head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.2
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.13.0.10
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.8
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.6
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2016.04.24.17.21.55;	author matthieu;	state Exp;
branches;
next	1.19;
commitid	4OIv6RoaEtHUOCtM;

1.19
date	2016.04.24.17.20.04;	author matthieu;	state Exp;
branches;
next	1.18;
commitid	XzcCr4xyQiQF4fIY;

1.18
date	2016.04.02.14.25.10;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	PbNjzNxfwpZTQYDj;

1.17
date	2016.03.06.17.11.47;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	vJ21xJXyutpDZ0GD;

1.16
date	2016.03.06.16.09.27;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	jrN0Aedz5AXRZ3u9;

1.15
date	2015.10.25.15.24.06;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	PiFoKHOeXNbWPoHj;

1.14
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	Te1daavkBLskZ8gc;

1.13
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.06.21.21.52;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.08.29.17.58.28;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.31.17.47.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Fix white space/indentation to match X.Org style.
@
text
@/*
 * Copyright 1992 by Rich Murphey <Rich@@Rice.edu>
 * Copyright 1993 by David Wexelblat <dwex@@goblin.org>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the names of Rich Murphey and David Wexelblat
 * not be used in advertising or publicity pertaining to distribution of
 * the software without specific, written prior permission.  Rich Murphey and
 * David Wexelblat make no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without express or
 * implied warranty.
 *
 * RICH MURPHEY AND DAVID WEXELBLAT DISCLAIM ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL RICH MURPHEY OR DAVID WEXELBLAT BE LIABLE FOR
 * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
 * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>

#include "compiler.h"

#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"
#include "osdep.h"

#include <sys/utsname.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>
#ifdef X_PRIVSEP
#include "os.h"
#include <pwd.h>
#endif
#include <stdlib.h>
#include <errno.h>

static Bool KeepTty = FALSE;

#ifdef PCCONS_SUPPORT
static int devConsoleFd = -1;
#endif
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT) \
    || defined(WSCONS_SUPPORT)
static int VTnum = -1;
static int initialVT = -1;
#endif

#ifdef PCCONS_SUPPORT
/* Stock 0.1 386bsd pccons console driver interface */
#define PCCONS_CONSOLE_DEV1 "/dev/ttyv0"
#define PCCONS_CONSOLE_DEV2 "/dev/vga"
#define PCCONS_CONSOLE_MODE O_RDWR|O_NDELAY
#endif

#ifdef SYSCONS_SUPPORT
/* The FreeBSD 1.1 version syscons driver uses /dev/ttyv0 */
#define SYSCONS_CONSOLE_DEV1 "/dev/ttyv0"
#define SYSCONS_CONSOLE_DEV2 "/dev/vga"
#define SYSCONS_CONSOLE_MODE O_RDWR|O_NDELAY
#endif

#ifdef PCVT_SUPPORT
/* Hellmuth Michaelis' pcvt driver */
#define PCVT_CONSOLE_DEV "/dev/ttyv0"
#define PCVT_CONSOLE_MODE O_RDWR|O_NDELAY
#endif

#ifdef WSCONS_SUPPORT
static Bool hasVT = FALSE;      /* has VT support ? */
#endif

#if defined(WSCONS_SUPPORT) && defined(__NetBSD__)
/* NetBSD's new console driver */
#define WSCONS_PCVT_COMPAT_CONSOLE_DEV "/dev/ttyE0"
#endif

#ifdef __GLIBC__
#define setpgrp setpgid
#endif

#define CHECK_DRIVER_MSG \
  "Check your kernel's console driver configuration and /dev entries"

static const char *supported_drivers[] = {
#ifdef PCCONS_SUPPORT
    "pccons (with X support)",
#endif
#ifdef SYSCONS_SUPPORT
    "syscons",
#endif
#ifdef PCVT_SUPPORT
    "pcvt",
#endif
#ifdef WSCONS_SUPPORT
    "wscons",
#endif
};

/*
 * Functions to probe for the existance of a supported console driver.
 * Any function returns either a valid file descriptor (driver probed
 * succesfully), -1 (driver not found), or uses FatalError() if the
 * driver was found but proved to not support the required mode to run
 * an X server.
 */

typedef int (*xf86ConsOpen_t) (void);

#ifdef PCCONS_SUPPORT
static int xf86OpenPccons(void);
#endif                          /* PCCONS_SUPPORT */

#ifdef SYSCONS_SUPPORT
static int xf86OpenSyscons(void);
#endif                          /* SYSCONS_SUPPORT */

#ifdef PCVT_SUPPORT
static int xf86OpenPcvt(void);
#endif                          /* PCVT_SUPPORT */

#ifdef WSCONS_SUPPORT
static int xf86OpenWScons(void);
#endif

/*
 * The sequence of the driver probes is important; start with the
 * driver that is best distinguishable, and end with the most generic
 * driver.  (Otherwise, pcvt would also probe as syscons, and either
 * pcvt or syscons might succesfully probe as pccons.)
 */
static xf86ConsOpen_t xf86ConsTab[] = {
#ifdef WSCONS_SUPPORT
    xf86OpenWScons,
#endif
#ifdef PCVT_SUPPORT
    xf86OpenPcvt,
#endif
#ifdef SYSCONS_SUPPORT
    xf86OpenSyscons,
#endif
#ifdef PCCONS_SUPPORT
    xf86OpenPccons,
#endif
    (xf86ConsOpen_t) NULL
};

void
xf86OpenConsole(void)
{
    int i, fd = -1;
    xf86ConsOpen_t *driver;

#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT) \
    || defined(WSCONS_SUPPORT)
    int result;

#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
    struct utsname uts;
#endif
    vtmode_t vtmode;
#endif
#ifdef WSCONS_SUPPORT
    int mode;
#endif

    if (xf86Info.consoleFd != -1) {
        return;
    }
    if (serverGeneration == 1) {
        /* check if we are run with euid==0 */
        if (geteuid() != 0 && issetugid()) {
            FatalError("xf86OpenConsole: Server must either be suid root"
                       " or without privileges at all");
        }

        if (!KeepTty) {
            /*
             * detaching the controlling tty solves problems of kbd character
             * loss.  This is not interesting for CO driver, because it is
             * exclusive.
             */
            setpgrp(0, getpid());
            if ((i = open("/dev/tty",O_RDWR)) >= 0) {
                ioctl(i,TIOCNOTTY,(char *)0);
                close(i);
            }
        }

        /* detect which driver we are running on */
        for (driver = xf86ConsTab; *driver; driver++) {
            if ((fd = (*driver)()) >= 0)
                break;
        }

        /* Check that a supported console driver was found */
        if (fd < 0) {
            char cons_drivers[80] = {0, };
            for (i = 0; i < sizeof(supported_drivers) / sizeof(char *); i++) {
                if (i) {
                    strcat(cons_drivers, ", ");
                }
                strcat(cons_drivers, supported_drivers[i]);
            }
            FatalError(
                "%s: No console driver found\n\tSupported drivers: %s\n\t%s",
                "xf86OpenConsole", cons_drivers, CHECK_DRIVER_MSG);
        }
        xf86Info.consoleFd = fd;

        switch (xf86Info.consType) {
#ifdef PCCONS_SUPPORT
        case PCCONS:
            if (ioctl(xf86Info.consoleFd, CONSOLE_X_MODE_ON, 0) < 0) {
                FatalError("%s: CONSOLE_X_MODE_ON failed (%s)\n%s",
                           "xf86OpenConsole", strerror(errno),
                           CHECK_DRIVER_MSG);
            }
            /*
             * Hack to prevent keyboard hanging when syslogd closes
             * /dev/console
             */
            if ((devConsoleFd = open("/dev/console", O_WRONLY, 0)) < 0) {
                xf86Msg(X_WARNING,
                        "xf86OpenConsole: couldn't open /dev/console (%s)\n",
                        strerror(errno));
            }
            break;
#endif
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
        case SYSCONS:
            /* as of FreeBSD 2.2.8, syscons driver does not need the #1 vt
             * switching anymore. Here we check for FreeBSD 3.1 and up.
             * Add cases for other *BSD that behave the same.
             */
#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
            uname(&uts);
            i = atof(uts.release) * 100;
            if (i >= 310)
                goto acquire_vt;
#endif
            /* otherwise fall through */
        case PCVT:
#if !(defined(__NetBSD__) && (__NetBSD_Version__ >= 200000000))
            /*
             * First activate the #1 VT.  This is a hack to allow a server
             * to be started while another one is active.  There should be
             * a better way.
             */
            if (initialVT != 1) {

                if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, 1) != 0) {
                    xf86Msg(X_WARNING,
                            "xf86OpenConsole: VT_ACTIVATE failed\n");
                }
                sleep(1);
            }
#endif
#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
acquire_vt:
#endif
            if (!xf86Info.ShareVTs) {
                /*
                 * now get the VT
                 */
                SYSCALL(result =
                        ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno));
                if (result != 0) {
                    xf86Msg(X_WARNING, "xf86OpenConsole: VT_ACTIVATE failed\n");
                }
                SYSCALL(result =
                        ioctl(xf86Info.consoleFd, VT_WAITACTIVE, xf86Info.vtno));
                if (result != 0) {
                    xf86Msg(X_WARNING, "xf86OpenConsole: VT_WAITACTIVE failed\n");
                }

                signal(SIGUSR2, xf86VTRequest);

                vtmode.mode = VT_PROCESS;
                vtmode.relsig = SIGUSR2;
                vtmode.acqsig = SIGUSR2;
                vtmode.frsig = SIGUSR2;
                if (ioctl(xf86Info.consoleFd, VT_SETMODE, &vtmode) < 0) {
                    FatalError("xf86OpenConsole: VT_SETMODE VT_PROCESS failed");
                }
#if !defined(__OpenBSD__) && !defined(USE_DEV_IO) && !defined(USE_I386_IOPL)
                if (ioctl(xf86Info.consoleFd, KDENABIO, 0) < 0) {
                    FatalError("xf86OpenConsole: KDENABIO failed (%s)",
                               strerror(errno));
                }
#endif
                if (ioctl(xf86Info.consoleFd, KDSETMODE, KD_GRAPHICS) < 0) {
                    FatalError("xf86OpenConsole: KDSETMODE KD_GRAPHICS failed");
                }
            }
            else { /* xf86Info.ShareVTs */
                close(xf86Info.consoleFd);
            }
            break;
#endif /* SYSCONS_SUPPORT || PCVT_SUPPORT */
#ifdef WSCONS_SUPPORT
          case WSCONS:

            if (hasVT) {
                /* now get the VT */
                SYSCALL(result =
                        ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno));
                if (result != 0) {
                    xf86Msg(X_WARNING, "xf86OpenConsole: VT_ACTIVATE %d failed\n", xf86Info.vtno);
                }
                SYSCALL(result =
                        ioctl(xf86Info.consoleFd, VT_WAITACTIVE, xf86Info.vtno));
                if (result != 0) {
                    xf86Msg(X_WARNING, "xf86OpenConsole: VT_WAITACTIVE failed\n");
                }

                signal(SIGUSR2, xf86VTRequest);

                vtmode.mode = VT_PROCESS;
                vtmode.relsig = SIGUSR2;
                vtmode.acqsig = SIGUSR2;
                vtmode.frsig = SIGUSR2;
                if (ioctl(xf86Info.consoleFd, VT_SETMODE, &vtmode) < 0) {
                    FatalError("xf86OpenConsole: VT_SETMODE VT_PROCESS failed");
                }
            }
            mode = WSDISPLAYIO_MODE_MAPPED;
            if (ioctl(fd, WSDISPLAYIO_SMODE, &mode) < 0) {
                FatalError("%s: WSDISPLAYIO_MODE_MAPPED failed (%s)\n%s",
                           "xf86OpenConsole", strerror(errno),
                           CHECK_DRIVER_MSG);
            }
            break;
#endif
        }
    } else {
        /* serverGeneration != 1 */
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
        if (!xf86Info.ShareVTs &&
            (xf86Info.consType == SYSCONS || xf86Info.consType == PCVT)) {
            if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno) != 0) {
                xf86Msg(X_WARNING, "xf86OpenConsole: VT_ACTIVATE failed\n");
            }
        }
#endif                          /* SYSCONS_SUPPORT || PCVT_SUPPORT */
    }
    return;
}

#ifdef PCCONS_SUPPORT

static int
xf86OpenPccons(void)
{
    int fd = -1;

    if ((fd = open(PCCONS_CONSOLE_DEV1, PCCONS_CONSOLE_MODE, 0))
        >= 0 || (fd = open(PCCONS_CONSOLE_DEV2, PCCONS_CONSOLE_MODE, 0))
        >= 0) {
        if (ioctl(fd, CONSOLE_X_MODE_OFF, 0) < 0) {
            FatalError("%s: CONSOLE_X_MODE_OFF failed (%s)\n%s\n%s",
                       "xf86OpenPccons",
                       strerror(errno),
                       "Was expecting pccons driver with X support",
                       CHECK_DRIVER_MSG);
        }
        xf86Info.consType = PCCONS;
        xf86Msg(X_PROBED, "Using pccons driver with X support\n");
    }
    return fd;
}

#endif                          /* PCCONS_SUPPORT */

#ifdef SYSCONS_SUPPORT

static int
xf86OpenSyscons(void)
{
    int fd = -1;
    vtmode_t vtmode;
    char vtname[12];
    long syscons_version;
    MessageType from;

    /* Check for syscons */
    if ((fd = open(SYSCONS_CONSOLE_DEV1, SYSCONS_CONSOLE_MODE, 0)) >= 0
        || (fd = open(SYSCONS_CONSOLE_DEV2, SYSCONS_CONSOLE_MODE, 0)) >= 0) {
        if (ioctl(fd, VT_GETMODE, &vtmode) >= 0) {
            /* Get syscons version */
            if (ioctl(fd, CONS_GETVERS, &syscons_version) < 0) {
                syscons_version = 0;
            }

            xf86Info.vtno = VTnum;
            from = X_CMDLINE;

#ifdef VT_GETACTIVE
            if (ioctl(fd, VT_GETACTIVE, &initialVT) < 0)
                initialVT = -1;
#endif
            if (xf86Info.ShareVTs)
                xf86Info.vtno = initialVT;

            if (xf86Info.vtno == -1) {
                /*
                 * For old syscons versions (<0x100), VT_OPENQRY returns
                 * the current VT rather than the next free VT.  In this
                 * case, the server gets started on the current VT instead
                 * of the next free VT.
                 */

#if 0
                /* check for the fixed VT_OPENQRY */
                if (syscons_version >= 0x100) {
#endif
                    if (ioctl(fd, VT_OPENQRY, &xf86Info.vtno) < 0) {
                        /* No free VTs */
                        xf86Info.vtno = -1;
                    }
#if 0
            }
#endif

                if (xf86Info.vtno == -1) {
                    /*
                     * All VTs are in use.  If initialVT was found, use it.
                     */
                    if (initialVT != -1) {
                        xf86Info.vtno = initialVT;
                    }
                    else {
                        if (syscons_version >= 0x100) {
                            FatalError("%s: Cannot find a free VT",
                                       "xf86OpenSyscons");
                        }
                        /* Should no longer reach here */
                        FatalError("%s: %s %s\n\t%s %s",
                                   "xf86OpenSyscons",
                                   "syscons versions prior to 1.0 require",
                                   "either the",
                                   "server's stdin be a VT",
                                   "or the use of the vtxx server option");
                    }
                }
                from = X_PROBED;
            }

            close(fd);
#ifndef __OpenBSD__
            snprintf(vtname, sizeof(vtname), "/dev/ttyv%01x", xf86Info.vtno - 1);
#else
            sprintf(vtname, sizeof(vtname), "/dev/ttyC%01x", xf86Info.vtno - 1);
#endif
            if ((fd = open(vtname, SYSCONS_CONSOLE_MODE, 0)) < 0) {
                FatalError("xf86OpenSyscons: Cannot open %s (%s)",
                           vtname, strerror(errno));
            }
            if (ioctl(fd, VT_GETMODE, &vtmode) < 0) {
                FatalError("xf86OpenSyscons: VT_GETMODE failed");
            }
            xf86Info.consType = SYSCONS;
            xf86Msg(X_PROBED, "Using syscons driver with X support");
            if (syscons_version >= 0x100) {
                xf86ErrorF(" (version %ld.%ld)\n", syscons_version >> 8,
                           syscons_version & 0xFF);
            }
            else {
                xf86ErrorF(" (version 0.x)\n");
            }
            xf86Msg(from, "using VT number %d\n\n", xf86Info.vtno);
        }
        else {
            /* VT_GETMODE failed, probably not syscons */
            close(fd);
            fd = -1;
        }
    }
    return fd;
}

#endif                          /* SYSCONS_SUPPORT */

#ifdef PCVT_SUPPORT

static int
xf86OpenPcvt(void)
{
    /* This looks much like syscons, since pcvt is API compatible */
    int fd = -1;
    vtmode_t vtmode;
    char vtname[12];
    const char *vtprefix;
    struct pcvtid pcvt_version;

#ifndef __OpenBSD__
    vtprefix = "/dev/ttyv";
#else
    vtprefix = "/dev/ttyC";
#endif

    if (VTnum != -1) {
            snprintf(vtname, sizeof(vtname), "%s%x", vtprefix, VTnum - 1);
            fd  = open(vtname, PCVT_CONSOLE_MODE, 0);
    }
    else {
            fd = open(PCVT_CONSOLE_DEV, PCVT_CONSOLE_MODE, 0);
    }
#ifdef WSCONS_PCVT_COMPAT_CONSOLE_DEV
    if (fd < 0) {
        fd = open(WSCONS_PCVT_COMPAT_CONSOLE_DEV, PCVT_CONSOLE_MODE, 0);
        vtprefix = "/dev/ttyE";
    }
#endif
    if (fd >= 0) {
        if (ioctl(fd, VGAPCVTID, &pcvt_version) >= 0) {
            if(ioctl(fd, VT_GETMODE, &vtmode) < 0) {
                FatalError("%s: VT_GETMODE failed\n%s%s\n%s",
                           "xf86OpenPcvt",
                           "Found pcvt driver but X11 seems to be",
                           " not supported.", CHECK_DRIVER_MSG);
            }

            xf86Info.vtno = VTnum;

            if (ioctl(fd, VT_GETACTIVE, &initialVT) < 0)
                initialVT = -1;

            if (xf86Info.vtno == -1) {
                if (ioctl(fd, VT_OPENQRY, &xf86Info.vtno) < 0) {
                    /* No free VTs */
                    xf86Info.vtno = -1;
                }

                if (xf86Info.vtno == -1) {
                    /*
                     * All VTs are in use.  If initialVT was found, use it.
                     */
                    if (initialVT != -1) {
                        xf86Info.vtno = initialVT;
                    }
                    else {
                        FatalError("%s: Cannot find a free VT",
                                   "xf86OpenPcvt");
                    }
                }
            }

            close(fd);
            snprintf(vtname, sizeof(vtname), "%s%01x", vtprefix, xf86Info.vtno - 1);
            if ((fd = open(vtname, PCVT_CONSOLE_MODE, 0)) < 0) {
                ErrorF("xf86OpenPcvt: Cannot open %s (%s)",
                       vtname, strerror(errno));
                xf86Info.vtno = initialVT;
                snprintf(vtname, sizeof(vtname), "%s%01x", vtprefix, xf86Info.vtno - 1);
                if ((fd = open(vtname, PCVT_CONSOLE_MODE, 0)) < 0) {
                    FatalError("xf86OpenPcvt: Cannot open %s (%s)",
                                vtname, strerror(errno));
                }
            }
            if (ioctl(fd, VT_GETMODE, &vtmode) < 0) {
                FatalError("xf86OpenPcvt: VT_GETMODE failed");
            }
            xf86Info.consType = PCVT;
#ifdef WSCONS_SUPPORT
            xf86Msg(X_PROBED,
                    "Using wscons driver on %s in pcvt compatibility mode "
                    "(version %d.%d)\n", vtname,
                    pcvt_version.rmajor, pcvt_version.rminor);
#else
            xf86Msg(X_PROBED, "Using pcvt driver (version %d.%d)\n",
                    pcvt_version.rmajor, pcvt_version.rminor);
#endif
        }
        else {
            /* Not pcvt */
            close(fd);
            fd = -1;
        }
    }
    return fd;
}

#endif                          /* PCVT_SUPPORT */

#ifdef WSCONS_SUPPORT

static int
xf86OpenWScons(void)
{
    char vtname[16], vtprefix[16];
    char *p;
    int mib[2];
    int fd = -1;
    int i;
    size_t len;
    dev_t dev;
    vtmode_t vtmode;

    if (xf86Info.ShareVTs)
        FatalError("-sharevt is not supported with wscons\n");

    /* default value if probing the console device fails */
    snprintf(vtprefix, sizeof(vtprefix), "/dev/ttyC");

    /* probe console device - it my be /dev/ttyD0 on some multi-heads setups */
    mib[0] = CTL_KERN;
    mib[1] = KERN_CONSDEV;
    len = sizeof(dev);
    if (sysctl(mib, 2, &dev, &len, NULL, 0) != -1) {
        snprintf(vtname, sizeof(vtname), "/dev/%s", devname(dev, S_IFCHR));
	if ((fd = open(vtname, O_RDWR)) != -1) {
	    if (ioctl(fd, WSDISPLAYIO_GTYPE, &i) == 0) {
                /* console is a wsdisplay(4) device */
                strlcpy(vtprefix, vtname, sizeof(vtprefix));
                /* strip number, assuming 0 */
                p = strchr(vtprefix, '0');
                *p = '\0';
	        close(fd);
		fd = -1;
	    }
	}
    }
    if (VTnum != -1) {
        snprintf(vtname, sizeof(vtname), "%s%01x", vtprefix, VTnum - 1);
        xf86Info.vtno = VTnum;
    } else {
        snprintf(vtname, sizeof(vtname), "%s0", vtprefix);
    }
    fd = open(vtname, O_RDWR);
    if (fd == -1)
        return fd;

    /* Check if USL VTs are supported */
    if (ioctl(fd, VT_GETACTIVE, &initialVT) < 0) {
        if (errno == ENOTTY) {
            /* double-check that this is a wsdisplay screeen */
	    if (ioctl(fd, WSDISPLAYIO_GTYPE, &i) == -1) {
	        close(fd);
		return -1;
	    }
            /* NO VTs */
            initialVT = 1;
            hasVT = FALSE;
        } else {
            close(fd);
            return -1;
        }
    } else {
        hasVT = TRUE;
        /* find a free VT */
        if (xf86Info.vtno == -1) {
            if (ioctl(fd, VT_OPENQRY, &xf86Info.vtno) < 0) {
                /* All VTs are in use.  If initialVT was found, use it. */
                if (initialVT != -1)
                    xf86Info.vtno = initialVT;
                else
                    FatalError("xf86OpenWScons: Cannot find a free VT");
            }
            /* re-open the new VT */
            close(fd);
            snprintf(vtname, sizeof(vtname), "%s%01x", vtprefix,
                     xf86Info.vtno - 1);
            if ((fd = open(vtname, O_RDWR)) < 0)
                FatalError("xf86OpenWScons: cannot open %s (%s)",
                           vtname, strerror(errno));
        }
    }
    xf86Info.consType = WSCONS;
    xf86Msg(X_PROBED, "Using wscons driver on %s\n", vtname);
    return fd;
}
#endif                          /* WSCONS_SUPPORT */

void
xf86CloseConsole(void)
{
#if defined(SYSCONS_SUPPORT) || defined(PCVT_SUPPORT)
    struct vt_mode VT;
#endif

    if (xf86Info.ShareVTs)
        return;

    switch (xf86Info.consType) {
#ifdef PCCONS_SUPPORT
    case PCCONS:
        ioctl(xf86Info.consoleFd, CONSOLE_X_MODE_OFF, 0);
        break;
#endif                          /* PCCONS_SUPPORT */
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
    case SYSCONS:
    case PCVT:
        ioctl(xf86Info.consoleFd, KDSETMODE, KD_TEXT);  /* Back to text mode */
        if (ioctl(xf86Info.consoleFd, VT_GETMODE, &VT) != -1) {
            VT.mode = VT_AUTO;
            ioctl(xf86Info.consoleFd, VT_SETMODE, &VT); /* dflt vt handling */
        }
#if !defined(__OpenBSD__) && !defined(USE_DEV_IO) && !defined(USE_I386_IOPL)
        if (ioctl(xf86Info.consoleFd, KDDISABIO, 0) < 0) {
            xf86FatalError("xf86CloseConsole: KDDISABIO failed (%s)",
                           strerror(errno));
        }
#endif
        if (initialVT != -1)
            ioctl(xf86Info.consoleFd, VT_ACTIVATE, initialVT);
        break;
#endif                          /* SYSCONS_SUPPORT || PCVT_SUPPORT */
#ifdef WSCONS_SUPPORT
    case WSCONS:
    {
        int mode = WSDISPLAYIO_MODE_EMUL;

        ioctl(xf86Info.consoleFd, WSDISPLAYIO_SMODE, &mode);
        if (initialVT != -1 && hasVT)
            ioctl(xf86Info.consoleFd, VT_ACTIVATE, initialVT);

        break;
    }
#endif
    }

    close(xf86Info.consoleFd);
#ifdef X_PRIVSEP
    xf86Info.consoleFd = -1;
#endif
#ifdef PCCONS_SUPPORT
    if (devConsoleFd >= 0)
        close(devConsoleFd);
#endif
    return;
}

int
xf86ProcessArgument(int argc, char *argv[], int i)
{
    /*
     * Keep server from detaching from controlling tty.  This is useful
     * when debugging (so the server can receive keyboard signals.
     */
    if (!strcmp(argv[i], "-keeptty")) {
        KeepTty = TRUE;
        return 1;
    }
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT) \
        || defined(WSCONS_SUPPORT)
    if ((argv[i][0] == 'v') && (argv[i][1] == 't')) {
        if (sscanf(argv[i], "vt%2d", &VTnum) == 0 || VTnum < 1 || VTnum > 12) {
            UseMsg();
            VTnum = -1;
            return 0;
        }
        return 1;
    }
#endif	/* SYSCONS_SUPPORT || PCVT_SUPPORT ||WSCONS_SUPPRT */
    return 0;
}

void
xf86UseMsg(void)
{
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT) \
    || defined(WSCONS_SUPPORT)
    ErrorF("vtXX                   use the specified VT number (1-12)\n");
#endif                          /* SYSCONS_SUPPORT || PCVT_SUPPORT */
    ErrorF("-keeptty               ");
    ErrorF("don't detach controlling tty (for debugging only)\n");
    return;
}

#ifdef X_PRIVSEP
/*
 * Revoke privileges after init.
 * If the X server is started as root (xdm case), then switch to _x11
 * if it exists.
 * Otherwise use the real uid.
 */
void
xf86DropPriv(void)
{
    struct passwd *pw;
    
    /* revoke privileges */
    if (getuid() == 0) {
        /* Running as root */
        pw = getpwnam("_x11");
        if (!pw)
            return;
        /* give away lock file to unpriviledged user */
        if (ChownLock(pw->pw_uid, pw->pw_gid) == -1) {
            FatalError("Chown Lock");
        }
        
        /* Start privileged child */
        if (priv_init(pw->pw_uid, pw->pw_gid) == -1) {
            FatalError("priv_init");
        }
    }
    else {
        /* Normal user */
        if (priv_init(getuid(), getgid()) == -1) {
            FatalError("priv_init");
        }
    }
}
#endif
@


1.19
log
@Fall back to /dev/ttyC0 when the console device is not a wsdisplay(4)

Problem noticed by sthen@@.
@
text
@d257 5
a261 5
	     * First activate the #1 VT.  This is a hack to allow a server
	     * to be started while another one is active.  There should be
	     * a better way.
	     */
	    if (initialVT != 1) {
d263 2
a264 2
		if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, 1) != 0) {
		    xf86Msg(X_WARNING,
d266 3
a268 3
		}
		sleep(1);
	    }
d273 1
a273 1
	    if (!xf86Info.ShareVTs) {
d289 1
a289 1
                
d306 1
a306 1
	    }
d309 2
a310 2
	    }
  	    break;
d435 8
a442 8
                
		if (xf86Info.vtno == -1) {
		    /*
		     * All VTs are in use.  If initialVT was found, use it.
		     */
		    if (initialVT != -1) {
			xf86Info.vtno = initialVT;
		    }
d444 17
a460 17
			if (syscons_version >= 0x100) {
			    FatalError("%s: Cannot find a free VT",
				       "xf86OpenSyscons");
			}
			/* Should no longer reach here */
			FatalError("%s: %s %s\n\t%s %s",
				   "xf86OpenSyscons",
				   "syscons versions prior to 1.0 require",
				   "either the",
				   "server's stdin be a VT",
				   "or the use of the vtxx server option");
		    }
		}
		from = X_PROBED;
	    }
            
	    close(fd);
d462 1
a462 1
	    snprintf(vtname, sizeof(vtname), "/dev/ttyv%01x", xf86Info.vtno - 1);
d464 1
a464 1
	    sprintf(vtname, sizeof(vtname), "/dev/ttyC%01x", xf86Info.vtno - 1);
d466 13
a478 13
	    if ((fd = open(vtname, SYSCONS_CONSOLE_MODE, 0)) < 0) {
		FatalError("xf86OpenSyscons: Cannot open %s (%s)",
			   vtname, strerror(errno));
	    }
	    if (ioctl(fd, VT_GETMODE, &vtmode) < 0) {
		FatalError("xf86OpenSyscons: VT_GETMODE failed");
	    }
	    xf86Info.consType = SYSCONS;
	    xf86Msg(X_PROBED, "Using syscons driver with X support");
	    if (syscons_version >= 0x100) {
		xf86ErrorF(" (version %ld.%ld)\n", syscons_version >> 8,
			   syscons_version & 0xFF);
	    }
d480 4
a483 4
		xf86ErrorF(" (version 0.x)\n");
	    }
	    xf86Msg(from, "using VT number %d\n\n", xf86Info.vtno);
	}
d485 4
a488 4
	    /* VT_GETMODE failed, probably not syscons */
	    close(fd);
	    fd = -1;
	}
d514 3
a516 3
	    snprintf(vtname, sizeof(vtname), "%s%x", vtprefix, VTnum - 1);
	    fd  = open(vtname, PCVT_CONSOLE_MODE, 0);
    } 
d518 1
a518 1
	    fd = open(PCVT_CONSOLE_DEV, PCVT_CONSOLE_MODE, 0);
d527 26
a552 26
	if (ioctl(fd, VGAPCVTID, &pcvt_version) >= 0) {
	    if(ioctl(fd, VT_GETMODE, &vtmode) < 0) {
		FatalError("%s: VT_GETMODE failed\n%s%s\n%s",
			   "xf86OpenPcvt",
			   "Found pcvt driver but X11 seems to be",
			   " not supported.", CHECK_DRIVER_MSG);
	    }
            
	    xf86Info.vtno = VTnum;
            
	    if (ioctl(fd, VT_GETACTIVE, &initialVT) < 0)
		initialVT = -1;

	    if (xf86Info.vtno == -1) {
		if (ioctl(fd, VT_OPENQRY, &xf86Info.vtno) < 0) {
		    /* No free VTs */
		    xf86Info.vtno = -1;
		}
                
		if (xf86Info.vtno == -1) {
		    /*
		     * All VTs are in use.  If initialVT was found, use it.
		     */
		    if (initialVT != -1) {
			xf86Info.vtno = initialVT;
		    }
d554 5
a558 5
			FatalError("%s: Cannot find a free VT",
				   "xf86OpenPcvt");
		    }
		}
	    }
d560 1
a560 1
	    close(fd);
d562 2
a563 2
	    if ((fd = open(vtname, PCVT_CONSOLE_MODE, 0)) < 0) {
		ErrorF("xf86OpenPcvt: Cannot open %s (%s)",
d565 3
a567 3
		xf86Info.vtno = initialVT;
	        snprintf(vtname, sizeof(vtname), "%s%01x", vtprefix, xf86Info.vtno - 1);
		if ((fd = open(vtname, PCVT_CONSOLE_MODE, 0)) < 0) {
d569 7
a575 7
			   	vtname, strerror(errno));
		}
	    }
	    if (ioctl(fd, VT_GETMODE, &vtmode) < 0) {
		FatalError("xf86OpenPcvt: VT_GETMODE failed");
	    }
	    xf86Info.consType = PCVT;
d792 24
a815 24
	struct passwd *pw;

	/* revoke privileges */
	if (getuid() == 0) {
		/* Running as root */
		pw = getpwnam("_x11");
		if (!pw)
			return;
		/* give away lock file to unpriviledged user */
		if (ChownLock(pw->pw_uid, pw->pw_gid) == -1) {
			FatalError("Chown Lock");
		}

		/* Start privileged child */
		if (priv_init(pw->pw_uid, pw->pw_gid) == -1) {
			FatalError("priv_init");
		}
	}
        else {
		/* Normal user */
		if (priv_init(getuid(), getgid()) == -1) {
			FatalError("priv_init");
		}
	}
@


1.18
log
@Implement VT switching (based on the USL compat interface) in the
wscons console backend and use it by default.
ok kettenis@@
@
text
@d614 4
d622 13
a634 7
        snprintf(vtprefix, sizeof(vtprefix), "/dev/%s", devname(dev, S_IFCHR));
        /* strip number, assuming 0 */
        p = strchr(vtprefix, '0');
        *p = '\0';
    } else
        snprintf(vtprefix, sizeof(vtprefix), "/dev/ttyC");

@


1.17
log
@Cleanup gcc warnings and function prototypes.
@
text
@d54 2
a55 1
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
a75 1
#ifndef __OpenBSD__
d77 1
a77 2
#else
#define PCVT_CONSOLE_DEV "/dev/ttyC0"
d79 3
a81 1
#define PCVT_CONSOLE_MODE O_RDWR|O_NDELAY
d144 3
a155 3
#ifdef WSCONS_SUPPORT
    xf86OpenWScons,
#endif
d165 2
a166 1
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
d174 3
d314 31
a344 2
	    /* Nothing to do */
   	    break;
d347 2
a348 3
    }
    else {
	/* serverGeneration != 1 */
d602 3
a605 1
    int mode = WSDISPLAYIO_MODE_MAPPED;
a606 2
    char vtname[16];
    int mib[2];
d609 4
a613 1
#ifdef KERN_CONSDEV
d618 21
a638 2
	snprintf(vtname, sizeof(vtname), "/dev/%s", devname(dev, S_IFCHR));
	if ((fd = open(vtname, 2)) != -1) {
d641 1
a641 1
		fd = -1;
d643 25
a667 18
	}
    }
#endif
    if (fd == -1) {
	for (i = 0; i < 8; i++) {
#if defined(__NetBSD__)
	    snprintf(vtname, sizeof(vtname), "/dev/ttyE%d", i);
#elif defined(__OpenBSD__)
	    snprintf(vtname,  sizeof(vtname), "/dev/ttyC%x", i);
#endif
	    if ((fd = open(vtname, 2)) != -1)
		break;
        }
    }
    if (fd != -1) {
        if (ioctl(fd, WSDISPLAYIO_SMODE, &mode) < 0) {
            FatalError("%s: WSDISPLAYIO_MODE_MAPPED failed (%s)\n%s",
                       "xf86OpenConsole", strerror(errno), CHECK_DRIVER_MSG);
a668 2
        xf86Info.consType = WSCONS;
        xf86Msg(X_PROBED, "Using wscons driver\n");
d670 2
a673 1

d716 3
d746 2
a747 1
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
d756 1
a756 1
#endif                          /* SYSCONS_SUPPORT || PCVT_SUPPORT */
d763 2
a764 1
#if defined (SYSCONS_SUPPORT) || defined (PCVT_SUPPORT)
@


1.16
log
@Fix typo introduced 5.5 years ago.

Note: this changes the #if test result, but the now #ifdef out code
has no effect.
@
text
@d37 1
d95 1
a95 1
static char *supported_drivers[] = {
d159 1
a159 1
xf86OpenConsole()
d265 1
d267 1
d331 1
a331 1
xf86OpenPccons()
d356 1
a356 1
xf86OpenSyscons()
d465 1
a465 1
xf86OpenPcvt()
d470 2
a471 1
    char vtname[12], *vtprefix;
d567 1
a567 1
xf86OpenWScons()
d572 1
a572 1
    char ttyname[16];
d582 2
a583 2
	snprintf(ttyname, sizeof(ttyname), "/dev/%s", devname(dev, S_IFCHR));
	if ((fd = open(ttyname, 2)) != -1) {
d594 1
a594 1
	    snprintf(ttyname, sizeof(ttyname), "/dev/ttyE%d", i);
d596 1
a596 1
	    snprintf(ttyname,  sizeof(ttyname), "/dev/ttyC%x", i);
d598 1
a598 1
	    if ((fd = open(ttyname, 2)) != -1)
d616 1
a616 1
xf86CloseConsole()
d696 1
a696 1
xf86UseMsg()
d714 1
a714 1
xf86DropPriv(char *disp)
@


1.15
log
@Reduce white space diff with upstreams. No other change.
@
text
@d289 1
a289 1
#if !defined(__0penBSD__) && !defined(USE_DEV_IO) && !defined(USE_I386_IOPL)
@


1.14
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d176 3
a178 3
	/* check if we are run with euid==0 */
	if (geteuid() != 0 && issetugid()) {
	    FatalError("xf86OpenConsole: Server must either be suid root"
d180 37
a216 37
	}
        
	if (!KeepTty) {
	    /*
	     * detaching the controlling tty solves problems of kbd character
	     * loss.  This is not interesting for CO driver, because it is
	     * exclusive.
	     */
	    setpgrp(0, getpid());
	    if ((i = open("/dev/tty",O_RDWR)) >= 0) {
		ioctl(i,TIOCNOTTY,(char *)0);
		close(i);
	    }
	}
        
	/* detect which driver we are running on */
	for (driver = xf86ConsTab; *driver; driver++) {
	    if ((fd = (*driver)()) >= 0)
		break;
	}
        
	/* Check that a supported console driver was found */
	if (fd < 0) {
	    char cons_drivers[80] = {0, };
	    for (i = 0; i < sizeof(supported_drivers) / sizeof(char *); i++) {
		if (i) {
		    strcat(cons_drivers, ", ");
		}
		strcat(cons_drivers, supported_drivers[i]);
	    }
	    FatalError(
		"%s: No console driver found\n\tSupported drivers: %s\n\t%s",
		"xf86OpenConsole", cons_drivers, CHECK_DRIVER_MSG);
	}
	xf86Info.consoleFd = fd;
        
	switch (xf86Info.consType) {
@


1.13
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d671 1
a671 1
     * Keep server from detaching from controlling tty.  This is useful 
@


1.12
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d50 1
d52 1
a108 1

d117 1
a117 1
typedef int (*xf86ConsOpen_t)(void);
d121 1
a121 1
#endif /* PCCONS_SUPPORT */
d125 1
a125 1
#endif /* SYSCONS_SUPPORT */
d129 1
a129 1
#endif /* PCVT_SUPPORT */
d154 1
a154 1
    (xf86ConsOpen_t)NULL
a156 1

d162 1
d165 1
d176 3
a178 3
        /* check if we are run with euid==0 */
        if (geteuid() != 0 && issetugid()) {
            FatalError("xf86OpenConsole: Server must either be suid root"
d180 37
a216 37
        }

        if (!KeepTty) {
            /*
             * detaching the controlling tty solves problems of kbd character
             * loss.  This is not interesting for CO driver, because it is
             * exclusive.
             */
            setpgrp(0, getpid());
            if ((i = open("/dev/tty",O_RDWR)) >= 0) {
                ioctl(i,TIOCNOTTY,(char *)0);
                close(i);
            }
        }

        /* detect which driver we are running on */
        for (driver = xf86ConsTab; *driver; driver++) {
            if ((fd = (*driver)()) >= 0)
                break;
        }

        /* Check that a supported console driver was found */
        if (fd < 0) {
            char cons_drivers[80] = {0, };
            for (i = 0; i < sizeof(supported_drivers) / sizeof(char *); i++) {
                if (i) {
                    strcat(cons_drivers, ", ");
                }
                strcat(cons_drivers, supported_drivers[i]);
            }
            FatalError
                ("%s: No console driver found\n\tSupported drivers: %s\n\t%s",
                 "xf86OpenConsole", cons_drivers, CHECK_DRIVER_MSG);
        }
        xf86Info.consoleFd = fd;

        switch (xf86Info.consType) {
d219 1
a219 1
            if (ioctl (xf86Info.consoleFd, CONSOLE_X_MODE_ON, 0) < 0) {
d228 1
a228 1
            if ((devConsoleFd = open("/dev/console", O_WRONLY,0)) < 0) {
d240 1
a240 1
            */
d242 1
a242 1
            uname (&uts);
d244 2
a245 1
            if (i >= 310) goto acquire_vt;
d251 5
a255 5
             * First activate the #1 VT.  This is a hack to allow a server
             * to be started while another one is active.  There should be
             * a better way.
             */
            if (initialVT != 1) {
d257 2
a258 2
                if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, 1) != 0) {
                    xf86Msg(X_WARNING,
d260 3
a262 3
                }
                sleep(1);
            }
d265 1
a265 1
            if (!xf86Info.ShareVTs) {
d281 1
a281 1

d298 1
a298 1
            }
d301 2
a302 2
            }
            break;
d305 3
a307 3
        case WSCONS:
            /* Nothing to do */
            break;
d312 1
a312 1
        /* serverGeneration != 1 */
d320 1
a320 1
#endif /* SYSCONS_SUPPORT || PCVT_SUPPORT */
a324 1

d333 1
a333 2
        >= 0 ||
        (fd = open(PCCONS_CONSOLE_DEV2, PCCONS_CONSOLE_MODE, 0))
d336 5
a340 6
            FatalError(
                "%s: CONSOLE_X_MODE_OFF failed (%s)\n%s\n%s",
                "xf86OpenPccons",
                strerror(errno),
                "Was expecting pccons driver with X support",
                CHECK_DRIVER_MSG);
d348 1
a348 1
#endif /* PCCONS_SUPPORT */
d397 1
a397 1
                }
d399 8
a406 8

                if (xf86Info.vtno == -1) {
                    /*
                     * All VTs are in use.  If initialVT was found, use it.
                     */
                    if (initialVT != -1) {
                        xf86Info.vtno = initialVT;
                    }
d408 17
a424 17
                        if (syscons_version >= 0x100) {
                            FatalError("%s: Cannot find a free VT",
                                       "xf86OpenSyscons");
                        }
                        /* Should no longer reach here */
                        FatalError("%s: %s %s\n\t%s %s",
                                   "xf86OpenSyscons",
                                   "syscons versions prior to 1.0 require",
                                   "either the",
                                   "server's stdin be a VT",
                                   "or the use of the vtxx server option");
                    }
                }
                from = X_PROBED;
            }

            close(fd);
d426 1
a426 1
            snprintf(vtname, sizeof(vtname), "/dev/ttyv%01x", xf86Info.vtno - 1);
d428 1
a428 1
            sprintf(vtname, sizeof(vtname), "/dev/ttyC%01x", xf86Info.vtno - 1);
d430 13
a442 13
            if ((fd = open(vtname, SYSCONS_CONSOLE_MODE, 0)) < 0) {
                FatalError("xf86OpenSyscons: Cannot open %s (%s)",
                           vtname, strerror(errno));
            }
            if (ioctl(fd, VT_GETMODE, &vtmode) < 0) {
                FatalError("xf86OpenSyscons: VT_GETMODE failed");
            }
            xf86Info.consType = SYSCONS;
            xf86Msg(X_PROBED, "Using syscons driver with X support");
            if (syscons_version >= 0x100) {
                xf86ErrorF(" (version %ld.%ld)\n", syscons_version >> 8,
                           syscons_version & 0xFF);
            }
d444 4
a447 4
                xf86ErrorF(" (version 0.x)\n");
            }
            xf86Msg(from, "using VT number %d\n\n", xf86Info.vtno);
        }
d449 4
a452 4
            /* VT_GETMODE failed, probably not syscons */
            close(fd);
            fd = -1;
        }
d457 1
a457 2
#endif /* SYSCONS_SUPPORT */

d477 3
a479 3
            snprintf(vtname, sizeof(vtname), "%s%x", vtprefix, VTnum - 1);
            fd  = open(vtname, PCVT_CONSOLE_MODE, 0);
    }
d481 1
a481 1
        fd = open(PCVT_CONSOLE_DEV, PCVT_CONSOLE_MODE, 0);
d490 26
a515 26
        if (ioctl(fd, VGAPCVTID, &pcvt_version) >= 0) {
            if(ioctl(fd, VT_GETMODE, &vtmode) < 0) {
                FatalError("%s: VT_GETMODE failed\n%s%s\n%s",
                           "xf86OpenPcvt",
                           "Found pcvt driver but X11 seems to be",
                           " not supported.", CHECK_DRIVER_MSG);
            }

            xf86Info.vtno = VTnum;

            if (ioctl(fd, VT_GETACTIVE, &initialVT) < 0)
                initialVT = -1;

            if (xf86Info.vtno == -1) {
                if (ioctl(fd, VT_OPENQRY, &xf86Info.vtno) < 0) {
                    /* No free VTs */
                    xf86Info.vtno = -1;
                }

                if (xf86Info.vtno == -1) {
                    /*
                     * All VTs are in use.  If initialVT was found, use it.
                     */
                    if (initialVT != -1) {
                        xf86Info.vtno = initialVT;
                    }
d517 5
a521 5
                        FatalError("%s: Cannot find a free VT",
                                   "xf86OpenPcvt");
                    }
                }
            }
d523 1
a523 1
            close(fd);
d525 14
a538 14
            if ((fd = open(vtname, PCVT_CONSOLE_MODE, 0)) < 0) {
                ErrorF("xf86OpenPcvt: Cannot open %s (%s)",
                           vtname, strerror(errno));
                xf86Info.vtno = initialVT;
                snprintf(vtname, sizeof(vtname), "%s%01x", vtprefix, xf86Info.vtno - 1);
                if ((fd = open(vtname, PCVT_CONSOLE_MODE, 0)) < 0) {
                        FatalError("xf86OpenPcvt: Cannot open %s (%s)",
                                vtname, strerror(errno));
                }
            }
            if (ioctl(fd, VT_GETMODE, &vtmode) < 0) {
                FatalError("xf86OpenPcvt: VT_GETMODE failed");
            }
            xf86Info.consType = PCVT;
d558 1
a558 1
#endif /* PCVT_SUPPORT */
d578 7
a584 7
        snprintf(ttyname, sizeof(ttyname), "/dev/%s", devname(dev, S_IFCHR));
        if ((fd = open(ttyname, 2)) != -1) {
            if (ioctl(fd, WSDISPLAYIO_GTYPE, &i) == -1) {
                close(fd);
                fd = -1;
            }
        }
d588 1
a588 1
        for (i = 0; i < 8; i++) {
d590 1
a590 1
            snprintf(ttyname, sizeof(ttyname), "/dev/ttyE%d", i);
d592 1
a592 1
            snprintf(ttyname,  sizeof(ttyname), "/dev/ttyC%x", i);
d594 2
a595 2
            if ((fd = open(ttyname, 2)) != -1)
                break;
d601 1
a601 2
                       "xf86OpenConsole", strerror(errno),
                       CHECK_DRIVER_MSG);
d609 1
a609 1
#endif /* WSCONS_SUPPORT */
d615 1
a615 1
    struct vt_mode   VT;
d618 2
a619 1
    if (xf86Info.ShareVTs) return;
d624 1
a624 1
        ioctl (xf86Info.consoleFd, CONSOLE_X_MODE_OFF, 0);
d626 1
a626 1
#endif /* PCCONS_SUPPORT */
d635 1
a635 1
#if !defined(OpenBSD) && !defined(USE_DEV_IO) && !defined(USE_I386_IOPL)
d644 1
a644 1
#endif /* SYSCONS_SUPPORT || PCVT_SUPPORT */
d646 2
a647 1
    case WSCONS: {
d649 1
d652 1
a652 1
      }
d671 1
a671 1
     * Keep server from detaching from controlling tty.  This is useful
d680 1
a680 2
        if (sscanf(argv[i], "vt%2d", &VTnum) == 0 ||
            VTnum < 1 || VTnum > 12) {
d687 1
a687 1
#endif /* SYSCONS_SUPPORT || PCVT_SUPPORT */
d696 1
a696 1
#endif /* SYSCONS_SUPPORT || PCVT_SUPPORT */
d712 1
a712 1
    struct passwd *pw;
d714 22
a735 22
    /* revoke privileges */
    if (getuid() == 0) {
        /* Running as root */
        pw = getpwnam("_x11");
        if (!pw)
            return;
        /* give away lock file to unpriviledged user */
        if (ChownLock(pw->pw_uid, pw->pw_gid) == -1) {
            FatalError("Chown Lock");
        }

        /* Start privileged child */
        if (priv_init(pw->pw_uid, pw->pw_gid) == -1) {
            FatalError("priv_init");
        }
    }
    else {
        /* Normal user */
        if (priv_init(getuid(), getgid()) == -1) {
            FatalError("priv_init");
        }
    }
@


1.11
log
@Update to xserver 1.11.2
@
text
@d9 2
a10 2
 * documentation, and that the names of Rich Murphey and David Wexelblat 
 * not be used in advertising or publicity pertaining to distribution of 
d12 2
a13 2
 * David Wexelblat make no representations about the suitability of this 
 * software for any purpose.  It is provided "as is" without express or 
d16 6
a21 6
 * RICH MURPHEY AND DAVID WEXELBLAT DISCLAIM ALL WARRANTIES WITH REGARD TO 
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND 
 * FITNESS, IN NO EVENT SHALL RICH MURPHEY OR DAVID WEXELBLAT BE LIABLE FOR 
 * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER 
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF 
 * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
d49 1
a53 1
static Bool ShareVTs = FALSE;
d73 1
a73 1
#  define PCVT_CONSOLE_DEV "/dev/ttyv0"
d75 1
a75 1
#  define PCVT_CONSOLE_DEV "/dev/ttyC0"
d94 1
a94 1
	"pccons (with X support)",
d97 1
a97 1
	"syscons",
d100 1
a100 1
	"pcvt",
d103 1
a103 1
	"wscons",
d169 1
a169 1
    
d171 1
a171 1
	    return;
d173 40
a212 52
    if (serverGeneration == 1)
    {
	/* check if we are run with euid==0 */
	if (geteuid() != 0 && issetugid())
	{
	    FatalError("xf86OpenConsole: Server must either be suid root"
			" or without privileges at all");
	}

	if (!KeepTty)
	{
	    /*
	     * detaching the controlling tty solves problems of kbd character
	     * loss.  This is not interesting for CO driver, because it is 
	     * exclusive.
	     */
	    setpgrp(0, getpid());
	    if ((i = open("/dev/tty",O_RDWR)) >= 0)
	    {
		ioctl(i,TIOCNOTTY,(char *)0);
		close(i);
	    }
	}

	/* detect which driver we are running on */
	for (driver = xf86ConsTab; *driver; driver++)
	{
	    if ((fd = (*driver)()) >= 0)
		break;
	}

	/* Check that a supported console driver was found */
	if (fd < 0)
	{
	    char cons_drivers[80] = {0, };
	    for (i = 0; i < sizeof(supported_drivers) / sizeof(char *); i++)
	    {
		if (i)
		{
		    strcat(cons_drivers, ", ");
		}
		strcat(cons_drivers, supported_drivers[i]);
	    }
	    FatalError(
		"%s: No console driver found\n\tSupported drivers: %s\n\t%s",
		"xf86OpenConsole", cons_drivers, CHECK_DRIVER_MSG);
	}
#if 0 /* stdin is already closed in OsInit() */
	fclose(stdin);
#endif
	xf86Info.consoleFd = fd;
	xf86Info.screenFd = fd;
d214 1
a214 2
	switch (xf86Info.consType)
	{
d216 16
a231 18
	case PCCONS:
	    if (ioctl (xf86Info.consoleFd, CONSOLE_X_MODE_ON, 0) < 0)
	    {
		FatalError("%s: CONSOLE_X_MODE_ON failed (%s)\n%s",
			   "xf86OpenConsole", strerror(errno),
			   CHECK_DRIVER_MSG);
	    }
	    /*
	     * Hack to prevent keyboard hanging when syslogd closes
	     * /dev/console
	     */
	    if ((devConsoleFd = open("/dev/console", O_WRONLY,0)) < 0)
	    {
		xf86Msg(X_WARNING,
			"xf86OpenConsole: couldn't open /dev/console (%s)\n",
			strerror(errno));
	    }
	    break;
d234 5
a238 5
	case SYSCONS:
	    /* as of FreeBSD 2.2.8, syscons driver does not need the #1 vt
	     * switching anymore. Here we check for FreeBSD 3.1 and up.
	     * Add cases for other *BSD that behave the same.
	    */
d240 3
a242 3
	    uname (&uts);
	    i = atof(uts.release) * 100;
	    if (i >= 310) goto acquire_vt;
d244 2
a245 2
	    /* otherwise fall through */
	case PCVT:
d247 13
a259 14
	    /*
	     * First activate the #1 VT.  This is a hack to allow a server
	     * to be started while another one is active.  There should be
	     * a better way.
	     */
	    if (initialVT != 1) {

		if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, 1) != 0)
		{
		    xf86Msg(X_WARNING,
				"xf86OpenConsole: VT_ACTIVATE failed\n");
		}
		sleep(1);
	    }
d262 24
a285 27
	    if (!ShareVTs) {
		    /*
		     * now get the VT
		     */
		    SYSCALL(result =
			    ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno));
		    if (result != 0)
		    {
			xf86Msg(X_WARNING, "xf86OpenConsole: VT_ACTIVATE failed\n");
		    }
		    SYSCALL(result =
		    ioctl(xf86Info.consoleFd, VT_WAITACTIVE, xf86Info.vtno));
		    if (result != 0)
		    {
			xf86Msg(X_WARNING, "xf86OpenConsole: VT_WAITACTIVE failed\n");
		    }

		    signal(SIGUSR2, xf86VTRequest);

		    vtmode.mode = VT_PROCESS;
		    vtmode.relsig = SIGUSR2;
		    vtmode.acqsig = SIGUSR2;
		    vtmode.frsig = SIGUSR2;
		    if (ioctl(xf86Info.consoleFd, VT_SETMODE, &vtmode) < 0) 
		    {
			FatalError("xf86OpenConsole: VT_SETMODE VT_PROCESS failed");
		    }
d287 13
a299 14
		    if (ioctl(xf86Info.consoleFd, KDENABIO, 0) < 0)
		    {
			FatalError("xf86OpenConsole: KDENABIO failed (%s)",
				   strerror(errno));
		    }
#endif
		    if (ioctl(xf86Info.consoleFd, KDSETMODE, KD_GRAPHICS) < 0)
		    {
			FatalError("xf86OpenConsole: KDSETMODE KD_GRAPHICS failed");
		    }
	    } else { /* ShareVTs */
		    close(xf86Info.consoleFd);
	    }	
  	    break; 
d302 3
a304 3
	case WSCONS:
	    /* Nothing to do */
   	    break; 
d308 2
a309 3
    else 
    {
	/* serverGeneration != 1 */
d311 5
a315 6
    	if (!ShareVTs) if (xf86Info.consType == SYSCONS || xf86Info.consType == PCVT)
    	{
	    if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno) != 0)
	    {
	        xf86Msg(X_WARNING, "xf86OpenConsole: VT_ACTIVATE failed\n");
	    }
d331 13
a343 15
	>= 0 ||
	(fd = open(PCCONS_CONSOLE_DEV2, PCCONS_CONSOLE_MODE, 0))
	>= 0)
    {
	if (ioctl(fd, CONSOLE_X_MODE_OFF, 0) < 0)
	{
	    FatalError(
		"%s: CONSOLE_X_MODE_OFF failed (%s)\n%s\n%s",
		"xf86OpenPccons",
		strerror(errno),
		"Was expecting pccons driver with X support",
		CHECK_DRIVER_MSG);
	}
	xf86Info.consType = PCCONS;
	xf86Msg(X_PROBED, "Using pccons driver with X support\n");
a357 1
    struct stat status;
d363 6
a368 9
	|| (fd = open(SYSCONS_CONSOLE_DEV2, SYSCONS_CONSOLE_MODE, 0)) >= 0)
    {
	if (ioctl(fd, VT_GETMODE, &vtmode) >= 0)
	{
	    /* Get syscons version */
	    if (ioctl(fd, CONS_GETVERS, &syscons_version) < 0)
	    {
		syscons_version = 0;
	    }
d370 2
a371 2
	    xf86Info.vtno = VTnum;
	    from = X_CMDLINE;
d374 2
a375 2
	    if (ioctl(fd, VT_GETACTIVE, &initialVT) < 0)
		initialVT = -1;
d377 2
a378 2
            if (ShareVTs)
		xf86Info.vtno = initialVT;
d380 7
a386 8
	    if (xf86Info.vtno == -1)
	    {
		/*
		 * For old syscons versions (<0x100), VT_OPENQRY returns
		 * the current VT rather than the next free VT.  In this
		 * case, the server gets started on the current VT instead
		 * of the next free VT.
		 */
d389 7
a395 9
		/* check for the fixed VT_OPENQRY */
		if (syscons_version >= 0x100)
		{
#endif
		    if (ioctl(fd, VT_OPENQRY, &xf86Info.vtno) < 0)
		    {
			/* No free VTs */
			xf86Info.vtno = -1;
		    }
d397 1
a397 1
		}
d400 23
a422 36
		if (xf86Info.vtno == -1)
		{
		    /*
		     * All VTs are in use.  If initialVT was found, use it.
		     * Otherwise, if stdin is a VT, use that one.
		     * XXX stdin is already closed, so this won't work.
		     */
		    if (initialVT != -1)
		    {
			xf86Info.vtno = initialVT;
		    }
		    else if ((fstat(0, &status) >= 0)
			     && S_ISCHR(status.st_mode)
			     && (ioctl(0, VT_GETMODE, &vtmode) >= 0))
		    {
			/* stdin is a VT */
			xf86Info.vtno = minor(status.st_rdev) + 1;
		    }
		    else
		    {
			if (syscons_version >= 0x100)
			{
			    FatalError("%s: Cannot find a free VT",
				       "xf86OpenSyscons");
			}
			/* Should no longer reach here */
			FatalError("%s: %s %s\n\t%s %s",
				   "xf86OpenSyscons",
				   "syscons versions prior to 1.0 require",
				   "either the",
				   "server's stdin be a VT",
				   "or the use of the vtxx server option");
		    }
		}
		from = X_PROBED;
	    }
d424 1
a424 1
	    close(fd);
d426 27
a452 32
	    sprintf(vtname, "/dev/ttyv%01x", xf86Info.vtno - 1);
#else 
	    sprintf(vtname, "/dev/ttyC%01x", xf86Info.vtno - 1);
#endif	    
	    if ((fd = open(vtname, SYSCONS_CONSOLE_MODE, 0)) < 0)
	    {
		FatalError("xf86OpenSyscons: Cannot open %s (%s)",
			   vtname, strerror(errno));
	    }
	    if (ioctl(fd, VT_GETMODE, &vtmode) < 0)
	    {
		FatalError("xf86OpenSyscons: VT_GETMODE failed");
	    }
	    xf86Info.consType = SYSCONS;
	    xf86Msg(X_PROBED, "Using syscons driver with X support");
	    if (syscons_version >= 0x100)
	    {
		xf86ErrorF(" (version %ld.%ld)\n", syscons_version >> 8,
			   syscons_version & 0xFF);
	    }
	    else
	    {
		xf86ErrorF(" (version 0.x)\n");
	    }
	    xf86Msg(from, "using VT number %d\n\n", xf86Info.vtno);
	}
	else
	{
	    /* VT_GETMODE failed, probably not syscons */
	    close(fd);
	    fd = -1;
	}
a468 1
    struct stat status;
d478 5
a482 4
	    snprintf(vtname, sizeof(vtname), "%s%x", vtprefix, VTnum - 1);
	    fd  = open(vtname, PCVT_CONSOLE_MODE, 0);
    } else {
	    fd = open(PCVT_CONSOLE_DEV, PCVT_CONSOLE_MODE, 0);
d485 55
a539 75
    if (fd < 0)
    {
	fd = open(WSCONS_PCVT_COMPAT_CONSOLE_DEV, PCVT_CONSOLE_MODE, 0);
	vtprefix = "/dev/ttyE";
    }
#endif
    if (fd >= 0) 
    {
	if (ioctl(fd, VGAPCVTID, &pcvt_version) >= 0)
	{
	    if(ioctl(fd, VT_GETMODE, &vtmode) < 0)
	    {
		FatalError("%s: VT_GETMODE failed\n%s%s\n%s",
			   "xf86OpenPcvt",
			   "Found pcvt driver but X11 seems to be",
			   " not supported.", CHECK_DRIVER_MSG);
	    }

	    xf86Info.vtno = VTnum;
		
	    if (ioctl(fd, VT_GETACTIVE, &initialVT) < 0)
		initialVT = -1;

	    if (xf86Info.vtno == -1)
	    {
		if (ioctl(fd, VT_OPENQRY, &xf86Info.vtno) < 0)
		{
		    /* No free VTs */
		    xf86Info.vtno = -1;
		}

		if (xf86Info.vtno == -1)
		{
		    /*
		     * All VTs are in use.  If initialVT was found, use it.
		     * Otherwise, if stdin is a VT, use that one.
		     * XXX stdin is already closed, so this won't work.
		     */
		    if (initialVT != -1)
		    {
			xf86Info.vtno = initialVT;
		    }
		    else if ((fstat(0, &status) >= 0)
			     && S_ISCHR(status.st_mode)
			     && (ioctl(0, VT_GETMODE, &vtmode) >= 0))
		    {
			/* stdin is a VT */
			xf86Info.vtno = minor(status.st_rdev) + 1;
		    }
		    else
		    {
			FatalError("%s: Cannot find a free VT",
				   "xf86OpenPcvt");
		    }
		}
	    }

	    close(fd);
            sprintf(vtname, "%s%01x", vtprefix, xf86Info.vtno - 1);
	    if ((fd = open(vtname, PCVT_CONSOLE_MODE, 0)) < 0)
	    {
		ErrorF("xf86OpenPcvt: Cannot open %s (%s)",
			   vtname, strerror(errno));
		xf86Info.vtno = initialVT;
	        sprintf(vtname, "%s%01x", vtprefix, xf86Info.vtno - 1);
		if ((fd = open(vtname, PCVT_CONSOLE_MODE, 0)) < 0) {
			FatalError("xf86OpenPcvt: Cannot open %s (%s)",
			   	vtname, strerror(errno));
		}
	    }
	    if (ioctl(fd, VT_GETMODE, &vtmode) < 0)
	    {
		FatalError("xf86OpenPcvt: VT_GETMODE failed");
	    }
	    xf86Info.consType = PCVT;
d541 4
a544 4
	    xf86Msg(X_PROBED,
		    "Using wscons driver on %s in pcvt compatibility mode "
		    "(version %d.%d)\n", vtname,
		    pcvt_version.rmajor, pcvt_version.rminor);
d546 2
a547 2
	    xf86Msg(X_PROBED, "Using pcvt driver (version %d.%d)\n",
		    pcvt_version.rmajor, pcvt_version.rminor);
d549 6
a554 7
	}
	else
	{
	    /* Not pcvt */
	    close(fd);
	    fd = -1;
	}
d579 7
a585 7
	snprintf(ttyname, sizeof(ttyname), "/dev/%s", devname(dev, S_IFCHR));
	if ((fd = open(ttyname, 2)) != -1) {
	    if (ioctl(fd, WSDISPLAYIO_GTYPE, &i) == -1) {
	        close(fd);
		fd = -1;
	    }
	}
d589 1
a589 1
	for (i = 0; i < 8; i++) {
d591 1
a591 1
	    sprintf(ttyname, "/dev/ttyE%d", i);
d593 1
a593 1
	    sprintf(ttyname, "/dev/ttyC%x", i);
d595 2
a596 2
	    if ((fd = open(ttyname, 2)) != -1)
		break;
d600 7
a606 7
	if (ioctl(fd, WSDISPLAYIO_SMODE, &mode) < 0) {
	    FatalError("%s: WSDISPLAYIO_MODE_MAPPED failed (%s)\n%s",
		       "xf86OpenConsole", strerror(errno),
		       CHECK_DRIVER_MSG);
	}
	xf86Info.consType = WSCONS;
	xf86Msg(X_PROBED, "Using wscons driver\n");
d620 1
a620 1
    if (ShareVTs) return;
d622 1
a622 2
    switch (xf86Info.consType)
    {
d625 2
a626 2
	ioctl (xf86Info.consoleFd, CONSOLE_X_MODE_OFF, 0);
	break;
d632 3
a634 4
        if (ioctl(xf86Info.consoleFd, VT_GETMODE, &VT) != -1)
        {
	    VT.mode = VT_AUTO;
	    ioctl(xf86Info.consoleFd, VT_SETMODE, &VT); /* dflt vt handling */
d637 1
a637 2
        if (ioctl(xf86Info.consoleFd, KDDISABIO, 0) < 0)
        {
d639 1
a639 1
	                   strerror(errno));
d642 2
a643 2
	if (initialVT != -1)
		ioctl(xf86Info.consoleFd, VT_ACTIVATE, initialVT);
d647 4
a650 5
    case WSCONS:
      {
	int mode = WSDISPLAYIO_MODE_EMUL;
	ioctl(xf86Info.screenFd, WSDISPLAYIO_SMODE, &mode);
	break;
a654 10
    if (xf86Info.screenFd != xf86Info.consoleFd)
    {
	close(xf86Info.screenFd);
	close(xf86Info.consoleFd);
	if ((xf86Info.consoleFd = open("/dev/console",O_RDONLY,0)) <0)
	{
	    xf86FatalError("xf86CloseConsole: Cannot open /dev/console (%s)",
			   strerror(errno));
	}
    }
d659 1
d661 2
a662 1
	close(devConsoleFd);
d669 8
a676 9
	/*
	 * Keep server from detaching from controlling tty.  This is useful 
	 * when debugging (so the server can receive keyboard signals.
	 */
	if (!strcmp(argv[i], "-keeptty"))
	{
		KeepTty = TRUE;
		return 1;
	}
d678 9
a686 16
	if (!strcmp(argv[i], "-sharevts"))
	{	
		ShareVTs = TRUE;
		return 1;
	}
	if ((argv[i][0] == 'v') && (argv[i][1] == 't'))
	{
		if (sscanf(argv[i], "vt%2d", &VTnum) == 0 ||
		    VTnum < 1 || VTnum > 12)
		{
			UseMsg();
			VTnum = -1;
			return 0;
		}
		return 1;
	}
d688 1
a688 1
	return 0;
d695 1
a695 2
	ErrorF("vtXX                   use the specified VT number (1-12)\n");
	ErrorF("-sharevts              share VTs with another X server\n");
d697 3
a699 3
	ErrorF("-keeptty               ");
	ErrorF("don't detach controlling tty (for debugging only)\n");
	return;
d705 1
a705 1
 * If the X server is started as root (xdm case), then switch to _x11 
d712 12
a723 1
	struct passwd *pw;
d725 11
a735 21
	/* revoke privileges */
	if (getuid() == 0) {
		/* Running as root */
		pw = getpwnam("_x11");
		if (!pw)
			return;
		/* give away lock file to unpriviledged user */
		if (ChownLock(pw->pw_uid, pw->pw_gid) == -1) {
			FatalError("Chown Lock");
		}
		
		/* Start privileged child */
		if (priv_init(pw->pw_uid, pw->pw_gid) == -1) {
			FatalError("priv_init");
		}
	} else {
		/* Normal user */
		if (priv_init(getuid(), getgid()) == -1) {
			FatalError("priv_init");
		}
	}
@


1.10
log
@Initialize len before passing it to sysctl(3).

ok matthieu@@
@
text
@d58 1
a58 5
#ifndef __OpenBSD__
#  define PCCONS_CONSOLE_DEV1 "/dev/ttyv0"
#else
#  define PCCONS_CONSOLE_DEV1 "/dev/ttyC0"
#endif
a639 1
#ifdef WSCONS_SUPPORT
a642 1
#endif
@


1.9
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d653 1
@


1.8
log
@Use the KERN_CONSDEV ioctl to figure out what the console device is and
attempt to open that first before trying /dev/ttyC[0-7].
This makes X autoconfiguration a tad bit more intuitive on machines
with multiple SBus or UPA framebuffers, where wsdisplay0 isn't the
console.  PCI framebuffers are still busted though.

ok matthieu@@
@
text
@d644 1
d648 1
d763 1
a763 1
		return(1);
d769 1
a769 1
		return(1);
d778 1
a778 1
			return(0);
d780 1
a780 1
		return(1);
d783 1
a783 1
	return(0);
@


1.7
log
@Fix X -keepPriv by calling xf86OpenConsole() early enough on architectures
that don't have a separate /dev/xf86. Problem noticed by kettenis@@ and krw@@
ok kettenis@@.
@
text
@d40 1
d644 19
a662 3

    /* XXX Is this ok? */
    for (i = 0; i < 8; i++) {
d664 1
a664 1
	sprintf(ttyname, "/dev/ttyE%d", i);
d666 1
a666 1
	sprintf(ttyname, "/dev/ttyC%x", i);
d668 3
a670 2
	if ((fd = open(ttyname, 2)) != -1)
	    break;
@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a172 1
#ifdef X_PRIVSEP
a175 1
#endif
@


1.5
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a281 1
#if defined(FreeBSD)
a282 1
#endif
a298 2
	    }
	    signal(SIGUSR2, xf86VTRequest);
d300 16
a315 14
	    vtmode.mode = VT_PROCESS;
	    vtmode.relsig = SIGUSR2;
	    vtmode.acqsig = SIGUSR2;
	    vtmode.frsig = SIGUSR2;
	    if (ioctl(xf86Info.consoleFd, VT_SETMODE, &vtmode) < 0) 
	    {
	        FatalError("xf86OpenConsole: VT_SETMODE VT_PROCESS failed");
	    }
#if !defined(OpenBSD) && !defined(USE_DEV_IO) && !defined(USE_I386_IOPL)
	    if (ioctl(xf86Info.consoleFd, KDENABIO, 0) < 0)
	    {
	        FatalError("xf86OpenConsole: KDENABIO failed (%s)",
		           strerror(errno));
	    }
d317 8
a324 5
	    if (ioctl(xf86Info.consoleFd, KDSETMODE, KD_GRAPHICS) < 0)
	    {
	        FatalError("xf86OpenConsole: KDSETMODE KD_GRAPHICS failed");
	    }
   	    break; 
d331 1
a331 1
	}
@


1.4
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d52 1
d282 1
d284 12
a295 10
	    /*
	     * now get the VT
	     */
	    SYSCALL(result =
		    ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno));
	    if (result != 0)
	    {
    	        xf86Msg(X_WARNING, "xf86OpenConsole: VT_ACTIVATE failed\n");
	    }
	    SYSCALL(result =
d297 4
a300 3
	    if (result != 0)
	    {
	        xf86Msg(X_WARNING, "xf86OpenConsole: VT_WAITACTIVE failed\n");
a301 1

d330 1
a330 1
        }
d336 1
a336 1
    	if (xf86Info.consType == SYSCONS || xf86Info.consType == PCVT)
d409 3
d676 2
d747 5
d772 1
@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@d166 1
d168 1
d265 1
d280 1
a280 1

@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@a24 1
/* $XConsortium: bsd_init.c /main/8 1996/10/23 13:13:05 kaleb $ */
@


1.1
log
@Initial revision
@
text
@d41 4
d171 5
d179 1
a179 1
	if (geteuid() != 0)
d181 2
a182 1
	    FatalError("xf86OpenConsole: Server must be suid root");
d296 1
a296 1
	    signal(SIGUSR1, xf86VTRequest);
d299 3
a301 3
	    vtmode.relsig = SIGUSR1;
	    vtmode.acqsig = SIGUSR1;
	    vtmode.frsig = SIGUSR1;
d306 1
a306 1
#if !defined(USE_DEV_IO) && !defined(USE_I386_IOPL)
d321 1
a321 2
	    fprintf(stderr, "xf86OpenConsole\n");
	    /* xf86Info.consoleFd = open("/dev/wskbd0", 0); */
d522 6
a527 1
    fd = open(PCVT_CONSOLE_DEV, PCVT_CONSOLE_MODE, 0);
d590 1
a590 1
		FatalError("xf86OpenPcvt: Cannot open %s (%s)",
d592 6
d606 2
a607 2
		    "Using wscons driver in pcvt compatibility mode "
		    "(version %d.%d)\n",
d641 1
a641 1
	sprintf(ttyname, "/dev/ttyC%d", i);
d683 1
a683 1
#if !defined(USE_DEV_IO) && !defined(USE_I386_IOPL)
d715 3
d761 36
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d25 1
@

