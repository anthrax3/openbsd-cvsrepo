head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	Te1daavkBLskZ8gc;

1.12
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2014.05.02.19.27.49;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.27;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.33;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.22;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright 1992 by Orest Zborowski <obz@@Kodak.com>
 * Copyright 1993 by David Wexelblat <dwex@@goblin.org>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the names of Orest Zborowski and David Wexelblat
 * not be used in advertising or publicity pertaining to distribution of
 * the software without specific, written prior permission.  Orest Zborowski
 * and David Wexelblat make no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without express or
 * implied warranty.
 *
 * OREST ZBOROWSKI AND DAVID WEXELBLAT DISCLAIMS ALL WARRANTIES WITH REGARD
 * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL OREST ZBOROWSKI OR DAVID WEXELBLAT BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <errno.h>
#include <string.h>

#include <X11/X.h>
#include "input.h"
#include "scrnintstr.h"

#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"
#include "xf86OSpriv.h"

static Bool ExtendedEnabled = FALSE;

#ifdef __ia64__

#include "compiler.h"
#include <sys/io.h>

#elif !defined(__powerpc__) && \
      !defined(__mc68000__) && \
      !defined(__sparc__) && \
      !defined(__mips__) && \
      !defined(__nds32__) && \
      !defined(__arm__) && \
      !defined(__aarch64__) && \
      !defined(__arc__) && \
      !defined(__xtensa__)

/*
 * Due to conflicts with "compiler.h", don't rely on <sys/io.h> to declare
 * these.
 */
extern int ioperm(unsigned long __from, unsigned long __num, int __turn_on);
extern int iopl(int __level);

#endif

/***************************************************************************/
/* Video Memory Mapping section                                            */
/***************************************************************************/

void
xf86OSInitVidMem(VidMemInfoPtr pVidMem)
{
    pVidMem->initialised = TRUE;
}

/***************************************************************************/
/* I/O Permissions section                                                 */
/***************************************************************************/

#if defined(__powerpc__)
volatile unsigned char *ioBase = NULL;

#ifndef __NR_pciconfig_iobase
#define __NR_pciconfig_iobase	200
#endif

static Bool
hwEnableIO(void)
{
    int fd;
    unsigned int ioBase_phys = syscall(__NR_pciconfig_iobase, 2, 0, 0);

    fd = open("/dev/mem", O_RDWR);
    if (ioBase == NULL) {
        ioBase = (volatile unsigned char *) mmap(0, 0x20000,
                                                 PROT_READ | PROT_WRITE,
                                                 MAP_SHARED, fd, ioBase_phys);
    }
    close(fd);

    return ioBase != MAP_FAILED;
}

static void
hwDisableIO(void)
{
    munmap(ioBase, 0x20000);
    ioBase = NULL;
}

#elif defined(__i386__) || defined(__x86_64__) || defined(__ia64__) || \
      defined(__alpha__)

static Bool
hwEnableIO(void)
{
    if (ioperm(0, 1024, 1) || iopl(3)) {
        ErrorF("xf86EnableIOPorts: failed to set IOPL for I/O (%s)\n",
               strerror(errno));
        return FALSE;
    }
#if !defined(__alpha__)
    /* XXX: this is actually not trapping anything because of iopl(3)
     * above */
    ioperm(0x40, 4, 0);         /* trap access to the timer chip */
    ioperm(0x60, 4, 0);         /* trap access to the keyboard controller */
#endif

    return TRUE;
}

static void
hwDisableIO(void)
{
    iopl(0);
    ioperm(0, 1024, 0);
}

#else /* non-IO architectures */

#define hwEnableIO() TRUE
#define hwDisableIO() do {} while (0)

#endif

Bool
xf86EnableIO(void)
{
    if (ExtendedEnabled)
        return TRUE;

    ExtendedEnabled = hwEnableIO();

    return ExtendedEnabled;
}

void
xf86DisableIO(void)
{
    if (!ExtendedEnabled)
        return;

    hwDisableIO();

    ExtendedEnabled = FALSE;
}

#if defined (__alpha__)

extern int readDense8(void *Base, register unsigned long Offset);
extern int readDense16(void *Base, register unsigned long Offset);
extern int readDense32(void *Base, register unsigned long Offset);
extern void
 writeDense8(int Value, void *Base, register unsigned long Offset);
extern void
 writeDense16(int Value, void *Base, register unsigned long Offset);
extern void
 writeDense32(int Value, void *Base, register unsigned long Offset);

void (*xf86WriteMmio8) (int Value, void *Base, unsigned long Offset)
    = writeDense8;
void (*xf86WriteMmio16) (int Value, void *Base, unsigned long Offset)
    = writeDense16;
void (*xf86WriteMmio32) (int Value, void *Base, unsigned long Offset)
    = writeDense32;
int (*xf86ReadMmio8) (void *Base, unsigned long Offset)
    = readDense8;
int (*xf86ReadMmio16) (void *Base, unsigned long Offset)
    = readDense16;
int (*xf86ReadMmio32) (void *Base, unsigned long Offset)
    = readDense32;

#endif                          /* __alpha__ */
@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a40 7
#ifdef __alpha__
#include "shared/xf86Axp.h"
#endif

#ifdef HAS_MTRR_SUPPORT
#include <asm/mtrr.h>
#endif
a67 6
#ifdef __alpha__
#define BUS_BASE bus_base
#else
#define BUS_BASE (0)
#endif                          /*  __alpha__ */

a71 277
static void *mapVidMem(int, unsigned long, unsigned long, int);
static void unmapVidMem(int, void *, unsigned long);

#if defined (__alpha__)
extern void sethae(unsigned long hae);
extern unsigned long _bus_base __P((void)) __attribute__ ((const));
extern unsigned long _bus_base_sparse __P((void)) __attribute__ ((const));

static void *mapVidMemSparse(int, unsigned long, unsigned long, int);
extern axpDevice lnxGetAXP(void);
static void unmapVidMemSparse(int, void *, unsigned long);
static axpDevice axpSystem = -1;
static Bool needSparse;
static unsigned long hae_thresh;
static unsigned long hae_mask;
static unsigned long bus_base;
#endif

#ifdef HAS_MTRR_SUPPORT

#define SPLIT_WC_REGIONS 1

static void *setWC(int, unsigned long, unsigned long, Bool, MessageType);
static void undoWC(int, void *);

/* The file desc for /proc/mtrr. Once opened, left opened, and the mtrr
   driver will clean up when we exit. */
#define MTRR_FD_UNOPENED (-1)   /* We have yet to open /proc/mtrr */
#define MTRR_FD_PROBLEM (-2)    /* We tried to open /proc/mtrr, but had
                                   a problem. */
static int mtrr_fd = MTRR_FD_UNOPENED;

/* Open /proc/mtrr. FALSE on failure. Will always fail on Linux 2.0, 
   and will fail on Linux 2.2 with MTRR support configured out,
   so verbosity should be chosen appropriately. */
static Bool
mtrr_open(int verbosity)
{
    /* Only report absence of /proc/mtrr once. */
    static Bool warned = FALSE;

    if (mtrr_fd == MTRR_FD_UNOPENED) {
        mtrr_fd = open("/proc/mtrr", O_WRONLY);

        if (mtrr_fd < 0)
            mtrr_fd = MTRR_FD_PROBLEM;
    }

    if (mtrr_fd == MTRR_FD_PROBLEM) {
        /* To make sure we only ever warn once, need to check
           verbosity outside xf86MsgVerb */
        if (!warned && verbosity <= xf86GetVerbosity()) {
            xf86MsgVerb(X_WARNING, verbosity,
                        "System lacks support for changing MTRRs\n");
            warned = TRUE;
        }

        return FALSE;
    }
    else
        return TRUE;
}

/*
 * We maintain a list of WC regions for each physical mapping so they can
 * be undone when unmapping.
 */

struct mtrr_wc_region {
    struct mtrr_sentry sentry;
    Bool added;                 /* added WC or removed it */
    struct mtrr_wc_region *next;
};

static struct mtrr_wc_region *
mtrr_cull_wc_region(int screenNum, unsigned long base, unsigned long size,
                    MessageType from)
{
    /* Some BIOS writers thought that setting wc over the mmio
       region of a graphics devices was a good idea. Try to fix
       it. */

    struct mtrr_gentry gent;
    struct mtrr_wc_region *wcreturn = NULL, *wcr;
    int count, ret = 0;

    /* Linux 2.0 users should not get a warning without -verbose */
    if (!mtrr_open(2))
        return NULL;

    for (gent.regnum = 0;
         ioctl(mtrr_fd, MTRRIOC_GET_ENTRY, &gent) >= 0; gent.regnum++) {
        if (gent.type != MTRR_TYPE_WRCOMB
            || gent.base + gent.size <= base || base + size <= gent.base)
            continue;

        /* Found an overlapping region. Delete it. */

        wcr = malloc(sizeof(*wcr));
        if (!wcr)
            return NULL;
        wcr->sentry.base = gent.base;
        wcr->sentry.size = gent.size;
        wcr->sentry.type = MTRR_TYPE_WRCOMB;
        wcr->added = FALSE;

        count = 3;
        while (count-- &&
               (ret = ioctl(mtrr_fd, MTRRIOC_KILL_ENTRY, &(wcr->sentry))) < 0);

        if (ret >= 0) {
            xf86DrvMsg(screenNum, from,
                       "Removed MMIO write-combining range "
                       "(0x%lx,0x%lx)\n",
                       (unsigned long) gent.base, (unsigned long) gent.size);
            wcr->next = wcreturn;
            wcreturn = wcr;
            gent.regnum--;
        }
        else {
            free(wcr);
            xf86DrvMsgVerb(screenNum, X_WARNING, 0,
                           "Failed to remove MMIO "
                           "write-combining range (0x%lx,0x%lx)\n",
                           (unsigned long)gent.base, (unsigned long) gent.size);
        }
    }
    return wcreturn;
}

static struct mtrr_wc_region *
mtrr_remove_offending(int screenNum, unsigned long base, unsigned long size,
                      MessageType from)
{
    struct mtrr_gentry gent;
    struct mtrr_wc_region *wcreturn = NULL, **wcr;

    if (!mtrr_open(2))
        return NULL;

    wcr = &wcreturn;
    for (gent.regnum = 0;
         ioctl(mtrr_fd, MTRRIOC_GET_ENTRY, &gent) >= 0; gent.regnum++) {
        if (gent.type == MTRR_TYPE_WRCOMB
            && ((gent.base >= base && gent.base + gent.size < base + size) ||
                (gent.base > base && gent.base + gent.size <= base + size))) {
            *wcr = mtrr_cull_wc_region(screenNum, gent.base, gent.size, from);
            if (*wcr)
                gent.regnum--;
            while (*wcr) {
                wcr = &((*wcr)->next);
            }
        }
    }
    return wcreturn;
}

static struct mtrr_wc_region *
mtrr_add_wc_region(int screenNum, unsigned long base, unsigned long size,
                   MessageType from)
{
    struct mtrr_wc_region **wcr, *wcreturn, *curwcr;

    /*
     * There can be only one....
     */

    wcreturn = mtrr_remove_offending(screenNum, base, size, from);
    wcr = &wcreturn;
    while (*wcr) {
        wcr = &((*wcr)->next);
    }

    /* Linux 2.0 should not warn, unless the user explicitly asks for
       WC. */

    if (!mtrr_open(from == X_CONFIG ? 0 : 2))
        return wcreturn;

    *wcr = curwcr = malloc(sizeof(**wcr));
    if (!curwcr)
        return wcreturn;

    curwcr->sentry.base = base;
    curwcr->sentry.size = size;
    curwcr->sentry.type = MTRR_TYPE_WRCOMB;
    curwcr->added = TRUE;
    curwcr->next = NULL;

#if SPLIT_WC_REGIONS
    /*
     * Splits up the write-combining region if it is not aligned on a
     * size boundary.
     */

    {
        unsigned long lbase, d_size = 1;
        unsigned long n_size = size;
        unsigned long n_base = base;

        for (lbase = n_base, d_size = 1; !(lbase & 1);
             lbase = lbase >> 1, d_size <<= 1);
        while (d_size > n_size)
            d_size = d_size >> 1;
        DebugF("WC_BASE: 0x%lx WC_END: 0x%lx\n", base, base + d_size - 1);
        n_base += d_size;
        n_size -= d_size;
        if (n_size) {
            xf86DrvMsgVerb(screenNum, X_INFO, 3, "Splitting WC range: "
                           "base: 0x%lx, size: 0x%lx\n", base, size);
            curwcr->next = mtrr_add_wc_region(screenNum, n_base, n_size, from);
        }
        curwcr->sentry.size = d_size;
    }

        /*****************************************************************/
#endif                          /* SPLIT_WC_REGIONS */

    if (ioctl(mtrr_fd, MTRRIOC_ADD_ENTRY, &curwcr->sentry) >= 0) {
        /* Avoid printing on every VT switch */
        if (xf86ServerIsInitialising()) {
            xf86DrvMsg(screenNum, from,
                       "Write-combining range (0x%lx,0x%lx)\n", base, size);
        }
        return wcreturn;
    }
    else {
        *wcr = curwcr->next;
        free(curwcr);

        /* Don't complain about the VGA region: MTRR fixed
           regions aren't currently supported, but might be in
           the future. */
        if ((unsigned long) base >= 0x100000) {
            xf86DrvMsgVerb(screenNum, X_WARNING, 0,
                           "Failed to set up write-combining range "
                           "(0x%lx,0x%lx)\n", base, size);
        }
        return wcreturn;
    }
}

static void
mtrr_undo_wc_region(int screenNum, struct mtrr_wc_region *wcr)
{
    struct mtrr_wc_region *p, *prev;

    if (mtrr_fd >= 0) {
        p = wcr;
        while (p) {
            if (p->added)
                ioctl(mtrr_fd, MTRRIOC_DEL_ENTRY, &p->sentry);
            prev = p;
            p = p->next;
            free(prev);
        }
    }
}

static void *
setWC(int screenNum, unsigned long base, unsigned long size, Bool enable,
      MessageType from)
{
    if (enable)
        return mtrr_add_wc_region(screenNum, base, size, from);
    else
        return mtrr_cull_wc_region(screenNum, base, size, from);
}

static void
undoWC(int screenNum, void *regioninfo)
{
    mtrr_undo_wc_region(screenNum, regioninfo);
}

#endif                          /* HAS_MTRR_SUPPORT */

a74 29
    pVidMem->linearSupported = TRUE;
#ifdef __alpha__
    if (axpSystem == -1) {
        axpSystem = lnxGetAXP();
        if ((needSparse = (_bus_base_sparse() > 0))) {
            hae_thresh = xf86AXPParams[axpSystem].hae_thresh;
            hae_mask = xf86AXPParams[axpSystem].hae_mask;
        }
        bus_base = _bus_base();
    }
    if (needSparse) {
        xf86Msg(X_INFO, "Machine needs sparse mapping\n");
        pVidMem->mapMem = mapVidMemSparse;
        pVidMem->unmapMem = unmapVidMemSparse;
    }
    else {
        xf86Msg(X_INFO, "Machine type has 8/16 bit access\n");
        pVidMem->mapMem = mapVidMem;
        pVidMem->unmapMem = unmapVidMem;
    }
#else
    pVidMem->mapMem = mapVidMem;
    pVidMem->unmapMem = unmapVidMem;
#endif                          /* __alpha__ */

#ifdef HAS_MTRR_SUPPORT
    pVidMem->setWC = setWC;
    pVidMem->undoWC = undoWC;
#endif
a77 77
#ifdef __sparc__
/* Basically, you simply cannot do this on Sparc.  You have to do something portable
 * like use /dev/fb* or mmap() on /proc/bus/pci/X/Y nodes. -DaveM
 */
static void *
mapVidMem(int ScreenNum, unsigned long Base, unsigned long Size, int flags)
{
    return NULL;
}
#else
static void *
mapVidMem(int ScreenNum, unsigned long Base, unsigned long Size, int flags)
{
    void *base;
    int fd;
    int mapflags = MAP_SHARED;
    int prot;
    memType realBase, alignOff;

    realBase = Base & ~(getpagesize() - 1);
    alignOff = Base - realBase;
    DebugF("base: %lx, realBase: %lx, alignOff: %lx \n",
           Base, realBase, alignOff);

#if defined(__ia64__) || defined(__arm__) || defined(__s390__)
#ifndef MAP_WRITECOMBINED
#define MAP_WRITECOMBINED 0x00010000
#endif
#ifndef MAP_NONCACHED
#define MAP_NONCACHED 0x00020000
#endif
    if (flags & VIDMEM_FRAMEBUFFER)
        mapflags |= MAP_WRITECOMBINED;
    else
        mapflags |= MAP_NONCACHED;
#endif

#if 0
    /* this will disappear when people upgrade their kernels */
    fd = open(DEV_MEM,
              ((flags & VIDMEM_READONLY) ? O_RDONLY : O_RDWR) | O_SYNC);
#else
    fd = open(DEV_MEM, (flags & VIDMEM_READONLY) ? O_RDONLY : O_RDWR);
#endif
    if (fd < 0) {
        FatalError("xf86MapVidMem: failed to open " DEV_MEM " (%s)\n",
                   strerror(errno));
    }

    if (flags & VIDMEM_READONLY)
        prot = PROT_READ;
    else
        prot = PROT_READ | PROT_WRITE;

    /* This requires linux-0.99.pl10 or above */
    base = mmap((caddr_t) 0, Size + alignOff, prot, mapflags, fd,
                (off_t) realBase + BUS_BASE);
    close(fd);
    if (base == MAP_FAILED) {
        FatalError("xf86MapVidMem: Could not mmap framebuffer"
                   " (0x%08lx,0x%lx) (%s)\n", Base, Size, strerror(errno));
    }
    DebugF("base: %lx aligned base: %lx\n", base, (char *) base + alignOff);
    return (char *) base + alignOff;
}
#endif                          /* !(__sparc__) */

static void
unmapVidMem(int ScreenNum, void *Base, unsigned long Size)
{
    uintptr_t alignOff = (uintptr_t) Base
        - ((uintptr_t) Base & ~(getpagesize() - 1));

    DebugF("alignment offset: %lx\n", (unsigned long) alignOff);
    munmap((void *) ((uintptr_t) Base - alignOff), (Size + alignOff));
}

a171 2
#define vuip    volatile unsigned int *

a175 6
 writeDenseNB8(int Value, void *Base, register unsigned long Offset);
extern void
 writeDenseNB16(int Value, void *Base, register unsigned long Offset);
extern void
 writeDenseNB32(int Value, void *Base, register unsigned long Offset);
extern void
a181 278
static int readSparse8(void *Base, register unsigned long Offset);
static int readSparse16(void *Base, register unsigned long Offset);
static int readSparse32(void *Base, register unsigned long Offset);
static void
 writeSparseNB8(int Value, void *Base, register unsigned long Offset);
static void
 writeSparseNB16(int Value, void *Base, register unsigned long Offset);
static void
 writeSparseNB32(int Value, void *Base, register unsigned long Offset);
static void
 writeSparse8(int Value, void *Base, register unsigned long Offset);
static void
 writeSparse16(int Value, void *Base, register unsigned long Offset);
static void
 writeSparse32(int Value, void *Base, register unsigned long Offset);

#define DENSE_BASE	0x2ff00000000UL
#define SPARSE_BASE	0x30000000000UL

static unsigned long msb_set = 0;

static void *
mapVidMemSparse(int ScreenNum, unsigned long Base, unsigned long Size,
                int flags)
{
    int fd, prot;
    unsigned long ret, rets = 0;

    static Bool was_here = FALSE;

    if (!was_here) {
        was_here = TRUE;

        xf86WriteMmio8 = writeSparse8;
        xf86WriteMmio16 = writeSparse16;
        xf86WriteMmio32 = writeSparse32;
        xf86WriteMmioNB8 = writeSparseNB8;
        xf86WriteMmioNB16 = writeSparseNB16;
        xf86WriteMmioNB32 = writeSparseNB32;
        xf86ReadMmio8 = readSparse8;
        xf86ReadMmio16 = readSparse16;
        xf86ReadMmio32 = readSparse32;
    }

    fd = open(DEV_MEM, (flags & VIDMEM_READONLY) ? O_RDONLY : O_RDWR);
    if (fd < 0) {
        FatalError("xf86MapVidMem: failed to open " DEV_MEM " (%s)\n",
                   strerror(errno));
    }

#if 0
    xf86Msg(X_INFO, "mapVidMemSparse: try Base 0x%lx size 0x%lx flags 0x%x\n",
            Base, Size, flags);
#endif

    if (flags & VIDMEM_READONLY)
        prot = PROT_READ;
    else
        prot = PROT_READ | PROT_WRITE;

    /* This requirers linux-0.99.pl10 or above */

    /*
     * Always do DENSE mmap, since read32/write32 currently require it.
     */
    ret = (unsigned long) mmap((caddr_t) (DENSE_BASE + Base), Size,
                               prot, MAP_SHARED, fd, (off_t) (bus_base + Base));

    /*
     * Do SPARSE mmap only when MMIO and not MMIO_32BIT, or FRAMEBUFFER
     * and SPARSE (which should require the use of read/write macros).
     *
     * By not SPARSE mmapping an 8MB framebuffer, we can save approx. 256K
     * bytes worth of pagetable (32 pages).
     */
    if (((flags & VIDMEM_MMIO) && !(flags & VIDMEM_MMIO_32BIT)) ||
        ((flags & VIDMEM_FRAMEBUFFER) && (flags & VIDMEM_SPARSE))) {
        rets = (unsigned long) mmap((caddr_t) (SPARSE_BASE + (Base << 5)),
                                    Size << 5, prot, MAP_SHARED, fd,
                                    (off_t) _bus_base_sparse() + (Base << 5));
    }

    close(fd);

    if (ret == (unsigned long) MAP_FAILED) {
        FatalError("xf86MapVidMemSparse: Could not (dense) mmap fb (%s)\n",
                   strerror(errno));
    }

    if (((flags & VIDMEM_MMIO) && !(flags & VIDMEM_MMIO_32BIT)) ||
        ((flags & VIDMEM_FRAMEBUFFER) && (flags & VIDMEM_SPARSE))) {
        if (rets == (unsigned long) MAP_FAILED ||
            rets != (SPARSE_BASE + (Base << 5))) {
            FatalError("mapVidMemSparse: Could not (sparse) mmap fb (%s)\n",
                       strerror(errno));
        }
    }

#if 1
    if (rets)
        xf86Msg(X_INFO, "mapVidMemSparse: mapped Base 0x%lx size 0x%lx"
                " to DENSE at 0x%lx and SPARSE at 0x%lx\n",
                Base, Size, ret, rets);
    else
        xf86Msg(X_INFO, "mapVidMemSparse: mapped Base 0x%lx size 0x%lx"
                " to DENSE only at 0x%lx\n", Base, Size, ret);

#endif
    return (void *) ret;
}

static void
unmapVidMemSparse(int ScreenNum, void *Base, unsigned long Size)
{
    unsigned long Offset = (unsigned long) Base - DENSE_BASE;

#if 1
    xf86Msg(X_INFO, "unmapVidMemSparse: unmapping Base 0x%lx Size 0x%lx\n",
            Base, Size);
#endif
    /* Unmap DENSE always. */
    munmap((caddr_t) Base, Size);

    /* Unmap SPARSE always, and ignore error in case we did not map it. */
    munmap((caddr_t) (SPARSE_BASE + (Offset << 5)), Size << 5);
}

static int
readSparse8(void *Base, register unsigned long Offset)
{
    register unsigned long result, shift;
    register unsigned long msb;

    mem_barrier();
    Offset += (unsigned long) Base - DENSE_BASE;
    shift = (Offset & 0x3) << 3;
    if (Offset >= (hae_thresh)) {
        msb = Offset & hae_mask;
        Offset -= msb;
        if (msb_set != msb) {
            sethae(msb);
            msb_set = msb;
        }
    }

    mem_barrier();
    result = *(vuip) (SPARSE_BASE + (Offset << 5));
    result >>= shift;
    return 0xffUL & result;
}

static int
readSparse16(void *Base, register unsigned long Offset)
{
    register unsigned long result, shift;
    register unsigned long msb;

    mem_barrier();
    Offset += (unsigned long) Base - DENSE_BASE;
    shift = (Offset & 0x2) << 3;
    if (Offset >= hae_thresh) {
        msb = Offset & hae_mask;
        Offset -= msb;
        if (msb_set != msb) {
            sethae(msb);
            msb_set = msb;
        }
    }

    mem_barrier();
    result = *(vuip) (SPARSE_BASE + (Offset << 5) + (1 << (5 - 2)));
    result >>= shift;
    return 0xffffUL & result;
}

static int
readSparse32(void *Base, register unsigned long Offset)
{
    /* NOTE: this is really using DENSE. */
    mem_barrier();
    return *(vuip) ((unsigned long) Base + (Offset));
}

static void
writeSparse8(int Value, void *Base, register unsigned long Offset)
{
    register unsigned long msb;
    register unsigned int b = Value & 0xffU;

    write_mem_barrier();
    Offset += (unsigned long) Base - DENSE_BASE;
    if (Offset >= hae_thresh) {
        msb = Offset & hae_mask;
        Offset -= msb;
        if (msb_set != msb) {
            sethae(msb);
            msb_set = msb;
        }
    }

    write_mem_barrier();
    *(vuip) (SPARSE_BASE + (Offset << 5)) = b * 0x01010101;
}

static void
writeSparse16(int Value, void *Base, register unsigned long Offset)
{
    register unsigned long msb;
    register unsigned int w = Value & 0xffffU;

    write_mem_barrier();
    Offset += (unsigned long) Base - DENSE_BASE;
    if (Offset >= hae_thresh) {
        msb = Offset & hae_mask;
        Offset -= msb;
        if (msb_set != msb) {
            sethae(msb);
            msb_set = msb;
        }
    }

    write_mem_barrier();
    *(vuip) (SPARSE_BASE + (Offset << 5) + (1 << (5 - 2))) = w * 0x00010001;
}

static void
writeSparse32(int Value, void *Base, register unsigned long Offset)
{
    /* NOTE: this is really using DENSE. */
    write_mem_barrier();
    *(vuip) ((unsigned long) Base + (Offset)) = Value;
    return;
}

static void
writeSparseNB8(int Value, void *Base, register unsigned long Offset)
{
    register unsigned long msb;
    register unsigned int b = Value & 0xffU;

    Offset += (unsigned long) Base - DENSE_BASE;
    if (Offset >= hae_thresh) {
        msb = Offset & hae_mask;
        Offset -= msb;
        if (msb_set != msb) {
            sethae(msb);
            msb_set = msb;
        }
    }
    *(vuip) (SPARSE_BASE + (Offset << 5)) = b * 0x01010101;
}

static void
writeSparseNB16(int Value, void *Base, register unsigned long Offset)
{
    register unsigned long msb;
    register unsigned int w = Value & 0xffffU;

    Offset += (unsigned long) Base - DENSE_BASE;
    if (Offset >= hae_thresh) {
        msb = Offset & hae_mask;
        Offset -= msb;
        if (msb_set != msb) {
            sethae(msb);
            msb_set = msb;
        }
    }
    *(vuip) (SPARSE_BASE + (Offset << 5) + (1 << (5 - 2))) = w * 0x00010001;
}

static void
writeSparseNB32(int Value, void *Base, register unsigned long Offset)
{
    /* NOTE: this is really using DENSE. */
    *(vuip) ((unsigned long) Base + (Offset)) = Value;
    return;
}

a187 6
void (*xf86WriteMmioNB8) (int Value, void *Base, unsigned long Offset)
    = writeDenseNB8;
void (*xf86WriteMmioNB16) (int Value, void *Base, unsigned long Offset)
    = writeDenseNB16;
void (*xf86WriteMmioNB32) (int Value, void *Base, unsigned long Offset)
    = writeDenseNB32;
@


1.11
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d62 3
a64 1
      !defined(__aarch64__)
d85 2
a86 2
static pointer mapVidMem(int, unsigned long, unsigned long, int);
static void unmapVidMem(int, pointer, unsigned long);
d93 1
a93 1
static pointer mapVidMemSparse(int, unsigned long, unsigned long, int);
d95 1
a95 1
static void unmapVidMemSparse(int, pointer, unsigned long);
d107 2
a108 2
static pointer setWC(int, unsigned long, unsigned long, Bool, MessageType);
static void undoWC(int, pointer);
d209 1
a209 1
                           gent.base, (unsigned long) gent.size);
d344 1
a344 1
static pointer
d355 1
a355 1
undoWC(int screenNum, pointer regioninfo)
d401 1
a401 1
static pointer
d407 1
a407 1
static pointer
d410 1
a410 1
    pointer base;
d465 1
a465 1
unmapVidMem(int ScreenNum, pointer Base, unsigned long Size)
d570 3
a572 3
extern int readDense8(pointer Base, register unsigned long Offset);
extern int readDense16(pointer Base, register unsigned long Offset);
extern int readDense32(pointer Base, register unsigned long Offset);
d574 1
a574 1
 writeDenseNB8(int Value, pointer Base, register unsigned long Offset);
d576 1
a576 1
 writeDenseNB16(int Value, pointer Base, register unsigned long Offset);
d578 1
a578 1
 writeDenseNB32(int Value, pointer Base, register unsigned long Offset);
d580 1
a580 1
 writeDense8(int Value, pointer Base, register unsigned long Offset);
d582 1
a582 1
 writeDense16(int Value, pointer Base, register unsigned long Offset);
d584 1
a584 1
 writeDense32(int Value, pointer Base, register unsigned long Offset);
d586 3
a588 3
static int readSparse8(pointer Base, register unsigned long Offset);
static int readSparse16(pointer Base, register unsigned long Offset);
static int readSparse32(pointer Base, register unsigned long Offset);
d590 1
a590 1
 writeSparseNB8(int Value, pointer Base, register unsigned long Offset);
d592 1
a592 1
 writeSparseNB16(int Value, pointer Base, register unsigned long Offset);
d594 1
a594 1
 writeSparseNB32(int Value, pointer Base, register unsigned long Offset);
d596 1
a596 1
 writeSparse8(int Value, pointer Base, register unsigned long Offset);
d598 1
a598 1
 writeSparse16(int Value, pointer Base, register unsigned long Offset);
d600 1
a600 1
 writeSparse32(int Value, pointer Base, register unsigned long Offset);
d607 1
a607 1
static pointer
d694 1
a694 1
    return (pointer) ret;
d698 1
a698 1
unmapVidMemSparse(int ScreenNum, pointer Base, unsigned long Size)
d714 1
a714 1
readSparse8(pointer Base, register unsigned long Offset)
d738 1
a738 1
readSparse16(pointer Base, register unsigned long Offset)
d762 1
a762 1
readSparse32(pointer Base, register unsigned long Offset)
d770 1
a770 1
writeSparse8(int Value, pointer Base, register unsigned long Offset)
d791 1
a791 1
writeSparse16(int Value, pointer Base, register unsigned long Offset)
d812 1
a812 1
writeSparse32(int Value, pointer Base, register unsigned long Offset)
d821 1
a821 1
writeSparseNB8(int Value, pointer Base, register unsigned long Offset)
d839 1
a839 1
writeSparseNB16(int Value, pointer Base, register unsigned long Offset)
d857 1
a857 1
writeSparseNB32(int Value, pointer Base, register unsigned long Offset)
d864 1
a864 1
void (*xf86WriteMmio8) (int Value, pointer Base, unsigned long Offset)
d866 1
a866 1
void (*xf86WriteMmio16) (int Value, pointer Base, unsigned long Offset)
d868 1
a868 1
void (*xf86WriteMmio32) (int Value, pointer Base, unsigned long Offset)
d870 1
a870 1
void (*xf86WriteMmioNB8) (int Value, pointer Base, unsigned long Offset)
d872 1
a872 1
void (*xf86WriteMmioNB16) (int Value, pointer Base, unsigned long Offset)
d874 1
a874 1
void (*xf86WriteMmioNB32) (int Value, pointer Base, unsigned long Offset)
d876 1
a876 1
int (*xf86ReadMmio8) (pointer Base, unsigned long Offset)
d878 1
a878 1
int (*xf86ReadMmio16) (pointer Base, unsigned long Offset)
d880 1
a880 1
int (*xf86ReadMmio32) (pointer Base, unsigned long Offset)
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d61 2
a62 1
      !defined(__arm__)
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d482 2
a483 4
#endif

Bool
xf86EnableIO(void)
a484 1
#if defined(__powerpc__)
d486 1
a486 8
    unsigned int ioBase_phys;
#endif

    if (ExtendedEnabled)
        return TRUE;

#if defined(__powerpc__)
    ioBase_phys = syscall(__NR_pciconfig_iobase, 2, 0, 0);
a492 9
/* Should this be fatal or just a warning? */
#if 0
        if (ioBase == MAP_FAILED) {
            xf86Msg(X_WARNING,
                    "xf86EnableIOPorts: Failed to map iobase (%s)\n",
                    strerror(errno));
            return FALSE;
        }
#endif
d495 17
a511 1
#elif !defined(__mc68000__) && !defined(__sparc__) && !defined(__mips__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && !defined(__arm__) && !defined(__m32r__) && !defined(__nds32__)
d513 2
a514 5
        if (errno == ENODEV)
            ErrorF("xf86EnableIOPorts: no I/O ports found\n");
        else
            FatalError("xf86EnableIOPorts: failed to set IOPL"
                       " for I/O (%s)\n", strerror(errno));
d523 16
a539 1
    ExtendedEnabled = TRUE;
d541 9
a549 1
    return TRUE;
d557 3
a559 7
#if defined(__powerpc__)
    munmap(ioBase, 0x20000);
    ioBase = NULL;
#elif !defined(__mc68000__) && !defined(__sparc__) && !defined(__mips__) && !defined(__sh__) && !defined(__hppa__) && !defined(__arm__) && !defined(__s390__) && !defined(__m32r__) && !defined(__nds32__)
    iopl(0);
    ioperm(0, 1024, 0);
#endif
a560 2

    return;
@


1.8
log
@Bugfix Update to xserver 1.11.3
@
text
@a48 4
#ifndef MAP_FAILED
#define MAP_FAILED ((void *)-1)
#endif

d73 2
a74 2
# define BUS_BASE bus_base
#else 
d76 1
a76 1
#endif /*  __alpha__ */
d84 2
a85 1
#if defined (__alpha__) 
d87 2
a88 2
extern unsigned long _bus_base __P ((void)) __attribute__ ((const));
extern unsigned long _bus_base_sparse __P ((void)) __attribute__ ((const));
d109 3
a111 3
#define MTRR_FD_UNOPENED (-1)	/* We have yet to open /proc/mtrr */
#define MTRR_FD_PROBLEM (-2)	/* We tried to open /proc/mtrr, but had
				   a problem. */
d120 2
a121 2
	/* Only report absence of /proc/mtrr once. */
	static Bool warned = FALSE;
d123 2
a124 2
	if (mtrr_fd == MTRR_FD_UNOPENED) { 
		mtrr_fd = open("/proc/mtrr", O_WRONLY);
d126 17
a142 17
		if (mtrr_fd < 0)
			mtrr_fd = MTRR_FD_PROBLEM;
	}

	if (mtrr_fd == MTRR_FD_PROBLEM) {
		/* To make sure we only ever warn once, need to check
		   verbosity outside xf86MsgVerb */
		if (!warned && verbosity <= xf86GetVerbosity()) {
			xf86MsgVerb(X_WARNING, verbosity,
				  "System lacks support for changing MTRRs\n");
			warned = TRUE;
		}

		return FALSE;
	}
	else
		return TRUE;
d151 3
a153 3
	struct mtrr_sentry	sentry;
	Bool			added;		/* added WC or removed it */
	struct mtrr_wc_region *	next;
a155 1

d158 1
a158 1
		      MessageType from)
d160 50
a209 51
	/* Some BIOS writers thought that setting wc over the mmio
	   region of a graphics devices was a good idea. Try to fix
	   it. */

	struct mtrr_gentry gent;
	struct mtrr_wc_region *wcreturn = NULL, *wcr;
	int count, ret=0;

	/* Linux 2.0 users should not get a warning without -verbose */
	if (!mtrr_open(2))
		return NULL;

	for (gent.regnum = 0; 
	     ioctl(mtrr_fd, MTRRIOC_GET_ENTRY, &gent) >= 0;
	     gent.regnum++) {
		if (gent.type != MTRR_TYPE_WRCOMB
		    || gent.base + gent.size <= base
		    || base + size <= gent.base)
			continue;

		/* Found an overlapping region. Delete it. */
		
		wcr = malloc(sizeof(*wcr));
		if (!wcr)
			return NULL;
		wcr->sentry.base = gent.base;
		wcr->sentry.size = gent.size;
		wcr->sentry.type = MTRR_TYPE_WRCOMB;
		wcr->added = FALSE;
		
		count = 3;
		while (count-- && 
		       (ret = ioctl(mtrr_fd, MTRRIOC_KILL_ENTRY, &(wcr->sentry))) < 0);
		
		if (ret >= 0) {
			xf86DrvMsg(screenNum, from,
				   "Removed MMIO write-combining range "
				   "(0x%lx,0x%lx)\n",
				   (unsigned long) gent.base, (unsigned long) gent.size);
			wcr->next = wcreturn;
			wcreturn = wcr;
			gent.regnum--;
		} else {
			free(wcr);
			xf86DrvMsgVerb(screenNum, X_WARNING, 0,
				   "Failed to remove MMIO "
				   "write-combining range (0x%lx,0x%lx)\n",
				       gent.base, (unsigned long) gent.size);
		}
	}
	return wcreturn;
a211 1

d214 1
a214 1
		      MessageType from)
d220 1
a220 1
	return NULL;
d223 12
a234 11
    for (gent.regnum = 0; 
	 ioctl(mtrr_fd, MTRRIOC_GET_ENTRY, &gent) >= 0; gent.regnum++ ) {
	if (gent.type == MTRR_TYPE_WRCOMB
	    && ((gent.base >= base && gent.base + gent.size < base + size) || 
		(gent.base >  base && gent.base + gent.size <= base + size))) {
	    *wcr = mtrr_cull_wc_region(screenNum, gent.base, gent.size, from);
	    if (*wcr) gent.regnum--;
	    while(*wcr) {
		wcr = &((*wcr)->next);
	    }
	}
a238 1

d241 1
a241 1
		   MessageType from)
d243 14
a256 1
        struct mtrr_wc_region **wcr, *wcreturn, *curwcr;
d258 12
a269 25
       /*
        * There can be only one....
        */

	wcreturn = mtrr_remove_offending(screenNum, base, size, from);
	wcr = &wcreturn;
	while (*wcr) {
	    wcr = &((*wcr)->next);
	} 

	/* Linux 2.0 should not warn, unless the user explicitly asks for
	   WC. */

	if (!mtrr_open(from == X_CONFIG ? 0 : 2))
		return wcreturn;

	*wcr = curwcr = malloc(sizeof(**wcr));
	if (!curwcr)
	    return wcreturn;

	curwcr->sentry.base = base;
	curwcr->sentry.size = size;
	curwcr->sentry.type = MTRR_TYPE_WRCOMB;
	curwcr->added = TRUE;
	curwcr->next = NULL;
d272 50
a321 51
	/*
	 * Splits up the write-combining region if it is not aligned on a
 	 * size boundary.
	 */

	{
	    unsigned long lbase, d_size = 1;
	    unsigned long n_size = size;
	    unsigned long n_base = base;

	    for (lbase = n_base, d_size = 1; !(lbase & 1);
		 lbase = lbase >> 1, d_size <<= 1);
	    while (d_size > n_size)
		d_size = d_size >> 1;
	    DebugF("WC_BASE: 0x%lx WC_END: 0x%lx\n",base,base+d_size-1);
	    n_base += d_size;
	    n_size -= d_size;
	    if (n_size) {
		xf86DrvMsgVerb(screenNum,X_INFO,3,"Splitting WC range: "
			       "base: 0x%lx, size: 0x%lx\n",base,size);
		curwcr->next = mtrr_add_wc_region(screenNum, n_base, n_size,from);
	    }
	    curwcr->sentry.size = d_size;
	} 
	
	/*****************************************************************/
#endif /* SPLIT_WC_REGIONS */

	if (ioctl(mtrr_fd, MTRRIOC_ADD_ENTRY, &curwcr->sentry) >= 0) {
		/* Avoid printing on every VT switch */
		if (xf86ServerIsInitialising()) {
			xf86DrvMsg(screenNum, from,
				   "Write-combining range (0x%lx,0x%lx)\n",
				   base, size);
		}
		return wcreturn;
	}
	else {
	        *wcr = curwcr->next;
		free(curwcr);
		
		/* Don't complain about the VGA region: MTRR fixed
		   regions aren't currently supported, but might be in
		   the future. */
		if ((unsigned long)base >= 0x100000) {
			xf86DrvMsgVerb(screenNum, X_WARNING, 0,
				"Failed to set up write-combining range "
				"(0x%lx,0x%lx)\n", base, size);
		}
		return wcreturn;
	}
d327 1
a327 1
	struct mtrr_wc_region *p, *prev;
d329 10
a338 10
	if (mtrr_fd >= 0) {
		p = wcr;
		while (p) {
			if (p->added)
				ioctl(mtrr_fd, MTRRIOC_DEL_ENTRY, &p->sentry);
			prev = p;
			p = p->next;
			free(prev);
		}
	}
d345 4
a348 4
	if (enable)
		return mtrr_add_wc_region(screenNum, base, size, from);
	else
		return mtrr_cull_wc_region(screenNum, base, size, from);
d354 1
a354 1
	mtrr_undo_wc_region(screenNum, regioninfo);
d357 1
a357 1
#endif /* HAS_MTRR_SUPPORT */
d362 1
a362 1
	pVidMem->linearSupported = TRUE;
d364 18
a381 17
	if (axpSystem == -1) {
	  axpSystem = lnxGetAXP();
	  if ((needSparse = (_bus_base_sparse() > 0))) {
	    hae_thresh = xf86AXPParams[axpSystem].hae_thresh;
	    hae_mask = xf86AXPParams[axpSystem].hae_mask;
	  }
	  bus_base = _bus_base();
	}
	if (needSparse) {
	  xf86Msg(X_INFO,"Machine needs sparse mapping\n");
	  pVidMem->mapMem = mapVidMemSparse;
	  pVidMem->unmapMem = unmapVidMemSparse;
	} else {
	  xf86Msg(X_INFO,"Machine type has 8/16 bit access\n");
	  pVidMem->mapMem = mapVidMem;
	  pVidMem->unmapMem = unmapVidMem;
	}	
d383 3
a385 4
	pVidMem->mapMem = mapVidMem;
	pVidMem->unmapMem = unmapVidMem;
#endif /* __alpha__ */

d388 2
a389 2
	pVidMem->setWC = setWC;
	pVidMem->undoWC = undoWC;
d391 1
a391 1
	pVidMem->initialised = TRUE;
d398 2
a399 1
static pointer mapVidMem(int ScreenNum, unsigned long Base, unsigned long Size, int flags)
d401 1
a401 1
	return NULL;
d409 1
a409 1
    int mapflags = MAP_SHARED; 
d416 1
a416 1
	   Base,realBase,alignOff);
d425 2
a426 2
    if(flags & VIDMEM_FRAMEBUFFER) 
        mapflags |= MAP_WRITECOMBINED; 
d428 1
a428 1
        mapflags |= MAP_NONCACHED; 
d434 1
a434 1
	      ((flags & VIDMEM_READONLY) ? O_RDONLY : O_RDWR) | O_SYNC);
d438 3
a440 4
    if (fd < 0)
    {
	FatalError("xf86MapVidMem: failed to open " DEV_MEM " (%s)\n",
		   strerror(errno));
d444 1
a444 1
	prot = PROT_READ;
d446 1
a446 1
	prot = PROT_READ | PROT_WRITE;
d449 2
a450 2
    base = mmap((caddr_t)0, Size + alignOff, prot, mapflags, fd,
 		(off_t)realBase  + BUS_BASE);
d454 1
a454 2
		   " (0x%08lx,0x%lx) (%s)\n", Base, Size,
		   strerror(errno));
d456 2
a457 2
    DebugF("base: %lx aligned base: %lx\n",base, (char *)base + alignOff);
    return (char *)base + alignOff;
d459 2
a460 2
#endif /* !(__sparc__) */
    
d464 2
a465 2
    uintptr_t alignOff = (uintptr_t)Base
	- ((uintptr_t)Base & ~(getpagesize() - 1));
d467 2
a468 2
    DebugF("alignment offset: %lx\n", (unsigned long)alignOff);
    munmap((void *)((uintptr_t)Base - alignOff), (Size + alignOff));
a470 1

d488 2
a489 2
	int fd;
	unsigned int ioBase_phys;
d492 2
a493 2
	if (ExtendedEnabled)
		return TRUE;
d496 1
a496 1
	ioBase_phys = syscall(__NR_pciconfig_iobase, 2, 0, 0);
d498 5
a502 5
	fd = open("/dev/mem", O_RDWR);
	if (ioBase == NULL) {
		ioBase = (volatile unsigned char *)mmap(0, 0x20000,
				PROT_READ | PROT_WRITE, MAP_SHARED, fd,
				ioBase_phys);
d505 6
a510 6
		if (ioBase == MAP_FAILED) {
		    xf86Msg(X_WARNING,
			    "xf86EnableIOPorts: Failed to map iobase (%s)\n",
			    strerror(errno));
		    return FALSE;
		}
d512 2
a513 2
	}
	close(fd);
d515 14
a528 14
        if (ioperm(0, 1024, 1) || iopl(3)) {
                if (errno == ENODEV)
                        ErrorF("xf86EnableIOPorts: no I/O ports found\n");
                else
                        FatalError("xf86EnableIOPorts: failed to set IOPL"
                                   " for I/O (%s)\n", strerror(errno));
		return FALSE;
        }
# if !defined(__alpha__)
	/* XXX: this is actually not trapping anything because of iopl(3)
	 * above */
	ioperm(0x40,4,0); /* trap access to the timer chip */
	ioperm(0x60,4,0); /* trap access to the keyboard controller */
# endif
d530 1
a530 1
	ExtendedEnabled = TRUE;
d532 1
a532 1
	return TRUE;
d538 2
a539 2
	if (!ExtendedEnabled)
		return;
d541 2
a542 2
	munmap(ioBase, 0x20000);
	ioBase = NULL;
d544 2
a545 2
	iopl(0);
	ioperm(0, 1024, 0);
d547 1
a547 1
	ExtendedEnabled = FALSE;
d549 1
a549 1
	return;
d560 1
a560 1
writeDenseNB8(int Value, pointer Base, register unsigned long Offset);
d562 1
a562 1
writeDenseNB16(int Value, pointer Base, register unsigned long Offset);
d564 1
a564 1
writeDenseNB32(int Value, pointer Base, register unsigned long Offset);
d566 1
a566 1
writeDense8(int Value, pointer Base, register unsigned long Offset);
d568 1
a568 1
writeDense16(int Value, pointer Base, register unsigned long Offset);
d570 1
a570 1
writeDense32(int Value, pointer Base, register unsigned long Offset);
d576 1
a576 1
writeSparseNB8(int Value, pointer Base, register unsigned long Offset);
d578 1
a578 1
writeSparseNB16(int Value, pointer Base, register unsigned long Offset);
d580 1
a580 1
writeSparseNB32(int Value, pointer Base, register unsigned long Offset);
d582 1
a582 1
writeSparse8(int Value, pointer Base, register unsigned long Offset);
d584 1
a584 1
writeSparse16(int Value, pointer Base, register unsigned long Offset);
d586 1
a586 1
writeSparse32(int Value, pointer Base, register unsigned long Offset);
d594 2
a595 1
mapVidMemSparse(int ScreenNum, unsigned long Base, unsigned long Size, int flags)
d603 1
a603 1
      was_here = TRUE;
d605 9
a613 9
      xf86WriteMmio8 = writeSparse8;
      xf86WriteMmio16 = writeSparse16;
      xf86WriteMmio32 = writeSparse32;
      xf86WriteMmioNB8 = writeSparseNB8;
      xf86WriteMmioNB16 = writeSparseNB16;
      xf86WriteMmioNB32 = writeSparseNB32;
      xf86ReadMmio8 = readSparse8;
      xf86ReadMmio16 = readSparse16;
      xf86ReadMmio32 = readSparse32;
d615 1
a615 1
	
d619 1
a619 1
		   strerror(errno));
d623 2
a624 2
    xf86Msg(X_INFO,"mapVidMemSparse: try Base 0x%lx size 0x%lx flags 0x%x\n",
	    Base, Size, flags);
d628 1
a628 1
	prot = PROT_READ;
d630 1
a630 1
	prot = PROT_READ | PROT_WRITE;
d637 2
a638 3
    ret = (unsigned long)mmap((caddr_t)(DENSE_BASE + Base), Size,
		   prot, MAP_SHARED, fd,
		   (off_t) (bus_base + Base));
d648 4
a651 5
	((flags & VIDMEM_FRAMEBUFFER) && (flags & VIDMEM_SPARSE)))
    {
        rets = (unsigned long)mmap((caddr_t)(SPARSE_BASE + (Base << 5)),
				   Size << 5, prot, MAP_SHARED, fd,
				   (off_t) _bus_base_sparse() + (Base << 5));
d655 2
a656 2
      
    if (ret == (unsigned long)MAP_FAILED) {
d658 1
a658 1
		   strerror(errno));
d662 6
a667 8
	((flags & VIDMEM_FRAMEBUFFER) && (flags & VIDMEM_SPARSE)))
    {
        if (rets == (unsigned long)MAP_FAILED ||
	    rets != (SPARSE_BASE + (Base << 5)))
	{
	    FatalError("mapVidMemSparse: Could not (sparse) mmap fb (%s)\n",
		       strerror(errno));
	}
d672 3
a674 3
        xf86Msg(X_INFO,"mapVidMemSparse: mapped Base 0x%lx size 0x%lx"
		" to DENSE at 0x%lx and SPARSE at 0x%lx\n",
		Base, Size, ret, rets);
d676 2
a677 3
        xf86Msg(X_INFO,"mapVidMemSparse: mapped Base 0x%lx size 0x%lx"
		" to DENSE only at 0x%lx\n",
		Base, Size, ret);
d686 2
a687 1
    unsigned long Offset = (unsigned long)Base - DENSE_BASE;
d689 2
a690 2
    xf86Msg(X_INFO,"unmapVidMemSparse: unmapping Base 0x%lx Size 0x%lx\n",
	    Base, Size);
d693 1
a693 1
    munmap((caddr_t)Base, Size);
d696 1
a696 1
    munmap((caddr_t)(SPARSE_BASE + (Offset << 5)), Size << 5);
d706 1
a706 1
    Offset += (unsigned long)Base - DENSE_BASE;
d711 4
a714 4
	if (msb_set != msb) {
	    sethae(msb);
	    msb_set = msb;
	}
d730 1
a730 1
    Offset += (unsigned long)Base - DENSE_BASE;
d735 4
a738 4
	if (msb_set != msb) {
	    sethae(msb);
	    msb_set = msb;
	}
d742 1
a742 1
    result = *(vuip)(SPARSE_BASE + (Offset<<5) + (1<<(5-2)));
d752 1
a752 1
    return *(vuip)((unsigned long)Base+(Offset));
d762 1
a762 1
    Offset += (unsigned long)Base - DENSE_BASE;
d765 5
a769 5
	Offset -= msb;
	if (msb_set != msb) {
	    sethae(msb); 
	    msb_set = msb;
	}
d783 1
a783 1
    Offset += (unsigned long)Base - DENSE_BASE;
d786 5
a790 5
	Offset -= msb;
	if (msb_set != msb) {
	    sethae(msb);
	    msb_set = msb;
	}
d794 1
a794 1
    *(vuip)(SPARSE_BASE + (Offset<<5) + (1<<(5-2))) = w * 0x00010001;
d802 1
a802 1
    *(vuip)((unsigned long)Base + (Offset)) = Value;
d812 1
a812 1
    Offset += (unsigned long)Base - DENSE_BASE;
d815 5
a819 5
	Offset -= msb;
	if (msb_set != msb) {
	    sethae(msb);
	    msb_set = msb;
	}
d830 1
a830 1
    Offset += (unsigned long)Base - DENSE_BASE;
d833 5
a837 5
	Offset -= msb;
	if (msb_set != msb) {
	    sethae(msb);
	    msb_set = msb;
	}
d839 1
a839 1
    *(vuip)(SPARSE_BASE+(Offset<<5)+(1<<(5-2))) = w * 0x00010001;
d846 1
a846 1
    *(vuip)((unsigned long)Base + (Offset)) = Value;
d850 18
a867 18
void (*xf86WriteMmio8)(int Value, pointer Base, unsigned long Offset)
     = writeDense8;
void (*xf86WriteMmio16)(int Value, pointer Base, unsigned long Offset)
     = writeDense16;
void (*xf86WriteMmio32)(int Value, pointer Base, unsigned long Offset)
     = writeDense32;
void (*xf86WriteMmioNB8)(int Value, pointer Base, unsigned long Offset)
     = writeDenseNB8;
void (*xf86WriteMmioNB16)(int Value, pointer Base, unsigned long Offset)
     = writeDenseNB16;
void (*xf86WriteMmioNB32)(int Value, pointer Base, unsigned long Offset)
     = writeDenseNB32;
int  (*xf86ReadMmio8)(pointer Base, unsigned long Offset)
     = readDense8;
int  (*xf86ReadMmio16)(pointer Base, unsigned long Offset)
     = readDense16;
int  (*xf86ReadMmio32)(pointer Base, unsigned long Offset)
     = readDense32;
d869 1
a869 1
#endif /* __alpha__ */
@


1.7
log
@Update to xserver 1.11.2
@
text
@d472 2
a473 2
    memType alignOff = (memType)Base 
	- ((memType)Base & ~(getpagesize() - 1));
d475 2
a476 2
    DebugF("alignment offset: %lx\n",alignOff);
    munmap((caddr_t)((memType)Base - alignOff), (Size + alignOff));
@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d64 1
d464 1
a464 1
    DebugF("base: %lx aligned base: %lx\n",base, base + alignOff);
d523 1
a523 1
#elif !defined(__mc68000__) && !defined(__sparc__) && !defined(__mips__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && !defined(__arm__) && !defined(__m32r__)
d552 1
a552 1
#elif !defined(__mc68000__) && !defined(__sparc__) && !defined(__mips__) && !defined(__sh__) && !defined(__hppa__) && !defined(__arm__) && !defined(__s390__) && !defined(__m32r__)
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d532 2
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d185 1
a185 1
		wcr = xalloc(sizeof(*wcr));
d206 1
a206 1
			xfree(wcr);
d266 1
a266 1
	*wcr = curwcr = xalloc(sizeof(**wcr));
d316 1
a316 1
		xfree(curwcr);
d342 1
a342 1
			xfree(prev);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a40 1
#include "lnx.h"
a75 3

extern void sethae(unsigned long hae);

a76 1

a77 1

a78 1

d88 4
a99 1
static unsigned long sparse_size;
d291 1
a291 3
#ifdef DEBUG
	    ErrorF("WC_BASE: 0x%lx WC_END: 0x%lx\n",base,base+d_size-1);
#endif
d335 1
a335 1
	if (mtrr_fd > 0) {
a374 1
	    sparse_size = xf86AXPParams[axpSystem].size;
d420 1
a420 2
#ifdef DEBUG
    ErrorF("base: %lx, realBase: %lx, alignOff: %lx \n",
d422 1
a422 2
#endif
    
d463 1
a463 3
#ifdef DEBUG
    ErrorF("base: %lx aligned base: %lx\n",base, base + alignOff);
#endif
d473 2
a474 4
    
#ifdef DEBUG
    ErrorF("alignment offset: %lx\n",alignOff);
#endif
d484 1
a484 1
_X_EXPORT volatile unsigned char *ioBase = NULL;
d492 1
a492 1
_X_EXPORT Bool
d541 1
a541 1
_X_EXPORT void
d859 1
a859 1
_X_EXPORT void (*xf86WriteMmio8)(int Value, pointer Base, unsigned long Offset) 
d861 1
a861 1
_X_EXPORT void (*xf86WriteMmio16)(int Value, pointer Base, unsigned long Offset)
d863 1
a863 1
_X_EXPORT void (*xf86WriteMmio32)(int Value, pointer Base, unsigned long Offset)
d865 1
a865 1
_X_EXPORT void (*xf86WriteMmioNB8)(int Value, pointer Base, unsigned long Offset) 
d867 1
a867 1
_X_EXPORT void (*xf86WriteMmioNB16)(int Value, pointer Base, unsigned long Offset)
d869 1
a869 1
_X_EXPORT void (*xf86WriteMmioNB32)(int Value, pointer Base, unsigned long Offset)
d871 1
a871 1
_X_EXPORT int  (*xf86ReadMmio8)(pointer Base, unsigned long Offset) 
d873 1
a873 1
_X_EXPORT int  (*xf86ReadMmio16)(pointer Base, unsigned long Offset)
d875 1
a875 1
_X_EXPORT int  (*xf86ReadMmio32)(pointer Base, unsigned long Offset)
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a77 1
# ifdef LIBC_IS_FIXED
a78 11
# else
#  include <unistd.h>
#  define sethae(x) syscall(301,x);
# endif

/* define to test the Sparse addressing on a non-Jensen */
# ifdef TEST_JENSEN_CODE 
#  define isJensen (1)
# else
#  define isJensen (axpSystem == JENSEN)
# endif
a97 4
# if defined(JENSEN_SUPPORT)
static pointer mapVidMemJensen(int, unsigned long, unsigned long, int);
static void unmapVidMemJensen(int, pointer, unsigned long);
# endif
d385 1
a385 11
	if (isJensen) {
# ifndef JENSEN_SUPPORT
	  FatalError("Jensen is not supported any more\n"
		     "If you are intereseted in fixing Jensen support\n"
		     "please contact xorg@@lists.freedesktop.org\n");
# else
	  xf86Msg(X_INFO,"Machine type is Jensen\n");
	  pVidMem->mapMem = mapVidMemJensen;
	  pVidMem->unmapMem = unmapVidMemJensen;
# endif /* JENSEN_SUPPORT */
	} else if (needSparse) {
d535 1
a535 1
#elif !defined(__mc68000__) && !defined(__sparc__) && !defined(__mips__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && !defined(__arm__)
d562 1
a562 1
#elif !defined(__mc68000__) && !defined(__sparc__) && !defined(__mips__) && !defined(__sh__) && !defined(__hppa__) && !defined(__arm__) && !defined(__s390__)
a570 18
/*
 * Don't use these two functions.  They can't possibly work.  If you actually
 * need interrupts off for something, you ought to be doing it in the kernel
 * anyway.
 */

_X_EXPORT Bool
xf86DisableInterrupts()
{
	return (TRUE);
}

_X_EXPORT void
xf86EnableInterrupts()
{
	return;
}

a889 171

#ifdef JENSEN_SUPPORT

static int
readSparseJensen8(pointer Base, register unsigned long Offset);
static int
readSparseJensen16(pointer Base, register unsigned long Offset);
static int
readSparseJensen32(pointer Base, register unsigned long Offset);
static void
writeSparseJensen8(int Value, pointer Base, register unsigned long Offset);
static void
writeSparseJensen16(int Value, pointer Base, register unsigned long Offset);
static void
writeSparseJensen32(int Value, pointer Base, register unsigned long Offset);
static void
writeSparseJensenNB8(int Value, pointer Base, register unsigned long Offset);
static void
writeSparseJensenNB16(int Value, pointer Base, register unsigned long Offset);
static void
writeSparseJensenNB32(int Value, pointer Base, register unsigned long Offset);

/*
 * The Jensen lacks dense memory, thus we have to address the bus via
 * the sparse addressing scheme.
 *
 * Martin Ostermann (ost@@comnets.rwth-aachen.de) - Apr.-Sep. 1996
 */

#ifdef TEST_JENSEN_CODE 
#define SPARSE (5)
#else
#define SPARSE (7)
#endif

#define JENSEN_SHIFT(x) ((long)x<<SPARSE)

static pointer
mapVidMemJensen(int ScreenNum, unsigned long Base, unsigned long Size, int flags)
{
  pointer base;
  int fd, prot;

  xf86WriteMmio8 = writeSparseJensen8;
  xf86WriteMmio16 = writeSparseJensen16;
  xf86WriteMmio32 = writeSparseJensen32;
  xf86WriteMmioNB8 = writeSparseJensenNB8;
  xf86WriteMmioNB16 = writeSparseJensenNB16;
  xf86WriteMmioNB32 = writeSparseJensenNB32;
  xf86ReadMmio8 = readSparseJensen8;
  xf86ReadMmio16 = readSparseJensen16;
  xf86ReadMmio32 = readSparseJensen32;

  fd = open(DEV_MEM, (flags & VIDMEM_READONLY) ? O_RDONLY : O_RDWR);
  if (fd < 0) {
    FatalError("xf86MapVidMem: failed to open " DEV_MEM " (%s)\n",
	       strerror(errno));
  }

  if (flags & VIDMEM_READONLY)
    prot = PROT_READ;
  else
    prot = PROT_READ | PROT_WRITE;

  /* This requires linux-0.99.pl10 or above */
  base = mmap((caddr_t)0, JENSEN_SHIFT(Size),
	      prot, MAP_SHARED, fd,
	      (off_t)(JENSEN_SHIFT((off_t)Base) + _bus_base_sparse()));
  close(fd);
  if (base == MAP_FAILED) {
    FatalError("xf86MapVidMem: Could not mmap framebuffer"
	       " (0x%08x,0x%x) (%s)\n", Base, Size,
	       strerror(errno));
  }
  return base;
}

static void
unmapVidMemJensen(int ScreenNum, pointer Base, unsigned long Size)
{
  munmap((caddr_t)Base, JENSEN_SHIFT(Size));
}

static int
readSparseJensen8(pointer Base, register unsigned long Offset)
{
    register unsigned long result, shift;

    mem_barrier();
    shift = (Offset & 0x3) << 3;

    result = *(vuip) ((unsigned long)Base + (Offset << SPARSE));

    result >>= shift;
    return 0xffUL & result;
}

static int
readSparseJensen16(pointer Base, register unsigned long Offset)
{
    register unsigned long result, shift;

    mem_barrier();
    shift = (Offset & 0x2) << 3;

    result = *(vuip)((unsigned long)Base+(Offset<<SPARSE)+(1<<(SPARSE-2)));

    result >>= shift;
    return 0xffffUL & result;
}

static int
readSparseJensen32(pointer Base, register unsigned long Offset)
{
    register unsigned long result;

    mem_barrier();
    result = *(vuip)((unsigned long)Base+(Offset<<SPARSE)+(3<<(SPARSE-2)));

    return result;
}

static void
writeSparseJensen8(int Value, pointer Base, register unsigned long Offset)
{
    register unsigned int b = Value & 0xffU;

    write_mem_barrier();
    *(vuip) ((unsigned long)Base + (Offset << SPARSE)) = b * 0x01010101;
}

static void
writeSparseJensen16(int Value, pointer Base, register unsigned long Offset)
{
    register unsigned int w = Value & 0xffffU;

    write_mem_barrier();
    *(vuip)((unsigned long)Base+(Offset<<SPARSE)+(1<<(SPARSE-2))) =
      w * 0x00010001;
}

static void
writeSparseJensen32(int Value, pointer Base, register unsigned long Offset)
{
    write_mem_barrier();
    *(vuip)((unsigned long)Base+(Offset<<SPARSE)+(3<<(SPARSE-2))) = Value;
}

static void
writeSparseJensenNB8(int Value, pointer Base, register unsigned long Offset)
{
    register unsigned int b = Value & 0xffU;

    *(vuip) ((unsigned long)Base + (Offset << SPARSE)) = b * 0x01010101;
}

static void
writeSparseJensenNB16(int Value, pointer Base, register unsigned long Offset)
{
    register unsigned int w = Value & 0xffffU;

    *(vuip)((unsigned long)Base+(Offset<<SPARSE)+(1<<(SPARSE-2))) =
      w * 0x00010001;
}

static void
writeSparseJensenNB32(int Value, pointer Base, register unsigned long Offset)
{
    *(vuip)((unsigned long)Base+(Offset<<SPARSE)+(3<<(SPARSE-2))) = Value;
}
#endif /* JENSEN_SUPPORT */
@


1.1
log
@Initial revision
@
text
@a24 1
/* $XConsortium: lnx_video.c /main/9 1996/10/19 18:06:34 kaleb $ */
d64 2
a65 1
      !defined(__mips__)
a144 7
	char **fn;
	static char *mtrr_files[] = {
		"/dev/cpu/mtrr",	/* Possible future name */
		"/proc/mtrr",		/* Current name */
		NULL
	};

d146 1
a146 3
		/* So open it. */
		for (fn = mtrr_files; mtrr_fd < 0 && *fn; fn++)
			mtrr_fd = open(*fn, O_WRONLY);
d405 1
a405 1
		     "please contact xfree86@@xfree86.org\n");
d561 1
a561 1
#elif !defined(__mc68000__) && !defined(__sparc__) && !defined(__mips__) && !defined(__sh__) && !defined(__hppa__)
d597 5
a601 6

/***************************************************************************/
/* Interrupt Handling section                                              */
/***************************************************************************/

/* XXX The #ifdefs should be made simpler. */
a605 26
#if !defined(__mc68000__) && !defined(__powerpc__) && !defined(__sparc__) && !defined(__mips__) && !defined(__ia64__) && !defined(__sh__) && !defined(__hppa__) && !defined(__arm__) && !defined(__s390__)
	if (!ExtendedEnabled)
	    if (iopl(3) || ioperm(0, 1024, 1))
			return (FALSE);
#endif
#if defined(__alpha__) || defined(__mc68000__) || defined(__powerpc__) || defined(__sparc__) || defined(__mips__) || defined(__arm__) || defined(__sh__) || defined(__ia64__) || defined(__hppa__) || defined(__s390__)
#else
# ifdef __GNUC__
#  if defined(__ia64__)
#   if 0
	__asm__ __volatile__ (";; rsm psr.i;; srlz.d" ::: "memory");
#   endif
#  else
      __asm__ __volatile__("cli");
#  endif
# else
	asm("cli");
# endif
#endif
#if !defined(__mc68000__) && !defined(__powerpc__) && !defined(__sparc__) && !defined(__mips__) && !defined(__sh__) && !defined(__ia64__) && !defined(__hppa__) && !defined(__arm__) && !defined(__s390__)
	if (!ExtendedEnabled) {
	    iopl(0);
	    ioperm(0, 1024, 0);
	}
	
#endif
a611 25
#if !defined(__mc68000__) && !defined(__powerpc__) && !defined(__sparc__) && !defined(__mips__) && !defined(__ia64__) && !defined(__sh__) && !defined(__hppa__) && !defined(__arm__) && !defined(__s390__)
	if (!ExtendedEnabled)
	    if (iopl(3) || ioperm(0, 1024, 1))
			return;
#endif
#if defined(__alpha__) || defined(__mc68000__) || defined(__powerpc__) || defined(__sparc__) || defined(__mips__) || defined(__arm__) || defined(__sh__) || defined(__ia64__) || defined(__hppa__) || defined(__s390__)
#else
# ifdef __GNUC__
#  if defined(__ia64__)
#   if 0
	__asm__ __volatile__ (";; ssm psr.i;; srlz.d" ::: "memory");
#   endif
#  else
      __asm__ __volatile__("sti");
#  endif
# else
	asm("sti");
# endif
#endif
#if !defined(__mc68000__) && !defined(__powerpc__) && !defined(__sparc__) && !defined(__mips__) && !defined(__sh__) && !defined(__ia64__) && !defined(__hppa__) && !defined(__arm__) && !defined(__s390__)
	if (!ExtendedEnabled) {
	    iopl(0);
	    ioperm(0, 1024, 0);
	}
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d25 1
d65 1
a65 2
      !defined(__mips__) && \
      !defined(__arm__)
d570 1
a570 1
#elif !defined(__mc68000__) && !defined(__sparc__) && !defined(__mips__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && !defined(__arm__)
d606 6
a611 5
/*
 * Don't use these two functions.  They can't possibly work.  If you actually
 * need interrupts off for something, you ought to be doing it in the kernel
 * anyway.
 */
d616 26
d648 25
@

