head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.4
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.2
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.08.09.18.59.53;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	6HLO5qdN5N4nPDjW;

1.12
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	7pAEtF6Y5EgemkuY;

1.10
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.52;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.27;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.22;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 * Copyright 1992 by Orest Zborowski <obz@@Kodak.com>
 * Copyright 1993 by David Wexelblat <dwex@@goblin.org>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the names of Orest Zborowski and David Wexelblat
 * not be used in advertising or publicity pertaining to distribution of
 * the software without specific, written prior permission.  Orest Zborowski
 * and David Wexelblat make no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without express or
 * implied warranty.
 *
 * OREST ZBOROWSKI AND DAVID WEXELBLAT DISCLAIMS ALL WARRANTIES WITH REGARD
 * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL OREST ZBOROWSKI OR DAVID WEXELBLAT BE LIABLE
 * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include <X11/Xmd.h>

#include "compiler.h"
#include "linux.h"

#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"

#include <sys/stat.h>

#ifndef K_OFF
#define K_OFF 0x4
#endif

#ifndef KDSKBMUTE
#define KDSKBMUTE 0x4B51
#endif

static Bool KeepTty = FALSE;
static int activeVT = -1;

static char vtname[11];
static struct termios tty_attr; /* tty state to restore */
static int tty_mode;            /* kbd mode to restore */

static void
drain_console(int fd, void *closure)
{
    errno = 0;
    if (tcflush(fd, TCIOFLUSH) == -1 && errno == EIO) {
        xf86SetConsoleHandler(NULL, NULL);
    }
}

static int
switch_to(int vt, const char *from)
{
    int ret;

    SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_ACTIVATE, vt));
    if (ret < 0) {
        xf86Msg(X_WARNING, "%s: VT_ACTIVATE failed: %s\n", from, strerror(errno));
        return 0;
    }

    SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_WAITACTIVE, vt));
    if (ret < 0) {
        xf86Msg(X_WARNING, "%s: VT_WAITACTIVE failed: %s\n", from, strerror(errno));
        return 0;
    }

    return 1;
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-nonliteral"

int
linux_parse_vt_settings(int may_fail)
{
    int i, fd = -1, ret, current_vt = -1;
    struct vt_stat vts;
    struct stat st;
    MessageType from = X_PROBED;

    /* Only do this once */
    static int vt_settings_parsed = 0;

    if (vt_settings_parsed)
        return 1;

    /*
     * setup the virtual terminal manager
     */
    if (xf86Info.vtno != -1) {
        from = X_CMDLINE;
    }
    else {
        fd = open("/dev/tty0", O_WRONLY, 0);
        if (fd < 0) {
            if (may_fail)
                return 0;
            FatalError("parse_vt_settings: Cannot open /dev/tty0 (%s)\n",
                       strerror(errno));
        }

        if (xf86Info.ShareVTs) {
            SYSCALL(ret = ioctl(fd, VT_GETSTATE, &vts));
            if (ret < 0) {
                if (may_fail)
                    return 0;
                FatalError("parse_vt_settings: Cannot find the current"
                           " VT (%s)\n", strerror(errno));
            }
            xf86Info.vtno = vts.v_active;
        }
        else {
            SYSCALL(ret = ioctl(fd, VT_OPENQRY, &xf86Info.vtno));
            if (ret < 0) {
                if (may_fail)
                    return 0;
                FatalError("parse_vt_settings: Cannot find a free VT: "
                           "%s\n", strerror(errno));
            }
            if (xf86Info.vtno == -1) {
                if (may_fail)
                    return 0;
                FatalError("parse_vt_settings: Cannot find a free VT\n");
            }
        }
        close(fd);
    }

    xf86Msg(from, "using VT number %d\n\n", xf86Info.vtno);

    /* Some of stdin / stdout / stderr maybe redirected to a file */
    for (i = STDIN_FILENO; i <= STDERR_FILENO; i++) {
        ret = fstat(i, &st);
        if (ret == 0 && S_ISCHR(st.st_mode) && major(st.st_rdev) == 4) {
            current_vt = minor(st.st_rdev);
            break;
        }
    }

    if (!KeepTty && current_vt == xf86Info.vtno) {
        xf86Msg(X_PROBED,
                "controlling tty is VT number %d, auto-enabling KeepTty\n",
                current_vt);
        KeepTty = TRUE;
    }

    vt_settings_parsed = 1;
    return 1;
}

int
linux_get_keeptty(void)
{
    return KeepTty;
}

void
xf86OpenConsole(void)
{
    int i, ret;
    struct vt_stat vts;
    struct vt_mode VT;
    const char *vcs[] = { "/dev/vc/%d", "/dev/tty%d", NULL };

    if (serverGeneration == 1) {
        linux_parse_vt_settings(FALSE);

        if (!KeepTty) {
            pid_t ppid = getppid();
            pid_t ppgid;

            ppgid = getpgid(ppid);

            /*
             * change to parent process group that pgid != pid so
             * that setsid() doesn't fail and we become process
             * group leader
             */
            if (setpgid(0, ppgid) < 0)
                xf86Msg(X_WARNING, "xf86OpenConsole: setpgid failed: %s\n",
                        strerror(errno));

            /* become process group leader */
            if ((setsid() < 0))
                xf86Msg(X_WARNING, "xf86OpenConsole: setsid failed: %s\n",
                        strerror(errno));
        }

        i = 0;
        while (vcs[i] != NULL) {
            snprintf(vtname, sizeof(vtname), vcs[i], xf86Info.vtno);    /* /dev/tty1-64 */
            if ((xf86Info.consoleFd = open(vtname, O_RDWR | O_NDELAY, 0)) >= 0)
                break;
            i++;
        }

        if (xf86Info.consoleFd < 0)
            FatalError("xf86OpenConsole: Cannot open virtual console"
                       " %d (%s)\n", xf86Info.vtno, strerror(errno));

        /*
         * Linux doesn't switch to an active vt after the last close of a vt,
         * so we do this ourselves by remembering which is active now.
         */
        SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_GETSTATE, &vts));
        if (ret < 0)
            xf86Msg(X_WARNING, "xf86OpenConsole: VT_GETSTATE failed: %s\n",
                    strerror(errno));
        else
            activeVT = vts.v_active;

        if (!xf86Info.ShareVTs) {
            struct termios nTty;

            /*
             * now get the VT.  This _must_ succeed, or else fail completely.
             */
            if (!switch_to(xf86Info.vtno, "xf86OpenConsole"))
                FatalError("xf86OpenConsole: Switching VT failed\n");

            SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_GETMODE, &VT));
            if (ret < 0)
                FatalError("xf86OpenConsole: VT_GETMODE failed %s\n",
                           strerror(errno));

            signal(SIGUSR1, xf86VTRequest);

            VT.mode = VT_PROCESS;
            VT.relsig = SIGUSR1;
            VT.acqsig = SIGUSR1;

            SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_SETMODE, &VT));
            if (ret < 0)
                FatalError
                    ("xf86OpenConsole: VT_SETMODE VT_PROCESS failed: %s\n",
                     strerror(errno));

            SYSCALL(ret = ioctl(xf86Info.consoleFd, KDSETMODE, KD_GRAPHICS));
            if (ret < 0)
                FatalError("xf86OpenConsole: KDSETMODE KD_GRAPHICS failed %s\n",
                           strerror(errno));

            tcgetattr(xf86Info.consoleFd, &tty_attr);
            SYSCALL(ioctl(xf86Info.consoleFd, KDGKBMODE, &tty_mode));

            /* disable kernel special keys and buffering, new style */
            SYSCALL(ret = ioctl(xf86Info.consoleFd, KDSKBMUTE, 1));
            if (ret < 0)
            {
                /* disable kernel special keys and buffering, old style */
                SYSCALL(ret = ioctl(xf86Info.consoleFd, KDSKBMODE, K_OFF));
                if (ret < 0)
                {
                    /* fine, just disable special keys */
                    SYSCALL(ret = ioctl(xf86Info.consoleFd, KDSKBMODE, K_RAW));
                    if (ret < 0)
                        FatalError("xf86OpenConsole: KDSKBMODE K_RAW failed %s\n",
                                   strerror(errno));

                    /* ... and drain events, else the kernel gets angry */
                    xf86SetConsoleHandler(drain_console, NULL);
                }
            }

            nTty = tty_attr;
            nTty.c_iflag = (IGNPAR | IGNBRK) & (~PARMRK) & (~ISTRIP);
            nTty.c_oflag = 0;
            nTty.c_cflag = CREAD | CS8;
            nTty.c_lflag = 0;
            nTty.c_cc[VTIME] = 0;
            nTty.c_cc[VMIN] = 1;
            cfsetispeed(&nTty, 9600);
            cfsetospeed(&nTty, 9600);
            tcsetattr(xf86Info.consoleFd, TCSANOW, &nTty);
        }
    }
    else {                      /* serverGeneration != 1 */
        if (!xf86Info.ShareVTs && xf86Info.autoVTSwitch) {
            /* now get the VT */
            if (!switch_to(xf86Info.vtno, "xf86OpenConsole"))
                FatalError("xf86OpenConsole: Switching VT failed\n");
        }
    }
}

#pragma GCC diagnostic pop

void
xf86CloseConsole(void)
{
    struct vt_mode VT;
    int ret;

    if (xf86Info.ShareVTs) {
        close(xf86Info.consoleFd);
        return;
    }

    /*
     * unregister the drain_console handler
     * - what to do if someone else changed it in the meantime?
     */
    xf86SetConsoleHandler(NULL, NULL);

    /* Back to text mode ... */
    SYSCALL(ret = ioctl(xf86Info.consoleFd, KDSETMODE, KD_TEXT));
    if (ret < 0)
        xf86Msg(X_WARNING, "xf86CloseConsole: KDSETMODE failed: %s\n",
                strerror(errno));

    SYSCALL(ioctl(xf86Info.consoleFd, KDSKBMUTE, 0));
    SYSCALL(ioctl(xf86Info.consoleFd, KDSKBMODE, tty_mode));
    tcsetattr(xf86Info.consoleFd, TCSANOW, &tty_attr);

    SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_GETMODE, &VT));
    if (ret < 0)
        xf86Msg(X_WARNING, "xf86CloseConsole: VT_GETMODE failed: %s\n",
                strerror(errno));
    else {
        /* set dflt vt handling */
        VT.mode = VT_AUTO;
        SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_SETMODE, &VT));
        if (ret < 0)
            xf86Msg(X_WARNING, "xf86CloseConsole: VT_SETMODE failed: %s\n",
                    strerror(errno));
    }

    if (xf86Info.autoVTSwitch) {
        /*
         * Perform a switch back to the active VT when we were started
         */
        if (activeVT >= 0) {
            switch_to(activeVT, "xf86CloseConsole");
            activeVT = -1;
        }
    }
    close(xf86Info.consoleFd);  /* make the vt-manager happy */
}

int
xf86ProcessArgument(int argc, char *argv[], int i)
{
    /*
     * Keep server from detaching from controlling tty.  This is useful
     * when debugging (so the server can receive keyboard signals.
     */
    if (!strcmp(argv[i], "-keeptty")) {
        KeepTty = TRUE;
        return 1;
    }

    if ((argv[i][0] == 'v') && (argv[i][1] == 't')) {
        if (sscanf(argv[i], "vt%2d", &xf86Info.vtno) == 0) {
            UseMsg();
            xf86Info.vtno = -1;
            return 0;
        }
        return 1;
    }
    return 0;
}

void
xf86UseMsg(void)
{
    ErrorF("vtXX                   use the specified VT number\n");
    ErrorF("-keeptty               ");
    ErrorF("don't detach controlling tty (for debugging only)\n");
}
@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@a95 1
    const char *tty0[] = { "/dev/tty0", "/dev/vc/0", NULL };
d110 1
a110 8

        i = 0;
        while (tty0[i] != NULL) {
            if ((fd = open(tty0[i], O_WRONLY, 0)) >= 0)
                break;
            i++;
        }

@


1.11
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d34 1
d89 2
a90 2
void
xf86OpenConsole(void)
a92 1
    struct vt_mode VT;
a96 1
    const char *vcs[] = { "/dev/vc/%d", "/dev/tty%d", NULL };
d98 26
a123 6
    if (serverGeneration == 1) {
        /*
         * setup the virtual terminal manager
         */
        if (xf86Info.vtno != -1) {
            from = X_CMDLINE;
a124 1
        else {
d126 7
a132 5
            i = 0;
            while (tty0[i] != NULL) {
                if ((fd = open(tty0[i], O_WRONLY, 0)) >= 0)
                    break;
                i++;
d134 9
a142 11

            if (fd < 0)
                FatalError("xf86OpenConsole: Cannot open /dev/tty0 (%s)\n",
                           strerror(errno));

            if (xf86Info.ShareVTs) {
                SYSCALL(ret = ioctl(fd, VT_GETSTATE, &vts));
                if (ret < 0)
                    FatalError("xf86OpenConsole: Cannot find the current"
                               " VT (%s)\n", strerror(errno));
                xf86Info.vtno = vts.v_active;
d144 4
a147 7
            else {
                SYSCALL(ret = ioctl(fd, VT_OPENQRY, &xf86Info.vtno));
                if (ret < 0)
                    FatalError("xf86OpenConsole: Cannot find a free VT: "
                               "%s\n", strerror(errno));
                if (xf86Info.vtno == -1)
                    FatalError("xf86OpenConsole: Cannot find a free VT\n");
a148 1
            close(fd);
d150 2
d153 1
a153 1
        xf86Msg(from, "using VT number %d\n\n", xf86Info.vtno);
d155 6
a160 7
        /* Some of stdin / stdout / stderr maybe redirected to a file */
        for (i = STDIN_FILENO; i <= STDERR_FILENO; i++) {
            ret = fstat(i, &st);
            if (ret == 0 && S_ISCHR(st.st_mode) && major(st.st_rdev) == 4) {
                current_vt = minor(st.st_rdev);
                break;
            }
d162 1
d164 27
a190 6
        if (!KeepTty && current_vt == xf86Info.vtno) {
            xf86Msg(X_PROBED,
                    "controlling tty is VT number %d, auto-enabling KeepTty\n",
                    current_vt);
            KeepTty = TRUE;
        }
a234 12

#if 0
        if (!KeepTty) {
            /*
             * Detach from the controlling tty to avoid char loss
             */
            if ((i = open("/dev/tty", O_RDWR)) >= 0) {
                SYSCALL(ioctl(i, TIOCNOTTY, 0));
                close(i);
            }
        }
#endif
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d65 1
a65 1
static void
d71 4
a74 2
    if (ret < 0)
        FatalError("%s: VT_ACTIVATE failed: %s\n", from, strerror(errno));
d77 6
a82 2
    if (ret < 0)
        FatalError("%s: VT_WAITACTIVE failed: %s\n", from, strerror(errno));
d217 2
a218 1
            switch_to(xf86Info.vtno, "xf86OpenConsole");
d279 2
a280 1
            switch_to(xf86Info.vtno, "xf86OpenConsole");
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d79 3
a171 1
#pragma GCC diagnostic ignored "-Wformat-nonliteral"
d276 2
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d82 1
a82 1
    int i, fd = -1, ret;
d85 1
d87 2
a88 2
    char *tty0[] = { "/dev/tty0", "/dev/vc/0", NULL };
    char *vcs[] = { "/dev/vc/%d", "/dev/tty%d", NULL };
a90 6

        /* when KeepTty check if we're run with euid==0 */
        if (KeepTty && geteuid() != 0)
            FatalError("xf86OpenConsole:"
                       " Server must be suid root for option \"KeepTTY\"\n");

d130 16
d169 1
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d41 8
d224 2
a225 3
#ifdef K_OFF
            /* disable kernel special keys and buffering */
            SYSCALL(ret = ioctl(xf86Info.consoleFd, KDSKBMODE, K_OFF));
a226 1
#endif
d228 2
a229 1
                SYSCALL(ret = ioctl(xf86Info.consoleFd, KDSKBMODE, K_RAW));
d231 10
a240 5
                    FatalError("xf86OpenConsole: KDSKBMODE K_RAW failed %s\n",
                               strerror(errno));

                /* need to keep the buffer clean, else the kernel gets angry */
                xf86SetConsoleHandler(drain_console, NULL);
a252 3

            /* we really should have a InitOSInputDevices() function instead
             * of Init?$#*&Device(). So I just place it here */
d286 1
@


1.6
log
@Update to xserver 1.11.2
@
text
@a41 2
static Bool VTSwitch = TRUE;
static Bool ShareVTs = FALSE;
d46 1
a46 1
static int tty_mode; /* kbd mode to restore */
d64 1
a64 1
	FatalError("%s: VT_ACTIVATE failed: %s\n", from, strerror(errno));
d68 1
a68 1
	FatalError("%s: VT_WAITACTIVE failed: %s\n", from, strerror(errno));
d83 4
a86 23
	/* when KeepTty check if we're run with euid==0 */
	if (KeepTty && geteuid() != 0) 
	    FatalError("xf86OpenConsole:"
		       " Server must be suid root for option \"KeepTTY\"\n");

	/*
	 * setup the virtual terminal manager
	 */
	if (xf86Info.vtno != -1) {
	    from = X_CMDLINE;
	} else {

	    i=0;
	    while (tty0[i] != NULL) {
		if ((fd = open(tty0[i],O_WRONLY,0)) >= 0)
		  break;
		i++;
	    }
	    
	    if (fd < 0)
		FatalError(
		    "xf86OpenConsole: Cannot open /dev/tty0 (%s)\n",
		    strerror(errno));
d88 24
a111 6
            if (ShareVTs)
            {
		SYSCALL(ret = ioctl(fd, VT_GETSTATE, &vts));
		if (ret < 0)
		    FatalError("xf86OpenConsole: Cannot find the current"
			       " VT (%s)\n", strerror(errno));
d113 11
a123 32
            } else {
		SYSCALL(ret = ioctl(fd, VT_OPENQRY, &xf86Info.vtno));
		if (ret < 0)
		    FatalError("xf86OpenConsole: Cannot find a free VT: "
			       "%s\n", strerror(errno));
		if (xf86Info.vtno == -1)
		    FatalError("xf86OpenConsole: Cannot find a free VT\n");
	    }
	    close(fd);
	}

	xf86Msg(from, "using VT number %d\n\n", xf86Info.vtno);

	if (!KeepTty) {
	    pid_t ppid = getppid();
	    pid_t ppgid;
	    ppgid = getpgid(ppid);

	    /*
	     * change to parent process group that pgid != pid so
	     * that setsid() doesn't fail and we become process
	     * group leader
	     */
	    if (setpgid(0,ppgid) < 0)
		xf86Msg(X_WARNING, "xf86OpenConsole: setpgid failed: %s\n",
			strerror(errno));

	    /* become process group leader */
	    if ((setsid() < 0))
		xf86Msg(X_WARNING, "xf86OpenConsole: setsid failed: %s\n",
			strerror(errno));
	}
d125 24
a148 1
        i=0;
d150 3
a152 3
            sprintf(vtname, vcs[i], xf86Info.vtno); /* /dev/tty1-64 */
     	    if ((xf86Info.consoleFd = open(vtname, O_RDWR|O_NDELAY, 0)) >= 0)
		break;
d156 14
a169 14
	if (xf86Info.consoleFd < 0)
	    FatalError("xf86OpenConsole: Cannot open virtual console"
		       " %d (%s)\n", xf86Info.vtno, strerror(errno));

	/*
	 * Linux doesn't switch to an active vt after the last close of a vt,
	 * so we do this ourselves by remembering which is active now.
	 */
	SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_GETSTATE, &vts));
	if (ret < 0)
	    xf86Msg(X_WARNING,"xf86OpenConsole: VT_GETSTATE failed: %s\n",
		    strerror(errno));
	else
	    activeVT = vts.v_active;
d172 9
a180 9
	if (!KeepTty) {
	    /*
	     * Detach from the controlling tty to avoid char loss
	     */
	    if ((i = open("/dev/tty",O_RDWR)) >= 0) {
		SYSCALL(ioctl(i, TIOCNOTTY, 0));
		close(i);
	    }
	}
d183 1
a183 2
        if (!ShareVTs)
        {
d186 3
a188 3
	    /*
	     * now get the VT.  This _must_ succeed, or else fail completely.
	     */
d191 21
a211 20
	    SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_GETMODE, &VT));
	    if (ret < 0)
		FatalError("xf86OpenConsole: VT_GETMODE failed %s\n",
			   strerror(errno));

	    signal(SIGUSR1, xf86VTRequest);

	    VT.mode = VT_PROCESS;
	    VT.relsig = SIGUSR1;
	    VT.acqsig = SIGUSR1;

	    SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_SETMODE, &VT));
	    if (ret < 0)
		FatalError("xf86OpenConsole: VT_SETMODE VT_PROCESS failed: %s\n",
		    strerror(errno));

	    SYSCALL(ret = ioctl(xf86Info.consoleFd, KDSETMODE, KD_GRAPHICS));
	    if (ret < 0)
		FatalError("xf86OpenConsole: KDSETMODE KD_GRAPHICS failed %s\n",
			   strerror(errno));
d214 1
a214 1
	    SYSCALL(ioctl(xf86Info.consoleFd, KDGKBMODE, &tty_mode));
d216 14
a229 4
	    SYSCALL(ret = ioctl(xf86Info.consoleFd, KDSKBMODE, K_RAW));
	    if (ret < 0)
		FatalError("xf86OpenConsole: KDSKBMODE K_RAW failed %s\n",
			strerror(errno));
d236 2
a237 2
            nTty.c_cc[VTIME]=0;
            nTty.c_cc[VMIN]=1;
d242 2
a243 5
            /* need to keep the buffer clean, else the kernel gets angry */
	    xf86SetConsoleHandler(drain_console, NULL);

	    /* we really should have a InitOSInputDevices() function instead
	     * of Init?$#*&Device(). So I just place it here */
d245 4
a248 4
    } else { 	/* serverGeneration != 1 */
        if (!ShareVTs && VTSwitch)
        {
	    /* now get the VT */
d257 1
a257 1
    struct vt_mode   VT;
d260 1
a260 1
    if (ShareVTs) {
d274 2
a275 2
	xf86Msg(X_WARNING, "xf86CloseConsole: KDSETMODE failed: %s\n",
		strerror(errno));
d282 2
a283 2
	xf86Msg(X_WARNING, "xf86CloseConsole: VT_GETMODE failed: %s\n",
		strerror(errno));
d285 6
a290 6
	/* set dflt vt handling */
	VT.mode = VT_AUTO;
	SYSCALL(ret = ioctl(xf86Info.consoleFd, VT_SETMODE, &VT));
	if (ret < 0)
	    xf86Msg(X_WARNING, "xf86CloseConsole: VT_SETMODE failed: %s\n",
		    strerror(errno));
d293 1
a293 2
    if (VTSwitch)
    {
d299 1
a299 1
	    activeVT = -1;
d302 1
a302 1
    close(xf86Info.consoleFd);	/* make the vt-manager happy */
d308 14
a321 13
	/*
	 * Keep server from detaching from controlling tty.  This is useful
	 * when debugging (so the server can receive keyboard signals.
	 */
	if (!strcmp(argv[i], "-keeptty"))
	{
		KeepTty = TRUE;
		return 1;
	}
        if (!strcmp(argv[i], "-novtswitch"))
        {
                VTSwitch = FALSE;
                return 1;
d323 3
a325 16
        if (!strcmp(argv[i], "-sharevts"))
        {
                ShareVTs = TRUE;
                return 1;
        }
	if ((argv[i][0] == 'v') && (argv[i][1] == 't'))
	{
		if (sscanf(argv[i], "vt%2d", &xf86Info.vtno) == 0)
		{
			UseMsg();
			xf86Info.vtno = -1;
			return 0;
		}
		return 1;
	}
	return 0;
d331 3
a333 5
	ErrorF("vtXX                   use the specified VT number\n");
	ErrorF("-keeptty               ");
	ErrorF("don't detach controlling tty (for debugging only)\n");
	ErrorF("-novtswitch            don't immediately switch to new VT\n");
	ErrorF("-sharevts              share VTs with another X server\n");
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a41 1
static int VTnum = -1;
a45 1
static int vtPermSave[4];
a49 21
static int
saveVtPerms(void)
{
    /* We need to use stat to get permissions. */
    struct stat svtp;

    /* Do them numerically ordered, hard coded tty0 first. */
    if (stat("/dev/tty0", &svtp) != 0)
	return 0;
    vtPermSave[0] = (int)svtp.st_uid;
    vtPermSave[1] = (int)svtp.st_gid;

    /* Now check the console we are dealing with. */
    if (stat(vtname, &svtp) != 0)
	return 0;
    vtPermSave[2] = (int)svtp.st_uid;
    vtPermSave[3] = (int)svtp.st_gid;

    return 1;
}

d51 1
a51 1
restoreVtPerms(void)
d53 3
a55 4
    if (geteuid() == 0) {
	 /* Set the terminal permissions back to before we started. */
	 (void)chown("/dev/tty0", vtPermSave[0], vtPermSave[1]);
	 (void)chown(vtname, vtPermSave[2], vtPermSave[3]);
a58 2
static void *console_handler;

d60 1
a60 1
drain_console(int fd, void *closure)
d62 9
a70 1
    tcflush(fd, TCIOFLUSH);
d76 1
a76 1
    int i, fd = -1;
d93 1
a93 2
	if (VTnum != -1) {
	    xf86Info.vtno = VTnum;
d111 5
a115 5
                if (ioctl(fd, VT_GETSTATE, &vts) == 0)
                    xf86Info.vtno = vts.v_active;
                else
                    FatalError("xf86OpenConsole: Cannot find the current"
                               " VT (%s)\n", strerror(errno));
d117 7
a123 5
	        if ((ioctl(fd, VT_OPENQRY, &xf86Info.vtno) < 0) ||
		    (xf86Info.vtno == -1))
		    FatalError("xf86OpenConsole: Cannot find a free VT: %s\n",
                               strerror(errno));
            }
a160 28
        if (!ShareVTs)
        {
	    /*
	     * Grab the vt ownership before we overwrite it.
	     * Hard coded /dev/tty0 into this function as well for below.
	     */
	    if (!saveVtPerms())
	        xf86Msg(X_WARNING,
		        "xf86OpenConsole: Could not save ownership of VT\n");

	    if (geteuid() == 0) {
		    /* change ownership of the vt */
		    if (chown(vtname, getuid(), getgid()) < 0)
			    xf86Msg(X_WARNING,"xf86OpenConsole: chown %s failed: %s\n",
				    vtname, strerror(errno));

		    /*
		     * the current VT device we're running on is not
		     * "console", we want to grab all consoles too
		     *
		     * Why is this needed??
		     */
		    if (chown("/dev/tty0", getuid(), getgid()) < 0)
			    xf86Msg(X_WARNING,"xf86OpenConsole: chown /dev/tty0 failed: %s\n",
				    strerror(errno));
	    }
        }

d165 2
a166 1
	if (ioctl(xf86Info.consoleFd, VT_GETSTATE, &vts) < 0)
d178 1
a178 1
		ioctl(i, TIOCNOTTY, 0);
d191 1
a191 3
	    if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno) < 0)
	        FatalError("xf86OpenConsole: VT_ACTIVATE failed: %s\n",
		           strerror(errno));
d193 3
a195 2
	    if (ioctl(xf86Info.consoleFd, VT_WAITACTIVE, xf86Info.vtno) < 0)
	        FatalError("xf86OpenConsole: VT_WAITACTIVE failed: %s\n",
a197 4
	    if (ioctl(xf86Info.consoleFd, VT_GETMODE, &VT) < 0)
	        FatalError("xf86OpenConsole: VT_GETMODE failed %s\n",
		           strerror(errno));

d204 3
a206 2
	    if (ioctl(xf86Info.consoleFd, VT_SETMODE, &VT) < 0)
	        FatalError("xf86OpenConsole: VT_SETMODE VT_PROCESS failed: %s\n",
d208 5
a212 4
	
	    if (ioctl(xf86Info.consoleFd, KDSETMODE, KD_GRAPHICS) < 0)
	        FatalError("xf86OpenConsole: KDSETMODE KD_GRAPHICS failed %s\n",
		           strerror(errno));
d215 1
a215 1
            ioctl(xf86Info.consoleFd, KDGKBMODE, &tty_mode);
d217 4
a220 3
            if (ioctl(xf86Info.consoleFd, KDSKBMODE, K_RAW) < 0)
                FatalError("xf86OpenConsole: KDSKBMODE K_RAW failed %s\n",
                        strerror(errno));
d234 1
a234 3
	    if (xf86Info.allowEmptyInput)
		console_handler = xf86AddGeneralHandler(xf86Info.consoleFd,
							drain_console, NULL);
d242 2
a243 10
	    /*
	     * now get the VT
	     */
	    if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno) < 0)
	        xf86Msg(X_WARNING, "xf86OpenConsole: VT_ACTIVATE failed %s\n",
		        strerror(errno));

	    if (ioctl(xf86Info.consoleFd, VT_WAITACTIVE, xf86Info.vtno) < 0)
	        xf86Msg(X_WARNING, "xf86OpenConsole: VT_WAITACTIVE failed %s\n",
		        strerror(errno));
d252 1
d259 5
a263 4
    if (console_handler) {
	xf86RemoveGeneralHandler(console_handler);
	console_handler = NULL;
    };
d266 2
a267 1
    if (ioctl(xf86Info.consoleFd, KDSETMODE, KD_TEXT) < 0)
d271 1
a271 1
    ioctl(xf86Info.consoleFd, KDSKBMODE, tty_mode);
d274 2
a275 1
    if (ioctl(xf86Info.consoleFd, VT_GETMODE, &VT) < 0) 
d281 2
a282 1
	if (ioctl(xf86Info.consoleFd, VT_SETMODE, &VT) < 0) 
d293 1
a293 7
	    if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, activeVT) < 0)
	        xf86Msg(X_WARNING, "xf86CloseConsole: VT_ACTIVATE failed: %s\n",
		        strerror(errno));
	    if (ioctl(xf86Info.consoleFd, VT_WAITACTIVE, activeVT) < 0)
		xf86Msg(X_WARNING,
			"xf86CloseConsole: VT_WAITACTIVE failed: %s\n",
			strerror(errno));
a297 2

    restoreVtPerms();		/* restore the permissions */
d324 1
a324 1
		if (sscanf(argv[i], "vt%2d", &VTnum) == 0)
d327 1
a327 1
			VTnum = -1;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d280 3
a282 2
            console_handler = xf86AddGeneralHandler(xf86Info.consoleFd,
                    drain_console, NULL);
d369 1
a369 1
		return(1);
d374 1
a374 1
                return(1);
d379 1
a379 1
                return(1);
d387 1
a387 1
			return(0);
d389 1
a389 1
		return(1);
d391 1
a391 1
	return(0);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a37 1
#include "lnx.h"
a40 6
#ifdef USE_DEV_FB
extern char *getenv(const char *);
#include <linux/fb.h>
char *fb_dev_name;
#endif

d76 5
a80 3
    /* Set the terminal permissions back to before we started. */
    chown("/dev/tty0", vtPermSave[0], vtPermSave[1]);
    chown(vtname, vtPermSave[2], vtPermSave[3]);
a97 4
#ifdef USE_DEV_FB
    struct fb_var_screeninfo var;
    int fbfd;
#endif
a143 16
#ifdef USE_DEV_FB
        if (!ShareVTs)
        {
	    fb_dev_name=getenv("FRAMEBUFFER");
	    if (!fb_dev_name)
	        fb_dev_name="/dev/fb0current";
	
	    if ((fbfd = open(fb_dev_name, O_RDONLY)) < 0)
	        FatalError("xf86OpenConsole: Cannot open %s (%s)\n",
		           fb_dev_name, strerror(errno));

	    if (ioctl(fbfd, FBIOGET_VSCREENINFO, &var) < 0)
	        FatalError("xf86OpenConsole: Unable to get screen info %s\n",
		           strerror(errno));
        }
#endif
d188 16
a203 14
	    /* change ownership of the vt */
	    if (chown(vtname, getuid(), getgid()) < 0)
	        xf86Msg(X_WARNING,"xf86OpenConsole: chown %s failed: %s\n",
		        vtname, strerror(errno));

	    /*
	     * the current VT device we're running on is not "console", we want
	     * to grab all consoles too
	     *
	     * Why is this needed??
	     */
	    if (chown("/dev/tty0", getuid(), getgid()) < 0)
	        xf86Msg(X_WARNING,"xf86OpenConsole: chown /dev/tty0 failed: %s\n",
                    strerror(errno));
a231 3
#if defined(DO_OS_FONTRESTORE)
	    lnx_savefont();
#endif
a284 11
	
#ifdef USE_DEV_FB
	    /* copy info to new console */
	    var.yoffset=0;
	    var.xoffset=0;
	    if (ioctl(fbfd, FBIOPUT_VSCREENINFO, &var))
	        FatalError("Unable to set screen info\n");
	    close(fbfd);
#endif
        } else { /* ShareVTs */
            close(xf86Info.consoleFd);
a285 1
	signal(SIGUSR2, xf86ReloadInputDevs);
a294 1
        }
d299 1
a300 1
    return;
d304 1
a304 1
xf86CloseConsole()
a306 4
#if defined(DO_OS_FONTRESTORE)
    struct vt_stat vts;
    int vtno = -1;
#endif
d308 4
a311 1
    if (ShareVTs) return;
a317 8
#if defined(DO_OS_FONTRESTORE)
    if (ioctl(xf86Info.consoleFd, VT_GETSTATE, &vts) < 0)
	xf86Msg(X_WARNING, "xf86CloseConsole: VT_GETSTATE failed: %s\n",
		strerror(errno));
    else
	vtno = vts.v_active;
#endif

a351 6

#if defined(DO_OS_FONTRESTORE)
        if (xf86Info.vtno == vtno)	/* check if we are active */
	    lnx_restorefont();
        lnx_freefontdata();
#endif
a355 2

    return;
d394 1
a394 1
xf86UseMsg()
d399 2
a400 3
        ErrorF("-novtswitch            don't immediately switch to new VT\n");
        ErrorF("-sharevts              share VTs with another X server\n");
	return;
@


1.2
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d253 2
d287 21
a307 31
	    /* Set the keyboard to RAW mode. If we're using the keyboard
	     * driver, the driver does it for us. If we have AEI on, then
	     * we're expecting the devices to be added (i.e. evdev) and we
	     * have to set it manually.
	     */
	    if (xf86Info.allowEmptyInput)
	    {
		struct termios nTty;

		tcgetattr(xf86Info.consoleFd, &tty_attr);
		ioctl(xf86Info.consoleFd, KDGKBMODE, &tty_mode);

		if (ioctl(xf86Info.consoleFd, KDSKBMODE, K_RAW) < 0)
		    FatalError("xf86OpenConsole: KDSKBMODE K_RAW failed %s\n",
			    strerror(errno));

		nTty = tty_attr;
		nTty.c_iflag = (IGNPAR | IGNBRK) & (~PARMRK) & (~ISTRIP);
		nTty.c_oflag = 0;
		nTty.c_cflag = CREAD | CS8;
		nTty.c_lflag = 0;
		nTty.c_cc[VTIME]=0;
		nTty.c_cc[VMIN]=1;
		cfsetispeed(&nTty, 9600);
		cfsetospeed(&nTty, 9600);
		tcsetattr(xf86Info.consoleFd, TCSANOW, &nTty);

		/* need to keep the buffer clean, else the kernel gets angry */
		console_handler = xf86AddGeneralHandler(xf86Info.consoleFd,
							drain_console, NULL);
	    }
@


1.1
log
@Initial revision
@
text
@a24 1
/* $XConsortium: lnx_init.c /main/7 1996/10/23 18:46:30 kaleb $ */
d56 2
d88 8
d257 1
a257 1
	     * now get the VT
d260 2
a261 2
	        xf86Msg(X_WARNING, "xf86OpenConsole: VT_ACTIVATE failed: %s\n",
		        strerror(errno));
d264 2
a265 2
	        xf86Msg(X_WARNING, "xf86OpenConsole: VT_WAITACTIVE failed: %s\n",
		    strerror(errno));
d285 32
d361 5
d378 4
a381 1
	
d402 4
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d25 1
d248 1
a248 1
	     * now get the VT.  This _must_ succeed, or else fail completely.
d251 2
a252 2
	        FatalError("xf86OpenConsole: VT_ACTIVATE failed: %s\n",
		           strerror(errno));
d255 2
a256 2
	        FatalError("xf86OpenConsole: VT_WAITACTIVE failed: %s\n",
			   strerror(errno));
a352 4
	    if (ioctl(xf86Info.consoleFd, VT_WAITACTIVE, activeVT) < 0)
		xf86Msg(X_WARNING,
			"xf86CloseConsole: VT_WAITACTIVE failed: %s\n",
			strerror(errno));
@

