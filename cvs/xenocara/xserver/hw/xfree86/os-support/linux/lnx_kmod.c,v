head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.8
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.6
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.4
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.10
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	Te1daavkBLskZ8gc;

1.4
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	cVXoV5PxI8YrEaVA;

1.3
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include "xf86_OSlib.h"
#include "xf86.h"

#define MODPROBE_PATH_FILE      "/proc/sys/kernel/modprobe"
#define MAX_PATH                1024

#if 0
/* XFree86 #defines execl to be the xf86execl() function which does
 * a fork AND exec.  We don't want that.  We want the regular,
 * standard execl().
 */
#ifdef execl
#undef execl
#endif
#endif

/*
 * Load a Linux kernel module.
 * This is used by the DRI/DRM to load a DRM kernel module when
 * the X server starts.  It could be used for other purposes in the future.
 * Input:
 *    modName - name of the kernel module (Ex: "tdfx")
 * Return:
 *    0 for failure, 1 for success
 */
int
xf86LoadKernelModule(const char *modName)
{
    char mpPath[MAX_PATH] = "";
    int fd = -1, status;
    pid_t pid;

    /* get the path to the modprobe program */
    fd = open(MODPROBE_PATH_FILE, O_RDONLY);
    if (fd >= 0) {
        int count = read(fd, mpPath, MAX_PATH - 1);

        if (count <= 0) {
            mpPath[0] = 0;
        }
        else if (mpPath[count - 1] == '\n') {
            mpPath[count - 1] = 0;      /* replaces \n with \0 */
        }
        close(fd);
        /* if this worked, mpPath will be "/sbin/modprobe" or similar. */
    }

    if (mpPath[0] == 0) {
        /* we failed to get the path from the system, use a default */
        strcpy(mpPath, "/sbin/modprobe");
    }

    /* now fork/exec the modprobe command */
    /*
     * It would be good to capture stdout/stderr so that it can be directed
     * to the log file.  modprobe errors currently are missing from the log
     * file.
     */
    switch (pid = fork()) {
    case 0:                    /* child */
        /* change real/effective user ID to 0/0 as we need to
         * preinstall agpgart module for some DRM modules
         */
        if (setreuid(0, 0)) {
            xf86Msg(X_WARNING, "LoadKernelModule: "
                    "Setting of real/effective user Id to 0/0 failed");
        }
        setenv("PATH", "/sbin", 1);
        execl(mpPath, "modprobe", modName, NULL);
        xf86Msg(X_WARNING, "LoadKernelModule %s\n", strerror(errno));
        exit(EXIT_FAILURE);     /* if we get here the child's exec failed */
        break;
    case -1:                   /* fork failed */
        return 0;
    default:                   /* fork worked */
    {
        /* XXX we loop over waitpid() because it sometimes fails on
         * the first attempt.  Don't know why!
         */
        int count = 0, p;

        do {
            p = waitpid(pid, &status, 0);
        } while (p == -1 && count++ < 4);

        if (p == -1) {
            return 0;
        }

        if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
            return 1;           /* success! */
        }
        else {
            return 0;
        }
    }
    }

    /* never get here */
    return 0;
}
@


1.4
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d72 1
a72 1
         * preinstall agpgart module for some DRM modules 
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d40 1
a40 1
    int fd = -1, status, n;
d79 1
a79 1
        n = execl(mpPath, "modprobe", modName, NULL);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a13 1

a16 1

a26 1

d39 54
a92 52
   char mpPath[MAX_PATH] = "";
   int fd = -1, status, n;
   pid_t pid;

   /* get the path to the modprobe program */
   fd = open(MODPROBE_PATH_FILE, O_RDONLY);
   if (fd >= 0) {
      int count = read(fd, mpPath, MAX_PATH - 1);
      if (count <= 0) {
         mpPath[0] = 0;
      }
      else if (mpPath[count - 1] == '\n') {
         mpPath[count - 1] = 0;  /* replaces \n with \0 */
      }
      close(fd);
      /* if this worked, mpPath will be "/sbin/modprobe" or similar. */
   }

   if (mpPath[0] == 0) {
      /* we failed to get the path from the system, use a default */
      strcpy(mpPath, "/sbin/modprobe");
   }

   /* now fork/exec the modprobe command */
   /*
    * It would be good to capture stdout/stderr so that it can be directed
    * to the log file.  modprobe errors currently are missing from the log
    * file.
    */
   switch (pid = fork()) {
   case 0:  /* child */
      /* change real/effective user ID to 0/0 as we need to
       * preinstall agpgart module for some DRM modules 
       */
      if (setreuid(0,0)) {
         xf86Msg(X_WARNING,"LoadKernelModule: "
		 "Setting of real/effective user Id to 0/0 failed");
      }
      setenv("PATH","/sbin",1);
      n = execl(mpPath, "modprobe", modName, NULL);
      xf86Msg(X_WARNING,"LoadKernelModule %s\n",strerror(errno));
      exit(EXIT_FAILURE);  /* if we get here the child's exec failed */
      break;
   case -1:  /* fork failed */
      return 0;
   default:  /* fork worked */
      {
         /* XXX we loop over waitpid() because it sometimes fails on
          * the first attempt.  Don't know why!
          */
         int count = 0, p;
         do {
d94 1
a94 1
         } while (p == -1 && count++ < 4);
d96 1
a96 1
         if (p == -1) {
d98 1
a98 1
         }
d100 4
a103 4
         if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
            return 1;  /* success! */
         }
         else {
d105 3
a107 3
         }
      }
   }
d109 2
a110 2
   /* never get here */
   return 0;
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
_X_EXPORT int
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
