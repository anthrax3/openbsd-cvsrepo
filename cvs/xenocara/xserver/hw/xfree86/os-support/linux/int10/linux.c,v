head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.27;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.23;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.09.39;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.57.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * linux specific part of the int10 module
 * Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2008 Egbert Eich
 */
#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86Pci.h"
#include "compiler.h"
#define _INT10_PRIVATE
#include "xf86int10.h"
#ifdef __sparc__
#define DEV_MEM "/dev/fb"
#else
#define DEV_MEM "/dev/mem"
#endif
#define ALLOC_ENTRIES(x) ((V_RAM / x) - 1)
#define SHMERRORPTR (void *)(-1)

#include <fcntl.h>
#include <errno.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <string.h>

static int counter = 0;
static unsigned long int10Generation = 0;

static CARD8 read_b(xf86Int10InfoPtr pInt, int addr);
static CARD16 read_w(xf86Int10InfoPtr pInt, int addr);
static CARD32 read_l(xf86Int10InfoPtr pInt, int addr);
static void write_b(xf86Int10InfoPtr pInt, int addr, CARD8 val);
static void write_w(xf86Int10InfoPtr pInt, int addr, CARD16 val);
static void write_l(xf86Int10InfoPtr pInt, int addr, CARD32 val);

int10MemRec linuxMem = {
    read_b,
    read_w,
    read_l,
    write_b,
    write_w,
    write_l
};

typedef struct {
    int lowMem;
    int highMem;
    char *base;
    char *base_high;
    char *alloc;
} linuxInt10Priv;

#if defined DoSubModules

typedef enum {
    INT10_NOT_LOADED,
    INT10_LOADED_VM86,
    INT10_LOADED_X86EMU,
    INT10_LOAD_FAILED
} Int10LinuxSubModuleState;

static Int10LinuxSubModuleState loadedSubModule = INT10_NOT_LOADED;

static Int10LinuxSubModuleState int10LinuxLoadSubModule(ScrnInfoPtr pScrn);

#endif                          /* DoSubModules */

static Bool
readLegacy(struct pci_device *dev, unsigned char *buf, int base, int len)
{
    void *map;

    if (pci_device_map_legacy(dev, base, len, 0, &map))
        return FALSE;

    memcpy(buf, map, len);
    pci_device_unmap_legacy(dev, man, len);

    return TRUE;
}

xf86Int10InfoPtr
xf86ExtendedInitInt10(int entityIndex, int Flags)
{
    xf86Int10InfoPtr pInt = NULL;
    int screen;
    int fd;
    static void *vidMem = NULL;
    static void *sysMem = NULL;
    void *vMem = NULL;
    void *options = NULL;
    int low_mem;
    int high_mem = -1;
    char *base = SHMERRORPTR;
    char *base_high = SHMERRORPTR;
    int pagesize;
    memType cs;
    legacyVGARec vga;
    Bool videoBiosMapped = FALSE;
    ScrnInfoPtr pScrn;
    if (int10Generation != serverGeneration) {
        counter = 0;
        int10Generation = serverGeneration;
    }

    pScrn = xf86FindScreenForEntity(entityIndex);
    screen = pScrn->scrnIndex;

    options = xf86HandleInt10Options(pScrn, entityIndex);

    if (int10skip(options)) {
        free(options);
        return NULL;
    }

#if defined DoSubModules
    if (loadedSubModule == INT10_NOT_LOADED)
        loadedSubModule = int10LinuxLoadSubModule(pScrn);

    if (loadedSubModule == INT10_LOAD_FAILED)
        return NULL;
#endif

    if ((!vidMem) || (!sysMem)) {
        if ((fd = open(DEV_MEM, O_RDWR, 0)) >= 0) {
            if (!sysMem) {
                DebugF("Mapping sys bios area\n");
                if ((sysMem = mmap((void *) (SYS_BIOS), BIOS_SIZE,
                                   PROT_READ | PROT_EXEC,
                                   MAP_SHARED | MAP_FIXED, fd, SYS_BIOS))
                    == MAP_FAILED) {
                    xf86DrvMsg(screen, X_ERROR, "Cannot map SYS BIOS\n");
                    close(fd);
                    goto error0;
                }
            }
            if (!vidMem) {
                DebugF("Mapping VRAM area\n");
                if ((vidMem = mmap((void *) (V_RAM), VRAM_SIZE,
                                   PROT_READ | PROT_WRITE | PROT_EXEC,
                                   MAP_SHARED | MAP_FIXED, fd, V_RAM))
                    == MAP_FAILED) {
                    xf86DrvMsg(screen, X_ERROR, "Cannot map V_RAM\n");
                    close(fd);
                    goto error0;
                }
            }
            close(fd);
        }
        else {
            xf86DrvMsg(screen, X_ERROR, "Cannot open %s\n", DEV_MEM);
            goto error0;
        }
    }

    pInt = (xf86Int10InfoPtr) xnfcalloc(1, sizeof(xf86Int10InfoRec));
    pInt->pScrn = pScrn;
    pInt->entityIndex = entityIndex;
    pInt->dev = xf86GetPciInfoForEntity(entityIndex);

    if (!xf86Int10ExecSetup(pInt))
        goto error0;
    pInt->mem = &linuxMem;
    pagesize = getpagesize();
    pInt->private = (void *) xnfcalloc(1, sizeof(linuxInt10Priv));
    ((linuxInt10Priv *) pInt->private)->alloc =
        (void *) xnfcalloc(1, ALLOC_ENTRIES(pagesize));

    if (!xf86IsEntityPrimary(entityIndex)) {
        DebugF("Mapping high memory area\n");
        if ((high_mem = shmget(counter++, HIGH_MEM_SIZE,
                               IPC_CREAT | SHM_R | SHM_W)) == -1) {
            if (errno == ENOSYS)
                xf86DrvMsg(screen, X_ERROR, "shmget error\n Please reconfigure"
                           " your kernel to include System V IPC support\n");
            else
                xf86DrvMsg(screen, X_ERROR,
                           "shmget(highmem) error: %s\n", strerror(errno));
            goto error1;
        }
    }
    else {
        DebugF("Mapping Video BIOS\n");
        videoBiosMapped = TRUE;
        if ((fd = open(DEV_MEM, O_RDWR, 0)) >= 0) {
            if ((vMem = mmap((void *) (V_BIOS), SYS_BIOS - V_BIOS,
                             PROT_READ | PROT_WRITE | PROT_EXEC,
                             MAP_SHARED | MAP_FIXED, fd, V_BIOS))
                == MAP_FAILED) {
                xf86DrvMsg(screen, X_ERROR, "Cannot map V_BIOS\n");
                close(fd);
                goto error1;
            }
            close(fd);
        }
        else
            goto error1;
    }
    ((linuxInt10Priv *) pInt->private)->highMem = high_mem;

    DebugF("Mapping 640kB area\n");
    if ((low_mem = shmget(counter++, V_RAM, IPC_CREAT | SHM_R | SHM_W)) == -1) {
        xf86DrvMsg(screen, X_ERROR,
                   "shmget(lowmem) error: %s\n", strerror(errno));
        goto error2;
    }

    ((linuxInt10Priv *) pInt->private)->lowMem = low_mem;
    base = shmat(low_mem, 0, 0);
    if (base == SHMERRORPTR) {
        xf86DrvMsg(screen, X_ERROR,
                   "shmat(low_mem) error: %s\n", strerror(errno));
        goto error3;
    }
    ((linuxInt10Priv *) pInt->private)->base = base;
    if (high_mem > -1) {
        base_high = shmat(high_mem, 0, 0);
        if (base_high == SHMERRORPTR) {
            xf86DrvMsg(screen, X_ERROR,
                       "shmat(high_mem) error: %s\n", strerror(errno));
            goto error3;
        }
        ((linuxInt10Priv *) pInt->private)->base_high = base_high;
    }
    else
        ((linuxInt10Priv *) pInt->private)->base_high = NULL;

    if (!MapCurrentInt10(pInt))
        goto error3;

    Int10Current = pInt;

    DebugF("Mapping int area\n");
    /* note: yes, we really are writing the 0 page here */
    if (!readLegacy(pInt->dev, (unsigned char *) 0, 0, LOW_PAGE_SIZE)) {
        xf86DrvMsg(screen, X_ERROR, "Cannot read int vect\n");
        goto error3;
    }
    DebugF("done\n");
    /*
     * Read in everything between V_BIOS and SYS_BIOS as some system BIOSes
     * have executable code there.  Note that xf86ReadBIOS() can only bring in
     * 64K bytes at a time.
     */
    if (!videoBiosMapped) {
        memset((void *) V_BIOS, 0, SYS_BIOS - V_BIOS);
        DebugF("Reading BIOS\n");
        for (cs = V_BIOS; cs < SYS_BIOS; cs += V_BIOS_SIZE)
            if (!readLegacy(pInt->dev, (void *)cs, cs, V_BIOS_SIZE))
                xf86DrvMsg(screen, X_WARNING,
                           "Unable to retrieve all of segment 0x%06lX.\n",
                           (long) cs);
        DebugF("done\n");
    }

    if (xf86IsEntityPrimary(entityIndex) && !(initPrimary(options))) {
        if (!xf86int10GetBiosSegment(pInt, NULL))
            goto error3;

        set_return_trap(pInt);
#ifdef _PC
        pInt->Flags = Flags & (SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
        if (!(pInt->Flags & SET_BIOS_SCRATCH))
            pInt->Flags &= ~RESTORE_BIOS_SCRATCH;
        xf86Int10SaveRestoreBIOSVars(pInt, TRUE);
#endif
    }
    else {
        const BusType location_type = xf86int10GetBiosLocationType(pInt);

        switch (location_type) {
        case BUS_PCI:{
            int err;
            struct pci_device *rom_device =
                xf86GetPciInfoForEntity(pInt->entityIndex);

            pci_device_enable(rom_device);
            err = pci_device_read_rom(rom_device, (unsigned char *) (V_BIOS));
            if (err) {
                xf86DrvMsg(screen, X_ERROR, "Cannot read V_BIOS (%s)\n",
                           strerror(err));
                goto error3;
            }

            pInt->BIOSseg = V_BIOS >> 4;
            break;
        }
        default:
            goto error3;
        }

        pInt->num = 0xe6;
        reset_int_vect(pInt);
        set_return_trap(pInt);
        LockLegacyVGA(pInt, &vga);
        xf86ExecX86int10(pInt);
        UnlockLegacyVGA(pInt, &vga);
    }
#ifdef DEBUG
    dprint(0xc0000, 0x20);
#endif

    free(options);
    return pInt;

 error3:
    if (base_high)
        shmdt(base_high);
    shmdt(base);
    shmdt(0);
    if (base_high)
        shmdt((char *) HIGH_MEM);
    shmctl(low_mem, IPC_RMID, NULL);
    Int10Current = NULL;
 error2:
    if (high_mem > -1)
        shmctl(high_mem, IPC_RMID, NULL);
 error1:
    if (vMem)
        munmap(vMem, SYS_BIOS - V_BIOS);
    free(((linuxInt10Priv *) pInt->private)->alloc);
    free(pInt->private);
 error0:
    free(options);
    free(pInt);
    return NULL;
}

Bool
MapCurrentInt10(xf86Int10InfoPtr pInt)
{
    void *addr;
    int fd = -1;

    if (Int10Current) {
        shmdt(0);
        if (((linuxInt10Priv *) Int10Current->private)->highMem >= 0)
            shmdt((char *) HIGH_MEM);
        else
            munmap((void *) V_BIOS, (SYS_BIOS - V_BIOS));
    }
    addr =
        shmat(((linuxInt10Priv *) pInt->private)->lowMem, (char *) 1, SHM_RND);
    if (addr == SHMERRORPTR) {
        xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR, "Cannot shmat() low memory\n");
        xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR,
                   "shmat(low_mem) error: %s\n", strerror(errno));
        return FALSE;
    }
    if (mprotect((void *) 0, V_RAM, PROT_READ | PROT_WRITE | PROT_EXEC) != 0)
        xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR,
                   "Cannot set EXEC bit on low memory: %s\n", strerror(errno));

    if (((linuxInt10Priv *) pInt->private)->highMem >= 0) {
        addr = shmat(((linuxInt10Priv *) pInt->private)->highMem,
                     (char *) HIGH_MEM, 0);
        if (addr == SHMERRORPTR) {
            xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR,
                       "Cannot shmat() high memory\n");
            xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR,
                       "shmget error: %s\n", strerror(errno));
            return FALSE;
        }
        if (mprotect((void *) HIGH_MEM, HIGH_MEM_SIZE,
                     PROT_READ | PROT_WRITE | PROT_EXEC) != 0)
            xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR,
                       "Cannot set EXEC bit on high memory: %s\n",
                       strerror(errno));
    }
    else {
        if ((fd = open(DEV_MEM, O_RDWR, 0)) >= 0) {
            if (mmap((void *) (V_BIOS), SYS_BIOS - V_BIOS,
                     PROT_READ | PROT_WRITE | PROT_EXEC,
                     MAP_SHARED | MAP_FIXED, fd, V_BIOS)
                == MAP_FAILED) {
                xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR, "Cannot map V_BIOS\n");
                close(fd);
                return FALSE;
            }
        }
        else {
            xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR, "Cannot open %s\n", DEV_MEM);
            return FALSE;
        }
        close(fd);
    }

    return TRUE;
}

void
xf86FreeInt10(xf86Int10InfoPtr pInt)
{
    if (!pInt)
        return;

#ifdef _PC
    xf86Int10SaveRestoreBIOSVars(pInt, FALSE);
#endif
    if (Int10Current == pInt) {
        shmdt(0);
        if (((linuxInt10Priv *) pInt->private)->highMem >= 0)
            shmdt((char *) HIGH_MEM);
        else
            munmap((void *) V_BIOS, (SYS_BIOS - V_BIOS));
        Int10Current = NULL;
    }

    if (((linuxInt10Priv *) pInt->private)->base_high)
        shmdt(((linuxInt10Priv *) pInt->private)->base_high);
    shmdt(((linuxInt10Priv *) pInt->private)->base);
    shmctl(((linuxInt10Priv *) pInt->private)->lowMem, IPC_RMID, NULL);
    if (((linuxInt10Priv *) pInt->private)->highMem >= 0)
        shmctl(((linuxInt10Priv *) pInt->private)->highMem, IPC_RMID, NULL);
    free(((linuxInt10Priv *) pInt->private)->alloc);
    free(pInt->private);
    free(pInt);
}

void *
xf86Int10AllocPages(xf86Int10InfoPtr pInt, int num, int *off)
{
    int pagesize = getpagesize();
    int num_pages = ALLOC_ENTRIES(pagesize);
    int i, j;

    for (i = 0; i < (num_pages - num); i++) {
        if (((linuxInt10Priv *) pInt->private)->alloc[i] == 0) {
            for (j = i; j < (num + i); j++)
                if ((((linuxInt10Priv *) pInt->private)->alloc[j] != 0))
                    break;
            if (j == (num + i))
                break;
            else
                i = i + num;
        }
    }
    if (i == (num_pages - num))
        return NULL;

    for (j = i; j < (i + num); j++)
        ((linuxInt10Priv *) pInt->private)->alloc[j] = 1;

    *off = (i + 1) * pagesize;

    return ((linuxInt10Priv *) pInt->private)->base + ((i + 1) * pagesize);
}

void
xf86Int10FreePages(xf86Int10InfoPtr pInt, void *pbase, int num)
{
    int pagesize = getpagesize();
    int first = (((unsigned long) pbase
                  - (unsigned long) ((linuxInt10Priv *) pInt->private)->base)
                 / pagesize) - 1;
    int i;

    for (i = first; i < (first + num); i++)
        ((linuxInt10Priv *) pInt->private)->alloc[i] = 0;
}

static CARD8
read_b(xf86Int10InfoPtr pInt, int addr)
{
    return *((CARD8 *) (memType) addr);
}

static CARD16
read_w(xf86Int10InfoPtr pInt, int addr)
{
    return *((CARD16 *) (memType) addr);
}

static CARD32
read_l(xf86Int10InfoPtr pInt, int addr)
{
    return *((CARD32 *) (memType) addr);
}

static void
write_b(xf86Int10InfoPtr pInt, int addr, CARD8 val)
{
    *((CARD8 *) (memType) addr) = val;
}

static void
write_w(xf86Int10InfoPtr pInt, int addr, CARD16 val)
{
    *((CARD16 *) (memType) addr) = val;
}

static
    void
write_l(xf86Int10InfoPtr pInt, int addr, CARD32 val)
{
    *((CARD32 *) (memType) addr) = val;
}

void *
xf86int10Addr(xf86Int10InfoPtr pInt, CARD32 addr)
{
    if (addr < V_RAM)
        return ((linuxInt10Priv *) pInt->private)->base + addr;
    else if (addr < V_BIOS)
        return (void *) (memType) addr;
    else if (addr < SYS_BIOS) {
        if (((linuxInt10Priv *) pInt->private)->base_high)
            return (void *) (((linuxInt10Priv *) pInt->private)->base_high
                              - V_BIOS + addr);
        else
            return (void *) (memType) addr;
    }
    else
        return (void *) (memType) addr;
}

#if defined DoSubModules

static Bool
vm86_tst(void)
{
    int __res;

#ifdef __PIC__
    /* When compiling with -fPIC, we can't use asm constraint "b" because
       %ebx is already taken by gcc. */
    __asm__ __volatile__("pushl %%ebx\n\t"
                         "movl %2,%%ebx\n\t"
                         "movl %1,%%eax\n\t"
                         "int $0x80\n\t" "popl %%ebx":"=a"(__res)
                         :"n"((int) 113), "r"(NULL));
#else
    __asm__ __volatile__("int $0x80\n\t":"=a"(__res):"a"((int) 113),
                         "b"((struct vm86_struct *) NULL));
#endif

    if (__res < 0 && __res == -ENOSYS)
        return FALSE;

    return TRUE;
}

static Int10LinuxSubModuleState
int10LinuxLoadSubModule(ScrnInfoPtr pScrn)
{
    if (vm86_tst()) {
        if (xf86LoadSubModule(pScrn, "vm86"))
            return INT10_LOADED_VM86;
    }
    if (xf86LoadSubModule(pScrn, "x86emu"))
        return INT10_LOADED_X86EMU;

    return INT10_LOAD_FAILED;
}

#endif                          /* DoSubModules */
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d73 14
d239 2
a240 1
    if (xf86ReadBIOS(0, 0, (unsigned char *) 0, LOW_PAGE_SIZE) < 0) {
d254 1
a254 1
            if (xf86ReadBIOS(cs, 0, (void *) cs, V_BIOS_SIZE) < V_BIOS_SIZE)
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d21 1
a21 1
#define SHMERRORPTR (pointer)(-1)
d156 1
a156 1
    pInt->private = (pointer) xnfcalloc(1, sizeof(linuxInt10Priv));
d158 1
a158 1
        (pointer) xnfcalloc(1, ALLOC_ENTRIES(pagesize));
d236 1
a236 1
        memset((pointer) V_BIOS, 0, SYS_BIOS - V_BIOS);
d239 1
a239 1
            if (xf86ReadBIOS(cs, 0, (pointer) cs, V_BIOS_SIZE) < V_BIOS_SIZE)
d322 1
a322 1
    pointer addr;
d330 1
a330 1
            munmap((pointer) V_BIOS, (SYS_BIOS - V_BIOS));
d395 1
a395 1
            munmap((pointer) V_BIOS, (SYS_BIOS - V_BIOS));
d489 1
a489 1
pointer
d495 1
a495 1
        return (pointer) (memType) addr;
d498 1
a498 1
            return (pointer) (((linuxInt10Priv *) pInt->private)->base_high
d501 1
a501 1
            return (pointer) (memType) addr;
d504 1
a504 1
        return (pointer) (memType) addr;
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a54 1
    int screen;
d91 1
a91 1

d97 2
a98 1
    screen = (xf86FindScreenForEntity(entityIndex))->scrnIndex;
d100 1
a100 1
    options = xf86HandleInt10Options(xf86Screens[screen], entityIndex);
d109 1
a109 1
        loadedSubModule = int10LinuxLoadSubModule(xf86Screens[screen]);
d148 1
a148 1
    pInt->scrnIndex = screen;
a156 1
    ((linuxInt10Priv *) pInt->private)->screen = screen;
d335 2
a336 2
        xf86DrvMsg(pInt->scrnIndex, X_ERROR, "Cannot shmat() low memory\n");
        xf86DrvMsg(pInt->scrnIndex, X_ERROR,
d341 1
a341 1
        xf86DrvMsg(pInt->scrnIndex, X_ERROR,
d348 1
a348 1
            xf86DrvMsg(pInt->scrnIndex, X_ERROR,
d350 1
a350 1
            xf86DrvMsg(pInt->scrnIndex, X_ERROR,
d356 1
a356 1
            xf86DrvMsg(pInt->scrnIndex, X_ERROR,
d366 1
a366 1
                xf86DrvMsg(pInt->scrnIndex, X_ERROR, "Cannot map V_BIOS\n");
d372 1
a372 1
            xf86DrvMsg(pInt->scrnIndex, X_ERROR, "Cannot open %s\n", DEV_MEM);
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d53 2
a54 2
    char* base;
    char* base_high;
d56 1
a56 1
    char* alloc;
d72 1
a72 1
#endif /* DoSubModules */
d80 3
a82 3
    static void* vidMem = NULL;
    static void* sysMem = NULL;
    void* vMem = NULL;
d88 1
a88 1
    int pagesize; 
d92 1
a92 1
    
d94 2
a95 2
	counter = 0;
	int10Generation = serverGeneration;
d100 1
a100 1
    options = xf86HandleInt10Options(xf86Screens[screen],entityIndex);
d103 2
a104 2
	free(options);
	return NULL;
d108 2
a109 2
    if (loadedSubModule == INT10_NOT_LOADED) 
	loadedSubModule = int10LinuxLoadSubModule(xf86Screens[screen]);
d112 1
a112 1
	return NULL;
d116 29
a144 28
	if ((fd = open(DEV_MEM, O_RDWR, 0)) >= 0) {
	    if (!sysMem) {
		DebugF("Mapping sys bios area\n");
		if ((sysMem = mmap((void *)(SYS_BIOS), BIOS_SIZE,
				   PROT_READ | PROT_EXEC,
				   MAP_SHARED | MAP_FIXED, fd, SYS_BIOS))
		    == MAP_FAILED) {
		    xf86DrvMsg(screen, X_ERROR, "Cannot map SYS BIOS\n");
		    close(fd);
		    goto error0;
		}
	    }
	    if (!vidMem) {
		DebugF("Mapping VRAM area\n");
		if ((vidMem = mmap((void *)(V_RAM), VRAM_SIZE,
				   PROT_READ | PROT_WRITE | PROT_EXEC,
				   MAP_SHARED | MAP_FIXED, fd, V_RAM))
		    == MAP_FAILED) {
		    xf86DrvMsg(screen, X_ERROR, "Cannot map V_RAM\n");
		    close(fd);
		    goto error0;
		}
	    }
	    close(fd);
	} else {
	    xf86DrvMsg(screen, X_ERROR, "Cannot open %s\n", DEV_MEM);
	    goto error0;
	}
d147 1
a147 1
    pInt = (xf86Int10InfoPtr)xnfcalloc(1, sizeof(xf86Int10InfoRec));
d153 1
a153 1
	goto error0;
d156 4
a159 4
    pInt->private = (pointer)xnfcalloc(1, sizeof(linuxInt10Priv));
    ((linuxInt10Priv*)pInt->private)->screen = screen;
    ((linuxInt10Priv*)pInt->private)->alloc =
	(pointer)xnfcalloc(1, ALLOC_ENTRIES(pagesize));
d162 28
a189 26
	DebugF("Mapping high memory area\n");
	if ((high_mem = shmget(counter++, HIGH_MEM_SIZE,
			       IPC_CREAT | SHM_R | SHM_W)) == -1) {
	    if (errno == ENOSYS)
		xf86DrvMsg(screen, X_ERROR, "shmget error\n Please reconfigure"
			   " your kernel to include System V IPC support\n");
	    else
		xf86DrvMsg(screen, X_ERROR,
			   "shmget(highmem) error: %s\n",strerror(errno));
	    goto error1;
	}
    } else {
	DebugF("Mapping Video BIOS\n");
	videoBiosMapped = TRUE;
	if ((fd = open(DEV_MEM, O_RDWR, 0)) >= 0) {
	    if ((vMem = mmap((void *)(V_BIOS), SYS_BIOS - V_BIOS,
			     PROT_READ | PROT_WRITE | PROT_EXEC,
			     MAP_SHARED | MAP_FIXED, fd, V_BIOS))
		== MAP_FAILED) {
		xf86DrvMsg(screen, X_ERROR, "Cannot map V_BIOS\n");
		close(fd);
		goto error1;
	    }
	    close (fd);
	} else
	    goto error1;
d191 2
a192 2
    ((linuxInt10Priv*)pInt->private)->highMem = high_mem;
    
d194 4
a197 5
    if ((low_mem = shmget(counter++, V_RAM,
			  IPC_CREAT | SHM_R | SHM_W)) == -1) {
	xf86DrvMsg(screen, X_ERROR,
		   "shmget(lowmem) error: %s\n",strerror(errno));
	goto error2;
d200 1
a200 1
    ((linuxInt10Priv*)pInt->private)->lowMem = low_mem;
d203 3
a205 3
	xf86DrvMsg(screen, X_ERROR,
		   "shmat(low_mem) error: %s\n",strerror(errno));
	goto error3;
d207 1
a207 1
    ((linuxInt10Priv *)pInt->private)->base = base;
d209 10
a218 9
	base_high = shmat(high_mem, 0, 0);
	if (base_high == SHMERRORPTR) {
	    xf86DrvMsg(screen, X_ERROR,
		       "shmat(high_mem) error: %s\n",strerror(errno));
	    goto error3;
	}
	((linuxInt10Priv*)pInt->private)->base_high = base_high;
    } else
	((linuxInt10Priv*)pInt->private)->base_high = NULL;
d221 2
a222 2
	goto error3;
    
d226 3
a228 3
    if (xf86ReadBIOS(0, 0, (unsigned char *)0, LOW_PAGE_SIZE) < 0) {
	xf86DrvMsg(screen, X_ERROR, "Cannot read int vect\n");
	goto error3;
d237 8
a244 8
	memset((pointer)V_BIOS, 0, SYS_BIOS - V_BIOS);
	DebugF("Reading BIOS\n");
	for (cs = V_BIOS;  cs < SYS_BIOS;  cs += V_BIOS_SIZE)
	    if (xf86ReadBIOS(cs, 0, (pointer)cs, V_BIOS_SIZE) < V_BIOS_SIZE)
		xf86DrvMsg(screen, X_WARNING,
			   "Unable to retrieve all of segment 0x%06lX.\n",
			   (long)cs);
	DebugF("done\n");
d248 2
a249 2
	if (!xf86int10GetBiosSegment(pInt, NULL))
	    goto error3;
d251 6
a256 18
	set_return_trap(pInt);
#ifdef _PC	
	pInt->Flags = Flags & (SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
	if (! (pInt->Flags & SET_BIOS_SCRATCH))
	    pInt->Flags &= ~RESTORE_BIOS_SCRATCH;
  	xf86Int10SaveRestoreBIOSVars(pInt, TRUE);
#endif
    } else {
	const BusType location_type = xf86int10GetBiosLocationType(pInt);

	switch (location_type) {
	case BUS_PCI: {
	    int err;
	    struct pci_device *rom_device =
		xf86GetPciInfoForEntity(pInt->entityIndex);

#if HAVE_PCI_DEVICE_ENABLE
	    pci_device_enable(rom_device);
d258 3
d262 27
a288 20
	    err = pci_device_read_rom(rom_device, (unsigned char *)(V_BIOS));
	    if (err) {
		xf86DrvMsg(screen,X_ERROR,"Cannot read V_BIOS (%s)\n",
			   strerror(err));
		goto error3;
	    }

	    pInt->BIOSseg = V_BIOS >> 4;
	    break;
	}
	default:
	    goto error3;
	}

	pInt->num = 0xe6;
	reset_int_vect(pInt);
	set_return_trap(pInt);
	LockLegacyVGA(pInt, &vga);
	xf86ExecX86int10(pInt);
	UnlockLegacyVGA(pInt, &vga);
d297 1
a297 1
error3:
d299 1
a299 1
	shmdt(base_high);
d303 1
a303 1
	shmdt((char*)HIGH_MEM);
d306 1
a306 1
error2:
d308 2
a309 2
	shmctl(high_mem, IPC_RMID,NULL);
error1:
d311 2
a312 2
	munmap(vMem, SYS_BIOS - V_BIOS);
    free(((linuxInt10Priv*)pInt->private)->alloc);
d314 1
a314 1
error0:
d325 1
a325 1
    
d327 5
a331 5
	shmdt(0);
	if (((linuxInt10Priv*)Int10Current->private)->highMem >= 0)
	    shmdt((char*)HIGH_MEM);
	else
	    munmap((pointer)V_BIOS, (SYS_BIOS - V_BIOS));
d333 2
a334 1
    addr = shmat(((linuxInt10Priv*)pInt->private)->lowMem, (char*)1, SHM_RND);
d336 4
a339 4
	xf86DrvMsg(pInt->scrnIndex, X_ERROR, "Cannot shmat() low memory\n");
	xf86DrvMsg(pInt->scrnIndex, X_ERROR,
		   "shmat(low_mem) error: %s\n",strerror(errno));
	return FALSE;
d341 1
a341 1
    if (mprotect((void*)0, V_RAM, PROT_READ|PROT_WRITE|PROT_EXEC) != 0)
d343 1
a343 1
		   "Cannot set EXEC bit on low memory: %s\n", strerror(errno));
d345 32
a376 30
    if (((linuxInt10Priv*)pInt->private)->highMem >= 0) {
	addr = shmat(((linuxInt10Priv*)pInt->private)->highMem,
		     (char*)HIGH_MEM, 0);
	if (addr == SHMERRORPTR) {
	    xf86DrvMsg(pInt->scrnIndex, X_ERROR,
		       "Cannot shmat() high memory\n");
	    xf86DrvMsg(pInt->scrnIndex, X_ERROR,
		       "shmget error: %s\n",strerror(errno));
	    return FALSE;
	}
	if (mprotect((void*)HIGH_MEM, HIGH_MEM_SIZE,
		     PROT_READ|PROT_WRITE|PROT_EXEC) != 0)
	    xf86DrvMsg(pInt->scrnIndex, X_ERROR,
		       "Cannot set EXEC bit on high memory: %s\n",
		       strerror(errno));
    } else {
	if ((fd = open(DEV_MEM, O_RDWR, 0)) >= 0) {
	    if (mmap((void *)(V_BIOS), SYS_BIOS - V_BIOS,
			     PROT_READ | PROT_WRITE | PROT_EXEC,
			     MAP_SHARED | MAP_FIXED, fd, V_BIOS)
		== MAP_FAILED) {
		xf86DrvMsg(pInt->scrnIndex, X_ERROR, "Cannot map V_BIOS\n");
		close (fd);
		return FALSE;
	    }
	} else {
	    xf86DrvMsg(pInt->scrnIndex, X_ERROR, "Cannot open %s\n",DEV_MEM);
	    return FALSE;
	}
	close (fd);
d378 1
a378 1
    
d386 1
a386 1
	return;
d389 1
a389 1
    xf86Int10SaveRestoreBIOSVars(pInt, FALSE); 
d392 15
a406 15
	shmdt(0);
	if (((linuxInt10Priv*)pInt->private)->highMem >= 0)
	    shmdt((char*)HIGH_MEM);
	else
	    munmap((pointer)V_BIOS, (SYS_BIOS - V_BIOS));
	Int10Current = NULL;
    }
    
    if (((linuxInt10Priv*)pInt->private)->base_high)
	shmdt(((linuxInt10Priv*)pInt->private)->base_high);
    shmdt(((linuxInt10Priv*)pInt->private)->base);
    shmctl(((linuxInt10Priv*)pInt->private)->lowMem, IPC_RMID, NULL);
    if (((linuxInt10Priv*)pInt->private)->highMem >= 0)
	shmctl(((linuxInt10Priv*)pInt->private)->highMem, IPC_RMID, NULL);
    free(((linuxInt10Priv*)pInt->private)->alloc);
d419 9
a427 9
	if (((linuxInt10Priv*)pInt->private)->alloc[i] == 0) {
	    for (j = i; j < (num + i); j++)
		if ((((linuxInt10Priv*)pInt->private)->alloc[j] != 0))
		    break;
	    if (j == (num + i))
		break;
	    else
		i = i + num;
	}
d430 1
a430 1
	return NULL;
d433 1
a433 1
	((linuxInt10Priv*)pInt->private)->alloc[j] = 1;
d437 1
a437 1
    return ((linuxInt10Priv*)pInt->private)->base + ((i + 1) * pagesize);
d444 3
a446 3
    int first = (((unsigned long)pbase
		 - (unsigned long)((linuxInt10Priv*)pInt->private)->base)
	/ pagesize) - 1;
d450 1
a450 1
	((linuxInt10Priv*)pInt->private)->alloc[i] = 0;
d456 1
a456 1
    return *((CARD8 *)(memType)addr);
d462 1
a462 1
    return *((CARD16 *)(memType)addr);
d468 1
a468 1
    return *((CARD32 *)(memType)addr);
d474 1
a474 1
    *((CARD8 *)(memType)addr) = val;
d480 1
a480 1
    *((CARD16 *)(memType)addr) = val;
d484 2
a485 1
void write_l(xf86Int10InfoPtr pInt, int addr, CARD32 val)
d487 1
a487 1
    *((CARD32 *)(memType) addr) = val;
d494 1
a494 1
	return ((linuxInt10Priv*)pInt->private)->base + addr;
d496 1
a496 1
	return (pointer)(memType)addr;
d498 8
a505 7
	if (((linuxInt10Priv*)pInt->private)->base_high)
	    return (pointer)(((linuxInt10Priv*)pInt->private)->base_high
			     - V_BIOS + addr);
	else
	    return (pointer) (memType)addr;
    } else
	return (pointer) (memType)addr;
d519 4
a522 6
			 "movl %2,%%ebx\n\t"
			 "movl %1,%%eax\n\t"
			 "int $0x80\n\t"
			 "popl %%ebx"
			 :"=a" (__res)
			 :"n" ((int)113), "r" (NULL));
d524 2
a525 3
    __asm__ __volatile__("int $0x80\n\t"
			 :"=a" (__res):"a" ((int)113),
			 "b" ((struct vm86_struct *)NULL));
d528 2
a529 2
    if (__res < 0 && __res == -ENOSYS) 
	return FALSE;
d538 5
a542 5
	if (xf86LoadSubModule(pScrn,"vm86"))
	    return INT10_LOADED_VM86;
    } 
    if (xf86LoadSubModule(pScrn,"x86emu"))
	return INT10_LOADED_X86EMU;
d547 1
a547 1
#endif /* DoSubModules */
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d103 1
a103 1
	xfree(options);
d293 1
a293 1
    xfree(options);
d311 2
a312 2
    xfree(((linuxInt10Priv*)pInt->private)->alloc);
    xfree(pInt->private);
d314 2
a315 2
    xfree(options);
    xfree(pInt);
d402 3
a404 3
    xfree(((linuxInt10Priv*)pInt->private)->alloc);
    xfree(pInt->private);
    xfree(pInt);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d118 1
a118 3
#ifdef DEBUG
		ErrorF("Mapping sys bios area\n");
#endif
d129 1
a129 3
#ifdef DEBUG
		ErrorF("Mapping VRAM area\n");
#endif
d161 1
a161 3
#ifdef DEBUG
	ErrorF("Mapping high memory area\n");
#endif
d173 1
a173 3
#ifdef DEBUG
	ErrorF("Mapping Video BIOS\n");
#endif
d190 1
a190 3
#ifdef DEBUG
    ErrorF("Mapping 640kB area\n");
#endif
d222 1
a222 3
#ifdef DEBUG
    ErrorF("Mapping int area\n");
#endif
d227 1
a227 3
#ifdef DEBUG
    ErrorF("done\n");
#endif
d235 1
a235 3
#ifdef DEBUG
	ErrorF("Reading BIOS\n");
#endif
d241 1
a241 3
#ifdef DEBUG
	ErrorF("done\n");
#endif
@


1.3
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d248 1
a248 1
	(void)memset((pointer)V_BIOS, 0, SYS_BIOS - V_BIOS);
d255 2
a256 1
			   "Unable to retrieve all of segment 0x%06lX.\n", cs);
a295 4
	case BUS_ISA:
	    if (!xf86int10GetBiosSegment(pInt, NULL))
		goto error3;
	    break;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d3 1
a3 1
 * Copyright 1999, 2000, 2001, 2002, 2003, 2004 Egbert Eich
d360 4
a363 1
    
d374 5
@


1.1
log
@Initial revision
@
text
@a90 1
    xf86int10BiosLocation bios;
d153 2
d261 2
a262 5
    xf86int10ParseBiosLocation(options,&bios);

    if (xf86IsEntityPrimary(entityIndex) 
	&& !(initPrimary(options))) {
	if (! xf86int10GetBiosSegment(pInt, &bios, NULL)) {
a263 1
	}
d273 1
a273 2
	const BusType location_type = xf86int10GetBiosLocationType(pInt,
								   &bios);
d277 12
a288 8
	    const int pci_entity = (bios.bus == BUS_PCI)
	      ? xf86GetPciEntity(bios.location.pci.bus,
				 bios.location.pci.dev,
				 bios.location.pci.func)
	      : pInt->entityIndex;
	    
	    if (!mapPciRom(pci_entity, (unsigned char *)(V_BIOS))) {
	        xf86DrvMsg(screen, X_ERROR, "Cannot read V_BIOS\n");
d291 1
d296 1
a296 1
	    if (! xf86int10GetBiosSegment(pInt, &bios, NULL)) {
a297 1
	    }
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@a92 1
    pciVideoPtr pvp;
a153 2
    pvp = xf86GetPciInfoForEntity(entityIndex);
    if (pvp) pInt->Tag = pciTag(pvp->bus, pvp->device, pvp->func);
@


1.1.1.3
log
@xserver 1.4
@
text
@d91 1
d263 5
a267 2
    if (xf86IsEntityPrimary(entityIndex) && !(initPrimary(options))) {
	if (!xf86int10GetBiosSegment(pInt, NULL))
d269 1
d279 2
a280 1
	const BusType location_type = xf86int10GetBiosLocationType(pInt);
d284 5
a288 1
	    const int pci_entity = pInt->entityIndex;
d298 1
a298 1
	    if (!xf86int10GetBiosSegment(pInt, NULL))
d300 1
@


