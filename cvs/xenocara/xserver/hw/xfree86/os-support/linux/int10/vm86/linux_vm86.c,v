head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.14
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.12
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.10
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.8
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <errno.h>
#include <string.h>

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86Pci.h"
#include "compiler.h"
#define _INT10_PRIVATE
#include "xf86int10.h"

#define REG pInt

#ifdef _VM86_LINUX
#include "int10Defines.h"

static int vm86_rep(struct vm86_struct *ptr);
static struct vm86_struct vm86_s;

Bool
xf86Int10ExecSetup(xf86Int10InfoPtr pInt)
{
#define VM86S ((struct vm86_struct *)pInt->cpuRegs)

    pInt->cpuRegs = &vm86_s;
    VM86S->flags = 0;
    VM86S->screen_bitmap = 0;
    VM86S->cpu_type = CPU_586;
    memset(&VM86S->int_revectored, 0xff, sizeof(VM86S->int_revectored));
    memset(&VM86S->int21_revectored, 0xff, sizeof(VM86S->int21_revectored));
    return TRUE;
}

/* get the linear address */
#define LIN_PREF_SI ((pref_seg << 4) + X86_SI)
#define LWECX       ((prefix66 ^ prefix67) ? X86_ECX : X86_CX)
#define LWECX_ZERO  {if (prefix66 ^ prefix67) X86_ECX = 0; else X86_CX = 0;}
#define DF (1 << 10)

/* vm86 fault handling */
static Bool
vm86_GP_fault(xf86Int10InfoPtr pInt)
{
    unsigned char *csp, *lina;
    CARD32 org_eip;
    int pref_seg;
    int done, is_rep, prefix66, prefix67;

    csp = lina = SEG_ADR((unsigned char *), X86_CS, IP);

    is_rep = 0;
    prefix66 = prefix67 = 0;
    pref_seg = -1;

    /* eat up prefixes */
    done = 0;
    do {
        switch (MEM_RB(pInt, (int) csp++)) {
        case 0x66:             /* operand prefix */
            prefix66 = 1;
            break;
        case 0x67:             /* address prefix */
            prefix67 = 1;
            break;
        case 0x2e:             /* CS */
            pref_seg = X86_CS;
            break;
        case 0x3e:             /* DS */
            pref_seg = X86_DS;
            break;
        case 0x26:             /* ES */
            pref_seg = X86_ES;
            break;
        case 0x36:             /* SS */
            pref_seg = X86_SS;
            break;
        case 0x65:             /* GS */
            pref_seg = X86_GS;
            break;
        case 0x64:             /* FS */
            pref_seg = X86_FS;
            break;
        case 0xf0:             /* lock */
            break;
        case 0xf2:             /* repnz */
        case 0xf3:             /* rep */
            is_rep = 1;
            break;
        default:
            done = 1;
        }
    } while (!done);
    csp--;                      /* oops one too many */
    org_eip = X86_EIP;
    X86_IP += (csp - lina);

    switch (MEM_RB(pInt, (int) csp)) {
    case 0x6c:                 /* insb */
        /* NOTE: ES can't be overwritten; prefixes 66,67 should use esi,edi,ecx
         * but is anyone using extended regs in real mode? */
        /* WARNING: no test for DI wrapping! */
        X86_EDI += port_rep_inb(pInt, X86_DX, SEG_EADR((CARD32), X86_ES, DI),
                                X86_FLAGS & DF, is_rep ? LWECX : 1);
        if (is_rep)
            LWECX_ZERO;
        X86_IP++;
        break;

    case 0x6d:                 /* (rep) insw / insd */
        /* NOTE: ES can't be overwritten */
        /* WARNING: no test for _DI wrapping! */
        if (prefix66) {
            X86_DI += port_rep_inl(pInt, X86_DX, SEG_ADR((CARD32), X86_ES, DI),
                                   X86_EFLAGS & DF, is_rep ? LWECX : 1);
        }
        else {
            X86_DI += port_rep_inw(pInt, X86_DX, SEG_ADR((CARD32), X86_ES, DI),
                                   X86_FLAGS & DF, is_rep ? LWECX : 1);
        }
        if (is_rep)
            LWECX_ZERO;
        X86_IP++;
        break;

    case 0x6e:                 /* (rep) outsb */
        if (pref_seg < 0)
            pref_seg = X86_DS;
        /* WARNING: no test for _SI wrapping! */
        X86_SI += port_rep_outb(pInt, X86_DX, (CARD32) LIN_PREF_SI,
                                X86_FLAGS & DF, is_rep ? LWECX : 1);
        if (is_rep)
            LWECX_ZERO;
        X86_IP++;
        break;

    case 0x6f:                 /* (rep) outsw / outsd */
        if (pref_seg < 0)
            pref_seg = X86_DS;
        /* WARNING: no test for _SI wrapping! */
        if (prefix66) {
            X86_SI += port_rep_outl(pInt, X86_DX, (CARD32) LIN_PREF_SI,
                                    X86_EFLAGS & DF, is_rep ? LWECX : 1);
        }
        else {
            X86_SI += port_rep_outw(pInt, X86_DX, (CARD32) LIN_PREF_SI,
                                    X86_FLAGS & DF, is_rep ? LWECX : 1);
        }
        if (is_rep)
            LWECX_ZERO;
        X86_IP++;
        break;

    case 0xe5:                 /* inw xx, inl xx */
        if (prefix66)
            X86_EAX = x_inl(csp[1]);
        else
            X86_AX = x_inw(csp[1]);
        X86_IP += 2;
        break;

    case 0xe4:                 /* inb xx */
        X86_AL = x_inb(csp[1]);
        X86_IP += 2;
        break;

    case 0xed:                 /* inw dx, inl dx */
        if (prefix66)
            X86_EAX = x_inl(X86_DX);
        else
            X86_AX = x_inw(X86_DX);
        X86_IP += 1;
        break;

    case 0xec:                 /* inb dx */
        X86_AL = x_inb(X86_DX);
        X86_IP += 1;
        break;

    case 0xe7:                 /* outw xx */
        if (prefix66)
            x_outl(csp[1], X86_EAX);
        else
            x_outw(csp[1], X86_AX);
        X86_IP += 2;
        break;

    case 0xe6:                 /* outb xx */
        x_outb(csp[1], X86_AL);
        X86_IP += 2;
        break;

    case 0xef:                 /* outw dx */
        if (prefix66)
            x_outl(X86_DX, X86_EAX);
        else
            x_outw(X86_DX, X86_AX);
        X86_IP += 1;
        break;

    case 0xee:                 /* outb dx */
        x_outb(X86_DX, X86_AL);
        X86_IP += 1;
        break;

    case 0xf4:
        DebugF("hlt at %p\n", lina);
        return FALSE;

    case 0x0f:
        xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR,
                   "CPU 0x0f Trap at CS:EIP=0x%4.4x:0x%8.8lx\n", X86_CS,
                   X86_EIP);
        goto op0ferr;

    default:
        xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR, "unknown reason for exception\n");

 op0ferr:
        dump_registers(pInt);
        stack_trace(pInt);
        dump_code(pInt);
        xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR, "cannot continue\n");
        return FALSE;
    }                           /* end of switch() */
    return TRUE;
}

static int
do_vm86(xf86Int10InfoPtr pInt)
{
    int retval, signo;

    xf86InterceptSignals(&signo);
    retval = vm86_rep(VM86S);
    xf86InterceptSignals(NULL);

    if (signo >= 0) {
        xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR,
                   "vm86() syscall generated signal %d.\n", signo);
        dump_registers(pInt);
        dump_code(pInt);
        stack_trace(pInt);
        return 0;
    }

    switch (VM86_TYPE(retval)) {
    case VM86_UNKNOWN:
        if (!vm86_GP_fault(pInt))
            return 0;
        break;
    case VM86_STI:
        xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR, "vm86_sti :-((\n");
        dump_registers(pInt);
        dump_code(pInt);
        stack_trace(pInt);
        return 0;
    case VM86_INTx:
        pInt->num = VM86_ARG(retval);
        if (!int_handler(pInt)) {
            xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR,
                       "Unknown vm86_int: 0x%X\n\n", VM86_ARG(retval));
            dump_registers(pInt);
            dump_code(pInt);
            stack_trace(pInt);
            return 0;
        }
        /* I'm not sure yet what to do if we can handle ints */
        break;
    case VM86_SIGNAL:
        return 1;
        /*
         * we used to warn here and bail out - but now the sigio stuff
         * always fires signals at us. So we just ignore them for now.
         */
        xf86DrvMsg(pInt->pScrn->scrnIndex, X_WARNING, "received signal\n");
        return 0;
    default:
        xf86DrvMsg(pInt->pScrn->scrnIndex, X_ERROR, "unknown type(0x%x)=0x%x\n",
                   VM86_ARG(retval), VM86_TYPE(retval));
        dump_registers(pInt);
        dump_code(pInt);
        stack_trace(pInt);
        return 0;
    }

    return 1;
}

void
xf86ExecX86int10(xf86Int10InfoPtr pInt)
{
    int sig = setup_int(pInt);

    if (int_handler(pInt))
        while (do_vm86(pInt)) {
        };

    finish_int(pInt, sig);
}

static int
vm86_rep(struct vm86_struct *ptr)
{
    int __res;

#ifdef __PIC__
    /* When compiling with -fPIC, we can't use asm constraint "b" because
       %ebx is already taken by gcc. */
    __asm__ __volatile__("pushl %%ebx\n\t"
                         "push %%gs\n\t"
                         "movl %2,%%ebx\n\t"
                         "movl %1,%%eax\n\t"
                         "int $0x80\n\t" "pop %%gs\n\t" "popl %%ebx":"=a"(__res)
                         :"n"((int) 113), "r"((struct vm86_struct *) ptr));
#else
    __asm__ __volatile__("push %%gs\n\t"
                         "int $0x80\n\t"
                         "pop %%gs":"=a"(__res):"a"((int) 113),
                         "b"((struct vm86_struct *) ptr));
#endif

    if (__res < 0) {
        errno = -__res;
        __res = -1;
    }
    else
        errno = 0;
    return __res;
}

#endif
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d213 1
a213 1
        xf86DrvMsg(pInt->scrnIndex, X_ERROR,
d219 1
a219 1
        xf86DrvMsg(pInt->scrnIndex, X_ERROR, "unknown reason for exception\n");
d225 1
a225 1
        xf86DrvMsg(pInt->scrnIndex, X_ERROR, "cannot continue\n");
d241 1
a241 1
        xf86DrvMsg(pInt->scrnIndex, X_ERROR,
d255 1
a255 1
        xf86DrvMsg(pInt->scrnIndex, X_ERROR, "vm86_sti :-((\n");
d263 1
a263 1
            xf86DrvMsg(pInt->scrnIndex, X_ERROR,
d278 1
a278 1
        xf86DrvMsg(pInt->scrnIndex, X_WARNING, "received signal\n");
d281 1
a281 1
        xf86DrvMsg(pInt->scrnIndex, X_ERROR, "unknown type(0x%x)=0x%x\n",
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d28 1
a28 1
    pInt->cpuRegs =  &vm86_s;
d61 34
a94 14
	switch (MEM_RB(pInt, (int)csp++)) {
	case 0x66:      /* operand prefix */  prefix66=1; break;
	case 0x67:      /* address prefix */  prefix67=1; break;
	case 0x2e:      /* CS */              pref_seg=X86_CS; break;
	case 0x3e:      /* DS */              pref_seg=X86_DS; break;
	case 0x26:      /* ES */              pref_seg=X86_ES; break;
	case 0x36:      /* SS */              pref_seg=X86_SS; break;
	case 0x65:      /* GS */              pref_seg=X86_GS; break;
	case 0x64:      /* FS */              pref_seg=X86_FS; break;
	case 0xf0:      /* lock */            break;
	case 0xf2:      /* repnz */
	case 0xf3:      /* rep */             is_rep=1; break;
	default: done=1;
	}
d96 1
a96 1
    csp--;   /* oops one too many */
d100 107
a206 93
    switch (MEM_RB(pInt, (int)csp)) {
    case 0x6c:                    /* insb */
	/* NOTE: ES can't be overwritten; prefixes 66,67 should use esi,edi,ecx
	 * but is anyone using extended regs in real mode? */
	/* WARNING: no test for DI wrapping! */
	X86_EDI += port_rep_inb(pInt, X86_DX, SEG_EADR((CARD32), X86_ES, DI),
				X86_FLAGS & DF, is_rep ? LWECX : 1);
	if (is_rep) LWECX_ZERO;
	X86_IP++;
	break;

    case 0x6d:                  /* (rep) insw / insd */
	/* NOTE: ES can't be overwritten */
	/* WARNING: no test for _DI wrapping! */
	if (prefix66) {
	    X86_DI += port_rep_inl(pInt, X86_DX, SEG_ADR((CARD32), X86_ES, DI),
				   X86_EFLAGS & DF, is_rep ? LWECX : 1);
	}
	else {
	    X86_DI += port_rep_inw(pInt, X86_DX, SEG_ADR((CARD32), X86_ES, DI),
				   X86_FLAGS & DF, is_rep ? LWECX : 1);
	}
	if (is_rep) LWECX_ZERO;
	X86_IP++;
	break;

    case 0x6e:                  /* (rep) outsb */
	if (pref_seg < 0) pref_seg = X86_DS;
	/* WARNING: no test for _SI wrapping! */
	X86_SI += port_rep_outb(pInt, X86_DX, (CARD32)LIN_PREF_SI,
			        X86_FLAGS & DF, is_rep ? LWECX : 1);
	if (is_rep) LWECX_ZERO;
	X86_IP++;
	break;

    case 0x6f:                  /* (rep) outsw / outsd */
	if (pref_seg < 0) pref_seg = X86_DS;
	/* WARNING: no test for _SI wrapping! */
	if (prefix66) {
	    X86_SI += port_rep_outl(pInt, X86_DX, (CARD32)LIN_PREF_SI,
				    X86_EFLAGS & DF, is_rep ? LWECX : 1);
	}
	else {
	    X86_SI += port_rep_outw(pInt, X86_DX, (CARD32)LIN_PREF_SI,
				    X86_FLAGS & DF, is_rep ? LWECX : 1);
	}
	if (is_rep) LWECX_ZERO;
	X86_IP++;
	break;

    case 0xe5:                  /* inw xx, inl xx */
	if (prefix66) X86_EAX = x_inl(csp[1]);
	else X86_AX = x_inw(csp[1]);
	X86_IP += 2;
	break;

    case 0xe4:                  /* inb xx */
	X86_AL = x_inb(csp[1]);
	X86_IP += 2;
	break;

    case 0xed:                  /* inw dx, inl dx */
	if (prefix66) X86_EAX = x_inl(X86_DX);
	else X86_AX = x_inw(X86_DX);
	X86_IP += 1;
	break;

    case 0xec:                  /* inb dx */
	X86_AL = x_inb(X86_DX);
	X86_IP += 1;
	break;

    case 0xe7:                  /* outw xx */
	if (prefix66) x_outl(csp[1], X86_EAX);
	else x_outw(csp[1], X86_AX);
	X86_IP += 2;
	break;

    case 0xe6:                  /* outb xx */
	x_outb(csp[1], X86_AL);
	X86_IP += 2;
	break;

    case 0xef:                  /* outw dx */
	if (prefix66) x_outl(X86_DX, X86_EAX);
	else x_outw(X86_DX, X86_AX);
	X86_IP += 1;
	break;

    case 0xee:                  /* outb dx */
	x_outb(X86_DX, X86_AL);
	X86_IP += 1;
	break;
d209 2
a210 2
	DebugF("hlt at %p\n", lina);
	return FALSE;
d213 4
a216 3
	xf86DrvMsg(pInt->scrnIndex, X_ERROR,
	    "CPU 0x0f Trap at CS:EIP=0x%4.4x:0x%8.8lx\n", X86_CS, X86_EIP);
	goto op0ferr;
d219 1
a219 1
	xf86DrvMsg(pInt->scrnIndex, X_ERROR, "unknown reason for exception\n");
d221 6
a226 6
    op0ferr:
	dump_registers(pInt);
	stack_trace(pInt);
	dump_code(pInt);
	xf86DrvMsg(pInt->scrnIndex, X_ERROR, "cannot continue\n");
	return FALSE;
d241 6
a246 6
	xf86DrvMsg(pInt->scrnIndex, X_ERROR,
	    "vm86() syscall generated signal %d.\n", signo);
	dump_registers(pInt);
	dump_code(pInt);
	stack_trace(pInt);
	return 0;
d251 3
a253 2
	if (!vm86_GP_fault(pInt)) return 0;
	break;
d255 5
a259 5
	xf86DrvMsg(pInt->scrnIndex, X_ERROR, "vm86_sti :-((\n");
	dump_registers(pInt);
	dump_code(pInt);
	stack_trace(pInt);
	return 0;
d261 11
a271 11
	pInt->num = VM86_ARG(retval);
	if (!int_handler(pInt)) {
	    xf86DrvMsg(pInt->scrnIndex, X_ERROR,
		"Unknown vm86_int: 0x%X\n\n", VM86_ARG(retval));
	    dump_registers(pInt);
	    dump_code(pInt);
	    stack_trace(pInt);
	    return 0;
	}
	/* I'm not sure yet what to do if we can handle ints */
	break;
d273 7
a279 7
	return 1;
	/*
	 * we used to warn here and bail out - but now the sigio stuff
	 * always fires signals at us. So we just ignore them for now.
	 */
	xf86DrvMsg(pInt->scrnIndex, X_WARNING, "received signal\n");
	return 0;
d281 6
a286 6
	xf86DrvMsg(pInt->scrnIndex, X_ERROR, "unknown type(0x%x)=0x%x\n",
		VM86_ARG(retval), VM86_TYPE(retval));
	dump_registers(pInt);
	dump_code(pInt);
	stack_trace(pInt);
	return 0;
d298 2
a299 1
	while(do_vm86(pInt)) {};
d313 5
a317 8
			 "push %%gs\n\t"
			 "movl %2,%%ebx\n\t"
			 "movl %1,%%eax\n\t"
			 "int $0x80\n\t"
			 "pop %%gs\n\t"
			 "popl %%ebx"
			 :"=a" (__res)
			 :"n" ((int)113), "r" ((struct vm86_struct *)ptr));
d320 3
a322 4
			 "int $0x80\n\t"
			 "pop %%gs"
			 :"=a" (__res):"a" ((int)113),
			 "b" ((struct vm86_struct *)ptr));
d325 7
a331 6
	    if (__res < 0) {
		errno = -__res;
		__res = -1;
	    }
	    else errno = 0;
	    return __res;
@


1.1
log
@Initial revision
@
text
@a0 2
/* $XFree86$ */

d175 1
a175 3
#ifdef DEBUG
	ErrorF("hlt at %p\n", lina);
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 2
@

