head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.12
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.10
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.6
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.34;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.35;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@#ifdef HAVE_XORG_CONFIG_H
#include "xorg-config.h"
#endif

#include "os.h"
#include "xf86.h"
#include "xf86Priv.h"
#define XF86_OS_PRIVS
#include "xf86_OSproc.h"
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

#define ACPI_SOCKET  "/var/run/acpid.socket"

#define ACPI_VIDEO_NOTIFY_SWITCH	0x80
#define ACPI_VIDEO_NOTIFY_PROBE		0x81
#define ACPI_VIDEO_NOTIFY_CYCLE		0x82
#define ACPI_VIDEO_NOTIFY_NEXT_OUTPUT	0x83
#define ACPI_VIDEO_NOTIFY_PREV_OUTPUT	0x84

#define ACPI_VIDEO_NOTIFY_CYCLE_BRIGHTNESS	0x85
#define	ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS	0x86
#define ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS	0x87
#define ACPI_VIDEO_NOTIFY_ZERO_BRIGHTNESS	0x88
#define ACPI_VIDEO_NOTIFY_DISPLAY_OFF		0x89

#define ACPI_VIDEO_HEAD_INVALID		(~0u - 1)
#define ACPI_VIDEO_HEAD_END		(~0u)

static void lnxCloseACPI(void);
static void *ACPIihPtr = NULL;
PMClose lnxACPIOpen(void);

/* in milliseconds */
#define ACPI_REOPEN_DELAY 1000

static CARD32
lnxACPIReopen(OsTimerPtr timer, CARD32 time, void *arg)
{
    if (lnxACPIOpen()) {
        TimerFree(timer);
        return 0;
    }

    return ACPI_REOPEN_DELAY;
}

#define LINE_LENGTH 80

static int
lnxACPIGetEventFromOs(int fd, pmEvent * events, int num)
{
    char ev[LINE_LENGTH];
    int n;

    memset(ev, 0, LINE_LENGTH);

    do {
        n = read(fd, ev, LINE_LENGTH);
    } while ((n == -1) && (errno == EAGAIN || errno == EINTR));

    if (n <= 0) {
        lnxCloseACPI();
        TimerSet(NULL, 0, ACPI_REOPEN_DELAY, lnxACPIReopen, NULL);
        return 0;
    }
    /* FIXME: this only processes the first read ACPI event & might break
     * with interrupted reads. */

    /* Check that we have a video event */
    if (!strncmp(ev, "video", 5)) {
        char *GFX = NULL;
        char *notify = NULL;
        char *data = NULL;      /* doesn't appear to be used in the kernel */
        unsigned long int notify_l;

        strtok(ev, " ");

        if (!(GFX = strtok(NULL, " ")))
            return 0;
#if 0
        ErrorF("GFX: %s\n", GFX);
#endif

        if (!(notify = strtok(NULL, " ")))
            return 0;
        notify_l = strtoul(notify, NULL, 16);
#if 0
        ErrorF("notify: 0x%lx\n", notify_l);
#endif

        if (!(data = strtok(NULL, " ")))
            return 0;
#if 0
        data_l = strtoul(data, NULL, 16);
        ErrorF("data: 0x%lx\n", data_l);
#endif

        /* Differentiate between events */
        switch (notify_l) {
        case ACPI_VIDEO_NOTIFY_SWITCH:
        case ACPI_VIDEO_NOTIFY_CYCLE:
        case ACPI_VIDEO_NOTIFY_NEXT_OUTPUT:
        case ACPI_VIDEO_NOTIFY_PREV_OUTPUT:
            events[0] = XF86_APM_CAPABILITY_CHANGED;
            return 1;
        case ACPI_VIDEO_NOTIFY_PROBE:
            return 0;
        default:
            return 0;
        }
    }

    return 0;
}

static pmWait
lnxACPIConfirmEventToOs(int fd, pmEvent event)
{
    /* No ability to send back to the kernel in ACPI */
    switch (event) {
    default:
        return PM_NONE;
    }
}

PMClose
lnxACPIOpen(void)
{
    int fd;
    struct sockaddr_un addr;
    int r = -1;
    static int warned = 0;

    DebugF("ACPI: OSPMOpen called\n");
    if (ACPIihPtr || !xf86Info.pmFlag)
        return NULL;

    DebugF("ACPI: Opening device\n");
    if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) > -1) {
        memset(&addr, 0, sizeof(addr));
        addr.sun_family = AF_UNIX;
        strcpy(addr.sun_path, ACPI_SOCKET);
        if ((r = connect(fd, (struct sockaddr *) &addr, sizeof(addr))) == -1) {
            if (!warned)
                xf86MsgVerb(X_WARNING, 3, "Open ACPI failed (%s) (%s)\n",
                            ACPI_SOCKET, strerror(errno));
            warned = 1;
            shutdown(fd, 2);
            close(fd);
            return NULL;
        }
    }

    xf86PMGetEventFromOs = lnxACPIGetEventFromOs;
    xf86PMConfirmEventToOs = lnxACPIConfirmEventToOs;
    ACPIihPtr = xf86AddGeneralHandler(fd, xf86HandlePMEvents, NULL);
    xf86MsgVerb(X_INFO, 3, "Open ACPI successful (%s)\n", ACPI_SOCKET);
    warned = 0;

    return lnxCloseACPI;
}

static void
lnxCloseACPI(void)
{
    int fd;

    DebugF("ACPI: Closing device\n");
    if (ACPIihPtr) {
        fd = xf86RemoveGeneralHandler(ACPIihPtr);
        shutdown(fd, 2);
        close(fd);
        ACPIihPtr = NULL;
    }
}
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d36 1
a36 1
static pointer ACPIihPtr = NULL;
d43 1
a43 1
lnxACPIReopen(OsTimerPtr timer, CARD32 time, pointer arg)
a76 1
        char *video = NULL;
d80 1
a80 1
        unsigned long int notify_l, data_l;
d82 1
a82 1
        video = strtok(ev, " ");
d99 1
a100 1
#if 0
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d85 2
a86 1
        GFX = strtok(NULL, " ");
d91 2
a92 1
        notify = strtok(NULL, " ");
d98 2
a99 1
        data = strtok(NULL, " ");
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d17 1
a17 1
 
d46 2
a47 2
	TimerFree(timer);
	return 0;
d56 1
a56 1
lnxACPIGetEventFromOs(int fd, pmEvent *events, int num)
d64 1
a64 1
	n = read( fd, ev, LINE_LENGTH );
d68 3
a70 3
	lnxCloseACPI();
	TimerSet(NULL, 0, ACPI_REOPEN_DELAY, lnxACPIReopen, NULL);
	return 0;
d74 1
a74 1
    
d77 5
a81 5
	char *video = NULL;
	char *GFX = NULL;
	char *notify = NULL;
	char *data = NULL; /* doesn't appear to be used in the kernel */
	unsigned long int notify_l, data_l;
d83 1
a83 1
	video = strtok(ev, " ");
d85 1
a85 1
	GFX = strtok(NULL, " ");
d87 1
a87 1
	ErrorF("GFX: %s\n",GFX);
d90 2
a91 2
	notify = strtok(NULL, " ");
	notify_l = strtoul(notify, NULL, 16);
d93 1
a93 1
	ErrorF("notify: 0x%lx\n",notify_l);
d96 2
a97 2
	data = strtok(NULL, " ");
	data_l = strtoul(data, NULL, 16);
d99 1
a99 1
	ErrorF("data: 0x%lx\n",data_l);
d102 13
a114 13
	/* Differentiate between events */
	switch (notify_l) {
		case ACPI_VIDEO_NOTIFY_SWITCH:
		case ACPI_VIDEO_NOTIFY_CYCLE:
		case ACPI_VIDEO_NOTIFY_NEXT_OUTPUT:
		case ACPI_VIDEO_NOTIFY_PREV_OUTPUT:
		    events[0] = XF86_APM_CAPABILITY_CHANGED;
		    return 1;
		case ACPI_VIDEO_NOTIFY_PROBE:
		    return 0;
		default:
		    return 0;
	}
d116 1
a116 1
    
d126 1
a126 1
	return PM_NONE;
d133 1
a133 1
    int fd;    
d140 2
a141 2
	return NULL;
   
d144 12
a155 12
	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	strcpy(addr.sun_path, ACPI_SOCKET);
	if ((r = connect(fd, (struct sockaddr*)&addr, sizeof(addr))) == -1) {
	    if (!warned)
		xf86MsgVerb(X_WARNING,3,"Open ACPI failed (%s) (%s)\n",
		            ACPI_SOCKET, strerror(errno));
	    warned = 1;
	    shutdown(fd, 2);
	    close(fd);
	    return NULL;
    	}
d160 2
a161 2
    ACPIihPtr = xf86AddGeneralHandler(fd,xf86HandlePMEvents,NULL);
    xf86MsgVerb(X_INFO,3,"Open ACPI successful (%s)\n", ACPI_SOCKET);
d174 4
a177 4
	fd = xf86RemoveGeneralHandler(ACPIihPtr);
	shutdown(fd, 2);
	close(fd);
	ACPIihPtr = NULL;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d136 1
d138 1
a138 3
#ifdef DEBUG
    ErrorF("ACPI: OSPMOpen called\n");
#endif
d142 1
a142 3
#ifdef DEBUG
    ErrorF("ACPI: Opening device\n");
#endif
d148 4
a151 2
	    xf86MsgVerb(X_WARNING,3,"Open ACPI failed (%s) (%s)\n", ACPI_SOCKET,
	    	strerror(errno));
d162 1
d171 2
a172 4
    
#ifdef DEBUG
   ErrorF("ACPI: Closing device\n");
#endif
@


1.1
log
@Initial revision
@
text
@d26 5
a30 5
#define ACPI_VIDEO_NOTIFY_CYCLE_BRIGHTNESS	0x82
#define	ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS	0x83
#define ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS	0x84
#define ACPI_VIDEO_NOTIFY_ZERO_BRIGHTNESS	0x85
#define ACPI_VIDEO_NOTIFY_DISPLAY_OFF		0x86
d72 2
d76 1
a76 1
    if (strstr(ev, "video") == ev) {
d102 1
a102 1
	/* We currently don't differentiate between any event */
a104 3
			break;
		case ACPI_VIDEO_NOTIFY_PROBE:
			break;
a105 1
			break;
a106 1
			break;
d108 4
a111 1
			break;
d113 1
a113 1
			break;
a114 5

	/* Deal with all ACPI events as a capability change */
        events[0] = XF86_APM_CAPABILITY_CHANGED;

	return 1;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
