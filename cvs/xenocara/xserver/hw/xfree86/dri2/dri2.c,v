head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	s0SI41sEunLdyFfd;

1.15
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	Te1daavkBLskZ8gc;

1.14
date	2015.02.11.20.58.46;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	dgcmwPGRv39E4MF9;

1.13
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.07.17.28.51;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2007, 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Soft-
 * ware"), to deal in the Software without restriction, including without
 * limitation the rights to use, copy, modify, merge, publish, distribute,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, provided that the above copyright
 * notice(s) and this permission notice appear in all copies of the Soft-
 * ware and that both the above copyright notice(s) and this permission
 * notice appear in supporting documentation.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
 * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
 * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
 * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
 * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
 * MANCE OF THIS SOFTWARE.
 *
 * Except as contained in this notice, the name of a copyright holder shall
 * not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization of
 * the copyright holder.
 *
 * Authors:
 *   Kristian Høgsberg (krh@@redhat.com)
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <errno.h>
#ifdef WITH_LIBDRM
#include <xf86drm.h>
#endif
#include "xf86Module.h"
#include "list.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "dixstruct.h"
#include "dri2.h"
#include "dri2int.h"
#include "xf86VGAarbiter.h"
#include "damage.h"
#include "xf86.h"

CARD8 dri2_major;               /* version of DRI2 supported by DDX */
CARD8 dri2_minor;

uint32_t prime_id_allocate_bitmask;

static DevPrivateKeyRec dri2ScreenPrivateKeyRec;

#define dri2ScreenPrivateKey (&dri2ScreenPrivateKeyRec)

static DevPrivateKeyRec dri2WindowPrivateKeyRec;

#define dri2WindowPrivateKey (&dri2WindowPrivateKeyRec)

static DevPrivateKeyRec dri2PixmapPrivateKeyRec;

#define dri2PixmapPrivateKey (&dri2PixmapPrivateKeyRec)

static DevPrivateKeyRec dri2ClientPrivateKeyRec;

#define dri2ClientPrivateKey (&dri2ClientPrivateKeyRec)

#define dri2ClientPrivate(_pClient) (dixLookupPrivate(&(_pClient)->devPrivates, \
                                                      dri2ClientPrivateKey))

typedef struct _DRI2Client {
    int prime_id;
} DRI2ClientRec, *DRI2ClientPtr;

static RESTYPE dri2DrawableRes;

typedef struct _DRI2Screen *DRI2ScreenPtr;

typedef struct _DRI2Drawable {
    DRI2ScreenPtr dri2_screen;
    DrawablePtr drawable;
    struct xorg_list reference_list;
    int width;
    int height;
    DRI2BufferPtr *buffers;
    int bufferCount;
    unsigned int swapsPending;
    int swap_interval;
    CARD64 swap_count;
    int64_t target_sbc;         /* -1 means no SBC wait outstanding */
    CARD64 last_swap_target;    /* most recently queued swap target */
    CARD64 last_swap_msc;       /* msc at completion of most recent swap */
    CARD64 last_swap_ust;       /* ust at completion of most recent swap */
    int swap_limit;             /* for N-buffering */
    unsigned blocked[3];
    Bool needInvalidate;
    int prime_id;
    PixmapPtr prime_slave_pixmap;
    PixmapPtr redirectpixmap;
} DRI2DrawableRec, *DRI2DrawablePtr;

typedef struct _DRI2Screen {
    ScreenPtr screen;
    int refcnt;
    unsigned int numDrivers;
    const char **driverNames;
    const char *deviceName;
    int fd;
    unsigned int lastSequence;
    int prime_id;

    DRI2CreateBufferProcPtr CreateBuffer;
    DRI2DestroyBufferProcPtr DestroyBuffer;
    DRI2CopyRegionProcPtr CopyRegion;
    DRI2ScheduleSwapProcPtr ScheduleSwap;
    DRI2GetMSCProcPtr GetMSC;
    DRI2ScheduleWaitMSCProcPtr ScheduleWaitMSC;
    DRI2AuthMagic2ProcPtr AuthMagic;
    DRI2AuthMagicProcPtr LegacyAuthMagic;
    DRI2ReuseBufferNotifyProcPtr ReuseBufferNotify;
    DRI2SwapLimitValidateProcPtr SwapLimitValidate;
    DRI2GetParamProcPtr GetParam;

    HandleExposuresProcPtr HandleExposures;

    ConfigNotifyProcPtr ConfigNotify;
    SetWindowPixmapProcPtr SetWindowPixmap;
    DRI2CreateBuffer2ProcPtr CreateBuffer2;
    DRI2DestroyBuffer2ProcPtr DestroyBuffer2;
    DRI2CopyRegion2ProcPtr CopyRegion2;
} DRI2ScreenRec;

static void
destroy_buffer(DrawablePtr pDraw, DRI2BufferPtr buffer, int prime_id);

enum DRI2WakeType {
    WAKE_SBC,
    WAKE_MSC,
    WAKE_SWAP,
};

#define Wake(c, t) (void *)((uintptr_t)(c) | (t))

static Bool
dri2WakeClient(ClientPtr client, void *closure)
{
    ClientWakeup(client);
    return TRUE;
}

static Bool
dri2WakeAll(ClientPtr client, DRI2DrawablePtr pPriv, enum DRI2WakeType t)
{
    int count;

    if (!pPriv->blocked[t])
        return FALSE;

    count = ClientSignalAll(client, dri2WakeClient, Wake(pPriv, t));
    pPriv->blocked[t] -= count;
    return count;
}

static Bool
dri2Sleep(ClientPtr client, DRI2DrawablePtr pPriv, enum DRI2WakeType t)
{
    if (ClientSleep(client, dri2WakeClient, Wake(pPriv, t))) {
        pPriv->blocked[t]++;
        return TRUE;
    }
    return FALSE;
}

static DRI2ScreenPtr
DRI2GetScreen(ScreenPtr pScreen)
{
    return dixLookupPrivate(&pScreen->devPrivates, dri2ScreenPrivateKey);
}

static ScreenPtr
GetScreenPrime(ScreenPtr master, int prime_id)
{
    ScreenPtr slave;
    if (prime_id == 0 || xorg_list_is_empty(&master->offload_slave_list)) {
        return master;
    }
    xorg_list_for_each_entry(slave, &master->offload_slave_list, offload_head) {
        DRI2ScreenPtr ds;

        ds = DRI2GetScreen(slave);
        if (ds == NULL)
            continue;

        if (ds->prime_id == prime_id)
            return slave;
    }
    return master;
}

static DRI2ScreenPtr
DRI2GetScreenPrime(ScreenPtr master, int prime_id)
{
    ScreenPtr slave = GetScreenPrime(master, prime_id);
    return DRI2GetScreen(slave);
}

static DRI2DrawablePtr
DRI2GetDrawable(DrawablePtr pDraw)
{
    WindowPtr pWin;
    PixmapPtr pPixmap;

    switch (pDraw->type) {
    case DRAWABLE_WINDOW:
        pWin = (WindowPtr) pDraw;
        return dixLookupPrivate(&pWin->devPrivates, dri2WindowPrivateKey);
    case DRAWABLE_PIXMAP:
        pPixmap = (PixmapPtr) pDraw;
        return dixLookupPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey);
    default:
        return NULL;
    }
}

static DRI2DrawablePtr
DRI2AllocateDrawable(DrawablePtr pDraw)
{
    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
    DRI2DrawablePtr pPriv;
    CARD64 ust;
    WindowPtr pWin;
    PixmapPtr pPixmap;

    pPriv = malloc(sizeof *pPriv);
    if (pPriv == NULL)
        return NULL;

    pPriv->dri2_screen = ds;
    pPriv->drawable = pDraw;
    pPriv->width = pDraw->width;
    pPriv->height = pDraw->height;
    pPriv->buffers = NULL;
    pPriv->bufferCount = 0;
    pPriv->swapsPending = 0;
    pPriv->swap_count = 0;
    pPriv->target_sbc = -1;
    pPriv->swap_interval = 1;
    /* Initialize last swap target from DDX if possible */
    if (!ds->GetMSC || !(*ds->GetMSC) (pDraw, &ust, &pPriv->last_swap_target))
        pPriv->last_swap_target = 0;

    memset(pPriv->blocked, 0, sizeof(pPriv->blocked));
    pPriv->swap_limit = 1;      /* default to double buffering */
    pPriv->last_swap_msc = 0;
    pPriv->last_swap_ust = 0;
    xorg_list_init(&pPriv->reference_list);
    pPriv->needInvalidate = FALSE;
    pPriv->redirectpixmap = NULL;
    pPriv->prime_slave_pixmap = NULL;
    if (pDraw->type == DRAWABLE_WINDOW) {
        pWin = (WindowPtr) pDraw;
        dixSetPrivate(&pWin->devPrivates, dri2WindowPrivateKey, pPriv);
    }
    else {
        pPixmap = (PixmapPtr) pDraw;
        dixSetPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey, pPriv);
    }

    return pPriv;
}

Bool
DRI2SwapLimit(DrawablePtr pDraw, int swap_limit)
{
    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDraw);
    DRI2ScreenPtr ds;

    if (!pPriv)
        return FALSE;

    ds = pPriv->dri2_screen;

    if (!ds->SwapLimitValidate || !ds->SwapLimitValidate(pDraw, swap_limit))
        return FALSE;

    pPriv->swap_limit = swap_limit;

    /* Check throttling */
    if (pPriv->swapsPending >= pPriv->swap_limit)
        return TRUE;

    dri2WakeAll(CLIENT_SIGNAL_ANY, pPriv, WAKE_SWAP);
    return TRUE;
}

typedef struct DRI2DrawableRefRec {
    XID id;
    XID dri2_id;
    DRI2InvalidateProcPtr invalidate;
    void *priv;
    struct xorg_list link;
} DRI2DrawableRefRec, *DRI2DrawableRefPtr;

static DRI2DrawableRefPtr
DRI2LookupDrawableRef(DRI2DrawablePtr pPriv, XID id)
{
    DRI2DrawableRefPtr ref;

    xorg_list_for_each_entry(ref, &pPriv->reference_list, link) {
        if (ref->id == id)
            return ref;
    }

    return NULL;
}

static int
DRI2AddDrawableRef(DRI2DrawablePtr pPriv, XID id, XID dri2_id,
                   DRI2InvalidateProcPtr invalidate, void *priv)
{
    DRI2DrawableRefPtr ref;

    ref = malloc(sizeof *ref);
    if (ref == NULL)
        return BadAlloc;

    if (!AddResource(dri2_id, dri2DrawableRes, pPriv)) {
        free(ref);
        return BadAlloc;
    }
    if (!DRI2LookupDrawableRef(pPriv, id))
        if (!AddResource(id, dri2DrawableRes, pPriv)) {
            FreeResourceByType(dri2_id, dri2DrawableRes, TRUE);
            free(ref);
            return BadAlloc;
        }

    ref->id = id;
    ref->dri2_id = dri2_id;
    ref->invalidate = invalidate;
    ref->priv = priv;
    xorg_list_add(&ref->link, &pPriv->reference_list);

    return Success;
}

int
DRI2CreateDrawable2(ClientPtr client, DrawablePtr pDraw, XID id,
                    DRI2InvalidateProcPtr invalidate, void *priv,
                    XID *dri2_id_out)
{
    DRI2DrawablePtr pPriv;
    DRI2ClientPtr dri2_client = dri2ClientPrivate(client);
    XID dri2_id;
    int rc;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL)
        pPriv = DRI2AllocateDrawable(pDraw);
    if (pPriv == NULL)
        return BadAlloc;

    pPriv->prime_id = dri2_client->prime_id;

    dri2_id = FakeClientID(client->index);
    rc = DRI2AddDrawableRef(pPriv, id, dri2_id, invalidate, priv);
    if (rc != Success)
        return rc;

    if (dri2_id_out)
        *dri2_id_out = dri2_id;

    return Success;
}

int
DRI2CreateDrawable(ClientPtr client, DrawablePtr pDraw, XID id,
                   DRI2InvalidateProcPtr invalidate, void *priv)
{
    return DRI2CreateDrawable2(client, pDraw, id, invalidate, priv, NULL);
}

static int
DRI2DrawableGone(void *p, XID id)
{
    DRI2DrawablePtr pPriv = p;
    DRI2DrawableRefPtr ref, next;
    WindowPtr pWin;
    PixmapPtr pPixmap;
    DrawablePtr pDraw;
    int i;

    xorg_list_for_each_entry_safe(ref, next, &pPriv->reference_list, link) {
        if (ref->dri2_id == id) {
            xorg_list_del(&ref->link);
            /* If this was the last ref under this X drawable XID,
             * unregister the X drawable resource. */
            if (!DRI2LookupDrawableRef(pPriv, ref->id))
                FreeResourceByType(ref->id, dri2DrawableRes, TRUE);
            free(ref);
            break;
        }

        if (ref->id == id) {
            xorg_list_del(&ref->link);
            FreeResourceByType(ref->dri2_id, dri2DrawableRes, TRUE);
            free(ref);
        }
    }

    if (!xorg_list_is_empty(&pPriv->reference_list))
        return Success;

    pDraw = pPriv->drawable;
    if (pDraw->type == DRAWABLE_WINDOW) {
        pWin = (WindowPtr) pDraw;
        dixSetPrivate(&pWin->devPrivates, dri2WindowPrivateKey, NULL);
    }
    else {
        pPixmap = (PixmapPtr) pDraw;
        dixSetPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey, NULL);
    }

    if (pPriv->prime_slave_pixmap) {
        (*pPriv->prime_slave_pixmap->master_pixmap->drawable.pScreen->DestroyPixmap)(pPriv->prime_slave_pixmap->master_pixmap);
        (*pPriv->prime_slave_pixmap->drawable.pScreen->DestroyPixmap)(pPriv->prime_slave_pixmap);
    }

    if (pPriv->buffers != NULL) {
        for (i = 0; i < pPriv->bufferCount; i++)
            destroy_buffer(pDraw, pPriv->buffers[i], pPriv->prime_id);

        free(pPriv->buffers);
    }

    if (pPriv->redirectpixmap) {
        (*pDraw->pScreen->ReplaceScanoutPixmap)(pDraw, pPriv->redirectpixmap, FALSE);
        (*pDraw->pScreen->DestroyPixmap)(pPriv->redirectpixmap);
    }

    dri2WakeAll(CLIENT_SIGNAL_ANY, pPriv, WAKE_SWAP);
    dri2WakeAll(CLIENT_SIGNAL_ANY, pPriv, WAKE_MSC);
    dri2WakeAll(CLIENT_SIGNAL_ANY, pPriv, WAKE_SBC);

    free(pPriv);

    return Success;
}

static DRI2BufferPtr
create_buffer(DRI2ScreenPtr ds, DrawablePtr pDraw,
              unsigned int attachment, unsigned int format)
{
    DRI2BufferPtr buffer;
    if (ds->CreateBuffer2)
        buffer = (*ds->CreateBuffer2)(GetScreenPrime(pDraw->pScreen,
                                                     DRI2GetDrawable(pDraw)->prime_id),
                                      pDraw, attachment, format);
    else
        buffer = (*ds->CreateBuffer)(pDraw, attachment, format);
    return buffer;
}

static void
destroy_buffer(DrawablePtr pDraw, DRI2BufferPtr buffer, int prime_id)
{
    ScreenPtr primeScreen;
    DRI2ScreenPtr ds;
    primeScreen = GetScreenPrime(pDraw->pScreen, prime_id);
    ds = DRI2GetScreen(primeScreen);
    if (ds->DestroyBuffer2)
        (*ds->DestroyBuffer2)(primeScreen, pDraw, buffer);
    else
        (*ds->DestroyBuffer)(pDraw, buffer);
}

static int
find_attachment(DRI2DrawablePtr pPriv, unsigned attachment)
{
    int i;

    if (pPriv->buffers == NULL) {
        return -1;
    }

    for (i = 0; i < pPriv->bufferCount; i++) {
        if ((pPriv->buffers[i] != NULL)
            && (pPriv->buffers[i]->attachment == attachment)) {
            return i;
        }
    }

    return -1;
}

static Bool
allocate_or_reuse_buffer(DrawablePtr pDraw, DRI2ScreenPtr ds,
                         DRI2DrawablePtr pPriv,
                         unsigned int attachment, unsigned int format,
                         int dimensions_match, DRI2BufferPtr * buffer)
{
    int old_buf = find_attachment(pPriv, attachment);

    if ((old_buf < 0)
        || attachment == DRI2BufferFrontLeft
        || !dimensions_match || (pPriv->buffers[old_buf]->format != format)) {
        *buffer = create_buffer(ds, pDraw, attachment, format);
        return TRUE;

    }
    else {
        *buffer = pPriv->buffers[old_buf];

        if (ds->ReuseBufferNotify)
            (*ds->ReuseBufferNotify) (pDraw, *buffer);

        pPriv->buffers[old_buf] = NULL;
        return FALSE;
    }
}

static void
update_dri2_drawable_buffers(DRI2DrawablePtr pPriv, DrawablePtr pDraw,
                             DRI2BufferPtr * buffers, int out_count, int *width,
                             int *height)
{
    int i;

    if (pPriv->buffers != NULL) {
        for (i = 0; i < pPriv->bufferCount; i++) {
            if (pPriv->buffers[i] != NULL) {
                destroy_buffer(pDraw, pPriv->buffers[i], pPriv->prime_id);
            }
        }

        free(pPriv->buffers);
    }

    pPriv->buffers = buffers;
    pPriv->bufferCount = out_count;
    pPriv->width = pDraw->width;
    pPriv->height = pDraw->height;
    *width = pPriv->width;
    *height = pPriv->height;
}

static DRI2BufferPtr *
do_get_buffers(DrawablePtr pDraw, int *width, int *height,
               unsigned int *attachments, int count, int *out_count,
               int has_format)
{
    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDraw);
    DRI2ScreenPtr ds;
    DRI2BufferPtr *buffers;
    int need_real_front = 0;
    int need_fake_front = 0;
    int have_fake_front = 0;
    int front_format = 0;
    int dimensions_match;
    int buffers_changed = 0;
    int i;

    if (!pPriv) {
        *width = pDraw->width;
        *height = pDraw->height;
        *out_count = 0;
        return NULL;
    }

    ds = DRI2GetScreenPrime(pDraw->pScreen, pPriv->prime_id);

    dimensions_match = (pDraw->width == pPriv->width)
        && (pDraw->height == pPriv->height);

    buffers = calloc((count + 1), sizeof(buffers[0]));
    if (!buffers)
        goto err_out;

    for (i = 0; i < count; i++) {
        const unsigned attachment = *(attachments++);
        const unsigned format = (has_format) ? *(attachments++) : 0;

        if (allocate_or_reuse_buffer(pDraw, ds, pPriv, attachment,
                                     format, dimensions_match, &buffers[i]))
            buffers_changed = 1;

        if (buffers[i] == NULL)
            goto err_out;

        /* If the drawable is a window and the front-buffer is requested,
         * silently add the fake front-buffer to the list of requested
         * attachments.  The counting logic in the loop accounts for the case
         * where the client requests both the fake and real front-buffer.
         */
        if (attachment == DRI2BufferBackLeft) {
            need_real_front++;
            front_format = format;
        }

        if (attachment == DRI2BufferFrontLeft) {
            need_real_front--;
            front_format = format;

            if (pDraw->type == DRAWABLE_WINDOW) {
                need_fake_front++;
            }
        }

        if (pDraw->type == DRAWABLE_WINDOW) {
            if (attachment == DRI2BufferFakeFrontLeft) {
                need_fake_front--;
                have_fake_front = 1;
            }
        }
    }

    if (need_real_front > 0) {
        if (allocate_or_reuse_buffer(pDraw, ds, pPriv, DRI2BufferFrontLeft,
                                     front_format, dimensions_match,
                                     &buffers[i]))
            buffers_changed = 1;

        if (buffers[i] == NULL)
            goto err_out;
        i++;
    }

    if (need_fake_front > 0) {
        if (allocate_or_reuse_buffer(pDraw, ds, pPriv, DRI2BufferFakeFrontLeft,
                                     front_format, dimensions_match,
                                     &buffers[i]))
            buffers_changed = 1;

        if (buffers[i] == NULL)
            goto err_out;

        i++;
        have_fake_front = 1;
    }

    *out_count = i;

    update_dri2_drawable_buffers(pPriv, pDraw, buffers, *out_count, width,
                                 height);

    /* If the client is getting a fake front-buffer, pre-fill it with the
     * contents of the real front-buffer.  This ensures correct operation of
     * applications that call glXWaitX before calling glDrawBuffer.
     */
    if (have_fake_front && buffers_changed) {
        BoxRec box;
        RegionRec region;

        box.x1 = 0;
        box.y1 = 0;
        box.x2 = pPriv->width;
        box.y2 = pPriv->height;
        RegionInit(&region, &box, 0);

        DRI2CopyRegion(pDraw, &region, DRI2BufferFakeFrontLeft,
                       DRI2BufferFrontLeft);
    }

    pPriv->needInvalidate = TRUE;

    return pPriv->buffers;

 err_out:

    *out_count = 0;

    if (buffers) {
        for (i = 0; i < count; i++) {
            if (buffers[i] != NULL)
                destroy_buffer(pDraw, buffers[i], 0);
        }

        free(buffers);
        buffers = NULL;
    }

    update_dri2_drawable_buffers(pPriv, pDraw, buffers, *out_count, width,
                                 height);

    return buffers;
}

DRI2BufferPtr *
DRI2GetBuffers(DrawablePtr pDraw, int *width, int *height,
               unsigned int *attachments, int count, int *out_count)
{
    return do_get_buffers(pDraw, width, height, attachments, count,
                          out_count, FALSE);
}

DRI2BufferPtr *
DRI2GetBuffersWithFormat(DrawablePtr pDraw, int *width, int *height,
                         unsigned int *attachments, int count, int *out_count)
{
    return do_get_buffers(pDraw, width, height, attachments, count,
                          out_count, TRUE);
}

static void
DRI2InvalidateDrawable(DrawablePtr pDraw)
{
    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDraw);
    DRI2DrawableRefPtr ref;

    if (!pPriv || !pPriv->needInvalidate)
        return;

    pPriv->needInvalidate = FALSE;

    xorg_list_for_each_entry(ref, &pPriv->reference_list, link)
        ref->invalidate(pDraw, ref->priv, ref->id);
}

/*
 * In the direct rendered case, we throttle the clients that have more
 * than their share of outstanding swaps (and thus busy buffers) when a
 * new GetBuffers request is received.  In the AIGLX case, we allow the
 * client to get the new buffers, but throttle when the next GLX request
 * comes in (see __glXDRIcontextWait()).
 */
Bool
DRI2ThrottleClient(ClientPtr client, DrawablePtr pDraw)
{
    DRI2DrawablePtr pPriv;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL)
        return FALSE;

    /* Throttle to swap limit */
    if (pPriv->swapsPending >= pPriv->swap_limit) {
        if (dri2Sleep(client, pPriv, WAKE_SWAP)) {
            ResetCurrentRequest(client);
            client->sequence--;
            return TRUE;
        }
    }

    return FALSE;
}

void
DRI2BlockClient(ClientPtr client, DrawablePtr pDraw)
{
    DRI2DrawablePtr pPriv;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL)
        return;

    dri2Sleep(client, pPriv, WAKE_MSC);
}

static inline PixmapPtr GetDrawablePixmap(DrawablePtr drawable)
{
    if (drawable->type == DRAWABLE_PIXMAP)
        return (PixmapPtr)drawable;
    else {
        struct _Window *pWin = (struct _Window *)drawable;
        return drawable->pScreen->GetWindowPixmap(pWin);
    }
}

/*
 * A TraverseTree callback to invalidate all windows using the same
 * pixmap
 */
static int
DRI2InvalidateWalk(WindowPtr pWin, void *data)
{
    if (pWin->drawable.pScreen->GetWindowPixmap(pWin) != data)
        return WT_DONTWALKCHILDREN;
    DRI2InvalidateDrawable(&pWin->drawable);
    return WT_WALKCHILDREN;
}

static void
DRI2InvalidateDrawableAll(DrawablePtr pDraw)
{
    if (pDraw->type == DRAWABLE_WINDOW) {
        WindowPtr pWin = (WindowPtr) pDraw;
        PixmapPtr pPixmap = pDraw->pScreen->GetWindowPixmap(pWin);

        /*
         * Find the top-most window using this pixmap
         */
        while (pWin->parent &&
               pDraw->pScreen->GetWindowPixmap(pWin->parent) == pPixmap)
            pWin = pWin->parent;

        /*
         * Walk the sub-tree to invalidate all of the
         * windows using the same pixmap
         */
        TraverseTree(pWin, DRI2InvalidateWalk, pPixmap);
        DRI2InvalidateDrawable(&pPixmap->drawable);
    }
    else
        DRI2InvalidateDrawable(pDraw);
}

DrawablePtr DRI2UpdatePrime(DrawablePtr pDraw, DRI2BufferPtr pDest)
{
    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDraw);
    PixmapPtr spix;
    PixmapPtr mpix = GetDrawablePixmap(pDraw);
    ScreenPtr master, slave;
    Bool ret;

    master = mpix->drawable.pScreen;

    if (pDraw->type == DRAWABLE_WINDOW) {
        WindowPtr pWin = (WindowPtr)pDraw;
        PixmapPtr pPixmap = pDraw->pScreen->GetWindowPixmap(pWin);

        if (pDraw->pScreen->GetScreenPixmap(pDraw->pScreen) == pPixmap) {
            if (pPriv->redirectpixmap &&
                pPriv->redirectpixmap->drawable.width == pDraw->width &&
                pPriv->redirectpixmap->drawable.height == pDraw->height &&
                pPriv->redirectpixmap->drawable.depth == pDraw->depth) {
                mpix = pPriv->redirectpixmap;
            } else {
                if (master->ReplaceScanoutPixmap) {
                    mpix = (*master->CreatePixmap)(master, pDraw->width, pDraw->height,
                                                   pDraw->depth, CREATE_PIXMAP_USAGE_SHARED);
                    if (!mpix)
                        return NULL;

                    ret = (*master->ReplaceScanoutPixmap)(pDraw, mpix, TRUE);
                    if (ret == FALSE) {
                        (*master->DestroyPixmap)(mpix);
                        return NULL;
                    }
                    pPriv->redirectpixmap = mpix;
                } else
                    return NULL;
            }
        } else if (pPriv->redirectpixmap) {
            (*master->ReplaceScanoutPixmap)(pDraw, pPriv->redirectpixmap, FALSE);
            (*master->DestroyPixmap)(pPriv->redirectpixmap);
            pPriv->redirectpixmap = NULL;
        }
    }

    slave = GetScreenPrime(pDraw->pScreen, pPriv->prime_id);

    /* check if the pixmap is still fine */
    if (pPriv->prime_slave_pixmap) {
        if (pPriv->prime_slave_pixmap->master_pixmap == mpix)
            return &pPriv->prime_slave_pixmap->drawable;
        else {
            (*pPriv->prime_slave_pixmap->master_pixmap->drawable.pScreen->DestroyPixmap)(pPriv->prime_slave_pixmap->master_pixmap);
            (*slave->DestroyPixmap)(pPriv->prime_slave_pixmap);
            pPriv->prime_slave_pixmap = NULL;
        }
    }

    spix = PixmapShareToSlave(mpix, slave);
    if (!spix)
        return NULL;

    pPriv->prime_slave_pixmap = spix;
#ifdef COMPOSITE
    spix->screen_x = mpix->screen_x;
    spix->screen_y = mpix->screen_y;
#endif

    DRI2InvalidateDrawableAll(pDraw);
    return &spix->drawable;
}

static void dri2_copy_region(DrawablePtr pDraw, RegionPtr pRegion,
                             DRI2BufferPtr pDest, DRI2BufferPtr pSrc)
{
    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDraw);
    DRI2ScreenPtr ds;
    ScreenPtr primeScreen;

    primeScreen = GetScreenPrime(pDraw->pScreen, pPriv->prime_id);
    ds = DRI2GetScreen(primeScreen);

    if (ds->CopyRegion2)
        (*ds->CopyRegion2)(primeScreen, pDraw, pRegion, pDest, pSrc);
    else
        (*ds->CopyRegion) (pDraw, pRegion, pDest, pSrc);

    /* cause damage to the box */
    if (pPriv->prime_id) {
       BoxRec box;
       RegionRec region;
       box.x1 = 0;
       box.x2 = box.x1 + pDraw->width;
       box.y1 = 0;
       box.y2 = box.y1 + pDraw->height;
       RegionInit(&region, &box, 1);
       RegionTranslate(&region, pDraw->x, pDraw->y);
       DamageRegionAppend(pDraw, &region);
       DamageRegionProcessPending(pDraw);
       RegionUninit(&region);
    }
}

int
DRI2CopyRegion(DrawablePtr pDraw, RegionPtr pRegion,
               unsigned int dest, unsigned int src)
{
    DRI2DrawablePtr pPriv;
    DRI2BufferPtr pDestBuffer, pSrcBuffer;
    int i;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL)
        return BadDrawable;

    pDestBuffer = NULL;
    pSrcBuffer = NULL;
    for (i = 0; i < pPriv->bufferCount; i++) {
        if (pPriv->buffers[i]->attachment == dest)
            pDestBuffer = (DRI2BufferPtr) pPriv->buffers[i];
        if (pPriv->buffers[i]->attachment == src)
            pSrcBuffer = (DRI2BufferPtr) pPriv->buffers[i];
    }
    if (pSrcBuffer == NULL || pDestBuffer == NULL)
        return BadValue;

    dri2_copy_region(pDraw, pRegion, pDestBuffer, pSrcBuffer);

    return Success;
}

/* Can this drawable be page flipped? */
Bool
DRI2CanFlip(DrawablePtr pDraw)
{
    ScreenPtr pScreen = pDraw->pScreen;
    WindowPtr pWin, pRoot;
    PixmapPtr pWinPixmap, pRootPixmap;

    if (pDraw->type == DRAWABLE_PIXMAP)
        return TRUE;

    pRoot = pScreen->root;
    pRootPixmap = pScreen->GetWindowPixmap(pRoot);

    pWin = (WindowPtr) pDraw;
    pWinPixmap = pScreen->GetWindowPixmap(pWin);
    if (pRootPixmap != pWinPixmap)
        return FALSE;
    if (!RegionEqual(&pWin->clipList, &pRoot->winSize))
        return FALSE;

    /* Does the window match the pixmap exactly? */
    if (pDraw->x != 0 || pDraw->y != 0 ||
#ifdef COMPOSITE
        pDraw->x != pWinPixmap->screen_x || pDraw->y != pWinPixmap->screen_y ||
#endif
        pDraw->width != pWinPixmap->drawable.width ||
        pDraw->height != pWinPixmap->drawable.height)
        return FALSE;

    return TRUE;
}

/* Can we do a pixmap exchange instead of a blit? */
Bool
DRI2CanExchange(DrawablePtr pDraw)
{
    return FALSE;
}

void
DRI2WaitMSCComplete(ClientPtr client, DrawablePtr pDraw, int frame,
                    unsigned int tv_sec, unsigned int tv_usec)
{
    DRI2DrawablePtr pPriv;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL)
        return;

    ProcDRI2WaitMSCReply(client, ((CARD64) tv_sec * 1000000) + tv_usec,
                         frame, pPriv->swap_count);

    dri2WakeAll(client, pPriv, WAKE_MSC);
}

static void
DRI2WakeClient(ClientPtr client, DrawablePtr pDraw, int frame,
               unsigned int tv_sec, unsigned int tv_usec)
{
    ScreenPtr pScreen = pDraw->pScreen;
    DRI2DrawablePtr pPriv;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL) {
        xf86DrvMsg(pScreen->myNum, X_ERROR,
                   "[DRI2] %s: bad drawable\n", __func__);
        return;
    }

    /*
     * Swap completed.
     * Wake the client iff:
     *   - it was waiting on SBC
     *   - was blocked due to GLX make current
     *   - was blocked due to swap throttling
     *   - is not blocked due to an MSC wait
     */
    if (pPriv->target_sbc != -1 && pPriv->target_sbc <= pPriv->swap_count) {
        if (dri2WakeAll(client, pPriv, WAKE_SBC)) {
            ProcDRI2WaitMSCReply(client, ((CARD64) tv_sec * 1000000) + tv_usec,
                                 frame, pPriv->swap_count);
            pPriv->target_sbc = -1;
        }
    }

    dri2WakeAll(CLIENT_SIGNAL_ANY, pPriv, WAKE_SWAP);
}

void
DRI2SwapComplete(ClientPtr client, DrawablePtr pDraw, int frame,
                 unsigned int tv_sec, unsigned int tv_usec, int type,
                 DRI2SwapEventPtr swap_complete, void *swap_data)
{
    ScreenPtr pScreen = pDraw->pScreen;
    DRI2DrawablePtr pPriv;
    CARD64 ust = 0;
    BoxRec box;
    RegionRec region;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL) {
        xf86DrvMsg(pScreen->myNum, X_ERROR,
                   "[DRI2] %s: bad drawable\n", __func__);
        return;
    }

    pPriv->swapsPending--;
    pPriv->swap_count++;

    box.x1 = 0;
    box.y1 = 0;
    box.x2 = pDraw->width;
    box.y2 = pDraw->height;
    RegionInit(&region, &box, 0);
    DRI2CopyRegion(pDraw, &region, DRI2BufferFakeFrontLeft,
                   DRI2BufferFrontLeft);

    ust = ((CARD64) tv_sec * 1000000) + tv_usec;
    if (swap_complete)
        swap_complete(client, swap_data, type, ust, frame, pPriv->swap_count);

    pPriv->last_swap_msc = frame;
    pPriv->last_swap_ust = ust;

    DRI2WakeClient(client, pDraw, frame, tv_sec, tv_usec);
}

Bool
DRI2WaitSwap(ClientPtr client, DrawablePtr pDrawable)
{
    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDrawable);

    /* If we're currently waiting for a swap on this drawable, reset
     * the request and suspend the client. */
    if (pPriv && pPriv->swapsPending) {
        if (dri2Sleep(client, pPriv, WAKE_SWAP)) {
            ResetCurrentRequest(client);
            client->sequence--;
            return TRUE;
        }
    }

    return FALSE;
}



int
DRI2SwapBuffers(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
                CARD64 divisor, CARD64 remainder, CARD64 * swap_target,
                DRI2SwapEventPtr func, void *data)
{
    ScreenPtr pScreen = pDraw->pScreen;
    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
    DRI2DrawablePtr pPriv;
    DRI2BufferPtr pDestBuffer = NULL, pSrcBuffer = NULL;
    int ret, i;
    CARD64 ust, current_msc;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL) {
        xf86DrvMsg(pScreen->myNum, X_ERROR,
                   "[DRI2] %s: bad drawable\n", __func__);
        return BadDrawable;
    }

    /* According to spec, return expected swapbuffers count SBC after this swap
     * will complete. This is ignored unless we return Success, but it must be
     * initialized on every path where we return Success or the caller will send
     * an uninitialized value off the stack to the client. So let's initialize
     * it as early as possible, just to be sure.
     */
    *swap_target = pPriv->swap_count + pPriv->swapsPending + 1;

    for (i = 0; i < pPriv->bufferCount; i++) {
        if (pPriv->buffers[i]->attachment == DRI2BufferFrontLeft)
            pDestBuffer = (DRI2BufferPtr) pPriv->buffers[i];
        if (pPriv->buffers[i]->attachment == DRI2BufferBackLeft)
            pSrcBuffer = (DRI2BufferPtr) pPriv->buffers[i];
    }
    if (pSrcBuffer == NULL || pDestBuffer == NULL) {
        xf86DrvMsg(pScreen->myNum, X_ERROR,
                   "[DRI2] %s: drawable has no back or front?\n", __func__);
        return BadDrawable;
    }

    /* Old DDX or no swap interval, just blit */
    if (!ds->ScheduleSwap || !pPriv->swap_interval || pPriv->prime_id) {
        BoxRec box;
        RegionRec region;

        box.x1 = 0;
        box.y1 = 0;
        box.x2 = pDraw->width;
        box.y2 = pDraw->height;
        RegionInit(&region, &box, 0);

        pPriv->swapsPending++;

        dri2_copy_region(pDraw, &region, pDestBuffer, pSrcBuffer);
        DRI2SwapComplete(client, pDraw, target_msc, 0, 0, DRI2_BLIT_COMPLETE,
                         func, data);
        return Success;
    }

    /*
     * In the simple glXSwapBuffers case, all params will be 0, and we just
     * need to schedule a swap for the last swap target + the swap interval.
     */
    if (target_msc == 0 && divisor == 0 && remainder == 0) {
        /* If the current vblank count of the drawable's crtc is lower
         * than the count stored in last_swap_target from a previous swap
         * then reinitialize last_swap_target to the current crtc's msc,
         * otherwise the swap will hang. This will happen if the drawable
         * is moved to a crtc with a lower refresh rate, or a crtc that just
         * got enabled.
         */
        if (ds->GetMSC) {
            if (!(*ds->GetMSC) (pDraw, &ust, &current_msc))
                pPriv->last_swap_target = 0;

            if (current_msc < pPriv->last_swap_target)
                pPriv->last_swap_target = current_msc;

        }

        /*
         * Swap target for this swap is last swap target + swap interval since
         * we have to account for the current swap count, interval, and the
         * number of pending swaps.
         */
        target_msc = pPriv->last_swap_target + pPriv->swap_interval;

    }

    pPriv->swapsPending++;
    ret = (*ds->ScheduleSwap) (client, pDraw, pDestBuffer, pSrcBuffer,
                               &target_msc, divisor, remainder, func, data);
    if (!ret) {
        pPriv->swapsPending--;  /* didn't schedule */
        xf86DrvMsg(pScreen->myNum, X_ERROR,
                   "[DRI2] %s: driver failed to schedule swap\n", __func__);
        return BadDrawable;
    }

    pPriv->last_swap_target = target_msc;

    DRI2InvalidateDrawableAll(pDraw);

    return Success;
}

void
DRI2SwapInterval(DrawablePtr pDrawable, int interval)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDrawable);

    if (pPriv == NULL) {
        xf86DrvMsg(pScreen->myNum, X_ERROR,
                   "[DRI2] %s: bad drawable\n", __func__);
        return;
    }

    /* fixme: check against arbitrary max? */
    pPriv->swap_interval = interval;
}

int
DRI2GetMSC(DrawablePtr pDraw, CARD64 * ust, CARD64 * msc, CARD64 * sbc)
{
    ScreenPtr pScreen = pDraw->pScreen;
    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
    DRI2DrawablePtr pPriv;
    Bool ret;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL) {
        xf86DrvMsg(pScreen->myNum, X_ERROR,
                   "[DRI2] %s: bad drawable\n", __func__);
        return BadDrawable;
    }

    if (!ds->GetMSC) {
        *ust = 0;
        *msc = 0;
        *sbc = pPriv->swap_count;
        return Success;
    }

    /*
     * Spec needs to be updated to include unmapped or redirected
     * drawables
     */

    ret = (*ds->GetMSC) (pDraw, ust, msc);
    if (!ret)
        return BadDrawable;

    *sbc = pPriv->swap_count;

    return Success;
}

int
DRI2WaitMSC(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
            CARD64 divisor, CARD64 remainder)
{
    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
    DRI2DrawablePtr pPriv;
    Bool ret;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL)
        return BadDrawable;

    /* Old DDX just completes immediately */
    if (!ds->ScheduleWaitMSC) {
        DRI2WaitMSCComplete(client, pDraw, target_msc, 0, 0);

        return Success;
    }

    ret =
        (*ds->ScheduleWaitMSC) (client, pDraw, target_msc, divisor, remainder);
    if (!ret)
        return BadDrawable;

    return Success;
}

int
DRI2WaitSBC(ClientPtr client, DrawablePtr pDraw, CARD64 target_sbc)
{
    DRI2DrawablePtr pPriv;

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv == NULL)
        return BadDrawable;

    if (pPriv->target_sbc != -1) /* already in use */
        return BadDrawable;

    /* target_sbc == 0 means to block until all pending swaps are
     * finished. Recalculate target_sbc to get that behaviour.
     */
    if (target_sbc == 0)
        target_sbc = pPriv->swap_count + pPriv->swapsPending;

    /* If current swap count already >= target_sbc, reply and
     * return immediately with (ust, msc, sbc) triplet of
     * most recent completed swap.
     */
    if (pPriv->swap_count >= target_sbc) {
        ProcDRI2WaitMSCReply(client, pPriv->last_swap_ust,
                             pPriv->last_swap_msc, pPriv->swap_count);
        return Success;
    }

    if (!dri2Sleep(client, pPriv, WAKE_SBC))
        return BadAlloc;

    pPriv->target_sbc = target_sbc;
    return Success;
}

Bool
DRI2HasSwapControl(ScreenPtr pScreen)
{
    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);

    return ds->ScheduleSwap && ds->GetMSC;
}

Bool
DRI2Connect(ClientPtr client, ScreenPtr pScreen,
            unsigned int driverType, int *fd,
            const char **driverName, const char **deviceName)
{
    DRI2ScreenPtr ds;
    uint32_t prime_id = DRI2DriverPrimeId(driverType);
    uint32_t driver_id = driverType & 0xffff;

    if (!dixPrivateKeyRegistered(dri2ScreenPrivateKey))
        return FALSE;

    ds = DRI2GetScreenPrime(pScreen, prime_id);
    if (ds == NULL)
        return FALSE;

    if (driver_id >= ds->numDrivers ||
        !ds->driverNames[driver_id])
        return FALSE;

    *driverName = ds->driverNames[driver_id];
    *deviceName = ds->deviceName;
    *fd = ds->fd;

    if (client) {
        DRI2ClientPtr dri2_client;
        dri2_client = dri2ClientPrivate(client);
        dri2_client->prime_id = prime_id;
    }

    return TRUE;
}

static int
DRI2AuthMagic (ScreenPtr pScreen, uint32_t magic)
{
    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
    if (ds == NULL)
        return -EINVAL;

    return (*ds->LegacyAuthMagic) (ds->fd, magic);
}

Bool
DRI2Authenticate(ClientPtr client, ScreenPtr pScreen, uint32_t magic)
{
    DRI2ScreenPtr ds;
    DRI2ClientPtr dri2_client = dri2ClientPrivate(client);
    ScreenPtr primescreen;

    ds = DRI2GetScreenPrime(pScreen, dri2_client->prime_id);
    if (ds == NULL)
        return FALSE;

    primescreen = GetScreenPrime(pScreen, dri2_client->prime_id);
    if ((*ds->AuthMagic)(primescreen, magic))
        return FALSE;
    return TRUE;
}

static int
DRI2ConfigNotify(WindowPtr pWin, int x, int y, int w, int h, int bw,
                 WindowPtr pSib)
{
    DrawablePtr pDraw = (DrawablePtr) pWin;
    ScreenPtr pScreen = pDraw->pScreen;
    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
    DRI2DrawablePtr dd = DRI2GetDrawable(pDraw);
    int ret;

    if (ds->ConfigNotify) {
        pScreen->ConfigNotify = ds->ConfigNotify;

        ret = (*pScreen->ConfigNotify) (pWin, x, y, w, h, bw, pSib);

        ds->ConfigNotify = pScreen->ConfigNotify;
        pScreen->ConfigNotify = DRI2ConfigNotify;
        if (ret)
            return ret;
    }

    if (!dd || (dd->width == w && dd->height == h))
        return Success;

    DRI2InvalidateDrawable(pDraw);
    return Success;
}

static void
DRI2SetWindowPixmap(WindowPtr pWin, PixmapPtr pPix)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);

    pScreen->SetWindowPixmap = ds->SetWindowPixmap;
    (*pScreen->SetWindowPixmap) (pWin, pPix);
    ds->SetWindowPixmap = pScreen->SetWindowPixmap;
    pScreen->SetWindowPixmap = DRI2SetWindowPixmap;

    DRI2InvalidateDrawable(&pWin->drawable);
}

#define MAX_PRIME DRI2DriverPrimeMask
static int
get_prime_id(void)
{
    int i;
    /* start at 1, prime id 0 is just normal driver */
    for (i = 1; i < MAX_PRIME; i++) {
         if (prime_id_allocate_bitmask & (1 << i))
             continue;

         prime_id_allocate_bitmask |= (1 << i);
         return i;
    }
    return -1;
}

#include "pci_ids/pci_id_driver_map.h"

static char *
dri2_probe_driver_name(ScreenPtr pScreen, DRI2InfoPtr info)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    EntityInfoPtr pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
    struct pci_device *pdev = NULL;
    int i, j;

    if (pEnt)
        pdev = xf86GetPciInfoForEntity(pEnt->index);

    /* For non-PCI devices, just assume that the 3D driver is named
     * the same as the kernel driver.  This is currently true for vc4
     * and msm (freedreno).
     */
    if (!pdev) {
        drmVersionPtr version = drmGetVersion(info->fd);
        char *kernel_driver;

        if (!version) {
            xf86DrvMsg(pScreen->myNum, X_ERROR,
                       "[DRI2] Couldn't drmGetVersion() on non-PCI device, "
                       "no driver name found.\n");
            return NULL;
        }

        kernel_driver = strndup(version->name, version->name_len);
        drmFreeVersion(version);
        return kernel_driver;
    }

    for (i = 0; driver_map[i].driver; i++) {
        if (pdev->vendor_id != driver_map[i].vendor_id)
            continue;

        if (driver_map[i].num_chips_ids == -1)
            return strdup(driver_map[i].driver);

        for (j = 0; j < driver_map[i].num_chips_ids; j++) {
            if (driver_map[i].chip_ids[j] == pdev->device_id)
                return strdup(driver_map[i].driver);
        }
    }

    xf86DrvMsg(pScreen->myNum, X_ERROR,
               "[DRI2] No driver mapping found for PCI device "
               "0x%04x / 0x%04x\n",
               pdev->vendor_id, pdev->device_id);
    return NULL;
}

Bool
DRI2ScreenInit(ScreenPtr pScreen, DRI2InfoPtr info)
{
    DRI2ScreenPtr ds;

    const char *driverTypeNames[] = {
        "DRI",                  /* DRI2DriverDRI */
        "VDPAU",                /* DRI2DriverVDPAU */
    };
    unsigned int i;
    CARD8 cur_minor;

    if (info->version < 3)
        return FALSE;

    if (!xf86VGAarbiterAllowDRI(pScreen)) {
        xf86DrvMsg(pScreen->myNum, X_WARNING,
                   "[DRI2] Direct rendering is not supported when VGA arb is necessary for the device\n");
        return FALSE;
    }

    if (!dixRegisterPrivateKey(&dri2ScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    if (!dixRegisterPrivateKey(&dri2WindowPrivateKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;

    if (!dixRegisterPrivateKey(&dri2PixmapPrivateKeyRec, PRIVATE_PIXMAP, 0))
        return FALSE;

    if (!dixRegisterPrivateKey(&dri2ClientPrivateKeyRec, PRIVATE_CLIENT, sizeof(DRI2ClientRec)))
        return FALSE;

    ds = calloc(1, sizeof *ds);
    if (!ds)
        return FALSE;

    ds->screen = pScreen;
    ds->fd = info->fd;
    ds->deviceName = info->deviceName;
    dri2_major = 1;

    ds->CreateBuffer = info->CreateBuffer;
    ds->DestroyBuffer = info->DestroyBuffer;
    ds->CopyRegion = info->CopyRegion;

    if (info->version >= 4) {
        ds->ScheduleSwap = info->ScheduleSwap;
        ds->ScheduleWaitMSC = info->ScheduleWaitMSC;
        ds->GetMSC = info->GetMSC;
        cur_minor = 3;
    }
    else {
        cur_minor = 1;
    }

    if (info->version >= 8) {
        ds->AuthMagic = info->AuthMagic2;
    }
    if (info->version >= 5) {
        ds->LegacyAuthMagic = info->AuthMagic;
    }

    if (info->version >= 6) {
        ds->ReuseBufferNotify = info->ReuseBufferNotify;
        ds->SwapLimitValidate = info->SwapLimitValidate;
    }

    if (info->version >= 7) {
        ds->GetParam = info->GetParam;
        cur_minor = 4;
    }

    if (info->version >= 9) {
        ds->CreateBuffer2 = info->CreateBuffer2;
        if (info->CreateBuffer2 && pScreen->isGPU) {
            ds->prime_id = get_prime_id();
            if (ds->prime_id == -1) {
                free(ds);
                return FALSE;
            }
        }
        ds->DestroyBuffer2 = info->DestroyBuffer2;
        ds->CopyRegion2 = info->CopyRegion2;
    }

    /*
     * if the driver doesn't provide an AuthMagic function or the info struct
     * version is too low, call through LegacyAuthMagic
     */
    if (!ds->AuthMagic) {
        ds->AuthMagic = DRI2AuthMagic;
        /*
         * If the driver doesn't provide an AuthMagic function
         * it relies on the old method (using libdrm) or fails
         */
        if (!ds->LegacyAuthMagic)
#ifdef WITH_LIBDRM
            ds->LegacyAuthMagic = drmAuthMagic;
#else
            goto err_out;
#endif
    }

    /* Initialize minor if needed and set to minimum provied by DDX */
    if (!dri2_minor || dri2_minor > cur_minor)
        dri2_minor = cur_minor;

    if (info->version == 3 || info->numDrivers == 0) {
        /* Driver too old: use the old-style driverName field */
        ds->numDrivers = info->driverName ? 1 : 2;
        ds->driverNames = xallocarray(ds->numDrivers, sizeof(*ds->driverNames));
        if (!ds->driverNames)
            goto err_out;

        if (info->driverName) {
            ds->driverNames[0] = info->driverName;
        } else {
            ds->driverNames[0] = ds->driverNames[1] = dri2_probe_driver_name(pScreen, info);
            if (!ds->driverNames[0])
                return FALSE;
        }
    }
    else {
        ds->numDrivers = info->numDrivers;
        ds->driverNames = xallocarray(info->numDrivers, sizeof(*ds->driverNames));
        if (!ds->driverNames)
            goto err_out;
        memcpy(ds->driverNames, info->driverNames,
               info->numDrivers * sizeof(*ds->driverNames));
    }

    dixSetPrivate(&pScreen->devPrivates, dri2ScreenPrivateKey, ds);

    ds->ConfigNotify = pScreen->ConfigNotify;
    pScreen->ConfigNotify = DRI2ConfigNotify;

    ds->SetWindowPixmap = pScreen->SetWindowPixmap;
    pScreen->SetWindowPixmap = DRI2SetWindowPixmap;

    xf86DrvMsg(pScreen->myNum, X_INFO, "[DRI2] Setup complete\n");
    for (i = 0; i < sizeof(driverTypeNames) / sizeof(driverTypeNames[0]); i++) {
        if (i < ds->numDrivers && ds->driverNames[i]) {
            xf86DrvMsg(pScreen->myNum, X_INFO, "[DRI2]   %s driver: %s\n",
                       driverTypeNames[i], ds->driverNames[i]);
        }
    }

    return TRUE;

 err_out:
    xf86DrvMsg(pScreen->myNum, X_WARNING,
               "[DRI2] Initialization failed for info version %d.\n",
               info->version);
    free(ds);
    return FALSE;
}

void
DRI2CloseScreen(ScreenPtr pScreen)
{
    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);

    pScreen->ConfigNotify = ds->ConfigNotify;
    pScreen->SetWindowPixmap = ds->SetWindowPixmap;

    if (ds->prime_id)
        prime_id_allocate_bitmask &= ~(1 << ds->prime_id);
    free(ds->driverNames);
    free(ds);
    dixSetPrivate(&pScreen->devPrivates, dri2ScreenPrivateKey, NULL);
}

/* Called by InitExtensions() */
Bool
DRI2ModuleSetup(void)
{
    dri2DrawableRes = CreateNewResourceType(DRI2DrawableGone, "DRI2Drawable");
    if (!dri2DrawableRes)
        return FALSE;

    return TRUE;
}

void
DRI2Version(int *major, int *minor)
{
    if (major != NULL)
        *major = 1;

    if (minor != NULL)
        *minor = 2;
}

int
DRI2GetParam(ClientPtr client,
             DrawablePtr drawable,
             CARD64 param,
             BOOL *is_param_recognized,
             CARD64 *value)
{
    DRI2ScreenPtr ds = DRI2GetScreen(drawable->pScreen);
    char high_byte = (param >> 24);

    switch (high_byte) {
    case 0:
        /* Parameter names whose high_byte is 0 are reserved for the X
         * server. The server currently recognizes no parameters.
         */
        goto not_recognized;
    case 1:
        /* Parameter names whose high byte is 1 are reserved for the DDX. */
        if (ds->GetParam)
            return ds->GetParam(client, drawable, param,
                                is_param_recognized, value);
        else
            goto not_recognized;
    default:
        /* Other parameter names are reserved for future use. They are never
         * recognized.
         */
        goto not_recognized;
    }

not_recognized:
    *is_param_recognized = FALSE;
    return Success;
}
@


1.15
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a92 2
    ClientPtr blockedClient;
    Bool blockedOnMsc;
d100 1
d141 38
a249 2
    pPriv->blockedClient = NULL;
    pPriv->blockedOnMsc = FALSE;
d257 1
d297 1
a297 7
    if (pPriv->target_sbc == -1 && !pPriv->blockedOnMsc) {
        if (pPriv->blockedClient) {
            AttendClient(pPriv->blockedClient);
            pPriv->blockedClient = NULL;
        }
    }

d446 4
d741 6
a746 6
    if ((pPriv->swapsPending >= pPriv->swap_limit) && !pPriv->blockedClient) {
        ResetCurrentRequest(client);
        client->sequence--;
        IgnoreClient(client);
        pPriv->blockedClient = client;
        return TRUE;
a751 9
static void
__DRI2BlockClient(ClientPtr client, DRI2DrawablePtr pPriv)
{
    if (pPriv->blockedClient == NULL) {
        IgnoreClient(client);
        pPriv->blockedClient = client;
    }
}

d761 1
a761 2
    __DRI2BlockClient(client, pPriv);
    pPriv->blockedOnMsc = TRUE;
d994 1
a994 5
    if (pPriv->blockedClient)
        AttendClient(pPriv->blockedClient);

    pPriv->blockedClient = NULL;
    pPriv->blockedOnMsc = FALSE;
d1020 4
a1023 11
        ProcDRI2WaitMSCReply(client, ((CARD64) tv_sec * 1000000) + tv_usec,
                             frame, pPriv->swap_count);
        pPriv->target_sbc = -1;

        AttendClient(pPriv->blockedClient);
        pPriv->blockedClient = NULL;
    }
    else if (pPriv->target_sbc == -1 && !pPriv->blockedOnMsc) {
        if (pPriv->blockedClient) {
            AttendClient(pPriv->blockedClient);
            pPriv->blockedClient = NULL;
d1026 2
d1075 7
a1081 7
     * the request and suspend the client.  We only support one
     * blocked client per drawable. */
    if (pPriv && pPriv->swapsPending && pPriv->blockedClient == NULL) {
        ResetCurrentRequest(client);
        client->sequence--;
        __DRI2BlockClient(client, pPriv);
        return TRUE;
d1282 3
d1301 3
a1304 2
    __DRI2BlockClient(client, pPriv);

d1407 1
a1407 2
    DrawablePtr pDraw = (DrawablePtr) pWin;
    ScreenPtr pScreen = pDraw->pScreen;
d1415 1
a1415 1
    DRI2InvalidateDrawableAll(pDraw);
d1598 1
a1598 1
        ds->driverNames = malloc(ds->numDrivers * sizeof(*ds->driverNames));
d1612 1
a1612 1
        ds->driverNames = malloc(info->numDrivers * sizeof(*ds->driverNames));
@


1.14
log
@Update to xserver 1.16.4.
Contains fix for CVE-2015-0255. ok dcoppa@@
@
text
@d1416 53
d1579 2
a1580 2
        ds->numDrivers = 1;
        ds->driverNames = malloc(sizeof(*ds->driverNames));
d1583 8
a1590 1
        ds->driverNames[0] = info->driverName;
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d159 3
@


1.12
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d133 1
d160 1
a160 1
            break;
d162 1
a162 3
    if (!slave)
        return master;
    return slave;
d356 1
a356 1
DRI2DrawableGone(pointer p, XID id)
d419 1
a419 1
create_buffer(DrawablePtr pDraw,
a421 3
    ScreenPtr primeScreen;
    DRI2DrawablePtr pPriv;
    DRI2ScreenPtr ds;
a422 3
    pPriv = DRI2GetDrawable(pDraw);
    primeScreen = GetScreenPrime(pDraw->pScreen, pPriv->prime_id);
    ds = DRI2GetScreenPrime(pDraw->pScreen, pPriv->prime_id);
d424 3
a426 1
        buffer = (*ds->CreateBuffer2)(primeScreen, pDraw, attachment, format);
d475 1
a475 1
        *buffer = create_buffer (pDraw, attachment, format);
d538 1
a538 1
    ds = DRI2GetScreen(pDraw->pScreen);
d752 1
a752 1
DRI2InvalidateWalk(WindowPtr pWin, pointer data)
d1090 8
d1155 1
a1155 1
        *swap_target = pPriv->last_swap_target + pPriv->swap_interval;
a1157 4
    else {
        /* glXSwapBuffersMscOML could have a 0 target_msc, honor it */
        *swap_target = target_msc;
    }
d1161 1
a1161 1
                               swap_target, divisor, remainder, func, data);
d1169 1
a1169 6
    pPriv->last_swap_target = *swap_target;

    /* According to spec, return expected swapbuffers count SBC after this swap
     * will complete.
     */
    *swap_target = pPriv->swap_count + pPriv->swapsPending;
d1382 15
d1543 3
d1570 1
a1577 2

extern Bool DRI2ModuleSetup(void);
@


1.11
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a101 1
    unsigned long serialNumber;
a190 13
static unsigned long
DRI2DrawableSerial(DrawablePtr pDraw)
{
    ScreenPtr pScreen = pDraw->pScreen;
    PixmapPtr pPix;

    if (pDraw->type != DRAWABLE_WINDOW)
        return pDraw->serialNumber;

    pPix = pScreen->GetWindowPixmap((WindowPtr) pDraw);
    return pPix->drawable.serialNumber;
}

a223 1
    pPriv->serialNumber = DRI2DrawableSerial(pDraw);
a480 1
        pPriv->serialNumber = DRI2DrawableSerial(pDraw);
d546 1
a546 2
        && (pDraw->height == pPriv->height)
        && (pPriv->serialNumber == DRI2DrawableSerial(pDraw));
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d47 1
d49 1
a49 1

d55 2
d69 11
d104 3
d117 1
d125 2
a126 1
    DRI2AuthMagicProcPtr AuthMagic;
d129 1
d134 3
d139 3
d148 26
d240 2
a241 1

d336 3
a338 2
DRI2CreateDrawable(ClientPtr client, DrawablePtr pDraw, XID id,
                   DRI2InvalidateProcPtr invalidate, void *priv)
d341 1
d351 2
d358 3
d364 7
a374 1
    DRI2ScreenPtr ds = pPriv->dri2_screen;
d412 5
d419 1
a419 1
            (*ds->DestroyBuffer) (pDraw, pPriv->buffers[i]);
d424 5
d434 31
d495 1
a495 1
        *buffer = (*ds->CreateBuffer) (pDraw, attachment, format);
a515 1
    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
d521 1
a521 1
                (*ds->DestroyBuffer) (pDraw, pPriv->buffers[i]);
a540 1
    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
d542 1
d559 2
d665 1
a665 1
                (*ds->DestroyBuffer) (pDraw, buffers[i]);
d759 149
a911 1
    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
d931 1
a931 1
    (*ds->CopyRegion) (pDraw, pRegion, pDestBuffer, pSrcBuffer);
d1091 1
a1091 12
/*
 * A TraverseTree callback to invalidate all windows using the same
 * pixmap
 */
static int
DRI2InvalidateWalk(WindowPtr pWin, pointer data)
{
    if (pWin->drawable.pScreen->GetWindowPixmap(pWin) != data)
        return WT_DONTWALKCHILDREN;
    DRI2InvalidateDrawable(&pWin->drawable);
    return WT_WALKCHILDREN;
}
d1125 1
a1125 1
    if (!ds->ScheduleSwap || !pPriv->swap_interval) {
d1137 1
a1137 1
        (*ds->CopyRegion) (pDraw, &region, pDestBuffer, pSrcBuffer);
d1194 1
a1194 20
    if (pDraw->type == DRAWABLE_WINDOW) {
        WindowPtr pWin = (WindowPtr) pDraw;
        PixmapPtr pPixmap = pScreen->GetWindowPixmap(pWin);

        /*
         * Find the top-most window using this pixmap
         */
        while (pWin->parent &&
               pScreen->GetWindowPixmap(pWin->parent) == pPixmap)
            pWin = pWin->parent;

        /*
         * Walk the sub-tree to invalidate all of the
         * windows using the same pixmap
         */
        TraverseTree(pWin, DRI2InvalidateWalk, pPixmap);
        DRI2InvalidateDrawable(&pPixmap->drawable);
    }
    else
        DRI2InvalidateDrawable(pDraw);
d1318 2
a1319 1
DRI2Connect(ScreenPtr pScreen, unsigned int driverType, int *fd,
d1323 2
d1329 6
a1334 3
    ds = DRI2GetScreen(pScreen);
    if (ds == NULL || driverType >= ds->numDrivers ||
        !ds->driverNames[driverType])
d1337 2
d1340 6
a1345 2
    *driverName = ds->driverNames[driverType];
    *deviceName = ds->deviceName;
d1350 10
d1361 1
a1361 1
DRI2Authenticate(ScreenPtr pScreen, uint32_t magic)
d1363 3
a1365 1
    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
d1367 2
a1368 1
    if (ds == NULL || (*ds->AuthMagic) (ds->fd, magic))
d1371 3
d1405 16
d1451 3
d1477 3
d1481 1
a1481 1
        ds->AuthMagic = info->AuthMagic;
d1489 18
d1509 1
a1509 1
     * version is too low, it relies on the old method (using libdrm) or fail
d1511 7
a1517 1
    if (!ds->AuthMagic)
d1519 1
a1519 1
        ds->AuthMagic = drmAuthMagic;
d1521 1
a1521 1
        goto err_out;
d1523 1
d1576 2
a1582 1
extern ExtensionModule dri2ExtensionModule;
a1595 32
static pointer
DRI2Setup(pointer module, pointer opts, int *errmaj, int *errmin)
{
    static Bool setupDone = FALSE;

    if (!setupDone) {
        setupDone = TRUE;
        LoadExtension(&dri2ExtensionModule, FALSE);
    }
    else {
        if (errmaj)
            *errmaj = LDR_ONCEONLY;
    }

    return (pointer) 1;
}

static XF86ModuleVersionInfo DRI2VersRec = {
    "dri2",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XORG_VERSION_CURRENT,
    1, 2, 0,
    ABI_CLASS_EXTENSION,
    ABI_EXTENSION_VERSION,
    MOD_CLASS_NONE,
    {0, 0, 0, 0}
};

_X_EXPORT XF86ModuleData dri2ModuleData = { &DRI2VersRec, DRI2Setup, NULL };

d1600 1
a1600 1
        *major = DRI2VersRec.majorversion;
d1603 36
a1638 1
        *minor = DRI2VersRec.minorversion;
@


1.9
log
@Bugfix Update to xserver 1.11.3
@
text
@d51 1
a51 1
CARD8 dri2_major; /* version of DRI2 supported by DDX */
d55 1
d59 1
d63 1
d66 1
a66 1
static RESTYPE       dri2DrawableRes;
d71 19
a89 19
    DRI2ScreenPtr        dri2_screen;
    DrawablePtr		 drawable;
    struct list		 reference_list;
    int			 width;
    int			 height;
    DRI2BufferPtr	*buffers;
    int			 bufferCount;
    unsigned int	 swapsPending;
    ClientPtr		 blockedClient;
    Bool		 blockedOnMsc;
    int			 swap_interval;
    CARD64		 swap_count;
    int64_t		 target_sbc; /* -1 means no SBC wait outstanding */
    CARD64		 last_swap_target; /* most recently queued swap target */
    CARD64		 last_swap_msc; /* msc at completion of most recent swap */
    CARD64		 last_swap_ust; /* ust at completion of most recent swap */
    int			 swap_limit; /* for N-buffering */
    unsigned long	 serialNumber;
    Bool		 needInvalidate;
d93 17
a109 15
    ScreenPtr			 screen;
    int				 refcnt;
    unsigned int		 numDrivers;
    const char			**driverNames;
    const char			*deviceName;
    int				 fd;
    unsigned int		 lastSequence;

    DRI2CreateBufferProcPtr	 CreateBuffer;
    DRI2DestroyBufferProcPtr	 DestroyBuffer;
    DRI2CopyRegionProcPtr	 CopyRegion;
    DRI2ScheduleSwapProcPtr	 ScheduleSwap;
    DRI2GetMSCProcPtr		 GetMSC;
    DRI2ScheduleWaitMSCProcPtr	 ScheduleWaitMSC;
    DRI2AuthMagicProcPtr	 AuthMagic;
d111 1
a111 1
    HandleExposuresProcPtr       HandleExposures;
d113 1
a113 1
    ConfigNotifyProcPtr		 ConfigNotify;
d130 2
a131 2
	pWin = (WindowPtr) pDraw;
	return dixLookupPrivate(&pWin->devPrivates, dri2WindowPrivateKey);
d133 2
a134 2
	pPixmap = (PixmapPtr) pDraw;
	return dixLookupPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey);
d136 1
a136 1
	return NULL;
d147 1
a147 1
	return pDraw->serialNumber;
d149 1
a149 1
    pPix = pScreen->GetWindowPixmap((WindowPtr)pDraw);
d156 1
a156 1
    DRI2ScreenPtr   ds = DRI2GetScreen(pDraw->pScreen);
d158 1
a158 1
    CARD64          ust;
d164 1
a164 1
	return NULL;
d179 2
a180 2
    if (!ds->GetMSC || !(*ds->GetMSC)(pDraw, &ust, &pPriv->last_swap_target))
	pPriv->last_swap_target = 0;
d182 1
a182 1
    pPriv->swap_limit = 1; /* default to double buffering */
d185 1
a185 1
    list_init(&pPriv->reference_list);
d187 1
d190 6
a195 5
	pWin = (WindowPtr) pDraw;
	dixSetPrivate(&pWin->devPrivates, dri2WindowPrivateKey, pPriv);
    } else {
	pPixmap = (PixmapPtr) pDraw;
	dixSetPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey, pPriv);
d201 30
d232 5
a236 5
    XID		  id;
    XID		  dri2_id;
    DRI2InvalidateProcPtr	invalidate;
    void	 *priv;
    struct list	  link;
d244 3
a246 3
    list_for_each_entry(ref, &pPriv->reference_list, link) {
	if (ref->id == id)
	    return ref;
d248 1
a248 1
    
d254 1
a254 1
		   DRI2InvalidateProcPtr invalidate, void *priv)
d260 2
a261 2
	return BadAlloc;
	
d263 2
a264 2
	free(ref);
	return BadAlloc;
d267 4
a270 4
	if (!AddResource(id, dri2DrawableRes, pPriv)) {
	    FreeResourceByType(dri2_id, dri2DrawableRes, TRUE);
	    free(ref);
	    return BadAlloc;
d274 1
a274 1
    ref->dri2_id = dri2_id; 
d277 1
a277 1
    list_add(&ref->link, &pPriv->reference_list);
d284 1
a284 1
		   DRI2InvalidateProcPtr invalidate, void *priv)
d292 1
a292 1
	pPriv = DRI2AllocateDrawable(pDraw);
d294 2
a295 2
	return BadAlloc;
    
d299 1
a299 1
	return rc;
d304 2
a305 1
static int DRI2DrawableGone(pointer p, XID id)
d308 1
a308 1
    DRI2ScreenPtr   ds = pPriv->dri2_screen;
d315 16
a330 16
    list_for_each_entry_safe(ref, next, &pPriv->reference_list, link) {
	if (ref->dri2_id == id) {
	    list_del(&ref->link);
	    /* If this was the last ref under this X drawable XID,
	     * unregister the X drawable resource. */
	    if (!DRI2LookupDrawableRef(pPriv, ref->id))
		FreeResourceByType(ref->id, dri2DrawableRes, TRUE);
	    free(ref);
	    break;
	}

	if (ref->id == id) {
	    list_del(&ref->link);
	    FreeResourceByType(ref->dri2_id, dri2DrawableRes, TRUE);
	    free(ref);
	}
d333 2
a334 2
    if (!list_is_empty(&pPriv->reference_list))
	return Success;
d338 6
a343 5
	pWin = (WindowPtr) pDraw;
	dixSetPrivate(&pWin->devPrivates, dri2WindowPrivateKey, NULL);
    } else {
	pPixmap = (PixmapPtr) pDraw;
	dixSetPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey, NULL);
d347 2
a348 2
	for (i = 0; i < pPriv->bufferCount; i++)
	    (*ds->DestroyBuffer)(pDraw, pPriv->buffers[i]);
d350 1
a350 1
	free(pPriv->buffers);
d364 1
a364 1
	return -1;
d368 4
a371 4
	if ((pPriv->buffers[i] != NULL)
	    && (pPriv->buffers[i]->attachment == attachment)) {
	    return i;
	}
d379 3
a381 3
			 DRI2DrawablePtr pPriv,
			 unsigned int attachment, unsigned int format,
			 int dimensions_match, DRI2BufferPtr *buffer)
d386 15
a400 10
	|| !dimensions_match
	|| (pPriv->buffers[old_buf]->format != format)) {
	*buffer = (*ds->CreateBuffer)(pDraw, attachment, format);
	pPriv->serialNumber = DRI2DrawableSerial(pDraw);
	return TRUE;

    } else {
	*buffer = pPriv->buffers[old_buf];
	pPriv->buffers[old_buf] = NULL;
	return FALSE;
d406 2
a407 1
			     DRI2BufferPtr *buffers, int out_count, int *width, int *height)
d409 1
a409 1
    DRI2ScreenPtr   ds = DRI2GetScreen(pDraw->pScreen);
d413 5
a417 5
	for (i = 0; i < pPriv->bufferCount; i++) {
	    if (pPriv->buffers[i] != NULL) {
		(*ds->DestroyBuffer)(pDraw, pPriv->buffers[i]);
	    }
	}
d419 1
a419 1
	free(pPriv->buffers);
d432 2
a433 2
	       unsigned int *attachments, int count, int *out_count,
	       int has_format)
d435 1
a435 1
    DRI2ScreenPtr   ds = DRI2GetScreen(pDraw->pScreen);
d437 1
a437 1
    DRI2BufferPtr  *buffers;
d447 4
a450 4
	*width = pDraw->width;
	*height = pDraw->height;
	*out_count = 0;
	return NULL;
d454 2
a455 2
	&& (pDraw->height == pPriv->height)
	&& (pPriv->serialNumber == DRI2DrawableSerial(pDraw));
d459 1
a459 1
	goto err_out;
d462 2
a463 2
	const unsigned attachment = *(attachments++);
	const unsigned format = (has_format) ? *(attachments++) : 0;
d465 32
a496 33
	if (allocate_or_reuse_buffer(pDraw, ds, pPriv, attachment,
				     format, dimensions_match,
				     &buffers[i]))
		buffers_changed = 1;

	if (buffers[i] == NULL)
	    goto err_out;

	/* If the drawable is a window and the front-buffer is requested,
	 * silently add the fake front-buffer to the list of requested
	 * attachments.  The counting logic in the loop accounts for the case
	 * where the client requests both the fake and real front-buffer.
	 */
	if (attachment == DRI2BufferBackLeft) {
	    need_real_front++;
	    front_format = format;
	}

	if (attachment == DRI2BufferFrontLeft) {
	    need_real_front--;
	    front_format = format;

	    if (pDraw->type == DRAWABLE_WINDOW) {
		need_fake_front++;
	    }
	}

	if (pDraw->type == DRAWABLE_WINDOW) {
	    if (attachment == DRI2BufferFakeFrontLeft) {
		need_fake_front--;
		have_fake_front = 1;
	    }
	}
d500 8
a507 8
	if (allocate_or_reuse_buffer(pDraw, ds, pPriv, DRI2BufferFrontLeft,
				     front_format, dimensions_match,
				     &buffers[i]))
	    buffers_changed = 1;

	if (buffers[i] == NULL)
	    goto err_out;
	i++;
d511 4
a514 4
	if (allocate_or_reuse_buffer(pDraw, ds, pPriv, DRI2BufferFakeFrontLeft,
				     front_format, dimensions_match,
				     &buffers[i]))
	    buffers_changed = 1;
d516 2
a517 2
	if (buffers[i] == NULL)
	    goto err_out;
d519 2
a520 2
	i++;
	have_fake_front = 1;
d525 2
a526 1
    update_dri2_drawable_buffers(pPriv, pDraw, buffers, *out_count, width, height);
d533 2
a534 2
	BoxRec box;
	RegionRec region;
d536 5
a540 5
	box.x1 = 0;
	box.y1 = 0;
	box.x2 = pPriv->width;
	box.y2 = pPriv->height;
	RegionInit(&region, &box, 0);
d542 2
a543 2
	DRI2CopyRegion(pDraw, &region, DRI2BufferFakeFrontLeft,
		       DRI2BufferFrontLeft);
d550 1
a550 1
err_out:
d555 4
a558 4
	for (i = 0; i < count; i++) {
	    if (buffers[i] != NULL)
		(*ds->DestroyBuffer)(pDraw, buffers[i]);
	}
d560 2
a561 2
	free(buffers);
	buffers = NULL;
d564 2
a565 1
    update_dri2_drawable_buffers(pPriv, pDraw, buffers, *out_count, width, height);
d572 1
a572 1
	       unsigned int *attachments, int count, int *out_count)
d575 1
a575 1
			  out_count, FALSE);
d580 1
a580 1
			 unsigned int *attachments, int count, int *out_count)
d583 1
a583 1
			  out_count, TRUE);
d597 2
a598 2
    list_for_each_entry(ref, &pPriv->reference_list, link)
	ref->invalidate(pDraw, ref->priv);
d615 1
a615 1
	return FALSE;
d618 6
a623 7
    if ((pPriv->swapsPending >= pPriv->swap_limit) &&
	!pPriv->blockedClient) {
	ResetCurrentRequest(client);
	client->sequence--;
	IgnoreClient(client);
	pPriv->blockedClient = client;
	return TRUE;
d633 2
a634 2
	IgnoreClient(client);
	pPriv->blockedClient = client;
d645 1
a645 1
	return;
d653 1
a653 1
	       unsigned int dest, unsigned int src)
d655 1
a655 1
    DRI2ScreenPtr   ds = DRI2GetScreen(pDraw->pScreen);
d657 2
a658 2
    DRI2BufferPtr   pDestBuffer, pSrcBuffer;
    int		    i;
d662 1
a662 1
	return BadDrawable;
d666 5
a670 6
    for (i = 0; i < pPriv->bufferCount; i++)
    {
	if (pPriv->buffers[i]->attachment == dest)
	    pDestBuffer = (DRI2BufferPtr) pPriv->buffers[i];
	if (pPriv->buffers[i]->attachment == src)
	    pSrcBuffer = (DRI2BufferPtr) pPriv->buffers[i];
d673 1
a673 1
	return BadValue;
d675 1
a675 1
    (*ds->CopyRegion)(pDraw, pRegion, pDestBuffer, pSrcBuffer);
d689 1
a689 1
	return TRUE;
d697 1
a697 1
	return FALSE;
d699 1
a699 1
	return FALSE;
d702 1
a702 2
    if (pDraw->x != 0 ||
	pDraw->y != 0 ||
d704 1
a704 2
	pDraw->x != pWinPixmap->screen_x ||
	pDraw->y != pWinPixmap->screen_y ||
d706 3
a708 3
	pDraw->width != pWinPixmap->drawable.width ||
	pDraw->height != pWinPixmap->drawable.height)
	return FALSE;
d722 1
a722 1
		    unsigned int tv_sec, unsigned int tv_usec)
d728 1
a728 1
	return;
d730 2
a731 2
    ProcDRI2WaitMSCReply(client, ((CARD64)tv_sec * 1000000) + tv_usec,
			 frame, pPriv->swap_count);
d734 1
a734 1
	AttendClient(pPriv->blockedClient);
d742 1
a742 1
	       unsigned int tv_sec, unsigned int tv_usec)
d744 1
a744 1
    ScreenPtr	    pScreen = pDraw->pScreen;
d750 2
a751 2
		   "[DRI2] %s: bad drawable\n", __func__);
	return;
d762 13
a774 13
    if (pPriv->target_sbc != -1 &&
	pPriv->target_sbc <= pPriv->swap_count) {
	ProcDRI2WaitMSCReply(client, ((CARD64)tv_sec * 1000000) + tv_usec,
			     frame, pPriv->swap_count);
	pPriv->target_sbc = -1;

	AttendClient(pPriv->blockedClient);
	pPriv->blockedClient = NULL;
    } else if (pPriv->target_sbc == -1 && !pPriv->blockedOnMsc) {
	if (pPriv->blockedClient) {
	    AttendClient(pPriv->blockedClient);
	    pPriv->blockedClient = NULL;
	}
d780 2
a781 2
		   unsigned int tv_sec, unsigned int tv_usec, int type,
		   DRI2SwapEventPtr swap_complete, void *swap_data)
d783 1
a783 1
    ScreenPtr	    pScreen = pDraw->pScreen;
d785 3
a787 3
    CARD64          ust = 0;
    BoxRec          box;
    RegionRec       region;
d792 2
a793 2
		   "[DRI2] %s: bad drawable\n", __func__);
	return;
d805 1
a805 1
		   DRI2BufferFrontLeft);
d807 1
a807 1
    ust = ((CARD64)tv_sec * 1000000) + tv_usec;
d809 1
a809 1
	swap_complete(client, swap_data, type, ust, frame, pPriv->swap_count);
d825 5
a829 7
    if (pPriv &&
	pPriv->swapsPending &&
	pPriv->blockedClient == NULL) {
	ResetCurrentRequest(client);
	client->sequence--;
	__DRI2BlockClient(client, pPriv);
	return TRUE;
d835 13
d850 2
a851 2
		CARD64 divisor, CARD64 remainder, CARD64 *swap_target,
		DRI2SwapEventPtr func, void *data)
d853 2
a854 2
    ScreenPtr       pScreen = pDraw->pScreen;
    DRI2ScreenPtr   ds = DRI2GetScreen(pDraw->pScreen);
d856 3
a858 3
    DRI2BufferPtr   pDestBuffer = NULL, pSrcBuffer = NULL;
    int             ret, i;
    CARD64          ust, current_msc;
d863 2
a864 2
		   "[DRI2] %s: bad drawable\n", __func__);
	return BadDrawable;
d868 4
a871 4
	if (pPriv->buffers[i]->attachment == DRI2BufferFrontLeft)
	    pDestBuffer = (DRI2BufferPtr) pPriv->buffers[i];
	if (pPriv->buffers[i]->attachment == DRI2BufferBackLeft)
	    pSrcBuffer = (DRI2BufferPtr) pPriv->buffers[i];
d875 2
a876 2
		   "[DRI2] %s: drawable has no back or front?\n", __func__);
	return BadDrawable;
d881 2
a882 2
	BoxRec box;
	RegionRec region;
d884 12
a895 12
	box.x1 = 0;
	box.y1 = 0;
	box.x2 = pDraw->width;
	box.y2 = pDraw->height;
	RegionInit(&region, &box, 0);

	pPriv->swapsPending++;

	(*ds->CopyRegion)(pDraw, &region, pDestBuffer, pSrcBuffer);
	DRI2SwapComplete(client, pDraw, target_msc, 0, 0, DRI2_BLIT_COMPLETE,
			 func, data);
	return Success;
d903 27
a929 26
	/* If the current vblank count of the drawable's crtc is lower
	 * than the count stored in last_swap_target from a previous swap
	 * then reinitialize last_swap_target to the current crtc's msc,
	 * otherwise the swap will hang. This will happen if the drawable
	 * is moved to a crtc with a lower refresh rate, or a crtc that just
	 * got enabled.
	 */
	if (ds->GetMSC) {
	    if (!(*ds->GetMSC)(pDraw, &ust, &current_msc))
		pPriv->last_swap_target = 0;

	    if (current_msc < pPriv->last_swap_target)
		pPriv->last_swap_target = current_msc;

	}

	/*
	 * Swap target for this swap is last swap target + swap interval since
	 * we have to account for the current swap count, interval, and the
	 * number of pending swaps.
	 */
	*swap_target = pPriv->last_swap_target + pPriv->swap_interval;

    } else {
	/* glXSwapBuffersMscOML could have a 0 target_msc, honor it */
	*swap_target = target_msc;
d933 2
a934 2
    ret = (*ds->ScheduleSwap)(client, pDraw, pDestBuffer, pSrcBuffer,
			      swap_target, divisor, remainder, func, data);
d936 1
a936 1
	pPriv->swapsPending--; /* didn't schedule */
d938 2
a939 2
		   "[DRI2] %s: driver failed to schedule swap\n", __func__);
	return BadDrawable;
d949 20
a968 1
    DRI2InvalidateDrawable(pDraw);
d976 1
a976 1
    ScreenPtr       pScreen = pDrawable->pScreen;
d981 2
a982 2
		   "[DRI2] %s: bad drawable\n", __func__);
	return;
d990 1
a990 1
DRI2GetMSC(DrawablePtr pDraw, CARD64 *ust, CARD64 *msc, CARD64 *sbc)
d1000 2
a1001 2
		   "[DRI2] %s: bad drawable\n", __func__);
	return BadDrawable;
d1005 4
a1008 4
	*ust = 0;
	*msc = 0;
	*sbc = pPriv->swap_count;
	return Success;
d1016 1
a1016 1
    ret = (*ds->GetMSC)(pDraw, ust, msc);
d1018 1
a1018 1
	return BadDrawable;
d1027 1
a1027 1
	    CARD64 divisor, CARD64 remainder)
d1035 1
a1035 1
	return BadDrawable;
d1039 1
a1039 1
	DRI2WaitMSCComplete(client, pDraw, target_msc, 0, 0);
d1041 1
a1041 1
	return Success;
d1044 2
a1045 1
    ret = (*ds->ScheduleWaitMSC)(client, pDraw, target_msc, divisor, remainder);
d1047 1
a1047 1
	return BadDrawable;
d1059 1
a1059 1
	return BadDrawable;
d1093 1
a1093 1
	    const char **driverName, const char **deviceName)
d1098 1
a1098 1
	return FALSE;
d1102 2
a1103 2
	    !ds->driverNames[driverType])
	return FALSE;
d1117 1
a1117 1
    if (ds == NULL || (*ds->AuthMagic)(ds->fd, magic))
d1125 1
a1125 1
		 WindowPtr pSib)
d1127 1
a1127 1
    DrawablePtr pDraw = (DrawablePtr)pWin;
d1134 1
a1134 1
	pScreen->ConfigNotify = ds->ConfigNotify;
d1136 1
a1136 1
	ret = (*pScreen->ConfigNotify)(pWin, x, y, w, h, bw, pSib);
d1138 4
a1141 4
	ds->ConfigNotify = pScreen->ConfigNotify;
	pScreen->ConfigNotify = DRI2ConfigNotify;
	if (ret)
	    return ret;
d1145 1
a1145 1
	return Success;
d1155 4
a1158 3
    const char* driverTypeNames[] = {
	"DRI", /* DRI2DriverDRI */
	"VDPAU", /* DRI2DriverVDPAU */
d1164 1
a1164 1
	return FALSE;
d1168 1
a1168 1
                  "[DRI2] Direct rendering is not supported when VGA arb is necessary for the device\n");
d1173 1
a1173 1
	return FALSE;
d1176 1
a1176 1
	return FALSE;
d1179 1
a1179 1
	return FALSE;
d1183 1
a1183 1
	return FALSE;
d1185 8
a1192 8
    ds->screen         = pScreen;
    ds->fd	       = info->fd;
    ds->deviceName     = info->deviceName;
    dri2_major         = 1;

    ds->CreateBuffer   = info->CreateBuffer;
    ds->DestroyBuffer  = info->DestroyBuffer;
    ds->CopyRegion     = info->CopyRegion;
d1195 7
a1201 6
	ds->ScheduleSwap = info->ScheduleSwap;
	ds->ScheduleWaitMSC = info->ScheduleWaitMSC;
	ds->GetMSC = info->GetMSC;
	cur_minor = 3;
    } else {
	cur_minor = 1;
d1208 5
d1226 1
a1226 1
	dri2_minor = cur_minor;
d1229 14
a1242 13
	/* Driver too old: use the old-style driverName field */
	ds->numDrivers = 1;
	ds->driverNames = malloc(sizeof(*ds->driverNames));
	if (!ds->driverNames)
	    goto err_out;
	ds->driverNames[0] = info->driverName;
    } else {
	ds->numDrivers = info->numDrivers;
	ds->driverNames = malloc(info->numDrivers * sizeof(*ds->driverNames));
	if (!ds->driverNames)
		goto err_out;
	memcpy(ds->driverNames, info->driverNames,
	       info->numDrivers * sizeof(*ds->driverNames));
d1252 4
a1255 4
	if (i < ds->numDrivers && ds->driverNames[i]) {
	    xf86DrvMsg(pScreen->myNum, X_INFO, "[DRI2]   %s driver: %s\n",
		       driverTypeNames[i], ds->driverNames[i]);
	}
d1260 1
a1260 1
err_out:
d1262 2
a1263 1
            "[DRI2] Initialization failed for info version %d.\n", info->version);
d1272 1
d1289 1
a1289 1
	return FALSE;
d1299 7
a1305 9
    if (!setupDone)
    {
	setupDone = TRUE;
	LoadExtension(&dri2ExtensionModule, FALSE);
    }
    else
    {
	if (errmaj)
	    *errmaj = LDR_ONCEONLY;
d1311 1
a1311 2
static XF86ModuleVersionInfo DRI2VersRec =
{
d1321 1
a1321 1
    { 0, 0, 0, 0 }
d1330 1
a1330 1
	*major = DRI2VersRec.majorversion;
d1333 1
a1333 1
	*minor = DRI2VersRec.minorversion;
@


1.8
log
@Update to xserver 1.11.2
@
text
@d783 2
a784 1
    if ((pPriv->swapsPending) &&
d1197 12
a1213 2

    dri2DrawableRes = CreateNewResourceType(DRI2DrawableGone, "DRI2Drawable");
@


1.7
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d86 1
d225 2
a226 1
    if (!AddResource(dri2_id, dri2DrawableRes, pPriv))
d228 1
d230 3
a232 1
	if (!AddResource(id, dri2DrawableRes, pPriv))
d234 1
d362 1
a362 1
			     DRI2BufferPtr *buffers, int *out_count, int *width, int *height)
d378 1
a378 1
    pPriv->bufferCount = *out_count;
d412 3
a414 1
    buffers = malloc((count + 1) * sizeof(buffers[0]));
d481 1
a481 1
    update_dri2_drawable_buffers(pPriv, pDraw, buffers, out_count, width, height);
d501 2
d509 2
a510 1
    for (i = 0; i < count; i++) {
d512 5
a516 1
		    (*ds->DestroyBuffer)(pDraw, buffers[i]);
d519 1
a519 4
    free(buffers);
    buffers = NULL;

    update_dri2_drawable_buffers(pPriv, pDraw, buffers, out_count, width, height);
d546 1
a546 1
    if (!pPriv)
d549 2
d1188 1
@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d643 11
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d831 3
a833 2
	if (!(*ds->GetMSC)(pDraw, &ust, &current_msc))
	    pPriv->last_swap_target = 0;
d835 4
a838 2
	if (current_msc < pPriv->last_swap_target)
	    pPriv->last_swap_target = current_msc;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d38 1
d40 1
d54 9
a62 6
static int           dri2ScreenPrivateKeyIndex;
static DevPrivateKey dri2ScreenPrivateKey = &dri2ScreenPrivateKeyIndex;
static int dri2WindowPrivateKeyIndex;
static DevPrivateKey dri2WindowPrivateKey = &dri2WindowPrivateKeyIndex;
static int dri2PixmapPrivateKeyIndex;
static DevPrivateKey dri2PixmapPrivateKey = &dri2PixmapPrivateKeyIndex;
d85 1
d103 1
d106 2
d122 2
a123 1
    if (pDraw->type == DRAWABLE_WINDOW) {
d126 1
a126 1
    } else {
d129 2
d134 13
d156 1
a156 1
    pPriv = xalloc(sizeof *pPriv);
d180 1
d194 5
a198 3
    XID id;
    XID dri2_id;
    struct list link;
d215 2
a216 1
DRI2AddDrawableRef(DRI2DrawablePtr pPriv, XID id, XID dri2_id)
d232 2
d240 2
a241 1
DRI2CreateDrawable(ClientPtr client, DrawablePtr pDraw, XID id)
d254 1
a254 1
    rc = DRI2AddDrawableRef(pPriv, id, dri2_id);
d305 1
a305 1
	xfree(pPriv->buffers);
d308 1
a308 1
    xfree(pPriv);
d344 1
d354 25
d403 2
a404 1
	&& (pDraw->height == pPriv->height);
d406 1
a406 1
    buffers = xalloc((count + 1) * sizeof(buffers[0]));
d417 3
d450 1
a450 1
				     &buffers[i++]))
d452 4
d461 1
a461 1
				     &buffers[i++]))
d464 4
d473 1
a473 18

    if (pPriv->buffers != NULL) {
	for (i = 0; i < pPriv->bufferCount; i++) {
	    if (pPriv->buffers[i] != NULL) {
		(*ds->DestroyBuffer)(pDraw, pPriv->buffers[i]);
	    }
	}

	xfree(pPriv->buffers);
    }

    pPriv->buffers = buffers;
    pPriv->bufferCount = *out_count;
    pPriv->width = pDraw->width;
    pPriv->height = pDraw->height;
    *width = pPriv->width;
    *height = pPriv->height;

d487 1
a487 1
	REGION_INIT(pDraw->pScreen, &region, &box, 0);
d494 16
d528 13
d633 1
a633 1
    pRoot = WindowTable[pScreen->myNum];
d640 1
a640 1
    if (!REGION_EQUAL(pScreen, &pWin->clipList, &pRoot->winSize))
a670 1

d719 2
d732 8
d809 1
a809 1
	REGION_INIT(pScreen, &region, &box, 0);
d866 2
d985 1
a985 1
    return (ds->ScheduleSwap && ds->GetMSC);
d992 4
a995 1
    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
d997 1
d1010 1
a1010 1
DRI2Authenticate(ScreenPtr pScreen, drm_magic_t magic)
d1014 2
a1015 2
    if (ds == NULL || drmAuthMagic(ds->fd, magic))
	return FALSE;
d1020 28
d1068 10
a1077 1
    ds = xcalloc(1, sizeof *ds);
d1094 1
a1094 1
	cur_minor = 2;
d1099 15
d1121 3
a1123 5
	ds->driverNames = xalloc(sizeof(*ds->driverNames));
	if (!ds->driverNames) {
	    xfree(ds);
	    return FALSE;
	}
d1127 3
a1129 5
	ds->driverNames = xalloc(info->numDrivers * sizeof(*ds->driverNames));
	if (!ds->driverNames) {
	    xfree(ds);
	    return FALSE;
	}
d1136 3
d1148 6
d1161 2
a1162 2
    xfree(ds->driverNames);
    xfree(ds);
@


1.3
log
@Update to server 1.6.5.
@
text
@d37 1
d40 1
d43 1
d45 1
d49 4
a52 1
static int dri2ScreenPrivateKeyIndex;
d58 3
d63 3
a65 1
    unsigned int	 refCount;
d68 1
a68 1
    DRI2Buffer2Ptr	*buffers;
d70 10
a79 1
    unsigned int	 pendingSequence;
d83 4
a86 1
    const char			*driverName;
a90 3
    DRI2CreateBuffersProcPtr	 CreateBuffers;
    DRI2DestroyBuffersProcPtr	 DestroyBuffers;

d94 3
d99 1
a99 1
} DRI2ScreenRec, *DRI2ScreenPtr;
d110 2
a111 2
    WindowPtr		  pWin;
    PixmapPtr		  pPixmap;
d113 1
a113 2
    if (pDraw->type == DRAWABLE_WINDOW)
    {
d116 1
a116 3
    }
    else
    {
d122 2
a123 2
int
DRI2CreateDrawable(DrawablePtr pDraw)
d125 1
a125 2
    WindowPtr	    pWin;
    PixmapPtr	    pPixmap;
d127 3
a129 7

    pPriv = DRI2GetDrawable(pDraw);
    if (pPriv != NULL)
    {
	pPriv->refCount++;
	return Success;
    }
d133 1
a133 1
	return BadAlloc;
d135 2
a136 1
    pPriv->refCount = 1;
d141 14
d156 1
a156 2
    if (pDraw->type == DRAWABLE_WINDOW)
    {
d159 96
d256 9
a264 2
    else
    {
d266 8
a273 1
	dixSetPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey, pPriv);
d276 2
d300 1
a300 1
static DRI2Buffer2Ptr
d304 1
a304 1
			 int dimensions_match)
d306 1
a306 4
    DRI2Buffer2Ptr buffer;
    int old_buf;

    old_buf = find_attachment(pPriv, attachment);
d311 3
a313 1
	buffer = (*ds->CreateBuffer)(pDraw, attachment, format);
d315 1
a315 1
	buffer = pPriv->buffers[old_buf];
d317 1
a318 2

    return buffer;
d321 1
a321 1
static DRI2Buffer2Ptr *
d328 1
a328 1
    DRI2Buffer2Ptr  *buffers;
d334 1
d349 22
a370 27
    if (ds->CreateBuffer) {
	/* Version 2 API with CreateBuffer */
	for (i = 0; i < count; i++) {
	    const unsigned attachment = *(attachments++);
	    const unsigned format = (has_format) ? *(attachments++) : 0;

	    buffers[i] = allocate_or_reuse_buffer(pDraw, ds, pPriv, attachment,
						  format, dimensions_match);

	    /* If the drawable is a window and the front-buffer is requested,
	     * silently add the fake front-buffer to the list of requested
	     * attachments.  The counting logic in the loop accounts for the case
	     * where the client requests both the fake and real front-buffer.
	     */
	    if (attachment == DRI2BufferBackLeft) {
		need_real_front++;
		front_format = format;
	    }

	    if (attachment == DRI2BufferFrontLeft) {
		need_real_front--;
		front_format = format;

		if (pDraw->type == DRAWABLE_WINDOW) {
		    need_fake_front++;
		}
	    }
d373 1
a373 4
		if (attachment == DRI2BufferFakeFrontLeft) {
		    need_fake_front--;
		    have_fake_front = 1;
		}
d377 2
a378 67
	if (need_real_front > 0) {
	    buffers[i++] = allocate_or_reuse_buffer(pDraw, ds, pPriv,
						    DRI2BufferFrontLeft,
						    front_format, dimensions_match);
	}

	if (need_fake_front > 0) {
	    buffers[i++] = allocate_or_reuse_buffer(pDraw, ds, pPriv,
						    DRI2BufferFakeFrontLeft,
						    front_format, dimensions_match);
	    have_fake_front = 1;
	}

	*out_count = i;


	if (pPriv->buffers != NULL) {
	    for (i = 0; i < pPriv->bufferCount; i++) {
		if (pPriv->buffers[i] != NULL) {
		    (*ds->DestroyBuffer)(pDraw, pPriv->buffers[i]);
		}
	    }

	    xfree(pPriv->buffers);
	}
    } else {
	DRI2BufferPtr	buffers1;
	unsigned int	temp_buf[32];
	unsigned int	*temp = temp_buf;
	int		i;
	int		buffers_match = 1;

	/* Version 1 API with CreateBuffers */

	if ((count + 1) > 32) {
	    temp = xalloc((count + 1) * sizeof(temp[0]));
	}

	for (i = 0; i < count; i++) {
	    const unsigned attachment = *(attachments++);

	    /* Version 1 doesn't deal with the format at all */
	    if (has_format)
		attachments++;

	    /*
	     * Make sure the client also gets the front buffer when
	     * it asks for a back buffer
	     */
	    if (attachment == DRI2BufferBackLeft)
		need_real_front++;

	    /*
	     * If the drawable is a window and the front-buffer is requested,
	     * silently add the fake front-buffer to the list of requested
	     * attachments.  The counting logic in the loop accounts for the
	     * case where the client requests both the fake and real
	     * front-buffer.
	     */
	    if (attachment == DRI2BufferFrontLeft) {
		need_real_front--;
		if (pDraw->type == DRAWABLE_WINDOW)
		    need_fake_front++;
	    }
	    if (pDraw->type == DRAWABLE_WINDOW &&
		attachment == DRI2BufferFakeFrontLeft)
	    {
a381 2

	    temp[i] = attachment;
d383 1
d385 6
a390 2
	if (need_real_front > 0)
	    temp[count++] = DRI2BufferFrontLeft;
d392 5
a396 4
	if (need_fake_front > 0) {
	    temp[count++] = DRI2BufferFakeFrontLeft;
	    have_fake_front = 1;
	}
d398 2
a399 18
	if (count != pPriv->bufferCount)
	    buffers_match = 0;
	else {
	    for (i = 0; i < count; i++)
		if (pPriv->buffers[i]->attachment != temp[i]) {
		    buffers_match = 0;
		    break;
		}
	}
	if (pPriv->buffers == NULL || !dimensions_match || !buffers_match)
	{
            buffers1 = (*ds->CreateBuffers)(pDraw, temp, count);
	    if (pPriv->buffers != NULL)
		(*ds->DestroyBuffers)(pDraw, (DRI2BufferPtr) pPriv->buffers[0],
				      pPriv->bufferCount);
	}
	else
	    buffers1 = (DRI2BufferPtr) pPriv->buffers[0];
d401 1
a401 2
        for (i = 0; i < count; i++)
	    buffers[i] = (DRI2Buffer2Ptr) &buffers1[i];
a402 1
        *out_count = count;
d404 6
a409 2
	if (pPriv->buffers)
	    xfree (pPriv->buffers);
d411 1
a411 3
	if (temp != temp_buf) {
	    xfree(temp);
	}
d426 1
a426 1
    if (have_fake_front) {
d443 1
a443 1
DRI2Buffer2Ptr *
d451 1
a451 1
DRI2Buffer2Ptr *
d459 51
d540 31
d572 2
a573 1
DRI2DestroyDrawable(DrawablePtr pDraw)
a574 1
    DRI2ScreenPtr   ds = DRI2GetScreen(pDraw->pScreen);
a575 2
    WindowPtr  	    pWin;
    PixmapPtr	    pPixmap;
d581 206
a786 2
    pPriv->refCount--;
    if (pPriv->refCount > 0)
d788 1
d790 11
a800 2
    if (pPriv->buffers != NULL) {
	int i;
d802 6
a807 8
	if (ds->DestroyBuffer) {
	    for (i = 0; i < pPriv->bufferCount; i++) {
		(*ds->DestroyBuffer)(pDraw, pPriv->buffers[i]);
	    }
	} else {
	    (*ds->DestroyBuffers)(pDraw, (DRI2BufferPtr) pPriv->buffers[0],
				  pPriv->bufferCount);
	}
d809 5
a813 1
	xfree(pPriv->buffers);
d816 29
a844 1
    xfree(pPriv);
d846 1
a846 4
    if (pDraw->type == DRAWABLE_WINDOW)
    {
	pWin = (WindowPtr) pDraw;
	dixSetPrivate(&pWin->devPrivates, dri2WindowPrivateKey, NULL);
d848 31
a878 4
    else
    {
	pPixmap = (PixmapPtr) pDraw;
	dixSetPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey, NULL);
d880 13
d901 2
a902 1
    if (ds == NULL)
a904 3
    if (driverType != DRI2DriverDRI)
	return BadValue;

d906 1
a906 1
    *driverName = ds->driverName;
d927 15
d943 1
a943 1
    ds = xalloc(sizeof *ds);
d947 1
a948 1
    ds->driverName     = info->driverName;
d950 5
d956 5
a960 13
    /* Prefer the new one-at-a-time buffer API */
    if (info->version >= 2 && info->CreateBuffer && info->DestroyBuffer) {
	ds->CreateBuffer   = info->CreateBuffer;
	ds->DestroyBuffer  = info->DestroyBuffer;
	ds->CreateBuffers  = NULL;
	ds->DestroyBuffers = NULL;
    } else if (info->CreateBuffers && info->DestroyBuffers) {
	xf86DrvMsg(pScreen->myNum, X_WARNING,
		   "[DRI2] Version 1 API (broken front buffer rendering)\n");
	ds->CreateBuffer   = NULL;
	ds->DestroyBuffer  = NULL;
	ds->CreateBuffers  = info->CreateBuffers;
	ds->DestroyBuffers = info->DestroyBuffers;
d962 1
a962 4
	xf86DrvMsg(pScreen->myNum, X_ERROR,
		   "[DRI2] Missing buffer management functions\n");
	xfree(ds);
	return FALSE;
d965 22
a986 5
    if (!info->CopyRegion) {
	xf86DrvMsg(pScreen->myNum, X_ERROR,
		   "[DRI2] Missing copy region function\n");
	xfree(ds);
	return FALSE;
a987 1
    ds->CopyRegion     = info->CopyRegion;
d992 6
d1007 1
d1019 2
d1042 1
a1042 1
    1, 1, 0,
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d193 1
a193 2
    const int dimensions_match = (pDraw->width == pPriv->width)
	&& (pDraw->height == pPriv->height);
d196 9
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 1
a2 1
 * Copyright © 2007 Red Hat, Inc.
a40 2
#include "region.h" 
#include "damage.h" 
a41 1
#include <GL/internal/dri_sarea.h>
d45 15
a59 9
static DevPrivateKey dri2ScreenPrivateKey = &dri2ScreenPrivateKey;
static DevPrivateKey dri2WindowPrivateKey = &dri2WindowPrivateKey;
static DevPrivateKey dri2PixmapPrivateKey = &dri2PixmapPrivateKey;

typedef struct _DRI2DrawablePriv {
    unsigned int		 refCount;
    unsigned int		 boHandle;
    unsigned int		 dri2Handle;
} DRI2DrawablePrivRec, *DRI2DrawablePrivPtr;
d62 2
d65 1
a65 5
    drmBO			 sareaBO;
    void			*sarea;
    unsigned int		 sareaSize;
    const char			*driverName;
    unsigned int		 nextHandle;
d67 2
a68 2
    __DRIEventBuffer		*buffer;
    int				 locked;
d70 3
a72 3
    DRI2GetPixmapHandleProcPtr   getPixmapHandle;
    DRI2BeginClipNotifyProcPtr	 beginClipNotify;
    DRI2EndClipNotifyProcPtr	 endClipNotify;
d74 1
a74 2
    ClipNotifyProcPtr		 ClipNotify;
    HandleExposuresProcPtr	 HandleExposures;
d83 2
a84 2
static void *
DRI2ScreenAllocEvent(DRI2ScreenPtr ds, size_t size)
d86 2
a87 40
    unsigned int *pad, mask = ds->buffer->size - 1;
    size_t pad_size;
    void *p;
    
    if ((ds->buffer->head & mask) + size > ds->buffer->size) {
	/* The requested event size would wrap the buffer, so pad to
	 * the end and allocate the event from the start. */
	pad_size = ds->buffer->size - (ds->buffer->head & mask);
	pad = (unsigned int *)
	    (ds->buffer->data + (ds->buffer->prealloc & mask));
	*pad = DRI2_EVENT_HEADER(DRI2_EVENT_PAD, pad_size);
	ds->buffer->prealloc += pad_size;
    }

    p = ds->buffer->data + (ds->buffer->prealloc & mask);
    ds->buffer->prealloc += size;

    return p;
}

static void
DRI2ScreenCommitEvents(DRI2ScreenPtr ds)
{
    ds->buffer->head = ds->buffer->prealloc;
}

static void
DRI2PostDrawableConfig(DrawablePtr pDraw)
{
    ScreenPtr			 pScreen = pDraw->pScreen;
    DRI2ScreenPtr		 ds = DRI2GetScreen(pScreen);
    DRI2DrawablePrivPtr		 pPriv;
    WindowPtr			 pWin;
    PixmapPtr			 pPixmap;
    BoxPtr			 pBox;
    BoxRec			 pixmapBox;
    int				 nBox;
    int				 i;
    __DRIDrawableConfigEvent	*e;
    size_t			 size;
d89 2
a90 1
    if (pDraw->type == DRAWABLE_WINDOW) {
d92 4
a95 7
	pPriv = dixLookupPrivate(&pWin->devPrivates, dri2WindowPrivateKey);

	nBox = REGION_NUM_RECTS(&pWin->clipList);
	pBox = REGION_RECTS(&pWin->clipList);

	pPixmap = pScreen->GetWindowPixmap(pWin);
    } else {
d97 1
a97 8
	pPriv = dixLookupPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey);

	pixmapBox.x1 = 0;
	pixmapBox.y1 = 0;
	pixmapBox.x2 = pDraw->width;
	pixmapBox.y2 = pDraw->height;
	nBox = 1;
	pBox = &pixmapBox;
d99 1
d101 6
a106 2
    if (!pPriv)
	return;
d108 6
a113 1
    size = sizeof *e + nBox * sizeof e->rects[0];
d115 3
a117 17
    e = DRI2ScreenAllocEvent(ds, size);
    e->event_header = DRI2_EVENT_HEADER(DRI2_EVENT_DRAWABLE_CONFIG, size);
    e->drawable = pPriv->dri2Handle;
    e->x = pDraw->x - pPixmap->screen_x;
    e->y = pDraw->y - pPixmap->screen_y;
    e->width = pDraw->width;
    e->height = pDraw->height;

    e->num_rects = nBox;
    for (i = 0; i < nBox; i++) {
	e->rects[i].x1 = pBox->x1 - pPixmap->screen_x;
	e->rects[i].y1 = pBox->y1 - pPixmap->screen_y;
	e->rects[i].x2 = pBox->x2 - pPixmap->screen_x;
	e->rects[i].y2 = pBox->y2 - pPixmap->screen_y;
	pBox++;
    }
}
d119 5
a123 12
static void
DRI2PostBufferAttach(DrawablePtr pDraw, Bool force)
{
    ScreenPtr			 pScreen = pDraw->pScreen;
    DRI2ScreenPtr		 ds = DRI2GetScreen(pScreen);
    DRI2DrawablePrivPtr		 pPriv;
    WindowPtr			 pWin;
    PixmapPtr			 pPixmap;
    __DRIBufferAttachEvent	*e;
    size_t			 size;
    unsigned int		 flags;
    unsigned int		 boHandle;
d125 2
a126 1
    if (pDraw->type == DRAWABLE_WINDOW) {
d128 4
a131 3
	pPixmap = pScreen->GetWindowPixmap(pWin);
	pPriv = dixLookupPrivate(&pWin->devPrivates, dri2WindowPrivateKey);
    } else {
d133 1
a133 1
	pPriv = dixLookupPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey);
d136 1
a136 17
    if (!pPriv)
	return;

    boHandle = ds->getPixmapHandle(pPixmap, &flags);
    if (boHandle == pPriv->boHandle && !force)
	return;

    pPriv->boHandle = boHandle;
    size = sizeof *e;
    e = DRI2ScreenAllocEvent(ds, size);
    e->event_header = DRI2_EVENT_HEADER(DRI2_EVENT_BUFFER_ATTACH, size);
    e->drawable = pPriv->dri2Handle;
    e->buffer.attachment = DRI_DRAWABLE_BUFFER_FRONT_LEFT;
    e->buffer.handle = pPriv->boHandle;
    e->buffer.pitch = pPixmap->devKind;
    e->buffer.cpp = pPixmap->drawable.bitsPerPixel / 8;
    e->buffer.flags = flags;
d139 2
a140 2
static void
DRI2ClipNotify(WindowPtr pWin, int dx, int dy)
d142 1
a142 2
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    DRI2ScreenPtr	ds = DRI2GetScreen(pScreen);
d144 2
a145 3
    if (!ds->locked) {
        ds->beginClipNotify(pScreen);
	ds->locked = 1;
d148 5
a152 4
    if (ds->ClipNotify) {
	pScreen->ClipNotify = ds->ClipNotify;
	pScreen->ClipNotify(pWin, dx, dy);
	pScreen->ClipNotify = DRI2ClipNotify;
d155 1
a155 2
    DRI2PostDrawableConfig(&pWin->drawable);
    DRI2PostBufferAttach(&pWin->drawable, FALSE);
d158 5
a162 2
static void
DRI2HandleExposures(WindowPtr pWin)
d164 2
a165 2
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    DRI2ScreenPtr	ds = DRI2GetScreen(pScreen);
d167 1
a167 5
    if (ds->HandleExposures) {
	pScreen->HandleExposures = ds->HandleExposures;
	pScreen->HandleExposures(pWin);
	pScreen->HandleExposures = DRI2HandleExposures;
    }
d169 7
a175 5
    DRI2ScreenCommitEvents(ds);

    if (ds->locked) {
        ds->endClipNotify(pScreen);
	ds->locked = 0;
a176 1
}
d178 1
a178 13
void
DRI2CloseScreen(ScreenPtr pScreen)
{
    DRI2ScreenPtr	ds = DRI2GetScreen(pScreen);

    pScreen->ClipNotify		= ds->ClipNotify;
    pScreen->HandleExposures	= ds->HandleExposures;

    drmBOUnmap(ds->fd, &ds->sareaBO);
    drmBOUnreference(ds->fd, &ds->sareaBO);

    xfree(ds);
    dixSetPrivate(&pScreen->devPrivates, dri2ScreenPrivateKey, NULL);
d181 77
a257 10
Bool
DRI2CreateDrawable(DrawablePtr pDraw,
		   unsigned int *handle, unsigned int *head)
{
    DRI2ScreenPtr	ds = DRI2GetScreen(pDraw->pScreen);
    WindowPtr		pWin;
    PixmapPtr		pPixmap;
    DRI2DrawablePrivPtr pPriv;
    DevPrivateKey	key;
    PrivateRec		**devPrivates;
d259 2
a260 4
    if (pDraw->type == DRAWABLE_WINDOW) {
	pWin = (WindowPtr) pDraw;
	devPrivates = &pWin->devPrivates;
	key = dri2WindowPrivateKey;
d262 145
a406 4
	pPixmap = (PixmapPtr) pDraw;
	devPrivates = &pPixmap->devPrivates;
	key = dri2PixmapPrivateKey;
    }
d408 8
a415 9
    pPriv = dixLookupPrivate(devPrivates, key);
    if (pPriv != NULL) {
	pPriv->refCount++;
    } else {
	pPriv = xalloc(sizeof *pPriv);
	pPriv->refCount = 1;
	pPriv->boHandle = 0;
	pPriv->dri2Handle = ds->nextHandle++;
	dixSetPrivate(devPrivates, key, pPriv);
d417 2
d420 1
a420 6
    *handle = pPriv->dri2Handle;
    *head = ds->buffer->head;

    DRI2PostDrawableConfig(pDraw);
    DRI2PostBufferAttach(pDraw, TRUE);
    DRI2ScreenCommitEvents(ds);
d422 1
a422 1
    return TRUE;
d428 4
a431 5
    PixmapPtr		  pPixmap;
    WindowPtr		  pWin;
    DRI2DrawablePrivPtr   pPriv;
    DevPrivateKey	  key;
    PrivateRec		**devPrivates;
d433 1
a433 11
    if (pDraw->type == DRAWABLE_WINDOW) {
	pWin = (WindowPtr) pDraw;
	devPrivates = &pWin->devPrivates;
	key = dri2WindowPrivateKey;
    } else {
	pPixmap = (PixmapPtr) pDraw;
	devPrivates = &pPixmap->devPrivates;
	key = dri2PixmapPrivateKey;
    }

    pPriv = dixLookupPrivate(devPrivates, key);
d436 1
a436 1
    
d438 16
a453 3
    if (pPriv->refCount == 0) {
	dixSetPrivate(devPrivates, key, NULL);
	xfree(pPriv);
a454 1
}
d456 1
a456 4
void
DRI2ReemitDrawableInfo(DrawablePtr pDraw, unsigned int *head)
{
    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
d458 10
a467 5
    *head = ds->buffer->head;

    DRI2PostDrawableConfig(pDraw);
    DRI2PostBufferAttach(pDraw, TRUE);
    DRI2ScreenCommitEvents(ds);
d471 2
a472 2
DRI2Connect(ScreenPtr pScreen, int *fd, const char **driverName,
	    unsigned int *sareaHandle)
d479 3
d484 1
a484 1
    *sareaHandle = ds->sareaBO.handle;
d490 1
a490 1
DRI2AuthConnection(ScreenPtr pScreen, drm_magic_t magic)
d500 1
a500 47
unsigned int
DRI2GetPixmapHandle(PixmapPtr pPixmap, unsigned int *flags)
{
    DRI2ScreenPtr ds = DRI2GetScreen(pPixmap->drawable.pScreen);

    return ds->getPixmapHandle(pPixmap, flags);
}

static void *
DRI2SetupSAREA(ScreenPtr pScreen, size_t driverSareaSize)
{
    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
    unsigned long mask;
    const size_t event_buffer_size = 32 * 1024;

    ds->sareaSize = 
	sizeof(*ds->buffer) + event_buffer_size +
	driverSareaSize +
	sizeof (unsigned int);

    mask = DRM_BO_FLAG_READ | DRM_BO_FLAG_WRITE | DRM_BO_FLAG_MAPPABLE |
	DRM_BO_FLAG_MEM_LOCAL | DRM_BO_FLAG_SHAREABLE;

    if (drmBOCreate(ds->fd, ds->sareaSize, 1, NULL, mask, 0, &ds->sareaBO))
	return NULL;

    if (drmBOMap(ds->fd, &ds->sareaBO,
		 DRM_BO_FLAG_READ | DRM_BO_FLAG_WRITE, 0, &ds->sarea)) {
	drmBOUnreference(ds->fd, &ds->sareaBO);
	return NULL;
    }

    xf86DrvMsg(pScreen->myNum, X_INFO,
	       "[DRI2] Allocated %d byte SAREA, BO handle 0x%08x\n",
	       ds->sareaSize, ds->sareaBO.handle);
    memset(ds->sarea, 0, ds->sareaSize);

    ds->buffer = ds->sarea;
    ds->buffer->block_header =
	DRI2_SAREA_BLOCK_HEADER(DRI2_SAREA_BLOCK_EVENT_BUFFER,
				sizeof *ds->buffer + event_buffer_size);
    ds->buffer->size = event_buffer_size;

    return DRI2_SAREA_BLOCK_NEXT(ds->buffer);
}

void *
a503 1
    void *p;
d507 1
a507 1
	return NULL;
d509 23
a531 14
    ds->fd			= info->fd;
    ds->driverName		= info->driverName;
    ds->nextHandle		= 1;

    ds->getPixmapHandle		= info->getPixmapHandle;
    ds->beginClipNotify		= info->beginClipNotify;
    ds->endClipNotify		= info->endClipNotify;

    ds->ClipNotify		= pScreen->ClipNotify;
    pScreen->ClipNotify		= DRI2ClipNotify;
    ds->HandleExposures		= pScreen->HandleExposures;
    pScreen->HandleExposures	= DRI2HandleExposures;

    dixSetPrivate(&pScreen->devPrivates, dri2ScreenPrivateKey, ds);
d533 3
a535 2
    p = DRI2SetupSAREA(pScreen, info->driverSareaSize);
    if (p == NULL) {
d537 1
a537 1
	return NULL;
d539 3
d545 10
a554 1
    return p;
d564 2
a565 1
    if (!setupDone) {
d568 3
a570 1
    } else {
d585 1
a585 1
    1, 0, 0,
d594 9
@

