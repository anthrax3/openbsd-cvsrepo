head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	7pAEtF6Y5EgemkuY;

1.10
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	vcnjRBuLQw44cPHf;

1.9
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2013.06.07.17.28.51;	author matthieu;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	;

1.8.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.9.2.1
date	2014.12.09.17.59.33;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.11
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/*
 * Copyright © 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Soft-
 * ware"), to deal in the Software without restriction, including without
 * limitation the rights to use, copy, modify, merge, publish, distribute,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, provided that the above copyright
 * notice(s) and this permission notice appear in all copies of the Soft-
 * ware and that both the above copyright notice(s) and this permission
 * notice appear in supporting documentation.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
 * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
 * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
 * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
 * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
 * MANCE OF THIS SOFTWARE.
 *
 * Except as contained in this notice, the name of a copyright holder shall
 * not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization of
 * the copyright holder.
 *
 * Authors:
 *   Kristian Høgsberg (krh@@redhat.com)
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/extensions/dri2proto.h>
#include <X11/extensions/xfixeswire.h>
#include "dixstruct.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "xfixes.h"
#include "dri2.h"
#include "dri2int.h"
#include "protocol-versions.h"

/* The only xf86 includes */
#include "xf86Module.h"
#include "xf86Extensions.h"

static int DRI2EventBase;


static Bool
validDrawable(ClientPtr client, XID drawable, Mask access_mode,
              DrawablePtr *pDrawable, int *status)
{
    *status = dixLookupDrawable(pDrawable, drawable, client,
                                M_DRAWABLE_WINDOW | M_DRAWABLE_PIXMAP,
                                access_mode);
    if (*status != Success) {
        client->errorValue = drawable;
        return FALSE;
    }

    return TRUE;
}

static int
ProcDRI2QueryVersion(ClientPtr client)
{
    REQUEST(xDRI2QueryVersionReq);
    xDRI2QueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = dri2_major,
        .minorVersion = dri2_minor
    };

    if (client->swapped)
        swaps(&stuff->length);

    REQUEST_SIZE_MATCH(xDRI2QueryVersionReq);

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.majorVersion);
        swapl(&rep.minorVersion);
    }

    WriteToClient(client, sizeof(xDRI2QueryVersionReply), &rep);

    return Success;
}

static int
ProcDRI2Connect(ClientPtr client)
{
    REQUEST(xDRI2ConnectReq);
    xDRI2ConnectReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .driverNameLength = 0,
        .deviceNameLength = 0
    };
    DrawablePtr pDraw;
    int fd, status;
    const char *driverName;
    const char *deviceName;

    REQUEST_SIZE_MATCH(xDRI2ConnectReq);
    if (!validDrawable(client, stuff->window, DixGetAttrAccess,
                       &pDraw, &status))
        return status;

    if (!DRI2Connect(client, pDraw->pScreen,
                     stuff->driverType, &fd, &driverName, &deviceName))
        goto fail;

    rep.driverNameLength = strlen(driverName);
    rep.deviceNameLength = strlen(deviceName);
    rep.length = (rep.driverNameLength + 3) / 4 +
        (rep.deviceNameLength + 3) / 4;

 fail:
    WriteToClient(client, sizeof(xDRI2ConnectReply), &rep);
    WriteToClient(client, rep.driverNameLength, driverName);
    WriteToClient(client, rep.deviceNameLength, deviceName);

    return Success;
}

static int
ProcDRI2Authenticate(ClientPtr client)
{
    REQUEST(xDRI2AuthenticateReq);
    xDRI2AuthenticateReply rep;
    DrawablePtr pDraw;
    int status;

    REQUEST_SIZE_MATCH(xDRI2AuthenticateReq);
    if (!validDrawable(client, stuff->window, DixGetAttrAccess,
                       &pDraw, &status))
        return status;

    rep = (xDRI2AuthenticateReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .authenticated = DRI2Authenticate(client, pDraw->pScreen, stuff->magic)
    };
    WriteToClient(client, sizeof(xDRI2AuthenticateReply), &rep);

    return Success;
}

static void
DRI2InvalidateBuffersEvent(DrawablePtr pDraw, void *priv, XID id)
{
    ClientPtr client = priv;
    xDRI2InvalidateBuffers event = {
        .type = DRI2EventBase + DRI2_InvalidateBuffers,
        .drawable = id
    };

    WriteEventsToClient(client, 1, (xEvent *) &event);
}

static int
ProcDRI2CreateDrawable(ClientPtr client)
{
    REQUEST(xDRI2CreateDrawableReq);
    DrawablePtr pDrawable;
    int status;

    REQUEST_SIZE_MATCH(xDRI2CreateDrawableReq);

    if (!validDrawable(client, stuff->drawable, DixAddAccess,
                       &pDrawable, &status))
        return status;

    status = DRI2CreateDrawable(client, pDrawable, stuff->drawable,
                                DRI2InvalidateBuffersEvent, client);
    if (status != Success)
        return status;

    return Success;
}

static int
ProcDRI2DestroyDrawable(ClientPtr client)
{
    REQUEST(xDRI2DestroyDrawableReq);
    DrawablePtr pDrawable;
    int status;

    REQUEST_SIZE_MATCH(xDRI2DestroyDrawableReq);
    if (!validDrawable(client, stuff->drawable, DixRemoveAccess,
                       &pDrawable, &status))
        return status;

    return Success;
}

static int
send_buffers_reply(ClientPtr client, DrawablePtr pDrawable,
                   DRI2BufferPtr * buffers, int count, int width, int height)
{
    xDRI2GetBuffersReply rep;
    int skip = 0;
    int i;

    if (buffers == NULL)
        return BadAlloc;

    if (pDrawable->type == DRAWABLE_WINDOW) {
        for (i = 0; i < count; i++) {
            /* Do not send the real front buffer of a window to the client.
             */
            if (buffers[i]->attachment == DRI2BufferFrontLeft) {
                skip++;
                continue;
            }
        }
    }

    rep = (xDRI2GetBuffersReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = (count - skip) * sizeof(xDRI2Buffer) / 4,
        .width = width,
        .height = height,
        .count = count - skip
    };
    WriteToClient(client, sizeof(xDRI2GetBuffersReply), &rep);

    for (i = 0; i < count; i++) {
        xDRI2Buffer buffer;

        /* Do not send the real front buffer of a window to the client.
         */
        if ((pDrawable->type == DRAWABLE_WINDOW)
            && (buffers[i]->attachment == DRI2BufferFrontLeft)) {
            continue;
        }

        buffer.attachment = buffers[i]->attachment;
        buffer.name = buffers[i]->name;
        buffer.pitch = buffers[i]->pitch;
        buffer.cpp = buffers[i]->cpp;
        buffer.flags = buffers[i]->flags;
        WriteToClient(client, sizeof(xDRI2Buffer), &buffer);
    }
    return Success;
}

static int
ProcDRI2GetBuffers(ClientPtr client)
{
    REQUEST(xDRI2GetBuffersReq);
    DrawablePtr pDrawable;
    DRI2BufferPtr *buffers;
    int status, width, height, count;
    unsigned int *attachments;

    REQUEST_AT_LEAST_SIZE(xDRI2GetBuffersReq);
    /* stuff->count is a count of CARD32 attachments that follows */
    if (stuff->count > (INT_MAX / sizeof(CARD32)))
        return BadLength;
    REQUEST_FIXED_SIZE(xDRI2GetBuffersReq, stuff->count * sizeof(CARD32));

    if (!validDrawable(client, stuff->drawable, DixReadAccess | DixWriteAccess,
                       &pDrawable, &status))
        return status;

    if (DRI2ThrottleClient(client, pDrawable))
        return Success;

    attachments = (unsigned int *) &stuff[1];
    buffers = DRI2GetBuffers(pDrawable, &width, &height,
                             attachments, stuff->count, &count);

    return send_buffers_reply(client, pDrawable, buffers, count, width, height);

}

static int
ProcDRI2GetBuffersWithFormat(ClientPtr client)
{
    REQUEST(xDRI2GetBuffersReq);
    DrawablePtr pDrawable;
    DRI2BufferPtr *buffers;
    int status, width, height, count;
    unsigned int *attachments;

    REQUEST_AT_LEAST_SIZE(xDRI2GetBuffersReq);
    /* stuff->count is a count of pairs of CARD32s (attachments & formats)
       that follows */
    if (stuff->count > (INT_MAX / (2 * sizeof(CARD32))))
        return BadLength;
    REQUEST_FIXED_SIZE(xDRI2GetBuffersReq,
                       stuff->count * (2 * sizeof(CARD32)));
    if (!validDrawable(client, stuff->drawable, DixReadAccess | DixWriteAccess,
                       &pDrawable, &status))
        return status;

    if (DRI2ThrottleClient(client, pDrawable))
        return Success;

    attachments = (unsigned int *) &stuff[1];
    buffers = DRI2GetBuffersWithFormat(pDrawable, &width, &height,
                                       attachments, stuff->count, &count);

    return send_buffers_reply(client, pDrawable, buffers, count, width, height);
}

static int
ProcDRI2CopyRegion(ClientPtr client)
{
    REQUEST(xDRI2CopyRegionReq);
    xDRI2CopyRegionReply rep;
    DrawablePtr pDrawable;
    int status;
    RegionPtr pRegion;

    REQUEST_SIZE_MATCH(xDRI2CopyRegionReq);

    if (!validDrawable(client, stuff->drawable, DixWriteAccess,
                       &pDrawable, &status))
        return status;

    VERIFY_REGION(pRegion, stuff->region, client, DixReadAccess);

    status = DRI2CopyRegion(pDrawable, pRegion, stuff->dest, stuff->src);
    if (status != Success)
        return status;

    /* CopyRegion needs to be a round trip to make sure the X server
     * queues the swap buffer rendering commands before the DRI client
     * continues rendering.  The reply has a bitmask to signal the
     * presense of optional return values as well, but we're not using
     * that yet.
     */

    rep = (xDRI2CopyRegionReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };

    WriteToClient(client, sizeof(xDRI2CopyRegionReply), &rep);

    return Success;
}

static void
load_swap_reply(xDRI2SwapBuffersReply * rep, CARD64 sbc)
{
    rep->swap_hi = sbc >> 32;
    rep->swap_lo = sbc & 0xffffffff;
}

static CARD64
vals_to_card64(CARD32 lo, CARD32 hi)
{
    return (CARD64) hi << 32 | lo;
}

static void
DRI2SwapEvent(ClientPtr client, void *data, int type, CARD64 ust, CARD64 msc,
              CARD32 sbc)
{
    DrawablePtr pDrawable = data;
    xDRI2BufferSwapComplete2 event = {
        .type = DRI2EventBase + DRI2_BufferSwapComplete,
        .event_type = type,
        .drawable = pDrawable->id,
        .ust_hi = (CARD64) ust >> 32,
        .ust_lo = ust & 0xffffffff,
        .msc_hi = (CARD64) msc >> 32,
        .msc_lo = msc & 0xffffffff,
        .sbc = sbc
    };

    WriteEventsToClient(client, 1, (xEvent *) &event);
}

static int
ProcDRI2SwapBuffers(ClientPtr client)
{
    REQUEST(xDRI2SwapBuffersReq);
    xDRI2SwapBuffersReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    DrawablePtr pDrawable;
    CARD64 target_msc, divisor, remainder, swap_target;
    int status;

    REQUEST_SIZE_MATCH(xDRI2SwapBuffersReq);

    if (!validDrawable(client, stuff->drawable,
                       DixReadAccess | DixWriteAccess, &pDrawable, &status))
        return status;

    /*
     * Ensures an out of control client can't exhaust our swap queue, and
     * also orders swaps.
     */
    if (DRI2ThrottleClient(client, pDrawable))
        return Success;

    target_msc = vals_to_card64(stuff->target_msc_lo, stuff->target_msc_hi);
    divisor = vals_to_card64(stuff->divisor_lo, stuff->divisor_hi);
    remainder = vals_to_card64(stuff->remainder_lo, stuff->remainder_hi);

    status = DRI2SwapBuffers(client, pDrawable, target_msc, divisor, remainder,
                             &swap_target, DRI2SwapEvent, pDrawable);
    if (status != Success)
        return BadDrawable;

    load_swap_reply(&rep, swap_target);

    WriteToClient(client, sizeof(xDRI2SwapBuffersReply), &rep);

    return Success;
}

static void
load_msc_reply(xDRI2MSCReply * rep, CARD64 ust, CARD64 msc, CARD64 sbc)
{
    rep->ust_hi = ust >> 32;
    rep->ust_lo = ust & 0xffffffff;
    rep->msc_hi = msc >> 32;
    rep->msc_lo = msc & 0xffffffff;
    rep->sbc_hi = sbc >> 32;
    rep->sbc_lo = sbc & 0xffffffff;
}

static int
ProcDRI2GetMSC(ClientPtr client)
{
    REQUEST(xDRI2GetMSCReq);
    xDRI2MSCReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    DrawablePtr pDrawable;
    CARD64 ust, msc, sbc;
    int status;

    REQUEST_SIZE_MATCH(xDRI2GetMSCReq);

    if (!validDrawable(client, stuff->drawable, DixReadAccess, &pDrawable,
                       &status))
        return status;

    status = DRI2GetMSC(pDrawable, &ust, &msc, &sbc);
    if (status != Success)
        return status;

    load_msc_reply(&rep, ust, msc, sbc);

    WriteToClient(client, sizeof(xDRI2MSCReply), &rep);

    return Success;
}

static int
ProcDRI2WaitMSC(ClientPtr client)
{
    REQUEST(xDRI2WaitMSCReq);
    DrawablePtr pDrawable;
    CARD64 target, divisor, remainder;
    int status;

    /* FIXME: in restart case, client may be gone at this point */

    REQUEST_SIZE_MATCH(xDRI2WaitMSCReq);

    if (!validDrawable(client, stuff->drawable, DixReadAccess, &pDrawable,
                       &status))
        return status;

    target = vals_to_card64(stuff->target_msc_lo, stuff->target_msc_hi);
    divisor = vals_to_card64(stuff->divisor_lo, stuff->divisor_hi);
    remainder = vals_to_card64(stuff->remainder_lo, stuff->remainder_hi);

    status = DRI2WaitMSC(client, pDrawable, target, divisor, remainder);
    if (status != Success)
        return status;

    return Success;
}

int
ProcDRI2WaitMSCReply(ClientPtr client, CARD64 ust, CARD64 msc, CARD64 sbc)
{
    xDRI2MSCReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };

    load_msc_reply(&rep, ust, msc, sbc);

    WriteToClient(client, sizeof(xDRI2MSCReply), &rep);

    return Success;
}

static int
ProcDRI2SwapInterval(ClientPtr client)
{
    REQUEST(xDRI2SwapIntervalReq);
    DrawablePtr pDrawable;
    int status;

    /* FIXME: in restart case, client may be gone at this point */

    REQUEST_SIZE_MATCH(xDRI2SwapIntervalReq);

    if (!validDrawable(client, stuff->drawable, DixReadAccess | DixWriteAccess,
                       &pDrawable, &status))
        return status;

    DRI2SwapInterval(pDrawable, stuff->interval);

    return Success;
}

static int
ProcDRI2WaitSBC(ClientPtr client)
{
    REQUEST(xDRI2WaitSBCReq);
    DrawablePtr pDrawable;
    CARD64 target;
    int status;

    REQUEST_SIZE_MATCH(xDRI2WaitSBCReq);

    if (!validDrawable(client, stuff->drawable, DixReadAccess, &pDrawable,
                       &status))
        return status;

    target = vals_to_card64(stuff->target_sbc_lo, stuff->target_sbc_hi);
    status = DRI2WaitSBC(client, pDrawable, target);

    return status;
}

static int
ProcDRI2GetParam(ClientPtr client)
{
    REQUEST(xDRI2GetParamReq);
    xDRI2GetParamReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    DrawablePtr pDrawable;
    CARD64 value;
    int status;

    REQUEST_SIZE_MATCH(xDRI2GetParamReq);

    if (!validDrawable(client, stuff->drawable, DixReadAccess,
                       &pDrawable, &status))
        return status;

    status = DRI2GetParam(client, pDrawable, stuff->param,
                          &rep.is_param_recognized, &value);
    rep.value_hi = value >> 32;
    rep.value_lo = value & 0xffffffff;

    if (status != Success)
        return status;

    WriteToClient(client, sizeof(xDRI2GetParamReply), &rep);

    return status;
}

static int
ProcDRI2Dispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_DRI2QueryVersion:
        return ProcDRI2QueryVersion(client);
    }

    if (!client->local)
        return BadRequest;

    switch (stuff->data) {
    case X_DRI2Connect:
        return ProcDRI2Connect(client);
    case X_DRI2Authenticate:
        return ProcDRI2Authenticate(client);
    case X_DRI2CreateDrawable:
        return ProcDRI2CreateDrawable(client);
    case X_DRI2DestroyDrawable:
        return ProcDRI2DestroyDrawable(client);
    case X_DRI2GetBuffers:
        return ProcDRI2GetBuffers(client);
    case X_DRI2CopyRegion:
        return ProcDRI2CopyRegion(client);
    case X_DRI2GetBuffersWithFormat:
        return ProcDRI2GetBuffersWithFormat(client);
    case X_DRI2SwapBuffers:
        return ProcDRI2SwapBuffers(client);
    case X_DRI2GetMSC:
        return ProcDRI2GetMSC(client);
    case X_DRI2WaitMSC:
        return ProcDRI2WaitMSC(client);
    case X_DRI2WaitSBC:
        return ProcDRI2WaitSBC(client);
    case X_DRI2SwapInterval:
        return ProcDRI2SwapInterval(client);
    case X_DRI2GetParam:
        return ProcDRI2GetParam(client);
    default:
        return BadRequest;
    }
}

static int
SProcDRI2Connect(ClientPtr client)
{
    REQUEST(xDRI2ConnectReq);
    xDRI2ConnectReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .driverNameLength = 0,
        .deviceNameLength = 0
    };

    /* If the client is swapped, it's not local.  Talk to the hand. */

    swaps(&stuff->length);
    if (sizeof(*stuff) / 4 != client->req_len)
        return BadLength;

    swaps(&rep.sequenceNumber);

    WriteToClient(client, sizeof(xDRI2ConnectReply), &rep);

    return Success;
}

static int
SProcDRI2Dispatch(ClientPtr client)
{
    REQUEST(xReq);

    /*
     * Only local clients are allowed DRI access, but remote clients
     * still need these requests to find out cleanly.
     */
    switch (stuff->data) {
    case X_DRI2QueryVersion:
        return ProcDRI2QueryVersion(client);
    case X_DRI2Connect:
        return SProcDRI2Connect(client);
    default:
        return BadRequest;
    }
}

void
DRI2ExtensionInit(void)
{
    ExtensionEntry *dri2Extension;

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        return;
#endif

    dri2Extension = AddExtension(DRI2_NAME,
                                 DRI2NumberEvents,
                                 DRI2NumberErrors,
                                 ProcDRI2Dispatch,
                                 SProcDRI2Dispatch, NULL, StandardMinorOpcode);

    DRI2EventBase = dri2Extension->eventBase;

    DRI2ModuleSetup();
}
@


1.10
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d272 3
a274 2
    REQUEST_FIXED_SIZE(xDRI2GetBuffersReq, stuff->count * 4);
    if (stuff->count > (INT_MAX / 4))
d276 1
d302 7
a308 1
    REQUEST_FIXED_SIZE(xDRI2GetBuffersReq, stuff->count * (2 * 4));
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d273 3
@


1.9.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a272 3
    if (stuff->count > (INT_MAX / 4))
        return BadLength;

@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d675 5
@


1.8.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a272 3
    if (stuff->count > (INT_MAX / 4))
        return BadLength;

@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d47 1
d50 1
a50 1
/* The only xf86 include */
d52 3
a55 2
static ExtensionEntry *dri2Extension;
extern Bool DRI2ModuleSetup(void);
d76 7
a82 1
    xDRI2QueryVersionReply rep;
a87 5
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = dri2_major;
    rep.minorVersion = dri2_minor;
d105 7
a111 1
    xDRI2ConnectReply rep;
d122 1
a122 7
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.driverNameLength = 0;
    rep.deviceNameLength = 0;

    if (!DRI2Connect(pDraw->pScreen,
d152 6
a157 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.authenticated = DRI2Authenticate(pDraw->pScreen, stuff->magic);
a165 1
    xDRI2InvalidateBuffers event;
d167 4
a170 3

    event.type = DRI2EventBase + DRI2_InvalidateBuffers;
    event.drawable = id;
d233 8
a240 6
    rep.type = X_Reply;
    rep.length = (count - skip) * sizeof(xDRI2Buffer) / 4;
    rep.sequenceNumber = client->sequence;
    rep.width = width;
    rep.height = height;
    rep.count = count - skip;
d340 5
a344 3
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
a367 1
    xDRI2BufferSwapComplete2 event;
d369 10
a378 9

    event.type = DRI2EventBase + DRI2_BufferSwapComplete;
    event.event_type = type;
    event.drawable = pDrawable->id;
    event.ust_hi = (CARD64) ust >> 32;
    event.ust_lo = ust & 0xffffffff;
    event.msc_hi = (CARD64) msc >> 32;
    event.msc_lo = msc & 0xffffffff;
    event.sbc = sbc;
d387 5
a391 1
    xDRI2SwapBuffersReply rep;
a417 3
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d440 5
a444 1
    xDRI2MSCReply rep;
a458 3
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d496 5
a500 1
    xDRI2MSCReply rep;
a501 3
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d550 32
d591 1
a591 1
    if (!LocalClient(client))
d619 2
d630 7
a636 1
    xDRI2ConnectReply rep;
a643 1
    rep.sequenceNumber = client->sequence;
d645 2
a646 3
    rep.length = 0;
    rep.driverNameLength = 0;
    rep.deviceNameLength = 0;
d670 1
a670 3
int DRI2EventBase;

static void
d673 2
a684 10

extern Bool noDRI2Extension;

_X_HIDDEN ExtensionModule dri2ExtensionModule = {
    DRI2ExtensionInit,
    DRI2_NAME,
    &noDRI2Extension,
    NULL,
    NULL
};
@


1.6
log
@Bugfix Update to xserver 1.11.3
@
text
@d52 1
a52 1
static ExtensionEntry	*dri2Extension;
d57 1
a57 1
	      DrawablePtr *pDrawable, int *status)
d60 2
a61 2
				M_DRAWABLE_WINDOW | M_DRAWABLE_PIXMAP,
				access_mode);
d63 2
a64 2
	client->errorValue = drawable;
	return FALSE;
a74 1
    int n;
d77 1
a77 1
	swaps(&stuff->length, n);
d87 4
a90 4
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swapl(&rep.majorVersion, n);
	swapl(&rep.minorVersion, n);
d110 3
a112 3
		       &pDraw, &status))
	return status;
    
d120 2
a121 2
		     stuff->driverType, &fd, &driverName, &deviceName))
	goto fail;
d126 1
a126 1
	    (rep.deviceNameLength + 3) / 4;
d146 2
a147 2
		       &pDraw, &status))
	return status;
d159 1
a159 1
DRI2InvalidateBuffersEvent(DrawablePtr pDraw, void *priv)
d165 1
a165 1
    event.drawable = pDraw->id;
d167 1
a167 1
    WriteEventsToClient(client, 1, (xEvent *)&event);
d180 2
a181 2
		       &pDrawable, &status))
	return status;
d184 1
a184 1
				DRI2InvalidateBuffersEvent, client);
d186 1
a186 1
	return status;
d200 2
a201 2
		       &pDrawable, &status))
	return status;
a205 1

d208 1
a208 1
		   DRI2BufferPtr *buffers, int count, int width, int height)
d215 1
a215 1
	    return BadAlloc;
d218 8
a225 8
	for (i = 0; i < count; i++) {
	    /* Do not send the real front buffer of a window to the client.
	     */
	    if (buffers[i]->attachment == DRI2BufferFrontLeft) {
		skip++;
		continue;
	    }
	}
d237 1
a237 1
	xDRI2Buffer buffer;
d239 13
a251 13
	/* Do not send the real front buffer of a window to the client.
	 */
	if ((pDrawable->type == DRAWABLE_WINDOW)
	    && (buffers[i]->attachment == DRI2BufferFrontLeft)) {
	    continue;
	}

	buffer.attachment = buffers[i]->attachment;
	buffer.name = buffers[i]->name;
	buffer.pitch = buffers[i]->pitch;
	buffer.cpp = buffers[i]->cpp;
	buffer.flags = buffers[i]->flags;
	WriteToClient(client, sizeof(xDRI2Buffer), &buffer);
a255 1

d267 2
a268 2
		       &pDrawable, &status))
	return status;
d271 1
a271 1
	return Success;
d275 1
a275 2
			     attachments, stuff->count, &count);

d292 2
a293 2
		       &pDrawable, &status))
	return status;
d296 1
a296 1
	return Success;
d300 1
a300 1
				       attachments, stuff->count, &count);
d317 2
a318 2
		       &pDrawable, &status))
	return status;
d324 1
a324 1
	return status;
d343 1
a343 1
load_swap_reply(xDRI2SwapBuffersReply *rep, CARD64 sbc)
d352 1
a352 1
    return (CARD64)hi << 32 | lo;
d357 1
a357 1
	      CARD32 sbc)
d365 1
a365 1
    event.ust_hi = (CARD64)ust >> 32;
d367 1
a367 1
    event.msc_hi = (CARD64)msc >> 32;
d371 1
a371 1
    WriteEventsToClient(client, 1, (xEvent *)&event);
d386 2
a387 2
		       DixReadAccess | DixWriteAccess, &pDrawable, &status))
	return status;
d394 1
a394 1
	return Success;
d401 1
a401 1
			     &swap_target, DRI2SwapEvent, pDrawable);
d403 1
a403 1
	return BadDrawable;
d416 1
a416 1
load_msc_reply(xDRI2MSCReply *rep, CARD64 ust, CARD64 msc, CARD64 sbc)
d438 2
a439 2
		       &status))
	return status;
d443 1
a443 1
	return status;
d468 2
a469 2
		       &status))
	return status;
d477 1
a477 1
	return status;
d509 2
a510 2
		       &pDrawable, &status))
	return status;
d528 2
a529 2
		       &status))
	return status;
d538 1
a538 1
ProcDRI2Dispatch (ClientPtr client)
d541 1
a541 1
    
d544 1
a544 1
	return ProcDRI2QueryVersion(client);
d548 1
a548 1
	return BadRequest;
d552 1
a552 1
	return ProcDRI2Connect(client);
d554 1
a554 1
	return ProcDRI2Authenticate(client);
d556 1
a556 1
	return ProcDRI2CreateDrawable(client);
d558 1
a558 1
	return ProcDRI2DestroyDrawable(client);
d560 1
a560 1
	return ProcDRI2GetBuffers(client);
d562 1
a562 1
	return ProcDRI2CopyRegion(client);
d564 1
a564 1
	return ProcDRI2GetBuffersWithFormat(client);
d566 1
a566 1
	return ProcDRI2SwapBuffers(client);
d568 1
a568 1
	return ProcDRI2GetMSC(client);
d570 1
a570 1
	return ProcDRI2WaitMSC(client);
d572 1
a572 1
	return ProcDRI2WaitSBC(client);
d574 1
a574 1
	return ProcDRI2SwapInterval(client);
d576 1
a576 1
	return BadRequest;
a584 1
    int n;
d588 1
a588 1
    swaps(&stuff->length, n);
d590 1
a590 1
	return BadLength;
d593 1
a593 1
    swaps(&rep.sequenceNumber, n);
d602 1
a602 1
SProcDRI2Dispatch (ClientPtr client)
d610 1
a610 2
    switch (stuff->data)
    {
d612 1
a612 1
	return ProcDRI2QueryVersion(client);
d614 1
a614 1
	return SProcDRI2Connect(client);
d616 1
a616 1
	return BadRequest;
d626 4
a629 6
				 DRI2NumberEvents,
				 DRI2NumberErrors,
				 ProcDRI2Dispatch,
				 SProcDRI2Dispatch,
				 NULL,
				 StandardMinorOpcode);
@


1.5
log
@Update to xserver 1.11.2
@
text
@d53 1
d640 2
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d360 1
a360 1
	      CARD64 sbc)
d362 1
a362 1
    xDRI2BufferSwapComplete event;
d372 1
a372 2
    event.sbc_hi = (CARD64)sbc >> 32;
    event.sbc_lo = sbc & 0xffffffff;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a44 1
#include "xf86drm.h"
d58 3
a60 1
    *status = dixLookupDrawable(pDrawable, drawable, client, 0, access_mode);
d95 1
a95 1
    return client->noClientException;
d133 1
a133 1
    return client->noClientException;
d155 13
a167 1
    return client->noClientException;
d183 2
a184 1
    status = DRI2CreateDrawable(client, pDrawable, stuff->drawable);
d188 1
a188 1
    return client->noClientException;
d203 1
a203 1
    return client->noClientException;
d207 1
a207 1
static void
d215 3
d254 1
d273 1
a273 1
	return client->noClientException;
d280 1
a280 1
    send_buffers_reply(client, pDrawable, buffers, count, width, height);
a281 1
    return client->noClientException;
d299 1
a299 1
	return client->noClientException;
d305 1
a305 3
    send_buffers_reply(client, pDrawable, buffers, count, width, height);

    return client->noClientException;
d342 1
a342 1
    return client->noClientException;
a365 1
    event.sequenceNumber = client->sequence;
d398 1
a398 1
	return client->noClientException;
d416 1
a416 1
    return client->noClientException;
d456 1
a456 1
    return client->noClientException;
d483 1
a483 1
    return client->noClientException;
d498 1
a498 1
    return client->noClientException;
d518 1
a518 1
    return client->noClientException;
d603 1
a603 1
    return client->noClientException;
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a36 1
#define NEED_REPLIES
d48 1
a53 1
static RESTYPE		 dri2DrawableRes;
d56 1
a56 1
validDrawable(ClientPtr client, XID drawable,
d59 1
a59 1
    *status = dixLookupDrawable(pDrawable, drawable, client, 0, DixReadAccess);
d82 2
a83 2
    rep.majorVersion = 1;
    rep.minorVersion = 1;
d108 2
a109 1
    if (!validDrawable(client, stuff->window, &pDraw, &status))
d144 2
a145 1
    if (!validDrawable(client, stuff->window, &pDraw, &status))
d166 2
a167 1
    if (!validDrawable(client, stuff->drawable, &pDrawable, &status))
d170 1
a170 1
    status = DRI2CreateDrawable(pDrawable);
a173 5
    if (!AddResource(stuff->drawable, dri2DrawableRes, pDrawable)) {
	DRI2DestroyDrawable(pDrawable);
	return BadAlloc;
    }

d185 2
a186 1
    if (!validDrawable(client, stuff->drawable, &pDrawable, &status))
a188 2
    FreeResourceByType(stuff->drawable, dri2DrawableRes, FALSE);

d195 1
a195 1
		   DRI2Buffer2Ptr *buffers, int count, int width, int height)
d245 1
a245 1
    DRI2Buffer2Ptr *buffers;
d250 2
a251 1
    if (!validDrawable(client, stuff->drawable, &pDrawable, &status))
d254 3
d272 1
a272 1
    DRI2Buffer2Ptr *buffers;
d277 2
a278 1
    if (!validDrawable(client, stuff->drawable, &pDrawable, &status))
d281 3
d304 2
a305 1
    if (!validDrawable(client, stuff->drawable, &pDrawable, &status))
d330 197
d555 10
d612 1
a612 8
static int DRI2DrawableGone(pointer p, XID id)
{
    DrawablePtr pDrawable = p;

    DRI2DestroyDrawable(pDrawable);

    return Success;
}
d625 1
a625 1
    dri2DrawableRes = CreateNewResourceType(DRI2DrawableGone);
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d41 1
d47 1
a56 13
validScreen(ClientPtr client, int screen, ScreenPtr *pScreen)
{
    if (screen >= screenInfo.numScreens) {
	client->errorValue = screen;
	return FALSE;
    }

    *pScreen = screenInfo.screens[screen];

    return TRUE;
}

static Bool
d83 2
a84 2
    rep.majorVersion = DRI2_MAJOR;
    rep.minorVersion = DRI2_MINOR;
d103 2
a104 2
    ScreenPtr pScreen;
    int fd;
d106 1
a106 2
    char *busId = NULL;
    unsigned int sareaHandle;
d109 2
a110 2
    if (!validScreen(client, stuff->screen, &pScreen))
	return BadValue;
d116 1
a116 5
    rep.busIdLength = 0;
    rep.sareaHandle = 0;

    if (!DRI2Connect(pScreen, &fd, &driverName, &sareaHandle))
	goto fail;
d118 2
a119 2
    busId = drmGetBusid(fd);
    if (busId == NULL)
d123 3
a125 3
    rep.busIdLength = strlen(busId);
    rep.sareaHandle = sareaHandle;
    rep.length = (rep.driverNameLength + 3) / 4 + (rep.busIdLength + 3) / 4;
d130 1
a130 2
    WriteToClient(client, rep.busIdLength, busId);
    drmFreeBusid(busId);
d136 1
a136 1
ProcDRI2AuthConnection(ClientPtr client)
d138 8
a145 7
    REQUEST(xDRI2AuthConnectionReq);
    xDRI2AuthConnectionReply rep;
    ScreenPtr pScreen;

    REQUEST_SIZE_MATCH(xDRI2AuthConnectionReq);
    if (!validScreen(client, stuff->screen, &pScreen))
	return BadValue;
d148 1
d150 2
a151 10
    rep.sequenceNumber = client->sequence;
    rep.authenticated = 1;

    if (!DRI2AuthConnection(pScreen, stuff->magic)) {
        ErrorF("DRI2: Failed to authenticate %lu\n",
	       (unsigned long) stuff->magic);
	rep.authenticated = 0;
    }

    WriteToClient(client, sizeof(xDRI2AuthConnectionReply), &rep);
a159 1
    xDRI2CreateDrawableReply rep;
a160 1
    unsigned int handle, head;
d168 3
a170 2
    if (!DRI2CreateDrawable(pDrawable, &handle, &head))
	return BadMatch;
a176 8
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.handle = handle;
    rep.head = head;

    WriteToClient(client, sizeof(xDRI2CreateDrawableReply), &rep);

d196 71
d268 1
a268 1
ProcDRI2ReemitDrawableInfo(ClientPtr client)
d270 24
a293 2
    REQUEST(xDRI2ReemitDrawableInfoReq);
    xDRI2ReemitDrawableInfoReply rep;
a294 1
    unsigned int head;
d296 3
a299 1
    REQUEST_SIZE_MATCH(xDRI2ReemitDrawableInfoReq);
d303 12
a314 1
    DRI2ReemitDrawableInfo(pDrawable, &head);
a318 1
    rep.head = head;
d320 1
a320 1
    WriteToClient(client, sizeof(xDRI2ReemitDrawableInfoReply), &rep);
d341 2
a342 2
    case X_DRI2AuthConnection:
	return ProcDRI2AuthConnection(client);
d347 6
a352 2
    case X_DRI2ReemitDrawableInfo:
	return ProcDRI2ReemitDrawableInfo(client);
d375 1
a375 2
    rep.busIdLength = 0;
    rep.sareaHandle = 0;
a399 5
static void
DRI2ResetProc (ExtensionEntry *extEntry)
{
}

d417 1
a417 1
				 DRI2ResetProc,
@

