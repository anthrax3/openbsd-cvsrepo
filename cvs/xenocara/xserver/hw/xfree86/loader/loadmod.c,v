head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.38;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.23;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.02;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.52;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.33;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.22;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.17.53;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.17.53;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.58.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 1995-1998 by Metro Link, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Metro Link, Inc. not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Metro Link, Inc. makes no
 * representations about the suitability of this software for any purpose.
 *  It is provided "as is" without express or implied warranty.
 *
 * METRO LINK, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL METRO LINK, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1997-2002 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "os.h"
/* For stat() and related stuff */
#define NO_OSLIB_PROTOTYPES
#include "xf86_OSlib.h"
#define LOADERDECLARATIONS
#include "loaderProcs.h"
#include "misc.h"
#include "xf86.h"
#include "xf86Priv.h"
#include "xf86Xinput.h"
#include "loader.h"
#include "xf86Optrec.h"

#include <sys/types.h>
#include <regex.h>
#include <dirent.h>
#include <limits.h>

typedef struct _pattern {
    const char *pattern;
    regex_t rex;
} PatternRec, *PatternPtr;

/* Prototypes for static functions */
static char *FindModule(const char *, const char *, const char **, PatternPtr);
static Bool CheckVersion(const char *, XF86ModuleVersionInfo *,
                         const XF86ModReqInfo *);
static char *LoaderGetCanonicalName(const char *, PatternPtr);
static void RemoveChild(ModuleDescPtr);

const ModuleVersions LoaderVersionInfo = {
    XORG_VERSION_CURRENT,
    ABI_ANSIC_VERSION,
    ABI_VIDEODRV_VERSION,
    ABI_XINPUT_VERSION,
    ABI_EXTENSION_VERSION,
    ABI_FONT_VERSION
};

static int ModuleDuplicated[] = { };

static void
FreeStringList(char **paths)
{
    char **p;

    if (!paths)
        return;

    for (p = paths; *p; p++)
        free(*p);

    free(paths);
}

static char **defaultPathList = NULL;

static Bool
PathIsAbsolute(const char *path)
{
    return *path == '/';
}

/*
 * Convert a comma-separated path into a NULL-terminated array of path
 * elements, rejecting any that are not full absolute paths, and appending
 * a '/' when it isn't already present.
 */
static char **
InitPathList(const char *path)
{
    char *fullpath = NULL;
    char *elem = NULL;
    char **list = NULL, **save = NULL;
    int len;
    int addslash;
    int n = 0;

    if (!path)
        return defaultPathList;

    fullpath = strdup(path);
    if (!fullpath)
        return NULL;
    elem = strtok(fullpath, ",");
    while (elem) {
        if (PathIsAbsolute(elem)) {
            len = strlen(elem);
            addslash = (elem[len - 1] != '/');
            if (addslash)
                len++;
            save = list;
            list = reallocarray(list, n + 2, sizeof(char *));
            if (!list) {
                if (save) {
                    save[n] = NULL;
                    FreeStringList(save);
                }
                free(fullpath);
                return NULL;
            }
            list[n] = malloc(len + 1);
            if (!list[n]) {
                FreeStringList(list);
                free(fullpath);
                return NULL;
            }
            strcpy(list[n], elem);
            if (addslash) {
                list[n][len - 1] = '/';
                list[n][len] = '\0';
            }
            n++;
        }
        elem = strtok(NULL, ",");
    }
    if (list)
        list[n] = NULL;
    free(fullpath);
    return list;
}

static void
FreePathList(char **pathlist)
{
    if (pathlist && pathlist != defaultPathList)
        FreeStringList(pathlist);
}

void
LoaderSetPath(const char *path)
{
    if (!path)
        return;

    defaultPathList = InitPathList(path);
}

/* Standard set of module subdirectories to search, in order of preference */
static const char *stdSubdirs[] = {
    "",
    "input/",
    "drivers/",
    "extensions/",
    "internal/",
    NULL
};

/*
 * Standard set of module name patterns to check, in order of preference
 * These are regular expressions (suitable for use with POSIX regex(3)).
 *
 * This list assumes that you're an ELFish platform and therefore your
 * shared libraries are named something.so.  If we're ever nuts enough
 * to port this DDX to, say, Darwin, we'll need to fix this.
 */
static PatternRec stdPatterns[] = {
#ifdef __CYGWIN__
    {"^cyg(.*)\\.dll$",},
    {"(.*)_drv\\.dll$",},
    {"(.*)\\.dll$",},
#else
    {"^lib(.*)\\.so$",},
    {"(.*)_drv\\.so$",},
    {"(.*)\\.so$",},
#endif
    {NULL,}
};

static PatternPtr
InitPatterns(const char **patternlist)
{
    char errmsg[80];
    int i, e;
    PatternPtr patterns = NULL;
    PatternPtr p = NULL;
    static int firstTime = 1;
    const char **s;

    if (firstTime) {
        /* precompile stdPatterns */
        firstTime = 0;
        for (p = stdPatterns; p->pattern; p++)
            if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
                regerror(e, &p->rex, errmsg, sizeof(errmsg));
                FatalError("InitPatterns: regcomp error for `%s': %s\n",
                           p->pattern, errmsg);
            }
    }

    if (patternlist) {
        for (i = 0, s = patternlist; *s; i++, s++)
            if (*s == DEFAULT_LIST)
                i += sizeof(stdPatterns) / sizeof(stdPatterns[0]) - 1 - 1;
        patterns = xallocarray(i + 1, sizeof(PatternRec));
        if (!patterns) {
            return NULL;
        }
        for (i = 0, s = patternlist; *s; i++, s++)
            if (*s != DEFAULT_LIST) {
                p = patterns + i;
                p->pattern = *s;
                if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
                    regerror(e, &p->rex, errmsg, sizeof(errmsg));
                    ErrorF("InitPatterns: regcomp error for `%s': %s\n",
                           p->pattern, errmsg);
                    i--;
                }
            }
            else {
                for (p = stdPatterns; p->pattern; p++, i++)
                    patterns[i] = *p;
                if (p != stdPatterns)
                    i--;
            }
        patterns[i].pattern = NULL;
    }
    else
        patterns = stdPatterns;
    return patterns;
}

static void
FreePatterns(PatternPtr patterns)
{
    if (patterns && patterns != stdPatterns)
        free(patterns);
}

static const char **
InitSubdirs(const char **subdirlist)
{
    int i;
    const char **tmp_subdirlist = NULL;
    char **subdirs = NULL;
    const char **s, **stmp = NULL;
    const char *osname;
    const char *slash;
    int oslen = 0, len;
    Bool indefault;

    if (subdirlist == NULL) {
        subdirlist = tmp_subdirlist = malloc(2 * sizeof(char *));
        if (subdirlist == NULL)
            return NULL;
        subdirlist[0] = DEFAULT_LIST;
        subdirlist[1] = NULL;
    }

    LoaderGetOS(&osname, NULL, NULL, NULL);
    oslen = strlen(osname);

    {
        /* Count number of entries and check for invalid paths */
        for (i = 0, s = subdirlist; *s; i++, s++) {
            if (*s == DEFAULT_LIST) {
                i += sizeof(stdSubdirs) / sizeof(stdSubdirs[0]) - 1 - 1;
            }
            else {
                /*
                 * Path validity check.  Don't allow absolute paths, or
                 * paths containing "..".  To catch absolute paths on
                 * platforms that use driver letters, don't allow the ':'
                 * character to appear at all.
                 */
                if (**s == '/' || **s == '\\' || strchr(*s, ':') ||
                    strstr(*s, "..")) {
                    xf86Msg(X_ERROR, "InitSubdirs: Bad subdir: \"%s\"\n", *s);
                    free(tmp_subdirlist);
                    return NULL;
                }
            }
        }
        subdirs = xallocarray(i * 2 + 1, sizeof(char *));
        if (!subdirs) {
            free(tmp_subdirlist);
            return NULL;
        }
        i = 0;
        s = subdirlist;
        indefault = FALSE;
        while (*s) {
            if (*s == DEFAULT_LIST) {
                /* Divert to the default list */
                indefault = TRUE;
                stmp = ++s;
                s = stdSubdirs;
            }
            len = strlen(*s);
            if (**s && (*s)[len - 1] != '/') {
                slash = "/";
                len++;
            }
            else
                slash = "";
            len += oslen + 2;
            if (!(subdirs[i] = malloc(len))) {
                while (--i >= 0)
                    free(subdirs[i]);
                free(subdirs);
                free(tmp_subdirlist);
                return NULL;
            }
            /* tack on the OS name */
            sprintf(subdirs[i], "%s%s%s/", *s, slash, osname);
            i++;
            /* path as given */
            subdirs[i] = strdup(*s);
            i++;
            s++;
            if (indefault && !s) {
                /* revert back to the main list */
                indefault = FALSE;
                s = stmp;
            }
        }
        subdirs[i] = NULL;
    }
    free(tmp_subdirlist);
    return (const char **) subdirs;
}

static void
FreeSubdirs(const char **subdirs)
{
    const char **s;

    if (subdirs) {
        for (s = subdirs; *s; s++)
            free((char *) *s);
        free(subdirs);
    }
}

static char *
FindModuleInSubdir(const char *dirpath, const char *module)
{
    struct dirent *direntry = NULL;
    DIR *dir = NULL;
    char *ret = NULL, tmpBuf[PATH_MAX];
    struct stat stat_buf;

    dir = opendir(dirpath);
    if (!dir)
        return NULL;

    while ((direntry = readdir(dir))) {
        if (direntry->d_name[0] == '.')
            continue;
        snprintf(tmpBuf, PATH_MAX, "%s%s/", dirpath, direntry->d_name);
        /* the stat with the appended / fails for normal files,
           and works for sub dirs fine, looks a bit strange in strace
           but does seem to work */
        if ((stat(tmpBuf, &stat_buf) == 0) && S_ISDIR(stat_buf.st_mode)) {
            if ((ret = FindModuleInSubdir(tmpBuf, module)))
                break;
            continue;
        }

#ifdef __CYGWIN__
        snprintf(tmpBuf, PATH_MAX, "cyg%s.dll", module);
#else
        snprintf(tmpBuf, PATH_MAX, "lib%s.so", module);
#endif
        if (strcmp(direntry->d_name, tmpBuf) == 0) {
            if (asprintf(&ret, "%s%s", dirpath, tmpBuf) == -1)
                ret = NULL;
            break;
        }

#ifdef __CYGWIN__
        snprintf(tmpBuf, PATH_MAX, "%s_drv.dll", module);
#else
        snprintf(tmpBuf, PATH_MAX, "%s_drv.so", module);
#endif
        if (strcmp(direntry->d_name, tmpBuf) == 0) {
            if (asprintf(&ret, "%s%s", dirpath, tmpBuf) == -1)
                ret = NULL;
            break;
        }

#ifdef __CYGWIN__
        snprintf(tmpBuf, PATH_MAX, "%s.dll", module);
#else
        snprintf(tmpBuf, PATH_MAX, "%s.so", module);
#endif
        if (strcmp(direntry->d_name, tmpBuf) == 0) {
            if (asprintf(&ret, "%s%s", dirpath, tmpBuf) == -1)
                ret = NULL;
            break;
        }
    }

    closedir(dir);
    return ret;
}

static char *
FindModule(const char *module, const char *dirname, const char **subdirlist,
           PatternPtr patterns)
{
    char buf[PATH_MAX + 1];
    char *name = NULL;
    const char **subdirs = NULL;
    const char **s;

    if (strlen(dirname) > PATH_MAX)
        return NULL;

    subdirs = InitSubdirs(subdirlist);
    if (!subdirs)
        return NULL;

    for (s = subdirs; *s; s++) {
        if ((strlen(dirname) + strlen(*s)) > PATH_MAX)
            continue;
        strcpy(buf, dirname);
        strcat(buf, *s);
        if ((name = FindModuleInSubdir(buf, module)))
            break;
    }

    FreeSubdirs(subdirs);

    return name;
}

const char **
LoaderListDirs(const char **subdirlist, const char **patternlist)
{
    char buf[PATH_MAX + 1];
    char **pathlist;
    char **elem;
    const char **subdirs;
    const char **s;
    PatternPtr patterns = NULL;
    PatternPtr p;
    DIR *d;
    struct dirent *dp;
    regmatch_t match[2];
    struct stat stat_buf;
    int len, dirlen;
    char *fp;
    char **listing = NULL;
    char **save;
    char **ret = NULL;
    int n = 0;

    if (!(pathlist = InitPathList(NULL)))
        return NULL;
    if (!(subdirs = InitSubdirs(subdirlist)))
        goto bail;
    if (!(patterns = InitPatterns(patternlist)))
        goto bail;

    for (elem = pathlist; *elem; elem++) {
        for (s = subdirs; *s; s++) {
            if ((dirlen = strlen(*elem) + strlen(*s)) > PATH_MAX)
                continue;
            strcpy(buf, *elem);
            strcat(buf, *s);
            fp = buf + dirlen;
            if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
                (d = opendir(buf))) {
                if (buf[dirlen - 1] != '/') {
                    buf[dirlen++] = '/';
                    fp++;
                }
                while ((dp = readdir(d))) {
                    if (dirlen + strlen(dp->d_name) > PATH_MAX)
                        continue;
                    strcpy(fp, dp->d_name);
                    if (!(stat(buf, &stat_buf) == 0 &&
                          S_ISREG(stat_buf.st_mode)))
                        continue;
                    for (p = patterns; p->pattern; p++) {
                        if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
                            match[1].rm_so != -1) {
                            len = match[1].rm_eo - match[1].rm_so;
                            save = listing;
                            listing = reallocarray(listing, n + 2,
                                                   sizeof(char *));
                            if (!listing) {
                                if (save) {
                                    save[n] = NULL;
                                    FreeStringList(save);
                                }
                                closedir(d);
                                goto bail;
                            }
                            listing[n] = malloc(len + 1);
                            if (!listing[n]) {
                                FreeStringList(listing);
                                closedir(d);
                                goto bail;
                            }
                            strncpy(listing[n], dp->d_name + match[1].rm_so,
                                    len);
                            listing[n][len] = '\0';
                            n++;
                            break;
                        }
                    }
                }
                closedir(d);
            }
        }
    }
    if (listing)
        listing[n] = NULL;
    ret = listing;

 bail:
    FreePatterns(patterns);
    FreeSubdirs(subdirs);
    FreePathList(pathlist);
    return (const char **) ret;
}

void
LoaderFreeDirList(char **list)
{
    FreeStringList(list);
}

static Bool
CheckVersion(const char *module, XF86ModuleVersionInfo * data,
             const XF86ModReqInfo * req)
{
    int vercode[4];
    long ver = data->xf86version;
    MessageType errtype;

    xf86Msg(X_INFO, "Module %s: vendor=\"%s\"\n",
            data->modname ? data->modname : "UNKNOWN!",
            data->vendor ? data->vendor : "UNKNOWN!");

    vercode[0] = ver / 10000000;
    vercode[1] = (ver / 100000) % 100;
    vercode[2] = (ver / 1000) % 100;
    vercode[3] = ver % 1000;
    xf86ErrorF("\tcompiled for %d.%d.%d", vercode[0], vercode[1], vercode[2]);
    if (vercode[3] != 0)
        xf86ErrorF(".%d", vercode[3]);
    xf86ErrorF(", module version = %d.%d.%d\n", data->majorversion,
               data->minorversion, data->patchlevel);

    if (data->moduleclass)
        xf86ErrorFVerb(2, "\tModule class: %s\n", data->moduleclass);

    ver = -1;
    if (data->abiclass) {
        int abimaj, abimin;
        int vermaj, vermin;

        if (!strcmp(data->abiclass, ABI_CLASS_ANSIC))
            ver = LoaderVersionInfo.ansicVersion;
        else if (!strcmp(data->abiclass, ABI_CLASS_VIDEODRV))
            ver = LoaderVersionInfo.videodrvVersion;
        else if (!strcmp(data->abiclass, ABI_CLASS_XINPUT))
            ver = LoaderVersionInfo.xinputVersion;
        else if (!strcmp(data->abiclass, ABI_CLASS_EXTENSION))
            ver = LoaderVersionInfo.extensionVersion;
        else if (!strcmp(data->abiclass, ABI_CLASS_FONT))
            ver = LoaderVersionInfo.fontVersion;

        abimaj = GET_ABI_MAJOR(data->abiversion);
        abimin = GET_ABI_MINOR(data->abiversion);
        xf86ErrorFVerb(2, "\tABI class: %s, version %d.%d\n",
                       data->abiclass, abimaj, abimin);
        if (ver != -1) {
            vermaj = GET_ABI_MAJOR(ver);
            vermin = GET_ABI_MINOR(ver);
            if (abimaj != vermaj) {
                if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
                    errtype = X_WARNING;
                else
                    errtype = X_ERROR;
                xf86MsgVerb(errtype, 0,
                            "module ABI major version (%d) doesn't"
                            " match the server's version (%d)\n",
                            abimaj, vermaj);
                if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
                    return FALSE;
            }
            else if (abimin > vermin) {
                if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
                    errtype = X_WARNING;
                else
                    errtype = X_ERROR;
                xf86MsgVerb(errtype, 0,
                            "module ABI minor version (%d) is "
                            "newer than the server's version "
                            "(%d)\n", abimin, vermin);
                if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
                    return FALSE;
            }
        }
    }

    /* Check against requirements that the caller has specified */
    if (req) {
        if (req->majorversion != MAJOR_UNSPEC) {
            if (data->majorversion != req->majorversion) {
                xf86MsgVerb(X_WARNING, 2, "module major version (%d) "
                            "doesn't match required major version (%d)\n",
                            data->majorversion, req->majorversion);
                return FALSE;
            }
            else if (req->minorversion != MINOR_UNSPEC) {
                if (data->minorversion < req->minorversion) {
                    xf86MsgVerb(X_WARNING, 2, "module minor version (%d) "
                                "is less than the required minor version (%d)\n",
                                data->minorversion, req->minorversion);
                    return FALSE;
                }
                else if (data->minorversion == req->minorversion &&
                         req->patchlevel != PATCH_UNSPEC) {
                    if (data->patchlevel < req->patchlevel) {
                        xf86MsgVerb(X_WARNING, 2, "module patch level (%d) "
                                    "is less than the required patch level (%d)\n",
                                    data->patchlevel, req->patchlevel);
                        return FALSE;
                    }
                }
            }
        }
        if (req->moduleclass) {
            if (!data->moduleclass ||
                strcmp(req->moduleclass, data->moduleclass)) {
                xf86MsgVerb(X_WARNING, 2, "Module class (%s) doesn't match "
                            "the required class (%s)\n",
                            data->moduleclass ? data->moduleclass : "<NONE>",
                            req->moduleclass);
                return FALSE;
            }
        }
        else if (req->abiclass != ABI_CLASS_NONE) {
            if (!data->abiclass || strcmp(req->abiclass, data->abiclass)) {
                xf86MsgVerb(X_WARNING, 2, "ABI class (%s) doesn't match the "
                            "required ABI class (%s)\n",
                            data->abiclass ? data->abiclass : "<NONE>",
                            req->abiclass);
                return FALSE;
            }
        }
        if ((req->abiclass != ABI_CLASS_NONE) &&
            req->abiversion != ABI_VERS_UNSPEC) {
            int reqmaj, reqmin, maj, min;

            reqmaj = GET_ABI_MAJOR(req->abiversion);
            reqmin = GET_ABI_MINOR(req->abiversion);
            maj = GET_ABI_MAJOR(data->abiversion);
            min = GET_ABI_MINOR(data->abiversion);
            if (maj != reqmaj) {
                xf86MsgVerb(X_WARNING, 2, "ABI major version (%d) doesn't "
                            "match the required ABI major version (%d)\n",
                            maj, reqmaj);
                return FALSE;
            }
            /* XXX Maybe this should be the other way around? */
            if (min > reqmin) {
                xf86MsgVerb(X_WARNING, 2, "module ABI minor version (%d) "
                            "is newer than that available (%d)\n", min, reqmin);
                return FALSE;
            }
        }
    }
    return TRUE;
}

static ModuleDescPtr
AddSibling(ModuleDescPtr head, ModuleDescPtr new)
{
    new->sib = head;
    return new;
}

void *
LoadSubModule(void *_parent, const char *module,
              const char **subdirlist, const char **patternlist,
              void *options, const XF86ModReqInfo * modreq,
              int *errmaj, int *errmin)
{
    ModuleDescPtr submod;
    ModuleDescPtr parent = (ModuleDescPtr) _parent;

    xf86MsgVerb(X_INFO, 3, "Loading sub module \"%s\"\n", module);

    if (PathIsAbsolute(module)) {
        xf86Msg(X_ERROR,
                "LoadSubModule: Absolute module path not permitted: \"%s\"\n",
                module);
        if (errmaj)
            *errmaj = LDR_BADUSAGE;
        if (errmin)
            *errmin = 0;
        return NULL;
    }

    submod = LoadModule(module, NULL, subdirlist, patternlist, options,
                        modreq, errmaj, errmin);
    if (submod && submod != (ModuleDescPtr) 1) {
        parent->child = AddSibling(parent->child, submod);
        submod->parent = parent;
    }
    return submod;
}

static ModuleDescPtr
NewModuleDesc(const char *name)
{
    ModuleDescPtr mdp = calloc(1, sizeof(ModuleDesc));

    if (mdp)
        mdp->name = xstrdup(name);

    return mdp;
}

ModuleDescPtr
DuplicateModule(ModuleDescPtr mod, ModuleDescPtr parent)
{
    ModuleDescPtr ret;

    if (!mod)
        return NULL;

    ret = NewModuleDesc(mod->name);
    if (ret == NULL)
        return NULL;

    ret->handle = mod->handle;

    ret->SetupProc = mod->SetupProc;
    ret->TearDownProc = mod->TearDownProc;
    ret->TearDownData = ModuleDuplicated;
    ret->child = DuplicateModule(mod->child, ret);
    ret->sib = DuplicateModule(mod->sib, parent);
    ret->parent = parent;
    ret->VersionInfo = mod->VersionInfo;
    ret->path = strdup(mod->path);

    return ret;
}

static const char *compiled_in_modules[] = {
    "ddc",
    "i2c",
    "ramdac",
    "dbe",
    "record",
    "extmod",
    "dri",
    "dri2",
#if DRI3
    "dri3",
#endif
#if PRESENT
    "present",
#endif
    NULL
};

/*
 * LoadModule: load a module
 *
 * module       The module name.  Normally this is not a filename but the
 *              module's "canonical name.  A full pathname is, however,
 *              also accepted.
 * path         A comma separated list of module directories.
 * subdirlist   A NULL terminated list of subdirectories to search.  When
 *              NULL, the default "stdSubdirs" list is used.  The default
 *              list is also substituted for entries with value DEFAULT_LIST.
 * patternlist  A NULL terminated list of regular expressions used to find
 *              module filenames.  Each regex should contain exactly one
 *              subexpression that corresponds to the canonical module name.
 *              When NULL, the default "stdPatterns" list is used.  The
 *              default list is also substituted for entries with value
 *              DEFAULT_LIST.
 * options      A NULL terminated list of Options that are passed to the
 *              module's SetupProc function.
 * modreq       An optional XF86ModReqInfo* containing
 *              version/ABI/vendor-ABI requirements to check for when
 *              loading the module.  The following fields of the
 *              XF86ModReqInfo struct are checked:
 *                majorversion - must match the module's majorversion exactly
 *                minorversion - the module's minorversion must be >= this
 *                patchlevel   - the module's minorversion.patchlevel must be
 *                               >= this.  Patchlevel is ignored when
 *                               minorversion is not set.
 *                abiclass     - (string) must match the module's abiclass
 *                abiversion   - must be consistent with the module's
 *                               abiversion (major equal, minor no older)
 *                moduleclass  - string must match the module's moduleclass
 *                               string
 *              "don't care" values are ~0 for numbers, and NULL for strings
 * errmaj       Major error return.
 * errmin       Minor error return.
 *
 */
ModuleDescPtr
LoadModule(const char *module, const char *path, const char **subdirlist,
           const char **patternlist, void *options,
           const XF86ModReqInfo * modreq, int *errmaj, int *errmin)
{
    XF86ModuleData *initdata = NULL;
    char **pathlist = NULL;
    char *found = NULL;
    char *name = NULL;
    char **path_elem = NULL;
    char *p = NULL;
    ModuleDescPtr ret = NULL;
    PatternPtr patterns = NULL;
    int noncanonical = 0;
    char *m = NULL;
    const char **cim;

    xf86MsgVerb(X_INFO, 3, "LoadModule: \"%s\"", module);

    patterns = InitPatterns(patternlist);
    name = LoaderGetCanonicalName(module, patterns);
    noncanonical = (name && strcmp(module, name) != 0);
    if (noncanonical) {
        xf86ErrorFVerb(3, " (%s)\n", name);
        xf86MsgVerb(X_WARNING, 1,
                    "LoadModule: given non-canonical module name \"%s\"\n",
                    module);
        m = name;
    }
    else {
        xf86ErrorFVerb(3, "\n");
        m = (char *) module;
    }

    for (cim = compiled_in_modules; *cim; cim++)
        if (!strcmp(m, *cim)) {
            xf86MsgVerb(X_INFO, 3, "Module \"%s\" already built-in\n", m);
            ret = (ModuleDescPtr) 1;
            goto LoadModule_exit;
        }

    if (!name) {
        if (errmaj)
            *errmaj = LDR_BADUSAGE;
        if (errmin)
            *errmin = 0;
        goto LoadModule_fail;
    }
    ret = NewModuleDesc(name);
    if (!ret) {
        if (errmaj)
            *errmaj = LDR_NOMEM;
        if (errmin)
            *errmin = 0;
        goto LoadModule_fail;
    }

    pathlist = InitPathList(path);
    if (!pathlist) {
        /* This could be a malloc failure too */
        if (errmaj)
            *errmaj = LDR_BADUSAGE;
        if (errmin)
            *errmin = 1;
        goto LoadModule_fail;
    }

    /*
     * if the module name is not a full pathname, we need to
     * check the elements in the path
     */
    if (PathIsAbsolute(module))
        found = xstrdup(module);
    path_elem = pathlist;
    while (!found && *path_elem != NULL) {
        found = FindModule(m, *path_elem, subdirlist, patterns);
        path_elem++;
        /*
         * When the module name isn't the canonical name, search for the
         * former if no match was found for the latter.
         */
        if (!*path_elem && m == name) {
            path_elem = pathlist;
            m = (char *) module;
        }
    }

    /*
     * did we find the module?
     */
    if (!found) {
        xf86Msg(X_WARNING, "Warning, couldn't open module %s\n", module);
        if (errmaj)
            *errmaj = LDR_NOENT;
        if (errmin)
            *errmin = 0;
        goto LoadModule_fail;
    }
    ret->handle = LoaderOpen(found, errmaj, errmin);
    if (ret->handle == NULL)
        goto LoadModule_fail;
    ret->path = strdup(found);

    /* drop any explicit suffix from the module name */
    p = strchr(name, '.');
    if (p)
        *p = '\0';

    /*
     * now check if the special data object <modulename>ModuleData is
     * present.
     */
    if (asprintf(&p, "%sModuleData", name) == -1) {
        p = NULL;
        if (errmaj)
            *errmaj = LDR_NOMEM;
        if (errmin)
            *errmin = 0;
        goto LoadModule_fail;
    }
    initdata = LoaderSymbolFromModule(ret->handle, p);
    if (initdata) {
        ModuleSetupProc setup;
        ModuleTearDownProc teardown;
        XF86ModuleVersionInfo *vers;

        vers = initdata->vers;
        setup = initdata->setup;
        teardown = initdata->teardown;

        if (vers) {
            if (!CheckVersion(module, vers, modreq)) {
                if (errmaj)
                    *errmaj = LDR_MISMATCH;
                if (errmin)
                    *errmin = 0;
                goto LoadModule_fail;
            }
        }
        else {
            xf86Msg(X_ERROR,
                    "LoadModule: Module %s does not supply"
                    " version information\n", module);
            if (errmaj)
                *errmaj = LDR_INVALID;
            if (errmin)
                *errmin = 0;
            goto LoadModule_fail;
        }
        if (setup)
            ret->SetupProc = setup;
        if (teardown)
            ret->TearDownProc = teardown;
        ret->VersionInfo = vers;
    }
    else {
        /* no initdata, fail the load */
        xf86Msg(X_ERROR, "LoadModule: Module %s does not have a %s "
                "data object.\n", module, p);
        if (errmaj)
            *errmaj = LDR_INVALID;
        if (errmin)
            *errmin = 0;
        goto LoadModule_fail;
    }
    if (ret->SetupProc) {
        ret->TearDownData = ret->SetupProc(ret, options, errmaj, errmin);
        if (!ret->TearDownData) {
            goto LoadModule_fail;
        }
    }
    else if (options) {
        xf86Msg(X_WARNING, "Module Options present, but no SetupProc "
                "available for %s\n", module);
    }
    goto LoadModule_exit;

 LoadModule_fail:
    UnloadModule(ret);
    ret = NULL;

 LoadModule_exit:
    FreePathList(pathlist);
    FreePatterns(patterns);
    free(found);
    free(name);
    free(p);

    return ret;
}

void
UnloadModule(void *_mod)
{
    ModuleDescPtr mod = _mod;

    if (mod == (ModuleDescPtr) 1)
        return;

    if (mod == NULL || mod->name == NULL)
        return;

    if (mod->parent)
        LogMessageVerbSigSafe(X_INFO, 3, "UnloadSubModule: \"%s\"\n",
                              mod->name);
    else
        LogMessageVerbSigSafe(X_INFO, 3, "UnloadModule: \"%s\"\n", mod->name);

    if (mod->TearDownData != ModuleDuplicated) {
        if ((mod->TearDownProc) && (mod->TearDownData))
            mod->TearDownProc(mod->TearDownData);
        LoaderUnload(mod->name, mod->handle);
    }

    if (mod->child)
        UnloadModule(mod->child);
    if (mod->sib)
        UnloadModule(mod->sib);
    free(mod->path);
    free(mod->name);
    free(mod);
}

void
UnloadSubModule(void *_mod)
{
    ModuleDescPtr mod = (ModuleDescPtr) _mod;

    /* Some drivers are calling us on built-in submodules, ignore them */
    if (mod == (ModuleDescPtr) 1)
        return;
    RemoveChild(mod);
    UnloadModule(mod);
}

static void
RemoveChild(ModuleDescPtr child)
{
    ModuleDescPtr mdp;
    ModuleDescPtr prevsib;
    ModuleDescPtr parent;

    if (!child->parent)
        return;

    parent = child->parent;
    if (parent->child == child) {
        parent->child = child->sib;
        return;
    }

    prevsib = parent->child;
    mdp = prevsib->sib;
    while (mdp && mdp != child) {
        prevsib = mdp;
        mdp = mdp->sib;
    }
    if (mdp == child)
        prevsib->sib = child->sib;
    child->sib = NULL;
    return;
}

void
LoaderErrorMsg(const char *name, const char *modname, int errmaj, int errmin)
{
    const char *msg;
    MessageType type = X_ERROR;

    switch (errmaj) {
    case LDR_NOERROR:
        msg = "no error";
        break;
    case LDR_NOMEM:
        msg = "out of memory";
        break;
    case LDR_NOENT:
        msg = "module does not exist";
        break;
    case LDR_NOSUBENT:
        msg = "a required submodule could not be loaded";
        break;
    case LDR_NOSPACE:
        msg = "too many modules";
        break;
    case LDR_NOMODOPEN:
        msg = "open failed";
        break;
    case LDR_UNKTYPE:
        msg = "unknown module type";
        break;
    case LDR_NOLOAD:
        msg = "loader failed";
        break;
    case LDR_ONCEONLY:
        msg = "already loaded";
        type = X_INFO;
        break;
    case LDR_NOPORTOPEN:
        msg = "port open failed";
        break;
    case LDR_NOHARDWARE:
        msg = "no hardware found";
        break;
    case LDR_MISMATCH:
        msg = "module requirement mismatch";
        break;
    case LDR_BADUSAGE:
        msg = "invalid argument(s) to LoadModule()";
        break;
    case LDR_INVALID:
        msg = "invalid module";
        break;
    case LDR_BADOS:
        msg = "module doesn't support this OS";
        break;
    case LDR_MODSPECIFIC:
        msg = "module-specific error";
        break;
    default:
        msg = "unknown error";
    }
    if (name)
        xf86Msg(type, "%s: Failed to load module \"%s\" (%s, %d)\n",
                name, modname, msg, errmin);
    else
        xf86Msg(type, "Failed to load module \"%s\" (%s, %d)\n",
                modname, msg, errmin);
}

/* Given a module path or file name, return the module's canonical name */
static char *
LoaderGetCanonicalName(const char *modname, PatternPtr patterns)
{
    char *str;
    const char *s;
    int len;
    PatternPtr p;
    regmatch_t match[2];

    /* Strip off any leading path */
    s = strrchr(modname, '/');
    if (s == NULL)
        s = modname;
    else
        s++;

    /* Find the first regex that is matched */
    for (p = patterns; p->pattern; p++)
        if (regexec(&p->rex, s, 2, match, 0) == 0 && match[1].rm_so != -1) {
            len = match[1].rm_eo - match[1].rm_so;
            str = malloc(len + 1);
            if (!str)
                return NULL;
            strncpy(str, s + match[1].rm_so, len);
            str[len] = '\0';
            return str;
        }

    /* If there is no match, return the whole name minus the leading path */
    return strdup(s);
}

/*
 * Return the module version information.
 */
unsigned long
LoaderGetModuleVersion(ModuleDescPtr mod)
{
    if (!mod || mod == (ModuleDescPtr) 1 || !mod->VersionInfo)
        return 0;

    return MODULE_VERSION_NUMERIC(mod->VersionInfo->majorversion,
                                  mod->VersionInfo->minorversion,
                                  mod->VersionInfo->patchlevel);
}
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d145 1
a145 1
            list = realloc(list, (n + 2) * sizeof(char *));
d247 1
a247 1
        patterns = malloc((i + 1) * sizeof(PatternRec));
d326 1
a326 1
        subdirs = malloc((i * 2 + 1) * sizeof(char *));
d533 2
a534 2
                            listing = realloc(listing,
                                              (n + 2) * sizeof(char *));
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a79 1
static void UnloadModuleOrDriver(ModuleDescPtr mod);
a81 3
static ModuleDescPtr doLoadModule(const char *, const char *, const char **,
                                  const char **, void *,
                                  const XF86ModReqInfo *, int *, int *);
a195 1
    "multimedia/",
a582 1
    char verstr[4];
d590 9
a598 36
    /* Check for the different scheme used in XFree86 4.0.x releases:
     * ((((((((major << 7) | minor) << 7) | subminor) << 5) | beta) << 5) | alpha)
     * Since it wasn't used in 4.1.0 or later, limit to versions in the 4.0.x
     * range, which limits the overlap with the new version scheme to conflicts
     * with 6.71.8.764 through 6.72.39.934.
     */
    if ((ver > (4 << 24)) && (ver < ((4 << 24) + (1 << 17)))) {
        /* 4.0.x and earlier */
        verstr[1] = verstr[3] = 0;
        verstr[2] = (ver & 0x1f) ? (ver & 0x1f) + 'a' - 1 : 0;
        ver >>= 5;
        verstr[0] = (ver & 0x1f) ? (ver & 0x1f) + 'A' - 1 : 0;
        ver >>= 5;
        vercode[2] = ver & 0x7f;
        ver >>= 7;
        vercode[1] = ver & 0x7f;
        ver >>= 7;
        vercode[0] = ver;
        xf86ErrorF("\tcompiled for %d.%d", vercode[0], vercode[1]);
        if (vercode[2] != 0)
            xf86ErrorF(".%d", vercode[2]);
        xf86ErrorF("%s%s, module version = %d.%d.%d\n", verstr, verstr + 2,
                   data->majorversion, data->minorversion, data->patchlevel);
    }
    else {
        vercode[0] = ver / 10000000;
        vercode[1] = (ver / 100000) % 100;
        vercode[2] = (ver / 1000) % 100;
        vercode[3] = ver % 1000;
        xf86ErrorF("\tcompiled for %d.%d.%d", vercode[0], vercode[1],
                   vercode[2]);
        if (vercode[3] != 0)
            xf86ErrorF(".%d", vercode[3]);
        xf86ErrorF(", module version = %d.%d.%d\n", data->majorversion,
                   data->minorversion, data->patchlevel);
    }
d753 2
a754 2
    submod = doLoadModule(module, NULL, subdirlist, patternlist, options,
                          modreq, errmaj, errmin);
d817 41
a857 4
static ModuleDescPtr
doLoadModule(const char *module, const char *path, const char **subdirlist,
             const char **patternlist, void *options,
             const XF86ModReqInfo * modreq, int *errmaj, int *errmin)
d921 1
a921 1
    /* 
d941 1
a941 1
    /* 
a1044 46
/*
 * LoadModule: load a module
 *
 * module       The module name.  Normally this is not a filename but the
 *              module's "canonical name.  A full pathname is, however,
 *              also accepted.
 * path         A comma separated list of module directories.
 * subdirlist   A NULL terminated list of subdirectories to search.  When
 *              NULL, the default "stdSubdirs" list is used.  The default
 *              list is also substituted for entries with value DEFAULT_LIST.
 * patternlist  A NULL terminated list of regular expressions used to find
 *              module filenames.  Each regex should contain exactly one
 *              subexpression that corresponds to the canonical module name.
 *              When NULL, the default "stdPatterns" list is used.  The
 *              default list is also substituted for entries with value
 *              DEFAULT_LIST.
 * options      A NULL terminated list of Options that are passed to the
 *              module's SetupProc function.
 * modreq       An optional XF86ModReqInfo* containing
 *              version/ABI/vendor-ABI requirements to check for when
 *              loading the module.  The following fields of the
 *              XF86ModReqInfo struct are checked:
 *                majorversion - must match the module's majorversion exactly
 *                minorversion - the module's minorversion must be >= this
 *                patchlevel   - the module's minorversion.patchlevel must be
 *                               >= this.  Patchlevel is ignored when
 *                               minorversion is not set.
 *                abiclass     - (string) must match the module's abiclass
 *                abiversion   - must be consistent with the module's
 *                               abiversion (major equal, minor no older)
 *                moduleclass  - string must match the module's moduleclass
 *                               string
 *              "don't care" values are ~0 for numbers, and NULL for strings
 * errmaj       Major error return.
 * errmin       Minor error return.
 *
 */
ModuleDescPtr
LoadModule(const char *module, const char *path, const char **subdirlist,
           const char **patternlist, void *options,
           const XF86ModReqInfo * modreq, int *errmaj, int *errmin)
{
    return doLoadModule(module, path, subdirlist, patternlist, options,
                        modreq, errmaj, errmin);
}

d1046 1
a1046 1
UnloadModule(void *mod)
d1048 1
a1048 2
    UnloadModuleOrDriver((ModuleDescPtr) mod);
}
a1049 3
static void
UnloadModuleOrDriver(ModuleDescPtr mod)
{
d1069 1
a1069 1
        UnloadModuleOrDriver(mod->child);
d1071 1
a1071 1
        UnloadModuleOrDriver(mod->sib);
d1086 1
a1086 1
    UnloadModuleOrDriver(mod);
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d84 1
a84 1
                                  const char **, pointer,
d485 1
a485 1
char **
d493 1
a493 1
    PatternPtr patterns;
d574 1
a574 1
    return ret;
d764 2
a765 2
pointer
LoadSubModule(pointer _parent, const char *module,
d767 1
a767 1
              pointer options, const XF86ModReqInfo * modreq,
d841 6
d852 1
a852 1
             const char **patternlist, pointer options,
d1080 1
a1080 1
           const char **patternlist, pointer options,
d1088 1
a1088 1
UnloadModule(pointer mod)
d1124 1
a1124 1
UnloadSubModule(pointer _mod)
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d215 5
d223 1
d417 3
d421 1
d428 3
d432 1
d439 3
d443 1
d836 5
d964 1
a964 1
    initdata = LoaderSymbol(p);
a999 4
        /* No initdata is OK for external modules */
        if (options == EXTERN_MODULE)
            goto LoadModule_exit;

d1097 2
a1098 1
        xf86MsgVerb(X_INFO, 3, "UnloadSubModule: \"%s\"\n", mod->name);
d1100 1
a1100 1
        xf86MsgVerb(X_INFO, 3, "UnloadModule: \"%s\"\n", mod->name);
@


1.7
log
@Bugfix Update to xserver 1.11.3
@
text
@d77 1
a77 2
static char *FindModule(const char *, const char *, const char **,
			PatternPtr);
d79 1
a79 1
			 const XF86ModReqInfo *);
d84 2
a85 2
				  const char **, pointer,
				  const XF86ModReqInfo *, int *, int *);
d96 2
d104 1
a104 1
	return;
d107 1
a107 1
	free(*p);
d118 1
a118 1
}	
d136 1
a136 1
	return defaultPathList;
d140 1
a140 1
	return NULL;
d143 29
a171 30
	if (PathIsAbsolute(elem))
	{
	    len = strlen(elem);
	    addslash = (elem[len - 1] != '/');
	    if (addslash)
		len++;
	    save = list;
	    list = realloc(list, (n + 2) * sizeof(char *));
	    if (!list) {
		if (save) {
		    save[n] = NULL;
		    FreeStringList(save);
		}
		free(fullpath);
		return NULL;
	    }
	    list[n] = malloc(len + 1);
	    if (!list[n]) {
		FreeStringList(list);
		free(fullpath);
		return NULL;
	    }
	    strcpy(list[n], elem);
	    if (addslash) {
		list[n][len - 1] = '/';
		list[n][len] = '\0';
	    }
	    n++;
	}
	elem = strtok(NULL, ",");
d174 1
a174 1
	list[n] = NULL;
d183 1
a183 1
	FreeStringList(pathlist);
d190 1
a190 1
	return;
d232 8
a239 8
	/* precompile stdPatterns */
	firstTime = 0;
	for (p = stdPatterns; p->pattern; p++)
	    if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
		regerror(e, &p->rex, errmsg, sizeof(errmsg));
		FatalError("InitPatterns: regcomp error for `%s': %s\n",
			   p->pattern, errmsg);
	    }
d243 28
a270 26
	for (i = 0, s = patternlist; *s; i++, s++)
	    if (*s == DEFAULT_LIST)
		i += sizeof(stdPatterns) / sizeof(stdPatterns[0]) - 1 - 1;
	patterns = malloc((i + 1) * sizeof(PatternRec));
	if (!patterns) {
	    return NULL;
	}
	for (i = 0, s = patternlist; *s; i++, s++)
	    if (*s != DEFAULT_LIST) {
		p = patterns + i;
		p->pattern = *s;
		if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
		    regerror(e, &p->rex, errmsg, sizeof(errmsg));
		    ErrorF("InitPatterns: regcomp error for `%s': %s\n",
			   p->pattern, errmsg);
		    i--;
		}
	    } else {
		for (p = stdPatterns; p->pattern; p++, i++)
		    patterns[i] = *p;
		if (p != stdPatterns)
		    i--;
	    }
	patterns[i].pattern = NULL;
    } else
	patterns = stdPatterns;
d278 1
a278 1
	free(patterns);
d294 5
a298 5
	subdirlist = tmp_subdirlist = malloc(2 * sizeof(char *));
	if (subdirlist == NULL)
	    return NULL;
	subdirlist[0] = DEFAULT_LIST;
	subdirlist[1] = NULL;
d305 64
a368 62
	/* Count number of entries and check for invalid paths */
	for (i = 0, s = subdirlist; *s; i++, s++) {
	    if (*s == DEFAULT_LIST) {
		i += sizeof(stdSubdirs) / sizeof(stdSubdirs[0]) - 1 - 1;
	    } else {
		/*
		 * Path validity check.  Don't allow absolute paths, or
		 * paths containing "..".  To catch absolute paths on
		 * platforms that use driver letters, don't allow the ':'
		 * character to appear at all.
		 */
		if (**s == '/' || **s == '\\' || strchr(*s, ':') ||
		    strstr(*s, "..")) {
		    xf86Msg(X_ERROR, "InitSubdirs: Bad subdir: \"%s\"\n", *s);
		    free(tmp_subdirlist);
		    return NULL;
		}
	    }
	}
	subdirs = malloc((i * 2 + 1) * sizeof(char *));
	if (!subdirs) {
	    free(tmp_subdirlist);
	    return NULL;
	}
	i = 0;
	s = subdirlist;
	indefault = FALSE;
	while (*s) {
	    if (*s == DEFAULT_LIST) {
		/* Divert to the default list */
		indefault = TRUE;
		stmp = ++s;
		s = stdSubdirs;
	    }
	    len = strlen(*s);
	    if (**s && (*s)[len - 1] != '/') {
		slash = "/";
		len++;
	    } else
		slash = "";
	    len += oslen + 2;
	    if (!(subdirs[i] = malloc(len))) {
		while (--i >= 0)
		    free(subdirs[i]);
		free(subdirs);
		free(tmp_subdirlist);
		return NULL;
	    }
	    /* tack on the OS name */
	    sprintf(subdirs[i], "%s%s%s/", *s, slash, osname);
	    i++;
	    /* path as given */
	    subdirs[i] = strdup(*s);
	    i++;
	    s++;
	    if (indefault && !s) {
		/* revert back to the main list */
		indefault = FALSE;
		s = stmp;
	    }
	}
	subdirs[i] = NULL;
d371 1
a371 1
    return (const char **)subdirs;
d380 3
a382 3
	for (s = subdirs; *s; s++)
	    free((char *)*s);
	free(subdirs);
d402 3
a404 3
	/* the stat with the appended / fails for normal files,
	   and works for sub dirs fine, looks a bit strange in strace
	   but does seem to work */
d410 1
a410 1
 
d414 1
a414 1
		ret = NULL;
d421 1
a421 1
		ret = NULL;
d428 1
a428 1
		ret = NULL;
d432 1
a432 1
    
d439 1
a439 1
	   PatternPtr patterns)
a441 1
    char *dirpath = NULL;
a442 1
    int dirlen;
d446 3
a448 4
    dirpath = (char *)dirname;
    if (strlen(dirpath) > PATH_MAX)
	return NULL;
    
d451 1
a451 1
	return NULL;
d454 4
a457 4
	if ((dirlen = strlen(dirpath) + strlen(*s)) > PATH_MAX)
	    continue;
	strcpy(buf, dirpath);
	strcat(buf, *s);
a462 2
    if (dirpath != dirname)
	free(dirpath);
d489 1
a489 1
	return NULL;
d491 1
a491 1
	goto bail;
d493 1
a493 1
	goto bail;
d496 51
a546 51
	for (s = subdirs; *s; s++) {
	    if ((dirlen = strlen(*elem) + strlen(*s)) > PATH_MAX)
		continue;
	    strcpy(buf, *elem);
	    strcat(buf, *s);
	    fp = buf + dirlen;
	    if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
		(d = opendir(buf))) {
		if (buf[dirlen - 1] != '/') {
		    buf[dirlen++] = '/';
		    fp++;
		}
		while ((dp = readdir(d))) {
		    if (dirlen + strlen(dp->d_name) > PATH_MAX)
			continue;
		    strcpy(fp, dp->d_name);
		    if (!(stat(buf, &stat_buf) == 0 &&
			  S_ISREG(stat_buf.st_mode)))
			continue;
		    for (p = patterns; p->pattern; p++) {
			if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
			    match[1].rm_so != -1) {
			    len = match[1].rm_eo - match[1].rm_so;
			    save = listing;
			    listing = realloc(listing,
					       (n + 2) * sizeof(char *));
			    if (!listing) {
				if (save) {
				    save[n] = NULL;
				    FreeStringList(save);
				}
				closedir(d);
				goto bail;
			    }
			    listing[n] = malloc(len + 1);
			    if (!listing[n]) {
				FreeStringList(listing);
				closedir(d);
				goto bail;
			    }
			    strncpy(listing[n], dp->d_name + match[1].rm_so,
				    len);
			    listing[n][len] = '\0';
			    n++;
			    break;
			}
		    }
		}
		closedir(d);
	    }
	}
d549 1
a549 1
	listing[n] = NULL;
d552 1
a552 1
bail:
d567 1
a567 1
	     const XF86ModReqInfo * req)
d575 2
a576 2
	    data->modname ? data->modname : "UNKNOWN!",
	    data->vendor ? data->vendor : "UNKNOWN!");
d584 29
a612 28
    if ((ver > (4 << 24)) && (ver < ( (4 << 24) + (1 << 17)))) {
	/* 4.0.x and earlier */
	verstr[1] = verstr[3] = 0;
	verstr[2] = (ver & 0x1f) ? (ver & 0x1f) + 'a' - 1 : 0;
	ver >>= 5;
	verstr[0] = (ver & 0x1f) ? (ver & 0x1f) + 'A' - 1 : 0;
	ver >>= 5;
	vercode[2] = ver & 0x7f;
	ver >>= 7;
	vercode[1] = ver & 0x7f;
	ver >>= 7;
	vercode[0] = ver;
	xf86ErrorF("\tcompiled for %d.%d", vercode[0], vercode[1]);
	if (vercode[2] != 0)
	    xf86ErrorF(".%d", vercode[2]);
	xf86ErrorF("%s%s, module version = %d.%d.%d\n", verstr, verstr + 2,
		   data->majorversion, data->minorversion, data->patchlevel);
    } else {
	vercode[0] = ver / 10000000;
	vercode[1] = (ver / 100000) % 100;
	vercode[2] = (ver / 1000) % 100;
	vercode[3] = ver % 1000;
	xf86ErrorF("\tcompiled for %d.%d.%d", vercode[0], vercode[1],
		   vercode[2]);
	if (vercode[3] != 0)
	    xf86ErrorF(".%d", vercode[3]);
	xf86ErrorF(", module version = %d.%d.%d\n", data->majorversion,
		   data->minorversion, data->patchlevel);
d616 1
a616 1
	xf86ErrorFVerb(2, "\tModule class: %s\n", data->moduleclass);
d620 2
a621 2
	int abimaj, abimin;
	int vermaj, vermin;
d623 43
a665 42
	if (!strcmp(data->abiclass, ABI_CLASS_ANSIC))
	    ver = LoaderVersionInfo.ansicVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_VIDEODRV))
	    ver = LoaderVersionInfo.videodrvVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_XINPUT))
	    ver = LoaderVersionInfo.xinputVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_EXTENSION))
	    ver = LoaderVersionInfo.extensionVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_FONT))
	    ver = LoaderVersionInfo.fontVersion;

	abimaj = GET_ABI_MAJOR(data->abiversion);
	abimin = GET_ABI_MINOR(data->abiversion);
	xf86ErrorFVerb(2, "\tABI class: %s, version %d.%d\n",
		       data->abiclass, abimaj, abimin);
	if (ver != -1) {
	    vermaj = GET_ABI_MAJOR(ver);
	    vermin = GET_ABI_MINOR(ver);
	    if (abimaj != vermaj) {
		if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
		    errtype = X_WARNING;
		else
		    errtype = X_ERROR;
		xf86MsgVerb(errtype, 0,
			    "module ABI major version (%d) doesn't"
			    " match the server's version (%d)\n",
			    abimaj, vermaj);
		if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
		    return FALSE;
	    } else if (abimin > vermin) {
		if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
		    errtype = X_WARNING;
		else
		    errtype = X_ERROR;
		xf86MsgVerb(errtype, 0,
			    "module ABI minor version (%d) is "
			    "newer than the server's version "
			    "(%d)\n", abimin, vermin);
		if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
		    return FALSE;
	    }
	}
d670 65
a734 62
	if (req->majorversion != MAJOR_UNSPEC) {
	    if (data->majorversion != req->majorversion) {
		xf86MsgVerb(X_WARNING, 2, "module major version (%d) "
			    "doesn't match required major version (%d)\n",
			    data->majorversion, req->majorversion);
		return FALSE;
	    } else if (req->minorversion != MINOR_UNSPEC) {
		if (data->minorversion < req->minorversion) {
		    xf86MsgVerb(X_WARNING, 2, "module minor version (%d) "
				"is less than the required minor version (%d)\n",
				data->minorversion, req->minorversion);
		    return FALSE;
		} else if (data->minorversion == req->minorversion &&
			   req->patchlevel != PATCH_UNSPEC) {
		    if (data->patchlevel < req->patchlevel) {
			xf86MsgVerb(X_WARNING, 2, "module patch level (%d) "
				    "is less than the required patch level (%d)\n",
				    data->patchlevel, req->patchlevel);
			return FALSE;
		    }
		}
	    }
	}
	if (req->moduleclass) {
	    if (!data->moduleclass ||
		strcmp(req->moduleclass, data->moduleclass)) {
		xf86MsgVerb(X_WARNING, 2, "Module class (%s) doesn't match "
			    "the required class (%s)\n",
			    data->moduleclass ? data->moduleclass : "<NONE>",
			    req->moduleclass);
		return FALSE;
	    }
	} else if (req->abiclass != ABI_CLASS_NONE) {
	    if (!data->abiclass || strcmp(req->abiclass, data->abiclass)) {
		xf86MsgVerb(X_WARNING, 2, "ABI class (%s) doesn't match the "
			    "required ABI class (%s)\n",
			    data->abiclass ? data->abiclass : "<NONE>",
			    req->abiclass);
		return FALSE;
	    }
	}
	if ((req->abiclass != ABI_CLASS_NONE) &&
	    req->abiversion != ABI_VERS_UNSPEC) {
	    int reqmaj, reqmin, maj, min;

	    reqmaj = GET_ABI_MAJOR(req->abiversion);
	    reqmin = GET_ABI_MINOR(req->abiversion);
	    maj = GET_ABI_MAJOR(data->abiversion);
	    min = GET_ABI_MINOR(data->abiversion);
	    if (maj != reqmaj) {
		xf86MsgVerb(X_WARNING, 2, "ABI major version (%d) doesn't "
			    "match the required ABI major version (%d)\n",
			    maj, reqmaj);
		return FALSE;
	    }
	    /* XXX Maybe this should be the other way around? */
	    if (min > reqmin) {
		xf86MsgVerb(X_WARNING, 2, "module ABI minor version (%d) "
			    "is newer than that available (%d)\n", min, reqmin);
		return FALSE;
	    }
	}
d748 3
a750 3
	      const char **subdirlist, const char **patternlist,
	      pointer options, const XF86ModReqInfo * modreq,
	      int *errmaj, int *errmin)
d753 1
a753 1
    ModuleDescPtr parent = (ModuleDescPtr)_parent;
d758 8
a765 8
	xf86Msg(X_ERROR,
		"LoadSubModule: Absolute module path not permitted: \"%s\"\n",
		module);
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 0;
	return NULL;
d769 1
a769 1
			  modreq, errmaj, errmin);
d771 2
a772 2
	parent->child = AddSibling(parent->child, submod);
	submod->parent = parent;
d783 1
a783 1
	mdp->name = xstrdup(name);
a791 1
    int errmaj, errmin;
d794 1
a794 1
	return NULL;
d798 1
a798 1
	return NULL;
d800 1
a800 4
    if (!(ret->handle = LoaderOpen(mod->path, &errmaj, &errmin))) {
        free(ret);
        return NULL;
    }
d804 1
a804 1
    ret->TearDownData = NULL;
d823 2
a824 3
	     const char **patternlist, pointer options,
	     const XF86ModReqInfo * modreq,
	     int *errmaj, int *errmin)
d844 9
a852 8
	xf86ErrorFVerb(3, " (%s)\n", name);
	xf86MsgVerb(X_WARNING, 1,
		    "LoadModule: given non-canonical module name \"%s\"\n",
		    module);
	m = name;
    } else {
	xf86ErrorFVerb(3, "\n");
	m = (char *)module;
d856 5
a860 6
	if (!strcmp (m, *cim))
	{
	    xf86MsgVerb(X_INFO, 3, "Module \"%s\" already built-in\n", m);
	    ret = (ModuleDescPtr) 1;
	    goto LoadModule_exit;
	}
d863 5
a867 5
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
d871 5
a875 5
	if (errmaj)
	    *errmaj = LDR_NOMEM;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
d880 6
a885 6
	/* This could be a malloc failure too */
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 1;
	goto LoadModule_fail;
d893 1
a893 1
	found = xstrdup(module);
d896 10
a905 10
	found = FindModule(m, *path_elem, subdirlist, patterns);
	path_elem++;
	/*
	 * When the module name isn't the canonical name, search for the
	 * former if no match was found for the latter.
	 */
	if (!*path_elem && m == name) {
	    path_elem = pathlist;
	    m = (char *)module;
	}
d912 6
a917 6
	xf86Msg(X_WARNING, "Warning, couldn't open module %s\n", module);
	if (errmaj)
	    *errmaj = LDR_NOENT;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
d921 1
a921 1
	goto LoadModule_fail;
d934 6
a939 6
	p = NULL;
	if (errmaj)
	    *errmaj = LDR_NOMEM;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
d943 7
a949 7
	ModuleSetupProc setup;
	ModuleTearDownProc teardown;
	XF86ModuleVersionInfo *vers;

	vers = initdata->vers;
	setup = initdata->setup;
	teardown = initdata->teardown;
d959 2
a960 1
        } else {
d970 19
a988 18
	if (setup)
	    ret->SetupProc = setup;
	if (teardown)
	    ret->TearDownProc = teardown;
	ret->VersionInfo = vers;
    } else {
	/* No initdata is OK for external modules */
	if (options == EXTERN_MODULE)
	    goto LoadModule_exit;

	/* no initdata, fail the load */
	xf86Msg(X_ERROR, "LoadModule: Module %s does not have a %s "
		"data object.\n", module, p);
	if (errmaj)
	    *errmaj = LDR_INVALID;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
d991 8
a998 7
	ret->TearDownData = ret->SetupProc(ret, options, errmaj, errmin);
	if (!ret->TearDownData) {
	    goto LoadModule_fail;
	}
    } else if (options) {
	xf86Msg(X_WARNING, "Module Options present, but no SetupProc "
		"available for %s\n", module);
d1002 1
a1002 1
  LoadModule_fail:
d1006 1
a1006 1
  LoadModule_exit:
d1055 2
a1056 2
	   const char **patternlist, pointer options,
	   const XF86ModReqInfo * modreq, int *errmaj, int *errmin)
d1058 2
a1059 2
  return doLoadModule(module, path, subdirlist, patternlist, options,
		      modreq, errmaj, errmin);
d1065 1
a1065 1
    UnloadModuleOrDriver((ModuleDescPtr)mod);
d1072 1
a1072 1
	return;
d1075 1
a1075 1
	return;
d1077 4
a1080 1
    xf86MsgVerb(X_INFO, 3, "UnloadModule: \"%s\"\n", mod->name);
d1082 5
a1086 3
    if ((mod->TearDownProc) && (mod->TearDownData))
	mod->TearDownProc(mod->TearDownData);
    LoaderUnload(mod->name, mod->handle);
d1089 1
a1089 1
	UnloadModuleOrDriver(mod->child);
d1091 1
a1091 1
	UnloadModuleOrDriver(mod->sib);
d1100 1
a1100 10
    ModuleDescPtr mod = (ModuleDescPtr)_mod;

    if (mod == NULL || mod->name == NULL)
	return;

    xf86MsgVerb(X_INFO, 3, "UnloadSubModule: \"%s\"\n", mod->name);

    if ((mod->TearDownProc) && (mod->TearDownData))
	mod->TearDownProc(mod->TearDownData);
    LoaderUnload(mod->name, mod->handle);
d1102 3
d1106 1
a1106 7

    if (mod->child)
	UnloadModuleOrDriver(mod->child);

    free(mod->path);
    free(mod->name);
    free(mod);
d1117 1
a1117 1
	return;
d1121 2
a1122 2
	parent->child = child->sib;
	return;
d1128 2
a1129 2
	prevsib = mdp;
	mdp = mdp->sib;
d1132 2
a1133 1
	prevsib->sib = child->sib;
d1145 2
a1146 2
	msg = "no error";
	break;
d1148 2
a1149 2
	msg = "out of memory";
	break;
d1151 2
a1152 2
	msg = "module does not exist";
	break;
d1154 2
a1155 2
	msg = "a required submodule could not be loaded";
	break;
d1157 2
a1158 2
	msg = "too many modules";
	break;
d1160 2
a1161 2
	msg = "open failed";
	break;
d1163 2
a1164 2
	msg = "unknown module type";
	break;
d1166 2
a1167 2
	msg = "loader failed";
	break;
d1169 1
a1169 1
	msg = "already loaded";
d1171 1
a1171 1
	break;
d1173 2
a1174 2
	msg = "port open failed";
	break;
d1176 2
a1177 2
	msg = "no hardware found";
	break;
d1179 2
a1180 2
	msg = "module requirement mismatch";
	break;
d1182 2
a1183 2
	msg = "invalid argument(s) to LoadModule()";
	break;
d1185 2
a1186 2
	msg = "invalid module";
	break;
d1188 2
a1189 2
	msg = "module doesn't support this OS";
	break;
d1191 2
a1192 2
	msg = "module-specific error";
	break;
d1194 1
a1194 1
	msg = "unknown error";
d1197 2
a1198 2
	xf86Msg(type, "%s: Failed to load module \"%s\" (%s, %d)\n",
		name, modname, msg, errmin);
d1200 2
a1201 2
	xf86Msg(type, "Failed to load module \"%s\" (%s, %d)\n",
		modname, msg, errmin);
d1217 1
a1217 1
	s = modname;
d1219 1
a1219 1
	s++;
d1223 9
a1231 9
	if (regexec(&p->rex, s, 2, match, 0) == 0 && match[1].rm_so != -1) {
	    len = match[1].rm_eo - match[1].rm_so;
	    str = malloc(len + 1);
	    if (!str)
		return NULL;
	    strncpy(str, s + match[1].rm_so, len);
	    str[len] = '\0';
	    return str;
	}
d1244 1
a1244 1
	return 0;
d1247 2
a1248 2
				  mod->VersionInfo->minorversion,
				  mod->VersionInfo->patchlevel);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d921 1
a921 1
    if (ret->handle < 0)
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d86 1
a86 2
				  const XF86ModReqInfo *, int *, int *,
				  int flags);
d377 1
a377 1
	    free(*s);
d409 2
a410 2
            ret = malloc(strlen(tmpBuf) + strlen(dirpath) + 2);
            sprintf(ret, "%s%s", dirpath, tmpBuf);
d416 2
a417 2
            ret = malloc(strlen(tmpBuf) + strlen(dirpath) + 2);
            sprintf(ret, "%s%s", dirpath, tmpBuf);
d423 2
a424 2
            ret = malloc(strlen(tmpBuf) + strlen(dirpath) + 2);
            sprintf(ret, "%s%s", dirpath, tmpBuf);
d486 1
d491 4
a494 9
    if (!(subdirs = InitSubdirs(subdirlist))) {
	FreePathList(pathlist);
	return NULL;
    }
    if (!(patterns = InitPatterns(patternlist))) {
	FreePathList(pathlist);
	FreeSubdirs(subdirs);
	return NULL;
    }
d528 2
a529 4
				FreePathList(pathlist);
				FreeSubdirs(subdirs);
				FreePatterns(patterns);
				return NULL;
d534 2
a535 4
				FreePathList(pathlist);
				FreeSubdirs(subdirs);
				FreePatterns(patterns);
				return NULL;
d551 7
a557 1
    return listing;
d765 1
a765 1
			  modreq, errmaj, errmin, LD_FLAG_GLOBAL);
d776 1
a776 1
    ModuleDescPtr mdp = malloc(sizeof(ModuleDesc));
d778 1
a778 4
    if (mdp) {
	mdp->child = NULL;
	mdp->sib = NULL;
	mdp->parent = NULL;
a779 5
	mdp->handle = -1;
	mdp->SetupProc = NULL;
	mdp->TearDownProc = NULL;
	mdp->TearDownData = NULL;
    }
d788 1
d797 4
a800 2
    if (LoaderHandleOpen(mod->handle) == -1)
	return NULL;
a801 1
    ret->handle = mod->handle;
d809 1
d825 1
a825 1
	     int *errmaj, int *errmin, int flags)
a833 1
    int wasLoaded = 0;
d920 1
a920 2
    ret->handle = LoaderOpen(found, name, 0,
			     errmaj, errmin, &wasLoaded, flags);
d923 1
d934 2
a935 2
    p = malloc(strlen(name) + strlen("ModuleData") + 1);
    if (!p) {
a941 2
    strcpy(p, name);
    strcat(p, "ModuleData");
d952 18
a969 20
	if (!wasLoaded) {
	    if (vers) {
		if (!CheckVersion(module, vers, modreq)) {
		    if (errmaj)
			*errmaj = LDR_MISMATCH;
		    if (errmin)
			*errmin = 0;
		    goto LoadModule_fail;
		}
	    } else {
		xf86Msg(X_ERROR,
			"LoadModule: Module %s does not supply"
			" version information\n", module);
		if (errmaj)
		    *errmaj = LDR_INVALID;
		if (errmin)
		    *errmin = 0;
		goto LoadModule_fail;
	    }
	}
d1057 1
a1057 1
		      modreq, errmaj, errmin, LD_FLAG_GLOBAL);
d1079 1
a1079 1
    LoaderUnload(mod->handle);
d1085 1
d1102 1
a1102 1
    LoaderUnload(mod->handle);
d1109 1
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d107 1
a107 1
	xfree(*p);
d109 1
a109 1
    xfree(paths);
d117 1
a117 1
    return (*path == '/');
d138 1
a138 1
    fullpath = xstrdup(path);
d150 1
a150 1
	    list = xrealloc(list, (n + 2) * sizeof(char *));
d156 1
a156 1
		xfree(fullpath);
d159 1
a159 1
	    list[n] = xalloc(len + 1);
d162 1
a162 1
		xfree(fullpath);
d176 1
a176 1
    xfree(fullpath);
d247 1
a247 1
	patterns = xalloc((i + 1) * sizeof(PatternRec));
d277 1
a277 1
	xfree(patterns);
d293 1
a293 1
	subdirlist = tmp_subdirlist = xalloc(2 * sizeof(char *));
d318 1
a318 2
		    if (tmp_subdirlist)
			xfree(tmp_subdirlist);
d323 1
a323 1
	subdirs = xalloc((i * 2 + 1) * sizeof(char *));
d325 1
a325 2
	    if (tmp_subdirlist)
		xfree(tmp_subdirlist);
d345 1
a345 1
	    if (!(subdirs[i] = xalloc(len))) {
d347 3
a349 4
		    xfree(subdirs[i]);
		xfree(subdirs);
		if (tmp_subdirlist)
		    xfree(tmp_subdirlist);
d356 1
a356 1
	    subdirs[i] = xstrdup(*s);
d367 1
a367 2
    if (tmp_subdirlist)
	xfree(tmp_subdirlist);
d378 2
a379 2
	    xfree(*s);
	xfree(subdirs);
d464 1
a464 1
	xfree(dirpath);
d526 1
a526 1
			    listing = xrealloc(listing,
d538 1
a538 1
			    listing[n] = xalloc(len + 1);
d742 1
a742 1
    return (new);
d779 1
a779 1
    ModuleDescPtr mdp = xalloc(sizeof(ModuleDesc));
d792 1
a792 1
    return (mdp);
d943 1
a943 1
    p = xalloc(strlen(name) + strlen("ModuleData") + 1);
d1020 3
a1022 3
    xfree(found);
    xfree(name);
    xfree(p);
d1098 2
a1099 2
    xfree(mod->name);
    xfree(mod);
d1121 2
a1122 2
    xfree(mod->name);
    xfree(mod);
d1240 1
a1240 1
	    str = xalloc(len + 1);
d1249 1
a1249 1
    return xstrdup(s);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a70 2
#define TestFree(a) if (a) { xfree (a); a = NULL; }

d402 5
a406 2
        if ((stat(direntry->d_name, &stat_buf) == 0) && S_ISDIR(stat_buf.st_mode)) {
            snprintf(tmpBuf, PATH_MAX, "%s/%s", dirpath, direntry->d_name);
d415 1
a415 1
            sprintf(ret, "%s/%s", dirpath, tmpBuf);
d422 1
a422 1
            sprintf(ret, "%s/%s", dirpath, tmpBuf);
d429 1
a429 1
            sprintf(ret, "%s/%s", dirpath, tmpBuf);
d473 1
a473 1
_X_EXPORT char **
d567 1
a567 1
_X_EXPORT void
d749 2
a750 2
_X_EXPORT ModuleDescPtr
LoadSubModule(ModuleDescPtr parent, const char *module,
d756 1
d799 1
a799 1
_X_EXPORT ModuleDescPtr
d1024 3
a1026 3
    TestFree(found);
    TestFree(name);
    TestFree(p);
a1027 9
    /*
     * If you need to do something to keep the
     * instruction cache in sync with the main
     * memory before jumping to that code, you may
     * do it here.
     */
#ifdef __alpha__
    istream_mem_barrier();
#endif
d1078 1
a1078 1
UnloadModule(ModuleDescPtr mod)
d1080 1
a1080 1
    UnloadModuleOrDriver(mod);
d1102 1
a1102 1
    TestFree(mod->name);
a1103 3
#ifdef __alpha__
    istream_mem_barrier();
#endif
d1106 2
a1107 2
_X_EXPORT void
UnloadSubModule(ModuleDescPtr mod)
d1109 2
d1125 1
a1125 1
    TestFree(mod->name);
d1156 1
a1156 1
_X_EXPORT void
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a61 1
#ifdef XINPUT
a62 1
#endif
a200 1
    "fonts/",
d850 1
a850 8
    xf86MsgVerb(X_INFO, 3, "LoadModule: \"%s\"\n", module);

    for (cim = compiled_in_modules; *cim; cim++)
	if (!strcmp (module, *cim))
	{
	    xf86MsgVerb(X_INFO, 3, "Module \"%s\" already built-in\n", module);
	    return (ModuleDescPtr) 1;
	}
d865 9
a1134 18
}

static void
FreeModuleDesc(ModuleDescPtr head)
{
    ModuleDescPtr sibs, prev;

    if (head == (ModuleDescPtr) 1)
	return;
    if (head->child)
	FreeModuleDesc(head->child);
    sibs = head;
    while (sibs) {
	prev = sibs;
	sibs = sibs->sib;
	TestFree(prev->name);
	xfree(prev);
    }
@


1.1
log
@Initial revision
@
text
@a120 4
#ifdef __UNIXOS2__
    return (*path == '/' || (strlen(path) > 2 && isalpha(elem[0]) &&
		elem[1] == ':' && elem[2] == '/'));
#else
a121 1
#endif
d180 1
d744 7
d774 1
a774 1
    if (submod) {
d781 2
a782 5
ModuleDescPtr
LoadSubModuleLocal(ModuleDescPtr parent, const char *module,
		   const char **subdirlist, const char **patternlist,
		   pointer options, const XF86ModReqInfo * modreq,
		   int *errmaj, int *errmin)
d784 1
a784 1
    ModuleDescPtr submod;
d786 9
a794 12
    xf86MsgVerb(X_INFO, 3, "Loading local sub module \"%s\"\n", module);

    if (PathIsAbsolute(module))
    {
	xf86Msg(X_ERROR,
		"LoadSubModule: Absolute module path not permitted: \"%s\"\n",
		module);
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 0;
	return NULL;
d797 1
a797 7
    submod = doLoadModule(module, NULL, subdirlist, patternlist, options,
			  modreq, errmaj, errmin, 0);
    if (submod) {
	parent->child = AddSibling(parent->child, submod);
	submod->parent = parent;
    }
    return submod;
a814 4
    ret->filename = xstrdup(mod->filename);
    ret->identifier = mod->identifier;
    ret->client_id = mod->client_id;
    ret->in_use = mod->in_use;
a818 1
    ret->path = mod->path;
d827 6
d851 3
d855 6
a860 1
    xf86MsgVerb(X_INFO, 3, "LoadModule: \"%s\"", module);
d906 1
a906 1
	xstrdup(module);
a936 2
    ret->filename = xstrdup(found);

a989 1
	ret->path = path;
a1084 8
ModuleDescPtr
LoadDriver(const char *module, const char *path, int handle, pointer options,
	   int *errmaj, int *errmin)
{
    return LoadModule(module, path, NULL, NULL, options, NULL, errmaj,
		      errmin);
}

a1090 6
void
UnloadDriver(ModuleDescPtr mod)
{
    UnloadModuleOrDriver(mod);
}

d1094 3
a1110 1
    TestFree(mod->filename);
a1134 1
    TestFree(mod->filename);
d1138 1
a1138 1
void
d1143 1
a1143 5
    /*
     * only free it if it's not marked as in use. In use means that it may
     * be unloaded someday, and UnloadModule or UnloadDriver will free it
     */
    if (head->in_use)
a1155 32
ModuleDescPtr
NewModuleDesc(const char *name)
{
    ModuleDescPtr mdp = xalloc(sizeof(ModuleDesc));

    if (mdp) {
	mdp->child = NULL;
	mdp->sib = NULL;
	mdp->parent = NULL;
	mdp->demand_next = NULL;
	mdp->name = xstrdup(name);
	mdp->filename = NULL;
	mdp->identifier = NULL;
	mdp->client_id = 0;
	mdp->in_use = 0;
	mdp->handle = -1;
	mdp->SetupProc = NULL;
	mdp->TearDownProc = NULL;
	mdp->TearDownData = NULL;
    }

    return (mdp);
}

ModuleDescPtr
AddSibling(ModuleDescPtr head, ModuleDescPtr new)
{
    new->sib = head;
    return (new);

}

d1289 1
a1289 1
    if (!mod || !mod->VersionInfo)
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d121 4
d126 1
a747 7
static ModuleDescPtr
AddSibling(ModuleDescPtr head, ModuleDescPtr new)
{
    new->sib = head;
    return (new);
}

d771 1
a771 1
    if (submod && submod != (ModuleDescPtr) 1) {
d778 5
a782 2
static ModuleDescPtr
NewModuleDesc(const char *name)
d784 3
a786 1
    ModuleDescPtr mdp = xalloc(sizeof(ModuleDesc));
d788 10
a797 14
    if (mdp) {
	mdp->child = NULL;
	mdp->sib = NULL;
	mdp->parent = NULL;
	mdp->demand_next = NULL;
	mdp->name = xstrdup(name);
	mdp->filename = NULL;
	mdp->identifier = NULL;
	mdp->client_id = 0;
	mdp->in_use = 0;
	mdp->handle = -1;
	mdp->SetupProc = NULL;
	mdp->TearDownProc = NULL;
	mdp->TearDownData = NULL;
d800 7
a806 1
    return (mdp);
a840 6
static const char *compiled_in_modules[] = {
    "ddc",
    "i2c",
    "ramdac",
    NULL
};
a858 1
    const char **cim;
a861 7
    for (cim = compiled_in_modules; *cim; cim++)
	if (!strcmp (module, *cim))
	{
	    xf86MsgVerb(X_INFO, 0, "Module \"%s\" already built-in\n", module);
	    return (ModuleDescPtr) 1;
	}

d906 1
a906 1
	found = xstrdup(module);
d1088 8
d1102 6
a1110 3
    if (mod == (ModuleDescPtr) 1)
	return;

d1154 1
a1154 1
static void
a1158 2
    if (head == (ModuleDescPtr) 1)
	return;
d1161 1
a1161 1
     * be unloaded someday, and UnloadModule will free it
d1176 32
d1341 1
a1341 1
    if (!mod || mod == (ModuleDescPtr) 1 || !mod->VersionInfo)
@

