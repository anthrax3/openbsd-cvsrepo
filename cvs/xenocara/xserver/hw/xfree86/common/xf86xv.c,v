head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.08;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.51;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * XFree86 Xv DDX written by Mark Vojkovich (markv@@valinux.com)
 */
/*
 * Copyright (c) 1998-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include <X11/Xproto.h>
#include "scrnintstr.h"
#include "regionstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "mivalidate.h"
#include "validate.h"
#include "resource.h"
#include "gcstruct.h"
#include "dixstruct.h"

#include <X11/extensions/Xv.h>
#include <X11/extensions/Xvproto.h>
#include "xvdix.h"

#include "xf86xvpriv.h"

/* XvAdaptorRec fields */

static int xf86XVPutVideo(DrawablePtr, XvPortPtr, GCPtr,
                          INT16, INT16, CARD16, CARD16,
                          INT16, INT16, CARD16, CARD16);
static int xf86XVPutStill(DrawablePtr, XvPortPtr, GCPtr,
                          INT16, INT16, CARD16, CARD16,
                          INT16, INT16, CARD16, CARD16);
static int xf86XVGetVideo(DrawablePtr, XvPortPtr, GCPtr,
                          INT16, INT16, CARD16, CARD16,
                          INT16, INT16, CARD16, CARD16);
static int xf86XVGetStill(DrawablePtr, XvPortPtr, GCPtr,
                          INT16, INT16, CARD16, CARD16,
                          INT16, INT16, CARD16, CARD16);
static int xf86XVStopVideo(XvPortPtr, DrawablePtr);
static int xf86XVSetPortAttribute(XvPortPtr, Atom, INT32);
static int xf86XVGetPortAttribute(XvPortPtr, Atom, INT32 *);
static int xf86XVQueryBestSize(XvPortPtr, CARD8,
                               CARD16, CARD16, CARD16, CARD16,
                               unsigned int *, unsigned int *);
static int xf86XVPutImage(DrawablePtr, XvPortPtr, GCPtr,
                          INT16, INT16, CARD16, CARD16,
                          INT16, INT16, CARD16, CARD16,
                          XvImagePtr, unsigned char *, Bool, CARD16, CARD16);
static int xf86XVQueryImageAttributes(XvPortPtr, XvImagePtr,
                                      CARD16 *, CARD16 *, int *, int *);

/* ScreenRec fields */

static Bool xf86XVDestroyWindow(WindowPtr pWin);
static void xf86XVWindowExposures(WindowPtr pWin, RegionPtr r1);
static void xf86XVPostValidateTree(WindowPtr pWin, WindowPtr pLayerWin,
                                   VTKind kind);
static void xf86XVClipNotify(WindowPtr pWin, int dx, int dy);
static Bool xf86XVCloseScreen(ScreenPtr);

#define PostValidateTreeUndefined ((PostValidateTreeProcPtr)-1)

/* ScrnInfoRec functions */

static Bool xf86XVEnterVT(ScrnInfoPtr);
static void xf86XVLeaveVT(ScrnInfoPtr);
static void xf86XVAdjustFrame(ScrnInfoPtr, int x, int y);
static void xf86XVModeSet(ScrnInfoPtr pScrn);

/* misc */

static Bool xf86XVInitAdaptors(ScreenPtr, XF86VideoAdaptorPtr *, int);

static DevPrivateKeyRec XF86XVWindowKeyRec;

#define XF86XVWindowKey (&XF86XVWindowKeyRec)

/* dixmain.c XvScreenPtr screen private */
DevPrivateKey XF86XvScreenKey;
/** xf86xv.c XF86XVScreenPtr screen private */
static DevPrivateKeyRec XF86XVScreenPrivateKey;

static unsigned long PortResource = 0;

#define GET_XV_SCREEN(pScreen) \
    ((XvScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, XF86XvScreenKey))

#define GET_XF86XV_SCREEN(pScreen) \
    ((XF86XVScreenPtr)(dixGetPrivate(&pScreen->devPrivates, &XF86XVScreenPrivateKey)))

#define GET_XF86XV_WINDOW(pWin) \
    ((XF86XVWindowPtr)dixLookupPrivate(&(pWin)->devPrivates, XF86XVWindowKey))

static xf86XVInitGenericAdaptorPtr *GenDrivers = NULL;
static int NumGenDrivers = 0;

int
xf86XVRegisterGenericAdaptorDriver(xf86XVInitGenericAdaptorPtr InitFunc)
{
    xf86XVInitGenericAdaptorPtr *newdrivers;

    newdrivers = reallocarray(GenDrivers, 1 + NumGenDrivers,
                              sizeof(xf86XVInitGenericAdaptorPtr));
    if (!newdrivers)
        return 0;
    GenDrivers = newdrivers;

    GenDrivers[NumGenDrivers++] = InitFunc;

    return 1;
}

int
xf86XVListGenericAdaptors(ScrnInfoPtr pScrn, XF86VideoAdaptorPtr ** adaptors)
{
    int i, j, n, num;
    XF86VideoAdaptorPtr *DrivAdap, *new;

    num = 0;
    *adaptors = NULL;
    /*
     * The v4l driver registers itself first, but can use surfaces registered
     * by other drivers.  So, call the v4l driver last.
     */
    for (i = NumGenDrivers; --i >= 0;) {
        DrivAdap = NULL;
        n = (*GenDrivers[i]) (pScrn, &DrivAdap);
        if (0 == n)
            continue;
        new = reallocarray(*adaptors, num + n, sizeof(XF86VideoAdaptorPtr));
        if (NULL == new)
            continue;
        *adaptors = new;
        for (j = 0; j < n; j++, num++)
            (*adaptors)[num] = DrivAdap[j];
    }
    return num;
}

/****************  Offscreen surface stuff *******************/

typedef struct {
    XF86OffscreenImagePtr images;
    int num;
} OffscreenImageRec;

static DevPrivateKeyRec OffscreenPrivateKeyRec;

#define OffscreenPrivateKey (&OffscreenPrivateKeyRec)
#define GetOffscreenImage(pScreen) ((OffscreenImageRec *) dixLookupPrivate(&(pScreen)->devPrivates, OffscreenPrivateKey))

Bool
xf86XVRegisterOffscreenImages(ScreenPtr pScreen,
                              XF86OffscreenImagePtr images, int num)
{
    OffscreenImageRec *OffscreenImage;

    /* This function may be called before xf86XVScreenInit, so there's
     * no better place than this to call dixRegisterPrivateKey to ensure we
     * have space reserved. After the first call it is a no-op. */
    if (!dixRegisterPrivateKey
        (OffscreenPrivateKey, PRIVATE_SCREEN, sizeof(OffscreenImageRec)) ||
        !(OffscreenImage = GetOffscreenImage(pScreen)))
        /* Every X.org driver assumes this function always succeeds, so
         * just die on allocation failure. */
        FatalError
            ("Could not allocate private storage for XV offscreen images.\n");

    OffscreenImage->num = num;
    OffscreenImage->images = images;
    return TRUE;
}

XF86OffscreenImagePtr
xf86XVQueryOffscreenImages(ScreenPtr pScreen, int *num)
{
    OffscreenImageRec *OffscreenImage = GetOffscreenImage(pScreen);

    *num = OffscreenImage->num;
    return OffscreenImage->images;
}

XF86VideoAdaptorPtr
xf86XVAllocateVideoAdaptorRec(ScrnInfoPtr pScrn)
{
    return calloc(1, sizeof(XF86VideoAdaptorRec));
}

void
xf86XVFreeVideoAdaptorRec(XF86VideoAdaptorPtr ptr)
{
    free(ptr);
}

Bool
xf86XVScreenInit(ScreenPtr pScreen, XF86VideoAdaptorPtr * adaptors, int num)
{
    ScrnInfoPtr pScrn;
    XF86XVScreenPtr ScreenPriv;

    if (num <= 0 || noXvExtension)
        return FALSE;

    if (Success != XvScreenInit(pScreen))
        return FALSE;

    if (!dixRegisterPrivateKey(&XF86XVWindowKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&XF86XVScreenPrivateKey, PRIVATE_SCREEN, 0))
        return FALSE;

    XF86XvScreenKey = XvGetScreenKey();

    PortResource = XvGetRTPort();

    ScreenPriv = malloc(sizeof(XF86XVScreenRec));
    dixSetPrivate(&pScreen->devPrivates, &XF86XVScreenPrivateKey, ScreenPriv);

    if (!ScreenPriv)
        return FALSE;

    pScrn = xf86ScreenToScrn(pScreen);

    ScreenPriv->DestroyWindow = pScreen->DestroyWindow;
    ScreenPriv->WindowExposures = pScreen->WindowExposures;
    ScreenPriv->PostValidateTree = PostValidateTreeUndefined;
    ScreenPriv->ClipNotify = pScreen->ClipNotify;
    ScreenPriv->CloseScreen = pScreen->CloseScreen;
    ScreenPriv->EnterVT = pScrn->EnterVT;
    ScreenPriv->LeaveVT = pScrn->LeaveVT;
    ScreenPriv->AdjustFrame = pScrn->AdjustFrame;
    ScreenPriv->ModeSet = pScrn->ModeSet;

    pScreen->DestroyWindow = xf86XVDestroyWindow;
    pScreen->WindowExposures = xf86XVWindowExposures;
    pScreen->ClipNotify = xf86XVClipNotify;
    pScreen->CloseScreen = xf86XVCloseScreen;
    pScrn->EnterVT = xf86XVEnterVT;
    pScrn->LeaveVT = xf86XVLeaveVT;
    if (pScrn->AdjustFrame)
        pScrn->AdjustFrame = xf86XVAdjustFrame;
    pScrn->ModeSet = xf86XVModeSet;

    if (!xf86XVInitAdaptors(pScreen, adaptors, num))
        return FALSE;

    return TRUE;
}

static void
xf86XVFreeAdaptor(XvAdaptorPtr pAdaptor)
{
    int i;

    if (pAdaptor->pPorts) {
        XvPortPtr pPort = pAdaptor->pPorts;
        XvPortRecPrivatePtr pPriv;

        for (i = 0; i < pAdaptor->nPorts; i++, pPort++) {
            pPriv = (XvPortRecPrivatePtr) pPort->devPriv.ptr;
            if (pPriv) {
                if (pPriv->clientClip)
                    RegionDestroy(pPriv->clientClip);
                if (pPriv->pCompositeClip && pPriv->FreeCompositeClip)
                    RegionDestroy(pPriv->pCompositeClip);
                if (pPriv->ckeyFilled)
                    RegionDestroy(pPriv->ckeyFilled);
                free(pPriv);
            }
        }
    }

    XvFreeAdaptor(pAdaptor);
}

static Bool
xf86XVInitAdaptors(ScreenPtr pScreen, XF86VideoAdaptorPtr * infoPtr, int number)
{
    XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    XF86VideoAdaptorPtr adaptorPtr;
    XvAdaptorPtr pAdaptor, pa;
    XvAdaptorRecPrivatePtr adaptorPriv;
    int na, numAdaptor;
    XvPortRecPrivatePtr portPriv;
    XvPortPtr pPort, pp;
    int numPort;
    XF86VideoFormatPtr formatPtr;
    XvFormatPtr pFormat, pf;
    int numFormat, totFormat;
    XF86VideoEncodingPtr encodingPtr;
    XvEncodingPtr pEncode, pe;
    int numVisuals;
    VisualPtr pVisual;
    int i;

    pxvs->nAdaptors = 0;
    pxvs->pAdaptors = NULL;

    if (!(pAdaptor = calloc(number, sizeof(XvAdaptorRec))))
        return FALSE;

    for (pa = pAdaptor, na = 0, numAdaptor = 0; na < number; na++, adaptorPtr++) {
        adaptorPtr = infoPtr[na];

        if (!adaptorPtr->StopVideo || !adaptorPtr->SetPortAttribute ||
            !adaptorPtr->GetPortAttribute || !adaptorPtr->QueryBestSize)
            continue;

        /* client libs expect at least one encoding */
        if (!adaptorPtr->nEncodings || !adaptorPtr->pEncodings)
            continue;

        pa->type = adaptorPtr->type;

        if (!adaptorPtr->PutVideo && !adaptorPtr->GetVideo)
            pa->type &= ~XvVideoMask;

        if (!adaptorPtr->PutStill && !adaptorPtr->GetStill)
            pa->type &= ~XvStillMask;

        if (!adaptorPtr->PutImage || !adaptorPtr->QueryImageAttributes)
            pa->type &= ~XvImageMask;

        if (!adaptorPtr->PutVideo && !adaptorPtr->PutImage &&
            !adaptorPtr->PutStill)
            pa->type &= ~XvInputMask;

        if (!adaptorPtr->GetVideo && !adaptorPtr->GetStill)
            pa->type &= ~XvOutputMask;

        if (!(adaptorPtr->type & (XvPixmapMask | XvWindowMask)))
            continue;
        if (!(adaptorPtr->type & (XvImageMask | XvVideoMask | XvStillMask)))
            continue;

        pa->pScreen = pScreen;
        pa->ddPutVideo = xf86XVPutVideo;
        pa->ddPutStill = xf86XVPutStill;
        pa->ddGetVideo = xf86XVGetVideo;
        pa->ddGetStill = xf86XVGetStill;
        pa->ddStopVideo = xf86XVStopVideo;
        pa->ddPutImage = xf86XVPutImage;
        pa->ddSetPortAttribute = xf86XVSetPortAttribute;
        pa->ddGetPortAttribute = xf86XVGetPortAttribute;
        pa->ddQueryBestSize = xf86XVQueryBestSize;
        pa->ddQueryImageAttributes = xf86XVQueryImageAttributes;
        pa->name = strdup(adaptorPtr->name);

        if (adaptorPtr->nEncodings &&
            (pEncode = calloc(adaptorPtr->nEncodings, sizeof(XvEncodingRec)))) {

            for (pe = pEncode, encodingPtr = adaptorPtr->pEncodings, i = 0;
                 i < adaptorPtr->nEncodings; pe++, i++, encodingPtr++) {
                pe->id = encodingPtr->id;
                pe->pScreen = pScreen;
                pe->name = strdup(encodingPtr->name);
                pe->width = encodingPtr->width;
                pe->height = encodingPtr->height;
                pe->rate.numerator = encodingPtr->rate.numerator;
                pe->rate.denominator = encodingPtr->rate.denominator;
            }
            pa->nEncodings = adaptorPtr->nEncodings;
            pa->pEncodings = pEncode;
        }

        if (adaptorPtr->nImages &&
            (pa->pImages = calloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {
            memcpy(pa->pImages, adaptorPtr->pImages,
                   adaptorPtr->nImages * sizeof(XvImageRec));
            pa->nImages = adaptorPtr->nImages;
        }

        if (adaptorPtr->nAttributes &&
            (pa->pAttributes = calloc(adaptorPtr->nAttributes,
                                      sizeof(XvAttributeRec)))) {
            memcpy(pa->pAttributes, adaptorPtr->pAttributes,
                   adaptorPtr->nAttributes * sizeof(XvAttributeRec));

            for (i = 0; i < adaptorPtr->nAttributes; i++) {
                pa->pAttributes[i].name =
                    strdup(adaptorPtr->pAttributes[i].name);
            }

            pa->nAttributes = adaptorPtr->nAttributes;
        }

        totFormat = adaptorPtr->nFormats;

        if (!(pFormat = calloc(totFormat, sizeof(XvFormatRec)))) {
            xf86XVFreeAdaptor(pa);
            continue;
        }
        for (pf = pFormat, i = 0, numFormat = 0, formatPtr =
             adaptorPtr->pFormats; i < adaptorPtr->nFormats; i++, formatPtr++) {
            numVisuals = pScreen->numVisuals;
            pVisual = pScreen->visuals;

            while (numVisuals--) {
                if ((pVisual->class == formatPtr->class) &&
                    (pVisual->nplanes == formatPtr->depth)) {

                    if (numFormat >= totFormat) {
                        void *moreSpace;

                        totFormat *= 2;
                        moreSpace = reallocarray(pFormat, totFormat,
                                                 sizeof(XvFormatRec));
                        if (!moreSpace)
                            break;
                        pFormat = moreSpace;
                        pf = pFormat + numFormat;
                    }

                    pf->visual = pVisual->vid;
                    pf->depth = formatPtr->depth;

                    pf++;
                    numFormat++;
                }
                pVisual++;
            }
        }
        pa->nFormats = numFormat;
        pa->pFormats = pFormat;
        if (!numFormat) {
            xf86XVFreeAdaptor(pa);
            continue;
        }

        if (!(adaptorPriv = calloc(1, sizeof(XvAdaptorRecPrivate)))) {
            xf86XVFreeAdaptor(pa);
            continue;
        }

        adaptorPriv->flags = adaptorPtr->flags;
        adaptorPriv->PutVideo = adaptorPtr->PutVideo;
        adaptorPriv->PutStill = adaptorPtr->PutStill;
        adaptorPriv->GetVideo = adaptorPtr->GetVideo;
        adaptorPriv->GetStill = adaptorPtr->GetStill;
        adaptorPriv->StopVideo = adaptorPtr->StopVideo;
        adaptorPriv->SetPortAttribute = adaptorPtr->SetPortAttribute;
        adaptorPriv->GetPortAttribute = adaptorPtr->GetPortAttribute;
        adaptorPriv->QueryBestSize = adaptorPtr->QueryBestSize;
        adaptorPriv->QueryImageAttributes = adaptorPtr->QueryImageAttributes;
        adaptorPriv->PutImage = adaptorPtr->PutImage;
        adaptorPriv->ReputImage = adaptorPtr->ReputImage;       /* image/still */

        pa->devPriv.ptr = (void *) adaptorPriv;

        if (!(pPort = calloc(adaptorPtr->nPorts, sizeof(XvPortRec)))) {
            xf86XVFreeAdaptor(pa);
            continue;
        }
        for (pp = pPort, i = 0, numPort = 0; i < adaptorPtr->nPorts; i++) {

            if (!(pp->id = FakeClientID(0)))
                continue;

            if (!(portPriv = calloc(1, sizeof(XvPortRecPrivate))))
                continue;

            if (!AddResource(pp->id, PortResource, pp)) {
                free(portPriv);
                continue;
            }

            pp->pAdaptor = pa;
            pp->pNotify = (XvPortNotifyPtr) NULL;
            pp->pDraw = (DrawablePtr) NULL;
            pp->client = (ClientPtr) NULL;
            pp->grab.client = (ClientPtr) NULL;
            pp->time = currentTime;
            pp->devPriv.ptr = portPriv;

            portPriv->pScrn = pScrn;
            portPriv->AdaptorRec = adaptorPriv;
            portPriv->DevPriv.ptr = adaptorPtr->pPortPrivates[i].ptr;

            pp++;
            numPort++;
        }
        pa->nPorts = numPort;
        pa->pPorts = pPort;
        if (!numPort) {
            xf86XVFreeAdaptor(pa);
            continue;
        }

        pa->base_id = pPort->id;

        pa++;
        numAdaptor++;
    }

    if (numAdaptor) {
        pxvs->nAdaptors = numAdaptor;
        pxvs->pAdaptors = pAdaptor;
    }
    else {
        free(pAdaptor);
        return FALSE;
    }

    return TRUE;
}

/* Video should be clipped to the intersection of the window cliplist
   and the client cliplist specified in the GC for which the video was
   initialized.  When we need to reclip a window, the GC that started
   the video may not even be around anymore.  That's why we save the
   client clip from the GC when the video is initialized.  We then
   use xf86XVUpdateCompositeClip to calculate the new composite clip
   when we need it.  This is different from what DEC did.  They saved
   the GC and used it's clip list when they needed to reclip the window,
   even if the client clip was different from the one the video was
   initialized with.  If the original GC was destroyed, they had to stop
   the video.  I like the new method better (MArk).

   This function only works for windows.  Will need to rewrite when
   (if) we support pixmap rendering.
*/

static void
xf86XVUpdateCompositeClip(XvPortRecPrivatePtr portPriv)
{
    RegionPtr pregWin, pCompositeClip;
    WindowPtr pWin;
    Bool freeCompClip = FALSE;

    if (portPriv->pCompositeClip)
        return;

    pWin = (WindowPtr) portPriv->pDraw;

    /* get window clip list */
    if (portPriv->subWindowMode == IncludeInferiors) {
        pregWin = NotClippedByChildren(pWin);
        freeCompClip = TRUE;
    }
    else
        pregWin = &pWin->clipList;

    if (!portPriv->clientClip) {
        portPriv->pCompositeClip = pregWin;
        portPriv->FreeCompositeClip = freeCompClip;
        return;
    }

    pCompositeClip = RegionCreate(NullBox, 1);
    RegionCopy(pCompositeClip, portPriv->clientClip);
    RegionTranslate(pCompositeClip, portPriv->pDraw->x, portPriv->pDraw->y);
    RegionIntersect(pCompositeClip, pregWin, pCompositeClip);

    portPriv->pCompositeClip = pCompositeClip;
    portPriv->FreeCompositeClip = TRUE;

    if (freeCompClip) {
        RegionDestroy(pregWin);
    }
}

/* Save the current clientClip and update the CompositeClip whenever
   we have a fresh GC */

static void
xf86XVCopyClip(XvPortRecPrivatePtr portPriv, GCPtr pGC)
{
    /* copy the new clip if it exists */
    if (pGC->clientClip) {
        if (!portPriv->clientClip)
            portPriv->clientClip = RegionCreate(NullBox, 1);
        /* Note: this is in window coordinates */
        RegionCopy(portPriv->clientClip, pGC->clientClip);
        RegionTranslate(portPriv->clientClip, pGC->clipOrg.x, pGC->clipOrg.y);
    }
    else if (portPriv->clientClip) {    /* free the old clientClip */
        RegionDestroy(portPriv->clientClip);
        portPriv->clientClip = NULL;
    }

    /* get rid of the old clip list */
    if (portPriv->pCompositeClip && portPriv->FreeCompositeClip) {
        RegionDestroy(portPriv->pCompositeClip);
    }

    portPriv->pCompositeClip = pGC->pCompositeClip;
    portPriv->FreeCompositeClip = FALSE;
    portPriv->subWindowMode = pGC->subWindowMode;
}

static void
xf86XVCopyCompositeClip(XvPortRecPrivatePtr portPriv,
                        GCPtr pGC, DrawablePtr pDraw)
{
    if (!portPriv->clientClip)
        portPriv->clientClip = RegionCreate(NullBox, 1);
    /* Keep the original GC composite clip around for ReputImage */
    RegionCopy(portPriv->clientClip, pGC->pCompositeClip);
    RegionTranslate(portPriv->clientClip, -pDraw->x, -pDraw->y);

    /* get rid of the old clip list */
    if (portPriv->pCompositeClip && portPriv->FreeCompositeClip)
        RegionDestroy(portPriv->pCompositeClip);

    portPriv->pCompositeClip = pGC->pCompositeClip;
    portPriv->FreeCompositeClip = FALSE;
    portPriv->subWindowMode = pGC->subWindowMode;
}

static int
xf86XVRegetVideo(XvPortRecPrivatePtr portPriv)
{
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    int ret = Success;
    Bool clippedAway = FALSE;

    xf86XVUpdateCompositeClip(portPriv);

    /* translate the video region to the screen */
    WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
    WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
    WinBox.x2 = WinBox.x1 + portPriv->drw_w;
    WinBox.y2 = WinBox.y1 + portPriv->drw_h;

    /* clip to the window composite clip */
    RegionInit(&WinRegion, &WinBox, 1);
    RegionNull(&ClipRegion);
    RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

    /* that's all if it's totally obscured */
    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto CLIP_VIDEO_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->GetVideo) (portPriv->pScrn,
                                             portPriv->vid_x, portPriv->vid_y,
                                             WinBox.x1, WinBox.y1,
                                             portPriv->vid_w, portPriv->vid_h,
                                             portPriv->drw_w, portPriv->drw_h,
                                             &ClipRegion, portPriv->DevPriv.ptr,
                                             portPriv->pDraw);

    if (ret == Success)
        portPriv->isOn = XV_ON;

 CLIP_VIDEO_BAILOUT:

    if ((clippedAway || (ret != Success)) && portPriv->isOn == XV_ON) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->pScrn,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    /* This clip was copied and only good for one shot */
    if (!portPriv->FreeCompositeClip)
        portPriv->pCompositeClip = NULL;

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
xf86XVReputVideo(XvPortRecPrivatePtr portPriv)
{
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    int ret = Success;
    Bool clippedAway = FALSE;

    xf86XVUpdateCompositeClip(portPriv);

    /* translate the video region to the screen */
    WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
    WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
    WinBox.x2 = WinBox.x1 + portPriv->drw_w;
    WinBox.y2 = WinBox.y1 + portPriv->drw_h;

    /* clip to the window composite clip */
    RegionInit(&WinRegion, &WinBox, 1);
    RegionNull(&ClipRegion);
    RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

    /* clip and translate to the viewport */
    if (portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
        RegionRec VPReg;
        BoxRec VPBox;

        VPBox.x1 = portPriv->pScrn->frameX0;
        VPBox.y1 = portPriv->pScrn->frameY0;
        VPBox.x2 = portPriv->pScrn->frameX1 + 1;
        VPBox.y2 = portPriv->pScrn->frameY1 + 1;

        RegionInit(&VPReg, &VPBox, 1);
        RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
        RegionUninit(&VPReg);
    }

    /* that's all if it's totally obscured */
    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto CLIP_VIDEO_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->PutVideo) (portPriv->pScrn,
                                             portPriv->vid_x, portPriv->vid_y,
                                             WinBox.x1, WinBox.y1,
                                             portPriv->vid_w, portPriv->vid_h,
                                             portPriv->drw_w, portPriv->drw_h,
                                             &ClipRegion, portPriv->DevPriv.ptr,
                                             portPriv->pDraw);

    if (ret == Success)
        portPriv->isOn = XV_ON;

 CLIP_VIDEO_BAILOUT:

    if ((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->pScrn,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    /* This clip was copied and only good for one shot */
    if (!portPriv->FreeCompositeClip)
        portPriv->pCompositeClip = NULL;

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

/* Reput image/still */
static int
xf86XVReputImage(XvPortRecPrivatePtr portPriv)
{
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    int ret = Success;
    Bool clippedAway = FALSE;

    xf86XVUpdateCompositeClip(portPriv);

    /* the clip can get smaller over time */
    RegionCopy(portPriv->clientClip, portPriv->pCompositeClip);
    RegionTranslate(portPriv->clientClip,
                    -portPriv->pDraw->x, -portPriv->pDraw->y);

    /* translate the video region to the screen */
    WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
    WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
    WinBox.x2 = WinBox.x1 + portPriv->drw_w;
    WinBox.y2 = WinBox.y1 + portPriv->drw_h;

    /* clip to the window composite clip */
    RegionInit(&WinRegion, &WinBox, 1);
    RegionNull(&ClipRegion);
    RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

    /* clip and translate to the viewport */
    if (portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
        RegionRec VPReg;
        BoxRec VPBox;

        VPBox.x1 = portPriv->pScrn->frameX0;
        VPBox.y1 = portPriv->pScrn->frameY0;
        VPBox.x2 = portPriv->pScrn->frameX1 + 1;
        VPBox.y2 = portPriv->pScrn->frameY1 + 1;

        RegionInit(&VPReg, &VPBox, 1);
        RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
        RegionUninit(&VPReg);
    }

    /* that's all if it's totally obscured */
    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto CLIP_VIDEO_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->ReputImage) (portPriv->pScrn,
                                               portPriv->vid_x, portPriv->vid_y,
                                               WinBox.x1, WinBox.y1,
                                               portPriv->vid_w, portPriv->vid_h,
                                               portPriv->drw_w, portPriv->drw_h,
                                               &ClipRegion,
                                               portPriv->DevPriv.ptr,
                                               portPriv->pDraw);

    portPriv->isOn = (ret == Success) ? XV_ON : XV_OFF;

 CLIP_VIDEO_BAILOUT:

    if ((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->pScrn,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    /* This clip was copied and only good for one shot */
    if (!portPriv->FreeCompositeClip)
        portPriv->pCompositeClip = NULL;

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
xf86XVReputAllVideo(WindowPtr pWin, void *data)
{
    XF86XVWindowPtr WinPriv = GET_XF86XV_WINDOW(pWin);

    while (WinPriv) {
        if (WinPriv->PortRec->type == XvInputMask)
            xf86XVReputVideo(WinPriv->PortRec);
        else
            xf86XVRegetVideo(WinPriv->PortRec);
        WinPriv = WinPriv->next;
    }

    return WT_WALKCHILDREN;
}

static int
xf86XVEnlistPortInWindow(WindowPtr pWin, XvPortRecPrivatePtr portPriv)
{
    XF86XVWindowPtr winPriv, PrivRoot;

    winPriv = PrivRoot = GET_XF86XV_WINDOW(pWin);

    /* Enlist our port in the window private */
    while (winPriv) {
        if (winPriv->PortRec == portPriv)       /* we're already listed */
            break;
        winPriv = winPriv->next;
    }

    if (!winPriv) {
        winPriv = calloc(1, sizeof(XF86XVWindowRec));
        if (!winPriv)
            return BadAlloc;
        winPriv->PortRec = portPriv;
        winPriv->next = PrivRoot;
        dixSetPrivate(&pWin->devPrivates, XF86XVWindowKey, winPriv);
    }

    portPriv->pDraw = (DrawablePtr) pWin;

    return Success;
}

static void
xf86XVRemovePortFromWindow(WindowPtr pWin, XvPortRecPrivatePtr portPriv)
{
    XF86XVWindowPtr winPriv, prevPriv = NULL;

    winPriv = GET_XF86XV_WINDOW(pWin);

    while (winPriv) {
        if (winPriv->PortRec == portPriv) {
            if (prevPriv)
                prevPriv->next = winPriv->next;
            else
                dixSetPrivate(&pWin->devPrivates, XF86XVWindowKey,
                              winPriv->next);
            free(winPriv);
            break;
        }
        prevPriv = winPriv;
        winPriv = winPriv->next;
    }
    portPriv->pDraw = NULL;
    if (portPriv->ckeyFilled) {
        RegionDestroy(portPriv->ckeyFilled);
        portPriv->ckeyFilled = NULL;
    }
    portPriv->clipChanged = FALSE;
}

static void
xf86XVReputOrStopPort(XvPortRecPrivatePtr pPriv, WindowPtr pWin, Bool visible)
{
    if (!visible) {
        if (pPriv->isOn == XV_ON) {
            (*pPriv->AdaptorRec->StopVideo) (pPriv->pScrn, pPriv->DevPriv.ptr,
                                             FALSE);
            pPriv->isOn = XV_PENDING;
        }

        if (!pPriv->type)       /* overlaid still/image */
            xf86XVRemovePortFromWindow(pWin, pPriv);

        return;
    }

    switch (pPriv->type) {
    case XvInputMask:
        xf86XVReputVideo(pPriv);
        break;
    case XvOutputMask:
        xf86XVRegetVideo(pPriv);
        break;
    default:                   /* overlaid still/image */
        if (pPriv->AdaptorRec->ReputImage)
            xf86XVReputImage(pPriv);
        break;
    }
}

static void
xf86XVReputOrStopAllPorts(ScrnInfoPtr pScrn, Bool onlyChanged)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
    XvAdaptorPtr pa;
    int c, i;

    for (c = pxvs->nAdaptors, pa = pxvs->pAdaptors; c > 0; c--, pa++) {
        XvPortPtr pPort = pa->pPorts;

        for (i = pa->nPorts; i > 0; i--, pPort++) {
            XvPortRecPrivatePtr pPriv =
                (XvPortRecPrivatePtr) pPort->devPriv.ptr;
            WindowPtr pWin = (WindowPtr) pPriv->pDraw;
            Bool visible;

            if (pPriv->isOn == XV_OFF || !pWin)
                continue;

            if (onlyChanged && !pPriv->clipChanged)
                continue;

            visible = pWin->visibility == VisibilityUnobscured ||
                pWin->visibility == VisibilityPartiallyObscured;

            /*
             * Stop and remove still/images if
             * ReputImage isn't supported.
             */
            if (!pPriv->type && !pPriv->AdaptorRec->ReputImage)
                visible = FALSE;

            xf86XVReputOrStopPort(pPriv, pWin, visible);

            pPriv->clipChanged = FALSE;
        }
    }
}

/****  ScreenRec fields ****/

static Bool
xf86XVDestroyWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
    XF86XVWindowPtr tmp, WinPriv = GET_XF86XV_WINDOW(pWin);
    int ret;

    while (WinPriv) {
        XvPortRecPrivatePtr pPriv = WinPriv->PortRec;

        if (pPriv->isOn > XV_OFF) {
            (*pPriv->AdaptorRec->StopVideo) (pPriv->pScrn, pPriv->DevPriv.ptr,
                                             TRUE);
            pPriv->isOn = XV_OFF;
        }

        pPriv->pDraw = NULL;
        tmp = WinPriv;
        WinPriv = WinPriv->next;
        free(tmp);
    }

    dixSetPrivate(&pWin->devPrivates, XF86XVWindowKey, NULL);

    pScreen->DestroyWindow = ScreenPriv->DestroyWindow;
    ret = (*pScreen->DestroyWindow) (pWin);
    pScreen->DestroyWindow = xf86XVDestroyWindow;

    return ret;
}

static void
xf86XVPostValidateTree(WindowPtr pWin, WindowPtr pLayerWin, VTKind kind)
{
    ScreenPtr pScreen;
    XF86XVScreenPtr ScreenPriv;
    ScrnInfoPtr pScrn;

    if (pWin)
        pScreen = pWin->drawable.pScreen;
    else
        pScreen = pLayerWin->drawable.pScreen;

    ScreenPriv = GET_XF86XV_SCREEN(pScreen);
    pScrn = xf86ScreenToScrn(pScreen);

    xf86XVReputOrStopAllPorts(pScrn, TRUE);

    pScreen->PostValidateTree = ScreenPriv->PostValidateTree;
    if (pScreen->PostValidateTree) {
        (*pScreen->PostValidateTree) (pWin, pLayerWin, kind);
    }
    ScreenPriv->PostValidateTree = PostValidateTreeUndefined;
}

static void
xf86XVWindowExposures(WindowPtr pWin, RegionPtr reg1)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
    XF86XVWindowPtr WinPriv = GET_XF86XV_WINDOW(pWin);
    XvPortRecPrivatePtr pPriv;
    Bool AreasExposed;

    AreasExposed = (WinPriv && reg1 && RegionNotEmpty(reg1));

    pScreen->WindowExposures = ScreenPriv->WindowExposures;
    (*pScreen->WindowExposures) (pWin, reg1);
    pScreen->WindowExposures = xf86XVWindowExposures;

    /* filter out XClearWindow/Area */
    if (!pWin->valdata)
        return;

    while (WinPriv) {
        Bool visible = TRUE;

        pPriv = WinPriv->PortRec;

        /*
         * Stop and remove still/images if areas were exposed and
         * ReputImage isn't supported.
         */
        if (!pPriv->type && !pPriv->AdaptorRec->ReputImage)
            visible = !AreasExposed;

        /*
         * Subtract exposed areas from overlaid image to match textured video
         * behavior.
         */
        if (!pPriv->type && pPriv->clientClip)
            RegionSubtract(pPriv->clientClip, pPriv->clientClip, reg1);

        if (visible && pPriv->ckeyFilled) {
            RegionRec tmp;

            RegionNull(&tmp);
            RegionCopy(&tmp, reg1);
            RegionTranslate(&tmp, pWin->drawable.x, pWin->drawable.y);
            RegionSubtract(pPriv->ckeyFilled, pPriv->ckeyFilled, &tmp);
        }

        WinPriv = WinPriv->next;
        xf86XVReputOrStopPort(pPriv, pWin, visible);

        pPriv->clipChanged = FALSE;
    }
}

static void
xf86XVClipNotify(WindowPtr pWin, int dx, int dy)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
    XF86XVWindowPtr WinPriv = GET_XF86XV_WINDOW(pWin);
    XvPortRecPrivatePtr pPriv;

    while (WinPriv) {
        pPriv = WinPriv->PortRec;

        if (pPriv->pCompositeClip && pPriv->FreeCompositeClip)
            RegionDestroy(pPriv->pCompositeClip);

        pPriv->pCompositeClip = NULL;

        pPriv->clipChanged = TRUE;

        if (ScreenPriv->PostValidateTree == PostValidateTreeUndefined) {
            ScreenPriv->PostValidateTree = pScreen->PostValidateTree;
            pScreen->PostValidateTree = xf86XVPostValidateTree;
        }

        WinPriv = WinPriv->next;
    }

    if (ScreenPriv->ClipNotify) {
        pScreen->ClipNotify = ScreenPriv->ClipNotify;
        (*pScreen->ClipNotify) (pWin, dx, dy);
        pScreen->ClipNotify = xf86XVClipNotify;
    }
}

/**** Required XvScreenRec fields ****/

static Bool
xf86XVCloseScreen(ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
    XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
    XvAdaptorPtr pa;
    int c;

    if (!ScreenPriv)
        return TRUE;

    pScreen->DestroyWindow = ScreenPriv->DestroyWindow;
    pScreen->WindowExposures = ScreenPriv->WindowExposures;
    pScreen->ClipNotify = ScreenPriv->ClipNotify;
    pScreen->CloseScreen = ScreenPriv->CloseScreen;

    pScrn->EnterVT = ScreenPriv->EnterVT;
    pScrn->LeaveVT = ScreenPriv->LeaveVT;
    pScrn->AdjustFrame = ScreenPriv->AdjustFrame;
    pScrn->ModeSet = ScreenPriv->ModeSet;

    for (c = 0, pa = pxvs->pAdaptors; c < pxvs->nAdaptors; c++, pa++) {
        xf86XVFreeAdaptor(pa);
    }

    free(pxvs->pAdaptors);
    free(ScreenPriv);

    return pScreen->CloseScreen(pScreen);
}

/**** ScrnInfoRec fields ****/

static Bool
xf86XVEnterVT(ScrnInfoPtr pScrn)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
    Bool ret;

    pScrn->EnterVT = ScreenPriv->EnterVT;
    ret = (*ScreenPriv->EnterVT) (pScrn);
    ScreenPriv->EnterVT = pScrn->EnterVT;
    pScrn->EnterVT = xf86XVEnterVT;

    if (ret)
        WalkTree(pScreen, xf86XVReputAllVideo, 0);

    return ret;
}

static void
xf86XVLeaveVT(ScrnInfoPtr pScrn)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
    XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
    XvAdaptorPtr pAdaptor;
    XvPortPtr pPort;
    XvPortRecPrivatePtr pPriv;
    int i, j;

    for (i = 0; i < pxvs->nAdaptors; i++) {
        pAdaptor = &pxvs->pAdaptors[i];
        for (j = 0; j < pAdaptor->nPorts; j++) {
            pPort = &pAdaptor->pPorts[j];
            pPriv = (XvPortRecPrivatePtr) pPort->devPriv.ptr;
            if (pPriv->isOn > XV_OFF) {

                (*pPriv->AdaptorRec->StopVideo) (pPriv->pScrn,
                                                 pPriv->DevPriv.ptr, TRUE);
                pPriv->isOn = XV_OFF;

                if (pPriv->pCompositeClip && pPriv->FreeCompositeClip)
                    RegionDestroy(pPriv->pCompositeClip);

                pPriv->pCompositeClip = NULL;

                if (!pPriv->type && pPriv->pDraw) {     /* still */
                    xf86XVRemovePortFromWindow((WindowPtr) pPriv->pDraw, pPriv);
                }
            }
        }
    }

    pScrn->LeaveVT = ScreenPriv->LeaveVT;
    (*ScreenPriv->LeaveVT) (pScrn);
    ScreenPriv->LeaveVT = pScrn->LeaveVT;
    pScrn->LeaveVT = xf86XVLeaveVT;
}

static void
xf86XVAdjustFrame(ScrnInfoPtr pScrn, int x, int y)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);

    if (ScreenPriv->AdjustFrame) {
        pScrn->AdjustFrame = ScreenPriv->AdjustFrame;
        (*pScrn->AdjustFrame) (pScrn, x, y);
        pScrn->AdjustFrame = xf86XVAdjustFrame;
    }

    xf86XVReputOrStopAllPorts(pScrn, FALSE);
}

static void
xf86XVModeSet(ScrnInfoPtr pScrn)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    XF86XVScreenPtr ScreenPriv;

    /* Can be called before pScrn->pScreen is set */
    if (!pScreen)
        return;

    ScreenPriv = GET_XF86XV_SCREEN(pScreen);

    if (ScreenPriv->ModeSet) {
        pScrn->ModeSet = ScreenPriv->ModeSet;
        (*pScrn->ModeSet) (pScrn);
        pScrn->ModeSet = xf86XVModeSet;
    }

    xf86XVReputOrStopAllPorts(pScrn, FALSE);
}

/**** XvAdaptorRec fields ****/

static int
xf86XVPutVideo(DrawablePtr pDraw,
               XvPortPtr pPort,
               GCPtr pGC,
               INT16 vid_x, INT16 vid_y,
               CARD16 vid_w, CARD16 vid_h,
               INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);
    int result;

    /* No dumping video to pixmaps... For now anyhow */
    if (pDraw->type != DRAWABLE_WINDOW) {
        pPort->pDraw = (DrawablePtr) NULL;
        return BadAlloc;
    }

    /* If we are changing windows, unregister our port in the old window */
    if (portPriv->pDraw && (portPriv->pDraw != pDraw))
        xf86XVRemovePortFromWindow((WindowPtr) (portPriv->pDraw), portPriv);

    /* Register our port with the new window */
    result = xf86XVEnlistPortInWindow((WindowPtr) pDraw, portPriv);
    if (result != Success)
        return result;

    portPriv->type = XvInputMask;

    /* save a copy of these parameters */
    portPriv->vid_x = vid_x;
    portPriv->vid_y = vid_y;
    portPriv->vid_w = vid_w;
    portPriv->vid_h = vid_h;
    portPriv->drw_x = drw_x;
    portPriv->drw_y = drw_y;
    portPriv->drw_w = drw_w;
    portPriv->drw_h = drw_h;

    /* make sure we have the most recent copy of the clientClip */
    xf86XVCopyClip(portPriv, pGC);

    /* To indicate to the DI layer that we were successful */
    pPort->pDraw = pDraw;

    if (!portPriv->pScrn->vtSema)
        return Success;         /* Success ? */

    return (xf86XVReputVideo(portPriv));
}

static int
xf86XVPutStill(DrawablePtr pDraw,
               XvPortPtr pPort,
               GCPtr pGC,
               INT16 vid_x, INT16 vid_y,
               CARD16 vid_w, CARD16 vid_h,
               INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    int ret = Success;
    Bool clippedAway = FALSE;

    if (pDraw->type != DRAWABLE_WINDOW)
        return BadAlloc;

    if (!portPriv->pScrn->vtSema)
        return Success;         /* Success ? */

    WinBox.x1 = pDraw->x + drw_x;
    WinBox.y1 = pDraw->y + drw_y;
    WinBox.x2 = WinBox.x1 + drw_w;
    WinBox.y2 = WinBox.y1 + drw_h;

    xf86XVCopyCompositeClip(portPriv, pGC, pDraw);

    RegionInit(&WinRegion, &WinBox, 1);
    RegionNull(&ClipRegion);
    RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

    if (portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
        RegionRec VPReg;
        BoxRec VPBox;

        VPBox.x1 = portPriv->pScrn->frameX0;
        VPBox.y1 = portPriv->pScrn->frameY0;
        VPBox.x2 = portPriv->pScrn->frameX1 + 1;
        VPBox.y2 = portPriv->pScrn->frameY1 + 1;

        RegionInit(&VPReg, &VPBox, 1);
        RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
        RegionUninit(&VPReg);
    }

    if (portPriv->pDraw) {
        xf86XVRemovePortFromWindow((WindowPtr) (portPriv->pDraw), portPriv);
    }

    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto PUT_STILL_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->PutStill) (portPriv->pScrn,
                                             vid_x, vid_y, WinBox.x1, WinBox.y1,
                                             vid_w, vid_h, drw_w, drw_h,
                                             &ClipRegion, portPriv->DevPriv.ptr,
                                             pDraw);

    if ((ret == Success) &&
        (portPriv->AdaptorRec->flags & VIDEO_OVERLAID_STILLS)) {

        xf86XVEnlistPortInWindow((WindowPtr) pDraw, portPriv);
        portPriv->isOn = XV_ON;
        portPriv->vid_x = vid_x;
        portPriv->vid_y = vid_y;
        portPriv->vid_w = vid_w;
        portPriv->vid_h = vid_h;
        portPriv->drw_x = drw_x;
        portPriv->drw_y = drw_y;
        portPriv->drw_w = drw_w;
        portPriv->drw_h = drw_h;
        portPriv->type = 0;     /* no mask means it's transient and should
                                   not be reput once it's removed */
        pPort->pDraw = pDraw;   /* make sure we can get stop requests */
    }

 PUT_STILL_BAILOUT:

    if ((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->pScrn,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    /* This clip was copied and only good for one shot */
    if (!portPriv->FreeCompositeClip)
        portPriv->pCompositeClip = NULL;

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
xf86XVGetVideo(DrawablePtr pDraw,
               XvPortPtr pPort,
               GCPtr pGC,
               INT16 vid_x, INT16 vid_y,
               CARD16 vid_w, CARD16 vid_h,
               INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);
    int result;

    /* No pixmaps... For now anyhow */
    if (pDraw->type != DRAWABLE_WINDOW) {
        pPort->pDraw = (DrawablePtr) NULL;
        return BadAlloc;
    }

    /* If we are changing windows, unregister our port in the old window */
    if (portPriv->pDraw && (portPriv->pDraw != pDraw))
        xf86XVRemovePortFromWindow((WindowPtr) (portPriv->pDraw), portPriv);

    /* Register our port with the new window */
    result = xf86XVEnlistPortInWindow((WindowPtr) pDraw, portPriv);
    if (result != Success)
        return result;

    portPriv->type = XvOutputMask;

    /* save a copy of these parameters */
    portPriv->vid_x = vid_x;
    portPriv->vid_y = vid_y;
    portPriv->vid_w = vid_w;
    portPriv->vid_h = vid_h;
    portPriv->drw_x = drw_x;
    portPriv->drw_y = drw_y;
    portPriv->drw_w = drw_w;
    portPriv->drw_h = drw_h;

    /* make sure we have the most recent copy of the clientClip */
    xf86XVCopyClip(portPriv, pGC);

    /* To indicate to the DI layer that we were successful */
    pPort->pDraw = pDraw;

    if (!portPriv->pScrn->vtSema)
        return Success;         /* Success ? */

    return (xf86XVRegetVideo(portPriv));
}

static int
xf86XVGetStill(DrawablePtr pDraw,
               XvPortPtr pPort,
               GCPtr pGC,
               INT16 vid_x, INT16 vid_y,
               CARD16 vid_w, CARD16 vid_h,
               INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    int ret = Success;
    Bool clippedAway = FALSE;

    if (pDraw->type != DRAWABLE_WINDOW)
        return BadAlloc;

    if (!portPriv->pScrn->vtSema)
        return Success;         /* Success ? */

    WinBox.x1 = pDraw->x + drw_x;
    WinBox.y1 = pDraw->y + drw_y;
    WinBox.x2 = WinBox.x1 + drw_w;
    WinBox.y2 = WinBox.y1 + drw_h;

    RegionInit(&WinRegion, &WinBox, 1);
    RegionNull(&ClipRegion);
    RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

    if (portPriv->pDraw) {
        xf86XVRemovePortFromWindow((WindowPtr) (portPriv->pDraw), portPriv);
    }

    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto GET_STILL_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->GetStill) (portPriv->pScrn,
                                             vid_x, vid_y, WinBox.x1, WinBox.y1,
                                             vid_w, vid_h, drw_w, drw_h,
                                             &ClipRegion, portPriv->DevPriv.ptr,
                                             pDraw);

 GET_STILL_BAILOUT:

    if ((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->pScrn,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
xf86XVStopVideo(XvPortPtr pPort, DrawablePtr pDraw)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    if (pDraw->type != DRAWABLE_WINDOW)
        return BadAlloc;

    xf86XVRemovePortFromWindow((WindowPtr) pDraw, portPriv);

    if (!portPriv->pScrn->vtSema)
        return Success;         /* Success ? */

    /* Must free resources. */

    if (portPriv->isOn > XV_OFF) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->pScrn,
                                            portPriv->DevPriv.ptr, TRUE);
        portPriv->isOn = XV_OFF;
    }

    return Success;
}

static int
xf86XVSetPortAttribute(XvPortPtr pPort, Atom attribute, INT32 value)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    return ((*portPriv->AdaptorRec->SetPortAttribute) (portPriv->pScrn,
                                                       attribute, value,
                                                       portPriv->DevPriv.ptr));
}

static int
xf86XVGetPortAttribute(XvPortPtr pPort, Atom attribute, INT32 *p_value)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    return ((*portPriv->AdaptorRec->GetPortAttribute) (portPriv->pScrn,
                                                       attribute, p_value,
                                                       portPriv->DevPriv.ptr));
}

static int
xf86XVQueryBestSize(XvPortPtr pPort,
                    CARD8 motion,
                    CARD16 vid_w, CARD16 vid_h,
                    CARD16 drw_w, CARD16 drw_h,
                    unsigned int *p_w, unsigned int *p_h)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    (*portPriv->AdaptorRec->QueryBestSize) (portPriv->pScrn,
                                            (Bool) motion, vid_w, vid_h, drw_w,
                                            drw_h, p_w, p_h,
                                            portPriv->DevPriv.ptr);

    return Success;
}

static int
xf86XVPutImage(DrawablePtr pDraw,
               XvPortPtr pPort,
               GCPtr pGC,
               INT16 src_x, INT16 src_y,
               CARD16 src_w, CARD16 src_h,
               INT16 drw_x, INT16 drw_y,
               CARD16 drw_w, CARD16 drw_h,
               XvImagePtr format,
               unsigned char *data, Bool sync, CARD16 width, CARD16 height)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);
    RegionRec WinRegion;
    RegionRec ClipRegion;
    BoxRec WinBox;
    int ret = Success;
    Bool clippedAway = FALSE;

    if (pDraw->type != DRAWABLE_WINDOW)
        return BadAlloc;

    if (!portPriv->pScrn->vtSema)
        return Success;         /* Success ? */

    xf86XVCopyCompositeClip(portPriv, pGC, pDraw);

    WinBox.x1 = pDraw->x + drw_x;
    WinBox.y1 = pDraw->y + drw_y;
    WinBox.x2 = WinBox.x1 + drw_w;
    WinBox.y2 = WinBox.y1 + drw_h;

    RegionInit(&WinRegion, &WinBox, 1);
    RegionNull(&ClipRegion);
    RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

    if (portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
        RegionRec VPReg;
        BoxRec VPBox;

        VPBox.x1 = portPriv->pScrn->frameX0;
        VPBox.y1 = portPriv->pScrn->frameY0;
        VPBox.x2 = portPriv->pScrn->frameX1 + 1;
        VPBox.y2 = portPriv->pScrn->frameY1 + 1;

        RegionInit(&VPReg, &VPBox, 1);
        RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
        RegionUninit(&VPReg);
    }

    /* If we are changing windows, unregister our port in the old window */
    if (portPriv->pDraw && (portPriv->pDraw != pDraw))
        xf86XVRemovePortFromWindow((WindowPtr) (portPriv->pDraw), portPriv);

    /* Register our port with the new window */
    ret = xf86XVEnlistPortInWindow((WindowPtr) pDraw, portPriv);
    if (ret != Success)
        goto PUT_IMAGE_BAILOUT;

    if (!RegionNotEmpty(&ClipRegion)) {
        clippedAway = TRUE;
        goto PUT_IMAGE_BAILOUT;
    }

    ret = (*portPriv->AdaptorRec->PutImage) (portPriv->pScrn,
                                             src_x, src_y, WinBox.x1, WinBox.y1,
                                             src_w, src_h, drw_w, drw_h,
                                             format->id, data, width, height,
                                             sync, &ClipRegion,
                                             portPriv->DevPriv.ptr, pDraw);

    if ((ret == Success) &&
        (portPriv->AdaptorRec->flags & VIDEO_OVERLAID_IMAGES)) {

        portPriv->isOn = XV_ON;
        portPriv->vid_x = src_x;
        portPriv->vid_y = src_y;
        portPriv->vid_w = src_w;
        portPriv->vid_h = src_h;
        portPriv->drw_x = drw_x;
        portPriv->drw_y = drw_y;
        portPriv->drw_w = drw_w;
        portPriv->drw_h = drw_h;
        portPriv->type = 0;     /* no mask means it's transient and should
                                   not be reput once it's removed */
        pPort->pDraw = pDraw;   /* make sure we can get stop requests */
    }

 PUT_IMAGE_BAILOUT:

    if ((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
        (*portPriv->AdaptorRec->StopVideo) (portPriv->pScrn,
                                            portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
    }

    /* This clip was copied and only good for one shot */
    if (!portPriv->FreeCompositeClip)
        portPriv->pCompositeClip = NULL;

    RegionUninit(&WinRegion);
    RegionUninit(&ClipRegion);

    return ret;
}

static int
xf86XVQueryImageAttributes(XvPortPtr pPort,
                           XvImagePtr format,
                           CARD16 *width,
                           CARD16 *height, int *pitches, int *offsets)
{
    XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    return (*portPriv->AdaptorRec->QueryImageAttributes) (portPriv->pScrn,
                                                          format->id, width,
                                                          height, pitches,
                                                          offsets);
}

void
xf86XVFillKeyHelperDrawable(DrawablePtr pDraw, CARD32 key, RegionPtr fillboxes)
{
    ScreenPtr pScreen = pDraw->pScreen;

    if (!xf86ScreenToScrn(pScreen)->vtSema)
        return;

    XvFillColorKey(pDraw, key, fillboxes);
}

void
xf86XVFillKeyHelper(ScreenPtr pScreen, CARD32 key, RegionPtr fillboxes)
{
    xf86XVFillKeyHelperDrawable(&pScreen->root->drawable, key, fillboxes);
}

void
xf86XVFillKeyHelperPort(DrawablePtr pDraw, void *data, CARD32 key,
                        RegionPtr clipboxes, Bool fillEverything)
{
    WindowPtr pWin = (WindowPtr) pDraw;
    XF86XVWindowPtr WinPriv = GET_XF86XV_WINDOW(pWin);
    XvPortRecPrivatePtr portPriv = NULL;
    RegionRec reg;
    RegionPtr fillboxes;

    while (WinPriv) {
        XvPortRecPrivatePtr pPriv = WinPriv->PortRec;

        if (data == pPriv->DevPriv.ptr) {
            portPriv = pPriv;
            break;
        }

        WinPriv = WinPriv->next;
    }

    if (!portPriv)
        return;

    if (!portPriv->ckeyFilled)
        portPriv->ckeyFilled = RegionCreate(NULL, 0);

    if (!fillEverything) {
        RegionNull(&reg);
        fillboxes = &reg;
        RegionSubtract(fillboxes, clipboxes, portPriv->ckeyFilled);

        if (!RegionNotEmpty(fillboxes))
            goto out;
    }
    else
        fillboxes = clipboxes;

    RegionCopy(portPriv->ckeyFilled, clipboxes);

    xf86XVFillKeyHelperDrawable(pDraw, key, fillboxes);
 out:
    if (!fillEverything)
        RegionUninit(&reg);
}

/* xf86XVClipVideoHelper -

   Takes the dst box in standard X BoxRec form (top and left
   edges inclusive, bottom and right exclusive).  The new dst
   box is returned.  The source boundaries are given (x1, y1
   inclusive, x2, y2 exclusive) and returned are the new source
   boundaries in 16.16 fixed point.
*/

Bool
xf86XVClipVideoHelper(BoxPtr dst,
                      INT32 *xa,
                      INT32 *xb,
                      INT32 *ya,
                      INT32 *yb, RegionPtr reg, INT32 width, INT32 height)
{
    double xsw, xdw, ysw, ydw;
    INT32 delta;
    BoxPtr extents = RegionExtents(reg);
    int diff;

    xsw = (*xb - *xa) << 16;
    xdw = dst->x2 - dst->x1;
    ysw = (*yb - *ya) << 16;
    ydw = dst->y2 - dst->y1;

    *xa <<= 16;
    *xb <<= 16;
    *ya <<= 16;
    *yb <<= 16;

    diff = extents->x1 - dst->x1;
    if (diff > 0) {
        dst->x1 = extents->x1;
        *xa += (diff * xsw) / xdw;
    }
    diff = dst->x2 - extents->x2;
    if (diff > 0) {
        dst->x2 = extents->x2;
        *xb -= (diff * xsw) / xdw;
    }
    diff = extents->y1 - dst->y1;
    if (diff > 0) {
        dst->y1 = extents->y1;
        *ya += (diff * ysw) / ydw;
    }
    diff = dst->y2 - extents->y2;
    if (diff > 0) {
        dst->y2 = extents->y2;
        *yb -= (diff * ysw) / ydw;
    }

    if (*xa < 0) {
        diff = (((-*xa) * xdw) + xsw - 1) / xsw;
        dst->x1 += diff;
        *xa += (diff * xsw) / xdw;
    }
    delta = *xb - (width << 16);
    if (delta > 0) {
        diff = ((delta * xdw) + xsw - 1) / xsw;
        dst->x2 -= diff;
        *xb -= (diff * xsw) / xdw;
    }
    if (*xa >= *xb)
        return FALSE;

    if (*ya < 0) {
        diff = (((-*ya) * ydw) + ysw - 1) / ysw;
        dst->y1 += diff;
        *ya += (diff * ysw) / ydw;
    }
    delta = *yb - (height << 16);
    if (delta > 0) {
        diff = ((delta * ydw) + ysw - 1) / ysw;
        dst->y2 -= diff;
        *yb -= (diff * ysw) / ydw;
    }
    if (*ya >= *yb)
        return FALSE;

    if ((dst->x1 > extents->x1) || (dst->x2 < extents->x2) ||
        (dst->y1 > extents->y1) || (dst->y2 < extents->y2)) {
        RegionRec clipReg;

        RegionInit(&clipReg, dst, 1);
        RegionIntersect(reg, reg, &clipReg);
        RegionUninit(&clipReg);
    }
    return TRUE;
}

void
xf86XVCopyYUV12ToPacked(const void *srcy,
                        const void *srcv,
                        const void *srcu,
                        void *dst,
                        int srcPitchy,
                        int srcPitchuv, int dstPitch, int h, int w)
{
    CARD32 *Dst;
    const CARD8 *Y, *U, *V;
    int i, j;

    w >>= 1;

    for (j = 0; j < h; j++) {
        Dst = dst;
        Y = srcy;
        V = srcv;
        U = srcu;
        i = w;
        while (i >= 4) {
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
            Dst[0] = Y[0] | (Y[1] << 16) | (U[0] << 8) | (V[0] << 24);
            Dst[1] = Y[2] | (Y[3] << 16) | (U[1] << 8) | (V[1] << 24);
            Dst[2] = Y[4] | (Y[5] << 16) | (U[2] << 8) | (V[2] << 24);
            Dst[3] = Y[6] | (Y[7] << 16) | (U[3] << 8) | (V[3] << 24);
#else
            /* This assumes a little-endian framebuffer */
            Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | V[0];
            Dst[1] = (Y[2] << 24) | (Y[3] << 8) | (U[1] << 16) | V[1];
            Dst[2] = (Y[4] << 24) | (Y[5] << 8) | (U[2] << 16) | V[2];
            Dst[3] = (Y[6] << 24) | (Y[7] << 8) | (U[3] << 16) | V[3];
#endif
            Dst += 4;
            Y += 8;
            V += 4;
            U += 4;
            i -= 4;
        }

        while (i--) {
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
            Dst[0] = Y[0] | (Y[1] << 16) | (U[0] << 8) | (V[0] << 24);
#else
            /* This assumes a little-endian framebuffer */
            Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | V[0];
#endif
            Dst++;
            Y += 2;
            V++;
            U++;
        }

        dst = (CARD8 *) dst + dstPitch;
        srcy = (const CARD8 *) srcy + srcPitchy;
        if (j & 1) {
            srcu = (const CARD8 *) srcu + srcPitchuv;
            srcv = (const CARD8 *) srcv + srcPitchuv;
        }
    }
}

void
xf86XVCopyPacked(const void *src,
                 void *dst, int srcPitch, int dstPitch, int h, int w)
{
    const CARD32 *Src;
    CARD32 *Dst;
    int i;

    w >>= 1;
    while (--h >= 0) {
        do {
            Dst = dst;
            Src = src;
            i = w;
            while (i >= 4) {
                Dst[0] = Src[0];
                Dst[1] = Src[1];
                Dst[2] = Src[2];
                Dst[3] = Src[3];
                Dst += 4;
                Src += 4;
                i -= 4;
            }
            if (!i)
                break;
            Dst[0] = Src[0];
            if (i == 1)
                break;
            Dst[1] = Src[1];
            if (i == 2)
                break;
            Dst[2] = Src[2];
        } while (0);

        src = (const CARD8 *) src + srcPitch;
        dst = (CARD8 *) dst + dstPitch;
    }
}
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d134 2
a135 2
    newdrivers = realloc(GenDrivers, sizeof(xf86XVInitGenericAdaptorPtr) *
                         (1 + NumGenDrivers));
d162 1
a162 1
        new = realloc(*adaptors, sizeof(XF86VideoAdaptorPtr) * (num + n));
d439 2
a440 2
                        moreSpace = realloc(pFormat,
                                            totFormat * sizeof(XvFormatRec));
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a56 5
/* XvScreenRec fields */

static Bool xf86XVCloseScreen(ScreenPtr);
static int xf86XVQueryAdaptors(ScreenPtr, XvAdaptorPtr *, int *);

d59 1
a59 3
static int xf86XVAllocatePort(unsigned long, XvPortPtr, XvPortPtr *);
static int xf86XVFreePort(XvPortPtr);
static int xf86XVPutVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
d62 1
a62 1
static int xf86XVPutStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
d65 1
a65 1
static int xf86XVGetVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
d68 1
a68 1
static int xf86XVGetStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
d71 4
a74 4
static int xf86XVStopVideo(ClientPtr, XvPortPtr, DrawablePtr);
static int xf86XVSetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32);
static int xf86XVGetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32 *);
static int xf86XVQueryBestSize(ClientPtr, XvPortPtr, CARD8,
d77 1
a77 1
static int xf86XVPutImage(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
d81 1
a81 1
static int xf86XVQueryImageAttributes(ClientPtr, XvPortPtr, XvImagePtr,
d87 1
a87 1
static void xf86XVWindowExposures(WindowPtr pWin, RegionPtr r1, RegionPtr r2);
d91 1
d110 1
d112 2
d121 1
a121 1
    ((XF86XVScreenPtr)(GET_XV_SCREEN(pScreen)->devPriv.ptr))
a231 1
    XvScreenPtr pxvs;
d241 2
a247 13
    pxvs = GET_XV_SCREEN(pScreen);

    /* Anyone initializing the Xv layer must provide these two.
       The Xv di layer calls them without even checking if they exist! */

    pxvs->ddCloseScreen = xf86XVCloseScreen;
    pxvs->ddQueryAdaptors = xf86XVQueryAdaptors;

    /* The Xv di layer provides us with a private hook so that we don't
       have to allocate our own screen private.  They also provide
       a CloseScreen hook so that we don't have to wrap it.  I'm not
       sure that I appreciate that.  */

d249 1
a249 1
    pxvs->devPriv.ptr = (void *) ScreenPriv;
d260 1
d269 1
a286 15
    free(pAdaptor->name);
    pAdaptor->name = NULL;

    if (pAdaptor->pEncodings) {
        XvEncodingPtr pEncode = pAdaptor->pEncodings;

        for (i = 0; i < pAdaptor->nEncodings; i++, pEncode++)
            free(pEncode->name);
        free(pAdaptor->pEncodings);
        pAdaptor->pEncodings = NULL;
    }

    free(pAdaptor->pFormats);
    pAdaptor->pFormats = NULL;

a302 2
        free(pAdaptor->pPorts);
        pAdaptor->pPorts = NULL;
d305 1
a305 13
    if (pAdaptor->pAttributes) {
        XvAttributePtr pAttribute = pAdaptor->pAttributes;

        for (i = 0; i < pAdaptor->nAttributes; i++, pAttribute++)
            free(pAttribute->name);
        free(pAdaptor->pAttributes);
        pAdaptor->pAttributes = NULL;
    }

    free(pAdaptor->pImages);
    free(pAdaptor->devPriv.ptr);
    pAdaptor->pImages = NULL;
    pAdaptor->devPriv.ptr = NULL;
a319 2
    XF86AttributePtr attributePtr;
    XvAttributePtr pAttribute, pat;
a324 2
    XF86ImagePtr imagePtr;
    XvImagePtr pImage, pi;
a369 2
        pa->ddAllocatePort = xf86XVAllocatePort;
        pa->ddFreePort = xf86XVFreePort;
d400 3
a402 27
            (pImage = calloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {

            for (i = 0, pi = pImage, imagePtr = adaptorPtr->pImages;
                 i < adaptorPtr->nImages; i++, pi++, imagePtr++) {
                pi->id = imagePtr->id;
                pi->type = imagePtr->type;
                pi->byte_order = imagePtr->byte_order;
                memcpy(pi->guid, imagePtr->guid, 16);
                pi->bits_per_pixel = imagePtr->bits_per_pixel;
                pi->format = imagePtr->format;
                pi->num_planes = imagePtr->num_planes;
                pi->depth = imagePtr->depth;
                pi->red_mask = imagePtr->red_mask;
                pi->green_mask = imagePtr->green_mask;
                pi->blue_mask = imagePtr->blue_mask;
                pi->y_sample_bits = imagePtr->y_sample_bits;
                pi->u_sample_bits = imagePtr->u_sample_bits;
                pi->v_sample_bits = imagePtr->v_sample_bits;
                pi->horz_y_period = imagePtr->horz_y_period;
                pi->horz_u_period = imagePtr->horz_u_period;
                pi->horz_v_period = imagePtr->horz_v_period;
                pi->vert_y_period = imagePtr->vert_y_period;
                pi->vert_u_period = imagePtr->vert_u_period;
                pi->vert_v_period = imagePtr->vert_v_period;
                memcpy(pi->component_order, imagePtr->component_order, 32);
                pi->scanline_order = imagePtr->scanline_order;
            }
a403 1
            pa->pImages = pImage;
d407 8
a414 8
            (pAttribute =
             calloc(adaptorPtr->nAttributes, sizeof(XvAttributeRec)))) {
            for (pat = pAttribute, attributePtr = adaptorPtr->pAttributes, i =
                 0; i < adaptorPtr->nAttributes; pat++, i++, attributePtr++) {
                pat->flags = attributePtr->flags;
                pat->min_value = attributePtr->min_value;
                pat->max_value = attributePtr->max_value;
                pat->name = strdup(attributePtr->name);
d416 1
a417 1
            pa->pAttributes = pAttribute;
d602 1
a602 1
    if ((pGC->clientClipType == CT_REGION) && pGC->clientClip) {
a670 4
    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

a742 16
    /* bailout if we have to clip but the hardware doesn't support it */
    if (portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
        BoxPtr clipBox = RegionRects(&ClipRegion);

        if ((RegionNumRects(&ClipRegion) != 1) ||
            (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
            (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) {
            clippedAway = TRUE;
            goto CLIP_VIDEO_BAILOUT;
        }
    }

    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

a820 16
    /* bailout if we have to clip but the hardware doesn't support it */
    if (portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
        BoxPtr clipBox = RegionRects(&ClipRegion);

        if ((RegionNumRects(&ClipRegion) != 1) ||
            (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
            (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) {
            clippedAway = TRUE;
            goto CLIP_VIDEO_BAILOUT;
        }
    }

    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

d1051 1
a1051 1
xf86XVWindowExposures(WindowPtr pWin, RegionPtr reg1, RegionPtr reg2)
d1062 1
a1062 1
    (*pScreen->WindowExposures) (pWin, reg1, reg2);
a1119 4
        if (pPriv->AdaptorRec->ClipNotify)
            (*pPriv->AdaptorRec->ClipNotify) (pPriv->pScrn, pPriv->DevPriv.ptr,
                                              pWin, dx, dy);

d1154 1
a1166 2
    return TRUE;
}
d1168 1
a1168 10
static int
xf86XVQueryAdaptors(ScreenPtr pScreen,
                    XvAdaptorPtr * p_pAdaptors, int *p_nAdaptors)
{
    XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);

    *p_nAdaptors = pxvs->nAdaptors;
    *p_pAdaptors = pxvs->pAdaptors;

    return Success;
d1270 1
a1270 15
xf86XVAllocatePort(unsigned long port, XvPortPtr pPort, XvPortPtr * ppPort)
{
    *ppPort = pPort;
    return Success;
}

static int
xf86XVFreePort(XvPortPtr pPort)
{
    return Success;
}

static int
xf86XVPutVideo(ClientPtr client,
               DrawablePtr pDraw,
d1320 1
a1320 2
xf86XVPutStill(ClientPtr client,
               DrawablePtr pDraw,
a1373 15
    if (portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
        BoxPtr clipBox = RegionRects(&ClipRegion);

        if ((RegionNumRects(&ClipRegion) != 1) ||
            (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
            (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) {
            clippedAway = TRUE;
            goto PUT_STILL_BAILOUT;
        }
    }

    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

d1417 1
a1417 2
xf86XVGetVideo(ClientPtr client,
               DrawablePtr pDraw,
d1467 1
a1467 2
xf86XVGetStill(ClientPtr client,
               DrawablePtr pDraw,
a1504 4
    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

d1526 1
a1526 1
xf86XVStopVideo(ClientPtr client, XvPortPtr pPort, DrawablePtr pDraw)
d1550 1
a1550 2
xf86XVSetPortAttribute(ClientPtr client,
                       XvPortPtr pPort, Atom attribute, INT32 value)
d1560 1
a1560 2
xf86XVGetPortAttribute(ClientPtr client,
                       XvPortPtr pPort, Atom attribute, INT32 *p_value)
d1570 1
a1570 2
xf86XVQueryBestSize(ClientPtr client,
                    XvPortPtr pPort,
d1587 1
a1587 2
xf86XVPutImage(ClientPtr client,
               DrawablePtr pDraw,
a1648 15
    if (portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
        BoxPtr clipBox = RegionRects(&ClipRegion);

        if ((RegionNumRects(&ClipRegion) != 1) ||
            (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
            (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) {
            clippedAway = TRUE;
            goto PUT_IMAGE_BAILOUT;
        }
    }

    if (portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
        RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
    }

d1692 1
a1692 2
xf86XVQueryImageAttributes(ClientPtr client,
                           XvPortPtr pPort,
a1708 5
    ChangeGCVal pval[2];
    BoxPtr pbox = RegionRects(fillboxes);
    int i, nbox = RegionNumRects(fillboxes);
    xRectangle *rects;
    GCPtr gc;
d1713 1
a1713 19
    gc = GetScratchGC(pDraw->depth, pScreen);
    pval[0].val = key;
    pval[1].val = IncludeInferiors;
    (void) ChangeGC(NullClient, gc, GCForeground | GCSubwindowMode, pval);
    ValidateGC(pDraw, gc);

    rects = malloc(nbox * sizeof(xRectangle));

    for (i = 0; i < nbox; i++, pbox++) {
        rects[i].x = pbox->x1 - pDraw->x;
        rects[i].y = pbox->y1 - pDraw->y;
        rects[i].width = pbox->x2 - pbox->x1;
        rects[i].height = pbox->y2 - pbox->y1;
    }

    (*gc->ops->PolyFillRect) (pDraw, gc, nbox, rects);

    free(rects);
    FreeScratchGC(gc);
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d264 1
a264 1
    pxvs->devPriv.ptr = (pointer) ScreenPriv;
d554 1
a554 1
        pa->devPriv.ptr = (pointer) adaptorPriv;
d960 1
a960 1
xf86XVReputAllVideo(WindowPtr pWin, pointer data)
d1925 1
a1925 1
xf86XVFillKeyHelperPort(DrawablePtr pDraw, pointer data, CARD32 key,
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a53 1
#include "xvmodproc.h"
d59 1
a59 1
static Bool xf86XVCloseScreen(int, ScreenPtr);
d103 3
a105 3
static Bool xf86XVEnterVT(int, int);
static void xf86XVLeaveVT(int, int);
static void xf86XVAdjustFrame(int index, int x, int y, int flags);
a119 4
DevPrivateKey (*XvGetScreenKeyProc) (void) = NULL;
unsigned long (*XvGetRTPortProc) (void) = NULL;
int (*XvScreenInitProc) (ScreenPtr) = NULL;

d237 1
a237 2
    if (num <= 0 ||
        !XvGetScreenKeyProc || !XvGetRTPortProc || !XvScreenInitProc)
d240 1
a240 1
    if (Success != (*XvScreenInitProc) (pScreen))
d246 1
a246 1
    XF86XvScreenKey = (*XvGetScreenKeyProc) ();
d248 1
a248 1
    PortResource = (*XvGetRTPortProc) ();
d269 1
a269 1
    pScrn = xf86Screens[pScreen->myNum];
d354 1
a354 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1064 1
a1064 1
    ScreenPtr pScreen = pScrn->pScreen;
d1148 1
a1148 1
    pScrn = xf86Screens[pScreen->myNum];
d1253 1
a1253 1
xf86XVCloseScreen(int i, ScreenPtr pScreen)
d1255 1
a1255 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1297 1
a1297 1
xf86XVEnterVT(int index, int flags)
d1299 1
a1299 2
    ScrnInfoPtr pScrn = xf86Screens[index];
    ScreenPtr pScreen = screenInfo.screens[index];
d1304 1
a1304 1
    ret = (*ScreenPriv->EnterVT) (index, flags);
d1315 1
a1315 1
xf86XVLeaveVT(int index, int flags)
d1317 1
a1317 2
    ScrnInfoPtr pScrn = xf86Screens[index];
    ScreenPtr pScreen = screenInfo.screens[index];
d1349 1
a1349 1
    (*ScreenPriv->LeaveVT) (index, flags);
d1355 1
a1355 1
xf86XVAdjustFrame(int index, int x, int y, int flags)
d1357 1
a1357 2
    ScrnInfoPtr pScrn = xf86Screens[index];
    ScreenPtr pScreen = pScrn->pScreen;
d1362 1
a1362 1
        (*pScrn->AdjustFrame) (index, x, y, flags);
d1372 1
a1372 1
    ScreenPtr pScreen = pScrn->pScreen;
d1894 1
a1894 1
    if (!xf86Screens[pScreen->myNum]->vtSema)
@


1.6
log
@Update to xserver 1.11.2
@
text
@a30 1

a57 1

d65 1
a65 1
static int xf86XVAllocatePort(unsigned long, XvPortPtr, XvPortPtr*);
d67 12
a78 12
static int xf86XVPutVideo(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
static int xf86XVPutStill(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
static int xf86XVGetVideo(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
static int xf86XVGetStill(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
d81 1
a81 1
static int xf86XVGetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32*);
d83 2
a84 2
				CARD16, CARD16,CARD16, CARD16,
				unsigned int*, unsigned int*);
d86 3
a88 4
				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16,
				XvImagePtr, unsigned char*, Bool,
				CARD16, CARD16);
d90 1
a90 2
				CARD16*, CARD16*, int*, int*);

d96 2
a97 1
static void xf86XVPostValidateTree(WindowPtr pWin, WindowPtr pLayerWin, VTKind kind);
d111 1
a111 1
static Bool xf86XVInitAdaptors(ScreenPtr, XF86VideoAdaptorPtr*, int);
d113 1
a114 1
static DevPrivateKeyRec XF86XVWindowKeyRec;
d121 3
a123 3
DevPrivateKey (*XvGetScreenKeyProc)(void) = NULL;
unsigned long (*XvGetRTPortProc)(void) = NULL;
int (*XvScreenInitProc)(ScreenPtr) = NULL;
d138 9
a146 10
xf86XVRegisterGenericAdaptorDriver(
    xf86XVInitGenericAdaptorPtr InitFunc
){
  xf86XVInitGenericAdaptorPtr *newdrivers;

  newdrivers = realloc(GenDrivers, sizeof(xf86XVInitGenericAdaptorPtr) *
			(1 + NumGenDrivers));
  if (!newdrivers)
    return 0;
  GenDrivers = newdrivers;
d148 1
a148 1
  GenDrivers[NumGenDrivers++] = InitFunc;
d150 1
a150 1
  return 1;
d154 4
a157 6
xf86XVListGenericAdaptors(
    ScrnInfoPtr pScrn,
    XF86VideoAdaptorPtr **adaptors
){
    int i,j,n,num;
    XF86VideoAdaptorPtr *DrivAdap,*new;
d165 11
a175 11
    for (i = NumGenDrivers; --i >= 0; ) {
	DrivAdap = NULL;
	n = (*GenDrivers[i])(pScrn, &DrivAdap);
	if (0 == n)
	    continue;
	new = realloc(*adaptors, sizeof(XF86VideoAdaptorPtr) * (num+n));
	if (NULL == new)
	    continue;
	*adaptors = new;
	for (j = 0; j < n; j++, num++)
	    (*adaptors)[num] = DrivAdap[j];
a179 1

d183 2
a184 2
   XF86OffscreenImagePtr images;
   int num;
d188 1
d193 3
a195 5
xf86XVRegisterOffscreenImages(
    ScreenPtr pScreen,
    XF86OffscreenImagePtr images,
    int num
){
d197 1
d201 3
a203 2
    if(!dixRegisterPrivateKey(OffscreenPrivateKey, PRIVATE_SCREEN, sizeof(OffscreenImageRec)) ||
       !(OffscreenImage = GetOffscreenImage(pScreen)))
d206 2
a207 1
        FatalError("Could not allocate private storage for XV offscreen images.\n");
d215 2
a216 4
xf86XVQueryOffscreenImages(
   ScreenPtr pScreen,
   int *num
){
d218 1
a222 1

d235 50
d286 8
a293 60
Bool
xf86XVScreenInit(
   ScreenPtr pScreen,
   XF86VideoAdaptorPtr *adaptors,
   int num
){
  ScrnInfoPtr pScrn;
  XF86XVScreenPtr ScreenPriv;
  XvScreenPtr pxvs;

  if(num <= 0 ||
     !XvGetScreenKeyProc || !XvGetRTPortProc || !XvScreenInitProc)
	return FALSE;

  if(Success != (*XvScreenInitProc)(pScreen)) return FALSE;

  if (!dixRegisterPrivateKey(&XF86XVWindowKeyRec, PRIVATE_WINDOW, 0))
      return FALSE;

  XF86XvScreenKey = (*XvGetScreenKeyProc)();

  PortResource = (*XvGetRTPortProc)();

  pxvs = GET_XV_SCREEN(pScreen);

  /* Anyone initializing the Xv layer must provide these two.
     The Xv di layer calls them without even checking if they exist! */

  pxvs->ddCloseScreen = xf86XVCloseScreen;
  pxvs->ddQueryAdaptors = xf86XVQueryAdaptors;

  /* The Xv di layer provides us with a private hook so that we don't
     have to allocate our own screen private.  They also provide
     a CloseScreen hook so that we don't have to wrap it.  I'm not
     sure that I appreciate that.  */

  ScreenPriv = malloc(sizeof(XF86XVScreenRec));
  pxvs->devPriv.ptr = (pointer)ScreenPriv;

  if(!ScreenPriv) return FALSE;

  pScrn = xf86Screens[pScreen->myNum];

  ScreenPriv->DestroyWindow = pScreen->DestroyWindow;
  ScreenPriv->WindowExposures = pScreen->WindowExposures;
  ScreenPriv->PostValidateTree = PostValidateTreeUndefined;
  ScreenPriv->ClipNotify = pScreen->ClipNotify;
  ScreenPriv->EnterVT = pScrn->EnterVT;
  ScreenPriv->LeaveVT = pScrn->LeaveVT;
  ScreenPriv->AdjustFrame = pScrn->AdjustFrame;
  ScreenPriv->ModeSet = pScrn->ModeSet;

  pScreen->DestroyWindow = xf86XVDestroyWindow;
  pScreen->WindowExposures = xf86XVWindowExposures;
  pScreen->ClipNotify = xf86XVClipNotify;
  pScrn->EnterVT = xf86XVEnterVT;
  pScrn->LeaveVT = xf86XVLeaveVT;
  if(pScrn->AdjustFrame)
     pScrn->AdjustFrame = xf86XVAdjustFrame;
  pScrn->ModeSet = xf86XVModeSet;
d295 2
a296 2
  if(!xf86XVInitAdaptors(pScreen, adaptors, num))
	return FALSE;
d298 1
a298 1
  return TRUE;
d304 1
a304 1
   int i;
d306 2
a307 2
   free(pAdaptor->name);
   pAdaptor->name = NULL;
d309 2
a310 2
   if(pAdaptor->pEncodings) {
      XvEncodingPtr pEncode = pAdaptor->pEncodings;
d312 42
a353 42
      for(i = 0; i < pAdaptor->nEncodings; i++, pEncode++)
	  free(pEncode->name);
      free(pAdaptor->pEncodings);
      pAdaptor->pEncodings = NULL;
   }

   free(pAdaptor->pFormats);
   pAdaptor->pFormats = NULL;

   if(pAdaptor->pPorts) {
      XvPortPtr pPort = pAdaptor->pPorts;
      XvPortRecPrivatePtr pPriv;

      for(i = 0; i < pAdaptor->nPorts; i++, pPort++) {
	  pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
	  if(pPriv) {
	     if(pPriv->clientClip)
		RegionDestroy(pPriv->clientClip);
	     if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
		RegionDestroy(pPriv->pCompositeClip);
	     if (pPriv->ckeyFilled)
		RegionDestroy(pPriv->ckeyFilled);
	     free(pPriv);
	  }
      }
      free(pAdaptor->pPorts);
      pAdaptor->pPorts = NULL;
   }

   if(pAdaptor->pAttributes) {
      XvAttributePtr pAttribute = pAdaptor->pAttributes;

      for(i = 0; i < pAdaptor->nAttributes; i++, pAttribute++)
	  free(pAttribute->name);
      free(pAdaptor->pAttributes);
      pAdaptor->pAttributes = NULL;
   }

   free(pAdaptor->pImages);
   free(pAdaptor->devPriv.ptr);
   pAdaptor->pImages = NULL;
   pAdaptor->devPriv.ptr = NULL;
d357 29
a385 264
xf86XVInitAdaptors(
   ScreenPtr pScreen,
   XF86VideoAdaptorPtr *infoPtr,
   int number
) {
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  XF86VideoAdaptorPtr adaptorPtr;
  XvAdaptorPtr pAdaptor, pa;
  XvAdaptorRecPrivatePtr adaptorPriv;
  int na, numAdaptor;
  XvPortRecPrivatePtr portPriv;
  XvPortPtr pPort, pp;
  int numPort;
  XF86AttributePtr attributePtr;
  XvAttributePtr pAttribute, pat;
  XF86VideoFormatPtr formatPtr;
  XvFormatPtr pFormat, pf;
  int numFormat, totFormat;
  XF86VideoEncodingPtr encodingPtr;
  XvEncodingPtr pEncode, pe;
  XF86ImagePtr imagePtr;
  XvImagePtr pImage, pi;
  int numVisuals;
  VisualPtr pVisual;
  int i;

  pxvs->nAdaptors = 0;
  pxvs->pAdaptors = NULL;

  if(!(pAdaptor = calloc(number, sizeof(XvAdaptorRec))))
      return FALSE;

  for(pa = pAdaptor, na = 0, numAdaptor = 0; na < number; na++, adaptorPtr++) {
      adaptorPtr = infoPtr[na];

      if(!adaptorPtr->StopVideo || !adaptorPtr->SetPortAttribute ||
	 !adaptorPtr->GetPortAttribute || !adaptorPtr->QueryBestSize)
	   continue;

      /* client libs expect at least one encoding */
      if(!adaptorPtr->nEncodings || !adaptorPtr->pEncodings)
	   continue;

      pa->type = adaptorPtr->type;

      if(!adaptorPtr->PutVideo && !adaptorPtr->GetVideo)
	 pa->type &= ~XvVideoMask;

      if(!adaptorPtr->PutStill && !adaptorPtr->GetStill)
	 pa->type &= ~XvStillMask;

      if(!adaptorPtr->PutImage || !adaptorPtr->QueryImageAttributes)
	 pa->type &= ~XvImageMask;

      if(!adaptorPtr->PutVideo && !adaptorPtr->PutImage &&
							  !adaptorPtr->PutStill)
	 pa->type &= ~XvInputMask;

      if(!adaptorPtr->GetVideo && !adaptorPtr->GetStill)
	 pa->type &= ~XvOutputMask;

      if(!(adaptorPtr->type & (XvPixmapMask | XvWindowMask)))
	  continue;
      if(!(adaptorPtr->type & (XvImageMask | XvVideoMask | XvStillMask)))
	  continue;

      pa->pScreen = pScreen;
      pa->ddAllocatePort = xf86XVAllocatePort;
      pa->ddFreePort = xf86XVFreePort;
      pa->ddPutVideo = xf86XVPutVideo;
      pa->ddPutStill = xf86XVPutStill;
      pa->ddGetVideo = xf86XVGetVideo;
      pa->ddGetStill = xf86XVGetStill;
      pa->ddStopVideo = xf86XVStopVideo;
      pa->ddPutImage = xf86XVPutImage;
      pa->ddSetPortAttribute = xf86XVSetPortAttribute;
      pa->ddGetPortAttribute = xf86XVGetPortAttribute;
      pa->ddQueryBestSize = xf86XVQueryBestSize;
      pa->ddQueryImageAttributes = xf86XVQueryImageAttributes;
      pa->name = strdup(adaptorPtr->name);

      if(adaptorPtr->nEncodings &&
	(pEncode = calloc(adaptorPtr->nEncodings, sizeof(XvEncodingRec)))) {

	for(pe = pEncode, encodingPtr = adaptorPtr->pEncodings, i = 0;
	    i < adaptorPtr->nEncodings; pe++, i++, encodingPtr++)
	{
	    pe->id = encodingPtr->id;
	    pe->pScreen = pScreen;
	    pe->name = strdup(encodingPtr->name);
	    pe->width = encodingPtr->width;
	    pe->height = encodingPtr->height;
	    pe->rate.numerator = encodingPtr->rate.numerator;
	    pe->rate.denominator = encodingPtr->rate.denominator;
	}
	pa->nEncodings = adaptorPtr->nEncodings;
	pa->pEncodings = pEncode;
      }

      if(adaptorPtr->nImages &&
	 (pImage = calloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {

	  for(i = 0, pi = pImage, imagePtr = adaptorPtr->pImages;
	      i < adaptorPtr->nImages; i++, pi++, imagePtr++)
	  {
	     pi->id = imagePtr->id;
	     pi->type = imagePtr->type;
	     pi->byte_order = imagePtr->byte_order;
	     memcpy(pi->guid, imagePtr->guid, 16);
	     pi->bits_per_pixel = imagePtr->bits_per_pixel;
	     pi->format = imagePtr->format;
	     pi->num_planes = imagePtr->num_planes;
	     pi->depth = imagePtr->depth;
	     pi->red_mask = imagePtr->red_mask;
	     pi->green_mask = imagePtr->green_mask;
	     pi->blue_mask = imagePtr->blue_mask;
	     pi->y_sample_bits = imagePtr->y_sample_bits;
	     pi->u_sample_bits = imagePtr->u_sample_bits;
	     pi->v_sample_bits = imagePtr->v_sample_bits;
	     pi->horz_y_period = imagePtr->horz_y_period;
	     pi->horz_u_period = imagePtr->horz_u_period;
	     pi->horz_v_period = imagePtr->horz_v_period;
	     pi->vert_y_period = imagePtr->vert_y_period;
	     pi->vert_u_period = imagePtr->vert_u_period;
	     pi->vert_v_period = imagePtr->vert_v_period;
	     memcpy(pi->component_order, imagePtr->component_order, 32);
	     pi->scanline_order = imagePtr->scanline_order;
	  }
	  pa->nImages = adaptorPtr->nImages;
	  pa->pImages = pImage;
      }

      if(adaptorPtr->nAttributes &&
	(pAttribute = calloc(adaptorPtr->nAttributes, sizeof(XvAttributeRec))))
      {
	for(pat = pAttribute, attributePtr = adaptorPtr->pAttributes, i = 0;
	    i < adaptorPtr->nAttributes; pat++, i++, attributePtr++)
	{
	    pat->flags = attributePtr->flags;
	    pat->min_value = attributePtr->min_value;
	    pat->max_value = attributePtr->max_value;
	    pat->name = strdup(attributePtr->name);
	}
	pa->nAttributes = adaptorPtr->nAttributes;
	pa->pAttributes = pAttribute;
      }


      totFormat = adaptorPtr->nFormats;

      if(!(pFormat = calloc(totFormat, sizeof(XvFormatRec)))) {
	  xf86XVFreeAdaptor(pa);
	  continue;
      }
      for(pf = pFormat, i = 0, numFormat = 0, formatPtr = adaptorPtr->pFormats;
	  i < adaptorPtr->nFormats; i++, formatPtr++)
      {
	  numVisuals = pScreen->numVisuals;
	  pVisual = pScreen->visuals;

	  while(numVisuals--) {
	      if((pVisual->class == formatPtr->class) &&
		 (pVisual->nplanes == formatPtr->depth)) {

		   if(numFormat >= totFormat) {
			void *moreSpace;
			totFormat *= 2;
			moreSpace = realloc(pFormat,
					     totFormat * sizeof(XvFormatRec));
			if(!moreSpace) break;
			pFormat = moreSpace;
			pf = pFormat + numFormat;
		   }

		   pf->visual = pVisual->vid;
		   pf->depth = formatPtr->depth;

		   pf++;
		   numFormat++;
	      }
	      pVisual++;
	  }
      }
      pa->nFormats = numFormat;
      pa->pFormats = pFormat;
      if(!numFormat) {
	  xf86XVFreeAdaptor(pa);
	  continue;
      }

      if(!(adaptorPriv = calloc(1, sizeof(XvAdaptorRecPrivate)))) {
	  xf86XVFreeAdaptor(pa);
	  continue;
      }

      adaptorPriv->flags = adaptorPtr->flags;
      adaptorPriv->PutVideo = adaptorPtr->PutVideo;
      adaptorPriv->PutStill = adaptorPtr->PutStill;
      adaptorPriv->GetVideo = adaptorPtr->GetVideo;
      adaptorPriv->GetStill = adaptorPtr->GetStill;
      adaptorPriv->StopVideo = adaptorPtr->StopVideo;
      adaptorPriv->SetPortAttribute = adaptorPtr->SetPortAttribute;
      adaptorPriv->GetPortAttribute = adaptorPtr->GetPortAttribute;
      adaptorPriv->QueryBestSize = adaptorPtr->QueryBestSize;
      adaptorPriv->QueryImageAttributes = adaptorPtr->QueryImageAttributes;
      adaptorPriv->PutImage = adaptorPtr->PutImage;
      adaptorPriv->ReputImage = adaptorPtr->ReputImage; /* image/still */

      pa->devPriv.ptr = (pointer)adaptorPriv;

      if(!(pPort = calloc(adaptorPtr->nPorts, sizeof(XvPortRec)))) {
	  xf86XVFreeAdaptor(pa);
	  continue;
      }
      for(pp = pPort, i = 0, numPort = 0;
	  i < adaptorPtr->nPorts; i++) {

	  if(!(pp->id = FakeClientID(0)))
		continue;

	  if(!(portPriv = calloc(1, sizeof(XvPortRecPrivate))))
		continue;

	  if(!AddResource(pp->id, PortResource, pp)) {
		free(portPriv);
		continue;
	  }

	  pp->pAdaptor = pa;
	  pp->pNotify = (XvPortNotifyPtr)NULL;
	  pp->pDraw = (DrawablePtr)NULL;
	  pp->client = (ClientPtr)NULL;
	  pp->grab.client = (ClientPtr)NULL;
	  pp->time = currentTime;
	  pp->devPriv.ptr = portPriv;

	  portPriv->pScrn = pScrn;
	  portPriv->AdaptorRec = adaptorPriv;
	  portPriv->DevPriv.ptr = adaptorPtr->pPortPrivates[i].ptr;

	  pp++;
	  numPort++;
      }
      pa->nPorts = numPort;
      pa->pPorts = pPort;
      if(!numPort) {
	  xf86XVFreeAdaptor(pa);
	  continue;
      }

      pa->base_id = pPort->id;

      pa++;
      numAdaptor++;
  }

  if(numAdaptor) {
      pxvs->nAdaptors = numAdaptor;
      pxvs->pAdaptors = pAdaptor;
  } else {
     free(pAdaptor);
     return FALSE;
  }
d387 230
a616 1
  return TRUE;
d638 34
a671 34
   RegionPtr	pregWin, pCompositeClip;
   WindowPtr	pWin;
   Bool		freeCompClip = FALSE;

   if(portPriv->pCompositeClip)
	return;

   pWin = (WindowPtr)portPriv->pDraw;

   /* get window clip list */
   if(portPriv->subWindowMode == IncludeInferiors) {
	pregWin = NotClippedByChildren(pWin);
	freeCompClip = TRUE;
   } else
	pregWin = &pWin->clipList;

   if(!portPriv->clientClip) {
	portPriv->pCompositeClip = pregWin;
	portPriv->FreeCompositeClip = freeCompClip;
	return;
   }

   pCompositeClip = RegionCreate(NullBox, 1);
   RegionCopy(pCompositeClip, portPriv->clientClip);
   RegionTranslate(pCompositeClip,
		   portPriv->pDraw->x, portPriv->pDraw->y);
   RegionIntersect(pCompositeClip, pregWin, pCompositeClip);

   portPriv->pCompositeClip = pCompositeClip;
   portPriv->FreeCompositeClip = TRUE;

   if(freeCompClip) {
	RegionDestroy(pregWin);
   }
d678 2
a679 4
xf86XVCopyClip(
   XvPortRecPrivatePtr portPriv,
   GCPtr pGC
){
d681 10
a690 10
    if((pGC->clientClipType == CT_REGION) && pGC->clientClip) {
	if(!portPriv->clientClip)
	    portPriv->clientClip = RegionCreate(NullBox, 1);
	/* Note: this is in window coordinates */
	RegionCopy(portPriv->clientClip, pGC->clientClip);
	RegionTranslate(portPriv->clientClip,
			pGC->clipOrg.x, pGC->clipOrg.y);
    } else if(portPriv->clientClip) { /* free the old clientClip */
	RegionDestroy(portPriv->clientClip);
	portPriv->clientClip = NULL;
d694 2
a695 2
    if(portPriv->pCompositeClip && portPriv->FreeCompositeClip) {
	RegionDestroy(portPriv->pCompositeClip);
d705 1
a705 2
			GCPtr pGC,
			DrawablePtr pDraw)
d708 1
a708 1
	portPriv->clientClip = RegionCreate(NullBox, 1);
d711 1
a711 2
    RegionTranslate(portPriv->clientClip,
		    -pDraw->x, -pDraw->y);
d715 1
a715 1
	RegionDestroy(portPriv->pCompositeClip);
d725 13
a737 51
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  xf86XVUpdateCompositeClip(portPriv);

  /* translate the video region to the screen */
  WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
  WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
  WinBox.x2 = WinBox.x1 + portPriv->drw_w;
  WinBox.y2 = WinBox.y1 + portPriv->drw_h;

  /* clip to the window composite clip */
  RegionInit(&WinRegion, &WinBox, 1);
  RegionNull(&ClipRegion);
  RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

  /* that's all if it's totally obscured */
  if(!RegionNotEmpty(&ClipRegion)) {
	clippedAway = TRUE;
	goto CLIP_VIDEO_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->GetVideo)(portPriv->pScrn,
			portPriv->vid_x, portPriv->vid_y,
			WinBox.x1, WinBox.y1,
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
			&ClipRegion, portPriv->DevPriv.ptr,
			portPriv->pDraw);

  if(ret == Success)
	portPriv->isOn = XV_ON;

CLIP_VIDEO_BAILOUT:

  if((clippedAway || (ret != Success)) && portPriv->isOn == XV_ON) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;
d739 14
a752 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d754 27
a780 1
  return ret;
a782 1

d786 5
a790 77
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  xf86XVUpdateCompositeClip(portPriv);

  /* translate the video region to the screen */
  WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
  WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
  WinBox.x2 = WinBox.x1 + portPriv->drw_w;
  WinBox.y2 = WinBox.y1 + portPriv->drw_h;

  /* clip to the window composite clip */
  RegionInit(&WinRegion, &WinBox, 1);
  RegionNull(&ClipRegion);
  RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

  /* clip and translate to the viewport */
  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = portPriv->pScrn->frameX0;
     VPBox.y1 = portPriv->pScrn->frameY0;
     VPBox.x2 = portPriv->pScrn->frameX1 + 1;
     VPBox.y2 = portPriv->pScrn->frameY1 + 1;

     RegionInit(&VPReg, &VPBox, 1);
     RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
     RegionUninit(&VPReg);
  }

  /* that's all if it's totally obscured */
  if(!RegionNotEmpty(&ClipRegion)) {
	clippedAway = TRUE;
	goto CLIP_VIDEO_BAILOUT;
  }

  /* bailout if we have to clip but the hardware doesn't support it */
  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = RegionRects(&ClipRegion);
     if(  (RegionNumRects(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	    clippedAway = TRUE;
	    goto CLIP_VIDEO_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->PutVideo)(portPriv->pScrn,
			portPriv->vid_x, portPriv->vid_y,
			WinBox.x1, WinBox.y1,
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
			&ClipRegion, portPriv->DevPriv.ptr,
			portPriv->pDraw);

  if(ret == Success) portPriv->isOn = XV_ON;

CLIP_VIDEO_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;
d792 33
a824 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d826 43
a868 1
  return ret;
d875 12
a886 82
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  xf86XVUpdateCompositeClip(portPriv);

  /* the clip can get smaller over time */
  RegionCopy(portPriv->clientClip, portPriv->pCompositeClip);
  RegionTranslate(portPriv->clientClip,
		  -portPriv->pDraw->x, -portPriv->pDraw->y);

  /* translate the video region to the screen */
  WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
  WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
  WinBox.x2 = WinBox.x1 + portPriv->drw_w;
  WinBox.y2 = WinBox.y1 + portPriv->drw_h;

  /* clip to the window composite clip */
  RegionInit(&WinRegion, &WinBox, 1);
  RegionNull(&ClipRegion);
  RegionIntersect(&ClipRegion, &WinRegion, portPriv->pCompositeClip);

  /* clip and translate to the viewport */
  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = portPriv->pScrn->frameX0;
     VPBox.y1 = portPriv->pScrn->frameY0;
     VPBox.x2 = portPriv->pScrn->frameX1 + 1;
     VPBox.y2 = portPriv->pScrn->frameY1 + 1;

     RegionInit(&VPReg, &VPBox, 1);
     RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
     RegionUninit(&VPReg);
  }

  /* that's all if it's totally obscured */
  if(!RegionNotEmpty(&ClipRegion)) {
	clippedAway = TRUE;
	goto CLIP_VIDEO_BAILOUT;
  }

  /* bailout if we have to clip but the hardware doesn't support it */
  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = RegionRects(&ClipRegion);
     if(  (RegionNumRects(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	    clippedAway = TRUE;
	    goto CLIP_VIDEO_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->ReputImage)(portPriv->pScrn,
			portPriv->vid_x, portPriv->vid_y,
			WinBox.x1, WinBox.y1,
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
			&ClipRegion, portPriv->DevPriv.ptr,
			portPriv->pDraw);

  portPriv->isOn = (ret == Success) ? XV_ON : XV_OFF;

CLIP_VIDEO_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;
d888 5
a892 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d894 69
a962 1
  return ret;
a964 1

d970 6
a975 6
    while(WinPriv) {
	if(WinPriv->PortRec->type == XvInputMask)
	    xf86XVReputVideo(WinPriv->PortRec);
	else
	    xf86XVRegetVideo(WinPriv->PortRec);
	WinPriv = WinPriv->next;
d984 1
a984 1
   XF86XVWindowPtr winPriv, PrivRoot;
d986 8
a993 1
   winPriv = PrivRoot = GET_XF86XV_WINDOW(pWin);
d995 8
a1002 14
  /* Enlist our port in the window private */
   while(winPriv) {
	if(winPriv->PortRec == portPriv) /* we're already listed */
	    break;
	winPriv = winPriv->next;
   }

   if(!winPriv) {
	winPriv = calloc(1, sizeof(XF86XVWindowRec));
	if(!winPriv) return BadAlloc;
	winPriv->PortRec = portPriv;
	winPriv->next = PrivRoot;
	dixSetPrivate(&pWin->devPrivates, XF86XVWindowKey, winPriv);
   }
d1004 1
a1004 1
   portPriv->pDraw = (DrawablePtr)pWin;
d1006 1
a1006 1
   return Success;
a1008 1

d1012 1
a1012 2
     XF86XVWindowPtr winPriv, prevPriv = NULL;
     winPriv = GET_XF86XV_WINDOW(pWin);
d1014 21
a1034 19
     while(winPriv) {
	if(winPriv->PortRec == portPriv) {
	    if(prevPriv)
		prevPriv->next = winPriv->next;
	    else
		dixSetPrivate(&pWin->devPrivates, XF86XVWindowKey,
			      winPriv->next);
	    free(winPriv);
	    break;
	}
	prevPriv = winPriv;
	winPriv = winPriv->next;
     }
     portPriv->pDraw = NULL;
     if (portPriv->ckeyFilled) {
	RegionDestroy(portPriv->ckeyFilled);
	portPriv->ckeyFilled = NULL;
     }
     portPriv->clipChanged = FALSE;
d1038 1
a1038 3
xf86XVReputOrStopPort(XvPortRecPrivatePtr pPriv,
		      WindowPtr pWin,
		      Bool visible)
d1041 5
a1045 4
	if (pPriv->isOn == XV_ON) {
	    (*pPriv->AdaptorRec->StopVideo)(pPriv->pScrn, pPriv->DevPriv.ptr, FALSE);
	    pPriv->isOn = XV_PENDING;
	}
d1047 2
a1048 2
	if (!pPriv->type) /* overlaid still/image*/
	    xf86XVRemovePortFromWindow(pWin, pPriv);
d1050 1
a1050 1
	return;
d1055 2
a1056 2
	xf86XVReputVideo(pPriv);
	break;
d1058 6
a1063 6
	xf86XVRegetVideo(pPriv);
	break;
    default:  /* overlaid still/image*/
	if (pPriv->AdaptorRec->ReputImage)
	    xf86XVReputImage(pPriv);
	break;
d1076 1
a1076 15
	XvPortPtr pPort = pa->pPorts;

	for (i = pa->nPorts; i > 0; i--, pPort++) {
	    XvPortRecPrivatePtr pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
	    WindowPtr pWin = (WindowPtr)pPriv->pDraw;
	    Bool visible;

	    if (pPriv->isOn == XV_OFF || !pWin)
		continue;

	    if (onlyChanged && !pPriv->clipChanged)
		continue;

	    visible = pWin->visibility == VisibilityUnobscured ||
		      pWin->visibility == VisibilityPartiallyObscured;
d1078 21
a1098 6
	    /*
	     * Stop and remove still/images if
	     * ReputImage isn't supported.
	     */
	    if (!pPriv->type && !pPriv->AdaptorRec->ReputImage)
		visible = FALSE;
d1100 1
a1100 1
	    xf86XVReputOrStopPort(pPriv, pWin, visible);
d1102 2
a1103 2
	    pPriv->clipChanged = FALSE;
	}
d1112 7
a1118 25
  ScreenPtr pScreen = pWin->drawable.pScreen;
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
  XF86XVWindowPtr tmp, WinPriv = GET_XF86XV_WINDOW(pWin);
  int ret;

  while(WinPriv) {
     XvPortRecPrivatePtr pPriv = WinPriv->PortRec;

     if(pPriv->isOn > XV_OFF) {
	(*pPriv->AdaptorRec->StopVideo)(
			pPriv->pScrn, pPriv->DevPriv.ptr, TRUE);
	pPriv->isOn = XV_OFF;
     }

     pPriv->pDraw = NULL;
     tmp = WinPriv;
     WinPriv = WinPriv->next;
     free(tmp);
  }

  dixSetPrivate(&pWin->devPrivates, XF86XVWindowKey, NULL);

  pScreen->DestroyWindow = ScreenPriv->DestroyWindow;
  ret = (*pScreen->DestroyWindow)(pWin);
  pScreen->DestroyWindow = xf86XVDestroyWindow;
d1120 19
a1138 1
  return ret;
d1149 1
a1149 1
	pScreen = pWin->drawable.pScreen;
d1151 1
a1151 1
	pScreen = pLayerWin->drawable.pScreen;
d1160 1
a1160 1
	(*pScreen->PostValidateTree)(pWin, pLayerWin, kind);
d1168 18
a1185 41
  ScreenPtr pScreen = pWin->drawable.pScreen;
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
  XF86XVWindowPtr WinPriv = GET_XF86XV_WINDOW(pWin);
  XvPortRecPrivatePtr pPriv;
  Bool AreasExposed;

  AreasExposed = (WinPriv && reg1 && RegionNotEmpty(reg1));

  pScreen->WindowExposures = ScreenPriv->WindowExposures;
  (*pScreen->WindowExposures)(pWin, reg1, reg2);
  pScreen->WindowExposures = xf86XVWindowExposures;

  /* filter out XClearWindow/Area */
  if (!pWin->valdata) return;

  while(WinPriv) {
     Bool visible = TRUE;

     pPriv = WinPriv->PortRec;

     /*
      * Stop and remove still/images if areas were exposed and
      * ReputImage isn't supported.
      */
     if (!pPriv->type && !pPriv->AdaptorRec->ReputImage)
	visible = !AreasExposed;

     /*
      * Subtract exposed areas from overlaid image to match textured video
      * behavior.
      */
     if (!pPriv->type && pPriv->clientClip)
	    RegionSubtract(pPriv->clientClip, pPriv->clientClip, reg1);

     if (visible && pPriv->ckeyFilled) {
        RegionRec tmp;
        RegionNull(&tmp);
        RegionCopy(&tmp, reg1);
        RegionTranslate(&tmp, pWin->drawable.x, pWin->drawable.y);
        RegionSubtract(pPriv->ckeyFilled, pPriv->ckeyFilled, &tmp);
     }
d1187 1
a1187 2
     WinPriv = WinPriv->next;
     xf86XVReputOrStopPort(pPriv, pWin, visible);
d1189 28
a1216 2
     pPriv->clipChanged = FALSE;
  }
d1222 18
a1239 33
  ScreenPtr pScreen = pWin->drawable.pScreen;
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
  XF86XVWindowPtr WinPriv = GET_XF86XV_WINDOW(pWin);
  XvPortRecPrivatePtr pPriv;

  while(WinPriv) {
     pPriv = WinPriv->PortRec;

     if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
	RegionDestroy(pPriv->pCompositeClip);

     pPriv->pCompositeClip = NULL;

     if (pPriv->AdaptorRec->ClipNotify)
        (*pPriv->AdaptorRec->ClipNotify)(pPriv->pScrn, pPriv->DevPriv.ptr,
                                         pWin, dx, dy);

     pPriv->clipChanged = TRUE;

     if (ScreenPriv->PostValidateTree == PostValidateTreeUndefined) {
        ScreenPriv->PostValidateTree = pScreen->PostValidateTree;
        pScreen->PostValidateTree = xf86XVPostValidateTree;
     }

     WinPriv = WinPriv->next;
  }

  if(ScreenPriv->ClipNotify) {
      pScreen->ClipNotify = ScreenPriv->ClipNotify;
      (*pScreen->ClipNotify)(pWin, dx, dy);
      pScreen->ClipNotify = xf86XVClipNotify;
  }
}
d1241 4
d1246 9
d1261 25
a1285 24
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
  XvAdaptorPtr pa;
  int c;

  if(!ScreenPriv) return TRUE;

  pScreen->DestroyWindow = ScreenPriv->DestroyWindow;
  pScreen->WindowExposures = ScreenPriv->WindowExposures;
  pScreen->ClipNotify = ScreenPriv->ClipNotify;

  pScrn->EnterVT = ScreenPriv->EnterVT;
  pScrn->LeaveVT = ScreenPriv->LeaveVT;
  pScrn->AdjustFrame = ScreenPriv->AdjustFrame;
  pScrn->ModeSet = ScreenPriv->ModeSet;

  for(c = 0, pa = pxvs->pAdaptors; c < pxvs->nAdaptors; c++, pa++) {
       xf86XVFreeAdaptor(pa);
  }

  free(pxvs->pAdaptors);
  free(ScreenPriv);
  return TRUE;
a1287 1

d1289 4
a1292 6
xf86XVQueryAdaptors(
   ScreenPtr pScreen,
   XvAdaptorPtr *p_pAdaptors,
   int *p_nAdaptors
){
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
d1294 2
a1295 2
  *p_nAdaptors = pxvs->nAdaptors;
  *p_pAdaptors = pxvs->pAdaptors;
d1297 1
a1297 1
  return Success;
a1299 1

d1311 1
a1311 1
    ret = (*ScreenPriv->EnterVT)(index, flags);
d1315 2
a1316 1
    if(ret) WalkTree(pScreen, xf86XVReputAllVideo, 0);
d1333 21
a1353 21
    for(i = 0; i < pxvs->nAdaptors; i++) {
	pAdaptor = &pxvs->pAdaptors[i];
	for(j = 0; j < pAdaptor->nPorts; j++) {
	    pPort = &pAdaptor->pPorts[j];
	    pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
	    if(pPriv->isOn > XV_OFF) {

		(*pPriv->AdaptorRec->StopVideo)(
			pPriv->pScrn, pPriv->DevPriv.ptr, TRUE);
		pPriv->isOn = XV_OFF;

		if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
		    RegionDestroy(pPriv->pCompositeClip);

		pPriv->pCompositeClip = NULL;

		if(!pPriv->type && pPriv->pDraw) { /* still */
		    xf86XVRemovePortFromWindow((WindowPtr)pPriv->pDraw, pPriv);
		}
	    }
	}
d1357 1
a1357 1
    (*ScreenPriv->LeaveVT)(index, flags);
d1365 3
a1367 9
  ScrnInfoPtr pScrn = xf86Screens[index];
  ScreenPtr pScreen = pScrn->pScreen;
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);

  if(ScreenPriv->AdjustFrame) {
	pScrn->AdjustFrame = ScreenPriv->AdjustFrame;
	(*pScrn->AdjustFrame)(index, x, y, flags);
	pScrn->AdjustFrame = xf86XVAdjustFrame;
  }
d1369 7
a1375 1
  xf86XVReputOrStopAllPorts(pScrn, FALSE);
d1386 1
a1386 1
	return;
d1391 3
a1393 3
	pScrn->ModeSet = ScreenPriv->ModeSet;
	(*pScrn->ModeSet)(pScrn);
	pScrn->ModeSet = xf86XVModeSet;
d1402 4
a1405 7
xf86XVAllocatePort(
   unsigned long port,
   XvPortPtr pPort,
   XvPortPtr *ppPort
){
  *ppPort = pPort;
  return Success;
a1407 2


d1411 1
a1411 1
  return Success;
a1413 1

d1415 40
a1454 37
xf86XVPutVideo(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  int result;

  /* No dumping video to pixmaps... For now anyhow */
  if(pDraw->type != DRAWABLE_WINDOW) {
      pPort->pDraw = (DrawablePtr)NULL;
      return BadAlloc;
  }

  /* If we are changing windows, unregister our port in the old window */
  if(portPriv->pDraw && (portPriv->pDraw != pDraw))
     xf86XVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);

  /* Register our port with the new window */
  result =  xf86XVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
  if(result != Success) return result;

  portPriv->type = XvInputMask;

  /* save a copy of these parameters */
  portPriv->vid_x = vid_x;  portPriv->vid_y = vid_y;
  portPriv->vid_w = vid_w;  portPriv->vid_h = vid_h;
  portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
  portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;

  /* make sure we have the most recent copy of the clientClip */
  xf86XVCopyClip(portPriv, pGC);
d1456 2
a1457 2
  /* To indicate to the DI layer that we were successful */
  pPort->pDraw = pDraw;
d1459 2
a1460 1
  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */
d1462 1
a1462 1
  return(xf86XVReputVideo(portPriv));
d1466 27
a1492 102
xf86XVPutStill(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  if (pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */

  WinBox.x1 = pDraw->x + drw_x;
  WinBox.y1 = pDraw->y + drw_y;
  WinBox.x2 = WinBox.x1 + drw_w;
  WinBox.y2 = WinBox.y1 + drw_h;

  xf86XVCopyCompositeClip(portPriv, pGC, pDraw);

  RegionInit(&WinRegion, &WinBox, 1);
  RegionNull(&ClipRegion);
  RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = portPriv->pScrn->frameX0;
     VPBox.y1 = portPriv->pScrn->frameY0;
     VPBox.x2 = portPriv->pScrn->frameX1 + 1;
     VPBox.y2 = portPriv->pScrn->frameY1 + 1;

     RegionInit(&VPReg, &VPBox, 1);
     RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
     RegionUninit(&VPReg);
  }

  if(portPriv->pDraw) {
     xf86XVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);
  }

  if(!RegionNotEmpty(&ClipRegion)) {
     clippedAway = TRUE;
     goto PUT_STILL_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = RegionRects(&ClipRegion);
     if(  (RegionNumRects(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	  clippedAway = TRUE;
	  goto PUT_STILL_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->PutStill)(portPriv->pScrn,
		vid_x, vid_y, WinBox.x1, WinBox.y1,
		vid_w, vid_h, drw_w, drw_h,
		&ClipRegion, portPriv->DevPriv.ptr,
		pDraw);

  if((ret == Success) &&
	(portPriv->AdaptorRec->flags & VIDEO_OVERLAID_STILLS)) {

     xf86XVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
     portPriv->isOn = XV_ON;
     portPriv->vid_x = vid_x;  portPriv->vid_y = vid_y;
     portPriv->vid_w = vid_w;  portPriv->vid_h = vid_h;
     portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
     portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;
     portPriv->type = 0;  /* no mask means it's transient and should
			     not be reput once it's removed */
     pPort->pDraw = pDraw;  /* make sure we can get stop requests */
  }

PUT_STILL_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;
d1494 3
a1496 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d1498 78
a1575 1
  return ret;
d1579 40
a1618 37
xf86XVGetVideo(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  int result;

  /* No pixmaps... For now anyhow */
  if(pDraw->type != DRAWABLE_WINDOW) {
      pPort->pDraw = (DrawablePtr)NULL;
      return BadAlloc;
  }

  /* If we are changing windows, unregister our port in the old window */
  if(portPriv->pDraw && (portPriv->pDraw != pDraw))
     xf86XVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);

  /* Register our port with the new window */
  result =  xf86XVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
  if(result != Success) return result;

  portPriv->type = XvOutputMask;

  /* save a copy of these parameters */
  portPriv->vid_x = vid_x;  portPriv->vid_y = vid_y;
  portPriv->vid_w = vid_w;  portPriv->vid_h = vid_h;
  portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
  portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;

  /* make sure we have the most recent copy of the clientClip */
  xf86XVCopyClip(portPriv, pGC);
d1620 2
a1621 2
  /* To indicate to the DI layer that we were successful */
  pPort->pDraw = pDraw;
d1623 2
a1624 1
  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */
d1626 1
a1626 1
  return(xf86XVRegetVideo(portPriv));
d1630 17
a1646 57
xf86XVGetStill(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  if (pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */

  WinBox.x1 = pDraw->x + drw_x;
  WinBox.y1 = pDraw->y + drw_y;
  WinBox.x2 = WinBox.x1 + drw_w;
  WinBox.y2 = WinBox.y1 + drw_h;

  RegionInit(&WinRegion, &WinBox, 1);
  RegionNull(&ClipRegion);
  RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

  if(portPriv->pDraw) {
     xf86XVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);
  }

  if(!RegionNotEmpty(&ClipRegion)) {
     clippedAway = TRUE;
     goto GET_STILL_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->GetStill)(portPriv->pScrn,
		vid_x, vid_y, WinBox.x1, WinBox.y1,
		vid_w, vid_h, drw_w, drw_h,
		&ClipRegion, portPriv->DevPriv.ptr,
		pDraw);

GET_STILL_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }
d1648 24
a1671 2
  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);
d1673 13
a1685 2
  return ret;
}
d1687 2
d1690 2
d1694 3
a1696 6
xf86XVStopVideo(
   ClientPtr client,
   XvPortPtr pPort,
   DrawablePtr pDraw
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
d1698 2
a1699 2
  if(pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;
d1701 1
a1701 1
  xf86XVRemovePortFromWindow((WindowPtr)pDraw, portPriv);
d1703 2
a1704 1
  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */
d1706 1
a1706 1
  /* Must free resources. */
d1708 5
a1712 5
  if(portPriv->isOn > XV_OFF) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, TRUE);
	portPriv->isOn = XV_OFF;
  }
d1714 1
a1714 1
  return Success;
d1718 4
a1721 7
xf86XVSetPortAttribute(
   ClientPtr client,
   XvPortPtr pPort,
   Atom attribute,
   INT32 value
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
d1723 3
a1725 2
  return((*portPriv->AdaptorRec->SetPortAttribute)(portPriv->pScrn,
		attribute, value, portPriv->DevPriv.ptr));
a1727 1

d1729 4
a1732 7
xf86XVGetPortAttribute(
   ClientPtr client,
   XvPortPtr pPort,
   Atom attribute,
   INT32 *p_value
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
d1734 3
a1736 2
  return((*portPriv->AdaptorRec->GetPortAttribute)(portPriv->pScrn,
		attribute, p_value, portPriv->DevPriv.ptr));
d1739 14
d1754 2
d1758 116
a1873 13
xf86XVQueryBestSize(
   ClientPtr client,
   XvPortPtr pPort,
   CARD8 motion,
   CARD16 vid_w, CARD16 vid_h,
   CARD16 drw_w, CARD16 drw_h,
   unsigned int *p_w, unsigned int *p_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);

  (*portPriv->AdaptorRec->QueryBestSize)(portPriv->pScrn,
		(Bool)motion, vid_w, vid_h, drw_w, drw_h,
		p_w, p_h, portPriv->DevPriv.ptr);
d1875 1
a1875 1
  return Success;
a1877 1

d1879 12
a1890 131
xf86XVPutImage(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 src_x, INT16 src_y,
   CARD16 src_w, CARD16 src_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h,
   XvImagePtr format,
   unsigned char* data,
   Bool sync,
   CARD16 width, CARD16 height
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  if (pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */

  xf86XVCopyCompositeClip(portPriv, pGC, pDraw);

  WinBox.x1 = pDraw->x + drw_x;
  WinBox.y1 = pDraw->y + drw_y;
  WinBox.x2 = WinBox.x1 + drw_w;
  WinBox.y2 = WinBox.y1 + drw_h;

  RegionInit(&WinRegion, &WinBox, 1);
  RegionNull(&ClipRegion);
  RegionIntersect(&ClipRegion, &WinRegion, pGC->pCompositeClip);

  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = portPriv->pScrn->frameX0;
     VPBox.y1 = portPriv->pScrn->frameY0;
     VPBox.x2 = portPriv->pScrn->frameX1 + 1;
     VPBox.y2 = portPriv->pScrn->frameY1 + 1;

     RegionInit(&VPReg, &VPBox, 1);
     RegionIntersect(&ClipRegion, &ClipRegion, &VPReg);
     RegionUninit(&VPReg);
  }

  /* If we are changing windows, unregister our port in the old window */
  if(portPriv->pDraw && (portPriv->pDraw != pDraw))
     xf86XVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);

  /* Register our port with the new window */
  ret =  xf86XVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
  if(ret != Success) goto PUT_IMAGE_BAILOUT;

  if(!RegionNotEmpty(&ClipRegion)) {
     clippedAway = TRUE;
     goto PUT_IMAGE_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = RegionRects(&ClipRegion);
     if(  (RegionNumRects(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	  clippedAway = TRUE;
	  goto PUT_IMAGE_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     RegionSubtract(&ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->PutImage)(portPriv->pScrn,
		src_x, src_y, WinBox.x1, WinBox.y1,
		src_w, src_h, drw_w, drw_h, format->id, data, width, height,
		sync, &ClipRegion, portPriv->DevPriv.ptr,
		pDraw);

  if((ret == Success) &&
	(portPriv->AdaptorRec->flags & VIDEO_OVERLAID_IMAGES)) {

     portPriv->isOn = XV_ON;
     portPriv->vid_x = src_x;  portPriv->vid_y = src_y;
     portPriv->vid_w = src_w;  portPriv->vid_h = src_h;
     portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
     portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;
     portPriv->type = 0;  /* no mask means it's transient and should
			     not be reput once it's removed */
     pPort->pDraw = pDraw;  /* make sure we can get stop requests */
  }

PUT_IMAGE_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;

  RegionUninit(&WinRegion);
  RegionUninit(&ClipRegion);

  return ret;
}


static  int
xf86XVQueryImageAttributes(
   ClientPtr client,
   XvPortPtr pPort,
   XvImagePtr format,
   CARD16 *width,
   CARD16 *height,
   int *pitches,
   int *offsets
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);

  return (*portPriv->AdaptorRec->QueryImageAttributes)(portPriv->pScrn,
			format->id, width, height, pitches, offsets);
d1894 1
a1894 1
xf86XVFillKeyHelperDrawable (DrawablePtr pDraw, CARD32 key, RegionPtr fillboxes)
d1896 29
a1924 29
   ScreenPtr pScreen = pDraw->pScreen;
   ChangeGCVal pval[2];
   BoxPtr pbox = RegionRects(fillboxes);
   int i, nbox = RegionNumRects(fillboxes);
   xRectangle *rects;
   GCPtr gc;

   if(!xf86Screens[pScreen->myNum]->vtSema) return;

   gc = GetScratchGC(pDraw->depth, pScreen);
   pval[0].val = key;
   pval[1].val = IncludeInferiors;
   (void) ChangeGC(NullClient, gc, GCForeground|GCSubwindowMode, pval);
   ValidateGC(pDraw, gc);

   rects = malloc(nbox * sizeof(xRectangle));

   for(i = 0; i < nbox; i++, pbox++) 
   {
      rects[i].x = pbox->x1 - pDraw->x;
      rects[i].y = pbox->y1 - pDraw->y;
      rects[i].width = pbox->x2 - pbox->x1;
      rects[i].height = pbox->y2 - pbox->y1;
   }
   
   (*gc->ops->PolyFillRect)(pDraw, gc, nbox, rects);
   
   free(rects);
   FreeScratchGC (gc);
d1928 1
a1928 1
xf86XVFillKeyHelper (ScreenPtr pScreen, CARD32 key, RegionPtr fillboxes)
d1930 1
a1930 1
    xf86XVFillKeyHelperDrawable (&pScreen->root->drawable, key, fillboxes);
d1934 2
a1935 1
xf86XVFillKeyHelperPort (DrawablePtr pDraw, pointer data, CARD32 key, RegionPtr clipboxes, Bool fillEverything)
d1937 1
a1937 1
    WindowPtr pWin = (WindowPtr)pDraw;
d1944 1
a1944 1
	XvPortRecPrivatePtr pPriv = WinPriv->PortRec;
d1946 4
a1949 4
	if (data == pPriv->DevPriv.ptr) {
	    portPriv = pPriv;
	    break;
	}
d1951 1
a1951 1
	WinPriv = WinPriv->next;
d1955 1
a1955 1
	return;
d1958 1
a1958 1
	portPriv->ckeyFilled = RegionCreate(NULL, 0);
d1961 3
a1963 8
	RegionNull(&reg);
	fillboxes = &reg;
	RegionSubtract(fillboxes, clipboxes, portPriv->ckeyFilled);

	if (!RegionNotEmpty(fillboxes))
	    goto out;
    } else
	fillboxes = clipboxes;
d1965 5
d1974 1
a1974 1
out:
a1978 1

d1989 6
a1994 10
xf86XVClipVideoHelper(
    BoxPtr dst,
    INT32 *xa,
    INT32 *xb,
    INT32 *ya,
    INT32 *yb,
    RegionPtr reg,
    INT32 width,
    INT32 height
){
d2005 4
a2008 2
    *xa <<= 16; *xb <<= 16;
    *ya <<= 16; *yb <<= 16;
d2012 2
a2013 2
	dst->x1 = extents->x1;
	*xa += (diff * xsw) / xdw;
d2017 2
a2018 2
	dst->x2 = extents->x2;
	*xb -= (diff * xsw) / xdw;
d2022 2
a2023 2
	dst->y1 = extents->y1;
	*ya += (diff * ysw) / ydw;
d2027 2
a2028 2
	dst->y2 = extents->y2;
	*yb -= (diff * ysw) / ydw;
d2032 3
a2034 3
	diff = (((-*xa) * xdw) + xsw - 1) / xsw;
	dst->x1 += diff;
	*xa += (diff * xsw) / xdw;
d2038 3
a2040 3
	diff = ((delta * xdw) + xsw - 1) / xsw;
	dst->x2 -= diff;
	*xb -= (diff * xsw) / xdw;
d2042 2
a2043 1
    if (*xa >= *xb) return FALSE;
d2046 3
a2048 3
	diff = (((-*ya) * ydw) + ysw - 1) / ysw;
	dst->y1 += diff;
	*ya += (diff * ysw) / ydw;
d2052 3
a2054 3
	diff = ((delta * ydw) + ysw - 1) / ysw;
	dst->y2 -= diff;
	*yb -= (diff * ysw) / ydw;
d2056 2
a2057 1
    if (*ya >= *yb) return FALSE;
d2060 6
a2065 6
	(dst->y1 > extents->y1) || (dst->y2 < extents->y2))
    {
	RegionRec clipReg;
	RegionInit(&clipReg, dst, 1);
	RegionIntersect(reg, reg, &clipReg);
	RegionUninit(&clipReg);
d2071 7
a2077 11
xf86XVCopyYUV12ToPacked(
    const void *srcy,
    const void *srcv,
    const void *srcu,
    void *dst,
    int srcPitchy,
    int srcPitchuv,
    int dstPitch,
    int h,
    int w
){
d2084 7
a2090 5
    for (j = 0;  j < h;  j++) {
	Dst = dst;
	Y = srcy;  V = srcv;  U = srcu;
	i = w;
	while (i >= 4) {
d2092 4
a2095 4
	    Dst[0] = Y[0] | (Y[1] << 16) | (U[0] << 8) | (V[0] << 24);
	    Dst[1] = Y[2] | (Y[3] << 16) | (U[1] << 8) | (V[1] << 24);
	    Dst[2] = Y[4] | (Y[5] << 16) | (U[2] << 8) | (V[2] << 24);
	    Dst[3] = Y[6] | (Y[7] << 16) | (U[3] << 8) | (V[3] << 24);
d2097 5
a2101 5
	    /* This assumes a little-endian framebuffer */
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | V[0];
	    Dst[1] = (Y[2] << 24) | (Y[3] << 8) | (U[1] << 16) | V[1];
	    Dst[2] = (Y[4] << 24) | (Y[5] << 8) | (U[2] << 16) | V[2];
	    Dst[3] = (Y[6] << 24) | (Y[7] << 8) | (U[3] << 16) | V[3];
d2103 6
a2108 3
	    Dst += 4;  Y += 8;  V += 4;  U += 4;
	    i -= 4;
	}
d2110 1
a2110 1
	while (i--) {
d2112 1
a2112 1
	    Dst[0] = Y[0] | (Y[1] << 16) | (U[0] << 8) | (V[0] << 24);
d2114 2
a2115 2
	    /* This assumes a little-endian framebuffer */
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | V[0];
d2117 12
a2128 9
	    Dst++;  Y += 2;  V++;  U++;
	}

	dst = (CARD8 *)dst + dstPitch;
	srcy = (const CARD8 *)srcy + srcPitchy;
	if (j & 1) {
	    srcu = (const CARD8 *)srcu + srcPitchuv;
	    srcv = (const CARD8 *)srcv + srcPitchuv;
	}
d2133 3
a2135 8
xf86XVCopyPacked(
    const void *src,
    void *dst,
    int srcPitch,
    int dstPitch,
    int h,
    int w
){
d2142 23
a2164 17
	do {
	    Dst = dst;  Src = src;
	    i = w;
	    while (i >= 4) {
		Dst[0] = Src[0];
		Dst[1] = Src[1];
		Dst[2] = Src[2];
		Dst[3] = Src[3];
		Dst += 4;  Src += 4;  i -= 4;
	    }
	    if (!i) break;
	    Dst[0] = Src[0];
	    if (i == 1) break;
	    Dst[1] = Src[1];
	    if (i == 2) break;
	    Dst[2] = Src[2];
	} while (0);
d2166 2
a2167 2
	src = (const CARD8 *)src + srcPitch;
	dst = (CARD8 *)dst + dstPitch;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d100 1
d103 2
d110 1
a285 2
  ScreenPriv->videoGC = NULL;  /* for the helper */

d288 1
d293 1
d302 1
d316 1
d324 1
d328 1
d341 2
d347 1
d350 1
a350 1
   if(pAdaptor->nAttributes) {
d356 1
d361 2
d446 1
a446 2
      if((pa->name = malloc(strlen(adaptorPtr->name) + 1)))
	  strcpy(pa->name, adaptorPtr->name);
d456 1
a456 2
	    if((pe->name = malloc(strlen(encodingPtr->name) + 1)))
		strcpy(pe->name, encodingPtr->name);
d508 1
a508 2
	    if((pat->name = malloc(strlen(attributePtr->name) + 1)))
		strcpy(pat->name, attributePtr->name);
d573 1
a573 1
      adaptorPriv->ReputImage = adaptorPtr->ReputImage;
d678 1
a678 2
			portPriv->pDraw->x + portPriv->clipOrg.x,
			portPriv->pDraw->y + portPriv->clipOrg.y);
d703 2
d715 21
a735 1
    portPriv->clipOrg = pGC->clipOrg;
d890 1
d902 5
d956 1
d958 2
a1031 1

d1048 75
a1145 3
     if(WinPriv->pGC) {
       FreeGC(WinPriv->pGC, 0);
     }
d1159 23
a1188 1
  XF86XVWindowPtr pPrev;
d1201 2
a1202 1
  pPrev = NULL;
a1203 1
  while(WinPriv) {
d1206 21
a1226 1
     /* Reput anyone with a reput function */
d1228 2
a1229 12
     switch(pPriv->type) {
     case XvInputMask:
	xf86XVReputVideo(pPriv);
	break;
     case XvOutputMask:
	xf86XVRegetVideo(pPriv);
	break;
     default:  /* overlaid still/image*/
	if (pPriv->AdaptorRec->ReputImage)
	   xf86XVReputImage(pPriv);
	else if(AreasExposed) {
	    XF86XVWindowPtr tmp;
d1231 1
a1231 21
	    if (pPriv->isOn == XV_ON) {
		(*pPriv->AdaptorRec->StopVideo)(
		    pPriv->pScrn, pPriv->DevPriv.ptr, FALSE);
		pPriv->isOn = XV_PENDING;
	    }
	    pPriv->pDraw = NULL;

	    if(!pPrev)
		dixSetPrivate(&pWin->devPrivates, XF86XVWindowKey,
			      WinPriv->next);
	    else
	       pPrev->next = WinPriv->next;
	    tmp = WinPriv;
	    WinPriv = WinPriv->next;
	    free(tmp);
	    continue;
	}
	break;
     }
     pPrev = WinPriv;
     WinPriv = WinPriv->next;
a1234 1

a1240 1
  XF86XVWindowPtr tmp, pPrev = NULL;
a1241 2
  Bool visible = (pWin->visibility == VisibilityUnobscured) ||
		 (pWin->visibility == VisibilityPartiallyObscured);
a1245 2
     if(!pPriv) goto next;
 
d1255 1
a1255 2
     /* Stop everything except images, but stop them too if the
	window isn't visible.  But we only remove the images. */
d1257 3
a1259 20
     if(pPriv->type || !visible) {
	if(pPriv->isOn == XV_ON) {
	    (*pPriv->AdaptorRec->StopVideo)(
			pPriv->pScrn, pPriv->DevPriv.ptr, FALSE);
	    pPriv->isOn = XV_PENDING;
	}

	if(!pPriv->type) {  /* overlaid still/image */
	    pPriv->pDraw = NULL;

	    if(!pPrev)
		dixSetPrivate(&pWin->devPrivates, XF86XVWindowKey,
			      WinPriv->next);
	    else
	       pPrev->next = WinPriv->next;
	    tmp = WinPriv;
	    WinPriv = WinPriv->next;
	    free(tmp);
	    continue;
	}
a1261 2
next:
     pPrev = WinPriv;
a1286 5
  if(ScreenPriv->videoGC) {
     FreeGC(ScreenPriv->videoGC, 0);
     ScreenPriv->videoGC = NULL;
  }

d1294 1
a1386 1
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
a1387 3
  WindowPtr pWin;
  XvAdaptorPtr pa;
  int c, i;
d1395 2
a1396 3
  for(c = pxvs->nAdaptors, pa = pxvs->pAdaptors; c > 0; c--, pa++) {
      XvPortPtr pPort = pa->pPorts;
      XvPortRecPrivatePtr pPriv;
d1398 5
a1402 2
      for(i = pa->nPorts; i > 0; i--, pPort++) {
	pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
d1404 3
a1406 1
	if(!pPriv->type && (pPriv->isOn != XV_OFF)) { /* overlaid still/image */
d1408 1
a1408 2
	  if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
	     RegionDestroy(pPriv->pCompositeClip);
d1410 5
a1414 1
	  pPriv->pCompositeClip = NULL;
d1416 1
a1416 17
	  pWin = (WindowPtr)pPriv->pDraw;

	  if ((pPriv->AdaptorRec->ReputImage) &&
	     ((pWin->visibility == VisibilityUnobscured) ||
	      (pWin->visibility == VisibilityPartiallyObscured)))
	  {
	      xf86XVReputImage(pPriv);
	  } else if (pPriv->isOn == XV_ON) {
	     (*pPriv->AdaptorRec->StopVideo)(
				 pPriv->pScrn, pPriv->DevPriv.ptr, FALSE);
	     xf86XVRemovePortFromWindow(pWin, pPriv);
	     pPriv->isOn = XV_PENDING;
	     continue;
	  }
	}
     }
  }
a1418 1

d1515 2
d1570 2
d1587 4
d1812 2
d1875 2
d1892 4
a1918 1

d1920 1
a1920 1
xf86XVFillKeyHelperDrawable (DrawablePtr pDraw, CARD32 key, RegionPtr clipboxes)
a1922 51
   WindowPtr pWin = (WindowPtr)pDraw;
   XF86XVWindowPtr pPriv = GET_XF86XV_WINDOW(pWin);
   GCPtr pGC = NULL;
   BoxPtr pbox = RegionRects(clipboxes);
   int i, nbox = RegionNumRects(clipboxes);
   xRectangle *rects;

   if(!xf86Screens[pScreen->myNum]->vtSema) return;

   if(pPriv)
      pGC = pPriv->pGC;

   if(!pGC) {
       int status;
       XID pval[2];
       pval[0] = key;
       pval[1] = IncludeInferiors;
       pGC = CreateGC(pDraw, GCForeground | GCSubwindowMode, pval, &status,
		      (XID)0, serverClient);
       if(!pGC) return;
       ValidateGC(pDraw, pGC);
       if (pPriv) pPriv->pGC = pGC;
   } else if (key != pGC->fgPixel){
       ChangeGCVal val;
       val.val = key;
       ChangeGC(NullClient, pGC, GCForeground, &val);
       ValidateGC(pDraw, pGC);
   }

   RegionTranslate(clipboxes, -pDraw->x, -pDraw->y);

   rects = malloc(nbox * sizeof(xRectangle));

   for(i = 0; i < nbox; i++, pbox++) {
      rects[i].x = pbox->x1;
      rects[i].y = pbox->y1;
      rects[i].width = pbox->x2 - pbox->x1;
      rects[i].height = pbox->y2 - pbox->y1;
   }

   (*pGC->ops->PolyFillRect)(pDraw, pGC, nbox, rects);

   if (!pPriv) FreeGC(pGC, 0);

   free(rects);
}

void
xf86XVFillKeyHelper (ScreenPtr pScreen, CARD32 key, RegionPtr clipboxes)
{
   DrawablePtr root = &pScreen->root->drawable;
d1924 2
a1925 2
   BoxPtr pbox = RegionRects(clipboxes);
   int i, nbox = RegionNumRects(clipboxes);
d1931 1
a1931 1
   gc = GetScratchGC(root->depth, pScreen);
d1935 1
a1935 1
   ValidateGC(root, gc);
d1941 2
a1942 2
      rects[i].x = pbox->x1;
      rects[i].y = pbox->y1;
d1947 1
a1947 1
   (*gc->ops->PolyFillRect)(root, gc, nbox, rects);
d1952 52
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d113 5
a117 4
static int XF86XVWindowKeyIndex;
static DevPrivateKey XF86XVWindowKey = &XF86XVWindowKeyIndex;
static int XF86XvScreenKeyIndex;
DevPrivateKey XF86XvScreenKey = &XF86XvScreenKeyIndex;
d142 1
a142 1
  newdrivers = xrealloc(GenDrivers, sizeof(xf86XVInitGenericAdaptorPtr) *
d172 1
a172 1
	new = xrealloc(*adaptors, sizeof(XF86VideoAdaptorPtr) * (num+n));
d190 3
a192 1
static OffscreenImageRec OffscreenImages[MAXSCREENS];
d200 9
a208 2
    OffscreenImages[pScreen->myNum].num = num;
    OffscreenImages[pScreen->myNum].images = images;
d210 2
d220 3
a222 2
   *num = OffscreenImages[pScreen->myNum].num;
   return OffscreenImages[pScreen->myNum].images;
d229 1
a229 1
    return xcalloc(1, sizeof(XF86VideoAdaptorRec));
d235 1
a235 1
    xfree(ptr);
d255 3
d259 1
d275 1
a275 1
  ScreenPriv = xalloc(sizeof(XF86XVScreenRec));
d310 1
a310 1
   xfree(pAdaptor->name);
d316 2
a317 2
	  xfree(pEncode->name);
      xfree(pAdaptor->pEncodings);
d320 1
a320 1
   xfree(pAdaptor->pFormats);
d330 1
a330 1
		REGION_DESTROY(pAdaptor->pScreen, pPriv->clientClip);
d332 2
a333 2
		REGION_DESTROY(pAdaptor->pScreen, pPriv->pCompositeClip);
	     xfree(pPriv);
d336 1
a336 1
      xfree(pAdaptor->pPorts);
d343 2
a344 2
	  xfree(pAttribute->name);
      xfree(pAdaptor->pAttributes);
d347 2
a348 2
   xfree(pAdaptor->pImages);
   xfree(pAdaptor->devPriv.ptr);
d382 1
a382 1
  if(!(pAdaptor = xcalloc(number, sizeof(XvAdaptorRec))))
d432 1
a432 1
      if((pa->name = xalloc(strlen(adaptorPtr->name) + 1)))
d436 1
a436 1
	(pEncode = xcalloc(adaptorPtr->nEncodings, sizeof(XvEncodingRec)))) {
d443 1
a443 1
	    if((pe->name = xalloc(strlen(encodingPtr->name) + 1)))
d455 1
a455 1
	 (pImage = xcalloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {
d488 1
a488 1
	(pAttribute = xcalloc(adaptorPtr->nAttributes, sizeof(XvAttributeRec))))
d496 1
a496 1
	    if((pat->name = xalloc(strlen(attributePtr->name) + 1)))
d506 1
a506 1
      if(!(pFormat = xcalloc(totFormat, sizeof(XvFormatRec)))) {
d523 1
a523 1
			moreSpace = xrealloc(pFormat,
d546 1
a546 1
      if(!(adaptorPriv = xcalloc(1, sizeof(XvAdaptorRecPrivate)))) {
d566 1
a566 1
      if(!(pPort = xcalloc(adaptorPtr->nPorts, sizeof(XvPortRec)))) {
d576 1
a576 1
	  if(!(portPriv = xcalloc(1, sizeof(XvPortRecPrivate))))
d580 1
a580 1
		xfree(portPriv);
d616 1
a616 1
     xfree(pAdaptor);
a643 1
   ScreenPtr	pScreen;
a649 1
   pScreen = pWin->drawable.pScreen;
d664 3
a666 3
   pCompositeClip = REGION_CREATE(pScreen, NullBox, 1);
   REGION_COPY(pScreen, pCompositeClip, portPriv->clientClip);
   REGION_TRANSLATE(pScreen, pCompositeClip,
d669 1
a669 1
   REGION_INTERSECT(pScreen, pCompositeClip, pregWin, pCompositeClip);
d675 1
a675 1
	REGION_DESTROY(pScreen, pregWin);
d690 1
a690 1
	    portPriv->clientClip = REGION_CREATE(pScreen, NullBox, 1);
d692 1
a692 1
	REGION_COPY(pScreen, portPriv->clientClip, pGC->clientClip);
d694 1
a694 1
	REGION_DESTROY(pScreen, portPriv->clientClip);
d700 1
a700 1
	REGION_DESTROY(pScreen, portPriv->pCompositeClip);
a714 1
  ScreenPtr pScreen;
a717 1
  pScreen = portPriv->pDraw->pScreen;
d727 3
a729 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);
d732 1
a732 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d738 1
a738 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d764 2
a765 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
a776 1
  ScreenPtr pScreen;
a779 2
  pScreen = portPriv->pDraw->pScreen;

d789 3
a791 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);
d803 3
a805 3
     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
d809 1
a809 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d816 2
a817 2
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
d827 1
a827 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d852 2
a853 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
a863 1
  ScreenPtr pScreen;
a866 2
  pScreen = portPriv->pDraw->pScreen;

d876 3
a878 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);
d890 3
a892 3
     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
d896 1
a896 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d903 2
a904 2
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
d914 1
a914 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d936 2
a937 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
d974 1
a974 1
	winPriv = xcalloc(1, sizeof(XF86XVWindowRec));
d1001 1
a1001 1
	    xfree(winPriv);
d1035 1
a1035 1
     xfree(tmp);
d1058 1
a1058 1
  AreasExposed = (WinPriv && reg1 && REGION_NOTEMPTY(pScreen, reg1));
d1101 1
a1101 1
	    xfree(tmp);
d1129 1
a1129 1
	REGION_DESTROY(pScreen, pPriv->pCompositeClip);
d1157 1
a1157 1
	    xfree(tmp);
a1186 3
  /* Clear offscreen images */
  memset(&OffscreenImages[pScreen->myNum], 0, sizeof(OffscreenImages[0]));

d1206 2
a1207 2
  xfree(pxvs->pAdaptors);
  xfree(ScreenPriv);
d1223 1
a1223 1
  return (Success);
d1232 1
d1237 1
d1239 2
d1250 1
d1271 1
a1271 1
		    REGION_DESTROY(pScreen, pPriv->pCompositeClip);
d1282 1
d1284 2
d1315 1
a1315 1
	     REGION_DESTROY(pScreen, pPriv->pCompositeClip);
a1418 1
  ScreenPtr pScreen;
a1429 2
  pScreen = pDraw->pScreen;

d1435 3
a1437 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1448 3
a1450 3
     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
d1457 1
a1457 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d1463 2
a1464 2
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
d1474 1
a1474 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d1503 2
a1504 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
a1567 1
  ScreenPtr pScreen;
a1578 2
  pScreen = pDraw->pScreen;

d1584 3
a1586 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1592 1
a1592 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d1598 1
a1598 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d1615 2
a1616 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
a1712 1
  ScreenPtr pScreen;
a1723 2
  pScreen = pDraw->pScreen;

d1729 3
a1731 3
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1742 3
a1744 3
     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
d1755 1
a1755 1
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
d1761 2
a1762 2
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
d1772 1
a1772 1
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
d1800 2
a1801 2
  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);
d1831 2
a1832 3
   XID pval[2];
   BoxPtr pbox = REGION_RECTS(clipboxes);
   int i, nbox = REGION_NUM_RECTS(clipboxes);
d1842 1
d1851 3
a1853 2
       pval[0] = key;
       ChangeGC(pGC, GCForeground, pval);
d1857 1
a1857 1
   REGION_TRANSLATE(pDraw->pScreen, clipboxes, -pDraw->x, -pDraw->y);
d1859 1
a1859 1
   rects = xalloc(nbox * sizeof(xRectangle));
d1872 1
a1872 1
   xfree(rects);
d1878 4
a1881 4
   DrawablePtr root = &WindowTable[pScreen->myNum]->drawable;
   XID pval[2];
   BoxPtr pbox = REGION_RECTS(clipboxes);
   int i, nbox = REGION_NUM_RECTS(clipboxes);
d1888 3
a1890 3
   pval[0] = key;
   pval[1] = IncludeInferiors;
   (void) ChangeGC(gc, GCForeground|GCSubwindowMode, pval);
d1893 1
a1893 1
   rects = xalloc (nbox * sizeof(xRectangle));
d1905 1
a1905 1
   xfree (rects);
a1917 2
#define DummyScreen screenInfo.screens[0]

d1931 1
a1931 1
    BoxPtr extents = REGION_EXTENTS(DummyScreen, reg);
d1993 3
a1995 3
	REGION_INIT(DummyScreen, &clipReg, dst, 1);
	REGION_INTERSECT(DummyScreen, reg, reg, &clipReg);
	REGION_UNINIT(DummyScreen, &clipReg);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d135 1
a135 1
_X_EXPORT int
d152 1
a152 1
_X_EXPORT int
d191 1
a191 1
_X_EXPORT Bool
d203 1
a203 1
_X_EXPORT XF86OffscreenImagePtr
d213 1
a213 1
_X_EXPORT XF86VideoAdaptorPtr
d219 1
a219 1
_X_EXPORT void
d226 1
a226 1
_X_EXPORT Bool
d790 2
a791 2
     VPBox.x2 = portPriv->pScrn->frameX1;
     VPBox.y2 = portPriv->pScrn->frameY1;
d880 2
a881 2
     VPBox.x2 = portPriv->pScrn->frameX1;
     VPBox.y2 = portPriv->pScrn->frameY1;
d1126 4
d1300 1
a1300 1
	if(!pPriv->type && (pPriv->isOn == XV_ON)) { /* overlaid still/image */
d1314 1
a1314 1
	  } else {
d1436 2
a1437 2
     VPBox.x2 = portPriv->pScrn->frameX1;
     VPBox.y2 = portPriv->pScrn->frameY1;
d1821 1
a1821 1
_X_EXPORT void
d1871 1
a1871 1
_X_EXPORT void
d1916 1
a1916 1
_X_EXPORT Bool
d1998 1
a1998 1
_X_EXPORT void
d2056 1
a2056 1
_X_EXPORT void
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d113 4
a116 2
static DevPrivateKey XF86XVWindowKey = &XF86XVWindowKey;
DevPrivateKey XF86XvScreenKey;
d967 1
a967 1
	winPriv = xalloc(sizeof(XF86XVWindowRec));
a968 1
	memset(winPriv, 0, sizeof(XF86XVWindowRec));
d1177 1
a1177 1
  (void)memset(&OffscreenImages[pScreen->myNum], 0, sizeof(OffscreenImages[0]));
@


1.1
log
@Initial revision
@
text
@d113 2
a114 3
int XF86XVWindowIndex = -1;
int XF86XvScreenIndex = -1;
static unsigned long XF86XVGeneration = 0;
d117 1
a117 1
int (*XvGetScreenIndexProc)(void) = NULL;
d122 1
a122 1
	((XvScreenPtr)((pScreen)->devPrivates[XF86XvScreenIndex].ptr))
d125 1
a125 1
	((XF86XVScreenPtr)(GET_XV_SCREEN(pScreen)->devPriv.ptr))
d128 1
a128 1
	((XF86XVWindowPtr)((pWin)->devPrivates[XF86XVWindowIndex].ptr))
d235 1
a235 10
     !XvGetScreenIndexProc || !XvGetRTPortProc || !XvScreenInitProc)
	return FALSE;

  if(XF86XVGeneration != serverGeneration) {
	if((XF86XVWindowIndex = AllocateWindowPrivateIndex()) < 0)
	    return FALSE;
	XF86XVGeneration = serverGeneration;
  }

  if(!AllocateWindowPrivate(pScreen,XF86XVWindowIndex,0))
d240 1
a240 1
  XF86XvScreenIndex = (*XvGetScreenIndexProc)();
d967 1
d970 1
a970 1
	pWin->devPrivates[XF86XVWindowIndex].ptr = (pointer)winPriv;
d972 3
d991 2
a992 2
		pWin->devPrivates[XF86XVWindowIndex].ptr =
					(pointer)winPriv->next;
d1023 3
d1030 1
a1030 1
  pWin->devPrivates[XF86XVWindowIndex].ptr = NULL;
d1087 2
a1088 2
	       pWin->devPrivates[XF86XVWindowIndex].ptr =
						(pointer)(WinPriv->next);
d1118 2
d1139 2
a1140 2
	       pWin->devPrivates[XF86XVWindowIndex].ptr =
						(pointer)(WinPriv->next);
d1150 1
a1370 1
  portPriv->pDraw = pDraw;
a1473 1
     portPriv->pDraw = pDraw;
a1522 1
  portPriv->pDraw = pDraw;
d1739 2
a1740 1
  if(portPriv->pDraw) {
d1742 4
a1745 1
  }
a1775 1
     xf86XVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
a1776 1
     portPriv->pDraw = pDraw;
d1815 1
d1817 1
a1817 1
xf86XVFillKeyHelper (ScreenPtr pScreen, CARD32 key, RegionPtr clipboxes)
d1819 4
a1822 2
   XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
   DrawablePtr root = &WindowTable[pScreen->myNum]->drawable;
d1830 4
a1833 1
   if(!ScreenPriv->videoGC) {
d1837 6
a1842 5
       ScreenPriv->videoGC = CreateGC(root, GCForeground | GCSubwindowMode,
				      pval, &status);
       if(!ScreenPriv->videoGC) return;
       ValidateGC(root, ScreenPriv->videoGC);
   } else if (key != ScreenPriv->videoGC->fgPixel){
d1844 2
a1845 2
       ChangeGC(ScreenPriv->videoGC, GCForeground, pval);
       ValidateGC(root, ScreenPriv->videoGC);
d1848 3
a1850 1
   rects = ALLOCATE_LOCAL(nbox * sizeof(xRectangle));
d1859 3
a1861 2
   (*ScreenPriv->videoGC->ops->PolyFillRect)(
			     root, ScreenPriv->videoGC, nbox, rects);
d1863 35
a1897 1
   DEALLOCATE_LOCAL(rects);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d113 1
a113 1
static int XF86XVWindowIndex = -1;
a976 1
	memset(winPriv, 0, sizeof(XF86XVWindowRec));
a980 3

   portPriv->pDraw = (DrawablePtr)pWin;

a1028 3
     if(WinPriv->pGC) {
       FreeGC(WinPriv->pGC, 0);
     }
a1120 2
     if(!pPriv) goto next;
 
a1150 1
next:
d1371 1
d1475 1
d1525 1
d1742 1
a1742 2
  /* If we are changing windows, unregister our port in the old window */
  if(portPriv->pDraw && (portPriv->pDraw != pDraw))
d1744 1
a1744 4

  /* Register our port with the new window */
  ret =  xf86XVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
  if(ret != Success) goto PUT_IMAGE_BAILOUT;
d1775 1
d1777 1
a1815 1

d1817 1
a1817 1
xf86XVFillKeyHelperDrawable (DrawablePtr pDraw, CARD32 key, RegionPtr clipboxes)
d1819 2
a1820 4
   ScreenPtr pScreen = pDraw->pScreen;
   WindowPtr pWin = (WindowPtr)pDraw;
   XF86XVWindowPtr pPriv = GET_XF86XV_WINDOW(pWin);
   GCPtr pGC = NULL;
d1828 1
a1828 4
   if(pPriv)
      pGC = pPriv->pGC;

   if(!pGC) {
d1832 5
a1836 5
       pGC = CreateGC(pDraw, GCForeground | GCSubwindowMode, pval, &status);
       if(!pGC) return;
       ValidateGC(pDraw, pGC);
       if (pPriv) pPriv->pGC = pGC;
   } else if (key != pGC->fgPixel){
d1838 2
a1839 2
       ChangeGC(pGC, GCForeground, pval);
       ValidateGC(pDraw, pGC);
a1841 2
   REGION_TRANSLATE(pDraw->pScreen, clipboxes, -pDraw->x, -pDraw->y);

d1851 2
a1852 3
   (*pGC->ops->PolyFillRect)(pDraw, pGC, nbox, rects);

   if (!pPriv) FreeGC(pGC, 0);
a1854 34
}

_X_EXPORT void
xf86XVFillKeyHelper (ScreenPtr pScreen, CARD32 key, RegionPtr clipboxes)
{
   DrawablePtr root = &WindowTable[pScreen->myNum]->drawable;
   XID pval[2];
   BoxPtr pbox = REGION_RECTS(clipboxes);
   int i, nbox = REGION_NUM_RECTS(clipboxes);
   xRectangle *rects;
   GCPtr gc;

   if(!xf86Screens[pScreen->myNum]->vtSema) return;

   gc = GetScratchGC(root->depth, pScreen);
   pval[0] = key;
   pval[1] = IncludeInferiors;
   (void) ChangeGC(gc, GCForeground|GCSubwindowMode, pval);
   ValidateGC(root, gc);

   rects = xalloc (nbox * sizeof(xRectangle));

   for(i = 0; i < nbox; i++, pbox++) 
   {
      rects[i].x = pbox->x1;
      rects[i].y = pbox->y1;
      rects[i].width = pbox->x2 - pbox->x1;
      rects[i].height = pbox->y2 - pbox->y1;
   }
   
   (*gc->ops->PolyFillRect)(root, gc, nbox, rects);
   
   xfree (rects);
   FreeScratchGC (gc);
@

