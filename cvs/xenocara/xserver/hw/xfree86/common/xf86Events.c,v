head	1.18;
access;
symbols
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.2
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.2
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	s0SI41sEunLdyFfd;

1.17
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	Te1daavkBLskZ8gc;

1.16
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	cVXoV5PxI8YrEaVA;

1.15
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.08.24.19.44.38;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.13.21.47.54;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.03;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.02;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.02;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.46;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.13.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Thomas Roell not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Thomas Roell makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * THOMAS ROELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THOMAS ROELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */
/*
 * Copyright (c) 1994-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

/* [JCH-96/01/21] Extended std reverse map to four buttons. */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include <X11/Xpoll.h>
#include <X11/Xproto.h>
#include <X11/Xatom.h>
#include "misc.h"
#include "xf86.h"
#include "xf86Priv.h"
#define XF86_OS_PRIVS
#include "xf86_OSlib.h"
#include <X11/keysym.h>

#ifdef XFreeXDGA
#include "dgaproc.h"
#endif

#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "inputstr.h"
#include "xf86Xinput.h"

#include "mi.h"
#include "mipointer.h"

#include "xkbsrv.h"
#include "xkbstr.h"

#ifdef DPMSExtension
#include <X11/extensions/dpmsconst.h>
#include "dpmsproc.h"
#endif

#include "xf86platformBus.h"
#include "systemd-logind.h"

/*
 * This is a toggling variable:
 *  FALSE = No VT switching keys have been pressed last time around
 *  TRUE  = Possible VT switch Pending
 * (DWH - 12/2/93)
 *
 * This has been generalised to work with Linux and *BSD+syscons (DHD)
 */

Bool VTSwitchEnabled = TRUE;    /* Allows run-time disabling for
                                 *BSD and for avoiding VT
                                 switches when using the DRI
                                 automatic full screen mode.*/

extern fd_set EnabledDevices;

#ifdef XF86PM
extern void (*xf86OSPMClose) (void);
#endif

static void xf86VTSwitch(void);

/*
 * Allow arbitrary drivers or other XFree86 code to register with our main
 * Wakeup handler.
 */
typedef struct x_IHRec {
    int fd;
    InputHandlerProc ihproc;
    void *data;
    Bool enabled;
    Bool is_input;
    struct x_IHRec *next;
} IHRec, *IHPtr;

static IHPtr InputHandlers = NULL;

Bool
LegalModifier(unsigned int key, DeviceIntPtr pDev)
{
    return TRUE;
}

/*
 * TimeSinceLastInputEvent --
 *      Function used for screensaver purposes by the os module. Returns the
 *      time in milliseconds since there last was any input.
 */
int
TimeSinceLastInputEvent(void)
{
    if (xf86Info.lastEventTime == 0) {
        xf86Info.lastEventTime = GetTimeInMillis();
    }
    return GetTimeInMillis() - xf86Info.lastEventTime;
}

/*
 * SetTimeSinceLastInputEvent --
 *      Set the lastEventTime to now.
 */
void
SetTimeSinceLastInputEvent(void)
{
    xf86Info.lastEventTime = GetTimeInMillis();
}

/*
 * ProcessInputEvents --
 *      Retrieve all waiting input events and pass them to DIX in their
 *      correct chronological order. Only reads from the system pointer
 *      and keyboard.
 */
void
ProcessInputEvents(void)
{
    int x, y;

    mieqProcessInputEvents();

    /* FIXME: This is a problem if we have multiple pointers */
    miPointerGetPosition(inputInfo.pointer, &x, &y);

    xf86SetViewport(xf86Info.currentScreen, x, y);
}

/*
 * Handle keyboard events that cause some kind of "action"
 * (i.e., server termination, video mode changes, VT switches, etc.)
 */
void
xf86ProcessActionEvent(ActionEvent action, void *arg)
{
    DebugF("ProcessActionEvent(%d,%p)\n", (int) action, arg);
    switch (action) {
    case ACTION_TERMINATE:
        if (!xf86Info.dontZap) {
            xf86Msg(X_INFO, "Server zapped. Shutting down.\n");
#ifdef XFreeXDGA
            DGAShutdown();
#endif
            GiveUp(0);
        }
        break;
    case ACTION_NEXT_MODE:
        if (!xf86Info.dontZoom)
            xf86ZoomViewport(xf86Info.currentScreen, 1);
        break;
    case ACTION_PREV_MODE:
        if (!xf86Info.dontZoom)
            xf86ZoomViewport(xf86Info.currentScreen, -1);
        break;
    case ACTION_SWITCHSCREEN:
        if (VTSwitchEnabled && !xf86Info.dontVTSwitch && arg) {
            int vtno = *((int *) arg);

            if (vtno != xf86Info.vtno) {
                if (!xf86VTActivate(vtno)) {
                    ErrorF("Failed to switch from vt%02d to vt%02d: %s\n",
                           xf86Info.vtno, vtno, strerror(errno));
                }
            }
        }
        break;
    case ACTION_SWITCHSCREEN_NEXT:
        if (VTSwitchEnabled && !xf86Info.dontVTSwitch) {
            if (!xf86VTActivate(xf86Info.vtno + 1)) {
                /* If first try failed, assume this is the last VT and
                 * try wrapping around to the first vt.
                 */
                if (!xf86VTActivate(1)) {
                    ErrorF("Failed to switch from vt%02d to next vt: %s\n",
                           xf86Info.vtno, strerror(errno));
                }
            }
        }
        break;
    case ACTION_SWITCHSCREEN_PREV:
        if (VTSwitchEnabled && !xf86Info.dontVTSwitch && xf86Info.vtno > 0) {
            if (!xf86VTActivate(xf86Info.vtno - 1)) {
                /* Don't know what the maximum VT is, so can't wrap around */
                ErrorF("Failed to switch from vt%02d to previous vt: %s\n",
                       xf86Info.vtno, strerror(errno));
            }
        }
        break;
    default:
        break;
    }
}

/*
 * xf86Wakeup --
 *      Os wakeup handler.
 */

/* ARGSUSED */
void
xf86Wakeup(void *blockData, int err, void *pReadmask)
{
    fd_set *LastSelectMask = (fd_set *) pReadmask;
    fd_set devicesWithInput;
    InputInfoPtr pInfo;

    if (err >= 0) {

        XFD_ANDSET(&devicesWithInput, LastSelectMask, &EnabledDevices);
        if (XFD_ANYSET(&devicesWithInput)) {
            pInfo = xf86InputDevs;
            while (pInfo) {
                if (pInfo->read_input && pInfo->fd >= 0 &&
                    (FD_ISSET(pInfo->fd, &devicesWithInput) != 0)) {
                    OsBlockSIGIO();

                    /*
                     * Remove the descriptior from the set because more than one
                     * device may share the same file descriptor.
                     */
                    FD_CLR(pInfo->fd, &devicesWithInput);

                    pInfo->read_input(pInfo);
                    OsReleaseSIGIO();
                }
                pInfo = pInfo->next;
            }
        }
    }

    if (err >= 0) {             /* we don't want the handlers called if select() */
        IHPtr ih, ih_tmp;       /* returned with an error condition, do we?      */

        nt_list_for_each_entry_safe(ih, ih_tmp, InputHandlers, next) {
            if (ih->enabled && ih->fd >= 0 && ih->ihproc &&
                (FD_ISSET(ih->fd, ((fd_set *) pReadmask)) != 0)) {
                ih->ihproc(ih->fd, ih->data);
            }
        }
    }

    if (xf86VTSwitchPending())
        xf86VTSwitch();
}

/*
 * xf86SigioReadInput --
 *    signal handler for the SIGIO signal.
 */
static void
xf86SigioReadInput(int fd, void *closure)
{
    int errno_save = errno;
    InputInfoPtr pInfo = closure;

    pInfo->read_input(pInfo);

    errno = errno_save;
}

/*
 * xf86AddEnabledDevice --
 *
 */
void
xf86AddEnabledDevice(InputInfoPtr pInfo)
{
    if (!xf86InstallSIGIOHandler(pInfo->fd, xf86SigioReadInput, pInfo)) {
        AddEnabledDevice(pInfo->fd);
    }
}

/*
 * xf86RemoveEnabledDevice --
 *
 */
void
xf86RemoveEnabledDevice(InputInfoPtr pInfo)
{
    if (!xf86RemoveSIGIOHandler(pInfo->fd)) {
        RemoveEnabledDevice(pInfo->fd);
    }
}

static int *xf86SignalIntercept = NULL;

void
xf86InterceptSignals(int *signo)
{
    if ((xf86SignalIntercept = signo))
        *signo = -1;
}

static void (*xf86SigIllHandler) (void) = NULL;

void
xf86InterceptSigIll(void (*sigillhandler) (void))
{
    xf86SigIllHandler = sigillhandler;
}

/*
 * xf86SigWrapper --
 *    Catch unexpected signals and exit or continue cleanly.
 */
int
xf86SigWrapper(int signo)
{
    if ((signo == SIGILL) && xf86SigIllHandler) {
        (*xf86SigIllHandler) ();
        return 0;               /* continue */
    }

    if (xf86SignalIntercept && (*xf86SignalIntercept < 0)) {
        *xf86SignalIntercept = signo;
        return 0;               /* continue */
    }

    xf86Info.caughtSignal = TRUE;
    return 1;                   /* abort */
}

/*
 * xf86PrintBacktrace --
 *    Print a stack backtrace for debugging purposes.
 */
void
xf86PrintBacktrace(void)
{
    xorg_backtrace();
}

static void
xf86ReleaseKeys(DeviceIntPtr pDev)
{
    KeyClassPtr keyc;
    int i;

    if (!pDev || !pDev->key)
        return;

    keyc = pDev->key;

    /*
     * Hmm... here is the biggest hack of every time !
     * It may be possible that a switch-vt procedure has finished BEFORE
     * you released all keys neccessary to do this. That peculiar behavior
     * can fool the X-server pretty much, cause it assumes that some keys
     * were not released. TWM may stuck alsmost completly....
     * OK, what we are doing here is after returning from the vt-switch
     * exeplicitely unrelease all keyboard keys before the input-devices
     * are reenabled.
     */

    for (i = keyc->xkbInfo->desc->min_key_code;
         i < keyc->xkbInfo->desc->max_key_code; i++) {
        if (key_is_down(pDev, i, KEY_POSTED)) {
            OsBlockSIGIO();
            QueueKeyboardEvents(pDev, KeyRelease, i);
            OsReleaseSIGIO();
        }
    }
}

void
xf86DisableInputDeviceForVTSwitch(InputInfoPtr pInfo)
{
    if (!pInfo->dev)
        return;

    if (!pInfo->dev->enabled)
        pInfo->flags |= XI86_DEVICE_DISABLED;

    xf86ReleaseKeys(pInfo->dev);
    ProcessInputEvents();
    DisableDevice(pInfo->dev, TRUE);
}

void
xf86EnableInputDeviceForVTSwitch(InputInfoPtr pInfo)
{
    if (pInfo->dev && (pInfo->flags & XI86_DEVICE_DISABLED) == 0)
        EnableDevice(pInfo->dev, TRUE);
    pInfo->flags &= ~XI86_DEVICE_DISABLED;
}

/*
 * xf86UpdateHasVTProperty --
 *    Update a flag property on the root window to say whether the server VT
 *    is currently the active one as some clients need to know this.
 */
static void
xf86UpdateHasVTProperty(Bool hasVT)
{
    Atom property_name;
    int32_t value = hasVT ? 1 : 0;
    int i;

    property_name = MakeAtom(HAS_VT_ATOM_NAME, sizeof(HAS_VT_ATOM_NAME) - 1,
                             FALSE);
    if (property_name == BAD_RESOURCE)
        FatalError("Failed to retrieve \"HAS_VT\" atom\n");
    for (i = 0; i < xf86NumScreens; i++) {
        ChangeWindowProperty(xf86ScrnToScreen(xf86Screens[i])->root,
                             property_name, XA_INTEGER, 32,
                             PropModeReplace, 1, &value, TRUE);
    }
}

void
xf86VTLeave(void)
{
    int i;
    InputInfoPtr pInfo;
    IHPtr ih;

    DebugF("xf86VTSwitch: Leaving, xf86Exiting is %s\n",
           BOOLTOSTRING((dispatchException & DE_TERMINATE) ? TRUE : FALSE));
#ifdef DPMSExtension
    if (DPMSPowerLevel != DPMSModeOn)
        DPMSSet(serverClient, DPMSModeOn);
#endif
    for (i = 0; i < xf86NumScreens; i++) {
        if (!(dispatchException & DE_TERMINATE))
            if (xf86Screens[i]->EnableDisableFBAccess)
                (*xf86Screens[i]->EnableDisableFBAccess) (xf86Screens[i], FALSE);
    }

    /*
     * Keep the order: Disable Device > LeaveVT
     *                        EnterVT > EnableDevice
     */
    for (ih = InputHandlers; ih; ih = ih->next) {
        if (ih->is_input)
            xf86DisableInputHandler(ih);
        else
            xf86DisableGeneralHandler(ih);
    }
    for (pInfo = xf86InputDevs; pInfo; pInfo = pInfo->next)
        xf86DisableInputDeviceForVTSwitch(pInfo);

    OsBlockSIGIO();
    for (i = 0; i < xf86NumScreens; i++)
        xf86Screens[i]->LeaveVT(xf86Screens[i]);
    for (i = 0; i < xf86NumGPUScreens; i++)
        xf86GPUScreens[i]->LeaveVT(xf86GPUScreens[i]);

    xf86AccessLeave();      /* We need this here, otherwise */

    if (!xf86VTSwitchAway())
        goto switch_failed;

#ifdef XF86PM
    if (xf86OSPMClose)
        xf86OSPMClose();
    xf86OSPMClose = NULL;
#endif

    for (i = 0; i < xf86NumScreens; i++) {
        /*
         * zero all access functions to
         * trap calls when switched away.
         */
        xf86Screens[i]->vtSema = FALSE;
    }
    if (xorgHWAccess)
        xf86DisableIO();

    xf86UpdateHasVTProperty(FALSE);

    return;

switch_failed:
    DebugF("xf86VTSwitch: Leave failed\n");
    xf86AccessEnter();
    for (i = 0; i < xf86NumScreens; i++) {
        if (!xf86Screens[i]->EnterVT(xf86Screens[i]))
            FatalError("EnterVT failed for screen %d\n", i);
    }
    for (i = 0; i < xf86NumGPUScreens; i++) {
        if (!xf86GPUScreens[i]->EnterVT(xf86GPUScreens[i]))
            FatalError("EnterVT failed for gpu screen %d\n", i);
    }
    if (!(dispatchException & DE_TERMINATE)) {
        for (i = 0; i < xf86NumScreens; i++) {
            if (xf86Screens[i]->EnableDisableFBAccess)
                (*xf86Screens[i]->EnableDisableFBAccess) (xf86Screens[i], TRUE);
        }
    }
    dixSaveScreens(serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);

    for (pInfo = xf86InputDevs; pInfo; pInfo = pInfo->next)
        xf86EnableInputDeviceForVTSwitch(pInfo);
    for (ih = InputHandlers; ih; ih = ih->next) {
        if (ih->is_input)
            xf86EnableInputHandler(ih);
        else
            xf86EnableGeneralHandler(ih);
    }
    OsReleaseSIGIO();
}

void
xf86VTEnter(void)
{
    int i;
    InputInfoPtr pInfo;
    IHPtr ih;

    DebugF("xf86VTSwitch: Entering\n");
    if (!xf86VTSwitchTo())
        return;

#ifdef XF86PM
    xf86OSPMClose = xf86OSPMOpen();
#endif

    if (xorgHWAccess)
        xf86EnableIO();
    xf86AccessEnter();
    for (i = 0; i < xf86NumScreens; i++) {
        xf86Screens[i]->vtSema = TRUE;
        if (!xf86Screens[i]->EnterVT(xf86Screens[i]))
            FatalError("EnterVT failed for screen %d\n", i);
    }
    for (i = 0; i < xf86NumGPUScreens; i++) {
        xf86GPUScreens[i]->vtSema = TRUE;
        if (!xf86GPUScreens[i]->EnterVT(xf86GPUScreens[i]))
            FatalError("EnterVT failed for gpu screen %d\n", i);
    }
    for (i = 0; i < xf86NumScreens; i++) {
        if (xf86Screens[i]->EnableDisableFBAccess)
            (*xf86Screens[i]->EnableDisableFBAccess) (xf86Screens[i], TRUE);
    }

    /* Turn screen saver off when switching back */
    dixSaveScreens(serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);

    for (pInfo = xf86InputDevs; pInfo; pInfo = pInfo->next) {
        /* Devices with server managed fds get enabled on logind resume */
        if (!(pInfo->flags & XI86_SERVER_FD))
            xf86EnableInputDeviceForVTSwitch(pInfo);
    }

    for (ih = InputHandlers; ih; ih = ih->next) {
        if (ih->is_input)
            xf86EnableInputHandler(ih);
        else
            xf86EnableGeneralHandler(ih);
    }
#ifdef XSERVER_PLATFORM_BUS
    /* check for any new output devices */
    xf86platformVTProbe();
#endif

    xf86UpdateHasVTProperty(TRUE);

    OsReleaseSIGIO();
}

/*
 * xf86VTSwitch --
 *      Handle requests for switching the vt.
 */
static void
xf86VTSwitch(void)
{
    DebugF("xf86VTSwitch()\n");

#ifdef XFreeXDGA
    if (!DGAVTSwitch())
        return;
#endif

    /*
     * Since all screens are currently all in the same state it is sufficient
     * check the first.  This might change in future.
     *
     * VTLeave is always handled here (VT_PROCESS guarantees this is safe),
     * if we use systemd_logind xf86VTEnter() gets called by systemd-logind.c
     * once it has resumed all drm nodes.
     */
    if (xf86VTOwner())
        xf86VTLeave();
    else if (!systemd_logind_controls_session())
        xf86VTEnter();
}

/* Input handler registration */

static void *
addInputHandler(int fd, InputHandlerProc proc, void *data)
{
    IHPtr ih;

    if (fd < 0 || !proc)
        return NULL;

    ih = calloc(sizeof(*ih), 1);
    if (!ih)
        return NULL;

    ih->fd = fd;
    ih->ihproc = proc;
    ih->data = data;
    ih->enabled = TRUE;

    ih->next = InputHandlers;
    InputHandlers = ih;

    return ih;
}

void *
xf86AddInputHandler(int fd, InputHandlerProc proc, void *data)
{
    IHPtr ih = addInputHandler(fd, proc, data);

    if (ih) {
        AddEnabledDevice(fd);
        ih->is_input = TRUE;
    }
    return ih;
}

void *
xf86AddGeneralHandler(int fd, InputHandlerProc proc, void *data)
{
    IHPtr ih = addInputHandler(fd, proc, data);

    if (ih)
        AddGeneralSocket(fd);
    return ih;
}

/**
 * Set the handler for the console's fd. Replaces (and returns) the previous
 * handler or NULL, whichever appropriate.
 * proc may be NULL if the server should not handle events on the console.
 */
InputHandlerProc
xf86SetConsoleHandler(InputHandlerProc proc, void *data)
{
    static IHPtr handler = NULL;
    InputHandlerProc old_proc = NULL;

    if (handler) {
        old_proc = handler->ihproc;
        xf86RemoveGeneralHandler(handler);
    }

    handler = xf86AddGeneralHandler(xf86Info.consoleFd, proc, data);

    return old_proc;
}

static void
removeInputHandler(IHPtr ih)
{
    IHPtr p;

    if (ih == InputHandlers)
        InputHandlers = ih->next;
    else {
        p = InputHandlers;
        while (p && p->next != ih)
            p = p->next;
        if (ih)
            p->next = ih->next;
    }
    free(ih);
}

int
xf86RemoveInputHandler(void *handler)
{
    IHPtr ih;
    int fd;

    if (!handler)
        return -1;

    ih = handler;
    fd = ih->fd;

    if (ih->fd >= 0)
        RemoveEnabledDevice(ih->fd);
    removeInputHandler(ih);

    return fd;
}

int
xf86RemoveGeneralHandler(void *handler)
{
    IHPtr ih;
    int fd;

    if (!handler)
        return -1;

    ih = handler;
    fd = ih->fd;

    if (ih->fd >= 0)
        RemoveGeneralSocket(ih->fd);
    removeInputHandler(ih);

    return fd;
}

void
xf86DisableInputHandler(void *handler)
{
    IHPtr ih;

    if (!handler)
        return;

    ih = handler;
    ih->enabled = FALSE;
    if (ih->fd >= 0)
        RemoveEnabledDevice(ih->fd);
}

void
xf86DisableGeneralHandler(void *handler)
{
    IHPtr ih;

    if (!handler)
        return;

    ih = handler;
    ih->enabled = FALSE;
    if (ih->fd >= 0)
        RemoveGeneralSocket(ih->fd);
}

void
xf86EnableInputHandler(void *handler)
{
    IHPtr ih;

    if (!handler)
        return;

    ih = handler;
    ih->enabled = TRUE;
    if (ih->fd >= 0)
        AddEnabledDevice(ih->fd);
}

void
xf86EnableGeneralHandler(void *handler)
{
    IHPtr ih;

    if (!handler)
        return;

    ih = handler;
    ih->enabled = TRUE;
    if (ih->fd >= 0)
        AddGeneralSocket(ih->fd);
}

/*
 * As used currently by the DRI, the return value is ignored.
 */
Bool
xf86EnableVTSwitch(Bool new)
{
    static Bool def = TRUE;
    Bool old;

    old = VTSwitchEnabled;
    if (!new) {
        /* Disable VT switching */
        def = VTSwitchEnabled;
        VTSwitchEnabled = FALSE;
    }
    else {
        /* Restore VT switching to default */
        VTSwitchEnabled = def;
    }
    return old;
}

void
DDXRingBell(int volume, int pitch, int duration)
{
    xf86OSRingBell(volume, pitch, duration);
}

Bool
xf86VTOwner(void)
{
    /* at system startup xf86Screens[0] won't be set - but we will own the VT */
    if (xf86NumScreens == 0)
	return TRUE;
    return xf86Screens[0]->vtSema;
}
@


1.17
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d183 1
a183 1
    DebugF("ProcessActionEvent(%d,%x)\n", (int) action, arg);
d406 1
a406 1
            QueueKeyboardEvents(pDev, KeyRelease, i, NULL);
@


1.16
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a60 1
#include "compiler.h"
d586 3
a588 3
    /* If we use systemd-logind it will enable input devices for us */
    if (!systemd_logind_controls_session())
        for (pInfo = xf86InputDevs; pInfo; pInfo = pInfo->next)
d590 1
@


1.15
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d59 1
d89 2
d120 1
a120 1
    pointer data;
d249 1
a249 1
xf86Wakeup(pointer blockData, int err, pointer pReadmask)
d413 22
d436 3
a438 2
 * xf86VTSwitch --
 *      Handle requests for switching the vt.
d441 19
a459 1
xf86VTSwitch(void)
d465 5
a469 5
    DebugF("xf86VTSwitch()\n");

#ifdef XFreeXDGA
    if (!DGAVTSwitch())
        return;
d471 5
d478 2
a479 2
     * Since all screens are currently all in the same state it is sufficient
     * check the first.  This might change in future.
d481 16
a496 1
    if (xf86VTOwner()) {
d498 7
a504 5
        DebugF("xf86VTSwitch: Leaving, xf86Exiting is %s\n",
               BOOLTOSTRING((dispatchException & DE_TERMINATE) ? TRUE : FALSE));
#ifdef DPMSExtension
        if (DPMSPowerLevel != DPMSModeOn)
            DPMSSet(serverClient, DPMSModeOn);
a505 5
        for (i = 0; i < xf86NumScreens; i++) {
            if (!(dispatchException & DE_TERMINATE))
                if (xf86Screens[i]->EnableDisableFBAccess)
                    (*xf86Screens[i]->EnableDisableFBAccess) (xf86Screens[i], FALSE);
        }
d507 1
d509 2
a510 2
         * Keep the order: Disable Device > LeaveVT
         *                        EnterVT > EnableDevice
d512 24
a535 14
        for (ih = InputHandlers; ih; ih = ih->next) {
            if (ih->is_input)
                xf86DisableInputHandler(ih);
            else
                xf86DisableGeneralHandler(ih);
        }
        for (pInfo = xf86InputDevs; pInfo; pInfo = pInfo->next) {
            if (pInfo->dev) {
                if (!pInfo->dev->enabled)
                    pInfo->flags |= XI86_DEVICE_DISABLED;
                xf86ReleaseKeys(pInfo->dev);
                ProcessInputEvents();
                DisableDevice(pInfo->dev, TRUE);
            }
d537 13
d551 6
a556 30
        OsBlockSIGIO();
        for (i = 0; i < xf86NumScreens; i++)
            xf86Screens[i]->LeaveVT(xf86Screens[i]);
        for (i = 0; i < xf86NumGPUScreens; i++)
            xf86GPUScreens[i]->LeaveVT(xf86GPUScreens[i]);

        xf86AccessLeave();      /* We need this here, otherwise */

        if (!xf86VTSwitchAway()) {
            /*
             * switch failed
             */

            DebugF("xf86VTSwitch: Leave failed\n");
            xf86AccessEnter();
            for (i = 0; i < xf86NumScreens; i++) {
                if (!xf86Screens[i]->EnterVT(xf86Screens[i]))
                    FatalError("EnterVT failed for screen %d\n", i);
            }
            for (i = 0; i < xf86NumGPUScreens; i++) {
                if (!xf86GPUScreens[i]->EnterVT(xf86GPUScreens[i]))
                    FatalError("EnterVT failed for gpu screen %d\n", i);
            }
            if (!(dispatchException & DE_TERMINATE)) {
                for (i = 0; i < xf86NumScreens; i++) {
                    if (xf86Screens[i]->EnableDisableFBAccess)
                        (*xf86Screens[i]->EnableDisableFBAccess) (xf86Screens[i], TRUE);
                }
            }
            dixSaveScreens(serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);
d558 3
a560 14
            pInfo = xf86InputDevs;
            while (pInfo) {
                if (pInfo->dev && (pInfo->flags & XI86_DEVICE_DISABLED) == 0)
                    EnableDevice(pInfo->dev, TRUE);
                pInfo->flags &= ~XI86_DEVICE_DISABLED;
                pInfo = pInfo->next;
            }
            for (ih = InputHandlers; ih; ih = ih->next) {
                if (ih->is_input)
                    xf86EnableInputHandler(ih);
                else
                    xf86EnableGeneralHandler(ih);
            }
            OsReleaseSIGIO();
a561 2
        }
        else {
d563 1
a563 3
            if (xf86OSPMClose)
                xf86OSPMClose();
            xf86OSPMClose = NULL;
d566 31
a596 10
            for (i = 0; i < xf86NumScreens; i++) {
                /*
                 * zero all access functions to
                 * trap calls when switched away.
                 */
                xf86Screens[i]->vtSema = FALSE;
            }
            if (xorgHWAccess)
                xf86DisableIO();
        }
d598 3
a600 7
    else {
        DebugF("xf86VTSwitch: Entering\n");
        if (!xf86VTSwitchTo())
            return;

#ifdef XF86PM
        xf86OSPMClose = xf86OSPMOpen();
d603 1
a603 17
        if (xorgHWAccess)
            xf86EnableIO();
        xf86AccessEnter();
        for (i = 0; i < xf86NumScreens; i++) {
            xf86Screens[i]->vtSema = TRUE;
            if (!xf86Screens[i]->EnterVT(xf86Screens[i]))
                FatalError("EnterVT failed for screen %d\n", i);
        }
        for (i = 0; i < xf86NumGPUScreens; i++) {
            xf86GPUScreens[i]->vtSema = TRUE;
            if (!xf86GPUScreens[i]->EnterVT(xf86GPUScreens[i]))
                FatalError("EnterVT failed for gpu screen %d\n", i);
        }
        for (i = 0; i < xf86NumScreens; i++) {
            if (xf86Screens[i]->EnableDisableFBAccess)
                (*xf86Screens[i]->EnableDisableFBAccess) (xf86Screens[i], TRUE);
        }
d605 2
a606 2
        /* Turn screen saver off when switching back */
        dixSaveScreens(serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);
d608 8
a615 7
        pInfo = xf86InputDevs;
        while (pInfo) {
            if (pInfo->dev && (pInfo->flags & XI86_DEVICE_DISABLED) == 0)
                EnableDevice(pInfo->dev, TRUE);
            pInfo->flags &= ~XI86_DEVICE_DISABLED;
            pInfo = pInfo->next;
        }
d617 3
a619 9
        for (ih = InputHandlers; ih; ih = ih->next) {
            if (ih->is_input)
                xf86EnableInputHandler(ih);
            else
                xf86EnableGeneralHandler(ih);
        }
#ifdef XSERVER_PLATFORM_BUS
        /* check for any new output devices */
        xf86platformVTProbe();
d622 12
a633 2
        OsReleaseSIGIO();
    }
d638 2
a639 2
static pointer
addInputHandler(int fd, InputHandlerProc proc, pointer data)
d661 2
a662 2
pointer
xf86AddInputHandler(int fd, InputHandlerProc proc, pointer data)
d673 2
a674 2
pointer
xf86AddGeneralHandler(int fd, InputHandlerProc proc, pointer data)
d689 1
a689 1
xf86SetConsoleHandler(InputHandlerProc proc, pointer data)
d722 1
a722 1
xf86RemoveInputHandler(pointer handler)
d741 1
a741 1
xf86RemoveGeneralHandler(pointer handler)
d760 1
a760 1
xf86DisableInputHandler(pointer handler)
d774 1
a774 1
xf86DisableGeneralHandler(pointer handler)
d788 1
a788 1
xf86EnableInputHandler(pointer handler)
d802 1
a802 1
xf86EnableGeneralHandler(pointer handler)
@


1.14
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d119 1
a417 1
    static int prevSIGIO;
d450 6
a455 2
        for (ih = InputHandlers; ih; ih = ih->next)
            xf86DisableInputHandler(ih);
d504 6
a509 3
            for (ih = InputHandlers; ih; ih = ih->next)
                xf86EnableInputHandler(ih);

d569 6
a574 3
        for (ih = InputHandlers; ih; ih = ih->next)
            xf86EnableInputHandler(ih);

d614 1
a614 1
    if (ih)
d616 2
@


1.13
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d87 1
d432 1
a432 1
    if (xf86Screens[0]->vtSema) {
d565 5
d777 9
@


1.12
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d183 1
d258 1
a258 1
                    int sigstate = xf86BlockSIGIO();
d267 1
a267 1
                    xf86UnblockSIGIO(sigstate);
d275 1
a275 1
        IHPtr ih;               /* returned with an error condition, do we?      */
d277 1
a277 1
        for (ih = InputHandlers; ih; ih = ih->next) {
d380 1
a380 1
    int i, sigstate;
d401 1
a401 1
            sigstate = xf86BlockSIGIO();
d403 1
a403 1
            xf86UnblockSIGIO(sigstate);
d442 1
a442 1
                    (*xf86Screens[i]->EnableDisableFBAccess) (i, FALSE);
d453 2
d461 1
a461 1
        prevSIGIO = xf86BlockSIGIO();
d463 3
a465 1
            xf86Screens[i]->LeaveVT(i, 0);
d477 1
a477 1
                if (!xf86Screens[i]->EnterVT(i, 0))
d480 4
d487 1
a487 1
                        (*xf86Screens[i]->EnableDisableFBAccess) (i, TRUE);
d494 1
a494 1
                if (pInfo->dev)
d496 1
d502 1
a502 1
            xf86UnblockSIGIO(prevSIGIO);
d537 1
a537 1
            if (!xf86Screens[i]->EnterVT(i, 0))
d540 5
d547 1
a547 1
                (*xf86Screens[i]->EnableDisableFBAccess) (i, TRUE);
d555 1
a555 1
            if (pInfo->dev)
d557 1
d564 1
a564 1
        xf86UnblockSIGIO(prevSIGIO);
d622 1
a622 1
    IHPtr old_handler = handler;
d624 4
a627 2
    if (old_handler)
        xf86RemoveGeneralHandler(old_handler);
d631 1
a631 1
    return (old_handler) ? old_handler->ihproc : NULL;
@


1.11
log
@Update to xserver 1.11.2
@
text
@d96 4
a99 4
Bool VTSwitchEnabled = TRUE;		/* Allows run-time disabling for
                                         *BSD and for avoiding VT
                                         switches when using the DRI
                                         automatic full screen mode.*/
d104 1
a104 1
extern void (*xf86OSPMClose)(void);
d114 5
a118 5
    int			fd;
    InputHandlerProc	ihproc;
    pointer		data;
    Bool		enabled;
    struct x_IHRec *	next;
a122 1

d137 4
a140 4
  if (xf86Info.lastEventTime == 0) {
    xf86Info.lastEventTime = GetTimeInMillis();
  }
  return GetTimeInMillis() - xf86Info.lastEventTime;
d150 1
a150 1
  xf86Info.lastEventTime = GetTimeInMillis();
d160 1
a160 1
ProcessInputEvents (void)
d162 3
a164 1
  int x, y;
d166 2
a167 1
  mieqProcessInputEvents();
d169 1
a169 3
  /* FIXME: This is a problem if we have multiple pointers */
  miPointerGetPosition(inputInfo.pointer, &x, &y);
  xf86SetViewport(xf86Info.currentScreen, x, y);
d182 1
a182 1
	if (!xf86Info.dontZap) {
d184 1
a184 1
	    DGAShutdown();
d186 3
a188 3
	    GiveUp(0);
	}
	break;
d190 3
a192 3
	if (!xf86Info.dontZoom)
	    xf86ZoomViewport(xf86Info.currentScreen,  1);
	break;
d194 3
a196 3
	if (!xf86Info.dontZoom)
	    xf86ZoomViewport(xf86Info.currentScreen, -1);
	break;
d198 2
a199 2
	if (VTSwitchEnabled && !xf86Info.dontVTSwitch && arg) {
	    int vtno = *((int *) arg);
d201 8
a208 8
	    if (vtno != xf86Info.vtno) {
		if (!xf86VTActivate(vtno)) {
		    ErrorF("Failed to switch from vt%02d to vt%02d: %s\n",
			   xf86Info.vtno, vtno, strerror(errno));
		}
	    }
	}
	break;
d210 12
a221 12
	if (VTSwitchEnabled && !xf86Info.dontVTSwitch) {
	    if (!xf86VTActivate(xf86Info.vtno + 1)) {
		/* If first try failed, assume this is the last VT and
		 * try wrapping around to the first vt.
		 */
		if (!xf86VTActivate(1)) {
		    ErrorF("Failed to switch from vt%02d to next vt: %s\n",
			   xf86Info.vtno, strerror(errno));
		}
	    }
	}
	break;
d223 8
a230 8
	if (VTSwitchEnabled && !xf86Info.dontVTSwitch && xf86Info.vtno > 0) {
	    if (!xf86VTActivate(xf86Info.vtno - 1)) {
		/* Don't know what the maximum VT is, so can't wrap around */
		ErrorF("Failed to switch from vt%02d to previous vt: %s\n",
		       xf86Info.vtno, strerror(errno));
	    }
	}
	break;
d232 1
a232 1
	break;
d245 1
a245 1
    fd_set* LastSelectMask = (fd_set*)pReadmask;
d251 20
a270 31
	XFD_ANDSET(&devicesWithInput, LastSelectMask, &EnabledDevices);
	if (XFD_ANYSET(&devicesWithInput)) {
	    pInfo = xf86InputDevs;
	    while (pInfo) {
		if (pInfo->read_input && pInfo->fd >= 0 &&
		    (FD_ISSET(pInfo->fd, &devicesWithInput) != 0)) {
		    int sigstate = xf86BlockSIGIO();

		    /*
		     * Remove the descriptior from the set because more than one
		     * device may share the same file descriptor.
		     */
		    FD_CLR(pInfo->fd, &devicesWithInput);

		    pInfo->read_input(pInfo);
		    xf86UnblockSIGIO(sigstate);
		}
		pInfo = pInfo->next;
	    }
	}
    }

    if (err >= 0) { /* we don't want the handlers called if select() */
	IHPtr ih;   /* returned with an error condition, do we?      */
	
	for (ih = InputHandlers; ih; ih = ih->next) {
	    if (ih->enabled && ih->fd >= 0 && ih->ihproc &&
		(FD_ISSET(ih->fd, ((fd_set *)pReadmask)) != 0)) {
		ih->ihproc(ih->fd, ih->data);
	    }
	}
d273 13
a285 1
    if (xf86VTSwitchPending()) xf86VTSwitch();
a287 1

d310 2
a311 2
    if (!xf86InstallSIGIOHandler (pInfo->fd, xf86SigioReadInput, pInfo)) {
	AddEnabledDevice(pInfo->fd);
d322 2
a323 2
    if (!xf86RemoveSIGIOHandler (pInfo->fd)) {
	RemoveEnabledDevice(pInfo->fd);
d333 1
a333 1
	*signo = -1;
d336 1
a336 1
static void (*xf86SigIllHandler)(void) = NULL;
d339 1
a339 1
xf86InterceptSigIll(void (*sigillhandler)(void))
d351 9
a359 9
  if ((signo == SIGILL) && xf86SigIllHandler) {
    (*xf86SigIllHandler)();
    return 0; /* continue */
  }

  if (xf86SignalIntercept && (*xf86SignalIntercept < 0)) {
    *xf86SignalIntercept = signo;
    return 0; /* continue */
  }
d361 2
a362 2
  xf86Info.caughtSignal = TRUE;
  return 1; /* abort */
d398 1
a398 2
         i < keyc->xkbInfo->desc->max_key_code;
         i++) {
d400 1
a400 1
            sigstate = xf86BlockSIGIO ();
d414 4
a417 4
  int i;
  static int prevSIGIO;
  InputInfoPtr pInfo;
  IHPtr ih;
d419 1
a419 1
  DebugF("xf86VTSwitch()\n");
d422 2
a423 2
  if(!DGAVTSwitch())
	return;
d426 5
a430 5
  /*
   * Since all screens are currently all in the same state it is sufficient
   * check the first.  This might change in future.
   */
  if (xf86Screens[0]->vtSema) {
d432 2
a433 2
    DebugF("xf86VTSwitch: Leaving, xf86Exiting is %s\n",
	   BOOLTOSTRING((dispatchException & DE_TERMINATE) ? TRUE : FALSE));
d435 2
a436 2
    if (DPMSPowerLevel != DPMSModeOn)
	DPMSSet(serverClient, DPMSModeOn);
d438 19
a456 5
    for (i = 0; i < xf86NumScreens; i++) {
      if (!(dispatchException & DE_TERMINATE))
	if (xf86Screens[i]->EnableDisableFBAccess)
	  (*xf86Screens[i]->EnableDisableFBAccess) (i, FALSE);
    }
d458 33
a490 47
    /*
     * Keep the order: Disable Device > LeaveVT
     *                        EnterVT > EnableDevice
     */
    for (ih = InputHandlers; ih; ih = ih->next)
      xf86DisableInputHandler(ih);
    for (pInfo = xf86InputDevs; pInfo; pInfo = pInfo->next) {
      if (pInfo->dev) {
          xf86ReleaseKeys(pInfo->dev);
          ProcessInputEvents();
          DisableDevice(pInfo->dev, TRUE);
      }
    }

    prevSIGIO = xf86BlockSIGIO();
    for (i = 0; i < xf86NumScreens; i++)
	xf86Screens[i]->LeaveVT(i, 0);

    xf86AccessLeave();      /* We need this here, otherwise */

    if (!xf86VTSwitchAway()) {
      /*
       * switch failed
       */

      DebugF("xf86VTSwitch: Leave failed\n");
      xf86AccessEnter();
      for (i = 0; i < xf86NumScreens; i++) {
	if (!xf86Screens[i]->EnterVT(i, 0))
	  FatalError("EnterVT failed for screen %d\n", i);
      }
      if (!(dispatchException & DE_TERMINATE)) {
	for (i = 0; i < xf86NumScreens; i++) {
	  if (xf86Screens[i]->EnableDisableFBAccess)
	    (*xf86Screens[i]->EnableDisableFBAccess) (i, TRUE);
	}
      }
      dixSaveScreens(serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);

      pInfo = xf86InputDevs;
      while (pInfo) {
        if (pInfo->dev)
            EnableDevice(pInfo->dev, TRUE);
	pInfo = pInfo->next;
      }
      for (ih = InputHandlers; ih; ih = ih->next)
        xf86EnableInputHandler(ih);
d492 1
a492 1
      xf86UnblockSIGIO(prevSIGIO);
d494 2
a495 1
    } else {
d497 3
a499 3
	  if (xf86OSPMClose)
	      xf86OSPMClose();
	  xf86OSPMClose = NULL;
d502 15
a516 13
	for (i = 0; i < xf86NumScreens; i++) {
 	    /*
 	     * zero all access functions to
 	     * trap calls when switched away.
 	     */
	    xf86Screens[i]->vtSema = FALSE;
	}
	if (xorgHWAccess)
	    xf86DisableIO();
    }
  } else {
    DebugF("xf86VTSwitch: Entering\n");
    if (!xf86VTSwitchTo()) return;
d519 1
a519 1
    xf86OSPMClose = xf86OSPMOpen();
d522 22
a543 22
    if (xorgHWAccess)
	xf86EnableIO();
    xf86AccessEnter();
    for (i = 0; i < xf86NumScreens; i++) {
      xf86Screens[i]->vtSema = TRUE;
      if (!xf86Screens[i]->EnterVT(i, 0))
	  FatalError("EnterVT failed for screen %d\n", i);
    }
    for (i = 0; i < xf86NumScreens; i++) {
      if (xf86Screens[i]->EnableDisableFBAccess)
	(*xf86Screens[i]->EnableDisableFBAccess)(i, TRUE);
    }

    /* Turn screen saver off when switching back */
    dixSaveScreens(serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);

    pInfo = xf86InputDevs;
    while (pInfo) {
      if (pInfo->dev)
          EnableDevice(pInfo->dev, TRUE);
      pInfo = pInfo->next;
    }
d545 2
a546 2
    for (ih = InputHandlers; ih; ih = ih->next)
      xf86EnableInputHandler(ih);
d548 2
a549 2
    xf86UnblockSIGIO(prevSIGIO);
  }
a551 1

d560 1
a560 1
	return NULL;
d564 1
a564 1
	return NULL;
d622 1
a622 1
	InputHandlers = ih->next;
d624 5
a628 5
	p = InputHandlers;
	while (p && p->next != ih)
	    p = p->next;
	if (ih)
	    p->next = ih->next;
d640 1
a640 1
	return -1;
d646 1
a646 1
	RemoveEnabledDevice(ih->fd);
d659 1
a659 1
	return -1;
d665 1
a665 1
	RemoveGeneralSocket(ih->fd);
d677 1
a677 1
	return;
d682 1
a682 1
	RemoveEnabledDevice(ih->fd);
d691 1
a691 1
	return;
d696 1
a696 1
	RemoveGeneralSocket(ih->fd);
d705 1
a705 1
	return;
d710 1
a710 1
	AddEnabledDevice(ih->fd);
d719 1
a719 1
	return;
d724 1
a724 1
	AddGeneralSocket(ih->fd);
d738 7
a744 6
	/* Disable VT switching */
	def = VTSwitchEnabled;
	VTSwitchEnabled = FALSE;
    } else {
	/* Restore VT switching to default */
	VTSwitchEnabled = def;
d750 2
a751 1
DDXRingBell(int volume, int pitch, int duration) {
@


1.10
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d379 1
a379 1
    int i, j, nevents, sigstate;
d402 1
a402 3
            nevents = GetKeyboardEvents(xf86Events, pDev, KeyRelease, i);
            for (j = 0; j < nevents; j++)
                mieqEnqueue(pDev, (InternalEvent*)(xf86Events + j)->event);
d415 2
a416 1
  int i, prevSIGIO;
d458 2
a459 1
    xf86EnterServerState(SETUP);
a470 1
      prevSIGIO = xf86BlockSIGIO();
a471 1
      xf86EnterServerState(SETUP);
a475 1
      xf86EnterServerState(OPERATING);
a512 1

a515 1
    prevSIGIO = xf86BlockSIGIO();
a522 1
    xf86EnterServerState(SETUP);
a527 1
    xf86EnterServerState(OPERATING);
d594 19
@


1.9
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a374 2
#define KeyPressed(k) (keyc->postdown[k >> 3] & (1 << (k & 7)))

d400 1
a400 1
        if (KeyPressed(i)) {
d568 1
a568 1
    ih = xcalloc(sizeof(*ih), 1);
d617 1
a617 1
    xfree(ih);
@


1.8
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@d79 2
a80 4
#ifdef XF86BIGFONT
#define _XF86BIGFONT_SERVER_
#include <X11/extensions/xf86bigfont.h>
#endif
a82 1
#ifdef HAVE_X11_EXTENSIONS_DPMSCONST_H
a83 4
#else
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
#endif
a87 6
 * The first of many hacks to get VT switching to work under
 * Solaris 2.1 for x86. The basic problem is that Solaris is supposed
 * to be SVR4. It is for the most part, except where the video interface
 * is concerned.  These hacks work around those problems.
 * See the comments for Linux, and SCO.
 *
d96 1
a96 1
_X_EXPORT Bool VTSwitchEnabled = TRUE;	/* Allows run-time disabling for
d136 1
a136 1
TimeSinceLastInputEvent()
d148 2
a149 2
_X_EXPORT void
SetTimeSinceLastInputEvent()
d161 1
a161 1
ProcessInputEvents ()
d179 1
a179 3
#ifdef DEBUG
    ErrorF("ProcessActionEvent(%d,%x)\n", (int) action, arg);
#endif
a196 2
#if !defined(__SOL8__) && \
    (!defined(sun) || defined(__i386__)) && defined(VT_ACTIVATE)
d200 7
a206 5
#if defined(__SCO__) || defined(__UNIXWARE__)
	    vtno--;
#endif
	    if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, vtno) < 0)
		ErrorF("Failed to switch consoles (%s)\n", strerror(errno));
d211 9
a219 12
/* Shouldn't this be true for (sun) && (i386) && (SVR4) ? */
#if defined(__SCO__) || defined(__UNIXWARE__)
	    if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno) < 0)
#else
	    if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno + 1) < 0)
#endif
#if defined (__SCO__) || (defined(sun) && defined (__i386__) && defined (SVR4)) || defined(__UNIXWARE__)
		if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, 0) < 0)
#else
		if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, 1) < 0)
#endif
		    ErrorF("Failed to switch consoles (%s)\n", strerror(errno));
d224 5
a228 2
	    if (ioctl(xf86Info.consoleFd, VT_ACTIVATE, xf86Info.vtno - 1) < 0)
		ErrorF("Failed to switch consoles (%s)\n", strerror(errno));
a230 1
#endif
a258 2
		    pInfo->read_input(pInfo);
		    xf86UnblockSIGIO(sigstate);
d264 3
d293 1
a293 2
xf86SigioReadInput(int fd,
		   void *closure)
d296 1
a296 2
    int sigstate = xf86BlockSIGIO();
    InputInfoPtr pInfo = (InputInfoPtr) closure;
a299 1
    xf86UnblockSIGIO(sigstate);
d307 1
a307 1
_X_EXPORT void
d319 1
a319 1
_X_EXPORT void
d329 1
a329 1
_X_EXPORT void
d338 1
a338 1
_X_EXPORT void
d345 1
a345 1
 * xf86SigHandler --
d348 2
a349 2
void
xf86SigHandler(int signo)
d353 1
a353 3
    /* Re-arm handler just in case we unexpectedly return here */
    (void) signal(signo, xf86SigHandler);
    return;
d358 1
a358 3
    /* Re-arm handler just in case */
    (void) signal(signo, xf86SigHandler);
    return;
a360 1
  signal(signo,SIG_IGN);
d362 1
a362 7
#ifdef XF86BIGFONT
  XF86BigfontCleanup();
#endif

  xorg_backtrace();

  FatalError("Caught signal %d.  Server aborting\n", signo);
d369 1
a369 1
_X_EXPORT void
a375 1
#define ModifierDown(k) ((keyc->state & (k)) == (k))
d380 2
a381 4
    KeyClassPtr keyc = NULL;
    KeySym *map = NULL;
    xEvent ke;
    int i = 0, j = 0, nevents = 0;
a386 1
    map = keyc->curKeySyms.map;
d399 3
a401 3
    for (i = keyc->curKeySyms.minKeyCode, map = keyc->curKeySyms.map;
         i < keyc->curKeySyms.maxKeyCode;
         i++, map += keyc->curKeySyms.mapWidth) {
d403 5
a407 26
            switch (*map) {
            /* Don't release the lock keys */
            case XK_Caps_Lock:
            case XK_Shift_Lock:
            case XK_Num_Lock:
            case XK_Scroll_Lock:
            case XK_Kana_Lock:
                break;
            default:
                if (pDev == inputInfo.keyboard) {
                    ke.u.keyButtonPointer.time = GetTimeInMillis();
                    ke.u.keyButtonPointer.rootX = 0;
                    ke.u.keyButtonPointer.rootY = 0;
                    ke.u.u.type = KeyRelease;
                    ke.u.u.detail = i;
                    (*pDev->public.processInputProc) (&ke, pDev, 1);
                }
                else {
		    int sigstate = xf86BlockSIGIO ();
                    nevents = GetKeyboardEvents(xf86Events, pDev, KeyRelease, i);
                    for (j = 0; j < nevents; j++)
                        mieqEnqueue(pDev, (xf86Events + j)->event);
		    xf86UnblockSIGIO(sigstate);
                }
                break;
            }
d417 1
a417 1
xf86VTSwitch()
d423 1
a423 3
#ifdef DEBUG
  ErrorF("xf86VTSwitch()\n");
#endif
d436 1
a436 2
#ifdef DEBUG
    ErrorF("xf86VTSwitch: Leaving, xf86Exiting is %s\n",
a437 1
#endif
d452 8
a459 5
    pInfo = xf86InputDevs;
    while (pInfo) {
      if (pInfo->dev)
          DisableDevice(pInfo->dev);
      pInfo = pInfo->next;
a464 2
    for (ih = InputHandlers; ih; ih = ih->next)
      xf86DisableInputHandler(ih);
a465 1
    xf86AccessLeaveState(); /* console won't be restored    */
d472 1
a472 3
#ifdef DEBUG
      ErrorF("xf86VTSwitch: Leave failed\n");
#endif
d491 2
a492 4
        if (pInfo->dev) {
            xf86ReleaseKeys(pInfo->dev);
            EnableDevice(pInfo->dev);
        }
a494 2
      /* XXX HACK */
      xf86ReleaseKeys(inputInfo.keyboard);
a512 2
	    xf86Screens[i]->access = NULL;
	    xf86Screens[i]->busAccess = NULL;
d519 1
a519 3
#ifdef DEBUG
    ErrorF("xf86VTSwitch: Entering\n");
#endif
d547 2
a548 4
      if (pInfo->dev) {
          xf86ReleaseKeys(pInfo->dev);
          EnableDevice(pInfo->dev);
      }
a550 2
    /* XXX HACK */
    xf86ReleaseKeys(inputInfo.keyboard);
d585 1
a585 1
_X_EXPORT pointer
d595 1
a595 1
_X_EXPORT pointer
d622 1
a622 1
_X_EXPORT int
d641 1
a641 1
_X_EXPORT int
d660 1
a660 1
_X_EXPORT void
d674 1
a674 1
_X_EXPORT void
d688 1
a688 1
_X_EXPORT void
d702 1
a702 1
_X_EXPORT void
d719 1
a719 1
_X_EXPORT Bool
a737 17
xf86ReloadInputDevs(int sig)
{
  InputInfoPtr pInfo;

  signal(sig, (void(*)(int))xf86ReloadInputDevs);

  pInfo = xf86InputDevs;
  while (pInfo) {
    DisableDevice(pInfo->dev);
    EnableDevice(pInfo->dev);
    pInfo = pInfo->next;
  }

  return;
}

_X_EXPORT void
@


1.7
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d85 3
d90 1
@


1.6
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@a59 1

a60 1

d65 1
a65 2
#include "atKeynames.h"

a70 1
#ifdef XINPUT
a72 1
#else
a73 1
#endif
a83 4
#ifdef XKB
extern Bool noXkbExtension;
#endif

a89 9
#define XE_POINTER  1
#define XE_KEYBOARD 2

#define EqEnqueue(pDev, ev) { \
    int __sigstate = xf86BlockSIGIO (); \
    mieqEnqueue (pDev, ev); \
    xf86UnblockSIGIO(__sigstate); \
}

a143 1

a152 2


a156 1

a162 2


a168 1

a172 41
#ifdef INHERIT_LOCK_STATE
  static int generation = 0;
#endif

    /*
     * With INHERIT_LOCK_STATE defined, the initial state of CapsLock, NumLock
     * and ScrollLock will be set to match that of the VT the server is
     * running on.
     */
#ifdef INHERIT_LOCK_STATE
    if (generation != serverGeneration) {
      xEvent kevent;
      DevicePtr pKeyboard = xf86Info.pKeyboard;
      extern unsigned int xf86InitialCaps, xf86InitialNum, xf86InitialScroll;

      generation = serverGeneration;
      kevent.u.keyButtonPointer.time = GetTimeInMillis();
      kevent.u.keyButtonPointer.rootX = 0;
      kevent.u.keyButtonPointer.rootY = 0;
      kevent.u.u.type = KeyPress;


      if (xf86InitialCaps) {
        kevent.u.u.detail = xf86InitialCaps;
        (* pKeyboard->processInputProc)(&kevent, (DeviceIntPtr)pKeyboard, 1);
        xf86InitialCaps = 0;
      }
      if (xf86InitialNum) {
        kevent.u.u.detail = xf86InitialNum;
        (* pKeyboard->processInputProc)(&kevent, (DeviceIntPtr)pKeyboard, 1);
        xf86InitialNum = 0;
      }
      if (xf86InitialScroll) {
        kevent.u.u.detail = xf86InitialScroll;
        (* pKeyboard->processInputProc)(&kevent, (DeviceIntPtr)pKeyboard, 1);
        xf86InitialScroll = 0;
      }
    }
#endif

  xf86Info.inputPending = FALSE;
a174 1
  miPointerUpdateSprite(inputInfo.pointer);
d176 1
a180 9
void
xf86GrabServerCallback(CallbackListPtr *callbacks, pointer data, pointer args)
{
    ServerGrabInfoRec *grab = (ServerGrabInfoRec*)args;

    xf86Info.grabInfo.server.client = grab->client;
    xf86Info.grabInfo.server.grabstate = grab->grabstate;
}

d208 1
a208 36
    case ACTION_DISABLEGRAB:
	if (!xf86Info.grabInfo.disabled && xf86Info.grabInfo.allowDeactivate) {
	  if (inputInfo.pointer && inputInfo.pointer->grab != NULL &&
	      inputInfo.pointer->DeactivateGrab)
	    inputInfo.pointer->DeactivateGrab(inputInfo.pointer);
	  if (inputInfo.keyboard && inputInfo.keyboard->grab != NULL &&
	      inputInfo.keyboard->DeactivateGrab)
	    inputInfo.keyboard->DeactivateGrab(inputInfo.keyboard);
	}
	break;
    case ACTION_CLOSECLIENT:
	if (!xf86Info.grabInfo.disabled && xf86Info.grabInfo.allowClosedown) {
	  ClientPtr pointer, keyboard, server;

	  pointer = keyboard = server = NULL;
	  if (inputInfo.pointer && inputInfo.pointer->grab != NULL)
	    pointer = clients[CLIENT_ID(inputInfo.pointer->grab->resource)];
	  if (inputInfo.keyboard && inputInfo.keyboard->grab != NULL) {
	    keyboard = clients[CLIENT_ID(inputInfo.keyboard->grab->resource)];
	    if (keyboard == pointer)
	      keyboard = NULL;
	  }
	  if ((xf86Info.grabInfo.server.grabstate == SERVER_GRABBED) &&
	      (((server = xf86Info.grabInfo.server.client) == pointer) ||
	       (server == keyboard)))
	      server = NULL;

	  if (pointer)
	    CloseDownClient(pointer);
	  if (keyboard)
	    CloseDownClient(keyboard);
	  if (server)
	    CloseDownClient(server);
	}
	break;
#if !defined(__SOL8__) && !defined(sgi) && \
a215 3
#if defined(QNX4)
	    xf86Info.vtRequestsPending = vtno;
#else
a217 1
#endif
a242 24
    case ACTION_MESSAGE:
        {
            char *retstr, *message = (char *) arg;
	    ScrnInfoPtr pScr = XF86SCRNINFO(xf86Info.currentScreen);

#ifdef DEBUG
            ErrorF("ActionMessage: '%s'\n", message);
#endif
	    /* Okay the message made it to the ddx.  The common layer */
	    /* can check for relevant messages here and react to any  */
	    /* that have a global effect.  For example:               */
	    /*                                                        */
	    /* if (!strcmp(message, "foo") {                          */
	    /*      do_foo(); break                                   */
	    /* }                                                      */
	    /*                                                        */
	    /* otherwise fallback to sending a key event message to   */
	    /* the current screen's driver:                           */
	    if (*pScr->HandleMessage != NULL) {
		(void) (*pScr->HandleMessage)(pScr->scrnIndex,
			"KeyEventMessage", message, &retstr);
	    }
        }
	break;
a247 43
#define ModifierIsSet(k) ((modifiers & (k)) == (k))

_X_EXPORT Bool
xf86CommonSpecialKey(int key, Bool down, int modifiers)
{
  if ((!ModifierIsSet(ShiftMask)) &&
      (((ModifierIsSet(ControlMask | AltMask)) ||
        (ModifierIsSet(ControlMask | AltLangMask))))) {
      switch (key) {
	
      case KEY_BackSpace:
	xf86ProcessActionEvent(ACTION_TERMINATE, NULL);
	break;

      /*
       * Check grabs
       */
      case KEY_KP_Divide:
	xf86ProcessActionEvent(ACTION_DISABLEGRAB, NULL);
	break;
      case KEY_KP_Multiply:
	xf86ProcessActionEvent(ACTION_CLOSECLIENT, NULL);
	break;
	
	/*
	 * The idea here is to pass the scancode down to a list of
	 * registered routines. There should be some standard conventions
	 * for processing certain keys.
	 */
      case KEY_KP_Minus:   /* Keypad - */
	if (down) xf86ProcessActionEvent(ACTION_PREV_MODE, NULL);
	if (!xf86Info.dontZoom) return TRUE;
	break;
	
      case KEY_KP_Plus:   /* Keypad + */
	if (down) xf86ProcessActionEvent(ACTION_NEXT_MODE, NULL);
	if (!xf86Info.dontZoom) return TRUE;
	break;
      }
  }
  return FALSE;
}

a256 1
#if !defined(__QNX__)
a282 21
#else   /* __QNX__ */

    InputInfoPtr pInfo;

    pInfo = xf86InputDevs;
    while (pInfo) {
		if (pInfo->read_input && pInfo->fd >= 0) {
		    int sigstate = xf86BlockSIGIO();

		    pInfo->read_input(pInfo);
		    xf86UnblockSIGIO(sigstate);
		    /*
		     * Must break here because more than one device may share
		     * the same file descriptor.
		     */
		    break;
		}
		pInfo = pInfo->next;
    }

#endif  /* __QNX__ */
a295 2

    if (xf86Info.inputPending) ProcessInputEvents();
d390 13
d453 1
a453 1
                        mieqEnqueue(pDev, xf86Events + j);
@


1.5
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a563 173
#ifdef HAVE_BACKTRACE
#include <execinfo.h>

static __inline__ void xorg_backtrace(void)
{
    void *array[32]; /* deeper nesting than this means something's wrong */
    size_t size, i;
    char **strings;
    ErrorF("\nBacktrace:\n");
    size = backtrace(array, 32);
    strings = backtrace_symbols(array, size);
    for (i = 0; i < size; i++)
        ErrorF("%d: %s\n", i, strings[i]);
    free(strings);
}

#else /* not glibc or glibc < 2.1 */

# if defined(sun) && defined(__SVR4)
#  define HAVE_PSTACK
# endif

# if defined(HAVE_WALKCONTEXT) /* Solaris 9 & later */

# include <ucontext.h>
# include <signal.h>
# include <dlfcn.h>
# include <sys/elf.h>

#ifdef _LP64
# define ElfSym Elf64_Sym
#else
# define ElfSym Elf32_Sym
#endif

/* Called for each frame on the stack to print it's contents */
static int xorg_backtrace_frame(uintptr_t pc, int signo, void *arg)
{
    Dl_info dlinfo;
    ElfSym *dlsym;
    char header[32];
    int depth = *((int *) arg);

    if (signo) {
	char signame[SIG2STR_MAX];

	if (sig2str(signo, signame) != 0) {
	    strcpy(signame, "unknown");
	}

	ErrorF("** Signal %d (%s)\n", signo, signame);
    }

    snprintf(header, sizeof(header), "%d: 0x%lx", depth, pc);
    *((int *) arg) = depth + 1;

    /* Ask system dynamic loader for info on the address */
    if (dladdr1((void *) pc, &dlinfo, (void **) &dlsym, RTLD_DL_SYMENT)) {
	unsigned long offset = pc - (uintptr_t) dlinfo.dli_saddr;
	const char *symname;
	
	if (offset < dlsym->st_size) { /* inside a function */
	    symname = dlinfo.dli_sname;
	} else { /* found which file it was in, but not which function */
	    symname = "<section start>";
	    offset = pc - (uintptr_t)dlinfo.dli_fbase;
	}
	ErrorF("%s: %s:%s+0x%lx\n", header, dlinfo.dli_fname,
	       symname, offset);

    } else {
	/* Couldn't find symbol info from system dynamic loader, should
	 * probably poke elfloader here, but haven't written that code yet,
	 * so we just print the pc.
	 */
	ErrorF("%s\n", header);
    }

    return 0;
}
# endif /* HAVE_WALKCONTEXT */

# ifdef HAVE_PSTACK
static int xorg_backtrace_pstack(void) {
    pid_t kidpid;
    int pipefd[2];

    if (pipe(pipefd) != 0) {
	return -1;
    }

    kidpid = fork1();

    if (kidpid == -1) {
	/* ERROR */
	return -1;
    } else if (kidpid == 0) {
	/* CHILD */
	char parent[16];
	
	seteuid(0);
	close(STDIN_FILENO);
	close(STDOUT_FILENO);
	dup2(pipefd[1],STDOUT_FILENO);
	closefrom(STDERR_FILENO);

	snprintf(parent, sizeof(parent), "%d", getppid());
	execle("/usr/bin/pstack", "pstack", parent, NULL);
	exit(1);
    } else {
	/* PARENT */
	char btline[256];
	int kidstat;
	int bytesread;
	int done = 0;
	
	close(pipefd[1]);

	while (!done) {
	    bytesread = read(pipefd[0], btline, sizeof(btline) - 1);

	    if (bytesread > 0) {
		btline[bytesread] = 0;
		ErrorF("%s", btline);
	    }
	    else if ((bytesread < 0) ||
		     ((errno != EINTR) && (errno != EAGAIN)))
		done = 1;
	}
	close(pipefd[0]);
	waitpid(kidpid, &kidstat, 0);
	if (kidstat != 0)
	    return -1;
    }
    return 0;
}
# endif /* HAVE_PSTACK */


# if defined(HAVE_PSTACK) || defined(HAVE_WALKCONTEXT)

static __inline__ void xorg_backtrace(void) {

    ErrorF("\nBacktrace:\n");

#  ifdef HAVE_PSTACK
/* First try fork/exec of pstack - otherwise fall back to walkcontext
   pstack is preferred since it can print names of non-exported functions */

    if (xorg_backtrace_pstack() < 0)
#  endif	
    {
#  ifdef HAVE_WALKCONTEXT
	ucontext_t u;
	int depth = 1;
	
	if (getcontext(&u) == 0)
	    walkcontext(&u, xorg_backtrace_frame, &depth);
	else
#  endif
	    Error("Failed to get backtrace info");
    }
    ErrorF("\n");	
}

# else

/* Default fallback if we can't find any way to get a backtrace */
static __inline__ void xorg_backtrace(void) { return; }

# endif
#endif

@


1.4
log
@Merge xserver 1.4.0.90. This includes fixes for some of the regressions
introduced by xserver 1.4, such as the keyboad caps/num-lock leds updates.
Tested by many.
@
text
@d320 1
a320 1
    (!defined(sun) || defined(i386)) && defined(VT_ACTIVATE)
d343 1
a343 1
#if defined (__SCO__) || (defined(sun) && defined (i386) && defined (SVR4)) || defined(__UNIXWARE__)
d860 1
a860 1
	DPMSSet(DPMSModeOn);
d909 1
a909 1
      SaveScreens(SCREEN_SAVER_FORCER, ScreenSaverReset);
d973 1
a973 1
    SaveScreens(SCREEN_SAVER_FORCER,ScreenSaverReset);
@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@d513 1
d520 1
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@a55 4
#ifdef __UNIXOS2__
#define I_NEED_OS2_H
#endif

d103 1
a103 7
#ifdef XINPUT
#define __EqEnqueue(ev) xf86eqEnqueue(ev)
#else
#define __EqEnqueue(ev) mieqEnqueue(ev)
#endif

#define EqEnqueue(ev) { \
d105 1
a105 1
    __EqEnqueue (ev); \
a108 5
#define ENQUEUE(ev, code, direction, dev_type) \
  (ev)->u.u.detail = (code); \
  (ev)->u.u.type   = (direction); \
  EqEnqueue((ev))

d124 1
a124 4
#ifdef USE_VT_SYSREQ
Bool VTSysreqToggle = FALSE;
#endif /* !USE_VT_SYSREQ */
Bool VTSwitchEnabled = TRUE;		/* Allows run-time disabling for
a130 3
#if defined(XQUEUE)
extern void xf86XqueRequest(void);
#endif
d152 6
a240 3
#ifdef XINPUT
  xf86eqProcessInputEvents();
#else
d242 1
a242 2
#endif
  miPointerUpdate();
d244 1
a244 1
  miPointerPosition(&x, &y);
d319 1
a319 1
#if !defined(__SOL8__) && !defined(__UNIXOS2__) && !defined(sgi) && \
d368 1
a368 1
	    /* that have a global effect.  For example:               */ 
a386 675
/*
 * xf86PostKbdEvent --
 *	Translate the raw hardware KbdEvent into an XEvent, and tell DIX
 *	about it. Scancode preprocessing and so on is done ...
 *
 *  OS/2 specific xf86PostKbdEvent(key) has been moved to os-support/os2/os2_kbd.c
 *  as some things differ, and I did not want to scatter this routine with
 *  ifdefs further (hv).
 */

#ifdef __linux__
extern u_char SpecialServerMap[];
#endif

#if !defined(__UNIXOS2__)
void
xf86PostKbdEvent(unsigned key)
{
  int         scanCode = (key & 0x7f);
  int         specialkey = 0;
  Bool        down = (key & 0x80 ? FALSE : TRUE);
  KeyClassRec *keyc = ((DeviceIntPtr)xf86Info.pKeyboard)->key;
  Bool        updateLeds = FALSE;
  Bool        UsePrefix = FALSE;
  Bool        Direction = FALSE;
  xEvent      kevent;
  KeySym      *keysym;
  int         keycode;
  static int  lockkeys = 0;
#if defined(SYSCONS_SUPPORT) || defined(PCVT_SUPPORT) || defined(WSCONS_SUPPORT)
  static Bool first_time = TRUE;
#endif
#if defined(__sparc__) && defined(__linux__)
  static int  kbdSun = -1;
#endif
  /* Disable any keyboard processing while in suspend */
  if (xf86inSuspend)
      return;

#if defined(SYSCONS_SUPPORT) || defined(PCVT_SUPPORT) || defined(WSCONS_SUPPORT)
  if (first_time)
  {
    first_time = FALSE;
    VTSwitchEnabled = (xf86Info.consType == SYSCONS)
	    || (xf86Info.consType == PCVT);
  }
#endif

#if defined (__sparc__) && defined(__linux__)
  if (kbdSun == -1) {
    if ((xf86Info.xkbmodel && !strcmp(xf86Info.xkbmodel, "sun"))
	|| (xf86Info.xkbrules && !strcmp(xf86Info.xkbrules, "sun")))
      kbdSun = 1;
    else
      kbdSun = 0;
  }
  if (kbdSun)
    goto special;
#endif /* __sparc__ && __linux__ */

#ifdef __linux__
  if (xf86Info.kbdCustomKeycodes) {
    specialkey = SpecialServerMap[scanCode];
    goto customkeycodes;
  }
#endif

  /*
   * First do some special scancode remapping ...
   */
  if (xf86Info.scanPrefix == 0) {

    switch (scanCode) {
    case KEY_Prefix0:
    case KEY_Prefix1:
#if defined(PCCONS_SUPPORT) || defined(SYSCONS_SUPPORT) || defined(PCVT_SUPPORT) || defined(WSCONS_SUPPORT)
      if (xf86Info.consType == PCCONS || xf86Info.consType == SYSCONS
	  || xf86Info.consType == PCVT
#ifdef WSCONS_SUPPORT
	  || (xf86Info.consType == WSCONS && xf86Info.kbdEvents != xf86WSKbdEvents)
#endif
      ) {
#endif
        xf86Info.scanPrefix = scanCode;  /* special prefixes */
        return;
#if defined(PCCONS_SUPPORT) || defined(SYSCONS_SUPPORT) || defined(PCVT_SUPPORT) || defined(WSCONS_SUPPORT)
      }
      break;
#endif
    }
#if defined (i386) && defined (SVR4)
    /* 
     * PANIX returns DICOP standards based keycodes in using 106jp 
     * keyboard. We need to remap some keys. 
     */
    if(xf86Info.panix106 == TRUE){
      switch (scanCode) {
      case 0x56:        scanCode = KEY_BSlash2;	break;  /* Backslash */
      case 0x5A:        scanCode = KEY_NFER;	break;  /* No Kanji Transfer*/
      case 0x5B:        scanCode = KEY_XFER;	break;  /* Kanji Tranfer */
      case 0x5C:        scanCode = KEY_Yen;	break;  /* Yen curs pgup */
      case 0x6B:        scanCode = KEY_Left;	break;  /* Cur Left */
      case 0x6F:        scanCode = KEY_PgUp;	break;  /* Cur PageUp */
      case 0x72:        scanCode = KEY_AltLang;	break;  /* AltLang(right) */
      case 0x73:        scanCode = KEY_RCtrl;	break;  /* not needed */
      }
    } else
#endif /* i386 && SVR4 */
#ifndef __OpenBSD__
    {
      switch (scanCode) {
      case 0x59:        scanCode = KEY_0x59; break;
      case 0x5a:        scanCode = KEY_0x5A; break;
      case 0x5b:        scanCode = KEY_0x5B; break;
      case 0x5c:        scanCode = KEY_KP_Equal; break; /* Keypad Equal */
      case 0x5d:        scanCode = KEY_0x5D; break;
      case 0x5e:        scanCode = KEY_0x5E; break;
      case 0x5f:        scanCode = KEY_0x5F; break;
      case 0x62:        scanCode = KEY_0x62; break;
      case 0x63:        scanCode = KEY_0x63; break;
      case 0x64:        scanCode = KEY_0x64; break;
      case 0x65:        scanCode = KEY_0x65; break;
      case 0x66:        scanCode = KEY_0x66; break;
      case 0x67:        scanCode = KEY_0x67; break;
      case 0x68:        scanCode = KEY_0x68; break;
      case 0x69:        scanCode = KEY_0x69; break;
      case 0x6a:        scanCode = KEY_0x6A; break;
      case 0x6b:        scanCode = KEY_0x6B; break;
      case 0x6c:        scanCode = KEY_0x6C; break;
      case 0x6d:        scanCode = KEY_0x6D; break;
      case 0x6e:        scanCode = KEY_0x6E; break;
      case 0x6f:        scanCode = KEY_0x6F; break;
      case 0x70:        scanCode = KEY_0x70; break;
      case 0x71:        scanCode = KEY_0x71; break;
      case 0x72:        scanCode = KEY_0x72; break;
      case 0x73:        scanCode = KEY_0x73; break;
      case 0x74:        scanCode = KEY_0x74; break;
      case 0x75:        scanCode = KEY_0x75; break;
      case 0x76:        scanCode = KEY_0x76; break;
      }
    }
#endif
  }

  else if (
#ifdef CSRG_BASED
           (xf86Info.consType == PCCONS || xf86Info.consType == SYSCONS
	    || xf86Info.consType == PCVT
#ifdef WSCONS_SUPPORT
	      || (xf86Info.consType == WSCONS && xf86Info.kbdEvents !=
	      xf86WSKbdEvents)
#endif
	      ) &&
#endif
           (xf86Info.scanPrefix == KEY_Prefix0)) {
    xf86Info.scanPrefix = 0;
	  
    switch (scanCode) {
    case KEY_KP_7:        scanCode = KEY_Home;      break;  /* curs home */
    case KEY_KP_8:        scanCode = KEY_Up;        break;  /* curs up */
    case KEY_KP_9:        scanCode = KEY_PgUp;      break;  /* curs pgup */
    case KEY_KP_4:        scanCode = KEY_Left;      break;  /* curs left */
    case KEY_KP_5:        scanCode = KEY_Begin;     break;  /* curs begin */
    case KEY_KP_6:        scanCode = KEY_Right;     break;  /* curs right */
    case KEY_KP_1:        scanCode = KEY_End;       break;  /* curs end */
    case KEY_KP_2:        scanCode = KEY_Down;      break;  /* curs down */
    case KEY_KP_3:        scanCode = KEY_PgDown;    break;  /* curs pgdown */
    case KEY_KP_0:        scanCode = KEY_Insert;    break;  /* curs insert */
    case KEY_KP_Decimal:  scanCode = KEY_Delete;    break;  /* curs delete */
    case KEY_Enter:       scanCode = KEY_KP_Enter;  break;  /* keypad enter */
    case KEY_LCtrl:       scanCode = KEY_RCtrl;     break;  /* right ctrl */
    case KEY_KP_Multiply: scanCode = KEY_Print;     break;  /* print */
    case KEY_Slash:       scanCode = KEY_KP_Divide; break;  /* keyp divide */
    case KEY_Alt:         scanCode = KEY_AltLang;   break;  /* right alt */
    case KEY_ScrollLock:  scanCode = KEY_Break;     break;  /* curs break */
    case 0x5b:            scanCode = KEY_LMeta;     break;
    case 0x5c:            scanCode = KEY_RMeta;     break;
    case 0x5d:            scanCode = KEY_Menu;      break;
    case KEY_F3:          scanCode = KEY_F13;       break;
    case KEY_F4:          scanCode = KEY_F14;       break;
    case KEY_F5:          scanCode = KEY_F15;       break;
    case KEY_F6:          scanCode = KEY_F16;       break;
    case KEY_F7:          scanCode = KEY_F17;       break;
    case KEY_KP_Plus:     scanCode = KEY_KP_DEC;    break;
      /*
       * Ignore virtual shifts (E0 2A, E0 AA, E0 36, E0 B6)
       */
    case 0x2A:
    case 0x36:
	return;
    default:
      xf86MsgVerb(X_INFO, 4, "Unreported Prefix0 scancode: 0x%02x\n",
		  scanCode);
      /*
       * "Internet" keyboards are generating lots of new codes.  Let them
       * pass.  There is little consistency between them, so don't bother
       * with symbolic names at this level.
       */
      scanCode += 0x78;
    }
  }
  
  else if (xf86Info.scanPrefix == KEY_Prefix1)
    {
      xf86Info.scanPrefix = (scanCode == KEY_LCtrl) ? KEY_LCtrl : 0;
      return;
    }
  
  else if (xf86Info.scanPrefix == KEY_LCtrl)
    {
      xf86Info.scanPrefix = 0;
      if (scanCode != KEY_NumLock) return;
      scanCode = KEY_Pause;       /* pause */
    }

#ifndef __sparc64__
  /*
   * PC keyboards generate separate key codes for
   * Alt+Print and Control+Pause but in the X keyboard model
   * they need to get the same key code as the base key on the same
   * physical keyboard key.
   */
  if (scanCode == KEY_SysReqest)
    scanCode = KEY_Print;
  else if (scanCode == KEY_Break)
    scanCode = KEY_Pause;
#endif
  
  /*
   * and now get some special keysequences
   */

  specialkey = scanCode;

#ifdef __linux__
customkeycodes:
#endif
#if defined(i386) || defined(__i386__)
  if (xf86IsPc98()) {
    switch (scanCode) {
      case 0x0e: specialkey = 0x0e; break; /* KEY_BackSpace */
      case 0x40: specialkey = 0x4a; break; /* KEY_KP_Minus  */
      case 0x49: specialkey = 0x4e; break; /* KEY_KP_Plus   */

      /* XXX needs cases for KEY_KP_Divide and KEY_KP_Multiply */

      case 0x62: specialkey = 0x3b; break; /* KEY_F1        */
      case 0x63: specialkey = 0x3c; break; /* KEY_F2        */
      case 0x64: specialkey = 0x3d; break; /* KEY_F3        */
      case 0x65: specialkey = 0x3e; break; /* KEY_F4        */
      case 0x66: specialkey = 0x3f; break; /* KEY_F5        */
      case 0x67: specialkey = 0x40; break; /* KEY_F6        */
      case 0x68: specialkey = 0x41; break; /* KEY_F7        */
      case 0x69: specialkey = 0x42; break; /* KEY_F8        */
      case 0x6a: specialkey = 0x43; break; /* KEY_F9        */
      case 0x6b: specialkey = 0x44; break; /* KEY_F10       */
      /* case 0x73: specialkey = 0x38; break; KEY_Alt       */
      /* case 0x74: specialkey = 0x1d; break; KEY_LCtrl     */
      default:   specialkey = 0x00; break;
    }
  }
#endif
#if defined (__sparc__) && defined(__linux__)
special:
  if (kbdSun) {
    switch (scanCode) {
      case 0x2b: specialkey = KEY_BackSpace; break;
      case 0x47: specialkey = KEY_KP_Minus; break;
      case 0x7d: specialkey = KEY_KP_Plus; break;

      /* XXX needs cases for KEY_KP_Divide and KEY_KP_Multiply */

      case 0x05: specialkey = KEY_F1; break;
      case 0x06: specialkey = KEY_F2; break;
      case 0x08: specialkey = KEY_F3; break;
      case 0x0a: specialkey = KEY_F4; break;
      case 0x0c: specialkey = KEY_F5; break;
      case 0x0e: specialkey = KEY_F6; break;
      case 0x10: specialkey = KEY_F7; break;
      case 0x11: specialkey = KEY_F8; break;
      case 0x12: specialkey = KEY_F9; break;
      case 0x07: specialkey = KEY_F10; break;
      case 0x09: specialkey = KEY_F11; break;
      case 0x0b: specialkey = KEY_F12; break;
      default: specialkey = 0; break;
    }
    /*
     * XXX XXX XXX:
     *
     * I really don't know what's wrong here, but passing the real
     * scanCode offsets by one from XKB's point of view.
     *
     * (ecd@@skynet.be, 980405)
     */
    scanCode--;
  }
#endif /* defined (__sparc__) && defined(__linux__) */

#ifdef XKB
  if ((xf86Info.ddxSpecialKeys == SKWhenNeeded &&
       !xf86Info.ActionKeyBindingsSet) ||
      noXkbExtension || xf86Info.ddxSpecialKeys == SKAlways) {
#endif
  if (!(ModifierDown(ShiftMask)) &&
      ((ModifierDown(ControlMask | AltMask)) ||
       (ModifierDown(ControlMask | AltLangMask))))
    {
      switch (specialkey) {
	
      case KEY_BackSpace:
	xf86ProcessActionEvent(ACTION_TERMINATE, NULL);
	break;

      /*
       * Check grabs
       */
      case KEY_KP_Divide:
	xf86ProcessActionEvent(ACTION_DISABLEGRAB, NULL);
	break;
      case KEY_KP_Multiply:
	xf86ProcessActionEvent(ACTION_CLOSECLIENT, NULL);
	break;

      /*
       * Video mode switches
       */
      case KEY_KP_Minus:   /* Keypad - */
	if (down) xf86ProcessActionEvent(ACTION_PREV_MODE, NULL);
	if (!xf86Info.dontZoom) return;
	break;
	
      case KEY_KP_Plus:   /* Keypad + */
	if (down) xf86ProcessActionEvent(ACTION_NEXT_MODE, NULL);
	if (!xf86Info.dontZoom) return;
	break;

	/* Under QNX4, we set the vtPending flag for VT switching and 
	 * let the VT switch function do the rest...
	 * This is a little different from the other OS'es.
	 */
#if defined(QNX4)
      case KEY_1:
      case KEY_2:
      case KEY_3:
      case KEY_4:
      case KEY_5:
      case KEY_6:
      case KEY_7:
      case KEY_8:
      case KEY_9:
	if (VTSwitchEnabled && !xf86Info.dontVTSwitch) {
	  if (down) {
	    int vtno = specialkey - KEY_1 + 1;
	    xf86ProcessActionEvent(ACTION_SWITCHSCREEN, (void *) &vtno);
	  }
	  return;
	}
	break;
#endif

#if defined(linux) || (defined(CSRG_BASED) && (defined(SYSCONS_SUPPORT) || defined(PCVT_SUPPORT) || defined(WSCONS_SUPPORT))) || defined(__SCO__) || defined(__UNIXWARE__)
	/*
	 * Under Linux, the raw keycodes are consumed before the kernel
	 * does any processing on them, so we must emulate the vt switching
	 * we want ourselves.
	 */
      case KEY_F1:
      case KEY_F2:
      case KEY_F3:
      case KEY_F4:
      case KEY_F5:
      case KEY_F6:
      case KEY_F7:
      case KEY_F8:
      case KEY_F9:
      case KEY_F10:
      case KEY_F11:
      case KEY_F12:
	if ((VTSwitchEnabled && !xf86Info.vtSysreq && !xf86Info.dontVTSwitch)
#if (defined(CSRG_BASED) && (defined(SYSCONS_SUPPORT) || defined(PCVT_SUPPORT) || defined(WSCONS_SUPPORT)))
	    && (xf86Info.consType == SYSCONS || xf86Info.consType == PCVT)
#endif
	   ) {
	    int vtno = specialkey - KEY_F1 + 1;
	    if (specialkey == KEY_F11 || specialkey == KEY_F12)
		vtno = specialkey - KEY_F11 + 11;
	    if (down)
		xf86ProcessActionEvent(ACTION_SWITCHSCREEN, (void *) &vtno);
	    return;
	}
	break;
#endif /* linux || BSD with VTs */

      /* just worth mentioning here: any 386bsd keyboard driver
       * (pccons.c or co_kbd.c) catches CTRL-ALT-DEL and CTRL-ALT-ESC
       * before any application (e.g. XF86) will see it
       * OBS: syscons does not, nor does pcvt !
       */
      } 
    }

    /*
     * Start of actual Solaris VT switching code.  
     * This should pretty much emulate standard SVR4 switching keys.
     * 
     * DWH 12/2/93
     */

#ifdef USE_VT_SYSREQ
    if (VTSwitchEnabled && xf86Info.vtSysreq && !xf86Info.dontVTSwitch)
    {
      switch (specialkey)
      {
      /*
       * syscons on *BSD doesn't have a VT #0  -- don't think Linux does
       * either
       */
#if defined (sun) && defined (i386) && defined (SVR4)
      case KEY_H: 
	if (VTSysreqToggle && down)
        {
	  xf86ProcessActionEvent(ACTION_SWITCHSCREEN, NULL);
          VTSysreqToggle = 0;
          return; 
        }
	break;

      /*
       * Yah, I know the N, and P keys seem backwards, however that's
       * how they work under Solaris
       * XXXX N means go to next active VT not necessarily vtno+1 (or vtno-1)
       */

      case KEY_N:
	if (VTSysreqToggle && down)
	{
	  xf86ProcessActionEvent(ACTION_SWITCHSCREEN_NEXT, NULL);
          VTSysreqToggle = FALSE;
          return;
        }
	break;

      case KEY_P:
	if (VTSysreqToggle && down)
	{
	  xf86ProcessActionEvent(ACTION_SWITCHSCREEN_NEXT, NULL);
          VTSysreqToggle = FALSE;
          return;
        }
	break;
#endif

      case KEY_F1:
      case KEY_F2:
      case KEY_F3:
      case KEY_F4:
      case KEY_F5:
      case KEY_F6:
      case KEY_F7:
      case KEY_F8:
      case KEY_F9:
      case KEY_F10:
      case KEY_F11:
      case KEY_F12:
	if (VTSysreqToggle && down)
	{ int vtno = specialkey - KEY_F1 + 1;
	  if (specialkey == KEY_F11 || specialkey == KEY_F12)
	    vtno = specialkey - KEY_F11 + 11;
	  xf86ProcessActionEvent(ACTION_SWITCHSCREEN, (void *) &vtno);
          VTSysreqToggle = FALSE;
          return;
        }
	break;

      /* Ignore these keys -- ie don't let them cancel an alt-sysreq */
      case KEY_Alt:
      case KEY_AltLang:
	break;

      case KEY_SysReqest:
        if (down && (ModifierDown(AltMask) || ModifierDown(AltLangMask)))
          VTSysreqToggle = TRUE;
	break;

      default:
        if (VTSysreqToggle)
	{
	  /*
	   * We only land here when Alt-SysReq is followed by a
	   * non-switching key.
	   */
          VTSysreqToggle = FALSE;

        }
      }
    }

#endif /* USE_VT_SYSREQ */

#ifdef __SCO__
    /*
     *	With the console in raw mode, SCO will not switch consoles,
     *	you get around this by activating the next console along, if
     *	this fails then go back to console 0, if there is only one
     *	then it doesn't matter, switching to yourself is a nop as far
     *	as the console driver is concerned.
     *	We could do something similar to linux here but SCO ODT uses
     *	Ctrl-PrintScrn, so why change?
     */
    if (specialkey == KEY_Print && ModifierDown(ControlMask)) {
      if (down)
	xf86ProcessActionEvent(ACTION_SWITCHSCREEN_NEXT, NULL);
      return;
    }
#endif /* __SCO__ */
#ifdef XKB
    }
#endif

  /*
   * Now map the scancodes to real X-keycodes ...
   */
  keycode = scanCode + MIN_KEYCODE;
  keysym = (keyc->curKeySyms.map +
	    keyc->curKeySyms.mapWidth * 
	    (keycode - keyc->curKeySyms.minKeyCode));
#ifdef XKB
  if (noXkbExtension) {
#endif
  /*
   * Filter autorepeated caps/num/scroll lock keycodes.
   */
#define CAPSFLAG 0x01
#define NUMFLAG 0x02
#define SCROLLFLAG 0x04
#define MODEFLAG 0x08
  if( down ) {
    switch( keysym[0] ) {
        case XK_Caps_Lock :
          if (lockkeys & CAPSFLAG)
              return;
	  else
	      lockkeys |= CAPSFLAG;
          break;

        case XK_Num_Lock :
          if (lockkeys & NUMFLAG)
              return;
	  else
	      lockkeys |= NUMFLAG;
          break;

        case XK_Scroll_Lock :
          if (lockkeys & SCROLLFLAG)
              return;
	  else
	      lockkeys |= SCROLLFLAG;
          break;
    }
    if (keysym[1] == XF86XK_ModeLock)
    {
      if (lockkeys & MODEFLAG)
          return;
      else
          lockkeys |= MODEFLAG;
    }
      
  }
  else {
    switch( keysym[0] ) {
        case XK_Caps_Lock :
            lockkeys &= ~CAPSFLAG;
            break;

        case XK_Num_Lock :
            lockkeys &= ~NUMFLAG;
            break;

        case XK_Scroll_Lock :
            lockkeys &= ~SCROLLFLAG;
            break;
    }
    if (keysym[1] == XF86XK_ModeLock)
      lockkeys &= ~MODEFLAG;
  }

  /*
   * LockKey special handling:
   * ignore releases, toggle on & off on presses.
   * Don't deal with the Caps_Lock keysym directly, but check the lock modifier
   */
  if (keyc->modifierMap[keycode] & LockMask ||
      keysym[0] == XK_Scroll_Lock ||
      keysym[1] == XF86XK_ModeLock ||
      keysym[0] == XK_Num_Lock)
    {
      Bool flag;

      if (!down) return;
      if (KeyPressed(keycode)) {
	down = !down;
	flag = FALSE;
      }
      else
	flag = TRUE;

      if (keyc->modifierMap[keycode] & LockMask)   xf86Info.capsLock   = flag;
      if (keysym[0] == XK_Num_Lock)    xf86Info.numLock    = flag;
      if (keysym[0] == XK_Scroll_Lock) xf86Info.scrollLock = flag;
      if (keysym[1] == XF86XK_ModeLock)   xf86Info.modeSwitchLock = flag;
      updateLeds = TRUE;
    }

  if (!xf86Info.kbdCustomKeycodes) {
    /*
     * normal, non-keypad keys
     */
    if (scanCode < KEY_KP_7 || scanCode > KEY_KP_Decimal) {
#if !defined(CSRG_BASED) && \
    !defined(__GNU__) && \
     defined(KB_84)
      /*
       * magic ALT_L key on AT84 keyboards for multilingual support
       */
      if (xf86Info.kbdType == KB_84 &&
	  ModifierDown(AltMask) &&
	  keysym[2] != NoSymbol)
	{
	  UsePrefix = TRUE;
	  Direction = TRUE;
	}
#endif /* !CSRG_BASED && ... */
    }
  }
  if (updateLeds) xf86UpdateKbdLeds();
#ifdef XKB
  }
#endif

  /*
   * check for an autorepeat-event
   */
  if (down && KeyPressed(keycode)) {
      KbdFeedbackClassRec *kbdfeed = ((DeviceIntPtr)xf86Info.pKeyboard)->kbdfeed;
      if ((xf86Info.autoRepeat != AutoRepeatModeOn) ||
          keyc->modifierMap[keycode] ||
          (kbdfeed && !(kbdfeed->ctrl.autoRepeats[keycode>>3] & ( 1<<(keycode&7) ))))
          return;
  }


  xf86Info.lastEventTime = kevent.u.keyButtonPointer.time = GetTimeInMillis();
  /*
   * And now send these prefixes ...
   * NOTE: There cannot be multiple Mode_Switch keys !!!!
   */
  if (UsePrefix)
    {
      ENQUEUE(&kevent,
	      keyc->modifierKeyMap[keyc->maxKeysPerModifier*7],
	      (Direction ? KeyPress : KeyRelease),
	      XE_KEYBOARD);
      ENQUEUE(&kevent, keycode, (down ? KeyPress : KeyRelease), XE_KEYBOARD);
      ENQUEUE(&kevent,
	      keyc->modifierKeyMap[keyc->maxKeysPerModifier*7],
	      (Direction ? KeyRelease : KeyPress),
	      XE_KEYBOARD);
    }
  else 
    {
      ENQUEUE(&kevent, keycode, (down ? KeyPress : KeyRelease), XE_KEYBOARD);
    }
}
#endif /* !__UNIXOS2__ */

d439 1
a439 1
#if !defined(__UNIXOS2__) && !defined(__QNX__)
a447 2
	    if (xf86Info.kbdEvents)
	    	(xf86Info.kbdEvents)();
d453 1
a453 1
		    
d455 1
a455 1
		    xf86UnblockSIGIO(sigstate);		    
d466 1
a466 1
#else   /* __UNIXOS2__ and __QNX__ */
a469 2
    (xf86Info.kbdEvents)();  /* Under OS/2 and QNX, always call */

d474 1
a474 1
		    
d476 1
a476 1
		    xf86UnblockSIGIO(sigstate);		    
d486 1
a486 1
#endif  /* __UNIXOS2__ and __QNX__ */
d498 1
a498 1
    
d523 1
a523 1
 *    
d535 1
a535 1
 *    
d556 1
a556 1
_X_EXPORT void 
d604 1
a604 1
    
d617 1
a617 1
    
d639 1
a639 1
    
d682 1
a682 1
	    
d706 2
a707 2
    
#  ifdef HAVE_PSTACK    
d710 1
a710 1
    
d748 1
a748 1
  
d763 1
a763 1
    
d767 2
a768 3
#ifdef MEMDEBUG
void
xf86SigMemDebug(int signo)
d770 54
a823 3
    CheckMemory();
    (void) signal(signo, xf86SigMemDebug);
    return;
a824 1
#endif
d840 1
a840 1
  
a864 1
#if !defined(__UNIXOS2__)
d866 1
a866 1
    /* 
d868 1
a868 1
     *                        EnterVT > EnableDevice 
a869 1
    DisableDevice((DeviceIntPtr)xf86Info.pKeyboard);
d872 2
a873 1
      DisableDevice(pInfo->dev);
a875 1
#endif /* !__UNIXOS2__ */
d887 1
a887 1
       * switch failed 
a908 2
#if !defined(__UNIXOS2__)
      EnableDevice((DeviceIntPtr)xf86Info.pKeyboard);
d911 4
a914 1
	EnableDevice(pInfo->dev);
d917 2
a918 1
#endif /* !__UNIXOS2__ */
a972 2
#if !defined(__UNIXOS2__)
    EnableDevice((DeviceIntPtr)xf86Info.pKeyboard);
d975 4
a978 1
      EnableDevice(pInfo->dev);
d981 3
a983 2
#endif /* !__UNIXOS2__ */
    
d1019 1
a1019 1
{   
d1029 1
a1029 1
{   
d1059 1
a1059 1
    
d1065 1
a1065 1
    
d1078 1
a1078 1
    
d1084 1
a1084 1
    
d1173 1
a1173 1
  
a1175 3
  DisableDevice((DeviceIntPtr)xf86Info.pKeyboard);
  EnableDevice((DeviceIntPtr)xf86Info.pKeyboard);

d1182 1
a1182 1
  
d1186 3
a1188 25
#ifdef WSCONS_SUPPORT

/* XXX Currently XKB is mandatory. */

extern int WSKbdToKeycode(int);

void
xf86PostWSKbdEvent(struct wscons_event *event)
{
  int type = event->type;
  int value = event->value;
  unsigned int keycode;
  int blocked;
  
  if (type == WSCONS_EVENT_KEY_UP || type == WSCONS_EVENT_KEY_DOWN) {
    Bool down = (type == WSCONS_EVENT_KEY_DOWN ? TRUE : FALSE);

    /* map the scancodes to standard XFree86 scancode */  	
    keycode = WSKbdToKeycode(value);
    if (!down) keycode |= 0x80;
    /* It seems better to block SIGIO there */
    blocked = xf86BlockSIGIO();
    xf86PostKbdEvent(keycode);
    xf86UnblockSIGIO(blocked);
  }
a1189 1
#endif /* WSCONS_SUPPORT */
@


1.1
log
@Initial revision
@
text
@d514 1
d547 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d56 4
d107 7
a113 1
#define EqEnqueue(pDev, ev) { \
d115 1
a115 1
    mieqEnqueue (pDev, ev); \
d119 5
d139 4
a142 1
_X_EXPORT Bool VTSwitchEnabled = TRUE;	/* Allows run-time disabling for
d149 3
a172 6
Bool
LegalModifier(unsigned int key, DeviceIntPtr pDev)
{
    return TRUE;
}

d256 3
d260 2
a261 1
  miPointerUpdateSprite(inputInfo.pointer);
d263 1
a263 1
  miPointerGetPosition(inputInfo.pointer, &x, &y);
d338 1
a338 1
#if !defined(__SOL8__) && !defined(sgi) && \
d387 1
a387 1
	    /* that have a global effect.  For example:               */
d406 673
d1131 1
a1131 1
#if !defined(__QNX__)
d1140 2
d1147 1
a1147 1

d1149 1
a1149 1
		    xf86UnblockSIGIO(sigstate);
d1160 1
a1160 1
#else   /* __QNX__ */
d1164 2
d1170 1
a1170 1

d1172 1
a1172 1
		    xf86UnblockSIGIO(sigstate);
d1182 1
a1182 1
#endif  /* __QNX__ */
d1194 1
a1194 1

d1219 1
a1219 1
 *
d1231 1
a1231 1
 *
d1252 1
a1252 1
_X_EXPORT void
d1300 1
a1300 1

d1313 1
a1313 1

d1335 1
a1335 1

d1378 1
a1378 1

d1402 2
a1403 2

#  ifdef HAVE_PSTACK
d1406 1
a1406 1

d1444 1
a1444 1

d1459 1
a1459 1

d1463 3
a1465 2
static void
xf86ReleaseKeys(DeviceIntPtr pDev)
d1467 3
a1469 54
    KeyClassPtr keyc = NULL;
    KeySym *map = NULL;
    xEvent ke;
    int i = 0, j = 0, nevents = 0;

    if (!pDev || !pDev->key)
        return;

    keyc = pDev->key;
    map = keyc->curKeySyms.map;

    /*
     * Hmm... here is the biggest hack of every time !
     * It may be possible that a switch-vt procedure has finished BEFORE
     * you released all keys neccessary to do this. That peculiar behavior
     * can fool the X-server pretty much, cause it assumes that some keys
     * were not released. TWM may stuck alsmost completly....
     * OK, what we are doing here is after returning from the vt-switch
     * exeplicitely unrelease all keyboard keys before the input-devices
     * are reenabled.
     */

    for (i = keyc->curKeySyms.minKeyCode, map = keyc->curKeySyms.map;
         i < keyc->curKeySyms.maxKeyCode;
         i++, map += keyc->curKeySyms.mapWidth) {
        if (KeyPressed(i)) {
            switch (*map) {
            /* Don't release the lock keys */
            case XK_Caps_Lock:
            case XK_Shift_Lock:
            case XK_Num_Lock:
            case XK_Scroll_Lock:
            case XK_Kana_Lock:
                break;
            default:
                if (pDev == inputInfo.keyboard) {
                    ke.u.keyButtonPointer.time = GetTimeInMillis();
                    ke.u.keyButtonPointer.rootX = 0;
                    ke.u.keyButtonPointer.rootY = 0;
                    ke.u.u.type = KeyRelease;
                    ke.u.u.detail = i;
                    (*pDev->public.processInputProc) (&ke, pDev, 1);
                }
                else {
		    int sigstate = xf86BlockSIGIO ();
                    nevents = GetKeyboardEvents(xf86Events, pDev, KeyRelease, i);
                    for (j = 0; j < nevents; j++)
                        mieqEnqueue(pDev, xf86Events + j);
		    xf86UnblockSIGIO(sigstate);
                }
                break;
            }
        }
    }
d1471 1
d1487 1
a1487 1

d1512 1
d1514 1
a1514 1
    /*
d1516 1
a1516 1
     *                        EnterVT > EnableDevice
d1518 1
d1521 1
a1521 2
      if (pInfo->dev)
          DisableDevice(pInfo->dev);
d1524 1
d1536 1
a1536 1
       * switch failed
d1558 2
d1562 1
a1562 4
        if (pInfo->dev) {
            xf86ReleaseKeys(pInfo->dev);
            EnableDevice(pInfo->dev);
        }
d1565 1
a1565 2
      /* XXX HACK */
      xf86ReleaseKeys(inputInfo.keyboard);
d1620 2
d1624 1
a1624 4
      if (pInfo->dev) {
          xf86ReleaseKeys(pInfo->dev);
          EnableDevice(pInfo->dev);
      }
d1627 2
a1628 3
    /* XXX HACK */
    xf86ReleaseKeys(inputInfo.keyboard);

d1664 1
a1664 1
{
d1674 1
a1674 1
{
d1704 1
a1704 1

d1710 1
a1710 1

d1723 1
a1723 1

d1729 1
a1729 1

d1818 2
d1821 2
a1822 1
  signal(sig, (void(*)(int))xf86ReloadInputDevs);
d1830 1
a1830 1

d1834 25
a1858 3
_X_EXPORT void
DDXRingBell(int volume, int pitch, int duration) {
    xf86OSRingBell(volume, pitch, duration);
d1860 1
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@a512 1
    int errno_save = errno;
a518 1
    errno = errno_save;
@


