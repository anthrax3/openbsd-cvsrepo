head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.2
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.4
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.08.09.18.59.52;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	6HLO5qdN5N4nPDjW;

1.16
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	s0SI41sEunLdyFfd;

1.15
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	Te1daavkBLskZ8gc;

1.14
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	cVXoV5PxI8YrEaVA;

1.13
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.23.12.06.43;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.08.24.21.02.23;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.03;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.04.20.20.19;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.06;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.42;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 * Copyright 2000-2002 by Alan Hourihane, Flint Mountain, North Wales.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Alan Hourihane not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Alan Hourihane makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * ALAN HOURIHANE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL ALAN HOURIHANE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Alan Hourihane, alanh@@fairlite.demon.co.uk
 *
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xf86.h"
#include "xf86Config.h"
#include "xf86_OSlib.h"
#include "xf86Priv.h"
#define IN_XSERVER
#include "Configint.h"
#include "xf86DDC.h"
#include "xf86pciBus.h"
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
#include "xf86Bus.h"
#include "xf86Sbus.h"
#endif
#include "misc.h"

typedef struct _DevToConfig {
    GDevRec GDev;
    struct pci_device *pVideo;
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
    sbusDevicePtr sVideo;
#endif
    int iDriver;
} DevToConfigRec, *DevToConfigPtr;

static DevToConfigPtr DevToConfig = NULL;
static int nDevToConfig = 0, CurrentDriver;

xf86MonPtr ConfiguredMonitor;
Bool xf86DoConfigurePass1 = TRUE;
static Bool foundMouse = FALSE;

#if   defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
static const char *DFLT_MOUSE_DEV = "/dev/sysmouse";
static const char *DFLT_MOUSE_PROTO = "auto";
#elif defined(linux)
static const char *DFLT_MOUSE_DEV = "/dev/input/mice";
static const char *DFLT_MOUSE_PROTO = "auto";
#elif defined(WSCONS_SUPPORT)
static const char *DFLT_MOUSE_DEV = "/dev/wsmouse";
static const char *DFLT_MOUSE_PROTO = "wsmouse";
#else
static const char *DFLT_MOUSE_DEV = "/dev/mouse";
static const char *DFLT_MOUSE_PROTO = "auto";
#endif

/*
 * This is called by the driver, either through xf86Match???Instances() or
 * directly.  We allocate a GDevRec and fill it in as much as we can, letting
 * the caller fill in the rest and/or change it as it sees fit.
 */
GDevPtr
xf86AddBusDeviceToConfigure(const char *driver, BusType bus, void *busData,
                            int chipset)
{
    int ret, i, j;
    char *lower_driver;

    if (!xf86DoConfigure || !xf86DoConfigurePass1)
        return NULL;

    /* Check for duplicates */
    for (i = 0; i < nDevToConfig; i++) {
        switch (bus) {
#ifdef XSERVER_LIBPCIACCESS
        case BUS_PCI:
            ret = xf86PciConfigure(busData, DevToConfig[i].pVideo);
            break;
#endif
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
        case BUS_SBUS:
            ret = xf86SbusConfigure(busData, DevToConfig[i].sVideo);
            break;
#endif
        default:
            return NULL;
        }
        if (ret == 0)
            goto out;
    }

    /* Allocate new structure occurrence */
    i = nDevToConfig++;
    DevToConfig =
        xnfreallocarray(DevToConfig, nDevToConfig, sizeof(DevToConfigRec));
    memset(DevToConfig + i, 0, sizeof(DevToConfigRec));

    DevToConfig[i].GDev.chipID =
        DevToConfig[i].GDev.chipRev = DevToConfig[i].GDev.irq = -1;

    DevToConfig[i].iDriver = CurrentDriver;

    /* Fill in what we know, converting the driver name to lower case */
    lower_driver = xnfalloc(strlen(driver) + 1);
    for (j = 0; (lower_driver[j] = tolower(driver[j])); j++);
    DevToConfig[i].GDev.driver = lower_driver;

    switch (bus) {
#ifdef XSERVER_LIBPCIACCESS
    case BUS_PCI:
	DevToConfig[i].pVideo = busData;
        xf86PciConfigureNewDev(busData, DevToConfig[i].pVideo,
                               &DevToConfig[i].GDev, &chipset);
        break;
#endif
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
    case BUS_SBUS:
	DevToConfig[i].sVideo = busData;
        xf86SbusConfigureNewDev(busData, DevToConfig[i].sVideo,
                                &DevToConfig[i].GDev);
        break;
#endif
    default:
        break;
    }

    /* Get driver's available options */
    if (xf86DriverList[CurrentDriver]->AvailableOptions)
        DevToConfig[i].GDev.options = (OptionInfoPtr)
            (*xf86DriverList[CurrentDriver]->AvailableOptions) (chipset, bus);

    return &DevToConfig[i].GDev;

 out:
    return NULL;
}

static XF86ConfInputPtr
configureInputSection(void)
{
    XF86ConfInputPtr mouse = NULL;

    parsePrologue(XF86ConfInputPtr, XF86ConfInputRec)

    ptr->inp_identifier = xnfstrdup("Keyboard0");
    ptr->inp_driver = xnfstrdup("kbd");
    ptr->list.next = NULL;

    /* Crude mechanism to auto-detect mouse (os dependent) */
    {
        int fd;

        fd = open(DFLT_MOUSE_DEV, 0);
        if (fd != -1) {
            foundMouse = TRUE;
            close(fd);
        }
    }

    mouse = calloc(1, sizeof(XF86ConfInputRec));
    mouse->inp_identifier = xnfstrdup("Mouse0");
    mouse->inp_driver = xnfstrdup("mouse");
    mouse->inp_option_lst =
        xf86addNewOption(mouse->inp_option_lst, xnfstrdup("Protocol"),
                         xnfstrdup(DFLT_MOUSE_PROTO));
    mouse->inp_option_lst =
        xf86addNewOption(mouse->inp_option_lst, xnfstrdup("Device"),
                         xnfstrdup(DFLT_MOUSE_DEV));
    mouse->inp_option_lst =
        xf86addNewOption(mouse->inp_option_lst, xnfstrdup("ZAxisMapping"),
                         xnfstrdup("4 5 6 7"));
    ptr = (XF86ConfInputPtr) xf86addListItem((glp) ptr, (glp) mouse);
    return ptr;
}

static XF86ConfScreenPtr
configureScreenSection(int screennum)
{
    int i;
    int depths[] = { 1, 4, 8, 15, 16, 24 /*, 32 */  };
    char *tmp;
    parsePrologue(XF86ConfScreenPtr, XF86ConfScreenRec)

    XNFasprintf(&tmp, "Screen%d", screennum);
    ptr->scrn_identifier = tmp;
    XNFasprintf(&tmp, "Monitor%d", screennum);
    ptr->scrn_monitor_str = tmp;
    XNFasprintf(&tmp, "Card%d", screennum);
    ptr->scrn_device_str = tmp;

    for (i = 0; i < sizeof(depths) / sizeof(depths[0]); i++) {
        XF86ConfDisplayPtr conf_display;

        conf_display = calloc(1, sizeof(XF86ConfDisplayRec));
        conf_display->disp_depth = depths[i];
        conf_display->disp_black.red = conf_display->disp_white.red = -1;
        conf_display->disp_black.green = conf_display->disp_white.green = -1;
        conf_display->disp_black.blue = conf_display->disp_white.blue = -1;
        ptr->scrn_display_lst = (XF86ConfDisplayPtr) xf86addListItem((glp) ptr->
                                                                     scrn_display_lst,
                                                                     (glp)
                                                                     conf_display);
    }

    return ptr;
}

static const char *
optionTypeToString(OptionValueType type)
{
    switch (type) {
    case OPTV_NONE:
        return "";
    case OPTV_INTEGER:
        return "<i>";
    case OPTV_STRING:
        return "<str>";
    case OPTV_ANYSTR:
        return "[<str>]";
    case OPTV_REAL:
        return "<f>";
    case OPTV_BOOLEAN:
        return "[<bool>]";
    case OPTV_FREQ:
        return "<freq>";
    case OPTV_PERCENT:
        return "<percent>";
    default:
        return "";
    }
}

static XF86ConfDevicePtr
configureDeviceSection(int screennum)
{
    OptionInfoPtr p;
    int i = 0;
    char *identifier;

    parsePrologue(XF86ConfDevicePtr, XF86ConfDeviceRec)

        /* Move device info to parser structure */
   if (asprintf(&identifier, "Card%d", screennum) == -1)
        identifier = NULL;
    ptr->dev_identifier = identifier;
    ptr->dev_chipset = DevToConfig[screennum].GDev.chipset;
    ptr->dev_busid = DevToConfig[screennum].GDev.busID;
    ptr->dev_driver = DevToConfig[screennum].GDev.driver;
    ptr->dev_ramdac = DevToConfig[screennum].GDev.ramdac;
    for (i = 0; i < MAXDACSPEEDS; i++)
        ptr->dev_dacSpeeds[i] = DevToConfig[screennum].GDev.dacSpeeds[i];
    ptr->dev_videoram = DevToConfig[screennum].GDev.videoRam;
    ptr->dev_bios_base = DevToConfig[screennum].GDev.BiosBase;
    ptr->dev_mem_base = DevToConfig[screennum].GDev.MemBase;
    ptr->dev_io_base = DevToConfig[screennum].GDev.IOBase;
    ptr->dev_clockchip = DevToConfig[screennum].GDev.clockchip;
    for (i = 0; (i < MAXCLOCKS) && (i < DevToConfig[screennum].GDev.numclocks);
         i++)
        ptr->dev_clock[i] = DevToConfig[screennum].GDev.clock[i];
    ptr->dev_clocks = i;
    ptr->dev_chipid = DevToConfig[screennum].GDev.chipID;
    ptr->dev_chiprev = DevToConfig[screennum].GDev.chipRev;
    ptr->dev_irq = DevToConfig[screennum].GDev.irq;

    /* Make sure older drivers don't segv */
    if (DevToConfig[screennum].GDev.options) {
        /* Fill in the available driver options for people to use */
        const char *descrip =
            "        ### Available Driver options are:-\n"
            "        ### Values: <i>: integer, <f>: float, "
            "<bool>: \"True\"/\"False\",\n"
            "        ### <string>: \"String\", <freq>: \"<f> Hz/kHz/MHz\",\n"
            "        ### <percent>: \"<f>%\"\n"
            "        ### [arg]: arg optional\n";
        ptr->dev_comment = xnfstrdup(descrip);
        if (ptr->dev_comment) {
            for (p = DevToConfig[screennum].GDev.options; p->name != NULL; p++) {
                char *p_e;
                const char *prefix = "        #Option     ";
                const char *middle = " \t# ";
                const char *suffix = "\n";
                const char *opttype = optionTypeToString(p->type);
                char *optname;
                int len = strlen(ptr->dev_comment) + strlen(prefix) +
                    strlen(middle) + strlen(suffix) + 1;

                if (asprintf(&optname, "\"%s\"", p->name) == -1)
                    break;

                len += max(20, strlen(optname));
                len += strlen(opttype);

                ptr->dev_comment = realloc(ptr->dev_comment, len);
                if (!ptr->dev_comment)
                    break;
                p_e = ptr->dev_comment + strlen(ptr->dev_comment);
                sprintf(p_e, "%s%-20s%s%s%s", prefix, optname, middle,
                        opttype, suffix);
                free(optname);
            }
        }
    }

    return ptr;
}

static XF86ConfLayoutPtr
configureLayoutSection(void)
{
    int scrnum = 0;

    parsePrologue(XF86ConfLayoutPtr, XF86ConfLayoutRec)

        ptr->lay_identifier = "X.org Configured";

    {
        XF86ConfInputrefPtr iptr;

        iptr = malloc(sizeof(XF86ConfInputrefRec));
        iptr->list.next = NULL;
        iptr->iref_option_lst = NULL;
        iptr->iref_inputdev_str = xnfstrdup("Mouse0");
        iptr->iref_option_lst =
            xf86addNewOption(iptr->iref_option_lst, xnfstrdup("CorePointer"),
                             NULL);
        ptr->lay_input_lst = (XF86ConfInputrefPtr)
            xf86addListItem((glp) ptr->lay_input_lst, (glp) iptr);
    }

    {
        XF86ConfInputrefPtr iptr;

        iptr = malloc(sizeof(XF86ConfInputrefRec));
        iptr->list.next = NULL;
        iptr->iref_option_lst = NULL;
        iptr->iref_inputdev_str = xnfstrdup("Keyboard0");
        iptr->iref_option_lst =
            xf86addNewOption(iptr->iref_option_lst, xnfstrdup("CoreKeyboard"),
                             NULL);
        ptr->lay_input_lst = (XF86ConfInputrefPtr)
            xf86addListItem((glp) ptr->lay_input_lst, (glp) iptr);
    }

    for (scrnum = 0; scrnum < nDevToConfig; scrnum++) {
        XF86ConfAdjacencyPtr aptr;
        char *tmp;

        aptr = malloc(sizeof(XF86ConfAdjacencyRec));
        aptr->list.next = NULL;
        aptr->adj_x = 0;
        aptr->adj_y = 0;
        aptr->adj_scrnum = scrnum;
        XNFasprintf(&tmp, "Screen%d", scrnum);
        aptr->adj_screen_str = tmp;
        if (scrnum == 0) {
            aptr->adj_where = CONF_ADJ_ABSOLUTE;
            aptr->adj_refscreen = NULL;
        }
        else {
            aptr->adj_where = CONF_ADJ_RIGHTOF;
            XNFasprintf(&tmp, "Screen%d", scrnum - 1);
            aptr->adj_refscreen = tmp;
        }
        ptr->lay_adjacency_lst =
            (XF86ConfAdjacencyPtr) xf86addListItem((glp) ptr->lay_adjacency_lst,
                                                   (glp) aptr);
    }

    return ptr;
}

static XF86ConfFlagsPtr
configureFlagsSection(void)
{
    parsePrologue(XF86ConfFlagsPtr, XF86ConfFlagsRec)

        return ptr;
}

static XF86ConfModulePtr
configureModuleSection(void)
{
    const char **elist, **el;

    /* Find the list of extension & font modules. */
    const char *esubdirs[] = {
        "extensions",
        "fonts",
        NULL
    };
    parsePrologue(XF86ConfModulePtr, XF86ConfModuleRec)

        elist = LoaderListDirs(esubdirs, NULL);
    if (elist) {
        for (el = elist; *el; el++) {
            XF86LoadPtr module;

            module = calloc(1, sizeof(XF86LoadRec));
            module->load_name = *el;
            ptr->mod_load_lst = (XF86LoadPtr) xf86addListItem((glp) ptr->
                                                              mod_load_lst,
                                                              (glp) module);
        }
        free(elist);
    }

    return ptr;
}

static XF86ConfFilesPtr
configureFilesSection(void)
{
    parsePrologue(XF86ConfFilesPtr, XF86ConfFilesRec)

        if (xf86ModulePath)
        ptr->file_modulepath = xnfstrdup(xf86ModulePath);
    if (defaultFontPath)
        ptr->file_fontpath = xnfstrdup(defaultFontPath);

    return ptr;
}

static XF86ConfMonitorPtr
configureMonitorSection(int screennum)
{
    char *tmp;
    parsePrologue(XF86ConfMonitorPtr, XF86ConfMonitorRec)

    XNFasprintf(&tmp, "Monitor%d", screennum);
    ptr->mon_identifier = tmp;
    ptr->mon_vendor = xnfstrdup("Monitor Vendor");
    ptr->mon_modelname = xnfstrdup("Monitor Model");

    return ptr;
}

/* Initialize Configure Monitor from Detailed Timing Block */
static void
handle_detailed_input(struct detailed_monitor_section *det_mon, void *data)
{
    XF86ConfMonitorPtr ptr = (XF86ConfMonitorPtr) data;

    switch (det_mon->type) {
    case DS_NAME:
        ptr->mon_modelname = realloc(ptr->mon_modelname,
                                     strlen((char *) (det_mon->section.name)) +
                                     1);
        strcpy(ptr->mon_modelname, (char *) (det_mon->section.name));
        break;
    case DS_RANGES:
        ptr->mon_hsync[ptr->mon_n_hsync].lo = det_mon->section.ranges.min_h;
        ptr->mon_hsync[ptr->mon_n_hsync].hi = det_mon->section.ranges.max_h;
        ptr->mon_n_vrefresh = 1;
        ptr->mon_vrefresh[ptr->mon_n_hsync].lo = det_mon->section.ranges.min_v;
        ptr->mon_vrefresh[ptr->mon_n_hsync].hi = det_mon->section.ranges.max_v;
        ptr->mon_n_hsync++;
    default:
        break;
    }
}

static XF86ConfMonitorPtr
configureDDCMonitorSection(int screennum)
{
    int len, mon_width, mon_height;

#define displaySizeMaxLen 80
    char displaySize_string[displaySizeMaxLen];
    int displaySizeLen;
    char *tmp;

    parsePrologue(XF86ConfMonitorPtr, XF86ConfMonitorRec)

    XNFasprintf(&tmp, "Monitor%d", screennum);
    ptr->mon_identifier = tmp;
    ptr->mon_vendor = xnfstrdup(ConfiguredMonitor->vendor.name);
    XNFasprintf(&ptr->mon_modelname, "%x", ConfiguredMonitor->vendor.prod_id);

    /* features in centimetres, we want millimetres */
    mon_width = 10 * ConfiguredMonitor->features.hsize;
    mon_height = 10 * ConfiguredMonitor->features.vsize;

#ifdef CONFIGURE_DISPLAYSIZE
    ptr->mon_width = mon_width;
    ptr->mon_height = mon_height;
#else
    if (mon_width && mon_height) {
        /* when values available add DisplaySize option AS A COMMENT */

        displaySizeLen = snprintf(displaySize_string, displaySizeMaxLen,
                                  "\t#DisplaySize\t%5d %5d\t# mm\n",
                                  mon_width, mon_height);

        if (displaySizeLen > 0 && displaySizeLen < displaySizeMaxLen) {
            if (ptr->mon_comment) {
                len = strlen(ptr->mon_comment);
            }
            else {
                len = 0;
            }
            if ((ptr->mon_comment =
                 realloc(ptr->mon_comment,
                         len + strlen(displaySize_string) + 1))) {
                strcpy(ptr->mon_comment + len, displaySize_string);
            }
        }
    }
#endif                          /* def CONFIGURE_DISPLAYSIZE */

    xf86ForEachDetailedBlock(ConfiguredMonitor, handle_detailed_input, ptr);

    if (ConfiguredMonitor->features.dpms) {
        ptr->mon_option_lst =
            xf86addNewOption(ptr->mon_option_lst, xnfstrdup("DPMS"), NULL);
    }

    return ptr;
}

void
DoConfigure(void)
{
    int i, j, screennum = -1;
    const char *home = NULL;
    char filename[PATH_MAX];
    const char *addslash = "";
    XF86ConfigPtr xf86config = NULL;
    const char **vlist, **vl;
    int *dev2screen;

    vlist = xf86DriverlistFromCompile();

    if (!vlist) {
        ErrorF("Missing output drivers.  Configuration failed.\n");
        goto bail;
    }

    ErrorF("List of video drivers:\n");
    for (vl = vlist; *vl; vl++)
        ErrorF("\t%s\n", *vl);

    /* Load all the drivers that were found. */
    xf86LoadModules(vlist, NULL);

    free(vlist);

    xorgHWAccess = xf86EnableIO();

    /* Create XF86Config file structure */
    xf86config = calloc(1, sizeof(XF86ConfigRec));

    /* Call all of the probe functions, reporting the results. */
    for (CurrentDriver = 0; CurrentDriver < xf86NumDrivers; CurrentDriver++) {
        Bool found_screen;
        DriverRec *const drv = xf86DriverList[CurrentDriver];

        found_screen = xf86CallDriverProbe(drv, TRUE);
        if (found_screen && drv->Identify) {
            (*drv->Identify) (0);
        }
    }

    if (nDevToConfig <= 0) {
        ErrorF("No devices to configure.  Configuration failed.\n");
        goto bail;
    }

    /* Add device, monitor and screen sections for detected devices */
    for (screennum = 0; screennum < nDevToConfig; screennum++) {
        XF86ConfDevicePtr device_ptr;
        XF86ConfMonitorPtr monitor_ptr;
        XF86ConfScreenPtr screen_ptr;

        device_ptr = configureDeviceSection(screennum);
        xf86config->conf_device_lst = (XF86ConfDevicePtr) xf86addListItem((glp)
                                                                          xf86config->
                                                                          conf_device_lst,
                                                                          (glp)
                                                                          device_ptr);
        monitor_ptr = configureMonitorSection(screennum);
        xf86config->conf_monitor_lst = (XF86ConfMonitorPtr) xf86addListItem((glp) xf86config->conf_monitor_lst, (glp) monitor_ptr);
        screen_ptr = configureScreenSection(screennum);
        xf86config->conf_screen_lst = (XF86ConfScreenPtr) xf86addListItem((glp)
                                                                          xf86config->
                                                                          conf_screen_lst,
                                                                          (glp)
                                                                          screen_ptr);
    }

    xf86config->conf_files = configureFilesSection();
    xf86config->conf_modules = configureModuleSection();
    xf86config->conf_flags = configureFlagsSection();
    xf86config->conf_videoadaptor_lst = NULL;
    xf86config->conf_modes_lst = NULL;
    xf86config->conf_vendor_lst = NULL;
    xf86config->conf_dri = NULL;
    xf86config->conf_input_lst = configureInputSection();
    xf86config->conf_layout_lst = configureLayoutSection();

    home = getenv("HOME");
    if ((home == NULL) || (home[0] == '\0')) {
        home = "/";
    }
    else {
        /* Determine if trailing slash is present or needed */
        int l = strlen(home);

        if (home[l - 1] != '/') {
            addslash = "/";
        }
    }

    snprintf(filename, sizeof(filename), "%s%s" XF86CONFIGFILE ".new",
             home, addslash);

    if (xf86writeConfigFile(filename, xf86config) == 0) {
        xf86Msg(X_ERROR, "Unable to write config file: \"%s\": %s\n",
                filename, strerror(errno));
        goto bail;
    }

    xf86DoConfigurePass1 = FALSE;
    /* Try to get DDC information filled in */
    xf86ConfigFile = filename;
    if (xf86HandleConfigFile(FALSE) != CONFIG_OK) {
        goto bail;
    }

    xf86DoConfigurePass1 = FALSE;

    dev2screen = xnfcalloc(xf86NumDrivers, sizeof(int));

    {
        Bool *driverProbed = xnfcalloc(xf86NumDrivers, sizeof(Bool));

        for (screennum = 0; screennum < nDevToConfig; screennum++) {
            int k, l, n, oldNumScreens;

            i = DevToConfig[screennum].iDriver;

            if (driverProbed[i])
                continue;
            driverProbed[i] = TRUE;

            oldNumScreens = xf86NumScreens;

            xf86CallDriverProbe(xf86DriverList[i], FALSE);

            /* reorder */
            k = screennum > 0 ? screennum : 1;
            for (l = oldNumScreens; l < xf86NumScreens; l++) {
                /* is screen primary? */
                Bool primary = FALSE;

                for (n = 0; n < xf86Screens[l]->numEntities; n++) {
                    if (xf86IsEntityPrimary(xf86Screens[l]->entityList[n])) {
                        dev2screen[0] = l;
                        primary = TRUE;
                        break;
                    }
                }
                if (primary)
                    continue;
                /* not primary: assign it to next device of same driver */
                /*
                 * NOTE: we assume that devices in DevToConfig
                 * and xf86Screens[] have the same order except
                 * for the primary device which always comes first.
                 */
                for (; k < nDevToConfig; k++) {
                    if (DevToConfig[k].iDriver == i) {
                        dev2screen[k++] = l;
                        break;
                    }
                }
            }
        }
        free(driverProbed);
    }

    if (nDevToConfig != xf86NumScreens) {
        ErrorF("Number of created screens does not match number of detected"
               " devices.\n  Configuration failed.\n");
        goto bail;
    }

    xf86PostProbe();

    for (j = 0; j < xf86NumScreens; j++) {
        xf86Screens[j]->scrnIndex = j;
    }

    xf86freeMonitorList(xf86config->conf_monitor_lst);
    xf86config->conf_monitor_lst = NULL;
    xf86freeScreenList(xf86config->conf_screen_lst);
    xf86config->conf_screen_lst = NULL;
    for (j = 0; j < xf86NumScreens; j++) {
        XF86ConfMonitorPtr monitor_ptr;
        XF86ConfScreenPtr screen_ptr;

        ConfiguredMonitor = NULL;

        if ((*xf86Screens[dev2screen[j]]->PreInit) (xf86Screens[dev2screen[j]],
                                                    PROBE_DETECT) &&
            ConfiguredMonitor) {
            monitor_ptr = configureDDCMonitorSection(j);
        }
        else {
            monitor_ptr = configureMonitorSection(j);
        }
        screen_ptr = configureScreenSection(j);

        xf86config->conf_monitor_lst = (XF86ConfMonitorPtr) xf86addListItem((glp) xf86config->conf_monitor_lst, (glp) monitor_ptr);
        xf86config->conf_screen_lst = (XF86ConfScreenPtr) xf86addListItem((glp)
                                                                          xf86config->
                                                                          conf_screen_lst,
                                                                          (glp)
                                                                          screen_ptr);
    }

    if (xf86writeConfigFile(filename, xf86config) == 0) {
        xf86Msg(X_ERROR, "Unable to write config file: \"%s\": %s\n",
                filename, strerror(errno));
        goto bail;
    }

    ErrorF("\n");

    if (!foundMouse) {
        ErrorF("\n" __XSERVERNAME__ " is not able to detect your mouse.\n"
               "Edit the file and correct the Device.\n");
    }
    else {
        ErrorF("\n" __XSERVERNAME__ " detected your mouse at device %s.\n"
               "Please check your config if the mouse is still not\n"
               "operational, as by default " __XSERVERNAME__
               " tries to autodetect\n" "the protocol.\n", DFLT_MOUSE_DEV);
    }

    if (xf86NumScreens > 1) {
        ErrorF("\n" __XSERVERNAME__
               " has configured a multihead system, please check your config.\n");
    }

    ErrorF("\nYour %s file is %s\n\n", XF86CONFIGFILE, filename);
    ErrorF("To test the server, run 'X -config %s'\n\n", filename);

 bail:
    CloseWellKnownConnections();
    OsCleanup(TRUE);
    AbortDDX(EXIT_ERR_CONFIGURE);
    fflush(stderr);
    exit(0);
}

/* Xorg -showopts:
 *   For each driver module installed, print out the list
 *   of options and their argument types, then exit
 *
 * Author:  Marcus Schaefer, ms@@suse.de
 */

void
DoShowOptions(void)
{
    int i = 0;
    const char **vlist = NULL;
    char *pSymbol = 0;
    XF86ModuleData *initData = 0;

    if (!(vlist = xf86DriverlistFromCompile())) {
        ErrorF("Missing output drivers\n");
        goto bail;
    }
    xf86LoadModules(vlist, 0);
    free(vlist);
    for (i = 0; i < xf86NumDrivers; i++) {
        if (xf86DriverList[i]->AvailableOptions) {
            const OptionInfoRec *pOption =
                (*xf86DriverList[i]->AvailableOptions) (0, 0);
            if (!pOption) {
                ErrorF("(EE) Couldn't read option table for %s driver\n",
                       xf86DriverList[i]->driverName);
                continue;
            }
            XNFasprintf(&pSymbol, "%sModuleData",
                        xf86DriverList[i]->driverName);
            initData = LoaderSymbol(pSymbol);
            if (initData) {
                XF86ModuleVersionInfo *vers = initData->vers;
                const OptionInfoRec *p;

                ErrorF("Driver[%d]:%s[%s] {\n",
                       i, xf86DriverList[i]->driverName, vers->vendor);
                for (p = pOption; p->name != NULL; p++) {
                    ErrorF("\t%s:%s\n", p->name, optionTypeToString(p->type));
                }
                ErrorF("}\n");
            }
        }
    }
 bail:
    OsCleanup(TRUE);
    AbortDDX(EXIT_ERR_DRIVERS);
    fflush(stderr);
    exit(0);
}
@


1.16
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d267 1
a267 1
    for (i = 0; (i < MAXDACSPEEDS) && (i < CONF_MAXDACSPEEDS); i++)
@


1.15
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d112 1
a112 1
        xnfrealloc(DevToConfig, nDevToConfig * sizeof(DevToConfigRec));
d648 1
a648 1
    dev2screen = xnfcalloc(1, xf86NumDrivers * sizeof(int));
d651 1
a651 1
        Bool *driverProbed = xnfcalloc(1, xf86NumDrivers * sizeof(Bool));
@


1.14
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a269 1
    ptr->dev_textclockfreq = DevToConfig[screennum].GDev.textClockFreq;
d682 2
a683 2
                /* 
                 * NOTE: we assume that devices in DevToConfig 
@


1.13
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d37 1
d84 1
d121 3
a123 2
    DevToConfig[i].GDev.driver = xnfalloc(strlen(driver) + 1);
    for (j = 0; (DevToConfig[i].GDev.driver[j] = tolower(driver[j])); j++);
d162 2
a163 2
        ptr->inp_identifier = "Keyboard0";
    ptr->inp_driver = "kbd";
d178 2
a179 2
    mouse->inp_identifier = "Mouse0";
    mouse->inp_driver = "mouse";
d181 2
a182 2
        xf86addNewOption(mouse->inp_option_lst, strdup("Protocol"),
                         strdup(DFLT_MOUSE_PROTO));
d184 2
a185 2
        xf86addNewOption(mouse->inp_option_lst, strdup("Device"),
                         strdup(DFLT_MOUSE_DEV));
d187 2
a188 2
        xf86addNewOption(mouse->inp_option_lst, strdup("ZAxisMapping"),
                         strdup("4 5 6 7"));
d198 1
d201 6
a206 3
        XNFasprintf(&ptr->scrn_identifier, "Screen%d", screennum);
    XNFasprintf(&ptr->scrn_monitor_str, "Monitor%d", screennum);
    XNFasprintf(&ptr->scrn_device_str, "Card%d", screennum);
d209 1
a209 1
        XF86ConfDisplayPtr display;
d211 5
a215 5
        display = calloc(1, sizeof(XF86ConfDisplayRec));
        display->disp_depth = depths[i];
        display->disp_black.red = display->disp_white.red = -1;
        display->disp_black.green = display->disp_white.green = -1;
        display->disp_black.blue = display->disp_white.blue = -1;
d219 1
a219 1
                                                                     display);
d255 1
d260 3
a262 2
        if (asprintf(&ptr->dev_identifier, "Card%d", screennum) == -1)
        ptr->dev_identifier = NULL;
d293 1
a293 1
        ptr->dev_comment = strdup(descrip);
d340 1
a340 1
        iptr->iref_inputdev_str = "Mouse0";
d342 1
a342 1
            xf86addNewOption(iptr->iref_option_lst, strdup("CorePointer"),
d354 1
a354 1
        iptr->iref_inputdev_str = "Keyboard0";
d356 1
a356 1
            xf86addNewOption(iptr->iref_option_lst, strdup("CoreKeyboard"),
d364 1
d371 2
a372 1
        XNFasprintf(&aptr->adj_screen_str, "Screen%d", scrnum);
d379 2
a380 1
            XNFasprintf(&aptr->adj_refscreen, "Screen%d", scrnum - 1);
d401 1
a401 1
    char **elist, **el;
d434 1
a434 1
        ptr->file_modulepath = strdup(xf86ModulePath);
d436 1
a436 1
        ptr->file_fontpath = strdup(defaultFontPath);
d444 1
d447 4
a450 3
        XNFasprintf(&ptr->mon_identifier, "Monitor%d", screennum);
    ptr->mon_vendor = strdup("Monitor Vendor");
    ptr->mon_modelname = strdup("Monitor Model");
d488 1
d492 3
a494 2
        XNFasprintf(&ptr->mon_identifier, "Monitor%d", screennum);
    ptr->mon_vendor = strdup(ConfiguredMonitor->vendor.name);
d532 1
a532 1
            xf86addNewOption(ptr->mon_option_lst, strdup("DPMS"), NULL);
d546 1
a546 1
    char **vlist, **vl;
d588 3
a590 3
        XF86ConfDevicePtr DevicePtr;
        XF86ConfMonitorPtr MonitorPtr;
        XF86ConfScreenPtr ScreenPtr;
d592 1
a592 1
        DevicePtr = configureDeviceSection(screennum);
d597 4
a600 4
                                                                          DevicePtr);
        MonitorPtr = configureMonitorSection(screennum);
        xf86config->conf_monitor_lst = (XF86ConfMonitorPtr) xf86addListItem((glp) xf86config->conf_monitor_lst, (glp) MonitorPtr);
        ScreenPtr = configureScreenSection(screennum);
d605 1
a605 1
                                                                          ScreenPtr);
d716 2
a717 2
        XF86ConfMonitorPtr MonitorPtr;
        XF86ConfScreenPtr ScreenPtr;
d724 1
a724 1
            MonitorPtr = configureDDCMonitorSection(j);
d727 1
a727 1
            MonitorPtr = configureMonitorSection(j);
d729 1
a729 1
        ScreenPtr = configureScreenSection(j);
d731 1
a731 1
        xf86config->conf_monitor_lst = (XF86ConfMonitorPtr) xf86addListItem((glp) xf86config->conf_monitor_lst, (glp) MonitorPtr);
d736 1
a736 1
                                                                          ScreenPtr);
d785 1
a785 1
    char **vlist = 0;
@


1.12
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d125 1
d132 1
@


1.11
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d304 2
a305 3
                snprintf(p_e, len - (ptr->dev_comment - p_e),
                         "%s%-20s%s%s%s", prefix, optname, middle,
                         opttype, suffix);
d547 1
a547 18
    for (i = 0; i < xf86NumDrivers; i++) {
        xorgHWFlags flags;

        if (!xf86DriverList[i]->driverFunc
            || !xf86DriverList[i]->driverFunc(NULL,
                                              GET_REQUIRED_HW_INTERFACES,
                                              &flags)
            || NEED_IO_ENABLED(flags)) {
            xorgHWAccess = TRUE;
            break;
        }
    }
    /* Enable full I/O access */
    if (xorgHWAccess) {
        if (!xf86EnableIO())
            /* oops, we have failed */
            xorgHWAccess = FALSE;
    }
a553 1
        xorgHWFlags flags;
a555 7

        if (!xorgHWAccess) {
            if (!drv->driverFunc
                || !drv->driverFunc(NULL, GET_REQUIRED_HW_INTERFACES, &flags)
                || NEED_IO_ENABLED(flags))
                continue;
        }
@


1.10
log
@Update to xserver 1.11.2
@
text
@d45 1
a45 1
    struct pci_device * pVideo;
d60 2
a61 2
static char *DFLT_MOUSE_DEV = "/dev/sysmouse";
static char *DFLT_MOUSE_PROTO = "auto";
d63 2
a64 2
static char DFLT_MOUSE_DEV[] = "/dev/input/mice";
static char DFLT_MOUSE_PROTO[] = "auto";
d66 2
a67 2
static char *DFLT_MOUSE_DEV = "/dev/wsmouse";
static char *DFLT_MOUSE_PROTO = "wsmouse";
d69 2
a70 2
static char *DFLT_MOUSE_DEV = "/dev/mouse";
static char *DFLT_MOUSE_PROTO = "auto";
d79 2
a80 1
xf86AddBusDeviceToConfigure(const char *driver, BusType bus, void *busData, int chipset)
d85 1
a85 1
	return NULL;
d88 1
a88 1
    for (i = 0;  i < nDevToConfig;  i++) {
d90 5
a94 3
            case BUS_PCI:
                ret = xf86PciConfigure(busData, DevToConfig[i].pVideo);
                break;
d96 3
a98 3
            case BUS_SBUS:
                ret = xf86SbusConfigure(busData, DevToConfig[i].sVideo);
                break;
d100 2
a101 2
            default:
                return NULL;
d110 1
a110 1
	xnfrealloc(DevToConfig, nDevToConfig * sizeof(DevToConfigRec));
d114 1
a114 1
            DevToConfig[i].GDev.chipRev = DevToConfig[i].GDev.irq = -1;
d120 1
a120 1
    for (j = 0;  (DevToConfig[i].GDev.driver[j] = tolower(driver[j]));  j++);
d123 6
a128 4
        case BUS_PCI:
            xf86PciConfigureNewDev(busData, DevToConfig[i].pVideo,
                                   &DevToConfig[i].GDev, &chipset);
	        break;
d130 4
a133 4
        case BUS_SBUS:
            xf86SbusConfigureNewDev(busData, DevToConfig[i].sVideo,
                                    &DevToConfig[i].GDev);
	        break;
d135 2
a136 2
        default:
	        break;
d141 2
a142 3
	DevToConfig[i].GDev.options = (OptionInfoPtr)
	    (*xf86DriverList[CurrentDriver]->AvailableOptions)(chipset,
							       bus);
d146 1
a146 1
out:
d151 1
a151 1
configureInputSection (void)
a153 1
    parsePrologue (XF86ConfInputPtr, XF86ConfInputRec)
d155 3
a157 1
    ptr->inp_identifier = "Keyboard0";
d162 2
a163 2
    { 
	int fd;
d165 5
a169 5
	fd = open(DFLT_MOUSE_DEV, 0);
	if (fd != -1) {
	    foundMouse = TRUE;
	    close(fd);
	}
d175 10
a184 10
    mouse->inp_option_lst = 
		xf86addNewOption(mouse->inp_option_lst, strdup("Protocol"),
				strdup(DFLT_MOUSE_PROTO));
    mouse->inp_option_lst = 
		xf86addNewOption(mouse->inp_option_lst, strdup("Device"),
				strdup(DFLT_MOUSE_DEV));
    mouse->inp_option_lst = 
		xf86addNewOption(mouse->inp_option_lst, strdup("ZAxisMapping"),
				strdup("4 5 6 7"));
    ptr = (XF86ConfInputPtr)xf86addListItem((glp)ptr, (glp)mouse);
d189 1
a189 1
configureScreenSection (int screennum)
d192 2
a193 2
    int depths[] = { 1, 4, 8, 15, 16, 24/*, 32*/ };
    parsePrologue (XF86ConfScreenPtr, XF86ConfScreenRec)
d195 1
a195 1
    XNFasprintf(&ptr->scrn_identifier, "Screen%d", screennum);
d199 2
a200 3
    for (i=0; i<sizeof(depths)/sizeof(depths[0]); i++)
    {
	XF86ConfDisplayPtr display;
d202 9
a210 7
	display = calloc(1, sizeof(XF86ConfDisplayRec));
	display->disp_depth = depths[i];
	display->disp_black.red = display->disp_white.red = -1;
	display->disp_black.green = display->disp_white.green = -1;
	display->disp_black.blue = display->disp_white.blue = -1;
	ptr->scrn_display_lst = (XF86ConfDisplayPtr)xf86addListItem(
				     (glp)ptr->scrn_display_lst, (glp)display);
d216 1
a216 1
static const char* 
d227 1
a227 1
       return "[<str>]";
d242 1
a242 1
configureDeviceSection (int screennum)
a245 1
    parsePrologue (XF86ConfDevicePtr, XF86ConfDeviceRec)
d247 4
a250 2
    /* Move device info to parser structure */
    if (asprintf(&ptr->dev_identifier, "Card%d", screennum) == -1)
d256 1
a256 1
    for (i = 0;  (i < MAXDACSPEEDS) && (i < CONF_MAXDACSPEEDS);  i++)
d264 2
a265 1
    for (i = 0;  (i < MAXCLOCKS) && (i < DevToConfig[screennum].GDev.numclocks);  i++)
d274 36
a309 37
    	/* Fill in the available driver options for people to use */
	const char *descrip =
	    "        ### Available Driver options are:-\n"
	    "        ### Values: <i>: integer, <f>: float, "
			"<bool>: \"True\"/\"False\",\n"
	    "        ### <string>: \"String\", <freq>: \"<f> Hz/kHz/MHz\",\n"
	    "        ### <percent>: \"<f>%\"\n"
	    "        ### [arg]: arg optional\n";
	ptr->dev_comment = strdup(descrip);
	if (ptr->dev_comment) {
    	    for (p = DevToConfig[screennum].GDev.options;
		 p->name != NULL; p++) {
		char *p_e;
		const char *prefix = "        #Option     ";
		const char *middle = " \t# ";
		const char *suffix = "\n";
		const char *opttype = optionTypeToString(p->type);
		char *optname;
		int len = strlen(ptr->dev_comment) + strlen(prefix) +
			  strlen(middle) + strlen(suffix) + 1;
		
		if (asprintf(&optname, "\"%s\"", p->name) == -1)
		    break;

		len += max(20, strlen(optname));
		len += strlen(opttype);

		ptr->dev_comment = realloc(ptr->dev_comment, len);
		if (!ptr->dev_comment)
		    break;
		p_e = ptr->dev_comment + strlen(ptr->dev_comment);
		snprintf(p_e, len - (ptr->dev_comment - p_e), 
			 "%s%-20s%s%s%s", prefix, optname, middle,
			 opttype, suffix);
		free(optname);
	    }
    	}
d316 1
a316 1
configureLayoutSection (void)
a318 1
    parsePrologue (XF86ConfLayoutPtr, XF86ConfLayoutRec)
d320 3
a322 1
    ptr->lay_identifier = "X.org Configured";
d325 1
a325 1
	XF86ConfInputrefPtr iptr;
d327 9
a335 8
	iptr = malloc (sizeof (XF86ConfInputrefRec));
	iptr->list.next = NULL;
	iptr->iref_option_lst = NULL;
	iptr->iref_inputdev_str = "Mouse0";
	iptr->iref_option_lst =
		xf86addNewOption (iptr->iref_option_lst, strdup("CorePointer"), NULL);
	ptr->lay_input_lst = (XF86ConfInputrefPtr)
		xf86addListItem ((glp) ptr->lay_input_lst, (glp) iptr);
d339 1
a339 1
	XF86ConfInputrefPtr iptr;
d341 31
a371 30
	iptr = malloc (sizeof (XF86ConfInputrefRec));
	iptr->list.next = NULL;
	iptr->iref_option_lst = NULL;
	iptr->iref_inputdev_str = "Keyboard0";
	iptr->iref_option_lst =
		xf86addNewOption (iptr->iref_option_lst, strdup("CoreKeyboard"), NULL);
	ptr->lay_input_lst = (XF86ConfInputrefPtr)
		xf86addListItem ((glp) ptr->lay_input_lst, (glp) iptr);
    }

    for (scrnum = 0;  scrnum < nDevToConfig;  scrnum++) {
	XF86ConfAdjacencyPtr aptr;

	aptr = malloc (sizeof (XF86ConfAdjacencyRec));
	aptr->list.next = NULL;
	aptr->adj_x = 0;
	aptr->adj_y = 0;
	aptr->adj_scrnum = scrnum;
	XNFasprintf(&aptr->adj_screen_str, "Screen%d", scrnum);
	if (scrnum == 0) {
	    aptr->adj_where = CONF_ADJ_ABSOLUTE;
	    aptr->adj_refscreen = NULL;
	}
	else {
	    aptr->adj_where = CONF_ADJ_RIGHTOF;
	    XNFasprintf(&aptr->adj_refscreen, "Screen%d", scrnum - 1);
	}
    	ptr->lay_adjacency_lst =
	    (XF86ConfAdjacencyPtr)xf86addListItem((glp)ptr->lay_adjacency_lst,
					      (glp)aptr);
d378 1
a378 1
configureFlagsSection (void)
d380 1
a380 1
    parsePrologue (XF86ConfFlagsPtr, XF86ConfFlagsRec)
d382 1
a382 1
    return ptr;
d386 1
a386 1
configureModuleSection (void)
d389 1
d392 3
a394 3
	"extensions",
	"fonts",
	NULL
d396 1
a396 1
    parsePrologue (XF86ConfModulePtr, XF86ConfModuleRec)
d398 1
a398 1
    elist = LoaderListDirs(esubdirs, NULL);
d400 2
a401 2
	for (el = elist; *el; el++) {
	    XF86LoadPtr module;
d403 7
a409 6
    	    module = calloc(1, sizeof(XF86LoadRec));
    	    module->load_name = *el;
            ptr->mod_load_lst = (XF86LoadPtr)xf86addListItem(
                                (glp)ptr->mod_load_lst, (glp)module);
    	}
	free(elist);
d416 1
a416 1
configureFilesSection (void)
d418 6
a423 1
    parsePrologue (XF86ConfFilesPtr, XF86ConfFilesRec)
a424 5
   if (xf86ModulePath)
       ptr->file_modulepath = strdup(xf86ModulePath);
   if (defaultFontPath)
       ptr->file_fontpath = strdup(defaultFontPath);
   
d429 1
a429 1
configureMonitorSection (int screennum)
d431 1
a431 1
    parsePrologue (XF86ConfMonitorPtr, XF86ConfMonitorRec)
d433 1
a433 1
    XNFasprintf(&ptr->mon_identifier, "Monitor%d", screennum);
d441 2
a442 2
static void handle_detailed_input(struct detailed_monitor_section *det_mon,
                                  void *data)
d449 1
a449 1
                                     strlen((char*)(det_mon->section.name)) +
d451 1
a451 2
        strcpy(ptr->mon_modelname,
	      (char*)(det_mon->section.name));
d454 2
a455 4
        ptr->mon_hsync[ptr->mon_n_hsync].lo =
            det_mon->section.ranges.min_h;
        ptr->mon_hsync[ptr->mon_n_hsync].hi =
            det_mon->section.ranges.max_h;
d457 2
a458 4
        ptr->mon_vrefresh[ptr->mon_n_hsync].lo =
            det_mon->section.ranges.min_v;
        ptr->mon_vrefresh[ptr->mon_n_hsync].hi =
            det_mon->section.ranges.max_v;
d466 1
a466 1
configureDDCMonitorSection (int screennum)
d469 1
d474 1
a474 1
    parsePrologue (XF86ConfMonitorPtr, XF86ConfMonitorRec)
d476 1
a476 1
    XNFasprintf(&ptr->mon_identifier, "Monitor%d", screennum);
d481 2
a482 2
    mon_width  = 10 * ConfiguredMonitor->features.hsize ;
    mon_height = 10 * ConfiguredMonitor->features.vsize ;
d485 1
a485 1
    ptr->mon_width  = mon_width;
d489 1
a489 1
      /* when values available add DisplaySize option AS A COMMENT */
d491 17
a507 15
      displaySizeLen = snprintf(displaySize_string, displaySizeMaxLen,
				"\t#DisplaySize\t%5d %5d\t# mm\n",
				mon_width, mon_height);

      if (displaySizeLen>0 && displaySizeLen<displaySizeMaxLen) {
	if (ptr->mon_comment) {
	  len = strlen(ptr->mon_comment);
	} else {
	  len = 0;
	}
	if ((ptr->mon_comment =
	     realloc(ptr->mon_comment, len + strlen(displaySize_string) + 1))) {
	  strcpy(ptr->mon_comment + len, displaySize_string);
	}
      }
d509 1
a509 1
#endif /* def CONFIGURE_DISPLAYSIZE */
d511 1
a511 2
    xf86ForEachDetailedBlock(ConfiguredMonitor, handle_detailed_input,
                             ptr);
d514 2
a515 1
      ptr->mon_option_lst = xf86addNewOption(ptr->mon_option_lst, strdup("DPMS"), NULL);
d524 2
a525 2
    int i,j, screennum = -1;
    char *home = NULL;
d527 1
a527 1
    char *addslash = "";
d535 2
a536 2
	ErrorF("Missing output drivers.  Configuration failed.\n");
	goto bail;
d541 1
a541 1
	ErrorF("\t%s\n", *vl);
d549 10
a558 9
	xorgHWFlags flags;
	if (!xf86DriverList[i]->driverFunc
	    || !xf86DriverList[i]->driverFunc(NULL,
					      GET_REQUIRED_HW_INTERFACES,
					      &flags)
	    || NEED_IO_ENABLED(flags)) {
	    xorgHWAccess = TRUE;
	    break;
	}
d562 3
a564 3
	if(!xf86EnableIO())
	    /* oops, we have failed */
	    xorgHWAccess = FALSE;
d571 16
a586 16
    for (CurrentDriver = 0;  CurrentDriver < xf86NumDrivers;  CurrentDriver++) {
	xorgHWFlags flags;
	Bool found_screen;
	DriverRec * const drv = xf86DriverList[CurrentDriver];

	if (!xorgHWAccess) {
	    if (!drv->driverFunc
		|| !drv->driverFunc( NULL, GET_REQUIRED_HW_INTERFACES, &flags )
		|| NEED_IO_ENABLED(flags)) 
		continue;
	}
	
	found_screen = xf86CallDriverProbe( drv, TRUE );
	if ( found_screen && drv->Identify ) {
	    (*drv->Identify)(0);
	}
d590 2
a591 2
	ErrorF("No devices to configure.  Configuration failed.\n");
	goto bail;
d595 19
a613 14
    for (screennum = 0;  screennum < nDevToConfig;  screennum++) {
    	XF86ConfDevicePtr DevicePtr;
	XF86ConfMonitorPtr MonitorPtr;
	XF86ConfScreenPtr ScreenPtr;

	DevicePtr = configureDeviceSection(screennum);
    	xf86config->conf_device_lst = (XF86ConfDevicePtr)xf86addListItem(
			    (glp)xf86config->conf_device_lst, (glp)DevicePtr);
	MonitorPtr = configureMonitorSection(screennum);
    	xf86config->conf_monitor_lst = (XF86ConfMonitorPtr)xf86addListItem(
			    (glp)xf86config->conf_monitor_lst, (glp)MonitorPtr);
	ScreenPtr = configureScreenSection(screennum);
    	xf86config->conf_screen_lst = (XF86ConfScreenPtr)xf86addListItem(
			    (glp)xf86config->conf_screen_lst, (glp)ScreenPtr);
d628 9
a636 8
    	home = "/";
    } else {
	/* Determine if trailing slash is present or needed */
	int l = strlen(home);

	if (home[l-1] != '/') {
	    addslash = "/";
	}
d640 1
a640 1
	     home, addslash);
d643 3
a645 3
	xf86Msg(X_ERROR, "Unable to write config file: \"%s\": %s\n",
		filename, strerror(errno));
	goto bail;
d652 1
a652 1
	goto bail;
d656 2
a657 2
    
    dev2screen = xnfcalloc(1,xf86NumDrivers*sizeof(int));
d660 45
a704 41
	Bool *driverProbed = xnfcalloc(1,xf86NumDrivers*sizeof(Bool));
	for (screennum = 0;  screennum < nDevToConfig;  screennum++) {
	    int k,l,n,oldNumScreens;

	    i = DevToConfig[screennum].iDriver;

	    if (driverProbed[i]) continue;
	    driverProbed[i] = TRUE;
	    
	    oldNumScreens = xf86NumScreens;

	    xf86CallDriverProbe( xf86DriverList[i], FALSE );

	    /* reorder */
	    k = screennum > 0 ? screennum : 1;
	    for (l = oldNumScreens; l < xf86NumScreens; l++) {
	        /* is screen primary? */
	        Bool primary = FALSE;
		for (n = 0; n<xf86Screens[l]->numEntities; n++) {
	            if (xf86IsEntityPrimary(xf86Screens[l]->entityList[n])) {
		        dev2screen[0] = l;
			primary = TRUE;
			break;
		    }
		}
		if (primary) continue;
		/* not primary: assign it to next device of same driver */
		/* 
		 * NOTE: we assume that devices in DevToConfig 
		 * and xf86Screens[] have the same order except
		 * for the primary device which always comes first.
		 */
		for (; k < nDevToConfig; k++) {
		    if (DevToConfig[k].iDriver == i) {
		        dev2screen[k++] = l;
			break;
		    }
		}
	    }
	}
	free(driverProbed);
a705 1
    
d708 3
a710 3
	ErrorF("Number of created screens does not match number of detected"
	       " devices.\n  Configuration failed.\n");
	goto bail;
d716 1
a716 1
	xf86Screens[j]->scrnIndex = j;
d724 2
a725 2
	XF86ConfMonitorPtr MonitorPtr;
	XF86ConfScreenPtr ScreenPtr;
d727 11
a737 1
	ConfiguredMonitor = NULL;
d739 6
a744 12
	if ((*xf86Screens[dev2screen[j]]->PreInit)(xf86Screens[dev2screen[j]], 
						   PROBE_DETECT) &&
	    ConfiguredMonitor) {
	    MonitorPtr = configureDDCMonitorSection(j);
	} else {
	    MonitorPtr = configureMonitorSection(j);
	}
	ScreenPtr = configureScreenSection(j);
	xf86config->conf_monitor_lst = (XF86ConfMonitorPtr)xf86addListItem(
		(glp)xf86config->conf_monitor_lst, (glp)MonitorPtr);
	xf86config->conf_screen_lst = (XF86ConfScreenPtr)xf86addListItem(
		(glp)xf86config->conf_screen_lst, (glp)ScreenPtr);
d748 3
a750 3
	xf86Msg(X_ERROR, "Unable to write config file: \"%s\": %s\n",
		filename, strerror(errno));
	goto bail;
d756 8
a763 8
	ErrorF("\n"__XSERVERNAME__" is not able to detect your mouse.\n"
		"Edit the file and correct the Device.\n");
    } else {
	ErrorF("\n"__XSERVERNAME__" detected your mouse at device %s.\n"
		"Please check your config if the mouse is still not\n"
		"operational, as by default "__XSERVERNAME__
	       " tries to autodetect\n"
		"the protocol.\n",DFLT_MOUSE_DEV);
d767 2
a768 2
	ErrorF("\n"__XSERVERNAME__
	       " has configured a multihead system, please check your config.\n");
d771 1
a771 1
    ErrorF("\nYour %s file is %s\n\n", XF86CONFIGFILE ,filename);
d774 1
a774 1
bail:
d778 53
@


1.9
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d37 1
a37 1
#if (defined(__sparc__) || defined(__sparc))
d41 1
d46 1
a46 1
#if (defined(__sparc__) || defined(__sparc))
d59 1
a59 6
#if defined(__SCO__)
static char *DFLT_MOUSE_PROTO = "OSMouse";
#elif defined(__UNIXWARE__)
static char *DFLT_MOUSE_PROTO = "OSMouse";
static char *DFLT_MOUSE_DEV = "/dev/mouse";
#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
d65 3
a72 81
static Bool
bus_pci_configure(void *busData)
{
    int i;
    struct pci_device * pVideo = NULL;

	pVideo = (struct pci_device *) busData;
	for (i = 0;  i < nDevToConfig;  i++)
	    if (DevToConfig[i].pVideo &&
		(DevToConfig[i].pVideo->domain == pVideo->domain) &&
		(DevToConfig[i].pVideo->bus == pVideo->bus) &&
		(DevToConfig[i].pVideo->dev == pVideo->dev) &&
		(DevToConfig[i].pVideo->func == pVideo->func))
		return 0;

	return 1;
}

static Bool
bus_sbus_configure(void *busData)
{
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
    int i;

    for (i = 0;  i < nDevToConfig;  i++)
        if (DevToConfig[i].sVideo &&
        DevToConfig[i].sVideo->fbNum == ((sbusDevicePtr) busData)->fbNum)
            return 0;

#endif
    return 1;
}

static void
bus_pci_newdev_configure(void *busData, int i, int *chipset)
{
	char busnum[8];
	struct pci_device * pVideo = NULL;

	pVideo = (struct pci_device *) busData;
	
	DevToConfig[i].pVideo = pVideo;

	DevToConfig[i].GDev.busID = xnfalloc(16);
	xf86FormatPciBusNumber(pVideo->bus, busnum);
	snprintf(DevToConfig[i].GDev.busID, 16, "PCI:%s:%d:%d",
	    busnum, pVideo->dev, pVideo->func);

	DevToConfig[i].GDev.chipID = pVideo->device_id;
	DevToConfig[i].GDev.chipRev = pVideo->revision;

	if (*chipset < 0) {
	    *chipset = (pVideo->vendor_id << 16) | pVideo->device_id;
	}
}

static void
bus_sbus_newdev_configure(void *busData, int i)
{
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
	char *promPath = NULL;
	size_t len;

	DevToConfig[i].sVideo = (sbusDevicePtr) busData;
	DevToConfig[i].GDev.identifier = DevToConfig[i].sVideo->descr;
	if (sparcPromInit() >= 0) {
	    promPath = sparcPromNode2Pathname(&DevToConfig[i].sVideo->node);
	    sparcPromClose();
	}
	if (promPath) {
	    len = strlen(promPath) + 6;
	    DevToConfig[i].GDev.busID = xnfalloc(len);
	    snprintf(DevToConfig[i].GDev.busID, len, "SBUS:%s", promPath);
	    free(promPath);
	} else {
	    NewDevice.GDev.busID = xnfalloc(12);
	    snprintf(DevToConfig[i].GDev.busID, 12, "SBUS:fb%d", NewDevice.sVideo->fbNum);
	}
#endif
}

d87 15
a101 9
    switch (bus) {
        case BUS_PCI:
            ret = bus_pci_configure(busData);
	        break;
        case BUS_SBUS:
            ret = bus_sbus_configure(busData);
	        break;
        default:
	        return NULL;
a103 3
    if (ret == 0)
        goto out;

d121 2
a122 1
            bus_pci_newdev_configure(busData, i, &chipset);
d124 1
d126 2
a127 1
            bus_sbus_newdev_configure(busData, i);
d129 1
a158 10
#ifdef WSCONS_SUPPORT
	fd = open("/dev/wsmouse", 0);
	if (fd >= 0) {
	    DFLT_MOUSE_DEV = "/dev/wsmouse";
	    DFLT_MOUSE_PROTO = "wsmouse";
	    close(fd);
	} else {
	    ErrorF("cannot open /dev/wsmouse\n");
	}
#endif
a159 1
#ifndef __SCO__
a164 3
#else
	foundMouse = TRUE;
#endif
a172 1
#ifndef __SCO__
a175 1
#endif
d190 3
a192 6
    ptr->scrn_identifier = malloc(18);
    snprintf(ptr->scrn_identifier, 18, "Screen%d", screennum);
    ptr->scrn_monitor_str = malloc(19);
    snprintf(ptr->scrn_monitor_str, 19, "Monitor%d", screennum);
    ptr->scrn_device_str = malloc(16);
    snprintf(ptr->scrn_device_str, 16, "Card%d", screennum);
a237 1
    char identifier[16];
d243 2
a244 2
    snprintf(identifier, sizeof(identifier), "Card%d", screennum);
    ptr->dev_identifier = strdup(identifier);
d286 2
a287 4
		int optlen = strlen(p->name) + 2 + 1;

		optname = malloc(optlen);
		if (!optname)
a288 1
		snprintf(optname, optlen, "\"%s\"", p->name);
d350 1
a350 2
	aptr->adj_screen_str = xnfalloc(18);
	snprintf(aptr->adj_screen_str, 18, "Screen%d", scrnum);
d357 1
a357 2
	    aptr->adj_refscreen = xnfalloc(18);
	    snprintf(aptr->adj_refscreen, 18, "Screen%d", scrnum - 1);
d421 1
a421 2
    ptr->mon_identifier = malloc(19);
    snprintf(ptr->mon_identifier, 19, "Monitor%d", screennum);
d468 1
a468 2
    ptr->mon_identifier = malloc(19);
    snprintf(ptr->mon_identifier, 19, "Monitor%d", screennum);
d470 1
a470 2
    ptr->mon_modelname = malloc(12);
    snprintf(ptr->mon_modelname, 12, "%x", ConfiguredMonitor->vendor.prod_id);
a510 4
#if !defined(PATH_MAX)
# define PATH_MAX 1024
#endif

a730 7
#ifdef __SCO__
    ErrorF("\n"__XSERVERNAME__
	   " is using the kernel event driver to access the mouse.\n"
	    "If you wish to use the internal "__XSERVERNAME__
	   " mouse drivers, please\n"
	    "edit the file and correct the Device.\n");
#else /* !__SCO__ */
a740 1
#endif /* !__SCO__ */
d753 1
a753 1
    AbortDDX();
@


1.8
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a109 2
	const char *VendorName;
	const char *CardName;
d111 1
a111 4
    struct pci_device * pVideo = NULL;
	size_t len;

    pVideo = (struct pci_device *) busData;
d113 2
a116 21
	VendorName = pci_device_get_vendor_name( pVideo );
	CardName = pci_device_get_device_name( pVideo );

	if (!VendorName) {
	    VendorName = xnfalloc(15);
	    snprintf((char*)VendorName, 15, "Unknown Vendor");
	}

	if (!CardName) {
	    CardName = xnfalloc(14);
	    snprintf((char*)CardName, 14, "Unknown Board");
	}

	len = strlen(VendorName) + strlen(CardName) + 2;
	DevToConfig[i].GDev.identifier = xnfalloc(len);
	snprintf(DevToConfig[i].GDev.identifier, len, "%s %s", 
	    VendorName, CardName);

	DevToConfig[i].GDev.vendor = (char *)VendorName;
	DevToConfig[i].GDev.board = (char *)CardName;

d147 1
a147 1
	    xfree(promPath);
d260 2
a261 2
		xf86addNewOption(mouse->inp_option_lst, xstrdup("Protocol"),
				xstrdup(DFLT_MOUSE_PROTO));
d264 2
a265 2
		xf86addNewOption(mouse->inp_option_lst, xstrdup("Device"),
				xstrdup(DFLT_MOUSE_DEV));
d268 2
a269 2
		xf86addNewOption(mouse->inp_option_lst, xstrdup("ZAxisMapping"),
				xstrdup("4 5 6 7"));
d305 1
a305 1
optionTypeToSting(OptionValueType type)
d322 2
a339 3
/*    ptr->dev_identifier = DevToConfig[screennum].GDev.identifier;*/
    ptr->dev_vendor = DevToConfig[screennum].GDev.vendor;
    ptr->dev_board = DevToConfig[screennum].GDev.board;
d366 2
a367 1
	    "        ### <string>: \"String\", <freq>: \"<f> Hz/kHz/MHz\"\n"
d369 1
a369 1
	ptr->dev_comment = xstrdup(descrip);
d377 1
a377 1
		const char *opttype = optionTypeToSting(p->type);
d383 1
a383 1
		optname = xalloc(optlen);
d391 1
a391 1
		ptr->dev_comment = xrealloc(ptr->dev_comment, len);
d398 1
a398 1
		xfree(optname);
d422 1
a422 1
		xf86addNewOption (iptr->iref_option_lst, xstrdup("CorePointer"), NULL);
d435 1
a435 1
		xf86addNewOption (iptr->iref_option_lst, xstrdup("CoreKeyboard"), NULL);
d497 1
a497 1
	xfree(elist);
d608 1
a608 1
      ptr->mon_option_lst = xf86addNewOption(ptr->mon_option_lst, xstrdup("DPMS"), NULL);
a621 1
    size_t len;
d643 1
a643 1
    xfree(vlist);
a662 2
    xf86FindPrimaryDevice();
 
d790 1
a790 1
	xfree(driverProbed);
a800 1
    xf86EntityInit();
a815 1
	xf86EnableAccess(xf86Screens[dev2screen[j]]);
@


1.7
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a29 12
#include <ctype.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <X11/X.h>
#include <X11/Xmd.h>
#include <pciaccess.h>
#include "Pci.h"
#include "os.h"
#include "loaderProcs.h"
a34 2
#include "xf86Parser.h"
#include "xf86tokens.h"
a35 1
#include "vbe.h"
a40 1
#include "globals.h"
d54 1
a54 1
_X_EXPORT xf86MonPtr ConfiguredMonitor;
d74 2
a75 7
/*
 * This is called by the driver, either through xf86Match???Instances() or
 * directly.  We allocate a GDevRec and fill it in as much as we can, letting
 * the caller fill in the rest and/or change it as it sees fit.
 */
GDevPtr
xf86AddBusDeviceToConfigure(const char *driver, BusType bus, void *busData, int chipset)
d77 1
a77 2
    int i, j;
    size_t len;
a78 1
    Bool isPrimary = FALSE;
a79 6
    if (xf86DoProbe || !xf86DoConfigure || !xf86DoConfigurePass1)
	return NULL;

    /* Check for duplicates */
    switch (bus) {
    case BUS_PCI:
d87 1
a87 14
		return NULL;
	isPrimary = xf86IsPrimaryPci(pVideo);
	break;
#if (defined(__sparc__) || defined(__sparc))
    case BUS_SBUS:
	for (i = 0;  i < nDevToConfig;  i++)
	    if (DevToConfig[i].sVideo &&
		DevToConfig[i].sVideo->fbNum == ((sbusDevicePtr) busData)->fbNum)
		return NULL;
	break;
#endif
    default:
	return NULL;
    }
d89 2
a90 12
    /* Allocate new structure occurrence */
    i = nDevToConfig++;
    DevToConfig =
	xnfrealloc(DevToConfig, nDevToConfig * sizeof(DevToConfigRec));
#if 1   /* Doesn't work when a driver detects more than one adapter */
    if ((i > 0) && isPrimary) {
        memmove(DevToConfig + 1,DevToConfig,
		(nDevToConfig - 1) * sizeof(DevToConfigRec));
	i = 0;
    } 
#endif
    memset(DevToConfig + i, 0, sizeof(DevToConfigRec));
d92 5
a96 1
#   define NewDevice DevToConfig[i]
d98 4
a101 1
    NewDevice.GDev.chipID = NewDevice.GDev.chipRev = NewDevice.GDev.irq = -1;
d103 3
a105 1
    NewDevice.iDriver = CurrentDriver;
d107 3
a109 6
    /* Fill in what we know, converting the driver name to lower case */
    NewDevice.GDev.driver = xnfalloc(strlen(driver) + 1);
    for (j = 0;  (NewDevice.GDev.driver[j] = tolower(driver[j]));  j++);

    switch (bus) {
    case BUS_PCI: {
d113 4
d118 1
a118 1
	NewDevice.pVideo = pVideo;
d134 2
a135 2
	NewDevice.GDev.identifier = xnfalloc(len);
	snprintf(NewDevice.GDev.identifier, len, "%s %s", 
d138 2
a139 2
	NewDevice.GDev.vendor = (char *)VendorName;
	NewDevice.GDev.board = (char *)CardName;
d141 1
a141 1
	NewDevice.GDev.busID = xnfalloc(16);
d143 1
a143 1
	snprintf(NewDevice.GDev.busID, 16, "PCI:%s:%d:%d",
d146 2
a147 2
	NewDevice.GDev.chipID = pVideo->device_id;
	NewDevice.GDev.chipRev = pVideo->revision;
d149 2
a150 2
	if (chipset < 0)
	    chipset = (pVideo->vendor_id << 16) | pVideo->device_id;
d152 5
a156 1
	break;
a157 1
    case BUS_SBUS: {
d159 4
a162 2
	NewDevice.sVideo = (sbusDevicePtr) busData;
	NewDevice.GDev.identifier = NewDevice.sVideo->descr;
d164 1
a164 1
	    promPath = sparcPromNode2Pathname(&NewDevice.sVideo->node);
d169 2
a170 2
	    NewDevice.GDev.busID = xnfalloc(len);
	    snprintf(NewDevice.GDev.busID, len, "SBUS:%s", promPath);
d174 1
a174 1
	    snprintf(NewDevice.GDev.busID, 12, "SBUS:fb%d", NewDevice.sVideo->fbNum);
a175 2
	}
	break;
d177 54
a230 2
    default:
	break;
d235 1
a235 1
	NewDevice.GDev.options = (OptionInfoPtr)
d239 1
a239 1
    return &NewDevice.GDev;
d241 2
a242 1
#   undef NewDevice
d260 1
a260 1
	if (fd > 0) {
d280 1
a280 1
    mouse = xf86confcalloc(1, sizeof(XF86ConfInputRec));
d305 1
a305 1
    ptr->scrn_identifier = xf86confmalloc(18);
d307 1
a307 1
    ptr->scrn_monitor_str = xf86confmalloc(19);
d309 1
a309 1
    ptr->scrn_device_str = xf86confmalloc(16);
d316 1
a316 1
	display = xf86confcalloc(1, sizeof(XF86ConfDisplayRec));
d441 1
a441 1
	iptr = xf86confmalloc (sizeof (XF86ConfInputrefRec));
d454 1
a454 1
	iptr = xf86confmalloc (sizeof (XF86ConfInputrefRec));
d467 1
a467 1
	aptr = xf86confmalloc (sizeof (XF86ConfAdjacencyRec));
d503 1
a503 1
    /* Find the list of extension modules. */
a505 3
	NULL
    };
    const char *fsubdirs[] = {
d516 1
a516 1
    	    module = xf86confcalloc(1, sizeof(XF86LoadRec));
a523 22
    /* Process list of font backends separately to include only required ones */
    elist = LoaderListDirs(fsubdirs, NULL);
    if (elist) {
	for (el = elist; *el; el++) {
	    XF86LoadPtr module;

    	    module = xf86confcalloc(1, sizeof(XF86LoadRec));
    	    module->load_name = *el;

            /* Add only those font backends which are referenced by fontpath */
            /* 'strstr(dFP,"/dir")' is meant as 'dFP =~ m(/dir\W)' */
    	    if (defaultFontPath && (
		(strcmp(*el, "freetype")  == 0 &&
		 strstr(defaultFontPath, "/TTF")) ||
    	        (strcmp(*el, "type1")  == 0 &&
		 strstr(defaultFontPath, "/Type1")))) 
	    	ptr->mod_load_lst = (XF86LoadPtr)xf86addListItem(
					(glp)ptr->mod_load_lst, (glp)module);
    	}
	xfree(elist);
    }

d545 1
a545 1
    ptr->mon_identifier = xf86confmalloc(19);
d553 30
a585 1
    int i = 0;
d593 1
a593 1
    ptr->mon_identifier = xf86confmalloc(19);
d596 1
a596 1
    ptr->mon_modelname = xf86confmalloc(12);
d621 1
a621 2
	     xf86confrealloc(ptr->mon_comment, 
			     len+strlen(displaySize_string)))) {
d628 2
a629 24
    for (i=0;i<4;i++) {
	switch (ConfiguredMonitor->det_mon[i].type) {
	    case DS_NAME:
		ptr->mon_modelname  = xf86confrealloc(ptr->mon_modelname, 
		  strlen((char*)(ConfiguredMonitor->det_mon[i].section.name))
		    + 1);
		strcpy(ptr->mon_modelname,
		       (char*)(ConfiguredMonitor->det_mon[i].section.name));
		break;
	    case DS_RANGES:
		ptr->mon_hsync[ptr->mon_n_hsync].lo =
		    ConfiguredMonitor->det_mon[i].section.ranges.min_h;
		ptr->mon_hsync[ptr->mon_n_hsync].hi =
		    ConfiguredMonitor->det_mon[i].section.ranges.max_h;
		ptr->mon_n_vrefresh = 1;
		ptr->mon_vrefresh[ptr->mon_n_hsync].lo =
		    ConfiguredMonitor->det_mon[i].section.ranges.min_v;
		ptr->mon_vrefresh[ptr->mon_n_hsync].hi =
		    ConfiguredMonitor->det_mon[i].section.ranges.max_v;
		ptr->mon_n_hsync++;
	    default:
		break;
	}
    }
a687 3
    /* Disable PCI devices */
    xf86ResourceBrokerInit();
    xf86AccessInit();
@


1.6
log
@missing action in if statement.
@
text
@a78 6
#elif defined(QNX4)
static char *DFLT_MOUSE_PROTO = "OSMouse";
static char *DFLT_MOUSE_DEV = "/dev/mouse";
#elif defined(__QNXNTO__)
static char *DFLT_MOUSE_PROTO = "OSMouse";
static char *DFLT_MOUSE_DEV = "/dev/devi/mouse0";
d99 1
a118 12
    case BUS_ISA:
	/*
	 * This needs to be revisited as it doesn't allow for non-PCI
	 * multihead.
	 */
	if (!xf86IsPrimaryIsa())
	    return NULL;
	isPrimary = TRUE;
	for (i = 0;  i < nDevToConfig;  i++)
	    if (!DevToConfig[i].pVideo)
		return NULL;
	break;
d167 1
a167 1
	    sprintf((char*)VendorName, "Unknown Vendor");
d172 1
a172 1
	    sprintf((char*)CardName, "Unknown Board");
d175 4
a178 3
	NewDevice.GDev.identifier =
	    xnfalloc(strlen(VendorName) + strlen(CardName) + 2);
	sprintf(NewDevice.GDev.identifier, "%s %s", VendorName, CardName);
d185 1
a185 1
	sprintf(NewDevice.GDev.busID, "PCI:%s:%d:%d",
d195 1
a195 5
    case BUS_ISA:
	NewDevice.GDev.identifier = "ISA Adapter";
	NewDevice.GDev.busID = "ISA";
	break;
#if (defined(__sparc__) || defined(__sparc))
d205 3
a207 2
	    NewDevice.GDev.busID = xnfalloc(strlen(promPath) + 6);
	    sprintf(NewDevice.GDev.busID, "SBUS:%s", promPath);
d211 1
a211 1
	    sprintf(NewDevice.GDev.busID, "SBUS:fb%d", NewDevice.sVideo->fbNum);
a230 11
/*
 * Backwards compatibility
 */
_X_EXPORT GDevPtr
xf86AddDeviceToConfigure(const char *driver, struct pci_device * pVideo, 
			 int chipset)
{
    return xf86AddBusDeviceToConfigure(driver, pVideo ? BUS_PCI : BUS_ISA,
				       pVideo, chipset);
}

d266 1
a266 2
    mouse = xf86confmalloc(sizeof(XF86ConfInputRec));
    memset((XF86ConfInputPtr)mouse,0,sizeof(XF86ConfInputRec));
d292 1
a292 1
    sprintf(ptr->scrn_identifier, "Screen%d", screennum);
d294 1
a294 1
    sprintf(ptr->scrn_monitor_str, "Monitor%d", screennum);
d296 1
a296 1
    sprintf(ptr->scrn_device_str, "Card%d", screennum);
d302 1
a302 2
	display = xf86confmalloc(sizeof(XF86ConfDisplayRec));
    	memset((XF86ConfDisplayPtr)display,0,sizeof(XF86ConfDisplayRec));
d346 1
a346 1
    sprintf(identifier, "Card%d", screennum);
d391 3
a393 2
		
		optname = xalloc(strlen(p->name) + 2 + 1);
d396 1
a396 1
		sprintf(optname, "\"%s\"", p->name);
d405 3
a407 2
		sprintf(p_e, "%s%-20s%s%s%s", prefix, optname, middle,
			opttype, suffix);
d459 1
a459 1
	sprintf(aptr->adj_screen_str, "Screen%d", scrnum);
d467 1
a467 1
	    sprintf(aptr->adj_refscreen, "Screen%d", scrnum - 1);
d505 1
a505 2
    	    module = xf86confmalloc(sizeof(XF86LoadRec));
    	    memset((XF86LoadPtr)module,0,sizeof(XF86LoadRec));
d519 1
a519 2
    	    module = xf86confmalloc(sizeof(XF86LoadRec));
    	    memset((XF86LoadPtr)module,0,sizeof(XF86LoadRec));
d557 1
a557 1
    sprintf(ptr->mon_identifier, "Monitor%d", screennum);
d576 1
a576 1
    sprintf(ptr->mon_identifier, "Monitor%d", screennum);
d579 1
a579 1
    sprintf(ptr->mon_modelname, "%x", ConfiguredMonitor->vendor.prod_id);
d643 4
d648 1
a648 1
DoConfigure()
d651 1
d653 2
a654 1
    char *filename = NULL;
d699 1
a699 5
    xf86config = malloc(sizeof(XF86ConfigRec));
    memset ((XF86ConfigPtr)xf86config, 0, sizeof(XF86ConfigRec));
    xf86config->conf_device_lst = NULL;
    xf86config->conf_screen_lst = NULL;
    xf86config->conf_monitor_lst = NULL;
d752 2
a753 1
    if (!(home = getenv("HOME")))
d755 7
a761 23
    {
#if !defined(PATH_MAX)
#define PATH_MAX 1024
#endif
        const char* configfile = XF86CONFIGFILE".new";
    	char homebuf[PATH_MAX];
    	/* getenv might return R/O memory, as with OS/2 */
    	strncpy(homebuf,home,PATH_MAX-1);
    	homebuf[PATH_MAX-1] = '\0';
    	home = homebuf;
    	if (!(filename =
	     (char *)xalloc(strlen(home) + 
	  			 strlen(configfile) + 3)))
		goto bail;

      	if (home[0] == '/' && home[1] == '\0')
            home[0] = '\0';
#ifndef QNX4
	sprintf(filename, "%s/%s", home,configfile);
#else
	sprintf(filename, "//%d%s/%s", getnid(),home,configfile);
#endif
	
d764 8
a771 1
    xf86writeConfigFile(filename, xf86config);
d867 5
a871 1
    xf86writeConfigFile(filename, xf86config);
@


1.5
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d797 1
@


1.4
log
@Make -configure work for SBus/UPA devices instead of crashing.

ok matthieu@@
@
text
@d38 2
a45 1
#include "xf86PciData.h"
d52 1
a52 1
#if defined(__sparc__) || defined(__sparc)
d60 2
a61 2
    pciVideoPtr pVideo;
#if defined(__sparc__) || defined(__sparc)
d105 1
a105 1
    pciVideoPtr pVideo = NULL;
d114 1
a114 1
	pVideo = (pciVideoPtr) busData;
d117 1
d119 1
a119 1
		(DevToConfig[i].pVideo->device == pVideo->device) &&
d136 1
a136 1
#if defined(__sparc__) || defined(__sparc)
d178 3
a180 3
	xf86FindPciNamesByDevice(pVideo->vendor, pVideo->chipType,
				 NOVENDOR, NOSUBSYS,
				 &VendorName, &CardName, NULL, NULL);
d202 1
a202 1
	    busnum, pVideo->device, pVideo->func);
d204 2
a205 2
	NewDevice.GDev.chipID = pVideo->chipType;
	NewDevice.GDev.chipRev = pVideo->chipRev;
d208 1
a208 1
	    chipset = (pVideo->vendor << 16) | pVideo->chipType;
d215 1
a215 1
#if defined(__sparc__) || defined(__sparc)
d254 2
a255 1
xf86AddDeviceToConfigure(const char *driver, pciVideoPtr pVideo, int chipset)
a374 3
#ifdef DO_FBDEV_PROBE
    Bool foundFBDEV = FALSE;
#endif
a442 26
#ifdef DO_FBDEV_PROBE
    /* Crude mechanism to auto-detect fbdev (os dependent) */
    /* Skip it for now. Options list it anyway, and we can't
     * determine which screen/driver this belongs too anyway. */
    {
	int fd;

	fd = open("/dev/fb0", 0);
	if (fd != -1) {
	    foundFBDEV = TRUE;
	    close(fd);
	}
    }

    if (foundFBDEV) {
	XF86OptionPtr fbdev;

    	fbdev = xf86confmalloc(sizeof(XF86OptionRec));
    	memset((XF86OptionPtr)fbdev,0,sizeof(XF86OptionRec));
    	fbdev->opt_name = "UseFBDev";
	fbdev->opt_val = "ON";
	ptr->dev_option_lst = (XF86OptionPtr)xf86addListItem(
					(glp)ptr->dev_option_lst, (glp)fbdev);
    }
#endif

a578 2
   if (rgbPath)
       ptr->file_rgbpath = strdup(rgbPath);
d734 3
a736 1
	
d738 2
a739 4
	    if (!xf86DriverList[CurrentDriver]->driverFunc
		|| !xf86DriverList[CurrentDriver]->driverFunc(NULL,
						GET_REQUIRED_HW_INTERFACES,
						&flags)
d744 4
a747 6
	if (xf86DriverList[CurrentDriver]->Probe == NULL) continue;

	if ((*xf86DriverList[CurrentDriver]->Probe)(
	    xf86DriverList[CurrentDriver], PROBE_DETECT) &&
	    xf86DriverList[CurrentDriver]->Identify)
	    (*xf86DriverList[CurrentDriver]->Identify)(0);
d795 1
a795 1
	     (char *)ALLOCATE_LOCAL(strlen(home) + 
d833 1
a833 1
	    (*xf86DriverList[i]->Probe)(xf86DriverList[i], 0);
a860 1
	    xf86SetPciVideo(NULL,NONE);
@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@d51 1
a51 1
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
d60 1
a60 1
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
d134 1
a134 1
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
d213 1
a213 1
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
@


1.2
log
@Clean up sockets after Xorg -configure.
@
text
@d51 1
a51 1
#if defined(__sparc__) && !defined(__OpenBSD__)
d60 1
a60 1
#if defined(__sparc__) && !defined(__OpenBSD__)
d71 1
a71 1
Bool foundMouse = FALSE;
d73 1
a73 4
#if defined(__UNIXOS2__)
#define DFLT_MOUSE_DEV "mouse$"
#define DFLT_MOUSE_PROTO "OS2Mouse"
#elif defined(__SCO__)
d76 1
a76 1
static char *DFLT_MOUSE_PROTO = "Xqueue";
d134 1
a134 1
#if defined(__sparc__) && !defined(__OpenBSD__)
d213 1
a213 1
#if defined(__sparc__) && !defined(__OpenBSD__)
a264 3
#ifdef USE_DEPRECATED_KEYBOARD_DRIVER
    ptr->inp_driver = "keyboard";
#else
a265 1
#endif
a270 11
#if 0 && defined linux
	/* Our autodetection code can do a better job */
	int len;
	char path[32];

	if ((len = readlink(DFLT_MOUSE_DEV, path, sizeof(path) - 1)) > 0) {
	    path[len] = '\0';
	    if (strstr(path, "psaux") != NULL)
		DFLT_MOUSE_PROTO = "PS/2";
	}
#endif
d298 2
a299 1
		xf86addNewOption(mouse->inp_option_lst, "Protocol", DFLT_MOUSE_PROTO);
d302 2
a303 1
		xf86addNewOption(mouse->inp_option_lst, "Device", DFLT_MOUSE_DEV);
d306 2
a307 1
		xf86addNewOption(mouse->inp_option_lst, "ZAxisMapping", "4 5 6 7");
a311 23
static XF86ConfDRIPtr
configureDRISection (void)
{
#ifdef NOTYET
    parsePrologue (XF86ConfDRIPtr, XF86ConfDRIRec)

    return ptr;
#else
    return NULL;
#endif
}

static XF86ConfVendorPtr
configureVendorSection (void)
{
    parsePrologue (XF86ConfVendorPtr, XF86ConfVendorRec)

    return NULL;
#if 0
    return ptr;
#endif
}

d488 1
a488 1
		xf86addNewOption (iptr->iref_option_lst, "CorePointer", NULL);
d501 1
a501 1
		xf86addNewOption (iptr->iref_option_lst, "CoreKeyboard", NULL);
a532 23
static XF86ConfModesPtr
configureModesSection (void)
{
#ifdef NOTYET
    parsePrologue (XF86ConfModesPtr, XF86ConfModesRec)

    return ptr;
#else
    return NULL;
#endif
}

static XF86ConfVideoAdaptorPtr
configureVideoAdaptorSection (void)
{
    parsePrologue (XF86ConfVideoAdaptorPtr, XF86ConfVideoAdaptorRec)

    return NULL;
#if 0
    return ptr;
#endif
}

d697 1
a697 1
      ptr->mon_option_lst = xf86addNewOption(ptr->mon_option_lst, "DPMS", NULL);
d805 4
a808 4
    xf86config->conf_videoadaptor_lst = configureVideoAdaptorSection();
    xf86config->conf_modes_lst = configureModesSection();
    xf86config->conf_vendor_lst = configureVendorSection();
    xf86config->conf_dri = configureDRISection();
a814 3
#ifdef __UNIXOS2__
#define PATH_MAX 2048
#endif
a949 1
#ifndef __UNIXOS2__  /* OS/2 definitely has a mouse */
a954 1
#endif
@


1.1
log
@Initial revision
@
text
@d1033 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d51 1
a51 1
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
d60 1
a60 1
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
d71 1
a71 1
static Bool foundMouse = FALSE;
d73 4
a76 1
#if defined(__SCO__)
d79 1
a79 1
static char *DFLT_MOUSE_PROTO = "OSMouse";
d137 1
a137 1
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
d216 1
a216 1
#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
d268 3
d272 1
d278 11
d316 1
a316 2
		xf86addNewOption(mouse->inp_option_lst, xstrdup("Protocol"),
				xstrdup(DFLT_MOUSE_PROTO));
d319 1
a319 2
		xf86addNewOption(mouse->inp_option_lst, xstrdup("Device"),
				xstrdup(DFLT_MOUSE_DEV));
d322 1
a322 2
		xf86addNewOption(mouse->inp_option_lst, xstrdup("ZAxisMapping"),
				xstrdup("4 5 6 7"));
d327 23
d526 1
a526 1
		xf86addNewOption (iptr->iref_option_lst, xstrdup("CorePointer"), NULL);
d539 1
a539 1
		xf86addNewOption (iptr->iref_option_lst, xstrdup("CoreKeyboard"), NULL);
d571 23
d758 1
a758 1
      ptr->mon_option_lst = xf86addNewOption(ptr->mon_option_lst, xstrdup("DPMS"), NULL);
d866 4
a869 4
    xf86config->conf_videoadaptor_lst = NULL;
    xf86config->conf_modes_lst = NULL;
    xf86config->conf_vendor_lst = NULL;
    xf86config->conf_dri = NULL;
d876 3
d1014 1
d1020 1
@

