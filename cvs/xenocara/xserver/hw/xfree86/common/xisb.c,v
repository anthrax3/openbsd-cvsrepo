head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.18
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.16
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.14
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.12
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.31;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.09;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.09;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.40;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@/*
 * Copyright (c) 1997  Metro Link Incorporated
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the Metro Link shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from Metro Link.
 *
 */

/*
	X Input Serial Buffer routines for use in any XInput driver that accesses
	a serial device.
*/

/*****************************************************************************
 *	Standard Headers
 ****************************************************************************/

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <misc.h>
#include <xf86.h>
#include <xf86_OSproc.h>
#include <xf86_OSlib.h>
#include <xf86Xinput.h>
#include "xisb.h"

/*****************************************************************************
 *	Local Headers
 ****************************************************************************/

/*****************************************************************************
 *	Variables without includable headers
 ****************************************************************************/

/*****************************************************************************
 *	Local Variables
 ****************************************************************************/

/*****************************************************************************
 *	Function Definitions
 ****************************************************************************/

XISBuffer *
XisbNew(int fd, ssize_t size)
{
    XISBuffer *b;

    b = malloc(sizeof(XISBuffer));
    if (!b)
        return NULL;
    b->buf = malloc((sizeof(unsigned char) * size));
    if (!b->buf) {
        free(b);
        return NULL;
    }

    b->fd = fd;
    b->trace = 0;
    b->block_duration = 0;
    b->current = 1;             /* force it to be past the end to trigger initial read */
    b->end = 0;
    b->buffer_size = size;
    return b;
}

void
XisbFree(XISBuffer * b)
{
    free(b->buf);
    free(b);
}

int
XisbRead(XISBuffer * b)
{
    int ret;

    if (b->current >= b->end) {
        if (b->block_duration >= 0) {
            if (xf86WaitForInput(b->fd, b->block_duration) < 1)
                return -1;
        }
        else {
            /*
             * automatically clear it so if XisbRead is called in a loop
             * the next call will make sure there is data with select and
             * thus prevent a blocking read
             */
            b->block_duration = 0;
        }

        ret = xf86ReadSerial(b->fd, b->buf, b->buffer_size);
        switch (ret) {
        case 0:
            return -1;          /* timeout */
        case -1:
            return -2;          /* error */
        default:
            b->end = ret;
            b->current = 0;
            break;
        }
    }
    if (b->trace)
        ErrorF("read 0x%02x (%c)\n", b->buf[b->current],
               isprint(b->buf[b->current]) ? b->buf[b->current] : '.');

    return b->buf[b->current++];
}

/* the only purpose of this function is to provide output tracing */
ssize_t
XisbWrite(XISBuffer * b, unsigned char *msg, ssize_t len)
{
    if (b->trace) {
        int i = 0;

        for (i = 0; i < len; i++)
            ErrorF("\t\twrote 0x%02x (%c)\n", msg[i], msg[i]);
    }
    return (xf86WriteSerial(b->fd, msg, len));
}

/* turn tracing of this buffer on (1) or off (0) */
void
XisbTrace(XISBuffer * b, int trace)
{
    b->trace = trace;
}

/*
 * specify a block_duration of -1 when you know the buffer's fd is ready to
 * read. After a read, it is automatically set to 0 so that the next read
 * will use check to select for data and prevent a block.
 * It is the caller's responsibility to set the block_duration to -1 if it
 * knows that there is data to read (because the main select loop triggered
 * the read) and want's to avoid the unnecessary overhead of the select call
 *
 * a zero or positive block duration will cause the select to block for the
 * give duration in usecs.
 */

void
XisbBlockDuration(XISBuffer * b, int block_duration)
{
    b->block_duration = block_duration;
}
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a32 1

d65 1
a65 1
XisbNew (int fd, ssize_t size)
d67 10
a76 1
	XISBuffer *b;
d78 7
a84 17
	b = malloc(sizeof (XISBuffer));
	if (!b)
		return NULL;
	b->buf = malloc((sizeof (unsigned char) * size));
	if (!b->buf)
	{
		free(b);
		return NULL;
	}

	b->fd = fd;
	b->trace = 0;
	b->block_duration = 0;
	b->current = 1;	/* force it to be past the end to trigger initial read */
	b->end = 0;
	b->buffer_size = size;
	return b;
d88 1
a88 1
XisbFree (XISBuffer *b)
d90 2
a91 2
	free(b->buf);
	free(b);
d95 1
a95 1
XisbRead (XISBuffer *b)
d97 1
a97 1
	int ret;
d99 29
a127 33
	if (b->current >= b->end)
	{
		if (b->block_duration >= 0)
		{
			if (xf86WaitForInput (b->fd, b->block_duration) < 1)
				return -1;
		}
		else
		{
			/*
			 * automatically clear it so if XisbRead is called in a loop
			 * the next call will make sure there is data with select and
			 * thus prevent a blocking read
			 */
			b->block_duration = 0;
		}
		
		ret = xf86ReadSerial (b->fd, b->buf, b->buffer_size);
		switch (ret)
		{
			case 0:
				return -1; /* timeout */
			case -1:
				return -2; /* error */
			default:
				b->end = ret;
				b->current = 0;
				break;
		}
	}
	if (b->trace)
		ErrorF ("read 0x%02x (%c)\n", b->buf[b->current], 
			isprint(b->buf[b->current])?b->buf[b->current]:'.');
d129 1
a129 1
	return b->buf[b->current++];
d134 1
a134 1
XisbWrite (XISBuffer *b, unsigned char *msg, ssize_t len)
d136 1
a136 2
    if (b->trace)
    {
d138 1
d140 1
a140 1
            ErrorF ("\t\twrote 0x%02x (%c)\n", msg[i], msg[i]);
d142 1
a142 1
    return (xf86WriteSerial (b->fd, msg, len));
d147 1
a147 1
XisbTrace (XISBuffer *b, int trace)
d149 1
a149 1
	b->trace = trace;
d165 1
a165 1
XisbBlockDuration (XISBuffer *b, int block_duration)
d167 1
a167 1
	b->block_duration = block_duration;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d70 1
a70 1
	b = xalloc (sizeof (XISBuffer));
d72 2
a73 2
		return (NULL);
	b->buf = xalloc ((sizeof (unsigned char) * size));
d76 2
a77 2
		xfree (b);
		return (NULL);
d86 1
a86 1
	return (b);
d92 2
a93 2
	xfree (b->buf);
	xfree (b);
d106 1
a106 1
				return (-1);
d122 1
a122 1
				return (-1); /* timeout */
d124 1
a124 1
				return (-2); /* error */
d135 1
a135 1
	return (b->buf[b->current++]);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d65 1
a65 1
_X_EXPORT XISBuffer *
d89 1
a89 1
_X_EXPORT void
d96 1
a96 1
_X_EXPORT int
d139 1
a139 1
_X_EXPORT ssize_t
d152 1
a152 1
_X_EXPORT void
d170 1
a170 1
_X_EXPORT void
@


1.1
log
@Initial revision
@
text
@a41 4
#ifdef __UNIXOS2__
#define I_NEED_OS2_H
#endif

a43 1
#include <xf86Version.h>
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d42 4
@

