head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.2
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.4
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.6.0.2
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	s0SI41sEunLdyFfd;

1.16
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	Te1daavkBLskZ8gc;

1.15
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	cVXoV5PxI8YrEaVA;

1.14
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.01.21.12.42;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.28.14.21.35;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.24.19.04.03;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.03.20.57.39;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.17;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Thomas Roell not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Thomas Roell makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * THOMAS ROELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THOMAS ROELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */
/*
 * Copyright (c) 1994-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifndef _COMPILER_H

#define _COMPILER_H

#if defined(__SUNPRO_C)
#define DO_PROTOTYPES
#endif

/* Map Sun compiler platform defines to gcc-style used in the code */
#if defined(__amd64) && !defined(__amd64__)
#define __amd64__
#endif
#if defined(__i386) && !defined(__i386__)
#define __i386__
#endif
#if defined(__sparc) && !defined(__sparc__)
#define __sparc__
#endif
#if defined(__sparcv9) && !defined(__sparc64__)
#define __sparc64__
#endif

#ifndef _X_EXPORT
#include <X11/Xfuncproto.h>
#endif

#include <pixman.h>             /* for uint*_t types */

/* Allow drivers to use the GCC-supported __inline__ and/or __inline. */
#ifndef __inline__
#if defined(__GNUC__)
    /* gcc has __inline__ */
#else
#define __inline__ /**/
#endif
#endif                          /* __inline__ */
#ifndef __inline
#if defined(__GNUC__)
    /* gcc has __inline */
#else
#define __inline /**/
#endif
#endif                          /* __inline */
/* Support gcc's __FUNCTION__ for people using other compilers */
#if !defined(__GNUC__) && !defined(__FUNCTION__)
#define __FUNCTION__ __func__   /* C99 */
#endif

#if defined(DO_PROTOTYPES)
#if !defined(__arm__)
#if !defined(__sparc__) && !defined(__arm32__) && !defined(__nds32__) \
      && !(defined(__alpha__) && defined(linux)) \
      && !(defined(__ia64__) && defined(linux)) \
      && !(defined(__mips64) && defined(linux)) \

extern _X_EXPORT void outb(unsigned short, unsigned char);
extern _X_EXPORT void outw(unsigned short, unsigned short);
extern _X_EXPORT void outl(unsigned short, unsigned int);
extern _X_EXPORT unsigned int inb(unsigned short);
extern _X_EXPORT unsigned int inw(unsigned short);
extern _X_EXPORT unsigned int inl(unsigned short);

#else                           /* __sparc__,  __arm32__, __alpha__, __nds32__ */
extern _X_EXPORT void outb(unsigned long, unsigned char);
extern _X_EXPORT void outw(unsigned long, unsigned short);
extern _X_EXPORT void outl(unsigned long, unsigned int);
extern _X_EXPORT unsigned int inb(unsigned long);
extern _X_EXPORT unsigned int inw(unsigned long);
extern _X_EXPORT unsigned int inl(unsigned long);

#ifdef __SUNPRO_C
extern _X_EXPORT unsigned char  xf86ReadMmio8    (void *, unsigned long);
extern _X_EXPORT unsigned short xf86ReadMmio16Be (void *, unsigned long);
extern _X_EXPORT unsigned short xf86ReadMmio16Le (void *, unsigned long);
extern _X_EXPORT unsigned int   xf86ReadMmio32Be (void *, unsigned long);
extern _X_EXPORT unsigned int   xf86ReadMmio32Le (void *, unsigned long);
extern _X_EXPORT void xf86WriteMmio8    (void *, unsigned long, unsigned int);
extern _X_EXPORT void xf86WriteMmio16Be (void *, unsigned long, unsigned int);
extern _X_EXPORT void xf86WriteMmio16Le (void *, unsigned long, unsigned int);
extern _X_EXPORT void xf86WriteMmio32Be (void *, unsigned long, unsigned int);
extern _X_EXPORT void xf86WriteMmio32Le (void *, unsigned long, unsigned int);
#endif                          /* _SUNPRO_C */
#endif                          /* __sparc__,  __arm32__, __alpha__, __nds32__ */
#endif                          /* __arm__ */

#endif                          /* NO_INLINE || DO_PROTOTYPES */

#ifdef __GNUC__
#ifdef __i386__

#ifdef __SSE__
#define write_mem_barrier() __asm__ __volatile__ ("sfence" : : : "memory")
#else
#define write_mem_barrier() __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory")
#endif

#ifdef __SSE2__
#define mem_barrier() __asm__ __volatile__ ("mfence" : : : "memory")
#else
#define mem_barrier() __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory")
#endif

#elif defined __alpha__

#define mem_barrier() __asm__ __volatile__ ("mb" : : : "memory")
#define write_mem_barrier() __asm__ __volatile__ ("wmb" : : : "memory")

#elif defined __amd64__

#define mem_barrier() __asm__ __volatile__ ("mfence" : : : "memory")
#define write_mem_barrier() __asm__ __volatile__ ("sfence" : : : "memory")

#elif defined __ia64__

#ifndef __INTEL_COMPILER
#define mem_barrier()        __asm__ __volatile__ ("mf" : : : "memory")
#define write_mem_barrier()  __asm__ __volatile__ ("mf" : : : "memory")
#else
#include "ia64intrin.h"
#define mem_barrier() __mf()
#define write_mem_barrier() __mf()
#endif

#elif defined __mips__
     /* Note: sync instruction requires MIPS II instruction set */
#define mem_barrier()		\
	__asm__ __volatile__(		\
		".set   push\n\t"	\
		".set   noreorder\n\t"	\
		".set   mips2\n\t"	\
		"sync\n\t"		\
		".set   pop"		\
		: /* no output */	\
		: /* no input */	\
		: "memory")
#define write_mem_barrier() mem_barrier()

#elif defined __powerpc__

#ifndef eieio
#define eieio() __asm__ __volatile__ ("eieio" ::: "memory")
#endif                          /* eieio */
#define mem_barrier()	eieio()
#define write_mem_barrier()	eieio()

#elif defined __sparc__

#define barrier() __asm__ __volatile__ (".word 0x8143e00a" : : : "memory")
#define mem_barrier()           /* XXX: nop for now */
#define write_mem_barrier()     /* XXX: nop for now */
#endif
#endif                          /* __GNUC__ */

#ifndef barrier
#define barrier()
#endif

#ifndef mem_barrier
#define mem_barrier()           /* NOP */
#endif

#ifndef write_mem_barrier
#define write_mem_barrier()     /* NOP */
#endif

#ifdef __GNUC__
#if defined(__alpha__)

#ifdef linux
/* for Linux on Alpha, we use the LIBC _inx/_outx routines */
/* note that the appropriate setup via "ioperm" needs to be done */
/*  *before* any inx/outx is done. */

extern _X_EXPORT void _outb(unsigned char val, unsigned long port);
extern _X_EXPORT void _outw(unsigned short val, unsigned long port);
extern _X_EXPORT void _outl(unsigned int val, unsigned long port);
extern _X_EXPORT unsigned int _inb(unsigned long port);
extern _X_EXPORT unsigned int _inw(unsigned long port);
extern _X_EXPORT unsigned int _inl(unsigned long port);

static __inline__ void
outb(unsigned long port, unsigned char val)
{
    _outb(val, port);
}

static __inline__ void
outw(unsigned long port, unsigned short val)
{
    _outw(val, port);
}

static __inline__ void
outl(unsigned long port, unsigned int val)
{
    _outl(val, port);
}

static __inline__ unsigned int
inb(unsigned long port)
{
    return _inb(port);
}

static __inline__ unsigned int
inw(unsigned long port)
{
    return _inw(port);
}

static __inline__ unsigned int
inl(unsigned long port)
{
    return _inl(port);
}

#endif                          /* linux */

#if (defined(__FreeBSD__) || defined(__OpenBSD__)) \
      && !defined(DO_PROTOTYPES)

/* for FreeBSD and OpenBSD on Alpha, we use the libio (resp. libalpha) */
/*  inx/outx routines */
/* note that the appropriate setup via "ioperm" needs to be done */
/*  *before* any inx/outx is done. */

extern _X_EXPORT void outb(unsigned int port, unsigned char val);
extern _X_EXPORT void outw(unsigned int port, unsigned short val);
extern _X_EXPORT void outl(unsigned int port, unsigned int val);
extern _X_EXPORT unsigned char inb(unsigned int port);
extern _X_EXPORT unsigned short inw(unsigned int port);
extern _X_EXPORT unsigned int inl(unsigned int port);

#endif                          /* (__FreeBSD__ || __OpenBSD__ ) && !DO_PROTOTYPES */

#if defined(__NetBSD__)
#include <machine/pio.h>
#endif                          /* __NetBSD__ */

#elif defined(__amd64__) || defined(__i386__) || defined(__ia64__)

#include <inttypes.h>

static __inline__ void
outb(unsigned short port, unsigned char val)
{
    __asm__ __volatile__("outb %0,%1"::"a"(val), "d"(port));
}

static __inline__ void
outw(unsigned short port, unsigned short val)
{
    __asm__ __volatile__("outw %0,%1"::"a"(val), "d"(port));
}

static __inline__ void
outl(unsigned short port, unsigned int val)
{
    __asm__ __volatile__("outl %0,%1"::"a"(val), "d"(port));
}

static __inline__ unsigned int
inb(unsigned short port)
{
    unsigned char ret;
    __asm__ __volatile__("inb %1,%0":"=a"(ret):"d"(port));

    return ret;
}

static __inline__ unsigned int
inw(unsigned short port)
{
    unsigned short ret;
    __asm__ __volatile__("inw %1,%0":"=a"(ret):"d"(port));

    return ret;
}

static __inline__ unsigned int
inl(unsigned short port)
{
    unsigned int ret;
    __asm__ __volatile__("inl %1,%0":"=a"(ret):"d"(port));

    return ret;
}

#elif defined(__sparc__)

#ifndef ASI_PL
#define ASI_PL 0x88
#endif

static __inline__ void
outb(unsigned long port, unsigned char val)
{
    __asm__ __volatile__("stba %0, [%1] %2":    /* No outputs */
                         :"r"(val), "r"(port), "i"(ASI_PL));

    barrier();
}

static __inline__ void
outw(unsigned long port, unsigned short val)
{
    __asm__ __volatile__("stha %0, [%1] %2":    /* No outputs */
                         :"r"(val), "r"(port), "i"(ASI_PL));

    barrier();
}

static __inline__ void
outl(unsigned long port, unsigned int val)
{
    __asm__ __volatile__("sta %0, [%1] %2":     /* No outputs */
                         :"r"(val), "r"(port), "i"(ASI_PL));

    barrier();
}

static __inline__ unsigned int
inb(unsigned long port)
{
    unsigned int ret;
    __asm__ __volatile__("lduba [%1] %2, %0":"=r"(ret)
                         :"r"(port), "i"(ASI_PL));

    return ret;
}

static __inline__ unsigned int
inw(unsigned long port)
{
    unsigned int ret;
    __asm__ __volatile__("lduha [%1] %2, %0":"=r"(ret)
                         :"r"(port), "i"(ASI_PL));

    return ret;
}

static __inline__ unsigned int
inl(unsigned long port)
{
    unsigned int ret;
    __asm__ __volatile__("lda [%1] %2, %0":"=r"(ret)
                         :"r"(port), "i"(ASI_PL));

    return ret;
}

static __inline__ unsigned char
xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
{
    unsigned long addr = ((unsigned long) base) + offset;
    unsigned char ret;

    __asm__ __volatile__("lduba [%1] %2, %0":"=r"(ret)
                         :"r"(addr), "i"(ASI_PL));

    return ret;
}

static __inline__ unsigned short
xf86ReadMmio16Be(__volatile__ void *base, const unsigned long offset)
{
    unsigned long addr = ((unsigned long) base) + offset;
    unsigned short ret;

    __asm__ __volatile__("lduh [%1], %0":"=r"(ret)
                         :"r"(addr));

    return ret;
}

static __inline__ unsigned short
xf86ReadMmio16Le(__volatile__ void *base, const unsigned long offset)
{
    unsigned long addr = ((unsigned long) base) + offset;
    unsigned short ret;

    __asm__ __volatile__("lduha [%1] %2, %0":"=r"(ret)
                         :"r"(addr), "i"(ASI_PL));

    return ret;
}

static __inline__ unsigned int
xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
{
    unsigned long addr = ((unsigned long) base) + offset;
    unsigned int ret;

    __asm__ __volatile__("ld [%1], %0":"=r"(ret)
                         :"r"(addr));

    return ret;
}

static __inline__ unsigned int
xf86ReadMmio32Le(__volatile__ void *base, const unsigned long offset)
{
    unsigned long addr = ((unsigned long) base) + offset;
    unsigned int ret;

    __asm__ __volatile__("lda [%1] %2, %0":"=r"(ret)
                         :"r"(addr), "i"(ASI_PL));

    return ret;
}

static __inline__ void
xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
               const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("stba %0, [%1] %2":    /* No outputs */
                         :"r"(val), "r"(addr), "i"(ASI_PL));

    barrier();
}

static __inline__ void
xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("sth %0, [%1]":        /* No outputs */
                         :"r"(val), "r"(addr));

    barrier();
}

static __inline__ void
xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("stha %0, [%1] %2":    /* No outputs */
                         :"r"(val), "r"(addr), "i"(ASI_PL));

    barrier();
}

static __inline__ void
xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("st %0, [%1]": /* No outputs */
                         :"r"(val), "r"(addr));

    barrier();
}

static __inline__ void
xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("sta %0, [%1] %2":     /* No outputs */
                         :"r"(val), "r"(addr), "i"(ASI_PL));

    barrier();
}

#elif defined(__mips__) || (defined(__arm32__) && !defined(__linux__))
#if defined(__arm32__) || defined(__mips64__)
#define PORT_SIZE long
#else
#define PORT_SIZE short
#endif

_X_EXPORT unsigned int IOPortBase;      /* Memory mapped I/O port area */

static __inline__ void
outb(unsigned PORT_SIZE port, unsigned char val)
{
    *(volatile unsigned char *) (((unsigned PORT_SIZE) (port)) + IOPortBase) =
        val;
}

static __inline__ void
outw(unsigned PORT_SIZE port, unsigned short val)
{
    *(volatile unsigned short *) (((unsigned PORT_SIZE) (port)) + IOPortBase) =
        val;
}

static __inline__ void
outl(unsigned PORT_SIZE port, unsigned int val)
{
    *(volatile unsigned int *) (((unsigned PORT_SIZE) (port)) + IOPortBase) =
        val;
}

static __inline__ unsigned int
inb(unsigned PORT_SIZE port)
{
    return *(volatile unsigned char *) (((unsigned PORT_SIZE) (port)) +
                                        IOPortBase);
}

static __inline__ unsigned int
inw(unsigned PORT_SIZE port)
{
    return *(volatile unsigned short *) (((unsigned PORT_SIZE) (port)) +
                                         IOPortBase);
}

static __inline__ unsigned int
inl(unsigned PORT_SIZE port)
{
    return *(volatile unsigned int *) (((unsigned PORT_SIZE) (port)) +
                                       IOPortBase);
}

#if defined(__mips__)
#ifdef linux                    /* don't mess with other OSs */
#if X_BYTE_ORDER == X_BIG_ENDIAN
static __inline__ unsigned int
xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
{
    unsigned long addr = ((unsigned long) base) + offset;
    unsigned int ret;

    __asm__ __volatile__("lw %0, 0(%1)":"=r"(ret)
                         :"r"(addr));

    return ret;
}

static __inline__ void
xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("sw %0, 0(%1)":        /* No outputs */
                         :"r"(val), "r"(addr));
}
#endif
#endif                          /* !linux */
#endif                          /* __mips__ */

#elif defined(__powerpc__)

#ifndef MAP_FAILED
#define MAP_FAILED ((void *)-1)
#endif

extern _X_EXPORT volatile unsigned char *ioBase;

static __inline__ unsigned char
xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
{
    register unsigned char val;
    __asm__ __volatile__("lbzx %0,%1,%2\n\t" "eieio":"=r"(val)
                         :"b"(base), "r"(offset),
                         "m"(*((volatile unsigned char *) base + offset)));
    return val;
}

static __inline__ unsigned short
xf86ReadMmio16Be(__volatile__ void *base, const unsigned long offset)
{
    register unsigned short val;
    __asm__ __volatile__("lhzx %0,%1,%2\n\t" "eieio":"=r"(val)
                         :"b"(base), "r"(offset),
                         "m"(*((volatile unsigned char *) base + offset)));
    return val;
}

static __inline__ unsigned short
xf86ReadMmio16Le(__volatile__ void *base, const unsigned long offset)
{
    register unsigned short val;
    __asm__ __volatile__("lhbrx %0,%1,%2\n\t" "eieio":"=r"(val)
                         :"b"(base), "r"(offset),
                         "m"(*((volatile unsigned char *) base + offset)));
    return val;
}

static __inline__ unsigned int
xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
{
    register unsigned int val;
    __asm__ __volatile__("lwzx %0,%1,%2\n\t" "eieio":"=r"(val)
                         :"b"(base), "r"(offset),
                         "m"(*((volatile unsigned char *) base + offset)));
    return val;
}

static __inline__ unsigned int
xf86ReadMmio32Le(__volatile__ void *base, const unsigned long offset)
{
    register unsigned int val;
    __asm__ __volatile__("lwbrx %0,%1,%2\n\t" "eieio":"=r"(val)
                         :"b"(base), "r"(offset),
                         "m"(*((volatile unsigned char *) base + offset)));
    return val;
}

static __inline__ void
xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
               const unsigned char val)
{
    __asm__
        __volatile__("stbx %1,%2,%3\n\t":"=m"
                     (*((volatile unsigned char *) base + offset))
                     :"r"(val), "b"(base), "r"(offset));
    eieio();
}

static __inline__ void
xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
                  const unsigned short val)
{
    __asm__
        __volatile__("sthbrx %1,%2,%3\n\t":"=m"
                     (*((volatile unsigned char *) base + offset))
                     :"r"(val), "b"(base), "r"(offset));
    eieio();
}

static __inline__ void
xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
                  const unsigned short val)
{
    __asm__
        __volatile__("sthx %1,%2,%3\n\t":"=m"
                     (*((volatile unsigned char *) base + offset))
                     :"r"(val), "b"(base), "r"(offset));
    eieio();
}

static __inline__ void
xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    __asm__
        __volatile__("stwbrx %1,%2,%3\n\t":"=m"
                     (*((volatile unsigned char *) base + offset))
                     :"r"(val), "b"(base), "r"(offset));
    eieio();
}

static __inline__ void
xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    __asm__
        __volatile__("stwx %1,%2,%3\n\t":"=m"
                     (*((volatile unsigned char *) base + offset))
                     :"r"(val), "b"(base), "r"(offset));
    eieio();
}

static __inline__ void
outb(unsigned short port, unsigned char value)
{
    if (ioBase == MAP_FAILED)
        return;
    xf86WriteMmio8((void *) ioBase, port, value);
}

static __inline__ void
outw(unsigned short port, unsigned short value)
{
    if (ioBase == MAP_FAILED)
        return;
    xf86WriteMmio16Le((void *) ioBase, port, value);
}

static __inline__ void
outl(unsigned short port, unsigned int value)
{
    if (ioBase == MAP_FAILED)
        return;
    xf86WriteMmio32Le((void *) ioBase, port, value);
}

static __inline__ unsigned int
inb(unsigned short port)
{
    if (ioBase == MAP_FAILED)
        return 0;
    return xf86ReadMmio8((void *) ioBase, port);
}

static __inline__ unsigned int
inw(unsigned short port)
{
    if (ioBase == MAP_FAILED)
        return 0;
    return xf86ReadMmio16Le((void *) ioBase, port);
}

static __inline__ unsigned int
inl(unsigned short port)
{
    if (ioBase == MAP_FAILED)
        return 0;
    return xf86ReadMmio32Le((void *) ioBase, port);
}

#elif defined(__arm__) && defined(__linux__)

/* for Linux on ARM, we use the LIBC inx/outx routines */
/* note that the appropriate setup via "ioperm" needs to be done */
/*  *before* any inx/outx is done. */

#include <sys/io.h>

static __inline__ void
xf_outb(unsigned short port, unsigned char val)
{
    outb(val, port);
}

static __inline__ void
xf_outw(unsigned short port, unsigned short val)
{
    outw(val, port);
}

static __inline__ void
xf_outl(unsigned short port, unsigned int val)
{
    outl(val, port);
}

#define outb xf_outb
#define outw xf_outw
#define outl xf_outl

#elif defined(__nds32__)

/*
 * Assume all port access are aligned.  We need to revise this implementation
 * if there is unaligned port access.
 */

#define PORT_SIZE long

static __inline__ unsigned char
xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
{
    return *(volatile unsigned char *) ((unsigned char *) base + offset);
}

static __inline__ void
xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
               const unsigned int val)
{
    *(volatile unsigned char *) ((unsigned char *) base + offset) = val;
    barrier();
}

static __inline__ unsigned short
xf86ReadMmio16Swap(__volatile__ void *base, const unsigned long offset)
{
    unsigned long addr = ((unsigned long) base) + offset;
    unsigned short ret;

    __asm__ __volatile__("lhi %0, [%1];\n\t" "wsbh %0, %0;\n\t":"=r"(ret)
                         :"r"(addr));

    return ret;
}

static __inline__ unsigned short
xf86ReadMmio16(__volatile__ void *base, const unsigned long offset)
{
    return *(volatile unsigned short *) ((char *) base + offset);
}

static __inline__ void
xf86WriteMmio16Swap(__volatile__ void *base, const unsigned long offset,
                    const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("wsbh %0, %0;\n\t" "shi %0, [%1];\n\t":        /* No outputs */
                         :"r"(val), "r"(addr));

    barrier();
}

static __inline__ void
xf86WriteMmio16(__volatile__ void *base, const unsigned long offset,
                const unsigned int val)
{
    *(volatile unsigned short *) ((unsigned char *) base + offset) = val;
    barrier();
}

static __inline__ unsigned int
xf86ReadMmio32Swap(__volatile__ void *base, const unsigned long offset)
{
    unsigned long addr = ((unsigned long) base) + offset;
    unsigned int ret;

    __asm__ __volatile__("lwi %0, [%1];\n\t"
                         "wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t":"=r"(ret)
                         :"r"(addr));

    return ret;
}

static __inline__ unsigned int
xf86ReadMmio32(__volatile__ void *base, const unsigned long offset)
{
    return *(volatile unsigned int *) ((unsigned char *) base + offset);
}

static __inline__ void
xf86WriteMmio32Swap(__volatile__ void *base, const unsigned long offset,
                    const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t" "swi %0, [%1];\n\t":        /* No outputs */
                         :"r"(val), "r"(addr));

    barrier();
}

static __inline__ void
xf86WriteMmio32(__volatile__ void *base, const unsigned long offset,
                const unsigned int val)
{
    *(volatile unsigned int *) ((unsigned char *) base + offset) = val;
    barrier();
}

#if defined(NDS32_MMIO_SWAP)
static __inline__ void
outb(unsigned PORT_SIZE port, unsigned char val)
{
    xf86WriteMmio8(IOPortBase, port, val);
}

static __inline__ void
outw(unsigned PORT_SIZE port, unsigned short val)
{
    xf86WriteMmio16Swap(IOPortBase, port, val);
}

static __inline__ void
outl(unsigned PORT_SIZE port, unsigned int val)
{
    xf86WriteMmio32Swap(IOPortBase, port, val);
}

static __inline__ unsigned int
inb(unsigned PORT_SIZE port)
{
    return xf86ReadMmio8(IOPortBase, port);
}

static __inline__ unsigned int
inw(unsigned PORT_SIZE port)
{
    return xf86ReadMmio16Swap(IOPortBase, port);
}

static __inline__ unsigned int
inl(unsigned PORT_SIZE port)
{
    return xf86ReadMmio32Swap(IOPortBase, port);
}

#else                           /* !NDS32_MMIO_SWAP */
static __inline__ void
outb(unsigned PORT_SIZE port, unsigned char val)
{
    *(volatile unsigned char *) (((unsigned PORT_SIZE) (port))) = val;
    barrier();
}

static __inline__ void
outw(unsigned PORT_SIZE port, unsigned short val)
{
    *(volatile unsigned short *) (((unsigned PORT_SIZE) (port))) = val;
    barrier();
}

static __inline__ void
outl(unsigned PORT_SIZE port, unsigned int val)
{
    *(volatile unsigned int *) (((unsigned PORT_SIZE) (port))) = val;
    barrier();
}

static __inline__ unsigned int
inb(unsigned PORT_SIZE port)
{
    return *(volatile unsigned char *) (((unsigned PORT_SIZE) (port)));
}

static __inline__ unsigned int
inw(unsigned PORT_SIZE port)
{
    return *(volatile unsigned short *) (((unsigned PORT_SIZE) (port)));
}

static __inline__ unsigned int
inl(unsigned PORT_SIZE port)
{
    return *(volatile unsigned int *) (((unsigned PORT_SIZE) (port)));
}

#endif                          /* NDS32_MMIO_SWAP */

#endif                          /* arch madness */

#else                           /* !GNUC */
#if defined(__STDC__) && (__STDC__ == 1)
#ifndef asm
#define asm __asm
#endif
#endif
#if !defined(__SUNPRO_C)
#include <sys/inline.h>
#endif
#endif                          /* __GNUC__ */

#if !defined(MMIO_IS_BE) && \
    (defined(SPARC_MMIO_IS_BE) || defined(PPC_MMIO_IS_BE))
#define MMIO_IS_BE
#endif

#ifdef __alpha__
/* entry points for Mmio memory access routines */
extern _X_EXPORT int (*xf86ReadMmio8) (void *, unsigned long);
extern _X_EXPORT int (*xf86ReadMmio16) (void *, unsigned long);
extern _X_EXPORT int (*xf86ReadMmio32) (void *, unsigned long);
extern _X_EXPORT void (*xf86WriteMmio8) (int, void *, unsigned long);
extern _X_EXPORT void (*xf86WriteMmio16) (int, void *, unsigned long);
extern _X_EXPORT void (*xf86WriteMmio32) (int, void *, unsigned long);
extern _X_EXPORT void xf86SlowBCopyFromBus(unsigned char *, unsigned char *,
                                           int);
extern _X_EXPORT void xf86SlowBCopyToBus(unsigned char *, unsigned char *, int);

/* Some macros to hide the system dependencies for MMIO accesses */
/* Changed to kill noise generated by gcc's -Wcast-align */
#define MMIO_IN8(base, offset) (*xf86ReadMmio8)(base, offset)
#define MMIO_IN16(base, offset) (*xf86ReadMmio16)(base, offset)
#define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)

#define MMIO_OUT32(base, offset, val) \
    do { \
	write_mem_barrier(); \
	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val); \
    } while (0)

#define MMIO_OUT8(base, offset, val) \
    (*xf86WriteMmio8)((CARD8)(val), base, offset)
#define MMIO_OUT16(base, offset, val) \
    (*xf86WriteMmio16)((CARD16)(val), base, offset)

#elif defined(__powerpc__) || defined(__sparc__)
 /*
  * we provide byteswapping and no byteswapping functions here
  * with byteswapping as default,
  * drivers that don't need byteswapping should define MMIO_IS_BE
  */
#define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#define MMIO_OUT8(base, offset, val) \
    xf86WriteMmio8(base, offset, (CARD8)(val))

#if defined(MMIO_IS_BE)     /* No byteswapping */
#define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#define MMIO_OUT16(base, offset, val) \
    xf86WriteMmio16Be(base, offset, (CARD16)(val))
#define MMIO_OUT32(base, offset, val) \
    xf86WriteMmio32Be(base, offset, (CARD32)(val))
#else                           /* byteswapping is the default */
#define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Le(base, offset, (CARD16)(val))
#define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Le(base, offset, (CARD32)(val))
#endif

#elif defined(__nds32__)
 /*
  * we provide byteswapping and no byteswapping functions here
  * with no byteswapping as default; when endianness of CPU core
  * and I/O devices don't match, byte swapping is necessary
  * drivers that need byteswapping should define NDS32_MMIO_SWAP
  */
#define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#define MMIO_OUT8(base, offset, val) \
    xf86WriteMmio8(base, offset, (CARD8)(val))

#if defined(NDS32_MMIO_SWAP)    /* byteswapping */
#define MMIO_IN16(base, offset) xf86ReadMmio16Swap(base, offset)
#define MMIO_IN32(base, offset) xf86ReadMmio32Swap(base, offset)
#define MMIO_OUT16(base, offset, val) \
    xf86WriteMmio16Swap(base, offset, (CARD16)(val))
#define MMIO_OUT32(base, offset, val) \
    xf86WriteMmio32Swap(base, offset, (CARD32)(val))
#else                           /* no byteswapping is the default */
#define MMIO_IN16(base, offset) xf86ReadMmio16(base, offset)
#define MMIO_IN32(base, offset) xf86ReadMmio32(base, offset)
#define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16(base, offset, (CARD16)(val))
#define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32(base, offset, (CARD32)(val))
#endif

#else                           /* !__alpha__ && !__powerpc__ && !__sparc__ */

#define MMIO_IN8(base, offset) \
	*(volatile CARD8 *)(((CARD8*)(base)) + (offset))
#define MMIO_IN16(base, offset) \
	*(volatile CARD16 *)(void *)(((CARD8*)(base)) + (offset))
#define MMIO_IN32(base, offset) \
	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset))
#define MMIO_OUT8(base, offset, val) \
	*(volatile CARD8 *)(((CARD8*)(base)) + (offset)) = (val)
#define MMIO_OUT16(base, offset, val) \
	*(volatile CARD16 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
#define MMIO_OUT32(base, offset, val) \
	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)

#endif                          /* __alpha__ */

/*
 * With Intel, the version in os-support/misc/SlowBcopy.s is used.
 * This avoids port I/O during the copy (which causes problems with
 * some hardware).
 */
#ifdef __alpha__
#define slowbcopy_tobus(src,dst,count) xf86SlowBCopyToBus(src,dst,count)
#define slowbcopy_frombus(src,dst,count) xf86SlowBCopyFromBus(src,dst,count)
#else                           /* __alpha__ */
#define slowbcopy_tobus(src,dst,count) xf86SlowBcopy(src,dst,count)
#define slowbcopy_frombus(src,dst,count) xf86SlowBcopy(src,dst,count)
#endif                          /* __alpha__ */

#endif                          /* _COMPILER_H */
@


1.16
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d289 1
a289 1
#elif defined(__amd64__)
a969 47
#elif defined(__i386__) || defined(__ia64__)

static __inline__ void
outb(unsigned short port, unsigned char val)
{
    __asm__ __volatile__("out%B0 (%1)"::"a"(val), "d"(port));
}

static __inline__ void
outw(unsigned short port, unsigned short val)
{
    __asm__ __volatile__("out%W0 (%1)"::"a"(val), "d"(port));
}

static __inline__ void
outl(unsigned short port, unsigned int val)
{
    __asm__ __volatile__("out%L0 (%1)"::"a"(val), "d"(port));
}

static __inline__ unsigned int
inb(unsigned short port)
{
    unsigned char ret;
    __asm__ __volatile__("in%B0 (%1)":"=a"(ret):"d"(port));

    return ret;
}

static __inline__ unsigned int
inw(unsigned short port)
{
    unsigned short ret;
    __asm__ __volatile__("in%W0 (%1)":"=a"(ret):"d"(port));

    return ret;
}

static __inline__ unsigned int
inl(unsigned short port)
{
    unsigned int ret;
    __asm__ __volatile__("in%L0 (%1)":"=a"(ret):"d"(port));

    return ret;
}

a991 2

#ifndef STANDALONE_MMIO
a992 9
#else
/* Some DRI 3D drivers need MMIO_IN32. */
static __inline__ int
xf86ReadMmio32(void *Base, unsigned long Offset)
{
    mem_barrier();
    return *(volatile unsigned int *) ((unsigned long) Base + (Offset));
}
#endif
a1003 1
#ifndef STANDALONE_MMIO
a1004 3
#else
#define MMIO_IN32(base, offset) xf86ReadMmio32(base, offset)
#endif
@


1.15
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a81 2
#elif defined(__HIGHC__)
#define __inline__ _Inline
a88 2
#elif defined(__HIGHC__)
#define __inline _Inline
d97 2
a98 1
#if defined(NO_INLINE) || defined(DO_PROTOTYPES)
d100 1
a100 1
#if !defined(__sparc__) && !defined(__sparc) && !defined(__arm32__) && !defined(__nds32__) \
a130 5
extern _X_EXPORT void xf86WriteMmio8NB    (void *, unsigned long, unsigned int);
extern _X_EXPORT void xf86WriteMmio16BeNB (void *, unsigned long, unsigned int);
extern _X_EXPORT void xf86WriteMmio16LeNB (void *, unsigned long, unsigned int);
extern _X_EXPORT void xf86WriteMmio32BeNB (void *, unsigned long, unsigned int);
extern _X_EXPORT void xf86WriteMmio32LeNB (void *, unsigned long, unsigned int);
a134 15
#if defined(__powerpc__) && !defined(__OpenBSD__)
extern unsigned long ldq_u(unsigned long *);
extern unsigned long ldl_u(unsigned int *);
extern unsigned long ldw_u(unsigned short *);
extern void stq_u(unsigned long, unsigned long *);
extern void stl_u(unsigned long, unsigned int *);
extern void stw_u(unsigned long, unsigned short *);
extern void mem_barrier(void);
extern void write_mem_barrier(void);
extern void stl_brx(unsigned long, volatile unsigned char *, int);
extern void stw_brx(unsigned short, volatile unsigned char *, int);
extern unsigned long ldl_brx(volatile unsigned char *, int);
extern unsigned short ldw_brx(volatile unsigned char *, int);
#endif                          /* __powerpc__ && !__OpenBSD */

a136 1
#ifndef NO_INLINE
d189 1
a189 8
#if defined(linux) && defined(__powerpc64__)
#include <linux/version.h>
#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
#include <asm/memory.h>
#endif
#endif                          /* defined(linux) && defined(__powerpc64__) */

#ifndef eieio                   /* We deal with arch-specific eieio() routines above... */
d202 4
a205 1
#endif                          /* NO_INLINE */
a214 1
#ifndef NO_INLINE
d216 1
a216 125

/* Define some packed structures to use with unaligned accesses */

struct __una_u64 {
    uint64_t x __attribute__ ((packed));
};
struct __una_u32 {
    uint32_t x __attribute__ ((packed));
};
struct __una_u16 {
    uint16_t x __attribute__ ((packed));
};

/* Elemental unaligned loads */

static __inline__ uint64_t
ldq_u(uint64_t * p)
{
    const struct __una_u64 *ptr = (const struct __una_u64 *) p;

    return ptr->x;
}

static __inline__ uint32_t
ldl_u(uint32_t * p)
{
    const struct __una_u32 *ptr = (const struct __una_u32 *) p;

    return ptr->x;
}

static __inline__ uint16_t
ldw_u(uint16_t * p)
{
    const struct __una_u16 *ptr = (const struct __una_u16 *) p;

    return ptr->x;
}

/* Elemental unaligned stores */

static __inline__ void
stq_u(uint64_t val, uint64_t * p)
{
    struct __una_u64 *ptr = (struct __una_u64 *) p;

    ptr->x = val;
}

static __inline__ void
stl_u(uint32_t val, uint32_t * p)
{
    struct __una_u32 *ptr = (struct __una_u32 *) p;

    ptr->x = val;
}

static __inline__ void
stw_u(uint16_t val, uint16_t * p)
{
    struct __una_u16 *ptr = (struct __una_u16 *) p;

    ptr->x = val;
}
#else                           /* !__GNUC__ */

#include <string.h>             /* needed for memmove */

static __inline__ uint64_t
ldq_u(uint64_t * p)
{
    uint64_t ret;

    memmove(&ret, p, sizeof(*p));
    return ret;
}

static __inline__ uint32_t
ldl_u(uint32_t * p)
{
    uint32_t ret;

    memmove(&ret, p, sizeof(*p));
    return ret;
}

static __inline__ uint16_t
ldw_u(uint16_t * p)
{
    uint16_t ret;

    memmove(&ret, p, sizeof(*p));
    return ret;
}

static __inline__ void
stq_u(uint64_t val, uint64_t * p)
{
    uint64_t tmp = val;

    memmove(p, &tmp, sizeof(*p));
}

static __inline__ void
stl_u(uint32_t val, uint32_t * p)
{
    uint32_t tmp = val;

    memmove(p, &tmp, sizeof(*p));
}

static __inline__ void
stw_u(uint16_t val, uint16_t * p)
{
    uint16_t tmp = val;

    memmove(p, &tmp, sizeof(*p));
}

#endif                          /* __GNUC__ */
#endif                          /* NO_INLINE */

#ifndef NO_INLINE
#ifdef __GNUC__
#if (defined(linux) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)) && (defined(__alpha__))
d289 1
a289 1
#elif (defined(linux) || defined(__FreeBSD__)) && defined(__amd64__)
d338 1
a338 1
#elif (defined(linux) || defined(sun) || defined(__OpenBSD__) || defined(__FreeBSD__)) && defined(__sparc__)
a520 50
static __inline__ void
xf86WriteMmio8NB(__volatile__ void *base, const unsigned long offset,
                 const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("stba %0, [%1] %2":    /* No outputs */
                         :"r"(val), "r"(addr), "i"(ASI_PL));
}

static __inline__ void
xf86WriteMmio16BeNB(__volatile__ void *base, const unsigned long offset,
                    const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("sth %0, [%1]":        /* No outputs */
                         :"r"(val), "r"(addr));
}

static __inline__ void
xf86WriteMmio16LeNB(__volatile__ void *base, const unsigned long offset,
                    const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("stha %0, [%1] %2":    /* No outputs */
                         :"r"(val), "r"(addr), "i"(ASI_PL));
}

static __inline__ void
xf86WriteMmio32BeNB(__volatile__ void *base, const unsigned long offset,
                    const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("st %0, [%1]": /* No outputs */
                         :"r"(val), "r"(addr));
}

static __inline__ void
xf86WriteMmio32LeNB(__volatile__ void *base, const unsigned long offset,
                    const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("sta %0, [%1] %2":     /* No outputs */
                         :"r"(val), "r"(addr), "i"(ASI_PL));
}

d600 1
a600 1
#elif (defined(linux) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__)) && defined(__powerpc__)
d659 2
a660 2
xf86WriteMmioNB8(__volatile__ void *base, const unsigned long offset,
                 const unsigned char val)
d666 1
d670 2
a671 2
xf86WriteMmioNB16Le(__volatile__ void *base, const unsigned long offset,
                    const unsigned short val)
d677 1
d681 2
a682 2
xf86WriteMmioNB16Be(__volatile__ void *base, const unsigned long offset,
                    const unsigned short val)
d688 1
d692 2
a693 2
xf86WriteMmioNB32Le(__volatile__ void *base, const unsigned long offset,
                    const unsigned int val)
d699 1
d703 2
a704 2
xf86WriteMmioNB32Be(__volatile__ void *base, const unsigned long offset,
                    const unsigned int val)
a709 39
}

static __inline__ void
xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
               const unsigned char val)
{
    xf86WriteMmioNB8(base, offset, val);
    eieio();
}

static __inline__ void
xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
                  const unsigned short val)
{
    xf86WriteMmioNB16Le(base, offset, val);
    eieio();
}

static __inline__ void
xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
                  const unsigned short val)
{
    xf86WriteMmioNB16Be(base, offset, val);
    eieio();
}

static __inline__ void
xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    xf86WriteMmioNB32Le(base, offset, val);
    eieio();
}

static __inline__ void
xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    xf86WriteMmioNB32Be(base, offset, val);
d795 1
a795 2
 * if there is unaligned port access.  For ldq_u, ldl_u, ldw_u, stq_u, stl_u and
 * stw_u, they are assumed unaligned.
a797 2
#define barrier()               /* no barrier */

a813 7
static __inline__ void
xf86WriteMmio8NB(__volatile__ void *base, const unsigned long offset,
                 const unsigned int val)
{
    *(volatile unsigned char *) ((unsigned char *) base + offset) = val;
}

a851 17
static __inline__ void
xf86WriteMmio16SwapNB(__volatile__ void *base, const unsigned long offset,
                      const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("wsbh %0, %0;\n\t" "shi %0, [%1];\n\t":        /* No outputs */
                         :"r"(val), "r"(addr));
}

static __inline__ void
xf86WriteMmio16NB(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    *(volatile unsigned short *) ((unsigned char *) base + offset) = val;
}

a890 17
static __inline__ void
xf86WriteMmio32SwapNB(__volatile__ void *base, const unsigned long offset,
                      const unsigned int val)
{
    unsigned long addr = ((unsigned long) base) + offset;

    __asm__ __volatile__("wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t" "swi %0, [%1];\n\t":        /* No outputs */
                         :"r"(val), "r"(addr));
}

static __inline__ void
xf86WriteMmio32NB(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
    *(volatile unsigned int *) ((unsigned char *) base + offset) = val;
}

a927 44
static __inline__ unsigned long
ldq_u(unsigned long *p)
{
    unsigned long addr = (unsigned long) p;
    unsigned int ret;

    __asm__ __volatile__("lmw.bi %0, [%1], %0, 0;\n\t"
                         "wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t":"=r"(ret)
                         :"r"(addr));

    return ret;
}

static __inline__ unsigned long
ldl_u(unsigned int *p)
{
    unsigned long addr = (unsigned long) p;
    unsigned int ret;

    __asm__ __volatile__("lmw.bi %0, [%1], %0, 0;\n\t"
                         "wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t":"=r"(ret)
                         :"r"(addr));

    return ret;
}

static __inline__ void
stq_u(unsigned long val, unsigned long *p)
{
    unsigned long addr = (unsigned long) p;

    __asm__ __volatile__("wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t" "smw.bi %0, [%1], %0, 0;\n\t":      /* No outputs */
                         :"r"(val), "r"(addr));
}

static __inline__ void
stl_u(unsigned long val, unsigned int *p)
{
    unsigned long addr = (unsigned long) p;

    __asm__ __volatile__("wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t" "smw.bi %0, [%1], %0, 0;\n\t":      /* No outputs */
                         :"r"(val), "r"(addr));
}

a967 41
static __inline__ unsigned long
ldq_u(unsigned long *p)
{
    unsigned long addr = (unsigned long) p;
    unsigned int ret;

    __asm__ __volatile__("lmw.bi %0, [%1], %0, 0;\n\t":"=r"(ret)
                         :"r"(addr));

    return ret;
}

static __inline__ unsigned long
ldl_u(unsigned int *p)
{
    unsigned long addr = (unsigned long) p;
    unsigned int ret;

    __asm__ __volatile__("lmw.bi %0, [%1], %0, 0;\n\t":"=r"(ret)
                         :"r"(addr));

    return ret;
}

static __inline__ void
stq_u(unsigned long val, unsigned long *p)
{
    unsigned long addr = (unsigned long) p;

    __asm__ __volatile__("smw.bi %0, [%1], %0, 0;\n\t": /* No outputs */
                         :"r"(val), "r"(addr));
}

static __inline__ void
stl_u(unsigned long val, unsigned int *p)
{
    unsigned long addr = (unsigned long) p;

    __asm__ __volatile__("smw.bi %0, [%1], %0, 0;\n\t": /* No outputs */
                         :"r"(val), "r"(addr));
}
d970 1
a970 75
#if (((X_BYTE_ORDER == X_BIG_ENDIAN) && !defined(NDS32_MMIO_SWAP)) || ((X_BYTE_ORDER != X_BIG_ENDIAN) && defined(NDS32_MMIO_SWAP)))
#define ldw_u(p)	((*(unsigned char *)(p)) << 8 | \
			(*((unsigned char *)(p)+1)))
#define stw_u(v,p)	(*(unsigned char *)(p)) = ((v) >> 8); \
				(*((unsigned char *)(p)+1)) = (v)
#else
#define ldw_u(p)	((*(unsigned char *)(p)) | \
			(*((unsigned char *)(p)+1)<<8))
#define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*((unsigned char *)(p)+1)) = ((v) >> 8)
#endif

#define mem_barrier()           /* XXX: nop for now */
#define write_mem_barrier()     /* XXX: nop for now */

#else                           /* ix86 */

#if !defined(__SUNPRO_C)
#if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && \
    !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && \
    !defined(__m32r__) && !defined(__aarch64__) && !defined(__arc__) && \
    !defined(__xtensa__)
#ifdef GCCUSESGAS

/*
 * If gcc uses gas rather than the native assembler, the syntax of these
 * inlines has to be different.		DHD
 */

static __inline__ void
outb(unsigned short port, unsigned char val)
{
    __asm__ __volatile__("outb %0,%1"::"a"(val), "d"(port));
}

static __inline__ void
outw(unsigned short port, unsigned short val)
{
    __asm__ __volatile__("outw %0,%1"::"a"(val), "d"(port));
}

static __inline__ void
outl(unsigned short port, unsigned int val)
{
    __asm__ __volatile__("outl %0,%1"::"a"(val), "d"(port));
}

static __inline__ unsigned int
inb(unsigned short port)
{
    unsigned char ret;
    __asm__ __volatile__("inb %1,%0":"=a"(ret):"d"(port));

    return ret;
}

static __inline__ unsigned int
inw(unsigned short port)
{
    unsigned short ret;
    __asm__ __volatile__("inw %1,%0":"=a"(ret):"d"(port));

    return ret;
}

static __inline__ unsigned int
inl(unsigned short port)
{
    unsigned int ret;
    __asm__ __volatile__("inl %1,%0":"=a"(ret):"d"(port));

    return ret;
}

#else                           /* GCCUSESGAS */
d1017 1
a1017 41
#endif                          /* GCCUSESGAS */

#else                           /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__m32r__) && !defined(__arc__) */

static __inline__ void
outb(unsigned short port, unsigned char val)
{
}

static __inline__ void
outw(unsigned short port, unsigned short val)
{
}

static __inline__ void
outl(unsigned short port, unsigned int val)
{
}

static __inline__ unsigned int
inb(unsigned short port)
{
    return 0;
}

static __inline__ unsigned int
inw(unsigned short port)
{
    return 0;
}

static __inline__ unsigned int
inl(unsigned short port)
{
    return 0;
}

#endif                          /* FAKEIT */
#endif                          /* __SUNPRO_C */

#endif                          /* ix86 */
a1027 9
#if !defined(__HIGHC__) && !defined(__SUNPRO_C) || \
	defined(__USLC__)
#pragma asm partial_optimization outl
#pragma asm partial_optimization outw
#pragma asm partial_optimization outb
#pragma asm partial_optimization inl
#pragma asm partial_optimization inw
#pragma asm partial_optimization inb
#endif
d1030 4
a1033 1
#endif                          /* NO_INLINE */
a1053 3
extern _X_EXPORT void (*xf86WriteMmioNB8) (int, void *, unsigned long);
extern _X_EXPORT void (*xf86WriteMmioNB16) (int, void *, unsigned long);
extern _X_EXPORT void (*xf86WriteMmioNB32) (int, void *, unsigned long);
a1072 2
#define MMIO_ONB32(base, offset, val) \
	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
a1077 6
#define MMIO_ONB8(base, offset, val) \
    (*xf86WriteMmioNB8)((CARD8)(val), base, offset)
#define MMIO_ONB16(base, offset, val) \
    (*xf86WriteMmioNB16)((CARD16)(val), base, offset)
#define MMIO_MOVE32(base, offset, val) \
    MMIO_OUT32(base, offset, val)
d1079 2
a1080 2
#elif defined(__powerpc__)
 /* 
d1082 2
a1083 2
  * with byteswapping as default, 
  * drivers that don't need byteswapping should define PPC_MMIO_IS_BE 
a1087 2
#define MMIO_ONB8(base, offset, val) \
    xf86WriteMmioNB8(base, offset, (CARD8)(val))
d1089 1
a1089 1
#if defined(PPC_MMIO_IS_BE)     /* No byteswapping */
a1095 45
#define MMIO_ONB16(base, offset, val) \
    xf86WriteMmioNB16Be(base, offset, (CARD16)(val))
#define MMIO_ONB32(base, offset, val) \
    xf86WriteMmioNB32Be(base, offset, (CARD32)(val))
#else                           /* byteswapping is the default */
#define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Le(base, offset, (CARD16)(val))
#define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Le(base, offset, (CARD32)(val))
#define MMIO_ONB16(base, offset, val) \
     xf86WriteMmioNB16Le(base, offset, (CARD16)(val))
#define MMIO_ONB32(base, offset, val) \
     xf86WriteMmioNB32Le(base, offset, (CARD32)(val))
#endif

#define MMIO_MOVE32(base, offset, val) \
       xf86WriteMmio32Be(base, offset, (CARD32)(val))

#elif defined(__sparc__) || defined(sparc) || defined(__sparc)
 /*
  * Like powerpc, we provide byteswapping and no byteswapping functions
  * here with byteswapping as default, drivers that don't need byteswapping
  * should define SPARC_MMIO_IS_BE (perhaps create a generic macro so that we
  * do not need to use PPC_MMIO_IS_BE and the sparc one in all the same places
  * of drivers?).
  */
#define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#define MMIO_OUT8(base, offset, val) \
    xf86WriteMmio8(base, offset, (CARD8)(val))
#define MMIO_ONB8(base, offset, val) \
    xf86WriteMmio8NB(base, offset, (CARD8)(val))

#if defined(SPARC_MMIO_IS_BE)   /* No byteswapping */
#define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Be(base, offset, (CARD16)(val))
#define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Be(base, offset, (CARD32)(val))
#define MMIO_ONB16(base, offset, val) \
     xf86WriteMmio16BeNB(base, offset, (CARD16)(val))
#define MMIO_ONB32(base, offset, val) \
     xf86WriteMmio32BeNB(base, offset, (CARD32)(val))
a1102 4
#define MMIO_ONB16(base, offset, val) \
     xf86WriteMmio16LeNB(base, offset, (CARD16)(val))
#define MMIO_ONB32(base, offset, val) \
     xf86WriteMmio32LeNB(base, offset, (CARD32)(val))
a1104 3
#define MMIO_MOVE32(base, offset, val) \
       xf86WriteMmio32Be(base, offset, (CARD32)(val))

a1114 2
#define MMIO_ONB8(base, offset, val) \
    xf86WriteMmioNB8(base, offset, (CARD8)(val))
a1122 4
#define MMIO_ONB16(base, offset, val) \
    xf86WriteMmioNB16Swap(base, offset, (CARD16)(val))
#define MMIO_ONB32(base, offset, val) \
    xf86WriteMmioNB32Swap(base, offset, (CARD32)(val))
a1129 24
#define MMIO_ONB16(base, offset, val) \
     xf86WriteMmioNB16(base, offset, (CARD16)(val))
#define MMIO_ONB32(base, offset, val) \
     xf86WriteMmioNB32(base, offset, (CARD32)(val))
#endif

#define MMIO_MOVE32(base, offset, val) \
       xf86WriteMmio32(base, offset, (CARD32)(val))

#ifdef N1213_HC                 /* for NDS32 N1213 hardcore */
static __inline__ void
nds32_flush_icache(char *addr)
{
    __asm__ volatile ("isync %0;"
                      "msync;"
                      "isb;"
                      "cctl %0,L1I_VA_INVAL;" "isb;"::"r" (addr):"memory");
}
#else
static __inline__ void
nds32_flush_icache(char *addr)
{
    __asm__ volatile ("isync %0;" "isb;"::"r" (addr):"memory");
}
a1145 5
#define MMIO_ONB8(base, offset, val) MMIO_OUT8(base, offset, val)
#define MMIO_ONB16(base, offset, val) MMIO_OUT16(base, offset, val)
#define MMIO_ONB32(base, offset, val) MMIO_OUT32(base, offset, val)

#define MMIO_MOVE32(base, offset, val) MMIO_OUT32(base, offset, val)
@


1.14
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d106 1
d1355 4
a1358 1
#if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && !defined(__m32r__) && !defined(__aarch64__)
d1460 1
a1460 1
#else                           /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__m32r__) */
@


1.13
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d1354 1
a1354 1
#if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && !defined(__m32r__)
@


1.12
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d122 17
@


1.11
log
@Update to xserver 1.11.2
@
text
@d52 1
a52 1
# define _COMPILER_H
d55 1
a55 1
# define DO_PROTOTYPES
d60 1
a60 1
# define __amd64__
d63 1
a63 1
# define __i386__
d66 1
a66 1
# define __sparc__
d69 1
a69 1
# define __sparc64__
d73 1
a73 1
# include <X11/Xfuncproto.h>
d76 1
a76 1
# include <pixman.h> /* for uint*_t types */
d79 2
a80 2
# ifndef __inline__
#  if defined(__GNUC__)
d82 8
a89 8
#  elif defined(__HIGHC__)
#   define __inline__ _Inline
#  else
#   define __inline__ /**/
#  endif
# endif /* __inline__ */
# ifndef __inline
#  if defined(__GNUC__)
d91 6
a96 7
#  elif defined(__HIGHC__)
#   define __inline _Inline
#  else
#   define __inline /**/
#  endif
# endif /* __inline */

d99 1
a99 1
# define __FUNCTION__ __func__ /* C99 */
d101 3
a103 5

# if defined(NO_INLINE) || defined(DO_PROTOTYPES)

#  if !defined(__arm__)
#   if !defined(__sparc__) && !defined(__sparc) && !defined(__arm32__) && !defined(__nds32__) \
d114 1
a114 2
#   else /* __sparc__,  __arm32__, __alpha__, __nds32__ */

d122 2
a123 2
#   endif /* __sparc__,  __arm32__, __alpha__, __nds32__ */
#  endif /* __arm__ */
d125 1
a125 1
#  if defined(__powerpc__) && !defined(__OpenBSD__)
d138 1
a138 1
#  endif /* __powerpc__ && !__OpenBSD */
d140 1
a140 1
# endif /* NO_INLINE || DO_PROTOTYPES */
d142 3
a144 3
# ifndef NO_INLINE
#  ifdef __GNUC__
#   ifdef __i386__
d146 5
a150 5
#    ifdef __SSE__
#     define write_mem_barrier() __asm__ __volatile__ ("sfence" : : : "memory")
#    else
#     define write_mem_barrier() __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory")
#    endif
d152 5
a156 5
#    ifdef __SSE2__
#     define mem_barrier() __asm__ __volatile__ ("mfence" : : : "memory")
#    else
#     define mem_barrier() __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory")
#    endif
d158 1
a158 1
#   elif defined __alpha__
d160 2
a161 2
#    define mem_barrier() __asm__ __volatile__ ("mb" : : : "memory")
#    define write_mem_barrier() __asm__ __volatile__ ("wmb" : : : "memory")
d163 1
a163 1
#   elif defined __amd64__
d165 2
a166 2
#    define mem_barrier() __asm__ __volatile__ ("mfence" : : : "memory")
#    define write_mem_barrier() __asm__ __volatile__ ("sfence" : : : "memory")
d168 1
a168 1
#   elif defined __ia64__
d170 8
a177 8
#    ifndef __INTEL_COMPILER
#     define mem_barrier()        __asm__ __volatile__ ("mf" : : : "memory")
#     define write_mem_barrier()  __asm__ __volatile__ ("mf" : : : "memory")
#    else
#     include "ia64intrin.h"
#     define mem_barrier() __mf()
#     define write_mem_barrier() __mf()
#    endif
d179 1
a179 1
#   elif defined __mips__
d181 1
a181 1
#    define mem_barrier()		\
d191 1
a191 1
#    define write_mem_barrier() mem_barrier()
d193 1
a193 1
#   elif defined __powerpc__
d195 6
a200 29
#    if defined(linux) && defined(__powerpc64__)
#     include <linux/version.h>
#     if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
#      include <asm/memory.h>
#     endif
#    endif /* defined(linux) && defined(__powerpc64__) */

#    ifndef eieio /* We deal with arch-specific eieio() routines above... */
#     define eieio() __asm__ __volatile__ ("eieio" ::: "memory")
#    endif /* eieio */
#    define mem_barrier()	eieio()
#    define write_mem_barrier()	eieio()

#   elif defined __sparc__

#    define barrier() __asm__ __volatile__ (".word 0x8143e00a" : : : "memory")
#    define mem_barrier()         /* XXX: nop for now */
#    define write_mem_barrier()   /* XXX: nop for now */
#   endif
#  endif /* __GNUC__ */
# endif /* NO_INLINE */

# ifndef mem_barrier
#  define mem_barrier() /* NOP */
# endif

# ifndef write_mem_barrier
#  define write_mem_barrier() /* NOP */
# endif
d202 18
d221 6
a226 2
# ifndef NO_INLINE
#  ifdef __GNUC__
d230 9
a238 3
struct __una_u64 { uint64_t x __attribute__((packed)); };
struct __una_u32 { uint32_t x __attribute__((packed)); };
struct __una_u16 { uint16_t x __attribute__((packed)); };
d242 2
a243 1
static __inline__ uint64_t ldq_u(uint64_t *p)
d245 3
a247 2
	const struct __una_u64 *ptr = (const struct __una_u64 *) p;
	return ptr->x;
d250 2
a251 1
static __inline__ uint32_t ldl_u(uint32_t *p)
d253 3
a255 2
	const struct __una_u32 *ptr = (const struct __una_u32 *) p;
	return ptr->x;
d258 2
a259 1
static __inline__ uint16_t ldw_u(uint16_t *p)
d261 3
a263 2
	const struct __una_u16 *ptr = (const struct __una_u16 *) p;
	return ptr->x;
d268 2
a269 1
static __inline__ void stq_u(uint64_t val, uint64_t *p)
d271 3
a273 2
	struct __una_u64 *ptr = (struct __una_u64 *) p;
	ptr->x = val;
d276 2
a277 1
static __inline__ void stl_u(uint32_t val, uint32_t *p)
d279 3
a281 2
	struct __una_u32 *ptr = (struct __una_u32 *) p;
	ptr->x = val;
d284 2
a285 1
static __inline__ void stw_u(uint16_t val, uint16_t *p)
d287 3
a289 2
	struct __una_u16 *ptr = (struct __una_u16 *) p;
	ptr->x = val;
d291 1
a291 1
#  else /* !__GNUC__ */
d293 1
a293 1
#include <string.h> /* needed for memmove */
d295 2
a296 1
static __inline__ uint64_t ldq_u(uint64_t *p)
d298 4
a301 3
	uint64_t ret;
	memmove(&ret, p, sizeof(*p));
	return ret;
d304 2
a305 1
static __inline__ uint32_t ldl_u(uint32_t *p)
d307 4
a310 3
	uint32_t ret;
	memmove(&ret, p, sizeof(*p));
	return ret;
d313 2
a314 1
static __inline__ uint16_t ldw_u(uint16_t *p)
d316 4
a319 3
	uint16_t ret;
	memmove(&ret, p, sizeof(*p));
	return ret;
d322 2
a323 1
static __inline__ void stq_u(uint64_t val, uint64_t *p)
d325 3
a327 2
	uint64_t tmp = val;
	memmove(p, &tmp, sizeof(*p));
d330 2
a331 1
static __inline__ void stl_u(uint32_t val, uint32_t *p)
d333 3
a335 2
	uint32_t tmp = val;
	memmove(p, &tmp, sizeof(*p));
d338 2
a339 1
static __inline__ void stw_u(uint16_t val, uint16_t *p)
d341 3
a343 2
	uint16_t tmp = val;
	memmove(p, &tmp, sizeof(*p));
d346 2
a347 2
#  endif /* __GNUC__ */
# endif /* NO_INLINE */
d349 3
a351 3
# ifndef NO_INLINE
#  ifdef __GNUC__
#   if (defined(linux) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)) && (defined(__alpha__))
d353 1
a353 1
#    ifdef linux
d386 1
a386 1
  return _inb(port);
d392 1
a392 1
  return _inw(port);
d398 1
a398 1
  return _inl(port);
d401 1
a401 1
#    endif /* linux */
d403 1
a403 1
#    if (defined(__FreeBSD__) || defined(__OpenBSD__)) \
d418 1
a418 2
#    endif /* (__FreeBSD__ || __OpenBSD__ ) && !DO_PROTOTYPES */

d422 3
a424 1
#endif /* __NetBSD__ */
d426 1
a426 22
#   elif defined(linux) && defined(__ia64__) 
 
#    include <inttypes.h>

#    include <sys/io.h>

#    undef outb
#    undef outw
#    undef outl
#    undef inb
#    undef inw
#    undef inl
extern _X_EXPORT void outb(unsigned long port, unsigned char val);
extern _X_EXPORT void outw(unsigned long port, unsigned short val);
extern _X_EXPORT void outl(unsigned long port, unsigned int val);
extern _X_EXPORT unsigned int inb(unsigned long port);
extern _X_EXPORT unsigned int inw(unsigned long port);
extern _X_EXPORT unsigned int inl(unsigned long port);
 
#   elif (defined(linux) || defined(__FreeBSD__)) && defined(__amd64__)
 
#    include <inttypes.h>
d431 1
a431 1
   __asm__ __volatile__("outb %0,%1" : :"a" (val), "d" (port));
a433 1

d437 1
a437 1
   __asm__ __volatile__("outw %0,%1" : :"a" (val), "d" (port));
d443 1
a443 1
   __asm__ __volatile__("outl %0,%1" : :"a" (val), "d" (port));
d449 4
a452 5
   unsigned char ret;
   __asm__ __volatile__("inb %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
d458 4
a461 5
   unsigned short ret;
   __asm__ __volatile__("inw %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
d467 4
a470 5
   unsigned int ret;
   __asm__ __volatile__("inl %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
d473 5
a477 5
#   elif (defined(linux) || defined(sun) || defined(__OpenBSD__) || defined(__FreeBSD__)) && defined(__sparc__)

#     ifndef ASI_PL
#      define ASI_PL 0x88
#     endif
d482 4
a485 4
	__asm__ __volatile__("stba %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (port), "i" (ASI_PL));
	barrier();
d491 4
a494 4
	__asm__ __volatile__("stha %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (port), "i" (ASI_PL));
	barrier();
d500 4
a503 4
	__asm__ __volatile__("sta %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (port), "i" (ASI_PL));
	barrier();
d509 5
a513 5
	unsigned int ret;
	__asm__ __volatile__("lduba [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (port), "i" (ASI_PL));
	return ret;
d519 5
a523 5
	unsigned int ret;
	__asm__ __volatile__("lduha [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (port), "i" (ASI_PL));
	return ret;
d529 5
a533 5
	unsigned int ret;
	__asm__ __volatile__("lda [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (port), "i" (ASI_PL));
	return ret;
d539 2
a540 2
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned char ret;
d542 4
a545 4
	__asm__ __volatile__("lduba [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (addr), "i" (ASI_PL));
	return ret;
d551 5
a555 2
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned short ret;
d557 1
a557 4
	__asm__ __volatile__("lduh [%1], %0"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
d563 2
a564 2
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned short ret;
d566 4
a569 4
	__asm__ __volatile__("lduha [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (addr), "i" (ASI_PL));
	return ret;
d575 5
a579 2
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned int ret;
d581 1
a581 4
	__asm__ __volatile__("ld [%1], %0"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
d587 5
a591 2
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned int ret;
d593 1
a593 4
	__asm__ __volatile__("lda [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (addr), "i" (ASI_PL));
	return ret;
d598 1
a598 1
	       const unsigned int val)
d600 1
a600 1
	unsigned long addr = ((unsigned long)base) + offset;
d602 4
a605 4
	__asm__ __volatile__("stba %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
	barrier();
d610 1
a610 1
		  const unsigned int val)
d612 1
a612 1
	unsigned long addr = ((unsigned long)base) + offset;
d614 4
a617 4
	__asm__ __volatile__("sth %0, [%1]"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
	barrier();
d622 1
a622 1
		  const unsigned int val)
d624 1
a624 1
	unsigned long addr = ((unsigned long)base) + offset;
d626 4
a629 4
	__asm__ __volatile__("stha %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
	barrier();
d634 1
a634 1
		  const unsigned int val)
d636 1
a636 1
	unsigned long addr = ((unsigned long)base) + offset;
d638 4
a641 4
	__asm__ __volatile__("st %0, [%1]"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
	barrier();
d646 1
a646 1
		  const unsigned int val)
d648 1
a648 1
	unsigned long addr = ((unsigned long)base) + offset;
d650 4
a653 4
	__asm__ __volatile__("sta %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
	barrier();
d658 1
a658 1
		 const unsigned int val)
d660 1
a660 1
	unsigned long addr = ((unsigned long)base) + offset;
d662 2
a663 3
	__asm__ __volatile__("stba %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
d668 1
a668 1
		    const unsigned int val)
d670 1
a670 1
	unsigned long addr = ((unsigned long)base) + offset;
d672 2
a673 3
	__asm__ __volatile__("sth %0, [%1]"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
d678 1
a678 1
		    const unsigned int val)
d680 1
a680 1
	unsigned long addr = ((unsigned long)base) + offset;
d682 2
a683 3
	__asm__ __volatile__("stha %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
d688 1
a688 1
		    const unsigned int val)
d690 1
a690 1
	unsigned long addr = ((unsigned long)base) + offset;
d692 2
a693 3
	__asm__ __volatile__("st %0, [%1]"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
d698 1
a698 1
		    const unsigned int val)
d700 1
a700 1
	unsigned long addr = ((unsigned long)base) + offset;
d702 2
a703 3
	__asm__ __volatile__("sta %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
d706 6
a711 6
#   elif defined(__mips__) || (defined(__arm32__) && !defined(__linux__))
#    if defined(__arm32__) || defined(__mips64__)
#     define PORT_SIZE long
#    else
#     define PORT_SIZE short
#    endif
d713 1
a713 1
_X_EXPORT unsigned int IOPortBase;  /* Memory mapped I/O port area */
d718 2
a719 1
	*(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
d725 2
a726 1
	*(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
d732 2
a733 1
	*(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
d739 2
a740 1
	return *(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase);
d746 2
a747 1
	return *(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase);
d753 2
a754 1
	return *(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase);
d757 3
a759 4

#    if defined(__mips__)
#     ifdef linux	/* don't mess with other OSs */
#       if X_BYTE_ORDER == X_BIG_ENDIAN
d763 5
a767 2
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned int ret;
d769 1
a769 4
	__asm__ __volatile__("lw %0, 0(%1)"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
d774 1
a774 1
		  const unsigned int val)
d776 1
a776 1
	unsigned long addr = ((unsigned long)base) + offset;
d778 2
a779 3
	__asm__ __volatile__("sw %0, 0(%1)"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
d781 3
a783 3
#      endif
#     endif /* !linux */
#    endif /* __mips__ */
d785 1
a785 1
#   elif (defined(linux) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__)) && defined(__powerpc__)
d787 3
a789 3
#    ifndef MAP_FAILED
#     define MAP_FAILED ((void *)-1)
#    endif
d796 5
a800 8
        register unsigned char val;
        __asm__ __volatile__(
                        "lbzx %0,%1,%2\n\t"
                        "eieio"
                        : "=r" (val)
                        : "b" (base), "r" (offset),
                        "m" (*((volatile unsigned char *)base+offset)));
        return val;
d806 5
a810 8
        register unsigned short val;
        __asm__ __volatile__(
                        "lhzx %0,%1,%2\n\t"
                        "eieio"
                        : "=r" (val)
                        : "b" (base), "r" (offset),
                        "m" (*((volatile unsigned char *)base+offset)));
        return val;
d816 5
a820 8
        register unsigned short val;
        __asm__ __volatile__(
                        "lhbrx %0,%1,%2\n\t"
                        "eieio"
                        : "=r" (val)
                        : "b" (base), "r" (offset),
                        "m" (*((volatile unsigned char *)base+offset)));
        return val;
d826 5
a830 8
        register unsigned int val;
        __asm__ __volatile__(
                        "lwzx %0,%1,%2\n\t"
                        "eieio"
                        : "=r" (val)
                        : "b" (base), "r" (offset),
                        "m" (*((volatile unsigned char *)base+offset)));
        return val;
d836 5
a840 8
        register unsigned int val;
        __asm__ __volatile__(
                        "lwbrx %0,%1,%2\n\t"
                        "eieio"
                        : "=r" (val)
                        : "b" (base), "r" (offset),
                        "m" (*((volatile unsigned char *)base+offset)));
        return val;
d845 1
a845 1
		 const unsigned char val)
d847 4
a850 4
        __asm__ __volatile__(
                        "stbx %1,%2,%3\n\t"
                        : "=m" (*((volatile unsigned char *)base+offset))
                        : "r" (val), "b" (base), "r" (offset));
d855 1
a855 1
		    const unsigned short val)
d857 4
a860 4
        __asm__ __volatile__(
                        "sthbrx %1,%2,%3\n\t"
                        : "=m" (*((volatile unsigned char *)base+offset))
                        : "r" (val), "b" (base), "r" (offset));
d865 1
a865 1
		    const unsigned short val)
d867 4
a870 4
        __asm__ __volatile__(
                        "sthx %1,%2,%3\n\t"
                        : "=m" (*((volatile unsigned char *)base+offset))
                        : "r" (val), "b" (base), "r" (offset));
d875 1
a875 1
		    const unsigned int val)
d877 4
a880 4
        __asm__ __volatile__(
                        "stwbrx %1,%2,%3\n\t"
                        : "=m" (*((volatile unsigned char *)base+offset))
                        : "r" (val), "b" (base), "r" (offset));
d885 1
a885 1
		    const unsigned int val)
d887 4
a890 4
        __asm__ __volatile__(
                        "stwx %1,%2,%3\n\t"
                        : "=m" (*((volatile unsigned char *)base+offset))
                        : "r" (val), "b" (base), "r" (offset));
d897 2
a898 2
        xf86WriteMmioNB8(base, offset, val);
        eieio();
d905 2
a906 2
        xf86WriteMmioNB16Le(base, offset, val);
        eieio();
d913 2
a914 2
        xf86WriteMmioNB16Be(base, offset, val);
        eieio();
d921 2
a922 2
        xf86WriteMmioNB32Le(base, offset, val);
        eieio();
d929 2
a930 2
        xf86WriteMmioNB32Be(base, offset, val);
        eieio();
a932 1

d936 3
a938 2
        if(ioBase == MAP_FAILED) return;
        xf86WriteMmio8((void *)ioBase, port, value);
d944 3
a946 2
        if(ioBase == MAP_FAILED) return;
        xf86WriteMmio16Le((void *)ioBase, port, value);
d952 3
a954 2
        if(ioBase == MAP_FAILED) return;
        xf86WriteMmio32Le((void *)ioBase, port, value);
d960 3
a962 2
        if(ioBase == MAP_FAILED) return 0;
        return xf86ReadMmio8((void *)ioBase, port);
d968 3
a970 2
        if(ioBase == MAP_FAILED) return 0;
        return xf86ReadMmio16Le((void *)ioBase, port);
d976 3
a978 2
        if(ioBase == MAP_FAILED) return 0;
        return xf86ReadMmio32Le((void *)ioBase, port);
d1011 1
a1011 1
#   elif defined(__nds32__)
d1019 1
a1019 1
#define barrier()		/* no barrier */
d1026 1
a1026 1
	return *(volatile unsigned char *)((unsigned char *)base + offset) ;
d1031 1
a1031 1
	       const unsigned int val)
d1033 2
a1034 2
	*(volatile unsigned char *)((unsigned char *)base + offset) = val ;
	barrier();
d1039 1
a1039 1
		 const unsigned int val)
d1041 1
a1041 1
	*(volatile unsigned char *)((unsigned char *)base + offset) = val ;
d1047 5
a1051 2
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned short ret;
d1053 1
a1053 6
	__asm__ __volatile__(
	           "lhi %0, [%1];\n\t"
	           "wsbh %0, %0;\n\t"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
d1059 1
a1059 1
	return *(volatile unsigned short *)((char *)base + offset) ;
d1064 1
a1064 1
		  const unsigned int val)
d1066 1
a1066 1
	unsigned long addr = ((unsigned long)base) + offset;
d1068 4
a1071 6
	__asm__ __volatile__(
	           "wsbh %0, %0;\n\t"
	           "shi %0, [%1];\n\t"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
	barrier();
d1076 1
a1076 1
		  const unsigned int val)
d1078 2
a1079 2
	*(volatile unsigned short *)((unsigned char *)base + offset) = val ;
	barrier();
d1084 1
a1084 1
		    const unsigned int val)
d1086 1
a1086 1
	unsigned long addr = ((unsigned long)base) + offset;
d1088 2
a1089 5
	__asm__ __volatile__(
	           "wsbh %0, %0;\n\t"
	           "shi %0, [%1];\n\t"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
d1094 1
a1094 1
		    const unsigned int val)
d1096 1
a1096 1
	*(volatile unsigned short *)((unsigned char *)base + offset) = val ;
d1102 6
a1107 2
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned int ret;
d1109 1
a1109 7
	__asm__ __volatile__(
	           "lwi %0, [%1];\n\t"
	           "wsbh %0, %0;\n\t"
				  "rotri %0, %0, 16;\n\t"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
d1115 1
a1115 1
	return *(volatile unsigned int *)((unsigned char *)base + offset) ;
d1120 1
a1120 1
		  const unsigned int val)
d1122 1
a1122 1
	unsigned long addr = ((unsigned long)base) + offset;
d1124 4
a1127 7
	__asm__ __volatile__(
	           "wsbh %0, %0;\n\t"
	           "rotri %0, %0, 16;\n\t"
				  "swi %0, [%1];\n\t"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
	barrier();
d1132 1
a1132 1
		  const unsigned int val)
d1134 2
a1135 2
	*(volatile unsigned int *)((unsigned char *)base + offset) = val ;
	barrier();
d1140 1
a1140 1
		    const unsigned int val)
d1142 1
a1142 1
	unsigned long addr = ((unsigned long)base) + offset;
d1144 2
a1145 6
	__asm__ __volatile__(
	           "wsbh %0, %0;\n\t"
				  "rotri %0, %0, 16;\n\t"
				  "swi %0, [%1];\n\t"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
d1150 1
a1150 1
		    const unsigned int val)
d1152 1
a1152 1
	*(volatile unsigned int *)((unsigned char *)base + offset) = val ;
d1155 1
a1155 1
#    if defined(NDS32_MMIO_SWAP)
d1159 1
a1159 1
   xf86WriteMmio8(IOPortBase, port, val);
d1165 1
a1165 1
   xf86WriteMmio16Swap(IOPortBase, port, val);
d1171 1
a1171 1
   xf86WriteMmio32Swap(IOPortBase, port, val);
d1177 1
a1177 1
   return xf86ReadMmio8(IOPortBase, port);
d1183 1
a1183 1
   return xf86ReadMmio16Swap(IOPortBase, port);
d1189 1
a1189 1
   return xf86ReadMmio32Swap(IOPortBase, port);
d1192 2
a1193 1
static __inline__ unsigned long ldq_u(unsigned long *p)
d1195 2
a1196 2
	unsigned long addr = (unsigned long)p;
	unsigned int ret;
d1198 5
a1202 7
	__asm__ __volatile__(
				  "lmw.bi %0, [%1], %0, 0;\n\t"
	           "wsbh %0, %0;\n\t"
				  "rotri %0, %0, 16;\n\t"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
d1205 2
a1206 1
static __inline__ unsigned long ldl_u(unsigned int *p)
d1208 6
a1213 2
	unsigned long addr = (unsigned long)p;
	unsigned int ret;
d1215 1
a1215 7
	__asm__ __volatile__(
				  "lmw.bi %0, [%1], %0, 0;\n\t"
	           "wsbh %0, %0;\n\t"
				  "rotri %0, %0, 16;\n\t"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
d1218 2
a1219 1
static __inline__ void stq_u(unsigned long val, unsigned long *p)
d1221 1
a1221 1
	unsigned long addr = (unsigned long)p;
d1223 2
a1224 6
	__asm__ __volatile__(
	           "wsbh %0, %0;\n\t"
				  "rotri %0, %0, 16;\n\t"
				  "smw.bi %0, [%1], %0, 0;\n\t"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
d1227 2
a1228 1
static __inline__ void stl_u(unsigned long val, unsigned int *p)
d1230 1
a1230 1
	unsigned long addr = (unsigned long)p;
d1232 2
a1233 6
	__asm__ __volatile__(
	           "wsbh %0, %0;\n\t"
				  "rotri %0, %0, 16;\n\t"
				  "smw.bi %0, [%1], %0, 0;\n\t"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
d1236 1
a1236 1
#    else /* !NDS32_MMIO_SWAP */
d1240 2
a1241 2
	*(volatile unsigned char*)(((unsigned PORT_SIZE)(port))) = val;
	barrier();
d1247 2
a1248 2
	*(volatile unsigned short*)(((unsigned PORT_SIZE)(port))) = val;
	barrier();
d1254 2
a1255 2
	*(volatile unsigned int*)(((unsigned PORT_SIZE)(port))) = val;
	barrier();
d1257 1
d1261 1
a1261 1
	return *(volatile unsigned char*)(((unsigned PORT_SIZE)(port)));
d1267 1
a1267 1
	return *(volatile unsigned short*)(((unsigned PORT_SIZE)(port)));
d1273 1
a1273 1
	return *(volatile unsigned int*)(((unsigned PORT_SIZE)(port)));
d1276 2
a1277 1
static __inline__ unsigned long ldq_u(unsigned long *p)
d1279 2
a1280 2
	unsigned long addr = (unsigned long)p;
	unsigned int ret;
d1282 4
a1285 5
	__asm__ __volatile__(
				  "lmw.bi %0, [%1], %0, 0;\n\t"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
d1288 2
a1289 1
static __inline__ unsigned long ldl_u(unsigned int *p)
d1291 5
a1295 2
	unsigned long addr = (unsigned long)p;
	unsigned int ret;
d1297 1
a1297 5
	__asm__ __volatile__(
				  "lmw.bi %0, [%1], %0, 0;\n\t"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
d1300 2
a1301 2

static __inline__ void stq_u(unsigned long val, unsigned long *p)
d1303 1
a1303 1
	unsigned long addr = (unsigned long)p;
d1305 2
a1306 4
	__asm__ __volatile__(
				  "smw.bi %0, [%1], %0, 0;\n\t"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
d1309 2
a1310 1
static __inline__ void stl_u(unsigned long val, unsigned int *p)
d1312 1
a1312 1
	unsigned long addr = (unsigned long)p;
d1314 2
a1315 4
	__asm__ __volatile__(
				  "smw.bi %0, [%1], %0, 0;\n\t"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
d1317 1
a1317 1
#    endif /* NDS32_MMIO_SWAP */
d1319 2
a1320 2
#    if (((X_BYTE_ORDER == X_BIG_ENDIAN) && !defined(NDS32_MMIO_SWAP)) || ((X_BYTE_ORDER != X_BIG_ENDIAN) && defined(NDS32_MMIO_SWAP)))
#    define ldw_u(p)	((*(unsigned char *)(p)) << 8 | \
d1322 1
a1322 1
#    define stw_u(v,p)	(*(unsigned char *)(p)) = ((v) >> 8); \
d1324 2
a1325 2
#    else
#    define ldw_u(p)	((*(unsigned char *)(p)) | \
d1327 1
a1327 1
#    define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
d1329 1
a1329 1
#    endif
d1331 2
a1332 2
#    define mem_barrier()         /* XXX: nop for now */
#    define write_mem_barrier()   /* XXX: nop for now */
d1334 1
a1334 1
#   else /* ix86 */
d1336 3
a1338 3
#    if !defined(__SUNPRO_C)
#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && !defined(__m32r__)
#     ifdef GCCUSESGAS
d1348 1
a1348 1
   __asm__ __volatile__("outb %0,%1" : :"a" (val), "d" (port));
a1350 1

d1354 1
a1354 1
   __asm__ __volatile__("outw %0,%1" : :"a" (val), "d" (port));
d1360 1
a1360 1
   __asm__ __volatile__("outl %0,%1" : :"a" (val), "d" (port));
d1366 4
a1369 5
   unsigned char ret;
   __asm__ __volatile__("inb %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
d1375 4
a1378 5
   unsigned short ret;
   __asm__ __volatile__("inw %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
d1384 4
a1387 5
   unsigned int ret;
   __asm__ __volatile__("inl %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
d1390 1
a1390 1
#     else	/* GCCUSESGAS */
d1395 1
a1395 1
  __asm__ __volatile__("out%B0 (%1)" : :"a" (val), "d" (port));
d1401 1
a1401 1
  __asm__ __volatile__("out%W0 (%1)" : :"a" (val), "d" (port));
d1407 1
a1407 1
  __asm__ __volatile__("out%L0 (%1)" : :"a" (val), "d" (port));
d1413 4
a1416 5
  unsigned char ret;
  __asm__ __volatile__("in%B0 (%1)" :
		   "=a" (ret) :
		   "d" (port));
  return ret;
d1422 4
a1425 5
  unsigned short ret;
  __asm__ __volatile__("in%W0 (%1)" :
		   "=a" (ret) :
		   "d" (port));
  return ret;
d1431 4
a1434 5
  unsigned int ret;
  __asm__ __volatile__("in%L0 (%1)" :
                   "=a" (ret) :
                   "d" (port));
  return ret;
d1437 1
a1437 1
#     endif /* GCCUSESGAS */
d1439 1
a1439 1
#    else /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__m32r__) */
d1459 1
a1459 1
  return 0;
d1465 1
a1465 1
  return 0;
d1471 1
a1471 1
  return 0;
d1474 2
a1475 2
#    endif /* FAKEIT */
#    endif /* __SUNPRO_C */
d1477 1
a1477 1
#   endif /* ix86 */
d1479 10
a1488 10
#  else /* !GNUC */
#    if defined(__STDC__) && (__STDC__ == 1)
#     ifndef asm
#      define asm __asm
#     endif
#    endif
#     if !defined(__SUNPRO_C)
#      include <sys/inline.h>
#     endif
#    if !defined(__HIGHC__) && !defined(__SUNPRO_C) || \
d1490 8
a1497 8
#     pragma asm partial_optimization outl
#     pragma asm partial_optimization outw
#     pragma asm partial_optimization outb
#     pragma asm partial_optimization inl
#     pragma asm partial_optimization inw
#     pragma asm partial_optimization inb
#    endif
#  endif /* __GNUC__ */
d1499 1
a1499 1
# endif /* NO_INLINE */
d1501 1
a1501 1
# ifdef __alpha__
d1503 6
a1508 5
extern _X_EXPORT int (*xf86ReadMmio8)(void *, unsigned long);
extern _X_EXPORT int (*xf86ReadMmio16)(void *, unsigned long);
#  ifndef STANDALONE_MMIO
extern _X_EXPORT int (*xf86ReadMmio32)(void *, unsigned long);
#  else
d1513 2
a1514 2
	mem_barrier();
	return *(volatile unsigned int*)((unsigned long)Base+(Offset));
d1516 9
a1524 8
#  endif
extern _X_EXPORT void (*xf86WriteMmio8)(int, void *, unsigned long);
extern _X_EXPORT void (*xf86WriteMmio16)(int, void *, unsigned long);
extern _X_EXPORT void (*xf86WriteMmio32)(int, void *, unsigned long);
extern _X_EXPORT void (*xf86WriteMmioNB8)(int, void *, unsigned long);
extern _X_EXPORT void (*xf86WriteMmioNB16)(int, void *, unsigned long);
extern _X_EXPORT void (*xf86WriteMmioNB32)(int, void *, unsigned long);
extern _X_EXPORT void xf86SlowBCopyFromBus(unsigned char *, unsigned char *, int);
d1529 7
a1535 7
#  define MMIO_IN8(base, offset) (*xf86ReadMmio8)(base, offset)
#  define MMIO_IN16(base, offset) (*xf86ReadMmio16)(base, offset)
#  ifndef STANDALONE_MMIO
#   define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)
#  else
#   define MMIO_IN32(base, offset) xf86ReadMmio32(base, offset)
#  endif
d1537 1
a1537 1
#  define MMIO_OUT32(base, offset, val) \
d1542 1
a1542 1
#  define MMIO_ONB32(base, offset, val) \
d1545 1
a1545 1
#  define MMIO_OUT8(base, offset, val) \
d1547 1
a1547 1
#  define MMIO_OUT16(base, offset, val) \
d1549 1
a1549 1
#  define MMIO_ONB8(base, offset, val) \
d1551 1
a1551 1
#  define MMIO_ONB16(base, offset, val) \
d1553 1
a1553 1
#  define MMIO_MOVE32(base, offset, val) \
d1556 1
a1556 1
# elif defined(__powerpc__)  
d1562 2
a1563 2
#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#  define MMIO_OUT8(base, offset, val) \
d1565 1
a1565 1
#  define MMIO_ONB8(base, offset, val) \
d1568 4
a1571 4
#  if defined(PPC_MMIO_IS_BE) /* No byteswapping */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#   define MMIO_OUT16(base, offset, val) \
d1573 1
a1573 1
#   define MMIO_OUT32(base, offset, val) \
d1575 1
a1575 1
#   define MMIO_ONB16(base, offset, val) \
d1577 1
a1577 1
#   define MMIO_ONB32(base, offset, val) \
d1579 4
a1582 4
#  else /* byteswapping is the default */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#   define MMIO_OUT16(base, offset, val) \
d1584 1
a1584 1
#   define MMIO_OUT32(base, offset, val) \
d1586 1
a1586 1
#   define MMIO_ONB16(base, offset, val) \
d1588 1
a1588 1
#   define MMIO_ONB32(base, offset, val) \
d1590 1
a1590 1
#  endif
d1592 1
a1592 1
#  define MMIO_MOVE32(base, offset, val) \
d1595 1
a1595 1
# elif defined(__sparc__) || defined(sparc) || defined(__sparc)
d1603 2
a1604 2
#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#  define MMIO_OUT8(base, offset, val) \
d1606 1
a1606 1
#  define MMIO_ONB8(base, offset, val) \
d1609 4
a1612 4
#  if defined(SPARC_MMIO_IS_BE) /* No byteswapping */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#   define MMIO_OUT16(base, offset, val) \
d1614 1
a1614 1
#   define MMIO_OUT32(base, offset, val) \
d1616 1
a1616 1
#   define MMIO_ONB16(base, offset, val) \
d1618 1
a1618 1
#   define MMIO_ONB32(base, offset, val) \
d1620 4
a1623 4
#  else /* byteswapping is the default */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#   define MMIO_OUT16(base, offset, val) \
d1625 1
a1625 1
#   define MMIO_OUT32(base, offset, val) \
d1627 1
a1627 1
#   define MMIO_ONB16(base, offset, val) \
d1629 1
a1629 1
#   define MMIO_ONB32(base, offset, val) \
d1631 1
a1631 1
#  endif
d1633 1
a1633 1
#  define MMIO_MOVE32(base, offset, val) \
d1636 1
a1636 1
# elif defined(__nds32__)
d1643 2
a1644 2
#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#  define MMIO_OUT8(base, offset, val) \
d1646 1
a1646 1
#  define MMIO_ONB8(base, offset, val) \
d1649 4
a1652 4
#  if defined(NDS32_MMIO_SWAP) /* byteswapping */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Swap(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Swap(base, offset)
#   define MMIO_OUT16(base, offset, val) \
d1654 1
a1654 1
#   define MMIO_OUT32(base, offset, val) \
d1656 1
a1656 1
#   define MMIO_ONB16(base, offset, val) \
d1658 1
a1658 1
#   define MMIO_ONB32(base, offset, val) \
d1660 4
a1663 4
#  else /* no byteswapping is the default */
#   define MMIO_IN16(base, offset) xf86ReadMmio16(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32(base, offset)
#   define MMIO_OUT16(base, offset, val) \
d1665 1
a1665 1
#   define MMIO_OUT32(base, offset, val) \
d1667 1
a1667 1
#   define MMIO_ONB16(base, offset, val) \
d1669 1
a1669 1
#   define MMIO_ONB32(base, offset, val) \
d1671 1
a1671 1
#  endif
d1673 1
a1673 1
#  define MMIO_MOVE32(base, offset, val) \
d1676 3
a1678 2
#ifdef N1213_HC /* for NDS32 N1213 hardcore */
static __inline__ void nds32_flush_icache(char *addr)
d1680 4
a1683 7
	__asm__ volatile (
		"isync %0;"
		"msync;"
		"isb;"
		"cctl %0,L1I_VA_INVAL;"
		"isb;"
		: : "r"(addr) : "memory");
d1686 2
a1687 1
static __inline__ void nds32_flush_icache(char *addr)
d1689 1
a1689 4
	__asm__ volatile (
		"isync %0;"
		"isb;"
		: : "r"(addr) : "memory");
d1693 1
a1693 1
# else /* !__alpha__ && !__powerpc__ && !__sparc__ */
d1695 1
a1695 1
#  define MMIO_IN8(base, offset) \
d1697 1
a1697 1
#  define MMIO_IN16(base, offset) \
d1699 1
a1699 1
#  define MMIO_IN32(base, offset) \
d1701 1
a1701 1
#  define MMIO_OUT8(base, offset, val) \
d1703 1
a1703 1
#  define MMIO_OUT16(base, offset, val) \
d1705 1
a1705 1
#  define MMIO_OUT32(base, offset, val) \
d1707 3
a1709 3
#  define MMIO_ONB8(base, offset, val) MMIO_OUT8(base, offset, val) 
#  define MMIO_ONB16(base, offset, val) MMIO_OUT16(base, offset, val) 
#  define MMIO_ONB32(base, offset, val) MMIO_OUT32(base, offset, val) 
d1711 1
a1711 1
#  define MMIO_MOVE32(base, offset, val) MMIO_OUT32(base, offset, val)
d1713 1
a1713 1
# endif /* __alpha__ */
d1720 7
a1726 7
# ifdef __alpha__
#  define slowbcopy_tobus(src,dst,count) xf86SlowBCopyToBus(src,dst,count)
#  define slowbcopy_frombus(src,dst,count) xf86SlowBCopyFromBus(src,dst,count)
# else /* __alpha__ */
#  define slowbcopy_tobus(src,dst,count) xf86SlowBcopy(src,dst,count)
#  define slowbcopy_frombus(src,dst,count) xf86SlowBcopy(src,dst,count)
# endif /* __alpha__ */
d1728 1
a1728 1
#endif /* _COMPILER_H */
@


1.10
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d711 1
a711 1
#    ifdef __arm32__
a1527 10
#    ifndef SCO325
#     if defined(__UNIXWARE__)
#     /* avoid including <sys/types.h> for <sys/inline.h> on UnixWare */
#      define ushort unsigned short
#      define ushort_t unsigned short
#      define ulong unsigned long
#      define ulong_t unsigned long
#      define uint_t unsigned int
#      define uchar_t unsigned char
#     endif /* __UNIXWARE__ */
a1530 3
#    else
#     include "scoasm.h"
#    endif
@


1.9
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d106 1
a106 1
#   if !defined(__sparc__) && !defined(__sparc) && !defined(__arm32__) \
d117 1
a117 1
#   else /* __sparc__,  __arm32__, __alpha__*/
d126 1
a126 1
#   endif /* __sparc__,  __arm32__, __alpha__ */
d1021 349
d1689 61
@


1.8
log
@basic support for mips64el. ok miod@@.
@
text
@d58 20
d110 6
a115 6
extern void outb(unsigned short, unsigned char);
extern void outw(unsigned short, unsigned short);
extern void outl(unsigned short, unsigned int);
extern unsigned int inb(unsigned short);
extern unsigned int inw(unsigned short);
extern unsigned int inl(unsigned short);
d119 6
a124 6
extern void outb(unsigned long, unsigned char);
extern void outw(unsigned long, unsigned short);
extern void outl(unsigned long, unsigned int);
extern unsigned int inb(unsigned long);
extern unsigned int inw(unsigned long);
extern unsigned int inl(unsigned long);
d129 1
d142 1
d144 1
a144 1
# endif
d148 7
a154 1
#   if (defined(linux) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)) && (defined(__alpha__))
d156 5
a160 4
#    ifdef linux
/* for Linux on Alpha, we use the LIBC _inx/_outx routines */
/* note that the appropriate setup via "ioperm" needs to be done */
/*  *before* any inx/outx is done. */
d162 1
a162 6
extern void (*_alpha_outb)(char val, unsigned long port);
static __inline__ void
outb(unsigned long port, unsigned char val)
{
    _alpha_outb(val, port);
}
d164 2
a165 6
extern void (*_alpha_outw)(short val, unsigned long port);
static __inline__ void
outw(unsigned long port, unsigned short val)
{
    _alpha_outw(val, port);
}
d167 1
a167 6
extern void (*_alpha_outl)(int val, unsigned long port);
static __inline__ void
outl(unsigned long port, unsigned int val)
{
    _alpha_outl(val, port);
}
d169 2
a170 6
extern unsigned int (*_alpha_inb)(unsigned long port);
static __inline__ unsigned int
inb(unsigned long port)
{
  return _alpha_inb(port);
}
d172 1
a172 6
extern unsigned int (*_alpha_inw)(unsigned long port);
static __inline__ unsigned int
inw(unsigned long port)
{
  return _alpha_inw(port);
}
d174 22
a195 6
extern unsigned int (*_alpha_inl)(unsigned long port);
static __inline__ unsigned int
inl(unsigned long port)
{
  return _alpha_inl(port);
}
d197 1
a197 1
#    endif /* linux */
d199 6
a204 2
#    if (defined(__FreeBSD__) || defined(__OpenBSD__)) \
      && !defined(DO_PROTOTYPES)
d206 5
a210 4
/* for FreeBSD and OpenBSD on Alpha, we use the libio (resp. libalpha) */
/*  inx/outx routines */
/* note that the appropriate setup via "ioperm" needs to be done */
/*  *before* any inx/outx is done. */
d212 1
a212 6
extern void outb(unsigned int port, unsigned char val);
extern void outw(unsigned int port, unsigned short val);
extern void outl(unsigned int port, unsigned int val);
extern unsigned char inb(unsigned int port);
extern unsigned short inw(unsigned int port);
extern unsigned int inl(unsigned int port);
d214 6
a219 1
#    endif /* (__FreeBSD__ || __OpenBSD__ ) && !DO_PROTOTYPES */
d221 3
d225 3
a227 3
#if defined(__NetBSD__)
#include <machine/pio.h>
#endif /* __NetBSD__ */
a228 4
/*
 * inline functions to do unaligned accesses
 * from linux/include/asm-alpha/unaligned.h
 */
d230 2
a231 4
/*
 * EGCS 1.1 knows about arbitrary unaligned loads.  Define some
 * packed structures to talk about such things with.
 */
d233 1
a233 3
struct __una_u64 { unsigned long  x __attribute__((packed)); };
struct __una_u32 { unsigned int   x __attribute__((packed)); };
struct __una_u16 { unsigned short x __attribute__((packed)); };
d235 5
a239 4
/*
 * Elemental unaligned loads 
 */
/* let's try making these things static */
d241 1
a241 1
static __inline__ unsigned long ldq_u(unsigned long * r11)
d243 1
a243 2
#    if defined(__GNUC__)
	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
a244 12
#    else
	unsigned long r1,r2;
	__asm__("ldq_u %0,%3\n\t"
		"ldq_u %1,%4\n\t"
		"extql %0,%2,%0\n\t"
		"extqh %1,%2,%1"
		:"=&r" (r1), "=&r" (r2)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(const unsigned long *)(7+(char *) r11)));
	return r1 | r2;
#    endif
d247 1
a247 1
static __inline__ unsigned long ldl_u(unsigned int * r11)
d249 1
a249 2
#    if defined(__GNUC__)
	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
a250 12
#    else
	unsigned long r1,r2;
	__asm__("ldq_u %0,%3\n\t"
		"ldq_u %1,%4\n\t"
		"extll %0,%2,%0\n\t"
		"extlh %1,%2,%1"
		:"=&r" (r1), "=&r" (r2)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(const unsigned long *)(3+(char *) r11)));
	return r1 | r2;
#    endif
d253 1
a253 1
static __inline__ unsigned long ldw_u(unsigned short * r11)
d255 1
a255 2
#    if defined(__GNUC__)
	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
a256 12
#    else
	unsigned long r1,r2;
	__asm__("ldq_u %0,%3\n\t"
		"ldq_u %1,%4\n\t"
		"extwl %0,%2,%0\n\t"
		"extwh %1,%2,%1"
		:"=&r" (r1), "=&r" (r2)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(const unsigned long *)(1+(char *) r11)));
	return r1 | r2;
#    endif
d259 13
a271 3
/*
 * Elemental unaligned stores 
 */
d273 1
a273 1
static __inline__ void stq_u(unsigned long r5, unsigned long * r11)
d275 6
a280 5
#    if defined(__GNUC__)
	struct __una_u64 *ptr = (struct __una_u64 *) r11;
	ptr->x = r5;
#    else
	unsigned long r1,r2,r3,r4;
d282 5
a286 15
	__asm__("ldq_u %3,%1\n\t"
		"ldq_u %2,%0\n\t"
		"insqh %6,%7,%5\n\t"
		"insql %6,%7,%4\n\t"
		"mskqh %3,%7,%3\n\t"
		"mskql %2,%7,%2\n\t"
		"bis %3,%5,%3\n\t"
		"bis %2,%4,%2\n\t"
		"stq_u %3,%1\n\t"
		"stq_u %2,%0"
		:"=m" (*r11),
		 "=m" (*(unsigned long *)(7+(char *) r11)),
		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
		:"r" (r5), "r" (r11));
#    endif
d289 1
a289 1
static __inline__ void stl_u(unsigned long r5, unsigned int * r11)
d291 4
a294 5
#    if defined(__GNUC__)
	struct __una_u32 *ptr = (struct __una_u32 *) r11;
	ptr->x = r5;
#    else
	unsigned long r1,r2,r3,r4;
d296 5
a300 15
	__asm__("ldq_u %3,%1\n\t"
		"ldq_u %2,%0\n\t"
		"inslh %6,%7,%5\n\t"
		"insll %6,%7,%4\n\t"
		"msklh %3,%7,%3\n\t"
		"mskll %2,%7,%2\n\t"
		"bis %3,%5,%3\n\t"
		"bis %2,%4,%2\n\t"
		"stq_u %3,%1\n\t"
		"stq_u %2,%0"
		:"=m" (*r11),
		 "=m" (*(unsigned long *)(3+(char *) r11)),
		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
		:"r" (r5), "r" (r11));
#    endif
d303 1
a303 1
static __inline__ void stw_u(unsigned long r5, unsigned short * r11)
d305 3
a307 5
#    if defined(__GNUC__)
	struct __una_u16 *ptr = (struct __una_u16 *) r11;
	ptr->x = r5;
#    else
	unsigned long r1,r2,r3,r4;
d309 4
a312 15
	__asm__("ldq_u %3,%1\n\t"
		"ldq_u %2,%0\n\t"
		"inswh %6,%7,%5\n\t"
		"inswl %6,%7,%4\n\t"
		"mskwh %3,%7,%3\n\t"
		"mskwl %2,%7,%2\n\t"
		"bis %3,%5,%3\n\t"
		"bis %2,%4,%2\n\t"
		"stq_u %3,%1\n\t"
		"stq_u %2,%0"
		:"=m" (*r11),
		 "=m" (*(unsigned long *)(1+(char *) r11)),
		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
		:"r" (r5), "r" (r11));
#    endif
d315 5
a319 15
/* to flush the I-cache before jumping to code which just got loaded */
#ifdef __FreeBSD__
#    define PAL_imb 134
#endif
#ifdef __OpenBSD__
#include <machine/pal.h>
#endif
#    define istream_mem_barrier() \
	__asm__ __volatile__("call_pal %0 #imb" : : "i" (PAL_imb) : "memory")
#    define mem_barrier()        __asm__ __volatile__("mb"  : : : "memory")
#    ifdef __ELF__
#     define write_mem_barrier()  __asm__ __volatile__("wmb" : : : "memory")
#    else  /*  ECOFF gas 2.6 doesn't know "wmb" :-(  */
#     define write_mem_barrier()  mem_barrier()
#    endif
d321 2
d324 3
a326 3
#   elif defined(linux) && defined(__ia64__) 
 
#    include <inttypes.h>
d328 4
a331 1
#    include <sys/io.h>
d333 6
a338 3
struct __una_u64 { uint64_t x __attribute__((packed)); };
struct __una_u32 { uint32_t x __attribute__((packed)); };
struct __una_u16 { uint16_t x __attribute__((packed)); };
d340 2
a341 2
static __inline__ unsigned long
__uldq (const unsigned long * r11)
d343 1
a343 2
	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
	return ptr->x;
d346 2
a347 2
static __inline__ unsigned long
__uldl (const unsigned int * r11)
d349 1
a349 2
	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
	return ptr->x;
d352 2
a353 2
static __inline__ unsigned long
__uldw (const unsigned short * r11)
d355 1
a355 2
	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
	return ptr->x;
d358 2
a359 2
static __inline__ void
__ustq (unsigned long r5, unsigned long * r11)
d361 1
a361 2
	struct __una_u64 *ptr = (struct __una_u64 *) r11;
	ptr->x = r5;
d364 2
a365 2
static __inline__ void
__ustl (unsigned long r5, unsigned int * r11)
d367 1
a367 2
	struct __una_u32 *ptr = (struct __una_u32 *) r11;
	ptr->x = r5;
d370 2
a371 2
static __inline__ void
__ustw (unsigned long r5, unsigned short * r11)
d373 1
a373 2
	struct __una_u16 *ptr = (struct __una_u16 *) r11;
	ptr->x = r5;
d376 19
a394 6
#    define ldq_u(p)	__uldq(p)
#    define ldl_u(p)	__uldl(p)
#    define ldw_u(p)	__uldw(p) 
#    define stq_u(v,p)	__ustq(v,p)
#    define stl_u(v,p)	__ustl(v,p)
#    define stw_u(v,p)	__ustw(v,p)
d396 9
a404 8
#    ifndef __INTEL_COMPILER  
#      define mem_barrier()        __asm__ __volatile__ ("mf" ::: "memory")
#      define write_mem_barrier()  __asm__ __volatile__ ("mf" ::: "memory")
#    else
#      include "ia64intrin.h"
#      define mem_barrier() __mf()
#      define write_mem_barrier() __mf()
#    endif
a405 21
/*
 * This is overkill, but for different reasons depending on where it is used.
 * This is thus general enough to be used everywhere cache flushes are needed.
 * It doesn't handle memory access serialisation by other processors, though.
 */
#    ifndef __INTEL_COMPILER
#       define ia64_flush_cache(Addr) \
	__asm__ __volatile__ ( \
		"fc.i %0;;;" \
		"sync.i;;;" \
		"mf;;;" \
		"srlz.i;;;" \
		:: "r"(Addr) : "memory")
#    else
#      define ia64_flush_cache(Addr) { \
        __fc(Addr);\
        __synci();\
        __mf();\
        __isrlz();\
       }
#    endif
d412 6
a417 6
extern void outb(unsigned long port, unsigned char val);
extern void outw(unsigned long port, unsigned short val);
extern void outl(unsigned long port, unsigned int val);
extern unsigned int inb(unsigned long port);
extern unsigned int inw(unsigned long port);
extern unsigned int inl(unsigned long port);
d419 1
a419 1
#   elif (defined(__OpenBSD__) || defined(linux)) && defined(__amd64__)
a422 13
#    define ldq_u(p)	(*((unsigned long  *)(p)))
#    define ldl_u(p)	(*((unsigned int   *)(p)))
#    define ldw_u(p)	(*((unsigned short *)(p)))
#    define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#    define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#    define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
  
#    define mem_barrier() \
       __asm__ __volatile__ ("lock; addl $0,0(%%rsp)": : :"memory")
#    define write_mem_barrier() \
       __asm__ __volatile__ ("": : :"memory")


a477 2
#     define barrier() __asm__ __volatile__(".word 0x8143e00a": : :"memory")

a709 92

/*
 * EGCS 1.1 knows about arbitrary unaligned loads.  Define some
 * packed structures to talk about such things with.
 */

#    if defined(__arch64__) || defined(__sparcv9)
struct __una_u64 { unsigned long  x __attribute__((packed)); };
#    endif
struct __una_u32 { unsigned int   x __attribute__((packed)); };
struct __una_u16 { unsigned short x __attribute__((packed)); };

static __inline__ unsigned long ldq_u(unsigned long *p)
{
#    if defined(__GNUC__)
#     if defined(__arch64__) || defined(__sparcv9)
	const struct __una_u64 *ptr = (const struct __una_u64 *) p;
#     else
	const struct __una_u32 *ptr = (const struct __una_u32 *) p;
#     endif
	return ptr->x;
#    else
	unsigned long ret;
	memmove(&ret, p, sizeof(*p));
	return ret;
#    endif
}

static __inline__ unsigned long ldl_u(unsigned int *p)
{
#    if defined(__GNUC__)
	const struct __una_u32 *ptr = (const struct __una_u32 *) p;
	return ptr->x;
#    else
	unsigned int ret;
	memmove(&ret, p, sizeof(*p));
	return ret;
#    endif
}

static __inline__ unsigned long ldw_u(unsigned short *p)
{
#    if defined(__GNUC__)
	const struct __una_u16 *ptr = (const struct __una_u16 *) p;
	return ptr->x;
#    else
	unsigned short ret;
	memmove(&ret, p, sizeof(*p));
	return ret;
#    endif
}

static __inline__ void stq_u(unsigned long val, unsigned long *p)
{
#    if defined(__GNUC__)
#     if defined(__arch64__) || defined(__sparcv9)
	struct __una_u64 *ptr = (struct __una_u64 *) p;
#     else
	struct __una_u32 *ptr = (struct __una_u32 *) p;
#     endif
	ptr->x = val;
#    else
	unsigned long tmp = val;
	memmove(p, &tmp, sizeof(*p));
#    endif
}

static __inline__ void stl_u(unsigned long val, unsigned int *p)
{
#    if defined(__GNUC__)
	struct __una_u32 *ptr = (struct __una_u32 *) p;
	ptr->x = val;
#    else
	unsigned int tmp = val;
	memmove(p, &tmp, sizeof(*p));
#    endif
}

static __inline__ void stw_u(unsigned long val, unsigned short *p)
{
#    if defined(__GNUC__)
	struct __una_u16 *ptr = (struct __una_u16 *) p;
	ptr->x = val;
#    else
	unsigned short tmp = val;
	memmove(p, &tmp, sizeof(*p));
#    endif
}

#    define mem_barrier()         /* XXX: nop for now */
#    define write_mem_barrier()   /* XXX: nop for now */

d711 1
a711 1
#    if defined(__arm32__) || defined(__mips64__)
a715 7
#    if defined(__arm__) && defined(__OpenBSD__)
/*
#     include <machine/sysarch.h>
*/
	int arm_sync_icache(long addr, int len);
#     define arm_flush_cache(addr)	arm_sync_icache((long)(addr), 4);
#    endif
d717 1
a717 1
unsigned int IOPortBase;  /* Memory mapped I/O port area */
a756 36
static __inline__ unsigned long ldq_u(unsigned long * r11)
{
	unsigned long r1;
	__asm__("lwr %0,%2\n\t"
		"lwl %0,%3\n\t"
		:"=&r" (r1)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(unsigned long *)(3+(char *) r11)));
	return r1;
}

static __inline__ unsigned long ldl_u(unsigned int * r11)
{
	unsigned long r1;
	__asm__("lwr %0,%2\n\t"
		"lwl %0,%3\n\t"
		:"=&r" (r1)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(unsigned long *)(3+(char *) r11)));
	return r1;
}

static __inline__ unsigned long ldw_u(unsigned short * r11)
{
	unsigned long r1;
	__asm__("lwr %0,%2\n\t"
		"lwl %0,%3\n\t"
		:"=&r" (r1)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(unsigned long *)(1+(char *) r11)));
	return r1;
}

a757 22

/*
 * EGCS 1.1 knows about arbitrary unaligned loads (and we don't support older
 * versions anyway. Define some packed structures to talk about such things
 * with.
 */

struct __una_u32 { unsigned int   x __attribute__((packed)); };
struct __una_u16 { unsigned short x __attribute__((packed)); };

static __inline__ void stw_u(unsigned long val, unsigned short *p)
{
	struct __una_u16 *ptr = (struct __una_u16 *) p;
	ptr->x = val;
}

static __inline__ void stl_u(unsigned long val, unsigned int *p)
{
	struct __una_u32 *ptr = (struct __una_u32 *) p;
	ptr->x = val;
}

a781 29

#      define mem_barrier() \
        __asm__ __volatile__(					\
		"# prevent instructions being moved around\n\t"	\
       		".set\tnoreorder\n\t"				\
		"# 8 nops to fool the R4400 pipeline\n\t"	\
		"nop;nop;nop;nop;nop;nop;nop;nop\n\t"		\
		".set\treorder"					\
		: /* no output */				\
		: /* no input */				\
		: "memory")
#      define write_mem_barrier() mem_barrier()

#     else  /* !linux */

#      define stq_u(v,p)	stl_u(v,p)
#      if X_BYTE_ORDER == X_BIG_ENDIAN
#       define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
			(*(unsigned char *)(p)+1) = ((v) >> 8);  \
			(*(unsigned char *)(p)+2) = ((v) >> 16); \
			(*(unsigned char *)(p)+3) = ((v) >> 24)

#       define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*(unsigned char *)(p)+1) = ((v) >> 8)
#      else
#       define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#       define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#      endif
#      define mem_barrier()   /* NOP */
a784 11
#    if defined(__arm32__)
#     define ldq_u(p)	(*((unsigned long  *)(p)))
#     define ldl_u(p)	(*((unsigned int   *)(p)))
#     define ldw_u(p)	(*((unsigned short *)(p)))
#     define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#     define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#     define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#     define mem_barrier()	/* NOP */
#     define write_mem_barrier()	/* NOP */
#    endif /* __arm32__ */

d791 1
a791 11
extern volatile unsigned char *ioBase;

#if defined(linux) && defined(__powerpc64__)
# include <linux/version.h>
# if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
#  include <asm/memory.h>
# endif
#endif /* defined(linux) && defined(__powerpc64__) */
#ifndef eieio /* We deal with arch-specific eieio() routines above... */
# define eieio() __asm__ __volatile__ ("eieio" ::: "memory")
#endif /* eieio */
a990 19
#    define ldq_u(p)	ldl_u(p)
#    define ldl_u(p)	((*(unsigned char *)(p))	| \
			(*((unsigned char *)(p)+1)<<8)	| \
			(*((unsigned char *)(p)+2)<<16)	| \
			(*((unsigned char *)(p)+3)<<24))
#    define ldw_u(p)	((*(unsigned char *)(p)) | \
			(*((unsigned char *)(p)+1)<<8))

#    define stq_u(v,p)	stl_u(v,p)
#    define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*((unsigned char *)(p)+1)) = ((v) >> 8);  \
				(*((unsigned char *)(p)+2)) = ((v) >> 16); \
				(*((unsigned char *)(p)+3)) = ((v) >> 24)
#    define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*((unsigned char *)(p)+1)) = ((v) >> 8)

#    define mem_barrier()	eieio()
#    define write_mem_barrier()	eieio()

a992 9
#define ldq_u(p)	(*((unsigned long  *)(p)))
#define ldl_u(p)	(*((unsigned int   *)(p)))
#define ldw_u(p)	(*((unsigned short *)(p)))
#define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#define mem_barrier()   /* NOP */
#define write_mem_barrier()   /* NOP */

a1020 10
#define arm_flush_cache(addr)						\
do {									\
  register unsigned long _beg __asm ("a1") = (unsigned long) (addr);	\
  register unsigned long _end __asm ("a2") = (unsigned long) (addr) + 4;\
  register unsigned long _flg __asm ("a3") = 0;				\
  __asm __volatile ("swi 0x9f0002		@@ sys_cacheflush"	\
    : "=r" (_beg)							\
    : "0" (_beg), "r" (_end), "r" (_flg));				\
} while (0)

a1022 9
#    define ldq_u(p)	(*((unsigned long  *)(p)))
#    define ldl_u(p)	(*((unsigned int   *)(p)))
#    define ldw_u(p)	(*((unsigned short *)(p)))
#    define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#    define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#    define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#    define mem_barrier()   /* NOP */
#    define write_mem_barrier()   /* NOP */

d1024 1
a1024 1
#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && !defined(__m32r__) && !defined(__vax__)
d1133 1
a1133 1
#    else /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__m32r__) && !defined(__vax__) */
a1203 8
#   define ldq_u(p)	(*((unsigned long  *)(p)))
#   define ldl_u(p)	(*((unsigned int   *)(p)))
#   define ldw_u(p)	(*((unsigned short *)(p)))
#   define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#   define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#   define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#   define mem_barrier()   /* NOP */
#   define write_mem_barrier()   /* NOP */
d1210 2
a1211 2
extern int (*xf86ReadMmio8)(void *, unsigned long);
extern int (*xf86ReadMmio16)(void *, unsigned long);
d1213 1
a1213 1
extern int (*xf86ReadMmio32)(void *, unsigned long);
d1219 1
a1219 1
	__asm__ __volatile__("mb"  : : : "memory");
d1223 8
a1230 8
extern void (*xf86WriteMmio8)(int, void *, unsigned long);
extern void (*xf86WriteMmio16)(int, void *, unsigned long);
extern void (*xf86WriteMmio32)(int, void *, unsigned long);
extern void (*xf86WriteMmioNB8)(int, void *, unsigned long);
extern void (*xf86WriteMmioNB16)(int, void *, unsigned long);
extern void (*xf86WriteMmioNB32)(int, void *, unsigned long);
extern void xf86SlowBCopyFromBus(unsigned char *, unsigned char *, int);
extern void xf86SlowBCopyToBus(unsigned char *, unsigned char *, int);
a1298 11

static __inline__ void ppc_flush_icache(char *addr)
{
	__asm__ volatile (
		"dcbf 0,%0;" 
		"sync;" 
		"icbi 0,%0;" 
		"sync;" 
		"isync;" 
		: : "r"(addr) : "memory");
}
@


1.7
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d872 1
a872 1
#    ifdef __arm32__
d1024 2
a1025 1
#      define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
d1030 1
a1030 1
#      define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
d1032 4
a1035 1

@


1.6
log
@provide mem_barrier() definition for amd64 too. from X.Org git. ok oga@@
@
text
@d78 4
a81 37
# if defined(IODEBUG) && defined(__GNUC__)
#  define outb RealOutb
#  define outw RealOutw
#  define outl RealOutl
#  define inb RealInb
#  define inw RealInw
#  define inl RealInl
# endif

# if defined(QNX4) /* Do this for now to keep Watcom happy */
#  define outb outp
#  define outw outpw
#  define outl outpd 
#  define inb inp
#  define inw inpw
#  define inl inpd

/* Define the ffs function for inlining */
extern int ffs(unsigned long);
#  pragma aux ffs_ = \
        "bsf edx, eax"          \
        "jnz bits_set"          \
        "xor eax, eax"          \
        "jmp exit1"             \
        "bits_set:"             \
        "mov eax, edx"          \
        "inc eax"               \
        "exit1:"                \
        __parm [eax]            \
        __modify [eax edx]      \
        __value [eax]           \
        ;
# endif

# if defined(__SUNPRO_C)
#  define DO_PROTOTYPES
# endif
d220 1
a220 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d239 1
a239 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d258 1
a258 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d281 1
a281 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d306 1
a306 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d331 1
a331 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d473 1
a473 1
#   elif (defined(linux) || defined(__OpenBSD__))  && (defined(__amd64__) || defined(__x86_64__))
d539 1
a539 1
#   elif (defined(linux) || defined(Lynx) || defined(sun) || defined(__OpenBSD__) || defined(__FreeBSD__)) && defined(__sparc__)
a540 1
#    if !defined(Lynx)
a778 1
#    endif	/* !Lynx */
d793 1
a793 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d809 1
a809 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d821 1
a821 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d833 1
a833 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d848 1
a848 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d859 1
a859 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d1047 1
a1047 1
#   elif (defined(Lynx) || defined(linux) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__)) && defined(__powerpc__)
d1343 1
a1343 1
#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && !defined(__vax__)
d1452 1
a1452 1
#    else /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__vax__) */
a1492 1
#   if !defined(QNX4)
d1508 1
a1508 1
#     if !defined(sgi) && !defined(__SUNPRO_C)
d1514 1
a1514 1
#    if (!defined(__HIGHC__) && !defined(sgi) && !defined(__SUNPRO_C)) || \
a1522 1
#   endif
a1532 26
#  if defined(QNX4)
#   include <sys/types.h>
extern unsigned  inb(unsigned port);
extern unsigned  inw(unsigned port);
extern unsigned  inl(unsigned port);
extern void outb(unsigned port, unsigned val);
extern void outw(unsigned port, unsigned val);
extern void outl(unsigned port, unsigned val);
#  endif /* QNX4 */

#  if defined(IODEBUG) && defined(__GNUC__)
#   undef inb
#   undef inw
#   undef inl
#   undef outb
#   undef outw
#   undef outl
#   define inb(a) __extension__ ({unsigned char __c=RealInb(a); ErrorF("inb(0x%03x) = 0x%02x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
#   define inw(a) __extension__ ({unsigned short __c=RealInw(a); ErrorF("inw(0x%03x) = 0x%04x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
#   define inl(a) __extension__ ({unsigned int __c=RealInl(a); ErrorF("inl(0x%03x) = 0x%08x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})

#   define outb(a,b) (ErrorF("outb(0x%03x, 0x%02x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutb(a,b))
#   define outw(a,b) (ErrorF("outw(0x%03x, 0x%04x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutw(a,b))
#   define outl(a,b) (ErrorF("outl(0x%03x, 0x%08x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutl(a,b))
#  endif

a1555 2
extern void xf86JensenMemToBus(char *, long, long, int);
extern void xf86JensenBusToMem(char *, char *, unsigned long, int);
d1569 1
a1569 7
#  if defined (JENSEN_SUPPORT)
#   define MMIO_OUT32(base, offset, val) \
    (*xf86WriteMmio32)((CARD32)(val), base, offset)
#   define MMIO_ONB32(base, offset, val) \
    (*xf86WriteMmioNB32)((CARD32)(val), base, offset)
#  else
#   define MMIO_OUT32(base, offset, val) \
d1574 1
a1574 1
#   define MMIO_ONB32(base, offset, val) \
a1575 1
#  endif
@


1.5
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d506 1
a506 1
#   elif defined(linux) && (defined(__amd64__) || defined(__x86_64__))
@


1.4
log
@merge xserver 1.4, 1st pass
@
text
@d506 1
a506 1
#   elif defined(linux) && defined(__amd64__) 
@


1.3
log
@Build fixes for OpenBSD/zaurus:
- __arm32__ isn't defined by gcc on OpenBSD/arm
- ioperm_noop.c is needed in libxorgos
@
text
@a49 2
/* $XConsortium: compiler.h /main/16 1996/10/25 15:38:34 kaleb $ */

d119 1
a119 1
#   if !defined(__sparc__) && !defined(__arm32__) \
d1378 1
a1378 1
#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__vax__)
d1710 1
a1710 1
# elif defined(__sparc__) || defined(sparc)
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@d914 1
a914 1
#    if defined(__arm32__) && defined(__OpenBSD__)
@


1.1
log
@Initial revision
@
text
@d390 1
d392 4
d914 7
d1380 1
a1380 1
#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)
d1489 1
a1489 1
#    else /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)*/
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d50 2
d121 1
a121 1
#   if !defined(__sparc__) && !defined(__sparc) && !defined(__arm32__) \
d1368 1
a1368 1
#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__)
d1700 1
a1700 1
# elif defined(__sparc__) || defined(sparc) || defined(__sparc)
@

