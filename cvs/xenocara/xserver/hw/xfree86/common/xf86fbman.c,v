head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.15;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.15;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@
/*
 * Copyright (c) 1998-2001 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"

#include <X11/X.h>
#include "scrnintstr.h"
#include "regionstr.h"
#include "xf86fbman.h"

/*
#define DEBUG
*/

static DevPrivateKeyRec xf86FBManagerKeyRec;
static DevPrivateKey xf86FBManagerKey;

Bool
xf86RegisterOffscreenManager(ScreenPtr pScreen, FBManagerFuncsPtr funcs)
{

    xf86FBManagerKey = &xf86FBManagerKeyRec;

    if (!dixRegisterPrivateKey(&xf86FBManagerKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    dixSetPrivate(&pScreen->devPrivates, xf86FBManagerKey, funcs);

    return TRUE;
}

Bool
xf86FBManagerRunning(ScreenPtr pScreen)
{
    if (xf86FBManagerKey == NULL)
        return FALSE;

    if (!dixLookupPrivate(&pScreen->devPrivates, xf86FBManagerKey))
        return FALSE;

    return TRUE;
}

Bool
xf86RegisterFreeBoxCallback(ScreenPtr pScreen,
                            FreeBoxCallbackProcPtr FreeBoxCallback,
                            void *devPriv)
{
    FBManagerFuncsPtr funcs;

    if (xf86FBManagerKey == NULL)
        return FALSE;
    if (!(funcs = (FBManagerFuncsPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                       xf86FBManagerKey)))
        return FALSE;

    return (*funcs->RegisterFreeBoxCallback) (pScreen, FreeBoxCallback,
                                              devPriv);
}

FBAreaPtr
xf86AllocateOffscreenArea(ScreenPtr pScreen,
                          int w, int h,
                          int gran,
                          MoveAreaCallbackProcPtr moveCB,
                          RemoveAreaCallbackProcPtr removeCB, void *privData)
{
    FBManagerFuncsPtr funcs;

    if (xf86FBManagerKey == NULL)
        return NULL;
    if (!(funcs = (FBManagerFuncsPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                       xf86FBManagerKey)))
        return NULL;

    return (*funcs->AllocateOffscreenArea) (pScreen, w, h, gran, moveCB,
                                            removeCB, privData);
}

FBLinearPtr
xf86AllocateOffscreenLinear(ScreenPtr pScreen,
                            int length,
                            int gran,
                            MoveLinearCallbackProcPtr moveCB,
                            RemoveLinearCallbackProcPtr removeCB,
                            void *privData)
{
    FBManagerFuncsPtr funcs;

    if (xf86FBManagerKey == NULL)
        return NULL;
    if (!(funcs = (FBManagerFuncsPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                       xf86FBManagerKey)))
        return NULL;

    return (*funcs->AllocateOffscreenLinear) (pScreen, length, gran, moveCB,
                                              removeCB, privData);
}

void
xf86FreeOffscreenArea(FBAreaPtr area)
{
    FBManagerFuncsPtr funcs;

    if (!area)
        return;

    if (xf86FBManagerKey == NULL)
        return;
    if (!
        (funcs =
         (FBManagerFuncsPtr) dixLookupPrivate(&area->pScreen->devPrivates,
                                              xf86FBManagerKey)))
        return;

    (*funcs->FreeOffscreenArea) (area);

    return;
}

void
xf86FreeOffscreenLinear(FBLinearPtr linear)
{
    FBManagerFuncsPtr funcs;

    if (!linear)
        return;

    if (xf86FBManagerKey == NULL)
        return;
    if (!
        (funcs =
         (FBManagerFuncsPtr) dixLookupPrivate(&linear->pScreen->devPrivates,
                                              xf86FBManagerKey)))
        return;

    (*funcs->FreeOffscreenLinear) (linear);

    return;
}

Bool
xf86ResizeOffscreenArea(FBAreaPtr resize, int w, int h)
{
    FBManagerFuncsPtr funcs;

    if (!resize)
        return FALSE;

    if (xf86FBManagerKey == NULL)
        return FALSE;
    if (!
        (funcs =
         (FBManagerFuncsPtr) dixLookupPrivate(&resize->pScreen->devPrivates,
                                              xf86FBManagerKey)))
        return FALSE;

    return (*funcs->ResizeOffscreenArea) (resize, w, h);
}

Bool
xf86ResizeOffscreenLinear(FBLinearPtr resize, int size)
{
    FBManagerFuncsPtr funcs;

    if (!resize)
        return FALSE;

    if (xf86FBManagerKey == NULL)
        return FALSE;
    if (!
        (funcs =
         (FBManagerFuncsPtr) dixLookupPrivate(&resize->pScreen->devPrivates,
                                              xf86FBManagerKey)))
        return FALSE;

    return (*funcs->ResizeOffscreenLinear) (resize, size);
}

Bool
xf86QueryLargestOffscreenArea(ScreenPtr pScreen,
                              int *w, int *h,
                              int gran, int preferences, int severity)
{
    FBManagerFuncsPtr funcs;

    *w = 0;
    *h = 0;

    if (xf86FBManagerKey == NULL)
        return FALSE;
    if (!(funcs = (FBManagerFuncsPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                       xf86FBManagerKey)))
        return FALSE;

    return (*funcs->QueryLargestOffscreenArea) (pScreen, w, h, gran,
                                                preferences, severity);
}

Bool
xf86QueryLargestOffscreenLinear(ScreenPtr pScreen,
                                int *size, int gran, int severity)
{
    FBManagerFuncsPtr funcs;

    *size = 0;

    if (xf86FBManagerKey == NULL)
        return FALSE;
    if (!(funcs = (FBManagerFuncsPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                       xf86FBManagerKey)))
        return FALSE;

    return (*funcs->QueryLargestOffscreenLinear) (pScreen, size, gran,
                                                  severity);
}

Bool
xf86PurgeUnlockedOffscreenAreas(ScreenPtr pScreen)
{
    FBManagerFuncsPtr funcs;

    if (xf86FBManagerKey == NULL)
        return FALSE;
    if (!(funcs = (FBManagerFuncsPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                       xf86FBManagerKey)))
        return FALSE;

    return (*funcs->PurgeOffscreenAreas) (pScreen);
}

/************************************************************\

   Below is a specific implementation of an offscreen manager.

\************************************************************/

static DevPrivateKeyRec xf86FBScreenKeyRec;

#define xf86FBScreenKey (&xf86FBScreenKeyRec)

typedef struct _FBLink {
    FBArea area;
    struct _FBLink *next;
} FBLink, *FBLinkPtr;

typedef struct _FBLinearLink {
    FBLinear linear;
    int free;                   /* need to add free here as FBLinear is publicly accessible */
    FBAreaPtr area;             /* only used if allocation came from XY area */
    struct _FBLinearLink *next;
} FBLinearLink, *FBLinearLinkPtr;

typedef struct {
    ScreenPtr pScreen;
    RegionPtr InitialBoxes;
    RegionPtr FreeBoxes;
    FBLinkPtr UsedAreas;
    int NumUsedAreas;
    FBLinearLinkPtr LinearAreas;
    CloseScreenProcPtr CloseScreen;
    int NumCallbacks;
    FreeBoxCallbackProcPtr *FreeBoxesUpdateCallback;
    DevUnion *devPrivates;
} FBManager, *FBManagerPtr;

static void
SendCallFreeBoxCallbacks(FBManagerPtr offman)
{
    int i = offman->NumCallbacks;

    while (i--) {
        (*offman->FreeBoxesUpdateCallback[i]) (offman->pScreen,
                                               offman->FreeBoxes,
                                               offman->devPrivates[i].ptr);
    }
}

static Bool
localRegisterFreeBoxCallback(ScreenPtr pScreen,
                             FreeBoxCallbackProcPtr FreeBoxCallback,
                             void *devPriv)
{
    FBManagerPtr offman;
    FreeBoxCallbackProcPtr *newCallbacks;
    DevUnion *newPrivates;

    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    newCallbacks = reallocarray(offman->FreeBoxesUpdateCallback,
                                offman->NumCallbacks + 1,
                                sizeof(FreeBoxCallbackProcPtr));
    if (!newCallbacks)
        return FALSE;
    else
        offman->FreeBoxesUpdateCallback = newCallbacks;

    newPrivates = reallocarray(offman->devPrivates,
                               offman->NumCallbacks + 1,
                               sizeof(DevUnion));
    if (!newPrivates)
        return FALSE;
    else
        offman->devPrivates = newPrivates;

    offman->FreeBoxesUpdateCallback[offman->NumCallbacks] = FreeBoxCallback;
    offman->devPrivates[offman->NumCallbacks].ptr = devPriv;
    offman->NumCallbacks++;

    SendCallFreeBoxCallbacks(offman);

    return TRUE;
}

static FBAreaPtr
AllocateArea(FBManagerPtr offman,
             int w, int h,
             int granularity,
             MoveAreaCallbackProcPtr moveCB,
             RemoveAreaCallbackProcPtr removeCB, void *privData)
{
    ScreenPtr pScreen = offman->pScreen;
    FBLinkPtr link = NULL;
    FBAreaPtr area = NULL;
    RegionRec NewReg;
    int i, x = 0, num;
    BoxPtr boxp;

    if (granularity <= 1)
        granularity = 0;

    boxp = RegionRects(offman->FreeBoxes);
    num = RegionNumRects(offman->FreeBoxes);

    /* look through the free boxes */
    for (i = 0; i < num; i++, boxp++) {
        x = boxp->x1;
        if (granularity > 1)
            x = ((x + granularity - 1) / granularity) * granularity;

        if (((boxp->y2 - boxp->y1) < h) || ((boxp->x2 - x) < w))
            continue;

        link = malloc(sizeof(FBLink));
        if (!link)
            return NULL;

        area = &(link->area);
        link->next = offman->UsedAreas;
        offman->UsedAreas = link;
        offman->NumUsedAreas++;
        break;
    }

    /* try to boot a removeable one out if we are not expendable ourselves */
    if (!area && !removeCB) {
        link = offman->UsedAreas;

        while (link) {
            if (!link->area.RemoveAreaCallback) {
                link = link->next;
                continue;
            }

            boxp = &(link->area.box);
            x = boxp->x1;
            if (granularity > 1)
                x = ((x + granularity - 1) / granularity) * granularity;

            if (((boxp->y2 - boxp->y1) < h) || ((boxp->x2 - x) < w)) {
                link = link->next;
                continue;
            }

            /* bye, bye */
            (*link->area.RemoveAreaCallback) (&link->area);
            RegionInit(&NewReg, &(link->area.box), 1);
            RegionUnion(offman->FreeBoxes, offman->FreeBoxes, &NewReg);
            RegionUninit(&NewReg);

            area = &(link->area);
            break;
        }
    }

    if (area) {
        area->pScreen = pScreen;
        area->granularity = granularity;
        area->box.x1 = x;
        area->box.x2 = x + w;
        area->box.y1 = boxp->y1;
        area->box.y2 = boxp->y1 + h;
        area->MoveAreaCallback = moveCB;
        area->RemoveAreaCallback = removeCB;
        area->devPrivate.ptr = privData;

        RegionInit(&NewReg, &(area->box), 1);
        RegionSubtract(offman->FreeBoxes, offman->FreeBoxes, &NewReg);
        RegionUninit(&NewReg);
    }

    return area;
}

static FBAreaPtr
localAllocateOffscreenArea(ScreenPtr pScreen,
                           int w, int h,
                           int gran,
                           MoveAreaCallbackProcPtr moveCB,
                           RemoveAreaCallbackProcPtr removeCB, void *privData)
{
    FBManagerPtr offman;
    FBAreaPtr area = NULL;

    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    if ((area = AllocateArea(offman, w, h, gran, moveCB, removeCB, privData)))
        SendCallFreeBoxCallbacks(offman);

    return area;
}

static void
localFreeOffscreenArea(FBAreaPtr area)
{
    FBManagerPtr offman;
    FBLinkPtr pLink, pLinkPrev = NULL;
    RegionRec FreedRegion;
    ScreenPtr pScreen;

    pScreen = area->pScreen;
    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    pLink = offman->UsedAreas;
    if (!pLink)
        return;

    while (&(pLink->area) != area) {
        pLinkPrev = pLink;
        pLink = pLink->next;
        if (!pLink)
            return;
    }

    /* put the area back into the pool */
    RegionInit(&FreedRegion, &(pLink->area.box), 1);
    RegionUnion(offman->FreeBoxes, offman->FreeBoxes, &FreedRegion);
    RegionUninit(&FreedRegion);

    if (pLinkPrev)
        pLinkPrev->next = pLink->next;
    else
        offman->UsedAreas = pLink->next;

    free(pLink);
    offman->NumUsedAreas--;

    SendCallFreeBoxCallbacks(offman);
}

static Bool
localResizeOffscreenArea(FBAreaPtr resize, int w, int h)
{
    FBManagerPtr offman;
    ScreenPtr pScreen;
    BoxRec OrigArea;
    RegionRec FreedReg;
    FBAreaPtr area = NULL;
    FBLinkPtr pLink, newLink, pLinkPrev = NULL;

    pScreen = resize->pScreen;
    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    /* find this link */
    if (!(pLink = offman->UsedAreas))
        return FALSE;

    while (&(pLink->area) != resize) {
        pLinkPrev = pLink;
        pLink = pLink->next;
        if (!pLink)
            return FALSE;
    }

    OrigArea.x1 = resize->box.x1;
    OrigArea.x2 = resize->box.x2;
    OrigArea.y1 = resize->box.y1;
    OrigArea.y2 = resize->box.y2;

    /* if it's smaller, this is easy */

    if ((w <= (resize->box.x2 - resize->box.x1)) &&
        (h <= (resize->box.y2 - resize->box.y1))) {
        RegionRec NewReg;

        resize->box.x2 = resize->box.x1 + w;
        resize->box.y2 = resize->box.y1 + h;

        if ((resize->box.y2 == OrigArea.y2) && (resize->box.x2 == OrigArea.x2))
            return TRUE;

        RegionInit(&FreedReg, &OrigArea, 1);
        RegionInit(&NewReg, &(resize->box), 1);
        RegionSubtract(&FreedReg, &FreedReg, &NewReg);
        RegionUnion(offman->FreeBoxes, offman->FreeBoxes, &FreedReg);
        RegionUninit(&FreedReg);
        RegionUninit(&NewReg);

        SendCallFreeBoxCallbacks(offman);

        return TRUE;
    }

    /* otherwise we remove the old region */

    RegionInit(&FreedReg, &OrigArea, 1);
    RegionUnion(offman->FreeBoxes, offman->FreeBoxes, &FreedReg);

    /* remove the old link */
    if (pLinkPrev)
        pLinkPrev->next = pLink->next;
    else
        offman->UsedAreas = pLink->next;

    /* and try to add a new one */

    if ((area = AllocateArea(offman, w, h, resize->granularity,
                             resize->MoveAreaCallback,
                             resize->RemoveAreaCallback,
                             resize->devPrivate.ptr))) {

        /* copy data over to our link and replace the new with old */
        memcpy(resize, area, sizeof(FBArea));

        pLinkPrev = NULL;
        newLink = offman->UsedAreas;

        while (&(newLink->area) != area) {
            pLinkPrev = newLink;
            newLink = newLink->next;
        }

        if (pLinkPrev)
            pLinkPrev->next = newLink->next;
        else
            offman->UsedAreas = newLink->next;

        pLink->next = offman->UsedAreas;
        offman->UsedAreas = pLink;

        free(newLink);

        /* AllocateArea added one but we really only exchanged one */
        offman->NumUsedAreas--;
    }
    else {
        /* reinstate the old region */
        RegionSubtract(offman->FreeBoxes, offman->FreeBoxes, &FreedReg);
        RegionUninit(&FreedReg);

        pLink->next = offman->UsedAreas;
        offman->UsedAreas = pLink;
        return FALSE;
    }

    RegionUninit(&FreedReg);

    SendCallFreeBoxCallbacks(offman);

    return TRUE;
}

static Bool
localQueryLargestOffscreenArea(ScreenPtr pScreen,
                               int *width, int *height,
                               int granularity, int preferences, int severity)
{
    FBManagerPtr offman;
    RegionPtr newRegion = NULL;
    BoxPtr pbox;
    int nbox;
    int x, w, h, area, oldArea;

    *width = *height = oldArea = 0;

    if (granularity <= 1)
        granularity = 0;

    if ((preferences < 0) || (preferences > 3))
        return FALSE;

    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    if (severity < 0)
        severity = 0;
    if (severity > 2)
        severity = 2;

    switch (severity) {
    case 2:
        if (offman->NumUsedAreas) {
            FBLinkPtr pLink;
            RegionRec tmpRegion;

            newRegion = RegionCreate(NULL, 1);
            RegionCopy(newRegion, offman->InitialBoxes);
            pLink = offman->UsedAreas;

            while (pLink) {
                if (!pLink->area.RemoveAreaCallback) {
                    RegionInit(&tmpRegion, &(pLink->area.box), 1);
                    RegionSubtract(newRegion, newRegion, &tmpRegion);
                    RegionUninit(&tmpRegion);
                }
                pLink = pLink->next;
            }

            nbox = RegionNumRects(newRegion);
            pbox = RegionRects(newRegion);
            break;
        }
    case 1:
        if (offman->NumUsedAreas) {
            FBLinkPtr pLink;
            RegionRec tmpRegion;

            newRegion = RegionCreate(NULL, 1);
            RegionCopy(newRegion, offman->FreeBoxes);
            pLink = offman->UsedAreas;

            while (pLink) {
                if (pLink->area.RemoveAreaCallback) {
                    RegionInit(&tmpRegion, &(pLink->area.box), 1);
                    RegionAppend(newRegion, &tmpRegion);
                    RegionUninit(&tmpRegion);
                }
                pLink = pLink->next;
            }

            nbox = RegionNumRects(newRegion);
            pbox = RegionRects(newRegion);
            break;
        }
    default:
        nbox = RegionNumRects(offman->FreeBoxes);
        pbox = RegionRects(offman->FreeBoxes);
        break;
    }

    while (nbox--) {
        x = pbox->x1;
        if (granularity > 1)
            x = ((x + granularity - 1) / granularity) * granularity;

        w = pbox->x2 - x;
        h = pbox->y2 - pbox->y1;
        area = w * h;

        if (w > 0) {
            Bool gotIt = FALSE;

            switch (preferences) {
            case FAVOR_AREA_THEN_WIDTH:
                if ((area > oldArea) || ((area == oldArea) && (w > *width)))
                    gotIt = TRUE;
                break;
            case FAVOR_AREA_THEN_HEIGHT:
                if ((area > oldArea) || ((area == oldArea) && (h > *height)))
                    gotIt = TRUE;
                break;
            case FAVOR_WIDTH_THEN_AREA:
                if ((w > *width) || ((w == *width) && (area > oldArea)))
                    gotIt = TRUE;
                break;
            case FAVOR_HEIGHT_THEN_AREA:
                if ((h > *height) || ((h == *height) && (area > oldArea)))
                    gotIt = TRUE;
                break;
            }
            if (gotIt) {
                *width = w;
                *height = h;
                oldArea = area;
            }
        }
        pbox++;
    }

    if (newRegion)
        RegionDestroy(newRegion);

    return TRUE;
}

static Bool
localPurgeUnlockedOffscreenAreas(ScreenPtr pScreen)
{
    FBManagerPtr offman;
    FBLinkPtr pLink, tmp, pPrev = NULL;
    RegionRec FreedRegion;
    Bool anyUsed = FALSE;

    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    pLink = offman->UsedAreas;
    if (!pLink)
        return TRUE;

    while (pLink) {
        if (pLink->area.RemoveAreaCallback) {
            (*pLink->area.RemoveAreaCallback) (&pLink->area);

            RegionInit(&FreedRegion, &(pLink->area.box), 1);
            RegionAppend(offman->FreeBoxes, &FreedRegion);
            RegionUninit(&FreedRegion);

            if (pPrev)
                pPrev->next = pLink->next;
            else
                offman->UsedAreas = pLink->next;

            tmp = pLink;
            pLink = pLink->next;
            free(tmp);
            offman->NumUsedAreas--;
            anyUsed = TRUE;
        }
        else {
            pPrev = pLink;
            pLink = pLink->next;
        }
    }

    if (anyUsed) {
        RegionValidate(offman->FreeBoxes, &anyUsed);
        SendCallFreeBoxCallbacks(offman);
    }

    return TRUE;
}

static void
LinearMoveCBWrapper(FBAreaPtr from, FBAreaPtr to)
{
    /* this will never get called */
}

static void
LinearRemoveCBWrapper(FBAreaPtr area)
{
    FBManagerPtr offman;
    FBLinearLinkPtr pLink, pLinkPrev = NULL;
    ScreenPtr pScreen = area->pScreen;

    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    pLink = offman->LinearAreas;
    if (!pLink)
        return;

    while (pLink->area != area) {
        pLinkPrev = pLink;
        pLink = pLink->next;
        if (!pLink)
            return;
    }

    /* give the user the callback it is expecting */
    (*pLink->linear.RemoveLinearCallback) (&(pLink->linear));

    if (pLinkPrev)
        pLinkPrev->next = pLink->next;
    else
        offman->LinearAreas = pLink->next;

    free(pLink);
}

static void
DumpDebug(FBLinearLinkPtr pLink)
{
#ifdef DEBUG
    if (!pLink)
        ErrorF("MMmm, PLINK IS NULL!\n");

    while (pLink) {
        ErrorF("  Offset:%08x, Size:%08x, %s,%s\n",
               pLink->linear.offset,
               pLink->linear.size,
               pLink->free ? "Free" : "Used", pLink->area ? "Area" : "Linear");

        pLink = pLink->next;
    }
#endif
}

static FBLinearPtr
AllocateLinear(FBManagerPtr offman, int size, int granularity, void *privData)
{
    ScreenPtr pScreen = offman->pScreen;
    FBLinearLinkPtr linear = NULL;
    FBLinearLinkPtr newlink = NULL;
    int offset, end;

    if (size <= 0)
        return NULL;

    if (!offman->LinearAreas)
        return NULL;

    linear = offman->LinearAreas;
    while (linear) {
        /* Make sure we get a free area that's not an XY fallback case */
        if (!linear->area && linear->free) {
            offset = linear->linear.offset;
            if (granularity > 1)
                offset =
                    ((offset + granularity - 1) / granularity) * granularity;
            end = offset + size;
            if (end <= (linear->linear.offset + linear->linear.size))
                break;
        }
        linear = linear->next;
    }
    if (!linear)
        return NULL;

    /* break left */
    if (offset > linear->linear.offset) {
        newlink = malloc(sizeof(FBLinearLink));
        if (!newlink)
            return NULL;
        newlink->area = NULL;
        newlink->linear.offset = offset;
        newlink->linear.size =
            linear->linear.size - (offset - linear->linear.offset);
        newlink->free = 1;
        newlink->next = linear->next;
        linear->linear.size -= newlink->linear.size;
        linear->next = newlink;
        linear = newlink;
    }

    /* break right */
    if (size < linear->linear.size) {
        newlink = malloc(sizeof(FBLinearLink));
        if (!newlink)
            return NULL;
        newlink->area = NULL;
        newlink->linear.offset = offset + size;
        newlink->linear.size = linear->linear.size - size;
        newlink->free = 1;
        newlink->next = linear->next;
        linear->linear.size = size;
        linear->next = newlink;
    }

    /* p = middle block */
    linear->linear.granularity = granularity;
    linear->free = 0;
    linear->linear.pScreen = pScreen;
    linear->linear.MoveLinearCallback = NULL;
    linear->linear.RemoveLinearCallback = NULL;
    linear->linear.devPrivate.ptr = NULL;

    DumpDebug(offman->LinearAreas);

    return &(linear->linear);
}

static FBLinearPtr
localAllocateOffscreenLinear(ScreenPtr pScreen,
                             int length,
                             int gran,
                             MoveLinearCallbackProcPtr moveCB,
                             RemoveLinearCallbackProcPtr removeCB,
                             void *privData)
{
    FBManagerPtr offman;
    FBLinearLinkPtr link;
    FBAreaPtr area;
    FBLinearPtr linear = NULL;
    BoxPtr extents;
    int w, h, pitch;

    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);

    /* Try to allocate from linear memory first...... */
    DebugF("ALLOCATING LINEAR\n");
    if ((linear = AllocateLinear(offman, length, gran, privData)))
        return linear;

    DebugF("NOPE, ALLOCATING AREA\n");

    if (!(link = malloc(sizeof(FBLinearLink))))
        return NULL;

    /* No linear available, so try and pinch some from the XY areas */
    extents = RegionExtents(offman->InitialBoxes);
    pitch = extents->x2 - extents->x1;

    if (gran > 1) {
        if (gran > pitch) {
            /* we can't match the specified alignment with XY allocations */
            free(link);
            return NULL;
        }

        if (pitch % gran) {
            /* pitch and granularity aren't a perfect match, let's allocate
             * a bit more so we can align later on
             */
            length += gran - 1;
        }
    }

    if (length < pitch) {       /* special case */
        w = length;
        h = 1;
    }
    else {
        w = pitch;
        h = (length + pitch - 1) / pitch;
    }

    if ((area = localAllocateOffscreenArea(pScreen, w, h, gran,
                                           moveCB ? LinearMoveCBWrapper : NULL,
                                           removeCB ? LinearRemoveCBWrapper :
                                           NULL, privData))) {
        link->area = area;
        link->free = 0;
        link->next = offman->LinearAreas;
        offman->LinearAreas = link;
        linear = &(link->linear);
        linear->pScreen = pScreen;
        linear->size = h * w;
        linear->offset = (pitch * area->box.y1) + area->box.x1;
        if (gran > 1)
            linear->offset = ((linear->offset + gran - 1) / gran) * gran;
        linear->granularity = gran;
        linear->MoveLinearCallback = moveCB;
        linear->RemoveLinearCallback = removeCB;
        linear->devPrivate.ptr = privData;
    }
    else
        free(link);

    DumpDebug(offman->LinearAreas);

    return linear;
}

static void
localFreeOffscreenLinear(FBLinearPtr linear)
{
    FBManagerPtr offman;
    FBLinearLinkPtr pLink, pLinkPrev = NULL;
    ScreenPtr pScreen = linear->pScreen;

    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    pLink = offman->LinearAreas;
    if (!pLink)
        return;

    while (&(pLink->linear) != linear) {
        pLinkPrev = pLink;
        pLink = pLink->next;
        if (!pLink)
            return;
    }

    if (pLink->area) {          /* really an XY area */
        DebugF("FREEING AREA\n");
        localFreeOffscreenArea(pLink->area);
        if (pLinkPrev)
            pLinkPrev->next = pLink->next;
        else
            offman->LinearAreas = pLink->next;
        free(pLink);
        DumpDebug(offman->LinearAreas);
        return;
    }

    pLink->free = 1;

    if (pLink->next && pLink->next->free) {
        FBLinearLinkPtr p = pLink->next;

        pLink->linear.size += p->linear.size;
        pLink->next = p->next;
        free(p);
    }

    if (pLinkPrev) {
        if (pLinkPrev->next && pLinkPrev->next->free && !pLinkPrev->area) {
            FBLinearLinkPtr p = pLinkPrev->next;

            pLinkPrev->linear.size += p->linear.size;
            pLinkPrev->next = p->next;
            free(p);
        }
    }

    DebugF("FREEING LINEAR\n");
    DumpDebug(offman->LinearAreas);
}

static Bool
localResizeOffscreenLinear(FBLinearPtr resize, int length)
{
    FBManagerPtr offman;
    FBLinearLinkPtr pLink;
    ScreenPtr pScreen = resize->pScreen;

    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    pLink = offman->LinearAreas;
    if (!pLink)
        return FALSE;

    while (&(pLink->linear) != resize) {
        pLink = pLink->next;
        if (!pLink)
            return FALSE;
    }

    /* This could actually be alot smarter and try to move allocations
       from XY to linear when available.  For now if it was XY, we keep
       it XY */

    if (pLink->area) {          /* really an XY area */
        BoxPtr extents;
        int pitch, w, h;

        extents = RegionExtents(offman->InitialBoxes);
        pitch = extents->x2 - extents->x1;

        if (length < pitch) {   /* special case */
            w = length;
            h = 1;
        }
        else {
            w = pitch;
            h = (length + pitch - 1) / pitch;
        }

        if (localResizeOffscreenArea(pLink->area, w, h)) {
            resize->size = h * w;
            resize->offset =
                (pitch * pLink->area->box.y1) + pLink->area->box.x1;
            return TRUE;
        }
    }
    else {
        /* TODO!!!! resize the linear area */
    }

    return FALSE;
}

static Bool
localQueryLargestOffscreenLinear(ScreenPtr pScreen,
                                 int *size, int gran, int priority)
{
    FBManagerPtr offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                          xf86FBScreenKey);
    FBLinearLinkPtr pLink;
    FBLinearLinkPtr pLinkRet;

    *size = 0;

    pLink = offman->LinearAreas;

    if (pLink && !pLink->area) {
        pLinkRet = pLink;
        while (pLink) {
            if (pLink->free) {
                if (pLink->linear.size > pLinkRet->linear.size)
                    pLinkRet = pLink;
            }
            pLink = pLink->next;
        }

        if (pLinkRet->free) {
            *size = pLinkRet->linear.size;
            return TRUE;
        }
    }
    else {
        int w, h;

        if (localQueryLargestOffscreenArea(pScreen, &w, &h, gran,
                                           FAVOR_WIDTH_THEN_AREA, priority)) {
            BoxPtr extents;

            extents = RegionExtents(offman->InitialBoxes);
            if ((extents->x2 - extents->x1) == w)
                *size = w * h;
            return TRUE;
        }
    }

    return FALSE;
}

static FBManagerFuncs xf86FBManFuncs = {
    localAllocateOffscreenArea,
    localFreeOffscreenArea,
    localResizeOffscreenArea,
    localQueryLargestOffscreenArea,
    localRegisterFreeBoxCallback,
    localAllocateOffscreenLinear,
    localFreeOffscreenLinear,
    localResizeOffscreenLinear,
    localQueryLargestOffscreenLinear,
    localPurgeUnlockedOffscreenAreas
};

static Bool
xf86FBCloseScreen(ScreenPtr pScreen)
{
    FBLinkPtr pLink, tmp;
    FBLinearLinkPtr pLinearLink, tmp2;
    FBManagerPtr offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                          xf86FBScreenKey);

    pScreen->CloseScreen = offman->CloseScreen;

    pLink = offman->UsedAreas;
    while (pLink) {
        tmp = pLink;
        pLink = pLink->next;
        free(tmp);
    }

    pLinearLink = offman->LinearAreas;
    while (pLinearLink) {
        tmp2 = pLinearLink;
        pLinearLink = pLinearLink->next;
        free(tmp2);
    }

    RegionDestroy(offman->InitialBoxes);
    RegionDestroy(offman->FreeBoxes);

    free(offman->FreeBoxesUpdateCallback);
    free(offman->devPrivates);
    free(offman);
    dixSetPrivate(&pScreen->devPrivates, xf86FBScreenKey, NULL);

    return (*pScreen->CloseScreen) (pScreen);
}

Bool
xf86InitFBManager(ScreenPtr pScreen, BoxPtr FullBox)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    RegionRec ScreenRegion;
    RegionRec FullRegion;
    BoxRec ScreenBox;
    Bool ret;

    ScreenBox.x1 = 0;
    ScreenBox.y1 = 0;
    ScreenBox.x2 = pScrn->virtualX;
    ScreenBox.y2 = pScrn->virtualY;

    if ((FullBox->x1 > ScreenBox.x1) || (FullBox->y1 > ScreenBox.y1) ||
        (FullBox->x2 < ScreenBox.x2) || (FullBox->y2 < ScreenBox.y2)) {
        return FALSE;
    }

    if (FullBox->y2 < FullBox->y1)
        return FALSE;
    if (FullBox->x2 < FullBox->x1)
        return FALSE;

    RegionInit(&ScreenRegion, &ScreenBox, 1);
    RegionInit(&FullRegion, FullBox, 1);

    RegionSubtract(&FullRegion, &FullRegion, &ScreenRegion);

    ret = xf86InitFBManagerRegion(pScreen, &FullRegion);

    RegionUninit(&ScreenRegion);
    RegionUninit(&FullRegion);

    return ret;
}

Bool
xf86InitFBManagerArea(ScreenPtr pScreen, int PixelArea, int Verbosity)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    xRectangle Rect[3];
    RegionPtr pRegion, pScreenRegion;
    int nRect;
    Bool ret = FALSE;

    if (PixelArea < (pScrn->displayWidth * pScrn->virtualY))
        return FALSE;

    Rect[0].x = Rect[0].y = 0;
    Rect[0].width = pScrn->displayWidth;
    Rect[0].height = PixelArea / pScrn->displayWidth;
    nRect = 1;

    /* Add a possible partial scanline */
    if ((Rect[1].height = Rect[1].width = PixelArea % pScrn->displayWidth)) {
        Rect[1].x = 0;
        Rect[1].y = Rect[0].height;
        Rect[1].height = 1;
        nRect++;
    }

    /* Factor out virtual resolution */
    pRegion = RegionFromRects(nRect, Rect, 0);
    if (pRegion) {
        if (!RegionNar(pRegion)) {
            Rect[2].x = Rect[2].y = 0;
            Rect[2].width = pScrn->virtualX;
            Rect[2].height = pScrn->virtualY;

            pScreenRegion = RegionFromRects(1, &Rect[2], 0);
            if (pScreenRegion) {
                if (!RegionNar(pScreenRegion)) {
                    RegionSubtract(pRegion, pRegion, pScreenRegion);

                    ret = xf86InitFBManagerRegion(pScreen, pRegion);

                    if (ret && xf86GetVerbosity() >= Verbosity) {
                        int scrnIndex = pScrn->scrnIndex;

                        xf86DrvMsgVerb(scrnIndex, X_INFO, Verbosity,
                                       "Largest offscreen areas (with overlaps):\n");

                        if (Rect[2].width < Rect[0].width) {
                            xf86DrvMsgVerb(scrnIndex, X_INFO, Verbosity,
                                           "\t%d x %d rectangle at %d,0\n",
                                           Rect[0].width - Rect[2].width,
                                           Rect[0].height, Rect[2].width);
                        }
                        if (Rect[2].width < Rect[1].width) {
                            xf86DrvMsgVerb(scrnIndex, X_INFO, Verbosity,
                                           "\t%d x %d rectangle at %d,0\n",
                                           Rect[1].width - Rect[2].width,
                                           Rect[0].height + Rect[1].height,
                                           Rect[2].width);
                        }
                        if (Rect[2].height < Rect[0].height) {
                            xf86DrvMsgVerb(scrnIndex, X_INFO, Verbosity,
                                           "\t%d x %d rectangle at 0,%d\n",
                                           Rect[0].width,
                                           Rect[0].height - Rect[2].height,
                                           Rect[2].height);
                        }
                        if (Rect[1].height) {
                            xf86DrvMsgVerb(scrnIndex, X_INFO, Verbosity,
                                           "\t%d x %d rectangle at 0,%d\n",
                                           Rect[1].width,
                                           Rect[0].height - Rect[2].height +
                                           Rect[1].height, Rect[2].height);
                        }
                    }
                }

                RegionDestroy(pScreenRegion);
            }
        }

        RegionDestroy(pRegion);
    }

    return ret;
}

Bool
xf86InitFBManagerRegion(ScreenPtr pScreen, RegionPtr FullRegion)
{
    FBManagerPtr offman;

    if (RegionNil(FullRegion))
        return FALSE;

    if (!dixRegisterPrivateKey(&xf86FBScreenKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    if (!xf86RegisterOffscreenManager(pScreen, &xf86FBManFuncs))
        return FALSE;

    offman = malloc(sizeof(FBManager));
    if (!offman)
        return FALSE;

    dixSetPrivate(&pScreen->devPrivates, xf86FBScreenKey, offman);

    offman->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = xf86FBCloseScreen;

    offman->InitialBoxes = RegionCreate(NULL, 1);
    offman->FreeBoxes = RegionCreate(NULL, 1);

    RegionCopy(offman->InitialBoxes, FullRegion);
    RegionCopy(offman->FreeBoxes, FullRegion);

    offman->pScreen = pScreen;
    offman->UsedAreas = NULL;
    offman->LinearAreas = NULL;
    offman->NumUsedAreas = 0;
    offman->NumCallbacks = 0;
    offman->FreeBoxesUpdateCallback = NULL;
    offman->devPrivates = NULL;

    return TRUE;
}

Bool
xf86InitFBManagerLinear(ScreenPtr pScreen, int offset, int size)
{
    FBManagerPtr offman;
    FBLinearLinkPtr link;
    FBLinearPtr linear;

    if (size <= 0)
        return FALSE;

    /* we expect people to have called the Area setup first for pixmap cache */
    if (!dixLookupPrivate(&pScreen->devPrivates, xf86FBScreenKey))
        return FALSE;

    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    offman->LinearAreas = malloc(sizeof(FBLinearLink));
    if (!offman->LinearAreas)
        return FALSE;

    link = offman->LinearAreas;
    link->area = NULL;
    link->next = NULL;
    link->free = 1;
    linear = &(link->linear);
    linear->pScreen = pScreen;
    linear->size = size;
    linear->offset = offset;
    linear->granularity = 0;
    linear->MoveLinearCallback = NULL;
    linear->RemoveLinearCallback = NULL;
    linear->devPrivate.ptr = NULL;

    return TRUE;
}

/* This is an implementation specific function and should
   disappear after the next release.  People should use the
   real linear functions instead */

FBAreaPtr
xf86AllocateLinearOffscreenArea(ScreenPtr pScreen,
                                int length,
                                int gran,
                                MoveAreaCallbackProcPtr moveCB,
                                RemoveAreaCallbackProcPtr removeCB,
                                void *privData)
{
    FBManagerFuncsPtr funcs;
    FBManagerPtr offman;
    BoxPtr extents;
    int w, h;

    if (xf86FBManagerKey == NULL)
        return NULL;
    if (!(funcs = (FBManagerFuncsPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                       xf86FBManagerKey)))
        return NULL;

    offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                             xf86FBScreenKey);
    extents = RegionExtents(offman->InitialBoxes);
    w = extents->x2 - extents->x1;

    if (gran > 1) {
        if (gran > w)
            return NULL;

        if (w % gran)
            length += gran - 1;
    }

    if (length <= w) {          /* special case */
        h = 1;
        w = length;
    }
    else {
        h = (length + w - 1) / w;
    }

    return (*funcs->AllocateOffscreenArea) (pScreen, w, h, gran, moveCB,
                                            removeCB, privData);
}
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d320 3
a322 3
    newCallbacks = realloc(offman->FreeBoxesUpdateCallback,
                           sizeof(FreeBoxCallbackProcPtr) *
                           (offman->NumCallbacks + 1));
d328 3
a330 2
    newPrivates = realloc(offman->devPrivates,
                          sizeof(DevUnion) * (offman->NumCallbacks + 1));
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d41 1
a41 1
/* 
d262 1
a262 1
/************************************************************\ 
d1384 1
a1384 1
/* This is an implementation specific function and should 
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d77 1
a77 1
                            pointer devPriv)
d96 1
a96 1
                          RemoveAreaCallbackProcPtr removeCB, pointer privData)
d116 1
a116 1
                            pointer privData)
d312 1
a312 1
                             pointer devPriv)
d349 1
a349 1
             RemoveAreaCallbackProcPtr removeCB, pointer privData)
d439 1
a439 1
                           RemoveAreaCallbackProcPtr removeCB, pointer privData)
d827 1
a827 1
AllocateLinear(FBManagerPtr offman, int size, int granularity, pointer privData)
d906 1
a906 1
                             pointer privData)
a1124 1
            FBManagerPtr offman;
a1126 2
            offman = (FBManagerPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                     xf86FBScreenKey);
d1394 1
a1394 1
                                pointer privData)
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d323 4
d330 1
a330 2

    if (!newCallbacks || !newPrivates)
d332 2
a333 3

    offman->FreeBoxesUpdateCallback = newCallbacks;
    offman->devPrivates = newPrivates;
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d1152 1
a1152 1
xf86FBCloseScreen(int i, ScreenPtr pScreen)
d1183 1
a1183 1
    return (*pScreen->CloseScreen) (i, pScreen);
d1189 1
a1189 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1226 1
a1226 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d48 3
a50 4
Bool xf86RegisterOffscreenManager(
    ScreenPtr pScreen, 
    FBManagerFuncsPtr funcs
){
d52 1
a52 1
   xf86FBManagerKey = &xf86FBManagerKeyRec;
d54 2
a55 2
   if (!dixRegisterPrivateKey(&xf86FBManagerKeyRec, PRIVATE_SCREEN, 0))
       return FALSE;
d57 1
a57 1
   dixSetPrivate(&pScreen->devPrivates, xf86FBManagerKey, funcs);
d59 1
a59 1
   return TRUE;
a61 1

d66 1
a66 1
	return FALSE;
d68 2
a69 2
    if(!dixLookupPrivate(&pScreen->devPrivates, xf86FBManagerKey))
	return FALSE;
d75 11
a85 12
xf86RegisterFreeBoxCallback(
    ScreenPtr pScreen,  
    FreeBoxCallbackProcPtr FreeBoxCallback,
    pointer devPriv
){
   FBManagerFuncsPtr funcs;

   if(xf86FBManagerKey == NULL) 
	return FALSE;
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(&pScreen->devPrivates,
						    xf86FBManagerKey)))
	return FALSE;
d87 2
a88 1
   return (*funcs->RegisterFreeBoxCallback)(pScreen, FreeBoxCallback, devPriv);
d91 8
d100 5
a104 16
FBAreaPtr
xf86AllocateOffscreenArea(
   ScreenPtr pScreen, 
   int w, int h,
   int gran,
   MoveAreaCallbackProcPtr moveCB,
   RemoveAreaCallbackProcPtr removeCB,
   pointer privData
){
   FBManagerFuncsPtr funcs;

   if(xf86FBManagerKey == NULL) 
	return NULL;
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(&pScreen->devPrivates,
						    xf86FBManagerKey)))
	return NULL;
d106 2
a107 2
   return (*funcs->AllocateOffscreenArea)(
		pScreen, w, h, gran, moveCB, removeCB, privData);
d110 9
d120 5
a124 16
FBLinearPtr
xf86AllocateOffscreenLinear(
    ScreenPtr pScreen, 
    int length,
    int gran,
    MoveLinearCallbackProcPtr moveCB,
    RemoveLinearCallbackProcPtr removeCB,
    pointer privData
){
   FBManagerFuncsPtr funcs;

   if(xf86FBManagerKey == NULL) 
	return NULL;
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(&pScreen->devPrivates,
						    xf86FBManagerKey)))
	return NULL;
d126 2
a127 2
   return (*funcs->AllocateOffscreenLinear)(
		pScreen, length, gran, moveCB, removeCB, privData);
a129 1

d133 1
a133 1
   FBManagerFuncsPtr funcs;
d135 2
a136 1
   if(!area) return;
d138 7
a144 5
   if(xf86FBManagerKey == NULL) 
	return;
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(
	    &area->pScreen->devPrivates, xf86FBManagerKey)))
	return;
d146 1
a146 1
   (*funcs->FreeOffscreenArea)(area);
d148 1
a148 1
   return;
a150 1

d154 1
a154 1
   FBManagerFuncsPtr funcs;
d156 2
a157 1
   if(!linear) return;
d159 7
a165 5
   if(xf86FBManagerKey == NULL) 
	return;
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(
	    &linear->pScreen->devPrivates, xf86FBManagerKey)))
	return;
d167 1
a167 1
   (*funcs->FreeOffscreenLinear)(linear);
d169 1
a169 1
   return;
d172 7
d180 7
a186 14
Bool
xf86ResizeOffscreenArea(
   FBAreaPtr resize,
   int w, int h
){
   FBManagerFuncsPtr funcs;

   if(!resize) return FALSE;

   if(xf86FBManagerKey == NULL) 
	return FALSE;
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(
	    &resize->pScreen->devPrivates, xf86FBManagerKey)))
	return FALSE;
d188 1
a188 1
   return (*funcs->ResizeOffscreenArea)(resize, w, h);
d192 3
a194 13
xf86ResizeOffscreenLinear(
   FBLinearPtr resize,
   int size
){
   FBManagerFuncsPtr funcs;

   if(!resize) return FALSE;

   if(xf86FBManagerKey == NULL) 
	return FALSE;
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(
	    &resize->pScreen->devPrivates, xf86FBManagerKey)))
	return FALSE;
d196 12
a207 1
   return (*funcs->ResizeOffscreenLinear)(resize, size);
d210 9
d220 5
a224 18
Bool
xf86QueryLargestOffscreenArea(
    ScreenPtr pScreen,
    int *w, int *h,
    int gran,
    int preferences,
    int severity
){
   FBManagerFuncsPtr funcs;

   *w = 0;
   *h = 0;

   if(xf86FBManagerKey == NULL) 
	return FALSE;
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(&pScreen->devPrivates,
						    xf86FBManagerKey)))
	return FALSE;
d226 2
a227 2
   return (*funcs->QueryLargestOffscreenArea)(
		pScreen, w, h, gran, preferences, severity);
d231 6
a236 15
xf86QueryLargestOffscreenLinear(
    ScreenPtr pScreen,
    int *size,
    int gran,
    int severity
){
   FBManagerFuncsPtr funcs;

   *size = 0;

   if(xf86FBManagerKey == NULL) 
	return FALSE;
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(&pScreen->devPrivates,
						    xf86FBManagerKey)))
	return FALSE;
d238 8
a245 2
   return (*funcs->QueryLargestOffscreenLinear)(
		pScreen, size, gran, severity);
a247 1

d251 1
a251 1
   FBManagerFuncsPtr funcs;
d253 5
a257 5
   if(xf86FBManagerKey == NULL) 
	return FALSE;
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(&pScreen->devPrivates,
						    xf86FBManagerKey)))
	return FALSE;
d259 1
a259 1
   return (*funcs->PurgeOffscreenAreas)(pScreen);
d266 1
a266 1
\************************************************************/ 
d269 1
d273 2
a274 2
  FBArea area;
  struct _FBLink *next;  
d278 4
a281 4
  FBLinear linear;
  int free;	/* need to add free here as FBLinear is publicly accessible */
  FBAreaPtr area;	/* only used if allocation came from XY area */
  struct _FBLinearLink *next;  
a283 1

d285 10
a294 10
   ScreenPtr    		pScreen;
   RegionPtr    		InitialBoxes;
   RegionPtr    		FreeBoxes;
   FBLinkPtr    		UsedAreas;
   int          		NumUsedAreas;
   FBLinearLinkPtr              LinearAreas;
   CloseScreenProcPtr           CloseScreen;
   int                          NumCallbacks;
   FreeBoxCallbackProcPtr       *FreeBoxesUpdateCallback;
   DevUnion                     *devPrivates;
a296 1

d300 1
a300 1
   int i = offman->NumCallbacks;
d302 5
a306 4
   while(i--) {
	(*offman->FreeBoxesUpdateCallback[i])(
	   offman->pScreen, offman->FreeBoxes, offman->devPrivates[i].ptr);
   }
d310 13
a322 26
localRegisterFreeBoxCallback(
    ScreenPtr pScreen,  
    FreeBoxCallbackProcPtr FreeBoxCallback,
    pointer devPriv
){
   FBManagerPtr offman;
   FreeBoxCallbackProcPtr *newCallbacks;
   DevUnion *newPrivates; 

   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);
   newCallbacks = realloc( offman->FreeBoxesUpdateCallback,
		sizeof(FreeBoxCallbackProcPtr) * (offman->NumCallbacks + 1));

   newPrivates = realloc(offman->devPrivates,
			  sizeof(DevUnion) * (offman->NumCallbacks + 1));

   if(!newCallbacks || !newPrivates)
	return FALSE;     

   offman->FreeBoxesUpdateCallback = newCallbacks;
   offman->devPrivates = newPrivates;

   offman->FreeBoxesUpdateCallback[offman->NumCallbacks] = FreeBoxCallback;
   offman->devPrivates[offman->NumCallbacks].ptr = devPriv;
   offman->NumCallbacks++;
d324 2
a325 1
   SendCallFreeBoxCallbacks(offman);
d327 13
a339 1
   return TRUE;
a341 1

d343 24
a366 25
AllocateArea(
   FBManagerPtr offman,
   int w, int h,
   int granularity,
   MoveAreaCallbackProcPtr moveCB,
   RemoveAreaCallbackProcPtr removeCB,
   pointer privData
){
   ScreenPtr pScreen = offman->pScreen;
   FBLinkPtr link = NULL;
   FBAreaPtr area = NULL;
   RegionRec NewReg;
   int i, x = 0, num;
   BoxPtr boxp;

   if(granularity <= 1) granularity = 0;

   boxp = RegionRects(offman->FreeBoxes);
   num = RegionNumRects(offman->FreeBoxes);

   /* look through the free boxes */
   for(i = 0; i < num; i++, boxp++) {
	x = boxp->x1;
	if (granularity > 1)
	    x = ((x + granularity - 1) / granularity) * granularity;
d368 2
a369 2
	if(((boxp->y2 - boxp->y1) < h) || ((boxp->x2 - x) < w))
	   continue;
d371 3
a373 2
	link = malloc(sizeof(FBLink));
	if(!link) return NULL;
d379 33
a411 2
	break;
   }
d413 10
a422 41
   /* try to boot a removeable one out if we are not expendable ourselves */
   if(!area && !removeCB) {
	link = offman->UsedAreas;

	while(link) {
	   if(!link->area.RemoveAreaCallback) {
		link = link->next;
		continue;
	   }

	   boxp = &(link->area.box);
	   x = boxp->x1;
 	   if (granularity > 1)
		x = ((x + granularity - 1) / granularity) * granularity;

	   if(((boxp->y2 - boxp->y1) < h) || ((boxp->x2 - x) < w)) {
		link = link->next;
		continue;
	   }

	   /* bye, bye */
	   (*link->area.RemoveAreaCallback)(&link->area);
	   RegionInit(&NewReg, &(link->area.box), 1);
	   RegionUnion(offman->FreeBoxes, offman->FreeBoxes, &NewReg);
	   RegionUninit(&NewReg);

           area = &(link->area);
	   break;
	}
   }

   if(area) {
	area->pScreen = pScreen;
	area->granularity = granularity;
	area->box.x1 = x;
	area->box.x2 = x + w;
	area->box.y1 = boxp->y1;
	area->box.y2 = boxp->y1 + h;
	area->MoveAreaCallback = moveCB;
	area->RemoveAreaCallback = removeCB;
	area->devPrivate.ptr = privData;
d425 3
a427 3
	RegionSubtract(offman->FreeBoxes, offman->FreeBoxes, &NewReg);
	RegionUninit(&NewReg);
   }
d429 1
a429 1
   return area;
d433 13
a445 15
localAllocateOffscreenArea(
   ScreenPtr pScreen, 
   int w, int h,
   int gran,
   MoveAreaCallbackProcPtr moveCB,
   RemoveAreaCallbackProcPtr removeCB,
   pointer privData
){
   FBManagerPtr offman;
   FBAreaPtr area = NULL;

   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);
   if((area = AllocateArea(offman, w, h, gran, moveCB, removeCB, privData)))
	SendCallFreeBoxCallbacks(offman);
d447 1
a447 1
   return area;
a449 1

d453 11
a463 25
   FBManagerPtr offman;
   FBLinkPtr pLink, pLinkPrev = NULL;
   RegionRec FreedRegion;
   ScreenPtr pScreen;

   pScreen = area->pScreen;
   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);
   pLink = offman->UsedAreas;
   if(!pLink) return;  
 
   while(&(pLink->area) != area) {
	pLinkPrev = pLink;
	pLink = pLink->next;
	if(!pLink) return;
   }

   /* put the area back into the pool */
   RegionInit(&FreedRegion, &(pLink->area.box), 1);
   RegionUnion(offman->FreeBoxes, offman->FreeBoxes, &FreedRegion);
   RegionUninit(&FreedRegion);

   if(pLinkPrev)
	pLinkPrev->next = pLink->next;
   else offman->UsedAreas = pLink->next;
d465 6
a470 2
   free(pLink);
   offman->NumUsedAreas--;
d472 14
a485 1
   SendCallFreeBoxCallbacks(offman);
a486 1
   
d488 34
d523 35
a557 71
static Bool
localResizeOffscreenArea(
   FBAreaPtr resize,
   int w, int h
){
   FBManagerPtr offman;
   ScreenPtr pScreen;
   BoxRec OrigArea;
   RegionRec FreedReg;
   FBAreaPtr area = NULL;
   FBLinkPtr pLink, newLink, pLinkPrev = NULL;

   pScreen = resize->pScreen;
   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);
   /* find this link */
   if(!(pLink = offman->UsedAreas))
	return FALSE;  
 
   while(&(pLink->area) != resize) {
	pLinkPrev = pLink;
	pLink = pLink->next;
	if(!pLink) return FALSE;
   }

   OrigArea.x1 = resize->box.x1;
   OrigArea.x2 = resize->box.x2;
   OrigArea.y1 = resize->box.y1;
   OrigArea.y2 = resize->box.y2;

   /* if it's smaller, this is easy */

   if((w <= (resize->box.x2 - resize->box.x1)) && 
      (h <= (resize->box.y2 - resize->box.y1))) {
	RegionRec NewReg;

	resize->box.x2 = resize->box.x1 + w;
	resize->box.y2 = resize->box.y1 + h;

        if((resize->box.y2 == OrigArea.y2) &&
	   (resize->box.x2 == OrigArea.x2))
		return TRUE;

	RegionInit(&FreedReg, &OrigArea, 1);
	RegionInit(&NewReg, &(resize->box), 1);
	RegionSubtract(&FreedReg, &FreedReg, &NewReg);
	RegionUnion(offman->FreeBoxes, offman->FreeBoxes, &FreedReg);
	RegionUninit(&FreedReg);
	RegionUninit(&NewReg);

	SendCallFreeBoxCallbacks(offman);

	return TRUE;
   }


   /* otherwise we remove the old region */

   RegionInit(&FreedReg, &OrigArea, 1);
   RegionUnion(offman->FreeBoxes, offman->FreeBoxes, &FreedReg);
  
   /* remove the old link */
   if(pLinkPrev)
	pLinkPrev->next = pLink->next;
   else offman->UsedAreas = pLink->next;

   /* and try to add a new one */

   if((area = AllocateArea(offman, w, h, resize->granularity,
		resize->MoveAreaCallback, resize->RemoveAreaCallback,
		resize->devPrivate.ptr))) {
d560 1
a560 1
	memcpy(resize, area, sizeof(FBArea));
d563 1
a563 1
 	newLink = offman->UsedAreas;
d565 3
a567 3
        while(&(newLink->area) != area) {
	    pLinkPrev = newLink;
	    newLink = newLink->next;
d570 4
a573 3
	if(pLinkPrev)
	    pLinkPrev->next = newLink->next;
	else offman->UsedAreas = newLink->next;
d578 1
a578 1
	free(newLink);
d580 7
a586 6
	/* AllocateArea added one but we really only exchanged one */
	offman->NumUsedAreas--;  
   } else {
      /* reinstate the old region */
      RegionSubtract(offman->FreeBoxes, offman->FreeBoxes, &FreedReg);
      RegionUninit(&FreedReg);
d588 4
a591 4
      pLink->next = offman->UsedAreas;
      offman->UsedAreas = pLink;
      return FALSE;
   }
d593 1
d595 1
a595 1
   RegionUninit(&FreedReg);
d597 1
a597 3
   SendCallFreeBoxCallbacks(offman);

   return TRUE;
d601 4
a604 7
localQueryLargestOffscreenArea(
    ScreenPtr pScreen,
    int *width, int *height,
    int granularity,
    int preferences,
    int severity
){
d613 2
a614 1
    if(granularity <= 1) granularity = 0;
d616 2
a617 2
    if((preferences < 0) || (preferences > 3))
	return FALSE;	
d619 6
a624 4
    offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					    xf86FBScreenKey);
    if(severity < 0) severity = 0;
    if(severity > 2) severity = 2;
d626 1
a626 1
    switch(severity) {
d628 21
a648 20
	if(offman->NumUsedAreas) {
	    FBLinkPtr pLink;
	    RegionRec tmpRegion;
	    newRegion = RegionCreate(NULL, 1);
	    RegionCopy(newRegion, offman->InitialBoxes);
	    pLink = offman->UsedAreas;

	    while(pLink) {
		if(!pLink->area.RemoveAreaCallback) {
		    RegionInit(&tmpRegion, &(pLink->area.box), 1);
		    RegionSubtract(newRegion, newRegion, &tmpRegion);
		    RegionUninit(&tmpRegion);
		}
		pLink = pLink->next;
	    }

	    nbox = RegionNumRects(newRegion);
	    pbox = RegionRects(newRegion);
	    break;
	}
d650 21
a670 20
	if(offman->NumUsedAreas) {
	    FBLinkPtr pLink;
	    RegionRec tmpRegion;
	    newRegion = RegionCreate(NULL, 1);
	    RegionCopy(newRegion, offman->FreeBoxes);
	    pLink = offman->UsedAreas;

	    while(pLink) {
		if(pLink->area.RemoveAreaCallback) {
		    RegionInit(&tmpRegion, &(pLink->area.box), 1);
		    RegionAppend(newRegion, &tmpRegion);
		    RegionUninit(&tmpRegion);
		}
		pLink = pLink->next;
	    }

	    nbox = RegionNumRects(newRegion);
	    pbox = RegionRects(newRegion);
	    break;
	}
d672 40
a711 39
	nbox = RegionNumRects(offman->FreeBoxes);
	pbox = RegionRects(offman->FreeBoxes);
	break;
    }

    while(nbox--) {
	x = pbox->x1;
	if (granularity > 1)
	   x = ((x + granularity - 1) / granularity) * granularity;

	w = pbox->x2 - x;
	h = pbox->y2 - pbox->y1;
	area = w * h;

	if(w > 0) {
	    Bool gotIt = FALSE;
	    switch(preferences) {
	    case FAVOR_AREA_THEN_WIDTH:
		if((area > oldArea) || ((area == oldArea) && (w > *width))) 
		    gotIt = TRUE;
		break;
	    case FAVOR_AREA_THEN_HEIGHT:
		if((area > oldArea) || ((area == oldArea) && (h > *height)))
		    gotIt = TRUE;
		break;
	    case FAVOR_WIDTH_THEN_AREA:
		if((w > *width) || ((w == *width) && (area > oldArea)))
		    gotIt = TRUE;
		break;
	    case FAVOR_HEIGHT_THEN_AREA:
		if((h > *height) || ((h == *height) && (area > oldArea)))
		    gotIt = TRUE;
		break;
	    }
	    if(gotIt) {
		*width = w;
		*height = h;
		oldArea = area;
	    }
d713 1
a713 1
	pbox++;
d716 2
a717 2
    if(newRegion)
	RegionDestroy(newRegion);
d725 23
a747 21
   FBManagerPtr offman;
   FBLinkPtr pLink, tmp, pPrev = NULL;
   RegionRec FreedRegion;
   Bool anyUsed = FALSE;

   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);
   pLink = offman->UsedAreas;
   if(!pLink) return TRUE;  
 
   while(pLink) {
	if(pLink->area.RemoveAreaCallback) {
	    (*pLink->area.RemoveAreaCallback)(&pLink->area);

	    RegionInit(&FreedRegion, &(pLink->area.box), 1);
	    RegionAppend(offman->FreeBoxes, &FreedRegion);
	    RegionUninit(&FreedRegion);

	    if(pPrev)
	      pPrev->next = pLink->next;
	    else offman->UsedAreas = pLink->next;
d749 2
a750 2
	    tmp = pLink;
	    pLink = pLink->next;
d752 13
a764 12
	    offman->NumUsedAreas--;
	    anyUsed = TRUE;
	} else {
	    pPrev = pLink;
	    pLink = pLink->next;
	}
   }

   if(anyUsed) {
	RegionValidate(offman->FreeBoxes, &anyUsed);
	SendCallFreeBoxCallbacks(offman);
   }
d766 1
a766 1
   return TRUE;
d769 1
a769 1
static void 
d775 1
a775 1
static void 
d778 11
a788 10
   FBManagerPtr offman;
   FBLinearLinkPtr pLink, pLinkPrev = NULL;
   ScreenPtr pScreen = area->pScreen;

   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);
   pLink = offman->LinearAreas;
   if(!pLink) return;  
 
   while(pLink->area != area) {
d791 3
a793 2
        if(!pLink) return;
   }
d795 2
a796 2
   /* give the user the callback it is expecting */
   (*pLink->linear.RemoveLinearCallback)(&(pLink->linear));
d798 1
a798 1
   if(pLinkPrev)
d800 2
a801 1
   else offman->LinearAreas = pLink->next;
d803 1
a803 1
   free(pLink);
d810 2
a811 1
   if (!pLink) ErrorF("MMmm, PLINK IS NULL!\n");
d813 5
a817 6
   while (pLink) {
	 ErrorF("  Offset:%08x, Size:%08x, %s,%s\n",
		pLink->linear.offset,
		pLink->linear.size,
		pLink->free ? "Free" : "Used",
		pLink->area ? "Area" : "Linear");
d819 2
a820 2
	 pLink = pLink->next;
   }
d825 6
a830 67
AllocateLinear(
   FBManagerPtr offman,
   int size,
   int granularity,
   pointer privData
){
   ScreenPtr pScreen = offman->pScreen;
   FBLinearLinkPtr linear = NULL;
   FBLinearLinkPtr newlink = NULL;
   int offset, end;

   if(size <= 0) return NULL;

   if (!offman->LinearAreas) return NULL;

   linear = offman->LinearAreas;
   while (linear) {
 	/* Make sure we get a free area that's not an XY fallback case */
      if (!linear->area && linear->free) {
	 offset = linear->linear.offset;
	 if (granularity > 1)
	    offset = ((offset + granularity - 1) / granularity) * granularity;
	 end = offset+size;
	 if (end <= (linear->linear.offset + linear->linear.size))
	    break;
      }
      linear = linear->next;
   }
   if (!linear)
      return NULL;

   /* break left */
   if (offset > linear->linear.offset) {
      newlink = malloc(sizeof(FBLinearLink));
      if (!newlink)
	 return NULL;
      newlink->area = NULL;
      newlink->linear.offset = offset;
      newlink->linear.size = linear->linear.size - (offset - linear->linear.offset);
      newlink->free = 1;
      newlink->next = linear->next;
      linear->linear.size -= newlink->linear.size;
      linear->next = newlink;
      linear = newlink;
   }

   /* break right */
   if (size < linear->linear.size) {
      newlink = malloc(sizeof(FBLinearLink));
      if (!newlink)
	 return NULL;
      newlink->area = NULL;
      newlink->linear.offset = offset + size;
      newlink->linear.size = linear->linear.size - size;
      newlink->free = 1;
      newlink->next = linear->next;
      linear->linear.size = size;
      linear->next = newlink;
   }

   /* p = middle block */
   linear->linear.granularity = granularity;
   linear->free = 0;
   linear->linear.pScreen = pScreen;
   linear->linear.MoveLinearCallback = NULL;
   linear->linear.RemoveLinearCallback = NULL;
   linear->linear.devPrivate.ptr = NULL;
d832 2
a833 1
   DumpDebug(offman->LinearAreas);
d835 61
a895 1
   return &(linear->linear);
d899 23
a921 31
localAllocateOffscreenLinear(
    ScreenPtr pScreen, 
    int length,
    int gran,
    MoveLinearCallbackProcPtr moveCB,
    RemoveLinearCallbackProcPtr removeCB,
    pointer privData
){
   FBManagerPtr offman;
   FBLinearLinkPtr link;
   FBAreaPtr area;
   FBLinearPtr linear = NULL;
   BoxPtr extents;
   int w, h, pitch;

   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);

   /* Try to allocate from linear memory first...... */
   DebugF("ALLOCATING LINEAR\n");
   if ((linear = AllocateLinear(offman, length, gran, privData)))
  	return linear;

   DebugF("NOPE, ALLOCATING AREA\n");

   if(!(link = malloc(sizeof(FBLinearLink))))
     return NULL;

   /* No linear available, so try and pinch some from the XY areas */
   extents = RegionExtents(offman->InitialBoxes);
   pitch = extents->x2 - extents->x1;
d923 8
a930 1
   if (gran > 1) {
d945 22
a966 22
   if(length < pitch) { /* special case */
	w = length;
	h = 1;
   } else {
	w = pitch;
	h = (length + pitch - 1) / pitch;
   }

   if((area = localAllocateOffscreenArea(pScreen, w, h, gran, 
			moveCB   ? LinearMoveCBWrapper   : NULL, 
			removeCB ? LinearRemoveCBWrapper : NULL, 
			privData))) 
   {
	link->area = area;
	link->free = 0;
	link->next = offman->LinearAreas;
	offman->LinearAreas = link;
	linear = &(link->linear);
	linear->pScreen = pScreen;
	linear->size = h * w;
	linear->offset = (pitch * area->box.y1) + area->box.x1;
	if (gran > 1)
d968 7
a974 6
	linear->granularity = gran;
	linear->MoveLinearCallback = moveCB;
	linear->RemoveLinearCallback = removeCB;
	linear->devPrivate.ptr = privData;
   } else 
	free(link);
d976 1
a976 1
   DumpDebug(offman->LinearAreas);
d978 1
a978 1
   return linear;
d981 1
a981 2

static void 
d984 11
a994 10
   FBManagerPtr offman;
   FBLinearLinkPtr pLink, pLinkPrev = NULL;
   ScreenPtr pScreen = linear->pScreen;

   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);
   pLink = offman->LinearAreas;
   if(!pLink) return;  
 
   while(&(pLink->linear) != linear) {
d997 3
a999 2
        if(!pLink) return;
   }
d1001 7
a1007 6
   if(pLink->area) {  /* really an XY area */
	DebugF("FREEING AREA\n");
	localFreeOffscreenArea(pLink->area);
   	if(pLinkPrev)
	    pLinkPrev->next = pLink->next;
   	else offman->LinearAreas = pLink->next;
d1009 26
a1034 24
	DumpDebug(offman->LinearAreas);
	return;
   }

   pLink->free = 1;

   if (pLink->next && pLink->next->free) {
      FBLinearLinkPtr p = pLink->next;
      pLink->linear.size += p->linear.size;
      pLink->next = p->next;
      free(p);
   }

   if(pLinkPrev) {
   	if (pLinkPrev->next && pLinkPrev->next->free && !pLinkPrev->area) {
      	    FBLinearLinkPtr p = pLinkPrev->next;
      	    pLinkPrev->linear.size += p->linear.size;
      	    pLinkPrev->next = p->next;
      	    free(p);
    	}
   } 
   
   DebugF("FREEING LINEAR\n");
   DumpDebug(offman->LinearAreas);
d1037 1
a1037 2

static Bool 
d1040 11
a1050 10
   FBManagerPtr offman;
   FBLinearLinkPtr pLink;
   ScreenPtr pScreen = resize->pScreen;

   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);
   pLink = offman->LinearAreas;
   if(!pLink) return FALSE;  
 
   while(&(pLink->linear) != resize) {
d1052 23
a1074 2
        if(!pLink) return FALSE;
   }
d1076 10
a1085 27
   /* This could actually be alot smarter and try to move allocations
      from XY to linear when available.  For now if it was XY, we keep
      it XY */

   if(pLink->area) {  /* really an XY area */
	BoxPtr extents;
	int pitch, w, h;

	extents = RegionExtents(offman->InitialBoxes);
	pitch = extents->x2 - extents->x1;

	if(length < pitch) { /* special case */
	    w = length;
	    h = 1;
	} else {
	    w = pitch;
	    h = (length + pitch - 1) / pitch;
	}

	if(localResizeOffscreenArea(pLink->area, w, h)) {
	    resize->size = h * w;
	    resize->offset = (pitch * pLink->area->box.y1) + pLink->area->box.x1;
	    return TRUE;	
	}
   } else {
	/* TODO!!!! resize the linear area */
   }
d1087 1
a1087 1
   return FALSE;
a1089 1

d1091 2
a1092 6
localQueryLargestOffscreenLinear(
    ScreenPtr pScreen,
    int *size,
    int gran,
    int priority
)
d1094 2
a1095 2
    FBManagerPtr offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
							 xf86FBScreenKey);
d1100 1
a1100 1
    
d1104 28
a1131 28
	pLinkRet = pLink;
	while (pLink) {
	    if (pLink->free) {
		if (pLink->linear.size > pLinkRet->linear.size)
		    pLinkRet = pLink;
	    }
	    pLink = pLink->next;
    	}

	if (pLinkRet->free) {
	    *size = pLinkRet->linear.size;
	    return TRUE;
    	}
    } else {
	int w, h;

    	if(localQueryLargestOffscreenArea(pScreen, &w, &h, gran, 
				FAVOR_WIDTH_THEN_AREA, priority))
    	{
	    FBManagerPtr offman;
	    BoxPtr extents;

	    offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
						    xf86FBScreenKey);
	    extents = RegionExtents(offman->InitialBoxes);
	    if((extents->x2 - extents->x1) == w)
	    	*size = w * h;
	    return TRUE;
d1138 12
d1151 16
d1168 6
a1173 12
static FBManagerFuncs xf86FBManFuncs = {
   localAllocateOffscreenArea,
   localFreeOffscreenArea,
   localResizeOffscreenArea,
   localQueryLargestOffscreenArea,
   localRegisterFreeBoxCallback,
   localAllocateOffscreenLinear,
   localFreeOffscreenLinear,
   localResizeOffscreenLinear,
   localQueryLargestOffscreenLinear,
   localPurgeUnlockedOffscreenAreas
 };
d1175 2
d1178 4
a1181 31
static Bool
xf86FBCloseScreen (int i, ScreenPtr pScreen)
{
   FBLinkPtr pLink, tmp;
   FBLinearLinkPtr pLinearLink, tmp2;
   FBManagerPtr offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
							xf86FBScreenKey);
   
   pScreen->CloseScreen = offman->CloseScreen;

   pLink = offman->UsedAreas;
   while(pLink) {
	tmp = pLink;
	pLink = pLink->next;
	free(tmp);
   }

   pLinearLink = offman->LinearAreas;
   while(pLinearLink) {
	tmp2 = pLinearLink;
	pLinearLink = pLinearLink->next;
	free(tmp2);
   }

   RegionDestroy(offman->InitialBoxes);
   RegionDestroy(offman->FreeBoxes);

   free(offman->FreeBoxesUpdateCallback);
   free(offman->devPrivates);
   free(offman);
   dixSetPrivate(&pScreen->devPrivates, xf86FBScreenKey, NULL);
d1183 1
a1183 1
   return (*pScreen->CloseScreen) (i, pScreen);
d1187 34
a1220 34
xf86InitFBManager(
    ScreenPtr pScreen,  
    BoxPtr FullBox
){
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   RegionRec ScreenRegion;
   RegionRec FullRegion;
   BoxRec ScreenBox;
   Bool ret;

   ScreenBox.x1 = 0;
   ScreenBox.y1 = 0;
   ScreenBox.x2 = pScrn->virtualX;
   ScreenBox.y2 = pScrn->virtualY;

   if((FullBox->x1 >  ScreenBox.x1) || (FullBox->y1 >  ScreenBox.y1) ||
      (FullBox->x2 <  ScreenBox.x2) || (FullBox->y2 <  ScreenBox.y2)) {
	return FALSE;   
   }

   if (FullBox->y2 < FullBox->y1) return FALSE;
   if (FullBox->x2 < FullBox->x1) return FALSE;

   RegionInit(&ScreenRegion, &ScreenBox, 1);
   RegionInit(&FullRegion, FullBox, 1);

   RegionSubtract(&FullRegion, &FullRegion, &ScreenRegion);

   ret = xf86InitFBManagerRegion(pScreen, &FullRegion);

   RegionUninit(&ScreenRegion);
   RegionUninit(&FullRegion);
    
   return ret;
d1224 1
a1224 5
xf86InitFBManagerArea(
    ScreenPtr pScreen,
    int PixelArea,
    int Verbosity
)
d1233 1
a1233 1
	return FALSE;
d1242 4
a1245 4
	Rect[1].x = 0;
	Rect[1].y = Rect[0].height;
	Rect[1].height = 1;
	nRect++;
d1251 51
a1301 53
	if (!RegionNar(pRegion)) {
	    Rect[2].x = Rect[2].y = 0;
	    Rect[2].width = pScrn->virtualX;
	    Rect[2].height = pScrn->virtualY;

	    pScreenRegion = RegionFromRects(1, &Rect[2], 0);
	    if (pScreenRegion) {
		if (!RegionNar(pScreenRegion)) {
		    RegionSubtract(pRegion, pRegion, pScreenRegion);

		    ret = xf86InitFBManagerRegion(pScreen, pRegion);

		    if (ret && xf86GetVerbosity() >= Verbosity) {
			int scrnIndex = pScrn->scrnIndex;

			xf86DrvMsgVerb(scrnIndex, X_INFO, Verbosity,
			    "Largest offscreen areas (with overlaps):\n");

			if (Rect[2].width < Rect[0].width) {
			    xf86DrvMsgVerb(scrnIndex, X_INFO, Verbosity,
				"\t%d x %d rectangle at %d,0\n",
				Rect[0].width - Rect[2].width,
				Rect[0].height,
				Rect[2].width);
			}
			if (Rect[2].width < Rect[1].width) {
			    xf86DrvMsgVerb(scrnIndex, X_INFO, Verbosity,
				"\t%d x %d rectangle at %d,0\n",
				Rect[1].width - Rect[2].width,
				Rect[0].height + Rect[1].height,
				Rect[2].width);
			}
			if (Rect[2].height < Rect[0].height) {
			    xf86DrvMsgVerb(scrnIndex, X_INFO, Verbosity,
				"\t%d x %d rectangle at 0,%d\n",
				Rect[0].width,
				Rect[0].height - Rect[2].height,
				Rect[2].height);
			}
			if (Rect[1].height) {
			    xf86DrvMsgVerb(scrnIndex, X_INFO, Verbosity,
				"\t%d x %d rectangle at 0,%d\n",
				Rect[1].width,
				Rect[0].height - Rect[2].height +
				    Rect[1].height,
				Rect[2].height);
			}
		    }
		}

		RegionDestroy(pScreenRegion);
	    }
	}
d1303 1
a1303 1
	RegionDestroy(pRegion);
d1310 3
a1312 5
xf86InitFBManagerRegion(
    ScreenPtr pScreen,  
    RegionPtr FullRegion
){
   FBManagerPtr offman;
d1314 2
a1315 2
   if(RegionNil(FullRegion))
	return FALSE;
d1317 2
a1318 2
   if (!dixRegisterPrivateKey(&xf86FBScreenKeyRec, PRIVATE_SCREEN, 0))
       return FALSE;
d1320 2
a1321 2
   if(!xf86RegisterOffscreenManager(pScreen, &xf86FBManFuncs))
	return FALSE;
d1323 3
a1325 2
   offman = malloc(sizeof(FBManager));
   if(!offman) return FALSE;
d1327 1
a1327 1
   dixSetPrivate(&pScreen->devPrivates, xf86FBScreenKey, offman);
d1329 2
a1330 2
   offman->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = xf86FBCloseScreen;
d1332 2
a1333 2
   offman->InitialBoxes = RegionCreate(NULL, 1);
   offman->FreeBoxes = RegionCreate(NULL, 1);
d1335 2
a1336 2
   RegionCopy(offman->InitialBoxes, FullRegion);
   RegionCopy(offman->FreeBoxes, FullRegion);
d1338 7
a1344 7
   offman->pScreen = pScreen;
   offman->UsedAreas = NULL;
   offman->LinearAreas = NULL;
   offman->NumUsedAreas = 0;  
   offman->NumCallbacks = 0;
   offman->FreeBoxesUpdateCallback = NULL;
   offman->devPrivates = NULL;
d1346 2
a1347 2
   return TRUE;
} 
d1350 8
a1357 34
xf86InitFBManagerLinear(
    ScreenPtr pScreen,  
    int offset,
    int size
){
   FBManagerPtr offman;
   FBLinearLinkPtr link;
   FBLinearPtr linear;

   if (size <= 0)
	return FALSE;

   /* we expect people to have called the Area setup first for pixmap cache */
   if (!dixLookupPrivate(&pScreen->devPrivates, xf86FBScreenKey))
	return FALSE;

   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);
   offman->LinearAreas = malloc(sizeof(FBLinearLink));
   if (!offman->LinearAreas)
	return FALSE;

   link = offman->LinearAreas;
   link->area = NULL;
   link->next = NULL;
   link->free = 1;
   linear = &(link->linear);
   linear->pScreen = pScreen;
   linear->size = size;
   linear->offset = offset;
   linear->granularity = 0;
   linear->MoveLinearCallback = NULL;
   linear->RemoveLinearCallback = NULL;
   linear->devPrivate.ptr = NULL;
d1359 24
a1382 1
   return TRUE;
a1384 1

d1390 11
a1400 12
xf86AllocateLinearOffscreenArea (
   ScreenPtr pScreen, 
   int length,
   int gran,
   MoveAreaCallbackProcPtr moveCB,
   RemoveAreaCallbackProcPtr removeCB,
   pointer privData
){
   FBManagerFuncsPtr funcs;
   FBManagerPtr offman;
   BoxPtr extents;
   int w, h;
d1402 1
a1402 1
   if(xf86FBManagerKey == NULL) 
d1404 2
a1405 2
   if(!(funcs = (FBManagerFuncsPtr)dixLookupPrivate(&pScreen->devPrivates,
						    xf86FBManagerKey)))
d1408 20
a1427 19
   offman = (FBManagerPtr)dixLookupPrivate(&pScreen->devPrivates,
					   xf86FBScreenKey);
   extents = RegionExtents(offman->InitialBoxes);
   w = extents->x2 - extents->x1;

   if (gran > 1) {
	if (gran > w)
	    return NULL;

	if (w % gran)
	    length += gran - 1;
   }

   if(length <= w) { /* special case */
	h = 1;
	w = length;
   } else {
	h = (length + w - 1) / w;
   }
d1429 2
a1430 2
   return (*funcs->AllocateOffscreenArea)(
                pScreen, w, h, gran, moveCB, removeCB, privData);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d45 1
a45 1
static int xf86FBManagerKeyIndex;
d53 5
a57 1
   xf86FBManagerKey = &xf86FBManagerKeyIndex;
d67 1
a67 1
    if(xf86FBManagerKey == NULL) 
d69 1
d278 2
a279 2
static int xf86FBScreenKeyIndex;
static DevPrivateKey xf86FBScreenKey = &xf86FBScreenKeyIndex;
d331 1
a331 1
   newCallbacks = xrealloc( offman->FreeBoxesUpdateCallback, 
d334 1
a334 1
   newPrivates = xrealloc(offman->devPrivates,
d371 2
a372 2
   boxp = REGION_RECTS(offman->FreeBoxes);
   num = REGION_NUM_RECTS(offman->FreeBoxes);
d383 1
a383 1
	link = xalloc(sizeof(FBLink));
d415 3
a417 3
	   REGION_INIT(pScreen, &NewReg, &(link->area.box), 1); 
	   REGION_UNION(pScreen, offman->FreeBoxes, offman->FreeBoxes, &NewReg);
	   REGION_UNINIT(pScreen, &NewReg); 
d435 3
a437 3
        REGION_INIT(pScreen, &NewReg, &(area->box), 1);
	REGION_SUBTRACT(pScreen, offman->FreeBoxes, offman->FreeBoxes, &NewReg);
	REGION_UNINIT(pScreen, &NewReg);
d485 3
a487 3
   REGION_INIT(pScreen, &FreedRegion, &(pLink->area.box), 1); 
   REGION_UNION(pScreen, offman->FreeBoxes, offman->FreeBoxes, &FreedRegion);
   REGION_UNINIT(pScreen, &FreedRegion); 
d493 1
a493 1
   xfree(pLink); 
d544 6
a549 6
	REGION_INIT(pScreen, &FreedReg, &OrigArea, 1); 
	REGION_INIT(pScreen, &NewReg, &(resize->box), 1); 
	REGION_SUBTRACT(pScreen, &FreedReg, &FreedReg, &NewReg);
	REGION_UNION(pScreen, offman->FreeBoxes, offman->FreeBoxes, &FreedReg);
	REGION_UNINIT(pScreen, &FreedReg); 
	REGION_UNINIT(pScreen, &NewReg); 
d559 2
a560 2
   REGION_INIT(pScreen, &FreedReg, &OrigArea, 1); 
   REGION_UNION(pScreen, offman->FreeBoxes, offman->FreeBoxes, &FreedReg);
d591 1
a591 1
	xfree(newLink);
d597 2
a598 2
      REGION_SUBTRACT(pScreen, offman->FreeBoxes, offman->FreeBoxes, &FreedReg);
      REGION_UNINIT(pScreen, &FreedReg); 
d606 1
a606 1
   REGION_UNINIT(pScreen, &FreedReg); 
d644 2
a645 2
	    newRegion = REGION_CREATE(pScreen, NULL, 1);
	    REGION_COPY(pScreen, newRegion, offman->InitialBoxes);
d650 3
a652 3
		    REGION_INIT(pScreen, &tmpRegion, &(pLink->area.box), 1);
		    REGION_SUBTRACT(pScreen, newRegion, newRegion, &tmpRegion);
		    REGION_UNINIT(pScreen, &tmpRegion);
d657 2
a658 2
	    nbox = REGION_NUM_RECTS(newRegion);
	    pbox = REGION_RECTS(newRegion);
d665 2
a666 2
	    newRegion = REGION_CREATE(pScreen, NULL, 1);
	    REGION_COPY(pScreen, newRegion, offman->FreeBoxes);
d671 3
a673 3
		    REGION_INIT(pScreen, &tmpRegion, &(pLink->area.box), 1);
		    REGION_APPEND(pScreen, newRegion, &tmpRegion);
		    REGION_UNINIT(pScreen, &tmpRegion);
d678 2
a679 2
	    nbox = REGION_NUM_RECTS(newRegion);
	    pbox = REGION_RECTS(newRegion);
d683 2
a684 2
	nbox = REGION_NUM_RECTS(offman->FreeBoxes);
	pbox = REGION_RECTS(offman->FreeBoxes);
d727 1
a727 1
	REGION_DESTROY(pScreen, newRegion);
d749 3
a751 3
	    REGION_INIT(pScreen, &FreedRegion, &(pLink->area.box), 1); 
	    REGION_APPEND(pScreen, offman->FreeBoxes, &FreedRegion);
	    REGION_UNINIT(pScreen, &FreedRegion); 
d759 1
a759 1
  	    xfree(tmp); 
d769 1
a769 1
	REGION_VALIDATE(pScreen, offman->FreeBoxes, &anyUsed);
d807 1
a807 1
   xfree(pLink);
d862 1
a862 1
      newlink = xalloc(sizeof(FBLinearLink));
d877 1
a877 1
      newlink = xalloc(sizeof(FBLinearLink));
d928 1
a928 1
   if(!(link = xalloc(sizeof(FBLinearLink))))
d932 1
a932 1
   extents = REGION_EXTENTS(pScreen, offman->InitialBoxes);
d938 1
a938 1
            xfree(link);
d978 1
a978 1
	xfree(link);
d1010 1
a1010 1
   	xfree(pLink); 
d1063 1
a1063 1
	extents = REGION_EXTENTS(pScreen, offman->InitialBoxes);
d1129 1
a1129 1
	    extents = REGION_EXTENTS(pScreen, offman->InitialBoxes);
d1169 1
a1169 1
	xfree(tmp);
d1176 1
a1176 1
	xfree(tmp2);
d1179 2
a1180 2
   REGION_DESTROY(pScreen, offman->InitialBoxes);
   REGION_DESTROY(pScreen, offman->FreeBoxes);
d1182 3
a1184 3
   xfree(offman->FreeBoxesUpdateCallback);
   xfree(offman->devPrivates);
   xfree(offman);
d1214 2
a1215 2
   REGION_INIT(pScreen, &ScreenRegion, &ScreenBox, 1); 
   REGION_INIT(pScreen, &FullRegion, FullBox, 1); 
d1217 1
a1217 1
   REGION_SUBTRACT(pScreen, &FullRegion, &FullRegion, &ScreenRegion);
d1221 2
a1222 2
   REGION_UNINIT(pScreen, &ScreenRegion);
   REGION_UNINIT(pScreen, &FullRegion);
d1257 1
a1257 1
    pRegion = RECTS_TO_REGION(pScreen, nRect, Rect, 0);
d1259 1
a1259 1
	if (!REGION_NAR(pRegion)) {
d1264 1
a1264 1
	    pScreenRegion = RECTS_TO_REGION(pScreen, 1, &Rect[2], 0);
d1266 2
a1267 2
		if (!REGION_NAR(pScreenRegion)) {
		    REGION_SUBTRACT(pScreen, pRegion, pRegion, pScreenRegion);
d1309 1
a1309 1
		REGION_DESTROY(pScreen, pScreenRegion);
d1313 1
a1313 1
	REGION_DESTROY(pScreen, pRegion);
d1326 1
a1326 1
   if(REGION_NIL(FullRegion))
d1329 3
d1335 1
a1335 1
   offman = xalloc(sizeof(FBManager));
d1343 2
a1344 2
   offman->InitialBoxes = REGION_CREATE(pScreen, NULL, 1);
   offman->FreeBoxes = REGION_CREATE(pScreen, NULL, 1);
d1346 2
a1347 2
   REGION_COPY(pScreen, offman->InitialBoxes, FullRegion);
   REGION_COPY(pScreen, offman->FreeBoxes, FullRegion);
d1379 1
a1379 1
   offman->LinearAreas = xalloc(sizeof(FBLinearLink));
d1426 1
a1426 1
   extents = REGION_EXTENTS(pScreen, offman->InitialBoxes);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d48 1
a48 1
_X_EXPORT Bool xf86RegisterOffscreenManager(
d60 1
a60 1
_X_EXPORT Bool
d71 1
a71 1
_X_EXPORT Bool
d89 1
a89 1
_X_EXPORT FBAreaPtr
d111 1
a111 1
_X_EXPORT FBLinearPtr
d133 1
a133 1
_X_EXPORT void
d152 1
a152 1
_X_EXPORT void
d171 1
a171 1
_X_EXPORT Bool
d189 1
a189 1
_X_EXPORT Bool
d208 1
a208 1
_X_EXPORT Bool
d231 1
a231 1
_X_EXPORT Bool
d253 1
a253 1
_X_EXPORT Bool
a804 1
#ifdef DEBUG
d806 1
a806 1
Dump(FBLinearLinkPtr pLink)
d808 1
d820 1
a821 1
#endif
d892 1
a892 3
#ifdef DEBUG
   Dump(offman->LinearAreas);
#endif
d917 1
a917 3
#ifdef DEBUG
   ErrorF("ALLOCATING LINEAR\n");
#endif
d921 1
a921 3
#ifdef DEBUG
   ErrorF("NOPE, ALLOCATING AREA\n");
#endif
d975 1
a975 3
#ifdef DEBUG
   Dump(offman->LinearAreas);
#endif
d1000 1
a1000 3
#ifdef DEBUG
	ErrorF("FREEING AREA\n");
#endif
d1006 1
a1006 3
#ifdef DEBUG
   	Dump(offman->LinearAreas);
#endif
d1028 2
a1029 4
#ifdef DEBUG
   ErrorF("FREEING LINEAR\n");
   Dump(offman->LinearAreas);
#endif
d1185 1
a1185 1
_X_EXPORT Bool
d1222 1
a1222 1
_X_EXPORT Bool
d1314 1
a1314 1
_X_EXPORT Bool
d1352 1
a1352 1
_X_EXPORT Bool
d1396 1
a1396 1
_X_EXPORT FBAreaPtr 
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d45 2
a46 1
static DevPrivateKey xf86FBManagerKey = NULL;
d53 1
a53 1
   xf86FBManagerKey = &xf86FBManagerKey;
d273 2
a274 1
static DevPrivateKey xf86FBScreenKey = &xf86FBScreenKey;
@


1.1
log
@Initial revision
@
text
@d45 1
a45 2
static int xf86FBMangerIndex = -1;
static unsigned long xf86ManagerGeneration = 0;
d52 2
a53 7
   if(xf86ManagerGeneration != serverGeneration) {
	if((xf86FBMangerIndex = AllocateScreenPrivateIndex()) < 0)
		return FALSE;
	xf86ManagerGeneration = serverGeneration;
   }

   pScreen->devPrivates[xf86FBMangerIndex].ptr = (pointer)funcs;
d62 1
a62 1
    if(xf86FBMangerIndex < 0) 
d64 1
a64 1
    if(!pScreen->devPrivates[xf86FBMangerIndex].ptr) 
d78 1
a78 1
   if(xf86FBMangerIndex < 0) 
d80 2
a81 1
   if(!(funcs = (FBManagerFuncsPtr)pScreen->devPrivates[xf86FBMangerIndex].ptr))
d99 1
a99 1
   if(xf86FBMangerIndex < 0) 
d101 2
a102 1
   if(!(funcs = (FBManagerFuncsPtr)pScreen->devPrivates[xf86FBMangerIndex].ptr))
d121 1
a121 1
   if(xf86FBMangerIndex < 0) 
d123 2
a124 1
   if(!(funcs = (FBManagerFuncsPtr)pScreen->devPrivates[xf86FBMangerIndex].ptr))
d139 1
a139 1
   if(xf86FBMangerIndex < 0) 
d141 2
a142 2
   if(!(funcs = 
	(FBManagerFuncsPtr)area->pScreen->devPrivates[xf86FBMangerIndex].ptr))
d158 1
a158 1
   if(xf86FBMangerIndex < 0) 
d160 2
a161 2
   if(!(funcs = 
	(FBManagerFuncsPtr)linear->pScreen->devPrivates[xf86FBMangerIndex].ptr))
d179 1
a179 1
   if(xf86FBMangerIndex < 0) 
d181 2
a182 2
   if(!(funcs = 
	(FBManagerFuncsPtr)resize->pScreen->devPrivates[xf86FBMangerIndex].ptr))
d197 1
a197 1
   if(xf86FBMangerIndex < 0) 
d199 2
a200 2
   if(!(funcs = 
	(FBManagerFuncsPtr)resize->pScreen->devPrivates[xf86FBMangerIndex].ptr))
d220 1
a220 1
   if(xf86FBMangerIndex < 0) 
d222 2
a223 1
   if(!(funcs = (FBManagerFuncsPtr)pScreen->devPrivates[xf86FBMangerIndex].ptr))
d241 1
a241 1
   if(xf86FBMangerIndex < 0) 
d243 2
a244 1
   if(!(funcs = (FBManagerFuncsPtr)pScreen->devPrivates[xf86FBMangerIndex].ptr))
d257 1
a257 1
   if(xf86FBMangerIndex < 0) 
d259 2
a260 1
   if(!(funcs = (FBManagerFuncsPtr)pScreen->devPrivates[xf86FBMangerIndex].ptr))
d272 1
a272 2
static unsigned long xf86FBGeneration = 0;
static int xf86FBScreenIndex = -1;
d322 2
a323 2
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;

d370 2
a371 4
	if(granularity) {
	    int tmp = x % granularity;
	    if(tmp) x += (granularity - tmp);
	}
d398 2
a399 4
 	   if(granularity) {
		int tmp = x % granularity;
		if(tmp) x += (granularity - tmp);
	   }
d448 2
a449 2
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;

d466 2
a467 2
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;
       
d507 2
a508 2
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;

d627 2
a628 2
    offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;

d683 2
a684 4
	if(granularity) {
	   int tmp = x % granularity;
	   if(tmp) x += (granularity - tmp);
        }
d733 2
a734 2
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;
       
d782 2
a783 2
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;
       
d841 3
a843 1
	 offset = (linear->linear.offset + granularity) & ~granularity;
d913 2
a914 1
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;
d934 14
a947 11
   if (gran && gran > pitch) {
	/* we can't match the specified alignment with XY allocations */
	xfree(link);
	return NULL;
   }
   if (gran && (pitch % gran)) {
       /* pitch and granularity aren't a perfect match, let's allocate
	* a bit more so we can align later on
	*/
       length += gran - 1;
   }
d970 2
a971 2
	if (gran && linear->offset % gran)
		linear->offset += gran - (linear->offset % gran);
d994 2
a995 2
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;

d1052 2
a1053 2
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;
       
d1102 2
a1103 1
    FBManagerPtr offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;
d1134 2
a1135 1
	    offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;
d1167 2
a1168 3
   FBManagerPtr offman = 
	(FBManagerPtr) pScreen->devPrivates[xf86FBScreenIndex].ptr;

d1192 1
a1192 1
   pScreen->devPrivates[xf86FBScreenIndex].ptr = NULL;
a1335 6
   if(xf86FBGeneration != serverGeneration) {
	if((xf86FBScreenIndex = AllocateScreenPrivateIndex()) < 0)
		return FALSE;
	xf86FBGeneration = serverGeneration;
   }

d1342 1
a1342 1
   pScreen->devPrivates[xf86FBScreenIndex].ptr = (pointer)offman;
d1378 1
a1378 1
   if (!pScreen->devPrivates[xf86FBScreenIndex].ptr)
d1381 2
a1382 2
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;

d1422 1
a1422 1
   if(xf86FBMangerIndex < 0) 
d1424 2
a1425 1
   if(!(funcs = (FBManagerFuncsPtr)pScreen->devPrivates[xf86FBMangerIndex].ptr))
d1428 2
a1429 2
   offman = pScreen->devPrivates[xf86FBScreenIndex].ptr;

d1433 6
a1438 3
   if(gran && ((gran > w) || (w % gran))) {
	/* we can't match the specified alignment with XY allocations */
	return NULL;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d371 4
a374 2
	if (granularity > 1)
	    x = ((x + granularity - 1) / granularity) * granularity;
d401 4
a404 2
 	   if (granularity > 1)
		x = ((x + granularity - 1) / granularity) * granularity;
d688 4
a691 2
	if (granularity > 1)
	   x = ((x + granularity - 1) / granularity) * granularity;
d848 1
a848 3
	 offset = linear->linear.offset;
	 if (granularity > 1)
	    offset = ((offset + granularity - 1) / granularity) * granularity;
d938 11
a948 14
   if (gran > 1) {
        if (gran > pitch) {
            /* we can't match the specified alignment with XY allocations */
            xfree(link);
            return NULL;
        }

        if (pitch % gran) {
            /* pitch and granularity aren't a perfect match, let's allocate
             * a bit more so we can align later on
             */
            length += gran - 1;
        }
    }
d971 2
a972 2
	if (gran > 1)
            linear->offset = ((linear->offset + gran - 1) / gran) * gran;
d1438 3
a1440 6
   if (gran > 1) {
	if (gran > w)
	    return NULL;

	if (w % gran)
	    length += gran - 1;
@

