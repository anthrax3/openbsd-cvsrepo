head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.6
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.03;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.45;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright (c) 1995  Jon Tombs
 * Copyright (c) 1995, 1996, 1999  XFree86 Inc
 * Copyright (c) 1998-2002 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 *
 * Written by Mark Vojkovich
 */

/*
 * This is quite literally just two files glued together:
 * hw/xfree86/common/xf86DGA.c is the first part, and
 * hw/xfree86/dixmods/extmod/xf86dga2.c is the second part.  One day, if
 * someone actually cares about DGA, it'd be nice to clean this up.  But trust
 * me, I am not that person.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "xf86.h"
#include "xf86str.h"
#include "xf86Priv.h"
#include "dgaproc.h"
#include <X11/extensions/xf86dgaproto.h>
#include "colormapst.h"
#include "pixmapstr.h"
#include "inputstr.h"
#include "globals.h"
#include "servermd.h"
#include "micmap.h"
#include "xkbsrv.h"
#include "xf86Xinput.h"
#include "exglobals.h"
#include "exevents.h"
#include "eventstr.h"
#include "eventconvert.h"
#include "xf86Extensions.h"

#include "mi.h"

#include "misc.h"
#include "dixstruct.h"
#include "dixevents.h"
#include "extnsionst.h"
#include "cursorstr.h"
#include "scrnintstr.h"
#include "swaprep.h"
#include "dgaproc.h"
#include "protocol-versions.h"

#include <string.h>

#define DGA_PROTOCOL_OLD_SUPPORT 1

static DevPrivateKeyRec DGAScreenKeyRec;

#define DGAScreenKeyRegistered dixPrivateKeyRegistered(&DGAScreenKeyRec)
static Bool mieq_installed;

static Bool DGACloseScreen(ScreenPtr pScreen);
static void DGADestroyColormap(ColormapPtr pmap);
static void DGAInstallColormap(ColormapPtr pmap);
static void DGAUninstallColormap(ColormapPtr pmap);
static void DGAHandleEvent(int screen_num, InternalEvent *event,
                           DeviceIntPtr device);

static void
 DGACopyModeInfo(DGAModePtr mode, XDGAModePtr xmode);

static unsigned char DGAReqCode = 0;
static int DGAErrorBase;
static int DGAEventBase;

#define DGA_GET_SCREEN_PRIV(pScreen) ((DGAScreenPtr) \
    dixLookupPrivate(&(pScreen)->devPrivates, &DGAScreenKeyRec))

typedef struct _FakedVisualList {
    Bool free;
    VisualPtr pVisual;
    struct _FakedVisualList *next;
} FakedVisualList;

typedef struct {
    ScrnInfoPtr pScrn;
    int numModes;
    DGAModePtr modes;
    CloseScreenProcPtr CloseScreen;
    DestroyColormapProcPtr DestroyColormap;
    InstallColormapProcPtr InstallColormap;
    UninstallColormapProcPtr UninstallColormap;
    DGADevicePtr current;
    DGAFunctionPtr funcs;
    int input;
    ClientPtr client;
    int pixmapMode;
    FakedVisualList *fakedVisuals;
    ColormapPtr dgaColormap;
    ColormapPtr savedColormap;
    Bool grabMouse;
    Bool grabKeyboard;
} DGAScreenRec, *DGAScreenPtr;

Bool
DGAInit(ScreenPtr pScreen, DGAFunctionPtr funcs, DGAModePtr modes, int num)
{
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    DGAScreenPtr pScreenPriv;
    int i;

    if (!funcs || !funcs->SetMode || !funcs->OpenFramebuffer)
        return FALSE;

    if (!modes || num <= 0)
        return FALSE;

    if (!dixRegisterPrivateKey(&DGAScreenKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);

    if (!pScreenPriv) {
        if (!(pScreenPriv = (DGAScreenPtr) malloc(sizeof(DGAScreenRec))))
            return FALSE;
        dixSetPrivate(&pScreen->devPrivates, &DGAScreenKeyRec, pScreenPriv);
        pScreenPriv->CloseScreen = pScreen->CloseScreen;
        pScreen->CloseScreen = DGACloseScreen;
        pScreenPriv->DestroyColormap = pScreen->DestroyColormap;
        pScreen->DestroyColormap = DGADestroyColormap;
        pScreenPriv->InstallColormap = pScreen->InstallColormap;
        pScreen->InstallColormap = DGAInstallColormap;
        pScreenPriv->UninstallColormap = pScreen->UninstallColormap;
        pScreen->UninstallColormap = DGAUninstallColormap;
    }

    pScreenPriv->pScrn = pScrn;
    pScreenPriv->numModes = num;
    pScreenPriv->modes = modes;
    pScreenPriv->current = NULL;

    pScreenPriv->funcs = funcs;
    pScreenPriv->input = 0;
    pScreenPriv->client = NULL;
    pScreenPriv->fakedVisuals = NULL;
    pScreenPriv->dgaColormap = NULL;
    pScreenPriv->savedColormap = NULL;
    pScreenPriv->grabMouse = FALSE;
    pScreenPriv->grabKeyboard = FALSE;

    for (i = 0; i < num; i++)
        modes[i].num = i + 1;

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        for (i = 0; i < num; i++)
            modes[i].flags &= ~DGA_PIXMAP_AVAILABLE;
#endif

    return TRUE;
}

/* DGAReInitModes allows the driver to re-initialize
 * the DGA mode list.
 */

Bool
DGAReInitModes(ScreenPtr pScreen, DGAModePtr modes, int num)
{
    DGAScreenPtr pScreenPriv;
    int i;

    /* No DGA? Ignore call (but don't make it look like it failed) */
    if (!DGAScreenKeyRegistered)
        return TRUE;

    pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);

    /* Same as above */
    if (!pScreenPriv)
        return TRUE;

    /* Can't do this while DGA is active */
    if (pScreenPriv->current)
        return FALSE;

    /* Quick sanity check */
    if (!num)
        modes = NULL;
    else if (!modes)
        num = 0;

    pScreenPriv->numModes = num;
    pScreenPriv->modes = modes;

    /* This practically disables DGA. So be it. */
    if (!num)
        return TRUE;

    for (i = 0; i < num; i++)
        modes[i].num = i + 1;

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        for (i = 0; i < num; i++)
            modes[i].flags &= ~DGA_PIXMAP_AVAILABLE;
#endif

    return TRUE;
}

static void
FreeMarkedVisuals(ScreenPtr pScreen)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
    FakedVisualList *prev, *curr, *tmp;

    if (!pScreenPriv->fakedVisuals)
        return;

    prev = NULL;
    curr = pScreenPriv->fakedVisuals;

    while (curr) {
        if (curr->free) {
            tmp = curr;
            curr = curr->next;
            if (prev)
                prev->next = curr;
            else
                pScreenPriv->fakedVisuals = curr;
            free(tmp->pVisual);
            free(tmp);
        }
        else {
            prev = curr;
            curr = curr->next;
        }
    }
}

static Bool
DGACloseScreen(ScreenPtr pScreen)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);

    if (mieq_installed) {
        mieqSetHandler(ET_DGAEvent, NULL);
        mieq_installed = FALSE;
    }

    FreeMarkedVisuals(pScreen);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;
    pScreen->DestroyColormap = pScreenPriv->DestroyColormap;
    pScreen->InstallColormap = pScreenPriv->InstallColormap;
    pScreen->UninstallColormap = pScreenPriv->UninstallColormap;

    /* DGAShutdown() should have ensured that no DGA
       screen were active by here */

    free(pScreenPriv);

    return ((*pScreen->CloseScreen) (pScreen));
}

static void
DGADestroyColormap(ColormapPtr pmap)
{
    ScreenPtr pScreen = pmap->pScreen;
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
    VisualPtr pVisual = pmap->pVisual;

    if (pScreenPriv->fakedVisuals) {
        FakedVisualList *curr = pScreenPriv->fakedVisuals;

        while (curr) {
            if (curr->pVisual == pVisual) {
                /* We can't get rid of them yet since FreeColormap
                   still needs the pVisual during the cleanup */
                curr->free = TRUE;
                break;
            }
            curr = curr->next;
        }
    }

    if (pScreenPriv->DestroyColormap) {
        pScreen->DestroyColormap = pScreenPriv->DestroyColormap;
        (*pScreen->DestroyColormap) (pmap);
        pScreen->DestroyColormap = DGADestroyColormap;
    }
}

static void
DGAInstallColormap(ColormapPtr pmap)
{
    ScreenPtr pScreen = pmap->pScreen;
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);

    if (pScreenPriv->current && pScreenPriv->dgaColormap) {
        if (pmap != pScreenPriv->dgaColormap) {
            pScreenPriv->savedColormap = pmap;
            pmap = pScreenPriv->dgaColormap;
        }
    }

    pScreen->InstallColormap = pScreenPriv->InstallColormap;
    (*pScreen->InstallColormap) (pmap);
    pScreen->InstallColormap = DGAInstallColormap;
}

static void
DGAUninstallColormap(ColormapPtr pmap)
{
    ScreenPtr pScreen = pmap->pScreen;
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);

    if (pScreenPriv->current && pScreenPriv->dgaColormap) {
        if (pmap == pScreenPriv->dgaColormap) {
            pScreenPriv->dgaColormap = NULL;
        }
    }

    pScreen->UninstallColormap = pScreenPriv->UninstallColormap;
    (*pScreen->UninstallColormap) (pmap);
    pScreen->UninstallColormap = DGAUninstallColormap;
}

int
xf86SetDGAMode(ScrnInfoPtr pScrn, int num, DGADevicePtr devRet)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    DGAScreenPtr pScreenPriv;
    DGADevicePtr device;
    PixmapPtr pPix = NULL;
    DGAModePtr pMode = NULL;

    /* First check if DGAInit was successful on this screen */
    if (!DGAScreenKeyRegistered)
        return BadValue;
    pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
    if (!pScreenPriv)
        return BadValue;

    if (!num) {
        if (pScreenPriv->current) {
            PixmapPtr oldPix = pScreenPriv->current->pPix;

            if (oldPix) {
                if (oldPix->drawable.id)
                    FreeResource(oldPix->drawable.id, RT_NONE);
                else
                    (*pScreen->DestroyPixmap) (oldPix);
            }
            free(pScreenPriv->current);
            pScreenPriv->current = NULL;
            pScrn->vtSema = TRUE;
            (*pScreenPriv->funcs->SetMode) (pScrn, NULL);
            if (pScreenPriv->savedColormap) {
                (*pScreen->InstallColormap) (pScreenPriv->savedColormap);
                pScreenPriv->savedColormap = NULL;
            }
            pScreenPriv->dgaColormap = NULL;
            (*pScrn->EnableDisableFBAccess) (pScrn, TRUE);

            FreeMarkedVisuals(pScreen);
        }

        pScreenPriv->grabMouse = FALSE;
        pScreenPriv->grabKeyboard = FALSE;

        return Success;
    }

    if (!pScrn->vtSema && !pScreenPriv->current)        /* Really switched away */
        return BadAlloc;

    if ((num > 0) && (num <= pScreenPriv->numModes))
        pMode = &(pScreenPriv->modes[num - 1]);
    else
        return BadValue;

    if (!(device = (DGADevicePtr) malloc(sizeof(DGADeviceRec))))
        return BadAlloc;

    if (!pScreenPriv->current) {
        Bool oldVTSema = pScrn->vtSema;

        pScrn->vtSema = FALSE;  /* kludge until we rewrite VT switching */
        (*pScrn->EnableDisableFBAccess) (pScrn, FALSE);
        pScrn->vtSema = oldVTSema;
    }

    if (!(*pScreenPriv->funcs->SetMode) (pScrn, pMode)) {
        free(device);
        return BadAlloc;
    }

    pScrn->currentMode = pMode->mode;

    if (!pScreenPriv->current && !pScreenPriv->input) {
        /* if it's multihead we need to warp the cursor off of
           our screen so it doesn't get trapped  */
    }

    pScrn->vtSema = FALSE;

    if (pScreenPriv->current) {
        PixmapPtr oldPix = pScreenPriv->current->pPix;

        if (oldPix) {
            if (oldPix->drawable.id)
                FreeResource(oldPix->drawable.id, RT_NONE);
            else
                (*pScreen->DestroyPixmap) (oldPix);
        }
        free(pScreenPriv->current);
        pScreenPriv->current = NULL;
    }

    if (pMode->flags & DGA_PIXMAP_AVAILABLE) {
        if ((pPix = (*pScreen->CreatePixmap) (pScreen, 0, 0, pMode->depth, 0))) {
            (*pScreen->ModifyPixmapHeader) (pPix,
                                            pMode->pixmapWidth,
                                            pMode->pixmapHeight, pMode->depth,
                                            pMode->bitsPerPixel,
                                            pMode->bytesPerScanline,
                                            (void *) (pMode->address));
        }
    }

    devRet->mode = device->mode = pMode;
    devRet->pPix = device->pPix = pPix;
    pScreenPriv->current = device;
    pScreenPriv->pixmapMode = FALSE;
    pScreenPriv->grabMouse = TRUE;
    pScreenPriv->grabKeyboard = TRUE;

    if (!mieq_installed) {
        mieqSetHandler(ET_DGAEvent, DGAHandleEvent);
        mieq_installed = TRUE;
    }

    return Success;
}

/*********** exported ones ***************/

static void
DGASetInputMode(int index, Bool keyboard, Bool mouse)
{
    ScreenPtr pScreen = screenInfo.screens[index];
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);

    if (pScreenPriv) {
        pScreenPriv->grabMouse = mouse;
        pScreenPriv->grabKeyboard = keyboard;

        if (!mieq_installed) {
            mieqSetHandler(ET_DGAEvent, DGAHandleEvent);
            mieq_installed = TRUE;
        }
    }
}

static Bool
DGAChangePixmapMode(int index, int *x, int *y, int mode)
{
    DGAScreenPtr pScreenPriv;
    DGADevicePtr pDev;
    DGAModePtr pMode;
    PixmapPtr pPix;

    if (!DGAScreenKeyRegistered)
        return FALSE;

    pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    if (!pScreenPriv || !pScreenPriv->current || !pScreenPriv->current->pPix)
        return FALSE;

    pDev = pScreenPriv->current;
    pPix = pDev->pPix;
    pMode = pDev->mode;

    if (mode) {
        int shift = 2;

        if (*x > (pMode->pixmapWidth - pMode->viewportWidth))
            *x = pMode->pixmapWidth - pMode->viewportWidth;
        if (*y > (pMode->pixmapHeight - pMode->viewportHeight))
            *y = pMode->pixmapHeight - pMode->viewportHeight;

        switch (xf86Screens[index]->bitsPerPixel) {
        case 16:
            shift = 1;
            break;
        case 32:
            shift = 0;
            break;
        default:
            break;
        }

        if (BITMAP_SCANLINE_PAD == 64)
            shift++;

        *x = (*x >> shift) << shift;

        pPix->drawable.x = *x;
        pPix->drawable.y = *y;
        pPix->drawable.width = pMode->viewportWidth;
        pPix->drawable.height = pMode->viewportHeight;
    }
    else {
        pPix->drawable.x = 0;
        pPix->drawable.y = 0;
        pPix->drawable.width = pMode->pixmapWidth;
        pPix->drawable.height = pMode->pixmapHeight;
    }
    pPix->drawable.serialNumber = NEXT_SERIAL_NUMBER;
    pScreenPriv->pixmapMode = mode;

    return TRUE;
}

Bool
DGAScreenAvailable(ScreenPtr pScreen)
{
    if (!DGAScreenKeyRegistered)
        return FALSE;

    if (DGA_GET_SCREEN_PRIV(pScreen))
        return TRUE;
    return FALSE;
}

static Bool
DGAAvailable(int index)
{
    ScreenPtr pScreen;

    assert(index < MAXSCREENS);
    pScreen = screenInfo.screens[index];
    return DGAScreenAvailable(pScreen);
}

Bool
DGAActive(int index)
{
    DGAScreenPtr pScreenPriv;

    if (!DGAScreenKeyRegistered)
        return FALSE;

    pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    if (pScreenPriv && pScreenPriv->current)
        return TRUE;

    return FALSE;
}

/* Called by the event code in case the server is abruptly terminated */

void
DGAShutdown(void)
{
    ScrnInfoPtr pScrn;
    int i;

    if (!DGAScreenKeyRegistered)
        return;

    for (i = 0; i < screenInfo.numScreens; i++) {
        pScrn = xf86Screens[i];

        (void) (*pScrn->SetDGAMode) (pScrn, 0, NULL);
    }
}

/* Called by the extension to initialize a mode */

static int
DGASetMode(int index, int num, XDGAModePtr mode, PixmapPtr *pPix)
{
    ScrnInfoPtr pScrn = xf86Screens[index];
    DGADeviceRec device;
    int ret;

    /* We rely on the extension to check that DGA is available */

    ret = (*pScrn->SetDGAMode) (pScrn, num, &device);
    if ((ret == Success) && num) {
        DGACopyModeInfo(device.mode, mode);
        *pPix = device.pPix;
    }

    return ret;
}

/* Called from the extension to let the DDX know which events are requested */

static void
DGASelectInput(int index, ClientPtr client, long mask)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    /* We rely on the extension to check that DGA is available */
    pScreenPriv->client = client;
    pScreenPriv->input = mask;
}

static int
DGAGetViewportStatus(int index)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    /* We rely on the extension to check that DGA is active */

    if (!pScreenPriv->funcs->GetViewport)
        return 0;

    return (*pScreenPriv->funcs->GetViewport) (pScreenPriv->pScrn);
}

static int
DGASetViewport(int index, int x, int y, int mode)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    if (pScreenPriv->funcs->SetViewport)
        (*pScreenPriv->funcs->SetViewport) (pScreenPriv->pScrn, x, y, mode);
    return Success;
}

static int
BitsClear(CARD32 data)
{
    int bits = 0;
    CARD32 mask;

    for (mask = 1; mask; mask <<= 1) {
        if (!(data & mask))
            bits++;
        else
            break;
    }

    return bits;
}

static int
DGACreateColormap(int index, ClientPtr client, int id, int mode, int alloc)
{
    ScreenPtr pScreen = screenInfo.screens[index];
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
    FakedVisualList *fvlp;
    VisualPtr pVisual;
    DGAModePtr pMode;
    ColormapPtr pmap;

    if (!mode || (mode > pScreenPriv->numModes))
        return BadValue;

    if ((alloc != AllocNone) && (alloc != AllocAll))
        return BadValue;

    pMode = &(pScreenPriv->modes[mode - 1]);

    if (!(pVisual = malloc(sizeof(VisualRec))))
        return BadAlloc;

    pVisual->vid = FakeClientID(0);
    pVisual->class = pMode->visualClass;
    pVisual->nplanes = pMode->depth;
    pVisual->ColormapEntries = 1 << pMode->depth;
    pVisual->bitsPerRGBValue = (pMode->depth + 2) / 3;

    switch (pVisual->class) {
    case PseudoColor:
    case GrayScale:
    case StaticGray:
        pVisual->bitsPerRGBValue = 8;   /* not quite */
        pVisual->redMask = 0;
        pVisual->greenMask = 0;
        pVisual->blueMask = 0;
        pVisual->offsetRed = 0;
        pVisual->offsetGreen = 0;
        pVisual->offsetBlue = 0;
        break;
    case DirectColor:
    case TrueColor:
        pVisual->ColormapEntries = 1 << pVisual->bitsPerRGBValue;
        /* fall through */
    case StaticColor:
        pVisual->redMask = pMode->red_mask;
        pVisual->greenMask = pMode->green_mask;
        pVisual->blueMask = pMode->blue_mask;
        pVisual->offsetRed = BitsClear(pVisual->redMask);
        pVisual->offsetGreen = BitsClear(pVisual->greenMask);
        pVisual->offsetBlue = BitsClear(pVisual->blueMask);
    }

    if (!(fvlp = malloc(sizeof(FakedVisualList)))) {
        free(pVisual);
        return BadAlloc;
    }

    fvlp->free = FALSE;
    fvlp->pVisual = pVisual;
    fvlp->next = pScreenPriv->fakedVisuals;
    pScreenPriv->fakedVisuals = fvlp;

    LEGAL_NEW_RESOURCE(id, client);

    return CreateColormap(id, pScreen, pVisual, &pmap, alloc, client->index);
}

/*  Called by the extension to install a colormap on DGA active screens */

static void
DGAInstallCmap(ColormapPtr cmap)
{
    ScreenPtr pScreen = cmap->pScreen;
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);

    /* We rely on the extension to check that DGA is active */

    if (!pScreenPriv->dgaColormap)
        pScreenPriv->savedColormap = GetInstalledmiColormap(pScreen);

    pScreenPriv->dgaColormap = cmap;

    (*pScreen->InstallColormap) (cmap);
}

static int
DGASync(int index)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    /* We rely on the extension to check that DGA is active */

    if (pScreenPriv->funcs->Sync)
        (*pScreenPriv->funcs->Sync) (pScreenPriv->pScrn);

    return Success;
}

static int
DGAFillRect(int index, int x, int y, int w, int h, unsigned long color)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    /* We rely on the extension to check that DGA is active */

    if (pScreenPriv->funcs->FillRect &&
        (pScreenPriv->current->mode->flags & DGA_FILL_RECT)) {

        (*pScreenPriv->funcs->FillRect) (pScreenPriv->pScrn, x, y, w, h, color);
        return Success;
    }
    return BadMatch;
}

static int
DGABlitRect(int index, int srcx, int srcy, int w, int h, int dstx, int dsty)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    /* We rely on the extension to check that DGA is active */

    if (pScreenPriv->funcs->BlitRect &&
        (pScreenPriv->current->mode->flags & DGA_BLIT_RECT)) {

        (*pScreenPriv->funcs->BlitRect) (pScreenPriv->pScrn,
                                         srcx, srcy, w, h, dstx, dsty);
        return Success;
    }
    return BadMatch;
}

static int
DGABlitTransRect(int index,
                 int srcx, int srcy,
                 int w, int h, int dstx, int dsty, unsigned long color)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    /* We rely on the extension to check that DGA is active */

    if (pScreenPriv->funcs->BlitTransRect &&
        (pScreenPriv->current->mode->flags & DGA_BLIT_RECT_TRANS)) {

        (*pScreenPriv->funcs->BlitTransRect) (pScreenPriv->pScrn,
                                              srcx, srcy, w, h, dstx, dsty,
                                              color);
        return Success;
    }
    return BadMatch;
}

static int
DGAGetModes(int index)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    /* We rely on the extension to check that DGA is available */

    return pScreenPriv->numModes;
}

static int
DGAGetModeInfo(int index, XDGAModePtr mode, int num)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    /* We rely on the extension to check that DGA is available */

    if ((num <= 0) || (num > pScreenPriv->numModes))
        return BadValue;

    DGACopyModeInfo(&(pScreenPriv->modes[num - 1]), mode);

    return Success;
}

static void
DGACopyModeInfo(DGAModePtr mode, XDGAModePtr xmode)
{
    DisplayModePtr dmode = mode->mode;

    xmode->num = mode->num;
    xmode->name = dmode->name;
    xmode->VSync_num = (int) (dmode->VRefresh * 1000.0);
    xmode->VSync_den = 1000;
    xmode->flags = mode->flags;
    xmode->imageWidth = mode->imageWidth;
    xmode->imageHeight = mode->imageHeight;
    xmode->pixmapWidth = mode->pixmapWidth;
    xmode->pixmapHeight = mode->pixmapHeight;
    xmode->bytesPerScanline = mode->bytesPerScanline;
    xmode->byteOrder = mode->byteOrder;
    xmode->depth = mode->depth;
    xmode->bitsPerPixel = mode->bitsPerPixel;
    xmode->red_mask = mode->red_mask;
    xmode->green_mask = mode->green_mask;
    xmode->blue_mask = mode->blue_mask;
    xmode->visualClass = mode->visualClass;
    xmode->viewportWidth = mode->viewportWidth;
    xmode->viewportHeight = mode->viewportHeight;
    xmode->xViewportStep = mode->xViewportStep;
    xmode->yViewportStep = mode->yViewportStep;
    xmode->maxViewportX = mode->maxViewportX;
    xmode->maxViewportY = mode->maxViewportY;
    xmode->viewportFlags = mode->viewportFlags;
    xmode->reserved1 = mode->reserved1;
    xmode->reserved2 = mode->reserved2;
    xmode->offset = mode->offset;

    if (dmode->Flags & V_INTERLACE)
        xmode->flags |= DGA_INTERLACED;
    if (dmode->Flags & V_DBLSCAN)
        xmode->flags |= DGA_DOUBLESCAN;
}

Bool
DGAVTSwitch(void)
{
    ScreenPtr pScreen;
    int i;

    for (i = 0; i < screenInfo.numScreens; i++) {
        pScreen = screenInfo.screens[i];

        /* Alternatively, this could send events to DGA clients */

        if (DGAScreenKeyRegistered) {
            DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);

            if (pScreenPriv && pScreenPriv->current)
                return FALSE;
        }
    }

    return TRUE;
}

Bool
DGAStealKeyEvent(DeviceIntPtr dev, int index, int key_code, int is_down)
{
    DGAScreenPtr pScreenPriv;
    DGAEvent event;

    if (!DGAScreenKeyRegistered)        /* no DGA */
        return FALSE;

    if (key_code < 8 || key_code > 255)
        return FALSE;

    pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    if (!pScreenPriv || !pScreenPriv->grabKeyboard)     /* no direct mode */
        return FALSE;

    event = (DGAEvent) {
        .header = ET_Internal,
        .type = ET_DGAEvent,
        .length = sizeof(event),
        .time = GetTimeInMillis(),
        .subtype = (is_down ? ET_KeyPress : ET_KeyRelease),
        .detail = key_code,
        .dx = 0,
        .dy = 0
    };
    mieqEnqueue(dev, (InternalEvent *) &event);

    return TRUE;
}

Bool
DGAStealMotionEvent(DeviceIntPtr dev, int index, int dx, int dy)
{
    DGAScreenPtr pScreenPriv;
    DGAEvent event;

    if (!DGAScreenKeyRegistered)        /* no DGA */
        return FALSE;

    pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    if (!pScreenPriv || !pScreenPriv->grabMouse)        /* no direct mode */
        return FALSE;

    event = (DGAEvent) {
        .header = ET_Internal,
        .type = ET_DGAEvent,
        .length = sizeof(event),
        .time = GetTimeInMillis(),
        .subtype = ET_Motion,
        .detail = 0,
        .dx = dx,
        .dy = dy
    };
    mieqEnqueue(dev, (InternalEvent *) &event);
    return TRUE;
}

Bool
DGAStealButtonEvent(DeviceIntPtr dev, int index, int button, int is_down)
{
    DGAScreenPtr pScreenPriv;
    DGAEvent event;

    if (!DGAScreenKeyRegistered)        /* no DGA */
        return FALSE;

    pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    if (!pScreenPriv || !pScreenPriv->grabMouse)
        return FALSE;

    event = (DGAEvent) {
        .header = ET_Internal,
        .type = ET_DGAEvent,
        .length = sizeof(event),
        .time = GetTimeInMillis(),
        .subtype = (is_down ? ET_ButtonPress : ET_ButtonRelease),
        .detail = button,
        .dx = 0,
        .dy = 0
    };
    mieqEnqueue(dev, (InternalEvent *) &event);

    return TRUE;
}

/* We have the power to steal or modify events that are about to get queued */

#define NoSuchEvent 0x80000000  /* so doesn't match NoEventMask */
static Mask filters[] = {
    NoSuchEvent,                /* 0 */
    NoSuchEvent,                /* 1 */
    KeyPressMask,               /* KeyPress */
    KeyReleaseMask,             /* KeyRelease */
    ButtonPressMask,            /* ButtonPress */
    ButtonReleaseMask,          /* ButtonRelease */
    PointerMotionMask,          /* MotionNotify (initial state) */
};

static void
DGAProcessKeyboardEvent(ScreenPtr pScreen, DGAEvent * event, DeviceIntPtr keybd)
{
    KeyClassPtr keyc = keybd->key;
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
    DeviceIntPtr pointer = GetMaster(keybd, POINTER_OR_FLOAT);
    DeviceEvent ev = {
        .header = ET_Internal,
        .length = sizeof(ev),
        .detail.key = event->detail,
        .type = event->subtype,
        .root_x = 0,
        .root_y = 0,
        .corestate = XkbStateFieldFromRec(&keyc->xkbInfo->state)
    };
    ev.corestate |= pointer->button->state;

    UpdateDeviceState(keybd, &ev);

    if (!IsMaster(keybd))
        return;

    /*
     * Deliver the DGA event
     */
    if (pScreenPriv->client) {
        dgaEvent de = {
            .u.event.time = event->time,
            .u.event.dx = event->dx,
            .u.event.dy = event->dy,
            .u.event.screen = pScreen->myNum,
            .u.event.state = ev.corestate
        };
        de.u.u.type = DGAEventBase + GetCoreType(ev.type);
        de.u.u.detail = event->detail;

        /* If the DGA client has selected input, then deliver based on the usual filter */
        TryClientEvents(pScreenPriv->client, keybd, (xEvent *) &de, 1,
                        filters[ev.type], pScreenPriv->input, 0);
    }
    else {
        /* If the keyboard is actively grabbed, deliver a grabbed core event */
        if (keybd->deviceGrab.grab && !keybd->deviceGrab.fromPassiveGrab) {
            ev.detail.key = event->detail;
            ev.time = event->time;
            ev.root_x = event->dx;
            ev.root_y = event->dy;
            ev.corestate = event->state;
            ev.deviceid = keybd->id;
            DeliverGrabbedEvent((InternalEvent *) &ev, keybd, FALSE);
        }
    }
}

static void
DGAProcessPointerEvent(ScreenPtr pScreen, DGAEvent * event, DeviceIntPtr mouse)
{
    ButtonClassPtr butc = mouse->button;
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
    DeviceIntPtr master = GetMaster(mouse, MASTER_KEYBOARD);
    DeviceEvent ev = {
        .header = ET_Internal,
        .length = sizeof(ev),
        .detail.key = event->detail,
        .type = event->subtype,
        .corestate = butc ? butc->state : 0
    };

    if (master && master->key)
        ev.corestate |= XkbStateFieldFromRec(&master->key->xkbInfo->state);

    UpdateDeviceState(mouse, &ev);

    if (!IsMaster(mouse))
        return;

    /*
     * Deliver the DGA event
     */
    if (pScreenPriv->client) {
        int coreEquiv = GetCoreType(ev.type);
        dgaEvent de = {
            .u.event.time = event->time,
            .u.event.dx = event->dx,
            .u.event.dy = event->dy,
            .u.event.screen = pScreen->myNum,
            .u.event.state = ev.corestate
        };
        de.u.u.type = DGAEventBase + coreEquiv;
        de.u.u.detail = event->detail;

        /* If the DGA client has selected input, then deliver based on the usual filter */
        TryClientEvents(pScreenPriv->client, mouse, (xEvent *) &de, 1,
                        filters[coreEquiv], pScreenPriv->input, 0);
    }
    else {
        /* If the pointer is actively grabbed, deliver a grabbed core event */
        if (mouse->deviceGrab.grab && !mouse->deviceGrab.fromPassiveGrab) {
            ev.detail.button = event->detail;
            ev.time = event->time;
            ev.root_x = event->dx;
            ev.root_y = event->dy;
            ev.corestate = event->state;
            /* DGA is core only, so valuators.data doesn't actually matter.
             * Mask must be set for EventToCore to create motion events. */
            SetBit(ev.valuators.mask, 0);
            SetBit(ev.valuators.mask, 1);
            DeliverGrabbedEvent((InternalEvent *) &ev, mouse, FALSE);
        }
    }
}

static Bool
DGAOpenFramebuffer(int index,
                   char **name,
                   unsigned char **mem, int *size, int *offset, int *flags)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    /* We rely on the extension to check that DGA is available */

    return (*pScreenPriv->funcs->OpenFramebuffer) (pScreenPriv->pScrn,
                                                   name, mem, size, offset,
                                                   flags);
}

static void
DGACloseFramebuffer(int index)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    /* We rely on the extension to check that DGA is available */
    if (pScreenPriv->funcs->CloseFramebuffer)
        (*pScreenPriv->funcs->CloseFramebuffer) (pScreenPriv->pScrn);
}

/*  For DGA 1.0 backwards compatibility only */

static int
DGAGetOldDGAMode(int index)
{
    DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
    ScrnInfoPtr pScrn = pScreenPriv->pScrn;
    DGAModePtr mode;
    int i, w, h, p;

    /* We rely on the extension to check that DGA is available */

    w = pScrn->currentMode->HDisplay;
    h = pScrn->currentMode->VDisplay;
    p = pad_to_int32(pScrn->displayWidth * bits_to_bytes(pScrn->bitsPerPixel));

    for (i = 0; i < pScreenPriv->numModes; i++) {
        mode = &(pScreenPriv->modes[i]);

        if ((mode->viewportWidth == w) && (mode->viewportHeight == h) &&
            (mode->bytesPerScanline == p) &&
            (mode->bitsPerPixel == pScrn->bitsPerPixel) &&
            (mode->depth == pScrn->depth)) {

            return mode->num;
        }
    }

    return 0;
}

static void
DGAHandleEvent(int screen_num, InternalEvent *ev, DeviceIntPtr device)
{
    DGAEvent *event = &ev->dga_event;
    ScreenPtr pScreen = screenInfo.screens[screen_num];
    DGAScreenPtr pScreenPriv;

    /* no DGA */
    if (!DGAScreenKeyRegistered || noXFree86DGAExtension)
	return;
    pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);

    /* DGA not initialized on this screen */
    if (!pScreenPriv)
        return;

    switch (event->subtype) {
    case KeyPress:
    case KeyRelease:
        DGAProcessKeyboardEvent(pScreen, event, device);
        break;
    case MotionNotify:
    case ButtonPress:
    case ButtonRelease:
        DGAProcessPointerEvent(pScreen, event, device);
        break;
    default:
        break;
    }
}

static void XDGAResetProc(ExtensionEntry * extEntry);

static void DGAClientStateChange(CallbackListPtr *, void *, void *);

static DevPrivateKeyRec DGAScreenPrivateKeyRec;

#define DGAScreenPrivateKey (&DGAScreenPrivateKeyRec)
#define DGAScreenPrivateKeyRegistered (DGAScreenPrivateKeyRec.initialized)
static DevPrivateKeyRec DGAClientPrivateKeyRec;

#define DGAClientPrivateKey (&DGAClientPrivateKeyRec)
static int DGACallbackRefCount = 0;

/* This holds the client's version information */
typedef struct {
    int major;
    int minor;
} DGAPrivRec, *DGAPrivPtr;

#define DGA_GETCLIENT(idx) ((ClientPtr) \
    dixLookupPrivate(&screenInfo.screens[idx]->devPrivates, DGAScreenPrivateKey))
#define DGA_SETCLIENT(idx,p) \
    dixSetPrivate(&screenInfo.screens[idx]->devPrivates, DGAScreenPrivateKey, p)

#define DGA_GETPRIV(c) ((DGAPrivPtr) \
    dixLookupPrivate(&(c)->devPrivates, DGAClientPrivateKey))
#define DGA_SETPRIV(c,p) \
    dixSetPrivate(&(c)->devPrivates, DGAClientPrivateKey, p)

static void
XDGAResetProc(ExtensionEntry * extEntry)
{
    DeleteCallback(&ClientStateCallback, DGAClientStateChange, NULL);
    DGACallbackRefCount = 0;
}

static int
ProcXDGAQueryVersion(ClientPtr client)
{
    xXDGAQueryVersionReply rep;

    REQUEST_SIZE_MATCH(xXDGAQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_XDGA_MAJOR_VERSION;
    rep.minorVersion = SERVER_XDGA_MINOR_VERSION;

    WriteToClient(client, sizeof(xXDGAQueryVersionReply), (char *) &rep);
    return Success;
}

static int
ProcXDGAOpenFramebuffer(ClientPtr client)
{
    REQUEST(xXDGAOpenFramebufferReq);
    xXDGAOpenFramebufferReply rep;
    char *deviceName;
    int nameSize;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    REQUEST_SIZE_MATCH(xXDGAOpenFramebufferReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (!DGAOpenFramebuffer(stuff->screen, &deviceName,
                            (unsigned char **) (&rep.mem1),
                            (int *) &rep.size, (int *) &rep.offset,
                            (int *) &rep.extra)) {
        return BadAlloc;
    }

    nameSize = deviceName ? (strlen(deviceName) + 1) : 0;
    rep.length = bytes_to_int32(nameSize);

    WriteToClient(client, sizeof(xXDGAOpenFramebufferReply), (char *) &rep);
    if (rep.length)
        WriteToClient(client, nameSize, deviceName);

    return Success;
}

static int
ProcXDGACloseFramebuffer(ClientPtr client)
{
    REQUEST(xXDGACloseFramebufferReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    REQUEST_SIZE_MATCH(xXDGACloseFramebufferReq);

    DGACloseFramebuffer(stuff->screen);

    return Success;
}

static int
ProcXDGAQueryModes(ClientPtr client)
{
    int i, num, size;

    REQUEST(xXDGAQueryModesReq);
    xXDGAQueryModesReply rep;
    xXDGAModeInfo info;
    XDGAModePtr mode;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXDGAQueryModesReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.number = 0;
    rep.sequenceNumber = client->sequence;

    if (!DGAAvailable(stuff->screen)) {
        rep.number = 0;
        rep.length = 0;
        WriteToClient(client, sz_xXDGAQueryModesReply, (char *) &rep);
        return Success;
    }

    if (!(num = DGAGetModes(stuff->screen))) {
        WriteToClient(client, sz_xXDGAQueryModesReply, (char *) &rep);
        return Success;
    }

    if (!(mode = xallocarray(num, sizeof(XDGAModeRec))))
        return BadAlloc;

    for (i = 0; i < num; i++)
        DGAGetModeInfo(stuff->screen, mode + i, i + 1);

    size = num * sz_xXDGAModeInfo;
    for (i = 0; i < num; i++)
        size += pad_to_int32(strlen(mode[i].name) + 1); /* plus NULL */

    rep.number = num;
    rep.length = bytes_to_int32(size);

    WriteToClient(client, sz_xXDGAQueryModesReply, (char *) &rep);

    for (i = 0; i < num; i++) {
        size = strlen(mode[i].name) + 1;

        info.byte_order = mode[i].byteOrder;
        info.depth = mode[i].depth;
        info.num = mode[i].num;
        info.bpp = mode[i].bitsPerPixel;
        info.name_size = (size + 3) & ~3L;
        info.vsync_num = mode[i].VSync_num;
        info.vsync_den = mode[i].VSync_den;
        info.flags = mode[i].flags;
        info.image_width = mode[i].imageWidth;
        info.image_height = mode[i].imageHeight;
        info.pixmap_width = mode[i].pixmapWidth;
        info.pixmap_height = mode[i].pixmapHeight;
        info.bytes_per_scanline = mode[i].bytesPerScanline;
        info.red_mask = mode[i].red_mask;
        info.green_mask = mode[i].green_mask;
        info.blue_mask = mode[i].blue_mask;
        info.visual_class = mode[i].visualClass;
        info.viewport_width = mode[i].viewportWidth;
        info.viewport_height = mode[i].viewportHeight;
        info.viewport_xstep = mode[i].xViewportStep;
        info.viewport_ystep = mode[i].yViewportStep;
        info.viewport_xmax = mode[i].maxViewportX;
        info.viewport_ymax = mode[i].maxViewportY;
        info.viewport_flags = mode[i].viewportFlags;
        info.reserved1 = mode[i].reserved1;
        info.reserved2 = mode[i].reserved2;

        WriteToClient(client, sz_xXDGAModeInfo, (char *) (&info));
        WriteToClient(client, size, mode[i].name);
    }

    free(mode);

    return Success;
}

static void
DGAClientStateChange(CallbackListPtr *pcbl, void *nulldata, void *calldata)
{
    NewClientInfoRec *pci = (NewClientInfoRec *) calldata;
    ClientPtr client = NULL;
    int i;

    for (i = 0; i < screenInfo.numScreens; i++) {
        if (DGA_GETCLIENT(i) == pci->client) {
            client = pci->client;
            break;
        }
    }

    if (client &&
        ((client->clientState == ClientStateGone) ||
         (client->clientState == ClientStateRetained))) {
        XDGAModeRec mode;
        PixmapPtr pPix;

        DGA_SETCLIENT(i, NULL);
        DGASelectInput(i, NULL, 0);
        DGASetMode(i, 0, &mode, &pPix);

        if (--DGACallbackRefCount == 0)
            DeleteCallback(&ClientStateCallback, DGAClientStateChange, NULL);
    }
}

static int
ProcXDGASetMode(ClientPtr client)
{
    REQUEST(xXDGASetModeReq);
    xXDGASetModeReply rep;
    XDGAModeRec mode;
    xXDGAModeInfo info;
    PixmapPtr pPix;
    ClientPtr owner;
    int size;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;
    owner = DGA_GETCLIENT(stuff->screen);

    REQUEST_SIZE_MATCH(xXDGASetModeReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.offset = 0;
    rep.flags = 0;
    rep.sequenceNumber = client->sequence;

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (owner && owner != client)
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (!stuff->mode) {
        if (owner) {
            if (--DGACallbackRefCount == 0)
                DeleteCallback(&ClientStateCallback, DGAClientStateChange,
                               NULL);
        }
        DGA_SETCLIENT(stuff->screen, NULL);
        DGASelectInput(stuff->screen, NULL, 0);
        DGASetMode(stuff->screen, 0, &mode, &pPix);
        WriteToClient(client, sz_xXDGASetModeReply, (char *) &rep);
        return Success;
    }

    if (Success != DGASetMode(stuff->screen, stuff->mode, &mode, &pPix))
        return BadValue;

    if (!owner) {
        if (DGACallbackRefCount++ == 0)
            AddCallback(&ClientStateCallback, DGAClientStateChange, NULL);
    }

    DGA_SETCLIENT(stuff->screen, client);

    if (pPix) {
        if (AddResource(stuff->pid, RT_PIXMAP, (void *) (pPix))) {
            pPix->drawable.id = (int) stuff->pid;
            rep.flags = DGA_PIXMAP_AVAILABLE;
        }
    }

    size = strlen(mode.name) + 1;

    info.byte_order = mode.byteOrder;
    info.depth = mode.depth;
    info.num = mode.num;
    info.bpp = mode.bitsPerPixel;
    info.name_size = (size + 3) & ~3L;
    info.vsync_num = mode.VSync_num;
    info.vsync_den = mode.VSync_den;
    info.flags = mode.flags;
    info.image_width = mode.imageWidth;
    info.image_height = mode.imageHeight;
    info.pixmap_width = mode.pixmapWidth;
    info.pixmap_height = mode.pixmapHeight;
    info.bytes_per_scanline = mode.bytesPerScanline;
    info.red_mask = mode.red_mask;
    info.green_mask = mode.green_mask;
    info.blue_mask = mode.blue_mask;
    info.visual_class = mode.visualClass;
    info.viewport_width = mode.viewportWidth;
    info.viewport_height = mode.viewportHeight;
    info.viewport_xstep = mode.xViewportStep;
    info.viewport_ystep = mode.yViewportStep;
    info.viewport_xmax = mode.maxViewportX;
    info.viewport_ymax = mode.maxViewportY;
    info.viewport_flags = mode.viewportFlags;
    info.reserved1 = mode.reserved1;
    info.reserved2 = mode.reserved2;

    rep.length = bytes_to_int32(sz_xXDGAModeInfo + info.name_size);

    WriteToClient(client, sz_xXDGASetModeReply, (char *) &rep);
    WriteToClient(client, sz_xXDGAModeInfo, (char *) (&info));
    WriteToClient(client, size, mode.name);

    return Success;
}

static int
ProcXDGASetViewport(ClientPtr client)
{
    REQUEST(xXDGASetViewportReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGASetViewportReq);

    DGASetViewport(stuff->screen, stuff->x, stuff->y, stuff->flags);

    return Success;
}

static int
ProcXDGAInstallColormap(ClientPtr client)
{
    ColormapPtr cmap;
    int rc;

    REQUEST(xXDGAInstallColormapReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGAInstallColormapReq);

    rc = dixLookupResourceByType((void **) &cmap, stuff->cmap, RT_COLORMAP,
                                 client, DixInstallAccess);
    if (rc != Success)
        return rc;
    DGAInstallCmap(cmap);
    return Success;
}

static int
ProcXDGASelectInput(ClientPtr client)
{
    REQUEST(xXDGASelectInputReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGASelectInputReq);

    if (DGA_GETCLIENT(stuff->screen) == client)
        DGASelectInput(stuff->screen, client, stuff->mask);

    return Success;
}

static int
ProcXDGAFillRectangle(ClientPtr client)
{
    REQUEST(xXDGAFillRectangleReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGAFillRectangleReq);

    if (Success != DGAFillRect(stuff->screen, stuff->x, stuff->y,
                               stuff->width, stuff->height, stuff->color))
        return BadMatch;

    return Success;
}

static int
ProcXDGACopyArea(ClientPtr client)
{
    REQUEST(xXDGACopyAreaReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGACopyAreaReq);

    if (Success != DGABlitRect(stuff->screen, stuff->srcx, stuff->srcy,
                               stuff->width, stuff->height, stuff->dstx,
                               stuff->dsty))
        return BadMatch;

    return Success;
}

static int
ProcXDGACopyTransparentArea(ClientPtr client)
{
    REQUEST(xXDGACopyTransparentAreaReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGACopyTransparentAreaReq);

    if (Success != DGABlitTransRect(stuff->screen, stuff->srcx, stuff->srcy,
                                    stuff->width, stuff->height, stuff->dstx,
                                    stuff->dsty, stuff->key))
        return BadMatch;

    return Success;
}

static int
ProcXDGAGetViewportStatus(ClientPtr client)
{
    REQUEST(xXDGAGetViewportStatusReq);
    xXDGAGetViewportStatusReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGAGetViewportStatusReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    rep.status = DGAGetViewportStatus(stuff->screen);

    WriteToClient(client, sizeof(xXDGAGetViewportStatusReply), (char *) &rep);
    return Success;
}

static int
ProcXDGASync(ClientPtr client)
{
    REQUEST(xXDGASyncReq);
    xXDGASyncReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGASyncReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    DGASync(stuff->screen);

    WriteToClient(client, sizeof(xXDGASyncReply), (char *) &rep);
    return Success;
}

static int
ProcXDGASetClientVersion(ClientPtr client)
{
    REQUEST(xXDGASetClientVersionReq);

    DGAPrivPtr pPriv;

    REQUEST_SIZE_MATCH(xXDGASetClientVersionReq);
    if ((pPriv = DGA_GETPRIV(client)) == NULL) {
        pPriv = malloc(sizeof(DGAPrivRec));
        /* XXX Need to look into freeing this */
        if (!pPriv)
            return BadAlloc;
        DGA_SETPRIV(client, pPriv);
    }
    pPriv->major = stuff->major;
    pPriv->minor = stuff->minor;

    return Success;
}

static int
ProcXDGAChangePixmapMode(ClientPtr client)
{
    REQUEST(xXDGAChangePixmapModeReq);
    xXDGAChangePixmapModeReply rep;
    int x, y;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGAChangePixmapModeReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    x = stuff->x;
    y = stuff->y;

    if (!DGAChangePixmapMode(stuff->screen, &x, &y, stuff->flags))
        return BadMatch;

    rep.x = x;
    rep.y = y;
    WriteToClient(client, sizeof(xXDGAChangePixmapModeReply), (char *) &rep);

    return Success;
}

static int
ProcXDGACreateColormap(ClientPtr client)
{
    REQUEST(xXDGACreateColormapReq);
    int result;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXDGACreateColormapReq);

    if (!stuff->mode)
        return BadValue;

    result = DGACreateColormap(stuff->screen, client, stuff->id,
                               stuff->mode, stuff->alloc);
    if (result != Success)
        return result;

    return Success;
}

/*
 *
 * Support for the old DGA protocol, used to live in xf86dga.c
 *
 */

#ifdef DGA_PROTOCOL_OLD_SUPPORT

static int
ProcXF86DGAGetVideoLL(ClientPtr client)
{
    REQUEST(xXF86DGAGetVideoLLReq);
    xXF86DGAGetVideoLLReply rep;
    XDGAModeRec mode;
    int num, offset, flags;
    char *name;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86DGAGetVideoLLReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (!(num = DGAGetOldDGAMode(stuff->screen)))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    /* get the parameters for the mode that best matches */
    DGAGetModeInfo(stuff->screen, &mode, num);

    if (!DGAOpenFramebuffer(stuff->screen, &name,
                            (unsigned char **) (&rep.offset),
                            (int *) (&rep.bank_size), &offset, &flags))
        return BadAlloc;

    rep.offset += mode.offset;
    rep.width = mode.bytesPerScanline / (mode.bitsPerPixel >> 3);
    rep.ram_size = rep.bank_size >> 10;

    WriteToClient(client, SIZEOF(xXF86DGAGetVideoLLReply), (char *) &rep);
    return Success;
}

static int
ProcXF86DGADirectVideo(ClientPtr client)
{
    int num;
    PixmapPtr pix;
    XDGAModeRec mode;
    ClientPtr owner;

    REQUEST(xXF86DGADirectVideoReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;
    REQUEST_SIZE_MATCH(xXF86DGADirectVideoReq);

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    owner = DGA_GETCLIENT(stuff->screen);

    if (owner && owner != client)
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (stuff->enable & XF86DGADirectGraphics) {
        if (!(num = DGAGetOldDGAMode(stuff->screen)))
            return DGAErrorBase + XF86DGANoDirectVideoMode;
    }
    else
        num = 0;

    if (Success != DGASetMode(stuff->screen, num, &mode, &pix))
        return DGAErrorBase + XF86DGAScreenNotActive;

    DGASetInputMode(stuff->screen,
                    (stuff->enable & XF86DGADirectKeyb) != 0,
                    (stuff->enable & XF86DGADirectMouse) != 0);

    /* We need to track the client and attach the teardown callback */
    if (stuff->enable &
        (XF86DGADirectGraphics | XF86DGADirectKeyb | XF86DGADirectMouse)) {
        if (!owner) {
            if (DGACallbackRefCount++ == 0)
                AddCallback(&ClientStateCallback, DGAClientStateChange, NULL);
        }

        DGA_SETCLIENT(stuff->screen, client);
    }
    else {
        if (owner) {
            if (--DGACallbackRefCount == 0)
                DeleteCallback(&ClientStateCallback, DGAClientStateChange,
                               NULL);
        }

        DGA_SETCLIENT(stuff->screen, NULL);
    }

    return Success;
}

static int
ProcXF86DGAGetViewPortSize(ClientPtr client)
{
    int num;
    XDGAModeRec mode;

    REQUEST(xXF86DGAGetViewPortSizeReq);
    xXF86DGAGetViewPortSizeReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86DGAGetViewPortSizeReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (!(num = DGAGetOldDGAMode(stuff->screen)))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    DGAGetModeInfo(stuff->screen, &mode, num);

    rep.width = mode.viewportWidth;
    rep.height = mode.viewportHeight;

    WriteToClient(client, SIZEOF(xXF86DGAGetViewPortSizeReply), (char *) &rep);
    return Success;
}

static int
ProcXF86DGASetViewPort(ClientPtr client)
{
    REQUEST(xXF86DGASetViewPortReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXF86DGASetViewPortReq);

    if (!DGAAvailable(stuff->screen))
        return DGAErrorBase + XF86DGANoDirectVideoMode;

    if (!DGAActive(stuff->screen))
        return DGAErrorBase + XF86DGADirectNotActivated;

    if (DGASetViewport(stuff->screen, stuff->x, stuff->y, DGA_FLIP_RETRACE)
        != Success)
        return DGAErrorBase + XF86DGADirectNotActivated;

    return Success;
}

static int
ProcXF86DGAGetVidPage(ClientPtr client)
{
    REQUEST(xXF86DGAGetVidPageReq);
    xXF86DGAGetVidPageReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86DGAGetVidPageReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.vpage = 0;              /* silently fail */

    WriteToClient(client, SIZEOF(xXF86DGAGetVidPageReply), (char *) &rep);
    return Success;
}

static int
ProcXF86DGASetVidPage(ClientPtr client)
{
    REQUEST(xXF86DGASetVidPageReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86DGASetVidPageReq);

    /* silently fail */

    return Success;
}

static int
ProcXF86DGAInstallColormap(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xXF86DGAInstallColormapReq);

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXF86DGAInstallColormapReq);

    if (!DGAActive(stuff->screen))
        return DGAErrorBase + XF86DGADirectNotActivated;

    rc = dixLookupResourceByType((void **) &pcmp, stuff->id, RT_COLORMAP,
                                 client, DixInstallAccess);
    if (rc == Success) {
        DGAInstallCmap(pcmp);
        return Success;
    }
    else {
        return rc;
    }
}

static int
ProcXF86DGAQueryDirectVideo(ClientPtr client)
{
    REQUEST(xXF86DGAQueryDirectVideoReq);
    xXF86DGAQueryDirectVideoReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    REQUEST_SIZE_MATCH(xXF86DGAQueryDirectVideoReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.flags = 0;

    if (DGAAvailable(stuff->screen))
        rep.flags = XF86DGADirectPresent;

    WriteToClient(client, SIZEOF(xXF86DGAQueryDirectVideoReply), (char *) &rep);
    return Success;
}

static int
ProcXF86DGAViewPortChanged(ClientPtr client)
{
    REQUEST(xXF86DGAViewPortChangedReq);
    xXF86DGAViewPortChangedReply rep;

    if (stuff->screen >= screenInfo.numScreens)
        return BadValue;

    if (DGA_GETCLIENT(stuff->screen) != client)
        return DGAErrorBase + XF86DGADirectNotActivated;

    REQUEST_SIZE_MATCH(xXF86DGAViewPortChangedReq);

    if (!DGAActive(stuff->screen))
        return DGAErrorBase + XF86DGADirectNotActivated;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.result = 1;

    WriteToClient(client, SIZEOF(xXF86DGAViewPortChangedReply), (char *) &rep);
    return Success;
}

#endif                          /* DGA_PROTOCOL_OLD_SUPPORT */

static int
SProcXDGADispatch(ClientPtr client)
{
    return DGAErrorBase + XF86DGAClientNotLocal;
}

#if 0
#define DGA_REQ_DEBUG
#endif

#ifdef DGA_REQ_DEBUG
static char *dgaMinor[] = {
    "QueryVersion",
    "GetVideoLL",
    "DirectVideo",
    "GetViewPortSize",
    "SetViewPort",
    "GetVidPage",
    "SetVidPage",
    "InstallColormap",
    "QueryDirectVideo",
    "ViewPortChanged",
    "10",
    "11",
    "QueryModes",
    "SetMode",
    "SetViewport",
    "InstallColormap",
    "SelectInput",
    "FillRectangle",
    "CopyArea",
    "CopyTransparentArea",
    "GetViewportStatus",
    "Sync",
    "OpenFramebuffer",
    "CloseFramebuffer",
    "SetClientVersion",
    "ChangePixmapMode",
    "CreateColormap",
};
#endif

static int
ProcXDGADispatch(ClientPtr client)
{
    REQUEST(xReq);

    if (!client->local)
        return DGAErrorBase + XF86DGAClientNotLocal;

#ifdef DGA_REQ_DEBUG
    if (stuff->data <= X_XDGACreateColormap)
        fprintf(stderr, "    DGA %s\n", dgaMinor[stuff->data]);
#endif

    switch (stuff->data) {
        /*
         * DGA2 Protocol
         */
    case X_XDGAQueryVersion:
        return ProcXDGAQueryVersion(client);
    case X_XDGAQueryModes:
        return ProcXDGAQueryModes(client);
    case X_XDGASetMode:
        return ProcXDGASetMode(client);
    case X_XDGAOpenFramebuffer:
        return ProcXDGAOpenFramebuffer(client);
    case X_XDGACloseFramebuffer:
        return ProcXDGACloseFramebuffer(client);
    case X_XDGASetViewport:
        return ProcXDGASetViewport(client);
    case X_XDGAInstallColormap:
        return ProcXDGAInstallColormap(client);
    case X_XDGASelectInput:
        return ProcXDGASelectInput(client);
    case X_XDGAFillRectangle:
        return ProcXDGAFillRectangle(client);
    case X_XDGACopyArea:
        return ProcXDGACopyArea(client);
    case X_XDGACopyTransparentArea:
        return ProcXDGACopyTransparentArea(client);
    case X_XDGAGetViewportStatus:
        return ProcXDGAGetViewportStatus(client);
    case X_XDGASync:
        return ProcXDGASync(client);
    case X_XDGASetClientVersion:
        return ProcXDGASetClientVersion(client);
    case X_XDGAChangePixmapMode:
        return ProcXDGAChangePixmapMode(client);
    case X_XDGACreateColormap:
        return ProcXDGACreateColormap(client);
        /*
         * Old DGA Protocol
         */
#ifdef DGA_PROTOCOL_OLD_SUPPORT
    case X_XF86DGAGetVideoLL:
        return ProcXF86DGAGetVideoLL(client);
    case X_XF86DGADirectVideo:
        return ProcXF86DGADirectVideo(client);
    case X_XF86DGAGetViewPortSize:
        return ProcXF86DGAGetViewPortSize(client);
    case X_XF86DGASetViewPort:
        return ProcXF86DGASetViewPort(client);
    case X_XF86DGAGetVidPage:
        return ProcXF86DGAGetVidPage(client);
    case X_XF86DGASetVidPage:
        return ProcXF86DGASetVidPage(client);
    case X_XF86DGAInstallColormap:
        return ProcXF86DGAInstallColormap(client);
    case X_XF86DGAQueryDirectVideo:
        return ProcXF86DGAQueryDirectVideo(client);
    case X_XF86DGAViewPortChanged:
        return ProcXF86DGAViewPortChanged(client);
#endif                          /* DGA_PROTOCOL_OLD_SUPPORT */
    default:
        return BadRequest;
    }
}

void
XFree86DGAExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if (!dixRegisterPrivateKey(&DGAClientPrivateKeyRec, PRIVATE_CLIENT, 0))
        return;

    if (!dixRegisterPrivateKey(&DGAScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return;

    if ((extEntry = AddExtension(XF86DGANAME,
                                 XF86DGANumberEvents,
                                 XF86DGANumberErrors,
                                 ProcXDGADispatch,
                                 SProcXDGADispatch,
                                 XDGAResetProc, StandardMinorOpcode))) {
        int i;

        DGAReqCode = (unsigned char) extEntry->base;
        DGAErrorBase = extEntry->errorBase;
        DGAEventBase = extEntry->eventBase;
        for (i = KeyPress; i <= MotionNotify; i++)
            SetCriticalEvent(DGAEventBase + i);
    }
}
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d474 1
a474 1
void
d491 1
a491 1
Bool
d563 1
a563 1
Bool
d609 1
a609 1
int
d629 1
a629 1
void
d639 1
a639 1
int
d652 1
a652 1
int
d678 1
a678 1
int
d747 1
a747 1
void
d763 1
a763 1
int
d776 1
a776 1
int
d792 1
a792 1
int
d809 1
a809 1
int
d829 1
a829 1
int
d839 1
a839 1
int
d1129 1
a1129 1
Bool
d1143 1
a1143 1
void
d1155 1
a1155 1
int
d1352 1
a1352 1
    if (!(mode = (XDGAModePtr) malloc(num * sizeof(XDGAModeRec))))
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d453 1
a453 1
                                            (pointer) (pMode->address));
d1217 1
a1217 1
static void DGAClientStateChange(CallbackListPtr *, pointer, pointer);
d1407 1
a1407 1
DGAClientStateChange(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
d1487 1
a1487 1
        if (AddResource(stuff->pid, RT_PIXMAP, (pointer) (pPix))) {
d1565 1
a1565 1
    rc = dixLookupResourceByType((pointer *) &cmap, stuff->cmap, RT_COLORMAP,
d1994 1
a1994 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->id, RT_COLORMAP,
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d2 2
d32 8
d44 2
d63 1
d67 14
d86 1
a86 1
static Bool DGACloseScreen(int i, ScreenPtr pScreen);
d96 3
a98 1
int *XDGAEventBase = NULL;
d132 1
a132 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d267 1
a267 1
DGACloseScreen(int i, ScreenPtr pScreen)
d288 1
a288 1
    return ((*pScreen->CloseScreen) (i, pScreen));
d355 1
a355 1
xf86SetDGAMode(int index, int num, DGADevicePtr devRet)
d357 1
a357 1
    ScreenPtr pScreen = screenInfo.screens[index];
a358 1
    ScrnInfoPtr pScrn;
a368 1
    pScrn = pScreenPriv->pScrn;
d389 1
a389 1
            (*pScrn->EnableDisableFBAccess) (index, TRUE);
d415 1
a415 1
        (*pScrn->EnableDisableFBAccess) (index, FALSE);
d553 1
a553 1
DGAAvailable(int index)
d558 1
a558 1
    if (DGA_GET_SCREEN_PRIV(screenInfo.screens[index]))
d560 7
d568 3
a570 1
    return FALSE;
d603 1
a603 1
        (void) (*pScrn->SetDGAMode) (pScrn->scrnIndex, 0, NULL);
d618 1
a618 1
    ret = (*pScrn->SetDGAMode) (index, num, &device);
d932 10
a941 9
    memset(&event, 0, sizeof(event));
    event.header = ET_Internal;
    event.type = ET_DGAEvent;
    event.length = sizeof(event);
    event.time = GetTimeInMillis();
    event.subtype = (is_down ? ET_KeyPress : ET_KeyRelease);
    event.detail = key_code;
    event.dx = 0;
    event.dy = 0;
d961 10
a970 9
    memset(&event, 0, sizeof(event));
    event.header = ET_Internal;
    event.type = ET_DGAEvent;
    event.length = sizeof(event);
    event.time = GetTimeInMillis();
    event.subtype = ET_Motion;
    event.detail = 0;
    event.dx = dx;
    event.dy = dy;
d989 10
a998 9
    memset(&event, 0, sizeof(event));
    event.header = ET_Internal;
    event.type = ET_DGAEvent;
    event.length = sizeof(event);
    event.time = GetTimeInMillis();
    event.subtype = (is_down ? ET_ButtonPress : ET_ButtonRelease);
    event.detail = button;
    event.dx = 0;
    event.dy = 0;
d1023 9
a1031 10
    DeviceEvent ev;

    memset(&ev, 0, sizeof(ev));
    ev.header = ET_Internal;
    ev.length = sizeof(ev);
    ev.detail.key = event->detail;
    ev.type = event->subtype;
    ev.root_x = 0;
    ev.root_y = 0;
    ev.corestate = XkbStateFieldFromRec(&keyc->xkbInfo->state);
d1036 3
d1043 8
a1050 3
        dgaEvent de;

        de.u.u.type = *XDGAEventBase + GetCoreType(ev.type);
a1051 5
        de.u.event.time = event->time;
        de.u.event.dx = event->dx;
        de.u.event.dy = event->dy;
        de.u.event.screen = pScreen->myNum;
        de.u.event.state = ev.corestate;
a1075 1
    DeviceEvent ev;
d1077 7
a1084 5
    memset(&ev, 0, sizeof(ev));
    ev.header = ET_Internal;
    ev.length = sizeof(ev);
    ev.type = event->subtype;
    ev.corestate = butc ? butc->state : 0;
d1090 3
d1097 9
a1105 6
        dgaEvent de;
        int coreEquiv;

        coreEquiv = GetCoreType(ev.type);

        de.u.u.type = *XDGAEventBase + coreEquiv;
a1106 5
        de.u.event.time = event->time;
        de.u.event.dx = event->dx;
        de.u.event.dy = event->dy;
        de.u.event.screen = pScreen->myNum;
        de.u.event.state = ev.corestate;
d1192 2
a1193 2
    if (!DGAScreenKeyRegistered || XDGAEventBase == 0)
        return;
a1199 3
    if (!IsMaster(device))
        return;

d1212 986
@


1.8
log
@Update to xserver 1.11.2
@
text
@d55 1
d67 1
a67 4
DGACopyModeInfo(
   DGAModePtr mode,
   XDGAModePtr xmode
);
d74 4
a77 5

typedef struct _FakedVisualList{
   Bool free;
   VisualPtr pVisual;
   struct _FakedVisualList *next;
a79 1

d81 17
a97 17
   ScrnInfoPtr 		pScrn;
   int			numModes;
   DGAModePtr		modes;
   CloseScreenProcPtr	CloseScreen;
   DestroyColormapProcPtr DestroyColormap;
   InstallColormapProcPtr InstallColormap;
   UninstallColormapProcPtr UninstallColormap;
   DGADevicePtr		current;
   DGAFunctionPtr	funcs;
   int			input;
   ClientPtr		client;
   int			pixmapMode;
   FakedVisualList	*fakedVisuals;
   ColormapPtr 		dgaColormap;
   ColormapPtr		savedColormap;
   Bool			grabMouse;
   Bool			grabKeyboard;
d101 2
a102 6
DGAInit(
   ScreenPtr pScreen,
   DGAFunctionPtr funcs, 
   DGAModePtr modes,
   int num
){
d107 2
a108 2
    if(!funcs || !funcs->SetMode || !funcs->OpenFramebuffer)
	return FALSE;
d110 2
a111 2
    if(!modes || num <= 0)
	return FALSE;
d114 1
a114 1
	return FALSE;
d118 12
a129 13
    if (!pScreenPriv)
    {
	if(!(pScreenPriv = (DGAScreenPtr)malloc(sizeof(DGAScreenRec))))
	    return FALSE;
	dixSetPrivate(&pScreen->devPrivates, &DGAScreenKeyRec, pScreenPriv);
	pScreenPriv->CloseScreen = pScreen->CloseScreen;
	pScreen->CloseScreen = DGACloseScreen;
	pScreenPriv->DestroyColormap = pScreen->DestroyColormap;
	pScreen->DestroyColormap = DGADestroyColormap;
	pScreenPriv->InstallColormap = pScreen->InstallColormap;
	pScreen->InstallColormap = DGAInstallColormap;
	pScreenPriv->UninstallColormap = pScreen->UninstallColormap;
	pScreen->UninstallColormap = DGAUninstallColormap;
d135 2
a136 2
    pScreenPriv->current = NULL;    
    
d145 3
a147 3
    
    for(i = 0; i < num; i++)
	modes[i].num = i + 1;
d150 3
a152 3
     if(!noPanoramiXExtension)
	for(i = 0; i < num; i++)
	    modes[i].flags &= ~DGA_PIXMAP_AVAILABLE;
d163 2
a164 5
DGAReInitModes(
   ScreenPtr pScreen,
   DGAModePtr modes,
   int num
){
d169 3
a171 3
    if(!DGAScreenKeyRegistered)
	return TRUE;
	
d175 2
a176 2
    if(!pScreenPriv)
	return TRUE;
d179 2
a180 2
    if(pScreenPriv->current)
	return FALSE;
d183 4
a186 4
    if(!num) 
	modes = NULL;
    else if(!modes) 
	num = 0;
d192 2
a193 2
    if(!num)
	return TRUE;
d195 2
a196 2
    for(i = 0; i < num; i++)
	modes[i].num = i + 1;
d199 3
a201 3
     if(!noPanoramiXExtension)
	for(i = 0; i < num; i++)
	    modes[i].flags &= ~DGA_PIXMAP_AVAILABLE;
d204 1
a204 1
     return TRUE;
d213 2
a214 2
    if(!pScreenPriv->fakedVisuals)
	return;
d219 15
a233 14
    while(curr) {
	if(curr->free) {
	    tmp = curr;
	    curr = curr->next;
	    if(prev)
		prev->next = curr;
	    else 
		pScreenPriv->fakedVisuals = curr;
	    free(tmp->pVisual);
	    free(tmp);
	} else {
	    prev = curr;
	    curr = curr->next;
	}
d237 1
a237 1
static Bool 
d240 1
a240 1
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
d242 4
a245 4
   if (mieq_installed) {
       mieqSetHandler(ET_DGAEvent, NULL);
       mieq_installed = FALSE;
   }
d247 1
a247 1
   FreeMarkedVisuals(pScreen);
d249 4
a252 4
   pScreen->CloseScreen = pScreenPriv->CloseScreen;
   pScreen->DestroyColormap = pScreenPriv->DestroyColormap;
   pScreen->InstallColormap = pScreenPriv->InstallColormap;
   pScreen->UninstallColormap = pScreenPriv->UninstallColormap;
d254 2
a255 2
   /* DGAShutdown() should have ensured that no DGA
	screen were active by here */
d257 1
a257 1
   free(pScreenPriv);
d259 1
a259 1
   return((*pScreen->CloseScreen)(i, pScreen));
d262 1
a262 2

static void 
d265 17
a281 17
   ScreenPtr pScreen = pmap->pScreen;
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
   VisualPtr pVisual = pmap->pVisual;

   if(pScreenPriv->fakedVisuals) {
	FakedVisualList *curr = pScreenPriv->fakedVisuals;
	
	while(curr) {
	    if(curr->pVisual == pVisual) {
		/* We can't get rid of them yet since FreeColormap
		   still needs the pVisual during the cleanup */
		curr->free = TRUE;
		break;
	    }
	    curr = curr->next;
	}
   }  
d283 1
a283 1
   if(pScreenPriv->DestroyColormap) {
d285 1
a285 1
        (*pScreen->DestroyColormap)(pmap);
d287 1
a287 1
   }
d290 1
a290 2

static void 
d296 5
a300 5
    if(pScreenPriv->current && pScreenPriv->dgaColormap) {
	if (pmap != pScreenPriv->dgaColormap) {
	    pScreenPriv->savedColormap = pmap;
	    pmap = pScreenPriv->dgaColormap;
	}
d304 1
a304 1
    (*pScreen->InstallColormap)(pmap);
d308 1
a308 1
static void 
d314 4
a317 4
    if(pScreenPriv->current && pScreenPriv->dgaColormap) {
	if (pmap == pScreenPriv->dgaColormap) {
	    pScreenPriv->dgaColormap = NULL;
	}
d321 1
a321 1
    (*pScreen->UninstallColormap)(pmap);
d326 41
a366 43
xf86SetDGAMode(
   int index,
   int num,
   DGADevicePtr devRet
){
   ScreenPtr pScreen = screenInfo.screens[index];
   DGAScreenPtr pScreenPriv;
   ScrnInfoPtr pScrn;
   DGADevicePtr device;
   PixmapPtr pPix = NULL;
   DGAModePtr pMode = NULL;

   /* First check if DGAInit was successful on this screen */
   if (!DGAScreenKeyRegistered)
	return BadValue;
   pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
   if (!pScreenPriv)
	return BadValue;
   pScrn = pScreenPriv->pScrn;

   if(!num) {
	if(pScreenPriv->current) {
	    PixmapPtr oldPix = pScreenPriv->current->pPix;
	    if(oldPix) {
		if(oldPix->drawable.id)
		    FreeResource(oldPix->drawable.id, RT_NONE);
		else
		    (*pScreen->DestroyPixmap)(oldPix);
	    }
	    free(pScreenPriv->current);
	    pScreenPriv->current = NULL;
	    pScrn->vtSema = TRUE;
	    (*pScreenPriv->funcs->SetMode)(pScrn, NULL);
	    if(pScreenPriv->savedColormap) {
	        (*pScreen->InstallColormap)(pScreenPriv->savedColormap);
		pScreenPriv->savedColormap = NULL;
	    }
	    pScreenPriv->dgaColormap = NULL;
	    (*pScrn->EnableDisableFBAccess)(index, TRUE);

	    FreeMarkedVisuals(pScreen);
	}
      
d370 35
a404 2
	return Success;
   }
d406 8
a413 52
   if(!pScrn->vtSema && !pScreenPriv->current) /* Really switched away */
	return BadAlloc;
      
   if((num > 0) && (num <= pScreenPriv->numModes))
	pMode = &(pScreenPriv->modes[num - 1]);
   else
	return BadValue;

   if(!(device = (DGADevicePtr)malloc(sizeof(DGADeviceRec))))
	return BadAlloc;

   if(!pScreenPriv->current) {
	Bool oldVTSema = pScrn->vtSema;

	pScrn->vtSema = FALSE;  /* kludge until we rewrite VT switching */
	(*pScrn->EnableDisableFBAccess)(index, FALSE);
	pScrn->vtSema = oldVTSema;
   } 

   if(!(*pScreenPriv->funcs->SetMode)(pScrn, pMode)) {
	free(device);
	return BadAlloc;
   }

   pScrn->currentMode = pMode->mode;

   if(!pScreenPriv->current && !pScreenPriv->input) {
	/* if it's multihead we need to warp the cursor off of
	   our screen so it doesn't get trapped  */
   } 

   pScrn->vtSema = FALSE;

   if(pScreenPriv->current) {
	PixmapPtr oldPix = pScreenPriv->current->pPix;
	if(oldPix) {
	    if(oldPix->drawable.id)
		FreeResource(oldPix->drawable.id, RT_NONE);
	    else
		(*pScreen->DestroyPixmap)(oldPix);
	}
	free(pScreenPriv->current);
	pScreenPriv->current = NULL;
   } 

   if(pMode->flags & DGA_PIXMAP_AVAILABLE) {
	if((pPix = (*pScreen->CreatePixmap)(pScreen, 0, 0, pMode->depth, 0))) {
	    (*pScreen->ModifyPixmapHeader)(pPix, 
			pMode->pixmapWidth, pMode->pixmapHeight,
			pMode->depth, pMode->bitsPerPixel, 
			pMode->bytesPerScanline,
 			(pointer)(pMode->address));
d415 14
a428 1
   }
d430 11
a440 11
   devRet->mode = device->mode = pMode;
   devRet->pPix = device->pPix = pPix;
   pScreenPriv->current = device;
   pScreenPriv->pixmapMode = FALSE;
   pScreenPriv->grabMouse = TRUE;
   pScreenPriv->grabKeyboard = TRUE;

   if (!mieq_installed) {
      mieqSetHandler(ET_DGAEvent, DGAHandleEvent);
      mieq_installed = TRUE;
   }
d442 1
a442 1
   return Success;
a444 2


d450 2
a451 2
   ScreenPtr pScreen = screenInfo.screens[index];
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
d453 9
a461 10
   if (pScreenPriv)
   {
      pScreenPriv->grabMouse = mouse;
      pScreenPriv->grabKeyboard = keyboard;

      if (!mieq_installed) {
          mieqSetHandler(ET_DGAEvent, DGAHandleEvent);
          mieq_installed = TRUE;
      }
   }
d467 35
a501 48
   DGAScreenPtr pScreenPriv;
   DGADevicePtr pDev;
   DGAModePtr   pMode;
   PixmapPtr    pPix;

   if(!DGAScreenKeyRegistered)
	return FALSE;

   pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

   if(!pScreenPriv || !pScreenPriv->current || !pScreenPriv->current->pPix)
	return FALSE;

   pDev = pScreenPriv->current;
   pPix = pDev->pPix;
   pMode = pDev->mode;

   if(mode) {
	int shift = 2;

	if(*x > (pMode->pixmapWidth - pMode->viewportWidth))
	    *x = pMode->pixmapWidth - pMode->viewportWidth;
	if(*y > (pMode->pixmapHeight - pMode->viewportHeight))
	    *y = pMode->pixmapHeight - pMode->viewportHeight;

	switch(xf86Screens[index]->bitsPerPixel) {
	case 16: shift = 1;  break;
	case 32: shift = 0;  break;
	default: break;
	}

	if(BITMAP_SCANLINE_PAD == 64)
	    shift++;

	*x = (*x >> shift) << shift;

	pPix->drawable.x = *x; 
	pPix->drawable.y = *y; 
	pPix->drawable.width = pMode->viewportWidth; 
	pPix->drawable.height = pMode->viewportHeight; 
   } else {
	pPix->drawable.x = 0; 
	pPix->drawable.y = 0; 
	pPix->drawable.width = pMode->pixmapWidth; 
	pPix->drawable.height = pMode->pixmapHeight; 
   }
   pPix->drawable.serialNumber = NEXT_SERIAL_NUMBER;
   pScreenPriv->pixmapMode = mode;
d503 20
a522 1
   return TRUE;
d526 1
a526 1
DGAAvailable(int index) 
d528 5
a532 5
   if(!DGAScreenKeyRegistered)
	return FALSE;
   
   if(DGA_GET_SCREEN_PRIV(screenInfo.screens[index]))
	return TRUE;
d534 1
a534 1
   return FALSE;
d538 1
a538 1
DGAActive(int index) 
d540 1
a540 1
   DGAScreenPtr pScreenPriv;
d542 2
a543 2
   if(!DGAScreenKeyRegistered)
	return FALSE;
d545 1
a545 1
   pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
d547 2
a548 2
   if(pScreenPriv && pScreenPriv->current)
	return TRUE;
d550 1
a550 1
   return FALSE;
a552 2


d561 2
a562 2
    if(!DGAScreenKeyRegistered)
	return;
d564 2
a565 2
    for(i = 0; i < screenInfo.numScreens; i++) {
	pScrn = xf86Screens[i];
d567 1
a567 1
	(void)(*pScrn->SetDGAMode)(pScrn->scrnIndex, 0, NULL);
d574 2
a575 6
DGASetMode(
   int index,
   int num,
   XDGAModePtr mode,
   PixmapPtr *pPix
){
d580 1
a580 1
    /* We rely on the extension to check that DGA is available */ 
d582 4
a585 4
    ret = (*pScrn->SetDGAMode)(index, num, &device);
    if((ret == Success) && num) {
	DGACopyModeInfo(device.mode, mode);
	*pPix = device.pPix;
d594 7
a600 10
DGASelectInput(
   int index,
   ClientPtr client,
   long mask
){
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

   /* We rely on the extension to check that DGA is available */
   pScreenPriv->client = client;
   pScreenPriv->input = mask;
d604 1
a604 1
DGAGetViewportStatus(int index) 
d606 1
a606 1
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
d608 1
a608 1
   /* We rely on the extension to check that DGA is active */ 
d610 2
a611 2
   if (!pScreenPriv->funcs->GetViewport)
      return 0;
d613 1
a613 1
   return (*pScreenPriv->funcs->GetViewport)(pScreenPriv->pScrn);
d617 7
a623 10
DGASetViewport(
   int index,
   int x, int y,
   int mode
){
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

   if (pScreenPriv->funcs->SetViewport)
      (*pScreenPriv->funcs->SetViewport)(pScreenPriv->pScrn, x, y, mode);
   return Success;
a625 1

d629 2
a630 2
   int bits = 0;
   CARD32 mask;
d632 6
a637 4
   for(mask = 1; mask; mask <<= 1) {
	if(!(data & mask)) bits++;
	else break;
   }
d639 1
a639 1
   return bits;
d645 53
a697 58
   ScreenPtr pScreen = screenInfo.screens[index];
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
   FakedVisualList *fvlp;
   VisualPtr pVisual;
   DGAModePtr pMode;
   ColormapPtr pmap;

   if(!mode || (mode > pScreenPriv->numModes))
	return BadValue;

   if((alloc != AllocNone) && (alloc != AllocAll))
	return BadValue;

   pMode = &(pScreenPriv->modes[mode - 1]);

   if(!(pVisual = malloc(sizeof(VisualRec))))
	return BadAlloc;

   pVisual->vid = FakeClientID(0);
   pVisual->class = pMode->visualClass;
   pVisual->nplanes = pMode->depth;
   pVisual->ColormapEntries = 1 << pMode->depth;
   pVisual->bitsPerRGBValue = (pMode->depth + 2) / 3;

   switch (pVisual->class) {
   case PseudoColor:
   case GrayScale:
   case StaticGray:
	pVisual->bitsPerRGBValue = 8; /* not quite */
	pVisual->redMask     = 0;
	pVisual->greenMask   = 0;
	pVisual->blueMask    = 0;
	pVisual->offsetRed   = 0;
	pVisual->offsetGreen = 0;
	pVisual->offsetBlue  = 0;
	break;
   case DirectColor:
   case TrueColor:
	pVisual->ColormapEntries = 1 << pVisual->bitsPerRGBValue;
                /* fall through */
   case StaticColor:
	pVisual->redMask = pMode->red_mask;
	pVisual->greenMask = pMode->green_mask;
	pVisual->blueMask = pMode->blue_mask;
	pVisual->offsetRed   = BitsClear(pVisual->redMask);
	pVisual->offsetGreen = BitsClear(pVisual->greenMask);
	pVisual->offsetBlue  = BitsClear(pVisual->blueMask);
   }

   if(!(fvlp = malloc(sizeof(FakedVisualList)))) {
	free(pVisual);
	return BadAlloc;
   }

   fvlp->free = FALSE;
   fvlp->pVisual = pVisual;
   fvlp->next = pScreenPriv->fakedVisuals;
   pScreenPriv->fakedVisuals = fvlp;
d699 4
a702 1
   LEGAL_NEW_RESOURCE(id, client);
d704 3
a706 1
   return CreateColormap(id, pScreen, pVisual, &pmap, alloc, client->index);
d717 1
a717 1
    /* We rely on the extension to check that DGA is active */ 
d719 2
a720 2
    if(!pScreenPriv->dgaColormap) 
	pScreenPriv->savedColormap = GetInstalledmiColormap(pScreen);
d722 1
a722 1
    pScreenPriv->dgaColormap = cmap;    
d724 1
a724 1
    (*pScreen->InstallColormap)(cmap);
d730 3
a732 3
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
   
   /* We rely on the extension to check that DGA is active */
d734 2
a735 2
   if (pScreenPriv->funcs->Sync)
      (*pScreenPriv->funcs->Sync)(pScreenPriv->pScrn);
d737 1
a737 1
   return Success;
d741 13
a753 16
DGAFillRect(
   int index,
   int x, int y, int w, int h,
   unsigned long color
){
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
   
   /* We rely on the extension to check that DGA is active */

   if(pScreenPriv->funcs->FillRect && 
	(pScreenPriv->current->mode->flags & DGA_FILL_RECT)) {

	(*pScreenPriv->funcs->FillRect)(pScreenPriv->pScrn, x, y, w, h, color);
	return Success;
   }
   return BadMatch;
d757 14
a770 18
DGABlitRect(
   int index,
   int srcx, int srcy, 
   int w, int h, 
   int dstx, int dsty
){
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
   
   /* We rely on the extension to check that DGA is active */

   if(pScreenPriv->funcs->BlitRect &&
	(pScreenPriv->current->mode->flags & DGA_BLIT_RECT)) {

	(*pScreenPriv->funcs->BlitRect)(pScreenPriv->pScrn, 	
		srcx, srcy, w, h, dstx, dsty);
	return Success;
   }
   return BadMatch;
d774 17
a790 19
DGABlitTransRect(
   int index,
   int srcx, int srcy, 
   int w, int h, 
   int dstx, int dsty,
   unsigned long color
){
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
   
   /* We rely on the extension to check that DGA is active */

   if(pScreenPriv->funcs->BlitTransRect && 
	(pScreenPriv->current->mode->flags & DGA_BLIT_RECT_TRANS)) {

	(*pScreenPriv->funcs->BlitTransRect)(pScreenPriv->pScrn, 	
		srcx, srcy, w, h, dstx, dsty, color);
	return Success;
   }
   return BadMatch;
a792 1

d796 1
a796 2
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
   /* We rely on the extension to check that DGA is available */
d798 3
a800 1
   return pScreenPriv->numModes;
d803 4
d808 1
a808 8
int
DGAGetModeInfo(
  int index,
  XDGAModePtr mode,
  int num
){
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
   /* We rely on the extension to check that DGA is available */
d810 2
a811 2
   if((num <= 0) || (num > pScreenPriv->numModes))
	return BadValue;
d813 1
a813 1
   DGACopyModeInfo(&(pScreenPriv->modes[num - 1]), mode);
d815 1
a815 1
   return Success;
a817 1

d819 3
a821 33
DGACopyModeInfo(
   DGAModePtr mode,
   XDGAModePtr xmode
){
   DisplayModePtr dmode = mode->mode;

   xmode->num = mode->num;
   xmode->name = dmode->name;
   xmode->VSync_num = (int)(dmode->VRefresh * 1000.0); 
   xmode->VSync_den = 1000;
   xmode->flags = mode->flags;
   xmode->imageWidth = mode->imageWidth;
   xmode->imageHeight = mode->imageHeight;
   xmode->pixmapWidth = mode->pixmapWidth;
   xmode->pixmapHeight = mode->pixmapHeight;
   xmode->bytesPerScanline = mode->bytesPerScanline;
   xmode->byteOrder = mode->byteOrder;
   xmode->depth = mode->depth;
   xmode->bitsPerPixel = mode->bitsPerPixel;
   xmode->red_mask = mode->red_mask;
   xmode->green_mask = mode->green_mask;
   xmode->blue_mask = mode->blue_mask;
   xmode->visualClass = mode->visualClass;
   xmode->viewportWidth = mode->viewportWidth;
   xmode->viewportHeight = mode->viewportHeight;
   xmode->xViewportStep = mode->xViewportStep;
   xmode->yViewportStep = mode->yViewportStep;
   xmode->maxViewportX = mode->maxViewportX;
   xmode->maxViewportY = mode->maxViewportY;
   xmode->viewportFlags = mode->viewportFlags;
   xmode->reserved1 = mode->reserved1;
   xmode->reserved2 = mode->reserved2;
   xmode->offset = mode->offset;
d823 32
a854 2
   if(dmode->Flags & V_INTERLACE) xmode->flags |= DGA_INTERLACED;
   if(dmode->Flags & V_DBLSCAN) xmode->flags |= DGA_DOUBLESCAN;
a856 1

d863 2
a864 2
    for(i = 0; i < screenInfo.numScreens; i++) {
       pScreen = screenInfo.screens[i];	
d866 1
a866 1
       /* Alternatively, this could send events to DGA clients */
d868 2
a869 2
       if(DGAScreenKeyRegistered) {
	   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
d871 3
a873 3
	   if(pScreenPriv && pScreenPriv->current)
		return FALSE;
       }
d876 1
a876 1
   return TRUE;
d882 2
a883 2
   DGAScreenPtr pScreenPriv;
   DGAEvent     event;
d885 1
a885 1
   if(!DGAScreenKeyRegistered) /* no DGA */
d888 2
a889 2
   if (key_code < 8 || key_code > 255)
       return FALSE;
d891 1
a891 1
   pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
d893 2
a894 2
   if(!pScreenPriv || !pScreenPriv->grabKeyboard) /* no direct mode */
        return FALSE; 
d905 1
a905 1
    mieqEnqueue (dev, (InternalEvent*)&event);
d907 2
a908 2
   return TRUE;
}  
d913 2
a914 2
   DGAScreenPtr pScreenPriv;
   DGAEvent event;
d916 1
a916 1
   if(!DGAScreenKeyRegistered) /* no DGA */
a917 2
    
   pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
d919 3
a921 1
   if(!pScreenPriv || !pScreenPriv->grabMouse) /* no direct mode */
d933 1
a933 1
    mieqEnqueue (dev, (InternalEvent*)&event);
d943 1
a943 1
    if(!DGAScreenKeyRegistered) /* no DGA */
d945 1
a945 1
    
d960 1
a960 1
    mieqEnqueue (dev, (InternalEvent*)&event);
d967 9
a975 10
#define NoSuchEvent 0x80000000	/* so doesn't match NoEventMask */
static Mask filters[] =
{
	NoSuchEvent,		       /* 0 */
	NoSuchEvent,		       /* 1 */
	KeyPressMask,		       /* KeyPress */
	KeyReleaseMask,		       /* KeyRelease */
	ButtonPressMask,	       /* ButtonPress */
	ButtonReleaseMask,	       /* ButtonRelease */
	PointerMotionMask,	       /* MotionNotify (initial state) */
d979 1
a979 1
DGAProcessKeyboardEvent (ScreenPtr pScreen, DGAEvent *event, DeviceIntPtr keybd)
d981 4
a984 4
    KeyClassPtr	    keyc = keybd->key;
    DGAScreenPtr    pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
    DeviceIntPtr    pointer = GetPairedDevice(keybd);
    DeviceEvent     ev;
d1001 1
a1001 2
    if (pScreenPriv->client)
    {
d1003 2
a1004 1
        de.u.u.type = *XDGAEventBase + GetCoreType((InternalEvent*)&ev);
d1012 3
a1014 3
	/* If the DGA client has selected input, then deliver based on the usual filter */
	TryClientEvents (pScreenPriv->client, keybd, (xEvent *)&de, 1,
			 filters[ev.type], pScreenPriv->input, 0);
d1016 3
a1018 5
    else
    {
	/* If the keyboard is actively grabbed, deliver a grabbed core event */
	if (keybd->deviceGrab.grab && !keybd->deviceGrab.fromPassiveGrab)
	{
d1020 7
a1026 7
            ev.time       = event->time;
            ev.root_x     = event->dx;
            ev.root_y     = event->dy;
            ev.corestate  = event->state;
            ev.deviceid   = keybd->id;
	    DeliverGrabbedEvent ((InternalEvent*)&ev, keybd, FALSE);
	}
d1031 1
a1031 1
DGAProcessPointerEvent (ScreenPtr pScreen, DGAEvent *event, DeviceIntPtr mouse)
d1033 4
a1036 4
    ButtonClassPtr  butc = mouse->button;
    DGAScreenPtr    pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
    DeviceEvent     ev;
    DeviceIntPtr    master = GetMaster(mouse, MASTER_KEYBOARD);
d1042 1
a1042 1
    ev.corestate  = butc ? butc->state : 0;
d1051 3
a1053 4
    if (pScreenPriv->client)
    {
        dgaEvent        de;
        int		coreEquiv;
d1055 1
a1055 1
        coreEquiv = GetCoreType((InternalEvent*)&ev);
d1065 3
a1067 3
	/* If the DGA client has selected input, then deliver based on the usual filter */
	TryClientEvents (pScreenPriv->client, mouse, (xEvent *)&de, 1,
			 filters[coreEquiv], pScreenPriv->input, 0);
d1069 8
a1076 10
    else
    {
	/* If the pointer is actively grabbed, deliver a grabbed core event */
	if (mouse->deviceGrab.grab && !mouse->deviceGrab.fromPassiveGrab)
	{
            ev.detail.button    = event->detail;
            ev.time             = event->time;
            ev.root_x           = event->dx;
            ev.root_y           = event->dy;
            ev.corestate        = event->state;
d1081 2
a1082 2
	    DeliverGrabbedEvent ((InternalEvent*)&ev, mouse, FALSE);
	}
d1087 5
a1091 9
DGAOpenFramebuffer(
   int index,
   char **name,
   unsigned char **mem,
   int *size,
   int *offset,
   int *flags
){
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
d1093 1
a1093 1
   /* We rely on the extension to check that DGA is available */
d1095 3
a1097 2
   return (*pScreenPriv->funcs->OpenFramebuffer)(pScreenPriv->pScrn, 
				name, mem, size, offset, flags);
d1103 1
a1103 1
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
d1105 3
a1107 3
   /* We rely on the extension to check that DGA is available */
   if(pScreenPriv->funcs->CloseFramebuffer)
	(*pScreenPriv->funcs->CloseFramebuffer)(pScreenPriv->pScrn);
d1115 22
a1136 22
   DGAScreenPtr pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);
   ScrnInfoPtr pScrn = pScreenPriv->pScrn;
   DGAModePtr mode;
   int i, w, h, p;

   /* We rely on the extension to check that DGA is available */

   w = pScrn->currentMode->HDisplay;
   h = pScrn->currentMode->VDisplay;
   p = pad_to_int32(pScrn->displayWidth * bits_to_bytes(pScrn->bitsPerPixel));

   for(i = 0; i < pScreenPriv->numModes; i++) {
	mode = &(pScreenPriv->modes[i]);
  	      
	if((mode->viewportWidth == w) && (mode->viewportHeight == h) &&
		(mode->bytesPerScanline == p) && 
		(mode->bitsPerPixel == pScrn->bitsPerPixel) &&
		(mode->depth == pScrn->depth)) {

		return mode->num;
	}
   }
d1138 1
a1138 1
   return 0;
d1144 3
a1146 3
    DGAEvent	    *event= &ev->dga_event;
    ScreenPtr       pScreen = screenInfo.screens[screen_num];
    DGAScreenPtr    pScreenPriv;
d1150 1
a1150 1
	return;
d1155 1
a1155 1
	return;
d1158 1
a1158 1
	return;
d1163 2
a1164 2
	DGAProcessKeyboardEvent (pScreen, event, device);
	break;
d1168 1
a1168 1
	DGAProcessPointerEvent (pScreen, event, device);
d1171 1
a1171 1
	break;
@


1.7
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d56 1
a56 1
static int mieq_installed = 0;
d253 1
a253 1
   if (XDGAEventBase) {
d255 2
a256 1
    }
d450 5
d475 1
a475 1
          mieq_installed = 1;
a944 2
static int  DGAMouseX, DGAMouseY;

a958 11
    DGAMouseX += dx;
    if (DGAMouseX < 0)
        DGAMouseX = 0;
    else if (DGAMouseX > screenInfo.screens[index]->width)
        DGAMouseX = screenInfo.screens[index]->width;
    DGAMouseY += dy;
    if (DGAMouseY < 0)
        DGAMouseY = 0;
    else if (DGAMouseY > screenInfo.screens[index]->height)
        DGAMouseY = screenInfo.screens[index]->height;

a1001 12
Bool
DGAIsDgaEvent (xEvent *e)
{
    int	    coreEquiv;
    if (!DGAScreenKeyRegistered || XDGAEventBase == 0)
	return FALSE;
    coreEquiv = e->u.u.type - *XDGAEventBase;
    if (KeyPress <= coreEquiv && coreEquiv <= MotionNotify)
	return TRUE;
    return FALSE;
}

d1023 1
d1043 2
a1044 2
        de.u.event.dx = 0;
        de.u.event.dy = 0;
d1099 2
a1100 2
        de.u.event.dx = 0;
        de.u.event.dy = 0;
d1199 3
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d1136 4
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d54 2
a55 2
static int DGAScreenKeyIndex;
static DevPrivateKey DGAScreenKey;
d74 1
a74 1
    dixLookupPrivate(&(pScreen)->devPrivates, DGAScreenKey))
d121 2
a122 1
    DGAScreenKey = &DGAScreenKeyIndex;
d128 1
a128 1
	if(!(pScreenPriv = (DGAScreenPtr)xalloc(sizeof(DGAScreenRec))))
d130 1
a130 1
	dixSetPrivate(&pScreen->devPrivates, DGAScreenKey, pScreenPriv);
d181 1
a181 1
    if(DGAScreenKey == NULL)
d239 2
a240 2
	    xfree(tmp->pVisual);
	    xfree(tmp);
d267 1
a267 1
   xfree(pScreenPriv);
d351 1
a351 1
   if (DGAScreenKey == NULL)
d367 1
a367 1
	    xfree(pScreenPriv->current);
d395 1
a395 1
   if(!(device = (DGADevicePtr)xalloc(sizeof(DGADeviceRec))))
d407 1
a407 1
	xfree(device);
d428 1
a428 1
	xfree(pScreenPriv->current);
d482 1
a482 1
   if(DGAScreenKey == NULL)
d532 1
a532 1
   if(DGAScreenKey == NULL)
d546 1
a546 1
   if(DGAScreenKey == NULL)
d567 1
a567 1
    if(DGAScreenKey == NULL)
d675 1
a675 1
   if(!(pVisual = xalloc(sizeof(VisualRec))))
d709 2
a710 2
   if(!(fvlp = xalloc(sizeof(FakedVisualList)))) {
	xfree(pVisual);
d735 1
a735 1
	pScreenPriv->savedColormap = miInstalledMaps[pScreen->myNum];
d897 1
a897 1
       if(DGAScreenKey) {
d914 1
a914 1
   if(DGAScreenKey == NULL) /* no DGA */
d947 1
a947 1
   if(DGAScreenKey == NULL) /* no DGA */
d985 1
a985 1
    if (DGAScreenKey == NULL)
d1013 1
a1013 1
    if (DGAScreenKey == NULL || XDGAEventBase == 0)
d1098 1
a1098 1
    ev.corestate  = butc->state;
d1207 1
a1207 1
    if (DGAScreenKey == NULL || XDGAEventBase == 0)
@


1.4
log
@Update to server 1.6.5.
@
text
@d38 1
a38 1
#include <X11/extensions/xf86dgastr.h>
d45 1
a45 3
#ifdef XKB
#include <xkbsrv.h>
#endif
d49 2
d62 2
a63 2
static void DGAHandleEvent(int screen_num, xEvent *event,
                           DeviceIntPtr device, int nevents);
d71 1
a71 1
_X_EXPORT int *XDGAEventBase = NULL;
d104 1
a104 1
_X_EXPORT Bool
d170 1
a170 1
_X_EXPORT Bool
d253 1
a253 5
       mieqSetHandler(*XDGAEventBase + MotionNotify, NULL);
       mieqSetHandler(*XDGAEventBase + ButtonPress, NULL);
       mieqSetHandler(*XDGAEventBase + ButtonRelease, NULL);
       mieqSetHandler(*XDGAEventBase + KeyPress, NULL);
       mieqSetHandler(*XDGAEventBase + KeyRelease, NULL);
d455 1
a455 1
_X_EXPORT void
d467 1
a467 5
          mieqSetHandler(*XDGAEventBase + MotionNotify, DGAHandleEvent);
          mieqSetHandler(*XDGAEventBase + ButtonPress, DGAHandleEvent);
          mieqSetHandler(*XDGAEventBase + ButtonRelease, DGAHandleEvent);
          mieqSetHandler(*XDGAEventBase + KeyPress, DGAHandleEvent);
          mieqSetHandler(*XDGAEventBase + KeyRelease, DGAHandleEvent);
d473 1
a473 1
_X_EXPORT Bool
d528 1
a528 1
_X_EXPORT Bool
a533 5
   if (!xf86NoSharedResources(((ScrnInfoPtr)dixLookupPrivate(
				   &screenInfo.screens[index]->devPrivates,
				   xf86ScreenKey))->scrnIndex, MEM))
       return FALSE;
   
d540 1
a540 1
_X_EXPORT Bool
d560 2
a561 2
void 
DGAShutdown()
d578 1
a578 1
_X_EXPORT int
d602 1
a602 1
_X_EXPORT void
d615 1
a615 1
_X_EXPORT int 
d628 1
a628 1
_X_EXPORT int
d656 1
a656 1
_X_EXPORT int
d725 1
a725 1
_X_EXPORT void
d741 1
a741 1
_X_EXPORT int
d754 1
a754 1
_X_EXPORT int
d773 1
a773 1
_X_EXPORT int
d794 1
a794 1
_X_EXPORT int
d817 1
a817 1
_X_EXPORT int
d827 1
a827 1
_X_EXPORT int
d885 1
a885 1
Bool 
d911 2
a912 2
   dgaEvent    de;
    
d924 10
a933 4
    de.u.u.type = *XDGAEventBase + (is_down ? KeyPress : KeyRelease);
    de.u.u.detail = key_code;
    de.u.event.time = GetTimeInMillis();
    mieqEnqueue (dev, (xEvent *) &de);
d944 1
a944 1
    dgaEvent    de;
d964 11
a974 8
    de.u.u.type = *XDGAEventBase + MotionNotify;
    de.u.u.detail = 0;
    de.u.event.time = GetTimeInMillis();
    de.u.event.dx = dx;
    de.u.event.dy = dy;
    de.u.event.pad1 = DGAMouseX;
    de.u.event.pad2 = DGAMouseY;
    mieqEnqueue (dev, (xEvent *) &de);
d982 1
a982 1
    dgaEvent de;
d992 10
a1001 8
    de.u.u.type = *XDGAEventBase + (is_down ? ButtonPress : ButtonRelease);
    de.u.u.detail = button;
    de.u.event.time = GetTimeInMillis();
    de.u.event.dx = 0;
    de.u.event.dy = 0;
    de.u.event.pad1 = DGAMouseX;
    de.u.event.pad2 = DGAMouseY;
    mieqEnqueue (dev, (xEvent *) &de);
d1033 1
a1033 1
DGAProcessKeyboardEvent (ScreenPtr pScreen, dgaEvent *de, DeviceIntPtr keybd)
a1034 2
    int		    coreEquiv;
    xEvent	    xi;
d1038 1
d1040 8
a1047 1
    coreEquiv = de->u.u.type - *XDGAEventBase;
d1049 1
a1049 11
    /*
     * Fill in remaining event state
     */
    de->u.event.dx = 0;
    de->u.event.dy = 0;
    de->u.event.screen = pScreen->myNum;
    de->u.event.state = keyc->state | pointer->button->state;

    de->u.u.type = (IEventBase - 1) + coreEquiv; /* change to XI event */
    UpdateDeviceState(keybd, (xEvent*)de, 1);
    de->u.u.type = *XDGAEventBase + coreEquiv; /* change back */
d1056 9
d1066 2
a1067 2
	TryClientEvents (pScreenPriv->client, keybd, (xEvent *) de, 1,
			 filters[coreEquiv], pScreenPriv->input, 0);
d1074 7
a1080 10
	    xi.u.u.type                  = (IEventBase - 1) + coreEquiv;
	    xi.u.u.detail                = de->u.u.detail;
	    xi.u.keyButtonPointer.time   = de->u.event.time;
	    xi.u.keyButtonPointer.eventX = de->u.event.dx;
	    xi.u.keyButtonPointer.eventY = de->u.event.dy;
	    xi.u.keyButtonPointer.rootX  = de->u.event.dx;
	    xi.u.keyButtonPointer.rootY  = de->u.event.dy;
	    xi.u.keyButtonPointer.state  = de->u.event.state;
	    ((deviceKeyButtonPointer*)&xi)->deviceid = keybd->id;
	    DeliverGrabbedEvent (&xi, keybd, FALSE, 1);
d1086 1
a1086 1
DGAProcessPointerEvent (ScreenPtr pScreen, dgaEvent *de, DeviceIntPtr mouse)
a1088 1
    int		    coreEquiv;
d1090 2
a1091 1
    xEvent	    xi;
d1093 7
a1099 6
    coreEquiv = de->u.u.type - *XDGAEventBase;
    /*
     * Fill in remaining event state
     */
    de->u.event.screen = pScreen->myNum;
    de->u.event.state = butc->state | GetPairedDevice(mouse)->key->state;
d1101 1
a1101 3
    de->u.u.type = (IEventBase - 1) + coreEquiv; /* change to XI event */
    UpdateDeviceState(mouse, (xEvent*)de, 1);
    de->u.u.type = *XDGAEventBase + coreEquiv; /* change back */
d1108 13
d1122 1
a1122 1
	TryClientEvents (pScreenPriv->client, mouse, (xEvent *) de, 1,
d1130 6
a1135 9
	    xi.u.u.type                   = (IEventBase - 1 ) + coreEquiv;
	    xi.u.u.detail                 = de->u.u.detail;
	    xi.u.keyButtonPointer.time    = de->u.event.time;
	    xi.u.keyButtonPointer.eventX  = de->u.event.dx;
	    xi.u.keyButtonPointer.eventY  = de->u.event.dy;
	    xi.u.keyButtonPointer.rootX   = de->u.event.dx;
	    xi.u.keyButtonPointer.rootY   = de->u.event.dy;
	    xi.u.keyButtonPointer.state   = de->u.event.state;
	    DeliverGrabbedEvent (&xi, mouse, FALSE, 1);
d1140 1
a1140 1
_X_EXPORT Bool 
d1157 1
a1157 1
_X_EXPORT void
d1169 1
a1169 1
_X_EXPORT int 
d1181 1
a1181 1
   p = ((pScrn->displayWidth * (pScrn->bitsPerPixel >> 3)) + 3) & ~3L;
d1199 1
a1199 1
DGAHandleEvent(int screen_num, xEvent *event, DeviceIntPtr device, int nevents)
d1201 1
a1201 1
    dgaEvent	    *de = (dgaEvent *) event;
a1203 1
    int		    coreEquiv;
d1209 1
a1209 1
    
d1213 2
a1214 7
    
    coreEquiv = de->u.u.type - *XDGAEventBase;
    /* Not a DGA event; shouldn't happen, but you never know. */
    if (coreEquiv < KeyPress || coreEquiv > MotionNotify)
	return;
    
    switch (coreEquiv) {
d1217 1
a1217 1
	DGAProcessKeyboardEvent (pScreen, de, device);
d1219 5
a1224 1
	DGAProcessPointerEvent (pScreen, de, device);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d123 16
a138 2
    if(!(pScreenPriv = (DGAScreenPtr)xalloc(sizeof(DGAScreenRec))))
	return FALSE;
a161 11

    dixSetPrivate(&pScreen->devPrivates, DGAScreenKey, pScreenPriv);
    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = DGACloseScreen;
    pScreenPriv->DestroyColormap = pScreen->DestroyColormap;
    pScreen->DestroyColormap = DGADestroyColormap;
    pScreenPriv->InstallColormap = pScreen->InstallColormap;
    pScreen->InstallColormap = DGAInstallColormap;
    pScreenPriv->UninstallColormap = pScreen->UninstallColormap;
    pScreen->UninstallColormap = DGAUninstallColormap;

@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d49 2
d54 2
a55 1
static DevPrivateKey DGAScreenKey = NULL;
d121 1
a121 1
    DGAScreenKey = &DGAScreenKey;
d918 1
a918 1
DGAStealKeyEvent(int index, int key_code, int is_down)
d926 3
d937 1
a937 1
    mieqEnqueue (inputInfo.keyboard, (xEvent *) &de);
d945 1
a945 1
DGAStealMotionEvent(int index, int dx, int dy)
d975 1
a975 1
    mieqEnqueue (inputInfo.pointer, (xEvent *) &de);
d980 1
a980 1
DGAStealButtonEvent(int index, int button, int is_down)
d1000 1
a1000 1
    mieqEnqueue (inputInfo.pointer, (xEvent *) &de);
a1033 5
    int             key, bit;
    register BYTE   *kptr;
    register int    i;
    register CARD8  modifiers;
    register CARD16 mask;
d1035 1
a1035 1
    xEvent	    core;
d1038 2
a1039 1
    
d1048 5
a1052 1
    de->u.event.state = keyc->state | (inputInfo.pointer)->button->state;
a1054 53
     * Keep the core state in sync by duplicating what
     * CoreProcessKeyboardEvent does
     */
    key = de->u.u.detail;
    kptr = &keyc->down[key >> 3];
    bit = 1 << (key & 7);
    modifiers = keyc->modifierMap[key];
    switch (coreEquiv)
    {
    case KeyPress:
	inputInfo.pointer->valuator->motionHintWindow = NullWindow;
	*kptr |= bit;
	keyc->prev_state = keyc->state;
#ifdef XKB
	if (noXkbExtension)
#endif
	{
	    
	    for (i = 0, mask = 1; modifiers; i++, mask <<= 1)
	    {
		if (mask & modifiers)
		{
		    /* This key affects modifier "i" */
		    keyc->modifierKeyCount[i]++;
		    keyc->state |= mask;
		    modifiers &= ~mask;
		}
	    }
	}
	break;
    case KeyRelease:
	inputInfo.pointer->valuator->motionHintWindow = NullWindow;
	*kptr &= ~bit;
	keyc->prev_state = keyc->state;
#ifdef XKB
	if (noXkbExtension)
#endif
	{
	    for (i = 0, mask = 1; modifiers; i++, mask <<= 1)
	    {
		if (mask & modifiers) {
		    /* This key affects modifier "i" */
		    if (--keyc->modifierKeyCount[i] <= 0) {
			keyc->state &= ~mask;
			keyc->modifierKeyCount[i] = 0;
		    }
		    modifiers &= ~mask;
		}
	    }
	}
	break;
    }
    /*
d1060 1
a1060 1
	TryClientEvents (pScreenPriv->client, (xEvent *) de, 1, 
d1066 1
a1066 1
	if (keybd->grab && !keybd->fromPassiveGrab)
d1068 10
a1077 9
	    core.u.u.type		    = coreEquiv;
	    core.u.u.detail		    = de->u.u.detail;
	    core.u.keyButtonPointer.time    = de->u.event.time;
	    core.u.keyButtonPointer.eventX  = de->u.event.dx;
	    core.u.keyButtonPointer.eventY  = de->u.event.dy;
	    core.u.keyButtonPointer.rootX   = de->u.event.dx;
	    core.u.keyButtonPointer.rootY   = de->u.event.dy;
	    core.u.keyButtonPointer.state   = de->u.event.state;
	    DeliverGrabbedEvent (&core, keybd, FALSE, 1);
d1086 1
a1086 1
    int		    coreEquiv;    
d1088 1
a1088 1
    xEvent	    core;
d1095 6
a1100 39
    de->u.event.state = butc->state | inputInfo.keyboard->key->state;
    /*
     * Keep the core state in sync by duplicating what
     * CoreProcessPointerEvent does
     */
    if (coreEquiv != MotionNotify)
    {
	register int  key;
	register BYTE *kptr;
	int           bit;
	
	key = de->u.u.detail;
	kptr = &butc->down[key >> 3];
	bit = 1 << (key & 7);
	switch (coreEquiv)
	{
	case ButtonPress: 
	    mouse->valuator->motionHintWindow = NullWindow;
	    if (!(*kptr & bit))
		butc->buttonsDown++;
	    butc->motionMask = ButtonMotionMask;
	    *kptr |= bit;
	    if (key <= 5)
		butc->state |= (Button1Mask >> 1) << key;
	    break;
	case ButtonRelease: 
	    mouse->valuator->motionHintWindow = NullWindow;
	    if (*kptr & bit)
		--butc->buttonsDown;
	    if (!butc->buttonsDown)
		butc->motionMask = 0;
	    *kptr &= ~bit;
	    if (key == 0)
		return;
	    if (key <= 5)
		butc->state &= ~((Button1Mask >> 1) << key);
	    break;
	}
    }
d1107 1
a1107 1
	TryClientEvents (pScreenPriv->client, (xEvent *) de, 1, 
d1113 1
a1113 1
	if (mouse->grab && !mouse->fromPassiveGrab)
d1115 9
a1123 9
	    core.u.u.type		    = coreEquiv;
	    core.u.u.detail		    = de->u.u.detail;
	    core.u.keyButtonPointer.time    = de->u.event.time;
	    core.u.keyButtonPointer.eventX  = de->u.event.dx;
	    core.u.keyButtonPointer.eventY  = de->u.event.dy;
	    core.u.keyButtonPointer.rootX   = de->u.event.dx;
	    core.u.keyButtonPointer.rootY   = de->u.event.dy;
	    core.u.keyButtonPointer.state   = de->u.event.state;
	    DeliverGrabbedEvent (&core, mouse, FALSE, 1);
d1211 1
a1211 1
	DGAProcessKeyboardEvent (pScreen, de, inputInfo.keyboard);
d1214 1
a1214 1
	DGAProcessPointerEvent (pScreen, de, inputInfo.pointer);
@


1.1
log
@Initial revision
@
text
@d46 1
a46 1
#include <X11/extensions/XKBsrv.h>
d50 4
a53 2
static unsigned long DGAGeneration = 0;
static int DGAScreenIndex = -1;
d59 2
d70 2
a71 2
#define DGA_GET_SCREEN_PRIV(pScreen) \
	((DGAScreenPtr)((pScreen)->devPrivates[DGAScreenIndex].ptr))
a100 1

d118 1
a118 5
    if(DGAGeneration != serverGeneration) {
	if((DGAScreenIndex = AllocateScreenPrivateIndex()) < 0)
	    return FALSE;
	DGAGeneration = serverGeneration;
    }
d146 1
a146 2

    pScreen->devPrivates[DGAScreenIndex].ptr = (pointer)pScreenPriv;
a155 5
    /*
     * This is now set in InitOutput().
     *
    pScrn->SetDGAMode = xf86SetDGAMode;
     */
d174 1
a174 1
    if(DGAScreenIndex < 0)
a240 1

d246 8
d348 1
a348 1
   if (DGAScreenIndex < 0)
d430 1
a430 1
	if((pPix = (*pScreen->CreatePixmap)(pScreen, 0, 0, pMode->depth))) {
d463 9
d483 1
a483 1
   if(DGAScreenIndex < 0)
d533 1
a533 1
   if(DGAScreenIndex < 0)
d536 3
a538 2
   if (!xf86NoSharedResources(((ScrnInfoPtr)screenInfo.screens[index]->
			 devPrivates[xf86ScreenIndex].ptr)->scrnIndex,MEM))
d552 1
a552 1
   if(DGAScreenIndex < 0)
d573 1
a573 1
    if(DGAScreenIndex < 0)
d903 1
a903 1
       if(DGAScreenIndex >= 0) {
a913 3

/* We have the power to steal or modify events that are about to get queued */

d915 1
a915 1
DGAStealKeyEvent(int index, xEvent *e)
d918 4
a921 4
    dgaEvent	de;

   if(DGAScreenIndex < 0) /* no DGA */
	return FALSE;
d926 6
a931 1
	return FALSE;
a932 4
    de.u.u.type = e->u.u.type + *XDGAEventBase;
    de.u.u.detail = e->u.u.detail;
    de.u.event.time = e->u.keyButtonPointer.time;
    xf86eqEnqueue ((xEvent *) &de);
d934 1
a934 1
}
d939 1
a939 1
DGAStealMouseEvent(int index, xEvent *e, int dx, int dy)
d942 1
a942 4
    dgaEvent	de;

   if(DGAScreenIndex < 0) /* no DGA */
	return FALSE;
d944 3
d950 2
a951 2
	return FALSE;
    
d954 1
a954 1
	DGAMouseX = 0;
d956 1
a956 1
	DGAMouseX = screenInfo.screens[index]->width;
d959 1
a959 1
	DGAMouseY = 0;
d961 4
a964 4
	DGAMouseY = screenInfo.screens[index]->height;
    de.u.u.type = e->u.u.type + *XDGAEventBase;
    de.u.u.detail = e->u.u.detail;
    de.u.event.time = e->u.keyButtonPointer.time;
d969 27
a995 1
    xf86eqEnqueue ((xEvent *) &de);
d999 2
d1005 1
a1005 1
    if (DGAScreenIndex < 0 || XDGAEventBase == 0)
a1206 33
Bool
DGADeliverEvent (ScreenPtr pScreen, xEvent *e)
{
    dgaEvent	    *de = (dgaEvent *) e;
    DGAScreenPtr    pScreenPriv;
    int		    coreEquiv;

    /* no DGA */
    if (DGAScreenIndex < 0 || XDGAEventBase == 0)
	return FALSE;
    pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
    
    /* DGA not initialized on this screen */
    if (!pScreenPriv)
	return FALSE;
    
    coreEquiv = de->u.u.type - *XDGAEventBase;
    /* Not a DGA event */
    if (coreEquiv < KeyPress || coreEquiv > MotionNotify)
	return FALSE;
    
    switch (coreEquiv) {
    case KeyPress:
    case KeyRelease:
	DGAProcessKeyboardEvent (pScreen, de, inputInfo.keyboard);
	break;
    default:
	DGAProcessPointerEvent (pScreen, de, inputInfo.pointer);
	break;
    }
    return TRUE;
}

d1265 32
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d46 1
a46 1
#include <xkbsrv.h>
a49 2
#include "mi.h"

a51 1
static int mieq_installed = 0;
a56 2
static void DGAHandleEvent(int screen_num, xEvent *event,
                           DeviceIntPtr device, int nevents);
d97 1
d147 1
d158 5
d248 1
a253 8
   if (XDGAEventBase) {
       mieqSetHandler(*XDGAEventBase + MotionNotify, NULL);
       mieqSetHandler(*XDGAEventBase + ButtonPress, NULL);
       mieqSetHandler(*XDGAEventBase + ButtonRelease, NULL);
       mieqSetHandler(*XDGAEventBase + KeyPress, NULL);
       mieqSetHandler(*XDGAEventBase + KeyRelease, NULL);
    }

a462 9

      if (!mieq_installed) {
          mieqSetHandler(*XDGAEventBase + MotionNotify, DGAHandleEvent);
          mieqSetHandler(*XDGAEventBase + ButtonPress, DGAHandleEvent);
          mieqSetHandler(*XDGAEventBase + ButtonRelease, DGAHandleEvent);
          mieqSetHandler(*XDGAEventBase + KeyPress, DGAHandleEvent);
          mieqSetHandler(*XDGAEventBase + KeyRelease, DGAHandleEvent);
          mieq_installed = 1;
      }
d904 3
d908 1
a908 1
DGAStealKeyEvent(int index, int key_code, int is_down)
d911 2
a912 2
   dgaEvent    de;
    
d914 1
a914 1
        return FALSE;
d919 1
a919 6
        return FALSE; 

    de.u.u.type = *XDGAEventBase + (is_down ? KeyPress : KeyRelease);
    de.u.u.detail = key_code;
    de.u.event.time = GetTimeInMillis();
    mieqEnqueue (inputInfo.keyboard, (xEvent *) &de);
d921 4
d926 1
a926 1
}  
d931 1
a931 1
DGAStealMotionEvent(int index, int dx, int dy)
d934 1
a934 1
    dgaEvent    de;
d937 2
a938 2
        return FALSE;
    
d942 2
a943 2
        return FALSE;

d946 1
a946 1
        DGAMouseX = 0;
d948 1
a948 1
        DGAMouseX = screenInfo.screens[index]->width;
d951 1
a951 1
        DGAMouseY = 0;
d953 4
a956 4
        DGAMouseY = screenInfo.screens[index]->height;
    de.u.u.type = *XDGAEventBase + MotionNotify;
    de.u.u.detail = 0;
    de.u.event.time = GetTimeInMillis();
d961 1
a961 1
    mieqEnqueue (inputInfo.pointer, (xEvent *) &de);
a965 28
DGAStealButtonEvent(int index, int button, int is_down)
{
    DGAScreenPtr pScreenPriv;
    dgaEvent de;

    if (DGAScreenIndex < 0)
        return FALSE;
    
    pScreenPriv = DGA_GET_SCREEN_PRIV(screenInfo.screens[index]);

    if (!pScreenPriv || !pScreenPriv->grabMouse)
        return FALSE;

    de.u.u.type = *XDGAEventBase + (is_down ? ButtonPress : ButtonRelease);
    de.u.u.detail = button;
    de.u.event.time = GetTimeInMillis();
    de.u.event.dx = 0;
    de.u.event.dy = 0;
    de.u.event.pad1 = DGAMouseX;
    de.u.event.pad2 = DGAMouseY;
    mieqEnqueue (inputInfo.pointer, (xEvent *) &de);

    return TRUE;
}

/* We have the power to steal or modify events that are about to get queued */

Bool
d1171 33
a1261 32
static void
DGAHandleEvent(int screen_num, xEvent *event, DeviceIntPtr device, int nevents)
{
    dgaEvent	    *de = (dgaEvent *) event;
    ScreenPtr       pScreen = screenInfo.screens[screen_num];
    DGAScreenPtr    pScreenPriv;
    int		    coreEquiv;

    /* no DGA */
    if (DGAScreenIndex < 0 || XDGAEventBase == 0)
	return;
    pScreenPriv = DGA_GET_SCREEN_PRIV(pScreen);
    
    /* DGA not initialized on this screen */
    if (!pScreenPriv)
	return;
    
    coreEquiv = de->u.u.type - *XDGAEventBase;
    /* Not a DGA event; shouldn't happen, but you never know. */
    if (coreEquiv < KeyPress || coreEquiv > MotionNotify)
	return;
    
    switch (coreEquiv) {
    case KeyPress:
    case KeyRelease:
	DGAProcessKeyboardEvent (pScreen, de, inputInfo.keyboard);
	break;
    default:
	DGAProcessPointerEvent (pScreen, de, inputInfo.pointer);
	break;
    }
}
@

