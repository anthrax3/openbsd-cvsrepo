head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.13;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.46;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * Copyright (c) 1998-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

/*
 * Author: David Dawes <dawes@@xfree86.org>
 *
 * This file includes public option handling functions.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <stdlib.h>
#include <ctype.h>
#include <X11/X.h>
#include "os.h"
#include "xf86.h"
#include "xf86Opt.h"
#include "xf86Xinput.h"
#include "xf86Optrec.h"
#include "xf86Parser.h"
#include "optionstr.h"

static Bool ParseOptionValue(int scrnIndex, XF86OptionPtr options,
                             OptionInfoPtr p, Bool markUsed);

/*
 * xf86CollectOptions collects the options from each of the config file
 * sections used by the screen and puts the combined list in pScrn->options.
 * This function requires that the following have been initialised:
 *
 *	pScrn->confScreen
 *	pScrn->Entities[i]->device
 *	pScrn->display
 *	pScrn->monitor
 *
 * The extraOpts parameter may optionally contain a list of additional options
 * to include.
 *
 * The order of precedence for options is:
 *
 *   extraOpts, display, confScreen, monitor, device
 */

void
xf86CollectOptions(ScrnInfoPtr pScrn, XF86OptionPtr extraOpts)
{
    XF86OptionPtr tmp;
    XF86OptionPtr extras = (XF86OptionPtr) extraOpts;
    GDevPtr device;

    int i;

    pScrn->options = NULL;

    for (i = pScrn->numEntities - 1; i >= 0; i--) {
        device = xf86GetDevFromEntity(pScrn->entityList[i],
                                      pScrn->entityInstanceList[i]);
        if (device && device->options) {
            tmp = xf86optionListDup(device->options);
            if (pScrn->options)
                xf86optionListMerge(pScrn->options, tmp);
            else
                pScrn->options = tmp;
        }
    }
    if (pScrn->monitor->options) {
        tmp = xf86optionListDup(pScrn->monitor->options);
        if (pScrn->options)
            pScrn->options = xf86optionListMerge(pScrn->options, tmp);
        else
            pScrn->options = tmp;
    }
    if (pScrn->confScreen->options) {
        tmp = xf86optionListDup(pScrn->confScreen->options);
        if (pScrn->options)
            pScrn->options = xf86optionListMerge(pScrn->options, tmp);
        else
            pScrn->options = tmp;
    }
    if (pScrn->display->options) {
        tmp = xf86optionListDup(pScrn->display->options);
        if (pScrn->options)
            pScrn->options = xf86optionListMerge(pScrn->options, tmp);
        else
            pScrn->options = tmp;
    }
    if (extras) {
        tmp = xf86optionListDup(extras);
        if (pScrn->options)
            pScrn->options = xf86optionListMerge(pScrn->options, tmp);
        else
            pScrn->options = tmp;
    }
}

/*
 * xf86CollectInputOptions collects extra options for an InputDevice (other
 * than those added by the config backend).
 * The options are merged into the existing ones and thus take precedence
 * over the others.
 */

void
xf86CollectInputOptions(InputInfoPtr pInfo, const char **defaultOpts)
{
    if (defaultOpts) {
        XF86OptionPtr tmp = xf86optionListCreate(defaultOpts, -1, 0);

        if (pInfo->options)
            pInfo->options = xf86optionListMerge(tmp, pInfo->options);
        else
            pInfo->options = tmp;
    }
}

/**
 * Duplicate the option list passed in. The returned pointer will be a newly
 * allocated option list and must be freed by the caller.
 */
XF86OptionPtr
xf86OptionListDuplicate(XF86OptionPtr options)
{
    XF86OptionPtr o = NULL;

    while (options) {
        o = xf86AddNewOption(o, xf86OptionName(options),
                             xf86OptionValue(options));
        options = xf86nextOption(options);
    }

    return o;
}

/* Created for new XInput stuff -- essentially extensions to the parser	*/

static int
LookupIntOption(XF86OptionPtr optlist, const char *name, int deflt,
                Bool markUsed)
{
    OptionInfoRec o;

    o.name = name;
    o.type = OPTV_INTEGER;
    if (ParseOptionValue(-1, optlist, &o, markUsed))
        deflt = o.value.num;
    return deflt;
}

static double
LookupRealOption(XF86OptionPtr optlist, const char *name, double deflt,
                 Bool markUsed)
{
    OptionInfoRec o;

    o.name = name;
    o.type = OPTV_REAL;
    if (ParseOptionValue(-1, optlist, &o, markUsed))
        deflt = o.value.realnum;
    return deflt;
}

static char *
LookupStrOption(XF86OptionPtr optlist, const char *name, const char *deflt,
                Bool markUsed)
{
    OptionInfoRec o;

    o.name = name;
    o.type = OPTV_STRING;
    if (ParseOptionValue(-1, optlist, &o, markUsed))
        deflt = o.value.str;
    if (deflt)
        return strdup(deflt);
    else
        return NULL;
}

static int
LookupBoolOption(XF86OptionPtr optlist, const char *name, int deflt,
                 Bool markUsed)
{
    OptionInfoRec o;

    o.name = name;
    o.type = OPTV_BOOLEAN;
    if (ParseOptionValue(-1, optlist, &o, markUsed))
        deflt = o.value.bool;
    return deflt;
}

static double
LookupPercentOption(XF86OptionPtr optlist, const char *name, double deflt,
                    Bool markUsed)
{
    OptionInfoRec o;

    o.name = name;
    o.type = OPTV_PERCENT;
    if (ParseOptionValue(-1, optlist, &o, markUsed))
        deflt = o.value.realnum;
    return deflt;
}

/* These xf86Set* functions are intended for use by non-screen specific code */

int
xf86SetIntOption(XF86OptionPtr optlist, const char *name, int deflt)
{
    return LookupIntOption(optlist, name, deflt, TRUE);
}

double
xf86SetRealOption(XF86OptionPtr optlist, const char *name, double deflt)
{
    return LookupRealOption(optlist, name, deflt, TRUE);
}

char *
xf86SetStrOption(XF86OptionPtr optlist, const char *name, const char *deflt)
{
    return LookupStrOption(optlist, name, deflt, TRUE);
}

int
xf86SetBoolOption(XF86OptionPtr optlist, const char *name, int deflt)
{
    return LookupBoolOption(optlist, name, deflt, TRUE);
}

double
xf86SetPercentOption(XF86OptionPtr optlist, const char *name, double deflt)
{
    return LookupPercentOption(optlist, name, deflt, TRUE);
}

/*
 * These are like the Set*Option functions, but they don't mark the options
 * as used.
 */
int
xf86CheckIntOption(XF86OptionPtr optlist, const char *name, int deflt)
{
    return LookupIntOption(optlist, name, deflt, FALSE);
}

double
xf86CheckRealOption(XF86OptionPtr optlist, const char *name, double deflt)
{
    return LookupRealOption(optlist, name, deflt, FALSE);
}

char *
xf86CheckStrOption(XF86OptionPtr optlist, const char *name, const char *deflt)
{
    return LookupStrOption(optlist, name, deflt, FALSE);
}

int
xf86CheckBoolOption(XF86OptionPtr optlist, const char *name, int deflt)
{
    return LookupBoolOption(optlist, name, deflt, FALSE);
}

double
xf86CheckPercentOption(XF86OptionPtr optlist, const char *name, double deflt)
{
    return LookupPercentOption(optlist, name, deflt, FALSE);
}

/*
 * xf86AddNewOption() has the required property of replacing the option value
 * if the option is already present.
 */
XF86OptionPtr
xf86ReplaceIntOption(XF86OptionPtr optlist, const char *name, const int val)
{
    char tmp[16];

    snprintf(tmp, sizeof(tmp), "%i", val);
    return xf86AddNewOption(optlist, name, tmp);
}

XF86OptionPtr
xf86ReplaceRealOption(XF86OptionPtr optlist, const char *name, const double val)
{
    char tmp[32];

    snprintf(tmp, sizeof(tmp), "%f", val);
    return xf86AddNewOption(optlist, name, tmp);
}

XF86OptionPtr
xf86ReplaceBoolOption(XF86OptionPtr optlist, const char *name, const Bool val)
{
    return xf86AddNewOption(optlist, name, val ? "True" : "False");
}

XF86OptionPtr
xf86ReplacePercentOption(XF86OptionPtr optlist, const char *name,
                         const double val)
{
    char tmp[16];

    snprintf(tmp, sizeof(tmp), "%lf%%", val);
    return xf86AddNewOption(optlist, name, tmp);
}

XF86OptionPtr
xf86ReplaceStrOption(XF86OptionPtr optlist, const char *name, const char *val)
{
    return xf86AddNewOption(optlist, name, val);
}

XF86OptionPtr
xf86AddNewOption(XF86OptionPtr head, const char *name, const char *val)
{
    /* XXX These should actually be allocated in the parser library. */
    char *tmp = val ? strdup(val) : NULL;
    char *tmp_name = strdup(name);

    return xf86addNewOption(head, tmp_name, tmp);
}

XF86OptionPtr
xf86NewOption(char *name, char *value)
{
    return xf86newOption(name, value);
}

XF86OptionPtr
xf86NextOption(XF86OptionPtr list)
{
    return xf86nextOption(list);
}

XF86OptionPtr
xf86OptionListCreate(const char **options, int count, int used)
{
    return xf86optionListCreate(options, count, used);
}

XF86OptionPtr
xf86OptionListMerge(XF86OptionPtr head, XF86OptionPtr tail)
{
    return xf86optionListMerge(head, tail);
}

void
xf86OptionListFree(XF86OptionPtr opt)
{
    xf86optionListFree(opt);
}

char *
xf86OptionName(XF86OptionPtr opt)
{
    return xf86optionName(opt);
}

char *
xf86OptionValue(XF86OptionPtr opt)
{
    return xf86optionValue(opt);
}

void
xf86OptionListReport(XF86OptionPtr parm)
{
    XF86OptionPtr opts = parm;

    while (opts) {
        if (xf86optionValue(opts))
            xf86ErrorFVerb(5, "\tOption \"%s\" \"%s\"\n",
                           xf86optionName(opts), xf86optionValue(opts));
        else
            xf86ErrorFVerb(5, "\tOption \"%s\"\n", xf86optionName(opts));
        opts = xf86nextOption(opts);
    }
}

/* End of XInput-caused section	*/

XF86OptionPtr
xf86FindOption(XF86OptionPtr options, const char *name)
{
    return xf86findOption(options, name);
}

const char *
xf86FindOptionValue(XF86OptionPtr options, const char *name)
{
    return xf86findOptionValue(options, name);
}

void
xf86MarkOptionUsed(XF86OptionPtr option)
{
    if (option != NULL)
        option->opt_used = TRUE;
}

void
xf86MarkOptionUsedByName(XF86OptionPtr options, const char *name)
{
    XF86OptionPtr opt;

    opt = xf86findOption(options, name);
    if (opt != NULL)
        opt->opt_used = TRUE;
}

Bool
xf86CheckIfOptionUsed(XF86OptionPtr option)
{
    if (option != NULL)
        return option->opt_used;
    else
        return FALSE;
}

Bool
xf86CheckIfOptionUsedByName(XF86OptionPtr options, const char *name)
{
    XF86OptionPtr opt;

    opt = xf86findOption(options, name);
    if (opt != NULL)
        return opt->opt_used;
    else
        return FALSE;
}

void
xf86ShowUnusedOptions(int scrnIndex, XF86OptionPtr opt)
{
    while (opt) {
        if (opt->opt_name && !opt->opt_used) {
            xf86DrvMsg(scrnIndex, X_WARNING, "Option \"%s\" is not used\n",
                       opt->opt_name);
        }
        opt = opt->list.next;
    }
}

static Bool
GetBoolValue(OptionInfoPtr p, const char *s)
{
    return xf86getBoolValue(&p->value.bool, s);
}

static Bool
ParseOptionValue(int scrnIndex, XF86OptionPtr options, OptionInfoPtr p,
                 Bool markUsed)
{
    const char *s;
    char *end;
    Bool wasUsed = FALSE;

    if ((s = xf86findOptionValue(options, p->name)) != NULL) {
        if (markUsed) {
            wasUsed = xf86CheckIfOptionUsedByName(options, p->name);
            xf86MarkOptionUsedByName(options, p->name);
        }
        switch (p->type) {
        case OPTV_INTEGER:
            if (*s == '\0') {
                if (markUsed) {
                    xf86DrvMsg(scrnIndex, X_WARNING,
                               "Option \"%s\" requires an integer value\n",
                               p->name);
                }
                p->found = FALSE;
            }
            else {
                p->value.num = strtoul(s, &end, 0);
                if (*end == '\0') {
                    p->found = TRUE;
                }
                else {
                    if (markUsed) {
                        xf86DrvMsg(scrnIndex, X_WARNING,
                                   "Option \"%s\" requires an integer value\n",
                                   p->name);
                    }
                    p->found = FALSE;
                }
            }
            break;
        case OPTV_STRING:
            if (*s == '\0') {
                if (markUsed) {
                    xf86DrvMsg(scrnIndex, X_WARNING,
                               "Option \"%s\" requires a string value\n",
                               p->name);
                }
                p->found = FALSE;
            }
            else {
                p->value.str = s;
                p->found = TRUE;
            }
            break;
        case OPTV_ANYSTR:
            p->value.str = s;
            p->found = TRUE;
            break;
        case OPTV_REAL:
            if (*s == '\0') {
                if (markUsed) {
                    xf86DrvMsg(scrnIndex, X_WARNING,
                               "Option \"%s\" requires a floating point "
                               "value\n", p->name);
                }
                p->found = FALSE;
            }
            else {
                p->value.realnum = strtod(s, &end);
                if (*end == '\0') {
                    p->found = TRUE;
                }
                else {
                    if (markUsed) {
                        xf86DrvMsg(scrnIndex, X_WARNING,
                                   "Option \"%s\" requires a floating point "
                                   "value\n", p->name);
                    }
                    p->found = FALSE;
                }
            }
            break;
        case OPTV_BOOLEAN:
            if (GetBoolValue(p, s)) {
                p->found = TRUE;
            }
            else {
                if (markUsed) {
                    xf86DrvMsg(scrnIndex, X_WARNING,
                               "Option \"%s\" requires a boolean value\n",
                               p->name);
                }
                p->found = FALSE;
            }
            break;
        case OPTV_PERCENT:
        {
            char tmp = 0;

            /* awkward match, but %% doesn't increase the match counter,
             * hence 100 looks the same as 100% to the caller of sccanf
             */
            if (sscanf(s, "%lf%c", &p->value.realnum, &tmp) != 2 || tmp != '%') {
                if (markUsed) {
                    xf86DrvMsg(scrnIndex, X_WARNING,
                               "Option \"%s\" requires a percent value\n",
                               p->name);
                }
                p->found = FALSE;
            }
            else {
                p->found = TRUE;
            }
        }
            break;
        case OPTV_FREQ:
            if (*s == '\0') {
                if (markUsed) {
                    xf86DrvMsg(scrnIndex, X_WARNING,
                               "Option \"%s\" requires a frequency value\n",
                               p->name);
                }
                p->found = FALSE;
            }
            else {
                double freq = strtod(s, &end);
                int units = 0;

                if (end != s) {
                    p->found = TRUE;
                    if (!xf86NameCmp(end, "Hz"))
                        units = 1;
                    else if (!xf86NameCmp(end, "kHz") || !xf86NameCmp(end, "k"))
                        units = 1000;
                    else if (!xf86NameCmp(end, "MHz") || !xf86NameCmp(end, "M"))
                        units = 1000000;
                    else {
                        if (markUsed) {
                            xf86DrvMsg(scrnIndex, X_WARNING,
                                       "Option \"%s\" requires a frequency value\n",
                                       p->name);
                        }
                        p->found = FALSE;
                    }
                    if (p->found)
                        freq *= (double) units;
                }
                else {
                    if (markUsed) {
                        xf86DrvMsg(scrnIndex, X_WARNING,
                                   "Option \"%s\" requires a frequency value\n",
                                   p->name);
                    }
                    p->found = FALSE;
                }
                if (p->found) {
                    p->value.freq.freq = freq;
                    p->value.freq.units = units;
                }
            }
            break;
        case OPTV_NONE:
            /* Should never get here */
            p->found = FALSE;
            break;
        }
        if (p->found && markUsed) {
            int verb = 2;

            if (wasUsed)
                verb = 4;
            xf86DrvMsgVerb(scrnIndex, X_CONFIG, verb, "Option \"%s\"", p->name);
            if (!(p->type == OPTV_BOOLEAN && *s == 0)) {
                xf86ErrorFVerb(verb, " \"%s\"", s);
            }
            xf86ErrorFVerb(verb, "\n");
        }
    }
    else if (p->type == OPTV_BOOLEAN) {
        /* Look for matches with options with or without a "No" prefix. */
        char *n, *newn;
        OptionInfoRec opt;

        n = xf86NormalizeName(p->name);
        if (!n) {
            p->found = FALSE;
            return FALSE;
        }
        if (strncmp(n, "no", 2) == 0) {
            newn = n + 2;
        }
        else {
            free(n);
            if (asprintf(&n, "No%s", p->name) == -1) {
                p->found = FALSE;
                return FALSE;
            }
            newn = n;
        }
        if ((s = xf86findOptionValue(options, newn)) != NULL) {
            if (markUsed)
                xf86MarkOptionUsedByName(options, newn);
            if (GetBoolValue(&opt, s)) {
                p->value.bool = !opt.value.bool;
                p->found = TRUE;
            }
            else {
                xf86DrvMsg(scrnIndex, X_WARNING,
                           "Option \"%s\" requires a boolean value\n", newn);
                p->found = FALSE;
            }
        }
        else {
            p->found = FALSE;
        }
        if (p->found && markUsed) {
            xf86DrvMsgVerb(scrnIndex, X_CONFIG, 2, "Option \"%s\"", newn);
            if (*s != 0) {
                xf86ErrorFVerb(2, " \"%s\"", s);
            }
            xf86ErrorFVerb(2, "\n");
        }
        free(n);
    }
    else {
        p->found = FALSE;
    }
    return p->found;
}

void
xf86ProcessOptions(int scrnIndex, XF86OptionPtr options, OptionInfoPtr optinfo)
{
    OptionInfoPtr p;

    for (p = optinfo; p->name != NULL; p++) {
        ParseOptionValue(scrnIndex, options, p, TRUE);
    }
}

OptionInfoPtr
xf86TokenToOptinfo(const OptionInfoRec * table, int token)
{
    const OptionInfoRec *p, *match = NULL, *set = NULL;

    if (!table) {
        ErrorF("xf86TokenToOptinfo: table is NULL\n");
        return NULL;
    }

    for (p = table; p->token >= 0; p++) {
        if (p->token == token) {
            match = p;
            if (p->found)
                set = p;
        }
    }

    if (set)
        return (OptionInfoPtr) set;
    else if (match)
        return (OptionInfoPtr) match;
    else
        return NULL;
}

const char *
xf86TokenToOptName(const OptionInfoRec * table, int token)
{
    const OptionInfoRec *p;

    p = xf86TokenToOptinfo(table, token);
    return p ? p->name : NULL;
}

Bool
xf86IsOptionSet(const OptionInfoRec * table, int token)
{
    OptionInfoPtr p;

    p = xf86TokenToOptinfo(table, token);
    return p && p->found;
}

const char *
xf86GetOptValString(const OptionInfoRec * table, int token)
{
    OptionInfoPtr p;

    p = xf86TokenToOptinfo(table, token);
    if (p && p->found)
        return p->value.str;
    else
        return NULL;
}

Bool
xf86GetOptValInteger(const OptionInfoRec * table, int token, int *value)
{
    OptionInfoPtr p;

    p = xf86TokenToOptinfo(table, token);
    if (p && p->found) {
        *value = p->value.num;
        return TRUE;
    }
    else
        return FALSE;
}

Bool
xf86GetOptValULong(const OptionInfoRec * table, int token, unsigned long *value)
{
    OptionInfoPtr p;

    p = xf86TokenToOptinfo(table, token);
    if (p && p->found) {
        *value = p->value.num;
        return TRUE;
    }
    else
        return FALSE;
}

Bool
xf86GetOptValReal(const OptionInfoRec * table, int token, double *value)
{
    OptionInfoPtr p;

    p = xf86TokenToOptinfo(table, token);
    if (p && p->found) {
        *value = p->value.realnum;
        return TRUE;
    }
    else
        return FALSE;
}

Bool
xf86GetOptValFreq(const OptionInfoRec * table, int token,
                  OptFreqUnits expectedUnits, double *value)
{
    OptionInfoPtr p;

    p = xf86TokenToOptinfo(table, token);
    if (p && p->found) {
        if (p->value.freq.units > 0) {
            /* Units give, so the scaling is known. */
            switch (expectedUnits) {
            case OPTUNITS_HZ:
                *value = p->value.freq.freq;
                break;
            case OPTUNITS_KHZ:
                *value = p->value.freq.freq / 1000.0;
                break;
            case OPTUNITS_MHZ:
                *value = p->value.freq.freq / 1000000.0;
                break;
            }
        }
        else {
            /* No units given, so try to guess the scaling. */
            switch (expectedUnits) {
            case OPTUNITS_HZ:
                *value = p->value.freq.freq;
                break;
            case OPTUNITS_KHZ:
                if (p->value.freq.freq > 1000.0)
                    *value = p->value.freq.freq / 1000.0;
                else
                    *value = p->value.freq.freq;
                break;
            case OPTUNITS_MHZ:
                if (p->value.freq.freq > 1000000.0)
                    *value = p->value.freq.freq / 1000000.0;
                else if (p->value.freq.freq > 1000.0)
                    *value = p->value.freq.freq / 1000.0;
                else
                    *value = p->value.freq.freq;
            }
        }
        return TRUE;
    }
    else
        return FALSE;
}

Bool
xf86GetOptValBool(const OptionInfoRec * table, int token, Bool *value)
{
    OptionInfoPtr p;

    p = xf86TokenToOptinfo(table, token);
    if (p && p->found) {
        *value = p->value.bool;
        return TRUE;
    }
    else
        return FALSE;
}

Bool
xf86ReturnOptValBool(const OptionInfoRec * table, int token, Bool def)
{
    OptionInfoPtr p;

    p = xf86TokenToOptinfo(table, token);
    if (p && p->found) {
        return p->value.bool;
    }
    else
        return def;
}

int
xf86NameCmp(const char *s1, const char *s2)
{
    return xf86nameCompare(s1, s2);
}

char *
xf86NormalizeName(const char *s)
{
    char *ret, *q;
    const char *p;

    if (s == NULL)
        return NULL;

    ret = malloc(strlen(s) + 1);
    for (p = s, q = ret; *p != 0; p++) {
        switch (*p) {
        case '_':
        case ' ':
        case '\t':
            continue;
        default:
            if (isupper(*p))
                *q++ = tolower(*p);
            else
                *q++ = *p;
        }
    }
    *q = '\0';
    return ret;
}
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d481 2
a482 1
    char *s, *end;
d759 1
a759 1
char *
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d746 1
a746 1
    return p->name;
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d279 1
a279 1
xf86CheckStrOption(XF86OptionPtr optlist, const char *name, char *deflt)
d518 1
a518 1
                               "Option \"%s\" requires an string value\n",
@


1.4
log
@Update to xserver 1.11.2
@
text
@d43 1
d47 1
d49 2
a50 2
static Bool ParseOptionValue(int scrnIndex, pointer options, OptionInfoPtr p,
			     Bool markUsed);
d71 1
a71 1
xf86CollectOptions(ScrnInfoPtr pScrn, pointer extraOpts)
d74 1
a74 1
    XF86OptionPtr extras = (XF86OptionPtr)extraOpts;
d76 1
a76 1
    
d81 10
a90 10
    for (i=pScrn->numEntities - 1; i >= 0; i--) {
	device = xf86GetDevFromEntity(pScrn->entityList[i],
					pScrn->entityInstanceList[i]);
	if (device && device->options) {
	    tmp = xf86optionListDup(device->options);
	    if (pScrn->options)
		xf86optionListMerge(pScrn->options,tmp);
	    else
		pScrn->options = tmp;
	}
d93 5
a97 5
	tmp = xf86optionListDup(pScrn->monitor->options);
	if (pScrn->options)
	    pScrn->options = xf86optionListMerge(pScrn->options, tmp);
	else
	    pScrn->options = tmp;
d100 5
a104 5
	tmp = xf86optionListDup(pScrn->confScreen->options);
	if (pScrn->options)
	    pScrn->options = xf86optionListMerge(pScrn->options, tmp);
	else
	    pScrn->options = tmp;
d107 5
a111 5
	tmp = xf86optionListDup(pScrn->display->options);
	if (pScrn->options)
	    pScrn->options = xf86optionListMerge(pScrn->options, tmp);
	else
	    pScrn->options = tmp;
d114 5
a118 5
	tmp = xf86optionListDup(extras);
	if (pScrn->options)
	    pScrn->options = xf86optionListMerge(pScrn->options, tmp);
	else
	    pScrn->options = tmp;
d133 6
a138 5
	XF86OptionPtr tmp =xf86optionListCreate(defaultOpts, -1, 0);
	if (pInfo->options)
	    pInfo->options = xf86optionListMerge(tmp, pInfo->options);
	else
	    pInfo->options = tmp;
d146 2
a147 2
pointer
xf86OptionListDuplicate(pointer options)
d149 1
a149 1
    pointer o = NULL;
d151 3
a153 3
    while (options)
    {
        o = xf86AddNewOption(o, xf86OptionName(options), xf86OptionValue(options));
a159 1

d163 2
a164 1
LookupIntOption(pointer optlist, const char *name, int deflt, Bool markUsed)
d171 1
a171 1
	deflt = o.value.num;
a174 1

d176 2
a177 2
LookupRealOption(pointer optlist, const char *name, double deflt,
		 Bool markUsed)
d184 1
a184 1
	deflt = o.value.realnum;
a187 1

d189 2
a190 1
LookupStrOption(pointer optlist, const char *name, char *deflt, Bool markUsed)
d199 1
a199 1
	return strdup(deflt);
d201 1
a201 1
	return NULL;
a203 1

d205 2
a206 1
LookupBoolOption(pointer optlist, const char *name, int deflt, Bool markUsed)
d213 1
a213 1
	deflt = o.value.bool;
d218 2
a219 1
LookupPercentOption(pointer optlist, const char *name, double deflt, Bool markUsed)
d226 1
a226 1
	deflt = o.value.realnum;
d233 1
a233 1
xf86SetIntOption(pointer optlist, const char *name, int deflt)
a237 1

d239 1
a239 1
xf86SetRealOption(pointer optlist, const char *name, double deflt)
a243 1

d245 1
a245 1
xf86SetStrOption(pointer optlist, const char *name, char *deflt)
a249 1

d251 1
a251 1
xf86SetBoolOption(pointer optlist, const char *name, int deflt)
d257 1
a257 1
xf86SetPercentOption(pointer optlist, const char *name, double deflt)
d267 1
a267 1
xf86CheckIntOption(pointer optlist, const char *name, int deflt)
a271 1

d273 1
a273 1
xf86CheckRealOption(pointer optlist, const char *name, double deflt)
a277 1

d279 1
a279 1
xf86CheckStrOption(pointer optlist, const char *name, char *deflt)
a283 1

d285 1
a285 1
xf86CheckBoolOption(pointer optlist, const char *name, int deflt)
a289 1

d291 1
a291 1
xf86CheckPercentOption(pointer optlist, const char *name, double deflt)
d295 1
d297 1
a297 1
 * addNewOption() has the required property of replacing the option value
d300 2
a301 2
pointer
xf86ReplaceIntOption(pointer optlist, const char *name, const int val)
d304 3
a306 2
    sprintf(tmp,"%i",val);
    return xf86AddNewOption(optlist,name,tmp);
d309 2
a310 2
pointer
xf86ReplaceRealOption(pointer optlist, const char *name, const double val)
d313 3
a315 2
    snprintf(tmp,32,"%f",val);
    return xf86AddNewOption(optlist,name,tmp);
d318 2
a319 2
pointer
xf86ReplaceBoolOption(pointer optlist, const char *name, const Bool val)
d321 1
a321 1
    return xf86AddNewOption(optlist,name,val?"True":"False");
d324 3
a326 2
pointer
xf86ReplacePercentOption(pointer optlist, const char *name, const double val)
d329 3
a331 2
    sprintf(tmp, "%lf%%", val);
    return xf86AddNewOption(optlist,name,tmp);
d334 2
a335 2
pointer
xf86ReplaceStrOption(pointer optlist, const char *name, const char* val)
d337 1
a337 1
      return xf86AddNewOption(optlist,name,val);
d340 2
a341 2
pointer
xf86AddNewOption(pointer head, const char *name, const char *val)
d350 1
a350 2

pointer
d356 2
a357 3

pointer
xf86NextOption(pointer list)
d362 1
a362 1
pointer
d365 1
a365 1
	return xf86optionListCreate(options, count, used);
d368 2
a369 2
pointer
xf86OptionListMerge(pointer head, pointer tail)
d371 1
a371 1
	return xf86optionListMerge(head, tail);
d375 1
a375 1
xf86OptionListFree(pointer opt)
d377 1
a377 1
	xf86optionListFree(opt);
d381 1
a381 1
xf86OptionName(pointer opt)
d383 1
a383 1
	return xf86optionName(opt);
d387 1
a387 1
xf86OptionValue(pointer opt)
d389 1
a389 1
	return xf86optionValue(opt);
d393 1
a393 1
xf86OptionListReport(pointer parm)
d397 7
a403 7
    while(opts) {
	if (xf86optionValue(opts))
	    xf86ErrorFVerb(5, "\tOption \"%s\" \"%s\"\n",
			    xf86optionName(opts), xf86optionValue(opts));
	else
	    xf86ErrorFVerb( 5, "\tOption \"%s\"\n", xf86optionName(opts));
	opts = xf86nextOption(opts);
d409 2
a410 2
pointer
xf86FindOption(pointer options, const char *name)
d415 2
a416 3

char *
xf86FindOptionValue(pointer options, const char *name)
a420 1

d422 1
a422 1
xf86MarkOptionUsed(pointer option)
d425 1
a425 1
	((XF86OptionPtr)option)->opt_used = TRUE;
a427 1

d429 1
a429 1
xf86MarkOptionUsedByName(pointer options, const char *name)
d435 1
a435 1
	opt->opt_used = TRUE;
d439 1
a439 1
xf86CheckIfOptionUsed(pointer option)
d442 1
a442 1
	return ((XF86OptionPtr)option)->opt_used;
d444 1
a444 1
	return FALSE;
d448 1
a448 1
xf86CheckIfOptionUsedByName(pointer options, const char *name)
d454 1
a454 1
	return opt->opt_used;
d456 1
a456 1
	return FALSE;
d460 1
a460 1
xf86ShowUnusedOptions(int scrnIndex, pointer options)
a461 2
    XF86OptionPtr opt = options;

d463 5
a467 5
	if (opt->opt_name && !opt->opt_used) {
	    xf86DrvMsg(scrnIndex, X_WARNING, "Option \"%s\" is not used\n",
			opt->opt_name);
	}
	opt = opt->list.next;
a470 1

d478 2
a479 2
ParseOptionValue(int scrnIndex, pointer options, OptionInfoPtr p,
		 Bool markUsed)
d485 215
a699 200
	if (markUsed) {
	    wasUsed = xf86CheckIfOptionUsedByName(options, p->name);
	    xf86MarkOptionUsedByName(options, p->name);
	}
	switch (p->type) {
	case OPTV_INTEGER:
	    if (*s == '\0') {
		if (markUsed) {
		    xf86DrvMsg(scrnIndex, X_WARNING,
			       "Option \"%s\" requires an integer value\n",
			       p->name);
		}
		p->found = FALSE;
	    } else {
		p->value.num = strtoul(s, &end, 0);
		if (*end == '\0') {
		    p->found = TRUE;
		} else {
		    if (markUsed) {
			xf86DrvMsg(scrnIndex, X_WARNING,
				   "Option \"%s\" requires an integer value\n",
				    p->name);
		    }
		    p->found = FALSE;
		}
	    }
	    break;
	case OPTV_STRING:
	    if (*s == '\0') {
		if (markUsed) {
		    xf86DrvMsg(scrnIndex, X_WARNING,
			       "Option \"%s\" requires an string value\n",
			       p->name);
		}
		p->found = FALSE;
	    } else {
		p->value.str = s;
		p->found = TRUE;
	    }
	    break;
	case OPTV_ANYSTR:
	    p->value.str = s;
	    p->found = TRUE;
	    break;
	case OPTV_REAL:	
	    if (*s == '\0') {
		if (markUsed) {
		    xf86DrvMsg(scrnIndex, X_WARNING,
			       "Option \"%s\" requires a floating point "
			       "value\n", p->name);
		}
		p->found = FALSE;
	    } else {
		p->value.realnum = strtod(s, &end);
		if (*end == '\0') {
		    p->found = TRUE;
		} else {
		    if (markUsed) {
			xf86DrvMsg(scrnIndex, X_WARNING,
				"Option \"%s\" requires a floating point "
				"value\n", p->name);
		    }
		    p->found = FALSE;
		}
	    }
	    break;
	case OPTV_BOOLEAN:
	    if (GetBoolValue(p, s)) {
		p->found = TRUE;
	    } else {
		if (markUsed) {
		    xf86DrvMsg(scrnIndex, X_WARNING,
			       "Option \"%s\" requires a boolean value\n",
			       p->name);
		}
		p->found = FALSE;
	    }
	    break;
	case OPTV_PERCENT:
	    {
		char tmp = 0;
		/* awkward match, but %% doesn't increase the match counter,
		 * hence 100 looks the same as 100% to the caller of sccanf
		 */
		if (sscanf(s, "%lf%c", &p->value.realnum, &tmp) != 2 || tmp != '%') {
		    if (markUsed) {
			xf86DrvMsg(scrnIndex, X_WARNING,
			       "Option \"%s\" requires a percent value\n", p->name);
		    }
		    p->found = FALSE;
		} else {
		    p->found = TRUE;
		}
	    }
	    break;
	case OPTV_FREQ:	
	    if (*s == '\0') {
		if (markUsed) {
		    xf86DrvMsg(scrnIndex, X_WARNING,
			       "Option \"%s\" requires a frequency value\n",
			       p->name);
		}
		p->found = FALSE;
	    } else {
		double freq = strtod(s, &end);
		int    units = 0;

		if (end != s) {
		    p->found = TRUE;
		    if (!xf86NameCmp(end, "Hz"))
			units = 1;
		    else if (!xf86NameCmp(end, "kHz") ||
			     !xf86NameCmp(end, "k"))
			units = 1000;
		    else if (!xf86NameCmp(end, "MHz") ||
			     !xf86NameCmp(end, "M"))
			units = 1000000;
		    else {
			if (markUsed) {
			    xf86DrvMsg(scrnIndex, X_WARNING,
				"Option \"%s\" requires a frequency value\n",
				p->name);
			}
			p->found = FALSE;
		    }
		    if (p->found)
			freq *= (double)units;
		} else {
		    if (markUsed) {
			xf86DrvMsg(scrnIndex, X_WARNING,
				"Option \"%s\" requires a frequency value\n",
				p->name);
		    }
		    p->found = FALSE;
		}
		if (p->found) {
		    p->value.freq.freq = freq;
		    p->value.freq.units = units;
		}
	    }
	    break;
	case OPTV_NONE:
	    /* Should never get here */
	    p->found = FALSE;
	    break;
	}
	if (p->found && markUsed) {
	    int verb = 2;
	    if (wasUsed)
		verb = 4;
	    xf86DrvMsgVerb(scrnIndex, X_CONFIG, verb, "Option \"%s\"", p->name);
	    if (!(p->type == OPTV_BOOLEAN && *s == 0)) {
		xf86ErrorFVerb(verb, " \"%s\"", s);
	    }
	    xf86ErrorFVerb(verb, "\n");
	}
    } else if (p->type == OPTV_BOOLEAN) {
	/* Look for matches with options with or without a "No" prefix. */
	char *n, *newn;
	OptionInfoRec opt;

	n = xf86NormalizeName(p->name);
	if (!n) {
	    p->found = FALSE;
	    return FALSE;
	}
	if (strncmp(n, "no", 2) == 0) {
	    newn = n + 2;
	} else {
	    free(n);
	    if (asprintf(&n, "No%s", p->name) == -1) {
		p->found = FALSE;
		return FALSE;
	    }
	    newn = n;
	}
	if ((s = xf86findOptionValue(options, newn)) != NULL) {
	    if (markUsed)
		xf86MarkOptionUsedByName(options, newn);
	    if (GetBoolValue(&opt, s)) {
		p->value.bool = !opt.value.bool;
		p->found = TRUE;
	    } else {
		xf86DrvMsg(scrnIndex, X_WARNING,
			   "Option \"%s\" requires a boolean value\n", newn);
		p->found = FALSE;
	    }
	} else {
	    p->found = FALSE;
	}
	if (p->found && markUsed) {
	    xf86DrvMsgVerb(scrnIndex, X_CONFIG, 2, "Option \"%s\"", newn);
	    if (*s != 0) {
		xf86ErrorFVerb(2, " \"%s\"", s);
	    }
	    xf86ErrorFVerb(2, "\n");
	}
	free(n);
    } else {
	p->found = FALSE;
a703 1

d705 1
a705 1
xf86ProcessOptions(int scrnIndex, pointer options, OptionInfoPtr optinfo)
d710 1
a710 1
	ParseOptionValue(scrnIndex, options, p, TRUE);
a713 1

d715 1
a715 1
xf86TokenToOptinfo(const OptionInfoRec *table, int token)
d720 2
a721 2
	ErrorF("xf86TokenToOptinfo: table is NULL\n");
	return NULL;
d725 5
a729 5
	if (p->token == token) {
	    match = p;
	    if (p->found)
		set = p;
	}
d733 1
a733 1
	return (OptionInfoPtr)set;
d735 1
a735 1
	return (OptionInfoPtr)match;
d737 1
a737 1
	return NULL;
a739 1

d741 1
a741 1
xf86TokenToOptName(const OptionInfoRec *table, int token)
a748 1

d750 1
a750 1
xf86IsOptionSet(const OptionInfoRec *table, int token)
a757 1

d759 1
a759 1
xf86GetOptValString(const OptionInfoRec *table, int token)
d765 1
a765 1
	return p->value.str;
d767 1
a767 1
	return NULL;
a769 1

d771 1
a771 1
xf86GetOptValInteger(const OptionInfoRec *table, int token, int *value)
d777 5
a781 4
	*value = p->value.num;
	return TRUE;
    } else
	return FALSE;
a783 1

d785 1
a785 1
xf86GetOptValULong(const OptionInfoRec *table, int token, unsigned long *value)
d791 5
a795 4
	*value = p->value.num;
	return TRUE;
    } else
	return FALSE;
a797 1

d799 1
a799 1
xf86GetOptValReal(const OptionInfoRec *table, int token, double *value)
d805 5
a809 4
	*value = p->value.realnum;
	return TRUE;
    } else
	return FALSE;
a811 1

d813 2
a814 2
xf86GetOptValFreq(const OptionInfoRec *table, int token,
		  OptFreqUnits expectedUnits, double *value)
d820 39
a858 37
	if (p->value.freq.units > 0) {
	    /* Units give, so the scaling is known. */
	    switch (expectedUnits) {
	    case OPTUNITS_HZ:
		*value = p->value.freq.freq;
		break;
	    case OPTUNITS_KHZ:
		*value = p->value.freq.freq / 1000.0;
		break;
	    case OPTUNITS_MHZ:
		*value = p->value.freq.freq / 1000000.0;
		break;
	    }
	} else {
	    /* No units given, so try to guess the scaling. */
	    switch (expectedUnits) {
	    case OPTUNITS_HZ:
		*value = p->value.freq.freq;
		break;
	    case OPTUNITS_KHZ:
		if (p->value.freq.freq > 1000.0)
		    *value = p->value.freq.freq / 1000.0;
		else
		    *value = p->value.freq.freq;
		break;
	    case OPTUNITS_MHZ:
		if (p->value.freq.freq > 1000000.0)
		    *value = p->value.freq.freq / 1000000.0;
		else if (p->value.freq.freq > 1000.0)
		    *value = p->value.freq.freq / 1000.0;
		else
		    *value = p->value.freq.freq;
	    }
	}
	return TRUE;
    } else
	return FALSE;
a860 1

d862 1
a862 1
xf86GetOptValBool(const OptionInfoRec *table, int token, Bool *value)
d868 5
a872 4
	*value = p->value.bool;
	return TRUE;
    } else
	return FALSE;
a874 1

d876 1
a876 1
xf86ReturnOptValBool(const OptionInfoRec *table, int token, Bool def)
d882 4
a885 3
	return p->value.bool;
    } else
	return def;
a887 1

d901 1
a901 1
	return NULL;
d905 11
a915 11
	switch (*p) {
	case '_':
	case ' ':
	case '\t':
	    continue;
	default:
	    if (isupper(*p))
		*q++ = tolower(*p);
	    else
		*q++ = *p;
	}
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d121 4
a124 12
 * xf86CollectInputOptions collects the options for an InputDevice.
 * This function requires that the following has been initialised:
 *
 *	pInfo->conf_idev
 *
 * The extraOpts parameter may optionally contain a list of additional options
 * to include.
 *
 * The order of precedence for options is:
 *
 *   extraOpts, pInfo->conf_idev->extraOptions,
 *   pInfo->conf_idev->commonOptions, defaultOpts
d128 1
a128 2
xf86CollectInputOptions(InputInfoPtr pInfo, const char **defaultOpts,
			pointer extraOpts)
a129 4
    XF86OptionPtr tmp;
    XF86OptionPtr extras = (XF86OptionPtr)extraOpts;

    pInfo->options = NULL;
d131 1
a131 4
	pInfo->options = xf86OptionListCreate(defaultOpts, -1, 0);
    }
    if (pInfo->conf_idev && pInfo->conf_idev->commonOptions) {
	tmp = xf86optionListDup(pInfo->conf_idev->commonOptions);
d133 1
a133 1
	    pInfo->options = xf86optionListMerge(pInfo->options, tmp);
d137 15
a151 13
    if (pInfo->conf_idev && pInfo->conf_idev->extraOptions) {
	tmp = xf86optionListDup(pInfo->conf_idev->extraOptions);
	if (pInfo->options)
	    pInfo->options = xf86optionListMerge(pInfo->options, tmp);
	else
	    pInfo->options = tmp;
    }
    if (extras) {
	tmp = xf86optionListDup(extras);
	if (pInfo->options)
	    pInfo->options = xf86optionListMerge(pInfo->options, tmp);
	else
	    pInfo->options = tmp;
d154 1
a154 3
    if (pInfo->conf_idev && pInfo->conf_idev->attrs) {
        pInfo->attrs = pInfo->conf_idev->attrs;
    }
d157 1
d215 1
a215 1
static int
d343 1
a343 1
    char *tmp = strdup(val);
d499 5
a503 3
		xf86DrvMsg(scrnIndex, X_WARNING,
			   "Option \"%s\" requires an integer value\n",
			   p->name);
d510 5
a514 3
		    xf86DrvMsg(scrnIndex, X_WARNING,
			       "Option \"%s\" requires an integer value\n",
			        p->name);
d521 5
a525 3
		xf86DrvMsg(scrnIndex, X_WARNING,
			   "Option \"%s\" requires an string value\n",
			   p->name);
d538 5
a542 3
		xf86DrvMsg(scrnIndex, X_WARNING,
			   "Option \"%s\" requires a floating point value\n",
			   p->name);
d549 5
a553 3
		    xf86DrvMsg(scrnIndex, X_WARNING,
			    "Option \"%s\" requires a floating point value\n",
			    p->name);
d562 5
a566 2
		xf86DrvMsg(scrnIndex, X_WARNING,
			   "Option \"%s\" requires a boolean value\n", p->name);
d577 2
a578 1
		    xf86DrvMsg(scrnIndex, X_WARNING,
d580 1
d589 5
a593 3
		xf86DrvMsg(scrnIndex, X_WARNING,
			   "Option \"%s\" requires a frequency value\n",
			   p->name);
d610 5
a614 3
			xf86DrvMsg(scrnIndex, X_WARNING,
			    "Option \"%s\" requires a frequency value\n",
			    p->name);
d620 5
a624 3
		    xf86DrvMsg(scrnIndex, X_WARNING,
			    "Option \"%s\" requires a frequency value\n",
			    p->name);
d662 1
a662 2
	    n = malloc(strlen(p->name) + 2 + 1);
	    if (!n) {
a665 2
	    strcpy(n, "No");
	    strcat(n, p->name);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d167 4
d212 1
a212 1
	return xstrdup(deflt);
d230 12
d271 6
d308 6
d341 8
d572 15
d655 2
a656 2
	    xfree(n);
	    n = xalloc(strlen(p->name) + 2 + 1);
d686 1
a686 1
	xfree(n);
d748 1
a748 1
    return (p && p->found);
d897 1
a897 1
    ret = xalloc(strlen(s) + 1);
@


1.1
log
@Initial revision
@
text
@d45 1
d68 1
a68 1
_X_EXPORT void
d135 1
a135 1
_X_EXPORT void
d146 1
a146 1
    if (pInfo->conf_idev->commonOptions) {
d153 1
a153 1
    if (pInfo->conf_idev->extraOptions) {
d228 1
a228 1
_X_EXPORT int
d235 1
a235 1
_X_EXPORT double
d242 1
a242 1
_X_EXPORT char *
d249 1
a249 1
_X_EXPORT int
d259 1
a259 1
_X_EXPORT int
d266 1
a266 1
_X_EXPORT double
d273 1
a273 1
_X_EXPORT char *
d280 1
a280 1
_X_EXPORT int
d290 1
a290 1
_X_EXPORT pointer
d293 1
a293 1
    char *tmp = xnfalloc(16);
d298 1
a298 1
_X_EXPORT pointer
d301 1
a301 1
    char *tmp = xnfalloc(32);
d306 1
a306 1
_X_EXPORT pointer
d312 1
a312 1
_X_EXPORT pointer
d318 1
a318 1
_X_EXPORT pointer
d329 1
a329 1
_X_EXPORT pointer
d336 1
a336 1
_X_EXPORT pointer
d342 1
a342 1
_X_EXPORT pointer
d348 1
a348 1
_X_EXPORT pointer
d354 1
a354 1
_X_EXPORT void
d360 1
a360 1
_X_EXPORT char *
d366 1
a366 1
_X_EXPORT char *
d372 1
a372 1
_X_EXPORT void
d389 1
a389 1
_X_EXPORT pointer
d396 1
a396 1
_X_EXPORT char *
d403 1
a403 1
_X_EXPORT void
d411 1
a411 1
_X_EXPORT void
d421 1
a421 1
_X_EXPORT Bool
d430 1
a430 1
_X_EXPORT Bool
d442 1
a442 1
_X_EXPORT void
d460 1
a460 23
    if (*s == '\0') {
	p->value.bool = TRUE;
    } else {
	if (xf86NameCmp(s, "1") == 0)
	    p->value.bool = TRUE;
	else if (xf86NameCmp(s, "on") == 0)
	    p->value.bool = TRUE;
	else if (xf86NameCmp(s, "true") == 0)
	    p->value.bool = TRUE;
	else if (xf86NameCmp(s, "yes") == 0)
	    p->value.bool = TRUE;
	else if (xf86NameCmp(s, "0") == 0)
	    p->value.bool = FALSE;
	else if (xf86NameCmp(s, "off") == 0)
	    p->value.bool = FALSE;
	else if (xf86NameCmp(s, "false") == 0)
	    p->value.bool = FALSE;
	else if (xf86NameCmp(s, "no") == 0)
	    p->value.bool = FALSE;
	else
	    return FALSE;
    }
    return TRUE;
d643 1
a643 1
_X_EXPORT void
d654 1
a654 1
_X_EXPORT OptionInfoPtr
d681 1
a681 1
_X_EXPORT const char *
d691 1
a691 1
_X_EXPORT Bool
d701 1
a701 1
_X_EXPORT char *
d714 1
a714 1
_X_EXPORT Bool
d728 1
a728 1
_X_EXPORT Bool
d742 1
a742 1
_X_EXPORT Bool
d756 1
a756 1
_X_EXPORT Bool
d804 1
a804 1
_X_EXPORT Bool
d818 1
a818 1
_X_EXPORT Bool
d831 1
a831 1
_X_EXPORT int
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d145 1
a145 1
    if (pInfo->conf_idev && pInfo->conf_idev->commonOptions) {
d152 1
a152 1
    if (pInfo->conf_idev && pInfo->conf_idev->extraOptions) {
d292 1
a292 1
    char tmp[16];
d300 1
a300 1
    char tmp[32];
@

