head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.6
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.14;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.14;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.50;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

/*
 * LCM() and scanLineWidth() are:
 *
 * Copyright 1997 through 2004 by Marc Aurele La France (TSI @@ UQV), tsi@@xfree86.org
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of Marc Aurele La France not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  Marc Aurele La France makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as-is" without express or implied warranty.
 *
 * MARC AURELE LA FRANCE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO
 * EVENT SHALL MARC AURELE LA FRANCE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Copyright 1990,91,92,93 by Thomas Roell, Germany.
 * Copyright 1991,92,93    by SGCS (Snitily Graphics Consulting Services), USA.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this  permission notice appear
 * in supporting documentation, and that the name of Thomas Roell nor
 * SGCS be used in advertising or publicity pertaining to distribution
 * of the software without specific, written prior permission.
 * Thomas Roell nor SGCS makes no representations about the suitability
 * of this software for any purpose. It is provided "as is" without
 * express or implied warranty.
 *
 * THOMAS ROELL AND SGCS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
 * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS, IN NO EVENT SHALL THOMAS ROELL OR SGCS BE LIABLE FOR ANY
 * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
 * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Authors: Dirk Hohndel <hohndel@@XFree86.Org>
 *          David Dawes <dawes@@XFree86.Org>
 *          Marc La France <tsi@@XFree86.Org>
 *          ... and others
 *
 * This file includes helper functions for mode related things.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include "xf86Modes.h"
#include "os.h"
#include "servermd.h"
#include "globals.h"
#include "xf86.h"
#include "xf86Priv.h"
#include "edid.h"

static void
printModeRejectMessage(int index, DisplayModePtr p, int status)
{
    const char *type;

    if (p->type & M_T_BUILTIN)
        type = "built-in ";
    else if (p->type & M_T_DEFAULT)
        type = "default ";
    else if (p->type & M_T_DRIVER)
        type = "driver ";
    else
        type = "";

    xf86DrvMsg(index, X_INFO, "Not using %smode \"%s\" (%s)\n", type, p->name,
               xf86ModeStatusToString(status));
}

/*
 * Find closest clock to given frequency (in kHz).  This assumes the
 * number of clocks is greater than zero.
 */
static int
xf86GetNearestClock(ScrnInfoPtr scrp, int freq, Bool allowDiv2,
                    int DivFactor, int MulFactor, int *divider)
{
    int nearestClock = 0, nearestDiv = 1;
    int minimumGap = abs(freq - scrp->clock[0]);
    int i, j, k, gap;

    if (allowDiv2)
        k = 2;
    else
        k = 1;

    /* Must set this here in case the best match is scrp->clock[0] */
    if (divider != NULL)
        *divider = 0;

    for (i = 0; i < scrp->numClocks; i++) {
        for (j = 1; j <= k; j++) {
            gap = abs((freq * j) - ((scrp->clock[i] * DivFactor) / MulFactor));
            if ((gap < minimumGap) || ((gap == minimumGap) && (j < nearestDiv))) {
                minimumGap = gap;
                nearestClock = i;
                nearestDiv = j;
                if (divider != NULL)
                    *divider = (j - 1) * V_CLKDIV2;
            }
        }
    }
    return nearestClock;
}

/*
 * xf86ModeStatusToString
 *
 * Convert a ModeStatus value to a printable message
 */

const char *
xf86ModeStatusToString(ModeStatus status)
{
    switch (status) {
    case MODE_OK:
        return "Mode OK";
    case MODE_HSYNC:
        return "hsync out of range";
    case MODE_VSYNC:
        return "vrefresh out of range";
    case MODE_H_ILLEGAL:
        return "illegal horizontal timings";
    case MODE_V_ILLEGAL:
        return "illegal vertical timings";
    case MODE_BAD_WIDTH:
        return "width requires unsupported line pitch";
    case MODE_NOMODE:
        return "no mode of this name";
    case MODE_NO_INTERLACE:
        return "interlace mode not supported";
    case MODE_NO_DBLESCAN:
        return "doublescan mode not supported";
    case MODE_NO_VSCAN:
        return "multiscan mode not supported";
    case MODE_MEM:
        return "insufficient memory for mode";
    case MODE_VIRTUAL_X:
        return "width too large for virtual size";
    case MODE_VIRTUAL_Y:
        return "height too large for virtual size";
    case MODE_MEM_VIRT:
        return "insufficient memory given virtual size";
    case MODE_NOCLOCK:
        return "no clock available for mode";
    case MODE_CLOCK_HIGH:
        return "mode clock too high";
    case MODE_CLOCK_LOW:
        return "mode clock too low";
    case MODE_CLOCK_RANGE:
        return "bad mode clock/interlace/doublescan";
    case MODE_BAD_HVALUE:
        return "horizontal timing out of range";
    case MODE_BAD_VVALUE:
        return "vertical timing out of range";
    case MODE_BAD_VSCAN:
        return "VScan value out of range";
    case MODE_HSYNC_NARROW:
        return "horizontal sync too narrow";
    case MODE_HSYNC_WIDE:
        return "horizontal sync too wide";
    case MODE_HBLANK_NARROW:
        return "horizontal blanking too narrow";
    case MODE_HBLANK_WIDE:
        return "horizontal blanking too wide";
    case MODE_VSYNC_NARROW:
        return "vertical sync too narrow";
    case MODE_VSYNC_WIDE:
        return "vertical sync too wide";
    case MODE_VBLANK_NARROW:
        return "vertical blanking too narrow";
    case MODE_VBLANK_WIDE:
        return "vertical blanking too wide";
    case MODE_PANEL:
        return "exceeds panel dimensions";
    case MODE_INTERLACE_WIDTH:
        return "width too large for interlaced mode";
    case MODE_ONE_WIDTH:
        return "all modes must have the same width";
    case MODE_ONE_HEIGHT:
        return "all modes must have the same height";
    case MODE_ONE_SIZE:
        return "all modes must have the same resolution";
    case MODE_NO_REDUCED:
        return "monitor doesn't support reduced blanking";
    case MODE_BANDWIDTH:
        return "mode requires too much memory bandwidth";
    case MODE_BAD:
        return "unknown reason";
    case MODE_ERROR:
        return "internal error";
    default:
        return "unknown";
    }
}

/*
 * xf86ShowClockRanges() -- Print the clock ranges allowed
 * and the clock values scaled by ClockMulFactor and ClockDivFactor
 */
void
xf86ShowClockRanges(ScrnInfoPtr scrp, ClockRangePtr clockRanges)
{
    ClockRangePtr cp;
    int MulFactor = 1;
    int DivFactor = 1;
    int i, j;
    int scaledClock;

    for (cp = clockRanges; cp != NULL; cp = cp->next) {
        DivFactor = max(1, cp->ClockDivFactor);
        MulFactor = max(1, cp->ClockMulFactor);
        if (scrp->progClock) {
            if (cp->minClock) {
                if (cp->maxClock) {
                    xf86DrvMsg(scrp->scrnIndex, X_INFO,
                               "Clock range: %6.2f to %6.2f MHz\n",
                               (double) cp->minClock / 1000.0,
                               (double) cp->maxClock / 1000.0);
                }
                else {
                    xf86DrvMsg(scrp->scrnIndex, X_INFO,
                               "Minimum clock: %6.2f MHz\n",
                               (double) cp->minClock / 1000.0);
                }
            }
            else {
                if (cp->maxClock) {
                    xf86DrvMsg(scrp->scrnIndex, X_INFO,
                               "Maximum clock: %6.2f MHz\n",
                               (double) cp->maxClock / 1000.0);
                }
            }
        }
        else if (DivFactor > 1 || MulFactor > 1) {
            j = 0;
            for (i = 0; i < scrp->numClocks; i++) {
                scaledClock = (scrp->clock[i] * DivFactor) / MulFactor;
                if (scaledClock >= cp->minClock && scaledClock <= cp->maxClock) {
                    if ((j % 8) == 0) {
                        if (j > 0)
                            xf86ErrorF("\n");
                        xf86DrvMsg(scrp->scrnIndex, X_INFO, "scaled clocks:");
                    }
                    xf86ErrorF(" %6.2f", (double) scaledClock / 1000.0);
                    j++;
                }
            }
            xf86ErrorF("\n");
        }
    }
}

static Bool
modeInClockRange(ClockRangePtr cp, DisplayModePtr p)
{
    return ((p->Clock >= cp->minClock) &&
            (p->Clock <= cp->maxClock) &&
            (cp->interlaceAllowed || !(p->Flags & V_INTERLACE)) &&
            (cp->doubleScanAllowed ||
             ((p->VScan <= 1) && !(p->Flags & V_DBLSCAN))));
}

/*
 * xf86FindClockRangeForMode()    [... like the name says ...]
 */
static ClockRangePtr
xf86FindClockRangeForMode(ClockRangePtr clockRanges, DisplayModePtr p)
{
    ClockRangePtr cp;

    for (cp = clockRanges;; cp = cp->next)
        if (!cp || modeInClockRange(cp, p))
            return cp;
}

/*
 * xf86HandleBuiltinMode() - handles built-in modes
 */
static ModeStatus
xf86HandleBuiltinMode(ScrnInfoPtr scrp,
                      DisplayModePtr p,
                      DisplayModePtr modep,
                      ClockRangePtr clockRanges, Bool allowDiv2)
{
    ClockRangePtr cp;
    int extraFlags = 0;
    int MulFactor = 1;
    int DivFactor = 1;
    int clockIndex;

    /* Reject previously rejected modes */
    if (p->status != MODE_OK)
        return p->status;

    /* Reject previously considered modes */
    if (p->prev)
        return MODE_NOMODE;

    if ((p->type & M_T_CLOCK_C) == M_T_CLOCK_C) {
        /* Check clock is in range */
        cp = xf86FindClockRangeForMode(clockRanges, p);
        if (cp == NULL) {
            modep->type = p->type;
            p->status = MODE_CLOCK_RANGE;
            return MODE_CLOCK_RANGE;
        }
        DivFactor = cp->ClockDivFactor;
        MulFactor = cp->ClockMulFactor;
        if (!scrp->progClock) {
            clockIndex = xf86GetNearestClock(scrp, p->Clock, allowDiv2,
                                             cp->ClockDivFactor,
                                             cp->ClockMulFactor, &extraFlags);
            modep->Clock = (scrp->clock[clockIndex] * DivFactor)
                / MulFactor;
            modep->ClockIndex = clockIndex;
            modep->SynthClock = scrp->clock[clockIndex];
            if (extraFlags & V_CLKDIV2) {
                modep->Clock /= 2;
                modep->SynthClock /= 2;
            }
        }
        else {
            modep->Clock = p->Clock;
            modep->ClockIndex = -1;
            modep->SynthClock = (modep->Clock * MulFactor)
                / DivFactor;
        }
        modep->PrivFlags = cp->PrivFlags;
    }
    else {
        if (!scrp->progClock) {
            modep->Clock = p->Clock;
            modep->ClockIndex = p->ClockIndex;
            modep->SynthClock = p->SynthClock;
        }
        else {
            modep->Clock = p->Clock;
            modep->ClockIndex = -1;
            modep->SynthClock = p->SynthClock;
        }
        modep->PrivFlags = p->PrivFlags;
    }
    modep->type = p->type;
    modep->HDisplay = p->HDisplay;
    modep->HSyncStart = p->HSyncStart;
    modep->HSyncEnd = p->HSyncEnd;
    modep->HTotal = p->HTotal;
    modep->HSkew = p->HSkew;
    modep->VDisplay = p->VDisplay;
    modep->VSyncStart = p->VSyncStart;
    modep->VSyncEnd = p->VSyncEnd;
    modep->VTotal = p->VTotal;
    modep->VScan = p->VScan;
    modep->Flags = p->Flags | extraFlags;
    modep->CrtcHDisplay = p->CrtcHDisplay;
    modep->CrtcHBlankStart = p->CrtcHBlankStart;
    modep->CrtcHSyncStart = p->CrtcHSyncStart;
    modep->CrtcHSyncEnd = p->CrtcHSyncEnd;
    modep->CrtcHBlankEnd = p->CrtcHBlankEnd;
    modep->CrtcHTotal = p->CrtcHTotal;
    modep->CrtcHSkew = p->CrtcHSkew;
    modep->CrtcVDisplay = p->CrtcVDisplay;
    modep->CrtcVBlankStart = p->CrtcVBlankStart;
    modep->CrtcVSyncStart = p->CrtcVSyncStart;
    modep->CrtcVSyncEnd = p->CrtcVSyncEnd;
    modep->CrtcVBlankEnd = p->CrtcVBlankEnd;
    modep->CrtcVTotal = p->CrtcVTotal;
    modep->CrtcHAdjusted = p->CrtcHAdjusted;
    modep->CrtcVAdjusted = p->CrtcVAdjusted;
    modep->HSync = p->HSync;
    modep->VRefresh = p->VRefresh;
    modep->Private = p->Private;
    modep->PrivSize = p->PrivSize;

    p->prev = modep;

    return MODE_OK;
}

/*
 * xf86LookupMode
 *
 * This function returns a mode from the given list which matches the
 * given name.  When multiple modes with the same name are available,
 * the method of picking the matching mode is determined by the
 * strategy selected.
 *
 * This function takes the following parameters:
 *    scrp         ScrnInfoPtr
 *    modep        pointer to the returned mode, which must have the name
 *                 field filled in.
 *    clockRanges  a list of clock ranges.   This is optional when all the
 *                 modes are built-in modes.
 *    strategy     how to decide which mode to use from multiple modes with
 *                 the same name
 *
 * In addition, the following fields from the ScrnInfoRec are used:
 *    modePool     the list of monitor modes compatible with the driver
 *    clocks       a list of discrete clocks
 *    numClocks    number of discrete clocks
 *    progClock    clock is programmable
 *
 * If a mode was found, its values are filled in to the area pointed to
 * by modep,  If a mode was not found the return value indicates the
 * reason.
 */

static ModeStatus
xf86LookupMode(ScrnInfoPtr scrp, DisplayModePtr modep,
               ClockRangePtr clockRanges, LookupModeFlags strategy)
{
    DisplayModePtr p, bestMode = NULL;
    ClockRangePtr cp;
    int i, k, gap, minimumGap = CLOCK_TOLERANCE + 1;
    double refresh, bestRefresh = 0.0;
    Bool found = FALSE;
    int extraFlags = 0;
    int clockIndex = -1;
    int MulFactor = 1;
    int DivFactor = 1;
    int ModePrivFlags = 0;
    ModeStatus status = MODE_NOMODE;
    Bool allowDiv2 = (strategy & LOOKUP_CLKDIV2) != 0;
    int n;

    const int types[] = {
        M_T_BUILTIN | M_T_PREFERRED,
        M_T_BUILTIN,
        M_T_USERDEF | M_T_PREFERRED,
        M_T_USERDEF,
        M_T_DRIVER | M_T_PREFERRED,
        M_T_DRIVER,
        0
    };
    const int ntypes = sizeof(types) / sizeof(int);

    strategy &= ~(LOOKUP_CLKDIV2 | LOOKUP_OPTIONAL_TOLERANCES);

    /* Some sanity checking */
    if (scrp == NULL || scrp->modePool == NULL ||
        (!scrp->progClock && scrp->numClocks == 0)) {
        ErrorF("xf86LookupMode: called with invalid scrnInfoRec\n");
        return MODE_ERROR;
    }
    if (modep == NULL || modep->name == NULL) {
        ErrorF("xf86LookupMode: called with invalid modep\n");
        return MODE_ERROR;
    }
    for (cp = clockRanges; cp != NULL; cp = cp->next) {
        /* DivFactor and MulFactor must be > 0 */
        cp->ClockDivFactor = max(1, cp->ClockDivFactor);
        cp->ClockMulFactor = max(1, cp->ClockMulFactor);
    }

    /* Scan the mode pool for matching names */
    for (n = 0; n < ntypes; n++) {
        int type = types[n];

        for (p = scrp->modePool; p != NULL; p = p->next) {

            /* scan through the modes in the sort order above */
            if ((p->type & type) != type)
                continue;

            if (strcmp(p->name, modep->name) == 0) {

                /* Skip over previously rejected modes */
                if (p->status != MODE_OK) {
                    if (!found)
                        status = p->status;
                    continue;
                }

                /* Skip over previously considered modes */
                if (p->prev)
                    continue;

                if (p->type & M_T_BUILTIN) {
                    return xf86HandleBuiltinMode(scrp, p, modep, clockRanges,
                                                 allowDiv2);
                }

                /* Check clock is in range */
                cp = xf86FindClockRangeForMode(clockRanges, p);
                if (cp == NULL) {
                    /*
                     * XXX Could do more here to provide a more detailed
                     * reason for not finding a mode.
                     */
                    p->status = MODE_CLOCK_RANGE;
                    if (!found)
                        status = MODE_CLOCK_RANGE;
                    continue;
                }

                /*
                 * If programmable clock and strategy is not
                 * LOOKUP_BEST_REFRESH, the required mode has been found,
                 * otherwise record the refresh and continue looking.
                 */
                if (scrp->progClock) {
                    found = TRUE;
                    if (strategy != LOOKUP_BEST_REFRESH) {
                        bestMode = p;
                        DivFactor = cp->ClockDivFactor;
                        MulFactor = cp->ClockMulFactor;
                        ModePrivFlags = cp->PrivFlags;
                        break;
                    }
                    refresh = xf86ModeVRefresh(p);
                    if (p->Flags & V_INTERLACE)
                        refresh /= INTERLACE_REFRESH_WEIGHT;
                    if (refresh > bestRefresh) {
                        bestMode = p;
                        DivFactor = cp->ClockDivFactor;
                        MulFactor = cp->ClockMulFactor;
                        ModePrivFlags = cp->PrivFlags;
                        bestRefresh = refresh;
                    }
                    continue;
                }

                /*
                 * Clock is in range, so if it is not a programmable clock, find
                 * a matching clock.
                 */

                i = xf86GetNearestClock(scrp, p->Clock, allowDiv2,
                                        cp->ClockDivFactor, cp->ClockMulFactor,
                                        &k);
                /*
                 * If the clock is too far from the requested clock, this
                 * mode is no good.
                 */
                if (k & V_CLKDIV2)
                    gap = abs((p->Clock * 2) -
                              ((scrp->clock[i] * cp->ClockDivFactor) /
                               cp->ClockMulFactor));
                else
                    gap = abs(p->Clock -
                              ((scrp->clock[i] * cp->ClockDivFactor) /
                               cp->ClockMulFactor));
                if (gap > minimumGap) {
                    p->status = MODE_NOCLOCK;
                    if (!found)
                        status = MODE_NOCLOCK;
                    continue;
                }
                found = TRUE;

                if (strategy == LOOKUP_BEST_REFRESH) {
                    refresh = xf86ModeVRefresh(p);
                    if (p->Flags & V_INTERLACE)
                        refresh /= INTERLACE_REFRESH_WEIGHT;
                    if (refresh > bestRefresh) {
                        bestMode = p;
                        DivFactor = cp->ClockDivFactor;
                        MulFactor = cp->ClockMulFactor;
                        ModePrivFlags = cp->PrivFlags;
                        extraFlags = k;
                        clockIndex = i;
                        bestRefresh = refresh;
                    }
                    continue;
                }
                if (strategy == LOOKUP_CLOSEST_CLOCK) {
                    if (gap < minimumGap) {
                        bestMode = p;
                        DivFactor = cp->ClockDivFactor;
                        MulFactor = cp->ClockMulFactor;
                        ModePrivFlags = cp->PrivFlags;
                        extraFlags = k;
                        clockIndex = i;
                        minimumGap = gap;
                    }
                    continue;
                }
                /*
                 * If strategy is neither LOOKUP_BEST_REFRESH or
                 * LOOKUP_CLOSEST_CLOCK the required mode has been found.
                 */
                bestMode = p;
                DivFactor = cp->ClockDivFactor;
                MulFactor = cp->ClockMulFactor;
                ModePrivFlags = cp->PrivFlags;
                extraFlags = k;
                clockIndex = i;
                break;
            }
        }
        if (found)
            break;
    }
    if (!found || bestMode == NULL)
        return status;

    /* Fill in the mode parameters */
    if (scrp->progClock) {
        modep->Clock = bestMode->Clock;
        modep->ClockIndex = -1;
        modep->SynthClock = (modep->Clock * MulFactor) / DivFactor;
    }
    else {
        modep->Clock = (scrp->clock[clockIndex] * DivFactor) / MulFactor;
        modep->ClockIndex = clockIndex;
        modep->SynthClock = scrp->clock[clockIndex];
        if (extraFlags & V_CLKDIV2) {
            modep->Clock /= 2;
            modep->SynthClock /= 2;
        }
    }
    modep->type = bestMode->type;
    modep->PrivFlags = ModePrivFlags;
    modep->HDisplay = bestMode->HDisplay;
    modep->HSyncStart = bestMode->HSyncStart;
    modep->HSyncEnd = bestMode->HSyncEnd;
    modep->HTotal = bestMode->HTotal;
    modep->HSkew = bestMode->HSkew;
    modep->VDisplay = bestMode->VDisplay;
    modep->VSyncStart = bestMode->VSyncStart;
    modep->VSyncEnd = bestMode->VSyncEnd;
    modep->VTotal = bestMode->VTotal;
    modep->VScan = bestMode->VScan;
    modep->Flags = bestMode->Flags | extraFlags;
    modep->CrtcHDisplay = bestMode->CrtcHDisplay;
    modep->CrtcHBlankStart = bestMode->CrtcHBlankStart;
    modep->CrtcHSyncStart = bestMode->CrtcHSyncStart;
    modep->CrtcHSyncEnd = bestMode->CrtcHSyncEnd;
    modep->CrtcHBlankEnd = bestMode->CrtcHBlankEnd;
    modep->CrtcHTotal = bestMode->CrtcHTotal;
    modep->CrtcHSkew = bestMode->CrtcHSkew;
    modep->CrtcVDisplay = bestMode->CrtcVDisplay;
    modep->CrtcVBlankStart = bestMode->CrtcVBlankStart;
    modep->CrtcVSyncStart = bestMode->CrtcVSyncStart;
    modep->CrtcVSyncEnd = bestMode->CrtcVSyncEnd;
    modep->CrtcVBlankEnd = bestMode->CrtcVBlankEnd;
    modep->CrtcVTotal = bestMode->CrtcVTotal;
    modep->CrtcHAdjusted = bestMode->CrtcHAdjusted;
    modep->CrtcVAdjusted = bestMode->CrtcVAdjusted;
    modep->HSync = bestMode->HSync;
    modep->VRefresh = bestMode->VRefresh;
    modep->Private = bestMode->Private;
    modep->PrivSize = bestMode->PrivSize;

    bestMode->prev = modep;

    return MODE_OK;
}

/*
 * xf86CheckModeForMonitor
 *
 * This function takes a mode and monitor description, and determines
 * if the mode is valid for the monitor.
 */
ModeStatus
xf86CheckModeForMonitor(DisplayModePtr mode, MonPtr monitor)
{
    int i;

    /* Sanity checks */
    if (mode == NULL || monitor == NULL) {
        ErrorF("xf86CheckModeForMonitor: called with invalid parameters\n");
        return MODE_ERROR;
    }

    DebugF("xf86CheckModeForMonitor(%p %s, %p %s)\n",
           mode, mode->name, monitor, monitor->id);

    /* Some basic mode validity checks */
    if (0 >= mode->HDisplay || mode->HDisplay > mode->HSyncStart ||
        mode->HSyncStart >= mode->HSyncEnd || mode->HSyncEnd >= mode->HTotal)
        return MODE_H_ILLEGAL;

    if (0 >= mode->VDisplay || mode->VDisplay > mode->VSyncStart ||
        mode->VSyncStart >= mode->VSyncEnd || mode->VSyncEnd >= mode->VTotal)
        return MODE_V_ILLEGAL;

    if (monitor->nHsync > 0) {
        /* Check hsync against the allowed ranges */
        float hsync = xf86ModeHSync(mode);

        for (i = 0; i < monitor->nHsync; i++)
            if ((hsync > monitor->hsync[i].lo * (1.0 - SYNC_TOLERANCE)) &&
                (hsync < monitor->hsync[i].hi * (1.0 + SYNC_TOLERANCE)))
                break;

        /* Now see whether we ran out of sync ranges without finding a match */
        if (i == monitor->nHsync)
            return MODE_HSYNC;
    }

    if (monitor->nVrefresh > 0) {
        /* Check vrefresh against the allowed ranges */
        float vrefrsh = xf86ModeVRefresh(mode);

        for (i = 0; i < monitor->nVrefresh; i++)
            if ((vrefrsh > monitor->vrefresh[i].lo * (1.0 - SYNC_TOLERANCE)) &&
                (vrefrsh < monitor->vrefresh[i].hi * (1.0 + SYNC_TOLERANCE)))
                break;

        /* Now see whether we ran out of refresh ranges without finding a match */
        if (i == monitor->nVrefresh)
            return MODE_VSYNC;
    }

    /* Force interlaced modes to have an odd VTotal */
    if (mode->Flags & V_INTERLACE)
        mode->CrtcVTotal = mode->VTotal |= 1;

    /*
     * This code stops cvt -r modes, and only cvt -r modes, from hitting 15y+
     * old CRTs which might, when there is a lot of solar flare activity and
     * when the celestial bodies are unfavourably aligned, implode trying to
     * sync to it. It's called "Protecting the user from doing anything stupid".
     * -- libv
     */

    if (xf86ModeIsReduced(mode)) {
        if (!monitor->reducedblanking && !(mode->type & M_T_DRIVER))
            return MODE_NO_REDUCED;
    }

    if ((monitor->maxPixClock) && (mode->Clock > monitor->maxPixClock))
        return MODE_CLOCK_HIGH;

    return MODE_OK;
}

/*
 * xf86CheckModeSize
 *
 * An internal routine to check if a mode fits in video memory.  This tries to
 * avoid overflows that would otherwise occur when video memory size is greater
 * than 256MB.
 */
static Bool
xf86CheckModeSize(ScrnInfoPtr scrp, int w, int x, int y)
{
    int bpp = scrp->fbFormat.bitsPerPixel, pad = scrp->fbFormat.scanlinePad;
    int lineWidth, lastWidth;

    if (scrp->depth == 4)
        pad *= 4;               /* 4 planes */

    /* Sanity check */
    if ((w < 0) || (x < 0) || (y <= 0))
        return FALSE;

    lineWidth = (((w * bpp) + pad - 1) / pad) * pad;
    lastWidth = x * bpp;

    /*
     * At this point, we need to compare
     *
     *  (lineWidth * (y - 1)) + lastWidth
     *
     * against
     *
     *  scrp->videoRam * (1024 * 8)
     *
     * These are bit quantities.  To avoid overflows, do the comparison in
     * terms of BITMAP_SCANLINE_PAD units.  This assumes BITMAP_SCANLINE_PAD
     * is a power of 2.  We currently use 32, which limits us to a video
     * memory size of 8GB.
     */

    lineWidth = (lineWidth + (BITMAP_SCANLINE_PAD - 1)) / BITMAP_SCANLINE_PAD;
    lastWidth = (lastWidth + (BITMAP_SCANLINE_PAD - 1)) / BITMAP_SCANLINE_PAD;

    if ((lineWidth * (y - 1) + lastWidth) >
        (scrp->videoRam * ((1024 * 8) / BITMAP_SCANLINE_PAD)))
        return FALSE;

    return TRUE;
}

/*
 * xf86InitialCheckModeForDriver
 *
 * This function checks if a mode satisfies a driver's initial requirements:
 *   -  mode size fits within the available pixel area (memory)
 *   -  width lies within the range of supported line pitches
 *   -  mode size fits within virtual size (if fixed)
 *   -  horizontal timings are in range
 *
 * This function takes the following parameters:
 *    scrp         ScrnInfoPtr
 *    mode         mode to check
 *    maxPitch     (optional) maximum line pitch
 *    virtualX     (optional) virtual width requested
 *    virtualY     (optional) virtual height requested
 *
 * In addition, the following fields from the ScrnInfoRec are used:
 *    monitor      pointer to structure for monitor section
 *    fbFormat     pixel format for the framebuffer
 *    videoRam     video memory size (in kB)
 *    maxHValue    maximum horizontal timing value
 *    maxVValue    maximum vertical timing value
 */

static ModeStatus
xf86InitialCheckModeForDriver(ScrnInfoPtr scrp, DisplayModePtr mode,
                              ClockRangePtr clockRanges,
                              LookupModeFlags strategy,
                              int maxPitch, int virtualX, int virtualY)
{
    ClockRangePtr cp;
    ModeStatus status;
    Bool allowDiv2 = (strategy & LOOKUP_CLKDIV2) != 0;
    int i, needDiv2;

    /* Sanity checks */
    if (!scrp || !mode || !clockRanges) {
        ErrorF("xf86InitialCheckModeForDriver: "
               "called with invalid parameters\n");
        return MODE_ERROR;
    }

    DebugF("xf86InitialCheckModeForDriver(%p, %p %s, %p, 0x%x, %d, %d, %d)\n",
           scrp, mode, mode->name, clockRanges, strategy, maxPitch, virtualX,
           virtualY);

    /* Some basic mode validity checks */
    if (0 >= mode->HDisplay || mode->HDisplay > mode->HSyncStart ||
        mode->HSyncStart >= mode->HSyncEnd || mode->HSyncEnd >= mode->HTotal)
        return MODE_H_ILLEGAL;

    if (0 >= mode->VDisplay || mode->VDisplay > mode->VSyncStart ||
        mode->VSyncStart >= mode->VSyncEnd || mode->VSyncEnd >= mode->VTotal)
        return MODE_V_ILLEGAL;

    if (!xf86CheckModeSize(scrp, mode->HDisplay, mode->HDisplay,
                           mode->VDisplay))
        return MODE_MEM;

    if (maxPitch > 0 && mode->HDisplay > maxPitch)
        return MODE_BAD_WIDTH;

    if (virtualX > 0 && mode->HDisplay > virtualX)
        return MODE_VIRTUAL_X;

    if (virtualY > 0 && mode->VDisplay > virtualY)
        return MODE_VIRTUAL_Y;

    if (scrp->maxHValue > 0 && mode->HTotal > scrp->maxHValue)
        return MODE_BAD_HVALUE;

    if (scrp->maxVValue > 0 && mode->VTotal > scrp->maxVValue)
        return MODE_BAD_VVALUE;

    /*
     * The use of the DisplayModeRec's Crtc* and SynthClock elements below is
     * provisional, in that they are later reused by the driver at mode-set
     * time.  Here, they are temporarily enlisted to contain the mode timings
     * as seen by the CRT or panel (rather than the CRTC).  The driver's
     * ValidMode() is allowed to modify these so it can deal with such things
     * as mode stretching and/or centering.  The driver should >NOT< modify the
     * user-supplied values as these are reported back when mode validation is
     * said and done.
     */
    /*
     * NOTE: We (ab)use the mode->Crtc* values here to store timing
     * information for the calculation of Hsync and Vrefresh. Before
     * these values are calculated the driver is given the opportunity
     * to either set these HSync and VRefresh itself or modify the timing
     * values.
     * The difference to the final calculation is small but imortand:
     * here we pass the flag INTERLACE_HALVE_V regardless if the driver
     * sets it or not. This way our calculation of VRefresh has the same
     * effect as if we do if (flags & V_INTERLACE) refresh *= 2.0
     * This dual use of the mode->Crtc* values will certainly create
     * confusion and is bad software design. However since it's part of
     * the driver API it's hard to change.
     */

    if (scrp->ValidMode) {

        xf86SetModeCrtc(mode, INTERLACE_HALVE_V);

        cp = xf86FindClockRangeForMode(clockRanges, mode);
        if (!cp)
            return MODE_CLOCK_RANGE;

        if (cp->ClockMulFactor < 1)
            cp->ClockMulFactor = 1;
        if (cp->ClockDivFactor < 1)
            cp->ClockDivFactor = 1;

        /*
         * XXX  The effect of clock dividers and multipliers on the monitor's
         *      pixel clock needs to be verified.
         */
        if (scrp->progClock) {
            mode->SynthClock = mode->Clock;
        }
        else {
            i = xf86GetNearestClock(scrp, mode->Clock, allowDiv2,
                                    cp->ClockDivFactor, cp->ClockMulFactor,
                                    &needDiv2);
            mode->SynthClock = (scrp->clock[i] * cp->ClockDivFactor) /
                cp->ClockMulFactor;
            if (needDiv2 & V_CLKDIV2)
                mode->SynthClock /= 2;
        }

        status = (*scrp->ValidMode) (scrp, mode, FALSE,
                                     MODECHECK_INITIAL);
        if (status != MODE_OK)
            return status;

        if (mode->HSync <= 0.0)
            mode->HSync = (float) mode->SynthClock / (float) mode->CrtcHTotal;
        if (mode->VRefresh <= 0.0)
            mode->VRefresh = (mode->SynthClock * 1000.0)
                / (mode->CrtcHTotal * mode->CrtcVTotal);
    }

    mode->HSync = xf86ModeHSync(mode);
    mode->VRefresh = xf86ModeVRefresh(mode);

    /* Assume it is OK */
    return MODE_OK;
}

/*
 * xf86CheckModeForDriver
 *
 * This function is for checking modes while the server is running (for
 * use mainly by the VidMode extension).
 *
 * This function checks if a mode satisfies a driver's requirements:
 *   -  width lies within the line pitch
 *   -  mode size fits within virtual size
 *   -  horizontal/vertical timings are in range
 *
 * This function takes the following parameters:
 *    scrp         ScrnInfoPtr
 *    mode         mode to check
 *    flags        not (currently) used
 *
 * In addition, the following fields from the ScrnInfoRec are used:
 *    maxHValue    maximum horizontal timing value
 *    maxVValue    maximum vertical timing value
 *    virtualX     virtual width
 *    virtualY     virtual height
 *    clockRanges  allowable clock ranges
 */

ModeStatus
xf86CheckModeForDriver(ScrnInfoPtr scrp, DisplayModePtr mode, int flags)
{
    ClockRangePtr cp;
    int i, k, gap, minimumGap = CLOCK_TOLERANCE + 1;
    int extraFlags = 0;
    int clockIndex = -1;
    int MulFactor = 1;
    int DivFactor = 1;
    int ModePrivFlags = 0;
    ModeStatus status = MODE_NOMODE;

    /* Some sanity checking */
    if (scrp == NULL || (!scrp->progClock && scrp->numClocks == 0)) {
        ErrorF("xf86CheckModeForDriver: called with invalid scrnInfoRec\n");
        return MODE_ERROR;
    }
    if (mode == NULL) {
        ErrorF("xf86CheckModeForDriver: called with invalid modep\n");
        return MODE_ERROR;
    }

    /* Check the mode size */
    if (mode->HDisplay > scrp->virtualX)
        return MODE_VIRTUAL_X;

    if (mode->VDisplay > scrp->virtualY)
        return MODE_VIRTUAL_Y;

    if (scrp->maxHValue > 0 && mode->HTotal > scrp->maxHValue)
        return MODE_BAD_HVALUE;

    if (scrp->maxVValue > 0 && mode->VTotal > scrp->maxVValue)
        return MODE_BAD_VVALUE;

    for (cp = scrp->clockRanges; cp != NULL; cp = cp->next) {
        /* DivFactor and MulFactor must be > 0 */
        cp->ClockDivFactor = max(1, cp->ClockDivFactor);
        cp->ClockMulFactor = max(1, cp->ClockMulFactor);
    }

    if (scrp->progClock) {
        /* Check clock is in range */
        for (cp = scrp->clockRanges; cp != NULL; cp = cp->next) {
            if (modeInClockRange(cp, mode))
                break;
        }
        if (cp == NULL) {
            return MODE_CLOCK_RANGE;
        }
        /*
         * If programmable clock the required mode has been found
         */
        DivFactor = cp->ClockDivFactor;
        MulFactor = cp->ClockMulFactor;
        ModePrivFlags = cp->PrivFlags;
    }
    else {
        status = MODE_CLOCK_RANGE;
        /* Check clock is in range */
        for (cp = scrp->clockRanges; cp != NULL; cp = cp->next) {
            if (modeInClockRange(cp, mode)) {
                /*
                 * Clock is in range, so if it is not a programmable clock,
                 * find a matching clock.
                 */

                i = xf86GetNearestClock(scrp, mode->Clock, 0,
                                        cp->ClockDivFactor, cp->ClockMulFactor,
                                        &k);
                /*
                 * If the clock is too far from the requested clock, this
                 * mode is no good.
                 */
                if (k & V_CLKDIV2)
                    gap = abs((mode->Clock * 2) -
                              ((scrp->clock[i] * cp->ClockDivFactor) /
                               cp->ClockMulFactor));
                else
                    gap = abs(mode->Clock -
                              ((scrp->clock[i] * cp->ClockDivFactor) /
                               cp->ClockMulFactor));
                if (gap > minimumGap) {
                    status = MODE_NOCLOCK;
                    continue;
                }

                DivFactor = cp->ClockDivFactor;
                MulFactor = cp->ClockMulFactor;
                ModePrivFlags = cp->PrivFlags;
                extraFlags = k;
                clockIndex = i;
                break;
            }
        }
        if (cp == NULL)
            return status;
    }

    /* Fill in the mode parameters */
    if (scrp->progClock) {
        mode->ClockIndex = -1;
        mode->SynthClock = (mode->Clock * MulFactor) / DivFactor;
    }
    else {
        mode->Clock = (scrp->clock[clockIndex] * DivFactor) / MulFactor;
        mode->ClockIndex = clockIndex;
        mode->SynthClock = scrp->clock[clockIndex];
        if (extraFlags & V_CLKDIV2) {
            mode->Clock /= 2;
            mode->SynthClock /= 2;
        }
    }
    mode->PrivFlags = ModePrivFlags;

    return MODE_OK;
}

static int
inferVirtualSize(ScrnInfoPtr scrp, DisplayModePtr modes, int *vx, int *vy)
{
    float aspect = 0.0;
    MonPtr mon = scrp->monitor;
    xf86MonPtr DDC;
    int x = 0, y = 0;
    DisplayModePtr mode;

    if (!mon)
        return 0;
    DDC = mon->DDC;

    if (DDC && DDC->ver.revision >= 4) {
        /* For 1.4, we might actually get native pixel format.  How novel. */
        if (PREFERRED_TIMING_MODE(DDC->features.msc)) {
            for (mode = modes; mode; mode = mode->next) {
                if (mode->type & (M_T_DRIVER | M_T_PREFERRED)) {
                    x = mode->HDisplay;
                    y = mode->VDisplay;
                    goto found;
                }
            }
        }
        /*
         * Even if we don't, we might get aspect ratio from extra CVT info
         * or from the monitor size fields.  TODO.
         */
    }

    /*
     * Technically this triggers if either is zero.  That wasn't legal
     * before EDID 1.4, but right now we'll get that wrong. TODO.
     */
    if (!aspect) {
        if (!mon->widthmm || !mon->heightmm)
            aspect = 4.0 / 3.0;
        else
            aspect = (float) mon->widthmm / (float) mon->heightmm;
    }

    /* find the largest M_T_DRIVER mode with that aspect ratio */
    for (mode = modes; mode; mode = mode->next) {
        float mode_aspect, metaspect;

        if (!(mode->type & (M_T_DRIVER | M_T_USERDEF)))
            continue;
        mode_aspect = (float) mode->HDisplay / (float) mode->VDisplay;
        metaspect = aspect / mode_aspect;
        /* 5% slop or so, since we only get size in centimeters */
        if (fabs(1.0 - metaspect) < 0.05) {
            if ((mode->HDisplay > x) && (mode->VDisplay > y)) {
                x = mode->HDisplay;
                y = mode->VDisplay;
            }
        }
    }

    if (!x || !y) {
        xf86DrvMsg(scrp->scrnIndex, X_WARNING,
                   "Unable to estimate virtual size\n");
        return 0;
    }

 found:
    *vx = x;
    *vy = y;

    xf86DrvMsg(scrp->scrnIndex, X_INFO,
               "Estimated virtual size for aspect ratio %.4f is %dx%d\n",
               aspect, *vx, *vy);

    return 1;
}

/* Least common multiple */
static unsigned int
LCM(unsigned int x, unsigned int y)
{
    unsigned int m = x, n = y, o;

    while ((o = m % n)) {
        m = n;
        n = o;
    }

    return (x / n) * y;
}

/*
 * Given various screen attributes, determine the minimum scanline width such
 * that each scanline is server and DDX padded and any pixels with imbedded
 * bank boundaries are off-screen.  This function returns -1 if such a width
 * cannot exist.
 */
static int
scanLineWidth(unsigned int xsize,       /* pixels */
              unsigned int ysize,       /* pixels */
              unsigned int width,       /* pixels */
              unsigned long BankSize,   /* char's */
              PixmapFormatRec * pBankFormat, unsigned int nWidthUnit    /* bits */
    )
{
    unsigned long nBitsPerBank, nBitsPerScanline, nBitsPerScanlinePadUnit;
    unsigned long minBitsPerScanline, maxBitsPerScanline;

    /* Sanity checks */

    if (!nWidthUnit || !pBankFormat)
        return -1;

    nBitsPerBank = BankSize * 8;
    if (nBitsPerBank % pBankFormat->scanlinePad)
        return -1;

    if (xsize > width)
        width = xsize;
    nBitsPerScanlinePadUnit = LCM(pBankFormat->scanlinePad, nWidthUnit);
    nBitsPerScanline =
        (((width * pBankFormat->bitsPerPixel) + nBitsPerScanlinePadUnit - 1) /
         nBitsPerScanlinePadUnit) * nBitsPerScanlinePadUnit;
    width = nBitsPerScanline / pBankFormat->bitsPerPixel;

    if (!xsize || !(nBitsPerBank % pBankFormat->bitsPerPixel))
        return (int) width;

    /*
     * Scanlines will be server-pad aligned at this point.  They will also be
     * a multiple of nWidthUnit bits long.  Ensure that pixels with imbedded
     * bank boundaries are off-screen.
     *
     * It seems reasonable to limit total frame buffer size to 1/16 of the
     * theoretical maximum address space size.  On a machine with 32-bit
     * addresses (to 8-bit quantities) this turns out to be 256MB.  Not only
     * does this provide a simple limiting condition for the loops below, but
     * it also prevents unsigned long wraparounds.
     */
    if (!ysize)
        return -1;

    minBitsPerScanline = xsize * pBankFormat->bitsPerPixel;
    if (minBitsPerScanline > nBitsPerBank)
        return -1;

    if (ysize == 1)
        return (int) width;

    maxBitsPerScanline =
        (((unsigned long) (-1) >> 1) - minBitsPerScanline) / (ysize - 1);
    while (nBitsPerScanline <= maxBitsPerScanline) {
        unsigned long BankBase, BankUnit;

        BankUnit = ((nBitsPerBank + nBitsPerScanline - 1) / nBitsPerBank) *
            nBitsPerBank;
        if (!(BankUnit % nBitsPerScanline))
            return (int) width;

        for (BankBase = BankUnit;; BankBase += nBitsPerBank) {
            unsigned long x, y;

            y = BankBase / nBitsPerScanline;
            if (y >= ysize)
                return (int) width;

            x = BankBase % nBitsPerScanline;
            if (!(x % pBankFormat->bitsPerPixel))
                continue;

            if (x < minBitsPerScanline) {
                /*
                 * Skip ahead certain widths by dividing the excess scanline
                 * amongst the y's.
                 */
                y *= nBitsPerScanlinePadUnit;
                nBitsPerScanline += ((x + y - 1) / y) * nBitsPerScanlinePadUnit;
                width = nBitsPerScanline / pBankFormat->bitsPerPixel;
                break;
            }

            if (BankBase != BankUnit)
                continue;

            if (!(nBitsPerScanline % x))
                return (int) width;

            BankBase = ((nBitsPerScanline - minBitsPerScanline) /
                        (nBitsPerScanline - x)) * BankUnit;
        }
    }

    return -1;
}

/*
 * xf86ValidateModes
 *
 * This function takes a set of mode names, modes and limiting conditions,
 * and selects a set of modes and parameters based on those conditions.
 *
 * This function takes the following parameters:
 *    scrp         ScrnInfoPtr
 *    availModes   the list of modes available for the monitor
 *    modeNames    (optional) list of mode names that the screen is requesting
 *    clockRanges  a list of clock ranges
 *    linePitches  (optional) a list of line pitches
 *    minPitch     (optional) minimum line pitch (in pixels)
 *    maxPitch     (optional) maximum line pitch (in pixels)
 *    pitchInc     (mandatory) pitch increment (in bits)
 *    minHeight    (optional) minimum virtual height (in pixels)
 *    maxHeight    (optional) maximum virtual height (in pixels)
 *    virtualX     (optional) virtual width requested (in pixels)
 *    virtualY     (optional) virtual height requested (in pixels)
 *    apertureSize size of video aperture (in bytes)
 *    strategy     how to decide which mode to use from multiple modes with
 *                 the same name
 *
 * In addition, the following fields from the ScrnInfoRec are used:
 *    clocks       a list of discrete clocks
 *    numClocks    number of discrete clocks
 *    progClock    clock is programmable
 *    monitor      pointer to structure for monitor section
 *    fbFormat     format of the framebuffer
 *    videoRam     video memory size
 *    maxHValue    maximum horizontal timing value
 *    maxVValue    maximum vertical timing value
 *    xInc         horizontal timing increment (defaults to 8 pixels)
 *
 * The function fills in the following ScrnInfoRec fields:
 *    modePool     A subset of the modes available to the monitor which
 *		   are compatible with the driver.
 *    modes        one mode entry for each of the requested modes, with the
 *                 status field filled in to indicate if the mode has been
 *                 accepted or not.
 *    virtualX     the resulting virtual width
 *    virtualY     the resulting virtual height
 *    displayWidth the resulting line pitch
 *
 * The function's return value is the number of matching modes found, or -1
 * if an unrecoverable error was encountered.
 */

int
xf86ValidateModes(ScrnInfoPtr scrp, DisplayModePtr availModes,
                  const char **modeNames, ClockRangePtr clockRanges,
                  int *linePitches, int minPitch, int maxPitch, int pitchInc,
                  int minHeight, int maxHeight, int virtualX, int virtualY,
                  int apertureSize, LookupModeFlags strategy)
{
    DisplayModePtr p, q, r, new, last, *endp;
    int i, numModes = 0;
    ModeStatus status;
    int linePitch = -1, virtX = 0, virtY = 0;
    int newLinePitch, newVirtX, newVirtY;
    int modeSize;               /* in pixels */
    Bool validateAllDefaultModes = FALSE;
    Bool userModes = FALSE;
    int saveType;
    PixmapFormatRec *BankFormat;
    ClockRangePtr cp;
    int numTimings = 0;
    range hsync[MAX_HSYNC];
    range vrefresh[MAX_VREFRESH];
    Bool inferred_virtual = FALSE;

    DebugF
        ("xf86ValidateModes(%p, %p, %p, %p,\n\t\t  %p, %d, %d, %d, %d, %d, %d, %d, %d, 0x%x)\n",
         scrp, availModes, modeNames, clockRanges, linePitches, minPitch,
         maxPitch, pitchInc, minHeight, maxHeight, virtualX, virtualY,
         apertureSize, strategy);

    /* Some sanity checking */
    if (scrp == NULL || scrp->name == NULL || !scrp->monitor ||
        (!scrp->progClock && scrp->numClocks == 0)) {
        ErrorF("xf86ValidateModes: called with invalid scrnInfoRec\n");
        return -1;
    }
    if (linePitches != NULL && linePitches[0] <= 0) {
        ErrorF("xf86ValidateModes: called with invalid linePitches\n");
        return -1;
    }
    if (pitchInc <= 0) {
        ErrorF("xf86ValidateModes: called with invalid pitchInc\n");
        return -1;
    }
    if ((virtualX > 0) != (virtualY > 0)) {
        ErrorF("xf86ValidateModes: called with invalid virtual resolution\n");
        return -1;
    }

    /*
     * If requested by the driver, allow missing hsync and/or vrefresh ranges
     * in the monitor section.
     */
    if (strategy & LOOKUP_OPTIONAL_TOLERANCES) {
        strategy &= ~LOOKUP_OPTIONAL_TOLERANCES;
    }
    else {
        const char *type = "";
        Bool specified = FALSE;

        if (scrp->monitor->nHsync <= 0) {
            if (numTimings > 0) {
                scrp->monitor->nHsync = numTimings;
                for (i = 0; i < numTimings; i++) {
                    scrp->monitor->hsync[i].lo = hsync[i].lo;
                    scrp->monitor->hsync[i].hi = hsync[i].hi;
                }
            }
            else {
                scrp->monitor->hsync[0].lo = 31.5;
                scrp->monitor->hsync[0].hi = 48.0;
                scrp->monitor->nHsync = 1;
            }
            type = "default ";
        }
        else {
            specified = TRUE;
        }
        for (i = 0; i < scrp->monitor->nHsync; i++) {
            if (scrp->monitor->hsync[i].lo == scrp->monitor->hsync[i].hi)
                xf86DrvMsg(scrp->scrnIndex, X_INFO,
                           "%s: Using %shsync value of %.2f kHz\n",
                           scrp->monitor->id, type, scrp->monitor->hsync[i].lo);
            else
                xf86DrvMsg(scrp->scrnIndex, X_INFO,
                           "%s: Using %shsync range of %.2f-%.2f kHz\n",
                           scrp->monitor->id, type,
                           scrp->monitor->hsync[i].lo,
                           scrp->monitor->hsync[i].hi);
        }

        type = "";
        if (scrp->monitor->nVrefresh <= 0) {
            if (numTimings > 0) {
                scrp->monitor->nVrefresh = numTimings;
                for (i = 0; i < numTimings; i++) {
                    scrp->monitor->vrefresh[i].lo = vrefresh[i].lo;
                    scrp->monitor->vrefresh[i].hi = vrefresh[i].hi;
                }
            }
            else {
                scrp->monitor->vrefresh[0].lo = 50;
                scrp->monitor->vrefresh[0].hi = 70;
                scrp->monitor->nVrefresh = 1;
            }
            type = "default ";
        }
        else {
            specified = TRUE;
        }
        for (i = 0; i < scrp->monitor->nVrefresh; i++) {
            if (scrp->monitor->vrefresh[i].lo == scrp->monitor->vrefresh[i].hi)
                xf86DrvMsg(scrp->scrnIndex, X_INFO,
                           "%s: Using %svrefresh value of %.2f Hz\n",
                           scrp->monitor->id, type,
                           scrp->monitor->vrefresh[i].lo);
            else
                xf86DrvMsg(scrp->scrnIndex, X_INFO,
                           "%s: Using %svrefresh range of %.2f-%.2f Hz\n",
                           scrp->monitor->id, type,
                           scrp->monitor->vrefresh[i].lo,
                           scrp->monitor->vrefresh[i].hi);
        }

        type = "";
        if (!scrp->monitor->maxPixClock && !specified) {
            type = "default ";
            scrp->monitor->maxPixClock = 65000.0;
        }
        if (scrp->monitor->maxPixClock) {
            xf86DrvMsg(scrp->scrnIndex, X_INFO,
                       "%s: Using %smaximum pixel clock of %.2f MHz\n",
                       scrp->monitor->id, type,
                       (float) scrp->monitor->maxPixClock / 1000.0);
        }
    }

    /*
     * Store the clockRanges for later use by the VidMode extension.
     */
    nt_list_for_each_entry(cp, clockRanges, next) {
        ClockRangePtr newCR = xnfalloc(sizeof(ClockRange));
        memcpy(newCR, cp, sizeof(ClockRange));
        newCR->next = NULL;
        if (scrp->clockRanges == NULL)
            scrp->clockRanges = newCR;
        else
            nt_list_append(newCR, scrp->clockRanges, ClockRange, next);
    }

    /* Determine which pixmap format to pass to scanLineWidth() */
    if (scrp->depth > 4)
        BankFormat = &scrp->fbFormat;
    else
        BankFormat = xf86GetPixFormat(scrp, 1); /* >not< scrp->depth! */

    if (scrp->xInc <= 0)
        scrp->xInc = 8;         /* Suitable for VGA and others */

#define _VIRTUALX(x) ((((x) + scrp->xInc - 1) / scrp->xInc) * scrp->xInc)

    /*
     * Determine maxPitch if it wasn't given explicitly.  Note linePitches
     * always takes precedence if is non-NULL.  In that case the minPitch and
     * maxPitch values passed are ignored.
     */
    if (linePitches) {
        minPitch = maxPitch = linePitches[0];
        for (i = 1; linePitches[i] > 0; i++) {
            if (linePitches[i] > maxPitch)
                maxPitch = linePitches[i];
            if (linePitches[i] < minPitch)
                minPitch = linePitches[i];
        }
    }

    /* Initial check of virtual size against other constraints */
    scrp->virtualFrom = X_PROBED;
    /*
     * Initialise virtX and virtY if the values are fixed.
     */
    if (virtualY > 0) {
        if (maxHeight > 0 && virtualY > maxHeight) {
            xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                       "Virtual height (%d) is too large for the hardware "
                       "(max %d)\n", virtualY, maxHeight);
            return -1;
        }

        if (minHeight > 0 && virtualY < minHeight) {
            xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                       "Virtual height (%d) is too small for the hardware "
                       "(min %d)\n", virtualY, minHeight);
            return -1;
        }

        virtualX = _VIRTUALX(virtualX);
        if (linePitches != NULL) {
            for (i = 0; linePitches[i] != 0; i++) {
                if ((linePitches[i] >= virtualX) &&
                    (linePitches[i] ==
                     scanLineWidth(virtualX, virtualY, linePitches[i],
                                   apertureSize, BankFormat, pitchInc))) {
                    linePitch = linePitches[i];
                    break;
                }
            }
        }
        else {
            linePitch = scanLineWidth(virtualX, virtualY, minPitch,
                                      apertureSize, BankFormat, pitchInc);
        }

        if ((linePitch < minPitch) || (linePitch > maxPitch)) {
            xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                       "Virtual width (%d) is too large for the hardware "
                       "(max %d)\n", virtualX, maxPitch);
            return -1;
        }

        if (!xf86CheckModeSize(scrp, linePitch, virtualX, virtualY)) {
            xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                       "Virtual size (%dx%d) (pitch %d) exceeds video memory\n",
                       virtualX, virtualY, linePitch);
            return -1;
        }

        virtX = virtualX;
        virtY = virtualY;
        scrp->virtualFrom = X_CONFIG;
    }
    else if (!modeNames || !*modeNames) {
        /* No virtual size given in the config, try to infer */
        /* XXX this doesn't take m{in,ax}Pitch into account; oh well */
        inferred_virtual = inferVirtualSize(scrp, availModes, &virtX, &virtY);
        if (inferred_virtual)
            linePitch = scanLineWidth(virtX, virtY, minPitch, apertureSize,
                                      BankFormat, pitchInc);
    }

    /* Print clock ranges and scaled clocks */
    xf86ShowClockRanges(scrp, clockRanges);

    /*
     * If scrp->modePool hasn't been setup yet, set it up now.  This allows the
     * modes that the driver definitely can't use to be weeded out early.  Note
     * that a modePool mode's prev field is used to hold a pointer to the
     * member of the scrp->modes list for which a match was considered.
     */
    if (scrp->modePool == NULL) {
        q = NULL;
        for (p = availModes; p != NULL; p = p->next) {
            status = xf86InitialCheckModeForDriver(scrp, p, clockRanges,
                                                   strategy, maxPitch,
                                                   virtX, virtY);

            if (status == MODE_OK) {
                status = xf86CheckModeForMonitor(p, scrp->monitor);
            }

            if (status == MODE_OK) {
                new = xnfalloc(sizeof(DisplayModeRec));
                *new = *p;
                new->next = NULL;
                if (!q) {
                    scrp->modePool = new;
                }
                else {
                    q->next = new;
                }
                new->prev = NULL;
                q = new;
                q->name = xnfstrdup(p->name);
                q->status = MODE_OK;
            }
            else {
                printModeRejectMessage(scrp->scrnIndex, p, status);
            }
        }

        if (scrp->modePool == NULL) {
            xf86DrvMsg(scrp->scrnIndex, X_WARNING, "Mode pool is empty\n");
            return 0;
        }
    }
    else {
        for (p = scrp->modePool; p != NULL; p = p->next) {
            p->prev = NULL;
            p->status = MODE_OK;
        }
    }

    /*
     * Allocate one entry in scrp->modes for each named mode.
     */
    while (scrp->modes)
        xf86DeleteMode(&scrp->modes, scrp->modes);
    endp = &scrp->modes;
    last = NULL;
    if (modeNames != NULL) {
        for (i = 0; modeNames[i] != NULL; i++) {
            userModes = TRUE;
            new = xnfcalloc(1, sizeof(DisplayModeRec));
            new->prev = last;
            new->type = M_T_USERDEF;
            new->name = xnfstrdup(modeNames[i]);
            if (new->prev)
                new->prev->next = new;
            *endp = last = new;
            endp = &new->next;
        }
    }

    /* Lookup each mode */
#ifdef RANDR
    if (!xf86Info.disableRandR
#ifdef PANORAMIX
        && noPanoramiXExtension
#endif
        )
        validateAllDefaultModes = TRUE;
#endif

    for (p = scrp->modes;; p = p->next) {
        Bool repeat;

        /*
         * If the supplied mode names don't produce a valid mode, scan through
         * unconsidered modePool members until one survives validation.  This
         * is done in decreasing order by mode pixel area.
         */

        if (p == NULL) {
            if ((numModes > 0) && !validateAllDefaultModes)
                break;

            validateAllDefaultModes = TRUE;
            r = NULL;
            modeSize = 0;
            for (q = scrp->modePool; q != NULL; q = q->next) {
                if ((q->prev == NULL) && (q->status == MODE_OK)) {
                    /*
                     * Deal with the case where this mode wasn't considered
                     * because of a builtin mode of the same name.
                     */
                    for (p = scrp->modes; p != NULL; p = p->next) {
                        if ((p->status != MODE_OK) && !strcmp(p->name, q->name))
                            break;
                    }

                    if (p != NULL)
                        q->prev = p;
                    else {
                        /*
                         * A quick check to not allow default modes with
                         * horizontal timing parameters that CRTs may have
                         * problems with.
                         */
                        if (!scrp->monitor->reducedblanking &&
                            (q->type & M_T_DEFAULT) &&
                            ((double) q->HTotal / (double) q->HDisplay) < 1.15)
                            continue;

                        if (modeSize < (q->HDisplay * q->VDisplay)) {
                            r = q;
                            modeSize = q->HDisplay * q->VDisplay;
                        }
                    }
                }
            }

            if (r == NULL)
                break;

            p = xnfcalloc(1, sizeof(DisplayModeRec));
            p->prev = last;
            p->name = xnfstrdup(r->name);
            if (!userModes)
                p->type = M_T_USERDEF;
            if (p->prev)
                p->prev->next = p;
            *endp = last = p;
            endp = &p->next;
        }

        repeat = FALSE;
 lookupNext:
        if (repeat && ((status = p->status) != MODE_OK))
            printModeRejectMessage(scrp->scrnIndex, p, status);
        saveType = p->type;
        status = xf86LookupMode(scrp, p, clockRanges, strategy);
        if (repeat && status == MODE_NOMODE)
            continue;
        if (status != MODE_OK)
            printModeRejectMessage(scrp->scrnIndex, p, status);
        if (status == MODE_ERROR) {
            ErrorF("xf86ValidateModes: "
                   "unexpected result from xf86LookupMode()\n");
            return -1;
        }
        if (status != MODE_OK) {
            if (p->status == MODE_OK)
                p->status = status;
            continue;
        }
        p->type |= saveType;
        repeat = TRUE;

        newLinePitch = linePitch;
        newVirtX = virtX;
        newVirtY = virtY;

        /*
         * Don't let non-user defined modes increase the virtual size
         */
        if (!(p->type & M_T_USERDEF) && (numModes > 0)) {
            if (p->HDisplay > virtX) {
                p->status = MODE_VIRTUAL_X;
                goto lookupNext;
            }
            if (p->VDisplay > virtY) {
                p->status = MODE_VIRTUAL_Y;
                goto lookupNext;
            }
        }
        /*
         * Adjust virtual width and height if the mode is too large for the
         * current values and if they are not fixed.
         */
        if (virtualX <= 0 && p->HDisplay > newVirtX)
            newVirtX = _VIRTUALX(p->HDisplay);
        if (virtualY <= 0 && p->VDisplay > newVirtY) {
            if (maxHeight > 0 && p->VDisplay > maxHeight) {
                p->status = MODE_VIRTUAL_Y;     /* ? */
                goto lookupNext;
            }
            newVirtY = p->VDisplay;
        }

        /*
         * If virtual resolution is to be increased, revalidate it.
         */
        if ((virtX != newVirtX) || (virtY != newVirtY)) {
            if (linePitches != NULL) {
                newLinePitch = -1;
                for (i = 0; linePitches[i] != 0; i++) {
                    if ((linePitches[i] >= newVirtX) &&
                        (linePitches[i] >= linePitch) &&
                        (linePitches[i] ==
                         scanLineWidth(newVirtX, newVirtY, linePitches[i],
                                       apertureSize, BankFormat, pitchInc))) {
                        newLinePitch = linePitches[i];
                        break;
                    }
                }
            }
            else {
                if (linePitch < minPitch)
                    linePitch = minPitch;
                newLinePitch = scanLineWidth(newVirtX, newVirtY, linePitch,
                                             apertureSize, BankFormat,
                                             pitchInc);
            }
            if ((newLinePitch < minPitch) || (newLinePitch > maxPitch)) {
                p->status = MODE_BAD_WIDTH;
                goto lookupNext;
            }

            /*
             * Check that the pixel area required by the new virtual height
             * and line pitch isn't too large.
             */
            if (!xf86CheckModeSize(scrp, newLinePitch, newVirtX, newVirtY)) {
                p->status = MODE_MEM_VIRT;
                goto lookupNext;
            }
        }

        if (scrp->ValidMode) {
            /*
             * Give the driver a final say, passing it the proposed virtual
             * geometry.
             */
            scrp->virtualX = newVirtX;
            scrp->virtualY = newVirtY;
            scrp->displayWidth = newLinePitch;
            p->status = (scrp->ValidMode) (scrp, p, FALSE,
                                           MODECHECK_FINAL);

            if (p->status != MODE_OK) {
                goto lookupNext;
            }
        }

        /* Mode has passed all the tests */
        virtX = newVirtX;
        virtY = newVirtY;
        linePitch = newLinePitch;
        p->status = MODE_OK;
        numModes++;
    }

    /*
     * If we estimated the virtual size above, we may have filtered away all
     * the modes that maximally match that size; scan again to find out and
     * fix up if so.
     */
    if (inferred_virtual) {
        int vx = 0, vy = 0;

        for (p = scrp->modes; p; p = p->next) {
            if (p->HDisplay > vx && p->VDisplay > vy) {
                vx = p->HDisplay;
                vy = p->VDisplay;
            }
        }
        if (vx < virtX || vy < virtY) {
            const int types[] = {
                M_T_BUILTIN | M_T_PREFERRED,
                M_T_BUILTIN,
                M_T_DRIVER | M_T_PREFERRED,
                M_T_DRIVER,
                0
            };
            const int ntypes = sizeof(types) / sizeof(int);
            int n;

            /*
             * We did not find the estimated virtual size. So now we want to
             * find the largest mode available, but we want to search in the
             * modes in the order of "types" listed above.
             */
            for (n = 0; n < ntypes; n++) {
                int type = types[n];

                vx = 0;
                vy = 0;
                for (p = scrp->modes; p; p = p->next) {
                    /* scan through the modes in the sort order above */
                    if ((p->type & type) != type)
                        continue;
                    if (p->HDisplay > vx && p->VDisplay > vy) {
                        vx = p->HDisplay;
                        vy = p->VDisplay;
                    }
                }
                if (vx && vy)
                    /* Found one */
                    break;
            }
            xf86DrvMsg(scrp->scrnIndex, X_WARNING,
                       "Shrinking virtual size estimate from %dx%d to %dx%d\n",
                       virtX, virtY, vx, vy);
            virtX = _VIRTUALX(vx);
            virtY = vy;
            for (p = scrp->modes; p; p = p->next) {
                if (numModes > 0) {
                    if (p->HDisplay > virtX)
                        p->status = MODE_VIRTUAL_X;
                    if (p->VDisplay > virtY)
                        p->status = MODE_VIRTUAL_Y;
                    if (p->status != MODE_OK) {
                        numModes--;
                        printModeRejectMessage(scrp->scrnIndex, p, p->status);
                    }
                }
            }
            if (linePitches != NULL) {
                for (i = 0; linePitches[i] != 0; i++) {
                    if ((linePitches[i] >= virtX) &&
                        (linePitches[i] ==
                         scanLineWidth(virtX, virtY, linePitches[i],
                                       apertureSize, BankFormat, pitchInc))) {
                        linePitch = linePitches[i];
                        break;
                    }
                }
            }
            else {
                linePitch = scanLineWidth(virtX, virtY, minPitch,
                                          apertureSize, BankFormat, pitchInc);
            }
        }
    }

    /* Update the ScrnInfoRec parameters */

    scrp->virtualX = virtX;
    scrp->virtualY = virtY;
    scrp->displayWidth = linePitch;

    if (numModes <= 0)
        return 0;

    /* Make the mode list into a circular list by joining up the ends */
    p = scrp->modes;
    while (p->next != NULL)
        p = p->next;
    /* p is now the last mode on the list */
    p->next = scrp->modes;
    scrp->modes->prev = p;

    if (minHeight > 0 && virtY < minHeight) {
        xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                   "Virtual height (%d) is too small for the hardware "
                   "(min %d)\n", virtY, minHeight);
        return -1;
    }

    return numModes;
}

/*
 * xf86DeleteMode
 *
 * This function removes a mode from a list of modes.
 *
 * There are different types of mode lists:
 *
 *  - singly linked linear lists, ending in NULL
 *  - doubly linked linear lists, starting and ending in NULL
 *  - doubly linked circular lists
 *
 */

void
xf86DeleteMode(DisplayModePtr * modeList, DisplayModePtr mode)
{
    /* Catch the easy/insane cases */
    if (modeList == NULL || *modeList == NULL || mode == NULL)
        return;

    /* If the mode is at the start of the list, move the start of the list */
    if (*modeList == mode)
        *modeList = mode->next;

    /* If mode is the only one on the list, set the list to NULL */
    if ((mode == mode->prev) && (mode == mode->next)) {
        *modeList = NULL;
    }
    else {
        if ((mode->prev != NULL) && (mode->prev->next == mode))
            mode->prev->next = mode->next;
        if ((mode->next != NULL) && (mode->next->prev == mode))
            mode->next->prev = mode->prev;
    }

    free((void *) mode->name);
    free(mode);
}

/*
 * xf86PruneDriverModes
 *
 * Remove modes from the driver's mode list which have been marked as
 * invalid.
 */

void
xf86PruneDriverModes(ScrnInfoPtr scrp)
{
    DisplayModePtr first, p, n;

    p = scrp->modes;
    if (p == NULL)
        return;

    do {
        if (!(first = scrp->modes))
            return;
        n = p->next;
        if (p->status != MODE_OK) {
            xf86DeleteMode(&(scrp->modes), p);
        }
        p = n;
    } while (p != NULL && p != first);

    /* modePool is no longer needed, turf it */
    while (scrp->modePool) {
        /*
         * A modePool mode's prev field is used to hold a pointer to the
         * member of the scrp->modes list for which a match was considered.
         * Clear that pointer first, otherwise xf86DeleteMode might get
         * confused
         */
        scrp->modePool->prev = NULL;
        xf86DeleteMode(&scrp->modePool, scrp->modePool);
    }
}

/*
 * xf86SetCrtcForModes
 *
 * Goes through the screen's mode list, and initialises the Crtc
 * parameters for each mode.  The initialisation includes adjustments
 * for interlaced and double scan modes.
 */
void
xf86SetCrtcForModes(ScrnInfoPtr scrp, int adjustFlags)
{
    DisplayModePtr p;

    /*
     * Store adjustFlags for use with the VidMode extension. There is an
     * implicit assumption here that SetCrtcForModes is called once.
     */
    scrp->adjustFlags = adjustFlags;

    p = scrp->modes;
    if (p == NULL)
        return;

    do {
        xf86SetModeCrtc(p, adjustFlags);
        DebugF("%sMode %s: %d (%d) %d %d (%d) %d %d (%d) %d %d (%d) %d\n",
               (p->type & M_T_DEFAULT) ? "Default " : "",
               p->name, p->CrtcHDisplay, p->CrtcHBlankStart,
               p->CrtcHSyncStart, p->CrtcHSyncEnd, p->CrtcHBlankEnd,
               p->CrtcHTotal, p->CrtcVDisplay, p->CrtcVBlankStart,
               p->CrtcVSyncStart, p->CrtcVSyncEnd, p->CrtcVBlankEnd,
               p->CrtcVTotal);
        p = p->next;
    } while (p != NULL && p != scrp->modes);
}

void
xf86PrintModes(ScrnInfoPtr scrp)
{
    DisplayModePtr p;
    float hsync, refresh = 0;
    const char *desc, *desc2, *prefix, *uprefix;

    if (scrp == NULL)
        return;

    xf86DrvMsg(scrp->scrnIndex, scrp->virtualFrom, "Virtual size is %dx%d "
               "(pitch %d)\n", scrp->virtualX, scrp->virtualY,
               scrp->displayWidth);

    p = scrp->modes;
    if (p == NULL)
        return;

    do {
        desc = desc2 = "";
        hsync = xf86ModeHSync(p);
        refresh = xf86ModeVRefresh(p);
        if (p->Flags & V_INTERLACE) {
            desc = " (I)";
        }
        if (p->Flags & V_DBLSCAN) {
            desc = " (D)";
        }
        if (p->VScan > 1) {
            desc2 = " (VScan)";
        }
        if (p->type & M_T_BUILTIN)
            prefix = "Built-in mode";
        else if (p->type & M_T_DEFAULT)
            prefix = "Default mode";
        else if (p->type & M_T_DRIVER)
            prefix = "Driver mode";
        else
            prefix = "Mode";
        if (p->type & M_T_USERDEF)
            uprefix = "*";
        else
            uprefix = " ";
        if (hsync == 0 || refresh == 0) {
            if (p->name)
                xf86DrvMsg(scrp->scrnIndex, X_CONFIG,
                           "%s%s \"%s\"\n", uprefix, prefix, p->name);
            else
                xf86DrvMsg(scrp->scrnIndex, X_PROBED,
                           "%s%s %dx%d (unnamed)\n",
                           uprefix, prefix, p->HDisplay, p->VDisplay);
        }
        else if (p->Clock == p->SynthClock) {
            xf86DrvMsg(scrp->scrnIndex, X_CONFIG,
                       "%s%s \"%s\": %.1f MHz, %.1f kHz, %.1f Hz%s%s\n",
                       uprefix, prefix, p->name, p->Clock / 1000.0,
                       hsync, refresh, desc, desc2);
        }
        else {
            xf86DrvMsg(scrp->scrnIndex, X_CONFIG,
                       "%s%s \"%s\": %.1f MHz (scaled from %.1f MHz), "
                       "%.1f kHz, %.1f Hz%s%s\n",
                       uprefix, prefix, p->name, p->Clock / 1000.0,
                       p->SynthClock / 1000.0, hsync, refresh, desc, desc2);
        }
        if (hsync != 0 && refresh != 0)
            xf86PrintModeline(scrp->scrnIndex, p);
        p = p->next;
    } while (p != NULL && p != scrp->modes);
}
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d115 2
a116 3
 * xf86GetNearestClock --
 *	Find closest clock to given frequency (in kHz).  This assumes the
 *	number of clocks is greater than zero.
d118 1
a118 1
int
d453 1
a453 1
ModeStatus
d847 1
a847 1
ModeStatus
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1881 2
a1882 2
            /* 
             * We did not find the estimated virtual size. So now we want to 
d2036 2
a2037 2
         * Clear that pointer first, otherwise xf86DeleteMode might get 
         * confused 
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d1357 1
a1357 1
                  char **modeNames, ClockRangePtr clockRanges,
d2001 1
a2001 1
    free(mode->name);
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a1372 1
    ClockRangePtr storeClockRanges;
d1494 4
a1497 7
    storeClockRanges = scrp->clockRanges;
    while (storeClockRanges != NULL) {
        storeClockRanges = storeClockRanges->next;
    }
    for (cp = clockRanges; cp != NULL; cp = cp->next,
         storeClockRanges = storeClockRanges->next) {
        storeClockRanges = xnfalloc(sizeof(ClockRange));
d1499 3
a1501 2
            scrp->clockRanges = storeClockRanges;
        memcpy(storeClockRanges, cp, sizeof(ClockRange));
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d953 1
a953 1
        status = (*scrp->ValidMode) (scrp->scrnIndex, mode, FALSE,
d1843 1
a1843 1
            p->status = (scrp->ValidMode) (scrp->scrnIndex, p, FALSE,
@


1.7
log
@Update to xserver 1.11.2
@
text
@d99 1
a99 1
    char *type;
d102 1
a102 1
	type = "built-in ";
d104 1
a104 1
	type = "default ";
d106 1
a106 1
	type = "driver ";
d108 1
a108 1
	type = "";
d111 1
a111 1
	       xf86ModeStatusToString(status));
d121 1
a121 1
    int DivFactor, int MulFactor, int *divider)
d128 1
a128 1
	k = 2;
d130 1
a130 1
	k = 1;
d134 13
a146 14
	*divider = 0;
    
    for (i = 0;  i < scrp->numClocks;  i++) {
	for (j = 1; j <= k; j++) {
	    gap = abs((freq * j) - ((scrp->clock[i] * DivFactor) / MulFactor));
	    if ((gap < minimumGap) ||
		((gap == minimumGap) && (j < nearestDiv))) {
		minimumGap = gap;
		nearestClock = i;
		nearestDiv = j;
		if (divider != NULL)
		    *divider = (j - 1) * V_CLKDIV2;
	    }
	}
d162 1
a162 1
	return "Mode OK";
d164 1
a164 1
	return "hsync out of range";
d166 1
a166 1
	return "vrefresh out of range";
d168 1
a168 1
	return "illegal horizontal timings";
d170 1
a170 1
	return "illegal vertical timings";
d172 1
a172 1
	return "width requires unsupported line pitch";
d174 1
a174 1
	return "no mode of this name";
d176 1
a176 1
	return "interlace mode not supported";
d178 1
a178 1
	return "doublescan mode not supported";
d180 1
a180 1
	return "multiscan mode not supported";
d182 1
a182 1
	return "insufficient memory for mode";
d184 1
a184 1
	return "width too large for virtual size";
d186 1
a186 1
	return "height too large for virtual size";
d188 1
a188 1
	return "insufficient memory given virtual size";
d190 1
a190 1
	return "no clock available for mode";
d192 1
a192 1
	return "mode clock too high";
d194 1
a194 1
	return "mode clock too low";
d196 1
a196 1
	return "bad mode clock/interlace/doublescan";
d198 1
a198 1
	return "horizontal timing out of range";
d200 1
a200 1
	return "vertical timing out of range";
d202 1
a202 1
	return "VScan value out of range";
d204 1
a204 1
	return "horizontal sync too narrow";
d206 1
a206 1
	return "horizontal sync too wide";
d208 1
a208 1
	return "horizontal blanking too narrow";
d210 1
a210 1
	return "horizontal blanking too wide";
d212 1
a212 1
	return "vertical sync too narrow";
d214 1
a214 1
	return "vertical sync too wide";
d216 1
a216 1
	return "vertical blanking too narrow";
d218 1
a218 1
	return "vertical blanking too wide";
d220 1
a220 1
	return "exceeds panel dimensions";
d222 1
a222 1
	return "width too large for interlaced mode";
d232 1
a232 1
	return "mode requires too much memory bandwidth";
d234 1
a234 1
	return "unknown reason";
d236 1
a236 1
	return "internal error";
d238 1
a238 1
	return "unknown";
d256 40
a295 37
	DivFactor = max(1, cp->ClockDivFactor);
	MulFactor = max(1, cp->ClockMulFactor);
	if (scrp->progClock) {
	    if (cp->minClock) {
		if (cp->maxClock) {
		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
			"Clock range: %6.2f to %6.2f MHz\n",
			(double)cp->minClock / 1000.0,
			(double)cp->maxClock / 1000.0);
		} else {
		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
			"Minimum clock: %6.2f MHz\n",
			(double)cp->minClock / 1000.0);
		}
	    } else {
		if (cp->maxClock) {
		    xf86DrvMsg(scrp->scrnIndex, X_INFO,
			"Maximum clock: %6.2f MHz\n",
			(double)cp->maxClock / 1000.0);
		}
	    }
	} else if (DivFactor > 1 || MulFactor > 1) {
	    j = 0;
	    for (i = 0; i < scrp->numClocks; i++) {
		scaledClock = (scrp->clock[i] * DivFactor) / MulFactor;
		if (scaledClock >= cp->minClock && scaledClock <= cp->maxClock) {
		    if ((j % 8) == 0) {
			if (j > 0)
			    xf86ErrorF("\n");
			xf86DrvMsg(scrp->scrnIndex, X_INFO, "scaled clocks:");
		    }
		    xf86ErrorF(" %6.2f", (double)scaledClock / 1000.0);
		    j++;
		}
	    }
	    xf86ErrorF("\n");
	}
d303 4
a306 4
	    (p->Clock <= cp->maxClock) &&
	    (cp->interlaceAllowed || !(p->Flags & V_INTERLACE)) &&
	    (cp->doubleScanAllowed ||
	     ((p->VScan <= 1) && !(p->Flags & V_DBLSCAN))));
d317 3
a319 3
    for (cp = clockRanges; ; cp = cp->next)
	if (!cp || modeInClockRange(cp, p))
	    return cp;
a321 1

d327 3
a329 4
		      DisplayModePtr p,
		      DisplayModePtr modep,
		      ClockRangePtr clockRanges,
		      Bool allowDiv2)
d336 1
a336 1
    
d339 1
a339 1
	return p->status;
d346 37
a382 30
	/* Check clock is in range */
	cp = xf86FindClockRangeForMode(clockRanges, p);
	if (cp == NULL){
	    modep->type = p->type;
	    p->status = MODE_CLOCK_RANGE;
	    return MODE_CLOCK_RANGE;
	}
	DivFactor = cp->ClockDivFactor;
	MulFactor = cp->ClockMulFactor;
	if (!scrp->progClock) {
	    clockIndex = xf86GetNearestClock(scrp, p->Clock, allowDiv2,
					     cp->ClockDivFactor,
					     cp->ClockMulFactor, &extraFlags);
	    modep->Clock = (scrp->clock[clockIndex] * DivFactor)
		/ MulFactor;
	    modep->ClockIndex	= clockIndex;
	    modep->SynthClock	= scrp->clock[clockIndex];
	    if (extraFlags & V_CLKDIV2) {
		modep->Clock /= 2;
		modep->SynthClock /= 2;
	    }
	} else {
	    modep->Clock = p->Clock;
	    modep->ClockIndex = -1;
	    modep->SynthClock = (modep->Clock * MulFactor)
		/ DivFactor;
	}
	modep->PrivFlags = cp->PrivFlags;
    } else {
	if(!scrp->progClock) {
d384 18
a401 22
	    modep->ClockIndex = p->ClockIndex;
	    modep->SynthClock = p->SynthClock;
	} else {
	    modep->Clock = p->Clock;
	    modep->ClockIndex = -1;
	    modep->SynthClock = p->SynthClock;
	}
	modep->PrivFlags = p->PrivFlags;
    }
    modep->type            = p->type;
    modep->HDisplay        = p->HDisplay;
    modep->HSyncStart      = p->HSyncStart;
    modep->HSyncEnd        = p->HSyncEnd;
    modep->HTotal          = p->HTotal;
    modep->HSkew           = p->HSkew;
    modep->VDisplay        = p->VDisplay;
    modep->VSyncStart      = p->VSyncStart;
    modep->VSyncEnd        = p->VSyncEnd;
    modep->VTotal          = p->VTotal;
    modep->VScan           = p->VScan;
    modep->Flags           = p->Flags | extraFlags;
    modep->CrtcHDisplay    = p->CrtcHDisplay;
d403 6
a408 6
    modep->CrtcHSyncStart  = p->CrtcHSyncStart;
    modep->CrtcHSyncEnd    = p->CrtcHSyncEnd;
    modep->CrtcHBlankEnd   = p->CrtcHBlankEnd;
    modep->CrtcHTotal      = p->CrtcHTotal;
    modep->CrtcHSkew       = p->CrtcHSkew;
    modep->CrtcVDisplay    = p->CrtcVDisplay;
d410 10
a419 10
    modep->CrtcVSyncStart  = p->CrtcVSyncStart;
    modep->CrtcVSyncEnd    = p->CrtcVSyncEnd;
    modep->CrtcVBlankEnd   = p->CrtcVBlankEnd;
    modep->CrtcVTotal      = p->CrtcVTotal;
    modep->CrtcHAdjusted   = p->CrtcHAdjusted;
    modep->CrtcVAdjusted   = p->CrtcVAdjusted;
    modep->HSync           = p->HSync;
    modep->VRefresh        = p->VRefresh;
    modep->Private         = p->Private;
    modep->PrivSize        = p->PrivSize;
d422 1
a422 1
    
d456 1
a456 1
	       ClockRangePtr clockRanges, LookupModeFlags strategy)
d471 1
d473 7
a479 7
	M_T_BUILTIN | M_T_PREFERRED,
	M_T_BUILTIN,
	M_T_USERDEF | M_T_PREFERRED,
	M_T_USERDEF,
	M_T_DRIVER | M_T_PREFERRED,
	M_T_DRIVER,
	0
d487 3
a489 3
	(!scrp->progClock && scrp->numClocks == 0)) {
	ErrorF("xf86LookupMode: called with invalid scrnInfoRec\n");
	return MODE_ERROR;
d492 2
a493 2
	ErrorF("xf86LookupMode: called with invalid modep\n");
	return MODE_ERROR;
d496 3
a498 3
	/* DivFactor and MulFactor must be > 0 */
	cp->ClockDivFactor = max(1, cp->ClockDivFactor);
	cp->ClockMulFactor = max(1, cp->ClockMulFactor);
d503 9
a511 2
	int type = types[n];
	for (p = scrp->modePool; p != NULL; p = p->next) {
d513 126
a638 130
	    /* scan through the modes in the sort order above */
	    if ((p->type & type) != type)
		continue;

	    if (strcmp(p->name, modep->name) == 0) {

		/* Skip over previously rejected modes */
		if (p->status != MODE_OK) {
		    if (!found)
			status = p->status;
		    continue;
		}

		/* Skip over previously considered modes */
		if (p->prev)
		    continue;

		if (p->type & M_T_BUILTIN) {
		    return xf86HandleBuiltinMode(scrp, p,modep, clockRanges,
			    allowDiv2);
		}

		/* Check clock is in range */
		cp = xf86FindClockRangeForMode(clockRanges, p);
		if (cp == NULL) {
		    /*
		     * XXX Could do more here to provide a more detailed
		     * reason for not finding a mode.
		     */
		    p->status = MODE_CLOCK_RANGE;
		    if (!found)
			status = MODE_CLOCK_RANGE;
		    continue;
		}

		/*
		 * If programmable clock and strategy is not
		 * LOOKUP_BEST_REFRESH, the required mode has been found,
		 * otherwise record the refresh and continue looking.
		 */
		if (scrp->progClock) {
		    found = TRUE;
		    if (strategy != LOOKUP_BEST_REFRESH) {
			bestMode = p;
			DivFactor = cp->ClockDivFactor;
			MulFactor = cp->ClockMulFactor;
			ModePrivFlags = cp->PrivFlags;
			break;
		    }
		    refresh = xf86ModeVRefresh(p);
		    if (p->Flags & V_INTERLACE)
			refresh /= INTERLACE_REFRESH_WEIGHT;
		    if (refresh > bestRefresh) {
			bestMode = p;
			DivFactor = cp->ClockDivFactor;
			MulFactor = cp->ClockMulFactor;
			ModePrivFlags = cp->PrivFlags;
			bestRefresh = refresh;
		    }
		    continue;
		}

		/*
		 * Clock is in range, so if it is not a programmable clock, find
		 * a matching clock.
		 */

		i = xf86GetNearestClock(scrp, p->Clock, allowDiv2,
			cp->ClockDivFactor, cp->ClockMulFactor, &k);
		/*
		 * If the clock is too far from the requested clock, this
		 * mode is no good.
		 */
		if (k & V_CLKDIV2)
		    gap = abs((p->Clock * 2) -
			    ((scrp->clock[i] * cp->ClockDivFactor) /
				cp->ClockMulFactor));
		else
		    gap = abs(p->Clock -
			    ((scrp->clock[i] * cp->ClockDivFactor) /
				cp->ClockMulFactor));
		if (gap > minimumGap) {
		    p->status = MODE_NOCLOCK;
		    if (!found)
			status = MODE_NOCLOCK;
		    continue;
		}
		found = TRUE;

		if (strategy == LOOKUP_BEST_REFRESH) {
		    refresh = xf86ModeVRefresh(p);
		    if (p->Flags & V_INTERLACE)
			refresh /= INTERLACE_REFRESH_WEIGHT;
		    if (refresh > bestRefresh) {
			bestMode = p;
			DivFactor = cp->ClockDivFactor;
			MulFactor = cp->ClockMulFactor;
			ModePrivFlags = cp->PrivFlags;
			extraFlags = k;
			clockIndex = i;
			bestRefresh = refresh;
		    }
		    continue;
		}
		if (strategy == LOOKUP_CLOSEST_CLOCK) {
		    if (gap < minimumGap) {
			bestMode = p;
			DivFactor = cp->ClockDivFactor;
			MulFactor = cp->ClockMulFactor;
			ModePrivFlags = cp->PrivFlags;
			extraFlags = k;
			clockIndex = i;
			minimumGap = gap;
		    }
		    continue;
		}
		/*
		 * If strategy is neither LOOKUP_BEST_REFRESH or
		 * LOOKUP_CLOSEST_CLOCK the required mode has been found.
		 */
		bestMode = p;
		DivFactor = cp->ClockDivFactor;
		MulFactor = cp->ClockMulFactor;
		ModePrivFlags = cp->PrivFlags;
		extraFlags = k;
		clockIndex = i;
		break;
	    }
	}
	if (found) break;
d641 1
a641 1
	return status;
d645 45
a689 45
        modep->Clock		= bestMode->Clock;
	modep->ClockIndex	= -1;
	modep->SynthClock	= (modep->Clock * MulFactor) / DivFactor;
    } else {
	modep->Clock		= (scrp->clock[clockIndex] * DivFactor) /
				    MulFactor;
	modep->ClockIndex	= clockIndex;
	modep->SynthClock	= scrp->clock[clockIndex];
	if (extraFlags & V_CLKDIV2) {
	    modep->Clock /= 2;
	    modep->SynthClock /= 2;
	}
    }
    modep->type                 = bestMode->type;
    modep->PrivFlags		= ModePrivFlags;
    modep->HDisplay		= bestMode->HDisplay;
    modep->HSyncStart		= bestMode->HSyncStart;
    modep->HSyncEnd		= bestMode->HSyncEnd;
    modep->HTotal		= bestMode->HTotal;
    modep->HSkew		= bestMode->HSkew;
    modep->VDisplay		= bestMode->VDisplay;
    modep->VSyncStart		= bestMode->VSyncStart;
    modep->VSyncEnd		= bestMode->VSyncEnd;
    modep->VTotal		= bestMode->VTotal;
    modep->VScan		= bestMode->VScan;
    modep->Flags		= bestMode->Flags | extraFlags;
    modep->CrtcHDisplay		= bestMode->CrtcHDisplay;
    modep->CrtcHBlankStart	= bestMode->CrtcHBlankStart;
    modep->CrtcHSyncStart	= bestMode->CrtcHSyncStart;
    modep->CrtcHSyncEnd		= bestMode->CrtcHSyncEnd;
    modep->CrtcHBlankEnd	= bestMode->CrtcHBlankEnd;
    modep->CrtcHTotal		= bestMode->CrtcHTotal;
    modep->CrtcHSkew		= bestMode->CrtcHSkew;
    modep->CrtcVDisplay		= bestMode->CrtcVDisplay;
    modep->CrtcVBlankStart	= bestMode->CrtcVBlankStart;
    modep->CrtcVSyncStart	= bestMode->CrtcVSyncStart;
    modep->CrtcVSyncEnd		= bestMode->CrtcVSyncEnd;
    modep->CrtcVBlankEnd	= bestMode->CrtcVBlankEnd;
    modep->CrtcVTotal		= bestMode->CrtcVTotal;
    modep->CrtcHAdjusted	= bestMode->CrtcHAdjusted;
    modep->CrtcVAdjusted	= bestMode->CrtcVAdjusted;
    modep->HSync		= bestMode->HSync;
    modep->VRefresh		= bestMode->VRefresh;
    modep->Private		= bestMode->Private;
    modep->PrivSize		= bestMode->PrivSize;
d709 2
a710 2
	ErrorF("xf86CheckModeForMonitor: called with invalid parameters\n");
	return MODE_ERROR;
d714 1
a714 1
	   mode, mode->name, monitor, monitor->id);
d718 2
a719 2
	mode->HSyncStart >= mode->HSyncEnd || mode->HSyncEnd >= mode->HTotal)
	return MODE_H_ILLEGAL;
d722 2
a723 2
	mode->VSyncStart >= mode->VSyncEnd || mode->VSyncEnd >= mode->VTotal)
	return MODE_V_ILLEGAL;
d726 11
a736 10
	/* Check hsync against the allowed ranges */
	float hsync = xf86ModeHSync(mode);
	for (i = 0; i < monitor->nHsync; i++) 
	    if ((hsync > monitor->hsync[i].lo * (1.0 - SYNC_TOLERANCE)) &&
		(hsync < monitor->hsync[i].hi * (1.0 + SYNC_TOLERANCE)))
		break;
	
	/* Now see whether we ran out of sync ranges without finding a match */
	if (i == monitor->nHsync) 
	    return MODE_HSYNC;
d740 11
a750 10
	/* Check vrefresh against the allowed ranges */
	float vrefrsh = xf86ModeVRefresh(mode);
	for (i = 0; i < monitor->nVrefresh; i++)
	    if ((vrefrsh > monitor->vrefresh[i].lo * (1.0 - SYNC_TOLERANCE)) &&
		(vrefrsh < monitor->vrefresh[i].hi * (1.0 + SYNC_TOLERANCE)))
		break;

	/* Now see whether we ran out of refresh ranges without finding a match */
	if (i == monitor->nVrefresh)
	    return MODE_VSYNC;
d755 1
a755 1
	mode->CrtcVTotal = mode->VTotal |= 1;
d771 1
a771 1
	return MODE_CLOCK_HIGH;
d786 1
a786 2
    int bpp = scrp->fbFormat.bitsPerPixel,
	pad = scrp->fbFormat.scanlinePad;
d790 1
a790 1
	pad *= 4;		/* 4 planes */
d794 1
a794 1
	return FALSE;
d802 1
a802 1
     *	(lineWidth * (y - 1)) + lastWidth
d806 1
a806 1
     *	scrp->videoRam * (1024 * 8)
d818 2
a819 2
	(scrp->videoRam * ((1024 * 8) / BITMAP_SCANLINE_PAD)))
	return FALSE;
d850 3
a852 3
			      ClockRangePtr clockRanges,
			      LookupModeFlags strategy,
			      int maxPitch, int virtualX, int virtualY)
d858 1
a858 1
    
d861 3
a863 3
	ErrorF("xf86InitialCheckModeForDriver: "
		"called with invalid parameters\n");
	return MODE_ERROR;
d867 2
a868 1
	   scrp, mode, mode->name , clockRanges, strategy, maxPitch,  virtualX, virtualY);
d872 2
a873 2
	mode->HSyncStart >= mode->HSyncEnd || mode->HSyncEnd >= mode->HTotal)
	return MODE_H_ILLEGAL;
d876 2
a877 2
	mode->VSyncStart >= mode->VSyncEnd || mode->VSyncEnd >= mode->VTotal)
	return MODE_V_ILLEGAL;
d880 1
a880 1
				 mode->VDisplay))
d884 1
a884 1
	return MODE_BAD_WIDTH;
d887 1
a887 1
	return MODE_VIRTUAL_X;
d890 1
a890 1
	return MODE_VIRTUAL_Y;
d893 1
a893 1
	return MODE_BAD_HVALUE;
d896 1
a896 1
	return MODE_BAD_VVALUE;
d922 1
a922 1
     
a923 2
	
	xf86SetModeCrtc(mode, INTERLACE_HALVE_V);
d925 38
a962 35
	cp = xf86FindClockRangeForMode(clockRanges, mode);
	if (!cp)
	    return MODE_CLOCK_RANGE;

	if (cp->ClockMulFactor < 1)
	    cp->ClockMulFactor = 1;
	if (cp->ClockDivFactor < 1)
	    cp->ClockDivFactor = 1;
	
	/*
	 * XXX  The effect of clock dividers and multipliers on the monitor's
	 *      pixel clock needs to be verified.
	 */
	if (scrp->progClock) {
	    mode->SynthClock = mode->Clock;
	} else {
	    i = xf86GetNearestClock(scrp, mode->Clock, allowDiv2,
				    cp->ClockDivFactor, cp->ClockMulFactor,
				    &needDiv2);
	    mode->SynthClock = (scrp->clock[i] * cp->ClockDivFactor) /
		cp->ClockMulFactor;
	    if (needDiv2 & V_CLKDIV2)
		mode->SynthClock /= 2;
	}

	status = (*scrp->ValidMode)(scrp->scrnIndex, mode, FALSE,
				    MODECHECK_INITIAL);
	if (status != MODE_OK)
	    return status;

	if (mode->HSync <= 0.0)
	    mode->HSync = (float)mode->SynthClock / (float)mode->CrtcHTotal;
	if (mode->VRefresh <= 0.0)
	    mode->VRefresh = (mode->SynthClock * 1000.0)
		/ (mode->CrtcHTotal * mode->CrtcVTotal);
d964 1
a964 1
    
d1009 3
a1011 3
    if (scrp == NULL ||	(!scrp->progClock && scrp->numClocks == 0)) {
	ErrorF("xf86CheckModeForDriver: called with invalid scrnInfoRec\n");
	return MODE_ERROR;
d1014 2
a1015 2
	ErrorF("xf86CheckModeForDriver: called with invalid modep\n");
	return MODE_ERROR;
d1020 1
a1020 1
	return MODE_VIRTUAL_X;
d1023 1
a1023 1
	return MODE_VIRTUAL_Y;
d1026 1
a1026 1
	return MODE_BAD_HVALUE;
d1029 1
a1029 1
	return MODE_BAD_VVALUE;
d1032 3
a1034 3
	/* DivFactor and MulFactor must be > 0 */
	cp->ClockDivFactor = max(1, cp->ClockDivFactor);
	cp->ClockMulFactor = max(1, cp->ClockMulFactor);
d1038 55
a1092 53
	/* Check clock is in range */
	for (cp = scrp->clockRanges; cp != NULL; cp = cp->next) {
	    if (modeInClockRange(cp, mode))
	        break;
	}
	if (cp == NULL) {
	    return MODE_CLOCK_RANGE;
	}
	/*
	 * If programmable clock the required mode has been found
	 */
    	DivFactor = cp->ClockDivFactor;
	MulFactor = cp->ClockMulFactor;
	ModePrivFlags = cp->PrivFlags;
    } else {
	 status = MODE_CLOCK_RANGE;
	/* Check clock is in range */
	for (cp = scrp->clockRanges; cp != NULL; cp = cp->next) {
	    if (modeInClockRange(cp, mode)) {
		/*
	 	 * Clock is in range, so if it is not a programmable clock,
		 * find a matching clock.
		 */
    
		i = xf86GetNearestClock(scrp, mode->Clock, 0,
			   cp->ClockDivFactor, cp->ClockMulFactor, &k);
		/*
		 * If the clock is too far from the requested clock, this
		 * mode is no good.
		 */
		if (k & V_CLKDIV2)
		    gap = abs((mode->Clock * 2) -
			      ((scrp->clock[i] * cp->ClockDivFactor) /
			       cp->ClockMulFactor));
		else
		    gap = abs(mode->Clock -
			      ((scrp->clock[i] * cp->ClockDivFactor) /
			       cp->ClockMulFactor));
		if (gap > minimumGap) {
		    status = MODE_NOCLOCK;
		    continue;
		}
		
		DivFactor = cp->ClockDivFactor;
		MulFactor = cp->ClockMulFactor;
		ModePrivFlags = cp->PrivFlags;
		extraFlags = k;
		clockIndex = i;
		break;
	    }
	}
	if (cp == NULL)
	    return status;
d1097 11
a1107 10
	mode->ClockIndex	= -1;
	mode->SynthClock	= (mode->Clock * MulFactor) / DivFactor;
    } else {
	mode->Clock		= (scrp->clock[clockIndex] * DivFactor) / MulFactor;
	mode->ClockIndex	= clockIndex;
	mode->SynthClock	= scrp->clock[clockIndex];
	if (extraFlags & V_CLKDIV2) {
	    mode->Clock /= 2;
	    mode->SynthClock /= 2;
	}
d1109 1
a1109 1
    mode->PrivFlags		= ModePrivFlags;
d1114 1
a1114 1
static int 
d1123 2
a1124 1
    if (!mon) return 0;
d1128 14
a1141 14
	/* For 1.4, we might actually get native pixel format.  How novel. */
	if (PREFERRED_TIMING_MODE(DDC->features.msc)) {
		for (mode = modes; mode; mode = mode->next) {
		    if (mode->type & (M_T_DRIVER | M_T_PREFERRED)) {
			x = mode->HDisplay;
			y = mode->VDisplay;
			goto found;
		    }
		}
	}
	/*
	 * Even if we don't, we might get aspect ratio from extra CVT info
	 * or from the monitor size fields.  TODO.
	 */
d1149 4
a1152 4
	if (!mon->widthmm || !mon->heightmm)
	    aspect = 4.0/3.0;
	else
	    aspect = (float)mon->widthmm / (float)mon->heightmm;
d1157 13
a1169 12
	float mode_aspect, metaspect;
	if (!(mode->type & (M_T_DRIVER|M_T_USERDEF)))
	    continue;
	mode_aspect = (float)mode->HDisplay / (float)mode->VDisplay;
	metaspect = aspect / mode_aspect;
	/* 5% slop or so, since we only get size in centimeters */
	if (fabs(1.0 - metaspect) < 0.05) {
	    if ((mode->HDisplay > x) && (mode->VDisplay > y)) {
		x = mode->HDisplay;
		y = mode->VDisplay;
	    }
	}
d1173 3
a1175 3
	xf86DrvMsg(scrp->scrnIndex, X_WARNING,
		   "Unable to estimate virtual size\n");
	return 0;
d1178 1
a1178 1
found:
d1183 2
a1184 2
	       "Estimated virtual size for aspect ratio %.4f is %dx%d\n",
	       aspect, *vx, *vy);
d1195 1
a1195 2
    while ((o = m % n))
    {
d1210 6
a1215 8
scanLineWidth(
    unsigned int     xsize,         /* pixels */
    unsigned int     ysize,         /* pixels */
    unsigned int     width,         /* pixels */
    unsigned long    BankSize,      /* char's */
    PixmapFormatRec *pBankFormat,
    unsigned int     nWidthUnit     /* bits */
)
d1238 1
a1238 1
        return (int)width;
d1259 1
a1259 1
        return (int)width;
d1262 2
a1263 3
        (((unsigned long)(-1) >> 1) - minBitsPerScanline) / (ysize - 1);
    while (nBitsPerScanline <= maxBitsPerScanline)
    {
d1269 1
a1269 1
            return (int)width;
d1271 1
a1271 2
        for (BankBase = BankUnit;  ;  BankBase += nBitsPerBank)
        {
d1276 1
a1276 1
                return (int)width;
d1282 1
a1282 2
            if (x < minBitsPerScanline)
            {
d1288 1
a1288 2
                nBitsPerScanline +=
                    ((x + y - 1) / y) * nBitsPerScanlinePadUnit;
d1297 1
a1297 1
                return (int)width;
d1300 1
a1300 1
                (nBitsPerScanline - x)) * BankUnit;
d1357 4
a1360 4
		  char **modeNames, ClockRangePtr clockRanges,
		  int *linePitches, int minPitch, int maxPitch, int pitchInc,
		  int minHeight, int maxHeight, int virtualX, int virtualY,
		  int apertureSize, LookupModeFlags strategy)
d1367 1
a1367 1
    int modeSize;					/* in pixels */
d1379 5
a1383 6
    DebugF("xf86ValidateModes(%p, %p, %p, %p,\n\t\t  %p, %d, %d, %d, %d, %d, %d, %d, %d, 0x%x)\n",
	   scrp, availModes, modeNames, clockRanges,
	   linePitches, minPitch, maxPitch, pitchInc,
	   minHeight, maxHeight, virtualX, virtualY,
	   apertureSize, strategy
	   );
d1387 3
a1389 3
	(!scrp->progClock && scrp->numClocks == 0)) {
	ErrorF("xf86ValidateModes: called with invalid scrnInfoRec\n");
	return -1;
d1392 2
a1393 2
	ErrorF("xf86ValidateModes: called with invalid linePitches\n");
	return -1;
d1396 2
a1397 2
	ErrorF("xf86ValidateModes: called with invalid pitchInc\n");
	return -1;
d1400 2
a1401 2
	ErrorF("xf86ValidateModes: called with invalid virtual resolution\n");
	return -1;
d1409 4
a1412 3
	strategy &= ~LOOKUP_OPTIONAL_TOLERANCES;
    } else {
	const char *type = "";
d1415 16
a1430 14
	if (scrp->monitor->nHsync <= 0) {
	    if (numTimings > 0) {
		scrp->monitor->nHsync = numTimings;
		for (i = 0; i < numTimings; i++) {
		    scrp->monitor->hsync[i].lo = hsync[i].lo;
		    scrp->monitor->hsync[i].hi = hsync[i].hi;
		}
	    } else {
		scrp->monitor->hsync[0].lo = 31.5;
		scrp->monitor->hsync[0].hi = 48.0;
		scrp->monitor->nHsync = 1;
	    }
	    type = "default ";
	} else {
d1433 30
a1462 29
	for (i = 0; i < scrp->monitor->nHsync; i++) {
	    if (scrp->monitor->hsync[i].lo == scrp->monitor->hsync[i].hi)
	      xf86DrvMsg(scrp->scrnIndex, X_INFO,
			 "%s: Using %shsync value of %.2f kHz\n",
			 scrp->monitor->id, type,
			 scrp->monitor->hsync[i].lo);
	    else
	      xf86DrvMsg(scrp->scrnIndex, X_INFO,
			 "%s: Using %shsync range of %.2f-%.2f kHz\n",
			 scrp->monitor->id, type,
			 scrp->monitor->hsync[i].lo,
			 scrp->monitor->hsync[i].hi);
	}

	type = "";
	if (scrp->monitor->nVrefresh <= 0) {
	    if (numTimings > 0) {
		scrp->monitor->nVrefresh = numTimings;
		for (i = 0; i < numTimings; i++) {
		    scrp->monitor->vrefresh[i].lo = vrefresh[i].lo;
		    scrp->monitor->vrefresh[i].hi = vrefresh[i].hi;
		}
	    } else {
		scrp->monitor->vrefresh[0].lo = 50;
		scrp->monitor->vrefresh[0].hi = 70;
		scrp->monitor->nVrefresh = 1;
	    }
	    type = "default ";
	} else {
d1465 13
a1477 13
	for (i = 0; i < scrp->monitor->nVrefresh; i++) {
	    if (scrp->monitor->vrefresh[i].lo == scrp->monitor->vrefresh[i].hi)
	      xf86DrvMsg(scrp->scrnIndex, X_INFO,
			 "%s: Using %svrefresh value of %.2f Hz\n",
			 scrp->monitor->id, type,
			 scrp->monitor->vrefresh[i].lo);
	    else
	      xf86DrvMsg(scrp->scrnIndex, X_INFO,
			 "%s: Using %svrefresh range of %.2f-%.2f Hz\n",
			 scrp->monitor->id, type,
			 scrp->monitor->vrefresh[i].lo,
			 scrp->monitor->vrefresh[i].hi);
	}
d1480 1
a1480 1
	if (!scrp->monitor->maxPixClock && !specified) {
d1484 6
a1489 6
	if (scrp->monitor->maxPixClock) {
	    xf86DrvMsg(scrp->scrnIndex, X_INFO,
		       "%s: Using %smaximum pixel clock of %.2f MHz\n",
		       scrp->monitor->id, type,
		       (float)scrp->monitor->maxPixClock / 1000.0);
	}
d1497 1
a1497 1
	storeClockRanges = storeClockRanges->next;
d1500 5
a1504 5
	   	storeClockRanges = storeClockRanges->next) {
	storeClockRanges = xnfalloc(sizeof(ClockRange));
	if (scrp->clockRanges == NULL)
	    scrp->clockRanges = storeClockRanges;
	memcpy(storeClockRanges, cp, sizeof(ClockRange));
d1509 1
a1509 1
	BankFormat = &scrp->fbFormat;
d1511 1
a1511 1
	BankFormat = xf86GetPixFormat(scrp, 1);	/* >not< scrp->depth! */
d1514 1
a1514 1
        scrp->xInc = 8;		/* Suitable for VGA and others */
d1524 7
a1530 7
	minPitch = maxPitch = linePitches[0];
	for (i = 1; linePitches[i] > 0; i++) {
	    if (linePitches[i] > maxPitch)
		maxPitch = linePitches[i];
	    if (linePitches[i] < minPitch)
		minPitch = linePitches[i];
	}
d1539 56
a1594 54
	if (maxHeight > 0 && virtualY > maxHeight) {
	    xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		       "Virtual height (%d) is too large for the hardware "
		       "(max %d)\n", virtualY, maxHeight);
	    return -1;
	}

	if (minHeight > 0 && virtualY < minHeight) {
	    xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		       "Virtual height (%d) is too small for the hardware "
		       "(min %d)\n", virtualY, minHeight);
	    return -1;
	}

	virtualX = _VIRTUALX(virtualX);
	if (linePitches != NULL) {
	    for (i = 0; linePitches[i] != 0; i++) {
		if ((linePitches[i] >= virtualX) &&
		    (linePitches[i] ==
		     scanLineWidth(virtualX, virtualY, linePitches[i],
				   apertureSize, BankFormat, pitchInc))) {
		    linePitch = linePitches[i];
		    break;
		}
	    }
	} else {
	    linePitch = scanLineWidth(virtualX, virtualY, minPitch,
				      apertureSize, BankFormat, pitchInc);
	}

	if ((linePitch < minPitch) || (linePitch > maxPitch)) {
	    xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		       "Virtual width (%d) is too large for the hardware "
		       "(max %d)\n", virtualX, maxPitch);
	    return -1;
	}

	if (!xf86CheckModeSize(scrp, linePitch, virtualX, virtualY)) {
	    xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		      "Virtual size (%dx%d) (pitch %d) exceeds video memory\n",
		      virtualX, virtualY, linePitch);
	    return -1;
	}

	virtX = virtualX;
	virtY = virtualY;
	scrp->virtualFrom = X_CONFIG;
    } else if (!modeNames || !*modeNames) {
	/* No virtual size given in the config, try to infer */
	/* XXX this doesn't take m{in,ax}Pitch into account; oh well */
	inferred_virtual = inferVirtualSize(scrp, availModes, &virtX, &virtY);
	if (inferred_virtual)
	    linePitch = scanLineWidth(virtX, virtY, minPitch, apertureSize,
				      BankFormat, pitchInc);
d1607 40
a1646 37
	q = NULL;
	for (p = availModes; p != NULL; p = p->next) {
	    status = xf86InitialCheckModeForDriver(scrp, p, clockRanges,
						   strategy, maxPitch,
						   virtX, virtY);

	    if (status == MODE_OK) {
		status = xf86CheckModeForMonitor(p, scrp->monitor);
	    }
	    
	    if (status == MODE_OK) {
		new = xnfalloc(sizeof(DisplayModeRec));
		*new = *p;
		new->next = NULL;
		if (!q) {
		    scrp->modePool = new;
		} else {
		    q->next = new;
		}
		new->prev = NULL;
		q = new;
		q->name = xnfstrdup(p->name);
	        q->status = MODE_OK;
	    } else {
		printModeRejectMessage(scrp->scrnIndex, p, status);
	    }
	}

	if (scrp->modePool == NULL) {
	    xf86DrvMsg(scrp->scrnIndex, X_WARNING, "Mode pool is empty\n");
	    return 0;
	}
    } else {
	for (p = scrp->modePool; p != NULL; p = p->next) {
	    p->prev = NULL;
	    p->status = MODE_OK;
	}
d1653 1
a1653 1
	xf86DeleteMode(&scrp->modes, scrp->modes);
d1657 11
a1667 11
	for (i = 0; modeNames[i] != NULL; i++) {
	    userModes = TRUE;
	    new = xnfcalloc(1, sizeof(DisplayModeRec));
	    new->prev = last;
	    new->type = M_T_USERDEF;
	    new->name = xnfstrdup(modeNames[i]);
	    if (new->prev)
		new->prev->next = new;
	    *endp = last = new;
	    endp = &new->next;
	}
d1672 1
a1672 1
    if (!xf86Info.disableRandR	
d1674 1
a1674 1
	&& noPanoramiXExtension
d1676 2
a1677 2
	)
	validateAllDefaultModes = TRUE;
d1680 84
a1763 2
    for (p = scrp->modes; ; p = p->next) {
	Bool repeat;
d1765 92
a1856 174
	/*
	 * If the supplied mode names don't produce a valid mode, scan through
	 * unconsidered modePool members until one survives validation.  This
	 * is done in decreasing order by mode pixel area.
	 */

	if (p == NULL) {
	    if ((numModes > 0) && !validateAllDefaultModes)
		break;

	    validateAllDefaultModes = TRUE;
	    r = NULL;
	    modeSize = 0;
	    for (q = scrp->modePool;  q != NULL;  q = q->next) {
		if ((q->prev == NULL) && (q->status == MODE_OK)) {
		    /*
		     * Deal with the case where this mode wasn't considered
		     * because of a builtin mode of the same name.
		     */
		    for (p = scrp->modes; p != NULL; p = p->next) {
			if ((p->status != MODE_OK) &&
			    !strcmp(p->name, q->name))
			    break;
		    }

		    if (p != NULL)
			q->prev = p;
		    else {
			/*
			 * A quick check to not allow default modes with
			 * horizontal timing parameters that CRTs may have
			 * problems with.
			 */
			if (!scrp->monitor->reducedblanking &&
			    (q->type & M_T_DEFAULT) &&
			    ((double)q->HTotal / (double)q->HDisplay) < 1.15)
			    continue;

			if (modeSize < (q->HDisplay * q->VDisplay)) {
			    r = q;
			    modeSize = q->HDisplay * q->VDisplay;
			}
		    }
		}
	    }

	    if (r == NULL)
		break;

	    p = xnfcalloc(1, sizeof(DisplayModeRec));
	    p->prev = last;
	    p->name = xnfstrdup(r->name);
	    if (!userModes)
		p->type = M_T_USERDEF;
	    if (p->prev)
		p->prev->next = p;
	    *endp = last = p;
	    endp = &p->next;
	}

	repeat = FALSE;
    lookupNext:
	if (repeat && ((status = p->status) != MODE_OK))
	    printModeRejectMessage(scrp->scrnIndex, p, status);
	saveType = p->type;
	status = xf86LookupMode(scrp, p, clockRanges, strategy);
	if (repeat && status == MODE_NOMODE)
	    continue;
	if (status != MODE_OK)
	    printModeRejectMessage(scrp->scrnIndex, p, status);
	if (status == MODE_ERROR) {
	    ErrorF("xf86ValidateModes: "
		   "unexpected result from xf86LookupMode()\n");
	    return -1;
	}
	if (status != MODE_OK) {
	    if (p->status == MODE_OK)
		p->status = status;
	    continue;
	}
	p->type |= saveType;
	repeat = TRUE;

	newLinePitch = linePitch;
	newVirtX = virtX;
	newVirtY = virtY;

	/*
	 * Don't let non-user defined modes increase the virtual size
	 */
	if (!(p->type & M_T_USERDEF) && (numModes > 0)) {
	    if (p->HDisplay > virtX) {
		p->status = MODE_VIRTUAL_X;
		goto lookupNext;
	    }
	    if (p->VDisplay > virtY) {
		p->status = MODE_VIRTUAL_Y;
		goto lookupNext;
	    }
	}
	/*
	 * Adjust virtual width and height if the mode is too large for the
	 * current values and if they are not fixed.
	 */
	if (virtualX <= 0 && p->HDisplay > newVirtX)
	    newVirtX = _VIRTUALX(p->HDisplay);
	if (virtualY <= 0 && p->VDisplay > newVirtY) {
	    if (maxHeight > 0 && p->VDisplay > maxHeight) {
		p->status = MODE_VIRTUAL_Y;	/* ? */
		goto lookupNext;
	    }
	    newVirtY = p->VDisplay;
	}

	/*
	 * If virtual resolution is to be increased, revalidate it.
	 */
	if ((virtX != newVirtX) || (virtY != newVirtY)) {
	    if (linePitches != NULL) {
		newLinePitch = -1;
		for (i = 0; linePitches[i] != 0; i++) {
		    if ((linePitches[i] >= newVirtX) &&
			(linePitches[i] >= linePitch) &&
			(linePitches[i] ==
			 scanLineWidth(newVirtX, newVirtY, linePitches[i],
				       apertureSize, BankFormat, pitchInc))) {
			newLinePitch = linePitches[i];
			break;
		    }
		}
	    } else {
		if (linePitch < minPitch)
		    linePitch = minPitch;
		newLinePitch = scanLineWidth(newVirtX, newVirtY, linePitch,
					     apertureSize, BankFormat,
					     pitchInc);
	    }
	    if ((newLinePitch < minPitch) || (newLinePitch > maxPitch)) {
		p->status = MODE_BAD_WIDTH;
		goto lookupNext;
	    }

	    /*
	     * Check that the pixel area required by the new virtual height
	     * and line pitch isn't too large.
	     */
	    if (!xf86CheckModeSize(scrp, newLinePitch, newVirtX, newVirtY)) {
		p->status = MODE_MEM_VIRT;
		goto lookupNext;
	    }
	}

	if (scrp->ValidMode) {
	    /*
	     * Give the driver a final say, passing it the proposed virtual
	     * geometry.
	     */
	    scrp->virtualX = newVirtX;
	    scrp->virtualY = newVirtY;
	    scrp->displayWidth = newLinePitch;
	    p->status = (scrp->ValidMode)(scrp->scrnIndex, p, FALSE,
					  MODECHECK_FINAL);

	    if (p->status != MODE_OK) {
	        goto lookupNext;
	    }
	}

	/* Mode has passed all the tests */
	virtX = newVirtX;
	virtY = newVirtY;
	linePitch = newLinePitch;
	p->status = MODE_OK;
	numModes++;
d1865 75
a1939 72
	int vx = 0, vy = 0;
	for (p = scrp->modes; p; p = p->next) {
	    if (p->HDisplay > vx && p->VDisplay > vy) {
		vx = p->HDisplay;
		vy = p->VDisplay;
	    }
	}
	if (vx < virtX || vy < virtY) {
	    const int types[] = {
		M_T_BUILTIN | M_T_PREFERRED,
		M_T_BUILTIN,
		M_T_DRIVER | M_T_PREFERRED,
		M_T_DRIVER,
		0
	    };
	    const int ntypes = sizeof(types) / sizeof(int);
	    int n;

	    /* 
	     * We did not find the estimated virtual size. So now we want to 
	     * find the largest mode available, but we want to search in the
	     * modes in the order of "types" listed above.
	     */
	    for (n = 0; n < ntypes; n++) {
		int type = types[n];

		vx = 0; vy = 0;
		for (p = scrp->modes; p; p = p->next) {
		    /* scan through the modes in the sort order above */
		    if ((p->type & type) != type)
			continue;
		    if (p->HDisplay > vx && p->VDisplay > vy) {
			vx = p->HDisplay;
			vy = p->VDisplay;
		    }
		}
		if (vx && vy)
		    /* Found one */
		    break;
	    }
	    xf86DrvMsg(scrp->scrnIndex, X_WARNING,
		       "Shrinking virtual size estimate from %dx%d to %dx%d\n",
		       virtX, virtY, vx, vy);
	    virtX = _VIRTUALX(vx);
	    virtY = vy;
	    for (p = scrp->modes; p; p = p->next) {
		if (numModes > 0) {
		    if (p->HDisplay > virtX)
			p->status = MODE_VIRTUAL_X;
		    if (p->VDisplay > virtY)
			p->status = MODE_VIRTUAL_Y;
		    if (p->status != MODE_OK) {
			numModes--;
			printModeRejectMessage(scrp->scrnIndex, p, p->status);
		    }
		}
	    }
	    if (linePitches != NULL) {
		for (i = 0; linePitches[i] != 0; i++) {
		    if ((linePitches[i] >= virtX) &&
			(linePitches[i] ==
			scanLineWidth(virtX, virtY, linePitches[i],
				      apertureSize, BankFormat, pitchInc))) {
			linePitch = linePitches[i];
			break;
		    }
		}
	    } else {
		linePitch = scanLineWidth(virtX, virtY, minPitch,
					  apertureSize, BankFormat, pitchInc);
	    }
	}
d1943 1
a1943 1
    
d1949 2
a1950 2
	return 0;
    
d1954 1
a1954 1
	p = p->next;
d1960 4
a1963 4
	xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		   "Virtual height (%d) is too small for the hardware "
		   "(min %d)\n", virtY, minHeight);
	return -1;
d1981 1
a1981 1
 
d1983 1
a1983 1
xf86DeleteMode(DisplayModePtr *modeList, DisplayModePtr mode)
d1987 1
a1987 1
	return;
d1991 1
a1991 1
	*modeList = mode->next;
d1995 7
a2001 6
	*modeList = NULL;
    } else {
	if ((mode->prev != NULL) && (mode->prev->next == mode))
	    mode->prev->next = mode->next;
	if ((mode->next != NULL) && (mode->next->prev == mode))
	    mode->next->prev = mode->prev;
d2022 1
a2022 1
	return;
d2025 7
a2031 7
	if (!(first = scrp->modes))
	    return;
	n = p->next;
	if (p->status != MODE_OK) {
	    xf86DeleteMode(&(scrp->modes), p);
	}
	p = n;
d2036 8
a2043 8
	/*
	 * A modePool mode's prev field is used to hold a pointer to the
	 * member of the scrp->modes list for which a match was considered.
	 * Clear that pointer first, otherwise xf86DeleteMode might get 
	 * confused 
	 */
	scrp->modePool->prev = NULL;
	xf86DeleteMode(&scrp->modePool, scrp->modePool);
a2046 1

d2067 1
a2067 1
	return;
d2070 9
a2078 9
	xf86SetModeCrtc(p, adjustFlags);
	DebugF("%sMode %s: %d (%d) %d %d (%d) %d %d (%d) %d %d (%d) %d\n",
	       (p->type & M_T_DEFAULT) ? "Default " : "",
	       p->name, p->CrtcHDisplay, p->CrtcHBlankStart,
	       p->CrtcHSyncStart, p->CrtcHSyncEnd, p->CrtcHBlankEnd,
	       p->CrtcHTotal, p->CrtcVDisplay, p->CrtcVBlankStart,
	       p->CrtcVSyncStart, p->CrtcVSyncEnd, p->CrtcVBlankEnd,
	       p->CrtcVTotal);
	p = p->next;
d2087 1
a2087 1
    char *desc, *desc2, *prefix, *uprefix;
d2090 1
a2090 1
	return;
d2093 3
a2095 3
	       "(pitch %d)\n", scrp->virtualX, scrp->virtualY,
	       scrp->displayWidth);
    
d2098 1
a2098 1
	return;
d2101 49
a2149 47
	desc = desc2 = "";
	hsync = xf86ModeHSync(p);
	refresh = xf86ModeVRefresh(p);
	if (p->Flags & V_INTERLACE) {
	    desc = " (I)";
	}
	if (p->Flags & V_DBLSCAN) {
	    desc = " (D)";
	}
	if (p->VScan > 1) {
	    desc2 = " (VScan)";
	}
	if (p->type & M_T_BUILTIN)
	    prefix = "Built-in mode";
	else if (p->type & M_T_DEFAULT)
	    prefix = "Default mode";
	else if (p->type & M_T_DRIVER)
	    prefix = "Driver mode";
	else
	    prefix = "Mode";
	if (p->type & M_T_USERDEF)
	    uprefix = "*";
	else
	    uprefix = " ";
	if (hsync == 0 || refresh == 0) {
	    if (p->name)
		xf86DrvMsg(scrp->scrnIndex, X_CONFIG,
			   "%s%s \"%s\"\n", uprefix, prefix, p->name);
	    else
		xf86DrvMsg(scrp->scrnIndex, X_PROBED,
			   "%s%s %dx%d (unnamed)\n",
			   uprefix, prefix, p->HDisplay, p->VDisplay);
	} else if (p->Clock == p->SynthClock) {
	    xf86DrvMsg(scrp->scrnIndex, X_CONFIG,
			"%s%s \"%s\": %.1f MHz, %.1f kHz, %.1f Hz%s%s\n",
			uprefix, prefix, p->name, p->Clock / 1000.0,
			hsync, refresh, desc, desc2);
	} else {
	    xf86DrvMsg(scrp->scrnIndex, X_CONFIG,
			"%s%s \"%s\": %.1f MHz (scaled from %.1f MHz), "
			"%.1f kHz, %.1f Hz%s%s\n",
			uprefix, prefix, p->name, p->Clock / 1000.0,
			p->SynthClock / 1000.0, hsync, refresh, desc, desc2);
	}
	if (hsync != 0 && refresh != 0)
	    xf86PrintModeline(scrp->scrnIndex,p);
	p = p->next;
@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d1405 1
d1416 1
a1416 1
		scrp->monitor->hsync[0].hi = 37.9;
d1420 3
a1422 1
	}
d1451 3
a1453 1
	}
d1467 6
d1475 2
a1476 2
		       "%s: Using maximum pixel clock of %.2f MHz\n",
		       scrp->monitor->id,
d1646 1
a1646 2
	    new->name = xnfalloc(strlen(modeNames[i]) + 1);
	    strcpy(new->name, modeNames[i]);
d1718 1
a1718 1
	    p->name = xnfalloc(strlen(r->name) + 1);
a1720 1
	    strcpy(p->name, r->name);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a1833 2
#undef _VIRTUALX

d1848 32
d1883 1
a1883 1
	    virtX = vx;
d1885 26
a1910 2
	    linePitch = scanLineWidth(vx, vy, minPitch, apertureSize,
				      BankFormat, pitchInc);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d29 46
a90 1
#include "mibank.h"
d1174 125
d1485 1
a1485 1
    /* Determine which pixmap format to pass to miScanLineWidth() */
d1536 2
a1537 2
		     miScanLineWidth(virtualX, virtualY, linePitches[i],
				     apertureSize, BankFormat, pitchInc))) {
d1543 2
a1544 2
	    linePitch = miScanLineWidth(virtualX, virtualY, minPitch,
					apertureSize, BankFormat, pitchInc);
d1569 2
a1570 2
	    linePitch = miScanLineWidth(virtX, virtY, minPitch, apertureSize,
					BankFormat, pitchInc);
d1782 2
a1783 2
			 miScanLineWidth(newVirtX, newVirtY, linePitches[i],
					 apertureSize, BankFormat, pitchInc))) {
d1791 3
a1793 3
		newLinePitch = miScanLineWidth(newVirtX, newVirtY, linePitch,
					       apertureSize, BankFormat,
					       pitchInc);
d1855 2
a1856 2
	    linePitch = miScanLineWidth(vx, vy, minPitch, apertureSize,
					BankFormat, pitchInc);
d1921 2
a1922 2
    xfree(mode->name);
    xfree(mode);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d74 1
a74 1
_X_EXPORT int
d113 1
a113 1
_X_EXPORT const char *
d202 1
a202 1
_X_EXPORT void
d252 9
d271 1
a271 6
	if (!cp ||
	    ((p->Clock >= cp->minClock) &&
	     (p->Clock <= cp->maxClock) &&
	     (cp->interlaceAllowed || !(p->Flags & V_INTERLACE)) &&
	     (cp->doubleScanAllowed ||
	      ((p->VScan <= 1) && !(p->Flags & V_DBLSCAN)))))
d406 1
a406 1
_X_EXPORT ModeStatus
d650 1
a650 1
_X_EXPORT ModeStatus
d661 1
a661 2
#ifdef DEBUG
    ErrorF("xf86CheckModeForMonitor(%p %s, %p %s)\n",
a662 1
#endif
d795 1
a795 1
_X_EXPORT ModeStatus
d813 1
a813 2
#ifdef DEBUG
    ErrorF("xf86InitialCheckModeForDriver(%p, %p %s, %p, 0x%x, %d, %d, %d)\n",
a814 1
#endif
d941 1
a941 1
_X_EXPORT ModeStatus
d944 1
a944 1
    ClockRangesPtr cp;
a950 1
    Bool allowDiv2;
d985 1
a985 5
	    if ((cp->minClock <= mode->Clock) &&
		(cp->maxClock >= mode->Clock) &&
		(cp->interlaceAllowed || !(mode->Flags & V_INTERLACE)) &&
		(cp->doubleScanAllowed ||
		 ((!(mode->Flags & V_DBLSCAN)) && (mode->VScan <= 1))))
d1001 1
a1001 6
	    if ((cp->minClock <= mode->Clock) &&
		(cp->maxClock >= mode->Clock) &&
		(cp->interlaceAllowed || !(mode->Flags & V_INTERLACE)) &&
		(cp->doubleScanAllowed ||
		 ((!(mode->Flags & V_DBLSCAN)) && (mode->VScan <= 1)))) {

d1007 1
a1007 2
		allowDiv2 = (cp->strategy & LOOKUP_CLKDIV2) != 0;
		i = xf86GetNearestClock(scrp, mode->Clock, allowDiv2,
d1177 1
a1177 1
_X_EXPORT int
d1195 1
a1195 2
    ClockRangesPtr storeClockRanges;
    double targetRefresh = 0.0;
d1201 1
a1201 2
#ifdef DEBUG
    ErrorF("xf86ValidateModes(%p, %p, %p, %p,\n\t\t  %p, %d, %d, %d, %d, %d, %d, %d, %d, 0x%x)\n",
a1206 1
#endif
d1301 1
a1301 2
     * Store the clockRanges for later use by the VidMode extension. Must
     * also store the strategy, since ClockDiv2 flag is stored there.
d1309 1
a1309 1
	storeClockRanges = xnfalloc(sizeof(ClockRanges));
a1312 1
	storeClockRanges->strategy = strategy;
a1452 20
     * Go through the mode pool and see if any modes match the target
     * refresh rate, (if specified).  If no modes match, abandon the target.
     */
    targetRefresh = xf86SetRealOption(scrp->options,
				      "TargetRefresh", 0.0);
    if (targetRefresh > 0.0) {
	for (p = scrp->modePool; p != NULL; p = p->next) {
	    if (xf86ModeVRefresh(p) > targetRefresh * (1.0 - SYNC_TOLERANCE))
		break;
	}
	if (!p)
	    targetRefresh = 0.0;
    }

    if (targetRefresh > 0.0) {
	xf86DrvMsg(scrp->scrnIndex, X_CONFIG,
		   "Target refresh rate is %.1f Hz\n", targetRefresh);
    }

    /*
a1524 8
			/*
			 * If there is a target refresh rate, skip modes that
			 * don't match up.
			 */
			if (xf86ModeVRefresh(q) <
			    (1.0 - SYNC_TOLERANCE) * targetRefresh)
			    continue;

d1730 1
a1730 1
_X_EXPORT void
d1762 1
a1762 1
_X_EXPORT void
d1802 1
a1802 1
_X_EXPORT void
d1819 1
a1819 2
#ifdef DEBUG
	ErrorF("%sMode %s: %d (%d) %d %d (%d) %d %d (%d) %d %d (%d) %d\n",
a1825 1
#endif
d1830 1
a1830 48

#if 0
static void
add(char **p, char *new)
{
    *p = xnfrealloc(*p, strlen(*p) + strlen(new) + 2);
    strcat(*p, " ");
    strcat(*p, new);
}

_X_EXPORT void
xf86PrintModeline(int scrnIndex,DisplayModePtr mode)
{
    char tmp[256];
    char *flags = xnfcalloc(1, 1);

    if (mode->HSkew) { 
	snprintf(tmp, 256, "hskew %i", mode->HSkew); 
	add(&flags, tmp);
    }
    if (mode->VScan) { 
	snprintf(tmp, 256, "vscan %i", mode->VScan); 
	add(&flags, tmp);
    }
    if (mode->Flags & V_INTERLACE) add(&flags, "interlace");
    if (mode->Flags & V_CSYNC) add(&flags, "composite");
    if (mode->Flags & V_DBLSCAN) add(&flags, "doublescan");
    if (mode->Flags & V_BCAST) add(&flags, "bcast");
    if (mode->Flags & V_PHSYNC) add(&flags, "+hsync");
    if (mode->Flags & V_NHSYNC) add(&flags, "-hsync");
    if (mode->Flags & V_PVSYNC) add(&flags, "+vsync");
    if (mode->Flags & V_NVSYNC) add(&flags, "-vsync");
    if (mode->Flags & V_PCSYNC) add(&flags, "+csync");
    if (mode->Flags & V_NCSYNC) add(&flags, "-csync");
#if 0
    if (mode->Flags & V_CLKDIV2) add(&flags, "vclk/2");
#endif
    xf86DrvMsgVerb(scrnIndex, X_INFO, 3,
		   "Modeline \"%s\"  %6.2f  %i %i %i %i  %i %i %i %i%s\n",
		   mode->name, mode->Clock/1000., mode->HDisplay,
		   mode->HSyncStart, mode->HSyncEnd, mode->HTotal,
		   mode->VDisplay, mode->VSyncStart, mode->VSyncEnd,
		   mode->VTotal, flags);
    xfree(flags);
}
#endif

_X_EXPORT void
a1897 26

#if 0
/**
 * Adds the new mode into the mode list, and returns the new list
 *
 * \param modes doubly-linked mode list.
 */
_X_EXPORT DisplayModePtr
xf86ModesAdd(DisplayModePtr modes, DisplayModePtr new)
{
    if (modes == NULL)
	return new;

    if (new) {
        DisplayModePtr mode = modes;

        while (mode->next)
            mode = mode->next;

        mode->next = new;
        new->prev = mode;
    }

    return modes;
}
#endif
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d42 1
d709 3
a711 10
    /* Is the horizontal blanking a bit lowish? */
    if (((mode->HDisplay * 5 / 4) & ~0x07) > mode->HTotal) {
        /* is this a cvt -r mode, and only a cvt -r mode? */
        if (((mode->HTotal - mode->HDisplay) == 160) &&
            ((mode->HSyncEnd - mode->HDisplay) == 80) &&
            ((mode->HSyncEnd - mode->HSyncStart) == 32) &&
            ((mode->VSyncStart - mode->VDisplay) == 3)) {
            if (!monitor->reducedblanking && !(mode->type & M_T_DRIVER))
                return MODE_NO_REDUCED;
        }
@


1.1
log
@Initial revision
@
text
@d186 2
a372 32
static double
ModeHSync(DisplayModePtr mode)
{
    double hsync = 0.0;
    
    if (mode->HSync > 0.0)
	    hsync = mode->HSync;
    else if (mode->HTotal > 0)
	    hsync = (float)mode->Clock / (float)mode->HTotal;

    return hsync;
}

static double
ModeVRefresh(DisplayModePtr mode)
{
    double refresh = 0.0;

    if (mode->VRefresh > 0.0)
	refresh = mode->VRefresh;
    else if (mode->HTotal > 0 && mode->VTotal > 0) {
	refresh = mode->Clock * 1000.0 / mode->HTotal / mode->VTotal;
	if (mode->Flags & V_INTERLACE)
	    refresh *= 2.0;
	if (mode->Flags & V_DBLSCAN)
	    refresh /= 2.0;
	if (mode->VScan > 1)
	    refresh /= (float)(mode->VScan);
    }
    return refresh;
}

a416 1
    Bool haveBuiltin;
d501 1
a501 1
		    refresh = ModeVRefresh(p);
d542 1
a542 1
		    refresh = ModeVRefresh(p);
a638 89

/*
 * xf86SetModeCrtc
 *
 * Initialises the Crtc parameters for a mode.  The initialisation includes
 * adjustments for interlaced and double scan modes.
 */
static void
xf86SetModeCrtc(DisplayModePtr p, int adjustFlags)
{
    if ((p == NULL) || ((p->type & M_T_CRTC_C) == M_T_BUILTIN))
	return;

    p->CrtcHDisplay             = p->HDisplay;
    p->CrtcHSyncStart           = p->HSyncStart;
    p->CrtcHSyncEnd             = p->HSyncEnd;
    p->CrtcHTotal               = p->HTotal;
    p->CrtcHSkew                = p->HSkew;
    p->CrtcVDisplay             = p->VDisplay;
    p->CrtcVSyncStart           = p->VSyncStart;
    p->CrtcVSyncEnd             = p->VSyncEnd;
    p->CrtcVTotal               = p->VTotal;
    if (p->Flags & V_INTERLACE) {
	if (adjustFlags & INTERLACE_HALVE_V) {
	    p->CrtcVDisplay         /= 2;
	    p->CrtcVSyncStart       /= 2;
	    p->CrtcVSyncEnd         /= 2;
	    p->CrtcVTotal           /= 2;
	}
	/* Force interlaced modes to have an odd VTotal */
	/* maybe we should only do this when INTERLACE_HALVE_V is set? */
	p->CrtcVTotal |= 1;
    }

    if (p->Flags & V_DBLSCAN) {
        p->CrtcVDisplay         *= 2;
        p->CrtcVSyncStart       *= 2;
        p->CrtcVSyncEnd         *= 2;
        p->CrtcVTotal           *= 2;
    }
    if (p->VScan > 1) {
        p->CrtcVDisplay         *= p->VScan;
        p->CrtcVSyncStart       *= p->VScan;
        p->CrtcVSyncEnd         *= p->VScan;
        p->CrtcVTotal           *= p->VScan;
    }
    p->CrtcHAdjusted = FALSE;
    p->CrtcVAdjusted = FALSE;

    /*
     * XXX
     *
     * The following is taken from VGA, but applies to other cores as well.
     */
    p->CrtcVBlankStart = min(p->CrtcVSyncStart, p->CrtcVDisplay);
    p->CrtcVBlankEnd = max(p->CrtcVSyncEnd, p->CrtcVTotal);
    if ((p->CrtcVBlankEnd - p->CrtcVBlankStart) >= 127) {
        /* 
         * V Blanking size must be < 127.
         * Moving blank start forward is safer than moving blank end
         * back, since monitors clamp just AFTER the sync pulse (or in
         * the sync pulse), but never before.
         */
        p->CrtcVBlankStart = p->CrtcVBlankEnd - 127;
	/*
	 * If VBlankStart is now > VSyncStart move VBlankStart
	 * to VSyncStart using the maximum width that fits into
	 * VTotal.
	 */
	if (p->CrtcVBlankStart > p->CrtcVSyncStart) {
	    p->CrtcVBlankStart = p->CrtcVSyncStart;
	    p->CrtcVBlankEnd = min(p->CrtcHBlankStart + 127, p->CrtcVTotal);
	}
    }
    p->CrtcHBlankStart = min(p->CrtcHSyncStart, p->CrtcHDisplay);
    p->CrtcHBlankEnd = max(p->CrtcHSyncEnd, p->CrtcHTotal);

    if ((p->CrtcHBlankEnd - p->CrtcHBlankStart) >= 63 * 8) {
        /*
         * H Blanking size must be < 63*8. Same remark as above.
         */
        p->CrtcHBlankStart = p->CrtcHBlankEnd - 63 * 8;
	if (p->CrtcHBlankStart > p->CrtcHSyncStart) {
	    p->CrtcHBlankStart = p->CrtcHSyncStart;
	    p->CrtcHBlankEnd = min(p->CrtcHBlankStart + 63 * 8, p->CrtcHTotal);
	}
    }
}

d672 1
a672 1
	float hsync = ModeHSync(mode);
d685 1
a685 1
	float vrefrsh = ModeVRefresh(mode);
d916 2
a917 2
    mode->HSync = ModeHSync(mode);
    mode->VRefresh = ModeVRefresh(mode);
d1078 1
d1083 18
d1103 2
a1104 3
     * technically this triggers if _either_ is zero, which is not what EDID
     * says, but if only one is zero this is best effort.  also we don't
     * know that all projectors are 4:3, but we certainly suspect it.
d1106 6
a1111 4
    if (!mon->widthmm || !mon->heightmm)
	aspect = 4.0/3.0;
    else
	aspect = (float)mon->widthmm / (float)mon->heightmm;
d1135 1
d1312 6
d1482 1
a1482 1
	    if (ModeVRefresh(p) > targetRefresh * (1.0 - SYNC_TOLERANCE))
d1571 1
a1571 1
			if (ModeVRefresh(q) <
d1735 1
a1735 1
	    linePitch = miScanLineWidth(vx, vy, linePitch, apertureSize,
d1883 1
d1892 2
a1893 2
static void
PrintModeline(int scrnIndex,DisplayModePtr mode)
d1927 1
d1949 2
a1950 2
	hsync = ModeHSync(p);
	refresh = ModeVRefresh(p);
d1993 1
a1993 1
	    PrintModeline(scrp->scrnIndex,p);
d1997 26
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d371 2
a372 4
#if 0
/** Calculates the horizontal sync rate of a mode */
_X_EXPORT double
xf86ModeHSync(DisplayModePtr mode)
d384 2
a385 3
/** Calculates the vertical refresh rate of a mode */
_X_EXPORT double
xf86ModeVRefresh(DisplayModePtr mode)
a402 11
/** Sets a default mode name of <width>x<height> on a mode. */
_X_EXPORT void
xf86SetModeDefaultName(DisplayModePtr mode)
{
    if (mode->name != NULL)
	xfree(mode->name);

    mode->name = XNFprintf("%dx%d", mode->HDisplay, mode->VDisplay);
}
#endif

d447 1
d532 1
a532 1
		    refresh = xf86ModeVRefresh(p);
d573 1
a573 1
		    refresh = xf86ModeVRefresh(p);
a670 1
#if 0
d677 1
a677 1
_X_EXPORT void
d716 8
d726 18
d747 8
a754 51
    p->CrtcHAdjusted = FALSE;
    p->CrtcVAdjusted = FALSE;
}
#endif

#if 0
/**
 * Allocates and returns a copy of pMode, including pointers within pMode.
 */
_X_EXPORT DisplayModePtr
xf86DuplicateMode(DisplayModePtr pMode)
{
    DisplayModePtr pNew;

    pNew = xnfalloc(sizeof(DisplayModeRec));
    *pNew = *pMode;
    pNew->next = NULL;
    pNew->prev = NULL;
    if (pNew->name == NULL) {
	xf86SetModeDefaultName(pMode);
    } else {
	pNew->name = xnfstrdup(pMode->name);
    }

    return pNew;
}

/**
 * Duplicates every mode in the given list and returns a pointer to the first
 * mode.
 *
 * \param modeList doubly-linked mode list
 */
_X_EXPORT DisplayModePtr
xf86DuplicateModes(ScrnInfoPtr pScrn, DisplayModePtr modeList)
{
    DisplayModePtr first = NULL, last = NULL;
    DisplayModePtr mode;

    for (mode = modeList; mode != NULL; mode = mode->next) {
	DisplayModePtr new;

	new = xf86DuplicateMode(mode);

	/* Insert pNew into modeList */
	if (last) {
	    last->next = new;
	    new->prev = last;
	} else {
	    first = new;
	    new->prev = NULL;
a755 2
	new->next = NULL;
	last = new;
a756 30

    return first;
}

/**
 * Returns true if the given modes should program to the same timings.
 *
 * This doesn't use Crtc values, as it might be used on ModeRecs without the
 * Crtc values set.  So, it's assumed that the other numbers are enough.
 */
_X_EXPORT Bool
xf86ModesEqual(DisplayModePtr pMode1, DisplayModePtr pMode2)
{
     if (pMode1->Clock == pMode2->Clock &&
	 pMode1->HDisplay == pMode2->HDisplay &&
	 pMode1->HSyncStart == pMode2->HSyncStart &&
	 pMode1->HSyncEnd == pMode2->HSyncEnd &&
	 pMode1->HTotal == pMode2->HTotal &&
	 pMode1->HSkew == pMode2->HSkew &&
	 pMode1->VDisplay == pMode2->VDisplay &&
	 pMode1->VSyncStart == pMode2->VSyncStart &&
	 pMode1->VSyncEnd == pMode2->VSyncEnd &&
	 pMode1->VTotal == pMode2->VTotal &&
	 pMode1->VScan == pMode2->VScan &&
	 pMode1->Flags == pMode2->Flags)
     {
	return TRUE;
     } else {
	return FALSE;
     }
a757 1
#endif
d792 1
a792 1
	float hsync = xf86ModeHSync(mode);
d805 1
a805 1
	float vrefrsh = xf86ModeVRefresh(mode);
d1036 2
a1037 2
    mode->HSync = xf86ModeHSync(mode);
    mode->VRefresh = xf86ModeVRefresh(mode);
a1410 6
	if (scrp->monitor->maxPixClock) {
	    xf86DrvMsg(scrp->scrnIndex, X_INFO,
		       "%s: Using maximum pixel clock of %.2f MHz\n",
		       scrp->monitor->id,
		       (float)scrp->monitor->maxPixClock / 1000.0);
	}
d1575 1
a1575 1
	    if (xf86ModeVRefresh(p) > targetRefresh * (1.0 - SYNC_TOLERANCE))
d1664 1
a1664 1
			if (xf86ModeVRefresh(q) <
d1828 1
a1828 1
	    linePitch = miScanLineWidth(vx, vy, minPitch, apertureSize,
a1975 1
#if 0
d1984 2
a1985 2
_X_EXPORT void
xf86PrintModeline(int scrnIndex,DisplayModePtr mode)
a2018 1
#endif
d2040 2
a2041 2
	hsync = xf86ModeHSync(p);
	refresh = xf86ModeVRefresh(p);
d2084 1
a2084 1
	    xf86PrintModeline(scrp->scrnIndex,p);
a2087 26

#if 0
/**
 * Adds the new mode into the mode list, and returns the new list
 *
 * \param modes doubly-linked mode list.
 */
_X_EXPORT DisplayModePtr
xf86ModesAdd(DisplayModePtr modes, DisplayModePtr new)
{
    if (modes == NULL)
	return new;

    if (new) {
        DisplayModePtr mode = modes;

        while (mode->next)
            mode = mode->next;

        mode->next = new;
        new->prev = mode;
    }

    return modes;
}
#endif
@

