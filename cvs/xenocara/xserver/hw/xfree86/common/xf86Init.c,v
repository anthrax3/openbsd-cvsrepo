head	1.25;
access;
symbols
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.2
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.2
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.08.09.18.59.52;	author matthieu;	state Exp;
branches;
next	1.24;
commitid	6HLO5qdN5N4nPDjW;

1.24
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.23;
commitid	s0SI41sEunLdyFfd;

1.23
date	2016.03.06.17.11.46;	author matthieu;	state Exp;
branches;
next	1.22;
commitid	vJ21xJXyutpDZ0GD;

1.22
date	2015.11.15.08.28.24;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	UCLlONrn8Bjyct7q;

1.21
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	Te1daavkBLskZ8gc;

1.20
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.19;
commitid	cVXoV5PxI8YrEaVA;

1.19
date	2013.08.24.19.44.38;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2012.08.07.20.12.01;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2012.08.05.18.11.38;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.13.19.46.28;	author todd;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.13.16.30.45;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.04.16.50.50;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.24.19.04.03;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.20.59.14;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.16;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.20.11.37;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.57.41;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 * Loosely based on code bearing the following copyright:
 *
 *   Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
 */
/*
 * Copyright (c) 1992-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <stdlib.h>
#include <errno.h>

#undef HAS_UTSNAME
#if !defined(WIN32)
#define HAS_UTSNAME 1
#include <sys/utsname.h>
#endif

#include <X11/X.h>
#include <X11/Xmd.h>
#include <X11/Xproto.h>
#include <X11/Xatom.h>
#include "input.h"
#include "servermd.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "site.h"
#include "mi.h"
#include "dbus-core.h"
#include "systemd-logind.h"

#include "loaderProcs.h"
#ifdef XFreeXDGA
#include "dgaproc.h"
#endif

#define XF86_OS_PRIVS
#include "xf86.h"
#include "xf86Priv.h"
#include "xf86Config.h"
#include "xf86_OSlib.h"
#include "xf86cmap.h"
#include "xorgVersion.h"
#include "xf86Build.h"
#include "mipointer.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "xf86Extensions.h"
#include "xf86DDC.h"
#include "xf86Xinput.h"
#include "xf86InPriv.h"
#include "picturestr.h"

#include "xf86Bus.h"
#ifdef XSERVER_LIBPCIACCESS
#include "xf86VGAarbiter.h"
#endif
#include "globals.h"
#include "xserver-properties.h"

#ifdef DPMSExtension
#include <X11/extensions/dpmsconst.h>
#include "dpmsproc.h"
#endif
#include <hotplug.h>

#ifdef XF86PM
void (*xf86OSPMClose) (void) = NULL;
#endif
static Bool xorgHWOpenConsole = FALSE;

/* Common pixmap formats */

static PixmapFormatRec formats[MAXFORMATS] = {
    {1, 1, BITMAP_SCANLINE_PAD},
    {4, 8, BITMAP_SCANLINE_PAD},
    {8, 8, BITMAP_SCANLINE_PAD},
    {15, 16, BITMAP_SCANLINE_PAD},
    {16, 16, BITMAP_SCANLINE_PAD},
    {24, 32, BITMAP_SCANLINE_PAD},
    {32, 32, BITMAP_SCANLINE_PAD},
};

static int numFormats = 7;
static Bool formatsDone = FALSE;

#ifdef X_PRIVSEP
static Bool xf86KeepPriv = FALSE;
#endif 

#ifndef OSNAME
#define OSNAME " unknown"
#endif
#ifndef OSVENDOR
#define OSVENDOR ""
#endif
#ifndef PRE_RELEASE
#define PRE_RELEASE XORG_VERSION_SNAP
#endif

static void
xf86PrintBanner(void)
{
#if PRE_RELEASE
    xf86ErrorFVerb(0, "\n"
                   "This is a pre-release version of the X server from "
                   XVENDORNAME ".\n" "It is not supported in any way.\n"
                   "Bugs may be filed in the bugzilla at http://bugs.freedesktop.org/.\n"
                   "Select the \"xorg\" product for bugs you find in this release.\n"
                   "Before reporting bugs in pre-release versions please check the\n"
                   "latest version in the X.Org Foundation git repository.\n"
                   "See http://wiki.x.org/wiki/GitPage for git access instructions.\n");
#endif
    xf86ErrorFVerb(0, "\nX.Org X Server %d.%d.%d",
                   XORG_VERSION_MAJOR, XORG_VERSION_MINOR, XORG_VERSION_PATCH);
#if XORG_VERSION_SNAP > 0
    xf86ErrorFVerb(0, ".%d", XORG_VERSION_SNAP);
#endif

#if XORG_VERSION_SNAP >= 900
    /* When the minor number is 99, that signifies that the we are making
     * a release candidate for a major version.  (X.0.0)
     * When the patch number is 99, that signifies that the we are making
     * a release candidate for a minor version.  (X.Y.0)
     * When the patch number is < 99, then we are making a release
     * candidate for the next point release.  (X.Y.Z)
     */
#if XORG_VERSION_MINOR >= 99
    xf86ErrorFVerb(0, " (%d.0.0 RC %d)", XORG_VERSION_MAJOR + 1,
                   XORG_VERSION_SNAP - 900);
#elif XORG_VERSION_PATCH == 99
    xf86ErrorFVerb(0, " (%d.%d.0 RC %d)", XORG_VERSION_MAJOR,
                   XORG_VERSION_MINOR + 1, XORG_VERSION_SNAP - 900);
#else
    xf86ErrorFVerb(0, " (%d.%d.%d RC %d)", XORG_VERSION_MAJOR,
                   XORG_VERSION_MINOR, XORG_VERSION_PATCH + 1,
                   XORG_VERSION_SNAP - 900);
#endif
#endif

#ifdef XORG_CUSTOM_VERSION
    xf86ErrorFVerb(0, " (%s)", XORG_CUSTOM_VERSION);
#endif
#ifndef XORG_DATE
#define XORG_DATE "Unknown"
#endif
    xf86ErrorFVerb(0, "\nRelease Date: %s\n", XORG_DATE);
    xf86ErrorFVerb(0, "X Protocol Version %d, Revision %d\n",
                   X_PROTOCOL, X_PROTOCOL_REVISION);
    xf86ErrorFVerb(0, "Build Operating System: %s %s\n", OSNAME, OSVENDOR);
#ifdef HAS_UTSNAME
    {
        struct utsname name;

        /* Linux & BSD state that 0 is success, SysV (including Solaris, HP-UX,
           and Irix) and Single Unix Spec 3 just say that non-negative is success.
           All agree that failure is represented by a negative number.
         */
        if (uname(&name) >= 0) {
            xf86ErrorFVerb(0, "Current Operating System: %s %s %s %s %s\n",
                           name.sysname, name.nodename, name.release,
                           name.version, name.machine);
#ifdef linux
            do {
                char buf[80];
                int fd = open("/proc/cmdline", O_RDONLY);

                if (fd != -1) {
                    xf86ErrorFVerb(0, "Kernel command line: ");
                    memset(buf, 0, 80);
                    while (read(fd, buf, 80) > 0) {
                        xf86ErrorFVerb(0, "%.80s", buf);
                        memset(buf, 0, 80);
                    }
                    close(fd);
                }
            } while (0);
#endif
        }
    }
#endif
#if defined(BUILD_DATE) && (BUILD_DATE > 19000000)
    {
        struct tm t;
        char buf[100];

        memset(&t, 0, sizeof(t));
        memset(buf, 0, sizeof(buf));
        t.tm_mday = BUILD_DATE % 100;
        t.tm_mon = (BUILD_DATE / 100) % 100 - 1;
        t.tm_year = BUILD_DATE / 10000 - 1900;
#if defined(BUILD_TIME)
        t.tm_sec = BUILD_TIME % 100;
        t.tm_min = (BUILD_TIME / 100) % 100;
        t.tm_hour = (BUILD_TIME / 10000) % 100;
        if (strftime(buf, sizeof(buf), "%d %B %Y  %I:%M:%S%p", &t))
            xf86ErrorFVerb(0, "Build Date: %s\n", buf);
#else
        if (strftime(buf, sizeof(buf), "%d %B %Y", &t))
            xf86ErrorFVerb(0, "Build Date: %s\n", buf);
#endif
    }
#endif
#if defined(BUILDERSTRING)
    xf86ErrorFVerb(0, "%s \n", BUILDERSTRING);
#endif
    xf86ErrorFVerb(0, "Current version of pixman: %s\n",
                   pixman_version_string());
    xf86ErrorFVerb(0, "\tBefore reporting problems, check "
                   "" __VENDORDWEBSUPPORT__ "\n"
                   "\tto make sure that you have the latest version.\n");
}

Bool
xf86PrivsElevated(void)
{
    static Bool privsTested = FALSE;
    static Bool privsElevated = TRUE;

    if (!privsTested) {
#if defined(WIN32)
        privsElevated = FALSE;
#else
        if ((getuid() != geteuid()) || (getgid() != getegid())) {
            privsElevated = TRUE;
        }
        else {
#if defined(HAVE_ISSETUGID)
            privsElevated = issetugid();
#elif defined(HAVE_GETRESUID)
            uid_t ruid, euid, suid;
            gid_t rgid, egid, sgid;

            if ((getresuid(&ruid, &euid, &suid) == 0) &&
                (getresgid(&rgid, &egid, &sgid) == 0)) {
                privsElevated = (euid != suid) || (egid != sgid);
            }
            else {
                printf("Failed getresuid or getresgid");
                /* Something went wrong, make defensive assumption */
                privsElevated = TRUE;
            }
#else
            if (getuid() == 0) {
                /* running as root: uid==euid==0 */
                privsElevated = FALSE;
            }
            else {
                /*
                 * If there are saved ID's the process might still be privileged
                 * even though the above test succeeded. If issetugid() and
                 * getresgid() aren't available, test this by trying to set
                 * euid to 0.
                 */
                unsigned int oldeuid;

                oldeuid = geteuid();

                if (seteuid(0) != 0) {
                    privsElevated = FALSE;
                }
                else {
                    if (seteuid(oldeuid) != 0) {
                        FatalError("Failed to drop privileges.  Exiting\n");
                    }
                    privsElevated = TRUE;
                }
            }
#endif
        }
#endif
        privsTested = TRUE;
    }
    return privsElevated;
}

static Bool
xf86CreateRootWindow(WindowPtr pWin)
{
    int ret = TRUE;
    int err = Success;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    RootWinPropPtr pProp;
    CreateWindowProcPtr create_window = (CreateWindowProcPtr)
        dixLookupPrivate(&pScreen->devPrivates, xf86CreateRootWindowKey);

    DebugF("xf86CreateRootWindow(%p)\n", pWin);

    /* Unhook this function ... */
    pScreen->CreateWindow = create_window;
    dixSetPrivate(&pScreen->devPrivates, xf86CreateRootWindowKey, NULL);

    /* ... and call the previous CreateWindow fuction, if any */
    if (NULL != pScreen->CreateWindow) {
        ret = (*pScreen->CreateWindow) (pWin);
    }

    /* Now do our stuff */
    if (xf86RegisteredPropertiesTable != NULL) {
        if (pWin->parent == NULL && xf86RegisteredPropertiesTable != NULL) {
            for (pProp = xf86RegisteredPropertiesTable[pScreen->myNum];
                 pProp != NULL && err == Success; pProp = pProp->next) {
                Atom prop;

                prop = MakeAtom(pProp->name, strlen(pProp->name), TRUE);
                err = dixChangeWindowProperty(serverClient, pWin,
                                              prop, pProp->type,
                                              pProp->format, PropModeReplace,
                                              pProp->size, pProp->data, FALSE);
            }

            /* Look at err */
            ret &= (err == Success);

        }
    }

    return ret;
}

static void
InstallSignalHandlers(void)
{
    /*
     * Install signal handler for unexpected signals
     */
    xf86Info.caughtSignal = FALSE;
    if (!xf86Info.notrapSignals) {
        OsRegisterSigWrapper(xf86SigWrapper);
    }
    else {
        signal(SIGSEGV, SIG_DFL);
        signal(SIGILL, SIG_DFL);
#ifdef SIGEMT
        signal(SIGEMT, SIG_DFL);
#endif
        signal(SIGFPE, SIG_DFL);
        signal(SIGBUS, SIG_DFL);
        signal(SIGSYS, SIG_DFL);
        signal(SIGXCPU, SIG_DFL);
        signal(SIGXFSZ, SIG_DFL);
    }
}

/* The memory storing the initial value of the XFree86_has_VT root window
 * property.  This has to remain available until server start-up, so we just
 * use a global. */
static CARD32 HasVTValue = 1;

/*
 * InitOutput --
 *	Initialize screenInfo for all actually accessible framebuffers.
 *      That includes vt-manager setup, querying all possible devices and
 *      collecting the pixmap formats.
 */
void
InitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
{
    int i, j, k, scr_index;
    const char **modulelist;
    void **optionlist;
    Pix24Flags screenpix24, pix24;
    MessageType pix24From = X_DEFAULT;
    Bool pix24Fail = FALSE;
    Bool autoconfig = FALSE;
    Bool sigio_blocked = FALSE;
    Bool want_hw_access = FALSE;
    GDevPtr configured_device;

    xf86Initialising = TRUE;

    config_pre_init();

    if (serverGeneration == 1) {
        if ((xf86ServerName = strrchr(argv[0], '/')) != 0)
            xf86ServerName++;
        else
            xf86ServerName = argv[0];

        xf86PrintBanner();
        LogPrintMarkers();
        if (xf86LogFile) {
            time_t t;
            const char *ct;

            t = time(NULL);
            ct = ctime(&t);
            xf86MsgVerb(xf86LogFileFrom, 0, "Log file: \"%s\", Time: %s",
                        xf86LogFile, ct);
        }

        /* Read and parse the config file */
        if (!xf86DoConfigure && !xf86DoShowOptions) {
            switch (xf86HandleConfigFile(FALSE)) {
            case CONFIG_OK:
                break;
            case CONFIG_PARSE_ERROR:
                xf86Msg(X_ERROR, "Error parsing the config file\n");
                return;
            case CONFIG_NOFILE:
                autoconfig = TRUE;
                break;
            }
        }

        InstallSignalHandlers();

        /* Initialise the loader */
        LoaderInit();

        /* Tell the loader the default module search path */
        LoaderSetPath(xf86ModulePath);

        if (xf86Info.ignoreABI) {
            LoaderSetOptions(LDR_OPT_ABI_MISMATCH_NONFATAL);
        }

        if (xf86DoShowOptions)
            DoShowOptions();

        dbus_core_init();
        systemd_logind_init();

        /* Do a general bus probe.  This will be a PCI probe for x86 platforms */
        xf86BusProbe();

        if (xf86DoConfigure)
            DoConfigure();

        if (autoconfig) {
            if (!xf86AutoConfig()) {
                xf86Msg(X_ERROR, "Auto configuration failed\n");
                return;
            }
        }

#ifdef XF86PM
        xf86OSPMClose = xf86OSPMOpen();
#endif

        xf86ExtensionInit();

        /* Load all modules specified explicitly in the config file */
        if ((modulelist = xf86ModulelistFromConfig(&optionlist))) {
            xf86LoadModules(modulelist, optionlist);
            free(modulelist);
            free(optionlist);
        }

        /* Load all driver modules specified in the config file */
        /* If there aren't any specified in the config file, autoconfig them */
        /* FIXME: Does not handle multiple active screen sections, but I'm not
         * sure if we really want to handle that case*/
        configured_device = xf86ConfigLayout.screens->screen->device;
        if ((!configured_device) || (!configured_device->driver)) {
            if (!autoConfigDevice(configured_device)) {
                xf86Msg(X_ERROR, "Automatic driver configuration failed\n");
                return;
            }
        }
        if ((modulelist = xf86DriverlistFromConfig())) {
            xf86LoadModules(modulelist, NULL);
            free(modulelist);
        }

        /* Load all input driver modules specified in the config file. */
        if ((modulelist = xf86InputDriverlistFromConfig())) {
            xf86LoadModules(modulelist, NULL);
            free(modulelist);
        }

        /*
         * It is expected that xf86AddDriver()/xf86AddInputDriver will be
         * called for each driver as it is loaded.  Those functions save the
         * module pointers for drivers.
         * XXX Nothing keeps track of them for other modules.
         */
        /* XXX What do we do if not all of these could be loaded? */

        /*
         * At this point, xf86DriverList[] is all filled in with entries for
         * each of the drivers to try and xf86NumDrivers has the number of
         * drivers.  If there are none, return now.
         */

        if (xf86NumDrivers == 0) {
            xf86Msg(X_ERROR, "No drivers available.\n");
            return;
        }

        /*
         * Call each of the Identify functions and call the driverFunc to check
         * if HW access is required.  The Identify functions print out some
         * identifying information, and anything else that might be
         * needed at this early stage.
         */

        for (i = 0; i < xf86NumDrivers; i++) {
            xorgHWFlags flags = HW_IO;

            if (xf86DriverList[i]->Identify != NULL)
                xf86DriverList[i]->Identify(0);

            if (xf86DriverList[i]->driverFunc)
                xf86DriverList[i]->driverFunc(NULL,
                                              GET_REQUIRED_HW_INTERFACES,
                                              &flags);

            if (NEED_IO_ENABLED(flags))
                want_hw_access = TRUE;

            /* Non-seat0 X servers should not open console */
            if (!(flags & HW_SKIP_CONSOLE) && !ServerIsNotSeat0())
                xorgHWOpenConsole = TRUE;
        }

        if (xorgHWOpenConsole)
            xf86OpenConsole();
        else
            xf86Info.dontVTSwitch = TRUE;

	/* Enable full I/O access */
	if (want_hw_access)
	    xorgHWAccess = xf86EnableIO();

        if (xf86BusConfig() == FALSE)
            return;

        xf86PostProbe();

        /*
         * Sort the drivers to match the requested ording.  Using a slow
         * bubble sort.
         */
        for (j = 0; j < xf86NumScreens - 1; j++) {
            for (i = 0; i < xf86NumScreens - j - 1; i++) {
                if (xf86Screens[i + 1]->confScreen->screennum <
                    xf86Screens[i]->confScreen->screennum) {
                    ScrnInfoPtr tmpScrn = xf86Screens[i + 1];

                    xf86Screens[i + 1] = xf86Screens[i];
                    xf86Screens[i] = tmpScrn;
                }
            }
        }
        /* Fix up the indexes */
        for (i = 0; i < xf86NumScreens; i++) {
            xf86Screens[i]->scrnIndex = i;
        }

        /*
         * Call the driver's PreInit()'s to complete initialisation for the first
         * generation.
         */

        for (i = 0; i < xf86NumScreens; i++) {
            xf86VGAarbiterScrnInit(xf86Screens[i]);
            xf86VGAarbiterLock(xf86Screens[i]);
            if (xf86Screens[i]->PreInit &&
                xf86Screens[i]->PreInit(xf86Screens[i], 0))
                xf86Screens[i]->configured = TRUE;
            xf86VGAarbiterUnlock(xf86Screens[i]);
        }
        for (i = 0; i < xf86NumScreens; i++)
            if (!xf86Screens[i]->configured)
                xf86DeleteScreen(xf86Screens[i--]);

        for (i = 0; i < xf86NumGPUScreens; i++) {
            xf86VGAarbiterScrnInit(xf86GPUScreens[i]);
            xf86VGAarbiterLock(xf86GPUScreens[i]);
            if (xf86GPUScreens[i]->PreInit &&
                xf86GPUScreens[i]->PreInit(xf86GPUScreens[i], 0))
                xf86GPUScreens[i]->configured = TRUE;
            xf86VGAarbiterUnlock(xf86GPUScreens[i]);
        }
        for (i = 0; i < xf86NumGPUScreens; i++)
            if (!xf86GPUScreens[i]->configured)
                xf86DeleteScreen(xf86GPUScreens[i--]);

        /*
         * If no screens left, return now.
         */

        if (xf86NumScreens == 0) {
            xf86Msg(X_ERROR,
                    "Screen(s) found, but none have a usable configuration.\n");
            return;
        }

        for (i = 0; i < xf86NumScreens; i++) {
            if (xf86Screens[i]->name == NULL) {
                char *tmp;
                XNFasprintf(&tmp, "screen%d", i);
                xf86Screens[i]->name = tmp;
                xf86MsgVerb(X_WARNING, 0,
                            "Screen driver %d has no name set, using `%s'.\n",
                            i, xf86Screens[i]->name);
            }
        }

        /* Remove (unload) drivers that are not required */
        for (i = 0; i < xf86NumDrivers; i++)
            if (xf86DriverList[i] && xf86DriverList[i]->refCount <= 0)
                xf86DeleteDriver(i);

        /*
         * At this stage we know how many screens there are.
         */

        for (i = 0; i < xf86NumScreens; i++)
            xf86InitViewport(xf86Screens[i]);

        /*
         * Collect all pixmap formats and check for conflicts at the display
         * level.  Should we die here?  Or just delete the offending screens?
         */
        screenpix24 = Pix24DontCare;
        for (i = 0; i < xf86NumScreens; i++) {
            if (xf86Screens[i]->imageByteOrder !=
                xf86Screens[0]->imageByteOrder)
                FatalError("Inconsistent display bitmapBitOrder.  Exiting\n");
            if (xf86Screens[i]->bitmapScanlinePad !=
                xf86Screens[0]->bitmapScanlinePad)
                FatalError
                    ("Inconsistent display bitmapScanlinePad.  Exiting\n");
            if (xf86Screens[i]->bitmapScanlineUnit !=
                xf86Screens[0]->bitmapScanlineUnit)
                FatalError
                    ("Inconsistent display bitmapScanlineUnit.  Exiting\n");
            if (xf86Screens[i]->bitmapBitOrder !=
                xf86Screens[0]->bitmapBitOrder)
                FatalError("Inconsistent display bitmapBitOrder.  Exiting\n");

            /* Determine the depth 24 pixmap format the screens would like */
            if (xf86Screens[i]->pixmap24 != Pix24DontCare) {
                if (screenpix24 == Pix24DontCare)
                    screenpix24 = xf86Screens[i]->pixmap24;
                else if (screenpix24 != xf86Screens[i]->pixmap24)
                    FatalError
                        ("Inconsistent depth 24 pixmap format.  Exiting\n");
            }
        }
        /* check if screenpix24 is consistent with the config/cmdline */
        if (xf86Info.pixmap24 != Pix24DontCare) {
            pix24 = xf86Info.pixmap24;
            pix24From = xf86Info.pix24From;
            if (screenpix24 != Pix24DontCare &&
                screenpix24 != xf86Info.pixmap24)
                pix24Fail = TRUE;
        }
        else if (screenpix24 != Pix24DontCare) {
            pix24 = screenpix24;
            pix24From = X_PROBED;
        }
        else
            pix24 = Pix24Use32;

        if (pix24Fail)
            FatalError("Screen(s) can't use the required depth 24 pixmap format"
                       " (%d).  Exiting\n", PIX24TOBPP(pix24));

        /* Initialise the depth 24 format */
        for (j = 0; j < numFormats && formats[j].depth != 24; j++);
        formats[j].bitsPerPixel = PIX24TOBPP(pix24);

        /* Collect additional formats */
        for (i = 0; i < xf86NumScreens; i++) {
            for (j = 0; j < xf86Screens[i]->numFormats; j++) {
                for (k = 0;; k++) {
                    if (k >= numFormats) {
                        if (k >= MAXFORMATS)
                            FatalError("Too many pixmap formats!  Exiting\n");
                        formats[k] = xf86Screens[i]->formats[j];
                        numFormats++;
                        break;
                    }
                    if (formats[k].depth == xf86Screens[i]->formats[j].depth) {
                        if ((formats[k].bitsPerPixel ==
                             xf86Screens[i]->formats[j].bitsPerPixel) &&
                            (formats[k].scanlinePad ==
                             xf86Screens[i]->formats[j].scanlinePad))
                            break;
                        FatalError("Inconsistent pixmap format for depth %d."
                                   "  Exiting\n", formats[k].depth);
                    }
                }
            }
        }
        formatsDone = TRUE;

        if (xf86Info.vtno >= 0) {
#define VT_ATOM_NAME         "XFree86_VT"
            Atom VTAtom = -1;
            Atom HasVTAtom = -1;
            CARD32 *VT = NULL;
            CARD32 *HasVT = &HasVTValue;
            int ret;

            /* This memory needs to stay available until the screen has been
               initialized, and we can create the property for real.
             */
            if ((VT = malloc(sizeof(CARD32))) == NULL) {
                FatalError
                    ("Unable to make VT property - out of memory. Exiting...\n");
            }
            *VT = xf86Info.vtno;

            VTAtom = MakeAtom(VT_ATOM_NAME, sizeof(VT_ATOM_NAME) - 1, TRUE);
            HasVTAtom = MakeAtom(HAS_VT_ATOM_NAME,
                                 sizeof(HAS_VT_ATOM_NAME) - 1, TRUE);

            for (i = 0, ret = Success; i < xf86NumScreens && ret == Success;
                 i++) {
                ret =
                    xf86RegisterRootWindowProperty(xf86Screens[i]->scrnIndex,
                                                   VTAtom, XA_INTEGER, 32, 1,
                                                   VT);
                if (ret == Success)
                    ret = xf86RegisterRootWindowProperty(xf86Screens[i]
                                                             ->scrnIndex,
                                                         HasVTAtom, XA_INTEGER,
                                                         32, 1, HasVT);
                if (ret != Success)
                    xf86DrvMsg(xf86Screens[i]->scrnIndex, X_WARNING,
                               "Failed to register VT properties\n");
            }
        }

        if (SeatId) {
            Atom SeatAtom;

            SeatAtom =
                MakeAtom(SEAT_ATOM_NAME, sizeof(SEAT_ATOM_NAME) - 1, TRUE);

            for (i = 0; i < xf86NumScreens; i++) {
                int ret;

                ret = xf86RegisterRootWindowProperty(xf86Screens[i]->scrnIndex,
                                                     SeatAtom, XA_STRING, 8,
                                                     strlen(SeatId) + 1,
                                                     SeatId);
                if (ret != Success) {
                    xf86DrvMsg(xf86Screens[i]->scrnIndex, X_WARNING,
                               "Failed to register seat property\n");
                }
            }
        }

        /* If a screen uses depth 24, show what the pixmap format is */
        for (i = 0; i < xf86NumScreens; i++) {
            if (xf86Screens[i]->depth == 24) {
                xf86Msg(pix24From, "Depth 24 pixmap format is %d bpp\n",
                        PIX24TOBPP(pix24));
                break;
            }
        }
    }
    else {
        /*
         * serverGeneration != 1; some OSs have to do things here, too.
         */
        if (xorgHWOpenConsole)
            xf86OpenConsole();

#ifdef XF86PM
        /*
           should we reopen it here? We need to deal with an already opened
           device. We could leave this to the OS layer. For now we simply
           close it here
         */
        if (xf86OSPMClose)
            xf86OSPMClose();
        if ((xf86OSPMClose = xf86OSPMOpen()) != NULL)
            xf86MsgVerb(X_INFO, 3, "APM registered successfully\n");
#endif

        /* Make sure full I/O access is enabled */
        if (xorgHWAccess)
            xf86EnableIO();
    }

    /*
     * Use the previously collected parts to setup pScreenInfo
     */

    pScreenInfo->imageByteOrder = xf86Screens[0]->imageByteOrder;
    pScreenInfo->bitmapScanlinePad = xf86Screens[0]->bitmapScanlinePad;
    pScreenInfo->bitmapScanlineUnit = xf86Screens[0]->bitmapScanlineUnit;
    pScreenInfo->bitmapBitOrder = xf86Screens[0]->bitmapBitOrder;
    pScreenInfo->numPixmapFormats = numFormats;
    for (i = 0; i < numFormats; i++)
        pScreenInfo->formats[i] = formats[i];

    /* Make sure the server's VT is active */

    if (serverGeneration != 1) {
        xf86Resetting = TRUE;
        /* All screens are in the same state, so just check the first */
        if (!xf86VTOwner()) {
#ifdef HAS_USL_VTS
            ioctl(xf86Info.consoleFd, VT_RELDISP, VT_ACKACQ);
#endif
            xf86AccessEnter();
            OsBlockSIGIO();
            sigio_blocked = TRUE;
        }
    }

    for (i = 0; i < xf86NumScreens; i++)
        if (!xf86ColormapAllocatePrivates(xf86Screens[i]))
            FatalError("Cannot register DDX private keys");

    if (!dixRegisterPrivateKey(&xf86ScreenKeyRec, PRIVATE_SCREEN, 0) ||
        !dixRegisterPrivateKey(&xf86CreateRootWindowKeyRec, PRIVATE_SCREEN, 0))
        FatalError("Cannot register DDX private keys");

    for (i = 0; i < xf86NumGPUScreens; i++) {
        ScrnInfoPtr pScrn = xf86GPUScreens[i];
        xf86VGAarbiterLock(pScrn);

        /*
         * Almost everything uses these defaults, and many of those that
         * don't, will wrap them.
         */
        pScrn->EnableDisableFBAccess = xf86EnableDisableFBAccess;
#ifdef XFreeXDGA
        pScrn->SetDGAMode = xf86SetDGAMode;
#endif
        pScrn->DPMSSet = NULL;
        pScrn->LoadPalette = NULL;
        pScrn->SetOverscan = NULL;
        pScrn->DriverFunc = NULL;
        pScrn->pScreen = NULL;
        scr_index = AddGPUScreen(pScrn->ScreenInit, argc, argv);
        xf86VGAarbiterUnlock(pScrn);
        if (scr_index == i) {
            dixSetPrivate(&screenInfo.gpuscreens[scr_index]->devPrivates,
                          xf86ScreenKey, xf86GPUScreens[i]);
            pScrn->pScreen = screenInfo.gpuscreens[scr_index];
            /* The driver should set this, but make sure it is set anyway */
            pScrn->vtSema = TRUE;
        } else {
            FatalError("AddScreen/ScreenInit failed for gpu driver %d %d\n", i, scr_index);
        }
    }

    for (i = 0; i < xf86NumScreens; i++) {
        xf86VGAarbiterLock(xf86Screens[i]);
        /*
         * Almost everything uses these defaults, and many of those that
         * don't, will wrap them.
         */
        xf86Screens[i]->EnableDisableFBAccess = xf86EnableDisableFBAccess;
#ifdef XFreeXDGA
        xf86Screens[i]->SetDGAMode = xf86SetDGAMode;
#endif
        xf86Screens[i]->DPMSSet = NULL;
        xf86Screens[i]->LoadPalette = NULL;
        xf86Screens[i]->SetOverscan = NULL;
        xf86Screens[i]->DriverFunc = NULL;
        xf86Screens[i]->pScreen = NULL;
        scr_index = AddScreen(xf86Screens[i]->ScreenInit, argc, argv);
        xf86VGAarbiterUnlock(xf86Screens[i]);
        if (scr_index == i) {
            /*
             * Hook in our ScrnInfoRec, and initialise some other pScreen
             * fields.
             */
            dixSetPrivate(&screenInfo.screens[scr_index]->devPrivates,
                          xf86ScreenKey, xf86Screens[i]);
            xf86Screens[i]->pScreen = screenInfo.screens[scr_index];
            /* The driver should set this, but make sure it is set anyway */
            xf86Screens[i]->vtSema = TRUE;
        }
        else {
            /* This shouldn't normally happen */
            FatalError("AddScreen/ScreenInit failed for driver %d\n", i);
        }

        DebugF("InitOutput - xf86Screens[%d]->pScreen = %p\n",
               i, xf86Screens[i]->pScreen);
        DebugF("xf86Screens[%d]->pScreen->CreateWindow = %p\n",
               i, xf86Screens[i]->pScreen->CreateWindow);

        dixSetPrivate(&screenInfo.screens[scr_index]->devPrivates,
                      xf86CreateRootWindowKey,
                      xf86Screens[i]->pScreen->CreateWindow);
        xf86Screens[i]->pScreen->CreateWindow = xf86CreateRootWindow;

        if (PictureGetSubpixelOrder(xf86Screens[i]->pScreen) == SubPixelUnknown) {
            xf86MonPtr DDC = (xf86MonPtr) (xf86Screens[i]->monitor->DDC);

            PictureSetSubpixelOrder(xf86Screens[i]->pScreen,
                                    DDC ?
                                    (DDC->features.input_type ?
                                     SubPixelHorizontalRGB : SubPixelNone) :
                                    SubPixelUnknown);
        }
#ifdef RANDR
        if (!xf86Info.disableRandR)
            xf86RandRInit(screenInfo.screens[scr_index]);
        xf86Msg(xf86Info.randRFrom, "RandR %s\n",
                xf86Info.disableRandR ? "disabled" : "enabled");
#endif
    }

    for (i = 0; i < xf86NumGPUScreens; i++)
        AttachUnboundGPU(xf86Screens[0]->pScreen, xf86GPUScreens[i]->pScreen);

    xf86VGAarbiterWrapFunctions();
    if (sigio_blocked)
        OsReleaseSIGIO();

    xf86InitOrigins();

    xf86Resetting = FALSE;
    xf86Initialising = FALSE;

    RegisterBlockAndWakeupHandlers((BlockHandlerProcPtr) NoopDDA, xf86Wakeup,
                                   NULL);
}

/**
 * Initialize all supported input devices present and referenced in the
 * xorg.conf.
 */
void
InitInput(int argc, char **argv)
{
    InputInfoPtr *pInfo;
    DeviceIntPtr dev;

    xf86Info.vtRequestsPending = FALSE;

    mieqInit();

    /* Initialize all configured input devices */
    for (pInfo = xf86ConfigLayout.inputs; pInfo && *pInfo; pInfo++) {
        (*pInfo)->options =
            xf86AddNewOption((*pInfo)->options, "driver", (*pInfo)->driver);
        (*pInfo)->options =
            xf86AddNewOption((*pInfo)->options, "identifier", (*pInfo)->name);
        /* If one fails, the others will too */
        if (NewInputDeviceRequest((*pInfo)->options, NULL, &dev) == BadAlloc)
            break;
    }

    config_init();
}

void
CloseInput(void)
{
    config_fini();
    mieqFini();
}

/*
 * OsVendorInit --
 *      OS/Vendor-specific initialisations.  Called from OsInit(), which
 *      is called by dix before establishing the well known sockets.
 */

void
OsVendorInit(void)
{
    static Bool beenHere = FALSE;

    signal(SIGCHLD, SIG_DFL);   /* Need to wait for child processes */

    if (!beenHere) {
        umask(022);
        xf86LogInit();
    }

    /* Set stderr to non-blocking. */
#ifndef O_NONBLOCK
#if defined(FNDELAY)
#define O_NONBLOCK FNDELAY
#elif defined(O_NDELAY)
#define O_NONBLOCK O_NDELAY
#endif

#ifdef O_NONBLOCK
    if (!beenHere) {
        if (xf86PrivsElevated()) {
            int status;

            status = fcntl(fileno(stderr), F_GETFL, 0);
            if (status != -1) {
                fcntl(fileno(stderr), F_SETFL, status | O_NONBLOCK);
            }
        }
    }
#endif
#endif
#if defined(X_PRIVSEP)
  if (!beenHere && !xf86KeepPriv && geteuid() == 0) {
	  xf86PrivilegedInit();
	  xf86DropPriv();
  }
#endif

    beenHere = TRUE;
}

/*
 * ddxGiveUp --
 *      Device dependent cleanup. Called by by dix before normal server death.
 *      For SYSV386 we must switch the terminal back to normal mode. No error-
 *      checking here, since there should be restored as much as possible.
 */

void
ddxGiveUp(enum ExitCode error)
{
    int i;

    xf86VGAarbiterFini();

#ifdef XF86PM
    if (xf86OSPMClose)
        xf86OSPMClose();
    xf86OSPMClose = NULL;
#endif

    for (i = 0; i < xf86NumScreens; i++) {
        /*
         * zero all access functions to
         * trap calls when switched away.
         */
        xf86Screens[i]->vtSema = FALSE;
    }

#ifdef XFreeXDGA
    DGAShutdown();
#endif

    if (xorgHWOpenConsole)
        xf86CloseConsole();

    systemd_logind_fini();
    dbus_core_fini();

    xf86CloseLog(error);

    /* If an unexpected signal was caught, dump a core for debugging */
    if (xf86Info.caughtSignal)
        OsAbort();
}

/*
 * AbortDDX --
 *      DDX - specific abort routine.  Called by AbortServer(). The attempt is
 *      made to restore all original setting of the displays. Also all devices
 *      are closed.
 */

void
AbortDDX(enum ExitCode error)
{
    int i;

    OsBlockSIGIO();

    /*
     * try to restore the original video state
     */
#ifdef DPMSExtension            /* Turn screens back on */
    if (DPMSPowerLevel != DPMSModeOn)
        DPMSSet(serverClient, DPMSModeOn);
#endif
    if (xf86Screens) {
        for (i = 0; i < xf86NumScreens; i++)
            if (xf86Screens[i]->vtSema) {
                /*
                 * if we are aborting before ScreenInit() has finished
                 * we might not have been wrapped yet. Therefore enable
                 * screen explicitely.
                 */
                xf86VGAarbiterLock(xf86Screens[i]);
                (xf86Screens[i]->LeaveVT) (xf86Screens[i]);
                xf86VGAarbiterUnlock(xf86Screens[i]);
            }
    }

    xf86AccessLeave();

    /*
     * This is needed for an abnormal server exit, since the normal exit stuff
     * MUST also be performed (i.e. the vt must be left in a defined state)
     */
    ddxGiveUp(error);
}

void
OsVendorFatalError(const char *f, va_list args)
{
#ifdef VENDORSUPPORT
    ErrorFSigSafe("\nPlease refer to your Operating System Vendor support "
                 "pages\nat %s for support on this crash.\n", VENDORSUPPORT);
#else
    ErrorFSigSafe("\nPlease consult the " XVENDORNAME " support \n\t at "
                 __VENDORDWEBSUPPORT__ "\n for help. \n");
#endif
    if (xf86LogFile && xf86LogFileWasOpened)
        ErrorFSigSafe("Please also check the log file at \"%s\" for additional "
                     "information.\n", xf86LogFile);
    ErrorFSigSafe("\n");
}

int
xf86SetVerbosity(int verb)
{
    int save = xf86Verbose;

    xf86Verbose = verb;
    LogSetParameter(XLOG_VERBOSITY, verb);
    return save;
}

int
xf86SetLogVerbosity(int verb)
{
    int save = xf86LogVerbose;

    xf86LogVerbose = verb;
    LogSetParameter(XLOG_FILE_VERBOSITY, verb);
    return save;
}

static void
xf86PrintDefaultModulePath(void)
{
    ErrorF("%s\n", DEFAULT_MODULE_PATH);
}

static void
xf86PrintDefaultLibraryPath(void)
{
    ErrorF("%s\n", DEFAULT_LIBRARY_PATH);
}

/*
 * ddxProcessArgument --
 *	Process device-dependent command line args. Returns 0 if argument is
 *      not device dependent, otherwise Count of number of elements of argv
 *      that are part of a device dependent commandline option.
 *
 */

/* ARGSUSED */
int
ddxProcessArgument(int argc, char **argv, int i)
{
#define CHECK_FOR_REQUIRED_ARGUMENT() \
    if (((i + 1) >= argc) || (!argv[i + 1])) { 				\
      ErrorF("Required argument to %s not specified\n", argv[i]); 	\
      UseMsg(); 							\
      FatalError("Required argument to %s not specified\n", argv[i]);	\
    }

    /* First the options that are not allowed with elevated privileges */
    if (!strcmp(argv[i], "-modulepath") || !strcmp(argv[i], "-logfile")) {
        if (xf86PrivsElevated()) {
            FatalError("The '%s' option cannot be used with "
                       "elevated privileges.\n", argv[i]);
        }
        else if (!strcmp(argv[i], "-modulepath")) {
            char *mp;

            CHECK_FOR_REQUIRED_ARGUMENT();
            mp = strdup(argv[i + 1]);
            if (!mp)
                FatalError("Can't allocate memory for ModulePath\n");
            xf86ModulePath = mp;
            xf86ModPathFrom = X_CMDLINE;
            return 2;
        }
        else if (!strcmp(argv[i], "-logfile")) {
            char *lf;

            CHECK_FOR_REQUIRED_ARGUMENT();
            lf = strdup(argv[i + 1]);
            if (!lf)
                FatalError("Can't allocate memory for LogFile\n");
            xf86LogFile = lf;
            xf86LogFileFrom = X_CMDLINE;
            return 2;
        }
    }
    if (!strcmp(argv[i], "-config") || !strcmp(argv[i], "-xf86config")) {
        CHECK_FOR_REQUIRED_ARGUMENT();
        if (xf86PrivsElevated() && !xf86PathIsSafe(argv[i + 1])) {
            FatalError("\nInvalid argument for %s\n"
                       "\tWith elevated privileges, the file specified with %s must be\n"
                       "\ta relative path and must not contain any \"..\" elements.\n"
                       "\tUsing default " __XCONFIGFILE__ " search path.\n\n",
                       argv[i], argv[i]);
        }
        xf86ConfigFile = argv[i + 1];
#ifdef X_PRIVSEP
        /* Cannot drop privs when -xf86config is used with unsafe path */
        if (!xf86PathIsSafe(xf86ConfigFile))
                xf86KeepPriv = TRUE;
#endif
        return 2;
    }
    if (!strcmp(argv[i], "-configdir")) {
        CHECK_FOR_REQUIRED_ARGUMENT();
        if (xf86PrivsElevated() && !xf86PathIsSafe(argv[i + 1])) {
            FatalError("\nInvalid argument for %s\n"
                       "\tWith elevated privileges, the file specified with %s must be\n"
                       "\ta relative path and must not contain any \"..\" elements.\n"
                       "\tUsing default " __XCONFIGDIR__ " search path.\n\n",
                       argv[i], argv[i]);
        }
        xf86ConfigDir = argv[i + 1];
        return 2;
    }
    if (!strcmp(argv[i], "-flipPixels")) {
        xf86FlipPixels = TRUE;
        return 1;
    }
#ifdef XF86VIDMODE
    if (!strcmp(argv[i], "-disableVidMode")) {
        xf86VidModeDisabled = TRUE;
        return 1;
    }
    if (!strcmp(argv[i], "-allowNonLocalXvidtune")) {
        xf86VidModeAllowNonLocal = TRUE;
        return 1;
    }
#endif
    if (!strcmp(argv[i], "-allowMouseOpenFail")) {
        xf86AllowMouseOpenFail = TRUE;
        return 1;
    }
    if (!strcmp(argv[i], "-ignoreABI")) {
        LoaderSetOptions(LDR_OPT_ABI_MISMATCH_NONFATAL);
        return 1;
    }
    if (!strcmp(argv[i], "-verbose")) {
        if (++i < argc && argv[i]) {
            char *end;
            long val;

            val = strtol(argv[i], &end, 0);
            if (*end == '\0') {
                xf86SetVerbosity(val);
                return 2;
            }
        }
        xf86SetVerbosity(++xf86Verbose);
        return 1;
    }
    if (!strcmp(argv[i], "-logverbose")) {
        if (++i < argc && argv[i]) {
            char *end;
            long val;

            val = strtol(argv[i], &end, 0);
            if (*end == '\0') {
                xf86SetLogVerbosity(val);
                return 2;
            }
        }
        xf86SetLogVerbosity(++xf86LogVerbose);
        return 1;
    }
    if (!strcmp(argv[i], "-quiet")) {
        xf86SetVerbosity(-1);
        return 1;
    }
    if (!strcmp(argv[i], "-showconfig") || !strcmp(argv[i], "-version")) {
        xf86PrintBanner();
        exit(0);
    }
    if (!strcmp(argv[i], "-showDefaultModulePath")) {
        xf86PrintDefaultModulePath();
        exit(0);
    }
    if (!strcmp(argv[i], "-showDefaultLibPath")) {
        xf86PrintDefaultLibraryPath();
        exit(0);
    }
    /* Notice the -fp flag, but allow it to pass to the dix layer */
    if (!strcmp(argv[i], "-fp")) {
        xf86fpFlag = TRUE;
        return 0;
    }
    /* Notice the -bs flag, but allow it to pass to the dix layer */
    if (!strcmp(argv[i], "-bs")) {
        xf86bsDisableFlag = TRUE;
        return 0;
    }
    /* Notice the +bs flag, but allow it to pass to the dix layer */
    if (!strcmp(argv[i], "+bs")) {
        xf86bsEnableFlag = TRUE;
        return 0;
    }
    /* Notice the -s flag, but allow it to pass to the dix layer */
    if (!strcmp(argv[i], "-s")) {
        xf86sFlag = TRUE;
        return 0;
    }
    if (!strcmp(argv[i], "-pixmap24")) {
        xf86Pix24 = Pix24Use24;
        return 1;
    }
    if (!strcmp(argv[i], "-pixmap32")) {
        xf86Pix24 = Pix24Use32;
        return 1;
    }
    if (!strcmp(argv[i], "-fbbpp")) {
        int bpp;

        CHECK_FOR_REQUIRED_ARGUMENT();
        if (sscanf(argv[++i], "%d", &bpp) == 1) {
            xf86FbBpp = bpp;
            return 2;
        }
        else {
            ErrorF("Invalid fbbpp\n");
            return 0;
        }
    }
    if (!strcmp(argv[i], "-depth")) {
        int depth;

        CHECK_FOR_REQUIRED_ARGUMENT();
        if (sscanf(argv[++i], "%d", &depth) == 1) {
            xf86Depth = depth;
            return 2;
        }
        else {
            ErrorF("Invalid depth\n");
            return 0;
        }
    }
    if (!strcmp(argv[i], "-weight")) {
        int red, green, blue;

        CHECK_FOR_REQUIRED_ARGUMENT();
        if (sscanf(argv[++i], "%1d%1d%1d", &red, &green, &blue) == 3) {
            xf86Weight.red = red;
            xf86Weight.green = green;
            xf86Weight.blue = blue;
            return 2;
        }
        else {
            ErrorF("Invalid weighting\n");
            return 0;
        }
    }
    if (!strcmp(argv[i], "-gamma") || !strcmp(argv[i], "-rgamma") ||
        !strcmp(argv[i], "-ggamma") || !strcmp(argv[i], "-bgamma")) {
        double gamma;

        CHECK_FOR_REQUIRED_ARGUMENT();
        if (sscanf(argv[++i], "%lf", &gamma) == 1) {
            if (gamma < GAMMA_MIN || gamma > GAMMA_MAX) {
                ErrorF("gamma out of range, only  %.2f <= gamma_value <= %.1f"
                       " is valid\n", GAMMA_MIN, GAMMA_MAX);
                return 0;
            }
            if (!strcmp(argv[i - 1], "-gamma"))
                xf86Gamma.red = xf86Gamma.green = xf86Gamma.blue = gamma;
            else if (!strcmp(argv[i - 1], "-rgamma"))
                xf86Gamma.red = gamma;
            else if (!strcmp(argv[i - 1], "-ggamma"))
                xf86Gamma.green = gamma;
            else if (!strcmp(argv[i - 1], "-bgamma"))
                xf86Gamma.blue = gamma;
            return 2;
        }
    }
    if (!strcmp(argv[i], "-layout")) {
        CHECK_FOR_REQUIRED_ARGUMENT();
        xf86LayoutName = argv[++i];
        return 2;
    }
    if (!strcmp(argv[i], "-screen")) {
        CHECK_FOR_REQUIRED_ARGUMENT();
        xf86ScreenName = argv[++i];
        return 2;
    }
    if (!strcmp(argv[i], "-pointer")) {
        CHECK_FOR_REQUIRED_ARGUMENT();
        xf86PointerName = argv[++i];
        return 2;
    }
    if (!strcmp(argv[i], "-keyboard")) {
        CHECK_FOR_REQUIRED_ARGUMENT();
        xf86KeyboardName = argv[++i];
        return 2;
    }
    if (!strcmp(argv[i], "-nosilk")) {
        xf86silkenMouseDisableFlag = TRUE;
        return 1;
    }
#ifdef HAVE_ACPI
    if (!strcmp(argv[i], "-noacpi")) {
        xf86acpiDisableFlag = TRUE;
        return 1;
    }
#endif
#ifdef X_PRIVSEP
    if (!strcmp(argv[i], "-keepPriv")) {
        if (getuid() != 0) {
            ErrorF("The '-keepPriv' option can only be used by root.\n");
            exit(1);
        }
        xf86KeepPriv = TRUE;
        return 1;
    }
#endif
    if (!strcmp(argv[i], "-showopts")) {
        if (getuid() != 0 && geteuid() == 0) {
            ErrorF("The '-showopts' option can only be used by root.\n");
            exit(1);
        }
        xf86DoShowOptions = TRUE;
        return 1;
    }
#ifdef XSERVER_LIBPCIACCESS
    if (!strcmp(argv[i], "-isolateDevice")) {
        CHECK_FOR_REQUIRED_ARGUMENT();
        if (strncmp(argv[++i], "PCI:", 4)) {
            FatalError("Bus types other than PCI not yet isolable\n");
        }
        xf86PciIsolateDevice(argv[i]);
        return 2;
    }
#endif
    /* Notice cmdline xkbdir, but pass to dix as well */
    if (!strcmp(argv[i], "-xkbdir")) {
        xf86xkbdirFlag = TRUE;
        return 0;
    }
    if (!strcmp(argv[i], "-novtswitch")) {
        xf86Info.autoVTSwitch = FALSE;
        return 1;
    }
    if (!strcmp(argv[i], "-sharevts")) {
        xf86Info.ShareVTs = TRUE;
        return 1;
    }
    if (!strcmp(argv[i], "-iglx") || !strcmp(argv[i], "+iglx")) {
        xf86Info.iglxFrom = X_CMDLINE;
        return 0;
    }

    /* OS-specific processing */
    return xf86ProcessArgument(argc, argv, i);
}

/*
 * ddxUseMsg --
 *	Print out correct use of device dependent commandline options.
 *      Maybe the user now knows what really to do ...
 */

void
ddxUseMsg(void)
{
    ErrorF("\n");
    ErrorF("\n");
    ErrorF("Device Dependent Usage\n");
    if (!xf86PrivsElevated()) {
        ErrorF("-modulepath paths      specify the module search path\n");
        ErrorF("-logfile file          specify a log file name\n");
        ErrorF("-configure             probe for devices and write an "
               __XCONFIGFILE__ "\n");
        ErrorF
            ("-showopts              print available options for all installed drivers\n");
    }
    ErrorF
        ("-config file           specify a configuration file, relative to the\n");
    ErrorF("                       " __XCONFIGFILE__
           " search path, only root can use absolute\n");
    ErrorF
        ("-configdir dir         specify a configuration directory, relative to the\n");
    ErrorF("                       " __XCONFIGDIR__
           " search path, only root can use absolute\n");
    ErrorF("-verbose [n]           verbose startup messages\n");
    ErrorF("-logverbose [n]        verbose log messages\n");
    ErrorF("-quiet                 minimal startup messages\n");
    ErrorF("-pixmap24              use 24bpp pixmaps for depth 24\n");
    ErrorF("-pixmap32              use 32bpp pixmaps for depth 24\n");
    ErrorF("-fbbpp n               set bpp for the framebuffer. Default: 8\n");
    ErrorF("-depth n               set colour depth. Default: 8\n");
    ErrorF
        ("-gamma f               set gamma value (0.1 < f < 10.0) Default: 1.0\n");
    ErrorF("-rgamma f              set gamma value for red phase\n");
    ErrorF("-ggamma f              set gamma value for green phase\n");
    ErrorF("-bgamma f              set gamma value for blue phase\n");
    ErrorF
        ("-weight nnn            set RGB weighting at 16 bpp.  Default: 565\n");
    ErrorF("-layout name           specify the ServerLayout section name\n");
    ErrorF("-screen name           specify the Screen section name\n");
    ErrorF
        ("-keyboard name         specify the core keyboard InputDevice name\n");
    ErrorF
        ("-pointer name          specify the core pointer InputDevice name\n");
    ErrorF("-nosilk                disable Silken Mouse\n");
    ErrorF("-flipPixels            swap default black/white Pixel values\n");
#ifdef XF86VIDMODE
    ErrorF("-disableVidMode        disable mode adjustments with xvidtune\n");
    ErrorF
        ("-allowNonLocalXvidtune allow xvidtune to be run as a non-local client\n");
#endif
    ErrorF
        ("-allowMouseOpenFail    start server even if the mouse can't be initialized\n");
    ErrorF("-ignoreABI             make module ABI mismatches non-fatal\n");
#ifdef XSERVER_LIBPCIACCESS
    ErrorF
        ("-isolateDevice bus_id  restrict device resets to bus_id (PCI only)\n");
#endif
    ErrorF("-version               show the server version\n");
    ErrorF("-showDefaultModulePath show the server default module path\n");
    ErrorF("-showDefaultLibPath    show the server default library path\n");
    ErrorF
        ("-novtswitch            don't automatically switch VT at reset & exit\n");
    ErrorF("-sharevts              share VTs with another X server\n");
#ifdef X_PRIVSEP
    ErrorF("-keepPriv		 don't revoque privs when running as root\n");
#endif
    /* OS-specific usage */
    xf86UseMsg();
    ErrorF("\n");
}

/*
 * xf86LoadModules iterates over a list that is being passed in.
 */
Bool
xf86LoadModules(const char **list, void **optlist)
{
    int errmaj, errmin;
    void *opt;
    int i;
    char *name;
    Bool failed = FALSE;

    if (!list)
        return TRUE;

    for (i = 0; list[i] != NULL; i++) {

        /* Normalise the module name */
        name = xf86NormalizeName(list[i]);

        /* Skip empty names */
        if (name == NULL || *name == '\0') {
            free(name);
            continue;
        }

        /* Replace obsolete keyboard driver with kbd */
        if (!xf86NameCmp(name, "keyboard")) {
            strcpy(name, "kbd");
        }

        if (optlist)
            opt = optlist[i];
        else
            opt = NULL;

        if (!LoadModule(name, NULL, NULL, NULL, opt, NULL, &errmaj, &errmin)) {
            LoaderErrorMsg(NULL, name, errmaj, errmin);
            failed = TRUE;
        }
        free(name);
    }
    return !failed;
}

/* Pixmap format stuff */

PixmapFormatPtr
xf86GetPixFormat(ScrnInfoPtr pScrn, int depth)
{
    int i;
    static PixmapFormatRec format;      /* XXX not reentrant */

    /*
     * When the formats[] list initialisation isn't complete, check the
     * depth 24 pixmap config/cmdline options and screen-specified formats.
     */

    if (!formatsDone) {
        if (depth == 24) {
            Pix24Flags pix24 = Pix24DontCare;

            format.depth = 24;
            format.scanlinePad = BITMAP_SCANLINE_PAD;
            if (xf86Info.pixmap24 != Pix24DontCare)
                pix24 = xf86Info.pixmap24;
            else if (pScrn->pixmap24 != Pix24DontCare)
                pix24 = pScrn->pixmap24;
            if (pix24 == Pix24Use24)
                format.bitsPerPixel = 24;
            else
                format.bitsPerPixel = 32;
            return &format;
        }
    }

    for (i = 0; i < numFormats; i++)
        if (formats[i].depth == depth)
            break;
    if (i != numFormats)
        return &formats[i];
    else if (!formatsDone) {
        /* Check for screen-specified formats */
        for (i = 0; i < pScrn->numFormats; i++)
            if (pScrn->formats[i].depth == depth)
                break;
        if (i != pScrn->numFormats)
            return &pScrn->formats[i];
    }
    return NULL;
}

int
xf86GetBppFromDepth(ScrnInfoPtr pScrn, int depth)
{
    PixmapFormatPtr format;

    format = xf86GetPixFormat(pScrn, depth);
    if (format)
        return format->bitsPerPixel;
    else
        return 0;
}

#ifdef DDXBEFORERESET
void
ddxBeforeReset(void)
{
}
#endif
@


1.24
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d1476 4
@


1.23
log
@Cleanup gcc warnings and function prototypes.
@
text
@d75 1
@


1.22
log
@Remove the -configure option. This has been broken for a loong time
and no one is going to fix it.
@
text
@a989 5
#ifdef X_PRIVSEP
extern void xf86DropPriv(char *);
extern void xf86PrivilegedInit(void);
#endif
 
d1026 1
a1026 1
	  xf86DropPriv(display);
@


1.21
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a1438 12
    if (!strcmp(argv[i], "-configure")) {
        if (getuid() != 0 && geteuid() == 0) {
            ErrorF("The '-configure' option can only be used by root.\n");
            exit(1);
        }
        xf86DoConfigure = TRUE;
        xf86AllowMouseOpenFail = TRUE;
#ifdef X_PRIVSEP
        xf86KeepPriv = TRUE;
#endif
        return 1;
    }
@


1.20
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a58 2
#include "compiler.h"

a239 6
static void
xf86PrintMarkers(void)
{
    LogPrintMarkers();
}

a314 8
    if (pScreen->CreateWindow != xf86CreateRootWindow) {
        /* Can't find hook we are hung on */
        xf86DrvMsg(pScreen->myNum, X_WARNING /* X_ERROR */ ,
                   "xf86CreateRootWindow %p called when not in pScreen->CreateWindow %p n",
                   (void *) xf86CreateRootWindow,
                   (void *) pScreen->CreateWindow);
    }

a341 6
        else {
            xf86Msg(X_ERROR, "xf86CreateRootWindow unexpectedly called with "
                    "non-root window %p (parent %p)\n",
                    (void *) pWin, (void *) pWin->parent);
            ret = FALSE;
        }
a343 1
    DebugF("xf86CreateRootWindow() returns %d\n", ret);
d407 1
a407 1
        xf86PrintMarkers();
@


1.19
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d56 2
d318 1
a318 1
    CreateWindowProcPtr CreateWindow = (CreateWindowProcPtr)
d332 1
a332 1
    pScreen->CreateWindow = CreateWindow;
d394 5
d409 2
a410 2
    char **modulelist;
    pointer *optionlist;
d470 3
d561 2
a562 1
            if (!(flags & HW_SKIP_CONSOLE))
d641 3
a643 1
                XNFasprintf(&xf86Screens[i]->name, "screen%d", i);
d743 1
d745 1
d758 2
d767 5
d774 1
a774 1
                               "Failed to register VT property\n");
d1096 3
d1600 1
a1600 1
xf86LoadModules(char **list, pointer *optlist)
d1603 1
a1603 1
    pointer opt;
@


1.18
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d826 1
a826 1
        if (!xf86Screens[0]->vtSema) {
@


1.17
log
@Remove white space diff with X.Org.
@
text
@d401 1
a401 1
    int i, j, k, scr_index, was_blocked = 0;
d408 2
d414 2
d480 2
d538 2
d543 7
a549 2
            if (!xorgHWAccess || !xorgHWOpenConsole) {
                xorgHWFlags flags;
d551 2
a552 11
                if (!xf86DriverList[i]->driverFunc
                    || !xf86DriverList[i]->driverFunc(NULL,
                                                      GET_REQUIRED_HW_INTERFACES,
                                                      &flags))
                    flags = HW_IO;

                if (NEED_IO_ENABLED(flags))
                    xorgHWAccess = TRUE;
                if (!(flags & HW_SKIP_CONSOLE))
                    xorgHWOpenConsole = TRUE;
            }
d560 4
d604 13
a616 1
                xf86DeleteScreen(i--, 0);
d831 2
a832 1
            was_blocked = xf86BlockSIGIO();
d844 30
d934 3
d938 2
a939 1
    xf86UnblockSIGIO(was_blocked);
a1034 1
    xf86UnblockSIGIO(0);
d1093 1
a1093 1
    xf86BlockSIGIO();
d1111 1
a1111 1
                (xf86Screens[i]->LeaveVT) (i, 0);
d1126 1
a1126 1
OsVendorFatalError(void)
d1129 2
a1130 2
    ErrorF("\nPlease refer to your Operating System Vendor support pages\n"
           "at %s for support on this crash.\n", VENDORSUPPORT);
d1132 2
a1133 2
    ErrorF("\nPlease consult the " XVENDORNAME " support \n"
           "\t at " __VENDORDWEBSUPPORT__ "\n for help. \n");
d1136 3
a1138 3
        ErrorF("Please also check the log file at \"%s\" for additional "
               "information.\n", xf86LogFile);
    ErrorF("\n");
d1234 1
a1234 1
	    xf86KeepPriv = TRUE;
d1451 1
a1451 1
        if (getuid() != 0 && geteuid() == 0) {
d1564 1
a1564 2
    ErrorF("-keepPriv              "
           "don't revoque privileges when running as root\n");
d1674 7
@


1.16
log
@Update to xserver 1.12.3.
@
text
@d981 1
@


1.15
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d980 1
a980 1

@


1.14
log
@Update to xserver 1.11.2
@
text
@d81 1
d83 1
d85 1
a92 1

d94 1
a94 1
void (*xf86OSPMClose)(void) = NULL;
d101 7
a107 7
	{ 1,	1,	BITMAP_SCANLINE_PAD },
	{ 4,	8,	BITMAP_SCANLINE_PAD },
	{ 8,	8,	BITMAP_SCANLINE_PAD },
	{ 15,	16,	BITMAP_SCANLINE_PAD },
	{ 16,	16,	BITMAP_SCANLINE_PAD },
	{ 24,	32,	BITMAP_SCANLINE_PAD },
	{ 32,	32,	BITMAP_SCANLINE_PAD },
d109 1
d131 11
a141 13
  xf86ErrorFVerb(0, "\n"
    "This is a pre-release version of the X server from " XVENDORNAME ".\n"
    "It is not supported in any way.\n"
    "Bugs may be filed in the bugzilla at http://bugs.freedesktop.org/.\n"
    "Select the \"xorg\" product for bugs you find in this release.\n"
    "Before reporting bugs in pre-release versions please check the\n"
    "latest version in the X.Org Foundation git repository.\n"
    "See http://wiki.x.org/wiki/GitPage for git access instructions.\n");
#endif
  xf86ErrorFVerb(0, "\nX.Org X Server %d.%d.%d",
	 XORG_VERSION_MAJOR,
	 XORG_VERSION_MINOR,
	 XORG_VERSION_PATCH);
d143 1
a143 1
  xf86ErrorFVerb(0, ".%d", XORG_VERSION_SNAP);
d147 7
a153 7
  /* When the minor number is 99, that signifies that the we are making
   * a release candidate for a major version.  (X.0.0)
   * When the patch number is 99, that signifies that the we are making
   * a release candidate for a minor version.  (X.Y.0)
   * When the patch number is < 99, then we are making a release
   * candidate for the next point release.  (X.Y.Z)
   */
d155 2
a156 2
  xf86ErrorFVerb(0, " (%d.0.0 RC %d)", XORG_VERSION_MAJOR+1,
                 XORG_VERSION_SNAP - 900);
d158 2
a159 2
  xf86ErrorFVerb(0, " (%d.%d.0 RC %d)", XORG_VERSION_MAJOR,
                 XORG_VERSION_MINOR + 1, XORG_VERSION_SNAP - 900);
d161 3
a163 3
  xf86ErrorFVerb(0, " (%d.%d.%d RC %d)", XORG_VERSION_MAJOR,
                 XORG_VERSION_MINOR, XORG_VERSION_PATCH + 1,
                 XORG_VERSION_SNAP - 900);
d168 1
a168 1
  xf86ErrorFVerb(0, " (%s)", XORG_CUSTOM_VERSION);
d171 1
a171 1
# define XORG_DATE "Unknown"
d173 4
a176 4
  xf86ErrorFVerb(0, "\nRelease Date: %s\n", XORG_DATE);
  xf86ErrorFVerb(0, "X Protocol Version %d, Revision %d\n",
         X_PROTOCOL, X_PROTOCOL_REVISION);
  xf86ErrorFVerb(0, "Build Operating System: %s %s\n", OSNAME, OSVENDOR);
d178 2
a179 2
  {
    struct utsname name;
d181 8
a188 7
    /* Linux & BSD state that 0 is success, SysV (including Solaris, HP-UX,
       and Irix) and Single Unix Spec 3 just say that non-negative is success.
       All agree that failure is represented by a negative number.
     */
    if (uname(&name) >= 0) {
      xf86ErrorFVerb(0, "Current Operating System: %s %s %s %s %s\n",
	name.sysname, name.nodename, name.release, name.version, name.machine);
d190 14
a203 13
      do {
	  char buf[80];
	  int fd = open("/proc/cmdline", O_RDONLY);
	  if (fd != -1) {
	    xf86ErrorFVerb(0, "Kernel command line: ");
	    memset(buf, 0, 80);
	    while (read(fd, buf, 80) > 0) {
		xf86ErrorFVerb(0, "%.80s", buf);
		memset(buf, 0, 80);
	    }
	    close(fd);
	  } 
      } while (0);
d205 1
a206 1
  }
d209 9
a217 9
  {
    struct tm t;
    char buf[100];

    memset(&t, 0, sizeof(t));
    memset(buf, 0, sizeof(buf));
    t.tm_mday = BUILD_DATE % 100;
    t.tm_mon = (BUILD_DATE / 100) % 100 - 1;
    t.tm_year = BUILD_DATE / 10000 - 1900;
d219 5
a223 5
    t.tm_sec = BUILD_TIME % 100;
    t.tm_min = (BUILD_TIME / 100) % 100;
    t.tm_hour = (BUILD_TIME / 10000) % 100;
    if (strftime(buf, sizeof(buf), "%d %B %Y  %I:%M:%S%p", &t))
       xf86ErrorFVerb(0, "Build Date: %s\n", buf);
d225 2
a226 2
    if (strftime(buf, sizeof(buf), "%d %B %Y", &t))
       xf86ErrorFVerb(0, "Build Date: %s\n", buf);
d228 1
a228 1
  }
d231 1
a231 1
  xf86ErrorFVerb(0, "%s \n", BUILDERSTRING);
d233 5
a237 5
  xf86ErrorFVerb(0, "Current version of pixman: %s\n",
                 pixman_version_string());
  xf86ErrorFVerb(0, "\tBefore reporting problems, check "
                 ""__VENDORDWEBSUPPORT__"\n"
                 "\tto make sure that you have the latest version.\n");
d243 64
a306 1
  LogPrintMarkers();
d312 39
a350 16
  int ret = TRUE;
  int err = Success;
  ScreenPtr pScreen = pWin->drawable.pScreen;
  RootWinPropPtr pProp;
  CreateWindowProcPtr CreateWindow = (CreateWindowProcPtr)
      dixLookupPrivate(&pScreen->devPrivates, xf86CreateRootWindowKey);

  DebugF("xf86CreateRootWindow(%p)\n", pWin);

  if ( pScreen->CreateWindow != xf86CreateRootWindow ) {
    /* Can't find hook we are hung on */
	xf86DrvMsg(pScreen->myNum, X_WARNING /* X_ERROR */,
		  "xf86CreateRootWindow %p called when not in pScreen->CreateWindow %p n",
		   (void *)xf86CreateRootWindow,
		   (void *)pScreen->CreateWindow );
  }
d352 2
a353 8
  /* Unhook this function ... */
  pScreen->CreateWindow = CreateWindow;
  dixSetPrivate(&pScreen->devPrivates, xf86CreateRootWindowKey, NULL);

  /* ... and call the previous CreateWindow fuction, if any */
  if (NULL!=pScreen->CreateWindow) {
    ret = (*pScreen->CreateWindow)(pWin);
  }
d355 7
a361 25
  /* Now do our stuff */
  if (xf86RegisteredPropertiesTable != NULL) {
    if (pWin->parent == NULL && xf86RegisteredPropertiesTable != NULL) {
      for (pProp = xf86RegisteredPropertiesTable[pScreen->myNum];
	   pProp != NULL && err==Success;
	   pProp = pProp->next )
	{
	  Atom prop;

	  prop = MakeAtom(pProp->name, strlen(pProp->name), TRUE);
	  err = dixChangeWindowProperty(serverClient, pWin,
					prop, pProp->type,
					pProp->format, PropModeReplace,
					pProp->size, pProp->data,
					FALSE);
	}

      /* Look at err */
      ret &= (err==Success);

    } else {
      xf86Msg(X_ERROR, "xf86CreateRootWindow unexpectedly called with "
	      "non-root window %p (parent %p)\n",
	      (void *)pWin, (void *)pWin->parent);
      ret = FALSE;
a362 1
  }
d364 2
a365 2
  DebugF("xf86CreateRootWindow() returns %d\n", ret);
  return ret;
a367 1

d374 1
a374 1
    xf86Info.caughtSignal=FALSE;
d376 5
a380 4
	OsRegisterSigWrapper(xf86SigWrapper);
    } else {
	signal(SIGSEGV, SIG_DFL);
	signal(SIGILL, SIG_DFL);
d382 1
a382 1
	signal(SIGEMT, SIG_DFL);
d384 5
a388 5
	signal(SIGFPE, SIG_DFL);
	signal(SIGBUS, SIG_DFL);
	signal(SIGSYS, SIG_DFL);
	signal(SIGXCPU, SIG_DFL);
	signal(SIGXFSZ, SIG_DFL);
d399 1
a399 1
InitOutput(ScreenInfo *pScreenInfo, int argc, char **argv)
d401 42
a442 16
  int                    i, j, k, scr_index, was_blocked = 0;
  char                   **modulelist;
  pointer                *optionlist;
  Pix24Flags		 screenpix24, pix24;
  MessageType		 pix24From = X_DEFAULT;
  Bool			 pix24Fail = FALSE;
  Bool			 autoconfig = FALSE;
  GDevPtr		 configured_device;

  xf86Initialising = TRUE;

  if (serverGeneration == 1) {
    if ((xf86ServerName = strrchr(argv[0], '/')) != 0)
      xf86ServerName++;
    else
      xf86ServerName = argv[0];
d444 1
a444 26
	xf86PrintBanner();
	xf86PrintMarkers();
	if (xf86LogFile)  {
	    time_t t;
	    const char *ct;
	    t = time(NULL);
	    ct = ctime(&t);
	    xf86MsgVerb(xf86LogFileFrom, 0, "Log file: \"%s\", Time: %s",
			xf86LogFile, ct);
	}

    /* Read and parse the config file */
    if (!xf86DoConfigure && !xf86DoShowOptions) {
      switch (xf86HandleConfigFile(FALSE)) {
      case CONFIG_OK:
	break;
      case CONFIG_PARSE_ERROR:
	xf86Msg(X_ERROR, "Error parsing the config file\n");
	return;
      case CONFIG_NOFILE:
	autoconfig = TRUE;
	break;
      }
    }

    InstallSignalHandlers();
d446 2
a447 2
    /* Initialise the loader */
    LoaderInit();
d449 2
a450 2
    /* Tell the loader the default module search path */
    LoaderSetPath(xf86ModulePath);
d452 3
a454 3
    if (xf86Info.ignoreABI) {
        LoaderSetOptions(LDR_OPT_ABI_MISMATCH_NONFATAL);
    }
d456 2
a457 2
    if (xf86DoShowOptions)
        DoShowOptions();
d459 2
a460 2
    /* Do a general bus probe.  This will be a PCI probe for x86 platforms */
    xf86BusProbe();
d462 2
a463 2
    if (xf86DoConfigure)
	DoConfigure();
d465 6
a470 6
    if (autoconfig) {
	if (!xf86AutoConfig()) {
	    xf86Msg(X_ERROR, "Auto configuration failed\n");
	    return;
	}
    }
d473 1
a473 1
    xf86OSPMClose = xf86OSPMOpen();
d476 22
a497 6
    /* Load all modules specified explicitly in the config file */
    if ((modulelist = xf86ModulelistFromConfig(&optionlist))) {
      xf86LoadModules(modulelist, optionlist);
      free(modulelist);
      free(optionlist);
    }
d499 4
a502 9
    /* Load all driver modules specified in the config file */
    /* If there aren't any specified in the config file, autoconfig them */
    /* FIXME: Does not handle multiple active screen sections, but I'm not
     * sure if we really want to handle that case*/
    configured_device = xf86ConfigLayout.screens->screen->device;
    if ((!configured_device) || (!configured_device->driver)) {
        if (!autoConfigDevice(configured_device)) {
            xf86Msg(X_ERROR, "Automatic driver configuration failed\n");
            return ;
a503 5
    }
    if ((modulelist = xf86DriverlistFromConfig())) {
      xf86LoadModules(modulelist, NULL);
      free(modulelist);
    }
d505 18
a522 5
    /* Load all input driver modules specified in the config file. */
    if ((modulelist = xf86InputDriverlistFromConfig())) {
      xf86LoadModules(modulelist, NULL);
      free(modulelist);
    }
d524 6
a529 7
    /*
     * It is expected that xf86AddDriver()/xf86AddInputDriver will be
     * called for each driver as it is loaded.  Those functions save the
     * module pointers for drivers.
     * XXX Nothing keeps track of them for other modules.
     */
    /* XXX What do we do if not all of these could be loaded? */
d531 19
a549 5
    /*
     * At this point, xf86DriverList[] is all filled in with entries for
     * each of the drivers to try and xf86NumDrivers has the number of
     * drivers.  If there are none, return now.
     */
d551 29
a579 4
    if (xf86NumDrivers == 0) {
      xf86Msg(X_ERROR, "No drivers available.\n");
      return;
    }
d581 4
a584 6
    /*
     * Call each of the Identify functions and call the driverFunc to check
     * if HW access is required.  The Identify functions print out some
     * identifying information, and anything else that might be
     * needed at this early stage.
     */
d586 11
a596 18
    for (i = 0; i < xf86NumDrivers; i++) {
	if (xf86DriverList[i]->Identify != NULL)
	    xf86DriverList[i]->Identify(0);

	if (!xorgHWAccess || !xorgHWOpenConsole) {
	    xorgHWFlags flags;
	    if(!xf86DriverList[i]->driverFunc
		|| !xf86DriverList[i]->driverFunc(NULL,
						  GET_REQUIRED_HW_INTERFACES,
						  &flags))
		flags = HW_IO;

	    if(NEED_IO_ENABLED(flags))
		xorgHWAccess = TRUE;
	    if(!(flags & HW_SKIP_CONSOLE))
		xorgHWOpenConsole = TRUE;
	}
    }
d598 3
a600 4
    if (xorgHWOpenConsole)
	xf86OpenConsole();
    else
	xf86Info.dontVTSwitch = TRUE;
d602 5
a606 2
    if (xf86BusConfig() == FALSE)
        return;
d608 8
a615 1
    xf86PostProbe();
d617 4
a620 18
    /*
     * Sort the drivers to match the requested ording.  Using a slow
     * bubble sort.
     */
    for (j = 0; j < xf86NumScreens - 1; j++) {
	for (i = 0; i < xf86NumScreens - j - 1; i++) {
	    if (xf86Screens[i + 1]->confScreen->screennum <
		xf86Screens[i]->confScreen->screennum) {
		ScrnInfoPtr tmpScrn = xf86Screens[i + 1];
		xf86Screens[i + 1] = xf86Screens[i];
		xf86Screens[i] = tmpScrn;
	    }
	}
    }
    /* Fix up the indexes */
    for (i = 0; i < xf86NumScreens; i++) {
	xf86Screens[i]->scrnIndex = i;
    }
d622 3
a624 4
    /*
     * Call the driver's PreInit()'s to complete initialisation for the first
     * generation.
     */
d626 2
a627 11
    for (i = 0; i < xf86NumScreens; i++) {
	xf86VGAarbiterScrnInit(xf86Screens[i]);
	xf86VGAarbiterLock(xf86Screens[i]);
	if (xf86Screens[i]->PreInit &&
	    xf86Screens[i]->PreInit(xf86Screens[i], 0))
	    xf86Screens[i]->configured = TRUE;
	xf86VGAarbiterUnlock(xf86Screens[i]);
    }
    for (i = 0; i < xf86NumScreens; i++)
	if (!xf86Screens[i]->configured)
	    xf86DeleteScreen(i--, 0);
d629 44
a672 3
    /*
     * If no screens left, return now.
     */
d674 32
a705 5
    if (xf86NumScreens == 0) {
      xf86Msg(X_ERROR,
	      "Screen(s) found, but none have a usable configuration.\n");
      return;
    }
d707 28
a734 8
    for (i = 0; i < xf86NumScreens; i++) {
      if (xf86Screens[i]->name == NULL) {
	XNFasprintf(&xf86Screens[i]->name, "screen%d", i);
	xf86MsgVerb(X_WARNING, 0,
		    "Screen driver %d has no name set, using `%s'.\n",
		    i, xf86Screens[i]->name);
      }
    }
d736 2
a737 4
    /* Remove (unload) drivers that are not required */
    for (i = 0; i < xf86NumDrivers; i++)
	if (xf86DriverList[i] && xf86DriverList[i]->refCount <= 0)
	    xf86DeleteDriver(i);
d739 2
a740 3
    /*
     * At this stage we know how many screens there are.
     */
d742 2
a743 2
    for (i = 0; i < xf86NumScreens; i++)
      xf86InitViewport(xf86Screens[i]);
d745 10
a754 47
    /*
     * Collect all pixmap formats and check for conflicts at the display
     * level.  Should we die here?  Or just delete the offending screens?
     */
    screenpix24 = Pix24DontCare;
    for (i = 0; i < xf86NumScreens; i++) {
	if (xf86Screens[i]->imageByteOrder !=
	    xf86Screens[0]->imageByteOrder)
	    FatalError("Inconsistent display bitmapBitOrder.  Exiting\n");
	if (xf86Screens[i]->bitmapScanlinePad !=
	    xf86Screens[0]->bitmapScanlinePad)
	    FatalError("Inconsistent display bitmapScanlinePad.  Exiting\n");
	if (xf86Screens[i]->bitmapScanlineUnit !=
	    xf86Screens[0]->bitmapScanlineUnit)
	    FatalError("Inconsistent display bitmapScanlineUnit.  Exiting\n");
	if (xf86Screens[i]->bitmapBitOrder !=
	    xf86Screens[0]->bitmapBitOrder)
	    FatalError("Inconsistent display bitmapBitOrder.  Exiting\n");

	/* Determine the depth 24 pixmap format the screens would like */
	if (xf86Screens[i]->pixmap24 != Pix24DontCare) {
	    if (screenpix24 == Pix24DontCare)
		screenpix24 = xf86Screens[i]->pixmap24;
	    else if (screenpix24 != xf86Screens[i]->pixmap24)
		FatalError("Inconsistent depth 24 pixmap format.  Exiting\n");
	}
    }
    /* check if screenpix24 is consistent with the config/cmdline */
    if (xf86Info.pixmap24 != Pix24DontCare) {
	pix24 = xf86Info.pixmap24;
	pix24From = xf86Info.pix24From;
	if (screenpix24 != Pix24DontCare && screenpix24 != xf86Info.pixmap24)
	    pix24Fail = TRUE;
    } else if (screenpix24 != Pix24DontCare) {
	pix24 = screenpix24;
	pix24From = X_PROBED;
    } else
	pix24 = Pix24Use32;

    if (pix24Fail)
	FatalError("Screen(s) can't use the required depth 24 pixmap format"
		   " (%d).  Exiting\n", PIX24TOBPP(pix24));

    /* Initialise the depth 24 format */
    for (j = 0; j < numFormats && formats[j].depth != 24; j++)
	;
    formats[j].bitsPerPixel = PIX24TOBPP(pix24);
d756 8
a763 22
    /* Collect additional formats */
    for (i = 0; i < xf86NumScreens; i++) {
	for (j = 0; j < xf86Screens[i]->numFormats; j++) {
	    for (k = 0; ; k++) {
		if (k >= numFormats) {
		    if (k >= MAXFORMATS)
			FatalError("Too many pixmap formats!  Exiting\n");
		    formats[k] = xf86Screens[i]->formats[j];
		    numFormats++;
		    break;
		}
		if (formats[k].depth == xf86Screens[i]->formats[j].depth) {
		    if ((formats[k].bitsPerPixel ==
			 xf86Screens[i]->formats[j].bitsPerPixel) &&
		        (formats[k].scanlinePad ==
			 xf86Screens[i]->formats[j].scanlinePad))
			break;
		    FatalError("Inconsistent pixmap format for depth %d."
			       "  Exiting\n", formats[k].depth);
		}
	    }
	}
d765 6
a770 1
    formatsDone = TRUE;
d772 15
a786 24
    if (xf86Info.vtno >= 0 ) {
#define VT_ATOM_NAME         "XFree86_VT"
      Atom VTAtom=-1;
      CARD32  *VT = NULL;
      int  ret;

      /* This memory needs to stay available until the screen has been
	 initialized, and we can create the property for real.
      */
      if ( (VT = malloc(sizeof(CARD32)))==NULL ) {
	FatalError("Unable to make VT property - out of memory. Exiting...\n");
      }
      *VT = xf86Info.vtno;

      VTAtom = MakeAtom(VT_ATOM_NAME, sizeof(VT_ATOM_NAME) - 1, TRUE);

      for (i = 0, ret = Success; i < xf86NumScreens && ret == Success; i++) {
	ret = xf86RegisterRootWindowProperty(xf86Screens[i]->scrnIndex,
					     VTAtom, XA_INTEGER, 32,
					     1, VT );
	if (ret != Success)
	  xf86DrvMsg(xf86Screens[i]->scrnIndex, X_WARNING,
		     "Failed to register VT property\n");
      }
a788 9
    /* If a screen uses depth 24, show what the pixmap format is */
    for (i = 0; i < xf86NumScreens; i++) {
	if (xf86Screens[i]->depth == 24) {
	    xf86Msg(pix24From, "Depth 24 pixmap format is %d bpp\n",
		    PIX24TOBPP(pix24));
	    break;
	}
    }
  } else {
d790 1
a790 1
     * serverGeneration != 1; some OSs have to do things here, too.
a791 2
    if (xorgHWOpenConsole)
	xf86OpenConsole();
d793 7
a799 11
#ifdef XF86PM
    /*
      should we reopen it here? We need to deal with an already opened
      device. We could leave this to the OS layer. For now we simply
      close it here
    */
    if (xf86OSPMClose)
        xf86OSPMClose();
    if ((xf86OSPMClose = xf86OSPMOpen()) != NULL)
	xf86MsgVerb(X_INFO, 3, "APM registered successfully\n");
#endif
d801 1
a801 4
    /* Make sure full I/O access is enabled */
    if (xorgHWAccess)
	xf86EnableIO();
  }
d803 4
a806 18
  /*
   * Use the previously collected parts to setup pScreenInfo
   */

  pScreenInfo->imageByteOrder = xf86Screens[0]->imageByteOrder;
  pScreenInfo->bitmapScanlinePad = xf86Screens[0]->bitmapScanlinePad;
  pScreenInfo->bitmapScanlineUnit = xf86Screens[0]->bitmapScanlineUnit;
  pScreenInfo->bitmapBitOrder = xf86Screens[0]->bitmapBitOrder;
  pScreenInfo->numPixmapFormats = numFormats;
  for (i = 0; i < numFormats; i++)
    pScreenInfo->formats[i] = formats[i];

  /* Make sure the server's VT is active */

  if (serverGeneration != 1) {
    xf86Resetting = TRUE;
    /* All screens are in the same state, so just check the first */
    if (!xf86Screens[0]->vtSema) {
d808 1
a808 1
      ioctl(xf86Info.consoleFd, VT_RELDISP, VT_ACKACQ);
d810 3
a812 2
      xf86AccessEnter();
      was_blocked = xf86BlockSIGIO();
a813 1
  }
d815 15
a829 15
  for (i = 0; i < xf86NumScreens; i++)
      if (!xf86ColormapAllocatePrivates(xf86Screens[i]))
	  FatalError("Cannot register DDX private keys");

  if (!dixRegisterPrivateKey(&xf86ScreenKeyRec, PRIVATE_SCREEN, 0) ||
      !dixRegisterPrivateKey(&xf86CreateRootWindowKeyRec, PRIVATE_SCREEN, 0))
      FatalError("Cannot register DDX private keys");

  for (i = 0; i < xf86NumScreens; i++) {
	xf86VGAarbiterLock(xf86Screens[i]);
	/*
	 * Almost everything uses these defaults, and many of those that
	 * don't, will wrap them.
	 */
	xf86Screens[i]->EnableDisableFBAccess = xf86EnableDisableFBAccess;
d831 1
a831 1
	xf86Screens[i]->SetDGAMode = xf86SetDGAMode;
d833 22
a854 31
	xf86Screens[i]->DPMSSet = NULL;
	xf86Screens[i]->LoadPalette = NULL;
	xf86Screens[i]->SetOverscan = NULL;
	xf86Screens[i]->DriverFunc = NULL;
	xf86Screens[i]->pScreen = NULL;
	scr_index = AddScreen(xf86Screens[i]->ScreenInit, argc, argv);
	xf86VGAarbiterUnlock(xf86Screens[i]);
      if (scr_index == i) {
	/*
	 * Hook in our ScrnInfoRec, and initialise some other pScreen
	 * fields.
	 */
	dixSetPrivate(&screenInfo.screens[scr_index]->devPrivates,
		      xf86ScreenKey, xf86Screens[i]);
	xf86Screens[i]->pScreen = screenInfo.screens[scr_index];
	/* The driver should set this, but make sure it is set anyway */
	xf86Screens[i]->vtSema = TRUE;
      } else {
	/* This shouldn't normally happen */
	FatalError("AddScreen/ScreenInit failed for driver %d\n", i);
      }

      DebugF("InitOutput - xf86Screens[%d]->pScreen = %p\n",
	     i, xf86Screens[i]->pScreen );
      DebugF("xf86Screens[%d]->pScreen->CreateWindow = %p\n",
	     i, xf86Screens[i]->pScreen->CreateWindow );

      dixSetPrivate(&screenInfo.screens[scr_index]->devPrivates,
		    xf86CreateRootWindowKey,
		    xf86Screens[i]->pScreen->CreateWindow);
      xf86Screens[i]->pScreen->CreateWindow = xf86CreateRootWindow;
d856 19
a874 9
    if (PictureGetSubpixelOrder (xf86Screens[i]->pScreen) == SubPixelUnknown)
    {
	xf86MonPtr DDC = (xf86MonPtr)(xf86Screens[i]->monitor->DDC);
	PictureSetSubpixelOrder (xf86Screens[i]->pScreen,
				 DDC ?
				 (DDC->features.input_type ?
				  SubPixelHorizontalRGB : SubPixelNone) :
				 SubPixelUnknown);
    }
d876 4
a879 4
    if (!xf86Info.disableRandR)
	xf86RandRInit (screenInfo.screens[scr_index]);
    xf86Msg(xf86Info.randRFrom, "RandR %s\n",
	    xf86Info.disableRandR ? "disabled" : "enabled");
d881 1
a881 1
  }
d883 2
a884 2
  xf86VGAarbiterWrapFunctions();
  xf86UnblockSIGIO(was_blocked);
d886 1
a886 1
  xf86InitOrigins();
d888 2
a889 2
  xf86Resetting = FALSE;
  xf86Initialising = FALSE;
d891 2
a892 2
  RegisterBlockAndWakeupHandlers((BlockHandlerProcPtr)NoopDDA, xf86Wakeup,
				 NULL);
d895 3
a897 18
static InputInfoPtr
duplicateDevice(InputInfoPtr pInfo)
{
    InputInfoPtr dup = calloc(1, sizeof(InputInfoRec));
    if (dup) {
        dup->name = strdup(pInfo->name);
        dup->driver = strdup(pInfo->driver);
        dup->options = xf86OptionListDuplicate(pInfo->options);
        /* type_name is a const string */
        dup->type_name = pInfo->type_name;
        dup->fd = -1;
    }
    return dup;
}

/*
 * InitInput --
 *      Initialize all supported input devices.
a898 1

d902 1
a902 1
    InputInfoPtr* pInfo;
d911 4
a914 12
        InputInfoPtr dup;
        /* Replace obsolete keyboard driver with kbd */
        if (!xf86NameCmp((*pInfo)->driver, "keyboard")) {
            strcpy((*pInfo)->driver, "kbd");
        }

        /* Data passed into xf86NewInputDevice will be freed on shutdown.
         * Duplicate from xf86ConfigLayout.inputs, otherwise we don't have any
         * xorg.conf input devices in the second generation
         */
        dup = duplicateDevice(*pInfo);

d916 1
a916 1
        if (xf86NewInputDevice(dup, &dev, TRUE) == BadAlloc)
d924 1
a924 1
CloseInput (void)
d944 1
a944 1
  static Bool beenHere = FALSE;
d946 1
a946 1
  signal(SIGCHLD, SIG_DFL);	/* Need to wait for child processes */
d948 4
a951 4
  if (!beenHere) {
    umask(022);
    xf86LogInit();
  }
d953 1
a953 1
        /* Set stderr to non-blocking. */
d962 9
a970 9
  if (!beenHere) {
    if (geteuid() == 0 && getuid() != geteuid())
    {
      int status;

      status = fcntl(fileno(stderr), F_GETFL, 0);
      if (status != -1) {
	fcntl(fileno(stderr), F_SETFL, status | O_NONBLOCK);
      }
a971 1
  }
d981 1
a981 1
  beenHere = TRUE;
d1000 1
a1000 1
	xf86OSPMClose();
d1005 5
a1009 5
	/*
	 * zero all access functions to
	 * trap calls when switched away.
	 */
	xf86Screens[i]->vtSema = FALSE;
d1017 1
a1017 1
	xf86CloseConsole();
d1023 1
a1023 1
	OsAbort();
a1025 2


d1036 1
a1036 1
  int i;
d1038 1
a1038 1
  xf86BlockSIGIO();
d1040 20
a1059 20
  /*
   * try to restore the original video state
   */
#ifdef DPMSExtension /* Turn screens back on */
  if (DPMSPowerLevel != DPMSModeOn)
      DPMSSet(serverClient, DPMSModeOn);
#endif
  if (xf86Screens) {
      for (i = 0; i < xf86NumScreens; i++)
	  if (xf86Screens[i]->vtSema) {
	      /*
	       * if we are aborting before ScreenInit() has finished
	       * we might not have been wrapped yet. Therefore enable
	       * screen explicitely.
	       */
	      xf86VGAarbiterLock(xf86Screens[i]);
	      (xf86Screens[i]->LeaveVT)(i, 0);
	      xf86VGAarbiterUnlock(xf86Screens[i]);
	  }
  }
d1061 1
a1061 1
  xf86AccessLeave();
d1063 5
a1067 5
  /*
   * This is needed for an abnormal server exit, since the normal exit stuff
   * MUST also be performed (i.e. the vt must be left in a defined state)
   */
  ddxGiveUp(error);
d1075 1
a1075 1
	   "at %s for support on this crash.\n",VENDORSUPPORT);
d1077 2
a1078 2
    ErrorF("\nPlease consult the "XVENDORNAME" support \n"
	   "\t at "__VENDORDWEBSUPPORT__"\n for help. \n");
d1081 2
a1082 2
	ErrorF("Please also check the log file at \"%s\" for additional "
              "information.\n", xf86LogFile);
d1109 1
a1109 1
  ErrorF("%s\n", DEFAULT_MODULE_PATH);
d1115 1
a1115 1
  ErrorF("%s\n", DEFAULT_LIBRARY_PATH);
d1137 28
a1164 4
  /* First the options that are only allowed for root */
  if (!strcmp(argv[i], "-modulepath") || !strcmp(argv[i], "-logfile")) {
    if ( (geteuid() == 0) && (getuid() != 0) ) {
      FatalError("The '%s' option can only be used by root.\n", argv[i]);
d1166 10
a1175 34
    else if (!strcmp(argv[i], "-modulepath"))
    {
      char *mp;
      CHECK_FOR_REQUIRED_ARGUMENT();
      mp = strdup(argv[i + 1]);
      if (!mp)
	FatalError("Can't allocate memory for ModulePath\n");
      xf86ModulePath = mp;
      xf86ModPathFrom = X_CMDLINE;
      return 2;
    }
    else if (!strcmp(argv[i], "-logfile"))
    {
      char *lf;
      CHECK_FOR_REQUIRED_ARGUMENT();
      lf = strdup(argv[i + 1]);
      if (!lf)
	FatalError("Can't allocate memory for LogFile\n");
      xf86LogFile = lf;
      xf86LogFileFrom = X_CMDLINE;
      return 2;
    }
  }
  if (!strcmp(argv[i], "-config") || !strcmp(argv[i], "-xf86config"))
  {
    CHECK_FOR_REQUIRED_ARGUMENT();
    if (getuid() != 0 && !xf86PathIsSafe(argv[i + 1])) {
      FatalError("\nInvalid argument for %s\n"
	  "\tFor non-root users, the file specified with %s must be\n"
	  "\ta relative path and must not contain any \"..\" elements.\n"
	  "\tUsing default "__XCONFIGFILE__" search path.\n\n",
	  argv[i], argv[i]);
    }
    xf86ConfigFile = argv[i + 1];
d1177 2
a1178 2
    /* Cannot drop privs when -xf86config is used with unsafe path */
    if (!xf86PathIsSafe(xf86ConfigFile))
d1181 17
a1197 11
    return 2;
  }
  if (!strcmp(argv[i], "-configdir"))
  {
    CHECK_FOR_REQUIRED_ARGUMENT();
    if (getuid() != 0 && !xf86PathIsSafe(argv[i + 1])) {
      FatalError("\nInvalid argument for %s\n"
	  "\tFor non-root users, the file specified with %s must be\n"
	  "\ta relative path and must not contain any \"..\" elements.\n"
	  "\tUsing default "__XCONFIGDIR__" search path.\n\n",
	  argv[i], argv[i]);
a1198 8
    xf86ConfigDir = argv[i + 1];
    return 2;
  }
  if (!strcmp(argv[i],"-flipPixels"))
  {
    xf86FlipPixels = TRUE;
    return 1;
  }
d1200 8
a1207 10
  if (!strcmp(argv[i],"-disableVidMode"))
  {
    xf86VidModeDisabled = TRUE;
    return 1;
  }
  if (!strcmp(argv[i],"-allowNonLocalXvidtune"))
  {
    xf86VidModeAllowNonLocal = TRUE;
    return 1;
  }
d1209 3
a1211 22
  if (!strcmp(argv[i],"-allowMouseOpenFail"))
  {
    xf86AllowMouseOpenFail = TRUE;
    return 1;
  }
  if (!strcmp(argv[i],"-ignoreABI"))
  {
    LoaderSetOptions(LDR_OPT_ABI_MISMATCH_NONFATAL);
    return 1;
  }
  if (!strcmp(argv[i],"-verbose"))
  {
    if (++i < argc && argv[i])
    {
      char *end;
      long val;
      val = strtol(argv[i], &end, 0);
      if (*end == '\0')
      {
	xf86SetVerbosity(val);
	return 2;
      }
d1213 3
a1215 15
    xf86SetVerbosity(++xf86Verbose);
    return 1;
  }
  if (!strcmp(argv[i],"-logverbose"))
  {
    if (++i < argc && argv[i])
    {
      char *end;
      long val;
      val = strtol(argv[i], &end, 0);
      if (*end == '\0')
      {
	xf86SetLogVerbosity(val);
	return 2;
      }
d1217 13
a1229 65
    xf86SetLogVerbosity(++xf86LogVerbose);
    return 1;
  }
  if (!strcmp(argv[i],"-quiet"))
  {
    xf86SetVerbosity(-1);
    return 1;
  }
  if (!strcmp(argv[i],"-showconfig") || !strcmp(argv[i],"-version"))
  {
    xf86PrintBanner();
    exit(0);
  }
  if (!strcmp(argv[i],"-showDefaultModulePath"))
  {
    xf86PrintDefaultModulePath();
    exit(0);
  }
  if (!strcmp(argv[i],"-showDefaultLibPath"))
  {
    xf86PrintDefaultLibraryPath();
    exit(0);
  }
  /* Notice the -fp flag, but allow it to pass to the dix layer */
  if (!strcmp(argv[i], "-fp"))
  {
    xf86fpFlag = TRUE;
    return 0;
  }
  /* Notice the -bs flag, but allow it to pass to the dix layer */
  if (!strcmp(argv[i], "-bs"))
  {
    xf86bsDisableFlag = TRUE;
    return 0;
  }
  /* Notice the +bs flag, but allow it to pass to the dix layer */
  if (!strcmp(argv[i], "+bs"))
  {
    xf86bsEnableFlag = TRUE;
    return 0;
  }
  /* Notice the -s flag, but allow it to pass to the dix layer */
  if (!strcmp(argv[i], "-s"))
  {
    xf86sFlag = TRUE;
    return 0;
  }
  if (!strcmp(argv[i], "-pixmap24"))
  {
    xf86Pix24 = Pix24Use24;
    return 1;
  }
  if (!strcmp(argv[i], "-pixmap32"))
  {
    xf86Pix24 = Pix24Use32;
    return 1;
  }
  if (!strcmp(argv[i], "-fbbpp"))
  {
    int bpp;
    CHECK_FOR_REQUIRED_ARGUMENT();
    if (sscanf(argv[++i], "%d", &bpp) == 1)
    {
      xf86FbBpp = bpp;
      return 2;
d1231 13
a1243 4
    else
    {
      ErrorF("Invalid fbbpp\n");
      return 0;
d1245 56
a1300 9
  }
  if (!strcmp(argv[i], "-depth"))
  {
    int depth;
    CHECK_FOR_REQUIRED_ARGUMENT();
    if (sscanf(argv[++i], "%d", &depth) == 1)
    {
      xf86Depth = depth;
      return 2;
d1302 12
a1313 4
    else
    {
      ErrorF("Invalid depth\n");
      return 0;
d1315 14
a1328 11
  }
  if (!strcmp(argv[i], "-weight"))
  {
    int red, green, blue;
    CHECK_FOR_REQUIRED_ARGUMENT();
    if (sscanf(argv[++i], "%1d%1d%1d", &red, &green, &blue) == 3)
    {
      xf86Weight.red = red;
      xf86Weight.green = green;
      xf86Weight.blue = blue;
      return 2;
d1330 21
a1350 4
    else
    {
      ErrorF("Invalid weighting\n");
      return 0;
d1352 23
a1374 18
  }
  if (!strcmp(argv[i], "-gamma")  || !strcmp(argv[i], "-rgamma") ||
      !strcmp(argv[i], "-ggamma") || !strcmp(argv[i], "-bgamma"))
  {
    double gamma;
    CHECK_FOR_REQUIRED_ARGUMENT();
    if (sscanf(argv[++i], "%lf", &gamma) == 1) {
       if (gamma < GAMMA_MIN || gamma > GAMMA_MAX) {
	  ErrorF("gamma out of range, only  %.2f <= gamma_value <= %.1f"
		 " is valid\n", GAMMA_MIN, GAMMA_MAX);
	  return 0;
       }
       if (!strcmp(argv[i-1], "-gamma"))
	  xf86Gamma.red = xf86Gamma.green = xf86Gamma.blue = gamma;
       else if (!strcmp(argv[i-1], "-rgamma")) xf86Gamma.red = gamma;
       else if (!strcmp(argv[i-1], "-ggamma")) xf86Gamma.green = gamma;
       else if (!strcmp(argv[i-1], "-bgamma")) xf86Gamma.blue = gamma;
       return 2;
a1375 30
  }
  if (!strcmp(argv[i], "-layout"))
  {
    CHECK_FOR_REQUIRED_ARGUMENT();
    xf86LayoutName = argv[++i];
    return 2;
  }
  if (!strcmp(argv[i], "-screen"))
  {
    CHECK_FOR_REQUIRED_ARGUMENT();
    xf86ScreenName = argv[++i];
    return 2;
  }
  if (!strcmp(argv[i], "-pointer"))
  {
    CHECK_FOR_REQUIRED_ARGUMENT();
    xf86PointerName = argv[++i];
    return 2;
  }
  if (!strcmp(argv[i], "-keyboard"))
  {
    CHECK_FOR_REQUIRED_ARGUMENT();
    xf86KeyboardName = argv[++i];
    return 2;
  }
  if (!strcmp(argv[i], "-nosilk"))
  {
    xf86silkenMouseDisableFlag = TRUE;
    return 1;
  }
d1377 14
a1390 5
  if (!strcmp(argv[i], "-noacpi"))
  {
    xf86acpiDisableFlag = TRUE;
    return 1;
  }
d1392 1
a1392 5
  if (!strcmp(argv[i], "-configure"))
  {
    if (getuid() != 0 && issetugid()) {
	ErrorF("The '-configure' option can only be used by root.\n");
	exit(1);
a1393 2
    xf86DoConfigure = TRUE;
    xf86AllowMouseOpenFail = TRUE;
d1395 8
a1402 1
    xf86KeepPriv = TRUE;
d1404 17
a1420 12
    return 1;
  }
#ifdef X_PRIVSEP
  if (!strcmp(argv[i], "-keepPriv")) 
  {
	  if (getuid() != 0) {
		  ErrorF("The '-keepPriv' option can only be used by root.\n");
		  exit(1);
	  }
	  xf86KeepPriv = TRUE;
	  return 1;
  }
d1422 8
a1429 5
  if (!strcmp(argv[i], "-showopts"))
  {
    if (getuid() != 0 && geteuid() == 0) {
    ErrorF("The '-showopts' option can only be used by root.\n");
    exit(1);
d1431 3
a1433 8
    xf86DoShowOptions = TRUE;
    return 1;
  }
  if (!strcmp(argv[i], "-isolateDevice"))
  {
    CHECK_FOR_REQUIRED_ARGUMENT();
    if (strncmp(argv[++i], "PCI:", 4)) {
       FatalError("Bus types other than PCI not yet isolable\n");
a1434 9
    xf86PciIsolateDevice(argv[i]);
    return 2;
  }
  /* Notice cmdline xkbdir, but pass to dix as well */
  if (!strcmp(argv[i], "-xkbdir"))
  {
    xf86xkbdirFlag = TRUE;
    return 0;
  }
d1436 2
a1437 2
  /* OS-specific processing */
  return xf86ProcessArgument(argc, argv, i);
d1449 41
a1489 32
  ErrorF("\n");
  ErrorF("\n");
  ErrorF("Device Dependent Usage\n");
  if (getuid() == 0 || geteuid() != 0)
  {
    ErrorF("-modulepath paths      specify the module search path\n");
    ErrorF("-logfile file          specify a log file name\n");
    ErrorF("-configure             probe for devices and write an "__XCONFIGFILE__"\n");
    ErrorF("-showopts              print available options for all installed drivers\n");
  }
  ErrorF("-config file           specify a configuration file, relative to the\n");
  ErrorF("                       "__XCONFIGFILE__" search path, only root can use absolute\n");
  ErrorF("-configdir dir         specify a configuration directory, relative to the\n");
  ErrorF("                       "__XCONFIGDIR__" search path, only root can use absolute\n");
  ErrorF("-verbose [n]           verbose startup messages\n");
  ErrorF("-logverbose [n]        verbose log messages\n");
  ErrorF("-quiet                 minimal startup messages\n");
  ErrorF("-pixmap24              use 24bpp pixmaps for depth 24\n");
  ErrorF("-pixmap32              use 32bpp pixmaps for depth 24\n");
  ErrorF("-fbbpp n               set bpp for the framebuffer. Default: 8\n");
  ErrorF("-depth n               set colour depth. Default: 8\n");
  ErrorF("-gamma f               set gamma value (0.1 < f < 10.0) Default: 1.0\n");
  ErrorF("-rgamma f              set gamma value for red phase\n");
  ErrorF("-ggamma f              set gamma value for green phase\n");
  ErrorF("-bgamma f              set gamma value for blue phase\n");
  ErrorF("-weight nnn            set RGB weighting at 16 bpp.  Default: 565\n");
  ErrorF("-layout name           specify the ServerLayout section name\n");
  ErrorF("-screen name           specify the Screen section name\n");
  ErrorF("-keyboard name         specify the core keyboard InputDevice name\n");
  ErrorF("-pointer name          specify the core pointer InputDevice name\n");
  ErrorF("-nosilk                disable Silken Mouse\n");
  ErrorF("-flipPixels            swap default black/white Pixel values\n");
d1491 17
a1507 9
  ErrorF("-disableVidMode        disable mode adjustments with xvidtune\n");
  ErrorF("-allowNonLocalXvidtune allow xvidtune to be run as a non-local client\n");
#endif
  ErrorF("-allowMouseOpenFail    start server even if the mouse can't be initialized\n");
  ErrorF("-ignoreABI             make module ABI mismatches non-fatal\n");
  ErrorF("-isolateDevice bus_id  restrict device resets to bus_id (PCI only)\n");
  ErrorF("-version               show the server version\n");
  ErrorF("-showDefaultModulePath show the server default module path\n");
  ErrorF("-showDefaultLibPath    show the server default library path\n");
d1509 2
a1510 1
  ErrorF("-keepPriv		 don't revoque privs when running as root\n");
d1512 3
a1514 3
  /* OS-specific usage */
  xf86UseMsg();
  ErrorF("\n");
a1516 1

d1530 1
a1530 1
	return TRUE;
d1534 13
a1546 2
	/* Normalise the module name */
	name = xf86NormalizeName(list[i]);
d1548 4
a1551 15
	/* Skip empty names */
	if (name == NULL || *name == '\0') {
	    free(name);
	    continue;
	}

	/* Replace obsolete keyboard driver with kbd */
	if (!xf86NameCmp(name, "keyboard")) {
	    strcpy(name, "kbd");
	}

	if (optlist)
	    opt = optlist[i];
	else
	    opt = NULL;
d1554 4
a1557 4
	    LoaderErrorMsg(NULL, name, errmaj, errmin);
	    failed = TRUE;
	}
	free(name);
d1568 1
a1568 1
    static PixmapFormatRec format;	/* XXX not reentrant */
d1576 2
a1577 2
	if (depth == 24) {
	    Pix24Flags pix24 = Pix24DontCare;
d1579 12
a1590 12
	    format.depth = 24;
	    format.scanlinePad = BITMAP_SCANLINE_PAD;
	    if (xf86Info.pixmap24 != Pix24DontCare)
		pix24 = xf86Info.pixmap24;
	    else if (pScrn->pixmap24 != Pix24DontCare)
		pix24 = pScrn->pixmap24;
	    if (pix24 == Pix24Use24)
		format.bitsPerPixel = 24;
	    else
		format.bitsPerPixel = 32;
	    return &format;
	}
d1594 2
a1595 2
	if (formats[i].depth == depth)
	   break;
d1597 1
a1597 1
	return &formats[i];
d1599 6
a1604 6
	/* Check for screen-specified formats */
	for (i = 0; i < pScrn->numFormats; i++)
	    if (pScrn->formats[i].depth == depth)
		break;
	if (i != pScrn->numFormats)
	    return &pScrn->formats[i];
a1613 1

d1616 1
a1616 1
	return format->bitsPerPixel;
d1618 1
a1618 1
	return 0;
@


1.13
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a320 1
#ifdef SIGBUS
a321 2
#endif
#ifdef SIGSYS
a322 2
#endif
#ifdef SIGXCPU
a323 2
#endif
#ifdef SIGXFSZ
a324 1
#endif
d337 1
a337 1
  int                    i, j, k, scr_index;
d543 1
a543 3
	size_t len = strlen("screen") + 10 + 1;
	xf86Screens[i]->name = xnfalloc(len);
	snprintf(xf86Screens[i]->name, len, "screen%d", i);
d715 1
a715 14
      xf86EnterServerState(SETUP);
    }
  }
#ifdef SCO325
  else {
    /*
     * Under SCO we must ack that we got the console at startup,
     * I think this is the safest way to assure it.
     */
    static int once = 1;
    if (once) {
      once = 0;
      if (ioctl(xf86Info.consoleFd, VT_RELDISP, VT_ACKACQ) < 0)
        xf86Msg(X_WARNING, "VT_ACKACQ failed");
a717 1
#endif /* SCO325 */
d724 1
a724 2
      !dixRegisterPrivateKey(&xf86CreateRootWindowKeyRec, PRIVATE_SCREEN, 0) ||
      !dixRegisterPrivateKey(&xf86PixmapKeyRec, PRIVATE_PIXMAP, 0))
d786 2
a787 1
  xf86PostScreenInit();
d798 15
d821 1
a821 1
    IDevPtr* pDev;
d828 3
a830 4
    GetEventList(&xf86Events);

    /* Call the PreInit function for each input device instance. */
    for (pDev = xf86ConfigLayout.inputs; pDev && *pDev; pDev++) {
d832 2
a833 2
        if (!xf86NameCmp((*pDev)->driver, "keyboard")) {
            strcpy((*pDev)->driver, "kbd");
d836 6
d843 1
a843 1
        if (xf86NewInputDevice(*pDev, &dev, TRUE) == BadAlloc)
d854 1
a872 1
#ifdef SIGCHLD
a873 1
#endif
d920 1
a920 1
ddxGiveUp(void)
d947 1
a947 1
    xf86CloseLog();
d964 1
a964 1
AbortDDX(void)
d968 2
a977 2
      if (xf86Screens[0]->vtSema)
	  xf86EnterServerState(SETUP);
d997 1
a997 1
  ddxGiveUp();
a1059 5
  /*
   * Note: can't use xalloc/xfree here because OsInit() hasn't been called
   * yet.  Use malloc/free instead.
   */

d1076 1
a1076 1
      mp = malloc(strlen(argv[i + 1]) + 1);
a1078 1
      strcpy(mp, argv[i + 1]);
d1087 1
a1087 1
      lf = malloc(strlen(argv[i + 1]) + 1);
a1089 1
      strcpy(lf, argv[i + 1]);
d1475 2
a1476 1
	if (name == NULL || *name == '\0')
d1478 1
@


1.12
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d69 1
a77 1
#ifdef RENDER
a78 1
#endif
d80 1
a87 5

#include <pciaccess.h>
#include "Pci.h"
#include "xf86Bus.h"

a89 3
/* forward declarations */
static Bool probe_devices_from_device_sections(DriverPtr drvp);
static Bool add_matching_devices_to_configure_list(DriverPtr drvp);
a104 1
#ifdef RENDER
a105 1
#endif
a106 1
#ifdef RENDER
a107 3
#else
static int numFormats = 6;
#endif
d210 2
a211 2
    bzero(&t, sizeof(t));
    bzero(buf, sizeof(buf));
d301 1
a301 1
  return (ret);
a335 195

#define END_OF_MATCHES(m) \
    (((m).vendor_id == 0) && ((m).device_id == 0) && ((m).subvendor_id == 0))

Bool
probe_devices_from_device_sections(DriverPtr drvp)
{
    int i, j;
    struct pci_device * pPci;
    Bool foundScreen = FALSE;
    const struct pci_id_match * const devices = drvp->supported_devices;
    GDevPtr *devList;
    const unsigned numDevs = xf86MatchDevice(drvp->driverName, & devList);


    for ( i = 0 ; i < numDevs ; i++ ) {
	struct pci_device_iterator *iter;
	unsigned device_id;


	/* Find the pciVideoRec associated with this device section.
	 */
	iter = pci_id_match_iterator_create(NULL);
	while ((pPci = pci_device_next(iter)) != NULL) {
	    if (devList[i]->busID && *devList[i]->busID) {
		if (xf86ComparePciBusString(devList[i]->busID,
					    ((pPci->domain << 8)
					     | pPci->bus),
					    pPci->dev,
					    pPci->func)) {
		    break;
		}
	    }
	    else if (xf86IsPrimaryPci(pPci)) {
		break;
	    }
	}

	pci_iterator_destroy(iter);

	if (pPci == NULL) {
	    continue;
	}

	device_id = (devList[i]->chipID > 0)
	  ? devList[i]->chipID : pPci->device_id;


	/* Once the pciVideoRec is found, determine if the device is supported
	 * by the driver.  If it is, probe it!
	 */
	for ( j = 0 ; ! END_OF_MATCHES( devices[j] ) ; j++ ) {
	    if ( PCI_ID_COMPARE( devices[j].vendor_id, pPci->vendor_id )
		 && PCI_ID_COMPARE( devices[j].device_id, device_id )
		 && ((devices[j].device_class_mask & pPci->device_class)
		      == devices[j].device_class) ) {
		int  entry;

		/* Allow the same entity to be used more than once for
		 * devices with multiple screens per entity.  This assumes
		 * implicitly that there will be a screen == 0 instance.
		 *
		 * FIXME Need to make sure that two different drivers don't
		 * FIXME claim the same screen > 0 instance.
		 */
		if ( (devList[i]->screen == 0) && !xf86CheckPciSlot( pPci ) )
		  continue;

		DebugF("%s: card at %d:%d:%d is claimed by a Device section\n",
		       drvp->driverName, pPci->bus, pPci->dev, pPci->func);

		/* Allocate an entry in the lists to be returned */
		entry = xf86ClaimPciSlot(pPci, drvp, device_id,
					  devList[i], devList[i]->active);

		if ((entry == -1) && (devList[i]->screen > 0)) {
		    unsigned k;

		    for ( k = 0; k < xf86NumEntities; k++ ) {
			EntityPtr pEnt = xf86Entities[k];
			if (pEnt->bus.type != BUS_PCI)
			  continue;

			if (pEnt->bus.id.pci == pPci) {
			    entry = k;
			    xf86AddDevToEntity(k, devList[i]);
			    break;
			}
		    }
		}

		if (entry != -1) {
		    if ((*drvp->PciProbe)(drvp, entry, pPci,
					  devices[j].match_data)) {
			foundScreen = TRUE;
		    } else
			xf86UnclaimPciSlot(pPci);
		}

		break;
	    }
	}
    }
    xfree(devList);

    return foundScreen;
}


Bool
add_matching_devices_to_configure_list(DriverPtr drvp)
{
    const struct pci_id_match * const devices = drvp->supported_devices;
    int j;
    struct pci_device *pPci;
    struct pci_device_iterator *iter;
    int numFound = 0;


    iter = pci_id_match_iterator_create(NULL);
    while ((pPci = pci_device_next(iter)) != NULL) {
	/* Determine if this device is supported by the driver.  If it is,
	 * add it to the list of devices to configure.
	 */
	for (j = 0 ; ! END_OF_MATCHES(devices[j]) ; j++) {
	    if ( PCI_ID_COMPARE( devices[j].vendor_id, pPci->vendor_id )
		 && PCI_ID_COMPARE( devices[j].device_id, pPci->device_id )
		 && ((devices[j].device_class_mask & pPci->device_class)
		     == devices[j].device_class) ) {
		if (xf86CheckPciSlot(pPci)) {
		    GDevPtr pGDev = xf86AddBusDeviceToConfigure(
					drvp->driverName, BUS_PCI, pPci, -1);
		    if (pGDev != NULL) {
			/* After configure pass 1, chipID and chipRev are
			 * treated as over-rides, so clobber them here.
			 */
			pGDev->chipID = -1;
			pGDev->chipRev = -1;
		    }

		    numFound++;
		}

		break;
	    }
	}
    }

    pci_iterator_destroy(iter);


    return (numFound != 0);
}

/**
 * Call the driver's correct probe function.
 *
 * If the driver implements the \c DriverRec::PciProbe entry-point and an
 * appropriate PCI device (with matching Device section in the xorg.conf file)
 * is found, it is called.  If \c DriverRec::PciProbe or no devices can be
 * successfully probed with it (e.g., only non-PCI devices are available),
 * the driver's \c DriverRec::Probe function is called.
 *
 * \param drv   Driver to probe
 *
 * \return
 * If a device can be successfully probed by the driver, \c TRUE is
 * returned.  Otherwise, \c FALSE is returned.
 */
Bool
xf86CallDriverProbe( DriverPtr drv, Bool detect_only )
{
    Bool     foundScreen = FALSE;

    if ( drv->PciProbe != NULL ) {
	if ( xf86DoConfigure && xf86DoConfigurePass1 ) {
	    assert( detect_only );
	    foundScreen = add_matching_devices_to_configure_list( drv );
	}
	else {
	    assert( ! detect_only );
	    foundScreen = probe_devices_from_device_sections( drv );
	}
    }

    if ( ! foundScreen && (drv->Probe != NULL) ) {
	xf86Msg( X_WARNING, "Falling back to old probe method for %s\n",
		 drv->driverName );
	foundScreen = (*drv->Probe)( drv, (detect_only) ? PROBE_DETECT
				     : PROBE_DEFAULT );
    }

    return foundScreen;
}

a347 1
  screenLayoutPtr	 layout;
a356 3

    pScreenInfo->numScreens = 0;

d422 2
a423 2
      xfree(modulelist);
      xfree(optionlist);
d439 1
a439 1
      xfree(modulelist);
d445 1
a445 1
      xfree(modulelist);
d498 2
a499 93
    /* Enable full I/O access */
    if (xorgHWAccess)
	xorgHWAccess = xf86EnableIO();

    /*
     * Locate bus slot that had register IO enabled at server startup
     */
    if (xorgHWAccess) {
        xf86AccessInit();
        xf86FindPrimaryDevice();
    }
    /*
     * Now call each of the Probe functions.  Each successful probe will
     * result in an extra entry added to the xf86Screens[] list for each
     * instance of the hardware found.
     */

    for (i = 0; i < xf86NumDrivers; i++) {
	xorgHWFlags flags;
	if (!xorgHWAccess) {
	    if (!xf86DriverList[i]->driverFunc
		|| !xf86DriverList[i]->driverFunc(NULL,
						 GET_REQUIRED_HW_INTERFACES,
						  &flags)
		|| NEED_IO_ENABLED(flags))
		continue;
	}

	xf86CallDriverProbe( xf86DriverList[i], FALSE );
    }

    /*
     * If nothing was detected, return now.
     */

    if (xf86NumScreens == 0) {
      xf86Msg(X_ERROR, "No devices detected.\n");
      return;
    }

    xf86VGAarbiterInit();

    /*
     * Match up the screens found by the probes against those specified
     * in the config file.  Remove the ones that won't be used.  Sort
     * them in the order specified.
     */

    /*
     * What is the best way to do this?
     *
     * For now, go through the screens allocated by the probes, and
     * look for screen config entry which refers to the same device
     * section as picked out by the probe.
     *
     */

    for (i = 0; i < xf86NumScreens; i++) {
      for (layout = xf86ConfigLayout.screens; layout->screen != NULL;
	   layout++) {
	  Bool found = FALSE;
	  for (j = 0; j < xf86Screens[i]->numEntities; j++) {

	      GDevPtr dev =
		xf86GetDevFromEntity(xf86Screens[i]->entityList[j],
				     xf86Screens[i]->entityInstanceList[j]);

	      if (dev == layout->screen->device) {
		  /* A match has been found */
		  xf86Screens[i]->confScreen = layout->screen;
		  found = TRUE;
		  break;
	      }
	  }
	  if (found) break;
      }
      if (layout->screen == NULL) {
	/* No match found */
	xf86Msg(X_ERROR,
	    "Screen %d deleted because of no matching config section.\n", i);
        xf86DeleteScreen(i--, 0);
      }
    }

    /*
     * If no screens left, return now.
     */

    if (xf86NumScreens == 0) {
      xf86Msg(X_ERROR,
	      "Device(s) detected, but none match those in the config file.\n");
      return;
    }
a501 1
    xf86EntityInit();
d654 1
a654 1
      if ( (VT = xalloc(sizeof(CARD32)))==NULL ) {
d743 9
a793 1
#ifdef RENDER
a802 1
#endif
a1387 1
    int bus, device, func;
d1392 2
a1393 9
    if (sscanf(argv[i], "PCI:%d:%d:%d", &bus, &device, &func) == 3) {
       xf86IsolateDevice.domain = PCI_DOM_FROM_BUS(bus);
       xf86IsolateDevice.bus = PCI_BUS_NO_DOMAIN(bus);
       xf86IsolateDevice.dev = device;
       xf86IsolateDevice.func = func;
       return 2;
    } else {
       FatalError("Invalid isolated device specification\n");
    }
d1504 1
a1504 1
	xfree(name);
@


1.11
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@a45 1
#define NEED_EVENTS
a69 1
#include "xf86Date.h"
d81 1
a84 1
#ifdef HAVE_X11_EXTENSIONS_DPMSCONST_H
a85 3
#else
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
a87 1
#endif
d93 2
a97 1
static Bool check_for_matching_devices(DriverPtr drvp);
d102 1
d142 1
a142 1
  ErrorF("\n"
d151 1
a151 1
  ErrorF("\nX.Org X Server %d.%d.%d",
d156 1
a156 1
  ErrorF(".%d", XORG_VERSION_SNAP);
d168 2
a169 1
  ErrorF(" (%d.0.0 RC %d)", XORG_VERSION_MAJOR+1, XORG_VERSION_SNAP - 900);
d171 2
a172 2
  ErrorF(" (%d.%d.0 RC %d)", XORG_VERSION_MAJOR, XORG_VERSION_MINOR + 1,
				XORG_VERSION_SNAP - 900);
d174 3
a176 2
  ErrorF(" (%d.%d.%d RC %d)", XORG_VERSION_MAJOR, XORG_VERSION_MINOR,
 			 XORG_VERSION_PATCH + 1, XORG_VERSION_SNAP - 900);
d181 1
a181 1
  ErrorF(" (%s)", XORG_CUSTOM_VERSION);
d184 1
a184 1
#define XORG_DATE XF86_DATE
d186 2
a187 2
  ErrorF("\nRelease Date: %s\n", XORG_DATE);
  ErrorF("X Protocol Version %d, Revision %d\n",
d189 1
a189 1
  ErrorF("Build Operating System: %s %s\n", OSNAME, OSVENDOR);
d199 1
a199 1
      ErrorF("Current Operating System: %s %s %s %s %s\n",
d201 15
d234 1
a234 1
       ErrorF("Build Date: %s\n", buf);
d237 1
a237 1
       ErrorF("Build Date: %s\n", buf);
a240 14
#if defined(CLOG_DATE) && (CLOG_DATE > 19000000)
  {
    struct tm t;
    char buf[100];

    bzero(&t, sizeof(t));
    bzero(buf, sizeof(buf));
    t.tm_mday = CLOG_DATE % 100;
    t.tm_mon = (CLOG_DATE / 100) % 100 - 1;
    t.tm_year = CLOG_DATE / 10000 - 1900;
    if (strftime(buf, sizeof(buf), "%d %B %Y", &t))
       ErrorF("Changelog Date: %s\n", buf);
  }
#endif
d242 1
a242 1
  ErrorF("%s \n",BUILDERSTRING);
d244 5
a248 2
  ErrorF("\tBefore reporting problems, check "__VENDORDWEBSUPPORT__"\n"
	 "\tto make sure that you have the latest version.\n");
a256 78
static void
DoModalias(void)
{
    int i = -1;
    char **vlist;

    /* Get all the drivers */
    vlist = xf86DriverlistFromCompile();
    if (!vlist) {
	ErrorF("Missing output drivers.  PCI Access dump failed.\n");
	goto bail;
    }

    /* Load all the drivers that were found. */
    xf86LoadModules(vlist, NULL);

    xfree(vlist);

    /* Iterate through each driver */
    for (i = 0; i < xf86NumDrivers; i++) {
        struct pci_id_match *match;

        /* Iterate through each pci id match data, dumping it to the screen */
        for (match = (struct pci_id_match *) xf86DriverList[i]->supported_devices ;
                 match && !(!match->vendor_id && !match->device_id) ; match++) {
             /* Prefix */
             ErrorF("alias pci:");

             /* Vendor */
             if (match->vendor_id == ~0)
                 ErrorF("v*");
             else
                 ErrorF("v%08X", match->vendor_id);

             /* Device */
             if (match->device_id == ~0)
                 ErrorF("d*");
             else
                 ErrorF("d%08X", match->device_id);

             /* Subvendor */
             if (match->subvendor_id == ~0)
                 ErrorF("sv*");
             else
                 ErrorF("sv%08X", match->subvendor_id);

             /* Subdevice */
             if (match->subdevice_id == ~0)
                 ErrorF("sd*");
             else
                 ErrorF("sd%08X", match->subdevice_id);

             /* Class */
             if ((match->device_class_mask >> 16 & 0xFF) == 0xFF)
                 ErrorF("bc%02X", match->device_class >> 16 & 0xFF);
             else
                 ErrorF("bc*");
             if ((match->device_class_mask >> 8 & 0xFF) == 0xFF)
                 ErrorF("sc%02X", match->device_class >> 8 & 0xFF);
             else
                 ErrorF("sc*");
             if ((match->device_class_mask & 0xFF) == 0xFF)
                 ErrorF("i%02X*", match->device_class & 0xFF);
             else
                 ErrorF("i*");

             /* Suffix (driver) */
             ErrorF(" %s\n", xf86DriverList[i]->driverName);
        }
    }

bail:
    OsCleanup(TRUE);
    AbortDDX();
    fflush(stderr);
    exit(0);
}

d267 1
a267 3
#ifdef DEBUG
  ErrorF("xf86CreateRootWindow(%p)\n", pWin);
#endif
d314 1
a314 3
#ifdef DEBUG
  ErrorF("xf86CreateRootWindow() returns %d\n", ret);
#endif
d327 4
a330 2
       signal(SIGSEGV,xf86SigHandler);
       signal(SIGILL,xf86SigHandler);
d332 1
a332 1
       signal(SIGEMT,xf86SigHandler);
d334 1
a334 1
       signal(SIGFPE,xf86SigHandler);
d336 1
a336 1
       signal(SIGBUS,xf86SigHandler);
d339 1
a339 1
       signal(SIGSYS,xf86SigHandler);
d342 1
a342 1
       signal(SIGXCPU,xf86SigHandler);
d345 1
a345 1
       signal(SIGXFSZ,xf86SigHandler);
d418 1
a418 2
#ifdef DEBUG
		ErrorF("%s: card at %d:%d:%d is claimed by a Device section\n",
a419 1
#endif
d430 1
a430 1
			if (pEnt->busType != BUS_PCI)
d445 2
a446 1
		    }
d453 1
a453 1

a503 26

Bool
check_for_matching_devices(DriverPtr drvp)
{
    const struct pci_id_match * const devices = drvp->supported_devices;
    int j;


    for (j = 0; ! END_OF_MATCHES(devices[j]); j++) {
	struct pci_device_iterator *iter;
	struct pci_device *dev;

	iter = pci_id_match_iterator_create(& devices[j]);
	dev = pci_device_next(iter);
	pci_iterator_destroy(iter);

	if (dev != NULL) {
	    return TRUE;
	}
    }


    return FALSE;
}


d525 1
a525 5
	if ( xf86DoProbe ) {
	    assert( detect_only );
	    foundScreen = check_for_matching_devices( drv );
	}
	else if ( xf86DoConfigure && xf86DoConfigurePass1 ) {
a544 70
static void
DoProbe(void)
{
    int i;
    Bool probeResult;
    Bool ioEnableFailed = FALSE;
    
    /* Find the list of video driver modules. */
    char **list = xf86DriverlistFromCompile();
    char **l;

    if (list) {
	ErrorF("List of video driver modules:\n");
	for (l = list; *l; l++)
	    ErrorF("\t%s\n", *l);
    } else {
	ErrorF("No video driver modules found\n");
    }

    /* Load all the drivers that were found. */
    xf86LoadModules(list, NULL);

    /* Disable PCI devices */
    xf86AccessInit();

    /* Call all of the probe functions, reporting the results. */
    for (i = 0; i < xf86NumDrivers; i++) {
	DriverRec * const drv = xf86DriverList[i];

	if (!xorgHWAccess) {
	    xorgHWFlags flags;
	    if (!drv->driverFunc
		|| !drv->driverFunc( NULL, GET_REQUIRED_HW_INTERFACES, &flags )
		|| NEED_IO_ENABLED(flags)) {
		if (ioEnableFailed)
		    continue;
		if (!xf86EnableIO()) {
		    ioEnableFailed = TRUE;
		    continue;
		}
		xorgHWAccess = TRUE;
	    }
	}
	    

	xf86MsgVerb(X_INFO, 3, "Probing in driver %s\n",  drv->driverName);

	probeResult = xf86CallDriverProbe( drv, TRUE );
	if (!probeResult) {
	    xf86ErrorF("Probe in driver `%s' returns FALSE\n",
		drv->driverName);
	} else {
	    xf86ErrorF("Probe in driver `%s' returns TRUE\n",
		drv->driverName);

	    /* If we have a result, then call driver's Identify function */
	    if (drv->Identify != NULL) {
		const int verbose = xf86SetVerbosity(1);
		(*drv->Identify)(0);
		xf86SetVerbosity(verbose);
	    }
	}
    }

    OsCleanup(TRUE);
    AbortDDX();
    fflush(stderr);
    exit(0);
}

a574 1
    if (!xf86DoModalias) {
a584 1
    }
d587 1
a587 1
    if (!xf86DoProbe && !xf86DoConfigure && !xf86DoModalias && !xf86DoShowOptions) {
a614 2
    xf86OpenConsole();

a617 3
    if (xf86DoProbe)
	DoProbe();

a620 4
    /* Do the PCI Access dump */
    if (xf86DoModalias)
        DoModalias();

a631 3
    /* Initialise the resource broker */
    xf86ResourceBrokerInit();

a687 2
	xorgHWFlags flags;

d691 3
a693 2
	if (!xorgHWAccess
	    && (!xf86DriverList[i]->driverFunc
d696 8
a703 3
						  &flags)
		|| NEED_IO_ENABLED(flags)))
	    xorgHWAccess = TRUE;
d706 5
d751 2
d833 2
a834 1
	xf86EnableAccess(xf86Screens[i]);
d838 1
a864 9
    /* XXX Should this be before or after loading dependent modules? */
    if (xf86ProbeOnly)
    {
      OsCleanup(TRUE);
      AbortDDX();
      fflush(stderr);
      exit(0);
    }

a879 1
     * Also, should this be done for -probeonly?
a983 4

    /* set up the proper access funcs */
    xf86PostPreInit();

d988 2
a989 1
    xf86OpenConsole();
d1049 1
a1049 1
	xf86EnableAccess(xf86Screens[i]);
d1055 1
d1057 1
d1064 1
d1080 1
a1080 2
#ifdef DEBUG
      ErrorF("InitOutput - xf86Screens[%d]->pScreen = %p\n",
d1082 1
a1082 1
      ErrorF("xf86Screens[%d]->pScreen->CreateWindow = %p\n",
a1083 1
#endif
d1126 1
a1126 3
InitInput(argc, argv)
     int	  argc;
     char	  **argv;
d1135 2
d1148 8
d1178 2
a1179 1
  if (!beenHere)
d1181 1
d1223 1
a1223 1
ddxGiveUp()
d1227 2
a1234 2
    xf86AccessLeaveState();

a1240 2
	xf86Screens[i]->access = NULL;
	xf86Screens[i]->busAccess = NULL;
d1247 2
a1248 1
    xf86CloseConsole();
d1254 1
a1254 1
	abort();
d1267 1
a1267 1
AbortDDX()
d1288 1
a1288 1
	      xf86EnableAccess(xf86Screens[i]);
d1290 1
d1304 1
a1304 1
OsVendorFatalError()
d1374 7
a1380 6
  
  /* First the options that are only allowed for root 
     or when the program is not privileged at all */
  if (getuid() == 0 || geteuid() != 0 || !issetugid())
  {
    if (!strcmp(argv[i], "-modulepath"))
a1403 2
  } else if (!strcmp(argv[i], "-modulepath") || !strcmp(argv[i], "-logfile")) {
    FatalError("The '%s' option can only be used by root.\n", argv[i]);
d1423 1
a1423 1
  if (!strcmp(argv[i],"-probeonly"))
d1425 10
a1434 2
    xf86ProbeOnly = TRUE;
    return 1;
d1497 1
a1497 1
    xf86SetVerbosity(0);
a1650 8
  if (!strcmp(argv[i], "-probe"))
  {
    xf86DoProbe = TRUE;
#if 0
    DoProbe(argc, argv, i);
#endif
    return 1;
  }
a1663 6
  if (!strcmp(argv[i], "-modalias"))
  {
    xf86DoModalias = TRUE;
    xf86AllowMouseOpenFail = TRUE;
    return 1;
  }
d1719 1
a1719 1
ddxUseMsg()
a1730 1
  ErrorF("-modalias              output a modalias-style filter for each driver installed\n");
d1733 2
a1734 1
  ErrorF("-probeonly             probe for devices, then exit\n");
d1817 1
a1817 1
_X_EXPORT PixmapFormatPtr
d1862 1
a1862 1
_X_EXPORT int
@


1.10
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d86 3
d92 1
@


1.9
log
@note to self: no cookie, a compile started is not a compile tested
@
text
@a73 1
#ifdef XINPUT
a75 3
#else
#include "inputstr.h"
#endif
a95 6

static void xf86PrintBanner(void);
static void xf86PrintMarkers(void);
static void xf86PrintDefaultModulePath(void);
static void xf86PrintDefaultLibraryPath(void);

d139 1
a139 1
xf86PrintBanner()
d246 1
a246 1
xf86PrintMarkers()
d252 1
a252 1
DoModalias()
a328 1

d376 1
a376 1
      
d379 1
a379 1
      
d396 1
a396 1
PostConfigInit(void)
a421 7

#ifdef XF86PM
    xf86OSPMClose = xf86OSPMOpen();
#endif
    
    /* Do this after XF86Config is read (it's normally in OsInit()) */
    OsInitColors();
d449 1
a449 1
		if (xf86ComparePciBusString(devList[i]->busID, 
d496 1
a496 1
	
d516 1
a516 1
		
d529 1
a529 1
	
d555 2
a556 2
		    GDevPtr pGDev = 
		      xf86AddDeviceToConfigure(drvp->driverName, pPci, -1);
d590 1
a590 1
	
d594 1
a594 1
	
d613 1
a613 1
 * 
d615 1
a615 1
 * 
d643 1
a643 1
	foundScreen = (*drv->Probe)( drv, (detect_only) ? PROBE_DETECT 
d650 70
d738 1
a738 1
  
d764 1
a764 1
    if (!xf86DoProbe && !xf86DoConfigure && !xf86DoModalias) {
d777 1
a777 2
    if (!autoconfig)
	PostConfigInit();
d789 3
a811 1
	PostConfigInit();
d814 4
d878 1
a878 1
      /* The Identify function is mandatory, but if it isn't there continue */
d881 1
a881 5
	else {
	    xf86Msg(X_WARNING, "Driver `%s' has no Identify function\n",
		  xf86DriverList[i]->driverName ? xf86DriverList[i]->driverName
					     : "noname");
	}
d892 2
a893 5
    if (xorgHWAccess) {
	if(!xf86EnableIO())
	    /* oops, we have failed */
	    xorgHWAccess = FALSE;
    }
d898 4
a901 4

    xf86AccessInit();
    xf86FindPrimaryDevice();

d915 1
a915 1
		|| NEED_IO_ENABLED(flags)) 
d951 1
a951 1
	
d1009 1
a1009 1
    
d1019 1
a1019 1
    
a1029 11
    /* This could be moved into a separate function */

    /*
     * Check that all screens have initialised the mandatory function
     * entry points.  Delete those which have not.
     */

#define WARN_SCREEN(func) \
    xf86Msg(X_ERROR, "Driver `%s' has no %s function, deleting.\n", \
	   xf86Screens[i]->name, (warned++, func))

a1030 1
      int warned = 0;
d1032 3
a1034 5
	xf86Screens[i]->name = xnfalloc(strlen("screen") + 1 + 1);
	if (i < 10)
	  sprintf(xf86Screens[i]->name, "screen%c", i + '0');
	else
	  sprintf(xf86Screens[i]->name, "screen%c", i - 10 + 'A');
a1038 17
      if (xf86Screens[i]->ScreenInit == NULL)
	WARN_SCREEN("ScreenInit");
      if (xf86Screens[i]->EnterVT == NULL)
	WARN_SCREEN("EnterVT");
      if (xf86Screens[i]->LeaveVT == NULL)
	WARN_SCREEN("LeaveVT");
      if (warned)
	xf86DeleteScreen(i--, 0);
    }

    /*
     * If no screens left, return now.
     */

    if (xf86NumScreens == 0) {
      xf86Msg(X_ERROR, "Screen(s) found, but drivers were unusable.\n");
      return;
d1149 1
a1149 1
    
d1154 1
a1154 1
					     VTAtom, XA_INTEGER, 32, 
a1170 3
#ifdef XKB
    xf86InitXkb();
#endif
a1173 2
    AddCallback(&ServerGrabCallback, xf86GrabServerCallback, NULL);
    
a1196 28
#if 0
  /*
   * Install signal handler for unexpected signals
   */
  xf86Info.caughtSignal=FALSE;
  if (!xf86Info.notrapSignals)
  {
     signal(SIGSEGV,xf86SigHandler);
     signal(SIGILL,xf86SigHandler);
#ifdef SIGEMT
     signal(SIGEMT,xf86SigHandler);
#endif
     signal(SIGFPE,xf86SigHandler);
#ifdef SIGBUS
     signal(SIGBUS,xf86SigHandler);
#endif
#ifdef SIGSYS
     signal(SIGSYS,xf86SigHandler);
#endif
#ifdef SIGXCPU
     signal(SIGXCPU,xf86SigHandler);
#endif
#ifdef SIGXFSZ
     signal(SIGXFSZ,xf86SigHandler);
#endif
  }
#endif

d1210 1
a1210 1
    
d1220 1
a1220 1
    } 
d1237 2
a1238 2
  for (i = 0; i < xf86NumScreens; i++) {    
   	xf86EnableAccess(xf86Screens[i]);
d1246 1
a1246 1
	xf86Screens[i]->LoadPalette = NULL; 
d1281 1
a1281 1
	xf86MonPtr DDC = (xf86MonPtr)(xf86Screens[i]->monitor->DDC); 
d1315 2
a1316 2
     int     	  argc;
     char    	  **argv;
d1319 1
a1319 2
    InputDriverPtr pDrv;
    InputInfoPtr pInfo;
d1322 2
a1323 1
    xf86Info.inputPending = FALSE;
d1332 3
a1334 30
        if ((pDrv = xf86LookupInputDriver((*pDev)->driver)) == NULL) {
            xf86Msg(X_ERROR, "No Input driver matching `%s'\n", (*pDev)->driver);
            /* XXX For now, just continue. */
            continue;
        }
        if (!pDrv->PreInit) {
            xf86MsgVerb(X_WARNING, 0,
                    "Input driver `%s' has no PreInit function (ignoring)\n",
                    pDrv->driverName);
            continue;
        }
        pInfo = pDrv->PreInit(pDrv, *pDev, 0);
        if (!pInfo) {
            xf86Msg(X_ERROR, "PreInit returned NULL for \"%s\"\n",
                    (*pDev)->identifier);
            continue;
        } else if (!(pInfo->flags & XI86_CONFIGURED)) {
            xf86Msg(X_ERROR, "PreInit failed for input device \"%s\"\n",
                    (*pDev)->identifier);
            xf86DeleteInput(pInfo, 0);
            continue;
        }
    }

    /* Initialise all input devices. */
    pInfo = xf86InputDevs;
    while (pInfo) {
        xf86Msg(X_INFO, "evaluating device (%s)\n", pInfo->name);
	xf86ActivateDevice(pInfo);
	pInfo = pInfo->next;
a1335 2

    mieqInit();
a1337 4
#ifndef SET_STDERR_NONBLOCKING
#define SET_STDERR_NONBLOCKING 1
#endif

a1356 4
  OsDelayInitColors = TRUE;
#ifndef BUILTIN_FONTS
  loadableFonts = TRUE;
#endif
a1360 1
#if SET_STDERR_NONBLOCKING
a1367 1
#endif
a1422 3
#ifdef USE_XF86_SERVERLOCK
    xf86UnlockServer();
#endif
d1471 1
a1471 1
  
d1473 1
a1473 1
  
d1517 12
a1536 2


d1555 1
a1555 1
  if (getuid() == 0 || !issetugid())
a1601 5
  if (!strcmp(argv[i],"-showunresolved"))
  {
    xf86ShowUnresolved = TRUE;
    return 1;
  }
a1623 12
#ifdef XF86MISC
  if (!strcmp(argv[i],"-disableModInDev"))
  {
    xf86MiscModInDevDisabled = TRUE;
    return 1;
  }
  if (!strcmp(argv[i],"-allowNonLocalModInDev"))
  {
    xf86MiscModInDevAllowNonLocal = TRUE;
    return 1;
  }
#endif
a1628 5
  if (!strcmp(argv[i],"-bestRefresh"))
  {
    xf86BestRefresh = TRUE;
    return 1;
  }
a1691 6
  /* Notice the -co flag, but allow it to pass to the dix layer */
  if (!strcmp(argv[i], "-co"))
  {
    xf86coFlag = TRUE;
    return 0;
  }
d1767 1
a1767 1
  if (!strcmp(argv[i], "-gamma")  || !strcmp(argv[i], "-rgamma") || 
d1771 1
a1771 1
    CHECK_FOR_REQUIRED_ARGUMENT();    
d1806 1
a1806 1
    CHECK_FOR_REQUIRED_ARGUMENT();    
d1843 6
d1860 1
a1860 1
  if (!strcmp(argv[i], "-modalias"))
d1862 5
a1866 2
    xf86DoModalias = TRUE;
    xf86AllowMouseOpenFail = TRUE;
d1886 7
a1896 5
/* ddxInitGlobals - called by |InitGlobals| from os/util.c */
void ddxInitGlobals(void)
{
}

d1914 1
a1941 4
#ifdef XF86MISC
  ErrorF("-disableModInDev       disable dynamic modification of input device settings\n");
  ErrorF("-allowNonLocalModInDev allow changes to keyboard and mouse settings\n");
  ErrorF("                       from non-local clients\n");
a1942 2
#endif
  ErrorF("-bestRefresh           choose modes with the best refresh rate\n");
a1955 11
static void
xf86PrintDefaultModulePath(void)
{
  ErrorF("%s\n", DEFAULT_MODULE_PATH);
}

static void
xf86PrintDefaultLibraryPath(void)
{
  ErrorF("%s\n", DEFAULT_LIBRARY_PATH);
}
d1959 1
a1959 1
 */             
d2030 1
a2030 1
	
d2052 1
a2052 1
   
a2058 1

@


1.8
log
@yet another gcc2 found bad coding practice, move variable declartion to the
top of the scope. this time found by sparc.
@
text
@d685 1
a685 1
  GDevPtr		 configured_device
@


1.7
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d685 1
d775 1
a775 1
    GDevPtr configured_device = xf86ConfigLayout.screens->screen->device;
@


1.6
log
@variable declarations at the beginning of the scope; found by sparc (a gcc2 arch)
@
text
@d138 202
a688 1
    GDevPtr configured_device;
d697 11
a707 9
    xf86PrintBanner();
    xf86PrintMarkers();
    if (xf86LogFile)  {
	time_t t;
	const char *ct;
	t = time(NULL);
	ct = ctime(&t);
	xf86MsgVerb(xf86LogFileFrom, 0, "Log file: \"%s\", Time: %s",
		    xf86LogFile, ct);
d711 1
a711 1
    if (!xf86DoProbe && !xf86DoConfigure) {
d748 4
d774 1
a774 1
    configured_device = xf86ConfigLayout.screens->screen->device;
d1927 6
d1977 1
a2020 125
}


#ifndef OSNAME
#define OSNAME " unknown"
#endif
#ifndef OSVENDOR
#define OSVENDOR ""
#endif
#ifndef PRE_RELEASE
#define PRE_RELEASE XORG_VERSION_SNAP
#endif

static void
xf86PrintBanner()
{
#if PRE_RELEASE
  ErrorF("\n"
    "This is a pre-release version of the X server from " XVENDORNAME ".\n"
    "It is not supported in any way.\n"
    "Bugs may be filed in the bugzilla at http://bugs.freedesktop.org/.\n"
    "Select the \"xorg\" product for bugs you find in this release.\n"
    "Before reporting bugs in pre-release versions please check the\n"
    "latest version in the X.Org Foundation git repository.\n"
    "See http://wiki.x.org/wiki/GitPage for git access instructions.\n");
#endif
  ErrorF("\nX.Org X Server %d.%d.%d",
	 XORG_VERSION_MAJOR,
	 XORG_VERSION_MINOR,
	 XORG_VERSION_PATCH);
#if XORG_VERSION_SNAP > 0
  ErrorF(".%d", XORG_VERSION_SNAP);
#endif

#if XORG_VERSION_SNAP >= 900
  /* When the minor number is 99, that signifies that the we are making
   * a release candidate for a major version.  (X.0.0)
   * When the patch number is 99, that signifies that the we are making
   * a release candidate for a minor version.  (X.Y.0)
   * When the patch number is < 99, then we are making a release
   * candidate for the next point release.  (X.Y.Z)
   */
#if XORG_VERSION_MINOR >= 99
  ErrorF(" (%d.0.0 RC %d)", XORG_VERSION_MAJOR+1, XORG_VERSION_SNAP - 900);
#elif XORG_VERSION_PATCH == 99
  ErrorF(" (%d.%d.0 RC %d)", XORG_VERSION_MAJOR, XORG_VERSION_MINOR + 1,
				XORG_VERSION_SNAP - 900);
#else
  ErrorF(" (%d.%d.%d RC %d)", XORG_VERSION_MAJOR, XORG_VERSION_MINOR,
 			 XORG_VERSION_PATCH + 1, XORG_VERSION_SNAP - 900);
#endif
#endif

#ifdef XORG_CUSTOM_VERSION
  ErrorF(" (%s)", XORG_CUSTOM_VERSION);
#endif
#ifndef XORG_DATE
#define XORG_DATE XF86_DATE
#endif
  ErrorF("\nRelease Date: %s\n", XORG_DATE);
  ErrorF("X Protocol Version %d, Revision %d\n",
         X_PROTOCOL, X_PROTOCOL_REVISION);
  ErrorF("Build Operating System: %s %s\n", OSNAME, OSVENDOR);
#ifdef HAS_UTSNAME
  {
    struct utsname name;

    /* Linux & BSD state that 0 is success, SysV (including Solaris, HP-UX,
       and Irix) and Single Unix Spec 3 just say that non-negative is success.
       All agree that failure is represented by a negative number.
     */
    if (uname(&name) >= 0) {
      ErrorF("Current Operating System: %s %s %s %s %s\n",
	name.sysname, name.nodename, name.release, name.version, name.machine);
    }
  }
#endif
#if defined(BUILD_DATE) && (BUILD_DATE > 19000000)
  {
    struct tm t;
    char buf[100];

    bzero(&t, sizeof(t));
    bzero(buf, sizeof(buf));
    t.tm_mday = BUILD_DATE % 100;
    t.tm_mon = (BUILD_DATE / 100) % 100 - 1;
    t.tm_year = BUILD_DATE / 10000 - 1900;
#if defined(BUILD_TIME)
    t.tm_sec = BUILD_TIME % 100;
    t.tm_min = (BUILD_TIME / 100) % 100;
    t.tm_hour = (BUILD_TIME / 10000) % 100;
    if (strftime(buf, sizeof(buf), "%d %B %Y  %I:%M:%S%p", &t))
       ErrorF("Build Date: %s\n", buf);
#else
    if (strftime(buf, sizeof(buf), "%d %B %Y", &t))
       ErrorF("Build Date: %s\n", buf);
#endif
  }
#endif
#if defined(CLOG_DATE) && (CLOG_DATE > 19000000)
  {
    struct tm t;
    char buf[100];

    bzero(&t, sizeof(t));
    bzero(buf, sizeof(buf));
    t.tm_mday = CLOG_DATE % 100;
    t.tm_mon = (CLOG_DATE / 100) % 100 - 1;
    t.tm_year = CLOG_DATE / 10000 - 1900;
    if (strftime(buf, sizeof(buf), "%d %B %Y", &t))
       ErrorF("Changelog Date: %s\n", buf);
  }
#endif
#if defined(BUILDERSTRING)
  ErrorF("%s \n",BUILDERSTRING);
#endif
  ErrorF("\tBefore reporting problems, check "__VENDORDWEBSUPPORT__"\n"
	 "\tto make sure that you have the latest version.\n");
  ErrorF("Module Loader present\n");
}

static void
xf86PrintMarkers()
{
  LogPrintMarkers();
@


1.5
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d487 1
d567 1
a567 1
    GDevPtr configured_device = xf86ConfigLayout.screens->screen->device;
@


1.4
log
@merge xserver 1.4, 1st pass
@
text
@d95 3
d105 4
a108 1
static void xf86RunVtInit(void);
a113 5
static char *baseModules[] = {
	"pcidata",
	NULL
};

d145 2
a146 2
  CreateWindowProcPtr CreateWindow =
    (CreateWindowProcPtr)(pScreen->devPrivates[xf86CreateRootWindowIndex].ptr);
d162 1
a162 1
  pScreen->devPrivates[xf86CreateRootWindowIndex].ptr = NULL;
d179 5
a183 6
	  err = ChangeWindowProperty(pWin,
				     prop, pProp->type,
				     pProp->format, PropModeReplace,
				     pProp->size, pProp->data,
				     FALSE
				     );
a203 7
/*
 * InitOutput --
 *	Initialize screenInfo for all actually accessible framebuffers.
 *      That includes vt-manager setup, querying all possible devices and
 *      collecting the pixmap formats.
 */

a235 3
    /* Run an external VT Init program if specified in the config file */
    xf86RunVtInit();

d240 232
a475 1
  static unsigned long   generation = 0;
a485 8
  /* Do this early? */
  if (generation != serverGeneration) {
      xf86ScreenIndex = AllocateScreenPrivateIndex();
      xf86CreateRootWindowIndex = AllocateScreenPrivateIndex();
      xf86PixmapIndex = AllocatePixmapPrivateIndex();
      generation = serverGeneration;
  }

a532 4
    /* Force load mandatory base modules */
    if (!xf86LoadModules(baseModules, NULL))
	FatalError("Unable to load required base modules, Exiting...\n");
    
d563 10
d659 2
a660 10
	    
	if (xf86DriverList[i]->Probe != NULL)
	    xf86DriverList[i]->Probe(xf86DriverList[i], PROBE_DEFAULT);
	else {
	    xf86MsgVerb(X_WARNING, 0,
			"Driver `%s' has no Probe function (ignoring)\n",
			xf86DriverList[i]->driverName
			? xf86DriverList[i]->driverName : "noname");
	}
	xf86SetPciVideo(NULL,NONE);
d1061 2
a1062 2
	screenInfo.screens[scr_index]->devPrivates[xf86ScreenIndex].ptr
	  = (pointer)xf86Screens[i];
d1078 3
a1080 2
      screenInfo.screens[scr_index]->devPrivates[xf86CreateRootWindowIndex].ptr
	= (void*)(xf86Screens[i]->pScreen->CreateWindow);
d1130 29
a1158 37
    if (serverGeneration == 1) {
	/* Call the PreInit function for each input device instance. */
	for (pDev = xf86ConfigLayout.inputs; pDev && *pDev; pDev++) {
	    /* Replace obsolete keyboard driver with kbd */
	    if (!xf86NameCmp((*pDev)->driver, "keyboard")) {
		xf86MsgVerb(X_WARNING, 0,
			    "*** WARNING the legacy keyboard driver \"%s\" has been removed\n",
			    (*pDev)->driver);
		xf86MsgVerb(X_WARNING, 0,
			    "*** Using the new \"kbd\" driver for \"%s\".\n",
			    (*pDev)->identifier);
		strcpy((*pDev)->driver, "kbd");
            }

	    if ((pDrv = xf86LookupInputDriver((*pDev)->driver)) == NULL) {
		xf86Msg(X_ERROR, "No Input driver matching `%s'\n", (*pDev)->driver);
		/* XXX For now, just continue. */
		continue;
	    }
	    if (!pDrv->PreInit) {
		xf86MsgVerb(X_WARNING, 0,
		    "Input driver `%s' has no PreInit function (ignoring)\n",
		    pDrv->driverName);
		continue;
	    }
	    pInfo = pDrv->PreInit(pDrv, *pDev, 0);
	    if (!pInfo) {
		xf86Msg(X_ERROR, "PreInit returned NULL for \"%s\"\n",
			(*pDev)->identifier);
		continue;
	    } else if (!(pInfo->flags & XI86_CONFIGURED)) {
		xf86Msg(X_ERROR, "PreInit failed for input device \"%s\"\n",
			(*pDev)->identifier);
		xf86DeleteInput(pInfo, 0);
		continue;
	    }
	}
a1191 2
  xf86WrapperInit();

a1299 4
#ifdef HAS_USL_VTS
  /* Need the sleep when starting X from within another X session */
  sleep(1);
#endif
d1302 1
a1302 1
      DPMSSet(DPMSModeOn);
a1574 9
  if (!strcmp(argv[i], "-bpp"))
  {
    ErrorF("The -bpp option is no longer supported.\n"
	"\tUse -depth to set the color depth, and use -fbbpp if you really\n"
	"\tneed to force a non-default framebuffer (hardware) pixel format.\n");
    if (++i >= argc)
      return 1;
    return 2;
  }
a1686 4
  if (!strcmp(argv[i], "-scanpci"))
  {
    DoScanPci(argc, argv, i);
  }
d1727 3
a1729 2
       xf86IsolateDevice.bus = bus;
       xf86IsolateDevice.device = device;
a1765 1
  ErrorF("-scanpci               execute the scanpci module and exit\n");
a1942 38
}

static void
xf86RunVtInit(void)
{
    int i;

    /*
     * If VTInit was set, run that program with consoleFd as stdin and stdout
     */

    if (xf86Info.vtinit) {
      switch(fork()) {
      case -1:
          FatalError("xf86RunVtInit: fork failed (%s)\n", strerror(errno));
          break;
      case 0:  /* child */
	  if (setuid(getuid()) == -1) {
	      xf86Msg(X_ERROR, "xf86RunVtInit: setuid failed (%s)\n",
			 strerror(errno));
	      exit(255);
	  }
          /* set stdin, stdout to the consoleFd */
          for (i = 0; i < 2; i++) {
            if (xf86Info.consoleFd != i) {
              close(i);
              dup(xf86Info.consoleFd);
            }
          }
          execl("/bin/sh", "sh", "-c", xf86Info.vtinit, (void *)NULL);
          xf86Msg(X_WARNING, "exec of /bin/sh failed for VTInit (%s)\n",
                 strerror(errno));
          exit(255);
          break;
      default:  /* parent */
          wait(NULL);
      }
    }
@


1.3
log
@- merge xserver 1.1.99.903
- regen generated files
@
text
@a0 1

d38 1
d41 1
a41 1
#if !defined(WIN32) && !defined(__UNIXOS2__)
a46 3
#ifdef __UNIXOS2__
#define I_NEED_OS2_H
#endif
a103 4
#ifdef __UNIXOS2__
extern void os2ServerVideoAccess();
#endif

a132 12
#ifdef USE_DEPRECATED_KEYBOARD_DRIVER
static InputDriverRec XF86KEYBOARD = {
	1,
	"keyboard",
	NULL,
	NULL,
	NULL,
	NULL,
	0
};
#endif

a236 3
#ifdef MEMDEBUG
       signal(SIGUSR2,xf86SigMemDebug);
#endif
a262 4
#ifdef __UNIXOS2__
  os2ServerVideoAccess();  /* See if we have access to the screen before doing anything */
#endif

a319 33
#ifdef TESTING
    {
	char **list, **l;
	const char *subdirs[] = {
		"drivers",
		NULL
	};
	const char *patlist[] = {
		"(.*)_drv\\.so",
		"(.*)_drv\\.o",
		NULL
	};
	ErrorF("Getting module listing...\n");
	list = LoaderListDirs(NULL, NULL);
	if (list)
	    for (l = list; *l; l++)
		ErrorF("module: %s\n", *l);
	LoaderFreeDirList(list);
	ErrorF("Getting video driver listing...\n");
	list = LoaderListDirs(subdirs, NULL);
	if (list)
	    for (l = list; *l; l++)
		ErrorF("video driver: %s\n", *l);
	LoaderFreeDirList(list);
	ErrorF("Getting driver listing...\n");
	list = LoaderListDirs(NULL, patlist);
	if (list)
	    for (l = list; *l; l++)
		ErrorF("video driver: %s\n", *l);
	LoaderFreeDirList(list);
    }
#endif
	
a358 4
#ifdef USE_DEPRECATED_KEYBOARD_DRIVER
    /* Setup the builtin input drivers */
    xf86AddInputDriver(&XF86KEYBOARD, NULL, 0);
#endif
d711 1
a711 1
      VTAtom = MakeAtom(VT_ATOM_NAME, sizeof(VT_ATOM_NAME), TRUE);
a731 21
#if BITMAP_SCANLINE_UNIT == 64
    /*
     * cfb24 doesn't currently work on architectures with a 64 bit
     * BITMAP_SCANLINE_UNIT, so check for 24 bit pixel size for pixmaps
     * or framebuffers.
     */
    {
	Bool usesCfb24 = FALSE;

	if (PIX24TOBPP(pix24) == 24)
	    usesCfb24 = TRUE;
	for (i = 0; i < xf86NumScreens; i++)
	    if (xf86Screens[i]->bitsPerPixel == 24)
		usesCfb24 = TRUE;
	if (usesCfb24) {
	    FatalError("24-bit pixel size is not supported on systems with"
			" 64-bit scanlines.\n");
	}
    }
#endif

a887 8
#ifdef NOT_USED
      /*
       * Here we have to let the driver getting access of the VT. Note that
       * this doesn't mean that the graphics board may access automatically
       * the monitor. If the monitor is shared this is done in xf86CrossScreen!
       */
      if (!xf86Info.sharedMonitor) (xf86Screens[i]->EnterLeaveMonitor)(ENTER);
#endif
a900 15

static InputDriverPtr
MatchInput(IDevPtr pDev)
{
    int i;

    for (i = 0; i < xf86NumInputDrivers; i++) {
	if (xf86InputDriverList[i] && xf86InputDriverList[i]->driverName &&
	    xf86NameCmp(pDev->driver, xf86InputDriverList[i]->driverName) == 0)
	    return xf86InputDriverList[i];
    }
    return NULL;
}


d911 1
a911 1
    IDevPtr pDev;
a913 1
    static InputInfoPtr coreKeyboard = NULL, corePointer = NULL;
d920 11
a930 12
	for (pDev = xf86ConfigLayout.inputs; pDev && pDev->identifier; pDev++) {
#ifdef USE_DEPRECATED_KEYBOARD_DRIVER
	    /* XXX The keyboard driver is a special case for now. */
	    if (!xf86NameCmp(pDev->driver, "keyboard")) {
		xf86MsgVerb(X_WARNING, 0, "*** WARNING the legacy keyboard driver \"keyboard\" is deprecated\n");
		xf86MsgVerb(X_WARNING, 0, "*** and will be removed in the next release of the Xorg server.\n");
		xf86MsgVerb(X_WARNING, 0, "*** Please consider using the the new \"kbd\" driver for \"%s\".\n",
			pDev->identifier);

		continue;
	    }
#endif
d932 2
a933 2
	    if ((pDrv = MatchInput(pDev)) == NULL) {
		xf86Msg(X_ERROR, "No Input driver matching `%s'\n", pDev->driver);
d943 1
a943 1
	    pInfo = pDrv->PreInit(pDrv, pDev, 0);
d946 1
a946 1
			pDev->identifier);
d950 1
a950 1
			pDev->identifier);
a953 32
	    if (pInfo->flags & XI86_CORE_KEYBOARD) {
		if (coreKeyboard) {
		    xf86Msg(X_ERROR,
		      "Attempt to register more than one core keyboard (%s)\n",
		      pInfo->name);
		    pInfo->flags &= ~XI86_CORE_KEYBOARD;
		} else {
		    if (!(pInfo->flags & XI86_KEYBOARD_CAPABLE)) {
			/* XXX just a warning for now */
			xf86Msg(X_WARNING,
			    "%s: does not have core keyboard capabilities\n",
			    pInfo->name);
		    }
		    coreKeyboard = pInfo;
		}
	    }
	    if (pInfo->flags & XI86_CORE_POINTER) {
		if (corePointer) {
		    xf86Msg(X_ERROR,
			"Attempt to register more than one core pointer (%s)\n",
			pInfo->name);
		    pInfo->flags &= ~XI86_CORE_POINTER;
		} else {
		    if (!(pInfo->flags & XI86_POINTER_CAPABLE)) {
			/* XXX just a warning for now */
			xf86Msg(X_WARNING,
			    "%s: does not have core pointer capabilities\n",
			    pInfo->name);
		    }
		    corePointer = pInfo;
		}
	    }
a954 10
	if (!corePointer) {
	    xf86Msg(X_WARNING, "No core pointer registered\n");
	    /* XXX register a dummy core pointer */
	}
#ifdef NEW_KBD
	if (!coreKeyboard) {
	    xf86Msg(X_WARNING, "No core keyboard registered\n");
	    /* XXX register a dummy core keyboard */
	}
#endif
d960 1
d965 1
a965 22
    if (coreKeyboard) {
      xf86Info.pKeyboard = coreKeyboard->dev;
      xf86Info.kbdEvents = NULL; /* to prevent the internal keybord driver usage*/
    }
    else {
#ifdef USE_DEPRECATED_KEYBOARD_DRIVER
      /* Only set this if we're allowing the old driver. */
	if (xf86Info.kbdProc != NULL) 
	    xf86Info.pKeyboard = AddInputDevice(xf86Info.kbdProc, TRUE);
#endif
    }
    if (corePointer)
	xf86Info.pMouse = corePointer->dev;
    if (xf86Info.pKeyboard)
      RegisterKeyboardDevice(xf86Info.pKeyboard); 

  miRegisterPointerDevice(screenInfo.screens[0], xf86Info.pMouse);
#ifdef XINPUT
  xf86eqInit ((DevicePtr)xf86Info.pKeyboard, (DevicePtr)xf86Info.pMouse);
#else
  mieqInit ((DevicePtr)xf86Info.pKeyboard, (DevicePtr)xf86Info.pMouse);
#endif
d994 1
d996 1
a1012 1
#if !defined(__EMX__)
a1013 1
#endif
a1095 6
   * try to deinitialize all input devices
   */
  if (xf86Info.kbdProc && xf86Info.pKeyboard)
    (xf86Info.kbdProc)(xf86Info.pKeyboard, DEVICE_CLOSE);

  /*
d1647 1
a1647 1
  ErrorF("\nX Window System Version %d.%d.%d",
d1681 2
a1682 2
  ErrorF("X Protocol Version %d, Revision %d, %s\n",
         X_PROTOCOL, X_PROTOCOL_REVISION, XORG_RELEASE );
d1708 7
d1717 1
a1814 3
#ifndef NORMALISE_MODULE_NAME
	name = xstrdup(list[i]);
#else
a1816 1
#endif
d1821 5
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@d103 2
d1514 10
d1790 2
d1915 12
@


1.1
log
@Initial revision
@
text
@d150 4
d1146 5
d1153 1
a1153 1
OsVendorInit()
d1194 6
d1367 3
a1369 2
  /* First the options that are only allowed for root */
  if (getuid() == 0 || geteuid() != 0)
d1409 5
d1670 3
d1677 1
a1677 1
    if (getuid() != 0 && geteuid() == 0) {
d1683 3
d1688 11
d1778 3
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.1.99.903 from X.Org 7.2RC3
@
text
@a102 2
static void xf86PrintDefaultModulePath(void);
static void xf86PrintDefaultLibraryPath(void);
a1490 10
  if (!strcmp(argv[i],"-showDefaultModulePath"))
  {
    xf86PrintDefaultModulePath();
    exit(0);
  }
  if (!strcmp(argv[i],"-showDefaultLibPath"))
  {
    xf86PrintDefaultLibraryPath();
    exit(0);
  }
a1739 2
  ErrorF("-showDefaultModulePath show the server default module path\n");
  ErrorF("-showDefaultLibPath    show the server default library path\n");
a1859 12
}

static void
xf86PrintDefaultModulePath(void)
{
  ErrorF("%s\n", DEFAULT_MODULE_PATH);
}

static void
xf86PrintDefaultLibraryPath(void)
{
  ErrorF("%s\n", DEFAULT_LIBRARY_PATH);
@


1.1.1.3
log
@xserver 1.4
@
text
@d1 1
a38 1
#include <errno.h>
d41 1
a41 1
#if !defined(WIN32)
d47 3
d107 4
d140 12
d252 3
d281 4
d342 33
d414 4
d770 1
a770 1
      VTAtom = MakeAtom(VT_ATOM_NAME, sizeof(VT_ATOM_NAME) - 1, TRUE);
d791 21
d968 8
d989 15
d1014 1
a1014 1
    IDevPtr* pDev;
d1017 1
d1024 12
a1035 11
	for (pDev = xf86ConfigLayout.inputs; pDev && *pDev; pDev++) {
	    /* Replace obsolete keyboard driver with kbd */
	    if (!xf86NameCmp((*pDev)->driver, "keyboard")) {
		xf86MsgVerb(X_WARNING, 0,
			    "*** WARNING the legacy keyboard driver \"%s\" has been removed\n",
			    (*pDev)->driver);
		xf86MsgVerb(X_WARNING, 0,
			    "*** Using the new \"kbd\" driver for \"%s\".\n",
			    (*pDev)->identifier);
		strcpy((*pDev)->driver, "kbd");
            }
d1037 2
a1038 2
	    if ((pDrv = xf86LookupInputDriver((*pDev)->driver)) == NULL) {
		xf86Msg(X_ERROR, "No Input driver matching `%s'\n", (*pDev)->driver);
d1048 1
a1048 1
	    pInfo = pDrv->PreInit(pDrv, *pDev, 0);
d1051 1
a1051 1
			(*pDev)->identifier);
d1055 1
a1055 1
			(*pDev)->identifier);
d1059 32
d1092 10
a1106 1
        xf86Msg(X_INFO, "evaluating device (%s)\n", pInfo->name);
d1111 22
a1132 1
    mieqInit();
a1155 1
#ifndef BUILTIN_FONTS
a1156 1
#endif
d1173 1
d1175 1
d1252 6
d1783 1
a1783 1
  ErrorF("\nX.Org X Server %d.%d.%d",
d1817 2
a1818 2
  ErrorF("X Protocol Version %d, Revision %d\n",
         X_PROTOCOL, X_PROTOCOL_REVISION);
a1843 7
#if defined(BUILD_TIME)
    t.tm_sec = BUILD_TIME % 100;
    t.tm_min = (BUILD_TIME / 100) % 100;
    t.tm_hour = (BUILD_TIME / 10000) % 100;
    if (strftime(buf, sizeof(buf), "%d %B %Y  %I:%M:%S%p", &t))
       ErrorF("Build Date: %s\n", buf);
#else
a1845 1
#endif
d1943 3
d1948 1
a1952 5

	/* Replace obsolete keyboard driver with kbd */
	if (!xf86NameCmp(name, "keyboard")) {
	    strcpy(name, "kbd");
	}
@


