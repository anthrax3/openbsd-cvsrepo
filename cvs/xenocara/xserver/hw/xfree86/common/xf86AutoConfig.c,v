head	1.27;
access;
symbols
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.2
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.2
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2016.08.03.19.31.23;	author matthieu;	state Exp;
branches;
next	1.26;
commitid	ybM2mWdopFZgaca3;

1.26
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.25;
commitid	s0SI41sEunLdyFfd;

1.25
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.24;
commitid	Te1daavkBLskZ8gc;

1.24
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.23;
commitid	cVXoV5PxI8YrEaVA;

1.23
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2012.11.04.17.20.33;	author tobiasu;	state Exp;
branches;
next	1.20;

1.20
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.28.17.59.01;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.18.22.37.36;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.15.20.50.52;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.27.20.49.51;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.06.05.57.00;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.11.22.12.50;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.19.21.53.30;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.07.30.21.43.11;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.07.12.13.02.55;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.16.23.20.50;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.20.10.25.12;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.16.20.59.14;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.05;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@xserver: fix an off-by-one error that lead to asprintf("%s", NULL)

reported by deraadt@@, fix reviewed in X.Org by Keith Packard.
@
text
@/*
 * Copyright 2003 by David H. Dawes.
 * Copyright 2003 by X-Oz Technologies.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 *
 * Author: David Dawes <dawes@@XFree86.Org>.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "xf86.h"
#include "xf86Parser.h"
#include "xf86tokens.h"
#include "xf86Config.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"
#include "xf86platformBus.h"
#include "xf86pciBus.h"
#if defined(__sparc__)
#include "xf86sbusBus.h"
#endif

#ifdef sun
#include <sys/visual_io.h>
#include <ctype.h>
#endif

/* Sections for the default built-in configuration. */

#define BUILTIN_DEVICE_NAME \
	"\"Builtin Default %s Device %d\""

#define BUILTIN_DEVICE_SECTION_PRE \
	"Section \"Device\"\n" \
	"\tIdentifier\t" BUILTIN_DEVICE_NAME "\n" \
	"\tDriver\t\"%s\"\n"

#define BUILTIN_DEVICE_SECTION_POST \
	"EndSection\n\n"

#define BUILTIN_DEVICE_SECTION \
	BUILTIN_DEVICE_SECTION_PRE \
	BUILTIN_DEVICE_SECTION_POST

#define BUILTIN_SCREEN_NAME \
	"\"Builtin Default %s Screen %d\""

#define BUILTIN_SCREEN_SECTION \
	"Section \"Screen\"\n" \
	"\tIdentifier\t" BUILTIN_SCREEN_NAME "\n" \
	"\tDevice\t" BUILTIN_DEVICE_NAME "\n" \
	"EndSection\n\n"

#define BUILTIN_LAYOUT_SECTION_PRE \
	"Section \"ServerLayout\"\n" \
	"\tIdentifier\t\"Builtin Default Layout\"\n"

#define BUILTIN_LAYOUT_SCREEN_LINE \
	"\tScreen\t" BUILTIN_SCREEN_NAME "\n"

#define BUILTIN_LAYOUT_SECTION_POST \
	"EndSection\n\n"

static const char **builtinConfig = NULL;
static int builtinLines = 0;

static void listPossibleVideoDrivers(char *matches[], int nmatches);

/*
 * A built-in config file is stored as an array of strings, with each string
 * representing a single line.  AppendToConfig() breaks up the string "s"
 * into lines, and appends those lines it to builtinConfig.
 */

static void
AppendToList(const char *s, const char ***list, int *lines)
{
    char *str, *newstr, *p;

    str = xnfstrdup(s);
    for (p = strtok(str, "\n"); p; p = strtok(NULL, "\n")) {
        (*lines)++;
        *list = xnfreallocarray(*list, *lines + 1, sizeof(**list));
        newstr = xnfalloc(strlen(p) + 2);
        strcpy(newstr, p);
        strcat(newstr, "\n");
        (*list)[*lines - 1] = newstr;
        (*list)[*lines] = NULL;
    }
    free(str);
}

static void
FreeList(const char ***list, int *lines)
{
    int i;

    for (i = 0; i < *lines; i++) {
        free((char *) ((*list)[i]));
    }
    free(*list);
    *list = NULL;
    *lines = 0;
}

static void
FreeConfig(void)
{
    FreeList(&builtinConfig, &builtinLines);
}

static void
AppendToConfig(const char *s)
{
    AppendToList(s, &builtinConfig, &builtinLines);
}

Bool
xf86AutoConfig(void)
{
    char *deviceList[20];
    char **p;
    const char **cp;
    char buf[1024];
    ConfigStatus ret;

    listPossibleVideoDrivers(deviceList, 20);

    for (p = deviceList; *p; p++) {
        snprintf(buf, sizeof(buf), BUILTIN_DEVICE_SECTION, *p, 0, *p);
        AppendToConfig(buf);
        snprintf(buf, sizeof(buf), BUILTIN_SCREEN_SECTION, *p, 0, *p, 0);
        AppendToConfig(buf);
    }

    AppendToConfig(BUILTIN_LAYOUT_SECTION_PRE);
    for (p = deviceList; *p; p++) {
        snprintf(buf, sizeof(buf), BUILTIN_LAYOUT_SCREEN_LINE, *p, 0);
        AppendToConfig(buf);
    }
    AppendToConfig(BUILTIN_LAYOUT_SECTION_POST);

    for (p = deviceList; *p; p++) {
        free(*p);
    }

    xf86MsgVerb(X_DEFAULT, 0,
                "Using default built-in configuration (%d lines)\n",
                builtinLines);

    xf86MsgVerb(X_DEFAULT, 3, "--- Start of built-in configuration ---\n");
    for (cp = builtinConfig; *cp; cp++)
        xf86ErrorFVerb(3, "\t%s", *cp);
    xf86MsgVerb(X_DEFAULT, 3, "--- End of built-in configuration ---\n");

    xf86initConfigFiles();
    xf86setBuiltinConfig(builtinConfig);
    ret = xf86HandleConfigFile(TRUE);
    FreeConfig();

    if (ret != CONFIG_OK)
        xf86Msg(X_ERROR, "Error parsing the built-in default configuration.\n");

    return ret == CONFIG_OK;
}

static void
listPossibleVideoDrivers(char *matches[], int nmatches)
{
    int i;

    for (i = 0; i < nmatches; i++) {
        matches[i] = NULL;
    }
    i = 0;

#ifdef XSERVER_PLATFORM_BUS
    i = xf86PlatformMatchDriver(matches, nmatches);
#endif
#ifdef sun
    /* Check for driver type based on /dev/fb type and if valid, use
       it instead of PCI bus probe results */
    if (xf86Info.consoleFd >= 0 && (i < (nmatches - 1))) {
        struct vis_identifier visid;
        const char *cp;
        int iret;

        SYSCALL(iret = ioctl(xf86Info.consoleFd, VIS_GETIDENTIFIER, &visid));
        if (iret < 0) {
            int fbfd;

            fbfd = open(xf86SolarisFbDev, O_RDONLY);
            if (fbfd >= 0) {
                SYSCALL(iret = ioctl(fbfd, VIS_GETIDENTIFIER, &visid));
                close(fbfd);
            }
        }

        if (iret < 0) {
            xf86Msg(X_WARNING,
                    "could not get frame buffer identifier from %s\n",
                    xf86SolarisFbDev);
        }
        else {
            xf86Msg(X_PROBED, "console driver: %s\n", visid.name);

            /* Special case from before the general case was set */
            if (strcmp(visid.name, "NVDAnvda") == 0) {
                matches[i++] = xnfstrdup("nvidia");
            }

            /* General case - split into vendor name (initial all-caps
               prefix) & driver name (rest of the string). */
            if (strcmp(visid.name, "SUNWtext") != 0) {
                for (cp = visid.name; (*cp != '\0') && isupper(*cp); cp++) {
                    /* find end of all uppercase vendor section */
                }
                if ((cp != visid.name) && (*cp != '\0')) {
                    char *driverName = xnfstrdup(cp);
                    char *vendorName = xnfstrdup(visid.name);

                    vendorName[cp - visid.name] = '\0';

                    matches[i++] = vendorName;
                    matches[i++] = driverName;
                }
            }
        }
    }
#endif
#ifdef __sparc__
    if (i < (nmatches - 1))
    {
        char *sbusDriver = sparcDriverName();

        if (sbusDriver)
            matches[i++] = xnfstrdup(sbusDriver);
    }
#endif
#ifdef XSERVER_LIBPCIACCESS
    if (i < (nmatches - 1))
        i += xf86PciMatchDriver(&matches[i], nmatches - i);
#endif

#if defined(__linux__)
    matches[i++] = xnfstrdup("modesetting");
#endif

#if !defined(sun)
    /* Fallback to platform default frame buffer driver */
    if (i < (nmatches - 1)) {
#if defined(__OpenBSD__)
#if !defined(__i386__) && !defined(__amd64__)
        if (i == 0) {
            matches[i++] = xnfstrdup("wsfb");
        }
#endif
#elif !defined(__linux__) && defined(__sparc__)
        matches[i++] = xnfstrdup("wsfb");
#else
        matches[i++] = xnfstrdup("fbdev");
#endif
    }
#endif                          /* !sun */

    /* Fallback to platform default hardware */
    if (i < (nmatches - 1)) {
#if defined(__i386__) || defined(__amd64__) || defined(__hurd__)
        matches[i++] = xnfstrdup("vesa");
#elif defined(__sparc__) && defined(__linux__)
        matches[i++] = xnfstrdup("sunffb");
#endif
    }
}

/* copy a screen section and enter the desired driver
 * and insert it at i in the list of screens */
static Bool
copyScreen(confScreenPtr oscreen, GDevPtr odev, int i, char *driver)
{
    confScreenPtr nscreen;
    GDevPtr cptr = NULL;
    char *identifier;

    nscreen = malloc(sizeof(confScreenRec));
    if (!nscreen)
        return FALSE;
    memcpy(nscreen, oscreen, sizeof(confScreenRec));

    cptr = malloc(sizeof(GDevRec));
    if (!cptr) {
        free(nscreen);
        return FALSE;
    }
    memcpy(cptr, odev, sizeof(GDevRec));

    if (asprintf(&identifier, "Autoconfigured Video Device %s", driver)
        == -1) {
        free(cptr);
        free(nscreen);
        return FALSE;
    }
    cptr->driver = driver;
    cptr->identifier = identifier;

    xf86ConfigLayout.screens[i].screen = nscreen;

    /* now associate the new driver entry with the new screen entry */
    xf86ConfigLayout.screens[i].screen->device = cptr;
    cptr->myScreenSection = xf86ConfigLayout.screens[i].screen;

    return TRUE;
}

GDevPtr
autoConfigDevice(GDevPtr preconf_device)
{
    GDevPtr ptr = NULL;
    char *matches[20];          /* If we have more than 20 drivers we're in trouble */
    int num_matches = 0, num_screens = 0, i;
    screenLayoutPtr slp;

    if (!xf86configptr) {
        return NULL;
    }

    /* If there's a configured section with no driver chosen, use it */
    if (preconf_device) {
        ptr = preconf_device;
    }
    else {
        ptr = calloc(1, sizeof(GDevRec));
        if (!ptr) {
            return NULL;
        }
        ptr->chipID = -1;
        ptr->chipRev = -1;
        ptr->irq = -1;

        ptr->active = TRUE;
        ptr->claimed = FALSE;
        ptr->identifier = "Autoconfigured Video Device";
        ptr->driver = NULL;
    }
    if (!ptr->driver) {
        /* get all possible video drivers and count them */
        listPossibleVideoDrivers(matches, 20);
        for (; matches[num_matches]; num_matches++) {
            xf86Msg(X_DEFAULT, "Matched %s as autoconfigured driver %d\n",
                    matches[num_matches], num_matches);
        }

        slp = xf86ConfigLayout.screens;
        if (slp) {
            /* count the number of screens and make space for
             * a new screen for each additional possible driver
             * minus one for the already existing first one
             * plus one for the terminating NULL */
            for (; slp[num_screens].screen; num_screens++);
            xf86ConfigLayout.screens = xnfcalloc(num_screens + num_matches,
                                                 sizeof(screenLayoutRec));
            xf86ConfigLayout.screens[0] = slp[0];

            /* do the first match and set that for the original first screen */
            ptr->driver = matches[0];
            if (!xf86ConfigLayout.screens[0].screen->device) {
                xf86ConfigLayout.screens[0].screen->device = ptr;
                ptr->myScreenSection = xf86ConfigLayout.screens[0].screen;
            }

            /* for each other driver found, copy the first screen, insert it
             * into the list of screens and set the driver */
            for (i = 1; i < num_matches; i++) {
                if (!copyScreen(slp[0].screen, ptr, i, matches[i]))
                    return NULL;
            }

            /* shift the rest of the original screen list
             * to the end of the current screen list
             *
             * TODO Handle rest of multiple screen sections */
            for (i = 1; i < num_screens; i++) {
                xf86ConfigLayout.screens[i + num_matches] = slp[i];
            }
            xf86ConfigLayout.screens[num_screens + num_matches - 1].screen =
                NULL;
            free(slp);
        }
        else {
            /* layout does not have any screens, not much to do */
            ptr->driver = matches[0];
            for (i = 1; matches[i]; i++) {
                if (matches[i] != matches[0]) {
                    free(matches[i]);
                }
            }
        }
    }

    xf86Msg(X_DEFAULT, "Assigned the driver to the xf86ConfigLayout\n");

    return ptr;
}
@


1.26
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d398 1
a398 2
            i = 0;
            while (i++ < num_matches) {
@


1.25
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d108 1
a108 1
        *list = xnfrealloc(*list, (*lines + 1) * sizeof(**list));
@


1.24
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d12 1
a12 1
 * 
d15 1
a15 1
 * 
d23 1
a23 1
 * 
d28 1
a28 1
 * 
a210 1
        extern char xf86SolarisFbDev[PATH_MAX];
@


1.23
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d268 1
a268 1
        i = xf86PciMatchDriver(matches, nmatches);
d309 1
d323 1
a323 1
    if (asprintf(&cptr->identifier, "Autoconfigured Video Device %s", driver)
d330 1
@


1.22
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a269 8
    /* Fallback to platform default hardware */
    if (i < (nmatches - 1)) {
#if defined(__i386__) || defined(__amd64__) || defined(__hurd__)
        matches[i++] = xnfstrdup("vesa");
#elif defined(__sparc__) && defined(__linux__)
        matches[i++] = xnfstrdup("sunffb");
#endif
    }
d291 9
@


1.21
log
@Include declaration of sparcDriverName()

Fixes segfault on sunffb graphics. ok matthieu@@
@
text
@d42 1
d202 3
d208 1
a208 1
    if (xf86Info.consoleFd >= 0) {
d257 2
a258 1
#if defined(__sparc__)
d267 2
a268 1
    i = xf86PciMatchDriver(matches, nmatches);
d278 4
@


1.20
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d43 1
a43 1
#if defined(__sparc__) && !defined(__OpenBSD__)
@


1.19
log
@Update to xserver 1.11.2
@
text
@d44 1
a44 1
# include "xf86sbusBus.h"
d48 2
a49 2
# include <sys/visual_io.h>
# include <ctype.h>
d106 7
a112 7
	(*lines)++;
	*list = xnfrealloc(*list, (*lines + 1) * sizeof(**list));
	newstr = xnfalloc(strlen(p) + 2);
	strcpy(newstr, p);
	strcat(newstr, "\n");
	(*list)[*lines - 1] = newstr;
	(*list)[*lines] = NULL;
d123 1
a123 1
	free((char *)((*list)[i]));
d154 4
a157 4
	snprintf(buf, sizeof(buf), BUILTIN_DEVICE_SECTION, *p, 0, *p);
	AppendToConfig(buf);
	snprintf(buf, sizeof(buf), BUILTIN_SCREEN_SECTION, *p, 0, *p, 0);
	AppendToConfig(buf);
d162 2
a163 2
	snprintf(buf, sizeof(buf), BUILTIN_LAYOUT_SCREEN_LINE, *p, 0);
	AppendToConfig(buf);
d168 1
a168 1
	free(*p);
d172 2
a173 2
		"Using default built-in configuration (%d lines)\n",
		builtinLines);
d177 1
a177 1
	xf86ErrorFVerb(3, "\t%s", *cp);
d186 1
a186 1
	xf86Msg(X_ERROR, "Error parsing the built-in default configuration.\n");
d195 2
a196 2
    
    for (i = 0 ; i < nmatches ; i++) {
d205 46
a250 44
	struct vis_identifier   visid;
	const char *cp;
	extern char xf86SolarisFbDev[PATH_MAX];
	int iret;

	SYSCALL(iret = ioctl(xf86Info.consoleFd, VIS_GETIDENTIFIER, &visid));
	if (iret < 0) {
	    int fbfd;

	    fbfd = open(xf86SolarisFbDev, O_RDONLY);
	    if (fbfd >= 0) {
		SYSCALL(iret = ioctl(fbfd, VIS_GETIDENTIFIER, &visid));
		close(fbfd);
	    }
	}

	if (iret < 0) {
	    xf86Msg(X_WARNING,
		    "could not get frame buffer identifier from %s\n",
		    xf86SolarisFbDev);
	} else {
	    xf86Msg(X_PROBED, "console driver: %s\n", visid.name);

	    /* Special case from before the general case was set */
	    if (strcmp(visid.name, "NVDAnvda") == 0) {
		matches[i++] = xnfstrdup("nvidia");
	    }

	    /* General case - split into vendor name (initial all-caps
	       prefix) & driver name (rest of the string). */
	    if (strcmp(visid.name, "SUNWtext") != 0) {
		for (cp = visid.name; (*cp != '\0') && isupper(*cp); cp++) {
		    /* find end of all uppercase vendor section */
		}
		if ((cp != visid.name) && (*cp != '\0')) {
		    char *driverName = xnfstrdup(cp);
		    char *vendorName = xnfstrdup(visid.name);
		    vendorName[cp - visid.name] = '\0';

		    matches[i++] = vendorName;
		    matches[i++] = driverName;
		}
	    }
	}
d255 4
a258 3
	char *sbusDriver = sparcDriverName();
	if (sbusDriver)
	    matches[i++] = xnfstrdup(sbusDriver);
d261 1
a261 1

d263 1
a263 1

d267 1
a267 1
	matches[i++] = xnfstrdup("vesa");
d269 1
a269 1
	matches[i++] = xnfstrdup("sunffb");
d273 1
d277 3
a279 3
#  if !defined(__i386__) && !defined(__amd64__)
	if (i == 0) {
	    matches[i++] = xnfstrdup("wsfb");
d281 1
a281 1
#  endif
d283 1
a283 1
	matches[i++] = xnfstrdup("wsfb");
d285 1
a285 1
	matches[i++] = xnfstrdup("fbdev");
d288 1
d332 1
a332 1
    char *matches[20]; /* If we have more than 20 drivers we're in trouble */
d343 2
a344 1
    } else {
d374 1
a374 1
                                                sizeof(screenLayoutRec));
d397 1
a397 1
                xf86ConfigLayout.screens[i+num_matches] = slp[i];
d399 2
a400 1
            xf86ConfigLayout.screens[num_screens+num_matches-1].screen = NULL;
d402 2
a403 1
        } else {
d406 1
a406 1
            for (i = 1; matches[i] ; i++) {
@


1.18
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d123 1
a123 1
	free((*list)[i]);
d291 1
d294 2
a295 2
    xf86ConfigLayout.screens[i].screen = xnfcalloc(1, sizeof(confScreenRec));
    if(!xf86ConfigLayout.screens[i].screen)
d297 1
a297 1
    memcpy(xf86ConfigLayout.screens[i].screen, oscreen, sizeof(confScreenRec));
d299 3
a301 2
    cptr = calloc(1, sizeof(GDevRec));
    if (!cptr)
d303 1
d306 6
a311 1
    cptr->identifier = Xprintf("Autoconfigured Video Device %s", driver);
d313 2
@


1.17
log
@Fix autoconfiguration for accelerated drivers on sparc/sparc64.  Currently
limited to sunffb; others will need to be added to bsd_sbus.c if we start
shipping them.

ok matthieu@@, oga@@
@
text
@d42 1
a45 1
#include "dirent.h"
d114 1
a114 1
    xfree(str);
d123 1
a123 2
	if ((*list)[i])
	    xfree((*list)[i]);
d125 1
a125 1
    xfree(*list);
a141 96
static int
videoPtrToDriverList(struct pci_device *dev,
		     char *returnList[], int returnListMax)
{
    int i;
    /* Add more entries here if we ever return more than 4 drivers for
       any device */
    char *driverList[5] = { NULL, NULL, NULL, NULL, NULL };

    switch (dev->vendor_id)
    {
	/* AMD Geode LX */
	case 0x1022:
	    if (dev->device_id == 0x2081)
		driverList[0] = "geode";
	    break;
	/* older Geode products acquired by AMD still carry an NSC vendor_id */
	case 0x100b:
	    if (dev->device_id == 0x0030) {
		/* NSC Geode GX2 specifically */
		driverList[0] = "geode";
		/* GX2 support started its life in the NSC tree and was later 
		   forked by AMD for GEODE so we keep it as a backup */
		driverList[1] = "nsc";
	    } else 
		/* other NSC variant e.g. 0x0104 (SC1400), 0x0504 (SCx200) */
		driverList[0] = "nsc";
	    break;
	/* Cyrix Geode GX1 */
	case 0x1078:
	    if (dev->device_id == 0x0104)
		driverList[0] = "cyrix";
	    break;
	case 0x1142:		    driverList[0] = "apm"; break;
	case 0xedd8:		    driverList[0] = "ark"; break;
	case 0x1a03:		    driverList[0] = "ast"; break;
	case 0x1002:		    driverList[0] = "ati"; break;
	case 0x102c:		    driverList[0] = "chips"; break;
	case 0x1013:		    driverList[0] = "cirrus"; break;
	case 0x3d3d:		    driverList[0] = "glint"; break;
	case 0x105d:		    driverList[0] = "i128"; break;
	case 0x8086:
	    if ((dev->device_id == 0x00d1) || (dev->device_id == 0x7800)) {
		driverList[0] = "i740";
            } else if (dev->device_id == 0x8108) {
                break; /* "hooray" for poulsbo */
	    } else {
		driverList[0] = "intel";
	    }
	    break;
	case 0x102b:		    driverList[0] = "mga";	break;
	case 0x10c8:		    driverList[0] = "neomagic"; break;
	case 0x10de: case 0x12d2:   driverList[0] = "nv";	break;
	case 0x1106:		    driverList[0] = "openchrome"; break;
        case 0x1b36:		    driverList[0] = "qxl"; break;
	case 0x1163:		    driverList[0] = "rendition"; break;
	case 0x5333:
	    switch (dev->device_id)
	    {
		case 0x88d0: case 0x88d1: case 0x88f0: case 0x8811:
		case 0x8812: case 0x8814: case 0x8901:
		    driverList[0] = "s3"; break;
		case 0x5631: case 0x883d: case 0x8a01: case 0x8a10:
		case 0x8c01: case 0x8c03: case 0x8904: case 0x8a13:
		    driverList[0] = "s3virge"; break;
		default:
		    driverList[0] = "savage"; break;
	    }
	    break;
	case 0x1039:		    driverList[0] = "sis";	break;
	case 0x126f:		    driverList[0] = "siliconmotion"; break;
	case 0x121a:
	    if (dev->device_id < 0x0003)
	        driverList[0] = "voodoo";
	    else
	        driverList[0] = "tdfx";
	    break;
	case 0x1011:		    driverList[0] = "tga"; break;
	case 0x1023:		    driverList[0] = "trident"; break;
	case 0x100c:		    driverList[0] = "tseng"; break;
	case 0x80ee:		    driverList[0] = "vboxvideo"; break;
	case 0x15ad:		    driverList[0] = "vmware"; break;
	case 0x18ca:
	    if (dev->device_id == 0x47)
		driverList[0] = "xgixp";
	    else
		driverList[0] = "xgi";
	    break;
	default: break;
    }
    for (i = 0; (i < returnListMax) && (driverList[i] != NULL); i++) {
	returnList[i] = xnfstrdup(driverList[i]);
    }
    return i;	/* Number of entries added */
}

d168 1
a168 1
	xfree(*p);
d188 1
a188 1
    return (ret == CONFIG_OK);
a190 121
static int
xchomp(char *line)
{
    size_t len = 0;

    if (!line) {
        return 1;
    }

    len = strlen(line);
    if (line[len - 1] == '\n' && len > 0) {
        line[len - 1] = '\0';
    }
    return 0;
}

#ifdef __linux__
/* This function is used to provide a workaround for binary drivers that
 * don't export their PCI ID's properly. If distros don't end up using this
 * feature it can and should be removed because the symbol-based resolution
 * scheme should be the primary one */
static void
matchDriverFromFiles (char** matches, uint16_t match_vendor, uint16_t match_chip)
{
    DIR *idsdir;
    FILE *fp;
    struct dirent *direntry;
    char *line = NULL;
    size_t len;
    ssize_t read;
    char path_name[256], vendor_str[5], chip_str[5];
    uint16_t vendor, chip;
    int i, j;

    idsdir = opendir(PCI_TXT_IDS_PATH);
    if (!idsdir)
        return;

    xf86Msg(X_INFO, "Scanning %s directory for additional PCI ID's supported by the drivers\n", PCI_TXT_IDS_PATH);
    direntry = readdir(idsdir);
    /* Read the directory */
    while (direntry) {
        if (direntry->d_name[0] == '.') {
            direntry = readdir(idsdir);
            continue;
        }
        len = strlen(direntry->d_name);
        /* A tiny bit of sanity checking. We should probably do better */
        if (strncmp(&(direntry->d_name[len-4]), ".ids", 4) == 0) {
            /* We need the full path name to open the file */
            strncpy(path_name, PCI_TXT_IDS_PATH, 256);
            strncat(path_name, "/", 1);
            strncat(path_name, direntry->d_name, (256 - strlen(path_name) - 1));
            fp = fopen(path_name, "r");
            if (fp == NULL) {
                xf86Msg(X_ERROR, "Could not open %s for reading. Exiting.\n", path_name);
                goto end;
            }
            /* Read the file */
#ifdef __GLIBC__
            while ((read = getline(&line, &len, fp)) != -1) {
#else
            while ((line = fgetln(fp, &len)) != (char *)NULL) {
#endif /* __GLIBC __ */
                xchomp(line);
                if (isdigit(line[0])) {
                    strncpy(vendor_str, line, 4);
                    vendor_str[4] = '\0';
                    vendor = (int)strtol(vendor_str, NULL, 16);
                    if ((strlen(&line[4])) == 0) {
                        chip_str[0] = '\0';
                        chip = -1;
                    } else {
                        /* Handle trailing whitespace */
                        if (isspace(line[4])) {
                            chip_str[0] = '\0';
                            chip = -1;
                        } else {
                            /* Ok, it's a real ID */
                            strncpy(chip_str, &line[4], 4);
                            chip_str[4] = '\0';
                            chip = (int)strtol(chip_str, NULL, 16);
                        }
                    }
                    if (vendor == match_vendor && chip == match_chip ) {
                        i = 0;
                        while (matches[i]) {
                            i++;
                        }
                        matches[i] = (char*)xalloc(sizeof(char) * strlen(direntry->d_name) -  3);
                        if (!matches[i]) {
                            xf86Msg(X_ERROR, "Could not allocate space for the module name. Exiting.\n");
                            goto end;
                        }
                        /* hack off the .ids suffix. This should guard
                         * against other problems, but it will end up
                         * taking off anything after the first '.' */
                        for (j = 0; j < (strlen(direntry->d_name) - 3) ; j++) {
                            if (direntry->d_name[j] == '.') {
                                matches[i][j] = '\0';
                                break;
                            } else {
                                matches[i][j] = direntry->d_name[j];
                            }
                        }
                        xf86Msg(X_INFO, "Matched %s from file name %s\n", matches[i], direntry->d_name);
                    }
                } else {
                    /* TODO Handle driver overrides here */
                }
            }
            fclose(fp);
        }
        direntry = readdir(idsdir);
    }
 end:
    xfree(line);
    closedir(idsdir);
}
#endif /* __linux__ */

a193 2
    struct pci_device * info = NULL;
    struct pci_device_iterator *iter;
d259 1
a259 26
    /* Find the primary device, and get some information about it. */
    iter = pci_slot_match_iterator_create(NULL);
    while ((info = pci_device_next(iter)) != NULL) {
	if (xf86IsPrimaryPci(info)) {
	    break;
	}
    }

    pci_iterator_destroy(iter);

    if (!info) {
	ErrorF("Primary device is not PCI\n");
    }
#ifdef __linux__
    else {
	matchDriverFromFiles(matches, info->vendor_id, info->device_id);
    }
#endif /* __linux__ */

    for (i = 0; (i < nmatches) && (matches[i]); i++) {
	/* find end of matches list */
    }

    if ((info != NULL) && (i < nmatches)) {
	i += videoPtrToDriverList(info, &(matches[i]), nmatches - i);
    }
d298 1
a298 1
    cptr = xcalloc(1, sizeof(GDevRec));
d329 1
a329 1
        ptr = xcalloc(1, sizeof(GDevRec));
d384 1
a384 1
            xfree(slp);
d390 1
a390 1
                    xfree(matches[i]);
@


1.16
log
@Fix autoconfiguration on sparc and sparc64.

The code to add sunffb unconditionally on !solaris for __sparc__
systems is incorrect for openbsd. More specifically, due to interactions
between hardware drivers and wsfb in preinit we can't unconditionally
add wsfb to the list of fallbacks, so we only add wsfb if no other
option was found. Additionally sunffb does not need to be
unconditionally added because the bus probing code will find these
devices already.

So, long story short:  make that code chunk conditional on __sparc__ &&
defined(__linux__) instead.

change from !openbsd to __linux__ requested by kettenis@@.

Tested by at least myself and stsp@@.

ok matthieu@@, kettenis@@.
@
text
@d471 1
a471 1
#if defined(__sparc__) && !defined(__OpenBSD__)
@


1.15
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d510 1
a510 1
#elif defined(__sparc__) && !defined(sun)
@


1.14
log
@Only add wsfb to the list of autoconfigured drivers if no other matches were
found.  Makes xorg.conf-less X work again on sparc64 and macppc systems with
a single display adapter.

ok matthieu@@, beck@@
@
text
@d42 1
a42 1
#ifdef __sparc__
a146 5
    /*
     * things not handled yet:
     * cyrix/nsc.  should be merged into geode anyway.
     * xgi.
     */
d154 1
d156 1
a156 1
	    if (dev->device_id == 0x2081) {
d158 17
a174 2
		driverList[1] = "amd";
	    }
d182 2
d187 2
a188 2
            } else if (dev->device_id == 0x8108) { 
                break; /* "hooray" for poulsbo */ 
a194 1
	case 0x105d:		    driverList[0] = "i128";	break;
d196 2
d220 1
a220 1
	case 0x3d3d:		    driverList[0] = "glint";	break;
d222 3
a224 3
	case 0x100c:		    driverList[0] = "tseng";	break;
	case 0x1106:		    driverList[0] = "openchrome"; break;
	case 0x15ad:		    driverList[0] = "vmware";	break;
d276 2
a277 1
    
d288 1
a288 1
int 
a303 40
GDevPtr
autoConfigDevice(GDevPtr preconf_device)
{
    GDevPtr ptr = NULL;

    if (!xf86configptr) {
        return NULL;
    }

    /* If there's a configured section with no driver chosen, use it */
    if (preconf_device) {
        ptr = preconf_device;
    } else {
        ptr = xcalloc(1, sizeof(GDevRec));
        if (!ptr) {
            return NULL;
        }
        ptr->chipID = -1;
        ptr->chipRev = -1;
        ptr->irq = -1;

        ptr->active = TRUE;
        ptr->claimed = FALSE;
        ptr->identifier = "Autoconfigured Video Device";
        ptr->driver = NULL;
    }
    if (!ptr->driver) {
        ptr->driver = chooseVideoDriver();
    }

    /* TODO Handle multiple screen sections */
    if (xf86ConfigLayout.screens && !xf86ConfigLayout.screens->screen->device) {   
        xf86ConfigLayout.screens->screen->device = ptr;
        ptr->myScreenSection = xf86ConfigLayout.screens->screen;
    }
    xf86Msg(X_DEFAULT, "Assigned the driver to the xf86ConfigLayout\n");

    return ptr;
}

d427 13
d441 5
a445 1
	if (ioctl(xf86Info.consoleFd, VIS_GETIDENTIFIER, &visid) >= 0) {
d471 1
a471 1
#ifdef __sparc__
d510 1
a510 1
#elif defined(__sparc__) && defined(__linux__)
d531 29
a559 2
char*
chooseVideoDriver(void)
d561 1
a561 2
    char *chosen_driver = NULL;
    int i;
d563 18
d582 12
a593 1
    listPossibleVideoDrivers(matches, 20);
d595 17
a611 2
    /* TODO Handle multiple drivers claiming to support the same PCI ID */
    chosen_driver = matches[0];
d613 7
a619 2
    xf86Msg(X_DEFAULT, "Matched %s for the autoconfigured driver\n",
	    chosen_driver);
d621 17
a637 3
    for (i = 0; matches[i] ; i++) {
        if (matches[i] != chosen_driver) {
            xfree(matches[i]);
d641 3
a643 1
    return chosen_driver;
@


1.13
log
@Replace fbdev by wsfb as fallback driver on arches that support it.
Ok todd@@, oga@@.
@
text
@d527 3
a529 1
	matches[i++] = xnfstrdup("wsfb");
@


1.12
log
@Merge intel driver autoconfiguration changes from upstream:
- don't list the dead i810 driver anymore
- blacklist the poulsbo chipset which isn't supported by
xf86-video-intel. Gives vesa a chance. ok oga@@, kettenis@@.
@
text
@d525 5
a529 1
#if !defined(__linux__) && defined(__sparc__)
@


1.11
log
@Don't unconditionnally add a "sunffb" device in autoconfig mode
on OpenBSD. It will be added by sparcDriverName() if a ffb card
is present.
@
text
@d174 2
a177 1
		driverList[1] = "i810";
@


1.10
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d517 1
a517 1
#elif defined(__sparc__) && !defined(sun)
@


1.9
log
@Add code to choose a video driver based on the wscons(4) display type.  Makes
it possible to run X without a configuration file on (some) sparc64 machines
and perhaps other machines that use wscons(4) frame buffers.

ok matthieu@@
@
text
@d42 3
d47 5
d90 2
a91 5
static const char *deviceList[] = {
	"fbdev",
	"vesa",
	NULL
};
d143 3
a145 2
static const char *
videoPtrToDriverName(struct pci_device *dev)
d152 4
d160 11
a170 10
		if (dev->device_id == 0x2081)
			return "geode";
		else
			return NULL;
	case 0x1142:		    return "apm";
	case 0xedd8:		    return "ark";
	case 0x1a03:		    return "ast";
	case 0x1002:		    return "ati";
	case 0x102c:		    return "chips";
	case 0x1013:		    return "cirrus";
d172 12
a183 8
	    if ((dev->device_id == 0x00d1) || (dev->device_id == 0x7800))
		return "i740";
	    else return "intel";
	case 0x102b:		    return "mga";
	case 0x10c8:		    return "neomagic";
	case 0x105d:		    return "i128";
	case 0x10de: case 0x12d2:   return "nv";
	case 0x1163:		    return "rendition";
d189 1
a189 1
		    return "s3";
d192 1
a192 1
		    return "s3virge";
d194 1
a194 1
		    return "savage";
d196 3
a198 2
	case 0x1039:		    return "sis";
	case 0x126f:		    return "siliconmotion";
d201 12
a212 1
	        return "voodoo";
d214 2
a215 6
	        return "tdfx";
	case 0x3d3d:		    return "glint";
	case 0x1023:		    return "trident";
	case 0x100c:		    return "tseng";
	case 0x1106:		    return "openchrome";
	case 0x15ad:		    return "vmware";
d218 4
a221 1
    return NULL;
d227 3
a229 1
    const char **p;
a230 1
    const char *driver = NULL;
d233 1
a233 13
    driver = chooseVideoDriver();

    if (driver) {
	snprintf(buf, sizeof(buf), BUILTIN_DEVICE_SECTION_PRE,
		 driver, 0, driver);
	AppendToConfig(buf);
	ErrorF("New driver is \"%s\"\n", driver);
	buf[0] = '\t';
	AppendToConfig(BUILTIN_DEVICE_SECTION_POST);
	snprintf(buf, sizeof(buf), BUILTIN_SCREEN_SECTION,
		 driver, 0, driver, 0);
	AppendToConfig(buf);
    }
a242 4
    if (driver) {
	snprintf(buf, sizeof(buf), BUILTIN_LAYOUT_SCREEN_LINE, driver, 0);
	AppendToConfig(buf);
    }
d249 4
d258 2
a259 2
    for (p = builtinConfig; *p; p++)
	xf86ErrorFVerb(3, "\t%s", *p);
d301 1
a301 1
        ptr = (GDevPtr)xalloc(sizeof(GDevRec));
a304 1
        memset((GDevPtr)ptr, 0, sizeof(GDevRec));
d433 2
a434 2
char*
chooseVideoDriver(void)
a437 1
    char *chosen_driver = NULL;
a438 1
    char *matches[20]; /* If we have more than 20 drivers we're in trouble */
d440 1
a440 1
    for (i=0 ; i<20 ; i++)
d442 43
d505 14
a518 20
    /* TODO Handle multiple drivers claiming to support the same PCI ID */
    if (matches[0]) {
        chosen_driver = matches[0];
    } else {
	if (info != NULL)
	    chosen_driver = videoPtrToDriverName(info);
#ifdef __OpenBSD__
	if (chosen_driver == NULL) {
	    int fd = xf86Info.screenFd;
	    int type;

	    if (ioctl(fd, WSDISPLAYIO_GTYPE, &type) != -1) {
		switch (type) {
		    case WSDISPLAY_TYPE_SUNFFB:
			chosen_driver = "sunffb";
			break;
#ifdef notyet
		    case WSDISPLAY_TYPE_SUNCG6:
			chosen_driver = "suncg6";
			break;
d520 6
a525 7
		    case WSDISPLAY_TYPE_IFB:
			chosen_driver = "wildcatfb";
			break;

		    default:
#if defined(__i386__) || defined(__amd64__)
			chosen_driver = "vesa";
d527 1
a527 1
			chosen_driver = "wsfb";
a528 14
			break;
		}
	    }
	}
#endif
	if (chosen_driver == NULL) {
#if defined  __i386__ || defined __amd64__ || defined __x86_64__ || defined __hurd__
	    chosen_driver = "vesa";
#elif defined __sparc__
	    chosen_driver = "sunffb";
#else
	    chosen_driver = "fbdev";
#endif
	}
d530 1
d532 8
a539 1
    xf86Msg(X_DEFAULT, "Matched %s for the autoconfigured driver\n", chosen_driver);
d541 7
a547 2
    i = 0;
    while (matches[i]) {
a550 1
        i++;
@


1.8
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d456 30
@


1.7
log
@The amd driver has been renamed geode. ok deraadt@@ oga@@.
@
text
@d42 1
a45 11
#define BUILTIN_MODULE_SECTION \
	"Section \"Module\"\n" \
	"\tLoad\t\"extmod\"\n" \
	"\tLoad\t\"dbe\"\n" \
	"\tLoad\t\"glx\"\n" \
	"\tLoad\t\"freetype\"\n" \
	"\tLoad\t\"type1\"\n" \
	"\tLoad\t\"record\"\n" \
	"\tLoad\t\"dri\"\n" \
	"EndSection\n\n"

a60 8
#define BUILTIN_MONITOR_NAME \
	"\"Builtin Default Monitor\""

#define BUILTIN_MONITOR_SECTION \
	"Section \"Monitor\"\n" \
	"\tIdentifier\t" BUILTIN_MONITOR_NAME "\n" \
	"EndSection\n\n"

a67 1
	"\tMonitor\t" BUILTIN_MONITOR_NAME "\n" \
a84 1
	"vga",
d139 1
a139 1
videoPtrToDriverName(pciVideoPtr info)
d147 1
a147 1
    switch (info->vendor)
d150 1
a150 1
		if (info->chipType == 0x2081)
d161 3
a163 11
	    switch (info->chipType)
	    {
		case 0x00d1: case 0x7800:
		    return "i740";
		case 0x1132: case 0x2562: case 0x2572: case 0x3577:
		case 0x3582: case 0x358e: case 0x7121: case 0x7123:
		case 0x7125:
		    return "i810";
		default:
		    return "intel";
	    }
d170 1
a170 1
	    switch (info->chipType)
d184 1
a184 1
	    if (info->chipType < 0x0003)
d203 1
a203 2
    pciVideoPtr *pciptr, info = NULL;
    char *driver = NULL;
d206 1
a206 19
    /* Find the primary device, and get some information about it. */
    if (xf86PciVideoInfo) {
	for (pciptr = xf86PciVideoInfo; (info = *pciptr); pciptr++) {
	    if (xf86IsPrimaryPci(info)) {
		break;
	    }
	}
	if (!info) {
	    ErrorF("Primary device is not PCI\n");
	}
    } else {
	ErrorF("xf86PciVideoInfo is not set\n");
    }

    if (info)
	driver = videoPtrToDriverName(info);

    AppendToConfig(BUILTIN_MODULE_SECTION);
    AppendToConfig(BUILTIN_MONITOR_SECTION);
d255 223
@


1.6
log
@use the openchrome driver for via chipsets.
@
text
@d171 1
a171 1
			return "amd";
@


1.5
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d219 1
a219 1
	case 0x1106:		    return "via";
@


1.4
log
@Based on a suggestion and an initial patch by kettenis@@, build
both the old i810 and the new intel drivers on i386, and let X
autoconfiguration code choose the one that is used based on the chipset.
Tested by landry@@ and a few others.
@
text
@d163 2
a164 2
     * amd/cyrix/nsc
     * xgi
d169 5
@


1.3
log
@Don't fall back to wsfb on autoconfig
@
text
@d176 11
a186 3
	    if ((info->chipType == 0x00d1) || (info->chipType == 0x7800))
		return "i740";
	    else return "i810";
@


1.2
log
@- merge xserver 1.1.99.903
- regen generated files
@
text
@a101 3
#ifdef __OpenBSD__
	"wsfb",
#endif
@


1.1
log
@Initial revision
@
text
@d102 3
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
