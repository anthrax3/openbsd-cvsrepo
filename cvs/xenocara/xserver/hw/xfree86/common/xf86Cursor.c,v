head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.03;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright (c) 1994-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include <X11/Xmd.h>
#include "input.h"
#include "cursor.h"
#include "mipointer.h"
#include "scrnintstr.h"
#include "globals.h"

#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSproc.h"

#include <X11/extensions/XIproto.h>
#include "xf86Xinput.h"

#ifdef XFreeXDGA
#include "dgaproc.h"
#endif

typedef struct _xf86EdgeRec {
    short screen;
    short start;
    short end;
    DDXPointRec offset;
    struct _xf86EdgeRec *next;
} xf86EdgeRec, *xf86EdgePtr;

typedef struct {
    xf86EdgePtr left, right, up, down;
} xf86ScreenLayoutRec, *xf86ScreenLayoutPtr;

static Bool xf86CursorOffScreen(ScreenPtr *pScreen, int *x, int *y);
static void xf86CrossScreen(ScreenPtr pScreen, Bool entering);
static void xf86WarpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y);

static void xf86PointerMoved(ScrnInfoPtr pScrn, int x, int y);

static miPointerScreenFuncRec xf86PointerScreenFuncs = {
    xf86CursorOffScreen,
    xf86CrossScreen,
    xf86WarpCursor,
};

static xf86ScreenLayoutRec xf86ScreenLayout[MAXSCREENS];

/*
 * xf86InitViewport --
 *      Initialize paning & zooming parameters, so that a driver must only
 *      check what resolutions are possible and whether the virtual area
 *      is valid if specified.
 */

void
xf86InitViewport(ScrnInfoPtr pScr)
{

    pScr->PointerMoved = xf86PointerMoved;

    /*
     * Compute the initial Viewport if necessary
     */
    if (pScr->display) {
        if (pScr->display->frameX0 < 0) {
            pScr->frameX0 = (pScr->virtualX - pScr->modes->HDisplay) / 2;
            pScr->frameY0 = (pScr->virtualY - pScr->modes->VDisplay) / 2;
        }
        else {
            pScr->frameX0 = pScr->display->frameX0;
            pScr->frameY0 = pScr->display->frameY0;
        }
    }

    pScr->frameX1 = pScr->frameX0 + pScr->modes->HDisplay - 1;
    pScr->frameY1 = pScr->frameY0 + pScr->modes->VDisplay - 1;

    /*
     * Now adjust the initial Viewport, so it lies within the virtual area
     */
    if (pScr->frameX1 >= pScr->virtualX) {
        pScr->frameX0 = pScr->virtualX - pScr->modes->HDisplay;
        pScr->frameX1 = pScr->frameX0 + pScr->modes->HDisplay - 1;
    }

    if (pScr->frameY1 >= pScr->virtualY) {
        pScr->frameY0 = pScr->virtualY - pScr->modes->VDisplay;
        pScr->frameY1 = pScr->frameY0 + pScr->modes->VDisplay - 1;
    }
}

/*
 * xf86SetViewport --
 *      Scroll the visual part of the screen so the pointer is visible.
 */

void
xf86SetViewport(ScreenPtr pScreen, int x, int y)
{
    ScrnInfoPtr pScr = xf86ScreenToScrn(pScreen);

    (*pScr->PointerMoved) (pScr, x, y);
}

static void
xf86PointerMoved(ScrnInfoPtr pScr, int x, int y)
{
    Bool frameChanged = FALSE;

    /*
     * check wether (x,y) belongs to the visual part of the screen
     * if not, change the base of the displayed frame accoring
     */
    if (pScr->frameX0 > x) {
        pScr->frameX0 = x;
        pScr->frameX1 = x + pScr->currentMode->HDisplay - 1;
        frameChanged = TRUE;
    }

    if (pScr->frameX1 < x) {
        pScr->frameX1 = x + 1;
        pScr->frameX0 = x - pScr->currentMode->HDisplay + 1;
        frameChanged = TRUE;
    }

    if (pScr->frameY0 > y) {
        pScr->frameY0 = y;
        pScr->frameY1 = y + pScr->currentMode->VDisplay - 1;
        frameChanged = TRUE;
    }

    if (pScr->frameY1 < y) {
        pScr->frameY1 = y;
        pScr->frameY0 = y - pScr->currentMode->VDisplay + 1;
        frameChanged = TRUE;
    }

    if (frameChanged && pScr->AdjustFrame != NULL)
        pScr->AdjustFrame(pScr, pScr->frameX0, pScr->frameY0);
}

/*
 * xf86LockZoom --
 *	Enable/disable ZoomViewport
 */

void
xf86LockZoom(ScreenPtr pScreen, Bool lock)
{
    ScrnInfoPtr pScr = xf86ScreenToScrn(pScreen);
    pScr->zoomLocked = lock;
}

/*
 * xf86SwitchMode --
 *	This is called by both keyboard processing and the VidMode extension to
 *	set a new mode.
 */

Bool
xf86SwitchMode(ScreenPtr pScreen, DisplayModePtr mode)
{
    ScrnInfoPtr pScr = xf86ScreenToScrn(pScreen);
    ScreenPtr pCursorScreen;
    Bool Switched;
    int px, py;
    DeviceIntPtr dev, it;

    if (!pScr->vtSema || !mode || !pScr->SwitchMode)
        return FALSE;

#ifdef XFreeXDGA
    if (DGAActive(pScr->scrnIndex))
        return FALSE;
#endif

    if (mode == pScr->currentMode)
        return TRUE;

    if (mode->HDisplay > pScr->virtualX || mode->VDisplay > pScr->virtualY)
        return FALSE;

    /* Let's take an educated guess for which pointer to take here. And about as
       educated as it gets is to take the first pointer we find.
     */
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (IsPointerDevice(dev) && dev->spriteInfo->spriteOwner)
            break;
    }

    pCursorScreen = miPointerGetScreen(dev);
    if (pScreen == pCursorScreen)
        miPointerGetPosition(dev, &px, &py);

    OsBlockSIGIO();
    Switched = (*pScr->SwitchMode) (pScr, mode);
    if (Switched) {
        pScr->currentMode = mode;

        /*
         * Adjust frame for new display size.
         * Frame is centered around cursor position if cursor is on same screen.
         */
        if (pScreen == pCursorScreen)
            pScr->frameX0 = px - (mode->HDisplay / 2) + 1;
        else
            pScr->frameX0 =
                (pScr->frameX0 + pScr->frameX1 + 1 - mode->HDisplay) / 2;

        if (pScr->frameX0 < 0)
            pScr->frameX0 = 0;

        pScr->frameX1 = pScr->frameX0 + mode->HDisplay - 1;
        if (pScr->frameX1 >= pScr->virtualX) {
            pScr->frameX0 = pScr->virtualX - mode->HDisplay;
            pScr->frameX1 = pScr->virtualX - 1;
        }

        if (pScreen == pCursorScreen)
            pScr->frameY0 = py - (mode->VDisplay / 2) + 1;
        else
            pScr->frameY0 =
                (pScr->frameY0 + pScr->frameY1 + 1 - mode->VDisplay) / 2;

        if (pScr->frameY0 < 0)
            pScr->frameY0 = 0;

        pScr->frameY1 = pScr->frameY0 + mode->VDisplay - 1;
        if (pScr->frameY1 >= pScr->virtualY) {
            pScr->frameY0 = pScr->virtualY - mode->VDisplay;
            pScr->frameY1 = pScr->virtualY - 1;
        }
    }
    OsReleaseSIGIO();

    if (pScr->AdjustFrame)
        (*pScr->AdjustFrame) (pScr, pScr->frameX0, pScr->frameY0);

    /* The original code centered the frame around the cursor if possible.
     * Since this is hard to achieve with multiple cursors, we do the following:
     *   - center around the first pointer
     *   - move all other pointers to the nearest edge on the screen (or leave
     *   them unmodified if they are within the boundaries).
     */
    if (pScreen == pCursorScreen) {
        xf86WarpCursor(dev, pScreen, px, py);
    }

    for (it = inputInfo.devices; it; it = it->next) {
        if (it == dev)
            continue;

        if (IsPointerDevice(it) && it->spriteInfo->spriteOwner) {
            pCursorScreen = miPointerGetScreen(it);
            if (pScreen == pCursorScreen) {
                miPointerGetPosition(it, &px, &py);
                if (px < pScr->frameX0)
                    px = pScr->frameX0;
                else if (px > pScr->frameX1)
                    px = pScr->frameX1;

                if (py < pScr->frameY0)
                    py = pScr->frameY0;
                else if (py > pScr->frameY1)
                    py = pScr->frameY1;

                xf86WarpCursor(it, pScreen, px, py);
            }
        }
    }

    return Switched;
}

/*
 * xf86ZoomViewport --
 *      Reinitialize the visual part of the screen for another mode.
 */

void
xf86ZoomViewport(ScreenPtr pScreen, int zoom)
{
    ScrnInfoPtr pScr = xf86ScreenToScrn(pScreen);
    DisplayModePtr mode;

    if (pScr->zoomLocked || !(mode = pScr->currentMode))
        return;

    do {
        if (zoom > 0)
            mode = mode->next;
        else
            mode = mode->prev;
    } while (mode != pScr->currentMode && !(mode->type & M_T_USERDEF));

    (void) xf86SwitchMode(pScreen, mode);
}

static xf86EdgePtr
FindEdge(xf86EdgePtr edge, int val)
{
    while (edge && (edge->end <= val))
        edge = edge->next;

    if (edge && (edge->start <= val))
        return edge;

    return NULL;
}

/*
 * xf86CursorOffScreen --
 *      Check whether it is necessary to switch to another screen
 */

static Bool
xf86CursorOffScreen(ScreenPtr *pScreen, int *x, int *y)
{
    xf86EdgePtr edge;
    int tmp;

    if (screenInfo.numScreens == 1)
        return FALSE;

    if (*x < 0) {
        tmp = *y;
        if (tmp < 0)
            tmp = 0;
        if (tmp >= (*pScreen)->height)
            tmp = (*pScreen)->height - 1;

        if ((edge = xf86ScreenLayout[(*pScreen)->myNum].left))
            edge = FindEdge(edge, tmp);

        if (!edge)
            *x = 0;
        else {
            *x += edge->offset.x;
            *y += edge->offset.y;
            *pScreen = xf86Screens[edge->screen]->pScreen;
        }
    }

    if (*x >= (*pScreen)->width) {
        tmp = *y;
        if (tmp < 0)
            tmp = 0;
        if (tmp >= (*pScreen)->height)
            tmp = (*pScreen)->height - 1;

        if ((edge = xf86ScreenLayout[(*pScreen)->myNum].right))
            edge = FindEdge(edge, tmp);

        if (!edge)
            *x = (*pScreen)->width - 1;
        else {
            *x += edge->offset.x;
            *y += edge->offset.y;
            *pScreen = xf86Screens[edge->screen]->pScreen;
        }
    }

    if (*y < 0) {
        tmp = *x;
        if (tmp < 0)
            tmp = 0;
        if (tmp >= (*pScreen)->width)
            tmp = (*pScreen)->width - 1;

        if ((edge = xf86ScreenLayout[(*pScreen)->myNum].up))
            edge = FindEdge(edge, tmp);

        if (!edge)
            *y = 0;
        else {
            *x += edge->offset.x;
            *y += edge->offset.y;
            *pScreen = xf86Screens[edge->screen]->pScreen;
        }
    }

    if (*y >= (*pScreen)->height) {
        tmp = *x;
        if (tmp < 0)
            tmp = 0;
        if (tmp >= (*pScreen)->width)
            tmp = (*pScreen)->width - 1;

        if ((edge = xf86ScreenLayout[(*pScreen)->myNum].down))
            edge = FindEdge(edge, tmp);

        if (!edge)
            *y = (*pScreen)->height - 1;
        else {
            *x += edge->offset.x;
            *y += edge->offset.y;
            (*pScreen) = xf86Screens[edge->screen]->pScreen;
        }
    }

    return TRUE;
}

/*
 * xf86CrossScreen --
 *      Switch to another screen
 *
 *	Currently nothing special happens, but mi assumes the CrossScreen
 *	method exists.
 */

static void
xf86CrossScreen(ScreenPtr pScreen, Bool entering)
{
}

/*
 * xf86WarpCursor --
 *      Warp possible to another screen
 */

/* ARGSUSED */
static void
xf86WarpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
    OsBlockSIGIO();
    miPointerWarpCursor(pDev, pScreen, x, y);

    xf86Info.currentScreen = pScreen;
    OsReleaseSIGIO();
}

void *
xf86GetPointerScreenFuncs(void)
{
    return (void *) &xf86PointerScreenFuncs;
}

static xf86EdgePtr
AddEdge(xf86EdgePtr edge,
        short min, short max, short dx, short dy, short screen)
{
    xf86EdgePtr pEdge = edge, pPrev = NULL, pNew;

    while (1) {
        while (pEdge && (min >= pEdge->end)) {
            pPrev = pEdge;
            pEdge = pEdge->next;
        }

        if (!pEdge) {
            if (!(pNew = malloc(sizeof(xf86EdgeRec))))
                break;

            pNew->screen = screen;
            pNew->start = min;
            pNew->end = max;
            pNew->offset.x = dx;
            pNew->offset.y = dy;
            pNew->next = NULL;

            if (pPrev)
                pPrev->next = pNew;
            else
                edge = pNew;

            break;
        }
        else if (min < pEdge->start) {
            if (!(pNew = malloc(sizeof(xf86EdgeRec))))
                break;

            pNew->screen = screen;
            pNew->start = min;
            pNew->offset.x = dx;
            pNew->offset.y = dy;
            pNew->next = pEdge;

            if (pPrev)
                pPrev->next = pNew;
            else
                edge = pNew;

            if (max <= pEdge->start) {
                pNew->end = max;
                break;
            }
            else {
                pNew->end = pEdge->start;
                min = pEdge->end;
            }
        }
        else
            min = pEdge->end;

        pPrev = pEdge;
        pEdge = pEdge->next;

        if (max <= min)
            break;
    }

    return edge;
}

static void
FillOutEdge(xf86EdgePtr pEdge, int limit)
{
    xf86EdgePtr pNext;
    int diff;

    if (pEdge->start > 0)
        pEdge->start = 0;

    while ((pNext = pEdge->next)) {
        diff = pNext->start - pEdge->end;
        if (diff > 0) {
            pEdge->end += diff >> 1;
            pNext->start -= diff - (diff >> 1);
        }
        pEdge = pNext;
    }

    if (pEdge->end < limit)
        pEdge->end = limit;
}

/*
 * xf86InitOrigins() can deal with a maximum of 32 screens
 * on 32 bit architectures, 64 on 64 bit architectures.
 */

void
xf86InitOrigins(void)
{
    unsigned long screensLeft, prevScreensLeft, mask;
    screenLayoutPtr screen;
    ScreenPtr pScreen, refScreen;
    int x1, x2, y1, y2, left, right, top, bottom;
    int i, j, ref, minX, minY, min, max;
    xf86ScreenLayoutPtr pLayout;
    Bool OldStyleConfig = FALSE;

    memset(xf86ScreenLayout, 0, MAXSCREENS * sizeof(xf86ScreenLayoutRec));

    screensLeft = prevScreensLeft = (1 << xf86NumScreens) - 1;

    while (1) {
        for (mask = screensLeft, i = 0; mask; mask >>= 1, i++) {
            if (!(mask & 1L))
                continue;

            screen = &xf86ConfigLayout.screens[i];

            if (screen->refscreen != NULL &&
                screen->refscreen->screennum >= xf86NumScreens) {
                screensLeft &= ~(1 << i);
                xf86Msg(X_WARNING,
                        "Not including screen \"%s\" in origins calculation.\n",
                        screen->screen->id);
                continue;
            }

            pScreen = xf86Screens[i]->pScreen;
            switch (screen->where) {
            case PosObsolete:
                OldStyleConfig = TRUE;
                pLayout = &xf86ScreenLayout[i];
                /* force edge lists */
                if (screen->left) {
                    ref = screen->left->screennum;
                    if (!xf86Screens[ref] || !xf86Screens[ref]->pScreen) {
                        ErrorF("Referenced uninitialized screen in Layout!\n");
                        break;
                    }
                    pLayout->left = AddEdge(pLayout->left,
                                            0, pScreen->height,
                                            xf86Screens[ref]->pScreen->width, 0,
                                            ref);
                }
                if (screen->right) {
                    ref = screen->right->screennum;
                    if (!xf86Screens[ref] || !xf86Screens[ref]->pScreen) {
                        ErrorF("Referenced uninitialized screen in Layout!\n");
                        break;
                    }
                    pLayout->right = AddEdge(pLayout->right,
                                             0, pScreen->height,
                                             -pScreen->width, 0, ref);
                }
                if (screen->top) {
                    ref = screen->top->screennum;
                    if (!xf86Screens[ref] || !xf86Screens[ref]->pScreen) {
                        ErrorF("Referenced uninitialized screen in Layout!\n");
                        break;
                    }
                    pLayout->up = AddEdge(pLayout->up,
                                          0, pScreen->width,
                                          0, xf86Screens[ref]->pScreen->height,
                                          ref);
                }
                if (screen->bottom) {
                    ref = screen->bottom->screennum;
                    if (!xf86Screens[ref] || !xf86Screens[ref]->pScreen) {
                        ErrorF("Referenced uninitialized screen in Layout!\n");
                        break;
                    }
                    pLayout->down = AddEdge(pLayout->down,
                                            0, pScreen->width, 0,
                                            -pScreen->height, ref);
                }
                /* we could also try to place it based on those
                   relative locations if we wanted to */
                screen->x = screen->y = 0;
                /* FALLTHROUGH */
            case PosAbsolute:
                pScreen->x = screen->x;
                pScreen->y = screen->y;
                screensLeft &= ~(1 << i);
                break;
            case PosRelative:
                ref = screen->refscreen->screennum;
                if (!xf86Screens[ref] || !xf86Screens[ref]->pScreen) {
                    ErrorF("Referenced uninitialized screen in Layout!\n");
                    break;
                }
                if (screensLeft & (1 << ref))
                    break;
                refScreen = xf86Screens[ref]->pScreen;
                pScreen->x = refScreen->x + screen->x;
                pScreen->y = refScreen->y + screen->y;
                screensLeft &= ~(1 << i);
                break;
            case PosRightOf:
                ref = screen->refscreen->screennum;
                if (!xf86Screens[ref] || !xf86Screens[ref]->pScreen) {
                    ErrorF("Referenced uninitialized screen in Layout!\n");
                    break;
                }
                if (screensLeft & (1 << ref))
                    break;
                refScreen = xf86Screens[ref]->pScreen;
                pScreen->x = refScreen->x + refScreen->width;
                pScreen->y = refScreen->y;
                screensLeft &= ~(1 << i);
                break;
            case PosLeftOf:
                ref = screen->refscreen->screennum;
                if (!xf86Screens[ref] || !xf86Screens[ref]->pScreen) {
                    ErrorF("Referenced uninitialized screen in Layout!\n");
                    break;
                }
                if (screensLeft & (1 << ref))
                    break;
                refScreen = xf86Screens[ref]->pScreen;
                pScreen->x = refScreen->x - pScreen->width;
                pScreen->y = refScreen->y;
                screensLeft &= ~(1 << i);
                break;
            case PosBelow:
                ref = screen->refscreen->screennum;
                if (!xf86Screens[ref] || !xf86Screens[ref]->pScreen) {
                    ErrorF("Referenced uninitialized screen in Layout!\n");
                    break;
                }
                if (screensLeft & (1 << ref))
                    break;
                refScreen = xf86Screens[ref]->pScreen;
                pScreen->x = refScreen->x;
                pScreen->y = refScreen->y + refScreen->height;
                screensLeft &= ~(1 << i);
                break;
            case PosAbove:
                ref = screen->refscreen->screennum;
                if (!xf86Screens[ref] || !xf86Screens[ref]->pScreen) {
                    ErrorF("Referenced uninitialized screen in Layout!\n");
                    break;
                }
                if (screensLeft & (1 << ref))
                    break;
                refScreen = xf86Screens[ref]->pScreen;
                pScreen->x = refScreen->x;
                pScreen->y = refScreen->y - pScreen->height;
                screensLeft &= ~(1 << i);
                break;
            default:
                ErrorF("Illegal placement keyword in Layout!\n");
                break;
            }

        }

        if (!screensLeft)
            break;

        if (screensLeft == prevScreensLeft) {
            /* All the remaining screens are referencing each other.
               Assign a value to one of them and go through again */
            i = 0;
            while (!((1 << i) & screensLeft)) {
                i++;
            }

            ref = xf86ConfigLayout.screens[i].refscreen->screennum;
            xf86Screens[ref]->pScreen->x = xf86Screens[ref]->pScreen->y = 0;
            screensLeft &= ~(1 << ref);
        }

        prevScreensLeft = screensLeft;
    }

    /* justify the topmost and leftmost to (0,0) */
    minX = xf86Screens[0]->pScreen->x;
    minY = xf86Screens[0]->pScreen->y;

    for (i = 1; i < xf86NumScreens; i++) {
        if (xf86Screens[i]->pScreen->x < minX)
            minX = xf86Screens[i]->pScreen->x;
        if (xf86Screens[i]->pScreen->y < minY)
            minY = xf86Screens[i]->pScreen->y;
    }

    if (minX || minY) {
        for (i = 0; i < xf86NumScreens; i++) {
            xf86Screens[i]->pScreen->x -= minX;
            xf86Screens[i]->pScreen->y -= minY;
        }
    }

    /* Create the edge lists */

    if (!OldStyleConfig) {
        for (i = 0; i < xf86NumScreens; i++) {
            pLayout = &xf86ScreenLayout[i];

            pScreen = xf86Screens[i]->pScreen;

            left = pScreen->x;
            right = left + pScreen->width;
            top = pScreen->y;
            bottom = top + pScreen->height;

            for (j = 0; j < xf86NumScreens; j++) {
                if (i == j)
                    continue;

                refScreen = xf86Screens[j]->pScreen;

                x1 = refScreen->x;
                x2 = x1 + refScreen->width;
                y1 = refScreen->y;
                y2 = y1 + refScreen->height;

                if ((bottom > y1) && (top < y2)) {
                    min = y1 - top;
                    if (min < 0)
                        min = 0;
                    max = pScreen->height - (bottom - y2);
                    if (max > pScreen->height)
                        max = pScreen->height;

                    if (((left - 1) >= x1) && ((left - 1) < x2))
                        pLayout->left = AddEdge(pLayout->left, min, max,
                                                pScreen->x - refScreen->x,
                                                pScreen->y - refScreen->y, j);

                    if ((right >= x1) && (right < x2))
                        pLayout->right = AddEdge(pLayout->right, min, max,
                                                 pScreen->x - refScreen->x,
                                                 pScreen->y - refScreen->y, j);
                }

                if ((left < x2) && (right > x1)) {
                    min = x1 - left;
                    if (min < 0)
                        min = 0;
                    max = pScreen->width - (right - x2);
                    if (max > pScreen->width)
                        max = pScreen->width;

                    if (((top - 1) >= y1) && ((top - 1) < y2))
                        pLayout->up = AddEdge(pLayout->up, min, max,
                                              pScreen->x - refScreen->x,
                                              pScreen->y - refScreen->y, j);

                    if ((bottom >= y1) && (bottom < y2))
                        pLayout->down = AddEdge(pLayout->down, min, max,
                                                pScreen->x - refScreen->x,
                                                pScreen->y - refScreen->y, j);
                }
            }
        }
    }

    if (!OldStyleConfig) {
        for (i = 0; i < xf86NumScreens; i++) {
            pLayout = &xf86ScreenLayout[i];
            pScreen = xf86Screens[i]->pScreen;
            if (pLayout->left)
                FillOutEdge(pLayout->left, pScreen->height);
            if (pLayout->right)
                FillOutEdge(pLayout->right, pScreen->height);
            if (pLayout->up)
                FillOutEdge(pLayout->up, pScreen->width);
            if (pLayout->down)
                FillOutEdge(pLayout->down, pScreen->width);
        }
    }

    update_desktop_dimensions();
}

void
xf86ReconfigureLayout(void)
{
    int i;

    for (i = 0; i < MAXSCREENS; i++) {
        xf86ScreenLayoutPtr sl = &xf86ScreenLayout[i];

        /* we don't have to zero these, xf86InitOrigins() takes care of that */
        free(sl->left);
        free(sl->right);
        free(sl->up);
        free(sl->down);
    }

    xf86InitOrigins();
}
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a39 2
#include "compiler.h"

a76 2
static Bool HardEdges;

a429 10
#if 0
    /* This presents problems for overlapping screens when
       HardEdges is used.  Have to think about the logic more */
    if ((*x < 0) || (*x >= (*pScreen)->width) ||
        (*y < 0) || (*y >= (*pScreen)->height)) {
        /* We may have crossed more than one screen */
        xf86CursorOffScreen(pScreen, x, y);
    }
#endif

a572 3
    /* need to have this set up with a config file option */
    HardEdges = FALSE;

d824 1
a824 1
    if (!HardEdges && !OldStyleConfig) {
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a74 3
    /* let miPointerInitialize take care of these */
    NULL,
    NULL
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d69 1
a69 1
static void xf86PointerMoved(int scrnIndex, int x, int y);
d136 1
a136 1
    ScrnInfoPtr pScr = XF86SCRNINFO(pScreen);
d138 1
a138 1
    (*pScr->PointerMoved) (pScreen->myNum, x, y);
d142 1
a142 1
xf86PointerMoved(int scrnIndex, int x, int y)
a144 1
    ScrnInfoPtr pScr = xf86Screens[scrnIndex];
d175 1
a175 1
        pScr->AdjustFrame(pScr->scrnIndex, pScr->frameX0, pScr->frameY0, 0);
d186 2
a187 1
    XF86SCRNINFO(pScreen)->zoomLocked = lock;
d199 1
a199 1
    ScrnInfoPtr pScr = XF86SCRNINFO(pScreen);
d202 1
a202 1
    int px, py, was_blocked;
d231 2
a232 2
    was_blocked = xf86BlockSIGIO();
    Switched = (*pScr->SwitchMode) (pScr->scrnIndex, mode, 0);
d270 1
a270 1
    xf86UnblockSIGIO(was_blocked);
d273 1
a273 1
        (*pScr->AdjustFrame) (pScr->scrnIndex, pScr->frameX0, pScr->frameY0, 0);
d319 1
a319 1
    ScrnInfoPtr pScr = XF86SCRNINFO(pScreen);
d472 1
a472 3
    int sigstate;

    sigstate = xf86BlockSIGIO();
d476 1
a476 1
    xf86UnblockSIGIO(sigstate);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d54 5
a58 5
   short screen;
   short start;
   short end;
   DDXPointRec offset;
   struct _xf86EdgeRec *next;
d62 1
a62 1
    xf86EdgePtr	left, right, up, down;
d72 6
a77 6
  xf86CursorOffScreen,
  xf86CrossScreen,
  xf86WarpCursor,
  /* let miPointerInitialize take care of these */
  NULL,
  NULL
d95 1
a95 1
  pScr->PointerMoved = xf86PointerMoved;
d97 28
a124 29
  /*
   * Compute the initial Viewport if necessary
   */
  if (pScr->display) {
    if (pScr->display->frameX0 < 0) {
      pScr->frameX0 = (pScr->virtualX - pScr->modes->HDisplay) / 2;
      pScr->frameY0 = (pScr->virtualY - pScr->modes->VDisplay) / 2;
    } else {
      pScr->frameX0 = pScr->display->frameX0;
      pScr->frameY0 = pScr->display->frameY0;
    }
  }

  pScr->frameX1 = pScr->frameX0 + pScr->modes->HDisplay - 1;
  pScr->frameY1 = pScr->frameY0 + pScr->modes->VDisplay - 1;

  /*
   * Now adjust the initial Viewport, so it lies within the virtual area
   */
  if (pScr->frameX1 >= pScr->virtualX)
    {
	pScr->frameX0 = pScr->virtualX - pScr->modes->HDisplay;
	pScr->frameX1 = pScr->frameX0 + pScr->modes->HDisplay - 1;
    }

  if (pScr->frameY1 >= pScr->virtualY)
    {
	pScr->frameY0 = pScr->virtualY - pScr->modes->VDisplay;
	pScr->frameY1 = pScr->frameY0 + pScr->modes->VDisplay - 1;
a127 1

d136 1
a136 1
  ScrnInfoPtr   pScr = XF86SCRNINFO(pScreen);
d138 1
a138 1
  (*pScr->PointerMoved)(pScreen->myNum, x, y);
d141 1
a141 2

static void 
d144 30
a173 2
  Bool          frameChanged = FALSE;
  ScrnInfoPtr   pScr = xf86Screens[scrnIndex];
d175 2
a176 30
  /*
   * check wether (x,y) belongs to the visual part of the screen
   * if not, change the base of the displayed frame accoring
   */
  if ( pScr->frameX0 > x) { 
    pScr->frameX0 = x;
    pScr->frameX1 = x + pScr->currentMode->HDisplay - 1;
    frameChanged = TRUE ;
  }
  
  if ( pScr->frameX1 < x) { 
    pScr->frameX1 = x + 1;
    pScr->frameX0 = x - pScr->currentMode->HDisplay + 1;
    frameChanged = TRUE ;
  }
  
  if ( pScr->frameY0 > y) { 
    pScr->frameY0 = y;
    pScr->frameY1 = y + pScr->currentMode->VDisplay - 1;
    frameChanged = TRUE;
  }
  
  if ( pScr->frameY1 < y) { 
    pScr->frameY1 = y;
    pScr->frameY0 = y - pScr->currentMode->VDisplay + 1;
    frameChanged = TRUE; 
  }
  
  if (frameChanged && pScr->AdjustFrame != NULL)
    pScr->AdjustFrame(pScr->scrnIndex, pScr->frameX0, pScr->frameY0, 0);
d187 1
a187 1
  XF86SCRNINFO(pScreen)->zoomLocked = lock;
d199 5
a203 5
  ScrnInfoPtr pScr = XF86SCRNINFO(pScreen);
  ScreenPtr   pCursorScreen;
  Bool        Switched;
  int         px, py, was_blocked;
  DeviceIntPtr dev, it;
d205 2
a206 2
  if (!pScr->vtSema || !mode || !pScr->SwitchMode)
    return FALSE;
d209 2
a210 2
  if (DGAActive(pScr->scrnIndex))
    return FALSE;
d213 2
a214 5
  if (mode == pScr->currentMode)
    return TRUE;

  if (mode->HDisplay > pScr->virtualX || mode->VDisplay > pScr->virtualY)
    return FALSE;
d216 2
a217 17
  /* Let's take an educated guess for which pointer to take here. And about as
     educated as it gets is to take the first pointer we find.
   */
  for (dev = inputInfo.devices; dev; dev = dev->next)
  {
      if (IsPointerDevice(dev) && dev->spriteInfo->spriteOwner)
          break;
  }

  pCursorScreen = miPointerGetScreen(dev);
  if (pScreen == pCursorScreen)
    miPointerGetPosition(dev, &px, &py);

  was_blocked = xf86BlockSIGIO();
  Switched = (*pScr->SwitchMode)(pScr->scrnIndex, mode, 0);
  if (Switched) {
    pScr->currentMode = mode;
d219 2
a220 3
    /*
     * Adjust frame for new display size.
     * Frame is centered around cursor position if cursor is on same screen.
d222 3
a224 12
    if (pScreen == pCursorScreen)
      pScr->frameX0 = px - (mode->HDisplay / 2) + 1;
    else
      pScr->frameX0 = (pScr->frameX0 + pScr->frameX1 + 1 - mode->HDisplay) / 2;

    if (pScr->frameX0 < 0)
      pScr->frameX0 = 0;

    pScr->frameX1 = pScr->frameX0 + mode->HDisplay - 1;
    if (pScr->frameX1 >= pScr->virtualX) {
      pScr->frameX0 = pScr->virtualX - mode->HDisplay;
      pScr->frameX1 = pScr->virtualX - 1;
d227 1
d229 1
a229 3
      pScr->frameY0 = py - (mode->VDisplay / 2) + 1;
    else
      pScr->frameY0 = (pScr->frameY0 + pScr->frameY1 + 1 - mode->VDisplay) / 2;
d231 53
a283 2
    if (pScr->frameY0 < 0)
      pScr->frameY0 = 0;
d285 21
a305 4
    pScr->frameY1 = pScr->frameY0 + mode->VDisplay - 1;
    if (pScr->frameY1 >= pScr->virtualY) {
      pScr->frameY0 = pScr->virtualY - mode->VDisplay;
      pScr->frameY1 = pScr->virtualY - 1;
a306 2
  }
  xf86UnblockSIGIO(was_blocked);
d308 2
a309 39
  if (pScr->AdjustFrame)
    (*pScr->AdjustFrame)(pScr->scrnIndex, pScr->frameX0, pScr->frameY0, 0);

  /* The original code centered the frame around the cursor if possible.
   * Since this is hard to achieve with multiple cursors, we do the following:
   *   - center around the first pointer
   *   - move all other pointers to the nearest edge on the screen (or leave
   *   them unmodified if they are within the boundaries).
   */
  if (pScreen == pCursorScreen)
  {
      xf86WarpCursor(dev, pScreen, px, py);
  }

  for (it = inputInfo.devices; it; it = it->next)
  {
      if (it == dev)
          continue;

      if (IsPointerDevice(it) && it->spriteInfo->spriteOwner)
      {
          pCursorScreen = miPointerGetScreen(it);
          if (pScreen == pCursorScreen)
          {
              miPointerGetPosition(it, &px, &py);
              if (px < pScr->frameX0)
                  px = pScr->frameX0;
              else if (px > pScr->frameX1)
                  px = pScr->frameX1;

              if(py < pScr->frameY0)
                  py = pScr->frameY0;
              else if(py > pScr->frameY1)
                  py = pScr->frameY1;

              xf86WarpCursor(it, pScreen, px, py);
          }
      }
  }
a310 3
  return Switched;
}
    
d319 2
a320 2
  ScrnInfoPtr    pScr = XF86SCRNINFO(pScreen);
  DisplayModePtr mode;
d322 2
a323 2
  if (pScr->zoomLocked || !(mode = pScr->currentMode))
    return;
d325 6
a330 6
  do {
    if (zoom > 0)
      mode = mode->next;
    else
      mode = mode->prev;
  } while (mode != pScr->currentMode && !(mode->type & M_T_USERDEF));
d332 1
a332 1
  (void)xf86SwitchMode(pScreen, mode);
a334 1

d338 2
a339 2
    while(edge && (edge->end <= val))
	edge = edge->next;
d341 2
a342 2
    if(edge && (edge->start <= val))
	return edge;
d358 2
a359 2
    if(screenInfo.numScreens == 1)
	return FALSE;
d361 1
a361 1
    if(*x < 0) {
d363 15
a377 12
	if(tmp < 0) tmp = 0;
	if(tmp >= (*pScreen)->height) tmp = (*pScreen)->height - 1;

	if((edge = xf86ScreenLayout[(*pScreen)->myNum].left))
	   edge = FindEdge(edge, tmp);

	if(!edge) *x = 0;
	else {
	    *x += edge->offset.x;
	    *y += edge->offset.y;
	    *pScreen = xf86Screens[edge->screen]->pScreen;
	}
d380 1
a380 1
    if(*x >= (*pScreen)->width) {
d382 15
a396 12
	if(tmp < 0) tmp = 0;
	if(tmp >= (*pScreen)->height) tmp = (*pScreen)->height - 1;

	if((edge = xf86ScreenLayout[(*pScreen)->myNum].right))
	   edge = FindEdge(edge, tmp);

	if(!edge) *x = (*pScreen)->width - 1;
	else {
	    *x += edge->offset.x;
	    *y += edge->offset.y;
	    *pScreen = xf86Screens[edge->screen]->pScreen;
	}
d399 1
a399 1
    if(*y < 0) {
d401 15
a415 12
	if(tmp < 0) tmp = 0;
	if(tmp >= (*pScreen)->width) tmp = (*pScreen)->width - 1;

	if((edge = xf86ScreenLayout[(*pScreen)->myNum].up))
	   edge = FindEdge(edge, tmp);

	if(!edge) *y = 0;
	else {
	    *x += edge->offset.x;
	    *y += edge->offset.y;
	    *pScreen = xf86Screens[edge->screen]->pScreen;
	}
d418 1
a418 1
    if(*y >= (*pScreen)->height) {
d420 15
a434 12
	if(tmp < 0) tmp = 0;
	if(tmp >= (*pScreen)->width) tmp = (*pScreen)->width - 1;

	if((edge = xf86ScreenLayout[(*pScreen)->myNum].down))
	   edge = FindEdge(edge, tmp);

	if(!edge) *y = (*pScreen)->height - 1;
	else {
	    *x += edge->offset.x;
	    *y += edge->offset.y;
	    (*pScreen) = xf86Screens[edge->screen]->pScreen;
	}
a436 1

d439 5
a443 5
 	HardEdges is used.  Have to think about the logic more */
    if((*x < 0) || (*x >= (*pScreen)->width) || 
       (*y < 0) || (*y >= (*pScreen)->height)) {
	/* We may have crossed more than one screen */
	xf86CursorOffScreen(pScreen, x, y);
a449 2


d459 1
a459 1
xf86CrossScreen (ScreenPtr pScreen, Bool entering)
a462 1

d470 1
a470 1
xf86WarpCursor (DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
d472 3
a474 2
    int    sigstate;
    sigstate = xf86BlockSIGIO ();
d478 1
a478 1
    xf86UnblockSIGIO (sigstate);
a480 1

d484 1
a484 1
    return (void *)&xf86PointerScreenFuncs;
d487 59
d547 5
a551 64
static xf86EdgePtr
AddEdge(
   xf86EdgePtr edge, 
   short min, 
   short max,
   short dx,
   short dy,
   short screen
){
   xf86EdgePtr pEdge = edge, pPrev = NULL, pNew;

   while(1) {
	while(pEdge && (min >= pEdge->end)) {
	    pPrev = pEdge;
	    pEdge = pEdge->next;
	}  

	if(!pEdge) {
	    if(!(pNew = malloc(sizeof(xf86EdgeRec))))
		break;

	    pNew->screen = screen;
	    pNew->start = min;  
	    pNew->end = max;   
	    pNew->offset.x = dx;
	    pNew->offset.y = dy;
	    pNew->next = NULL;

	    if(pPrev)
		pPrev->next = pNew;
	    else
		edge = pNew;
	    
	    break;
	} else if (min < pEdge->start) {
	    if(!(pNew = malloc(sizeof(xf86EdgeRec))))
		break;

	    pNew->screen = screen;
	    pNew->start = min;  
	    pNew->offset.x = dx;
	    pNew->offset.y = dy;
	    pNew->next = pEdge;

	    if(pPrev) pPrev->next = pNew;
	    else edge = pNew;

	    if(max <= pEdge->start) {
		pNew->end = max;   
		break;
	    } else {
		pNew->end = pEdge->start;
		min = pEdge->end;
	    }
	} else
	    min = pEdge->end;

	pPrev = pEdge;
	pEdge = pEdge->next;

	if(max <= min) break;
   }
	
   return edge;
d560 2
a561 1
    if(pEdge->start > 0) pEdge->start = 0;
d563 7
a569 7
    while((pNext = pEdge->next)) {
	diff = pNext->start - pEdge->end;
	if(diff > 0) {	
	    pEdge->end += diff >> 1;
	    pNext->start -= diff - (diff >> 1);
	}
	pEdge = pNext;
d572 2
a573 2
    if(pEdge->end < limit)
	pEdge->end = limit;    
d596 1
a596 1
	
d599 160
a758 146
    while(1) {
	for(mask = screensLeft, i = 0; mask; mask >>= 1, i++) {
	    if(!(mask & 1L)) continue;

	    screen = &xf86ConfigLayout.screens[i];

	    if (screen->refscreen != NULL &&
		screen->refscreen->screennum >= xf86NumScreens) {
		screensLeft &= ~(1 << i);
	        xf86Msg(X_WARNING, "Not including screen \"%s\" in origins calculation.\n",
			screen->screen->id);
	        continue;
	    }

	    pScreen = xf86Screens[i]->pScreen;
	    switch(screen->where) {
	    case PosObsolete:
		OldStyleConfig = TRUE;
		pLayout = &xf86ScreenLayout[i];
		/* force edge lists */
		if(screen->left) {
		    ref = screen->left->screennum;
		    if (! xf86Screens[ref] || ! xf86Screens[ref]->pScreen) {
			ErrorF("Referenced uninitialized screen in Layout!\n");
			break;
		    }
		    pLayout->left = AddEdge(pLayout->left, 
			0, pScreen->height,
			xf86Screens[ref]->pScreen->width, 0, ref);
		}
		if(screen->right) {
		    ref = screen->right->screennum;
		    if (! xf86Screens[ref] || ! xf86Screens[ref]->pScreen) {
			ErrorF("Referenced uninitialized screen in Layout!\n");
			break;
		    }
		    pLayout->right = AddEdge(pLayout->right, 
			0, pScreen->height, -pScreen->width, 0, ref);
		}
		if(screen->top) {
		    ref = screen->top->screennum;
		    if (! xf86Screens[ref] || ! xf86Screens[ref]->pScreen) {
			ErrorF("Referenced uninitialized screen in Layout!\n");
			break;
		    }
		    pLayout->up = AddEdge(pLayout->up, 
			0, pScreen->width,
			0, xf86Screens[ref]->pScreen->height, ref);
		}
		if(screen->bottom) {
		    ref = screen->bottom->screennum;
		    if (! xf86Screens[ref] || ! xf86Screens[ref]->pScreen) {
			ErrorF("Referenced uninitialized screen in Layout!\n");
			break;
		    }
		    pLayout->down = AddEdge(pLayout->down, 
			0, pScreen->width, 0, -pScreen->height, ref);
		}
	        /* we could also try to place it based on those
		   relative locations if we wanted to */
		screen->x = screen->y = 0;
		/* FALLTHROUGH */
	    case PosAbsolute:
		pScreen->x = screen->x;
		pScreen->y = screen->y;
		screensLeft &= ~(1 << i);
		break;
	    case PosRelative:
		ref = screen->refscreen->screennum;
		if (! xf86Screens[ref] || ! xf86Screens[ref]->pScreen) {
		    ErrorF("Referenced uninitialized screen in Layout!\n");
		    break;
		}
		if(screensLeft & (1 << ref)) break;
		refScreen = xf86Screens[ref]->pScreen;
		pScreen->x = refScreen->x + screen->x;
		pScreen->y = refScreen->y + screen->y;
		screensLeft &= ~(1 << i);
		break;
	    case PosRightOf:
		ref = screen->refscreen->screennum;
		if (! xf86Screens[ref] || ! xf86Screens[ref]->pScreen) {
		    ErrorF("Referenced uninitialized screen in Layout!\n");
		    break;
		}
		if(screensLeft & (1 << ref)) break;
		refScreen = xf86Screens[ref]->pScreen;
		pScreen->x = refScreen->x + refScreen->width;
		pScreen->y = refScreen->y;
		screensLeft &= ~(1 << i);
		break;
	    case PosLeftOf:
		ref = screen->refscreen->screennum;
		if (! xf86Screens[ref] || ! xf86Screens[ref]->pScreen) {
		    ErrorF("Referenced uninitialized screen in Layout!\n");
		    break;
		}
		if(screensLeft & (1 << ref)) break;
		refScreen = xf86Screens[ref]->pScreen;
		pScreen->x = refScreen->x - pScreen->width;
		pScreen->y = refScreen->y;
		screensLeft &= ~(1 << i);
		break;
	    case PosBelow:
		ref = screen->refscreen->screennum;
		if (! xf86Screens[ref] || ! xf86Screens[ref]->pScreen) {
		    ErrorF("Referenced uninitialized screen in Layout!\n");
		    break;
		}
		if(screensLeft & (1 << ref)) break;
		refScreen = xf86Screens[ref]->pScreen;
		pScreen->x = refScreen->x;
		pScreen->y = refScreen->y + refScreen->height;
		screensLeft &= ~(1 << i);
		break;
	    case PosAbove:
		ref = screen->refscreen->screennum;
		if (! xf86Screens[ref] || ! xf86Screens[ref]->pScreen) {
		    ErrorF("Referenced uninitialized screen in Layout!\n");
		    break;
		}
		if(screensLeft & (1 << ref)) break;
		refScreen = xf86Screens[ref]->pScreen;
		pScreen->x = refScreen->x;
		pScreen->y = refScreen->y - pScreen->height;
		screensLeft &= ~(1 << i);
		break;
	    default:
		ErrorF("Illegal placement keyword in Layout!\n");
		break;
	    }

	}

	if(!screensLeft) break;

	if(screensLeft == prevScreensLeft) {
	/* All the remaining screens are referencing each other.
	   Assign a value to one of them and go through again */
	    i = 0;
	    while(!((1 << i) & screensLeft)){ i++; }

	    ref = xf86ConfigLayout.screens[i].refscreen->screennum;
	    xf86Screens[ref]->pScreen->x = xf86Screens[ref]->pScreen->y = 0;
	    screensLeft &= ~(1 << ref);
	}
d760 1
a760 1
	prevScreensLeft = screensLeft;
d767 5
a771 5
    for(i = 1; i < xf86NumScreens; i++) {
	if(xf86Screens[i]->pScreen->x < minX)
	  minX = xf86Screens[i]->pScreen->x;
	if(xf86Screens[i]->pScreen->y < minY)
	  minY = xf86Screens[i]->pScreen->y;
d775 4
a778 4
	for(i = 0; i < xf86NumScreens; i++) {
	   xf86Screens[i]->pScreen->x -= minX;
	   xf86Screens[i]->pScreen->y -= minY;
	}
a780 1

d783 76
a858 72
    if(!OldStyleConfig) {
      for(i = 0; i < xf86NumScreens; i++) {
	pLayout = &xf86ScreenLayout[i];

	pScreen = xf86Screens[i]->pScreen;

	left = pScreen->x;
	right = left + pScreen->width;
	top = pScreen->y;
	bottom = top + pScreen->height;

	for(j = 0; j < xf86NumScreens; j++) {
	    if(i == j) continue;

	    refScreen = xf86Screens[j]->pScreen;

	    x1 = refScreen->x;
	    x2 = x1 + refScreen->width;
	    y1 = refScreen->y;
	    y2 = y1 + refScreen->height;

	    if((bottom > y1) && (top < y2)) {
		min = y1 - top;
		if(min < 0) min = 0;
		max = pScreen->height - (bottom - y2);
		if(max > pScreen->height) max = pScreen->height;

		if(((left - 1) >= x1) && ((left - 1) < x2))
		    pLayout->left = AddEdge(pLayout->left, min, max,
			pScreen->x - refScreen->x,
			pScreen->y - refScreen->y, j);

		if((right >= x1) && (right < x2))	
		    pLayout->right = AddEdge(pLayout->right, min, max,
			pScreen->x - refScreen->x,
			pScreen->y - refScreen->y, j);
	    }


	    if((left < x2) && (right > x1)) {
		min = x1 - left;
		if(min < 0) min = 0;
		max = pScreen->width - (right - x2);
		if(max > pScreen->width) max = pScreen->width;

		if(((top - 1) >= y1) && ((top - 1) < y2))
		    pLayout->up = AddEdge(pLayout->up, min, max,
			pScreen->x - refScreen->x,
			pScreen->y - refScreen->y, j);

		if((bottom >= y1) && (bottom < y2))
		    pLayout->down = AddEdge(pLayout->down, min, max,
			pScreen->x - refScreen->x,
			pScreen->y - refScreen->y, j);
	    }
	}
      }
    }

    if(!HardEdges && !OldStyleConfig) {
	for(i = 0; i < xf86NumScreens; i++) {
	    pLayout = &xf86ScreenLayout[i];
	    pScreen = xf86Screens[i]->pScreen;
	    if(pLayout->left) 
		FillOutEdge(pLayout->left, pScreen->height);
	    if(pLayout->right) 
		FillOutEdge(pLayout->right, pScreen->height);
	    if(pLayout->up) 
		FillOutEdge(pLayout->up, pScreen->width);
	    if(pLayout->down) 
		FillOutEdge(pLayout->down, pScreen->width);
	}
d860 2
d870 7
a876 6
	xf86ScreenLayoutPtr sl = &xf86ScreenLayout[i];
	/* we don't have to zero these, xf86InitOrigins() takes care of that */
	free(sl->left);
	free(sl->right);
	free(sl->up);
	free(sl->down);
a880 2

	
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d205 1
a205 1
  int         px, py;
d235 1
a235 1
  xf86EnterServerState(SETUP);
d272 1
a272 1
  xf86EnterServerState(OPERATING);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d505 1
a505 1
	    if(!(pNew = xalloc(sizeof(xf86EdgeRec))))
d522 1
a522 1
	    if(!(pNew = xalloc(sizeof(xf86EdgeRec))))
d584 1
a584 1
    ScreenPtr pScreen;
d593 1
a593 1
    bzero(xf86ScreenLayout, MAXSCREENS * sizeof(xf86ScreenLayoutRec));
d611 1
d624 1
a624 1
			0, xf86Screens[i]->pScreen->height,
a632 1
		    pScreen = xf86Screens[i]->pScreen;
d643 1
a643 1
			0, xf86Screens[i]->pScreen->width,
a651 1
		    pScreen = xf86Screens[i]->pScreen;
d660 2
a661 2
		dixScreenOrigins[i].x = screen->x;
		dixScreenOrigins[i].y = screen->y;
d671 3
a673 2
		dixScreenOrigins[i].x = dixScreenOrigins[ref].x + screen->x;
		dixScreenOrigins[i].y = dixScreenOrigins[ref].y + screen->y;
d683 3
a685 4
		pScreen = xf86Screens[ref]->pScreen;
		dixScreenOrigins[i].x = 
			dixScreenOrigins[ref].x + pScreen->width;
		dixScreenOrigins[i].y = dixScreenOrigins[ref].y;
d695 3
a697 4
		pScreen = xf86Screens[i]->pScreen;
		dixScreenOrigins[i].x = 
			dixScreenOrigins[ref].x - pScreen->width;
		dixScreenOrigins[i].y = dixScreenOrigins[ref].y;
d707 3
a709 4
		pScreen = xf86Screens[ref]->pScreen;
		dixScreenOrigins[i].x = dixScreenOrigins[ref].x;
		dixScreenOrigins[i].y = 
			dixScreenOrigins[ref].y + pScreen->height;
d719 3
a721 4
		pScreen = xf86Screens[i]->pScreen;
		dixScreenOrigins[i].x = dixScreenOrigins[ref].x;
		dixScreenOrigins[i].y = 
			dixScreenOrigins[ref].y - pScreen->height;
d740 1
a740 1
	    dixScreenOrigins[ref].x = dixScreenOrigins[ref].y = 0;
d748 2
a749 2
    minX = dixScreenOrigins[0].x;
    minY = dixScreenOrigins[0].y;
d752 4
a755 4
	if(dixScreenOrigins[i].x < minX)
	  minX = dixScreenOrigins[i].x;
	if(dixScreenOrigins[i].y < minY)
	  minY = dixScreenOrigins[i].y;
d760 2
a761 2
	   dixScreenOrigins[i].x -= minX;
	   dixScreenOrigins[i].y -= minY;
d774 1
a774 1
	left = dixScreenOrigins[i].x;
d776 1
a776 1
	top = dixScreenOrigins[i].y;
d782 6
a787 4
	    x1 = dixScreenOrigins[j].x;
	    x2 = x1 + xf86Screens[j]->pScreen->width;
	    y1 = dixScreenOrigins[j].y;
	    y2 = y1 + xf86Screens[j]->pScreen->height;
d797 2
a798 2
			dixScreenOrigins[i].x - dixScreenOrigins[j].x,
			dixScreenOrigins[i].y - dixScreenOrigins[j].y, j);
d802 2
a803 2
			dixScreenOrigins[i].x - dixScreenOrigins[j].x,
			dixScreenOrigins[i].y - dixScreenOrigins[j].y, j);
d815 2
a816 2
			dixScreenOrigins[i].x - dixScreenOrigins[j].x,
			dixScreenOrigins[i].y - dixScreenOrigins[j].y, j);
d820 2
a821 2
			dixScreenOrigins[i].x - dixScreenOrigins[j].x,
			dixScreenOrigins[i].y - dixScreenOrigins[j].y, j);
d851 4
a854 4
	if (sl->left) xfree(sl->left);
	if (sl->right) xfree(sl->right);
	if (sl->up) xfree(sl->up);
	if (sl->down) xfree(sl->down);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a27 1
#define NEED_EVENTS
a229 2
  if (!dev)
      dev = inputInfo.pointer;
d480 1
a480 1
_X_EXPORT void *
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a46 1
#ifdef XINPUT
a48 1
#endif
d68 1
a68 1
static void xf86WarpCursor(ScreenPtr pScreen, int x, int y);
d207 1
d223 12
a234 1
  pCursorScreen = miPointerGetScreen(inputInfo.pointer);
d236 1
a236 1
    miPointerGetPosition(inputInfo.pointer, &px, &py);
d245 1
d280 6
d287 29
a315 1
    xf86WarpCursor(pScreen, px, py);
d472 1
a472 1
xf86WarpCursor (ScreenPtr pScreen, int x, int y)
d476 1
a476 1
  miPointerWarpCursor(pScreen,x,y);
d478 1
a478 1
  xf86Info.currentScreen = pScreen;
@


1.1
log
@Initial revision
@
text
@a27 2
/* $XConsortium: xf86Cursor.c /main/10 1996/10/19 17:58:23 kaleb $ */

a77 4
#ifdef XINPUT
  xf86eqEnqueue,
  xf86eqSwitchScreen
#else
a80 1
#endif
d224 1
a224 1
  pCursorScreen = miPointerCurrentScreen();
d226 1
a226 1
    miPointerPosition(&px, &py);
d409 3
a413 2
/* NEED TO CHECK THIS */
/* ARGSUSED */
a416 5
#if 0
  if (xf86Info.sharedMonitor)
    (XF86SCRNINFO(pScreen)->EnterLeaveMonitor)(entering);
  (XF86SCRNINFO(pScreen)->EnterLeaveCursor)(entering);
#endif
d560 8
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d28 2
d80 4
d87 1
d231 1
a231 1
  pCursorScreen = miPointerGetScreen(inputInfo.pointer);
d233 1
a233 1
    miPointerGetPosition(inputInfo.pointer, &px, &py);
a415 3
 *
 *	Currently nothing special happens, but mi assumes the CrossScreen
 *	method exists.
d418 2
d423 5
@

