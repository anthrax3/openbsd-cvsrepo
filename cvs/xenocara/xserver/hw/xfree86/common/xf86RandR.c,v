head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.07;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *
 * Copyright Â© 2002 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include "os.h"
#include "globals.h"
#include "xf86.h"
#include "xf86str.h"
#include "xf86Priv.h"
#include "xf86DDC.h"
#include "mipointer.h"
#include <randrstr.h>
#include "inputstr.h"

typedef struct _xf86RandRInfo {
    CloseScreenProcPtr CloseScreen;
    int virtualX;
    int virtualY;
    int mmWidth;
    int mmHeight;
    Rotation rotation;
} XF86RandRInfoRec, *XF86RandRInfoPtr;

static DevPrivateKeyRec xf86RandRKeyRec;
static DevPrivateKey xf86RandRKey;

#define XF86RANDRINFO(p) ((XF86RandRInfoPtr)dixLookupPrivate(&(p)->devPrivates, xf86RandRKey))

static int
xf86RandRModeRefresh(DisplayModePtr mode)
{
    if (mode->VRefresh)
        return (int) (mode->VRefresh + 0.5);
    else if (mode->Clock == 0)
        return 0;
    else
        return (int) (mode->Clock * 1000.0 / mode->HTotal / mode->VTotal + 0.5);
}

static Bool
xf86RandRGetInfo(ScreenPtr pScreen, Rotation * rotations)
{
    RRScreenSizePtr pSize;
    ScrnInfoPtr scrp = xf86ScreenToScrn(pScreen);
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    DisplayModePtr mode;
    int refresh0 = 60;
    xorgRRModeMM RRModeMM;

    *rotations = RR_Rotate_0;

    for (mode = scrp->modes; mode != NULL; mode = mode->next) {
        int refresh = xf86RandRModeRefresh(mode);

        if (mode == scrp->modes)
            refresh0 = refresh;

        RRModeMM.mode = mode;
        RRModeMM.virtX = randrp->virtualX;
        RRModeMM.virtY = randrp->virtualY;
        RRModeMM.mmWidth = randrp->mmWidth;
        RRModeMM.mmHeight = randrp->mmHeight;

        if (scrp->DriverFunc) {
            (*scrp->DriverFunc) (scrp, RR_GET_MODE_MM, &RRModeMM);
        }

        pSize = RRRegisterSize(pScreen,
                               mode->HDisplay, mode->VDisplay,
                               RRModeMM.mmWidth, RRModeMM.mmHeight);
        if (!pSize)
            return FALSE;
        RRRegisterRate(pScreen, pSize, refresh);
        if (mode == scrp->currentMode &&
            mode->HDisplay == scrp->virtualX &&
            mode->VDisplay == scrp->virtualY)
            RRSetCurrentConfig(pScreen, randrp->rotation, refresh, pSize);
        if (mode->next == scrp->modes)
            break;
    }
    if (scrp->currentMode->HDisplay != randrp->virtualX ||
        scrp->currentMode->VDisplay != randrp->virtualY) {
        mode = scrp->modes;

        RRModeMM.mode = NULL;
        RRModeMM.virtX = randrp->virtualX;
        RRModeMM.virtY = randrp->virtualY;
        RRModeMM.mmWidth = randrp->mmWidth;
        RRModeMM.mmHeight = randrp->mmHeight;

        if (scrp->DriverFunc) {
            (*scrp->DriverFunc) (scrp, RR_GET_MODE_MM, &RRModeMM);
        }

        pSize = RRRegisterSize(pScreen,
                               randrp->virtualX, randrp->virtualY,
                               RRModeMM.mmWidth, RRModeMM.mmHeight);
        if (!pSize)
            return FALSE;
        RRRegisterRate(pScreen, pSize, refresh0);
        if (scrp->virtualX == randrp->virtualX &&
            scrp->virtualY == randrp->virtualY) {
            RRSetCurrentConfig(pScreen, randrp->rotation, refresh0, pSize);
        }
    }

    /* If there is driver support for randr, let it set our supported rotations */
    if (scrp->DriverFunc) {
        xorgRRRotation RRRotation;

        RRRotation.RRRotations = *rotations;
        if (!(*scrp->DriverFunc) (scrp, RR_GET_INFO, &RRRotation))
            return TRUE;
        *rotations = RRRotation.RRRotations;
    }

    return TRUE;
}

static Bool
xf86RandRSetMode(ScreenPtr pScreen,
                 DisplayModePtr mode,
                 Bool useVirtual, int mmWidth, int mmHeight)
{
    ScrnInfoPtr scrp = xf86ScreenToScrn(pScreen);
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    int oldWidth = pScreen->width;
    int oldHeight = pScreen->height;
    int oldmmWidth = pScreen->mmWidth;
    int oldmmHeight = pScreen->mmHeight;
    int oldVirtualX = scrp->virtualX;
    int oldVirtualY = scrp->virtualY;
    WindowPtr pRoot = pScreen->root;
    Bool ret = TRUE;

    if (pRoot && scrp->vtSema)
        (*scrp->EnableDisableFBAccess) (scrp, FALSE);
    if (useVirtual) {
        scrp->virtualX = randrp->virtualX;
        scrp->virtualY = randrp->virtualY;
    }
    else {
        scrp->virtualX = mode->HDisplay;
        scrp->virtualY = mode->VDisplay;
    }

    /*
     * The DIX forgets the physical dimensions we passed into RRRegisterSize, so
     * reconstruct them if possible.
     */
    if (scrp->DriverFunc) {
        xorgRRModeMM RRModeMM;

        RRModeMM.mode = mode;
        RRModeMM.virtX = scrp->virtualX;
        RRModeMM.virtY = scrp->virtualY;
        RRModeMM.mmWidth = mmWidth;
        RRModeMM.mmHeight = mmHeight;

        (*scrp->DriverFunc) (scrp, RR_GET_MODE_MM, &RRModeMM);

        mmWidth = RRModeMM.mmWidth;
        mmHeight = RRModeMM.mmHeight;
    }
    if (randrp->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
        /* If the screen is rotated 90 or 270 degrees, swap the sizes. */
        pScreen->width = scrp->virtualY;
        pScreen->height = scrp->virtualX;
        pScreen->mmWidth = mmHeight;
        pScreen->mmHeight = mmWidth;
    }
    else {
        pScreen->width = scrp->virtualX;
        pScreen->height = scrp->virtualY;
        pScreen->mmWidth = mmWidth;
        pScreen->mmHeight = mmHeight;
    }
    if (!xf86SwitchMode(pScreen, mode)) {
        pScreen->width = oldWidth;
        pScreen->height = oldHeight;
        pScreen->mmWidth = oldmmWidth;
        pScreen->mmHeight = oldmmHeight;
        scrp->virtualX = oldVirtualX;
        scrp->virtualY = oldVirtualY;
        ret = FALSE;
    }
    /*
     * Make sure the layout is correct
     */
    xf86ReconfigureLayout();

    if (scrp->vtSema) {
        /*
         * Make sure the whole screen is visible
         */
        xf86SetViewport (pScreen, pScreen->width, pScreen->height);
        xf86SetViewport (pScreen, 0, 0);
        if (pRoot)
            (*scrp->EnableDisableFBAccess) (scrp, TRUE);
    }
    return ret;
}

static Bool
xf86RandRSetConfig(ScreenPtr pScreen,
                   Rotation rotation, int rate, RRScreenSizePtr pSize)
{
    ScrnInfoPtr scrp = xf86ScreenToScrn(pScreen);
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);
    DisplayModePtr mode;
    int pos[MAXDEVICES][2];
    Bool useVirtual = FALSE;
    Rotation oldRotation = randrp->rotation;
    DeviceIntPtr dev;
    Bool view_adjusted = FALSE;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (!IsMaster(dev) && !IsFloating(dev))
            continue;

        miPointerGetPosition(dev, &pos[dev->id][0], &pos[dev->id][1]);
    }

    for (mode = scrp->modes;; mode = mode->next) {
        if (mode->HDisplay == pSize->width &&
            mode->VDisplay == pSize->height &&
            (rate == 0 || xf86RandRModeRefresh(mode) == rate))
            break;
        if (mode->next == scrp->modes) {
            if (pSize->width == randrp->virtualX &&
                pSize->height == randrp->virtualY) {
                mode = scrp->modes;
                useVirtual = TRUE;
                break;
            }
            return FALSE;
        }
    }

    if (randrp->rotation != rotation) {

        /* Have the driver do its thing. */
        if (scrp->DriverFunc) {
            xorgRRRotation RRRotation;

            RRRotation.RRConfig.rotation = rotation;
            RRRotation.RRConfig.rate = rate;
            RRRotation.RRConfig.width = pSize->width;
            RRRotation.RRConfig.height = pSize->height;

            /*
             * Currently we need to rely on HW support for rotation.
             */
            if (!(*scrp->DriverFunc) (scrp, RR_SET_CONFIG, &RRRotation))
                return FALSE;
        }
        else
            return FALSE;

        randrp->rotation = rotation;
    }

    if (!xf86RandRSetMode
        (pScreen, mode, useVirtual, pSize->mmWidth, pSize->mmHeight)) {
        if (randrp->rotation != oldRotation) {
            /* Have the driver undo its thing. */
            if (scrp->DriverFunc) {
                xorgRRRotation RRRotation;

                RRRotation.RRConfig.rotation = oldRotation;
                RRRotation.RRConfig.rate =
                    xf86RandRModeRefresh(scrp->currentMode);
                RRRotation.RRConfig.width = scrp->virtualX;
                RRRotation.RRConfig.height = scrp->virtualY;
                (*scrp->DriverFunc) (scrp, RR_SET_CONFIG, &RRRotation);
            }

            randrp->rotation = oldRotation;
        }
        return FALSE;
    }

    update_desktop_dimensions();

    /*
     * Move the cursor back where it belongs; SwitchMode repositions it
     * FIXME: duplicated code, see modes/xf86RandR12.c
     */
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (!IsMaster(dev) && !IsFloating(dev))
            continue;

        if (pScreen == miPointerGetScreen(dev)) {
            int px = pos[dev->id][0];
            int py = pos[dev->id][1];

            px = (px >= pScreen->width ? (pScreen->width - 1) : px);
            py = (py >= pScreen->height ? (pScreen->height - 1) : py);

            /* Setting the viewpoint makes only sense on one device */
            if (!view_adjusted && IsMaster(dev)) {
                xf86SetViewport(pScreen, px, py);
                view_adjusted = TRUE;
            }

            (*pScreen->SetCursorPosition) (dev, pScreen, px, py, FALSE);
        }
    }

    return TRUE;
}

/*
 * Reset size back to original
 */
static Bool
xf86RandRCloseScreen(ScreenPtr pScreen)
{
    ScrnInfoPtr scrp = xf86ScreenToScrn(pScreen);
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);

    scrp->virtualX = pScreen->width = randrp->virtualX;
    scrp->virtualY = pScreen->height = randrp->virtualY;
    scrp->currentMode = scrp->modes;
    pScreen->CloseScreen = randrp->CloseScreen;
    free(randrp);
    dixSetPrivate(&pScreen->devPrivates, xf86RandRKey, NULL);
    return (*pScreen->CloseScreen) (pScreen);
}

Rotation
xf86GetRotation(ScreenPtr pScreen)
{
    if (xf86RandRKey == NULL)
        return RR_Rotate_0;

    return XF86RANDRINFO(pScreen)->rotation;
}

/* Function to change RandR's idea of the virtual screen size */
Bool
xf86RandRSetNewVirtualAndDimensions(ScreenPtr pScreen,
                                    int newvirtX, int newvirtY, int newmmWidth,
                                    int newmmHeight, Bool resetMode)
{
    XF86RandRInfoPtr randrp;

    if (xf86RandRKey == NULL)
        return FALSE;

    randrp = XF86RANDRINFO(pScreen);
    if (randrp == NULL)
        return FALSE;

    if (newvirtX > 0)
        randrp->virtualX = newvirtX;

    if (newvirtY > 0)
        randrp->virtualY = newvirtY;

    if (newmmWidth > 0)
        randrp->mmWidth = newmmWidth;

    if (newmmHeight > 0)
        randrp->mmHeight = newmmHeight;

    /* This is only for during server start */
    if (resetMode) {
	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
        return (xf86RandRSetMode(pScreen,
                                 pScrn->currentMode,
                                 TRUE, pScreen->mmWidth, pScreen->mmHeight));
    }

    return TRUE;
}

Bool
xf86RandRInit(ScreenPtr pScreen)
{
    rrScrPrivPtr rp;
    XF86RandRInfoPtr randrp;
    ScrnInfoPtr scrp = xf86ScreenToScrn(pScreen);

#ifdef PANORAMIX
    /* XXX disable RandR when using Xinerama */
    if (!noPanoramiXExtension)
        return TRUE;
#endif

    xf86RandRKey = &xf86RandRKeyRec;

    if (!dixRegisterPrivateKey(&xf86RandRKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    randrp = malloc(sizeof(XF86RandRInfoRec));
    if (!randrp)
        return FALSE;

    if (!RRScreenInit(pScreen)) {
        free(randrp);
        return FALSE;
    }
    rp = rrGetScrPriv(pScreen);
    rp->rrGetInfo = xf86RandRGetInfo;
    rp->rrSetConfig = xf86RandRSetConfig;

    randrp->virtualX = scrp->virtualX;
    randrp->virtualY = scrp->virtualY;
    randrp->mmWidth = pScreen->mmWidth;
    randrp->mmHeight = pScreen->mmHeight;

    randrp->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = xf86RandRCloseScreen;

    randrp->rotation = RR_Rotate_0;

    dixSetPrivate(&pScreen->devPrivates, xf86RandRKey, randrp);
    return TRUE;
}
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a39 1
    CreateScreenResourcesProcPtr CreateScreenResources;
a337 28
 * Wait until the screen is initialized before whacking the
 * sizes around; otherwise the screen pixmap will be allocated
 * at the current mode size rather than the maximum size
 */
static Bool
xf86RandRCreateScreenResources(ScreenPtr pScreen)
{
    XF86RandRInfoPtr randrp = XF86RANDRINFO(pScreen);

#if 0
    ScrnInfoPtr scrp = xf86ScreenToScrn(pScreen);
    DisplayModePtr mode;
#endif

    pScreen->CreateScreenResources = randrp->CreateScreenResources;
    if (!(*pScreen->CreateScreenResources) (pScreen))
        return FALSE;

#if 0
    mode = scrp->currentMode;
    if (mode)
        xf86RandRSetMode(pScreen, mode, TRUE);
#endif

    return TRUE;
}

/*
a435 3

    randrp->CreateScreenResources = pScreen->CreateScreenResources;
    pScreen->CreateScreenResources = xf86RandRCreateScreenResources;
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d217 9
a225 7
    /*
     * Make sure the whole screen is visible
     */
    xf86SetViewport(pScreen, pScreen->width, pScreen->height);
    xf86SetViewport(pScreen, 0, 0);
    if (pRoot && scrp->vtSema)
        (*scrp->EnableDisableFBAccess) (scrp, TRUE);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d69 1
a69 1
    ScrnInfoPtr scrp = XF86SCRNINFO(pScreen);
d150 1
a150 1
    ScrnInfoPtr scrp = XF86SCRNINFO(pScreen);
d162 1
a162 1
        (*scrp->EnableDisableFBAccess) (pScreen->myNum, FALSE);
d223 1
a223 1
        (*scrp->EnableDisableFBAccess) (pScreen->myNum, TRUE);
d231 1
a231 1
    ScrnInfoPtr scrp = XF86SCRNINFO(pScreen);
d347 1
a347 1
    ScrnInfoPtr scrp = XF86SCRNINFO(pScreen);
d368 1
a368 1
xf86RandRCloseScreen(int index, ScreenPtr pScreen)
d370 1
a370 1
    ScrnInfoPtr scrp = XF86SCRNINFO(pScreen);
d379 1
a379 1
    return (*pScreen->CloseScreen) (index, pScreen);
d420 1
d422 1
a422 1
                                 XF86SCRNINFO(pScreen)->currentMode,
d434 1
a434 1
    ScrnInfoPtr scrp = XF86SCRNINFO(pScreen);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d40 7
a46 7
    CreateScreenResourcesProcPtr    CreateScreenResources;
    CloseScreenProcPtr		    CloseScreen;
    int				    virtualX;
    int				    virtualY;
    int				    mmWidth;
    int				    mmHeight;
    Rotation			    rotation;
d55 1
a55 1
xf86RandRModeRefresh (DisplayModePtr mode)
d58 1
a58 1
	return (int) (mode->VRefresh + 0.5);
d60 1
a60 1
	return 0;
d62 1
a62 1
	return (int) (mode->Clock * 1000.0 / mode->HTotal / mode->VTotal + 0.5);
d66 1
a66 1
xf86RandRGetInfo (ScreenPtr pScreen, Rotation *rotations)
d68 6
a73 6
    RRScreenSizePtr	    pSize;
    ScrnInfoPtr		    scrp = XF86SCRNINFO(pScreen);
    XF86RandRInfoPtr	    randrp = XF86RANDRINFO(pScreen);
    DisplayModePtr	    mode;
    int			    refresh0 = 60;
    xorgRRModeMM	    RRModeMM;
d77 28
a104 28
    for (mode = scrp->modes; mode != NULL ; mode = mode->next)
    {
	int refresh = xf86RandRModeRefresh (mode);

	if (mode == scrp->modes)
	    refresh0 = refresh;

	RRModeMM.mode = mode;
	RRModeMM.virtX = randrp->virtualX;
	RRModeMM.virtY = randrp->virtualY;
	RRModeMM.mmWidth = randrp->mmWidth;
	RRModeMM.mmHeight = randrp->mmHeight;

	if(scrp->DriverFunc) {
	   (*scrp->DriverFunc)(scrp, RR_GET_MODE_MM, &RRModeMM);
	}

	pSize = RRRegisterSize (pScreen,
				mode->HDisplay, mode->VDisplay,
				RRModeMM.mmWidth, RRModeMM.mmHeight);
	if (!pSize)
	    return FALSE;
	RRRegisterRate (pScreen, pSize, refresh);
	if (mode == scrp->currentMode &&
	    mode->HDisplay == scrp->virtualX && mode->VDisplay == scrp->virtualY)
	    RRSetCurrentConfig (pScreen, randrp->rotation, refresh, pSize);
	if (mode->next == scrp->modes)
	    break;
d107 23
a129 25
	scrp->currentMode->VDisplay != randrp->virtualY)
    {
	mode = scrp->modes;

	RRModeMM.mode = NULL;
	RRModeMM.virtX = randrp->virtualX;
	RRModeMM.virtY = randrp->virtualY;
	RRModeMM.mmWidth = randrp->mmWidth;
	RRModeMM.mmHeight = randrp->mmHeight;

	if(scrp->DriverFunc) {
	   (*scrp->DriverFunc)(scrp, RR_GET_MODE_MM, &RRModeMM);
	}

	pSize = RRRegisterSize (pScreen,
				randrp->virtualX, randrp->virtualY,
				RRModeMM.mmWidth, RRModeMM.mmHeight);
	if (!pSize)
	    return FALSE;
	RRRegisterRate (pScreen, pSize, refresh0);
	if (scrp->virtualX == randrp->virtualX &&
	    scrp->virtualY == randrp->virtualY)
	{
	    RRSetCurrentConfig (pScreen, randrp->rotation, refresh0, pSize);
	}
d133 2
a134 2
    if(scrp->DriverFunc) {
	xorgRRRotation RRRotation;
d136 4
a139 4
	RRRotation.RRRotations = *rotations;
	if (!(*scrp->DriverFunc)(scrp, RR_GET_INFO, &RRRotation))
	    return TRUE;
	*rotations = RRRotation.RRRotations;
d146 3
a148 5
xf86RandRSetMode (ScreenPtr	    pScreen,
		  DisplayModePtr    mode,
		  Bool		    useVirtual,
		  int		    mmWidth,
		  int		    mmHeight)
d150 10
a159 10
    ScrnInfoPtr		scrp = XF86SCRNINFO(pScreen);
    XF86RandRInfoPtr	randrp = XF86RANDRINFO(pScreen);
    int			oldWidth = pScreen->width;
    int			oldHeight = pScreen->height;
    int			oldmmWidth = pScreen->mmWidth;
    int			oldmmHeight = pScreen->mmHeight;
    int			oldVirtualX = scrp->virtualX;
    int			oldVirtualY = scrp->virtualY;
    WindowPtr		pRoot = pScreen->root;
    Bool		ret = TRUE;
d162 8
a169 10
	(*scrp->EnableDisableFBAccess) (pScreen->myNum, FALSE);
    if (useVirtual)
    {
	scrp->virtualX = randrp->virtualX;
	scrp->virtualY = randrp->virtualY;
    }
    else
    {
	scrp->virtualX = mode->HDisplay;
	scrp->virtualY = mode->VDisplay;
d176 2
a177 2
    if(scrp->DriverFunc) {
	xorgRRModeMM RRModeMM;
d179 32
a210 35
	RRModeMM.mode = mode;
	RRModeMM.virtX = scrp->virtualX;
	RRModeMM.virtY = scrp->virtualY;
	RRModeMM.mmWidth = mmWidth;
	RRModeMM.mmHeight = mmHeight;

	(*scrp->DriverFunc)(scrp, RR_GET_MODE_MM, &RRModeMM);

	mmWidth = RRModeMM.mmWidth;
	mmHeight = RRModeMM.mmHeight;
    }
    if(randrp->rotation & (RR_Rotate_90 | RR_Rotate_270))
    {
	/* If the screen is rotated 90 or 270 degrees, swap the sizes. */
	pScreen->width = scrp->virtualY;
	pScreen->height = scrp->virtualX;
	pScreen->mmWidth = mmHeight;
	pScreen->mmHeight = mmWidth;
    }
    else
    {
	pScreen->width = scrp->virtualX;
	pScreen->height = scrp->virtualY;
	pScreen->mmWidth = mmWidth;
	pScreen->mmHeight = mmHeight;
    }
    if (!xf86SwitchMode (pScreen, mode))
    {
	pScreen->width = oldWidth;
	pScreen->height = oldHeight;
	pScreen->mmWidth = oldmmWidth;
	pScreen->mmHeight = oldmmHeight;
	scrp->virtualX = oldVirtualX;
	scrp->virtualY = oldVirtualY;
	ret = FALSE;
d220 2
a221 2
    xf86SetViewport (pScreen, pScreen->width, pScreen->height);
    xf86SetViewport (pScreen, 0, 0);
d223 1
a223 1
	(*scrp->EnableDisableFBAccess) (pScreen->myNum, TRUE);
d228 2
a229 4
xf86RandRSetConfig (ScreenPtr		pScreen,
		    Rotation		rotation,
		    int			rate,
		    RRScreenSizePtr	pSize)
d231 30
a260 34
    ScrnInfoPtr		    scrp = XF86SCRNINFO(pScreen);
    XF86RandRInfoPtr	    randrp = XF86RANDRINFO(pScreen);
    DisplayModePtr	    mode;
    int			    pos[MAXDEVICES][2];
    Bool		    useVirtual = FALSE;
    Rotation		    oldRotation = randrp->rotation;
    DeviceIntPtr	    dev;
    Bool		    view_adjusted = FALSE;

    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
	if (!IsMaster(dev) && !IsFloating(dev))
		continue;

	miPointerGetPosition(dev, &pos[dev->id][0], &pos[dev->id][1]);
    }

    for (mode = scrp->modes; ; mode = mode->next)
    {
	if (mode->HDisplay == pSize->width &&
	    mode->VDisplay == pSize->height &&
	    (rate == 0 || xf86RandRModeRefresh (mode) == rate))
	    break;
	if (mode->next == scrp->modes)
	{
	    if (pSize->width == randrp->virtualX &&
		pSize->height == randrp->virtualY)
	    {
		mode = scrp->modes;
		useVirtual = TRUE;
		break;
	    }
	    return FALSE;
	}
d266 38
a303 33
	if (scrp->DriverFunc) {
	    xorgRRRotation RRRotation;
	    RRRotation.RRConfig.rotation = rotation;
	    RRRotation.RRConfig.rate = rate;
	    RRRotation.RRConfig.width = pSize->width;
	    RRRotation.RRConfig.height = pSize->height;

	    /*
	     * Currently we need to rely on HW support for rotation.
	     */
	    if (!(*scrp->DriverFunc)(scrp, RR_SET_CONFIG, &RRRotation))
		return FALSE;
	} else
	    return FALSE;

	randrp->rotation = rotation;
    }

    if (!xf86RandRSetMode (pScreen, mode, useVirtual, pSize->mmWidth, pSize->mmHeight)) {
	if(randrp->rotation != oldRotation) {
	   /* Have the driver undo its thing. */
	   if (scrp->DriverFunc) {
	       xorgRRRotation RRRotation;
	       RRRotation.RRConfig.rotation = oldRotation;
	       RRRotation.RRConfig.rate = xf86RandRModeRefresh (scrp->currentMode);
	       RRRotation.RRConfig.width = scrp->virtualX;
	       RRRotation.RRConfig.height = scrp->virtualY;
	       (*scrp->DriverFunc)(scrp, RR_SET_CONFIG, &RRRotation);
	   }

	   randrp->rotation = oldRotation;
	}
	return FALSE;
d306 2
d312 16
a327 17
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
	if (!IsMaster(dev) && !IsFloating(dev))
		continue;

	if (pScreen == miPointerGetScreen(dev)) {
	    int px = pos[dev->id][0];
	    int py = pos[dev->id][1];

	    px = (px >= pScreen->width ? (pScreen->width - 1) : px);
	    py = (py >= pScreen->height ? (pScreen->height - 1) : py);

	    /* Setting the viewpoint makes only sense on one device */
	    if (!view_adjusted && IsMaster(dev)) {
		xf86SetViewport(pScreen, px, py);
		view_adjusted = TRUE;
	    }
d329 2
a330 2
	    (*pScreen->SetCursorPosition) (dev, pScreen, px, py, FALSE);
	}
d342 1
a342 1
xf86RandRCreateScreenResources (ScreenPtr pScreen)
d344 2
a345 1
    XF86RandRInfoPtr	    randrp = XF86RANDRINFO(pScreen);
d347 2
a348 2
    ScrnInfoPtr		    scrp = XF86SCRNINFO(pScreen);
    DisplayModePtr	    mode;
d353 1
a353 1
	return FALSE;
d358 1
a358 1
	xf86RandRSetMode (pScreen, mode, TRUE);
d368 1
a368 1
xf86RandRCloseScreen (int index, ScreenPtr pScreen)
d370 2
a371 2
    ScrnInfoPtr		    scrp = XF86SCRNINFO(pScreen);
    XF86RandRInfoPtr	    randrp = XF86RANDRINFO(pScreen);
d386 1
a386 1
       return RR_Rotate_0;
d394 2
a395 2
	int newvirtX, int newvirtY, int newmmWidth, int newmmHeight,
	Bool resetMode)
d400 1
a400 1
	return FALSE;
d404 1
a404 1
	return FALSE;
d407 1
a407 1
	randrp->virtualX = newvirtX;
d410 1
a410 1
	randrp->virtualY = newvirtY;
d413 1
a413 1
	randrp->mmWidth = newmmWidth;
d416 1
a416 1
	randrp->mmHeight = newmmHeight;
d420 3
a422 4
	return (xf86RandRSetMode(pScreen,
		  XF86SCRNINFO(pScreen)->currentMode,
		  TRUE,
		  pScreen->mmWidth, pScreen->mmHeight));
d429 1
a429 1
xf86RandRInit (ScreenPtr    pScreen)
d431 3
a433 3
    rrScrPrivPtr	rp;
    XF86RandRInfoPtr	randrp;
    ScrnInfoPtr		scrp = XF86SCRNINFO(pScreen);
d438 1
a438 1
	return TRUE;
d444 1
a444 1
	return FALSE;
d446 1
a446 1
    randrp = malloc(sizeof (XF86RandRInfoRec));
d448 1
a448 1
	return FALSE;
d450 3
a452 4
    if (!RRScreenInit (pScreen))
    {
	free(randrp);
	return FALSE;
a473 2


@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d245 1
a245 1
    int			    px, py;
d248 10
a258 1
    miPointerGetPosition(inputInfo.pointer, &px, &py);
d315 1
d318 1
d320 1
a320 1
    if (pScreen == miPointerCurrentScreen ())
d322 2
a323 2
	px = (px >= pScreen->width ? (pScreen->width - 1) : px);
	py = (py >= pScreen->height ? (pScreen->height - 1) : py);
d325 12
a336 1
        xf86SetViewport(pScreen, px, py);
d338 2
a339 1
        (*pScreen->SetCursorPosition) (inputInfo.pointer, pScreen, px, py, FALSE);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a29 1
#include "mibank.h"
d49 1
a49 1
static int xf86RandRKeyIndex;
d162 1
a162 1
    WindowPtr		pRoot = WindowTable[pScreen->myNum];
d362 1
a362 1
    xfree (randrp);
d427 1
a427 1
    xf86RandRKey = &xf86RandRKeyIndex;
d429 4
a432 1
    randrp = xalloc (sizeof (XF86RandRInfoRec));
d438 1
a438 1
	xfree (randrp);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d33 1
d166 1
a166 1
    if (pRoot)
d232 1
a232 1
    if (pRoot)
d368 1
a368 1
_X_EXPORT Rotation
d378 1
a378 1
_X_EXPORT Bool
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d37 1
d49 2
a50 1
static DevPrivateKey xf86RandRKey = NULL;
d77 1
a77 1
    for (mode = scrp->modes; ; mode = mode->next)
d249 1
a249 1
    miPointerPosition (&px, &py);
d316 1
a316 1
        (*pScreen->SetCursorPosition) (pScreen, px, py, FALSE);
d427 1
a427 1
    xf86RandRKey = &xf86RandRKey;
@


1.1
log
@Initial revision
@
text
@d48 1
a48 2
static int	    xf86RandRIndex = -1;
static int	    xf86RandRGeneration;
d50 1
a50 1
#define XF86RANDRINFO(p)    ((XF86RandRInfoPtr) (p)->devPrivates[xf86RandRIndex].ptr)
d57 2
d175 19
d361 1
a361 1
    pScreen->devPrivates[xf86RandRIndex].ptr = 0;
d368 1
a368 1
    if (xf86RandRIndex == -1)
d382 1
a382 1
    if (xf86RandRIndex == -1)
d424 2
a425 5
    if (xf86RandRGeneration != serverGeneration)
    {
	xf86RandRIndex = AllocateScreenPrivateIndex();
	xf86RandRGeneration = serverGeneration;
    }
d453 1
a453 1
    pScreen->devPrivates[xf86RandRIndex].ptr = randrp;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
