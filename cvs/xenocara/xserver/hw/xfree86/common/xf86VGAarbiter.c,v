head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.6
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 * This code was stolen from RAC and adapted to control the legacy vga
 * interface.
 *
 *
 * Copyright (c) 2007 Paulo R. Zanoni, Tiago Vignatti
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "xorg-config.h"

#include "xf86VGAarbiter.h"
#include "xf86VGAarbiterPriv.h"
#include "xf86Bus.h"
#include "xf86Priv.h"
#include "pciaccess.h"

static GCFuncs VGAarbiterGCFuncs = {
    VGAarbiterValidateGC, VGAarbiterChangeGC, VGAarbiterCopyGC,
    VGAarbiterDestroyGC, VGAarbiterChangeClip, VGAarbiterDestroyClip,
    VGAarbiterCopyClip
};

static GCOps VGAarbiterGCOps = {
    VGAarbiterFillSpans, VGAarbiterSetSpans, VGAarbiterPutImage,
    VGAarbiterCopyArea, VGAarbiterCopyPlane, VGAarbiterPolyPoint,
    VGAarbiterPolylines, VGAarbiterPolySegment, VGAarbiterPolyRectangle,
    VGAarbiterPolyArc, VGAarbiterFillPolygon, VGAarbiterPolyFillRect,
    VGAarbiterPolyFillArc, VGAarbiterPolyText8, VGAarbiterPolyText16,
    VGAarbiterImageText8, VGAarbiterImageText16, VGAarbiterImageGlyphBlt,
    VGAarbiterPolyGlyphBlt, VGAarbiterPushPixels,
};

static miPointerSpriteFuncRec VGAarbiterSpriteFuncs = {
    VGAarbiterSpriteRealizeCursor, VGAarbiterSpriteUnrealizeCursor,
    VGAarbiterSpriteSetCursor, VGAarbiterSpriteMoveCursor,
    VGAarbiterDeviceCursorInitialize, VGAarbiterDeviceCursorCleanup
};

static DevPrivateKeyRec VGAarbiterScreenKeyRec;

#define VGAarbiterScreenKey (&VGAarbiterScreenKeyRec)
static DevPrivateKeyRec VGAarbiterGCKeyRec;

#define VGAarbiterGCKey (&VGAarbiterGCKeyRec)

static int vga_no_arb = 0;
void
xf86VGAarbiterInit(void)
{
    if (pci_device_vgaarb_init() != 0) {
        vga_no_arb = 1;
        xf86Msg(X_WARNING,
                "VGA arbiter: cannot open kernel arbiter, no multi-card support\n");
    }
}

void
xf86VGAarbiterFini(void)
{
    if (vga_no_arb)
        return;
    pci_device_vgaarb_fini();
}

void
xf86VGAarbiterLock(ScrnInfoPtr pScrn)
{
    if (vga_no_arb)
        return;
    pci_device_vgaarb_set_target(pScrn->vgaDev);
    pci_device_vgaarb_lock();
}

void
xf86VGAarbiterUnlock(ScrnInfoPtr pScrn)
{
    if (vga_no_arb)
        return;
    pci_device_vgaarb_unlock();
}

Bool
xf86VGAarbiterAllowDRI(ScreenPtr pScreen)
{
    int vga_count;
    int rsrc_decodes;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);

    if (vga_no_arb)
        return TRUE;

    pci_device_vgaarb_get_info(pScrn->vgaDev, &vga_count, &rsrc_decodes);
    if (vga_count > 1) {
        if (rsrc_decodes) {
            return FALSE;
        }
    }
    return TRUE;
}

void
xf86VGAarbiterScrnInit(ScrnInfoPtr pScrn)
{
    struct pci_device *dev;
    EntityPtr pEnt;

    if (vga_no_arb)
        return;

    pEnt = xf86Entities[pScrn->entityList[0]];
    if (pEnt->bus.type != BUS_PCI)
        return;

    dev = pEnt->bus.id.pci;
    pScrn->vgaDev = dev;
}

void
xf86VGAarbiterDeviceDecodes(ScrnInfoPtr pScrn, int rsrc)
{
    if (vga_no_arb)
        return;
    pci_device_vgaarb_set_target(pScrn->vgaDev);
    pci_device_vgaarb_decodes(rsrc);
}

Bool
xf86VGAarbiterWrapFunctions(void)
{
    ScrnInfoPtr pScrn;
    VGAarbiterScreenPtr pScreenPriv;
    miPointerScreenPtr PointPriv;
    PictureScreenPtr ps;
    ScreenPtr pScreen;
    int vga_count, i;

    if (vga_no_arb)
        return FALSE;

    /*
     * we need to wrap the arbiter if we have more than
     * one VGA card - hotplug cries.
     */
    pci_device_vgaarb_get_info(NULL, &vga_count, NULL);
    if (vga_count < 2 || !xf86Screens)
        return FALSE;

    xf86Msg(X_INFO, "Found %d VGA devices: arbiter wrapping enabled\n",
            vga_count);

    for (i = 0; i < xf86NumScreens; i++) {
        pScreen = xf86Screens[i]->pScreen;
        ps = GetPictureScreenIfSet(pScreen);
        pScrn = xf86ScreenToScrn(pScreen);
        PointPriv = dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);

        if (!dixRegisterPrivateKey
            (&VGAarbiterGCKeyRec, PRIVATE_GC, sizeof(VGAarbiterGCRec)))
            return FALSE;

        if (!dixRegisterPrivateKey(&VGAarbiterScreenKeyRec, PRIVATE_SCREEN, 0))
            return FALSE;

        if (!(pScreenPriv = malloc(sizeof(VGAarbiterScreenRec))))
            return FALSE;

        dixSetPrivate(&pScreen->devPrivates, VGAarbiterScreenKey, pScreenPriv);

        WRAP_SCREEN(CloseScreen, VGAarbiterCloseScreen);
        WRAP_SCREEN(SaveScreen, VGAarbiterSaveScreen);
        WRAP_SCREEN(WakeupHandler, VGAarbiterWakeupHandler);
        WRAP_SCREEN(BlockHandler, VGAarbiterBlockHandler);
        WRAP_SCREEN(CreateGC, VGAarbiterCreateGC);
        WRAP_SCREEN(GetImage, VGAarbiterGetImage);
        WRAP_SCREEN(GetSpans, VGAarbiterGetSpans);
        WRAP_SCREEN(SourceValidate, VGAarbiterSourceValidate);
        WRAP_SCREEN(CopyWindow, VGAarbiterCopyWindow);
        WRAP_SCREEN(ClearToBackground, VGAarbiterClearToBackground);
        WRAP_SCREEN(CreatePixmap, VGAarbiterCreatePixmap);
        WRAP_SCREEN(StoreColors, VGAarbiterStoreColors);
        WRAP_SCREEN(DisplayCursor, VGAarbiterDisplayCursor);
        WRAP_SCREEN(RealizeCursor, VGAarbiterRealizeCursor);
        WRAP_SCREEN(UnrealizeCursor, VGAarbiterUnrealizeCursor);
        WRAP_SCREEN(RecolorCursor, VGAarbiterRecolorCursor);
        WRAP_SCREEN(SetCursorPosition, VGAarbiterSetCursorPosition);
        WRAP_PICT(Composite, VGAarbiterComposite);
        WRAP_PICT(Glyphs, VGAarbiterGlyphs);
        WRAP_PICT(CompositeRects, VGAarbiterCompositeRects);
        WRAP_SCREEN_INFO(AdjustFrame, VGAarbiterAdjustFrame);
        WRAP_SCREEN_INFO(SwitchMode, VGAarbiterSwitchMode);
        WRAP_SCREEN_INFO(EnterVT, VGAarbiterEnterVT);
        WRAP_SCREEN_INFO(LeaveVT, VGAarbiterLeaveVT);
        WRAP_SCREEN_INFO(FreeScreen, VGAarbiterFreeScreen);
        WRAP_SPRITE;
    }

    return TRUE;
}

/* Screen funcs */
static Bool
VGAarbiterCloseScreen(ScreenPtr pScreen)
{
    Bool val;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    VGAarbiterScreenPtr pScreenPriv =
        (VGAarbiterScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               VGAarbiterScreenKey);
    miPointerScreenPtr PointPriv =
        (miPointerScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                              miPointerScreenKey);
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    UNWRAP_SCREEN(CreateGC);
    UNWRAP_SCREEN(CloseScreen);
    UNWRAP_SCREEN(GetImage);
    UNWRAP_SCREEN(GetSpans);
    UNWRAP_SCREEN(SourceValidate);
    UNWRAP_SCREEN(CopyWindow);
    UNWRAP_SCREEN(ClearToBackground);
    UNWRAP_SCREEN(SaveScreen);
    UNWRAP_SCREEN(StoreColors);
    UNWRAP_SCREEN(DisplayCursor);
    UNWRAP_SCREEN(RealizeCursor);
    UNWRAP_SCREEN(UnrealizeCursor);
    UNWRAP_SCREEN(RecolorCursor);
    UNWRAP_SCREEN(SetCursorPosition);
    UNWRAP_PICT(Composite);
    UNWRAP_PICT(Glyphs);
    UNWRAP_PICT(CompositeRects);
    UNWRAP_SCREEN_INFO(AdjustFrame);
    UNWRAP_SCREEN_INFO(SwitchMode);
    UNWRAP_SCREEN_INFO(EnterVT);
    UNWRAP_SCREEN_INFO(LeaveVT);
    UNWRAP_SCREEN_INFO(FreeScreen);
    UNWRAP_SPRITE;

    free((void *) pScreenPriv);
    xf86VGAarbiterLock(xf86ScreenToScrn(pScreen));
    val = (*pScreen->CloseScreen) (pScreen);
    xf86VGAarbiterUnlock(xf86ScreenToScrn(pScreen));
    return val;
}

static void
VGAarbiterBlockHandler(ScreenPtr pScreen,
                       void *pTimeout, void *pReadmask)
{
    SCREEN_PROLOG(BlockHandler);
    VGAGet(pScreen);
    pScreen->BlockHandler(pScreen, pTimeout, pReadmask);
    VGAPut();
    SCREEN_EPILOG(BlockHandler, VGAarbiterBlockHandler);
}

static void
VGAarbiterWakeupHandler(ScreenPtr pScreen, unsigned long result,
                        void *pReadmask)
{
    SCREEN_PROLOG(WakeupHandler);
    VGAGet(pScreen);
    pScreen->WakeupHandler(pScreen, result, pReadmask);
    VGAPut();
    SCREEN_EPILOG(WakeupHandler, VGAarbiterWakeupHandler);
}

static void
VGAarbiterGetImage(DrawablePtr pDrawable,
                   int sx, int sy, int w, int h,
                   unsigned int format, unsigned long planemask, char *pdstLine)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    SCREEN_PROLOG(GetImage);
    VGAGet(pScreen);
    (*pScreen->GetImage) (pDrawable, sx, sy, w, h, format, planemask, pdstLine);
    VGAPut();
    SCREEN_EPILOG(GetImage, VGAarbiterGetImage);
}

static void
VGAarbiterGetSpans(DrawablePtr pDrawable,
                   int wMax,
                   DDXPointPtr ppt, int *pwidth, int nspans, char *pdstStart)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    SCREEN_PROLOG(GetSpans);
    VGAGet(pScreen);
    (*pScreen->GetSpans) (pDrawable, wMax, ppt, pwidth, nspans, pdstStart);
    VGAPut();
    SCREEN_EPILOG(GetSpans, VGAarbiterGetSpans);
}

static void
VGAarbiterSourceValidate(DrawablePtr pDrawable,
                         int x, int y, int width, int height,
                         unsigned int subWindowMode)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    SCREEN_PROLOG(SourceValidate);
    VGAGet(pScreen);
    if (pScreen->SourceValidate)
        (*pScreen->SourceValidate) (pDrawable, x, y, width, height,
                                    subWindowMode);
    VGAPut();
    SCREEN_EPILOG(SourceValidate, VGAarbiterSourceValidate);
}

static void
VGAarbiterCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    SCREEN_PROLOG(CopyWindow);
    VGAGet(pScreen);
    (*pScreen->CopyWindow) (pWin, ptOldOrg, prgnSrc);
    VGAPut();
    SCREEN_EPILOG(CopyWindow, VGAarbiterCopyWindow);
}

static void
VGAarbiterClearToBackground(WindowPtr pWin,
                            int x, int y, int w, int h, Bool generateExposures)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    SCREEN_PROLOG(ClearToBackground);
    VGAGet(pScreen);
    (*pScreen->ClearToBackground) (pWin, x, y, w, h, generateExposures);
    VGAPut();
    SCREEN_EPILOG(ClearToBackground, VGAarbiterClearToBackground);
}

static PixmapPtr
VGAarbiterCreatePixmap(ScreenPtr pScreen, int w, int h, int depth,
                       unsigned usage_hint)
{
    PixmapPtr pPix;

    SCREEN_PROLOG(CreatePixmap);
    VGAGet(pScreen);
    pPix = (*pScreen->CreatePixmap) (pScreen, w, h, depth, usage_hint);
    VGAPut();
    SCREEN_EPILOG(CreatePixmap, VGAarbiterCreatePixmap);

    return pPix;
}

static Bool
VGAarbiterSaveScreen(ScreenPtr pScreen, Bool unblank)
{
    Bool val;

    SCREEN_PROLOG(SaveScreen);
    VGAGet(pScreen);
    val = (*pScreen->SaveScreen) (pScreen, unblank);
    VGAPut();
    SCREEN_EPILOG(SaveScreen, VGAarbiterSaveScreen);

    return val;
}

static void
VGAarbiterStoreColors(ColormapPtr pmap, int ndef, xColorItem * pdefs)
{
    ScreenPtr pScreen = pmap->pScreen;

    SCREEN_PROLOG(StoreColors);
    VGAGet(pScreen);
    (*pScreen->StoreColors) (pmap, ndef, pdefs);
    VGAPut();
    SCREEN_EPILOG(StoreColors, VGAarbiterStoreColors);
}

static void
VGAarbiterRecolorCursor(DeviceIntPtr pDev,
                        ScreenPtr pScreen, CursorPtr pCurs, Bool displayed)
{
    SCREEN_PROLOG(RecolorCursor);
    VGAGet(pScreen);
    (*pScreen->RecolorCursor) (pDev, pScreen, pCurs, displayed);
    VGAPut();
    SCREEN_EPILOG(RecolorCursor, VGAarbiterRecolorCursor);
}

static Bool
VGAarbiterRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    Bool val;

    SCREEN_PROLOG(RealizeCursor);
    VGAGet(pScreen);
    val = (*pScreen->RealizeCursor) (pDev, pScreen, pCursor);
    VGAPut();
    SCREEN_EPILOG(RealizeCursor, VGAarbiterRealizeCursor);
    return val;
}

static Bool
VGAarbiterUnrealizeCursor(DeviceIntPtr pDev,
                          ScreenPtr pScreen, CursorPtr pCursor)
{
    Bool val;

    SCREEN_PROLOG(UnrealizeCursor);
    VGAGet(pScreen);
    val = (*pScreen->UnrealizeCursor) (pDev, pScreen, pCursor);
    VGAPut();
    SCREEN_EPILOG(UnrealizeCursor, VGAarbiterUnrealizeCursor);
    return val;
}

static Bool
VGAarbiterDisplayCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    Bool val;

    SCREEN_PROLOG(DisplayCursor);
    VGAGet(pScreen);
    val = (*pScreen->DisplayCursor) (pDev, pScreen, pCursor);
    VGAPut();
    SCREEN_EPILOG(DisplayCursor, VGAarbiterDisplayCursor);
    return val;
}

static Bool
VGAarbiterSetCursorPosition(DeviceIntPtr pDev,
                            ScreenPtr pScreen, int x, int y, Bool generateEvent)
{
    Bool val;

    SCREEN_PROLOG(SetCursorPosition);
    VGAGet(pScreen);
    val = (*pScreen->SetCursorPosition) (pDev, pScreen, x, y, generateEvent);
    VGAPut();
    SCREEN_EPILOG(SetCursorPosition, VGAarbiterSetCursorPosition);
    return val;
}

static void
VGAarbiterAdjustFrame(ScrnInfoPtr pScrn, int x, int y)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    VGAarbiterScreenPtr pScreenPriv =
        (VGAarbiterScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               VGAarbiterScreenKey);

    VGAGet(pScreen);
    (*pScreenPriv->AdjustFrame) (pScrn, x, y);
    VGAPut();
}

static Bool
VGAarbiterSwitchMode(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    Bool val;
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    VGAarbiterScreenPtr pScreenPriv =
        (VGAarbiterScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               VGAarbiterScreenKey);

    VGAGet(pScreen);
    val = (*pScreenPriv->SwitchMode) (pScrn, mode);
    VGAPut();
    return val;
}

static Bool
VGAarbiterEnterVT(ScrnInfoPtr pScrn)
{
    Bool val;
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    VGAarbiterScreenPtr pScreenPriv =
        (VGAarbiterScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               VGAarbiterScreenKey);

    VGAGet(pScreen);
    pScrn->EnterVT = pScreenPriv->EnterVT;
    val = (*pScrn->EnterVT) (pScrn);
    pScreenPriv->EnterVT = pScrn->EnterVT;
    pScrn->EnterVT = VGAarbiterEnterVT;
    VGAPut();
    return val;
}

static void
VGAarbiterLeaveVT(ScrnInfoPtr pScrn)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    VGAarbiterScreenPtr pScreenPriv =
        (VGAarbiterScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               VGAarbiterScreenKey);

    VGAGet(pScreen);
    pScrn->LeaveVT = pScreenPriv->LeaveVT;
    (*pScreenPriv->LeaveVT) (pScrn);
    pScreenPriv->LeaveVT = pScrn->LeaveVT;
    pScrn->LeaveVT = VGAarbiterLeaveVT;
    VGAPut();
}

static void
VGAarbiterFreeScreen(ScrnInfoPtr pScrn)
{
    ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
    VGAarbiterScreenPtr pScreenPriv =
        (VGAarbiterScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                               VGAarbiterScreenKey);

    VGAGet(pScreen);
    (*pScreenPriv->FreeScreen) (pScrn);
    VGAPut();
}

static Bool
VGAarbiterCreateGC(GCPtr pGC)
{
    ScreenPtr pScreen = pGC->pScreen;
    VGAarbiterGCPtr pGCPriv =
        (VGAarbiterGCPtr) dixLookupPrivate(&pGC->devPrivates, VGAarbiterGCKey);
    Bool ret;

    SCREEN_PROLOG(CreateGC);
    ret = (*pScreen->CreateGC) (pGC);
    GC_WRAP(pGC);
    SCREEN_EPILOG(CreateGC, VGAarbiterCreateGC);

    return ret;
}

/* GC funcs */
static void
VGAarbiterValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
{
    GC_UNWRAP(pGC);
    (*pGC->funcs->ValidateGC) (pGC, changes, pDraw);
    GC_WRAP(pGC);
}

static void
VGAarbiterDestroyGC(GCPtr pGC)
{
    GC_UNWRAP(pGC);
    (*pGC->funcs->DestroyGC) (pGC);
    GC_WRAP(pGC);
}

static void
VGAarbiterChangeGC(GCPtr pGC, unsigned long mask)
{
    GC_UNWRAP(pGC);
    (*pGC->funcs->ChangeGC) (pGC, mask);
    GC_WRAP(pGC);
}

static void
VGAarbiterCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
{
    GC_UNWRAP(pGCDst);
    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
    GC_WRAP(pGCDst);
}

static void
VGAarbiterChangeClip(GCPtr pGC, int type, void *pvalue, int nrects)
{
    GC_UNWRAP(pGC);
    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
    GC_WRAP(pGC);
}

static void
VGAarbiterCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    GC_UNWRAP(pgcDst);
    (*pgcDst->funcs->CopyClip) (pgcDst, pgcSrc);
    GC_WRAP(pgcDst);
}

static void
VGAarbiterDestroyClip(GCPtr pGC)
{
    GC_UNWRAP(pGC);
    (*pGC->funcs->DestroyClip) (pGC);
    GC_WRAP(pGC);
}

/* GC Ops */
static void
VGAarbiterFillSpans(DrawablePtr pDraw,
                    GC * pGC,
                    int nInit,
                    DDXPointPtr pptInit, int *pwidthInit, int fSorted)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->FillSpans) (pDraw, pGC, nInit, pptInit, pwidthInit, fSorted);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterSetSpans(DrawablePtr pDraw,
                   GCPtr pGC,
                   char *pcharsrc,
                   register DDXPointPtr ppt,
                   int *pwidth, int nspans, int fSorted)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->SetSpans) (pDraw, pGC, pcharsrc, ppt, pwidth, nspans, fSorted);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterPutImage(DrawablePtr pDraw,
                   GCPtr pGC,
                   int depth,
                   int x, int y, int w, int h,
                   int leftPad, int format, char *pImage)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->PutImage) (pDraw, pGC, depth, x, y, w, h,
                           leftPad, format, pImage);
    VGAPut();
    GC_WRAP(pGC);
}

static RegionPtr
VGAarbiterCopyArea(DrawablePtr pSrc,
                   DrawablePtr pDst,
                   GC * pGC,
                   int srcx, int srcy,
                   int width, int height, int dstx, int dsty)
{
    RegionPtr ret;
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    ret = (*pGC->ops->CopyArea) (pSrc, pDst,
                                 pGC, srcx, srcy, width, height, dstx, dsty);
    VGAPut();
    GC_WRAP(pGC);
    return ret;
}

static RegionPtr
VGAarbiterCopyPlane(DrawablePtr pSrc,
                    DrawablePtr pDst,
                    GCPtr pGC,
                    int srcx, int srcy,
                    int width, int height,
                    int dstx, int dsty, unsigned long bitPlane)
{
    RegionPtr ret;
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    ret = (*pGC->ops->CopyPlane) (pSrc, pDst, pGC, srcx, srcy,
                                  width, height, dstx, dsty, bitPlane);
    VGAPut();
    GC_WRAP(pGC);
    return ret;
}

static void
VGAarbiterPolyPoint(DrawablePtr pDraw,
                    GCPtr pGC, int mode, int npt, xPoint * pptInit)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->PolyPoint) (pDraw, pGC, mode, npt, pptInit);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterPolylines(DrawablePtr pDraw,
                    GCPtr pGC, int mode, int npt, DDXPointPtr pptInit)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->Polylines) (pDraw, pGC, mode, npt, pptInit);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterPolySegment(DrawablePtr pDraw, GCPtr pGC, int nseg, xSegment * pSeg)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->PolySegment) (pDraw, pGC, nseg, pSeg);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterPolyRectangle(DrawablePtr pDraw,
                        GCPtr pGC, int nRectsInit, xRectangle *pRectsInit)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->PolyRectangle) (pDraw, pGC, nRectsInit, pRectsInit);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterPolyArc(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->PolyArc) (pDraw, pGC, narcs, parcs);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterFillPolygon(DrawablePtr pDraw,
                      GCPtr pGC,
                      int shape, int mode, int count, DDXPointPtr ptsIn)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->FillPolygon) (pDraw, pGC, shape, mode, count, ptsIn);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterPolyFillRect(DrawablePtr pDraw,
                       GCPtr pGC, int nrectFill, xRectangle *prectInit)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->PolyFillRect) (pDraw, pGC, nrectFill, prectInit);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterPolyFillArc(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->PolyFillArc) (pDraw, pGC, narcs, parcs);
    VGAPut();
    GC_WRAP(pGC);
}

static int
VGAarbiterPolyText8(DrawablePtr pDraw,
                    GCPtr pGC, int x, int y, int count, char *chars)
{
    int ret;
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    ret = (*pGC->ops->PolyText8) (pDraw, pGC, x, y, count, chars);
    VGAPut();
    GC_WRAP(pGC);
    return ret;
}

static int
VGAarbiterPolyText16(DrawablePtr pDraw,
                     GCPtr pGC, int x, int y, int count, unsigned short *chars)
{
    int ret;
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    ret = (*pGC->ops->PolyText16) (pDraw, pGC, x, y, count, chars);
    VGAPut();
    GC_WRAP(pGC);
    return ret;
}

static void
VGAarbiterImageText8(DrawablePtr pDraw,
                     GCPtr pGC, int x, int y, int count, char *chars)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->ImageText8) (pDraw, pGC, x, y, count, chars);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterImageText16(DrawablePtr pDraw,
                      GCPtr pGC, int x, int y, int count, unsigned short *chars)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->ImageText16) (pDraw, pGC, x, y, count, chars);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterImageGlyphBlt(DrawablePtr pDraw,
                        GCPtr pGC,
                        int xInit, int yInit,
                        unsigned int nglyph,
                        CharInfoPtr * ppci, void *pglyphBase)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->ImageGlyphBlt) (pDraw, pGC, xInit, yInit,
                                nglyph, ppci, pglyphBase);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterPolyGlyphBlt(DrawablePtr pDraw,
                       GCPtr pGC,
                       int xInit, int yInit,
                       unsigned int nglyph,
                       CharInfoPtr * ppci, void *pglyphBase)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->PolyGlyphBlt) (pDraw, pGC, xInit, yInit,
                               nglyph, ppci, pglyphBase);
    VGAPut();
    GC_WRAP(pGC);
}

static void
VGAarbiterPushPixels(GCPtr pGC,
                     PixmapPtr pBitMap,
                     DrawablePtr pDraw, int dx, int dy, int xOrg, int yOrg)
{
    ScreenPtr pScreen = pGC->pScreen;

    GC_UNWRAP(pGC);
    VGAGet(pScreen);
    (*pGC->ops->PushPixels) (pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);
    VGAPut();
    GC_WRAP(pGC);
}

/* miSpriteFuncs */
static Bool
VGAarbiterSpriteRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
                              CursorPtr pCur)
{
    Bool val;

    SPRITE_PROLOG;
    VGAGet(pScreen);
    val = PointPriv->spriteFuncs->RealizeCursor(pDev, pScreen, pCur);
    VGAPut();
    SPRITE_EPILOG;
    return val;
}

static Bool
VGAarbiterSpriteUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
                                CursorPtr pCur)
{
    Bool val;

    SPRITE_PROLOG;
    VGAGet(pScreen);
    val = PointPriv->spriteFuncs->UnrealizeCursor(pDev, pScreen, pCur);
    VGAPut();
    SPRITE_EPILOG;
    return val;
}

static void
VGAarbiterSpriteSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCur,
                          int x, int y)
{
    SPRITE_PROLOG;
    VGAGet(pScreen);
    PointPriv->spriteFuncs->SetCursor(pDev, pScreen, pCur, x, y);
    VGAPut();
    SPRITE_EPILOG;
}

static void
VGAarbiterSpriteMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
    SPRITE_PROLOG;
    VGAGet(pScreen);
    PointPriv->spriteFuncs->MoveCursor(pDev, pScreen, x, y);
    VGAPut();
    SPRITE_EPILOG;
}

static Bool
VGAarbiterDeviceCursorInitialize(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    Bool val;

    SPRITE_PROLOG;
    VGAGet(pScreen);
    val = PointPriv->spriteFuncs->DeviceCursorInitialize(pDev, pScreen);
    VGAPut();
    SPRITE_EPILOG;
    return val;
}

static void
VGAarbiterDeviceCursorCleanup(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    SPRITE_PROLOG;
    VGAGet(pScreen);
    PointPriv->spriteFuncs->DeviceCursorCleanup(pDev, pScreen);
    VGAPut();
    SPRITE_EPILOG;
}

static void
VGAarbiterComposite(CARD8 op, PicturePtr pSrc, PicturePtr pMask,
                    PicturePtr pDst, INT16 xSrc, INT16 ySrc, INT16 xMask,
                    INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width,
                    CARD16 height)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);

    PICTURE_PROLOGUE(Composite);

    VGAGet(pScreen);
    (*ps->Composite) (op, pSrc, pMask, pDst, xSrc, ySrc, xMask, yMask, xDst,
                      yDst, width, height);
    VGAPut();
    PICTURE_EPILOGUE(Composite, VGAarbiterComposite);
}

static void
VGAarbiterGlyphs(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
                 PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc, int nlist,
                 GlyphListPtr list, GlyphPtr * glyphs)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);

    PICTURE_PROLOGUE(Glyphs);

    VGAGet(pScreen);
    (*ps->Glyphs) (op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);
    VGAPut();
    PICTURE_EPILOGUE(Glyphs, VGAarbiterGlyphs);
}

static void
VGAarbiterCompositeRects(CARD8 op, PicturePtr pDst, xRenderColor * color,
                         int nRect, xRectangle *rects)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);

    PICTURE_PROLOGUE(CompositeRects);

    VGAGet(pScreen);
    (*ps->CompositeRects) (op, pDst, color, nRect, rects);
    VGAPut();
    PICTURE_EPILOGUE(CompositeRects, VGAarbiterCompositeRects);
}
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d260 1
a260 1
    free((pointer) pScreenPriv);
d269 1
a269 1
                       pointer pTimeout, pointer pReadmask)
d280 1
a280 1
                        pointer pReadmask)
d589 1
a589 1
VGAarbiterChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects)
d863 1
a863 1
                        CharInfoPtr * ppci, pointer pglyphBase)
d880 1
a880 1
                       CharInfoPtr * ppci, pointer pglyphBase)
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d109 1
a109 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d176 1
a176 1
        pScrn = xf86Screens[pScreen->myNum];
d224 1
a224 1
VGAarbiterCloseScreen(int i, ScreenPtr pScreen)
d227 1
a227 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d261 3
a263 3
    xf86VGAarbiterLock(xf86Screens[i]);
    val = (*pScreen->CloseScreen) (i, pScreen);
    xf86VGAarbiterUnlock(xf86Screens[i]);
d268 2
a269 2
VGAarbiterBlockHandler(int i,
                       pointer blockData, pointer pTimeout, pointer pReadmask)
a270 2
    ScreenPtr pScreen = screenInfo.screens[i];

d273 1
a273 1
    pScreen->BlockHandler(i, blockData, pTimeout, pReadmask);
d279 1
a279 1
VGAarbiterWakeupHandler(int i, pointer blockData, unsigned long result,
a281 2
    ScreenPtr pScreen = screenInfo.screens[i];

d284 1
a284 1
    pScreen->WakeupHandler(i, blockData, result, pReadmask);
a296 1
//    if (xf86Screens[pScreen->myNum]->vtSema) {
a297 1
//    }
d465 1
a465 1
VGAarbiterAdjustFrame(int index, int x, int y, int flags)
d467 1
a467 1
    ScreenPtr pScreen = screenInfo.screens[index];
d473 1
a473 1
    (*pScreenPriv->AdjustFrame) (index, x, y, flags);
d478 1
a478 1
VGAarbiterSwitchMode(int index, DisplayModePtr mode, int flags)
d481 1
a481 1
    ScreenPtr pScreen = screenInfo.screens[index];
d487 1
a487 1
    val = (*pScreenPriv->SwitchMode) (index, mode, flags);
d493 1
a493 1
VGAarbiterEnterVT(int index, int flags)
d496 1
a496 2
    ScrnInfoPtr pScrn = xf86Screens[index];
    ScreenPtr pScreen = screenInfo.screens[index];
d503 1
a503 1
    val = (*pScrn->EnterVT) (index, flags);
d511 1
a511 1
VGAarbiterLeaveVT(int index, int flags)
d513 1
a513 2
    ScrnInfoPtr pScrn = xf86Screens[index];
    ScreenPtr pScreen = screenInfo.screens[index];
d520 1
a520 1
    (*pScreenPriv->LeaveVT) (index, flags);
d527 1
a527 1
VGAarbiterFreeScreen(int index, int flags)
d529 1
a529 1
    ScreenPtr pScreen = screenInfo.screens[index];
d535 1
a535 1
    (*pScreenPriv->FreeScreen) (index, flags);
@


1.3
log
@Update to xserver 1.11.2
@
text
@a33 2

#ifdef HAVE_PCI_DEVICE_VGAARB_INIT
a38 1

d62 1
d65 1
d73 3
a75 2
	vga_no_arb = 1;
        xf86Msg(X_WARNING, "VGA arbiter: cannot open kernel arbiter, no multi-card support\n");
d83 1
a83 1
	return;
d91 1
a91 1
	return;
d100 1
a100 1
	return;
d104 2
a105 1
Bool xf86VGAarbiterAllowDRI(ScreenPtr pScreen)
d109 1
a109 1
    ScrnInfoPtr         pScrn = xf86Screens[pScreen->myNum];
d112 1
a112 1
	return TRUE;
d130 1
a130 1
	return;
d134 1
a134 1
	return;
d144 1
a144 1
	return;
d155 1
a155 1
    PictureScreenPtr    ps;
d170 1
a170 1
    xf86Msg(X_INFO,"Found %d VGA devices: arbiter wrapping enabled\n",
d179 2
a180 1
        if (!dixRegisterPrivateKey(&VGAarbiterGCKeyRec, PRIVATE_GC, sizeof(VGAarbiterGCRec)))
d183 2
a184 2
	if (!dixRegisterPrivateKey(&VGAarbiterScreenKeyRec, PRIVATE_SCREEN, 0))
	    return FALSE;
d208 3
a210 3
        WRAP_PICT(Composite,VGAarbiterComposite);
        WRAP_PICT(Glyphs,VGAarbiterGlyphs);
        WRAP_PICT(CompositeRects,VGAarbiterCompositeRects);
d224 1
a224 1
VGAarbiterCloseScreen (int i, ScreenPtr pScreen)
d228 7
a234 5
    VGAarbiterScreenPtr pScreenPriv = (VGAarbiterScreenPtr)dixLookupPrivate(
        &pScreen->devPrivates, VGAarbiterScreenKey);
    miPointerScreenPtr PointPriv = (miPointerScreenPtr)dixLookupPrivate(
        &pScreen->devPrivates, miPointerScreenKey);
    PictureScreenPtr    ps = GetPictureScreenIfSet(pScreen);
d272 1
d281 2
a282 1
VGAarbiterWakeupHandler(int i, pointer blockData, unsigned long result, pointer pReadmask)
d285 1
d294 3
a296 7
VGAarbiterGetImage (
    DrawablePtr pDrawable,
    int sx, int sy, int w, int h,
    unsigned int    format,
    unsigned long   planemask,
    char        *pdstLine
    )
d299 1
d304 1
a304 2
    (*pScreen->GetImage) (pDrawable, sx, sy, w, h,
              format, planemask, pdstLine);
d306 1
a306 1
    SCREEN_EPILOG (GetImage, VGAarbiterGetImage);
d310 3
a312 8
VGAarbiterGetSpans (
    DrawablePtr pDrawable,
    int     wMax,
    DDXPointPtr ppt,
    int     *pwidth,
    int     nspans,
    char    *pdstStart
    )
d314 1
a314 1
    ScreenPtr       pScreen = pDrawable->pScreen;
d316 1
a316 1
    SCREEN_PROLOG (GetSpans);
d320 1
a320 1
    SCREEN_EPILOG (GetSpans, VGAarbiterGetSpans);
d324 3
a326 4
VGAarbiterSourceValidate (
    DrawablePtr pDrawable,
    int x, int y, int width, int height,
    unsigned int subWindowMode )
d328 3
a330 2
    ScreenPtr   pScreen = pDrawable->pScreen;
    SCREEN_PROLOG (SourceValidate);
d333 2
a334 1
    (*pScreen->SourceValidate) (pDrawable, x, y, width, height, subWindowMode);
d336 1
a336 1
    SCREEN_EPILOG (SourceValidate, VGAarbiterSourceValidate);
d340 1
a340 4
VGAarbiterCopyWindow(
    WindowPtr pWin,
    DDXPointRec ptOldOrg,
    RegionPtr prgnSrc )
d344 1
a344 1
    SCREEN_PROLOG (CopyWindow);
d348 1
a348 1
    SCREEN_EPILOG (CopyWindow, VGAarbiterCopyWindow);
d352 2
a353 5
VGAarbiterClearToBackground (
    WindowPtr pWin,
    int x, int y,
    int w, int h,
    Bool generateExposures )
d357 1
a357 1
    SCREEN_PROLOG ( ClearToBackground);
d361 1
a361 1
    SCREEN_EPILOG (ClearToBackground, VGAarbiterClearToBackground);
d365 2
a366 1
VGAarbiterCreatePixmap(ScreenPtr pScreen, int w, int h, int depth, unsigned usage_hint)
d370 1
a370 1
    SCREEN_PROLOG ( CreatePixmap);
d374 1
a374 1
    SCREEN_EPILOG (CreatePixmap, VGAarbiterCreatePixmap);
d384 1
a384 1
    SCREEN_PROLOG (SaveScreen);
d388 1
a388 1
    SCREEN_EPILOG (SaveScreen, VGAarbiterSaveScreen);
d394 1
a394 4
VGAarbiterStoreColors (
    ColormapPtr        pmap,
    int                ndef,
    xColorItem         *pdefs)
d398 1
a398 1
    SCREEN_PROLOG (StoreColors);
d400 1
a400 1
    (*pScreen->StoreColors) (pmap,ndef,pdefs);
d402 1
a402 1
    SCREEN_EPILOG ( StoreColors, VGAarbiterStoreColors);
d406 2
a407 6
VGAarbiterRecolorCursor (
    DeviceIntPtr pDev,
    ScreenPtr pScreen,
    CursorPtr pCurs,
    Bool displayed
    )
d409 1
a409 1
    SCREEN_PROLOG (RecolorCursor);
d413 1
a413 1
    SCREEN_EPILOG ( RecolorCursor, VGAarbiterRecolorCursor);
d417 1
a417 5
VGAarbiterRealizeCursor (
    DeviceIntPtr pDev,
    ScreenPtr   pScreen,
    CursorPtr   pCursor
    )
d421 1
a421 1
    SCREEN_PROLOG (RealizeCursor);
d423 1
a423 1
    val = (*pScreen->RealizeCursor) (pDev, pScreen,pCursor);
d425 1
a425 1
    SCREEN_EPILOG ( RealizeCursor, VGAarbiterRealizeCursor);
d430 2
a431 5
VGAarbiterUnrealizeCursor (
    DeviceIntPtr pDev,
    ScreenPtr   pScreen,
    CursorPtr   pCursor
    )
d435 1
a435 1
    SCREEN_PROLOG (UnrealizeCursor);
d439 1
a439 1
    SCREEN_EPILOG ( UnrealizeCursor, VGAarbiterUnrealizeCursor);
d444 1
a444 5
VGAarbiterDisplayCursor (
    DeviceIntPtr pDev,
    ScreenPtr   pScreen,
    CursorPtr   pCursor
    )
d448 1
a448 1
    SCREEN_PROLOG (DisplayCursor);
d452 1
a452 1
    SCREEN_EPILOG ( DisplayCursor, VGAarbiterDisplayCursor);
d457 2
a458 5
VGAarbiterSetCursorPosition (
    DeviceIntPtr pDev,
    ScreenPtr   pScreen,
    int x, int y,
    Bool generateEvent)
d462 1
a462 1
    SCREEN_PROLOG (SetCursorPosition);
d466 1
a466 1
    SCREEN_EPILOG ( SetCursorPosition, VGAarbiterSetCursorPosition);
d474 3
a476 2
    VGAarbiterScreenPtr pScreenPriv = (VGAarbiterScreenPtr)dixLookupPrivate(
        &pScreen->devPrivates, VGAarbiterScreenKey);
d479 1
a479 1
    (*pScreenPriv->AdjustFrame)(index, x, y, flags);
d488 3
a490 2
    VGAarbiterScreenPtr pScreenPriv = (VGAarbiterScreenPtr)dixLookupPrivate(
        &pScreen->devPrivates, VGAarbiterScreenKey);
d493 1
a493 1
    val = (*pScreenPriv->SwitchMode)(index, mode, flags);
d504 3
a506 2
    VGAarbiterScreenPtr pScreenPriv = (VGAarbiterScreenPtr)dixLookupPrivate(
        &pScreen->devPrivates, VGAarbiterScreenKey);
d510 1
a510 1
    val = (*pScrn->EnterVT)(index, flags);
d522 3
a524 2
    VGAarbiterScreenPtr pScreenPriv = (VGAarbiterScreenPtr)dixLookupPrivate(
        &pScreen->devPrivates, VGAarbiterScreenKey);
d528 1
a528 1
    (*pScreenPriv->LeaveVT)(index, flags);
d538 3
a540 2
    VGAarbiterScreenPtr pScreenPriv = (VGAarbiterScreenPtr)dixLookupPrivate(
        &pScreen->devPrivates, VGAarbiterScreenKey);
d543 1
a543 1
    (*pScreenPriv->FreeScreen)(index, flags);
d550 4
a553 3
    ScreenPtr    pScreen = pGC->pScreen;
    VGAarbiterGCPtr pGCPriv = (VGAarbiterGCPtr)dixLookupPrivate(&pGC->devPrivates, VGAarbiterGCKey);
    Bool         ret;
d556 1
a556 1
    ret = (*pScreen->CreateGC)(pGC);
d558 1
a558 1
    SCREEN_EPILOG(CreateGC,VGAarbiterCreateGC);
d565 1
a565 4
VGAarbiterValidateGC(
   GCPtr         pGC,
   unsigned long changes,
   DrawablePtr   pDraw )
d568 1
a568 1
    (*pGC->funcs->ValidateGC)(pGC, changes, pDraw);
a571 1

d575 3
a577 3
    GC_UNWRAP (pGC);
    (*pGC->funcs->DestroyGC)(pGC);
    GC_WRAP (pGC);
d581 1
a581 3
VGAarbiterChangeGC (
    GCPtr       pGC,
    unsigned long   mask)
d583 1
a583 1
    GC_UNWRAP (pGC);
d585 1
a585 1
    GC_WRAP (pGC);
d589 1
a589 4
VGAarbiterCopyGC (
    GCPtr       pGCSrc,
    unsigned long   mask,
    GCPtr       pGCDst)
d591 1
a591 1
    GC_UNWRAP (pGCDst);
d593 1
a593 1
    GC_WRAP (pGCDst);
d597 1
a597 5
VGAarbiterChangeClip (
    GCPtr   pGC,
    int     type,
    pointer pvalue,
    int     nrects )
d599 1
a599 1
    GC_UNWRAP (pGC);
d601 1
a601 1
    GC_WRAP (pGC);
d607 3
a609 3
    GC_UNWRAP (pgcDst);
    (* pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
    GC_WRAP (pgcDst);
d615 3
a617 3
    GC_UNWRAP (pGC);
    (* pGC->funcs->DestroyClip)(pGC);
    GC_WRAP (pGC);
d622 4
a625 7
VGAarbiterFillSpans(
    DrawablePtr pDraw,
    GC      *pGC,
    int     nInit,
    DDXPointPtr pptInit,
    int *pwidthInit,
    int fSorted )
d628 1
d631 1
a631 1
    (*pGC->ops->FillSpans)(pDraw, pGC, nInit, pptInit, pwidthInit, fSorted);
d637 5
a641 8
VGAarbiterSetSpans(
    DrawablePtr     pDraw,
    GCPtr       pGC,
    char        *pcharsrc,
    register DDXPointPtr ppt,
    int         *pwidth,
    int         nspans,
    int         fSorted )
d644 1
d647 1
a647 1
    (*pGC->ops->SetSpans)(pDraw, pGC, pcharsrc, ppt, pwidth, nspans, fSorted);
d653 5
a657 8
VGAarbiterPutImage(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     depth,
    int x, int y, int w, int h,
    int     leftPad,
    int     format,
    char    *pImage )
d660 1
d663 2
a664 2
    (*pGC->ops->PutImage)(pDraw, pGC, depth, x, y, w, h,
              leftPad, format, pImage);
d670 5
a674 7
VGAarbiterCopyArea(
    DrawablePtr pSrc,
    DrawablePtr pDst,
    GC *pGC,
    int srcx, int srcy,
    int width, int height,
    int dstx, int dsty )
d678 1
d681 2
a682 2
    ret = (*pGC->ops->CopyArea)(pSrc, pDst,
                pGC, srcx, srcy, width, height, dstx, dsty);
d689 6
a694 8
VGAarbiterCopyPlane(
    DrawablePtr pSrc,
    DrawablePtr pDst,
    GCPtr pGC,
    int srcx, int srcy,
    int width, int height,
    int dstx, int dsty,
    unsigned long bitPlane )
d698 1
d701 2
a702 2
    ret = (*pGC->ops->CopyPlane)(pSrc, pDst, pGC, srcx, srcy,
                 width, height, dstx, dsty, bitPlane);
d709 2
a710 6
VGAarbiterPolyPoint(
    DrawablePtr pDraw,
    GCPtr pGC,
    int mode,
    int npt,
    xPoint *pptInit )
d713 1
d716 1
a716 1
    (*pGC->ops->PolyPoint)(pDraw, pGC, mode, npt, pptInit);
a720 1

d722 2
a723 6
VGAarbiterPolylines(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     mode,
    int     npt,
    DDXPointPtr pptInit )
d726 1
d729 1
a729 1
    (*pGC->ops->Polylines)(pDraw, pGC, mode, npt, pptInit);
d735 1
a735 5
VGAarbiterPolySegment(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     nseg,
    xSegment    *pSeg )
d738 1
d741 1
a741 1
    (*pGC->ops->PolySegment)(pDraw, pGC, nseg, pSeg);
d747 2
a748 5
VGAarbiterPolyRectangle(
    DrawablePtr  pDraw,
    GCPtr        pGC,
    int          nRectsInit,
    xRectangle  *pRectsInit )
d751 1
d754 1
a754 1
    (*pGC->ops->PolyRectangle)(pDraw, pGC, nRectsInit, pRectsInit);
d760 1
a760 5
VGAarbiterPolyArc(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     narcs,
    xArc    *parcs )
d763 1
d766 1
a766 1
    (*pGC->ops->PolyArc)(pDraw, pGC, narcs, parcs);
d772 3
a774 7
VGAarbiterFillPolygon(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     shape,
    int     mode,
    int     count,
    DDXPointPtr ptsIn )
d777 1
d780 1
a780 1
    (*pGC->ops->FillPolygon)(pDraw, pGC, shape, mode, count, ptsIn);
d786 2
a787 5
VGAarbiterPolyFillRect(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     nrectFill,
    xRectangle  *prectInit)
d790 1
d793 1
a793 1
    (*pGC->ops->PolyFillRect)(pDraw, pGC, nrectFill, prectInit);
d799 1
a799 5
VGAarbiterPolyFillArc(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     narcs,
    xArc    *parcs )
d802 1
d805 1
a805 1
    (*pGC->ops->PolyFillArc)(pDraw, pGC, narcs, parcs);
d811 2
a812 7
VGAarbiterPolyText8(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     x,
    int     y,
    int     count,
    char    *chars )
d816 1
d819 1
a819 1
    ret = (*pGC->ops->PolyText8)(pDraw, pGC, x, y, count, chars);
d826 2
a827 7
VGAarbiterPolyText16(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     x,
    int     y,
    int     count,
    unsigned short *chars )
d831 1
d834 1
a834 1
    ret = (*pGC->ops->PolyText16)(pDraw, pGC, x, y, count, chars);
d841 2
a842 7
VGAarbiterImageText8(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     x,
    int     y,
    int     count,
    char    *chars )
d845 1
d848 1
a848 1
    (*pGC->ops->ImageText8)(pDraw, pGC, x, y, count, chars);
d854 2
a855 7
VGAarbiterImageText16(
    DrawablePtr pDraw,
    GCPtr   pGC,
    int     x,
    int     y,
    int     count,
    unsigned short *chars )
d858 1
d861 1
a861 1
    (*pGC->ops->ImageText16)(pDraw, pGC, x, y, count, chars);
a865 1

d867 5
a871 7
VGAarbiterImageGlyphBlt(
    DrawablePtr pDraw,
    GCPtr pGC,
    int xInit, int yInit,
    unsigned int nglyph,
    CharInfoPtr *ppci,
    pointer pglyphBase )
d874 1
d877 2
a878 2
    (*pGC->ops->ImageGlyphBlt)(pDraw, pGC, xInit, yInit,
                   nglyph, ppci, pglyphBase);
d884 5
a888 7
VGAarbiterPolyGlyphBlt(
    DrawablePtr pDraw,
    GCPtr pGC,
    int xInit, int yInit,
    unsigned int nglyph,
    CharInfoPtr *ppci,
    pointer pglyphBase )
d891 1
d894 2
a895 2
    (*pGC->ops->PolyGlyphBlt)(pDraw, pGC, xInit, yInit,
                  nglyph, ppci, pglyphBase);
d901 3
a903 5
VGAarbiterPushPixels(
    GCPtr   pGC,
    PixmapPtr   pBitMap,
    DrawablePtr pDraw,
    int dx, int dy, int xOrg, int yOrg )
d906 1
d909 1
a909 1
    (*pGC->ops->PushPixels)(pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);
a913 1

d916 2
a917 1
VGAarbiterSpriteRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCur)
d920 1
d930 2
a931 1
VGAarbiterSpriteUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCur)
d934 1
d944 2
a945 1
VGAarbiterSpriteSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCur, int x, int y)
d968 1
d989 3
a991 3
         PicturePtr pDst, INT16 xSrc, INT16 ySrc, INT16 xMask,
         INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width,
         CARD16 height)
d993 2
a994 2
    ScreenPtr       pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
d1000 1
a1000 1
              yDst, width, height);
d1007 2
a1008 2
      PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc, int nlist,
      GlyphListPtr list, GlyphPtr *glyphs)
d1010 2
a1011 2
    ScreenPtr       pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
d1016 1
a1016 1
    (*ps->Glyphs)(op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);
d1018 1
a1018 1
    PICTURE_EPILOGUE (Glyphs, VGAarbiterGlyphs);
d1022 2
a1023 2
VGAarbiterCompositeRects(CARD8 op, PicturePtr pDst, xRenderColor *color, int nRect,
          xRectangle *rects)
d1025 2
a1026 2
    ScreenPtr       pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr    ps = GetPictureScreen(pScreen);
d1031 1
a1031 1
    (*ps->CompositeRects)(op, pDst, color, nRect, rects);
d1033 1
a1033 1
    PICTURE_EPILOGUE (CompositeRects, VGAarbiterCompositeRects);
a1034 13
#else
/* dummy functions */
void xf86VGAarbiterInit(void) {}
void xf86VGAarbiterFini(void) {}

void xf86VGAarbiterLock(ScrnInfoPtr pScrn) {}
void xf86VGAarbiterUnlock(ScrnInfoPtr pScrn) {}
Bool xf86VGAarbiterAllowDRI(ScreenPtr pScreen) { return TRUE; }
void xf86VGAarbiterScrnInit(ScrnInfoPtr pScrn) {}
void xf86VGAarbiterDeviceDecodes(ScrnInfoPtr pScrn, int rsrc) {}
Bool xf86VGAarbiterWrapFunctions(void) { return FALSE; }

#endif
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a55 1
    {NULL}      /* devPrivate */
d140 1
a140 1
xf86VGAarbiterDeviceDecodes(ScrnInfoPtr pScrn)
d144 2
a145 1
    pci_device_vgaarb_decodes(VGA_ARB_RSRC_LEGACY_MEM | VGA_ARB_RSRC_LEGACY_IO);
d269 1
a269 1
    VGAGet();
d280 1
a280 1
    VGAGet();
d298 1
a298 1
    VGAGet();
d319 1
a319 1
    VGAGet();
d328 2
a329 1
    int x, int y, int width, int height )
d333 1
a333 1
    VGAGet();
d335 1
a335 1
    (*pScreen->SourceValidate) (pDrawable, x, y, width, height);
d349 1
a349 1
    VGAGet();
d365 1
a365 1
    VGAGet();
d377 1
a377 1
    VGAGet();
d391 1
a391 1
    VGAGet();
d408 1
a408 1
    VGAGet();
d423 1
a423 1
    VGAGet();
d439 1
a439 1
    VGAGet();
d456 1
a456 1
    VGAGet();
d473 1
a473 1
    VGAGet();
d490 1
a490 1
    VGAGet();
d504 1
a504 1
    VGAGet();
d517 1
a517 1
    VGAGet();
d532 1
a532 1
    VGAGet();
d549 1
a549 1
    VGAGet();
d564 1
a564 1
    VGAGet();
a576 1
    VGAGet();
a577 1
    VGAPut();
d664 1
d666 1
a666 1
    VGAGet_GC();
d668 1
a668 1
    VGAPut_GC();
d682 1
d684 1
a684 1
    VGAGet_GC();
d686 1
a686 1
    VGAPut_GC();
d700 1
d702 1
a702 1
    VGAGet_GC();
d705 1
a705 1
    VGAPut_GC();
d719 1
a719 1

d721 1
a721 1
    VGAGet_GC();
d724 1
a724 1
    VGAPut_GC();
d740 1
a740 1

d742 1
a742 1
    VGAGet_GC();
d745 1
a745 1
    VGAPut_GC();
d758 1
d760 1
a760 1
    VGAGet_GC();
d762 1
a762 1
    VGAPut_GC();
d775 1
d777 1
a777 1
    VGAGet_GC();
d779 1
a779 1
    VGAPut_GC();
d790 1
d792 1
a792 1
    VGAGet_GC();
d794 1
a794 1
    VGAPut_GC();
d805 1
d807 1
a807 1
    VGAGet_GC();
d809 1
a809 1
    VGAPut_GC();
d820 1
d822 1
a822 1
    VGAGet_GC();
d824 1
a824 1
    VGAPut_GC();
d837 1
d839 1
a839 1
    VGAGet_GC();
d841 1
a841 1
    VGAPut_GC();
d852 1
d854 1
a854 1
    VGAGet_GC();
d856 1
a856 1
    VGAPut_GC();
d867 1
d869 1
a869 1
    VGAGet_GC();
d871 1
a871 1
    VGAPut_GC();
d885 1
a885 1

d887 1
a887 1
    VGAGet_GC();
d889 1
a889 1
    VGAPut_GC();
d904 1
a904 1

d906 1
a906 1
    VGAGet_GC();
d908 1
a908 1
    VGAPut_GC();
d922 1
d924 1
a924 1
    VGAGet_GC();
d926 1
a926 1
    VGAPut_GC();
d939 1
d941 1
a941 1
    VGAGet_GC();
d943 1
a943 1
    VGAPut_GC();
d957 1
d959 1
a959 1
    VGAGet_GC();
d962 1
a962 1
    VGAPut_GC();
d975 1
d977 1
a977 1
    VGAGet_GC();
d980 1
a980 1
    VGAPut_GC();
d991 1
d993 1
a993 1
    VGAGet_GC();
d995 1
a995 1
    VGAPut_GC();
d1006 1
a1006 1
    VGAGet();
d1018 1
a1018 1
    VGAGet();
d1029 1
a1029 1
    VGAGet();
d1039 1
a1039 1
    VGAGet();
d1050 1
a1050 1
    VGAGet();
d1061 1
a1061 1
    VGAGet();
d1078 1
a1078 1
    VGAGet();
d1095 1
a1095 1
    VGAGet();
d1110 1
a1110 1
    VGAGet();
d1124 1
a1124 1
void xf86VGAarbiterDeviceDecodes(ScrnInfoPtr pScrn) {}
@


1.1
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d65 4
a68 4
static int VGAarbiterKeyIndex;
static DevPrivateKey VGAarbiterScreenKey = &VGAarbiterKeyIndex;
static int VGAarbiterGCIndex;
static DevPrivateKey VGAarbiterGCKey = &VGAarbiterGCIndex;
a153 1
#ifdef RENDER
a154 1
#endif
a173 1
#ifdef RENDER
a174 1
#endif
d178 1
a178 1
        if (!dixRequestPrivate(VGAarbiterGCKey, sizeof(VGAarbiterGCRec)))
d181 4
a184 1
        if (!(pScreenPriv = xalloc(sizeof(VGAarbiterScreenRec))))
a205 1
#ifdef RENDER
a208 1
#endif
a229 1
#ifdef RENDER
a230 1
#endif
a245 1
#ifdef RENDER
a248 1
#endif
d256 1
a256 1
    xfree ((pointer) pScreenPriv);
d526 1
d532 4
a535 1
    val = (*pScreenPriv->EnterVT)(index, flags);
d543 1
d549 1
d551 2
a1051 1
#ifdef RENDER
a1099 1
#endif
@

