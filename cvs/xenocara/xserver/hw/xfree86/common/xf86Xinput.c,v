head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.6
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.2
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	s0SI41sEunLdyFfd;

1.21
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	Te1daavkBLskZ8gc;

1.20
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.19;
commitid	cVXoV5PxI8YrEaVA;

1.19
date	2013.08.24.19.44.38;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2012.08.05.18.11.38;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.31.07.52.36;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2011.06.29.19.55.01;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.21.20.10.47;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.21.06.42.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.13.21.47.54;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.03;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.12;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.12;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.53;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.13.42;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 1995-1999 by Frederic Lepied, France. <Lepied@@XFree86.org>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is  hereby granted without fee, provided that
 * the  above copyright   notice appear  in   all  copies and  that both  that
 * copyright  notice   and   this  permission   notice  appear  in  supporting
 * documentation, and that   the  name of  Frederic   Lepied not  be  used  in
 * advertising or publicity pertaining to distribution of the software without
 * specific,  written      prior  permission.     Frederic  Lepied   makes  no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * FREDERIC  LEPIED DISCLAIMS ALL   WARRANTIES WITH REGARD  TO  THIS SOFTWARE,
 * INCLUDING ALL IMPLIED   WARRANTIES OF MERCHANTABILITY  AND   FITNESS, IN NO
 * EVENT  SHALL FREDERIC  LEPIED BE   LIABLE   FOR ANY  SPECIAL, INDIRECT   OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA  OR PROFITS, WHETHER  IN  AN ACTION OF  CONTRACT,  NEGLIGENCE OR OTHER
 * TORTIOUS  ACTION, ARISING    OUT OF OR   IN  CONNECTION  WITH THE USE    OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */
/*
 * Copyright (c) 2000-2002 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/Xfuncproto.h>
#include <X11/Xmd.h>
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include <X11/Xatom.h>
#include "xf86.h"
#include "xf86Priv.h"
#include "xf86Config.h"
#include "xf86Xinput.h"
#include "xf86Optrec.h"
#include "mipointer.h"
#include "extinit.h"
#include "loaderProcs.h"
#include "systemd-logind.h"

#include "exevents.h"           /* AddInputDevice */
#include "exglobals.h"
#include "eventstr.h"
#include "inpututils.h"
#include "optionstr.h"

#include <string.h>             /* InputClassMatches */
#ifdef HAVE_FNMATCH_H
#include <fnmatch.h>
#endif
#ifdef HAVE_SYS_UTSNAME_H
#include <sys/utsname.h>
#endif

#include <stdarg.h>
#include <stdint.h>             /* for int64_t */
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#ifdef HAVE_SYS_MKDEV_H
#include <sys/mkdev.h>          /* for major() & minor() on Solaris */
#endif

#include "mi.h"

#include <ptrveloc.h>           /* dix pointer acceleration */
#include <xserver-properties.h>

#ifdef XFreeXDGA
#include "dgaproc.h"
#endif

#include "xkbsrv.h"

/* Valuator verification macro */
#define XI_VERIFY_VALUATORS(num_valuators)					\
	if (num_valuators > MAX_VALUATORS) {					\
		xf86Msg(X_ERROR, "%s: num_valuator %d is greater than"		\
			" MAX_VALUATORS\n", __FUNCTION__, num_valuators);	\
		return;								\
	}

static int
 xf86InputDevicePostInit(DeviceIntPtr dev);

static InputInfoPtr *new_input_devices;
static int new_input_devices_count;

/**
 * Eval config and modify DeviceVelocityRec accordingly
 */
static void
ProcessVelocityConfiguration(DeviceIntPtr pDev, const char *devname, void *list,
                             DeviceVelocityPtr s)
{
    int tempi;
    float tempf;
    Atom float_prop = XIGetKnownProperty(XATOM_FLOAT);
    Atom prop;

    if (!s)
        return;

    /* common settings (available via device properties) */
    tempf = xf86SetRealOption(list, "ConstantDeceleration", 1.0);
    if (tempf > 1.0) {
        xf86Msg(X_CONFIG, "%s: (accel) constant deceleration by %.1f\n",
                devname, tempf);
        prop = XIGetKnownProperty(ACCEL_PROP_CONSTANT_DECELERATION);
        XIChangeDeviceProperty(pDev, prop, float_prop, 32,
                               PropModeReplace, 1, &tempf, FALSE);
    }

    tempf = xf86SetRealOption(list, "AdaptiveDeceleration", 1.0);
    if (tempf > 1.0) {
        xf86Msg(X_CONFIG, "%s: (accel) adaptive deceleration by %.1f\n",
                devname, tempf);
        prop = XIGetKnownProperty(ACCEL_PROP_ADAPTIVE_DECELERATION);
        XIChangeDeviceProperty(pDev, prop, float_prop, 32,
                               PropModeReplace, 1, &tempf, FALSE);
    }

    /* select profile by number */
    tempi = xf86SetIntOption(list, "AccelerationProfile",
                             s->statistics.profile_number);

    prop = XIGetKnownProperty(ACCEL_PROP_PROFILE_NUMBER);
    if (XIChangeDeviceProperty(pDev, prop, XA_INTEGER, 32,
                               PropModeReplace, 1, &tempi, FALSE) == Success) {
        xf86Msg(X_CONFIG, "%s: (accel) acceleration profile %i\n", devname,
                tempi);
    }
    else {
        xf86Msg(X_CONFIG, "%s: (accel) acceleration profile %i is unknown\n",
                devname, tempi);
    }

    /* set scaling */
    tempf = xf86SetRealOption(list, "ExpectedRate", 0);
    prop = XIGetKnownProperty(ACCEL_PROP_VELOCITY_SCALING);
    if (tempf > 0) {
        tempf = 1000.0 / tempf;
        XIChangeDeviceProperty(pDev, prop, float_prop, 32,
                               PropModeReplace, 1, &tempf, FALSE);
    }
    else {
        tempf = xf86SetRealOption(list, "VelocityScale", s->corr_mul);
        XIChangeDeviceProperty(pDev, prop, float_prop, 32,
                               PropModeReplace, 1, &tempf, FALSE);
    }

    tempi = xf86SetIntOption(list, "VelocityTrackerCount", -1);
    if (tempi > 1)
        InitTrackers(s, tempi);

    s->initial_range = xf86SetIntOption(list, "VelocityInitialRange",
                                        s->initial_range);

    s->max_diff = xf86SetRealOption(list, "VelocityAbsDiff", s->max_diff);

    tempf = xf86SetRealOption(list, "VelocityRelDiff", -1);
    if (tempf >= 0) {
        xf86Msg(X_CONFIG, "%s: (accel) max rel. velocity difference: %.1f%%\n",
                devname, tempf * 100.0);
        s->max_rel_diff = tempf;
    }

    /*  Configure softening. If const deceleration is used, this is expected
     *  to provide better subpixel information so we enable
     *  softening by default only if ConstantDeceleration is not used
     */
    s->use_softening = xf86SetBoolOption(list, "Softening",
                                         s->const_acceleration == 1.0);

    s->average_accel = xf86SetBoolOption(list, "AccelerationProfileAveraging",
                                         s->average_accel);

    s->reset_time = xf86SetIntOption(list, "VelocityReset", s->reset_time);
}

static void
ApplyAccelerationSettings(DeviceIntPtr dev)
{
    int scheme, i;
    DeviceVelocityPtr pVel;
    InputInfoPtr pInfo = (InputInfoPtr) dev->public.devicePrivate;
    char *schemeStr;

    if (dev->valuator && dev->ptrfeed) {
        schemeStr = xf86SetStrOption(pInfo->options, "AccelerationScheme", "");

        scheme = dev->valuator->accelScheme.number;

        if (!xf86NameCmp(schemeStr, "predictable"))
            scheme = PtrAccelPredictable;

        if (!xf86NameCmp(schemeStr, "lightweight"))
            scheme = PtrAccelLightweight;

        if (!xf86NameCmp(schemeStr, "none"))
            scheme = PtrAccelNoOp;

        /* reinit scheme if needed */
        if (dev->valuator->accelScheme.number != scheme) {
            if (dev->valuator->accelScheme.AccelCleanupProc) {
                dev->valuator->accelScheme.AccelCleanupProc(dev);
            }

            if (InitPointerAccelerationScheme(dev, scheme)) {
                xf86Msg(X_CONFIG, "%s: (accel) selected scheme %s/%i\n",
                        pInfo->name, schemeStr, scheme);
            }
            else {
                xf86Msg(X_CONFIG, "%s: (accel) could not init scheme %s\n",
                        pInfo->name, schemeStr);
                scheme = dev->valuator->accelScheme.number;
            }
        }
        else {
            xf86Msg(X_CONFIG, "%s: (accel) keeping acceleration scheme %i\n",
                    pInfo->name, scheme);
        }

        free(schemeStr);

        /* process special configuration */
        switch (scheme) {
        case PtrAccelPredictable:
            pVel = GetDevicePredictableAccelData(dev);
            ProcessVelocityConfiguration(dev, pInfo->name, pInfo->options,
                                         pVel);
            break;
        }

        i = xf86SetIntOption(pInfo->options, "AccelerationNumerator",
                             dev->ptrfeed->ctrl.num);
        if (i >= 0)
            dev->ptrfeed->ctrl.num = i;

        i = xf86SetIntOption(pInfo->options, "AccelerationDenominator",
                             dev->ptrfeed->ctrl.den);
        if (i > 0)
            dev->ptrfeed->ctrl.den = i;

        i = xf86SetIntOption(pInfo->options, "AccelerationThreshold",
                             dev->ptrfeed->ctrl.threshold);
        if (i >= 0)
            dev->ptrfeed->ctrl.threshold = i;

        xf86Msg(X_CONFIG, "%s: (accel) acceleration factor: %.3f\n",
                pInfo->name, ((float) dev->ptrfeed->ctrl.num) /
                ((float) dev->ptrfeed->ctrl.den));
        xf86Msg(X_CONFIG, "%s: (accel) acceleration threshold: %i\n",
                pInfo->name, dev->ptrfeed->ctrl.threshold);
    }
}

static void
ApplyTransformationMatrix(DeviceIntPtr dev)
{
    InputInfoPtr pInfo = (InputInfoPtr) dev->public.devicePrivate;
    char *str;
    int rc;
    float matrix[9] = { 0 };

    if (!dev->valuator)
        return;

    str = xf86SetStrOption(pInfo->options, "TransformationMatrix", NULL);
    if (!str)
        return;

    rc = sscanf(str, "%f %f %f %f %f %f %f %f %f", &matrix[0], &matrix[1],
                &matrix[2], &matrix[3], &matrix[4], &matrix[5], &matrix[6],
                &matrix[7], &matrix[8]);
    if (rc != 9) {
        xf86Msg(X_ERROR,
                "%s: invalid format for transformation matrix. Ignoring configuration.\n",
                pInfo->name);
        return;
    }

    XIChangeDeviceProperty(dev, XIGetKnownProperty(XI_PROP_TRANSFORM),
                           XIGetKnownProperty(XATOM_FLOAT), 32,
                           PropModeReplace, 9, matrix, FALSE);
}

/***********************************************************************
 *
 * xf86ProcessCommonOptions --
 *
 *	Process global options.
 *
 ***********************************************************************
 */
void
xf86ProcessCommonOptions(InputInfoPtr pInfo, XF86OptionPtr list)
{
    if (xf86SetBoolOption(list, "Floating", 0) ||
        !xf86SetBoolOption(list, "AlwaysCore", 1) ||
        !xf86SetBoolOption(list, "SendCoreEvents", 1) ||
        !xf86SetBoolOption(list, "CorePointer", 1) ||
        !xf86SetBoolOption(list, "CoreKeyboard", 1)) {
        xf86Msg(X_CONFIG, "%s: doesn't report core events\n", pInfo->name);
    }
    else {
        pInfo->flags |= XI86_ALWAYS_CORE;
        xf86Msg(X_CONFIG, "%s: always reports core events\n", pInfo->name);
    }
}

/***********************************************************************
 *
 * xf86ActivateDevice --
 *
 *	Initialize an input device.
 *
 * Returns TRUE on success, or FALSE otherwise.
 ***********************************************************************
 */
static DeviceIntPtr
xf86ActivateDevice(InputInfoPtr pInfo)
{
    DeviceIntPtr dev;
    Atom atom;

    dev = AddInputDevice(serverClient, pInfo->device_control, TRUE);

    if (dev == NULL) {
        xf86Msg(X_ERROR, "Too many input devices. Ignoring %s\n", pInfo->name);
        pInfo->dev = NULL;
        return NULL;
    }

    atom = MakeAtom(pInfo->type_name, strlen(pInfo->type_name), TRUE);
    AssignTypeAndName(dev, atom, pInfo->name);
    dev->public.devicePrivate = pInfo;
    pInfo->dev = dev;

    dev->coreEvents = pInfo->flags & XI86_ALWAYS_CORE;
    dev->type = SLAVE;
    dev->spriteInfo->spriteOwner = FALSE;

    dev->config_info = xf86SetStrOption(pInfo->options, "config_info", NULL);

    if (serverGeneration == 1)
        xf86Msg(X_INFO,
                "XINPUT: Adding extended input device \"%s\" (type: %s, id %d)\n",
                pInfo->name, pInfo->type_name, dev->id);

    return dev;
}

/****************************************************************************
 *
 * Caller:	ProcXSetDeviceMode
 *
 * Change the mode of an extension device.
 * This function is used to change the mode of a device from reporting
 * relative motion to reporting absolute positional information, and
 * vice versa.
 * The default implementation below is that no such devices are supported.
 *
 ***********************************************************************
 */

int
SetDeviceMode(ClientPtr client, DeviceIntPtr dev, int mode)
{
    InputInfoPtr pInfo = (InputInfoPtr) dev->public.devicePrivate;

    if (pInfo->switch_mode) {
        return (*pInfo->switch_mode) (client, dev, mode);
    }
    else
        return BadMatch;
}

/***********************************************************************
 *
 * Caller:	ProcXSetDeviceValuators
 *
 * Set the value of valuators on an extension input device.
 * This function is used to set the initial value of valuators on
 * those input devices that are capable of reporting either relative
 * motion or an absolute position, and allow an initial position to be set.
 * The default implementation below is that no such devices are supported.
 *
 ***********************************************************************
 */

int
SetDeviceValuators(ClientPtr client, DeviceIntPtr dev, int *valuators,
                   int first_valuator, int num_valuators)
{
    InputInfoPtr pInfo = (InputInfoPtr) dev->public.devicePrivate;

    if (pInfo->set_device_valuators)
        return (*pInfo->set_device_valuators) (pInfo, valuators, first_valuator,
                                               num_valuators);

    return BadMatch;
}

/***********************************************************************
 *
 * Caller:	ProcXChangeDeviceControl
 *
 * Change the specified device controls on an extension input device.
 *
 ***********************************************************************
 */

int
ChangeDeviceControl(ClientPtr client, DeviceIntPtr dev, xDeviceCtl * control)
{
    InputInfoPtr pInfo = (InputInfoPtr) dev->public.devicePrivate;

    if (!pInfo->control_proc) {
        switch (control->control) {
        case DEVICE_CORE:
        case DEVICE_ABS_CALIB:
        case DEVICE_ABS_AREA:
            return BadMatch;
        case DEVICE_RESOLUTION:
        case DEVICE_ENABLE:
            return Success;
        default:
            return BadMatch;
        }
    }
    else {
        return (*pInfo->control_proc) (pInfo, control);
    }
}

/*
 * Get the operating system name from uname and store it statically to avoid
 * repeating the system call each time MatchOS is checked.
 */
static const char *
HostOS(void)
{
#ifdef HAVE_SYS_UTSNAME_H
    struct utsname name;
    static char host_os[sizeof(name.sysname)] = "";

    if (*host_os == '\0') {
        if (uname(&name) >= 0)
            strlcpy(host_os, name.sysname, sizeof(host_os));
        else {
            strlcpy(host_os, "unknown", sizeof(host_os));
        }
    }
    return host_os;
#else
    return "";
#endif
}

static int
match_substring(const char *attr, const char *pattern)
{
    return (strstr(attr, pattern)) ? 0 : -1;
}

#ifdef HAVE_FNMATCH_H
static int
match_pattern(const char *attr, const char *pattern)
{
    return fnmatch(pattern, attr, 0);
}
#else
#define match_pattern match_substring
#endif

#ifdef HAVE_FNMATCH_H
static int
match_path_pattern(const char *attr, const char *pattern)
{
    return fnmatch(pattern, attr, FNM_PATHNAME);
}
#else
#define match_path_pattern match_substring
#endif

/*
 * If no Layout section is found, xf86ServerLayout.id becomes "(implicit)"
 * It is convenient that "" in patterns means "no explicit layout"
 */
static int
match_string_implicit(const char *attr, const char *pattern)
{
    if (strlen(pattern)) {
        return strcmp(attr, pattern);
    }
    else {
        return strcmp(attr, "(implicit)");
    }
}

/*
 * Match an attribute against a list of NULL terminated arrays of patterns.
 * If a pattern in each list entry is matched, return TRUE.
 */
static Bool
MatchAttrToken(const char *attr, struct xorg_list *patterns,
               int (*compare) (const char *attr, const char *pattern))
{
    const xf86MatchGroup *group;

    /* If there are no patterns, accept the match */
    if (xorg_list_is_empty(patterns))
        return TRUE;

    /* If there are patterns but no attribute, reject the match */
    if (!attr)
        return FALSE;

    /*
     * Otherwise, iterate the list of patterns ensuring each entry has a
     * match. Each list entry is a separate Match line of the same type.
     */
    xorg_list_for_each_entry(group, patterns, entry) {
        char *const *cur;
        Bool match = FALSE;

        for (cur = group->values; *cur; cur++)
            if ((*compare) (attr, *cur) == 0) {
                match = TRUE;
                break;
            }
        if (!match)
            return FALSE;
    }

    /* All the entries in the list matched the attribute */
    return TRUE;
}

/*
 * Classes without any Match statements match all devices. Otherwise, all
 * statements must match.
 */
static Bool
InputClassMatches(const XF86ConfInputClassPtr iclass, const InputInfoPtr idev,
                  const InputAttributes * attrs)
{
    /* MatchProduct substring */
    if (!MatchAttrToken
        (attrs->product, &iclass->match_product, match_substring))
        return FALSE;

    /* MatchVendor substring */
    if (!MatchAttrToken(attrs->vendor, &iclass->match_vendor, match_substring))
        return FALSE;

    /* MatchDevicePath pattern */
    if (!MatchAttrToken
        (attrs->device, &iclass->match_device, match_path_pattern))
        return FALSE;

    /* MatchOS case-insensitive string */
    if (!MatchAttrToken(HostOS(), &iclass->match_os, strcasecmp))
        return FALSE;

    /* MatchPnPID pattern */
    if (!MatchAttrToken(attrs->pnp_id, &iclass->match_pnpid, match_pattern))
        return FALSE;

    /* MatchUSBID pattern */
    if (!MatchAttrToken(attrs->usb_id, &iclass->match_usbid, match_pattern))
        return FALSE;

    /* MatchDriver string */
    if (!MatchAttrToken(idev->driver, &iclass->match_driver, strcmp))
        return FALSE;

    /*
     * MatchTag string
     * See if any of the device's tags match any of the MatchTag tokens.
     */
    if (!xorg_list_is_empty(&iclass->match_tag)) {
        char *const *tag;
        Bool match;

        if (!attrs->tags)
            return FALSE;
        for (tag = attrs->tags, match = FALSE; *tag; tag++) {
            if (MatchAttrToken(*tag, &iclass->match_tag, strcmp)) {
                match = TRUE;
                break;
            }
        }
        if (!match)
            return FALSE;
    }

    /* MatchLayout string */
    if (!xorg_list_is_empty(&iclass->match_layout)) {
        if (!MatchAttrToken(xf86ConfigLayout.id,
                            &iclass->match_layout, match_string_implicit))
            return FALSE;
    }

    /* MatchIs* booleans */
    if (iclass->is_keyboard.set &&
        iclass->is_keyboard.val != ! !(attrs->flags & ATTR_KEYBOARD))
        return FALSE;
    if (iclass->is_pointer.set &&
        iclass->is_pointer.val != ! !(attrs->flags & ATTR_POINTER))
        return FALSE;
    if (iclass->is_joystick.set &&
        iclass->is_joystick.val != ! !(attrs->flags & ATTR_JOYSTICK))
        return FALSE;
    if (iclass->is_tablet.set &&
        iclass->is_tablet.val != ! !(attrs->flags & ATTR_TABLET))
        return FALSE;
    if (iclass->is_touchpad.set &&
        iclass->is_touchpad.val != ! !(attrs->flags & ATTR_TOUCHPAD))
        return FALSE;
    if (iclass->is_touchscreen.set &&
        iclass->is_touchscreen.val != ! !(attrs->flags & ATTR_TOUCHSCREEN))
        return FALSE;

    return TRUE;
}

/*
 * Merge in any InputClass configurations. Options in each InputClass
 * section have more priority than the original device configuration as
 * well as any previous InputClass sections.
 */
static int
MergeInputClasses(const InputInfoPtr idev, const InputAttributes * attrs)
{
    XF86ConfInputClassPtr cl;
    XF86OptionPtr classopts;

    for (cl = xf86configptr->conf_inputclass_lst; cl; cl = cl->list.next) {
        if (!InputClassMatches(cl, idev, attrs))
            continue;

        /* Collect class options and driver settings */
        classopts = xf86optionListDup(cl->option_lst);
        if (cl->driver) {
            free((void *) idev->driver);
            idev->driver = xstrdup(cl->driver);
            if (!idev->driver) {
                xf86Msg(X_ERROR, "Failed to allocate memory while merging "
                        "InputClass configuration");
                return BadAlloc;
            }
            classopts = xf86ReplaceStrOption(classopts, "driver", idev->driver);
        }

        /* Apply options to device with InputClass settings preferred. */
        xf86Msg(X_CONFIG, "%s: Applying InputClass \"%s\"\n",
                idev->name, cl->identifier);
        idev->options = xf86optionListMerge(idev->options, classopts);
    }

    return Success;
}

/*
 * Iterate the list of classes and look for Option "Ignore". Return the
 * value of the last matching class and holler when returning TRUE.
 */
static Bool
IgnoreInputClass(const InputInfoPtr idev, const InputAttributes * attrs)
{
    XF86ConfInputClassPtr cl;
    Bool ignore = FALSE;
    const char *ignore_class;

    for (cl = xf86configptr->conf_inputclass_lst; cl; cl = cl->list.next) {
        if (!InputClassMatches(cl, idev, attrs))
            continue;
        if (xf86findOption(cl->option_lst, "Ignore")) {
            ignore = xf86CheckBoolOption(cl->option_lst, "Ignore", FALSE);
            ignore_class = cl->identifier;
        }
    }

    if (ignore)
        xf86Msg(X_CONFIG, "%s: Ignoring device from InputClass \"%s\"\n",
                idev->name, ignore_class);
    return ignore;
}

InputInfoPtr
xf86AllocateInput(void)
{
    InputInfoPtr pInfo;

    pInfo = calloc(sizeof(*pInfo), 1);
    if (!pInfo)
        return NULL;

    pInfo->fd = -1;
    pInfo->type_name = "UNKNOWN";

    return pInfo;
}

/* Append InputInfoRec to the tail of xf86InputDevs. */
static void
xf86AddInput(InputDriverPtr drv, InputInfoPtr pInfo)
{
    InputInfoPtr *prev = NULL;

    pInfo->drv = drv;
    pInfo->module = DuplicateModule(drv->module, NULL);

    for (prev = &xf86InputDevs; *prev; prev = &(*prev)->next);

    *prev = pInfo;
    pInfo->next = NULL;

    xf86CollectInputOptions(pInfo, (const char **) drv->default_options);
    xf86OptionListReport(pInfo->options);
    xf86ProcessCommonOptions(pInfo, pInfo->options);
}

/*
 * Remove an entry from xf86InputDevs and free all the device's information.
 */
void
xf86DeleteInput(InputInfoPtr pInp, int flags)
{
    /* First check if the inputdev is valid. */
    if (pInp == NULL)
        return;

    if (pInp->module)
        UnloadModule(pInp->module);

    /* This should *really* be handled in drv->UnInit(dev) call instead, but
     * if the driver forgets about it make sure we free it or at least crash
     * with flying colors */
    free(pInp->private);

    FreeInputAttributes(pInp->attrs);

    if (pInp->flags & XI86_SERVER_FD)
        systemd_logind_release_fd(pInp->major, pInp->minor, pInp->fd);

    /* Remove the entry from the list. */
    if (pInp == xf86InputDevs)
        xf86InputDevs = pInp->next;
    else {
        InputInfoPtr p = xf86InputDevs;

        while (p && p->next != pInp)
            p = p->next;
        if (p)
            p->next = pInp->next;
        /* Else the entry wasn't in the xf86InputDevs list (ignore this). */
    }

    free((void *) pInp->driver);
    free((void *) pInp->name);
    xf86optionListFree(pInp->options);
    free(pInp);
}

/*
 * Apply backend-specific initialization. Invoked after ActivateDevice(),
 * i.e. after the driver successfully completed DEVICE_INIT and the device
 * is advertised.
 * @@param dev the device
 * @@return Success or an error code
 */
static int
xf86InputDevicePostInit(DeviceIntPtr dev)
{
    ApplyAccelerationSettings(dev);
    ApplyTransformationMatrix(dev);
    return Success;
}

static void
xf86stat(const char *path, int *maj, int *min)
{
    struct stat st;

    if (stat(path, &st) == -1)
        return;

    *maj = major(st.st_rdev);
    *min = minor(st.st_rdev);
}

/**
 * Create a new input device, activate and enable it.
 *
 * Possible return codes:
 *    BadName .. a bad driver name was supplied.
 *    BadImplementation ... The driver does not have a PreInit function. This
 *                          is a driver bug.
 *    BadMatch .. device initialization failed.
 *    BadAlloc .. too many input devices
 *
 * @@param idev The device, already set up with identifier, driver, and the
 * options.
 * @@param pdev Pointer to the new device, if Success was reported.
 * @@param enable Enable the device after activating it.
 *
 * @@return Success or an error code
 */
_X_INTERNAL int
xf86NewInputDevice(InputInfoPtr pInfo, DeviceIntPtr *pdev, BOOL enable)
{
    InputDriverPtr drv = NULL;
    DeviceIntPtr dev = NULL;
    Bool paused;
    int rval;
    char *path = NULL;

    /* Memory leak for every attached device if we don't
     * test if the module is already loaded first */
    drv = xf86LookupInputDriver(pInfo->driver);
    if (!drv)
        if (xf86LoadOneModule(pInfo->driver, NULL))
            drv = xf86LookupInputDriver(pInfo->driver);
    if (!drv) {
        xf86Msg(X_ERROR, "No input driver matching `%s'\n", pInfo->driver);
        rval = BadName;
        goto unwind;
    }

    path = xf86CheckStrOption(pInfo->options, "Device", NULL);
    if (path && pInfo->major == 0 && pInfo->minor == 0)
        xf86stat(path, &pInfo->major, &pInfo->minor);

    if (path && (drv->capabilities & XI86_DRV_CAP_SERVER_FD)){
        int fd = systemd_logind_take_fd(pInfo->major, pInfo->minor,
                                        path, &paused);
        if (fd != -1) {
            if (paused) {
                /* Put on new_input_devices list for delayed probe */
                new_input_devices = xnfreallocarray(new_input_devices,
                                                    new_input_devices_count + 1,
                                                    sizeof(pInfo));
                new_input_devices[new_input_devices_count] = pInfo;
                new_input_devices_count++;
                systemd_logind_release_fd(pInfo->major, pInfo->minor, fd);
                free(path);
                return BadMatch;
            }
            pInfo->fd = fd;
            pInfo->flags |= XI86_SERVER_FD;
            pInfo->options = xf86ReplaceIntOption(pInfo->options, "fd", fd);
        }
    }

    free(path);

    xf86Msg(X_INFO, "Using input driver '%s' for '%s'\n", drv->driverName,
            pInfo->name);

    if (!drv->PreInit) {
        xf86Msg(X_ERROR,
                "Input driver `%s' has no PreInit function (ignoring)\n",
                drv->driverName);
        rval = BadImplementation;
        goto unwind;
    }

    xf86AddInput(drv, pInfo);

    rval = drv->PreInit(drv, pInfo, 0);

    if (rval != Success) {
        xf86Msg(X_ERROR, "PreInit returned %d for \"%s\"\n", rval, pInfo->name);
        goto unwind;
    }

    if (!(dev = xf86ActivateDevice(pInfo))) {
        rval = BadAlloc;
        goto unwind;
    }

    rval = ActivateDevice(dev, TRUE);
    if (rval != Success) {
        xf86Msg(X_ERROR, "Couldn't init device \"%s\"\n", pInfo->name);
        RemoveDevice(dev, TRUE);
        goto unwind;
    }

    rval = xf86InputDevicePostInit(dev);
    if (rval != Success) {
        xf86Msg(X_ERROR, "Couldn't post-init device \"%s\"\n", pInfo->name);
        RemoveDevice(dev, TRUE);
        goto unwind;
    }

    /* Enable it if it's properly initialised and we're currently in the VT */
    if (enable && dev->inited && dev->startup && xf86VTOwner()) {
        OsBlockSignals();
        EnableDevice(dev, TRUE);
        if (!dev->enabled) {
            OsReleaseSignals();
            xf86Msg(X_ERROR, "Couldn't init device \"%s\"\n", pInfo->name);
            RemoveDevice(dev, TRUE);
            rval = BadMatch;
            goto unwind;
        }
        /* send enter/leave event, update sprite window */
        CheckMotion(NULL, dev);
        OsReleaseSignals();
    }

    *pdev = dev;
    return Success;

 unwind:
    if (pInfo) {
        if (drv && drv->UnInit)
            drv->UnInit(drv, pInfo, 0);
        else
            xf86DeleteInput(pInfo, 0);
    }
    return rval;
}

int
NewInputDeviceRequest(InputOption *options, InputAttributes * attrs,
                      DeviceIntPtr *pdev)
{
    InputInfoPtr pInfo = NULL;
    InputOption *option = NULL;
    int rval = Success;
    int is_auto = 0;

    pInfo = xf86AllocateInput();
    if (!pInfo)
        return BadAlloc;

    nt_list_for_each_entry(option, options, list.next) {
        const char *key = input_option_get_key(option);
        const char *value = input_option_get_value(option);

        if (strcasecmp(key, "driver") == 0) {
            if (pInfo->driver) {
                rval = BadRequest;
                goto unwind;
            }
            pInfo->driver = xstrdup(value);
            if (!pInfo->driver) {
                rval = BadAlloc;
                goto unwind;
            }
        }

        if (strcasecmp(key, "name") == 0 || strcasecmp(key, "identifier") == 0) {
            if (pInfo->name) {
                rval = BadRequest;
                goto unwind;
            }
            pInfo->name = xstrdup(value);
            if (!pInfo->name) {
                rval = BadAlloc;
                goto unwind;
            }
        }

        if (strcmp(key, "_source") == 0 &&
            (strcmp(value, "server/hal") == 0 ||
             strcmp(value, "server/udev") == 0 ||
             strcmp(value, "server/wscons") == 0)) {
            is_auto = 1;
            if (!xf86Info.autoAddDevices) {
                rval = BadMatch;
                goto unwind;
            }
        }

        if (strcmp(key, "major") == 0)
            pInfo->major = atoi(value);

        if (strcmp(key, "minor") == 0)
            pInfo->minor = atoi(value);
    }

    nt_list_for_each_entry(option, options, list.next) {
        /* Copy option key/value strings from the provided list */
        pInfo->options = xf86AddNewOption(pInfo->options,
                                          input_option_get_key(option),
                                          input_option_get_value(option));
    }

    /* Apply InputClass settings */
    if (attrs) {
        if (IgnoreInputClass(pInfo, attrs)) {
            rval = BadIDChoice;
            goto unwind;
        }

        rval = MergeInputClasses(pInfo, attrs);
        if (rval != Success)
            goto unwind;

        pInfo->attrs = DuplicateInputAttributes(attrs);
    }

    if (!pInfo->name) {
        xf86Msg(X_INFO, "No identifier specified, ignoring this device.\n");
        rval = BadRequest;
        goto unwind;
    }

    if (!pInfo->driver) {
        xf86Msg(X_INFO, "No input driver specified, ignoring this device.\n");
        xf86Msg(X_INFO,
                "This device may have been added with another device file.\n");
        rval = BadRequest;
        goto unwind;
    }

    rval = xf86NewInputDevice(pInfo, pdev,
                              (!is_auto ||
                               (is_auto && xf86Info.autoEnableDevices)));

    return rval;

 unwind:
    if (is_auto && !xf86Info.autoAddDevices)
        xf86Msg(X_INFO, "AutoAddDevices is off - not adding device.\n");
    xf86DeleteInput(pInfo, 0);
    return rval;
}

void
DeleteInputDeviceRequest(DeviceIntPtr pDev)
{
    InputInfoPtr pInfo = (InputInfoPtr) pDev->public.devicePrivate;
    InputDriverPtr drv = NULL;
    Bool isMaster = IsMaster(pDev);

    if (pInfo)                  /* need to get these before RemoveDevice */
        drv = pInfo->drv;

    OsBlockSignals();
    RemoveDevice(pDev, TRUE);

    if (!isMaster && pInfo != NULL) {
        if (drv->UnInit)
            drv->UnInit(drv, pInfo, 0);
        else
            xf86DeleteInput(pInfo, 0);
    }
    OsReleaseSignals();
}

/*
 * convenient functions to post events
 */

void
xf86PostMotionEvent(DeviceIntPtr device,
                    int is_absolute, int first_valuator, int num_valuators, ...)
{
    va_list var;
    int i = 0;
    ValuatorMask mask;

    XI_VERIFY_VALUATORS(num_valuators);

    valuator_mask_zero(&mask);
    va_start(var, num_valuators);
    for (i = 0; i < num_valuators; i++)
        valuator_mask_set(&mask, first_valuator + i, va_arg(var, int));

    va_end(var);

    xf86PostMotionEventM(device, is_absolute, &mask);
}

void
xf86PostMotionEventP(DeviceIntPtr device,
                     int is_absolute,
                     int first_valuator,
                     int num_valuators, const int *valuators)
{
    ValuatorMask mask;

    XI_VERIFY_VALUATORS(num_valuators);

    valuator_mask_set_range(&mask, first_valuator, num_valuators, valuators);
    xf86PostMotionEventM(device, is_absolute, &mask);
}

static int
xf86CheckMotionEvent4DGA(DeviceIntPtr device, int is_absolute,
                         const ValuatorMask *mask)
{
    int stolen = 0;

#if XFreeXDGA
    ScreenPtr scr = NULL;
    int idx = 0, i;

    /* The evdev driver may not always send all axes across. */
    if (valuator_mask_isset(mask, 0) || valuator_mask_isset(mask, 1)) {
        scr = miPointerGetScreen(device);
        if (scr) {
            int dx = 0, dy = 0;

            idx = scr->myNum;

            if (valuator_mask_isset(mask, 0)) {
                dx = valuator_mask_get(mask, 0);
                if (is_absolute)
                    dx -= device->last.valuators[0];
                else if (valuator_mask_has_unaccelerated(mask))
                    dx = valuator_mask_get_unaccelerated(mask, 0);
            }

            if (valuator_mask_isset(mask, 1)) {
                dy = valuator_mask_get(mask, 1);
                if (is_absolute)
                    dy -= device->last.valuators[1];
                else if (valuator_mask_has_unaccelerated(mask))
                    dy = valuator_mask_get_unaccelerated(mask, 1);
            }

            if (DGAStealMotionEvent(device, idx, dx, dy))
                stolen = 1;
        }
    }

    for (i = 2; i < valuator_mask_size(mask); i++) {
        AxisInfoPtr ax;
        double incr;
        int val, button;

        if (i >= device->valuator->numAxes)
            break;

        if (!valuator_mask_isset(mask, i))
            continue;

        ax = &device->valuator->axes[i];

        if (ax->scroll.type == SCROLL_TYPE_NONE)
            continue;

        if (!scr) {
            scr = miPointerGetScreen(device);
            if (!scr)
                break;
            idx = scr->myNum;
        }

        incr = ax->scroll.increment;
        val = valuator_mask_get(mask, i);

        if (ax->scroll.type == SCROLL_TYPE_VERTICAL) {
            if (incr * val < 0)
                button = 4; /* up */
            else
                button = 5; /* down */
        } else { /* SCROLL_TYPE_HORIZONTAL */
            if (incr * val < 0)
                button = 6; /* left */
            else
                button = 7; /* right */
        }

        if (DGAStealButtonEvent(device, idx, button, 1) &&
                DGAStealButtonEvent(device, idx, button, 0))
            stolen = 1;
    }

#endif

    return stolen;
}

void
xf86PostMotionEventM(DeviceIntPtr device,
                     int is_absolute, const ValuatorMask *mask)
{
    int flags = 0;

    if (xf86CheckMotionEvent4DGA(device, is_absolute, mask))
        return;

    if (valuator_mask_num_valuators(mask) > 0) {
        if (is_absolute)
            flags = POINTER_ABSOLUTE;
        else
            flags = POINTER_RELATIVE | POINTER_ACCELERATE;
    }

    QueuePointerEvents(device, MotionNotify, 0, flags, mask);
}

void
xf86PostProximityEvent(DeviceIntPtr device,
                       int is_in, int first_valuator, int num_valuators, ...)
{
    va_list var;
    int i;
    ValuatorMask mask;

    XI_VERIFY_VALUATORS(num_valuators);

    valuator_mask_zero(&mask);
    va_start(var, num_valuators);
    for (i = 0; i < num_valuators; i++)
        valuator_mask_set(&mask, first_valuator + i, va_arg(var, int));

    va_end(var);

    xf86PostProximityEventM(device, is_in, &mask);
}

void
xf86PostProximityEventP(DeviceIntPtr device,
                        int is_in,
                        int first_valuator,
                        int num_valuators, const int *valuators)
{
    ValuatorMask mask;

    XI_VERIFY_VALUATORS(num_valuators);

    valuator_mask_set_range(&mask, first_valuator, num_valuators, valuators);
    xf86PostProximityEventM(device, is_in, &mask);
}

void
xf86PostProximityEventM(DeviceIntPtr device,
                        int is_in, const ValuatorMask *mask)
{
    QueueProximityEvents(device, is_in ? ProximityIn : ProximityOut, mask);
}

void
xf86PostButtonEvent(DeviceIntPtr device,
                    int is_absolute,
                    int button,
                    int is_down, int first_valuator, int num_valuators, ...)
{
    va_list var;
    ValuatorMask mask;
    int i = 0;

    XI_VERIFY_VALUATORS(num_valuators);

    valuator_mask_zero(&mask);

    va_start(var, num_valuators);
    for (i = 0; i < num_valuators; i++)
        valuator_mask_set(&mask, first_valuator + i, va_arg(var, int));

    va_end(var);

    xf86PostButtonEventM(device, is_absolute, button, is_down, &mask);
}

void
xf86PostButtonEventP(DeviceIntPtr device,
                     int is_absolute,
                     int button,
                     int is_down,
                     int first_valuator,
                     int num_valuators, const int *valuators)
{
    ValuatorMask mask;

    XI_VERIFY_VALUATORS(num_valuators);

    valuator_mask_set_range(&mask, first_valuator, num_valuators, valuators);
    xf86PostButtonEventM(device, is_absolute, button, is_down, &mask);
}

void
xf86PostButtonEventM(DeviceIntPtr device,
                     int is_absolute,
                     int button, int is_down, const ValuatorMask *mask)
{
    int flags = 0;

    if (valuator_mask_num_valuators(mask) > 0) {
        if (is_absolute)
            flags = POINTER_ABSOLUTE;
        else
            flags = POINTER_RELATIVE | POINTER_ACCELERATE;
    }

#if XFreeXDGA
    if (miPointerGetScreen(device)) {
        int index = miPointerGetScreen(device)->myNum;

        if (DGAStealButtonEvent(device, index, button, is_down))
            return;
    }
#endif

    QueuePointerEvents(device,
                       is_down ? ButtonPress : ButtonRelease, button,
                       flags, mask);
}

void
xf86PostKeyEvent(DeviceIntPtr device, unsigned int key_code, int is_down)
{
    xf86PostKeyEventM(device, key_code, is_down);
}

void
xf86PostKeyEventP(DeviceIntPtr device,
                  unsigned int key_code,
                  int is_down)
{
    xf86PostKeyEventM(device, key_code, is_down);
}

void
xf86PostKeyEventM(DeviceIntPtr device, unsigned int key_code, int is_down)
{
#if XFreeXDGA
    DeviceIntPtr pointer;

    /* Some pointers send key events, paired device is wrong then. */
    pointer = GetMaster(device, POINTER_OR_FLOAT);

    if (miPointerGetScreen(pointer)) {
        int index = miPointerGetScreen(pointer)->myNum;

        if (DGAStealKeyEvent(device, index, key_code, is_down))
            return;
    }
#endif

    QueueKeyboardEvents(device, is_down ? KeyPress : KeyRelease, key_code);
}

void
xf86PostKeyboardEvent(DeviceIntPtr device, unsigned int key_code, int is_down)
{
    ValuatorMask mask;

    valuator_mask_zero(&mask);
    xf86PostKeyEventM(device, key_code, is_down);
}

InputInfoPtr
xf86FirstLocalDevice(void)
{
    return xf86InputDevs;
}

/*
 * Cx     - raw data from touch screen
 * to_max - scaled highest dimension
 *          (remember, this is of rows - 1 because of 0 origin)
 * to_min  - scaled lowest dimension
 * from_max - highest raw value from touch screen calibration
 * from_min  - lowest raw value from touch screen calibration
 *
 * This function is the same for X or Y coordinates.
 * You may have to reverse the high and low values to compensate for
 * different orgins on the touch screen vs X.
 *
 * e.g. to scale from device coordinates into screen coordinates, call
 * xf86ScaleAxis(x, 0, screen_width, dev_min, dev_max);
 */

int
xf86ScaleAxis(int Cx, int to_max, int to_min, int from_max, int from_min)
{
    int X;
    int64_t to_width = to_max - to_min;
    int64_t from_width = from_max - from_min;

    if (from_width) {
        X = (int) (((to_width * (Cx - from_min)) / from_width) + to_min);
    }
    else {
        X = 0;
        ErrorF("Divide by Zero in xf86ScaleAxis\n");
    }

    if (X > to_max)
        X = to_max;
    if (X < to_min)
        X = to_min;

    return X;
}

Bool
xf86InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval,
                           int maxval, int resolution, int min_res, int max_res,
                           int mode)
{
    if (!dev || !dev->valuator)
        return FALSE;

    return InitValuatorAxisStruct(dev, axnum, label, minval, maxval, resolution,
                                  min_res, max_res, mode);
}

/*
 * Set the valuator values to be in sync with dix/event.c
 * DefineInitialRootWindow().
 */
void
xf86InitValuatorDefaults(DeviceIntPtr dev, int axnum)
{
    if (axnum == 0) {
        dev->valuator->axisVal[0] = screenInfo.screens[0]->width / 2;
        dev->last.valuators[0] = dev->valuator->axisVal[0];
    }
    else if (axnum == 1) {
        dev->valuator->axisVal[1] = screenInfo.screens[0]->height / 2;
        dev->last.valuators[1] = dev->valuator->axisVal[1];
    }
}

/**
 * Deactivate a device. Call this function from the driver if you receive a
 * read error or something else that spoils your day.
 * Device will be moved to the off_devices list, but it will still be there
 * until you really clean up after it.
 * Notifies the client about an inactive device.
 *
 * @@param panic True if device is unrecoverable and needs to be removed.
 */
void
xf86DisableDevice(DeviceIntPtr dev, Bool panic)
{
    if (!panic) {
        DisableDevice(dev, TRUE);
    }
    else {
        SendDevicePresenceEvent(dev->id, DeviceUnrecoverable);
        DeleteInputDeviceRequest(dev);
    }
}

/**
 * Reactivate a device. Call this function from the driver if you just found
 * out that the read error wasn't quite that bad after all.
 * Device will be re-activated, and an event sent to the client.
 */
void
xf86EnableDevice(DeviceIntPtr dev)
{
    EnableDevice(dev, TRUE);
}

/**
 * Post a touch event with optional valuators.  If this is the first touch in
 * the sequence, at least x & y valuators must be provided. The driver is
 * responsible for maintaining the correct event sequence (TouchBegin, TouchUpdate,
 * TouchEnd). Submitting an update or end event for a unregistered touchid will
 * result in errors.
 * Touch IDs may be reused by the driver but only after a TouchEnd has been
 * submitted for that touch ID.
 *
 * @@param dev The device to post the event for
 * @@param touchid The touchid of the current touch event. Must be an
 * existing ID for TouchUpdate or TouchEnd events
 * @@param type One of XI_TouchBegin, XI_TouchUpdate, XI_TouchEnd
 * @@param flags Flags for this event
 * @@param The valuator mask with all valuators set for this event.
 */
void
xf86PostTouchEvent(DeviceIntPtr dev, uint32_t touchid, uint16_t type,
                   uint32_t flags, const ValuatorMask *mask)
{

    QueueTouchEvents(dev, type, touchid, flags, mask);
}

void
xf86InputEnableVTProbe(void)
{
    int i, is_auto = 0;
    InputOption *option = NULL;
    DeviceIntPtr pdev;

    for (i = 0; i < new_input_devices_count; i++) {
        InputInfoPtr pInfo = new_input_devices[i];

        is_auto = 0;
        nt_list_for_each_entry(option, pInfo->options, list.next) {
            const char *key = input_option_get_key(option);
            const char *value = input_option_get_value(option);

            if (strcmp(key, "_source") == 0 &&
                (strcmp(value, "server/hal") == 0 ||
                 strcmp(value, "server/udev") == 0 ||
                 strcmp(value, "server/wscons") == 0))
                is_auto = 1;
        }
        xf86NewInputDevice(pInfo, &pdev,
                                  (!is_auto ||
                                   (is_auto && xf86Info.autoEnableDevices)));
    }
    new_input_devices_count = 0;
}

/* end of xf86Xinput.c */
@


1.21
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d846 1
a846 1
    const char *path;
d870 3
a872 2
                new_input_devices = xnfrealloc(new_input_devices,
                            sizeof(pInfo) * (new_input_devices_count + 1));
d876 1
d885 2
d1144 2
d1152 2
d1337 1
a1337 4
xf86PostKeyEvent(DeviceIntPtr device,
                 unsigned int key_code,
                 int is_down,
                 int is_absolute, int first_valuator, int num_valuators, ...)
d1339 1
a1339 15
    va_list var;
    int i = 0;
    ValuatorMask mask;

    XI_VERIFY_VALUATORS(num_valuators);

    valuator_mask_zero(&mask);

    va_start(var, num_valuators);
    for (i = 0; i < num_valuators; i++)
        valuator_mask_set(&mask, first_valuator + i, va_arg(var, int));

    va_end(var);

    xf86PostKeyEventM(device, key_code, is_down, is_absolute, &mask);
d1345 1
a1345 3
                  int is_down,
                  int is_absolute,
                  int first_valuator, int num_valuators, const int *valuators)
d1347 1
a1347 6
    ValuatorMask mask;

    XI_VERIFY_VALUATORS(num_valuators);

    valuator_mask_set_range(&mask, first_valuator, num_valuators, valuators);
    xf86PostKeyEventM(device, key_code, is_down, is_absolute, &mask);
d1351 1
a1351 3
xf86PostKeyEventM(DeviceIntPtr device,
                  unsigned int key_code,
                  int is_down, int is_absolute, const ValuatorMask *mask)
d1367 1
a1367 2
    QueueKeyboardEvents(device,
                        is_down ? KeyPress : KeyRelease, key_code, mask);
d1376 1
a1376 1
    xf86PostKeyEventM(device, key_code, is_down, 0, &mask);
@


1.20
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d3 1
a3 1
 *                                                                            
d12 2
a13 2
 * is provided "as is" without express or implied warranty.                   
 *                                                                            
d318 1
a318 1
 * 
d1080 1
a1080 1
/* 
d1404 1
a1404 1
/* 
d1478 1
a1478 1
 * 
d1496 1
a1496 1
 * Device will be re-activated, and an event sent to the client. 
@


1.19
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d3 1
a3 1
 *
d12 2
a13 2
 * is provided "as is" without express or implied warranty.
 *
d66 1
d84 6
d113 3
d120 1
a120 1
ProcessVelocityConfiguration(DeviceIntPtr pDev, char *devname, pointer list,
d318 1
a318 1
 *
d674 1
a674 1
            free(idev->driver);
d773 3
d789 2
a790 2
    free(pInp->driver);
    free(pInp->name);
d810 12
d844 1
d846 1
d860 23
d1002 6
d1080 1
a1080 1
/*
d1126 1
a1126 1
    int idx, i;
d1404 1
a1404 1
/*
d1478 1
a1478 1
 *
d1496 1
a1496 1
 * Device will be re-activated, and an event sent to the client.
d1526 28
@


1.18
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d873 1
a873 1
    if (enable && dev->inited && dev->startup && xf86Screens[0]->vtSema) {
@


1.17
log
@Update to xserver 1.12.3.
@
text
@d3 1
a3 1
 *                                                                            
d12 2
a13 2
 * is provided "as is" without express or implied warranty.                   
 *                                                                            
d308 1
a308 1
 * 
d1024 1
a1024 1
/* 
d1348 1
a1348 1
/* 
d1422 1
a1422 1
 * 
d1440 1
a1440 1
 * Device will be re-activated, and an event sent to the client. 
@


1.16
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d1062 3
a1064 3
void
xf86PostMotionEventM(DeviceIntPtr device,
                     int is_absolute, const ValuatorMask *mask)
d1066 1
a1066 1
    int flags = 0;
d1068 3
a1070 6
    if (valuator_mask_num_valuators(mask) > 0) {
        if (is_absolute)
            flags = POINTER_ABSOLUTE;
        else
            flags = POINTER_RELATIVE | POINTER_ACCELERATE;
    }
a1071 1
#if XFreeXDGA
d1073 3
a1075 3
    if (valuator_mask_isset(mask, 0) || valuator_mask_isset(mask, 1))
        if (miPointerGetScreen(device)) {
            int index = miPointerGetScreen(device)->myNum;
d1078 2
d1092 26
a1117 2
            if (DGAStealMotionEvent(device, index, dx, dy))
                return;
d1119 21
d1141 19
@


1.15
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@d67 1
a67 1
#include "exevents.h"	/* AddInputDevice */
d71 1
d73 1
a73 1
#include <string.h>     /* InputClassMatches */
d82 1
a82 1
#include <stdint.h>          /* for int64_t */
d86 1
a86 1
#include <ptrveloc.h>          /* dix pointer acceleration */
d104 1
a104 1
xf86InputDevicePostInit(DeviceIntPtr dev);
d110 1
a110 1
ProcessVelocityConfiguration(DeviceIntPtr pDev, char* devname, pointer list,
d118 1
a118 1
    if(!s)
d142 1
a142 1
            s->statistics.profile_number);
d149 2
a150 1
    } else {
d162 2
a163 1
    } else {
d171 1
a171 1
	InitTrackers(s, tempi);
d180 3
a182 3
	xf86Msg(X_CONFIG, "%s: (accel) max rel. velocity difference: %.1f%%\n",
	        devname, tempf*100.0);
	s->max_rel_diff = tempf;
d199 2
a200 1
ApplyAccelerationSettings(DeviceIntPtr dev){
d203 2
a204 2
    InputInfoPtr pInfo = (InputInfoPtr)dev->public.devicePrivate;
    char* schemeStr;
d207 1
a207 1
	schemeStr = xf86SetStrOption(pInfo->options, "AccelerationScheme", "");
d209 1
a209 1
	scheme = dev->valuator->accelScheme.number;
d211 2
a212 2
	if (!xf86NameCmp(schemeStr, "predictable"))
	    scheme = PtrAccelPredictable;
d214 2
a215 2
	if (!xf86NameCmp(schemeStr, "lightweight"))
	    scheme = PtrAccelLightweight;
d217 2
a218 2
	if (!xf86NameCmp(schemeStr, "none"))
	    scheme = PtrAccelNoOp;
d227 7
a233 6
		xf86Msg(X_CONFIG, "%s: (accel) selected scheme %s/%i\n",
		        pInfo->name, schemeStr, scheme);
	    } else {
        	xf86Msg(X_CONFIG, "%s: (accel) could not init scheme %s\n",
		        pInfo->name, schemeStr);
        	scheme = dev->valuator->accelScheme.number;
d235 2
a236 1
        } else {
d245 5
a249 5
            case PtrAccelPredictable:
                pVel = GetDevicePredictableAccelData(dev);
                ProcessVelocityConfiguration (dev, pInfo->name, pInfo->options,
                                              pVel);
                break;
d268 2
a269 2
                            pInfo->name, ((float)dev->ptrfeed->ctrl.num)/
                                         ((float)dev->ptrfeed->ctrl.den));
d275 30
d314 1
a314 2
xf86ProcessCommonOptions(InputInfoPtr pInfo,
                         pointer	list)
d322 2
a323 1
    } else {
d341 2
a342 2
    DeviceIntPtr	dev;
    Atom		atom;
d346 2
a347 4
    if (dev == NULL)
    {
        xf86Msg(X_ERROR, "Too many input devices. Ignoring %s\n",
                pInfo->name);
d364 2
a365 1
        xf86Msg(X_INFO, "XINPUT: Adding extended input device \"%s\" (type: %s, id %d)\n",
d385 1
a385 1
SetDeviceMode (ClientPtr client, DeviceIntPtr dev, int mode)
d387 1
a387 1
  InputInfoPtr        pInfo = (InputInfoPtr)dev->public.devicePrivate;
d389 5
a393 5
  if (pInfo->switch_mode) {
    return (*pInfo->switch_mode)(client, dev, mode);
  }
  else
    return BadMatch;
a395 1

d410 2
a411 2
SetDeviceValuators (ClientPtr client, DeviceIntPtr dev, int *valuators,
                    int first_valuator, int num_valuators)
d416 2
a417 2
	return (*pInfo->set_device_valuators)(pInfo, valuators, first_valuator,
					      num_valuators);
a421 1

d432 1
a432 1
ChangeDeviceControl (ClientPtr client, DeviceIntPtr dev, xDeviceCtl *control)
d434 1
a434 1
  InputInfoPtr        pInfo = (InputInfoPtr)dev->public.devicePrivate;
d436 16
a451 16
  if (!pInfo->control_proc) {
      switch (control->control) {
      case DEVICE_CORE:
      case DEVICE_ABS_CALIB:
      case DEVICE_ABS_AREA:
          return BadMatch;
      case DEVICE_RESOLUTION:
      case DEVICE_ENABLE:
        return Success;
      default:
        return BadMatch;
      }
  }
  else {
      return (*pInfo->control_proc)(pInfo, control);
  }
d467 1
a467 1
            strcpy(host_os, name.sysname);
d469 1
a469 2
            strncpy(host_os, "unknown", sizeof(host_os));
            host_os[sizeof(host_os)-1] = '\0';
d513 3
a515 2
    } else {
        return strcmp(attr,"(implicit)");
d524 2
a525 2
MatchAttrToken(const char *attr, struct list *patterns,
               int (*compare)(const char *attr, const char *pattern))
d530 1
a530 1
    if (list_is_empty(patterns))
d541 2
a542 2
    list_for_each_entry(group, patterns, entry) {
        char * const *cur;
d546 1
a546 1
            if ((*compare)(attr, *cur) == 0) {
d564 1
a564 1
                  const InputAttributes *attrs)
d567 2
a568 1
    if (!MatchAttrToken(attrs->product, &iclass->match_product, match_substring))
d576 2
a577 1
    if (!MatchAttrToken(attrs->device, &iclass->match_device, match_path_pattern))
d600 2
a601 2
    if (!list_is_empty(&iclass->match_tag)) {
        char * const *tag;
d617 1
a617 1
    if (!list_is_empty(&iclass->match_layout)) {
d625 1
a625 1
        iclass->is_keyboard.val != !!(attrs->flags & ATTR_KEYBOARD))
d628 1
a628 1
        iclass->is_pointer.val != !!(attrs->flags & ATTR_POINTER))
d631 1
a631 1
        iclass->is_joystick.val != !!(attrs->flags & ATTR_JOYSTICK))
d634 1
a634 1
        iclass->is_tablet.val != !!(attrs->flags & ATTR_TABLET))
d637 1
a637 1
        iclass->is_touchpad.val != !!(attrs->flags & ATTR_TOUCHPAD))
d640 1
a640 1
        iclass->is_touchscreen.val != !!(attrs->flags & ATTR_TOUCHSCREEN))
d652 1
a652 1
MergeInputClasses(const InputInfoPtr idev, const InputAttributes *attrs)
d671 1
a671 2
            classopts = xf86ReplaceStrOption(classopts, "driver",
                                             idev->driver);
d688 1
a688 1
IgnoreInputClass(const InputInfoPtr idev, const InputAttributes *attrs)
d733 1
a733 2
    for (prev = &xf86InputDevs; *prev; prev = &(*prev)->next)
        ;
d738 1
a738 1
    xf86CollectInputOptions(pInfo, (const char**)drv->default_options);
d751 1
a751 1
	return;
d754 1
a754 1
	UnloadModule(pInp->module);
d765 1
a765 1
	xf86InputDevs = pInp->next;
d767 7
a773 6
	InputInfoPtr p = xf86InputDevs;
	while (p && p->next != pInp)
	    p = p->next;
	if (p)
	    p->next = pInp->next;
	/* Else the entry wasn't in the xf86InputDevs list (ignore this). */
d783 1
a783 1
 * Apply backend-specific initialization. Invoked after ActiveteDevice(),
d790 2
a791 1
xf86InputDevicePostInit(DeviceIntPtr dev) {
d793 1
d833 2
a834 1
    xf86Msg(X_INFO, "Using input driver '%s' for '%s'\n", drv->driverName, pInfo->name);
d853 1
a853 2
    if (!(dev = xf86ActivateDevice(pInfo)))
    {
d859 1
a859 2
    if (rval != Success)
    {
d866 4
a869 5
    if (rval != Success)
    {
	xf86Msg(X_ERROR, "Couldn't post-init device \"%s\"\n", pInfo->name);
	RemoveDevice(dev, TRUE);
	goto unwind;
d873 1
a873 2
    if (enable && dev->inited && dev->startup && xf86Screens[0]->vtSema)
    {
d876 1
a876 2
        if (!dev->enabled)
        {
d891 3
a893 3
unwind:
    if(pInfo) {
        if(drv && drv->UnInit)
d902 2
a903 2
NewInputDeviceRequest (InputOption *options, InputAttributes *attrs,
                       DeviceIntPtr *pdev)
d914 5
a918 2
    for (option = options; option; option = option->next) {
        if (strcasecmp(option->key, "driver") == 0) {
d923 1
a923 1
            pInfo->driver = xstrdup(option->value);
d930 1
a930 2
        if (strcasecmp(option->key, "name") == 0 ||
            strcasecmp(option->key, "identifier") == 0) {
d935 1
a935 1
            pInfo->name = xstrdup(option->value);
d942 4
a945 4
        if (strcmp(option->key, "_source") == 0 &&
            (strcmp(option->value, "server/hal") == 0 ||
             strcmp(option->value, "server/udev") == 0 ||
	     strcmp(option->value, "server/wscons") == 0)) {
d954 5
a958 7
    for (option = options; option; option = option->next) {
        /* Steal option key/value strings from the provided list.
         * We need those strings, the InputOption list doesn't. */
        pInfo->options = xf86addNewOption(pInfo->options,
                                               option->key, option->value);
        option->key = NULL;
        option->value = NULL;
d983 2
a984 1
        xf86Msg(X_INFO, "This device may have been added with another device file.\n");
d990 2
a991 1
                (!is_auto || (is_auto && xf86Info.autoEnableDevices)));
d995 1
a995 1
unwind:
d1009 1
a1009 1
    if (pInfo) /* need to get these before RemoveDevice */
d1015 2
a1016 3
    if (!isMaster && pInfo != NULL)
    {
        if(drv->UnInit)
d1029 2
a1030 5
xf86PostMotionEvent(DeviceIntPtr	device,
                    int			is_absolute,
                    int			first_valuator,
                    int			num_valuators,
                    ...)
d1042 1
d1049 4
a1052 5
xf86PostMotionEventP(DeviceIntPtr	device,
                    int			is_absolute,
                    int			first_valuator,
                    int			num_valuators,
                    const int		*valuators)
d1063 2
a1064 3
xf86PostMotionEventM(DeviceIntPtr	device,
                     int		is_absolute,
                     const ValuatorMask	*mask)
d1068 1
a1068 2
    if (valuator_mask_num_valuators(mask) > 0)
    {
d1077 1
a1077 2
    if (valuator_mask_isset(mask, 0) ||
        valuator_mask_isset(mask, 1))
d1082 1
a1082 2
            if (valuator_mask_isset(mask, 0))
            {
d1088 1
a1088 2
            if (valuator_mask_isset(mask, 1))
            {
d1103 2
a1104 5
xf86PostProximityEvent(DeviceIntPtr	device,
                       int		is_in,
                       int		first_valuator,
                       int		num_valuators,
                       ...)
d1116 1
d1123 4
a1126 5
xf86PostProximityEventP(DeviceIntPtr	device,
                        int		is_in,
                        int		first_valuator,
                        int		num_valuators,
                        const int	*valuators)
d1137 2
a1138 3
xf86PostProximityEventM(DeviceIntPtr	device,
                        int		is_in,
                        const ValuatorMask *mask)
d1144 4
a1147 7
xf86PostButtonEvent(DeviceIntPtr	device,
                    int			is_absolute,
                    int			button,
                    int			is_down,
                    int			first_valuator,
                    int			num_valuators,
                    ...)
d1160 1
d1167 6
a1172 7
xf86PostButtonEventP(DeviceIntPtr	device,
                     int		is_absolute,
                     int		button,
                     int		is_down,
                     int		first_valuator,
                     int		num_valuators,
                     const int		*valuators)
d1183 3
a1185 5
xf86PostButtonEventM(DeviceIntPtr	device,
                     int		is_absolute,
                     int		button,
                     int		is_down,
                     const ValuatorMask	*mask)
d1189 1
a1189 2
    if (valuator_mask_num_valuators(mask) > 0)
    {
d1211 4
a1214 7
xf86PostKeyEvent(DeviceIntPtr	device,
                 unsigned int	key_code,
                 int		is_down,
                 int		is_absolute,
                 int		first_valuator,
                 int		num_valuators,
                 ...)
d1227 1
d1234 5
a1238 7
xf86PostKeyEventP(DeviceIntPtr	device,
                  unsigned int	key_code,
                  int		is_down,
                  int		is_absolute,
                  int		first_valuator,
                  int		num_valuators,
                  const int	*valuators)
d1249 3
a1251 5
xf86PostKeyEventM(DeviceIntPtr	device,
                  unsigned int	key_code,
                  int		is_down,
                  int		is_absolute,
                  const ValuatorMask *mask)
d1257 2
a1258 1
    pointer = IsPointerDevice(device) ? device : GetPairedDevice(device);
d1268 1
a1268 2
                        is_down ? KeyPress : KeyRelease,
                        key_code, mask);
d1272 1
a1272 3
xf86PostKeyboardEvent(DeviceIntPtr      device,
                      unsigned int      key_code,
                      int               is_down)
d1303 1
a1303 5
xf86ScaleAxis(int	Cx,
              int	to_max,
              int	to_min,
              int	from_max,
              int	from_min )
d1310 1
a1310 1
	X = (int)(((to_width * (Cx - from_min)) / from_width) + to_min);
d1313 2
a1314 2
	X = 0;
	ErrorF ("Divide by Zero in xf86ScaleAxis\n");
d1316 1
a1316 1
    
d1318 1
a1318 1
	X = to_max;
d1320 2
a1321 2
	X = to_min;
    
d1325 4
a1328 22
/*
 * This function checks the given screen against the current screen and
 * makes changes if appropriate. It should be called from an XInput driver's
 * ReadInput function before any events are posted, if the device is screen
 * specific like a touch screen.
 */
void
xf86XInputSetScreen(InputInfoPtr	pInfo,
		    int			screen_number,
		    int			x,
		    int			y)
{
    if (miPointerGetScreen(pInfo->dev) !=
          screenInfo.screens[screen_number]) {
	miPointerSetScreen(pInfo->dev, screen_number, x, y);
    }
}


void
xf86InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval, int maxval,
			   int resolution, int min_res, int max_res, int mode)
d1331 1
a1331 1
        return;
d1333 2
a1334 2
    InitValuatorAxisStruct(dev, axnum, label, minval, maxval, resolution, min_res,
			   max_res, mode);
d1338 1
a1338 1
 * Set the valuator values to be in synch with dix/event.c
d1345 1
a1345 1
	dev->valuator->axisVal[0] = screenInfo.screens[0]->width / 2;
d1349 1
a1349 1
	dev->valuator->axisVal[1] = screenInfo.screens[0]->height / 2;
a1353 1

d1366 1
a1366 2
    if(!panic)
    {
d1368 2
a1369 2
    } else
    {
d1384 24
@


1.14
log
@Update to xserver 1.11.2
@
text
@d943 2
a944 2
    if (!pInfo->driver || !pInfo->name) {
        xf86Msg(X_INFO, "No input driver/identifier specified (ignoring)\n");
d949 4
a952 3
    if (!pInfo->name) {
        xf86Msg(X_ERROR, "No device identifier specified (ignoring)\n");
        rval = BadMatch;
@


1.13
log
@Introduce new autoconfiguration code for X input drivers, based on X
hotplug framework.This also takes care of the configuration of the
keyboard layout from the wscons layout that was hacked inside the
keyboard driver.

Tested by many, ok oga@@.
@
text
@a61 1
#include "XIstubs.h"
a62 1
#include "xf86Parser.h"
a63 2
#include "xf86InPriv.h"
#include "compiler.h"
a66 5
#ifdef DPMSExtension
#include <X11/extensions/dpmsconst.h>
#include "dpmsproc.h"
#endif

d70 1
a79 4
#include "extnsionst.h"

#include "windowstr.h"	/* screenIsSaved */

a82 2
#include <X11/Xpoll.h>

d94 7
a100 1
#include "os.h"
d102 2
a103 1
EventListPtr xf86Events = NULL;
d199 1
a199 1
    LocalDevicePtr local = (LocalDevicePtr)dev->public.devicePrivate;
d203 1
a203 1
	schemeStr = xf86SetStrOption(local->options, "AccelerationScheme", "");
d224 1
a224 1
		        local->name, schemeStr, scheme);
d227 1
a227 1
        	        local->name, schemeStr);
d232 1
a232 1
                    local->name, scheme);
d241 1
a241 1
                ProcessVelocityConfiguration (dev, local->name, local->options,
d246 1
a246 1
        i = xf86SetIntOption(local->options, "AccelerationNumerator",
d251 1
a251 1
        i = xf86SetIntOption(local->options, "AccelerationDenominator",
d256 1
a256 1
        i = xf86SetIntOption(local->options, "AccelerationThreshold",
d262 1
a262 1
                            local->name, ((float)dev->ptrfeed->ctrl.num)/
d265 1
a265 1
                local->name, dev->ptrfeed->ctrl.threshold);
a268 11
static Bool
xf86SendDragEvents(DeviceIntPtr	device)
{
    LocalDevicePtr local = (LocalDevicePtr) device->public.devicePrivate;
    
    if (device->button && device->button->buttonsDown > 0)
        return local->flags & XI86_SEND_DRAG_EVENTS;
    else
        return TRUE;
}

d278 1
a278 1
xf86ProcessCommonOptions(LocalDevicePtr local,
d281 2
a282 1
    if (!xf86SetBoolOption(list, "AlwaysCore", 1) ||
d286 1
a286 1
        xf86Msg(X_CONFIG, "%s: doesn't report core events\n", local->name);
d288 2
a289 2
        local->flags |= XI86_ALWAYS_CORE;
        xf86Msg(X_CONFIG, "%s: always reports core events\n", local->name);
a290 9

    if (xf86SetBoolOption(list, "SendDragEvents", 1)) {
        local->flags |= XI86_SEND_DRAG_EVENTS;
    } else {
        xf86Msg(X_CONFIG, "%s: doesn't report drag events\n", local->name);
    }

    /* Backwards compatibility. */
    local->history_size = GetMotionHistorySize();
d302 2
a303 2
int
xf86ActivateDevice(LocalDevicePtr local)
d306 1
d308 1
a308 2
    if (local->flags & XI86_CONFIGURED) {
        dev = AddInputDevice(serverClient, local->device_control, TRUE);
d310 6
a315 28
        if (dev == NULL)
        {
            xf86Msg(X_ERROR, "Too many input devices. Ignoring %s\n",
                    local->name);
            local->dev = NULL;
            return FALSE;
        }

        local->atom = MakeAtom(local->type_name,
                               strlen(local->type_name),
                               TRUE);
        AssignTypeAndName(dev, local->atom, local->name);
        dev->public.devicePrivate = (pointer) local;
        local->dev = dev;      
        
        dev->coreEvents = local->flags & XI86_ALWAYS_CORE; 
        dev->type = SLAVE;
        dev->spriteInfo->spriteOwner = FALSE;

        dev->deviceGrab.ActivateGrab = ActivateKeyboardGrab;
        dev->deviceGrab.DeactivateGrab = DeactivateKeyboardGrab;

        RegisterOtherDevice(dev);
        XkbSetExtension(dev, ProcessKeyboardEvent);

        if (serverGeneration == 1) 
            xf86Msg(X_INFO, "XINPUT: Adding extended input device \"%s\" (type: %s)\n",
                    local->name, local->type_name);
d318 4
a321 3
    return TRUE;
}

d323 3
a325 22
/***********************************************************************
 *
 * Caller:	ProcXOpenDevice
 *
 * This is the implementation-dependent routine to open an input device.
 * Some implementations open all input devices when the server is first
 * initialized, and never close them.  Other implementations open only
 * the X pointer and keyboard devices during server initialization,
 * and only open other input devices when some client makes an
 * XOpenDevice request.  This entry point is for the latter type of 
 * implementation.
 *
 * If the physical device is not already open, do it here.  In this case,
 * you need to keep track of the fact that one or more clients has the
 * device open, and physically close it when the last client that has
 * it open does an XCloseDevice.
 *
 * The default implementation is to do nothing (assume all input devices
 * are opened during X server initialization and kept open).
 *
 ***********************************************************************
 */
d327 1
a327 7
void
OpenInputDevice(DeviceIntPtr	dev,
                ClientPtr	client,
                int		*status)
{
    if (!dev->inited)
        ActivateDevice(dev, TRUE);
d329 3
a331 2
    *status = Success;
}
d333 1
a333 4
void
CloseInputDevice(DeviceIntPtr dev,
                 ClientPtr client)
{
d352 1
a352 1
  LocalDevicePtr        local = (LocalDevicePtr)dev->public.devicePrivate;
d354 2
a355 2
  if (local->switch_mode) {
    return (*local->switch_mode)(client, dev, mode);
d379 1
a379 1
    LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;
d381 2
a382 2
    if (local->set_device_valuators)
	return (*local->set_device_valuators)(local, valuators, first_valuator,
d401 1
a401 1
  LocalDevicePtr        local = (LocalDevicePtr)dev->public.devicePrivate;
d403 1
a403 1
  if (!local->control_proc) {
d406 2
a409 2
      case DEVICE_ABS_CALIB:
      case DEVICE_ABS_AREA:
d417 1
a417 1
      return (*local->control_proc)(local, control);
a420 5
void
AddOtherInputDevices(void)
{
}

d473 14
d530 1
a530 1
InputClassMatches(const XF86ConfInputClassPtr iclass, const IDevPtr idev,
d581 7
d617 1
a617 1
MergeInputClasses(const IDevPtr idev, const InputAttributes *attrs)
d642 2
a643 3
                idev->identifier, cl->identifier);
        idev->commonOptions = xf86optionListMerge(idev->commonOptions,
                                                  classopts);
d654 1
a654 1
IgnoreInputClass(const IDevPtr idev, const InputAttributes *attrs)
d671 1
a671 1
                idev->identifier, ignore_class);
d675 86
d779 1
a779 1
xf86NewInputDevice(IDevPtr idev, DeviceIntPtr *pdev, BOOL enable)
a781 1
    InputInfoPtr pInfo = NULL;
d787 1
a787 1
    drv = xf86LookupInputDriver(idev->driver);
d789 2
a790 2
        if (xf86LoadOneModule(idev->driver, NULL))
            drv = xf86LookupInputDriver(idev->driver);
d792 1
a792 1
        xf86Msg(X_ERROR, "No input driver matching `%s'\n", idev->driver);
d797 2
d807 3
a809 1
    pInfo = drv->PreInit(drv, idev, 0);
d811 2
a812 9
    if (!pInfo) {
        xf86Msg(X_ERROR, "PreInit returned NULL for \"%s\"\n", idev->identifier);
        rval = BadMatch;
        goto unwind;
    }
    else if (!(pInfo->flags & XI86_CONFIGURED)) {
        xf86Msg(X_ERROR, "PreInit failed for input device \"%s\"\n",
                idev->identifier);
        rval = BadMatch;
d816 1
a816 1
    if (!xf86ActivateDevice(pInfo))
a821 1
    dev = pInfo->dev;
d825 1
a825 1
        xf86Msg(X_ERROR, "Couldn't init device \"%s\"\n", idev->identifier);
d830 8
d841 1
d845 3
a847 1
            xf86Msg(X_ERROR, "Couldn't init device \"%s\"\n", idev->identifier);
d853 1
d861 1
a861 1
        if(drv->UnInit)
d873 1
a873 1
    IDevRec *idev = NULL;
d878 2
a879 2
    idev = calloc(sizeof(*idev), 1);
    if (!idev)
d884 1
a884 1
            if (idev->driver) {
d888 2
a889 2
            idev->driver = xstrdup(option->value);
            if (!idev->driver) {
d897 1
a897 1
            if (idev->identifier) {
d901 2
a902 2
            idev->identifier = xstrdup(option->value);
            if (!idev->identifier) {
d923 1
a923 1
        idev->commonOptions = xf86addNewOption(idev->commonOptions,
d931 1
a931 1
        if (IgnoreInputClass(idev, attrs)) {
d936 1
a936 1
        rval = MergeInputClasses(idev, attrs);
d940 1
a940 1
        idev->attrs = DuplicateInputAttributes(attrs);
d943 1
a943 1
    if (!idev->driver || !idev->identifier) {
d949 1
a949 1
    if (!idev->identifier) {
d951 2
a952 1
        return BadMatch;
d955 1
a955 1
    rval = xf86NewInputDevice(idev, pdev,
d957 2
a958 2
    if (rval == Success)
        return Success;
d963 1
a963 4
    free(idev->driver);
    free(idev->identifier);
    xf86optionListFree(idev->commonOptions);
    free(idev);
d970 1
a970 1
    LocalDevicePtr pInfo = (LocalDevicePtr) pDev->public.devicePrivate;
a971 2
    IDevRec *idev = NULL;
    IDevPtr *it;
a974 1
    {
a975 2
        idev = pInfo->conf_idev;
    }
a985 13

        /* devices added through HAL aren't in the config layout */
        it = xf86ConfigLayout.inputs;
        while(*it && *it != idev)
            it++;

        if (!(*it)) /* end of list, not in the layout */
        {
            free(idev->driver);
            free(idev->identifier);
            xf86optionListFree(idev->commonOptions);
            free(idev);
        }
d1003 1
a1003 1
    static int valuators[MAX_VALUATORS];
d1007 1
d1010 1
a1010 1
        valuators[i] = va_arg(var, int);
d1013 1
a1013 1
    xf86PostMotionEventP(device, is_absolute, first_valuator, num_valuators, valuators);
d1021 1
a1021 1
                    int			*valuators)
d1023 3
a1025 4
    int i = 0, nevents = 0;
    Bool drag = xf86SendDragEvents(device);
    DeviceEvent *event;
    int flags = 0;
d1027 3
a1029 4
#if XFreeXDGA
    int index;
    int dx = 0, dy = 0;
#endif
d1031 6
a1036 1
    XI_VERIFY_VALUATORS(num_valuators);
d1038 7
a1044 4
    if (is_absolute)
        flags = POINTER_ABSOLUTE;
    else
        flags = POINTER_RELATIVE | POINTER_ACCELERATE;
d1048 2
a1049 1
    if (num_valuators >= 1 && first_valuator <= 1) {
d1051 4
a1054 2
            index = miPointerGetScreen(device)->myNum;
            if (first_valuator == 0)
d1056 1
a1056 1
                dx = valuators[0];
d1061 1
a1061 1
            if (first_valuator == 1 || num_valuators >= 2)
d1063 1
a1063 1
                dy = valuators[1 - first_valuator];
a1070 1
    }
d1073 1
a1073 13
    nevents = GetPointerEvents(xf86Events, device, MotionNotify, 0,
                               flags, first_valuator, num_valuators,
                               valuators);

    for (i = 0; i < nevents; i++) {
        event = (DeviceEvent*)((xf86Events + i)->event);
        /* Don't post core motion events for devices not registered to send
         * drag events. */
        if (event->header == ET_Internal &&
            (event->type != ET_Motion || drag)) {
            mieqEnqueue(device, (InternalEvent*)((xf86Events + i)->event));
        }
    }
d1085 1
a1085 1
    int valuators[MAX_VALUATORS];
d1089 1
d1092 1
a1092 1
        valuators[i] = va_arg(var, int);
d1095 1
a1095 3
    xf86PostProximityEventP(device, is_in, first_valuator, num_valuators,
			    valuators);

d1103 1
a1103 1
                        int		*valuators)
d1105 1
a1105 1
    int i, nevents;
d1109 3
a1111 5
    nevents = GetProximityEvents(xf86Events, device,
                                 is_in ? ProximityIn : ProximityOut, 
                                 first_valuator, num_valuators, valuators);
    for (i = 0; i < nevents; i++)
        mieqEnqueue(device, (InternalEvent*)((xf86Events + i)->event));
d1113 6
d1131 1
a1131 1
    int valuators[MAX_VALUATORS];
d1136 2
d1140 1
a1140 1
        valuators[i] = va_arg(var, int);
d1143 1
a1143 3
    xf86PostButtonEventP(device, is_absolute, button, is_down, first_valuator,
			 num_valuators, valuators);

d1153 1
a1153 1
                     int		*valuators)
d1155 3
a1157 2
    int i = 0, nevents = 0;
    int flags = 0;
d1159 3
a1161 3
#if XFreeXDGA
    int index;
#endif
d1163 8
a1170 1
    XI_VERIFY_VALUATORS(num_valuators);
d1172 7
a1178 4
    if (is_absolute)
        flags = POINTER_ABSOLUTE;
    else
        flags = POINTER_RELATIVE | POINTER_ACCELERATE;
d1182 2
a1183 1
        index = miPointerGetScreen(device)->myNum;
d1189 3
a1191 7
    nevents = GetPointerEvents(xf86Events, device,
                               is_down ? ButtonPress : ButtonRelease, button,
                               flags, first_valuator, num_valuators, valuators);

    for (i = 0; i < nevents; i++)
        mieqEnqueue(device, (InternalEvent*)((xf86Events + i)->event));

d1205 1
a1205 1
    static int valuators[MAX_VALUATORS];
d1209 2
d1213 1
a1213 1
      valuators[i] = va_arg(var, int);
d1216 1
a1216 3
    xf86PostKeyEventP(device, key_code, is_down, is_absolute, first_valuator,
		      num_valuators, valuators);

d1226 1
a1226 1
                  int		*valuators)
d1228 1
a1228 1
    int i = 0, nevents = 0;
d1232 21
a1252 10
    if (is_absolute) {
        nevents = GetKeyboardValuatorEvents(xf86Events, device,
                                            is_down ? KeyPress : KeyRelease,
                                            key_code, first_valuator,
                                            num_valuators, valuators);
    }
    else {
        nevents = GetKeyboardEvents(xf86Events, device,
                                    is_down ? KeyPress : KeyRelease,
                                    key_code);
d1254 1
d1256 3
a1258 2
    for (i = 0; i < nevents; i++)
        mieqEnqueue(device, (InternalEvent*)((xf86Events + i)->event));
d1266 4
a1269 1
    xf86PostKeyEventP(device, key_code, is_down, 0, 0, 0, NULL);
d1272 1
a1272 1
LocalDevicePtr
d1280 1
a1280 1
 * Sxhigh - scaled highest dimension
d1282 3
a1284 3
 * Sxlow  - scaled lowest dimension
 * Rxhigh - highest raw value from touch screen calibration
 * Rxlow  - lowest raw value from touch screen calibration
d1289 3
d1296 4
a1299 4
              int	Sxhigh,
              int	Sxlow,
              int	Rxhigh,
              int	Rxlow )
d1302 2
a1303 2
    int64_t dSx = Sxhigh - Sxlow;
    int64_t dRx = Rxhigh - Rxlow;
d1305 2
a1306 2
    if (dRx) {
	X = (int)(((dSx * (Cx - Rxlow)) / dRx) + Sxlow);
d1313 4
a1316 4
    if (X > Sxhigh)
	X = Sxhigh;
    if (X < Sxlow)
	X = Sxlow;
d1328 1
a1328 1
xf86XInputSetScreen(LocalDevicePtr	local,
d1333 1
a1333 1
    if (miPointerGetScreen(local->dev) !=
d1335 1
a1335 1
	miPointerSetScreen(local->dev, screen_number, x, y);
d1342 1
a1342 1
			   int resolution, int min_res, int max_res)
d1348 1
a1348 1
			   max_res);
a1365 3

    if(axnum == 0)  /* to prevent double invocation */
	ApplyAccelerationSettings(dev);
@


1.12
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d876 2
a877 1
             strcmp(option->value, "server/udev") == 0)) {
@


1.11
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d1268 1
a1268 1
	ErrorF ("Divide by Zero in xf86ScaleAxis");
@


1.10
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d69 1
d84 3
d242 1
a242 1
        xfree(schemeStr);
a267 3
        /* mostly a no-op anyway */
        (*dev->ptrfeed->CtrlProc)(dev, &dev->ptrfeed->ctrl);

d282 1
a282 1
        return (local->flags & XI86_SEND_DRAG_EVENTS);
d284 1
a284 1
        return (TRUE);
d501 2
a502 2
 * Classes without any Match statements match all devices. Otherwise, all
 * statements must match.
d504 23
a526 2
static Bool
InputClassMatches(XF86ConfInputClassPtr iclass, InputAttributes *attrs)
d528 12
a539 2
    char **cur;
    Bool match;
a540 29
    if (iclass->match_product) {
        if (!attrs->product)
            return FALSE;
        /* see if any of the values match */
        for (cur = iclass->match_product, match = FALSE; *cur; cur++)
            if (strstr(attrs->product, *cur)) {
                match = TRUE;
                break;
            }
        if (!match)
            return FALSE;
    }
    if (iclass->match_vendor) {
        if (!attrs->vendor)
            return FALSE;
        /* see if any of the values match */
        for (cur = iclass->match_vendor, match = FALSE; *cur; cur++)
            if (strstr(attrs->vendor, *cur)) {
                match = TRUE;
                break;
            }
        if (!match)
            return FALSE;
    }
    if (iclass->match_device) {
        if (!attrs->device)
            return FALSE;
        /* see if any of the values match */
        for (cur = iclass->match_device, match = FALSE; *cur; cur++)
d542 5
a546 1
            if (fnmatch(*cur, attrs->device, FNM_PATHNAME) == 0) {
d548 1
a548 1
            if (strstr(attrs->device, *cur)) {
d550 29
d585 49
a633 1
    if (iclass->match_tag) {
d636 4
a639 8

        for (cur = iclass->match_tag, match = FALSE; *cur && !match; cur++) {
            char * const *tag;
            for(tag = attrs->tags; *tag; tag++) {
                if (!strcmp(*tag, *cur)) {
                    match = TRUE;
                    break;
                }
a641 1

d646 1
d665 1
d675 1
a675 1
MergeInputClasses(IDevPtr idev, InputAttributes *attrs)
d678 1
a678 2
    XF86OptionPtr classopts, mergedopts = NULL;
    char *classdriver = NULL;
d681 1
a681 1
        if (!InputClassMatches(cl, attrs))
d684 15
a698 1
        /* Collect class options and merge over previous classes */
d701 2
a702 4
        if (cl->driver)
            classdriver = cl->driver;
        classopts = xf86optionListDup(cl->option_lst);
        mergedopts = xf86optionListMerge(mergedopts, classopts);
a704 13
    /* Apply options to device with InputClass settings preferred. */
    if (classdriver) {
        xfree(idev->driver);
        idev->driver = xstrdup(classdriver);
        if (!idev->driver) {
            xf86Msg(X_ERROR, "Failed to allocate memory while merging "
                    "InputClass configuration");
            return BadAlloc;
        }
        mergedopts = xf86ReplaceStrOption(mergedopts, "driver", idev->driver);
    }
    idev->commonOptions = xf86optionListMerge(idev->commonOptions, mergedopts);

d713 1
a713 1
IgnoreInputClass(IDevPtr idev, InputAttributes *attrs)
d720 1
a720 1
        if (!InputClassMatches(cl, attrs))
d844 1
a844 1
    idev = xcalloc(sizeof(*idev), 1);
d904 2
d927 2
a928 4
    if(idev->driver)
        xfree(idev->driver);
    if(idev->identifier)
        xfree(idev->identifier);
d930 1
a930 1
    xfree(idev);
d966 2
a967 2
            xfree(idev->driver);
            xfree(idev->identifier);
d969 1
a969 1
            xfree(idev);
d1276 1
a1276 1
    return (X);
@


1.9
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@d57 1
d60 1
d64 1
a70 1
#ifdef HAVE_X11_EXTENSIONS_DPMSCONST_H
a71 4
#else
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
#endif
d77 6
a83 1
#define EXTENSION_PROC_ARGS void *
d89 1
d96 1
a101 1
#ifdef XKB
a102 1
#endif
d112 7
a118 3
ProcessVelocityConfiguration(char* devname, pointer list, DeviceVelocityPtr s){
    int tempi, i;
    float tempf, tempf2;
d123 1
a123 21
    tempf = xf86SetRealOption(list, "FilterHalflife", -1);
    if(tempf > 0)
        tempf = 1.0 / tempf;   /* set reciprocal if possible */

    tempf2 = xf86SetRealOption(list, "FilterChainProgression", 2.0);
    xf86Msg(X_CONFIG, "%s: (accel) filter chain progression: %.2f\n",
            devname, tempf2);
    if(tempf2 < 1)
        tempf2 = 2;

    tempi = xf86SetIntOption(list, "FilterChainLength", 1);
    if(tempi < 1 || tempi > MAX_VELOCITY_FILTERS)
	tempi = 1;

    if(tempf > 0.0f && tempi >= 1 && tempf2 >= 1.0f)
	InitFilterChain(s, tempf, tempf2, tempi, 40);

    for(i = 0; i < tempi; i++)
	xf86Msg(X_CONFIG, "%s: (accel) filter stage %i: %.2f ms\n",
                devname, i, 1.0f / (s->filters[i].rdecay));

d125 1
a125 1
    if(tempf > 1.0){
d128 3
a130 2
        s->const_acceleration = 1.0 / tempf;   /* set reciprocal deceleration
                                                  alias acceleration */
d134 1
a134 1
    if(tempf > 1.0){
d137 3
a139 1
        s->min_acceleration = 1.0 / tempf;   /* set minimum acceleration */
d142 41
a182 5
    tempf = xf86SetRealOption(list, "VelocityCoupling", -1);
    if(tempf >= 0){
	xf86Msg(X_CONFIG, "%s: (accel) velocity coupling is %.1f%%\n", devname,
                tempf*100.0);
	s->coupling = tempf;
a195 18

    tempf = xf86SetRealOption(list, "ExpectedRate", 0);
    if(tempf > 0){
        s->corr_mul = 1000.0 / tempf;
    }else{
        s->corr_mul = xf86SetRealOption(list, "VelocityScale", s->corr_mul);
    }

    /* select profile by number */
    tempi= xf86SetIntOption(list, "AccelerationProfile",
                            s->statistics.profile_number);

    if(SetAccelerationProfile(s, tempi)){
        xf86Msg(X_CONFIG, "%s: (accel) set acceleration profile %i\n", devname, tempi);
    }else{
        xf86Msg(X_CONFIG, "%s: (accel) acceleration profile %i is unknown\n",
                devname, tempi);
    }
d200 1
a200 1
    int scheme;
d205 1
a205 1
    if(dev->valuator){
d210 1
a210 1
	if(!xf86NameCmp(schemeStr, "predictable"))
d213 1
a213 1
	if(!xf86NameCmp(schemeStr, "lightweight"))
d216 1
a216 1
	if(!xf86NameCmp(schemeStr, "none"))
d220 2
a221 2
        if(dev->valuator->accelScheme.number != scheme){
            if(dev->valuator->accelScheme.AccelCleanupProc){
d225 1
a225 1
            if(InitPointerAccelerationScheme(dev, scheme)){
d228 1
a228 1
	    }else{
d233 1
a233 1
        }else{
d241 1
a241 1
        switch(scheme){
d244 1
a244 1
                ProcessVelocityConfiguration (local->name, local->options,
d248 24
d294 1
a294 1
_X_EXPORT void
a315 5
    /* Preallocate xEvent store */
    if (!xf86Events)
        GetEventList(&xf86Events);
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");
d327 1
a327 1
_X_EXPORT int
d351 1
a351 1
        dev->isMaster = FALSE;
d354 2
a355 9
        if (DeviceIsPointerType(dev))
        {
            dev->deviceGrab.ActivateGrab = ActivatePointerGrab;
            dev->deviceGrab.DeactivateGrab = DeactivatePointerGrab;
        } else 
        {
            dev->deviceGrab.ActivateGrab = ActivateKeyboardGrab;
            dev->deviceGrab.DeactivateGrab = DeactivateKeyboardGrab;
        }
d358 1
a358 4
#ifdef XKB
        if (!noXkbExtension)
            XkbSetExtension(dev, ProcessKeyboardEvent);
#endif
d398 1
a398 1
        ActivateDevice(dev);
d495 1
a495 1
AddOtherInputDevices()
d499 156
d721 1
a721 1
    rval = ActivateDevice(dev);
d725 1
a725 1
        RemoveDevice(dev);
d732 7
a738 1
        EnableDevice(dev);
d756 3
a758 2
_X_EXPORT int
NewInputDeviceRequest (InputOption *options, DeviceIntPtr *pdev)
a794 1
        /* Right now, the only automatic config we know of is HAL. */
d796 3
a798 1
            strcmp(option->value, "server/hal") == 0) {
d803 2
d806 14
a819 1
            is_auto = 1;
d821 4
d826 1
d828 1
a828 1
        xf86Msg(X_ERROR, "No input driver/identifier specified (ignoring)\n");
a837 9
    for (option = options; option; option = option->next) {
        /* Steal option key/value strings from the provided list.
         * We need those strings, the InputOption list doesn't. */
        idev->commonOptions = xf86addNewOption(idev->commonOptions,
                                               option->key, option->value);
        option->key = NULL;
        option->value = NULL;
    }

d844 2
d855 1
a855 1
_X_EXPORT void
d862 1
a862 1
    Bool isMaster = pDev->isMaster;
d871 1
a871 1
    RemoveDevice(pDev);
d873 1
a873 1
    if (!isMaster)
d900 1
a900 1
_X_EXPORT void
d911 1
a911 5
    if (num_valuators > MAX_VALUATORS) {
	xf86Msg(X_ERROR, "%s: num_valuator %d is greater than"
	    " MAX_VALUATORS\n", __FUNCTION__, num_valuators);
	return;
    }
d921 1
a921 1
_X_EXPORT void
a928 1
    int dx = 0, dy = 0;
d930 4
a933 1
    xEvent *xE = NULL;
d935 2
a936 1
    int flags = 0;
d938 1
a938 5
    if (num_valuators > MAX_VALUATORS) {
	xf86Msg(X_ERROR, "%s: num_valuator %d is greater than"
	    " MAX_VALUATORS\n", __FUNCTION__, num_valuators);
	return;
    }
a969 1
    GetEventList(&xf86Events);
d975 1
a975 1
        xE = (xf86Events + i)->event;
d978 3
a980 2
        if (xE->u.u.type != MotionNotify || drag) {
            mieqEnqueue(device, (xf86Events + i)->event);
d985 1
a985 1
_X_EXPORT void
d993 1
a993 1
    int i, nevents;
d996 1
a996 6

    if (num_valuators > MAX_VALUATORS) {
	xf86Msg(X_ERROR, "%s: num_valuator %d is greater than"
	    " MAX_VALUATORS\n", __FUNCTION__, num_valuators);
	return;
    }
d1003 16
a1018 1
    GetEventList(&xf86Events);
d1023 1
a1023 1
        mieqEnqueue(device, (xf86Events + i)->event);
d1027 1
a1027 1
_X_EXPORT void
d1038 23
d1062 3
d1066 8
a1081 10
    if (num_valuators > MAX_VALUATORS) {
	xf86Msg(X_ERROR, "%s: num_valuator %d is greater than"
	    " MAX_VALUATORS\n", __FUNCTION__, num_valuators);
	return;
    }

    va_start(var, num_valuators);
    for (i = 0; i < num_valuators; i++)
        valuators[i] = va_arg(var, int);
    va_end(var);
a1082 1
    GetEventList(&xf86Events);
d1085 1
a1085 2
                               (is_absolute) ? POINTER_ABSOLUTE : POINTER_RELATIVE,
                               first_valuator, num_valuators, valuators);
d1088 1
a1088 1
        mieqEnqueue(device, (xf86Events + i)->event);
d1092 1
a1092 1
_X_EXPORT void
d1102 24
a1126 1
    static int valuators[MAX_VALUATORS];
d1128 1
a1128 10
    /* instil confidence in the user */
    DebugF("this function has never been tested properly.  if things go quite "
           "badly south after this message, then xf86PostKeyEvent is "
           "broken.\n");

    if (num_valuators > MAX_VALUATORS) {
	xf86Msg(X_ERROR, "%s: num_valuator %d is greater than"
	    " MAX_VALUATORS\n", __FUNCTION__, num_valuators);
	return;
    }
a1130 6
        va_start(var, num_valuators);
        for (i = 0; i < num_valuators; i++)
            valuators[i] = va_arg(var, int);
        va_end(var);

        GetEventList(&xf86Events);
d1143 1
a1143 1
        mieqEnqueue(device, (xf86Events + i)->event);
d1146 1
a1146 1
_X_EXPORT void
d1151 1
a1151 22
    int nevents = 0, i = 0;
    int index;

#if XFreeXDGA
    DeviceIntPtr pointer;

    /* Some pointers send key events, paired device is wrong then. */
    pointer = IsPointerDevice(device) ? device : GetPairedDevice(device);

    if (miPointerGetScreen(pointer)) {
        index = miPointerGetScreen(pointer)->myNum;
        if (DGAStealKeyEvent(device, index, key_code, is_down))
            return;
    }
#endif

    GetEventList(&xf86Events);
    nevents = GetKeyboardEvents(xf86Events, device,
                                is_down ? KeyPress : KeyRelease, key_code);

    for (i = 0; i < nevents; i++)
        mieqEnqueue(device, (xf86Events + i)->event);
d1154 2
a1155 2
_X_EXPORT LocalDevicePtr
xf86FirstLocalDevice()
d1173 1
a1173 1
_X_EXPORT int
d1181 2
a1182 2
    int dSx = Sxhigh - Sxlow;
    int dRx = Rxhigh - Rxlow;
a1183 1
    dSx = Sxhigh - Sxlow;
d1185 1
a1185 1
	X = ((dSx * (Cx - Rxlow)) / dRx) + Sxlow;
d1206 1
a1206 1
_X_EXPORT void
d1219 2
a1220 2
_X_EXPORT void
xf86InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, int minval, int maxval,
d1226 1
a1226 1
    InitValuatorAxisStruct(dev, axnum, minval, maxval, resolution, min_res,
d1234 1
a1234 1
_X_EXPORT void
d1260 1
a1260 1
_X_EXPORT void
a1262 3
    devicePresenceNotify ev;
    DeviceIntRec dummyDev;

d1265 1
a1265 1
        DisableDevice(dev);
d1268 1
a1268 8
        ev.type = DevicePresenceNotify;
        ev.time = currentTime.milliseconds;
        ev.devchange = DeviceUnrecoverable;
        ev.deviceid = dev->id;
        dummyDev.id = 0;
        SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                (xEvent *) &ev, 1);

d1278 1
a1278 1
_X_EXPORT void
d1281 1
a1281 1
    EnableDevice(dev);
@


1.8
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d68 3
d73 1
@


1.7
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a54 1
#ifdef XINPUT
a56 1
#endif
a59 1
#ifdef XINPUT
a61 1
#endif
d64 2
d87 2
d93 145
a237 1
xEvent *xf86Events = NULL;
d282 1
a282 1
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
d290 1
a290 1
 * 
d293 1
d296 1
a296 1
_X_EXPORT void
d302 1
a302 1
        dev = AddInputDevice(local->device_control, TRUE);
d305 7
a311 2
            FatalError("Too many input devices");
        
d319 14
a332 1
        dev->coreEvents = local->flags & XI86_ALWAYS_CORE;
a333 1

d343 2
a347 1
#ifdef XINPUT
d458 1
a476 1
#endif
d478 96
a573 1
int
a576 2
    InputDriverPtr drv = NULL;
    InputInfoPtr pInfo = NULL;
a577 1
    DeviceIntPtr dev = NULL;
a590 12
            /* Memory leak for every attached device if we don't
             * test if the module is already loaded first */
            drv = xf86LookupInputDriver(option->value);
            if (!drv)
                if (xf86LoadOneModule(option->value, NULL))
                    drv = xf86LookupInputDriver(option->value);
            if (!drv) {
                xf86Msg(X_ERROR, "No input driver matching `%s'\n",
                        option->value);
                rval = BadName;
                goto unwind;
            }
d628 3
a630 6
    if (!drv->PreInit) {
        xf86Msg(X_ERROR,
                "Input driver `%s' has no PreInit function (ignoring)\n",
                drv->driverName);
        rval = BadImplementation;
        goto unwind;
d642 4
a645 26
    pInfo = drv->PreInit(drv, idev, 0);

    if (!pInfo) {
        xf86Msg(X_ERROR, "PreInit returned NULL for \"%s\"\n", idev->identifier);
        rval = BadMatch;
        goto unwind;
    }
    else if (!(pInfo->flags & XI86_CONFIGURED)) {
        xf86Msg(X_ERROR, "PreInit failed for input device \"%s\"\n",
                idev->identifier);
        rval = BadMatch;
        goto unwind;
    }

    xf86ActivateDevice(pInfo);

    dev = pInfo->dev;
    ActivateDevice(dev);
    /* Enable it if it's properly initialised, we're currently in the VT, and
     * either it's a manual request, or we're automatically enabling devices. */
    if (dev->inited && dev->startup && xf86Screens[0]->vtSema &&
        (!is_auto || xf86Info.autoEnableDevices))
        EnableDevice(dev);

    *pdev = dev;
    return Success;
a647 6
    if(pInfo) {
        if(drv->UnInit)
            drv->UnInit(drv, pInfo, 0);
        else
            xf86DeleteInput(pInfo, 0);
    }
d657 1
a657 1
void
d661 2
a662 3
    InputDriverPtr drv;
    IDevRec *idev;
    BOOL found;
d664 1
d671 2
d675 6
a680 2
    if (!pInfo) /* VCP and VCK */
        return;
d682 12
a693 16
    if(drv->UnInit)
        drv->UnInit(drv, pInfo, 0);
    else
        xf86DeleteInput(pInfo, 0);

    /* devices added through HAL aren't in the config layout */
    it = xf86ConfigLayout.inputs;
    while(*it && *it != idev)
        it++;

    if (!(*it)) /* end of list, not in the layout */
    {
        xfree(idev->driver);
        xfree(idev->identifier);
        xf86optionListFree(idev->commonOptions);
        xfree(idev);
d695 1
a701 2
#define MAX_VALUATORS 36 /* XXX from comment in dix/getevents.c */

d714 2
a715 2
	xf86Msg(X_ERROR, "xf86PostMotionEvent: num_valuator %d"
	    " is greater than MAX_VALUATORS\n", num_valuators);
d735 1
a735 1
    int dx, dy;
d742 2
a743 2
	xf86Msg(X_ERROR, "xf86PostMotionEvent: num_valuator %d"
	    " is greater than MAX_VALUATORS\n", num_valuators);
d753 9
a761 6
    if (first_valuator == 0 && num_valuators >= 2) {
        if (miPointerGetScreen(inputInfo.pointer)) {
            index = miPointerGetScreen(inputInfo.pointer)->myNum;
            if (is_absolute) {
                dx = valuators[0] - device->valuator->lastx;
                dy = valuators[1] - device->valuator->lasty;
d763 6
a768 3
            else {
                dx = valuators[0];
                dy = valuators[1];
d770 2
a771 1
            if (DGAStealMotionEvent(index, dx, dy))
d777 1
a777 3
    if (!xf86Events)
        FatalError("Didn't allocate event store\n");

d783 1
a783 1
        xE = xf86Events + i;
d787 1
a787 1
            mieqEnqueue(device, xf86Events + i);
d805 2
a806 2
	xf86Msg(X_ERROR, "xf86PostMotionEvent: num_valuator %d"
	    " is greater than MAX_VALUATORS\n", num_valuators);
d815 1
a815 3
    if (!xf86Events)
        FatalError("Didn't allocate event store\n");

d820 1
a820 1
        mieqEnqueue(device, xf86Events + i);
d839 3
a841 3
    if (miPointerGetScreen(inputInfo.pointer)) {
        index = miPointerGetScreen(inputInfo.pointer)->myNum;
        if (DGAStealButtonEvent(index, button, is_down))
d846 2
a847 2
	xf86Msg(X_ERROR, "xf86PostMotionEvent: num_valuator %d"
	    " is greater than MAX_VALUATORS\n", num_valuators);
d850 1
a850 1
    
d856 1
a856 3
    if (!xf86Events)
        FatalError("Didn't allocate event store\n");

d859 1
a859 2
                               is_absolute ? POINTER_ABSOLUTE :
                                             POINTER_RELATIVE,
d863 2
a864 1
        mieqEnqueue(device, xf86Events + i);
d886 2
a887 2
	xf86Msg(X_ERROR, "xf86PostMotionEvent: num_valuator %d"
	    " is greater than MAX_VALUATORS\n", num_valuators);
a890 3
    if (!xf86Events)
        FatalError("Didn't allocate event store\n");

d897 1
d910 1
a910 1
        mieqEnqueue(device, xf86Events + i);
d922 8
a929 3
    if (miPointerGetScreen(inputInfo.pointer)) {
        index = miPointerGetScreen(inputInfo.pointer)->myNum;
        if (DGAStealKeyEvent(index, key_code, is_down))
d934 1
a934 3
    if (!xf86Events)
        FatalError("Didn't allocate event store\n");

d939 1
a939 1
        mieqEnqueue(device, xf86Events + i);
d981 3
a983 1
    if (X > Sxlow)
a984 2
    if (X < Sxhigh)
	X = Sxhigh;
d1028 1
a1028 1
        dev->valuator->lastx = dev->valuator->axisVal[0];
d1032 1
a1032 1
        dev->valuator->lasty = dev->valuator->axisVal[1];
d1034 3
@


1.6
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@a79 1
#include "extinit.h"	/* LookupDeviceIntRec */
d449 11
a459 2
    InputDriverPtr drv = pInfo->drv;
    IDevRec *idev = pInfo->conf_idev;
d461 2
a462 1
    RemoveDevice(pDev);
d469 12
a480 4
    xfree(idev->driver);
    xfree(idev->identifier);
    xf86optionListFree(idev->commonOptions);
    xfree(idev);
d528 6
d670 6
@


1.5
log
@Don't call xcalloc() in functions called by the big SIGIO handler.
Problem initially reported by sthen@@, fix tested by many.
@
text
@d119 1
a119 1
    if (xf86SetBoolOption(list, "AlwaysCore", 0) ||
@


1.4
log
@Merge xserver 1.4.0.90. This includes fixes for some of the regressions
introduced by xserver 1.4, such as the keyboad caps/num-lock leds updates.
Tested by many.
@
text
@d137 5
d470 2
d481 1
a481 7
    static int *valuators = NULL;
    static int n_valuators = 0;

    if (num_valuators > n_valuators) {
	xfree (valuators);
	valuators = NULL;
    }
d483 4
a486 3
    if (!valuators) {
	valuators = xcalloc(sizeof(int), num_valuators);
	n_valuators = num_valuators;
d535 1
a535 3
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");
d559 2
a560 1
    int i, nevents, *valuators = NULL;
d562 6
a567 1
    valuators = xcalloc(sizeof(int), num_valuators);
d575 1
a575 3
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");
a582 1
    xfree(valuators);
d595 1
a595 1
    int *valuators = NULL;
d606 5
a611 2
    valuators = xcalloc(sizeof(int), num_valuators);

d618 1
a618 3
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");
a627 2

    xfree(valuators);
d640 2
a641 1
    int i = 0, nevents = 0, *valuators = NULL;
d649 1
a649 3
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");
a651 1
        valuators = xcalloc(sizeof(int), num_valuators);
a660 1
        xfree(valuators);
d689 1
a689 3
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");
@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@d168 5
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@a40 1
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
a47 1
/* $XConsortium: xf86Xinput.c /main/14 1996/10/27 11:05:25 kaleb $ */
d64 1
a74 4
#ifdef XFreeXDGA
#include "dgaproc.h"
#endif

a85 1
#include "osdep.h"		/* EnabledDevices */
a86 11
#include "xf86_OSproc.h"	/* sigio stuff */

/******************************************************************************
 * debugging macro
 *****************************************************************************/
#ifdef DBG
#undef DBG
#endif
#ifdef DEBUG
#undef DEBUG
#endif
d88 1
a88 1
#define DEBUG 0
d90 2
a91 6
#if DEBUG
static int      debug_level = 0;

#define DBG(lvl, f) {if ((lvl) <= debug_level) f;}
#else
#define DBG(lvl, f)
d94 1
a94 43
/******************************************************************************
 * macros
 *****************************************************************************/
#define ENQUEUE(e) xf86eqEnqueue((e))

/***********************************************************************
 *
 * xf86AlwaysCoreControl --
 *	
 *	Control proc for the integer feedback that controls the always
 * core feature.
 *
 ***********************************************************************
 */
static void
xf86AlwaysCoreControl(DeviceIntPtr	device,
		      IntegerCtrl	*control)
{
}

/***********************************************************************
 *
 * Core devices functions --
 *	
 *	Test if device is the core device by checking the
 * value of always core feedback and the inputInfo struct.
 *
 ***********************************************************************
 */
_X_EXPORT int
xf86IsCorePointer(DeviceIntPtr	device)
{
    return(device == inputInfo.pointer);
}

static int
xf86ShareCorePointer(DeviceIntPtr	device)
{
    LocalDevicePtr	local = (LocalDevicePtr) device->public.devicePrivate;
    
    return((local->always_core_feedback &&
	    local->always_core_feedback->ctrl.integer_displayed));
}
d101 2
a102 2
    if (inputInfo.pointer->button->buttonsDown > 0)
	return (local->flags & XI86_SEND_DRAG_EVENTS);
d104 1
a104 53
	return (TRUE);
}

int
xf86IsCoreKeyboard(DeviceIntPtr	device)
{
    LocalDevicePtr	local = (LocalDevicePtr) device->public.devicePrivate;
    
    return((local->flags & XI86_ALWAYS_CORE) ||
	   (device == inputInfo.keyboard));
}

_X_EXPORT void
xf86XInputSetSendCoreEvents(LocalDevicePtr local, Bool always)
{
    if (always) {
	local->flags |= XI86_ALWAYS_CORE;
    } else {
	local->flags &= ~XI86_ALWAYS_CORE;
    }
}

static int xf86CoreButtonState;

/***********************************************************************
 *
 * xf86CheckButton --
 *	
 *	Test if the core pointer button state is coherent with
 * the button event to send.
 *
 ***********************************************************************
 */
Bool
xf86CheckButton(int	button,
		int	down)
{
    int	check;
    int bit = (1 << (button - 1));

    check = xf86CoreButtonState & bit;
    
    DBG(5, ErrorF("xf86CheckButton "
		  "button=%d down=%d state=%d check=%d returns ",
		   button, down, xf86CoreButtonState, check));
    if ((check && down) || (!check && !down)) {
	DBG(5, ErrorF("FALSE\n"));
	return FALSE;
    }
    xf86CoreButtonState ^= bit;

    DBG(5, ErrorF("TRUE\n"));
    return TRUE;
d117 1
a117 1
			 pointer	list)
d120 7
a126 13
	xf86SetBoolOption(list, "SendCoreEvents", 0)) {
	local->flags |= XI86_ALWAYS_CORE;
	xf86Msg(X_CONFIG, "%s: always reports core events\n", local->name);
    }

    if (xf86SetBoolOption(list, "CorePointer", 0)) {
	local->flags |= XI86_CORE_POINTER;
	xf86Msg(X_CONFIG, "%s: Core Pointer\n", local->name);
    }

    if (xf86SetBoolOption(list, "CoreKeyboard", 0)) {
	local->flags |= XI86_CORE_KEYBOARD;
	xf86Msg(X_CONFIG, "%s: Core Keyboard\n", local->name);
d130 1
a130 1
	local->flags |= XI86_SEND_DRAG_EVENTS;
d132 1
a132 1
	xf86Msg(X_CONFIG, "%s: doesn't report drag events\n", local->name);
a133 2
    
    local->history_size = xf86SetIntOption(list, "HistorySize", 0);
d135 2
a136 29
    if (local->history_size > 0) {
	xf86Msg(X_CONFIG, "%s: has a history of %d motions\n", local->name,
		local->history_size);
    }
}

/***********************************************************************
 *
 * xf86XinputFinalizeInit --
 * 
 *	Create and initialize an integer feedback to control the always
 * core feature.
 *
 ***********************************************************************
 */
void
xf86XinputFinalizeInit(DeviceIntPtr	dev)
{
    LocalDevicePtr        local = (LocalDevicePtr)dev->public.devicePrivate;

    local->dxremaind = 0.0;
    local->dyremaind = 0.0;
    
    if (InitIntegerFeedbackClassDeviceStruct(dev, xf86AlwaysCoreControl) == FALSE) {
	ErrorF("Unable to init integer feedback for always core feature\n");
    } else {
	local->always_core_feedback = dev->intfeed;
	dev->intfeed->ctrl.integer_displayed = (local->flags & XI86_ALWAYS_CORE) ? 1 : 0;
    }
d153 1
a153 32
	int	open_on_init;
	
	open_on_init = local->flags &
		(XI86_OPEN_ON_INIT |
		 XI86_ALWAYS_CORE | XI86_CORE_POINTER | XI86_CORE_KEYBOARD);
	
	dev = AddInputDevice(local->device_control,
			     open_on_init);
	if (dev == NULL)
	    FatalError("Too many input devices");
	
	local->atom = MakeAtom(local->type_name,
			       strlen(local->type_name),
			       TRUE);
	AssignTypeAndName (dev, local->atom, local->name);
	dev->public.devicePrivate = (pointer) local;
	local->dev = dev;      
	
	xf86XinputFinalizeInit(dev);

	/*
	 * XXX Can a single device instance be both core keyboard and
	 * core pointer?  If so, this should be changed.
	 */
	if (local->flags & XI86_CORE_POINTER)
	    RegisterPointerDevice(dev);
	else if (local->flags & XI86_CORE_KEYBOARD)
	    RegisterKeyboardDevice(dev);
#ifdef XINPUT
	else
	    RegisterOtherDevice(dev);
#endif
d155 16
a170 3
	if (serverGeneration == 1) 
	    xf86Msg(X_INFO, "XINPUT: Adding extended input device \"%s\" (type: %s)\n",
		    local->name, local->type_name);
d201 2
a202 90
		ClientPtr	client,
		int		*status)
{
    if (!dev->inited) {
	*status = BadDevice;
    } else {
	if (!dev->public.on) {
	    if (!EnableDevice(dev)) {
		*status = BadDevice;
	    } else {
		/* to prevent ProcXOpenDevice to call EnableDevice again */
		dev->startup = FALSE;
	    }
	}
    }
}


/***********************************************************************
 *
 * Caller:	ProcXChangeKeyboardDevice
 *
 * This procedure does the implementation-dependent portion of the work
 * needed to change the keyboard device.
 *
 * The X keyboard device has a FocusRec.  If the device that has been 
 * made into the new X keyboard did not have a FocusRec, 
 * ProcXChangeKeyboardDevice will allocate one for it.
 *
 * If you do not want clients to be able to focus the old X keyboard
 * device, call DeleteFocusClassDeviceStruct to free the FocusRec.
 *
 * If you support input devices with keys that you do not want to be 
 * used as the X keyboard, you need to check for them here and return 
 * a BadDevice error.
 *
 * The default implementation is to do nothing (assume you do want
 * clients to be able to focus the old X keyboard).  The commented-out
 * sample code shows what you might do if you don't want the default.
 *
 ***********************************************************************
 */

int
ChangeKeyboardDevice (DeviceIntPtr old_dev, DeviceIntPtr new_dev)
{
  /**********************************************************************
   * DeleteFocusClassDeviceStruct(old_dev);	 * defined in xchgptr.c *
   **********************************************************************/
  return !Success;
}


/***********************************************************************
 *
 * Caller:	ProcXChangePointerDevice
 *
 * This procedure does the implementation-dependent portion of the work
 * needed to change the pointer device.
 *
 * The X pointer device does not have a FocusRec.  If the device that
 * has been made into the new X pointer had a FocusRec, 
 * ProcXChangePointerDevice will free it.
 *
 * If you want clients to be able to focus the old pointer device that
 * has now become accessible through the input extension, you need to 
 * add a FocusRec to it here.
 *
 * The XChangePointerDevice protocol request also allows the client
 * to choose which axes of the new pointer device are used to move 
 * the X cursor in the X- and Y- directions.  If the axes are different
 * than the default ones, you need to keep track of that here.
 *
 * If you support input devices with valuators that you do not want to be 
 * used as the X pointer, you need to check for them here and return a 
 * BadDevice error.
 *
 * The default implementation is to do nothing (assume you don't want
 * clients to be able to focus the old X pointer).  The commented-out
 * sample code shows what you might do if you don't want the default.
 *
 ***********************************************************************
 */

int
ChangePointerDevice (
     DeviceIntPtr	old_dev,
     DeviceIntPtr	new_dev,
     unsigned char	x,
     unsigned char	y)
d204 2
a205 10
  /************************************************************************
    InitFocusClassDeviceStruct(old_dev);	* allow focusing old ptr*
    
    x_axis = x;					* keep track of new x-axis*
    y_axis = y;					* keep track of new y-axis*
    if (x_axis != 0 || y_axis != 1)
    axes_changed = TRUE;			* remember axes have changed*
    else
    axes_changed = FALSE;
   *************************************************************************/
d207 1
a207 25
  /*
   * We don't allow axis swap or other exotic features.
   */
  if (x == 0 && y == 1) {
      LocalDevicePtr	old_local = (LocalDevicePtr)old_dev->public.devicePrivate;
      LocalDevicePtr	new_local = (LocalDevicePtr)new_dev->public.devicePrivate;
      
      InitFocusClassDeviceStruct(old_dev);
    
      /* Restore Extended motion history information */
      old_dev->valuator->GetMotionProc   = old_local->motion_history_proc;
      old_dev->valuator->numMotionEvents = old_local->history_size;

      /* Save Extended motion history information */
      new_local->motion_history_proc = new_dev->valuator->GetMotionProc;
      new_local->history_size	     = new_dev->valuator->numMotionEvents;
      
      /* Set Core motion history information */
      new_dev->valuator->GetMotionProc   = miPointerGetMotionEvents;
      new_dev->valuator->numMotionEvents = miPointerGetMotionBufferSize();
      
    return Success;
  }
  else
    return !Success;
a209 15

/***********************************************************************
 *
 * Caller:	ProcXCloseDevice
 *
 * Take care of implementation-dependent details of closing a device.
 * Some implementations may actually close the device, others may just
 * remove this clients interest in that device.
 *
 * The default implementation is to do nothing (assume all input devices
 * are initialized during X server initialization and kept open).
 *
 ***********************************************************************
 */

d211 2
a212 1
CloseInputDevice (DeviceIntPtr d, ClientPtr client)
a213 1
  ErrorF("ProcXCloseDevice to close or not ?\n");
a215 34

/***********************************************************************
 *
 * Caller:	ProcXListInputDevices
 *
 * This is the implementation-dependent routine to initialize an input 
 * device to the point that information about it can be listed.
 * Some implementations open all input devices when the server is first
 * initialized, and never close them.  Other implementations open only
 * the X pointer and keyboard devices during server initialization,
 * and only open other input devices when some client makes an
 * XOpenDevice request.  If some other process has the device open, the
 * server may not be able to get information about the device to list it.
 *
 * This procedure should be used by implementations that do not initialize
 * all input devices at server startup.  It should do device-dependent
 * initialization for any devices not previously initialized, and call
 * AddInputDevice for each of those devices so that a DeviceIntRec will be 
 * created for them.
 *
 * The default implementation is to do nothing (assume all input devices
 * are initialized during X server initialization and kept open).
 * The commented-out sample code shows what you might do if you don't want 
 * the default.
 *
 ***********************************************************************
 */

void
AddOtherInputDevices ()
{
}


d257 1
a257 1
		    int first_valuator, int num_valuators)
d259 7
a265 1
  return BadMatch;
d284 10
a293 1
      return (BadMatch);
a298 1
#endif
d300 4
a303 10
/*
 * adapted from mieq.c to support extended events
 *
 */
#define QUEUE_SIZE  256

typedef struct _Event {
    xEvent	event;
#ifdef XINPUT
  deviceValuator val;
a304 2
    ScreenPtr	pScreen;
} EventRec, *EventPtr;
d306 110
a415 25
typedef struct _EventQueue {
    HWEventQueueType head, tail;
    CARD32	lastEventTime;	    /* to avoid time running backwards */
    Bool	lastMotion;
    EventRec	events[QUEUE_SIZE]; /* static allocation for signals */
    DevicePtr	pKbd, pPtr;	    /* device pointer, to get funcs */
    ScreenPtr	pEnqueueScreen;	    /* screen events are being delivered to */
    ScreenPtr	pDequeueScreen;	    /* screen events are being dispatched to */
} EventQueueRec, *EventQueuePtr;

static EventQueueRec xf86EventQueue;

Bool
xf86eqInit (DevicePtr pKbd, DevicePtr pPtr)
{
    xf86EventQueue.head = xf86EventQueue.tail = 0;
    xf86EventQueue.lastEventTime = GetTimeInMillis ();
    xf86EventQueue.pKbd = pKbd;
    xf86EventQueue.pPtr = pPtr;
    xf86EventQueue.lastMotion = FALSE;
    xf86EventQueue.pEnqueueScreen = screenInfo.screens[0];
    xf86EventQueue.pDequeueScreen = xf86EventQueue.pEnqueueScreen;
    SetInputCheck (&xf86EventQueue.head, &xf86EventQueue.tail);
    return TRUE;
}
d417 2
a418 6
/*
 * Must be reentrant with ProcessInputEvents.  Assumption: xf86eqEnqueue
 * will never be interrupted.  If this is called from both signal
 * handlers and regular code, make sure the signal is suspended when
 * called from regular code.
 */
d420 14
a433 78
_X_EXPORT void
xf86eqEnqueue (xEvent *e)
{
    int		oldtail, newtail;
    Bool	isMotion;
#ifdef XINPUT
    int		count;
    
    xf86AssertBlockedSIGIO ("xf86eqEnqueue");
    switch (e->u.u.type) {
    case KeyPress:
    case KeyRelease:
#ifdef XFreeXDGA
	/* we do this here, because nobody seems to be calling
	   xf86PostKeyEvent().  We can't steal MotionNotify events here
	   because the motion-relative information has been lost already. */
	if(DGAStealKeyEvent(xf86EventQueue.pEnqueueScreen->myNum, e))
	    return;
#endif
	/* fall through */
    case ButtonPress:
    case ButtonRelease:
    case MotionNotify:
        count = 1;
        break;
    default:
#ifdef XFreeXDGA
	if (DGAIsDgaEvent (e))
	{
	    count = 1;
	    break;
	}
#endif
	if (!((deviceKeyButtonPointer *) e)->deviceid & MORE_EVENTS) {
            count = 1;
	}
        else {
	    count = 2;
	}
        break;
    }
#endif

    oldtail = xf86EventQueue.tail;
    isMotion = e->u.u.type == MotionNotify;
    if (isMotion && xf86EventQueue.lastMotion && oldtail != xf86EventQueue.head) {
	if (oldtail == 0)
	    oldtail = QUEUE_SIZE;
	oldtail = oldtail - 1;
    }
    else {
    	newtail = oldtail + 1;
    	if (newtail == QUEUE_SIZE)
	    newtail = 0;
    	/* Toss events which come in late */
    	if (newtail == xf86EventQueue.head)
	    return;
	xf86EventQueue.tail = newtail;
    }
    
    xf86EventQueue.lastMotion = isMotion;
    xf86EventQueue.events[oldtail].event = *e;
#ifdef XINPUT
    if (count == 2) {
	xf86EventQueue.events[oldtail].val = *((deviceValuator *) (((deviceKeyButtonPointer *) e)+1));
    }
#endif
    /*
     * Make sure that event times don't go backwards - this
     * is "unnecessary", but very useful
     */
    if (e->u.keyButtonPointer.time < xf86EventQueue.lastEventTime &&
	xf86EventQueue.lastEventTime - e->u.keyButtonPointer.time < 10000) {
	
	xf86EventQueue.events[oldtail].event.u.keyButtonPointer.time =
	    xf86EventQueue.lastEventTime;
    }
    xf86EventQueue.events[oldtail].pScreen = xf86EventQueue.pEnqueueScreen;
a435 3
/*
 * Call this from ProcessInputEvents()
 */
d437 1
a437 1
xf86eqProcessInputEvents ()
d439 3
a441 13
    EventRec	*e;
    int		x, y;
    struct {
	xEvent	event;
#ifdef XINPUT
	deviceValuator	val;
#endif
    }		xe;
#ifdef XINPUT
    DeviceIntPtr                dev;
    int                         id, count;
    deviceKeyButtonPointer      *dev_xe;
#endif
d443 1
a443 6
    while (xf86EventQueue.head != xf86EventQueue.tail) {
	if (screenIsSaved == SCREEN_SAVER_ON)
	    SaveScreens (SCREEN_SAVER_OFF, ScreenSaverReset);
#ifdef DPMSExtension
	else if (DPMSPowerLevel != DPMSModeOn)
	    SetScreenSaverTimer();
d445 4
a448 3
        if (DPMSPowerLevel != DPMSModeOn)
            DPMSSet(DPMSModeOn);
#endif
d450 4
a453 79
	e = &xf86EventQueue.events[xf86EventQueue.head];
	/*
	 * Assumption - screen switching can only occur on motion events
	 */
	if (e->pScreen != xf86EventQueue.pDequeueScreen) {
	    xf86EventQueue.pDequeueScreen = e->pScreen;
	    x = e->event.u.keyButtonPointer.rootX;
	    y = e->event.u.keyButtonPointer.rootY;
	    if (xf86EventQueue.head == QUEUE_SIZE - 1)
	    	xf86EventQueue.head = 0;
	    else
	    	++xf86EventQueue.head;
	    NewCurrentScreen (xf86EventQueue.pDequeueScreen, x, y);
	}
	else {
	    xe.event = e->event;
	    xe.val = e->val;
	    if (xf86EventQueue.head == QUEUE_SIZE - 1)
	    	xf86EventQueue.head = 0;
	    else
	    	++xf86EventQueue.head;
	    switch (xe.event.u.u.type) {
	    case KeyPress:
	    case KeyRelease:
	    	(*xf86EventQueue.pKbd->processInputProc)
		    (&xe.event, (DeviceIntPtr)xf86EventQueue.pKbd, 1);
	    	break;
#ifdef XINPUT
            case ButtonPress:
            case ButtonRelease:
            case MotionNotify:
	    	(*(inputInfo.pointer->public.processInputProc))
		    (&xe.event, (DeviceIntPtr)inputInfo.pointer, 1);
		break;

	    default:
#ifdef XFreeXDGA
		if (DGADeliverEvent (xf86EventQueue.pDequeueScreen, &xe.event))
		    break;
#endif
		dev_xe = (deviceKeyButtonPointer *) &xe.event;
		id = dev_xe->deviceid & DEVICE_BITS;
		if (!(dev_xe->deviceid & MORE_EVENTS)) {
		    count = 1;
		}
		else {
		    count = 2;
		}
		dev = LookupDeviceIntRec(id);
		if (dev == NULL) {
		    ErrorF("LookupDeviceIntRec id=0x%x not found\n", id);
/*                   FatalError("xf86eqProcessInputEvents : device not found.\n");
 */
		    break;
		}
		if (!dev->public.processInputProc) {
		    FatalError("xf86eqProcessInputEvents : device has no input proc.\n");
		    break;
		}
		(*dev->public.processInputProc)(&xe.event, dev, count);
#else
	    default:
	    	(*xf86EventQueue.pPtr->processInputProc)
		    (&xe.event, (DeviceIntPtr)xf86EventQueue.pPtr, 1);
#endif
	    	break;
	    }
	}
    }
}

void
xf86eqSwitchScreen(ScreenPtr	pScreen,
		   Bool		fromDIX)
{
    xf86EventQueue.pEnqueueScreen = pScreen;
  
    if (fromDIX)
	xf86EventQueue.pDequeueScreen = pScreen;
d462 18
a479 40
		    int			is_absolute,
		    int			first_valuator,
		    int			num_valuators,
		    ...)
{
    va_list			var;
    int				loop;
    xEvent			xE[2];
    deviceKeyButtonPointer	*xev  = (deviceKeyButtonPointer*) xE;
    deviceValuator		*xv   = (deviceValuator*) xev+1;
    LocalDevicePtr		local = (LocalDevicePtr) device->public.devicePrivate;
    char			*buff = 0;
    Time			current;
    Bool			is_core = xf86IsCorePointer(device);
    Bool			is_shared = xf86ShareCorePointer(device);
    Bool			drag = xf86SendDragEvents(device);
    ValuatorClassPtr		val = device->valuator;
    int				valuator[6];
    int				oldaxis[6];
    int				*axisvals;
    int				dx = 0, dy = 0;
    float			mult;
    int				x, y;
    int				loop_start;
    int				i;
    int				num;
    
    DBG(5, ErrorF("xf86PostMotionEvent BEGIN 0x%x(%s) is_core=%s is_shared=%s is_absolute=%s\n",
		  device, device->name,
		  is_core ? "True" : "False",
		  is_shared ? "True" : "False",
		  is_absolute ? "True" : "False"));
    
    xf86Info.lastEventTime = xev->time = current = GetTimeInMillis();
    
    if (!is_core) {
      if (HAS_MOTION_HISTORY(local)) {
	buff = ((char *)local->motion_history +
		(sizeof(INT32) * local->dev->valuator->numAxes + sizeof(Time)) * local->last);
      }
d482 21
a502 4
    if (num_valuators && (!val || (first_valuator + num_valuators > val->numAxes))) {
	ErrorF("Bad valuators reported for device \"%s\"\n", device->name);
	return;
    }
d504 4
a507 3
    axisvals = val->axisVal;
    
    va_start(var, num_valuators);
d509 16
a524 127
    loop_start = first_valuator;
    for(loop=0; loop<num_valuators; loop++) {
	
	valuator[loop%6] = va_arg(var,int);
	
	if (loop % 6 == 5 || loop == num_valuators - 1)	{
	    num = loop % 6 + 1;
	    /*
	     * Adjust first two relative valuators
	     */
	    if (!is_absolute && num_valuators >= 2 && loop_start == 0) {
		
		dx = valuator[0];
		dy = valuator[1];

		/*
		 * Accelerate
		 */
		if (device->ptrfeed && device->ptrfeed->ctrl.num) {
		    /* modeled from xf86Events.c */
		    if (device->ptrfeed->ctrl.threshold) {
			if ((abs(dx) + abs(dy)) >= device->ptrfeed->ctrl.threshold) {
			    local->dxremaind = ((float)dx * (float)(device->ptrfeed->ctrl.num)) /
			        (float)(device->ptrfeed->ctrl.den) + local->dxremaind;
			    valuator[0] = (int)local->dxremaind;
			    local->dxremaind = local->dxremaind - (float)valuator[0];
			    
			    local->dyremaind = ((float)dy * (float)(device->ptrfeed->ctrl.num)) /
			        (float)(device->ptrfeed->ctrl.den) + local->dyremaind;
			    valuator[1] = (int)local->dyremaind;
			    local->dyremaind = local->dyremaind - (float)valuator[1];
			}
		    }
		    else if (dx || dy) {
			mult = pow((float)dx*(float)dx + (float)dy*(float)dy,
				   ((float)(device->ptrfeed->ctrl.num) /
				    (float)(device->ptrfeed->ctrl.den) - 1.0) / 
				   2.0) / 2.0;
			if (dx) {
			    local->dxremaind = mult * (float)dx + local->dxremaind;
			    valuator[0] = (int)local->dxremaind;
			    local->dxremaind = local->dxremaind - (float)valuator[0];
			}
			if (dy) {
			    local->dyremaind = mult * (float)dy + local->dyremaind;
			    valuator[1] = (int)local->dyremaind;
			    local->dyremaind = local->dyremaind - (float)valuator[1];
			}
		    }
		    DBG(6, ErrorF("xf86PostMotionEvent acceleration v0=%d v1=%d\n",
				  valuator[0], valuator[1]));
		}
		
		/*
		 * Map current position back to device space in case
		 * the cursor was warped
		 */
		if (is_core || is_shared)
		{
		    miPointerPosition (&x, &y);
		    if (local->reverse_conversion_proc)
			(*local->reverse_conversion_proc)(local, x, y, axisvals);
		    else
		    {
			axisvals[0] = x;
			axisvals[1] = y;
		    }
		}
	    }
		
	    /*
	     * Update axes
	     */
	    for (i = 0; i < num; i++)
	    {
		oldaxis[i] = axisvals[loop_start + i];
	        if (is_absolute)
		    axisvals[loop_start + i] = valuator[i];
		else
		    axisvals[loop_start + i] += valuator[i];
	    }
		
	    /*
	     * Deliver extension event
	     */
	    if (!is_core) {
		xev->type = DeviceMotionNotify;
		xev->detail = 0;
		xev->deviceid = device->id | MORE_EVENTS;
            
		xv->type = DeviceValuator;
		xv->deviceid = device->id;
	    
		xv->device_state = 0;
		xv->num_valuators = num;
		xv->first_valuator = loop_start;
		memcpy (&xv->valuator0, &axisvals[loop_start],
			sizeof(INT32)*xv->num_valuators);
		
		if (HAS_MOTION_HISTORY(local)) {
		    *(Time*)buff = current;
		    memcpy(buff+sizeof(Time)+sizeof(INT32)*xv->first_valuator,
			   &axisvals[loop_start],
			   sizeof(INT32)*xv->num_valuators);
		}
		ENQUEUE(xE);
	    }
	    
	    /*
	     * Deliver core event
	     */
	    if (is_core ||
		(is_shared && num_valuators >= 2 && loop_start == 0)) {
#ifdef XFreeXDGA
		/*
		 * Let DGA peek at the event and steal it
		 */
		xev->type = MotionNotify;
		xev->detail = 0;
		if (is_absolute)
		{
		    dx = axisvals[0] - oldaxis[0];
		    dy = axisvals[1] - oldaxis[1];
		}
		if (DGAStealMouseEvent(xf86EventQueue.pEnqueueScreen->myNum,
				       xE, dx, dy))
		    continue;
d526 17
a542 23
		if (!(*local->conversion_proc)(local, loop_start, num,
					       axisvals[0], axisvals[1],
					       axisvals[2], axisvals[3],
					       axisvals[4], axisvals[5],
					       &x, &y))
		    continue;

		if (drag)
		    miPointerAbsoluteCursor (x, y, current);
		/*
		 * Retrieve the position
		 */
		miPointerPosition (&x, &y);
		if (local->reverse_conversion_proc)
		    (*local->reverse_conversion_proc)(local, x, y, axisvals);
		else
		{
		    axisvals[0] = x;
		    axisvals[1] = y;
		}
	    }
	    loop_start += 6;
	}
a543 10
    va_end(var);
    if (HAS_MOTION_HISTORY(local)) {
	local->last = (local->last + 1) % device->valuator->numMotionEvents;
	if (local->last == local->first)
	    local->first = (local->first + 1) % device->valuator->numMotionEvents;
    }
    DBG(5, ErrorF("xf86PostMotionEvent END   0x%x(%s) is_core=%s is_shared=%s\n",
		  device, device->name,
		  is_core ? "True" : "False",
		  is_shared ? "True" : "False"));
d548 25
a572 79
		       int		is_in,
		       int		first_valuator,
		       int		num_valuators,
		       ...)
{
    va_list			var;
    int				loop;
    xEvent			xE[2];
    deviceKeyButtonPointer	*xev = (deviceKeyButtonPointer*) xE;
    deviceValuator		*xv = (deviceValuator*) xev+1;
    ValuatorClassPtr		val = device->valuator;
    Bool			is_core = xf86IsCorePointer(device);
    Bool			is_absolute = val && ((val->mode & 1) == Relative);
    
    DBG(5, ErrorF("xf86PostProximityEvent BEGIN 0x%x(%s) prox=%s is_core=%s is_absolute=%s\n",
		  device, device->name, is_in ? "true" : "false",
		  is_core ? "True" : "False",
		  is_absolute ? "True" : "False"));
    
    if (is_core) {
	return;
    }
  
    if (num_valuators && (!val || (first_valuator + num_valuators > val->numAxes))) {
	ErrorF("Bad valuators reported for device \"%s\"\n", device->name);
	return;
    }

    xev->type = is_in ? ProximityIn : ProximityOut;
    xev->detail = 0;
    xev->deviceid = device->id | MORE_EVENTS;
	
    xv->type = DeviceValuator;
    xv->deviceid = device->id;
    xv->device_state = 0;

    if ((device->valuator->mode & 1) == Relative) {
	num_valuators = 0;
    }
  
    if (num_valuators != 0) {
	int	*axisvals = val->axisVal;
	    
	va_start(var, num_valuators);

	for(loop=0; loop<num_valuators; loop++) {
	    switch (loop % 6) {
	    case 0:
		xv->valuator0 = is_absolute ? va_arg(var, int) : axisvals[loop]; 
		break;
	    case 1:
		xv->valuator1 = is_absolute ? va_arg(var, int) : axisvals[loop];
		break;
	    case 2:
		xv->valuator2 = is_absolute ? va_arg(var, int) : axisvals[loop];
		break;
	    case 3:
		xv->valuator3 = is_absolute ? va_arg(var, int) : axisvals[loop];
		break;
	    case 4:
		xv->valuator4 = is_absolute ? va_arg(var, int) : axisvals[loop];
		break;
	    case 5:
		xv->valuator5 = is_absolute ? va_arg(var, int) : axisvals[loop];
		break;
	    }
	    if ((loop % 6 == 5) || (loop == num_valuators - 1)) {
		xf86Info.lastEventTime = xev->time = GetTimeInMillis();

		xv->num_valuators = (loop % 6) + 1;
		xv->first_valuator = first_valuator + (loop / 6) * 6;
		ENQUEUE(xE);
	    }
	}
	va_end(var);
    }
    else {
	/* no valuator */
	xf86Info.lastEventTime = xev->time = GetTimeInMillis();
d574 1
a574 9
	xv->num_valuators = 0;
	xv->first_valuator = 0;
	ENQUEUE(xE);
    }
    DBG(5, ErrorF("xf86PostProximityEvent END   0x%x(%s) prox=%s is_core=%s is_absolute=%s\n",
		  device, device->name, is_in ? "true" : "false",
		  is_core ? "True" : "False",
		  is_absolute ? "True" : "False"));
    
d579 17
a595 30
		    int			is_absolute,
		    int			button,
		    int			is_down,
		    int			first_valuator,
		    int			num_valuators,
		    ...)
{
    va_list			var;
    int				loop;
    xEvent			xE[2];
    deviceKeyButtonPointer	*xev	        = (deviceKeyButtonPointer*) xE;
    deviceValuator		*xv	        = (deviceValuator*) xev+1;
    ValuatorClassPtr		val		= device->valuator;
    Bool			is_core		= xf86IsCorePointer(device);
    Bool			is_shared       = xf86ShareCorePointer(device);
    
    DBG(5, ErrorF("xf86PostButtonEvent BEGIN 0x%x(%s) button=%d down=%s is_core=%s is_shared=%s is_absolute=%s\n",
		  device, device->name, button,
		  is_down ? "True" : "False",
		  is_core ? "True" : "False",
		  is_shared ? "True" : "False",
		  is_absolute ? "True" : "False"));
    
    /* Check the core pointer button state not to send an inconsistent
     * event. This can happen with the AlwaysCore feature.
     */
    if ((is_core || is_shared) && 
	!xf86CheckButton(device->button->map[button], is_down)) 
    {
	return;
d597 1
d599 22
a620 71
    if (num_valuators && (!val || (first_valuator + num_valuators > val->numAxes))) {
	ErrorF("Bad valuators reported for device \"%s\"\n", device->name);
	return;
    }

    if (!is_core) {
	xev->type = is_down ? DeviceButtonPress : DeviceButtonRelease;
	xev->detail = button;
	xev->deviceid = device->id | MORE_EVENTS;
	    
	xv->type = DeviceValuator;
	xv->deviceid = device->id;
	xv->device_state = 0;

	if (num_valuators != 0) {
	    int			*axisvals = val->axisVal;
	    
	    va_start(var, num_valuators);
      
	    for(loop=0; loop<num_valuators; loop++) {
		switch (loop % 6) {
		case 0:
		    xv->valuator0 = is_absolute ? va_arg(var, int) : axisvals[loop];
		    break;
		case 1:
		    xv->valuator1 = is_absolute ? va_arg(var, int) : axisvals[loop];
		    break;
		case 2:
		    xv->valuator2 = is_absolute ? va_arg(var, int) : axisvals[loop];
		    break;
		case 3:
		    xv->valuator3 = is_absolute ? va_arg(var, int) : axisvals[loop];
		    break;
		case 4:
		    xv->valuator4 = is_absolute ? va_arg(var, int) : axisvals[loop];
		    break;
		case 5:
		    xv->valuator5 = is_absolute ? va_arg(var, int) : axisvals[loop];
		    break;
		}
		if ((loop % 6 == 5) || (loop == num_valuators - 1)) {
		    xf86Info.lastEventTime = xev->time = GetTimeInMillis();
		    xv->num_valuators = (loop % 6) + 1;
		    xv->first_valuator = first_valuator + (loop / 6) * 6;
		    ENQUEUE(xE);
		    
		}
	    }
	    va_end(var);
	}
	else {
	    /* no valuator */
	    xf86Info.lastEventTime = xev->time = GetTimeInMillis();
	    xv->num_valuators = 0;
	    xv->first_valuator = 0;
	    ENQUEUE(xE);
	}
    }

    /* removed rootX/rootY as DIX sets these fields */
    if (is_core || is_shared) {
	xE->u.u.type = is_down ? ButtonPress : ButtonRelease;
	xE->u.u.detail =  device->button->map[button];
	xf86Info.lastEventTime = xE->u.keyButtonPointer.time = GetTimeInMillis();
	
#ifdef XFreeXDGA
	if (!DGAStealMouseEvent(xf86EventQueue.pEnqueueScreen->myNum, xE, 0, 0))
#endif
	    ENQUEUE(xE);
    }
    DBG(5, ErrorF("xf86PostButtonEvent END\n"));
d625 38
a662 14
		 unsigned int	key_code,
		 int		is_down,
		 int		is_absolute,
		 int		first_valuator,
		 int		num_valuators,
		 ...)
{
    va_list			var;
    int				loop;
    xEvent			xE[2];
    deviceKeyButtonPointer	*xev = (deviceKeyButtonPointer*) xE;
    deviceValuator		*xv = (deviceValuator*) xev+1;
    
    va_start(var, num_valuators);
d664 2
a665 41
    for(loop=0; loop<num_valuators; loop++) {
	switch (loop % 6) {
	case 0:
	    xv->valuator0 = va_arg(var, int);
	    break;
	case 1:
	    xv->valuator1 = va_arg(var, int);
	    break;
	case 2:
	    xv->valuator2 = va_arg(var, int);
	    break;
	case 3:
	    xv->valuator3 = va_arg(var, int);
	    break;
	case 4:
	    xv->valuator4 = va_arg(var, int);
	    break;
	case 5:
	    xv->valuator5 = va_arg(var, int);
	    break;
	}
	if (((loop % 6 == 5) || (loop == num_valuators - 1))) {
	    xev->type = is_down ? DeviceKeyPress : DeviceKeyRelease;
	    xev->detail = key_code;
	    
	    xf86Info.lastEventTime = xev->time = GetTimeInMillis();
	    xev->deviceid = device->id | MORE_EVENTS;
	    
	    xv->type = DeviceValuator;
	    xv->deviceid = device->id;
	    xv->device_state = 0;
	    /* if the device is in the relative mode we don't have to send valuators */
	    xv->num_valuators = is_absolute ? (loop % 6) + 1 : 0;
	    xv->first_valuator = first_valuator + (loop / 6) * 6;
	    
	    ENQUEUE(xE);
	    /* if the device is in the relative mode only one event is needed */
	    if (!is_absolute) break;
	}
    }
    va_end(var);
d673 2
a674 2
    xEvent                      xE[2];
    deviceKeyButtonPointer      *xev = (deviceKeyButtonPointer*) xE;
d676 5
a680 4
    if (xf86IsCoreKeyboard(device)) {
        xev->type = is_down ? KeyPress : KeyRelease;
    } else {
        xev->type = is_down ? DeviceKeyPress : DeviceKeyRelease;
a681 5
    xev->detail = key_code;
    xf86Info.lastEventTime = xev->time = GetTimeInMillis();

#ifdef XFreeXDGA
    /* if(!DGAStealKeyEvent(xf86EventQueue.pEnqueueScreen->myNum, xE)) */
a682 2
    ENQUEUE(xE);
}
d684 4
a687 17
/* 
 * Motion history management.
 */

_X_EXPORT void
xf86MotionHistoryAllocate(LocalDevicePtr	local)
{
    ValuatorClassPtr	valuator = local->dev->valuator;
    
    if (!HAS_MOTION_HISTORY(local))
	return;
    if (local->motion_history) xfree(local->motion_history);
    local->motion_history = xalloc((sizeof(INT32) * valuator->numAxes + sizeof(Time))
				   * valuator->numMotionEvents);
    local->first = 0;
    local->last	 = 0;
}
d689 2
a690 16
_X_EXPORT int
xf86GetMotionEvents(DeviceIntPtr	dev,
		    xTimecoord		*buff,
		    unsigned long	start,
		    unsigned long	stop,
		    ScreenPtr		pScreen)
{
    LocalDevicePtr	local	 = (LocalDevicePtr)dev->public.devicePrivate;
    ValuatorClassPtr	valuator = dev->valuator;
    int			num  	 = 0;
    int			loop	 = local->first;
    int			size;
    Time		current;
    
    if (!HAS_MOTION_HISTORY(local))
	return 0;
d692 2
a693 14
    size = (sizeof(INT32) * valuator->numAxes + sizeof(Time));

    while (loop != local->last) {
	current = *(Time*)(((char *)local->motion_history)+loop*size);
	if (current > stop)
	    return num;
	if (current >= start) {
	    memcpy(((char *)buff)+size*num,
		   ((char *)local->motion_history)+loop*size, size);
	    num++;
	}
	loop = (loop + 1) % valuator->numMotionEvents;
    }
    return num;
d717 4
a720 4
	      int	Sxhigh,
	      int	Sxlow,
	      int	Rxhigh,
	      int	Rxlow )
d755 3
a757 3
    if ((xf86IsCorePointer(local->dev) || xf86ShareCorePointer(local->dev)) &&
	(miPointerCurrentScreen() != screenInfo.screens[screen_number])) {
	miPointerSetNewScreen (screen_number, x, y);
d766 3
a768 8
#ifdef XINPUT
    if (maxval == -1) {
	if (axnum == 0)
	    maxval = screenInfo.screens[0]->width - 1;
	else if (axnum == 1)
	    maxval = screenInfo.screens[0]->height - 1;
	/* else? */
    }
a770 1
#endif
d780 1
a780 2
#ifdef XINPUT
    if (axnum == 0)
d782 3
a784 1
    else if (axnum == 1)
d786 46
a831 1
#endif
@


1.1
log
@Initial revision
@
text
@d953 1
a953 1
			mult = pow((float)(dx*dx+dy*dy),
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d41 1
d49 1
a65 1
#include "xf86Optrec.h"
d76 4
d91 1
d93 13
d107 2
a108 1
#include "mi.h"
d110 3
a112 2
#ifdef XFreeXDGA
#include "dgaproc.h"
d115 43
a157 1
xEvent *xf86Events = NULL;
d164 2
a165 2
    if (device->button && device->button->buttonsDown > 0)
        return (local->flags & XI86_SEND_DRAG_EVENTS);
d167 53
a219 1
        return (TRUE);
d232 1
a232 1
                         pointer	list)
d235 13
a247 7
        !xf86SetBoolOption(list, "SendCoreEvents", 1) ||
        !xf86SetBoolOption(list, "CorePointer", 1) ||
        !xf86SetBoolOption(list, "CoreKeyboard", 1)) {
        xf86Msg(X_CONFIG, "%s: doesn't report core events\n", local->name);
    } else {
        local->flags |= XI86_ALWAYS_CORE;
        xf86Msg(X_CONFIG, "%s: always reports core events\n", local->name);
d251 1
a251 1
        local->flags |= XI86_SEND_DRAG_EVENTS;
d253 1
a253 1
        xf86Msg(X_CONFIG, "%s: doesn't report drag events\n", local->name);
d255 2
d258 29
a286 2
    /* Backwards compatibility. */
    local->history_size = GetMotionHistorySize();
d303 32
a334 1
        dev = AddInputDevice(local->device_control, TRUE);
d336 3
a338 16
        if (dev == NULL)
            FatalError("Too many input devices");
        
        local->atom = MakeAtom(local->type_name,
                               strlen(local->type_name),
                               TRUE);
        AssignTypeAndName(dev, local->atom, local->name);
        dev->public.devicePrivate = (pointer) local;
        local->dev = dev;      
        
        dev->coreEvents = local->flags & XI86_ALWAYS_CORE;
        RegisterOtherDevice(dev);

        if (serverGeneration == 1) 
            xf86Msg(X_INFO, "XINPUT: Adding extended input device \"%s\" (type: %s)\n",
                    local->name, local->type_name);
d369 90
a458 2
                ClientPtr	client,
                int		*status)
d460 10
a469 2
    if (!dev->inited)
        ActivateDevice(dev);
d471 25
a495 1
    *status = Success;
d498 15
d514 1
a514 2
CloseInputDevice(DeviceIntPtr dev,
                 ClientPtr client)
d516 1
d519 34
d594 1
a594 1
                    int first_valuator, int num_valuators)
d596 1
a596 7
    LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;

    if (local->set_device_valuators)
	return (*local->set_device_valuators)(local, valuators, first_valuator,
					      num_valuators);

    return BadMatch;
d615 1
a615 10
      switch (control->control) {
      case DEVICE_CORE:
      case DEVICE_RESOLUTION:
      case DEVICE_ABS_CALIB:
      case DEVICE_ABS_AREA:
      case DEVICE_ENABLE:
        return Success;
      default:
        return BadMatch;
      }
d621 1
d623 38
a660 3
void
AddOtherInputDevices()
{
a661 1
#endif
d663 9
a671 2
int
NewInputDeviceRequest (InputOption *options, DeviceIntPtr *pdev)
d673 39
a711 107
    IDevRec *idev = NULL;
    InputDriverPtr drv = NULL;
    InputInfoPtr pInfo = NULL;
    InputOption *option = NULL;
    DeviceIntPtr dev = NULL;
    int rval = Success;
    int is_auto = 0;

    idev = xcalloc(sizeof(*idev), 1);
    if (!idev)
        return BadAlloc;

    for (option = options; option; option = option->next) {
        if (strcasecmp(option->key, "driver") == 0) {
            if (idev->driver) {
                rval = BadRequest;
                goto unwind;
            }
            /* Memory leak for every attached device if we don't
             * test if the module is already loaded first */
            drv = xf86LookupInputDriver(option->value);
            if (!drv)
                if (xf86LoadOneModule(option->value, NULL))
                    drv = xf86LookupInputDriver(option->value);
            if (!drv) {
                xf86Msg(X_ERROR, "No input driver matching `%s'\n",
                        option->value);
                rval = BadName;
                goto unwind;
            }
            idev->driver = xstrdup(option->value);
            if (!idev->driver) {
                rval = BadAlloc;
                goto unwind;
            }
        }

        if (strcasecmp(option->key, "name") == 0 ||
            strcasecmp(option->key, "identifier") == 0) {
            if (idev->identifier) {
                rval = BadRequest;
                goto unwind;
            }
            idev->identifier = xstrdup(option->value);
            if (!idev->identifier) {
                rval = BadAlloc;
                goto unwind;
            }
        }

        /* Right now, the only automatic config we know of is HAL. */
        if (strcmp(option->key, "_source") == 0 &&
            strcmp(option->value, "server/hal") == 0) {
            if (!xf86Info.autoAddDevices) {
                rval = BadMatch;
                goto unwind;
            }

            is_auto = 1;
        }
    }
    if (!idev->driver || !idev->identifier) {
        xf86Msg(X_ERROR, "No input driver/identifier specified (ignoring)\n");
        rval = BadRequest;
        goto unwind;
    }

    if (!drv->PreInit) {
        xf86Msg(X_ERROR,
                "Input driver `%s' has no PreInit function (ignoring)\n",
                drv->driverName);
        rval = BadImplementation;
        goto unwind;
    }

    for (option = options; option; option = option->next) {
        /* Steal option key/value strings from the provided list.
         * We need those strings, the InputOption list doesn't. */
        idev->commonOptions = xf86addNewOption(idev->commonOptions,
                                               option->key, option->value);
        option->key = NULL;
        option->value = NULL;
    }

    pInfo = drv->PreInit(drv, idev, 0);

    if (!pInfo) {
        xf86Msg(X_ERROR, "PreInit returned NULL for \"%s\"\n", idev->identifier);
        rval = BadMatch;
        goto unwind;
    }
    else if (!(pInfo->flags & XI86_CONFIGURED)) {
        xf86Msg(X_ERROR, "PreInit failed for input device \"%s\"\n",
                idev->identifier);
        rval = BadMatch;
        goto unwind;
    }

    xf86ActivateDevice(pInfo);

    dev = pInfo->dev;
    ActivateDevice(dev);
    /* Enable it if it's properly initialised, we're currently in the VT, and
     * either it's a manual request, or we're automatically enabling devices. */
    if (dev->inited && dev->startup && xf86Screens[0]->vtSema &&
        (!is_auto || xf86Info.autoEnableDevices))
        EnableDevice(dev);
d713 35
a747 17
    *pdev = dev;
    return Success;

unwind:
    if(pInfo) {
        if(drv->UnInit)
            drv->UnInit(drv, pInfo, 0);
        else
            xf86DeleteInput(pInfo, 0);
    }
    if(idev->driver)
        xfree(idev->driver);
    if(idev->identifier)
        xfree(idev->identifier);
    xf86optionListFree(idev->commonOptions);
    xfree(idev);
    return rval;
d750 3
d754 1
a754 1
DeleteInputDeviceRequest(DeviceIntPtr pDev)
d756 13
a768 3
    LocalDevicePtr pInfo = (LocalDevicePtr) pDev->public.devicePrivate;
    InputDriverPtr drv = pInfo->drv;
    IDevRec *idev = pInfo->conf_idev;
d770 6
a775 1
    RemoveDevice(pDev);
d777 38
a814 4
    if(drv->UnInit)
        drv->UnInit(drv, pInfo, 0);
    else
        xf86DeleteInput(pInfo, 0);
d816 44
a859 4
    xfree(idev->driver);
    xfree(idev->identifier);
    xf86optionListFree(idev->commonOptions);
    xfree(idev);
d868 40
a907 18
                    int			is_absolute,
                    int			first_valuator,
                    int			num_valuators,
                    ...)
{
    va_list var;
    int i = 0;
    static int *valuators = NULL;
    static int n_valuators = 0;

    if (num_valuators > n_valuators) {
	xfree (valuators);
	valuators = NULL;
    }

    if (!valuators) {
	valuators = xcalloc(sizeof(int), num_valuators);
	n_valuators = num_valuators;
d910 7
a917 3
    for (i = 0; i < num_valuators; i++)
        valuators[i] = va_arg(var, int);
    va_end(var);
d919 127
a1045 38
    xf86PostMotionEventP(device, is_absolute, first_valuator, num_valuators, valuators);
}

_X_EXPORT void
xf86PostMotionEventP(DeviceIntPtr	device,
                    int			is_absolute,
                    int			first_valuator,
                    int			num_valuators,
                    int			*valuators)
{
    int i = 0, nevents = 0;
    int dx, dy;
    Bool drag = xf86SendDragEvents(device);
    xEvent *xE = NULL;
    int index;
    int flags = 0;

    if (is_absolute)
        flags = POINTER_ABSOLUTE;
    else
        flags = POINTER_RELATIVE | POINTER_ACCELERATE;

#if XFreeXDGA
    if (first_valuator == 0 && num_valuators >= 2) {
        if (miPointerGetScreen(inputInfo.pointer)) {
            index = miPointerGetScreen(inputInfo.pointer)->myNum;
            if (is_absolute) {
                dx = valuators[0] - device->valuator->lastx;
                dy = valuators[1] - device->valuator->lasty;
            }
            else {
                dx = valuators[0];
                dy = valuators[1];
            }
            if (DGAStealMotionEvent(index, dx, dy))
                return;
        }
    }
d1047 23
a1069 17

    if (!xf86Events)
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");

    nevents = GetPointerEvents(xf86Events, device, MotionNotify, 0,
                               flags, first_valuator, num_valuators,
                               valuators);

    for (i = 0; i < nevents; i++) {
        xE = xf86Events + i;
        /* Don't post core motion events for devices not registered to send
         * drag events. */
        if (xE->u.u.type != MotionNotify || drag) {
            mieqEnqueue(device, xf86Events + i);
        }
d1071 10
d1085 79
a1163 7
                       int		is_in,
                       int		first_valuator,
                       int		num_valuators,
                       ...)
{
    va_list var;
    int i, nevents, *valuators = NULL;
d1165 9
a1173 19
    valuators = xcalloc(sizeof(int), num_valuators);

    va_start(var, num_valuators);
    for (i = 0; i < num_valuators; i++)
        valuators[i] = va_arg(var, int);
    va_end(var);

    if (!xf86Events)
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");

    nevents = GetProximityEvents(xf86Events, device,
                                 is_in ? ProximityIn : ProximityOut, 
                                 first_valuator, num_valuators, valuators);
    for (i = 0; i < nevents; i++)
        mieqEnqueue(device, xf86Events + i);

    xfree(valuators);
d1178 30
a1207 17
                    int			is_absolute,
                    int			button,
                    int			is_down,
                    int			first_valuator,
                    int			num_valuators,
                    ...)
{
    va_list var;
    int *valuators = NULL;
    int i = 0, nevents = 0;
    int index;

#if XFreeXDGA
    if (miPointerGetScreen(inputInfo.pointer)) {
        index = miPointerGetScreen(inputInfo.pointer)->myNum;
        if (DGAStealButtonEvent(index, button, is_down))
            return;
d1209 68
d1278 3
a1280 23
    
    valuators = xcalloc(sizeof(int), num_valuators);

    va_start(var, num_valuators);
    for (i = 0; i < num_valuators; i++)
        valuators[i] = va_arg(var, int);
    va_end(var);

    if (!xf86Events)
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");

    nevents = GetPointerEvents(xf86Events, device,
                               is_down ? ButtonPress : ButtonRelease, button,
                               is_absolute ? POINTER_ABSOLUTE :
                                             POINTER_RELATIVE,
                               first_valuator, num_valuators, valuators);

    for (i = 0; i < nevents; i++)
        mieqEnqueue(device, xf86Events + i);

    xfree(valuators);
d1285 54
a1338 32
                 unsigned int	key_code,
                 int		is_down,
                 int		is_absolute,
                 int		first_valuator,
                 int		num_valuators,
                 ...)
{
    va_list var;
    int i = 0, nevents = 0, *valuators = NULL;

    /* instil confidence in the user */
    DebugF("this function has never been tested properly.  if things go quite "
           "badly south after this message, then xf86PostKeyEvent is "
           "broken.\n");

    if (!xf86Events)
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");

    if (is_absolute) {
        valuators = xcalloc(sizeof(int), num_valuators);
        va_start(var, num_valuators);
        for (i = 0; i < num_valuators; i++)
            valuators[i] = va_arg(var, int);
        va_end(var);

        nevents = GetKeyboardValuatorEvents(xf86Events, device,
                                            is_down ? KeyPress : KeyRelease,
                                            key_code, first_valuator,
                                            num_valuators, valuators);
        xfree(valuators);
d1340 1
a1340 8
    else {
        nevents = GetKeyboardEvents(xf86Events, device,
                                    is_down ? KeyPress : KeyRelease,
                                    key_code);
    }

    for (i = 0; i < nevents; i++)
        mieqEnqueue(device, xf86Events + i);
d1348 2
a1349 2
    int nevents = 0, i = 0;
    int index;
d1351 4
a1354 5
#if XFreeXDGA
    if (miPointerGetScreen(inputInfo.pointer)) {
        index = miPointerGetScreen(inputInfo.pointer)->myNum;
        if (DGAStealKeyEvent(index, key_code, is_down))
            return;
d1356 5
d1362 2
d1365 17
a1381 4
    if (!xf86Events)
        xf86Events = (xEvent *)xcalloc(sizeof(xEvent), GetMaximumEventsNum());
    if (!xf86Events)
        FatalError("Couldn't allocate event store\n");
d1383 16
a1398 2
    nevents = GetKeyboardEvents(xf86Events, device,
                                is_down ? KeyPress : KeyRelease, key_code);
d1400 14
a1413 2
    for (i = 0; i < nevents; i++)
        mieqEnqueue(device, xf86Events + i);
d1437 4
a1440 4
              int	Sxhigh,
              int	Sxlow,
              int	Rxhigh,
              int	Rxlow )
d1475 3
a1477 3
    if (miPointerGetScreen(local->dev) !=
          screenInfo.screens[screen_number]) {
	miPointerSetScreen(local->dev, screen_number, x, y);
d1486 8
a1493 3
    if (!dev || !dev->valuator)
        return;

d1496 1
d1506 2
a1507 1
    if (axnum == 0) {
d1509 1
a1509 3
        dev->valuator->lastx = dev->valuator->axisVal[0];
    }
    else if (axnum == 1) {
d1511 1
a1511 46
        dev->valuator->lasty = dev->valuator->axisVal[1];
    }
}


/**
 * Deactivate a device. Call this function from the driver if you receive a
 * read error or something else that spoils your day.
 * Device will be moved to the off_devices list, but it will still be there
 * until you really clean up after it.
 * Notifies the client about an inactive device.
 * 
 * @@param panic True if device is unrecoverable and needs to be removed.
 */
_X_EXPORT void
xf86DisableDevice(DeviceIntPtr dev, Bool panic)
{
    devicePresenceNotify ev;
    DeviceIntRec dummyDev;

    if(!panic)
    {
        DisableDevice(dev);
    } else
    {
        ev.type = DevicePresenceNotify;
        ev.time = currentTime.milliseconds;
        ev.devchange = DeviceUnrecoverable;
        ev.deviceid = dev->id;
        dummyDev.id = 0;
        SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                (xEvent *) &ev, 1);

        DeleteInputDeviceRequest(dev);
    }
}

/**
 * Reactivate a device. Call this function from the driver if you just found
 * out that the read error wasn't quite that bad after all.
 * Device will be re-activated, and an event sent to the client. 
 */
_X_EXPORT void
xf86EnableDevice(DeviceIntPtr dev)
{
    EnableDevice(dev);
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@a167 5
#ifdef XKB
        if (!noXkbExtension)
            XkbSetExtension(dev, ProcessKeyboardEvent);
#endif

@


