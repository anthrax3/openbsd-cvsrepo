head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.02;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.02;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.39;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@
/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

/*
 * This file contains definitions of the public XFree86 data structures/types.
 * Any data structures that video drivers need to access should go here.
 */

#ifndef _XF86STR_H
#define _XF86STR_H

#include "misc.h"
#include "input.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "colormapst.h"
#include "xf86Module.h"
#include "xf86Opt.h"
#include "displaymode.h"

/**
 * Integer type that is of the size of the addressable memory (machine size).
 * On most platforms \c uintptr_t will suffice.  However, on some mixed
 * 32-bit / 64-bit platforms, such as 32-bit binaries on 64-bit PowerPC, this
 * must be 64-bits.
 */
#include <inttypes.h>
#if defined(__powerpc__)
typedef uint64_t memType;
#else
typedef uintptr_t memType;
#endif

/* Video mode flags */

typedef enum {
    V_PHSYNC = 0x0001,
    V_NHSYNC = 0x0002,
    V_PVSYNC = 0x0004,
    V_NVSYNC = 0x0008,
    V_INTERLACE = 0x0010,
    V_DBLSCAN = 0x0020,
    V_CSYNC = 0x0040,
    V_PCSYNC = 0x0080,
    V_NCSYNC = 0x0100,
    V_HSKEW = 0x0200,           /* hskew provided */
    V_BCAST = 0x0400,
    V_PIXMUX = 0x1000,
    V_DBLCLK = 0x2000,
    V_CLKDIV2 = 0x4000
} ModeFlags;

typedef enum {
    INTERLACE_HALVE_V = 0x0001  /* Halve V values for interlacing */
} CrtcAdjustFlags;

/* Flags passed to ChipValidMode() */
typedef enum {
    MODECHECK_INITIAL = 0,
    MODECHECK_FINAL = 1
} ModeCheckFlags;

/*
 * The mode sets are, from best to worst: USERDEF, DRIVER, and DEFAULT/BUILTIN.
 * Preferred will bubble a mode to the top within a set.
 */
#define M_T_BUILTIN 0x01        /* built-in mode */
#define M_T_CLOCK_C (0x02 | M_T_BUILTIN)        /* built-in mode - configure clock */
#define M_T_CRTC_C  (0x04 | M_T_BUILTIN)        /* built-in mode - configure CRTC  */
#define M_T_CLOCK_CRTC_C  (M_T_CLOCK_C | M_T_CRTC_C)
                               /* built-in mode - configure CRTC and clock */
#define M_T_PREFERRED 0x08      /* preferred mode within a set */
#define M_T_DEFAULT 0x10        /* (VESA) default modes */
#define M_T_USERDEF 0x20        /* One of the modes from the config file */
#define M_T_DRIVER  0x40        /* Supplied by the driver (EDID, etc) */
#define M_T_USERPREF 0x80       /* mode preferred by the user config */

/* The monitor description */

#define MAX_HSYNC 8
#define MAX_VREFRESH 8

typedef struct {
    float hi, lo;
} range;

typedef struct {
    CARD32 red, green, blue;
} rgb;

typedef struct {
    float red, green, blue;
} Gamma;

/* The permitted gamma range is 1 / GAMMA_MAX <= g <= GAMMA_MAX */
#define GAMMA_MAX	10.0
#define GAMMA_MIN	(1.0 / GAMMA_MAX)
#define GAMMA_ZERO	(GAMMA_MIN / 100.0)

typedef struct {
    const char *id;
    const char *vendor;
    const char *model;
    int nHsync;
    range hsync[MAX_HSYNC];
    int nVrefresh;
    range vrefresh[MAX_VREFRESH];
    DisplayModePtr Modes;       /* Start of the monitor's mode list */
    DisplayModePtr Last;        /* End of the monitor's mode list */
    Gamma gamma;                /* Gamma of the monitor */
    int widthmm;
    int heightmm;
    void *options;
    void *DDC;
    Bool reducedblanking;       /* Allow CVT reduced blanking modes? */
    int maxPixClock;            /* in kHz, like mode->Clock */
} MonRec, *MonPtr;

/* the list of clock ranges */
typedef struct x_ClockRange {
    struct x_ClockRange *next;
    int minClock;               /* (kHz) */
    int maxClock;               /* (kHz) */
    int clockIndex;             /* -1 for programmable clocks */
    Bool interlaceAllowed;
    Bool doubleScanAllowed;
    int ClockMulFactor;
    int ClockDivFactor;
    int PrivFlags;
} ClockRange, *ClockRangePtr;

/*
 * The driverFunc. xorgDriverFuncOp specifies the action driver should
 * perform. If requested option is not supported function should return
 * FALSE. pointer can be used to pass arguments to the function or
 * to return data to the caller.
 */
typedef struct _ScrnInfoRec *ScrnInfoPtr;

/* do not change order */
typedef enum {
    RR_GET_INFO,
    RR_SET_CONFIG,
    RR_GET_MODE_MM,
    GET_REQUIRED_HW_INTERFACES = 10,
    SUPPORTS_SERVER_FDS = 11,
} xorgDriverFuncOp;

typedef Bool xorgDriverFuncProc(ScrnInfoPtr, xorgDriverFuncOp, void *);

/* RR_GET_INFO, RR_SET_CONFIG */
typedef struct {
    int rotation;
    int rate;
    int width;
    int height;
} xorgRRConfig;

typedef union {
    short RRRotations;
    xorgRRConfig RRConfig;
} xorgRRRotation, *xorgRRRotationPtr;

/* RR_GET_MODE_MM */
typedef struct {
    DisplayModePtr mode;
    int virtX;
    int virtY;
    int mmWidth;
    int mmHeight;
} xorgRRModeMM, *xorgRRModeMMPtr;

/* GET_REQUIRED_HW_INTERFACES */
#define HW_IO 1
#define HW_MMIO 2
#define HW_SKIP_CONSOLE 4
#define NEED_IO_ENABLED(x) (x & HW_IO)

typedef CARD32 xorgHWFlags;

/*
 * The driver list struct.  This contains the information required for each
 * driver before a ScrnInfoRec has been allocated.
 */
struct _DriverRec;

typedef struct {
    int driverVersion;
    const char *driverName;
    void (*Identify) (int flags);
    Bool (*Probe) (struct _DriverRec * drv, int flags);
    const OptionInfoRec *(*AvailableOptions) (int chipid, int bustype);
    void *module;
    int refCount;
} DriverRec1;

struct _SymTabRec;
struct _PciChipsets;

struct pci_device;
struct xf86_platform_device;

typedef struct _DriverRec {
    int driverVersion;
    const char *driverName;
    void (*Identify) (int flags);
    Bool (*Probe) (struct _DriverRec * drv, int flags);
    const OptionInfoRec *(*AvailableOptions) (int chipid, int bustype);
    void *module;
    int refCount;
    xorgDriverFuncProc *driverFunc;

    const struct pci_id_match *supported_devices;
    Bool (*PciProbe) (struct _DriverRec * drv, int entity_num,
                      struct pci_device * dev, intptr_t match_data);
    Bool (*platformProbe) (struct _DriverRec * drv, int entity_num, int flags,
                           struct xf86_platform_device * dev, intptr_t match_data);
} DriverRec, *DriverPtr;

/*
 * platform probe flags
 */
#define PLATFORM_PROBE_GPU_SCREEN 1

/*
 *  AddDriver flags
 */
#define HaveDriverFuncs 1

/*
 * These are the private bus types.  New types can be added here.  Types
 * required for the public interface should be added to xf86str.h, with
 * function prototypes added to xf86.h.
 */

/* Tolerate prior #include <linux/input.h> */
#if defined(linux)
#undef BUS_NONE
#undef BUS_PCI
#undef BUS_SBUS
#undef BUS_PLATFORM
#undef BUS_last
#endif

typedef enum {
    BUS_NONE,
    BUS_PCI,
    BUS_SBUS,
    BUS_PLATFORM,
    BUS_last                    /* Keep last */
} BusType;

typedef struct {
    int fbNum;
} SbusBusId;

typedef struct _bus {
    BusType type;
    union {
        struct pci_device *pci;
        SbusBusId sbus;
        struct xf86_platform_device *plat;
    } id;
} BusRec, *BusPtr;

typedef enum {
    DAC_BPP8 = 0,
    DAC_BPP16,
    DAC_BPP24,
    DAC_BPP32,
    MAXDACSPEEDS
} DacSpeedIndex;

typedef struct {
    const char *identifier;
    const char *vendor;
    const char *board;
    const char *chipset;
    const char *ramdac;
    const char *driver;
    struct _confscreenrec *myScreenSection;
    Bool claimed;
    int dacSpeeds[MAXDACSPEEDS];
    int numclocks;
    int clock[MAXCLOCKS];
    const char *clockchip;
    const char *busID;
    Bool active;
    Bool inUse;
    int videoRam;
    unsigned long BiosBase;     /* Base address of video BIOS */
    unsigned long MemBase;      /* Frame buffer base address */
    unsigned long IOBase;
    int chipID;
    int chipRev;
    void *options;
    int irq;
    int screen;                 /* For multi-CRTC cards */
} GDevRec, *GDevPtr;

typedef struct {
    int frameX0;
    int frameY0;
    int virtualX;
    int virtualY;
    int depth;
    int fbbpp;
    rgb weight;
    rgb blackColour;
    rgb whiteColour;
    int defaultVisual;
    const char **modes;
    void *options;
} DispRec, *DispPtr;

typedef struct _confxvportrec {
    const char *identifier;
    void *options;
} confXvPortRec, *confXvPortPtr;

typedef struct _confxvadaptrec {
    const char *identifier;
    int numports;
    confXvPortPtr ports;
    void *options;
} confXvAdaptorRec, *confXvAdaptorPtr;

#define MAX_GPUDEVICES 4
typedef struct _confscreenrec {
    const char *id;
    int screennum;
    int defaultdepth;
    int defaultbpp;
    int defaultfbbpp;
    MonPtr monitor;
    GDevPtr device;
    int numdisplays;
    DispPtr displays;
    int numxvadaptors;
    confXvAdaptorPtr xvadaptors;
    void *options;

    int num_gpu_devices;
    GDevPtr gpu_devices[MAX_GPUDEVICES];
} confScreenRec, *confScreenPtr;

typedef enum {
    PosObsolete = -1,
    PosAbsolute = 0,
    PosRightOf,
    PosLeftOf,
    PosAbove,
    PosBelow,
    PosRelative
} PositionType;

typedef struct _screenlayoutrec {
    confScreenPtr screen;
    const char *topname;
    confScreenPtr top;
    const char *bottomname;
    confScreenPtr bottom;
    const char *leftname;
    confScreenPtr left;
    const char *rightname;
    confScreenPtr right;
    PositionType where;
    int x;
    int y;
    const char *refname;
    confScreenPtr refscreen;
} screenLayoutRec, *screenLayoutPtr;

typedef struct _InputInfoRec InputInfoRec;

typedef struct _serverlayoutrec {
    const char *id;
    screenLayoutPtr screens;
    GDevPtr inactives;
    InputInfoRec **inputs;      /* NULL terminated */
    void *options;
} serverLayoutRec, *serverLayoutPtr;

typedef struct _confdribufferrec {
    int count;
    int size;
    enum {
        XF86DRI_WC_HINT = 0x0001        /* Placeholder: not implemented */
    } flags;
} confDRIBufferRec, *confDRIBufferPtr;

typedef struct _confdrirec {
    int group;
    int mode;
    int bufs_count;
    confDRIBufferRec *bufs;
} confDRIRec, *confDRIPtr;

/* These values should be adjusted when new fields are added to ScrnInfoRec */
#define NUM_RESERVED_INTS		16
#define NUM_RESERVED_POINTERS		14
#define NUM_RESERVED_FUNCS		10

/* let clients know they can use this */
#define XF86_SCRN_HAS_PREFER_CLONE 1

typedef void *(*funcPointer) (void);

/* flags for depth 24 pixmap options */
typedef enum {
    Pix24DontCare = 0,
    Pix24Use24,
    Pix24Use32
} Pix24Flags;

/* Power management events: so far we only support APM */

typedef enum {
    XF86_APM_UNKNOWN = -1,
    XF86_APM_SYS_STANDBY,
    XF86_APM_SYS_SUSPEND,
    XF86_APM_CRITICAL_SUSPEND,
    XF86_APM_USER_STANDBY,
    XF86_APM_USER_SUSPEND,
    XF86_APM_STANDBY_RESUME,
    XF86_APM_NORMAL_RESUME,
    XF86_APM_CRITICAL_RESUME,
    XF86_APM_LOW_BATTERY,
    XF86_APM_POWER_STATUS_CHANGE,
    XF86_APM_UPDATE_TIME,
    XF86_APM_CAPABILITY_CHANGED,
    XF86_APM_STANDBY_FAILED,
    XF86_APM_SUSPEND_FAILED
} pmEvent;

typedef enum {
    PM_WAIT,
    PM_CONTINUE,
    PM_FAILED,
    PM_NONE
} pmWait;

typedef struct _PciChipsets {
    /**
     * Key used to match this device with its name in an array of
     * \c SymTabRec.
     */
    int numChipset;

    /**
     * This value is quirky.  Depending on the driver, it can take on one of
     * three meanings.  In drivers that have exactly one vendor ID (e.g.,
     * radeon, mga, i810) the low 16-bits are the device ID.
     *
     * In drivers that can have multiple vendor IDs (e.g., the glint driver
     * can have either 3dlabs' ID or TI's ID, the i740 driver can have either
     * Intel's ID or Real3D's ID, etc.) the low 16-bits are the device ID and
     * the high 16-bits are the vendor ID.
     *
     * In drivers that don't have a specific vendor (e.g., vga) contains the
     * device ID for either the generic VGA or generic 8514 devices.  This
     * turns out to be the same as the subclass and programming interface
     * value (e.g., the full 24-bit class for the VGA device is 0x030000 (or
     * 0x000101) and for 8514 is 0x030001).
     */
    int PCIid;

/* dummy place holders for drivers to build against old/new servers */
#define RES_UNDEFINED NULL
#define RES_EXCLUSIVE_VGA NULL
#define RES_SHARED_VGA NULL
    void *dummy;
} PciChipsets;

/* Entity properties */
typedef void (*EntityProc) (int entityIndex, void *private);

typedef struct _entityInfo {
    int index;
    BusRec location;
    int chipset;
    Bool active;
    GDevPtr device;
    DriverPtr driver;
} EntityInfoRec, *EntityInfoPtr;

/* DGA */

typedef struct {
    int num;                    /* A unique identifier for the mode (num > 0) */
    DisplayModePtr mode;
    int flags;                  /* DGA_CONCURRENT_ACCESS, etc... */
    int imageWidth;             /* linear accessible portion (pixels) */
    int imageHeight;
    int pixmapWidth;            /* Xlib accessible portion (pixels) */
    int pixmapHeight;           /* both fields ignored if no concurrent access */
    int bytesPerScanline;
    int byteOrder;              /* MSBFirst, LSBFirst */
    int depth;
    int bitsPerPixel;
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    short visualClass;
    int viewportWidth;
    int viewportHeight;
    int xViewportStep;          /* viewport position granularity */
    int yViewportStep;
    int maxViewportX;           /* max viewport origin */
    int maxViewportY;
    int viewportFlags;          /* types of page flipping possible */
    int offset;                 /* offset into physical memory */
    unsigned char *address;     /* server's mapped framebuffer */
    int reserved1;
    int reserved2;
} DGAModeRec, *DGAModePtr;

typedef struct {
    DGAModePtr mode;
    PixmapPtr pPix;
} DGADeviceRec, *DGADevicePtr;

/*
 * Flags for driver Probe() functions.
 */
#define PROBE_DEFAULT	  0x00
#define PROBE_DETECT	  0x01
#define PROBE_TRYHARD	  0x02

/*
 * Driver entry point types
 */

typedef Bool xf86ProbeProc(DriverPtr, int);
typedef Bool xf86PreInitProc(ScrnInfoPtr, int);
typedef Bool xf86ScreenInitProc(ScreenPtr, int, char **);
typedef Bool xf86SwitchModeProc(ScrnInfoPtr, DisplayModePtr);
typedef void xf86AdjustFrameProc(ScrnInfoPtr, int, int);
typedef Bool xf86EnterVTProc(ScrnInfoPtr);
typedef void xf86LeaveVTProc(ScrnInfoPtr);
typedef void xf86FreeScreenProc(ScrnInfoPtr);
typedef ModeStatus xf86ValidModeProc(ScrnInfoPtr, DisplayModePtr, Bool, int);
typedef void xf86EnableDisableFBAccessProc(ScrnInfoPtr, Bool);
typedef int xf86SetDGAModeProc(ScrnInfoPtr, int, DGADevicePtr);
typedef int xf86ChangeGammaProc(ScrnInfoPtr, Gamma);
typedef void xf86PointerMovedProc(ScrnInfoPtr, int, int);
typedef Bool xf86PMEventProc(ScrnInfoPtr, pmEvent, Bool);
typedef void xf86DPMSSetProc(ScrnInfoPtr, int, int);
typedef void xf86LoadPaletteProc(ScrnInfoPtr, int, int *, LOCO *, VisualPtr);
typedef void xf86SetOverscanProc(ScrnInfoPtr, int);
typedef void xf86ModeSetProc(ScrnInfoPtr);

/*
 * ScrnInfoRec
 *
 * There is one of these for each screen, and it holds all the screen-specific
 * information.
 *
 * Note: the size and layout must be kept the same across versions.  New
 * fields are to be added in place of the "reserved*" fields.  No fields
 * are to be dependent on compile-time defines.
 */

typedef struct _ScrnInfoRec {
    int driverVersion;
    const char *driverName;     /* canonical name used in */
    /* the config file */
    ScreenPtr pScreen;          /* Pointer to the ScreenRec */
    int scrnIndex;              /* Number of this screen */
    Bool configured;            /* Is this screen valid */
    int origIndex;              /* initial number assigned to
                                 * this screen before
                                 * finalising the number of
                                 * available screens */

    /* Display-wide screenInfo values needed by this screen */
    int imageByteOrder;
    int bitmapScanlineUnit;
    int bitmapScanlinePad;
    int bitmapBitOrder;
    int numFormats;
    PixmapFormatRec formats[MAXFORMATS];
    PixmapFormatRec fbFormat;

    int bitsPerPixel;           /* fb bpp */
    Pix24Flags pixmap24;        /* pixmap pref for depth 24 */
    int depth;                  /* depth of default visual */
    MessageType depthFrom;      /* set from config? */
    MessageType bitsPerPixelFrom;       /* set from config? */
    rgb weight;                 /* r/g/b weights */
    rgb mask;                   /* rgb masks */
    rgb offset;                 /* rgb offsets */
    int rgbBits;                /* Number of bits in r/g/b */
    Gamma gamma;                /* Gamma of the monitor */
    int defaultVisual;          /* default visual class */
    int maxHValue;              /* max horizontal timing */
    int maxVValue;              /* max vertical timing value */
    int virtualX;               /* Virtual width */
    int virtualY;               /* Virtual height */
    int xInc;                   /* Horizontal timing increment */
    MessageType virtualFrom;    /* set from config? */
    int displayWidth;           /* memory pitch */
    int frameX0;                /* viewport position */
    int frameY0;
    int frameX1;
    int frameY1;
    int zoomLocked;             /* Disallow mode changes */
    DisplayModePtr modePool;    /* list of compatible modes */
    DisplayModePtr modes;       /* list of actual modes */
    DisplayModePtr currentMode; /* current mode
                                 * This was previously
                                 * overloaded with the modes
                                 * field, which is a pointer
                                 * into a circular list */
    confScreenPtr confScreen;   /* Screen config info */
    MonPtr monitor;             /* Monitor information */
    DispPtr display;            /* Display information */
    int *entityList;            /* List of device entities */
    int numEntities;
    int widthmm;                /* physical display dimensions
                                 * in mm */
    int heightmm;
    int xDpi;                   /* width DPI */
    int yDpi;                   /* height DPI */
    const char *name;           /* Name to prefix messages */
    void *driverPrivate;        /* Driver private area */
    DevUnion *privates;         /* Other privates can hook in
                                 * here */
    DriverPtr drv;              /* xf86DriverList[] entry */
    void *module;               /* Pointer to module head */
    int colorKey;
    int overlayFlags;

    /* Some of these may be moved out of here into the driver private area */

    const char *chipset;        /* chipset name */
    const char *ramdac;         /* ramdac name */
    const char *clockchip;      /* clock name */
    Bool progClock;             /* clock is programmable */
    int numClocks;              /* number of clocks */
    int clock[MAXCLOCKS];       /* list of clock frequencies */
    int videoRam;               /* amount of video ram (kb) */
    unsigned long biosBase;     /* Base address of video BIOS */
    unsigned long memPhysBase;  /* Physical address of FB */
    unsigned long fbOffset;     /* Offset of FB in the above */
    int memClk;                 /* memory clock */
    Bool flipPixels;            /* swap default black/white */
    void *options;

    int chipID;
    int chipRev;

    /* Allow screens to be enabled/disabled individually */
    Bool vtSema;

    /* hw cursor moves at SIGIO time */
    Bool silkenMouse;

    /* Storage for clockRanges and adjustFlags for use with the VidMode ext */
    ClockRangePtr clockRanges;
    int adjustFlags;

    /* initial rightof support disable */
    int                 preferClone;

    /*
     * These can be used when the minor ABI version is incremented.
     * The NUM_* parameters must be reduced appropriately to keep the
     * structure size and alignment unchanged.
     */
    int reservedInt[NUM_RESERVED_INTS];

    int *entityInstanceList;
    struct pci_device *vgaDev;

    void *reservedPtr[NUM_RESERVED_POINTERS];

    /*
     * Driver entry points.
     *
     */

    xf86ProbeProc *Probe;
    xf86PreInitProc *PreInit;
    xf86ScreenInitProc *ScreenInit;
    xf86SwitchModeProc *SwitchMode;
    xf86AdjustFrameProc *AdjustFrame;
    xf86EnterVTProc *EnterVT;
    xf86LeaveVTProc *LeaveVT;
    xf86FreeScreenProc *FreeScreen;
    xf86ValidModeProc *ValidMode;
    xf86EnableDisableFBAccessProc *EnableDisableFBAccess;
    xf86SetDGAModeProc *SetDGAMode;
    xf86ChangeGammaProc *ChangeGamma;
    xf86PointerMovedProc *PointerMoved;
    xf86PMEventProc *PMEvent;
    xf86DPMSSetProc *DPMSSet;
    xf86LoadPaletteProc *LoadPalette;
    xf86SetOverscanProc *SetOverscan;
    xorgDriverFuncProc *DriverFunc;
    xf86ModeSetProc *ModeSet;

    /*
     * This can be used when the minor ABI version is incremented.
     * The NUM_* parameter must be reduced appropriately to keep the
     * structure size and alignment unchanged.
     */
    funcPointer reservedFuncs[NUM_RESERVED_FUNCS];

    Bool is_gpu;
    uint32_t capabilities;
} ScrnInfoRec;

typedef struct {
    Bool (*OpenFramebuffer) (ScrnInfoPtr pScrn,
                             char **name,
                             unsigned char **mem,
                             int *size, int *offset, int *extra);
    void (*CloseFramebuffer) (ScrnInfoPtr pScrn);
    Bool (*SetMode) (ScrnInfoPtr pScrn, DGAModePtr pMode);
    void (*SetViewport) (ScrnInfoPtr pScrn, int x, int y, int flags);
    int (*GetViewport) (ScrnInfoPtr pScrn);
    void (*Sync) (ScrnInfoPtr);
    void (*FillRect) (ScrnInfoPtr pScrn,
                      int x, int y, int w, int h, unsigned long color);
    void (*BlitRect) (ScrnInfoPtr pScrn,
                      int srcx, int srcy, int w, int h, int dstx, int dsty);
    void (*BlitTransRect) (ScrnInfoPtr pScrn,
                           int srcx, int srcy,
                           int w, int h,
                           int dstx, int dsty, unsigned long color);
} DGAFunctionRec, *DGAFunctionPtr;

typedef struct _SymTabRec {
    int token;                  /* id of the token */
    const char *name;           /* token name */
} SymTabRec, *SymTabPtr;

/* flags for xf86LookupMode */
typedef enum {
    LOOKUP_DEFAULT = 0,         /* Use default mode lookup method */
    LOOKUP_BEST_REFRESH,        /* Pick modes with best refresh */
    LOOKUP_CLOSEST_CLOCK,       /* Pick modes with the closest clock */
    LOOKUP_LIST_ORDER,          /* Pick first useful mode in list */
    LOOKUP_CLKDIV2 = 0x0100,    /* Allow half clocks */
    LOOKUP_OPTIONAL_TOLERANCES = 0x0200 /* Allow missing hsync/vrefresh */
} LookupModeFlags;

#define NoDepth24Support	0x00
#define Support24bppFb		0x01    /* 24bpp framebuffer supported */
#define Support32bppFb		0x02    /* 32bpp framebuffer supported */
#define SupportConvert24to32	0x04    /* Can convert 24bpp pixmap to 32bpp */
#define SupportConvert32to24	0x08    /* Can convert 32bpp pixmap to 24bpp */
#define PreferConvert24to32	0x10    /* prefer 24bpp pixmap to 32bpp conv */
#define PreferConvert32to24	0x20    /* prefer 32bpp pixmap to 24bpp conv */

/* For DPMS */
typedef void (*DPMSSetProcPtr) (ScrnInfoPtr, int, int);

/* Input handler proc */
typedef void (*InputHandlerProc) (int fd, void *data);

/* These are used by xf86GetClocks */
#define CLK_REG_SAVE		-1
#define CLK_REG_RESTORE		-2

/*
 * misc constants
 */
#define INTERLACE_REFRESH_WEIGHT	1.5
#define SYNC_TOLERANCE		0.01    /* 1 percent */
#define CLOCK_TOLERANCE		2000    /* Clock matching tolerance (2MHz) */

#define OVERLAY_8_32_DUALFB	0x00000001
#define OVERLAY_8_24_DUALFB	0x00000002
#define OVERLAY_8_16_DUALFB	0x00000004
#define OVERLAY_8_32_PLANAR	0x00000008

/* Values of xf86Info.mouseFlags */
#define MF_CLEAR_DTR       1
#define MF_CLEAR_RTS       2

/* Action Events */
typedef enum {
    ACTION_TERMINATE = 0,       /* Terminate Server */
    ACTION_NEXT_MODE = 10,      /* Switch to next video mode */
    ACTION_PREV_MODE,
    ACTION_SWITCHSCREEN = 100,  /* VT switch */
    ACTION_SWITCHSCREEN_NEXT,
    ACTION_SWITCHSCREEN_PREV,
} ActionEvent;

#endif                          /* _XF86STR_H */
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d44 1
a87 42
/* These are possible return values for xf86CheckMode() and ValidMode() */
typedef enum {
    MODE_OK = 0,                /* Mode OK */
    MODE_HSYNC,                 /* hsync out of range */
    MODE_VSYNC,                 /* vsync out of range */
    MODE_H_ILLEGAL,             /* mode has illegal horizontal timings */
    MODE_V_ILLEGAL,             /* mode has illegal horizontal timings */
    MODE_BAD_WIDTH,             /* requires an unsupported linepitch */
    MODE_NOMODE,                /* no mode with a maching name */
    MODE_NO_INTERLACE,          /* interlaced mode not supported */
    MODE_NO_DBLESCAN,           /* doublescan mode not supported */
    MODE_NO_VSCAN,              /* multiscan mode not supported */
    MODE_MEM,                   /* insufficient video memory */
    MODE_VIRTUAL_X,             /* mode width too large for specified virtual size */
    MODE_VIRTUAL_Y,             /* mode height too large for specified virtual size */
    MODE_MEM_VIRT,              /* insufficient video memory given virtual size */
    MODE_NOCLOCK,               /* no fixed clock available */
    MODE_CLOCK_HIGH,            /* clock required is too high */
    MODE_CLOCK_LOW,             /* clock required is too low */
    MODE_CLOCK_RANGE,           /* clock/mode isn't in a ClockRange */
    MODE_BAD_HVALUE,            /* horizontal timing was out of range */
    MODE_BAD_VVALUE,            /* vertical timing was out of range */
    MODE_BAD_VSCAN,             /* VScan value out of range */
    MODE_HSYNC_NARROW,          /* horizontal sync too narrow */
    MODE_HSYNC_WIDE,            /* horizontal sync too wide */
    MODE_HBLANK_NARROW,         /* horizontal blanking too narrow */
    MODE_HBLANK_WIDE,           /* horizontal blanking too wide */
    MODE_VSYNC_NARROW,          /* vertical sync too narrow */
    MODE_VSYNC_WIDE,            /* vertical sync too wide */
    MODE_VBLANK_NARROW,         /* vertical blanking too narrow */
    MODE_VBLANK_WIDE,           /* vertical blanking too wide */
    MODE_PANEL,                 /* exceeds panel dimensions */
    MODE_INTERLACE_WIDTH,       /* width too large for interlaced mode */
    MODE_ONE_WIDTH,             /* only one width is supported */
    MODE_ONE_HEIGHT,            /* only one height is supported */
    MODE_ONE_SIZE,              /* only one resolution is supported */
    MODE_NO_REDUCED,            /* monitor doesn't accept reduced blanking */
    MODE_BANDWIDTH,             /* mode requires too much memory bandwidth */
    MODE_BAD = -2,              /* unspecified reason */
    MODE_ERROR = -1             /* error condition */
} ModeStatus;

a102 48
/* Video mode */
typedef struct _DisplayModeRec {
    struct _DisplayModeRec *prev;
    struct _DisplayModeRec *next;
    const char *name;           /* identifier for the mode */
    ModeStatus status;
    int type;

    /* These are the values that the user sees/provides */
    int Clock;                  /* pixel clock freq (kHz) */
    int HDisplay;               /* horizontal timing */
    int HSyncStart;
    int HSyncEnd;
    int HTotal;
    int HSkew;
    int VDisplay;               /* vertical timing */
    int VSyncStart;
    int VSyncEnd;
    int VTotal;
    int VScan;
    int Flags;

    /* These are the values the hardware uses */
    int ClockIndex;
    int SynthClock;             /* Actual clock freq to
                                 * be programmed  (kHz) */
    int CrtcHDisplay;
    int CrtcHBlankStart;
    int CrtcHSyncStart;
    int CrtcHSyncEnd;
    int CrtcHBlankEnd;
    int CrtcHTotal;
    int CrtcHSkew;
    int CrtcVDisplay;
    int CrtcVBlankStart;
    int CrtcVSyncStart;
    int CrtcVSyncEnd;
    int CrtcVBlankEnd;
    int CrtcVTotal;
    Bool CrtcHAdjusted;
    Bool CrtcVAdjusted;
    int PrivSize;
    INT32 *Private;
    int PrivFlags;

    float HSync, VRefresh;
} DisplayModeRec, *DisplayModePtr;

a290 1
#define MAXCLOCKS   128
d353 1
d367 3
d429 3
d687 3
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a405 1
    int textClockFreq;
d571 1
a571 1
     * value (e.g., the full 24-bit class for the VGA device is 0x030000 (or 
a754 1
    int textClockFreq;          /* clock of text mode */
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d148 1
a148 1
    char *name;                 /* identifier for the mode */
d215 3
a217 3
    char *id;
    char *vendor;
    char *model;
d227 2
a228 2
    pointer options;
    pointer DDC;
d259 2
a260 1
    GET_REQUIRED_HW_INTERFACES = 10
d263 1
a263 1
typedef Bool xorgDriverFuncProc(ScrnInfoPtr, xorgDriverFuncOp, pointer);
d303 1
a303 1
    char *driverName;
d307 1
a307 1
    pointer module;
d319 1
a319 1
    char *driverName;
d323 1
a323 1
    pointer module;
d390 6
a395 6
    char *identifier;
    char *vendor;
    char *board;
    char *chipset;
    char *ramdac;
    char *driver;
d401 2
a402 2
    char *clockchip;
    char *busID;
d412 1
a412 1
    pointer options;
d428 2
a429 2
    char **modes;
    pointer options;
d433 2
a434 2
    char *identifier;
    pointer options;
d438 1
a438 1
    char *identifier;
d441 1
a441 1
    pointer options;
d445 1
a445 1
    char *id;
d456 1
a456 1
    pointer options;
d471 1
a471 1
    char *topname;
d473 1
a473 1
    char *bottomname;
d475 1
a475 1
    char *leftname;
d477 1
a477 1
    char *rightname;
d482 1
a482 1
    char *refname;
d489 1
a489 1
    char *id;
d493 1
a493 1
    pointer options;
d516 1
a516 1
typedef pointer (*funcPointer) (void);
d585 1
a585 1
typedef void (*EntityProc) (int entityIndex, pointer private);
d675 1
a675 1
    char *driverName;           /* canonical name used in */
d734 2
a735 2
    char *name;                 /* Name to prefix messages */
    pointer driverPrivate;      /* Driver private area */
d739 1
a739 1
    pointer module;             /* Pointer to module head */
d745 3
a747 3
    char *chipset;              /* chipset name */
    char *ramdac;               /* ramdac name */
    char *clockchip;            /* clock name */
d758 1
a758 1
    pointer options;
d783 1
a783 1
    pointer reservedPtr[NUM_RESERVED_POINTERS];
d868 1
a868 1
typedef void (*InputHandlerProc) (int fd, pointer data);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d314 1
d329 2
d334 5
d350 1
a350 1
#if defined(linux) && defined(_INPUT_H)
d354 1
d362 1
d375 1
d644 12
a655 12
typedef Bool xf86ScreenInitProc(int, ScreenPtr, int, char **);
typedef Bool xf86SwitchModeProc(int, DisplayModePtr, int);
typedef void xf86AdjustFrameProc(int, int, int, int);
typedef Bool xf86EnterVTProc(int, int);
typedef void xf86LeaveVTProc(int, int);
typedef void xf86FreeScreenProc(int, int);
typedef ModeStatus xf86ValidModeProc(int, DisplayModePtr, Bool, int);
typedef void xf86EnableDisableFBAccessProc(int, Bool);
typedef int xf86SetDGAModeProc(int, int, DGADevicePtr);
typedef int xf86ChangeGammaProc(int, Gamma);
typedef void xf86PointerMovedProc(int, int, int);
typedef Bool xf86PMEventProc(int, pmEvent, Bool);
d816 2
@


1.6
log
@Update to xserver 1.11.2
@
text
@a43 3
#include "xf86Pci.h"

#include <pciaccess.h>
a57 1

d61 14
a74 14
    V_PHSYNC	= 0x0001,
    V_NHSYNC	= 0x0002,
    V_PVSYNC	= 0x0004,
    V_NVSYNC	= 0x0008,
    V_INTERLACE	= 0x0010,
    V_DBLSCAN	= 0x0020,
    V_CSYNC	= 0x0040,
    V_PCSYNC	= 0x0080,
    V_NCSYNC	= 0x0100,
    V_HSKEW	= 0x0200,	/* hskew provided */
    V_BCAST	= 0x0400,
    V_PIXMUX	= 0x1000,
    V_DBLCLK	= 0x2000,
    V_CLKDIV2	= 0x4000
d78 1
a78 1
    INTERLACE_HALVE_V	= 0x0001	/* Halve V values for interlacing */
d84 1
a84 1
    MODECHECK_FINAL   = 1
d89 38
a126 38
    MODE_OK	= 0,	/* Mode OK */
    MODE_HSYNC,		/* hsync out of range */
    MODE_VSYNC,		/* vsync out of range */
    MODE_H_ILLEGAL,	/* mode has illegal horizontal timings */
    MODE_V_ILLEGAL,	/* mode has illegal horizontal timings */
    MODE_BAD_WIDTH,	/* requires an unsupported linepitch */
    MODE_NOMODE,	/* no mode with a maching name */
    MODE_NO_INTERLACE,	/* interlaced mode not supported */
    MODE_NO_DBLESCAN,	/* doublescan mode not supported */
    MODE_NO_VSCAN,	/* multiscan mode not supported */
    MODE_MEM,		/* insufficient video memory */
    MODE_VIRTUAL_X,	/* mode width too large for specified virtual size */
    MODE_VIRTUAL_Y,	/* mode height too large for specified virtual size */
    MODE_MEM_VIRT,	/* insufficient video memory given virtual size */
    MODE_NOCLOCK,	/* no fixed clock available */
    MODE_CLOCK_HIGH,	/* clock required is too high */
    MODE_CLOCK_LOW,	/* clock required is too low */
    MODE_CLOCK_RANGE,	/* clock/mode isn't in a ClockRange */
    MODE_BAD_HVALUE,	/* horizontal timing was out of range */
    MODE_BAD_VVALUE,	/* vertical timing was out of range */
    MODE_BAD_VSCAN,	/* VScan value out of range */
    MODE_HSYNC_NARROW,	/* horizontal sync too narrow */
    MODE_HSYNC_WIDE,	/* horizontal sync too wide */
    MODE_HBLANK_NARROW,	/* horizontal blanking too narrow */
    MODE_HBLANK_WIDE,	/* horizontal blanking too wide */
    MODE_VSYNC_NARROW,	/* vertical sync too narrow */
    MODE_VSYNC_WIDE,	/* vertical sync too wide */
    MODE_VBLANK_NARROW,	/* vertical blanking too narrow */
    MODE_VBLANK_WIDE,	/* vertical blanking too wide */
    MODE_PANEL,         /* exceeds panel dimensions */
    MODE_INTERLACE_WIDTH, /* width too large for interlaced mode */
    MODE_ONE_WIDTH,     /* only one width is supported */
    MODE_ONE_HEIGHT,    /* only one height is supported */
    MODE_ONE_SIZE,      /* only one resolution is supported */
    MODE_NO_REDUCED,    /* monitor doesn't accept reduced blanking */
    MODE_BANDWIDTH,	/* mode requires too much memory bandwidth */
    MODE_BAD = -2,	/* unspecified reason */
    MODE_ERROR	= -1	/* error condition */
d133 4
a136 4
# define M_T_BUILTIN 0x01        /* built-in mode */
# define M_T_CLOCK_C (0x02 | M_T_BUILTIN) /* built-in mode - configure clock */
# define M_T_CRTC_C  (0x04 | M_T_BUILTIN) /* built-in mode - configure CRTC  */
# define M_T_CLOCK_CRTC_C  (M_T_CLOCK_C | M_T_CRTC_C)
d138 5
a142 5
# define M_T_PREFERRED 0x08	/* preferred mode within a set */
# define M_T_DEFAULT 0x10	/* (VESA) default modes */
# define M_T_USERDEF 0x20	/* One of the modes from the config file */
# define M_T_DRIVER  0x40	/* Supplied by the driver (EDID, etc) */
# define M_T_USERPREF 0x80	/* mode preferred by the user config */
d146 5
a150 5
    struct _DisplayModeRec *	prev;
    struct _DisplayModeRec *	next;
    char *			name;		/* identifier for the mode */
    ModeStatus			status;
    int				type;
d153 35
a187 35
    int				Clock;		/* pixel clock freq (kHz) */
    int				HDisplay;	/* horizontal timing */
    int				HSyncStart;
    int				HSyncEnd;
    int				HTotal;
    int				HSkew;
    int				VDisplay;	/* vertical timing */
    int				VSyncStart;
    int				VSyncEnd;
    int				VTotal;
    int				VScan;
    int				Flags;

  /* These are the values the hardware uses */
    int				ClockIndex;
    int				SynthClock;	/* Actual clock freq to
					  	 * be programmed  (kHz) */
    int				CrtcHDisplay;
    int				CrtcHBlankStart;
    int				CrtcHSyncStart;
    int				CrtcHSyncEnd;
    int				CrtcHBlankEnd;
    int				CrtcHTotal;
    int				CrtcHSkew;
    int				CrtcVDisplay;
    int				CrtcVBlankStart;
    int				CrtcVSyncStart;
    int				CrtcVSyncEnd;
    int				CrtcVBlankEnd;
    int				CrtcVTotal;
    Bool			CrtcHAdjusted;
    Bool			CrtcVAdjusted;
    int				PrivSize;
    INT32 *			Private;
    int				PrivFlags;
d189 1
a189 1
    float			HSync, VRefresh;
d197 3
a199 1
typedef struct { float hi, lo; } range;
d201 3
a203 1
typedef struct { CARD32 red, green, blue; } rgb;
d205 3
a207 1
typedef struct { float red, green, blue; } Gamma;
d215 16
a230 16
    char *		id;
    char *		vendor;
    char *		model;
    int			nHsync;
    range		hsync[MAX_HSYNC];
    int			nVrefresh;
    range		vrefresh[MAX_VREFRESH];
    DisplayModePtr	Modes;		/* Start of the monitor's mode list */
    DisplayModePtr	Last;		/* End of the monitor's mode list */
    Gamma		gamma;		/* Gamma of the monitor */
    int			widthmm;
    int			heightmm;
    pointer		options;
    pointer		DDC;
    Bool                reducedblanking; /* Allow CVT reduced blanking modes? */
    int			maxPixClock;	 /* in kHz, like mode->Clock */
d236 8
a243 8
    int			minClock;	/* (kHz) */
    int			maxClock;	/* (kHz) */
    int			clockIndex;	/* -1 for programmable clocks */
    Bool		interlaceAllowed;
    Bool		doubleScanAllowed;
    int			ClockMulFactor;
    int			ClockDivFactor;
    int			PrivFlags;
d262 1
a262 2
typedef Bool xorgDriverFuncProc		  (ScrnInfoPtr, xorgDriverFuncOp,
					   pointer);
d301 7
a307 7
    int			driverVersion;
    char *		driverName;
    void		(*Identify)(int flags);
    Bool		(*Probe)(struct _DriverRec *drv, int flags);
    const OptionInfoRec * (*AvailableOptions)(int chipid, int bustype);
    pointer		module;
    int			refCount;
d313 2
d316 12
a327 12
    int			driverVersion;
    char *		driverName;
    void		(*Identify)(int flags);
    Bool		(*Probe)(struct _DriverRec *drv, int flags);
    const OptionInfoRec * (*AvailableOptions)(int chipid, int bustype);
    pointer		module;
    int			refCount;
    xorgDriverFuncProc  *driverFunc;

    const struct pci_id_match * supported_devices;
    Bool (*PciProbe)( struct _DriverRec * drv, int entity_num,
        struct pci_device * dev, intptr_t match_data );
d353 1
a353 1
    BUS_last    /* Keep last */
a355 2
struct pci_device;

d357 1
a357 1
    int		fbNum;
d363 2
a364 2
	struct pci_device *pci;
	SbusBusId sbus;
d378 25
a402 25
   char *			identifier;
   char *			vendor;
   char *			board;
   char *			chipset;
   char *			ramdac;
   char *			driver;
   struct _confscreenrec *	myScreenSection;
   Bool				claimed;
   int				dacSpeeds[MAXDACSPEEDS];
   int				numclocks;
   int				clock[MAXCLOCKS];
   char *			clockchip;
   char *			busID;
   Bool				active;
   Bool				inUse;
   int				videoRam;
   int				textClockFreq;
   unsigned long		BiosBase;	/* Base address of video BIOS */
   unsigned long		MemBase;	/* Frame buffer base address */
   unsigned long		IOBase;
   int				chipID;
   int				chipRev;
   pointer			options;
   int                          irq;
   int                          screen;         /* For multi-CRTC cards */
d406 12
a417 12
    int			frameX0;
    int			frameY0;
    int			virtualX;
    int			virtualY;
    int			depth;
    int			fbbpp;
    rgb			weight;
    rgb			blackColour;
    rgb			whiteColour;
    int			defaultVisual;
    char **		modes;
    pointer		options;
d421 2
a422 2
    char *		identifier;
    pointer		options;
d426 4
a429 4
    char *		identifier;
    int			numports;
    confXvPortPtr	ports;
    pointer		options;
d433 12
a444 12
    char *		id;
    int			screennum;
    int			defaultdepth;
    int			defaultbpp;
    int			defaultfbbpp;
    MonPtr		monitor;
    GDevPtr		device;
    int			numdisplays;
    DispPtr		displays;
    int			numxvadaptors;
    confXvAdaptorPtr	xvadaptors;
    pointer		options;
d458 14
a471 14
    confScreenPtr	screen;
    char *		topname;
    confScreenPtr	top;
    char *		bottomname;
    confScreenPtr	bottom;
    char *		leftname;
    confScreenPtr	left;
    char *		rightname;
    confScreenPtr	right;
    PositionType	where;
    int			x;
    int			y;
    char *		refname;
    confScreenPtr	refscreen;
d477 5
a481 5
    char *		id;
    screenLayoutPtr	screens;
    GDevPtr		inactives;
    InputInfoRec**      inputs; /* NULL terminated */
    pointer		options;
d485 2
a486 2
    int                 count;
    int                 size;
d488 2
a489 2
	XF86DRI_WC_HINT = 0x0001 /* Placeholder: not implemented */
    }                   flags;
d493 4
a496 4
    int                 group;
    int                 mode;
    int                 bufs_count;
    confDRIBufferRec    *bufs;
d504 1
a504 1
typedef pointer (*funcPointer)(void);
a571 1

d573 1
a573 1
typedef void (*EntityProc)(int entityIndex,pointer private);
d587 26
a612 26
   int num;		/* A unique identifier for the mode (num > 0) */
   DisplayModePtr mode;
   int flags;		/* DGA_CONCURRENT_ACCESS, etc... */
   int imageWidth;	/* linear accessible portion (pixels) */
   int imageHeight;
   int pixmapWidth;	/* Xlib accessible portion (pixels) */
   int pixmapHeight;	/* both fields ignored if no concurrent access */
   int bytesPerScanline;
   int byteOrder;	/* MSBFirst, LSBFirst */
   int depth;
   int bitsPerPixel;
   unsigned long red_mask;
   unsigned long green_mask;
   unsigned long blue_mask;
   short visualClass;
   int viewportWidth;
   int viewportHeight;
   int xViewportStep;	/* viewport position granularity */
   int yViewportStep;
   int maxViewportX;	/* max viewport origin */
   int maxViewportY;
   int viewportFlags;	/* types of page flipping possible */
   int offset;		/* offset into physical memory */
   unsigned char *address;	/* server's mapped framebuffer */
   int reserved1;
   int reserved2;
d616 2
a617 2
   DGAModePtr mode;
   PixmapPtr pPix;
d631 9
a639 9
typedef Bool xf86ProbeProc                (DriverPtr, int);
typedef Bool xf86PreInitProc              (ScrnInfoPtr, int);
typedef Bool xf86ScreenInitProc           (int, ScreenPtr, int, char**);
typedef Bool xf86SwitchModeProc           (int, DisplayModePtr, int);
typedef void xf86AdjustFrameProc          (int, int, int, int);
typedef Bool xf86EnterVTProc              (int, int);
typedef void xf86LeaveVTProc              (int, int);
typedef void xf86FreeScreenProc           (int, int);
typedef ModeStatus xf86ValidModeProc      (int, DisplayModePtr, Bool, int);
d641 8
a648 9
typedef int  xf86SetDGAModeProc           (int, int, DGADevicePtr);
typedef int  xf86ChangeGammaProc          (int, Gamma);
typedef void xf86PointerMovedProc         (int, int, int);
typedef Bool xf86PMEventProc              (int, pmEvent, Bool);
typedef void xf86DPMSSetProc		  (ScrnInfoPtr, int, int);
typedef void xf86LoadPaletteProc   (ScrnInfoPtr, int, int *, LOCO *, VisualPtr);
typedef void xf86SetOverscanProc          (ScrnInfoPtr, int);
typedef void xf86ModeSetProc              (ScrnInfoPtr);

a660 1

d662 10
a671 10
    int			driverVersion;
    char *		driverName;		/* canonical name used in */
						/* the config file */
    ScreenPtr		pScreen;		/* Pointer to the ScreenRec */
    int			scrnIndex;		/* Number of this screen */
    Bool		configured;		/* Is this screen valid */
    int			origIndex;		/* initial number assigned to
						 * this screen before
						 * finalising the number of
						 * available screens */
d674 56
a729 56
    int			imageByteOrder;
    int			bitmapScanlineUnit;
    int			bitmapScanlinePad;
    int			bitmapBitOrder;
    int			numFormats;
    PixmapFormatRec	formats[MAXFORMATS];
    PixmapFormatRec	fbFormat;

    int			bitsPerPixel;		/* fb bpp */
    Pix24Flags		pixmap24;		/* pixmap pref for depth 24 */
    int			depth;			/* depth of default visual */
    MessageType		depthFrom;		/* set from config? */
    MessageType		bitsPerPixelFrom;	/* set from config? */
    rgb			weight;			/* r/g/b weights */
    rgb			mask;			/* rgb masks */
    rgb			offset;			/* rgb offsets */
    int			rgbBits;		/* Number of bits in r/g/b */
    Gamma		gamma;			/* Gamma of the monitor */
    int			defaultVisual;		/* default visual class */
    int			maxHValue;		/* max horizontal timing */
    int			maxVValue;		/* max vertical timing value */
    int			virtualX;		/* Virtual width */
    int			virtualY; 		/* Virtual height */
    int			xInc;			/* Horizontal timing increment */
    MessageType		virtualFrom;		/* set from config? */
    int			displayWidth;		/* memory pitch */
    int			frameX0;		/* viewport position */
    int			frameY0;
    int			frameX1;
    int			frameY1;
    int			zoomLocked;		/* Disallow mode changes */
    DisplayModePtr	modePool;		/* list of compatible modes */
    DisplayModePtr	modes;			/* list of actual modes */
    DisplayModePtr	currentMode;		/* current mode
						 * This was previously
						 * overloaded with the modes
						 * field, which is a pointer
						 * into a circular list */
    confScreenPtr	confScreen;		/* Screen config info */
    MonPtr		monitor;		/* Monitor information */
    DispPtr		display;		/* Display information */
    int *		entityList;		/* List of device entities */
    int			numEntities;
    int			widthmm;		/* physical display dimensions
						 * in mm */
    int			heightmm;
    int			xDpi;			/* width DPI */
    int			yDpi;			/* height DPI */
    char *		name;			/* Name to prefix messages */
    pointer		driverPrivate;		/* Driver private area */
    DevUnion *		privates;		/* Other privates can hook in
						 * here */
    DriverPtr		drv;			/* xf86DriverList[] entry */
    pointer		module;			/* Pointer to module head */
    int			colorKey;
    int			overlayFlags;
d733 14
a746 15
    char *		chipset;		/* chipset name */
    char *		ramdac;			/* ramdac name */
    char *		clockchip;		/* clock name */
    Bool		progClock;		/* clock is programmable */
    int			numClocks;		/* number of clocks */
    int			clock[MAXCLOCKS];	/* list of clock frequencies */
    int			videoRam;		/* amount of video ram (kb) */
    unsigned long	biosBase;		/* Base address of video BIOS */
    unsigned long	memPhysBase;		/* Physical address of FB */
    unsigned long 	fbOffset;		/* Offset of FB in the above */
    IOADDRESS    	domainIOBase;		/* Domain I/O base address */
    int			memClk;			/* memory clock */
    int			textClockFreq;		/* clock of text mode */
    Bool		flipPixels;		/* swap default black/white */
    pointer		options;
d748 2
a749 2
    int			chipID;
    int			chipRev;
d752 1
a752 1
    Bool		vtSema;
d755 1
a755 1
    Bool		silkenMouse;
d758 2
a759 2
    ClockRangePtr	clockRanges;
    int			adjustFlags;
d766 1
a766 1
    int			reservedInt[NUM_RESERVED_INTS];
d768 2
a769 2
    int *		entityInstanceList;
    struct pci_device   *vgaDev;
d771 1
a771 1
    pointer		reservedPtr[NUM_RESERVED_POINTERS];
d778 19
a796 19
    xf86ProbeProc			*Probe;
    xf86PreInitProc			*PreInit;
    xf86ScreenInitProc			*ScreenInit;
    xf86SwitchModeProc			*SwitchMode;
    xf86AdjustFrameProc			*AdjustFrame;
    xf86EnterVTProc			*EnterVT;
    xf86LeaveVTProc			*LeaveVT;
    xf86FreeScreenProc			*FreeScreen;
    xf86ValidModeProc			*ValidMode;
    xf86EnableDisableFBAccessProc	*EnableDisableFBAccess;
    xf86SetDGAModeProc			*SetDGAMode;
    xf86ChangeGammaProc			*ChangeGamma;
    xf86PointerMovedProc		*PointerMoved;
    xf86PMEventProc			*PMEvent;
    xf86DPMSSetProc			*DPMSSet;
    xf86LoadPaletteProc			*LoadPalette;
    xf86SetOverscanProc			*SetOverscan;
    xorgDriverFuncProc			*DriverFunc;
    xf86ModeSetProc			*ModeSet;
d803 1
a803 1
    funcPointer		reservedFuncs[NUM_RESERVED_FUNCS];
a806 1

d808 17
a824 31
   Bool (*OpenFramebuffer)(
	ScrnInfoPtr pScrn,
	char **name,
	unsigned char **mem,
	int *size,
	int *offset,
        int *extra
   );
   void	(*CloseFramebuffer)(ScrnInfoPtr pScrn);
   Bool (*SetMode)(ScrnInfoPtr pScrn, DGAModePtr pMode);
   void (*SetViewport)(ScrnInfoPtr pScrn, int x, int y, int flags);
   int  (*GetViewport)(ScrnInfoPtr pScrn);
   void (*Sync)(ScrnInfoPtr);
   void (*FillRect)(
	ScrnInfoPtr pScrn,
	int x, int y, int w, int h,
	unsigned long color
   );
   void (*BlitRect)(
	ScrnInfoPtr pScrn,
	int srcx, int srcy,
	int w, int h,
	int dstx, int dsty
   );
   void (*BlitTransRect)(
	ScrnInfoPtr pScrn,
	int srcx, int srcy,
	int w, int h,
	int dstx, int dsty,
	unsigned long color
   );
d828 2
a829 2
    int			token;		/* id of the token */
    const char *	name;		/* token name */
d834 6
a839 6
    LOOKUP_DEFAULT		= 0,	/* Use default mode lookup method */
    LOOKUP_BEST_REFRESH,		/* Pick modes with best refresh */
    LOOKUP_CLOSEST_CLOCK,		/* Pick modes with the closest clock */
    LOOKUP_LIST_ORDER,			/* Pick first useful mode in list */
    LOOKUP_CLKDIV2		= 0x0100, /* Allow half clocks */
    LOOKUP_OPTIONAL_TOLERANCES	= 0x0200  /* Allow missing hsync/vrefresh */
d843 6
a848 7
#define Support24bppFb		0x01	/* 24bpp framebuffer supported */
#define Support32bppFb		0x02	/* 32bpp framebuffer supported */
#define SupportConvert24to32	0x04	/* Can convert 24bpp pixmap to 32bpp */
#define SupportConvert32to24	0x08	/* Can convert 32bpp pixmap to 24bpp */
#define PreferConvert24to32	0x10	/* prefer 24bpp pixmap to 32bpp conv */
#define PreferConvert32to24	0x20	/* prefer 32bpp pixmap to 24bpp conv */

d851 1
a851 1
typedef void (*DPMSSetProcPtr)(ScrnInfoPtr, int, int);
d854 1
a854 1
typedef void (*InputHandlerProc)(int fd, pointer data);
d864 2
a865 3
#define SYNC_TOLERANCE		0.01	/* 1 percent */
#define CLOCK_TOLERANCE		2000	/* Clock matching tolerance (2MHz) */

d878 2
a879 2
    ACTION_TERMINATE		= 0,	/* Terminate Server */
    ACTION_NEXT_MODE		= 10,	/* Switch to next video mode */
d881 1
a881 1
    ACTION_SWITCHSCREEN		= 100,	/* VT switch */
d886 1
a886 1
#endif /* _XF86STR_H */
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a404 8
   char *			identifier;
   char *			driver;
   pointer		 	commonOptions;
   pointer			extraOptions;
   InputAttributes              *attrs;
} IDevRec, *IDevPtr;

typedef struct {
d473 2
d479 1
a479 1
    IDevPtr*            inputs; /* NULL terminated */
d501 1
a501 1
#define NUM_RESERVED_FUNCS		11
a583 7
/* server states */

typedef enum {
    SETUP,
    OPERATING
} xf86State;

d648 1
a755 1
    DevUnion		pixmapPrivate;		/* saved devPrivate from pixmap */
d799 1
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a340 1
#undef BUS_ISA
a347 1
    BUS_ISA,
d409 1
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a243 14
/* Need to store the strategy with clockRange for VidMode extension */
typedef struct x_ClockRanges {
    struct x_ClockRanges *next;
    int			minClock;
    int			maxClock;
    int			clockIndex;	/* -1 for programmable clocks */
    Bool		interlaceAllowed;
    Bool		doubleScanAllowed;
    int			ClockMulFactor;
    int			ClockDivFactor;
    int			PrivFlags;
    int			strategy;
} ClockRanges, *ClockRangesPtr;

d288 1
a331 15

/*
 * The optional module list struct. This allows modules exporting helping
 * functions to configuration tools, the Xserver, or any other
 * application/module interested in such information.
 */
_X_DEPRECATED typedef struct _ModuleInfoRec {
    int			moduleVersion;
    char *		moduleName;
    pointer		module;
    int			refCount;
    const OptionInfoRec * (*AvailableOptions)(void *unused);
    pointer		unused[8];	/* leave some space for more fields */
} ModuleInfoRec, *ModuleInfoPtr;

d507 1
a507 1
#define NUM_RESERVED_POINTERS		15
a545 139
/*
 * The IO access enabler struct. This contains the address for
 * the IOEnable/IODisable funcs for their specific bus along
 * with a pointer to data needed by them
 */
typedef struct _AccessRec {
    void (*AccessDisable)(void *arg);
    void (*AccessEnable)(void *arg);
    void *arg;
} xf86AccessRec, *xf86AccessPtr;

typedef struct {
    xf86AccessPtr mem;
    xf86AccessPtr io;
    xf86AccessPtr io_mem;
} xf86SetAccessFuncRec, *xf86SetAccessFuncPtr;

/*  bus-access-related types */
typedef enum {
    NONE,
    IO,
    MEM_IO,
    MEM
} resType;

typedef struct _EntityAccessRec {
    xf86AccessPtr fallback;
    xf86AccessPtr pAccess;
    resType rt;
    pointer  busAcc;
    struct _EntityAccessRec *next;
} EntityAccessRec, *EntityAccessPtr;

typedef struct _CurrAccRec {
    EntityAccessPtr pMemAccess;
    EntityAccessPtr pIoAccess;
} xf86CurrentAccessRec, *xf86CurrentAccessPtr;

/* new RAC */

/* Resource Type values */
#define ResNone		((unsigned long)(-1))

#define ResMem		0x0001
#define ResIo		0x0002
#define ResPhysMask	0x000F

#define ResExclusive	0x0010
#define ResShared	0x0020
#define ResAny		0x0040
#define ResAccMask	0x0070
#define ResUnused	0x0080

#define ResUnusedOpr	0x0100
#define ResDisableOpr	0x0200
#define ResOprMask	0x0300

#define ResBlock	0x0400
#define ResSparse	0x0800
#define ResExtMask	0x0C00

#define ResEstimated	0x001000
#define ResInit 	0x002000
#define ResBios		0x004000
#define ResMiscMask	0x00F000

#define ResBus		0x010000

#if defined(__alpha__) && defined(linux)
# define ResDomain	0x1ff000000ul
#else
# define ResDomain	0xff000000ul
#endif
#define ResTypeMask	(ResPhysMask | ResDomain)	/* For conflict check */

#define ResEnd		ResNone

#define ResExcMemBlock		(ResMem | ResExclusive | ResBlock)
#define ResExcIoBlock		(ResIo | ResExclusive | ResBlock)
#define ResShrMemBlock		(ResMem | ResShared | ResBlock)
#define ResShrIoBlock		(ResIo | ResShared | ResBlock)
#define ResExcUusdMemBlock	(ResMem | ResExclusive | ResUnused | ResBlock)
#define ResExcUusdIoBlock	(ResIo | ResExclusive | ResUnused | ResBlock)
#define ResShrUusdMemBlock	(ResMem | ResShared | ResUnused | ResBlock)
#define ResShrUusdIoBlock	(ResIo | ResShared | ResUnused | ResBlock)
#define ResExcUusdMemSparse	(ResMem | ResExclusive | ResUnused | ResSparse)
#define ResExcUusdIoSparse	(ResIo | ResExclusive | ResUnused | ResSparse)
#define ResShrUusdMemSparse	(ResMem | ResShared | ResUnused | ResSparse)
#define ResShrUusdIoSparse	(ResIo | ResShared | ResUnused | ResSparse)

#define ResExcMemSparse		(ResMem | ResExclusive | ResSparse)
#define ResExcIoSparse		(ResIo | ResExclusive | ResSparse)
#define ResShrMemSparse		(ResMem | ResShared | ResSparse)
#define ResShrIoSparse		(ResIo | ResShared | ResSparse)
#define ResUusdMemSparse	(ResMem | ResUnused | ResSparse)
#define ResUusdIoSparse		(ResIo | ResUnused | ResSparse)

#define ResIsMem(r)		(((r)->type & ResPhysMask) == ResMem)
#define ResIsIo(r)		(((r)->type & ResPhysMask) == ResIo)
#define ResIsExclusive(r)	(((r)->type & ResAccMask) == ResExclusive)
#define ResIsShared(r)		(((r)->type & ResAccMask) == ResShared)
#define ResIsUnused(r)		(((r)->type & ResAccMask) == ResUnused)
#define ResIsBlock(r)		(((r)->type & ResExtMask) == ResBlock)
#define ResIsSparse(r)		(((r)->type & ResExtMask) == ResSparse)
#define ResIsEstimated(r)	(((r)->type & ResMiscMask) == ResEstimated)

typedef struct {
    unsigned long type;     /* shared, exclusive, unused etc. */
    memType a;
    memType b;
} resRange, *resList;

#define RANGE_TYPE(type, domain) \
               (((unsigned long)(domain) << 24) | ((type) & ~ResBus))
#define RANGE(r,u,v,t) {\
                       (r).a = (u);\
                       (r).b = (v);\
                       (r).type = (t);\
                       }

#define rBase a
#define rMask b
#define rBegin a
#define rEnd b

/* resource record */
typedef struct _resRec *resPtr;
typedef struct _resRec {
    resRange    val;
    int		entityIndex;	/* who owns the resource */
    resPtr	next;
} resRec;

#define sparse_base	val.rBase
#define sparse_mask	val.rMask
#define block_begin	val.rBegin
#define block_end	val.rEnd
#define res_type	val.type

d571 5
a575 4
    /**
     * Resources associated with this type of device.
     */
    resRange *resList;
d578 1
a586 1
    resPtr resources;
a597 12
typedef enum {
    NOTIFY_SETUP_TRANSITION,
    NOTIFY_SETUP,
    NOTIFY_OPERATING,
    NOTIFY_OPERATING_TRANSITION,
    NOTIFY_ENABLE,
    NOTIFY_ENTER,
    NOTIFY_LEAVE
} xf86NotifyState;

typedef void (*xf86StateChangeNotificationCallbackFunc)(xf86NotifyState state,pointer);

a765 6
    int			racMemFlags;
    int			racIoFlags;
    pointer		access;
    xf86CurrentAccessPtr CurrentAccess;
    resType		resourceType;
    pointer		busAccess;
d775 1
a775 1
    ClockRangesPtr	clockRanges;
d786 2
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a385 4
    unsigned int dummy;
} IsaBusId;

typedef struct {
a391 1
	IsaBusId isa;
a433 2
typedef int (*FindIsaDevProc)(GDevPtr dev);

a618 3
#define ResIrq		0x0003
#define ResDma		0x0004
#define ResPciCfg	0x000e	/* PCI Configuration space */
a640 1
#define ResOverlap	0x020000
a678 1
#define ResCanOverlap(r)	(ResIsEstimated(r) || ((r)->type & ResOverlap))
a712 5
typedef struct {
    int numChipset;
    resRange *resList;
} IsaChipsets;

a836 1
typedef int  xf86HandleMessageProc     (int, const char*, const char*, char**);
a990 1
    xf86HandleMessageProc		*HandleMessage;
a1073 8
/* xf86Debug.c */
#ifdef BUILDDEBUG
typedef struct {
    long sec;
    long usec;
} xf86TsRec, *xf86TsPtr;
#endif

a1086 7
#if 0
#define LD_RESOLV_IFDONE		0	/* only check if no more
						   delays pending */
#define LD_RESOLV_NOW			1	/* finish one delay step */
#define LD_RESOLV_FORCE			2	/* force checking... */
#endif

a1095 2
    ACTION_DISABLEGRAB		= 20,	/* Cancel server/pointer/kbd grabs */
    ACTION_CLOSECLIENT,			/* Kill client holding grab */
a1098 1
    ACTION_MESSAGE		= 9999  /* Generic message passing */
a1099 24

/* xf86Versions.c */
/*
 * Never change existing values, and always assign values explicitly.
 * NUM_BUILTIN_IFS must always be the last entry.
 */
typedef enum {
    BUILTIN_IF_OSMOUSE = 0,
    BUILTIN_IF_OSKBD = 1,
    NUM_BUILTIN_IFS
} BuiltinInterface;

/*
 * These are intentionally the same as the module version macros.
 * It is possible to register a module as providing a specific interface,
 * in which case the module's version is used.  This feature isn't
 * really ready for use yet though.
 */

#define BUILTIN_INTERFACE_VERSION_NUMERIC(maj, min, patch) \
	((((maj) & 0xFF) << 24) | (((min) & 0xFF) << 16) | (patch & 0xFFFF))
#define GET_BUILTIN_INTERFACE_MAJOR_VERSION(vers)	(((vers) >> 24) & 0xFF)
#define GET_BUILTIN_INTERFACE_MINOR_VERSION(vers)	(((vers) >> 16) & 0xFF)
#define GET_BUILTIN_INTERFACE_PATCH_VERSION(vers)	((vers) & 0xFFFF)
@


1.1
log
@Initial revision
@
text
@d46 15
a60 5
/*
 * memType is of the size of the addressable memory (machine size)
 * usually unsigned long.
 */
typedef unsigned long memType;
d128 1
d146 1
d322 3
d334 4
d351 1
a351 1
typedef struct _ModuleInfoRec {
d383 1
a383 5
typedef struct {
    int		bus;
    int		device;
    int		func;
} PciBusId;
d397 1
a397 1
	PciBusId pci;
a448 23
    int			vendor;
    int			chipType;
    int			chipRev;
    int			subsysVendor;
    int			subsysCard;
    int			bus;
    int			device;
    int			func;
    int			class;
    int			subclass;
    int			interface;
    memType  	        memBase[6];
    memType  	        ioBase[6];
    int			size[6];
    unsigned char	type[6];
    memType   	        biosBase;
    int			biosSize;
    pointer		thisCard;
    Bool                validSize;
    Bool                validate;
} pciVideoRec, *pciVideoPtr;

typedef struct {
d521 1
a521 1
    IDevPtr		inputs;
d730 1
a730 1
typedef struct {
d1059 1
a1059 1
typedef struct {
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d529 1
a529 1
    IDevPtr*            inputs; /* NULL terminated */
@

