head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.8
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.21;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.08;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.08;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@
/*
 * Copyright (c) 2001-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include <X11/X.h>
#include <X11/Xproto.h>
#include "scrnintstr.h"
#include "resource.h"
#include "dixstruct.h"

#include "xf86xvpriv.h"
#include "xf86xvmc.h"

typedef struct {
    CloseScreenProcPtr CloseScreen;
    int num_adaptors;
    XF86MCAdaptorPtr *adaptors;
    XvMCAdaptorPtr dixinfo;
} xf86XvMCScreenRec, *xf86XvMCScreenPtr;

static DevPrivateKeyRec XF86XvMCScreenKeyRec;

#define XF86XvMCScreenKey (&XF86XvMCScreenKeyRec)

#define XF86XVMC_GET_PRIVATE(pScreen) (xf86XvMCScreenPtr) \
    dixLookupPrivate(&(pScreen)->devPrivates, XF86XvMCScreenKey)

static int
xf86XvMCCreateContext(XvPortPtr pPort,
                      XvMCContextPtr pContext, int *num_priv, CARD32 **priv)
{
    xf86XvMCScreenPtr pScreenPriv = XF86XVMC_GET_PRIVATE(pContext->pScreen);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pContext->pScreen);

    pContext->port_priv = (XvPortRecPrivatePtr) (pPort->devPriv.ptr);

    return (*pScreenPriv->adaptors[pContext->adapt_num]->CreateContext) (pScrn,
                                                                         pContext,
                                                                         num_priv,
                                                                         priv);
}

static void
xf86XvMCDestroyContext(XvMCContextPtr pContext)
{
    xf86XvMCScreenPtr pScreenPriv = XF86XVMC_GET_PRIVATE(pContext->pScreen);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pContext->pScreen);

    (*pScreenPriv->adaptors[pContext->adapt_num]->DestroyContext) (pScrn,
                                                                   pContext);
}

static int
xf86XvMCCreateSurface(XvMCSurfacePtr pSurface, int *num_priv, CARD32 **priv)
{
    XvMCContextPtr pContext = pSurface->context;
    xf86XvMCScreenPtr pScreenPriv = XF86XVMC_GET_PRIVATE(pContext->pScreen);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pContext->pScreen);

    return (*pScreenPriv->adaptors[pContext->adapt_num]->CreateSurface) (pScrn,
                                                                         pSurface,
                                                                         num_priv,
                                                                         priv);
}

static void
xf86XvMCDestroySurface(XvMCSurfacePtr pSurface)
{
    XvMCContextPtr pContext = pSurface->context;
    xf86XvMCScreenPtr pScreenPriv = XF86XVMC_GET_PRIVATE(pContext->pScreen);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pContext->pScreen);

    (*pScreenPriv->adaptors[pContext->adapt_num]->DestroySurface) (pScrn,
                                                                   pSurface);
}

static int
xf86XvMCCreateSubpicture(XvMCSubpicturePtr pSubpicture,
                         int *num_priv, CARD32 **priv)
{
    XvMCContextPtr pContext = pSubpicture->context;
    xf86XvMCScreenPtr pScreenPriv = XF86XVMC_GET_PRIVATE(pContext->pScreen);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pContext->pScreen);

    return (*pScreenPriv->adaptors[pContext->adapt_num]->
            CreateSubpicture) (pScrn, pSubpicture, num_priv, priv);
}

static void
xf86XvMCDestroySubpicture(XvMCSubpicturePtr pSubpicture)
{
    XvMCContextPtr pContext = pSubpicture->context;
    xf86XvMCScreenPtr pScreenPriv = XF86XVMC_GET_PRIVATE(pContext->pScreen);
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pContext->pScreen);

    (*pScreenPriv->adaptors[pContext->adapt_num]->DestroySubpicture) (pScrn,
                                                                      pSubpicture);
}

static Bool
xf86XvMCCloseScreen(ScreenPtr pScreen)
{
    xf86XvMCScreenPtr pScreenPriv = XF86XVMC_GET_PRIVATE(pScreen);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;

    free(pScreenPriv->dixinfo);
    free(pScreenPriv);

    return (*pScreen->CloseScreen) (pScreen);
}

Bool
xf86XvMCScreenInit(ScreenPtr pScreen,
                   int num_adaptors, XF86MCAdaptorPtr * adaptors)
{
    XvMCAdaptorPtr pAdapt;
    xf86XvMCScreenPtr pScreenPriv;
    XvScreenPtr pxvs = (XvScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                      XF86XvScreenKey);
    int i, j;

    if (noXvExtension)
        return FALSE;

    if (!(pAdapt = xallocarray(num_adaptors, sizeof(XvMCAdaptorRec))))
        return FALSE;

    if (!dixRegisterPrivateKey(&XF86XvMCScreenKeyRec, PRIVATE_SCREEN, 0)) {
        free(pAdapt);
        return FALSE;
    }

    if (!(pScreenPriv = malloc(sizeof(xf86XvMCScreenRec)))) {
        free(pAdapt);
        return FALSE;
    }

    dixSetPrivate(&pScreen->devPrivates, XF86XvMCScreenKey, pScreenPriv);

    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = xf86XvMCCloseScreen;

    pScreenPriv->num_adaptors = num_adaptors;
    pScreenPriv->adaptors = adaptors;
    pScreenPriv->dixinfo = pAdapt;

    for (i = 0; i < num_adaptors; i++) {
        pAdapt[i].xv_adaptor = NULL;
        for (j = 0; j < pxvs->nAdaptors; j++) {
            if (!strcmp((*adaptors)->name, pxvs->pAdaptors[j].name)) {
                pAdapt[i].xv_adaptor = &(pxvs->pAdaptors[j]);
                break;
            }
        }
        if (!pAdapt[i].xv_adaptor) {
            /* no adaptor by that name */
            free(pAdapt);
            return FALSE;
        }
        pAdapt[i].num_surfaces = (*adaptors)->num_surfaces;
        pAdapt[i].surfaces = (XvMCSurfaceInfoPtr *) ((*adaptors)->surfaces);
        pAdapt[i].num_subpictures = (*adaptors)->num_subpictures;
        pAdapt[i].subpictures = (XvImagePtr *) ((*adaptors)->subpictures);
        pAdapt[i].CreateContext = xf86XvMCCreateContext;
        pAdapt[i].DestroyContext = xf86XvMCDestroyContext;
        pAdapt[i].CreateSurface = xf86XvMCCreateSurface;
        pAdapt[i].DestroySurface = xf86XvMCDestroySurface;
        pAdapt[i].CreateSubpicture = xf86XvMCCreateSubpicture;
        pAdapt[i].DestroySubpicture = xf86XvMCDestroySubpicture;
        adaptors++;
    }

    if (Success != XvMCScreenInit(pScreen, num_adaptors, pAdapt))
        return FALSE;

    return TRUE;
}

XF86MCAdaptorPtr
xf86XvMCCreateAdaptorRec(void)
{
    return calloc(1, sizeof(XF86MCAdaptorRec));
}

void
xf86XvMCDestroyAdaptorRec(XF86MCAdaptorPtr adaptor)
{
    free(adaptor);
}
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d158 1
a158 1
    if (!(pAdapt = malloc(sizeof(XvMCAdaptorRec) * num_adaptors)))
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d161 2
a162 1
    if (!dixRegisterPrivateKey(&XF86XvMCScreenKeyRec, PRIVATE_SCREEN, 0))
d164 1
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a42 2
#include "xvmodproc.h"

a45 2
XvMCScreenInitProcPtr XvMCScreenInitProc = NULL;

d65 1
a65 1
    ScrnInfoPtr pScrn = xf86Screens[pContext->pScreen->myNum];
d79 1
a79 1
    ScrnInfoPtr pScrn = xf86Screens[pContext->pScreen->myNum];
d90 1
a90 1
    ScrnInfoPtr pScrn = xf86Screens[pContext->pScreen->myNum];
d103 1
a103 1
    ScrnInfoPtr pScrn = xf86Screens[pContext->pScreen->myNum];
d115 1
a115 1
    ScrnInfoPtr pScrn = xf86Screens[pContext->pScreen->myNum];
d126 1
a126 1
    ScrnInfoPtr pScrn = xf86Screens[pContext->pScreen->myNum];
d133 1
a133 1
xf86XvMCCloseScreen(int i, ScreenPtr pScreen)
d142 1
a142 1
    return (*pScreen->CloseScreen) (i, pScreen);
d155 1
a155 1
    if (!XvMCScreenInitProc)
d204 1
a204 1
    if (Success != (*XvMCScreenInitProc) (pScreen, num_adaptors, pAdapt))
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a49 1

d51 4
a54 4
  CloseScreenProcPtr CloseScreen; 
  int num_adaptors;
  XF86MCAdaptorPtr *adaptors;
  XvMCAdaptorPtr dixinfo;
d58 1
d64 3
a66 8

static int 
xf86XvMCCreateContext (
  XvPortPtr pPort,
  XvMCContextPtr pContext,
  int *num_priv,
  CARD32 **priv
)
d71 1
a71 1
    pContext->port_priv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
d73 4
a76 2
    return (*pScreenPriv->adaptors[pContext->adapt_num]->CreateContext)(
		pScrn, pContext, num_priv, priv);
d79 2
a80 2
static void 
xf86XvMCDestroyContext ( XvMCContextPtr pContext)
d85 2
a86 2
    (*pScreenPriv->adaptors[pContext->adapt_num]->DestroyContext)(
                				pScrn, pContext);
d89 2
a90 6
static int 
xf86XvMCCreateSurface (
  XvMCSurfacePtr pSurface,
  int *num_priv,
  CARD32 **priv
)
d96 4
a99 2
    return (*pScreenPriv->adaptors[pContext->adapt_num]->CreateSurface)(
                pScrn, pSurface, num_priv, priv);
d102 2
a103 2
static void 
xf86XvMCDestroySurface (XvMCSurfacePtr pSurface)
d109 2
a110 2
    (*pScreenPriv->adaptors[pContext->adapt_num]->DestroySurface)(
                                                pScrn, pSurface);
d113 3
a115 6
static int 
xf86XvMCCreateSubpicture (
  XvMCSubpicturePtr pSubpicture,
  int *num_priv,
  CARD32 **priv
)
d121 2
a122 2
    return (*pScreenPriv->adaptors[pContext->adapt_num]->CreateSubpicture)(
                                  pScrn, pSubpicture, num_priv, priv);
d126 1
a126 1
xf86XvMCDestroySubpicture (XvMCSubpicturePtr pSubpicture)
d132 2
a133 2
    (*pScreenPriv->adaptors[pContext->adapt_num]->DestroySubpicture)(
                                                pScrn, pSubpicture);
a135 1

d137 1
a137 1
xf86XvMCCloseScreen (int i, ScreenPtr pScreen)
d146 1
a146 67
    return (*pScreen->CloseScreen)(i, pScreen);
}

Bool xf86XvMCScreenInit(
   ScreenPtr pScreen, 
   int num_adaptors,
   XF86MCAdaptorPtr *adaptors
)
{
   XvMCAdaptorPtr pAdapt;
   xf86XvMCScreenPtr pScreenPriv;
   XvScreenPtr pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						    XF86XvScreenKey);
   int i, j;

   if(!XvMCScreenInitProc) return FALSE;

   if(!(pAdapt = malloc(sizeof(XvMCAdaptorRec) * num_adaptors)))
	return FALSE;

   if (!dixRegisterPrivateKey(&XF86XvMCScreenKeyRec, PRIVATE_SCREEN, 0))
       return FALSE;

   if(!(pScreenPriv = malloc(sizeof(xf86XvMCScreenRec)))) {
	free(pAdapt);
	return FALSE;
   }

   dixSetPrivate(&pScreen->devPrivates, XF86XvMCScreenKey, pScreenPriv);

   pScreenPriv->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = xf86XvMCCloseScreen;

   pScreenPriv->num_adaptors = num_adaptors;
   pScreenPriv->adaptors = adaptors;
   pScreenPriv->dixinfo = pAdapt;

   for(i = 0; i < num_adaptors; i++) {
	pAdapt[i].xv_adaptor = NULL;
	for(j = 0; j < pxvs->nAdaptors; j++) {
	   if(!strcmp((*adaptors)->name, pxvs->pAdaptors[j].name)) {
		pAdapt[i].xv_adaptor = &(pxvs->pAdaptors[j]); 
		break;
	   }
	}
	if(!pAdapt[i].xv_adaptor) {
	    /* no adaptor by that name */
	    free(pAdapt);
	    return FALSE;
	}
	pAdapt[i].num_surfaces = (*adaptors)->num_surfaces;
	pAdapt[i].surfaces = (XvMCSurfaceInfoPtr*)((*adaptors)->surfaces);
	pAdapt[i].num_subpictures = (*adaptors)->num_subpictures;
	pAdapt[i].subpictures = (XvImagePtr*)((*adaptors)->subpictures);
	pAdapt[i].CreateContext = xf86XvMCCreateContext;
	pAdapt[i].DestroyContext = xf86XvMCDestroyContext;
	pAdapt[i].CreateSurface = xf86XvMCCreateSurface;
	pAdapt[i].DestroySurface = xf86XvMCDestroySurface;
	pAdapt[i].CreateSubpicture = xf86XvMCCreateSubpicture;
	pAdapt[i].DestroySubpicture = xf86XvMCDestroySubpicture;
	adaptors++;
   }

   if(Success != (*XvMCScreenInitProc)(pScreen, num_adaptors, pAdapt))
	return FALSE;

   return TRUE;
d149 67
a215 1
XF86MCAdaptorPtr xf86XvMCCreateAdaptorRec (void)
d217 1
a217 1
   return calloc(1, sizeof(XF86MCAdaptorRec));
d220 2
a221 1
void xf86XvMCDestroyAdaptorRec(XF86MCAdaptorPtr adaptor)
d223 1
a223 1
   free(adaptor);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d58 2
a59 2
static int XF86XvMCScreenKeyIndex;
static DevPrivateKey XF86XvMCScreenKey = &XF86XvMCScreenKeyIndex;
d152 2
a153 2
    xfree(pScreenPriv->dixinfo);
    xfree(pScreenPriv);
d172 1
a172 1
   if(!(pAdapt = xalloc(sizeof(XvMCAdaptorRec) * num_adaptors)))
d175 5
a179 2
   if(!(pScreenPriv = xalloc(sizeof(xf86XvMCScreenRec)))) {
	xfree(pAdapt);
d202 1
a202 1
	    xfree(pAdapt);
d226 1
a226 1
   return xcalloc(1, sizeof(XF86MCAdaptorRec));
d231 1
a231 1
   xfree(adaptor);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d48 1
a48 2
typedef int (*XvMCScreenInitProcPtr)(ScreenPtr, int, XvMCAdaptorPtr);
_X_EXPORT XvMCScreenInitProcPtr XvMCScreenInitProc = NULL;
d158 1
a158 1
_X_EXPORT Bool xf86XvMCScreenInit(
d221 1
a221 1
_X_EXPORT XF86MCAdaptorPtr xf86XvMCCreateAdaptorRec (void)
d226 1
a226 1
_X_EXPORT void xf86XvMCDestroyAdaptorRec(XF86MCAdaptorPtr adaptor)
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d59 2
a60 1
static DevPrivateKey XF86XvMCScreenKey = &XF86XvMCScreenKey;
@


1.1
log
@Initial revision
@
text
@d59 1
a59 2
static unsigned long XF86XvMCGeneration = 0;
static int XF86XvMCScreenIndex = -1;
d61 2
a62 2
#define XF86XVMC_GET_PRIVATE(pScreen) \
   (xf86XvMCScreenPtr)((pScreen)->devPrivates[XF86XvMCScreenIndex].ptr)
d166 2
a167 3
   XvScreenPtr pxvs = 
	(XvScreenPtr)(pScreen->devPrivates[XF86XvScreenIndex].ptr);

a171 6
   if(XF86XvMCGeneration != serverGeneration) {
	if((XF86XvMCScreenIndex = AllocateScreenPrivateIndex()) < 0)
	   return FALSE;
	XF86XvMCGeneration = serverGeneration;
   }

d180 1
a180 1
   pScreen->devPrivates[XF86XvMCScreenIndex].ptr = (pointer)pScreenPriv; 
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
