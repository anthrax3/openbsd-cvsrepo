head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.6
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.10;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.10;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.49;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

/*
 * Authors: Dirk Hohndel <hohndel@@XFree86.Org>
 *          David Dawes <dawes@@XFree86.Org>
 *          ... and others
 *
 * This file includes the helper functions that the server provides for
 * different drivers.
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <X11/X.h>
#include "os.h"
#include "servermd.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "propertyst.h"
#include "gcstruct.h"
#include "loaderProcs.h"
#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"
#include "micmap.h"
#include "xf86DDC.h"
#include "xf86Xinput.h"
#include "xf86InPriv.h"
#include "mivalidate.h"
#include "xf86Crtc.h"

/* For xf86GetClocks */
#if defined(CSRG_BASED) || defined(__GNU__)
#define HAS_SETPRIORITY
#include <sys/resource.h>
#endif

static int xf86ScrnInfoPrivateCount = 0;

/* Add a pointer to a new DriverRec to xf86DriverList */

void
xf86AddDriver(DriverPtr driver, void *module, int flags)
{
    /* Don't add null entries */
    if (!driver)
        return;

    if (xf86DriverList == NULL)
        xf86NumDrivers = 0;

    xf86NumDrivers++;
    xf86DriverList = xnfreallocarray(xf86DriverList,
                                     xf86NumDrivers, sizeof(DriverPtr));
    xf86DriverList[xf86NumDrivers - 1] = xnfalloc(sizeof(DriverRec));
    if (flags & HaveDriverFuncs)
        *xf86DriverList[xf86NumDrivers - 1] = *driver;
    else {
        (void) memset(xf86DriverList[xf86NumDrivers - 1], 0, sizeof(DriverRec));
        (void) memcpy(xf86DriverList[xf86NumDrivers - 1], driver,
                      sizeof(DriverRec1));

    }
    xf86DriverList[xf86NumDrivers - 1]->module = module;
    xf86DriverList[xf86NumDrivers - 1]->refCount = 0;
}

void
xf86DeleteDriver(int drvIndex)
{
    if (xf86DriverList[drvIndex]
        && (!xf86DriverHasEntities(xf86DriverList[drvIndex]))) {
        if (xf86DriverList[drvIndex]->module)
            UnloadModule(xf86DriverList[drvIndex]->module);
        free(xf86DriverList[drvIndex]);
        xf86DriverList[drvIndex] = NULL;
    }
}

/* Add a pointer to a new InputDriverRec to xf86InputDriverList */

void
xf86AddInputDriver(InputDriverPtr driver, void *module, int flags)
{
    /* Don't add null entries */
    if (!driver)
        return;

    if (xf86InputDriverList == NULL)
        xf86NumInputDrivers = 0;

    xf86NumInputDrivers++;
    xf86InputDriverList = xnfreallocarray(xf86InputDriverList,
                                          xf86NumInputDrivers,
                                          sizeof(InputDriverPtr));
    xf86InputDriverList[xf86NumInputDrivers - 1] =
        xnfalloc(sizeof(InputDriverRec));
    *xf86InputDriverList[xf86NumInputDrivers - 1] = *driver;
    xf86InputDriverList[xf86NumInputDrivers - 1]->module = module;
}

void
xf86DeleteInputDriver(int drvIndex)
{
    if (xf86InputDriverList[drvIndex] && xf86InputDriverList[drvIndex]->module)
        UnloadModule(xf86InputDriverList[drvIndex]->module);
    free(xf86InputDriverList[drvIndex]);
    xf86InputDriverList[drvIndex] = NULL;
}

InputDriverPtr
xf86LookupInputDriver(const char *name)
{
    int i;

    for (i = 0; i < xf86NumInputDrivers; i++) {
        if (xf86InputDriverList[i] && xf86InputDriverList[i]->driverName &&
            xf86NameCmp(name, xf86InputDriverList[i]->driverName) == 0)
            return xf86InputDriverList[i];
    }
    return NULL;
}

InputInfoPtr
xf86LookupInput(const char *name)
{
    InputInfoPtr p;

    for (p = xf86InputDevs; p != NULL; p = p->next) {
        if (strcmp(name, p->name) == 0)
            return p;
    }

    return NULL;
}

/* Allocate a new ScrnInfoRec in xf86Screens */

ScrnInfoPtr
xf86AllocateScreen(DriverPtr drv, int flags)
{
    int i;
    ScrnInfoPtr pScrn;

    if (flags & XF86_ALLOCATE_GPU_SCREEN) {
        if (xf86GPUScreens == NULL)
            xf86NumGPUScreens = 0;
        i = xf86NumGPUScreens++;
        xf86GPUScreens = xnfreallocarray(xf86GPUScreens, xf86NumGPUScreens,
                                         sizeof(ScrnInfoPtr));
        xf86GPUScreens[i] = xnfcalloc(sizeof(ScrnInfoRec), 1);
        pScrn = xf86GPUScreens[i];
        pScrn->scrnIndex = i + GPU_SCREEN_OFFSET;      /* Changes when a screen is removed */
        pScrn->is_gpu = TRUE;
    } else {
        if (xf86Screens == NULL)
            xf86NumScreens = 0;

        i = xf86NumScreens++;
        xf86Screens = xnfreallocarray(xf86Screens, xf86NumScreens,
                                      sizeof(ScrnInfoPtr));
        xf86Screens[i] = xnfcalloc(sizeof(ScrnInfoRec), 1);
        pScrn = xf86Screens[i];

        pScrn->scrnIndex = i;      /* Changes when a screen is removed */
    }

    pScrn->origIndex = pScrn->scrnIndex;      /* This never changes */
    pScrn->privates = xnfcalloc(sizeof(DevUnion), xf86ScrnInfoPrivateCount);
    /*
     * EnableDisableFBAccess now gets initialized in InitOutput()
     * pScrn->EnableDisableFBAccess = xf86EnableDisableFBAccess;
     */

    pScrn->drv = drv;
    drv->refCount++;
    pScrn->module = DuplicateModule(drv->module, NULL);

    pScrn->DriverFunc = drv->driverFunc;

    return pScrn;
}

/*
 * Remove an entry from xf86Screens.  Ideally it should free all allocated
 * data.  To do this properly may require a driver hook.
 */

void
xf86DeleteScreen(ScrnInfoPtr pScrn)
{
    int i;
    int scrnIndex;
    Bool is_gpu = FALSE;

    if (!pScrn)
        return;

    if (pScrn->is_gpu) {
        /* First check if the screen is valid */
        if (xf86NumGPUScreens == 0 || xf86GPUScreens == NULL)
            return;
        is_gpu = TRUE;
    } else {
        /* First check if the screen is valid */
        if (xf86NumScreens == 0 || xf86Screens == NULL)
            return;
    }

    scrnIndex = pScrn->scrnIndex;
    /* If a FreeScreen function is defined, call it here */
    if (pScrn->FreeScreen != NULL)
        pScrn->FreeScreen(pScrn);

    while (pScrn->modes)
        xf86DeleteMode(&pScrn->modes, pScrn->modes);

    while (pScrn->modePool)
        xf86DeleteMode(&pScrn->modePool, pScrn->modePool);

    xf86OptionListFree(pScrn->options);

    if (pScrn->module)
        UnloadModule(pScrn->module);

    if (pScrn->drv)
        pScrn->drv->refCount--;

    free(pScrn->privates);

    xf86ClearEntityListForScreen(pScrn);

    free(pScrn);

    /* Move the other entries down, updating their scrnIndex fields */

    if (is_gpu) {
        xf86NumGPUScreens--;
        scrnIndex -= GPU_SCREEN_OFFSET;
        for (i = scrnIndex; i < xf86NumGPUScreens; i++) {
            xf86GPUScreens[i] = xf86GPUScreens[i + 1];
            xf86GPUScreens[i]->scrnIndex = i + GPU_SCREEN_OFFSET;
            /* Also need to take care of the screen layout settings */
        }
    }
    else {
        xf86NumScreens--;

        for (i = scrnIndex; i < xf86NumScreens; i++) {
            xf86Screens[i] = xf86Screens[i + 1];
            xf86Screens[i]->scrnIndex = i;
            /* Also need to take care of the screen layout settings */
        }
    }
}

/*
 * Allocate a private in ScrnInfoRec.
 */

int
xf86AllocateScrnInfoPrivateIndex(void)
{
    int idx, i;
    ScrnInfoPtr pScr;
    DevUnion *nprivs;

    idx = xf86ScrnInfoPrivateCount++;
    for (i = 0; i < xf86NumScreens; i++) {
        pScr = xf86Screens[i];
        nprivs = xnfreallocarray(pScr->privates,
                                 xf86ScrnInfoPrivateCount, sizeof(DevUnion));
        /* Zero the new private */
        memset(&nprivs[idx], 0, sizeof(DevUnion));
        pScr->privates = nprivs;
    }
    for (i = 0; i < xf86NumGPUScreens; i++) {
        pScr = xf86GPUScreens[i];
        nprivs = xnfreallocarray(pScr->privates,
                                 xf86ScrnInfoPrivateCount, sizeof(DevUnion));
        /* Zero the new private */
        memset(&nprivs[idx], 0, sizeof(DevUnion));
        pScr->privates = nprivs;
    }
    return idx;
}

Bool
xf86AddPixFormat(ScrnInfoPtr pScrn, int depth, int bpp, int pad)
{
    int i;

    if (pScrn->numFormats >= MAXFORMATS)
        return FALSE;

    if (bpp <= 0) {
        if (depth == 1)
            bpp = 1;
        else if (depth <= 8)
            bpp = 8;
        else if (depth <= 16)
            bpp = 16;
        else if (depth <= 32)
            bpp = 32;
        else
            return FALSE;
    }
    if (pad <= 0)
        pad = BITMAP_SCANLINE_PAD;

    i = pScrn->numFormats++;
    pScrn->formats[i].depth = depth;
    pScrn->formats[i].bitsPerPixel = bpp;
    pScrn->formats[i].scanlinePad = pad;
    return TRUE;
}

/*
 * Set the depth we are using based on (in the following order of preference):
 *  - values given on the command line
 *  - values given in the config file
 *  - values provided by the driver
 *  - an overall default when nothing else is given
 *
 * Also find a Display subsection matching the depth/bpp found.
 *
 * Sets the following ScrnInfoRec fields:
 *     bitsPerPixel, pixmap24, depth, display, imageByteOrder,
 *     bitmapScanlinePad, bitmapScanlineUnit, bitmapBitOrder, numFormats,
 *     formats, fbFormat.
 */

/* Can the screen handle 24 bpp pixmaps */
#define DO_PIX24(f) ((f & Support24bppFb) || \
		     ((f & Support32bppFb) && (f & SupportConvert24to32)))

/* Can the screen handle 32 bpp pixmaps */
#define DO_PIX32(f) ((f & Support32bppFb) || \
		     ((f & Support24bppFb) && (f & SupportConvert32to24)))

/* Does the screen prefer 32bpp fb for 24bpp pixmaps */
#define CHOOSE32FOR24(f) ((f & Support32bppFb) && (f & SupportConvert24to32) \
			  && (f & PreferConvert24to32))

/* Does the screen prefer 24bpp fb for 32bpp pixmaps */
#define CHOOSE24FOR32(f) ((f & Support24bppFb) && (f & SupportConvert32to24) \
			  && (f & PreferConvert32to24))

/* Can the screen handle 32bpp pixmaps for 24bpp fb */
#define DO_PIX32FOR24(f) ((f & Support24bppFb) && (f & SupportConvert32to24))

/* Can the screen handle 24bpp pixmaps for 32bpp fb */
#define DO_PIX24FOR32(f) ((f & Support32bppFb) && (f & SupportConvert24to32))

#ifndef GLOBAL_DEFAULT_DEPTH
#define GLOBAL_DEFAULT_DEPTH 24
#endif

Bool
xf86SetDepthBpp(ScrnInfoPtr scrp, int depth, int dummy, int fbbpp,
                int depth24flags)
{
    int i;
    DispPtr disp;
    Pix24Flags pix24 = xf86Info.pixmap24;
    Bool nomatch = FALSE;

    scrp->bitsPerPixel = -1;
    scrp->depth = -1;
    scrp->pixmap24 = Pix24DontCare;
    scrp->bitsPerPixelFrom = X_DEFAULT;
    scrp->depthFrom = X_DEFAULT;

    if (xf86FbBpp > 0) {
        scrp->bitsPerPixel = xf86FbBpp;
        scrp->bitsPerPixelFrom = X_CMDLINE;
    }

    if (xf86Depth > 0) {
        scrp->depth = xf86Depth;
        scrp->depthFrom = X_CMDLINE;
    }

    if (xf86FbBpp < 0 && xf86Depth < 0) {
        if (scrp->confScreen->defaultfbbpp > 0) {
            scrp->bitsPerPixel = scrp->confScreen->defaultfbbpp;
            scrp->bitsPerPixelFrom = X_CONFIG;
        }
        if (scrp->confScreen->defaultdepth > 0) {
            scrp->depth = scrp->confScreen->defaultdepth;
            scrp->depthFrom = X_CONFIG;
        }

        if (scrp->confScreen->defaultfbbpp <= 0 &&
            scrp->confScreen->defaultdepth <= 0) {
            /*
             * Check for DefaultDepth and DefaultFbBpp options in the
             * Device sections.
             */
            GDevPtr device;
            Bool found = FALSE;

            for (i = 0; i < scrp->numEntities; i++) {
                device = xf86GetDevFromEntity(scrp->entityList[i],
                                              scrp->entityInstanceList[i]);
                if (device && device->options) {
                    if (xf86FindOption(device->options, "DefaultDepth")) {
                        scrp->depth = xf86SetIntOption(device->options,
                                                       "DefaultDepth", -1);
                        scrp->depthFrom = X_CONFIG;
                        found = TRUE;
                    }
                    if (xf86FindOption(device->options, "DefaultFbBpp")) {
                        scrp->bitsPerPixel = xf86SetIntOption(device->options,
                                                              "DefaultFbBpp",
                                                              -1);
                        scrp->bitsPerPixelFrom = X_CONFIG;
                        found = TRUE;
                    }
                }
                if (found)
                    break;
            }
        }
    }

    /* If none of these is set, pick a default */
    if (scrp->bitsPerPixel < 0 && scrp->depth < 0) {
        if (fbbpp > 0 || depth > 0) {
            if (fbbpp > 0)
                scrp->bitsPerPixel = fbbpp;
            if (depth > 0)
                scrp->depth = depth;
        }
        else {
            scrp->depth = GLOBAL_DEFAULT_DEPTH;
        }
    }

    /* If any are not given, determine a default for the others */

    if (scrp->bitsPerPixel < 0) {
        /* The depth must be set */
        if (scrp->depth > -1) {
            if (scrp->depth == 1)
                scrp->bitsPerPixel = 1;
            else if (scrp->depth <= 4)
                scrp->bitsPerPixel = 4;
            else if (scrp->depth <= 8)
                scrp->bitsPerPixel = 8;
            else if (scrp->depth <= 16)
                scrp->bitsPerPixel = 16;
            else if (scrp->depth <= 24) {
                /*
                 * Figure out if a choice is possible based on the depth24
                 * and pix24 flags.
                 */
                /* Check pix24 first */
                if (pix24 != Pix24DontCare) {
                    if (pix24 == Pix24Use32) {
                        if (DO_PIX32(depth24flags)) {
                            if (CHOOSE24FOR32(depth24flags))
                                scrp->bitsPerPixel = 24;
                            else
                                scrp->bitsPerPixel = 32;
                        }
                        else {
                            nomatch = TRUE;
                        }
                    }
                    else if (pix24 == Pix24Use24) {
                        if (DO_PIX24(depth24flags)) {
                            if (CHOOSE32FOR24(depth24flags))
                                scrp->bitsPerPixel = 32;
                            else
                                scrp->bitsPerPixel = 24;
                        }
                        else {
                            nomatch = TRUE;
                        }
                    }
                }
                else {
                    if (DO_PIX32(depth24flags)) {
                        if (CHOOSE24FOR32(depth24flags))
                            scrp->bitsPerPixel = 24;
                        else
                            scrp->bitsPerPixel = 32;
                    }
                    else if (DO_PIX24(depth24flags)) {
                        if (CHOOSE32FOR24(depth24flags))
                            scrp->bitsPerPixel = 32;
                        else
                            scrp->bitsPerPixel = 24;
                    }
                }
            }
            else if (scrp->depth <= 32)
                scrp->bitsPerPixel = 32;
            else {
                xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                           "Specified depth (%d) is greater than 32\n",
                           scrp->depth);
                return FALSE;
            }
        }
        else {
            xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                       "xf86SetDepthBpp: internal error: depth and fbbpp"
                       " are both not set\n");
            return FALSE;
        }
        if (scrp->bitsPerPixel < 0) {
            if (nomatch)
                xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                           "Driver can't support depth 24 pixmap format (%d)\n",
                           PIX24TOBPP(pix24));
            else if ((depth24flags & (Support24bppFb | Support32bppFb)) ==
                     NoDepth24Support)
                xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                           "Driver can't support depth 24\n");
            else
                xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                           "Can't find fbbpp for depth 24\n");
            return FALSE;
        }
        scrp->bitsPerPixelFrom = X_PROBED;
    }

    if (scrp->depth <= 0) {
        /* bitsPerPixel is already set */
        switch (scrp->bitsPerPixel) {
        case 32:
            scrp->depth = 24;
            break;
        default:
            /* 1, 4, 8, 16 and 24 */
            scrp->depth = scrp->bitsPerPixel;
            break;
        }
        scrp->depthFrom = X_PROBED;
    }

    /* Sanity checks */
    if (scrp->depth < 1 || scrp->depth > 32) {
        xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                   "Specified depth (%d) is not in the range 1-32\n",
                   scrp->depth);
        return FALSE;
    }
    switch (scrp->bitsPerPixel) {
    case 1:
    case 4:
    case 8:
    case 16:
    case 24:
    case 32:
        break;
    default:
        xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                   "Specified fbbpp (%d) is not a permitted value\n",
                   scrp->bitsPerPixel);
        return FALSE;
    }
    if (scrp->depth > scrp->bitsPerPixel) {
        xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                   "Specified depth (%d) is greater than the fbbpp (%d)\n",
                   scrp->depth, scrp->bitsPerPixel);
        return FALSE;
    }

    /* set scrp->pixmap24 if the driver isn't flexible */
    if (scrp->bitsPerPixel == 24 && !DO_PIX32FOR24(depth24flags)) {
        scrp->pixmap24 = Pix24Use24;
    }
    if (scrp->bitsPerPixel == 32 && !DO_PIX24FOR32(depth24flags)) {
        scrp->pixmap24 = Pix24Use32;
    }

    /*
     * Find the Display subsection matching the depth/fbbpp and initialise
     * scrp->display with it.
     */
    for (i = 0, disp = scrp->confScreen->displays;
         i < scrp->confScreen->numdisplays; i++, disp++) {
        if ((disp->depth == scrp->depth && disp->fbbpp == scrp->bitsPerPixel)
            || (disp->depth == scrp->depth && disp->fbbpp <= 0)
            || (disp->fbbpp == scrp->bitsPerPixel && disp->depth <= 0)) {
            scrp->display = disp;
            break;
        }
    }

    /*
     * If an exact match can't be found, see if there is one with no
     * depth or fbbpp specified.
     */
    if (i == scrp->confScreen->numdisplays) {
        for (i = 0, disp = scrp->confScreen->displays;
             i < scrp->confScreen->numdisplays; i++, disp++) {
            if (disp->depth <= 0 && disp->fbbpp <= 0) {
                scrp->display = disp;
                break;
            }
        }
    }

    /*
     * If all else fails, create a default one.
     */
    if (i == scrp->confScreen->numdisplays) {
        scrp->confScreen->numdisplays++;
        scrp->confScreen->displays =
            xnfreallocarray(scrp->confScreen->displays,
                            scrp->confScreen->numdisplays, sizeof(DispRec));
        xf86DrvMsg(scrp->scrnIndex, X_INFO,
                   "Creating default Display subsection in Screen section\n"
                   "\t\"%s\" for depth/fbbpp %d/%d\n",
                   scrp->confScreen->id, scrp->depth, scrp->bitsPerPixel);
        memset(&scrp->confScreen->displays[i], 0, sizeof(DispRec));
        scrp->confScreen->displays[i].blackColour.red = -1;
        scrp->confScreen->displays[i].blackColour.green = -1;
        scrp->confScreen->displays[i].blackColour.blue = -1;
        scrp->confScreen->displays[i].whiteColour.red = -1;
        scrp->confScreen->displays[i].whiteColour.green = -1;
        scrp->confScreen->displays[i].whiteColour.blue = -1;
        scrp->confScreen->displays[i].defaultVisual = -1;
        scrp->confScreen->displays[i].modes = xnfalloc(sizeof(char *));
        scrp->confScreen->displays[i].modes[0] = NULL;
        scrp->confScreen->displays[i].depth = depth;
        scrp->confScreen->displays[i].fbbpp = fbbpp;
        scrp->display = &scrp->confScreen->displays[i];
    }

    /*
     * Setup defaults for the display-wide attributes the framebuffer will
     * need.  These defaults should eventually be set globally, and not
     * dependent on the screens.
     */
    scrp->imageByteOrder = IMAGE_BYTE_ORDER;
    scrp->bitmapScanlinePad = BITMAP_SCANLINE_PAD;
    if (scrp->depth < 8) {
        /* Planar modes need these settings */
        scrp->bitmapScanlineUnit = 8;
        scrp->bitmapBitOrder = MSBFirst;
    }
    else {
        scrp->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
        scrp->bitmapBitOrder = BITMAP_BIT_ORDER;
    }

    /*
     * If an unusual depth is required, add it to scrp->formats.  The formats
     * for the common depths are handled globally in InitOutput
     */
    switch (scrp->depth) {
    case 1:
    case 4:
    case 8:
    case 15:
    case 16:
    case 24:
        /* Common depths.  Nothing to do for them */
        break;
    default:
        if (!xf86AddPixFormat(scrp, scrp->depth, 0, 0)) {
            xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                       "Can't add pixmap format for depth %d\n", scrp->depth);
            return FALSE;
        }
    }

    /* Initialise the framebuffer format for this screen */
    scrp->fbFormat.depth = scrp->depth;
    scrp->fbFormat.bitsPerPixel = scrp->bitsPerPixel;
    scrp->fbFormat.scanlinePad = BITMAP_SCANLINE_PAD;

    return TRUE;
}

/*
 * Print out the selected depth and bpp.
 */
void
xf86PrintDepthBpp(ScrnInfoPtr scrp)
{
    xf86DrvMsg(scrp->scrnIndex, scrp->depthFrom, "Depth %d, ", scrp->depth);
    xf86Msg(scrp->bitsPerPixelFrom, "framebuffer bpp %d\n", scrp->bitsPerPixel);
}

/*
 * xf86SetWeight sets scrp->weight, scrp->mask, scrp->offset, and for depths
 * greater than MAX_PSEUDO_DEPTH also scrp->rgbBits.
 */
Bool
xf86SetWeight(ScrnInfoPtr scrp, rgb weight, rgb mask)
{
    MessageType weightFrom = X_DEFAULT;

    scrp->weight.red = 0;
    scrp->weight.green = 0;
    scrp->weight.blue = 0;

    if (xf86Weight.red > 0 && xf86Weight.green > 0 && xf86Weight.blue > 0) {
        scrp->weight = xf86Weight;
        weightFrom = X_CMDLINE;
    }
    else if (scrp->display->weight.red > 0 && scrp->display->weight.green > 0
             && scrp->display->weight.blue > 0) {
        scrp->weight = scrp->display->weight;
        weightFrom = X_CONFIG;
    }
    else if (weight.red > 0 && weight.green > 0 && weight.blue > 0) {
        scrp->weight = weight;
    }
    else {
        switch (scrp->depth) {
        case 1:
        case 4:
        case 8:
            scrp->weight.red = scrp->weight.green =
                scrp->weight.blue = scrp->rgbBits;
            break;
        case 15:
            scrp->weight.red = scrp->weight.green = scrp->weight.blue = 5;
            break;
        case 16:
            scrp->weight.red = scrp->weight.blue = 5;
            scrp->weight.green = 6;
            break;
        case 18:
            scrp->weight.red = scrp->weight.green = scrp->weight.blue = 6;
            break;
        case 24:
            scrp->weight.red = scrp->weight.green = scrp->weight.blue = 8;
            break;
        case 30:
            scrp->weight.red = scrp->weight.green = scrp->weight.blue = 10;
            break;
        }
    }

    if (scrp->weight.red)
        xf86DrvMsg(scrp->scrnIndex, weightFrom, "RGB weight %d%d%d\n",
                   (int) scrp->weight.red, (int) scrp->weight.green,
                   (int) scrp->weight.blue);

    if (scrp->depth > MAX_PSEUDO_DEPTH &&
        (scrp->depth != scrp->weight.red + scrp->weight.green +
         scrp->weight.blue)) {
        xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                   "Weight given (%d%d%d) is inconsistent with the "
                   "depth (%d)\n",
                   (int) scrp->weight.red, (int) scrp->weight.green,
                   (int) scrp->weight.blue, scrp->depth);
        return FALSE;
    }
    if (scrp->depth > MAX_PSEUDO_DEPTH && scrp->weight.red) {
        /*
         * XXX Does this even mean anything for TrueColor visuals?
         * If not, we shouldn't even be setting it here.  However, this
         * matches the behaviour of 3.x versions of XFree86.
         */
        scrp->rgbBits = scrp->weight.red;
        if (scrp->weight.green > scrp->rgbBits)
            scrp->rgbBits = scrp->weight.green;
        if (scrp->weight.blue > scrp->rgbBits)
            scrp->rgbBits = scrp->weight.blue;
    }

    /* Set the mask and offsets */
    if (mask.red == 0 || mask.green == 0 || mask.blue == 0) {
        /* Default to a setting common to PC hardware */
        scrp->offset.red = scrp->weight.green + scrp->weight.blue;
        scrp->offset.green = scrp->weight.blue;
        scrp->offset.blue = 0;
        scrp->mask.red = ((1 << scrp->weight.red) - 1) << scrp->offset.red;
        scrp->mask.green = ((1 << scrp->weight.green) - 1)
            << scrp->offset.green;
        scrp->mask.blue = (1 << scrp->weight.blue) - 1;
    }
    else {
        /* Initialise to the values passed */
        scrp->mask.red = mask.red;
        scrp->mask.green = mask.green;
        scrp->mask.blue = mask.blue;
        scrp->offset.red = ffs(mask.red);
        scrp->offset.green = ffs(mask.green);
        scrp->offset.blue = ffs(mask.blue);
    }
    return TRUE;
}

Bool
xf86SetDefaultVisual(ScrnInfoPtr scrp, int visual)
{
    MessageType visualFrom = X_DEFAULT;

    if (defaultColorVisualClass >= 0) {
        scrp->defaultVisual = defaultColorVisualClass;
        visualFrom = X_CMDLINE;
    }
    else if (scrp->display->defaultVisual >= 0) {
        scrp->defaultVisual = scrp->display->defaultVisual;
        visualFrom = X_CONFIG;
    }
    else if (visual >= 0) {
        scrp->defaultVisual = visual;
    }
    else {
        if (scrp->depth == 1)
            scrp->defaultVisual = StaticGray;
        else if (scrp->depth == 4)
            scrp->defaultVisual = StaticColor;
        else if (scrp->depth <= MAX_PSEUDO_DEPTH)
            scrp->defaultVisual = PseudoColor;
        else
            scrp->defaultVisual = TrueColor;
    }
    switch (scrp->defaultVisual) {
    case StaticGray:
    case GrayScale:
    case StaticColor:
    case PseudoColor:
    case TrueColor:
    case DirectColor:
        xf86DrvMsg(scrp->scrnIndex, visualFrom, "Default visual is %s\n",
                   xf86VisualNames[scrp->defaultVisual]);
        return TRUE;
    default:

        xf86DrvMsg(scrp->scrnIndex, X_ERROR,
                   "Invalid default visual class (%d)\n", scrp->defaultVisual);
        return FALSE;
    }
}

#define TEST_GAMMA(g) \
	(g).red > GAMMA_ZERO || (g).green > GAMMA_ZERO || (g).blue > GAMMA_ZERO

#define SET_GAMMA(g) \
	(g) > GAMMA_ZERO ? (g) : 1.0

Bool
xf86SetGamma(ScrnInfoPtr scrp, Gamma gamma)
{
    MessageType from = X_DEFAULT;

#if 0
    xf86MonPtr DDC = (xf86MonPtr) (scrp->monitor->DDC);
#endif
    if (TEST_GAMMA(xf86Gamma)) {
        from = X_CMDLINE;
        scrp->gamma.red = SET_GAMMA(xf86Gamma.red);
        scrp->gamma.green = SET_GAMMA(xf86Gamma.green);
        scrp->gamma.blue = SET_GAMMA(xf86Gamma.blue);
    }
    else if (TEST_GAMMA(scrp->monitor->gamma)) {
        from = X_CONFIG;
        scrp->gamma.red = SET_GAMMA(scrp->monitor->gamma.red);
        scrp->gamma.green = SET_GAMMA(scrp->monitor->gamma.green);
        scrp->gamma.blue = SET_GAMMA(scrp->monitor->gamma.blue);
#if 0
    }
    else if (DDC && DDC->features.gamma > GAMMA_ZERO) {
        from = X_PROBED;
        scrp->gamma.red = SET_GAMMA(DDC->features.gamma);
        scrp->gamma.green = SET_GAMMA(DDC->features.gamma);
        scrp->gamma.blue = SET_GAMMA(DDC->features.gamma);
        /* EDID structure version 2 gives optional seperate red, green & blue gamma values
         * in bytes 0x57-0x59 */
#endif
    }
    else if (TEST_GAMMA(gamma)) {
        scrp->gamma.red = SET_GAMMA(gamma.red);
        scrp->gamma.green = SET_GAMMA(gamma.green);
        scrp->gamma.blue = SET_GAMMA(gamma.blue);
    }
    else {
        scrp->gamma.red = 1.0;
        scrp->gamma.green = 1.0;
        scrp->gamma.blue = 1.0;
    }
    /* Pretend we succeeded if we support better a gamma system.
     * This avoids a confusing message.
     */
    if (xf86_crtc_supports_gamma(scrp))
        return TRUE;
    xf86DrvMsg(scrp->scrnIndex, from,
               "Using gamma correction (%.1f, %.1f, %.1f)\n",
               scrp->gamma.red, scrp->gamma.green, scrp->gamma.blue);

    return TRUE;
}

#undef TEST_GAMMA
#undef SET_GAMMA

/*
 * Set the DPI from the command line option.  XXX should allow it to be
 * calculated from the widthmm/heightmm values.
 */

#undef MMPERINCH
#define MMPERINCH 25.4

void
xf86SetDpi(ScrnInfoPtr pScrn, int x, int y)
{
    MessageType from = X_DEFAULT;
    xf86MonPtr DDC = (xf86MonPtr) (pScrn->monitor->DDC);
    int ddcWidthmm, ddcHeightmm;
    int widthErr, heightErr;

    /* XXX Maybe there is no need for widthmm/heightmm in ScrnInfoRec */
    pScrn->widthmm = pScrn->monitor->widthmm;
    pScrn->heightmm = pScrn->monitor->heightmm;

    if (DDC && (DDC->features.hsize > 0 && DDC->features.vsize > 0)) {
        /* DDC gives display size in mm for individual modes,
         * but cm for monitor
         */
        ddcWidthmm = DDC->features.hsize * 10;  /* 10mm in 1cm */
        ddcHeightmm = DDC->features.vsize * 10; /* 10mm in 1cm */
    }
    else {
        ddcWidthmm = ddcHeightmm = 0;
    }

    if (monitorResolution > 0) {
        pScrn->xDpi = monitorResolution;
        pScrn->yDpi = monitorResolution;
        from = X_CMDLINE;
    }
    else if (pScrn->widthmm > 0 || pScrn->heightmm > 0) {
        from = X_CONFIG;
        if (pScrn->widthmm > 0) {
            pScrn->xDpi =
                (int) ((double) pScrn->virtualX * MMPERINCH / pScrn->widthmm);
        }
        if (pScrn->heightmm > 0) {
            pScrn->yDpi =
                (int) ((double) pScrn->virtualY * MMPERINCH / pScrn->heightmm);
        }
        if (pScrn->xDpi > 0 && pScrn->yDpi <= 0)
            pScrn->yDpi = pScrn->xDpi;
        if (pScrn->yDpi > 0 && pScrn->xDpi <= 0)
            pScrn->xDpi = pScrn->yDpi;
        xf86DrvMsg(pScrn->scrnIndex, from, "Display dimensions: (%d, %d) mm\n",
                   pScrn->widthmm, pScrn->heightmm);

        /* Warn if config and probe disagree about display size */
        if (ddcWidthmm && ddcHeightmm) {
            if (pScrn->widthmm > 0) {
                widthErr = abs(ddcWidthmm - pScrn->widthmm);
            }
            else {
                widthErr = 0;
            }
            if (pScrn->heightmm > 0) {
                heightErr = abs(ddcHeightmm - pScrn->heightmm);
            }
            else {
                heightErr = 0;
            }
            if (widthErr > 10 || heightErr > 10) {
                /* Should include config file name for monitor here */
                xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                           "Probed monitor is %dx%d mm, using Displaysize %dx%d mm\n",
                           ddcWidthmm, ddcHeightmm, pScrn->widthmm,
                           pScrn->heightmm);
            }
        }
    }
    else if (ddcWidthmm && ddcHeightmm) {
        from = X_PROBED;
        xf86DrvMsg(pScrn->scrnIndex, from, "Display dimensions: (%d, %d) mm\n",
                   ddcWidthmm, ddcHeightmm);
        pScrn->widthmm = ddcWidthmm;
        pScrn->heightmm = ddcHeightmm;
        if (pScrn->widthmm > 0) {
            pScrn->xDpi =
                (int) ((double) pScrn->virtualX * MMPERINCH / pScrn->widthmm);
        }
        if (pScrn->heightmm > 0) {
            pScrn->yDpi =
                (int) ((double) pScrn->virtualY * MMPERINCH / pScrn->heightmm);
        }
        if (pScrn->xDpi > 0 && pScrn->yDpi <= 0)
            pScrn->yDpi = pScrn->xDpi;
        if (pScrn->yDpi > 0 && pScrn->xDpi <= 0)
            pScrn->xDpi = pScrn->yDpi;
    }
    else {
        if (x > 0)
            pScrn->xDpi = x;
        else
            pScrn->xDpi = DEFAULT_DPI;
        if (y > 0)
            pScrn->yDpi = y;
        else
            pScrn->yDpi = DEFAULT_DPI;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "DPI set to (%d, %d)\n",
               pScrn->xDpi, pScrn->yDpi);
}

#undef MMPERINCH

void
xf86SetBlackWhitePixels(ScreenPtr pScreen)
{
    if (xf86FlipPixels) {
        pScreen->whitePixel = 0;
        pScreen->blackPixel = 1;
    }
    else {
        pScreen->whitePixel = 1;
        pScreen->blackPixel = 0;
    }
}

/*
 * Function to enable/disable access to the frame buffer
 *
 * This is used when VT switching and when entering/leaving DGA direct mode.
 *
 * This has been rewritten again to eliminate the saved pixmap.  The
 * devPrivate field in the screen pixmap is set to NULL to catch code
 * accidentally referencing the frame buffer while the X server is not
 * supposed to touch it.
 *
 * Here, we exchange the pixmap private data, rather than the pixmaps
 * themselves to avoid having to find and change any references to the screen
 * pixmap such as GC's, window privates etc.  This also means that this code
 * does not need to know exactly how the pixmap pixels are accessed.  Further,
 * this exchange is >not< done through the screen's ModifyPixmapHeader()
 * vector.  This means the called frame buffer code layers can determine
 * whether they are switched in or out by keeping track of the root pixmap's
 * private data, and therefore don't need to access pScrnInfo->vtSema.
 */
void
xf86EnableDisableFBAccess(ScrnInfoPtr pScrnInfo, Bool enable)
{
    ScreenPtr pScreen = pScrnInfo->pScreen;

    if (enable) {
        /*
         * Restore all of the clip lists on the screen
         */
        if (!xf86Resetting)
            SetRootClip(pScreen, ROOT_CLIP_FULL);

    }
    else {
        /*
         * Empty all of the clip lists on the screen
         */
        SetRootClip(pScreen, ROOT_CLIP_NONE);
    }
}

/* Print driver messages in the standard format of
   (<type>) <screen name>(<screen index>): <message> */
void
xf86VDrvMsgVerb(int scrnIndex, MessageType type, int verb, const char *format,
                va_list args)
{
    /* Prefix the scrnIndex name to the format string. */
    if (scrnIndex >= 0 && scrnIndex < xf86NumScreens &&
        xf86Screens[scrnIndex]->name)
        LogHdrMessageVerb(type, verb, format, args, "%s(%d): ",
                          xf86Screens[scrnIndex]->name, scrnIndex);
    else if (scrnIndex >= GPU_SCREEN_OFFSET &&
             scrnIndex < GPU_SCREEN_OFFSET + xf86NumGPUScreens &&
             xf86GPUScreens[scrnIndex - GPU_SCREEN_OFFSET]->name)
        LogHdrMessageVerb(type, verb, format, args, "%s(G%d): ",
                          xf86GPUScreens[scrnIndex - GPU_SCREEN_OFFSET]->name, scrnIndex - GPU_SCREEN_OFFSET);
    else
        LogVMessageVerb(type, verb, format, args);
}

/* Print driver messages, with verbose level specified directly */
void
xf86DrvMsgVerb(int scrnIndex, MessageType type, int verb, const char *format,
               ...)
{
    va_list ap;

    va_start(ap, format);
    xf86VDrvMsgVerb(scrnIndex, type, verb, format, ap);
    va_end(ap);
}

/* Print driver messages, with verbose level of 1 (default) */
void
xf86DrvMsg(int scrnIndex, MessageType type, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    xf86VDrvMsgVerb(scrnIndex, type, 1, format, ap);
    va_end(ap);
}

/* Print input driver messages in the standard format of
   (<type>) <driver>: <device name>: <message> */
void
xf86VIDrvMsgVerb(InputInfoPtr dev, MessageType type, int verb,
                 const char *format, va_list args)
{
    const char *driverName = NULL;
    const char *deviceName = NULL;

    /* Prefix driver and device names to formatted message. */
    if (dev) {
        deviceName = dev->name;
        if (dev->drv)
            driverName = dev->drv->driverName;
    }

    LogHdrMessageVerb(type, verb, format, args, "%s: %s: ", driverName,
                      deviceName);
}

/* Print input driver message, with verbose level specified directly */
void
xf86IDrvMsgVerb(InputInfoPtr dev, MessageType type, int verb,
                const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    xf86VIDrvMsgVerb(dev, type, verb, format, ap);
    va_end(ap);
}

/* Print input driver messages, with verbose level of 1 (default) */
void
xf86IDrvMsg(InputInfoPtr dev, MessageType type, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    xf86VIDrvMsgVerb(dev, type, 1, format, ap);
    va_end(ap);
}

/* Print non-driver messages with verbose level specified directly */
void
xf86MsgVerb(MessageType type, int verb, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    LogVMessageVerb(type, verb, format, ap);
    va_end(ap);
}

/* Print non-driver messages with verbose level of 1 (default) */
void
xf86Msg(MessageType type, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    LogVMessageVerb(type, 1, format, ap);
    va_end(ap);
}

/* Just like ErrorF, but with the verbose level checked */
void
xf86ErrorFVerb(int verb, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    if (xf86Verbose >= verb || xf86LogVerbose >= verb)
        LogVWrite(verb, format, ap);
    va_end(ap);
}

/* Like xf86ErrorFVerb, but with an implied verbose level of 1 */
void
xf86ErrorF(const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    if (xf86Verbose >= 1 || xf86LogVerbose >= 1)
        LogVWrite(1, format, ap);
    va_end(ap);
}

/* Note temporarily modifies the passed in buffer! */
static void xf86_mkdir_p(char *path)
{
    char *sep = path;

    while ((sep = strchr(sep + 1, '/'))) {
        *sep = 0;
        (void)mkdir(path, 0777);
        *sep = '/';
    }
    (void)mkdir(path, 0777);
}

void
xf86LogInit(void)
{
    char *env, *lf = NULL;
    char buf[PATH_MAX];

#define LOGSUFFIX ".log"
#define LOGOLDSUFFIX ".old"

    /* Get the log file name */
    if (xf86LogFileFrom == X_DEFAULT) {
        /* When not running as root, we won't be able to write to /var/log */
        if (geteuid() != 0) {
            if ((env = getenv("XDG_DATA_HOME")))
                snprintf(buf, sizeof(buf), "%s/%s", env,
                         DEFAULT_XDG_DATA_HOME_LOGDIR);
            else if ((env = getenv("HOME")))
                snprintf(buf, sizeof(buf), "%s/%s/%s", env,
                         DEFAULT_XDG_DATA_HOME, DEFAULT_XDG_DATA_HOME_LOGDIR);

            if (env) {
                xf86_mkdir_p(buf);
                strlcat(buf, "/" DEFAULT_LOGPREFIX, sizeof(buf));
                xf86LogFile = buf;
            }
        }
        /* Append the display number and ".log" */
        if (asprintf(&lf, "%s%%s" LOGSUFFIX, xf86LogFile) == -1)
            FatalError("Cannot allocate space for the log file name\n");
        xf86LogFile = lf;
    }

    xf86LogFile = LogInit(xf86LogFile, LOGOLDSUFFIX);
    xf86LogFileWasOpened = TRUE;

    xf86SetVerbosity(xf86Verbose);
    xf86SetLogVerbosity(xf86LogVerbose);

#undef LOGSUFFIX
#undef LOGOLDSUFFIX

    free(lf);
}

void
xf86CloseLog(enum ExitCode error)
{
    LogClose(error);
}

/*
 * Drivers can use these for using their own SymTabRecs.
 */

const char *
xf86TokenToString(SymTabPtr table, int token)
{
    int i;

    for (i = 0; table[i].token >= 0 && table[i].token != token; i++);

    if (table[i].token < 0)
        return NULL;
    else
        return table[i].name;
}

int
xf86StringToToken(SymTabPtr table, const char *string)
{
    int i;

    if (string == NULL)
        return -1;

    for (i = 0; table[i].token >= 0 && xf86NameCmp(string, table[i].name); i++);

    return table[i].token;
}

/*
 * helper to display the clocks found on a card
 */
void
xf86ShowClocks(ScrnInfoPtr scrp, MessageType from)
{
    int j;

    xf86DrvMsg(scrp->scrnIndex, from, "Pixel clocks available:");
    for (j = 0; j < scrp->numClocks; j++) {
        if ((j % 4) == 0) {
            xf86ErrorF("\n");
            xf86DrvMsg(scrp->scrnIndex, from, "pixel clocks:");
        }
        xf86ErrorF(" %7.3f", (double) scrp->clock[j] / 1000.0);
    }
    xf86ErrorF("\n");
}

/*
 * This prints out the driver identify message, including the names of
 * the supported chipsets.
 *
 * XXX This makes assumptions about the line width, etc.  Maybe we could
 * use a more general "pretty print" function for messages.
 */
void
xf86PrintChipsets(const char *drvname, const char *drvmsg, SymTabPtr chips)
{
    int len, i;

    len = 6 + strlen(drvname) + 2 + strlen(drvmsg) + 2;
    xf86Msg(X_INFO, "%s: %s:", drvname, drvmsg);
    for (i = 0; chips[i].name != NULL; i++) {
        if (i != 0) {
            xf86ErrorF(",");
            len++;
        }
        if (len + 2 + strlen(chips[i].name) < 78) {
            xf86ErrorF(" ");
            len++;
        }
        else {
            xf86ErrorF("\n\t");
            len = 8;
        }
        xf86ErrorF("%s", chips[i].name);
        len += strlen(chips[i].name);
    }
    xf86ErrorF("\n");
}

int
xf86MatchDevice(const char *drivername, GDevPtr ** sectlist)
{
    GDevPtr gdp, *pgdp = NULL;
    confScreenPtr screensecptr;
    int i, j, k;

    if (sectlist)
        *sectlist = NULL;

    /*
     * This can happen when running Xorg -showopts and a module like ati
     * or vmware tries to load its submodules when xf86ConfigLayout is empty
     */
    if (!xf86ConfigLayout.screens)
        return 0;

    /*
     * This is a very important function that matches the device sections
     * as they show up in the config file with the drivers that the server
     * loads at run time.
     *
     * ChipProbe can call
     * int xf86MatchDevice(char * drivername, GDevPtr ** sectlist)
     * with its driver name. The function allocates an array of GDevPtr and
     * returns this via sectlist and returns the number of elements in
     * this list as return value. 0 means none found, -1 means fatal error.
     *
     * It can figure out which of the Device sections to use for which card
     * (using things like the Card statement, etc). For single headed servers
     * there will of course be just one such Device section.
     */
    i = 0;

    /*
     * first we need to loop over all the Screens sections to get to all
     * 'active' device sections
     */
    for (j = 0; xf86ConfigLayout.screens[j].screen != NULL; j++) {
        screensecptr = xf86ConfigLayout.screens[j].screen;
        if ((screensecptr->device->driver != NULL)
            && (xf86NameCmp(screensecptr->device->driver, drivername) == 0)
            && (!screensecptr->device->claimed)) {
            /*
             * we have a matching driver that wasn't claimed, yet
             */
            pgdp = xnfreallocarray(pgdp, i + 2, sizeof(GDevPtr));
            pgdp[i++] = screensecptr->device;
        }
        for (k = 0; k < screensecptr->num_gpu_devices; k++) {
            if ((screensecptr->gpu_devices[k]->driver != NULL)
            && (xf86NameCmp(screensecptr->gpu_devices[k]->driver, drivername) == 0)
                && (!screensecptr->gpu_devices[k]->claimed)) {
                /*
                 * we have a matching driver that wasn't claimed, yet
                 */
                pgdp = xnfrealloc(pgdp, (i + 2) * sizeof(GDevPtr));
                pgdp[i++] = screensecptr->gpu_devices[k];
            }
        }
    }

    /* Then handle the inactive devices */
    j = 0;
    while (xf86ConfigLayout.inactives[j].identifier) {
        gdp = &xf86ConfigLayout.inactives[j];
        if (gdp->driver && !gdp->claimed &&
            !xf86NameCmp(gdp->driver, drivername)) {
            /* we have a matching driver that wasn't claimed yet */
            pgdp = xnfreallocarray(pgdp, i + 2, sizeof(GDevPtr));
            pgdp[i++] = gdp;
        }
        j++;
    }

    /*
     * make the array NULL terminated and return its address
     */
    if (i)
        pgdp[i] = NULL;

    if (sectlist)
        *sectlist = pgdp;
    else
        free(pgdp);
    return i;
}

const char *
xf86GetVisualName(int visual)
{
    if (visual < 0 || visual > DirectColor)
        return NULL;

    return xf86VisualNames[visual];
}

int
xf86GetVerbosity(void)
{
    return max(xf86Verbose, xf86LogVerbose);
}

Pix24Flags
xf86GetPix24(void)
{
    return xf86Info.pixmap24;
}

int
xf86GetDepth(void)
{
    return xf86Depth;
}

rgb
xf86GetWeight(void)
{
    return xf86Weight;
}

Gamma
xf86GetGamma(void)
{
    return xf86Gamma;
}

Bool
xf86GetFlipPixels(void)
{
    return xf86FlipPixels;
}

const char *
xf86GetServerName(void)
{
    return xf86ServerName;
}

Bool
xf86ServerIsExiting(void)
{
    return (dispatchException & DE_TERMINATE) == DE_TERMINATE;
}

Bool
xf86ServerIsResetting(void)
{
    return xf86Resetting;
}

Bool
xf86ServerIsInitialising(void)
{
    return xf86Initialising;
}

Bool
xf86ServerIsOnlyDetecting(void)
{
    return xf86DoConfigure;
}

Bool
xf86CaughtSignal(void)
{
    return xf86Info.caughtSignal;
}

Bool
xf86GetVidModeAllowNonLocal(void)
{
    return xf86Info.vidModeAllowNonLocal;
}

Bool
xf86GetVidModeEnabled(void)
{
    return xf86Info.vidModeEnabled;
}

Bool
xf86GetModInDevAllowNonLocal(void)
{
    return xf86Info.miscModInDevAllowNonLocal;
}

Bool
xf86GetModInDevEnabled(void)
{
    return xf86Info.miscModInDevEnabled;
}

Bool
xf86GetAllowMouseOpenFail(void)
{
    return xf86Info.allowMouseOpenFail;
}

void
xf86DisableRandR(void)
{
    xf86Info.disableRandR = TRUE;
    xf86Info.randRFrom = X_PROBED;
}

CARD32
xf86GetModuleVersion(void *module)
{
    return (CARD32) LoaderGetModuleVersion(module);
}

void *
xf86LoadDrvSubModule(DriverPtr drv, const char *name)
{
    void *ret;
    int errmaj = 0, errmin = 0;

    ret = LoadSubModule(drv->module, name, NULL, NULL, NULL, NULL,
                        &errmaj, &errmin);
    if (!ret)
        LoaderErrorMsg(NULL, name, errmaj, errmin);
    return ret;
}

void *
xf86LoadSubModule(ScrnInfoPtr pScrn, const char *name)
{
    void *ret;
    int errmaj = 0, errmin = 0;

    ret = LoadSubModule(pScrn->module, name, NULL, NULL, NULL, NULL,
                        &errmaj, &errmin);
    if (!ret)
        LoaderErrorMsg(pScrn->name, name, errmaj, errmin);
    return ret;
}

/*
 * xf86LoadOneModule loads a single module.
 */
void *
xf86LoadOneModule(const char *name, void *opt)
{
    int errmaj, errmin;
    char *Name;
    void *mod;

    if (!name)
        return NULL;

    /* Normalise the module name */
    Name = xf86NormalizeName(name);

    /* Skip empty names */
    if (Name == NULL)
        return NULL;
    if (*Name == '\0') {
        free(Name);
        return NULL;
    }

    mod = LoadModule(Name, NULL, NULL, NULL, opt, NULL, &errmaj, &errmin);
    if (!mod)
        LoaderErrorMsg(NULL, Name, errmaj, errmin);
    free(Name);
    return mod;
}

void
xf86UnloadSubModule(void *mod)
{
    UnloadSubModule(mod);
}

Bool
xf86LoaderCheckSymbol(const char *name)
{
    return LoaderSymbol(name) != NULL;
}

typedef enum {
    OPTION_BACKING_STORE
} BSOpts;

static const OptionInfoRec BSOptions[] = {
    {OPTION_BACKING_STORE, "BackingStore", OPTV_BOOLEAN, {0}, FALSE},
    {-1, NULL, OPTV_NONE, {0}, FALSE}
};

void
xf86SetBackingStore(ScreenPtr pScreen)
{
    Bool useBS = FALSE;
    MessageType from = X_DEFAULT;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    OptionInfoPtr options;

    options = xnfalloc(sizeof(BSOptions));
    (void) memcpy(options, BSOptions, sizeof(BSOptions));
    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, options);

    /* check for commandline option here */
    if (xf86bsEnableFlag) {
        from = X_CMDLINE;
        useBS = TRUE;
    }
    else if (xf86bsDisableFlag) {
        from = X_CMDLINE;
        useBS = FALSE;
    }
    else {
        if (xf86GetOptValBool(options, OPTION_BACKING_STORE, &useBS))
            from = X_CONFIG;
#ifdef COMPOSITE
        if (from != X_CONFIG)
            useBS = xf86ReturnOptValBool(options, OPTION_BACKING_STORE,
                                         !noCompositeExtension);
#endif
    }
    free(options);
    pScreen->backingStoreSupport = useBS ? WhenMapped : NotUseful;
    if (serverGeneration == 1)
        xf86DrvMsg(pScreen->myNum, from, "Backing store %s\n",
                   useBS ? "enabled" : "disabled");
}

typedef enum {
    OPTION_SILKEN_MOUSE
} SMOpts;

static const OptionInfoRec SMOptions[] = {
    {OPTION_SILKEN_MOUSE, "SilkenMouse", OPTV_BOOLEAN, {0}, FALSE},
    {-1, NULL, OPTV_NONE, {0}, FALSE}
};

void
xf86SetSilkenMouse(ScreenPtr pScreen)
{
    Bool useSM = TRUE;
    MessageType from = X_DEFAULT;
    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
    OptionInfoPtr options;

    options = xnfalloc(sizeof(SMOptions));
    (void) memcpy(options, SMOptions, sizeof(SMOptions));
    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, options);

    /* check for commandline option here */
    /* disable if screen shares resources */
    /* TODO VGA arb disable silken mouse */
    if (xf86silkenMouseDisableFlag) {
        from = X_CMDLINE;
        useSM = FALSE;
    }
    else {
        if (xf86GetOptValBool(options, OPTION_SILKEN_MOUSE, &useSM))
            from = X_CONFIG;
    }
    free(options);
    /*
     * XXX quick hack to report correctly for OSs that can't do SilkenMouse
     * yet.  Should handle this differently so that alternate async methods
     * work correctly with this too.
     */
    pScrn->silkenMouse = useSM && xf86Info.useSIGIO && xf86SIGIOSupported();
    if (serverGeneration == 1)
        xf86DrvMsg(pScreen->myNum, from, "Silken mouse %s\n",
                   pScrn->silkenMouse ? "enabled" : "disabled");
}

/* Wrote this function for the PM2 Xv driver, preliminary. */

void *
xf86FindXvOptions(ScrnInfoPtr pScrn, int adaptor_index, const char *port_name,
                  const char **adaptor_name, void **adaptor_options)
{
    confXvAdaptorPtr adaptor;
    int i;

    if (adaptor_index >= pScrn->confScreen->numxvadaptors) {
        if (adaptor_name)
            *adaptor_name = NULL;
        if (adaptor_options)
            *adaptor_options = NULL;
        return NULL;
    }

    adaptor = &pScrn->confScreen->xvadaptors[adaptor_index];
    if (adaptor_name)
        *adaptor_name = adaptor->identifier;
    if (adaptor_options)
        *adaptor_options = adaptor->options;

    for (i = 0; i < adaptor->numports; i++)
        if (!xf86NameCmp(adaptor->ports[i].identifier, port_name))
            return adaptor->ports[i].options;

    return NULL;
}

/* Rather than duplicate loader's get OS function, just include it directly */
#define LoaderGetOS xf86GetOS
#include "loader/os.c"

static void
xf86ConfigFbEntityInactive(EntityInfoPtr pEnt, EntityProc init,
                           EntityProc enter, EntityProc leave, void *private)
{
    ScrnInfoPtr pScrn;

    if ((pScrn = xf86FindScreenForEntity(pEnt->index)))
        xf86RemoveEntityFromScreen(pScrn, pEnt->index);
    xf86SetEntityFuncs(pEnt->index, init, enter, leave, private);
}

ScrnInfoPtr
xf86ConfigFbEntity(ScrnInfoPtr pScrn, int scrnFlag, int entityIndex,
                   EntityProc init, EntityProc enter, EntityProc leave,
                   void *private)
{
    EntityInfoPtr pEnt = xf86GetEntityInfo(entityIndex);

    if (!pEnt)
        return pScrn;

    if (!(pEnt->location.type == BUS_NONE)) {
        free(pEnt);
        return pScrn;
    }

    if (!pEnt->active) {
        xf86ConfigFbEntityInactive(pEnt, init, enter, leave, private);
        free(pEnt);
        return pScrn;
    }

    if (!pScrn)
        pScrn = xf86AllocateScreen(pEnt->driver, scrnFlag);
    xf86AddEntityToScreen(pScrn, entityIndex);

    xf86SetEntityFuncs(entityIndex, init, enter, leave, private);

    free(pEnt);
    return pScrn;
}

Bool
xf86IsScreenPrimary(ScrnInfoPtr pScrn)
{
    int i;

    for (i = 0; i < pScrn->numEntities; i++) {
        if (xf86IsEntityPrimary(i))
            return TRUE;
    }
    return FALSE;
}

int
xf86RegisterRootWindowProperty(int ScrnIndex, Atom property, Atom type,
                               int format, unsigned long len, void *value)
{
    RootWinPropPtr pNewProp = NULL, pRegProp;
    Bool existing = FALSE;

    DebugF("xf86RegisterRootWindowProperty(%d, %ld, %ld, %d, %ld, %p)\n",
           ScrnIndex, (long)property, (long)type, format, len, value);

    if (ScrnIndex < 0 || ScrnIndex >= xf86NumScreens) {
        return BadMatch;
    }

    if (xf86RegisteredPropertiesTable &&
        xf86RegisteredPropertiesTable[ScrnIndex]) {
        for (pNewProp = xf86RegisteredPropertiesTable[ScrnIndex];
             pNewProp; pNewProp = pNewProp->next) {
            if (strcmp(pNewProp->name, NameForAtom(property)) == 0)
                break;
        }
    }

    if (!pNewProp) {
        if ((pNewProp = (RootWinPropPtr) malloc(sizeof(RootWinProp))) == NULL) {
            return BadAlloc;
        }
        /*
         * We will put this property at the end of the list so that
         * the changes are made in the order they were requested.
         */
        pNewProp->next = NULL;
    }
    else {
        free((void *) pNewProp->name);
        existing = TRUE;
    }

    pNewProp->name = xnfstrdup(NameForAtom(property));
    pNewProp->type = type;
    pNewProp->format = format;
    pNewProp->size = len;
    pNewProp->data = value;

    DebugF("new property filled\n");

    if (xf86RegisteredPropertiesTable == NULL) {
        DebugF("creating xf86RegisteredPropertiesTable[] size %d\n",
               xf86NumScreens);
        xf86RegisteredPropertiesTable =
            xnfcalloc(sizeof(RootWinProp), xf86NumScreens);
    }

    DebugF("xf86RegisteredPropertiesTable %p\n",
           (void *) xf86RegisteredPropertiesTable);
    DebugF("xf86RegisteredPropertiesTable[%d] %p\n",
           ScrnIndex, (void *) xf86RegisteredPropertiesTable[ScrnIndex]);

    if (!existing) {
        if (xf86RegisteredPropertiesTable[ScrnIndex] == NULL) {
            xf86RegisteredPropertiesTable[ScrnIndex] = pNewProp;
        }
        else {
            pRegProp = xf86RegisteredPropertiesTable[ScrnIndex];
            while (pRegProp->next != NULL) {
                DebugF("- next %p\n", (void *) pRegProp);
                pRegProp = pRegProp->next;
            }
            pRegProp->next = pNewProp;
        }
    }
    DebugF("xf86RegisterRootWindowProperty succeeded\n");
    return Success;
}

Bool
xf86IsUnblank(int mode)
{
    switch (mode) {
    case SCREEN_SAVER_OFF:
    case SCREEN_SAVER_FORCER:
        return TRUE;
    case SCREEN_SAVER_ON:
    case SCREEN_SAVER_CYCLE:
        return FALSE;
    default:
        xf86MsgVerb(X_WARNING, 0, "Unexpected save screen mode: %d\n", mode);
        return TRUE;
    }
}

void
xf86MotionHistoryAllocate(InputInfoPtr pInfo)
{
    AllocateMotionHistory(pInfo->dev);
}

ScrnInfoPtr
xf86ScreenToScrn(ScreenPtr pScreen)
{
    if (pScreen->isGPU) {
        assert(pScreen->myNum - GPU_SCREEN_OFFSET < xf86NumGPUScreens);
        return xf86GPUScreens[pScreen->myNum - GPU_SCREEN_OFFSET];
    } else {
        assert(pScreen->myNum < xf86NumScreens);
        return xf86Screens[pScreen->myNum];
    }
}

ScreenPtr
xf86ScrnToScreen(ScrnInfoPtr pScrn)
{
    if (pScrn->is_gpu) {
        assert(pScrn->scrnIndex - GPU_SCREEN_OFFSET < screenInfo.numGPUScreens);
        return screenInfo.gpuscreens[pScrn->scrnIndex - GPU_SCREEN_OFFSET];
    } else {
        assert(pScrn->scrnIndex < screenInfo.numScreens);
        return screenInfo.screens[pScrn->scrnIndex];
    }
}

void
xf86UpdateDesktopDimensions(void)
{
    update_desktop_dimensions();
}
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d80 2
a81 2
    xf86DriverList = xnfrealloc(xf86DriverList,
                                xf86NumDrivers * sizeof(DriverPtr));
d120 3
a122 3
    xf86InputDriverList = xnfrealloc(xf86InputDriverList,
                                     xf86NumInputDrivers *
                                     sizeof(InputDriverPtr));
d176 2
a177 1
        xf86GPUScreens = xnfrealloc(xf86GPUScreens, xf86NumGPUScreens * sizeof(ScrnInfoPtr));
d187 2
a188 1
        xf86Screens = xnfrealloc(xf86Screens, xf86NumScreens * sizeof(ScrnInfoPtr));
d298 2
a299 2
        nprivs = xnfrealloc(pScr->privates,
                            xf86ScrnInfoPrivateCount * sizeof(DevUnion));
d306 2
a307 2
        nprivs = xnfrealloc(pScr->privates,
                            xf86ScrnInfoPrivateCount * sizeof(DevUnion));
d641 2
a642 2
            xnfrealloc(scrp->confScreen->displays,
                       scrp->confScreen->numdisplays * sizeof(DispRec));
d1079 1
a1079 1
            SetRootClip(pScreen, TRUE);
d1086 1
a1086 1
        SetRootClip(pScreen, FALSE);
d1372 1
a1372 1
    int i, j;
d1413 1
a1413 1
            pgdp = xnfrealloc(pgdp, (i + 2) * sizeof(GDevPtr));
d1416 11
d1436 1
a1436 1
            pgdp = xnfrealloc(pgdp, (i + 2) * sizeof(GDevPtr));
d1834 1
a1834 1
           ScrnIndex, property, type, format, len, value);
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d70 1
a70 1
xf86AddDriver(DriverPtr driver, pointer module, int flags)
d110 1
a110 1
xf86AddInputDriver(InputDriverPtr driver, pointer module, int flags)
a424 1
            int i;
a1070 1
    PixmapPtr pspix;
a1071 1
    pspix = (*pScreen->GetScreenPixmap) (pScreen);
d1220 13
d1236 2
a1237 1
    char *lf = NULL;
d1244 15
d1561 1
a1561 1
xf86GetModuleVersion(pointer module)
d1566 1
a1566 1
pointer
d1569 1
a1569 1
    pointer ret;
d1579 1
a1579 1
pointer
d1582 1
a1582 1
    pointer ret;
d1595 2
a1596 2
pointer
xf86LoadOneModule(char *name, pointer opt)
d1600 1
a1600 1
    pointer mod;
d1624 1
a1624 1
xf86UnloadSubModule(pointer mod)
d1727 3
a1729 3
pointer
xf86FindXvOptions(ScrnInfoPtr pScrn, int adaptor_index, char *port_name,
                  char **adaptor_name, pointer *adaptor_options)
d1761 1
a1761 1
                           EntityProc enter, EntityProc leave, pointer private)
d1773 1
a1773 1
                   pointer private)
d1815 1
a1815 1
                               int format, unsigned long len, pointer value)
d1847 1
a1847 1
        free(pNewProp->name);
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d220 4
a234 3
    if (!pScrn)
        return;

d1642 5
d1649 1
a1649 1
    pScreen->backingStoreSupport = useBS ? Always : NotUseful;
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d170 19
d190 2
a191 2
    if (xf86Screens == NULL)
        xf86NumScreens = 0;
d193 2
a194 7
    i = xf86NumScreens++;
    xf86Screens = xnfrealloc(xf86Screens, xf86NumScreens * sizeof(ScrnInfoPtr));
    xf86Screens[i] = xnfcalloc(sizeof(ScrnInfoRec), 1);
    xf86Screens[i]->scrnIndex = i;      /* Changes when a screen is removed */
    xf86Screens[i]->origIndex = i;      /* This never changes */
    xf86Screens[i]->privates = xnfcalloc(sizeof(DevUnion),
                                         xf86ScrnInfoPrivateCount);
d197 1
a197 1
     * xf86Screens[i]->EnableDisableFBAccess = xf86EnableDisableFBAccess;
d200 1
a200 1
    xf86Screens[i]->drv = drv;
d202 1
a202 1
    xf86Screens[i]->module = DuplicateModule(drv->module, NULL);
d204 1
a204 1
    xf86Screens[i]->DriverFunc = drv->driverFunc;
d206 1
a206 1
    return xf86Screens[i];
d215 1
a215 1
xf86DeleteScreen(int scrnIndex, int flags)
a216 1
    ScrnInfoPtr pScrn;
d218 12
d231 1
a231 8
    /* First check if the screen is valid */
    if (xf86NumScreens == 0 || xf86Screens == NULL)
        return;

    if (scrnIndex > xf86NumScreens - 1)
        return;

    if (!(pScrn = xf86Screens[scrnIndex]))
d234 1
d237 1
a237 1
        pScrn->FreeScreen(scrnIndex, 0);
d255 1
a255 1
    xf86ClearEntityListForScreen(scrnIndex);
d261 11
a271 1
    xf86NumScreens--;
d273 5
a277 4
    for (i = scrnIndex; i < xf86NumScreens; i++) {
        xf86Screens[i] = xf86Screens[i + 1];
        xf86Screens[i]->scrnIndex = i;
        /* Also need to take care of the screen layout settings */
d301 8
d1068 1
a1068 1
xf86EnableDisableFBAccess(int scrnIndex, Bool enable)
a1069 1
    ScrnInfoPtr pScrnInfo = xf86Screens[scrnIndex];
d1101 5
d1622 1
a1622 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1663 1
a1663 1
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
d1696 1
a1696 1
xf86FindXvOptions(int scrnIndex, int adaptor_index, char *port_name,
a1698 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1770 1
a1770 1
xf86IsScreenPrimary(int scrnIndex)
a1771 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d1876 30
@


1.7
log
@Update to xserver 1.11.2
@
text
@a66 1

d74 1
a74 1
	return;
d77 1
a77 1
	xf86NumDrivers = 0;
d81 1
a81 1
				xf86NumDrivers * sizeof(DriverPtr));
d84 1
a84 1
	*xf86DriverList[xf86NumDrivers - 1] = *driver;
d86 3
a88 4
	(void) memset( xf86DriverList[xf86NumDrivers - 1], 0,
		       sizeof( DriverRec ) );
	(void) memcpy( xf86DriverList[xf86NumDrivers - 1], driver,
		       sizeof(DriverRec1));
d99 5
a103 5
	&& (!xf86DriverHasEntities(xf86DriverList[drvIndex]))) {
	if (xf86DriverList[drvIndex]->module)
	    UnloadModule(xf86DriverList[drvIndex]->module);
	free(xf86DriverList[drvIndex]);
	xf86DriverList[drvIndex] = NULL;
d114 1
a114 1
	return;
d117 1
a117 1
	xf86NumInputDrivers = 0;
d121 2
a122 1
				xf86NumInputDrivers * sizeof(InputDriverPtr));
d124 1
a124 1
				xnfalloc(sizeof(InputDriverRec));
d133 1
a133 1
	UnloadModule(xf86InputDriverList[drvIndex]->module);
d144 3
a146 3
       if (xf86InputDriverList[i] && xf86InputDriverList[i]->driverName &&
           xf86NameCmp(name, xf86InputDriverList[i]->driverName) == 0)
           return xf86InputDriverList[i];
d172 1
a172 1
	xf86NumScreens = 0;
d177 2
a178 2
    xf86Screens[i]->scrnIndex = i;	/* Changes when a screen is removed */
    xf86Screens[i]->origIndex = i;	/* This never changes */
d180 1
a180 1
					 xf86ScrnInfoPrivateCount);
a194 1

d208 1
a208 1
	return;
d211 1
a211 1
	return;
d214 1
a214 1
	return;
d218 1
a218 1
	pScrn->FreeScreen(scrnIndex, 0);
d221 1
a221 1
	xf86DeleteMode(&pScrn->modes, pScrn->modes);
d224 1
a224 1
	xf86DeleteMode(&pScrn->modePool, pScrn->modePool);
d229 1
a229 1
	UnloadModule(pScrn->module);
d232 1
a232 1
	pScrn->drv->refCount--;
d245 3
a247 3
	xf86Screens[i] = xf86Screens[i + 1];
	xf86Screens[i]->scrnIndex = i;
	/* Also need to take care of the screen layout settings */
d264 6
a269 6
	pScr = xf86Screens[i];
	nprivs = xnfrealloc(pScr->privates,
			    xf86ScrnInfoPrivateCount * sizeof(DevUnion));
	/* Zero the new private */
	memset(&nprivs[idx], 0, sizeof(DevUnion));
	pScr->privates = nprivs;
d280 1
a280 1
	return FALSE;
d283 10
a292 10
	if (depth == 1)
	    bpp = 1;
	else if (depth <= 8)
	    bpp = 8;
	else if (depth <= 16)
	    bpp = 16;
	else if (depth <= 32)
	    bpp = 32;
	else
	    return FALSE;
d295 1
a295 1
	pad = BITMAP_SCANLINE_PAD;
d347 1
a347 1
		int depth24flags)
d361 2
a362 2
	scrp->bitsPerPixel = xf86FbBpp;
	scrp->bitsPerPixelFrom = X_CMDLINE;
d366 2
a367 2
	scrp->depth = xf86Depth;
	scrp->depthFrom = X_CMDLINE;
d371 41
a411 41
	if (scrp->confScreen->defaultfbbpp > 0) {
	    scrp->bitsPerPixel = scrp->confScreen->defaultfbbpp;
	    scrp->bitsPerPixelFrom = X_CONFIG;
	}
	if (scrp->confScreen->defaultdepth > 0) {
	    scrp->depth = scrp->confScreen->defaultdepth;
	    scrp->depthFrom = X_CONFIG;
	}

	if (scrp->confScreen->defaultfbbpp <= 0 &&
	    scrp->confScreen->defaultdepth <= 0) {
	    /*
	     * Check for DefaultDepth and DefaultFbBpp options in the
	     * Device sections.
	     */
	    int i;
	    GDevPtr device;
	    Bool found = FALSE;

	    for (i = 0; i < scrp->numEntities; i++) {
		device = xf86GetDevFromEntity(scrp->entityList[i],
					      scrp->entityInstanceList[i]);
		if (device && device->options) {
		    if (xf86FindOption(device->options, "DefaultDepth")) {
			scrp->depth = xf86SetIntOption(device->options,
						       "DefaultDepth", -1);
			scrp->depthFrom = X_CONFIG;
			found = TRUE;
		    }
		    if (xf86FindOption(device->options, "DefaultFbBpp")) {
			scrp->bitsPerPixel = xf86SetIntOption(device->options,
							      "DefaultFbBpp",
							      -1);
			scrp->bitsPerPixelFrom = X_CONFIG;
			found = TRUE;
		    }
		}
		if (found)
		    break;
	    }
	}
d417 8
a424 7
	    if (fbbpp > 0)
		scrp->bitsPerPixel = fbbpp;
	    if (depth > 0)
		scrp->depth = depth;
	} else {
	    scrp->depth = GLOBAL_DEFAULT_DEPTH;
	}
d430 85
a514 78
	/* The depth must be set */
	if (scrp->depth > -1) {
	    if (scrp->depth == 1)
		scrp->bitsPerPixel = 1;
	    else if (scrp->depth <= 4)
		scrp->bitsPerPixel = 4;
	    else if (scrp->depth <= 8)
		scrp->bitsPerPixel = 8;
	    else if (scrp->depth <= 16)
		scrp->bitsPerPixel = 16;
	    else if (scrp->depth <= 24) {
		/*
		 * Figure out if a choice is possible based on the depth24
		 * and pix24 flags.
		 */
		/* Check pix24 first */
		if (pix24 != Pix24DontCare) {
		    if (pix24 == Pix24Use32) {
			if (DO_PIX32(depth24flags)) {
			    if (CHOOSE24FOR32(depth24flags))
				scrp->bitsPerPixel = 24;
			    else
				scrp->bitsPerPixel = 32;
			} else {
			    nomatch = TRUE;
			}
		    } else if (pix24 == Pix24Use24) {
			if (DO_PIX24(depth24flags)) {
			    if (CHOOSE32FOR24(depth24flags))
				scrp->bitsPerPixel = 32;
			    else
				scrp->bitsPerPixel = 24;
			} else {
			    nomatch = TRUE;
			}
		    }
		} else {
		    if (DO_PIX32(depth24flags)) {
			if (CHOOSE24FOR32(depth24flags))
			    scrp->bitsPerPixel = 24;
			else
			    scrp->bitsPerPixel = 32;
		    } else if (DO_PIX24(depth24flags)) {
			if (CHOOSE32FOR24(depth24flags))
			    scrp->bitsPerPixel = 32;
			else
			    scrp->bitsPerPixel = 24;
		    }
		}
	    } else if (scrp->depth <= 32)
		scrp->bitsPerPixel = 32;
	    else {
		xf86DrvMsg(scrp->scrnIndex, X_ERROR,
			   "Specified depth (%d) is greater than 32\n",
			   scrp->depth);
		return FALSE;
	    }
	} else {
	    xf86DrvMsg(scrp->scrnIndex, X_ERROR,
			"xf86SetDepthBpp: internal error: depth and fbbpp"
			" are both not set\n");
	    return FALSE;
	}
	if (scrp->bitsPerPixel < 0) {
	    if (nomatch)
		xf86DrvMsg(scrp->scrnIndex, X_ERROR,
			"Driver can't support depth 24 pixmap format (%d)\n",
			PIX24TOBPP(pix24));
	    else if ((depth24flags & (Support24bppFb | Support32bppFb)) ==
		     NoDepth24Support)
		xf86DrvMsg(scrp->scrnIndex, X_ERROR,
			"Driver can't support depth 24\n");
	    else
		xf86DrvMsg(scrp->scrnIndex, X_ERROR,
			"Can't find fbbpp for depth 24\n");
	    return FALSE;
	}
	scrp->bitsPerPixelFrom = X_PROBED;
d518 11
a528 11
	/* bitsPerPixel is already set */
	switch (scrp->bitsPerPixel) {
	case 32:
	    scrp->depth = 24;
	    break;
	default:
	    /* 1, 4, 8, 16 and 24 */
	    scrp->depth = scrp->bitsPerPixel;
	    break;
	}
	scrp->depthFrom = X_PROBED;
d533 4
a536 4
	xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		   "Specified depth (%d) is not in the range 1-32\n",
		    scrp->depth);
	return FALSE;
d545 1
a545 1
	break;
d547 4
a550 4
	xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		   "Specified fbbpp (%d) is not a permitted value\n",
		   scrp->bitsPerPixel);
	return FALSE;
d553 4
a556 4
	xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		   "Specified depth (%d) is greater than the fbbpp (%d)\n",
		   scrp->depth, scrp->bitsPerPixel);
	return FALSE;
d561 1
a561 1
	scrp->pixmap24 = Pix24Use24;
d564 1
a564 1
	scrp->pixmap24 = Pix24Use32;
d572 7
a578 7
	 i < scrp->confScreen->numdisplays; i++, disp++) {
	if ((disp->depth == scrp->depth && disp->fbbpp == scrp->bitsPerPixel)
	    || (disp->depth == scrp->depth && disp->fbbpp <= 0)
	    || (disp->fbbpp == scrp->bitsPerPixel && disp->depth <= 0)) {
	    scrp->display = disp;
	    break;
	}
d586 7
a592 7
	for (i = 0, disp = scrp->confScreen->displays;
	     i < scrp->confScreen->numdisplays; i++, disp++) {
	    if (disp->depth <= 0 && disp->fbbpp <= 0) {
		scrp->display = disp;
		break;
	    }
	}
d599 21
a619 21
	scrp->confScreen->numdisplays++;
	scrp->confScreen->displays =
		xnfrealloc(scrp->confScreen->displays,
			   scrp->confScreen->numdisplays * sizeof(DispRec));
	xf86DrvMsg(scrp->scrnIndex, X_INFO,
		   "Creating default Display subsection in Screen section\n"
		   "\t\"%s\" for depth/fbbpp %d/%d\n",
		   scrp->confScreen->id, scrp->depth, scrp->bitsPerPixel);
	memset(&scrp->confScreen->displays[i], 0, sizeof(DispRec));
	scrp->confScreen->displays[i].blackColour.red = -1;
	scrp->confScreen->displays[i].blackColour.green = -1;
	scrp->confScreen->displays[i].blackColour.blue = -1;
	scrp->confScreen->displays[i].whiteColour.red = -1;
	scrp->confScreen->displays[i].whiteColour.green = -1;
	scrp->confScreen->displays[i].whiteColour.blue = -1;
	scrp->confScreen->displays[i].defaultVisual = -1;
	scrp->confScreen->displays[i].modes = xnfalloc(sizeof(char *));
	scrp->confScreen->displays[i].modes[0] = NULL;
	scrp->confScreen->displays[i].depth = depth;
	scrp->confScreen->displays[i].fbbpp = fbbpp;
	scrp->display = &scrp->confScreen->displays[i];
d630 7
a636 6
	/* Planar modes need these settings */
	scrp->bitmapScanlineUnit = 8;
	scrp->bitmapBitOrder = MSBFirst;
    } else {
	scrp->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
	scrp->bitmapBitOrder = BITMAP_BIT_ORDER;
d650 2
a651 2
	/* Common depths.  Nothing to do for them */
	break;
d653 5
a657 5
	if (!xf86AddPixFormat(scrp, scrp->depth, 0, 0)) {
	    xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		       "Can't add pixmap format for depth %d\n", scrp->depth);
	    return FALSE;
	}
d692 36
a727 33
	scrp->weight = xf86Weight;
	weightFrom = X_CMDLINE;
    } else if (scrp->display->weight.red > 0 && scrp->display->weight.green > 0
	       && scrp->display->weight.blue > 0) {
	scrp->weight = scrp->display->weight;
	weightFrom = X_CONFIG;
    } else if (weight.red > 0 && weight.green > 0 && weight.blue > 0) {
	scrp->weight = weight;
    } else {
	switch (scrp->depth) {
	case 1:
	case 4:
	case 8:
	    scrp->weight.red = scrp->weight.green =
		scrp->weight.blue = scrp->rgbBits;
	    break;
	case 15:
	    scrp->weight.red = scrp->weight.green = scrp->weight.blue = 5;
	    break;
	case 16:
	    scrp->weight.red = scrp->weight.blue = 5;
	    scrp->weight.green = 6;
	    break;
	case 18:
	    scrp->weight.red = scrp->weight.green = scrp->weight.blue = 6;
	    break;
	case 24:
	    scrp->weight.red = scrp->weight.green = scrp->weight.blue = 8;
	    break;
	case 30:
	    scrp->weight.red = scrp->weight.green = scrp->weight.blue = 10;
	    break;
	}
d731 3
a733 3
	xf86DrvMsg(scrp->scrnIndex, weightFrom, "RGB weight %d%d%d\n",
		   (int)scrp->weight.red, (int)scrp->weight.green,
		   (int)scrp->weight.blue);
d736 8
a743 8
	(scrp->depth != scrp->weight.red + scrp->weight.green +
			scrp->weight.blue)) {
	xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		   "Weight given (%d%d%d) is inconsistent with the "
		   "depth (%d)\n",
		   (int)scrp->weight.red, (int)scrp->weight.green,
		   (int)scrp->weight.blue, scrp->depth);
	return FALSE;
d746 10
a755 10
	/*
	 * XXX Does this even mean anything for TrueColor visuals?
	 * If not, we shouldn't even be setting it here.  However, this
	 * matches the behaviour of 3.x versions of XFree86.
	 */
	scrp->rgbBits = scrp->weight.red;
	if (scrp->weight.green > scrp->rgbBits)
	    scrp->rgbBits = scrp->weight.green;
	if (scrp->weight.blue > scrp->rgbBits)
	    scrp->rgbBits = scrp->weight.blue;
d760 17
a776 16
	/* Default to a setting common to PC hardware */
	scrp->offset.red = scrp->weight.green + scrp->weight.blue;
	scrp->offset.green = scrp->weight.blue;
	scrp->offset.blue = 0;
	scrp->mask.red = ((1 << scrp->weight.red) - 1) << scrp->offset.red;
	scrp->mask.green = ((1 << scrp->weight.green) - 1)
				<< scrp->offset.green;
	scrp->mask.blue = (1 << scrp->weight.blue) - 1;
    } else {
	/* Initialise to the values passed */
	scrp->mask.red = mask.red;
	scrp->mask.green = mask.green;
	scrp->mask.blue = mask.blue;
	scrp->offset.red = ffs(mask.red);
	scrp->offset.green = ffs(mask.green);
	scrp->offset.blue = ffs(mask.blue);
d787 19
a805 16
	scrp->defaultVisual = defaultColorVisualClass;
	visualFrom = X_CMDLINE;
    } else if (scrp->display->defaultVisual >= 0) {
	scrp->defaultVisual = scrp->display->defaultVisual;
	visualFrom = X_CONFIG;
    } else if (visual >= 0) {
	scrp->defaultVisual = visual;
    } else {
	if (scrp->depth == 1)
	    scrp->defaultVisual = StaticGray;
	else if (scrp->depth == 4)
	    scrp->defaultVisual = StaticColor;
	else if (scrp->depth <= MAX_PSEUDO_DEPTH)
	    scrp->defaultVisual = PseudoColor;
	else
	    scrp->defaultVisual = TrueColor;
d814 3
a816 3
	xf86DrvMsg(scrp->scrnIndex, visualFrom, "Default visual is %s\n",
		   xf86VisualNames[scrp->defaultVisual]);
	    return TRUE;
d819 3
a821 3
	xf86DrvMsg(scrp->scrnIndex, X_ERROR,
		   "Invalid default visual class (%d)\n", scrp->defaultVisual);
	return FALSE;
d835 1
d837 1
a837 1
    xf86MonPtr DDC = (xf86MonPtr)(scrp->monitor->DDC);
d840 10
a849 9
	from = X_CMDLINE;
	scrp->gamma.red = SET_GAMMA(xf86Gamma.red);
	scrp->gamma.green = SET_GAMMA(xf86Gamma.green);
	scrp->gamma.blue = SET_GAMMA(xf86Gamma.blue);
    } else if (TEST_GAMMA(scrp->monitor->gamma)) {
	from = X_CONFIG;
	scrp->gamma.red = SET_GAMMA(scrp->monitor->gamma.red);
	scrp->gamma.green = SET_GAMMA(scrp->monitor->gamma.green);
	scrp->gamma.blue = SET_GAMMA(scrp->monitor->gamma.blue);
d851 2
a852 1
    } else if ( DDC && DDC->features.gamma > GAMMA_ZERO ) {
d854 5
a858 5
	scrp->gamma.red = SET_GAMMA(DDC->features.gamma);
	scrp->gamma.green = SET_GAMMA(DDC->features.gamma);
	scrp->gamma.blue = SET_GAMMA(DDC->features.gamma);
	/* EDID structure version 2 gives optional seperate red, green & blue gamma values
	 * in bytes 0x57-0x59 */
d860 10
a869 8
    } else if (TEST_GAMMA(gamma)) {
	scrp->gamma.red = SET_GAMMA(gamma.red);
	scrp->gamma.green = SET_GAMMA(gamma.green);
	scrp->gamma.blue = SET_GAMMA(gamma.blue);
    } else {
	scrp->gamma.red = 1.0;
	scrp->gamma.green = 1.0;
	scrp->gamma.blue = 1.0;
d875 1
a875 1
	return TRUE;
d877 2
a878 2
	       "Using gamma correction (%.1f, %.1f, %.1f)\n",
	       scrp->gamma.red, scrp->gamma.green, scrp->gamma.blue);
a885 1

d898 1
a898 1
    xf86MonPtr DDC = (xf86MonPtr)(pScrn->monitor->DDC);
d906 9
a914 8
    if (DDC && (DDC->features.hsize > 0 && DDC->features.vsize > 0) ) {
      /* DDC gives display size in mm for individual modes,
       * but cm for monitor
       */
      ddcWidthmm = DDC->features.hsize * 10; /* 10mm in 1cm */
      ddcHeightmm = DDC->features.vsize * 10; /* 10mm in 1cm */
    } else {
      ddcWidthmm = ddcHeightmm = 0;
d918 72
a989 66
	pScrn->xDpi = monitorResolution;
	pScrn->yDpi = monitorResolution;
	from = X_CMDLINE;
    } else if (pScrn->widthmm > 0 || pScrn->heightmm > 0) {
	from = X_CONFIG;
	if (pScrn->widthmm > 0) {
	   pScrn->xDpi =
		(int)((double)pScrn->virtualX * MMPERINCH / pScrn->widthmm);
	}
	if (pScrn->heightmm > 0) {
	   pScrn->yDpi =
		(int)((double)pScrn->virtualY * MMPERINCH / pScrn->heightmm);
	}
	if (pScrn->xDpi > 0 && pScrn->yDpi <= 0)
	    pScrn->yDpi = pScrn->xDpi;
	if (pScrn->yDpi > 0 && pScrn->xDpi <= 0)
	    pScrn->xDpi = pScrn->yDpi;
	xf86DrvMsg(pScrn->scrnIndex, from, "Display dimensions: (%d, %d) mm\n",
		   pScrn->widthmm, pScrn->heightmm);

	/* Warn if config and probe disagree about display size */
	if ( ddcWidthmm && ddcHeightmm ) {
	  if (pScrn->widthmm > 0) {
	    widthErr  = abs(ddcWidthmm  - pScrn->widthmm);
	  } else {
	    widthErr  = 0;
	  }
	  if (pScrn->heightmm > 0) {
	    heightErr = abs(ddcHeightmm - pScrn->heightmm);
	  } else {
	    heightErr = 0;
	  }
	  if (widthErr>10 || heightErr>10) {
	    /* Should include config file name for monitor here */
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Probed monitor is %dx%d mm, using Displaysize %dx%d mm\n",
		       ddcWidthmm,ddcHeightmm, pScrn->widthmm,pScrn->heightmm);
	  }
	}
    } else if ( ddcWidthmm && ddcHeightmm ) {
	from = X_PROBED;
	xf86DrvMsg(pScrn->scrnIndex, from, "Display dimensions: (%d, %d) mm\n",
		   ddcWidthmm, ddcHeightmm );
	pScrn->widthmm = ddcWidthmm;
	pScrn->heightmm = ddcHeightmm;
	if (pScrn->widthmm > 0) {
	   pScrn->xDpi =
		(int)((double)pScrn->virtualX * MMPERINCH / pScrn->widthmm);
	}
	if (pScrn->heightmm > 0) {
	   pScrn->yDpi =
		(int)((double)pScrn->virtualY * MMPERINCH / pScrn->heightmm);
	}
	if (pScrn->xDpi > 0 && pScrn->yDpi <= 0)
	    pScrn->yDpi = pScrn->xDpi;
	if (pScrn->yDpi > 0 && pScrn->xDpi <= 0)
	    pScrn->xDpi = pScrn->yDpi;
    } else {
	if (x > 0)
	    pScrn->xDpi = x;
	else
	    pScrn->xDpi = DEFAULT_DPI;
	if (y > 0)
	    pScrn->yDpi = y;
	else
	    pScrn->yDpi = DEFAULT_DPI;
d992 1
a992 1
	       pScrn->xDpi, pScrn->yDpi);
a996 1

d1001 6
a1006 5
	pScreen->whitePixel = 0;
	pScreen->blackPixel = 1;
    } else {
	pScreen->whitePixel = 1;
	pScreen->blackPixel = 0;
d1037 6
a1042 7
    if (enable)
    {
	/*
	 * Restore all of the clip lists on the screen
	 */
	if (!xf86Resetting)
	    SetRootClip (pScreen, TRUE);
d1045 5
a1049 6
    else
    {
	/*
	 * Empty all of the clip lists on the screen
	 */
	SetRootClip (pScreen, FALSE);
d1053 2
a1054 5
/* Print driver messages in the standard format */

#undef PREFIX_SIZE
#define PREFIX_SIZE 14

d1057 1
a1057 1
		va_list args)
a1058 2
    char *tmpFormat;

d1061 5
a1065 15
	xf86Screens[scrnIndex]->name) {
	tmpFormat = malloc(strlen(format) +
			   strlen(xf86Screens[scrnIndex]->name) +
			   PREFIX_SIZE + 1);
	if (!tmpFormat)
	    return;

	snprintf(tmpFormat, PREFIX_SIZE + 1, "%s(%d): ",
		 xf86Screens[scrnIndex]->name, scrnIndex);

	strcat(tmpFormat, format);
	LogVMessageVerb(type, verb, tmpFormat, args);
	free(tmpFormat);
    } else
	LogVMessageVerb(type, verb, format, args);
a1066 1
#undef PREFIX_SIZE
d1071 1
a1071 1
	       ...)
d1092 1
a1092 1
   <driver>: <device name>: <message> */
d1094 2
a1095 2
xf86VIDrvMsgVerb(InputInfoPtr dev, MessageType type, int verb, const char *format,
		 va_list args)
d1097 2
a1098 1
    char *msg;
d1100 5
a1104 6
    if (asprintf(&msg, "%s: %s: %s", dev->drv->driverName, dev->name, format)
	== -1) {
	LogVMessageVerb(type, verb, "%s", args);
    } else {
	LogVMessageVerb(type, verb, msg, args);
	free(msg);
d1106 3
d1113 2
a1114 2
xf86IDrvMsgVerb(InputInfoPtr dev, MessageType type, int verb, const char *format,
	       ...)
a1133 1

d1164 1
a1164 1
	LogVWrite(verb, format, ap);
d1176 1
a1176 1
	LogVWrite(1, format, ap);
a1179 1

d1190 4
a1193 4
	/* Append the display number and ".log" */
	if (asprintf(&lf, "%s%%s" LOGSUFFIX, xf86LogFile) == -1)
	    FatalError("Cannot allocate space for the log file name\n");
	xf86LogFile = lf;
a1213 1

d1223 1
a1223 2
    for (i = 0; table[i].token >= 0 && table[i].token != token; i++)
	;
d1226 1
a1226 1
	return NULL;
d1228 1
a1228 1
	return table[i].name;
d1237 1
a1237 1
	return -1;
d1239 1
a1239 2
    for (i = 0; table[i].token >= 0 && xf86NameCmp(string, table[i].name); i++)
	;
d1253 6
a1258 6
    for (j=0; j < scrp->numClocks; j++) {
	if ((j % 4) == 0) {
	    xf86ErrorF("\n");
	    xf86DrvMsg(scrp->scrnIndex, from, "pixel clocks:");
	}
	xf86ErrorF(" %7.3f", (double)scrp->clock[j] / 1000.0);
a1262 1

d1278 14
a1291 13
	if (i != 0) {
	    xf86ErrorF(",");
	    len++;
	}
	if (len + 2 + strlen(chips[i].name) < 78) {
	    xf86ErrorF(" ");
	    len++;
	} else {
	    xf86ErrorF("\n\t");
	    len = 8;
	}
	xf86ErrorF("%s", chips[i].name);
	len += strlen(chips[i].name);
a1295 1

d1297 1
a1297 1
xf86MatchDevice(const char *drivername, GDevPtr **sectlist)
d1299 1
a1299 1
    GDevPtr       gdp, *pgdp = NULL;
d1301 1
a1301 1
    int i,j;
d1304 1
a1304 1
	*sectlist = NULL;
d1311 1
a1311 1
	return 0;
d1334 1
a1334 1
    for (j=0; xf86ConfigLayout.screens[j].screen != NULL; j++) {
d1337 2
a1338 2
            && (xf86NameCmp( screensecptr->device->driver,drivername) == 0)
            && (! screensecptr->device->claimed)) {
d1350 8
a1357 8
	gdp = &xf86ConfigLayout.inactives[j];
	if (gdp->driver && !gdp->claimed &&
	    !xf86NameCmp(gdp->driver,drivername)) {
	    /* we have a matching driver that wasn't claimed yet */
	    pgdp = xnfrealloc(pgdp, (i + 2) * sizeof(GDevPtr));
	    pgdp[i++] = gdp;
	}
	j++;
d1367 1
a1367 1
	*sectlist = pgdp;
d1369 1
a1369 1
	free(pgdp);
a1372 90
/*
 * xf86GetClocks -- get the dot-clocks via a BIG BAD hack ...
 */
void
xf86GetClocks(ScrnInfoPtr pScrn, int num, Bool (*ClockFunc)(ScrnInfoPtr, int),
	      void (*ProtectRegs)(ScrnInfoPtr, Bool),
	      void (*BlankScreen)(ScrnInfoPtr, Bool), IOADDRESS vertsyncreg,
	      int maskval, int knownclkindex, int knownclkvalue)
{
    register int status = vertsyncreg;
    unsigned long i, cnt, rcnt, sync;

    /* First save registers that get written on */
    (*ClockFunc)(pScrn, CLK_REG_SAVE);

    if (num > MAXCLOCKS)
	num = MAXCLOCKS;

    for (i = 0; i < num; i++)
    {
	if (ProtectRegs)
	    (*ProtectRegs)(pScrn, TRUE);
	if (!(*ClockFunc)(pScrn, i))
	{
	    pScrn->clock[i] = -1;
	    continue;
	}
	if (ProtectRegs)
	    (*ProtectRegs)(pScrn, FALSE);
	if (BlankScreen)
	    (*BlankScreen)(pScrn, FALSE);

    	usleep(50000);     /* let VCO stabilise */

    	cnt  = 0;
    	sync = 200000;

	while ((inb(status) & maskval) == 0x00)
	    if (sync-- == 0) goto finish;
	/* Something appears to be happening, so reset sync count */
	sync = 200000;
	while ((inb(status) & maskval) == maskval)
	    if (sync-- == 0) goto finish;
	/* Something appears to be happening, so reset sync count */
	sync = 200000;
	while ((inb(status) & maskval) == 0x00)
	    if (sync-- == 0) goto finish;

	for (rcnt = 0; rcnt < 5; rcnt++)
	{
	    while (!(inb(status) & maskval))
		cnt++;
	    while ((inb(status) & maskval))
		cnt++;
	}

finish:
	pScrn->clock[i] = cnt ? cnt : -1;
	if (BlankScreen)
            (*BlankScreen)(pScrn, TRUE);
    }

    for (i = 0; i < num; i++)
    {
	if (i != knownclkindex)
	{
	    if (pScrn->clock[i] == -1)
	    {
		pScrn->clock[i] = 0;
	    }
	    else
	    {
		pScrn->clock[i] = (int)(0.5 +
                    (((float)knownclkvalue) * pScrn->clock[knownclkindex]) /
	            (pScrn->clock[i]));
		/* Round to nearest 10KHz */
		pScrn->clock[i] += 5;
		pScrn->clock[i] /= 10;
		pScrn->clock[i] *= 10;
	    }
	}
    }

    pScrn->clock[knownclkindex] = knownclkvalue;
    pScrn->numClocks = num;

    /* Restore registers that were written on */
    (*ClockFunc)(pScrn, CLK_REG_RESTORE);
}

d1377 1
a1377 1
	return NULL;
a1381 1

a1393 1

a1399 1

a1405 1

a1411 1

a1417 1

a1423 1

a1429 1

a1435 1

a1441 1

a1447 1

a1453 1

a1459 1

a1471 1

a1477 1

a1483 11

Bool
xf86IsPc98(void)
{
#if SUPPORT_PC98
    return xf86Info.pc98;
#else
    return FALSE;
#endif
}

d1494 1
a1494 1
    return (CARD32)LoaderGetModuleVersion(module);
d1504 1
a1504 1
			&errmaj, &errmin);
d1506 1
a1506 1
	LoaderErrorMsg(NULL, name, errmaj, errmin);
d1517 1
a1517 1
			&errmaj, &errmin);
d1519 1
a1519 1
	LoaderErrorMsg(pScrn->name, name, errmaj, errmin);
d1534 1
a1534 1
	return NULL;
d1541 1
a1541 1
	return NULL;
d1543 2
a1544 2
	free(Name);
	return NULL;
d1549 1
a1549 1
	LoaderErrorMsg(NULL, Name, errmaj, errmin);
a1556 5
    /*
     * This is disabled for now.  The loader isn't smart enough yet to undo
     * relocations.
     */
#if 0
a1557 1
#endif
d1567 1
a1567 1
   OPTION_BACKING_STORE
d1571 2
a1572 2
   { OPTION_BACKING_STORE, "BackingStore", OPTV_BOOLEAN, {0}, FALSE },
   { -1,                   NULL,           OPTV_NONE,    {0}, FALSE }
d1584 1
a1584 1
    (void)memcpy(options, BSOptions, sizeof(BSOptions));
d1589 10
a1598 8
	from = X_CMDLINE;
	useBS = TRUE;
    } else if (xf86bsDisableFlag) {
	from = X_CMDLINE;
	useBS = FALSE;
    } else {
	if (xf86GetOptValBool(options, OPTION_BACKING_STORE, &useBS))
	    from = X_CONFIG;
d1603 2
a1604 2
	xf86DrvMsg(pScreen->myNum, from, "Backing store %s\n",
		   useBS ? "enabled" : "disabled");
a1606 1

d1608 1
a1608 1
   OPTION_SILKEN_MOUSE
d1612 2
a1613 2
   { OPTION_SILKEN_MOUSE, "SilkenMouse",   OPTV_BOOLEAN, {0}, FALSE },
   { -1,                   NULL,           OPTV_NONE,    {0}, FALSE }
d1617 1
a1617 1
xf86SetSilkenMouse (ScreenPtr pScreen)
d1625 1
a1625 1
    (void)memcpy(options, SMOptions, sizeof(SMOptions));
d1630 1
a1630 1
	/* TODO VGA arb disable silken mouse */
d1633 5
a1637 4
	useSM = FALSE;
    } else {
	if (xf86GetOptValBool(options, OPTION_SILKEN_MOUSE, &useSM))
	    from = X_CONFIG;
d1647 2
a1648 2
	xf86DrvMsg(pScreen->myNum, from, "Silken mouse %s\n",
		   pScrn->silkenMouse ? "enabled" : "disabled");
d1655 1
a1655 1
		  char **adaptor_name, pointer *adaptor_options)
d1662 5
a1666 3
	if (adaptor_name) *adaptor_name = NULL;
	if (adaptor_options) *adaptor_options = NULL;
	return NULL;
d1670 4
a1673 2
    if (adaptor_name) *adaptor_name = adaptor->identifier;
    if (adaptor_options) *adaptor_options = adaptor->options;
d1676 2
a1677 2
	if (!xf86NameCmp(adaptor->ports[i].identifier, port_name))
	    return adaptor->ports[i].options;
d1688 1
a1688 1
			   EntityProc enter, EntityProc leave, pointer private)
d1693 2
a1694 2
	xf86RemoveEntityFromScreen(pScrn,pEnt->index);
    xf86SetEntityFuncs(pEnt->index,init,enter,leave,private);
d1699 2
a1700 2
		   EntityProc init, EntityProc enter, EntityProc leave,
		   pointer private)
d1703 3
a1705 1
    if (!pEnt) return pScrn;
d1708 2
a1709 2
	free(pEnt);
	return pScrn;
d1713 3
a1715 3
	xf86ConfigFbEntityInactive(pEnt, init,  enter, leave,  private);
	free(pEnt);
	return pScrn;
d1719 2
a1720 2
	pScrn = xf86AllocateScreen(pEnt->driver,scrnFlag);
    xf86AddEntityToScreen(pScrn,entityIndex);
d1722 1
a1722 1
    xf86SetEntityFuncs(entityIndex,init,enter,leave,private);
d1734 3
a1736 3
    for (i=0 ; i < pScrn->numEntities; i++) {
	if (xf86IsEntityPrimary(i))
	    return TRUE;
d1743 1
a1743 1
			       int format, unsigned long len, pointer value )
a1745 1
    int i;
d1749 1
a1749 1
	   ScrnIndex, property, type, format, len, value);
d1751 2
a1752 2
    if (ScrnIndex<0 || ScrnIndex>=xf86NumScreens) {
      return BadMatch;
d1756 6
a1761 6
	xf86RegisteredPropertiesTable[ScrnIndex]) {
      for (pNewProp = xf86RegisteredPropertiesTable[ScrnIndex];
	   pNewProp; pNewProp = pNewProp->next) {
	if (strcmp(pNewProp->name, NameForAtom(property)) == 0)
	  break;
      }
d1765 12
a1776 11
      if ((pNewProp = (RootWinPropPtr)malloc(sizeof(RootWinProp))) == NULL) {
	return BadAlloc;
      }
      /*
       * We will put this property at the end of the list so that
       * the changes are made in the order they were requested.
       */
      pNewProp->next = NULL;
    } else {
      free(pNewProp->name);
      existing = TRUE;
d1787 5
a1791 9
    if (NULL==xf86RegisteredPropertiesTable) {
      DebugF("creating xf86RegisteredPropertiesTable[] size %d\n",
	     xf86NumScreens);
      if ( NULL==(xf86RegisteredPropertiesTable=(RootWinPropPtr*)xnfcalloc(sizeof(RootWinProp),xf86NumScreens) )) {
	return BadAlloc;
      }
      for (i=0; i<xf86NumScreens; i++) {
	xf86RegisteredPropertiesTable[i] = NULL;
      }
d1795 1
a1795 1
	   (void *)xf86RegisteredPropertiesTable);
d1797 1
a1797 1
	   ScrnIndex, (void *)xf86RegisteredPropertiesTable[ScrnIndex]);
d1800 10
a1809 7
      if ( xf86RegisteredPropertiesTable[ScrnIndex] == NULL) {
	xf86RegisteredPropertiesTable[ScrnIndex] = pNewProp;
      } else {
	pRegProp = xf86RegisteredPropertiesTable[ScrnIndex];
	while (pRegProp->next != NULL) {
	  DebugF("- next %p\n", (void *)pRegProp);
	  pRegProp = pRegProp->next;
a1810 2
	pRegProp->next = pNewProp;
      }
d1819 1
a1819 1
    switch(mode) {
d1822 1
a1822 1
	return TRUE;
d1825 1
a1825 1
	return FALSE;
d1827 2
a1828 2
	xf86MsgVerb(X_WARNING, 0, "Unexpected save screen mode: %d\n", mode);
	return TRUE;
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a127 1
    xf86InputDriverList[xf86NumInputDrivers - 1]->refCount = 0;
a275 70
/* Allocate a new InputInfoRec and append it to the tail of xf86InputDevs. */
InputInfoPtr
xf86AllocateInput(InputDriverPtr drv, int flags)
{
    InputInfoPtr new, *prev = NULL;

    if (!(new = calloc(sizeof(InputInfoRec), 1)))
	return NULL;

    new->drv = drv;
    drv->refCount++;
    new->module = DuplicateModule(drv->module, NULL);

    for (prev = &xf86InputDevs; *prev; prev = &(*prev)->next)
        ;

    *prev = new;
    new->next = NULL;

    return new;
}


/*
 * Remove an entry from xf86InputDevs.  Ideally it should free all allocated
 * data.  To do this properly may require a driver hook.
 */

void
xf86DeleteInput(InputInfoPtr pInp, int flags)
{
    InputInfoPtr p;

    /* First check if the inputdev is valid. */
    if (pInp == NULL)
	return;

#if 0
    /* If a free function is defined, call it here. */
    if (pInp->free)
	pInp->free(pInp, 0);
#endif

    if (pInp->module)
	UnloadModule(pInp->module);

    if (pInp->drv)
	pInp->drv->refCount--;

    /* This should *really* be handled in drv->UnInit(dev) call instead, but
     * if the driver forgets about it make sure we free it or at least crash
     * with flying colors */
    free(pInp->private);

    FreeInputAttributes(pInp->attrs);

    /* Remove the entry from the list. */
    if (pInp == xf86InputDevs)
	xf86InputDevs = pInp->next;
    else {
	p = xf86InputDevs;
	while (p && p->next != pInp)
	    p = p->next;
	if (p)
	    p->next = pInp->next;
	/* Else the entry wasn't in the xf86InputDevs list (ignore this). */
    }
    free(pInp);
}

a985 100
 * xf86SetRootClip --
 *	Enable or disable rendering to the screen by
 *	setting the root clip list and revalidating
 *	all of the windows
 */

static void
xf86SetRootClip (ScreenPtr pScreen, Bool enable)
{
    WindowPtr	pWin = pScreen->root;
    WindowPtr	pChild;
    Bool	WasViewable = (Bool)(pWin->viewable);
    Bool	anyMarked = FALSE;
    WindowPtr   pLayerWin;
    BoxRec	box;

    if (WasViewable)
    {
	for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib)
	{
	    (void) (*pScreen->MarkOverlappedWindows)(pChild,
						     pChild,
						     &pLayerWin);
	}
	(*pScreen->MarkWindow) (pWin);
	anyMarked = TRUE;
	if (pWin->valdata)
	{
	    if (HasBorder (pWin))
	    {
		RegionPtr	borderVisible;

		borderVisible = RegionCreate(NullBox, 1);
		RegionSubtract(borderVisible,
				&pWin->borderClip, &pWin->winSize);
		pWin->valdata->before.borderVisible = borderVisible;
	    }
	    pWin->valdata->before.resized = TRUE;
	}
    }

    /*
     * Use REGION_BREAK to avoid optimizations in ValidateTree
     * that assume the root borderClip can't change well, normally
     * it doesn't...)
     */
    if (enable)
    {
	box.x1 = 0;
	box.y1 = 0;
	box.x2 = pScreen->width;
	box.y2 = pScreen->height;
	RegionInit(&pWin->winSize, &box, 1);
	RegionInit(&pWin->borderSize, &box, 1);
	if (WasViewable)
	    RegionReset(&pWin->borderClip, &box);
	pWin->drawable.width = pScreen->width;
	pWin->drawable.height = pScreen->height;
        RegionBreak(&pWin->clipList);
    }
    else
    {
	RegionEmpty(&pWin->borderClip);
	RegionBreak(&pWin->clipList);
    }

    ResizeChildrenWinSize (pWin, 0, 0, 0, 0);

    if (WasViewable)
    {
	if (pWin->firstChild)
	{
	    anyMarked |= (*pScreen->MarkOverlappedWindows)(pWin->firstChild,
							   pWin->firstChild,
							   (WindowPtr *)NULL);
	}
	else
	{
	    (*pScreen->MarkWindow) (pWin);
	    anyMarked = TRUE;
	}


	if (anyMarked)
	    (*pScreen->ValidateTree)(pWin, NullWindow, VTOther);
    }

    if (WasViewable)
    {
	if (anyMarked)
	    (*pScreen->HandleExposures)(pWin);
	if (anyMarked && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pWin, NullWindow, VTOther);
    }
    if (pWin->realized)
	WindowsRestructured ();
    FlushAllOutput ();
}

/*
a1014 4
	 * Restore the screen pixmap devPrivate field
	 */
	pspix->devPrivate = pScrnInfo->pixmapPrivate;
	/*
d1018 1
a1018 1
	    xf86SetRootClip (pScreen, TRUE);
d1026 1
a1026 8
	xf86SetRootClip (pScreen, FALSE);
	/*
	 * save the screen pixmap devPrivate field and
	 * replace it with NULL so accidental references
	 * to the frame buffer are caught
	 */
	pScrnInfo->pixmapPrivate = pspix->devPrivate;
	pspix->devPrivate.ptr = NULL;
d1084 41
d1132 1
a1132 1
    xf86VDrvMsgVerb(-1, type, verb, format, ap);
d1143 1
a1143 1
    xf86VDrvMsgVerb(-1, type, 1, format, ap);
d1183 1
a1183 3
	lf = malloc(strlen(xf86LogFile) + strlen("%s") +
		    strlen(LOGSUFFIX) + 1);
	if (!lf)
a1184 1
	sprintf(lf, "%s%%s" LOGSUFFIX, xf86LogFile);
d1201 1
a1201 1
xf86CloseLog(void)
d1203 1
a1203 1
    LogClose();
d1834 1
d1946 1
a1946 1
xf86MotionHistoryAllocate(LocalDevicePtr local)
d1948 1
a1948 1
    AllocateMotionHistory(local->dev);
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a40 3
#include <pciaccess.h>
#include "Pci.h"

a56 1
#include "xf86Bus.h"
d104 1
a104 1
	xfree(xf86DriverList[drvIndex]);
d136 1
a136 1
    xfree(xf86InputDriverList[drvIndex]);
d237 1
a237 2
    if (pScrn->privates)
	xfree(pScrn->privates);
d241 1
a241 1
    xfree(pScrn);
d271 1
a271 1
	bzero(&nprivs[idx], sizeof(DevUnion));
d283 1
a283 1
    if (!(new = xcalloc(sizeof(InputInfoRec), 1)))
d329 3
a331 2
    if (pInp->private)
	xfree(pInp->private);
d344 1
a344 1
    xfree(pInp);
d779 3
d1066 1
a1066 1
    WindowPtr	pWin = WindowTable[pScreen->myNum];
d1089 2
a1090 2
		borderVisible = REGION_CREATE(pScreen, NullBox, 1);
		REGION_SUBTRACT(pScreen, borderVisible,
d1109 2
a1110 2
	REGION_INIT (pScreen, &pWin->winSize, &box, 1);
	REGION_INIT (pScreen, &pWin->borderSize, &box, 1);
d1112 1
a1112 1
	    REGION_RESET(pScreen, &pWin->borderClip, &box);
d1115 1
a1115 1
        REGION_BREAK (pWin->drawable.pScreen, &pWin->clipList);
d1119 2
a1120 2
	REGION_EMPTY(pScreen, &pWin->borderClip);
	REGION_BREAK (pWin->drawable.pScreen, &pWin->clipList);
d1226 1
a1226 1
	tmpFormat = xalloc(strlen(format) +
d1237 1
a1237 1
	xfree(tmpFormat);
d1366 1
a1366 1
	return(table[i].name);
d1380 1
a1380 1
    return(table[i].token);
d1446 6
a1451 1
    if (xf86DoConfigure && xf86DoConfigurePass1) return 1;
d1509 1
a1509 1
	xfree(pgdp);
a1512 414
static Bool
pciDeviceHasBars(struct pci_device *pci)
{
    int i;

    for (i = 0; i < 6; i++)
	if (pci->regions[i].size)
	    return TRUE;

    if (pci->rom_size)
	return TRUE;

    return FALSE;
}

struct Inst {
    struct pci_device *	pci;
    GDevPtr		dev;
    Bool		foundHW;  /* PCIid in list of supported chipsets */
    Bool		claimed;  /* BusID matches with a device section */
    int 		chip;
    int 		screen;
};


/**
 * Find set of unclaimed devices matching a given vendor ID.
 *
 * Used by drivers to find as yet unclaimed devices matching the specified
 * vendor ID.
 *
 * \param driverName     Name of the driver.  This is used to find Device
 *                       sections in the config file.
 * \param vendorID       PCI vendor ID of associated devices.  If zero, then
 *                       the true vendor ID must be encoded in the \c PCIid
 *                       fields of the \c PCIchipsets entries.
 * \param chipsets       Symbol table used to associate chipset names with
 *                       PCI IDs.
 * \param devList        List of Device sections parsed from the config file.
 * \param numDevs        Number of entries in \c devList.
 * \param drvp           Pointer the driver's control structure.
 * \param foundEntities  Returned list of entity indicies associated with the
 *                       driver.
 *
 * \returns
 * The number of elements in returned in \c foundEntities on success or zero
 * on failure.
 *
 * \todo
 * This function does a bit more than short description says.  Fill in some
 * more of the details of its operation.
 *
 * \todo
 * The \c driverName parameter is redundant.  It is the same as
 * \c DriverRec::driverName.  In a future version of this function, remove
 * that parameter.
 */
int
xf86MatchPciInstances(const char *driverName, int vendorID,
		      SymTabPtr chipsets, PciChipsets *PCIchipsets,
		      GDevPtr *devList, int numDevs, DriverPtr drvp,
		      int **foundEntities)
{
    int i,j;
    struct pci_device * pPci;
    struct pci_device_iterator *iter;
    struct Inst *instances = NULL;
    int numClaimedInstances = 0;
    int allocatedInstances = 0;
    int numFound = 0;
    SymTabRec *c;
    PciChipsets *id;
    int *retEntities = NULL;

    *foundEntities = NULL;


    /* Each PCI device will contribute at least one entry.  Each device
     * section can contribute at most one entry.  The sum of the two is
     * guaranteed to be larger than the maximum possible number of entries.
     * Do this calculation and memory allocation once now to eliminate the
     * need for realloc calls inside the loop.
     */
    if (!(xf86DoConfigure && xf86DoConfigurePass1)) {
	unsigned max_entries = numDevs;

	iter = pci_slot_match_iterator_create(NULL);
	while ((pPci = pci_device_next(iter)) != NULL) {
	    max_entries++;
	}

	pci_iterator_destroy(iter);
	instances = xnfalloc(max_entries * sizeof(struct Inst));
    }

    iter = pci_slot_match_iterator_create(NULL);
    while ((pPci = pci_device_next(iter)) != NULL) {
	unsigned device_class = pPci->device_class;
	Bool foundVendor = FALSE;


	/* Convert the pre-PCI 2.0 device class for a VGA adapter to the
	 * 2.0 version of the same class.
	 */
	if ( device_class == 0x00000101 ) {
	    device_class = 0x00030000;
	}


	/* Find PCI devices that match the given vendor ID.  The vendor ID is
	 * either specified explicitly as a parameter to the function or
	 * implicitly encoded in the high bits of id->PCIid.
	 *
	 * The first device with a matching vendor is recorded, even if the
	 * device ID doesn't match.  This is done because the Device section
	 * in the xorg.conf file can over-ride the device ID.  A matching PCI
	 * ID might not be found now, but after the device ID over-ride is
	 * applied there /might/ be a match.
	 */
	for (id = PCIchipsets; id->PCIid != -1; id++) {
	    const unsigned vendor_id = ((id->PCIid & 0xFFFF0000) >> 16)
		| vendorID;
	    const unsigned device_id = (id->PCIid & 0x0000FFFF);
	    const unsigned match_class = 0x00030000 | id->PCIid;

	    if ((vendor_id == pPci->vendor_id)
		|| ((vendorID == PCI_VENDOR_GENERIC) && (match_class == device_class))) {
		if (!foundVendor && (instances != NULL)) {
		    ++allocatedInstances;
		    instances[allocatedInstances - 1].pci = pPci;
		    instances[allocatedInstances - 1].dev = NULL;
		    instances[allocatedInstances - 1].claimed = FALSE;
		    instances[allocatedInstances - 1].foundHW = FALSE;
		    instances[allocatedInstances - 1].screen = 0;
		}

		foundVendor = TRUE;

		if ( (device_id == pPci->device_id)
		     || ((vendorID == PCI_VENDOR_GENERIC) 
			 && (match_class == device_class)) ) {
		    if ( instances != NULL ) {
			instances[allocatedInstances - 1].foundHW = TRUE;
			instances[allocatedInstances - 1].chip = id->numChipset;
		    }


		    if ( xf86DoConfigure && xf86DoConfigurePass1 ) {
			if (xf86CheckPciSlot(pPci)) {
			    GDevPtr pGDev = 
			      xf86AddBusDeviceToConfigure(drvp->driverName,
							  BUS_PCI, pPci, -1);
			    if (pGDev) {
				/* After configure pass 1, chipID and chipRev
				 * are treated as over-rides, so clobber them
				 * here.
				 */
				pGDev->chipID = -1;
				pGDev->chipRev = -1;
			    }

			    numFound++;
			}
		    }
		    else {
			numFound++;
		    }

		    break;
		}
	    }
	}
    }

    pci_iterator_destroy(iter);


    /* In "probe only" or "configure" mode (signaled by instances being NULL),
     * our work is done.  Return the number of detected devices.
     */
    if ( instances == NULL ) {
	return numFound;
    }


    /*
     * This may be debatable, but if no PCI devices with a matching vendor
     * type is found, return zero now.  It is probably not desirable to
     * allow the config file to override this.
     */
    if (allocatedInstances <= 0) {
	xfree(instances);
	return 0;
    }


    DebugF("%s instances found: %d\n", driverName, allocatedInstances);

   /*
    * Check for devices that need duplicated instances.  This is required
    * when there is more than one screen per entity.
    *
    * XXX This currently doesn't work for cases where the BusID isn't
    * specified explicitly in the config file.
    */

    for (j = 0; j < numDevs; j++) {
        if (devList[j]->screen > 0 && devList[j]->busID
	    && *devList[j]->busID) {
	    for (i = 0; i < allocatedInstances; i++) {
	        pPci = instances[i].pci;
	        if (xf86ComparePciBusString(devList[j]->busID, 
					    PCI_MAKE_BUS( pPci->domain, pPci->bus ),
					    pPci->dev,
					    pPci->func)) {
		    allocatedInstances++;
		    instances[allocatedInstances - 1] = instances[i];
		    instances[allocatedInstances - 1].screen =
		      				devList[j]->screen;
		    numFound++;
		    break;
		}
	    }
	}
    }

    for (i = 0; i < allocatedInstances; i++) {
	GDevPtr dev = NULL;
	GDevPtr devBus = NULL;

	pPci = instances[i].pci;
	for (j = 0; j < numDevs; j++) {
	    if (devList[j]->busID && *devList[j]->busID) {
		if (xf86ComparePciBusString(devList[j]->busID, 
					    PCI_MAKE_BUS( pPci->domain, pPci->bus ),
					    pPci->dev,
					    pPci->func) &&
		    devList[j]->screen == instances[i].screen) {

		    if (devBus)
                        xf86MsgVerb(X_WARNING,0,
			    "%s: More than one matching Device section for "
			    "instances\n\t(BusID: %s) found: %s\n",
			    driverName, devList[j]->busID,
			    devList[j]->identifier);
		    else
			devBus = devList[j];
		}
	    } else {
		/*
		 * if device section without BusID is found
		 * only assign to it to the primary device.
		 */
		if (xf86IsPrimaryPci(pPci)) {
		    xf86Msg(X_PROBED, "Assigning device section with no busID"
			    " to primary device\n");
		    if (dev || devBus)
			xf86MsgVerb(X_WARNING, 0,
			    "%s: More than one matching Device section "
			    "found: %s\n", driverName, devList[j]->identifier);
		    else
			dev = devList[j];
		}
	    }
	}
	if (devBus) dev = devBus;  /* busID preferred */
	if (!dev) {
	    if (xf86CheckPciSlot(pPci) && pciDeviceHasBars(pPci)) {
		xf86MsgVerb(X_WARNING, 0, "%s: No matching Device section "
			    "for instance (BusID PCI:%u@@%u:%u:%u) found\n",
			    driverName, pPci->domain, pPci->bus, pPci->dev,
			    pPci->func);
	    }
	} else {
	    numClaimedInstances++;
	    instances[i].claimed = TRUE;
	    instances[i].dev = dev;
	}
    }
    DebugF("%s instances found: %d\n", driverName, numClaimedInstances);
    /*
     * Now check that a chipset or chipID override in the device section
     * is valid.  Chipset has precedence over chipID.
     * If chipset is not valid ignore BusSlot completely.
     */
    for (i = 0; i < allocatedInstances && numClaimedInstances > 0; i++) {
	MessageType from = X_PROBED;

	if (!instances[i].claimed) {
	    continue;
	}
	if (instances[i].dev->chipset) {
	    for (c = chipsets; c->token >= 0; c++) {
		if (xf86NameCmp(c->name, instances[i].dev->chipset) == 0)
		    break;
	    }
	    if (c->token == -1) {
		instances[i].claimed = FALSE;
		numClaimedInstances--;
		xf86MsgVerb(X_WARNING, 0, "%s: Chipset \"%s\" in Device "
			    "section \"%s\" isn't valid for this driver\n",
			    driverName, instances[i].dev->chipset,
			    instances[i].dev->identifier);
	    } else {
		instances[i].chip = c->token;

		for (id = PCIchipsets; id->numChipset >= 0; id++) {
		    if (id->numChipset == instances[i].chip)
			break;
		}
		if(id->numChipset >=0){
		    xf86Msg(X_CONFIG,"Chipset override: %s\n",
			     instances[i].dev->chipset);
		    from = X_CONFIG;
		} else {
		    instances[i].claimed = FALSE;
		    numClaimedInstances--;
		    xf86MsgVerb(X_WARNING, 0, "%s: Chipset \"%s\" in Device "
				"section \"%s\" isn't a valid PCI chipset\n",
				driverName, instances[i].dev->chipset,
				instances[i].dev->identifier);
		}
	    }
	} else if (instances[i].dev->chipID > 0) {
	    for (id = PCIchipsets; id->numChipset >= 0; id++) {
		if (id->PCIid == instances[i].dev->chipID)
		    break;
	    }
	    if (id->numChipset == -1) {
		instances[i].claimed = FALSE;
		numClaimedInstances--;
		xf86MsgVerb(X_WARNING, 0, "%s: ChipID 0x%04X in Device "
			    "section \"%s\" isn't valid for this driver\n",
			    driverName, instances[i].dev->chipID,
			    instances[i].dev->identifier);
	    } else {
		instances[i].chip = id->numChipset;

		xf86Msg( X_CONFIG,"ChipID override: 0x%04X\n",
			 instances[i].dev->chipID);
		from = X_CONFIG;
	    }
	} else if (!instances[i].foundHW) {
	    /*
	     * This means that there was no override and the PCI chipType
	     * doesn't match one that is supported
	     */
	    instances[i].claimed = FALSE;
	    numClaimedInstances--;
	}
	if (instances[i].claimed == TRUE){
	    for (c = chipsets; c->token >= 0; c++) {
		if (c->token == instances[i].chip)
		    break;
	    }
	    xf86Msg(from,"Chipset %s found\n",
		    c->name);
	}
    }

    /*
     * Of the claimed instances, check that another driver hasn't already
     * claimed its slot.
     */
    numFound = 0;
    for (i = 0; i < allocatedInstances && numClaimedInstances > 0; i++) {
	
	if (!instances[i].claimed)
	    continue;
	pPci = instances[i].pci;


        /*
	 * Allow the same entity to be used more than once for devices with
	 * multiple screens per entity.  This assumes implicitly that there
	 * will be a screen == 0 instance.
	 *
	 * XXX Need to make sure that two different drivers don't claim
	 * the same screen > 0 instance.
	 */
        if (instances[i].screen == 0 && !xf86CheckPciSlot( pPci ))
	    continue;

	DebugF("%s: card at %d:%d:%d is claimed by a Device section\n",
	       driverName, pPci->bus, pPci->dev, pPci->func);

	/* Allocate an entry in the lists to be returned */
	numFound++;
	retEntities = xnfrealloc(retEntities, numFound * sizeof(int));
	retEntities[numFound - 1] = xf86ClaimPciSlot( pPci, drvp,
						      instances[i].chip,
						      instances[i].dev,
						      instances[i].dev->active);
        if (retEntities[numFound - 1] == -1 && instances[i].screen > 0) {
	    for (j = 0; j < xf86NumEntities; j++) {
	        EntityPtr pEnt = xf86Entities[j];
	        if (pEnt->bus.type != BUS_PCI)
		    continue;
	        if (pEnt->bus.id.pci == pPci) {
		    retEntities[numFound - 1] = j;
		    xf86AddDevToEntity(j, instances[i].dev);
		    break;
		}
	    }
	}
    }
    xfree(instances);
    if (numFound > 0) {
	*foundEntities = retEntities;
    }
	
    return numFound;
}

d1799 1
a1799 1
	xfree(Name);
d1806 1
a1806 1
    xfree(Name);
d1860 1
a1860 1
    xfree(options);
d1899 1
a1899 1
    xfree(options);
a1941 22
/* new RAC */
/*
 * xf86ConfigPciEntityInactive() -- This function can be used
 * to configure an inactive entity as well as to reconfigure an
 * previously active entity inactive. If the entity has been
 * assigned to a screen before it will be removed. If p_chip is
 * non-NULL all static resources listed there will be registered.
 */
static void
xf86ConfigPciEntityInactive(EntityInfoPtr pEnt, PciChipsets *p_chip,
			    EntityProc init, EntityProc enter,
			    EntityProc leave, pointer private)
{
    ScrnInfoPtr pScrn;

    if ((pScrn = xf86FindScreenForEntity(pEnt->index)))
	xf86RemoveEntityFromScreen(pScrn,pEnt->index);

    /* shared resources are only needed when entity is active: remove */
    xf86SetEntityFuncs(pEnt->index,init,enter,leave,private);
}

a1953 36
xf86ConfigPciEntity(ScrnInfoPtr pScrn, int scrnFlag, int entityIndex,
			  PciChipsets *p_chip, void *dummy, EntityProc init,
			  EntityProc enter, EntityProc leave, pointer private)
{
    EntityInfoPtr pEnt = xf86GetEntityInfo(entityIndex);
    if (!pEnt) return pScrn;

    if (!(pEnt->location.type == BUS_PCI)
	|| !xf86GetPciInfoForEntity(entityIndex)) {
	xfree(pEnt);
	return pScrn;
    }
    if (!pEnt->active) {
	xf86ConfigPciEntityInactive(pEnt, p_chip, init,  enter,
				    leave,  private);
	xfree(pEnt);
	return pScrn;
    }

    if (!pScrn)
	pScrn = xf86AllocateScreen(pEnt->driver,scrnFlag);
    if (xf86IsEntitySharable(entityIndex)) {
        xf86SetEntityShared(entityIndex);
    }
    xf86AddEntityToScreen(pScrn,entityIndex);
    if (xf86IsEntityShared(entityIndex)) {
        return pScrn;
    }
    xfree(pEnt);

    xf86SetEntityFuncs(entityIndex,init,enter,leave,private);

    return pScrn;
}

ScrnInfoPtr
d1962 1
a1962 1
	xfree(pEnt);
d1968 1
a1968 1
	xfree(pEnt);
a1980 27
/*
 *
 *  OBSOLETE ! xf86ConfigActivePciEntity() is an obsolete function.
 *             It is likely to be removed. Don't use!
 */

Bool
xf86ConfigActivePciEntity(ScrnInfoPtr pScrn, int entityIndex,
                          PciChipsets *p_chip, void *dummy, EntityProc init,
                          EntityProc enter, EntityProc leave, pointer private)
{
    EntityInfoPtr pEnt = xf86GetEntityInfo(entityIndex);
    if (!pEnt) return FALSE;

    if (!pEnt->active || !(pEnt->location.type == BUS_PCI)) {
        xfree(pEnt);
        return FALSE;
    }
    xf86AddEntityToScreen(pScrn,entityIndex);

    xfree(pEnt);
    if (!xf86SetEntityFuncs(entityIndex,init,enter,leave,private))
        return FALSE;

    return TRUE;
}

d2006 1
a2006 1
      return(BadMatch);
d2019 2
a2020 2
      if ((pNewProp = (RootWinPropPtr)xalloc(sizeof(RootWinProp))) == NULL) {
	return(BadAlloc);
d2028 1
a2028 2
      if (pNewProp->name)
	xfree(pNewProp->name);
d2044 1
a2044 1
	return(BadAlloc);
d2069 1
a2069 1
    return(Success);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a55 1
#include "xf86PciInfo.h"
a59 1
#include "xf86RAC.h"
d61 1
d74 1
a74 1
_X_EXPORT void
d101 1
a101 1
_X_EXPORT void
d115 1
a115 1
_X_EXPORT void
a169 11
/* ABI stubs of despair */
_X_EXPORT void
xf86AddModuleInfo(pointer info, pointer module)
{
}

_X_EXPORT void
xf86DeleteModuleInfo(int idx)
{
}

d172 1
a172 1
_X_EXPORT ScrnInfoPtr
a194 16
    /*
     * set the initial access state. This will be modified after PreInit.
     * XXX Or should we do it some other place?
     */
    xf86Screens[i]->CurrentAccess = &xf86CurrentAccess;
    xf86Screens[i]->resourceType = MEM_IO;

#ifdef DEBUG
    /* OOps -- What's this ? */
    ErrorF("xf86AllocateScreen - xf86Screens[%d]->pScreen = %p\n",
	   i, xf86Screens[i]->pScreen );
    if ( NULL != xf86Screens[i]->pScreen ) {
      ErrorF("xf86Screens[%d]->pScreen->CreateWindow = %p\n",
	     i, xf86Screens[i]->pScreen->CreateWindow );
    }
#endif
d207 1
a207 1
_X_EXPORT void
d263 1
a263 1
_X_EXPORT int
d283 1
a283 1
_X_EXPORT InputInfoPtr
d310 1
a310 1
_X_EXPORT void
d351 1
a351 1
_X_EXPORT Bool
d422 1
a422 1
_X_EXPORT Bool
d739 1
a739 1
_X_EXPORT void
d750 1
a750 1
_X_EXPORT Bool
d842 1
a842 1
_X_EXPORT Bool
d889 1
a889 1
_X_EXPORT Bool
d924 5
d948 1
a948 1
_X_EXPORT void
d1045 1
a1045 1
_X_EXPORT void
d1176 1
a1176 1
_X_EXPORT void
d1218 1
a1218 1
_X_EXPORT void
d1245 1
a1245 1
_X_EXPORT void
d1257 1
a1257 1
_X_EXPORT void
d1268 1
a1268 1
_X_EXPORT void
d1279 1
a1279 1
_X_EXPORT void
d1290 1
a1290 1
_X_EXPORT void
d1302 1
a1302 1
_X_EXPORT void
d1315 1
a1315 1
xf86LogInit()
d1346 1
a1346 1
xf86CloseLog()
d1356 1
a1356 1
_X_EXPORT const char *
d1370 1
a1370 1
_X_EXPORT int
d1387 1
a1387 1
_X_EXPORT void
d1411 1
a1411 1
_X_EXPORT void
d1437 1
a1437 1
_X_EXPORT int
a1446 4
    if (xf86DoModalias) return 0;

    if (xf86DoProbe) return 1;

d1566 1
a1566 1
_X_EXPORT int
d1592 1
a1592 1
    if ( !xf86DoProbe && !(xf86DoConfigure && xf86DoConfigurePass1) ) {
d1705 1
a1705 3
#ifdef DEBUG
    ErrorF("%s instances found: %d\n", driverName, allocatedInstances);
#endif
d1788 1
a1788 3
#ifdef DEBUG
    ErrorF("%s instances found: %d\n", driverName, numClaimedInstances);
#endif
d1892 1
a1892 2
#ifdef DEBUG
	ErrorF("%s: card at %d:%d:%d is claimed by a Device section\n",
d1894 1
a1894 2
#endif
	
d1926 1
a1926 1
_X_EXPORT void
a1937 2
    xf86SetPriority(TRUE);

a1984 2
    xf86SetPriority(FALSE);

d2013 1
a2013 25
_X_EXPORT void
xf86SetPriority(Bool up)
{
    static int saved_nice;

    if (up) {
#ifdef HAS_SETPRIORITY
	saved_nice = getpriority(PRIO_PROCESS, 0);
	setpriority(PRIO_PROCESS, 0, -20);
#endif
#if defined(SYSV) || defined(SVR4) || defined(linux)
	saved_nice = nice(0);
	nice(-20 - saved_nice);
#endif
    } else {
#ifdef HAS_SETPRIORITY
	setpriority(PRIO_PROCESS, 0, saved_nice);
#endif
#if defined(SYSV) || defined(SVR4) || defined(linux)
	nice(20 + saved_nice);
#endif
    }
}

_X_EXPORT const char *
d2023 2
a2024 2
_X_EXPORT int
xf86GetVerbosity()
d2029 2
a2030 2
_X_EXPORT Pix24Flags
xf86GetPix24()
d2036 2
a2037 2
_X_EXPORT int
xf86GetDepth()
d2043 2
a2044 2
_X_EXPORT rgb
xf86GetWeight()
d2050 2
a2051 2
_X_EXPORT Gamma
xf86GetGamma()
d2057 2
a2058 2
_X_EXPORT Bool
xf86GetFlipPixels()
d2064 2
a2065 2
_X_EXPORT const char *
xf86GetServerName()
d2071 2
a2072 2
_X_EXPORT Bool
xf86ServerIsExiting()
d2078 2
a2079 2
_X_EXPORT Bool
xf86ServerIsResetting()
d2086 1
a2086 1
xf86ServerIsInitialising()
d2092 1
a2092 1
_X_EXPORT Bool
d2095 1
a2095 1
    return xf86DoProbe || xf86DoConfigure;
d2099 2
a2100 9
_X_EXPORT Bool
xf86ServerIsOnlyProbing(void)
{
    return xf86ProbeOnly;
}


_X_EXPORT Bool
xf86CaughtSignal()
d2106 2
a2107 2
_X_EXPORT Bool
xf86GetVidModeAllowNonLocal()
d2113 2
a2114 2
_X_EXPORT Bool
xf86GetVidModeEnabled()
d2119 2
a2120 2
_X_EXPORT Bool
xf86GetModInDevAllowNonLocal()
d2126 2
a2127 2
_X_EXPORT Bool
xf86GetModInDevEnabled()
d2133 2
a2134 2
_X_EXPORT Bool
xf86GetAllowMouseOpenFail()
d2140 2
a2141 2
_X_EXPORT Bool
xf86IsPc98()
d2143 1
a2143 1
#ifdef __i386__
d2150 2
a2151 2
_X_EXPORT void
xf86DisableRandR()
d2157 1
a2157 1
_X_EXPORT CARD32
d2163 1
a2163 1
_X_EXPORT pointer
d2176 1
a2176 1
_X_EXPORT pointer
d2192 1
a2192 1
_X_EXPORT pointer
d2220 1
a2220 1
_X_EXPORT void
d2232 1
a2232 1
_X_EXPORT Bool
a2237 22
/* These two are just ABI stubs, they don't do anything in dlloader world */
_X_EXPORT void
xf86LoaderReqSymLists(const char **list0, ...)
{
}

_X_EXPORT void
xf86LoaderReqSymbols(const char *sym0, ...)
{
}

_X_EXPORT void
xf86LoaderRefSymLists(const char **list0, ...)
{
}

_X_EXPORT void
xf86LoaderRefSymbols(const char *sym0, ...)
{
}


d2247 1
a2247 1
_X_EXPORT void
d2287 1
a2287 1
_X_EXPORT void
d2301 2
a2302 7
    if (((pScrn->racMemFlags & RAC_CURSOR) &&
	 !xf86NoSharedResources(pScrn->scrnIndex,MEM)) ||
	((pScrn->racIoFlags & RAC_CURSOR) &&
	 !xf86NoSharedResources(pScrn->scrnIndex,IO))) {
	useSM = FALSE;
	from = X_PROBED;
    } else if (xf86silkenMouseDisableFlag) {
d2315 1
a2315 1
    pScrn->silkenMouse = useSM && xf86SIGIOSupported();
d2323 1
a2323 1
_X_EXPORT pointer
d2353 16
d2370 16
a2385 1
_X_EXPORT ScrnInfoPtr
d2387 1
a2387 1
			  PciChipsets *p_chip, resList res, EntityProc init,
a2389 1
    PciChipsets *p_id;
d2399 1
a2399 1
	xf86ConfigPciEntityInactive(pEnt, p_chip, res, init,  enter,
a2413 6
    if (p_chip) {
	for (p_id = p_chip; p_id->numChipset != -1; p_id++) {
	    if (pEnt->chipset == p_id->numChipset) break;
	}
	xf86ClaimFixedResources(p_id->resList,entityIndex);
    }
a2415 1
    xf86ClaimFixedResources(res,entityIndex);
d2421 1
a2421 1
_X_EXPORT ScrnInfoPtr
d2451 2
a2452 2
 *  OBSOLETE ! xf86ConfigActivePciEntity() is an obsolete functions.
 *	       They the are likely to be removed. Don't use!
d2455 1
a2455 1
_X_EXPORT Bool
d2457 1
a2457 1
                          PciChipsets *p_chip, resList res, EntityProc init,
a2459 1
    PciChipsets *p_id;
a2468 6
    if (p_chip) {
        for (p_id = p_chip; p_id->numChipset != -1; p_id++) {
            if (pEnt->chipset == p_id->numChipset) break;
        }
        xf86ClaimFixedResources(p_id->resList,entityIndex);
    }
a2469 2

    xf86ClaimFixedResources(res,entityIndex);
d2476 1
a2476 41
/*
 * xf86ConfigPciEntityInactive() -- This functions can be used
 * to configure an inactive entity as well as to reconfigure an
 * previously active entity inactive. If the entity has been
 * assigned to a screen before it will be removed. If p_pci is
 * non-NULL all static resources listed there will be registered.
 */
_X_EXPORT void
xf86ConfigPciEntityInactive(EntityInfoPtr pEnt, PciChipsets *p_chip,
			    resList res, EntityProc init, EntityProc enter,
			    EntityProc leave, pointer private)
{
    PciChipsets *p_id;
    ScrnInfoPtr pScrn;

    if ((pScrn = xf86FindScreenForEntity(pEnt->index)))
	xf86RemoveEntityFromScreen(pScrn,pEnt->index);
    else if (p_chip) {
	for (p_id = p_chip; p_id->numChipset != -1; p_id++) {
	    if (pEnt->chipset == p_id->numChipset) break;
	}
	xf86ClaimFixedResources(p_id->resList,pEnt->index);
    }
    xf86ClaimFixedResources(res,pEnt->index);
    /* shared resources are only needed when entity is active: remove */
    xf86DeallocateResourcesForEntity(pEnt->index, ResShared);
    xf86SetEntityFuncs(pEnt->index,init,enter,leave,private);
}

void
xf86ConfigFbEntityInactive(EntityInfoPtr pEnt, EntityProc init,
			   EntityProc enter, EntityProc leave, pointer private)
{
    ScrnInfoPtr pScrn;

    if ((pScrn = xf86FindScreenForEntity(pEnt->index)))
	xf86RemoveEntityFromScreen(pScrn,pEnt->index);
    xf86SetEntityFuncs(pEnt->index,init,enter,leave,private);
}

_X_EXPORT Bool
d2489 1
a2489 1
_X_EXPORT int
d2497 1
a2497 2
#ifdef DEBUG
    ErrorF("xf86RegisterRootWindowProperty(%d, %ld, %ld, %d, %ld, %p)\n",
a2498 1
#endif
d2534 1
a2534 3
#ifdef DEBUG
    ErrorF("new property filled\n");
#endif
d2537 1
a2537 2
#ifdef DEBUG
      ErrorF("creating xf86RegisteredPropertiesTable[] size %d\n",
a2538 1
#endif
d2547 1
a2547 2
#ifdef DEBUG
    ErrorF("xf86RegisteredPropertiesTable %p\n",
d2549 1
a2549 1
    ErrorF("xf86RegisteredPropertiesTable[%d] %p\n",
a2550 1
#endif
d2558 1
a2558 3
#ifdef DEBUG
	  ErrorF("- next %p\n", (void *)pRegProp);
#endif
d2564 1
a2564 3
#ifdef DEBUG
    ErrorF("xf86RegisterRootWindowProperty succeeded\n");
#endif
d2568 1
a2568 1
_X_EXPORT Bool
d2584 1
a2584 1
_X_EXPORT void
a2587 7
}

_X_EXPORT int
xf86GetMotionEvents(DeviceIntPtr pDev, xTimecoord *buff, unsigned long start,
                    unsigned long stop, ScreenPtr pScreen, BOOL core)
{
    return GetMotionHistory(pDev, buff, start, stop, pScreen, core);
@


1.3
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@a62 1
#include "xf86Version.h"
d359 3
a361 2
    /* This should *really* be handled in drv->UnInit(dev) call instead */
#if 0
a363 1
#endif
a1093 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a1162 6
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	{
	    dosave = (*pScreen->ChangeSaveUnder)(pLayerWin, pLayerWin);
	}
#endif /* DO_SAVE_UNDERS */
a1171 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pLayerWin, pLayerWin);
#endif /* DO_SAVE_UNDERS */
d1536 15
d1686 2
a1687 2
			      xf86AddDeviceToConfigure(drvp->driverName,
						       pPci, -1);
d1805 1
a1805 1
	    if ( xf86CheckPciSlot( pPci ) ) {
a1955 102
_X_EXPORT int
xf86MatchIsaInstances(const char *driverName, SymTabPtr chipsets,
		      IsaChipsets *ISAchipsets, DriverPtr drvp,
		      FindIsaDevProc FindIsaDevice, GDevPtr *devList,
		      int numDevs, int **foundEntities)
{
    SymTabRec *c;
    IsaChipsets *Chips;
    int i;
    int numFound = 0;
    int foundChip = -1;
    int *retEntities = NULL;

    *foundEntities = NULL;

#if defined(__sparc__) || defined(__powerpc__)
    FindIsaDevice = NULL;	/* Temporary */
#endif

    if (xf86DoProbe || (xf86DoConfigure && xf86DoConfigurePass1)) {
	if (FindIsaDevice &&
	    ((foundChip = (*FindIsaDevice)(NULL)) != -1)) {
	    xf86AddDeviceToConfigure(drvp->driverName, NULL, foundChip);
	    return 1;
	}
	return 0;
    }

    for (i = 0; i < numDevs; i++) {
	MessageType from = X_CONFIG;
	GDevPtr dev = NULL;
	GDevPtr devBus = NULL;

	if (devList[i]->busID && *devList[i]->busID) {
	    if (xf86ParseIsaBusString(devList[i]->busID)) {
		if (devBus) xf86MsgVerb(X_WARNING,0,
					"%s: More than one matching Device "
					"section for ISA-Bus found: %s\n",
					driverName,devList[i]->identifier);
		else devBus = devList[i];
	    }
	} else {
	    if (xf86IsPrimaryIsa()) {
		if (dev) xf86MsgVerb(X_WARNING,0,
				     "%s: More than one matching "
				     "Device section found: %s\n",
				     driverName,devList[i]->identifier);
		else dev = devList[i];
	    }
	}
	if (devBus) dev = devBus;
	if (dev) {
	    if (dev->chipset) {
		for (c = chipsets; c->token >= 0; c++) {
		    if (xf86NameCmp(c->name, dev->chipset) == 0)
			break;
		}
		if (c->token == -1) {
		    xf86MsgVerb(X_WARNING, 0, "%s: Chipset \"%s\" in Device "
				"section \"%s\" isn't valid for this driver\n",
				driverName, dev->chipset,
				dev->identifier);
		} else
		    foundChip = c->token;
	    } else {
		if (FindIsaDevice) foundChip = (*FindIsaDevice)(dev);
                                                        /* Probe it */
		from = X_PROBED;
	    }
	}
	
	/* Check if the chip type is listed in the chipset table - for sanity*/

	if (foundChip >= 0){
	    for (Chips = ISAchipsets; Chips->numChipset >= 0; Chips++) {
		if (Chips->numChipset == foundChip)
		    break;
	    }
	    if (Chips->numChipset == -1){
		foundChip = -1;
		xf86MsgVerb(X_WARNING,0,
			    "%s: Driver detected unknown ISA-Bus Chipset\n",
			    driverName);
	    }
	}
	if (foundChip != -1) {
	    numFound++;
	    retEntities = xnfrealloc(retEntities,numFound * sizeof(int));
	    retEntities[numFound - 1] =
	    xf86ClaimIsaSlot(drvp,foundChip,dev, dev->active ? TRUE : FALSE);
	    for (c = chipsets; c->token >= 0; c++) {
		if (c->token == foundChip)
		    break;
	    }
	    xf86Msg(from, "Chipset %s found\n", c->name);
	}
    }
    *foundEntities = retEntities;

    return numFound;
}

a1994 8
	/* XXX How critical is this? */
    	if (!xf86DisableInterrupts())
    	{
	    (*ClockFunc)(pScrn, CLK_REG_RESTORE);
	    ErrorF("Failed to disable interrupts during clock probe.  If\n");
	    ErrorF("your OS does not support disabling interrupts, then you\n");
	    FatalError("must specify a Clocks line in the XF86Config file.\n");
	}
a2014 2
	xf86EnableInterrupts();

a2225 6
xf86GetVersion()
{
    return XF86_VERSION_CURRENT;
}

_X_EXPORT CARD32
a2447 43
/*
 * xf86ConfigIsa/PciEntity() -- These helper functions assign an
 * active entity to a screen, registers its fixed resources, assign
 * special enter/leave functions and their private scratch area to
 * this entity, take the dog for a walk...
 */
_X_EXPORT ScrnInfoPtr
xf86ConfigIsaEntity(ScrnInfoPtr pScrn, int scrnFlag, int entityIndex,
			  IsaChipsets *i_chip, resList res, EntityProc init,
			  EntityProc enter, EntityProc leave, pointer private)
{
    IsaChipsets *i_id;
    EntityInfoPtr pEnt = xf86GetEntityInfo(entityIndex);
    if (!pEnt) return pScrn;

    if (!(pEnt->location.type == BUS_ISA)) {
	xfree(pEnt);
	return pScrn;
    }

    if (!pEnt->active) {
	xf86ConfigIsaEntityInactive(pEnt, i_chip, res, init,  enter,
				    leave,  private);
	xfree(pEnt);
	return pScrn;
    }

    if (!pScrn)
	pScrn = xf86AllocateScreen(pEnt->driver,scrnFlag);
    xf86AddEntityToScreen(pScrn,entityIndex);

    if (i_chip) {
	for (i_id = i_chip; i_id->numChipset != -1; i_id++) {
	    if (pEnt->chipset == i_id->numChipset) break;
	}
	xf86ClaimFixedResources(i_id->resList,entityIndex);
    }
    xfree(pEnt);
    xf86ClaimFixedResources(res,entityIndex);
    xf86SetEntityFuncs(entityIndex,init,enter,leave,private);

    return pScrn;
}
d2523 2
a2524 3
 *  OBSOLETE ! xf86ConfigActiveIsaEntity() and xf86ConfigActivePciEntity()
 *             are obsolete functions. They the are likely to be removed
 *             Don't use!
a2525 29
_X_EXPORT Bool
xf86ConfigActiveIsaEntity(ScrnInfoPtr pScrn, int entityIndex,
                          IsaChipsets *i_chip, resList res, EntityProc init,
                          EntityProc enter, EntityProc leave, pointer private)
{
    IsaChipsets *i_id;
    EntityInfoPtr pEnt = xf86GetEntityInfo(entityIndex);
    if (!pEnt) return FALSE;

    if (!pEnt->active || !(pEnt->location.type == BUS_ISA)) {
        xfree(pEnt);
        return FALSE;
    }

    xf86AddEntityToScreen(pScrn,entityIndex);

    if (i_chip) {
        for (i_id = i_chip; i_id->numChipset != -1; i_id++) {
            if (pEnt->chipset == i_id->numChipset) break;
        }
        xf86ClaimFixedResources(i_id->resList,entityIndex);
    }
    xfree(pEnt);
    xf86ClaimFixedResources(res,entityIndex);
    if (!xf86SetEntityFuncs(entityIndex,init,enter,leave,private))
        return FALSE;

    return TRUE;
}
d2558 1
a2558 1
 * xf86ConfigPci/IsaEntityInactive() -- These functions can be used
d2561 1
a2561 1
 * assigned to a screen before it will be removed. If p_pci(p_isa) is
a2585 22
_X_EXPORT void
xf86ConfigIsaEntityInactive(EntityInfoPtr pEnt, IsaChipsets *i_chip,
			    resList res, EntityProc init, EntityProc enter,
			    EntityProc leave, pointer private)
{
    IsaChipsets *i_id;
    ScrnInfoPtr pScrn;

    if ((pScrn = xf86FindScreenForEntity(pEnt->index)))
	xf86RemoveEntityFromScreen(pScrn,pEnt->index);
    else if (i_chip) {
	for (i_id = i_chip; i_id->numChipset != -1; i_id++) {
	    if (pEnt->chipset == i_id->numChipset) break;
	}
	xf86ClaimFixedResources(i_id->resList,pEnt->index);
    }
    xf86ClaimFixedResources(res,pEnt->index);
    /* shared resources are only needed when entity is active: remove */
    xf86DeallocateResourcesForEntity(pEnt->index, ResShared);
    xf86SetEntityFuncs(pEnt->index,init,enter,leave,private);
}

d2725 1
a2725 7
                    unsigned long stop, ScreenPtr pScreen)
{
    return GetMotionHistory(pDev, buff, start, stop, pScreen);
}

_X_EXPORT void
xf86getsecs(long * secs, long * usecs)
d2727 1
a2727 9
    struct timeval tv;

    X_GETTIMEOFDAY(&tv);
    if (secs)
	*secs = tv.tv_sec;
    if (usecs)
	*usecs= tv.tv_usec;

    return;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a450 4
#ifndef GLOBAL_DEFAULT_FBBPP
#define GLOBAL_DEFAULT_FBBPP 32
#endif

a527 1
	    scrp->bitsPerPixel = GLOBAL_DEFAULT_FBBPP;
d1483 2
@


1.1
log
@Initial revision
@
text
@a0 1

d41 3
d95 1
a95 1
	(void) memcpy( xf86DriverList[xf86NumDrivers - 1], driver, 
d146 15
a160 2
_X_EXPORT void
xf86AddModuleInfo(ModuleInfoPtr info, pointer module)
d162 6
a167 3
    /* Don't add null entries */
    if (!module)
	return;
d169 2
a170 2
    if (xf86ModuleInfoList == NULL)
	xf86NumModuleInfos = 0;
d172 4
a175 7
    xf86NumModuleInfos++;
    xf86ModuleInfoList = xnfrealloc(xf86ModuleInfoList,
				    xf86NumModuleInfos * sizeof(ModuleInfoPtr));
    xf86ModuleInfoList[xf86NumModuleInfos - 1] = xnfalloc(sizeof(ModuleInfoRec));
    *xf86ModuleInfoList[xf86NumModuleInfos - 1] = *info;
    xf86ModuleInfoList[xf86NumModuleInfos - 1]->module = module;
    xf86ModuleInfoList[xf86NumModuleInfos - 1]->refCount = 0;
a180 6
    if (xf86ModuleInfoList[idx]) {
	if (xf86ModuleInfoList[idx]->module)
	    UnloadModule(xf86ModuleInfoList[idx]->module);
	xfree(xf86ModuleInfoList[idx]);
	xf86ModuleInfoList[idx] = NULL;
    }
a182 1

d226 1
a226 1
    
d278 1
a278 1
    
d311 1
a311 2
/* Allocate a new InputInfoRec and add it to the head xf86InputDevs. */

d315 1
a315 1
    InputInfoPtr new;
d323 7
a329 2
    new->next = xf86InputDevs;
    xf86InputDevs = new;
d360 2
d364 1
a469 10
#if BITMAP_SCANLINE_UNIT == 64
    /*
     * For platforms with 64-bit scanlines, modify the driver's depth24flags
     * to remove preferences for packed 24bpp modes, which are not currently
     * supported on these platforms.
     */
    depth24flags &= ~(SupportConvert32to24 | SupportConvert32to24 |
		      PreferConvert24to32 | PreferConvert32to24);
#endif
     
d928 1
a928 1
    xf86MonPtr DDC = (xf86MonPtr)(scrp->monitor->DDC); 
d981 1
a981 1
    xf86MonPtr DDC = (xf86MonPtr)(pScrn->monitor->DDC); 
d991 1
a991 1
       * but cm for monitor 
d1035 1
a1035 1
		       "Probed monitor is %dx%d mm, using Displaysize %dx%d mm\n", 
a1099 1
    RegionPtr	pOldClip = NULL, bsExposed;
d1130 1
a1130 1
    
d1155 1
a1155 1
    
d1157 1
a1157 1
    
a1159 6
	if (pWin->backStorage)
	{
	    pOldClip = REGION_CREATE(pScreen, NullBox, 1);
	    REGION_COPY(pScreen, pOldClip, &pWin->clipList);
	}

a1182 22
    if (pWin->backStorage &&
	((pWin->backingStore == Always) || WasViewable))
    {
	if (!WasViewable)
	    pOldClip = &pWin->clipList; /* a convenient empty region */
	bsExposed = (*pScreen->TranslateBackingStore)
			     (pWin, 0, 0, pOldClip,
			      pWin->drawable.x, pWin->drawable.y);
	if (WasViewable)
	    REGION_DESTROY(pScreen, pOldClip);
	if (bsExposed)
	{
	    RegionPtr	valExposed = NullRegion;
    
	    if (pWin->valdata)
		valExposed = &pWin->valdata->after.exposed;
	    (*pScreen->WindowExposures) (pWin, valExposed, bsExposed);
	    if (valExposed)
		REGION_EMPTY(pScreen, valExposed);
	    REGION_DESTROY(pScreen, bsExposed);
	}
    }
d1233 1
a1233 1
	 * Restore all of the clip lists on the screen 
d1242 1
a1242 1
	 * Empty all of the clip lists on the screen 
d1359 1
a1359 1
    char *lf;
d1363 1
a1363 1
    
d1383 2
a1478 3
#define MAXDRIVERS 64	/* A >hack<, to be sure ... */


d1490 1
a1490 1
  
d1498 2
a1499 2
     * ChipProbe can call 
     * int xf86MatchDevice(char * drivername, GDevPtr ** sectlist) 
d1503 1
a1503 1
     * 
d1509 1
a1509 1
    
d1539 1
a1539 1
    
d1554 1
a1554 1
    pciVideoPtr	pci;
d1565 1
a1565 1
 * 
d1581 1
a1581 1
 * 
d1596 1
a1596 1
xf86MatchPciInstances(const char *driverName, int vendorID, 
d1602 2
a1603 1
    pciVideoPtr pPci, *ppPci;
a1613 2
    if (!xf86PciVideoInfo)
	return 0;
d1623 3
a1625 1
	for (ppPci = xf86PciVideoInfo ; *ppPci != NULL ; ppPci++) {
d1629 2
a1630 1
	instances = xnfalloc( max_entries * sizeof(struct Inst) );
d1633 3
a1635 3
    for (ppPci = xf86PciVideoInfo; *ppPci != NULL; ppPci++) {
	unsigned device_class = ((*ppPci)->class << 16)
	    | ((*ppPci)->subclass << 8) | ((*ppPci)->interface);
a1638 2
	pPci = *ppPci;

d1663 3
a1665 3
	    if ( (vendor_id == pPci->vendor)
		 || ((vendorID == PCI_VENDOR_GENERIC) && (match_class == device_class)) ) {
		if ( !foundVendor && (instances != NULL) ) {
d1667 1
a1667 1
		    instances[allocatedInstances - 1].pci = *ppPci;
a1671 1
		    foundVendor = TRUE;
d1673 4
a1676 1
		if ( (device_id == pPci->chipType)
d1686 1
a1686 2
			if ( xf86CheckPciSlot(pPci->bus, pPci->device,
					      pPci->func) ) {
d1688 2
a1689 2
			      xf86AddDeviceToConfigure( drvp->driverName,
							pPci, -1 );
d1712 2
d1747 1
a1747 1
        if (devList[j]->screen > 0 && devList[j]->busID 
d1751 3
a1753 2
	        if (xf86ComparePciBusString(devList[j]->busID, pPci->bus,
					    pPci->device,
d1773 4
a1776 3
		if (xf86ComparePciBusString(devList[j]->busID, pPci->bus,
					   pPci->device,
					   pPci->func) &&
d1778 1
a1778 1
		   
d1787 1
a1787 1
		} 
d1789 2
a1790 2
		/* 
		 * if device section without BusID is found 
d1805 1
a1805 1
	if (devBus) dev = devBus;  /* busID preferred */ 
d1807 1
a1807 1
	    if (xf86CheckPciSlot(pPci->bus, pPci->device, pPci->func)) {
d1809 3
a1811 2
			    "for instance (BusID PCI:%i:%i:%i) found\n",
			    driverName, pPci->bus, pPci->device, pPci->func);
d1922 1
a1922 2
        if (instances[i].screen == 0 &&
	    !xf86CheckPciSlot(pPci->bus, pPci->device, pPci->func))
d1927 1
a1927 1
	       driverName, pPci->bus, pPci->device, pPci->func);
d1933 4
a1936 5
	retEntities[numFound - 1]
	    = xf86ClaimPciSlot(pPci->bus, pPci->device,
			       pPci->func,drvp,	instances[i].chip,
			       instances[i].dev,instances[i].dev->active ?
			       TRUE : FALSE);
d1940 1
a1940 1
	        if (pEnt->busType != BUS_PCI)
d1942 1
a1942 3
	        if (pEnt->pciBusId.bus == pPci->bus &&
		    pEnt->pciBusId.device == pPci->device &&
		    pEnt->pciBusId.func == pPci->func) {
d2022 1
a2022 1
	    } else { 
d2033 1
a2033 1
		if (Chips->numChipset == foundChip) 
d2056 1
a2056 1
    
d2080 1
a2080 1
    for (i = 0; i < num; i++) 
d2093 1
a2093 1
	    
d2107 1
a2107 1
	while ((inb(status) & maskval) == 0x00) 
d2111 1
a2111 1
	while ((inb(status) & maskval) == maskval) 
d2115 1
a2115 1
	while ((inb(status) & maskval) == 0x00) 
d2117 2
a2118 2
    
	for (rcnt = 0; rcnt < 5; rcnt++) 
d2120 1
a2120 1
	    while (!(inb(status) & maskval)) 
d2122 1
a2122 1
	    while ((inb(status) & maskval)) 
d2125 1
a2125 1
    
d2136 1
a2136 1
    for (i = 0; i < num; i++) 
d2144 1
a2144 1
	    else 
d2147 1
a2147 1
                    (((float)knownclkvalue) * pScrn->clock[knownclkindex]) / 
d2158 1
a2158 1
    pScrn->numClocks = num; 
d2325 1
a2325 1
#if defined(i386) || defined(__i386__)
d2379 1
a2379 1
 */             
d2386 1
a2386 1
    
d2389 1
a2389 4
    
#ifndef NORMALISE_MODULE_NAME
    Name = xstrdup(name);
#else
a2391 1
#endif
d2457 1
a2457 1
_X_EXPORT void 
d2497 1
a2497 1
_X_EXPORT void 
d2508 1
a2508 1
    
d2511 1
a2511 1
    if (((pScrn->racMemFlags & RAC_CURSOR) && 
d2513 1
a2513 1
	((pScrn->racIoFlags & RAC_CURSOR) && 
d2528 1
a2528 1
     * like Xqueue work correctly with this too.
d2582 1
a2582 1
    
d2596 1
a2596 1
	pScrn = xf86AllocateScreen(pEnt->driver,scrnFlag); 
d2621 1
a2621 1
    if (!(pEnt->location.type == BUS_PCI) 
d2658 1
a2658 1
		   EntityProc init, EntityProc enter, EntityProc leave, 
d2663 1
a2663 1
    
d2676 1
a2676 1
	pScrn = xf86AllocateScreen(pEnt->driver,scrnFlag); 
d2698 1
a2698 1
 
d2703 1
a2703 1
 
d2705 1
a2705 1
 
d2716 1
a2716 1
 
d2719 1
a2719 1
 
d2728 1
a2728 1
 
d2734 1
a2734 1
 
d2742 1
a2742 1
 
d2746 1
a2746 1
 
d2802 1
a2802 1
xf86ConfigFbEntityInactive(EntityInfoPtr pEnt, EntityProc init, 
d2871 1
a2871 1
 
d2913 1
a2913 1
    return(Success);    
d2930 27
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d93 1
a93 1
	(void) memcpy( xf86DriverList[xf86NumDrivers - 1], driver,
a143 26
InputDriverPtr
xf86LookupInputDriver(const char *name)
{
    int i;

    for (i = 0; i < xf86NumInputDrivers; i++) {
       if (xf86InputDriverList[i] && xf86InputDriverList[i]->driverName &&
           xf86NameCmp(name, xf86InputDriverList[i]->driverName) == 0)
           return xf86InputDriverList[i];
    }
    return NULL;
}

InputInfoPtr
xf86LookupInput(const char *name)
{
    InputInfoPtr p;

    for (p = xf86InputDevs; p != NULL; p = p->next) {
        if (strcmp(name, p->name) == 0)
            return p;
    }

    return NULL;
}

d218 1
a218 1

d270 1
a270 1

a347 2
    /* This should *really* be handled in drv->UnInit(dev) call instead */
#if 0
a349 1
#endif
d455 10
d923 1
a923 1
    xf86MonPtr DDC = (xf86MonPtr)(scrp->monitor->DDC);
d976 1
a976 1
    xf86MonPtr DDC = (xf86MonPtr)(pScrn->monitor->DDC);
d986 1
a986 1
       * but cm for monitor
d1030 1
a1030 1
		       "Probed monitor is %dx%d mm, using Displaysize %dx%d mm\n",
d1126 1
a1126 1

d1151 1
a1151 1

d1153 1
a1153 1

d1198 1
a1198 1

d1257 1
a1257 1
	 * Restore all of the clip lists on the screen
d1266 1
a1266 1
	 * Empty all of the clip lists on the screen
d1387 1
a1387 1

d1515 1
a1515 1

d1523 2
a1524 2
     * ChipProbe can call
     * int xf86MatchDevice(char * drivername, GDevPtr ** sectlist)
d1528 1
a1528 1
     *
d1534 1
a1534 1

d1564 1
a1564 1

d1590 1
a1590 1
 *
d1606 1
a1606 1
 *
d1621 1
a1621 1
xf86MatchPciInstances(const char *driverName, int vendorID,
d1700 1
a1700 1
		     || ((vendorID == PCI_VENDOR_GENERIC)
d1711 1
a1711 1
			    GDevPtr pGDev =
d1769 1
a1769 1
        if (devList[j]->screen > 0 && devList[j]->busID
d1798 1
a1798 1

d1807 1
a1807 1
		}
d1809 2
a1810 2
		/*
		 * if device section without BusID is found
d1825 1
a1825 1
	if (devBus) dev = devBus;  /* busID preferred */
d2045 1
a2045 1
	    } else {
d2056 1
a2056 1
		if (Chips->numChipset == foundChip)
d2079 1
a2079 1

d2103 1
a2103 1
    for (i = 0; i < num; i++)
d2116 1
a2116 1

d2130 1
a2130 1
	while ((inb(status) & maskval) == 0x00)
d2134 1
a2134 1
	while ((inb(status) & maskval) == maskval)
d2138 1
a2138 1
	while ((inb(status) & maskval) == 0x00)
d2140 2
a2141 2

	for (rcnt = 0; rcnt < 5; rcnt++)
d2143 1
a2143 1
	    while (!(inb(status) & maskval))
d2145 1
a2145 1
	    while ((inb(status) & maskval))
d2148 1
a2148 1

d2159 1
a2159 1
    for (i = 0; i < num; i++)
d2167 1
a2167 1
	    else
d2170 1
a2170 1
                    (((float)knownclkvalue) * pScrn->clock[knownclkindex]) /
d2181 1
a2181 1
    pScrn->numClocks = num;
d2402 1
a2402 1
 */
d2409 1
a2409 1

d2412 4
a2415 1

d2418 1
d2484 1
a2484 1
_X_EXPORT void
d2524 1
a2524 1
_X_EXPORT void
d2535 1
a2535 1

d2538 1
a2538 1
    if (((pScrn->racMemFlags & RAC_CURSOR) &&
d2540 1
a2540 1
	((pScrn->racIoFlags & RAC_CURSOR) &&
d2555 1
a2555 1
     * work correctly with this too.
d2609 1
a2609 1

d2623 1
a2623 1
	pScrn = xf86AllocateScreen(pEnt->driver,scrnFlag);
d2648 1
a2648 1
    if (!(pEnt->location.type == BUS_PCI)
d2685 1
a2685 1
		   EntityProc init, EntityProc enter, EntityProc leave,
d2690 1
a2690 1

d2703 1
a2703 1
	pScrn = xf86AllocateScreen(pEnt->driver,scrnFlag);
d2725 1
a2725 1

d2730 1
a2730 1

d2732 1
a2732 1

d2743 1
a2743 1

d2746 1
a2746 1

d2755 1
a2755 1

d2761 1
a2761 1

d2769 1
a2769 1

d2773 1
a2773 1

d2829 1
a2829 1
xf86ConfigFbEntityInactive(EntityInfoPtr pEnt, EntityProc init,
d2898 1
a2898 1

d2940 1
a2940 1
    return(Success);
a2956 13
}

_X_EXPORT void
xf86MotionHistoryAllocate(LocalDevicePtr local)
{
    AllocateMotionHistory(local->dev);
}

_X_EXPORT int
xf86GetMotionEvents(DeviceIntPtr pDev, xTimecoord *buff, unsigned long start,
                    unsigned long stop, ScreenPtr pScreen)
{
    return GetMotionHistory(pDev, buff, start, stop, pScreen);
@

