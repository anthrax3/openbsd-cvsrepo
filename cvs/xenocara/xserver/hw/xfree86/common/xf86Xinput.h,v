head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.6
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.24;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.51;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.07;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.12;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.12;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.39;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright 1995-1999 by Frederic Lepied, France. <Lepied@@XFree86.org>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is  hereby granted without fee, provided that
 * the  above copyright   notice appear  in   all  copies and  that both  that
 * copyright  notice   and   this  permission   notice  appear  in  supporting
 * documentation, and that   the  name of  Frederic   Lepied not  be  used  in
 * advertising or publicity pertaining to distribution of the software without
 * specific,  written      prior  permission.     Frederic  Lepied   makes  no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * FREDERIC  LEPIED DISCLAIMS ALL   WARRANTIES WITH REGARD  TO  THIS SOFTWARE,
 * INCLUDING ALL IMPLIED   WARRANTIES OF MERCHANTABILITY  AND   FITNESS, IN NO
 * EVENT  SHALL FREDERIC  LEPIED BE   LIABLE   FOR ANY  SPECIAL, INDIRECT   OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA  OR PROFITS, WHETHER  IN  AN ACTION OF  CONTRACT,  NEGLIGENCE OR OTHER
 * TORTIOUS  ACTION, ARISING    OUT OF OR   IN  CONNECTION  WITH THE USE    OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */

/*
 * Copyright (c) 2000-2002 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifndef _xf86Xinput_h
#define _xf86Xinput_h

#include "xf86.h"
#include "xf86str.h"
#include "inputstr.h"
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "XIstubs.h"

/* Input device flags */
#define XI86_ALWAYS_CORE	0x04    /* device always controls the pointer */
/* the device sends Xinput and core pointer events */
#define XI86_SEND_CORE_EVENTS	XI86_ALWAYS_CORE
/* 0x08 is reserved for legacy XI86_SEND_DRAG_EVENTS, do not use for now */
/* server-internal only */
#define XI86_DEVICE_DISABLED    0x10    /* device was disabled before vt switch */
#define XI86_SERVER_FD		0x20	/* fd is managed by xserver */

/* Input device driver capabilities */
#define XI86_DRV_CAP_SERVER_FD	0x01

/* This holds the input driver entry and module information. */
typedef struct _InputDriverRec {
    int driverVersion;
    const char *driverName;
    void (*Identify) (int flags);
    int (*PreInit) (struct _InputDriverRec * drv,
                    struct _InputInfoRec * pInfo, int flags);
    void (*UnInit) (struct _InputDriverRec * drv,
                    struct _InputInfoRec * pInfo, int flags);
    void *module;
    const char **default_options;
    int capabilities;
} InputDriverRec, *InputDriverPtr;

/* This is to input devices what the ScrnInfoRec is to screens. */

struct _InputInfoRec {
    struct _InputInfoRec *next;
    char *name;
    char *driver;

    int flags;

    Bool (*device_control) (DeviceIntPtr device, int what);
    void (*read_input) (struct _InputInfoRec * local);
    int (*control_proc) (struct _InputInfoRec * local, xDeviceCtl * control);
    int (*switch_mode) (ClientPtr client, DeviceIntPtr dev, int mode);
    int (*set_device_valuators)
     (struct _InputInfoRec * local,
      int *valuators, int first_valuator, int num_valuators);

    int fd;
    int major;
    int minor;
    DeviceIntPtr dev;
    void *private;
    const char *type_name;
    InputDriverPtr drv;
    void *module;
    XF86OptionPtr options;
    InputAttributes *attrs;
};

/* xf86Globals.c */
extern InputInfoPtr xf86InputDevs;

/* xf86Xinput.c */
extern _X_EXPORT void xf86PostMotionEvent(DeviceIntPtr device, int is_absolute,
                                          int first_valuator, int num_valuators,
                                          ...);
extern _X_EXPORT void xf86PostMotionEventP(DeviceIntPtr device, int is_absolute,
                                           int first_valuator,
                                           int num_valuators,
                                           const int *valuators);
extern _X_EXPORT void xf86PostMotionEventM(DeviceIntPtr device, int is_absolute,
                                           const ValuatorMask *mask);
extern _X_EXPORT void xf86PostProximityEvent(DeviceIntPtr device, int is_in,
                                             int first_valuator,
                                             int num_valuators, ...);
extern _X_EXPORT void xf86PostProximityEventP(DeviceIntPtr device, int is_in,
                                              int first_valuator,
                                              int num_valuators,
                                              const int *valuators);
extern _X_EXPORT void xf86PostProximityEventM(DeviceIntPtr device, int is_in,
                                              const ValuatorMask *mask);
extern _X_EXPORT void xf86PostButtonEvent(DeviceIntPtr device, int is_absolute,
                                          int button, int is_down,
                                          int first_valuator, int num_valuators,
                                          ...);
extern _X_EXPORT void xf86PostButtonEventP(DeviceIntPtr device, int is_absolute,
                                           int button, int is_down,
                                           int first_valuator,
                                           int num_valuators,
                                           const int *valuators);
extern _X_EXPORT void xf86PostButtonEventM(DeviceIntPtr device, int is_absolute,
                                           int button, int is_down,
                                           const ValuatorMask *mask);
extern _X_EXPORT void xf86PostKeyEvent(DeviceIntPtr device,
                                       unsigned int key_code, int is_down);
extern _X_EXPORT void xf86PostKeyEventM(DeviceIntPtr device,
                                        unsigned int key_code, int is_down);
extern _X_EXPORT void xf86PostKeyEventP(DeviceIntPtr device,
                                        unsigned int key_code, int is_down);
extern _X_EXPORT void xf86PostKeyboardEvent(DeviceIntPtr device,
                                            unsigned int key_code, int is_down);
extern _X_EXPORT void xf86PostTouchEvent(DeviceIntPtr dev, uint32_t touchid,
                                         uint16_t type, uint32_t flags,
                                         const ValuatorMask *mask);
extern _X_EXPORT InputInfoPtr xf86FirstLocalDevice(void);
extern _X_EXPORT int xf86ScaleAxis(int Cx, int to_max, int to_min, int from_max,
                                   int from_min);
extern _X_EXPORT void xf86ProcessCommonOptions(InputInfoPtr pInfo,
                                               XF86OptionPtr options);
extern _X_EXPORT Bool xf86InitValuatorAxisStruct(DeviceIntPtr dev, int axnum,
                                                 Atom label, int minval,
                                                 int maxval, int resolution,
                                                 int min_res, int max_res,
                                                 int mode);
extern _X_EXPORT void xf86InitValuatorDefaults(DeviceIntPtr dev, int axnum);
extern _X_EXPORT void xf86AddEnabledDevice(InputInfoPtr pInfo);
extern _X_EXPORT void xf86RemoveEnabledDevice(InputInfoPtr pInfo);
extern _X_EXPORT void xf86DisableDevice(DeviceIntPtr dev, Bool panic);
extern _X_EXPORT void xf86EnableDevice(DeviceIntPtr dev);
extern _X_EXPORT void xf86InputEnableVTProbe(void);

/* not exported */
int xf86NewInputDevice(InputInfoPtr pInfo, DeviceIntPtr *pdev, BOOL is_auto);
InputInfoPtr xf86AllocateInput(void);

/* xf86Helper.c */
extern _X_EXPORT void xf86AddInputDriver(InputDriverPtr driver, void *module,
                                         int flags);
extern _X_EXPORT void xf86DeleteInputDriver(int drvIndex);
extern _X_EXPORT InputDriverPtr xf86LookupInputDriver(const char *name);
extern _X_EXPORT InputInfoPtr xf86LookupInput(const char *name);
extern _X_EXPORT void xf86DeleteInput(InputInfoPtr pInp, int flags);
extern _X_EXPORT void xf86MotionHistoryAllocate(InputInfoPtr pInfo);
extern _X_EXPORT void
xf86IDrvMsgVerb(InputInfoPtr dev,
                MessageType type, int verb, const char *format, ...)
_X_ATTRIBUTE_PRINTF(4, 5);
extern _X_EXPORT void
xf86IDrvMsg(InputInfoPtr dev, MessageType type, const char *format, ...)
_X_ATTRIBUTE_PRINTF(3, 4);
extern _X_EXPORT void
xf86VIDrvMsgVerb(InputInfoPtr dev,
                 MessageType type, int verb, const char *format, va_list args)
_X_ATTRIBUTE_PRINTF(4, 0);

/* xf86Option.c */
extern _X_EXPORT void
xf86CollectInputOptions(InputInfoPtr pInfo, const char **defaultOpts);

#endif                          /* _xf86Xinput_h */
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d151 1
a151 3
                                       unsigned int key_code, int is_down,
                                       int is_absolute, int first_valuator,
                                       int num_valuators, ...);
d153 1
a153 3
                                        unsigned int key_code, int is_down,
                                        int is_absolute,
                                        const ValuatorMask *mask);
d155 1
a155 4
                                        unsigned int key_code, int is_down,
                                        int is_absolute, int first_valuator,
                                        int num_valuators,
                                        const int *valuators);
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d3 1
a3 1
 *                                                                            
d12 2
a13 2
 * is provided "as is" without express or implied warranty.                   
 *                                                                            
d54 1
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d67 4
d81 1
a81 1
    pointer module;
d83 1
d88 1
a88 1
typedef struct _InputInfoRec {
d104 2
d107 1
a107 1
    pointer private;
d110 1
a110 1
    pointer module;
d113 1
a113 1
} *InputInfoPtr;
d182 1
d189 1
a189 1
extern _X_EXPORT void xf86AddInputDriver(InputDriverPtr driver, pointer module,
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d64 3
d71 1
a71 1
    char *driverName;
d78 1
a78 1
    char **default_options;
d101 1
a101 1
    char *type_name;
@


1.5
log
@Update to xserver 1.11.2
@
text
@a50 1

d61 1
a61 1
#define XI86_ALWAYS_CORE	0x04 /* device always controls the pointer */
d67 9
a75 10
    int			    driverVersion;
    char *		    driverName;
    void		    (*Identify)(int flags);
    int			    (*PreInit)(struct _InputDriverRec *drv,
				       struct _InputInfoRec* pInfo, int flags);
    void		    (*UnInit)(struct _InputDriverRec *drv,
				      struct _InputInfoRec *pInfo,
				      int flags);
    pointer		    module;
    char **		    default_options;
d82 2
a83 2
    char *		    name;
    char *		    driver;
d85 1
a85 1
    int			    flags;
d87 16
a102 19
    Bool		    (*device_control)(DeviceIntPtr device, int what);
    void		    (*read_input)(struct _InputInfoRec *local);
    int			    (*control_proc)(struct _InputInfoRec *local,
					   xDeviceCtl *control);
    int			    (*switch_mode)(ClientPtr client, DeviceIntPtr dev,
					  int mode);
    int                     (*set_device_valuators)
				(struct _InputInfoRec *local,
				 int *valuators, int first_valuator,
				 int num_valuators);

    int			    fd;
    DeviceIntPtr	    dev;
    pointer		    private;
    char *		    type_name;
    InputDriverPtr	    drv;
    pointer		    module;
    pointer		    options;
    InputAttributes         *attrs;
d110 2
a111 1
			 int first_valuator, int num_valuators, ...);
d113 3
a115 1
			 int first_valuator, int num_valuators, const int *valuators);
d117 1
a117 1
			 const ValuatorMask *mask);
d119 6
a124 3
			    int first_valuator, int num_valuators, ...);
extern _X_EXPORT void xf86PostProximityEventP(DeviceIntPtr device, int is_in, int first_valuator,
			     int num_valuators, const int *valuators);
d126 31
a156 19
			 const ValuatorMask *mask);
extern _X_EXPORT void xf86PostButtonEvent(DeviceIntPtr device, int is_absolute, int button,
		    	 int is_down, int first_valuator, int num_valuators,
			 ...);
extern _X_EXPORT void xf86PostButtonEventP(DeviceIntPtr device, int is_absolute, int button,
			  int is_down, int first_valuator, int num_valuators,
			  const int *valuators);
extern _X_EXPORT void xf86PostButtonEventM(DeviceIntPtr device, int is_absolute, int button,
			  int is_down, const ValuatorMask *mask);
extern _X_EXPORT void xf86PostKeyEvent(DeviceIntPtr device, unsigned int key_code, int is_down,
		      int is_absolute, int first_valuator, int num_valuators,
		      ...);
extern _X_EXPORT void xf86PostKeyEventM(DeviceIntPtr device, unsigned int key_code, int is_down,
		       int is_absolute, const ValuatorMask *mask);
extern _X_EXPORT void xf86PostKeyEventP(DeviceIntPtr device, unsigned int key_code, int is_down,
		       int is_absolute, int first_valuator, int num_valuators,
		       const int *valuators);
extern _X_EXPORT void xf86PostKeyboardEvent(DeviceIntPtr device, unsigned int key_code,
                           int is_down);
d158 9
a166 6
extern _X_EXPORT int xf86ScaleAxis(int Cx, int to_max, int to_min, int from_max, int from_min);
extern _X_EXPORT void xf86XInputSetScreen(InputInfoPtr pInfo, int screen_number, int x, int y);
extern _X_EXPORT void xf86ProcessCommonOptions(InputInfoPtr pInfo, pointer options);
extern _X_EXPORT void xf86InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval,
				int maxval, int resolution, int min_res,
				int max_res, int mode);
d172 1
d178 2
a179 1
extern _X_EXPORT void xf86AddInputDriver(InputDriverPtr driver, pointer module, int flags);
d185 11
a195 11
extern _X_EXPORT void xf86IDrvMsgVerb(InputInfoPtr dev,
				      MessageType type, int verb,
				      const char *format, ...) _X_ATTRIBUTE_PRINTF(4,5);
extern _X_EXPORT void xf86IDrvMsg(InputInfoPtr dev,
				  MessageType type,
				  const char *format, ...) _X_ATTRIBUTE_PRINTF(3,4);
extern _X_EXPORT void xf86VIDrvMsgVerb(InputInfoPtr dev,
				       MessageType type,
				       int verb,
				       const char *format,
				       va_list args);
d198 2
a199 1
extern _X_EXPORT void xf86CollectInputOptions(InputInfoPtr pInfo, const char **defaultOpts);
d201 1
a201 1
#endif /* _xf86Xinput_h */
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a61 2
#define XI86_OPEN_ON_INIT       0x01 /* open the device at startup time */
#define XI86_CONFIGURED         0x02 /* the device has been configured */
a64 27
/* if the device is the core pointer or is sending core events, and
 * SEND_DRAG_EVENTS is false, and a buttons is done, then no motion events
 * (mouse drag action) are sent. This is mainly to allow a touch screen to be
 * used with netscape and other browsers which do strange things if the mouse
 * moves between button down and button up. With a touch screen, this motion
 * is common due to the user's finger moving slightly.
 */
#define XI86_SEND_DRAG_EVENTS	0x08
#define XI86_CORE_POINTER	0x10 /* device is the core pointer */
#define XI86_CORE_KEYBOARD	0x20 /* device is the core keyboard */
#define XI86_POINTER_CAPABLE	0x40 /* capable of being a core pointer */
#define XI86_KEYBOARD_CAPABLE	0x80 /* capable of being a core keyboard */

#define XI_PRIVATE(dev) \
	(((LocalDevicePtr)((dev)->public.devicePrivate))->private)

/* Valuator verification macro */
#define XI_VERIFY_VALUATORS(num_valuators)					\
	if (num_valuators > MAX_VALUATORS) {					\
		xf86Msg(X_ERROR, "%s: num_valuator %d is greater than"		\
			" MAX_VALUATORS\n", __FUNCTION__, num_valuators);	\
		return;								\
	}

/* Stupid API backwards-compatibility. */
#define TS_Raw 60
#define TS_Scaled 61
d71 2
a72 2
    struct _LocalDeviceRec *(*PreInit)(struct _InputDriverRec *drv,
				       IDevPtr dev, int flags);
d74 1
a74 1
				      struct _LocalDeviceRec *pInfo,
d77 1
a77 1
    int			    refCount;
d82 2
a83 2
typedef struct _LocalDeviceRec {
    struct _LocalDeviceRec *next;
d85 2
d90 2
a91 2
    void		    (*read_input)(struct _LocalDeviceRec *local);
    int			    (*control_proc)(struct _LocalDeviceRec *local,
a92 1
    void		    (*close_proc)(struct _LocalDeviceRec *local);
a94 7
    Bool		    (*conversion_proc)(struct _LocalDeviceRec *local,
					      int first, int num, int v0,
					      int v1, int v2, int v3, int v4,
					      int v5, int *x, int *y);
    Bool		    (*reverse_conversion_proc)(
					struct _LocalDeviceRec *local,
					int x, int y, int *valuators);
d96 1
a96 1
				(struct _LocalDeviceRec *local,
a100 1
    Atom		    atom;
a102 5
    int			    private_flags;
    unsigned int	    first;
    unsigned int	    last;
    int			    old_x;
    int			    old_y;
a103 2
    IntegerFeedbackPtr	    always_core_feedback;
    IDevPtr		    conf_idev;
a106 1
    unsigned int            history_size;
d108 1
a108 7
} LocalDeviceRec, *LocalDevicePtr, InputInfoRec, *InputInfoPtr;

typedef struct _DeviceAssocRec 
{
    char *		    config_section_name;
    LocalDevicePtr	    (*device_allocate)(void);
} DeviceAssocRec, *DeviceAssocPtr;
d111 1
a111 1
extern _X_EXPORT InputInfoPtr xf86InputDevs;
d117 3
a119 1
			 int first_valuator, int num_valuators, int *valuators);
d123 3
a125 1
			     int num_valuators, int *valuators);
d131 3
a133 1
			  int *valuators);
d137 2
d141 1
a141 1
		       int *valuators);
d144 3
a146 4
extern _X_EXPORT int xf86ActivateDevice(LocalDevicePtr local);
extern _X_EXPORT LocalDevicePtr xf86FirstLocalDevice(void);
extern _X_EXPORT int xf86ScaleAxis(int Cx, int Sxhigh, int Sxlow, int Rxhigh, int Rxlow);
extern _X_EXPORT void xf86XInputSetScreen(LocalDevicePtr local, int screen_number, int x, int y);
d150 1
a150 1
				int max_res);
d157 2
a158 1
int xf86NewInputDevice(IDevPtr idev, DeviceIntPtr *pdev, BOOL is_auto);
a162 1
extern _X_EXPORT InputInfoPtr xf86AllocateInput(InputDriverPtr drv, int flags);
d166 12
a177 1
extern _X_EXPORT void xf86MotionHistoryAllocate(LocalDevicePtr local);
d180 1
a180 7
extern _X_EXPORT void xf86CollectInputOptions(InputInfoPtr pInfo, const char **defaultOpts,
			     pointer extraOpts);


/* Legacy hatred */
#define SendCoreEvents 59
#define DontSendCoreEvents 60
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d151 1
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a54 3
#ifndef NEED_EVENTS
#define NEED_EVENTS
#endif
d83 8
d160 1
a160 1
extern InputInfoPtr xf86InputDevs;
d163 1
a163 2
void InitExtInput(void);
void xf86PostMotionEvent(DeviceIntPtr device, int is_absolute,
d165 1
a165 1
void xf86PostMotionEventP(DeviceIntPtr device, int is_absolute,
d167 1
a167 1
void xf86PostProximityEvent(DeviceIntPtr device, int is_in,
d169 3
a171 1
void xf86PostButtonEvent(DeviceIntPtr device, int is_absolute, int button,
d174 4
a177 1
void xf86PostKeyEvent(DeviceIntPtr device, unsigned int key_code, int is_down,
d180 4
a183 1
void xf86PostKeyboardEvent(DeviceIntPtr device, unsigned int key_code,
d185 6
a190 6
int xf86ActivateDevice(LocalDevicePtr local);
LocalDevicePtr xf86FirstLocalDevice(void);
int xf86ScaleAxis(int Cx, int Sxhigh, int Sxlow, int Rxhigh, int Rxlow);
void xf86XInputSetScreen(LocalDevicePtr local, int screen_number, int x, int y);
void xf86ProcessCommonOptions(InputInfoPtr pInfo, pointer options);
void xf86InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, int minval,
d193 6
a198 5
void xf86InitValuatorDefaults(DeviceIntPtr dev, int axnum);
void xf86AddEnabledDevice(InputInfoPtr pInfo);
void xf86RemoveEnabledDevice(InputInfoPtr pInfo);
void xf86DisableDevice(DeviceIntPtr dev, Bool panic);
void xf86EnableDevice(DeviceIntPtr dev);
d202 7
a208 10
void xf86AddInputDriver(InputDriverPtr driver, pointer module, int flags);
void xf86DeleteInputDriver(int drvIndex);
InputInfoPtr xf86AllocateInput(InputDriverPtr drv, int flags);
InputDriverPtr xf86LookupInputDriver(const char *name);
InputInfoPtr xf86LookupInput(const char *name);
void xf86DeleteInput(InputInfoPtr pInp, int flags);
void xf86MotionHistoryAllocate(LocalDevicePtr local);
int xf86GetMotionEvents(DeviceIntPtr dev, xTimecoord *buff,
                        unsigned long start, unsigned long stop,
                        ScreenPtr pScreen, BOOL core);
d211 1
a211 1
void xf86CollectInputOptions(InputInfoPtr pInfo, const char **defaultOpts,
@


1.1
log
@Initial revision
@
text
@a0 1
/* $XConsortium: xf86Xinput.h /main/11 1996/10/27 11:05:29 kaleb $ */
a59 1
#ifdef XINPUT
a62 1
#endif
d86 3
a88 9
#ifdef DBG
#undef DBG
#endif
#define DBG(lvl, f) {if ((lvl) <= xf86GetVerbosity()) f;}

#ifdef HAS_MOTION_HISTORY
#undef HAS_MOTION_HISTORY
#endif
#define HAS_MOTION_HISTORY(local) ((local)->dev->valuator && (local)->dev->valuator->numMotionEvents)
a89 1
#ifdef XINPUT
a102 1
#endif
d110 1
a110 1
    
d125 5
a129 1
    
a134 3
    pointer		    motion_history;
    ValuatorMotionProcPtr   motion_history_proc;
    unsigned int	    history_size;   /* only for configuration purpose */
a138 2
    float		    dxremaind;
    float		    dyremaind;
d145 1
a157 5
int xf86IsCorePointer(DeviceIntPtr dev);
int xf86IsCoreKeyboard(DeviceIntPtr dev);
void xf86XInputSetSendCoreEvents(LocalDevicePtr local, Bool always);
#define xf86AlwaysCore(a,b) xf86XInputSetSendCoreEvents(a,b)

a158 4
Bool xf86eqInit(DevicePtr pKbd, DevicePtr pPtr);
void xf86eqEnqueue(struct _xEvent *event);
void xf86eqProcessInputEvents (void);
void xf86eqSwitchScreen(ScreenPtr pScreen, Bool fromDIX);
d161 2
d173 1
a173 8
void xf86MotionHistoryAllocate(LocalDevicePtr local);
int xf86GetMotionEvents(DeviceIntPtr dev, xTimecoord *buff,
			unsigned long start, unsigned long stop,
			ScreenPtr pScreen);
void xf86XinputFinalizeInit(DeviceIntPtr dev);
void xf86ActivateDevice(LocalDevicePtr local);
Bool xf86CheckButton(int button, int down);
void xf86SwitchCoreDevice(LocalDevicePtr device, DeviceIntPtr core);
d184 3
d192 2
d195 4
d203 5
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d1 1
d89 9
a97 3
/* Stupid API backwards-compatibility. */
#define TS_Raw 60
#define TS_Scaled 61
d121 1
a121 1

d136 1
a136 5
    int                     (*set_device_valuators)
				(struct _LocalDeviceRec *local,
				 int *valuators, int first_valuator,
				 int num_valuators);

d142 3
d149 2
a156 1
    unsigned int            history_size;
d169 5
d175 4
a180 2
void xf86PostMotionEventP(DeviceIntPtr device, int is_absolute,
			 int first_valuator, int num_valuators, int *valuators);
d191 4
a208 2
void xf86DisableDevice(DeviceIntPtr dev, Bool panic);
void xf86EnableDevice(DeviceIntPtr dev);
a213 2
InputDriverPtr xf86LookupInputDriver(const char *name);
InputInfoPtr xf86LookupInput(const char *name);
a214 4
void xf86MotionHistoryAllocate(LocalDevicePtr local);
int xf86GetMotionEvents(DeviceIntPtr dev, xTimecoord *buff,
                        unsigned long start, unsigned long stop,
                        ScreenPtr pScreen);
a218 5


/* Legacy hatred */
#define SendCoreEvents 59
#define DontSendCoreEvents 60
@

