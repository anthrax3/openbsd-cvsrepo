head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.2
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.2
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.19.0.2
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.2
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2016.08.09.18.59.52;	author matthieu;	state Exp;
branches;
next	1.24;
commitid	6HLO5qdN5N4nPDjW;

1.24
date	2016.05.29.12.02.37;	author matthieu;	state Exp;
branches;
next	1.23;
commitid	s0SI41sEunLdyFfd;

1.23
date	2015.09.16.19.10.22;	author matthieu;	state Exp;
branches;
next	1.22;
commitid	Te1daavkBLskZ8gc;

1.22
date	2014.09.27.17.53.01;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	cVXoV5PxI8YrEaVA;

1.21
date	2014.05.02.19.27.48;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.07.17.28.49;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2012.08.08.16.37.19;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2012.08.05.18.11.37;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2012.06.10.13.21.23;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.04.17.55.31;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.05.13.32.50;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.06.29.19.55.01;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2011.03.08.07.59.23;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.05.15.36.06;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.27.19.02.30;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.06.19.44.25;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.02.15.26.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.29.03.09.26;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.24.19.04.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.02.10.18.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.16.20.59.14;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.21.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.21.05;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.12.16.20.11.44;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.57.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 * Loosely based on code bearing the following copyright:
 *
 *   Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
 */

/*
 * Copyright 1992-2003 by The XFree86 Project, Inc.
 * Copyright 1997 by Metro Link, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

/*
 *
 * Authors:
 *	Dirk Hohndel <hohndel@@XFree86.Org>
 *	David Dawes <dawes@@XFree86.Org>
 *      Marc La France <tsi@@XFree86.Org>
 *      Egbert Eich <eich@@XFree86.Org>
 *      ... and others
 */

#ifdef HAVE_XORG_CONFIG_H
#include <xorg-config.h>
#endif

#include <sys/types.h>
#include <grp.h>

#include "xf86.h"
#include "xf86Modes.h"
#include "xf86Parser.h"
#include "xf86tokens.h"
#include "xf86Config.h"
#include "xf86Priv.h"
#include "xf86_OSlib.h"
#include "configProcs.h"
#include "globals.h"
#include "extension.h"
#include "xf86pciBus.h"

#include "xf86Xinput.h"

#include "xkbsrv.h"

#include "picture.h"

/*
 * These paths define the way the config file search is done.  The escape
 * sequences are documented in parser/scan.c.
 */
#ifndef ALL_CONFIGPATH
#define ALL_CONFIGPATH	"%A," "%R," \
			"/etc/X11/%R," "%P/etc/X11/%R," \
			"%E," "%F," \
			"/etc/X11/%F," "%P/etc/X11/%F," \
			"/etc/X11/%X," "/etc/%X," \
			"%P/etc/X11/%X.%H," \
			"%P/etc/X11/%X," \
			"%P/lib/X11/%X.%H," \
			"%P/lib/X11/%X"
#endif
#ifndef RESTRICTED_CONFIGPATH
#define RESTRICTED_CONFIGPATH	"/etc/X11/%S," "%P/etc/X11/%S," \
			"/etc/X11/%G," "%P/etc/X11/%G," \
			"/etc/X11/%X," "/etc/%X," \
			"%P/etc/X11/%X.%H," \
			"%P/etc/X11/%X," \
			"%P/lib/X11/%X.%H," \
			"%P/lib/X11/%X"
#endif
#ifndef ALL_CONFIGDIRPATH
#define ALL_CONFIGDIRPATH	"%A," "%R," \
				"/etc/X11/%R," "%C/X11/%R," \
				"/etc/X11/%X," "%C/X11/%X"
#endif
#ifndef RESTRICTED_CONFIGDIRPATH
#define RESTRICTED_CONFIGDIRPATH	"/etc/X11/%R," "%C/X11/%R," \
					"/etc/X11/%X," "%C/X11/%X"
#endif
#ifndef SYS_CONFIGDIRPATH
#define SYS_CONFIGDIRPATH	"%D/X11/%X"
#endif
#ifndef PROJECTROOT
#define PROJECTROOT	"/usr/X11R6"
#endif

static ModuleDefault ModuleDefaults[] = {
#ifdef GLXEXT
    {.name = "glx",.toLoad = TRUE,.load_opt = NULL},
#endif
#ifdef __CYGWIN__
    /* load DIX modules used by drivers first */
    {.name = "fb",.toLoad = TRUE,.load_opt = NULL},
    {.name = "shadow",.toLoad = TRUE,.load_opt = NULL},
#endif
    {.name = NULL,.toLoad = FALSE,.load_opt = NULL}
};

/* Forward declarations */
static Bool configScreen(confScreenPtr screenp, XF86ConfScreenPtr conf_screen,
                         int scrnum, MessageType from, Bool auto_gpu_device);
static Bool configMonitor(MonPtr monitorp, XF86ConfMonitorPtr conf_monitor);
static Bool configDevice(GDevPtr devicep, XF86ConfDevicePtr conf_device,
                         Bool active, Bool gpu);
static Bool configInput(InputInfoPtr pInfo, XF86ConfInputPtr conf_input,
                        MessageType from);
static Bool configDisplay(DispPtr displayp, XF86ConfDisplayPtr conf_display);
static Bool addDefaultModes(MonPtr monitorp);

static void configDRI(XF86ConfDRIPtr drip);
static void configExtensions(XF86ConfExtensionsPtr conf_ext);

/*
 * xf86GetPathElem --
 *	Extract a single element from the font path string starting at
 *	pnt.  The font path element will be returned, and pnt will be
 *	updated to point to the start of the next element, or set to
 *	NULL if there are no more.
 */
static char *
xf86GetPathElem(char **pnt)
{
    char *p1;

    p1 = *pnt;
    *pnt = index(*pnt, ',');
    if (*pnt != NULL) {
        **pnt = '\0';
        *pnt += 1;
    }
    return p1;
}

/*
 * xf86ValidateFontPath --
 *	Validates the user-specified font path.  Each element that
 *	begins with a '/' is checked to make sure the directory exists.
 *	If the directory exists, the existence of a file named 'fonts.dir'
 *	is checked.  If either check fails, an error is printed and the
 *	element is removed from the font path.
 */

#define DIR_FILE "/fonts.dir"
static char *
xf86ValidateFontPath(char *path)
{
    char *next, *tmp_path, *out_pnt, *path_elem, *p1, *dir_elem;
    struct stat stat_buf;
    int flag;
    int dirlen;

    tmp_path = calloc(1, strlen(path) + 1);
    out_pnt = tmp_path;
    path_elem = NULL;
    next = path;
    while (next != NULL) {
        path_elem = xf86GetPathElem(&next);
        if (*path_elem == '/') {
            dir_elem = xnfcalloc(1, strlen(path_elem) + 1);
            if ((p1 = strchr(path_elem, ':')) != 0)
                dirlen = p1 - path_elem;
            else
                dirlen = strlen(path_elem);
            strlcpy(dir_elem, path_elem, dirlen + 1);
            flag = stat(dir_elem, &stat_buf);
            if (flag == 0)
                if (!S_ISDIR(stat_buf.st_mode))
                    flag = -1;
            if (flag != 0) {
                xf86Msg(X_WARNING, "The directory \"%s\" does not exist.\n",
                        dir_elem);
                xf86ErrorF("\tEntry deleted from font path.\n");
                free(dir_elem);
                continue;
            }
            else {
                XNFasprintf(&p1, "%s%s", dir_elem, DIR_FILE);
                flag = stat(p1, &stat_buf);
                if (flag == 0)
                    if (!S_ISREG(stat_buf.st_mode))
                        flag = -1;
                free(p1);
                if (flag != 0) {
                    xf86Msg(X_WARNING,
                            "`fonts.dir' not found (or not valid) in \"%s\".\n",
                            dir_elem);
                    xf86ErrorF("\tEntry deleted from font path.\n");
                    xf86ErrorF("\t(Run 'mkfontdir' on \"%s\").\n", dir_elem);
                    free(dir_elem);
                    continue;
                }
            }
            free(dir_elem);
        }

        /*
         * Either an OK directory, or a font server name.  So add it to
         * the path.
         */
        if (out_pnt != tmp_path)
            *out_pnt++ = ',';
        strcat(out_pnt, path_elem);
        out_pnt += strlen(path_elem);
    }
    return tmp_path;
}

#define FIND_SUITABLE(pointertype, listhead, ptr)                                            \
    do {                                                                                     \
        pointertype _l, _p;                                                                  \
                                                                                             \
        for (_l = (listhead), _p = NULL; !_p && _l; _l = (pointertype)_l->list.next) {       \
            if (!_l->match_seat || (SeatId && xf86nameCompare(_l->match_seat, SeatId) == 0)) \
                _p = _l;                                                                     \
        }                                                                                    \
                                                                                             \
        (ptr) = _p;                                                                          \
    } while(0)

/*
 * use the datastructure that the parser provides and pick out the parts
 * that we need at this point
 */
const char **
xf86ModulelistFromConfig(void ***optlist)
{
    int count = 0, i = 0;
    const char **modulearray;

    const char *ignore[] = { "GLcore", "speedo", "bitmap", "drm",
        "freetype", "type1",
        NULL
    };
    void **optarray;
    XF86LoadPtr modp;
    Bool found;

    /*
     * make sure the config file has been parsed and that we have a
     * ModulePath set; if no ModulePath was given, use the default
     * ModulePath
     */
    if (xf86configptr == NULL) {
        xf86Msg(X_ERROR, "Cannot access global config data structure\n");
        return NULL;
    }

    if (xf86configptr->conf_modules) {
        /* Walk the disable list and let people know what we've parsed to
         * not be loaded
         */
        modp = xf86configptr->conf_modules->mod_disable_lst;
        while (modp) {
            xf86Msg(X_WARNING,
                    "\"%s\" will not be loaded unless you've specified it to be loaded elsewhere.\n",
                    modp->load_name);
            modp = (XF86LoadPtr) modp->list.next;
        }
        /*
         * Walk the default settings table. For each module listed to be
         * loaded, make sure it's in the mod_load_lst. If it's not, make
         * sure it's not in the mod_no_load_lst. If it's not disabled,
         * append it to mod_load_lst
         */
        for (i = 0; ModuleDefaults[i].name != NULL; i++) {
            if (ModuleDefaults[i].toLoad == FALSE) {
                xf86Msg(X_WARNING,
                        "\"%s\" is not to be loaded by default. Skipping.\n",
                        ModuleDefaults[i].name);
                continue;
            }
            found = FALSE;
            modp = xf86configptr->conf_modules->mod_load_lst;
            while (modp) {
                if (strcmp(modp->load_name, ModuleDefaults[i].name) == 0) {
                    xf86Msg(X_INFO,
                            "\"%s\" will be loaded. This was enabled by default and also specified in the config file.\n",
                            ModuleDefaults[i].name);
                    found = TRUE;
                    break;
                }
                modp = (XF86LoadPtr) modp->list.next;
            }
            if (found == FALSE) {
                modp = xf86configptr->conf_modules->mod_disable_lst;
                while (modp) {
                    if (strcmp(modp->load_name, ModuleDefaults[i].name) == 0) {
                        xf86Msg(X_INFO,
                                "\"%s\" will be loaded even though the default is to disable it.\n",
                                ModuleDefaults[i].name);
                        found = TRUE;
                        break;
                    }
                    modp = (XF86LoadPtr) modp->list.next;
                }
            }
            if (found == FALSE) {
                XF86LoadPtr ptr = (XF86LoadPtr) xf86configptr->conf_modules;

                xf86addNewLoadDirective(ptr, ModuleDefaults[i].name,
                                        XF86_LOAD_MODULE,
                                        ModuleDefaults[i].load_opt);
                xf86Msg(X_INFO, "\"%s\" will be loaded by default.\n",
                        ModuleDefaults[i].name);
            }
        }
    }
    else {
        xf86configptr->conf_modules = xnfcalloc(1, sizeof(XF86ConfModuleRec));
        for (i = 0; ModuleDefaults[i].name != NULL; i++) {
            if (ModuleDefaults[i].toLoad == TRUE) {
                XF86LoadPtr ptr = (XF86LoadPtr) xf86configptr->conf_modules;

                xf86addNewLoadDirective(ptr, ModuleDefaults[i].name,
                                        XF86_LOAD_MODULE,
                                        ModuleDefaults[i].load_opt);
            }
        }
    }

    /*
     * Walk the list of modules in the "Module" section to determine how
     * many we have.
     */
    modp = xf86configptr->conf_modules->mod_load_lst;
    while (modp) {
        for (i = 0; ignore[i]; i++) {
            if (strcmp(modp->load_name, ignore[i]) == 0)
                modp->ignore = 1;
        }
        if (!modp->ignore)
            count++;
        modp = (XF86LoadPtr) modp->list.next;
    }

    /*
     * allocate the memory and walk the list again to fill in the pointers
     */
    modulearray = xnfallocarray(count + 1, sizeof(char *));
    optarray = xnfallocarray(count + 1, sizeof(void *));
    count = 0;
    if (xf86configptr->conf_modules) {
        modp = xf86configptr->conf_modules->mod_load_lst;
        while (modp) {
            if (!modp->ignore) {
                modulearray[count] = modp->load_name;
                optarray[count] = modp->load_opt;
                count++;
            }
            modp = (XF86LoadPtr) modp->list.next;
        }
    }
    modulearray[count] = NULL;
    optarray[count] = NULL;
    if (optlist)
        *optlist = optarray;
    else
        free(optarray);
    return modulearray;
}

const char **
xf86DriverlistFromConfig(void)
{
    int count = 0;
    int j, k;
    const char **modulearray;
    screenLayoutPtr slp;

    /*
     * make sure the config file has been parsed and that we have a
     * ModulePath set; if no ModulePath was given, use the default
     * ModulePath
     */
    if (xf86configptr == NULL) {
        xf86Msg(X_ERROR, "Cannot access global config data structure\n");
        return NULL;
    }

    /*
     * Walk the list of driver lines in active "Device" sections to
     * determine now many implicitly loaded modules there are.
     *
     */
    if (xf86ConfigLayout.screens) {
        slp = xf86ConfigLayout.screens;
        while (slp->screen) {
            count++;
            count += slp->screen->num_gpu_devices;
            slp++;
        }
    }

    /*
     * Handle the set of inactive "Device" sections.
     */
    j = 0;
    while (xf86ConfigLayout.inactives[j++].identifier)
        count++;

    if (count == 0)
        return NULL;

    /*
     * allocate the memory and walk the list again to fill in the pointers
     */
    modulearray = xnfallocarray(count + 1, sizeof(char *));
    count = 0;
    slp = xf86ConfigLayout.screens;
    while (slp->screen) {
        modulearray[count] = slp->screen->device->driver;
        count++;
        for (k = 0; k < slp->screen->num_gpu_devices; k++) {
            modulearray[count] = slp->screen->gpu_devices[k]->driver;
            count++;
        }
        slp++;
    }

    j = 0;

    while (xf86ConfigLayout.inactives[j].identifier)
        modulearray[count++] = xf86ConfigLayout.inactives[j++].driver;

    modulearray[count] = NULL;

    /* Remove duplicates */
    for (count = 0; modulearray[count] != NULL; count++) {
        int i;

        for (i = 0; i < count; i++)
            if (xf86NameCmp(modulearray[i], modulearray[count]) == 0) {
                modulearray[count] = "";
                break;
            }
    }
    return modulearray;
}

const char **
xf86InputDriverlistFromConfig(void)
{
    int count = 0;
    const char **modulearray;
    InputInfoPtr *idp;

    /*
     * make sure the config file has been parsed and that we have a
     * ModulePath set; if no ModulePath was given, use the default
     * ModulePath
     */
    if (xf86configptr == NULL) {
        xf86Msg(X_ERROR, "Cannot access global config data structure\n");
        return NULL;
    }

    /*
     * Walk the list of driver lines in active "InputDevice" sections to
     * determine now many implicitly loaded modules there are.
     */
    if (xf86ConfigLayout.inputs) {
        idp = xf86ConfigLayout.inputs;
        while (*idp) {
            count++;
            idp++;
        }
    }

    if (count == 0)
        return NULL;

    /*
     * allocate the memory and walk the list again to fill in the pointers
     */
    modulearray = xnfallocarray(count + 1, sizeof(char *));
    count = 0;
    idp = xf86ConfigLayout.inputs;
    while (idp && *idp) {
        modulearray[count] = (*idp)->driver;
        count++;
        idp++;
    }
    modulearray[count] = NULL;

    /* Remove duplicates */
    for (count = 0; modulearray[count] != NULL; count++) {
        int i;

        for (i = 0; i < count; i++)
            if (xf86NameCmp(modulearray[i], modulearray[count]) == 0) {
                modulearray[count] = "";
                break;
            }
    }
    return modulearray;
}

static int
is_fallback(const char *s)
{
    /* later entries are less preferred */
    const char *fallback[5] = { "modesetting", "fbdev", "vesa",  "wsfb", NULL };
    int i;

    for (i = 0; fallback[i]; i++)
	if (strstr(s, fallback[i]))
	    return i;

    return -1;
}

static int
driver_sort(const void *_l, const void *_r)
{
    const char *l = *(const char **)_l;
    const char *r = *(const char **)_r;
    int left = is_fallback(l);
    int right = is_fallback(r);

    /* neither is a fallback, asciibetize */
    if (left == -1 && right == -1)
	return strcmp(l, r);

    /* left is a fallback */
    if (left >= 0)
	return 1;

    /* right is a fallback */
    if (right >= 0)
	return -1;

    /* both are fallbacks, which is worse */
    return left - right;
}

static void
fixup_video_driver_list(const char **drivers)
{
    const char **end;

    /* walk to the end of the list */
    for (end = drivers; *end && **end; end++);
    end--;

    qsort(drivers, end - drivers, sizeof(const char *), driver_sort);
}

static const char **
GenerateDriverlist(const char *dirname)
{
    const char **ret;
    const char *subdirs[] = { dirname, NULL };
    static const char *patlist[] = { "(.*)_drv\\.so", NULL };
    ret = LoaderListDirs(subdirs, patlist);

    /* fix up the probe order for video drivers */
    if (strstr(dirname, "drivers") && ret != NULL)
        fixup_video_driver_list(ret);

    return ret;
}

const char **
xf86DriverlistFromCompile(void)
{
    static const char **driverlist = NULL;

    if (!driverlist)
        driverlist = GenerateDriverlist("drivers");

    return driverlist;
}

static void
configFiles(XF86ConfFilesPtr fileconf)
{
    MessageType pathFrom;
    Bool must_copy;
    int size, countDirs;
    char *temp_path, *log_buf, *start, *end;

    /* FontPath */
    must_copy = TRUE;

    temp_path = defaultFontPath ? (char *) defaultFontPath : (char *) "";
    if (xf86fpFlag)
        pathFrom = X_CMDLINE;
    else if (fileconf && fileconf->file_fontpath) {
        pathFrom = X_CONFIG;
        if (xf86Info.useDefaultFontPath) {
            char *new_font_path;
            if (asprintf(&new_font_path, "%s%s%s", fileconf->file_fontpath,
                         *temp_path ? "," : "", temp_path) == -1)
                new_font_path = NULL;
            else
                must_copy = FALSE;
            defaultFontPath = new_font_path;
        }
        else
            defaultFontPath = fileconf->file_fontpath;
    }
    else
        pathFrom = X_DEFAULT;
    temp_path = defaultFontPath ? (char *) defaultFontPath : (char *) "";

    /* xf86ValidateFontPath modifies its argument, but returns a copy of it. */
    temp_path = must_copy ? xnfstrdup(defaultFontPath) : (char *) defaultFontPath;
    defaultFontPath = xf86ValidateFontPath(temp_path);
    free(temp_path);

    /* make fontpath more readable in the logfiles */
    countDirs = 1;
    temp_path = (char *) defaultFontPath;
    while ((temp_path = index(temp_path, ',')) != NULL) {
        countDirs++;
        temp_path++;
    }

    log_buf = xnfalloc(strlen(defaultFontPath) + (2 * countDirs) + 1);
    temp_path = log_buf;
    start = (char *) defaultFontPath;
    while ((end = index(start, ',')) != NULL) {
        size = (end - start) + 1;
        *(temp_path++) = '\t';
        strncpy(temp_path, start, size);
        temp_path += size;
        *(temp_path++) = '\n';
        start += size;
    }
    /* copy last entry */
    *(temp_path++) = '\t';
    strcpy(temp_path, start);
    xf86Msg(pathFrom, "FontPath set to:\n%s\n", log_buf);
    free(log_buf);

    /* ModulePath */

    if (fileconf) {
        if (xf86ModPathFrom != X_CMDLINE && fileconf->file_modulepath) {
            xf86ModulePath = fileconf->file_modulepath;
            xf86ModPathFrom = X_CONFIG;
        }
    }

    xf86Msg(xf86ModPathFrom, "ModulePath set to \"%s\"\n", xf86ModulePath);

    if (!xf86xkbdirFlag && fileconf && fileconf->file_xkbdir) {
        XkbBaseDirectory = fileconf->file_xkbdir;
        xf86Msg(X_CONFIG, "XKB base directory set to \"%s\"\n",
                XkbBaseDirectory);
    }
#if 0
    /* LogFile */
    /*
     * XXX The problem with this is that the log file is already open.
     * One option might be to copy the exiting contents to the new location.
     * and re-open it.  The down side is that the default location would
     * already have been overwritten.  Another option would be to start with
     * unique temporary location, then copy it once the correct name is known.
     * A problem with this is what happens if the server exits before that
     * happens.
     */
    if (xf86LogFileFrom == X_DEFAULT && fileconf->file_logfile) {
        xf86LogFile = fileconf->file_logfile;
        xf86LogFileFrom = X_CONFIG;
    }
#endif

    return;
}

typedef enum {
    FLAG_NOTRAPSIGNALS,
    FLAG_DONTVTSWITCH,
    FLAG_DONTZAP,
    FLAG_DONTZOOM,
    FLAG_DISABLEVIDMODE,
    FLAG_ALLOWNONLOCAL,
    FLAG_ALLOWMOUSEOPENFAIL,
    FLAG_SAVER_BLANKTIME,
    FLAG_DPMS_STANDBYTIME,
    FLAG_DPMS_SUSPENDTIME,
    FLAG_DPMS_OFFTIME,
    FLAG_PIXMAP,
    FLAG_NOPM,
    FLAG_XINERAMA,
    FLAG_LOG,
    FLAG_RENDER_COLORMAP_MODE,
    FLAG_RANDR,
    FLAG_AIGLX,
    FLAG_IGNORE_ABI,
    FLAG_ALLOW_EMPTY_INPUT,
    FLAG_USE_DEFAULT_FONT_PATH,
    FLAG_AUTO_ADD_DEVICES,
    FLAG_AUTO_ENABLE_DEVICES,
    FLAG_GLX_VISUALS,
    FLAG_DRI2,
    FLAG_USE_SIGIO,
    FLAG_AUTO_ADD_GPU,
    FLAG_MAX_CLIENTS,
    FLAG_IGLX,
} FlagValues;

/**
 * NOTE: the last value for each entry is NOT the default. It is set to TRUE
 * if the parser found the option in the config file.
 */
static OptionInfoRec FlagOptions[] = {
    {FLAG_NOTRAPSIGNALS, "NoTrapSignals", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_DONTVTSWITCH, "DontVTSwitch", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_DONTZAP, "DontZap", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_DONTZOOM, "DontZoom", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_DISABLEVIDMODE, "DisableVidModeExtension", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_ALLOWNONLOCAL, "AllowNonLocalXvidtune", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_ALLOWMOUSEOPENFAIL, "AllowMouseOpenFail", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_SAVER_BLANKTIME, "BlankTime", OPTV_INTEGER,
     {0}, FALSE},
    {FLAG_DPMS_STANDBYTIME, "StandbyTime", OPTV_INTEGER,
     {0}, FALSE},
    {FLAG_DPMS_SUSPENDTIME, "SuspendTime", OPTV_INTEGER,
     {0}, FALSE},
    {FLAG_DPMS_OFFTIME, "OffTime", OPTV_INTEGER,
     {0}, FALSE},
    {FLAG_PIXMAP, "Pixmap", OPTV_INTEGER,
     {0}, FALSE},
    {FLAG_NOPM, "NoPM", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_XINERAMA, "Xinerama", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_LOG, "Log", OPTV_STRING,
     {0}, FALSE},
    {FLAG_RENDER_COLORMAP_MODE, "RenderColormapMode", OPTV_STRING,
     {0}, FALSE},
    {FLAG_RANDR, "RandR", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_AIGLX, "AIGLX", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_IGNORE_ABI, "IgnoreABI", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_USE_DEFAULT_FONT_PATH, "UseDefaultFontPath", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_AUTO_ADD_DEVICES, "AutoAddDevices", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_AUTO_ENABLE_DEVICES, "AutoEnableDevices", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_GLX_VISUALS, "GlxVisuals", OPTV_STRING,
     {0}, FALSE},
    {FLAG_DRI2, "DRI2", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_USE_SIGIO, "UseSIGIO", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_AUTO_ADD_GPU, "AutoAddGPU", OPTV_BOOLEAN,
     {0}, FALSE},
    {FLAG_MAX_CLIENTS, "MaxClients", OPTV_INTEGER,
     {0}, FALSE },
    {FLAG_IGLX, "IndirectGLX", OPTV_BOOLEAN,
     {0}, FALSE},
    {-1, NULL, OPTV_NONE,
     {0}, FALSE},
};

static void
configServerFlags(XF86ConfFlagsPtr flagsconf, XF86OptionPtr layoutopts)
{
    XF86OptionPtr optp, tmp;
    int i;
    Pix24Flags pix24 = Pix24DontCare;
    Bool value;
    MessageType from;
    const char *s;
    XkbRMLVOSet set;
    const char *rules;

    /*
     * Merge the ServerLayout and ServerFlags options.  The former have
     * precedence over the latter.
     */
    optp = NULL;
    if (flagsconf && flagsconf->flg_option_lst)
        optp = xf86optionListDup(flagsconf->flg_option_lst);
    if (layoutopts) {
        tmp = xf86optionListDup(layoutopts);
        if (optp)
            optp = xf86optionListMerge(optp, tmp);
        else
            optp = tmp;
    }

    xf86ProcessOptions(-1, optp, FlagOptions);

    xf86GetOptValBool(FlagOptions, FLAG_NOTRAPSIGNALS, &xf86Info.notrapSignals);
    xf86GetOptValBool(FlagOptions, FLAG_DONTVTSWITCH, &xf86Info.dontVTSwitch);
    xf86GetOptValBool(FlagOptions, FLAG_DONTZAP, &xf86Info.dontZap);
    xf86GetOptValBool(FlagOptions, FLAG_DONTZOOM, &xf86Info.dontZoom);

    xf86GetOptValBool(FlagOptions, FLAG_IGNORE_ABI, &xf86Info.ignoreABI);
    if (xf86Info.ignoreABI) {
        xf86Msg(X_CONFIG, "Ignoring ABI Version\n");
    }

    if (xf86SIGIOSupported()) {
        xf86Info.useSIGIO =
            xf86ReturnOptValBool(FlagOptions, FLAG_USE_SIGIO,
                                 USE_SIGIO_BY_DEFAULT);
        if (xf86IsOptionSet(FlagOptions, FLAG_USE_SIGIO)) {
            from = X_CONFIG;
        }
        else {
            from = X_DEFAULT;
        }
        if (!xf86Info.useSIGIO) {
            xf86Msg(from, "Disabling SIGIO handlers for input devices\n");
        }
        else if (from == X_CONFIG) {
            xf86Msg(from, "Enabling SIGIO handlers for input devices\n");
        }
    }
    else {
        xf86Info.useSIGIO = FALSE;
    }

    if (xf86IsOptionSet(FlagOptions, FLAG_AUTO_ADD_DEVICES)) {
        xf86GetOptValBool(FlagOptions, FLAG_AUTO_ADD_DEVICES,
                          &xf86Info.autoAddDevices);
        from = X_CONFIG;
    }
    else {
        from = X_DEFAULT;
    }
    xf86Msg(from, "%sutomatically adding devices\n",
            xf86Info.autoAddDevices ? "A" : "Not a");

    if (xf86IsOptionSet(FlagOptions, FLAG_AUTO_ENABLE_DEVICES)) {
        xf86GetOptValBool(FlagOptions, FLAG_AUTO_ENABLE_DEVICES,
                          &xf86Info.autoEnableDevices);
        from = X_CONFIG;
    }
    else {
        from = X_DEFAULT;
    }
    xf86Msg(from, "%sutomatically enabling devices\n",
            xf86Info.autoEnableDevices ? "A" : "Not a");

    if (xf86IsOptionSet(FlagOptions, FLAG_AUTO_ADD_GPU)) {
        xf86GetOptValBool(FlagOptions, FLAG_AUTO_ADD_GPU,
                          &xf86Info.autoAddGPU);
        from = X_CONFIG;
    }
    else {
        from = X_DEFAULT;
    }
    xf86Msg(from, "%sutomatically adding GPU devices\n",
            xf86Info.autoAddGPU ? "A" : "Not a");
    /*
     * Set things up based on the config file information.  Some of these
     * settings may be overridden later when the command line options are
     * checked.
     */
#ifdef XF86VIDMODE
    if (xf86GetOptValBool(FlagOptions, FLAG_DISABLEVIDMODE, &value))
        xf86Info.vidModeEnabled = !value;
    if (xf86GetOptValBool(FlagOptions, FLAG_ALLOWNONLOCAL, &value))
        xf86Info.vidModeAllowNonLocal = value;
#endif

    if (xf86GetOptValBool(FlagOptions, FLAG_ALLOWMOUSEOPENFAIL, &value))
        xf86Info.allowMouseOpenFail = value;

    xf86Info.pmFlag = TRUE;
    if (xf86GetOptValBool(FlagOptions, FLAG_NOPM, &value))
        xf86Info.pmFlag = !value;
    {
        if ((s = xf86GetOptValString(FlagOptions, FLAG_LOG))) {
            if (!xf86NameCmp(s, "flush")) {
                xf86Msg(X_CONFIG, "Flushing logfile enabled\n");
                LogSetParameter(XLOG_FLUSH, TRUE);
            }
            else if (!xf86NameCmp(s, "sync")) {
                xf86Msg(X_CONFIG, "Syncing logfile enabled\n");
                LogSetParameter(XLOG_FLUSH, TRUE);
                LogSetParameter(XLOG_SYNC, TRUE);
            }
            else {
                xf86Msg(X_WARNING, "Unknown Log option\n");
            }
        }
    }

    {
        if ((s = xf86GetOptValString(FlagOptions, FLAG_RENDER_COLORMAP_MODE))) {
            int policy = PictureParseCmapPolicy(s);

            if (policy == PictureCmapPolicyInvalid)
                xf86Msg(X_WARNING, "Unknown colormap policy \"%s\"\n", s);
            else {
                xf86Msg(X_CONFIG, "Render colormap policy set to %s\n", s);
                PictureCmapPolicy = policy;
            }
        }
    }

#ifdef RANDR
    xf86Info.disableRandR = FALSE;
    xf86Info.randRFrom = X_DEFAULT;
    if (xf86GetOptValBool(FlagOptions, FLAG_RANDR, &value)) {
        xf86Info.disableRandR = !value;
        xf86Info.randRFrom = X_CONFIG;
    }
#endif

    xf86Info.aiglx = TRUE;
    xf86Info.aiglxFrom = X_DEFAULT;
    if (xf86GetOptValBool(FlagOptions, FLAG_AIGLX, &value)) {
        xf86Info.aiglx = value;
        xf86Info.aiglxFrom = X_CONFIG;
    }

#ifdef GLXEXT
    xf86Info.glxVisuals = XF86_GlxVisualsTypical;
    xf86Info.glxVisualsFrom = X_DEFAULT;
    if ((s = xf86GetOptValString(FlagOptions, FLAG_GLX_VISUALS))) {
        if (!xf86NameCmp(s, "minimal")) {
            xf86Info.glxVisuals = XF86_GlxVisualsMinimal;
        }
        else if (!xf86NameCmp(s, "typical")) {
            xf86Info.glxVisuals = XF86_GlxVisualsTypical;
        }
        else if (!xf86NameCmp(s, "all")) {
            xf86Info.glxVisuals = XF86_GlxVisualsAll;
        }
        else {
            xf86Msg(X_WARNING, "Unknown GlxVisuals option\n");
        }
    }

    if (xf86GetOptValBool(FlagOptions, FLAG_AIGLX, &value)) {
        xf86Info.aiglx = value;
        xf86Info.aiglxFrom = X_CONFIG;
    }
    if (xf86Info.iglxFrom != X_CMDLINE) {
        if (xf86GetOptValBool(FlagOptions, FLAG_IGLX, &value)) {
            enableIndirectGLX = value;
            xf86Info.iglxFrom = X_CONFIG;
        }
    }
#endif

    /* if we're not hotplugging, force some input devices to exist */
    xf86Info.forceInputDevices = !(xf86Info.autoAddDevices &&
                                   xf86Info.autoEnableDevices);

    /* when forcing input devices, we use kbd. otherwise evdev, so use the
     * evdev rules set. */
#if defined(linux)
    if (!xf86Info.forceInputDevices)
        rules = "evdev";
    else
#endif
        rules = "base";

    /* Xkb default options. */
    XkbInitRules(&set, rules, "pc105", "us", NULL, NULL);
    XkbSetRulesDflts(&set);
    XkbFreeRMLVOSet(&set, FALSE);

    xf86Info.useDefaultFontPath = TRUE;
    if (xf86GetOptValBool(FlagOptions, FLAG_USE_DEFAULT_FONT_PATH, &value)) {
        xf86Info.useDefaultFontPath = value;
    }

/* Make sure that timers don't overflow CARD32's after multiplying */
#define MAX_TIME_IN_MIN (0x7fffffff / MILLI_PER_MIN)

    i = -1;
    xf86GetOptValInteger(FlagOptions, FLAG_SAVER_BLANKTIME, &i);
    if ((i >= 0) && (i < MAX_TIME_IN_MIN))
        ScreenSaverTime = defaultScreenSaverTime = i * MILLI_PER_MIN;
    else if (i != -1)
        ErrorF("BlankTime value %d outside legal range of 0 - %d minutes\n",
               i, MAX_TIME_IN_MIN);

#ifdef DPMSExtension
    i = -1;
    xf86GetOptValInteger(FlagOptions, FLAG_DPMS_STANDBYTIME, &i);
    if ((i >= 0) && (i < MAX_TIME_IN_MIN))
        DPMSStandbyTime = i * MILLI_PER_MIN;
    else if (i != -1)
        ErrorF("StandbyTime value %d outside legal range of 0 - %d minutes\n",
               i, MAX_TIME_IN_MIN);
    i = -1;
    xf86GetOptValInteger(FlagOptions, FLAG_DPMS_SUSPENDTIME, &i);
    if ((i >= 0) && (i < MAX_TIME_IN_MIN))
        DPMSSuspendTime = i * MILLI_PER_MIN;
    else if (i != -1)
        ErrorF("SuspendTime value %d outside legal range of 0 - %d minutes\n",
               i, MAX_TIME_IN_MIN);
    i = -1;
    xf86GetOptValInteger(FlagOptions, FLAG_DPMS_OFFTIME, &i);
    if ((i >= 0) && (i < MAX_TIME_IN_MIN))
        DPMSOffTime = i * MILLI_PER_MIN;
    else if (i != -1)
        ErrorF("OffTime value %d outside legal range of 0 - %d minutes\n",
               i, MAX_TIME_IN_MIN);
#endif

    i = -1;
    xf86GetOptValInteger(FlagOptions, FLAG_PIXMAP, &i);
    switch (i) {
    case 24:
        pix24 = Pix24Use24;
        break;
    case 32:
        pix24 = Pix24Use32;
        break;
    case -1:
        break;
    default:
        ErrorF("Pixmap option's value (%d) must be 24 or 32\n", i);
        break;
    }
    if (xf86Pix24 != Pix24DontCare) {
        xf86Info.pixmap24 = xf86Pix24;
        xf86Info.pix24From = X_CMDLINE;
    }
    else if (pix24 != Pix24DontCare) {
        xf86Info.pixmap24 = pix24;
        xf86Info.pix24From = X_CONFIG;
    }
    else {
        xf86Info.pixmap24 = Pix24DontCare;
        xf86Info.pix24From = X_DEFAULT;
    }

#ifdef PANORAMIX
    from = X_DEFAULT;
    if (!noPanoramiXExtension)
        from = X_CMDLINE;
    else if (xf86GetOptValBool(FlagOptions, FLAG_XINERAMA, &value)) {
        noPanoramiXExtension = !value;
        from = X_CONFIG;
    }
    if (!noPanoramiXExtension)
        xf86Msg(from, "Xinerama: enabled\n");
#endif

#ifdef DRI2
    xf86Info.dri2 = FALSE;
    xf86Info.dri2From = X_DEFAULT;
    if (xf86GetOptValBool(FlagOptions, FLAG_DRI2, &value)) {
        xf86Info.dri2 = value;
        xf86Info.dri2From = X_CONFIG;
    }
#endif

    from = X_DEFAULT;
    if (LimitClients != LIMITCLIENTS)
	from = X_CMDLINE;
    i = -1;
    if (xf86GetOptValInteger(FlagOptions, FLAG_MAX_CLIENTS, &i)) {
	if (i != 64 && i != 128 && i != 256 && i != 512)
		ErrorF("MaxClients must be one of 64, 128, 256 or 512\n");
	from = X_CONFIG;
	LimitClients = i;
    }
    xf86Msg(from, "Max clients allowed: %i, resource mask: 0x%x\n",
	    LimitClients, RESOURCE_ID_MASK);
}

Bool
xf86DRI2Enabled(void)
{
    return xf86Info.dri2;
}

/**
 * Search for the pInfo in the null-terminated list given and remove (and
 * free) it if present. All other devices are moved forward.
 */
static void
freeDevice(InputInfoPtr * list, InputInfoPtr pInfo)
{
    InputInfoPtr *devs;

    for (devs = list; devs && *devs; devs++) {
        if (*devs == pInfo) {
            free(*devs);
            for (; devs && *devs; devs++)
                devs[0] = devs[1];
            break;
        }
    }
}

/**
 * Append pInfo to the null-terminated list, allocating space as necessary.
 * pInfo is used as the last element.
 */
static InputInfoPtr *
addDevice(InputInfoPtr * list, InputInfoPtr pInfo)
{
    InputInfoPtr *devs;
    int count = 1;

    for (devs = list; devs && *devs; devs++)
        count++;

    list = xnfreallocarray(list, count + 1, sizeof(InputInfoPtr));
    list[count] = NULL;

    list[count - 1] = pInfo;
    return list;
}

/*
 * Locate the core input devices.  These can be specified/located in
 * the following ways, in order of priority:
 *
 *  1. The InputDevices named by the -pointer and -keyboard command line
 *     options.
 *  2. The "CorePointer" and "CoreKeyboard" InputDevices referred to by
 *     the active ServerLayout.
 *  3. The first InputDevices marked as "CorePointer" and "CoreKeyboard".
 *  4. The first InputDevices that use 'keyboard' or 'kbd' and a valid mouse
 *     driver (mouse, synaptics, evdev, vmmouse, void)
 *  5. Default devices with an empty (default) configuration.  These defaults
 *     will reference the 'mouse' and 'keyboard' drivers.
 */

static Bool
checkCoreInputDevices(serverLayoutPtr servlayoutp, Bool implicitLayout)
{
    InputInfoPtr corePointer = NULL, coreKeyboard = NULL;
    Bool foundPointer = FALSE, foundKeyboard = FALSE;
    const char *pointerMsg = NULL, *keyboardMsg = NULL;
    InputInfoPtr *devs,         /* iterator */
     indp;
    InputInfoPtr Pointer, Keyboard;
    XF86ConfInputPtr confInput;
    XF86ConfInputRec defPtr, defKbd;
    MessageType from = X_DEFAULT;

    const char *mousedrivers[] = { "mouse", "synaptics", "evdev", "vmmouse",
        "ws", "void", NULL
    };

    /*
     * First check if a core pointer or core keyboard have been specified
     * in the active ServerLayout.  If more than one is specified for either,
     * remove the core attribute from the later ones.
     */
    for (devs = servlayoutp->inputs; devs && *devs; devs++) {
        indp = *devs;
        if (indp->options &&
            xf86CheckBoolOption(indp->options, "CorePointer", FALSE)) {
            if (!corePointer) {
                corePointer = indp;
            }
        }
        if (indp->options &&
            xf86CheckBoolOption(indp->options, "CoreKeyboard", FALSE)) {
            if (!coreKeyboard) {
                coreKeyboard = indp;
            }
        }
    }

    confInput = NULL;

    /* 1. Check for the -pointer command line option. */
    if (xf86PointerName) {
        confInput = xf86findInput(xf86PointerName,
                                  xf86configptr->conf_input_lst);
        if (!confInput) {
            xf86Msg(X_ERROR, "No InputDevice section called \"%s\"\n",
                    xf86PointerName);
            return FALSE;
        }
        from = X_CMDLINE;
        /*
         * If one was already specified in the ServerLayout, it needs to be
         * removed.
         */
        if (corePointer) {
            freeDevice(servlayoutp->inputs, corePointer);
            corePointer = NULL;
        }
        foundPointer = TRUE;
    }

    /* 2. ServerLayout-specified core pointer. */
    if (corePointer) {
        foundPointer = TRUE;
        from = X_CONFIG;
    }

    /* 3. First core pointer device. */
    if (!foundPointer && (xf86Info.forceInputDevices || implicitLayout)) {
        XF86ConfInputPtr p;

        for (p = xf86configptr->conf_input_lst; p; p = p->list.next) {
            if (p->inp_option_lst &&
                xf86CheckBoolOption(p->inp_option_lst, "CorePointer", FALSE)) {
                confInput = p;
                foundPointer = TRUE;
                from = X_DEFAULT;
                pointerMsg = "first core pointer device";
                break;
            }
        }
    }

    /* 4. First pointer with an allowed mouse driver. */
    if (!foundPointer && xf86Info.forceInputDevices) {
        const char **driver = mousedrivers;

        confInput = xf86findInput(CONF_IMPLICIT_POINTER,
                                  xf86configptr->conf_input_lst);
        while (*driver && !confInput) {
            confInput = xf86findInputByDriver(*driver,
                                              xf86configptr->conf_input_lst);
            driver++;
        }
        if (confInput) {
            foundPointer = TRUE;
            from = X_DEFAULT;
            pointerMsg = "first mouse device";
        }
    }

    /* 5. Built-in default. */
    if (!foundPointer && xf86Info.forceInputDevices) {
        memset(&defPtr, 0, sizeof(defPtr));
        defPtr.inp_identifier = strdup("<default pointer>");
        defPtr.inp_driver = strdup("mouse");
        confInput = &defPtr;
        foundPointer = TRUE;
        from = X_DEFAULT;
        pointerMsg = "default mouse configuration";
    }

    /* Add the core pointer device to the layout, and set it to Core. */
    if (foundPointer && confInput) {
        Pointer = xf86AllocateInput();
        if (Pointer)
            foundPointer = configInput(Pointer, confInput, from);
        if (foundPointer) {
            Pointer->options = xf86AddNewOption(Pointer->options,
                                                "CorePointer", "on");
            Pointer->options = xf86AddNewOption(Pointer->options,
                                                "driver",
                                                confInput->inp_driver);
            Pointer->options =
                xf86AddNewOption(Pointer->options, "identifier",
                                 confInput->inp_identifier);
            servlayoutp->inputs = addDevice(servlayoutp->inputs, Pointer);
        }
    }

    if (!foundPointer && xf86Info.forceInputDevices) {
        /* This shouldn't happen. */
        xf86Msg(X_ERROR, "Cannot locate a core pointer device.\n");
        xf86DeleteInput(Pointer, 0);
        return FALSE;
    }

    confInput = NULL;

    /* 1. Check for the -keyboard command line option. */
    if (xf86KeyboardName) {
        confInput = xf86findInput(xf86KeyboardName,
                                  xf86configptr->conf_input_lst);
        if (!confInput) {
            xf86Msg(X_ERROR, "No InputDevice section called \"%s\"\n",
                    xf86KeyboardName);
            return FALSE;
        }
        from = X_CMDLINE;
        /*
         * If one was already specified in the ServerLayout, it needs to be
         * removed.
         */
        if (coreKeyboard) {
            freeDevice(servlayoutp->inputs, coreKeyboard);
            coreKeyboard = NULL;
        }
        foundKeyboard = TRUE;
    }

    /* 2. ServerLayout-specified core keyboard. */
    if (coreKeyboard) {
        foundKeyboard = TRUE;
        from = X_CONFIG;
    }

    /* 3. First core keyboard device. */
    if (!foundKeyboard && (xf86Info.forceInputDevices || implicitLayout)) {
        XF86ConfInputPtr p;

        for (p = xf86configptr->conf_input_lst; p; p = p->list.next) {
            if (p->inp_option_lst &&
                xf86CheckBoolOption(p->inp_option_lst, "CoreKeyboard", FALSE)) {
                confInput = p;
                foundKeyboard = TRUE;
                from = X_DEFAULT;
                keyboardMsg = "first core keyboard device";
                break;
            }
        }
    }

    /* 4. First keyboard with 'keyboard' or 'kbd' as the driver. */
    if (!foundKeyboard && xf86Info.forceInputDevices) {
        confInput = xf86findInput(CONF_IMPLICIT_KEYBOARD,
                                  xf86configptr->conf_input_lst);
        if (!confInput) {
            confInput = xf86findInputByDriver("kbd",
                                              xf86configptr->conf_input_lst);
        }
        if (confInput) {
            foundKeyboard = TRUE;
            from = X_DEFAULT;
            keyboardMsg = "first keyboard device";
        }
    }

    /* 5. Built-in default. */
    if (!foundKeyboard && xf86Info.forceInputDevices) {
        memset(&defKbd, 0, sizeof(defKbd));
        defKbd.inp_identifier = strdup("<default keyboard>");
        defKbd.inp_driver = strdup("kbd");
        confInput = &defKbd;
        foundKeyboard = TRUE;
        keyboardMsg = "default keyboard configuration";
        from = X_DEFAULT;
    }

    /* Add the core keyboard device to the layout, and set it to Core. */
    if (foundKeyboard && confInput) {
        Keyboard = xf86AllocateInput();
        if (Keyboard)
            foundKeyboard = configInput(Keyboard, confInput, from);
        if (foundKeyboard) {
            Keyboard->options = xf86AddNewOption(Keyboard->options,
                                                 "CoreKeyboard", "on");
            Keyboard->options = xf86AddNewOption(Keyboard->options,
                                                 "driver",
                                                 confInput->inp_driver);
            Keyboard->options =
                xf86AddNewOption(Keyboard->options, "identifier",
                                 confInput->inp_identifier);
            servlayoutp->inputs = addDevice(servlayoutp->inputs, Keyboard);
        }
    }

    if (!foundKeyboard && xf86Info.forceInputDevices) {
        /* This shouldn't happen. */
        xf86Msg(X_ERROR, "Cannot locate a core keyboard device.\n");
        xf86DeleteInput(Keyboard, 0);
        return FALSE;
    }

    if (pointerMsg) {
        if (implicitLayout)
            xf86Msg(X_DEFAULT, "No Layout section. Using the %s.\n",
                    pointerMsg);
        else
            xf86Msg(X_DEFAULT, "The core pointer device wasn't specified "
                    "explicitly in the layout.\n"
                    "\tUsing the %s.\n", pointerMsg);
    }

    if (keyboardMsg) {
        if (implicitLayout)
            xf86Msg(X_DEFAULT, "No Layout section. Using the %s.\n",
                    keyboardMsg);
        else
            xf86Msg(X_DEFAULT, "The core keyboard device wasn't specified "
                    "explicitly in the layout.\n"
                    "\tUsing the %s.\n", keyboardMsg);
    }

    if (!xf86Info.forceInputDevices && !(foundPointer && foundKeyboard)) {
#if defined(CONFIG_HAL) || defined(CONFIG_UDEV) || defined(CONFIG_WSCONS)
        const char *config_backend;

#if defined(CONFIG_HAL)
        config_backend = "HAL";
#elif defined(CONFIG_UDEV)
        config_backend = "udev";
#else
        config_backend = "wscons";
#endif
        xf86Msg(X_INFO, "The server relies on %s to provide the list of "
                "input devices.\n\tIf no devices become available, "
                "reconfigure %s or disable AutoAddDevices.\n",
                config_backend, config_backend);
#else
        xf86Msg(X_WARNING, "Hotplugging requested but the server was "
                "compiled without a config backend. "
                "No input devices were configured, the server "
                "will start without any input devices.\n");
#endif
    }

    return TRUE;
}

typedef enum {
    LAYOUT_ISOLATEDEVICE,
    LAYOUT_SINGLECARD
} LayoutValues;

static OptionInfoRec LayoutOptions[] = {
    {LAYOUT_ISOLATEDEVICE, "IsolateDevice", OPTV_STRING,
     {0}, FALSE},
    {LAYOUT_SINGLECARD, "SingleCard", OPTV_BOOLEAN,
     {0}, FALSE},
    {-1, NULL, OPTV_NONE,
     {0}, FALSE},
};

static Bool
configInputDevices(XF86ConfLayoutPtr layout, serverLayoutPtr servlayoutp)
{
    XF86ConfInputrefPtr irp;
    InputInfoPtr *indp;
    int count = 0;

    /*
     * Count the number of input devices.
     */
    irp = layout->lay_input_lst;
    while (irp) {
        count++;
        irp = (XF86ConfInputrefPtr) irp->list.next;
    }
    DebugF("Found %d input devices in the layout section %s\n",
           count, layout->lay_identifier);
    indp = xnfcalloc((count + 1), sizeof(InputInfoPtr));
    indp[count] = NULL;
    irp = layout->lay_input_lst;
    count = 0;
    while (irp) {
        indp[count] = xf86AllocateInput();
        if (!configInput(indp[count], irp->iref_inputdev, X_CONFIG)) {
            do {
                free(indp[count]);
            } while (count--);
            free(indp);
            return FALSE;
        }
        indp[count]->options = xf86OptionListMerge(indp[count]->options,
                                                   irp->iref_option_lst);
        count++;
        irp = (XF86ConfInputrefPtr) irp->list.next;
    }
    servlayoutp->inputs = indp;

    return TRUE;
}

/*
 * figure out which layout is active, which screens are used in that layout,
 * which drivers and monitors are used in these screens
 */
static Bool
configLayout(serverLayoutPtr servlayoutp, XF86ConfLayoutPtr conf_layout,
             char *default_layout)
{
    XF86ConfAdjacencyPtr adjp;
    XF86ConfInactivePtr idp;
    int saved_count, count = 0;
    int scrnum;
    XF86ConfLayoutPtr l;
    MessageType from;
    screenLayoutPtr slp;
    GDevPtr gdp;
    int i = 0, j;

    if (!servlayoutp)
        return FALSE;

    /*
     * which layout section is the active one?
     *
     * If there is a -layout command line option, use that one, otherwise
     * pick the first one.
     */
    from = X_DEFAULT;
    if (xf86LayoutName != NULL)
        from = X_CMDLINE;
    else if (default_layout) {
        xf86LayoutName = default_layout;
        from = X_CONFIG;
    }
    if (xf86LayoutName != NULL) {
        if ((l = xf86findLayout(xf86LayoutName, conf_layout)) == NULL) {
            xf86Msg(X_ERROR, "No ServerLayout section called \"%s\"\n",
                    xf86LayoutName);
            return FALSE;
        }
        conf_layout = l;
    }
    xf86Msg(from, "ServerLayout \"%s\"\n", conf_layout->lay_identifier);
    adjp = conf_layout->lay_adjacency_lst;

    /*
     * we know that each screen is referenced exactly once on the left side
     * of a layout statement in the Layout section. So to allocate the right
     * size for the array we do a quick walk of the list to figure out how
     * many sections we have
     */
    while (adjp) {
        count++;
        adjp = (XF86ConfAdjacencyPtr) adjp->list.next;
    }

    DebugF("Found %d screens in the layout section %s",
           count, conf_layout->lay_identifier);
    if (!count)                 /* alloc enough storage even if no screen is specified */
        count = 1;

    slp = xnfcalloc((count + 1), sizeof(screenLayoutRec));
    slp[count].screen = NULL;
    /*
     * now that we have storage, loop over the list again and fill in our
     * data structure; at this point we do not fill in the adjacency
     * information as it is not clear if we need it at all
     */
    adjp = conf_layout->lay_adjacency_lst;
    count = 0;
    while (adjp) {
        slp[count].screen = xnfcalloc(1, sizeof(confScreenRec));
        if (adjp->adj_scrnum < 0)
            scrnum = count;
        else
            scrnum = adjp->adj_scrnum;
        if (!configScreen(slp[count].screen, adjp->adj_screen, scrnum,
                          X_CONFIG, (scrnum == 0 && !adjp->list.next))) {
            do {
                free(slp[count].screen);
            } while (count--);
            free(slp);
            return FALSE;
        }
        slp[count].x = adjp->adj_x;
        slp[count].y = adjp->adj_y;
        slp[count].refname = adjp->adj_refscreen;
        switch (adjp->adj_where) {
        case CONF_ADJ_OBSOLETE:
            slp[count].where = PosObsolete;
            slp[count].topname = adjp->adj_top_str;
            slp[count].bottomname = adjp->adj_bottom_str;
            slp[count].leftname = adjp->adj_left_str;
            slp[count].rightname = adjp->adj_right_str;
            break;
        case CONF_ADJ_ABSOLUTE:
            slp[count].where = PosAbsolute;
            break;
        case CONF_ADJ_RIGHTOF:
            slp[count].where = PosRightOf;
            break;
        case CONF_ADJ_LEFTOF:
            slp[count].where = PosLeftOf;
            break;
        case CONF_ADJ_ABOVE:
            slp[count].where = PosAbove;
            break;
        case CONF_ADJ_BELOW:
            slp[count].where = PosBelow;
            break;
        case CONF_ADJ_RELATIVE:
            slp[count].where = PosRelative;
            break;
        }
        count++;
        adjp = (XF86ConfAdjacencyPtr) adjp->list.next;
    }

    /* No screen was specified in the layout. take the first one from the
     * config file, or - if it is NULL - configScreen autogenerates one for
     * us */
    if (!count) {
        XF86ConfScreenPtr screen;

        FIND_SUITABLE (XF86ConfScreenPtr, xf86configptr->conf_screen_lst, screen);
        slp[0].screen = xnfcalloc(1, sizeof(confScreenRec));
        if (!configScreen(slp[0].screen, screen,
                          0, X_CONFIG, TRUE)) {
            free(slp[0].screen);
            free(slp);
            return FALSE;
        }
    }

    /* XXX Need to tie down the upper left screen. */

    /* Fill in the refscreen and top/bottom/left/right values */
    for (i = 0; i < count; i++) {
        for (j = 0; j < count; j++) {
            if (slp[i].refname &&
                strcmp(slp[i].refname, slp[j].screen->id) == 0) {
                slp[i].refscreen = slp[j].screen;
            }
            if (slp[i].topname &&
                strcmp(slp[i].topname, slp[j].screen->id) == 0) {
                slp[i].top = slp[j].screen;
            }
            if (slp[i].bottomname &&
                strcmp(slp[i].bottomname, slp[j].screen->id) == 0) {
                slp[i].bottom = slp[j].screen;
            }
            if (slp[i].leftname &&
                strcmp(slp[i].leftname, slp[j].screen->id) == 0) {
                slp[i].left = slp[j].screen;
            }
            if (slp[i].rightname &&
                strcmp(slp[i].rightname, slp[j].screen->id) == 0) {
                slp[i].right = slp[j].screen;
            }
        }
        if (slp[i].where != PosObsolete
            && slp[i].where != PosAbsolute && !slp[i].refscreen) {
            xf86Msg(X_ERROR, "Screen %s doesn't exist: deleting placement\n",
                    slp[i].refname);
            slp[i].where = PosAbsolute;
            slp[i].x = 0;
            slp[i].y = 0;
        }
    }

    if (!count)
        saved_count = 1;
    else
        saved_count = count;
    /*
     * Count the number of inactive devices.
     */
    count = 0;
    idp = conf_layout->lay_inactive_lst;
    while (idp) {
        count++;
        idp = (XF86ConfInactivePtr) idp->list.next;
    }
    DebugF("Found %d inactive devices in the layout section %s\n",
           count, conf_layout->lay_identifier);
    gdp = xnfallocarray(count + 1, sizeof(GDevRec));
    gdp[count].identifier = NULL;
    idp = conf_layout->lay_inactive_lst;
    count = 0;
    while (idp) {
        if (!configDevice(&gdp[count], idp->inactive_device, FALSE, FALSE))
            goto bail;
        count++;
        idp = (XF86ConfInactivePtr) idp->list.next;
    }

    if (!configInputDevices(conf_layout, servlayoutp))
        goto bail;

    servlayoutp->id = conf_layout->lay_identifier;
    servlayoutp->screens = slp;
    servlayoutp->inactives = gdp;
    servlayoutp->options = conf_layout->lay_option_lst;
    from = X_DEFAULT;

    return TRUE;

 bail:
    do {
        free(slp[saved_count].screen);
    } while (saved_count--);
    free(slp);
    free(gdp);
    return FALSE;
}

/*
 * No layout section, so find the first Screen section and set that up as
 * the only active screen.
 */
static Bool
configImpliedLayout(serverLayoutPtr servlayoutp, XF86ConfScreenPtr conf_screen,
                    XF86ConfigPtr conf_ptr)
{
    MessageType from;
    XF86ConfScreenPtr s;
    screenLayoutPtr slp;
    InputInfoPtr *indp;
    XF86ConfLayoutRec layout;

    if (!servlayoutp)
        return FALSE;

    /*
     * which screen section is the active one?
     *
     * If there is a -screen option, use that one, otherwise use the first
     * one.
     */

    from = X_CONFIG;
    if (xf86ScreenName != NULL) {
        if ((s = xf86findScreen(xf86ScreenName, conf_screen)) == NULL) {
            xf86Msg(X_ERROR, "No Screen section called \"%s\"\n",
                    xf86ScreenName);
            return FALSE;
        }
        conf_screen = s;
        from = X_CMDLINE;
    }

    /* We have exactly one screen */

    slp = xnfcalloc(1, 2 * sizeof(screenLayoutRec));
    slp[0].screen = xnfcalloc(1, sizeof(confScreenRec));
    slp[1].screen = NULL;
    if (!configScreen(slp[0].screen, conf_screen, 0, from, TRUE)) {
        free(slp);
        return FALSE;
    }
    servlayoutp->id = "(implicit)";
    servlayoutp->screens = slp;
    servlayoutp->inactives = xnfcalloc(1, sizeof(GDevRec));
    servlayoutp->options = NULL;

    memset(&layout, 0, sizeof(layout));
    layout.lay_identifier = servlayoutp->id;
    if (xf86layoutAddInputDevices(conf_ptr, &layout) > 0) {
        if (!configInputDevices(&layout, servlayoutp))
            return FALSE;
        from = X_DEFAULT;
    }
    else {
        /* Set up an empty input device list, then look for some core devices. */
        indp = xnfalloc(sizeof(InputInfoPtr));
        *indp = NULL;
        servlayoutp->inputs = indp;
    }

    return TRUE;
}

static Bool
configXvAdaptor(confXvAdaptorPtr adaptor, XF86ConfVideoAdaptorPtr conf_adaptor)
{
    int count = 0;
    XF86ConfVideoPortPtr conf_port;

    xf86Msg(X_CONFIG, "|   |-->VideoAdaptor \"%s\"\n",
            conf_adaptor->va_identifier);
    adaptor->identifier = conf_adaptor->va_identifier;
    adaptor->options = conf_adaptor->va_option_lst;
    if (conf_adaptor->va_busid || conf_adaptor->va_driver) {
        xf86Msg(X_CONFIG, "|   | Unsupported device type, skipping entry\n");
        return FALSE;
    }

    /*
     * figure out how many videoport subsections there are and fill them in
     */
    conf_port = conf_adaptor->va_port_lst;
    while (conf_port) {
        count++;
        conf_port = (XF86ConfVideoPortPtr) conf_port->list.next;
    }
    adaptor->ports = xnfallocarray(count, sizeof(confXvPortRec));
    adaptor->numports = count;
    count = 0;
    conf_port = conf_adaptor->va_port_lst;
    while (conf_port) {
        adaptor->ports[count].identifier = conf_port->vp_identifier;
        adaptor->ports[count].options = conf_port->vp_option_lst;
        count++;
        conf_port = (XF86ConfVideoPortPtr) conf_port->list.next;
    }

    return TRUE;
}

static Bool
configScreen(confScreenPtr screenp, XF86ConfScreenPtr conf_screen, int scrnum,
             MessageType from, Bool auto_gpu_device)
{
    int count = 0;
    XF86ConfDisplayPtr dispptr;
    XF86ConfAdaptorLinkPtr conf_adaptor;
    Bool defaultMonitor = FALSE;
    XF86ConfScreenRec local_conf_screen;
    int i;

    if (!conf_screen) {
        memset(&local_conf_screen, 0, sizeof(local_conf_screen));
        conf_screen = &local_conf_screen;
        conf_screen->scrn_identifier = "Default Screen Section";
        xf86Msg(X_DEFAULT, "No screen section available. Using defaults.\n");
    }

    xf86Msg(from, "|-->Screen \"%s\" (%d)\n", conf_screen->scrn_identifier,
            scrnum);
    /*
     * now we fill in the elements of the screen
     */
    screenp->id = conf_screen->scrn_identifier;
    screenp->screennum = scrnum;
    screenp->defaultdepth = conf_screen->scrn_defaultdepth;
    screenp->defaultbpp = conf_screen->scrn_defaultbpp;
    screenp->defaultfbbpp = conf_screen->scrn_defaultfbbpp;
    screenp->monitor = xnfcalloc(1, sizeof(MonRec));
    /* If no monitor is specified, create a default one. */
    if (!conf_screen->scrn_monitor) {
        XF86ConfMonitorRec defMon;

        memset(&defMon, 0, sizeof(defMon));
        defMon.mon_identifier = "<default monitor>";
        if (!configMonitor(screenp->monitor, &defMon))
            return FALSE;
        defaultMonitor = TRUE;
    }
    else {
        if (!configMonitor(screenp->monitor, conf_screen->scrn_monitor))
            return FALSE;
    }
    /* Configure the device. If there isn't one configured, attach to the
     * first inactive one that we can configure. If there's none that work,
     * set it to NULL so that the section can be autoconfigured later */
    screenp->device = xnfcalloc(1, sizeof(GDevRec));
    if ((!conf_screen->scrn_device) && (xf86configptr->conf_device_lst)) {
        FIND_SUITABLE (XF86ConfDevicePtr, xf86configptr->conf_device_lst, conf_screen->scrn_device);
        xf86Msg(X_DEFAULT, "No device specified for screen \"%s\".\n"
                "\tUsing the first device section listed.\n", screenp->id);
    }
    if (configDevice(screenp->device, conf_screen->scrn_device, TRUE, FALSE)) {
        screenp->device->myScreenSection = screenp;
    }
    else {
        screenp->device = NULL;
    }

    if (auto_gpu_device && conf_screen->num_gpu_devices == 0 &&
        xf86configptr->conf_device_lst) {
        XF86ConfDevicePtr sdevice = xf86configptr->conf_device_lst->list.next;

        for (i = 0; i < MAX_GPUDEVICES; i++) {
            if (!sdevice)
                break;

            FIND_SUITABLE (XF86ConfDevicePtr, sdevice, conf_screen->scrn_gpu_devices[i]);
            if (!conf_screen->scrn_gpu_devices[i])
                break;
            screenp->gpu_devices[i] = xnfcalloc(1, sizeof(GDevRec));
            if (configDevice(screenp->gpu_devices[i], conf_screen->scrn_gpu_devices[i], TRUE, TRUE)) {
                screenp->gpu_devices[i]->myScreenSection = screenp;
            }
            sdevice = conf_screen->scrn_gpu_devices[i]->list.next;
        }
        screenp->num_gpu_devices = i;

    } else {
        for (i = 0; i < conf_screen->num_gpu_devices; i++) {
            screenp->gpu_devices[i] = xnfcalloc(1, sizeof(GDevRec));
            if (configDevice(screenp->gpu_devices[i], conf_screen->scrn_gpu_devices[i], TRUE, TRUE)) {
                screenp->gpu_devices[i]->myScreenSection = screenp;
            }
        }
        screenp->num_gpu_devices = conf_screen->num_gpu_devices;
    }

    screenp->options = conf_screen->scrn_option_lst;

    /*
     * figure out how many display subsections there are and fill them in
     */
    dispptr = conf_screen->scrn_display_lst;
    while (dispptr) {
        count++;
        dispptr = (XF86ConfDisplayPtr) dispptr->list.next;
    }
    screenp->displays = xnfallocarray(count, sizeof(DispRec));
    screenp->numdisplays = count;

    /* Fill in the default Virtual size, if any */
    if (conf_screen->scrn_virtualX && conf_screen->scrn_virtualY) {
        for (count = 0, dispptr = conf_screen->scrn_display_lst;
             dispptr;
             dispptr = (XF86ConfDisplayPtr) dispptr->list.next, count++) {
            screenp->displays[count].virtualX = conf_screen->scrn_virtualX;
            screenp->displays[count].virtualY = conf_screen->scrn_virtualY;
        }
    }

    /* Now do the per-Display Virtual sizes */
    count = 0;
    dispptr = conf_screen->scrn_display_lst;
    while (dispptr) {
        configDisplay(&(screenp->displays[count]), dispptr);
        count++;
        dispptr = (XF86ConfDisplayPtr) dispptr->list.next;
    }

    /*
     * figure out how many videoadaptor references there are and fill them in
     */
    conf_adaptor = conf_screen->scrn_adaptor_lst;
    while (conf_adaptor) {
        count++;
        conf_adaptor = (XF86ConfAdaptorLinkPtr) conf_adaptor->list.next;
    }
    screenp->xvadaptors = xnfallocarray(count, sizeof(confXvAdaptorRec));
    screenp->numxvadaptors = 0;
    conf_adaptor = conf_screen->scrn_adaptor_lst;
    while (conf_adaptor) {
        if (configXvAdaptor(&(screenp->xvadaptors[screenp->numxvadaptors]),
                            conf_adaptor->al_adaptor))
            screenp->numxvadaptors++;
        conf_adaptor = (XF86ConfAdaptorLinkPtr) conf_adaptor->list.next;
    }

    if (defaultMonitor) {
        xf86Msg(X_DEFAULT, "No monitor specified for screen \"%s\".\n"
                "\tUsing a default monitor configuration.\n", screenp->id);
    }
    return TRUE;
}

typedef enum {
    MON_REDUCEDBLANKING,
    MON_MAX_PIX_CLOCK,
} MonitorValues;

static OptionInfoRec MonitorOptions[] = {
    {MON_REDUCEDBLANKING, "ReducedBlanking", OPTV_BOOLEAN,
     {0}, FALSE},
    {MON_MAX_PIX_CLOCK, "MaxPixClock", OPTV_FREQ,
     {0}, FALSE},
    {-1, NULL, OPTV_NONE,
     {0}, FALSE},
};

static Bool
configMonitor(MonPtr monitorp, XF86ConfMonitorPtr conf_monitor)
{
    int count;
    DisplayModePtr mode, last = NULL;
    XF86ConfModeLinePtr cmodep;
    XF86ConfModesPtr modes;
    XF86ConfModesLinkPtr modeslnk = conf_monitor->mon_modes_sect_lst;
    Gamma zeros = { 0.0, 0.0, 0.0 };
    float badgamma = 0.0;
    double maxPixClock;

    xf86Msg(X_CONFIG, "|   |-->Monitor \"%s\"\n", conf_monitor->mon_identifier);
    monitorp->id = conf_monitor->mon_identifier;
    monitorp->vendor = conf_monitor->mon_vendor;
    monitorp->model = conf_monitor->mon_modelname;
    monitorp->Modes = NULL;
    monitorp->Last = NULL;
    monitorp->gamma = zeros;
    monitorp->widthmm = conf_monitor->mon_width;
    monitorp->heightmm = conf_monitor->mon_height;
    monitorp->reducedblanking = FALSE;
    monitorp->maxPixClock = 0;
    monitorp->options = conf_monitor->mon_option_lst;

    /*
     * fill in the monitor structure
     */
    for (count = 0;
         count < conf_monitor->mon_n_hsync && count < MAX_HSYNC; count++) {
        monitorp->hsync[count].hi = conf_monitor->mon_hsync[count].hi;
        monitorp->hsync[count].lo = conf_monitor->mon_hsync[count].lo;
    }
    monitorp->nHsync = count;
    for (count = 0;
         count < conf_monitor->mon_n_vrefresh && count < MAX_VREFRESH;
         count++) {
        monitorp->vrefresh[count].hi = conf_monitor->mon_vrefresh[count].hi;
        monitorp->vrefresh[count].lo = conf_monitor->mon_vrefresh[count].lo;
    }
    monitorp->nVrefresh = count;

    /*
     * first we collect the mode lines from the UseModes directive
     */
    while (modeslnk) {
        modes = xf86findModes(modeslnk->ml_modes_str,
                              xf86configptr->conf_modes_lst);
        modeslnk->ml_modes = modes;

        /* now add the modes found in the modes
           section to the list of modes for this
           monitor unless it has been added before
           because we are reusing the same section
           for another screen */
        if (xf86itemNotSublist((GenericListPtr) conf_monitor->mon_modeline_lst,
                               (GenericListPtr) modes->mon_modeline_lst)) {
            conf_monitor->mon_modeline_lst = (XF86ConfModeLinePtr)
                xf86addListItem((GenericListPtr) conf_monitor->mon_modeline_lst,
                                (GenericListPtr) modes->mon_modeline_lst);
        }
        modeslnk = modeslnk->list.next;
    }

    /*
     * we need to hook in the mode lines now
     * here both data structures use lists, only our internal one
     * is double linked
     */
    cmodep = conf_monitor->mon_modeline_lst;
    while (cmodep) {
        mode = xnfcalloc(1, sizeof(DisplayModeRec));
        mode->type = 0;
        mode->Clock = cmodep->ml_clock;
        mode->HDisplay = cmodep->ml_hdisplay;
        mode->HSyncStart = cmodep->ml_hsyncstart;
        mode->HSyncEnd = cmodep->ml_hsyncend;
        mode->HTotal = cmodep->ml_htotal;
        mode->VDisplay = cmodep->ml_vdisplay;
        mode->VSyncStart = cmodep->ml_vsyncstart;
        mode->VSyncEnd = cmodep->ml_vsyncend;
        mode->VTotal = cmodep->ml_vtotal;
        mode->Flags = cmodep->ml_flags;
        mode->HSkew = cmodep->ml_hskew;
        mode->VScan = cmodep->ml_vscan;
        mode->name = xnfstrdup(cmodep->ml_identifier);
        if (last) {
            mode->prev = last;
            last->next = mode;
        }
        else {
            /*
             * this is the first mode
             */
            monitorp->Modes = mode;
            mode->prev = NULL;
        }
        last = mode;
        cmodep = (XF86ConfModeLinePtr) cmodep->list.next;
    }
    if (last) {
        last->next = NULL;
    }
    monitorp->Last = last;

    /* add the (VESA) default modes */
    if (!addDefaultModes(monitorp))
        return FALSE;

    if (conf_monitor->mon_gamma_red > GAMMA_ZERO)
        monitorp->gamma.red = conf_monitor->mon_gamma_red;
    if (conf_monitor->mon_gamma_green > GAMMA_ZERO)
        monitorp->gamma.green = conf_monitor->mon_gamma_green;
    if (conf_monitor->mon_gamma_blue > GAMMA_ZERO)
        monitorp->gamma.blue = conf_monitor->mon_gamma_blue;

    /* Check that the gamma values are within range */
    if (monitorp->gamma.red > GAMMA_ZERO &&
        (monitorp->gamma.red < GAMMA_MIN || monitorp->gamma.red > GAMMA_MAX)) {
        badgamma = monitorp->gamma.red;
    }
    else if (monitorp->gamma.green > GAMMA_ZERO &&
             (monitorp->gamma.green < GAMMA_MIN ||
              monitorp->gamma.green > GAMMA_MAX)) {
        badgamma = monitorp->gamma.green;
    }
    else if (monitorp->gamma.blue > GAMMA_ZERO &&
             (monitorp->gamma.blue < GAMMA_MIN ||
              monitorp->gamma.blue > GAMMA_MAX)) {
        badgamma = monitorp->gamma.blue;
    }
    if (badgamma > GAMMA_ZERO) {
        ErrorF("Gamma value %.f is out of range (%.2f - %.1f)\n", badgamma,
               GAMMA_MIN, GAMMA_MAX);
        return FALSE;
    }

    xf86ProcessOptions(-1, monitorp->options, MonitorOptions);
    xf86GetOptValBool(MonitorOptions, MON_REDUCEDBLANKING,
                      &monitorp->reducedblanking);
    if (xf86GetOptValFreq(MonitorOptions, MON_MAX_PIX_CLOCK, OPTUNITS_KHZ,
                          &maxPixClock) == TRUE) {
        monitorp->maxPixClock = (int) maxPixClock;
    }

    return TRUE;
}

static int
lookupVisual(const char *visname)
{
    int i;

    if (!visname || !*visname)
        return -1;

    for (i = 0; i <= DirectColor; i++) {
        if (!xf86nameCompare(visname, xf86VisualNames[i]))
            break;
    }

    if (i <= DirectColor)
        return i;

    return -1;
}

static Bool
configDisplay(DispPtr displayp, XF86ConfDisplayPtr conf_display)
{
    int count = 0;
    XF86ModePtr modep;

    displayp->frameX0 = conf_display->disp_frameX0;
    displayp->frameY0 = conf_display->disp_frameY0;
    displayp->virtualX = conf_display->disp_virtualX;
    displayp->virtualY = conf_display->disp_virtualY;
    displayp->depth = conf_display->disp_depth;
    displayp->fbbpp = conf_display->disp_bpp;
    displayp->weight.red = conf_display->disp_weight.red;
    displayp->weight.green = conf_display->disp_weight.green;
    displayp->weight.blue = conf_display->disp_weight.blue;
    displayp->blackColour.red = conf_display->disp_black.red;
    displayp->blackColour.green = conf_display->disp_black.green;
    displayp->blackColour.blue = conf_display->disp_black.blue;
    displayp->whiteColour.red = conf_display->disp_white.red;
    displayp->whiteColour.green = conf_display->disp_white.green;
    displayp->whiteColour.blue = conf_display->disp_white.blue;
    displayp->options = conf_display->disp_option_lst;
    if (conf_display->disp_visual) {
        displayp->defaultVisual = lookupVisual(conf_display->disp_visual);
        if (displayp->defaultVisual == -1) {
            ErrorF("Invalid visual name: \"%s\"\n", conf_display->disp_visual);
            return FALSE;
        }
    }
    else {
        displayp->defaultVisual = -1;
    }

    /*
     * now hook in the modes
     */
    modep = conf_display->disp_mode_lst;
    while (modep) {
        count++;
        modep = (XF86ModePtr) modep->list.next;
    }
    displayp->modes = xnfallocarray(count + 1, sizeof(char *));
    modep = conf_display->disp_mode_lst;
    count = 0;
    while (modep) {
        displayp->modes[count] = modep->mode_name;
        count++;
        modep = (XF86ModePtr) modep->list.next;
    }
    displayp->modes[count] = NULL;

    return TRUE;
}

static Bool
configDevice(GDevPtr devicep, XF86ConfDevicePtr conf_device, Bool active, Bool gpu)
{
    int i;

    if (!conf_device) {
        return FALSE;
    }

    if (active) {
        if (gpu)
            xf86Msg(X_CONFIG, "|   |-->GPUDevice \"%s\"\n",
                    conf_device->dev_identifier);
        else
            xf86Msg(X_CONFIG, "|   |-->Device \"%s\"\n",
                    conf_device->dev_identifier);
    } else
        xf86Msg(X_CONFIG, "|-->Inactive Device \"%s\"\n",
                conf_device->dev_identifier);

    devicep->identifier = conf_device->dev_identifier;
    devicep->vendor = conf_device->dev_vendor;
    devicep->board = conf_device->dev_board;
    devicep->chipset = conf_device->dev_chipset;
    devicep->ramdac = conf_device->dev_ramdac;
    devicep->driver = conf_device->dev_driver;
    devicep->active = active;
    devicep->videoRam = conf_device->dev_videoram;
    devicep->BiosBase = conf_device->dev_bios_base;
    devicep->MemBase = conf_device->dev_mem_base;
    devicep->IOBase = conf_device->dev_io_base;
    devicep->clockchip = conf_device->dev_clockchip;
    devicep->busID = conf_device->dev_busid;
    devicep->chipID = conf_device->dev_chipid;
    devicep->chipRev = conf_device->dev_chiprev;
    devicep->options = conf_device->dev_option_lst;
    devicep->irq = conf_device->dev_irq;
    devicep->screen = conf_device->dev_screen;

    for (i = 0; i < MAXDACSPEEDS; i++) {
        if (i < CONF_MAXDACSPEEDS)
            devicep->dacSpeeds[i] = conf_device->dev_dacSpeeds[i];
        else
            devicep->dacSpeeds[i] = 0;
    }
    devicep->numclocks = conf_device->dev_clocks;
    if (devicep->numclocks > MAXCLOCKS)
        devicep->numclocks = MAXCLOCKS;
    for (i = 0; i < devicep->numclocks; i++) {
        devicep->clock[i] = conf_device->dev_clock[i];
    }
    devicep->claimed = FALSE;

    return TRUE;
}

static void
configDRI(XF86ConfDRIPtr drip)
{
    struct group *grp;

    xf86ConfigDRI.group = -1;
    xf86ConfigDRI.mode = 0;

    if (drip) {
        if (drip->dri_group_name) {
            if ((grp = getgrnam(drip->dri_group_name)))
                xf86ConfigDRI.group = grp->gr_gid;
        }
        else {
            if (drip->dri_group >= 0)
                xf86ConfigDRI.group = drip->dri_group;
        }
        xf86ConfigDRI.mode = drip->dri_mode;
    }
}

static void
configExtensions(XF86ConfExtensionsPtr conf_ext)
{
    XF86OptionPtr o;

    if (conf_ext && conf_ext->ext_option_lst) {
        for (o = conf_ext->ext_option_lst; o; o = xf86NextOption(o)) {
            char *name = xf86OptionName(o);
            char *val = xf86OptionValue(o);
            char *n;
            Bool enable = TRUE;

            /* Handle "No<ExtensionName>" */
            n = xf86NormalizeName(name);
            if (strncmp(n, "no", 2) == 0) {
                name += 2;
                enable = FALSE;
            }

            if (!val ||
                xf86NameCmp(val, "enable") == 0 ||
                xf86NameCmp(val, "enabled") == 0 ||
                xf86NameCmp(val, "on") == 0 ||
                xf86NameCmp(val, "1") == 0 ||
                xf86NameCmp(val, "yes") == 0 || xf86NameCmp(val, "true") == 0) {
                /* NOTHING NEEDED -- enabling is handled below */
            }
            else if (xf86NameCmp(val, "disable") == 0 ||
                     xf86NameCmp(val, "disabled") == 0 ||
                     xf86NameCmp(val, "off") == 0 ||
                     xf86NameCmp(val, "0") == 0 ||
                     xf86NameCmp(val, "no") == 0 ||
                     xf86NameCmp(val, "false") == 0) {
                enable = !enable;
            }
            else {
                xf86Msg(X_WARNING, "Ignoring unrecognized value \"%s\"\n", val);
                free(n);
                continue;
            }

            if (EnableDisableExtension(name, enable)) {
                xf86Msg(X_CONFIG, "Extension \"%s\" is %s\n",
                        name, enable ? "enabled" : "disabled");
            }
            else {
                xf86Msg(X_WARNING, "Ignoring unrecognized extension \"%s\"\n",
                        name);
            }
            free(n);
        }
    }
}

static Bool
configInput(InputInfoPtr inputp, XF86ConfInputPtr conf_input, MessageType from)
{
    xf86Msg(from, "|-->Input Device \"%s\"\n", conf_input->inp_identifier);
    inputp->name = conf_input->inp_identifier;
    inputp->driver = conf_input->inp_driver;
    inputp->options = conf_input->inp_option_lst;
    inputp->attrs = NULL;

    return TRUE;
}

static Bool
modeIsPresent(DisplayModePtr mode, MonPtr monitorp)
{
    DisplayModePtr knownmodes = monitorp->Modes;

    /* all I can think of is a linear search... */
    while (knownmodes != NULL) {
        if (!strcmp(mode->name, knownmodes->name) &&
            !(knownmodes->type & M_T_DEFAULT))
            return TRUE;
        knownmodes = knownmodes->next;
    }
    return FALSE;
}

static Bool
addDefaultModes(MonPtr monitorp)
{
    DisplayModePtr mode;
    DisplayModePtr last = monitorp->Last;
    int i = 0;

    for (i = 0; i < xf86NumDefaultModes; i++) {
        mode = xf86DuplicateMode(&xf86DefaultModes[i]);
        if (!modeIsPresent(mode, monitorp)) {
            monitorp->Modes = xf86ModesAdd(monitorp->Modes, mode);
            last = mode;
        }
        else {
            free(mode);
        }
    }
    monitorp->Last = last;

    return TRUE;
}

static void
checkInput(serverLayoutPtr layout, Bool implicit_layout)
{
    checkCoreInputDevices(layout, implicit_layout);

    /* Unless we're forcing input devices, disable mouse/kbd devices in the
     * config. Otherwise the same physical device is added multiple times,
     * leading to duplicate events.
     */
    if (!xf86Info.forceInputDevices && layout->inputs) {
        InputInfoPtr *dev = layout->inputs;
        BOOL warned = FALSE;

        while (*dev) {
            if (strcmp((*dev)->driver, "kbd") == 0 ||
                strcmp((*dev)->driver, "mouse") == 0 ||
                strcmp((*dev)->driver, "vmmouse") == 0) {
                InputInfoPtr *current;

                if (!warned) {
                    xf86Msg(X_WARNING, "Hotplugging is on, devices using "
                            "drivers 'kbd', 'mouse' or 'vmmouse' will be disabled.\n");
                    warned = TRUE;
                }

                xf86Msg(X_WARNING, "Disabling %s\n", (*dev)->name);

                current = dev;
                free(*dev);
                *dev = NULL;

                do {
                    *current = *(current + 1);
                    current++;
                } while (*current);
            }
            else
                dev++;
        }
    }
}

/*
 * load the config file and fill the global data structure
 */
ConfigStatus
xf86HandleConfigFile(Bool autoconfig)
{
    const char *scanptr;
    Bool singlecard = 0;
    Bool implicit_layout = FALSE;
    XF86ConfLayoutPtr layout;

    if (!autoconfig) {
        char *filename, *dirname, *sysdirname;
        const char *filesearch, *dirsearch;
        MessageType filefrom = X_DEFAULT;
        MessageType dirfrom = X_DEFAULT;

        if (!xf86PrivsElevated()) {
            filesearch = ALL_CONFIGPATH;
            dirsearch = ALL_CONFIGDIRPATH;
        }
        else {
            filesearch = RESTRICTED_CONFIGPATH;
            dirsearch = RESTRICTED_CONFIGDIRPATH;
        }

        if (xf86ConfigFile)
            filefrom = X_CMDLINE;
        if (xf86ConfigDir)
            dirfrom = X_CMDLINE;

        xf86initConfigFiles();
        sysdirname = xf86openConfigDirFiles(SYS_CONFIGDIRPATH, NULL,
                                            PROJECTROOT);
        dirname = xf86openConfigDirFiles(dirsearch, xf86ConfigDir, PROJECTROOT);
        filename = xf86openConfigFile(filesearch, xf86ConfigFile, PROJECTROOT);
        if (filename) {
            xf86MsgVerb(filefrom, 0, "Using config file: \"%s\"\n", filename);
            xf86ConfigFile = xnfstrdup(filename);
        }
        else {
            if (xf86ConfigFile)
                xf86Msg(X_ERROR, "Unable to locate/open config file: \"%s\"\n",
                        xf86ConfigFile);
        }
        if (dirname) {
            xf86MsgVerb(dirfrom, 0, "Using config directory: \"%s\"\n",
                        dirname);
            xf86ConfigDir = xnfstrdup(dirname);
        }
        else {
            if (xf86ConfigDir)
                xf86Msg(X_ERROR,
                        "Unable to locate/open config directory: \"%s\"\n",
                        xf86ConfigDir);
        }
        if (sysdirname)
            xf86MsgVerb(X_DEFAULT, 0, "Using system config directory \"%s\"\n",
                        sysdirname);
        if (!filename && !dirname && !sysdirname)
            return CONFIG_NOFILE;

        free(filename);
        free(dirname);
        free(sysdirname);
    }

    if ((xf86configptr = xf86readConfigFile()) == NULL) {
        xf86Msg(X_ERROR, "Problem parsing the config file\n");
        return CONFIG_PARSE_ERROR;
    }
    xf86closeConfigFile();

    /* Initialise a few things. */

    /*
     * now we convert part of the information contained in the parser
     * structures into our own structures.
     * The important part here is to figure out which Screen Sections
     * in the XF86Config file are active so that we can piece together
     * the modes that we need later down the road.
     * And while we are at it, we'll decode the rest of the stuff as well
     */

    /* First check if a layout section is present, and if it is valid. */
    FIND_SUITABLE(XF86ConfLayoutPtr, xf86configptr->conf_layout_lst, layout);
    if (layout == NULL || xf86ScreenName != NULL) {
        XF86ConfScreenPtr screen;

        if (xf86ScreenName == NULL) {
            xf86Msg(X_DEFAULT,
                    "No Layout section.  Using the first Screen section.\n");
        }
        FIND_SUITABLE (XF86ConfScreenPtr, xf86configptr->conf_screen_lst, screen);
        if (!configImpliedLayout(&xf86ConfigLayout,
                                 screen,
                                 xf86configptr)) {
            xf86Msg(X_ERROR, "Unable to determine the screen layout\n");
            return CONFIG_PARSE_ERROR;
        }
        implicit_layout = TRUE;
    }
    else {
        if (xf86configptr->conf_flags != NULL) {
            char *dfltlayout = NULL;
            void *optlist = xf86configptr->conf_flags->flg_option_lst;

            if (optlist && xf86FindOption(optlist, "defaultserverlayout"))
                dfltlayout =
                    xf86SetStrOption(optlist, "defaultserverlayout", NULL);
            if (!configLayout(&xf86ConfigLayout, layout, dfltlayout)) {
                xf86Msg(X_ERROR, "Unable to determine the screen layout\n");
                return CONFIG_PARSE_ERROR;
            }
        }
        else {
            if (!configLayout(&xf86ConfigLayout, layout, NULL)) {
                xf86Msg(X_ERROR, "Unable to determine the screen layout\n");
                return CONFIG_PARSE_ERROR;
            }
        }
    }

    xf86ProcessOptions(-1, xf86ConfigLayout.options, LayoutOptions);
#ifdef XSERVER_LIBPCIACCESS
    if ((scanptr = xf86GetOptValString(LayoutOptions, LAYOUT_ISOLATEDEVICE))) {
        ;                       /* IsolateDevice specified; overrides SingleCard */
    }
    else {
        xf86GetOptValBool(LayoutOptions, LAYOUT_SINGLECARD, &singlecard);
        if (singlecard)
            scanptr = xf86ConfigLayout.screens->screen->device->busID;
    }
    if (scanptr) {
        if (strncmp(scanptr, "PCI:", 4) != 0) {
            xf86Msg(X_WARNING, "Bus types other than PCI not yet isolable.\n"
                    "\tIgnoring IsolateDevice option.\n");
        }
        else
            xf86PciIsolateDevice(scanptr);
    }
#endif
    /* Now process everything else */
    configServerFlags(xf86configptr->conf_flags, xf86ConfigLayout.options);
    configFiles(xf86configptr->conf_files);
    configExtensions(xf86configptr->conf_extensions);
    configDRI(xf86configptr->conf_dri);

    checkInput(&xf86ConfigLayout, implicit_layout);

    /*
     * Handle some command line options that can override some of the
     * ServerFlags settings.
     */
#ifdef XF86VIDMODE
    if (xf86VidModeDisabled)
        xf86Info.vidModeEnabled = FALSE;
    if (xf86VidModeAllowNonLocal)
        xf86Info.vidModeAllowNonLocal = TRUE;
#endif

    if (xf86AllowMouseOpenFail)
        xf86Info.allowMouseOpenFail = TRUE;

    return CONFIG_OK;
}

Bool
xf86PathIsSafe(const char *path)
{
    return (xf86pathIsSafe(path) != 0);
}
@


1.24
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d521 38
d562 1
a562 4
    static const char *fallback[5] = { "modesetting", "fbdev", "vesa", "wsfb", NULL };
    const char **end, **drv;
    const char *x;
    int i;
d567 2
a568 15
    /*
     * for each of the fallback drivers, if we find it in the list,
     * swap it with the last available non-fallback driver.
     */
    for (i = 0; fallback[i]; i++) {
        for (drv = drivers; drv != end; drv++) {
            if (strstr(*drv, fallback[i])) {
                x = *drv;
                *drv = *end;
                *end = x;
                end--;
                break;
            }
        }
    }
d724 1
d786 2
d969 6
@


1.23
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a48 1
#ifdef XF86DRI
a50 1
#endif
d124 1
a124 1
                         int scrnum, MessageType from);
d127 1
a127 1
                         Bool active);
a132 1
#ifdef XF86DRI
a133 1
#endif
d362 2
a363 2
    modulearray = xnfalloc((count + 1) * sizeof(char *));
    optarray = xnfalloc((count + 1) * sizeof(void *));
d389 1
a389 1
    int j;
d410 1
a410 1
        while ((slp++)->screen) {
d412 2
d430 1
a430 1
    modulearray = xnfalloc((count + 1) * sizeof(char *));
d436 4
d498 1
a498 1
    modulearray = xnfalloc((count + 1) * sizeof(char *));
d701 1
d761 2
d1053 13
d1106 1
a1106 1
    list = xnfrealloc(list, (count + 1) * sizeof(InputInfoPtr));
d1522 1
a1522 1
    slp = xnfcalloc(1, (count + 1) * sizeof(screenLayoutRec));
d1538 1
a1538 1
                          X_CONFIG)) {
d1588 1
a1588 1
                          0, X_CONFIG)) {
d1646 1
a1646 1
    gdp = xnfalloc((count + 1) * sizeof(GDevRec));
d1651 1
a1651 1
        if (!configDevice(&gdp[count], idp->inactive_device, FALSE))
d1717 1
a1717 1
    if (!configScreen(slp[0].screen, conf_screen, 0, from)) {
d1766 1
a1766 1
    adaptor->ports = xnfalloc((count) * sizeof(confXvPortRec));
d1782 1
a1782 1
             MessageType from)
d1789 1
d1832 1
a1832 1
    if (configDevice(screenp->device, conf_screen->scrn_device, TRUE)) {
d1838 30
d1878 1
a1878 1
    screenp->displays = xnfalloc((count) * sizeof(DispRec));
d1908 1
a1908 1
    screenp->xvadaptors = xnfalloc((count) * sizeof(confXvAdaptorRec));
d2147 1
a2147 1
    displayp->modes = xnfalloc((count + 1) * sizeof(char *));
d2161 1
a2161 1
configDevice(GDevPtr devicep, XF86ConfDevicePtr conf_device, Bool active)
d2169 8
a2176 4
    if (active)
        xf86Msg(X_CONFIG, "|   |-->Device \"%s\"\n",
                conf_device->dev_identifier);
    else
a2215 1
#ifdef XF86DRI
a2235 1
#endif
a2527 1
#ifdef XF86DRI
a2528 1
#endif
@


1.22
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d277 1
a277 1
         * not be loaded 
a572 19
/*
 * xf86ConfigError --
 *      Print a READABLE ErrorMessage!!!  All information that is 
 *      available is printed.
 */
static void
_X_ATTRIBUTE_PRINTF(1, 2)
xf86ConfigError(const char *msg, ...)
{
    va_list ap;

    ErrorF("\nConfig Error:\n");
    va_start(ap, msg);
    VErrorF(msg, ap);
    va_end(ap);
    ErrorF("\n");
    return;
}

d762 1
a762 1
static Bool
a875 1
                xf86Info.log = LogFlush;
a879 1
                xf86Info.log = LogSync;
a960 1
    xf86Info.useDefaultFontPathFrom = X_DEFAULT;
a962 1
        xf86Info.useDefaultFontPathFrom = X_CONFIG;
d973 2
a974 3
        xf86ConfigError
            ("BlankTime value %d outside legal range of 0 - %d minutes", i,
             MAX_TIME_IN_MIN);
d982 2
a983 3
        xf86ConfigError
            ("StandbyTime value %d outside legal range of 0 - %d minutes", i,
             MAX_TIME_IN_MIN);
d989 2
a990 3
        xf86ConfigError
            ("SuspendTime value %d outside legal range of 0 - %d minutes", i,
             MAX_TIME_IN_MIN);
d996 2
a997 3
        xf86ConfigError
            ("OffTime value %d outside legal range of 0 - %d minutes", i,
             MAX_TIME_IN_MIN);
d1012 2
a1013 2
        xf86ConfigError("Pixmap option's value (%d) must be 24 or 32\n", i);
        return FALSE;
a1047 2

    return TRUE;
d1943 1
a1943 1
           because we are reusing the same section 
d2022 2
a2023 2
        xf86ConfigError("Gamma value %.f is out of range (%.2f - %.1f)\n",
                        badgamma, GAMMA_MIN, GAMMA_MAX);
d2082 1
a2082 2
            xf86ConfigError("Invalid visual name: \"%s\"",
                            conf_display->disp_visual);
a2139 1
    devicep->textClockFreq = conf_device->dev_textclockfreq;
d2474 1
a2474 5
    if (!configServerFlags(xf86configptr->conf_flags, xf86ConfigLayout.options)) {
        ErrorF("Problem when converting the config data structures\n");
        return CONFIG_PARSE_ERROR;
    }

@


1.21
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d106 1
a106 1
#define SYS_CONFIGDIRPATH	"/usr/share/X11/%X," "%D/X11/%X"
d174 1
a174 1
    char *tmp_path, *out_pnt, *path_elem, *next, *p1, *dir_elem;
d235 12
d251 2
a252 2
char **
xf86ModulelistFromConfig(pointer **optlist)
d255 1
a255 1
    char **modulearray;
d261 1
a261 1
    pointer *optarray;
d367 1
a367 1
    optarray = xnfalloc((count + 1) * sizeof(pointer));
d389 1
a389 1
char **
d394 1
a394 1
    char **modulearray;
d461 1
a461 1
char **
d465 1
a465 1
    char **modulearray;
d520 1
a520 1
fixup_video_driver_list(char **drivers)
d522 3
a524 3
    static const char *fallback[4] = { "fbdev", "vesa", "wsfb", NULL };
    char **end, **drv;
    char *x;
d547 1
a547 1
static char **
d550 1
a550 1
    char **ret;
d562 1
a562 1
char **
d565 1
a565 1
    static char **driverlist = NULL;
d603 1
a603 1
    temp_path = defaultFontPath ? defaultFontPath : "";
d609 2
a610 1
            if (asprintf(&defaultFontPath, "%s%s%s", fileconf->file_fontpath,
d612 1
a612 1
                defaultFontPath = NULL;
d615 1
d622 1
a622 1
    temp_path = defaultFontPath ? defaultFontPath : "";
d625 1
a625 1
    temp_path = must_copy ? xnfstrdup(defaultFontPath) : defaultFontPath;
d631 1
a631 1
    temp_path = defaultFontPath;
d639 1
a639 1
    start = defaultFontPath;
d791 1
a791 7

    /* Default options. */
    set.rules = XKB_DFLT_RULES;
    set.model = "pc105";
    set.layout = "us";
    set.variant = NULL;
    set.options = NULL;
d971 2
a972 1
        set.rules = "evdev";
d974 4
d979 1
d1594 3
d1598 1
a1598 1
        if (!configScreen(slp[0].screen, xf86configptr->conf_screen_lst,
d1694 1
a1694 1
                    XF86ConfigPtr xf86configptr)
d1739 1
a1739 1
    if (xf86layoutAddInputDevices(xf86configptr, &layout) > 0) {
d1838 1
a1838 1
        conf_screen->scrn_device = xf86configptr->conf_device_lst;
d2368 1
a2368 1
    char *scanptr;
d2371 1
d2447 3
a2450 1
    if (xf86configptr->conf_layout_lst == NULL || xf86ScreenName != NULL) {
d2455 1
d2457 1
a2457 1
                                 xf86configptr->conf_screen_lst,
d2467 1
a2467 1
            pointer optlist = xf86configptr->conf_flags->flg_option_lst;
d2472 1
a2472 3
            if (!configLayout
                (&xf86ConfigLayout, xf86configptr->conf_layout_lst,
                 dfltlayout)) {
d2478 1
a2478 2
            if (!configLayout(&xf86ConfigLayout, xf86configptr->conf_layout_lst,
                              NULL)) {
@


1.20
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d55 1
d510 2
a511 3
    static const char *fallback[4] = { "vesa", "fbdev", "wsfb", NULL };
    static const char *blacklist[] = { "radeonhd", "radeonold", NULL };
    char **end, **drv, **d;
a529 10
            }
        }
    }
    /* Remove blacklisted drivers */
    for (i = 0; blacklist[i]; i++) {
        for (drv = drivers; drv != end; drv++) {
            if (strcmp(*drv, blacklist[i]) == 0) {
                end--;
                for (d = drv; d != end; d++)
                    *d = *(d+1);
@


1.19
log
@Un-blacklist radeon, blacklist radeonold. So X -configure will now
select the radeon driver.
@
text
@a111 4
    {.name = "extmod",.toLoad = TRUE,.load_opt = NULL},
#ifdef DBE
    {.name = "dbe",.toLoad = TRUE,.load_opt = NULL},
#endif
d115 4
a118 8
#ifdef XRECORD
    {.name = "record",.toLoad = TRUE,.load_opt = NULL},
#endif
#ifdef XF86DRI
    {.name = "dri",.toLoad = TRUE,.load_opt = NULL},
#endif
#ifdef DRI2
    {.name = "dri2",.toLoad = TRUE,.load_opt = NULL},
d712 2
a713 1
    FLAG_USE_SIGIO
d771 2
d865 10
@


1.18
log
@Update to xserver 1.12.3.
@
text
@d518 1
a518 1
    static const char *blacklist[] = { "radeonhd", "radeon", NULL };
@


1.17
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d2337 1
@


1.16
log
@Introduce a black list of drivers for Xorg -configure, and blacklist
all radeon driver variants, except radeonold.
This fixes the conflicting symbols warnings seen by Xorg -configure
and forces it to use radeonold in the generated xorg.conf file.

Xorg -configure is still broken in many ways, and should be
avoided.
@
text
@d75 2
a76 2
#ifndef ROOT_CONFIGPATH
#define ROOT_CONFIGPATH	"%A," "%R," \
d86 2
a87 2
#ifndef USER_CONFIGPATH
#define USER_CONFIGPATH	"/etc/X11/%S," "%P/etc/X11/%S," \
d95 2
a96 2
#ifndef ROOT_CONFIGDIRPATH
#define ROOT_CONFIGDIRPATH	"%A," "%R," \
d100 3
a102 3
#ifndef USER_CONFIGDIRPATH
#define USER_CONFIGDIRPATH	"/etc/X11/%R," "%C/X11/%R," \
				"/etc/X11/%X," "%C/X11/%X"
d112 1
a112 1
    {.name = "extmod",   .toLoad = TRUE,    .load_opt=NULL},
d114 1
a114 1
    {.name = "dbe",      .toLoad = TRUE,    .load_opt=NULL},
d117 1
a117 1
    {.name = "glx",      .toLoad = TRUE,    .load_opt=NULL},
d120 1
a120 1
    {.name = "record",   .toLoad = TRUE,    .load_opt=NULL},
d123 1
a123 1
    {.name = "dri",      .toLoad = TRUE,    .load_opt=NULL},
d126 1
a126 1
    {.name = "dri2",     .toLoad = TRUE,    .load_opt=NULL},
d128 1
a128 1
    {.name = NULL,       .toLoad = FALSE,   .load_opt=NULL}
a130 1

d133 1
a133 1
			 int scrnum, MessageType from);
d136 1
a136 1
			 Bool active);
d138 1
a138 1
			MessageType from);
d141 1
d157 1
a157 1
  char *p1;
d159 7
a165 7
  p1 = *pnt;
  *pnt = index(*pnt, ',');
  if (*pnt != NULL) {
    **pnt = '\0';
    *pnt += 1;
  }
  return p1;
d181 57
a237 47
  char *tmp_path, *out_pnt, *path_elem, *next, *p1, *dir_elem;
  struct stat stat_buf;
  int flag;
  int dirlen;

  tmp_path = calloc(1,strlen(path)+1);
  out_pnt = tmp_path;
  path_elem = NULL;
  next = path;
  while (next != NULL) {
    path_elem = xf86GetPathElem(&next);
    if (*path_elem == '/') {
      dir_elem = xnfcalloc(1, strlen(path_elem) + 1);
      if ((p1 = strchr(path_elem, ':')) != 0)
	dirlen = p1 - path_elem;
      else
	dirlen = strlen(path_elem);
      strncpy(dir_elem, path_elem, dirlen);
      dir_elem[dirlen] = '\0';
      flag = stat(dir_elem, &stat_buf);
      if (flag == 0)
	if (!S_ISDIR(stat_buf.st_mode))
	  flag = -1;
      if (flag != 0) {
        xf86Msg(X_WARNING, "The directory \"%s\" does not exist.\n", dir_elem);
	xf86ErrorF("\tEntry deleted from font path.\n");
	free(dir_elem);
	continue;
      }
      else {
	XNFasprintf(&p1, "%s%s", dir_elem, DIR_FILE);
	flag = stat(p1, &stat_buf);
	if (flag == 0)
	  if (!S_ISREG(stat_buf.st_mode))
	    flag = -1;
	free(p1);
	if (flag != 0) {
	  xf86Msg(X_WARNING,
		  "`fonts.dir' not found (or not valid) in \"%s\".\n", 
		  dir_elem);
	  xf86ErrorF("\tEntry deleted from font path.\n");
	  xf86ErrorF("\t(Run 'mkfontdir' on \"%s\").\n", dir_elem);
	  free(dir_elem);
	  continue;
	}
      }
      free(dir_elem);
d239 1
a239 11

    /*
     * Either an OK directory, or a font server name.  So add it to
     * the path.
     */
    if (out_pnt != tmp_path)
      *out_pnt++ = ',';
    strcat(out_pnt, path_elem);
    out_pnt += strlen(path_elem);
  }
  return tmp_path;
a241 1

d251 5
a255 3
    char *ignore[] = { "GLcore", "speedo", "bitmap", "drm",
		       "freetype", "type1",
		       NULL };
d259 1
a259 1
    
d269 1
a269 1
    
d276 4
a279 2
            xf86Msg(X_WARNING, "\"%s\" will not be loaded unless you've specified it to be loaded elsewhere.\n", modp->load_name);
	        modp = (XF86LoadPtr) modp->list.next;
d287 1
a287 1
         for (i=0 ; ModuleDefaults[i].name != NULL ; i++) {
d289 3
a291 1
                xf86Msg(X_WARNING, "\"%s\" is not to be loaded by default. Skipping.\n", ModuleDefaults[i].name);
d298 3
a300 1
                    xf86Msg(X_INFO, "\"%s\" will be loaded. This was enabled by default and also specified in the config file.\n", ModuleDefaults[i].name);
d304 1
a304 1
	        modp = (XF86LoadPtr) modp->list.next;
d310 3
a312 1
                        xf86Msg(X_INFO, "\"%s\" will be loaded even though the default is to disable it.\n", ModuleDefaults[i].name);
d316 1
a316 1
	                modp = (XF86LoadPtr) modp->list.next;
d320 37
a356 29
		XF86LoadPtr ptr = (XF86LoadPtr)xf86configptr->conf_modules;
                xf86addNewLoadDirective(ptr, ModuleDefaults[i].name, XF86_LOAD_MODULE, ModuleDefaults[i].load_opt);
                xf86Msg(X_INFO, "\"%s\" will be loaded by default.\n", ModuleDefaults[i].name);
            }
         }
    } else {
	xf86configptr->conf_modules = xnfcalloc(1, sizeof(XF86ConfModuleRec));
	for (i=0 ; ModuleDefaults[i].name != NULL ; i++) {
	    if (ModuleDefaults[i].toLoad == TRUE) {
		XF86LoadPtr ptr = (XF86LoadPtr)xf86configptr->conf_modules;
		xf86addNewLoadDirective(ptr, ModuleDefaults[i].name, XF86_LOAD_MODULE, ModuleDefaults[i].load_opt);
	    }
	}
    }

	    /*
	     * Walk the list of modules in the "Module" section to determine how
	     * many we have.
	    */
	    modp = xf86configptr->conf_modules->mod_load_lst;
	    while (modp) {
                for (i = 0; ignore[i]; i++) {
                    if (strcmp(modp->load_name, ignore[i]) == 0)
                        modp->ignore = 1;
                }
                if (!modp->ignore)
	            count++;
	        modp = (XF86LoadPtr) modp->list.next;
	    }
d361 1
a361 1
    modulearray = xnfalloc((count + 1) * sizeof(char*));
d365 2
a366 2
	    modp = xf86configptr->conf_modules->mod_load_lst;
	    while (modp) {
d368 3
a370 3
	            modulearray[count] = modp->load_name;
	            optarray[count] = modp->load_opt;
	            count++;
d372 2
a373 2
	        modp = (XF86LoadPtr) modp->list.next;
	    }
d378 1
a378 1
	    *optlist = optarray;
d380 1
a380 1
	    free(optarray);
a383 1

d391 1
a391 1
    
d401 1
a401 1
    
d410 1
a410 1
	    count++;
d419 1
a419 1
	count++;
d422 1
a422 1
	return NULL;
d427 1
a427 1
    modulearray = xnfalloc((count + 1) * sizeof(char*));
d431 3
a433 3
	modulearray[count] = slp->screen->device->driver;
	count++;
	slp++;
d438 2
a439 2
    while (xf86ConfigLayout.inactives[j].identifier) 
	modulearray[count++] = xf86ConfigLayout.inactives[j++].driver;
d445 1
a445 1
	int i;
d447 5
a451 5
	for (i = 0; i < count; i++)
	    if (xf86NameCmp(modulearray[i], modulearray[count]) == 0) {
		modulearray[count] = "";
		break;
	    }
d472 1
a472 1
    
d480 2
a481 2
	    count++;
	    idp++;
d486 1
a486 1
	return NULL;
d491 1
a491 1
    modulearray = xnfalloc((count + 1) * sizeof(char*));
d496 2
a497 2
	count++;
	idp++;
d503 1
a503 1
	int i;
d505 5
a509 5
	for (i = 0; i < count; i++)
	    if (xf86NameCmp(modulearray[i], modulearray[count]) == 0) {
		modulearray[count] = "";
		break;
	    }
d524 1
a524 1
    for (end = drivers; *end && **end; end++) ;
a525 1

d533 3
a535 1
                x = *drv; *drv = *end; *end = x;
d543 7
a549 7
	for (drv = drivers; drv != end; drv++) {
	    if (strcmp(*drv, blacklist[i]) == 0) {
		end--;
		for (d = drv; d != end; d++)
		    *d = *(d+1);
	    }
	}
d554 1
a554 1
GenerateDriverlist(char * dirname)
d558 1
a558 1
    static const char *patlist[] = {"(.*)_drv\\.so", NULL};
d560 1
a560 1
    
d585 2
a586 1
xf86ConfigError(char *msg, ...)
d601 4
a604 4
    MessageType	 pathFrom;
    Bool	 must_copy;
    int		 size, countDirs;
    char	*temp_path, *log_buf, *start, *end;
d611 1
a611 1
	pathFrom = X_CMDLINE;
d613 10
a622 10
	pathFrom = X_CONFIG;
	if (xf86Info.useDefaultFontPath) {
	    if (asprintf(&defaultFontPath, "%s%s%s", fileconf->file_fontpath,
			 *temp_path ? "," : "", temp_path) == -1)
		defaultFontPath = NULL;
	    else
		must_copy = FALSE;
	}
	else
	    defaultFontPath = fileconf->file_fontpath;
d625 1
a625 1
	pathFrom = X_DEFAULT;
d637 2
a638 2
	countDirs++;
	temp_path++;
d644 7
a650 7
    while((end = index(start, ',')) != NULL) {
      size = (end - start) + 1;
      *(temp_path++) = '\t';
      strncpy(temp_path, start, size);
      temp_path += size;
      *(temp_path++) = '\n';
      start += size;
a656 2
  
  /* ModulePath */
d658 16
a673 14
  if (fileconf) {
    if (xf86ModPathFrom != X_CMDLINE && fileconf->file_modulepath) {
      xf86ModulePath = fileconf->file_modulepath;
      xf86ModPathFrom = X_CONFIG;
    }
  }

  xf86Msg(xf86ModPathFrom, "ModulePath set to \"%s\"\n", xf86ModulePath);

  if (!xf86xkbdirFlag && fileconf && fileconf->file_xkbdir) {
    XkbBaseDirectory = fileconf->file_xkbdir;
    xf86Msg(X_CONFIG, "XKB base directory set to \"%s\"\n",
	    XkbBaseDirectory);
  }
d675 14
a688 14
  /* LogFile */
  /*
   * XXX The problem with this is that the log file is already open.
   * One option might be to copy the exiting contents to the new location.
   * and re-open it.  The down side is that the default location would
   * already have been overwritten.  Another option would be to start with
   * unique temporary location, then copy it once the correct name is known.
   * A problem with this is what happens if the server exits before that
   * happens.
   */
  if (xf86LogFileFrom == X_DEFAULT && fileconf->file_logfile) {
    xf86LogFile = fileconf->file_logfile;
    xf86LogFileFrom = X_CONFIG;
  }
d691 1
a691 1
  return;
a701 1
    FLAG_VTSYSREQ,
a706 1
    FLAG_PC98,
d728 52
a779 56
  { FLAG_NOTRAPSIGNALS,		"NoTrapSignals",		OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_DONTVTSWITCH,		"DontVTSwitch",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_DONTZAP,		"DontZap",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_DONTZOOM,		"DontZoom",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_DISABLEVIDMODE,	"DisableVidModeExtension",	OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_ALLOWNONLOCAL,		"AllowNonLocalXvidtune",	OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_ALLOWMOUSEOPENFAIL,	"AllowMouseOpenFail",		OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_VTSYSREQ,		"VTSysReq",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_SAVER_BLANKTIME,	"BlankTime"		,	OPTV_INTEGER,
	{0}, FALSE },
  { FLAG_DPMS_STANDBYTIME,	"StandbyTime",			OPTV_INTEGER,
	{0}, FALSE },
  { FLAG_DPMS_SUSPENDTIME,	"SuspendTime",			OPTV_INTEGER,
	{0}, FALSE },
  { FLAG_DPMS_OFFTIME,		"OffTime",			OPTV_INTEGER,
	{0}, FALSE },
  { FLAG_PIXMAP,		"Pixmap",			OPTV_INTEGER,
	{0}, FALSE },
  { FLAG_PC98,			"PC98",				OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_NOPM,			"NoPM",				OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_XINERAMA,		"Xinerama",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_LOG,			"Log",				OPTV_STRING,
	{0}, FALSE },
  { FLAG_RENDER_COLORMAP_MODE,	"RenderColormapMode",		OPTV_STRING,
        {0}, FALSE },
  { FLAG_RANDR,			"RandR",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_AIGLX,			"AIGLX",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_IGNORE_ABI,		"IgnoreABI",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_USE_DEFAULT_FONT_PATH,  "UseDefaultFontPath",		OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_AUTO_ADD_DEVICES,       "AutoAddDevices",		OPTV_BOOLEAN,
        {0}, FALSE },
  { FLAG_AUTO_ENABLE_DEVICES,    "AutoEnableDevices",		OPTV_BOOLEAN,
        {0}, FALSE },
  { FLAG_GLX_VISUALS,		"GlxVisuals",			OPTV_STRING,
        {0}, FALSE },
  { FLAG_DRI2,			"DRI2",				OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_USE_SIGIO,		"UseSIGIO",			OPTV_BOOLEAN,
	{0}, FALSE },
  { -1,				NULL,				OPTV_NONE,
	{0}, FALSE },
a781 15
#ifdef SUPPORT_PC98
static Bool
detectPC98(void)
{
    unsigned char buf[2];

    if (xf86ReadBIOS(0xf8000, 0xe80, buf, 2) != 2)
	return FALSE;
    if ((buf[0] == 0x98) && (buf[1] == 0x21))
	return TRUE;
    else
	return FALSE;
}
#endif

d792 1
d806 1
a806 1
	optp = xf86optionListDup(flagsconf->flg_option_lst);
d808 5
a812 5
	tmp = xf86optionListDup(layoutopts);
	if (optp)
	    optp = xf86optionListMerge(optp, tmp);
	else
	    optp = tmp;
d824 1
a824 1
	    xf86Msg(X_CONFIG, "Ignoring ABI Version\n");
d828 18
a845 13
	xf86Info.useSIGIO = xf86ReturnOptValBool(FlagOptions, FLAG_USE_SIGIO, USE_SIGIO_BY_DEFAULT);
	if (xf86IsOptionSet(FlagOptions, FLAG_USE_SIGIO)) {
	    from = X_CONFIG;
	} else {
	    from = X_DEFAULT;
	}
	if (!xf86Info.useSIGIO) {
	    xf86Msg(from, "Disabling SIGIO handlers for input devices\n");
	} else if (from == X_CONFIG) {
	    xf86Msg(from, "Enabling SIGIO handlers for input devices\n");
	}
    } else {
	xf86Info.useSIGIO = FALSE;
d877 1
a877 1
	xf86Info.vidModeEnabled = !value;
d879 1
a879 1
	xf86Info.vidModeAllowNonLocal = value;
d883 1
a883 11
	xf86Info.allowMouseOpenFail = value;

    if (xf86GetOptValBool(FlagOptions, FLAG_VTSYSREQ, &value)) {
#ifdef USE_VT_SYSREQ
	xf86Info.vtSysreq = value;
	xf86Msg(X_CONFIG, "VTSysReq %s\n", value ? "enabled" : "disabled");
#else
	if (value)
	    xf86Msg(X_WARNING, "VTSysReq is not supported on this OS\n");
#endif
    }
d886 2
a887 2
    if (xf86GetOptValBool(FlagOptions, FLAG_NOPM, &value)) 
	xf86Info.pmFlag = !value;
d889 15
a903 13
	if ((s = xf86GetOptValString(FlagOptions, FLAG_LOG))) {
	    if (!xf86NameCmp(s,"flush")) {
		xf86Msg(X_CONFIG, "Flushing logfile enabled\n");
		xf86Info.log = LogFlush;
		LogSetParameter(XLOG_FLUSH, TRUE);
	    } else if (!xf86NameCmp(s,"sync")) {
		xf86Msg(X_CONFIG, "Syncing logfile enabled\n");
		xf86Info.log = LogSync;
		LogSetParameter(XLOG_FLUSH, TRUE);
		LogSetParameter(XLOG_SYNC, TRUE);
	    } else {
		xf86Msg(X_WARNING,"Unknown Log option\n");
	    }
d906 1
a906 1
    
d908 10
a917 10
	if ((s = xf86GetOptValString(FlagOptions, FLAG_RENDER_COLORMAP_MODE))){
	    int policy = PictureParseCmapPolicy (s);
	    if (policy == PictureCmapPolicyInvalid)
		xf86Msg(X_WARNING, "Unknown colormap policy \"%s\"\n", s);
	    else
	    {
		xf86Msg(X_CONFIG, "Render colormap policy set to %s\n", s);
		PictureCmapPolicy = policy;
	    }
	}
d924 2
a925 2
	xf86Info.disableRandR = !value;
	xf86Info.randRFrom = X_CONFIG;
d932 2
a933 2
	xf86Info.aiglx = value;
	xf86Info.aiglxFrom = X_CONFIG;
d940 12
a951 9
	if (!xf86NameCmp(s, "minimal")) {
	    xf86Info.glxVisuals = XF86_GlxVisualsMinimal;
	} else if (!xf86NameCmp(s, "typical")) {
	    xf86Info.glxVisuals = XF86_GlxVisualsTypical;
	} else if (!xf86NameCmp(s, "all")) {
	    xf86Info.glxVisuals = XF86_GlxVisualsAll;
	} else {
	    xf86Msg(X_WARNING,"Unknown GlxVisuals option\n");
	}
d955 2
a956 2
	xf86Info.aiglx = value;
	xf86Info.aiglxFrom = X_CONFIG;
d961 2
a962 1
    xf86Info.forceInputDevices = !(xf86Info.autoAddDevices && xf86Info.autoEnableDevices);
d975 2
a976 2
	xf86Info.useDefaultFontPath = value;
	xf86Info.useDefaultFontPathFrom = X_CONFIG;
d985 1
a985 1
	ScreenSaverTime = defaultScreenSaverTime = i * MILLI_PER_MIN;
d987 3
a989 2
	xf86ConfigError("BlankTime value %d outside legal range of 0 - %d minutes",
			i, MAX_TIME_IN_MIN);
d995 1
a995 1
	DPMSStandbyTime = i * MILLI_PER_MIN;
d997 3
a999 2
	xf86ConfigError("StandbyTime value %d outside legal range of 0 - %d minutes",
			i, MAX_TIME_IN_MIN);
d1003 1
a1003 1
	DPMSSuspendTime = i * MILLI_PER_MIN;
d1005 3
a1007 2
	xf86ConfigError("SuspendTime value %d outside legal range of 0 - %d minutes",
			i, MAX_TIME_IN_MIN);
d1011 1
a1011 1
	DPMSOffTime = i * MILLI_PER_MIN;
d1013 3
a1015 2
	xf86ConfigError("OffTime value %d outside legal range of 0 - %d minutes",
			i, MAX_TIME_IN_MIN);
d1022 2
a1023 2
	pix24 = Pix24Use24;
	break;
d1025 2
a1026 2
	pix24 = Pix24Use32;
	break;
d1028 1
a1028 1
	break;
d1030 2
a1031 2
	xf86ConfigError("Pixmap option's value (%d) must be 24 or 32\n", i);
	return FALSE;
d1034 11
a1044 21
	xf86Info.pixmap24 = xf86Pix24;
	xf86Info.pix24From = X_CMDLINE;
    } else if (pix24 != Pix24DontCare) {
	xf86Info.pixmap24 = pix24;
	xf86Info.pix24From = X_CONFIG;
    } else {
	xf86Info.pixmap24 = Pix24DontCare;
	xf86Info.pix24From = X_DEFAULT;
    }
#ifdef SUPPORT_PC98
    if (xf86GetOptValBool(FlagOptions, FLAG_PC98, &value)) {
	xf86Info.pc98 = value;
	if (value) {
	    xf86Msg(X_CONFIG, "Japanese PC98 architecture\n");
	}
    } else
	if (detectPC98()) {
	    xf86Info.pc98 = TRUE;
	    xf86Msg(X_PROBED, "Japanese PC98 architecture\n");
	}
#endif
d1049 1
a1049 1
      from = X_CMDLINE;
d1051 2
a1052 2
      noPanoramiXExtension = !value;
      from = X_CONFIG;
d1055 1
a1055 1
      xf86Msg(from, "Xinerama: enabled\n");
d1062 2
a1063 2
	xf86Info.dri2 = value;
	xf86Info.dri2From = X_CONFIG;
d1070 2
a1071 1
Bool xf86DRI2Enabled(void)
d1076 39
d1136 3
a1138 3
    InputInfoPtr *devs, /* iterator */
            indp;
    InputInfoRec Pointer = {}, Keyboard = {};
a1140 1
    int count = 0;
d1142 1
a1142 1
    int found = 0;
d1144 2
a1145 1
				   "ws", "void", NULL };
d1154 12
a1165 23
	if (indp->options &&
	    xf86CheckBoolOption(indp->options, "CorePointer", FALSE)) {
	    if (!corePointer) {
		corePointer = indp;
	    } else {
		    xf86ReplaceBoolOption(indp->options, "CorePointer", FALSE);
		xf86Msg(X_WARNING, "Duplicate core pointer devices.  "
			"Removing core pointer attribute from \"%s\"\n",
			indp->name);
	    }
	}
	if (indp->options &&
	    xf86CheckBoolOption(indp->options, "CoreKeyboard", FALSE)) {
	    if (!coreKeyboard) {
		coreKeyboard = indp;
	    } else {
		    xf86ReplaceBoolOption(indp->options, "CoreKeyboard", FALSE);
		xf86Msg(X_WARNING, "Duplicate core keyboard devices.  "
			"Removing core keyboard attribute from \"%s\"\n",
			indp->name);
	    }
	}
	count++;
d1172 17
a1188 26
	confInput = xf86findInput(xf86PointerName,
				  xf86configptr->conf_input_lst);
	if (!confInput) {
	    xf86Msg(X_ERROR, "No InputDevice section called \"%s\"\n",
		    xf86PointerName);
	    return FALSE;
	}
	from = X_CMDLINE;
	/*
	 * If one was already specified in the ServerLayout, it needs to be
	 * removed.
	 */
	if (corePointer) {
	    for (devs = servlayoutp->inputs; devs && *devs; devs++)
		if (*devs == corePointer)
                {
                    free(*devs);
                    *devs = (InputInfoPtr)0x1; /* ensure we dont skip next loop*/
		    break;
                }
	    for (; devs && *devs; devs++)
		devs[0] = devs[1];
	    count--;
	}
	corePointer = NULL;
	foundPointer = TRUE;
d1193 2
a1194 2
	foundPointer = TRUE;
	from = X_CONFIG;
d1199 1
a1199 1
	XF86ConfInputPtr p;
d1201 10
a1210 10
	for (p = xf86configptr->conf_input_lst; p; p = p->list.next) {
	    if (p->inp_option_lst &&
		xf86CheckBoolOption(p->inp_option_lst, "CorePointer", FALSE)) {
		confInput = p;
		foundPointer = TRUE;
		from = X_DEFAULT;
		pointerMsg = "first core pointer device";
		break;
	    }
	}
d1215 14
a1228 13
	const char **driver = mousedrivers;
	confInput = xf86findInput(CONF_IMPLICIT_POINTER,
				  xf86configptr->conf_input_lst);
	while (*driver && !confInput) {
	    confInput = xf86findInputByDriver(*driver,
					      xf86configptr->conf_input_lst);
	    driver++;
	}
	if (confInput) {
	    foundPointer = TRUE;
	    from = X_DEFAULT;
	    pointerMsg = "first mouse device";
	}
d1233 7
a1239 7
	memset(&defPtr, 0, sizeof(defPtr));
	defPtr.inp_identifier = strdup("<default pointer>");
	defPtr.inp_driver = strdup("mouse");
	confInput = &defPtr;
	foundPointer = TRUE;
	from = X_DEFAULT;
	pointerMsg = "default mouse configuration";
d1244 3
a1246 1
	foundPointer = configInput(&Pointer, confInput, from);
d1248 10
a1257 12
	    count++;
	    devs = xnfrealloc(servlayoutp->inputs,
			      (count + 1) * sizeof(InputInfoPtr));
            devs[count - 1] = xnfalloc(sizeof(InputInfoRec));
            Pointer.fd = -1;
	    *devs[count - 1] = Pointer;
	    devs[count - 1]->options =
				xf86addNewOption(devs[count -1]->options,
				    xnfstrdup("CorePointer"), NULL);
	    devs[count] = NULL;
	    servlayoutp->inputs = devs;
	}
d1261 4
a1264 42
	/* This shouldn't happen. */
	xf86Msg(X_ERROR, "Cannot locate a core pointer device.\n");
	return FALSE;
    }

    /*
     * always synthesize a 'mouse' section configured to send core
     * events, unless a 'void' section is found, in which case the user
     * probably wants to run footless.
     *
     * If you're using an evdev keyboard and expect a default mouse
     * section ... deal.
     */
    for (devs = servlayoutp->inputs; devs && *devs; devs++) {
	const char **driver = mousedrivers;
	while(*driver) {
	    if (!strcmp((*devs)->driver, *driver)) {
		found = 1;
		break;
	    }
	    driver++;
	}
    }
    if (!found && xf86Info.forceInputDevices) {
	xf86Msg(X_INFO, "No default mouse found, adding one\n");
	memset(&defPtr, 0, sizeof(defPtr));
	defPtr.inp_identifier = strdup("<default pointer>");
	defPtr.inp_driver = strdup("mouse");
	confInput = &defPtr;
	foundPointer = configInput(&Pointer, confInput, from);
        if (foundPointer) {
	    count++;
	    devs = xnfrealloc(servlayoutp->inputs,
			      (count + 1) * sizeof(InputInfoPtr));
            devs[count - 1] = xnfalloc(sizeof(InputInfoRec));
            Pointer.fd = -1;
	    *devs[count - 1] = Pointer;
	    devs[count - 1]->options =
				xf86addNewOption(NULL, xnfstrdup("AlwaysCore"), NULL);
	    devs[count] = NULL;
	    servlayoutp->inputs = devs;
	}
d1271 17
a1287 26
	confInput = xf86findInput(xf86KeyboardName,
				  xf86configptr->conf_input_lst);
	if (!confInput) {
	    xf86Msg(X_ERROR, "No InputDevice section called \"%s\"\n",
		    xf86KeyboardName);
	    return FALSE;
	}
	from = X_CMDLINE;
	/*
	 * If one was already specified in the ServerLayout, it needs to be
	 * removed.
	 */
	if (coreKeyboard) {
	    for (devs = servlayoutp->inputs; devs && *devs; devs++)
		if (*devs == coreKeyboard)
                {
                    free(*devs);
                    *devs = (InputInfoPtr)0x1; /* ensure we dont skip next loop */
		    break;
                }
	    for (; devs && *devs; devs++)
		devs[0] = devs[1];
	    count--;
	}
	coreKeyboard = NULL;
	foundKeyboard = TRUE;
d1292 2
a1293 2
	foundKeyboard = TRUE;
	from = X_CONFIG;
d1298 1
a1298 1
	XF86ConfInputPtr p;
d1300 10
a1309 10
	for (p = xf86configptr->conf_input_lst; p; p = p->list.next) {
	    if (p->inp_option_lst &&
		xf86CheckBoolOption(p->inp_option_lst, "CoreKeyboard", FALSE)) {
		confInput = p;
		foundKeyboard = TRUE;
		from = X_DEFAULT;
		keyboardMsg = "first core keyboard device";
		break;
	    }
	}
d1314 11
a1324 11
	confInput = xf86findInput(CONF_IMPLICIT_KEYBOARD,
				  xf86configptr->conf_input_lst);
	if (!confInput) {
	    confInput = xf86findInputByDriver("kbd",
					      xf86configptr->conf_input_lst);
	}
	if (confInput) {
	    foundKeyboard = TRUE;
	    from = X_DEFAULT;
	    keyboardMsg = "first keyboard device";
	}
d1329 7
a1335 7
	memset(&defKbd, 0, sizeof(defKbd));
	defKbd.inp_identifier = strdup("<default keyboard>");
	defKbd.inp_driver = strdup("kbd");
	confInput = &defKbd;
	foundKeyboard = TRUE;
	keyboardMsg = "default keyboard configuration";
	from = X_DEFAULT;
d1340 3
a1342 1
	foundKeyboard = configInput(&Keyboard, confInput, from);
d1344 10
a1353 12
	    count++;
	    devs = xnfrealloc(servlayoutp->inputs,
			      (count + 1) * sizeof(InputInfoPtr));
            devs[count - 1] = xnfalloc(sizeof(InputInfoRec));
            Keyboard.fd = -1;
	    *devs[count - 1] = Keyboard;
	    devs[count - 1]->options =
				xf86addNewOption(devs[count - 1]->options,
				    xnfstrdup("CoreKeyboard"), NULL);
	    devs[count] = NULL;
	    servlayoutp->inputs = devs;
	}
d1357 4
a1360 3
	/* This shouldn't happen. */
	xf86Msg(X_ERROR, "Cannot locate a core keyboard device.\n");
	return FALSE;
d1364 7
a1370 7
	if (implicitLayout)
	    xf86Msg(X_DEFAULT, "No Layout section. Using the %s.\n",
	            pointerMsg);
	else
	    xf86Msg(X_DEFAULT, "The core pointer device wasn't specified "
	            "explicitly in the layout.\n"
	            "\tUsing the %s.\n", pointerMsg);
d1374 7
a1380 7
	if (implicitLayout)
	    xf86Msg(X_DEFAULT, "No Layout section. Using the %s.\n",
	            keyboardMsg);
	else
	    xf86Msg(X_DEFAULT, "The core keyboard device wasn't specified "
	            "explicitly in the layout.\n"
	            "\tUsing the %s.\n", keyboardMsg);
d1385 2
a1386 1
	const char *config_backend;
d1388 1
a1388 1
	config_backend = "HAL";
d1390 1
a1390 1
	config_backend = "udev";
d1392 1
a1392 1
	config_backend = "wscons";
d1394 4
a1397 4
	xf86Msg(X_INFO, "The server relies on %s to provide the list of "
	                "input devices.\n\tIf no devices become available, "
	                "reconfigure %s or disable AutoAddDevices.\n",
			config_backend, config_backend);
d1399 4
a1402 4
	xf86Msg(X_WARNING, "Hotplugging requested but the server was "
			   "compiled without a config backend. "
			   "No input devices were configured, the server "
			   "will start without any input devices.\n");
d1415 6
a1420 6
  { LAYOUT_ISOLATEDEVICE,      "IsolateDevice",        OPTV_STRING,
       {0}, FALSE },
  { LAYOUT_SINGLECARD,         "SingleCard",           OPTV_BOOLEAN,
       {0}, FALSE },
  { -1,                                NULL,                   OPTV_NONE,
       {0}, FALSE },
d1435 2
a1436 2
	count++;
	irp = (XF86ConfInputrefPtr)irp->list.next;
d1439 1
a1439 1
	    count, layout->lay_identifier);
d1445 12
a1456 12
	indp[count] = xf86AllocateInput();
	if (!configInput(indp[count], irp->iref_inputdev, X_CONFIG)) {
	    do {
		free(indp[count]);
	    } while(count--);
	    free(indp);
	    return FALSE;
	}
	indp[count]->options = xf86OptionListMerge(indp[count]->options,
						   irp->iref_option_lst);
	count++;
	irp = (XF86ConfInputrefPtr)irp->list.next;
a1462 1

d1469 1
a1469 1
	     char *default_layout)
d1482 1
a1482 1
	return FALSE;
d1492 1
a1492 1
	from = X_CMDLINE;
d1494 2
a1495 2
	xf86LayoutName = default_layout;
	from = X_CONFIG;
d1498 6
a1503 6
	if ((l = xf86findLayout(xf86LayoutName, conf_layout)) == NULL) {
	    xf86Msg(X_ERROR, "No ServerLayout section called \"%s\"\n",
		    xf86LayoutName);
	    return FALSE;
	}
	conf_layout = l;
d1516 1
a1516 1
        adjp = (XF86ConfAdjacencyPtr)adjp->list.next;
d1521 1
a1521 1
    if (!count) /* alloc enough storage even if no screen is specified */
d1535 42
a1576 42
	if (adjp->adj_scrnum < 0)
	    scrnum = count;
	else
	    scrnum = adjp->adj_scrnum;
	if (!configScreen(slp[count].screen, adjp->adj_screen, scrnum,
			  X_CONFIG)) {
	    do {
		free(slp[count].screen);
	    } while(count--);
	    free(slp);
	    return FALSE;
	}
	slp[count].x = adjp->adj_x;
	slp[count].y = adjp->adj_y;
	slp[count].refname = adjp->adj_refscreen;
	switch (adjp->adj_where) {
	case CONF_ADJ_OBSOLETE:
	    slp[count].where = PosObsolete;
	    slp[count].topname = adjp->adj_top_str;
	    slp[count].bottomname = adjp->adj_bottom_str;
	    slp[count].leftname = adjp->adj_left_str;
	    slp[count].rightname = adjp->adj_right_str;
	    break;
	case CONF_ADJ_ABSOLUTE:
	    slp[count].where = PosAbsolute;
	    break;
	case CONF_ADJ_RIGHTOF:
	    slp[count].where = PosRightOf;
	    break;
	case CONF_ADJ_LEFTOF:
	    slp[count].where = PosLeftOf;
	    break;
	case CONF_ADJ_ABOVE:
	    slp[count].where = PosAbove;
	    break;
	case CONF_ADJ_BELOW:
	    slp[count].where = PosBelow;
	    break;
	case CONF_ADJ_RELATIVE:
	    slp[count].where = PosRelative;
	    break;
	}
d1578 1
a1578 1
        adjp = (XF86ConfAdjacencyPtr)adjp->list.next;
d1584 1
a1584 2
    if (!count)
    {
d1586 1
a1586 1
	if (!configScreen(slp[0].screen, xf86configptr->conf_screen_lst,
d1588 4
a1591 4
	    free(slp[0].screen);
	    free(slp);
	    return FALSE;
	}
d1598 30
a1627 31
	for (j = 0; j < count; j++) {
	    if (slp[i].refname &&
		strcmp(slp[i].refname, slp[j].screen->id) == 0) {
		slp[i].refscreen = slp[j].screen;
	    }
	    if (slp[i].topname &&
		strcmp(slp[i].topname, slp[j].screen->id) == 0) {
		slp[i].top = slp[j].screen;
	    }
	    if (slp[i].bottomname &&
		strcmp(slp[i].bottomname, slp[j].screen->id) == 0) {
		slp[i].bottom = slp[j].screen;
	    }
	    if (slp[i].leftname &&
		strcmp(slp[i].leftname, slp[j].screen->id) == 0) {
		slp[i].left = slp[j].screen;
	    }
	    if (slp[i].rightname &&
		strcmp(slp[i].rightname, slp[j].screen->id) == 0) {
		slp[i].right = slp[j].screen;
	    }
	}
	if (slp[i].where != PosObsolete
	    && slp[i].where != PosAbsolute
	    && !slp[i].refscreen) {
	    xf86Msg(X_ERROR,"Screen %s doesn't exist: deleting placement\n",
		     slp[i].refname);
	    slp[i].where = PosAbsolute;
	    slp[i].x = 0;
	    slp[i].y = 0;
	}
d1631 1
a1631 1
	saved_count = 1;
d1633 1
a1633 1
	saved_count = count;
d1641 1
a1641 1
        idp = (XF86ConfInactivePtr)idp->list.next;
d1650 2
a1651 2
	if (!configDevice(&gdp[count], idp->inactive_device, FALSE))
	    goto bail;
d1653 1
a1653 1
        idp = (XF86ConfInactivePtr)idp->list.next;
d1657 1
a1657 1
	goto bail;
d1667 1
a1667 1
bail:
d1669 2
a1670 2
	free(slp[saved_count].screen);
    } while(saved_count--);
d1691 1
a1691 1
	return FALSE;
d1702 7
a1708 7
	if ((s = xf86findScreen(xf86ScreenName, conf_screen)) == NULL) {
	    xf86Msg(X_ERROR, "No Screen section called \"%s\"\n",
		    xf86ScreenName);
	    return FALSE;
	}
	conf_screen = s;
	from = X_CMDLINE;
d1717 2
a1718 2
	free(slp);
	return FALSE;
d1728 9
a1736 8
	if (!configInputDevices(&layout, servlayoutp))
	    return FALSE;
	from = X_DEFAULT;
    } else {
	/* Set up an empty input device list, then look for some core devices. */
	indp = xnfalloc(sizeof(InputInfoPtr));
	*indp = NULL;
	servlayoutp->inputs = indp;
d1749 1
a1749 1
	    conf_adaptor->va_identifier);
d1753 2
a1754 2
	xf86Msg(X_CONFIG, "|   | Unsupported device type, skipping entry\n");
	return FALSE;
d1761 1
a1761 1
    while(conf_port) {
d1763 1
a1763 1
        conf_port = (XF86ConfVideoPortPtr)conf_port->list.next;
d1769 3
a1771 3
    while(conf_port) {
	adaptor->ports[count].identifier = conf_port->vp_identifier;
	adaptor->ports[count].options = conf_port->vp_option_lst;
d1773 1
a1773 1
        conf_port = (XF86ConfVideoPortPtr)conf_port->list.next;
d1781 1
a1781 1
	     MessageType from)
d1797 1
a1797 1
	    scrnum);
d1801 2
a1802 2
    screenp->id         = conf_screen->scrn_identifier;
    screenp->screennum  = scrnum;
d1806 1
a1806 1
    screenp->monitor    = xnfcalloc(1, sizeof(MonRec));
d1809 1
a1809 1
	XF86ConfMonitorRec defMon;
d1811 9
a1819 8
	memset(&defMon, 0, sizeof(defMon));
	defMon.mon_identifier = "<default monitor>";
	if (!configMonitor(screenp->monitor, &defMon))
	    return FALSE;
	defaultMonitor = TRUE;
    } else {
	if (!configMonitor(screenp->monitor,conf_screen->scrn_monitor))
	    return FALSE;
d1824 1
a1824 1
    screenp->device     = xnfcalloc(1, sizeof(GDevRec));
d1827 2
a1828 2
	xf86Msg(X_DEFAULT, "No device specified for screen \"%s\".\n"
		"\tUsing the first device section listed.\n", screenp->id);
d1830 1
a1830 1
    if (configDevice(screenp->device,conf_screen->scrn_device, TRUE)) {
d1832 2
a1833 1
    } else {
d1837 1
a1837 1
    
d1842 1
a1842 1
    while(dispptr) {
d1844 1
a1844 1
        dispptr = (XF86ConfDisplayPtr)dispptr->list.next;
d1846 1
a1846 1
    screenp->displays   = xnfalloc((count) * sizeof(DispRec));
d1848 1
a1848 1
    
d1851 6
a1856 6
	for (count = 0, dispptr = conf_screen->scrn_display_lst;
	     dispptr;
	     dispptr = (XF86ConfDisplayPtr)dispptr->list.next, count++) {
	    screenp->displays[count].virtualX = conf_screen->scrn_virtualX;
	    screenp->displays[count].virtualY = conf_screen->scrn_virtualY;
	}
d1862 2
a1863 2
    while(dispptr) {
        configDisplay(&(screenp->displays[count]),dispptr);
d1865 1
a1865 1
        dispptr = (XF86ConfDisplayPtr)dispptr->list.next;
d1872 1
a1872 1
    while(conf_adaptor) {
d1874 1
a1874 1
        conf_adaptor = (XF86ConfAdaptorLinkPtr)conf_adaptor->list.next;
d1879 1
a1879 1
    while(conf_adaptor) {
d1881 3
a1883 3
			    conf_adaptor->al_adaptor))
    	    screenp->numxvadaptors++;
        conf_adaptor = (XF86ConfAdaptorLinkPtr)conf_adaptor->list.next;
d1887 2
a1888 2
	xf86Msg(X_DEFAULT, "No monitor specified for screen \"%s\".\n"
		"\tUsing a default monitor configuration.\n", screenp->id);
d1899 6
a1904 6
  { MON_REDUCEDBLANKING,      "ReducedBlanking",        OPTV_BOOLEAN,
       {0}, FALSE },
  { MON_MAX_PIX_CLOCK,	      "MaxPixClock",		OPTV_FREQ,
       {0}, FALSE },
  { -1,                                NULL,                   OPTV_NONE,
       {0}, FALSE },
d1911 1
a1911 1
    DisplayModePtr mode,last = NULL;
d1915 1
a1915 1
    Gamma zeros = {0.0, 0.0, 0.0};
d1918 2
a1919 3
    
    xf86Msg(X_CONFIG, "|   |-->Monitor \"%s\"\n",
	    conf_monitor->mon_identifier);
d1934 3
a1936 4
     */    
    for( count = 0 ;
	 count < conf_monitor->mon_n_hsync && count < MAX_HSYNC;
	 count++) {
d1941 3
a1943 3
    for( count = 0 ;
	 count < conf_monitor->mon_n_vrefresh && count < MAX_VREFRESH;
	 count++) {
d1952 17
a1968 21
    while(modeslnk)
    {
        modes = xf86findModes (modeslnk->ml_modes_str, 
			       xf86configptr->conf_modes_lst);
	modeslnk->ml_modes = modes;
	
	    
	/* now add the modes found in the modes
	   section to the list of modes for this
	   monitor unless it has been added before
	   because we are reusing the same section 
	   for another screen */
	if (xf86itemNotSublist(
			       (GenericListPtr)conf_monitor->mon_modeline_lst,
			       (GenericListPtr)modes->mon_modeline_lst)) {
	    conf_monitor->mon_modeline_lst = (XF86ConfModeLinePtr)
	        xf86addListItem(
				(GenericListPtr)conf_monitor->mon_modeline_lst,
				(GenericListPtr)modes->mon_modeline_lst);
	}
	modeslnk = modeslnk->list.next;
d1977 1
a1977 1
    while( cmodep ) {
d1979 3
a1981 3
	mode->type       = 0;
        mode->Clock      = cmodep->ml_clock;
        mode->HDisplay   = cmodep->ml_hdisplay;
d1983 3
a1985 3
        mode->HSyncEnd   = cmodep->ml_hsyncend;
        mode->HTotal     = cmodep->ml_htotal;
        mode->VDisplay   = cmodep->ml_vdisplay;
d1987 7
a1993 7
        mode->VSyncEnd   = cmodep->ml_vsyncend;
        mode->VTotal     = cmodep->ml_vtotal;
        mode->Flags      = cmodep->ml_flags;
        mode->HSkew      = cmodep->ml_hskew;
        mode->VScan      = cmodep->ml_vscan;
        mode->name       = xnfstrdup(cmodep->ml_identifier);
        if( last ) {
d2005 1
a2005 1
        cmodep = (XF86ConfModeLinePtr)cmodep->list.next;
d2007 2
a2008 2
    if(last){
      last->next = NULL;
d2013 2
a2014 2
    if (! addDefaultModes(monitorp) )
	return FALSE;
d2017 1
a2017 1
	monitorp->gamma.red = conf_monitor->mon_gamma_red;
d2019 1
a2019 1
	monitorp->gamma.green = conf_monitor->mon_gamma_green;
d2021 2
a2022 2
	monitorp->gamma.blue = conf_monitor->mon_gamma_blue;
    
d2025 12
a2036 11
	(monitorp->gamma.red < GAMMA_MIN ||
	 monitorp->gamma.red > GAMMA_MAX)) {
	badgamma = monitorp->gamma.red;
    } else if (monitorp->gamma.green > GAMMA_ZERO &&
	(monitorp->gamma.green < GAMMA_MIN ||
	 monitorp->gamma.green > GAMMA_MAX)) {
	badgamma = monitorp->gamma.green;
    } else if (monitorp->gamma.blue > GAMMA_ZERO &&
	(monitorp->gamma.blue < GAMMA_MIN ||
	 monitorp->gamma.blue > GAMMA_MAX)) {
	badgamma = monitorp->gamma.blue;
d2039 3
a2041 3
	xf86ConfigError("Gamma value %.f is out of range (%.2f - %.1f)\n",
			badgamma, GAMMA_MIN, GAMMA_MAX);
	    return FALSE;
d2048 2
a2049 2
			  &maxPixClock) == TRUE) {
	monitorp->maxPixClock = (int) maxPixClock;
d2051 1
a2051 1
	
d2061 1
a2061 1
	return -1;
d2064 2
a2065 2
	if (!xf86nameCompare(visname, xf86VisualNames[i]))
	    break;
d2069 1
a2069 1
	return i;
a2073 1

d2079 11
a2089 11
    
    displayp->frameX0           = conf_display->disp_frameX0;
    displayp->frameY0           = conf_display->disp_frameY0;
    displayp->virtualX          = conf_display->disp_virtualX;
    displayp->virtualY          = conf_display->disp_virtualY;
    displayp->depth             = conf_display->disp_depth;
    displayp->fbbpp             = conf_display->disp_bpp;
    displayp->weight.red        = conf_display->disp_weight.red;
    displayp->weight.green      = conf_display->disp_weight.green;
    displayp->weight.blue       = conf_display->disp_weight.blue;
    displayp->blackColour.red   = conf_display->disp_black.red;
d2091 2
a2092 2
    displayp->blackColour.blue  = conf_display->disp_black.blue;
    displayp->whiteColour.red   = conf_display->disp_white.red;
d2094 2
a2095 2
    displayp->whiteColour.blue  = conf_display->disp_white.blue;
    displayp->options           = conf_display->disp_option_lst;
d2097 9
a2105 8
	displayp->defaultVisual = lookupVisual(conf_display->disp_visual);
	if (displayp->defaultVisual == -1) {
	    xf86ConfigError("Invalid visual name: \"%s\"",
			    conf_display->disp_visual);
	    return FALSE;
	}
    } else {
	displayp->defaultVisual = -1;
d2107 1
a2107 1
	
d2112 1
a2112 1
    while(modep) {
d2114 1
a2114 1
        modep = (XF86ModePtr)modep->list.next;
d2116 1
a2116 1
    displayp->modes = xnfalloc((count+1) * sizeof(char*));
d2119 1
a2119 1
    while(modep) {
d2122 1
a2122 1
        modep = (XF86ModePtr)modep->list.next;
d2125 1
a2125 1
    
d2139 2
a2140 2
	xf86Msg(X_CONFIG, "|   |-->Device \"%s\"\n",
		conf_device->dev_identifier);
d2142 2
a2143 2
	xf86Msg(X_CONFIG, "|-->Inactive Device \"%s\"\n",
		conf_device->dev_identifier);
d2166 1
a2166 1
	if (i < CONF_MAXDACSPEEDS)
d2168 2
a2169 2
	else
	    devicep->dacSpeeds[i] = 0;
d2173 1
a2173 1
	devicep->numclocks = MAXCLOCKS;
d2175 1
a2175 1
	devicep->clock[i] = conf_device->dev_clock[i];
d2186 1
a2186 1
    struct group       *grp;
d2188 2
a2189 2
    xf86ConfigDRI.group      = -1;
    xf86ConfigDRI.mode       = 0;
d2192 9
a2200 8
	if (drip->dri_group_name) {
	    if ((grp = getgrnam(drip->dri_group_name)))
		xf86ConfigDRI.group = grp->gr_gid;
	} else {
	    if (drip->dri_group >= 0)
		xf86ConfigDRI.group = drip->dri_group;
	}
	xf86ConfigDRI.mode = drip->dri_mode;
d2211 41
a2251 39
	for (o = conf_ext->ext_option_lst; o; o = xf86NextOption(o)) {
	    char *name   = xf86OptionName(o);
	    char *val    = xf86OptionValue(o);
	    char *n;
	    Bool  enable = TRUE;

	    /* Handle "No<ExtensionName>" */
	    n = xf86NormalizeName(name);
	    if (strncmp(n, "no", 2) == 0) {
		name += 2;
		enable = FALSE;
	    }

	    if (!val ||
		xf86NameCmp(val, "enable") == 0 ||
		xf86NameCmp(val, "enabled") == 0 ||
		xf86NameCmp(val, "on") == 0 ||
		xf86NameCmp(val, "1") == 0 ||
		xf86NameCmp(val, "yes") == 0 ||
		xf86NameCmp(val, "true") == 0) {
		/* NOTHING NEEDED -- enabling is handled below */
	    } else if (xf86NameCmp(val, "disable") == 0 ||
                       xf86NameCmp(val, "disabled") == 0 ||
		       xf86NameCmp(val, "off") == 0 ||
		       xf86NameCmp(val, "0") == 0 ||
		       xf86NameCmp(val, "no") == 0 ||
		       xf86NameCmp(val, "false") == 0) {
		enable = !enable;
	    } else {
		xf86Msg(X_WARNING, "Ignoring unrecognized value \"%s\"\n", val);
		free(n);
		continue;
	    }

	    if (EnableDisableExtension(name, enable)) {
		xf86Msg(X_CONFIG, "Extension \"%s\" is %s\n",
			name, enable ? "enabled" : "disabled");
	    } else {
		xf86Msg(X_WARNING, "Ignoring unrecognized extension \"%s\"\n",
d2253 3
a2255 3
	    }
	    free(n);
	}
d2277 5
a2281 6
    while(knownmodes != NULL)
    {
	if(!strcmp(mode->name, knownmodes->name) &&
	   !(knownmodes->type & M_T_DEFAULT))
	    return TRUE;
	knownmodes = knownmodes->next;
d2293 9
a2301 10
    for (i = 0; i < xf86NumDefaultModes; i++)
    {
	mode = xf86DuplicateMode(&xf86DefaultModes[i]);
	if (!modeIsPresent(mode, monitorp))
	{
	    monitorp->Modes = xf86ModesAdd(monitorp->Modes, mode);
	    last = mode;
	} else {
	    free(mode);
	}
d2309 2
a2310 1
checkInput(serverLayoutPtr layout, Bool implicit_layout) {
d2317 1
a2317 2
    if (!xf86Info.forceInputDevices && layout->inputs)
    {
d2321 1
a2321 2
        while(*dev)
        {
d2324 1
a2324 2
                strcmp((*dev)->driver, "vmmouse") == 0)
            {
d2326 2
a2327 2
                if (!warned)
                {
d2341 3
a2343 2
                } while(*current);
            } else
a2354 4
    const char *filename, *dirname, *sysdirname;
    char *filesearch, *dirsearch;
    MessageType filefrom = X_DEFAULT;
    MessageType dirfrom = X_DEFAULT;
d2360 58
a2417 46
	if (getuid() == 0) {
	    filesearch = ROOT_CONFIGPATH;
	    dirsearch = ROOT_CONFIGDIRPATH;
	} else {
	    filesearch = USER_CONFIGPATH;
	    dirsearch = USER_CONFIGDIRPATH;
	}

	if (xf86ConfigFile)
	    filefrom = X_CMDLINE;
	if (xf86ConfigDir)
	    dirfrom = X_CMDLINE;

	xf86initConfigFiles();
	sysdirname = xf86openConfigDirFiles(SYS_CONFIGDIRPATH, NULL,
					    PROJECTROOT);
	dirname = xf86openConfigDirFiles(dirsearch, xf86ConfigDir, PROJECTROOT);
	filename = xf86openConfigFile(filesearch, xf86ConfigFile, PROJECTROOT);
	if (filename) {
	    xf86MsgVerb(filefrom, 0, "Using config file: \"%s\"\n", filename);
	    xf86ConfigFile = xnfstrdup(filename);
	} else {
	    if (xf86ConfigFile)
		xf86Msg(X_ERROR, "Unable to locate/open config file: \"%s\"\n",
			xf86ConfigFile);
	}
	if (dirname) {
	    xf86MsgVerb(dirfrom, 0, "Using config directory: \"%s\"\n",
			dirname);
	    xf86ConfigDir = xnfstrdup(dirname);
	} else {
	    if (xf86ConfigDir)
		xf86Msg(X_ERROR,
			"Unable to locate/open config directory: \"%s\"\n",
			xf86ConfigDir);
	}
	if (sysdirname)
	    xf86MsgVerb(X_DEFAULT, 0, "Using system config directory \"%s\"\n",
			sysdirname);
	if (!filename && !dirname && !sysdirname)
	    return CONFIG_NOFILE;
    }

    if ((xf86configptr = xf86readConfigFile ()) == NULL) {
	xf86Msg(X_ERROR, "Problem parsing the config file\n");
	return CONFIG_PARSE_ERROR;
d2419 1
a2419 1
    xf86closeConfigFile ();
d2435 7
a2441 7
	if (xf86ScreenName == NULL) {
	    xf86Msg(X_DEFAULT,
		    "No Layout section.  Using the first Screen section.\n");
	}
	if (!configImpliedLayout(&xf86ConfigLayout,
				 xf86configptr->conf_screen_lst,
				 xf86configptr)) {
d2443 26
a2468 22
	    return CONFIG_PARSE_ERROR;
	}
	implicit_layout = TRUE;
    } else {
	if (xf86configptr->conf_flags != NULL) {
	  char *dfltlayout = NULL;
 	  pointer optlist = xf86configptr->conf_flags->flg_option_lst;
	
	  if (optlist && xf86FindOption(optlist, "defaultserverlayout"))
	    dfltlayout = xf86SetStrOption(optlist, "defaultserverlayout", NULL);
	  if (!configLayout(&xf86ConfigLayout, xf86configptr->conf_layout_lst,
			  dfltlayout)) {
	    xf86Msg(X_ERROR, "Unable to determine the screen layout\n");
	    return CONFIG_PARSE_ERROR;
	  }
	} else {
	  if (!configLayout(&xf86ConfigLayout, xf86configptr->conf_layout_lst,
			  NULL)) {
	    xf86Msg(X_ERROR, "Unable to determine the screen layout\n");
	    return CONFIG_PARSE_ERROR;
	  }
	}
d2472 1
a2472 1

d2474 6
a2479 5
       ; /* IsolateDevice specified; overrides SingleCard */
    } else {
       xf86GetOptValBool(LayoutOptions, LAYOUT_SINGLECARD, &singlecard);
       if (singlecard)
           scanptr = xf86ConfigLayout.screens->screen->device->busID;
d2482 6
a2487 5
       if (strncmp(scanptr, "PCI:", 4) != 0) {
           xf86Msg(X_WARNING, "Bus types other than PCI not yet isolable.\n"
                              "\tIgnoring IsolateDevice option.\n");
       } else
           xf86PciIsolateDevice(scanptr);
d2489 1
a2489 1

d2491 3
a2493 3
    if (!configServerFlags(xf86configptr->conf_flags,xf86ConfigLayout.options)){
             ErrorF ("Problem when converting the config data structures\n");
             return CONFIG_PARSE_ERROR;
d2510 1
a2510 1
	xf86Info.vidModeEnabled = FALSE;
d2512 1
a2512 1
	xf86Info.vidModeAllowNonLocal = TRUE;
d2516 1
a2516 1
	xf86Info.allowMouseOpenFail = TRUE;
@


1.15
log
@Update to xserver 1.11.2
@
text
@d502 2
a503 1
    char **end, **drv;
d523 10
@


1.14
log
@Introduce new autoconfiguration code for X input drivers, based on X
hotplug framework.This also takes care of the configuration of the
keyboard layout from the wscons layout that was hacked inside the
keyboard driver.

Tested by many, ok oga@@.
@
text
@d63 1
a63 1
#include "Pci.h"
a65 1
extern DeviceAssocRec mouse_assoc;
d80 2
a81 2
			"/etc/X11/%X-%M," "/etc/X11/%X," "/etc/%X," \
			"%P/etc/X11/%X.%H," "%P/etc/X11/%X-%M," \
d83 1
a83 1
			"%P/lib/X11/%X.%H," "%P/lib/X11/%X-%M," \
d89 2
a90 2
			"/etc/X11/%X-%M," "/etc/X11/%X," "/etc/%X," \
			"%P/etc/X11/%X.%H," "%P/etc/X11/%X-%M," \
d92 1
a92 1
			"%P/lib/X11/%X.%H," "%P/lib/X11/%X-%M," \
d138 1
a138 1
static Bool configInput(IDevPtr inputp, XF86ConfInputPtr conf_input,
d211 1
a211 3
	p1 = xnfalloc(strlen(dir_elem)+strlen(DIR_FILE)+1);
	strcpy(p1, dir_elem);
	strcat(p1, DIR_FILE);
d312 1
a312 1
	            ptr = xf86addNewLoadDirective(ptr, ModuleDefaults[i].name, XF86_LOAD_MODULE, ModuleDefaults[i].load_opt);
d321 1
a321 1
		ptr = xf86addNewLoadDirective(ptr, ModuleDefaults[i].name, XF86_LOAD_MODULE, ModuleDefaults[i].load_opt);
d445 2
a446 2
    IDevPtr* idp;
    
a503 1
    char **ati, **atimisc;
a522 18
    /*
     * since the ati wrapper driver is gross and awful, sort ati before
     * atimisc, which makes sure all the ati symbols are visible in xorgcfg.
     */
    for (drv = drivers; drv != end; drv++) {
        if (!strcmp(*drv, "atimisc")) {
            atimisc = drv;
            for (drv = atimisc; drv != end; drv++) {
                if (!strcmp(*drv, "ati")) {
                    ati = drv;
                    x = *ati; *ati = *atimisc; *atimisc = x;
                    return;
                }
            }
            /* if we get here, ati was already ahead of atimisc */
            return;
        }
    }
d530 1
a530 1
    static const char *patlist[] = {"(.*)_drv\\.so", "(.*)_drv\\.o", NULL};
d586 4
a589 4
	    defaultFontPath = Xprintf("%s%s%s",
				      fileconf->file_fontpath,
				      *temp_path ? "," : "", temp_path);
	    if (defaultFontPath != NULL) {
a590 1
	    }
a740 2
  { FLAG_ALLOW_EMPTY_INPUT,     "AllowEmptyInput",              OPTV_BOOLEAN,
        {0}, FALSE },
d951 2
a952 3
    /* AllowEmptyInput is automatically true if we're hotplugging */
    xf86Info.allowEmptyInput = (xf86Info.autoAddDevices && xf86Info.autoEnableDevices);
    xf86GetOptValBool(FlagOptions, FLAG_ALLOW_EMPTY_INPUT, &xf86Info.allowEmptyInput);
d954 2
a955 1
    /* AEI on? Then we're not using kbd, so use the evdev rules set. */
d957 1
a957 1
    if (xf86Info.allowEmptyInput)
d1089 1
a1089 1
    IDevPtr corePointer = NULL, coreKeyboard = NULL;
d1092 1
a1092 1
    IDevPtr *devs, /* iterator */
d1094 1
a1094 1
    IDevRec Pointer, Keyboard;
a1108 1
	pointer opt1 = NULL, opt2 = NULL;
d1110 2
a1111 9
	if (indp->commonOptions &&
	    xf86CheckBoolOption(indp->commonOptions, "CorePointer", FALSE)) {
	    opt1 = indp->commonOptions;
	}
	if (indp->extraOptions &&
	    xf86CheckBoolOption(indp->extraOptions, "CorePointer", FALSE)) {
	    opt2 = indp->extraOptions;
	}
	if (opt1 || opt2) {
d1115 1
a1115 4
		if (opt1)
		    xf86ReplaceBoolOption(opt1, "CorePointer", FALSE);
		if (opt2)
		    xf86ReplaceBoolOption(opt2, "CorePointer", FALSE);
d1118 1
a1118 1
			indp->identifier);
d1121 2
a1122 10
	opt1 = opt2 = NULL;
	if (indp->commonOptions &&
	    xf86CheckBoolOption(indp->commonOptions, "CoreKeyboard", FALSE)) {
	    opt1 = indp->commonOptions;
	}
	if (indp->extraOptions &&
	    xf86CheckBoolOption(indp->extraOptions, "CoreKeyboard", FALSE)) {
	    opt2 = indp->extraOptions;
	}
	if (opt1 || opt2) {
d1126 1
a1126 4
		if (opt1)
		    xf86ReplaceBoolOption(opt1, "CoreKeyboard", FALSE);
		if (opt2)
		    xf86ReplaceBoolOption(opt2, "CoreKeyboard", FALSE);
d1129 1
a1129 1
			indp->identifier);
d1156 1
a1156 1
                    *devs = (IDevPtr)0x1; /* ensure we dont skip next loop*/
d1174 1
a1174 1
    if (!foundPointer && (!xf86Info.allowEmptyInput || implicitLayout)) {
d1190 1
a1190 1
    if (!foundPointer && !xf86Info.allowEmptyInput) {
d1207 1
a1207 1
    if (!foundPointer && !xf86Info.allowEmptyInput) {
d1223 3
a1225 2
			      (count + 1) * sizeof(IDevPtr));
            devs[count - 1] = xnfalloc(sizeof(IDevRec));
d1227 3
a1229 2
	    devs[count - 1]->extraOptions =
				xf86addNewOption(NULL, xnfstrdup("CorePointer"), NULL);
d1235 1
a1235 1
    if (!foundPointer && !xf86Info.allowEmptyInput) {
d1259 1
a1259 1
    if (!found && !xf86Info.allowEmptyInput) {
d1269 3
a1271 2
			      (count + 1) * sizeof(IDevPtr));
            devs[count - 1] = xnfalloc(sizeof(IDevRec));
d1273 1
a1273 1
	    devs[count - 1]->extraOptions =
d1301 1
a1301 1
                    *devs = (IDevPtr)0x1; /* ensure we dont skip next loop */
d1319 1
a1319 1
    if (!foundKeyboard && (!xf86Info.allowEmptyInput || implicitLayout)) {
d1335 1
a1335 1
    if (!foundKeyboard && !xf86Info.allowEmptyInput) {
d1350 1
a1350 1
    if (!foundKeyboard && !xf86Info.allowEmptyInput) {
d1366 3
a1368 2
			      (count + 1) * sizeof(IDevPtr));
            devs[count - 1] = xnfalloc(sizeof(IDevRec));
d1370 3
a1372 2
	    devs[count - 1]->extraOptions =
				xf86addNewOption(NULL, xnfstrdup("CoreKeyboard"), NULL);
d1378 1
a1378 1
    if (!foundKeyboard && !xf86Info.allowEmptyInput) {
d1404 1
a1404 1
    if (xf86Info.allowEmptyInput && !(foundPointer && foundKeyboard)) {
d1419 4
a1422 2
	xf86Msg(X_INFO, "Hotplugging is disabled and no input devices were configured.\n"
			"\tTry disabling AllowEmptyInput.\n");
d1447 1
a1447 1
    IDevPtr *indp;
d1460 1
a1460 1
    indp = xnfcalloc((count + 1), sizeof(IDevPtr));
d1465 1
a1465 1
	indp[count] = xnfalloc(sizeof(IDevRec));
d1467 1
a1467 1
	    while(count--)
d1469 1
d1473 2
a1474 1
	indp[count]->extraOptions = irp->iref_option_lst;
d1494 1
a1494 1
    int count = 0;
d1562 3
d1653 4
d1673 2
a1674 4
	if (!configDevice(&gdp[count], idp->inactive_device, FALSE)) {
	    free(gdp);
	    return FALSE;
	}
d1680 1
a1680 1
	return FALSE;
d1689 8
d1710 1
a1710 1
    IDevPtr *indp;
d1756 1
a1756 1
	indp = xnfalloc(sizeof(IDevPtr));
d1809 1
d1812 2
a1813 1
        conf_screen = xnfcalloc(1, sizeof(XF86ConfScreenRec));
a2210 3
    int                count = 0;
    XF86ConfBuffersPtr bufs;
    int                i;
a2214 2
    xf86ConfigDRI.bufs_count = 0;
    xf86ConfigDRI.bufs       = NULL;
a2224 18
	for (bufs = drip->dri_buffers_lst; bufs; bufs = bufs->list.next)
	    ++count;
	
	xf86ConfigDRI.bufs_count = count;
	xf86ConfigDRI.bufs = xnfalloc(count * sizeof(*xf86ConfigDRI.bufs));
	
	for (i = 0, bufs = drip->dri_buffers_lst;
	     i < count;
	     i++, bufs = bufs->list.next) {
	    
	    xf86ConfigDRI.bufs[i].count = bufs->buf_count;
	    xf86ConfigDRI.bufs[i].size  = bufs->buf_size;
				/* FIXME: Flags not implemented.  These
                                   could be used, for example, to specify a
                                   contiguous block and/or write-combining
                                   cache policy. */
	    xf86ConfigDRI.bufs[i].flags = 0;
	}
d2282 1
a2282 1
configInput(IDevPtr inputp, XF86ConfInputPtr conf_input, MessageType from)
d2285 1
a2285 1
    inputp->identifier = conf_input->inp_identifier;
d2287 1
a2287 2
    inputp->commonOptions = conf_input->inp_option_lst;
    inputp->extraOptions = NULL;
d2336 3
a2338 2
    /* AllowEmptyInput and the "kbd" and "mouse" drivers are mutually
     * exclusive. Trawl the list for mouse/kbd devices and disable them.
d2340 1
a2340 1
    if (xf86Info.allowEmptyInput && layout->inputs)
d2342 1
a2342 1
        IDevPtr *dev = layout->inputs;
d2351 1
a2351 1
                IDevPtr *current;
d2354 1
a2354 1
                    xf86Msg(X_WARNING, "AllowEmptyInput is on, devices using "
d2359 1
a2359 1
                xf86Msg(X_WARNING, "Disabling %s\n", (*dev)->identifier);
a2493 1
       int bus, device, func;
d2497 2
a2498 8
       } else if (sscanf(scanptr, "PCI:%d:%d:%d", &bus, &device, &func) == 3) {
           xf86IsolateDevice.domain = PCI_DOM_FROM_BUS(bus);
           xf86IsolateDevice.bus = PCI_BUS_NO_DOMAIN(bus);
           xf86IsolateDevice.dev = device;
           xf86IsolateDevice.func = func;
           xf86Msg(X_INFO,
                   "Isolating PCI bus \"%d:%d:%d\"\n", bus, device, func);
       }
@


1.13
log
@add a new build switch 'XENOCARA_USE_XKEYBOARD_CONFIG' to enable
the use of xkeyboard-config xkb definitions instead of the old xkbdata.
This will make testing easier. No changes in default builds.
ok shadchin@@
@
text
@d1447 1
a1447 1
#if defined(CONFIG_HAL) || defined(CONFIG_UDEV)
d1451 2
d1454 1
a1454 1
	config_backend = "udev";
@


1.12
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d810 1
a810 1
    set.rules = "xorg";
@


1.11
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a69 1
#ifdef RENDER
a70 1
#endif
d166 1
a166 1
  return(p1);
d187 1
a187 1
  tmp_path = xcalloc(1,strlen(path)+1);
d208 1
a208 1
	xfree(dir_elem);
d219 1
a219 1
	xfree(p1);
d226 1
a226 1
	  xfree(dir_elem);
d230 1
a230 1
      xfree(dir_elem);
d242 1
a242 1
  return(tmp_path);
d366 1
a366 1
	    xfree(optarray);
d625 1
a625 1
    xfree(temp_path);
d650 1
a650 1
    xfree(log_buf);
a925 1
#ifdef RENDER
a937 1
#endif
d1202 1
a1202 1
                    xfree(*devs);
d1255 1
a1255 1
	bzero(&defPtr, sizeof(defPtr));
d1306 1
a1306 1
	bzero(&defPtr, sizeof(defPtr));
d1344 1
a1344 1
                    xfree(*devs);
d1395 1
a1395 1
	bzero(&defKbd, sizeof(defKbd));
d1506 2
a1507 2
		xfree(indp[count]);
	    xfree(indp);
d1598 1
a1598 1
	    xfree(slp);
d1643 2
a1644 2
	    xfree(slp[0].screen);
	    xfree(slp);
d1703 1
a1703 1
	    xfree(gdp);
d1763 1
a1763 1
	xfree(slp);
d1854 1
a1854 1
	bzero(&defMon, sizeof(defMon));
d2309 1
a2309 1
		xfree(n);
d2320 1
a2320 1
	    xfree(n);
d2333 1
d2369 1
a2369 1
	    xfree(mode);
d2406 1
a2406 1
                xfree(*dev);
@


1.10
log
@Update to server 1.6.5.
@
text
@d68 1
a68 5
#ifdef XKB
#undef XKB_IN_SERVER
#define XKB_IN_SERVER
#include <xkbsrv.h>
#endif
a73 7
#if (defined(__i386__)) && \
    (defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || \
     defined(__NetBSD__) || defined(linux) || \
     (defined(SVR4) && !defined(sun)) || defined(__GNU__))
#define SUPPORT_PC98
#endif

d98 12
d116 1
d118 2
d121 1
d125 1
d127 1
d257 3
a259 1
    char *ignore[] = { "GLcore", "speedo", "bitmap", "drm", NULL };
d374 1
a374 1
xf86DriverlistFromConfig()
d446 1
a446 1
xf86InputDriverlistFromConfig()
d625 1
a625 1
    temp_path = must_copy ? XNFstrdup(defaultFontPath) : defaultFontPath;
d627 1
a627 1
    free(temp_path);
a652 8


  if (fileconf && fileconf->file_inputdevs) {
      xf86InputDeviceList = fileconf->file_inputdevs;
      xf86Msg(X_CONFIG, "Input device list set to \"%s\"\n",
	  xf86InputDeviceList);
  }
  
a696 2
    FLAG_DISABLEMODINDEV,
    FLAG_MODINDEVALLOWNONLOCAL,
a698 1
    FLAG_XKBDISABLE,
a708 1
    FLAG_HANDLE_SPECIAL_KEYS,
d718 1
d720 5
a724 1
   
a737 4
  { FLAG_DISABLEMODINDEV,	"DisableModInDev",		OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_MODINDEVALLOWNONLOCAL,	"AllowNonLocalModInDev",	OPTV_BOOLEAN,
	{0}, FALSE },
a741 2
  { FLAG_XKBDISABLE,		"XkbDisable",			OPTV_BOOLEAN,
	{0}, FALSE },
a761 2
  { FLAG_HANDLE_SPECIAL_KEYS,	"HandleSpecialKeys",		OPTV_STRING,
        {0}, FALSE },
d773 1
a773 1
        {0}, TRUE },
d775 1
a775 1
        {0}, TRUE },
d780 2
d786 1
a786 1
#ifdef __i386__
a789 1
#ifdef SUPPORT_PC98
d798 1
a798 2
#else
    return FALSE;
a799 2
}
#endif /* __i386__ */
d810 7
a816 3
#ifdef XKB
    char *rules = "xorg";
#endif
d845 16
a907 10
    if (xf86GetOptValBool(FlagOptions, FLAG_XKBDISABLE, &value)) {
#ifdef XKB
	noXkbExtension = value;
	xf86Msg(X_CONFIG, "Xkb %s\n", value ? "disabled" : "enabled");
#else
	if (!value)
	    xf86Msg(X_WARNING, "Xserver doesn't support XKB\n");
#endif
    }

d942 1
a942 16
    {
	if ((s = xf86GetOptValString(FlagOptions, FLAG_HANDLE_SPECIAL_KEYS))) {
	    if (!xf86NameCmp(s,"always")) {
		xf86Msg(X_CONFIG, "Always handling special keys in DDX\n");
		xf86Info.ddxSpecialKeys = SKAlways;
	    } else if (!xf86NameCmp(s,"whenneeded")) {
		xf86Msg(X_CONFIG, "Special keys handled in DDX only if needed\n");
		xf86Info.ddxSpecialKeys = SKWhenNeeded;
	    } else if (!xf86NameCmp(s,"never")) {
		xf86Msg(X_CONFIG, "Never handling special keys in DDX\n");
		xf86Info.ddxSpecialKeys = SKNever;
	    } else {
		xf86Msg(X_WARNING,"Unknown HandleSpecialKeys option\n");
	    }
        }
    }
a984 1
#ifdef XKB
d987 1
a987 3
        rules = "evdev";
#endif
    XkbSetRulesDflts(rules, "pc105", "us", NULL, NULL);
d989 1
d1013 1
a1013 1
	DPMSStandbyTime = defaultDPMSStandbyTime = i * MILLI_PER_MIN;
d1020 1
a1020 1
	DPMSSuspendTime = defaultDPMSSuspendTime = i * MILLI_PER_MIN;
d1027 1
a1027 1
	DPMSOffTime = defaultDPMSOffTime = i * MILLI_PER_MIN;
d1058 1
a1058 1
#ifdef __i386__
d1109 2
a1110 2
 *  4. The first InputDevices that use the 'mouse' and 'keyboard' or 'kbd'
 *     drivers.
d1129 2
d1240 1
a1240 1
    /* 4. First pointer with 'mouse' as the driver. */
d1242 1
d1245 2
a1246 2
	if (!confInput) {
	    confInput = xf86findInputByDriver("mouse",
d1248 1
d1284 4
a1287 8
    if (!foundPointer) {
	if (!xf86Info.allowEmptyInput) {
	    /* This shouldn't happen. */
	    xf86Msg(X_ERROR, "Cannot locate a core pointer device.\n");
	    return FALSE;
	} else {
	    xf86Msg(X_INFO, "Cannot locate a core pointer device.\n");
	}
d1299 7
a1305 4
	if (!strcmp((*devs)->driver, "void") || !strcmp((*devs)->driver, "mouse") ||
            !strcmp((*devs)->driver, "vmmouse") || !strcmp((*devs)->driver, "evdev") ||
	    !strcmp((*devs)->driver, "ws")) {
	    found = 1; break;
d1424 4
a1427 8
    if (!foundKeyboard) {
	if (!xf86Info.allowEmptyInput) {
		/* This shouldn't happen. */
		xf86Msg(X_ERROR, "Cannot locate a core keyboard device.\n");
		return FALSE;
	} else {
		xf86Msg(X_INFO, "Cannot locate a core keyboard device.\n");
	}
d1451 8
a1458 2
#ifdef CONFIG_HAL
	xf86Msg(X_INFO, "The server relies on HAL to provide the list of "
d1460 2
a1461 1
	                "reconfigure HAL or disable AllowEmptyInput.\n");
d1463 1
a1463 1
	xf86Msg(X_INFO, "HAL is disabled and no input devices were configured.\n"
d1485 39
a1533 1
    XF86ConfInputrefPtr irp;
a1539 1
    IDevPtr* indp;
d1580 1
a1580 2
#ifdef DEBUG
    ErrorF("Found %d screens in the layout section %s",
a1581 1
#endif
a1689 39
#ifdef LAYOUT_DEBUG
    ErrorF("Layout \"%s\"\n", conf_layout->lay_identifier);
    for (i = 0; i < count; i++) {
	ErrorF("Screen: \"%s\" (%d):\n", slp[i].screen->id,
	       slp[i].screen->screennum);
	switch (slp[i].where) {
	case PosObsolete:
	    ErrorF("\tObsolete format: \"%s\" \"%s\" \"%s\" \"%s\"\n",
		   slp[i].top, slp[i].bottom, slp[i].left, slp[i].right);
	    break;
	case PosAbsolute:
	    if (slp[i].x == -1)
		if (slp[i].screen->screennum == 0)
		    ErrorF("\tImplicitly left-most\n");
		else
		    ErrorF("\tImplicitly right of screen %d\n",
			   slp[i].screen->screennum - 1);
	    else
		ErrorF("\t%d %d\n", slp[i].x, slp[i].y);
	    break;
	case PosRightOf:
	    ErrorF("\tRight of \"%s\"\n", slp[i].refscreen->id);
	    break;
	case PosLeftOf:
	    ErrorF("\tLeft of \"%s\"\n", slp[i].refscreen->id);
	    break;
	case PosAbove:
	    ErrorF("\tAbove \"%s\"\n", slp[i].refscreen->id);
	    break;
	case PosBelow:
	    ErrorF("\tBelow \"%s\"\n", slp[i].refscreen->id);
	    break;
	case PosRelative:
	    ErrorF("\t%d %d relative to \"%s\"\n", slp[i].x, slp[i].y,
		   slp[i].refscreen->id);
	    break;
	}
    }
#endif
d1699 1
a1699 2
#ifdef DEBUG
    ErrorF("Found %d inactive devices in the layout section %s",
a1700 1
#endif
d1713 4
a1716 29
    /*
     * Count the number of input devices.
     */
    count = 0;
    irp = conf_layout->lay_input_lst;
    while (irp) {
        count++;
        irp = (XF86ConfInputrefPtr)irp->list.next;
    }
#ifdef DEBUG
    ErrorF("Found %d input devices in the layout section %s",
           count, conf_layout->lay_identifier);
#endif
    indp = xnfcalloc((count + 1), sizeof(IDevPtr));
    indp[count] = NULL;
    irp = conf_layout->lay_input_lst;
    count = 0;
    while (irp) {
        indp[count] = xnfalloc(sizeof(IDevRec));
	if (!configInput(indp[count], irp->iref_inputdev, X_CONFIG)) {
            while(count--) 
                xfree(indp[count]);
            xfree(indp);
            return FALSE;
	}
	indp[count]->extraOptions = irp->iref_option_lst;
        count++;
        irp = (XF86ConfInputrefPtr)irp->list.next;
    }
a1719 1
    servlayoutp->inputs = indp;
d1731 2
a1732 1
configImpliedLayout(serverLayoutPtr servlayoutp, XF86ConfScreenPtr conf_screen)
d1738 1
d1774 13
a1786 4
    /* Set up an empty input device list, then look for some core devices. */
    indp = xnfalloc(sizeof(IDevPtr));
    *indp = NULL;
    servlayoutp->inputs = indp;
a1859 10
	/*
	 * TARGET_REFRESH_RATE may be defined to effectively limit the
	 * default resolution to the largest that has a "good" refresh
	 * rate.
	 */
#ifdef TARGET_REFRESH_RATE
	defMon.mon_option_lst = xf86ReplaceRealOption(defMon.mon_option_lst,
						      "TargetRefresh",
						      TARGET_REFRESH_RATE);
#endif
d2427 4
a2430 3
    const char *filename;
    char *searchpath;
    MessageType from = X_DEFAULT;
d2436 7
a2442 4
	if (getuid() == 0)
	    searchpath = ROOT_CONFIGPATH;
	else
	    searchpath = USER_CONFIGPATH;
d2445 9
a2453 3
	    from = X_CMDLINE;

	filename = xf86openConfigFile(searchpath, xf86ConfigFile, PROJECTROOT);
d2455 1
a2455 1
	    xf86MsgVerb(from, 0, "Using config file: \"%s\"\n", filename);
d2461 15
a2476 1
	}
d2478 1
a2478 1
     
d2504 2
a2505 1
				 xf86configptr->conf_screen_lst)) {
@


1.9
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a614 16
    /* ensure defaultFontPath contains "built-ins" */
    start = strstr(temp_path, "built-ins");
    end = start + strlen("built-ins");
    if (start == NULL ||
	!((start == temp_path || start[-1] == ',') && (!*end || *end == ','))) {
	defaultFontPath = Xprintf("%s%sbuilt-ins",
				  temp_path, *temp_path ? "," : "");
	if (must_copy == TRUE) {
	    if (defaultFontPath != NULL) {
		must_copy = FALSE;
	    }
	} else {
	    /* already made a copy of the font path */
	    xfree(temp_path);
	}
    }
@


1.8
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@a64 1
#ifdef XINPUT
a66 1
#endif
a112 2
static char *fontPath = NULL;

a116 1
    {.name = "freetype", .toLoad = TRUE,    .load_opt=NULL},
d307 1
a307 1
	            XF86ConfModulePtr ptr = xf86configptr->conf_modules;
d316 1
a316 1
		XF86ConfModulePtr ptr = xf86configptr->conf_modules;
d587 23
a609 41
  MessageType pathFrom = X_DEFAULT;
  int countDirs;
  char *temp_path;
  char *log_buf;

  /* FontPath */
  /* Try XF86Config FontPath first */
  if (!xf86fpFlag) {
   if (fileconf) {
    if (fileconf->file_fontpath) {
      char *f = xf86ValidateFontPath(fileconf->file_fontpath);
      pathFrom = X_CONFIG;
      if (*f) {
        if (xf86Info.useDefaultFontPath) {
          char *g;
          xf86Msg(X_DEFAULT, "Including the default font path %s.\n", defaultFontPath);
	  g = xnfalloc(strlen(defaultFontPath) + strlen(f) + 3);
          strcpy(g, f);
          strcat(g, ",");
          defaultFontPath = strcat(g, defaultFontPath);
          xfree(f);
        } else {
          defaultFontPath = f;
        }
      } else {
	xf86Msg(X_WARNING,
	    "FontPath is completely invalid.  Using compiled-in default.\n");
        fontPath = NULL;
        pathFrom = X_DEFAULT;
      }
    } 
   } else {
      xf86Msg(X_DEFAULT,
	    "No FontPath specified.  Using compiled-in default.\n");
      pathFrom = X_DEFAULT;
   }
  } else {
    /* Use fontpath specified with '-fp' */
    if (fontPath)
    {
      fontPath = NULL;
d611 19
a629 20
    pathFrom = X_CMDLINE;
  }
  if (!fileconf) {
      /* xf86ValidateFontPath will write into it's arg, but defaultFontPath
       could be static, so we make a copy. */
    char *f = xnfalloc(strlen(defaultFontPath) + 1);
    f[0] = '\0';
    strcpy (f, defaultFontPath);
    defaultFontPath = xf86ValidateFontPath(f);
    xfree(f);
  } else {
   if (fileconf) {
    if (!fileconf->file_fontpath) {
      /* xf86ValidateFontPath will write into it's arg, but defaultFontPath
       could be static, so we make a copy. */
     char *f = xnfalloc(strlen(defaultFontPath) + 1);
     f[0] = '\0';
     strcpy (f, defaultFontPath);
     defaultFontPath = xf86ValidateFontPath(f);
     xfree(f);
d631 4
a634 2
   }
  }
d636 7
a642 1
  /* If defaultFontPath is still empty, exit here */
d644 1
a644 16
  if (! *defaultFontPath)
    FatalError("No valid FontPath could be found.");

  /* make fontpath more readable in the logfiles */
  countDirs = 1;
  temp_path = defaultFontPath;
  while((temp_path = index(temp_path, ',')) != NULL) {
    countDirs++;
    temp_path++;
  }
  log_buf = xnfalloc(strlen(defaultFontPath) + (2 * countDirs) + 1);
  if(!log_buf) /* fallback to old method */
    xf86Msg(pathFrom, "FontPath set to \"%s\"\n", defaultFontPath);
  else {
    char *start, *end;
    int size;
a659 1
  }
d680 5
a716 6
    FLAG_PCIPROBE1,
    FLAG_PCIPROBE2,
    FLAG_PCIFORCECONFIG1,
    FLAG_PCIFORCECONFIG2,
    FLAG_PCIFORCENONE,
    FLAG_PCIOSCONFIG,
a722 1
    FLAG_ESTIMATE_SIZES_AGGRESSIVELY,
a724 2
    FLAG_ALLOW_DEACTIVATE_GRABS,
    FLAG_ALLOW_CLOSEDOWN_GRABS,
a761 12
  { FLAG_PCIPROBE1,		"PciProbe1"		,	OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_PCIPROBE2,		"PciProbe2",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_PCIFORCECONFIG1,	"PciForceConfig1",		OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_PCIFORCECONFIG2,	"PciForceConfig2",		OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_PCIFORCENONE,		"PciForceNone",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_PCIOSCONFIG,	        "PciOsConfig",   		OPTV_BOOLEAN,
	{0}, FALSE },
a773 2
  { FLAG_ESTIMATE_SIZES_AGGRESSIVELY,"EstimateSizesAggressively",OPTV_INTEGER,
	{0}, FALSE },
a777 4
  { FLAG_ALLOW_DEACTIVATE_GRABS,"AllowDeactivateGrabs",		OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_ALLOW_CLOSEDOWN_GRABS, "AllowClosedownGrabs",		OPTV_BOOLEAN,
	{0}, FALSE },
d834 3
a859 4
    xf86GetOptValBool(FlagOptions, FLAG_ALLOW_DEACTIVATE_GRABS,
		      &(xf86Info.grabInfo.allowDeactivate));
    xf86GetOptValBool(FlagOptions, FLAG_ALLOW_CLOSEDOWN_GRABS,
		      &(xf86Info.grabInfo.allowClosedown));
a870 6
#ifndef __OpenBSD__
        xf86Info.autoAddDevices = TRUE;
#else
       /* No hot-plug support -> don't break static autoconfiguration */
       xf86Info.autoAddDevices = FALSE;
#endif
a881 5
#ifndef __OpenBSD__
        xf86Info.autoEnableDevices = TRUE;
#else
	xf86Info.autoEnableDevices = FALSE;
#endif
a898 7
#ifdef XF86MISC
    if (xf86GetOptValBool(FlagOptions, FLAG_DISABLEMODINDEV, &value))
	xf86Info.miscModInDevEnabled = !value;
    if (xf86GetOptValBool(FlagOptions, FLAG_MODINDEVALLOWNONLOCAL, &value))
	xf86Info.miscModInDevAllowNonLocal = value;
#endif

a921 13
    if (xf86IsOptionSet(FlagOptions, FLAG_PCIPROBE1))
	xf86Info.pciFlags = PCIProbe1;
    if (xf86IsOptionSet(FlagOptions, FLAG_PCIPROBE2))
	xf86Info.pciFlags = PCIProbe2;
    if (xf86IsOptionSet(FlagOptions, FLAG_PCIFORCECONFIG1))
	xf86Info.pciFlags = PCIForceConfig1;
    if (xf86IsOptionSet(FlagOptions, FLAG_PCIFORCECONFIG2))
	xf86Info.pciFlags = PCIForceConfig2;
    if (xf86IsOptionSet(FlagOptions, FLAG_PCIOSCONFIG))
	xf86Info.pciFlags = PCIOsConfig;
    if (xf86IsOptionSet(FlagOptions, FLAG_PCIFORCENONE))
	xf86Info.pciFlags = PCIForceNone;

a979 6
    i = -1;
    xf86GetOptValInteger(FlagOptions, FLAG_ESTIMATE_SIZES_AGGRESSIVELY, &i);
    if (i >= 0)
	xf86Info.estimateSizesAggressively = i;
    else
	xf86Info.estimateSizesAggressively = 0;
d999 1
a999 1
	    xf86Msg(X_WARNING,"Unknown HandleSpecialKeys option\n");
d1013 9
d1320 1
a1320 1
#if 0
d1331 2
a1332 1
            !strcmp((*devs)->driver, "vmmouse") || !strcmp((*devs)->driver, "evdev")) {
d1355 1
a1355 1
#endif
d1483 1
d1487 4
d1567 1
d1572 3
d1629 14
d1833 1
a1833 1
    
d2018 1
d2153 5
a2157 2
    xf86GetOptValFreq(MonitorOptions, MON_MAX_PIX_CLOCK, OPTUNITS_KHZ,
		      &monitorp->maxPixClock);
d2451 2
a2452 1
                strcmp((*dev)->driver, "mouse") == 0)
d2458 1
a2458 1
                            "drivers 'kbd' or 'mouse' will be disabled.\n");
a2503 1
	    xf86Msg(X_ERROR, "Unable to locate/open config file");
d2505 2
a2506 2
		xf86ErrorFVerb(0, ": \"%s\"", xf86ConfigFile);
	    xf86ErrorFVerb(0, "\n");
a2608 7
#endif

#ifdef XF86MISC
    if (xf86MiscModInDevDisabled)
	xf86Info.miscModInDevEnabled = FALSE;
    if (xf86MiscModInDevAllowNonLocal)
	xf86Info.miscModInDevAllowNonLocal = TRUE;
@


1.7
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d1353 1
a1353 1
    if (!foundPointer && (!xf86Info.allowEmptyInput || implicitLayout)) {
d1493 1
a1493 1
    if (!foundKeyboard && (!xf86Info.allowEmptyInput || implicitLayout)) {
d2494 35
@


1.6
log
@fix for gcc2 (declaration 1st within each scope)
ok matthieu@@
@
text
@d63 1
d80 1
a80 1
#if (defined(i386) || defined(__i386__)) && \
a95 1
			"%D/%X," \
d117 16
d502 1
a502 1
    static const char *fallback[5] = { "vga", "vesa", "fbdev", "wsfb", NULL };
a544 6

/*
 * Generate a compiled-in list of driver names.  This is used to produce a
 * consistent probe order.  For the loader server, we also look for vendor-
 * provided modules, pre-pending them to our own list.
 */
d546 1
a546 1
GenerateDriverlist(char * dirname, char * drivernames)
a559 1

a563 1
    static Bool generated = FALSE;
d565 2
a566 7
    /* This string is modified in-place */
    static char drivernames[] = DRIVERS;

    if (!generated) {
        generated = TRUE;
        driverlist = GenerateDriverlist("drivers", drivernames);
    }
a693 15
  /* RgbPath */

  pathFrom = X_DEFAULT;

  if (xf86coFlag)
    pathFrom = X_CMDLINE;
  else if (fileconf) {
    if (fileconf->file_rgbpath) {
      rgbPath = fileconf->file_rgbpath;
      pathFrom = X_CONFIG;
    }
  }

  xf86Msg(pathFrom, "RgbPath set to \"%s\"\n", rgbPath);

a741 1
    FLAG_VTINIT,
d771 2
a793 2
  { FLAG_VTINIT,		"VTInit",			OPTV_STRING,
	{0}, FALSE },
d844 1
a844 1
  { FLAG_IGNORE_ABI,			"IgnoreABI",			OPTV_BOOLEAN,
d846 1
a846 1
  { FLAG_USE_DEFAULT_FONT_PATH,  "UseDefaultFontPath",			OPTV_BOOLEAN,
d848 1
a848 1
  { FLAG_AUTO_ADD_DEVICES,       "AutoAddDevices",                      OPTV_BOOLEAN,
d850 1
a850 1
  { FLAG_AUTO_ENABLE_DEVICES,    "AutoEnableDevices",                   OPTV_BOOLEAN,
d852 4
d860 1
a860 1
#if defined(i386) || defined(__i386__)
d887 1
d926 1
d928 4
d943 1
d945 3
a994 2
    xf86Info.vtinit = xf86GetOptValString(FlagOptions, FLAG_VTINIT);

a1011 1
	const char *s;
a1029 2
	const char *s;

a1042 1
	const char *s;
d1080 24
a1103 3
    xf86Info.allowEmptyInput = FALSE;
    if (xf86GetOptValBool(FlagOptions, FLAG_ALLOW_EMPTY_INPUT, &value))
        xf86Info.allowEmptyInput = TRUE;
d1172 1
a1172 1
#if defined(i386) || defined(__i386__)
d1197 9
d1209 5
d1337 1
a1337 1
    if (!foundPointer) {
d1353 1
a1353 1
    if (!foundPointer) {
d1368 1
a1368 1
    if (!foundPointer) {
d1370 2
a1371 2
	defPtr.inp_identifier = "<default pointer>";
	defPtr.inp_driver = "mouse";
d1395 7
a1401 3
	/* This shouldn't happen. */
	xf86Msg(X_ERROR, "Cannot locate a core pointer device.\n");
	return FALSE;
d1418 1
a1418 1
    if (!found) {
d1421 2
a1422 2
	defPtr.inp_identifier = "<default pointer>";
	defPtr.inp_driver = "mouse";
d1477 1
a1477 1
    if (!foundKeyboard) {
d1493 1
a1493 1
    if (!foundKeyboard) {
d1508 1
a1508 1
    if (!foundKeyboard) {
d1510 2
a1511 2
	defKbd.inp_identifier = "<default keyboard>";
	defKbd.inp_driver = "kbd";
d1535 7
a1541 3
	/* This shouldn't happen. */
	xf86Msg(X_ERROR, "Cannot locate a core keyboard device.\n");
	return FALSE;
d1545 7
a1551 3
	xf86Msg(X_DEFAULT, "The core pointer device wasn't specified "
		"explicitly in the layout.\n"
		"\tUsing the %s.\n", pointerMsg);
d1555 13
a1567 3
	xf86Msg(X_DEFAULT, "The core keyboard device wasn't specified "
		"explicitly in the layout.\n"
		"\tUsing the %s.\n", keyboardMsg);
a1856 5
    if (conf_screen == NULL) {
	xf86ConfigError("No Screen sections present\n");
	return FALSE;
    }

a1891 2
    if (!xf86Info.allowEmptyInput && !checkCoreInputDevices(servlayoutp, TRUE))
	return FALSE;
d1942 6
d1982 3
d1986 10
a1995 2
    configDevice(screenp->device,conf_screen->scrn_device, TRUE);
    screenp->device->myScreenSection = screenp;
d2008 12
d2143 1
a2143 2
        mode = xnfalloc(sizeof(DisplayModeRec));
        memset(mode,'\0',sizeof(DisplayModeRec));
d2295 4
d2305 1
a2305 1
	
d2453 1
a2453 1
modeIsPresent(char * modename,MonPtr monitorp)
d2460 1
a2460 1
	if(!strcmp(modename,knownmodes->name) &&
d2475 1
a2475 1
    while (xf86DefaultModes[i].name != NULL)
d2477 8
a2484 23
	if ( ! modeIsPresent(xf86DefaultModes[i].name,monitorp) )
	    do
	    {
		mode = xnfalloc(sizeof(DisplayModeRec));
		memcpy(mode,&xf86DefaultModes[i],sizeof(DisplayModeRec));
		if (xf86DefaultModes[i].name)
		    mode->name = xnfstrdup(xf86DefaultModes[i].name);
		if( last ) {
		    mode->prev = last;
		    last->next = mode;
		}
		else {
		    /* this is the first mode */
		    monitorp->Modes = mode;
		    mode->prev = NULL;
		}
		last = mode;
		i++;
	    }
	    while((xf86DefaultModes[i].name != NULL) &&
		  (!strcmp(xf86DefaultModes[i].name,xf86DefaultModes[i-1].name)));
	else
	    i++;
d2492 2
a2493 3
checkInput(serverLayoutPtr layout) {
    if (!xf86Info.allowEmptyInput)
        checkCoreInputDevices(layout, FALSE);
d2507 1
d2560 1
d2597 3
a2599 2
           xf86IsolateDevice.bus = bus;
           xf86IsolateDevice.device = device;
d2618 1
a2618 1
    checkInput(&xf86ConfigLayout);
@


1.5
log
@merge xserver 1.4, 1st pass
@
text
@d603 1
d605 1
a605 1
          char *g = xnfalloc(strlen(defaultFontPath) + strlen(f) + 3);
d1220 1
a1221 1
	pointer opt1 = NULL, opt2 = NULL;
@


1.4
log
@Don't force the addition of a "mouse" section if none was found.
This heuristic to fix configuration errors is wrong when
a touch screen is the primary input device (zaurus).
@
text
@a0 2


a53 4
#ifdef __UNIXOS2__
#define I_NEED_OS2_H
#endif

d72 1
a72 1
#include <X11/extensions/XKBsrv.h>
d128 1
a128 1
static Bool configDRI(XF86ConfDRIPtr drip);
d130 1
a130 1
static Bool configExtensions(XF86ConfExtensionsPtr conf_ext);
a177 1
#ifndef __UNIXOS2__
a179 6
#else
    /* OS/2 must prepend X11ROOT */
      path_elem = (char*)__XOS2RedirRoot(path_elem);
      dir_elem = xnfcalloc(1, strlen(path_elem) + 1);
      if (p1 = strchr(path_elem+2, ':'))
#endif
a202 1
#ifndef __UNIXOS2__
a203 1
#endif
d242 1
d255 44
a298 9
	/*
	 * Walk the list of modules in the "Module" section to determine how
	 * many we have.
	 */
	modp = xf86configptr->conf_modules->mod_load_lst;
	while (modp) {
            for (i = 0; ignore[i]; i++) {
                if (strcmp(modp->load_name, ignore[i]) == 0)
                    modp->ignore = 1;
d300 1
a300 4
            if (!modp->ignore)
	        count++;
	    modp = (XF86LoadPtr) modp->list.next;
	}
d303 6
d311 14
a324 11
    if (count == 0) {
	XF86ConfModulePtr ptr = xf86configptr->conf_modules;
	ptr = xf86addNewLoadDirective(ptr, "extmod", XF86_LOAD_MODULE, NULL);
	ptr = xf86addNewLoadDirective(ptr, "dbe", XF86_LOAD_MODULE, NULL);
	ptr = xf86addNewLoadDirective(ptr, "glx", XF86_LOAD_MODULE, NULL);
	ptr = xf86addNewLoadDirective(ptr, "freetype", XF86_LOAD_MODULE, NULL);
	ptr = xf86addNewLoadDirective(ptr, "type1", XF86_LOAD_MODULE, NULL);
	ptr = xf86addNewLoadDirective(ptr, "record", XF86_LOAD_MODULE, NULL);
	ptr = xf86addNewLoadDirective(ptr, "dri", XF86_LOAD_MODULE, NULL);
	count = 7;
    }
d333 2
a334 2
	modp = xf86configptr->conf_modules->mod_load_lst;
	while (modp) {
d336 3
a338 3
	        modulearray[count] = modp->load_name;
	        optarray[count] = modp->load_opt;
	        count++;
d340 2
a341 2
	    modp = (XF86LoadPtr) modp->list.next;
	}
d346 1
a346 1
	*optlist = optarray;
d348 1
a348 1
	xfree(optarray);
a424 12

Bool
xf86BuiltinInputDriver(const char *name)
{
#ifdef USE_DEPRECATED_KEYBOARD_DRIVER
    if (xf86NameCmp(name, "keyboard") == 0)
	return TRUE;
    else
#endif
	return FALSE;
}

d430 1
a430 1
    IDevPtr idp;
d448 2
a449 3
        while (idp->identifier) {
	    if (!xf86BuiltinInputDriver(idp->driver))
	        count++;
d463 3
a465 5
    while (idp->identifier) {
	if (!xf86BuiltinInputDriver(idp->driver)) {
	    modulearray[count] = idp->driver;
	    count++;
	}
a567 19

char **
xf86InputDriverlistFromCompile(void)
{
    static char **driverlist = NULL;
    static Bool generated = FALSE;

    /* This string is modified in-place */
    static char drivernames[] = IDRIVERS;

    if (!generated) {
        generated = TRUE;
	driverlist = GenerateDriverlist("input", drivernames);
    }

    return driverlist;
}


d586 1
a586 1
static Bool
a594 1

d601 12
a612 3
      if (*f)
        defaultFontPath = f;
      else {
d620 1
a620 1
      xf86Msg(X_WARNING,
d740 1
a740 1
  return TRUE;
d778 5
a782 1
    FLAG_IGNORE_ABI
d854 2
d858 6
d927 24
d1021 1
d1084 11
a1183 303
 * XXX This function is temporary, and will be removed when the keyboard
 * driver is converted into a regular input driver.
 */
static Bool
configInputKbd(IDevPtr inputp)
{
  char *s;
  MessageType from = X_DEFAULT;
  Bool customKeycodesDefault = FALSE;
  int verb = 0;
#if defined(XQUEUE)
  char *kbdproto = "Xqueue";
#else
  char *kbdproto = "standard";
#endif

  /* Initialize defaults */
  xf86Info.xleds         = 0L;
  xf86Info.kbdDelay      = 500;
  xf86Info.kbdRate       = 30;
  
  xf86Info.kbdProc       = NULL;
  xf86Info.vtinit        = NULL;
  xf86Info.vtSysreq      = VT_SYSREQ_DEFAULT;
#if defined(SVR4) && defined(i386)
  xf86Info.panix106      = FALSE;
#endif
  xf86Info.kbdCustomKeycodes = FALSE;
#ifdef WSCONS_SUPPORT
  xf86Info.kbdFd 	   = -1;
#endif
#ifdef XKB
  if (!xf86IsPc98()) {
    xf86Info.xkbrules      = __XKBDEFRULES__;
    xf86Info.xkbmodel      = "pc105";
    xf86Info.xkblayout     = "us";
    xf86Info.xkbvariant    = NULL;
    xf86Info.xkboptions    = NULL;
  } else {
    xf86Info.xkbrules      = "xfree98";
    xf86Info.xkbmodel      = "pc98";
    xf86Info.xkblayout     = "nec/jp";
    xf86Info.xkbvariant    = NULL;
    xf86Info.xkboptions    = NULL;
  }
  xf86Info.xkbcomponents_specified = FALSE;
  /* Should discourage the use of these. */
  xf86Info.xkbkeymap     = NULL;
  xf86Info.xkbtypes      = NULL;
  xf86Info.xkbcompat     = NULL;
  xf86Info.xkbkeycodes   = NULL;
  xf86Info.xkbsymbols    = NULL;
  xf86Info.xkbgeometry   = NULL;
#endif

  s = xf86SetStrOption(inputp->commonOptions, "Protocol", kbdproto);
  if (xf86NameCmp(s, "standard") == 0) {
     xf86Info.kbdProc    = xf86KbdProc;
     xf86Info.kbdEvents  = xf86KbdEvents;
     xfree(s);
  } else if (xf86NameCmp(s, "xqueue") == 0) {
#ifdef __UNIXWARE__
    /*
     * To retain compatibility with older config files, on UnixWare, we
     * accept the xqueue protocol but use the normal keyboard procs.
     */
     xf86Info.kbdProc    = xf86KbdProc;
     xf86Info.kbdEvents  = xf86KbdEvents;
#else
#ifdef XQUEUE
    xf86Info.kbdProc = xf86XqueKbdProc;
    xf86Info.kbdEvents = xf86XqueEvents;
    xf86Msg(X_CONFIG, "Xqueue selected for keyboard input\n");
#endif
#endif
    xfree(s);
#ifdef WSCONS_SUPPORT
  } else if (xf86NameCmp(s, "wskbd") == 0) {
     xf86Info.kbdProc    = xf86KbdProc;
     xf86Info.kbdEvents  = xf86WSKbdEvents;
     xfree(s);
     s = xf86SetStrOption(inputp->commonOptions, "Device", NULL);
     xf86Msg(X_CONFIG, "Keyboard: Protocol: wskbd\n");
     if (s == NULL) {
	 xf86ConfigError("A \"device\" option is required with"
			 " the \"wskbd\" keyboard protocol");
	 return FALSE;
     }
#ifndef X_PRIVSEP
     xf86Info.kbdFd = open(s, O_RDWR | O_NONBLOCK | O_EXCL);
#else
     xf86Info.kbdFd = priv_open_device(s);
#endif
     if (xf86Info.kbdFd == -1) {
       xf86ConfigError("cannot open \"%s\"", s);
       xfree(s);
       return FALSE;
     }
     xfree(s);
     /* Find out keyboard type */
     if (ioctl(xf86Info.kbdFd, WSKBDIO_GTYPE, &xf86Info.wsKbdType) == -1) {
	     xf86ConfigError("cannot get keyboard type");
	     close(xf86Info.kbdFd);
	     return FALSE;
     }
     switch (xf86Info.wsKbdType) {
     case WSKBD_TYPE_PC_XT:
	     xf86Msg(X_PROBED, "Keyboard type: XT\n");
	     break;
     case WSKBD_TYPE_PC_AT:
	     xf86Msg(X_PROBED, "Keyboard type: AT\n");
	     break;
     case WSKBD_TYPE_USB:
	     xf86Msg(X_PROBED, "Keyboard type: USB\n");
	     break;
#ifdef WSKBD_TYPE_ADB
     case WSKBD_TYPE_ADB:
	     xf86Msg(X_PROBED, "Keyboard type: ADB\n");
	     break;
#endif
#ifdef WSKBD_TYPE_SUN
     case WSKBD_TYPE_SUN:
	     xf86Msg(X_PROBED, "Keyboard type: Sun\n");
	     break;
#endif
#ifdef WSKBD_TYPE_SUN5
     case WSKBD_TYPE_SUN5:
	     xf86Msg(X_PROBED, "Keyboard type: Sun5\n");
	     break;
#endif
     default:
	     xf86ConfigError("Unsupported wskbd type \"%d\"", 
			     xf86Info.wsKbdType);
	     close(xf86Info.kbdFd);
	     return FALSE;
     }
     close (xf86Info.kbdFd);
#endif /* WSCONS_SUPPORT */
  } else {
    xf86ConfigError("\"%s\" is not a valid keyboard protocol name", s);
    xfree(s);
    return FALSE;
  }

  s = xf86SetStrOption(inputp->commonOptions, "AutoRepeat", NULL);
  if (s) {
    if (sscanf(s, "%d %d", &xf86Info.kbdDelay, &xf86Info.kbdRate) != 2) {
      xf86ConfigError("\"%s\" is not a valid AutoRepeat value", s);
      xfree(s);
      return FALSE;
    }
  xfree(s);
  }

  s = xf86SetStrOption(inputp->commonOptions, "XLeds", NULL);
  if (s) {
    char *l, *end;
    unsigned int i;
    l = strtok(s, " \t\n");
    while (l) {
      i = strtoul(l, &end, 0);
      if (*end == '\0')
	xf86Info.xleds |= 1L << (i - 1);
      else {
	xf86ConfigError("\"%s\" is not a valid XLeds value", l);
	xfree(s);
	return FALSE;
      }
      l = strtok(NULL, " \t\n");
    }
    xfree(s);
  }

#ifdef XKB
  from = X_DEFAULT;
  if (noXkbExtension)
    from = X_CMDLINE;
  else if (xf86FindOption(inputp->commonOptions, "XkbDisable")) {
    xf86Msg(X_WARNING, "KEYBOARD: XKB should be disabled in the "
	    "ServerFlags section instead\n"
	    "\tof in the \"keyboard\" InputDevice section.\n");
    noXkbExtension =
	xf86SetBoolOption(inputp->commonOptions, "XkbDisable", FALSE);
    from = X_CONFIG;
  }
  if (noXkbExtension)
    xf86Msg(from, "XKB: disabled\n");

#define NULL_IF_EMPTY(s) (s[0] ? s : (xfree(s), (char *)NULL))

  if (!noXkbExtension) {
    if ((s = xf86SetStrOption(inputp->commonOptions, "XkbKeymap", NULL))) {
      xf86Info.xkbkeymap = NULL_IF_EMPTY(s);
      xf86Msg(X_CONFIG, "XKB: keymap: \"%s\" "
		"(overrides other XKB settings)\n", xf86Info.xkbkeymap);
    } else {
      if ((s = xf86SetStrOption(inputp->commonOptions, "XkbCompat", NULL))) {
	xf86Info.xkbcompat = NULL_IF_EMPTY(s);
	xf86Info.xkbcomponents_specified = TRUE;
	xf86Msg(X_CONFIG, "XKB: compat: \"%s\"\n", s);
      }

      if ((s = xf86SetStrOption(inputp->commonOptions, "XkbTypes", NULL))) {
	xf86Info.xkbtypes = NULL_IF_EMPTY(s);
	xf86Info.xkbcomponents_specified = TRUE;
	xf86Msg(X_CONFIG, "XKB: types: \"%s\"\n", s);
      }

      if ((s = xf86SetStrOption(inputp->commonOptions, "XkbKeycodes", NULL))) {
	xf86Info.xkbkeycodes = NULL_IF_EMPTY(s);
	xf86Info.xkbcomponents_specified = TRUE;
	xf86Msg(X_CONFIG, "XKB: keycodes: \"%s\"\n", s);
      }

      if ((s = xf86SetStrOption(inputp->commonOptions, "XkbGeometry", NULL))) {
	xf86Info.xkbgeometry = NULL_IF_EMPTY(s);
	xf86Info.xkbcomponents_specified = TRUE;
	xf86Msg(X_CONFIG, "XKB: geometry: \"%s\"\n", s);
      }

      if ((s = xf86SetStrOption(inputp->commonOptions, "XkbSymbols", NULL))) {
	xf86Info.xkbsymbols = NULL_IF_EMPTY(s);
	xf86Info.xkbcomponents_specified = TRUE;
	xf86Msg(X_CONFIG, "XKB: symbols: \"%s\"\n", s);
      }

      if ((s = xf86SetStrOption(inputp->commonOptions, "XkbRules", NULL))) {
	xf86Info.xkbrules = NULL_IF_EMPTY(s);
	xf86Info.xkbcomponents_specified = TRUE;
	xf86Msg(X_CONFIG, "XKB: rules: \"%s\"\n", s);
      }

      if ((s = xf86SetStrOption(inputp->commonOptions, "XkbModel", NULL))) {
	xf86Info.xkbmodel = NULL_IF_EMPTY(s);
	xf86Info.xkbcomponents_specified = TRUE;
	xf86Msg(X_CONFIG, "XKB: model: \"%s\"\n", s);
      }

      if ((s = xf86SetStrOption(inputp->commonOptions, "XkbLayout", NULL))) {
	xf86Info.xkblayout = NULL_IF_EMPTY(s);
	xf86Info.xkbcomponents_specified = TRUE;
	xf86Msg(X_CONFIG, "XKB: layout: \"%s\"\n", s);
      }

      if ((s = xf86SetStrOption(inputp->commonOptions, "XkbVariant", NULL))) {
	xf86Info.xkbvariant = NULL_IF_EMPTY(s);
	xf86Info.xkbcomponents_specified = TRUE;
	xf86Msg(X_CONFIG, "XKB: variant: \"%s\"\n", s);
      }

      if ((s = xf86SetStrOption(inputp->commonOptions, "XkbOptions", NULL))) {
	xf86Info.xkboptions = NULL_IF_EMPTY(s);
	xf86Info.xkbcomponents_specified = TRUE;
	xf86Msg(X_CONFIG, "XKB: options: \"%s\"\n", s);
      }
    }
  }
#undef NULL_IF_EMPTY
#endif
#if defined(SVR4) && defined(i386)
  if ((xf86Info.panix106 =
	xf86SetBoolOption(inputp->commonOptions, "Panix106", FALSE))) {
    xf86Msg(X_CONFIG, "PANIX106: enabled\n");
  }
#endif

  /*
   * This was once a compile time option (ASSUME_CUSTOM_KEYCODES)
   * defaulting to 1 on Linux/PPC. It is no longer necessary, but for
   * backwards compatibility we provide 'Option "CustomKeycodes"'
   * and try to autoprobe on Linux/PPC.
   */
  from = X_DEFAULT;
  verb = 2;
#if defined(__linux__) && defined(__powerpc__)
  {
    FILE *f;

    f = fopen("/proc/sys/dev/mac_hid/keyboard_sends_linux_keycodes","r");
    if (f) {
      if (fgetc(f) == '0') {
	customKeycodesDefault = TRUE;
	from = X_PROBED;
	verb = 1;
      }
      fclose(f);
    }
  }
#endif
  if (xf86FindOption(inputp->commonOptions, "CustomKeycodes")) {
    from = X_CONFIG;
    verb = 1;
  }
  xf86Info.kbdCustomKeycodes =
	xf86SetBoolOption(inputp->commonOptions, "CustomKeycodes",
			  customKeycodesDefault);
  xf86MsgVerb(from, verb, "Keyboard: CustomKeycode %s\n",
		xf86Info.kbdCustomKeycodes ? "enabled" : "disabled");

  return TRUE;
}

/*
d1204 2
a1205 1
    IDevPtr indp, i;
d1218 2
a1219 1
    for (indp = servlayoutp->inputs; indp->identifier; indp++) {
d1284 5
a1288 2
	    for (indp = servlayoutp->inputs; indp->identifier; indp++)
		if (indp == corePointer)
d1290 3
a1292 2
	    for (; indp->identifier; indp++)
		indp[0] = indp[1];
d1352 8
a1359 7
	    indp = xnfrealloc(servlayoutp->inputs,
			      (count + 1) * sizeof(IDevRec));
	    indp[count - 1] = Pointer;
	    indp[count - 1].extraOptions =
				xf86addNewOption(NULL, "CorePointer", NULL);
	    indp[count].identifier = NULL;
	    servlayoutp->inputs = indp;
d1373 3
d1377 3
a1379 2
    for (i = servlayoutp->inputs; i->identifier && i->driver; i++) {
	if (!strcmp(i->driver, "void") || !strcmp(i->driver, "mouse")) {
d1392 8
a1399 7
	    indp = xnfrealloc(servlayoutp->inputs,
			      (count + 1) * sizeof(IDevRec));
	    indp[count - 1] = Pointer;
	    indp[count - 1].extraOptions =
				xf86addNewOption(NULL, "AlwaysCore", NULL);
	    indp[count].identifier = NULL;
	    servlayoutp->inputs = indp;
d1420 5
a1424 2
	    for (indp = servlayoutp->inputs; indp->identifier; indp++)
		if (indp == coreKeyboard)
d1426 3
a1428 2
	    for (; indp->identifier; indp++)
		indp[0] = indp[1];
a1464 4
	if (!confInput) {
	    confInput = xf86findInputByDriver("keyboard",
					      xf86configptr->conf_input_lst);
	}
d1488 8
a1495 7
	    indp = xnfrealloc(servlayoutp->inputs,
			      (count + 1) * sizeof(IDevRec));
	    indp[count - 1] = Keyboard;
	    indp[count - 1].extraOptions =
				xf86addNewOption(NULL, "CoreKeyboard", NULL);
	    indp[count].identifier = NULL;
	    servlayoutp->inputs = indp;
d1506 1
a1506 1
	xf86Msg(X_WARNING, "The core pointer device wasn't specified "
d1512 1
a1512 1
	xf86Msg(X_WARNING, "The core keyboard device wasn't specified "
d1551 1
a1551 1
    IDevPtr indp;
d1763 2
a1764 2
    indp = xnfalloc((count + 1) * sizeof(IDevRec));
    indp[count].identifier = NULL;
d1768 6
a1773 3
	if (!configInput(&indp[count], irp->iref_inputdev, X_CONFIG)) {
	    xfree(indp);
	    return FALSE;
d1775 1
a1775 1
	indp[count].extraOptions = irp->iref_option_lst;
a1785 2
    if (!checkCoreInputDevices(servlayoutp, FALSE))
	return FALSE;
d1799 1
a1799 1
    IDevPtr indp;
d1841 2
a1842 2
    indp = xnfalloc(sizeof(IDevRec));
    indp->identifier = NULL;
d1844 1
a1844 1
    if (!checkCoreInputDevices(servlayoutp, TRUE))
d1972 1
a1972 1
	xf86Msg(X_WARNING, "No monitor specified for screen \"%s\".\n"
d1979 2
a1980 1
    MON_REDUCEDBLANKING
d1986 2
a2133 1
    /* Check wether this Monitor accepts Reduced Blanking modelines */
a2134 1

d2137 2
d2266 1
a2266 1
static Bool
a2306 2

    return TRUE;
d2310 1
a2310 1
static Bool
d2345 1
a2345 3
		xf86Msg(X_ERROR,
			"%s is not a valid value for the Extension option\n",
			val);
d2347 1
a2347 1
		return FALSE;
a2359 2

    return TRUE;
a2370 4
    /* XXX This is required until the keyboard driver is converted */
    if (!xf86NameCmp(inputp->driver, "keyboard"))
	return configInputKbd(inputp);

d2428 6
d2489 1
a2489 1
	    xf86Msg(X_WARNING,
d2542 4
d2547 2
a2548 4
    if (!configFiles(xf86configptr->conf_files) ||
        !configServerFlags(xf86configptr->conf_flags,
			   xf86ConfigLayout.options) ||
	!configExtensions(xf86configptr->conf_extensions)
d2550 1
a2550 1
	|| !configDRI(xf86configptr->conf_dri)
d2552 2
a2553 4
       ) {
             ErrorF ("Problem when converting the config data structures\n");
             return CONFIG_PARSE_ERROR;
    }
a2578 8

/* These make the equivalent parser functions visible to the common layer. */
Bool
xf86PathIsAbsolute(const char *path)
{
    return (xf86pathIsAbsolute(path) != 0);
}

a2583 1

@


1.3
log
@- merge xserver 1.1.99.903
- regen generated files
@
text
@d1615 1
a1615 1

d1644 1
a1644 1

@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@d254 1
a254 1
    char *ignore[] = { "GLcore", "speedo", "bitmap", NULL };
d1621 1
a1621 1
    for (i = servlayoutp->inputs; i->driver; i++) {
@


1.1
log
@Initial revision
@
text
@d1223 1
d1225 3
d1271 2
a1272 1
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.1.99.903 from X.Org 7.2RC3
@
text
@d254 1
a254 1
    char *ignore[] = { "GLcore", "speedo", "bitmap", "drm", NULL };
d1616 1
a1616 1
    for (i = servlayoutp->inputs; i->identifier && i->driver; i++) {
@


1.1.1.3
log
@xserver 1.4
@
text
@d1 2
d56 4
d78 1
a78 1
#include <xkbsrv.h>
d134 1
a134 1
static void configDRI(XF86ConfDRIPtr drip);
d136 1
a136 1
static void configExtensions(XF86ConfExtensionsPtr conf_ext);
d184 1
d187 6
d216 1
d218 1
a256 1
    Bool found;
d269 9
a277 18
        /* Walk the disable list and let people know what we've parsed to
         * not be loaded 
         */
        modp = xf86configptr->conf_modules->mod_disable_lst;
        while (modp) {
            xf86Msg(X_WARNING, "\"%s\" will not be loaded unless you've specified it to be loaded elsewhere.\n", modp->load_name);
	        modp = (XF86LoadPtr) modp->list.next;
        }
        /*
         * Walk the default settings table. For each module listed to be
         * loaded, make sure it's in the mod_load_lst. If it's not, make
         * sure it's not in the mod_no_load_lst. If it's not disabled,
         * append it to mod_load_lst
         */
         for (i=0 ; ModuleDefaults[i].name != NULL ; i++) {
            if (ModuleDefaults[i].toLoad == FALSE) {
                xf86Msg(X_WARNING, "\"%s\" is not to be loaded by default. Skipping.\n", ModuleDefaults[i].name);
                continue;
d279 4
a282 27
            found = FALSE;
            modp = xf86configptr->conf_modules->mod_load_lst;
            while (modp) {
                if (strcmp(modp->load_name, ModuleDefaults[i].name) == 0) {
                    xf86Msg(X_INFO, "\"%s\" will be loaded. This was enabled by default and also specified in the config file.\n", ModuleDefaults[i].name);
                    found = TRUE;
                    break;
                }
	        modp = (XF86LoadPtr) modp->list.next;
            }
            if (found == FALSE) {
                modp = xf86configptr->conf_modules->mod_disable_lst;
                while (modp) {
                    if (strcmp(modp->load_name, ModuleDefaults[i].name) == 0) {
                        xf86Msg(X_INFO, "\"%s\" will be loaded even though the default is to disable it.\n", ModuleDefaults[i].name);
                        found = TRUE;
                        break;
                    }
	                modp = (XF86LoadPtr) modp->list.next;
                }
            }
            if (found == FALSE) {
	            XF86ConfModulePtr ptr = xf86configptr->conf_modules;
	            ptr = xf86addNewLoadDirective(ptr, ModuleDefaults[i].name, XF86_LOAD_MODULE, ModuleDefaults[i].load_opt);
                xf86Msg(X_INFO, "\"%s\" will be loaded by default.\n", ModuleDefaults[i].name);
            }
         }
a284 6
	for (i=0 ; ModuleDefaults[i].name != NULL ; i++) {
	    if (ModuleDefaults[i].toLoad == TRUE) {
		XF86ConfModulePtr ptr = xf86configptr->conf_modules;
		ptr = xf86addNewLoadDirective(ptr, ModuleDefaults[i].name, XF86_LOAD_MODULE, ModuleDefaults[i].load_opt);
	    }
	}
d287 11
a297 14
	    /*
	     * Walk the list of modules in the "Module" section to determine how
	     * many we have.
	    */
	    modp = xf86configptr->conf_modules->mod_load_lst;
	    while (modp) {
                for (i = 0; ignore[i]; i++) {
                    if (strcmp(modp->load_name, ignore[i]) == 0)
                        modp->ignore = 1;
                }
                if (!modp->ignore)
	            count++;
	        modp = (XF86LoadPtr) modp->list.next;
	    }
d306 2
a307 2
	    modp = xf86configptr->conf_modules->mod_load_lst;
	    while (modp) {
d309 3
a311 3
	            modulearray[count] = modp->load_name;
	            optarray[count] = modp->load_opt;
	            count++;
d313 2
a314 2
	        modp = (XF86LoadPtr) modp->list.next;
	    }
d319 1
a319 1
	    *optlist = optarray;
d321 1
a321 1
	    xfree(optarray);
d398 12
d415 1
a415 1
    IDevPtr* idp;
d433 3
a435 2
        while (*idp) {
	    count++;
d449 5
a453 3
    while (idp && *idp) {
        modulearray[count] = (*idp)->driver;
	count++;
d556 19
d593 1
a593 1
static void
d602 1
d609 3
a611 12
      if (*f) {
        if (xf86Info.useDefaultFontPath) {
          xf86Msg(X_DEFAULT, "Including the default font path %s.\n", defaultFontPath);
          char *g = xnfalloc(strlen(defaultFontPath) + strlen(f) + 3);
          strcpy(g, f);
          strcat(g, ",");
          defaultFontPath = strcat(g, defaultFontPath);
          xfree(f);
        } else {
          defaultFontPath = f;
        }
      } else {
d619 1
a619 1
      xf86Msg(X_DEFAULT,
d739 1
a739 1
  return;
d777 1
a777 5
    FLAG_IGNORE_ABI,
    FLAG_ALLOW_EMPTY_INPUT,
    FLAG_USE_DEFAULT_FONT_PATH,
    FLAG_AUTO_ADD_DEVICES,
    FLAG_AUTO_ENABLE_DEVICES,
a848 2
  { FLAG_ALLOW_EMPTY_INPUT,     "AllowEmptyInput",              OPTV_BOOLEAN,
        {0}, FALSE },
a850 6
  { FLAG_USE_DEFAULT_FONT_PATH,  "UseDefaultFontPath",			OPTV_BOOLEAN,
	{0}, FALSE },
  { FLAG_AUTO_ADD_DEVICES,       "AutoAddDevices",                      OPTV_BOOLEAN,
        {0}, TRUE },
  { FLAG_AUTO_ENABLE_DEVICES,    "AutoEnableDevices",                   OPTV_BOOLEAN,
        {0}, TRUE },
a913 24
    if (xf86IsOptionSet(FlagOptions, FLAG_AUTO_ADD_DEVICES)) {
        xf86GetOptValBool(FlagOptions, FLAG_AUTO_ADD_DEVICES,
                          &xf86Info.autoAddDevices);
        from = X_CONFIG;
    }
    else {
        xf86Info.autoAddDevices = TRUE;
        from = X_DEFAULT;
    }
    xf86Msg(from, "%sutomatically adding devices\n",
            xf86Info.autoAddDevices ? "A" : "Not a");

    if (xf86IsOptionSet(FlagOptions, FLAG_AUTO_ENABLE_DEVICES)) {
        xf86GetOptValBool(FlagOptions, FLAG_AUTO_ENABLE_DEVICES,
                          &xf86Info.autoEnableDevices);
        from = X_CONFIG;
    }
    else {
        xf86Info.autoEnableDevices = TRUE;
        from = X_DEFAULT;
    }
    xf86Msg(from, "%sutomatically enabling devices\n",
            xf86Info.autoEnableDevices ? "A" : "Not a");

a983 1
		LogSetParameter(XLOG_FLUSH, TRUE);
a1045 11
    xf86Info.allowEmptyInput = FALSE;
    if (xf86GetOptValBool(FlagOptions, FLAG_ALLOW_EMPTY_INPUT, &value))
        xf86Info.allowEmptyInput = TRUE;

    xf86Info.useDefaultFontPath = TRUE;
    xf86Info.useDefaultFontPathFrom = X_DEFAULT;
    if (xf86GetOptValBool(FlagOptions, FLAG_USE_DEFAULT_FONT_PATH, &value)) {
	xf86Info.useDefaultFontPath = value;
	xf86Info.useDefaultFontPathFrom = X_CONFIG;
    }

d1135 298
d1453 1
a1453 2
    IDevPtr *devs, /* iterator */
            indp;
d1466 1
a1466 2
    for (devs = servlayoutp->inputs; devs && *devs; devs++) {
        indp = *devs;
d1531 2
a1532 5
	    for (devs = servlayoutp->inputs; devs && *devs; devs++)
		if (*devs == corePointer)
                {
                    xfree(*devs);
                    *devs = (IDevPtr)0x1; /* ensure we dont skip next loop*/
d1534 2
a1535 3
                }
	    for (; devs && *devs; devs++)
		devs[0] = devs[1];
d1595 7
a1601 8
	    devs = xnfrealloc(servlayoutp->inputs,
			      (count + 1) * sizeof(IDevPtr));
            devs[count - 1] = xnfalloc(sizeof(IDevRec));
	    *devs[count - 1] = Pointer;
	    devs[count - 1]->extraOptions =
				xf86addNewOption(NULL, xnfstrdup("CorePointer"), NULL);
	    devs[count] = NULL;
	    servlayoutp->inputs = devs;
a1614 3
     *
     * If you're using an evdev keyboard and expect a default mouse
     * section ... deal.
d1616 2
a1617 3
    for (devs = servlayoutp->inputs; devs && *devs; devs++) {
	if (!strcmp((*devs)->driver, "void") || !strcmp((*devs)->driver, "mouse") ||
            !strcmp((*devs)->driver, "vmmouse") || !strcmp((*devs)->driver, "evdev")) {
d1630 7
a1636 8
	    devs = xnfrealloc(servlayoutp->inputs,
			      (count + 1) * sizeof(IDevPtr));
            devs[count - 1] = xnfalloc(sizeof(IDevRec));
	    *devs[count - 1] = Pointer;
	    devs[count - 1]->extraOptions =
				xf86addNewOption(NULL, xnfstrdup("AlwaysCore"), NULL);
	    devs[count] = NULL;
	    servlayoutp->inputs = devs;
d1657 2
a1658 5
	    for (devs = servlayoutp->inputs; devs && *devs; devs++)
		if (*devs == coreKeyboard)
                {
                    xfree(*devs);
                    *devs = (IDevPtr)0x1; /* ensure we dont skip next loop */
d1660 2
a1661 3
                }
	    for (; devs && *devs; devs++)
		devs[0] = devs[1];
d1698 4
d1725 7
a1731 8
	    devs = xnfrealloc(servlayoutp->inputs,
			      (count + 1) * sizeof(IDevPtr));
            devs[count - 1] = xnfalloc(sizeof(IDevRec));
	    *devs[count - 1] = Keyboard;
	    devs[count - 1]->extraOptions =
				xf86addNewOption(NULL, xnfstrdup("CoreKeyboard"), NULL);
	    devs[count] = NULL;
	    servlayoutp->inputs = devs;
d1742 1
a1742 1
	xf86Msg(X_DEFAULT, "The core pointer device wasn't specified "
d1748 1
a1748 1
	xf86Msg(X_DEFAULT, "The core keyboard device wasn't specified "
d1787 1
a1787 1
    IDevPtr* indp;
d1999 2
a2000 2
    indp = xnfcalloc((count + 1), sizeof(IDevPtr));
    indp[count] = NULL;
d2004 3
a2006 6
        indp[count] = xnfalloc(sizeof(IDevRec));
	if (!configInput(indp[count], irp->iref_inputdev, X_CONFIG)) {
            while(count--) 
                xfree(indp[count]);
            xfree(indp);
            return FALSE;
d2008 1
a2008 1
	indp[count]->extraOptions = irp->iref_option_lst;
d2019 2
d2034 1
a2034 1
    IDevPtr *indp;
d2076 2
a2077 2
    indp = xnfalloc(sizeof(IDevPtr));
    *indp = NULL;
d2079 1
a2079 1
    if (!xf86Info.allowEmptyInput && !checkCoreInputDevices(servlayoutp, TRUE))
d2207 1
a2207 1
	xf86Msg(X_DEFAULT, "No monitor specified for screen \"%s\".\n"
d2214 1
a2214 2
    MON_REDUCEDBLANKING,
    MON_MAX_PIX_CLOCK,
a2219 2
  { MON_MAX_PIX_CLOCK,	      "MaxPixClock",		OPTV_FREQ,
       {0}, FALSE },
d2366 1
d2368 1
a2370 2
    xf86GetOptValFreq(MonitorOptions, MON_MAX_PIX_CLOCK, OPTUNITS_KHZ,
		      &monitorp->maxPixClock);
d2498 1
a2498 1
static void
d2539 2
d2544 1
a2544 1
static void
d2579 3
a2581 1
		xf86Msg(X_WARNING, "Ignoring unrecognized value \"%s\"\n", val);
d2583 1
a2583 1
		continue;
d2596 2
d2609 4
a2669 6
static void
checkInput(serverLayoutPtr layout) {
    if (!xf86Info.allowEmptyInput)
        checkCoreInputDevices(layout, FALSE);
}

d2725 1
a2725 1
	    xf86Msg(X_DEFAULT,
d2778 9
a2786 1
    if (!configServerFlags(xf86configptr->conf_flags,xf86ConfigLayout.options)){
a2790 8
    configFiles(xf86configptr->conf_files);
    configExtensions(xf86configptr->conf_extensions);
#ifdef XF86DRI
    configDRI(xf86configptr->conf_dri);
#endif

    checkInput(&xf86ConfigLayout);

d2815 8
d2828 1
@


