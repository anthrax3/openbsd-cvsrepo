head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	OPENBSD_5_0:1.1.1.1.0.18
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.14
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.09.16.19.10.24;	author matthieu;	state dead;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Dakshinamurthy Karra
 *		Suhaib M Siddiqi
 *		Peter Busch
 *		Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

/*
 * Local function prototypes
 */

static Bool
 winAllocateFBPrimaryDD(ScreenPtr pScreen);

static Bool
 winCloseScreenPrimaryDD(ScreenPtr pScreen);

static Bool
 winInitVisualsPrimaryDD(ScreenPtr pScreen);

static Bool
 winAdjustVideoModePrimaryDD(ScreenPtr pScreen);

static Bool
 winActivateAppPrimaryDD(ScreenPtr pScreen);

static Bool
 winHotKeyAltTabPrimaryDD(ScreenPtr pScreen);

/*
 * Create a DirectDraw primary surface 
 */

static Bool
winAllocateFBPrimaryDD(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    HRESULT ddrval = DD_OK;
    DDSURFACEDESC ddsd;
    DDSURFACEDESC *pddsdPrimary = NULL;
    DDSURFACEDESC *pddsdOffscreen = NULL;
    RECT rcClient;

    ErrorF("winAllocateFBPrimaryDD\n");

    /* Get client area location in screen coords */
    GetClientRect(pScreenPriv->hwndScreen, &rcClient);
    MapWindowPoints(pScreenPriv->hwndScreen,
                    HWND_DESKTOP, (LPPOINT) &rcClient, 2);

    /* Create a DirectDraw object, store the address at lpdd */
    ddrval = (*g_fpDirectDrawCreate) (NULL, &pScreenPriv->pdd, NULL);
    if (ddrval != DD_OK)
        FatalError("winAllocateFBPrimaryDD - Could not start DirectDraw\n");

    /* Get a DirectDraw2 interface pointer */
    ddrval = IDirectDraw_QueryInterface(pScreenPriv->pdd,
                                        &IID_IDirectDraw2,
                                        (LPVOID *) &pScreenPriv->pdd2);
    if (FAILED(ddrval)) {
        ErrorF("winAllocateFBShadowDD - Failed DD2 query: %08x\n",
               (unsigned int) ddrval);
        return FALSE;
    }

    ErrorF("winAllocateFBPrimaryDD - Created and initialized DD\n");

    /* Are we windowed or fullscreen? */
    if (pScreenInfo->fFullScreen) {
        /* Full screen mode */
        ddrval = IDirectDraw2_SetCooperativeLevel(pScreenPriv->pdd2,
                                                  pScreenPriv->hwndScreen,
                                                  DDSCL_FULLSCREEN
                                                  | DDSCL_EXCLUSIVE);
        if (FAILED(ddrval))
            FatalError("winAllocateFBPrimaryDD - Could not set "
                       "cooperative level\n");

        /* Change the video mode to the mode requested */
        ddrval = IDirectDraw2_SetDisplayMode(pScreenPriv->pdd2,
                                             pScreenInfo->dwWidth,
                                             pScreenInfo->dwHeight,
                                             pScreenInfo->dwBPP,
                                             pScreenInfo->dwRefreshRate, 0);
        if (FAILED(ddrval))
            FatalError("winAllocateFBPrimaryDD - Could not set "
                       "full screen display mode\n");
    }
    else {
        /* Windowed mode */
        ddrval = IDirectDraw2_SetCooperativeLevel(pScreenPriv->pdd2,
                                                  pScreenPriv->hwndScreen,
                                                  DDSCL_NORMAL);
        if (FAILED(ddrval))
            FatalError("winAllocateFBPrimaryDD - Could not set "
                       "cooperative level\n");
    }

    /* Describe the primary surface */
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

    /* Create the primary surface */
    ddrval = IDirectDraw2_CreateSurface(pScreenPriv->pdd2,
                                        &ddsd, &pScreenPriv->pddsPrimary, NULL);
    if (FAILED(ddrval))
        FatalError("winAllocateFBPrimaryDD - Could not create primary "
                   "surface %08x\n", (unsigned int) ddrval);

    ErrorF("winAllocateFBPrimaryDD - Created primary\n");

    /* Allocate a DD surface description for our screen privates */
    pddsdPrimary = pScreenPriv->pddsdPrimary = malloc(sizeof(DDSURFACEDESC));
    if (pddsdPrimary == NULL)
        FatalError("winAllocateFBPrimaryDD - Could not allocate surface "
                   "description memory\n");
    ZeroMemory(pddsdPrimary, sizeof(*pddsdPrimary));
    pddsdPrimary->dwSize = sizeof(*pddsdPrimary);

    /* Describe the offscreen surface to be created */
    /*
     * NOTE: Do not use a DDSCAPS_VIDEOMEMORY surface,
     * as drawing, locking, and unlocking take forever
     * with video memory surfaces.  In addition,
     * video memory is a somewhat scarce resource,
     * so you shouldn't be allocating video memory when
     * you have the option of using system memory instead.
     */
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
    ddsd.dwHeight = pScreenInfo->dwHeight;
    ddsd.dwWidth = pScreenInfo->dwWidth;

    /* Create the shadow surface */
    ddrval = IDirectDraw2_CreateSurface(pScreenPriv->pdd2,
                                        &ddsd,
                                        &pScreenPriv->pddsOffscreen, NULL);
    if (ddrval != DD_OK)
        FatalError("winAllocateFBPrimaryDD - Could not create shadow "
                   "surface\n");

    ErrorF("winAllocateFBPrimaryDD - Created offscreen\n");

    /* Allocate a DD surface description for our screen privates */
    pddsdOffscreen = pScreenPriv->pddsdOffscreen
        = malloc(sizeof(DDSURFACEDESC));
    if (pddsdOffscreen == NULL)
        FatalError("winAllocateFBPrimaryDD - Could not allocate surface "
                   "description memory\n");
    ZeroMemory(pddsdOffscreen, sizeof(*pddsdOffscreen));
    pddsdOffscreen->dwSize = sizeof(*pddsdOffscreen);

    ErrorF("winAllocateFBPrimaryDD - Locking primary\n");

    /* Lock the primary surface */
    ddrval = IDirectDrawSurface2_Lock(pScreenPriv->pddsPrimary,
                                      pScreenInfo->
                                      fFullScreen ? NULL : &rcClient,
                                      pddsdPrimary, DDLOCK_WAIT, NULL);
    if (ddrval != DD_OK || pddsdPrimary->lpSurface == NULL)
        FatalError("winAllocateFBPrimaryDD - Could not lock "
                   "primary surface\n");

    ErrorF("winAllocateFBPrimaryDD - Locked primary\n");

    /* We don't know how to deal with anything other than RGB */
    if (!(pddsdPrimary->ddpfPixelFormat.dwFlags & DDPF_RGB))
        FatalError("winAllocateFBPrimaryDD - Color format other than RGB\n");

    /* Grab the pitch from the surface desc */
    pScreenInfo->dwStride = (pddsdPrimary->u1.lPitch * 8)
        / pScreenInfo->dwBPP;

    /* Save the pointer to our surface memory */
    pScreenInfo->pfb = pddsdPrimary->lpSurface;

    /* Grab the color depth and masks from the surface description */
    pScreenPriv->dwRedMask = pddsdPrimary->ddpfPixelFormat.u2.dwRBitMask;
    pScreenPriv->dwGreenMask = pddsdPrimary->ddpfPixelFormat.u3.dwGBitMask;
    pScreenPriv->dwBlueMask = pddsdPrimary->ddpfPixelFormat.u4.dwBBitMask;

    ErrorF("winAllocateFBPrimaryDD - Returning\n");

    return TRUE;
}

static void
winFreeFBPrimaryDD(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Free the offscreen surface, if there is one */
    if (pScreenPriv->pddsOffscreen) {
        IDirectDrawSurface2_Unlock(pScreenPriv->pddsOffscreen, NULL);
        IDirectDrawSurface2_Release(pScreenPriv->pddsOffscreen);
        pScreenPriv->pddsOffscreen = NULL;
    }

    /* Release the primary surface, if there is one */
    if (pScreenPriv->pddsPrimary) {
        IDirectDrawSurface2_Unlock(pScreenPriv->pddsPrimary, NULL);
        IDirectDrawSurface2_Release(pScreenPriv->pddsPrimary);
        pScreenPriv->pddsPrimary = NULL;
    }

    /* Free the DirectDraw object, if there is one */
    if (pScreenPriv->pdd) {
        IDirectDraw2_RestoreDisplayMode(pScreenPriv->pdd);
        IDirectDraw2_Release(pScreenPriv->pdd);
        pScreenPriv->pdd = NULL;
    }

    /* Invalidate the ScreenInfo's fb pointer */
    pScreenInfo->pfb = NULL;
}

static Bool
winInitScreenPrimaryDD(ScreenPtr pScreen)
{
    return winAllocateFBPrimaryDD(pScreen);
}

/*
 * Call the wrapped CloseScreen function.
 * 
 * Free our resources and private structures.
 */

static Bool
winCloseScreenPrimaryDD(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    Bool fReturn;

    ErrorF("winCloseScreenPrimaryDD - Freeing screen resources\n");

    /* Flag that the screen is closed */
    pScreenPriv->fClosed = TRUE;
    pScreenPriv->fActive = FALSE;

    /* Call the wrapped CloseScreen procedure */
    WIN_UNWRAP(CloseScreen);
    if (pScreen->CloseScreen)
        fReturn = (*pScreen->CloseScreen) (pScreen);

    /* Delete the window property */
    RemoveProp(pScreenPriv->hwndScreen, WIN_SCR_PROP);

    winFreeFBPrimaryDD(pScreen);

    /* Delete tray icon, if we have one */
    if (!pScreenInfo->fNoTrayIcon)
        winDeleteNotifyIcon(pScreenPriv);

    /* Free the exit confirmation dialog box, if it exists */
    if (g_hDlgExit != NULL) {
        DestroyWindow(g_hDlgExit);
        g_hDlgExit = NULL;
    }

    /* Kill our window */
    if (pScreenPriv->hwndScreen) {
        DestroyWindow(pScreenPriv->hwndScreen);
        pScreenPriv->hwndScreen = NULL;
    }

    /* Kill our screeninfo's pointer to the screen */
    pScreenInfo->pScreen = NULL;

    /* Free the screen privates for this screen */
    free((void *) pScreenPriv);

    return fReturn;
}

/*
 * Tell mi what sort of visuals we need.
 * 
 * Generally we only need one visual, as our screen can only
 * handle one format at a time, I believe.  You may want
 * to verify that last sentence.
 */

static Bool
winInitVisualsPrimaryDD(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    DWORD dwRedBits, dwGreenBits, dwBlueBits;

    /* Count the number of ones in each color mask */
    dwRedBits = winCountBits(pScreenPriv->dwRedMask);
    dwGreenBits = winCountBits(pScreenPriv->dwGreenMask);
    dwBlueBits = winCountBits(pScreenPriv->dwBlueMask);

    /* Store the maximum number of ones in a color mask as the bitsPerRGB */
    if (dwRedBits > dwGreenBits && dwRedBits > dwBlueBits)
        pScreenPriv->dwBitsPerRGB = dwRedBits;
    else if (dwGreenBits > dwRedBits && dwGreenBits > dwBlueBits)
        pScreenPriv->dwBitsPerRGB = dwGreenBits;
    else
        pScreenPriv->dwBitsPerRGB = dwBlueBits;

    ErrorF("winInitVisualsPrimaryDD - Masks: %08x %08x %08x bpRGB: %d\n",
           (unsigned int) pScreenPriv->dwRedMask,
           (unsigned int) pScreenPriv->dwGreenMask,
           (unsigned int) pScreenPriv->dwBlueMask,
           (int) pScreenPriv->dwBitsPerRGB);

    /* Create a single visual according to the Windows screen depth */
    switch (pScreenInfo->dwDepth) {
    case 24:
    case 16:
    case 15:
        if (!miSetVisualTypesAndMasks(pScreenInfo->dwDepth,
                                      TrueColorMask,
                                      pScreenPriv->dwBitsPerRGB,
                                      TrueColor,
                                      pScreenPriv->dwRedMask,
                                      pScreenPriv->dwGreenMask,
                                      pScreenPriv->dwBlueMask)) {
            ErrorF("winInitVisualsPrimaryDD - "
                   "miSetVisualTypesAndMasks failed\n");
            return FALSE;
        }
        break;

    case 8:
#if CYGDEBUG
        winDebug("winInitVisuals - Calling miSetVisualTypesAndMasks\n");
#endif                          /* CYGDEBUG */
        if (!miSetVisualTypesAndMasks(pScreenInfo->dwDepth,
                                      PseudoColorMask,
                                      pScreenPriv->dwBitsPerRGB,
                                      PseudoColor,
                                      pScreenPriv->dwRedMask,
                                      pScreenPriv->dwGreenMask,
                                      pScreenPriv->dwBlueMask)) {
            ErrorF("winInitVisualsPrimaryDD - "
                   "miSetVisualTypesAndMasks failed\n");
            return FALSE;
        }
#if CYGDEBUG
        winDebug("winInitVisualsPrimaryDD - Returned from "
                 "miSetVisualTypesAndMasks\n");
#endif                          /* CYGDEBUG */
        break;

    default:
        ErrorF("winInitVisualsPrimaryDD - Unknown screen depth\n");
        return FALSE;
    }

    ErrorF("winInitVisualsPrimaryDD - Returning\n");

    return TRUE;
}

static Bool
winAdjustVideoModePrimaryDD(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    HDC hdc = NULL;
    DWORD dwBPP;

    /* We're in serious trouble if we can't get a DC */
    hdc = GetDC(NULL);
    if (hdc == NULL) {
        ErrorF("winAdjustVideoModePrimaryDD - GetDC failed\n");
        return FALSE;
    }

    /* Query GDI for current display depth */
    dwBPP = GetDeviceCaps(hdc, BITSPIXEL);

    /* DirectDraw can only change the depth in fullscreen mode */
    if (!(pScreenInfo->fFullScreen && (pScreenInfo->dwBPP != WIN_DEFAULT_BPP))) {
        /* Otherwise, We'll use GDI's depth */
        pScreenInfo->dwBPP = dwBPP;
    }

    /* Release our DC */
    ReleaseDC(NULL, hdc);

    return TRUE;
}

/*
 * We need to blit our offscreen fb to
 * the screen when we are activated, and we need to point
 * the fb code back to the primary surface memory.
 */

static Bool
winActivateAppPrimaryDD(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    RECT rcSrc, rcClient;
    HRESULT ddrval = DD_OK;

    /* Check for errors */
    if (pScreenPriv == NULL
        || pScreenPriv->pScreenInfo == NULL
        || pScreenPriv->pddsPrimary == NULL
        || pScreenPriv->pddsOffscreen == NULL)
        return FALSE;

    /* Check for do-nothing */
    if (!pScreenPriv->fActive)
        return TRUE;

    /* We are activating */
    ddrval = IDirectDrawSurface2_IsLost(pScreenPriv->pddsOffscreen);
    if (ddrval == DD_OK) {
        IDirectDrawSurface2_Unlock(pScreenPriv->pddsOffscreen, NULL);
        /*
         * We don't check for an error from Unlock, because it
         * doesn't matter if the Unlock failed.
         */
    }

    /* Restore both surfaces, just cause I like it that way */
    IDirectDrawSurface2_Restore(pScreenPriv->pddsOffscreen);
    IDirectDrawSurface2_Restore(pScreenPriv->pddsPrimary);

    /* Get client area in screen coords */
    GetClientRect(pScreenPriv->hwndScreen, &rcClient);
    MapWindowPoints(pScreenPriv->hwndScreen,
                    HWND_DESKTOP, (LPPOINT) &rcClient, 2);

    /* Setup a source rectangle */
    rcSrc.left = 0;
    rcSrc.top = 0;
    rcSrc.right = pScreenPriv->pScreenInfo->dwWidth;
    rcSrc.bottom = pScreenPriv->pScreenInfo->dwHeight;

    ddrval = IDirectDrawSurface2_Blt(pScreenPriv->pddsPrimary,
                                     &rcClient,
                                     pScreenPriv->pddsOffscreen,
                                     &rcSrc, DDBLT_WAIT, NULL);
    if (ddrval != DD_OK)
        FatalError("winActivateAppPrimaryDD () - Failed blitting offscreen "
                   "surface to primary surface %08x\n", (unsigned int) ddrval);

    /* Lock the primary surface */
    ddrval = IDirectDrawSurface2_Lock(pScreenPriv->pddsPrimary,
                                      &rcClient,
                                      pScreenPriv->pddsdPrimary,
                                      DDLOCK_WAIT, NULL);
    if (ddrval != DD_OK || pScreenPriv->pddsdPrimary->lpSurface == NULL)
        FatalError("winActivateAppPrimaryDD () - Could not lock "
                   "primary surface\n");

    /* Notify FB of the new memory pointer */
    winUpdateFBPointer(pScreen, pScreenPriv->pddsdPrimary->lpSurface);

    /*
     * Register the Alt-Tab combo as a hotkey so we can copy
     * the primary framebuffer before the display mode changes
     */
    RegisterHotKey(pScreenPriv->hwndScreen, 1, MOD_ALT, 9);

    return TRUE;
}

/*
 * Handle the Alt+Tab hotkey.
 *
 * We need to save the primary fb to an offscreen fb when
 * we get deactivated, and point the fb code at the offscreen
 * fb for the duration of the deactivation.
 */

static Bool
winHotKeyAltTabPrimaryDD(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    HRESULT ddrval = DD_OK;

    ErrorF("\nwinHotKeyAltTabPrimaryDD\n\n");

    /* Alt+Tab was pressed, we will lose focus very soon */
    pScreenPriv->fActive = FALSE;

    /* Check for error conditions */
    if (pScreenPriv->pddsPrimary == NULL || pScreenPriv->pddsOffscreen == NULL)
        return FALSE;

    /* Did we loose the primary surface? */
    ddrval = IDirectDrawSurface2_IsLost(pScreenPriv->pddsPrimary);
    if (ddrval == DD_OK) {
        ddrval = IDirectDrawSurface2_Unlock(pScreenPriv->pddsPrimary, NULL);
        if (FAILED(ddrval))
            FatalError("winHotKeyAltTabPrimaryDD - Failed unlocking primary "
                       "surface\n");
    }

    /* Blit the primary surface to the offscreen surface */
    ddrval = IDirectDrawSurface2_Blt(pScreenPriv->pddsOffscreen, NULL,  /* should be rcDest */
                                     pScreenPriv->pddsPrimary,
                                     NULL, DDBLT_WAIT, NULL);
    if (ddrval == DDERR_SURFACELOST) {
        IDirectDrawSurface2_Restore(pScreenPriv->pddsOffscreen);
        IDirectDrawSurface2_Restore(pScreenPriv->pddsPrimary);

        /* Blit the primary surface to the offscreen surface */
        ddrval = IDirectDrawSurface2_Blt(pScreenPriv->pddsOffscreen,
                                         NULL,
                                         pScreenPriv->pddsPrimary,
                                         NULL, DDBLT_WAIT, NULL);
        if (FAILED(ddrval))
            FatalError("winHotKeyAltTabPrimaryDD - Failed blitting primary "
                       "surface to offscreen surface: %08x\n",
                       (unsigned int) ddrval);
    }
    else {
        FatalError("winHotKeyAltTabPrimaryDD - Unknown error from "
                   "Blt: %08dx\n", (unsigned int) ddrval);
    }

    /* Lock the offscreen surface */
    ddrval = IDirectDrawSurface2_Lock(pScreenPriv->pddsOffscreen,
                                      NULL,
                                      pScreenPriv->pddsdOffscreen,
                                      DDLOCK_WAIT, NULL);
    if (ddrval != DD_OK || pScreenPriv->pddsdPrimary->lpSurface == NULL)
        FatalError("winHotKeyAltTabPrimaryDD - Could not lock "
                   "offscreen surface\n");

    /* Notify FB of the new memory pointer */
    winUpdateFBPointer(pScreen, pScreenPriv->pddsdOffscreen->lpSurface);

    /* Unregister our hotkey */
    UnregisterHotKey(pScreenPriv->hwndScreen, 1);

    return TRUE;
}

/* Set engine specific functions */
Bool
winSetEngineFunctionsPrimaryDD(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Set our pointers */
    pScreenPriv->pwinAllocateFB = winAllocateFBPrimaryDD;
    pScreenPriv->pwinFreeFB = winFreeFBPrimaryDD;
    pScreenPriv->pwinShadowUpdate =
        (winShadowUpdateProcPtr) (void (*)(void)) NoopDDA;
    pScreenPriv->pwinInitScreen = winInitScreenPrimaryDD;
    pScreenPriv->pwinCloseScreen = winCloseScreenPrimaryDD;
    pScreenPriv->pwinInitVisuals = winInitVisualsPrimaryDD;
    pScreenPriv->pwinAdjustVideoMode = winAdjustVideoModePrimaryDD;
    if (pScreenInfo->fFullScreen)
        pScreenPriv->pwinCreateBoundingWindow =
            winCreateBoundingWindowFullScreen;
    else
        pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowWindowed;
    pScreenPriv->pwinFinishScreenInit = winFinishScreenInitFB;
    pScreenPriv->pwinBltExposedRegions =
        (winBltExposedRegionsProcPtr) (void (*)(void)) NoopDDA;
    pScreenPriv->pwinActivateApp = winActivateAppPrimaryDD;
    pScreenPriv->pwinRedrawScreen = NULL;
    pScreenPriv->pwinRealizeInstalledPalette = NULL;
    pScreenPriv->pwinInstallColormap = NULL;
    pScreenPriv->pwinStoreColors = NULL;
    pScreenPriv->pwinCreateColormap = NULL;
    pScreenPriv->pwinDestroyColormap = NULL;
    pScreenPriv->pwinHotKeyAltTab = winHotKeyAltTabPrimaryDD;
    pScreenPriv->pwinCreatePrimarySurface =
        (winCreatePrimarySurfaceProcPtr) (void (*)(void)) NoopDDA;
    pScreenPriv->pwinReleasePrimarySurface =
        (winReleasePrimarySurfaceProcPtr) (void (*)(void)) NoopDDA;
#ifdef XWIN_MULTIWINDOW
    pScreenPriv->pwinFinishCreateWindowsWindow =
        (winFinishCreateWindowsWindowProcPtr) (void (*)(void)) NoopDDA;
#endif

    return TRUE;
}
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@@


1.5
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d309 1
a309 1
    free((pointer) pScreenPriv);
@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a516 2
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    RECT rcClient, rcSrc;
a527 5
    /* Get client area in screen coords */
    GetClientRect(pScreenPriv->hwndScreen, &rcClient);
    MapWindowPoints(pScreenPriv->hwndScreen,
                    HWND_DESKTOP, (LPPOINT) &rcClient, 2);

a535 6

    /* Setup a source rectangle */
    rcSrc.left = 0;
    rcSrc.top = 0;
    rcSrc.right = pScreenInfo->dwWidth;
    rcSrc.bottom = pScreenInfo->dwHeight;
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d47 1
a47 1
 winCloseScreenPrimaryDD(int nIndex, ScreenPtr pScreen);
d81 1
a81 1
                    HWND_DESKTOP, (LPPOINT) & rcClient, 2);
d91 1
a91 1
                                        (LPVOID *) & pScreenPriv->pdd2);
d267 1
a267 1
winCloseScreenPrimaryDD(int nIndex, ScreenPtr pScreen)
d282 1
a282 1
        fReturn = (*pScreen->CloseScreen) (nIndex, pScreen);
d468 1
a468 1
                    HWND_DESKTOP, (LPPOINT) & rcClient, 2);
d533 1
a533 1
                    HWND_DESKTOP, (LPPOINT) & rcClient, 2);
@


1.2
log
@Update to xserver 1.11.2
@
text
@a38 1

d44 1
a44 1
winAllocateFBPrimaryDD (ScreenPtr pScreen);
d47 1
a47 1
winCloseScreenPrimaryDD (int nIndex, ScreenPtr pScreen);
d50 1
a50 1
winInitVisualsPrimaryDD (ScreenPtr pScreen);
d53 1
a53 1
winAdjustVideoModePrimaryDD (ScreenPtr pScreen);
d56 1
a56 1
winActivateAppPrimaryDD (ScreenPtr pScreen);
d59 1
a59 2
winHotKeyAltTabPrimaryDD (ScreenPtr pScreen);

d66 1
a66 1
winAllocateFBPrimaryDD (ScreenPtr pScreen)
d68 149
a216 160
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;  
  HRESULT		ddrval = DD_OK;
  DDSURFACEDESC		ddsd;
  DDSURFACEDESC		*pddsdPrimary = NULL;
  DDSURFACEDESC		*pddsdOffscreen = NULL;
  RECT			rcClient;

  ErrorF ("winAllocateFBPrimaryDD\n");

  /* Get client area location in screen coords */
  GetClientRect (pScreenPriv->hwndScreen, &rcClient);
  MapWindowPoints (pScreenPriv->hwndScreen,
		   HWND_DESKTOP,
		   (LPPOINT)&rcClient, 2);

  /* Create a DirectDraw object, store the address at lpdd */
  ddrval = (*g_fpDirectDrawCreate) (NULL, &pScreenPriv->pdd, NULL);
  if (ddrval != DD_OK)
    FatalError ("winAllocateFBPrimaryDD - Could not start DirectDraw\n");
  
  /* Get a DirectDraw2 interface pointer */
  ddrval = IDirectDraw_QueryInterface (pScreenPriv->pdd,
				       &IID_IDirectDraw2,
				       (LPVOID*) &pScreenPriv->pdd2);
  if (FAILED (ddrval))
    {
      ErrorF ("winAllocateFBShadowDD - Failed DD2 query: %08x\n",
	      (unsigned int) ddrval);
      return FALSE;
    }


  ErrorF ("winAllocateFBPrimaryDD - Created and initialized DD\n");

  /* Are we windowed or fullscreen? */
  if (pScreenInfo->fFullScreen)
    {
      /* Full screen mode */
      ddrval = IDirectDraw2_SetCooperativeLevel (pScreenPriv->pdd2,
						 pScreenPriv->hwndScreen,
						 DDSCL_FULLSCREEN
						 | DDSCL_EXCLUSIVE);
      if (FAILED (ddrval))
	FatalError ("winAllocateFBPrimaryDD - Could not set "
		    "cooperative level\n");

      /* Change the video mode to the mode requested */
      ddrval = IDirectDraw2_SetDisplayMode (pScreenPriv->pdd2,
					    pScreenInfo->dwWidth,
					    pScreenInfo->dwHeight,
					    pScreenInfo->dwBPP,
					    pScreenInfo->dwRefreshRate,
					    0);
       if (FAILED (ddrval))
	FatalError ("winAllocateFBPrimaryDD - Could not set "
		    "full screen display mode\n");
    }
  else
    {
      /* Windowed mode */
      ddrval = IDirectDraw2_SetCooperativeLevel (pScreenPriv->pdd2,
						 pScreenPriv->hwndScreen,
						 DDSCL_NORMAL);
      if (FAILED (ddrval))
	FatalError ("winAllocateFBPrimaryDD - Could not set "
		    "cooperative level\n");
    }

  /* Describe the primary surface */
  ZeroMemory (&ddsd, sizeof (ddsd));
  ddsd.dwSize = sizeof (ddsd);
  ddsd.dwFlags = DDSD_CAPS;
  ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
  
  /* Create the primary surface */
  ddrval = IDirectDraw2_CreateSurface (pScreenPriv->pdd2,
				       &ddsd,
				       &pScreenPriv->pddsPrimary,
				       NULL);
  if (FAILED (ddrval))
       FatalError ("winAllocateFBPrimaryDD - Could not create primary "
		  "surface %08x\n", (unsigned int) ddrval);

  ErrorF ("winAllocateFBPrimaryDD - Created primary\n");

  /* Allocate a DD surface description for our screen privates */
  pddsdPrimary = pScreenPriv->pddsdPrimary
    = malloc (sizeof (DDSURFACEDESC));
  if (pddsdPrimary == NULL)
    FatalError ("winAllocateFBPrimaryDD - Could not allocate surface "
		"description memory\n");
  ZeroMemory (pddsdPrimary, sizeof (*pddsdPrimary));
  pddsdPrimary->dwSize = sizeof (*pddsdPrimary);

  /* Describe the offscreen surface to be created */
  /*
   * NOTE: Do not use a DDSCAPS_VIDEOMEMORY surface,
   * as drawing, locking, and unlocking take forever
   * with video memory surfaces.  In addition,
   * video memory is a somewhat scarce resource,
   * so you shouldn't be allocating video memory when
   * you have the option of using system memory instead.
   */
  ZeroMemory (&ddsd, sizeof (ddsd));
  ddsd.dwSize = sizeof (ddsd);
  ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
  ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
  ddsd.dwHeight = pScreenInfo->dwHeight;
  ddsd.dwWidth = pScreenInfo->dwWidth;

  /* Create the shadow surface */
  ddrval = IDirectDraw2_CreateSurface (pScreenPriv->pdd2,
				       &ddsd,
				       &pScreenPriv->pddsOffscreen,
				       NULL);
  if (ddrval != DD_OK)
    FatalError ("winAllocateFBPrimaryDD - Could not create shadow "
		"surface\n");
  
  ErrorF ("winAllocateFBPrimaryDD - Created offscreen\n");

  /* Allocate a DD surface description for our screen privates */
  pddsdOffscreen = pScreenPriv->pddsdOffscreen
    = malloc (sizeof (DDSURFACEDESC));
  if (pddsdOffscreen == NULL)
    FatalError ("winAllocateFBPrimaryDD - Could not allocate surface "
		"description memory\n");
  ZeroMemory (pddsdOffscreen, sizeof (*pddsdOffscreen));
  pddsdOffscreen->dwSize = sizeof (*pddsdOffscreen);

  ErrorF ("winAllocateFBPrimaryDD - Locking primary\n");

  /* Lock the primary surface */
  ddrval = IDirectDrawSurface2_Lock (pScreenPriv->pddsPrimary,
				    pScreenInfo->fFullScreen ? NULL:&rcClient,
				    pddsdPrimary,
				    DDLOCK_WAIT,
				    NULL);
  if (ddrval != DD_OK || pddsdPrimary->lpSurface == NULL)
    FatalError ("winAllocateFBPrimaryDD - Could not lock "
		"primary surface\n");

  ErrorF ("winAllocateFBPrimaryDD - Locked primary\n");

  /* We don't know how to deal with anything other than RGB */
  if (!(pddsdPrimary->ddpfPixelFormat.dwFlags & DDPF_RGB))
    FatalError ("winAllocateFBPrimaryDD - Color format other than RGB\n");

  /* Grab the pitch from the surface desc */
  pScreenInfo->dwStride = (pddsdPrimary->u1.lPitch * 8)
    / pScreenInfo->dwBPP;

  /* Save the pointer to our surface memory */
  pScreenInfo->pfb = pddsdPrimary->lpSurface;
  
  /* Grab the color depth and masks from the surface description */
  pScreenPriv->dwRedMask = pddsdPrimary->ddpfPixelFormat.u2.dwRBitMask;
  pScreenPriv->dwGreenMask = pddsdPrimary->ddpfPixelFormat.u3.dwGBitMask;
  pScreenPriv->dwBlueMask = pddsdPrimary->ddpfPixelFormat.u4.dwBBitMask;
d218 1
a218 1
  ErrorF ("winAllocateFBPrimaryDD - Returning\n");
d220 1
a220 1
  return TRUE;
d224 1
a224 1
winFreeFBPrimaryDD (ScreenPtr pScreen)
d226 16
a241 2
  winScreenPriv(pScreen);
  winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
d243 5
a247 22
  /* Free the offscreen surface, if there is one */
  if (pScreenPriv->pddsOffscreen)
    {
      IDirectDrawSurface2_Unlock (pScreenPriv->pddsOffscreen, NULL);
      IDirectDrawSurface2_Release (pScreenPriv->pddsOffscreen);
      pScreenPriv->pddsOffscreen = NULL;
    }

  /* Release the primary surface, if there is one */
  if (pScreenPriv->pddsPrimary)
    {
      IDirectDrawSurface2_Unlock (pScreenPriv->pddsPrimary, NULL);
      IDirectDrawSurface2_Release (pScreenPriv->pddsPrimary);
      pScreenPriv->pddsPrimary = NULL;
    }

  /* Free the DirectDraw object, if there is one */
  if (pScreenPriv->pdd)
    {
      IDirectDraw2_RestoreDisplayMode (pScreenPriv->pdd);
      IDirectDraw2_Release (pScreenPriv->pdd);
      pScreenPriv->pdd = NULL;
d250 2
a251 2
  /* Invalidate the ScreenInfo's fb pointer */
  pScreenInfo->pfb = NULL;
d257 1
a257 1
  return winAllocateFBPrimaryDD(pScreen);
d267 1
a267 1
winCloseScreenPrimaryDD (int nIndex, ScreenPtr pScreen)
d269 3
a271 5
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  Bool			fReturn;
  
  ErrorF ("winCloseScreenPrimaryDD - Freeing screen resources\n");
d273 1
a273 3
  /* Flag that the screen is closed */
  pScreenPriv->fClosed = TRUE;
  pScreenPriv->fActive = FALSE;
d275 3
a277 4
  /* Call the wrapped CloseScreen procedure */
  WIN_UNWRAP(CloseScreen);
  if (pScreen->CloseScreen)
    fReturn = (*pScreen->CloseScreen) (nIndex, pScreen);
d279 4
a282 2
  /* Delete the window property */
  RemoveProp (pScreenPriv->hwndScreen, WIN_SCR_PROP);
d284 2
a285 1
  winFreeFBPrimaryDD(pScreen);
d287 1
a287 3
  /* Delete tray icon, if we have one */
  if (!pScreenInfo->fNoTrayIcon)
    winDeleteNotifyIcon (pScreenPriv);
d289 8
a296 5
  /* Free the exit confirmation dialog box, if it exists */
  if (g_hDlgExit != NULL)
    {
      DestroyWindow (g_hDlgExit);
      g_hDlgExit = NULL;
d299 4
a302 5
  /* Kill our window */
  if (pScreenPriv->hwndScreen)
    {
      DestroyWindow (pScreenPriv->hwndScreen);
      pScreenPriv->hwndScreen = NULL;
d305 2
a306 2
  /* Kill our screeninfo's pointer to the screen */
  pScreenInfo->pScreen = NULL;
d308 2
a309 2
  /* Free the screen privates for this screen */
  free ((pointer) pScreenPriv);
d311 1
a311 1
  return fReturn;
a313 1

d323 1
a323 1
winInitVisualsPrimaryDD (ScreenPtr pScreen)
d325 25
a349 26
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  DWORD			dwRedBits, dwGreenBits, dwBlueBits;

  /* Count the number of ones in each color mask */
  dwRedBits = winCountBits (pScreenPriv->dwRedMask);
  dwGreenBits = winCountBits (pScreenPriv->dwGreenMask);
  dwBlueBits = winCountBits (pScreenPriv->dwBlueMask);
  
  /* Store the maximum number of ones in a color mask as the bitsPerRGB */
  if (dwRedBits > dwGreenBits && dwRedBits > dwBlueBits)
    pScreenPriv->dwBitsPerRGB = dwRedBits;
  else if (dwGreenBits > dwRedBits && dwGreenBits > dwBlueBits)
    pScreenPriv->dwBitsPerRGB = dwGreenBits;
  else
    pScreenPriv->dwBitsPerRGB = dwBlueBits;
  
  ErrorF ("winInitVisualsPrimaryDD - Masks: %08x %08x %08x bpRGB: %d\n",
	  (unsigned int) pScreenPriv->dwRedMask,
	  (unsigned int) pScreenPriv->dwGreenMask,
	  (unsigned int) pScreenPriv->dwBlueMask,
	  (int) pScreenPriv->dwBitsPerRGB);

  /* Create a single visual according to the Windows screen depth */
  switch (pScreenInfo->dwDepth)
    {
d353 12
a364 13
      if (!miSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     TrueColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     TrueColor,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsPrimaryDD - " 
		  "miSetVisualTypesAndMasks failed\n");
	  return FALSE;
	}
      break;
d368 13
a380 14
      winDebug ("winInitVisuals - Calling miSetVisualTypesAndMasks\n");
#endif /* CYGDEBUG */
      if (!miSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     PseudoColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     PseudoColor,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsPrimaryDD - "
		  "miSetVisualTypesAndMasks failed\n");
	  return FALSE;
	}
d382 4
a385 4
      winDebug ("winInitVisualsPrimaryDD - Returned from "
	      "miSetVisualTypesAndMasks\n");
#endif /* CYGDEBUG */
      break;
d388 2
a389 2
      ErrorF ("winInitVisualsPrimaryDD - Unknown screen depth\n");
      return FALSE;
d392 1
a392 1
  ErrorF ("winInitVisualsPrimaryDD - Returning\n");
d394 1
a394 1
  return TRUE;
a396 1

d398 1
a398 1
winAdjustVideoModePrimaryDD (ScreenPtr pScreen)
d400 10
a409 22
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  HDC			hdc = NULL;
  DWORD			dwBPP;

  /* We're in serious trouble if we can't get a DC */
  hdc = GetDC (NULL);
  if (hdc == NULL)
    {
      ErrorF ("winAdjustVideoModePrimaryDD - GetDC failed\n");
      return FALSE;
    }

  /* Query GDI for current display depth */
  dwBPP = GetDeviceCaps (hdc, BITSPIXEL);

  /* DirectDraw can only change the depth in fullscreen mode */
  if (!(pScreenInfo->fFullScreen &&
        (pScreenInfo->dwBPP != WIN_DEFAULT_BPP)))
    {
      /* Otherwise, We'll use GDI's depth */
      pScreenInfo->dwBPP = dwBPP;
d412 2
a413 2
  /* Release our DC */
  ReleaseDC (NULL, hdc);
d415 10
a424 1
  return TRUE;
a426 1

d434 1
a434 1
winActivateAppPrimaryDD (ScreenPtr pScreen)
d436 65
a500 10
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  RECT			rcSrc, rcClient;
  HRESULT		ddrval = DD_OK;

  /* Check for errors */
  if (pScreenPriv == NULL
      || pScreenPriv->pddsPrimary == NULL
      || pScreenPriv->pddsOffscreen == NULL)
    return FALSE;
a501 2
  /* Check for do-nothing */
  if (!pScreenPriv->fActive)
a502 61
  
  /* We are activating */
  ddrval = IDirectDrawSurface2_IsLost (pScreenPriv->pddsOffscreen);
  if (ddrval == DD_OK)
    {
      IDirectDrawSurface2_Unlock (pScreenPriv->pddsOffscreen,
				  NULL);
      /*
       * We don't check for an error from Unlock, because it
       * doesn't matter if the Unlock failed.
       */
    }

  /* Restore both surfaces, just cause I like it that way */
  IDirectDrawSurface2_Restore (pScreenPriv->pddsOffscreen);
  IDirectDrawSurface2_Restore (pScreenPriv->pddsPrimary);
			      
  /* Get client area in screen coords */
  GetClientRect (pScreenPriv->hwndScreen, &rcClient);
  MapWindowPoints (pScreenPriv->hwndScreen,
		   HWND_DESKTOP,
		   (LPPOINT)&rcClient, 2);

  /* Setup a source rectangle */
  rcSrc.left = 0;
  rcSrc.top = 0;
  rcSrc.right = pScreenInfo->dwWidth;
  rcSrc.bottom = pScreenInfo->dwHeight;

  ddrval = IDirectDrawSurface2_Blt (pScreenPriv->pddsPrimary,
				    &rcClient,
				    pScreenPriv->pddsOffscreen,
				    &rcSrc,
				    DDBLT_WAIT,
				    NULL);
  if (ddrval != DD_OK)
    FatalError ("winActivateAppPrimaryDD () - Failed blitting offscreen "
		"surface to primary surface %08x\n", (unsigned int) ddrval);
  
  /* Lock the primary surface */
  ddrval = IDirectDrawSurface2_Lock (pScreenPriv->pddsPrimary,
				     &rcClient,
				     pScreenPriv->pddsdPrimary,
				     DDLOCK_WAIT,
				     NULL);
  if (ddrval != DD_OK
      || pScreenPriv->pddsdPrimary->lpSurface == NULL)
    FatalError ("winActivateAppPrimaryDD () - Could not lock "
		"primary surface\n");

  /* Notify FB of the new memory pointer */
  winUpdateFBPointer (pScreen,
		      pScreenPriv->pddsdPrimary->lpSurface);

  /*
   * Register the Alt-Tab combo as a hotkey so we can copy
   * the primary framebuffer before the display mode changes
   */
  RegisterHotKey (pScreenPriv->hwndScreen, 1, MOD_ALT, 9);

  return TRUE;
a504 1

d514 1
a514 1
winHotKeyAltTabPrimaryDD (ScreenPtr pScreen)
d516 68
a583 82
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  RECT			rcClient, rcSrc;
  HRESULT		ddrval = DD_OK;

  ErrorF ("\nwinHotKeyAltTabPrimaryDD\n\n");

  /* Alt+Tab was pressed, we will lose focus very soon */
  pScreenPriv->fActive = FALSE;
  
  /* Check for error conditions */
  if (pScreenPriv->pddsPrimary == NULL
      || pScreenPriv->pddsOffscreen == NULL)
    return FALSE;

  /* Get client area in screen coords */
  GetClientRect (pScreenPriv->hwndScreen, &rcClient);
  MapWindowPoints (pScreenPriv->hwndScreen,
		   HWND_DESKTOP,
		   (LPPOINT)&rcClient, 2);

  /* Did we loose the primary surface? */
  ddrval = IDirectDrawSurface2_IsLost (pScreenPriv->pddsPrimary);
  if (ddrval == DD_OK)
    {
      ddrval = IDirectDrawSurface2_Unlock (pScreenPriv->pddsPrimary,
					   NULL);
      if (FAILED (ddrval))
	FatalError ("winHotKeyAltTabPrimaryDD - Failed unlocking primary "
		    "surface\n");
    }

  /* Setup a source rectangle */
  rcSrc.left = 0;
  rcSrc.top = 0;
  rcSrc.right = pScreenInfo->dwWidth;
  rcSrc.bottom = pScreenInfo->dwHeight;

      /* Blit the primary surface to the offscreen surface */
  ddrval = IDirectDrawSurface2_Blt (pScreenPriv->pddsOffscreen,
				    NULL, /* should be rcDest */
				    pScreenPriv->pddsPrimary,
				    NULL,
				    DDBLT_WAIT,
				    NULL);
  if (ddrval == DDERR_SURFACELOST)
    {
      IDirectDrawSurface2_Restore (pScreenPriv->pddsOffscreen);  
      IDirectDrawSurface2_Restore (pScreenPriv->pddsPrimary);
		  		  
      /* Blit the primary surface to the offscreen surface */
      ddrval = IDirectDrawSurface2_Blt (pScreenPriv->pddsOffscreen,
					NULL,
					pScreenPriv->pddsPrimary,
					NULL,
					DDBLT_WAIT,
					NULL);
      if (FAILED (ddrval))
	FatalError ("winHotKeyAltTabPrimaryDD - Failed blitting primary "
		    "surface to offscreen surface: %08x\n",
		    (unsigned int) ddrval);
    }
  else
    {
      FatalError ("winHotKeyAltTabPrimaryDD - Unknown error from "
		  "Blt: %08dx\n", (unsigned int) ddrval);
    }

  /* Lock the offscreen surface */
  ddrval = IDirectDrawSurface2_Lock (pScreenPriv->pddsOffscreen,
				     NULL,
				     pScreenPriv->pddsdOffscreen,
				     DDLOCK_WAIT,
				     NULL);
  if (ddrval != DD_OK
      || pScreenPriv->pddsdPrimary->lpSurface == NULL)
    FatalError ("winHotKeyAltTabPrimaryDD - Could not lock "
		"offscreen surface\n");

  /* Notify FB of the new memory pointer */
  winUpdateFBPointer (pScreen,
		      pScreenPriv->pddsdOffscreen->lpSurface);
d585 2
a586 2
  /* Unregister our hotkey */
  UnregisterHotKey (pScreenPriv->hwndScreen, 1);
d588 1
a588 1
  return TRUE;
a590 1

d593 1
a593 1
winSetEngineFunctionsPrimaryDD (ScreenPtr pScreen)
d595 32
a626 27
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  
  /* Set our pointers */
  pScreenPriv->pwinAllocateFB = winAllocateFBPrimaryDD;
  pScreenPriv->pwinFreeFB = winFreeFBPrimaryDD;
  pScreenPriv->pwinShadowUpdate = (winShadowUpdateProcPtr) (void (*)(void))NoopDDA;
  pScreenPriv->pwinInitScreen = winInitScreenPrimaryDD;
  pScreenPriv->pwinCloseScreen = winCloseScreenPrimaryDD;
  pScreenPriv->pwinInitVisuals = winInitVisualsPrimaryDD;
  pScreenPriv->pwinAdjustVideoMode = winAdjustVideoModePrimaryDD;
  if (pScreenInfo->fFullScreen)
    pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowFullScreen;
  else
    pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowWindowed;
  pScreenPriv->pwinFinishScreenInit = winFinishScreenInitFB;
  pScreenPriv->pwinBltExposedRegions = (winBltExposedRegionsProcPtr) (void (*)(void))NoopDDA;
  pScreenPriv->pwinActivateApp = winActivateAppPrimaryDD;
  pScreenPriv->pwinRedrawScreen = NULL;
  pScreenPriv->pwinRealizeInstalledPalette = NULL;
  pScreenPriv->pwinInstallColormap = NULL;
  pScreenPriv->pwinStoreColors = NULL;
  pScreenPriv->pwinCreateColormap = NULL;
  pScreenPriv->pwinDestroyColormap = NULL;
  pScreenPriv->pwinHotKeyAltTab = winHotKeyAltTabPrimaryDD;
  pScreenPriv->pwinCreatePrimarySurface = (winCreatePrimarySurfaceProcPtr) (void (*)(void))NoopDDA;
  pScreenPriv->pwinReleasePrimarySurface = (winReleasePrimarySurfaceProcPtr) (void (*)(void))NoopDDA;
d628 2
a629 2
  pScreenPriv->pwinFinishCreateWindowsWindow =
    (winFinishCreateWindowsWindowProcPtr) (void (*)(void))NoopDDA;
d632 1
a632 1
  return TRUE;
@


1.1
log
@Initial revision
@
text
@a40 8
 * External symbols
 */

extern const GUID		_IID_IDirectDraw2;
extern HWND			g_hDlgExit;


/*
d236 39
d297 2
a298 1
  fReturn = (*pScreen->CloseScreen) (nIndex, pScreen);
d303 1
a303 23
  /* Free the offscreen surface, if there is one */
  if (pScreenPriv->pddsOffscreen)
    {
      IDirectDrawSurface2_Unlock (pScreenPriv->pddsOffscreen, NULL);
      IDirectDrawSurface2_Release (pScreenPriv->pddsOffscreen);
      pScreenPriv->pddsOffscreen = NULL;
    }

  /* Release the primary surface, if there is one */
  if (pScreenPriv->pddsPrimary)
    {
      IDirectDrawSurface2_Unlock (pScreenPriv->pddsPrimary, NULL);
      IDirectDrawSurface2_Release (pScreenPriv->pddsPrimary);
      pScreenPriv->pddsPrimary = NULL;
    }

  /* Free the DirectDraw object, if there is one */
  if (pScreenPriv->pdd)
    {
      IDirectDraw2_RestoreDisplayMode (pScreenPriv->pdd);
      IDirectDraw2_Release (pScreenPriv->pdd);
      pScreenPriv->pdd = NULL;
    }
a325 3
  /* Invalidate the ScreenInfo's fb pointer */
  pScreenInfo->pfb = NULL;

d440 2
a441 1
  if (pScreenInfo->dwBPP == WIN_DEFAULT_BPP)
d443 1
a443 5
      /* No -depth parameter passed, let the user know the depth being used */
      ErrorF ("winAdjustVideoModePrimaryDD - Using Windows display "
	      "depth of %d bits per pixel\n", (int) dwBPP);

      /* Use GDI's depth */
a445 13
  else if (pScreenInfo->fFullScreen
	   && pScreenInfo->dwBPP != dwBPP)
    {
      /* FullScreen, and GDI depth differs from -depth parameter */
      ErrorF ("winAdjustVideoModePrimaryDD - FullScreen, using command "
	      "line depth: %d\n", (int) pScreenInfo->dwBPP);
    }
  else if (dwBPP != pScreenInfo->dwBPP)
    {
      /* Windowed, and GDI depth differs from -depth parameter */
      ErrorF ("winAdjustVideoModePrimaryDD - Windowed, command line "
	      "depth: %d, using depth: %d\n",
	      (int) pScreenInfo->dwBPP, (int) dwBPP);
a446 4
      /* We'll use GDI's depth */
      pScreenInfo->dwBPP = dwBPP;
    }
  
d651 3
a653 2
  pScreenPriv->pwinShadowUpdate
    = (winShadowUpdateProcPtr) (void (*)(void))NoopDDA;
d662 1
a662 2
  pScreenPriv->pwinBltExposedRegions
    = (winBltExposedRegionsProcPtr) (void (*)(void))NoopDDA;
d664 6
d671 2
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
