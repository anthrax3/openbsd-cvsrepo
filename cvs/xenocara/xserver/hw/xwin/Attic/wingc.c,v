head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.24;	author matthieu;	state dead;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *Copyright (C) 2001-2004 Harold L Hunt II All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL HAROLD L HUNT II BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of Harold L Hunt II
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from Harold L Hunt II.
 *
 * Authors:	Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

/*
 * Local prototypes
 */

#if 0
static void
 winChangeGCNativeGDI(GCPtr pGC, unsigned long ulChanges);
#endif

static void

winValidateGCNativeGDI(GCPtr pGC, unsigned long changes, DrawablePtr pDrawable);

#if 0
static void
 winCopyGCNativeGDI(GCPtr pGCsrc, unsigned long ulMask, GCPtr pGCdst);
#endif

static void
 winDestroyGCNativeGDI(GCPtr pGC);

#if 0
static void
 winChangeClipNativeGDI(GCPtr pGC, int nType, void *pValue, int nRects);

static void
 winDestroyClipNativeGDI(GCPtr pGC);

static void
 winCopyClipNativeGDI(GCPtr pGCdst, GCPtr pGCsrc);
#endif

#if 0
/* GC Handling Routines */
const GCFuncs winGCFuncs = {
    winValidateGCNativeGDI,
    winChangeGCNativeGDI,
    winCopyGCNativeGDI,
    winDestroyGCNativeGDI,
    winChangeClipNativeGDI,
    winDestroyClipNativeGDI,
    winCopyClipNativeGDI,
};
#else
const GCFuncs winGCFuncs = {
    winValidateGCNativeGDI,
    miChangeGC,
    miCopyGC,
    winDestroyGCNativeGDI,
    miChangeClip,
    miDestroyClip,
    miCopyClip,
};
#endif

/* Drawing Primitives */
const GCOps winGCOps = {
    winFillSpansNativeGDI,
    winSetSpansNativeGDI,
    miPutImage,
    miCopyArea,
    miCopyPlane,
    miPolyPoint,
    winPolyLineNativeGDI,
    miPolySegment,
    miPolyRectangle,
    miPolyArc,
    miFillPolygon,
    miPolyFillRect,
    miPolyFillArc,
    miPolyText8,
    miPolyText16,
    miImageText8,
    miImageText16,
#if 0
    winImageGlyphBltNativeGDI,
    winPolyGlyphBltNativeGDI,
#else
    miImageGlyphBlt,
    miPolyGlyphBlt,
#endif
    miPushPixels,
};

/* See Porting Layer Definition - p. 45 */
/* See mfb/mfbgc.c - mfbCreateGC() */
/* See Strategies for Porting - pp. 15, 16 */
Bool
winCreateGCNativeGDI(GCPtr pGC)
{
    winPrivGCPtr pGCPriv = NULL;
    winPrivScreenPtr pScreenPriv = NULL;

#if 0
    ErrorF("winCreateGCNativeGDI - depth: %d\n", pGC->depth);
#endif

    pGC->ops = (GCOps *) &winGCOps;
    pGC->funcs = (GCFuncs *) &winGCFuncs;

    /* We want all coordinates passed to spans functions to be screen relative */
    pGC->miTranslate = TRUE;

    /* Allocate privates for this GC */
    pGCPriv = winGetGCPriv(pGC);
    if (pGCPriv == NULL) {
        ErrorF("winCreateGCNativeGDI () - Privates pointer was NULL\n");
        return FALSE;
    }

    /* Create a new screen DC for the display window */
    pScreenPriv = winGetScreenPriv(pGC->pScreen);
    pGCPriv->hdc = GetDC(pScreenPriv->hwndScreen);

    /* Allocate a memory DC for the GC */
    pGCPriv->hdcMem = CreateCompatibleDC(pGCPriv->hdc);

    return TRUE;
}

#if 0
/* See Porting Layer Definition - p. 45 */
static void
winChangeGCNativeGDI(GCPtr pGC, unsigned long ulChanges)
{
#if 0
    ErrorF("winChangeGCNativeGDI () - Doing nothing\n");
#endif
}
#endif

static void
winValidateGCNativeGDI(GCPtr pGC,
                       unsigned long ulChanges, DrawablePtr pDrawable)
{
    if ((ulChanges &
         (GCClipXOrigin | GCClipYOrigin | GCClipMask | GCSubwindowMode))
        || (pDrawable->serialNumber !=
            (pGC->serialNumber & DRAWABLE_SERIAL_BITS))) {
        miComputeCompositeClip(pGC, pDrawable);
    }
}

#if 0
/* See Porting Layer Definition - p. 46 */
static void
winCopyGCNativeGDI(GCPtr pGCsrc, unsigned long ulMask, GCPtr pGCdst)
{

}
#endif

/* See Porting Layer Definition - p. 46 */
static void
winDestroyGCNativeGDI(GCPtr pGC)
{
    winGCPriv(pGC);
    winScreenPriv(pGC->pScreen);

    if (pGC->freeCompClip)
        RegionDestroy(pGC->pCompositeClip);

    /* Free the memory DC */
    if (pGCPriv->hdcMem != NULL) {
        DeleteDC(pGCPriv->hdcMem);
        pGCPriv->hdcMem = NULL;
    }

    /* Release the screen DC for the display window */
    if (pGCPriv->hdc != NULL) {
        ReleaseDC(pScreenPriv->hwndScreen, pGCPriv->hdc);
        pGCPriv->hdc = NULL;
    }

    /* Invalidate the GC privates pointer */
    winSetGCPriv(pGC, NULL);
}

#if 0
/* See Porting Layer Definition - p. 46 */
static void
winChangeClipNativeGDI(GCPtr pGC, int nType, void *pValue, int nRects)
{

}

/* See Porting Layer Definition - p. 47 */
static void
winDestroyClipNativeGDI(GCPtr pGC)
{

}

/* See Porting Layer Definition - p. 47 */
static void
winCopyClipNativeGDI(GCPtr pGCdst, GCPtr pGCsrc)
{

}
#endif
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d59 1
a59 1
 winChangeClipNativeGDI(GCPtr pGC, int nType, pointer pValue, int nRects);
d217 1
a217 1
winChangeClipNativeGDI(GCPtr pGC, int nType, pointer pValue, int nRects)
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a35 5
void

winPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr pDrawable, int dx,
              int dy, int xOrg, int yOrg);

d133 2
a134 2
    pGC->ops = (GCOps *) & winGCOps;
    pGC->funcs = (GCFuncs *) & winGCFuncs;
@


1.4
log
@Update to xserver 1.11.2
@
text
@a36 1
winPushPixels (GCPtr pGC, PixmapPtr pBitMap, DrawablePtr pDrawable, int dx, int dy, int xOrg, int yOrg);
d38 2
d47 1
a47 1
winChangeGCNativeGDI (GCPtr pGC, unsigned long ulChanges);
d51 2
a52 3
winValidateGCNativeGDI (GCPtr pGC,
			unsigned long changes,
			DrawablePtr pDrawable);
d56 1
a56 1
winCopyGCNativeGDI (GCPtr pGCsrc, unsigned long ulMask, GCPtr pGCdst);
d60 1
a60 1
winDestroyGCNativeGDI (GCPtr pGC);
d64 1
a64 1
winChangeClipNativeGDI (GCPtr pGC, int nType, pointer pValue, int nRects);
d67 1
a67 1
winDestroyClipNativeGDI (GCPtr pGC);
d70 1
a70 1
winCopyClipNativeGDI (GCPtr pGCdst, GCPtr pGCsrc);
d76 7
a82 7
  winValidateGCNativeGDI,
  winChangeGCNativeGDI,
  winCopyGCNativeGDI,
  winDestroyGCNativeGDI,
  winChangeClipNativeGDI,
  winDestroyClipNativeGDI,
  winCopyClipNativeGDI,
d86 7
a92 7
  winValidateGCNativeGDI,
  miChangeGC,
  miCopyGC,
  winDestroyGCNativeGDI,
  miChangeClip,
  miDestroyClip,
  miCopyClip,
d98 17
a114 17
  winFillSpansNativeGDI,
  winSetSpansNativeGDI,
  miPutImage,
  miCopyArea,
  miCopyPlane,
  miPolyPoint,
  winPolyLineNativeGDI,
  miPolySegment,
  miPolyRectangle,
  miPolyArc,
  miFillPolygon,
  miPolyFillRect,
  miPolyFillArc,
  miPolyText8,
  miPolyText16,
  miImageText8,
  miImageText16,
d116 2
a117 2
  winImageGlyphBltNativeGDI,
  winPolyGlyphBltNativeGDI,
d119 2
a120 2
  miImageGlyphBlt,
  miPolyGlyphBlt,
d122 1
a122 1
  miPushPixels,
a124 1

d129 1
a129 1
winCreateGCNativeGDI (GCPtr pGC)
d131 2
a132 2
  winPrivGCPtr		pGCPriv = NULL;
  winPrivScreenPtr	pScreenPriv = NULL;
d135 1
a135 2
  ErrorF ("winCreateGCNativeGDI - depth: %d\n",
	  pGC->depth);
d138 2
a139 2
  pGC->ops = (GCOps *) &winGCOps;
  pGC->funcs = (GCFuncs *) &winGCFuncs;
d141 2
a142 2
  /* We want all coordinates passed to spans functions to be screen relative */
  pGC->miTranslate = TRUE;
d144 5
a148 6
  /* Allocate privates for this GC */
  pGCPriv = winGetGCPriv (pGC);
  if (pGCPriv == NULL)
    {
      ErrorF ("winCreateGCNativeGDI () - Privates pointer was NULL\n");
      return FALSE;
d151 3
a153 3
  /* Create a new screen DC for the display window */
  pScreenPriv = winGetScreenPriv (pGC->pScreen);
  pGCPriv->hdc = GetDC (pScreenPriv->hwndScreen);
d155 2
a156 2
  /* Allocate a memory DC for the GC */
  pGCPriv->hdcMem = CreateCompatibleDC (pGCPriv->hdc);
d158 1
a158 1
  return TRUE;
a160 1

d164 1
a164 1
winChangeGCNativeGDI (GCPtr pGC, unsigned long ulChanges)
d167 1
a167 1
  ErrorF ("winChangeGCNativeGDI () - Doing nothing\n");
a171 1

d173 2
a174 3
winValidateGCNativeGDI (GCPtr pGC,
			unsigned long ulChanges,
			DrawablePtr pDrawable)
d176 6
a181 5
  if ((ulChanges & (GCClipXOrigin | GCClipYOrigin | GCClipMask | GCSubwindowMode)) 
      || (pDrawable->serialNumber != (pGC->serialNumber & DRAWABLE_SERIAL_BITS)))
  {
    miComputeCompositeClip (pGC, pDrawable);
  }
a183 1

d187 1
a187 1
winCopyGCNativeGDI (GCPtr pGCsrc, unsigned long ulMask, GCPtr pGCdst)
a192 1

d195 1
a195 1
winDestroyGCNativeGDI (GCPtr pGC)
d197 2
a198 2
  winGCPriv(pGC);
  winScreenPriv(pGC->pScreen);
d200 2
a201 2
  if (pGC->freeCompClip)
	RegionDestroy(pGC->pCompositeClip);
d203 4
a206 5
  /* Free the memory DC */
  if (pGCPriv->hdcMem != NULL)
    {
      DeleteDC (pGCPriv->hdcMem);
      pGCPriv->hdcMem = NULL;
d209 4
a212 5
  /* Release the screen DC for the display window */
  if (pGCPriv->hdc != NULL)
    {
      ReleaseDC (pScreenPriv->hwndScreen, pGCPriv->hdc);
      pGCPriv->hdc = NULL;
d215 2
a216 2
  /* Invalidate the GC privates pointer */
  winSetGCPriv (pGC, NULL);
d222 1
a222 1
winChangeClipNativeGDI (GCPtr pGC, int nType, pointer pValue, int nRects)
a226 1

d229 1
a229 1
winDestroyClipNativeGDI (GCPtr pGC)
a233 1

d236 1
a236 1
winCopyClipNativeGDI (GCPtr pGCdst, GCPtr pGCsrc)
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a139 5
  pGC->clientClip = NULL;
  pGC->clientClipType = CT_NONE;
  pGC->freeCompClip = FALSE;
  pGC->pCompositeClip = 0;

@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d213 1
a213 1
	REGION_DESTROY (pGC->pScreen, pGC->pCompositeClip);
@


1.1
log
@Initial revision
@
text
@d122 1
a122 1
  winPushPixels
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
