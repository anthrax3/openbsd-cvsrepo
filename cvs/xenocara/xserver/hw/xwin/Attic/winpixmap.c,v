head	1.7;
access;
symbols
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.12
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.8
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.09.16.19.10.24;	author matthieu;	state dead;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.27;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.27;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	drewry, september 1986
 *		Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

/*
 * Local prototypes
 */

#if 0
static void
 winXRotatePixmapNativeGDI(PixmapPtr pPix, int rw);

static void
 winYRotatePixmapNativeGDI(PixmapPtr pPix, int rh);

static void

winCopyRotatePixmapNativeGDI(PixmapPtr psrcPix, PixmapPtr *ppdstPix,
                             int xrot, int yrot);
#endif

/* See Porting Layer Definition - p. 34 */
/* See mfb/mfbpixmap.c - mfbCreatePixmap() */
PixmapPtr
winCreatePixmapNativeGDI(ScreenPtr pScreen,
                         int iWidth, int iHeight,
                         int iDepth, unsigned usage_hint)
{
    winPrivPixmapPtr pPixmapPriv = NULL;
    PixmapPtr pPixmap = NULL;

    /* Allocate pixmap memory */
    pPixmap = AllocatePixmap(pScreen, 0);
    if (!pPixmap) {
        ErrorF("winCreatePixmapNativeGDI () - Couldn't allocate a pixmap\n");
        return NullPixmap;
    }

#if CYGDEBUG
    winDebug("winCreatePixmap () - w %d h %d d %d uh %d bw %d\n",
             iWidth, iHeight, iDepth, usage_hint,
             PixmapBytePad(iWidth, iDepth));
#endif

    /* Setup pixmap values */
    pPixmap->drawable.type = DRAWABLE_PIXMAP;
    pPixmap->drawable.class = 0;
    pPixmap->drawable.pScreen = pScreen;
    pPixmap->drawable.depth = iDepth;
    pPixmap->drawable.bitsPerPixel = BitsPerPixel(iDepth);
    pPixmap->drawable.id = 0;
    pPixmap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
    pPixmap->drawable.x = 0;
    pPixmap->drawable.y = 0;
    pPixmap->drawable.width = iWidth;
    pPixmap->drawable.height = iHeight;
    pPixmap->devKind = 0;
    pPixmap->refcnt = 1;
    pPixmap->devPrivate.ptr = NULL;
    pPixmap->usage_hint = usage_hint;

    /* Pixmap privates are allocated by AllocatePixmap */
    pPixmapPriv = winGetPixmapPriv(pPixmap);

    /* Initialize pixmap privates */
    pPixmapPriv->hBitmap = NULL;
    pPixmapPriv->hdcSelected = NULL;
    pPixmapPriv->pbBits = NULL;
    pPixmapPriv->dwScanlineBytes = PixmapBytePad(iWidth, iDepth);

    /* Check for zero width or height pixmaps */
    if (iWidth == 0 || iHeight == 0) {
        /* Don't allocate a real pixmap, just set fields and return */
        return pPixmap;
    }

    /* Create a DIB for the pixmap */
    pPixmapPriv->hBitmap = winCreateDIBNativeGDI(iWidth, iHeight, iDepth,
                                                 &pPixmapPriv->pbBits,
                                                 (BITMAPINFO **) &pPixmapPriv->
                                                 pbmih);

#if CYGDEBUG
    winDebug("winCreatePixmap () - Created a pixmap %08x, %dx%dx%d, for "
             "screen: %08x\n",
             pPixmapPriv->hBitmap, iWidth, iHeight, iDepth, pScreen);
#endif

    return pPixmap;
}

/* 
 * See Porting Layer Definition - p. 35
 *
 * See mfb/mfbpixmap.c - mfbDestroyPixmap()
 */

Bool
winDestroyPixmapNativeGDI(PixmapPtr pPixmap)
{
    winPrivPixmapPtr pPixmapPriv = NULL;

#if CYGDEBUG
    winDebug("winDestroyPixmapNativeGDI ()\n");
#endif

    /* Bail early if there is not a pixmap to destroy */
    if (pPixmap == NULL) {
        ErrorF("winDestroyPixmapNativeGDI () - No pixmap to destroy\n");
        return TRUE;
    }

    /* Get a handle to the pixmap privates */
    pPixmapPriv = winGetPixmapPriv(pPixmap);

#if CYGDEBUG
    winDebug("winDestroyPixmapNativeGDI - pPixmapPriv->hBitmap: %08x\n",
             pPixmapPriv->hBitmap);
#endif

    /* Decrement reference count, return if nonzero */
    --pPixmap->refcnt;
    if (pPixmap->refcnt != 0)
        return TRUE;

    /* Free GDI bitmap */
    if (pPixmapPriv->hBitmap)
        DeleteObject(pPixmapPriv->hBitmap);

    /* Free the bitmap info header memory */
    free(pPixmapPriv->pbmih);
    pPixmapPriv->pbmih = NULL;

    /* Free the pixmap memory */
    free(pPixmap);
    pPixmap = NULL;

    return TRUE;
}

/* 
 * Not used yet
 */

Bool
winModifyPixmapHeaderNativeGDI(PixmapPtr pPixmap,
                               int iWidth, int iHeight,
                               int iDepth,
                               int iBitsPerPixel, int devKind, void *pPixData)
{
    FatalError("winModifyPixmapHeaderNativeGDI ()\n");
    return TRUE;
}

#if 0
/* 
 * Not used yet.
 * See cfb/cfbpixmap.c
 */

static void
winXRotatePixmapNativeGDI(PixmapPtr pPix, int rw)
{
    ErrorF("winXRotatePixmap()\n");
    /* fill in this function, look at CFB */
}

/*
 * Not used yet.
 * See cfb/cfbpixmap.c
 */
static void
winYRotatePixmapNativeGDI(PixmapPtr pPix, int rh)
{
    ErrorF("winYRotatePixmap()\n");
    /* fill in this function, look at CFB */
}

/* 
 * Not used yet.
 * See cfb/cfbpixmap.c
 */

static void
winCopyRotatePixmapNativeGDI(PixmapPtr psrcPix, PixmapPtr *ppdstPix,
                             int xrot, int yrot)
{
    ErrorF("winCopyRotatePixmap()\n");
    /* fill in this function, look at CFB */
}
#endif
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d181 1
a181 1
                               int iBitsPerPixel, int devKind, pointer pPixData)
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d112 1
a112 1
                                                 (BITMAPINFO **) & pPixmapPriv->
@


1.3
log
@Update to xserver 1.11.2
@
text
@a36 1

d43 1
a43 1
winXRotatePixmapNativeGDI (PixmapPtr pPix, int rw);
d46 1
a46 1
winYRotatePixmapNativeGDI (PixmapPtr pPix, int rh);
d49 3
a51 2
winCopyRotatePixmapNativeGDI (PixmapPtr psrcPix, PixmapPtr *ppdstPix,
			      int xrot, int yrot);
a53 1

d57 12
a68 13
winCreatePixmapNativeGDI (ScreenPtr pScreen,
			  int iWidth, int iHeight,
			  int iDepth, unsigned usage_hint)
{
  winPrivPixmapPtr	pPixmapPriv = NULL;
  PixmapPtr		pPixmap = NULL;

  /* Allocate pixmap memory */
  pPixmap = AllocatePixmap (pScreen, 0);
  if (!pPixmap)
    {
      ErrorF ("winCreatePixmapNativeGDI () - Couldn't allocate a pixmap\n");
      return NullPixmap;
d72 3
a74 3
  winDebug ("winCreatePixmap () - w %d h %d d %d uh %d bw %d\n",
	  iWidth, iHeight, iDepth, usage_hint,
	  PixmapBytePad (iWidth, iDepth));
d77 30
a106 31
  /* Setup pixmap values */
  pPixmap->drawable.type = DRAWABLE_PIXMAP;
  pPixmap->drawable.class = 0;
  pPixmap->drawable.pScreen = pScreen;
  pPixmap->drawable.depth = iDepth;
  pPixmap->drawable.bitsPerPixel = BitsPerPixel (iDepth);
  pPixmap->drawable.id = 0;
  pPixmap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
  pPixmap->drawable.x = 0;
  pPixmap->drawable.y = 0;
  pPixmap->drawable.width = iWidth;
  pPixmap->drawable.height = iHeight;
  pPixmap->devKind = 0;
  pPixmap->refcnt = 1;
  pPixmap->devPrivate.ptr = NULL;
  pPixmap->usage_hint = usage_hint;

  /* Pixmap privates are allocated by AllocatePixmap */
  pPixmapPriv = winGetPixmapPriv (pPixmap);

  /* Initialize pixmap privates */
  pPixmapPriv->hBitmap = NULL;
  pPixmapPriv->hdcSelected = NULL;
  pPixmapPriv->pbBits = NULL;
  pPixmapPriv->dwScanlineBytes = PixmapBytePad (iWidth, iDepth);

  /* Check for zero width or height pixmaps */
  if (iWidth == 0 || iHeight == 0)
    {
      /* Don't allocate a real pixmap, just set fields and return */
      return pPixmap;
d109 5
a113 4
  /* Create a DIB for the pixmap */
  pPixmapPriv->hBitmap = winCreateDIBNativeGDI (iWidth, iHeight, iDepth,
						&pPixmapPriv->pbBits,
						(BITMAPINFO **) &pPixmapPriv->pbmih);
d116 3
a118 3
  winDebug ("winCreatePixmap () - Created a pixmap %08x, %dx%dx%d, for " \
	  "screen: %08x\n",
	  pPixmapPriv->hBitmap, iWidth, iHeight, iDepth, pScreen);
d121 1
a121 1
  return pPixmap;
a123 1

d131 1
a131 1
winDestroyPixmapNativeGDI (PixmapPtr pPixmap)
d133 2
a134 2
  winPrivPixmapPtr		pPixmapPriv = NULL;
  
d136 1
a136 1
  winDebug ("winDestroyPixmapNativeGDI ()\n");
d139 4
a142 5
  /* Bail early if there is not a pixmap to destroy */
  if (pPixmap == NULL)
    {
      ErrorF ("winDestroyPixmapNativeGDI () - No pixmap to destroy\n");
      return TRUE;
d145 2
a146 2
  /* Get a handle to the pixmap privates */
  pPixmapPriv = winGetPixmapPriv (pPixmap);
d149 2
a150 2
  winDebug ("winDestroyPixmapNativeGDI - pPixmapPriv->hBitmap: %08x\n",
	  pPixmapPriv->hBitmap);
d153 17
a169 3
  /* Decrement reference count, return if nonzero */
  --pPixmap->refcnt;
  if (pPixmap->refcnt != 0)
a170 13

  /* Free GDI bitmap */
  if (pPixmapPriv->hBitmap) DeleteObject (pPixmapPriv->hBitmap);
  
  /* Free the bitmap info header memory */
  free(pPixmapPriv->pbmih);
  pPixmapPriv->pbmih = NULL;

  /* Free the pixmap memory */
  free (pPixmap);
  pPixmap = NULL;

  return TRUE;
a172 1

d178 4
a181 6
winModifyPixmapHeaderNativeGDI (PixmapPtr pPixmap,
				int iWidth, int iHeight,
				int iDepth,
				int iBitsPerPixel,
				int devKind,
				pointer pPixData)
d183 2
a184 2
  FatalError ("winModifyPixmapHeaderNativeGDI ()\n");
  return TRUE;
a186 1

d194 1
a194 1
winXRotatePixmapNativeGDI (PixmapPtr pPix, int rw)
d196 2
a197 2
  ErrorF ("winXRotatePixmap()\n");
  /* fill in this function, look at CFB */
a199 1

d205 1
a205 1
winYRotatePixmapNativeGDI (PixmapPtr pPix, int rh)
d207 2
a208 2
  ErrorF ("winYRotatePixmap()\n");
  /* fill in this function, look at CFB */
a210 1

d217 2
a218 2
winCopyRotatePixmapNativeGDI (PixmapPtr psrcPix, PixmapPtr *ppdstPix,
			      int xrot, int yrot)
d220 2
a221 2
  ErrorF ("winCopyRotatePixmap()\n");
  /* fill in this function, look at CFB */
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d166 2
a167 5
  if (pPixmapPriv->pbmih != NULL)
    {
      free (pPixmapPriv->pbmih);
      pPixmapPriv->pbmih = NULL;
    }
@


1.1
log
@Initial revision
@
text
@a38 7
 * References to external symbols
 */

extern int			g_iPixmapPrivateIndex;


/*
d60 1
a60 1
			  int iDepth)
d74 2
a75 2
  winDebug ("winCreatePixmap () - w %d h %d d %d bw %d\n",
	  iWidth, iHeight, iDepth,
d94 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
