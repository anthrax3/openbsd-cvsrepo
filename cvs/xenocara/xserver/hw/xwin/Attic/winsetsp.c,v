head	1.8;
access;
symbols
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.24;	author matthieu;	state dead;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Harold L Hunt II
 * 		Alan Hourihane <alanh@@fairlite.demon.co.uk>
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

/* See Porting Layer Definition - p. 55 */
void
winSetSpansNativeGDI(DrawablePtr pDrawable,
                     GCPtr pGC,
                     char *pSrcs,
                     DDXPointPtr pPoints,
                     int *piWidths, int iSpans, int fSorted)
{
    winGCPriv(pGC);
    PixmapPtr pPixmap = NULL;
    winPrivPixmapPtr pPixmapPriv = NULL;
    HBITMAP hbmpOrig = NULL;
    BITMAPINFO *pbmi;
    HRGN hrgn = NULL, combined = NULL;
    int nbox;
    BoxPtr pbox;

    nbox = RegionNumRects(pGC->pCompositeClip);
    pbox = RegionRects(pGC->pCompositeClip);

    if (!nbox)
        return;

    pbmi = malloc(sizeof(BITMAPINFO) + sizeof(RGBQUAD));

    combined = CreateRectRgn(pbox->x1, pbox->y1, pbox->x2, pbox->y2);
    nbox--;
    pbox++;
    while (nbox--) {
        hrgn = CreateRectRgn(pbox->x1, pbox->y1, pbox->x2, pbox->y2);
        CombineRgn(combined, combined, hrgn, RGN_OR);
        DeleteObject(hrgn);
        hrgn = NULL;
        pbox++;
    }

    /* Branch on the drawable type */
    switch (pDrawable->type) {
    case DRAWABLE_PIXMAP:

        SelectClipRgn(pGCPriv->hdcMem, combined);
        DeleteObject(combined);
        combined = NULL;

        pPixmap = (PixmapPtr) pDrawable;
        pPixmapPriv = winGetPixmapPriv(pPixmap);

        /* Select the drawable pixmap into a DC */
        hbmpOrig = SelectObject(pGCPriv->hdcMem, pPixmapPriv->hBitmap);
        if (hbmpOrig == NULL)
            FatalError("winSetSpans - DRAWABLE_PIXMAP - SelectObject () "
                       "failed on pPixmapPriv->hBitmap\n");

        while (iSpans--) {
            ZeroMemory(pbmi, sizeof(BITMAPINFO));
            pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            pbmi->bmiHeader.biWidth = *piWidths;
            pbmi->bmiHeader.biHeight = 1;
            pbmi->bmiHeader.biPlanes = 1;
            pbmi->bmiHeader.biBitCount = pDrawable->depth;
            pbmi->bmiHeader.biCompression = BI_RGB;

            /* Setup color table for mono DIBs */
            if (pDrawable->depth == 1) {
                RGBQUAD *bmiColors = &(pbmi->bmiColors[0]);
                bmiColors[1].rgbBlue = 255;
                bmiColors[1].rgbGreen = 255;
                bmiColors[1].rgbRed = 255;
            }

            StretchDIBits(pGCPriv->hdcMem,
                          pPoints->x, pPoints->y,
                          *piWidths, 1,
                          0, 0,
                          *piWidths, 1,
                          pSrcs,
                          (BITMAPINFO *) pbmi,
                          DIB_RGB_COLORS, g_copyROP[pGC->alu]);

            pSrcs += PixmapBytePad(*piWidths, pDrawable->depth);
            pPoints++;
            piWidths++;
        }

        /* Reset the clip region */
        SelectClipRgn(pGCPriv->hdcMem, NULL);

        /* Push the drawable pixmap out of the GC HDC */
        SelectObject(pGCPriv->hdcMem, hbmpOrig);
        break;

    case DRAWABLE_WINDOW:

        SelectClipRgn(pGCPriv->hdc, combined);
        DeleteObject(combined);
        combined = NULL;

        while (iSpans--) {
            ZeroMemory(pbmi, sizeof(BITMAPINFO));
            pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            pbmi->bmiHeader.biWidth = *piWidths;
            pbmi->bmiHeader.biHeight = 1;
            pbmi->bmiHeader.biPlanes = 1;
            pbmi->bmiHeader.biBitCount = pDrawable->depth;
            pbmi->bmiHeader.biCompression = BI_RGB;

            /* Setup color table for mono DIBs */
            if (pDrawable->depth == 1) {
                RGBQUAD *bmiColors = &(pbmi->bmiColors[0]);
                bmiColors[1].rgbBlue = 255;
                bmiColors[1].rgbGreen = 255;
                bmiColors[1].rgbRed = 255;
            }

            StretchDIBits(pGCPriv->hdc,
                          pPoints->x, pPoints->y,
                          *piWidths, 1,
                          0, 0,
                          *piWidths, 1,
                          pSrcs,
                          (BITMAPINFO *) pbmi,
                          DIB_RGB_COLORS, g_copyROP[pGC->alu]);

            pSrcs += PixmapBytePad(*piWidths, pDrawable->depth);
            pPoints++;
            piWidths++;
        }

        /* Reset the clip region */
        SelectClipRgn(pGCPriv->hdc, NULL);
        break;

    default:
        FatalError("\nwinSetSpansNativeGDI - Unknown drawable type\n\n");
        break;
    }

    free(pbmi);
}
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d49 1
a49 1
    BITMAPINFO bmi;
d60 2
d91 7
a97 7
            ZeroMemory(&bmi, sizeof(BITMAPINFO));
            bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            bmi.bmiHeader.biWidth = *piWidths;
            bmi.bmiHeader.biHeight = 1;
            bmi.bmiHeader.biPlanes = 1;
            bmi.bmiHeader.biBitCount = pDrawable->depth;
            bmi.bmiHeader.biCompression = BI_RGB;
d101 4
a104 3
                bmi.bmiColors[1].rgbBlue = 255;
                bmi.bmiColors[1].rgbGreen = 255;
                bmi.bmiColors[1].rgbRed = 255;
d113 1
a113 1
                          (BITMAPINFO *) &bmi,
d135 7
a141 7
            ZeroMemory(&bmi, sizeof(BITMAPINFO));
            bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            bmi.bmiHeader.biWidth = *piWidths;
            bmi.bmiHeader.biHeight = 1;
            bmi.bmiHeader.biPlanes = 1;
            bmi.bmiHeader.biBitCount = pDrawable->depth;
            bmi.bmiHeader.biCompression = BI_RGB;
d145 4
a148 3
                bmi.bmiColors[1].rgbBlue = 255;
                bmi.bmiColors[1].rgbGreen = 255;
                bmi.bmiColors[1].rgbRed = 255;
d157 1
a157 1
                          (BITMAPINFO *) &bmi,
d173 2
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d110 1
a110 1
                          (BITMAPINFO *) & bmi,
d153 1
a153 1
                          (BITMAPINFO *) & bmi,
@


1.4
log
@Update to xserver 1.11.2
@
text
@a36 1

d39 5
a43 7
winSetSpansNativeGDI (DrawablePtr	pDrawable,
		      GCPtr		pGC,
		      char		*pSrcs,
		      DDXPointPtr	pPoints,
		      int		*piWidths,
		      int		iSpans,
		      int		fSorted)
d45 24
a68 23
  winGCPriv(pGC);
  PixmapPtr		pPixmap = NULL;
  winPrivPixmapPtr	pPixmapPriv = NULL;
  HBITMAP		hbmpOrig = NULL;
  BITMAPINFO		bmi;
  HRGN			hrgn = NULL, combined = NULL;
  int			nbox;
  BoxPtr	 	pbox;

  nbox = RegionNumRects (pGC->pCompositeClip);
  pbox = RegionRects (pGC->pCompositeClip);

  if (!nbox) return;

  combined = CreateRectRgn (pbox->x1, pbox->y1, pbox->x2, pbox->y2);
  nbox--; pbox++;
  while (nbox--)
    {
      hrgn = CreateRectRgn (pbox->x1, pbox->y1, pbox->x2, pbox->y2);
      CombineRgn (combined, combined, hrgn, RGN_OR);
      DeleteObject (hrgn);
      hrgn = NULL;
      pbox++;
d71 2
a72 3
  /* Branch on the drawable type */
  switch (pDrawable->type)
    {
d75 41
a115 44
      SelectClipRgn (pGCPriv->hdcMem, combined);
      DeleteObject (combined);
      combined = NULL;

      pPixmap = (PixmapPtr) pDrawable;
      pPixmapPriv = winGetPixmapPriv (pPixmap);
      
      /* Select the drawable pixmap into a DC */
      hbmpOrig = SelectObject (pGCPriv->hdcMem, pPixmapPriv->hBitmap);
      if (hbmpOrig == NULL)
	FatalError ("winSetSpans - DRAWABLE_PIXMAP - SelectObject () "
		    "failed on pPixmapPriv->hBitmap\n");

      while (iSpans--)
        {
	  ZeroMemory (&bmi, sizeof (BITMAPINFO));
	  bmi.bmiHeader.biSize = sizeof (BITMAPINFOHEADER);
	  bmi.bmiHeader.biWidth = *piWidths;
	  bmi.bmiHeader.biHeight = 1;
	  bmi.bmiHeader.biPlanes = 1;
	  bmi.bmiHeader.biBitCount = pDrawable->depth;
	  bmi.bmiHeader.biCompression = BI_RGB;

  	  /* Setup color table for mono DIBs */
  	  if (pDrawable->depth == 1)
    	    {
      	      bmi.bmiColors[1].rgbBlue = 255;
      	      bmi.bmiColors[1].rgbGreen = 255;
      	      bmi.bmiColors[1].rgbRed = 255;
    	    }

	  StretchDIBits (pGCPriv->hdcMem, 
			 pPoints->x, pPoints->y,
			 *piWidths, 1,
			 0, 0,
			 *piWidths, 1,
			 pSrcs,
			 (BITMAPINFO *) &bmi,
			 DIB_RGB_COLORS,
			 g_copyROP[pGC->alu]);

	  pSrcs += PixmapBytePad (*piWidths, pDrawable->depth);
	  pPoints++;
	  piWidths++;
d117 7
a123 7
      
      /* Reset the clip region */
      SelectClipRgn (pGCPriv->hdcMem, NULL);

      /* Push the drawable pixmap out of the GC HDC */
      SelectObject (pGCPriv->hdcMem, hbmpOrig);
      break;
d127 32
a158 35
      SelectClipRgn (pGCPriv->hdc, combined);
      DeleteObject (combined);
      combined = NULL;

      while (iSpans--)
        {
	  ZeroMemory (&bmi, sizeof (BITMAPINFO));
	  bmi.bmiHeader.biSize = sizeof (BITMAPINFOHEADER);
	  bmi.bmiHeader.biWidth = *piWidths;
	  bmi.bmiHeader.biHeight = 1;
	  bmi.bmiHeader.biPlanes = 1;
	  bmi.bmiHeader.biBitCount = pDrawable->depth;
	  bmi.bmiHeader.biCompression = BI_RGB;

  	  /* Setup color table for mono DIBs */
  	  if (pDrawable->depth == 1)
    	    {
      	      bmi.bmiColors[1].rgbBlue = 255;
      	      bmi.bmiColors[1].rgbGreen = 255;
      	      bmi.bmiColors[1].rgbRed = 255;
    	    }

	  StretchDIBits (pGCPriv->hdc, 
			 pPoints->x, pPoints->y,
			 *piWidths, 1,
			 0, 0,
			 *piWidths, 1,
			 pSrcs,
			 (BITMAPINFO *) &bmi,
			 DIB_RGB_COLORS,
			 g_copyROP[pGC->alu]);

	  pSrcs += PixmapBytePad (*piWidths, pDrawable->depth);
	  pPoints++;
	  piWidths++;
d161 3
a163 3
      /* Reset the clip region */
      SelectClipRgn (pGCPriv->hdc, NULL);
      break;
d166 2
a167 2
      FatalError ("\nwinSetSpansNativeGDI - Unknown drawable type\n\n");
      break;
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a173 8
    case UNDRAWABLE_WINDOW:
      FatalError ("\nwinSetSpansNativeGDI - UNDRAWABLE_WINDOW\n\n");
      break;

    case DRAWABLE_BUFFER:
      FatalError ("\nwinSetSpansNativeGDI - DRAWABLE_BUFFER\n\n");
      break;
      
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d57 2
a58 2
  nbox = REGION_NUM_RECTS (pGC->pCompositeClip);
  pbox = REGION_RECTS (pGC->pCompositeClip);
@


1.1
log
@Initial revision
@
text
@a37 9
/*
 * References to external symbols
 */

extern int			g_iPixmapPrivateIndex;
extern int			g_iGCPrivateIndex;
extern int                      g_copyROP[];


@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
