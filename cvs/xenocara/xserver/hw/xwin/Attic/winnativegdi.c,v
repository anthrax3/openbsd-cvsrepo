head	1.6;
access;
symbols
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	OPENBSD_5_0:1.1.1.1.0.18
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.14
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.09.16.19.10.24;	author matthieu;	state dead;
branches;
next	1.5;
commitid	Te1daavkBLskZ8gc;

1.5
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	cVXoV5PxI8YrEaVA;

1.4
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

/*
 * Local function prototypes
 */

static Bool
 winAllocateFBNativeGDI(ScreenPtr pScreen);

static void
 winShadowUpdateNativeGDI(ScreenPtr pScreen, shadowBufPtr pBuf);

static Bool
 winCloseScreenNativeGDI(ScreenPtr pScreen);

static Bool
 winInitVisualsNativeGDI(ScreenPtr pScreen);

static Bool
 winAdjustVideoModeNativeGDI(ScreenPtr pScreen);

#if 0
static Bool
 winBltExposedRegionsNativeGDI(ScreenPtr pScreen);
#endif

static Bool
 winActivateAppNativeGDI(ScreenPtr pScreen);

static Bool
 winRedrawScreenNativeGDI(ScreenPtr pScreen);

static Bool
 winRealizeInstalledPaletteNativeGDI(ScreenPtr pScreen);

static Bool
 winInstallColormapNativeGDI(ColormapPtr pColormap);

static Bool
 winStoreColorsNativeGDI(ColormapPtr pmap, int ndef, xColorItem * pdefs);

static Bool
 winCreateColormapNativeGDI(ColormapPtr pColormap);

static Bool
 winDestroyColormapNativeGDI(ColormapPtr pColormap);

static Bool
winAllocateFBNativeGDI(ScreenPtr pScreen)
{
    FatalError("winAllocateFBNativeGDI\n");

    return TRUE;
}

static void
winFreeFBNativeGDI(ScreenPtr pScreen)
{
    FatalError("winFreeFBNativeGDI\n");
}

static Bool
winInitScreenNativeGDI(ScreenPtr pScreen)
{
    FatalError("winInitScreenNativeGDI\n");
}

/*
 * We wrap whatever CloseScreen procedure was specified by fb;
 * a pointer to said procedure is stored in our privates.
 */

static Bool
winCloseScreenNativeGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    ErrorF("winCloseScreenNativeGDI - Freeing screen resources\n");

    /* Flag that the screen is closed */
    pScreenPriv->fClosed = TRUE;
    pScreenPriv->fActive = FALSE;

    /* 
     * NOTE: mi doesn't use a CloseScreen procedure, so we do not
     * need to call a wrapped procedure here.
     */

    /* Delete the window property */
    RemoveProp(pScreenPriv->hwndScreen, WIN_SCR_PROP);

    ErrorF("winCloseScreenNativeGDI - Destroying window\n");

    /* Delete tray icon, if we have one */
    if (!pScreenInfo->fNoTrayIcon)
        winDeleteNotifyIcon(pScreenPriv);

    /* Free the exit confirmation dialog box, if it exists */
    if (g_hDlgExit != NULL) {
        DestroyWindow(g_hDlgExit);
        g_hDlgExit = NULL;
    }

    /* Kill our window */
    if (pScreenPriv->hwndScreen) {
        DestroyWindow(pScreenPriv->hwndScreen);
        pScreenPriv->hwndScreen = NULL;
    }

    /* Invalidate our screeninfo's pointer to the screen */
    pScreenInfo->pScreen = NULL;

    /* Free the screen privates for this screen */
    free(pScreenPriv);

    ErrorF("winCloseScreenNativeGDI - Returning\n");

    return TRUE;
}

static void
winShadowUpdateNativeGDI(ScreenPtr pScreen, shadowBufPtr pBuf)
{
    FatalError("winShadowUpdateNativeGDI\n");
    return;
}

static Bool
winInitVisualsNativeGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Set the bitsPerRGB and bit masks */
    switch (pScreenInfo->dwDepth) {
    case 24:
        pScreenPriv->dwBitsPerRGB = 8;
        pScreenPriv->dwRedMask = 0x00FF0000;
        pScreenPriv->dwGreenMask = 0x0000FF00;
        pScreenPriv->dwBlueMask = 0x000000FF;
        break;

    case 16:
        pScreenPriv->dwBitsPerRGB = 6;
        pScreenPriv->dwRedMask = 0xF800;
        pScreenPriv->dwGreenMask = 0x07E0;
        pScreenPriv->dwBlueMask = 0x001F;
        break;

    case 15:
        pScreenPriv->dwBitsPerRGB = 5;
        pScreenPriv->dwRedMask = 0x7C00;
        pScreenPriv->dwGreenMask = 0x03E0;
        pScreenPriv->dwBlueMask = 0x001F;
        break;

    case 8:
        pScreenPriv->dwBitsPerRGB = 8;
        pScreenPriv->dwRedMask = 0;
        pScreenPriv->dwGreenMask = 0;
        pScreenPriv->dwBlueMask = 0;
        break;

    default:
        ErrorF("winInitVisualsNativeGDI - Unknown screen depth\n");
        return FALSE;
        break;
    }

    /* Tell the user how many bits per RGB we are using */
    ErrorF("winInitVisualsNativeGDI - Using dwBitsPerRGB: %d\n",
           (int) pScreenPriv->dwBitsPerRGB);

    /* Create a single visual according to the Windows screen depth */
    switch (pScreenInfo->dwDepth) {
    case 24:
    case 16:
    case 15:
        if (!miSetVisualTypesAndMasks(pScreenInfo->dwDepth,
                                      TrueColorMask,
                                      pScreenPriv->dwBitsPerRGB,
                                      TrueColor,
                                      pScreenPriv->dwRedMask,
                                      pScreenPriv->dwGreenMask,
                                      pScreenPriv->dwBlueMask)) {
            ErrorF("winInitVisuals - miSetVisualTypesAndMasks failed\n");
            return FALSE;
        }
        break;

    case 8:
        ErrorF("winInitVisuals - Calling miSetVisualTypesAndMasks\n");
        if (!miSetVisualTypesAndMasks(pScreenInfo->dwDepth,
                                      StaticColorMask,
                                      pScreenPriv->dwBitsPerRGB,
                                      StaticColor,
                                      pScreenPriv->dwRedMask,
                                      pScreenPriv->dwGreenMask,
                                      pScreenPriv->dwBlueMask)) {
            ErrorF("winInitVisuals - miSetVisualTypesAndMasks failed\n");
            return FALSE;
        }
        break;

    default:
        ErrorF("winInitVisualsNativeGDI - Unknown screen depth\n");
        return FALSE;
    }

#if 1
    ErrorF("winInitVisualsNativeGDI - Returning\n");
#endif

    return TRUE;
}

/* Adjust the video mode */
static Bool
winAdjustVideoModeNativeGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    HDC hdc = NULL;
    DWORD dwBPP;

    hdc = GetDC(NULL);

    /* We're in serious trouble if we can't get a DC */
    if (hdc == NULL) {
        ErrorF("winAdjustVideoModeNativeGDI - GetDC () failed\n");
        return FALSE;
    }

    /* Query GDI for current display depth */
    dwBPP = GetDeviceCaps(hdc, BITSPIXEL);
    pScreenInfo->dwDepth = GetDeviceCaps(hdc, PLANES);

    switch (pScreenInfo->dwDepth) {
    case 24:
    case 16:
    case 15:
    case 8:
        break;
    default:
        if (dwBPP == 32)
            pScreenInfo->dwDepth = 24;
        else
            pScreenInfo->dwDepth = dwBPP;
        break;
    }

    /* GDI cannot change the screen depth, so we'll use GDI's depth */
    pScreenInfo->dwBPP = dwBPP;

    /* Release our DC */
    ReleaseDC(NULL, hdc);

    return TRUE;
}

static Bool
winActivateAppNativeGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);

    /*
     * Are we active?
     * Are we fullscreen?
     */
    if (pScreenPriv != NULL
        && pScreenPriv->fActive
        && pScreenPriv->pScreenInfo && pScreenPriv->pScreenInfo->fFullScreen) {
        /*
         * Activating, attempt to bring our window 
         * to the top of the display
         */
        ShowWindow(pScreenPriv->hwndScreen, SW_RESTORE);
    }

    /*
     * Are we inactive?
     * Are we fullscreen?
     */
    if (pScreenPriv != NULL
        && !pScreenPriv->fActive
        && pScreenPriv->pScreenInfo && pScreenPriv->pScreenInfo->fFullScreen) {
        /*
         * Deactivating, stuff our window onto the
         * task bar.
         */
        ShowWindow(pScreenPriv->hwndScreen, SW_MINIMIZE);
    }

    return TRUE;
}

HBITMAP
winCreateDIBNativeGDI(int iWidth, int iHeight, int iDepth,
                      BYTE ** ppbBits, BITMAPINFO ** ppbmi)
{
    BITMAPINFOHEADER *pbmih = NULL;
    HBITMAP hBitmap = NULL;
    BITMAPINFO *pbmi = NULL;

    /* Don't create an invalid bitmap */
    if (iWidth == 0 || iHeight == 0 || iDepth == 0) {
        ErrorF("\nwinCreateDIBNativeGDI - Invalid specs w %d h %d d %d\n\n",
               iWidth, iHeight, iDepth);
        return NULL;
    }

    /* Allocate bitmap info header */
    pbmih = malloc(sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
    if (pbmih == NULL) {
        ErrorF("winCreateDIBNativeGDI - malloc () failed\n");
        return FALSE;
    }
    ZeroMemory(pbmih, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));

    /* Describe bitmap to be created */
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth = iWidth;
    pbmih->biHeight = -iHeight;
    pbmih->biPlanes = 1;
    pbmih->biBitCount = iDepth;
    pbmih->biCompression = BI_RGB;
    pbmih->biSizeImage = 0;
    pbmih->biXPelsPerMeter = 0;
    pbmih->biYPelsPerMeter = 0;
    pbmih->biClrUsed = 0;
    pbmih->biClrImportant = 0;

    /* Setup color table for mono DIBs */
    if (iDepth == 1) {
        pbmi = (BITMAPINFO *) pbmih;
        pbmi->bmiColors[1].rgbBlue = 255;
        pbmi->bmiColors[1].rgbGreen = 255;
        pbmi->bmiColors[1].rgbRed = 255;
    }

    /* Create a DIB with a bit pointer */
    hBitmap = CreateDIBSection(NULL,
                               (BITMAPINFO *) pbmih,
                               DIB_RGB_COLORS, (void **) ppbBits, NULL, 0);
    if (hBitmap == NULL) {
        ErrorF("winCreateDIBNativeGDI - CreateDIBSection () failed\n");
        return NULL;
    }

    /* Free the bitmap info header memory */
    if (ppbmi != NULL) {
        /* Store the address of the BMIH in the ppbmih parameter */
        *ppbmi = (BITMAPINFO *) pbmih;
    }
    else {
        free(pbmih);
        pbmih = NULL;
    }

    return hBitmap;
}

#if 0
static Bool
winBltExposedRegionsNativeGDI(ScreenPtr pScreen)
{

    return TRUE;
}
#endif

static Bool
winRedrawScreenNativeGDI(ScreenPtr pScreen)
{
    FatalError("winRedrawScreenNativeGDI\n");
    return TRUE;
}

static Bool
winRealizeInstalledPaletteNativeGDI(ScreenPtr pScreen)
{
    FatalError("winRealizeInstalledPaletteNativeGDI\n");
    return TRUE;
}

static Bool
winInstallColormapNativeGDI(ColormapPtr pColormap)
{
    FatalError("winInstallColormapNativeGDI\n");
    return TRUE;
}

static Bool
winStoreColorsNativeGDI(ColormapPtr pmap, int ndef, xColorItem * pdefs)
{
    FatalError("winStoreColorsNativeGDI\n");
    return TRUE;
}

static Bool
winCreateColormapNativeGDI(ColormapPtr pColormap)
{
    FatalError("winCreateColormapNativeGDI\n");
    return TRUE;
}

static Bool
winDestroyColormapNativeGDI(ColormapPtr pColormap)
{
    FatalError("winDestroyColormapNativeGDI\n");
    return TRUE;
}

/* Set engine specific funtions */
Bool
winSetEngineFunctionsNativeGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Set our pointers */
    pScreenPriv->pwinAllocateFB = winAllocateFBNativeGDI;
    pScreenPriv->pwinFreeFB = winFreeFBNativeGDI;
    pScreenPriv->pwinShadowUpdate = winShadowUpdateNativeGDI;
    pScreenPriv->pwinInitScreen = winInitScreenNativeGDI;
    pScreenPriv->pwinCloseScreen = winCloseScreenNativeGDI;
    pScreenPriv->pwinInitVisuals = winInitVisualsNativeGDI;
    pScreenPriv->pwinAdjustVideoMode = winAdjustVideoModeNativeGDI;
    if (pScreenInfo->fFullScreen)
        pScreenPriv->pwinCreateBoundingWindow =
            winCreateBoundingWindowFullScreen;
    else
        pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowWindowed;
    pScreenPriv->pwinFinishScreenInit = winFinishScreenInitNativeGDI;
    /*
     * WARNING: Do not set the BltExposedRegions procedure pointer to anything
     * other than NULL until a working painting procedure is in place.
     * Else, winWindowProc will get stuck in an infinite loop because
     * Windows expects the BeginPaint and EndPaint functions to be called
     * before a WM_PAINT message can be removed from the queue.  We are
     * using NULL here as a signal for winWindowProc that it should
     * not signal that the WM_PAINT message has been processed.
     */
    pScreenPriv->pwinBltExposedRegions = NULL;
    pScreenPriv->pwinActivateApp = winActivateAppNativeGDI;
    pScreenPriv->pwinRedrawScreen = winRedrawScreenNativeGDI;
    pScreenPriv->pwinRealizeInstalledPalette =
        winRealizeInstalledPaletteNativeGDI;
    pScreenPriv->pwinInstallColormap = winInstallColormapNativeGDI;
    pScreenPriv->pwinStoreColors = winStoreColorsNativeGDI;
    pScreenPriv->pwinCreateColormap = winCreateColormapNativeGDI;
    pScreenPriv->pwinDestroyColormap = winDestroyColormapNativeGDI;
    pScreenPriv->pwinHotKeyAltTab =
        (winHotKeyAltTabProcPtr) (void (*)(void)) NoopDDA;

    return TRUE;
}
@


1.5
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d347 1
a347 2
    pbmih = (BITMAPINFOHEADER *) malloc(sizeof(BITMAPINFOHEADER)
                                        + 256 * sizeof(RGBQUAD));
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d47 1
a47 1
 winCloseScreenNativeGDI(int nIndex, ScreenPtr pScreen);
d107 1
a107 1
winCloseScreenNativeGDI(int nIndex, ScreenPtr pScreen)
@


1.2
log
@Update to xserver 1.11.2
@
text
@a35 1

d41 1
a41 1
winAllocateFBNativeGDI (ScreenPtr pScreen);
d44 1
a44 2
winShadowUpdateNativeGDI (ScreenPtr pScreen, 
			  shadowBufPtr pBuf);
d47 1
a47 1
winCloseScreenNativeGDI (int nIndex, ScreenPtr pScreen);
d50 1
a50 1
winInitVisualsNativeGDI (ScreenPtr pScreen);
d53 1
a53 1
winAdjustVideoModeNativeGDI (ScreenPtr pScreen);
d57 1
a57 1
winBltExposedRegionsNativeGDI (ScreenPtr pScreen);
d61 1
a61 1
winActivateAppNativeGDI (ScreenPtr pScreen);
d64 1
a64 1
winRedrawScreenNativeGDI (ScreenPtr pScreen);
d67 1
a67 1
winRealizeInstalledPaletteNativeGDI (ScreenPtr pScreen);
d70 1
a70 1
winInstallColormapNativeGDI (ColormapPtr pColormap);
d73 1
a73 3
winStoreColorsNativeGDI (ColormapPtr pmap, 
			 int ndef,
			 xColorItem *pdefs);
d76 1
a76 1
winCreateColormapNativeGDI (ColormapPtr pColormap);
d79 1
a79 3
winDestroyColormapNativeGDI (ColormapPtr pColormap);


d82 1
a82 1
winAllocateFBNativeGDI (ScreenPtr pScreen)
d84 1
a84 1
  FatalError ("winAllocateFBNativeGDI\n");
d86 1
a86 1
  return TRUE;
d90 1
a90 1
winFreeFBNativeGDI (ScreenPtr pScreen)
d92 1
a92 1
  FatalError ("winFreeFBNativeGDI\n");
a94 1

d98 1
a98 1
  FatalError ("winInitScreenNativeGDI\n");
d107 1
a107 1
winCloseScreenNativeGDI (int nIndex, ScreenPtr pScreen)
d109 4
a112 2
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
d114 3
a116 1
  ErrorF ("winCloseScreenNativeGDI - Freeing screen resources\n");
d118 4
a121 3
  /* Flag that the screen is closed */
  pScreenPriv->fClosed = TRUE;
  pScreenPriv->fActive = FALSE;
d123 2
a124 4
  /* 
   * NOTE: mi doesn't use a CloseScreen procedure, so we do not
   * need to call a wrapped procedure here.
   */
d126 1
a126 8
  /* Delete the window property */
  RemoveProp (pScreenPriv->hwndScreen, WIN_SCR_PROP);
  
  ErrorF ("winCloseScreenNativeGDI - Destroying window\n");
  
  /* Delete tray icon, if we have one */
  if (!pScreenInfo->fNoTrayIcon)
    winDeleteNotifyIcon (pScreenPriv);
d128 8
a135 5
  /* Free the exit confirmation dialog box, if it exists */
  if (g_hDlgExit != NULL)
    {
      DestroyWindow (g_hDlgExit);
      g_hDlgExit = NULL;
d138 4
a141 5
  /* Kill our window */
  if (pScreenPriv->hwndScreen)
    {
      DestroyWindow (pScreenPriv->hwndScreen);
      pScreenPriv->hwndScreen = NULL;
d144 2
a145 2
  /* Invalidate our screeninfo's pointer to the screen */
  pScreenInfo->pScreen = NULL;
d147 2
a148 2
  /* Free the screen privates for this screen */
  free (pScreenPriv);
d150 1
a150 1
  ErrorF ("winCloseScreenNativeGDI - Returning\n");
d152 1
a152 1
  return TRUE;
a154 1

d156 1
a156 2
winShadowUpdateNativeGDI (ScreenPtr pScreen, 
			  shadowBufPtr pBuf)
d158 2
a159 2
  FatalError ("winShadowUpdateNativeGDI\n");
  return;
a161 1

d163 1
a163 1
winInitVisualsNativeGDI (ScreenPtr pScreen)
d165 2
a166 2
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
d168 2
a169 3
  /* Set the bitsPerRGB and bit masks */
  switch (pScreenInfo->dwDepth)
    {
d171 6
a176 6
      pScreenPriv->dwBitsPerRGB = 8;
      pScreenPriv->dwRedMask = 0x00FF0000;
      pScreenPriv->dwGreenMask = 0x0000FF00;
      pScreenPriv->dwBlueMask = 0x000000FF;
      break;
      
d178 6
a183 6
      pScreenPriv->dwBitsPerRGB = 6;
      pScreenPriv->dwRedMask = 0xF800;
      pScreenPriv->dwGreenMask = 0x07E0;
      pScreenPriv->dwBlueMask = 0x001F;
      break;
      
d185 6
a190 6
      pScreenPriv->dwBitsPerRGB = 5;
      pScreenPriv->dwRedMask = 0x7C00;
      pScreenPriv->dwGreenMask = 0x03E0;
      pScreenPriv->dwBlueMask = 0x001F;
      break;
      
d192 5
a196 5
      pScreenPriv->dwBitsPerRGB = 8;
      pScreenPriv->dwRedMask = 0;
      pScreenPriv->dwGreenMask = 0;
      pScreenPriv->dwBlueMask = 0;
      break;
d199 3
a201 3
      ErrorF ("winInitVisualsNativeGDI - Unknown screen depth\n");
      return FALSE;
      break;
d204 6
a209 7
  /* Tell the user how many bits per RGB we are using */
  ErrorF ("winInitVisualsNativeGDI - Using dwBitsPerRGB: %d\n",
	  (int) pScreenPriv->dwBitsPerRGB);

  /* Create a single visual according to the Windows screen depth */
  switch (pScreenInfo->dwDepth)
    {
d213 11
a223 12
      if (!miSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     TrueColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     TrueColor,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisuals - miSetVisualTypesAndMasks failed\n");
	  return FALSE;
	}
      break;
d226 12
a237 13
      ErrorF ("winInitVisuals - Calling miSetVisualTypesAndMasks\n");
      if (!miSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     StaticColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     StaticColor,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisuals - miSetVisualTypesAndMasks failed\n");
	  return FALSE;
	}
      break;
d240 2
a241 2
      ErrorF ("winInitVisualsNativeGDI - Unknown screen depth\n");
      return FALSE;
d245 1
a245 1
  ErrorF ("winInitVisualsNativeGDI - Returning\n");
d248 1
a248 1
  return TRUE;
a250 1

d253 1
a253 1
winAdjustVideoModeNativeGDI (ScreenPtr pScreen)
d255 4
a258 17
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  HDC			hdc = NULL;
  DWORD			dwBPP;
  
  hdc = GetDC (NULL);

  /* We're in serious trouble if we can't get a DC */
  if (hdc == NULL)
    {
      ErrorF ("winAdjustVideoModeNativeGDI - GetDC () failed\n");
      return FALSE;
    }

  /* Query GDI for current display depth */
  dwBPP = GetDeviceCaps (hdc, BITSPIXEL);
  pScreenInfo->dwDepth = GetDeviceCaps (hdc, PLANES);
d260 13
a272 1
  switch (pScreenInfo->dwDepth) {
d277 1
a277 1
      break;
d279 14
a292 14
      if (dwBPP == 32)
        pScreenInfo->dwDepth = 24;
      else
        pScreenInfo->dwDepth = dwBPP; 
      break;
  }

  /* GDI cannot change the screen depth, so we'll use GDI's depth */
  pScreenInfo->dwBPP = dwBPP;

  /* Release our DC */
  ReleaseDC (NULL, hdc);

  return TRUE;
d295 4
d300 26
a325 34
static Bool
winActivateAppNativeGDI (ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;

  /*
   * Are we active?
   * Are we fullscreen?
   */
  if (pScreenPriv != NULL
      && pScreenPriv->fActive
      && pScreenInfo->fFullScreen)
    {
      /*
       * Activating, attempt to bring our window 
       * to the top of the display
       */
      ShowWindow (pScreenPriv->hwndScreen, SW_RESTORE);
    }

  /*
   * Are we inactive?
   * Are we fullscreen?
   */
  if (pScreenPriv != NULL
      && !pScreenPriv->fActive
      && pScreenInfo->fFullScreen)
    {
      /*
       * Deactivating, stuff our window onto the
       * task bar.
       */
      ShowWindow (pScreenPriv->hwndScreen, SW_MINIMIZE);
d328 1
a328 1
  return TRUE;
a330 1

d332 2
a333 2
winCreateDIBNativeGDI (int iWidth, int iHeight, int iDepth,
		       BYTE **ppbBits, BITMAPINFO **ppbmi)
d335 58
a392 69
  BITMAPINFOHEADER	*pbmih = NULL;
  HBITMAP		hBitmap = NULL;
  BITMAPINFO		*pbmi = NULL;

  /* Don't create an invalid bitmap */
  if (iWidth == 0
      || iHeight == 0
      || iDepth == 0)
    {
      ErrorF ("\nwinCreateDIBNativeGDI - Invalid specs w %d h %d d %d\n\n",
	      iWidth, iHeight, iDepth);
      return NULL;
    }

  /* Allocate bitmap info header */
  pbmih = (BITMAPINFOHEADER*) malloc (sizeof (BITMAPINFOHEADER)
				      + 256 * sizeof (RGBQUAD));
  if (pbmih == NULL)
    {
      ErrorF ("winCreateDIBNativeGDI - malloc () failed\n");
      return FALSE;
    }
  ZeroMemory (pbmih, sizeof(BITMAPINFOHEADER) + 256 * sizeof (RGBQUAD));

  /* Describe bitmap to be created */
  pbmih->biSize = sizeof (BITMAPINFOHEADER);
  pbmih->biWidth = iWidth;
  pbmih->biHeight = -iHeight;
  pbmih->biPlanes = 1;
  pbmih->biBitCount = iDepth;
  pbmih->biCompression = BI_RGB;
  pbmih->biSizeImage = 0;
  pbmih->biXPelsPerMeter = 0;
  pbmih->biYPelsPerMeter = 0;
  pbmih->biClrUsed = 0;
  pbmih->biClrImportant = 0;

  /* Setup color table for mono DIBs */
  if (iDepth == 1)
    {
      pbmi = (BITMAPINFO*) pbmih;
      pbmi->bmiColors[1].rgbBlue = 255;
      pbmi->bmiColors[1].rgbGreen = 255;
      pbmi->bmiColors[1].rgbRed = 255;
    }

  /* Create a DIB with a bit pointer */
  hBitmap = CreateDIBSection (NULL,
			      (BITMAPINFO *) pbmih,
			      DIB_RGB_COLORS,
			      (void **) ppbBits,
			      NULL,
			      0);
  if (hBitmap == NULL)
    {
      ErrorF ("winCreateDIBNativeGDI - CreateDIBSection () failed\n");
      return NULL;
    }

  /* Free the bitmap info header memory */
  if (ppbmi != NULL)
    {
      /* Store the address of the BMIH in the ppbmih parameter */
      *ppbmi = (BITMAPINFO *) pbmih;
    }
  else
    {
      free (pbmih);
      pbmih = NULL;
d395 1
a395 1
  return hBitmap;
a397 1

d400 1
a400 1
winBltExposedRegionsNativeGDI (ScreenPtr pScreen)
d402 2
a403 2
  
  return TRUE;
a406 1

d408 1
a408 1
winRedrawScreenNativeGDI (ScreenPtr pScreen)
d410 2
a411 2
  FatalError ("winRedrawScreenNativeGDI\n");
  return TRUE;
a413 1

d415 1
a415 1
winRealizeInstalledPaletteNativeGDI (ScreenPtr pScreen)
d417 2
a418 2
  FatalError ("winRealizeInstalledPaletteNativeGDI\n");
  return TRUE;
a420 1

d422 1
a422 1
winInstallColormapNativeGDI (ColormapPtr pColormap)
d424 2
a425 2
  FatalError ("winInstallColormapNativeGDI\n");
  return TRUE;
a427 1

d429 1
a429 3
winStoreColorsNativeGDI (ColormapPtr pmap, 
			 int ndef,
			 xColorItem *pdefs)
d431 2
a432 2
  FatalError ("winStoreColorsNativeGDI\n");
  return TRUE;
a434 1

d436 1
a436 1
winCreateColormapNativeGDI (ColormapPtr pColormap)
d438 2
a439 2
  FatalError ("winCreateColormapNativeGDI\n");
  return TRUE;
a441 1

d443 1
a443 1
winDestroyColormapNativeGDI (ColormapPtr pColormap)
d445 2
a446 2
  FatalError ("winDestroyColormapNativeGDI\n");
  return TRUE;
a448 1

d451 1
a451 1
winSetEngineFunctionsNativeGDI (ScreenPtr pScreen)
d453 37
a489 35
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  
  /* Set our pointers */
  pScreenPriv->pwinAllocateFB = winAllocateFBNativeGDI;
  pScreenPriv->pwinFreeFB = winFreeFBNativeGDI;
  pScreenPriv->pwinShadowUpdate = winShadowUpdateNativeGDI;
  pScreenPriv->pwinInitScreen = winInitScreenNativeGDI;
  pScreenPriv->pwinCloseScreen = winCloseScreenNativeGDI;
  pScreenPriv->pwinInitVisuals = winInitVisualsNativeGDI;
  pScreenPriv->pwinAdjustVideoMode = winAdjustVideoModeNativeGDI;
  if (pScreenInfo->fFullScreen)
    pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowFullScreen;
  else
    pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowWindowed;
  pScreenPriv->pwinFinishScreenInit = winFinishScreenInitNativeGDI;
  /*
   * WARNING: Do not set the BltExposedRegions procedure pointer to anything
   * other than NULL until a working painting procedure is in place.
   * Else, winWindowProc will get stuck in an infinite loop because
   * Windows expects the BeginPaint and EndPaint functions to be called
   * before a WM_PAINT message can be removed from the queue.  We are
   * using NULL here as a signal for winWindowProc that it should
   * not signal that the WM_PAINT message has been processed.
   */
  pScreenPriv->pwinBltExposedRegions = NULL;
  pScreenPriv->pwinActivateApp = winActivateAppNativeGDI;
  pScreenPriv->pwinRedrawScreen = winRedrawScreenNativeGDI;
  pScreenPriv->pwinRealizeInstalledPalette = 
    winRealizeInstalledPaletteNativeGDI;
  pScreenPriv->pwinInstallColormap = winInstallColormapNativeGDI;
  pScreenPriv->pwinStoreColors = winStoreColorsNativeGDI;
  pScreenPriv->pwinCreateColormap = winCreateColormapNativeGDI;
  pScreenPriv->pwinDestroyColormap = winDestroyColormapNativeGDI;
  pScreenPriv->pwinHotKeyAltTab = (winHotKeyAltTabProcPtr) (void (*)(void))NoopDDA;
d491 1
a491 1
  return TRUE;
@


1.1
log
@Initial revision
@
text
@a37 7
 * External symbols
 */

extern HWND			g_hDlgExit;


/*
d95 12
d304 2
a305 17
  /* GDI cannot change the screen depth */
  if (pScreenInfo->dwBPP == WIN_DEFAULT_BPP)
    {
      /* No -depth parameter passed, let the user know the depth being used */
      ErrorF ("winAdjustVideoModeNativeGDI - Using Windows display "
	      "depth of %d bits per pixel, %d depth\n",
	      (int) dwBPP, (int) pScreenInfo->dwDepth);

      /* Use GDI's depth */
      pScreenInfo->dwBPP = dwBPP;
    }
  else if (dwBPP != pScreenInfo->dwBPP)
    {
      /* Warn user if GDI depth is different than -depth parameter */
      ErrorF ("winAdjustVideoModeNativeGDI - Command line bpp: %d, "\
	      "using bpp: %d\n",
	      (int) pScreenInfo->dwBPP, (int) dwBPP);
a306 4
      /* We'll use GDI's depth */
      pScreenInfo->dwBPP = dwBPP;
    }
  
d502 1
d504 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
