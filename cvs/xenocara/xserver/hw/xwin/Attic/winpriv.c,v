head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2010.12.05.15.36.10;	author matthieu;	state dead;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@/*
 * Export window information for the Windows-OpenGL GLX implementation.
 *
 * Authors: Alexander Gottwald
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include "winpriv.h"
#include "winwindow.h"

void
winCreateWindowsWindow (WindowPtr pWin);
/**
 * Return size and handles of a window.
 * If pWin is NULL, then the information for the root window is requested.
 */ 
extern void winGetWindowInfo(WindowPtr pWin, winWindowInfoPtr pWinInfo)
{
    /* Sanity check */
    if (pWinInfo == NULL)
        return;

    winDebug("%s:%d pWin=%p\n", __FUNCTION__, __LINE__, pWin);

    /* a real window was requested */
    if (pWin != NULL) 
    {
        /* Initialize the size information */
        RECT rect = {
            pWin->drawable.x,
            pWin->drawable.y,
            pWin->drawable.x + pWin->drawable.width,
            pWin->drawable.y + pWin->drawable.height
        }, rect_extends;
        /* Get the window and screen privates */
        ScreenPtr pScreen = pWin->drawable.pScreen;
        winPrivScreenPtr pWinScreen = winGetScreenPriv(pScreen);
        winScreenInfoPtr pScreenInfo = NULL;

        rect_extends = rect;
        OffsetRect(&rect_extends, -pWin->drawable.x, -pWin->drawable.y);

        if (pWinScreen == NULL) 
        {
            ErrorF("winGetWindowInfo: screen has no privates\n");
            return;
        }
        
        pWinInfo->hwnd = pWinScreen->hwndScreen;
        pWinInfo->hrgn = NULL;
        pWinInfo->rect = rect;
    

        pScreenInfo = pWinScreen->pScreenInfo;
#ifdef XWIN_MULTIWINDOW
        /* check for multiwindow mode */
        if (pScreenInfo->fMultiWindow)
        {
            winWindowPriv(pWin);

            if (pWinPriv == NULL)
            {
                ErrorF("winGetWindowInfo: window has no privates\n");
                return;
            }

            if (pWinPriv->hWnd == NULL)
            {
                winCreateWindowsWindow(pWin);
            }
            if (pWinPriv->hWnd != NULL) { 
                
                /* copy size and window handle */
                pWinInfo->rect = rect_extends;
                pWinInfo->hwnd = pWinPriv->hWnd;

                /* Copy window region */
                if (pWinInfo->hrgn)
                    DeleteObject(pWinInfo->hrgn);
                pWinInfo->hrgn = CreateRectRgn(0,0,0,0);
                CombineRgn(pWinInfo->hrgn, pWinPriv->hRgn, pWinPriv->hRgn, 
                        RGN_COPY);
            }
            
            return;
        }
#endif
#ifdef XWIN_MULTIWINDOWEXTWM
        /* check for multiwindow external wm mode */
        if (pScreenInfo->fMWExtWM)
        {
            win32RootlessWindowPtr pRLWinPriv
                = (win32RootlessWindowPtr) RootlessFrameForWindow (pWin, FALSE);

            if (pRLWinPriv == NULL) {
                ErrorF("winGetWindowInfo: window has no privates\n");
                return;
            }
            
            if (pRLWinPriv->hWnd != NULL)
            {
                /* copy size and window handle */
                pWinInfo->rect = rect_extends;
                pWinInfo->hwnd = pRLWinPriv->hWnd;
            }
            return;
        }
#endif
    } 
    else 
    {
        RECT rect = {0, 0, 0, 0};
        ScreenPtr pScreen = g_ScreenInfo[0].pScreen;
        winPrivScreenPtr pWinScreen = winGetScreenPriv(pScreen);

        pWinInfo->hwnd = NULL;
        pWinInfo->hrgn = NULL;
        pWinInfo->rect = rect;
        
        if (pWinScreen == NULL)
        {
            ErrorF("winGetWindowInfo: screen has no privates\n");
            return;
        }

        ErrorF("winGetWindowInfo: returning root window\n");

        pWinInfo->hwnd = pWinScreen->hwndScreen;
    }
    return;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
