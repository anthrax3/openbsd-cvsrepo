head	1.5;
access;
symbols
	OPENBSD_5_8:1.4.0.10
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.8
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.8
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.09.16.19.10.24;	author matthieu;	state dead;
branches;
next	1.4;
commitid	Te1daavkBLskZ8gc;

1.4
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *Copyright (C) 2003-2004 Harold L Hunt II All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL HAROLD L HUNT II BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of Harold L Hunt II
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from Harold L Hunt II.
 *
 * Authors:	Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include <stdio.h>
#include <stdlib.h>

void
 winClipboardDOStoUNIX(char *pszSrc, int iLength);
void
 winClipboardUNIXtoDOS(char **ppszData, int iLength);

/*
 * Convert \r\n to \n
 *
 * NOTE: This was heavily inspired by, Cygwin's
 * winsup/cygwin/fhandler.cc/fhandler_base::read ()
 */

void
winClipboardDOStoUNIX(char *pszSrc, int iLength)
{
    char *pszDest = pszSrc;
    char *pszEnd = pszSrc + iLength;

    /* Loop until the last character */
    while (pszSrc < pszEnd) {
        /* Copy the current source character to current destination character */
        *pszDest = *pszSrc;

        /* Advance to the next source character */
        pszSrc++;

        /* Don't advance the destination character if we need to drop an \r */
        if (*pszDest != '\r' || *pszSrc != '\n')
            pszDest++;
    }

    /* Move the terminating null */
    *pszDest = '\0';
}

/*
 * Convert \n to \r\n
 */

void
winClipboardUNIXtoDOS(char **ppszData, int iLength)
{
    int iNewlineCount = 0;
    char *pszSrc = *ppszData;
    char *pszEnd = pszSrc + iLength;
    char *pszDest = NULL, *pszDestBegin = NULL;

    winDebug("UNIXtoDOS () - Original data:'%s'\n", *ppszData);

    /* Count \n characters without leading \r */
    while (pszSrc < pszEnd) {
        /* Skip ahead two character if found set of \r\n */
        if (*pszSrc == '\r' && pszSrc + 1 < pszEnd && *(pszSrc + 1) == '\n') {
            pszSrc += 2;
            continue;
        }

        /* Increment the count if found naked \n */
        if (*pszSrc == '\n') {
            iNewlineCount++;
        }

        pszSrc++;
    }

    /* Return if no naked \n's */
    if (iNewlineCount == 0)
        return;

    /* Allocate a new string */
    pszDestBegin = pszDest = malloc(iLength + iNewlineCount + 1);

    /* Set source pointer to beginning of data string */
    pszSrc = *ppszData;

    /* Loop through all characters in source string */
    while (pszSrc < pszEnd) {
        /* Copy line endings that are already valid */
        if (*pszSrc == '\r' && pszSrc + 1 < pszEnd && *(pszSrc + 1) == '\n') {
            *pszDest = *pszSrc;
            *(pszDest + 1) = *(pszSrc + 1);
            pszDest += 2;
            pszSrc += 2;
            continue;
        }

        /* Add \r to naked \n's */
        if (*pszSrc == '\n') {
            *pszDest = '\r';
            *(pszDest + 1) = *pszSrc;
            pszDest += 2;
            pszSrc += 1;
            continue;
        }

        /* Copy normal characters */
        *pszDest = *pszSrc;
        pszSrc++;
        pszDest++;
    }

    /* Put terminating null at end of new string */
    *pszDest = '\0';

    /* Swap string pointers */
    free(*ppszData);
    *ppszData = pszDestBegin;

    winDebug("UNIXtoDOS () - Final string:'%s'\n", pszDestBegin);
}
@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d41 1
a41 1
 winClipboardUNIXtoDOS(unsigned char **ppszData, int iLength);
d78 1
a78 1
winClipboardUNIXtoDOS(unsigned char **ppszData, int iLength)
d81 3
a83 3
    unsigned char *pszSrc = *ppszData;
    unsigned char *pszEnd = pszSrc + iLength;
    unsigned char *pszDest = NULL, *pszDestBegin = NULL;
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d39 1
a39 1
winClipboardDOStoUNIX (char *pszSrc, int iLength);
d41 1
a41 1
winClipboardUNIXtoDOS (unsigned char **ppszData, int iLength);
d51 1
a51 1
winClipboardDOStoUNIX (char *pszSrc, int iLength)
d53 2
a54 2
  char			*pszDest = pszSrc;
  char			*pszEnd = pszSrc + iLength;
d56 11
a66 12
  /* Loop until the last character */
  while (pszSrc < pszEnd)
    {
      /* Copy the current source character to current destination character */
      *pszDest = *pszSrc;

      /* Advance to the next source character */
      pszSrc++;

      /* Don't advance the destination character if we need to drop an \r */
      if (*pszDest != '\r' || *pszSrc != '\n')
	pszDest++;
d69 2
a70 2
  /* Move the terminating null */
  *pszDest = '\0';
a72 1

d78 1
a78 1
winClipboardUNIXtoDOS (unsigned char **ppszData, int iLength)
d80 19
a98 22
  int			iNewlineCount = 0;
  unsigned char		*pszSrc = *ppszData;
  unsigned char		*pszEnd = pszSrc + iLength;
  unsigned char		*pszDest = NULL, *pszDestBegin = NULL;

  winDebug("UNIXtoDOS () - Original data:'%s'\n", *ppszData);

  /* Count \n characters without leading \r */
  while (pszSrc < pszEnd)
    {
      /* Skip ahead two character if found set of \r\n */
      if (*pszSrc == '\r' && pszSrc + 1 < pszEnd && *(pszSrc + 1) == '\n')
	{
	  pszSrc += 2;
	  continue;
	} 

      /* Increment the count if found naked \n */
      if (*pszSrc == '\n')
	{
	  iNewlineCount++;
	}
d100 1
a100 1
      pszSrc++;
d102 35
a136 38
  
  /* Return if no naked \n's */
  if (iNewlineCount == 0)
    return;

  /* Allocate a new string */
  pszDestBegin = pszDest = malloc (iLength + iNewlineCount + 1);

  /* Set source pointer to beginning of data string */
  pszSrc = *ppszData;

  /* Loop through all characters in source string */
  while (pszSrc < pszEnd)
    {
      /* Copy line endings that are already valid */
      if (*pszSrc == '\r' && pszSrc + 1 < pszEnd && *(pszSrc + 1) == '\n')
	{
	  *pszDest = *pszSrc;
	  *(pszDest + 1) = *(pszSrc + 1);
	  pszDest += 2;
	  pszSrc += 2;
	  continue;
	}

      /* Add \r to naked \n's */
      if (*pszSrc == '\n')
	{
	  *pszDest = '\r';
	  *(pszDest + 1) = *pszSrc;
	  pszDest += 2;
	  pszSrc += 1;
	  continue;
	}

      /* Copy normal characters */
      *pszDest = *pszSrc;
      pszSrc++;
      pszDest++;
d139 2
a140 2
  /* Put terminating null at end of new string */
  *pszDest = '\0';
d142 3
a144 3
  /* Swap string pointers */
  free (*ppszData);
  *ppszData = pszDestBegin;
d146 1
a146 1
  winDebug("UNIXtoDOS () - Final string:'%s'\n", pszDestBegin);
@


1.1
log
@Initial revision
@
text
@d87 1
a87 3
#if 0
  ErrorF ("UNIXtoDOS () - Original data:\n%s\n", *ppszData);
#endif
d154 1
a154 3
#if 0
  ErrorF ("UNIXtoDOS () - Final string:\n%s\n", pszDestBegin);
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
