head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Kensuke Matsuzaki
 *		Earle F. Philhower, III
 *		Harold L Hunt II
 */
/*
 * Look at hw/darwin/quartz/xpr/xprFrame.c and hw/darwin/quartz/cr/crFrame.c
 */
#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include <winuser.h>
#define _WINDOWSWM_SERVER_
#include <X11/extensions/windowswmstr.h>
#include "winmultiwindowclass.h"
#include <X11/Xatom.h>

/*
 * Constant defines
 */

#ifndef ULW_COLORKEY
#define ULW_COLORKEY	0x00000001
#endif
#ifndef ULW_ALPHA
#define ULW_ALPHA	0x00000002
#endif
#ifndef ULW_OPAQUE
#define ULW_OPAQUE	0x00000004
#endif
#define AC_SRC_ALPHA	0x01

/*
 * Local function
 */

DEFINE_ATOM_HELPER(AtmWindowsWmNativeHwnd, WINDOWSWM_NATIVE_HWND)
static void
winMWExtWMSetNativeProperty(RootlessWindowPtr pFrame);

/*
 * Global variables
 */

Bool g_fNoConfigureWindow = FALSE;

/*
 * Internal function to get the DIB format that is compatible with the screen
 * Fixme: Share code with winshadgdi.c
 */

static
Bool
winMWExtWMQueryDIBFormat(win32RootlessWindowPtr pRLWinPriv,
                         BITMAPINFOHEADER * pbmih)
{
    HBITMAP hbmp;

#if CYGMULTIWINDOW_DEBUG
    LPDWORD pdw = NULL;
#endif

    /* Create a memory bitmap compatible with the screen */
    hbmp = CreateCompatibleBitmap(pRLWinPriv->hdcScreen, 1, 1);
    if (hbmp == NULL) {
        ErrorF("winMWExtWMQueryDIBFormat - CreateCompatibleBitmap failed\n");
        return FALSE;
    }

    /* Initialize our bitmap info header */
    ZeroMemory(pbmih, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
    pbmih->biSize = sizeof(BITMAPINFOHEADER);

    /* Get the biBitCount */
    if (!GetDIBits(pRLWinPriv->hdcScreen,
                   hbmp, 0, 1, NULL, (BITMAPINFO *) pbmih, DIB_RGB_COLORS)) {
        ErrorF("winMWExtWMQueryDIBFormat - First call to GetDIBits failed\n");
        DeleteObject(hbmp);
        return FALSE;
    }

#if CYGMULTIWINDOW_DEBUG
    /* Get a pointer to bitfields */
    pdw = (DWORD *) ((CARD8 *) pbmih + sizeof(BITMAPINFOHEADER));

    winDebug("winMWExtWMQueryDIBFormat - First call masks: %08x %08x %08x\n",
             (unsigned int) pdw[0], (unsigned int) pdw[1],
             (unsigned int) pdw[2]);
#endif

    /* Get optimal color table, or the optimal bitfields */
    if (!GetDIBits(pRLWinPriv->hdcScreen,
                   hbmp, 0, 1, NULL, (BITMAPINFO *) pbmih, DIB_RGB_COLORS)) {
        ErrorF("winMWExtWMQueryDIBFormat - Second call to GetDIBits "
               "failed\n");
        DeleteObject(hbmp);
        return FALSE;
    }

    /* Free memory */
    DeleteObject(hbmp);

    return TRUE;
}

static HRGN
winMWExtWMCreateRgnFromRegion(RegionPtr pShape)
{
    int nRects;
    BoxPtr pRects, pEnd;
    HRGN hRgn, hRgnRect;

    if (pShape == NULL)
        return NULL;

    nRects = RegionNumRects(pShape);
    pRects = RegionRects(pShape);

    hRgn = CreateRectRgn(0, 0, 0, 0);
    if (hRgn == NULL) {
        ErrorF("winReshape - Initial CreateRectRgn (%d, %d, %d, %d) "
               "failed: %d\n", 0, 0, 0, 0, (int) GetLastError());
    }

    /* Loop through all rectangles in the X region */
    for (pEnd = pRects + nRects; pRects < pEnd; pRects++) {
        /* Create a Windows region for the X rectangle */
        hRgnRect = CreateRectRgn(pRects->x1,
                                 pRects->y1, pRects->x2, pRects->y2);
        if (hRgnRect == NULL) {
            ErrorF("winReshape - Loop CreateRectRgn (%d, %d, %d, %d) "
                   "failed: %d\n",
                   pRects->x1,
                   pRects->y1, pRects->x2, pRects->y2, (int) GetLastError());
        }

        /* Merge the Windows region with the accumulated region */
        if (CombineRgn(hRgn, hRgn, hRgnRect, RGN_OR) == ERROR) {
            ErrorF("winReshape - CombineRgn () failed: %d\n",
                   (int) GetLastError());
        }

        /* Delete the temporary Windows region */
        DeleteObject(hRgnRect);
    }

    return hRgn;
}

static void
InitWin32RootlessEngine(win32RootlessWindowPtr pRLWinPriv)
{
    pRLWinPriv->hdcScreen = GetDC(pRLWinPriv->hWnd);
    pRLWinPriv->hdcShadow = CreateCompatibleDC(pRLWinPriv->hdcScreen);
    pRLWinPriv->hbmpShadow = NULL;

    /* Allocate bitmap info header */
    pRLWinPriv->pbmihShadow =
        malloc(sizeof(BITMAPINFOHEADER)
               + 256 * sizeof(RGBQUAD));
    if (pRLWinPriv->pbmihShadow == NULL) {
        ErrorF("InitWin32RootlessEngine - malloc () failed\n");
        return;
    }

    /* Query the screen format */
    winMWExtWMQueryDIBFormat(pRLWinPriv, pRLWinPriv->pbmihShadow);
}

Bool
winMWExtWMCreateFrame(RootlessWindowPtr pFrame, ScreenPtr pScreen,
                      int newX, int newY, RegionPtr pShape)
{
#define CLASS_NAME_LENGTH 512
    Bool fResult = TRUE;
    win32RootlessWindowPtr pRLWinPriv;
    WNDCLASSEX wc;
    char pszClass[CLASS_NAME_LENGTH], pszWindowID[12];
    HICON hIcon;
    HICON hIconSmall;
    char *res_name, *res_class, *res_role;
    static int s_iWindowID = 0;

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMCreateFrame %d %d - %d %d\n",
             newX, newY, pFrame->width, pFrame->height);
#endif

    pRLWinPriv = malloc(sizeof(win32RootlessWindowRec));
    pRLWinPriv->pFrame = pFrame;
    pRLWinPriv->pfb = NULL;
    pRLWinPriv->hbmpShadow = NULL;
    pRLWinPriv->hdcShadow = NULL;
    pRLWinPriv->hdcScreen = NULL;
    pRLWinPriv->pbmihShadow = NULL;
    pRLWinPriv->fResized = TRUE;
    pRLWinPriv->fClose = FALSE;
    pRLWinPriv->fRestackingNow = FALSE;
    pRLWinPriv->fDestroyed = FALSE;
    pRLWinPriv->fMovingOrSizing = FALSE;

    // Store the implementation private frame ID
    pFrame->wid = (RootlessFrameID) pRLWinPriv;

    winSelectIcons(&hIcon, &hIconSmall);

    /* Set standard class name prefix so we can identify window easily */
    strncpy(pszClass, WINDOW_CLASS_X, sizeof(pszClass));

    if (winMultiWindowGetClassHint(pFrame->win, &res_name, &res_class)) {
        strncat(pszClass, "-", 1);
        strncat(pszClass, res_name, CLASS_NAME_LENGTH - strlen(pszClass));
        strncat(pszClass, "-", 1);
        strncat(pszClass, res_class, CLASS_NAME_LENGTH - strlen(pszClass));

        /* Check if a window class is provided by the WM_WINDOW_ROLE property,
         * if not use the WM_CLASS information.
         * For further information see:
         * http://tronche.com/gui/x/icccm/sec-5.html
         */
        if (winMultiWindowGetWindowRole(pFrame->win, &res_role)) {
            strcat(pszClass, "-");
            strcat(pszClass, res_role);
            free(res_role);
        }

        free(res_name);
        free(res_class);
    }

    /* Add incrementing window ID to make unique class name */
    snprintf(pszWindowID, sizeof(pszWindowID), "-%x", s_iWindowID++);
    pszWindowID[sizeof(pszWindowID) - 1] = 0;
    strcat(pszClass, pszWindowID);

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMCreateFrame - Creating class: %s\n", pszClass);
#endif

    /* Setup our window class */
    wc.cbSize = sizeof(wc);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = winMWExtWMWindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInstance;
    wc.hIcon = hIcon;
    wc.hIconSm = hIconSmall;
    wc.hCursor = 0;
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = pszClass;
    RegisterClassEx(&wc);

    /* Create the window */
    g_fNoConfigureWindow = TRUE;
    pRLWinPriv->hWnd = CreateWindowExA(WS_EX_TOOLWINDOW,        /* Extended styles */
                                       pszClass,        /* Class name */
                                       WINDOW_TITLE_X,  /* Window name */
                                       WS_POPUP | WS_CLIPCHILDREN, newX,        /* Horizontal position */
                                       newY,    /* Vertical position */
                                       pFrame->width,   /* Right edge */
                                       pFrame->height,  /* Bottom edge */
                                       (HWND) NULL,     /* No parent or owner window */
                                       (HMENU) NULL,    /* No menu */
                                       GetModuleHandle(NULL),   /* Instance handle */
                                       pRLWinPriv);     /* ScreenPrivates */
    if (pRLWinPriv->hWnd == NULL) {
        ErrorF("winMWExtWMCreateFrame - CreateWindowExA () failed: %d\n",
               (int) GetLastError());
        fResult = FALSE;
    }

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMCreateFrame - ShowWindow\n");
#endif

    //ShowWindow (pRLWinPriv->hWnd, SW_SHOWNOACTIVATE);
    g_fNoConfigureWindow = FALSE;

    if (pShape != NULL) {
        winMWExtWMReshapeFrame(pFrame->wid, pShape);
    }

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMCreateFrame - (%p) %p\n",
             pFrame->wid, pRLWinPriv->hWnd);
#if 0
    {
        WindowPtr pWin2 = NULL;
        win32RootlessWindowPtr pRLWinPriv2 = NULL;

        /* Check if the Windows window property for our X window pointer is valid */
        if ((pWin2 =
             (WindowPtr) GetProp(pRLWinPriv->hWnd, WIN_WINDOW_PROP)) != NULL) {
            pRLWinPriv2 =
                (win32RootlessWindowPtr) RootlessFrameForWindow(pWin2, FALSE);
        }
        winDebug("winMWExtWMCreateFrame2 (%08x) %08x\n",
                 pRLWinPriv2, pRLWinPriv2->hWnd);
        if (pRLWinPriv != pRLWinPriv2 || pRLWinPriv->hWnd != pRLWinPriv2->hWnd) {
            winDebug("Error param missmatch\n");
        }
    }
#endif
#endif

    winMWExtWMSetNativeProperty(pFrame);

    return fResult;
}

void
winMWExtWMDestroyFrame(RootlessFrameID wid)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
    HICON hIcon;
    HICON hIconSm;
    HMODULE hInstance;
    int iReturn;
    char pszClass[CLASS_NAME_LENGTH];

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMDestroyFrame (%p) %p\n",
             pRLWinPriv, pRLWinPriv->hWnd);
#if 0
    {
        WindowPtr pWin2 = NULL;
        win32RootlessWindowPtr pRLWinPriv2 = NULL;

        /* Check if the Windows window property for our X window pointer is valid */
        if ((pWin2 =
             (WindowPtr) GetProp(pRLWinPriv->hWnd, WIN_WINDOW_PROP)) != NULL) {
            pRLWinPriv2 =
                (win32RootlessWindowPtr) RootlessFrameForWindow(pWin2, FALSE);
        }
        winDebug("winMWExtWMDestroyFrame2 (%08x) %08x\n",
                 pRLWinPriv2, pRLWinPriv2->hWnd);
        if (pRLWinPriv != pRLWinPriv2 || pRLWinPriv->hWnd != pRLWinPriv2->hWnd) {
            winDebug("Error param missmatch\n");
            *(int *) 0 = 1;     //raise exseption
        }
    }
#endif
#endif

    /* Store the info we need to destroy after this window is gone */
    hInstance = (HINSTANCE) GetClassLongPtr(pRLWinPriv->hWnd, GCLP_HMODULE);
    hIcon = (HICON) SendMessage(pRLWinPriv->hWnd, WM_GETICON, ICON_BIG, 0);
    hIconSm = (HICON) SendMessage(pRLWinPriv->hWnd, WM_GETICON, ICON_SMALL, 0);
    iReturn = GetClassName(pRLWinPriv->hWnd, pszClass, CLASS_NAME_LENGTH);

    pRLWinPriv->fClose = TRUE;
    pRLWinPriv->fDestroyed = TRUE;

    /* Destroy the Windows window */
    DestroyWindow(pRLWinPriv->hWnd);

    /* Only if we were able to get the name */
    if (iReturn) {
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMDestroyFrame - Unregistering %s: ", pszClass);
#endif
        iReturn = UnregisterClass(pszClass, hInstance);
    }

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMDestroyFramew - Deleting Icon\n");
#endif

    winDestroyIcon(hIcon);
    winDestroyIcon(hIconSm);

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMDestroyFrame - done\n");
#endif
}

void
winMWExtWMMoveFrame(RootlessFrameID wid, ScreenPtr pScreen, int iNewX,
                    int iNewY)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
    RECT rcNew;
    DWORD dwExStyle;
    DWORD dwStyle;
    int iX, iY, iWidth, iHeight;

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMMoveFrame (%p) (%d %d)\n", pRLWinPriv, iNewX,
             iNewY);
#endif

    /* Get the Windows window style and extended style */
    dwExStyle = GetWindowLongPtr(pRLWinPriv->hWnd, GWL_EXSTYLE);
    dwStyle = GetWindowLongPtr(pRLWinPriv->hWnd, GWL_STYLE);

    /* Get the X and Y location of the X window */
    iX = iNewX + GetSystemMetrics(SM_XVIRTUALSCREEN);
    iY = iNewY + GetSystemMetrics(SM_YVIRTUALSCREEN);

    /* Get the height and width of the X window */
    iWidth = pRLWinPriv->pFrame->width;
    iHeight = pRLWinPriv->pFrame->height;

    /* Store the origin, height, and width in a rectangle structure */
    SetRect(&rcNew, iX, iY, iX + iWidth, iY + iHeight);

#ifdef CYGMULTIWINDOW_DEBUG
    winDebug("\tWindow {%d, %d, %d, %d}, {%d, %d}\n",
             rcNew.left, rcNew.top, rcNew.right, rcNew.bottom,
             rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
#endif
    /*
     * Calculate the required size of the Windows window rectangle,
     * given the size of the Windows window client area.
     */
    AdjustWindowRectEx(&rcNew, dwStyle, FALSE, dwExStyle);

#ifdef CYGMULTIWINDOW_DEBUG
    winDebug("\tAdjusted {%d, %d, %d, %d}, {%d, %d}\n",
             rcNew.left, rcNew.top, rcNew.right, rcNew.bottom,
             rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
#endif
    g_fNoConfigureWindow = TRUE;
    SetWindowPos(pRLWinPriv->hWnd, NULL, rcNew.left, rcNew.top, 0, 0,
                 SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
    g_fNoConfigureWindow = FALSE;
#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMMoveFrame (%p) done\n", pRLWinPriv);
#endif
}

void
winMWExtWMResizeFrame(RootlessFrameID wid, ScreenPtr pScreen,
                      int iNewX, int iNewY,
                      unsigned int uiNewWidth, unsigned int uiNewHeight,
                      unsigned int uiGravity)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
    RECT rcNew;
    RECT rcOld;
    DWORD dwExStyle;
    DWORD dwStyle;
    int iX, iY;

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMResizeFrame (%p) (%d %d)-(%d %d)\n",
             pRLWinPriv, iNewX, iNewY, uiNewWidth, uiNewHeight);
#endif

    pRLWinPriv->fResized = TRUE;

    /* Get the Windows window style and extended style */
    dwExStyle = GetWindowLongPtr(pRLWinPriv->hWnd, GWL_EXSTYLE);
    dwStyle = GetWindowLongPtr(pRLWinPriv->hWnd, GWL_STYLE);

    /* Get the X and Y location of the X window */
    iX = iNewX + GetSystemMetrics(SM_XVIRTUALSCREEN);
    iY = iNewY + GetSystemMetrics(SM_YVIRTUALSCREEN);

    /* Store the origin, height, and width in a rectangle structure */
    SetRect(&rcNew, iX, iY, iX + uiNewWidth, iY + uiNewHeight);

    /*
     * Calculate the required size of the Windows window rectangle,
     * given the size of the Windows window client area.
     */
    AdjustWindowRectEx(&rcNew, dwStyle, FALSE, dwExStyle);

    /* Get a rectangle describing the old Windows window */
    GetWindowRect(pRLWinPriv->hWnd, &rcOld);

    /* Check if the old rectangle and new rectangle are the same */
    if (!EqualRect(&rcNew, &rcOld)) {

        g_fNoConfigureWindow = TRUE;
        MoveWindow(pRLWinPriv->hWnd,
                   rcNew.left, rcNew.top,
                   rcNew.right - rcNew.left, rcNew.bottom - rcNew.top, TRUE);
        g_fNoConfigureWindow = FALSE;
    }
}

void
winMWExtWMRestackFrame(RootlessFrameID wid, RootlessFrameID nextWid)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
    win32RootlessWindowPtr pRLNextWinPriv = (win32RootlessWindowPtr) nextWid;

    winScreenPriv(pRLWinPriv->pFrame->win->drawable.pScreen);
    winScreenInfo *pScreenInfo = NULL;
    DWORD dwCurrentProcessID = GetCurrentProcessId();
    DWORD dwWindowProcessID = 0;
    HWND hWnd;
    Bool fFirst = TRUE;
    Bool fNeedRestack = TRUE;

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMRestackFrame (%p)\n", pRLWinPriv);
#endif

    if (pScreenPriv && pScreenPriv->fRestacking)
        return;

    if (pScreenPriv)
        pScreenInfo = pScreenPriv->pScreenInfo;

    pRLWinPriv->fRestackingNow = TRUE;

    /* Show window */
    if (!IsWindowVisible(pRLWinPriv->hWnd))
        ShowWindow(pRLWinPriv->hWnd, SW_SHOWNOACTIVATE);

    if (pRLNextWinPriv == NULL) {
#if CYGMULTIWINDOW_DEBUG
        winDebug("Win %08x is top\n", pRLWinPriv);
#endif
        pScreenPriv->widTop = wid;
        SetWindowPos(pRLWinPriv->hWnd, HWND_TOP,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }
    else if (winIsInternalWMRunning(pScreenInfo)) {
        /* using mulwinidow wm */
#if CYGMULTIWINDOW_DEBUG
        winDebug("Win %08x is not top\n", pRLWinPriv);
#endif
        for (hWnd = GetNextWindow(pRLWinPriv->hWnd, GW_HWNDPREV);
             fNeedRestack && hWnd != NULL;
             hWnd = GetNextWindow(hWnd, GW_HWNDPREV)) {
            GetWindowThreadProcessId(hWnd, &dwWindowProcessID);

            if ((dwWindowProcessID == dwCurrentProcessID)
                && GetProp(hWnd, WIN_WINDOW_PROP)) {
                if (hWnd == pRLNextWinPriv->hWnd) {
                    /* Enable interleave X window and Windows window */
                    if (!fFirst) {
#if CYGMULTIWINDOW_DEBUG
                        winDebug("raise: Insert after Win %08x\n",
                                 pRLNextWinPriv);
#endif
                        SetWindowPos(pRLWinPriv->hWnd, pRLNextWinPriv->hWnd,
                                     0, 0, 0, 0,
                                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                    }
                    else {
#if CYGMULTIWINDOW_DEBUG
                        winDebug("No change\n");
#endif
                    }
                    fNeedRestack = FALSE;
                    break;
                }
                if (fFirst)
                    fFirst = FALSE;
            }
        }

        for (hWnd = GetNextWindow(pRLWinPriv->hWnd, GW_HWNDNEXT);
             fNeedRestack && hWnd != NULL;
             hWnd = GetNextWindow(hWnd, GW_HWNDNEXT)) {
            GetWindowThreadProcessId(hWnd, &dwWindowProcessID);

            if ((dwWindowProcessID == dwCurrentProcessID)
                && GetProp(hWnd, WIN_WINDOW_PROP)) {
                if (hWnd == pRLNextWinPriv->hWnd) {
#if CYGMULTIWINDOW_DEBUG
                    winDebug("lower: Insert after Win %08x\n", pRLNextWinPriv);
#endif
                    SetWindowPos(pRLWinPriv->hWnd, pRLNextWinPriv->hWnd,
                                 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                    fNeedRestack = FALSE;
                    break;
                }
            }
        }
    }
    else {
        /* using general wm like twm, wmaker etc.
           Interleave X window and Windows window will cause problem. */
        SetWindowPos(pRLWinPriv->hWnd, pRLNextWinPriv->hWnd,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }
#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMRestackFrame - done (%p)\n", pRLWinPriv);
#endif

    pRLWinPriv->fRestackingNow = FALSE;
}

void
winMWExtWMReshapeFrame(RootlessFrameID wid, RegionPtr pShape)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
    HRGN hRgn, hRgnWindow, hRgnClient;
    RECT rcWindow, rcClient;

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMReshapeFrame (%p)\n", pRLWinPriv);
#endif

    hRgn = winMWExtWMCreateRgnFromRegion(pShape);

    /* Create region for non-client area */
    GetWindowRect(pRLWinPriv->hWnd, &rcWindow);
    GetClientRect(pRLWinPriv->hWnd, &rcClient);
    MapWindowPoints(pRLWinPriv->hWnd, HWND_DESKTOP, (LPPOINT) &rcClient, 2);
    OffsetRgn(hRgn, rcClient.left - rcWindow.left, rcClient.top - rcWindow.top);
    OffsetRect(&rcClient, -rcWindow.left, -rcWindow.top);
    OffsetRect(&rcWindow, -rcWindow.left, -rcWindow.top);
    hRgnWindow = CreateRectRgnIndirect(&rcWindow);
    hRgnClient = CreateRectRgnIndirect(&rcClient);
    CombineRgn(hRgnWindow, hRgnWindow, hRgnClient, RGN_DIFF);
    CombineRgn(hRgn, hRgnWindow, hRgn, RGN_OR);

    SetWindowRgn(pRLWinPriv->hWnd, hRgn, TRUE);

    DeleteObject(hRgnWindow);
    DeleteObject(hRgnClient);
}

void
winMWExtWMUnmapFrame(RootlessFrameID wid)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMUnmapFrame (%p)\n", pRLWinPriv);
#endif

    g_fNoConfigureWindow = TRUE;
    //ShowWindow (pRLWinPriv->hWnd, SW_MINIMIZE);
    ShowWindow(pRLWinPriv->hWnd, SW_HIDE);
    g_fNoConfigureWindow = FALSE;
}

/*
 * Fixme: Code sharing with winshadgdi.c and other engine support
 */
void
winMWExtWMStartDrawing(RootlessFrameID wid, char **pixelData, int *bytesPerRow)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
    winPrivScreenPtr pScreenPriv = NULL;
    winScreenInfo *pScreenInfo = NULL;
    ScreenPtr pScreen = NULL;
    DIBSECTION dibsection;
    Bool fReturn = TRUE;
    HDC hdcNew;
    HBITMAP hbmpNew;

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMStartDrawing (%p) %08x\n", pRLWinPriv,
             pRLWinPriv->fDestroyed);
#endif

    if (!pRLWinPriv->fDestroyed) {
        pScreen = pRLWinPriv->pFrame->win->drawable.pScreen;
        if (pScreen)
            pScreenPriv = winGetScreenPriv(pScreen);
        if (pScreenPriv)
            pScreenInfo = pScreenPriv->pScreenInfo;

#if CYGMULTIWINDOW_DEBUG
        winDebug("\tpScreenPriv %p\n", pScreenPriv);
        winDebug("\tpScreenInfo %p\n", pScreenInfo);
        winDebug("\t(%d, %d)\n", (int) pRLWinPriv->pFrame->width,
                 (int) pRLWinPriv->pFrame->height);
#endif
        if (pRLWinPriv->hdcScreen == NULL) {
            InitWin32RootlessEngine(pRLWinPriv);
        }

        if (pRLWinPriv->fResized) {
            /* width * bpp must be multiple of 4 to match 32bit alignment */
            int stridesize;
            int misalignment;

            pRLWinPriv->pbmihShadow->biWidth = pRLWinPriv->pFrame->width;
            pRLWinPriv->pbmihShadow->biHeight = -pRLWinPriv->pFrame->height;

            stridesize = pRLWinPriv->pFrame->width * (pScreenInfo->dwBPP >> 3);
            misalignment = stridesize & 3;
            if (misalignment != 0) {
                stridesize += 4 - misalignment;
                pRLWinPriv->pbmihShadow->biWidth =
                    stridesize / (pScreenInfo->dwBPP >> 3);
                winDebug("\tresizing to %d (was %d)\n",
                         pRLWinPriv->pbmihShadow->biWidth,
                         pRLWinPriv->pFrame->width);
            }

            hdcNew = CreateCompatibleDC(pRLWinPriv->hdcScreen);
            /* Create a DI shadow bitmap with a bit pointer */
            hbmpNew = CreateDIBSection(pRLWinPriv->hdcScreen,
                                       (BITMAPINFO *) pRLWinPriv->pbmihShadow,
                                       DIB_RGB_COLORS,
                                       (VOID **) &pRLWinPriv->pfb, NULL, 0);
            if (hbmpNew == NULL || pRLWinPriv->pfb == NULL) {
                ErrorF("winMWExtWMStartDrawing - CreateDIBSection failed\n");
                //return FALSE;
            }
            else {
#if CYGMULTIWINDOW_DEBUG
                winDebug("winMWExtWMStartDrawing - Shadow buffer allocated\n");
#endif
            }

            /* Get information about the bitmap that was allocated */
            GetObject(hbmpNew, sizeof(dibsection), &dibsection);

#if CYGMULTIWINDOW_DEBUG
            /* Print information about bitmap allocated */
            winDebug("winMWExtWMStartDrawing - Dibsection width: %d height: %d "
                     "depth: %d size image: %d\n",
                     (unsigned int) dibsection.dsBmih.biWidth,
                     (unsigned int) dibsection.dsBmih.biHeight,
                     (unsigned int) dibsection.dsBmih.biBitCount,
                     (unsigned int) dibsection.dsBmih.biSizeImage);
#endif

            /* Select the shadow bitmap into the shadow DC */
            SelectObject(hdcNew, hbmpNew);

#if CYGMULTIWINDOW_DEBUG
            winDebug("winMWExtWMStartDrawing - Attempting a shadow blit\n");
#endif

            /* Blit from the old shadow to the new shadow */
            fReturn = BitBlt(hdcNew,
                             0, 0,
                             pRLWinPriv->pFrame->width,
                             pRLWinPriv->pFrame->height, pRLWinPriv->hdcShadow,
                             0, 0, SRCCOPY);
            if (fReturn) {
#if CYGMULTIWINDOW_DEBUG
                winDebug("winMWExtWMStartDrawing - Shadow blit success\n");
#endif
            }
            else {
                ErrorF("winMWExtWMStartDrawing - Shadow blit failure\n");
            }

            /* Look for height weirdness */
            if (dibsection.dsBmih.biHeight < 0) {
                /* FIXME: Figure out why biHeight is sometimes negative */
                ErrorF("winMWExtWMStartDrawing - WEIRDNESS - "
                       "biHeight still negative: %d\n",
                       (int) dibsection.dsBmih.biHeight);
                ErrorF("winMWExtWMStartDrawing - WEIRDNESS - "
                       "Flipping biHeight sign\n");
                dibsection.dsBmih.biHeight = -dibsection.dsBmih.biHeight;
            }

            pRLWinPriv->dwWidthBytes = dibsection.dsBm.bmWidthBytes;

#if CYGMULTIWINDOW_DEBUG
            winDebug("winMWExtWMStartDrawing - bytesPerRow: %d\n",
                     (unsigned int) dibsection.dsBm.bmWidthBytes);
#endif

            /* Free the old shadow bitmap */
            DeleteObject(pRLWinPriv->hdcShadow);
            DeleteObject(pRLWinPriv->hbmpShadow);

            pRLWinPriv->hdcShadow = hdcNew;
            pRLWinPriv->hbmpShadow = hbmpNew;

            pRLWinPriv->fResized = FALSE;
#if CYGMULTIWINDOW_DEBUG && FALSE
            winDebug("winMWExtWMStartDrawing - 0x%08x %d\n",
                     (unsigned int) pRLWinPriv->pfb,
                     (unsigned int) dibsection.dsBm.bmWidthBytes);
#endif
        }
    }
    else {
        ErrorF("winMWExtWMStartDrawing - Already window was destroyed \n");
    }
#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMStartDrawing - done (%p) %p %d\n",
             pRLWinPriv,
             pRLWinPriv->pfb,
             (unsigned int) pRLWinPriv->dwWidthBytes);
#endif
    *pixelData = pRLWinPriv->pfb;
    *bytesPerRow = pRLWinPriv->dwWidthBytes;
}

void
winMWExtWMStopDrawing(RootlessFrameID wid, Bool fFlush)
{
#if 0
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
    BLENDFUNCTION bfBlend;
    SIZE szWin;
    POINT ptSrc;

#if CYGMULTIWINDOW_DEBUG || TRUE
    winDebug("winMWExtWMStopDrawing (%08x)\n", pRLWinPriv);
#endif
    szWin.cx = pRLWinPriv->dwWidth;
    szWin.cy = pRLWinPriv->dwHeight;
    ptSrc.x = 0;
    ptSrc.y = 0;
    bfBlend.BlendOp = AC_SRC_OVER;
    bfBlend.BlendFlags = 0;
    bfBlend.SourceConstantAlpha = 255;
    bfBlend.AlphaFormat = AC_SRC_ALPHA;

    if (!UpdateLayeredWindow(pRLWinPriv->hWnd,
                             NULL, NULL, &szWin,
                             pRLWinPriv->hdcShadow, &ptSrc,
                             0, &bfBlend, ULW_ALPHA)) {
        ErrorF("winMWExtWMStopDrawing - UpdateLayeredWindow failed\n");
    }
#endif
}

void
winMWExtWMUpdateRegion(RootlessFrameID wid, RegionPtr pDamage)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;

#if 0
    BLENDFUNCTION bfBlend;
    SIZE szWin;
    POINT ptSrc;
#endif
#if CYGMULTIWINDOW_DEBUG && 0
    winDebug("winMWExtWMUpdateRegion (%08x)\n", pRLWinPriv);
#endif
#if 0
    szWin.cx = pRLWinPriv->dwWidth;
    szWin.cy = pRLWinPriv->dwHeight;
    ptSrc.x = 0;
    ptSrc.y = 0;
    bfBlend.BlendOp = AC_SRC_OVER;
    bfBlend.BlendFlags = 0;
    bfBlend.SourceConstantAlpha = 255;
    bfBlend.AlphaFormat = AC_SRC_ALPHA;

    if (!UpdateLayeredWindow(pRLWinPriv->hWnd,
                             NULL, NULL, &szWin,
                             pRLWinPriv->hdcShadow, &ptSrc,
                             0, &bfBlend, ULW_ALPHA)) {
        LPVOID lpMsgBuf;

        /* Display a fancy error message */
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_SYSTEM |
                      FORMAT_MESSAGE_IGNORE_INSERTS,
                      NULL,
                      GetLastError(),
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPTSTR) &lpMsgBuf, 0, NULL);

        ErrorF("winMWExtWMUpdateRegion - UpdateLayeredWindow failed: %s\n",
               (LPSTR) lpMsgBuf);
        LocalFree(lpMsgBuf);
    }
#endif
    if (!g_fNoConfigureWindow)
        UpdateWindow(pRLWinPriv->hWnd);
}

void
winMWExtWMDamageRects(RootlessFrameID wid, int nCount, const BoxRec * pRects,
                      int shift_x, int shift_y)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
    const BoxRec *pEnd;

#if CYGMULTIWINDOW_DEBUG && 0
    winDebug("winMWExtWMDamageRects (%08x, %d, %08x, %d, %d)\n",
             pRLWinPriv, nCount, pRects, shift_x, shift_y);
#endif

    for (pEnd = pRects + nCount; pRects < pEnd; pRects++) {
        RECT rcDmg;

        rcDmg.left = pRects->x1 + shift_x;
        rcDmg.top = pRects->y1 + shift_y;
        rcDmg.right = pRects->x2 + shift_x;
        rcDmg.bottom = pRects->y2 + shift_y;

        InvalidateRect(pRLWinPriv->hWnd, &rcDmg, FALSE);
    }
}

void
winMWExtWMRootlessSwitchWindow(RootlessWindowPtr pFrame, WindowPtr oldWin)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) pFrame->wid;

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMRootlessSwitchWindow (%p) %p\n",
             pRLWinPriv, pRLWinPriv->hWnd);
#endif
    pRLWinPriv->pFrame = pFrame;
    pRLWinPriv->fResized = TRUE;

    /* Set the window extended style flags */
    SetWindowLongPtr(pRLWinPriv->hWnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW);

    /* Set the window standard style flags */
    SetWindowLongPtr(pRLWinPriv->hWnd, GWL_STYLE, WS_POPUP | WS_CLIPCHILDREN);

    DeleteProperty(serverClient, oldWin, AtmWindowsWmNativeHwnd());
    winMWExtWMSetNativeProperty(pFrame);
#if CYGMULTIWINDOW_DEBUG
#if 0
    {
        WindowPtr pWin2 = NULL;
        win32RootlessWindowPtr pRLWinPriv2 = NULL;

        /* Check if the Windows window property for our X window pointer is valid */
        if ((pWin2 =
             (WindowPtr) GetProp(pRLWinPriv->hWnd, WIN_WINDOW_PROP)) != NULL) {
            pRLWinPriv2 =
                (win32RootlessWindowPtr) RootlessFrameForWindow(pWin2, FALSE);
        }
        winDebug("winMWExtWMSwitchFrame2 (%08x) %08x\n",
                 pRLWinPriv2, pRLWinPriv2->hWnd);
        if (pRLWinPriv != pRLWinPriv2 || pRLWinPriv->hWnd != pRLWinPriv2->hWnd) {
            winDebug("Error param missmatch\n");
        }
    }
#endif
#endif
}

void
winMWExtWMCopyBytes(unsigned int width, unsigned int height,
                    const void *src, unsigned int srcRowBytes,
                    void *dst, unsigned int dstRowBytes)
{
#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMCopyBytes - Not implemented\n");
#endif
}

void
winMWExtWMCopyWindow(RootlessFrameID wid, int nDstRects,
                     const BoxRec * pDstRects, int nDx, int nDy)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
    const BoxRec *pEnd;
    RECT rcDmg;

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMCopyWindow (%p, %d, %p, %d, %d)\n",
             pRLWinPriv, nDstRects, pDstRects, nDx, nDy);
#endif

    for (pEnd = pDstRects + nDstRects; pDstRects < pEnd; pDstRects++) {
#if CYGMULTIWINDOW_DEBUG
        winDebug("BitBlt (%d, %d, %d, %d) (%d, %d)\n",
                 pDstRects->x1, pDstRects->y1,
                 pDstRects->x2 - pDstRects->x1,
                 pDstRects->y2 - pDstRects->y1,
                 pDstRects->x1 + nDx, pDstRects->y1 + nDy);
#endif

        if (!BitBlt(pRLWinPriv->hdcShadow,
                    pDstRects->x1, pDstRects->y1,
                    pDstRects->x2 - pDstRects->x1,
                    pDstRects->y2 - pDstRects->y1,
                    pRLWinPriv->hdcShadow,
                    pDstRects->x1 + nDx, pDstRects->y1 + nDy, SRCCOPY)) {
            ErrorF("winMWExtWMCopyWindow - BitBlt failed.\n");
        }

        rcDmg.left = pDstRects->x1;
        rcDmg.top = pDstRects->y1;
        rcDmg.right = pDstRects->x2;
        rcDmg.bottom = pDstRects->y2;

        InvalidateRect(pRLWinPriv->hWnd, &rcDmg, FALSE);
    }
#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMCopyWindow - done\n");
#endif
}

/*
 * winMWExtWMSetNativeProperty
 */

static void
winMWExtWMSetNativeProperty(RootlessWindowPtr pFrame)
{
    win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) pFrame->wid;
    long lData;

    /* FIXME: move this to WindowsWM extension */

    lData = (long) pRLWinPriv->hWnd;
    dixChangeWindowProperty(serverClient, pFrame->win, AtmWindowsWmNativeHwnd(),
                            XA_INTEGER, 32, PropModeReplace, 1, &lData, TRUE);
}
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a41 1
#include "dixevents.h"
d186 2
a187 2
        (BITMAPINFOHEADER *) malloc(sizeof(BITMAPINFOHEADER)
                                    + 256 * sizeof(RGBQUAD));
d216 1
a216 2
    pRLWinPriv =
        (win32RootlessWindowPtr) malloc(sizeof(win32RootlessWindowRec));
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d315 2
a316 2
    winDebug("winMWExtWMCreateFrame - (%08x) %08x\n",
             (int) pFrame->wid, (int) pRLWinPriv->hWnd);
d353 2
a354 2
    winDebug("winMWExtWMDestroyFrame (%08x) %08x\n",
             (int) pRLWinPriv, (int) pRLWinPriv->hWnd);
d419 1
a419 1
    winDebug("winMWExtWMMoveFrame (%08x) (%d %d)\n", (int) pRLWinPriv, iNewX,
d459 1
a459 1
    winDebug("winMWExtWMMoveFrame (%08x) done\n", (int) pRLWinPriv);
d477 2
a478 2
    winDebug("winMWExtWMResizeFrame (%08x) (%d %d)-(%d %d)\n",
             (int) pRLWinPriv, iNewX, iNewY, uiNewWidth, uiNewHeight);
d529 1
a529 1
    winDebug("winMWExtWMRestackFrame (%08x)\n", (int) pRLWinPriv);
d615 1
a615 1
    winDebug("winMWExtWMRestackFrame - done (%08x)\n", (int) pRLWinPriv);
d629 1
a629 1
    winDebug("winMWExtWMReshapeFrame (%08x)\n", (int) pRLWinPriv);
d658 1
a658 1
    winDebug("winMWExtWMUnmapFrame (%08x)\n", (int) pRLWinPriv);
d683 1
a683 1
    winDebug("winMWExtWMStartDrawing (%08x) %08x\n", (int) pRLWinPriv,
d695 2
a696 2
        winDebug("\tpScreenPriv %08X\n", (int) pScreenPriv);
        winDebug("\tpScreenInfo %08X\n", (int) pScreenInfo);
d811 3
a813 3
    winDebug("winMWExtWMStartDrawing - done (0x%08x) 0x%08x %d\n",
             (int) pRLWinPriv,
             (unsigned int) pRLWinPriv->pfb,
d927 2
a928 2
    winDebug("winMWExtWMRootlessSwitchWindow (%08x) %08x\n",
             (int) pRLWinPriv, (int) pRLWinPriv->hWnd);
d982 2
a983 2
    winDebug("winMWExtWMCopyWindow (%08x, %d, %08x, %d, %d)\n",
             (int) pRLWinPriv, nDstRects, (int) pDstRects, nDx, nDy);
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d234 1
a234 1
    winSelectIcons(pFrame->win, &hIcon, &hIconSmall);
d266 1
a266 1
    winDebug("winCreateWindowsWindow - Creating class: %s\n", pszClass);
d637 1
a637 1
    MapWindowPoints(pRLWinPriv->hWnd, HWND_DESKTOP, (LPPOINT) & rcClient, 2);
d728 1
a728 1
                                       (VOID **) & pRLWinPriv->pfb, NULL, 0);
d886 1
a886 1
                      (LPTSTR) & lpMsgBuf, 0, NULL);
@


1.5
log
@Update to xserver 1.11.2
@
text
@a45 1

d67 1
a67 1
winMWExtWMSetNativeProperty (RootlessWindowPtr pFrame);
d73 1
a73 1
Bool			g_fNoConfigureWindow = FALSE;
d82 2
a83 1
winMWExtWMQueryDIBFormat (win32RootlessWindowPtr pRLWinPriv, BITMAPINFOHEADER *pbmih)
d85 2
a86 1
  HBITMAP		hbmp;
d88 1
a88 1
  LPDWORD		pdw = NULL;
d90 6
a95 7
  
  /* Create a memory bitmap compatible with the screen */
  hbmp = CreateCompatibleBitmap (pRLWinPriv->hdcScreen, 1, 1);
  if (hbmp == NULL)
    {
      ErrorF ("winMWExtWMQueryDIBFormat - CreateCompatibleBitmap failed\n");
      return FALSE;
d97 11
a107 16
  
  /* Initialize our bitmap info header */
  ZeroMemory (pbmih, sizeof (BITMAPINFOHEADER) + 256 * sizeof (RGBQUAD));
  pbmih->biSize = sizeof (BITMAPINFOHEADER);

  /* Get the biBitCount */
  if (!GetDIBits (pRLWinPriv->hdcScreen,
		  hbmp,
		  0, 1,
		  NULL,
		  (BITMAPINFO*) pbmih,
		  DIB_RGB_COLORS))
    {
      ErrorF ("winMWExtWMQueryDIBFormat - First call to GetDIBits failed\n");
      DeleteObject (hbmp);
      return FALSE;
d111 2
a112 2
  /* Get a pointer to bitfields */
  pdw = (DWORD*) ((CARD8*)pbmih + sizeof (BITMAPINFOHEADER));
d114 3
a116 2
  winDebug ("winMWExtWMQueryDIBFormat - First call masks: %08x %08x %08x\n",
	  (unsigned int)pdw[0], (unsigned int)pdw[1], (unsigned int)pdw[2]);
d119 7
a125 12
  /* Get optimal color table, or the optimal bitfields */
  if (!GetDIBits (pRLWinPriv->hdcScreen,
		  hbmp,
		  0, 1,
		  NULL,
		  (BITMAPINFO*)pbmih,
		  DIB_RGB_COLORS))
    {
      ErrorF ("winMWExtWMQueryDIBFormat - Second call to GetDIBits "
	      "failed\n");
      DeleteObject (hbmp);
      return FALSE;
d128 4
a131 4
  /* Free memory */
  DeleteObject (hbmp);
  
  return TRUE;
d135 1
a135 1
winMWExtWMCreateRgnFromRegion (RegionPtr pShape)
d137 36
a172 15
  int		nRects;
  BoxPtr	pRects, pEnd;
  HRGN		hRgn, hRgnRect;

  if (pShape == NULL) return NULL;

  nRects = RegionNumRects(pShape);
  pRects = RegionRects(pShape);
  
  hRgn = CreateRectRgn (0, 0, 0, 0);
  if (hRgn == NULL)
    {
      ErrorF ("winReshape - Initial CreateRectRgn (%d, %d, %d, %d) "
	      "failed: %d\n",
	      0, 0, 0, 0, (int) GetLastError ());
d175 1
a175 31
  /* Loop through all rectangles in the X region */
  for (pEnd = pRects + nRects; pRects < pEnd; pRects++)
    {
      /* Create a Windows region for the X rectangle */
      hRgnRect = CreateRectRgn (pRects->x1,
				pRects->y1,
				pRects->x2,
				pRects->y2);
      if (hRgnRect == NULL)
	{
	  ErrorF ("winReshape - Loop CreateRectRgn (%d, %d, %d, %d) "
		  "failed: %d\n",
		  pRects->x1,
		  pRects->y1,
		  pRects->x2,
		  pRects->y2,
		  (int) GetLastError ());
	}
      
      /* Merge the Windows region with the accumulated region */
      if (CombineRgn (hRgn, hRgn, hRgnRect, RGN_OR) == ERROR)
	{
	  ErrorF ("winReshape - CombineRgn () failed: %d\n",
		  (int) GetLastError ());
	}
      
      /* Delete the temporary Windows region */
      DeleteObject (hRgnRect);
    }
  
  return hRgn;
d179 1
a179 1
InitWin32RootlessEngine (win32RootlessWindowPtr pRLWinPriv)
d181 11
a191 11
  pRLWinPriv->hdcScreen = GetDC (pRLWinPriv->hWnd);
  pRLWinPriv->hdcShadow = CreateCompatibleDC (pRLWinPriv->hdcScreen);
  pRLWinPriv->hbmpShadow = NULL;

  /* Allocate bitmap info header */
  pRLWinPriv->pbmihShadow = (BITMAPINFOHEADER*) malloc (sizeof (BITMAPINFOHEADER)
							+ 256 * sizeof (RGBQUAD));
  if (pRLWinPriv->pbmihShadow == NULL)
    {
      ErrorF ("InitWin32RootlessEngine - malloc () failed\n");
      return;
d193 3
a195 4
  
  /* Query the screen format */
  winMWExtWMQueryDIBFormat (pRLWinPriv,
				  pRLWinPriv->pbmihShadow);
d199 2
a200 2
winMWExtWMCreateFrame (RootlessWindowPtr pFrame, ScreenPtr pScreen,
			     int newX, int newY, RegionPtr pShape)
d203 106
a308 34
  Bool				fResult = TRUE;
  win32RootlessWindowPtr	pRLWinPriv;
  WNDCLASSEX			wc;
  char				pszClass[CLASS_NAME_LENGTH], pszWindowID[12];
  HICON				hIcon;
  HICON				hIconSmall;
  char				*res_name, *res_class, *res_role;
  static int			s_iWindowID = 0;
 
#if CYGMULTIWINDOW_DEBUG
  winDebug ("winMWExtWMCreateFrame %d %d - %d %d\n",
	  newX, newY, pFrame->width, pFrame->height);
#endif

  pRLWinPriv = (win32RootlessWindowPtr) malloc (sizeof (win32RootlessWindowRec));
  pRLWinPriv->pFrame = pFrame;
  pRLWinPriv->pfb = NULL;
  pRLWinPriv->hbmpShadow = NULL;
  pRLWinPriv->hdcShadow = NULL;
  pRLWinPriv->hdcScreen = NULL;
  pRLWinPriv->pbmihShadow = NULL;
  pRLWinPriv->fResized = TRUE;
  pRLWinPriv->fClose = FALSE;
  pRLWinPriv->fRestackingNow = FALSE;
  pRLWinPriv->fDestroyed = FALSE;
  pRLWinPriv->fMovingOrSizing = FALSE;
  
  // Store the implementation private frame ID
  pFrame->wid = (RootlessFrameID) pRLWinPriv;

  winSelectIcons(pFrame->win, &hIcon, &hIconSmall); 
  
  /* Set standard class name prefix so we can identify window easily */
  strncpy (pszClass, WINDOW_CLASS_X, sizeof(pszClass));
d310 2
a311 66
  if (winMultiWindowGetClassHint (pFrame->win, &res_name, &res_class))
    {
      strncat (pszClass, "-", 1);
      strncat (pszClass, res_name, CLASS_NAME_LENGTH - strlen (pszClass));
      strncat (pszClass, "-", 1);
      strncat (pszClass, res_class, CLASS_NAME_LENGTH - strlen (pszClass));
      
      /* Check if a window class is provided by the WM_WINDOW_ROLE property,
       * if not use the WM_CLASS information.
       * For further information see:
       * http://tronche.com/gui/x/icccm/sec-5.html
       */
      if (winMultiWindowGetWindowRole (pFrame->win, &res_role) )
	{
	  strcat (pszClass, "-");
	  strcat (pszClass, res_role);
	  free (res_role);
	}

      free (res_name);
      free (res_class);
    }

  /* Add incrementing window ID to make unique class name */
  snprintf (pszWindowID, sizeof(pszWindowID), "-%x", s_iWindowID++);
  pszWindowID[sizeof(pszWindowID)-1] = 0;
  strcat (pszClass, pszWindowID);

#if CYGMULTIWINDOW_DEBUG
  winDebug ("winCreateWindowsWindow - Creating class: %s\n", pszClass);
#endif

  /* Setup our window class */
  wc.cbSize = sizeof(wc);
  wc.style = CS_HREDRAW | CS_VREDRAW;
  wc.lpfnWndProc = winMWExtWMWindowProc;
  wc.cbClsExtra = 0;
  wc.cbWndExtra = 0;
  wc.hInstance = g_hInstance;
  wc.hIcon = hIcon;
  wc.hIconSm = hIconSmall;
  wc.hCursor = 0;
  wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
  wc.lpszMenuName = NULL;
  wc.lpszClassName = pszClass;
  RegisterClassEx (&wc);

  /* Create the window */
  g_fNoConfigureWindow = TRUE;
  pRLWinPriv->hWnd = CreateWindowExA (WS_EX_TOOLWINDOW,		/* Extended styles */
				      pszClass,			/* Class name */
				      WINDOW_TITLE_X,		/* Window name */
				      WS_POPUP | WS_CLIPCHILDREN,
				      newX,			/* Horizontal position */
				      newY,			/* Vertical position */
				      pFrame->width,		/* Right edge */ 
				      pFrame->height,		/* Bottom edge */
				      (HWND) NULL,		/* No parent or owner window */
				      (HMENU) NULL,		/* No menu */
				      GetModuleHandle (NULL),	/* Instance handle */
				      pRLWinPriv);		/* ScreenPrivates */
  if (pRLWinPriv->hWnd == NULL)
    {
      ErrorF ("winMWExtWMCreateFrame - CreateWindowExA () failed: %d\n",
	      (int) GetLastError ());
      fResult = FALSE;
d315 6
a320 2
  winDebug ("winMWExtWMCreateFrame - ShowWindow\n");
#endif
d322 11
a332 6
  //ShowWindow (pRLWinPriv->hWnd, SW_SHOWNOACTIVATE);
  g_fNoConfigureWindow = FALSE;
  
  if (pShape != NULL)
    {
      winMWExtWMReshapeFrame (pFrame->wid, pShape);
a333 21

#if CYGMULTIWINDOW_DEBUG
  winDebug ("winMWExtWMCreateFrame - (%08x) %08x\n",
	  (int) pFrame->wid, (int) pRLWinPriv->hWnd);
#if 0
  {
   WindowPtr		pWin2 = NULL;
   win32RootlessWindowPtr pRLWinPriv2 = NULL;

   /* Check if the Windows window property for our X window pointer is valid */
   if ((pWin2 = (WindowPtr)GetProp (pRLWinPriv->hWnd, WIN_WINDOW_PROP)) != NULL)
     {
       pRLWinPriv2 = (win32RootlessWindowPtr) RootlessFrameForWindow (pWin2, FALSE);
     }
   winDebug ("winMWExtWMCreateFrame2 (%08x) %08x\n",
	   pRLWinPriv2, pRLWinPriv2->hWnd);
   if (pRLWinPriv != pRLWinPriv2 || pRLWinPriv->hWnd != pRLWinPriv2->hWnd)
     {
       winDebug ("Error param missmatch\n");
     }
 }
d337 1
a337 1
  winMWExtWMSetNativeProperty (pFrame);
d339 1
a339 1
  return fResult;
d343 1
a343 1
winMWExtWMDestroyFrame (RootlessFrameID wid)
d345 6
a350 6
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
  HICON			hIcon;
  HICON			hIconSm;
  HMODULE		hInstance;
  int			iReturn;
  char			pszClass[CLASS_NAME_LENGTH];
d353 2
a354 2
  winDebug ("winMWExtWMDestroyFrame (%08x) %08x\n",
	  (int) pRLWinPriv, (int) pRLWinPriv->hWnd);
d356 3
a358 3
 {
   WindowPtr		pWin2 = NULL;
   win32RootlessWindowPtr pRLWinPriv2 = NULL;
d360 13
a372 13
   /* Check if the Windows window property for our X window pointer is valid */
   if ((pWin2 = (WindowPtr)GetProp (pRLWinPriv->hWnd, WIN_WINDOW_PROP)) != NULL)
     {
       pRLWinPriv2 = (win32RootlessWindowPtr) RootlessFrameForWindow (pWin2, FALSE);
     }
   winDebug ("winMWExtWMDestroyFrame2 (%08x) %08x\n",
	   pRLWinPriv2, pRLWinPriv2->hWnd);
   if (pRLWinPriv != pRLWinPriv2 || pRLWinPriv->hWnd != pRLWinPriv2->hWnd)
     {
       winDebug ("Error param missmatch\n");
       *(int*)0 = 1;//raise exseption
     }
 }
d376 5
a380 5
  /* Store the info we need to destroy after this window is gone */
  hInstance = (HINSTANCE) GetClassLongPtr (pRLWinPriv->hWnd, GCLP_HMODULE);
  hIcon = (HICON)SendMessage(pRLWinPriv->hWnd, WM_GETICON, ICON_BIG, 0);
  hIconSm = (HICON)SendMessage(pRLWinPriv->hWnd, WM_GETICON, ICON_SMALL, 0);
  iReturn = GetClassName (pRLWinPriv->hWnd, pszClass, CLASS_NAME_LENGTH);
d382 2
a383 2
  pRLWinPriv->fClose = TRUE;
  pRLWinPriv->fDestroyed = TRUE;
d385 2
a386 2
  /* Destroy the Windows window */
  DestroyWindow (pRLWinPriv->hWnd);
d388 2
a389 3
  /* Only if we were able to get the name */
  if (iReturn)
    { 
d391 1
a391 1
      winDebug ("winMWExtWMDestroyFrame - Unregistering %s: ", pszClass);
d393 1
a393 1
      iReturn = UnregisterClass (pszClass, hInstance);
d397 1
a397 1
  winDebug ("winMWExtWMDestroyFramew - Deleting Icon\n");
d400 2
a401 2
  winDestroyIcon(hIcon);
  winDestroyIcon(hIconSm);
d404 1
a404 1
  winDebug ("winMWExtWMDestroyFrame - done\n");
d409 2
a410 1
winMWExtWMMoveFrame (RootlessFrameID wid, ScreenPtr pScreen, int iNewX, int iNewY)
d412 5
a416 5
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
  RECT rcNew;
  DWORD dwExStyle;
  DWORD dwStyle;
  int iX, iY, iWidth, iHeight;
d419 2
a420 1
  winDebug ("winMWExtWMMoveFrame (%08x) (%d %d)\n", (int) pRLWinPriv, iNewX, iNewY);
d423 3
a425 3
  /* Get the Windows window style and extended style */
  dwExStyle = GetWindowLongPtr (pRLWinPriv->hWnd, GWL_EXSTYLE);
  dwStyle = GetWindowLongPtr (pRLWinPriv->hWnd, GWL_STYLE);
d427 3
a429 3
  /* Get the X and Y location of the X window */
  iX = iNewX + GetSystemMetrics (SM_XVIRTUALSCREEN);
  iY = iNewY + GetSystemMetrics (SM_YVIRTUALSCREEN);
d431 3
a433 3
  /* Get the height and width of the X window */
  iWidth = pRLWinPriv->pFrame->width;
  iHeight = pRLWinPriv->pFrame->height;
d435 2
a436 2
  /* Store the origin, height, and width in a rectangle structure */
  SetRect (&rcNew, iX, iY, iX + iWidth, iY + iHeight);
d439 9
a447 9
          winDebug("\tWindow {%d, %d, %d, %d}, {%d, %d}\n", 
              rcNew.left, rcNew.top, rcNew.right, rcNew.bottom,
              rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
#endif
  /*
   * Calculate the required size of the Windows window rectangle,
   * given the size of the Windows window client area.
   */
  AdjustWindowRectEx (&rcNew, dwStyle, FALSE, dwExStyle);
d450 8
a457 8
          winDebug("\tAdjusted {%d, %d, %d, %d}, {%d, %d}\n", 
              rcNew.left, rcNew.top, rcNew.right, rcNew.bottom,
              rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
#endif
  g_fNoConfigureWindow = TRUE;
  SetWindowPos (pRLWinPriv->hWnd, NULL, rcNew.left, rcNew.top, 0, 0,
		SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
  g_fNoConfigureWindow = FALSE;
d459 1
a459 1
  winDebug ("winMWExtWMMoveFrame (%08x) done\n", (int) pRLWinPriv);
d464 4
a467 4
winMWExtWMResizeFrame (RootlessFrameID wid, ScreenPtr pScreen,
			     int iNewX, int iNewY,
			     unsigned int uiNewWidth, unsigned int uiNewHeight,
			     unsigned int uiGravity)
d469 6
a474 6
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
  RECT rcNew;
  RECT rcOld;
  DWORD dwExStyle;
  DWORD dwStyle;
  int iX, iY;
d477 2
a478 2
  winDebug ("winMWExtWMResizeFrame (%08x) (%d %d)-(%d %d)\n",
	  (int) pRLWinPriv, iNewX, iNewY, uiNewWidth, uiNewHeight);
d481 1
a481 1
  pRLWinPriv->fResized = TRUE;
d483 3
a485 3
  /* Get the Windows window style and extended style */
  dwExStyle = GetWindowLongPtr (pRLWinPriv->hWnd, GWL_EXSTYLE);
  dwStyle = GetWindowLongPtr (pRLWinPriv->hWnd, GWL_STYLE);
d487 3
a489 3
  /* Get the X and Y location of the X window */
  iX = iNewX + GetSystemMetrics (SM_XVIRTUALSCREEN);
  iY = iNewY + GetSystemMetrics (SM_YVIRTUALSCREEN);
d491 2
a492 2
  /* Store the origin, height, and width in a rectangle structure */
  SetRect (&rcNew, iX, iY, iX + uiNewWidth, iY + uiNewHeight);
d494 5
a498 5
  /*
   * Calculate the required size of the Windows window rectangle,
   * given the size of the Windows window client area.
   */
  AdjustWindowRectEx (&rcNew, dwStyle, FALSE, dwExStyle);
d500 2
a501 2
  /* Get a rectangle describing the old Windows window */
  GetWindowRect (pRLWinPriv->hWnd, &rcOld);
d503 2
a504 3
  /* Check if the old rectangle and new rectangle are the same */
  if (!EqualRect (&rcNew, &rcOld))
    {
d506 5
a510 6
      g_fNoConfigureWindow = TRUE;
      MoveWindow (pRLWinPriv->hWnd,
		  rcNew.left, rcNew.top,
		  rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
		  TRUE);
      g_fNoConfigureWindow = FALSE;
d515 1
a515 1
winMWExtWMRestackFrame (RootlessFrameID wid, RootlessFrameID nextWid)
d517 11
a527 9
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
  win32RootlessWindowPtr pRLNextWinPriv = (win32RootlessWindowPtr) nextWid;
  winScreenPriv(pRLWinPriv->pFrame->win->drawable.pScreen);
  winScreenInfo *pScreenInfo = NULL;
  DWORD dwCurrentProcessID = GetCurrentProcessId ();
  DWORD dwWindowProcessID = 0;
  HWND hWnd;
  Bool fFirst = TRUE;
  Bool fNeedRestack = TRUE;
d529 1
a529 1
  winDebug ("winMWExtWMRestackFrame (%08x)\n", (int) pRLWinPriv);
d532 2
a533 1
  if (pScreenPriv->fRestacking) return;
d535 2
a536 1
  if (pScreenPriv) pScreenInfo = pScreenPriv->pScreenInfo;
d538 1
a538 1
  pRLWinPriv->fRestackingNow = TRUE;
d540 3
a542 3
  /* Show window */
  if(!IsWindowVisible (pRLWinPriv->hWnd))
    ShowWindow (pRLWinPriv->hWnd, SW_SHOWNOACTIVATE);
d544 1
a544 2
  if (pRLNextWinPriv == NULL)
    {
d546 1
a546 1
      winDebug ("Win %08x is top\n", pRLWinPriv);
d548 3
a550 3
      pScreenPriv->widTop = wid;
      SetWindowPos (pRLWinPriv->hWnd, HWND_TOP,
		    0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);
d552 44
a595 3
  else if (winIsInternalWMRunning(pScreenInfo))
    {
      /* using mulwinidow wm */
d597 1
a597 1
      winDebug ("Win %08x is not top\n", pRLWinPriv);
d599 8
a606 56
      for (hWnd = GetNextWindow (pRLWinPriv->hWnd, GW_HWNDPREV);
	   fNeedRestack && hWnd != NULL;
	   hWnd = GetNextWindow (hWnd, GW_HWNDPREV))
	{
	  GetWindowThreadProcessId (hWnd, &dwWindowProcessID);

	  if ((dwWindowProcessID == dwCurrentProcessID)
	      && GetProp (hWnd, WIN_WINDOW_PROP))
	    {
	      if (hWnd == pRLNextWinPriv->hWnd)
		{
		  /* Enable interleave X window and Windows window */
		  if (!fFirst)
		    {
#if CYGMULTIWINDOW_DEBUG
		      winDebug ("raise: Insert after Win %08x\n", pRLNextWinPriv);
#endif
		      SetWindowPos (pRLWinPriv->hWnd, pRLNextWinPriv->hWnd,
				    0, 0, 0, 0,
				    SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);
		    }
		  else
		    {
#if CYGMULTIWINDOW_DEBUG
		      winDebug ("No change\n");
#endif
		    }
		  fNeedRestack = FALSE;
		  break;
		}
	      if (fFirst) fFirst = FALSE;
	    }
	}

      for (hWnd = GetNextWindow (pRLWinPriv->hWnd, GW_HWNDNEXT);
	   fNeedRestack && hWnd != NULL;
	   hWnd = GetNextWindow (hWnd, GW_HWNDNEXT))
	{
	  GetWindowThreadProcessId (hWnd, &dwWindowProcessID);

	  if ((dwWindowProcessID == dwCurrentProcessID)
	      && GetProp (hWnd, WIN_WINDOW_PROP))
	    {
	      if (hWnd == pRLNextWinPriv->hWnd)
		{
#if CYGMULTIWINDOW_DEBUG
		  winDebug ("lower: Insert after Win %08x\n", pRLNextWinPriv);
#endif
		  SetWindowPos (pRLWinPriv->hWnd, pRLNextWinPriv->hWnd,
				0, 0, 0, 0,
				SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);
		  fNeedRestack = FALSE;
		  break;
		}
	    }
	}
d608 5
a612 9
  else
    {
      /* using general wm like twm, wmaker etc.
	 Interleave X window and Windows window will cause problem. */
      SetWindowPos (pRLWinPriv->hWnd, pRLNextWinPriv->hWnd,
		    0, 0, 0, 0,
		    SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);
#if 0
#endif
d615 1
a615 1
  winDebug ("winMWExtWMRestackFrame - done (%08x)\n", (int) pRLWinPriv);
d618 1
a618 1
  pRLWinPriv->fRestackingNow = FALSE;
d622 1
a622 1
winMWExtWMReshapeFrame (RootlessFrameID wid, RegionPtr pShape)
d624 3
a626 20
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
  HRGN hRgn, hRgnWindow, hRgnClient;
  RECT rcWindow, rcClient;
#if CYGMULTIWINDOW_DEBUG
  winDebug ("winMWExtWMReshapeFrame (%08x)\n", (int) pRLWinPriv);
#endif

  hRgn = winMWExtWMCreateRgnFromRegion (pShape);
  
  /* Create region for non-client area */
  GetWindowRect (pRLWinPriv->hWnd, &rcWindow);
  GetClientRect (pRLWinPriv->hWnd, &rcClient);
  MapWindowPoints (pRLWinPriv->hWnd, HWND_DESKTOP, (LPPOINT)&rcClient, 2);
  OffsetRgn (hRgn, rcClient.left - rcWindow.left, rcClient.top - rcWindow.top);
  OffsetRect (&rcClient, -rcWindow.left, -rcWindow.top);
  OffsetRect (&rcWindow, -rcWindow.left, -rcWindow.top);
  hRgnWindow = CreateRectRgnIndirect (&rcWindow);
  hRgnClient = CreateRectRgnIndirect (&rcClient);
  CombineRgn (hRgnWindow, hRgnWindow, hRgnClient, RGN_DIFF);
  CombineRgn (hRgn, hRgnWindow, hRgn, RGN_OR);
d628 5
d634 11
a644 1
  SetWindowRgn (pRLWinPriv->hWnd, hRgn, TRUE);
d646 4
a649 2
  DeleteObject (hRgnWindow);
  DeleteObject (hRgnClient);
d653 1
a653 1
winMWExtWMUnmapFrame (RootlessFrameID wid)
d655 2
a656 1
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
d658 1
a658 1
  winDebug ("winMWExtWMUnmapFrame (%08x)\n", (int) pRLWinPriv);
d661 4
a664 4
  g_fNoConfigureWindow = TRUE;
  //ShowWindow (pRLWinPriv->hWnd, SW_MINIMIZE);
  ShowWindow (pRLWinPriv->hWnd, SW_HIDE);
  g_fNoConfigureWindow = FALSE;
d671 1
a671 1
winMWExtWMStartDrawing (RootlessFrameID wid, char **pixelData, int *bytesPerRow)
d673 9
a681 8
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
  winPrivScreenPtr	pScreenPriv = NULL;
  winScreenInfo		*pScreenInfo = NULL;
  ScreenPtr		pScreen = NULL;
  DIBSECTION		dibsection;
  Bool			fReturn = TRUE;
  HDC			hdcNew;
  HBITMAP		hbmpNew;
d683 2
a684 1
  winDebug ("winMWExtWMStartDrawing (%08x) %08x\n", (int) pRLWinPriv, pRLWinPriv->fDestroyed);
d687 113
a799 121
  if (!pRLWinPriv->fDestroyed)
    {
      pScreen = pRLWinPriv->pFrame->win->drawable.pScreen;
      if (pScreen) pScreenPriv = winGetScreenPriv(pScreen);
      if (pScreenPriv) pScreenInfo = pScreenPriv->pScreenInfo;
      
#if CYGMULTIWINDOW_DEBUG
      winDebug ("\tpScreenPriv %08X\n", (int) pScreenPriv);
      winDebug ("\tpScreenInfo %08X\n", (int) pScreenInfo);
      winDebug ("\t(%d, %d)\n", (int)pRLWinPriv->pFrame->width,
		(int) pRLWinPriv->pFrame->height);
#endif
      if (pRLWinPriv->hdcScreen == NULL)
	{
	  InitWin32RootlessEngine (pRLWinPriv);
	}
      
      if (pRLWinPriv->fResized)
	{
          /* width * bpp must be multiple of 4 to match 32bit alignment */
	  int stridesize;
	  int misalignment;
         
	  pRLWinPriv->pbmihShadow->biWidth = pRLWinPriv->pFrame->width;
	  pRLWinPriv->pbmihShadow->biHeight = -pRLWinPriv->pFrame->height;
 
	  stridesize = pRLWinPriv->pFrame->width * (pScreenInfo->dwBPP >> 3);
	  misalignment = stridesize & 3; 
	  if (misalignment != 0)
	  {
	    stridesize += 4 - misalignment;
	    pRLWinPriv->pbmihShadow->biWidth = stridesize / (pScreenInfo->dwBPP >> 3);
	    winDebug("\tresizing to %d (was %d)\n", 
		    pRLWinPriv->pbmihShadow->biWidth, pRLWinPriv->pFrame->width);
	  }
	  
	  hdcNew = CreateCompatibleDC (pRLWinPriv->hdcScreen);
	  /* Create a DI shadow bitmap with a bit pointer */
	  hbmpNew = CreateDIBSection (pRLWinPriv->hdcScreen,
				      (BITMAPINFO *) pRLWinPriv->pbmihShadow,
				      DIB_RGB_COLORS,
				      (VOID**) &pRLWinPriv->pfb,
				      NULL,
				      0);
	  if (hbmpNew == NULL || pRLWinPriv->pfb == NULL)
	    {
	      ErrorF ("winMWExtWMStartDrawing - CreateDIBSection failed\n");
	      //return FALSE;
	    }
	  else
	    {
#if CYGMULTIWINDOW_DEBUG
	      winDebug ("winMWExtWMStartDrawing - Shadow buffer allocated\n");
#endif
	    }
	  
	  /* Get information about the bitmap that was allocated */
	  GetObject (hbmpNew, sizeof (dibsection), &dibsection);
	  
#if CYGMULTIWINDOW_DEBUG
	  /* Print information about bitmap allocated */
	  winDebug ("winMWExtWMStartDrawing - Dibsection width: %d height: %d "
		    "depth: %d size image: %d\n",
		    (unsigned int)dibsection.dsBmih.biWidth,
		    (unsigned int)dibsection.dsBmih.biHeight,
		    (unsigned int)dibsection.dsBmih.biBitCount,
		    (unsigned int)dibsection.dsBmih.biSizeImage);
#endif
	  
	  /* Select the shadow bitmap into the shadow DC */
	  SelectObject (hdcNew, hbmpNew);
	  
#if CYGMULTIWINDOW_DEBUG
	  winDebug ("winMWExtWMStartDrawing - Attempting a shadow blit\n");
#endif
	  
	  /* Blit from the old shadow to the new shadow */
	  fReturn = BitBlt (hdcNew,
			    0, 0,
			    pRLWinPriv->pFrame->width, pRLWinPriv->pFrame->height,
			    pRLWinPriv->hdcShadow,
			    0, 0,
			    SRCCOPY);
	  if (fReturn)
	    {
#if CYGMULTIWINDOW_DEBUG
	      winDebug ("winMWExtWMStartDrawing - Shadow blit success\n");
#endif
	    }
	  else
	    {
	      ErrorF ("winMWExtWMStartDrawing - Shadow blit failure\n");
	    }
	  
	  /* Look for height weirdness */
	  if (dibsection.dsBmih.biHeight < 0)
	    {
	      /* FIXME: Figure out why biHeight is sometimes negative */
	      ErrorF ("winMWExtWMStartDrawing - WEIRDNESS - "
                  "biHeight still negative: %d\n", 
                  (int) dibsection.dsBmih.biHeight);
	      ErrorF ("winMWExtWMStartDrawing - WEIRDNESS - "
                  "Flipping biHeight sign\n");
	      dibsection.dsBmih.biHeight = -dibsection.dsBmih.biHeight;
	    }
	  
	  pRLWinPriv->dwWidthBytes = dibsection.dsBm.bmWidthBytes;
	  
#if CYGMULTIWINDOW_DEBUG
	  winDebug ("winMWExtWMStartDrawing - bytesPerRow: %d\n",
		    (unsigned int)dibsection.dsBm.bmWidthBytes);
#endif
	  
	  /* Free the old shadow bitmap */
	  DeleteObject (pRLWinPriv->hdcShadow);
	  DeleteObject (pRLWinPriv->hbmpShadow);
	  
	  pRLWinPriv->hdcShadow = hdcNew;
	  pRLWinPriv->hbmpShadow = hbmpNew;
	  
	  pRLWinPriv->fResized = FALSE;
d801 3
a803 3
	  winDebug ("winMWExtWMStartDrawing - 0x%08x %d\n",
		(unsigned int)pRLWinPriv->pfb, 
		(unsigned int)dibsection.dsBm.bmWidthBytes);
d805 1
a805 1
	}
d807 2
a808 3
  else
    {
      ErrorF ("winMWExtWMStartDrawing - Already window was destroyed \n"); 
d811 4
a814 3
  winDebug ("winMWExtWMStartDrawing - done (0x%08x) 0x%08x %d\n",
	    (int) pRLWinPriv,
	    (unsigned int)pRLWinPriv->pfb, (unsigned int)pRLWinPriv->dwWidthBytes);
d816 2
a817 2
  *pixelData = pRLWinPriv->pfb;
  *bytesPerRow = pRLWinPriv->dwWidthBytes;
d821 1
a821 1
winMWExtWMStopDrawing (RootlessFrameID wid, Bool fFlush)
d824 5
a828 4
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
  BLENDFUNCTION bfBlend;
  SIZE szWin;
  POINT ptSrc;
d830 1
a830 1
  winDebug ("winMWExtWMStopDrawing (%08x)\n", pRLWinPriv);
d832 14
a845 15
  szWin.cx = pRLWinPriv->dwWidth;
  szWin.cy = pRLWinPriv->dwHeight;
  ptSrc.x = 0;
  ptSrc.y = 0;
  bfBlend.BlendOp = AC_SRC_OVER;
  bfBlend.BlendFlags = 0;
  bfBlend.SourceConstantAlpha = 255;
  bfBlend.AlphaFormat = AC_SRC_ALPHA;

  if (!UpdateLayeredWindow (pRLWinPriv->hWnd,
			    NULL, NULL, &szWin,
			    pRLWinPriv->hdcShadow, &ptSrc,
			    0, &bfBlend, ULW_ALPHA))
    {
      ErrorF ("winMWExtWMStopDrawing - UpdateLayeredWindow failed\n");
d851 1
a851 1
winMWExtWMUpdateRegion (RootlessFrameID wid, RegionPtr pDamage)
d853 2
a854 1
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
d856 3
a858 3
  BLENDFUNCTION bfBlend;
  SIZE szWin;
  POINT ptSrc;
d861 1
a861 1
  winDebug ("winMWExtWMUpdateRegion (%08x)\n", pRLWinPriv);
d864 31
a894 32
  szWin.cx = pRLWinPriv->dwWidth;
  szWin.cy = pRLWinPriv->dwHeight;
  ptSrc.x = 0;
  ptSrc.y = 0;
  bfBlend.BlendOp = AC_SRC_OVER;
  bfBlend.BlendFlags = 0;
  bfBlend.SourceConstantAlpha = 255;
  bfBlend.AlphaFormat = AC_SRC_ALPHA;

  if (!UpdateLayeredWindow (pRLWinPriv->hWnd,
			    NULL, NULL, &szWin,
			    pRLWinPriv->hdcShadow, &ptSrc,
			    0, &bfBlend, ULW_ALPHA))
    {
      LPVOID lpMsgBuf;
      
      /* Display a fancy error message */
      FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		     FORMAT_MESSAGE_FROM_SYSTEM | 
		     FORMAT_MESSAGE_IGNORE_INSERTS,
		     NULL,
		     GetLastError (),
		     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		     (LPTSTR) &lpMsgBuf,
		     0, NULL);
      
      ErrorF ("winMWExtWMUpdateRegion - UpdateLayeredWindow failed: %s\n",
	      (LPSTR)lpMsgBuf);
      LocalFree (lpMsgBuf);
    }
#endif
  if (!g_fNoConfigureWindow) UpdateWindow (pRLWinPriv->hWnd);
d898 2
a899 2
winMWExtWMDamageRects (RootlessFrameID wid, int nCount, const BoxRec *pRects,
			     int shift_x, int shift_y)
d901 3
a903 2
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
  const BoxRec *pEnd;
d905 2
a906 2
  winDebug ("winMWExtWMDamageRects (%08x, %d, %08x, %d, %d)\n",
	    pRLWinPriv, nCount, pRects, shift_x, shift_y);
d909 1
a909 1
  for (pEnd = pRects + nCount; pRects < pEnd; pRects++) {
d911 1
d917 1
a917 1
	InvalidateRect (pRLWinPriv->hWnd, &rcDmg, FALSE);
d922 1
a922 1
winMWExtWMRootlessSwitchWindow (RootlessWindowPtr pFrame, WindowPtr oldWin)
d924 2
a925 1
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) pFrame->wid;
d927 2
a928 2
  winDebug ("winMWExtWMRootlessSwitchWindow (%08x) %08x\n",
	    (int) pRLWinPriv, (int) pRLWinPriv->hWnd);
d930 2
a931 2
  pRLWinPriv->pFrame = pFrame;
  pRLWinPriv->fResized = TRUE;
d933 2
a934 2
  /* Set the window extended style flags */
  SetWindowLongPtr (pRLWinPriv->hWnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW);
d936 2
a937 3
  /* Set the window standard style flags */
  SetWindowLongPtr (pRLWinPriv->hWnd, GWL_STYLE,
		    WS_POPUP | WS_CLIPCHILDREN);
d939 2
a940 2
  DeleteProperty (serverClient, oldWin, AtmWindowsWmNativeHwnd ());
  winMWExtWMSetNativeProperty (pFrame);
d943 16
a958 16
 {
   WindowPtr		pWin2 = NULL;
   win32RootlessWindowPtr pRLWinPriv2 = NULL;

   /* Check if the Windows window property for our X window pointer is valid */
   if ((pWin2 = (WindowPtr)GetProp (pRLWinPriv->hWnd, WIN_WINDOW_PROP)) != NULL)
     {
       pRLWinPriv2 = (win32RootlessWindowPtr) RootlessFrameForWindow (pWin2, FALSE);
     }
   winDebug ("winMWExtWMSwitchFrame2 (%08x) %08x\n",
	   pRLWinPriv2, pRLWinPriv2->hWnd);
   if (pRLWinPriv != pRLWinPriv2 || pRLWinPriv->hWnd != pRLWinPriv2->hWnd)
     {
       winDebug ("Error param missmatch\n");
     }
 }
d964 3
a966 3
winMWExtWMCopyBytes (unsigned int width, unsigned int height,
			   const void *src, unsigned int srcRowBytes,
			   void *dst, unsigned int dstRowBytes)
d969 1
a969 1
  winDebug ("winMWExtWMCopyBytes - Not implemented\n");
d974 2
a975 2
winMWExtWMCopyWindow (RootlessFrameID wid, int nDstRects, const BoxRec *pDstRects,
			    int nDx, int nDy)
d977 4
a980 3
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) wid;
  const BoxRec *pEnd;
  RECT rcDmg;
d982 2
a983 2
  winDebug ("winMWExtWMCopyWindow (%08x, %d, %08x, %d, %d)\n",
	  (int) pRLWinPriv, nDstRects, (int) pDstRects, nDx, nDy);
d986 1
a986 2
  for (pEnd = pDstRects + nDstRects; pDstRects < pEnd; pDstRects++)
    {
d988 22
a1009 25
      winDebug ("BitBlt (%d, %d, %d, %d) (%d, %d)\n",
	      pDstRects->x1, pDstRects->y1,
	      pDstRects->x2 - pDstRects->x1,
	      pDstRects->y2 - pDstRects->y1,
	      pDstRects->x1 + nDx,
	      pDstRects->y1 + nDy);
#endif

      if (!BitBlt (pRLWinPriv->hdcShadow,
		   pDstRects->x1, pDstRects->y1,
		   pDstRects->x2 - pDstRects->x1,
		   pDstRects->y2 - pDstRects->y1,
		   pRLWinPriv->hdcShadow,
		   pDstRects->x1 + nDx,  pDstRects->y1 + nDy,
		   SRCCOPY))
	{
	  ErrorF ("winMWExtWMCopyWindow - BitBlt failed.\n");
	}
      
      rcDmg.left = pDstRects->x1;
      rcDmg.top = pDstRects->y1;
      rcDmg.right = pDstRects->x2;
      rcDmg.bottom = pDstRects->y2;
      
      InvalidateRect (pRLWinPriv->hWnd, &rcDmg, FALSE);
d1012 1
a1012 1
  winDebug ("winMWExtWMCopyWindow - done\n");
a1015 1

d1021 1
a1021 1
winMWExtWMSetNativeProperty (RootlessWindowPtr pFrame)
d1023 2
a1024 2
  win32RootlessWindowPtr pRLWinPriv = (win32RootlessWindowPtr) pFrame->wid;
  long lData;
d1026 1
a1026 1
  /* FIXME: move this to WindowsWM extension */
d1028 3
a1030 3
  lData = (long) pRLWinPriv->hWnd;
  dixChangeWindowProperty(serverClient, pFrame->win, AtmWindowsWmNativeHwnd(),
			  XA_INTEGER, 32, PropModeReplace, 1, &lData, TRUE);
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a43 1
#include "winprefs.h"
d369 2
a370 2
  HICON			hiconClass;
  HICON			hiconSmClass;
d401 2
a402 2
  hiconClass = (HICON) GetClassLongPtr (pRLWinPriv->hWnd, GCLP_HICON);
  hiconSmClass = (HICON) GetClassLongPtr (pRLWinPriv->hWnd, GCLP_HICONSM);
d418 2
a419 1
      
d421 1
a421 1
      winDebug ("winMWExtWMDestroyFramew - %d Deleting Icon: ", iReturn);
d423 3
a425 4
      
      winDestroyIcon(hiconClass);
      winDestroyIcon(hiconSmClass);
    }
a1006 22

void
winMWExtWMFillBytes (unsigned int width, unsigned int height, unsigned int value,
			   void *dst, unsigned int dstRowBytes)
{
#if CYGMULTIWINDOW_DEBUG
  winDebug ("winMWExtWMFillBytes - Not implemented\n");
#endif
}

int
winMWExtWMCompositePixels (unsigned int width, unsigned int height, unsigned int function,
				 void *src[2], unsigned int srcRowBytes[2],
				 void *mask, unsigned int maskRowBytes,
				 void *dst[2], unsigned int dstRowBytes[2])
{
#if CYGMULTIWINDOW_DEBUG
  winDebug ("winMWExtWMCompositePixels - Not implemented\n");
#endif
  return 0;
}

@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d153 2
a154 2
  nRects = REGION_NUM_RECTS(pShape);
  pRects = REGION_RECTS(pShape);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d41 1
a41 1
#include "windowswmstr.h"
d52 1
a52 2
#define MOUSE_POLLING_INTERVAL		500

d54 2
d57 2
d60 1
a76 3

extern void winSelectIcons(WindowPtr pWin, HICON *pIcon, HICON *pSmallIcon);

d401 3
a403 3
  hInstance = (HINSTANCE) GetClassLong (pRLWinPriv->hWnd, GCL_HMODULE);
  hiconClass = (HICON) GetClassLong (pRLWinPriv->hWnd, GCL_HICON);
  hiconSmClass = (HICON) GetClassLong (pRLWinPriv->hWnd, GCL_HICONSM);
@


1.1
log
@Initial revision
@
text
@d974 1
a974 1
  DeleteProperty (oldWin, AtmWindowsWmNativeHwnd ());
d1090 2
a1091 2
  ChangeWindowProperty (pFrame->win, AtmWindowsWmNativeHwnd (),
			XA_INTEGER, 32, PropModeReplace, 1, &lData, TRUE);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
