head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.6
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.03.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Dakshinamurthy Karra
 *		Suhaib M Siddiqi
 *		Peter Busch
 *		Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include "winkeybd.h"
#include "winconfig.h"
#include "winmsg.h"

#include "xkbsrv.h"

/* C does not have a logical XOR operator, so we use a macro instead */
#define LOGICAL_XOR(a,b) ((!(a) && (b)) || ((a) && !(b)))

static Bool g_winKeyState[NUM_KEYCODES];

/*
 * Local prototypes
 */

static void
 winKeybdBell(int iPercent, DeviceIntPtr pDeviceInt, void *pCtrl, int iClass);

static void
 winKeybdCtrl(DeviceIntPtr pDevice, KeybdCtrl * pCtrl);

/*
 * Translate a Windows WM_[SYS]KEY(UP/DOWN) message
 * into an ASCII scan code.
 *
 * We do this ourselves, rather than letting Windows handle it,
 * because Windows tends to munge the handling of special keys,
 * like AltGr on European keyboards.
 */

int
winTranslateKey(WPARAM wParam, LPARAM lParam)
{
    int iKeyFixup = g_iKeyMap[wParam * WIN_KEYMAP_COLS + 1];
    int iKeyFixupEx = g_iKeyMap[wParam * WIN_KEYMAP_COLS + 2];
    int iParam = HIWORD(lParam);
    int iParamScanCode = LOBYTE(iParam);
    int iScanCode;

    winDebug("winTranslateKey: wParam %08x lParam %08x\n", (int)wParam, (int)lParam);

/* WM_ key messages faked by Vista speech recognition (WSR) don't have a
 * scan code.
 *
 * Vocola 3 (Rick Mohr's supplement to WSR) uses
 * System.Windows.Forms.SendKeys.SendWait(), which appears always to give a
 * scan code of 1
 */
    if (iParamScanCode <= 1) {
        if (VK_PRIOR <= wParam && wParam <= VK_DOWN)
            /* Trigger special case table to translate to extended
             * keycode, otherwise if num_lock is on, we can get keypad
             * numbers instead of navigation keys. */
            iParam |= KF_EXTENDED;
        else
            iParamScanCode = MapVirtualKeyEx(wParam,
                                             /*MAPVK_VK_TO_VSC */ 0,
                                             GetKeyboardLayout(0));
    }

    /* Branch on special extended, special non-extended, or normal key */
    if ((iParam & KF_EXTENDED) && iKeyFixupEx)
        iScanCode = iKeyFixupEx;
    else if (iKeyFixup)
        iScanCode = iKeyFixup;
    else if (wParam == 0 && iParamScanCode == 0x70)
        iScanCode = KEY_HKTG;
    else
        switch (iParamScanCode) {
        case 0x70:
            iScanCode = KEY_HKTG;
            break;
        case 0x73:
            iScanCode = KEY_BSlash2;
            break;
        default:
            iScanCode = iParamScanCode;
            break;
        }

    return iScanCode;
}

/* Ring the keyboard bell (system speaker on PCs) */
static void
winKeybdBell(int iPercent, DeviceIntPtr pDeviceInt, void *pCtrl, int iClass)
{
    /*
     * We can't use Beep () here because it uses the PC speaker
     * on NT/2000.  MessageBeep (MB_OK) will play the default system
     * sound on systems with a sound card or it will beep the PC speaker
     * on systems that do not have a sound card.
     */
    if (iPercent > 0) MessageBeep(MB_OK);
}

/* Change some keyboard configuration parameters */
static void
winKeybdCtrl(DeviceIntPtr pDevice, KeybdCtrl * pCtrl)
{
}

/*
 * See Porting Layer Definition - p. 18
 * winKeybdProc is known as a DeviceProc.
 */

int
winKeybdProc(DeviceIntPtr pDeviceInt, int iState)
{
    DevicePtr pDevice = (DevicePtr) pDeviceInt;
    XkbSrvInfoPtr xkbi;
    XkbControlsPtr ctrl;

    switch (iState) {
    case DEVICE_INIT:
        winConfigKeyboard(pDeviceInt);

        /* FIXME: Maybe we should use winGetKbdLeds () here? */
        defaultKeyboardControl.leds = g_winInfo.keyboard.leds;

        winErrorFVerb(2, "Rules = \"%s\" Model = \"%s\" Layout = \"%s\""
                      " Variant = \"%s\" Options = \"%s\"\n",
                      g_winInfo.xkb.rules ? g_winInfo.xkb.rules : "none",
                      g_winInfo.xkb.model ? g_winInfo.xkb.model : "none",
                      g_winInfo.xkb.layout ? g_winInfo.xkb.layout : "none",
                      g_winInfo.xkb.variant ? g_winInfo.xkb.variant : "none",
                      g_winInfo.xkb.options ? g_winInfo.xkb.options : "none");

        InitKeyboardDeviceStruct(pDeviceInt,
                                 &g_winInfo.xkb, winKeybdBell, winKeybdCtrl);

        xkbi = pDeviceInt->key->xkbInfo;
        if ((xkbi != NULL) && (xkbi->desc != NULL)) {
            ctrl = xkbi->desc->ctrls;
            ctrl->repeat_delay = g_winInfo.keyboard.delay;
            ctrl->repeat_interval = 1000 / g_winInfo.keyboard.rate;
        }
        else {
            winErrorFVerb(1,
                          "winKeybdProc - Error initializing keyboard AutoRepeat\n");
        }

        break;

    case DEVICE_ON:
        pDevice->on = TRUE;

        // immediately copy the state of this keyboard device to the VCK
        // (which otherwise happens lazily after the first keypress)
        CopyKeyClass(pDeviceInt, inputInfo.keyboard);
        break;

    case DEVICE_CLOSE:
    case DEVICE_OFF:
        pDevice->on = FALSE;
        break;
    }

    return Success;
}

/*
 * Detect current mode key states upon server startup.
 *
 * Simulate a press and release of any key that is currently
 * toggled.
 */

void
winInitializeModeKeyStates(void)
{
    /* Restore NumLock */
    if (GetKeyState(VK_NUMLOCK) & 0x0001) {
        winSendKeyEvent(KEY_NumLock, TRUE);
        winSendKeyEvent(KEY_NumLock, FALSE);
    }

    /* Restore CapsLock */
    if (GetKeyState(VK_CAPITAL) & 0x0001) {
        winSendKeyEvent(KEY_CapsLock, TRUE);
        winSendKeyEvent(KEY_CapsLock, FALSE);
    }

    /* Restore ScrollLock */
    if (GetKeyState(VK_SCROLL) & 0x0001) {
        winSendKeyEvent(KEY_ScrollLock, TRUE);
        winSendKeyEvent(KEY_ScrollLock, FALSE);
    }

    /* Restore KanaLock */
    if (GetKeyState(VK_KANA) & 0x0001) {
        winSendKeyEvent(KEY_HKTG, TRUE);
        winSendKeyEvent(KEY_HKTG, FALSE);
    }
}

/*
 * Upon regaining the keyboard focus we must
 * resynchronize our internal mode key states
 * with the actual state of the keys.
 */

void
winRestoreModeKeyStates(void)
{
    DWORD dwKeyState;
    BOOL processEvents = TRUE;
    unsigned short internalKeyStates;

    /* X server is being initialized */
    if (!inputInfo.keyboard)
        return;

    /* Only process events if the rootwindow is mapped. The keyboard events
     * will cause segfaults otherwise */
    if (screenInfo.screens[0]->root &&
        screenInfo.screens[0]->root->mapped == FALSE)
        processEvents = FALSE;

    /* Force to process all pending events in the mi event queue */
    if (processEvents)
        mieqProcessInputEvents();

    /* Read the mode key states of our X server */
    /* (stored in the virtual core keyboard) */
    internalKeyStates =
        XkbStateFieldFromRec(&inputInfo.keyboard->key->xkbInfo->state);
    winDebug("winRestoreModeKeyStates: state %d\n", internalKeyStates);

    /* Check if modifier keys are pressed, and if so, fake a press */
    {

        BOOL lctrl = (GetAsyncKeyState(VK_LCONTROL) < 0);
        BOOL rctrl = (GetAsyncKeyState(VK_RCONTROL) < 0);
        BOOL lshift = (GetAsyncKeyState(VK_LSHIFT) < 0);
        BOOL rshift = (GetAsyncKeyState(VK_RSHIFT) < 0);
        BOOL alt = (GetAsyncKeyState(VK_LMENU) < 0);
        BOOL altgr = (GetAsyncKeyState(VK_RMENU) < 0);

        /*
           If AltGr and CtrlL appear to be pressed, assume the
           CtrL is a fake one
         */
        if (lctrl && altgr)
            lctrl = FALSE;

        if (lctrl)
            winSendKeyEvent(KEY_LCtrl, TRUE);

        if (rctrl)
            winSendKeyEvent(KEY_RCtrl, TRUE);

        if (lshift)
            winSendKeyEvent(KEY_ShiftL, TRUE);

        if (rshift)
            winSendKeyEvent(KEY_ShiftL, TRUE);

        if (alt)
            winSendKeyEvent(KEY_Alt, TRUE);

        if (altgr)
            winSendKeyEvent(KEY_AltLang, TRUE);
    }

    /*
       Check if latching modifier key states have changed, and if so,
       fake a press and a release to toggle the modifier to the correct
       state
    */
    dwKeyState = GetKeyState(VK_NUMLOCK) & 0x0001;
    if (LOGICAL_XOR(internalKeyStates & NumLockMask, dwKeyState)) {
        winSendKeyEvent(KEY_NumLock, TRUE);
        winSendKeyEvent(KEY_NumLock, FALSE);
    }

    dwKeyState = GetKeyState(VK_CAPITAL) & 0x0001;
    if (LOGICAL_XOR(internalKeyStates & LockMask, dwKeyState)) {
        winSendKeyEvent(KEY_CapsLock, TRUE);
        winSendKeyEvent(KEY_CapsLock, FALSE);
    }

    dwKeyState = GetKeyState(VK_SCROLL) & 0x0001;
    if (LOGICAL_XOR(internalKeyStates & ScrollLockMask, dwKeyState)) {
        winSendKeyEvent(KEY_ScrollLock, TRUE);
        winSendKeyEvent(KEY_ScrollLock, FALSE);
    }

    dwKeyState = GetKeyState(VK_KANA) & 0x0001;
    if (LOGICAL_XOR(internalKeyStates & KanaMask, dwKeyState)) {
        winSendKeyEvent(KEY_HKTG, TRUE);
        winSendKeyEvent(KEY_HKTG, FALSE);
    }

    /*
       For strict correctness, we should also press any non-modifier keys
       which are already down when we gain focus, but nobody has complained
       yet :-)
     */
}

/*
 * Look for the lovely fake Control_L press/release generated by Windows
 * when AltGr is pressed/released on a non-U.S. keyboard.
 */

Bool
winIsFakeCtrl_L(UINT message, WPARAM wParam, LPARAM lParam)
{
    MSG msgNext;
    LONG lTime;
    Bool fReturn;

    static Bool lastWasControlL = FALSE;
    static LONG lastTime;

    /*
     * Fake Ctrl_L presses will be followed by an Alt_R press
     * with the same timestamp as the Ctrl_L press.
     */
    if ((message == WM_KEYDOWN || message == WM_SYSKEYDOWN)
        && wParam == VK_CONTROL && (HIWORD(lParam) & KF_EXTENDED) == 0) {
        /* Got a Ctrl_L press */

        /* Get time of current message */
        lTime = GetMessageTime();

        /* Look for next press message */
        fReturn = PeekMessage(&msgNext, NULL,
                              WM_KEYDOWN, WM_SYSKEYDOWN, PM_NOREMOVE);

        if (fReturn && msgNext.message != WM_KEYDOWN &&
            msgNext.message != WM_SYSKEYDOWN)
            fReturn = 0;

        if (!fReturn) {
            lastWasControlL = TRUE;
            lastTime = lTime;
        }
        else {
            lastWasControlL = FALSE;
        }

        /* Is next press an Alt_R with the same timestamp? */
        if (fReturn && msgNext.wParam == VK_MENU
            && msgNext.time == lTime
            && (HIWORD(msgNext.lParam) & KF_EXTENDED)) {
            /*
             * Next key press is Alt_R with same timestamp as current
             * Ctrl_L message.  Therefore, this Ctrl_L press is a fake
             * event, so discard it.
             */
            return TRUE;
        }
    }
    /*
     * Sometimes, the Alt_R press message is not yet posted when the
     * fake Ctrl_L press message arrives (even though it has the
     * same timestamp), so check for an Alt_R press message that has
     * arrived since the last Ctrl_L message.
     */
    else if ((message == WM_KEYDOWN || message == WM_SYSKEYDOWN)
             && wParam == VK_MENU && (HIWORD(lParam) & KF_EXTENDED)) {
        /* Got a Alt_R press */

        if (lastWasControlL) {
            lTime = GetMessageTime();

            if (lastTime == lTime) {
                /* Undo the fake Ctrl_L press by sending a fake Ctrl_L release */
                winSendKeyEvent(KEY_LCtrl, FALSE);
            }
            lastWasControlL = FALSE;
        }
    }
    /*
     * Fake Ctrl_L releases will be followed by an Alt_R release
     * with the same timestamp as the Ctrl_L release.
     */
    else if ((message == WM_KEYUP || message == WM_SYSKEYUP)
             && wParam == VK_CONTROL && (HIWORD(lParam) & KF_EXTENDED) == 0) {
        /* Got a Ctrl_L release */

        /* Get time of current message */
        lTime = GetMessageTime();

        /* Look for next release message */
        fReturn = PeekMessage(&msgNext, NULL,
                              WM_KEYUP, WM_SYSKEYUP, PM_NOREMOVE);

        if (fReturn && msgNext.message != WM_KEYUP &&
            msgNext.message != WM_SYSKEYUP)
            fReturn = 0;

        lastWasControlL = FALSE;

        /* Is next press an Alt_R with the same timestamp? */
        if (fReturn
            && (msgNext.message == WM_KEYUP || msgNext.message == WM_SYSKEYUP)
            && msgNext.wParam == VK_MENU
            && msgNext.time == lTime
            && (HIWORD(msgNext.lParam) & KF_EXTENDED)) {
            /*
             * Next key release is Alt_R with same timestamp as current
             * Ctrl_L message. Therefore, this Ctrl_L release is a fake
             * event, so discard it.
             */
            return TRUE;
        }
    }
    else {
        /* On any other press or release message, we don't have a
           potentially fake Ctrl_L to worry about anymore... */
        lastWasControlL = FALSE;
    }

    /* Not a fake control left press/release */
    return FALSE;
}

/*
 * Lift any modifier keys that are pressed
 */

void
winKeybdReleaseKeys(void)
{
    int i;

#ifdef HAS_DEVWINDOWS
    /* Verify that the mi input system has been initialized */
    if (g_fdMessageQueue == WIN_FD_INVALID)
        return;
#endif

    /* Loop through all keys */
    for (i = 0; i < NUM_KEYCODES; ++i) {
        /* Pop key if pressed */
        if (g_winKeyState[i])
            winSendKeyEvent(i, FALSE);

        /* Reset pressed flag for keys */
        g_winKeyState[i] = FALSE;
    }
}

/*
 * Take a raw X key code and send an up or down event for it.
 *
 * Thanks to VNC for inspiration, though it is a simple function.
 */

void
winSendKeyEvent(DWORD dwKey, Bool fDown)
{
    /*
     * When alt-tabing between screens we can get phantom key up messages
     * Here we only pass them through it we think we should!
     */
    if (g_winKeyState[dwKey] == FALSE && fDown == FALSE)
        return;

    /* Update the keyState map */
    g_winKeyState[dwKey] = fDown;

    QueueKeyboardEvents(g_pwinKeyboard, fDown ? KeyPress : KeyRelease,
                        dwKey + MIN_KEYCODE);

    winDebug("winSendKeyEvent: dwKey: %u, fDown: %u\n", (unsigned int)dwKey, fDown);
}

BOOL
winCheckKeyPressed(WPARAM wParam, LPARAM lParam)
{
    switch (wParam) {
    case VK_CONTROL:
        if ((lParam & 0x1ff0000) == 0x11d0000 && g_winKeyState[KEY_RCtrl])
            return TRUE;
        if ((lParam & 0x1ff0000) == 0x01d0000 && g_winKeyState[KEY_LCtrl])
            return TRUE;
        break;
    case VK_SHIFT:
        if ((lParam & 0x1ff0000) == 0x0360000 && g_winKeyState[KEY_ShiftR])
            return TRUE;
        if ((lParam & 0x1ff0000) == 0x02a0000 && g_winKeyState[KEY_ShiftL])
            return TRUE;
        break;
    default:
        return TRUE;
    }
    return FALSE;
}

/* Only one shift release message is sent even if both are pressed.
 * Fix this here
 */
void
winFixShiftKeys(int iScanCode)
{
    if (GetKeyState(VK_SHIFT) & 0x8000)
        return;

    if (iScanCode == KEY_ShiftL && g_winKeyState[KEY_ShiftR])
        winSendKeyEvent(KEY_ShiftR, FALSE);
    if (iScanCode == KEY_ShiftR && g_winKeyState[KEY_ShiftL])
        winSendKeyEvent(KEY_ShiftL, FALSE);
}
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d77 1
a77 1
    winDebug("winTranslateKey: wParam %08x lParam %08x\n", wParam, lParam);
d505 1
a505 1
                        dwKey + MIN_KEYCODE, NULL);
d507 1
a507 1
    winDebug("winSendKeyEvent: dwKey: %d, fDown: %d\n", dwKey, fDown);
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d54 1
a54 1
 winKeybdBell(int iPercent, DeviceIntPtr pDeviceInt, pointer pCtrl, int iClass);
d123 1
a123 1
winKeybdBell(int iPercent, DeviceIntPtr pDeviceInt, pointer pCtrl, int iClass)
d131 1
a131 1
    MessageBeep(MB_OK);
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d68 2
a69 2
void
winTranslateKey(WPARAM wParam, LPARAM lParam, int *piScanCode)
d75 1
d100 1
a100 1
        *piScanCode = iKeyFixupEx;
d102 1
a102 1
        *piScanCode = iKeyFixup;
d104 1
a104 1
        *piScanCode = KEY_HKTG;
d108 1
a108 1
            *piScanCode = KEY_HKTG;
d111 1
a111 1
            *piScanCode = KEY_BSlash2;
d114 1
a114 1
            *piScanCode = iParamScanCode;
d117 2
d270 5
a274 2
        BOOL ctrl = (GetAsyncKeyState(VK_CONTROL) < 0);
        BOOL shift = (GetAsyncKeyState(VK_SHIFT) < 0);
d278 15
a292 2
        if (ctrl && altgr)
            ctrl = FALSE;
d294 2
a295 2
        if (LOGICAL_XOR(internalKeyStates & ControlMask, ctrl))
            winSendKeyEvent(KEY_LCtrl, ctrl);
d297 2
a298 2
        if (LOGICAL_XOR(internalKeyStates & ShiftMask, shift))
            winSendKeyEvent(KEY_ShiftL, shift);
d300 2
a301 5
        if (LOGICAL_XOR(internalKeyStates & Mod1Mask, alt))
            winSendKeyEvent(KEY_Alt, alt);

        if (LOGICAL_XOR(internalKeyStates & Mod5Mask, altgr))
            winSendKeyEvent(KEY_AltLang, altgr);
d332 6
a352 1
    static UINT lastMessage;
a375 1
            lastMessage = message;
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d44 3
d59 1
a59 1
/* 
d137 1
a137 1
/* 
d265 22
a286 5
    /* 
     * NOTE: The C XOR operator, ^, will not work here because it is
     * a bitwise operator, not a logical operator.  C does not
     * have a logical XOR operator, so we use a macro instead.
     */
d288 5
a292 1
    /* Has the key state changed? */
d294 1
a294 1
    if (WIN_XOR(internalKeyStates & NumLockMask, dwKeyState)) {
a298 1
    /* Has the key state changed? */
d300 1
a300 1
    if (WIN_XOR(internalKeyStates & LockMask, dwKeyState)) {
a304 1
    /* Has the key state changed? */
d306 1
a306 1
    if (WIN_XOR(internalKeyStates & ScrollLockMask, dwKeyState)) {
a310 1
    /* Has the key state changed? */
d312 1
a312 1
    if (WIN_XOR(internalKeyStates & KanaMask, dwKeyState)) {
d512 2
a513 2
/* Only on shift release message is sent even if both are pressed.
 * Fix this here 
@


1.4
log
@Update to xserver 1.11.2
@
text
@a33 1

d51 1
a51 2
winKeybdBell (int iPercent, DeviceIntPtr pDeviceInt,
	      pointer pCtrl, int iClass);
d54 1
a54 2
winKeybdCtrl (DeviceIntPtr pDevice, KeybdCtrl *pCtrl);

d66 1
a66 1
winTranslateKey (WPARAM wParam, LPARAM lParam, int *piScanCode)
d68 4
a71 4
  int		iKeyFixup = g_iKeyMap[wParam * WIN_KEYMAP_COLS + 1];
  int		iKeyFixupEx = g_iKeyMap[wParam * WIN_KEYMAP_COLS + 2];
  int		iParam = HIWORD (lParam);
  int		iParamScanCode = LOBYTE (iParam);
d73 1
a73 1
  winDebug("winTranslateKey: wParam %08x lParam %08x\n", wParam, lParam);
d82 18
a99 24
  if (iParamScanCode <= 1)
    {
      if (VK_PRIOR <= wParam && wParam <= VK_DOWN)
        /* Trigger special case table to translate to extended
         * keycode, otherwise if num_lock is on, we can get keypad
         * numbers instead of navigation keys. */
        iParam |= KF_EXTENDED;
      else
        iParamScanCode = MapVirtualKeyEx(wParam,
                         /*MAPVK_VK_TO_VSC*/0,
                         GetKeyboardLayout(0));
    }

  /* Branch on special extended, special non-extended, or normal key */
  if ((iParam & KF_EXTENDED) && iKeyFixupEx)
    *piScanCode = iKeyFixupEx;
  else if (iKeyFixup)
    *piScanCode = iKeyFixup;
  else if (wParam == 0 && iParamScanCode == 0x70)
    *piScanCode = KEY_HKTG;
  else
    switch (iParamScanCode)
    {
      case 0x70:
d101 12
a112 8
        break;
      case 0x73:
        *piScanCode = KEY_BSlash2;
        break;
      default: 
        *piScanCode = iParamScanCode;
        break;
    }
a114 1

d117 1
a117 2
winKeybdBell (int iPercent, DeviceIntPtr pDeviceInt,
	      pointer pCtrl, int iClass)
d119 7
a125 7
  /*
   * We can't use Beep () here because it uses the PC speaker
   * on NT/2000.  MessageBeep (MB_OK) will play the default system
   * sound on systems with a sound card or it will beep the PC speaker
   * on systems that do not have a sound card.
   */
  MessageBeep (MB_OK);
a127 1

d130 1
a130 1
winKeybdCtrl (DeviceIntPtr pDevice, KeybdCtrl *pCtrl)
a133 1

d140 1
a140 1
winKeybdProc (DeviceIntPtr pDeviceInt, int iState)
d142 3
a144 3
  DevicePtr		pDevice = (DevicePtr) pDeviceInt;
  XkbSrvInfoPtr       xkbi;
  XkbControlsPtr      ctrl;
d146 1
a146 2
  switch (iState)
    {
d148 1
a148 1
      winConfigKeyboard (pDeviceInt);
d150 2
a151 2
      /* FIXME: Maybe we should use winGetKbdLeds () here? */
      defaultKeyboardControl.leds = g_winInfo.keyboard.leds;
d153 16
a168 19
      winErrorFVerb(2, "Rules = \"%s\" Model = \"%s\" Layout = \"%s\""
                    " Variant = \"%s\" Options = \"%s\"\n",
                    g_winInfo.xkb.rules ? g_winInfo.xkb.rules : "none",
                    g_winInfo.xkb.model ? g_winInfo.xkb.model : "none",
                    g_winInfo.xkb.layout ? g_winInfo.xkb.layout : "none",
                    g_winInfo.xkb.variant ? g_winInfo.xkb.variant : "none",
                    g_winInfo.xkb.options ? g_winInfo.xkb.options : "none");

      InitKeyboardDeviceStruct (pDeviceInt,
                                &g_winInfo.xkb,
                                winKeybdBell,
                                winKeybdCtrl);

      xkbi = pDeviceInt->key->xkbInfo;
      if ((xkbi != NULL) && (xkbi->desc != NULL))
        {
          ctrl = xkbi->desc->ctrls;
          ctrl->repeat_delay = g_winInfo.keyboard.delay;
          ctrl->repeat_interval = 1000/g_winInfo.keyboard.rate;
d170 3
a172 3
      else
        {
          winErrorFVerb (1, "winKeybdProc - Error initializing keyboard AutoRepeat\n");
d175 9
a183 9
      break;
      
    case DEVICE_ON: 
      pDevice->on = TRUE;

      // immediately copy the state of this keyboard device to the VCK
      // (which otherwise happens lazily after the first keypress)
      CopyKeyClass(pDeviceInt, inputInfo.keyboard);
      break;
d186 3
a188 3
    case DEVICE_OFF: 
      pDevice->on = FALSE;
      break;
d191 1
a191 1
  return Success;
a193 1

d202 1
a202 1
winInitializeModeKeyStates (void)
d204 22
a225 26
  /* Restore NumLock */
  if (GetKeyState (VK_NUMLOCK) & 0x0001)
    {
      winSendKeyEvent (KEY_NumLock, TRUE);
      winSendKeyEvent (KEY_NumLock, FALSE);
    }

  /* Restore CapsLock */
  if (GetKeyState (VK_CAPITAL) & 0x0001)
    {
      winSendKeyEvent (KEY_CapsLock, TRUE);
      winSendKeyEvent (KEY_CapsLock, FALSE);
    }

  /* Restore ScrollLock */
  if (GetKeyState (VK_SCROLL) & 0x0001)
    {
      winSendKeyEvent (KEY_ScrollLock, TRUE);
      winSendKeyEvent (KEY_ScrollLock, FALSE);
    }

  /* Restore KanaLock */
  if (GetKeyState (VK_KANA) & 0x0001)
    {
      winSendKeyEvent (KEY_HKTG, TRUE);
      winSendKeyEvent (KEY_HKTG, FALSE);
a228 1

d236 1
a236 1
winRestoreModeKeyStates (void)
d238 56
a293 58
  DWORD			dwKeyState;
  BOOL			processEvents = TRUE;
  unsigned short	internalKeyStates;

  /* X server is being initialized */
  if (!inputInfo.keyboard)
    return;

  /* Only process events if the rootwindow is mapped. The keyboard events
   * will cause segfaults otherwise */
  if (screenInfo.screens[0]->root && screenInfo.screens[0]->root->mapped == FALSE)
    processEvents = FALSE;    
  
  /* Force to process all pending events in the mi event queue */
  if (processEvents)
    mieqProcessInputEvents ();
  
  /* Read the mode key states of our X server */
  /* (stored in the virtual core keyboard) */
  internalKeyStates = XkbStateFieldFromRec(&inputInfo.keyboard->key->xkbInfo->state);
  winDebug("winRestoreModeKeyStates: state %d\n", internalKeyStates);

  /* 
   * NOTE: The C XOR operator, ^, will not work here because it is
   * a bitwise operator, not a logical operator.  C does not
   * have a logical XOR operator, so we use a macro instead.
   */

  /* Has the key state changed? */
  dwKeyState = GetKeyState (VK_NUMLOCK) & 0x0001;
  if (WIN_XOR (internalKeyStates & NumLockMask, dwKeyState))
    {
      winSendKeyEvent (KEY_NumLock, TRUE);
      winSendKeyEvent (KEY_NumLock, FALSE);
    }

  /* Has the key state changed? */
  dwKeyState = GetKeyState (VK_CAPITAL) & 0x0001;
  if (WIN_XOR (internalKeyStates & LockMask, dwKeyState))
    {
      winSendKeyEvent (KEY_CapsLock, TRUE);
      winSendKeyEvent (KEY_CapsLock, FALSE);
    }

  /* Has the key state changed? */
  dwKeyState = GetKeyState (VK_SCROLL) & 0x0001;
  if (WIN_XOR (internalKeyStates & ScrollLockMask, dwKeyState))
    {
      winSendKeyEvent (KEY_ScrollLock, TRUE);
      winSendKeyEvent (KEY_ScrollLock, FALSE);
    }

  /* Has the key state changed? */
  dwKeyState = GetKeyState (VK_KANA) & 0x0001;
  if (WIN_XOR (internalKeyStates & KanaMask, dwKeyState))
    {
      winSendKeyEvent (KEY_HKTG, TRUE);
      winSendKeyEvent (KEY_HKTG, FALSE);
a296 1

d303 1
a303 1
winIsFakeCtrl_L (UINT message, WPARAM wParam, LPARAM lParam)
d305 111
a415 108
  MSG		msgNext;
  LONG		lTime;
  Bool		fReturn;

  /*
   * Fake Ctrl_L presses will be followed by an Alt_R keypress
   * with the same timestamp as the Ctrl_L press.
   */
  if ((message == WM_KEYDOWN || message == WM_SYSKEYDOWN)
      && wParam == VK_CONTROL
      && (HIWORD (lParam) & KF_EXTENDED) == 0)
    {
      /* Got a Ctrl_L press */

      /* Get time of current message */
      lTime = GetMessageTime ();

      /* Look for fake Ctrl_L preceeding an Alt_R press. */
      fReturn = PeekMessage (&msgNext, NULL,
			     WM_KEYDOWN, WM_SYSKEYDOWN,
			     PM_NOREMOVE);

      /*
       * Try again if the first call fails.
       * NOTE: This usually happens when TweakUI is enabled.
       */
      if (!fReturn)
	{
	  /* Voodoo to make sure that the Alt_R message has posted */
	  Sleep (0);

	  /* Look for fake Ctrl_L preceeding an Alt_R press. */
	  fReturn = PeekMessage (&msgNext, NULL,
				 WM_KEYDOWN, WM_SYSKEYDOWN,
				 PM_NOREMOVE);
	}
      if (msgNext.message != WM_KEYDOWN && msgNext.message != WM_SYSKEYDOWN)
          fReturn = 0;

      /* Is next press an Alt_R with the same timestamp? */
      if (fReturn && msgNext.wParam == VK_MENU
	  && msgNext.time == lTime
	  && (HIWORD (msgNext.lParam) & KF_EXTENDED))
	{
	  /* 
	   * Next key press is Alt_R with same timestamp as current
	   * Ctrl_L message.  Therefore, this Ctrl_L press is a fake
	   * event, so discard it.
	   */
	  return TRUE;
	}
    }

  /* 
   * Fake Ctrl_L releases will be followed by an Alt_R release
   * with the same timestamp as the Ctrl_L release.
   */
  if ((message == WM_KEYUP || message == WM_SYSKEYUP)
      && wParam == VK_CONTROL
      && (HIWORD (lParam) & KF_EXTENDED) == 0)
    {
      /* Got a Ctrl_L release */

      /* Get time of current message */
      lTime = GetMessageTime ();

      /* Look for fake Ctrl_L release preceeding an Alt_R release. */
      fReturn = PeekMessage (&msgNext, NULL,
			     WM_KEYUP, WM_SYSKEYUP, 
			     PM_NOREMOVE);

      /*
       * Try again if the first call fails.
       * NOTE: This usually happens when TweakUI is enabled.
       */
      if (!fReturn)
	{
	  /* Voodoo to make sure that the Alt_R message has posted */
	  Sleep (0);

	  /* Look for fake Ctrl_L release preceeding an Alt_R release. */
	  fReturn = PeekMessage (&msgNext, NULL,
				 WM_KEYUP, WM_SYSKEYUP, 
				 PM_NOREMOVE);
	}

      if (msgNext.message != WM_KEYUP && msgNext.message != WM_SYSKEYUP)
          fReturn = 0;
      
      /* Is next press an Alt_R with the same timestamp? */
      if (fReturn
	  && (msgNext.message == WM_KEYUP
	      || msgNext.message == WM_SYSKEYUP)
	  && msgNext.wParam == VK_MENU
	  && msgNext.time == lTime
	  && (HIWORD (msgNext.lParam) & KF_EXTENDED))
	{
	  /*
	   * Next key release is Alt_R with same timestamp as current
	   * Ctrl_L message. Therefore, this Ctrl_L release is a fake
	   * event, so discard it.
	   */
	  return TRUE;
	}
    }
  
  /* Not a fake control left press/release */
  return FALSE;
a417 1

d423 1
a423 1
winKeybdReleaseKeys (void)
d425 1
a425 1
  int				i;
d428 3
a430 3
  /* Verify that the mi input system has been initialized */
  if (g_fdMessageQueue == WIN_FD_INVALID)
    return;
d433 5
a437 6
  /* Loop through all keys */
  for (i = 0; i < NUM_KEYCODES; ++i)
    {
      /* Pop key if pressed */
      if (g_winKeyState[i])
	winSendKeyEvent (i, FALSE);
d439 2
a440 2
      /* Reset pressed flag for keys */
      g_winKeyState[i] = FALSE;
a443 1

d451 1
a451 1
winSendKeyEvent (DWORD dwKey, Bool fDown)
d453 6
a458 5
  /*
   * When alt-tabing between screens we can get phantom key up messages
   * Here we only pass them through it we think we should!
   */
  if (g_winKeyState[dwKey] == FALSE && fDown == FALSE) return;
d460 2
a461 2
  /* Update the keyState map */
  g_winKeyState[dwKey] = fDown;
d463 2
a464 1
  QueueKeyboardEvents(g_pwinKeyboard, fDown ? KeyPress : KeyRelease, dwKey + MIN_KEYCODE, NULL);
d466 1
a466 2
  winDebug("winSendKeyEvent: dwKey: %d, fDown: %d\n",
           dwKey, fDown);
d469 2
a470 1
BOOL winCheckKeyPressed(WPARAM wParam, LPARAM lParam)
d472 1
a472 2
  switch (wParam)
  {
d474 5
a478 5
      if ((lParam & 0x1ff0000) == 0x11d0000 && g_winKeyState[KEY_RCtrl])
        return TRUE;
      if ((lParam & 0x1ff0000) == 0x01d0000 && g_winKeyState[KEY_LCtrl])
        return TRUE;
      break;
d480 6
a485 1
      if ((lParam & 0x1ff0000) == 0x0360000 && g_winKeyState[KEY_ShiftR])
d487 2
a488 7
      if ((lParam & 0x1ff0000) == 0x02a0000 && g_winKeyState[KEY_ShiftL])
        return TRUE;
      break;
    default:
      return TRUE;
  }
  return FALSE;
d494 2
a495 1
void winFixShiftKeys (int iScanCode)
d497 2
a498 2
  if (GetKeyState (VK_SHIFT) & 0x8000)
    return;
d500 4
a503 4
  if (iScanCode == KEY_ShiftL && g_winKeyState[KEY_ShiftR])
    winSendKeyEvent (KEY_ShiftR, FALSE);
  if (iScanCode == KEY_ShiftR && g_winKeyState[KEY_ShiftL])
    winSendKeyEvent (KEY_ShiftL, FALSE);
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d76 2
a474 3
  EventListPtr events;
  int i, nevents;

d484 1
a484 2
  GetEventList(&events);
  nevents = GetKeyboardEvents(events, g_pwinKeyboard, fDown ? KeyPress : KeyRelease, dwKey + MIN_KEYCODE);
d486 2
a487 7
  for (i = 0; i < nevents; i++)
    mieqEnqueue(g_pwinKeyboard, events[i].event);

#if CYGDEBUG
  ErrorF("winSendKeyEvent: dwKey: %d, fDown: %d, nEvents %d\n",
          dwKey, fDown, nevents);
#endif
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d265 1
a265 1
  if (WindowTable && WindowTable[0] && WindowTable[0]->mapped == FALSE)
@


1.1
log
@Initial revision
@
text
@d43 1
a43 6
#ifdef XKB
#ifndef XKB_IN_SERVER
#define XKB_IN_SERVER
#endif
#include <X11/extensions/XKBsrv.h>
#endif
a46 4
/* Stored to get internal mode key states.  Must be read-only.  */
static unsigned short const *g_winInternalModeKeyStatesPtr = NULL;


a51 3
winGetKeyMappings (KeySymsPtr pKeySyms, CARD8 *pModMap);

static void
d73 22
a94 1
  int		iParamScanCode = LOBYTE (HIWORD (lParam));
d97 1
a97 1
  if ((HIWORD (lParam) & KF_EXTENDED) && iKeyFixupEx)
a118 83
/*
 * We call this function from winKeybdProc when we are
 * initializing the keyboard.
 */

static void
winGetKeyMappings (KeySymsPtr pKeySyms, CARD8 *pModMap)
{
  int			i;
  KeySym		*pMap = map;
  KeySym		*pKeySym;

  /*
   * Initialize all key states to up... which may not be true
   * but it is close enough.
   */
  ZeroMemory (g_winKeyState, sizeof (g_winKeyState[0]) * NUM_KEYCODES);

  /* MAP_LENGTH is defined in Xserver/include/input.h to be 256 */
  for (i = 0; i < MAP_LENGTH; i++)
    pModMap[i] = NoSymbol;  /* make sure it is restored */

  /* Loop through all valid entries in the key symbol table */
  for (pKeySym = pMap, i = MIN_KEYCODE;
       i < (MIN_KEYCODE + NUM_KEYCODES);
       i++, pKeySym += GLYPHS_PER_KEY)
    {
      switch (*pKeySym)
	{
	case XK_Shift_L:
	case XK_Shift_R:
	  pModMap[i] = ShiftMask;
	  break;

	case XK_Control_L:
	case XK_Control_R:
	  pModMap[i] = ControlMask;
	  break;

	case XK_Caps_Lock:
	  pModMap[i] = LockMask;
	  break;

	case XK_Alt_L:
	case XK_Alt_R:
	  pModMap[i] = AltMask;
	  break;

	case XK_Num_Lock:
	  pModMap[i] = NumLockMask;
	  break;

	case XK_Scroll_Lock:
	  pModMap[i] = ScrollLockMask;
	  break;

#if 0
	case XK_Super_L:
	case XK_Super_R:
	  pModMap[i] = Mod4Mask;
	  break;
#else
	/* Hirigana/Katakana toggle */
	case XK_Kana_Lock:
	case XK_Kana_Shift:
	  pModMap[i] = KanaMask;
	  break;
#endif

	/* alternate toggle for multinational support */
	case XK_Mode_switch:
	  pModMap[i] = AltLangMask;
	  break;
	}
    }

  pKeySyms->map        = (KeySym *) pMap;
  pKeySyms->mapWidth   = GLYPHS_PER_KEY;
  pKeySyms->minKeyCode = MIN_KEYCODE;
  pKeySyms->maxKeyCode = MAX_KEYCODE;
}


a137 1
  g_winInternalModeKeyStatesPtr = &(pDevice->key->state);
a148 2
  KeySymsRec		keySyms;
  CARD8 		modMap[MAP_LENGTH];
a149 2
#ifdef XKB
  XkbComponentNamesRec names;
a151 1
#endif
a157 3
      winGetKeyMappings (&keySyms, modMap);

#ifdef XKB
a159 3
#else
      defaultKeyboardControl.leds = g_winInfo.keyboard.leds;
#endif
d161 23
a183 49
#ifdef XKB
      if (g_winInfo.xkb.disable) 
	{
#endif
	  InitKeyboardDeviceStruct (pDevice,
				    &keySyms,
				    modMap,
				    winKeybdBell,
				    winKeybdCtrl);
#ifdef XKB
	} 
      else 
	{

          names.keymap = g_winInfo.xkb.keymap;
          names.keycodes = g_winInfo.xkb.keycodes;
          names.types = g_winInfo.xkb.types;
          names.compat = g_winInfo.xkb.compat;
          names.symbols = g_winInfo.xkb.symbols;
          names.geometry = g_winInfo.xkb.geometry;

	  winErrorFVerb(2, "Rules = \"%s\" Model = \"%s\" Layout = \"%s\""
		 " Variant = \"%s\" Options = \"%s\"\n",
		 g_winInfo.xkb.rules, g_winInfo.xkb.model,
		 g_winInfo.xkb.layout, g_winInfo.xkb.variant,
		 g_winInfo.xkb.options);
          
	  XkbSetRulesDflts (g_winInfo.xkb.rules, g_winInfo.xkb.model, 
			    g_winInfo.xkb.layout, g_winInfo.xkb.variant, 
			    g_winInfo.xkb.options);
	  XkbInitKeyboardDeviceStruct (pDeviceInt, &names, &keySyms,
				       modMap, winKeybdBell, winKeybdCtrl);
	}
#endif

#ifdef XKB
      if (!g_winInfo.xkb.disable)
        {  
          xkbi = pDeviceInt->key->xkbInfo;
          if (xkbi != NULL)
            {  
              ctrl = xkbi->desc->ctrls;
              ctrl->repeat_delay = g_winInfo.keyboard.delay;
              ctrl->repeat_interval = 1000/g_winInfo.keyboard.rate;
            }
          else
            {  
              winErrorFVerb (1, "winKeybdProc - Error initializing keyboard AutoRepeat (No XKB)\n");
            }
a184 1
#endif
a185 1
      g_winInternalModeKeyStatesPtr = &(pDeviceInt->key->state);
d190 4
a193 1
      g_winInternalModeKeyStatesPtr = &(pDeviceInt->key->state);
a198 1
      g_winInternalModeKeyStatesPtr = NULL;
d253 1
a253 1
winRestoreModeKeyStates ()
d260 1
a260 1
  if (!g_winInternalModeKeyStatesPtr)
d273 3
a275 1
  internalKeyStates = *g_winInternalModeKeyStatesPtr;
d441 1
a441 1
winKeybdReleaseKeys ()
d473 2
a474 1
  xEvent			xCurrentEvent;
a483 2
  
  ZeroMemory (&xCurrentEvent, sizeof (xCurrentEvent));
d485 10
a494 5
  xCurrentEvent.u.u.type = fDown ? KeyPress : KeyRelease;
  xCurrentEvent.u.keyButtonPointer.time =
    g_c32LastInputEventTime = GetTickCount ();
  xCurrentEvent.u.u.detail = dwKey + MIN_KEYCODE;
  mieqEnqueue (&xCurrentEvent);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d47 1
a47 1
#include <xkbsrv.h>
@

