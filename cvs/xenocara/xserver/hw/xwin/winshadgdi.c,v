head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 2001-2004 Harold L Hunt II All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL HAROLD L HUNT II BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of Harold L Hunt II
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from Harold L Hunt II.
 *
 * Authors:	Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

/*
 * Local function prototypes
 */

#ifdef XWIN_MULTIWINDOW
static wBOOL CALLBACK winRedrawAllProcShadowGDI(HWND hwnd, LPARAM lParam);

static wBOOL CALLBACK winRedrawDamagedWindowShadowGDI(HWND hwnd, LPARAM lParam);
#endif

static Bool
 winAllocateFBShadowGDI(ScreenPtr pScreen);

static void
 winShadowUpdateGDI(ScreenPtr pScreen, shadowBufPtr pBuf);

static Bool
 winCloseScreenShadowGDI(ScreenPtr pScreen);

static Bool
 winInitVisualsShadowGDI(ScreenPtr pScreen);

static Bool
 winAdjustVideoModeShadowGDI(ScreenPtr pScreen);

static Bool
 winBltExposedRegionsShadowGDI(ScreenPtr pScreen);

static Bool
 winActivateAppShadowGDI(ScreenPtr pScreen);

static Bool
 winRedrawScreenShadowGDI(ScreenPtr pScreen);

static Bool
 winRealizeInstalledPaletteShadowGDI(ScreenPtr pScreen);

static Bool
 winInstallColormapShadowGDI(ColormapPtr pColormap);

static Bool
 winStoreColorsShadowGDI(ColormapPtr pmap, int ndef, xColorItem * pdefs);

static Bool
 winCreateColormapShadowGDI(ColormapPtr pColormap);

static Bool
 winDestroyColormapShadowGDI(ColormapPtr pColormap);

/*
 * Internal function to get the DIB format that is compatible with the screen
 */

static
    Bool
winQueryScreenDIBFormat(ScreenPtr pScreen, BITMAPINFOHEADER * pbmih)
{
    winScreenPriv(pScreen);
    HBITMAP hbmp;

#if CYGDEBUG
    LPDWORD pdw = NULL;
#endif

    /* Create a memory bitmap compatible with the screen */
    hbmp = CreateCompatibleBitmap(pScreenPriv->hdcScreen, 1, 1);
    if (hbmp == NULL) {
        ErrorF("winQueryScreenDIBFormat - CreateCompatibleBitmap failed\n");
        return FALSE;
    }

    /* Initialize our bitmap info header */
    ZeroMemory(pbmih, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
    pbmih->biSize = sizeof(BITMAPINFOHEADER);

    /* Get the biBitCount */
    if (!GetDIBits(pScreenPriv->hdcScreen,
                   hbmp, 0, 1, NULL, (BITMAPINFO *) pbmih, DIB_RGB_COLORS)) {
        ErrorF("winQueryScreenDIBFormat - First call to GetDIBits failed\n");
        DeleteObject(hbmp);
        return FALSE;
    }

#if CYGDEBUG
    /* Get a pointer to bitfields */
    pdw = (DWORD *) ((CARD8 *) pbmih + sizeof(BITMAPINFOHEADER));

    winDebug("winQueryScreenDIBFormat - First call masks: %08x %08x %08x\n",
             (unsigned int)pdw[0], (unsigned int)pdw[1], (unsigned int)pdw[2]);
#endif

    /* Get optimal color table, or the optimal bitfields */
    if (!GetDIBits(pScreenPriv->hdcScreen,
                   hbmp, 0, 1, NULL, (BITMAPINFO *) pbmih, DIB_RGB_COLORS)) {
        ErrorF("winQueryScreenDIBFormat - Second call to GetDIBits "
               "failed\n");
        DeleteObject(hbmp);
        return FALSE;
    }

    /* Free memory */
    DeleteObject(hbmp);

    return TRUE;
}

/*
 * Internal function to determine the GDI bits per rgb and bit masks
 */

static
    Bool
winQueryRGBBitsAndMasks(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    BITMAPINFOHEADER *pbmih = NULL;
    Bool fReturn = TRUE;
    LPDWORD pdw = NULL;
    DWORD dwRedBits, dwGreenBits, dwBlueBits;

    /* Color masks for 8 bpp are standardized */
    if (GetDeviceCaps(pScreenPriv->hdcScreen, RASTERCAPS) & RC_PALETTE) {
        /*
         * RGB BPP for 8 bit palletes is always 8
         * and the color masks are always 0.
         */
        pScreenPriv->dwBitsPerRGB = 8;
        pScreenPriv->dwRedMask = 0x0L;
        pScreenPriv->dwGreenMask = 0x0L;
        pScreenPriv->dwBlueMask = 0x0L;
        return TRUE;
    }

    /* Color masks for 24 bpp are standardized */
    if (GetDeviceCaps(pScreenPriv->hdcScreen, PLANES)
        * GetDeviceCaps(pScreenPriv->hdcScreen, BITSPIXEL) == 24) {
        ErrorF("winQueryRGBBitsAndMasks - GetDeviceCaps (BITSPIXEL) "
               "returned 24 for the screen.  Using default 24bpp masks.\n");

        /* 8 bits per primary color */
        pScreenPriv->dwBitsPerRGB = 8;

        /* Set screen privates masks */
        pScreenPriv->dwRedMask = WIN_24BPP_MASK_RED;
        pScreenPriv->dwGreenMask = WIN_24BPP_MASK_GREEN;
        pScreenPriv->dwBlueMask = WIN_24BPP_MASK_BLUE;

        return TRUE;
    }

    /* Allocate a bitmap header and color table */
    pbmih = malloc(sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
    if (pbmih == NULL) {
        ErrorF("winQueryRGBBitsAndMasks - malloc failed\n");
        return FALSE;
    }

    /* Get screen description */
    if (winQueryScreenDIBFormat(pScreen, pbmih)) {
        /* Get a pointer to bitfields */
        pdw = (DWORD *) ((CARD8 *) pbmih + sizeof(BITMAPINFOHEADER));

#if CYGDEBUG
        winDebug("%s - Masks: %08x %08x %08x\n", __FUNCTION__,
                 (unsigned int)pdw[0], (unsigned int)pdw[1], (unsigned int)pdw[2]);
        winDebug("%s - Bitmap: %dx%d %d bpp %d planes\n", __FUNCTION__,
                 (int)pbmih->biWidth, (int)pbmih->biHeight, pbmih->biBitCount,
                 pbmih->biPlanes);
        winDebug("%s - Compression: %u %s\n", __FUNCTION__,
                 (unsigned int)pbmih->biCompression,
                 (pbmih->biCompression ==
                  BI_RGB ? "(BI_RGB)" : (pbmih->biCompression ==
                                         BI_RLE8 ? "(BI_RLE8)" : (pbmih->
                                                                  biCompression
                                                                  ==
                                                                  BI_RLE4 ?
                                                                  "(BI_RLE4)"
                                                                  : (pbmih->
                                                                     biCompression
                                                                     ==
                                                                     BI_BITFIELDS
                                                                     ?
                                                                     "(BI_BITFIELDS)"
                                                                     : "")))));
#endif

        /* Handle BI_RGB case, which is returned by Wine */
        if (pbmih->biCompression == BI_RGB) {
            dwRedBits = 5;
            dwGreenBits = 5;
            dwBlueBits = 5;

            pScreenPriv->dwBitsPerRGB = 5;

            /* Set screen privates masks */
            pScreenPriv->dwRedMask = 0x7c00;
            pScreenPriv->dwGreenMask = 0x03e0;
            pScreenPriv->dwBlueMask = 0x001f;
        }
        else {
            /* Count the number of bits in each mask */
            dwRedBits = winCountBits(pdw[0]);
            dwGreenBits = winCountBits(pdw[1]);
            dwBlueBits = winCountBits(pdw[2]);

            /* Find maximum bits per red, green, blue */
            if (dwRedBits > dwGreenBits && dwRedBits > dwBlueBits)
                pScreenPriv->dwBitsPerRGB = dwRedBits;
            else if (dwGreenBits > dwRedBits && dwGreenBits > dwBlueBits)
                pScreenPriv->dwBitsPerRGB = dwGreenBits;
            else
                pScreenPriv->dwBitsPerRGB = dwBlueBits;

            /* Set screen privates masks */
            pScreenPriv->dwRedMask = pdw[0];
            pScreenPriv->dwGreenMask = pdw[1];
            pScreenPriv->dwBlueMask = pdw[2];
        }
    }
    else {
        ErrorF("winQueryRGBBitsAndMasks - winQueryScreenDIBFormat failed\n");
        fReturn = FALSE;
    }

    /* Free memory */
    free(pbmih);

    return fReturn;
}

#ifdef XWIN_MULTIWINDOW
/*
 * Redraw all ---?
 */

static wBOOL CALLBACK
winRedrawAllProcShadowGDI(HWND hwnd, LPARAM lParam)
{
    if (hwnd == (HWND) lParam)
        return TRUE;
    InvalidateRect(hwnd, NULL, FALSE);
    UpdateWindow(hwnd);
    return TRUE;
}

static wBOOL CALLBACK
winRedrawDamagedWindowShadowGDI(HWND hwnd, LPARAM lParam)
{
    BoxPtr pDamage = (BoxPtr) lParam;
    RECT rcClient, rcDamage, rcRedraw;
    POINT topLeft, bottomRight;

    if (IsIconic(hwnd))
        return TRUE;            /* Don't care minimized windows */

    /* Convert the damaged area from Screen coords to Client coords */
    topLeft.x = pDamage->x1;
    topLeft.y = pDamage->y1;
    bottomRight.x = pDamage->x2;
    bottomRight.y = pDamage->y2;
    topLeft.x += GetSystemMetrics(SM_XVIRTUALSCREEN);
    bottomRight.x += GetSystemMetrics(SM_XVIRTUALSCREEN);
    topLeft.y += GetSystemMetrics(SM_YVIRTUALSCREEN);
    bottomRight.y += GetSystemMetrics(SM_YVIRTUALSCREEN);
    ScreenToClient(hwnd, &topLeft);
    ScreenToClient(hwnd, &bottomRight);
    SetRect(&rcDamage, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);

    GetClientRect(hwnd, &rcClient);

    if (IntersectRect(&rcRedraw, &rcClient, &rcDamage)) {
        InvalidateRect(hwnd, &rcRedraw, FALSE);
        UpdateWindow(hwnd);
    }
    return TRUE;
}
#endif

/*
 * Allocate a DIB for the shadow framebuffer GDI server
 */

static Bool
winAllocateFBShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    DIBSECTION dibsection;
    Bool fReturn = TRUE;

    /* Describe shadow bitmap to be created */
    pScreenPriv->pbmih->biWidth = pScreenInfo->dwWidth;
    pScreenPriv->pbmih->biHeight = -pScreenInfo->dwHeight;

    ErrorF("winAllocateFBShadowGDI - Creating DIB with width: %d height: %d "
           "depth: %d\n",
           (int) pScreenPriv->pbmih->biWidth,
           (int) -pScreenPriv->pbmih->biHeight, pScreenPriv->pbmih->biBitCount);

    /* Create a DI shadow bitmap with a bit pointer */
    pScreenPriv->hbmpShadow = CreateDIBSection(pScreenPriv->hdcScreen,
                                               (BITMAPINFO *) pScreenPriv->
                                               pbmih, DIB_RGB_COLORS,
                                               (VOID **) &pScreenInfo->pfb,
                                               NULL, 0);
    if (pScreenPriv->hbmpShadow == NULL || pScreenInfo->pfb == NULL) {
        winW32Error(2, "winAllocateFBShadowGDI - CreateDIBSection failed:");
        return FALSE;
    }
    else {
#if CYGDEBUG
        winDebug("winAllocateFBShadowGDI - Shadow buffer allocated\n");
#endif
    }

    /* Get information about the bitmap that was allocated */
    GetObject(pScreenPriv->hbmpShadow, sizeof(dibsection), &dibsection);

#if CYGDEBUG || YES
    /* Print information about bitmap allocated */
    winDebug("winAllocateFBShadowGDI - Dibsection width: %d height: %d "
             "depth: %d size image: %d\n",
             (int) dibsection.dsBmih.biWidth, (int) dibsection.dsBmih.biHeight,
             dibsection.dsBmih.biBitCount, (int) dibsection.dsBmih.biSizeImage);
#endif

    /* Select the shadow bitmap into the shadow DC */
    SelectObject(pScreenPriv->hdcShadow, pScreenPriv->hbmpShadow);

#if CYGDEBUG
    winDebug("winAllocateFBShadowGDI - Attempting a shadow blit\n");
#endif

    /* Do a test blit from the shadow to the screen, I think */
    fReturn = BitBlt(pScreenPriv->hdcScreen,
                     0, 0,
                     pScreenInfo->dwWidth, pScreenInfo->dwHeight,
                     pScreenPriv->hdcShadow, 0, 0, SRCCOPY);
    if (fReturn) {
#if CYGDEBUG
        winDebug("winAllocateFBShadowGDI - Shadow blit success\n");
#endif
    }
    else {
        winW32Error(2, "winAllocateFBShadowGDI - Shadow blit failure\n");
#if 0
        return FALSE;
#else
        /* ago: ignore this error. The blit fails with wine, but does not
         * cause any problems later. */

        fReturn = TRUE;
#endif
    }

    /* Look for height weirdness */
    if (dibsection.dsBmih.biHeight < 0) {
        dibsection.dsBmih.biHeight = -dibsection.dsBmih.biHeight;
    }

    /* Set screeninfo stride */
    pScreenInfo->dwStride = ((dibsection.dsBmih.biSizeImage
                              / dibsection.dsBmih.biHeight)
                             * 8) / pScreenInfo->dwBPP;

#if CYGDEBUG || YES
    winDebug("winAllocateFBShadowGDI - Created shadow stride: %d\n",
             (int) pScreenInfo->dwStride);
#endif

#ifdef XWIN_MULTIWINDOW
    /* Redraw all windows */
    if (pScreenInfo->fMultiWindow)
        EnumThreadWindows(g_dwCurrentThreadID, winRedrawAllProcShadowGDI, 0);
#endif

    return fReturn;
}

static void
winFreeFBShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Free the shadow bitmap */
    DeleteObject(pScreenPriv->hbmpShadow);

    /* Invalidate the ScreenInfo's fb pointer */
    pScreenInfo->pfb = NULL;
}

/*
 * Blit the damaged regions of the shadow fb to the screen
 */

static void
winShadowUpdateGDI(ScreenPtr pScreen, shadowBufPtr pBuf)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    RegionPtr damage = shadowDamage(pBuf);
    DWORD dwBox = RegionNumRects(damage);
    BoxPtr pBox = RegionRects(damage);
    int x, y, w, h;
    HRGN hrgnCombined = NULL;

#ifdef XWIN_UPDATESTATS
    static DWORD s_dwNonUnitRegions = 0;
    static DWORD s_dwTotalUpdates = 0;
    static DWORD s_dwTotalBoxes = 0;
#endif
    BoxPtr pBoxExtents = RegionExtents(damage);

    /*
     * Return immediately if the app is not active
     * and we are fullscreen, or if we have a bad display depth
     */
    if ((!pScreenPriv->fActive && pScreenInfo->fFullScreen)
        || pScreenPriv->fBadDepth)
        return;

#ifdef XWIN_UPDATESTATS
    ++s_dwTotalUpdates;
    s_dwTotalBoxes += dwBox;

    if (dwBox != 1) {
        ++s_dwNonUnitRegions;
        ErrorF("winShadowUpdatGDI - dwBox: %d\n", dwBox);
    }

    if ((s_dwTotalUpdates % 100) == 0)
        ErrorF("winShadowUpdateGDI - %d%% non-unity regions, avg boxes: %d "
               "nu: %d tu: %d\n",
               (s_dwNonUnitRegions * 100) / s_dwTotalUpdates,
               s_dwTotalBoxes / s_dwTotalUpdates,
               s_dwNonUnitRegions, s_dwTotalUpdates);
#endif                          /* XWIN_UPDATESTATS */

    /*
     * Handle small regions with multiple blits,
     * handle large regions by creating a clipping region and
     * doing a single blit constrained to that clipping region.
     */
    if (!pScreenInfo->fMultiWindow &&
        (pScreenInfo->dwClipUpdatesNBoxes == 0 ||
         dwBox < pScreenInfo->dwClipUpdatesNBoxes)) {
        /* Loop through all boxes in the damaged region */
        while (dwBox--) {
            /*
             * Calculate x offset, y offset, width, and height for
             * current damage box
             */
            x = pBox->x1;
            y = pBox->y1;
            w = pBox->x2 - pBox->x1;
            h = pBox->y2 - pBox->y1;

            BitBlt(pScreenPriv->hdcScreen,
                   x, y, w, h, pScreenPriv->hdcShadow, x, y, SRCCOPY);

            /* Get a pointer to the next box */
            ++pBox;
        }
    }
    else if (!pScreenInfo->fMultiWindow) {

        /* Compute a GDI region from the damaged region */
        hrgnCombined =
            CreateRectRgn(pBoxExtents->x1, pBoxExtents->y1, pBoxExtents->x2,
                          pBoxExtents->y2);

        /* Install the GDI region as a clipping region */
        SelectClipRgn(pScreenPriv->hdcScreen, hrgnCombined);
        DeleteObject(hrgnCombined);
        hrgnCombined = NULL;

        /*
         * Blit the shadow buffer to the screen,
         * constrained to the clipping region.
         */
        BitBlt(pScreenPriv->hdcScreen,
               pBoxExtents->x1, pBoxExtents->y1,
               pBoxExtents->x2 - pBoxExtents->x1,
               pBoxExtents->y2 - pBoxExtents->y1,
               pScreenPriv->hdcShadow,
               pBoxExtents->x1, pBoxExtents->y1, SRCCOPY);

        /* Reset the clip region */
        SelectClipRgn(pScreenPriv->hdcScreen, NULL);
    }

#ifdef XWIN_MULTIWINDOW
    /* Redraw all multiwindow windows */
    if (pScreenInfo->fMultiWindow)
        EnumThreadWindows(g_dwCurrentThreadID,
                          winRedrawDamagedWindowShadowGDI,
                          (LPARAM) pBoxExtents);
#endif
}

static Bool
winInitScreenShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);

    /* Get device contexts for the screen and shadow bitmap */
    pScreenPriv->hdcScreen = GetDC(pScreenPriv->hwndScreen);
    pScreenPriv->hdcShadow = CreateCompatibleDC(pScreenPriv->hdcScreen);

    /* Allocate bitmap info header */
    pScreenPriv->pbmih = malloc(sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
    if (pScreenPriv->pbmih == NULL) {
        ErrorF("winInitScreenShadowGDI - malloc () failed\n");
        return FALSE;
    }

    /* Query the screen format */
    if (!winQueryScreenDIBFormat(pScreen, pScreenPriv->pbmih)) {
        ErrorF("winInitScreenShadowGDI - winQueryScreenDIBFormat failed\n");
        return FALSE;
    }

    /* Determine our color masks */
    if (!winQueryRGBBitsAndMasks(pScreen)) {
        ErrorF("winInitScreenShadowGDI - winQueryRGBBitsAndMasks failed\n");
        return FALSE;
    }

    return winAllocateFBShadowGDI(pScreen);
}

/* See Porting Layer Definition - p. 33 */
/*
 * We wrap whatever CloseScreen procedure was specified by fb;
 * a pointer to said procedure is stored in our privates.
 */

static Bool
winCloseScreenShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    Bool fReturn;

#if CYGDEBUG
    winDebug("winCloseScreenShadowGDI - Freeing screen resources\n");
#endif

    /* Flag that the screen is closed */
    pScreenPriv->fClosed = TRUE;
    pScreenPriv->fActive = FALSE;

    /* Call the wrapped CloseScreen procedure */
    WIN_UNWRAP(CloseScreen);
    if (pScreen->CloseScreen)
        fReturn = (*pScreen->CloseScreen) (pScreen);

    /* Delete the window property */
    RemoveProp(pScreenPriv->hwndScreen, WIN_SCR_PROP);

    /* Free the shadow DC; which allows the bitmap to be freed */
    DeleteDC(pScreenPriv->hdcShadow);

    winFreeFBShadowGDI(pScreen);

    /* Free the screen DC */
    ReleaseDC(pScreenPriv->hwndScreen, pScreenPriv->hdcScreen);

    /* Delete tray icon, if we have one */
    if (!pScreenInfo->fNoTrayIcon)
        winDeleteNotifyIcon(pScreenPriv);

    /* Free the exit confirmation dialog box, if it exists */
    if (g_hDlgExit != NULL) {
        DestroyWindow(g_hDlgExit);
        g_hDlgExit = NULL;
    }

    /* Kill our window */
    if (pScreenPriv->hwndScreen) {
        DestroyWindow(pScreenPriv->hwndScreen);
        pScreenPriv->hwndScreen = NULL;
    }

#if defined(XWIN_CLIPBOARD) || defined(XWIN_MULTIWINDOW)
    /* Destroy the thread startup mutex */
    pthread_mutex_destroy(&pScreenPriv->pmServerStarted);
#endif

    /* Invalidate our screeninfo's pointer to the screen */
    pScreenInfo->pScreen = NULL;

    /* Free the screen privates for this screen */
    free((void *) pScreenPriv);

    return fReturn;
}

/*
 * Tell mi what sort of visuals we need.
 *
 * Generally we only need one visual, as our screen can only
 * handle one format at a time, I believe.  You may want
 * to verify that last sentence.
 */

static Bool
winInitVisualsShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Display debugging information */
    ErrorF("winInitVisualsShadowGDI - Masks %08x %08x %08x BPRGB %d d %d "
           "bpp %d\n",
           (unsigned int) pScreenPriv->dwRedMask,
           (unsigned int) pScreenPriv->dwGreenMask,
           (unsigned int) pScreenPriv->dwBlueMask,
           (int) pScreenPriv->dwBitsPerRGB,
           (int) pScreenInfo->dwDepth, (int) pScreenInfo->dwBPP);

    /* Create a single visual according to the Windows screen depth */
    switch (pScreenInfo->dwDepth) {
    case 24:
    case 16:
    case 15:
        /* Setup the real visual */
        if (!miSetVisualTypesAndMasks(pScreenInfo->dwDepth,
                                      TrueColorMask,
                                      pScreenPriv->dwBitsPerRGB,
                                      -1,
                                      pScreenPriv->dwRedMask,
                                      pScreenPriv->dwGreenMask,
                                      pScreenPriv->dwBlueMask)) {
            ErrorF("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
                   "failed\n");
            return FALSE;
        }

#ifdef XWIN_EMULATEPSEUDO
        if (!pScreenInfo->fEmulatePseudo)
            break;

        /* Setup a pseudocolor visual */
        if (!miSetVisualTypesAndMasks(8, PseudoColorMask, 8, -1, 0, 0, 0)) {
            ErrorF("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
                   "failed for PseudoColor\n");
            return FALSE;
        }
#endif
        break;

    case 8:
        if (!miSetVisualTypesAndMasks(pScreenInfo->dwDepth,
                                      PseudoColorMask,
                                      pScreenPriv->dwBitsPerRGB,
                                      PseudoColor,
                                      pScreenPriv->dwRedMask,
                                      pScreenPriv->dwGreenMask,
                                      pScreenPriv->dwBlueMask)) {
            ErrorF("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
                   "failed\n");
            return FALSE;
        }
        break;

    default:
        ErrorF("winInitVisualsShadowGDI - Unknown screen depth\n");
        return FALSE;
    }

#if CYGDEBUG
    winDebug("winInitVisualsShadowGDI - Returning\n");
#endif

    return TRUE;
}

/*
 * Adjust the proposed video mode
 */

static Bool
winAdjustVideoModeShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    HDC hdc;
    DWORD dwBPP;

    hdc = GetDC(NULL);

    /* We're in serious trouble if we can't get a DC */
    if (hdc == NULL) {
        ErrorF("winAdjustVideoModeShadowGDI - GetDC () failed\n");
        return FALSE;
    }

    /* Query GDI for current display depth */
    dwBPP = GetDeviceCaps(hdc, BITSPIXEL);

    /* GDI cannot change the screen depth, so always use GDI's depth */
    pScreenInfo->dwBPP = dwBPP;

    /* Release our DC */
    ReleaseDC(NULL, hdc);
    hdc = NULL;

    return TRUE;
}

/*
 * Blt exposed regions to the screen
 */

static Bool
winBltExposedRegionsShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    winPrivCmapPtr pCmapPriv = NULL;
    HDC hdcUpdate;
    PAINTSTRUCT ps;

    /* BeginPaint gives us an hdc that clips to the invalidated region */
    hdcUpdate = BeginPaint(pScreenPriv->hwndScreen, &ps);

    /* Realize the palette, if we have one */
    if (pScreenPriv->pcmapInstalled != NULL) {
        pCmapPriv = winGetCmapPriv(pScreenPriv->pcmapInstalled);

        SelectPalette(hdcUpdate, pCmapPriv->hPalette, FALSE);
        RealizePalette(hdcUpdate);
    }

    /* Our BitBlt will be clipped to the invalidated region */
    BitBlt(hdcUpdate,
           0, 0,
           pScreenInfo->dwWidth, pScreenInfo->dwHeight,
           pScreenPriv->hdcShadow, 0, 0, SRCCOPY);

    /* EndPaint frees the DC */
    EndPaint(pScreenPriv->hwndScreen, &ps);

#ifdef XWIN_MULTIWINDOW
    /* Redraw all windows */
    if (pScreenInfo->fMultiWindow)
        EnumThreadWindows(g_dwCurrentThreadID, winRedrawAllProcShadowGDI,
                          (LPARAM) pScreenPriv->hwndScreen);
#endif

    return TRUE;
}

/*
 * Do any engine-specific appliation-activation processing
 */

static Bool
winActivateAppShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /*
     * 2004/04/12 - Harold - We perform the restoring or minimizing
     * manually for ShadowGDI in fullscreen modes so that this engine
     * will perform just like ShadowDD and ShadowDDNL in fullscreen mode;
     * if we do not do this then our fullscreen window will appear in the
     * z-order when it is deactivated and it can be uncovered by resizing
     * or minimizing another window that is on top of it, which is not how
     * the DirectDraw engines work.  Therefore we keep this code here to
     * make sure that all engines work the same in fullscreen mode.
     */

    /*
     * Are we active?
     * Are we fullscreen?
     */
    if (pScreenPriv->fActive && pScreenInfo->fFullScreen) {
        /*
         * Activating, attempt to bring our window
         * to the top of the display
         */
        ShowWindow(pScreenPriv->hwndScreen, SW_RESTORE);
    }
    else if (!pScreenPriv->fActive && pScreenInfo->fFullScreen) {
        /*
         * Deactivating, stuff our window onto the
         * task bar.
         */
        ShowWindow(pScreenPriv->hwndScreen, SW_MINIMIZE);
    }

    return TRUE;
}

/*
 * Reblit the shadow framebuffer to the screen.
 */

static Bool
winRedrawScreenShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Redraw the whole window, to take account for the new colors */
    BitBlt(pScreenPriv->hdcScreen,
           0, 0,
           pScreenInfo->dwWidth, pScreenInfo->dwHeight,
           pScreenPriv->hdcShadow, 0, 0, SRCCOPY);

#ifdef XWIN_MULTIWINDOW
    /* Redraw all windows */
    if (pScreenInfo->fMultiWindow)
        EnumThreadWindows(g_dwCurrentThreadID, winRedrawAllProcShadowGDI, 0);
#endif

    return TRUE;
}

/*
 * Realize the currently installed colormap
 */

static Bool
winRealizeInstalledPaletteShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winPrivCmapPtr pCmapPriv = NULL;

#if CYGDEBUG
    winDebug("winRealizeInstalledPaletteShadowGDI\n");
#endif

    /* Don't do anything if there is not a colormap */
    if (pScreenPriv->pcmapInstalled == NULL) {
#if CYGDEBUG
        winDebug("winRealizeInstalledPaletteShadowGDI - No colormap "
                 "installed\n");
#endif
        return TRUE;
    }

    pCmapPriv = winGetCmapPriv(pScreenPriv->pcmapInstalled);

    /* Realize our palette for the screen */
    if (RealizePalette(pScreenPriv->hdcScreen) == GDI_ERROR) {
        ErrorF("winRealizeInstalledPaletteShadowGDI - RealizePalette () "
               "failed\n");
        return FALSE;
    }

    /* Set the DIB color table */
    if (SetDIBColorTable(pScreenPriv->hdcShadow,
                         0,
                         WIN_NUM_PALETTE_ENTRIES, pCmapPriv->rgbColors) == 0) {
        ErrorF("winRealizeInstalledPaletteShadowGDI - SetDIBColorTable () "
               "failed\n");
        return FALSE;
    }

    return TRUE;
}

/*
 * Install the specified colormap
 */

static Bool
winInstallColormapShadowGDI(ColormapPtr pColormap)
{
    ScreenPtr pScreen = pColormap->pScreen;

    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    winCmapPriv(pColormap);

    /*
     * Tell Windows to install the new colormap
     */
    if (SelectPalette(pScreenPriv->hdcScreen,
                      pCmapPriv->hPalette, FALSE) == NULL) {
        ErrorF("winInstallColormapShadowGDI - SelectPalette () failed\n");
        return FALSE;
    }

    /* Realize the palette */
    if (GDI_ERROR == RealizePalette(pScreenPriv->hdcScreen)) {
        ErrorF("winInstallColormapShadowGDI - RealizePalette () failed\n");
        return FALSE;
    }

    /* Set the DIB color table */
    if (SetDIBColorTable(pScreenPriv->hdcShadow,
                         0,
                         WIN_NUM_PALETTE_ENTRIES, pCmapPriv->rgbColors) == 0) {
        ErrorF("winInstallColormapShadowGDI - SetDIBColorTable () failed\n");
        return FALSE;
    }

    /* Redraw the whole window, to take account for the new colors */
    BitBlt(pScreenPriv->hdcScreen,
           0, 0,
           pScreenInfo->dwWidth, pScreenInfo->dwHeight,
           pScreenPriv->hdcShadow, 0, 0, SRCCOPY);

    /* Save a pointer to the newly installed colormap */
    pScreenPriv->pcmapInstalled = pColormap;

#ifdef XWIN_MULTIWINDOW
    /* Redraw all windows */
    if (pScreenInfo->fMultiWindow)
        EnumThreadWindows(g_dwCurrentThreadID, winRedrawAllProcShadowGDI, 0);
#endif

    return TRUE;
}

/*
 * Store the specified colors in the specified colormap
 */

static Bool
winStoreColorsShadowGDI(ColormapPtr pColormap, int ndef, xColorItem * pdefs)
{
    ScreenPtr pScreen = pColormap->pScreen;

    winScreenPriv(pScreen);
    winCmapPriv(pColormap);
    ColormapPtr curpmap = pScreenPriv->pcmapInstalled;

    /* Put the X colormap entries into the Windows logical palette */
    if (SetPaletteEntries(pCmapPriv->hPalette,
                          pdefs[0].pixel,
                          ndef, pCmapPriv->peColors + pdefs[0].pixel) == 0) {
        ErrorF("winStoreColorsShadowGDI - SetPaletteEntries () failed\n");
        return FALSE;
    }

    /* Don't install the Windows palette if the colormap is not installed */
    if (pColormap != curpmap) {
        return TRUE;
    }

    /* Try to install the newly modified colormap */
    if (!winInstallColormapShadowGDI(pColormap)) {
        ErrorF("winInstallColormapShadowGDI - winInstallColormapShadowGDI "
               "failed\n");
        return FALSE;
    }

#if 0
    /* Tell Windows that the palette has changed */
    RealizePalette(pScreenPriv->hdcScreen);

    /* Set the DIB color table */
    if (SetDIBColorTable(pScreenPriv->hdcShadow,
                         pdefs[0].pixel,
                         ndef, pCmapPriv->rgbColors + pdefs[0].pixel) == 0) {
        ErrorF("winInstallColormapShadowGDI - SetDIBColorTable () failed\n");
        return FALSE;
    }

    /* Save a pointer to the newly installed colormap */
    pScreenPriv->pcmapInstalled = pColormap;
#endif

    return TRUE;
}

/*
 * Colormap initialization procedure
 */

static Bool
winCreateColormapShadowGDI(ColormapPtr pColormap)
{
    LPLOGPALETTE lpPaletteNew = NULL;
    DWORD dwEntriesMax;
    VisualPtr pVisual;
    HPALETTE hpalNew = NULL;

    winCmapPriv(pColormap);

    /* Get a pointer to the visual that the colormap belongs to */
    pVisual = pColormap->pVisual;

    /* Get the maximum number of palette entries for this visual */
    dwEntriesMax = pVisual->ColormapEntries;

    /* Allocate a Windows logical color palette with max entries */
    lpPaletteNew = malloc(sizeof(LOGPALETTE)
                          + (dwEntriesMax - 1) * sizeof(PALETTEENTRY));
    if (lpPaletteNew == NULL) {
        ErrorF("winCreateColormapShadowGDI - Couldn't allocate palette "
               "with %d entries\n", (int) dwEntriesMax);
        return FALSE;
    }

    /* Zero out the colormap */
    ZeroMemory(lpPaletteNew, sizeof(LOGPALETTE)
               + (dwEntriesMax - 1) * sizeof(PALETTEENTRY));

    /* Set the logical palette structure */
    lpPaletteNew->palVersion = 0x0300;
    lpPaletteNew->palNumEntries = dwEntriesMax;

    /* Tell Windows to create the palette */
    hpalNew = CreatePalette(lpPaletteNew);
    if (hpalNew == NULL) {
        ErrorF("winCreateColormapShadowGDI - CreatePalette () failed\n");
        free(lpPaletteNew);
        return FALSE;
    }

    /* Save the Windows logical palette handle in the X colormaps' privates */
    pCmapPriv->hPalette = hpalNew;

    /* Free the palette initialization memory */
    free(lpPaletteNew);

    return TRUE;
}

/*
 * Colormap destruction procedure
 */

static Bool
winDestroyColormapShadowGDI(ColormapPtr pColormap)
{
    winScreenPriv(pColormap->pScreen);
    winCmapPriv(pColormap);

    /*
     * Is colormap to be destroyed the default?
     *
     * Non-default colormaps should have had winUninstallColormap
     * called on them before we get here.  The default colormap
     * will not have had winUninstallColormap called on it.  Thus,
     * we need to handle the default colormap in a special way.
     */
    if (pColormap->flags & IsDefault) {
#if CYGDEBUG
        winDebug("winDestroyColormapShadowGDI - Destroying default "
                 "colormap\n");
#endif

        /*
         * FIXME: Walk the list of all screens, popping the default
         * palette out of each screen device context.
         */

        /* Pop the palette out of the device context */
        SelectPalette(pScreenPriv->hdcScreen,
                      GetStockObject(DEFAULT_PALETTE), FALSE);

        /* Clear our private installed colormap pointer */
        pScreenPriv->pcmapInstalled = NULL;
    }

    /* Try to delete the logical palette */
    if (DeleteObject(pCmapPriv->hPalette) == 0) {
        ErrorF("winDestroyColormap - DeleteObject () failed\n");
        return FALSE;
    }

    /* Invalidate the colormap privates */
    pCmapPriv->hPalette = NULL;

    return TRUE;
}

/*
 * Set engine specific funtions
 */

Bool
winSetEngineFunctionsShadowGDI(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Set our pointers */
    pScreenPriv->pwinAllocateFB = winAllocateFBShadowGDI;
    pScreenPriv->pwinFreeFB = winFreeFBShadowGDI;
    pScreenPriv->pwinShadowUpdate = winShadowUpdateGDI;
    pScreenPriv->pwinInitScreen = winInitScreenShadowGDI;
    pScreenPriv->pwinCloseScreen = winCloseScreenShadowGDI;
    pScreenPriv->pwinInitVisuals = winInitVisualsShadowGDI;
    pScreenPriv->pwinAdjustVideoMode = winAdjustVideoModeShadowGDI;
    if (pScreenInfo->fFullScreen)
        pScreenPriv->pwinCreateBoundingWindow =
            winCreateBoundingWindowFullScreen;
    else
        pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowWindowed;
    pScreenPriv->pwinFinishScreenInit = winFinishScreenInitFB;
    pScreenPriv->pwinBltExposedRegions = winBltExposedRegionsShadowGDI;
    pScreenPriv->pwinActivateApp = winActivateAppShadowGDI;
    pScreenPriv->pwinRedrawScreen = winRedrawScreenShadowGDI;
    pScreenPriv->pwinRealizeInstalledPalette =
        winRealizeInstalledPaletteShadowGDI;
    pScreenPriv->pwinInstallColormap = winInstallColormapShadowGDI;
    pScreenPriv->pwinStoreColors = winStoreColorsShadowGDI;
    pScreenPriv->pwinCreateColormap = winCreateColormapShadowGDI;
    pScreenPriv->pwinDestroyColormap = winDestroyColormapShadowGDI;
    pScreenPriv->pwinHotKeyAltTab =
        (winHotKeyAltTabProcPtr) (void (*)(void)) NoopDDA;
    pScreenPriv->pwinCreatePrimarySurface =
        (winCreatePrimarySurfaceProcPtr) (void (*)(void)) NoopDDA;
    pScreenPriv->pwinReleasePrimarySurface =
        (winReleasePrimarySurfaceProcPtr) (void (*)(void)) NoopDDA;
#ifdef XWIN_MULTIWINDOW
    pScreenPriv->pwinFinishCreateWindowsWindow =
        (winFinishCreateWindowsWindowProcPtr) (void (*)(void)) NoopDDA;
#endif

    return TRUE;
}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d124 1
a124 1
             pdw[0], pdw[1], pdw[2]);
d200 1
a200 1
                 pdw[0], pdw[1], pdw[2]);
d202 1
a202 1
                 pbmih->biWidth, pbmih->biHeight, pbmih->biBitCount,
d204 2
a205 2
        winDebug("%s - Compression: %d %s\n", __FUNCTION__,
                 pbmih->biCompression,
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d158 1
a158 1
        /* 
d384 1
a384 1
        /* ago: ignore this error. The blit fails with wine, but does not 
d477 1
a477 1
     * handle large regions by creating a clipping region and 
d637 1
a637 1
 * 
d818 1
a818 1
         * Activating, attempt to bring our window 
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d187 1
a187 2
    pbmih = (BITMAPINFOHEADER *) malloc(sizeof(BITMAPINFOHEADER)
                                        + 256 * sizeof(RGBQUAD));
d547 1
a547 2
    pScreenPriv->pbmih = (BITMAPINFOHEADER *) malloc(sizeof(BITMAPINFOHEADER)
                                                     + 256 * sizeof(RGBQUAD));
d630 1
a630 1
    free((pointer) pScreenPriv);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d53 1
a53 1
 winCloseScreenShadowGDI(int nIndex, ScreenPtr pScreen);
d340 1
a340 1
                                               (VOID **) & pScreenInfo->pfb,
d442 1
a442 1
    HRGN hrgnTemp = NULL, hrgnCombined = NULL;
d503 1
d505 3
a507 9
        hrgnCombined = CreateRectRgn(pBox->x1, pBox->y1, pBox->x2, pBox->y2);
        dwBox--;
        pBox++;
        while (dwBox--) {
            hrgnTemp = CreateRectRgn(pBox->x1, pBox->y1, pBox->x2, pBox->y2);
            CombineRgn(hrgnCombined, hrgnCombined, hrgnTemp, RGN_OR);
            DeleteObject(hrgnTemp);
            pBox++;
        }
d577 1
a577 1
winCloseScreenShadowGDI(int nIndex, ScreenPtr pScreen)
d594 1
a594 1
        fReturn = (*pScreen->CloseScreen) (nIndex, pScreen);
@


1.4
log
@Update to xserver 1.11.2
@
text
@a35 1

d41 1
a41 2
static wBOOL CALLBACK
winRedrawAllProcShadowGDI (HWND hwnd, LPARAM lParam);
d43 1
a43 2
static wBOOL CALLBACK
winRedrawDamagedWindowShadowGDI (HWND hwnd, LPARAM lParam);
d47 1
a47 1
winAllocateFBShadowGDI (ScreenPtr pScreen);
d50 1
a50 2
winShadowUpdateGDI (ScreenPtr pScreen, 
		    shadowBufPtr pBuf);
d53 1
a53 1
winCloseScreenShadowGDI (int nIndex, ScreenPtr pScreen);
d56 1
a56 1
winInitVisualsShadowGDI (ScreenPtr pScreen);
d59 1
a59 1
winAdjustVideoModeShadowGDI (ScreenPtr pScreen);
d62 1
a62 1
winBltExposedRegionsShadowGDI (ScreenPtr pScreen);
d65 1
a65 1
winActivateAppShadowGDI (ScreenPtr pScreen);
d68 1
a68 1
winRedrawScreenShadowGDI (ScreenPtr pScreen);
d71 1
a71 1
winRealizeInstalledPaletteShadowGDI (ScreenPtr pScreen);
d74 1
a74 1
winInstallColormapShadowGDI (ColormapPtr pColormap);
d77 1
a77 3
winStoreColorsShadowGDI (ColormapPtr pmap, 
			 int ndef,
			 xColorItem *pdefs);
d80 1
a80 1
winCreateColormapShadowGDI (ColormapPtr pColormap);
d83 1
a83 2
winDestroyColormapShadowGDI (ColormapPtr pColormap);

d90 2
a91 2
Bool
winQueryScreenDIBFormat (ScreenPtr pScreen, BITMAPINFOHEADER *pbmih)
d93 3
a95 2
  winScreenPriv(pScreen);
  HBITMAP		hbmp;
d97 1
a97 1
  LPDWORD		pdw = NULL;
d99 18
a116 24
  
  /* Create a memory bitmap compatible with the screen */
  hbmp = CreateCompatibleBitmap (pScreenPriv->hdcScreen, 1, 1);
  if (hbmp == NULL)
    {
      ErrorF ("winQueryScreenDIBFormat - CreateCompatibleBitmap failed\n");
      return FALSE;
    }
  
  /* Initialize our bitmap info header */
  ZeroMemory (pbmih, sizeof (BITMAPINFOHEADER) + 256 * sizeof (RGBQUAD));
  pbmih->biSize = sizeof (BITMAPINFOHEADER);

  /* Get the biBitCount */
  if (!GetDIBits (pScreenPriv->hdcScreen,
		  hbmp,
		  0, 1,
		  NULL,
		  (BITMAPINFO*) pbmih,
		  DIB_RGB_COLORS))
    {
      ErrorF ("winQueryScreenDIBFormat - First call to GetDIBits failed\n");
      DeleteObject (hbmp);
      return FALSE;
d120 2
a121 2
  /* Get a pointer to bitfields */
  pdw = (DWORD*) ((CARD8*)pbmih + sizeof (BITMAPINFOHEADER));
d123 2
a124 2
  winDebug ("winQueryScreenDIBFormat - First call masks: %08x %08x %08x\n",
	  pdw[0], pdw[1], pdw[2]);
d127 13
a139 18
  /* Get optimal color table, or the optimal bitfields */
  if (!GetDIBits (pScreenPriv->hdcScreen,
		  hbmp,
		  0, 1,
		  NULL,
		  (BITMAPINFO*)pbmih,
		  DIB_RGB_COLORS))
    {
      ErrorF ("winQueryScreenDIBFormat - Second call to GetDIBits "
	      "failed\n");
      DeleteObject (hbmp);
      return FALSE;
    }

  /* Free memory */
  DeleteObject (hbmp);
  
  return TRUE;
a141 1

d147 2
a148 2
Bool
winQueryRGBBitsAndMasks (ScreenPtr pScreen)
d150 49
a198 53
  winScreenPriv(pScreen);
  BITMAPINFOHEADER	*pbmih = NULL;
  Bool			fReturn = TRUE;
  LPDWORD		pdw = NULL;
  DWORD			dwRedBits, dwGreenBits, dwBlueBits;

  /* Color masks for 8 bpp are standardized */
  if (GetDeviceCaps (pScreenPriv->hdcScreen, RASTERCAPS) & RC_PALETTE)
    {
      /* 
       * RGB BPP for 8 bit palletes is always 8
       * and the color masks are always 0.
       */
      pScreenPriv->dwBitsPerRGB = 8;
      pScreenPriv->dwRedMask = 0x0L;
      pScreenPriv->dwGreenMask = 0x0L;
      pScreenPriv->dwBlueMask = 0x0L;
      return TRUE;
    }

  /* Color masks for 24 bpp are standardized */
  if (GetDeviceCaps (pScreenPriv->hdcScreen, PLANES)
      * GetDeviceCaps (pScreenPriv->hdcScreen, BITSPIXEL) == 24)
    {
      ErrorF ("winQueryRGBBitsAndMasks - GetDeviceCaps (BITSPIXEL) "
	      "returned 24 for the screen.  Using default 24bpp masks.\n");

      /* 8 bits per primary color */
      pScreenPriv->dwBitsPerRGB = 8;

      /* Set screen privates masks */
      pScreenPriv->dwRedMask = WIN_24BPP_MASK_RED;
      pScreenPriv->dwGreenMask = WIN_24BPP_MASK_GREEN;
      pScreenPriv->dwBlueMask = WIN_24BPP_MASK_BLUE;
      
      return TRUE;
    }

  /* Allocate a bitmap header and color table */
  pbmih = (BITMAPINFOHEADER*) malloc (sizeof (BITMAPINFOHEADER)
				      + 256  * sizeof (RGBQUAD));
  if (pbmih == NULL)
    {
      ErrorF ("winQueryRGBBitsAndMasks - malloc failed\n");
      return FALSE;
    }

  /* Get screen description */
  if (winQueryScreenDIBFormat (pScreen, pbmih))
    {
      /* Get a pointer to bitfields */
      pdw = (DWORD*) ((CARD8*)pbmih + sizeof (BITMAPINFOHEADER));
      
d200 35
a234 26
      winDebug ("%s - Masks: %08x %08x %08x\n", __FUNCTION__,
	      pdw[0], pdw[1], pdw[2]);
      winDebug ("%s - Bitmap: %dx%d %d bpp %d planes\n", __FUNCTION__,
              pbmih->biWidth, pbmih->biHeight, pbmih->biBitCount, pbmih->biPlanes);
      winDebug ("%s - Compression: %d %s\n", __FUNCTION__,
              pbmih->biCompression,
              (pbmih->biCompression == BI_RGB?"(BI_RGB)":
               (pbmih->biCompression == BI_RLE8?"(BI_RLE8)":
                (pbmih->biCompression == BI_RLE4?"(BI_RLE4)":
                 (pbmih->biCompression == BI_BITFIELDS?"(BI_BITFIELDS)":""
                 )))));
#endif

      /* Handle BI_RGB case, which is returned by Wine */
      if (pbmih->biCompression == BI_RGB)
        {
	  dwRedBits = 5;
	  dwGreenBits = 5;
	  dwBlueBits = 5;
	  
	  pScreenPriv->dwBitsPerRGB = 5;
	  
	  /* Set screen privates masks */
	  pScreenPriv->dwRedMask = 0x7c00;
	  pScreenPriv->dwGreenMask = 0x03e0;
	  pScreenPriv->dwBlueMask = 0x001f;
d236 23
a258 26
      else 
        {
          /* Count the number of bits in each mask */
          dwRedBits = winCountBits (pdw[0]);
          dwGreenBits = winCountBits (pdw[1]);
          dwBlueBits = winCountBits (pdw[2]);

	  /* Find maximum bits per red, green, blue */
	  if (dwRedBits > dwGreenBits && dwRedBits > dwBlueBits)
	    pScreenPriv->dwBitsPerRGB = dwRedBits;
	  else if (dwGreenBits > dwRedBits && dwGreenBits > dwBlueBits)
	    pScreenPriv->dwBitsPerRGB = dwGreenBits;
	  else
	    pScreenPriv->dwBitsPerRGB = dwBlueBits;

	  /* Set screen privates masks */
	  pScreenPriv->dwRedMask = pdw[0];
	  pScreenPriv->dwGreenMask = pdw[1];
	  pScreenPriv->dwBlueMask = pdw[2];
	}
    }
  else
    {
      ErrorF ("winQueryRGBBitsAndMasks - winQueryScreenDIBFormat failed\n");
      free (pbmih);
      fReturn = FALSE;
d261 2
a262 2
  /* Free memory */
  free (pbmih);
d264 1
a264 1
  return fReturn;
a266 1

d273 1
a273 1
winRedrawAllProcShadowGDI (HWND hwnd, LPARAM lParam)
d275 5
a279 5
  if (hwnd == (HWND)lParam)
    return TRUE;  
  InvalidateRect (hwnd, NULL, FALSE);
  UpdateWindow (hwnd);
  return TRUE;
d283 1
a283 1
winRedrawDamagedWindowShadowGDI (HWND hwnd, LPARAM lParam)
d285 25
a309 24
  BoxPtr pDamage = (BoxPtr)lParam;
  RECT rcClient, rcDamage, rcRedraw;
  POINT topLeft, bottomRight;
  
  if (IsIconic (hwnd))
    return TRUE; /* Don't care minimized windows */
  
  /* Convert the damaged area from Screen coords to Client coords */
  topLeft.x = pDamage->x1; topLeft.y = pDamage->y1;
  bottomRight.x = pDamage->x2; bottomRight.y = pDamage->y2;
  topLeft.x += GetSystemMetrics (SM_XVIRTUALSCREEN);
  bottomRight.x += GetSystemMetrics (SM_XVIRTUALSCREEN);
  topLeft.y += GetSystemMetrics (SM_YVIRTUALSCREEN);
  bottomRight.y += GetSystemMetrics (SM_YVIRTUALSCREEN);
  ScreenToClient (hwnd, &topLeft);
  ScreenToClient (hwnd, &bottomRight);
  SetRect (&rcDamage, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);

  GetClientRect (hwnd, &rcClient);

  if (IntersectRect (&rcRedraw, &rcClient, &rcDamage))
    {
      InvalidateRect (hwnd, &rcRedraw, FALSE);
      UpdateWindow (hwnd);
d311 1
a311 1
  return TRUE;
a314 1

d320 1
a320 1
winAllocateFBShadowGDI (ScreenPtr pScreen)
d322 23
a344 24
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  DIBSECTION		dibsection;
  Bool			fReturn = TRUE;

  /* Describe shadow bitmap to be created */
  pScreenPriv->pbmih->biWidth = pScreenInfo->dwWidth;
  pScreenPriv->pbmih->biHeight = -pScreenInfo->dwHeight;

  ErrorF ("winAllocateFBShadowGDI - Creating DIB with width: %d height: %d "
	  "depth: %d\n",
	  (int) pScreenPriv->pbmih->biWidth, (int) -pScreenPriv->pbmih->biHeight, pScreenPriv->pbmih->biBitCount);

  /* Create a DI shadow bitmap with a bit pointer */
  pScreenPriv->hbmpShadow = CreateDIBSection (pScreenPriv->hdcScreen,
					      (BITMAPINFO *) pScreenPriv->pbmih,
					      DIB_RGB_COLORS,
					      (VOID**) &pScreenInfo->pfb,
					      NULL,
					      0);
  if (pScreenPriv->hbmpShadow == NULL || pScreenInfo->pfb == NULL)
    {
      winW32Error (2, "winAllocateFBShadowGDI - CreateDIBSection failed:");
      return FALSE;
d346 1
a346 2
  else
    {
d348 1
a348 1
      winDebug ("winAllocateFBShadowGDI - Shadow buffer allocated\n");
d352 2
a353 4
  /* Get information about the bitmap that was allocated */
  GetObject (pScreenPriv->hbmpShadow,
	     sizeof (dibsection),
	     &dibsection);
d356 5
a360 6
  /* Print information about bitmap allocated */
  winDebug ("winAllocateFBShadowGDI - Dibsection width: %d height: %d "
	  "depth: %d size image: %d\n",
	  (int) dibsection.dsBmih.biWidth, (int) dibsection.dsBmih.biHeight,
	  dibsection.dsBmih.biBitCount,
	  (int) dibsection.dsBmih.biSizeImage);
d363 2
a364 3
  /* Select the shadow bitmap into the shadow DC */
  SelectObject (pScreenPriv->hdcShadow,
		pScreenPriv->hbmpShadow);
d367 1
a367 1
  winDebug ("winAllocateFBShadowGDI - Attempting a shadow blit\n");
d370 6
a375 9
  /* Do a test blit from the shadow to the screen, I think */
  fReturn = BitBlt (pScreenPriv->hdcScreen,
		    0, 0,
		    pScreenInfo->dwWidth, pScreenInfo->dwHeight,
		    pScreenPriv->hdcShadow,
		    0, 0,
		    SRCCOPY);
  if (fReturn)
    {
d377 1
a377 1
      winDebug ("winAllocateFBShadowGDI - Shadow blit success\n");
d380 7
a386 8
  else
    {
      winW32Error (2, "winAllocateFBShadowGDI - Shadow blit failure\n");
#if 0      
      return FALSE;
#else 
      /* ago: ignore this error. The blit fails with wine, but does not 
       * cause any problems later. */
d388 2
a389 2
      fReturn = TRUE;
#endif      
d392 3
a394 4
  /* Look for height weirdness */
  if (dibsection.dsBmih.biHeight < 0)
    {
      dibsection.dsBmih.biHeight = -dibsection.dsBmih.biHeight;
d397 4
a400 4
  /* Set screeninfo stride */
  pScreenInfo->dwStride = ((dibsection.dsBmih.biSizeImage
			    / dibsection.dsBmih.biHeight)
			   * 8) / pScreenInfo->dwBPP;
d403 2
a404 2
  winDebug ("winAllocateFBShadowGDI - Created shadow stride: %d\n",
	  (int) pScreenInfo->dwStride);
d408 3
a410 3
  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow)
    EnumThreadWindows (g_dwCurrentThreadID, winRedrawAllProcShadowGDI, 0);
d413 1
a413 1
  return fReturn;
d417 1
a417 1
winFreeFBShadowGDI (ScreenPtr pScreen)
d419 2
a420 2
  winScreenPriv(pScreen);
  winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
d422 2
a423 2
  /* Free the shadow bitmap */
  DeleteObject (pScreenPriv->hbmpShadow);
d425 2
a426 2
  /* Invalidate the ScreenInfo's fb pointer */
  pScreenInfo->pfb = NULL;
d434 1
a434 2
winShadowUpdateGDI (ScreenPtr pScreen, 
		    shadowBufPtr pBuf)
d436 8
a443 7
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  RegionPtr		damage = shadowDamage(pBuf);
  DWORD			dwBox = RegionNumRects (damage);
  BoxPtr		pBox = RegionRects (damage);
  int			x, y, w, h;
  HRGN			hrgnTemp = NULL, hrgnCombined = NULL;
d445 13
a457 12
  static DWORD		s_dwNonUnitRegions = 0;
  static DWORD		s_dwTotalUpdates = 0;
  static DWORD		s_dwTotalBoxes = 0;
#endif
  BoxPtr		pBoxExtents = RegionExtents(damage);

  /*
   * Return immediately if the app is not active
   * and we are fullscreen, or if we have a bad display depth
   */
  if ((!pScreenPriv->fActive && pScreenInfo->fFullScreen)
      || pScreenPriv->fBadDepth) return;
d460 2
a461 2
  ++s_dwTotalUpdates;
  s_dwTotalBoxes += dwBox;
d463 31
a493 76
  if (dwBox != 1)
    {
      ++s_dwNonUnitRegions;
      ErrorF ("winShadowUpdatGDI - dwBox: %d\n", dwBox);
    }
  
  if ((s_dwTotalUpdates % 100) == 0)
    ErrorF ("winShadowUpdateGDI - %d%% non-unity regions, avg boxes: %d "
	    "nu: %d tu: %d\n",
	    (s_dwNonUnitRegions * 100) / s_dwTotalUpdates,
	    s_dwTotalBoxes / s_dwTotalUpdates,
	    s_dwNonUnitRegions, s_dwTotalUpdates);
#endif /* XWIN_UPDATESTATS */

  /*
   * Handle small regions with multiple blits,
   * handle large regions by creating a clipping region and 
   * doing a single blit constrained to that clipping region.
   */
  if (!pScreenInfo->fMultiWindow &&
      (pScreenInfo->dwClipUpdatesNBoxes == 0 ||
      dwBox < pScreenInfo->dwClipUpdatesNBoxes))
    {
      /* Loop through all boxes in the damaged region */
      while (dwBox--)
	{
	  /*
	   * Calculate x offset, y offset, width, and height for
	   * current damage box
	   */
	  x = pBox->x1;
	  y = pBox->y1;
	  w = pBox->x2 - pBox->x1;
	  h = pBox->y2 - pBox->y1;
	  
	  BitBlt (pScreenPriv->hdcScreen,
		  x, y,
		  w, h,
		  pScreenPriv->hdcShadow,
		  x, y,
		  SRCCOPY);
	  
	  /* Get a pointer to the next box */
	  ++pBox;
	}
    }
  else if (!pScreenInfo->fMultiWindow)
    {
      /* Compute a GDI region from the damaged region */
      hrgnCombined = CreateRectRgn (pBox->x1, pBox->y1, pBox->x2, pBox->y2);
      dwBox--;
      pBox++;
      while (dwBox--)
	{
	  hrgnTemp = CreateRectRgn (pBox->x1, pBox->y1, pBox->x2, pBox->y2);
	  CombineRgn (hrgnCombined, hrgnCombined, hrgnTemp, RGN_OR);
	  DeleteObject (hrgnTemp);
	  pBox++;
	}
      
      /* Install the GDI region as a clipping region */
      SelectClipRgn (pScreenPriv->hdcScreen, hrgnCombined);
      DeleteObject (hrgnCombined);
      hrgnCombined = NULL;
      
      /*
       * Blit the shadow buffer to the screen,
       * constrained to the clipping region.
       */
      BitBlt (pScreenPriv->hdcScreen,
	      pBoxExtents->x1, pBoxExtents->y1,
	      pBoxExtents->x2 - pBoxExtents->x1,
	      pBoxExtents->y2 - pBoxExtents->y1,
	      pScreenPriv->hdcShadow,
	      pBoxExtents->x1, pBoxExtents->y1,
	      SRCCOPY);
d495 37
a531 2
      /* Reset the clip region */
      SelectClipRgn (pScreenPriv->hdcScreen, NULL);
d535 5
a539 5
  /* Redraw all multiwindow windows */
  if (pScreenInfo->fMultiWindow)
    EnumThreadWindows (g_dwCurrentThreadID,
		       winRedrawDamagedWindowShadowGDI,
		       (LPARAM)pBoxExtents);
a542 1

d544 1
a544 1
winInitScreenShadowGDI (ScreenPtr pScreen)
d546 1
a546 1
  winScreenPriv(pScreen);
d548 3
a550 3
  /* Get device contexts for the screen and shadow bitmap */
  pScreenPriv->hdcScreen = GetDC (pScreenPriv->hwndScreen);
  pScreenPriv->hdcShadow = CreateCompatibleDC (pScreenPriv->hdcScreen);
d552 6
a557 7
  /* Allocate bitmap info header */
  pScreenPriv->pbmih = (BITMAPINFOHEADER*) malloc (sizeof (BITMAPINFOHEADER)
                                                   + 256 * sizeof (RGBQUAD));
  if (pScreenPriv->pbmih == NULL)
    {
      ErrorF ("winInitScreenShadowGDI - malloc () failed\n");
      return FALSE;
d560 4
a563 5
  /* Query the screen format */
  if (!winQueryScreenDIBFormat (pScreen, pScreenPriv->pbmih))
    {
      ErrorF ("winInitScreenShadowGDI - winQueryScreenDIBFormat failed\n");
      return FALSE;
d566 4
a569 5
  /* Determine our color masks */
  if (!winQueryRGBBitsAndMasks (pScreen))
    {
      ErrorF ("winInitScreenShadowGDI - winQueryRGBBitsAndMasks failed\n");
      return FALSE;
d572 1
a572 1
  return winAllocateFBShadowGDI(pScreen);
d582 1
a582 1
winCloseScreenShadowGDI (int nIndex, ScreenPtr pScreen)
d584 3
a586 3
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  Bool			fReturn;
d589 1
a589 1
  winDebug ("winCloseScreenShadowGDI - Freeing screen resources\n");
d592 3
a594 3
  /* Flag that the screen is closed */
  pScreenPriv->fClosed = TRUE;
  pScreenPriv->fActive = FALSE;
d596 4
a599 4
  /* Call the wrapped CloseScreen procedure */
  WIN_UNWRAP(CloseScreen);
  if (pScreen->CloseScreen)
    fReturn = (*pScreen->CloseScreen) (nIndex, pScreen);
d601 2
a602 2
  /* Delete the window property */
  RemoveProp (pScreenPriv->hwndScreen, WIN_SCR_PROP);
d604 2
a605 2
  /* Free the shadow DC; which allows the bitmap to be freed */
  DeleteDC (pScreenPriv->hdcShadow);
d607 1
a607 1
  winFreeFBShadowGDI(pScreen);
d609 2
a610 2
  /* Free the screen DC */
  ReleaseDC (pScreenPriv->hwndScreen, pScreenPriv->hdcScreen);
d612 3
a614 3
  /* Delete tray icon, if we have one */
  if (!pScreenInfo->fNoTrayIcon)
    winDeleteNotifyIcon (pScreenPriv);
d616 4
a619 5
  /* Free the exit confirmation dialog box, if it exists */
  if (g_hDlgExit != NULL)
    {
      DestroyWindow (g_hDlgExit);
      g_hDlgExit = NULL;
d622 4
a625 5
  /* Kill our window */
  if (pScreenPriv->hwndScreen)
    {
      DestroyWindow (pScreenPriv->hwndScreen);
      pScreenPriv->hwndScreen = NULL;
d629 2
a630 2
  /* Destroy the thread startup mutex */
  pthread_mutex_destroy (&pScreenPriv->pmServerStarted);
d633 2
a634 2
  /* Invalidate our screeninfo's pointer to the screen */
  pScreenInfo->pScreen = NULL;
d636 2
a637 2
  /* Free the screen privates for this screen */
  free ((pointer) pScreenPriv);
d639 1
a639 1
  return fReturn;
a641 1

d651 1
a651 1
winInitVisualsShadowGDI (ScreenPtr pScreen)
d653 2
a654 2
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
d656 11
a666 13
  /* Display debugging information */
  ErrorF ("winInitVisualsShadowGDI - Masks %08x %08x %08x BPRGB %d d %d "
	  "bpp %d\n",
	  (unsigned int) pScreenPriv->dwRedMask,
	  (unsigned int) pScreenPriv->dwGreenMask,
	  (unsigned int) pScreenPriv->dwBlueMask,
	  (int) pScreenPriv->dwBitsPerRGB,
	  (int) pScreenInfo->dwDepth,
	  (int) pScreenInfo->dwBPP);

  /* Create a single visual according to the Windows screen depth */
  switch (pScreenInfo->dwDepth)
    {
d670 12
a681 13
      /* Setup the real visual */
      if (!miSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     TrueColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     -1,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
		  "failed\n");
	  return FALSE;
	}
d684 2
a685 2
      if (!pScreenInfo->fEmulatePseudo)
	break;
d687 6
a692 13
      /* Setup a pseudocolor visual */
      if (!miSetVisualTypesAndMasks (8,
				     PseudoColorMask,
				     8,
				     -1,
				     0,
				     0,
				     0))
	{
	  ErrorF ("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
		  "failed for PseudoColor\n");
	  return FALSE;
	}
d694 1
a694 1
      break;
d697 12
a708 13
      if (!miSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     PseudoColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     PseudoColor,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
		  "failed\n");
	  return FALSE;
	}
      break;
d711 2
a712 2
      ErrorF ("winInitVisualsShadowGDI - Unknown screen depth\n");
      return FALSE;
d716 1
a716 1
  winDebug ("winInitVisualsShadowGDI - Returning\n");
d719 1
a719 1
  return TRUE;
a721 1

d727 1
a727 1
winAdjustVideoModeShadowGDI (ScreenPtr pScreen)
d729 18
a746 23
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  HDC			hdc;
  DWORD			dwBPP;
  
  hdc = GetDC (NULL);

  /* We're in serious trouble if we can't get a DC */
  if (hdc == NULL)
    {
      ErrorF ("winAdjustVideoModeShadowGDI - GetDC () failed\n");
      return FALSE;
    }

  /* Query GDI for current display depth */
  dwBPP = GetDeviceCaps (hdc, BITSPIXEL);

  /* GDI cannot change the screen depth, so always use GDI's depth */
  pScreenInfo->dwBPP = dwBPP;

  /* Release our DC */
  ReleaseDC (NULL, hdc);
  hdc = NULL;
d748 5
a752 1
  return TRUE;
a754 1

d760 1
a760 1
winBltExposedRegionsShadowGDI (ScreenPtr pScreen)
d762 22
a783 25
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  winPrivCmapPtr	pCmapPriv = NULL;
  HDC			hdcUpdate;
  PAINTSTRUCT		ps;

  /* BeginPaint gives us an hdc that clips to the invalidated region */
  hdcUpdate = BeginPaint (pScreenPriv->hwndScreen, &ps);

  /* Realize the palette, if we have one */
  if (pScreenPriv->pcmapInstalled != NULL)
    {
      pCmapPriv = winGetCmapPriv (pScreenPriv->pcmapInstalled);
      
      SelectPalette (hdcUpdate, pCmapPriv->hPalette, FALSE);
      RealizePalette (hdcUpdate);
    }

  /* Our BitBlt will be clipped to the invalidated region */
  BitBlt (hdcUpdate,
	  0, 0,
	  pScreenInfo->dwWidth, pScreenInfo->dwHeight,
	  pScreenPriv->hdcShadow,
	  0, 0,
	  SRCCOPY);
d785 2
a786 2
  /* EndPaint frees the DC */
  EndPaint (pScreenPriv->hwndScreen, &ps);
d789 4
a792 4
  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow)
    EnumThreadWindows(g_dwCurrentThreadID, winRedrawAllProcShadowGDI, 
            (LPARAM)pScreenPriv->hwndScreen);
d795 1
a795 1
  return TRUE;
a797 1

d803 1
a803 1
winActivateAppShadowGDI (ScreenPtr pScreen)
d805 2
a806 2
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
d808 28
a835 32
  /*
   * 2004/04/12 - Harold - We perform the restoring or minimizing
   * manually for ShadowGDI in fullscreen modes so that this engine
   * will perform just like ShadowDD and ShadowDDNL in fullscreen mode;
   * if we do not do this then our fullscreen window will appear in the
   * z-order when it is deactivated and it can be uncovered by resizing
   * or minimizing another window that is on top of it, which is not how
   * the DirectDraw engines work.  Therefore we keep this code here to
   * make sure that all engines work the same in fullscreen mode.
   */

  /*
   * Are we active?
   * Are we fullscreen?
   */
  if (pScreenPriv->fActive
      && pScreenInfo->fFullScreen)
    {
      /*
       * Activating, attempt to bring our window 
       * to the top of the display
       */
      ShowWindow (pScreenPriv->hwndScreen, SW_RESTORE);
    }
  else if (!pScreenPriv->fActive
	   && pScreenInfo->fFullScreen)
    {
      /*
       * Deactivating, stuff our window onto the
       * task bar.
       */
      ShowWindow (pScreenPriv->hwndScreen, SW_MINIMIZE);
d838 1
a838 1
  return TRUE;
a840 1

d846 1
a846 1
winRedrawScreenShadowGDI (ScreenPtr pScreen)
d848 2
a849 2
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
d851 5
a855 7
  /* Redraw the whole window, to take account for the new colors */
  BitBlt (pScreenPriv->hdcScreen,
	  0, 0,
	  pScreenInfo->dwWidth, pScreenInfo->dwHeight,
	  pScreenPriv->hdcShadow,
	  0, 0,
	  SRCCOPY);
d858 3
a860 3
  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow)
    EnumThreadWindows(g_dwCurrentThreadID, winRedrawAllProcShadowGDI, 0);
d863 1
a863 1
  return TRUE;
a865 2


d871 1
a871 1
winRealizeInstalledPaletteShadowGDI (ScreenPtr pScreen)
d873 2
a874 2
  winScreenPriv(pScreen);
  winPrivCmapPtr	pCmapPriv = NULL;
d877 1
a877 1
  winDebug ("winRealizeInstalledPaletteShadowGDI\n");
d880 2
a881 3
  /* Don't do anything if there is not a colormap */
  if (pScreenPriv->pcmapInstalled == NULL)
    {
d883 2
a884 2
      winDebug ("winRealizeInstalledPaletteShadowGDI - No colormap "
	      "installed\n");
d886 10
a895 1
      return TRUE;
d898 7
a904 19
  pCmapPriv = winGetCmapPriv (pScreenPriv->pcmapInstalled);
  
  /* Realize our palette for the screen */
  if (RealizePalette (pScreenPriv->hdcScreen) == GDI_ERROR)
    {
      ErrorF ("winRealizeInstalledPaletteShadowGDI - RealizePalette () "
	      "failed\n");
      return FALSE;
    }
  
  /* Set the DIB color table */
  if (SetDIBColorTable (pScreenPriv->hdcShadow,
			0,
			WIN_NUM_PALETTE_ENTRIES,
			pCmapPriv->rgbColors) == 0)
    {
      ErrorF ("winRealizeInstalledPaletteShadowGDI - SetDIBColorTable () "
	      "failed\n");
      return FALSE;
d906 2
a907 2
  
  return TRUE;
a909 1

d915 1
a915 1
winInstallColormapShadowGDI (ColormapPtr pColormap)
d917 4
a920 40
  ScreenPtr		pScreen = pColormap->pScreen;
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  winCmapPriv(pColormap);

  /*
   * Tell Windows to install the new colormap
   */
  if (SelectPalette (pScreenPriv->hdcScreen,
		     pCmapPriv->hPalette,
		     FALSE) == NULL)
    {
      ErrorF ("winInstallColormapShadowGDI - SelectPalette () failed\n");
      return FALSE;
    }
      
  /* Realize the palette */
  if (GDI_ERROR == RealizePalette (pScreenPriv->hdcScreen))
    {
      ErrorF ("winInstallColormapShadowGDI - RealizePalette () failed\n");
      return FALSE;
    }

  /* Set the DIB color table */
  if (SetDIBColorTable (pScreenPriv->hdcShadow,
			0,
			WIN_NUM_PALETTE_ENTRIES,
			pCmapPriv->rgbColors) == 0)
    {
      ErrorF ("winInstallColormapShadowGDI - SetDIBColorTable () failed\n");
      return FALSE;
    }

  /* Redraw the whole window, to take account for the new colors */
  BitBlt (pScreenPriv->hdcScreen,
	  0, 0,
	  pScreenInfo->dwWidth, pScreenInfo->dwHeight,
	  pScreenPriv->hdcShadow,
	  0, 0,
	  SRCCOPY);
d922 33
a954 2
  /* Save a pointer to the newly installed colormap */
  pScreenPriv->pcmapInstalled = pColormap;
d957 3
a959 3
  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow)
    EnumThreadWindows (g_dwCurrentThreadID, winRedrawAllProcShadowGDI, 0);
d962 1
a962 1
  return TRUE;
a964 1

d970 1
a970 3
winStoreColorsShadowGDI (ColormapPtr pColormap,
			 int ndef,
			 xColorItem *pdefs)
d972 24
a995 27
  ScreenPtr		pScreen = pColormap->pScreen;
  winScreenPriv(pScreen);
  winCmapPriv(pColormap);
  ColormapPtr curpmap = pScreenPriv->pcmapInstalled;
  
  /* Put the X colormap entries into the Windows logical palette */
  if (SetPaletteEntries (pCmapPriv->hPalette,
			 pdefs[0].pixel,
			 ndef,
			 pCmapPriv->peColors + pdefs[0].pixel) == 0)
    {
      ErrorF ("winStoreColorsShadowGDI - SetPaletteEntries () failed\n");
      return FALSE;
    }

  /* Don't install the Windows palette if the colormap is not installed */
  if (pColormap != curpmap)
    {
      return TRUE;
    }

  /* Try to install the newly modified colormap */
  if (!winInstallColormapShadowGDI (pColormap))
    {
      ErrorF ("winInstallColormapShadowGDI - winInstallColormapShadowGDI "
	      "failed\n");
      return FALSE;
d999 9
a1007 11
  /* Tell Windows that the palette has changed */
  RealizePalette (pScreenPriv->hdcScreen);
  
  /* Set the DIB color table */
  if (SetDIBColorTable (pScreenPriv->hdcShadow,
			pdefs[0].pixel,
			ndef,
			pCmapPriv->rgbColors + pdefs[0].pixel) == 0)
    {
      ErrorF ("winInstallColormapShadowGDI - SetDIBColorTable () failed\n");
      return FALSE;
d1010 2
a1011 2
  /* Save a pointer to the newly installed colormap */
  pScreenPriv->pcmapInstalled = pColormap;
d1014 1
a1014 1
  return TRUE;
a1016 1

d1022 1
a1022 1
winCreateColormapShadowGDI (ColormapPtr pColormap)
d1024 36
a1059 38
  LPLOGPALETTE		lpPaletteNew = NULL;
  DWORD			dwEntriesMax;
  VisualPtr		pVisual;
  HPALETTE		hpalNew = NULL;
  winCmapPriv(pColormap);

  /* Get a pointer to the visual that the colormap belongs to */
  pVisual = pColormap->pVisual;

  /* Get the maximum number of palette entries for this visual */
  dwEntriesMax = pVisual->ColormapEntries;

  /* Allocate a Windows logical color palette with max entries */
  lpPaletteNew = malloc (sizeof (LOGPALETTE)
			 + (dwEntriesMax - 1) * sizeof (PALETTEENTRY));
  if (lpPaletteNew == NULL)
    {
      ErrorF ("winCreateColormapShadowGDI - Couldn't allocate palette "
	      "with %d entries\n",
	      (int) dwEntriesMax);
      return FALSE;
    }

  /* Zero out the colormap */
  ZeroMemory (lpPaletteNew, sizeof (LOGPALETTE)
	      + (dwEntriesMax - 1) * sizeof (PALETTEENTRY));
  
  /* Set the logical palette structure */
  lpPaletteNew->palVersion = 0x0300;
  lpPaletteNew->palNumEntries = dwEntriesMax;

  /* Tell Windows to create the palette */
  hpalNew = CreatePalette (lpPaletteNew);
  if (hpalNew == NULL)
    {
      ErrorF ("winCreateColormapShadowGDI - CreatePalette () failed\n");
      free (lpPaletteNew);
      return FALSE;
d1062 2
a1063 2
  /* Save the Windows logical palette handle in the X colormaps' privates */
  pCmapPriv->hPalette = hpalNew;
d1065 2
a1066 2
  /* Free the palette initialization memory */
  free (lpPaletteNew);
d1068 1
a1068 1
  return TRUE;
a1070 1

d1076 1
a1076 1
winDestroyColormapShadowGDI (ColormapPtr pColormap)
d1078 2
a1079 2
  winScreenPriv(pColormap->pScreen);
  winCmapPriv(pColormap);
d1081 9
a1089 10
  /*
   * Is colormap to be destroyed the default?
   *
   * Non-default colormaps should have had winUninstallColormap
   * called on them before we get here.  The default colormap
   * will not have had winUninstallColormap called on it.  Thus,
   * we need to handle the default colormap in a special way.
   */
  if (pColormap->flags & IsDefault)
    {
d1091 2
a1092 2
      winDebug ("winDestroyColormapShadowGDI - Destroying default "
	      "colormap\n");
a1093 24
      
      /*
       * FIXME: Walk the list of all screens, popping the default
       * palette out of each screen device context.
       */
      
      /* Pop the palette out of the device context */
      SelectPalette (pScreenPriv->hdcScreen,
		     GetStockObject (DEFAULT_PALETTE),
		     FALSE);

      /* Clear our private installed colormap pointer */
      pScreenPriv->pcmapInstalled = NULL;
    }
  
  /* Try to delete the logical palette */
  if (DeleteObject (pCmapPriv->hPalette) == 0)
    {
      ErrorF ("winDestroyColormap - DeleteObject () failed\n");
      return FALSE;
    }
  
  /* Invalidate the colormap privates */
  pCmapPriv->hPalette = NULL;
d1095 23
a1117 1
  return TRUE;
a1119 1

d1125 1
a1125 1
winSetEngineFunctionsShadowGDI (ScreenPtr pScreen)
d1127 32
a1158 30
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  
  /* Set our pointers */
  pScreenPriv->pwinAllocateFB = winAllocateFBShadowGDI;
  pScreenPriv->pwinFreeFB = winFreeFBShadowGDI;
  pScreenPriv->pwinShadowUpdate = winShadowUpdateGDI;
  pScreenPriv->pwinInitScreen = winInitScreenShadowGDI;
  pScreenPriv->pwinCloseScreen = winCloseScreenShadowGDI;
  pScreenPriv->pwinInitVisuals = winInitVisualsShadowGDI;
  pScreenPriv->pwinAdjustVideoMode = winAdjustVideoModeShadowGDI;
  if (pScreenInfo->fFullScreen)
    pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowFullScreen;
  else
    pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowWindowed;
  pScreenPriv->pwinFinishScreenInit = winFinishScreenInitFB;
  pScreenPriv->pwinBltExposedRegions = winBltExposedRegionsShadowGDI;
  pScreenPriv->pwinActivateApp = winActivateAppShadowGDI;
  pScreenPriv->pwinRedrawScreen = winRedrawScreenShadowGDI;
  pScreenPriv->pwinRealizeInstalledPalette = 
    winRealizeInstalledPaletteShadowGDI;
  pScreenPriv->pwinInstallColormap = winInstallColormapShadowGDI;
  pScreenPriv->pwinStoreColors = winStoreColorsShadowGDI;
  pScreenPriv->pwinCreateColormap = winCreateColormapShadowGDI;
  pScreenPriv->pwinDestroyColormap = winDestroyColormapShadowGDI;
  pScreenPriv->pwinHotKeyAltTab = (winHotKeyAltTabProcPtr) (void (*)(void))NoopDDA;
  pScreenPriv->pwinCreatePrimarySurface
    = (winCreatePrimarySurfaceProcPtr) (void (*)(void))NoopDDA;
  pScreenPriv->pwinReleasePrimarySurface
    = (winReleasePrimarySurfaceProcPtr) (void (*)(void))NoopDDA;
d1160 2
a1161 2
  pScreenPriv->pwinFinishCreateWindowsWindow =
    (winFinishCreateWindowsWindowProcPtr) (void (*)(void))NoopDDA;
d1164 1
a1164 1
  return TRUE;
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a37 10
 * External symbols
 */

#ifdef XWIN_MULTIWINDOW
extern DWORD			g_dwCurrentThreadID;
#endif
extern HWND			g_hDlgExit;


/*
a340 1
  BITMAPINFOHEADER	*pbmih = NULL;
d344 3
a346 3
  /* Get device contexts for the screen and shadow bitmap */
  pScreenPriv->hdcScreen = GetDC (pScreenPriv->hwndScreen);
  pScreenPriv->hdcShadow = CreateCompatibleDC (pScreenPriv->hdcScreen);
a347 16
  /* Allocate bitmap info header */
  pbmih = (BITMAPINFOHEADER*) malloc (sizeof (BITMAPINFOHEADER)
				      + 256 * sizeof (RGBQUAD));
  if (pbmih == NULL)
    {
      ErrorF ("winAllocateFBShadowGDI - malloc () failed\n");
      return FALSE;
    }

  /* Query the screen format */
  fReturn = winQueryScreenDIBFormat (pScreen, pbmih);

  /* Describe shadow bitmap to be created */
  pbmih->biWidth = pScreenInfo->dwWidth;
  pbmih->biHeight = -pScreenInfo->dwHeight;
  
d350 1
a350 1
	  (int) pbmih->biWidth, (int) -pbmih->biHeight, pbmih->biBitCount);
d354 1
a354 1
					      (BITMAPINFO *) pbmih,
a434 19
  /* See if the shadow bitmap will be larger than the DIB size limit */
  if (pScreenInfo->dwWidth * pScreenInfo->dwHeight * pScreenInfo->dwBPP
      >= WIN_DIB_MAXIMUM_SIZE)
    {
      ErrorF ("winAllocateFBShadowGDI - Requested DIB (bitmap) "
	      "will be larger than %d MB.  The surface may fail to be "
	      "allocated on Windows 95, 98, or Me, due to a %d MB limit in "
	      "DIB size.  This limit does not apply to Windows NT/2000, and "
	      "this message may be ignored on those platforms.\n",
	      WIN_DIB_MAXIMUM_SIZE_MB, WIN_DIB_MAXIMUM_SIZE_MB);
    }

  /* Determine our color masks */
  if (!winQueryRGBBitsAndMasks (pScreen))
    {
      ErrorF ("winAllocateFBShadowGDI - winQueryRGBBitsAndMasks failed\n");
      return FALSE;
    }

d444 12
d581 35
d639 2
a640 1
  fReturn = (*pScreen->CloseScreen) (nIndex, pScreen);
d647 2
a648 3
  
  /* Free the shadow bitmap */
  DeleteObject (pScreenPriv->hbmpShadow);
a678 3
  /* Invalidate the ScreenInfo's fb pointer */
  pScreenInfo->pfb = NULL;

a715 1
#if defined(XFree86Server)
a747 32
#else /* XFree86Server */
      /* Setup the real visual */
      if (!fbSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     TrueColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowGDI - fbSetVisualTypesAndMasks "
		  "failed for TrueColor\n");
	  return FALSE;
	}

#ifdef XWIN_EMULATEPSEUDO
      if (!pScreenInfo->fEmulatePseudo)
	break;

      /* Setup a pseudocolor visual */
      if (!fbSetVisualTypesAndMasks (8,
				     PseudoColorMask,
				     8,
				     0,
				     0,
				     0))
	{
	  ErrorF ("winInitVisualsShadowGDI - fbSetVisualTypesAndMasks "
		  "failed for PseudoColor\n");
	  return FALSE;
	}
#endif
#endif /* XFree86Server */
a750 1
#if defined(XFree86Server)
a762 13
#else /* XFree86Server */
      if (!fbSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     PseudoColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowGDI - fbSetVisualTypesAndMasks "
		  "failed\n");
	  return FALSE;
	}
#endif
d802 2
a803 6
  /* GDI cannot change the screen depth */
  if (pScreenInfo->dwBPP == WIN_DEFAULT_BPP)
    {
      /* No -depth parameter passed, let the user know the depth being used */
      ErrorF ("winAdjustVideoModeShadowGDI - Using Windows display "
	      "depth of %d bits per pixel\n", (int) dwBPP);
a804 13
      /* Use GDI's depth */
      pScreenInfo->dwBPP = dwBPP;
    }
  else if (dwBPP != pScreenInfo->dwBPP)
    {
      /* Warn user if GDI depth is different than -depth parameter */
      ErrorF ("winAdjustVideoModeShadowGDI - Command line bpp: %d, "\
	      "using bpp: %d\n", (int) pScreenInfo->dwBPP, (int) dwBPP);

      /* We'll use GDI's depth */
      pScreenInfo->dwBPP = dwBPP;
    }
  
d1229 1
d1231 1
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d502 2
a503 2
  DWORD			dwBox = REGION_NUM_RECTS (damage);
  BoxPtr		pBox = REGION_RECTS (damage);
d511 1
a511 1
  BoxPtr		pBoxExtents = REGION_EXTENTS (pScreen, damage);
@


1.1
log
@Initial revision
@
text
@d501 1
a501 1
  RegionPtr		damage = &pBuf->damage;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
