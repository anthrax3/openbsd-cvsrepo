head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.8
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.6
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.32;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.32;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.03.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 * Copyright (C) Colin Harrison 2005-2008
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the XFree86 Project
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * from the XFree86 Project.
 *
 * Authors:     Earle F. Philhower, III
 *              Colin Harrison
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#ifdef __CYGWIN__
#include <sys/resource.h>
#endif
#include "win.h"

#include <X11/Xwindows.h>
#include <shellapi.h>

#include "winprefs.h"
#include "windisplay.h"
#include "winmultiwindowclass.h"

/* Where will the custom menu commands start counting from? */
#define STARTMENUID WM_USER

extern const char *winGetBaseDir(void);

/* From winprefslex.l, the real parser */
extern int parse_file(FILE * fp);

/* Currently in use command ID, incremented each new menu item created */
static int g_cmdid = STARTMENUID;

/* Local function to handle comma-ified icon names */
static HICON LoadImageComma(char *fname, int sx, int sy, int flags);

/*
 * Creates or appends a menu from a MENUPARSED structure
 */
static HMENU
MakeMenu(char *name, HMENU editMenu, int editItem)
{
    int i;
    int item;
    MENUPARSED *m;
    HMENU hmenu, hsub;

    for (i = 0; i < pref.menuItems; i++) {
        if (!strcmp(name, pref.menu[i].menuName))
            break;
    }

    /* Didn't find a match, bummer */
    if (i == pref.menuItems) {
        ErrorF("MakeMenu: Can't find menu %s\n", name);
        return NULL;
    }

    m = &(pref.menu[i]);

    if (editMenu) {
        hmenu = editMenu;
        item = editItem;
    }
    else {
        hmenu = CreatePopupMenu();
        if (!hmenu) {
            ErrorF("MakeMenu: Unable to CreatePopupMenu() %s\n", name);
            return NULL;
        }
        item = 0;
    }

    /* Add the menu items */
    for (i = 0; i < m->menuItems; i++) {
        /* Only assign IDs one time... */
        if (m->menuItem[i].commandID == 0)
            m->menuItem[i].commandID = g_cmdid++;

        switch (m->menuItem[i].cmd) {
        case CMD_EXEC:
        case CMD_ALWAYSONTOP:
        case CMD_RELOAD:
            InsertMenu(hmenu,
                       item,
                       MF_BYPOSITION | MF_ENABLED | MF_STRING,
                       m->menuItem[i].commandID, m->menuItem[i].text);
            break;

        case CMD_SEPARATOR:
            InsertMenu(hmenu, item, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
            break;

        case CMD_MENU:
            /* Recursive! */
            hsub = MakeMenu(m->menuItem[i].param, 0, 0);
            if (hsub)
                InsertMenu(hmenu,
                           item,
                           MF_BYPOSITION | MF_POPUP | MF_ENABLED | MF_STRING,
                           (UINT_PTR) hsub, m->menuItem[i].text);
            break;
        }

        /* If item==-1 (means to add at end of menu) don't increment) */
        if (item >= 0)
            item++;
    }

    return hmenu;
}

#ifdef XWIN_MULTIWINDOW
/*
 * Callback routine that is executed once per window class.
 * Removes or creates custom window settings depending on LPARAM
 */
static wBOOL CALLBACK
ReloadEnumWindowsProc(HWND hwnd, LPARAM lParam)
{
    HICON hicon;

    if (!hwnd) {
        ErrorF("ReloadEnumWindowsProc: hwnd==NULL!\n");
        return FALSE;
    }

    /* It's our baby, either clean or dirty it */
    if (lParam == FALSE) {
        /* Reset the window's icon to undefined. */
        hicon = (HICON) SendMessage(hwnd, WM_SETICON, ICON_BIG, 0);

        /* If the old icon is generated on-the-fly, get rid of it, will regen */
        winDestroyIcon(hicon);

        /* Same for the small icon */
        hicon = (HICON) SendMessage(hwnd, WM_SETICON, ICON_SMALL, 0);
        winDestroyIcon(hicon);

        /* Remove any menu additions; bRevert=TRUE destroys any modified menus */
        GetSystemMenu(hwnd, TRUE);

        /* This window is now clean of our taint (but with undefined icons) */
    }
    else {
        /* Send a message to WM thread telling it re-evaluate the icon for this window */
        {
            winWMMessageRec wmMsg;

            WindowPtr pWin = GetProp(hwnd, WIN_WINDOW_PROP);

            if (pWin) {
                winPrivWinPtr pWinPriv = winGetWindowPriv(pWin);
                winPrivScreenPtr s_pScreenPriv = pWinPriv->pScreenPriv;

                wmMsg.msg = WM_WM_ICON_EVENT;
                wmMsg.hwndWindow = hwnd;
                wmMsg.iWindow = (Window) (INT_PTR) GetProp(hwnd, WIN_WID_PROP);

                winSendMessageToWM(s_pScreenPriv->pWMInfo, &wmMsg);
            }
        }

        /* Update the system menu for this window */
        SetupSysMenu(hwnd);

        /* That was easy... */
    }

    return TRUE;
}
#endif

/*
 * Removes any custom icons in classes, custom menus, etc.
 * Frees all members in pref structure.
 * Reloads the preferences file.
 * Set custom icons and menus again.
 */
static void
ReloadPrefs(void)
{
    int i;

#ifdef XWIN_MULTIWINDOW
    /* First, iterate over all windows, deleting their icons and custom menus.
     * This is really only needed because winDestroyIcon() will try to
     * destroy the old global icons, which will have changed.
     * It is probably better to set a windows USER_DATA to flag locally defined
     * icons, and use that to accurately know when to destroy old icons.
     */
    EnumThreadWindows(g_dwCurrentThreadID, ReloadEnumWindowsProc, FALSE);
#endif

    /* Now, free/clear all info from our prefs structure */
    for (i = 0; i < pref.menuItems; i++)
        free(pref.menu[i].menuItem);
    free(pref.menu);
    pref.menu = NULL;
    pref.menuItems = 0;

    pref.rootMenuName[0] = 0;

    free(pref.sysMenu);
    pref.sysMenuItems = 0;

    pref.defaultSysMenuName[0] = 0;
    pref.defaultSysMenuPos = 0;

    pref.iconDirectory[0] = 0;
    pref.defaultIconName[0] = 0;
    pref.trayIconName[0] = 0;

    for (i = 0; i < pref.iconItems; i++)
        if (pref.icon[i].hicon)
            DestroyIcon((HICON) pref.icon[i].hicon);
    free(pref.icon);
    pref.icon = NULL;
    pref.iconItems = 0;

    /* Free global default X icon */
    if (g_hIconX)
        DestroyIcon(g_hIconX);
    if (g_hSmallIconX)
        DestroyIcon(g_hSmallIconX);

    /* Reset the custom command IDs */
    g_cmdid = STARTMENUID;

    /* Load the updated resource file */
    LoadPreferences();

    g_hIconX = NULL;
    g_hSmallIconX = NULL;

#ifdef XWIN_MULTIWINDOW
    winInitGlobalIcons();
#endif

#ifdef XWIN_MULTIWINDOW
    /* Rebuild the icons and menus */
    EnumThreadWindows(g_dwCurrentThreadID, ReloadEnumWindowsProc, TRUE);
#endif

    /* Whew, done */
}

/*
 * Check/uncheck the ALWAYSONTOP items in this menu
 */
void
HandleCustomWM_INITMENU(HWND hwnd, HMENU hmenu)
{
    DWORD dwExStyle;
    int i, j;

    if (!hwnd || !hmenu)
        return;

    if (GetWindowLongPtr(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
        dwExStyle = MF_BYCOMMAND | MF_CHECKED;
    else
        dwExStyle = MF_BYCOMMAND | MF_UNCHECKED;

    for (i = 0; i < pref.menuItems; i++)
        for (j = 0; j < pref.menu[i].menuItems; j++)
            if (pref.menu[i].menuItem[j].cmd == CMD_ALWAYSONTOP)
                CheckMenuItem(hmenu, pref.menu[i].menuItem[j].commandID,
                              dwExStyle);

}

/*
 * Searches for the custom WM_COMMAND command ID and performs action.
 * Return TRUE if command is proccessed, FALSE otherwise.
 */
Bool
HandleCustomWM_COMMAND(HWND hwnd, int command)
{
    int i, j;
    MENUPARSED *m;
    DWORD dwExStyle;

    if (!command)
        return FALSE;

    for (i = 0; i < pref.menuItems; i++) {
        m = &(pref.menu[i]);
        for (j = 0; j < m->menuItems; j++) {
            if (command == m->menuItem[j].commandID) {
                /* Match! */
                switch (m->menuItem[j].cmd) {
#ifdef __CYGWIN__
                case CMD_EXEC:
                    if (fork() == 0) {
                        struct rlimit rl;
                        int fd;

                        /* Close any open descriptors except for STD* */
                        getrlimit(RLIMIT_NOFILE, &rl);
                        for (fd = STDERR_FILENO + 1; fd < rl.rlim_cur; fd++)
                            close(fd);

                        /* Disassociate any TTYs */
                        setsid();

                        execl("/bin/sh",
                              "/bin/sh", "-c", m->menuItem[j].param, NULL);
                        exit(0);
                    }
                    else
                        return TRUE;
                    break;
#else
                case CMD_EXEC:
                {
                    /* Start process without console window */
                    STARTUPINFO start;
                    PROCESS_INFORMATION child;

                    memset(&start, 0, sizeof(start));
                    start.cb = sizeof(start);
                    start.dwFlags = STARTF_USESHOWWINDOW;
                    start.wShowWindow = SW_HIDE;

                    memset(&child, 0, sizeof(child));

                    if (CreateProcess
                        (NULL, m->menuItem[j].param, NULL, NULL, FALSE, 0, NULL,
                         NULL, &start, &child)) {
                        CloseHandle(child.hThread);
                        CloseHandle(child.hProcess);
                    }
                    else
                        MessageBox(NULL, m->menuItem[j].param,
                                   "Mingrc Exec Command Error!",
                                   MB_OK | MB_ICONEXCLAMATION);
                }
                    return TRUE;
#endif
                case CMD_ALWAYSONTOP:
                    if (!hwnd)
                        return FALSE;

                    /* Get extended window style */
                    dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);

                    /* Handle topmost windows */
                    if (dwExStyle & WS_EX_TOPMOST)
                        SetWindowPos(hwnd,
                                     HWND_NOTOPMOST,
                                     0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
                    else
                        SetWindowPos(hwnd,
                                     HWND_TOPMOST,
                                     0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
#if XWIN_MULTIWINDOW
                    /* Reflect the changed Z order */
                    winReorderWindowsMultiWindow();
#endif
                    return TRUE;

                case CMD_RELOAD:
                    ReloadPrefs();
                    return TRUE;

                default:
                    return FALSE;
                }
            }                   /* match */
        }                       /* for j */
    }                           /* for i */

    return FALSE;
}

#ifdef XWIN_MULTIWINDOW
/*
 * Add the default or a custom menu depending on the class match
 */
void
SetupSysMenu(HWND hwnd)
{
    HMENU sys;
    int i;
    WindowPtr pWin;
    char *res_name, *res_class;

    if (!hwnd)
        return;

    pWin = GetProp(hwnd, WIN_WINDOW_PROP);

    sys = GetSystemMenu(hwnd, FALSE);
    if (!sys)
        return;

    if (pWin) {
        /* First see if there's a class match... */
        if (winMultiWindowGetClassHint(pWin, &res_name, &res_class)) {
            for (i = 0; i < pref.sysMenuItems; i++) {
                if (!strcmp(pref.sysMenu[i].match, res_name) ||
                    !strcmp(pref.sysMenu[i].match, res_class)) {
                    free(res_name);
                    free(res_class);

                    MakeMenu(pref.sysMenu[i].menuName, sys,
                             pref.sysMenu[i].menuPos == AT_START ? 0 : -1);
                    return;
                }
            }

            /* No match, just free alloc'd strings */
            free(res_name);
            free(res_class);
        }                       /* Found wm_class */
    }                           /* if pwin */

    /* Fallback to system default */
    if (pref.defaultSysMenuName[0]) {
        if (pref.defaultSysMenuPos == AT_START)
            MakeMenu(pref.defaultSysMenuName, sys, 0);
        else
            MakeMenu(pref.defaultSysMenuName, sys, -1);
    }
}
#endif

/*
 * Possibly add a menu to the toolbar icon
 */
void
SetupRootMenu(HMENU root)
{
    if (!root)
        return;

    if (pref.rootMenuName[0]) {
        MakeMenu(pref.rootMenuName, root, 0);
    }
}

/*
 * Check for and return an overridden default ICON specified in the prefs
 */
HICON
winOverrideDefaultIcon(int size)
{
    HICON hicon;

    if (pref.defaultIconName[0]) {
        hicon = LoadImageComma(pref.defaultIconName, size, size, 0);
        if (hicon == NULL)
            ErrorF("winOverrideDefaultIcon: LoadImageComma(%s) failed\n",
                   pref.defaultIconName);

        return hicon;
    }

    return 0;
}

/*
 * Return the HICON to use in the taskbar notification area
 */
HICON
winTaskbarIcon(void)
{
    HICON hicon;

    hicon = 0;
    /* First try and load an overridden, if success then return it */
    if (pref.trayIconName[0]) {
        hicon = LoadImageComma(pref.trayIconName,
                               GetSystemMetrics(SM_CXSMICON),
                               GetSystemMetrics(SM_CYSMICON), 0);
    }

    /* Otherwise return the default */
    if (!hicon)
        hicon = (HICON) LoadImage(g_hInstance,
                                  MAKEINTRESOURCE(IDI_XWIN),
                                  IMAGE_ICON,
                                  GetSystemMetrics(SM_CXSMICON),
                                  GetSystemMetrics(SM_CYSMICON), 0);

    return hicon;
}

/*
 * Parse a filename to extract an icon:
 *  If fname is exactly ",nnn" then extract icon from our resource
 *  else if it is "file,nnn" then extract icon nnn from that file
 *  else try to load it as an .ico file and if that fails return NULL
 */
static HICON
LoadImageComma(char *fname, int sx, int sy, int flags)
{
    HICON hicon;
    int i;
    char file[PATH_MAX + NAME_MAX + 2];

    /* Some input error checking */
    if (!fname || !fname[0])
        return NULL;

    i = 0;
    hicon = NULL;

    if (fname[0] == ',') {
        /* It's the XWIN.EXE resource they want */
        i = atoi(fname + 1);
        hicon = LoadImage(g_hInstance,
                          MAKEINTRESOURCE(i), IMAGE_ICON, sx, sy, flags);
    }
    else {
        file[0] = 0;
        /* Prepend path if not given a "X:\" filename */
        if (!(fname[0] && fname[1] == ':' && fname[2] == '\\')) {
            strcpy(file, pref.iconDirectory);
            if (pref.iconDirectory[0])
                if (fname[strlen(fname) - 1] != '\\')
                    strcat(file, "\\");
        }
        strcat(file, fname);

        if (strrchr(file, ',')) {
            /* Specified as <fname>,<index> */

            *(strrchr(file, ',')) = 0;  /* End string at comma */
            i = atoi(strrchr(fname, ',') + 1);
            hicon = ExtractIcon(g_hInstance, file, i);
        }
        else {
            /* Just an .ico file... */

            hicon = (HICON) LoadImage(NULL,
                                      file,
                                      IMAGE_ICON,
                                      sx, sy, LR_LOADFROMFILE | flags);
        }
    }
    return hicon;
}

/*
 * Check for a match of the window class to one specified in the
 * ICONS{} section in the prefs file, and load the icon from a file
 */
HICON
winOverrideIcon(char *res_name, char *res_class, char *wmName)
{
    int i;
    HICON hicon;

    for (i = 0; i < pref.iconItems; i++) {
        if ((res_name && !strcmp(pref.icon[i].match, res_name)) ||
            (res_class && !strcmp(pref.icon[i].match, res_class)) ||
            (wmName && strstr(wmName, pref.icon[i].match))) {
            if (pref.icon[i].hicon)
                return pref.icon[i].hicon;

            hicon = LoadImageComma(pref.icon[i].iconFile, 0, 0, LR_DEFAULTSIZE);
            if (hicon == NULL)
                ErrorF("winOverrideIcon: LoadImageComma(%s) failed\n",
                       pref.icon[i].iconFile);

            pref.icon[i].hicon = hicon;
            return hicon;
        }
    }

    /* Didn't find the icon, fail gracefully */
    return 0;
}

/*
 * Should we free this icon or leave it in memory (is it part of our
 * ICONS{} overrides)?
 */
int
winIconIsOverride(HICON hicon)
{
    int i;

    if (!hicon)
        return 0;

    for (i = 0; i < pref.iconItems; i++)
        if ((HICON) pref.icon[i].hicon == hicon)
            return 1;

    return 0;
}

/*
 * Open and parse the XWinrc config file @@path.
 * If @@path is NULL, use the built-in default.
 */
static int
winPrefsLoadPreferences(const char *path)
{
    FILE *prefFile = NULL;

    if (path)
        prefFile = fopen(path, "r");
#ifdef __CYGWIN__
    else {
        char defaultPrefs[] =
            "MENU rmenu {\n"
            "  \"How to customize this menu\" EXEC \"xterm +tb -e man XWinrc\"\n"
            "  \"Launch xterm\" EXEC xterm\n"
            "  \"Load .XWinrc\" RELOAD\n"
            "  SEPARATOR\n" "}\n" "\n" "ROOTMENU rmenu\n";

        path = "built-in default";
        prefFile = fmemopen(defaultPrefs, strlen(defaultPrefs), "r");
    }
#endif

    if (!prefFile) {
        ErrorF("LoadPreferences: %s not found\n", path);
        return FALSE;
    }

    ErrorF("LoadPreferences: Loading %s\n", path);

    if ((parse_file(prefFile)) != 0) {
        ErrorF("LoadPreferences: %s is badly formed!\n", path);
        fclose(prefFile);
        return FALSE;
    }

    fclose(prefFile);
    return TRUE;
}

/*
 * Try and open ~/.XWinrc and system.XWinrc
 * Load it into prefs structure for use by other functions
 */
void
LoadPreferences(void)
{
    char *home;
    char fname[PATH_MAX + NAME_MAX + 2];
    char szDisplay[512];
    char *szEnvDisplay;
    int i, j;
    char param[PARAM_MAX + 1];
    char *srcParam, *dstParam;
    int parsed = FALSE;

    /* First, clear all preference settings */
    memset(&pref, 0, sizeof(pref));

    /* Now try and find a ~/.xwinrc file */
    home = getenv("HOME");
    if (home) {
        strcpy(fname, home);
        if (fname[strlen(fname) - 1] != '/')
            strcat(fname, "/");
        strcat(fname, ".XWinrc");
        parsed = winPrefsLoadPreferences(fname);
    }

    /* No home file found, check system default */
    if (!parsed) {
        char buffer[MAX_PATH];

#ifdef RELOCATE_PROJECTROOT
        snprintf(buffer, sizeof(buffer), "%s\\system.XWinrc", winGetBaseDir());
#else
        strncpy(buffer, SYSCONFDIR "/X11/system.XWinrc", sizeof(buffer));
#endif
        buffer[sizeof(buffer) - 1] = 0;
        parsed = winPrefsLoadPreferences(buffer);
    }

    /* Neither user nor system configuration found, or were badly formed */
    if (!parsed) {
        ErrorF
            ("LoadPreferences: See \"man XWinrc\" to customize the XWin menu.\n");
        parsed = winPrefsLoadPreferences(NULL);
    }

    /* Setup a DISPLAY environment variable, need to allocate on heap */
    /* because putenv doesn't copy the argument... */
    winGetDisplayName(szDisplay, 0);
    szEnvDisplay = (char *) (malloc(strlen(szDisplay) + strlen("DISPLAY=") + 1));
    if (szEnvDisplay) {
        snprintf(szEnvDisplay, 512, "DISPLAY=%s", szDisplay);
        putenv(szEnvDisplay);
    }

    /* Replace any "%display%" in menu commands with display string */
    for (i = 0; i < pref.menuItems; i++) {
        for (j = 0; j < pref.menu[i].menuItems; j++) {
            if (pref.menu[i].menuItem[j].cmd == CMD_EXEC) {
                srcParam = pref.menu[i].menuItem[j].param;
                dstParam = param;
                while (*srcParam) {
                    if (!strncmp(srcParam, "%display%", 9)) {
                        memcpy(dstParam, szDisplay, strlen(szDisplay));
                        dstParam += strlen(szDisplay);
                        srcParam += 9;
                    }
                    else {
                        *dstParam = *srcParam;
                        dstParam++;
                        srcParam++;
                    }
                }
                *dstParam = 0;
                strcpy(pref.menu[i].menuItem[j].param, param);
            }                   /* cmd==cmd_exec */
        }                       /* for all menuitems */
    }                           /* for all menus */

}

/*
 * Check for a match of the window class to one specified in the
 * STYLES{} section in the prefs file, and return the style type
 */
unsigned long
winOverrideStyle(char *res_name, char *res_class, char *wmName)
{
    int i;

    for (i = 0; i < pref.styleItems; i++) {
        if ((res_name && !strcmp(pref.style[i].match, res_name)) ||
            (res_class && !strcmp(pref.style[i].match, res_class)) ||
            (wmName && strstr(wmName, pref.style[i].match))) {
            if (pref.style[i].type)
                return pref.style[i].type;
        }
    }

    /* Didn't find the style, fail gracefully */
    return STYLE_NONE;
}
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d47 1
d628 1
a628 1
winPrefsLoadPreferences(char *path)
d716 2
a717 2
    snprintf(szDisplay, 512, "DISPLAY=127.0.0.1:%s.0", display);
    szEnvDisplay = (char *) (malloc(strlen(szDisplay) + 1));
d719 1
a719 1
        strcpy(szEnvDisplay, szDisplay);
a723 1
    snprintf(szDisplay, 512, "127.0.0.1:%s.0", display);
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d184 1
a184 1
                wmMsg.iWindow = (Window) GetProp(hwnd, WIN_WID_PROP);
d191 1
a191 1
        SetupSysMenu((unsigned long) hwnd);
d278 1
a278 1
HandleCustomWM_INITMENU(unsigned long hwndIn, unsigned long hmenuIn)
a279 2
    HWND hwnd;
    HMENU hmenu;
a282 2
    hwnd = (HWND) hwndIn;
    hmenu = (HMENU) hmenuIn;
d304 1
a304 1
HandleCustomWM_COMMAND(unsigned long hwndIn, int command)
a305 1
    HWND hwnd;
a309 2
    hwnd = (HWND) hwndIn;

d408 1
a408 1
SetupSysMenu(unsigned long hwndIn)
a409 1
    HWND hwnd;
a414 1
    hwnd = (HWND) hwndIn;
d459 1
a459 1
SetupRootMenu(unsigned long hmenuRoot)
a460 3
    HMENU root;

    root = (HMENU) hmenuRoot;
d608 1
a608 1
winIconIsOverride(unsigned hiconIn)
a609 1
    HICON hicon;
a610 2

    hicon = (HICON) hiconIn;
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a59 3
/* Defined in DIX */
extern char *display;

a147 1
    Window wid;
d172 17
a188 4
        /* winUpdateIcon() will set the icon default, dynamic, or from xwinrc */
        wid = (Window) GetProp(hwnd, WIN_WID_PROP);
        if (wid)
            winUpdateIcon(wid);
d330 1
a330 1
                        unsigned long i;
d334 2
a335 2
                        for (i = STDERR_FILENO + 1; i < rl.rlim_cur; i++)
                            close(i);
d538 1
a538 1
    int index;
d545 1
a545 1
    index = 0;
d550 1
a550 1
        index = atoi(fname + 1);
d552 1
a552 1
                          MAKEINTRESOURCE(index), IMAGE_ICON, sx, sy, flags);
d569 2
a570 2
            index = atoi(strrchr(fname, ',') + 1);
            hicon = ExtractIcon(g_hInstance, file, index);
d589 1
a589 1
winOverrideIcon(unsigned long longWin)
a590 2
    WindowPtr pWin = (WindowPtr) longWin;
    char *res_name, *res_class;
a592 10
    char *wmName;

    if (pWin == NULL)
        return 0;

    /* If we can't find the class, we can't override from default! */
    if (!winMultiWindowGetClassHint(pWin, &res_name, &res_class))
        return 0;

    winMultiWindowGetWMName(pWin, &wmName);
d595 2
a596 2
        if (!strcmp(pref.icon[i].match, res_name) ||
            !strcmp(pref.icon[i].match, res_class) ||
a597 4
            free(res_name);
            free(res_class);
            free(wmName);

a611 4
    free(res_name);
    free(res_class);
    free(wmName);

d648 1
d660 1
@


1.4
log
@Update to xserver 1.11.2
@
text
@d54 2
a55 3
/* From winmultiwindowflex.l, the real parser */
extern void parse_file (FILE *fp);

a59 1

d64 1
a64 3
static HICON
LoadImageComma (char *fname, int sx, int sy, int flags);

d70 31
a100 82
MakeMenu (char *name,
	  HMENU editMenu,
	  int editItem)
{
  int i;
  int item;
  MENUPARSED *m;
  HMENU hmenu, hsub;

  for (i=0; i<pref.menuItems; i++)
    {
      if (!strcmp(name, pref.menu[i].menuName))
	break;
    }
  
  /* Didn't find a match, bummer */
  if (i==pref.menuItems)
    {
      ErrorF("MakeMenu: Can't find menu %s\n", name);
      return NULL;
    }
  
  m = &(pref.menu[i]);

  if (editMenu)
    {
      hmenu = editMenu;
      item = editItem;
    }
  else
    {
      hmenu = CreatePopupMenu();
      if (!hmenu)
	{
	  ErrorF("MakeMenu: Unable to CreatePopupMenu() %s\n", name);
	  return NULL;
	}
      item = 0;
    }

  /* Add the menu items */
  for (i=0; i<m->menuItems; i++)
    {
      /* Only assign IDs one time... */
      if ( m->menuItem[i].commandID == 0 )
	m->menuItem[i].commandID = g_cmdid++;

      switch (m->menuItem[i].cmd)
	{
	case CMD_EXEC:
	case CMD_ALWAYSONTOP:
	case CMD_RELOAD:
	  InsertMenu (hmenu,
		      item,
		      MF_BYPOSITION|MF_ENABLED|MF_STRING,
		      m->menuItem[i].commandID,
		      m->menuItem[i].text);
	  break;
	  
	case CMD_SEPARATOR:
	  InsertMenu (hmenu,
		      item,
		      MF_BYPOSITION|MF_SEPARATOR,
		      0,
		      NULL);
	  break;
	  
	case CMD_MENU:
	  /* Recursive! */
	  hsub = MakeMenu (m->menuItem[i].param, 0, 0);
	  if (hsub)
	    InsertMenu (hmenu,
			item,
			MF_BYPOSITION|MF_POPUP|MF_ENABLED|MF_STRING,
			(UINT_PTR)hsub,
			m->menuItem[i].text);
	  break;
	}

      /* If item==-1 (means to add at end of menu) don't increment) */
      if (item>=0)
	item++;
d103 37
a139 1
  return hmenu;
a141 1

d148 1
a148 1
ReloadEnumWindowsProc (HWND hwnd, LPARAM lParam)
d150 2
a151 2
  HICON   hicon;
  Window  wid;
d153 9
a161 4
  if (!hwnd) {
    ErrorF("ReloadEnumWindowsProc: hwnd==NULL!\n");
    return FALSE;
  }
d163 2
a164 5
  /* It's our baby, either clean or dirty it */
  if (lParam==FALSE) 
    {
      /* Reset the window's icon to undefined. */
      hicon = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, 0);
d166 3
a168 2
      /* If the old icon is generated on-the-fly, get rid of it, will regen */
      winDestroyIcon (hicon);
d170 2
a171 3
      /* Same for the small icon */
      hicon = (HICON)SendMessage(hwnd, WM_SETICON, ICON_SMALL, 0);
      winDestroyIcon (hicon);
d173 1
a173 4
      /* Remove any menu additions; bRevert=TRUE destroys any modified menus */
      GetSystemMenu (hwnd, TRUE);
      
      /* This window is now clean of our taint (but with undefined icons) */
d175 5
a179 6
  else
    {
      /* winUpdateIcon() will set the icon default, dynamic, or from xwinrc */
      wid = (Window)GetProp (hwnd, WIN_WID_PROP);
      if (wid)
	winUpdateIcon (wid);
d181 2
a182 2
      /* Update the system menu for this window */
      SetupSysMenu ((unsigned long)hwnd);
d184 1
a184 1
      /* That was easy... */
d187 1
a187 1
  return TRUE;
a190 1

d198 1
a198 1
ReloadPrefs (void)
d200 1
a200 1
  int i;
d203 7
a209 7
  /* First, iterate over all windows, deleting their icons and custom menus.
   * This is really only needed because winDestroyIcon() will try to
   * destroy the old global icons, which will have changed.
   * It is probably better to set a windows USER_DATA to flag locally defined
   * icons, and use that to accurately know when to destroy old icons.
   */
  EnumThreadWindows (g_dwCurrentThreadID, ReloadEnumWindowsProc, FALSE);
a210 32
  
  /* Now, free/clear all info from our prefs structure */
  for (i=0; i<pref.menuItems; i++)
    free (pref.menu[i].menuItem);
  free (pref.menu);
  pref.menu = NULL;
  pref.menuItems = 0;

  pref.rootMenuName[0] = 0;

  free (pref.sysMenu);
  pref.sysMenuItems = 0;

  pref.defaultSysMenuName[0] = 0;
  pref.defaultSysMenuPos = 0;

  pref.iconDirectory[0] = 0;
  pref.defaultIconName[0] = 0;
  pref.trayIconName[0] = 0;

  for (i=0; i<pref.iconItems; i++)
    if (pref.icon[i].hicon)
      DestroyIcon ((HICON)pref.icon[i].hicon);
  free (pref.icon);
  pref.icon = NULL;
  pref.iconItems = 0;
  
  /* Free global default X icon */
  if (g_hIconX) 
    DestroyIcon (g_hIconX);
  if (g_hSmallIconX)
    DestroyIcon (g_hSmallIconX);  
d212 34
a245 2
  /* Reset the custom command IDs */
  g_cmdid = STARTMENUID;
d247 2
a248 2
  /* Load the updated resource file */
  LoadPreferences();
d250 2
a251 2
  g_hIconX = NULL;
  g_hSmallIconX = NULL;
d254 1
a254 1
  winInitGlobalIcons();
d256 1
a256 1
  
d258 2
a259 2
  /* Rebuild the icons and menus */
  EnumThreadWindows (g_dwCurrentThreadID, ReloadEnumWindowsProc, TRUE);
d262 1
a262 1
  /* Whew, done */
d269 1
a269 2
HandleCustomWM_INITMENU(unsigned long hwndIn,
			unsigned long hmenuIn)
d271 21
a291 20
  HWND    hwnd;
  HMENU   hmenu;
  DWORD   dwExStyle;
  int     i, j;

  hwnd = (HWND)hwndIn;
  hmenu = (HMENU)hmenuIn;
  if (!hwnd || !hmenu) 
    return;
  
  if (GetWindowLongPtr(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
    dwExStyle = MF_BYCOMMAND | MF_CHECKED;
  else
    dwExStyle = MF_BYCOMMAND | MF_UNCHECKED;

  for (i=0; i<pref.menuItems; i++)
    for (j=0; j<pref.menu[i].menuItems; j++)
      if (pref.menu[i].menuItem[j].cmd==CMD_ALWAYSONTOP)
	CheckMenuItem (hmenu, pref.menu[i].menuItem[j].commandID, dwExStyle );
  
d293 1
a293 1
    
d299 1
a299 2
HandleCustomWM_COMMAND (unsigned long hwndIn,
			int           command)
d301 16
a316 20
  HWND hwnd;
  int i, j;
  MENUPARSED *m;
  DWORD			dwExStyle;

  hwnd = (HWND)hwndIn;

  if (!command)
    return FALSE;

  for (i=0; i<pref.menuItems; i++)
    {
      m = &(pref.menu[i]);
      for (j=0; j<m->menuItems; j++)
	{
	  if (command==m->menuItem[j].commandID)
	    {
	      /* Match! */
	      switch(m->menuItem[j].cmd)
		{
d318 20
a337 24
		case CMD_EXEC:
		  if (fork()==0)
		    {
		      struct rlimit rl;
		      unsigned long i;

		      /* Close any open descriptors except for STD* */
		      getrlimit (RLIMIT_NOFILE, &rl);
		      for (i = STDERR_FILENO+1; i < rl.rlim_cur; i++)
			close(i);

		      /* Disassociate any TTYs */
		      setsid();

		      execl ("/bin/sh",
			     "/bin/sh",
			     "-c",
			     m->menuItem[j].param,
			     NULL);
		      exit (0);
		    }
		  else
		    return TRUE;
		  break;
d339 25
a363 23
		case CMD_EXEC:
                  {
		    /* Start process without console window */
		    STARTUPINFO start;
		    PROCESS_INFORMATION child;

		    memset (&start, 0, sizeof (start));
		    start.cb = sizeof (start);
		    start.dwFlags = STARTF_USESHOWWINDOW;
		    start.wShowWindow = SW_HIDE;

		    memset (&child, 0, sizeof (child));

		    if (CreateProcess (NULL, m->menuItem[j].param, NULL, NULL, FALSE, 0,
				       NULL, NULL, &start, &child))
		    {
			CloseHandle (child.hThread);
			CloseHandle (child.hProcess);
		    }
		    else
			MessageBox(NULL, m->menuItem[j].param, "Mingrc Exec Command Error!", MB_OK | MB_ICONEXCLAMATION);
                  }
		  return TRUE;
d365 16
a380 20
		case CMD_ALWAYSONTOP:
		  if (!hwnd)
		    return FALSE;

		  /* Get extended window style */
		  dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
		  
		  /* Handle topmost windows */
		  if (dwExStyle & WS_EX_TOPMOST)
		    SetWindowPos (hwnd,
				  HWND_NOTOPMOST,
				  0, 0,
				  0, 0,
				  SWP_NOSIZE | SWP_NOMOVE);
		  else
		    SetWindowPos (hwnd,
				  HWND_TOPMOST,
				  0, 0,
				  0, 0,
				  SWP_NOSIZE | SWP_NOMOVE);
d382 2
a383 2
		  /* Reflect the changed Z order */
		  winReorderWindowsMultiWindow ();
d385 12
a396 12
		  return TRUE;
		  
		case CMD_RELOAD:
		  ReloadPrefs();
		  return TRUE;

		default:
		  return FALSE;
	      }
	    } /* match */
	} /* for j */
    } /* for i */
d398 1
a398 1
  return FALSE;
a400 1

d406 1
a406 1
SetupSysMenu (unsigned long hwndIn)
d408 43
a450 48
  HWND    hwnd;
  HMENU	  sys;
  int     i;
  WindowPtr pWin;
  char *res_name, *res_class;

  hwnd = (HWND)hwndIn;
  if (!hwnd)
    return;

  pWin = GetProp (hwnd, WIN_WINDOW_PROP);
  
  sys = GetSystemMenu (hwnd, FALSE);
  if (!sys)
    return;

  if (pWin)
    {
      /* First see if there's a class match... */
      if (winMultiWindowGetClassHint (pWin, &res_name, &res_class))
	{
	  for (i=0; i<pref.sysMenuItems; i++)
	    {
	      if (!strcmp(pref.sysMenu[i].match, res_name) ||
		  !strcmp(pref.sysMenu[i].match, res_class) ) 
		{
		  free(res_name);
		  free(res_class);
  
		  MakeMenu (pref.sysMenu[i].menuName, sys,
			    pref.sysMenu[i].menuPos==AT_START?0:-1);
		  return;
		}
	    }
	  
	  /* No match, just free alloc'd strings */
	  free(res_name);
	  free(res_class);
	} /* Found wm_class */
    } /* if pwin */

  /* Fallback to system default */
  if (pref.defaultSysMenuName[0])
    {
      if (pref.defaultSysMenuPos==AT_START)
	MakeMenu (pref.defaultSysMenuName, sys, 0);
      else
	MakeMenu (pref.defaultSysMenuName, sys, -1);
a454 1

d459 1
a459 1
SetupRootMenu (unsigned long hmenuRoot)
d461 1
a461 1
  HMENU root;
d463 3
a465 3
  root = (HMENU)hmenuRoot;
  if (!root)
    return;
d467 2
a468 3
  if (pref.rootMenuName[0])
    {
      MakeMenu(pref.rootMenuName, root, 0);
a471 1

d478 1
a478 8
  HICON hicon;
  
  if (pref.defaultIconName[0])
    {
      hicon = LoadImageComma (pref.defaultIconName, size, size, 0);
      if (hicon==NULL)
        ErrorF ("winOverrideDefaultIcon: LoadImageComma(%s) failed\n",
		pref.defaultIconName);
d480 7
a486 1
      return hicon;
d489 1
a489 1
  return 0;
a491 1

d498 1
a498 1
  HICON hicon;
d500 15
a514 18
  hicon = 0;
  /* First try and load an overridden, if success then return it */
  if (pref.trayIconName[0])
    {
      hicon = LoadImageComma (pref.trayIconName,
			      GetSystemMetrics (SM_CXSMICON),
			      GetSystemMetrics (SM_CYSMICON),
			      0 );
    }

  /* Otherwise return the default */
  if (!hicon)
    hicon =  (HICON) LoadImage (g_hInstance,
				MAKEINTRESOURCE(IDI_XWIN),
				IMAGE_ICON,
				GetSystemMetrics (SM_CXSMICON),
				GetSystemMetrics (SM_CYSMICON),
				0);
d516 1
a516 1
  return hicon;
a518 1

d526 1
a526 1
LoadImageComma (char *fname, int sx, int sy, int flags)
d528 25
a552 32
  HICON  hicon;
  int    index;
  char   file[PATH_MAX+NAME_MAX+2];

  /* Some input error checking */
  if (!fname || !fname[0])
    return NULL;

  index = 0;
  hicon = NULL;

  if (fname[0]==',')
    {
      /* It's the XWIN.EXE resource they want */
      index = atoi (fname+1);
      hicon = LoadImage (g_hInstance,
                        MAKEINTRESOURCE(index),
                        IMAGE_ICON,
                        sx,
                        sy,
                        flags);
    }
  else
    {
      file[0] = 0;
      /* Prepend path if not given a "X:\" filename */
      if ( !(fname[0] && fname[1]==':' && fname[2]=='\\') )
        {
         strcpy (file, pref.iconDirectory);
         if (pref.iconDirectory[0])
           if (fname[strlen(fname)-1]!='\\')
             strcat (file, "\\");
d554 4
a557 1
      strcat (file, fname);
d559 12
a570 19
      if (strrchr (file, ','))
       {
         /* Specified as <fname>,<index> */

         *(strrchr (file, ',')) = 0; /* End string at comma */
         index = atoi (strrchr (fname, ',') + 1);
         hicon = ExtractIcon (g_hInstance, file, index);
       }
      else
       {
         /* Just an .ico file... */

         hicon = (HICON)LoadImage (NULL,
                                   file,
                                   IMAGE_ICON,
                                   sx,
                                   sy,
                                   LR_LOADFROMFILE|flags);
       }
d572 1
a572 1
  return hicon;
d580 1
a580 1
winOverrideIcon (unsigned long longWin)
d582 35
a616 5
  WindowPtr pWin = (WindowPtr) longWin;
  char *res_name, *res_class;
  int i;
  HICON hicon;
  char *wmName;
d618 4
a621 2
  if (pWin==NULL)
    return 0;
a622 2
  /* If we can't find the class, we can't override from default! */
  if (!winMultiWindowGetClassHint (pWin, &res_name, &res_class))
a623 31

  winMultiWindowGetWMName (pWin, &wmName);
  
  for (i=0; i<pref.iconItems; i++) {
    if (!strcmp(pref.icon[i].match, res_name) ||
	!strcmp(pref.icon[i].match, res_class) ||
	(wmName && strstr(wmName, pref.icon[i].match))) 
      {
	free (res_name);
	free (res_class);
	free(wmName);

	if (pref.icon[i].hicon)
	  return pref.icon[i].hicon;

       hicon = LoadImageComma (pref.icon[i].iconFile, 0, 0, LR_DEFAULTSIZE);
       if (hicon==NULL)
         ErrorF ("winOverrideIcon: LoadImageComma(%s) failed\n",
                  pref.icon[i].iconFile);

	pref.icon[i].hicon = hicon;
	return hicon;
      }
  }
  
  /* Didn't find the icon, fail gracefully */
  free (res_name);
  free (res_class);
  free(wmName);

  return 0;
a625 1

d633 4
a636 2
  HICON hicon;
  int i;
d638 6
a643 1
  hicon = (HICON)hiconIn;
a644 1
  if (!hicon)
a645 6
  
  for (i=0; i<pref.iconItems; i++)
    if ((HICON)pref.icon[i].hicon == hicon)
      return 1;
  
  return 0;
d648 22
d671 16
d693 1
a693 1
LoadPreferences (void)
d695 26
a720 31
  char *home;
  char fname[PATH_MAX+NAME_MAX+2];
  FILE *prefFile;
  char szDisplay[512];
  char *szEnvDisplay;
  int i, j;
  char param[PARAM_MAX+1];
  char *srcParam, *dstParam;

  /* First, clear all preference settings */
  memset (&pref, 0, sizeof(pref));
  prefFile = NULL;

  /* Now try and find a ~/.xwinrc file */
  home = getenv ("HOME");
  if (home)
    {
      strcpy (fname, home);
      if (fname[strlen(fname)-1]!='/')
	strcat (fname, "/");
      strcat (fname, ".XWinrc");
      
      prefFile = fopen (fname, "r");
      if (prefFile)
	ErrorF ("winPrefsLoadPreferences: %s\n", fname);
    }

  /* No home file found, check system default */
  if (!prefFile)
    {
      char buffer[MAX_PATH];
d722 1
a722 1
      snprintf(buffer, sizeof(buffer), "%s\\system.XWinrc", winGetBaseDir());
d724 1
a724 1
      strncpy(buffer, SYSCONFDIR"/X11/system.XWinrc", sizeof(buffer));
d726 44
a769 52
      buffer[sizeof(buffer)-1] = 0;
      prefFile = fopen (buffer, "r");
      if (prefFile)
	ErrorF ("winPrefsLoadPreferences: %s\n", buffer);
    }

  /* If we could open it, then read the settings and close it */
  if (prefFile)
    {
      parse_file (prefFile);
      fclose (prefFile);
    }

  /* Setup a DISPLAY environment variable, need to allocate on heap */
  /* because putenv doesn't copy the argument... */
  snprintf (szDisplay, 512, "DISPLAY=127.0.0.1:%s.0", display);
  szEnvDisplay = (char *)(malloc (strlen(szDisplay)+1));
  if (szEnvDisplay)
    {
      strcpy (szEnvDisplay, szDisplay);
      putenv (szEnvDisplay);
    }

  /* Replace any "%display%" in menu commands with display string */
  snprintf (szDisplay, 512, "127.0.0.1:%s.0", display);
  for (i=0; i<pref.menuItems; i++)
    {
      for (j=0; j<pref.menu[i].menuItems; j++)
	{
	  if (pref.menu[i].menuItem[j].cmd==CMD_EXEC)
	    {
	      srcParam = pref.menu[i].menuItem[j].param;
	      dstParam = param;
	      while (*srcParam) {
		if (!strncmp(srcParam, "%display%", 9))
		  {
		    memcpy (dstParam, szDisplay, strlen(szDisplay));
		    dstParam += strlen(szDisplay);
		    srcParam += 9;
		  }
		else
		  {
		    *dstParam = *srcParam;
		    dstParam++;
		    srcParam++;
		  }
	      }
	      *dstParam = 0;
	      strcpy (pref.menu[i].menuItem[j].param, param);
	    } /* cmd==cmd_exec */
	} /* for all menuitems */
    } /* for all menus */
a772 1

d778 1
a778 1
winOverrideStyle (char *res_name, char *res_class, char *wmName)
d780 1
a780 1
  int i;
d782 8
a789 9
  for (i=0; i<pref.styleItems; i++) {
    if ((res_name && !strcmp(pref.style[i].match, res_name)) ||
	(res_class && !strcmp(pref.style[i].match, res_class)) ||
	(wmName && strstr(wmName, pref.style[i].match)))
      {
	if (pref.style[i].type)
	  return pref.style[i].type;
      }
  }
d791 2
a792 2
  /* Didn't find the style, fail gracefully */
  return STYLE_NONE;
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a51 5
/* External global variables */
#ifdef XWIN_MULTIWINDOW
extern DWORD g_dwCurrentThreadID;
#endif

a56 6
/* From winprefyacc.y, the pref structure loaded by the parser */
extern WINPREFS pref;

/* The global X default icon */
extern HICON		g_hIconX;
extern HICON		g_hSmallIconX;
d816 1
a816 1
winOverrideStyle (unsigned long longpWin)
a817 2
  WindowPtr pWin = (WindowPtr) longpWin;
  char *res_name, *res_class;
a818 10
  char *wmName;

  if (pWin==NULL)
    return STYLE_NONE;

  /* If we can't find the class, we can't override from default! */
  if (!winMultiWindowGetClassHint (pWin, &res_name, &res_class))
    return STYLE_NONE;

  winMultiWindowGetWMName (pWin, &wmName);
d821 2
a822 2
    if (!strcmp(pref.style[i].match, res_name) ||
	!strcmp(pref.style[i].match, res_class) ||
a824 4
	free (res_name);
	free (res_class);
	free(wmName);

a830 4
  free (res_name);
  free (res_class);
  free(wmName);

@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d675 1
a675 2
	if (wmName)
	  free (wmName);
d693 1
a693 2
  if (wmName)
    free (wmName);
d850 1
a850 2
	if (wmName)
	  free (wmName);
d860 1
a860 2
  if (wmName)
    free (wmName);
@


1.1
log
@Initial revision
@
text
@d3 1
d30 1
a31 1
/* $XFree86: $ */
d192 2
a193 1
      hicon = (HICON)GetClassLong(hwnd, GCL_HICON);
d195 2
a196 2
      /* Unselect any icon in the class structure */
      SetClassLong (hwnd, GCL_HICON, (LONG)LoadIcon (NULL, IDI_APPLICATION));
d198 2
a199 1
      /* If it's generated on-the-fly, get rid of it, will regen */
a200 5
     
      hicon = (HICON)GetClassLong(hwnd, GCL_HICONSM);

      /* Unselect any icon in the class structure */
      SetClassLong (hwnd, GCL_HICONSM, 0);
d202 1
a202 4
      /* If it's generated on-the-fly, get rid of it, will regen */
      winDestroyIcon (hicon);
      
      /* Remove any menu additions, use bRevert flag */
d205 1
a205 1
      /* This window is now clean of our taint */
d209 1
a209 3
      /* Make the icon default, dynamic, or from xwinrc */
      SetClassLong (hwnd, GCL_HICON, (LONG)g_hIconX);
      SetClassLong (hwnd, GCL_HICONSM, (LONG)g_hSmallIconX);
d213 1
d237 6
a242 2
  /* First, iterate over all windows replacing their icon with system */
  /* default one and deleting any custom system menus                 */
d316 1
a316 1
  if (GetWindowLong (hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
d411 1
a411 1
		  dwExStyle = GetWindowLong (hwnd, GWL_EXSTYLE);
d529 1
a529 1
unsigned long
d541 1
a541 1
      return (unsigned long)hicon;
d551 1
a551 1
unsigned long
d575 1
a575 1
  return (unsigned long)hicon;
d650 1
a650 1
unsigned long
d686 2
a687 2
	pref.icon[i].hicon = (unsigned long)hicon;
	return (unsigned long)hicon;
d726 1
a726 1
 * Try and open ~/.XWinrc and /usr/X11R6/lib/X11/system.XWinrc
d730 1
a730 1
LoadPreferences ()
d766 1
a766 1
      strncpy(buffer, PROJECTROOT"/lib/X11/system.XWinrc", sizeof(buffer));
d821 46
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d30 1
@

