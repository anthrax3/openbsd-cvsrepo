head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Dakshinamurthy Karra
 *		Suhaib M Siddiqi
 *		Peter Busch
 *		Harold L Hunt II
 *		Kensuke Matsuzaki
 */

#ifndef _WIN_H_
#define _WIN_H_

#ifndef NO
#define NO					0
#endif
#ifndef YES
#define YES					1
#endif

/* We can handle WM_MOUSEHWHEEL even though _WIN32_WINNT < 0x0600 */
#ifndef WM_MOUSEHWHEEL
#define WM_MOUSEHWHEEL 0x020E
#endif

/* Turn debug messages on or off */
#ifndef CYGDEBUG
#define CYGDEBUG				NO
#endif

#define WIN_DEFAULT_BPP				0
#define WIN_DEFAULT_WHITEPIXEL			255
#define WIN_DEFAULT_BLACKPIXEL			0
#define WIN_DEFAULT_LINEBIAS			0
#define WIN_DEFAULT_E3B_TIME			50      /* milliseconds */
#define WIN_DEFAULT_DPI				96
#define WIN_DEFAULT_REFRESH			0
#define WIN_DEFAULT_WIN_KILL			TRUE
#define WIN_DEFAULT_UNIX_KILL			FALSE
#define WIN_DEFAULT_CLIP_UPDATES_NBOXES		0
#ifdef XWIN_EMULATEPSEUDO
#define WIN_DEFAULT_EMULATE_PSEUDO		FALSE
#endif
#define WIN_DEFAULT_USER_GAVE_HEIGHT_AND_WIDTH	FALSE

/*
 * Windows only supports 256 color palettes
 */
#define WIN_NUM_PALETTE_ENTRIES			256

/*
 * Number of times to call Restore in an attempt to restore the primary surface
 */
#define WIN_REGAIN_SURFACE_RETRIES		1

/*
 * Build a supported display depths mask by shifting one to the left
 * by the number of bits in the supported depth.
 */
#define WIN_SUPPORTED_BPPS	( (1 << (32 - 1)) | (1 << (24 - 1)) \
				| (1 << (16 - 1)) | (1 << (15 - 1)) \
				| (1 << ( 8 - 1)))
#define WIN_CHECK_DEPTH		YES

/*
 * Timer IDs for WM_TIMER
 */
#define WIN_E3B_TIMER_ID		1
#define WIN_POLLING_MOUSE_TIMER_ID	2

#define MOUSE_POLLING_INTERVAL		50

#define WIN_E3B_OFF		-1
#define WIN_E3B_DEFAULT         0

#define WIN_FD_INVALID		-1

#define WIN_SERVER_NONE		0x0L    /* 0 */
#define WIN_SERVER_SHADOW_GDI	0x1L    /* 1 */
#define WIN_SERVER_SHADOW_DDNL	0x4L    /* 4 */

#define AltMapIndex		Mod1MapIndex
#define NumLockMapIndex		Mod2MapIndex
#define AltLangMapIndex		Mod3MapIndex
#define KanaMapIndex		Mod4MapIndex
#define ScrollLockMapIndex	Mod5MapIndex

#define WIN_MOD_LALT		0x00000001
#define WIN_MOD_RALT		0x00000002
#define WIN_MOD_LCONTROL	0x00000004
#define WIN_MOD_RCONTROL	0x00000008

#define WIN_24BPP_MASK_RED	0x00FF0000
#define WIN_24BPP_MASK_GREEN	0x0000FF00
#define WIN_24BPP_MASK_BLUE	0x000000FF

#define WIN_MAX_KEYS_PER_KEY	4

#define NONAMELESSUNION

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>

#include <errno.h>
#if defined(XWIN_MULTIWINDOWEXTWM) || defined(XWIN_CLIPBOARD) || defined(XWIN_MULTIWINDOW)
#define HANDLE void *
#include <pthread.h>
#undef HANDLE
#endif

#ifdef HAVE_MMAP
#include <sys/mman.h>
#ifndef MAP_FILE
#define MAP_FILE 0
#endif                          /* MAP_FILE */
#endif                          /* HAVE_MMAP */

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xos.h>
#include <X11/Xprotostr.h>
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "pixmap.h"
#include "region.h"
#include "gcstruct.h"
#include "colormap.h"
#include "colormapst.h"
#include "miscstruct.h"
#include "servermd.h"
#include "windowstr.h"
#include "mi.h"
#include "micmap.h"
#include "mifillarc.h"
#include "mifpoly.h"
#include "input.h"
#include "mipointer.h"
#include "X11/keysym.h"
#include "micoord.h"
#include "dix.h"
#include "miline.h"
#include "shadow.h"
#include "fb.h"
#include "rootless.h"

#include "mipict.h"
#include "picturestr.h"

#ifdef RANDR
#include "randrstr.h"
#endif

/*
 * Windows headers
 */
#include "winms.h"
#include "winresource.h"

/*
 * Define Windows constants
 */

#define WM_TRAYICON		(WM_USER + 1000)
#define WM_INIT_SYS_MENU	(WM_USER + 1001)
#define WM_GIVEUP		(WM_USER + 1002)

/* Local includes */
#include "winwindow.h"
#include "winmsg.h"

/*
 * Debugging macros
 */

#if CYGDEBUG
#define DEBUG_MSG(str,...) \
if (fDebugProcMsg) \
{ \
  char *pszTemp; \
  int iLength; \
  if (asprintf (&pszTemp, str, ##__VA_ARGS__) != -1) { \
    MessageBox (NULL, pszTemp, szFunctionName, MB_OK); \
    free (pszTemp); \
  } \
}
#else
#define DEBUG_MSG(str,...)
#endif

#if CYGDEBUG
#define DEBUG_FN_NAME(str) PTSTR szFunctionName = str
#else
#define DEBUG_FN_NAME(str)
#endif

#if CYGDEBUG || YES
#define DEBUGVARS BOOL fDebugProcMsg = FALSE
#else
#define DEBUGVARS
#endif

#if CYGDEBUG || YES
#define DEBUGPROC_MSG fDebugProcMsg = TRUE
#else
#define DEBUGPROC_MSG
#endif

#define PROFILEPOINT(point,thresh)\
{\
static unsigned int PROFPT##point = 0;\
if (++PROFPT##point % thresh == 0)\
ErrorF (#point ": PROFILEPOINT hit %u times\n", PROFPT##point);\
}

#define DEFINE_ATOM_HELPER(func,atom_name)			\
static Atom func (void) {					\
    static int generation;					\
    static Atom atom;						\
    if (generation != serverGeneration) {			\
	generation = serverGeneration;				\
	atom = MakeAtom (atom_name, strlen (atom_name), TRUE);	\
    }								\
    return atom;						\
}

/*
 * Typedefs for engine dependent function pointers
 */

typedef Bool (*winAllocateFBProcPtr) (ScreenPtr);

typedef void (*winFreeFBProcPtr) (ScreenPtr);

typedef void (*winShadowUpdateProcPtr) (ScreenPtr, shadowBufPtr);

typedef Bool (*winInitScreenProcPtr) (ScreenPtr);

typedef Bool (*winCloseScreenProcPtr) (ScreenPtr);

typedef Bool (*winInitVisualsProcPtr) (ScreenPtr);

typedef Bool (*winAdjustVideoModeProcPtr) (ScreenPtr);

typedef Bool (*winCreateBoundingWindowProcPtr) (ScreenPtr);

typedef Bool (*winFinishScreenInitProcPtr) (int, ScreenPtr, int, char **);

typedef Bool (*winBltExposedRegionsProcPtr) (ScreenPtr);

typedef Bool (*winActivateAppProcPtr) (ScreenPtr);

typedef Bool (*winRedrawScreenProcPtr) (ScreenPtr pScreen);

typedef Bool (*winRealizeInstalledPaletteProcPtr) (ScreenPtr pScreen);

typedef Bool (*winInstallColormapProcPtr) (ColormapPtr pColormap);

typedef Bool (*winStoreColorsProcPtr) (ColormapPtr pmap,
                                       int ndef, xColorItem * pdefs);

typedef Bool (*winCreateColormapProcPtr) (ColormapPtr pColormap);

typedef Bool (*winDestroyColormapProcPtr) (ColormapPtr pColormap);

typedef Bool (*winHotKeyAltTabProcPtr) (ScreenPtr);

typedef Bool (*winCreatePrimarySurfaceProcPtr) (ScreenPtr);

typedef Bool (*winReleasePrimarySurfaceProcPtr) (ScreenPtr);

typedef Bool (*winFinishCreateWindowsWindowProcPtr) (WindowPtr pWin);

typedef Bool (*winCreateScreenResourcesProc) (ScreenPtr);

/*
 * GC (graphics context) privates
 */

typedef struct {
    HDC hdc;
    HDC hdcMem;
} winPrivGCRec, *winPrivGCPtr;

/*
 * Pixmap privates
 */

typedef struct {
    HDC hdcSelected;
    HBITMAP hBitmap;
    BYTE *pbBits;
    DWORD dwScanlineBytes;
    BITMAPINFOHEADER *pbmih;
} winPrivPixmapRec, *winPrivPixmapPtr;

/*
 * Colormap privates
 */

typedef struct {
    HPALETTE hPalette;
    LPDIRECTDRAWPALETTE lpDDPalette;
    RGBQUAD rgbColors[WIN_NUM_PALETTE_ENTRIES];
    PALETTEENTRY peColors[WIN_NUM_PALETTE_ENTRIES];
} winPrivCmapRec, *winPrivCmapPtr;

/*
 * Windows Cursor handling.
 */

typedef struct {
    /* from GetSystemMetrics */
    int sm_cx;
    int sm_cy;

    BOOL visible;
    HCURSOR handle;
    QueryBestSizeProcPtr QueryBestSize;
    miPointerSpriteFuncPtr spriteFuncs;
} winCursorRec;

/*
 * Resize modes
 */
typedef enum {
    notAllowed,
    resizeWithScrollbars,
    resizeWithRandr
} winResizeMode;

/*
 * Screen information structure that we need before privates are available
 * in the server startup sequence.
 */

typedef struct {
    ScreenPtr pScreen;

    /* Did the user specify a height and width? */
    Bool fUserGaveHeightAndWidth;

    DWORD dwScreen;

    int iMonitor;
    HMONITOR hMonitor;
    DWORD dwUserWidth;
    DWORD dwUserHeight;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwPaddedWidth;

    /* Did the user specify a screen position? */
    Bool fUserGavePosition;
    DWORD dwInitialX;
    DWORD dwInitialY;

    /*
     * dwStride is the number of whole pixels that occupy a scanline,
     * including those pixels that are not displayed.  This is basically
     * a rounding up of the width.
     */
    DWORD dwStride;

    /* Offset of the screen in the window when using scrollbars */
    DWORD dwXOffset;
    DWORD dwYOffset;

    DWORD dwBPP;
    DWORD dwDepth;
    DWORD dwRefreshRate;
    char *pfb;
    DWORD dwEngine;
    DWORD dwEnginePreferred;
    DWORD dwClipUpdatesNBoxes;
#ifdef XWIN_EMULATEPSEUDO
    Bool fEmulatePseudo;
#endif
    Bool fFullScreen;
    Bool fDecoration;
#ifdef XWIN_MULTIWINDOWEXTWM
    Bool fMWExtWM;
    Bool fInternalWM;
    Bool fAnotherWMRunning;
#endif
    Bool fRootless;
#ifdef XWIN_MULTIWINDOW
    Bool fMultiWindow;
#endif
#if defined(XWIN_MULTIWINDOW) || defined(XWIN_MULTIWINDOWEXTWM)
    Bool fMultiMonitorOverride;
#endif
    Bool fMultipleMonitors;
    Bool fLessPointer;
    winResizeMode iResizeMode;
    Bool fNoTrayIcon;
    int iE3BTimeout;
    /* Windows (Alt+F4) and Unix (Ctrl+Alt+Backspace) Killkey */
    Bool fUseWinKillKey;
    Bool fUseUnixKillKey;
    Bool fIgnoreInput;

    /* Did the user explicitly set this screen? */
    Bool fExplicitScreen;
} winScreenInfo, *winScreenInfoPtr;

/*
 * Screen privates
 */

typedef struct _winPrivScreenRec {
    winScreenInfoPtr pScreenInfo;

    Bool fEnabled;
    Bool fClosed;
    Bool fActive;
    Bool fBadDepth;

    int iDeltaZ;
    int iDeltaV;

    int iConnectedClients;

    CloseScreenProcPtr CloseScreen;

    DWORD dwRedMask;
    DWORD dwGreenMask;
    DWORD dwBlueMask;
    DWORD dwBitsPerRGB;

    DWORD dwModeKeyStates;

    /* Handle to icons that must be freed */
    HICON hiconNotifyIcon;

    /* Palette management */
    ColormapPtr pcmapInstalled;

    /* Pointer to the root visual so we only have to look it up once */
    VisualPtr pRootVisual;

    /* 3 button emulation variables */
    int iE3BCachedPress;
    Bool fE3BFakeButton2Sent;

    /* Privates used by shadow fb GDI engine */
    HBITMAP hbmpShadow;
    HDC hdcScreen;
    HDC hdcShadow;
    HWND hwndScreen;
    BITMAPINFOHEADER *pbmih;

    /* Privates used by shadow fb DirectDraw Nonlocking engine */
    LPDIRECTDRAW pdd;
    LPDIRECTDRAW4 pdd4;
    LPDIRECTDRAWSURFACE4 pddsShadow4;
    LPDIRECTDRAWSURFACE4 pddsPrimary4;
    LPDIRECTDRAWCLIPPER pddcPrimary;
    BOOL fRetryCreateSurface;

#ifdef XWIN_MULTIWINDOWEXTWM
    /* Privates used by multi-window external window manager */
    RootlessFrameID widTop;
    Bool fRestacking;
#endif

#ifdef XWIN_MULTIWINDOW
    /* Privates used by multi-window */
    pthread_t ptWMProc;
    pthread_t ptXMsgProc;
    void *pWMInfo;
#endif

#if defined(XWIN_MULTIWINDOW) || defined(XWIN_MULTIWINDOWEXTWM)
    /* Privates used by both multi-window and rootless */
    Bool fRootWindowShown;
#endif

#if defined(XWIN_CLIPBOARD) || defined(XWIN_MULTIWINDOW)
    /* Privates used for any module running in a seperate thread */
    pthread_mutex_t pmServerStarted;
    Bool fServerStarted;
#endif

    /* Engine specific functions */
    winAllocateFBProcPtr pwinAllocateFB;
    winFreeFBProcPtr pwinFreeFB;
    winShadowUpdateProcPtr pwinShadowUpdate;
    winInitScreenProcPtr pwinInitScreen;
    winCloseScreenProcPtr pwinCloseScreen;
    winInitVisualsProcPtr pwinInitVisuals;
    winAdjustVideoModeProcPtr pwinAdjustVideoMode;
    winCreateBoundingWindowProcPtr pwinCreateBoundingWindow;
    winFinishScreenInitProcPtr pwinFinishScreenInit;
    winBltExposedRegionsProcPtr pwinBltExposedRegions;
    winActivateAppProcPtr pwinActivateApp;
    winRedrawScreenProcPtr pwinRedrawScreen;
    winRealizeInstalledPaletteProcPtr pwinRealizeInstalledPalette;
    winInstallColormapProcPtr pwinInstallColormap;
    winStoreColorsProcPtr pwinStoreColors;
    winCreateColormapProcPtr pwinCreateColormap;
    winDestroyColormapProcPtr pwinDestroyColormap;
    winHotKeyAltTabProcPtr pwinHotKeyAltTab;
    winCreatePrimarySurfaceProcPtr pwinCreatePrimarySurface;
    winReleasePrimarySurfaceProcPtr pwinReleasePrimarySurface;

    winCreateScreenResourcesProc pwinCreateScreenResources;

#ifdef XWIN_MULTIWINDOW
    /* Window Procedures for MultiWindow mode */
    winFinishCreateWindowsWindowProcPtr pwinFinishCreateWindowsWindow;
#endif

    /* Window Procedures for Rootless mode */
    CreateWindowProcPtr CreateWindow;
    DestroyWindowProcPtr DestroyWindow;
    PositionWindowProcPtr PositionWindow;
    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
    RealizeWindowProcPtr RealizeWindow;
    UnrealizeWindowProcPtr UnrealizeWindow;
    ValidateTreeProcPtr ValidateTree;
    PostValidateTreeProcPtr PostValidateTree;
    CopyWindowProcPtr CopyWindow;
    ClearToBackgroundProcPtr ClearToBackground;
    ClipNotifyProcPtr ClipNotify;
    RestackWindowProcPtr RestackWindow;
    ReparentWindowProcPtr ReparentWindow;
    ResizeWindowProcPtr ResizeWindow;
    MoveWindowProcPtr MoveWindow;
    SetShapeProcPtr SetShape;

    winCursorRec cursor;
} winPrivScreenRec;

#ifdef XWIN_MULTIWINDOWEXTWM
typedef struct {
    RootlessWindowPtr pFrame;
    HWND hWnd;
    int dwWidthBytes;
    BITMAPINFOHEADER *pbmihShadow;
    HBITMAP hbmpShadow;
    HDC hdcShadow;
    HDC hdcScreen;
    BOOL fResized;
    BOOL fRestackingNow;
    BOOL fClose;
    BOOL fMovingOrSizing;
    BOOL fDestroyed;            //for debug
    char *pfb;
} win32RootlessWindowRec, *win32RootlessWindowPtr;
#endif

typedef struct {
    void *value;
    XID id;
} WindowIDPairRec, *WindowIDPairPtr;

/*
 * Extern declares for general global variables
 */

#include "winglobals.h"

extern winScreenInfo *g_ScreenInfo;
extern miPointerScreenFuncRec g_winPointerCursorFuncs;
extern DWORD g_dwEvents;

#ifdef HAS_DEVWINDOWS
extern int g_fdMessageQueue;
#endif
extern DevPrivateKeyRec g_iScreenPrivateKeyRec;

#define g_iScreenPrivateKey  	(&g_iScreenPrivateKeyRec)
extern DevPrivateKeyRec g_iCmapPrivateKeyRec;

#define g_iCmapPrivateKey 	(&g_iCmapPrivateKeyRec)
extern DevPrivateKeyRec g_iGCPrivateKeyRec;

#define g_iGCPrivateKey 	(&g_iGCPrivateKeyRec)
extern DevPrivateKeyRec g_iPixmapPrivateKeyRec;

#define g_iPixmapPrivateKey 	(&g_iPixmapPrivateKeyRec)
extern DevPrivateKeyRec g_iWindowPrivateKeyRec;

#define g_iWindowPrivateKey 	(&g_iWindowPrivateKeyRec)

extern unsigned long g_ulServerGeneration;
extern DWORD g_dwEnginesSupported;
extern HINSTANCE g_hInstance;
extern int g_copyROP[];
extern int g_patternROP[];
extern const char *g_pszQueryHost;
extern DeviceIntPtr g_pwinPointer;
extern DeviceIntPtr g_pwinKeyboard;

/*
 * Extern declares for dynamically loaded library function pointers
 */

extern FARPROC g_fpDirectDrawCreate;
extern FARPROC g_fpDirectDrawCreateClipper;

/*
 * Screen privates macros
 */

#define winGetScreenPriv(pScreen) ((winPrivScreenPtr) \
    dixLookupPrivate(&(pScreen)->devPrivates, g_iScreenPrivateKey))

#define winSetScreenPriv(pScreen,v) \
    dixSetPrivate(&(pScreen)->devPrivates, g_iScreenPrivateKey, v)

#define winScreenPriv(pScreen) \
	winPrivScreenPtr pScreenPriv = winGetScreenPriv(pScreen)

/*
 * Colormap privates macros
 */

#define winGetCmapPriv(pCmap) ((winPrivCmapPtr) \
    dixLookupPrivate(&(pCmap)->devPrivates, g_iCmapPrivateKey))

#define winSetCmapPriv(pCmap,v) \
    dixSetPrivate(&(pCmap)->devPrivates, g_iCmapPrivateKey, v)

#define winCmapPriv(pCmap) \
	winPrivCmapPtr pCmapPriv = winGetCmapPriv(pCmap)

/*
 * GC privates macros
 */

#define winGetGCPriv(pGC) ((winPrivGCPtr) \
    dixLookupPrivate(&(pGC)->devPrivates, g_iGCPrivateKey))

#define winSetGCPriv(pGC,v) \
    dixSetPrivate(&(pGC)->devPrivates, g_iGCPrivateKey, v)

#define winGCPriv(pGC) \
	winPrivGCPtr pGCPriv = winGetGCPriv(pGC)

/*
 * Pixmap privates macros
 */

#define winGetPixmapPriv(pPixmap) ((winPrivPixmapPtr) \
    dixLookupPrivate(&(pPixmap)->devPrivates, g_iPixmapPrivateKey))

#define winSetPixmapPriv(pPixmap,v) \
    dixLookupPrivate(&(pPixmap)->devPrivates, g_iPixmapPrivateKey, v)

#define winPixmapPriv(pPixmap) \
	winPrivPixmapPtr pPixmapPriv = winGetPixmapPriv(pPixmap)

/*
 * Window privates macros
 */

#define winGetWindowPriv(pWin) ((winPrivWinPtr) \
    dixLookupPrivate(&(pWin)->devPrivates, g_iWindowPrivateKey))

#define winSetWindowPriv(pWin,v) \
    dixLookupPrivate(&(pWin)->devPrivates, g_iWindowPrivateKey, v)

#define winWindowPriv(pWin) \
	winPrivWinPtr pWinPriv = winGetWindowPriv(pWin)

/*
 * wrapper macros
 */
#define _WIN_WRAP(priv, real, mem, func) {\
    priv->mem = real->mem; \
    real->mem = func; \
}

#define _WIN_UNWRAP(priv, real, mem) {\
    real->mem = priv->mem; \
}

#define WIN_WRAP(mem, func) _WIN_WRAP(pScreenPriv, pScreen, mem, func)

#define WIN_UNWRAP(mem) _WIN_UNWRAP(pScreenPriv, pScreen, mem)

/*
 * BEGIN DDX and DIX Function Prototypes
 */

/*
 * winallpriv.c
 */

Bool
 winAllocatePrivates(ScreenPtr pScreen);

Bool
 winInitCmapPrivates(ColormapPtr pCmap, int i);

Bool
 winAllocateCmapPrivates(ColormapPtr pCmap);

/*
 * winauth.c
 */

#if defined(XWIN_CLIPBOARD) || defined(XWIN_MULTIWINDOW)
Bool
 winGenerateAuthorization(void);
void winSetAuthorization(void);
#endif

/*
 * winblock.c
 */

void

winBlockHandler(ScreenPtr pScreen,
                void *pTimeout, void *pReadMask);

#ifdef XWIN_CLIPBOARD
/*
 * winclipboardinit.c
 */

Bool
 winInitClipboard(void);

void
 winClipboardShutdown(void);
#endif

/*
 * wincmap.c
 */

void
 winSetColormapFunctions(ScreenPtr pScreen);

Bool
 winCreateDefColormap(ScreenPtr pScreen);

/*
 * wincreatewnd.c
 */

Bool
 winCreateBoundingWindowFullScreen(ScreenPtr pScreen);

Bool
 winCreateBoundingWindowWindowed(ScreenPtr pScreen);

/*
 * windialogs.c
 */

void
 winDisplayExitDialog(winPrivScreenPtr pScreenPriv);

void
 winDisplayDepthChangeDialog(winPrivScreenPtr pScreenPriv);

void
 winDisplayAboutDialog(winPrivScreenPtr pScreenPriv);

/*
 * winengine.c
 */

void
 winDetectSupportedEngines(void);

Bool
 winSetEngine(ScreenPtr pScreen);

Bool
 winGetDDProcAddresses(void);

void
 winReleaseDDProcAddresses(void);

/*
 * winerror.c
 */

#ifdef DDXOSVERRORF
void
OsVendorVErrorF(const char *pszFormat, va_list va_args)
_X_ATTRIBUTE_PRINTF(1, 0);
#endif

void
winMessageBoxF(const char *pszError, UINT uType, ...)
_X_ATTRIBUTE_PRINTF(1, 3);

/*
 * winglobals.c
 */

void
 winInitializeGlobals(void);

/*
 * winkeybd.c
 */

int
 winTranslateKey(WPARAM wParam, LPARAM lParam);

int
 winKeybdProc(DeviceIntPtr pDeviceInt, int iState);

void
 winInitializeModeKeyStates(void);

void
 winRestoreModeKeyStates(void);

Bool
 winIsFakeCtrl_L(UINT message, WPARAM wParam, LPARAM lParam);

void
 winKeybdReleaseKeys(void);

void
 winSendKeyEvent(DWORD dwKey, Bool fDown);

BOOL winCheckKeyPressed(WPARAM wParam, LPARAM lParam);

void
 winFixShiftKeys(int iScanCode);

/*
 * winkeyhook.c
 */

Bool
 winInstallKeyboardHookLL(void);

void
 winRemoveKeyboardHookLL(void);

/*
 * winmisc.c
 */

CARD8
 winCountBits(DWORD dw);

Bool
 winUpdateFBPointer(ScreenPtr pScreen, void *pbits);

/*
 * winmouse.c
 */

int
 winMouseProc(DeviceIntPtr pDeviceInt, int iState);

int
 winMouseWheel(int *iTotalDeltaZ, int iDeltaZ, int iButtonUp, int iButtonDown);

void
 winMouseButtonsSendEvent(int iEventType, int iButton);

int

winMouseButtonsHandle(ScreenPtr pScreen,
                      int iEventType, int iButton, WPARAM wParam);

void
 winEnqueueMotion(int x, int y);

/*
 * winscrinit.c
 */

Bool
 winScreenInit(ScreenPtr pScreen, int argc, char **argv);

Bool
 winFinishScreenInitFB(int i, ScreenPtr pScreen, int argc, char **argv);

/*
 * winshadddnl.c
 */

Bool
 winSetEngineFunctionsShadowDDNL(ScreenPtr pScreen);

/*
 * winshadgdi.c
 */

Bool
 winSetEngineFunctionsShadowGDI(ScreenPtr pScreen);

/*
 * winwakeup.c
 */

void

winWakeupHandler(ScreenPtr pScreen,
                 unsigned long ulResult, void *pReadmask);

/*
 * winwindow.c
 */

Bool
 winCreateWindowRootless(WindowPtr pWindow);

Bool
 winDestroyWindowRootless(WindowPtr pWindow);

Bool
 winPositionWindowRootless(WindowPtr pWindow, int x, int y);

Bool
 winChangeWindowAttributesRootless(WindowPtr pWindow, unsigned long mask);

Bool
 winUnmapWindowRootless(WindowPtr pWindow);

Bool
 winMapWindowRootless(WindowPtr pWindow);

void
 winSetShapeRootless(WindowPtr pWindow, int kind);

#ifdef XWIN_MULTIWINDOW
/*
 * winmultiwindowshape.c
 */

void
 winReshapeMultiWindow(WindowPtr pWin);

void
 winSetShapeMultiWindow(WindowPtr pWindow, int kind);

void
 winUpdateRgnMultiWindow(WindowPtr pWindow);
#endif

#ifdef XWIN_MULTIWINDOW
/*
 * winmultiwindowwindow.c
 */

Bool
 winCreateWindowMultiWindow(WindowPtr pWindow);

Bool
 winDestroyWindowMultiWindow(WindowPtr pWindow);

Bool
 winPositionWindowMultiWindow(WindowPtr pWindow, int x, int y);

Bool
 winChangeWindowAttributesMultiWindow(WindowPtr pWindow, unsigned long mask);

Bool
 winUnmapWindowMultiWindow(WindowPtr pWindow);

Bool
 winMapWindowMultiWindow(WindowPtr pWindow);

void
 winReparentWindowMultiWindow(WindowPtr pWin, WindowPtr pPriorParent);

void
 winRestackWindowMultiWindow(WindowPtr pWin, WindowPtr pOldNextSib);

void
 winReorderWindowsMultiWindow(void);

void

winResizeWindowMultiWindow(WindowPtr pWin, int x, int y, unsigned int w,
                           unsigned int h, WindowPtr pSib);
void

winMoveWindowMultiWindow(WindowPtr pWin, int x, int y,
                         WindowPtr pSib, VTKind kind);

void

winCopyWindowMultiWindow(WindowPtr pWin, DDXPointRec oldpt,
                         RegionPtr oldRegion);

XID
 winGetWindowID(WindowPtr pWin);

int
 winAdjustXWindow(WindowPtr pWin, HWND hwnd);
#endif

#ifdef XWIN_MULTIWINDOW
/*
 * winmultiwindowwndproc.c
 */

LRESULT CALLBACK
winTopLevelWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif

/*
 * wintrayicon.c
 */

void
 winInitNotifyIcon(winPrivScreenPtr pScreenPriv);

void
 winDeleteNotifyIcon(winPrivScreenPtr pScreenPriv);

LRESULT
winHandleIconMessage(HWND hwnd, UINT message,
                     WPARAM wParam, LPARAM lParam,
                     winPrivScreenPtr pScreenPriv);

/*
 * winwndproc.c
 */

LRESULT CALLBACK
winWindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef XWIN_MULTIWINDOWEXTWM
/*
 * winwin32rootless.c
 */

Bool

winMWExtWMCreateFrame(RootlessWindowPtr pFrame, ScreenPtr pScreen,
                      int newX, int newY, RegionPtr pShape);

void
 winMWExtWMDestroyFrame(RootlessFrameID wid);

void

winMWExtWMMoveFrame(RootlessFrameID wid, ScreenPtr pScreen, int newX, int newY);

void

winMWExtWMResizeFrame(RootlessFrameID wid, ScreenPtr pScreen,
                      int newX, int newY, unsigned int newW, unsigned int newH,
                      unsigned int gravity);

void
 winMWExtWMRestackFrame(RootlessFrameID wid, RootlessFrameID nextWid);

void
 winMWExtWMReshapeFrame(RootlessFrameID wid, RegionPtr pShape);

void
 winMWExtWMUnmapFrame(RootlessFrameID wid);

void

winMWExtWMStartDrawing(RootlessFrameID wid, char **pixelData, int *bytesPerRow);

void
 winMWExtWMStopDrawing(RootlessFrameID wid, Bool flush);

void
 winMWExtWMUpdateRegion(RootlessFrameID wid, RegionPtr pDamage);

void

winMWExtWMDamageRects(RootlessFrameID wid, int count, const BoxRec * rects,
                      int shift_x, int shift_y);

void
 winMWExtWMRootlessSwitchWindow(RootlessWindowPtr pFrame, WindowPtr oldWin);

void

winMWExtWMCopyBytes(unsigned int width, unsigned int height,
                    const void *src, unsigned int srcRowBytes,
                    void *dst, unsigned int dstRowBytes);

void

winMWExtWMCopyWindow(RootlessFrameID wid, int dstNrects,
                     const BoxRec * dstRects, int dx, int dy);
#endif

#ifdef XWIN_MULTIWINDOWEXTWM
/*
 * winwin32rootlesswindow.c
 */

void
 winMWExtWMReorderWindows(ScreenPtr pScreen);

void
 winMWExtWMMoveXWindow(WindowPtr pWin, int x, int y);

void
 winMWExtWMResizeXWindow(WindowPtr pWin, int w, int h);

void
 winMWExtWMMoveResizeXWindow(WindowPtr pWin, int x, int y, int w, int h);

void

winMWExtWMUpdateWindowDecoration(win32RootlessWindowPtr pRLWinPriv,
                                 winScreenInfoPtr pScreenInfo);

wBOOL CALLBACK winMWExtWMDecorateWindow(HWND hwnd, LPARAM lParam);

Bool
 winIsInternalWMRunning(winScreenInfoPtr pScreenInfo);

void
 winMWExtWMRestackWindows(ScreenPtr pScreen);
#endif

#ifdef XWIN_MULTIWINDOWEXTWM
/*
 * winwin32rootlesswndproc.c
 */

LRESULT CALLBACK
winMWExtWMWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#endif

/*
 * winwindowswm.c
 */

void

winWindowsWMSendEvent(int type, unsigned int mask, int which, int arg,
                      Window window, int x, int y, int w, int h);

void
 winWindowsWMExtensionInit(void);

/*
 * wincursor.c
 */

Bool
 winInitCursor(ScreenPtr pScreen);

/*
 * winprocarg.c
 */
void
 winInitializeScreens(int maxscreens);

/*
 * winrandr.c
 */
Bool
 winRandRInit(ScreenPtr pScreen);
void

winDoRandRScreenSetSize(ScreenPtr pScreen,
                        CARD16 width,
                        CARD16 height, CARD32 mmWidth, CARD32 mmHeight);

/*
 * winmsgwindow.c
 */
Bool
winCreateMsgWindowThread(void);

/*
 * winos.c
 */
void
winOS(void);

/*
 * END DDX and DIX Function Prototypes
 */

#endif                          /* _WIN_H_ */
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a103 1
#define WIN_SERVER_SHADOW_DD	0x2L    /* 2 */
d470 1
a470 1
    /* Privates used by shadow fb GDI server */
d477 1
a477 1
    /* Privates used by shadow fb and primary fb DirectDraw servers */
a478 13
    LPDIRECTDRAWSURFACE2 pddsPrimary;
    LPDIRECTDRAW2 pdd2;

    /* Privates used by shadow fb DirectDraw server */
    LPDIRECTDRAWSURFACE2 pddsShadow;
    LPDDSURFACEDESC pddsdShadow;

    /* Privates used by primary fb DirectDraw server */
    LPDIRECTDRAWSURFACE2 pddsOffscreen;
    LPDDSURFACEDESC pddsdOffscreen;
    LPDDSURFACEDESC pddsdPrimary;

    /* Privates used by shadow fb DirectDraw Nonlocking server */
d482 1
a484 3
    /* Privates used by both shadow fb DirectDraw servers */
    LPDIRECTDRAWCLIPPER pddcPrimary;

a907 7
 * winshaddd.c
 */

Bool
 winSetEngineFunctionsShadowDD(ScreenPtr pScreen);

/*
d1197 6
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a105 6
#ifdef XWIN_PRIMARYFB
#define WIN_SERVER_PRIMARY_DD	0x8L    /* 8 */
#endif
#ifdef XWIN_NATIVEGDI
#define WIN_SERVER_NATIVE_GDI	0x10L   /* 16 */
#endif
a300 6
#ifdef XWIN_NATIVEGDI
/* Typedefs for native GDI wrappers */
typedef Bool (*RealizeFontPtr) (ScreenPtr pScreen, FontPtr pFont);
typedef Bool (*UnrealizeFontPtr) (ScreenPtr pScreen, FontPtr pFont);
#endif

a572 6

#ifdef XWIN_NATIVEGDI
    RealizeFontPtr RealizeFont;
    UnrealizeFontPtr UnrealizeFont;
#endif

d709 1
a709 1
 * wrapper macros 
a759 9
#ifdef XWIN_NATIVEGDI
/*
 * winclip.c
 */

RegionPtr
 winPixmapToRegionNativeGDI(PixmapPtr pPix);
#endif

d769 1
a769 1
 winFixClipboardChain(void);
a834 46
#ifdef XWIN_NATIVEGDI
/*
 * winfillsp.c
 */

void

winFillSpansNativeGDI(DrawablePtr pDrawable,
                      GCPtr pGC,
                      int nSpans,
                      DDXPointPtr pPoints, int *pWidths, int fSorted);
#endif

#ifdef XWIN_NATIVEGDI
/*
 * winfont.c
 */

Bool
 winRealizeFontNativeGDI(ScreenPtr pScreen, FontPtr pFont);

Bool
 winUnrealizeFontNativeGDI(ScreenPtr pScreen, FontPtr pFont);
#endif

#ifdef XWIN_NATIVEGDI
/*
 * wingc.c
 */

Bool
 winCreateGCNativeGDI(GCPtr pGC);
#endif

#ifdef XWIN_NATIVEGDI
/*
 * wingetsp.c
 */

void

winGetSpansNativeGDI(DrawablePtr pDrawable,
                     int wMax,
                     DDXPointPtr pPoints, int *pWidths, int nSpans, char *pDst);
#endif

a885 7
#ifdef XWIN_NATIVEGDI
void

winQueryBestSizeNativeGDI(int class, unsigned short *pWidth,
                          unsigned short *pHeight, ScreenPtr pScreen);
#endif

a891 4
#ifdef XWIN_NATIVEGDI
BOOL winPaintBackground(HWND hwnd, COLORREF colorref);
#endif

a912 54
#ifdef XWIN_NATIVEGDI
/*
 * winnativegdi.c
 */

HBITMAP
winCreateDIBNativeGDI(int iWidth, int iHeight, int iDepth,
                      BYTE ** ppbBits, BITMAPINFO ** ppbmi);

Bool
 winSetEngineFunctionsNativeGDI(ScreenPtr pScreen);
#endif

#ifdef XWIN_PRIMARYFB
/*
 * winpfbddd.c
 */

Bool
 winSetEngineFunctionsPrimaryDD(ScreenPtr pScreen);
#endif

#ifdef XWIN_NATIVEGDI
/*
 * winpixmap.c
 */

PixmapPtr

winCreatePixmapNativeGDI(ScreenPtr pScreen, int width, int height, int depth,
                         unsigned usage_hint);

Bool
 winDestroyPixmapNativeGDI(PixmapPtr pPixmap);

Bool

winModifyPixmapHeaderNativeGDI(PixmapPtr pPixmap,
                               int iWidth, int iHeight,
                               int iDepth,
                               int iBitsPerPixel,
                               int devKind, void *pPixData);
#endif

#ifdef XWIN_NATIVEGDI
/*
 * winpolyline.c
 */

void

winPolyLineNativeGDI(DrawablePtr pDrawable,
                     GCPtr pGC, int mode, int npt, DDXPointPtr ppt);
#endif
a922 20
#if defined(XWIN_NATIVEGDI)
Bool

winFinishScreenInitNativeGDI(int i,
                             ScreenPtr pScreen, int argc, char **argv);
#endif

#ifdef XWIN_NATIVEGDI
/*
 * winsetsp.c
 */

void

winSetSpansNativeGDI(DrawablePtr pDrawable,
                     GCPtr pGC,
                     char *pSrc,
                     DDXPointPtr pPoints, int *pWidth, int nSpans, int fSorted);
#endif

a955 24

#ifdef XWIN_NATIVEGDI
Bool
 winCreateWindowNativeGDI(WindowPtr pWin);

Bool
 winDestroyWindowNativeGDI(WindowPtr pWin);

Bool
 winPositionWindowNativeGDI(WindowPtr pWin, int x, int y);

void

winCopyWindowNativeGDI(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);

Bool
 winChangeWindowAttributesNativeGDI(WindowPtr pWin, unsigned long mask);

Bool
 winUnmapWindowNativeGDI(WindowPtr pWindow);

Bool
 winMapWindowNativeGDI(WindowPtr pWindow);
#endif
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d612 1
a612 1
    pointer value;
d754 1
a754 1
 winInitCmapPrivates(ColormapPtr pCmap, int index);
d776 1
a776 1
                pointer pTimeout, pointer pReadMask);
d1038 1
a1038 1
                               int devKind, pointer pPixData);
d1059 1
a1059 1
 winFinishScreenInitFB(int index, ScreenPtr pScreen, int argc, char **argv);
d1064 1
a1064 1
winFinishScreenInitNativeGDI(int index,
d1109 1
a1109 1
                 unsigned long ulResult, pointer pReadmask);
a1336 3

void
 winMWExtWMUpdateIcon(Window id);
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d45 5
a54 11
/* WM_XBUTTON Messages. They should go into w32api. */
#ifndef WM_XBUTTONDOWN
#define WM_XBUTTONDOWN 523
#endif
#ifndef WM_XBUTTONUP
#define WM_XBUTTONUP 524
#endif
#ifndef WM_XBUTTONDBLCLK
#define WM_XBUTTONDBLCLK 525
#endif

d457 1
d919 2
a920 2
void
 winTranslateKey(WPARAM wParam, LPARAM lParam, int *piScanCode);
d984 1
a984 1
 winMouseWheel(ScreenPtr pScreen, int iDeltaZ);
d1399 6
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d136 2
a173 1
#include "mibstore.h"
a252 3
/* We use xor this macro for detecting toggle key state changes */
#define WIN_XOR(a,b) ((!(a) && (b)) || ((a) && !(b)))

d276 1
a276 1
typedef Bool (*winCloseScreenProcPtr) (int, ScreenPtr);
d389 1
a579 1
    WindowExposuresProcPtr WindowExposures;
d780 2
a781 2
winBlockHandler(int nScreen,
                pointer pBlockData, pointer pTimeout, pointer pReadMask);
d859 2
a860 1
 OSVenderVErrorF(const char *pszFormat, va_list va_args);
d864 2
a865 1
 winMessageBoxF(const char *pszError, UINT uType, ...);
a1055 12

#ifdef XWIN_NATIVEGDI
/*
 * winpushpxl.c
 */

void

winPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr pDrawable,
              int dx, int dy, int xOrg, int yOrg);
#endif

d1061 1
a1061 1
 winScreenInit(int index, ScreenPtr pScreen, int argc, char **argv);
d1113 1
a1113 2
winWakeupHandler(int nScreen,
                 pointer pWakeupData,
a1163 9

/*
 * winmultiwindowicons.c - Used by both multi-window and Win32Rootless
 */

HICON winXIconToHICON(WindowPtr pWin, int iconSize);

void
 winSelectIcons(WindowPtr pWin, HICON * pIcon, HICON * pSmallIcon);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d52 1
a52 1
# define WM_XBUTTONDOWN 523
d55 1
a55 1
# define WM_XBUTTONUP 524
d58 1
a58 1
# define WM_XBUTTONDBLCLK 525
a60 1

d65 2
a66 2
#define WIN_DEFAULT_E3B_TIME			50 /* milliseconds */
#define WIN_DEFAULT_DPI				75
d104 2
d108 4
a111 4
#define WIN_SERVER_NONE		0x0L	/* 0 */
#define WIN_SERVER_SHADOW_GDI	0x1L	/* 1 */
#define WIN_SERVER_SHADOW_DD	0x2L	/* 2 */
#define WIN_SERVER_SHADOW_DDNL	0x4L	/* 4 */
d113 1
a113 1
#define WIN_SERVER_PRIMARY_DD	0x8L	/* 8 */
d116 1
a116 1
# define WIN_SERVER_NATIVE_GDI	0x10L	/* 16 */
d147 1
a147 1
#ifdef HAS_MMAP
d151 2
a152 2
#endif /* MAP_FILE */
#endif /* HAS_MMAP */
a195 1

a203 1

a207 1

a251 1

d270 1
a270 1
typedef Bool (*winAllocateFBProcPtr)(ScreenPtr);
d272 1
a272 1
typedef void (*winFreeFBProcPtr)(ScreenPtr);
d274 1
a274 1
typedef void (*winShadowUpdateProcPtr)(ScreenPtr, shadowBufPtr);
d276 1
a276 1
typedef Bool (*winInitScreenProcPtr)(ScreenPtr);
d278 1
a278 1
typedef Bool (*winCloseScreenProcPtr)(int, ScreenPtr);
d280 1
a280 1
typedef Bool (*winInitVisualsProcPtr)(ScreenPtr);
d282 1
a282 1
typedef Bool (*winAdjustVideoModeProcPtr)(ScreenPtr);
d284 1
a284 1
typedef Bool (*winCreateBoundingWindowProcPtr)(ScreenPtr);
d286 1
a286 1
typedef Bool (*winFinishScreenInitProcPtr)(int, ScreenPtr, int, char **);
d288 1
a288 1
typedef Bool (*winBltExposedRegionsProcPtr)(ScreenPtr);
d290 1
a290 1
typedef Bool (*winActivateAppProcPtr)(ScreenPtr);
d292 1
a292 1
typedef Bool (*winRedrawScreenProcPtr)(ScreenPtr pScreen);
d294 1
a294 1
typedef Bool (*winRealizeInstalledPaletteProcPtr)(ScreenPtr pScreen);
d296 1
a296 1
typedef Bool (*winInstallColormapProcPtr)(ColormapPtr pColormap);
d298 2
a299 2
typedef Bool (*winStoreColorsProcPtr)(ColormapPtr pmap, 
				      int ndef, xColorItem *pdefs);
d301 1
a301 1
typedef Bool (*winCreateColormapProcPtr)(ColormapPtr pColormap);
d303 1
a303 1
typedef Bool (*winDestroyColormapProcPtr)(ColormapPtr pColormap);
d305 1
a305 1
typedef Bool (*winHotKeyAltTabProcPtr)(ScreenPtr);
d307 1
a307 1
typedef Bool (*winCreatePrimarySurfaceProcPtr)(ScreenPtr);
d309 1
a309 1
typedef Bool (*winReleasePrimarySurfaceProcPtr)(ScreenPtr);
d311 1
a311 1
typedef Bool (*winFinishCreateWindowsWindowProcPtr)(WindowPtr pWin);
d313 1
a313 1
typedef Bool (*winCreateScreenResourcesProc)(ScreenPtr);
d318 1
a318 1
typedef Bool (*UnrealizeFontPtr)(ScreenPtr pScreen, FontPtr pFont);
a320 1

d325 3
a327 4
typedef struct
{
  HDC			hdc;
  HDC			hdcMem;
a329 1

d334 6
a339 7
typedef struct
{
  HDC			hdcSelected;
  HBITMAP		hBitmap;
  BYTE			*pbBits;
  DWORD			dwScanlineBytes;
  BITMAPINFOHEADER	*pbmih;
a341 1

d346 5
a350 6
typedef struct
{
  HPALETTE		hPalette;
  LPDIRECTDRAWPALETTE	lpDDPalette;
  RGBQUAD		rgbColors[WIN_NUM_PALETTE_ENTRIES];
  PALETTEENTRY		peColors[WIN_NUM_PALETTE_ENTRIES];
d355 2
a356 2
 */ 
  
d358 8
a365 8
  /* from GetSystemMetrics */
  int sm_cx;
  int sm_cy;

  BOOL visible;
  HCURSOR handle;
  QueryBestSizeProcPtr QueryBestSize;
  miPointerSpriteFuncPtr spriteFuncs;
d372 3
a374 3
  notAllowed,
  resizeWithScrollbars,
  resizeWithRandr
d382 38
a419 39
typedef struct
{
  ScreenPtr		pScreen;
  
  /* Did the user specify a height and width? */
  Bool			fUserGaveHeightAndWidth;

  DWORD			dwScreen;

  int			iMonitor;
  DWORD			dwUserWidth;
  DWORD			dwUserHeight;
  DWORD			dwWidth;
  DWORD			dwHeight;
  DWORD			dwPaddedWidth;

  /* Did the user specify a screen position? */
  Bool			fUserGavePosition;
  DWORD                 dwInitialX;
  DWORD                 dwInitialY;

  /*
   * dwStride is the number of whole pixels that occupy a scanline,
   * including those pixels that are not displayed.  This is basically
   * a rounding up of the width.
   */
  DWORD			dwStride;

  /* Offset of the screen in the window when using scrollbars */
  DWORD			dwXOffset;
  DWORD			dwYOffset;

  DWORD			dwBPP;
  DWORD			dwDepth;
  DWORD			dwRefreshRate;
  char			*pfb;
  DWORD			dwEngine;
  DWORD			dwEnginePreferred;
  DWORD			dwClipUpdatesNBoxes;
d421 1
a421 1
  Bool			fEmulatePseudo;
d423 2
a424 2
  Bool			fFullScreen;
  Bool			fDecoration;
d426 3
a428 3
  Bool			fMWExtWM;
  Bool			fInternalWM;
  Bool			fAnotherWMRunning;
d430 1
a430 1
  Bool			fRootless;
d432 1
a432 1
  Bool			fMultiWindow;
d435 1
a435 1
  Bool			fMultiMonitorOverride;
d437 9
a445 9
  Bool                  fMultipleMonitors;
  Bool			fLessPointer;
  winResizeMode		iResizeMode;
  Bool			fNoTrayIcon;
  int			iE3BTimeout;
  /* Windows (Alt+F4) and Unix (Ctrl+Alt+Backspace) Killkey */
  Bool                  fUseWinKillKey;
  Bool                  fUseUnixKillKey;
  Bool			fIgnoreInput;
d447 2
a448 2
  /* Did the user explicitly set this screen? */
  Bool			fExplicitScreen;
a450 1

d455 29
a483 61
typedef struct _winPrivScreenRec
{
  winScreenInfoPtr	pScreenInfo;

  Bool			fEnabled;
  Bool			fClosed;
  Bool			fActive;
  Bool			fBadDepth;

  int			iDeltaZ;

  int			iConnectedClients;

  CloseScreenProcPtr	CloseScreen;

  DWORD			dwRedMask;
  DWORD			dwGreenMask;
  DWORD			dwBlueMask;
  DWORD			dwBitsPerRGB;

  DWORD			dwModeKeyStates;

  /* Handle to icons that must be freed */
  HICON			hiconNotifyIcon;

  /* Palette management */
  ColormapPtr		pcmapInstalled;

  /* Pointer to the root visual so we only have to look it up once */
  VisualPtr		pRootVisual;

  /* 3 button emulation variables */
  int			iE3BCachedPress;
  Bool			fE3BFakeButton2Sent;

  /* Privates used by shadow fb GDI server */
  HBITMAP		hbmpShadow;
  HDC			hdcScreen;
  HDC			hdcShadow;
  HWND			hwndScreen;
  BITMAPINFOHEADER      *pbmih;

  /* Privates used by shadow fb and primary fb DirectDraw servers */
  LPDIRECTDRAW		pdd;
  LPDIRECTDRAWSURFACE2	pddsPrimary;
  LPDIRECTDRAW2		pdd2;

  /* Privates used by shadow fb DirectDraw server */
  LPDIRECTDRAWSURFACE2	pddsShadow;
  LPDDSURFACEDESC	pddsdShadow;

  /* Privates used by primary fb DirectDraw server */
  LPDIRECTDRAWSURFACE2	pddsOffscreen;
  LPDDSURFACEDESC	pddsdOffscreen;
  LPDDSURFACEDESC	pddsdPrimary;

  /* Privates used by shadow fb DirectDraw Nonlocking server */
  LPDIRECTDRAW4		pdd4;
  LPDIRECTDRAWSURFACE4	pddsShadow4;
  LPDIRECTDRAWSURFACE4	pddsPrimary4;
  BOOL			fRetryCreateSurface;
d485 33
a517 2
  /* Privates used by both shadow fb DirectDraw servers */
  LPDIRECTDRAWCLIPPER	pddcPrimary;
d520 3
a522 3
  /* Privates used by multi-window external window manager */
  RootlessFrameID	widTop;
  Bool			fRestacking;
d526 4
a529 4
  /* Privates used by multi-window */
  pthread_t		ptWMProc;
  pthread_t		ptXMsgProc;
  void			*pWMInfo;
d533 2
a534 2
  /* Privates used by both multi-window and rootless */
  Bool			fRootWindowShown;
d538 26
a563 26
  /* Privates used for any module running in a seperate thread */
  pthread_mutex_t	pmServerStarted;
  Bool			fServerStarted;
#endif
  
  /* Engine specific functions */
  winAllocateFBProcPtr			pwinAllocateFB;
  winFreeFBProcPtr			pwinFreeFB;
  winShadowUpdateProcPtr		pwinShadowUpdate;
  winInitScreenProcPtr			pwinInitScreen;
  winCloseScreenProcPtr			pwinCloseScreen;
  winInitVisualsProcPtr			pwinInitVisuals;
  winAdjustVideoModeProcPtr		pwinAdjustVideoMode;
  winCreateBoundingWindowProcPtr	pwinCreateBoundingWindow;
  winFinishScreenInitProcPtr		pwinFinishScreenInit;
  winBltExposedRegionsProcPtr		pwinBltExposedRegions;
  winActivateAppProcPtr			pwinActivateApp;
  winRedrawScreenProcPtr		pwinRedrawScreen;
  winRealizeInstalledPaletteProcPtr	pwinRealizeInstalledPalette;
  winInstallColormapProcPtr		pwinInstallColormap;
  winStoreColorsProcPtr			pwinStoreColors;
  winCreateColormapProcPtr		pwinCreateColormap;
  winDestroyColormapProcPtr		pwinDestroyColormap;
  winHotKeyAltTabProcPtr		pwinHotKeyAltTab;
  winCreatePrimarySurfaceProcPtr	pwinCreatePrimarySurface;
  winReleasePrimarySurfaceProcPtr	pwinReleasePrimarySurface;
d565 1
a565 1
  winCreateScreenResourcesProc       pwinCreateScreenResources;
d568 2
a569 2
  /* Window Procedures for MultiWindow mode */
  winFinishCreateWindowsWindowProcPtr	pwinFinishCreateWindowsWindow;
d572 18
a589 18
  /* Window Procedures for Rootless mode */
  CreateWindowProcPtr			CreateWindow;
  DestroyWindowProcPtr			DestroyWindow;
  PositionWindowProcPtr			PositionWindow;
  ChangeWindowAttributesProcPtr		ChangeWindowAttributes;
  RealizeWindowProcPtr			RealizeWindow;
  UnrealizeWindowProcPtr		UnrealizeWindow;
  ValidateTreeProcPtr			ValidateTree;
  PostValidateTreeProcPtr		PostValidateTree;
  WindowExposuresProcPtr		WindowExposures;
  CopyWindowProcPtr			CopyWindow;
  ClearToBackgroundProcPtr		ClearToBackground;
  ClipNotifyProcPtr			ClipNotify;
  RestackWindowProcPtr			RestackWindow;
  ReparentWindowProcPtr			ReparentWindow;
  ResizeWindowProcPtr			ResizeWindow;
  MoveWindowProcPtr			MoveWindow;
  SetShapeProcPtr			SetShape;
d591 1
a591 1
  winCursorRec                          cursor;
d594 2
a595 2
  RealizeFontPtr                        RealizeFont;
  UnrealizeFontPtr                      UnrealizeFont;
a599 1

d602 13
a614 13
  RootlessWindowPtr	pFrame;
  HWND			hWnd;
  int			dwWidthBytes;
  BITMAPINFOHEADER	*pbmihShadow;
  HBITMAP		hbmpShadow;
  HDC			hdcShadow;
  HDC			hdcScreen;
  BOOL			fResized;
  BOOL			fRestackingNow;
  BOOL			fClose;
  BOOL			fMovingOrSizing;
  BOOL			fDestroyed;//for debug
  char			*pfb;
a617 1

d619 2
a620 2
  pointer		value;
  XID			id;
a622 1

d629 4
a632 3
extern winScreenInfo *		g_ScreenInfo;
extern miPointerScreenFuncRec	g_winPointerCursorFuncs;
extern DWORD			g_dwEvents;
d634 1
a634 1
extern int			g_fdMessageQueue;
d636 2
a637 1
extern DevPrivateKeyRec		g_iScreenPrivateKeyRec;
d639 2
a640 1
extern DevPrivateKeyRec		g_iCmapPrivateKeyRec;
d642 2
a643 1
extern DevPrivateKeyRec		g_iGCPrivateKeyRec;
d645 2
a646 1
extern DevPrivateKeyRec		g_iPixmapPrivateKeyRec;
d648 2
a649 1
extern DevPrivateKeyRec		g_iWindowPrivateKeyRec;
d652 8
a659 8
extern unsigned long		g_ulServerGeneration;
extern DWORD			g_dwEnginesSupported;
extern HINSTANCE		g_hInstance;
extern int                      g_copyROP[];
extern int                      g_patternROP[];
extern const char *		g_pszQueryHost;
extern DeviceIntPtr             g_pwinPointer;
extern DeviceIntPtr             g_pwinKeyboard;
d665 2
a666 4
extern FARPROC			g_fpDirectDrawCreate;
extern FARPROC			g_fpDirectDrawCreateClipper;
extern FARPROC			g_fpTrackMouseEvent;

a680 1

a693 1

a706 1

a719 1

d745 1
a745 1
#define WIN_WRAP(mem, func) _WIN_WRAP(pScreenPriv, pScreen, mem, func) 
a752 1

d758 1
a758 1
winAllocatePrivates (ScreenPtr pScreen);
d761 1
a761 1
winInitCmapPrivates (ColormapPtr pCmap, int index);
d764 1
a764 2
winAllocateCmapPrivates (ColormapPtr pCmap);

d772 1
a772 1
winGenerateAuthorization (void);
a775 1

a780 4
winBlockHandler (int nScreen,
		 pointer pBlockData,
		 pointer pTimeout,
		 pointer pReadMask);
d782 2
d791 1
a791 1
winPixmapToRegionNativeGDI (PixmapPtr pPix);
a793 1

d800 1
a800 1
winInitClipboard (void);
d803 1
a803 1
winFixClipboardChain (void);
a805 1

d811 1
a811 1
winSetColormapFunctions (ScreenPtr pScreen);
d814 1
a814 2
winCreateDefColormap (ScreenPtr pScreen);

d821 1
a821 1
winCreateBoundingWindowFullScreen (ScreenPtr pScreen);
d824 1
a824 2
winCreateBoundingWindowWindowed (ScreenPtr pScreen);

d831 1
a831 1
winDisplayExitDialog (winPrivScreenPtr pScreenPriv);
d834 1
a834 1
winDisplayDepthChangeDialog (winPrivScreenPtr pScreenPriv);
d837 1
a837 2
winDisplayAboutDialog (winPrivScreenPtr pScreenPriv);

d844 1
a844 1
winDetectSupportedEngines (void);
d847 1
a847 1
winSetEngine (ScreenPtr pScreen);
d850 1
a850 1
winGetDDProcAddresses (void);
d853 1
a853 2
winReleaseDDProcAddresses(void);

d861 1
a861 1
OSVenderVErrorF (const char *pszFormat, va_list va_args);
d865 1
a865 2
winMessageBoxF (const char *pszError, UINT uType, ...);

d873 5
a877 6
winFillSpansNativeGDI (DrawablePtr	pDrawable,
		       GCPtr		pGC,
		       int		nSpans,
		       DDXPointPtr	pPoints,
		       int		*pWidths,
		       int		fSorted);
a879 1

d886 1
a886 1
winRealizeFontNativeGDI (ScreenPtr pScreen, FontPtr pFont);
d889 1
a889 1
winUnrealizeFontNativeGDI (ScreenPtr pScreen, FontPtr pFont);
a891 1

d898 1
a898 1
winCreateGCNativeGDI (GCPtr pGC);
a900 1

d907 4
a910 6
winGetSpansNativeGDI (DrawablePtr	pDrawable, 
		      int		wMax, 
		      DDXPointPtr	pPoints, 
		      int		*pWidths, 
		      int		nSpans, 
		      char		*pDst);
a912 1

d918 1
a918 2
winInitializeGlobals (void);

d925 1
a925 1
winTranslateKey (WPARAM wParam, LPARAM lParam, int *piScanCode);
d928 1
a928 1
winKeybdProc (DeviceIntPtr pDeviceInt, int iState);
d931 1
a931 1
winInitializeModeKeyStates (void);
d934 1
a934 1
winRestoreModeKeyStates (void);
d937 1
a937 1
winIsFakeCtrl_L (UINT message, WPARAM wParam, LPARAM lParam);
d940 1
a940 1
winKeybdReleaseKeys (void);
d943 1
a943 1
winSendKeyEvent (DWORD dwKey, Bool fDown);
d945 1
a945 2
BOOL
winCheckKeyPressed(WPARAM wParam, LPARAM lParam);
d948 1
a948 1
winFixShiftKeys (int iScanCode);
d955 1
a955 1
winInstallKeyboardHookLL (void);
d958 1
a958 2
winRemoveKeyboardHookLL (void);

d966 3
a968 2
winQueryBestSizeNativeGDI (int class, unsigned short *pWidth,
			   unsigned short *pHeight, ScreenPtr pScreen);
d972 1
a972 1
winCountBits (DWORD dw);
d975 1
a975 1
winUpdateFBPointer (ScreenPtr pScreen, void *pbits);
d978 1
a978 2
BOOL
winPaintBackground (HWND hwnd, COLORREF colorref);
a980 1

d986 1
a986 1
winMouseProc (DeviceIntPtr pDeviceInt, int iState);
d989 1
a989 1
winMouseWheel (ScreenPtr pScreen, int iDeltaZ);
d992 1
a992 1
winMouseButtonsSendEvent (int iEventType, int iButton);
d995 3
a997 3
winMouseButtonsHandle (ScreenPtr pScreen,
		       int iEventType, int iButton,
		       WPARAM wParam);
d1000 1
a1000 1
winEnqueueMotion(int x, int y);
d1008 2
a1009 2
winCreateDIBNativeGDI (int iWidth, int iHeight, int iDepth,
		       BYTE **ppbBits, BITMAPINFO **ppbmi);
d1012 1
a1012 1
winSetEngineFunctionsNativeGDI (ScreenPtr pScreen);
a1014 1

d1021 1
a1021 1
winSetEngineFunctionsPrimaryDD (ScreenPtr pScreen);
a1023 1

d1030 3
a1032 2
winCreatePixmapNativeGDI (ScreenPtr pScreen, int width, int height, int depth,
			  unsigned usage_hint);
d1035 1
a1035 1
winDestroyPixmapNativeGDI (PixmapPtr pPixmap);
d1038 6
a1043 6
winModifyPixmapHeaderNativeGDI (PixmapPtr pPixmap,
				int iWidth, int iHeight,
				int iDepth,
				int iBitsPerPixel,
				int devKind,
				pointer pPixData);
d1052 3
a1054 5
winPolyLineNativeGDI (DrawablePtr	pDrawable,
		      GCPtr		pGC,
		      int		mode,
		      int		npt,
		      DDXPointPtr	ppt);
a1056 1

d1063 3
a1065 2
winPushPixels (GCPtr pGC, PixmapPtr pBitMap, DrawablePtr pDrawable,
	       int dx, int dy, int xOrg, int yOrg);
a1067 1

d1073 1
a1073 3
winScreenInit (int index,
	       ScreenPtr pScreen,
	       int argc, char **argv);
d1076 1
a1076 3
winFinishScreenInitFB (int index,
		       ScreenPtr pScreen,
		       int argc, char **argv);
d1080 3
a1082 3
winFinishScreenInitNativeGDI (int index,
			      ScreenPtr pScreen,
			      int argc, char **argv);
a1084 1

d1091 5
a1095 7
winSetSpansNativeGDI (DrawablePtr	pDrawable,
		      GCPtr		pGC,
		      char		*pSrc,
		      DDXPointPtr	pPoints,
		      int		*pWidth,
		      int		nSpans,
		      int		fSorted);
a1097 1

d1103 1
a1103 2
winSetEngineFunctionsShadowDD (ScreenPtr pScreen);

d1110 1
a1110 2
winSetEngineFunctionsShadowDDNL (ScreenPtr pScreen);

d1117 1
a1117 2
winSetEngineFunctionsShadowGDI (ScreenPtr pScreen);

a1123 4
winWakeupHandler (int nScreen,
		  pointer pWakeupData,
		  unsigned long ulResult,
		  pointer pReadmask);
d1125 3
d1135 1
a1135 1
winCreateWindowNativeGDI (WindowPtr pWin);
d1138 1
a1138 1
winDestroyWindowNativeGDI (WindowPtr pWin);
d1141 3
a1143 1
winPositionWindowNativeGDI (WindowPtr pWin, int x, int y);
d1145 1
a1145 4
void 
winCopyWindowNativeGDI (WindowPtr pWin,
			DDXPointRec ptOldOrg,
			RegionPtr prgnSrc);
d1148 1
a1148 1
winChangeWindowAttributesNativeGDI (WindowPtr pWin, unsigned long mask);
d1151 1
a1151 1
winUnmapWindowNativeGDI (WindowPtr pWindow);
d1154 1
a1154 1
winMapWindowNativeGDI (WindowPtr pWindow);
d1158 1
a1158 1
winCreateWindowRootless (WindowPtr pWindow);
d1161 1
a1161 1
winDestroyWindowRootless (WindowPtr pWindow);
d1164 1
a1164 1
winPositionWindowRootless (WindowPtr pWindow, int x, int y);
d1167 1
a1167 1
winChangeWindowAttributesRootless (WindowPtr pWindow, unsigned long mask);
d1170 1
a1170 1
winUnmapWindowRootless (WindowPtr pWindow);
d1173 1
a1173 1
winMapWindowRootless (WindowPtr pWindow);
d1176 1
a1176 2
winSetShapeRootless (WindowPtr pWindow, int kind);

d1182 1
a1182 2
HICON
winXIconToHICON (WindowPtr pWin, int iconSize);
d1185 1
a1185 1
winSelectIcons(WindowPtr pWin, HICON *pIcon, HICON *pSmallIcon);
d1193 1
a1193 1
winReshapeMultiWindow (WindowPtr pWin);
d1196 1
a1196 1
winSetShapeMultiWindow (WindowPtr pWindow, int kind);
d1199 1
a1199 1
winUpdateRgnMultiWindow (WindowPtr pWindow);
a1201 1

d1208 1
a1208 1
winCreateWindowMultiWindow (WindowPtr pWindow);
d1211 1
a1211 1
winDestroyWindowMultiWindow (WindowPtr pWindow);
d1214 1
a1214 1
winPositionWindowMultiWindow (WindowPtr pWindow, int x, int y);
d1217 1
a1217 1
winChangeWindowAttributesMultiWindow (WindowPtr pWindow, unsigned long mask);
d1220 1
a1220 1
winUnmapWindowMultiWindow (WindowPtr pWindow);
d1223 1
a1223 1
winMapWindowMultiWindow (WindowPtr pWindow);
d1226 1
a1226 1
winReparentWindowMultiWindow (WindowPtr pWin, WindowPtr pPriorParent);
d1229 1
a1229 1
winRestackWindowMultiWindow (WindowPtr pWin, WindowPtr pOldNextSib);
d1232 1
a1232 1
winReorderWindowsMultiWindow (void);
d1235 3
a1237 2
winResizeWindowMultiWindow (WindowPtr pWin, int x, int y, unsigned int w,
			    unsigned int h, WindowPtr pSib);
d1239 3
a1241 2
winMoveWindowMultiWindow (WindowPtr pWin, int x, int y,
			  WindowPtr pSib, VTKind kind);
d1244 3
a1246 2
winCopyWindowMultiWindow (WindowPtr pWin, DDXPointRec oldpt,
			  RegionPtr oldRegion);
d1249 1
a1249 1
winGetWindowID (WindowPtr pWin);
d1252 1
a1252 1
winAdjustXWindow (WindowPtr pWin, HWND hwnd);
a1254 1

d1261 1
a1261 2
winTopLevelWindowProc (HWND hwnd, UINT message, 
		       WPARAM wParam, LPARAM lParam);
a1263 1

d1269 1
a1269 1
winInitNotifyIcon (winPrivScreenPtr pScreenPriv);
d1272 1
a1272 1
winDeleteNotifyIcon (winPrivScreenPtr pScreenPriv);
d1275 3
a1277 4
winHandleIconMessage (HWND hwnd, UINT message,
		      WPARAM wParam, LPARAM lParam,
		      winPrivScreenPtr pScreenPriv);

d1284 1
a1284 3
winWindowProc (HWND hWnd, UINT message, 
	       WPARAM wParam, LPARAM lParam);

d1292 3
a1294 2
winMWExtWMCreateFrame (RootlessWindowPtr pFrame, ScreenPtr pScreen,
			     int newX, int newY, RegionPtr pShape);
d1297 1
a1297 1
winMWExtWMDestroyFrame (RootlessFrameID wid);
d1300 2
a1301 1
winMWExtWMMoveFrame (RootlessFrameID wid, ScreenPtr pScreen, int newX, int newY);
d1304 4
a1307 3
winMWExtWMResizeFrame (RootlessFrameID wid, ScreenPtr pScreen,
			     int newX, int newY, unsigned int newW, unsigned int newH,
			     unsigned int gravity);
d1310 1
a1310 1
winMWExtWMRestackFrame (RootlessFrameID wid, RootlessFrameID nextWid);
d1313 1
a1313 1
winMWExtWMReshapeFrame (RootlessFrameID wid, RegionPtr pShape);
d1316 1
a1316 1
winMWExtWMUnmapFrame (RootlessFrameID wid);
d1319 2
a1320 1
winMWExtWMStartDrawing (RootlessFrameID wid, char **pixelData, int *bytesPerRow);
d1323 1
a1323 1
winMWExtWMStopDrawing (RootlessFrameID wid, Bool flush);
d1326 1
a1326 1
winMWExtWMUpdateRegion (RootlessFrameID wid, RegionPtr pDamage);
d1329 3
a1331 2
winMWExtWMDamageRects (RootlessFrameID wid, int count, const BoxRec *rects,
			     int shift_x, int shift_y);
d1334 1
a1334 1
winMWExtWMRootlessSwitchWindow (RootlessWindowPtr pFrame, WindowPtr oldWin);
d1337 4
a1340 3
winMWExtWMCopyBytes (unsigned int width, unsigned int height,
			   const void *src, unsigned int srcRowBytes,
			   void *dst, unsigned int dstRowBytes);
d1343 3
a1345 2
winMWExtWMCopyWindow (RootlessFrameID wid, int dstNrects, const BoxRec *dstRects,
			    int dx, int dy);
a1347 1

d1354 1
a1354 1
winMWExtWMReorderWindows (ScreenPtr pScreen);
d1357 1
a1357 1
winMWExtWMMoveXWindow (WindowPtr pWin, int x, int y);
d1360 1
a1360 1
winMWExtWMResizeXWindow (WindowPtr pWin, int w, int h);
d1363 1
a1363 1
winMWExtWMMoveResizeXWindow (WindowPtr pWin, int x, int y, int w, int h);
d1366 1
a1366 1
winMWExtWMUpdateIcon (Window id);
a1368 2
winMWExtWMUpdateWindowDecoration (win32RootlessWindowPtr pRLWinPriv,
				  winScreenInfoPtr pScreenInfo);
d1370 4
a1373 2
wBOOL CALLBACK
winMWExtWMDecorateWindow (HWND hwnd, LPARAM lParam);
d1376 1
a1376 1
winIsInternalWMRunning (winScreenInfoPtr pScreenInfo);
d1379 1
a1379 1
winMWExtWMRestackWindows (ScreenPtr pScreen);
a1381 1

d1388 1
a1388 2
winMWExtWMWindowProc (HWND hwnd, UINT message, 
			    WPARAM wParam, LPARAM lParam);
a1390 1

d1396 3
a1398 2
winWindowsWMSendEvent (int type, unsigned int mask, int which, int arg,
		       Window window, int x, int y, int w, int h);
d1401 1
a1401 1
winWindowsWMExtensionInit (void);
d1408 1
a1408 1
winInitCursor (ScreenPtr pScreen);
d1414 1
a1414 1
winInitializeScreens(int maxscreens);
d1420 1
a1420 1
winRandRInit (ScreenPtr pScreen);
d1422 4
a1425 5
winDoRandRScreenSetSize (ScreenPtr  pScreen,
                         CARD16	    width,
                         CARD16	    height,
                         CARD32	    mmWidth,
                         CARD32	    mmHeight);
d1431 1
a1431 2
#endif /* _WIN_H_ */

@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a76 3
#define WIN_DIB_MAXIMUM_SIZE	0x08000000 /* 16 MB on Windows 95, 98, Me */
#define WIN_DIB_MAXIMUM_SIZE_MB (WIN_DIB_MAXIMUM_SIZE / 8 / 1024 / 1024)

a174 1
#include "mibstore.h"
d220 4
a223 3
  pszTemp = Xprintf (str, ##__VA_ARGS__); \
  MessageBox (NULL, pszTemp, szFunctionName, MB_OK); \
  free(pszTemp); \
d275 2
d279 2
d318 5
a322 2
/* Typedef for DIX wrapper functions */
typedef int (*winDispatchProcPtr) (ClientPtr);
d378 9
d399 2
a404 2
  DWORD			dwWidth_mm;
  DWORD			dwHeight_mm;
d449 1
a449 1
  Bool			fScrollbars;
a490 5
  /* Last width, height, and depth of the Windows display */
  DWORD			dwLastWindowsWidth;
  DWORD			dwLastWindowsHeight;
  DWORD			dwLastWindowsBitsPixel;

d506 2
a507 1
  
d557 1
d559 1
d604 6
d642 2
a669 1

d671 1
a671 1
 * Extern declares for dynamically loaded libraries and function pointers
a673 1
extern HMODULE			g_hmodDirectDraw;
a675 2

extern HMODULE			g_hmodCommonControls;
d877 3
a1397 10
winMWExtWMFillBytes (unsigned int width, unsigned int height, unsigned int value,
			   void *dst, unsigned int dstRowBytes);

int
winMWExtWMCompositePixels (unsigned int width, unsigned int height, unsigned int function,
				 void *src[2], unsigned int srcRowBytes[2],
				 void *mask, unsigned int maskRowBytes,
				 void *dst[2], unsigned int dstRowBytes[2]);

void
d1472 12
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a185 1
#ifdef RENDER
a187 1
#endif
d226 1
a226 1
  xfree (pszTemp); \
d625 1
a625 1
extern winScreenInfo		g_ScreenInfo[];
d631 11
a641 5
extern DevPrivateKey		g_iScreenPrivateKey;
extern DevPrivateKey		g_iCmapPrivateKey;
extern DevPrivateKey		g_iGCPrivateKey;
extern DevPrivateKey		g_iPixmapPrivateKey;
extern DevPrivateKey		g_iWindowPrivateKey;
d1213 1
a1213 1
winSetShapeRootless (WindowPtr pWindow);
d1235 1
a1235 1
winSetShapeMultiWindow (WindowPtr pWindow);
d1458 6
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a60 1
#define NEED_EVENTS
d105 1
d199 1
a199 1
#include "./winresource.h"
d317 1
d568 2
a638 1
extern CARD32			g_c32LastInputEventTime;
d644 2
a768 1
# if defined(XCSECURITY)  
d771 1
a771 1
# endif
d958 5
d1015 3
d1219 2
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a588 1
#ifdef SHAPE
a589 1
#endif
a1196 1
#ifdef SHAPE
a1198 1
#endif
a1213 1
# ifdef SHAPE
a1221 1
# endif
@


1.1
log
@Initial revision
@
text
@a581 2
  PaintWindowBackgroundProcPtr		PaintWindowBackground;
  PaintWindowBorderProcPtr		PaintWindowBorder;
d632 5
a636 5
extern int			g_iScreenPrivateIndex;
extern int			g_iCmapPrivateIndex;
extern int			g_iGCPrivateIndex;
extern int			g_iPixmapPrivateIndex;
extern int			g_iWindowPrivateIndex;
d662 2
a663 2
#define winGetScreenPriv(pScreen) \
	((winPrivScreenPtr) (pScreen)->devPrivates[g_iScreenPrivateIndex].ptr)
d666 1
a666 1
	((pScreen)->devPrivates[g_iScreenPrivateIndex].ptr = (pointer) v)
d676 2
a677 2
#define winGetCmapPriv(pCmap) \
	((winPrivCmapPtr) (pCmap)->devPrivates[g_iCmapPrivateIndex].ptr)
d680 1
a680 1
	((pCmap)->devPrivates[g_iCmapPrivateIndex].ptr = (pointer) v)
d690 2
a691 2
#define winGetGCPriv(pGC) \
	((winPrivGCPtr) (pGC)->devPrivates[g_iGCPrivateIndex].ptr)
d694 1
a694 1
	((pGC)->devPrivates[g_iGCPrivateIndex].ptr = (pointer) v)
d704 2
a705 2
#define winGetPixmapPriv(pPixmap) \
	((winPrivPixmapPtr) (pPixmap)->devPrivates[g_iPixmapPrivateIndex].ptr)
d708 1
a708 1
	((pPixmap)->devPrivates[g_iPixmapPrivateIndex].ptr = (pointer) v)
d718 2
a719 2
#define winGetWindowPriv(pWin) \
	((winPrivWinPtr) (pWin)->devPrivates[g_iWindowPrivateIndex].ptr)
d722 1
a722 1
	((pWin)->devPrivates[g_iWindowPrivateIndex].ptr = (pointer) v)
d1039 2
a1040 1
winCreatePixmapNativeGDI (ScreenPtr pScreen, int width, int height, int depth);
a1052 11


#ifdef XWIN_NATIVEGDI
/*
 * winpntwin.c
 */

void
winPaintWindowNativeGDI (WindowPtr pWin, RegionPtr pRegion, int what);
#endif

@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
