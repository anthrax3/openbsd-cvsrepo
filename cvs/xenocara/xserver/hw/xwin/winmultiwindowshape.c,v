head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.8
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.6
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.10
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.8
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.37;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Kensuke Matsuzaki
 *		Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif

#include "win.h"

/*
 * winSetShapeMultiWindow - See Porting Layer Definition - p. 42
 */

void
winSetShapeMultiWindow(WindowPtr pWin, int kind)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winScreenPriv(pScreen);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("winSetShapeMultiWindow - pWin: %p kind: %i\n", pWin, kind);
#endif

    WIN_UNWRAP(SetShape);
    (*pScreen->SetShape) (pWin, kind);
    WIN_WRAP(SetShape, winSetShapeMultiWindow);

    /* Update the Windows window's shape */
    winReshapeMultiWindow(pWin);
    winUpdateRgnMultiWindow(pWin);

    return;
}

/*
 * winUpdateRgnMultiWindow - Local function to update a Windows window region
 */

void
winUpdateRgnMultiWindow(WindowPtr pWin)
{
    SetWindowRgn(winGetWindowPriv(pWin)->hWnd,
                 winGetWindowPriv(pWin)->hRgn, TRUE);

    /* The system now owns the region specified by the region handle and will delete it when it is no longer needed. */
    winGetWindowPriv(pWin)->hRgn = NULL;
}

/*
 * winReshapeMultiWindow - Computes the composite clipping region for a window
 */

void
winReshapeMultiWindow(WindowPtr pWin)
{
    int nRects;
    RegionRec rrNewShape;
    BoxPtr pShape, pRects, pEnd;
    HRGN hRgn, hRgnRect;

    winWindowPriv(pWin);

#if CYGDEBUG
    winDebug("winReshape ()\n");
#endif

    /* Bail if the window is the root window */
    if (pWin->parent == NULL)
        return;

    /* Bail if the window is not top level */
    if (pWin->parent->parent != NULL)
        return;

    /* Bail if Windows window handle is invalid */
    if (pWinPriv->hWnd == NULL)
        return;

    /* Free any existing window region stored in the window privates */
    if (pWinPriv->hRgn != NULL) {
        DeleteObject(pWinPriv->hRgn);
        pWinPriv->hRgn = NULL;
    }

    /* Bail if the window has no bounding region defined */
    if (!wBoundingShape(pWin))
        return;

    RegionNull(&rrNewShape);
    RegionCopy(&rrNewShape, wBoundingShape(pWin));
    RegionTranslate(&rrNewShape, pWin->borderWidth, pWin->borderWidth);

    nRects = RegionNumRects(&rrNewShape);
    pShape = RegionRects(&rrNewShape);

    /* Don't do anything if there are no rectangles in the region */
    if (nRects > 0) {
        RECT rcClient;
        RECT rcWindow;
        int iOffsetX, iOffsetY;

        /* Get client rectangle */
        if (!GetClientRect(pWinPriv->hWnd, &rcClient)) {
            ErrorF("winReshape - GetClientRect failed, bailing: %d\n",
                   (int) GetLastError());
            return;
        }

        /* Translate client rectangle coords to screen coords */
        /* NOTE: Only transforms top and left members */
        ClientToScreen(pWinPriv->hWnd, (LPPOINT) &rcClient);

        /* Get window rectangle */
        if (!GetWindowRect(pWinPriv->hWnd, &rcWindow)) {
            ErrorF("winReshape - GetWindowRect failed, bailing: %d\n",
                   (int) GetLastError());
            return;
        }

        /* Calculate offset from window upper-left to client upper-left */
        iOffsetX = rcClient.left - rcWindow.left;
        iOffsetY = rcClient.top - rcWindow.top;

        /* Create initial Windows region for title bar */
        /* FIXME: Mean, nasty, ugly hack!!! */
        hRgn = CreateRectRgn(0, 0, rcWindow.right, iOffsetY);
        if (hRgn == NULL) {
            ErrorF("winReshape - Initial CreateRectRgn (%d, %d, %d, %d) "
                   "failed: %d\n",
                   0, 0, (int) rcWindow.right, iOffsetY, (int) GetLastError());
        }

        /* Loop through all rectangles in the X region */
        for (pRects = pShape, pEnd = pShape + nRects; pRects < pEnd; pRects++) {
            /* Create a Windows region for the X rectangle */
            hRgnRect = CreateRectRgn(pRects->x1 + iOffsetX,
                                     pRects->y1 + iOffsetY,
                                     pRects->x2 + iOffsetX,
                                     pRects->y2 + iOffsetY);
            if (hRgnRect == NULL) {
                ErrorF("winReshape - Loop CreateRectRgn (%d, %d, %d, %d) "
                       "failed: %d\n"
                       "\tx1: %d x2: %d xOff: %d y1: %d y2: %d yOff: %d\n",
                       pRects->x1 + iOffsetX,
                       pRects->y1 + iOffsetY,
                       pRects->x2 + iOffsetX,
                       pRects->y2 + iOffsetY,
                       (int) GetLastError(),
                       pRects->x1, pRects->x2, iOffsetX,
                       pRects->y1, pRects->y2, iOffsetY);
            }

            /* Merge the Windows region with the accumulated region */
            if (CombineRgn(hRgn, hRgn, hRgnRect, RGN_OR) == ERROR) {
                ErrorF("winReshape - CombineRgn () failed: %d\n",
                       (int) GetLastError());
            }

            /* Delete the temporary Windows region */
            DeleteObject(hRgnRect);
        }

        /* Save a handle to the composite region in the window privates */
        pWinPriv->hRgn = hRgn;
    }

    RegionUninit(&rrNewShape);

    return;
}
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d50 1
a50 1
    ErrorF("winSetShapeMultiWindow - pWin: %08x kind: %i\n", pWin, kind);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d140 1
a140 1
        ClientToScreen(pWinPriv->hWnd, (LPPOINT) & rcClient);
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a37 1

d43 1
a43 1
winSetShapeMultiWindow (WindowPtr pWin, int kind)
d45 3
a47 2
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winScreenPriv(pScreen);
d50 1
a50 1
  ErrorF ("winSetShapeMultiWindow - pWin: %08x kind: %i\n", pWin, kind);
a51 8
  
  WIN_UNWRAP(SetShape); 
  (*pScreen->SetShape)(pWin, kind);
  WIN_WRAP(SetShape, winSetShapeMultiWindow);
  
  /* Update the Windows window's shape */
  winReshapeMultiWindow (pWin);
  winUpdateRgnMultiWindow (pWin);
d53 9
a61 1
  return;
a63 1

d69 1
a69 1
winUpdateRgnMultiWindow (WindowPtr pWin)
d71 2
a72 2
  SetWindowRgn (winGetWindowPriv(pWin)->hWnd,
		winGetWindowPriv(pWin)->hRgn, TRUE);
d74 2
a75 2
  /* The system now owns the region specified by the region handle and will delete it when it is no longer needed. */
  winGetWindowPriv(pWin)->hRgn = NULL;
a77 1

d83 1
a83 1
winReshapeMultiWindow (WindowPtr pWin)
d85 6
a90 5
  int		nRects;
  RegionRec	rrNewShape;
  BoxPtr	pShape, pRects, pEnd;
  HRGN		hRgn, hRgnRect;
  winWindowPriv(pWin);
d93 1
a93 1
  winDebug ("winReshape ()\n");
a94 4
  
  /* Bail if the window is the root window */
  if (pWin->parent == NULL)
    return;
d96 52
a147 3
  /* Bail if the window is not top level */
  if (pWin->parent->parent != NULL)
    return;
d149 12
a160 14
  /* Bail if Windows window handle is invalid */
  if (pWinPriv->hWnd == NULL)
    return;
  
  /* Free any existing window region stored in the window privates */
  if (pWinPriv->hRgn != NULL)
    {
      DeleteObject (pWinPriv->hRgn);
      pWinPriv->hRgn = NULL;
    }
  
  /* Bail if the window has no bounding region defined */
  if (!wBoundingShape (pWin))
    return;
d162 25
a186 76
  RegionNull(&rrNewShape);
  RegionCopy(&rrNewShape, wBoundingShape(pWin));
  RegionTranslate(&rrNewShape, pWin->borderWidth, pWin->borderWidth);
  
  nRects = RegionNumRects(&rrNewShape);
  pShape = RegionRects(&rrNewShape);
  
  /* Don't do anything if there are no rectangles in the region */
  if (nRects > 0)
    {
      RECT			rcClient;
      RECT			rcWindow;
      int			iOffsetX, iOffsetY;
      
      /* Get client rectangle */
      if (!GetClientRect (pWinPriv->hWnd, &rcClient))
	{
	  ErrorF ("winReshape - GetClientRect failed, bailing: %d\n",
		  (int) GetLastError ());
	  return;
	}

      /* Translate client rectangle coords to screen coords */
      /* NOTE: Only transforms top and left members */
      ClientToScreen (pWinPriv->hWnd, (LPPOINT) &rcClient);

      /* Get window rectangle */
      if (!GetWindowRect (pWinPriv->hWnd, &rcWindow))
	{
	  ErrorF ("winReshape - GetWindowRect failed, bailing: %d\n",
		  (int) GetLastError ());
	  return;
	}

      /* Calculate offset from window upper-left to client upper-left */
      iOffsetX = rcClient.left - rcWindow.left;
      iOffsetY = rcClient.top - rcWindow.top;

      /* Create initial Windows region for title bar */
      /* FIXME: Mean, nasty, ugly hack!!! */
      hRgn = CreateRectRgn (0, 0, rcWindow.right, iOffsetY);
      if (hRgn == NULL)
	{
	  ErrorF ("winReshape - Initial CreateRectRgn (%d, %d, %d, %d) "
		  "failed: %d\n",
		  0, 0, (int) rcWindow.right, iOffsetY, (int) GetLastError ());
	}

      /* Loop through all rectangles in the X region */
      for (pRects = pShape, pEnd = pShape + nRects; pRects < pEnd; pRects++)
        {
	  /* Create a Windows region for the X rectangle */
	  hRgnRect = CreateRectRgn (pRects->x1 + iOffsetX,
				    pRects->y1 + iOffsetY,
				    pRects->x2 + iOffsetX,
				    pRects->y2 + iOffsetY);
	  if (hRgnRect == NULL)
	    {
	      ErrorF ("winReshape - Loop CreateRectRgn (%d, %d, %d, %d) "
		      "failed: %d\n"
		      "\tx1: %d x2: %d xOff: %d y1: %d y2: %d yOff: %d\n",
		      pRects->x1 + iOffsetX,
		      pRects->y1 + iOffsetY,
		      pRects->x2 + iOffsetX,
		      pRects->y2 + iOffsetY,
		      (int) GetLastError (),
		      pRects->x1, pRects->x2, iOffsetX,
		      pRects->y1, pRects->y2, iOffsetY);
	    }

	  /* Merge the Windows region with the accumulated region */
	  if (CombineRgn (hRgn, hRgn, hRgnRect, RGN_OR) == ERROR)
	    {
	      ErrorF ("winReshape - CombineRgn () failed: %d\n",
		      (int) GetLastError ());
	    }
d188 2
a189 2
	  /* Delete the temporary Windows region */
	  DeleteObject (hRgnRect);
d191 3
a193 3
      
      /* Save a handle to the composite region in the window privates */
      pWinPriv->hRgn = hRgn;
d196 3
a198 3
  RegionUninit(&rrNewShape);
  
  return;
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d44 1
a44 1
winSetShapeMultiWindow (WindowPtr pWin)
d50 1
a50 1
  ErrorF ("winSetShapeMultiWindow - pWin: %08x\n", pWin);
d54 1
a54 1
  (*pScreen->SetShape)(pWin);
d120 3
a122 6
  REGION_NULL(pWin->drawable.pScreen, &rrNewShape);
  REGION_COPY(pWin->drawable.pScreen, &rrNewShape, wBoundingShape(pWin));
  REGION_TRANSLATE(pWin->drawable.pScreen,
		   &rrNewShape,
		   pWin->borderWidth,
                   pWin->borderWidth);
d124 2
a125 2
  nRects = REGION_NUM_RECTS(&rrNewShape);
  pShape = REGION_RECTS(&rrNewShape);
d205 1
a205 1
  REGION_UNINIT(pWin->drawable.pScreen, &rrNewShape);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a46 1
  winWindowPriv(pWin);
d74 3
@


1.1
log
@Initial revision
@
text
@a34 1
#ifdef SHAPE
a209 1
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
