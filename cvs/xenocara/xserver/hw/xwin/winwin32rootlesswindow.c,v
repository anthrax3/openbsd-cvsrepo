head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.10
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.8
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Kensuke Matsuzaki
 *		Earle F. Philhower, III
 *		Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include "winprefs.h"

#if 0
/*
 * winMWExtWMReorderWindows
 */

void
winMWExtWMReorderWindows(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    HWND hwnd = NULL;
    win32RootlessWindowPtr pRLWin = NULL;
    win32RootlessWindowPtr pRLWinSib = NULL;
    DWORD dwCurrentProcessID = GetCurrentProcessId();
    DWORD dwWindowProcessID = 0;
    XID vlist[2];

#if CYGMULTIWINDOW_DEBUG && FALSE
    winDebug("winMWExtWMReorderWindows\n");
#endif

    pScreenPriv->fRestacking = TRUE;

    if (pScreenPriv->fWindowOrderChanged) {
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMReorderWindows - Need to restack\n");
#endif
        hwnd = GetTopWindow(NULL);

        while (hwnd) {
            GetWindowThreadProcessId(hwnd, &dwWindowProcessID);

            if ((dwWindowProcessID == dwCurrentProcessID)
                && GetProp(hwnd, WIN_WINDOW_PROP)) {
                pRLWinSib = pRLWin;
                pRLWin =
                    (win32RootlessWindowPtr) GetProp(hwnd, WIN_WINDOW_PROP);

                if (pRLWinSib) {
                    vlist[0] = pRLWinSib->pFrame->win->drawable.id;
                    vlist[1] = Below;

                    ConfigureWindow(pRLWin->pFrame->win,
                                    CWSibling | CWStackMode, vlist,
                                    wClient(pRLWin->pFrame->win));
                }
                else {
                    /* 1st window - raise to the top */
                    vlist[0] = Above;

                    ConfigureWindow(pRLWin->pFrame->win, CWStackMode,
                                    vlist, wClient(pRLWin->pFrame->win));
                }
            }
            hwnd = GetNextWindow(hwnd, GW_HWNDNEXT);
        }
    }

    pScreenPriv->fRestacking = FALSE;
    pScreenPriv->fWindowOrderChanged = FALSE;
}
#endif

/*
 * winMWExtWMMoveXWindow
 */

void
winMWExtWMMoveXWindow(WindowPtr pWin, int x, int y)
{
    CARD32 *vlist = malloc(sizeof(CARD32) * 2);

    vlist[0] = x;
    vlist[1] = y;
    ConfigureWindow(pWin, CWX | CWY, vlist, wClient(pWin));
    free(vlist);
}

/*
 * winMWExtWMResizeXWindow
 */

void
winMWExtWMResizeXWindow(WindowPtr pWin, int w, int h)
{
    CARD32 *vlist = malloc(sizeof(CARD32) * 2);

    vlist[0] = w;
    vlist[1] = h;
    ConfigureWindow(pWin, CWWidth | CWHeight, vlist, wClient(pWin));
    free(vlist);
}

/*
 * winMWExtWMMoveResizeXWindow
 */

void
winMWExtWMMoveResizeXWindow(WindowPtr pWin, int x, int y, int w, int h)
{
    CARD32 *vlist = malloc(sizeof(long) * 4);

    vlist[0] = x;
    vlist[1] = y;
    vlist[2] = w;
    vlist[3] = h;

    ConfigureWindow(pWin, CWX | CWY | CWWidth | CWHeight, vlist, wClient(pWin));
    free(vlist);
}

/*


 * winMWExtWMDecorateWindow - Update window style. Called by EnumWindows.
 */

wBOOL CALLBACK
winMWExtWMDecorateWindow(HWND hwnd, LPARAM lParam)
{
    win32RootlessWindowPtr pRLWinPriv = NULL;
    ScreenPtr pScreen = NULL;
    winPrivScreenPtr pScreenPriv = NULL;
    winScreenInfo *pScreenInfo = NULL;

    /* Check if the Windows window property for our X window pointer is valid */
    if ((pRLWinPriv =
         (win32RootlessWindowPtr) GetProp(hwnd, WIN_WINDOW_PROP)) != NULL) {
        if (pRLWinPriv != NULL && pRLWinPriv->pFrame != NULL &&
            pRLWinPriv->pFrame->win != NULL)
            pScreen = pRLWinPriv->pFrame->win->drawable.pScreen;
        if (pScreen)
            pScreenPriv = winGetScreenPriv(pScreen);
        if (pScreenPriv)
            pScreenInfo = pScreenPriv->pScreenInfo;
        if (pRLWinPriv && pScreenInfo)
            winMWExtWMUpdateWindowDecoration(pRLWinPriv, pScreenInfo);
    }
    return TRUE;
}

/*
 * winMWExtWMUpdateWindowDecoration - Update window style.
 */

void
winMWExtWMUpdateWindowDecoration(win32RootlessWindowPtr pRLWinPriv,
                                 winScreenInfoPtr pScreenInfo)
{
    Bool fDecorate = FALSE;
    DWORD dwExStyle = 0;
    WINDOWPLACEMENT wndPlace;
    UINT showCmd = 0;

    wndPlace.length = sizeof(WINDOWPLACEMENT);

    /* Get current window placement */
    GetWindowPlacement(pRLWinPriv->hWnd, &wndPlace);

    if (winIsInternalWMRunning(pScreenInfo)) {
        if (!pRLWinPriv->pFrame->win->overrideRedirect)
            fDecorate = TRUE;
    }
#if 0
    if (wndPlace.showCmd == SW_HIDE)
        return;                 //showCmd = SWP_HIDEWINDOW;
    else
        showCmd = SWP_SHOWWINDOW;
#else
    if (wndPlace.showCmd == SW_HIDE)
        return;

    if (IsWindowVisible(pRLWinPriv->hWnd))
        showCmd = SWP_SHOWWINDOW;
#endif

    showCmd |= SWP_NOMOVE | SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOZORDER;

    winDebug("winMWExtWMUpdateWindowDecoration %p %s\n",
             pRLWinPriv, fDecorate ? "Decorate" : "Bare");

    /* Get the extended window style information */
    dwExStyle = GetWindowLongPtr(pRLWinPriv->hWnd, GWL_EXSTYLE);

    if (fDecorate) {
        RECT rcNew;
        int iDx, iDy;
        winWMMessageRec wmMsg;

        winScreenPriv(pScreenInfo->pScreen);

        /* */
        if (!(dwExStyle & WS_EX_APPWINDOW)) {
            winDebug("\tBare=>Decorate\n");
            /* Setup a rectangle with the X window position and size */
            SetRect(&rcNew,
                    pRLWinPriv->pFrame->x,
                    pRLWinPriv->pFrame->y,
                    pRLWinPriv->pFrame->x + pRLWinPriv->pFrame->width,
                    pRLWinPriv->pFrame->y + pRLWinPriv->pFrame->height);

#ifdef CYGMULTIWINDOW_DEBUG
            winDebug("\tWindow extend {%d, %d, %d, %d}, {%d, %d}\n",
                     rcNew.left, rcNew.top, rcNew.right, rcNew.bottom,
                     rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
#endif
            /* */
            AdjustWindowRectEx(&rcNew,
                               WS_POPUP | WS_SIZEBOX | WS_OVERLAPPEDWINDOW,
                               FALSE, WS_EX_APPWINDOW);

#ifdef CYGMULTIWINDOW_DEBUG
            winDebug("\tAdjusted {%d, %d, %d, %d}, {%d, %d}\n",
                     rcNew.left, rcNew.top, rcNew.right, rcNew.bottom,
                     rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
#endif
            /* Calculate position deltas */
            iDx = pRLWinPriv->pFrame->x - rcNew.left;
            iDy = pRLWinPriv->pFrame->y - rcNew.top;

            /* Calculate new rectangle */
            rcNew.left += iDx;
            rcNew.right += iDx;
            rcNew.top += iDy;
            rcNew.bottom += iDy;

            /* Set the window extended style flags */
            SetWindowLongPtr(pRLWinPriv->hWnd, GWL_EXSTYLE, WS_EX_APPWINDOW);

            /* Set the window standard style flags */
            SetWindowLongPtr(pRLWinPriv->hWnd, GWL_STYLE,
                             WS_POPUP | WS_SIZEBOX | WS_OVERLAPPEDWINDOW);

#ifdef CYGMULTIWINDOW_DEBUG
            winDebug("\tWindowStyle: %08x %08x\n",
                     WS_POPUP | WS_SIZEBOX | WS_OVERLAPPEDWINDOW,
                     WS_EX_APPWINDOW);
#endif
            /* Position the Windows window */
#ifdef CYGMULTIWINDOW_DEBUG
            winDebug("\tMoved {%d, %d, %d, %d}, {%d, %d}\n",
                     rcNew.left, rcNew.top, rcNew.right, rcNew.bottom,
                     rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
#endif
            SetWindowPos(pRLWinPriv->hWnd, NULL,
                         rcNew.left, rcNew.top,
                         rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
                         showCmd);

            wmMsg.hwndWindow = pRLWinPriv->hWnd;
            wmMsg.iWindow = (Window) pRLWinPriv->pFrame->win->drawable.id;
            wmMsg.msg = WM_WM_NAME_EVENT;
            winSendMessageToWM(pScreenPriv->pWMInfo, &wmMsg);

            winMWExtWMReshapeFrame((RootlessFrameID) pRLWinPriv,
                                   wBoundingShape(pRLWinPriv->pFrame->win));
        }
    }
    else {
        RECT rcNew;

        /* */
        if (dwExStyle & WS_EX_APPWINDOW) {
            winDebug("\tDecorate=>Bare\n");
            /* Setup a rectangle with the X window position and size */
            SetRect(&rcNew,
                    pRLWinPriv->pFrame->x,
                    pRLWinPriv->pFrame->y,
                    pRLWinPriv->pFrame->x + pRLWinPriv->pFrame->width,
                    pRLWinPriv->pFrame->y + pRLWinPriv->pFrame->height);
#if 0
            /* */
            AdjustWindowRectEx(&rcNew,
                               WS_POPUP | WS_CLIPCHILDREN,
                               FALSE, WS_EX_TOOLWINDOW);

            /* Calculate position deltas */
            iDx = pRLWinPriv->pFrame->x - rcNew.left;
            iDy = pRLWinPriv->pFrame->y - rcNew.top;

            /* Calculate new rectangle */
            rcNew.left += iDx;
            rcNew.right += iDx;
            rcNew.top += iDy;
            rcNew.bottom += iDy;
#endif

            /* Hide window temporary to remove from taskbar. */
            ShowWindow(pRLWinPriv->hWnd, SW_HIDE);

            /* Set the window extended style flags */
            SetWindowLongPtr(pRLWinPriv->hWnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW);

            /* Set the window standard style flags */
            SetWindowLongPtr(pRLWinPriv->hWnd, GWL_STYLE,
                             WS_POPUP | WS_CLIPCHILDREN);

            /* Position the Windows window */
            SetWindowPos(pRLWinPriv->hWnd, NULL,
                         rcNew.left, rcNew.top,
                         rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
                         showCmd);

            winMWExtWMReshapeFrame((RootlessFrameID) pRLWinPriv,
                                   wBoundingShape(pRLWinPriv->pFrame->win));
        }
    }
}

/*
 * winIsInternalWMRunning (winScreenInfoPtr pScreenInfo)
 */
Bool
winIsInternalWMRunning(winScreenInfoPtr pScreenInfo)
{
    return pScreenInfo->fInternalWM && !pScreenInfo->fAnotherWMRunning;
}

/*
 * winMWExtWMRestackWindows
 */

void
winMWExtWMRestackWindows(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    WindowPtr pRoot = pScreen->root;
    WindowPtr pWin = NULL;
    WindowPtr pWinPrev = NULL;
    win32RootlessWindowPtr pRLWin = NULL;
    win32RootlessWindowPtr pRLWinPrev = NULL;
    int nWindow = 0;
    HDWP hWinPosInfo = NULL;

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMRestackWindows\n");
#endif

    pScreenPriv->fRestacking = TRUE;

    if (pRoot != NULL) {
        for (pWin = pRoot->firstChild; pWin; pWin = pWin->nextSib)
            nWindow++;

        hWinPosInfo = BeginDeferWindowPos(nWindow);

        for (pWin = pRoot->firstChild; pWin; pWin = pWin->nextSib) {
            if (pWin->realized) {
                UINT uFlags;

                pRLWin =
                    (win32RootlessWindowPtr) RootlessFrameForWindow(pWin,
                                                                    FALSE);
                if (pRLWin == NULL)
                    continue;

                if (pWinPrev)
                    pRLWinPrev =
                        (win32RootlessWindowPtr)
                        RootlessFrameForWindow(pWinPrev, FALSE);

                uFlags = SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW;
                if (pRLWinPrev != NULL)
                    uFlags |= SWP_NOACTIVATE;

#if CYGMULTIWINDOW_DEBUG
                winDebug
                    ("winMWExtWMRestackWindows - DeferWindowPos (%08x, %08x)\n",
                     pRLWin->hWnd, pRLWinPrev ? pRLWinPrev->hWnd : HWND_TOP);
#endif
                hWinPosInfo = DeferWindowPos(hWinPosInfo, pRLWin->hWnd,
                                             pRLWinPrev ? pRLWinPrev->
                                             hWnd : HWND_TOP, 0, 0, 0, 0,
                                             uFlags);
                if (hWinPosInfo == NULL) {
                    ErrorF
                        ("winMWExtWMRestackWindows - DeferWindowPos () failed: %d\n",
                         (int) GetLastError());
                    return;
                }
                pWinPrev = pWin;
            }
        }
        if (!EndDeferWindowPos(hWinPosInfo)) {
            ErrorF
                ("winMWExtWMRestackWindows - EndDeferWindowPos () failed: %d\n",
                 (int) GetLastError());
            return;
        }
    }

#if CYGMULTIWINDOW_DEBUG
    winDebug("winMWExtWMRestackWindows - done\n");
#endif
    pScreenPriv->fRestacking = FALSE;
}
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a188 1
    DWORD dwStyle = 0;
d216 2
a217 2
    winDebug("winMWExtWMUpdateWindowDecoration %08x %s\n",
             (int) pRLWinPriv, fDecorate ? "Decorate" : "Bare");
d219 1
a219 1
    /* Get the standard and extended window style information */
a220 1
    dwStyle = GetWindowLongPtr(pRLWinPriv->hWnd, GWL_STYLE);
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a149 3
 * winMWExtWMUpdateIcon
 * Change the Windows window icon
 */
a150 5
void
winMWExtWMUpdateIcon(Window id)
{
    WindowPtr pWin;
    HICON hIcon, hiconOld;
a151 23
    dixLookupResourceByType((pointer) &pWin, id, RT_WINDOW, NullClient,
                            DixUnknownAccess);
    hIcon = winOverrideIcon((unsigned long) pWin);

    if (!hIcon)
        hIcon = winXIconToHICON(pWin, GetSystemMetrics(SM_CXICON));

    if (hIcon) {
        win32RootlessWindowPtr pRLWinPriv
            = (win32RootlessWindowPtr) RootlessFrameForWindow(pWin, FALSE);

        if (pRLWinPriv->hWnd) {

            hiconOld = (HICON) SendMessage(pRLWinPriv->hWnd,
                                           WM_SETICON, ICON_BIG,
                                           (LPARAM) hIcon);
            winDestroyIcon(hiconOld);
        }
        hIcon = NULL;
    }
}

/*
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d45 1
a45 1
winMWExtWMReorderWindows (ScreenPtr pScreen)
d47 7
a53 7
  winScreenPriv(pScreen);
  HWND hwnd = NULL;
  win32RootlessWindowPtr pRLWin = NULL;
  win32RootlessWindowPtr pRLWinSib = NULL;
  DWORD dwCurrentProcessID = GetCurrentProcessId ();
  DWORD dwWindowProcessID = 0;
  XID vlist[2];
d56 1
a56 1
  winDebug ("winMWExtWMReorderWindows\n");
d59 1
a59 1
  pScreenPriv->fRestacking = TRUE;
d61 1
a61 2
  if (pScreenPriv->fWindowOrderChanged)
    {
d63 1
a63 1
      winDebug ("winMWExtWMReorderWindows - Need to restack\n");
d65 1
a65 1
      hwnd = GetTopWindow (NULL);
d67 27
a93 29
      while (hwnd)
	{
	  GetWindowThreadProcessId (hwnd, &dwWindowProcessID);

	  if ((dwWindowProcessID == dwCurrentProcessID)
	      && GetProp (hwnd, WIN_WINDOW_PROP))
	    {
	      pRLWinSib = pRLWin;
	      pRLWin = (win32RootlessWindowPtr)GetProp (hwnd, WIN_WINDOW_PROP);
	      
	      if (pRLWinSib)
		{
		  vlist[0] = pRLWinSib->pFrame->win->drawable.id;
		  vlist[1] = Below;

		  ConfigureWindow (pRLWin->pFrame->win, CWSibling | CWStackMode,
				   vlist, wClient(pRLWin->pFrame->win));
		}
	      else
		{
		  /* 1st window - raise to the top */
		  vlist[0] = Above;

		  ConfigureWindow (pRLWin->pFrame->win, CWStackMode,
				   vlist, wClient(pRLWin->pFrame->win));
		}
	    }
	  hwnd = GetNextWindow (hwnd, GW_HWNDNEXT);
	}
d96 2
a97 2
  pScreenPriv->fRestacking = FALSE;
  pScreenPriv->fWindowOrderChanged = FALSE;
a100 1

d106 1
a106 1
winMWExtWMMoveXWindow (WindowPtr pWin, int x, int y)
d108 1
a108 1
  CARD32 *vlist = malloc(sizeof(CARD32)*2);
d110 4
a113 4
  vlist[0] = x;
  vlist[1] = y;
  ConfigureWindow (pWin, CWX | CWY, vlist, wClient(pWin));
  free(vlist);
a115 1

d121 1
a121 1
winMWExtWMResizeXWindow (WindowPtr pWin, int w, int h)
d123 1
a123 1
  CARD32 *vlist = malloc(sizeof(CARD32)*2);
d125 4
a128 4
  vlist[0] = w;
  vlist[1] = h;
  ConfigureWindow (pWin, CWWidth | CWHeight, vlist, wClient(pWin));
  free(vlist);
a130 1

d136 1
a136 1
winMWExtWMMoveResizeXWindow (WindowPtr pWin, int x, int y, int w, int h)
d138 1
a138 1
  CARD32 *vlist = malloc(sizeof(long)*4);
d140 4
a143 4
  vlist[0] = x;
  vlist[1] = y;
  vlist[2] = w;
  vlist[3] = h;
d145 2
a146 2
  ConfigureWindow (pWin, CWX | CWY | CWWidth | CWHeight, vlist, wClient(pWin));
  free(vlist);
a148 1

d155 1
a155 1
winMWExtWMUpdateIcon (Window id)
d157 2
a158 5
  WindowPtr		pWin;
  HICON			hIcon, hiconOld;

  dixLookupResourceByType((pointer) &pWin, id, RT_WINDOW, NullClient, DixUnknownAccess);
  hIcon = winOverrideIcon ((unsigned long)pWin);
d160 19
a178 16
  if (!hIcon)
    hIcon = winXIconToHICON (pWin, GetSystemMetrics(SM_CXICON));

  if (hIcon)
    {
      win32RootlessWindowPtr pRLWinPriv
	= (win32RootlessWindowPtr) RootlessFrameForWindow (pWin, FALSE);

      if (pRLWinPriv->hWnd)
	{

          hiconOld = (HICON) SendMessage (pRLWinPriv->hWnd,
                     WM_SETICON, ICON_BIG, (LPARAM) hIcon);
          winDestroyIcon(hiconOld);
	}
      hIcon=NULL;
a181 1

d187 1
a187 1
winMWExtWMDecorateWindow (HWND hwnd, LPARAM lParam)
d189 17
a205 12
  win32RootlessWindowPtr pRLWinPriv = NULL;
  ScreenPtr		pScreen = NULL;
  winPrivScreenPtr	pScreenPriv = NULL;
  winScreenInfo		*pScreenInfo = NULL;

  /* Check if the Windows window property for our X window pointer is valid */
  if ((pRLWinPriv = (win32RootlessWindowPtr)GetProp (hwnd, WIN_WINDOW_PROP)) != NULL)
    {
      pScreen				= pRLWinPriv->pFrame->win->drawable.pScreen;
      if (pScreen) pScreenPriv		= winGetScreenPriv(pScreen);
      if (pScreenPriv) pScreenInfo	= pScreenPriv->pScreenInfo;
      if (pRLWinPriv && pScreenInfo) winMWExtWMUpdateWindowDecoration (pRLWinPriv, pScreenInfo);
d207 1
a207 1
  return TRUE;
a209 1

d215 2
a216 2
winMWExtWMUpdateWindowDecoration (win32RootlessWindowPtr pRLWinPriv,
				  winScreenInfoPtr pScreenInfo)
d218 14
a231 15
  Bool		fDecorate = FALSE;
  DWORD		dwExStyle = 0;
  DWORD		dwStyle = 0;
  WINDOWPLACEMENT wndPlace;
  UINT		showCmd = 0;

  wndPlace.length = sizeof (WINDOWPLACEMENT);

  /* Get current window placement */
  GetWindowPlacement (pRLWinPriv->hWnd, &wndPlace);

  if (winIsInternalWMRunning(pScreenInfo))
    {
      if (!pRLWinPriv->pFrame->win->overrideRedirect)
	fDecorate = TRUE;
d234 4
a237 4
  if (wndPlace.showCmd == SW_HIDE)
    return;//showCmd = SWP_HIDEWINDOW;
  else
    showCmd = SWP_SHOWWINDOW;
d239 2
a240 2
  if (wndPlace.showCmd == SW_HIDE)
    return;
d242 2
a243 2
  if (IsWindowVisible (pRLWinPriv->hWnd))
    showCmd = SWP_SHOWWINDOW;
d246 1
a246 1
  showCmd |= SWP_NOMOVE | SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOZORDER;
d248 23
a270 24
  winDebug ("winMWExtWMUpdateWindowDecoration %08x %s\n",
	    (int)pRLWinPriv, fDecorate?"Decorate":"Bare");

  /* Get the standard and extended window style information */
  dwExStyle = GetWindowLongPtr (pRLWinPriv->hWnd, GWL_EXSTYLE);
  dwStyle = GetWindowLongPtr (pRLWinPriv->hWnd, GWL_STYLE);

  if (fDecorate)
    {
      RECT		rcNew;
      int		iDx, iDy;
      winWMMessageRec	wmMsg;
      winScreenPriv(pScreenInfo->pScreen);

      /* */
      if (!(dwExStyle & WS_EX_APPWINDOW))
	{
	  winDebug ("\tBare=>Decorate\n");
	  /* Setup a rectangle with the X window position and size */
	  SetRect (&rcNew,
		   pRLWinPriv->pFrame->x,
		   pRLWinPriv->pFrame->y,
		   pRLWinPriv->pFrame->x + pRLWinPriv->pFrame->width,
		   pRLWinPriv->pFrame->y + pRLWinPriv->pFrame->height);
d273 8
a280 9
          winDebug("\tWindow extend {%d, %d, %d, %d}, {%d, %d}\n", 
              rcNew.left, rcNew.top, rcNew.right, rcNew.bottom,
              rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
#endif
	  /* */
	  AdjustWindowRectEx (&rcNew,
			      WS_POPUP | WS_SIZEBOX | WS_OVERLAPPEDWINDOW,
			      FALSE,
			      WS_EX_APPWINDOW);
d283 20
a302 20
          winDebug("\tAdjusted {%d, %d, %d, %d}, {%d, %d}\n", 
              rcNew.left, rcNew.top, rcNew.right, rcNew.bottom,
              rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
#endif
	  /* Calculate position deltas */
	  iDx = pRLWinPriv->pFrame->x - rcNew.left;
	  iDy = pRLWinPriv->pFrame->y - rcNew.top;

	  /* Calculate new rectangle */
	  rcNew.left += iDx;
	  rcNew.right += iDx;
	  rcNew.top += iDy;
	  rcNew.bottom += iDy;

	  /* Set the window extended style flags */
	  SetWindowLongPtr (pRLWinPriv->hWnd, GWL_EXSTYLE, WS_EX_APPWINDOW);

	  /* Set the window standard style flags */
	  SetWindowLongPtr (pRLWinPriv->hWnd, GWL_STYLE,
			    WS_POPUP | WS_SIZEBOX | WS_OVERLAPPEDWINDOW);
d305 3
a307 3
          winDebug("\tWindowStyle: %08x %08x\n",
              WS_POPUP | WS_SIZEBOX | WS_OVERLAPPEDWINDOW,
              WS_EX_APPWINDOW);
d309 1
a309 1
	  /* Position the Windows window */
d311 17
a327 18
          winDebug("\tMoved {%d, %d, %d, %d}, {%d, %d}\n", 
              rcNew.left, rcNew.top, rcNew.right, rcNew.bottom,
              rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
#endif
	  SetWindowPos (pRLWinPriv->hWnd, NULL,
			rcNew.left, rcNew.top,
			rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
			showCmd);
            

	  wmMsg.hwndWindow = pRLWinPriv->hWnd;
	  wmMsg.iWindow	= (Window)pRLWinPriv->pFrame->win->drawable.id;
	  wmMsg.msg = WM_WM_NAME_EVENT;
	  winSendMessageToWM (pScreenPriv->pWMInfo, &wmMsg);

	  winMWExtWMReshapeFrame ((RootlessFrameID)pRLWinPriv ,
				  wBoundingShape(pRLWinPriv->pFrame->win));
	}
d329 12
a340 14
  else
    {
      RECT		rcNew;

      /* */
      if (dwExStyle & WS_EX_APPWINDOW)
	{
	  winDebug ("\tDecorate=>Bare\n");
	  /* Setup a rectangle with the X window position and size */
	  SetRect (&rcNew,
		   pRLWinPriv->pFrame->x,
		   pRLWinPriv->pFrame->y,
		   pRLWinPriv->pFrame->x + pRLWinPriv->pFrame->width,
		   pRLWinPriv->pFrame->y + pRLWinPriv->pFrame->height);
d342 35
a376 36
	  /* */
	  AdjustWindowRectEx (&rcNew,
			      WS_POPUP | WS_CLIPCHILDREN,
			      FALSE,
			      WS_EX_TOOLWINDOW);

	  /* Calculate position deltas */
	  iDx = pRLWinPriv->pFrame->x - rcNew.left;
	  iDy = pRLWinPriv->pFrame->y - rcNew.top;

	  /* Calculate new rectangle */
	  rcNew.left += iDx;
	  rcNew.right += iDx;
	  rcNew.top += iDy;
	  rcNew.bottom += iDy;
#endif

	  /* Hide window temporary to remove from taskbar. */
	  ShowWindow( pRLWinPriv->hWnd, SW_HIDE );

	  /* Set the window extended style flags */
	  SetWindowLongPtr (pRLWinPriv->hWnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW);

	  /* Set the window standard style flags */
	  SetWindowLongPtr (pRLWinPriv->hWnd, GWL_STYLE,
			    WS_POPUP | WS_CLIPCHILDREN);

	  /* Position the Windows window */
	  SetWindowPos (pRLWinPriv->hWnd, NULL,
			rcNew.left, rcNew.top,
			rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
			showCmd);

	  winMWExtWMReshapeFrame ((RootlessFrameID)pRLWinPriv ,
				  wBoundingShape(pRLWinPriv->pFrame->win));
	}
a379 1

d384 1
a384 1
winIsInternalWMRunning (winScreenInfoPtr pScreenInfo)
d386 1
a386 1
  return pScreenInfo->fInternalWM && !pScreenInfo->fAnotherWMRunning;
a388 1

d394 1
a394 1
winMWExtWMRestackWindows (ScreenPtr pScreen)
d396 8
a403 8
  winScreenPriv(pScreen);
  WindowPtr pRoot = pScreen->root;
  WindowPtr pWin = NULL;
  WindowPtr pWinPrev = NULL;
  win32RootlessWindowPtr pRLWin = NULL;
  win32RootlessWindowPtr pRLWinPrev = NULL;
  int  nWindow = 0;
  HDWP hWinPosInfo = NULL;
d406 1
a406 1
  winDebug ("winMWExtWMRestackWindows\n");
d409 1
a409 1
  pScreenPriv->fRestacking = TRUE;
d411 3
a413 4
  if (pRoot != NULL)
    {
      for (pWin = pRoot->firstChild; pWin; pWin = pWin->nextSib)
	nWindow ++;
d415 1
a415 1
      hWinPosInfo = BeginDeferWindowPos(nWindow);
d417 3
a419 5
      for (pWin = pRoot->firstChild; pWin; pWin = pWin->nextSib)
	{
	  if (pWin->realized)
	    {
	      UINT uFlags;
d421 5
a425 2
	      pRLWin = (win32RootlessWindowPtr) RootlessFrameForWindow (pWin, FALSE);
	      if (pRLWin == NULL) continue;
d427 4
a430 2
	      if (pWinPrev)
		pRLWinPrev = (win32RootlessWindowPtr) RootlessFrameForWindow (pWinPrev, FALSE);
d432 3
a434 2
	      uFlags = SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW;
	      if (pRLWinPrev != NULL) uFlags |= SWP_NOACTIVATE;
d437 23
a459 23
	      winDebug ("winMWExtWMRestackWindows - DeferWindowPos (%08x, %08x)\n",
			pRLWin->hWnd,
			pRLWinPrev ? pRLWinPrev->hWnd : HWND_TOP);
#endif
	      hWinPosInfo = DeferWindowPos (hWinPosInfo, pRLWin->hWnd,
					    pRLWinPrev ? pRLWinPrev->hWnd : HWND_TOP,
					    0, 0, 0, 0,
					    uFlags);
	      if (hWinPosInfo == NULL)
		{
		  ErrorF ("winMWExtWMRestackWindows - DeferWindowPos () failed: %d\n",
			  (int) GetLastError ());
		  return;
		}
	      pWinPrev = pWin;
	    }
	}
      if (!EndDeferWindowPos (hWinPosInfo))
	{
	  ErrorF ("winMWExtWMRestackWindows - EndDeferWindowPos () failed: %d\n",
		  (int) GetLastError ());
	  return;
	}
d463 1
a463 1
  winDebug ("winMWExtWMRestackWindows - done\n");
d465 1
a465 1
  pScreenPriv->fRestacking = FALSE;
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d410 1
a410 1
  WindowPtr pRoot = WindowTable[pScreen->myNum];
@


1.1
log
@Initial revision
@
text
@d167 2
a168 2
  pWin = (WindowPtr) LookupIDByType (id, RT_WINDOW);
  hIcon = (HICON)winOverrideIcon ((unsigned long)pWin);
d180 3
a182 4
	  hiconOld = (HICON) SetClassLong (pRLWinPriv->hWnd,
					   GCL_HICON,
					   (int) hIcon);
	  
d185 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
