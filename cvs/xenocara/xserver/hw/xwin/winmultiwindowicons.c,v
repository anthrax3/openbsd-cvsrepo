head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Earle F. Philhower, III
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif

#ifndef WINVER
#define WINVER 0x0500
#endif

#include <X11/Xwindows.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

#include "winresource.h"
#include "winprefs.h"
#include "winmsg.h"
#include "winmultiwindowicons.h"
#include "winglobals.h"
/*
 * global variables
 */
extern HINSTANCE g_hInstance;

/*
 * Scale an X icon ZPixmap into a Windoze icon bitmap
 */

static void
winScaleXImageToWindowsIcon(int iconSize,
                            int effBPP,
                            int stride, XImage * pixmap, unsigned char *image)
{
    int row, column, effXBPP, effXDepth;
    unsigned char *outPtr;
    unsigned char *iconData = 0;
    int xStride;
    float factX, factY;
    int posX, posY;
    unsigned char *ptr;
    unsigned int zero;
    unsigned int color;

    effXBPP = pixmap->bits_per_pixel;
    if (pixmap->bits_per_pixel == 15)
        effXBPP = 16;

    effXDepth = pixmap->depth;
    if (pixmap->depth == 15)
        effXDepth = 16;

    xStride = pixmap->bytes_per_line;
    if (stride == 0 || xStride == 0) {
        ErrorF("winScaleXBitmapToWindows - stride or xStride is zero.  "
               "Bailing.\n");
        return;
    }

    /* Get icon data */
    iconData = (unsigned char *) pixmap->data;

    /* Keep aspect ratio */
    factX = ((float) pixmap->width) / ((float) iconSize);
    factY = ((float) pixmap->height) / ((float) iconSize);
    if (factX > factY)
        factY = factX;
    else
        factX = factY;

    /* Out-of-bounds, fill icon with zero */
    zero = 0;

    for (row = 0; row < iconSize; row++) {
        outPtr = image + stride * row;
        for (column = 0; column < iconSize; column++) {
            posX = factX * column;
            posY = factY * row;

            ptr = (unsigned char *) iconData + posY * xStride;
            if (effXBPP == 1) {
                ptr += posX / 8;

                /* Out of X icon bounds, leave space blank */
                if (posX >= pixmap->width || posY >= pixmap->height)
                    ptr = (unsigned char *) &zero;

                if ((*ptr) & (1 << (posX & 7)))
                    switch (effBPP) {
                    case 32:
                        *(outPtr++) = 0;
                    case 24:
                        *(outPtr++) = 0;
                    case 16:
                        *(outPtr++) = 0;
                    case 8:
                        *(outPtr++) = 0;
                        break;
                    case 1:
                        outPtr[column / 8] &= ~(1 << (7 - (column & 7)));
                        break;
                    }
                else
                    switch (effBPP) {
                    case 32:
                        *(outPtr++) = 255;
                        *(outPtr++) = 255;
                        *(outPtr++) = 255;
                        *(outPtr++) = 0;
                        break;
                    case 24:
                        *(outPtr++) = 255;
                    case 16:
                        *(outPtr++) = 255;
                    case 8:
                        *(outPtr++) = 255;
                        break;
                    case 1:
                        outPtr[column / 8] |= (1 << (7 - (column & 7)));
                        break;
                    }
            }
            else if (effXDepth == 24 || effXDepth == 32) {
                ptr += posX * (effXBPP / 8);

                /* Out of X icon bounds, leave space blank */
                if (posX >= pixmap->width || posY >= pixmap->height)
                    ptr = (unsigned char *) &zero;
                color = (((*ptr) << 16)
                         + ((*(ptr + 1)) << 8)
                         + ((*(ptr + 2)) << 0));
                switch (effBPP) {
                case 32:
                    *(outPtr++) = *(ptr++);     /* b */
                    *(outPtr++) = *(ptr++);     /* g */
                    *(outPtr++) = *(ptr++);     /* r */
                    *(outPtr++) = (effXDepth == 32) ? *(ptr++) : 0x0;   /* alpha */
                    break;
                case 24:
                    *(outPtr++) = *(ptr++);
                    *(outPtr++) = *(ptr++);
                    *(outPtr++) = *(ptr++);
                    break;
                case 16:
                    color = ((((*ptr) >> 2) << 10)
                             + (((*(ptr + 1)) >> 2) << 5)
                             + (((*(ptr + 2)) >> 2)));
                    *(outPtr++) = (color >> 8);
                    *(outPtr++) = (color & 255);
                    break;
                case 8:
                    color = (((*ptr))) + (((*(ptr + 1)))) + (((*(ptr + 2))));
                    color /= 3;
                    *(outPtr++) = color;
                    break;
                case 1:
                    if (color)
                        outPtr[column / 8] |= (1 << (7 - (column & 7)));
                    else
                        outPtr[column / 8] &= ~(1 << (7 - (column & 7)));
                }
            }
            else if (effXDepth == 16) {
                ptr += posX * (effXBPP / 8);

                /* Out of X icon bounds, leave space blank */
                if (posX >= pixmap->width || posY >= pixmap->height)
                    ptr = (unsigned char *) &zero;
                color = ((*ptr) << 8) + (*(ptr + 1));
                switch (effBPP) {
                case 32:
                    *(outPtr++) = (color & 31) << 2;
                    *(outPtr++) = ((color >> 5) & 31) << 2;
                    *(outPtr++) = ((color >> 10) & 31) << 2;
                    *(outPtr++) = 0;    /* resvd */
                    break;
                case 24:
                    *(outPtr++) = (color & 31) << 2;
                    *(outPtr++) = ((color >> 5) & 31) << 2;
                    *(outPtr++) = ((color >> 10) & 31) << 2;
                    break;
                case 16:
                    *(outPtr++) = *(ptr++);
                    *(outPtr++) = *(ptr++);
                    break;
                case 8:
                    *(outPtr++) = (((color & 31)
                                    + ((color >> 5) & 31)
                                    + ((color >> 10) & 31)) / 3) << 2;
                    break;
                case 1:
                    if (color)
                        outPtr[column / 8] |= (1 << (7 - (column & 7)));
                    else
                        outPtr[column / 8] &= ~(1 << (7 - (column & 7)));
                    break;
                }               /* end switch(effbpp) */
            }                   /* end if effxbpp==16) */
        }                       /* end for column */
    }                           /* end for row */
}

static HICON
NetWMToWinIconAlpha(uint32_t * icon)
{
    int width = icon[0];
    int height = icon[1];
    uint32_t *pixels = &icon[2];
    HICON result;
    HDC hdc = GetDC(NULL);
    uint32_t *DIB_pixels;
    ICONINFO ii;
    BITMAPV4HEADER bmh = { sizeof(bmh) };

    /* Define an ARGB pixel format used for Color+Alpha icons */
    bmh.bV4Width = width;
    bmh.bV4Height = -height;    /* Invert the image */
    bmh.bV4Planes = 1;
    bmh.bV4BitCount = 32;
    bmh.bV4V4Compression = BI_BITFIELDS;
    bmh.bV4AlphaMask = 0xFF000000;
    bmh.bV4RedMask = 0x00FF0000;
    bmh.bV4GreenMask = 0x0000FF00;
    bmh.bV4BlueMask = 0x000000FF;

    ii.fIcon = TRUE;
    ii.xHotspot = 0;            /* ignored */
    ii.yHotspot = 0;            /* ignored */
    ii.hbmColor = CreateDIBSection(hdc, (BITMAPINFO *) &bmh,
                                   DIB_RGB_COLORS, (void **) &DIB_pixels, NULL,
                                   0);
    ReleaseDC(NULL, hdc);

    if (!ii.hbmColor)
      return NULL;

    ii.hbmMask = CreateBitmap(width, height, 1, 1, NULL);
    memcpy(DIB_pixels, pixels, height * width * 4);

    /* CreateIconIndirect() traditionally required DDBitmaps */
    /* Systems from WinXP accept 32-bit ARGB DIBitmaps with full 8-bit alpha support */
    /* The icon is created with a DIB + empty DDB mask (an MS example does the same) */
    result = CreateIconIndirect(&ii);

    DeleteObject(ii.hbmColor);
    DeleteObject(ii.hbmMask);

    winDebug("NetWMToWinIconAlpha - %d x %d = %p\n", icon[0], icon[1], result);
    return result;
}

static HICON
NetWMToWinIconThreshold(uint32_t * icon)
{
    int width = icon[0];
    int height = icon[1];
    uint32_t *pixels = &icon[2];
    int row, col;
    HICON result;
    ICONINFO ii;

    HDC hdc = GetDC(NULL);
    HDC xorDC = CreateCompatibleDC(hdc);
    HDC andDC = CreateCompatibleDC(hdc);

    ii.fIcon = TRUE;
    ii.xHotspot = 0;            /* ignored */
    ii.yHotspot = 0;            /* ignored */
    ii.hbmColor = CreateCompatibleBitmap(hdc, width, height);
    ii.hbmMask = CreateCompatibleBitmap(hdc, width, height);
    ReleaseDC(NULL, hdc);
    SelectObject(xorDC, ii.hbmColor);
    SelectObject(andDC, ii.hbmMask);

    for (row = 0; row < height; row++) {
        for (col = 0; col < width; col++) {
            if ((*pixels & 0xFF000000) > 31 << 24) {    /* 31 alpha threshold, i.e. opaque above, transparent below */
                SetPixelV(xorDC, col, row,
                          RGB(((char *) pixels)[2], ((char *) pixels)[1],
                              ((char *) pixels)[0]));
                SetPixelV(andDC, col, row, RGB(0, 0, 0));       /* black mask */
            }
            else {
                SetPixelV(xorDC, col, row, RGB(0, 0, 0));
                SetPixelV(andDC, col, row, RGB(255, 255, 255)); /* white mask */
            }
            pixels++;
        }
    }
    DeleteDC(xorDC);
    DeleteDC(andDC);

    result = CreateIconIndirect(&ii);

    DeleteObject(ii.hbmColor);
    DeleteObject(ii.hbmMask);

    winDebug("NetWMToWinIconThreshold - %d x %d = %p\n", icon[0], icon[1],
             result);
    return result;
}

static HICON
NetWMToWinIcon(int bpp, uint32_t * icon)
{
    static Bool hasIconAlphaChannel = FALSE;
    static BOOL versionChecked = FALSE;

    if (!versionChecked) {
        OSVERSIONINFOEX osvi = { 0 };
        ULONGLONG dwlConditionMask = 0;

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        osvi.dwMajorVersion = 5;
        osvi.dwMinorVersion = 1;

        /* Windows versions later than XP have icon alpha channel suport, 2000 does not */
        VER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION,
                          VER_GREATER_EQUAL);
        VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION,
                          VER_GREATER_EQUAL);
        hasIconAlphaChannel =
            VerifyVersionInfo(&osvi, VER_MAJORVERSION | VER_MINORVERSION,
                              dwlConditionMask);
        versionChecked = TRUE;

        ErrorF("OS has icon alpha channel support: %s\n",
               hasIconAlphaChannel ? "yes" : "no");
    }

    if (hasIconAlphaChannel && (bpp == 32))
        return NetWMToWinIconAlpha(icon);
    else
        return NetWMToWinIconThreshold(icon);
}

/*
 * Attempt to create a custom icon from the WM_HINTS bitmaps
 */

static
 HICON
winXIconToHICON(Display * pDisplay, Window id, int iconSize)
{
    unsigned char *mask, *image = NULL, *imageMask;
    unsigned char *dst, *src;
    int planes, bpp, i;
    unsigned int biggest_size = 0;
    HDC hDC;
    ICONINFO ii;
    XWMHints *hints;
    HICON hIcon = NULL;
    uint32_t *biggest_icon = NULL;
    static Atom _XA_NET_WM_ICON;
    static int generation;
    uint32_t *icon, *icon_data = NULL;
    unsigned long int size;
    Atom type;
    int format;
    unsigned long int left;

    hDC = GetDC(GetDesktopWindow());
    planes = GetDeviceCaps(hDC, PLANES);
    bpp = GetDeviceCaps(hDC, BITSPIXEL);
    ReleaseDC(GetDesktopWindow(), hDC);

    /* Always prefer _NET_WM_ICON icons */
    if (generation != serverGeneration) {
        generation = serverGeneration;
        _XA_NET_WM_ICON = XInternAtom(pDisplay, "_NET_WM_ICON", FALSE);
    }

    if ((XGetWindowProperty(pDisplay, id, _XA_NET_WM_ICON,
                            0, MAXINT, FALSE,
                            AnyPropertyType, &type, &format, &size, &left,
                            (unsigned char **) &icon_data) == Success) &&
        (icon_data != NULL)) {
        for (icon = icon_data; icon < &icon_data[size] && *icon;
             icon = &icon[icon[0] * icon[1] + 2]) {
            winDebug("winXIconToHICON: %u x %u NetIcon\n", icon[0], icon[1]);

            /* Icon data size will overflow an int and thus is bigger than the
               property can possibly be */
            if ((INT_MAX/icon[0]) < icon[1]) {
                winDebug("winXIconToHICON: _NET_WM_ICON icon data size overflow\n");
                break;
            }

            /* Icon data size is bigger than amount of data remaining */
            if (&icon[icon[0] * icon[1] + 2] > &icon_data[size]) {
                winDebug("winXIconToHICON: _NET_WM_ICON data is malformed\n");
                break;
            }

            /* Found an exact match to the size we require...  */
            if (icon[0] == iconSize && icon[1] == iconSize) {
                winDebug("winXIconToHICON: selected %d x %d NetIcon\n",
                         iconSize, iconSize);
                hIcon = NetWMToWinIcon(bpp, icon);
                break;
            }
            /* Otherwise, find the biggest icon and let Windows scale the size */
            else if (biggest_size < icon[0]) {
                biggest_icon = icon;
                biggest_size = icon[0];
            }
        }

        if (!hIcon && biggest_icon) {
            winDebug
                ("winXIconToHICON: selected %u x %u NetIcon for scaling to %d x %d\n",
                 biggest_icon[0], biggest_icon[1], iconSize, iconSize);

            hIcon = NetWMToWinIcon(bpp, biggest_icon);
        }

        XFree(icon_data);
    }

    if (!hIcon) {
        winDebug("winXIconToHICON: no suitable NetIcon\n");

        hints = XGetWMHints(pDisplay, id);
        if (hints) {
            winDebug("winXIconToHICON: id 0x%x icon_pixmap hint 0x%x\n",
                     (unsigned int)id,
                     (unsigned int)hints->icon_pixmap);

            if (hints->icon_pixmap) {
                Window root;
                int x, y;
                unsigned int width, height, border_width, depth;
                XImage *xImageIcon;
                XImage *xImageMask = NULL;

                XGetGeometry(pDisplay, hints->icon_pixmap, &root, &x, &y,
                             &width, &height, &border_width, &depth);

                xImageIcon =
                    XGetImage(pDisplay, hints->icon_pixmap, 0, 0, width, height,
                              0xFFFFFFFF, ZPixmap);
                winDebug("winXIconToHICON: id 0x%x icon Ximage 0x%p\n",
                         (unsigned int)id, xImageIcon);

                if (hints->icon_mask)
                    xImageMask =
                        XGetImage(pDisplay, hints->icon_mask, 0, 0, width,
                                  height, 0xFFFFFFFF, ZPixmap);

                if (xImageIcon) {
                    int effBPP, stride, maskStride;

                    /* 15 BPP is really 16BPP as far as we care */
                    if (bpp == 15)
                        effBPP = 16;
                    else
                        effBPP = bpp;

                    /* Need 16-bit aligned rows for DDBitmaps */
                    stride = ((iconSize * effBPP + 15) & (~15)) / 8;

                    /* Mask is 1-bit deep */
                    maskStride = ((iconSize * 1 + 15) & (~15)) / 8;

                    image = malloc(stride * iconSize);
                    imageMask = malloc(stride * iconSize);
                    mask = malloc(maskStride * iconSize);

                    /* Default to a completely black mask */
                    memset(imageMask, 0, stride * iconSize);
                    memset(mask, 0, maskStride * iconSize);

                    winScaleXImageToWindowsIcon(iconSize, effBPP, stride,
                                                xImageIcon, image);

                    if (xImageMask) {
                        winScaleXImageToWindowsIcon(iconSize, 1, maskStride,
                                                    xImageMask, mask);
                        winScaleXImageToWindowsIcon(iconSize, effBPP, stride,
                                                    xImageMask, imageMask);
                    }

                    /* Now we need to set all bits of the icon which are not masked */
                    /* on to 0 because Color is really an XOR, not an OR function */
                    dst = image;
                    src = imageMask;

                    for (i = 0; i < (stride * iconSize); i++)
                        if ((*(src++)))
                            *(dst++) = 0;
                        else
                            dst++;

                    ii.fIcon = TRUE;
                    ii.xHotspot = 0;    /* ignored */
                    ii.yHotspot = 0;    /* ignored */

                    /* Create Win32 mask from pixmap shape */
                    ii.hbmMask =
                        CreateBitmap(iconSize, iconSize, planes, 1, mask);

                    /* Create Win32 bitmap from pixmap */
                    ii.hbmColor =
                        CreateBitmap(iconSize, iconSize, planes, bpp, image);

                    /* Merge Win32 mask and bitmap into icon */
                    hIcon = CreateIconIndirect(&ii);

                    /* Release Win32 mask and bitmap */
                    DeleteObject(ii.hbmMask);
                    DeleteObject(ii.hbmColor);

                    /* Free X mask and bitmap */
                    free(mask);
                    free(image);
                    free(imageMask);

                    if (xImageMask)
                        XDestroyImage(xImageMask);

                    XDestroyImage(xImageIcon);
                }
            }
            XFree(hints);
        }
    }
    return hIcon;
}

/*
 * Change the Windows window icon
 */

#ifdef XWIN_MULTIWINDOW
void
winUpdateIcon(HWND hWnd, Display * pDisplay, Window id, HICON hIconNew)
{
    HICON hIcon, hIconSmall = NULL, hIconOld;

    /* Start with the icon from preferences, if any */
    hIcon = hIconNew;
    hIconSmall = hIconNew;

    /* If we still need an icon, try and get the icon from WM_HINTS */
    if (!hIcon)
        hIcon = winXIconToHICON(pDisplay, id, GetSystemMetrics(SM_CXICON));
    if (!hIconSmall)
        hIconSmall =
            winXIconToHICON(pDisplay, id, GetSystemMetrics(SM_CXSMICON));

    /* If we got the small, but not the large one swap them */
    if (!hIcon && hIconSmall) {
        hIcon = hIconSmall;
        hIconSmall = NULL;
    }

    /* Set the large icon */
    hIconOld = (HICON) SendMessage(hWnd, WM_SETICON, ICON_BIG, (LPARAM) hIcon);
    /* Delete the old icon if its not the default */
    winDestroyIcon(hIconOld);

    /* Same for the small icon */
    hIconOld =
        (HICON) SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM) hIconSmall);
    winDestroyIcon(hIconOld);
}

void
winInitGlobalIcons(void)
{
    int sm_cx = GetSystemMetrics(SM_CXICON);
    int sm_cxsm = GetSystemMetrics(SM_CXSMICON);

    /* Load default X icon in case it's not ready yet */
    if (!g_hIconX) {
        g_hIconX = winOverrideDefaultIcon(sm_cx);
        g_hSmallIconX = winOverrideDefaultIcon(sm_cxsm);
    }

    if (!g_hIconX) {
        g_hIconX = (HICON) LoadImage(g_hInstance,
                                     MAKEINTRESOURCE(IDI_XWIN),
                                     IMAGE_ICON,
                                     GetSystemMetrics(SM_CXICON),
                                     GetSystemMetrics(SM_CYICON), 0);
        g_hSmallIconX = (HICON) LoadImage(g_hInstance,
                                          MAKEINTRESOURCE(IDI_XWIN),
                                          IMAGE_ICON,
                                          GetSystemMetrics(SM_CXSMICON),
                                          GetSystemMetrics(SM_CYSMICON),
                                          LR_DEFAULTSIZE);
    }
}

void
winSelectIcons(HICON * pIcon, HICON * pSmallIcon)
{
    HICON hIcon, hSmallIcon;

    winInitGlobalIcons();

    /* Use default X icon */
    hIcon = g_hIconX;
    hSmallIcon = g_hSmallIconX;

    if (pIcon)
        *pIcon = hIcon;

    if (pSmallIcon)
        *pSmallIcon = hSmallIcon;
}

void
winDestroyIcon(HICON hIcon)
{
    /* Delete the icon if its not one of the application defaults or an override */
    if (hIcon &&
        hIcon != g_hIconX &&
        hIcon != g_hSmallIconX && !winIconIsOverride(hIcon))
        DestroyIcon(hIcon);
}
#endif
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d452 3
a454 2
            winDebug("winXIconToHICON: id 0x%x icon_pixmap hint %x\n", id,
                     hints->icon_pixmap);
d469 2
a470 2
                winDebug("winXIconToHICON: id 0x%x icon Ximage 0x%p\n", id,
                         xImageIcon);
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d385 1
a385 1
    unsigned long int type;
d468 1
a468 1
                winDebug("winXIconToHICON: id 0x%x icon Ximage 0x%x\n", id,
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d375 1
a375 1
    int biggest_size = 0;
a380 1

d407 16
a422 1
            /* Find an exact match to the size we require...  */
d424 2
a425 2
                winDebug("winXIconToHICON: found %lu x %lu NetIcon\n", icon[0],
                         icon[1]);
d438 1
a438 1
                ("winXIconToHICON: selected %lu x %lu NetIcon for scaling to %u x %u\n",
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d260 4
d631 1
a631 1
        hIcon != g_hSmallIconX && !winIconIsOverride((unsigned long) hIcon))
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a33 4
#include "win.h"
#include "dixevents.h"
#include "winmultiwindowclass.h"
#include "winprefs.h"
d35 7
a41 2
#include "propertyst.h"
#include "windowstr.h"
d43 5
d49 1
a49 1
 * Prototypes for local functions
d51 1
a51 5

static void

winScaleXBitmapToWindows(int iconSize, int effBPP,
                         PixmapPtr pixmap, unsigned char *image);
d54 1
a54 1
 * Scale an X icon bitmap into a Windoze icon bitmap
d58 3
a60 2
winScaleXBitmapToWindows(int iconSize,
                         int effBPP, PixmapPtr pixmap, unsigned char *image)
d64 2
a65 2
    char *iconData = 0;
    int stride, xStride;
d72 2
a73 4
    effXBPP = BitsPerPixel(pixmap->drawable.depth);
    effXDepth = pixmap->drawable.depth;

    if (pixmap->drawable.bitsPerPixel == 15)
d76 2
a77 1
    if (pixmap->drawable.depth == 15)
d80 1
a80 3
    /* Need 16-bit aligned rows for DDBitmaps */
    stride = ((iconSize * effBPP + 15) & (~15)) / 8;
    xStride = PixmapBytePad(pixmap->drawable.width, pixmap->drawable.depth);
a86 8
    /* Allocate memory for icon data */
    iconData = malloc(xStride * pixmap->drawable.height);
    if (!iconData) {
        ErrorF("winScaleXBitmapToWindows - malloc failed for iconData.  "
               "Bailing.\n");
        return;
    }

d88 1
a88 3
    miGetImage((DrawablePtr) &(pixmap->drawable), 0, 0,
               pixmap->drawable.width, pixmap->drawable.height,
               ZPixmap, 0xffffffff, iconData);
d91 2
a92 2
    factX = ((float) pixmap->drawable.width) / ((float) iconSize);
    factY = ((float) pixmap->drawable.height) / ((float) iconSize);
d112 1
a112 2
                if (posX >= pixmap->drawable.width
                    || posY >= pixmap->drawable.height)
d154 1
a154 2
                if (posX >= pixmap->drawable.width
                    || posY >= pixmap->drawable.height)
d194 1
a194 2
                if (posX >= pixmap->drawable.width
                    || posY >= pixmap->drawable.height)
a227 1
    free(iconData);
d239 1
a239 1
    ICONINFO ii = { TRUE };
d253 4
a256 1
    ii.hbmColor = CreateDIBSection(hdc, (BITMAPINFO *) & bmh,
d283 1
a283 1
    ICONINFO ii = { TRUE };
d289 3
a359 23
static pointer
GetWindowProp(WindowPtr pWin, Atom name, long int *size_return)
{
    struct _Window *pwin;
    struct _Property *prop;

    if (!pWin || !name) {
        ErrorF("GetWindowProp - pWin or name was NULL\n");
        return 0;
    }
    pwin = (struct _Window *) pWin;
    if (!pwin->optional)
        return NULL;
    for (prop = (struct _Property *) pwin->optional->userProps;
         prop; prop = prop->next) {
        if (prop->propertyName == name) {
            *size_return = prop->size;
            return prop->data;
        }
    }
    return NULL;
}

d364 3
a366 2
HICON
winXIconToHICON(WindowPtr pWin, int iconSize)
d368 1
a368 1
    unsigned char *mask, *image, *imageMask;
d370 1
a370 3
    PixmapPtr iconPtr;
    PixmapPtr maskPtr;
    int planes, bpp, effBPP, stride, maskStride, i;
d374 1
a374 1
    WinXWMHints hints;
a377 1
    /* Try to get _NET_WM_ICON icons first */
d381 4
a384 1
    long int size = 0;
d391 1
d394 1
a394 1
        _XA_NET_WM_ICON = MakeAtom("_NET_WM_ICON", 12, TRUE);
d397 6
a402 5
    if (_XA_NET_WM_ICON)
        icon_data = GetWindowProp(pWin, _XA_NET_WM_ICON, &size);
    if (icon_data) {
        for (icon = icon_data;
             icon < &icon_data[size] && *icon;
d404 8
a411 3
            if (icon[0] == iconSize && icon[1] == iconSize)
                return NetWMToWinIcon(bpp, icon);
            /* Find the biggest icon and let Windows scale the size */
a416 5
        if (biggest_icon)
            return NetWMToWinIcon(bpp, biggest_icon);
    }
    winDebug("winXIconToHICON - pWin %x: no suitable NetIcon\n", (int) pWin,
             iconSize);
d418 4
a421 15
    winMultiWindowGetWMHints(pWin, &hints);
    if (!hints.icon_pixmap)
        return NULL;

    dixLookupResourceByType((pointer) &iconPtr, hints.icon_pixmap, RT_PIXMAP,
                            NullClient, DixUnknownAccess);

    if (!iconPtr)
        return NULL;

    /* 15 BPP is really 16BPP as far as we care */
    if (bpp == 15)
        effBPP = 16;
    else
        effBPP = bpp;
d423 2
a424 2
    /* Need 16-bit aligned rows for DDBitmaps */
    stride = ((iconSize * effBPP + 15) & (~15)) / 8;
d426 2
a427 2
    /* Mask is 1-bit deep */
    maskStride = ((iconSize * 1 + 15) & (~15)) / 8;
d429 2
a430 25
    image = malloc(stride * iconSize);
    imageMask = malloc(stride * iconSize);
    /* Default to a completely black mask */
    mask = calloc(maskStride, iconSize);

    winScaleXBitmapToWindows(iconSize, effBPP, iconPtr, image);
    dixLookupResourceByType((pointer) &maskPtr, hints.icon_mask, RT_PIXMAP,
                            NullClient, DixUnknownAccess);

    if (maskPtr) {
        winScaleXBitmapToWindows(iconSize, 1, maskPtr, mask);

        winScaleXBitmapToWindows(iconSize, effBPP, maskPtr, imageMask);

        /* Now we need to set all bits of the icon which are not masked */
        /* on to 0 because Color is really an XOR, not an OR function */
        dst = image;
        src = imageMask;

        for (i = 0; i < (stride * iconSize); i++)
            if ((*(src++)))
                *(dst++) = 0;
            else
                dst++;
    }
d432 34
a465 3
    ii.fIcon = TRUE;
    ii.xHotspot = 0;            /* ignored */
    ii.yHotspot = 0;            /* ignored */
d467 2
a468 2
    /* Create Win32 mask from pixmap shape */
    ii.hbmMask = CreateBitmap(iconSize, iconSize, planes, 1, mask);
d470 2
a471 2
    /* Create Win32 bitmap from pixmap */
    ii.hbmColor = CreateBitmap(iconSize, iconSize, planes, bpp, image);
d473 17
a489 2
    /* Merge Win32 mask and bitmap into icon */
    hIcon = CreateIconIndirect(&ii);
d491 34
a524 3
    /* Release Win32 mask and bitmap */
    DeleteObject(ii.hbmMask);
    DeleteObject(ii.hbmColor);
d526 2
a527 4
    /* Free X mask and bitmap */
    free(mask);
    free(image);
    free(imageMask);
d529 6
d539 1
a539 1
 * Change the Windows window icon 
d544 1
a544 1
winUpdateIcon(Window id)
a545 1
    WindowPtr pWin;
d548 10
a557 18
    dixLookupResourceByType((pointer) &pWin, id, RT_WINDOW, NullClient,
                            DixUnknownAccess);
    if (pWin) {
        winWindowPriv(pWin);
        if (pWinPriv->hWnd) {
            hIcon = winOverrideIcon((unsigned long) pWin);
            if (!hIcon) {
                hIcon = winXIconToHICON(pWin, GetSystemMetrics(SM_CXICON));
                if (!hIcon) {
                    hIcon = g_hIconX;
                    hIconSmall = g_hSmallIconX;
                }
                else {
                    /* Leave undefined if not found */
                    hIconSmall =
                        winXIconToHICON(pWin, GetSystemMetrics(SM_CXSMICON));
                }
            }
d559 4
a562 14
            /* Set the large icon */
            hIconOld = (HICON) SendMessage(pWinPriv->hWnd,
                                           WM_SETICON, ICON_BIG,
                                           (LPARAM) hIcon);

            /* Delete the icon if its not the default */
            winDestroyIcon(hIconOld);

            /* Same for the small icon */
            hIconOld = (HICON) SendMessage(pWinPriv->hWnd,
                                           WM_SETICON, ICON_SMALL,
                                           (LPARAM) hIconSmall);
            winDestroyIcon(hIconOld);
        }
d564 10
d604 1
a604 1
winSelectIcons(WindowPtr pWin, HICON * pIcon, HICON * pSmallIcon)
d610 3
a612 15
    /* Try and get the icon from WM_HINTS */
    hIcon = winXIconToHICON(pWin, GetSystemMetrics(SM_CXICON));
    hSmallIcon = winXIconToHICON(pWin, GetSystemMetrics(SM_CXSMICON));

    /* If we got the small, but not the large one swap them */
    if (!hIcon && hSmallIcon) {
        hIcon = hSmallIcon;
        hSmallIcon = NULL;
    }

    /* Use default X icon if no icon loaded from WM_HINTS */
    if (!hIcon) {
        hIcon = g_hIconX;
        hSmallIcon = g_hSmallIconX;
    }
a615 2
    else
        winDestroyIcon(hIcon);
a618 2
    else
        winDestroyIcon(hSmallIcon);
@


1.4
log
@Update to xserver 1.11.2
@
text
@a41 1

a46 2
winScaleXBitmapToWindows (int iconSize, int effBPP,
			  PixmapPtr pixmap, unsigned char *image);
d48 2
d56 2
a57 4
winScaleXBitmapToWindows (int iconSize,
			  int effBPP,
			  PixmapPtr pixmap,
			  unsigned char *image)
d59 183
a241 194
  int			row, column, effXBPP, effXDepth;
  unsigned char		*outPtr;
  char		*iconData = 0;
  int			stride, xStride;
  float			factX, factY;
  int			posX, posY;
  unsigned char		*ptr;
  unsigned int		zero;
  unsigned int		color;

  effXBPP = BitsPerPixel(pixmap->drawable.depth);
  effXDepth = pixmap->drawable.depth;

  if (pixmap->drawable.bitsPerPixel == 15)
    effXBPP = 16;
  
  if (pixmap->drawable.depth == 15)
    effXDepth = 16;

  /* Need 16-bit aligned rows for DDBitmaps */
  stride = ((iconSize * effBPP + 15) & (~15)) / 8;
  xStride = PixmapBytePad (pixmap->drawable.width, pixmap->drawable.depth);
  if (stride == 0 || xStride == 0)
    {
      ErrorF ("winScaleXBitmapToWindows - stride or xStride is zero.  "
	      "Bailing.\n");
      return;
    }

  /* Allocate memory for icon data */
  iconData = malloc (xStride * pixmap->drawable.height);
  if (!iconData)
    {
      ErrorF ("winScaleXBitmapToWindows - malloc failed for iconData.  "
	      "Bailing.\n");
      return;
    }

  /* Get icon data */
  miGetImage ((DrawablePtr) &(pixmap->drawable), 0, 0,
	      pixmap->drawable.width, pixmap->drawable.height,
	      ZPixmap, 0xffffffff, iconData);

  /* Keep aspect ratio */
  factX = ((float)pixmap->drawable.width) / ((float)iconSize);
  factY = ((float)pixmap->drawable.height) / ((float)iconSize);
  if (factX > factY)
    factY = factX;
  else
    factX = factY;
  
  /* Out-of-bounds, fill icon with zero */
  zero = 0;
 
  for (row = 0; row < iconSize; row++)
    {
      outPtr = image + stride * row;
      for (column = 0; column < iconSize; column++)
	{
	  posX = factX * column;
	  posY = factY * row;
	  
	  ptr = (unsigned char*) iconData + posY*xStride;
	  if (effXBPP == 1)
	    {
	      ptr += posX / 8;
	      
	      /* Out of X icon bounds, leave space blank */
	      if (posX >= pixmap->drawable.width
		  || posY >= pixmap->drawable.height)
		ptr = (unsigned char *) &zero;
	      
	      if ((*ptr) & (1 << (posX & 7)))
		switch (effBPP)
		  {
		  case 32:
		    *(outPtr++) = 0;
		  case 24:
		    *(outPtr++) = 0;
		  case 16:
		    *(outPtr++) = 0;
		  case 8:
		    *(outPtr++) = 0;
		    break;
		  case 1:
		    outPtr[column / 8] &= ~(1 << (7 - (column & 7)));
		    break;
		  }
	      else
		switch (effBPP)
		  {
		  case 32:
		    *(outPtr++) = 255;
		    *(outPtr++) = 255;
		    *(outPtr++) = 255;
		    *(outPtr++) = 0;
		    break;
		  case 24:
		    *(outPtr++) = 255;
		  case 16:
		    *(outPtr++) = 255;
		  case 8: 
		    *(outPtr++) = 255;
		    break;
		  case 1:
		    outPtr[column / 8] |= (1 << (7 - (column & 7)));
		    break;
		  }
	    }
	  else if (effXDepth == 24 || effXDepth == 32)
	    {
	      ptr += posX * (effXBPP / 8);

	      /* Out of X icon bounds, leave space blank */
	      if (posX >= pixmap->drawable.width
		  || posY >= pixmap->drawable.height)
		ptr = (unsigned char *) &zero;
	      color = (((*ptr) << 16)
		       + ((*(ptr + 1)) << 8)
		       + ((*(ptr + 2)) << 0));
	      switch (effBPP)
		{
		case 32:
		  *(outPtr++) = *(ptr++); /* b */
		  *(outPtr++) = *(ptr++); /* g */
		  *(outPtr++) = *(ptr++); /* r */
		  *(outPtr++) = (effXDepth == 32) ? *(ptr++) : 0x0; /* alpha */
		  break;
		case 24:
		  *(outPtr++) = *(ptr++);
		  *(outPtr++) = *(ptr++);
		  *(outPtr++) = *(ptr++);
		  break;
		case 16:
		  color = ((((*ptr) >> 2) << 10)
			   + (((*(ptr + 1)) >> 2) << 5)
			   + (((*(ptr + 2)) >> 2)));
		  *(outPtr++) = (color >> 8);
		  *(outPtr++) = (color & 255);
		  break;
		case 8:
		  color = (((*ptr))) + (((*(ptr + 1)))) + (((*(ptr + 2))));
		  color /= 3;
		  *(outPtr++) = color;
		  break;
		case 1:
		  if (color)
		    outPtr[column / 8] |= (1 << (7 - (column & 7)));
		  else
		    outPtr[column / 8] &= ~(1 << (7 - (column & 7)));
		}
	    }
	  else if (effXDepth == 16)
	    {
	      ptr += posX * (effXBPP / 8);
	
	      /* Out of X icon bounds, leave space blank */
	      if (posX >= pixmap->drawable.width
		  || posY >= pixmap->drawable.height)
		ptr = (unsigned char *) &zero;
	      color = ((*ptr) << 8) + (*(ptr + 1));
	      switch (effBPP)
		{
		case 32:
		  *(outPtr++) = (color & 31) << 2;
		  *(outPtr++) = ((color >> 5) & 31) << 2;
		  *(outPtr++) = ((color >> 10) & 31) << 2;
		  *(outPtr++) = 0; /* resvd */
		  break;
		case 24:
		  *(outPtr++) = (color & 31) << 2;
		  *(outPtr++) = ((color >> 5) & 31) << 2;
		  *(outPtr++) = ((color >> 10) & 31) << 2;
		  break;
		case 16:
		  *(outPtr++) = *(ptr++);
		  *(outPtr++) = *(ptr++);
		  break;
		case 8:
		  *(outPtr++) = (((color & 31)
				  + ((color >> 5) & 31)
				  + ((color >> 10) & 31)) / 3) << 2;
		  break;
		case 1:
		  if (color)
		    outPtr[column / 8] |= (1 << (7 - (column & 7)));
		  else
		    outPtr[column / 8] &= ~(1 << (7 - (column & 7)));
		  break;
		} /* end switch(effbpp) */
	    } /* end if effxbpp==16) */
	} /* end for column */
    } /* end for row */
  free (iconData);
d245 1
a245 1
NetWMToWinIconAlpha(uint32_t *icon)
d247 31
a277 30
  int width = icon[0];
  int height = icon[1];
  uint32_t *pixels = &icon[2];
  HICON result;
  HDC hdc = GetDC(NULL);
  uint32_t *DIB_pixels;
  ICONINFO ii = {TRUE};
  BITMAPV4HEADER bmh = {sizeof(bmh)};

  /* Define an ARGB pixel format used for Color+Alpha icons */
  bmh.bV4Width = width;
  bmh.bV4Height = -height; /* Invert the image */
  bmh.bV4Planes = 1;
  bmh.bV4BitCount = 32;
  bmh.bV4V4Compression = BI_BITFIELDS;
  bmh.bV4AlphaMask = 0xFF000000;
  bmh.bV4RedMask =   0x00FF0000;
  bmh.bV4GreenMask = 0x0000FF00;
  bmh.bV4BlueMask =  0x000000FF;

  ii.hbmColor = CreateDIBSection(hdc, (BITMAPINFO*)&bmh,
                DIB_RGB_COLORS, (void**)&DIB_pixels, NULL, 0);
  ReleaseDC(NULL, hdc);
  ii.hbmMask = CreateBitmap(width, height, 1, 1, NULL);
  memcpy(DIB_pixels, pixels, height*width*4);

  /* CreateIconIndirect() traditionally required DDBitmaps */
  /* Systems from WinXP accept 32-bit ARGB DIBitmaps with full 8-bit alpha support */
  /* The icon is created with a DIB + empty DDB mask (an MS example does the same) */
  result = CreateIconIndirect(&ii);
d279 2
a280 2
  DeleteObject(ii.hbmColor);
  DeleteObject(ii.hbmMask);
d282 2
a283 2
  winDebug("NetWMToWinIconAlpha - %d x %d = %p\n", icon[0], icon[1], result);
  return result;
d287 1
a287 1
NetWMToWinIconThreshold(uint32_t *icon)
d289 34
a322 32
  int width = icon[0];
  int height = icon[1];
  uint32_t *pixels = &icon[2];
  int row, col;
  HICON result;
  ICONINFO ii = {TRUE};

  HDC hdc = GetDC(NULL);
  HDC xorDC = CreateCompatibleDC(hdc);
  HDC andDC = CreateCompatibleDC(hdc);
  ii.hbmColor = CreateCompatibleBitmap(hdc, width, height);
  ii.hbmMask = CreateCompatibleBitmap(hdc, width, height);
  ReleaseDC(NULL, hdc);
  SelectObject(xorDC, ii.hbmColor);
  SelectObject(andDC, ii.hbmMask);

  for (row = 0; row < height; row++) {
    for (col = 0; col < width; col++) {
      if ((*pixels & 0xFF000000) > 31<<24) { /* 31 alpha threshold, i.e. opaque above, transparent below */
	SetPixelV(xorDC, col, row, RGB(((char*)pixels)[2], ((char*)pixels)[1],
		((char*)pixels)[0]));
	SetPixelV(andDC, col, row, RGB(0, 0, 0)); /* black mask */
      }
      else {
	SetPixelV(xorDC, col, row, RGB(0, 0, 0));
	SetPixelV(andDC, col, row, RGB(255, 255, 255)); /* white mask */
      }
      pixels++;
    }
  }
  DeleteDC(xorDC);
  DeleteDC(andDC);
d324 1
a324 1
  result = CreateIconIndirect(&ii);
d326 2
a327 2
  DeleteObject(ii.hbmColor);
  DeleteObject(ii.hbmMask );
d329 3
a331 2
  winDebug("NetWMToWinIconThreshold - %d x %d = %p\n", icon[0], icon[1], result);
  return result;
d335 1
a335 1
NetWMToWinIcon(int bpp, uint32_t *icon)
d337 24
a360 2
  static Bool hasIconAlphaChannel = FALSE;
  static BOOL versionChecked = FALSE;
d362 4
a365 22
  if (!versionChecked)
    {
      OSVERSIONINFOEX osvi = {0};
      ULONGLONG dwlConditionMask = 0;

      osvi.dwOSVersionInfoSize = sizeof (osvi);
      osvi.dwMajorVersion = 5;
      osvi.dwMinorVersion = 1;

      /* Windows versions later than XP have icon alpha channel suport, 2000 does not */
      VER_SET_CONDITION(dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL);
      VER_SET_CONDITION(dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL);
      hasIconAlphaChannel = VerifyVersionInfo(&osvi, VER_MAJORVERSION | VER_MINORVERSION, dwlConditionMask);
      versionChecked = TRUE;

      ErrorF("OS has icon alpha channel support: %s\n", hasIconAlphaChannel ? "yes" : "no");
    }

  if (hasIconAlphaChannel && (bpp==32))
    return NetWMToWinIconAlpha(icon);
  else
    return NetWMToWinIconThreshold(icon);
d371 2
a372 2
  struct _Window	*pwin;
  struct _Property	*prop;
d374 3
a376 12
  if (!pWin || !name) {
    ErrorF ("GetWindowProp - pWin or name was NULL\n");
    return 0;
  }
  pwin = (struct _Window*) pWin;
  if (!pwin->optional) return NULL;
  for (prop = (struct _Property *) pwin->optional->userProps;
       prop;
       prop=prop->next){
    if (prop->propertyName == name) {
      *size_return=prop->size;
      return prop->data;
d378 11
a388 2
  }
  return NULL;
d396 1
a396 1
winXIconToHICON (WindowPtr pWin, int iconSize)
d398 99
a496 117
  unsigned char		*mask, *image, *imageMask;
  unsigned char		*dst, *src;
  PixmapPtr		iconPtr;
  PixmapPtr		maskPtr;
  int			planes, bpp, effBPP, stride, maskStride, i;
  int			biggest_size = 0;
  HDC			hDC;
  ICONINFO		ii;
  WinXWMHints		hints;
  HICON			hIcon = NULL;
  uint32_t		*biggest_icon = NULL;

  /* Try to get _NET_WM_ICON icons first */
  static Atom _XA_NET_WM_ICON;
  static int generation;
  uint32_t *icon, *icon_data = NULL;
  long int size=0;

  hDC = GetDC (GetDesktopWindow ());
  planes = GetDeviceCaps (hDC, PLANES);
  bpp = GetDeviceCaps (hDC, BITSPIXEL);
  ReleaseDC (GetDesktopWindow (), hDC);

  if (generation != serverGeneration) {
     generation = serverGeneration;
     _XA_NET_WM_ICON = MakeAtom("_NET_WM_ICON", 12, TRUE);
  }

  if (_XA_NET_WM_ICON) icon_data = GetWindowProp(pWin, _XA_NET_WM_ICON, &size);
  if (icon_data)
    {
      for(icon = icon_data;
	  icon < &icon_data[size] && *icon;
	  icon = &icon[icon[0]*icon[1]+2])
	{
	  if (icon[0]==iconSize && icon[1]==iconSize)
            return NetWMToWinIcon(bpp, icon);
	  /* Find the biggest icon and let Windows scale the size */
	  else if (biggest_size < icon[0])
	    {
	      biggest_icon = icon;
	      biggest_size = icon[0];
	    }
	}
      if (biggest_icon)
	return NetWMToWinIcon(bpp, biggest_icon);
    }
  winDebug("winXIconToHICON - pWin %x: no suitable NetIcon\n",(int)pWin, iconSize);

  winMultiWindowGetWMHints (pWin, &hints);
  if (!hints.icon_pixmap) return NULL;

  dixLookupResourceByType((pointer) &iconPtr, hints.icon_pixmap, RT_PIXMAP,
				NullClient, DixUnknownAccess);
  
  if (!iconPtr) return NULL;

  /* 15 BPP is really 16BPP as far as we care */
  if (bpp == 15)
    effBPP = 16;
  else
    effBPP = bpp;
  
  /* Need 16-bit aligned rows for DDBitmaps */
  stride = ((iconSize * effBPP + 15) & (~15)) / 8;

  /* Mask is 1-bit deep */
  maskStride = ((iconSize * 1 + 15) & (~15)) / 8;

  image = malloc (stride * iconSize);
  imageMask = malloc (stride * iconSize);
  /* Default to a completely black mask */
  mask = calloc (maskStride, iconSize);
  
  winScaleXBitmapToWindows (iconSize, effBPP, iconPtr, image);
  dixLookupResourceByType((pointer) &maskPtr, hints.icon_mask, RT_PIXMAP,
				NullClient, DixUnknownAccess);

  if (maskPtr) 
    {
      winScaleXBitmapToWindows (iconSize, 1, maskPtr, mask);
      
      winScaleXBitmapToWindows (iconSize, effBPP, maskPtr, imageMask);
      
      /* Now we need to set all bits of the icon which are not masked */
      /* on to 0 because Color is really an XOR, not an OR function */
      dst = image;
      src = imageMask;

      for (i = 0; i < (stride * iconSize); i++)
	if ((*(src++)))
	  *(dst++) = 0;
	else
	  dst++;
    }
  
  ii.fIcon = TRUE;
  ii.xHotspot = 0; /* ignored */
  ii.yHotspot = 0; /* ignored */
  
  /* Create Win32 mask from pixmap shape */
  ii.hbmMask = CreateBitmap (iconSize, iconSize, planes, 1, mask);

  /* Create Win32 bitmap from pixmap */
  ii.hbmColor = CreateBitmap (iconSize, iconSize, planes, bpp, image);

  /* Merge Win32 mask and bitmap into icon */
  hIcon = CreateIconIndirect (&ii);

  /* Release Win32 mask and bitmap */
  DeleteObject (ii.hbmMask);
  DeleteObject (ii.hbmColor);

  /* Free X mask and bitmap */
  free (mask);
  free (image);
  free (imageMask);
d498 12
a509 2
  return hIcon;
}
d511 4
d516 2
d525 1
a525 1
winUpdateIcon (Window id)
d527 2
a528 2
  WindowPtr		pWin;
  HICON			hIcon, hIconSmall=NULL, hIconOld;
d530 32
a561 15
  dixLookupResourceByType((pointer) &pWin, id, RT_WINDOW, NullClient, DixUnknownAccess);
  if (pWin)
    {
      winWindowPriv(pWin);
      if (pWinPriv->hWnd) {
        hIcon = winOverrideIcon ((unsigned long)pWin);
        if (!hIcon) {
          hIcon = winXIconToHICON (pWin, GetSystemMetrics(SM_CXICON));
          if (!hIcon) {
            hIcon = g_hIconX;
            hIconSmall = g_hSmallIconX;
          } else {
            /* Leave undefined if not found */
            hIconSmall = winXIconToHICON (pWin, GetSystemMetrics(SM_CXSMICON));
          }
d563 1
a563 14

        /* Set the large icon */
        hIconOld = (HICON) SendMessage (pWinPriv->hWnd,
                                        WM_SETICON, ICON_BIG, (LPARAM) hIcon);

        /* Delete the icon if its not the default */
        winDestroyIcon(hIconOld);

        /* Same for the small icon */
        hIconOld = (HICON) SendMessage (pWinPriv->hWnd,
                                        WM_SETICON, ICON_SMALL, (LPARAM) hIconSmall);
        winDestroyIcon(hIconOld);
      }
  }
d566 2
a567 1
void winInitGlobalIcons (void)
d569 21
a589 23
  int sm_cx = GetSystemMetrics(SM_CXICON);
  int sm_cxsm = GetSystemMetrics(SM_CXSMICON);
  /* Load default X icon in case it's not ready yet */
  if (!g_hIconX) 
    {  
      g_hIconX = winOverrideDefaultIcon(sm_cx);
      g_hSmallIconX = winOverrideDefaultIcon(sm_cxsm);
    }
  
  if (!g_hIconX)
    {   
      g_hIconX = (HICON)LoadImage (g_hInstance,
	      MAKEINTRESOURCE(IDI_XWIN),
	      IMAGE_ICON,
	      GetSystemMetrics(SM_CXICON),
	      GetSystemMetrics(SM_CYICON),
	      0);
      g_hSmallIconX = (HICON)LoadImage (g_hInstance,
	      MAKEINTRESOURCE(IDI_XWIN),
	      IMAGE_ICON,
	      GetSystemMetrics(SM_CXSMICON),
	      GetSystemMetrics(SM_CYSMICON),
	      LR_DEFAULTSIZE);
d593 2
a594 1
void winSelectIcons(WindowPtr pWin, HICON *pIcon, HICON *pSmallIcon)
d596 29
a624 30
  HICON hIcon, hSmallIcon;
  
  winInitGlobalIcons();  
  
  /* Try and get the icon from WM_HINTS */
  hIcon = winXIconToHICON (pWin, GetSystemMetrics(SM_CXICON));
  hSmallIcon = winXIconToHICON (pWin, GetSystemMetrics(SM_CXSMICON));

  /* If we got the small, but not the large one swap them */
  if (!hIcon && hSmallIcon) 
  {
      hIcon = hSmallIcon;
      hSmallIcon = NULL;
  }
  
  /* Use default X icon if no icon loaded from WM_HINTS */
  if (!hIcon) {
    hIcon = g_hIconX;
    hSmallIcon = g_hSmallIconX;
  }

  if (pIcon)
    *pIcon = hIcon;
  else
    winDestroyIcon(hIcon);

  if (pSmallIcon)
    *pSmallIcon = hSmallIcon;
  else
    winDestroyIcon(hSmallIcon);
d627 2
a628 1
void winDestroyIcon(HICON hIcon)
d630 5
a634 6
  /* Delete the icon if its not one of the application defaults or an override */
  if (hIcon &&
      hIcon != g_hIconX &&
      hIcon != g_hSmallIconX &&
      !winIconIsOverride((unsigned long)hIcon))
    DestroyIcon (hIcon);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a39 2

#include "propertyst.h"
a41 7
/*
 * External global variables
 */

extern HICON		g_hIconX;
extern HICON		g_hSmallIconX;

d625 1
d634 1
a634 1
  /* Delete the icon if its not the default */
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d39 4
d73 1
a73 1
  unsigned char		*iconData = 0;
d90 2
a91 2
  /* Need 32-bit aligned rows */
  stride = ((iconSize * effBPP + 31) & (~31)) / 8;
d133 1
a133 1
	  ptr = iconData + posY*xStride;
d194 4
a197 4
		  *(outPtr++) = *(ptr++); // b
		  *(outPtr++) = *(ptr++); // g
		  *(outPtr++) = *(ptr++); // r
		  *(outPtr++) = 0; // resvd
d238 1
a238 1
		  *(outPtr++) = 0; // resvd
d267 138
d418 1
d422 2
a423 1
  HICON			hIcon;
d425 5
a429 2
  winMultiWindowGetWMHints (pWin, &hints);
  if (!hints.icon_pixmap) return NULL;
a430 4
  iconPtr = (PixmapPtr) LookupIDByType (hints.icon_pixmap, RT_PIXMAP);
  
  if (!iconPtr) return NULL;
  
d435 32
d468 2
d476 2
a477 2
  /* Need 32-bit aligned rows */
  stride = ((iconSize * effBPP + 31) & (~31)) / 8;
d480 1
a480 1
  maskStride = ((iconSize * 1 + 31) & (~31)) / 8; 
d488 2
a489 1
  maskPtr = (PixmapPtr) LookupIDByType (hints.icon_mask, RT_PIXMAP);
d545 1
a545 5
  HICON			hIcon, hiconOld;

  pWin = (WindowPtr) LookupIDByType (id, RT_WINDOW);
  if (!pWin) return;
  hIcon = (HICON)winOverrideIcon ((unsigned long)pWin);
d547 2
a548 4
  if (!hIcon)
    hIcon = winXIconToHICON (pWin, GetSystemMetrics(SM_CXICON));

  if (hIcon)
d551 26
a576 25

      if (pWinPriv->hWnd)
	{
	  hiconOld = (HICON) SetClassLong (pWinPriv->hWnd,
					   GCL_HICON,
					   (int) hIcon);
	  
	  /* Delete the icon if its not the default */
	  winDestroyIcon(hiconOld);
	}
    }
 
  hIcon = winXIconToHICON (pWin, GetSystemMetrics(SM_CXSMICON));
  if (hIcon)
    {
      winWindowPriv(pWin);

      if (pWinPriv->hWnd)
	{
	  hiconOld = (HICON) SetClassLong (pWinPriv->hWnd,
					   GCL_HICONSM,
					   (int) hIcon);
	  winDestroyIcon (hiconOld);
	}
    }
d586 2
a587 2
      g_hIconX = (HICON)winOverrideDefaultIcon(sm_cx);
      g_hSmallIconX = (HICON)winOverrideDefaultIcon(sm_cxsm);
@


1.1
log
@Initial revision
@
text
@d305 2
a306 4
  image = (unsigned char * ) malloc (stride * iconSize);
  imageMask = (unsigned char *) malloc (stride * iconSize);
  mask = (unsigned char *) malloc (maskStride * iconSize);
  
d308 1
a308 1
  memset (mask, 0, maskStride * iconSize);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
