head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Dakshinamurthy Karra
 *		Suhaib M Siddiqi
 *		Peter Busch
 *		Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

#define FAIL_MSG_MAX_BLT	10

/*
 * Local prototypes
 */

static Bool
 winAllocateFBShadowDDNL(ScreenPtr pScreen);

static void
 winShadowUpdateDDNL(ScreenPtr pScreen, shadowBufPtr pBuf);

static Bool
 winCloseScreenShadowDDNL(ScreenPtr pScreen);

static Bool
 winInitVisualsShadowDDNL(ScreenPtr pScreen);

static Bool
 winAdjustVideoModeShadowDDNL(ScreenPtr pScreen);

static Bool
 winBltExposedRegionsShadowDDNL(ScreenPtr pScreen);

static Bool
 winActivateAppShadowDDNL(ScreenPtr pScreen);

static Bool
 winRedrawScreenShadowDDNL(ScreenPtr pScreen);

static Bool
 winRealizeInstalledPaletteShadowDDNL(ScreenPtr pScreen);

static Bool
 winInstallColormapShadowDDNL(ColormapPtr pColormap);

static Bool
 winStoreColorsShadowDDNL(ColormapPtr pmap, int ndef, xColorItem * pdefs);

static Bool
 winCreateColormapShadowDDNL(ColormapPtr pColormap);

static Bool
 winDestroyColormapShadowDDNL(ColormapPtr pColormap);

static Bool
 winCreatePrimarySurfaceShadowDDNL(ScreenPtr pScreen);

static Bool
 winReleasePrimarySurfaceShadowDDNL(ScreenPtr pScreen);

/*
 * Create the primary surface and attach the clipper.
 * Used for both the initial surface creation and during
 * WM_DISPLAYCHANGE messages.
 */

static Bool
winCreatePrimarySurfaceShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    HRESULT ddrval = DD_OK;
    DDSURFACEDESC2 ddsd;

    winDebug("winCreatePrimarySurfaceShadowDDNL - Creating primary surface\n");

    /* Describe the primary surface */
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

    /* Create the primary surface */
    ddrval = IDirectDraw4_CreateSurface(pScreenPriv->pdd4,
                                        &ddsd,
                                        &pScreenPriv->pddsPrimary4, NULL);
    pScreenPriv->fRetryCreateSurface = FALSE;
    if (FAILED(ddrval)) {
        if (ddrval == DDERR_NOEXCLUSIVEMODE) {
            /* Recreating the surface failed. Mark screen to retry later */
            pScreenPriv->fRetryCreateSurface = TRUE;
            winDebug("winCreatePrimarySurfaceShadowDDNL - Could not create "
                     "primary surface: DDERR_NOEXCLUSIVEMODE\n");
        }
        else {
            ErrorF("winCreatePrimarySurfaceShadowDDNL - Could not create "
                   "primary surface: %08x\n", (unsigned int) ddrval);
        }
        return FALSE;
    }

#if 1
    winDebug("winCreatePrimarySurfaceShadowDDNL - Created primary surface\n");
#endif

    /* Attach our clipper to our primary surface handle */
    ddrval = IDirectDrawSurface4_SetClipper(pScreenPriv->pddsPrimary4,
                                            pScreenPriv->pddcPrimary);
    if (FAILED(ddrval)) {
        ErrorF("winCreatePrimarySurfaceShadowDDNL - Primary attach clipper "
               "failed: %08x\n", (unsigned int) ddrval);
        return FALSE;
    }

#if 1
    winDebug("winCreatePrimarySurfaceShadowDDNL - Attached clipper to primary "
             "surface\n");
#endif

    /* Everything was correct */
    return TRUE;
}

/*
 * Detach the clipper and release the primary surface.
 * Called from WM_DISPLAYCHANGE.
 */

static Bool
winReleasePrimarySurfaceShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);

    winDebug("winReleasePrimarySurfaceShadowDDNL - Hello\n");

    /* Release the primary surface and clipper, if they exist */
    if (pScreenPriv->pddsPrimary4) {
        /*
         * Detach the clipper from the primary surface.
         * NOTE: We do this explicity for clarity.  The Clipper is not released.
         */
        IDirectDrawSurface4_SetClipper(pScreenPriv->pddsPrimary4, NULL);

        winDebug("winReleasePrimarySurfaceShadowDDNL - Detached clipper\n");

        /* Release the primary surface */
        IDirectDrawSurface4_Release(pScreenPriv->pddsPrimary4);
        pScreenPriv->pddsPrimary4 = NULL;
    }

    winDebug("winReleasePrimarySurfaceShadowDDNL - Released primary surface\n");

    return TRUE;
}

/*
 * Create a DirectDraw surface for the shadow framebuffer; also create
 * a primary surface object so we can blit to the display.
 *
 * Install a DirectDraw clipper on our primary surface object
 * that clips our blits to the unobscured client area of our display window.
 */

Bool
winAllocateFBShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    HRESULT ddrval = DD_OK;
    DDSURFACEDESC2 ddsdShadow;
    char *lpSurface = NULL;
    DDPIXELFORMAT ddpfPrimary;

#if CYGDEBUG
    winDebug("winAllocateFBShadowDDNL - w %u h %u d %u\n",
             (unsigned int)pScreenInfo->dwWidth,
             (unsigned int)pScreenInfo->dwHeight,
             (unsigned int)pScreenInfo->dwDepth);
#endif

    /* Set the padded screen width */
    pScreenInfo->dwPaddedWidth = PixmapBytePad(pScreenInfo->dwWidth,
                                               pScreenInfo->dwBPP);

    /* Allocate memory for our shadow surface */
    lpSurface = malloc(pScreenInfo->dwPaddedWidth * pScreenInfo->dwHeight);
    if (lpSurface == NULL) {
        ErrorF("winAllocateFBShadowDDNL - Could not allocate bits\n");
        return FALSE;
    }

    /*
     * Initialize the framebuffer memory so we don't get a
     * strange display at startup
     */
    ZeroMemory(lpSurface, pScreenInfo->dwPaddedWidth * pScreenInfo->dwHeight);

    /* Create a clipper */
    ddrval = (*g_fpDirectDrawCreateClipper) (0,
                                             &pScreenPriv->pddcPrimary, NULL);
    if (FAILED(ddrval)) {
        ErrorF("winAllocateFBShadowDDNL - Could not attach clipper: %08x\n",
               (unsigned int) ddrval);
        return FALSE;
    }

#if CYGDEBUG
    winDebug("winAllocateFBShadowDDNL - Created a clipper\n");
#endif

    /* Attach the clipper to our display window */
    ddrval = IDirectDrawClipper_SetHWnd(pScreenPriv->pddcPrimary,
                                        0, pScreenPriv->hwndScreen);
    if (FAILED(ddrval)) {
        ErrorF("winAllocateFBShadowDDNL - Clipper not attached "
               "to window: %08x\n", (unsigned int) ddrval);
        return FALSE;
    }

#if CYGDEBUG
    winDebug("winAllocateFBShadowDDNL - Attached clipper to window\n");
#endif

    /* Create a DirectDraw object, store the address at lpdd */
    ddrval = (*g_fpDirectDrawCreate) (NULL,
                                      (LPDIRECTDRAW *) &pScreenPriv->pdd,
                                      NULL);
    if (FAILED(ddrval)) {
        ErrorF("winAllocateFBShadowDDNL - Could not start "
               "DirectDraw: %08x\n", (unsigned int) ddrval);
        return FALSE;
    }

#if CYGDEBUG
    winDebug("winAllocateFBShadowDDNL - Created and initialized DD\n");
#endif

    /* Get a DirectDraw4 interface pointer */
    ddrval = IDirectDraw_QueryInterface(pScreenPriv->pdd,
                                        &IID_IDirectDraw4,
                                        (LPVOID *) &pScreenPriv->pdd4);
    if (FAILED(ddrval)) {
        ErrorF("winAllocateFBShadowDDNL - Failed DD4 query: %08x\n",
               (unsigned int) ddrval);
        return FALSE;
    }

    /* Are we full screen? */
    if (pScreenInfo->fFullScreen) {
        DDSURFACEDESC2 ddsdCurrent;
        DWORD dwRefreshRateCurrent = 0;
        HDC hdc = NULL;

        /* Set the cooperative level to full screen */
        ddrval = IDirectDraw4_SetCooperativeLevel(pScreenPriv->pdd4,
                                                  pScreenPriv->hwndScreen,
                                                  DDSCL_EXCLUSIVE
                                                  | DDSCL_FULLSCREEN);
        if (FAILED(ddrval)) {
            ErrorF("winAllocateFBShadowDDNL - Could not set "
                   "cooperative level: %08x\n", (unsigned int) ddrval);
            return FALSE;
        }

        /*
         * We only need to get the current refresh rate for comparison
         * if a refresh rate has been passed on the command line.
         */
        if (pScreenInfo->dwRefreshRate != 0) {
            ZeroMemory(&ddsdCurrent, sizeof(ddsdCurrent));
            ddsdCurrent.dwSize = sizeof(ddsdCurrent);

            /* Get information about current display settings */
            ddrval = IDirectDraw4_GetDisplayMode(pScreenPriv->pdd4,
                                                 &ddsdCurrent);
            if (FAILED(ddrval)) {
                ErrorF("winAllocateFBShadowDDNL - Could not get current "
                       "refresh rate: %08x.  Continuing.\n",
                       (unsigned int) ddrval);
                dwRefreshRateCurrent = 0;
            }
            else {
                /* Grab the current refresh rate */
                dwRefreshRateCurrent = ddsdCurrent.u2.dwRefreshRate;
            }
        }

        /* Clean up the refresh rate */
        if (dwRefreshRateCurrent == pScreenInfo->dwRefreshRate) {
            /*
             * Refresh rate is non-specified or equal to current.
             */
            pScreenInfo->dwRefreshRate = 0;
        }

        /* Grab a device context for the screen */
        hdc = GetDC(NULL);
        if (hdc == NULL) {
            ErrorF("winAllocateFBShadowDDNL - GetDC () failed\n");
            return FALSE;
        }

        /* Only change the video mode when different than current mode */
        if (!pScreenInfo->fMultipleMonitors
            && (pScreenInfo->dwWidth != GetSystemMetrics(SM_CXSCREEN)
                || pScreenInfo->dwHeight != GetSystemMetrics(SM_CYSCREEN)
                || pScreenInfo->dwBPP != GetDeviceCaps(hdc, BITSPIXEL)
                || pScreenInfo->dwRefreshRate != 0)) {
            winDebug("winAllocateFBShadowDDNL - Changing video mode\n");

            /* Change the video mode to the mode requested, and use the driver default refresh rate on failure */
            ddrval = IDirectDraw4_SetDisplayMode(pScreenPriv->pdd4,
                                                 pScreenInfo->dwWidth,
                                                 pScreenInfo->dwHeight,
                                                 pScreenInfo->dwBPP,
                                                 pScreenInfo->dwRefreshRate, 0);
            if (FAILED(ddrval)) {
                ErrorF("winAllocateFBShadowDDNL - Could not set "
                       "full screen display mode: %08x\n",
                       (unsigned int) ddrval);
                ErrorF
                    ("winAllocateFBShadowDDNL - Using default driver refresh rate\n");
                ddrval =
                    IDirectDraw4_SetDisplayMode(pScreenPriv->pdd4,
                                                pScreenInfo->dwWidth,
                                                pScreenInfo->dwHeight,
                                                pScreenInfo->dwBPP, 0, 0);
                if (FAILED(ddrval)) {
                    ErrorF
                        ("winAllocateFBShadowDDNL - Could not set default refresh rate "
                         "full screen display mode: %08x\n",
                         (unsigned int) ddrval);
                    return FALSE;
                }
            }
        }
        else {
            winDebug("winAllocateFBShadowDDNL - Not changing video mode\n");
        }

        /* Release our DC */
        ReleaseDC(NULL, hdc);
        hdc = NULL;
    }
    else {
        /* Set the cooperative level for windowed mode */
        ddrval = IDirectDraw4_SetCooperativeLevel(pScreenPriv->pdd4,
                                                  pScreenPriv->hwndScreen,
                                                  DDSCL_NORMAL);
        if (FAILED(ddrval)) {
            ErrorF("winAllocateFBShadowDDNL - Could not set "
                   "cooperative level: %08x\n", (unsigned int) ddrval);
            return FALSE;
        }
    }

    /* Create the primary surface */
    if (!winCreatePrimarySurfaceShadowDDNL(pScreen)) {
        ErrorF("winAllocateFBShadowDDNL - winCreatePrimarySurfaceShadowDDNL "
               "failed\n");
        return FALSE;
    }

    /* Get primary surface's pixel format */
    ZeroMemory(&ddpfPrimary, sizeof(ddpfPrimary));
    ddpfPrimary.dwSize = sizeof(ddpfPrimary);
    ddrval = IDirectDrawSurface4_GetPixelFormat(pScreenPriv->pddsPrimary4,
                                                &ddpfPrimary);
    if (FAILED(ddrval)) {
        ErrorF("winAllocateFBShadowDDNL - Could not get primary "
               "pixformat: %08x\n", (unsigned int) ddrval);
        return FALSE;
    }

#if CYGDEBUG
    winDebug("winAllocateFBShadowDDNL - Primary masks: %08x %08x %08x "
             "dwRGBBitCount: %u\n",
             (unsigned int)ddpfPrimary.u2.dwRBitMask,
             (unsigned int)ddpfPrimary.u3.dwGBitMask,
             (unsigned int)ddpfPrimary.u4.dwBBitMask,
             (unsigned int)ddpfPrimary.u1.dwRGBBitCount);
#endif

    /* Describe the shadow surface to be created */
    /*
     * NOTE: Do not use a DDSCAPS_VIDEOMEMORY surface,
     * as drawing, locking, and unlocking take forever
     * with video memory surfaces.  In addition,
     * video memory is a somewhat scarce resource,
     * so you shouldn't be allocating video memory when
     * you have the option of using system memory instead.
     */
    ZeroMemory(&ddsdShadow, sizeof(ddsdShadow));
    ddsdShadow.dwSize = sizeof(ddsdShadow);
    ddsdShadow.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH
        | DDSD_LPSURFACE | DDSD_PITCH | DDSD_PIXELFORMAT;
    ddsdShadow.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
    ddsdShadow.dwHeight = pScreenInfo->dwHeight;
    ddsdShadow.dwWidth = pScreenInfo->dwWidth;
    ddsdShadow.u1.lPitch = pScreenInfo->dwPaddedWidth;
    ddsdShadow.lpSurface = lpSurface;
    ddsdShadow.u4.ddpfPixelFormat = ddpfPrimary;

    winDebug("winAllocateFBShadowDDNL - lPitch: %d\n",
             (int) pScreenInfo->dwPaddedWidth);

    /* Create the shadow surface */
    ddrval = IDirectDraw4_CreateSurface(pScreenPriv->pdd4,
                                        &ddsdShadow,
                                        &pScreenPriv->pddsShadow4, NULL);
    if (FAILED(ddrval)) {
        ErrorF("winAllocateFBShadowDDNL - Could not create shadow "
               "surface: %08x\n", (unsigned int) ddrval);
        return FALSE;
    }

#if CYGDEBUG || YES
    winDebug("winAllocateFBShadowDDNL - Created shadow pitch: %d\n",
             (int) ddsdShadow.u1.lPitch);
#endif

    /* Grab the pitch from the surface desc */
    pScreenInfo->dwStride = (ddsdShadow.u1.lPitch * 8)
        / pScreenInfo->dwBPP;

#if CYGDEBUG || YES
    winDebug("winAllocateFBShadowDDNL - Created shadow stride: %d\n",
             (int) pScreenInfo->dwStride);
#endif

    /* Save the pointer to our surface memory */
    pScreenInfo->pfb = lpSurface;

    /* Grab the masks from the surface description */
    pScreenPriv->dwRedMask = ddsdShadow.u4.ddpfPixelFormat.u2.dwRBitMask;
    pScreenPriv->dwGreenMask = ddsdShadow.u4.ddpfPixelFormat.u3.dwGBitMask;
    pScreenPriv->dwBlueMask = ddsdShadow.u4.ddpfPixelFormat.u4.dwBBitMask;

#if CYGDEBUG
    winDebug("winAllocateFBShadowDDNL - Returning\n");
#endif

    return TRUE;
}

static void
winFreeFBShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Free the shadow surface, if there is one */
    if (pScreenPriv->pddsShadow4) {
        IDirectDrawSurface4_Release(pScreenPriv->pddsShadow4);
        free(pScreenInfo->pfb);
        pScreenInfo->pfb = NULL;
        pScreenPriv->pddsShadow4 = NULL;
    }

    /* Detach the clipper from the primary surface and release the primary surface, if there is one */
    winReleasePrimarySurfaceShadowDDNL(pScreen);

    /* Release the clipper object */
    if (pScreenPriv->pddcPrimary) {
        IDirectDrawClipper_Release(pScreenPriv->pddcPrimary);
        pScreenPriv->pddcPrimary = NULL;
    }

    /* Free the DirectDraw4 object, if there is one */
    if (pScreenPriv->pdd4) {
        IDirectDraw4_RestoreDisplayMode(pScreenPriv->pdd4);
        IDirectDraw4_Release(pScreenPriv->pdd4);
        pScreenPriv->pdd4 = NULL;
    }

    /* Free the DirectDraw object, if there is one */
    if (pScreenPriv->pdd) {
        IDirectDraw_Release(pScreenPriv->pdd);
        pScreenPriv->pdd = NULL;
    }

    /* Invalidate the ScreenInfo's fb pointer */
    pScreenInfo->pfb = NULL;
}

/*
 * Transfer the damaged regions of the shadow framebuffer to the display.
 */

static void
winShadowUpdateDDNL(ScreenPtr pScreen, shadowBufPtr pBuf)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    RegionPtr damage = shadowDamage(pBuf);
    HRESULT ddrval = DD_OK;
    RECT rcDest, rcSrc;
    POINT ptOrigin;
    DWORD dwBox = RegionNumRects(damage);
    BoxPtr pBox = RegionRects(damage);
    HRGN hrgnCombined = NULL;

    /*
     * Return immediately if the app is not active
     * and we are fullscreen, or if we have a bad display depth
     */
    if ((!pScreenPriv->fActive && pScreenInfo->fFullScreen)
        || pScreenPriv->fBadDepth)
        return;

    /* Return immediately if we didn't get needed surfaces */
    if (!pScreenPriv->pddsPrimary4 || !pScreenPriv->pddsShadow4)
        return;

    /* Get the origin of the window in the screen coords */
    ptOrigin.x = pScreenInfo->dwXOffset;
    ptOrigin.y = pScreenInfo->dwYOffset;
    MapWindowPoints(pScreenPriv->hwndScreen,
                    HWND_DESKTOP, (LPPOINT) &ptOrigin, 1);

    /*
     * Handle small regions with multiple blits,
     * handle large regions by creating a clipping region and
     * doing a single blit constrained to that clipping region.
     */
    if (pScreenInfo->dwClipUpdatesNBoxes == 0
        || dwBox < pScreenInfo->dwClipUpdatesNBoxes) {
        /* Loop through all boxes in the damaged region */
        while (dwBox--) {
            /* Assign damage box to source rectangle */
            rcSrc.left = pBox->x1;
            rcSrc.top = pBox->y1;
            rcSrc.right = pBox->x2;
            rcSrc.bottom = pBox->y2;

            /* Calculate destination rectangle */
            rcDest.left = ptOrigin.x + rcSrc.left;
            rcDest.top = ptOrigin.y + rcSrc.top;
            rcDest.right = ptOrigin.x + rcSrc.right;
            rcDest.bottom = ptOrigin.y + rcSrc.bottom;

            /* Blit the damaged areas */
            ddrval = IDirectDrawSurface4_Blt(pScreenPriv->pddsPrimary4,
                                             &rcDest,
                                             pScreenPriv->pddsShadow4,
                                             &rcSrc, DDBLT_WAIT, NULL);
            if (FAILED(ddrval)) {
                static int s_iFailCount = 0;

                if (s_iFailCount < FAIL_MSG_MAX_BLT) {
                    ErrorF("winShadowUpdateDDNL - IDirectDrawSurface4_Blt () "
                           "failed: %08x\n", (unsigned int) ddrval);

                    ++s_iFailCount;

                    if (s_iFailCount == FAIL_MSG_MAX_BLT) {
                        ErrorF("winShadowUpdateDDNL - IDirectDrawSurface4_Blt "
                               "failure message maximum (%d) reached.  No "
                               "more failure messages will be printed.\n",
                               FAIL_MSG_MAX_BLT);
                    }
                }
            }

            /* Get a pointer to the next box */
            ++pBox;
        }
    }
    else {
        BoxPtr pBoxExtents = RegionExtents(damage);

        /* Compute a GDI region from the damaged region */
        hrgnCombined =
            CreateRectRgn(pBoxExtents->x1, pBoxExtents->y1, pBoxExtents->x2,
                          pBoxExtents->y2);

        /* Install the GDI region as a clipping region */
        SelectClipRgn(pScreenPriv->hdcScreen, hrgnCombined);
        DeleteObject(hrgnCombined);
        hrgnCombined = NULL;

#if CYGDEBUG
        winDebug("winShadowUpdateDDNL - be x1 %d y1 %d x2 %d y2 %d\n",
                 pBoxExtents->x1, pBoxExtents->y1,
                 pBoxExtents->x2, pBoxExtents->y2);
#endif

        /* Calculating a bounding box for the source is easy */
        rcSrc.left = pBoxExtents->x1;
        rcSrc.top = pBoxExtents->y1;
        rcSrc.right = pBoxExtents->x2;
        rcSrc.bottom = pBoxExtents->y2;

        /* Calculating a bounding box for the destination is trickier */
        rcDest.left = ptOrigin.x + rcSrc.left;
        rcDest.top = ptOrigin.y + rcSrc.top;
        rcDest.right = ptOrigin.x + rcSrc.right;
        rcDest.bottom = ptOrigin.y + rcSrc.bottom;

        /* Our Blt should be clipped to the invalidated region */
        ddrval = IDirectDrawSurface4_Blt(pScreenPriv->pddsPrimary4,
                                         &rcDest,
                                         pScreenPriv->pddsShadow4,
                                         &rcSrc, DDBLT_WAIT, NULL);

        /* Reset the clip region */
        SelectClipRgn(pScreenPriv->hdcScreen, NULL);
    }
}

static Bool
winInitScreenShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);

    /* Get a device context for the screen  */
    pScreenPriv->hdcScreen = GetDC(pScreenPriv->hwndScreen);

    return winAllocateFBShadowDDNL(pScreen);
}

/*
 * Call the wrapped CloseScreen function.
 *
 * Free our resources and private structures.
 */

static Bool
winCloseScreenShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    Bool fReturn;

#if CYGDEBUG
    winDebug("winCloseScreenShadowDDNL - Freeing screen resources\n");
#endif

    /* Flag that the screen is closed */
    pScreenPriv->fClosed = TRUE;
    pScreenPriv->fActive = FALSE;

    /* Call the wrapped CloseScreen procedure */
    WIN_UNWRAP(CloseScreen);
    if (pScreen->CloseScreen)
        fReturn = (*pScreen->CloseScreen) (pScreen);

    winFreeFBShadowDDNL(pScreen);

    /* Free the screen DC */
    ReleaseDC(pScreenPriv->hwndScreen, pScreenPriv->hdcScreen);

    /* Delete the window property */
    RemoveProp(pScreenPriv->hwndScreen, WIN_SCR_PROP);

    /* Delete tray icon, if we have one */
    if (!pScreenInfo->fNoTrayIcon)
        winDeleteNotifyIcon(pScreenPriv);

    /* Free the exit confirmation dialog box, if it exists */
    if (g_hDlgExit != NULL) {
        DestroyWindow(g_hDlgExit);
        g_hDlgExit = NULL;
    }

    /* Kill our window */
    if (pScreenPriv->hwndScreen) {
        DestroyWindow(pScreenPriv->hwndScreen);
        pScreenPriv->hwndScreen = NULL;
    }

#if defined(XWIN_CLIPBOARD) || defined(XWIN_MULTIWINDOW)
    /* Destroy the thread startup mutex */
    pthread_mutex_destroy(&pScreenPriv->pmServerStarted);
#endif

    /* Kill our screeninfo's pointer to the screen */
    pScreenInfo->pScreen = NULL;

    /* Free the screen privates for this screen */
    free((void *) pScreenPriv);

    return fReturn;
}

/*
 * Tell mi what sort of visuals we need.
 *
 * Generally we only need one visual, as our screen can only
 * handle one format at a time, I believe.  You may want
 * to verify that last sentence.
 */

static Bool
winInitVisualsShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    DWORD dwRedBits, dwGreenBits, dwBlueBits;

    /* Count the number of ones in each color mask */
    dwRedBits = winCountBits(pScreenPriv->dwRedMask);
    dwGreenBits = winCountBits(pScreenPriv->dwGreenMask);
    dwBlueBits = winCountBits(pScreenPriv->dwBlueMask);

    /* Store the maximum number of ones in a color mask as the bitsPerRGB */
    if (dwRedBits == 0 || dwGreenBits == 0 || dwBlueBits == 0)
        pScreenPriv->dwBitsPerRGB = 8;
    else if (dwRedBits > dwGreenBits && dwRedBits > dwBlueBits)
        pScreenPriv->dwBitsPerRGB = dwRedBits;
    else if (dwGreenBits > dwRedBits && dwGreenBits > dwBlueBits)
        pScreenPriv->dwBitsPerRGB = dwGreenBits;
    else
        pScreenPriv->dwBitsPerRGB = dwBlueBits;

    winDebug("winInitVisualsShadowDDNL - Masks %08x %08x %08x BPRGB %d d %d "
             "bpp %d\n",
             (unsigned int) pScreenPriv->dwRedMask,
             (unsigned int) pScreenPriv->dwGreenMask,
             (unsigned int) pScreenPriv->dwBlueMask,
             (int) pScreenPriv->dwBitsPerRGB,
             (int) pScreenInfo->dwDepth, (int) pScreenInfo->dwBPP);

    /* Create a single visual according to the Windows screen depth */
    switch (pScreenInfo->dwDepth) {
    case 24:
    case 16:
    case 15:
        /* Setup the real visual */
        if (!miSetVisualTypesAndMasks(pScreenInfo->dwDepth,
                                      TrueColorMask,
                                      pScreenPriv->dwBitsPerRGB,
                                      -1,
                                      pScreenPriv->dwRedMask,
                                      pScreenPriv->dwGreenMask,
                                      pScreenPriv->dwBlueMask)) {
            ErrorF("winInitVisualsShadowDDNL - miSetVisualTypesAndMasks "
                   "failed for TrueColor\n");
            return FALSE;
        }

#ifdef XWIN_EMULATEPSEUDO
        if (!pScreenInfo->fEmulatePseudo)
            break;

        /* Setup a pseudocolor visual */
        if (!miSetVisualTypesAndMasks(8, PseudoColorMask, 8, -1, 0, 0, 0)) {
            ErrorF("winInitVisualsShadowDDNL - miSetVisualTypesAndMasks "
                   "failed for PseudoColor\n");
            return FALSE;
        }
#endif
        break;

    case 8:
        if (!miSetVisualTypesAndMasks(pScreenInfo->dwDepth,
                                      pScreenInfo->fFullScreen
                                      ? PseudoColorMask : StaticColorMask,
                                      pScreenPriv->dwBitsPerRGB,
                                      pScreenInfo->fFullScreen
                                      ? PseudoColor : StaticColor,
                                      pScreenPriv->dwRedMask,
                                      pScreenPriv->dwGreenMask,
                                      pScreenPriv->dwBlueMask)) {
            ErrorF("winInitVisualsShadowDDNL - miSetVisualTypesAndMasks "
                   "failed\n");
            return FALSE;
        }
        break;

    default:
        ErrorF("winInitVisualsShadowDDNL - Unknown screen depth\n");
        return FALSE;
    }

#if CYGDEBUG
    winDebug("winInitVisualsShadowDDNL - Returning\n");
#endif

    return TRUE;
}

/*
 * Adjust the user proposed video mode
 */

static Bool
winAdjustVideoModeShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    HDC hdc = NULL;
    DWORD dwBPP;

    /* We're in serious trouble if we can't get a DC */
    hdc = GetDC(NULL);
    if (hdc == NULL) {
        ErrorF("winAdjustVideoModeShadowDDNL - GetDC () failed\n");
        return FALSE;
    }

    /* Query GDI for current display depth */
    dwBPP = GetDeviceCaps(hdc, BITSPIXEL);

    /* DirectDraw can only change the depth in fullscreen mode */
    if (!(pScreenInfo->fFullScreen && (pScreenInfo->dwBPP != WIN_DEFAULT_BPP))) {
        /* Otherwise, We'll use GDI's depth */
        pScreenInfo->dwBPP = dwBPP;
    }

    /* Release our DC */
    ReleaseDC(NULL, hdc);

    return TRUE;
}

/*
 * Blt exposed regions to the screen
 */

static Bool
winBltExposedRegionsShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    RECT rcSrc, rcDest;
    POINT ptOrigin;
    HDC hdcUpdate;
    PAINTSTRUCT ps;
    HRESULT ddrval = DD_OK;
    Bool fReturn = TRUE;
    int i;

    /* Quite common case. The primary surface was lost (maybe because of depth
     * change). Try to create a new primary surface. Bail out if this fails */
    if (pScreenPriv->pddsPrimary4 == NULL && pScreenPriv->fRetryCreateSurface &&
        !winCreatePrimarySurfaceShadowDDNL(pScreen)) {
        Sleep(100);
        return FALSE;
    }
    if (pScreenPriv->pddsPrimary4 == NULL)
        return FALSE;

    /* BeginPaint gives us an hdc that clips to the invalidated region */
    hdcUpdate = BeginPaint(pScreenPriv->hwndScreen, &ps);
    if (hdcUpdate == NULL) {
        fReturn = FALSE;
        ErrorF("winBltExposedRegionsShadowDDNL - BeginPaint () returned "
               "a NULL device context handle.  Aborting blit attempt.\n");
        goto winBltExposedRegionsShadowDDNL_Exit;
    }

    /* Get the origin of the window in the screen coords */
    ptOrigin.x = pScreenInfo->dwXOffset;
    ptOrigin.y = pScreenInfo->dwYOffset;

    MapWindowPoints(pScreenPriv->hwndScreen,
                    HWND_DESKTOP, (LPPOINT) &ptOrigin, 1);
    rcDest.left = ptOrigin.x;
    rcDest.right = ptOrigin.x + pScreenInfo->dwWidth;
    rcDest.top = ptOrigin.y;
    rcDest.bottom = ptOrigin.y + pScreenInfo->dwHeight;

    /* Source can be entire shadow surface, as Blt should clip for us */
    rcSrc.left = 0;
    rcSrc.top = 0;
    rcSrc.right = pScreenInfo->dwWidth;
    rcSrc.bottom = pScreenInfo->dwHeight;

    /* Try to regain the primary surface and blit again if we've lost it */
    for (i = 0; i <= WIN_REGAIN_SURFACE_RETRIES; ++i) {
        /* Our Blt should be clipped to the invalidated region */
        ddrval = IDirectDrawSurface4_Blt(pScreenPriv->pddsPrimary4,
                                         &rcDest,
                                         pScreenPriv->pddsShadow4,
                                         &rcSrc, DDBLT_WAIT, NULL);
        if (ddrval == DDERR_SURFACELOST) {
            /* Surface was lost */
            winErrorFVerb(1, "winBltExposedRegionsShadowDDNL - "
                          "IDirectDrawSurface4_Blt reported that the primary "
                          "surface was lost, trying to restore, retry: %d\n",
                          i + 1);

            /* Try to restore the surface, once */

            ddrval = IDirectDrawSurface4_Restore(pScreenPriv->pddsPrimary4);
            winDebug("winBltExposedRegionsShadowDDNL - "
                     "IDirectDrawSurface4_Restore returned: ");
            if (ddrval == DD_OK)
                winDebug("DD_OK\n");
            else if (ddrval == DDERR_WRONGMODE)
                winDebug("DDERR_WRONGMODE\n");
            else if (ddrval == DDERR_INCOMPATIBLEPRIMARY)
                winDebug("DDERR_INCOMPATIBLEPRIMARY\n");
            else if (ddrval == DDERR_UNSUPPORTED)
                winDebug("DDERR_UNSUPPORTED\n");
            else if (ddrval == DDERR_INVALIDPARAMS)
                winDebug("DDERR_INVALIDPARAMS\n");
            else if (ddrval == DDERR_INVALIDOBJECT)
                winDebug("DDERR_INVALIDOBJECT\n");
            else
                winDebug("unknown error: %08x\n", (unsigned int) ddrval);

            /* Loop around to try the blit one more time */
            continue;
        }
        else if (FAILED(ddrval)) {
            fReturn = FALSE;
            winErrorFVerb(1, "winBltExposedRegionsShadowDDNL - "
                          "IDirectDrawSurface4_Blt failed, but surface not "
                          "lost: %08x %d\n",
                          (unsigned int) ddrval, (int) ddrval);
            goto winBltExposedRegionsShadowDDNL_Exit;
        }
        else {
            /* Success, stop looping */
            break;
        }
    }

 winBltExposedRegionsShadowDDNL_Exit:
    /* EndPaint frees the DC */
    if (hdcUpdate != NULL)
        EndPaint(pScreenPriv->hwndScreen, &ps);
    return fReturn;
}

/*
 * Do any engine-specific application-activation processing
 */

static Bool
winActivateAppShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);

    /*
     * Do we have a surface?
     * Are we active?
     * Are we full screen?
     */
    if (pScreenPriv != NULL
        && pScreenPriv->pddsPrimary4 != NULL && pScreenPriv->fActive) {
        /* Primary surface was lost, restore it */
        IDirectDrawSurface4_Restore(pScreenPriv->pddsPrimary4);
    }

    return TRUE;
}

/*
 * Reblit the shadow framebuffer to the screen.
 */

static Bool
winRedrawScreenShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    HRESULT ddrval = DD_OK;
    RECT rcSrc, rcDest;
    POINT ptOrigin;

    /* Return immediately if we didn't get needed surfaces */
    if (!pScreenPriv->pddsPrimary4 || !pScreenPriv->pddsShadow4)
        return FALSE;

    /* Get the origin of the window in the screen coords */
    ptOrigin.x = pScreenInfo->dwXOffset;
    ptOrigin.y = pScreenInfo->dwYOffset;
    MapWindowPoints(pScreenPriv->hwndScreen,
                    HWND_DESKTOP, (LPPOINT) &ptOrigin, 1);
    rcDest.left = ptOrigin.x;
    rcDest.right = ptOrigin.x + pScreenInfo->dwWidth;
    rcDest.top = ptOrigin.y;
    rcDest.bottom = ptOrigin.y + pScreenInfo->dwHeight;

    /* Source can be entire shadow surface, as Blt should clip for us */
    rcSrc.left = 0;
    rcSrc.top = 0;
    rcSrc.right = pScreenInfo->dwWidth;
    rcSrc.bottom = pScreenInfo->dwHeight;

    /* Redraw the whole window, to take account for the new colors */
    ddrval = IDirectDrawSurface4_Blt(pScreenPriv->pddsPrimary4,
                                     &rcDest,
                                     pScreenPriv->pddsShadow4,
                                     &rcSrc, DDBLT_WAIT, NULL);
    if (FAILED(ddrval)) {
        ErrorF("winRedrawScreenShadowDDNL - IDirectDrawSurface4_Blt () "
               "failed: %08x\n", (unsigned int) ddrval);
    }

    return TRUE;
}

/*
 * Realize the currently installed colormap
 */

static Bool
winRealizeInstalledPaletteShadowDDNL(ScreenPtr pScreen)
{
    return TRUE;
}

/*
 * Install the specified colormap
 */

static Bool
winInstallColormapShadowDDNL(ColormapPtr pColormap)
{
    ScreenPtr pScreen = pColormap->pScreen;

    winScreenPriv(pScreen);
    winCmapPriv(pColormap);
    HRESULT ddrval = DD_OK;

    /* Install the DirectDraw palette on the primary surface */
    ddrval = IDirectDrawSurface4_SetPalette(pScreenPriv->pddsPrimary4,
                                            pCmapPriv->lpDDPalette);
    if (FAILED(ddrval)) {
        ErrorF("winInstallColormapShadowDDNL - Failed installing the "
               "DirectDraw palette.\n");
        return FALSE;
    }

    /* Save a pointer to the newly installed colormap */
    pScreenPriv->pcmapInstalled = pColormap;

    return TRUE;
}

/*
 * Store the specified colors in the specified colormap
 */

static Bool
winStoreColorsShadowDDNL(ColormapPtr pColormap, int ndef, xColorItem * pdefs)
{
    ScreenPtr pScreen = pColormap->pScreen;

    winScreenPriv(pScreen);
    winCmapPriv(pColormap);
    ColormapPtr curpmap = pScreenPriv->pcmapInstalled;
    HRESULT ddrval = DD_OK;

    /* Put the X colormap entries into the Windows logical palette */
    ddrval = IDirectDrawPalette_SetEntries(pCmapPriv->lpDDPalette,
                                           0,
                                           pdefs[0].pixel,
                                           ndef,
                                           pCmapPriv->peColors
                                           + pdefs[0].pixel);
    if (FAILED(ddrval)) {
        ErrorF("winStoreColorsShadowDDNL - SetEntries () failed: %08x\n",
               (unsigned int) ddrval);
        return FALSE;
    }

    /* Don't install the DirectDraw palette if the colormap is not installed */
    if (pColormap != curpmap) {
        return TRUE;
    }

    if (!winInstallColormapShadowDDNL(pColormap)) {
        ErrorF("winStoreColorsShadowDDNL - Failed installing colormap\n");
        return FALSE;
    }

    return TRUE;
}

/*
 * Colormap initialization procedure
 */

static Bool
winCreateColormapShadowDDNL(ColormapPtr pColormap)
{
    HRESULT ddrval = DD_OK;
    ScreenPtr pScreen = pColormap->pScreen;

    winScreenPriv(pScreen);
    winCmapPriv(pColormap);

    /* Create a DirectDraw palette */
    ddrval = IDirectDraw4_CreatePalette(pScreenPriv->pdd4,
                                        DDPCAPS_8BIT | DDPCAPS_ALLOW256,
                                        pCmapPriv->peColors,
                                        &pCmapPriv->lpDDPalette, NULL);
    if (FAILED(ddrval)) {
        ErrorF("winCreateColormapShadowDDNL - CreatePalette failed\n");
        return FALSE;
    }

    return TRUE;
}

/*
 * Colormap destruction procedure
 */

static Bool
winDestroyColormapShadowDDNL(ColormapPtr pColormap)
{
    winScreenPriv(pColormap->pScreen);
    winCmapPriv(pColormap);
    HRESULT ddrval = DD_OK;

    /*
     * Is colormap to be destroyed the default?
     *
     * Non-default colormaps should have had winUninstallColormap
     * called on them before we get here.  The default colormap
     * will not have had winUninstallColormap called on it.  Thus,
     * we need to handle the default colormap in a special way.
     */
    if (pColormap->flags & IsDefault) {
#if CYGDEBUG
        winDebug
            ("winDestroyColormapShadowDDNL - Destroying default colormap\n");
#endif

        /*
         * FIXME: Walk the list of all screens, popping the default
         * palette out of each screen device context.
         */

        /* Pop the palette out of the primary surface */
        ddrval = IDirectDrawSurface4_SetPalette(pScreenPriv->pddsPrimary4,
                                                NULL);
        if (FAILED(ddrval)) {
            ErrorF("winDestroyColormapShadowDDNL - Failed freeing the "
                   "default colormap DirectDraw palette.\n");
            return FALSE;
        }

        /* Clear our private installed colormap pointer */
        pScreenPriv->pcmapInstalled = NULL;
    }

    /* Release the palette */
    IDirectDrawPalette_Release(pCmapPriv->lpDDPalette);

    /* Invalidate the colormap privates */
    pCmapPriv->lpDDPalette = NULL;

    return TRUE;
}

/*
 * Set pointers to our engine specific functions
 */

Bool
winSetEngineFunctionsShadowDDNL(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Set our pointers */
    pScreenPriv->pwinAllocateFB = winAllocateFBShadowDDNL;
    pScreenPriv->pwinFreeFB = winFreeFBShadowDDNL;
    pScreenPriv->pwinShadowUpdate = winShadowUpdateDDNL;
    pScreenPriv->pwinInitScreen = winInitScreenShadowDDNL;
    pScreenPriv->pwinCloseScreen = winCloseScreenShadowDDNL;
    pScreenPriv->pwinInitVisuals = winInitVisualsShadowDDNL;
    pScreenPriv->pwinAdjustVideoMode = winAdjustVideoModeShadowDDNL;
    if (pScreenInfo->fFullScreen)
        pScreenPriv->pwinCreateBoundingWindow =
            winCreateBoundingWindowFullScreen;
    else
        pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowWindowed;
    pScreenPriv->pwinFinishScreenInit = winFinishScreenInitFB;
    pScreenPriv->pwinBltExposedRegions = winBltExposedRegionsShadowDDNL;
    pScreenPriv->pwinActivateApp = winActivateAppShadowDDNL;
    pScreenPriv->pwinRedrawScreen = winRedrawScreenShadowDDNL;
    pScreenPriv->pwinRealizeInstalledPalette
        = winRealizeInstalledPaletteShadowDDNL;
    pScreenPriv->pwinInstallColormap = winInstallColormapShadowDDNL;
    pScreenPriv->pwinStoreColors = winStoreColorsShadowDDNL;
    pScreenPriv->pwinCreateColormap = winCreateColormapShadowDDNL;
    pScreenPriv->pwinDestroyColormap = winDestroyColormapShadowDDNL;
    pScreenPriv->pwinHotKeyAltTab =
        (winHotKeyAltTabProcPtr) (void (*)(void)) NoopDDA;
    pScreenPriv->pwinCreatePrimarySurface = winCreatePrimarySurfaceShadowDDNL;
    pScreenPriv->pwinReleasePrimarySurface = winReleasePrimarySurfaceShadowDDNL;
#ifdef XWIN_MULTIWINDOW
    pScreenPriv->pwinFinishCreateWindowsWindow
        = (winFinishCreateWindowsWindowProcPtr) (void (*)(void)) NoopDDA;
#endif

    return TRUE;
}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d203 4
a206 2
    winDebug("winAllocateFBShadowDDNL - w %d h %d d %d\n",
             pScreenInfo->dwWidth, pScreenInfo->dwHeight, pScreenInfo->dwDepth);
d405 5
a409 4
             "dwRGBBitCount: %d\n",
             ddpfPrimary.u2.dwRBitMask,
             ddpfPrimary.u3.dwGBitMask,
             ddpfPrimary.u4.dwBBitMask, ddpfPrimary.u1.dwRGBBitCount);
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d187 1
a187 1
 * 
d219 1
a219 1
     * Initialize the framebuffer memory so we don't get a 
d548 1
a548 1
     * handle large regions by creating a clipping region and 
d988 4
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d706 1
a706 1
    free((pointer) pScreenPriv);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a38 18
/*
 * FIXME: Headers are broken, DEFINE_GUID doesn't work correctly,
 * so we have to redefine it here.
 */
#ifdef DEFINE_GUID
#undef DEFINE_GUID
#define DEFINE_GUID(n,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) const GUID n GUID_SECT = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}
#endif                          /* DEFINE_GUID */

/*
 * FIXME: Headers are broken, IID_IDirectDraw4 has to be defined
 * here manually.  Should be handled by ddraw.h
 */
#ifndef IID_IDirectDraw4
DEFINE_GUID(IID_IDirectDraw4, 0x9c59509a, 0x39bd, 0x11d1, 0x8c, 0x4a, 0x00,
            0xc0, 0x4f, 0xd9, 0x30, 0xc5);
#endif                          /* IID_IDirectDraw4 */

d52 1
a52 1
 winCloseScreenShadowDDNL(int nIndex, ScreenPtr pScreen);
d252 1
a252 1
                                      (LPDIRECTDRAW *) & pScreenPriv->pdd,
d267 1
a267 1
                                        (LPVOID *) & pScreenPriv->pdd4);
a510 44
#if defined(XWIN_MULTIWINDOW) || defined(XWIN_MULTIWINDOWEXTWM)
/*
 * Create a DirectDraw surface for the new multi-window window
 */

static
    Bool
winFinishCreateWindowsWindowDDNL(WindowPtr pWin)
{
    winWindowPriv(pWin);
    winPrivScreenPtr pScreenPriv = pWinPriv->pScreenPriv;
    HRESULT ddrval = DD_OK;
    DDSURFACEDESC2 ddsd;
    int iWidth, iHeight;
    int iX, iY;

    winDebug("winFinishCreateWindowsWindowDDNL!\n\n");

    iX = pWin->drawable.x + GetSystemMetrics(SM_XVIRTUALSCREEN);
    iY = pWin->drawable.y + GetSystemMetrics(SM_YVIRTUALSCREEN);

    iWidth = pWin->drawable.width;
    iHeight = pWin->drawable.height;

    /* Describe the primary surface */
    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
    ddsd.dwHeight = iHeight;
    ddsd.dwWidth = iWidth;

    /* Create the primary surface */
    ddrval = IDirectDraw4_CreateSurface(pScreenPriv->pdd4,
                                        &ddsd, &pWinPriv->pddsPrimary4, NULL);
    if (FAILED(ddrval)) {
        ErrorF("winFinishCreateWindowsWindowDDNL - Could not create primary "
               "surface: %08x\n", (unsigned int) ddrval);
        return FALSE;
    }
    return TRUE;
}
#endif

d526 1
a526 1
    HRGN hrgnTemp = NULL, hrgnCombined = NULL;
d544 1
a544 1
                    HWND_DESKTOP, (LPPOINT) & ptOrigin, 1);
d598 3
a600 9
        hrgnCombined = CreateRectRgn(pBox->x1, pBox->y1, pBox->x2, pBox->y2);
        dwBox--;
        pBox++;
        while (dwBox--) {
            hrgnTemp = CreateRectRgn(pBox->x1, pBox->y1, pBox->x2, pBox->y2);
            CombineRgn(hrgnCombined, hrgnCombined, hrgnTemp, RGN_OR);
            DeleteObject(hrgnTemp);
            pBox++;
        }
d654 1
a654 1
winCloseScreenShadowDDNL(int nIndex, ScreenPtr pScreen)
d671 1
a671 1
        fReturn = (*pScreen->CloseScreen) (nIndex, pScreen);
d883 1
a883 1
                    HWND_DESKTOP, (LPPOINT) & ptOrigin, 1);
d993 1
a993 1
                    HWND_DESKTOP, (LPPOINT) & ptOrigin, 1);
d1213 1
a1213 1
        = winFinishCreateWindowsWindowDDNL;
@


1.4
log
@Update to xserver 1.11.2
@
text
@a38 1

d46 1
a46 1
#endif /* DEFINE_GUID */
d53 3
a55 2
DEFINE_GUID( IID_IDirectDraw4, 0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
#endif /* IID_IDirectDraw4 */
a58 1

d64 1
a64 1
winAllocateFBShadowDDNL (ScreenPtr pScreen);
d67 1
a67 2
winShadowUpdateDDNL (ScreenPtr pScreen, 
		     shadowBufPtr pBuf);
d70 1
a70 1
winCloseScreenShadowDDNL (int nIndex, ScreenPtr pScreen);
d73 1
a73 1
winInitVisualsShadowDDNL (ScreenPtr pScreen);
d76 1
a76 1
winAdjustVideoModeShadowDDNL (ScreenPtr pScreen);
d79 1
a79 1
winBltExposedRegionsShadowDDNL (ScreenPtr pScreen);
d82 1
a82 1
winActivateAppShadowDDNL (ScreenPtr pScreen);
d85 1
a85 1
winRedrawScreenShadowDDNL (ScreenPtr pScreen);
d88 1
a88 1
winRealizeInstalledPaletteShadowDDNL (ScreenPtr pScreen);
d91 1
a91 1
winInstallColormapShadowDDNL (ColormapPtr pColormap);
d94 1
a94 3
winStoreColorsShadowDDNL (ColormapPtr pmap, 
			  int ndef,
			  xColorItem *pdefs);
d97 1
a97 1
winCreateColormapShadowDDNL (ColormapPtr pColormap);
d100 1
a100 1
winDestroyColormapShadowDDNL (ColormapPtr pColormap);
d103 1
a103 1
winCreatePrimarySurfaceShadowDDNL (ScreenPtr pScreen);
d106 1
a106 2
winReleasePrimarySurfaceShadowDDNL (ScreenPtr pScreen);

d115 1
a115 1
winCreatePrimarySurfaceShadowDDNL (ScreenPtr pScreen)
d117 23
a139 26
  winScreenPriv(pScreen);
  HRESULT		ddrval = DD_OK;
  DDSURFACEDESC2	ddsd;

  winDebug ("winCreatePrimarySurfaceShadowDDNL - Creating primary surface\n");

  /* Describe the primary surface */
  ZeroMemory (&ddsd, sizeof (ddsd));
  ddsd.dwSize = sizeof (ddsd);
  ddsd.dwFlags = DDSD_CAPS;
  ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
  
  /* Create the primary surface */
  ddrval = IDirectDraw4_CreateSurface (pScreenPriv->pdd4,
				       &ddsd,
				       &pScreenPriv->pddsPrimary4,
				       NULL);
  pScreenPriv->fRetryCreateSurface = FALSE;
  if (FAILED (ddrval))
    {
      if (ddrval == DDERR_NOEXCLUSIVEMODE)
        {
          /* Recreating the surface failed. Mark screen to retry later */ 
          pScreenPriv->fRetryCreateSurface = TRUE;
          winDebug ("winCreatePrimarySurfaceShadowDDNL - Could not create "
	          "primary surface: DDERR_NOEXCLUSIVEMODE\n");
d141 3
a143 4
      else
        {
          ErrorF ("winCreatePrimarySurfaceShadowDDNL - Could not create "
	          "primary surface: %08x\n", (unsigned int) ddrval);
d145 1
a145 1
      return FALSE;
d147 1
a147 1
  
d149 1
a149 1
  winDebug ("winCreatePrimarySurfaceShadowDDNL - Created primary surface\n");
d152 7
a158 9
  /* Attach our clipper to our primary surface handle */
  ddrval = IDirectDrawSurface4_SetClipper (pScreenPriv->pddsPrimary4,
					   pScreenPriv->pddcPrimary);
  if (FAILED (ddrval))
    {
      ErrorF ("winCreatePrimarySurfaceShadowDDNL - Primary attach clipper "
	      "failed: %08x\n",
	      (unsigned int) ddrval);
      return FALSE;
d162 2
a163 2
  winDebug ("winCreatePrimarySurfaceShadowDDNL - Attached clipper to primary "
	  "surface\n");
d166 2
a167 2
  /* Everything was correct */
  return TRUE;
a169 1

d176 1
a176 1
winReleasePrimarySurfaceShadowDDNL (ScreenPtr pScreen)
d178 3
a180 1
  winScreenPriv(pScreen);
d182 7
a188 1
  winDebug ("winReleasePrimarySurfaceShadowDDNL - Hello\n");
d190 10
a199 20
  /* Release the primary surface and clipper, if they exist */
  if (pScreenPriv->pddsPrimary4)
    {
      /*
       * Detach the clipper from the primary surface.
       * NOTE: We do this explicity for clarity.  The Clipper is not released.
       */
      IDirectDrawSurface4_SetClipper (pScreenPriv->pddsPrimary4,
				      NULL);
  
      winDebug ("winReleasePrimarySurfaceShadowDDNL - Detached clipper\n");

      /* Release the primary surface */
      IDirectDrawSurface4_Release (pScreenPriv->pddsPrimary4);
      pScreenPriv->pddsPrimary4 = NULL;
    }

  winDebug ("winReleasePrimarySurfaceShadowDDNL - Released primary surface\n");
  
  return TRUE;
a201 1

d211 1
a211 1
winAllocateFBShadowDDNL (ScreenPtr pScreen)
d213 6
a218 6
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;  
  HRESULT		ddrval = DD_OK;
  DDSURFACEDESC2	ddsdShadow;
  char			*lpSurface = NULL;
  DDPIXELFORMAT		ddpfPrimary;
d221 2
a222 2
  winDebug ("winAllocateFBShadowDDNL - w %d h %d d %d\n",
	  pScreenInfo->dwWidth, pScreenInfo->dwHeight, pScreenInfo->dwDepth);
d225 24
a248 27
  /* Set the padded screen width */
  pScreenInfo->dwPaddedWidth = PixmapBytePad (pScreenInfo->dwWidth,
					      pScreenInfo->dwBPP);

  /* Allocate memory for our shadow surface */
  lpSurface = malloc (pScreenInfo->dwPaddedWidth * pScreenInfo->dwHeight);
  if (lpSurface == NULL)
    {
      ErrorF ("winAllocateFBShadowDDNL - Could not allocate bits\n");
      return FALSE;
    }

  /*
   * Initialize the framebuffer memory so we don't get a 
   * strange display at startup
   */
  ZeroMemory (lpSurface, pScreenInfo->dwPaddedWidth * pScreenInfo->dwHeight);
  
  /* Create a clipper */
  ddrval = (*g_fpDirectDrawCreateClipper) (0,
					   &pScreenPriv->pddcPrimary,
					   NULL);
  if (FAILED (ddrval))
    {
      ErrorF ("winAllocateFBShadowDDNL - Could not attach clipper: %08x\n",
	      (unsigned int) ddrval);
      return FALSE;
d252 1
a252 1
  winDebug ("winAllocateFBShadowDDNL - Created a clipper\n");
d255 7
a261 10
  /* Attach the clipper to our display window */
  ddrval = IDirectDrawClipper_SetHWnd (pScreenPriv->pddcPrimary,
				       0,
				       pScreenPriv->hwndScreen);
  if (FAILED (ddrval))
    {
      ErrorF ("winAllocateFBShadowDDNL - Clipper not attached "
	      "to window: %08x\n",
	      (unsigned int) ddrval);
      return FALSE;
d265 1
a265 1
  winDebug ("winAllocateFBShadowDDNL - Attached clipper to window\n");
d268 8
a275 10
  /* Create a DirectDraw object, store the address at lpdd */
  ddrval = (*g_fpDirectDrawCreate) (NULL,
				    (LPDIRECTDRAW*) &pScreenPriv->pdd,
				    NULL);
  if (FAILED (ddrval))
    {
      ErrorF ("winAllocateFBShadowDDNL - Could not start "
	      "DirectDraw: %08x\n",
	      (unsigned int) ddrval);
      return FALSE;
d279 1
a279 1
  winDebug ("winAllocateFBShadowDDNL - Created and initialized DD\n");
d282 135
a416 154
  /* Get a DirectDraw4 interface pointer */
  ddrval = IDirectDraw_QueryInterface (pScreenPriv->pdd,
				       &IID_IDirectDraw4,
				       (LPVOID*) &pScreenPriv->pdd4);
  if (FAILED (ddrval))
    {
      ErrorF ("winAllocateFBShadowDDNL - Failed DD4 query: %08x\n",
	      (unsigned int) ddrval);
      return FALSE;
    }

  /* Are we full screen? */
  if (pScreenInfo->fFullScreen)
    {
      DDSURFACEDESC2	ddsdCurrent;
      DWORD		dwRefreshRateCurrent = 0;
      HDC		hdc = NULL;

      /* Set the cooperative level to full screen */
      ddrval = IDirectDraw4_SetCooperativeLevel (pScreenPriv->pdd4,
						 pScreenPriv->hwndScreen,
						 DDSCL_EXCLUSIVE
						 | DDSCL_FULLSCREEN);
      if (FAILED (ddrval))
	{
	  ErrorF ("winAllocateFBShadowDDNL - Could not set "
		  "cooperative level: %08x\n",
		  (unsigned int) ddrval);
	  return FALSE;
	}

      /*
       * We only need to get the current refresh rate for comparison
       * if a refresh rate has been passed on the command line.
       */
      if (pScreenInfo->dwRefreshRate != 0)
	{
	  ZeroMemory (&ddsdCurrent, sizeof (ddsdCurrent));
	  ddsdCurrent.dwSize = sizeof (ddsdCurrent);

	  /* Get information about current display settings */
	  ddrval = IDirectDraw4_GetDisplayMode (pScreenPriv->pdd4,
						&ddsdCurrent);
	  if (FAILED (ddrval))
	    {
	      ErrorF ("winAllocateFBShadowDDNL - Could not get current "
		      "refresh rate: %08x.  Continuing.\n",
		      (unsigned int) ddrval);
	      dwRefreshRateCurrent = 0;
	    }
	  else
	    {
	      /* Grab the current refresh rate */
	      dwRefreshRateCurrent = ddsdCurrent.u2.dwRefreshRate;
	    }
	}

      /* Clean up the refresh rate */
      if (dwRefreshRateCurrent == pScreenInfo->dwRefreshRate)
	{
	  /*
	   * Refresh rate is non-specified or equal to current.
	   */
	  pScreenInfo->dwRefreshRate = 0;
	}

      /* Grab a device context for the screen */
      hdc = GetDC (NULL);
      if (hdc == NULL)
	{
	  ErrorF ("winAllocateFBShadowDDNL - GetDC () failed\n");
	  return FALSE;
	}

      /* Only change the video mode when different than current mode */
      if (!pScreenInfo->fMultipleMonitors
	  && (pScreenInfo->dwWidth != GetSystemMetrics (SM_CXSCREEN)
	      || pScreenInfo->dwHeight != GetSystemMetrics (SM_CYSCREEN)
	      || pScreenInfo->dwBPP != GetDeviceCaps (hdc, BITSPIXEL)
	      || pScreenInfo->dwRefreshRate != 0))
	{
	  winDebug ("winAllocateFBShadowDDNL - Changing video mode\n");

	  /* Change the video mode to the mode requested, and use the driver default refresh rate on failure */
	  ddrval = IDirectDraw4_SetDisplayMode (pScreenPriv->pdd4,
						pScreenInfo->dwWidth,
						pScreenInfo->dwHeight,
						pScreenInfo->dwBPP,
						pScreenInfo->dwRefreshRate,
						0);	       
	  if (FAILED (ddrval))
	    {
	      ErrorF ("winAllocateFBShadowDDNL - Could not set "
		      "full screen display mode: %08x\n",
		      (unsigned int) ddrval);
	      ErrorF ("winAllocateFBShadowDDNL - Using default driver refresh rate\n");
	      ddrval = IDirectDraw4_SetDisplayMode (pScreenPriv->pdd4,
						    pScreenInfo->dwWidth,
						    pScreenInfo->dwHeight,
						    pScreenInfo->dwBPP,
						    0,
						    0);
	      if (FAILED(ddrval))
		{
			ErrorF ("winAllocateFBShadowDDNL - Could not set default refresh rate "
				"full screen display mode: %08x\n",
				(unsigned int) ddrval);
			return FALSE;
		}
	    }
	}
      else
	{
	  winDebug ("winAllocateFBShadowDDNL - Not changing video mode\n");
	}

      /* Release our DC */
      ReleaseDC (NULL, hdc);
      hdc = NULL;
    }
  else
    {
      /* Set the cooperative level for windowed mode */
      ddrval = IDirectDraw4_SetCooperativeLevel (pScreenPriv->pdd4,
						 pScreenPriv->hwndScreen,
						 DDSCL_NORMAL);
      if (FAILED (ddrval))
	{
	  ErrorF ("winAllocateFBShadowDDNL - Could not set "
		  "cooperative level: %08x\n",
		  (unsigned int) ddrval);
	  return FALSE;
	}
    }

  /* Create the primary surface */
  if (!winCreatePrimarySurfaceShadowDDNL (pScreen))
    {
      ErrorF ("winAllocateFBShadowDDNL - winCreatePrimarySurfaceShadowDDNL "
	      "failed\n");
      return FALSE;
    }

  /* Get primary surface's pixel format */
  ZeroMemory (&ddpfPrimary, sizeof (ddpfPrimary));
  ddpfPrimary.dwSize = sizeof (ddpfPrimary);
  ddrval = IDirectDrawSurface4_GetPixelFormat (pScreenPriv->pddsPrimary4,
					       &ddpfPrimary);
  if (FAILED (ddrval))
    {
      ErrorF ("winAllocateFBShadowDDNL - Could not get primary "
	      "pixformat: %08x\n",
	      (unsigned int) ddrval);
      return FALSE;
d420 5
a424 6
  winDebug ("winAllocateFBShadowDDNL - Primary masks: %08x %08x %08x "
	  "dwRGBBitCount: %d\n",
	  ddpfPrimary.u2.dwRBitMask,
	  ddpfPrimary.u3.dwGBitMask,
	  ddpfPrimary.u4.dwBBitMask,
	  ddpfPrimary.u1.dwRGBBitCount);
d427 31
a457 33
  /* Describe the shadow surface to be created */
  /*
   * NOTE: Do not use a DDSCAPS_VIDEOMEMORY surface,
   * as drawing, locking, and unlocking take forever
   * with video memory surfaces.  In addition,
   * video memory is a somewhat scarce resource,
   * so you shouldn't be allocating video memory when
   * you have the option of using system memory instead.
   */
  ZeroMemory (&ddsdShadow, sizeof (ddsdShadow));
  ddsdShadow.dwSize = sizeof (ddsdShadow);
  ddsdShadow.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH
    | DDSD_LPSURFACE | DDSD_PITCH | DDSD_PIXELFORMAT;
  ddsdShadow.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
  ddsdShadow.dwHeight = pScreenInfo->dwHeight;
  ddsdShadow.dwWidth = pScreenInfo->dwWidth;
  ddsdShadow.u1.lPitch = pScreenInfo->dwPaddedWidth;
  ddsdShadow.lpSurface = lpSurface;
  ddsdShadow.u4.ddpfPixelFormat = ddpfPrimary;
  
  winDebug ("winAllocateFBShadowDDNL - lPitch: %d\n",
	  (int) pScreenInfo->dwPaddedWidth);

  /* Create the shadow surface */
  ddrval = IDirectDraw4_CreateSurface (pScreenPriv->pdd4,
				       &ddsdShadow,
				       &pScreenPriv->pddsShadow4,
				       NULL);
  if (FAILED (ddrval))
    {
      ErrorF ("winAllocateFBShadowDDNL - Could not create shadow "
	      "surface: %08x\n", (unsigned int) ddrval);
      return FALSE;
d459 1
a459 1
  
d461 2
a462 2
  winDebug ("winAllocateFBShadowDDNL - Created shadow pitch: %d\n",
	  (int) ddsdShadow.u1.lPitch);
d465 3
a467 3
  /* Grab the pitch from the surface desc */
  pScreenInfo->dwStride = (ddsdShadow.u1.lPitch * 8)
    / pScreenInfo->dwBPP;
d470 2
a471 2
  winDebug ("winAllocateFBShadowDDNL - Created shadow stride: %d\n",
	  (int) pScreenInfo->dwStride);
d474 7
a480 7
  /* Save the pointer to our surface memory */
  pScreenInfo->pfb = lpSurface;
  
  /* Grab the masks from the surface description */
  pScreenPriv->dwRedMask = ddsdShadow.u4.ddpfPixelFormat.u2.dwRBitMask;
  pScreenPriv->dwGreenMask = ddsdShadow.u4.ddpfPixelFormat.u3.dwGBitMask;
  pScreenPriv->dwBlueMask = ddsdShadow.u4.ddpfPixelFormat.u4.dwBBitMask;
d483 1
a483 1
  winDebug ("winAllocateFBShadowDDNL - Returning\n");
d486 1
a486 1
  return TRUE;
d492 2
a493 2
  winScreenPriv(pScreen);
  winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
d495 6
a500 7
  /* Free the shadow surface, if there is one */
  if (pScreenPriv->pddsShadow4)
    {
      IDirectDrawSurface4_Release (pScreenPriv->pddsShadow4);
      free (pScreenInfo->pfb);
      pScreenInfo->pfb = NULL;
      pScreenPriv->pddsShadow4 = NULL;
d503 2
a504 2
  /* Detach the clipper from the primary surface and release the primary surface, if there is one */
  winReleasePrimarySurfaceShadowDDNL(pScreen);
d506 4
a509 5
  /* Release the clipper object */
  if (pScreenPriv->pddcPrimary)
    {
      IDirectDrawClipper_Release (pScreenPriv->pddcPrimary);
      pScreenPriv->pddcPrimary = NULL;
d512 5
a516 6
  /* Free the DirectDraw4 object, if there is one */
  if (pScreenPriv->pdd4)
    {
      IDirectDraw4_RestoreDisplayMode (pScreenPriv->pdd4);
      IDirectDraw4_Release (pScreenPriv->pdd4);
      pScreenPriv->pdd4 = NULL;
d519 4
a522 5
  /* Free the DirectDraw object, if there is one */
  if (pScreenPriv->pdd)
    {
      IDirectDraw_Release (pScreenPriv->pdd);
      pScreenPriv->pdd = NULL;
d525 2
a526 2
  /* Invalidate the ScreenInfo's fb pointer */
  pScreenInfo->pfb = NULL;
d535 2
a536 2
Bool
winFinishCreateWindowsWindowDDNL (WindowPtr pWin)
d538 30
a567 34
  winWindowPriv(pWin);
  winPrivScreenPtr	pScreenPriv = pWinPriv->pScreenPriv;
  HRESULT		ddrval = DD_OK;
  DDSURFACEDESC2	ddsd;
  int			iWidth, iHeight;
  int			iX, iY;

  winDebug ("winFinishCreateWindowsWindowDDNL!\n\n");

  iX = pWin->drawable.x + GetSystemMetrics (SM_XVIRTUALSCREEN);
  iY = pWin->drawable.y + GetSystemMetrics (SM_YVIRTUALSCREEN);
  
  iWidth = pWin->drawable.width;
  iHeight = pWin->drawable.height;

  /* Describe the primary surface */
  ZeroMemory (&ddsd, sizeof (ddsd));
  ddsd.dwSize = sizeof (ddsd);
  ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT;
  ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
  ddsd.dwHeight = iHeight;
  ddsd.dwWidth = iWidth;

  /* Create the primary surface */
  ddrval = IDirectDraw4_CreateSurface (pScreenPriv->pdd4,
				       &ddsd,
				       &pWinPriv->pddsPrimary4,
				       NULL);
  if (FAILED (ddrval))
    {
      ErrorF ("winFinishCreateWindowsWindowDDNL - Could not create primary "
	      "surface: %08x\n",
	      (unsigned int)ddrval);
      return FALSE;
d569 1
a569 1
  return TRUE;
a572 1

d578 1
a578 2
winShadowUpdateDDNL (ScreenPtr pScreen, 
		     shadowBufPtr pBuf)
d580 94
a673 104
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  RegionPtr		damage = shadowDamage(pBuf);
  HRESULT		ddrval = DD_OK;
  RECT			rcDest, rcSrc;
  POINT			ptOrigin;
  DWORD			dwBox = RegionNumRects (damage);
  BoxPtr		pBox = RegionRects (damage);
  HRGN			hrgnTemp = NULL, hrgnCombined = NULL;

  /*
   * Return immediately if the app is not active
   * and we are fullscreen, or if we have a bad display depth
   */
  if ((!pScreenPriv->fActive && pScreenInfo->fFullScreen)
      || pScreenPriv->fBadDepth) return;

  /* Return immediately if we didn't get needed surfaces */
  if (!pScreenPriv->pddsPrimary4 || !pScreenPriv->pddsShadow4)
    return;

  /* Get the origin of the window in the screen coords */
  ptOrigin.x = pScreenInfo->dwXOffset;
  ptOrigin.y = pScreenInfo->dwYOffset;
  MapWindowPoints (pScreenPriv->hwndScreen,
		   HWND_DESKTOP,
		   (LPPOINT)&ptOrigin, 1);

  /*
   * Handle small regions with multiple blits,
   * handle large regions by creating a clipping region and 
   * doing a single blit constrained to that clipping region.
   */
  if (pScreenInfo->dwClipUpdatesNBoxes == 0
      || dwBox < pScreenInfo->dwClipUpdatesNBoxes)
    {
      /* Loop through all boxes in the damaged region */
      while (dwBox--)
	{
	  /* Assign damage box to source rectangle */
	  rcSrc.left = pBox->x1;
	  rcSrc.top = pBox->y1;
	  rcSrc.right = pBox->x2;
	  rcSrc.bottom = pBox->y2;
	  
	  /* Calculate destination rectangle */
	  rcDest.left = ptOrigin.x + rcSrc.left;
	  rcDest.top = ptOrigin.y + rcSrc.top;
	  rcDest.right = ptOrigin.x + rcSrc.right;
	  rcDest.bottom = ptOrigin.y + rcSrc.bottom;
	  
	  /* Blit the damaged areas */
	  ddrval = IDirectDrawSurface4_Blt (pScreenPriv->pddsPrimary4,
					    &rcDest,
					    pScreenPriv->pddsShadow4,
					    &rcSrc,
					    DDBLT_WAIT,
					    NULL);
	  if (FAILED (ddrval))
	    {
	      static int	s_iFailCount = 0;
	      
	      if (s_iFailCount < FAIL_MSG_MAX_BLT)
		{
		  ErrorF ("winShadowUpdateDDNL - IDirectDrawSurface4_Blt () "
			  "failed: %08x\n",
			  (unsigned int) ddrval);
		  
		  ++s_iFailCount;

		  if (s_iFailCount == FAIL_MSG_MAX_BLT)
		    {
		      ErrorF ("winShadowUpdateDDNL - IDirectDrawSurface4_Blt "
			      "failure message maximum (%d) reached.  No "
			      "more failure messages will be printed.\n",
			      FAIL_MSG_MAX_BLT);
		    }
		}
	    }
	  
	  /* Get a pointer to the next box */
	  ++pBox;
	}
    }
  else
    {
      BoxPtr		pBoxExtents = RegionExtents(damage);

      /* Compute a GDI region from the damaged region */
      hrgnCombined = CreateRectRgn (pBox->x1, pBox->y1, pBox->x2, pBox->y2);
      dwBox--;
      pBox++;
      while (dwBox--)
	{
	  hrgnTemp = CreateRectRgn (pBox->x1, pBox->y1, pBox->x2, pBox->y2);
	  CombineRgn (hrgnCombined, hrgnCombined, hrgnTemp, RGN_OR);
	  DeleteObject (hrgnTemp);
	  pBox++;
	}

      /* Install the GDI region as a clipping region */
      SelectClipRgn (pScreenPriv->hdcScreen, hrgnCombined);
      DeleteObject (hrgnCombined);
      hrgnCombined = NULL;
d676 3
a678 3
      winDebug ("winShadowUpdateDDNL - be x1 %d y1 %d x2 %d y2 %d\n",
	      pBoxExtents->x1, pBoxExtents->y1,
	      pBoxExtents->x2, pBoxExtents->y2);
d681 17
a697 19
      /* Calculating a bounding box for the source is easy */
      rcSrc.left = pBoxExtents->x1;
      rcSrc.top = pBoxExtents->y1;
      rcSrc.right = pBoxExtents->x2;
      rcSrc.bottom = pBoxExtents->y2;

      /* Calculating a bounding box for the destination is trickier */
      rcDest.left = ptOrigin.x + rcSrc.left;
      rcDest.top = ptOrigin.y + rcSrc.top;
      rcDest.right = ptOrigin.x + rcSrc.right;
      rcDest.bottom = ptOrigin.y + rcSrc.bottom;

      /* Our Blt should be clipped to the invalidated region */
      ddrval = IDirectDrawSurface4_Blt (pScreenPriv->pddsPrimary4,
					&rcDest,
					pScreenPriv->pddsShadow4,
					&rcSrc,
					DDBLT_WAIT,
					NULL);
d699 2
a700 2
      /* Reset the clip region */
      SelectClipRgn (pScreenPriv->hdcScreen, NULL);
d707 1
a707 1
  winScreenPriv(pScreen);
d709 2
a710 2
  /* Get a device context for the screen  */
  pScreenPriv->hdcScreen = GetDC (pScreenPriv->hwndScreen);
d712 1
a712 1
  return winAllocateFBShadowDDNL(pScreen);
d722 1
a722 1
winCloseScreenShadowDDNL (int nIndex, ScreenPtr pScreen)
d724 3
a726 3
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  Bool			fReturn;
d729 1
a729 1
  winDebug ("winCloseScreenShadowDDNL - Freeing screen resources\n");
d732 31
a762 33
  /* Flag that the screen is closed */
  pScreenPriv->fClosed = TRUE;
  pScreenPriv->fActive = FALSE;

  /* Call the wrapped CloseScreen procedure */
  WIN_UNWRAP(CloseScreen);
  if (pScreen->CloseScreen)
    fReturn = (*pScreen->CloseScreen) (nIndex, pScreen);

  winFreeFBShadowDDNL(pScreen);

  /* Free the screen DC */
  ReleaseDC (pScreenPriv->hwndScreen, pScreenPriv->hdcScreen);

  /* Delete the window property */
  RemoveProp (pScreenPriv->hwndScreen, WIN_SCR_PROP);

  /* Delete tray icon, if we have one */
  if (!pScreenInfo->fNoTrayIcon)
    winDeleteNotifyIcon (pScreenPriv);

  /* Free the exit confirmation dialog box, if it exists */
  if (g_hDlgExit != NULL)
    {
      DestroyWindow (g_hDlgExit);
      g_hDlgExit = NULL;
    }

  /* Kill our window */
  if (pScreenPriv->hwndScreen)
    {
      DestroyWindow (pScreenPriv->hwndScreen);
      pScreenPriv->hwndScreen = NULL;
d766 2
a767 2
  /* Destroy the thread startup mutex */
  pthread_mutex_destroy (&pScreenPriv->pmServerStarted);
d770 2
a771 2
  /* Kill our screeninfo's pointer to the screen */
  pScreenInfo->pScreen = NULL;
d773 2
a774 2
  /* Free the screen privates for this screen */
  free ((pointer) pScreenPriv);
d776 1
a776 1
  return fReturn;
a778 1

d788 1
a788 1
winInitVisualsShadowDDNL (ScreenPtr pScreen)
d790 29
a818 31
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  DWORD			dwRedBits, dwGreenBits, dwBlueBits;

  /* Count the number of ones in each color mask */
  dwRedBits = winCountBits (pScreenPriv->dwRedMask);
  dwGreenBits = winCountBits (pScreenPriv->dwGreenMask);
  dwBlueBits = winCountBits (pScreenPriv->dwBlueMask);
  
  /* Store the maximum number of ones in a color mask as the bitsPerRGB */
  if (dwRedBits == 0 || dwGreenBits == 0 || dwBlueBits == 0)
    pScreenPriv->dwBitsPerRGB = 8;
  else if (dwRedBits > dwGreenBits && dwRedBits > dwBlueBits)
    pScreenPriv->dwBitsPerRGB = dwRedBits;
  else if (dwGreenBits > dwRedBits && dwGreenBits > dwBlueBits)
    pScreenPriv->dwBitsPerRGB = dwGreenBits;
  else
    pScreenPriv->dwBitsPerRGB = dwBlueBits;

  winDebug ("winInitVisualsShadowDDNL - Masks %08x %08x %08x BPRGB %d d %d "
	  "bpp %d\n",
	  (unsigned int) pScreenPriv->dwRedMask,
	  (unsigned int) pScreenPriv->dwGreenMask,
	  (unsigned int) pScreenPriv->dwBlueMask,
	  (int) pScreenPriv->dwBitsPerRGB,
	  (int) pScreenInfo->dwDepth,
	  (int) pScreenInfo->dwBPP);

  /* Create a single visual according to the Windows screen depth */
  switch (pScreenInfo->dwDepth)
    {
d822 12
a833 13
      /* Setup the real visual */
      if (!miSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     TrueColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     -1,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowDDNL - miSetVisualTypesAndMasks "
		  "failed for TrueColor\n");
	  return FALSE;
	}
d836 2
a837 2
      if (!pScreenInfo->fEmulatePseudo)
	break;
d839 6
a844 13
      /* Setup a pseudocolor visual */
      if (!miSetVisualTypesAndMasks (8,
				     PseudoColorMask,
				     8,
				     -1,
				     0,
				     0,
				     0))
	{
	  ErrorF ("winInitVisualsShadowDDNL - miSetVisualTypesAndMasks "
		  "failed for PseudoColor\n");
	  return FALSE;
	}
d846 1
a846 1
      break;
d849 14
a862 15
      if (!miSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     pScreenInfo->fFullScreen 
				     ? PseudoColorMask : StaticColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     pScreenInfo->fFullScreen 
				     ? PseudoColor : StaticColor,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowDDNL - miSetVisualTypesAndMasks "
		  "failed\n");
	  return FALSE;
	}
      break;
d865 2
a866 2
      ErrorF ("winInitVisualsShadowDDNL - Unknown screen depth\n");
      return FALSE;
d870 1
a870 1
  winDebug ("winInitVisualsShadowDDNL - Returning\n");
d873 1
a873 1
  return TRUE;
a875 1

d881 1
a881 1
winAdjustVideoModeShadowDDNL (ScreenPtr pScreen)
d883 19
a901 22
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  HDC			hdc = NULL;
  DWORD			dwBPP;

  /* We're in serious trouble if we can't get a DC */
  hdc = GetDC (NULL);
  if (hdc == NULL)
    {
      ErrorF ("winAdjustVideoModeShadowDDNL - GetDC () failed\n");
      return FALSE;
    }

  /* Query GDI for current display depth */
  dwBPP = GetDeviceCaps (hdc, BITSPIXEL);

  /* DirectDraw can only change the depth in fullscreen mode */
  if (!(pScreenInfo->fFullScreen &&
        (pScreenInfo->dwBPP != WIN_DEFAULT_BPP)))
    {
      /* Otherwise, We'll use GDI's depth */
      pScreenInfo->dwBPP = dwBPP;
d904 2
a905 2
  /* Release our DC */
  ReleaseDC (NULL, hdc);
d907 1
a907 1
  return TRUE;
a909 1

d915 1
a915 1
winBltExposedRegionsShadowDDNL (ScreenPtr pScreen)
d917 95
a1011 103
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  RECT			rcSrc, rcDest;
  POINT			ptOrigin;
  HDC			hdcUpdate;
  PAINTSTRUCT		ps;
  HRESULT		ddrval = DD_OK;
  Bool			fReturn = TRUE;
  int			i;

  /* Quite common case. The primary surface was lost (maybe because of depth
   * change). Try to create a new primary surface. Bail out if this fails */
  if (pScreenPriv->pddsPrimary4 == NULL && pScreenPriv->fRetryCreateSurface &&
      !winCreatePrimarySurfaceShadowDDNL(pScreen))
    {
      Sleep(100);
      return FALSE;
    }
  if (pScreenPriv->pddsPrimary4 == NULL)
    return FALSE;  
  
  /* BeginPaint gives us an hdc that clips to the invalidated region */
  hdcUpdate = BeginPaint (pScreenPriv->hwndScreen, &ps);
  if (hdcUpdate == NULL)
    {
      fReturn = FALSE;
      ErrorF ("winBltExposedRegionsShadowDDNL - BeginPaint () returned "
	      "a NULL device context handle.  Aborting blit attempt.\n");
      goto winBltExposedRegionsShadowDDNL_Exit;
    }

  /* Get the origin of the window in the screen coords */
  ptOrigin.x = pScreenInfo->dwXOffset;
  ptOrigin.y = pScreenInfo->dwYOffset;

  MapWindowPoints (pScreenPriv->hwndScreen,
		   HWND_DESKTOP,
		   (LPPOINT)&ptOrigin, 1);
  rcDest.left = ptOrigin.x;
  rcDest.right = ptOrigin.x + pScreenInfo->dwWidth;
  rcDest.top = ptOrigin.y;
  rcDest.bottom = ptOrigin.y + pScreenInfo->dwHeight;

  /* Source can be entire shadow surface, as Blt should clip for us */
  rcSrc.left = 0;
  rcSrc.top = 0;
  rcSrc.right = pScreenInfo->dwWidth;
  rcSrc.bottom = pScreenInfo->dwHeight;

  /* Try to regain the primary surface and blit again if we've lost it */
  for (i = 0; i <= WIN_REGAIN_SURFACE_RETRIES; ++i)
    {
      /* Our Blt should be clipped to the invalidated region */
      ddrval = IDirectDrawSurface4_Blt (pScreenPriv->pddsPrimary4,
					&rcDest,
					pScreenPriv->pddsShadow4,
					&rcSrc,
					DDBLT_WAIT,
					NULL);
      if (ddrval == DDERR_SURFACELOST)
	{
	  /* Surface was lost */
	  winErrorFVerb (1, "winBltExposedRegionsShadowDDNL - "
          "IDirectDrawSurface4_Blt reported that the primary "
          "surface was lost, trying to restore, retry: %d\n", i + 1);

	  /* Try to restore the surface, once */
	  
	  ddrval = IDirectDrawSurface4_Restore (pScreenPriv->pddsPrimary4);
	  winDebug ("winBltExposedRegionsShadowDDNL - "
		  "IDirectDrawSurface4_Restore returned: ");
	  if (ddrval == DD_OK)
	    winDebug ("DD_OK\n");
	  else if (ddrval == DDERR_WRONGMODE)
	    winDebug ("DDERR_WRONGMODE\n");
	  else if (ddrval == DDERR_INCOMPATIBLEPRIMARY)
	    winDebug ("DDERR_INCOMPATIBLEPRIMARY\n");
	  else if (ddrval == DDERR_UNSUPPORTED)
	    winDebug ("DDERR_UNSUPPORTED\n");
	  else if (ddrval == DDERR_INVALIDPARAMS)
	    winDebug ("DDERR_INVALIDPARAMS\n");
	  else if (ddrval == DDERR_INVALIDOBJECT)
	    winDebug ("DDERR_INVALIDOBJECT\n");
	  else
	    winDebug ("unknown error: %08x\n", (unsigned int) ddrval);
	  
	  /* Loop around to try the blit one more time */
	  continue;
	}  
      else if (FAILED (ddrval))
	{
	  fReturn = FALSE;
	  winErrorFVerb (1, "winBltExposedRegionsShadowDDNL - "
		  "IDirectDrawSurface4_Blt failed, but surface not "
		  "lost: %08x %d\n",
		  (unsigned int) ddrval, (int) ddrval);
	  goto winBltExposedRegionsShadowDDNL_Exit;
	}
      else
	{
	  /* Success, stop looping */
	  break;
	}
d1015 4
a1018 4
  /* EndPaint frees the DC */
  if (hdcUpdate != NULL)
    EndPaint (pScreenPriv->hwndScreen, &ps);
  return fReturn;
a1020 1

d1026 1
a1026 1
winActivateAppShadowDDNL (ScreenPtr pScreen)
d1028 1
a1028 1
  winScreenPriv(pScreen);
d1030 9
a1038 11
  /*
   * Do we have a surface?
   * Are we active?
   * Are we full screen?
   */
  if (pScreenPriv != NULL
      && pScreenPriv->pddsPrimary4 != NULL
      && pScreenPriv->fActive)
    {
      /* Primary surface was lost, restore it */
      IDirectDrawSurface4_Restore (pScreenPriv->pddsPrimary4);
d1041 1
a1041 1
  return TRUE;
a1043 1

d1049 1
a1049 1
winRedrawScreenShadowDDNL (ScreenPtr pScreen)
d1051 30
a1080 35
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  HRESULT		ddrval = DD_OK;
  RECT			rcSrc, rcDest;
  POINT			ptOrigin;

  /* Get the origin of the window in the screen coords */
  ptOrigin.x = pScreenInfo->dwXOffset;
  ptOrigin.y = pScreenInfo->dwYOffset;
  MapWindowPoints (pScreenPriv->hwndScreen,
		   HWND_DESKTOP,
		   (LPPOINT)&ptOrigin, 1);
  rcDest.left = ptOrigin.x;
  rcDest.right = ptOrigin.x + pScreenInfo->dwWidth;
  rcDest.top = ptOrigin.y;
  rcDest.bottom = ptOrigin.y + pScreenInfo->dwHeight;

  /* Source can be entire shadow surface, as Blt should clip for us */
  rcSrc.left = 0;
  rcSrc.top = 0;
  rcSrc.right = pScreenInfo->dwWidth;
  rcSrc.bottom = pScreenInfo->dwHeight;

  /* Redraw the whole window, to take account for the new colors */
  ddrval = IDirectDrawSurface4_Blt (pScreenPriv->pddsPrimary4,
				    &rcDest,
				    pScreenPriv->pddsShadow4,
				    &rcSrc,
				    DDBLT_WAIT,
				    NULL);
  if (FAILED (ddrval))
    {
      ErrorF ("winRedrawScreenShadowDDNL - IDirectDrawSurface4_Blt () "
	      "failed: %08x\n",
	      (unsigned int) ddrval);
d1083 1
a1083 1
  return TRUE;
a1085 1

d1091 1
a1091 1
winRealizeInstalledPaletteShadowDDNL (ScreenPtr pScreen)
d1093 1
a1093 1
  return TRUE;
a1095 1

d1101 1
a1101 1
winInstallColormapShadowDDNL (ColormapPtr pColormap)
d1103 13
a1115 13
  ScreenPtr		pScreen = pColormap->pScreen;
  winScreenPriv(pScreen);
  winCmapPriv(pColormap);
  HRESULT		ddrval = DD_OK;

  /* Install the DirectDraw palette on the primary surface */
  ddrval = IDirectDrawSurface4_SetPalette (pScreenPriv->pddsPrimary4,
					   pCmapPriv->lpDDPalette);
  if (FAILED (ddrval))
    {
      ErrorF ("winInstallColormapShadowDDNL - Failed installing the "
	      "DirectDraw palette.\n");
      return FALSE;
d1118 2
a1119 2
  /* Save a pointer to the newly installed colormap */
  pScreenPriv->pcmapInstalled = pColormap;
d1121 1
a1121 1
  return TRUE;
a1123 1

d1129 1
a1129 3
winStoreColorsShadowDDNL (ColormapPtr pColormap, 
			  int ndef,
			  xColorItem *pdefs)
d1131 28
a1158 29
  ScreenPtr		pScreen = pColormap->pScreen;
  winScreenPriv(pScreen);
  winCmapPriv(pColormap);
  ColormapPtr		curpmap = pScreenPriv->pcmapInstalled;
  HRESULT		ddrval = DD_OK;
  
  /* Put the X colormap entries into the Windows logical palette */
  ddrval = IDirectDrawPalette_SetEntries (pCmapPriv->lpDDPalette,
					  0,
					  pdefs[0].pixel,
					  ndef,
					  pCmapPriv->peColors 
					  + pdefs[0].pixel);
  if (FAILED (ddrval))
    {
      ErrorF ("winStoreColorsShadowDDNL - SetEntries () failed: %08x\n", (unsigned int) ddrval);
      return FALSE;
    }

  /* Don't install the DirectDraw palette if the colormap is not installed */
  if (pColormap != curpmap)
    {
      return TRUE;
    }

  if (!winInstallColormapShadowDDNL (pColormap))
    {
      ErrorF ("winStoreColorsShadowDDNL - Failed installing colormap\n");
      return FALSE;
d1161 1
a1161 1
  return TRUE;
a1163 1

d1169 1
a1169 1
winCreateColormapShadowDDNL (ColormapPtr pColormap)
d1171 14
a1184 15
  HRESULT		ddrval = DD_OK;
  ScreenPtr		pScreen = pColormap->pScreen;
  winScreenPriv(pScreen);
  winCmapPriv(pColormap);
  
  /* Create a DirectDraw palette */
  ddrval = IDirectDraw4_CreatePalette (pScreenPriv->pdd4,
				       DDPCAPS_8BIT | DDPCAPS_ALLOW256,
				       pCmapPriv->peColors,
				       &pCmapPriv->lpDDPalette,
				       NULL);
  if (FAILED (ddrval))
    {
      ErrorF ("winCreateColormapShadowDDNL - CreatePalette failed\n");
      return FALSE;
d1187 1
a1187 1
  return TRUE;
a1189 1

d1195 1
a1195 1
winDestroyColormapShadowDDNL (ColormapPtr pColormap)
d1197 13
a1209 14
  winScreenPriv(pColormap->pScreen);
  winCmapPriv(pColormap);
  HRESULT		ddrval = DD_OK;

  /*
   * Is colormap to be destroyed the default?
   *
   * Non-default colormaps should have had winUninstallColormap
   * called on them before we get here.  The default colormap
   * will not have had winUninstallColormap called on it.  Thus,
   * we need to handle the default colormap in a special way.
   */
  if (pColormap->flags & IsDefault)
    {
d1211 2
a1212 1
      winDebug ("winDestroyColormapShadowDDNL - Destroying default colormap\n");
a1213 25
      
      /*
       * FIXME: Walk the list of all screens, popping the default
       * palette out of each screen device context.
       */
      
      /* Pop the palette out of the primary surface */
      ddrval = IDirectDrawSurface4_SetPalette (pScreenPriv->pddsPrimary4,
					       NULL);
      if (FAILED (ddrval))
	{
	  ErrorF ("winDestroyColormapShadowDDNL - Failed freeing the "
		  "default colormap DirectDraw palette.\n");
	  return FALSE;
	}

      /* Clear our private installed colormap pointer */
      pScreenPriv->pcmapInstalled = NULL;
    }
  
  /* Release the palette */
  IDirectDrawPalette_Release (pCmapPriv->lpDDPalette);
 
  /* Invalidate the colormap privates */
  pCmapPriv->lpDDPalette = NULL;
d1215 25
a1239 1
  return TRUE;
a1241 1

d1247 1
a1247 1
winSetEngineFunctionsShadowDDNL (ScreenPtr pScreen)
d1249 30
a1278 28
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  
  /* Set our pointers */
  pScreenPriv->pwinAllocateFB = winAllocateFBShadowDDNL;
  pScreenPriv->pwinFreeFB = winFreeFBShadowDDNL;
  pScreenPriv->pwinShadowUpdate = winShadowUpdateDDNL;
  pScreenPriv->pwinInitScreen = winInitScreenShadowDDNL;
  pScreenPriv->pwinCloseScreen = winCloseScreenShadowDDNL;
  pScreenPriv->pwinInitVisuals = winInitVisualsShadowDDNL;
  pScreenPriv->pwinAdjustVideoMode = winAdjustVideoModeShadowDDNL;
  if (pScreenInfo->fFullScreen)
    pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowFullScreen;
  else
    pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowWindowed;
  pScreenPriv->pwinFinishScreenInit = winFinishScreenInitFB;
  pScreenPriv->pwinBltExposedRegions = winBltExposedRegionsShadowDDNL;
  pScreenPriv->pwinActivateApp = winActivateAppShadowDDNL;
  pScreenPriv->pwinRedrawScreen = winRedrawScreenShadowDDNL;
  pScreenPriv->pwinRealizeInstalledPalette
    = winRealizeInstalledPaletteShadowDDNL;
  pScreenPriv->pwinInstallColormap = winInstallColormapShadowDDNL;
  pScreenPriv->pwinStoreColors = winStoreColorsShadowDDNL;
  pScreenPriv->pwinCreateColormap = winCreateColormapShadowDDNL;
  pScreenPriv->pwinDestroyColormap = winDestroyColormapShadowDDNL;
  pScreenPriv->pwinHotKeyAltTab = (winHotKeyAltTabProcPtr) (void (*)(void))NoopDDA;
  pScreenPriv->pwinCreatePrimarySurface = winCreatePrimarySurfaceShadowDDNL;
  pScreenPriv->pwinReleasePrimarySurface = winReleasePrimarySurfaceShadowDDNL;
d1280 2
a1281 2
  pScreenPriv->pwinFinishCreateWindowsWindow
    = winFinishCreateWindowsWindowDDNL;
d1284 1
a1284 1
  return TRUE;
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a40 7
 * External symbols
 */

extern HWND			g_hDlgExit;


/*
d240 4
a272 3
  /* Get a device context for the screen  */
  pScreenPriv->hdcScreen = GetDC (pScreenPriv->hwndScreen);

d534 43
d652 4
d771 10
d805 4
a808 1
  fReturn = (*pScreen->CloseScreen) (nIndex, pScreen);
a815 43
  /* Free the shadow surface, if there is one */
  if (pScreenPriv->pddsShadow4)
    {
      IDirectDrawSurface4_Release (pScreenPriv->pddsShadow4);
      free (pScreenInfo->pfb);
      pScreenInfo->pfb = NULL;
      pScreenPriv->pddsShadow4 = NULL;
    }

  /* Detach the clipper from the primary surface and release the clipper. */
  if (pScreenPriv->pddcPrimary)
    {
      /* Detach the clipper */
      IDirectDrawSurface4_SetClipper (pScreenPriv->pddsPrimary4,
				      NULL);

      /* Release the clipper object */
      IDirectDrawClipper_Release (pScreenPriv->pddcPrimary);
      pScreenPriv->pddcPrimary = NULL;
    }

  /* Release the primary surface, if there is one */
  if (pScreenPriv->pddsPrimary4)
    {
      IDirectDrawSurface4_Release (pScreenPriv->pddsPrimary4);
      pScreenPriv->pddsPrimary4 = NULL;
    }

  /* Free the DirectDraw4 object, if there is one */
  if (pScreenPriv->pdd4)
    {
      IDirectDraw4_RestoreDisplayMode (pScreenPriv->pdd4);
      IDirectDraw4_Release (pScreenPriv->pdd4);
      pScreenPriv->pdd4 = NULL;
    }

  /* Free the DirectDraw object, if there is one */
  if (pScreenPriv->pdd)
    {
      IDirectDraw_Release (pScreenPriv->pdd);
      pScreenPriv->pdd = NULL;
    }

a841 3
  /* Invalidate the ScreenInfo's fb pointer */
  pScreenInfo->pfb = NULL;

a893 1
#if defined(XFree86Server)
a925 32
#else /* XFree86Server */
      /* Setup the real visual */
      if (!fbSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     TrueColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowDDNL - fbSetVisualTypesAndMasks "
		  "failed for TrueColor\n");
	  return FALSE;
	}

#ifdef XWIN_EMULATEPSEUDO
      if (!pScreenInfo->fEmulatePseudo)
	break;

      /* Setup a pseudocolor visual */
      if (!fbSetVisualTypesAndMasks (8,
				     PseudoColorMask,
				     8,
				     0,
				     0,
				     0))
	{
	  ErrorF ("winInitVisualsShadowDDNL - fbSetVisualTypesAndMasks "
		  "failed for PseudoColor\n");
	  return FALSE;
	}
#endif
#endif /* XFree86Server */
a928 1
#if defined(XFree86Server)
a942 14
#else /* XFree86Server */
        if (!fbSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     pScreenInfo->fFullScreen 
				     ? PseudoColorMask : StaticColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowDDNL - fbSetVisualTypesAndMasks "
		  "failed\n");
	  return FALSE;
	}    
#endif /* XFree86Server */
d982 2
a983 1
  if (pScreenInfo->dwBPP == WIN_DEFAULT_BPP)
d985 1
a985 22
      /* No -depth parameter passed, let the user know the depth being used */
      winErrorFVerb (2, "winAdjustVideoModeShadowDDNL - Using Windows display "
	      "depth of %d bits per pixel\n", (int) dwBPP);

      /* Use GDI's depth */
      pScreenInfo->dwBPP = dwBPP;
    }
  else if (pScreenInfo->fFullScreen
	   && pScreenInfo->dwBPP != dwBPP)
    {
      /* FullScreen, and GDI depth differs from -depth parameter */
      winErrorFVerb (2, "winAdjustVideoModeShadowDDNL - FullScreen, using command "
	      "line bpp: %d\n", (int) pScreenInfo->dwBPP);
    }
  else if (dwBPP != pScreenInfo->dwBPP)
    {
      /* Windowed, and GDI depth differs from -depth parameter */
      winErrorFVerb (2, "winAdjustVideoModeShadowDDNL - Windowed, command line "
	      "bpp: %d, using bpp: %d\n",
	      (int) pScreenInfo->dwBPP, (int) dwBPP);

      /* We'll use GDI's depth */
a988 12
  /* See if the shadow bitmap will be larger than the DIB size limit */
  if (pScreenInfo->dwWidth * pScreenInfo->dwHeight * pScreenInfo->dwBPP
      >= WIN_DIB_MAXIMUM_SIZE)
    {
      winErrorFVerb (1, "winAdjustVideoModeShadowDDNL - Requested DirectDraw surface "
	      "will be larger than %d MB.  The surface may fail to be "
	      "allocated on Windows 95, 98, or Me, due to a %d MB limit in "
	      "DIB size.  This limit does not apply to Windows NT/2000, and "
	      "this message may be ignored on those platforms.\n",
	      WIN_DIB_MAXIMUM_SIZE_MB, WIN_DIB_MAXIMUM_SIZE_MB);
    }
  
d1368 1
d1370 1
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d604 2
a605 2
  DWORD			dwBox = REGION_NUM_RECTS (damage);
  BoxPtr		pBox = REGION_RECTS (damage);
d680 1
a680 1
      BoxPtr		pBoxExtents = REGION_EXTENTS (pScreen, damage);
@


1.1
log
@Initial revision
@
text
@d394 1
a394 1
	  /* Change the video mode to the mode requested */
d406 14
a419 1
	      return FALSE;
d557 1
a557 1
  winDebug ("\nwinFinishCreateWindowsWindowDDNL!\n\n");
d600 1
a600 1
  RegionPtr		damage = &pBuf->damage;
d1326 1
a1326 1
      ErrorF ("winStoreColorsShadowDDNL - SetEntries () failed: %08x\n", ddrval);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
