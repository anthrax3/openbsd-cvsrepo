head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.6
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.36;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 2003-2004 Harold L Hunt II All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL HAROLD L HUNT II BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of Harold L Hunt II
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from Harold L Hunt II.
 *
 * Authors:	Harold L Hunt II
 *              Earle F. Philhower III
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include <shellapi.h>
#include "winprefs.h"

/*
 * Local function prototypes
 */

static INT_PTR CALLBACK
winExitDlgProc(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam);

static INT_PTR CALLBACK
winChangeDepthDlgProc(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam);

static INT_PTR CALLBACK
winAboutDlgProc(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam);

static void
 winDrawURLWindow(LPARAM lParam);

static LRESULT CALLBACK
winURLWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

static void
 winOverrideURLButton(HWND hdlg, int id);

static void
 winUnoverrideURLButton(HWND hdlg, int id);

/*
 * Owner-draw a button as a URL
 */

static void
winDrawURLWindow(LPARAM lParam)
{
    DRAWITEMSTRUCT *draw;
    char str[256];
    RECT rect;
    HFONT font;
    COLORREF crText;

    draw = (DRAWITEMSTRUCT *) lParam;
    GetWindowText(draw->hwndItem, str, sizeof(str));
    str[255] = 0;
    GetClientRect(draw->hwndItem, &rect);

    /* Color the button depending upon its state */
    if (draw->itemState & ODS_SELECTED)
        crText = RGB(128 + 64, 0, 0);
    else if (draw->itemState & ODS_FOCUS)
        crText = RGB(0, 128 + 64, 0);
    else
        crText = RGB(0, 0, 128 + 64);
    SetTextColor(draw->hDC, crText);

    /* Create font 8 high, standard dialog font */
    font = CreateFont(-8, 0, 0, 0, FW_DONTCARE, FALSE, FALSE, FALSE,
                      0, 0, 0, 0, 0, "MS Sans Serif");
    if (!font) {
        ErrorF("winDrawURLWindow: Unable to create URL font, bailing.\n");
        return;
    }
    /* Draw it */
    SetBkMode(draw->hDC, OPAQUE);
    SelectObject(draw->hDC, font);
    DrawText(draw->hDC, str, strlen(str), &rect, DT_LEFT | DT_VCENTER);
    /* Delete the created font, replace it with stock font */
    DeleteObject(SelectObject(draw->hDC, GetStockObject(ANSI_VAR_FONT)));
}

/*
 * WndProc for overridden buttons
 */

static LRESULT CALLBACK
winURLWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WNDPROC origCB = NULL;
    HCURSOR cursor;

    /* If it's a SetCursor message, tell it to the hand */
    if (msg == WM_SETCURSOR) {
        cursor = LoadCursor(NULL, IDC_HAND);
        if (cursor)
            SetCursor(cursor);
        return TRUE;
    }
    origCB = (WNDPROC) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    /* Otherwise fall through to original WndProc */
    if (origCB)
        return CallWindowProc(origCB, hwnd, msg, wParam, lParam);
    else
        return FALSE;
}

/*
 * Register and unregister the custom WndProc
 */

static void
winOverrideURLButton(HWND hwnd, int id)
{
    WNDPROC origCB;

    origCB = (WNDPROC) SetWindowLongPtr(GetDlgItem(hwnd, id),
                                        GWLP_WNDPROC, (LONG_PTR) winURLWndProc);
    SetWindowLongPtr(GetDlgItem(hwnd, id), GWLP_USERDATA, (LONG_PTR) origCB);
}

static void
winUnoverrideURLButton(HWND hwnd, int id)
{
    WNDPROC origCB;

    origCB = (WNDPROC) SetWindowLongPtr(GetDlgItem(hwnd, id), GWLP_USERDATA, 0);
    if (origCB)
        SetWindowLongPtr(GetDlgItem(hwnd, id), GWLP_WNDPROC, (LONG_PTR) origCB);
}

/*
 * Center a dialog window in the desktop window
 * and set small and large icons to X icons.
 */

static void
winInitDialog(HWND hwndDlg)
{
    HWND hwndDesk;
    RECT rc, rcDlg, rcDesk;
    HICON hIcon, hIconSmall;

    hwndDesk = GetParent(hwndDlg);
    if (!hwndDesk || IsIconic(hwndDesk))
        hwndDesk = GetDesktopWindow();

    /* Remove minimize and maximize buttons */
    SetWindowLongPtr(hwndDlg, GWL_STYLE, GetWindowLongPtr(hwndDlg, GWL_STYLE)
                     & ~(WS_MAXIMIZEBOX | WS_MINIMIZEBOX));

    /* Set Window not to show in the task bar */
    SetWindowLongPtr(hwndDlg, GWL_EXSTYLE,
                     GetWindowLongPtr(hwndDlg, GWL_EXSTYLE) & ~WS_EX_APPWINDOW);

    /* Center dialog window in the screen. Not done for multi-monitor systems, where
     * it is likely to end up split across the screens. In that case, it appears
     * near the Tray icon.
     */
    if (GetSystemMetrics(SM_CMONITORS) > 1) {
        /* Still need to refresh the frame change. */
        SetWindowPos(hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_FRAMECHANGED);
    }
    else {
        GetWindowRect(hwndDesk, &rcDesk);
        GetWindowRect(hwndDlg, &rcDlg);
        CopyRect(&rc, &rcDesk);

        OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
        OffsetRect(&rc, -rc.left, -rc.top);
        OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);

        SetWindowPos(hwndDlg,
                     HWND_TOPMOST,
                     rcDesk.left + (rc.right / 2),
                     rcDesk.top + (rc.bottom / 2),
                     0, 0, SWP_NOSIZE | SWP_FRAMECHANGED);
    }

#ifdef XWIN_MULTIWINDOW
    if (g_hIconX)
        hIcon = g_hIconX;
    else
#endif
        hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_XWIN));

#ifdef XWIN_MULTIWINDOW
    if (g_hSmallIconX)
        hIconSmall = g_hSmallIconX;
    else
#endif
        hIconSmall = LoadImage(g_hInstance,
                               MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,
                               GetSystemMetrics(SM_CXSMICON),
                               GetSystemMetrics(SM_CYSMICON), LR_SHARED);

    PostMessage(hwndDlg, WM_SETICON, ICON_BIG, (LPARAM) hIcon);
    PostMessage(hwndDlg, WM_SETICON, ICON_SMALL, (LPARAM) hIconSmall);
}

/*
 * Display the Exit dialog box
 */

void
winDisplayExitDialog(winPrivScreenPtr pScreenPriv)
{
    int i;
    int liveClients = 0;

    /* Count up running clients (clients[0] is serverClient) */
    for (i = 1; i < currentMaxClients; i++)
        if (clients[i] != NullClient)
            liveClients++;
#if defined(XWIN_MULTIWINDOW)
    /* Count down server internal clients */
    if (pScreenPriv->pScreenInfo->fMultiWindow)
        liveClients -= 2;       /* multiwindow window manager & XMsgProc  */
#endif
#if defined(XWIN_CLIPBOARD)
    if (g_fClipboardStarted)
        liveClients--;          /* clipboard manager */
#endif

    /* A user reported that this sometimes drops below zero. just eye-candy. */
    if (liveClients < 0)
        liveClients = 0;

    /* Don't show the exit confirmation dialog if SilentExit & no clients,
       or ForceExit, is enabled */
    if ((pref.fSilentExit && liveClients <= 0) || pref.fForceExit) {
        if (g_hDlgExit != NULL) {
            DestroyWindow(g_hDlgExit);
            g_hDlgExit = NULL;
        }
        PostMessage(pScreenPriv->hwndScreen, WM_GIVEUP, 0, 0);
        return;
    }

    pScreenPriv->iConnectedClients = liveClients;

    /* Check if dialog already exists */
    if (g_hDlgExit != NULL) {
        /* Dialog box already exists, display it */
        ShowWindow(g_hDlgExit, SW_SHOWDEFAULT);

        /* User has lost the dialog.  Show them where it is. */
        SetForegroundWindow(g_hDlgExit);

        return;
    }

    /* Create dialog box */
    g_hDlgExit = CreateDialogParam(g_hInstance,
                                   "EXIT_DIALOG",
                                   pScreenPriv->hwndScreen,
                                   winExitDlgProc, (LPARAM) pScreenPriv);

    /* Show the dialog box */
    ShowWindow(g_hDlgExit, SW_SHOW);

    /* Needed to get keyboard controls (tab, arrows, enter, esc) to work */
    SetForegroundWindow(g_hDlgExit);

    /* Set focus to the Cancel button */
    PostMessage(g_hDlgExit, WM_NEXTDLGCTL,
                (WPARAM) GetDlgItem(g_hDlgExit, IDCANCEL), TRUE);
}

#define CONNECTED_CLIENTS_FORMAT	"There %s currently %d client%s connected."

/*
 * Exit dialog window procedure
 */

static INT_PTR CALLBACK
winExitDlgProc(HWND hDialog, UINT message, WPARAM wParam, LPARAM lParam)
{
    static winPrivScreenPtr s_pScreenPriv = NULL;

    /* Branch on message type */
    switch (message) {
    case WM_INITDIALOG:
    {
        char *pszConnectedClients;

        /* Store pointers to private structures for future use */
        s_pScreenPriv = (winPrivScreenPtr) lParam;

        winInitDialog(hDialog);

        /* Format the connected clients string */
        if (asprintf(&pszConnectedClients, CONNECTED_CLIENTS_FORMAT,
                     (s_pScreenPriv->iConnectedClients == 1) ? "is" : "are",
                     s_pScreenPriv->iConnectedClients,
                     (s_pScreenPriv->iConnectedClients == 1) ? "" : "s") == -1)
            return TRUE;

        /* Set the number of connected clients */
        SetWindowText(GetDlgItem(hDialog, IDC_CLIENTS_CONNECTED),
                      pszConnectedClients);
        free(pszConnectedClients);
    }
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            /* Send message to call the GiveUp function */
            PostMessage(s_pScreenPriv->hwndScreen, WM_GIVEUP, 0, 0);
            DestroyWindow(g_hDlgExit);
            g_hDlgExit = NULL;

            /* Fix to make sure keyboard focus isn't trapped */
            PostMessage(s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);
            return TRUE;

        case IDCANCEL:
            DestroyWindow(g_hDlgExit);
            g_hDlgExit = NULL;

            /* Fix to make sure keyboard focus isn't trapped */
            PostMessage(s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);
            return TRUE;
        }
        break;

    case WM_MOUSEMOVE:
    case WM_NCMOUSEMOVE:
        /* Show the cursor if it is hidden */
        if (g_fSoftwareCursor && !g_fCursor) {
            g_fCursor = TRUE;
            ShowCursor(TRUE);
        }
        return TRUE;

    case WM_CLOSE:
        DestroyWindow(g_hDlgExit);
        g_hDlgExit = NULL;

        /* Fix to make sure keyboard focus isn't trapped */
        PostMessage(s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);
        return TRUE;
    }

    return FALSE;
}

/*
 * Display the Depth Change dialog box
 */

void
winDisplayDepthChangeDialog(winPrivScreenPtr pScreenPriv)
{
    /* Check if dialog already exists */
    if (g_hDlgDepthChange != NULL) {
        /* Dialog box already exists, display it */
        ShowWindow(g_hDlgDepthChange, SW_SHOWDEFAULT);

        /* User has lost the dialog.  Show them where it is. */
        SetForegroundWindow(g_hDlgDepthChange);

        return;
    }

    /*
     * Display a notification to the user that the visual
     * will not be displayed until the Windows display depth
     * is restored to the original value.
     */
    g_hDlgDepthChange = CreateDialogParam(g_hInstance,
                                          "DEPTH_CHANGE_BOX",
                                          pScreenPriv->hwndScreen,
                                          winChangeDepthDlgProc,
                                          (LPARAM) pScreenPriv);
    /* Show the dialog box */
    ShowWindow(g_hDlgDepthChange, SW_SHOW);

    if (!g_hDlgDepthChange)
        ErrorF("winDisplayDepthChangeDialog - GetLastError: %d\n",
                (int) GetLastError());

    /* Minimize the display window */
    ShowWindow(pScreenPriv->hwndScreen, SW_MINIMIZE);
}

/*
 * Process messages for the dialog that is displayed for
 * disruptive screen depth changes.
 */

static INT_PTR CALLBACK
winChangeDepthDlgProc(HWND hwndDialog, UINT message,
                      WPARAM wParam, LPARAM lParam)
{
    static winPrivScreenPtr s_pScreenPriv = NULL;
    static winScreenInfo *s_pScreenInfo = NULL;

#if CYGDEBUG
    winDebug("winChangeDepthDlgProc\n");
#endif

    /* Branch on message type */
    switch (message) {
    case WM_INITDIALOG:
#if CYGDEBUG
        winDebug("winChangeDepthDlgProc - WM_INITDIALOG\n");
#endif

        /* Store pointers to private structures for future use */
        s_pScreenPriv = (winPrivScreenPtr) lParam;
        s_pScreenInfo = s_pScreenPriv->pScreenInfo;

#if CYGDEBUG
        winDebug("winChangeDepthDlgProc - WM_INITDIALOG - s_pScreenPriv: %p, "
                 "s_pScreenInfo: %p\n",
                 s_pScreenPriv, s_pScreenInfo);
#endif

#if CYGDEBUG
        winDebug("winChangeDepthDlgProc - WM_INITDIALOG - orig bpp: %u, "
                 "current bpp: %d\n",
                 (unsigned int)s_pScreenInfo->dwBPP,
                 GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL));
#endif

        winInitDialog(hwndDialog);

        return TRUE;

    case WM_DISPLAYCHANGE:
#if CYGDEBUG
        winDebug("winChangeDepthDlgProc - WM_DISPLAYCHANGE - orig bpp: %u, "
                 "new bpp: %d\n",
                 (unsigned int)s_pScreenInfo->dwBPP,
                 GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL));
#endif

        /* Dismiss the dialog if the display returns to the original depth */
        if (GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL) ==
            s_pScreenInfo->dwBPP) {
            ErrorF("winChangeDelthDlgProc - wParam == s_pScreenInfo->dwBPP\n");

            /* Depth has been restored, dismiss dialog */
            DestroyWindow(g_hDlgDepthChange);
            g_hDlgDepthChange = NULL;

            /* Flag that we have a valid screen depth */
            s_pScreenPriv->fBadDepth = FALSE;
        }
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
            winDebug("winChangeDepthDlgProc - WM_COMMAND - IDOK or IDCANCEL\n");

            /*
             * User dismissed the dialog, hide it until the
             * display mode is restored.
             */
            ShowWindow(g_hDlgDepthChange, SW_HIDE);
            return TRUE;
        }
        break;

    case WM_CLOSE:
        winDebug("winChangeDepthDlgProc - WM_CLOSE\n");

        DestroyWindow(g_hDlgAbout);
        g_hDlgAbout = NULL;

        /* Fix to make sure keyboard focus isn't trapped */
        PostMessage(s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);
        return TRUE;
    }

    return FALSE;
}

/*
 * Display the About dialog box
 */

void
winDisplayAboutDialog(winPrivScreenPtr pScreenPriv)
{
    /* Check if dialog already exists */
    if (g_hDlgAbout != NULL) {
        /* Dialog box already exists, display it */
        ShowWindow(g_hDlgAbout, SW_SHOWDEFAULT);

        /* User has lost the dialog.  Show them where it is. */
        SetForegroundWindow(g_hDlgAbout);

        return;
    }

    /*
     * Display the about box
     */
    g_hDlgAbout = CreateDialogParam(g_hInstance,
                                    "ABOUT_BOX",
                                    pScreenPriv->hwndScreen,
                                    winAboutDlgProc, (LPARAM) pScreenPriv);

    /* Show the dialog box */
    ShowWindow(g_hDlgAbout, SW_SHOW);

    /* Needed to get keyboard controls (tab, arrows, enter, esc) to work */
    SetForegroundWindow(g_hDlgAbout);

    /* Set focus to the OK button */
    PostMessage(g_hDlgAbout, WM_NEXTDLGCTL,
                (WPARAM) GetDlgItem(g_hDlgAbout, IDOK), TRUE);
}

/*
 * Process messages for the about dialog.
 */

static INT_PTR CALLBACK
winAboutDlgProc(HWND hwndDialog, UINT message, WPARAM wParam, LPARAM lParam)
{
    static winPrivScreenPtr s_pScreenPriv = NULL;

#if CYGDEBUG
    winDebug("winAboutDlgProc\n");
#endif

    /* Branch on message type */
    switch (message) {
    case WM_INITDIALOG:
#if CYGDEBUG
        winDebug("winAboutDlgProc - WM_INITDIALOG\n");
#endif

        /* Store pointer to private structure for future use */
        s_pScreenPriv = (winPrivScreenPtr) lParam;

        winInitDialog(hwndDialog);

        /* Override the URL buttons */
        winOverrideURLButton(hwndDialog, ID_ABOUT_WEBSITE);

        return TRUE;

    case WM_DRAWITEM:
        /* Draw the URL buttons as needed */
        winDrawURLWindow(lParam);
        return TRUE;

    case WM_MOUSEMOVE:
    case WM_NCMOUSEMOVE:
        /* Show the cursor if it is hidden */
        if (g_fSoftwareCursor && !g_fCursor) {
            g_fCursor = TRUE;
            ShowCursor(TRUE);
        }
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
            winDebug("winAboutDlgProc - WM_COMMAND - IDOK or IDCANCEL\n");

            DestroyWindow(g_hDlgAbout);
            g_hDlgAbout = NULL;

            /* Fix to make sure keyboard focus isn't trapped */
            PostMessage(s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);

            /* Restore window procedures for URL buttons */
            winUnoverrideURLButton(hwndDialog, ID_ABOUT_WEBSITE);

            return TRUE;

        case ID_ABOUT_WEBSITE:
        {
            const char *pszPath = __VENDORDWEBSUPPORT__;
            INT_PTR iReturn;

            iReturn = (INT_PTR) ShellExecute(NULL,
                                         "open",
                                         pszPath, NULL, NULL, SW_MAXIMIZE);
            if (iReturn < 32) {
                ErrorF("winAboutDlgProc - WM_COMMAND - ID_ABOUT_WEBSITE - "
                       "ShellExecute failed: %d\n", (int)iReturn);

            }
        }
            return TRUE;
        }
        break;

    case WM_CLOSE:
        winDebug("winAboutDlgProc - WM_CLOSE\n");

        DestroyWindow(g_hDlgAbout);
        g_hDlgAbout = NULL;

        /* Fix to make sure keyboard focus isn't trapped */
        PostMessage(s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);

        /* Restore window procedures for URL buttons */
        winUnoverrideURLButton(hwndDialog, ID_ABOUT_WEBSITE);

        return TRUE;
    }

    return FALSE;
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d446 1
a446 1
        winDebug("winChangeDepthDlgProc - WM_INITDIALOG - orig bpp: %d, "
d448 1
a448 1
                 s_pScreenInfo->dwBPP,
d458 1
a458 1
        winDebug("winChangeDepthDlgProc - WM_DISPLAYCHANGE - orig bpp: %d, "
d460 1
a460 1
                 s_pScreenInfo->dwBPP,
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a39 7
 * References to external globals
 */

#ifdef XWIN_CLIPBOARD
extern Bool g_fClipboardStarted;
#endif
/*
d392 2
a393 2
     * Display a notification to the user that the visual 
     * will not be displayed until the Windows display depth 
d414 1
a414 1
 * disruptive screen depth changes. 
d440 2
a441 2
        winDebug("winChangeDepthDlgProc - WM_INITDIALOG - s_pScreenPriv: %08x, "
                 "s_pScreenInfo: %08x\n",
d484 1
a484 1
            /* 
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@a576 1
        winOverrideURLButton(hwndDialog, ID_ABOUT_CHANGELOG);
a577 2
        winOverrideURLButton(hwndDialog, ID_ABOUT_UG);
        winOverrideURLButton(hwndDialog, ID_ABOUT_FAQ);
a607 1
            winUnoverrideURLButton(hwndDialog, ID_ABOUT_CHANGELOG);
a608 2
            winUnoverrideURLButton(hwndDialog, ID_ABOUT_UG);
            winUnoverrideURLButton(hwndDialog, ID_ABOUT_FAQ);
a611 17
        case ID_ABOUT_CHANGELOG:
        {
            INT_PTR iReturn;

            const char *pszWinPath = "http://x.cygwin.com/"
                "devel/server/changelog.html";

            iReturn = (INT_PTR) ShellExecute(NULL,
                                         "open",
                                         pszWinPath, NULL, NULL, SW_MAXIMIZE);
            if (iReturn < 32) {
                ErrorF("winAboutDlgProc - WM_COMMAND - ID_ABOUT_CHANGELOG - "
                       "ShellExecute failed: %d\n", (int)iReturn);
            }
        }
            return TRUE;

a626 30

        case ID_ABOUT_UG:
        {
            const char *pszPath = "http://x.cygwin.com/docs/ug/";
            INT_PTR iReturn;

            iReturn = (INT_PTR) ShellExecute(NULL,
                                         "open",
                                         pszPath, NULL, NULL, SW_MAXIMIZE);
            if (iReturn < 32) {
                ErrorF("winAboutDlgProc - WM_COMMAND - ID_ABOUT_UG - "
                       "ShellExecute failed: %d\n", (int)iReturn);
            }
        }
            return TRUE;

        case ID_ABOUT_FAQ:
        {
            const char *pszPath = "http://x.cygwin.com/docs/faq/";
            INT_PTR iReturn;

            iReturn = (INT_PTR) ShellExecute(NULL,
                                         "open",
                                         pszPath, NULL, NULL, SW_MAXIMIZE);
            if (iReturn < 32) {
                ErrorF("winAboutDlgProc - WM_COMMAND - ID_ABOUT_FAQ - "
                       "ShellExecute failed: %d\n", (int)iReturn);
            }
        }
            return TRUE;
a639 1
        winUnoverrideURLButton(hwndDialog, ID_ABOUT_CHANGELOG);
a640 2
        winUnoverrideURLButton(hwndDialog, ID_ABOUT_UG);
        winUnoverrideURLButton(hwndDialog, ID_ABOUT_FAQ);
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a35 3
#ifdef __CYGWIN__
#include <sys/cygwin.h>
#endif
d50 1
a50 1
static wBOOL CALLBACK
d53 1
a53 1
static wBOOL CALLBACK
d56 1
a56 1
static wBOOL CALLBACK
d288 1
a288 1
                                   winExitDlgProc, (int) pScreenPriv);
d307 1
a307 1
static wBOOL CALLBACK
d407 1
a407 1
                                          (int) pScreenPriv);
d411 3
a413 4
    ErrorF("winDisplayDepthChangeDialog - DialogBox returned: %d\n",
           (int) g_hDlgDepthChange);
    ErrorF("winDisplayDepthChangeDialog - GetLastError: %d\n",
           (int) GetLastError());
d424 1
a424 1
static wBOOL CALLBACK
a429 1
    static ScreenPtr s_pScreen = NULL;
a444 1
        s_pScreen = s_pScreenInfo->pScreen;
d448 2
a449 2
                 "s_pScreenInfo: %08x, s_pScreen: %08x\n",
                 s_pScreenPriv, s_pScreenInfo, s_pScreen);
d538 1
a538 1
                                    winAboutDlgProc, (int) pScreenPriv);
d555 1
a555 1
static wBOOL CALLBACK
a558 2
    static winScreenInfo *s_pScreenInfo = NULL;
    static ScreenPtr s_pScreen = NULL;
d571 1
a571 1
        /* Store pointers to private structures for future use */
a572 2
        s_pScreenInfo = s_pScreenPriv->pScreenInfo;
        s_pScreen = s_pScreenInfo->pScreen;
d620 1
a620 1
            int iReturn;
a621 8
#ifdef __CYGWIN__
            const char *pszCygPath = "/usr/X11R6/share/doc/"
                "xorg-x11-xwin/changelog.html";
            char pszWinPath[MAX_PATH + 1];

            /* Convert the POSIX path to a Win32 path */
            cygwin_conv_to_win32_path(pszCygPath, pszWinPath);
#else
a623 1
#endif
d625 1
a625 1
            iReturn = (int) ShellExecute(NULL,
d630 1
a630 1
                       "ShellExecute failed: %d\n", iReturn);
d638 1
a638 1
            int iReturn;
d640 1
a640 1
            iReturn = (int) ShellExecute(NULL,
d645 2
a646 1
                       "ShellExecute failed: %d\n", iReturn);
d654 1
a654 1
            int iReturn;
d656 1
a656 1
            iReturn = (int) ShellExecute(NULL,
d661 1
a661 1
                       "ShellExecute failed: %d\n", iReturn);
d669 1
a669 1
            int iReturn;
d671 1
a671 1
            iReturn = (int) ShellExecute(NULL,
d676 1
a676 1
                       "ShellExecute failed: %d\n", iReturn);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d495 1
a495 1
            ErrorF("winChangeDepthDlgProc - WM_COMMAND - IDOK or IDCANCEL\n");
d507 1
a507 1
        ErrorF("winChangeDepthDlgProc - WM_CLOSE\n");
d612 1
a612 1
            ErrorF("winAboutDlgProc - WM_COMMAND - IDOK or IDCANCEL\n");
d702 1
a702 1
        ErrorF("winAboutDlgProc - WM_CLOSE\n");
@


1.4
log
@Update to xserver 1.11.2
@
text
@a41 1

d47 1
a47 1
extern Bool			g_fClipboardStarted;
d54 1
a54 2
winExitDlgProc (HWND hDialog, UINT message,
		WPARAM wParam, LPARAM lParam);
d57 1
a57 2
winChangeDepthDlgProc (HWND hDialog, UINT message,
		       WPARAM wParam, LPARAM lParam);
d60 1
a60 3
winAboutDlgProc (HWND hDialog, UINT message,
		 WPARAM wParam, LPARAM lParam);

d63 1
a63 1
winDrawURLWindow (LPARAM lParam);
d66 1
a66 1
winURLWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
d69 1
a69 1
winOverrideURLButton (HWND hdlg, int id);
d72 1
a72 2
winUnoverrideURLButton (HWND hdlg, int id);

d79 1
a79 1
winDrawURLWindow (LPARAM lParam)
d81 26
a106 27
  DRAWITEMSTRUCT *draw;
  char str[256];
  RECT rect;
  HFONT font;
  COLORREF crText;
  
  draw = (DRAWITEMSTRUCT *) lParam;
  GetWindowText (draw->hwndItem, str, sizeof(str));
  str[255] = 0;
  GetClientRect (draw->hwndItem, &rect);
  
  /* Color the button depending upon its state */
  if (draw->itemState & ODS_SELECTED)
    crText = RGB(128+64,0,0);
  else if (draw->itemState & ODS_FOCUS)
    crText = RGB(0,128+64,0);
  else
    crText = RGB(0,0,128+64);
  SetTextColor (draw->hDC, crText);
  
  /* Create font 8 high, standard dialog font */
  font = CreateFont (-8, 0, 0, 0, FW_DONTCARE, FALSE, FALSE, FALSE,
		     0, 0, 0, 0, 0, "MS Sans Serif");
  if (!font)
    {
      ErrorF ("winDrawURLWindow: Unable to create URL font, bailing.\n");
      return;
d108 6
a113 6
  /* Draw it */
  SetBkMode (draw->hDC, OPAQUE);
  SelectObject (draw->hDC, font);
  DrawText (draw->hDC, str, strlen (str),&rect,DT_LEFT | DT_VCENTER);
  /* Delete the created font, replace it with stock font */
  DeleteObject (SelectObject (draw->hDC, GetStockObject (ANSI_VAR_FONT)));
a115 1

d123 16
a138 16
  WNDPROC origCB = NULL;
  HCURSOR cursor;
  
  /* If it's a SetCursor message, tell it to the hand */
  if (msg==WM_SETCURSOR) {
    cursor = LoadCursor (NULL, IDC_HAND);
    if (cursor)
      SetCursor (cursor);
    return TRUE;
  }
  origCB = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);
  /* Otherwise fall through to original WndProc */
  if (origCB)
    return CallWindowProc (origCB, hwnd, msg, wParam, lParam);
  else
    return FALSE;
a140 1

d146 1
a146 1
winOverrideURLButton (HWND hwnd, int id)
d148 5
a152 4
  WNDPROC origCB;
  origCB = (WNDPROC)SetWindowLongPtr(GetDlgItem (hwnd, id),
                                     GWLP_WNDPROC, (LONG_PTR)winURLWndProc);
  SetWindowLongPtr(GetDlgItem (hwnd, id), GWLP_USERDATA, (LONG_PTR)origCB);
d156 1
a156 1
winUnoverrideURLButton (HWND hwnd, int id)
d158 5
a162 5
  WNDPROC origCB;
  origCB = (WNDPROC)SetWindowLongPtr(GetDlgItem (hwnd, id),
                                     GWLP_USERDATA, 0);
  if (origCB)
    SetWindowLongPtr(GetDlgItem (hwnd, id), GWLP_WNDPROC, (LONG_PTR)origCB);
a164 1

d171 1
a171 1
winInitDialog (HWND hwndDlg)
d173 40
a212 41
  HWND hwndDesk; 
  RECT rc, rcDlg, rcDesk;
  HICON hIcon, hIconSmall;
 
  hwndDesk = GetParent (hwndDlg);
  if (!hwndDesk || IsIconic (hwndDesk))
    hwndDesk = GetDesktopWindow (); 
  
  /* Remove minimize and maximize buttons */
  SetWindowLongPtr(hwndDlg, GWL_STYLE,
                   GetWindowLongPtr(hwndDlg, GWL_STYLE)
                   & ~(WS_MAXIMIZEBOX | WS_MINIMIZEBOX));

  /* Set Window not to show in the task bar */
  SetWindowLongPtr(hwndDlg, GWL_EXSTYLE,
                   GetWindowLongPtr(hwndDlg, GWL_EXSTYLE) & ~WS_EX_APPWINDOW );

  /* Center dialog window in the screen. Not done for multi-monitor systems, where
   * it is likely to end up split across the screens. In that case, it appears
   * near the Tray icon.
   */
  if (GetSystemMetrics(SM_CMONITORS)>1) {
    /* Still need to refresh the frame change. */
    SetWindowPos (hwndDlg, HWND_TOPMOST, 0,0,0,0,
		SWP_NOMOVE | SWP_NOSIZE | SWP_FRAMECHANGED);
  } else {
    GetWindowRect (hwndDesk, &rcDesk);
    GetWindowRect (hwndDlg, &rcDlg);
    CopyRect (&rc, &rcDesk);

    OffsetRect (&rcDlg, -rcDlg.left, -rcDlg.top);
    OffsetRect (&rc, -rc.left, -rc.top);
    OffsetRect (&rc, -rcDlg.right, -rcDlg.bottom);

    SetWindowPos (hwndDlg,
		HWND_TOPMOST,
		rcDesk.left + (rc.right / 2),
		rcDesk.top + (rc.bottom / 2),
		0, 0,
		SWP_NOSIZE | SWP_FRAMECHANGED);
  }
d215 3
a217 2
  if (g_hIconX) hIcon=g_hIconX;
  else
d219 1
a219 1
  hIcon = LoadIcon (g_hInstance, MAKEINTRESOURCE(IDI_XWIN));
d222 8
a229 8
  if (g_hSmallIconX) hIconSmall=g_hSmallIconX;
  else
#endif
  hIconSmall = LoadImage (g_hInstance,
                        MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,
                        GetSystemMetrics(SM_CXSMICON),
                        GetSystemMetrics(SM_CYSMICON),
                        LR_SHARED);
d231 2
a232 2
  PostMessage (hwndDlg, WM_SETICON, ICON_BIG, (LPARAM) hIcon);
  PostMessage (hwndDlg, WM_SETICON, ICON_SMALL, (LPARAM) hIconSmall);
a234 1

d240 1
a240 1
winDisplayExitDialog (winPrivScreenPtr pScreenPriv)
d242 2
a243 2
  int i;
  int liveClients = 0;
d245 4
a248 4
  /* Count up running clients (clients[0] is serverClient) */
  for (i = 1; i < currentMaxClients; i++)
    if (clients[i] != NullClient)	
      liveClients++;
d250 3
a252 3
  /* Count down server internal clients */
  if (pScreenPriv->pScreenInfo->fMultiWindow)
    liveClients -= 2; /* multiwindow window manager & XMsgProc  */
d255 2
a256 2
  if (g_fClipboardStarted)
    liveClients--; /* clipboard manager */
d259 14
a272 3
  /* A user reported that this sometimes drops below zero. just eye-candy. */ 
  if (liveClients < 0)
    liveClients = 0;      
d274 1
a274 12
  /* Don't show the exit confirmation dialog if SilentExit & no clients,
     or ForceExit, is enabled */
  if ((pref.fSilentExit && liveClients <= 0) || pref.fForceExit)
    {
      if (g_hDlgExit != NULL)
	{
	  DestroyWindow (g_hDlgExit);
	  g_hDlgExit = NULL;
	}
      PostMessage (pScreenPriv->hwndScreen, WM_GIVEUP, 0, 0);
      return;
    }
d276 4
a279 7
  pScreenPriv->iConnectedClients = liveClients;
  
  /* Check if dialog already exists */
  if (g_hDlgExit != NULL)
    {
      /* Dialog box already exists, display it */
      ShowWindow (g_hDlgExit, SW_SHOWDEFAULT);
d281 2
a282 2
      /* User has lost the dialog.  Show them where it is. */
      SetForegroundWindow (g_hDlgExit);
d284 1
a284 1
      return;
d287 15
a301 16
  /* Create dialog box */
  g_hDlgExit = CreateDialogParam (g_hInstance,
				  "EXIT_DIALOG",
				  pScreenPriv->hwndScreen,
				  winExitDlgProc,
				  (int) pScreenPriv);

  /* Show the dialog box */
  ShowWindow (g_hDlgExit, SW_SHOW);
  
  /* Needed to get keyboard controls (tab, arrows, enter, esc) to work */
  SetForegroundWindow (g_hDlgExit);
  
  /* Set focus to the Cancel button */
  PostMessage (g_hDlgExit, WM_NEXTDLGCTL,
	       (WPARAM)GetDlgItem (g_hDlgExit, IDCANCEL), TRUE);
a305 1

d311 1
a311 2
winExitDlgProc (HWND hDialog, UINT message,
		WPARAM wParam, LPARAM lParam)
d313 1
a313 1
  static winPrivScreenPtr	s_pScreenPriv = NULL;
d315 3
a317 2
  /* Branch on message type */
  switch (message)
d319 6
a324 3
    case WM_INITDIALOG:
      {
	char			*pszConnectedClients;
d326 13
a338 20
	/* Store pointers to private structures for future use */
	s_pScreenPriv = (winPrivScreenPtr) lParam;
	
	winInitDialog (hDialog);

	/* Format the connected clients string */
	if (asprintf (&pszConnectedClients, CONNECTED_CLIENTS_FORMAT,
           (s_pScreenPriv->iConnectedClients == 1) ? "is" : "are",
            s_pScreenPriv->iConnectedClients,
           (s_pScreenPriv->iConnectedClients == 1) ? "" : "s") == -1)
	    return TRUE;
     
        
	
	/* Set the number of connected clients */
	SetWindowText (GetDlgItem (hDialog, IDC_CLIENTS_CONNECTED),
		       pszConnectedClients);
	free(pszConnectedClients);
      }
      return TRUE;
d341 20
a360 21
      switch (LOWORD (wParam))
	{
	case IDOK:
	  /* Send message to call the GiveUp function */
	  PostMessage (s_pScreenPriv->hwndScreen, WM_GIVEUP, 0, 0);
	  DestroyWindow (g_hDlgExit);
	  g_hDlgExit = NULL;

	  /* Fix to make sure keyboard focus isn't trapped */
	  PostMessage (s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);
	  return TRUE;

	case IDCANCEL:
	  DestroyWindow (g_hDlgExit);
	  g_hDlgExit = NULL;

	  /* Fix to make sure keyboard focus isn't trapped */
	  PostMessage (s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);
	  return TRUE;
	}
      break;
d364 6
a369 7
      /* Show the cursor if it is hidden */
      if (g_fSoftwareCursor && !g_fCursor)
	{
	  g_fCursor = TRUE;
	  ShowCursor (TRUE);
	}
      return TRUE;
d372 2
a373 2
      DestroyWindow (g_hDlgExit);
      g_hDlgExit = NULL;
d375 3
a377 3
      /* Fix to make sure keyboard focus isn't trapped */
      PostMessage (s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);
      return TRUE;
d380 1
a380 1
  return FALSE;
a382 1

d388 1
a388 1
winDisplayDepthChangeDialog (winPrivScreenPtr pScreenPriv)
d390 4
a393 5
  /* Check if dialog already exists */
  if (g_hDlgDepthChange != NULL)
    {
      /* Dialog box already exists, display it */
      ShowWindow (g_hDlgDepthChange, SW_SHOWDEFAULT);
d395 2
a396 2
      /* User has lost the dialog.  Show them where it is. */
      SetForegroundWindow (g_hDlgDepthChange);
d398 1
a398 1
      return;
d401 20
a420 20
  /*
   * Display a notification to the user that the visual 
   * will not be displayed until the Windows display depth 
   * is restored to the original value.
   */
  g_hDlgDepthChange = CreateDialogParam (g_hInstance,
					 "DEPTH_CHANGE_BOX",
					 pScreenPriv->hwndScreen,
					 winChangeDepthDlgProc,
					 (int) pScreenPriv);
  /* Show the dialog box */
  ShowWindow (g_hDlgDepthChange, SW_SHOW);
  
  ErrorF ("winDisplayDepthChangeDialog - DialogBox returned: %d\n",
	  (int) g_hDlgDepthChange);
  ErrorF ("winDisplayDepthChangeDialog - GetLastError: %d\n",
	  (int) GetLastError ());
	      
  /* Minimize the display window */
  ShowWindow (pScreenPriv->hwndScreen, SW_MINIMIZE);
a422 1

d429 2
a430 2
winChangeDepthDlgProc (HWND hwndDialog, UINT message,
		       WPARAM wParam, LPARAM lParam)
d432 3
a434 3
  static winPrivScreenPtr	s_pScreenPriv = NULL;
  static winScreenInfo		*s_pScreenInfo = NULL;
  static ScreenPtr		s_pScreen = NULL;
d437 1
a437 1
  winDebug ("winChangeDepthDlgProc\n");
d440 2
a441 3
  /* Branch on message type */
  switch (message)
    {
d444 1
a444 1
      winDebug ("winChangeDepthDlgProc - WM_INITDIALOG\n");
d447 4
a450 4
      /* Store pointers to private structures for future use */
      s_pScreenPriv = (winPrivScreenPtr) lParam;
      s_pScreenInfo = s_pScreenPriv->pScreenInfo;
      s_pScreen = s_pScreenInfo->pScreen;
d453 3
a455 3
      winDebug ("winChangeDepthDlgProc - WM_INITDIALOG - s_pScreenPriv: %08x, "
	      "s_pScreenInfo: %08x, s_pScreen: %08x\n",
	      s_pScreenPriv, s_pScreenInfo, s_pScreen);
d459 4
a462 4
      winDebug ("winChangeDepthDlgProc - WM_INITDIALOG - orig bpp: %d, "
	      "current bpp: %d\n",
	      s_pScreenInfo->dwBPP,
              GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL));
d465 1
a465 1
      winInitDialog( hwndDialog );
d467 1
a467 1
      return TRUE;
d471 19
a489 19
      winDebug ("winChangeDepthDlgProc - WM_DISPLAYCHANGE - orig bpp: %d, "
	      "new bpp: %d\n",
	      s_pScreenInfo->dwBPP,
              GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL));
#endif

      /* Dismiss the dialog if the display returns to the original depth */
      if (GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL) == s_pScreenInfo->dwBPP)
	{
	  ErrorF ("winChangeDelthDlgProc - wParam == s_pScreenInfo->dwBPP\n");

	  /* Depth has been restored, dismiss dialog */
	  DestroyWindow (g_hDlgDepthChange);
	  g_hDlgDepthChange = NULL;

	  /* Flag that we have a valid screen depth */
	  s_pScreenPriv->fBadDepth = FALSE;
	}
      return TRUE;
d492 13
a504 14
      switch (LOWORD (wParam))
	{
	case IDOK:
	case IDCANCEL:
	  ErrorF ("winChangeDepthDlgProc - WM_COMMAND - IDOK or IDCANCEL\n");

	  /* 
	   * User dismissed the dialog, hide it until the
	   * display mode is restored.
	   */
	  ShowWindow (g_hDlgDepthChange, SW_HIDE);
	  return TRUE;
	}
      break;
d507 1
a507 1
      ErrorF ("winChangeDepthDlgProc - WM_CLOSE\n");
d509 2
a510 2
      DestroyWindow (g_hDlgAbout);
      g_hDlgAbout = NULL;
d512 3
a514 3
      /* Fix to make sure keyboard focus isn't trapped */
      PostMessage (s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);
      return TRUE;
d517 1
a517 1
  return FALSE;
a519 1

d525 1
a525 1
winDisplayAboutDialog (winPrivScreenPtr pScreenPriv)
d527 4
a530 5
  /* Check if dialog already exists */
  if (g_hDlgAbout != NULL)
    {
      /* Dialog box already exists, display it */
      ShowWindow (g_hDlgAbout, SW_SHOWDEFAULT);
d532 2
a533 2
      /* User has lost the dialog.  Show them where it is. */
      SetForegroundWindow (g_hDlgAbout);
d535 1
a535 1
      return;
d538 17
a554 18
  /*
   * Display the about box
   */
  g_hDlgAbout = CreateDialogParam (g_hInstance,
				   "ABOUT_BOX",
				   pScreenPriv->hwndScreen,
				   winAboutDlgProc,
				   (int) pScreenPriv);
 
  /* Show the dialog box */
  ShowWindow (g_hDlgAbout, SW_SHOW);

  /* Needed to get keyboard controls (tab, arrows, enter, esc) to work */
  SetForegroundWindow (g_hDlgAbout);
  
  /* Set focus to the OK button */
  PostMessage (g_hDlgAbout, WM_NEXTDLGCTL,
	       (WPARAM)GetDlgItem (g_hDlgAbout, IDOK), TRUE);
a556 1

d562 1
a562 2
winAboutDlgProc (HWND hwndDialog, UINT message,
		 WPARAM wParam, LPARAM lParam)
d564 3
a566 3
  static winPrivScreenPtr	s_pScreenPriv = NULL;
  static winScreenInfo		*s_pScreenInfo = NULL;
  static ScreenPtr		s_pScreen = NULL;
d569 1
a569 1
  winDebug ("winAboutDlgProc\n");
d572 2
a573 3
  /* Branch on message type */
  switch (message)
    {
d576 1
a576 1
      winDebug ("winAboutDlgProc - WM_INITDIALOG\n");
d579 4
a582 4
      /* Store pointers to private structures for future use */
      s_pScreenPriv = (winPrivScreenPtr) lParam;
      s_pScreenInfo = s_pScreenPriv->pScreenInfo;
      s_pScreen = s_pScreenInfo->pScreen;
d584 1
a584 1
      winInitDialog (hwndDialog);
d586 5
a590 5
      /* Override the URL buttons */
      winOverrideURLButton (hwndDialog, ID_ABOUT_CHANGELOG);
      winOverrideURLButton (hwndDialog, ID_ABOUT_WEBSITE);
      winOverrideURLButton (hwndDialog, ID_ABOUT_UG);
      winOverrideURLButton (hwndDialog, ID_ABOUT_FAQ);
d592 1
a592 1
      return TRUE;
d595 3
a597 3
      /* Draw the URL buttons as needed */
      winDrawURLWindow (lParam);
      return TRUE;
d601 6
a606 7
      /* Show the cursor if it is hidden */
      if (g_fSoftwareCursor && !g_fCursor)
	{
	  g_fCursor = TRUE;
	  ShowCursor (TRUE);
	}
      return TRUE;
d609 23
a631 23
      switch (LOWORD (wParam))
	{
	case IDOK:
	case IDCANCEL:
	  ErrorF ("winAboutDlgProc - WM_COMMAND - IDOK or IDCANCEL\n");

	  DestroyWindow (g_hDlgAbout);
	  g_hDlgAbout = NULL;

	  /* Fix to make sure keyboard focus isn't trapped */
	  PostMessage (s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);

	  /* Restore window procedures for URL buttons */
	  winUnoverrideURLButton (hwndDialog, ID_ABOUT_CHANGELOG);
	  winUnoverrideURLButton (hwndDialog, ID_ABOUT_WEBSITE);
	  winUnoverrideURLButton (hwndDialog, ID_ABOUT_UG);
	  winUnoverrideURLButton (hwndDialog, ID_ABOUT_FAQ);

	  return TRUE;

	case ID_ABOUT_CHANGELOG:
	  {
	    int iReturn;
d633 3
a635 3
	    const char *	pszCygPath = "/usr/X11R6/share/doc/"
	      "xorg-x11-xwin/changelog.html";
	    char		pszWinPath[MAX_PATH + 1];
d637 2
a638 2
	    /* Convert the POSIX path to a Win32 path */
	    cygwin_conv_to_win32_path (pszCygPath, pszWinPath);
d640 2
a641 2
	    const char *	pszWinPath = "http://x.cygwin.com/"
		    "devel/server/changelog.html";
d643 57
a699 77
	    
	    iReturn = (int)ShellExecute (NULL,
                                    "open",
                                    pszWinPath,
                                    NULL,
                                    NULL,
                                    SW_MAXIMIZE);
	    if (iReturn < 32)
	      {
		ErrorF ("winAboutDlgProc - WM_COMMAND - ID_ABOUT_CHANGELOG - "
			"ShellExecute failed: %d\n",
			iReturn);
	      }	    
	  }
	  return TRUE;

	case ID_ABOUT_WEBSITE:
	  {
	    const char *	pszPath = __VENDORDWEBSUPPORT__;
	    int			iReturn;
	    
	    iReturn = (int)ShellExecute (NULL,
                                    "open",
                                    pszPath,
                                    NULL,
                                    NULL,
                                    SW_MAXIMIZE);
	    if (iReturn < 32)
	      {
		ErrorF ("winAboutDlgProc - WM_COMMAND - ID_ABOUT_WEBSITE - "
			"ShellExecute failed: %d\n",
			iReturn);
	      }	    
	  }
	  return TRUE;

	case ID_ABOUT_UG:
	  {
	    const char *	pszPath = "http://x.cygwin.com/docs/ug/";
	    int			iReturn;
	    
	    iReturn = (int)ShellExecute (NULL,
                                    "open",
                                    pszPath,
                                    NULL,
                                    NULL,
                                    SW_MAXIMIZE);
	    if (iReturn < 32)
	      {
		ErrorF ("winAboutDlgProc - WM_COMMAND - ID_ABOUT_UG - "
			"ShellExecute failed: %d\n",
			iReturn);
	      }	    
	  }
	  return TRUE;

	case ID_ABOUT_FAQ:
	  {
	    const char *	pszPath = "http://x.cygwin.com/docs/faq/";
	    int			iReturn;
	    
	    iReturn = (int)ShellExecute (NULL,
                                    "open",
                                    pszPath,
                                    NULL,
                                    NULL,
                                    SW_MAXIMIZE);
	    if (iReturn < 32)
	      {
		ErrorF ("winAboutDlgProc - WM_COMMAND - ID_ABOUT_FAQ - "
			"ShellExecute failed: %d\n",
			iReturn);
	      }	    
	  }
	  return TRUE;
	}
      break;
d702 1
a702 1
      ErrorF ("winAboutDlgProc - WM_CLOSE\n");
d704 2
a705 2
      DestroyWindow (g_hDlgAbout);
      g_hDlgAbout = NULL;
d707 2
a708 2
      /* Fix to make sure keyboard focus isn't trapped */
      PostMessage (s_pScreenPriv->hwndScreen, WM_NULL, 0, 0);
d710 5
a714 5
      /* Restore window procedures for URL buttons */
      winUnoverrideURLButton (hwndDialog, ID_ABOUT_CHANGELOG);
      winUnoverrideURLButton (hwndDialog, ID_ABOUT_WEBSITE);
      winUnoverrideURLButton (hwndDialog, ID_ABOUT_UG);
      winUnoverrideURLButton (hwndDialog, ID_ABOUT_FAQ);
d716 1
a716 1
      return TRUE;
d719 1
a719 1
  return FALSE;
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a46 5
extern Bool			g_fCursor;
extern HWND			g_hDlgDepthChange;
extern HWND			g_hDlgExit;
extern HWND			g_hDlgAbout;
extern WINPREFS			pref;
a49 7
extern Bool			g_fSoftwareCursor;

#if defined(XWIN_MULTIWINDOW)
extern HICON                    g_hIconX;
extern HICON                    g_hSmallIconX;
#endif

d118 1
a118 1
  DrawText (draw->hDC, str, strlen (str),&rect,DT_CENTER | DT_VCENTER);
d315 1
a315 1
	       GetDlgItem (g_hDlgExit, IDCANCEL), TRUE);
d344 1
a344 1
	pszConnectedClients = Xprintf (CONNECTED_CLIENTS_FORMAT,
d347 1
a347 2
           (s_pScreenPriv->iConnectedClients == 1) ? "" : "s");
	if (!pszConnectedClients)
d485 1
a485 1
	      "last bpp: %d\n",
d487 1
a487 1
	      s_pScreenPriv->dwLastWindowsBitsPixel);
d489 1
a489 1
      
d497 1
a497 1
	      "last bpp: %d, new bpp: %d\n",
d499 1
a499 2
	      s_pScreenPriv->dwLastWindowsBitsPixel,
	      wParam);
d503 1
a503 1
      if (wParam == s_pScreenInfo->dwBPP)
d583 1
a583 1
	       GetDlgItem (g_hDlgAbout, IDOK), TRUE);
d664 1
a664 1
	    HINSTANCE iReturn;
d677 1
a677 1
	    iReturn = ShellExecute (NULL,
d697 1
a697 1
	    iReturn = ShellExecute (NULL,
d717 1
a717 1
	    iReturn = ShellExecute (NULL,
d737 1
a737 1
	    iReturn = ShellExecute (NULL,
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d368 1
a368 1
	xfree (pszConnectedClients);
@


1.1
log
@Initial revision
@
text
@d57 4
d119 2
a120 2
  /* Create underlined font 14 high, standard dialog font */
  font = CreateFont (-14, 0, 0, 0, FW_NORMAL, FALSE, TRUE, FALSE,
d153 1
a153 1
  origCB = (WNDPROC)GetWindowLong (hwnd, GWL_USERDATA);
d170 3
a172 3
  origCB = (WNDPROC)SetWindowLong (GetDlgItem (hwnd, id),
				   GWL_WNDPROC, (LONG)winURLWndProc);
  SetWindowLong (GetDlgItem (hwnd, id), GWL_USERDATA, (LONG)origCB);
d179 2
a180 2
  origCB = (WNDPROC)SetWindowLong (GetDlgItem (hwnd, id),
				   GWL_USERDATA, 0);
d182 1
a182 1
    SetWindowLong (GetDlgItem (hwnd, id), GWL_WNDPROC, (LONG)origCB);
d188 1
d192 1
a192 1
winCenterDialog (HWND hwndDlg)
d195 2
a196 1
  RECT rc, rcDlg, rcDesk; 
d202 30
a231 12
  GetWindowRect (hwndDesk, &rcDesk); 
  GetWindowRect (hwndDlg, &rcDlg); 
  CopyRect (&rc, &rcDesk); 
  
  OffsetRect (&rcDlg, -rcDlg.left, -rcDlg.top); 
  OffsetRect (&rc, -rc.left, -rc.top); 
  OffsetRect (&rc, -rcDlg.right, -rcDlg.bottom); 
  
  SetWindowPos (hwndDlg, 
		HWND_TOP, 
		rcDesk.left + (rc.right / 2), 
		rcDesk.top + (rc.bottom / 2), 
d233 21
a253 1
		SWP_NOSIZE | SWP_NOZORDER); 
d267 1
a267 1
  /* Count up running clinets (clients[0] is serverClient) */
d285 3
a287 2
  /* Don't show the exit confirmation dialog if SilentExit is enabled */
  if (pref.fSilentExit && liveClients <= 0)
a318 9
  /* Drop minimize and maximize buttons */
  SetWindowLong (g_hDlgExit, GWL_STYLE,
		 GetWindowLong (g_hDlgExit, GWL_STYLE)
		 & ~(WS_MAXIMIZEBOX | WS_MINIMIZEBOX));
  SetWindowLong (g_hDlgExit, GWL_EXSTYLE,
		 GetWindowLong (g_hDlgExit, GWL_EXSTYLE) & ~WS_EX_APPWINDOW );
  SetWindowPos (g_hDlgExit, HWND_TOPMOST, 0, 0, 0, 0,
		SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE); 
 
d327 1
a327 1
	       (int) GetDlgItem (g_hDlgExit, IDCANCEL), TRUE);
d330 1
a330 1
#define CONNECTED_CLIENTS_FORMAT	"There are currently %d clients connected."
d353 1
a353 8
	winCenterDialog (hDialog);
	
	/* Set icon to standard app icon */
	PostMessage (hDialog,
		     WM_SETICON,
		     ICON_SMALL,
		     (LPARAM) LoadIcon (g_hInstance,
					MAKEINTRESOURCE(IDI_XWIN)));
d357 3
a359 1
            s_pScreenPriv->iConnectedClients);
a446 11
 
  /* Drop minimize and maximize buttons */
  SetWindowLong (g_hDlgDepthChange, GWL_STYLE,
		 GetWindowLong (g_hDlgDepthChange, GWL_STYLE)
		 & ~(WS_MAXIMIZEBOX | WS_MINIMIZEBOX));
  SetWindowLong (g_hDlgDepthChange, GWL_EXSTYLE,
		 GetWindowLong (g_hDlgDepthChange, GWL_EXSTYLE)
		 & ~WS_EX_APPWINDOW );
  SetWindowPos (g_hDlgDepthChange, 0, 0, 0, 0, 0,
		SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOZORDER | SWP_NOSIZE); 

d503 1
a503 7
      winCenterDialog( hwndDialog );

      /* Set icon to standard app icon */
      PostMessage (hwndDialog,
		   WM_SETICON,
		   ICON_SMALL,
		   (LPARAM) LoadIcon (g_hInstance, MAKEINTRESOURCE(IDI_XWIN)));
a588 9
  /* Drop minimize and maximize buttons */
  SetWindowLong (g_hDlgAbout, GWL_STYLE,
		 GetWindowLong (g_hDlgAbout, GWL_STYLE)
		 & ~(WS_MAXIMIZEBOX | WS_MINIMIZEBOX));
  SetWindowLong (g_hDlgAbout, GWL_EXSTYLE,
		 GetWindowLong (g_hDlgAbout, GWL_EXSTYLE) & ~WS_EX_APPWINDOW);
  SetWindowPos (g_hDlgAbout, 0, 0, 0, 0, 0,
		SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE); 

d597 1
a597 1
	       (int) GetDlgItem (g_hDlgAbout, IDOK), TRUE);
d630 1
a630 7
      winCenterDialog (hwndDialog);

      /* Set icon to standard app icon */
      PostMessage (hwndDialog,
		   WM_SETICON,
		   ICON_SMALL,
		   (LPARAM) LoadIcon (g_hInstance, MAKEINTRESOURCE(IDI_XWIN)));
d678 1
a678 1
	    int			iReturn;
d691 6
a696 6
	    iReturn = (int) ShellExecute (NULL,
					  "open",
					  pszWinPath,
					  NULL,
					  NULL,
					  SW_MAXIMIZE);
d708 1
a708 1
	    const char *	pszPath = "http://x.cygwin.com/";
d711 6
a716 6
	    iReturn = (int) ShellExecute (NULL,
					  "open",
					  pszPath,
					  NULL,
					  NULL,
					  SW_MAXIMIZE);
d731 6
a736 6
	    iReturn = (int) ShellExecute (NULL,
					  "open",
					  pszPath,
					  NULL,
					  NULL,
					  SW_MAXIMIZE);
d751 6
a756 6
	    iReturn = (int) ShellExecute (NULL,
					  "open",
					  pszPath,
					  NULL,
					  NULL,
					  SW_MAXIMIZE);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
