head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.03.45;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Kensuke Matsuzaki
 *		Earle F. Philhower, III
 *		Harold L Hunt II
 */
#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include <winuser.h>
#define _WINDOWSWM_SERVER_
#include <X11/extensions/windowswmstr.h>
#include "dixevents.h"
#include "propertyst.h"
#include <X11/Xatom.h>
#include "winmultiwindowclass.h"
#include "winmsg.h"
#include "inputstr.h"

/*
 * Constant defines
 */

#define MOUSE_ACTIVATE_DEFAULT		TRUE
#define RAISE_ON_CLICK_DEFAULT		FALSE

/*
 * Local globals
 */

static UINT_PTR g_uipMousePollingTimerID = 0;

/*
 * Local function
 */

DEFINE_ATOM_HELPER(AtmWindowsWmRaiseOnClick, WINDOWSWM_RAISE_ON_CLICK)
    DEFINE_ATOM_HELPER(AtmWindowsWMMouseActivate, WINDOWSWM_MOUSE_ACTIVATE)
/* DEFINE_ATOM_HELPER(AtmWindowsWMClientWindow, WINDOWSWM_CLIENT_WINDOW) */
/*
 * ConstrainSize - Taken from TWM sources - Respects hints for sizing
 */
#define makemult(a,b) ((b==1) ? (a) : (((int)((a)/(b))) * (b)) )
static void
ConstrainSize(WinXSizeHints hints, int *widthp, int *heightp)
{
    int minWidth, minHeight, maxWidth, maxHeight, xinc, yinc, delta;
    int baseWidth, baseHeight;
    int dwidth = *widthp, dheight = *heightp;

    if (hints.flags & PMinSize) {
        minWidth = hints.min_width;
        minHeight = hints.min_height;
    }
    else if (hints.flags & PBaseSize) {
        minWidth = hints.base_width;
        minHeight = hints.base_height;
    }
    else
        minWidth = minHeight = 1;

    if (hints.flags & PBaseSize) {
        baseWidth = hints.base_width;
        baseHeight = hints.base_height;
    }
    else if (hints.flags & PMinSize) {
        baseWidth = hints.min_width;
        baseHeight = hints.min_height;
    }
    else
        baseWidth = baseHeight = 0;

    if (hints.flags & PMaxSize) {
        maxWidth = hints.max_width;
        maxHeight = hints.max_height;
    }
    else {
        maxWidth = MAXINT;
        maxHeight = MAXINT;
    }

    if (hints.flags & PResizeInc) {
        xinc = hints.width_inc;
        yinc = hints.height_inc;
    }
    else
        xinc = yinc = 1;

    /*
     * First, clamp to min and max values
     */
    if (dwidth < minWidth)
        dwidth = minWidth;
    if (dheight < minHeight)
        dheight = minHeight;

    if (dwidth > maxWidth)
        dwidth = maxWidth;
    if (dheight > maxHeight)
        dheight = maxHeight;

    /*
     * Second, fit to base + N * inc
     */
    dwidth = ((dwidth - baseWidth) / xinc * xinc) + baseWidth;
    dheight = ((dheight - baseHeight) / yinc * yinc) + baseHeight;

    /*
     * Third, adjust for aspect ratio
     */

    /*
     * The math looks like this:
     *
     * minAspectX    dwidth     maxAspectX
     * ---------- <= ------- <= ----------
     * minAspectY    dheight    maxAspectY
     *
     * If that is multiplied out, then the width and height are
     * invalid in the following situations:
     *
     * minAspectX * dheight > minAspectY * dwidth
     * maxAspectX * dheight < maxAspectY * dwidth
     *
     */

    if (hints.flags & PAspect) {
        if (hints.min_aspect.x * dheight > hints.min_aspect.y * dwidth) {
            delta =
                makemult(hints.min_aspect.x * dheight / hints.min_aspect.y -
                         dwidth, xinc);
            if (dwidth + delta <= maxWidth)
                dwidth += delta;
            else {
                delta =
                    makemult(dheight -
                             dwidth * hints.min_aspect.y / hints.min_aspect.x,
                             yinc);
                if (dheight - delta >= minHeight)
                    dheight -= delta;
            }
        }

        if (hints.max_aspect.x * dheight < hints.max_aspect.y * dwidth) {
            delta =
                makemult(dwidth * hints.max_aspect.y / hints.max_aspect.x -
                         dheight, yinc);
            if (dheight + delta <= maxHeight)
                dheight += delta;
            else {
                delta =
                    makemult(dwidth -
                             hints.max_aspect.x * dheight / hints.max_aspect.y,
                             xinc);
                if (dwidth - delta >= minWidth)
                    dwidth -= delta;
            }
        }
    }

    /* Return computed values */
    *widthp = dwidth;
    *heightp = dheight;
}

#undef makemult

/*
 * ValidateSizing - Ensures size request respects hints
 */
static int
ValidateSizing(HWND hwnd, WindowPtr pWin, WPARAM wParam, LPARAM lParam)
{
    WinXSizeHints sizeHints;
    RECT *rect;
    int iWidth, iHeight, iTopBorder;
    POINT pt;

    /* Invalid input checking */
    if (pWin == NULL || lParam == 0) {
        ErrorF("Invalid input checking\n");
        return FALSE;
    }

    /* No size hints, no checking */
    if (!winMultiWindowGetWMNormalHints(pWin, &sizeHints)) {
        ErrorF("No size hints, no checking\n");
        return FALSE;
    }

    /* Avoid divide-by-zero */
    if (sizeHints.flags & PResizeInc) {
        if (sizeHints.width_inc == 0)
            sizeHints.width_inc = 1;
        if (sizeHints.height_inc == 0)
            sizeHints.height_inc = 1;
    }

    rect = (RECT *) lParam;

    iWidth = rect->right - rect->left;
    iHeight = rect->bottom - rect->top;

    /* Get title bar height, there must be an easier way?! */
    pt.x = pt.y = 0;
    ClientToScreen(hwnd, &pt);
    iTopBorder = pt.y - rect->top;

    /* Now remove size of any borders */
    iWidth -= 2 * GetSystemMetrics(SM_CXSIZEFRAME);
    iHeight -= GetSystemMetrics(SM_CYSIZEFRAME) + iTopBorder;

    /* Constrain the size to legal values */
    ConstrainSize(sizeHints, &iWidth, &iHeight);

    /* Add back the borders */
    iWidth += 2 * GetSystemMetrics(SM_CXSIZEFRAME);
    iHeight += GetSystemMetrics(SM_CYSIZEFRAME) + iTopBorder;

    /* Adjust size according to where we're dragging from */
    switch (wParam) {
    case WMSZ_TOP:
    case WMSZ_TOPRIGHT:
    case WMSZ_BOTTOM:
    case WMSZ_BOTTOMRIGHT:
    case WMSZ_RIGHT:
        rect->right = rect->left + iWidth;
        break;
    default:
        rect->left = rect->right - iWidth;
        break;
    }
    switch (wParam) {
    case WMSZ_BOTTOM:
    case WMSZ_BOTTOMRIGHT:
    case WMSZ_BOTTOMLEFT:
    case WMSZ_RIGHT:
    case WMSZ_LEFT:
        rect->bottom = rect->top + iHeight;
        break;
    default:
        rect->top = rect->bottom - iHeight;
        break;
    }
    return TRUE;
}

/*
 * IsRaiseOnClick
 */

static Bool
IsRaiseOnClick(WindowPtr pWin)
{

    struct _Window *pwin;
    struct _Property *prop;

    /* XXX We're getting inputInfo.poniter here, but this might be really wrong.
     * Which pointer's current window do we want? */
    WindowPtr pRoot = GetCurrentRootWindow(inputInfo.pointer);

    if (!pWin) {
        ErrorF("IsRaiseOnClick - no prop use default value:%d\n",
               RAISE_ON_CLICK_DEFAULT);
        return RAISE_ON_CLICK_DEFAULT;
    }

    pwin = (struct _Window *) pWin;

    if (pwin->optional)
        prop = (struct _Property *) pwin->optional->userProps;
    else
        prop = NULL;

    while (prop) {
        if (prop->propertyName == AtmWindowsWmRaiseOnClick()
            && prop->type == XA_INTEGER && prop->format == 32) {
            return *(int *) prop->data;
        }
        else
            prop = prop->next;
    }

    if (pWin != pRoot) {
        return IsRaiseOnClick(pRoot);
    }
    else {
#if CYGMULTIWINDOW_DEBUG
        winDebug("IsRaiseOnClick - no prop use default value:%d\n",
                 RAISE_ON_CLICK_DEFAULT);
#endif
        return RAISE_ON_CLICK_DEFAULT;
    }
}

/*
 * IsMouseActive
 */

static Bool
IsMouseActive(WindowPtr pWin)
{

    struct _Window *pwin;
    struct _Property *prop;

    /* XXX We're getting inputInfo.poniter here, but this might be really wrong.
     * Which pointer's current window do we want? */
    WindowPtr pRoot = GetCurrentRootWindow(inputInfo.pointer);

    if (!pWin) {
        ErrorF("IsMouseActive - pWin was NULL use default value:%d\n",
               MOUSE_ACTIVATE_DEFAULT);
        return MOUSE_ACTIVATE_DEFAULT;
    }

    pwin = (struct _Window *) pWin;

    if (pwin->optional)
        prop = (struct _Property *) pwin->optional->userProps;
    else
        prop = NULL;

    while (prop) {
        if (prop->propertyName == AtmWindowsWMMouseActivate()
            && prop->type == XA_INTEGER && prop->format == 32) {
            return *(int *) prop->data;
        }
        else
            prop = prop->next;
    }

    if (pWin != pRoot) {
        return IsMouseActive(pRoot);
    }
    else {
#if CYGMULTIWINDOW_DEBUG
        winDebug("IsMouseActive - no prop use default value:%d\n",
                 MOUSE_ACTIVATE_DEFAULT);
#endif
        return MOUSE_ACTIVATE_DEFAULT;
    }
}

/*
 * winMWExtWMWindowProc - Window procedure
 */

LRESULT CALLBACK
winMWExtWMWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    WindowPtr pWin = NULL;
    win32RootlessWindowPtr pRLWinPriv = NULL;
    ScreenPtr pScreen = NULL;
    winPrivScreenPtr pScreenPriv = NULL;
    winScreenInfo *pScreenInfo = NULL;
    HWND hwndScreen = NULL;
    POINT ptMouse;
    static Bool s_fTracking = FALSE;
    HDC hdcUpdate;
    PAINTSTRUCT ps;
    LPWINDOWPOS pWinPos = NULL;
    RECT rcClient;
    winWMMessageRec wmMsg;
    Bool fWMMsgInitialized = FALSE;

    /* Check if the Windows window property for our X window pointer is valid */
    if ((pRLWinPriv =
         (win32RootlessWindowPtr) GetProp(hwnd, WIN_WINDOW_PROP)) != NULL) {
        pWin = pRLWinPriv->pFrame->win;
        pScreen = pWin->drawable.pScreen;
        if (pScreen)
            pScreenPriv = winGetScreenPriv(pScreen);
        if (pScreenPriv)
            pScreenInfo = pScreenPriv->pScreenInfo;
        if (pScreenPriv)
            hwndScreen = pScreenPriv->hwndScreen;

        wmMsg.msg = 0;
        wmMsg.hwndWindow = hwnd;
        wmMsg.iWindow = (Window) pWin->drawable.id;

        wmMsg.iX = pRLWinPriv->pFrame->x;
        wmMsg.iY = pRLWinPriv->pFrame->y;
        wmMsg.iWidth = pRLWinPriv->pFrame->width;
        wmMsg.iHeight = pRLWinPriv->pFrame->height;

        fWMMsgInitialized = TRUE;
#if CYGDEBUG
        winDebugWin32Message("winMWExtWMWindowProc", hwnd, message, wParam,
                             lParam);

        winDebug("\thWnd %08X\n", hwnd);
        winDebug("\tpScreenPriv %08X\n", pScreenPriv);
        winDebug("\tpScreenInfo %08X\n", pScreenInfo);
        winDebug("\thwndScreen %08X\n", hwndScreen);
        winDebug("winMWExtWMWindowProc (%08x) %08x %08x %08x\n",
                 pRLWinPriv, message, wParam, lParam);
#endif
    }
    /* Branch on message type */
    switch (message) {
    case WM_CREATE:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_CREATE\n");
#endif
        /* */
        SetProp(hwnd,
                WIN_WINDOW_PROP,
                (HANDLE) ((LPCREATESTRUCT) lParam)->lpCreateParams);
        return 0;

    case WM_CLOSE:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_CLOSE %d\n", pRLWinPriv->fClose);
#endif
        /* Tell window-manager to close window */
        if (pRLWinPriv->fClose) {
            DestroyWindow(hwnd);
        }
        else {
            if (winIsInternalWMRunning(pScreenInfo)) {
                /* Tell our Window Manager thread to kill the window */
                wmMsg.msg = WM_WM_KILL;
                if (fWMMsgInitialized)
                    winSendMessageToWM(pScreenPriv->pWMInfo, &wmMsg);
            }
            winWindowsWMSendEvent(WindowsWMControllerNotify,
                                  WindowsWMControllerNotifyMask,
                                  1,
                                  WindowsWMCloseWindow,
                                  pWin->drawable.id, 0, 0, 0, 0);
        }
        return 0;

    case WM_DESTROY:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_DESTROY\n");
#endif
        /* Free the shaodw DC; which allows the bitmap to be freed */
        DeleteDC(pRLWinPriv->hdcShadow);
        pRLWinPriv->hdcShadow = NULL;

        /* Free the shadow bitmap */
        DeleteObject(pRLWinPriv->hbmpShadow);
        pRLWinPriv->hbmpShadow = NULL;

        /* Free the screen DC */
        ReleaseDC(pRLWinPriv->hWnd, pRLWinPriv->hdcScreen);
        pRLWinPriv->hdcScreen = NULL;

        /* Free shadow buffer info header */
        free(pRLWinPriv->pbmihShadow);
        pRLWinPriv->pbmihShadow = NULL;

        pRLWinPriv->fResized = FALSE;
        pRLWinPriv->pfb = NULL;
        free(pRLWinPriv);
        RemoveProp(hwnd, WIN_WINDOW_PROP);
        break;

    case WM_MOUSEMOVE:
#if CYGMULTIWINDOW_DEBUG && 0
        winDebug("winMWExtWMWindowProc - WM_MOUSEMOVE\n");
#endif
        /* Unpack the client area mouse coordinates */
        ptMouse.x = GET_X_LPARAM(lParam);
        ptMouse.y = GET_Y_LPARAM(lParam);

        /* Translate the client area mouse coordinates to screen coordinates */
        ClientToScreen(hwnd, &ptMouse);

        /* Screen Coords from (-X, -Y) -> Root Window (0, 0) */
        ptMouse.x -= GetSystemMetrics(SM_XVIRTUALSCREEN);
        ptMouse.y -= GetSystemMetrics(SM_YVIRTUALSCREEN);

        /* We can't do anything without privates */
        if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
            break;

        /* Has the mouse pointer crossed screens? */
        if (pScreen != miPointerGetScreen(inputInfo.pointer))
             miPointerSetScreen(inputInfo.pointer, pScreenInfo->dwScreen,
                                ptMouse.x - pScreenInfo->dwXOffset,
                                ptMouse.y - pScreenInfo->dwYOffset);

        /* Are we tracking yet? */
        if (!s_fTracking) {
            TRACKMOUSEEVENT tme;

            /* Setup data structure */
            ZeroMemory(&tme, sizeof(tme));
            tme.cbSize = sizeof(tme);
            tme.dwFlags = TME_LEAVE;
            tme.hwndTrack = hwnd;

            /* Call the tracking function */
            if (!TrackMouseEvent(&tme))
                ErrorF("winMWExtWMWindowProc - TrackMouseEvent failed\n");

            /* Flag that we are tracking now */
            s_fTracking = TRUE;
        }

        /* Kill the timer used to poll mouse events */
        if (g_uipMousePollingTimerID != 0) {
            KillTimer(pScreenPriv->hwndScreen, WIN_POLLING_MOUSE_TIMER_ID);
            g_uipMousePollingTimerID = 0;
        }

        /* Deliver absolute cursor position to X Server */
        winEnqueueMotion(ptMouse.x - pScreenInfo->dwXOffset,
                         ptMouse.y - pScreenInfo->dwYOffset);

        return 0;

    case WM_NCMOUSEMOVE:
#if CYGMULTIWINDOW_DEBUG && 0
        winDebug("winMWExtWMWindowProc - WM_NCMOUSEMOVE\n");
#endif
        /*
         * We break instead of returning 0 since we need to call
         * DefWindowProc to get the mouse cursor changes
         * and min/max/close button highlighting in Windows XP.
         * The Platform SDK says that you should return 0 if you
         * process this message, but it fails to mention that you
         * will give up any default functionality if you do return 0.
         */

        /* We can't do anything without privates */
        if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
            break;

        /*
         * Timer to poll mouse events.  This is needed to make
         * programs like xeyes follow the mouse properly.
         */
        if (g_uipMousePollingTimerID == 0)
            g_uipMousePollingTimerID = SetTimer(pScreenPriv->hwndScreen,
                                                WIN_POLLING_MOUSE_TIMER_ID,
                                                MOUSE_POLLING_INTERVAL, NULL);
        break;

    case WM_MOUSELEAVE:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_MOUSELEAVE\n");
#endif
        /* Mouse has left our client area */

        /* Flag that we are no longer tracking */
        s_fTracking = FALSE;

        /*
         * Timer to poll mouse events.  This is needed to make
         * programs like xeyes follow the mouse properly.
         */
        if (g_uipMousePollingTimerID == 0)
            g_uipMousePollingTimerID = SetTimer(pScreenPriv->hwndScreen,
                                                WIN_POLLING_MOUSE_TIMER_ID,
                                                MOUSE_POLLING_INTERVAL, NULL);
        return 0;

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_LBUTTONDBLCLK\n");
#endif
        if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
            break;
        SetCapture(hwnd);
        return winMouseButtonsHandle(pScreen, ButtonPress, Button1, wParam);

    case WM_LBUTTONUP:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_LBUTTONUP\n");
#endif
        if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
            break;
        ReleaseCapture();
        return winMouseButtonsHandle(pScreen, ButtonRelease, Button1, wParam);

    case WM_MBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_MBUTTONDBLCLK\n");
#endif
        if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
            break;
        SetCapture(hwnd);
        return winMouseButtonsHandle(pScreen, ButtonPress, Button2, wParam);

    case WM_MBUTTONUP:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_MBUTTONUP\n");
#endif
        if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
            break;
        ReleaseCapture();
        return winMouseButtonsHandle(pScreen, ButtonRelease, Button2, wParam);

    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_RBUTTONDBLCLK\n");
#endif
        if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
            break;
        SetCapture(hwnd);
        return winMouseButtonsHandle(pScreen, ButtonPress, Button3, wParam);

    case WM_RBUTTONUP:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_RBUTTONUP\n");
#endif
        if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
            break;
        ReleaseCapture();
        return winMouseButtonsHandle(pScreen, ButtonRelease, Button3, wParam);

    case WM_XBUTTONDBLCLK:
    case WM_XBUTTONDOWN:
        if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
            break;
        SetCapture(hwnd);
        return winMouseButtonsHandle(pScreen, ButtonPress, HIWORD(wParam) + 7,
                                     wParam);
    case WM_XBUTTONUP:
        if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
            break;
        ReleaseCapture();
        return winMouseButtonsHandle(pScreen, ButtonRelease, HIWORD(wParam) + 7,
                                     wParam);

    case WM_MOUSEWHEEL:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_MOUSEWHEEL\n");
#endif

        /* Pass the message to the root window */
        SendMessage(hwndScreen, message, wParam, lParam);
        return 0;

    case WM_MOUSEHWHEEL:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_MOUSEHWHEEL\n");
#endif

        /* Pass the message to the root window */
        SendMessage(hwndScreen, message, wParam, lParam);
        return 0;

    case WM_MOUSEACTIVATE:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_MOUSEACTIVATE\n");
#endif
#if 1
        /* Check if this window needs to be made active when clicked */
        if (winIsInternalWMRunning(pScreenInfo) && pWin->overrideRedirect) {
#if CYGMULTIWINDOW_DEBUG
            winDebug("winMWExtWMWindowProc - WM_MOUSEACTIVATE - "
                     "MA_NOACTIVATE\n");
#endif

            /* */
            return MA_NOACTIVATE;
        }
#endif
        if (!winIsInternalWMRunning(pScreenInfo) && !IsMouseActive(pWin))
            return MA_NOACTIVATE;

        break;

    case WM_KILLFOCUS:
        /* Pop any pressed keys since we are losing keyboard focus */
        winKeybdReleaseKeys();
        return 0;

    case WM_SYSDEADCHAR:
    case WM_DEADCHAR:
        /*
         * NOTE: We do nothing with WM_*CHAR messages,
         * nor does the root window, so we can just toss these messages.
         */
        return 0;

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_*KEYDOWN\n");
#endif

        /*
         * Don't pass Alt-F4 key combo to root window,
         * let Windows translate to WM_CLOSE and close this top-level window.
         *
         * NOTE: We purposely don't check the fUseWinKillKey setting because
         * it should only apply to the key handling for the root window,
         * not for top-level window-manager windows.
         *
         * ALSO NOTE: We do pass Ctrl-Alt-Backspace to the root window
         * because that is a key combo that no X app should be expecting to
         * receive, since it has historically been used to shutdown the X server.
         * Passing Ctrl-Alt-Backspace to the root window preserves that
         * behavior, assuming that -unixkill has been passed as a parameter.
         */
        if (wParam == VK_F4 && (GetKeyState(VK_MENU) & 0x8000))
            break;

        /* Pass the message to the root window */
        SendMessage(hwndScreen, message, wParam, lParam);
        return 0;

    case WM_SYSKEYUP:
    case WM_KEYUP:

#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_*KEYUP\n");
#endif

        /* Pass the message to the root window */
        SendMessage(hwndScreen, message, wParam, lParam);
        return 0;

    case WM_HOTKEY:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_HOTKEY\n");
#endif

        /* Pass the message to the root window */
        SendMessage(hwndScreen, message, wParam, lParam);
        return 0;

    case WM_ERASEBKGND:
#if CYGDEBUG
        winDebug("winMWExtWMWindowProc - WM_ERASEBKGND\n");
#endif
        /*
         * Pretend that we did erase the background but we don't care,
         * since we repaint the entire region anyhow
         * This avoids some flickering when resizing.
         */
        return TRUE;

    case WM_PAINT:

        /* BeginPaint gives us an hdc that clips to the invalidated region */
        hdcUpdate = BeginPaint(hwnd, &ps);

        /* Try to copy from the shadow buffer */
        if (!BitBlt(hdcUpdate,
                    ps.rcPaint.left, ps.rcPaint.top,
                    ps.rcPaint.right - ps.rcPaint.left,
                    ps.rcPaint.bottom - ps.rcPaint.top,
                    pRLWinPriv->hdcShadow,
                    ps.rcPaint.left, ps.rcPaint.top, SRCCOPY)) {
            LPVOID lpMsgBuf;

            /* Display a fancy error message */
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_FROM_SYSTEM |
                          FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          GetLastError(),
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                          (LPTSTR) &lpMsgBuf, 0, NULL);

            ErrorF("winMWExtWMWindowProc - BitBlt failed: %s\n",
                   (LPSTR) lpMsgBuf);
            LocalFree(lpMsgBuf);
        }

        /* EndPaint frees the DC */
        EndPaint(hwnd, &ps);
        break;

    case WM_ACTIVATE:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_ACTIVATE\n");
#endif
        if (LOWORD(wParam) != WA_INACTIVE) {
            if (winIsInternalWMRunning(pScreenInfo)) {
#if 0
                /* Raise the window to the top in Z order */
                wmMsg.msg = WM_WM_RAISE;
                if (fWMMsgInitialized)
                    winSendMessageToWM(pScreenPriv->pWMInfo, &wmMsg);
#endif
                /* Tell our Window Manager thread to activate the window */
                wmMsg.msg = WM_WM_ACTIVATE;
                if (fWMMsgInitialized)
                    if (!pWin || !pWin->overrideRedirect)       /* for OOo menus */
                        winSendMessageToWM(pScreenPriv->pWMInfo, &wmMsg);
            }
            winWindowsWMSendEvent(WindowsWMControllerNotify,
                                  WindowsWMControllerNotifyMask,
                                  1,
                                  WindowsWMActivateWindow,
                                  pWin->drawable.id, 0, 0, 0, 0);
        }
        return 0;

#if 1
    case WM_WINDOWPOSCHANGING:
        pWinPos = (LPWINDOWPOS) lParam;
        if (!(pWinPos->flags & SWP_NOZORDER)) {
            if (pRLWinPriv->fRestackingNow || pScreenPriv->fRestacking) {
#if CYGMULTIWINDOW_DEBUG
                winDebug("Win %p is now restacking.\n",
                         pRLWinPriv);
#endif
                break;
            }

            if (winIsInternalWMRunning(pScreenInfo) || IsRaiseOnClick(pWin)) {
#if CYGMULTIWINDOW_DEBUG
                winDebug("Win %p has WINDOWSWM_RAISE_ON_CLICK.\n",
                         pRLWinPriv);
#endif
                break;
            }

#if CYGMULTIWINDOW_DEBUG
            winDebug("Win %p forbid to change z order (%p).\n",
                     pRLWinPriv,
                     pWinPos->hwndInsertAfter);
#endif
            pWinPos->flags |= SWP_NOZORDER;
        }
        break;
#endif

    case WM_MOVE:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_MOVE\n");
#endif
        if (g_fNoConfigureWindow)
            break;
#if 0
        /* Bail if Windows window is not actually moving */
        if (pRLWinPriv->dwX == (short) LOWORD(lParam)
            && pRLWinPriv->dwY == (short) HIWORD(lParam))
            break;

        /* Also bail if we're maximizing, we'll do the whole thing in WM_SIZE */
        {
            WINDOWPLACEMENT windPlace;

            windPlace.length = sizeof(WINDOWPLACEMENT);

            /* Get current window placement */
            GetWindowPlacement(hwnd, &windPlace);

            /* Bail if maximizing */
            if (windPlace.showCmd == SW_MAXIMIZE
                || windPlace.showCmd == SW_SHOWMAXIMIZED)
                break;
        }
#endif

#if CYGMULTIWINDOW_DEBUG
        winDebug("\t(%d, %d)\n", (short) LOWORD(lParam),
                 (short) HIWORD(lParam));
#endif
        if (!pRLWinPriv->fMovingOrSizing) {
            if (winIsInternalWMRunning(pScreenInfo))
                winAdjustXWindow(pWin, hwnd);

            winMWExtWMMoveXWindow(pWin, (LOWORD(lParam) - wBorderWidth(pWin)
                                         - GetSystemMetrics(SM_XVIRTUALSCREEN)),
                                  (HIWORD(lParam) - wBorderWidth(pWin)
                                   - GetSystemMetrics(SM_YVIRTUALSCREEN)));
        }
        return 0;

    case WM_SHOWWINDOW:
#if CYGMULTIWINDOW_DEBUG || TRUE
        winDebug("winMWExtWMWindowProc - WM_SHOWWINDOW\n");
#endif
        /* Bail out if the window is being hidden */
        if (!wParam)
            return 0;

        if (!pScreenInfo->fInternalWM)  //XXXX
            return 0;

        winMWExtWMUpdateWindowDecoration(pRLWinPriv, pScreenInfo);

        if (winIsInternalWMRunning(pScreenInfo)) {
#if CYGMULTIWINDOW_DEBUG || TRUE
            winDebug("\tMapWindow\n");
#endif
            /* Tell X to map the window */
            MapWindow(pWin, wClient(pWin));

            if (!pRLWinPriv->pFrame->win->overrideRedirect)
                /* Bring the Windows window to the foreground */
                SetForegroundWindow(hwnd);

            /* Setup the Window Manager message */
            wmMsg.msg = WM_WM_MAP;
            wmMsg.iWidth = pRLWinPriv->pFrame->width;
            wmMsg.iHeight = pRLWinPriv->pFrame->height;

            /* Tell our Window Manager thread to map the window */
            if (fWMMsgInitialized)
                winSendMessageToWM(pScreenPriv->pWMInfo, &wmMsg);
        }
        break;

    case WM_SIZING:
        /* Need to legalize the size according to WM_NORMAL_HINTS */
        /* for applications like xterm */
        return ValidateSizing(hwnd, pWin, wParam, lParam);

    case WM_WINDOWPOSCHANGED:
    {
        pWinPos = (LPWINDOWPOS) lParam;
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_WINDOWPOSCHANGED\n");
        winDebug("\tflags: %s%s%s%s%s%s%s%s%s%s%s%s\n",
                 (pWinPos->flags & SWP_DRAWFRAME) ? "SWP_DRAWFRAME " : "",
                 (pWinPos->flags & SWP_FRAMECHANGED) ? "SWP_FRAMECHANGED " : "",
                 (pWinPos->flags & SWP_HIDEWINDOW) ? "SWP_HIDEWINDOW " : "",
                 (pWinPos->flags & SWP_NOACTIVATE) ? "SWP_NOACTIVATE " : "",
                 (pWinPos->flags & SWP_NOCOPYBITS) ? "SWP_NOCOPYBITS " : "",
                 (pWinPos->flags & SWP_NOMOVE) ? "SWP_NOMOVE " : "",
                 (pWinPos->
                  flags & SWP_NOOWNERZORDER) ? "SWP_NOOWNERZORDER " : "",
                 (pWinPos->flags & SWP_NOSIZE) ? "SWP_NOSIZE " : "",
                 (pWinPos->flags & SWP_NOREDRAW) ? "SWP_NOREDRAW " : "",
                 (pWinPos->
                  flags & SWP_NOSENDCHANGING) ? "SWP_NOSENDCHANGING " : "",
                 (pWinPos->flags & SWP_NOZORDER) ? "SWP_NOZORDER " : "",
                 (pWinPos->flags & SWP_SHOWWINDOW) ? "SWP_SHOWWINDOW " : "");
        winDebug("\tno_configure: %s\n", (g_fNoConfigureWindow ? "Yes" : "No"));
        winDebug("\textend: (%d, %d, %d, %d)\n",
                 pWinPos->x, pWinPos->y, pWinPos->cx, pWinPos->cy);

#endif
        if (pWinPos->flags & SWP_HIDEWINDOW)
            break;

        /* Reorder if window z order was changed */
        if ((pScreenPriv != NULL)
            && !(pWinPos->flags & SWP_NOZORDER)
            && !(pWinPos->flags & SWP_SHOWWINDOW)
            && winIsInternalWMRunning(pScreenInfo)) {
#if CYGMULTIWINDOW_DEBUG
            winDebug("\twindow z order was changed\n");
#endif
            if (pWinPos->hwndInsertAfter == HWND_TOP
                || pWinPos->hwndInsertAfter == HWND_TOPMOST
                || pWinPos->hwndInsertAfter == HWND_NOTOPMOST) {
#if CYGMULTIWINDOW_DEBUG
                winDebug("\traise to top\n");
#endif
                /* Raise the window to the top in Z order */
                wmMsg.msg = WM_WM_RAISE;
                if (fWMMsgInitialized)
                    winSendMessageToWM(pScreenPriv->pWMInfo, &wmMsg);
            }
#if 1
            else if (pWinPos->hwndInsertAfter == HWND_BOTTOM) {
            }
            else {
                /* Check if this window is top of X windows. */
                HWND hWndAbove = NULL;
                DWORD dwCurrentProcessID = GetCurrentProcessId();
                DWORD dwWindowProcessID = 0;

                for (hWndAbove = pWinPos->hwndInsertAfter;
                     hWndAbove != NULL;
                     hWndAbove = GetNextWindow(hWndAbove, GW_HWNDPREV)) {
                    /* Ignore other XWin process's window */
                    GetWindowThreadProcessId(hWndAbove, &dwWindowProcessID);

                    if ((dwWindowProcessID == dwCurrentProcessID)
                        && GetProp(hWndAbove, WIN_WINDOW_PROP)
                        && !IsWindowVisible(hWndAbove)
                        && !IsIconic(hWndAbove))        /* ignore minimized windows */
                        break;
                }
                /* If this is top of X windows in Windows stack,
                   raise it in X stack. */
                if (hWndAbove == NULL) {
#if CYGMULTIWINDOW_DEBUG
                    winDebug("\traise to top\n");
#endif
                    /* Raise the window to the top in Z order */
                    wmMsg.msg = WM_WM_RAISE;
                    if (fWMMsgInitialized)
                        winSendMessageToWM(pScreenPriv->pWMInfo, &wmMsg);
                }
            }
#endif
        }

        if (!(pWinPos->flags & SWP_NOSIZE)) {
            if (IsIconic(hwnd)) {
#if CYGMULTIWINDOW_DEBUG
                winDebug("\tIconic -> MINIMIZED\n");
#endif
                if (winIsInternalWMRunning(pScreenInfo)) {
                    /* Raise the window to the top in Z order */
                    wmMsg.msg = WM_WM_LOWER;
                    if (fWMMsgInitialized)
                        winSendMessageToWM(pScreenPriv->pWMInfo, &wmMsg);
                }
                winWindowsWMSendEvent(WindowsWMControllerNotify,
                                      WindowsWMControllerNotifyMask,
                                      1,
                                      WindowsWMMinimizeWindow,
                                      pWin->drawable.id, 0, 0, 0, 0);
            }
            else if (IsZoomed(hwnd)) {
#if CYGMULTIWINDOW_DEBUG
                winDebug("\tZoomed -> MAXIMIZED\n");
#endif
                winWindowsWMSendEvent(WindowsWMControllerNotify,
                                      WindowsWMControllerNotifyMask,
                                      1,
                                      WindowsWMMaximizeWindow,
                                      pWin->drawable.id, 0, 0, 0, 0);
            }
            else {
#if CYGMULTIWINDOW_DEBUG
                winDebug("\tnone -> RESTORED\n");
#endif
                winWindowsWMSendEvent(WindowsWMControllerNotify,
                                      WindowsWMControllerNotifyMask,
                                      1,
                                      WindowsWMRestoreWindow,
                                      pWin->drawable.id, 0, 0, 0, 0);
            }
        }
        if (!g_fNoConfigureWindow) {

            if (!pRLWinPriv->fMovingOrSizing
                /*&& (pWinPos->flags & SWP_SHOWWINDOW) */ ) {
                GetClientRect(hwnd, &rcClient);
                MapWindowPoints(hwnd, HWND_DESKTOP, (LPPOINT) &rcClient, 2);

                if (!(pWinPos->flags & SWP_NOMOVE)
                    && !(pWinPos->flags & SWP_NOSIZE)) {
#if CYGMULTIWINDOW_DEBUG
                    winDebug("\tmove & resize\n");
#endif
                    if (winIsInternalWMRunning(pScreenInfo))
                        winAdjustXWindow(pWin, hwnd);

                    winMWExtWMMoveResizeXWindow(pWin,
                                                rcClient.left -
                                                wBorderWidth(pWin)
                                                -
                                                GetSystemMetrics
                                                (SM_XVIRTUALSCREEN),
                                                rcClient.top -
                                                wBorderWidth(pWin)
                                                -
                                                GetSystemMetrics
                                                (SM_YVIRTUALSCREEN),
                                                rcClient.right - rcClient.left -
                                                wBorderWidth(pWin) * 2,
                                                rcClient.bottom - rcClient.top -
                                                wBorderWidth(pWin) * 2);
                }
                else if (!(pWinPos->flags & SWP_NOMOVE)) {
#if CYGMULTIWINDOW_DEBUG
                    winDebug("\tmove\n");
#endif
                    if (winIsInternalWMRunning(pScreenInfo))
                        winAdjustXWindow(pWin, hwnd);

                    winMWExtWMMoveResizeXWindow(pWin,
                                                rcClient.left -
                                                wBorderWidth(pWin)
                                                -
                                                GetSystemMetrics
                                                (SM_XVIRTUALSCREEN),
                                                rcClient.top -
                                                wBorderWidth(pWin)
                                                -
                                                GetSystemMetrics
                                                (SM_YVIRTUALSCREEN),
                                                rcClient.right - rcClient.left -
                                                wBorderWidth(pWin) * 2,
                                                rcClient.bottom - rcClient.top -
                                                wBorderWidth(pWin) * 2);
                }
                else if (!(pWinPos->flags & SWP_NOMOVE)) {
#if CYGMULTIWINDOW_DEBUG
                    winDebug("\tmove\n");
#endif
                    if (winIsInternalWMRunning(pScreenInfo))
                        winAdjustXWindow(pWin, hwnd);

                    winMWExtWMMoveXWindow(pWin,
                                          rcClient.left - wBorderWidth(pWin)
                                          - GetSystemMetrics(SM_XVIRTUALSCREEN),
                                          rcClient.top - wBorderWidth(pWin)
                                          -
                                          GetSystemMetrics(SM_YVIRTUALSCREEN));
                }
                else if (!(pWinPos->flags & SWP_NOSIZE)) {
#if CYGMULTIWINDOW_DEBUG
                    winDebug("\tresize\n");
#endif
                    if (winIsInternalWMRunning(pScreenInfo))
                        winAdjustXWindow(pWin, hwnd);

                    winMWExtWMResizeXWindow(pWin,
                                            rcClient.right - rcClient.left
                                            - wBorderWidth(pWin) * 2,
                                            rcClient.bottom - rcClient.top
                                            - wBorderWidth(pWin) * 2);
                }
            }
        }
    }
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_WINDOWPOSCHANGED - done.\n");
#endif
        return 0;

    case WM_SIZE:
        /* see dix/window.c */
        /* FIXME: Maximize/Restore? */
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_SIZE\n");
#endif
#if CYGMULTIWINDOW_DEBUG
        winDebug("\t(%d, %d) %d\n", (short) LOWORD(lParam),
                 (short) HIWORD(lParam), g_fNoConfigureWindow);
#endif
        if (g_fNoConfigureWindow)
            break;

        /* Branch on type of resizing occurring */
        switch (wParam) {
        case SIZE_MINIMIZED:
#if CYGMULTIWINDOW_DEBUG
            winDebug("\tSIZE_MINIMIZED\n");
#endif
            if (winIsInternalWMRunning(pScreenInfo)) {
                /* Raise the window to the top in Z order */
                wmMsg.msg = WM_WM_LOWER;
                if (fWMMsgInitialized)
                    winSendMessageToWM(pScreenPriv->pWMInfo, &wmMsg);
            }
            winWindowsWMSendEvent(WindowsWMControllerNotify,
                                  WindowsWMControllerNotifyMask,
                                  1,
                                  WindowsWMMinimizeWindow,
                                  pWin->drawable.id,
                                  0, 0, LOWORD(lParam), HIWORD(lParam));
            break;

        case SIZE_RESTORED:
#if CYGMULTIWINDOW_DEBUG
            winDebug("\tSIZE_RESTORED\n");
#endif
            winWindowsWMSendEvent(WindowsWMControllerNotify,
                                  WindowsWMControllerNotifyMask,
                                  1,
                                  WindowsWMRestoreWindow,
                                  pWin->drawable.id,
                                  0, 0, LOWORD(lParam), HIWORD(lParam));
            break;

        case SIZE_MAXIMIZED:
#if CYGMULTIWINDOW_DEBUG
            winDebug("\tSIZE_MAXIMIZED\n");
#endif
            winWindowsWMSendEvent(WindowsWMControllerNotify,
                                  WindowsWMControllerNotifyMask,
                                  1,
                                  WindowsWMMaximizeWindow,
                                  pWin->drawable.id,
                                  0, 0, LOWORD(lParam), HIWORD(lParam));
            break;
        }

        /* Perform the resize and notify the X client */
        if (!pRLWinPriv->fMovingOrSizing) {
            if (winIsInternalWMRunning(pScreenInfo))
                winAdjustXWindow(pWin, hwnd);

            winMWExtWMResizeXWindow(pWin, (short) LOWORD(lParam)
                                    - wBorderWidth(pWin) * 2,
                                    (short) HIWORD(lParam)
                                    - wBorderWidth(pWin) * 2);
        }
        break;

    case WM_ACTIVATEAPP:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_ACTIVATEAPP\n");
#endif
        if (wParam) {
            if (winIsInternalWMRunning(pScreenInfo)) {
            }
            else {
            }
            winWindowsWMSendEvent(WindowsWMActivationNotify,
                                  WindowsWMActivationNotifyMask,
                                  1,
                                  WindowsWMIsActive,
                                  pWin->drawable.id, 0, 0, 0, 0);
        }
        else {
            winWindowsWMSendEvent(WindowsWMActivationNotify,
                                  WindowsWMActivationNotifyMask,
                                  1,
                                  WindowsWMIsInactive,
                                  pWin->drawable.id, 0, 0, 0, 0);
        }
        break;

    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT) {
            if (!g_fSoftwareCursor)
                SetCursor(pScreenPriv->cursor.handle);
            return TRUE;
        }
        break;

    case WM_ENTERSIZEMOVE:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_ENTERSIZEMOVE\n");
#endif
        pRLWinPriv->fMovingOrSizing = TRUE;
        break;

    case WM_EXITSIZEMOVE:
#if CYGMULTIWINDOW_DEBUG
        winDebug("winMWExtWMWindowProc - WM_EXITSIZEMOVE\n");
#endif
        pRLWinPriv->fMovingOrSizing = FALSE;

        GetClientRect(hwnd, &rcClient);

        MapWindowPoints(hwnd, HWND_DESKTOP, (LPPOINT) &rcClient, 2);

        if (winIsInternalWMRunning(pScreenInfo))
            winAdjustXWindow(pWin, hwnd);

        winMWExtWMMoveResizeXWindow(pWin, rcClient.left - wBorderWidth(pWin)
                                    - GetSystemMetrics(SM_XVIRTUALSCREEN),
                                    rcClient.top - wBorderWidth(pWin)
                                    - GetSystemMetrics(SM_YVIRTUALSCREEN),
                                    rcClient.right - rcClient.left
                                    - wBorderWidth(pWin) * 2,
                                    rcClient.bottom - rcClient.top
                                    - wBorderWidth(pWin) * 2);
        break;

    case WM_MANAGE:
        ErrorF("winMWExtWMWindowProc - WM_MANAGE\n");
        break;

    case WM_UNMANAGE:
        ErrorF("winMWExtWMWindowProc - WM_UNMANAGE\n");
        break;

    default:
        break;
    }

    return DefWindowProc(hwnd, message, wParam, lParam);
}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d861 1
a861 2
        winDebug("winMWExtWMWindowProc - WM_MOVE - %d ms\n",
                 (unsigned int) GetTickCount());
d904 1
a904 2
        winDebug("winMWExtWMWindowProc - WM_SHOWWINDOW - %d ms\n",
                 (unsigned int) GetTickCount());
d1156 1
a1156 2
        winDebug("winMWExtWMWindowProc - WM_SIZE - %d ms\n",
                 (unsigned int) GetTickCount());
d1224 1
a1224 2
        winDebug("winMWExtWMWindowProc - WM_ACTIVATEAPP - %d ms\n",
                 (unsigned int) GetTickCount());
d1256 1
a1256 2
        winDebug("winMWExtWMWindowProc - WM_ENTERSIZEMOVE - %d ms\n",
                 (unsigned int) GetTickCount());
d1263 1
a1263 2
        winDebug("winMWExtWMWindowProc - WM_EXITSIZEMOVE - %d ms\n",
                 (unsigned int) GetTickCount());
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d150 1
a150 1
     * 
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d652 1
a652 1
        return winMouseButtonsHandle(pScreen, ButtonPress, HIWORD(wParam) + 5,
d658 1
a658 1
        return winMouseButtonsHandle(pScreen, ButtonRelease, HIWORD(wParam) + 5,
d670 9
d835 2
a836 2
                winDebug("Win %08x is now restacking.\n",
                         (unsigned int) pRLWinPriv);
d843 2
a844 2
                winDebug("Win %08x has WINDOWSWM_RAISE_ON_CLICK.\n",
                         (unsigned int) pRLWinPriv);
d850 3
a852 3
            winDebug("Win %08x forbid to change z order (%08x).\n",
                     (unsigned int) pRLWinPriv,
                     (unsigned int) pWinPos->hwndInsertAfter);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d783 1
a783 1
                          (LPTSTR) & lpMsgBuf, 0, NULL);
d1061 1
a1061 1
                MapWindowPoints(hwnd, HWND_DESKTOP, (LPPOINT) & rcClient, 2);
d1266 1
a1266 1
        MapWindowPoints(hwnd, HWND_DESKTOP, (LPPOINT) & rcClient, 2);
@


1.4
log
@Update to xserver 1.11.2
@
text
@a45 1

a52 1

d57 1
a57 2
static UINT_PTR		g_uipMousePollingTimerID = 0;

d64 1
a64 1
DEFINE_ATOM_HELPER(AtmWindowsWMMouseActivate, WINDOWSWM_MOUSE_ACTIVATE)
a65 1

d71 1
a71 1
ConstrainSize (WinXSizeHints hints, int *widthp, int *heightp)
d73 11
a83 8
  int minWidth, minHeight, maxWidth, maxHeight, xinc, yinc, delta;
  int baseWidth, baseHeight;
  int dwidth = *widthp, dheight = *heightp;
  
  if (hints.flags & PMinSize)
    {
      minWidth = hints.min_width;
      minHeight = hints.min_height;
d85 6
a90 4
  else if (hints.flags & PBaseSize)
    {
      minWidth = hints.base_width;
      minHeight = hints.base_height;
d92 3
a94 12
  else
    minWidth = minHeight = 1;
  
  if (hints.flags & PBaseSize)
    {
      baseWidth = hints.base_width;
      baseHeight = hints.base_height;
    } 
  else if (hints.flags & PMinSize)
    {
      baseWidth = hints.min_width;
      baseHeight = hints.min_height;
d96 2
a97 2
  else
    baseWidth = baseHeight = 0;
d99 3
a101 4
  if (hints.flags & PMaxSize)
    {
      maxWidth = hints.max_width;
      maxHeight = hints.max_height;
d103 3
a105 4
  else
    {
      maxWidth = MAXINT;
      maxHeight = MAXINT;
d108 3
a110 4
  if (hints.flags & PResizeInc)
    {
      xinc = hints.width_inc;
      yinc = hints.height_inc;
d112 2
a113 2
  else
    xinc = yinc = 1;
d115 52
a166 50
  /*
   * First, clamp to min and max values
   */
  if (dwidth < minWidth)
    dwidth = minWidth;
  if (dheight < minHeight)
    dheight = minHeight;

  if (dwidth > maxWidth)
    dwidth = maxWidth;
  if (dheight > maxHeight)
    dheight = maxHeight;

  /*
   * Second, fit to base + N * inc
   */
  dwidth = ((dwidth - baseWidth) / xinc * xinc) + baseWidth;
  dheight = ((dheight - baseHeight) / yinc * yinc) + baseHeight;
  
  /*
   * Third, adjust for aspect ratio
   */

  /*
   * The math looks like this:
   *
   * minAspectX    dwidth     maxAspectX
   * ---------- <= ------- <= ----------
   * minAspectY    dheight    maxAspectY
   *
   * If that is multiplied out, then the width and height are
   * invalid in the following situations:
   *
   * minAspectX * dheight > minAspectY * dwidth
   * maxAspectX * dheight < maxAspectY * dwidth
   * 
   */
  
  if (hints.flags & PAspect)
    {
      if (hints.min_aspect.x * dheight > hints.min_aspect.y * dwidth)
        {
	  delta = makemult(hints.min_aspect.x * dheight / hints.min_aspect.y - dwidth, xinc);
	  if (dwidth + delta <= maxWidth)
	    dwidth += delta;
	  else
            {
	      delta = makemult(dheight - dwidth*hints.min_aspect.y/hints.min_aspect.x, yinc);
	      if (dheight - delta >= minHeight)
		dheight -= delta;
d169 14
a182 11
      
      if (hints.max_aspect.x * dheight < hints.max_aspect.y * dwidth)
        {
	  delta = makemult(dwidth * hints.max_aspect.y / hints.max_aspect.x - dheight, yinc);
	  if (dheight + delta <= maxHeight)
	    dheight += delta;
	  else
            {
	      delta = makemult(dwidth - hints.max_aspect.x*dheight/hints.max_aspect.y, xinc);
	      if (dwidth - delta >= minWidth)
		dwidth -= delta;
d186 4
a189 4
  
  /* Return computed values */
  *widthp = dwidth;
  *heightp = dheight;
d191 1
a193 2


d198 1
a198 2
ValidateSizing (HWND hwnd, WindowPtr pWin,
		WPARAM wParam, LPARAM lParam)
d200 10
a209 4
  WinXSizeHints sizeHints;
  RECT *rect;
  int iWidth, iHeight, iTopBorder;
  POINT pt;
d211 12
a222 5
  /* Invalid input checking */
  if (pWin==NULL || lParam==0)
    {
      ErrorF ("Invalid input checking\n");
      return FALSE;
d225 33
a257 5
  /* No size hints, no checking */
  if (!winMultiWindowGetWMNormalHints (pWin, &sizeHints))
    {
      ErrorF ("No size hints, no checking\n");
      return FALSE;
d259 11
a269 6
  
  /* Avoid divide-by-zero */
  if (sizeHints.flags & PResizeInc)
    {
      if (sizeHints.width_inc == 0) sizeHints.width_inc = 1;
      if (sizeHints.height_inc == 0) sizeHints.height_inc = 1;
d271 1
a271 48
  
  rect = (RECT*)lParam;
  
  iWidth = rect->right - rect->left;
  iHeight = rect->bottom - rect->top;

  /* Get title bar height, there must be an easier way?! */
  pt.x = pt.y = 0;
  ClientToScreen(hwnd, &pt);
  iTopBorder = pt.y - rect->top;
  
  /* Now remove size of any borders */
  iWidth -= 2 * GetSystemMetrics(SM_CXSIZEFRAME);
  iHeight -= GetSystemMetrics(SM_CYSIZEFRAME) + iTopBorder;

  /* Constrain the size to legal values */
  ConstrainSize (sizeHints, &iWidth, &iHeight);

  /* Add back the borders */
  iWidth += 2 * GetSystemMetrics(SM_CXSIZEFRAME);
  iHeight += GetSystemMetrics(SM_CYSIZEFRAME) + iTopBorder;

  /* Adjust size according to where we're dragging from */
  switch(wParam) {
  case WMSZ_TOP:
  case WMSZ_TOPRIGHT:
  case WMSZ_BOTTOM:
  case WMSZ_BOTTOMRIGHT:
  case WMSZ_RIGHT:
    rect->right = rect->left + iWidth;
    break;
  default:
    rect->left = rect->right - iWidth;
    break;
  }
  switch(wParam) {
  case WMSZ_BOTTOM:
  case WMSZ_BOTTOMRIGHT:
  case WMSZ_BOTTOMLEFT:
  case WMSZ_RIGHT:
  case WMSZ_LEFT:
    rect->bottom = rect->top + iHeight;
    break;
  default:
    rect->top = rect->bottom - iHeight;
    break;
  }
  return TRUE;
a273 1

d279 1
a279 1
IsRaiseOnClick (WindowPtr pWin)
d282 12
a293 5
  struct _Window	*pwin;
  struct _Property	*prop;  
  /* XXX We're getting inputInfo.poniter here, but this might be really wrong.
   * Which pointer's current window do we want? */
  WindowPtr		pRoot = GetCurrentRootWindow (inputInfo.pointer);
d295 1
a295 13
  if (!pWin)
    {
      ErrorF ("IsRaiseOnClick - no prop use default value:%d\n",
	      RAISE_ON_CLICK_DEFAULT);
      return RAISE_ON_CLICK_DEFAULT;
    } 

  pwin = (struct _Window*) pWin;

  if (pwin->optional)
    prop = (struct _Property *) pwin->optional->userProps;
  else
    prop = NULL;
d297 12
a308 10
  while (prop)
    {
      if (prop->propertyName == AtmWindowsWmRaiseOnClick ()
	  && prop->type == XA_INTEGER
	  && prop->format == 32)
	{
	  return *(int*)prop->data;
	}
      else
	prop = prop->next;
d311 2
a312 3
  if (pWin != pRoot)
    {
      return IsRaiseOnClick (pRoot);
d314 1
a314 2
  else
    {
d316 2
a317 2
      winDebug ("IsRaiseOnClick - no prop use default value:%d\n",
		RAISE_ON_CLICK_DEFAULT);
d319 1
a319 1
      return RAISE_ON_CLICK_DEFAULT;
a322 1

d328 1
a328 1
IsMouseActive (WindowPtr pWin)
d331 12
a342 5
  struct _Window	*pwin;
  struct _Property	*prop;
  /* XXX We're getting inputInfo.poniter here, but this might be really wrong.
   * Which pointer's current window do we want? */
  WindowPtr		pRoot = GetCurrentRootWindow (inputInfo.pointer);
d344 1
a344 13
  if (!pWin)
    {
      ErrorF ("IsMouseActive - pWin was NULL use default value:%d\n",
	      MOUSE_ACTIVATE_DEFAULT);
      return MOUSE_ACTIVATE_DEFAULT;
    } 

  pwin = (struct _Window*) pWin;

  if (pwin->optional)
    prop = (struct _Property *) pwin->optional->userProps;
  else
    prop = NULL;
d346 12
a357 10
  while (prop)
    {
      if (prop->propertyName == AtmWindowsWMMouseActivate ()
	  && prop->type == XA_INTEGER
	  && prop->format == 32)
	{
	  return *(int*)prop->data;
	}
      else
	prop = prop->next;
d360 2
a361 3
  if (pWin != pRoot)
    {
      return IsMouseActive (pRoot);
d363 1
a363 2
  else
    {
d365 2
a366 2
      winDebug ("IsMouseActive - no prop use default value:%d\n",
		MOUSE_ACTIVATE_DEFAULT);
d368 1
a368 1
      return MOUSE_ACTIVATE_DEFAULT;
a371 1

d377 1
a377 2
winMWExtWMWindowProc (HWND hwnd, UINT message, 
			    WPARAM wParam, LPARAM lParam)
d379 35
a413 14
  WindowPtr		pWin = NULL;
  win32RootlessWindowPtr pRLWinPriv = NULL;
  ScreenPtr		pScreen = NULL;
  winPrivScreenPtr	pScreenPriv = NULL;
  winScreenInfo		*pScreenInfo = NULL;
  HWND			hwndScreen = NULL;
  POINT			ptMouse;
  static Bool		s_fTracking = FALSE;
  HDC			hdcUpdate;
  PAINTSTRUCT		ps;
  LPWINDOWPOS		pWinPos = NULL;
  RECT			rcClient;
  winWMMessageRec	wmMsg;
  Bool			fWMMsgInitialized = FALSE;
d415 1
a415 19
  /* Check if the Windows window property for our X window pointer is valid */
  if ((pRLWinPriv = (win32RootlessWindowPtr)GetProp (hwnd, WIN_WINDOW_PROP)) != NULL)
    {
      pWin = pRLWinPriv->pFrame->win;
      pScreen				= pWin->drawable.pScreen;
      if (pScreen) pScreenPriv		= winGetScreenPriv(pScreen);
      if (pScreenPriv) pScreenInfo	= pScreenPriv->pScreenInfo;
      if (pScreenPriv) hwndScreen	= pScreenPriv->hwndScreen;

      wmMsg.msg		= 0;
      wmMsg.hwndWindow	= hwnd;
      wmMsg.iWindow	= (Window)pWin->drawable.id;

      wmMsg.iX		= pRLWinPriv->pFrame->x;
      wmMsg.iY		= pRLWinPriv->pFrame->y;
      wmMsg.iWidth	= pRLWinPriv->pFrame->width;
      wmMsg.iHeight	= pRLWinPriv->pFrame->height;

      fWMMsgInitialized = TRUE;
d417 2
a418 1
      winDebugWin32Message("winMWExtWMWindowProc", hwnd, message, wParam, lParam);
d420 6
a425 6
      winDebug ("\thWnd %08X\n", hwnd);
      winDebug ("\tpScreenPriv %08X\n", pScreenPriv);
      winDebug ("\tpScreenInfo %08X\n", pScreenInfo);
      winDebug ("\thwndScreen %08X\n", hwndScreen);
      winDebug ("winMWExtWMWindowProc (%08x) %08x %08x %08x\n",
	      pRLWinPriv, message, wParam, lParam);
d428 2
a429 3
  /* Branch on message type */
  switch (message)
    {
d432 1
a432 1
      winDebug ("winMWExtWMWindowProc - WM_CREATE\n");
d434 5
a438 5
      /* */
      SetProp (hwnd,
	       WIN_WINDOW_PROP,
	       (HANDLE)((LPCREATESTRUCT) lParam)->lpCreateParams);
      return 0;
d442 1
a442 1
      winDebug ("winMWExtWMWindowProc - WM_CLOSE %d\n", pRLWinPriv->fClose);
d444 18
a461 22
      /* Tell window-manager to close window */
      if (pRLWinPriv->fClose)
	{
	  DestroyWindow (hwnd);
	}
      else
	{
	  if (winIsInternalWMRunning(pScreenInfo))
	    {
	      /* Tell our Window Manager thread to kill the window */
	      wmMsg.msg = WM_WM_KILL;
	      if (fWMMsgInitialized)
		winSendMessageToWM (pScreenPriv->pWMInfo, &wmMsg);
	    }
	  winWindowsWMSendEvent(WindowsWMControllerNotify,
				WindowsWMControllerNotifyMask,
				1,
				WindowsWMCloseWindow,
				pWin->drawable.id,
				0, 0, 0, 0);
	}
      return 0;
d465 1
a465 1
      winDebug ("winMWExtWMWindowProc - WM_DESTROY\n");
d467 21
a487 21
      /* Free the shaodw DC; which allows the bitmap to be freed */
      DeleteDC (pRLWinPriv->hdcShadow);
      pRLWinPriv->hdcShadow = NULL;
      
      /* Free the shadow bitmap */
      DeleteObject (pRLWinPriv->hbmpShadow);
      pRLWinPriv->hbmpShadow = NULL;
      
      /* Free the screen DC */
      ReleaseDC (pRLWinPriv->hWnd, pRLWinPriv->hdcScreen);
      pRLWinPriv->hdcScreen = NULL;

      /* Free shadow buffer info header */
      free (pRLWinPriv->pbmihShadow);
      pRLWinPriv->pbmihShadow = NULL;
      
      pRLWinPriv->fResized = FALSE;
      pRLWinPriv->pfb = NULL;
      free (pRLWinPriv);
      RemoveProp (hwnd, WIN_WINDOW_PROP);
      break;
d491 1
a491 1
      winDebug ("winMWExtWMWindowProc - WM_MOUSEMOVE\n");
d493 50
a542 50
      /* Unpack the client area mouse coordinates */
      ptMouse.x = GET_X_LPARAM(lParam);
      ptMouse.y = GET_Y_LPARAM(lParam);

      /* Translate the client area mouse coordinates to screen coordinates */
      ClientToScreen (hwnd, &ptMouse);

      /* Screen Coords from (-X, -Y) -> Root Window (0, 0) */
      ptMouse.x -= GetSystemMetrics (SM_XVIRTUALSCREEN);
      ptMouse.y -= GetSystemMetrics (SM_YVIRTUALSCREEN);

      /* We can't do anything without privates */
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;

      /* Has the mouse pointer crossed screens? */
      if (pScreen != miPointerGetScreen(inputInfo.pointer))
	miPointerSetScreen (inputInfo.pointer, pScreenInfo->dwScreen,
			       ptMouse.x - pScreenInfo->dwXOffset,
			       ptMouse.y - pScreenInfo->dwYOffset);

      /* Are we tracking yet? */
      if (!s_fTracking)
	{
	  TRACKMOUSEEVENT		tme;
	  
	  /* Setup data structure */
	  ZeroMemory (&tme, sizeof (tme));
	  tme.cbSize = sizeof (tme);
	  tme.dwFlags = TME_LEAVE;
	  tme.hwndTrack = hwnd;

	  /* Call the tracking function */
	  if (!(*g_fpTrackMouseEvent) (&tme))
	    ErrorF ("winMWExtWMWindowProc - _TrackMouseEvent failed\n");

	  /* Flag that we are tracking now */
	  s_fTracking = TRUE;
	}
      
      /* Kill the timer used to poll mouse events */
      if (g_uipMousePollingTimerID != 0)
	{
	  KillTimer (pScreenPriv->hwndScreen, WIN_POLLING_MOUSE_TIMER_ID);
	  g_uipMousePollingTimerID = 0;
	}

      /* Deliver absolute cursor position to X Server */
      winEnqueueMotion(ptMouse.x - pScreenInfo->dwXOffset,
		       ptMouse.y - pScreenInfo->dwYOffset);
a543 2
      return 0;
      
d546 1
a546 1
      winDebug ("winMWExtWMWindowProc - WM_NCMOUSEMOVE\n");
d548 22
a569 23
      /*
       * We break instead of returning 0 since we need to call
       * DefWindowProc to get the mouse cursor changes
       * and min/max/close button highlighting in Windows XP.
       * The Platform SDK says that you should return 0 if you
       * process this message, but it fails to mention that you
       * will give up any default functionality if you do return 0.
       */
      
      /* We can't do anything without privates */
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;

      /*
       * Timer to poll mouse events.  This is needed to make
       * programs like xeyes follow the mouse properly.
       */
      if (g_uipMousePollingTimerID == 0)
	g_uipMousePollingTimerID = SetTimer (pScreenPriv->hwndScreen,
					     WIN_POLLING_MOUSE_TIMER_ID,
					     MOUSE_POLLING_INTERVAL,
					     NULL);
      break;
d573 1
a573 1
      winDebug ("winMWExtWMWindowProc - WM_MOUSELEAVE\n");
d575 1
a575 1
      /* Mouse has left our client area */
d577 2
a578 2
      /* Flag that we are no longer tracking */
      s_fTracking = FALSE;
d580 9
a588 10
      /*
       * Timer to poll mouse events.  This is needed to make
       * programs like xeyes follow the mouse properly.
       */
      if (g_uipMousePollingTimerID == 0)
	g_uipMousePollingTimerID = SetTimer (pScreenPriv->hwndScreen,
					     WIN_POLLING_MOUSE_TIMER_ID,
					     MOUSE_POLLING_INTERVAL,
					     NULL);
      return 0;
d593 1
a593 1
      winDebug ("winMWExtWMWindowProc - WM_LBUTTONDBLCLK\n");
d595 5
a599 5
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      SetCapture (hwnd);
      return winMouseButtonsHandle (pScreen, ButtonPress, Button1, wParam);
      
d602 1
a602 1
      winDebug ("winMWExtWMWindowProc - WM_LBUTTONUP\n");
d604 4
a607 4
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      ReleaseCapture ();
      return winMouseButtonsHandle (pScreen, ButtonRelease, Button1, wParam);
d612 1
a612 1
      winDebug ("winMWExtWMWindowProc - WM_MBUTTONDBLCLK\n");
d614 5
a618 5
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      SetCapture (hwnd);
      return winMouseButtonsHandle (pScreen, ButtonPress, Button2, wParam);
      
d621 1
a621 1
      winDebug ("winMWExtWMWindowProc - WM_MBUTTONUP\n");
d623 5
a627 5
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      ReleaseCapture ();
      return winMouseButtonsHandle (pScreen, ButtonRelease, Button2, wParam);
      
d631 1
a631 1
      winDebug ("winMWExtWMWindowProc - WM_RBUTTONDBLCLK\n");
d633 5
a637 5
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      SetCapture (hwnd);
      return winMouseButtonsHandle (pScreen, ButtonPress, Button3, wParam);
      
d640 1
a640 1
      winDebug ("winMWExtWMWindowProc - WM_RBUTTONUP\n");
d642 4
a645 4
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      ReleaseCapture ();
      return winMouseButtonsHandle (pScreen, ButtonRelease, Button3, wParam);
d649 5
a653 4
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      SetCapture (hwnd);
      return winMouseButtonsHandle (pScreen, ButtonPress, HIWORD(wParam) + 5, wParam);
d655 5
a659 4
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      ReleaseCapture ();
      return winMouseButtonsHandle (pScreen, ButtonRelease, HIWORD(wParam) + 5, wParam);
d663 1
a663 1
      winDebug ("winMWExtWMWindowProc - WM_MOUSEWHEEL\n");
d665 4
a668 4
      
      /* Pass the message to the root window */
      SendMessage (hwndScreen, message, wParam, lParam);
      return 0;
d672 1
a672 1
      winDebug ("winMWExtWMWindowProc - WM_MOUSEACTIVATE\n");
d675 2
a676 3
      /* Check if this window needs to be made active when clicked */
      if (winIsInternalWMRunning(pScreenInfo) && pWin->overrideRedirect)
	{
d678 2
a679 2
	  winDebug ("winMWExtWMWindowProc - WM_MOUSEACTIVATE - "
		    "MA_NOACTIVATE\n");
d682 3
a684 3
	  /* */
	  return MA_NOACTIVATE;
	}
d686 2
a687 2
      if (!winIsInternalWMRunning(pScreenInfo) && !IsMouseActive (pWin))
	return MA_NOACTIVATE;
d689 1
a689 1
      break;
d692 3
a694 3
      /* Pop any pressed keys since we are losing keyboard focus */
      winKeybdReleaseKeys ();
      return 0;
d698 5
a702 5
      /*
       * NOTE: We do nothing with WM_*CHAR messages,
       * nor does the root window, so we can just toss these messages.
       */
      return 0;
d707 1
a707 1
      winDebug ("winMWExtWMWindowProc - WM_*KEYDOWN\n");
d710 20
a729 20
      /*
       * Don't pass Alt-F4 key combo to root window,
       * let Windows translate to WM_CLOSE and close this top-level window.
       *
       * NOTE: We purposely don't check the fUseWinKillKey setting because
       * it should only apply to the key handling for the root window,
       * not for top-level window-manager windows.
       *
       * ALSO NOTE: We do pass Ctrl-Alt-Backspace to the root window
       * because that is a key combo that no X app should be expecting to
       * receive, since it has historically been used to shutdown the X server.
       * Passing Ctrl-Alt-Backspace to the root window preserves that
       * behavior, assuming that -unixkill has been passed as a parameter.
       */
      if (wParam == VK_F4 && (GetKeyState (VK_MENU) & 0x8000))
	  break;

      /* Pass the message to the root window */
      SendMessage (hwndScreen, message, wParam, lParam);
      return 0;
d735 1
a735 1
      winDebug ("winMWExtWMWindowProc - WM_*KEYUP\n");
d738 3
a740 3
      /* Pass the message to the root window */
      SendMessage (hwndScreen, message, wParam, lParam);
      return 0;
d744 1
a744 1
      winDebug ("winMWExtWMWindowProc - WM_HOTKEY\n");
d747 3
a749 3
      /* Pass the message to the root window */
      SendMessage (hwndScreen, message, wParam, lParam);
      return 0;
d753 1
a753 1
      winDebug ("winMWExtWMWindowProc - WM_ERASEBKGND\n");
d755 6
a760 6
      /*
       * Pretend that we did erase the background but we don't care,
       * since we repaint the entire region anyhow
       * This avoids some flickering when resizing.
       */
      return TRUE;
d763 30
a792 33
    
      /* BeginPaint gives us an hdc that clips to the invalidated region */
      hdcUpdate = BeginPaint (hwnd, &ps);

      /* Try to copy from the shadow buffer */
      if (!BitBlt (hdcUpdate,
		   ps.rcPaint.left, ps.rcPaint.top,
		   ps.rcPaint.right - ps.rcPaint.left,
		   ps.rcPaint.bottom - ps.rcPaint.top,
		   pRLWinPriv->hdcShadow,
		   ps.rcPaint.left, ps.rcPaint.top,
		   SRCCOPY))
	{
	  LPVOID lpMsgBuf;
	  
	  /* Display a fancy error message */
	  FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			 FORMAT_MESSAGE_FROM_SYSTEM | 
			 FORMAT_MESSAGE_IGNORE_INSERTS,
			 NULL,
			 GetLastError (),
			 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			 (LPTSTR) &lpMsgBuf,
			 0, NULL);

	  ErrorF ("winMWExtWMWindowProc - BitBlt failed: %s\n",
		  (LPSTR)lpMsgBuf);
	  LocalFree (lpMsgBuf);
	}

      /* EndPaint frees the DC */
      EndPaint (hwnd, &ps);
      break;
d796 1
a796 1
      winDebug ("winMWExtWMWindowProc - WM_ACTIVATE\n");
d798 2
a799 4
      if (LOWORD(wParam) != WA_INACTIVE)
	{
	  if (winIsInternalWMRunning(pScreenInfo))
	    {
d801 18
a818 20
	      /* Raise the window to the top in Z order */
	      wmMsg.msg = WM_WM_RAISE;
	      if (fWMMsgInitialized)
		winSendMessageToWM (pScreenPriv->pWMInfo, &wmMsg);
#endif
	      /* Tell our Window Manager thread to activate the window */
	      wmMsg.msg = WM_WM_ACTIVATE;
	      if (fWMMsgInitialized)
		if (!pWin || !pWin->overrideRedirect) /* for OOo menus */
		  winSendMessageToWM (pScreenPriv->pWMInfo, &wmMsg);
	    }
	  winWindowsWMSendEvent(WindowsWMControllerNotify,
				WindowsWMControllerNotifyMask,
				1,
				WindowsWMActivateWindow,
				pWin->drawable.id,
				0, 0,
				0, 0);
	}
      return 0;
d822 3
a824 5
      pWinPos = (LPWINDOWPOS)lParam;
      if (!(pWinPos->flags & SWP_NOZORDER))
	{
	  if (pRLWinPriv->fRestackingNow || pScreenPriv->fRestacking)
	    {
d826 2
a827 1
	      winDebug ("Win %08x is now restacking.\n", (unsigned int)pRLWinPriv);
d829 2
a830 2
	      break;
	    }
d832 1
a832 2
	  if (winIsInternalWMRunning(pScreenInfo) || IsRaiseOnClick (pWin))
	    {
d834 2
a835 1
	      winDebug ("Win %08x has WINDOWSWM_RAISE_ON_CLICK.\n", (unsigned int)pRLWinPriv);
d837 2
a838 2
	      break;
	    }
d841 3
a843 2
	  winDebug ("Win %08x forbid to change z order (%08x).\n",
		    (unsigned int)pRLWinPriv, (unsigned int)pWinPos->hwndInsertAfter);
d845 3
a847 3
	  pWinPos->flags |= SWP_NOZORDER;
	}
      break;
d852 2
a853 2
      winDebug ("winMWExtWMWindowProc - WM_MOVE - %d ms\n",
		(unsigned int)GetTickCount ());
d855 2
a856 1
      if (g_fNoConfigureWindow) break;
d858 19
a876 18
      /* Bail if Windows window is not actually moving */
      if (pRLWinPriv->dwX == (short) LOWORD(lParam)
	  && pRLWinPriv->dwY == (short) HIWORD(lParam))
	break;

      /* Also bail if we're maximizing, we'll do the whole thing in WM_SIZE */
      {
	WINDOWPLACEMENT windPlace;
	windPlace.length = sizeof (WINDOWPLACEMENT);

	/* Get current window placement */
	GetWindowPlacement (hwnd, &windPlace);

	/* Bail if maximizing */
	if (windPlace.showCmd == SW_MAXIMIZE
	    || windPlace.showCmd == SW_SHOWMAXIMIZED)
	  break;
      }
d880 13
a892 14
      winDebug ("\t(%d, %d)\n", (short) LOWORD(lParam), (short) HIWORD(lParam));
#endif
      if (!pRLWinPriv->fMovingOrSizing)
	{
	  if (winIsInternalWMRunning(pScreenInfo))
	    winAdjustXWindow (pWin, hwnd);

	  winMWExtWMMoveXWindow (pWin,
				 (LOWORD(lParam) - wBorderWidth (pWin)
				  - GetSystemMetrics (SM_XVIRTUALSCREEN)),
				 (HIWORD(lParam) - wBorderWidth (pWin)
				  - GetSystemMetrics (SM_YVIRTUALSCREEN)));
	}
      return 0;
d896 2
a897 2
      winDebug ("winMWExtWMWindowProc - WM_SHOWWINDOW - %d ms\n",
		(unsigned int)GetTickCount ());
d899 3
a901 3
      /* Bail out if the window is being hidden */
      if (!wParam)
	return 0;
d903 2
a904 2
      if (!pScreenInfo->fInternalWM)//XXXX
	return 0;
d906 1
a906 1
      winMWExtWMUpdateWindowDecoration (pRLWinPriv, pScreenInfo);
d908 1
a908 2
      if (winIsInternalWMRunning(pScreenInfo))
	{
d910 1
a910 1
	  winDebug ("\tMapWindow\n");
d912 2
a913 2
	  /* Tell X to map the window */
	   MapWindow (pWin, wClient(pWin));
d915 14
a928 14
	  if (!pRLWinPriv->pFrame->win->overrideRedirect)
	    /* Bring the Windows window to the foreground */
	    SetForegroundWindow (hwnd);

	  /* Setup the Window Manager message */
	  wmMsg.msg = WM_WM_MAP;
	  wmMsg.iWidth = pRLWinPriv->pFrame->width;
	  wmMsg.iHeight = pRLWinPriv->pFrame->height;

	  /* Tell our Window Manager thread to map the window */
	  if (fWMMsgInitialized)
	    winSendMessageToWM (pScreenPriv->pWMInfo, &wmMsg);
	}
      break;
d931 3
a933 3
      /* Need to legalize the size according to WM_NORMAL_HINTS */
      /* for applications like xterm */
      return ValidateSizing (hwnd, pWin, wParam, lParam);
d936 2
a937 2
      {
	pWinPos = (LPWINDOWPOS) lParam;
d940 42
a981 41
	winDebug("\tflags: %s%s%s%s%s%s%s%s%s%s%s%s\n",
	(pWinPos->flags & SWP_DRAWFRAME)?"SWP_DRAWFRAME ":"",
	(pWinPos->flags & SWP_FRAMECHANGED)?"SWP_FRAMECHANGED ":"",
	(pWinPos->flags & SWP_HIDEWINDOW)?"SWP_HIDEWINDOW ":"",
	(pWinPos->flags & SWP_NOACTIVATE)?"SWP_NOACTIVATE ":"",
	(pWinPos->flags & SWP_NOCOPYBITS)?"SWP_NOCOPYBITS ":"",
	(pWinPos->flags & SWP_NOMOVE)?"SWP_NOMOVE ":"",
	(pWinPos->flags & SWP_NOOWNERZORDER)?"SWP_NOOWNERZORDER ":"",
	(pWinPos->flags & SWP_NOSIZE)?"SWP_NOSIZE ":"",
	(pWinPos->flags & SWP_NOREDRAW)?"SWP_NOREDRAW ":"",
	(pWinPos->flags & SWP_NOSENDCHANGING)?"SWP_NOSENDCHANGING ":"",
	(pWinPos->flags & SWP_NOZORDER)?"SWP_NOZORDER ":"",
	(pWinPos->flags & SWP_SHOWWINDOW)?"SWP_SHOWWINDOW ":"");
	winDebug("\tno_configure: %s\n", (g_fNoConfigureWindow?"Yes":"No"));
	winDebug("\textend: (%d, %d, %d, %d)\n",
            pWinPos->x, pWinPos->y, pWinPos->cx, pWinPos->cy);

#endif
	if (pWinPos->flags & SWP_HIDEWINDOW) break;

	/* Reorder if window z order was changed */
	if ((pScreenPriv != NULL)
	    && !(pWinPos->flags & SWP_NOZORDER)
	    && !(pWinPos->flags & SWP_SHOWWINDOW)
	    && winIsInternalWMRunning(pScreenInfo))
	  {
#if CYGMULTIWINDOW_DEBUG
	    winDebug ("\twindow z order was changed\n");
#endif
	    if (pWinPos->hwndInsertAfter == HWND_TOP
		||pWinPos->hwndInsertAfter == HWND_TOPMOST
		||pWinPos->hwndInsertAfter == HWND_NOTOPMOST)
	      {
#if CYGMULTIWINDOW_DEBUG
		winDebug ("\traise to top\n");
#endif
		/* Raise the window to the top in Z order */
		wmMsg.msg = WM_WM_RAISE;
		if (fWMMsgInitialized)
		  winSendMessageToWM (pScreenPriv->pWMInfo, &wmMsg);
	      }
d983 53
a1035 147
	    else if (pWinPos->hwndInsertAfter == HWND_BOTTOM)
	      {
	      }
	    else
	      {
		/* Check if this window is top of X windows. */
		HWND hWndAbove = NULL;
		DWORD dwCurrentProcessID = GetCurrentProcessId ();
		DWORD dwWindowProcessID = 0;

		for (hWndAbove = pWinPos->hwndInsertAfter;
		     hWndAbove != NULL;
		     hWndAbove = GetNextWindow (hWndAbove, GW_HWNDPREV))
		  {
		    /* Ignore other XWin process's window */
		    GetWindowThreadProcessId (hWndAbove, &dwWindowProcessID);

		    if ((dwWindowProcessID == dwCurrentProcessID)
			&& GetProp (hWndAbove, WIN_WINDOW_PROP)
			&& !IsWindowVisible (hWndAbove)
			&& !IsIconic (hWndAbove) ) /* ignore minimized windows */
		      break;
		  }
		/* If this is top of X windows in Windows stack,
		   raise it in X stack. */
		if (hWndAbove == NULL)
		  {
#if CYGMULTIWINDOW_DEBUG
		    winDebug ("\traise to top\n");
#endif
		    /* Raise the window to the top in Z order */
		    wmMsg.msg = WM_WM_RAISE;
		    if (fWMMsgInitialized)
		      winSendMessageToWM (pScreenPriv->pWMInfo, &wmMsg);
		  }
	      }
#endif
	  }

	if (!(pWinPos->flags & SWP_NOSIZE)) {
	  if (IsIconic(hwnd)){
#if CYGMULTIWINDOW_DEBUG
	    winDebug ("\tIconic -> MINIMIZED\n");
#endif
	    if (winIsInternalWMRunning(pScreenInfo))
	      {
	      /* Raise the window to the top in Z order */
		wmMsg.msg = WM_WM_LOWER;
		if (fWMMsgInitialized)
		  winSendMessageToWM (pScreenPriv->pWMInfo, &wmMsg);
	      }
	    winWindowsWMSendEvent(WindowsWMControllerNotify,
				  WindowsWMControllerNotifyMask,
				  1,
				  WindowsWMMinimizeWindow,
				  pWin->drawable.id,
				  0, 0, 0, 0);
	  } else if (IsZoomed(hwnd)){
#if CYGMULTIWINDOW_DEBUG
	    winDebug ("\tZoomed -> MAXIMIZED\n");
#endif
	    winWindowsWMSendEvent(WindowsWMControllerNotify,
				  WindowsWMControllerNotifyMask,
				  1,
				  WindowsWMMaximizeWindow,
				  pWin->drawable.id,
				  0, 0, 0, 0);
	  } else {
#if CYGMULTIWINDOW_DEBUG
	    winDebug ("\tnone -> RESTORED\n");
#endif
	    winWindowsWMSendEvent(WindowsWMControllerNotify,
				  WindowsWMControllerNotifyMask,
				  1,
				  WindowsWMRestoreWindow,
				  pWin->drawable.id,
				  0, 0, 0, 0);
	  }
	}
	if (!g_fNoConfigureWindow ) {

	  if (!pRLWinPriv->fMovingOrSizing
	      /*&& (pWinPos->flags & SWP_SHOWWINDOW)*/) {
	    GetClientRect (hwnd, &rcClient);
	    MapWindowPoints (hwnd, HWND_DESKTOP, (LPPOINT)&rcClient, 2);

	    if (!(pWinPos->flags & SWP_NOMOVE)
		&&!(pWinPos->flags & SWP_NOSIZE)) {
#if CYGMULTIWINDOW_DEBUG
	      winDebug ("\tmove & resize\n");
#endif
	      if (winIsInternalWMRunning(pScreenInfo))
                winAdjustXWindow (pWin, hwnd);

	      winMWExtWMMoveResizeXWindow (pWin,
					   rcClient.left - wBorderWidth (pWin)
					   - GetSystemMetrics (SM_XVIRTUALSCREEN),
					   rcClient.top - wBorderWidth (pWin)
					   - GetSystemMetrics (SM_YVIRTUALSCREEN),
					   rcClient.right - rcClient.left
					   - wBorderWidth (pWin)*2,
					   rcClient.bottom - rcClient.top
					   - wBorderWidth (pWin)*2);
	    } else if (!(pWinPos->flags & SWP_NOMOVE)) {
#if CYGMULTIWINDOW_DEBUG
	      winDebug ("\tmove\n");
#endif
	      if (winIsInternalWMRunning(pScreenInfo))
                winAdjustXWindow (pWin, hwnd);

	      winMWExtWMMoveResizeXWindow (pWin,
					   rcClient.left - wBorderWidth (pWin)
					   - GetSystemMetrics (SM_XVIRTUALSCREEN),
					   rcClient.top - wBorderWidth (pWin)
					   - GetSystemMetrics (SM_YVIRTUALSCREEN),
					   rcClient.right - rcClient.left
					   - wBorderWidth (pWin)*2,
					   rcClient.bottom - rcClient.top
					   - wBorderWidth (pWin)*2);
	    } else if (!(pWinPos->flags & SWP_NOMOVE)) {
#if CYGMULTIWINDOW_DEBUG
	      winDebug ("\tmove\n");
#endif
	      if (winIsInternalWMRunning(pScreenInfo))
                winAdjustXWindow (pWin, hwnd); 

	      winMWExtWMMoveXWindow (pWin,
				     rcClient.left - wBorderWidth (pWin)
				     - GetSystemMetrics (SM_XVIRTUALSCREEN),
				     rcClient.top - wBorderWidth (pWin)
				     - GetSystemMetrics (SM_YVIRTUALSCREEN));
	    } else if (!(pWinPos->flags & SWP_NOSIZE)) {
#if CYGMULTIWINDOW_DEBUG
	      winDebug ("\tresize\n");
#endif
	      if (winIsInternalWMRunning(pScreenInfo))
                winAdjustXWindow (pWin, hwnd); 

	      winMWExtWMResizeXWindow (pWin,
				       rcClient.right - rcClient.left
				       - wBorderWidth (pWin)*2,
				       rcClient.bottom - rcClient.top
				       - wBorderWidth (pWin)*2);
	    }
	  }
	}
      }
d1037 1
a1037 1
      winDebug ("winMWExtWMWindowProc - WM_WINDOWPOSCHANGED - done.\n");
d1039 105
a1143 1
      return 0;
d1146 2
a1147 2
      /* see dix/window.c */
      /* FIXME: Maximize/Restore? */
d1149 2
a1150 2
      winDebug ("winMWExtWMWindowProc - WM_SIZE - %d ms\n",
		(unsigned int)GetTickCount ());
d1153 2
a1154 1
      winDebug ("\t(%d, %d) %d\n", (short) LOWORD(lParam), (short) HIWORD(lParam), g_fNoConfigureWindow);
d1156 59
a1214 65
      if (g_fNoConfigureWindow) break;

      /* Branch on type of resizing occurring */
      switch (wParam)
	{
	case SIZE_MINIMIZED:
#if CYGMULTIWINDOW_DEBUG
	  winDebug ("\tSIZE_MINIMIZED\n");
#endif
	  if (winIsInternalWMRunning(pScreenInfo))
	    {
	      /* Raise the window to the top in Z order */
	      wmMsg.msg = WM_WM_LOWER;
	      if (fWMMsgInitialized)
		winSendMessageToWM (pScreenPriv->pWMInfo, &wmMsg);
	    }
	  winWindowsWMSendEvent(WindowsWMControllerNotify,
				WindowsWMControllerNotifyMask,
				1,
				WindowsWMMinimizeWindow,
				pWin->drawable.id,
				0, 0,
				LOWORD(lParam), HIWORD(lParam));
	  break;

	case SIZE_RESTORED:
#if CYGMULTIWINDOW_DEBUG
	  winDebug ("\tSIZE_RESTORED\n");
#endif
	  winWindowsWMSendEvent(WindowsWMControllerNotify,
				WindowsWMControllerNotifyMask,
				1,
				WindowsWMRestoreWindow,
				pWin->drawable.id,
				0, 0,
				LOWORD(lParam), HIWORD(lParam));
	  break;

	case SIZE_MAXIMIZED:
#if CYGMULTIWINDOW_DEBUG
	  winDebug ("\tSIZE_MAXIMIZED\n");
#endif
	  winWindowsWMSendEvent(WindowsWMControllerNotify,
				WindowsWMControllerNotifyMask,
				1,
				WindowsWMMaximizeWindow,
				pWin->drawable.id,
				0, 0,
				LOWORD(lParam), HIWORD(lParam));
	  break;
	}

      /* Perform the resize and notify the X client */
      if (!pRLWinPriv->fMovingOrSizing)
	{
	  if (winIsInternalWMRunning(pScreenInfo))
            winAdjustXWindow (pWin, hwnd);

	  winMWExtWMResizeXWindow (pWin,
				   (short) LOWORD(lParam)
				   - wBorderWidth (pWin)*2,
				   (short) HIWORD(lParam)
				   - wBorderWidth (pWin)*2);
	}
      break;
d1218 2
a1219 2
      winDebug ("winMWExtWMWindowProc - WM_ACTIVATEAPP - %d ms\n",
		(unsigned int)GetTickCount ());
d1221 19
a1239 27
      if (wParam)
	{
	  if (winIsInternalWMRunning(pScreenInfo))
	    {
	    }
	  else
	    {
	    }
	  winWindowsWMSendEvent(WindowsWMActivationNotify,
				WindowsWMActivationNotifyMask,
				1,
				WindowsWMIsActive,
				pWin->drawable.id,
				0, 0,
				0, 0);
	}
      else
	{
	  winWindowsWMSendEvent(WindowsWMActivationNotify,
				WindowsWMActivationNotifyMask,
				1,
				WindowsWMIsInactive,
				pWin->drawable.id,
				0, 0,
				0, 0);
	}
      break;
d1242 6
a1247 6
      if (LOWORD(lParam) == HTCLIENT)
	{
	  if (!g_fSoftwareCursor) SetCursor (pScreenPriv->cursor.handle);
	  return TRUE;
	}
      break;
d1251 2
a1252 2
      winDebug ("winMWExtWMWindowProc - WM_ENTERSIZEMOVE - %d ms\n",
		(unsigned int)GetTickCount ());
d1254 2
a1255 2
      pRLWinPriv->fMovingOrSizing = TRUE;
      break;
d1259 2
a1260 2
      winDebug ("winMWExtWMWindowProc - WM_EXITSIZEMOVE - %d ms\n",
		(unsigned int)GetTickCount ());
d1262 1
a1262 1
      pRLWinPriv->fMovingOrSizing = FALSE;
d1264 1
a1264 1
      GetClientRect (hwnd, &rcClient);
d1266 1
a1266 1
      MapWindowPoints (hwnd, HWND_DESKTOP, (LPPOINT)&rcClient, 2);
d1268 12
a1279 13
      if (winIsInternalWMRunning(pScreenInfo))
        winAdjustXWindow (pWin, hwnd); 

      winMWExtWMMoveResizeXWindow (pWin,
				   rcClient.left - wBorderWidth (pWin)
				   - GetSystemMetrics (SM_XVIRTUALSCREEN),
				   rcClient.top - wBorderWidth (pWin)
				   - GetSystemMetrics (SM_YVIRTUALSCREEN),
				   rcClient.right - rcClient.left
				   - wBorderWidth (pWin)*2,
				   rcClient.bottom - rcClient.top
				   - wBorderWidth (pWin)*2);
      break;
d1282 2
a1283 2
      ErrorF ("winMWExtWMWindowProc - WM_MANAGE\n");
      break;
d1286 2
a1287 2
      ErrorF ("winMWExtWMWindowProc - WM_UNMANAGE\n");
      break;
d1290 1
a1290 1
      break;
d1293 1
a1293 1
  return DefWindowProc (hwnd, message, wParam, lParam);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a55 8
 * Global variables
 */

extern Bool			g_fNoConfigureWindow;
extern Bool			g_fSoftwareCursor;


/*
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d38 1
a38 1
#include "windowswmstr.h"
a50 1
#define MOUSE_POLLING_INTERVAL		500
d573 3
a575 3
      miPointerAbsoluteCursor (ptMouse.x - pScreenInfo->dwXOffset,
			       ptMouse.y - pScreenInfo->dwYOffset,
			       g_c32LastInputEventTime = GetTickCount ());
d785 11
@


1.1
log
@Initial revision
@
text
@d44 1
d303 3
a305 1
  WindowPtr		pRoot = GetCurrentRootWindow ();
d358 3
a360 1
  WindowPtr		pRoot = GetCurrentRootWindow ();
d542 2
a543 2
      if (pScreen != miPointerCurrentScreen ())
	miPointerSetNewScreen (pScreenInfo->dwScreen,
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a43 1
#include "inputstr.h"
d537 2
a538 2
      if (pScreen != miPointerGetScreen(inputInfo.pointer))
	miPointerSetScreen (inputInfo.pointer, pScreenInfo->dwScreen,
@

