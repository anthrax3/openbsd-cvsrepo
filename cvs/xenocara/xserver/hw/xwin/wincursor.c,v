head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.19;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Dakshinamurthy Karra
 *		Suhaib M Siddiqi
 *		Peter Busch
 *		Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include "winmsg.h"
#include <cursorstr.h>
#include <mipointrst.h>
#include <servermd.h>
#include "misc.h"

#define BRIGHTNESS(x) (x##Red * 0.299 + x##Green * 0.587 + x##Blue * 0.114)

#if 0
#define WIN_DEBUG_MSG winDebug
#else
#define WIN_DEBUG_MSG(...)
#endif

/*
 * Local function prototypes
 */

static void
 winPointerWarpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y);

static Bool
 winCursorOffScreen(ScreenPtr *ppScreen, int *x, int *y);

static void
 winCrossScreen(ScreenPtr pScreen, Bool fEntering);

miPointerScreenFuncRec g_winPointerCursorFuncs = {
    winCursorOffScreen,
    winCrossScreen,
    winPointerWarpCursor
};

static void
winPointerWarpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
    winScreenPriv(pScreen);
    RECT rcClient;
    static Bool s_fInitialWarp = TRUE;

    /* Discard first warp call */
    if (s_fInitialWarp) {
        /* First warp moves mouse to center of window, just ignore it */

        /* Don't ignore subsequent warps */
        s_fInitialWarp = FALSE;

        winErrorFVerb(2,
                      "winPointerWarpCursor - Discarding first warp: %d %d\n",
                      x, y);

        return;
    }

    /*
       Only update the Windows cursor position if root window is active,
       or we are in a rootless mode
     */
    if ((pScreenPriv->hwndScreen == GetForegroundWindow())
        || pScreenPriv->pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOW
        || pScreenPriv->pScreenInfo->fMultiWindow
#endif
        ) {
        /* Get the client area coordinates */
        GetClientRect(pScreenPriv->hwndScreen, &rcClient);

        /* Translate the client area coords to screen coords */
        MapWindowPoints(pScreenPriv->hwndScreen,
                        HWND_DESKTOP, (LPPOINT) &rcClient, 2);

        /*
         * Update the Windows cursor position so that we don't
         * immediately warp back to the current position.
         */
        SetCursorPos(rcClient.left + x, rcClient.top + y);
    }

    /* Call the mi warp procedure to do the actual warping in X. */
    miPointerWarpCursor(pDev, pScreen, x, y);
}

static Bool
winCursorOffScreen(ScreenPtr *ppScreen, int *x, int *y)
{
    return FALSE;
}

static void
winCrossScreen(ScreenPtr pScreen, Bool fEntering)
{
}

static unsigned char
reverse(unsigned char c)
{
    int i;
    unsigned char ret = 0;

    for (i = 0; i < 8; ++i) {
        ret |= ((c >> i) & 1) << (7 - i);
    }
    return ret;
}

/*
 * Convert X cursor to Windows cursor
 * FIXME: Perhaps there are more smart code
 */
static HCURSOR
winLoadCursor(ScreenPtr pScreen, CursorPtr pCursor, int screen)
{
    winScreenPriv(pScreen);
    HCURSOR hCursor = NULL;
    unsigned char *pAnd;
    unsigned char *pXor;
    int nCX, nCY;
    int nBytes;
    double dForeY, dBackY;
    BOOL fReverse;
    HBITMAP hAnd, hXor;
    ICONINFO ii;
    unsigned char *pCur;
    unsigned char bit;
    HDC hDC;
    BITMAPV4HEADER bi;
    BITMAPINFO *pbmi;
    uint32_t *lpBits;

    WIN_DEBUG_MSG("winLoadCursor: Win32: %dx%d X11: %dx%d hotspot: %d,%d\n",
                  pScreenPriv->cursor.sm_cx, pScreenPriv->cursor.sm_cy,
                  pCursor->bits->width, pCursor->bits->height,
                  pCursor->bits->xhot, pCursor->bits->yhot);

    /* We can use only White and Black, so calc brightness of color
     * Also check if the cursor is inverted */
    dForeY = BRIGHTNESS(pCursor->fore);
    dBackY = BRIGHTNESS(pCursor->back);
    fReverse = dForeY < dBackY;

    /* Check wether the X11 cursor is bigger than the win32 cursor */
    if (pScreenPriv->cursor.sm_cx < pCursor->bits->width ||
        pScreenPriv->cursor.sm_cy < pCursor->bits->height) {
        winErrorFVerb(3,
                      "winLoadCursor - Windows requires %dx%d cursor but X requires %dx%d\n",
                      pScreenPriv->cursor.sm_cx, pScreenPriv->cursor.sm_cy,
                      pCursor->bits->width, pCursor->bits->height);
    }

    /* Get the number of bytes required to store the whole cursor image
     * This is roughly (sm_cx * sm_cy) / 8
     * round up to 8 pixel boundary so we can convert whole bytes */
    nBytes =
        bits_to_bytes(pScreenPriv->cursor.sm_cx) * pScreenPriv->cursor.sm_cy;

    /* Get the effective width and height */
    nCX = min(pScreenPriv->cursor.sm_cx, pCursor->bits->width);
    nCY = min(pScreenPriv->cursor.sm_cy, pCursor->bits->height);

    /* Allocate memory for the bitmaps */
    pAnd = malloc(nBytes);
    memset(pAnd, 0xFF, nBytes);
    pXor = calloc(1, nBytes);

    /* Convert the X11 bitmap to a win32 bitmap
     * The first is for an empty mask */
    if (pCursor->bits->emptyMask) {
        int x, y, xmax = bits_to_bytes(nCX);

        for (y = 0; y < nCY; ++y)
            for (x = 0; x < xmax; ++x) {
                int nWinPix = bits_to_bytes(pScreenPriv->cursor.sm_cx) * y + x;
                int nXPix = BitmapBytePad(pCursor->bits->width) * y + x;

                pAnd[nWinPix] = 0;
                if (fReverse)
                    pXor[nWinPix] = reverse(~pCursor->bits->source[nXPix]);
                else
                    pXor[nWinPix] = reverse(pCursor->bits->source[nXPix]);
            }
    }
    else {
        int x, y, xmax = bits_to_bytes(nCX);

        for (y = 0; y < nCY; ++y)
            for (x = 0; x < xmax; ++x) {
                int nWinPix = bits_to_bytes(pScreenPriv->cursor.sm_cx) * y + x;
                int nXPix = BitmapBytePad(pCursor->bits->width) * y + x;

                unsigned char mask = pCursor->bits->mask[nXPix];

                pAnd[nWinPix] = reverse(~mask);
                if (fReverse)
                    pXor[nWinPix] =
                        reverse(~pCursor->bits->source[nXPix] & mask);
                else
                    pXor[nWinPix] =
                        reverse(pCursor->bits->source[nXPix] & mask);
            }
    }

    /* prepare the pointers */
    hCursor = NULL;
    lpBits = NULL;

    /* We have a truecolor alpha-blended cursor and can use it! */
    if (pCursor->bits->argb) {
        WIN_DEBUG_MSG("winLoadCursor: Trying truecolor alphablended cursor\n");
        memset(&bi, 0, sizeof(BITMAPV4HEADER));
        bi.bV4Size = sizeof(BITMAPV4HEADER);
        bi.bV4Width = pScreenPriv->cursor.sm_cx;
        bi.bV4Height = -(pScreenPriv->cursor.sm_cy);    /* right-side up */
        bi.bV4Planes = 1;
        bi.bV4BitCount = 32;
        bi.bV4V4Compression = BI_BITFIELDS;
        bi.bV4RedMask = 0x00FF0000;
        bi.bV4GreenMask = 0x0000FF00;
        bi.bV4BlueMask = 0x000000FF;
        bi.bV4AlphaMask = 0xFF000000;

        lpBits = calloc(pScreenPriv->cursor.sm_cx * pScreenPriv->cursor.sm_cy,
                        sizeof(uint32_t));

        if (lpBits) {
            int y;
            for (y = 0; y < nCY; y++) {
                void *src, *dst;
                src = &(pCursor->bits->argb[y * pCursor->bits->width]);
                dst = &(lpBits[y * pScreenPriv->cursor.sm_cx]);
                memcpy(dst, src, 4 * nCX);
            }
        }
    }                           /* End if-truecolor-icon */

    if (!lpBits) {
        RGBQUAD *pbmiColors;
        /* Bicolor, use a palettized DIB */
        WIN_DEBUG_MSG("winLoadCursor: Trying two color cursor\n");
        pbmi = (BITMAPINFO *) &bi;
        pbmiColors = &(pbmi->bmiColors[0]);

        memset(pbmi, 0, sizeof(BITMAPINFOHEADER));
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth = pScreenPriv->cursor.sm_cx;
        pbmi->bmiHeader.biHeight = -abs(pScreenPriv->cursor.sm_cy);     /* right-side up */
        pbmi->bmiHeader.biPlanes = 1;
        pbmi->bmiHeader.biBitCount = 8;
        pbmi->bmiHeader.biCompression = BI_RGB;
        pbmi->bmiHeader.biSizeImage = 0;
        pbmi->bmiHeader.biClrUsed = 3;
        pbmi->bmiHeader.biClrImportant = 3;

        pbmiColors[0].rgbRed = 0;  /* Empty */
        pbmiColors[0].rgbGreen = 0;
        pbmiColors[0].rgbBlue = 0;
        pbmiColors[0].rgbReserved = 0;
        pbmiColors[1].rgbRed = pCursor->backRed >> 8;      /* Background */
        pbmiColors[1].rgbGreen = pCursor->backGreen >> 8;
        pbmiColors[1].rgbBlue = pCursor->backBlue >> 8;
        pbmiColors[1].rgbReserved = 0;
        pbmiColors[2].rgbRed = pCursor->foreRed >> 8;      /* Foreground */
        pbmiColors[2].rgbGreen = pCursor->foreGreen >> 8;
        pbmiColors[2].rgbBlue = pCursor->foreBlue >> 8;
        pbmiColors[2].rgbReserved = 0;

        lpBits = calloc(pScreenPriv->cursor.sm_cx * pScreenPriv->cursor.sm_cy, 1);

        pCur = (unsigned char *) lpBits;
        if (lpBits) {
	    int x, y;
            for (y = 0; y < pScreenPriv->cursor.sm_cy; y++) {
                for (x = 0; x < pScreenPriv->cursor.sm_cx; x++) {
                    if (x >= nCX || y >= nCY)   /* Outside of X11 icon bounds */
                        (*pCur++) = 0;
                    else {      /* Within X11 icon bounds */

                        int nWinPix =
                            bits_to_bytes(pScreenPriv->cursor.sm_cx) * y +
                            (x / 8);

                        bit = pAnd[nWinPix];
                        bit = bit & (1 << (7 - (x & 7)));
                        if (!bit) {     /* Within the cursor mask? */
                            int nXPix =
                                BitmapBytePad(pCursor->bits->width) * y +
                                (x / 8);
                            bit =
                                ~reverse(~pCursor->bits->
                                         source[nXPix] & pCursor->bits->
                                         mask[nXPix]);
                            bit = bit & (1 << (7 - (x & 7)));
                            if (bit)    /* Draw foreground */
                                (*pCur++) = 2;
                            else        /* Draw background */
                                (*pCur++) = 1;
                        }
                        else    /* Outside the cursor mask */
                            (*pCur++) = 0;
                    }
                }               /* end for (x) */
            }                   /* end for (y) */
        }                       /* end if (lpbits) */
    }

    /* If one of the previous two methods gave us the bitmap we need, make a cursor */
    if (lpBits) {
        WIN_DEBUG_MSG("winLoadCursor: Creating bitmap cursor: hotspot %d,%d\n",
                      pCursor->bits->xhot, pCursor->bits->yhot);

        hAnd = NULL;
        hXor = NULL;

        hAnd =
            CreateBitmap(pScreenPriv->cursor.sm_cx, pScreenPriv->cursor.sm_cy,
                         1, 1, pAnd);

        hDC = GetDC(NULL);
        if (hDC) {
            hXor =
                CreateCompatibleBitmap(hDC, pScreenPriv->cursor.sm_cx,
                                       pScreenPriv->cursor.sm_cy);
            SetDIBits(hDC, hXor, 0, pScreenPriv->cursor.sm_cy, lpBits,
                      (BITMAPINFO *) &bi, DIB_RGB_COLORS);
            ReleaseDC(NULL, hDC);
        }
        free(lpBits);

        if (hAnd && hXor) {
            ii.fIcon = FALSE;
            ii.xHotspot = pCursor->bits->xhot;
            ii.yHotspot = pCursor->bits->yhot;
            ii.hbmMask = hAnd;
            ii.hbmColor = hXor;
            hCursor = (HCURSOR) CreateIconIndirect(&ii);

            if (hCursor == NULL)
                winW32Error(2, "winLoadCursor - CreateIconIndirect failed:");
            else {
                if (GetIconInfo(hCursor, &ii)) {
                    if (ii.fIcon) {
                        WIN_DEBUG_MSG
                            ("winLoadCursor: CreateIconIndirect returned  no cursor. Trying again.\n");

                        DestroyCursor(hCursor);

                        ii.fIcon = FALSE;
                        ii.xHotspot = pCursor->bits->xhot;
                        ii.yHotspot = pCursor->bits->yhot;
                        hCursor = (HCURSOR) CreateIconIndirect(&ii);

                        if (hCursor == NULL)
                            winW32Error(2,
                                        "winLoadCursor - CreateIconIndirect failed:");
                    }
                    /* GetIconInfo creates new bitmaps. Destroy them again */
                    if (ii.hbmMask)
                        DeleteObject(ii.hbmMask);
                    if (ii.hbmColor)
                        DeleteObject(ii.hbmColor);
                }
            }
        }

        if (hAnd)
            DeleteObject(hAnd);
        if (hXor)
            DeleteObject(hXor);
    }

    if (!hCursor) {
        /* We couldn't make a color cursor for this screen, use
           black and white instead */
        hCursor = CreateCursor(g_hInstance,
                               pCursor->bits->xhot, pCursor->bits->yhot,
                               pScreenPriv->cursor.sm_cx,
                               pScreenPriv->cursor.sm_cy, pAnd, pXor);
        if (hCursor == NULL)
            winW32Error(2, "winLoadCursor - CreateCursor failed:");
    }
    free(pAnd);
    free(pXor);

    return hCursor;
}

/*
===========================================================================

 Pointer sprite functions

===========================================================================
*/

/*
 * winRealizeCursor
 *  Convert the X cursor representation to native format if possible.
 */
static Bool
winRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    if (pCursor == NULL || pCursor->bits == NULL)
        return FALSE;

    /* FIXME: cache ARGB8888 representation? */

    return TRUE;
}

/*
 * winUnrealizeCursor
 *  Free the storage space associated with a realized cursor.
 */
static Bool
winUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    return TRUE;
}

/*
 * winSetCursor
 *  Set the cursor sprite and position.
 */
static void
winSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor, int x,
             int y)
{
    POINT ptCurPos, ptTemp;
    HWND hwnd;
    RECT rcClient;
    BOOL bInhibit;

    winScreenPriv(pScreen);
    WIN_DEBUG_MSG("winSetCursor: cursor=%p\n", pCursor);

    /* Inhibit changing the cursor if the mouse is not in a client area */
    bInhibit = FALSE;
    if (GetCursorPos(&ptCurPos)) {
        hwnd = WindowFromPoint(ptCurPos);
        if (hwnd) {
            if (GetClientRect(hwnd, &rcClient)) {
                ptTemp.x = rcClient.left;
                ptTemp.y = rcClient.top;
                if (ClientToScreen(hwnd, &ptTemp)) {
                    rcClient.left = ptTemp.x;
                    rcClient.top = ptTemp.y;
                    ptTemp.x = rcClient.right;
                    ptTemp.y = rcClient.bottom;
                    if (ClientToScreen(hwnd, &ptTemp)) {
                        rcClient.right = ptTemp.x;
                        rcClient.bottom = ptTemp.y;
                        if (!PtInRect(&rcClient, ptCurPos))
                            bInhibit = TRUE;
                    }
                }
            }
        }
    }

    if (pCursor == NULL) {
        if (pScreenPriv->cursor.visible) {
            if (!bInhibit && g_fSoftwareCursor)
                ShowCursor(FALSE);
            pScreenPriv->cursor.visible = FALSE;
        }
    }
    else {
        if (pScreenPriv->cursor.handle) {
            if (!bInhibit)
                SetCursor(NULL);
            DestroyCursor(pScreenPriv->cursor.handle);
            pScreenPriv->cursor.handle = NULL;
        }
        pScreenPriv->cursor.handle =
            winLoadCursor(pScreen, pCursor, pScreen->myNum);
        WIN_DEBUG_MSG("winSetCursor: handle=%p\n", pScreenPriv->cursor.handle);

        if (!bInhibit)
            SetCursor(pScreenPriv->cursor.handle);

        if (!pScreenPriv->cursor.visible) {
            if (!bInhibit && g_fSoftwareCursor)
                ShowCursor(TRUE);
            pScreenPriv->cursor.visible = TRUE;
        }
    }
}

/*
 * winMoveCursor
 *  Move the cursor. This is a noop for us.
 */
static void
winMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
}

static Bool
winDeviceCursorInitialize(DeviceIntPtr pDev, ScreenPtr pScr)
{
    winScreenPriv(pScr);
    return pScreenPriv->cursor.spriteFuncs->DeviceCursorInitialize(pDev, pScr);
}

static void
winDeviceCursorCleanup(DeviceIntPtr pDev, ScreenPtr pScr)
{
    winScreenPriv(pScr);
    pScreenPriv->cursor.spriteFuncs->DeviceCursorCleanup(pDev, pScr);
}

static miPointerSpriteFuncRec winSpriteFuncsRec = {
    winRealizeCursor,
    winUnrealizeCursor,
    winSetCursor,
    winMoveCursor,
    winDeviceCursorInitialize,
    winDeviceCursorCleanup
};

/*
===========================================================================

 Other screen functions

===========================================================================
*/

/*
 * winCursorQueryBestSize
 *  Handle queries for best cursor size
 */
static void
winCursorQueryBestSize(int class, unsigned short *width,
                       unsigned short *height, ScreenPtr pScreen)
{
    winScreenPriv(pScreen);

    if (class == CursorShape) {
        *width = pScreenPriv->cursor.sm_cx;
        *height = pScreenPriv->cursor.sm_cy;
    }
    else {
        if (pScreenPriv->cursor.QueryBestSize)
            (*pScreenPriv->cursor.QueryBestSize) (class, width, height,
                                                  pScreen);
    }
}

/*
 * winInitCursor
 *  Initialize cursor support
 */
Bool
winInitCursor(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    miPointerScreenPtr pPointPriv;

    /* override some screen procedures */
    pScreenPriv->cursor.QueryBestSize = pScreen->QueryBestSize;
    pScreen->QueryBestSize = winCursorQueryBestSize;

    pPointPriv = (miPointerScreenPtr)
        dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);

    pScreenPriv->cursor.spriteFuncs = pPointPriv->spriteFuncs;
    pPointPriv->spriteFuncs = &winSpriteFuncsRec;

    pScreenPriv->cursor.handle = NULL;
    pScreenPriv->cursor.visible = FALSE;

    pScreenPriv->cursor.sm_cx = GetSystemMetrics(SM_CXCURSOR);
    pScreenPriv->cursor.sm_cy = GetSystemMetrics(SM_CYCURSOR);

    return TRUE;
}
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d109 1
a109 1
        /* 
d172 1
a172 1
    /* We can use only White and Black, so calc brightness of color 
d187 2
a188 2
    /* Get the number of bytes required to store the whole cursor image 
     * This is roughly (sm_cx * sm_cy) / 8 
d202 1
a202 1
    /* Convert the X11 bitmap to a win32 bitmap 
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d258 2
a259 4
        lpBits =
            (uint32_t *) calloc(pScreenPriv->cursor.sm_cx *
                                pScreenPriv->cursor.sm_cy,
                                sizeof(uint32_t));
d303 1
a303 3
        lpBits =
            (uint32_t *) calloc(pScreenPriv->cursor.sm_cx *
                                pScreenPriv->cursor.sm_cy, sizeof(char));
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d165 1
a165 1
    unsigned long *lpBits;
d259 3
a261 3
            (unsigned long *) calloc(pScreenPriv->cursor.sm_cx *
                                     pScreenPriv->cursor.sm_cy,
                                     sizeof(unsigned long));
d266 1
a266 2
                unsigned long *src, *dst;

d275 1
d279 2
d291 13
a303 12
        pbmi->bmiColors[0].rgbRed = 0;  /* Empty */
        pbmi->bmiColors[0].rgbGreen = 0;
        pbmi->bmiColors[0].rgbBlue = 0;
        pbmi->bmiColors[0].rgbReserved = 0;
        pbmi->bmiColors[1].rgbRed = pCursor->backRed >> 8;      /* Background */
        pbmi->bmiColors[1].rgbGreen = pCursor->backGreen >> 8;
        pbmi->bmiColors[1].rgbBlue = pCursor->backBlue >> 8;
        pbmi->bmiColors[1].rgbReserved = 0;
        pbmi->bmiColors[2].rgbRed = pCursor->foreRed >> 8;      /* Foreground */
        pbmi->bmiColors[2].rgbGreen = pCursor->foreGreen >> 8;
        pbmi->bmiColors[2].rgbBlue = pCursor->foreBlue >> 8;
        pbmi->bmiColors[2].rgbReserved = 0;
d306 2
a307 2
            (unsigned long *) calloc(pScreenPriv->cursor.sm_cx *
                                     pScreenPriv->cursor.sm_cy, sizeof(char));
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d107 1
a107 1
                        HWND_DESKTOP, (LPPOINT) & rcClient, 2);
a160 1
    int x, y;
d264 1
d278 1
a278 1
        pbmi = (BITMAPINFO *) & bi;
d308 1
d361 1
a361 1
                      (BITMAPINFO *) & bi, DIB_RGB_COLORS);
@


1.5
log
@Update to xserver 1.11.2
@
text
@d47 1
a47 1
# define WIN_DEBUG_MSG winDebug
d49 1
a49 1
# define WIN_DEBUG_MSG(...)
d57 1
a57 1
winPointerWarpCursor (DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y);
d60 1
a60 1
winCursorOffScreen (ScreenPtr *ppScreen, int *x, int *y);
d63 1
a63 1
winCrossScreen (ScreenPtr pScreen, Bool fEntering);
d65 4
a68 5
miPointerScreenFuncRec g_winPointerCursorFuncs =
{
  winCursorOffScreen,
  winCrossScreen,
  winPointerWarpCursor
a70 1

d72 1
a72 1
winPointerWarpCursor (DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
d74 24
a97 24
  winScreenPriv(pScreen);
  RECT			rcClient;
  static Bool		s_fInitialWarp = TRUE;

  /* Discard first warp call */
  if (s_fInitialWarp)
    {
      /* First warp moves mouse to center of window, just ignore it */

      /* Don't ignore subsequent warps */
      s_fInitialWarp = FALSE;

      winErrorFVerb (2, "winPointerWarpCursor - Discarding first warp: %d %d\n",
	      x, y);
      
      return;
    }

  /*
     Only update the Windows cursor position if root window is active,
     or we are in a rootless mode
  */
  if ((pScreenPriv->hwndScreen == GetForegroundWindow ())
      || pScreenPriv->pScreenInfo->fRootless
d99 1
a99 1
      || pScreenPriv->pScreenInfo->fMultiWindow
d101 13
a113 16
      )
    {
      /* Get the client area coordinates */
      GetClientRect (pScreenPriv->hwndScreen, &rcClient);
      
      /* Translate the client area coords to screen coords */
      MapWindowPoints (pScreenPriv->hwndScreen,
		       HWND_DESKTOP,
		       (LPPOINT)&rcClient,
		       2);
      
      /* 
       * Update the Windows cursor position so that we don't
       * immediately warp back to the current position.
       */
      SetCursorPos (rcClient.left + x, rcClient.top + y);
d116 2
a117 2
  /* Call the mi warp procedure to do the actual warping in X. */
  miPointerWarpCursor (pDev, pScreen, x, y);
d121 1
a121 1
winCursorOffScreen (ScreenPtr *ppScreen, int *x, int *y)
d123 1
a123 1
  return FALSE;
d127 1
a127 1
winCrossScreen (ScreenPtr pScreen, Bool fEntering)
d134 5
a138 5
  int i;
  unsigned char ret = 0;
  for (i = 0; i < 8; ++i)
    {
      ret |= ((c >> i)&1) << (7 - i);
d140 1
a140 1
  return ret;
d148 1
a148 1
winLoadCursor (ScreenPtr pScreen, CursorPtr pCursor, int screen)
d150 266
a415 263
  winScreenPriv(pScreen);
  HCURSOR hCursor = NULL;
  unsigned char *pAnd;
  unsigned char *pXor;
  int nCX, nCY;
  int nBytes;
  double dForeY, dBackY;
  BOOL fReverse;
  HBITMAP hAnd, hXor;
  ICONINFO ii;
  unsigned char *pCur;
  int x, y;
  unsigned char bit;
  HDC hDC;
  BITMAPV4HEADER bi;
  BITMAPINFO *pbmi;
  unsigned long *lpBits;

  WIN_DEBUG_MSG("winLoadCursor: Win32: %dx%d X11: %dx%d hotspot: %d,%d\n", 
          pScreenPriv->cursor.sm_cx, pScreenPriv->cursor.sm_cy,
          pCursor->bits->width, pCursor->bits->height,
          pCursor->bits->xhot, pCursor->bits->yhot
          );

  /* We can use only White and Black, so calc brightness of color 
   * Also check if the cursor is inverted */  
  dForeY = BRIGHTNESS(pCursor->fore);
  dBackY = BRIGHTNESS(pCursor->back);
  fReverse = dForeY < dBackY;
 
  /* Check wether the X11 cursor is bigger than the win32 cursor */
  if (pScreenPriv->cursor.sm_cx < pCursor->bits->width || 
      pScreenPriv->cursor.sm_cy < pCursor->bits->height)
    {
      winErrorFVerb (3, "winLoadCursor - Windows requires %dx%d cursor but X requires %dx%d\n",
	      pScreenPriv->cursor.sm_cx, pScreenPriv->cursor.sm_cy,
	      pCursor->bits->width, pCursor->bits->height);
    }

  /* Get the number of bytes required to store the whole cursor image 
   * This is roughly (sm_cx * sm_cy) / 8 
   * round up to 8 pixel boundary so we can convert whole bytes */
  nBytes = bits_to_bytes(pScreenPriv->cursor.sm_cx) * pScreenPriv->cursor.sm_cy;

  /* Get the effective width and height */
  nCX = min(pScreenPriv->cursor.sm_cx, pCursor->bits->width);
  nCY = min(pScreenPriv->cursor.sm_cy, pCursor->bits->height);

  /* Allocate memory for the bitmaps */
  pAnd = malloc (nBytes);
  memset (pAnd, 0xFF, nBytes);
  pXor = calloc (1, nBytes);

  /* Convert the X11 bitmap to a win32 bitmap 
   * The first is for an empty mask */
  if (pCursor->bits->emptyMask)
    {
      int x, y, xmax = bits_to_bytes(nCX);
      for (y = 0; y < nCY; ++y)
	for (x = 0; x < xmax; ++x)
	  {
	    int nWinPix = bits_to_bytes(pScreenPriv->cursor.sm_cx) * y + x;
	    int nXPix = BitmapBytePad(pCursor->bits->width) * y + x;

	    pAnd[nWinPix] = 0;
	    if (fReverse)
	      pXor[nWinPix] = reverse (~pCursor->bits->source[nXPix]);
	    else
	      pXor[nWinPix] = reverse (pCursor->bits->source[nXPix]);
	  }
    }
  else
    {
      int x, y, xmax = bits_to_bytes(nCX);
      for (y = 0; y < nCY; ++y)
	for (x = 0; x < xmax; ++x)
	  {
	    int nWinPix = bits_to_bytes(pScreenPriv->cursor.sm_cx) * y + x;
	    int nXPix = BitmapBytePad(pCursor->bits->width) * y + x;

	    unsigned char mask = pCursor->bits->mask[nXPix];
	    pAnd[nWinPix] = reverse (~mask);
	    if (fReverse)
	      pXor[nWinPix] = reverse (~pCursor->bits->source[nXPix] & mask);
	    else
	      pXor[nWinPix] = reverse (pCursor->bits->source[nXPix] & mask);
	  }
    }

  /* prepare the pointers */ 
  hCursor = NULL;
  lpBits = NULL;

  /* We have a truecolor alpha-blended cursor and can use it! */
  if (pCursor->bits->argb) 
    {
      WIN_DEBUG_MSG("winLoadCursor: Trying truecolor alphablended cursor\n"); 
      memset (&bi, 0, sizeof (BITMAPV4HEADER));
      bi.bV4Size = sizeof(BITMAPV4HEADER);
      bi.bV4Width = pScreenPriv->cursor.sm_cx;
      bi.bV4Height = -(pScreenPriv->cursor.sm_cy); /* right-side up */
      bi.bV4Planes = 1;
      bi.bV4BitCount = 32;
      bi.bV4V4Compression = BI_BITFIELDS;
      bi.bV4RedMask = 0x00FF0000;
      bi.bV4GreenMask = 0x0000FF00;
      bi.bV4BlueMask = 0x000000FF;
      bi.bV4AlphaMask = 0xFF000000; 
      
      lpBits = (unsigned long *) calloc (pScreenPriv->cursor.sm_cx*pScreenPriv->cursor.sm_cy,
					 sizeof (unsigned long));
      
      if (lpBits)
	{
	  for (y=0; y<nCY; y++)
	    {
	      unsigned long *src, *dst;
	      src = &(pCursor->bits->argb[y * pCursor->bits->width]);
	      dst = &(lpBits[y * pScreenPriv->cursor.sm_cx]);
	      memcpy (dst, src, 4*nCX);
	    }
	}
    } /* End if-truecolor-icon */
  
  if (!lpBits)
    {
      /* Bicolor, use a palettized DIB */
      WIN_DEBUG_MSG("winLoadCursor: Trying two color cursor\n"); 
      pbmi = (BITMAPINFO*)&bi;
      memset (pbmi, 0, sizeof (BITMAPINFOHEADER));
      pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
      pbmi->bmiHeader.biWidth = pScreenPriv->cursor.sm_cx;
      pbmi->bmiHeader.biHeight = -abs(pScreenPriv->cursor.sm_cy); /* right-side up */
      pbmi->bmiHeader.biPlanes = 1;
      pbmi->bmiHeader.biBitCount = 8;
      pbmi->bmiHeader.biCompression = BI_RGB;
      pbmi->bmiHeader.biSizeImage = 0;
      pbmi->bmiHeader.biClrUsed = 3;
      pbmi->bmiHeader.biClrImportant = 3;
      pbmi->bmiColors[0].rgbRed = 0; /* Empty */
      pbmi->bmiColors[0].rgbGreen = 0;
      pbmi->bmiColors[0].rgbBlue = 0;
      pbmi->bmiColors[0].rgbReserved = 0;
      pbmi->bmiColors[1].rgbRed = pCursor->backRed>>8; /* Background */
      pbmi->bmiColors[1].rgbGreen = pCursor->backGreen>>8;
      pbmi->bmiColors[1].rgbBlue = pCursor->backBlue>>8;
      pbmi->bmiColors[1].rgbReserved = 0;
      pbmi->bmiColors[2].rgbRed = pCursor->foreRed>>8; /* Foreground */
      pbmi->bmiColors[2].rgbGreen = pCursor->foreGreen>>8;
      pbmi->bmiColors[2].rgbBlue = pCursor->foreBlue>>8;
      pbmi->bmiColors[2].rgbReserved = 0;
      
      lpBits = (unsigned long *) calloc (pScreenPriv->cursor.sm_cx*pScreenPriv->cursor.sm_cy,
					 sizeof (char));
      
      pCur = (unsigned char *)lpBits;
      if (lpBits)
	{
	  for (y=0; y<pScreenPriv->cursor.sm_cy; y++)
	    {
	      for (x=0; x<pScreenPriv->cursor.sm_cx; x++)
		{
		  if (x>=nCX || y>=nCY) /* Outside of X11 icon bounds */
		    (*pCur++) = 0;
		  else /* Within X11 icon bounds */
		    {
		      int nWinPix = bits_to_bytes(pScreenPriv->cursor.sm_cx) * y + (x/8);

		      bit = pAnd[nWinPix];
		      bit = bit & (1<<(7-(x&7)));
		      if (!bit) /* Within the cursor mask? */
			{
			  int nXPix = BitmapBytePad(pCursor->bits->width) * y + (x/8);
			  bit = ~reverse(~pCursor->bits->source[nXPix] & pCursor->bits->mask[nXPix]);
			  bit = bit & (1<<(7-(x&7)));
			  if (bit) /* Draw foreground */
			    (*pCur++) = 2;
			  else /* Draw background */
			    (*pCur++) = 1;
			}
		      else /* Outside the cursor mask */
			(*pCur++) = 0;
		    }
		} /* end for (x) */
	    } /* end for (y) */
	} /* end if (lpbits) */
    }

  /* If one of the previous two methods gave us the bitmap we need, make a cursor */
  if (lpBits)
    {
      WIN_DEBUG_MSG("winLoadCursor: Creating bitmap cursor: hotspot %d,%d\n",
              pCursor->bits->xhot, pCursor->bits->yhot);

      hAnd = NULL;
      hXor = NULL;

      hAnd = CreateBitmap (pScreenPriv->cursor.sm_cx, pScreenPriv->cursor.sm_cy, 1, 1, pAnd);

      hDC = GetDC (NULL);
      if (hDC)
	{
	  hXor = CreateCompatibleBitmap (hDC, pScreenPriv->cursor.sm_cx, pScreenPriv->cursor.sm_cy);
	  SetDIBits (hDC, hXor, 0, pScreenPriv->cursor.sm_cy, lpBits, (BITMAPINFO*)&bi, DIB_RGB_COLORS);
	  ReleaseDC (NULL, hDC);
	}
      free (lpBits);
      
      
      if (hAnd && hXor)
	{
	  ii.fIcon = FALSE;
	  ii.xHotspot = pCursor->bits->xhot;
	  ii.yHotspot = pCursor->bits->yhot;
	  ii.hbmMask = hAnd;
	  ii.hbmColor = hXor;
	  hCursor = (HCURSOR) CreateIconIndirect( &ii );

	  if (hCursor == NULL)
	    winW32Error(2, "winLoadCursor - CreateIconIndirect failed:");
	  else 
	    {
	      if (GetIconInfo(hCursor, &ii))
		{
		  if (ii.fIcon)
		    {
		      WIN_DEBUG_MSG("winLoadCursor: CreateIconIndirect returned  no cursor. Trying again.\n");
		      
		      DestroyCursor(hCursor);
		      
		      ii.fIcon = FALSE;
		      ii.xHotspot = pCursor->bits->xhot;
		      ii.yHotspot = pCursor->bits->yhot;
		      hCursor = (HCURSOR) CreateIconIndirect( &ii );
		      
		      if (hCursor == NULL)
			winW32Error(2, "winLoadCursor - CreateIconIndirect failed:");
		    }
		  /* GetIconInfo creates new bitmaps. Destroy them again */
		  if (ii.hbmMask)
     	            DeleteObject(ii.hbmMask);
		  if (ii.hbmColor)
		    DeleteObject(ii.hbmColor);
		}
	    }
	}

      if (hAnd)
	DeleteObject (hAnd);
      if (hXor)
	DeleteObject (hXor);
    }

  if (!hCursor)
    {
      /* We couldn't make a color cursor for this screen, use
	 black and white instead */
      hCursor = CreateCursor (g_hInstance,
			      pCursor->bits->xhot, pCursor->bits->yhot,
			      pScreenPriv->cursor.sm_cx, pScreenPriv->cursor.sm_cy,
			      pAnd, pXor);
      if (hCursor == NULL)
	winW32Error(2, "winLoadCursor - CreateCursor failed:");
d417 2
a418 2
  free (pAnd);
  free (pXor);
d420 1
a420 1
  return hCursor;
d436 1
a436 1
winRealizeCursor (DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
d438 4
a441 4
  if(pCursor == NULL || pCursor->bits == NULL)
    return FALSE;
  
  /* FIXME: cache ARGB8888 representation? */
d443 1
a443 1
  return TRUE;
a445 1

d453 1
a453 1
  return TRUE;
a455 1

d461 2
a462 1
winSetCursor (DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor, int x, int y)
d464 58
a521 67
  POINT ptCurPos, ptTemp;
  HWND  hwnd;
  RECT  rcClient;
  BOOL  bInhibit;
  winScreenPriv(pScreen);
  WIN_DEBUG_MSG("winSetCursor: cursor=%p\n", pCursor); 
  
  /* Inhibit changing the cursor if the mouse is not in a client area */
  bInhibit = FALSE;
  if (GetCursorPos (&ptCurPos))
    {
      hwnd = WindowFromPoint (ptCurPos);
      if (hwnd)
	{
	  if (GetClientRect (hwnd, &rcClient))
	    {
	      ptTemp.x = rcClient.left;
	      ptTemp.y = rcClient.top;
	      if (ClientToScreen (hwnd, &ptTemp))
		{
		  rcClient.left = ptTemp.x;
		  rcClient.top = ptTemp.y;
		  ptTemp.x = rcClient.right;
		  ptTemp.y = rcClient.bottom;
		  if (ClientToScreen (hwnd, &ptTemp))
		    {
		      rcClient.right = ptTemp.x;
		      rcClient.bottom = ptTemp.y;
		      if (!PtInRect (&rcClient, ptCurPos))
			bInhibit = TRUE;
		    }
		}
	    }
	}
    }

  if (pCursor == NULL)
    {
      if (pScreenPriv->cursor.visible)
	{
	  if (!bInhibit && g_fSoftwareCursor)
	    ShowCursor (FALSE);
	  pScreenPriv->cursor.visible = FALSE;
	}
    }
  else
    {
      if (pScreenPriv->cursor.handle)
	{
	  if (!bInhibit)
	    SetCursor (NULL);
	  DestroyCursor (pScreenPriv->cursor.handle);
	  pScreenPriv->cursor.handle = NULL;
	}
      pScreenPriv->cursor.handle =
	winLoadCursor (pScreen, pCursor, pScreen->myNum);
      WIN_DEBUG_MSG("winSetCursor: handle=%p\n", pScreenPriv->cursor.handle); 

      if (!bInhibit)
	SetCursor (pScreenPriv->cursor.handle);

      if (!pScreenPriv->cursor.visible)
	{
	  if (!bInhibit && g_fSoftwareCursor)
	    ShowCursor (TRUE);
	  pScreenPriv->cursor.visible = TRUE;
	}
a524 1

d530 1
a530 1
winMoveCursor (DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
d537 2
a538 2
  winScreenPriv(pScr);
  return pScreenPriv->cursor.spriteFuncs->DeviceCursorInitialize(pDev, pScr);
d544 2
a545 2
  winScreenPriv(pScr);
  pScreenPriv->cursor.spriteFuncs->DeviceCursorCleanup(pDev, pScr);
d549 6
a554 6
  winRealizeCursor,
  winUnrealizeCursor,
  winSetCursor,
  winMoveCursor,
  winDeviceCursorInitialize,
  winDeviceCursorCleanup
a556 1

d570 2
a571 2
winCursorQueryBestSize (int class, unsigned short *width,
				     unsigned short *height, ScreenPtr pScreen)
d573 10
a582 11
  winScreenPriv(pScreen);
  
  if (class == CursorShape)
    {
      *width = pScreenPriv->cursor.sm_cx;
      *height = pScreenPriv->cursor.sm_cy;
    }
  else
    {
      if (pScreenPriv->cursor.QueryBestSize)
        (*pScreenPriv->cursor.QueryBestSize)(class, width, height, pScreen);
d591 1
a591 1
winInitCursor (ScreenPtr pScreen)
d593 18
a610 17
  winScreenPriv(pScreen);
  miPointerScreenPtr pPointPriv;
  /* override some screen procedures */
  pScreenPriv->cursor.QueryBestSize = pScreen->QueryBestSize;
  pScreen->QueryBestSize = winCursorQueryBestSize;
  
  pPointPriv = (miPointerScreenPtr)
      dixLookupPrivate(&pScreen->devPrivates, miPointerScreenKey);
  
  pScreenPriv->cursor.spriteFuncs = pPointPriv->spriteFuncs;
  pPointPriv->spriteFuncs = &winSpriteFuncsRec;

  pScreenPriv->cursor.handle = NULL;
  pScreenPriv->cursor.visible = FALSE;
  
  pScreenPriv->cursor.sm_cx = GetSystemMetrics (SM_CXCURSOR);
  pScreenPriv->cursor.sm_cy = GetSystemMetrics (SM_CYCURSOR);
d612 1
a612 1
  return TRUE;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a43 2
extern Bool	g_fSoftwareCursor;

d558 1
a558 1
  return pScreenPriv->cursor.spriteFuncs->DeviceCursorCleanup(pDev, pScr);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d42 1
a45 7

#ifndef MIN
#define MIN(x,y) ((x)<(y)?(x):(y))
#endif

#define BYTE_COUNT(x) (((x) + 7) / 8)

d59 1
a59 1
winPointerWarpCursor (ScreenPtr pScreen, int x, int y);
d76 1
a76 1
winPointerWarpCursor (ScreenPtr pScreen, int x, int y)
d96 10
a105 2
  /* Only update the Windows cursor position if we are active */
  if (pScreenPriv->hwndScreen == GetForegroundWindow ())
d124 1
a124 1
  miPointerWarpCursor (pScreen, x, y);
d191 1
a191 2
      winErrorFVerb (2, "winLoadCursor - Windows requires %dx%d cursor\n"
	      "\tbut X requires %dx%d\n",
d199 1
a199 1
  nBytes = BYTE_COUNT(pScreenPriv->cursor.sm_cx) * pScreenPriv->cursor.sm_cy;
d202 2
a203 2
  nCX = MIN(pScreenPriv->cursor.sm_cx, pCursor->bits->width);
  nCY = MIN(pScreenPriv->cursor.sm_cy, pCursor->bits->height);
d214 1
a214 1
      int x, y, xmax = BYTE_COUNT(nCX);
d218 1
a218 1
	    int nWinPix = BYTE_COUNT(pScreenPriv->cursor.sm_cx) * y + x;
d230 1
a230 1
      int x, y, xmax = BYTE_COUNT(nCX);
d234 1
a234 1
	    int nWinPix = BYTE_COUNT(pScreenPriv->cursor.sm_cx) * y + x;
d323 1
a323 1
		      int nWinPix = BYTE_COUNT(pScreenPriv->cursor.sm_cx) * y + (x/8);
d440 1
a440 1
winRealizeCursor (ScreenPtr pScreen, CursorPtr pCursor)
d456 1
a456 1
winUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
d467 1
a467 1
winSetCursor (ScreenPtr pScreen, CursorPtr pCursor, int x, int y)
d541 1
a541 1
 * QuartzMoveCursor
d545 6
a550 1
winMoveCursor (ScreenPtr pScreen, int x, int y)
d552 2
d556 6
d567 3
a569 1
  winMoveCursor
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d207 1
a207 2
  pXor = malloc (nBytes);
  memset (pXor, 0x00, nBytes);
@


1.1
log
@Initial revision
@
text
@d601 2
a602 1
  pPointPriv = (miPointerScreenPtr) pScreen->devPrivates[miPointerScreenIndex].ptr;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
