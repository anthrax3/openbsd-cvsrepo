head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.26;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.11.20;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.18.03.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@
/*

Copyright 1993, 1998  The Open Group
Copyright (C) Colin Harrison 2005-2008

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include "winmsg.h"
#include "winconfig.h"
#include "winprefs.h"
#ifdef XWIN_CLIPBOARD
#include "X11/Xlocale.h"
#endif
#ifdef DPMSExtension
#include "dpmsproc.h"
#endif
#ifdef __CYGWIN__
#include <mntent.h>
#endif
#if defined(WIN32)
#include "xkbsrv.h"
#endif
#ifdef RELOCATE_PROJECTROOT
#pragma push_macro("Status")
#undef Status
#define Status wStatus
#include <shlobj.h>
#pragma pop_macro("Status")
typedef WINAPI HRESULT(*SHGETFOLDERPATHPROC) (HWND hwndOwner,
                                              int nFolder,
                                              HANDLE hToken,
                                              DWORD dwFlags, LPTSTR pszPath);
#endif

#include "winmonitors.h"
#include "nonsdk_extinit.h"
#include "pseudoramiX/pseudoramiX.h"

#include "glx_extinit.h"
#ifdef XWIN_GLX_WINDOWS
#include "glx/glwindows.h"
#endif

/*
 * References to external symbols
 */

/*
 * Function prototypes
 */

static Bool
 winCheckDisplayNumber(void);

void
 winLogCommandLine(int argc, char *argv[]);

void
 winLogVersionInfo(void);

Bool
 winValidateArgs(void);

#ifdef RELOCATE_PROJECTROOT
const char *winGetBaseDir(void);
#endif

/*
 * For the depth 24 pixmap we default to 32 bits per pixel, but
 * we change this pixmap format later if we detect that the display
 * is going to be running at 24 bits per pixel.
 *
 * FIXME: On second thought, don't DIBs only support 32 bits per pixel?
 * DIBs are the underlying bitmap used for DirectDraw surfaces, so it
 * seems that all pixmap formats with depth 24 would be 32 bits per pixel.
 * Confirm whether depth 24 DIBs can have 24 bits per pixel, then remove/keep
 * the bits per pixel adjustment and update this comment to reflect the
 * situation.  Harold Hunt - 2002/07/02
 */

static PixmapFormatRec g_PixmapFormats[] = {
    {1, 1, BITMAP_SCANLINE_PAD},
    {4, 8, BITMAP_SCANLINE_PAD},
    {8, 8, BITMAP_SCANLINE_PAD},
    {15, 16, BITMAP_SCANLINE_PAD},
    {16, 16, BITMAP_SCANLINE_PAD},
    {24, 32, BITMAP_SCANLINE_PAD},
    {32, 32, BITMAP_SCANLINE_PAD}
};

const int NUMFORMATS = sizeof(g_PixmapFormats) / sizeof(g_PixmapFormats[0]);

static const ExtensionModule xwinExtensions[] = {
#ifdef GLXEXT
  { GlxExtensionInit, "GLX", &noGlxExtension },
#endif
};

/*
 * XwinExtensionInit
 * Initialises Xwin-specific extensions.
 */
static
void XwinExtensionInit(void)
{
#ifdef XWIN_GLX_WINDOWS
    if (g_fNativeGl) {
        /* install the native GL provider */
        glxWinPushNativeProvider();
    }
#endif

    LoadExtensionList(xwinExtensions, ARRAY_SIZE(xwinExtensions), TRUE);
}

#if defined(DDXBEFORERESET)
/*
 * Called right before KillAllClients when the server is going to reset,
 * allows us to shutdown our seperate threads cleanly.
 */

void
ddxBeforeReset(void)
{
    winDebug("ddxBeforeReset - Hello\n");

#ifdef XWIN_CLIPBOARD
    winClipboardShutdown();
#endif
}
#endif

int
main(int argc, char *argv[], char *envp[])
{
    int iReturn;

    /* Create & acquire the termination mutex */
    iReturn = pthread_mutex_init(&g_pmTerminating, NULL);
    if (iReturn != 0) {
        ErrorF("ddxMain - pthread_mutex_init () failed: %d\n", iReturn);
    }

    iReturn = pthread_mutex_lock(&g_pmTerminating);
    if (iReturn != 0) {
        ErrorF("ddxMain - pthread_mutex_lock () failed: %d\n", iReturn);
    }

    return dix_main(argc, argv, envp);
}

/* See Porting Layer Definition - p. 57 */
void
ddxGiveUp(enum ExitCode error)
{
    int i;

#if CYGDEBUG
    winDebug("ddxGiveUp\n");
#endif

    /* Perform per-screen deinitialization */
    for (i = 0; i < g_iNumScreens; ++i) {
        /* Delete the tray icon */
        if (!g_ScreenInfo[i].fNoTrayIcon && g_ScreenInfo[i].pScreen)
            winDeleteNotifyIcon(winGetScreenPriv(g_ScreenInfo[i].pScreen));
    }

#ifdef XWIN_MULTIWINDOW
    /* Unload libraries for taskbar grouping */
    winPropertyStoreDestroy();

    /* Notify the worker threads we're exiting */
    winDeinitMultiWindowWM();
#endif

#ifdef HAS_DEVWINDOWS
    /* Close our handle to our message queue */
    if (g_fdMessageQueue != WIN_FD_INVALID) {
        /* Close /dev/windows */
        close(g_fdMessageQueue);

        /* Set the file handle to invalid */
        g_fdMessageQueue = WIN_FD_INVALID;
    }
#endif

    if (!g_fLogInited) {
        g_pszLogFile = LogInit(g_pszLogFile, NULL);
        g_fLogInited = TRUE;
    }
    LogClose(error);

    /*
     * At this point we aren't creating any new screens, so
     * we are guaranteed to not need the DirectDraw functions.
     */
    winReleaseDDProcAddresses();

    /* Free concatenated command line */
    free(g_pszCommandLine);
    g_pszCommandLine = NULL;

    /* Remove our keyboard hook if it is installed */
    winRemoveKeyboardHookLL();

    /* Tell Windows that we want to end the app */
    PostQuitMessage(0);

    {
        int iReturn = pthread_mutex_unlock(&g_pmTerminating);

        winDebug("ddxGiveUp - Releasing termination mutex\n");

        if (iReturn != 0) {
            ErrorF("winMsgWindowProc - pthread_mutex_unlock () failed: %d\n",
                   iReturn);
        }
    }

    winDebug("ddxGiveUp - End\n");
}

/* See Porting Layer Definition - p. 57 */
void
AbortDDX(enum ExitCode error)
{
#if CYGDEBUG
    winDebug("AbortDDX\n");
#endif
    ddxGiveUp(error);
}

#ifdef __CYGWIN__
/* hasmntopt is currently not implemented for cygwin */
static const char *
winCheckMntOpt(const struct mntent *mnt, const char *opt)
{
    const char *s;
    size_t len;

    if (mnt == NULL)
        return NULL;
    if (opt == NULL)
        return NULL;
    if (mnt->mnt_opts == NULL)
        return NULL;

    len = strlen(opt);
    s = strstr(mnt->mnt_opts, opt);
    if (s == NULL)
        return NULL;
    if ((s == mnt->mnt_opts || *(s - 1) == ',') &&
        (s[len] == 0 || s[len] == ','))
        return (char *) opt;
    return NULL;
}

static void
winCheckMount(void)
{
    FILE *mnt;
    struct mntent *ent;

    enum { none = 0, sys_root, user_root, sys_tmp, user_tmp }
        level = none, curlevel;
    BOOL binary = TRUE;

    mnt = setmntent("/etc/mtab", "r");
    if (mnt == NULL) {
        ErrorF("setmntent failed");
        return;
    }

    while ((ent = getmntent(mnt)) != NULL) {
        BOOL sys = (winCheckMntOpt(ent, "user") != NULL);
        BOOL root = (strcmp(ent->mnt_dir, "/") == 0);
        BOOL tmp = (strcmp(ent->mnt_dir, "/tmp") == 0);

        if (sys) {
            if (root)
                curlevel = sys_root;
            else if (tmp)
                curlevel = sys_tmp;
            else
                continue;
        }
        else {
            if (root)
                curlevel = user_root;
            else if (tmp)
                curlevel = user_tmp;
            else
                continue;
        }

        if (curlevel <= level)
            continue;
        level = curlevel;

        if ((winCheckMntOpt(ent, "binary") == NULL) &&
            (winCheckMntOpt(ent, "binmode") == NULL))
            binary = FALSE;
        else
            binary = TRUE;
    }

    if (endmntent(mnt) != 1) {
        ErrorF("endmntent failed");
        return;
    }

    if (!binary)
        winMsg(X_WARNING, "/tmp mounted in textmode\n");
}
#else
static void
winCheckMount(void)
{
}
#endif

#ifdef RELOCATE_PROJECTROOT
const char *
winGetBaseDir(void)
{
    static BOOL inited = FALSE;
    static char buffer[MAX_PATH];

    if (!inited) {
        char *fendptr;
        HMODULE module = GetModuleHandle(NULL);
        DWORD size = GetModuleFileName(module, buffer, sizeof(buffer));

        if (sizeof(buffer) > 0)
            buffer[sizeof(buffer) - 1] = 0;

        fendptr = buffer + size;
        while (fendptr > buffer) {
            if (*fendptr == '\\' || *fendptr == '/') {
                *fendptr = 0;
                break;
            }
            fendptr--;
        }
        inited = TRUE;
    }
    return buffer;
}
#endif

static void
winFixupPaths(void)
{
    BOOL changed_fontpath = FALSE;
    MessageType font_from = X_DEFAULT;

#ifdef RELOCATE_PROJECTROOT
    const char *basedir = winGetBaseDir();
    size_t basedirlen = strlen(basedir);
#endif

#ifdef READ_FONTDIRS
    {
        /* Open fontpath configuration file */
        FILE *fontdirs = fopen(ETCX11DIR "/font-dirs", "rt");

        if (fontdirs != NULL) {
            char buffer[256];
            int needs_sep = TRUE;
            int comment_block = FALSE;

            /* get default fontpath */
            char *fontpath = strdup(defaultFontPath);
            size_t size = strlen(fontpath);

            /* read all lines */
            while (!feof(fontdirs)) {
                size_t blen;
                char *hashchar;
                char *str;
                int has_eol = FALSE;

                /* read one line */
                str = fgets(buffer, sizeof(buffer), fontdirs);
                if (str == NULL)        /* stop on error or eof */
                    break;

                if (strchr(str, '\n') != NULL)
                    has_eol = TRUE;

                /* check if block is continued comment */
                if (comment_block) {
                    /* ignore all input */
                    *str = 0;
                    blen = 0;
                    if (has_eol)        /* check if line ended in this block */
                        comment_block = FALSE;
                }
                else {
                    /* find comment character. ignore all trailing input */
                    hashchar = strchr(str, '#');
                    if (hashchar != NULL) {
                        *hashchar = 0;
                        if (!has_eol)   /* mark next block as continued comment */
                            comment_block = TRUE;
                    }
                }

                /* strip whitespaces from beginning */
                while (*str == ' ' || *str == '\t')
                    str++;

                /* get size, strip whitespaces from end */
                blen = strlen(str);
                while (blen > 0 && (str[blen - 1] == ' ' ||
                                    str[blen - 1] == '\t' ||
                                    str[blen - 1] == '\n')) {
                    str[--blen] = 0;
                }

                /* still something left to add? */
                if (blen > 0) {
                    size_t newsize = size + blen;

                    /* reserve one character more for ',' */
                    if (needs_sep)
                        newsize++;

                    /* allocate memory */
                    if (fontpath == NULL)
                        fontpath = malloc(newsize + 1);
                    else
                        fontpath = realloc(fontpath, newsize + 1);

                    /* add separator */
                    if (needs_sep) {
                        fontpath[size] = ',';
                        size++;
                        needs_sep = FALSE;
                    }

                    /* mark next line as new entry */
                    if (has_eol)
                        needs_sep = TRUE;

                    /* add block */
                    strncpy(fontpath + size, str, blen);
                    fontpath[newsize] = 0;
                    size = newsize;
                }
            }

            /* cleanup */
            fclose(fontdirs);
            defaultFontPath = strdup(fontpath);
            free(fontpath);
            changed_fontpath = TRUE;
            font_from = X_CONFIG;
        }
    }
#endif                          /* READ_FONTDIRS */
#ifdef RELOCATE_PROJECTROOT
    {
        const char *libx11dir = PROJECTROOT "/lib/X11";
        size_t libx11dir_len = strlen(libx11dir);
        char *newfp = NULL;
        size_t newfp_len = 0;
        const char *endptr, *ptr, *oldptr = defaultFontPath;

        endptr = oldptr + strlen(oldptr);
        ptr = strchr(oldptr, ',');
        if (ptr == NULL)
            ptr = endptr;
        while (ptr != NULL) {
            size_t oldfp_len = (ptr - oldptr);
            size_t newsize = oldfp_len;
            char *newpath = malloc(newsize + 1);

            strncpy(newpath, oldptr, newsize);
            newpath[newsize] = 0;

            if (strncmp(libx11dir, newpath, libx11dir_len) == 0) {
                char *compose;

                newsize = newsize - libx11dir_len + basedirlen;
                compose = malloc(newsize + 1);
                strcpy(compose, basedir);
                strncat(compose, newpath + libx11dir_len, newsize - basedirlen);
                compose[newsize] = 0;
                free(newpath);
                newpath = compose;
            }

            oldfp_len = newfp_len;
            if (oldfp_len > 0)
                newfp_len++;    /* space for separator */
            newfp_len += newsize;

            if (newfp == NULL)
                newfp = malloc(newfp_len + 1);
            else
                newfp = realloc(newfp, newfp_len + 1);

            if (oldfp_len > 0) {
                strcpy(newfp + oldfp_len, ",");
                oldfp_len++;
            }
            strcpy(newfp + oldfp_len, newpath);

            free(newpath);

            if (*ptr == 0) {
                oldptr = ptr;
                ptr = NULL;
            }
            else {
                oldptr = ptr + 1;
                ptr = strchr(oldptr, ',');
                if (ptr == NULL)
                    ptr = endptr;
            }
        }

        defaultFontPath = strdup(newfp);
        free(newfp);
        changed_fontpath = TRUE;
    }
#endif                          /* RELOCATE_PROJECTROOT */
    if (changed_fontpath)
        winMsg(font_from, "FontPath set to \"%s\"\n", defaultFontPath);

#ifdef RELOCATE_PROJECTROOT
    if (getenv("XKEYSYMDB") == NULL) {
        char buffer[MAX_PATH];

        snprintf(buffer, sizeof(buffer), "XKEYSYMDB=%s\\XKeysymDB", basedir);
        buffer[sizeof(buffer) - 1] = 0;
        putenv(buffer);
    }
    if (getenv("XERRORDB") == NULL) {
        char buffer[MAX_PATH];

        snprintf(buffer, sizeof(buffer), "XERRORDB=%s\\XErrorDB", basedir);
        buffer[sizeof(buffer) - 1] = 0;
        putenv(buffer);
    }
    if (getenv("XLOCALEDIR") == NULL) {
        char buffer[MAX_PATH];

        snprintf(buffer, sizeof(buffer), "XLOCALEDIR=%s\\locale", basedir);
        buffer[sizeof(buffer) - 1] = 0;
        putenv(buffer);
    }
    if (getenv("HOME") == NULL) {
        char buffer[MAX_PATH + 5];

        strncpy(buffer, "HOME=", 5);

        /* query appdata directory */
        if (SHGetFolderPathA
            (NULL, CSIDL_APPDATA | CSIDL_FLAG_CREATE, NULL, 0,
             buffer + 5) == 0) {
            putenv(buffer);
        }
        else {
            winMsg(X_ERROR, "Can not determine HOME directory\n");
        }
    }
    if (!g_fLogFileChanged) {
        static char buffer[MAX_PATH];
        DWORD size = GetTempPath(sizeof(buffer), buffer);

        if (size && size < sizeof(buffer)) {
            snprintf(buffer + size, sizeof(buffer) - size,
                     "XWin.%s.log", display);
            buffer[sizeof(buffer) - 1] = 0;
            g_pszLogFile = buffer;
            winMsg(X_DEFAULT, "Logfile set to \"%s\"\n", g_pszLogFile);
        }
    }
    {
        static char xkbbasedir[MAX_PATH];

        snprintf(xkbbasedir, sizeof(xkbbasedir), "%s\\xkb", basedir);
        if (sizeof(xkbbasedir) > 0)
            xkbbasedir[sizeof(xkbbasedir) - 1] = 0;
        XkbBaseDirectory = xkbbasedir;
        XkbBinDirectory = basedir;
    }
#endif                          /* RELOCATE_PROJECTROOT */
}

void
OsVendorInit(void)
{
    /* Re-initialize global variables on server reset */
    winInitializeGlobals();

    winFixupPaths();

#ifdef DDXOSVERRORF
    if (!OsVendorVErrorFProc)
        OsVendorVErrorFProc = OsVendorVErrorF;
#endif

    if (!g_fLogInited) {
        /* keep this order. If LogInit fails it calls Abort which then calls
         * ddxGiveUp where LogInit is called again and creates an infinite
         * recursion. If we set g_fLogInited to TRUE before the init we
         * avoid the second call
         */
        g_fLogInited = TRUE;
        g_pszLogFile = LogInit(g_pszLogFile, NULL);
    }
    LogSetParameter(XLOG_FLUSH, 1);
    LogSetParameter(XLOG_VERBOSITY, g_iLogVerbose);
    LogSetParameter(XLOG_FILE_VERBOSITY, g_iLogVerbose);

    /* Log the version information */
    if (serverGeneration == 1)
        winLogVersionInfo();

    winCheckMount();

    /* Add a default screen if no screens were specified */
    if (g_iNumScreens == 0) {
        winDebug("OsVendorInit - Creating default screen 0\n");

        /*
         * We need to initialize the default screen 0 if no -screen
         * arguments were processed.
         *
         * Add a screen 0 using the defaults set by winInitializeDefaultScreens()
         * and any additional default screen parameters given
         */
        winInitializeScreens(1);

        /* We have to flag this as an explicit screen, even though it isn't */
        g_ScreenInfo[0].fExplicitScreen = TRUE;
    }

    /* Work out what the default emulate3buttons setting should be, and apply
       it if nothing was explicitly specified */
    {
        int mouseButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);
        int j;

        for (j = 0; j < g_iNumScreens; j++) {
            if (g_ScreenInfo[j].iE3BTimeout == WIN_E3B_DEFAULT) {
                if (mouseButtons < 3) {
                    static Bool reportOnce = TRUE;

                    g_ScreenInfo[j].iE3BTimeout = WIN_DEFAULT_E3B_TIME;
                    if (reportOnce) {
                        reportOnce = FALSE;
                        winMsg(X_PROBED,
                               "Windows reports only %d mouse buttons, defaulting to -emulate3buttons\n",
                               mouseButtons);
                    }
                }
                else {
                    g_ScreenInfo[j].iE3BTimeout = WIN_E3B_OFF;
                }
            }
        }
    }
}

static void
winUseMsg(void)
{
    ErrorF("\n");
    ErrorF("\n");
    ErrorF(EXECUTABLE_NAME " Device Dependent Usage:\n");
    ErrorF("\n");

#ifdef XWIN_CLIPBOARD
    ErrorF("-[no]clipboard\n"
           "\tEnable [disable] the clipboard integration. Default is enabled.\n");
#endif

    ErrorF("-clipupdates num_boxes\n"
           "\tUse a clipping region to constrain shadow update blits to\n"
           "\tthe updated region when num_boxes, or more, are in the\n"
           "\tupdated region.\n");

#ifdef XWIN_XF86CONFIG
    ErrorF("-config\n" "\tSpecify a configuration file.\n");

    ErrorF("-configdir\n" "\tSpecify a configuration directory.\n");
#endif

    ErrorF("-depth bits_per_pixel\n"
           "\tSpecify an optional bitdepth to use in fullscreen mode\n"
           "\twith a DirectDraw engine.\n");

    ErrorF("-[no]emulate3buttons [timeout]\n"
           "\tEmulate 3 button mouse with an optional timeout in\n"
           "\tmilliseconds.\n");

#ifdef XWIN_EMULATEPSEUDO
    ErrorF("-emulatepseudo\n"
           "\tCreate a depth 8 PseudoColor visual when running in\n"
           "\tdepths 15, 16, 24, or 32, collectively known as TrueColor\n"
           "\tdepths.  The PseudoColor visual does not have correct colors,\n"
           "\tand it may crash, but it at least allows you to run your\n"
           "\tapplication in TrueColor modes.\n");
#endif

    ErrorF("-engine engine_type_id\n"
           "\tOverride the server's automatically selected engine type:\n"
           "\t\t1 - Shadow GDI\n"
           "\t\t4 - Shadow DirectDraw4 Non-Locking\n"
        );

    ErrorF("-fullscreen\n" "\tRun the server in fullscreen mode.\n");

    ErrorF("-[no]hostintitle\n"
           "\tIn multiwindow mode, add remote host names to window titles.\n");

    ErrorF("-ignoreinput\n" "\tIgnore keyboard and mouse input.\n");

#ifdef XWIN_MULTIWINDOWEXTWM
    ErrorF("-internalwm\n" "\tRun the internal window manager.\n");
#endif

#ifdef XWIN_XF86CONFIG
    ErrorF("-keyboard\n"
           "\tSpecify a keyboard device from the configuration file.\n");
#endif

    ErrorF("-[no]keyhook\n"
           "\tGrab special Windows keypresses like Alt-Tab or the Menu "
           "key.\n");

    ErrorF("-lesspointer\n"
           "\tHide the windows mouse pointer when it is over any\n"
           "\t" EXECUTABLE_NAME
           " window.  This prevents ghost cursors appearing when\n"
           "\tthe Windows cursor is drawn on top of the X cursor\n");

    ErrorF("-logfile filename\n" "\tWrite log messages to <filename>.\n");

    ErrorF("-logverbose verbosity\n"
           "\tSet the verbosity of log messages. [NOTE: Only a few messages\n"
           "\trespect the settings yet]\n"
           "\t\t0 - only print fatal error.\n"
           "\t\t1 - print additional configuration information.\n"
           "\t\t2 - print additional runtime information [default].\n"
           "\t\t3 - print debugging and tracing information.\n");

    ErrorF("-[no]multimonitors or -[no]multiplemonitors\n"
           "\tUse the entire virtual screen if multiple\n"
           "\tmonitors are present.\n");

#ifdef XWIN_MULTIWINDOW
    ErrorF("-multiwindow\n" "\tRun the server in multi-window mode.\n");
#endif

#ifdef XWIN_MULTIWINDOWEXTWM
    ErrorF("-mwextwm\n"
           "\tRun the server in multi-window external window manager mode.\n");
#endif

    ErrorF("-nodecoration\n"
           "\tDo not draw a window border, title bar, etc.  Windowed\n"
           "\tmode only.\n");

#ifdef XWIN_CLIPBOARD
    ErrorF("-nounicodeclipboard\n"
           "\tDo not use Unicode clipboard even if on a NT-based platform.\n");

    ErrorF("-[no]primary\n"
           "\tWhen clipboard integration is enabled, map the X11 PRIMARY selection\n"
           "\tto the Windows clipboard. Default is enabled.\n");
#endif

    ErrorF("-refresh rate_in_Hz\n"
           "\tSpecify an optional refresh rate to use in fullscreen mode\n"
           "\twith a DirectDraw engine.\n");

    ErrorF("-resize=none|scrollbars|randr"
           "\tIn windowed mode, [don't] allow resizing of the window. 'scrollbars'\n"
           "\tmode gives the window scrollbars as needed, 'randr' mode uses the RANR\n"
           "\textension to resize the X screen.  'randr' is the default.\n");

    ErrorF("-rootless\n" "\tRun the server in rootless mode.\n");

    ErrorF("-screen scr_num [width height [x y] | [[WxH[+X+Y]][@@m]] ]\n"
           "\tEnable screen scr_num and optionally specify a width and\n"
           "\theight and initial position for that screen. Additionally\n"
           "\ta monitor number can be specified to start the server on,\n"
           "\tat which point, all coordinates become relative to that\n"
           "\tmonitor. Examples:\n"
           "\t -screen 0 800x600+100+100@@2 ; 2nd monitor offset 100,100 size 800x600\n"
           "\t -screen 0 1024x768@@3        ; 3rd monitor size 1024x768\n"
           "\t -screen 0 @@1 ; on 1st monitor using its full resolution (the default)\n");

    ErrorF("-silent-dup-error\n"
           "\tIf another instance of " EXECUTABLE_NAME
           " with the same display number is running\n"
           "\texit silently and don't display any error message.\n");

    ErrorF("-swcursor\n"
           "\tDisable the usage of the Windows cursor and use the X11 software\n"
           "\tcursor instead.\n");

    ErrorF("-[no]trayicon\n"
           "\tDo not create a tray icon.  Default is to create one\n"
           "\ticon per screen.  You can globally disable tray icons with\n"
           "\t-notrayicon, then enable it for specific screens with\n"
           "\t-trayicon for those screens.\n");

    ErrorF("-[no]unixkill\n" "\tCtrl+Alt+Backspace exits the X Server.\n");

#ifdef XWIN_GLX_WINDOWS
    ErrorF("-[no]wgl\n"
           "\tEnable the GLX extension to use the native Windows WGL interface for hardware-accelerated OpenGL\n");
#endif

    ErrorF("-[no]winkill\n" "\tAlt+F4 exits the X Server.\n");

    ErrorF("-xkblayout XKBLayout\n"
           "\tEquivalent to XKBLayout in XF86Config files.\n"
           "\tFor example: -xkblayout de\n");

    ErrorF("-xkbmodel XKBModel\n"
           "\tEquivalent to XKBModel in XF86Config files.\n");

    ErrorF("-xkboptions XKBOptions\n"
           "\tEquivalent to XKBOptions in XF86Config files.\n");

    ErrorF("-xkbrules XKBRules\n"
           "\tEquivalent to XKBRules in XF86Config files.\n");

    ErrorF("-xkbvariant XKBVariant\n"
           "\tEquivalent to XKBVariant in XF86Config files.\n"
           "\tFor example: -xkbvariant nodeadkeys\n");
}

/* See Porting Layer Definition - p. 57 */
void
ddxUseMsg(void)
{
    /* Set a flag so that FatalError won't give duplicate warning message */
    g_fSilentFatalError = TRUE;

    winUseMsg();

    /* Log file will not be opened for UseMsg unless we open it now */
    if (!g_fLogInited) {
        g_pszLogFile = LogInit(g_pszLogFile, NULL);
        g_fLogInited = TRUE;
    }
    LogClose(EXIT_NO_ERROR);

    /* Notify user where UseMsg text can be found. */
    if (!g_fNoHelpMessageBox)
        winMessageBoxF("The " PROJECT_NAME " help text has been printed to "
                       "%s.\n"
                       "Please open %s to read the help text.\n",
                       MB_ICONINFORMATION, g_pszLogFile, g_pszLogFile);
}

/* See Porting Layer Definition - p. 20 */
/*
 * Do any global initialization, then initialize each screen.
 *
 * NOTE: We use ddxProcessArgument, so we don't need to touch argc and argv
 */

void
InitOutput(ScreenInfo * pScreenInfo, int argc, char *argv[])
{
    int i;

    if (serverGeneration == 1)
        XwinExtensionInit();

    /* Log the command line */
    winLogCommandLine(argc, argv);

#if CYGDEBUG
    winDebug("InitOutput\n");
#endif

    /* Validate command-line arguments */
    if (serverGeneration == 1 && !winValidateArgs()) {
        FatalError("InitOutput - Invalid command-line arguments found.  "
                   "Exiting.\n");
    }

    /* Check for duplicate invocation on same display number. */
    if (serverGeneration == 1 && !winCheckDisplayNumber()) {
        if (g_fSilentDupError)
            g_fSilentFatalError = TRUE;
        FatalError("InitOutput - Duplicate invocation on display "
                   "number: %s.  Exiting.\n", display);
    }

#ifdef XWIN_XF86CONFIG
    /* Try to read the xorg.conf-style configuration file */
    if (!winReadConfigfile())
        winErrorFVerb(1, "InitOutput - Error reading config file\n");
#else
    winMsg(X_INFO, "xorg.conf is not supported\n");
    winMsg(X_INFO, "See http://x.cygwin.com/docs/faq/cygwin-x-faq.html "
           "for more information\n");
    winConfigFiles();
#endif

    /* Load preferences from XWinrc file */
    LoadPreferences();

    /* Setup global screen info parameters */
    pScreenInfo->imageByteOrder = IMAGE_BYTE_ORDER;
    pScreenInfo->bitmapScanlinePad = BITMAP_SCANLINE_PAD;
    pScreenInfo->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
    pScreenInfo->bitmapBitOrder = BITMAP_BIT_ORDER;
    pScreenInfo->numPixmapFormats = NUMFORMATS;

    /* Describe how we want common pixmap formats padded */
    for (i = 0; i < NUMFORMATS; i++) {
        pScreenInfo->formats[i] = g_PixmapFormats[i];
    }

    /* Load pointers to DirectDraw functions */
    winGetDDProcAddresses();

    /* Detect supported engines */
    winDetectSupportedEngines();
#ifdef XWIN_MULTIWINDOW
    /* Load libraries for taskbar grouping */
    winPropertyStoreInit();
#endif

    /* Store the instance handle */
    g_hInstance = GetModuleHandle(NULL);

    /* Create the messaging window */
    if (serverGeneration == 1)
        winCreateMsgWindowThread();

    /* Initialize each screen */
    for (i = 0; i < g_iNumScreens; ++i) {
        /* Initialize the screen */
        if (-1 == AddScreen(winScreenInit, argc, argv)) {
            FatalError("InitOutput - Couldn't add screen %d", i);
        }
    }

  /*
     Unless full xinerama has been explicitly enabled, register all native screens with pseudoramiX
  */
  if (!noPanoramiXExtension)
      noPseudoramiXExtension = TRUE;

  if ((g_ScreenInfo[0].fMultipleMonitors) && !noPseudoramiXExtension)
    {
      int pass;

      PseudoramiXExtensionInit();

      /* Add primary monitor on pass 0, other monitors on pass 1, to ensure
       the primary monitor is first in XINERAMA list */
      for (pass = 0; pass < 2; pass++)
        {
          int iMonitor;

          for (iMonitor = 1; ; iMonitor++)
            {
              struct GetMonitorInfoData data;
              QueryMonitor(iMonitor, &data);
              if (data.bMonitorSpecifiedExists)
                {
                  MONITORINFO mi;
                  mi.cbSize = sizeof(MONITORINFO);

                  if (GetMonitorInfo(data.monitorHandle, &mi))
                    {
                      /* pass == 1 XOR primary monitor flags is set */
                      if ((!(pass == 1)) != (!(mi.dwFlags & MONITORINFOF_PRIMARY)))
                        {
                          /*
                            Note the screen origin in a normalized coordinate space where (0,0) is at the top left
                            of the native virtual desktop area
                          */
                          data.monitorOffsetX = data.monitorOffsetX - GetSystemMetrics(SM_XVIRTUALSCREEN);
                          data.monitorOffsetY = data.monitorOffsetY - GetSystemMetrics(SM_YVIRTUALSCREEN);

                          winDebug ("InitOutput - screen %d added at virtual desktop coordinate (%d,%d) (pseudoramiX) \n",
                                    iMonitor-1, data.monitorOffsetX, data.monitorOffsetY);

                          PseudoramiXAddScreen(data.monitorOffsetX, data.monitorOffsetY,
                                               data.monitorWidth, data.monitorHeight);
                        }
                    }
                }
              else
                break;
            }
        }
    }

#if defined(XWIN_CLIPBOARD) || defined(XWIN_MULTIWINDOW)

    /* Generate a cookie used by internal clients for authorization */
    if (g_fXdmcpEnabled || g_fAuthEnabled)
        winGenerateAuthorization();

    /* Perform some one time initialization */
    if (1 == serverGeneration) {
        /*
         * setlocale applies to all threads in the current process.
         * Apply locale specified in LANG environment variable.
         */
        setlocale(LC_ALL, "");
    }
#endif

#if CYGDEBUG || YES
    winDebug("InitOutput - Returning.\n");
#endif
}

/*
 * winCheckDisplayNumber - Check if another instance of Cygwin/X is
 * already running on the same display number.  If no one exists,
 * make a mutex to prevent new instances from running on the same display.
 *
 * return FALSE if the display number is already used.
 */

static Bool
winCheckDisplayNumber(void)
{
    int nDisp;
    HANDLE mutex;
    char name[MAX_PATH];
    const char *pszPrefix = '\0';
    OSVERSIONINFO osvi = { 0 };

    /* Check display range */
    nDisp = atoi(display);
    if (nDisp < 0 || nDisp > 65535) {
        ErrorF("winCheckDisplayNumber - Bad display number: %d\n", nDisp);
        return FALSE;
    }

    /* Set first character of mutex name to null */
    name[0] = '\0';

    /* Get operating system version information */
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    /* Want a mutex shared among all terminals on NT > 4.0 */
    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT && osvi.dwMajorVersion >= 5) {
        pszPrefix = "Global\\";
    }

    /* Setup Cygwin/X specific part of name */
    snprintf(name, sizeof(name), "%sCYGWINX_DISPLAY:%d", pszPrefix, nDisp);

    /* Windows automatically releases the mutex when this process exits */
    mutex = CreateMutex(NULL, FALSE, name);
    if (!mutex) {
        LPVOID lpMsgBuf;

        /* Display a fancy error message */
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_SYSTEM |
                      FORMAT_MESSAGE_IGNORE_INSERTS,
                      NULL,
                      GetLastError(),
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPTSTR) &lpMsgBuf, 0, NULL);
        ErrorF("winCheckDisplayNumber - CreateMutex failed: %s\n",
               (LPSTR) lpMsgBuf);
        LocalFree(lpMsgBuf);

        return FALSE;
    }
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        ErrorF("winCheckDisplayNumber - "
               PROJECT_NAME " is already running on display %d\n", nDisp);
        return FALSE;
    }

    return TRUE;
}
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d61 5
a740 1
           "\t\t2 - Shadow DirectDraw\n"
d746 1
a746 1
    ErrorF("-hostintitle\n"
d977 53
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a68 8
#ifdef XWIN_CLIPBOARD
extern Bool g_fUnicodeClipboard;
extern Bool g_fClipboardLaunched;
extern Bool g_fClipboardStarted;
extern pthread_t g_ptClipboardProc;
extern HWND g_hwndClipboard;
extern Bool g_fClipboard;
#endif
a73 5
#ifdef XWIN_CLIPBOARD
static void
 winClipboardShutdown(void);
#endif

a114 25
#ifdef XWIN_CLIPBOARD
static void
winClipboardShutdown(void)
{
    /* Close down clipboard resources */
    if (g_fClipboard && g_fClipboardLaunched && g_fClipboardStarted) {
        /* Synchronously destroy the clipboard window */
        if (g_hwndClipboard != NULL) {
            SendMessage(g_hwndClipboard, WM_DESTROY, 0, 0);
            /* NOTE: g_hwndClipboard is set to NULL in winclipboardthread.c */
        }
        else
            return;

        /* Wait for the clipboard thread to exit */
        pthread_join(g_ptClipboardProc, NULL);

        g_fClipboardLaunched = FALSE;
        g_fClipboardStarted = FALSE;

        winDebug("winClipboardShutdown - Clipboard thread has exited.\n");
    }
}
#endif

d631 3
a633 3
         * ddxGiveUp where LogInit is called again and creates an infinite 
         * recursion. If we set g_fLogInited to TRUE before the init we 
         * avoid the second call 
a737 6
#ifdef XWIN_PRIMARYFB
           "\t\t8 - Primary DirectDraw - obsolete\n"
#endif
#ifdef XWIN_NATIVEGDI
           "\t\t16 - Native GDI - experimental\n"
#endif
d796 4
d892 1
a892 1
 * 
d1011 1
a1011 1
    char *pszPrefix = '\0';
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d61 4
a65 1
#include "glx_extinit.h"
a165 2
    int i;

d173 1
a173 2
    for (i = 0; i < ARRAY_SIZE(xwinExtensions); i++)
        LoadExtension(&xwinExtensions[i], TRUE);
d271 2
a274 2
        int iReturn = pthread_mutex_unlock(&g_pmTerminating);

d785 3
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d51 3
d55 1
d193 19
d269 13
d1000 4
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d58 1
a79 5
#if defined(DDXOSVERRORF)
void
 OsVendorVErrorF(const char *pszFormat, va_list va_args);
#endif

d146 12
a157 2
void
ddxPushProviders(void)
d159 2
d167 3
d207 3
d300 1
a300 1
        BOOL system = (winCheckMntOpt(ent, "user") != NULL);
d304 1
a304 1
        if (system) {
d810 1
a810 1
           "\textension to resize the X screen.\n");
d843 1
a843 1
           "\tEnable the GLX extension to use the native Windows WGL interface for accelerated OpenGL\n");
d898 1
a898 1
InitOutput(ScreenInfo * screenInfo, int argc, char *argv[])
d902 3
d941 5
a945 5
    screenInfo->imageByteOrder = IMAGE_BYTE_ORDER;
    screenInfo->bitmapScanlinePad = BITMAP_SCANLINE_PAD;
    screenInfo->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
    screenInfo->bitmapBitOrder = BITMAP_BIT_ORDER;
    screenInfo->numPixmapFormats = NUMFORMATS;
d949 1
a949 1
        screenInfo->formats[i] = g_PixmapFormats[i];
d957 4
d1045 1
a1045 1
                      (LPTSTR) & lpMsgBuf, 0, NULL);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d52 4
a55 7
typedef WINAPI HRESULT (*SHGETFOLDERPATHPROC)(
    HWND hwndOwner,
    int nFolder,
    HANDLE hToken,
    DWORD dwFlags,
    LPTSTR pszPath
);
d62 6
a67 6
extern Bool			g_fUnicodeClipboard;
extern Bool			g_fClipboardLaunched;
extern Bool			g_fClipboardStarted;
extern pthread_t		g_ptClipboardProc;
extern HWND			g_hwndClipboard;
extern Bool			g_fClipboard;
a69 6

/*
  module handle for dynamically loaded comctl32 library
*/
static HMODULE g_hmodCommonControls = NULL;

d76 1
a76 1
winClipboardShutdown (void);
d81 1
a81 1
OsVendorVErrorF (const char *pszFormat, va_list va_args);
d85 1
a85 1
winCheckDisplayNumber (void);
d88 1
a88 1
winLogCommandLine (int argc, char *argv[]);
d91 1
a91 1
winLogVersionInfo (void);
d94 1
a94 1
winValidateArgs (void);
d97 1
a97 2
const char *
winGetBaseDir(void);
d114 7
a120 7
  { 1,    1,      BITMAP_SCANLINE_PAD },
  { 4,    8,      BITMAP_SCANLINE_PAD },
  { 8,    8,      BITMAP_SCANLINE_PAD },
  { 15,   16,     BITMAP_SCANLINE_PAD },
  { 16,   16,     BITMAP_SCANLINE_PAD },
  { 24,   32,     BITMAP_SCANLINE_PAD },
  { 32,   32,     BITMAP_SCANLINE_PAD }
d123 1
a123 1
const int NUMFORMATS = sizeof (g_PixmapFormats) / sizeof (g_PixmapFormats[0]);
d127 1
a127 1
winClipboardShutdown (void)
d129 12
a140 14
  /* Close down clipboard resources */
  if (g_fClipboard && g_fClipboardLaunched && g_fClipboardStarted)
    {
      /* Synchronously destroy the clipboard window */
      if (g_hwndClipboard != NULL)
	{
	  SendMessage (g_hwndClipboard, WM_DESTROY, 0, 0);
	  /* NOTE: g_hwndClipboard is set to NULL in winclipboardthread.c */
	}
      else
	return;
      
      /* Wait for the clipboard thread to exit */
      pthread_join (g_ptClipboardProc, NULL);
d142 2
a143 2
      g_fClipboardLaunched = FALSE;
      g_fClipboardStarted = FALSE;
d145 1
a145 1
      winDebug ("winClipboardShutdown - Clipboard thread has exited.\n");
d154 3
a156 4
  if (g_fNativeGl)
    {
      /* install the native GL provider */
      glxWinPushNativeProvider();
d168 1
a168 1
ddxBeforeReset (void)
d170 1
a170 1
  winDebug ("ddxBeforeReset - Hello\n");
d173 1
a173 1
  winClipboardShutdown ();
a177 1

d180 1
a180 1
ddxGiveUp (enum ExitCode error)
d182 1
a182 1
  int		i;
d185 1
a185 1
  winDebug ("ddxGiveUp\n");
d188 5
a192 6
  /* Perform per-screen deinitialization */
  for (i = 0; i < g_iNumScreens; ++i)
    {
      /* Delete the tray icon */
      if (!g_ScreenInfo[i].fNoTrayIcon && g_ScreenInfo[i].pScreen)
 	winDeleteNotifyIcon (winGetScreenPriv (g_ScreenInfo[i].pScreen));
d196 2
a197 2
  /* Notify the worker threads we're exiting */
  winDeinitMultiWindowWM ();
d201 4
a204 5
  /* Close our handle to our message queue */
  if (g_fdMessageQueue != WIN_FD_INVALID)
    {
      /* Close /dev/windows */
      close (g_fdMessageQueue);
d206 2
a207 2
      /* Set the file handle to invalid */
      g_fdMessageQueue = WIN_FD_INVALID;
d211 5
a215 5
  if (!g_fLogInited) {
    g_pszLogFile = LogInit (g_pszLogFile, NULL);
    g_fLogInited = TRUE;
  }  
  LogClose (error);
d217 5
a221 5
  /*
   * At this point we aren't creating any new screens, so
   * we are guaranteed to not need the DirectDraw functions.
   */
  winReleaseDDProcAddresses();
d223 3
a225 11
  /* Unload our TrackMouseEvent function pointer */
  if (g_hmodCommonControls != NULL)
    {
      FreeLibrary (g_hmodCommonControls);
      g_hmodCommonControls = NULL;
      g_fpTrackMouseEvent = (FARPROC) (void (*)(void))NoopDDA;
    }
  
  /* Free concatenated command line */
  free(g_pszCommandLine);
  g_pszCommandLine = NULL;
d227 2
a228 2
  /* Remove our keyboard hook if it is installed */
  winRemoveKeyboardHookLL ();
d230 2
a231 2
  /* Tell Windows that we want to end the app */
  PostQuitMessage (0);
a233 1

d236 1
a236 1
AbortDDX (enum ExitCode error)
d239 1
a239 1
  winDebug ("AbortDDX\n");
d241 1
a241 1
  ddxGiveUp (error);
d246 2
a247 1
static const char *winCheckMntOpt(const struct mntent *mnt, const char *opt)
d251 1
d263 3
a265 2
    if ((s == mnt->mnt_opts || *(s-1) == ',') &&  (s[len] == 0 || s[len] == ','))
        return (char *)opt;
d272 38
a309 2
  FILE *mnt;
  struct mntent *ent;
d311 10
a320 25
  enum { none = 0, sys_root, user_root, sys_tmp, user_tmp } 
    level = none, curlevel;
  BOOL binary = TRUE;

  mnt = setmntent("/etc/mtab", "r");
  if (mnt == NULL)
  {
    ErrorF("setmntent failed");
    return;
  }

  while ((ent = getmntent(mnt)) != NULL)
  {
    BOOL system = (winCheckMntOpt(ent, "user") != NULL);
    BOOL root = (strcmp(ent->mnt_dir, "/") == 0);
    BOOL tmp = (strcmp(ent->mnt_dir, "/tmp") == 0);
    
    if (system)
    {
      if (root)
        curlevel = sys_root;
      else if (tmp)
        curlevel = sys_tmp;
      else
        continue;
d322 3
a324 29
    else
    {
      if (root)
        curlevel = user_root;
      else if (tmp) 
        curlevel = user_tmp;
      else
        continue;
    }

    if (curlevel <= level)
      continue;
    level = curlevel;

    if ((winCheckMntOpt(ent, "binary") == NULL) &&
        (winCheckMntOpt(ent, "binmode") == NULL))
      binary = FALSE;
    else
      binary = TRUE;
  }
    
  if (endmntent(mnt) != 1)
  {
    ErrorF("endmntent failed");
    return;
  }
  
 if (!binary) 
   winMsg(X_WARNING, "/tmp mounted in textmode\n");
d328 1
a328 1
winCheckMount(void) 
d334 1
a334 1
const char * 
d339 2
a340 2
    if (!inited)
    {
d344 1
d346 2
a347 2
            buffer[sizeof(buffer)-1] = 0;
    
d349 2
a350 4
        while (fendptr > buffer)
        {
            if (*fendptr == '\\' || *fendptr == '/')
            {
d363 1
a363 1
winFixupPaths (void)
d367 1
d377 2
a378 2
        if (fontdirs != NULL)
        {
d380 1
a380 1
            int needs_sep = TRUE; 
d388 1
a388 2
            while (!feof(fontdirs))
            {
d396 1
a396 1
                if (str == NULL) /* stop on error or eof */
d403 1
a403 2
                if (comment_block)
                {
d405 3
a407 3
                    *str = 0; 
                    blen = 0; 
                    if (has_eol) /* check if line ended in this block */
d410 1
a410 2
                else 
                {
d413 1
a413 2
                    if (hashchar != NULL)
                    {
d415 1
a415 1
                        if (!has_eol) /* mark next block as continued comment */
d424 1
a424 1
                /* get size, strip whitespaces from end */ 
d426 3
a428 3
                while (blen > 0 && (str[blen-1] == ' ' || 
                            str[blen-1] == '\t' || str[blen-1] == '\n'))
                {
d432 2
a433 3
                /* still something left to add? */ 
                if (blen > 0)
                {
d435 1
d442 1
a442 1
                        fontpath = malloc(newsize+1);
d444 1
a444 1
                        fontpath = realloc(fontpath, newsize+1);
d447 1
a447 2
                    if (needs_sep)
                    {
d465 1
a465 1
            fclose(fontdirs);  
d472 1
a472 1
#endif /* READ_FONTDIRS */
d485 1
a485 2
        while (ptr != NULL)
        {
d489 1
d493 2
a495 3
            if (strncmp(libx11dir, newpath, libx11dir_len) == 0)
            {
                char *compose;
d497 1
a497 1
                compose = malloc(newsize + 1);  
d507 1
a507 1
                newfp_len ++; /* space for separator */
d515 1
a515 2
            if (oldfp_len > 0)
            {
d523 1
a523 2
            if (*ptr == 0)
            {
d526 2
a527 2
            } else
            {
d533 1
a533 1
        } 
d539 1
a539 1
#endif /* RELOCATE_PROJECTROOT */
d541 1
a541 1
        winMsg (font_from, "FontPath set to \"%s\"\n", defaultFontPath);
d544 1
a544 2
    if (getenv("XKEYSYMDB") == NULL)
    {
d546 3
a548 3
        snprintf(buffer, sizeof(buffer), "XKEYSYMDB=%s\\XKeysymDB",
                basedir);
        buffer[sizeof(buffer)-1] = 0;
d551 1
a551 2
    if (getenv("XERRORDB") == NULL)
    {
d553 3
a555 3
        snprintf(buffer, sizeof(buffer), "XERRORDB=%s\\XErrorDB",
                basedir);
        buffer[sizeof(buffer)-1] = 0;
d558 1
a558 2
    if (getenv("XLOCALEDIR") == NULL)
    {
d560 3
a562 3
        snprintf(buffer, sizeof(buffer), "XLOCALEDIR=%s\\locale",
                basedir);
        buffer[sizeof(buffer)-1] = 0;
d565 1
a565 4
    if (getenv("HOME") == NULL)
    {
        HMODULE shfolder;
        SHGETFOLDERPATHPROC shgetfolderpath = NULL;
d567 1
a569 11
        /* Try to load SHGetFolderPath from shfolder.dll and shell32.dll */
        
        shfolder = LoadLibrary("shfolder.dll");
        /* fallback to shell32.dll */
        if (shfolder == NULL)
            shfolder = LoadLibrary("shell32.dll");

        /* resolve SHGetFolderPath */
        if (shfolder != NULL)
            shgetfolderpath = (SHGETFOLDERPATHPROC)GetProcAddress(shfolder, "SHGetFolderPathA");

d571 3
a573 4
        if (shgetfolderpath &&
                shgetfolderpath(NULL, CSIDL_APPDATA|CSIDL_FLAG_CREATE, NULL, 0, 
                    buffer + 5) == 0)
        { 
d575 4
a578 6
        } else
        {
            winMsg (X_ERROR, "Can not determine HOME directory\n");
        } 
        if (shfolder != NULL)
            FreeLibrary(shfolder);
d583 5
a587 5
        if (size && size < sizeof(buffer))
        {
            snprintf(buffer + size, sizeof(buffer) - size, 
                    "XWin.%s.log", display); 
            buffer[sizeof(buffer)-1] = 0;
d589 1
a589 1
            winMsg (X_DEFAULT, "Logfile set to \"%s\"\n", g_pszLogFile);
d597 1
a597 1
            xkbbasedir[sizeof(xkbbasedir)-1] = 0;
d599 1
a599 1
	XkbBinDirectory = basedir;
d601 1
a601 1
#endif /* RELOCATE_PROJECTROOT */
d605 1
a605 1
OsVendorInit (void)
d607 2
a608 2
  /* Re-initialize global variables on server reset */
  winInitializeGlobals ();
d610 1
a610 1
  winFixupPaths();
d613 2
a614 2
  if (!OsVendorVErrorFProc)
    OsVendorVErrorFProc = OsVendorVErrorF;
d617 60
a676 35
  if (!g_fLogInited) {
    /* keep this order. If LogInit fails it calls Abort which then calls
     * ddxGiveUp where LogInit is called again and creates an infinite 
     * recursion. If we set g_fLogInited to TRUE before the init we 
     * avoid the second call 
     */  
    g_fLogInited = TRUE;
    g_pszLogFile = LogInit (g_pszLogFile, NULL);
  } 
  LogSetParameter (XLOG_FLUSH, 1);
  LogSetParameter (XLOG_VERBOSITY, g_iLogVerbose);
  LogSetParameter (XLOG_FILE_VERBOSITY, g_iLogVerbose);

  /* Log the version information */
  if (serverGeneration == 1)
    winLogVersionInfo ();

  winCheckMount();  

  /* Add a default screen if no screens were specified */
  if (g_iNumScreens == 0)
    {
      winDebug ("OsVendorInit - Creating default screen 0\n");

      /*
       * We need to initialize the default screen 0 if no -screen
       * arguments were processed.
       *
       * Add a screen 0 using the defaults set by winInitializeDefaultScreens()
       * and any additional default screen parameters given
       */
      winInitializeScreens(1);

      /* We have to flag this as an explicit screen, even though it isn't */
      g_ScreenInfo[0].fExplicitScreen = TRUE;
a679 1

d681 1
a681 1
winUseMsg (void)
d683 4
a686 4
  ErrorF("\n");
  ErrorF("\n");
  ErrorF(EXECUTABLE_NAME " Device Dependent Usage:\n");
  ErrorF("\n");
d689 2
a690 2
  ErrorF ("-[no]clipboard\n"
	  "\tEnable [disable] the clipboard integration. Default is enabled.\n");
d693 4
a696 4
  ErrorF ("-clipupdates num_boxes\n"
	  "\tUse a clipping region to constrain shadow update blits to\n"
	  "\tthe updated region when num_boxes, or more, are in the\n"
	  "\tupdated region.\n");
d699 1
a699 2
  ErrorF ("-config\n"
          "\tSpecify a configuration file.\n");
d701 1
a701 2
  ErrorF ("-configdir\n"
          "\tSpecify a configuration directory.\n");
d704 3
a706 3
  ErrorF ("-depth bits_per_pixel\n"
	  "\tSpecify an optional bitdepth to use in fullscreen mode\n"
	  "\twith a DirectDraw engine.\n");
d708 3
a710 3
  ErrorF ("-emulate3buttons [timeout]\n"
	  "\tEmulate 3 button mouse with an optional timeout in\n"
	  "\tmilliseconds.\n");
d713 6
a718 6
  ErrorF ("-emulatepseudo\n"
	  "\tCreate a depth 8 PseudoColor visual when running in\n"
	  "\tdepths 15, 16, 24, or 32, collectively known as TrueColor\n"
	  "\tdepths.  The PseudoColor visual does not have correct colors,\n"
	  "\tand it may crash, but it at least allows you to run your\n"
	  "\tapplication in TrueColor modes.\n");
d721 5
a725 5
  ErrorF ("-engine engine_type_id\n"
	  "\tOverride the server's automatically selected engine type:\n"
	  "\t\t1 - Shadow GDI\n"
	  "\t\t2 - Shadow DirectDraw\n"
	  "\t\t4 - Shadow DirectDraw4 Non-Locking\n"
d727 1
a727 1
	  "\t\t8 - Primary DirectDraw - obsolete\n"
d730 1
a730 1
	  "\t\t16 - Native GDI - experimental\n"
d732 1
a732 1
	  );
d734 1
a734 2
  ErrorF ("-fullscreen\n"
	  "\tRun the server in fullscreen mode.\n");
d736 1
a736 2
  ErrorF ("-ignoreinput\n"
	  "\tIgnore keyboard and mouse input.\n");
d739 1
a739 2
  ErrorF ("-internalwm\n"
	  "\tRun the internal window manager.\n");
d743 2
a744 2
  ErrorF ("-keyboard\n"
	  "\tSpecify a keyboard device from the configuration file.\n");
d747 23
a769 23
  ErrorF ("-[no]keyhook\n"
	  "\tGrab special Windows keypresses like Alt-Tab or the Menu "
          "key.\n");

  ErrorF ("-lesspointer\n"
	  "\tHide the windows mouse pointer when it is over any\n"
          "\t" EXECUTABLE_NAME " window.  This prevents ghost cursors appearing when\n"
	  "\tthe Windows cursor is drawn on top of the X cursor\n");

  ErrorF ("-logfile filename\n"
	  "\tWrite log messages to <filename>.\n");

  ErrorF ("-logverbose verbosity\n"
	  "\tSet the verbosity of log messages. [NOTE: Only a few messages\n"
	  "\trespect the settings yet]\n"
	  "\t\t0 - only print fatal error.\n"
	  "\t\t1 - print additional configuration information.\n"
	  "\t\t2 - print additional runtime information [default].\n"
	  "\t\t3 - print debugging and tracing information.\n");

  ErrorF ("-[no]multimonitors or -[no]multiplemonitors\n"
	  "\tUse the entire virtual screen if multiple\n"
	  "\tmonitors are present.\n");
d772 1
a772 2
  ErrorF ("-multiwindow\n"
	  "\tRun the server in multi-window mode.\n");
d776 2
a777 2
  ErrorF ("-mwextwm\n"
	  "\tRun the server in multi-window external window manager mode.\n");
d780 3
a782 3
  ErrorF ("-nodecoration\n"
          "\tDo not draw a window border, title bar, etc.  Windowed\n"
	  "\tmode only.\n");
d785 2
a786 2
  ErrorF ("-nounicodeclipboard\n"
	  "\tDo not use Unicode clipboard even if on a NT-based platform.\n");
d789 35
a823 35
  ErrorF ("-refresh rate_in_Hz\n"
	  "\tSpecify an optional refresh rate to use in fullscreen mode\n"
	  "\twith a DirectDraw engine.\n");

  ErrorF ("-resize=none|scrollbars|randr"
	  "\tIn windowed mode, [don't] allow resizing of the window. 'scrollbars'\n"
	  "\tmode gives the window scrollbars as needed, 'randr' mode uses the RANR\n"
	  "\textension to resize the X screen.\n");

  ErrorF ("-rootless\n"
	  "\tRun the server in rootless mode.\n");

  ErrorF ("-screen scr_num [width height [x y] | [[WxH[+X+Y]][@@m]] ]\n"
	  "\tEnable screen scr_num and optionally specify a width and\n"
	  "\theight and initial position for that screen. Additionally\n"
	  "\ta monitor number can be specified to start the server on,\n"
	  "\tat which point, all coordinates become relative to that\n"
      "\tmonitor (Not for Windows NT4 and 95). Examples:\n"
      "\t -screen 0 800x600+100+100@@2 ; 2nd monitor offset 100,100 size 800x600\n"
      "\t -screen 0 1024x768@@3        ; 3rd monitor size 1024x768\n"
      "\t -screen 0 @@1 ; on 1st monitor using its full resolution (the default)\n");

  ErrorF ("-silent-dup-error\n"
	  "\tIf another instance of " EXECUTABLE_NAME " with the same display number is running\n"
	  "\texit silently and don't display any error message.\n");

  ErrorF ("-swcursor\n"
	  "\tDisable the usage of the Windows cursor and use the X11 software\n"
	  "\tcursor instead.\n");

  ErrorF ("-[no]trayicon\n"
          "\tDo not create a tray icon.  Default is to create one\n"
	  "\ticon per screen.  You can globally disable tray icons with\n"
	  "\t-notrayicon, then enable it for specific screens with\n"
	  "\t-trayicon for those screens.\n");
d825 1
a825 2
  ErrorF ("-[no]unixkill\n"
          "\tCtrl+Alt+Backspace exits the X Server.\n");
d828 2
a829 2
  ErrorF ("-[no]wgl\n"
	  "\tEnable the GLX extension to use the native Windows WGL interface for accelerated OpenGL\n");
d832 1
a832 2
  ErrorF ("-[no]winkill\n"
          "\tAlt+F4 exits the X Server.\n");
d834 3
a836 3
  ErrorF ("-xkblayout XKBLayout\n"
	  "\tEquivalent to XKBLayout in XF86Config files.\n"
	  "\tFor example: -xkblayout de\n");
d838 2
a839 2
  ErrorF ("-xkbmodel XKBModel\n"
	  "\tEquivalent to XKBModel in XF86Config files.\n");
d841 2
a842 2
  ErrorF ("-xkboptions XKBOptions\n"
	  "\tEquivalent to XKBOptions in XF86Config files.\n");
d844 2
a845 2
  ErrorF ("-xkbrules XKBRules\n"
	  "\tEquivalent to XKBRules in XF86Config files.\n");
d847 3
a849 3
  ErrorF ("-xkbvariant XKBVariant\n"
	  "\tEquivalent to XKBVariant in XF86Config files.\n"
	  "\tFor example: -xkbvariant nodeadkeys\n");
d856 18
a873 18
  /* Set a flag so that FatalError won't give duplicate warning message */
  g_fSilentFatalError = TRUE;
  
  winUseMsg();  

  /* Log file will not be opened for UseMsg unless we open it now */
  if (!g_fLogInited) {
    g_pszLogFile = LogInit (g_pszLogFile, NULL);
    g_fLogInited = TRUE;
  }  
  LogClose (EXIT_NO_ERROR);

  /* Notify user where UseMsg text can be found.*/
  if (!g_fNoHelpMessageBox)
    winMessageBoxF ("The " PROJECT_NAME " help text has been printed to "
		  "%s.\n"
		  "Please open %s to read the help text.\n",
		  MB_ICONINFORMATION, g_pszLogFile, g_pszLogFile);
d884 1
a884 1
InitOutput (ScreenInfo *screenInfo, int argc, char *argv[])
d886 1
a886 1
  int		i;
d888 2
a889 2
  /* Log the command line */
  winLogCommandLine (argc, argv);
d892 1
a892 1
  winDebug ("InitOutput\n");
d895 4
a898 5
  /* Validate command-line arguments */
  if (serverGeneration == 1 && !winValidateArgs ())
    {
      FatalError ("InitOutput - Invalid command-line arguments found.  "
		  "Exiting.\n");
d901 6
a906 7
  /* Check for duplicate invocation on same display number.*/
  if (serverGeneration == 1 && !winCheckDisplayNumber ())
    {
      if (g_fSilentDupError)
        g_fSilentFatalError = TRUE;  
      FatalError ("InitOutput - Duplicate invocation on display "
		  "number: %s.  Exiting.\n", display);
d910 3
a912 3
  /* Try to read the xorg.conf-style configuration file */
  if (!winReadConfigfile ())
    winErrorFVerb (1, "InitOutput - Error reading config file\n");
d914 5
a918 21
  winMsg(X_INFO, "xorg.conf is not supported\n");
  winMsg(X_INFO, "See http://x.cygwin.com/docs/faq/cygwin-x-faq.html "
         "for more information\n");
  winConfigFiles ();
#endif

  /* Load preferences from XWinrc file */
  LoadPreferences();

  /* Setup global screen info parameters */
  screenInfo->imageByteOrder = IMAGE_BYTE_ORDER;
  screenInfo->bitmapScanlinePad = BITMAP_SCANLINE_PAD;
  screenInfo->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
  screenInfo->bitmapBitOrder = BITMAP_BIT_ORDER;
  screenInfo->numPixmapFormats = NUMFORMATS;
  
  /* Describe how we want common pixmap formats padded */
  for (i = 0; i < NUMFORMATS; i++)
    {
      screenInfo->formats[i] = g_PixmapFormats[i];
    }
d920 2
a921 18
  /* Load pointers to DirectDraw functions */
  winGetDDProcAddresses ();
  
  /* Detect supported engines */
  winDetectSupportedEngines ();

  /* Load common controls library */
  g_hmodCommonControls = LoadLibraryEx ("comctl32.dll", NULL, 0);

  /* Load TrackMouseEvent function pointer */  
  g_fpTrackMouseEvent = GetProcAddress (g_hmodCommonControls,
					 "_TrackMouseEvent");
  if (g_fpTrackMouseEvent == NULL)
    {
      winErrorFVerb (1, "InitOutput - Could not get pointer to function\n"
	      "\t_TrackMouseEvent in comctl32.dll.  Try installing\n"
	      "\tInternet Explorer 3.0 or greater if you have not\n"
	      "\talready.\n");
d923 6
a928 3
      /* Free the library since we won't need it */
      FreeLibrary (g_hmodCommonControls);
      g_hmodCommonControls = NULL;
d930 3
a932 2
      /* Set function pointer to point to no operation function */
      g_fpTrackMouseEvent = (FARPROC) (void (*)(void))NoopDDA;
d935 5
a939 2
  /* Store the instance handle */
  g_hInstance = GetModuleHandle (NULL);
d941 9
a949 8
  /* Initialize each screen */
  for (i = 0; i < g_iNumScreens; ++i)
    {
      /* Initialize the screen */
      if (-1 == AddScreen (winScreenInit, argc, argv))
	{
	  FatalError ("InitOutput - Couldn't add screen %d", i);
	}
d954 11
a964 12
  /* Generate a cookie used by internal clients for authorization */
  if (g_fXdmcpEnabled || g_fAuthEnabled)
    winGenerateAuthorization ();

  /* Perform some one time initialization */
  if (1 == serverGeneration)
    {
      /*
       * setlocale applies to all threads in the current process.
       * Apply locale specified in LANG environment variable.
       */
      setlocale (LC_ALL, "");
d969 1
a969 1
  winDebug ("InitOutput - Returning.\n");
a972 1

d982 1
a982 1
winCheckDisplayNumber (void)
d984 51
a1034 58
  int			nDisp;
  HANDLE		mutex;
  char			name[MAX_PATH];
  char *		pszPrefix = '\0';
  OSVERSIONINFO		osvi = {0};

  /* Check display range */
  nDisp = atoi (display);
  if (nDisp < 0 || nDisp > 65535)
    {
      ErrorF ("winCheckDisplayNumber - Bad display number: %d\n", nDisp);
      return FALSE;
    }

  /* Set first character of mutex name to null */
  name[0] = '\0';

  /* Get operating system version information */
  osvi.dwOSVersionInfoSize = sizeof (osvi);
  GetVersionEx (&osvi);

  /* Want a mutex shared among all terminals on NT > 4.0 */
  if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT
      && osvi.dwMajorVersion >= 5)
    {
      pszPrefix = "Global\\";
    }

  /* Setup Cygwin/X specific part of name */
  snprintf (name, sizeof(name), "%sCYGWINX_DISPLAY:%d", pszPrefix, nDisp);

  /* Windows automatically releases the mutex when this process exits */
  mutex = CreateMutex (NULL, FALSE, name);
  if (!mutex)
    {
      LPVOID lpMsgBuf;

      /* Display a fancy error message */
      FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		     FORMAT_MESSAGE_FROM_SYSTEM | 
		     FORMAT_MESSAGE_IGNORE_INSERTS,
		     NULL,
		     GetLastError (),
		     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		     (LPTSTR) &lpMsgBuf,
		     0, NULL);
      ErrorF ("winCheckDisplayNumber - CreateMutex failed: %s\n",
	      (LPSTR)lpMsgBuf);
      LocalFree (lpMsgBuf);

      return FALSE;
    }
  if (GetLastError () == ERROR_ALREADY_EXISTS)
    {
      ErrorF ("winCheckDisplayNumber - "
	      PROJECT_NAME " is already running on display %d\n",
	      nDisp);
      return FALSE;
d1037 1
a1037 1
  return TRUE;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d52 1
a52 1
typedef HRESULT (*SHGETFOLDERPATHPROC)(
a60 1

a63 19

extern int			g_iNumScreens;
extern winScreenInfo *		g_ScreenInfo;
extern char *			g_pszCommandLine;
extern Bool			g_fSilentFatalError;

extern const char *		g_pszLogFile;
extern Bool			g_fLogFileChanged;
extern int			g_iLogVerbose;
Bool				g_fLogInited;

extern Bool			g_fXdmcpEnabled;
extern Bool			g_fAuthEnabled;
#ifdef HAS_DEVWINDOWS
extern int			g_fdMessageQueue;
#endif
extern const char *		g_pszQueryHost;
extern HINSTANCE		g_hInstance;

d73 5
a77 9
extern HMODULE			g_hmodDirectDraw;
extern FARPROC			g_fpDirectDrawCreate;
extern FARPROC			g_fpDirectDrawCreateClipper;
  
extern HMODULE			g_hmodCommonControls;
extern FARPROC			g_fpTrackMouseEvent;
extern Bool			g_fNoHelpMessageBox;                     
extern Bool			g_fSilentDupError;                     
extern Bool                     g_fNativeGl;
d194 1
a194 1
ddxGiveUp (void)
d231 1
a231 1
  LogClose ();
d237 1
a237 7
  if (g_hmodDirectDraw != NULL)
    {
      FreeLibrary (g_hmodDirectDraw);
      g_hmodDirectDraw = NULL;
      g_fpDirectDrawCreate = NULL;
      g_fpDirectDrawCreateClipper = NULL;
    }
d239 1
a239 1
  /* Unload our TrackMouseEvent funtion pointer */
d261 1
a261 1
AbortDDX (void)
d266 1
a266 1
  ddxGiveUp ();
d410 1
a410 1
            /* get defautl fontpath */
d758 3
d829 5
a846 5
  ErrorF ("-scrollbars\n"
	  "\tIn windowed mode, allow screens bigger than the Windows desktop.\n"
	  "\tMoreover, if the window has decorations, one can now resize\n"
	  "\tit.\n");

d849 1
a849 1
     "\texit silently and don’t display any error message.\n");
d904 1
a904 1
  LogClose ();
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d67 1
a67 2
extern winScreenInfo		g_ScreenInfo[];
extern int			g_iLastScreen;
d101 2
a102 2
  
  
a116 3
void
winInitializeDefaultScreens (void);

a153 1
#ifdef RENDER
a154 1
#endif
d186 11
d278 2
a279 5
  if (g_pszCommandLine)
    {
      free (g_pszCommandLine);
      g_pszCommandLine = NULL;
    }
d441 1
a441 1
            char *fontpath = xstrdup(defaultFontPath);
d528 1
a528 1
            defaultFontPath = xstrdup(fontpath);
d600 1
a600 1
        defaultFontPath = xstrdup(newfp);
d723 1
a723 8
      winDebug ("OsVendorInit - Creating bogus screen 0\n");

      /* 
       * We need to initialize default screens if no arguments
       * were processed.  Otherwise, the default screens would
       * already have been initialized by ddxProcessArgument ().
       */
      winInitializeDefaultScreens ();
d726 5
a730 3
       * Add a screen 0 using the defaults set by 
       * winInitializeDefaultScreens () and any additional parameters
       * processed by ddxProcessArgument ().
d732 1
a732 2
      g_iNumScreens = 1;
      g_iLastScreen = 0;
d890 5
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d1 1
d5 1
d47 2
a48 2
#if defined(XKB) && defined(WIN32)
#include <xkbsrv.h>
d72 1
a72 1
extern char *			g_pszLogFile;
d78 1
d247 1
a247 1
    LogInit (g_pszLogFile, NULL);
d338 1
a338 1
    BOOL system = (strcmp(ent->mnt_type, "system") == 0);
d365 3
a367 2
    if (winCheckMntOpt(ent, "binmode") == NULL)
      binary = 0;
d369 1
a369 1
      binary = 1;
d379 1
a379 1
   winMsg(X_WARNING, "/tmp mounted int textmode\n"); 
a673 1
#ifdef XKB
a682 1
#endif /* XKB */
a691 3
  LogInit (NULL, NULL);
  LogSetParameter (XLOG_VERBOSITY, g_iLogVerbose);

d706 1
a706 1
    LogInit (g_pszLogFile, NULL);
d710 1
a710 1
  LogSetParameter (XLOG_FILE_VERBOSITY, 1);
d747 23
d778 9
a798 14
  
  ErrorF ("-refresh rate_in_Hz\n"
	  "\tSpecify an optional refresh rate to use in fullscreen mode\n"
	  "\twith a DirectDraw engine.\n");

  ErrorF ("-screen scr_num [width height [x y] | [[WxH[+X+Y]][@@m]] ]\n"
	  "\tEnable screen scr_num and optionally specify a width and\n"
	  "\theight and initial position for that screen. Additionally\n"
	  "\ta monitor number can be specified to start the server on,\n"
	  "\tat which point, all coordinates become relative to that\n"
      "\tmonitor (Not for Windows NT4 and 95). Examples:\n"
      "\t -screen 0 800x600+100+100@@2 ; 2nd monitor offset 100,100 size 800x600\n"
      "\t -screen 0 1024x768@@3        ; 3rd monitor size 1024x768\n"
      "\t -screen 0 @@1 ; on 1st monitor using its full resolution (the default)\n");
d800 2
a801 8
  ErrorF ("-lesspointer\n"
	  "\tHide the windows mouse pointer when it is over an inactive\n"
          "\t" PROJECT_NAME " window.  This prevents ghost cursors appearing where\n"
	  "\tthe Windows cursor is drawn overtop of the X cursor\n");

  ErrorF ("-nodecoration\n"
          "\tDo not draw a window border, title bar, etc.  Windowed\n"
	  "\tmode only.\n");
a803 3
  ErrorF ("-mwextwm\n"
	  "\tRun the server in multi-window external window manager mode.\n");

d808 28
a835 2
  ErrorF ("-rootless\n"
	  "\tRun the server in rootless mode.\n");
d842 8
a849 3
  ErrorF ("-multiplemonitors\n"
	  "\tEXPERIMENTAL: Use the entire virtual screen if multiple\n"
	  "\tmonitors are present.\n");
a851 4
  ErrorF ("-clipboard\n"
	  "\tRun the clipboard integration module.\n"
	  "\tDo not use at the same time as 'xwinclip'.\n");

d853 1
a853 1
	  "\tDo not use Unicode clipboard even if NT-based platform.\n");
d856 17
d878 8
a891 14
  ErrorF ("-clipupdates num_boxes\n"
	  "\tUse a clipping region to constrain shadow update blits to\n"
	  "\tthe updated region when num_boxes, or more, are in the\n"
	  "\tupdated region.  Currently supported only by `-engine 1'.\n");

#ifdef XWIN_EMULATEPSEUDO
  ErrorF ("-emulatepseudo\n"
	  "\tCreate a depth 8 PseudoColor visual when running in\n"
	  "\tdepths 15, 16, 24, or 32, collectively known as TrueColor\n"
	  "\tdepths.  The PseudoColor visual does not have correct colors,\n"
	  "\tand it may crash, but it at least allows you to run your\n"
	  "\tapplication in TrueColor modes.\n");
#endif

a897 15
#ifdef XWIN_XF86CONFIG
  ErrorF ("-config\n"
          "\tSpecify a configuration file.\n");

  ErrorF ("-keyboard\n"
	  "\tSpecify a keyboard device from the configuration file.\n");
#endif

#ifdef XKB
  ErrorF ("-xkbrules XKBRules\n"
	  "\tEquivalent to XKBRules in XF86Config files.\n");

  ErrorF ("-xkbmodel XKBModel\n"
	  "\tEquivalent to XKBModel in XF86Config files.\n");

d902 2
a903 3
  ErrorF ("-xkbvariant XKBVariant\n"
	  "\tEquivalent to XKBVariant in XF86Config files.\n"
	  "\tFor example: -xkbvariant nodeadkeys\n");
a906 1
#endif
d908 2
a909 2
  ErrorF ("-logfile filename\n"
	  "\tWrite logmessages to <filename> instead of /tmp/Xwin.log.\n");
d911 3
a913 15
  ErrorF ("-logverbose verbosity\n"
	  "\tSet the verbosity of logmessages. [NOTE: Only a few messages\n"
	  "\trespect the settings yet]\n"
	  "\t\t0 - only print fatal error.\n"
	  "\t\t1 - print additional configuration information.\n"
	  "\t\t2 - print additional runtime information [default].\n"
	  "\t\t3 - print debugging and tracing information.\n");

  ErrorF ("-[no]keyhook\n"
	  "\tGrab special windows key combinations like Alt-Tab or the Menu "
          "key.\n These keys are discarded by default.\n");

  ErrorF ("-swcursor\n"
	  "\tDisable the usage of the windows cursor and use the X11 software "
	  "cursor instead\n");
d927 1
a927 1
    LogInit (g_pszLogFile, NULL);
d935 3
a937 3
		  "/tmp/XWin.log.\n"
		  "Please open /tmp/XWin.log to read the help text.\n",
		  MB_ICONINFORMATION);
d980 1
a980 1
  winMsg(X_INFO, "XF86Config is not supported\n");
a1043 1
#if defined(XCSECURITY)
d1045 1
a1045 1
  if (g_fXdmcpEnabled)
a1046 1
#endif
d1074 1
a1074 1
winCheckDisplayNumber ()
a1137 17

#ifdef DPMSExtension
Bool DPMSSupported(void)
{
  return FALSE;
}

void DPMSSet(int level)
{
  return;
}

int DPMSGet(int *plevel)
{
  return 0;
}
#endif
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a922 5
/* ddxInitGlobals - called by |InitGlobals| from os/util.c */
void ddxInitGlobals(void)
{
}

@


1.1
log
@Initial revision
@
text
@a0 1
/* $TOG: InitOutput.c /main/20 1998/02/10 13:23:56 kaleb $ */
d46 1
a46 1
#include <X11/extensions/XKBsrv.h>
a602 18
    if (1) {
      const char *libx11dir = "/usr/X11R6/lib/X11";
      size_t libx11dir_len = strlen(libx11dir);

      if (strncmp(libx11dir, rgbPath, libx11dir_len) == 0)
      {
          size_t newsize = strlen(rgbPath) - libx11dir_len + basedirlen;
          char *compose = malloc(newsize + 1);  
          strcpy(compose, basedir);
          strcat(compose, rgbPath + libx11dir_len);
          compose[newsize] = 0;
          rgbPath = xstrdup (compose);
          free (compose);

          winMsg (X_DEFAULT, "RgbPath set to \"%s\"\n", rgbPath);
      }
    }

d678 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@a696 1
	XkbBinDirectory = basedir;
@


1.1.1.3
log
@xserver 1.4
@
text
@d1 1
d47 1
a47 1
#include <xkbsrv.h>
@


