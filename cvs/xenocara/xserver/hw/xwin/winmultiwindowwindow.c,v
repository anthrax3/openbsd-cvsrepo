head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.10
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.8
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.6
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.4
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.18;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.11.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *Copyright (C) Colin Harrison 2005-2008
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Kensuke Matsuzaki
 *		Earle F. Philhower, III
 *		Harold L Hunt II
 *              Colin Harrison
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include "dixevents.h"
#include "winmultiwindowclass.h"

/*
 * Prototypes for local functions
 */

void
 winCreateWindowsWindow(WindowPtr pWin);

static void
 winDestroyWindowsWindow(WindowPtr pWin);

static void
 winUpdateWindowsWindow(WindowPtr pWin);

static void
 winFindWindow(void *value, XID id, void *cdata);

static
    void
winInitMultiWindowClass(void)
{
    static wATOM atomXWinClass = 0;
    WNDCLASSEX wcx;

    if (atomXWinClass == 0) {
        HICON hIcon, hIconSmall;

        /* Load the default icons */
        winSelectIcons(&hIcon, &hIconSmall);

        /* Setup our window class */
        wcx.cbSize = sizeof(WNDCLASSEX);
        wcx.style = CS_HREDRAW | CS_VREDRAW | (g_fNativeGl ? CS_OWNDC : 0);
        wcx.lpfnWndProc = winTopLevelWindowProc;
        wcx.cbClsExtra = 0;
        wcx.cbWndExtra = 0;
        wcx.hInstance = g_hInstance;
        wcx.hIcon = hIcon;
        wcx.hCursor = 0;
        wcx.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
        wcx.lpszMenuName = NULL;
        wcx.lpszClassName = WINDOW_CLASS_X;
        wcx.hIconSm = hIconSmall;

#if CYGMULTIWINDOW_DEBUG
        ErrorF("winCreateWindowsWindow - Creating class: %s\n", WINDOW_CLASS_X);
#endif

        atomXWinClass = RegisterClassEx(&wcx);
    }
}

/*
 * CreateWindow - See Porting Layer Definition - p. 37
 */

Bool
winCreateWindowMultiWindow(WindowPtr pWin)
{
    Bool fResult = TRUE;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winWindowPriv(pWin);
    winScreenPriv(pScreen);

#if CYGMULTIWINDOW_DEBUG
    winTrace("winCreateWindowMultiWindow - pWin: %p\n", pWin);
#endif

    WIN_UNWRAP(CreateWindow);
    fResult = (*pScreen->CreateWindow) (pWin);
    WIN_WRAP(CreateWindow, winCreateWindowMultiWindow);

    /* Initialize some privates values */
    pWinPriv->hRgn = NULL;
    pWinPriv->hWnd = NULL;
    pWinPriv->pScreenPriv = winGetScreenPriv(pWin->drawable.pScreen);
    pWinPriv->fXKilled = FALSE;
#ifdef XWIN_GLX_WINDOWS
    pWinPriv->fWglUsed = FALSE;
#endif

    return fResult;
}

/*
 * DestroyWindow - See Porting Layer Definition - p. 37
 */

Bool
winDestroyWindowMultiWindow(WindowPtr pWin)
{
    Bool fResult = TRUE;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winWindowPriv(pWin);
    winScreenPriv(pScreen);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("winDestroyWindowMultiWindow - pWin: %p\n", pWin);
#endif

    WIN_UNWRAP(DestroyWindow);
    fResult = (*pScreen->DestroyWindow) (pWin);
    WIN_WRAP(DestroyWindow, winDestroyWindowMultiWindow);

    /* Flag that the window has been destroyed */
    pWinPriv->fXKilled = TRUE;

    /* Kill the MS Windows window associated with this window */
    winDestroyWindowsWindow(pWin);

    return fResult;
}

/*
 * PositionWindow - See Porting Layer Definition - p. 37
 *
 * This function adjusts the position and size of Windows window
 * with respect to the underlying X window.  This is the inverse
 * of winAdjustXWindow, which adjusts X window to Windows window.
 */

Bool
winPositionWindowMultiWindow(WindowPtr pWin, int x, int y)
{
    Bool fResult = TRUE;
    int iX, iY, iWidth, iHeight;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winWindowPriv(pWin);
    winScreenPriv(pScreen);

    HWND hWnd = pWinPriv->hWnd;
    RECT rcNew;
    RECT rcOld;

#if CYGMULTIWINDOW_DEBUG
    RECT rcClient;
    RECT *lpRc;
#endif
    DWORD dwExStyle;
    DWORD dwStyle;

#if CYGMULTIWINDOW_DEBUG
    winTrace("winPositionWindowMultiWindow - pWin: %p\n", pWin);
#endif

    WIN_UNWRAP(PositionWindow);
    fResult = (*pScreen->PositionWindow) (pWin, x, y);
    WIN_WRAP(PositionWindow, winPositionWindowMultiWindow);

#if CYGWINDOWING_DEBUG
    ErrorF("winPositionWindowMultiWindow: (x, y) = (%d, %d)\n", x, y);
#endif

    /* Bail out if the Windows window handle is bad */
    if (!hWnd) {
#if CYGWINDOWING_DEBUG
        ErrorF("\timmediately return since hWnd is NULL\n");
#endif
        return fResult;
    }

    /* Get the Windows window style and extended style */
    dwExStyle = GetWindowLongPtr(hWnd, GWL_EXSTYLE);
    dwStyle = GetWindowLongPtr(hWnd, GWL_STYLE);

    /* Get the X and Y location of the X window */
    iX = pWin->drawable.x + GetSystemMetrics(SM_XVIRTUALSCREEN);
    iY = pWin->drawable.y + GetSystemMetrics(SM_YVIRTUALSCREEN);

    /* Get the height and width of the X window */
    iWidth = pWin->drawable.width;
    iHeight = pWin->drawable.height;

    /* Store the origin, height, and width in a rectangle structure */
    SetRect(&rcNew, iX, iY, iX + iWidth, iY + iHeight);

#if CYGMULTIWINDOW_DEBUG
    lpRc = &rcNew;
    ErrorF("winPositionWindowMultiWindow - drawable (%d, %d)-(%d, %d)\n",
           (int)lpRc->left, (int)lpRc->top, (int)lpRc->right, (int)lpRc->bottom);
#endif

    /*
     * Calculate the required size of the Windows window rectangle,
     * given the size of the Windows window client area.
     */
    AdjustWindowRectEx(&rcNew, dwStyle, FALSE, dwExStyle);

    /* Get a rectangle describing the old Windows window */
    GetWindowRect(hWnd, &rcOld);

#if CYGMULTIWINDOW_DEBUG
    /* Get a rectangle describing the Windows window client area */
    GetClientRect(hWnd, &rcClient);

    lpRc = &rcNew;
    ErrorF("winPositionWindowMultiWindow - rcNew (%d, %d)-(%d, %d)\n",
           (int)lpRc->left, (int)lpRc->top, (int)lpRc->right, (int)lpRc->bottom);

    lpRc = &rcOld;
    ErrorF("winPositionWindowMultiWindow - rcOld (%d, %d)-(%d, %d)\n",
           (int)lpRc->left, (int)lpRc->top, (int)lpRc->right, (int)lpRc->bottom);

    lpRc = &rcClient;
    ErrorF("rcClient (%d, %d)-(%d, %d)\n",
           (int)lpRc->left, (int)lpRc->top, (int)lpRc->right, (int)lpRc->bottom);
#endif

    /* Check if the old rectangle and new rectangle are the same */
    if (!EqualRect(&rcNew, &rcOld)) {
#if CYGMULTIWINDOW_DEBUG
        ErrorF("winPositionWindowMultiWindow - Need to move\n");
#endif

#if CYGWINDOWING_DEBUG
        ErrorF("\tMoveWindow to (%d, %d) - %dx%d\n", (int)rcNew.left, (int)rcNew.top,
               (int)(rcNew.right - rcNew.left), (int)(rcNew.bottom - rcNew.top));
#endif
        /* Change the position and dimensions of the Windows window */
        MoveWindow(hWnd,
                   rcNew.left, rcNew.top,
                   rcNew.right - rcNew.left, rcNew.bottom - rcNew.top, TRUE);
    }
    else {
#if CYGMULTIWINDOW_DEBUG
        ErrorF("winPositionWindowMultiWindow - Not need to move\n");
#endif
    }

    return fResult;
}

/*
 * ChangeWindowAttributes - See Porting Layer Definition - p. 37
 */

Bool
winChangeWindowAttributesMultiWindow(WindowPtr pWin, unsigned long mask)
{
    Bool fResult = TRUE;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winScreenPriv(pScreen);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("winChangeWindowAttributesMultiWindow - pWin: %p\n", pWin);
#endif

    WIN_UNWRAP(ChangeWindowAttributes);
    fResult = (*pScreen->ChangeWindowAttributes) (pWin, mask);
    WIN_WRAP(ChangeWindowAttributes, winChangeWindowAttributesMultiWindow);

    /*
     * NOTE: We do not currently need to do anything here.
     */

    return fResult;
}

/*
 * UnmapWindow - See Porting Layer Definition - p. 37
 * Also referred to as UnrealizeWindow
 */

Bool
winUnmapWindowMultiWindow(WindowPtr pWin)
{
    Bool fResult = TRUE;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winWindowPriv(pWin);
    winScreenPriv(pScreen);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("winUnmapWindowMultiWindow - pWin: %p\n", pWin);
#endif

    WIN_UNWRAP(UnrealizeWindow);
    fResult = (*pScreen->UnrealizeWindow) (pWin);
    WIN_WRAP(UnrealizeWindow, winUnmapWindowMultiWindow);

    /* Flag that the window has been killed */
    pWinPriv->fXKilled = TRUE;

    /* Destroy the Windows window associated with this X window */
    winDestroyWindowsWindow(pWin);

    return fResult;
}

/*
 * MapWindow - See Porting Layer Definition - p. 37
 * Also referred to as RealizeWindow
 */

Bool
winMapWindowMultiWindow(WindowPtr pWin)
{
    Bool fResult = TRUE;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winWindowPriv(pWin);
    winScreenPriv(pScreen);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("winMapWindowMultiWindow - pWin: %p\n", pWin);
#endif

    WIN_UNWRAP(RealizeWindow);
    fResult = (*pScreen->RealizeWindow) (pWin);
    WIN_WRAP(RealizeWindow, winMapWindowMultiWindow);

    /* Flag that this window has not been destroyed */
    pWinPriv->fXKilled = FALSE;

    /* Refresh/redisplay the Windows window associated with this X window */
    winUpdateWindowsWindow(pWin);

    /* Update the Windows window's shape */
    winReshapeMultiWindow(pWin);
    winUpdateRgnMultiWindow(pWin);

    return fResult;
}

/*
 * ReparentWindow - See Porting Layer Definition - p. 42
 */

void
winReparentWindowMultiWindow(WindowPtr pWin, WindowPtr pPriorParent)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winScreenPriv(pScreen);

    winDebug
        ("winReparentMultiWindow - pWin:%p XID:0x%x, reparent from pWin:%p XID:0x%x to pWin:%p XID:0x%x\n",
         pWin, (unsigned int)pWin->drawable.id,
         pPriorParent, (unsigned int)pPriorParent->drawable.id,
         pWin->parent, (unsigned int)pWin->parent->drawable.id);

    WIN_UNWRAP(ReparentWindow);
    if (pScreen->ReparentWindow)
        (*pScreen->ReparentWindow) (pWin, pPriorParent);
    WIN_WRAP(ReparentWindow, winReparentWindowMultiWindow);

    /* Update the Windows window associated with this X window */
    winUpdateWindowsWindow(pWin);
}

/*
 * RestackWindow - Shuffle the z-order of a window
 */

void
winRestackWindowMultiWindow(WindowPtr pWin, WindowPtr pOldNextSib)
{
#if 0
    WindowPtr pPrevWin;
    UINT uFlags;
    HWND hInsertAfter;
    HWND hWnd = NULL;
#endif
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winScreenPriv(pScreen);

#if CYGMULTIWINDOW_DEBUG || CYGWINDOWING_DEBUG
    winTrace("winRestackMultiWindow - %p\n", pWin);
#endif

    WIN_UNWRAP(RestackWindow);
    if (pScreen->RestackWindow)
        (*pScreen->RestackWindow) (pWin, pOldNextSib);
    WIN_WRAP(RestackWindow, winRestackWindowMultiWindow);

#if 1
    /*
     * Calling winReorderWindowsMultiWindow here means our window manager
     * (i.e. Windows Explorer) has initiative to determine Z order.
     */
    if (pWin->nextSib != pOldNextSib)
        winReorderWindowsMultiWindow();
#else
    /* Bail out if no window privates or window handle is invalid */
    if (!pWinPriv || !pWinPriv->hWnd)
        return;

    /* Get a pointer to our previous sibling window */
    pPrevWin = pWin->prevSib;

    /*
     * Look for a sibling window with
     * valid privates and window handle
     */
    while (pPrevWin && !winGetWindowPriv(pPrevWin)
           && !winGetWindowPriv(pPrevWin)->hWnd)
        pPrevWin = pPrevWin->prevSib;

    /* Check if we found a valid sibling */
    if (pPrevWin) {
        /* Valid sibling - get handle to insert window after */
        hInsertAfter = winGetWindowPriv(pPrevWin)->hWnd;
        uFlags = SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE;

        hWnd = GetNextWindow(pWinPriv->hWnd, GW_HWNDPREV);

        do {
            if (GetProp(hWnd, WIN_WINDOW_PROP)) {
                if (hWnd == winGetWindowPriv(pPrevWin)->hWnd) {
                    uFlags |= SWP_NOZORDER;
                }
                break;
            }
            hWnd = GetNextWindow(hWnd, GW_HWNDPREV);
        }
        while (hWnd);
    }
    else {
        /* No valid sibling - make this window the top window */
        hInsertAfter = HWND_TOP;
        uFlags = SWP_NOMOVE | SWP_NOSIZE;
    }

    /* Perform the restacking operation in Windows */
    SetWindowPos(pWinPriv->hWnd, hInsertAfter, 0, 0, 0, 0, uFlags);
#endif
}

/*
 * winCreateWindowsWindow - Create a Windows window associated with an X window
 */

void
winCreateWindowsWindow(WindowPtr pWin)
{
    int iX, iY;
    int iWidth;
    int iHeight;
    HWND hWnd;
    HWND hFore = NULL;

    winWindowPriv(pWin);
    winPrivScreenPtr pScreenPriv = pWinPriv->pScreenPriv;
    WinXSizeHints hints;
    Window daddyId;
    DWORD dwStyle, dwExStyle;
    RECT rc;

    winInitMultiWindowClass();

    winDebug("winCreateWindowsTopLevelWindow - pWin:%p XID:0x%x \n", pWin,
             (unsigned int)pWin->drawable.id);

    iX = pWin->drawable.x + GetSystemMetrics(SM_XVIRTUALSCREEN);
    iY = pWin->drawable.y + GetSystemMetrics(SM_YVIRTUALSCREEN);

    iWidth = pWin->drawable.width;
    iHeight = pWin->drawable.height;

    /* If it's an InputOutput window, and so is going to end up being made visible,
       make sure the window actually ends up somewhere where it will be visible

       To handle arrangements of monitors which form a non-rectangular virtual
       desktop, check if the window will end up with it's top-left corner on any
       monitor
    */
    if (pWin->drawable.class != InputOnly) {
        POINT pt = { iX, iY };
        if (MonitorFromPoint(pt, MONITOR_DEFAULTTONULL) == NULL)
            {
                iX = CW_USEDEFAULT;
                iY = CW_USEDEFAULT;
            }
    }

    winDebug("winCreateWindowsWindow - %dx%d @@ %dx%d\n", iWidth, iHeight, iX,
             iY);

    if (winMultiWindowGetTransientFor(pWin, &daddyId)) {
        if (daddyId) {
            WindowPtr pParent;
            int res = dixLookupWindow(&pParent, daddyId, serverClient, DixReadAccess);
            if (res == Success)
                {
                    winPrivWinPtr pParentPriv = winGetWindowPriv(pParent);
                    hFore = pParentPriv->hWnd;
                }
        }
    }
    else {
        /* Default positions if none specified */
        if (!winMultiWindowGetWMNormalHints(pWin, &hints))
            hints.flags = 0;
        if (!(hints.flags & (USPosition | PPosition)) &&
            !pWin->overrideRedirect) {
            iX = CW_USEDEFAULT;
            iY = CW_USEDEFAULT;
        }
    }

    /* Make it WS_OVERLAPPED in create call since WS_POPUP doesn't support */
    /* CW_USEDEFAULT, change back to popup after creation */
    dwStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
    dwExStyle = WS_EX_TOOLWINDOW;

    /*
       Calculate the window coordinates containing the requested client area,
       being careful to preseve CW_USEDEFAULT
     */
    rc.top = (iY != CW_USEDEFAULT) ? iY : 0;
    rc.left = (iX != CW_USEDEFAULT) ? iX : 0;
    rc.bottom = rc.top + iHeight;
    rc.right = rc.left + iWidth;
    AdjustWindowRectEx(&rc, dwStyle, FALSE, dwExStyle);
    if (iY != CW_USEDEFAULT)
        iY = rc.top;
    if (iX != CW_USEDEFAULT)
        iX = rc.left;
    iHeight = rc.bottom - rc.top;
    iWidth = rc.right - rc.left;

    winDebug("winCreateWindowsWindow - %dx%d @@ %dx%d\n", iWidth, iHeight, iX,
             iY);

    /* Create the window */
    hWnd = CreateWindowExA(dwExStyle,   /* Extended styles */
                           WINDOW_CLASS_X,      /* Class name */
                           WINDOW_TITLE_X,      /* Window name */
                           dwStyle,     /* Styles */
                           iX,  /* Horizontal position */
                           iY,  /* Vertical position */
                           iWidth,      /* Right edge */
                           iHeight,     /* Bottom edge */
                           hFore,       /* Null or Parent window if transient */
                           (HMENU) NULL,        /* No menu */
                           GetModuleHandle(NULL),       /* Instance handle */
                           pWin);       /* ScreenPrivates */
    if (hWnd == NULL) {
        ErrorF("winCreateWindowsWindow - CreateWindowExA () failed: %d\n",
               (int) GetLastError());
    }
    pWinPriv->hWnd = hWnd;

    /* Change style back to popup, already placed... */
    SetWindowLongPtr(hWnd, GWL_STYLE,
                     WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS);
    SetWindowPos(hWnd, 0, 0, 0, 0, 0,
                 SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE |
                 SWP_NOACTIVATE);

    /* Adjust the X window to match the window placement we actually got... */
    winAdjustXWindow(pWin, hWnd);

    /* Make sure it gets the proper system menu for a WS_POPUP, too */
    GetSystemMenu(hWnd, TRUE);

    /* Cause any .XWinrc menus to be added in main WNDPROC */
    PostMessage(hWnd, WM_INIT_SYS_MENU, 0, 0);

    SetProp(hWnd, WIN_WID_PROP, (HANDLE) (INT_PTR) winGetWindowID(pWin));

    /* Flag that this Windows window handles its own activation */
    SetProp(hWnd, WIN_NEEDMANAGE_PROP, (HANDLE) 0);

    /* Call engine-specific create window procedure */
    (*pScreenPriv->pwinFinishCreateWindowsWindow) (pWin);
}

Bool winInDestroyWindowsWindow = FALSE;

/*
 * winDestroyWindowsWindow - Destroy a Windows window associated
 * with an X window
 */
static void
winDestroyWindowsWindow(WindowPtr pWin)
{
    MSG msg;

    winWindowPriv(pWin);
    BOOL oldstate = winInDestroyWindowsWindow;
    HICON hIcon;
    HICON hIconSm;

    winDebug("winDestroyWindowsWindow - pWin:%p XID:0x%x \n", pWin,
             (unsigned int)pWin->drawable.id);

    /* Bail out if the Windows window handle is invalid */
    if (pWinPriv->hWnd == NULL)
        return;

    winInDestroyWindowsWindow = TRUE;

    /* Store the info we need to destroy after this window is gone */
    hIcon = (HICON) SendMessage(pWinPriv->hWnd, WM_GETICON, ICON_BIG, 0);
    hIconSm = (HICON) SendMessage(pWinPriv->hWnd, WM_GETICON, ICON_SMALL, 0);

    /* Destroy the Windows window */
    DestroyWindow(pWinPriv->hWnd);

    /* Null our handle to the Window so referencing it will cause an error */
    pWinPriv->hWnd = NULL;

    /* Destroy any icons we created for this window */
    winDestroyIcon(hIcon);
    winDestroyIcon(hIconSm);

#ifdef XWIN_GLX_WINDOWS
    /* No longer note WGL used on this window */
    pWinPriv->fWglUsed = FALSE;
#endif

    /* Process all messages on our queue */
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        if (g_hDlgDepthChange == 0 || !IsDialogMessage(g_hDlgDepthChange, &msg)) {
            DispatchMessage(&msg);
        }
    }

    winInDestroyWindowsWindow = oldstate;

    winDebug("winDestroyWindowsWindow - done\n");
}

/*
 * winUpdateWindowsWindow - Redisplay/redraw a Windows window
 * associated with an X window
 */

static void
winUpdateWindowsWindow(WindowPtr pWin)
{
    winWindowPriv(pWin);
    HWND hWnd = pWinPriv->hWnd;

#if CYGMULTIWINDOW_DEBUG
    ErrorF("winUpdateWindowsWindow\n");
#endif

    /* Check if the Windows window's parents have been destroyed */
    if (pWin->parent != NULL && pWin->parent->parent == NULL && pWin->mapped) {
        /* Create the Windows window if it has been destroyed */
        if (hWnd == NULL) {
            winCreateWindowsWindow(pWin);
            assert(pWinPriv->hWnd != NULL);
        }

        /* Display the window without activating it */
        if (pWin->drawable.class != InputOnly)
            ShowWindow(pWinPriv->hWnd, SW_SHOWNOACTIVATE);

        /* Send first paint message */
        UpdateWindow(pWinPriv->hWnd);
    }
    else if (hWnd != NULL) {
        /* Destroy the Windows window if its parents are destroyed */
        winDestroyWindowsWindow(pWin);
        assert(pWinPriv->hWnd == NULL);
    }

#if CYGMULTIWINDOW_DEBUG
    ErrorF("-winUpdateWindowsWindow\n");
#endif
}

/*
 * winGetWindowID -
 */

XID
winGetWindowID(WindowPtr pWin)
{
    WindowIDPairRec wi = { pWin, 0 };
    ClientPtr c = wClient(pWin);

    /* */
    FindClientResourcesByType(c, RT_WINDOW, winFindWindow, &wi);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("winGetWindowID - Window ID: %u\n", (unsigned int)wi.id);
#endif

    return wi.id;
}

/*
 * winFindWindow -
 */

static void
winFindWindow(void *value, XID id, void *cdata)
{
    WindowIDPairPtr wi = (WindowIDPairPtr) cdata;

    if (value == wi->value) {
        wi->id = id;
    }
}

/*
 * winReorderWindowsMultiWindow -
 */

void
winReorderWindowsMultiWindow(void)
{
    HWND hwnd = NULL;
    WindowPtr pWin = NULL;
    WindowPtr pWinSib = NULL;
    XID vlist[2];
    static Bool fRestacking = FALSE;    /* Avoid recusive calls to this function */
    DWORD dwCurrentProcessID = GetCurrentProcessId();
    DWORD dwWindowProcessID = 0;

#if CYGMULTIWINDOW_DEBUG || CYGWINDOWING_DEBUG
    winTrace("winReorderWindowsMultiWindow\n");
#endif

    if (fRestacking) {
        /* It is a recusive call so immediately exit */
#if CYGWINDOWING_DEBUG
        ErrorF("winReorderWindowsMultiWindow - "
               "exit because fRestacking == TRUE\n");
#endif
        return;
    }
    fRestacking = TRUE;

    /* Loop through top level Window windows, descending in Z order */
    for (hwnd = GetTopWindow(NULL);
         hwnd; hwnd = GetNextWindow(hwnd, GW_HWNDNEXT)) {
        /* Don't take care of other Cygwin/X process's windows */
        GetWindowThreadProcessId(hwnd, &dwWindowProcessID);

        if (GetProp(hwnd, WIN_WINDOW_PROP)
            && (dwWindowProcessID == dwCurrentProcessID)
            && !IsIconic(hwnd)) {       /* ignore minimized windows */
            pWinSib = pWin;
            pWin = GetProp(hwnd, WIN_WINDOW_PROP);

            if (!pWinSib) {     /* 1st window - raise to the top */
                vlist[0] = Above;

                ConfigureWindow(pWin, CWStackMode, vlist, wClient(pWin));
            }
            else {              /* 2nd or deeper windows - just below the previous one */
                vlist[0] = winGetWindowID(pWinSib);
                vlist[1] = Below;

                ConfigureWindow(pWin, CWSibling | CWStackMode,
                                vlist, wClient(pWin));
            }
        }
    }

    fRestacking = FALSE;
}

/*
 * winMinimizeWindow - Minimize in response to WM_CHANGE_STATE
 */

void
winMinimizeWindow(Window id)
{
    WindowPtr pWin;
    winPrivWinPtr pWinPriv;

#ifdef XWIN_MULTIWINDOWEXTWM
    win32RootlessWindowPtr pRLWinPriv;
#endif
    HWND hWnd;
    ScreenPtr pScreen = NULL;
    winPrivScreenPtr pScreenPriv = NULL;

#if CYGWINDOWING_DEBUG
    ErrorF("winMinimizeWindow\n");
#endif

    dixLookupResourceByType((void *) &pWin, id, RT_WINDOW, NullClient,
                            DixUnknownAccess);
    if (!pWin) {
        ErrorF("%s: NULL pWin. Leaving\n", __FUNCTION__);
        return;
    }

    pScreen = pWin->drawable.pScreen;
    if (pScreen)
        pScreenPriv = winGetScreenPriv(pScreen);

#ifdef XWIN_MULTIWINDOWEXTWM
    if (pScreenPriv && pScreenPriv->pScreenInfo->fInternalWM) {
        pRLWinPriv =
            (win32RootlessWindowPtr) RootlessFrameForWindow(pWin, FALSE);
        hWnd = pRLWinPriv->hWnd;
    }
    else
#else
    if (pScreenPriv)
#endif
    {
        pWinPriv = winGetWindowPriv(pWin);
        hWnd = pWinPriv->hWnd;
    }

    ShowWindow(hWnd, SW_MINIMIZE);
}

/*
 * CopyWindow - See Porting Layer Definition - p. 39
 */
void
winCopyWindowMultiWindow(WindowPtr pWin, DDXPointRec oldpt, RegionPtr oldRegion)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winScreenPriv(pScreen);

#if CYGWINDOWING_DEBUG
    ErrorF("CopyWindowMultiWindow\n");
#endif
    WIN_UNWRAP(CopyWindow);
    (*pScreen->CopyWindow) (pWin, oldpt, oldRegion);
    WIN_WRAP(CopyWindow, winCopyWindowMultiWindow);
}

/*
 * MoveWindow - See Porting Layer Definition - p. 42
 */
void
winMoveWindowMultiWindow(WindowPtr pWin, int x, int y,
                         WindowPtr pSib, VTKind kind)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winScreenPriv(pScreen);

#if CYGWINDOWING_DEBUG
    ErrorF("MoveWindowMultiWindow to (%d, %d)\n", x, y);
#endif

    WIN_UNWRAP(MoveWindow);
    (*pScreen->MoveWindow) (pWin, x, y, pSib, kind);
    WIN_WRAP(MoveWindow, winMoveWindowMultiWindow);
}

/*
 * ResizeWindow - See Porting Layer Definition - p. 42
 */
void
winResizeWindowMultiWindow(WindowPtr pWin, int x, int y, unsigned int w,
                           unsigned int h, WindowPtr pSib)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    winScreenPriv(pScreen);

#if CYGWINDOWING_DEBUG
    ErrorF("ResizeWindowMultiWindow to (%d, %d) - %dx%d\n", x, y, w, h);
#endif
    WIN_UNWRAP(ResizeWindow);
    (*pScreen->ResizeWindow) (pWin, x, y, w, h, pSib);
    WIN_WRAP(ResizeWindow, winResizeWindowMultiWindow);
}

/*
 * winAdjustXWindow
 *
 * Move and resize X window with respect to corresponding Windows window.
 * This is called from WM_MOVE/WM_SIZE handlers when the user performs
 * any windowing operation (move, resize, minimize, maximize, restore).
 *
 * The functionality is the inverse of winPositionWindowMultiWindow, which
 * adjusts Windows window with respect to X window.
 */
int
winAdjustXWindow(WindowPtr pWin, HWND hwnd)
{
    RECT rcDraw;                /* Rect made from pWin->drawable to be adjusted */
    RECT rcWin;                 /* The source: WindowRect from hwnd */
    DrawablePtr pDraw;
    XID vlist[4];
    LONG dX, dY, dW, dH, x, y;
    DWORD dwStyle, dwExStyle;

#define WIDTH(rc) (rc.right - rc.left)
#define HEIGHT(rc) (rc.bottom - rc.top)

#if CYGWINDOWING_DEBUG
    ErrorF("winAdjustXWindow\n");
#endif

    if (IsIconic(hwnd)) {
#if CYGWINDOWING_DEBUG
        ErrorF("\timmediately return because the window is iconized\n");
#endif
        /*
         * If the Windows window is minimized, its WindowRect has
         * meaningless values so we don't adjust X window to it.
         */
        vlist[0] = 0;
        vlist[1] = 0;
        return ConfigureWindow(pWin, CWX | CWY, vlist, wClient(pWin));
    }

    pDraw = &pWin->drawable;

    /* Calculate the window rect from the drawable */
    x = pDraw->x + GetSystemMetrics(SM_XVIRTUALSCREEN);
    y = pDraw->y + GetSystemMetrics(SM_YVIRTUALSCREEN);
    SetRect(&rcDraw, x, y, x + pDraw->width, y + pDraw->height);
#ifdef CYGMULTIWINDOW_DEBUG
    winDebug("\tDrawable extend {%d, %d, %d, %d}, {%d, %d}\n",
             (int)rcDraw.left, (int)rcDraw.top, (int)rcDraw.right, (int)rcDraw.bottom,
             (int)(rcDraw.right - rcDraw.left), (int)(rcDraw.bottom - rcDraw.top));
#endif
    dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
    dwStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
#ifdef CYGMULTIWINDOW_DEBUG
    winDebug("\tWindowStyle: %08x %08x\n", (unsigned int)dwStyle, (unsigned int)dwExStyle);
#endif
    AdjustWindowRectEx(&rcDraw, dwStyle, FALSE, dwExStyle);

    /* The source of adjust */
    GetWindowRect(hwnd, &rcWin);
#ifdef CYGMULTIWINDOW_DEBUG
    winDebug("\tWindow extend {%d, %d, %d, %d}, {%d, %d}\n",
             (int)rcWin.left, (int)rcWin.top, (int)rcWin.right, (int)rcWin.bottom,
             (int)(rcWin.right - rcWin.left), (int)(rcWin.bottom - rcWin.top));
    winDebug("\tDraw extend {%d, %d, %d, %d}, {%d, %d}\n",
             (int)rcDraw.left, (int)rcDraw.top, (int)rcDraw.right, (int)rcDraw.bottom,
             (int)(rcDraw.right - rcDraw.left), (int)(rcDraw.bottom - rcDraw.top));
#endif

    if (EqualRect(&rcDraw, &rcWin)) {
        /* Bail if no adjust is needed */
#if CYGWINDOWING_DEBUG
        ErrorF("\treturn because already adjusted\n");
#endif
        return 0;
    }

    /* Calculate delta values */
    dX = rcWin.left - rcDraw.left;
    dY = rcWin.top - rcDraw.top;
    dW = WIDTH(rcWin) - WIDTH(rcDraw);
    dH = HEIGHT(rcWin) - HEIGHT(rcDraw);

    /*
     * Adjust.
     * We may only need to move (vlist[0] and [1]), or only resize
     * ([2] and [3]) but currently we set all the parameters and leave
     * the decision to ConfigureWindow.  The reason is code simplicity.
     */
    vlist[0] = pDraw->x + dX - wBorderWidth(pWin);
    vlist[1] = pDraw->y + dY - wBorderWidth(pWin);
    vlist[2] = pDraw->width + dW;
    vlist[3] = pDraw->height + dH;
#if CYGWINDOWING_DEBUG
    ErrorF("\tConfigureWindow to (%u, %u) - %ux%u\n",
           (unsigned int)vlist[0], (unsigned int)vlist[1],
           (unsigned int)vlist[2], (unsigned int)vlist[3]);
#endif
    return ConfigureWindow(pWin, CWX | CWY | CWWidth | CWHeight,
                           vlist, wClient(pWin));

#undef WIDTH
#undef HEIGHT
}
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d222 2
a223 2
    ErrorF("winPositionWindowMultiWindow - (%d ms)drawable (%d, %d)-(%d, %d)\n",
           GetTickCount(), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
d240 2
a241 2
    ErrorF("winPositionWindowMultiWindow - (%d ms)rcNew (%d, %d)-(%d, %d)\n",
           GetTickCount(), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
d244 2
a245 2
    ErrorF("winPositionWindowMultiWindow - (%d ms)rcOld (%d, %d)-(%d, %d)\n",
           GetTickCount(), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
d248 2
a249 2
    ErrorF("(%d ms)rcClient (%d, %d)-(%d, %d)\n",
           GetTickCount(), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
d259 2
a260 2
        ErrorF("\tMoveWindow to (%ld, %ld) - %ldx%ld\n", rcNew.left, rcNew.top,
               rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
d382 3
a384 2
         pWin, pWin->drawable.id, pPriorParent, pPriorParent->drawable.id,
         pWin->parent, pWin->parent->drawable.id);
d497 1
a497 1
             pWin->drawable.id);
d506 6
a511 1
       make sure the window actually ends up somewhere where it will be visible */
d513 6
a518 7
        if ((iX < GetSystemMetrics(SM_XVIRTUALSCREEN)) ||
            (iX > GetSystemMetrics(SM_CXVIRTUALSCREEN)))
            iX = CW_USEDEFAULT;

        if ((iY < GetSystemMetrics(SM_YVIRTUALSCREEN)) ||
            (iY > GetSystemMetrics(SM_CYVIRTUALSCREEN)))
            iY = CW_USEDEFAULT;
d526 7
a532 3
            hFore = GetForegroundWindow();
            if (hFore && (daddyId != (Window) (INT_PTR) GetProp(hFore, WIN_WID_PROP)))
                hFore = NULL;
d631 1
a631 1
             pWin->drawable.id);
d725 1
a725 1
    ErrorF("winGetWindowID - Window ID: %d\n", wi.id);
d959 2
a960 2
             rcDraw.left, rcDraw.top, rcDraw.right, rcDraw.bottom,
             rcDraw.right - rcDraw.left, rcDraw.bottom - rcDraw.top);
d965 1
a965 1
    winDebug("\tWindowStyle: %08x %08x\n", dwStyle, dwExStyle);
d973 2
a974 2
             rcWin.left, rcWin.top, rcWin.right, rcWin.bottom,
             rcWin.right - rcWin.left, rcWin.bottom - rcWin.top);
d976 2
a977 2
             rcDraw.left, rcDraw.top, rcDraw.right, rcDraw.bottom,
             rcDraw.right - rcDraw.left, rcDraw.bottom - rcDraw.top);
d1005 3
a1007 2
    ErrorF("\tConfigureWindow to (%ld, %ld) - %ldx%ld\n", vlist[0], vlist[1],
           vlist[2], vlist[3]);
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d289 1
a289 1
    ErrorF("winChangeWindowAttributesMultiWindow - pWin: %08x\n", pWin);
d318 1
a318 1
    ErrorF("winUnmapWindowMultiWindow - pWin: %08x\n", pWin);
d349 1
a349 1
    ErrorF("winMapWindowMultiWindow - pWin: %08x\n", pWin);
d381 1
a381 1
        ("winReparentMultiWindow - pWin:%08x XID:0x%x, reparent from pWin:%08x XID:0x%x to pWin:%08x XID:0x%x\n",
d412 1
a412 1
    winTrace("winRestackMultiWindow - %08x\n", pWin);
d495 1
a495 1
    winDebug("winCreateWindowsTopLevelWindow - pWin:%08x XID:0x%x \n", pWin,
d621 1
a621 1
    winDebug("winDestroyWindowsWindow - pWin:%08x XID:0x%x \n", pWin,
d703 1
a703 1
 * winGetWindowID - 
d723 1
a723 1
 * winFindWindow - 
d737 1
a737 1
 * winReorderWindowsMultiWindow - 
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d56 1
a56 1
 winFindWindow(pointer value, XID id, pointer cdata);
d727 1
a727 1
winFindWindow(pointer value, XID id, pointer cdata)
d816 1
a816 1
    dixLookupResourceByType((pointer) &pWin, id, RT_WINDOW, NullClient,
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d489 1
a489 1
    WindowPtr pDaddy;
d519 2
a520 2
    if (winMultiWindowGetTransientFor(pWin, &pDaddy)) {
        if (pDaddy) {
d522 1
a522 1
            if (hFore && (pDaddy != (WindowPtr) GetProp(hFore, WIN_WID_PROP)))
d596 1
a596 1
    SetProp(hWnd, WIN_WID_PROP, (HANDLE) winGetWindowID(pWin));
a810 1
    winScreenInfo *pScreenInfo = NULL;
a825 2
    if (pScreenPriv)
        pScreenInfo = pScreenPriv->pScreenInfo;
d828 1
a828 1
    if (pScreenPriv && pScreenInfo->fInternalWM) {
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d66 5
d78 1
a78 1
        wcx.hIcon = g_hIconX;
d83 1
a83 1
        wcx.hIconSm = g_hSmallIconX;
a486 2
    HICON hIcon;
    HICON hIconSmall;
a578 7

    /* Set application or .XWinrc defined Icons */
    winSelectIcons(pWin, &hIcon, &hIconSmall);
    if (hIcon)
        SendMessage(hWnd, WM_SETICON, ICON_BIG, (LPARAM) hIcon);
    if (hIconSmall)
        SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM) hIconSmall);
@


1.5
log
@Update to xserver 1.11.2
@
text
@d47 1
a47 1
winCreateWindowsWindow (WindowPtr pWin);
d50 1
a50 1
winDestroyWindowsWindow (WindowPtr pWin);
d53 1
a53 1
winUpdateWindowsWindow (WindowPtr pWin);
d56 1
a56 1
winFindWindow (pointer value, XID id, pointer cdata);
d59 2
a60 1
void winInitMultiWindowClass(void)
d62 2
a63 2
  static wATOM atomXWinClass=0;
  WNDCLASSEX wcx;
d65 14
a78 15
  if (atomXWinClass==0)
  {
    /* Setup our window class */
    wcx.cbSize=sizeof(WNDCLASSEX);
    wcx.style = CS_HREDRAW | CS_VREDRAW | (g_fNativeGl ? CS_OWNDC : 0);
    wcx.lpfnWndProc = winTopLevelWindowProc;
    wcx.cbClsExtra = 0;
    wcx.cbWndExtra = 0;
    wcx.hInstance = g_hInstance;
    wcx.hIcon = g_hIconX;
    wcx.hCursor = 0;
    wcx.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wcx.lpszMenuName = NULL;
    wcx.lpszClassName = WINDOW_CLASS_X;
    wcx.hIconSm = g_hSmallIconX;
d81 1
a81 1
    ErrorF ("winCreateWindowsWindow - Creating class: %s\n", WINDOW_CLASS_X);
d84 2
a85 2
    atomXWinClass = RegisterClassEx (&wcx);
  }
d93 1
a93 1
winCreateWindowMultiWindow (WindowPtr pWin)
d95 19
a113 18
  Bool			fResult = TRUE;
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winWindowPriv(pWin);
  winScreenPriv(pScreen);

#if CYGMULTIWINDOW_DEBUG
  winTrace ("winCreateWindowMultiWindow - pWin: %p\n", pWin);
#endif
  
  WIN_UNWRAP(CreateWindow);
  fResult = (*pScreen->CreateWindow) (pWin);
  WIN_WRAP(CreateWindow, winCreateWindowMultiWindow);
  
  /* Initialize some privates values */
  pWinPriv->hRgn = NULL;
  pWinPriv->hWnd = NULL;
  pWinPriv->pScreenPriv = winGetScreenPriv(pWin->drawable.pScreen);
  pWinPriv->fXKilled = FALSE;
d115 1
a115 1
  pWinPriv->fWglUsed = FALSE;
d118 1
a118 1
  return fResult;
a120 1

d126 1
a126 1
winDestroyWindowMultiWindow (WindowPtr pWin)
d128 13
a140 18
  Bool			fResult = TRUE;
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winWindowPriv(pWin);
  winScreenPriv(pScreen);

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winDestroyWindowMultiWindow - pWin: %p\n", pWin);
#endif
  
  WIN_UNWRAP(DestroyWindow); 
  fResult = (*pScreen->DestroyWindow)(pWin);
  WIN_WRAP(DestroyWindow, winDestroyWindowMultiWindow);
  
  /* Flag that the window has been destroyed */
  pWinPriv->fXKilled = TRUE;
  
  /* Kill the MS Windows window associated with this window */
  winDestroyWindowsWindow (pWin); 
d142 7
a148 1
  return fResult;
a150 1

d160 1
a160 1
winPositionWindowMultiWindow (WindowPtr pWin, int x, int y)
d162 10
a171 5
  Bool			fResult = TRUE;
  int		        iX, iY, iWidth, iHeight;
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winWindowPriv(pWin);
  winScreenPriv(pScreen);
a172 3
  HWND hWnd = pWinPriv->hWnd;
  RECT rcNew;
  RECT rcOld;
d174 2
a175 2
  RECT rcClient;
  RECT *lpRc;
d177 2
a178 2
  DWORD dwExStyle;
  DWORD dwStyle;
d181 1
a181 1
  winTrace ("winPositionWindowMultiWindow - pWin: %p\n", pWin);
d183 5
a187 5
  
  WIN_UNWRAP(PositionWindow);
  fResult = (*pScreen->PositionWindow)(pWin, x, y);
  WIN_WRAP(PositionWindow, winPositionWindowMultiWindow);
  
d189 1
a189 2
  ErrorF ("winPositionWindowMultiWindow: (x, y) = (%d, %d)\n",
	  x, y);
d192 2
a193 3
  /* Bail out if the Windows window handle is bad */
  if (!hWnd)
    {
d195 1
a195 1
      ErrorF ("\timmediately return since hWnd is NULL\n");
d197 1
a197 1
      return fResult;
d200 3
a202 3
  /* Get the Windows window style and extended style */
  dwExStyle = GetWindowLongPtr (hWnd, GWL_EXSTYLE);
  dwStyle = GetWindowLongPtr (hWnd, GWL_STYLE);
d204 3
a206 3
  /* Get the X and Y location of the X window */
  iX = pWin->drawable.x + GetSystemMetrics (SM_XVIRTUALSCREEN);
  iY = pWin->drawable.y + GetSystemMetrics (SM_YVIRTUALSCREEN);
d208 3
a210 3
  /* Get the height and width of the X window */
  iWidth = pWin->drawable.width;
  iHeight = pWin->drawable.height;
d212 2
a213 2
  /* Store the origin, height, and width in a rectangle structure */
  SetRect (&rcNew, iX, iY, iX + iWidth, iY + iHeight);
d216 3
a218 3
  lpRc = &rcNew;
  ErrorF ("winPositionWindowMultiWindow - (%d ms)drawable (%d, %d)-(%d, %d)\n",
	  GetTickCount (), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
d221 5
a225 5
  /*
   * Calculate the required size of the Windows window rectangle,
   * given the size of the Windows window client area.
   */
  AdjustWindowRectEx (&rcNew, dwStyle, FALSE, dwExStyle);
d227 2
a228 2
  /* Get a rectangle describing the old Windows window */
  GetWindowRect (hWnd, &rcOld);
d231 6
a236 2
  /* Get a rectangle describing the Windows window client area */
  GetClientRect (hWnd, &rcClient);
d238 7
a244 11
  lpRc = &rcNew;
  ErrorF ("winPositionWindowMultiWindow - (%d ms)rcNew (%d, %d)-(%d, %d)\n",
	  GetTickCount (), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
      
  lpRc = &rcOld;
  ErrorF ("winPositionWindowMultiWindow - (%d ms)rcOld (%d, %d)-(%d, %d)\n",
	  GetTickCount (), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
      
  lpRc = &rcClient;
  ErrorF ("(%d ms)rcClient (%d, %d)-(%d, %d)\n",
	  GetTickCount (), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
d247 2
a248 3
  /* Check if the old rectangle and new rectangle are the same */
  if (!EqualRect (&rcNew, &rcOld))
    {
d250 1
a250 1
      ErrorF ("winPositionWindowMultiWindow - Need to move\n");
d254 2
a255 2
      ErrorF ("\tMoveWindow to (%ld, %ld) - %ldx%ld\n", rcNew.left, rcNew.top,
	      rcNew.right - rcNew.left, rcNew.bottom - rcNew.top);
d257 4
a260 5
      /* Change the position and dimensions of the Windows window */
      MoveWindow (hWnd,
		  rcNew.left, rcNew.top,
		  rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
		  TRUE);
d262 1
a262 2
  else
    {
d264 1
a264 1
      ErrorF ("winPositionWindowMultiWindow - Not need to move\n");
d268 1
a268 1
  return fResult;
a270 1

d276 1
a276 1
winChangeWindowAttributesMultiWindow (WindowPtr pWin, unsigned long mask)
d278 4
a281 3
  Bool			fResult = TRUE;
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winScreenPriv(pScreen);
d284 1
a284 1
  ErrorF ("winChangeWindowAttributesMultiWindow - pWin: %08x\n", pWin);
a285 8
  
  WIN_UNWRAP(ChangeWindowAttributes); 
  fResult = (*pScreen->ChangeWindowAttributes)(pWin, mask);
  WIN_WRAP(ChangeWindowAttributes, winChangeWindowAttributesMultiWindow);
  
  /*
   * NOTE: We do not currently need to do anything here.
   */
d287 9
a295 1
  return fResult;
a297 1

d304 1
a304 1
winUnmapWindowMultiWindow (WindowPtr pWin)
d306 5
a310 18
  Bool			fResult = TRUE;
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winWindowPriv(pWin);
  winScreenPriv(pScreen);

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winUnmapWindowMultiWindow - pWin: %08x\n", pWin);
#endif
  
  WIN_UNWRAP(UnrealizeWindow); 
  fResult = (*pScreen->UnrealizeWindow)(pWin);
  WIN_WRAP(UnrealizeWindow, winUnmapWindowMultiWindow);
  
  /* Flag that the window has been killed */
  pWinPriv->fXKilled = TRUE;
 
  /* Destroy the Windows window associated with this X window */
  winDestroyWindowsWindow (pWin);
d312 15
a326 1
  return fResult;
a328 1

d335 1
a335 1
winMapWindowMultiWindow (WindowPtr pWin)
d337 5
a341 4
  Bool			fResult = TRUE;
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winWindowPriv(pWin);
  winScreenPriv(pScreen);
d344 1
a344 1
  ErrorF ("winMapWindowMultiWindow - pWin: %08x\n", pWin);
a345 7
  
  WIN_UNWRAP(RealizeWindow); 
  fResult = (*pScreen->RealizeWindow)(pWin);
  WIN_WRAP(RealizeWindow, winMapWindowMultiWindow);
  
  /* Flag that this window has not been destroyed */
  pWinPriv->fXKilled = FALSE;
d347 9
a355 2
  /* Refresh/redisplay the Windows window associated with this X window */
  winUpdateWindowsWindow (pWin);
d357 3
a359 3
  /* Update the Windows window's shape */
  winReshapeMultiWindow (pWin);
  winUpdateRgnMultiWindow (pWin);
d361 1
a361 1
  return fResult;
a363 1

d369 1
a369 1
winReparentWindowMultiWindow (WindowPtr pWin, WindowPtr pPriorParent)
d371 8
a378 2
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winScreenPriv(pScreen);
d380 4
a383 2
  winDebug("winReparentMultiWindow - pWin:%08x XID:0x%x, reparent from pWin:%08x XID:0x%x to pWin:%08x XID:0x%x\n",
           pWin, pWin->drawable.id, pPriorParent, pPriorParent->drawable.id, pWin->parent, pWin->parent->drawable.id);
d385 2
a386 7
  WIN_UNWRAP(ReparentWindow);
  if (pScreen->ReparentWindow) 
    (*pScreen->ReparentWindow)(pWin, pPriorParent);
  WIN_WRAP(ReparentWindow, winReparentWindowMultiWindow);
  
  /* Update the Windows window associated with this X window */
  winUpdateWindowsWindow (pWin);
a388 1

d394 1
a394 1
winRestackWindowMultiWindow (WindowPtr pWin, WindowPtr pOldNextSib)
d397 4
a400 4
  WindowPtr		pPrevWin;
  UINT			uFlags;
  HWND			hInsertAfter;
  HWND                  hWnd = NULL;
d402 3
a404 2
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winScreenPriv(pScreen);
d407 1
a407 1
  winTrace ("winRestackMultiWindow - %08x\n", pWin);
d409 6
a414 6
  
   WIN_UNWRAP(RestackWindow);
   if (pScreen->RestackWindow) 
     (*pScreen->RestackWindow)(pWin, pOldNextSib);
   WIN_WRAP(RestackWindow, winRestackWindowMultiWindow);
  
d416 6
a421 6
  /*
   * Calling winReorderWindowsMultiWindow here means our window manager
   * (i.e. Windows Explorer) has initiative to determine Z order.
   */
  if (pWin->nextSib != pOldNextSib)
    winReorderWindowsMultiWindow ();
d423 38
a460 38
  /* Bail out if no window privates or window handle is invalid */
  if (!pWinPriv || !pWinPriv->hWnd)
    return;

  /* Get a pointer to our previous sibling window */
  pPrevWin = pWin->prevSib;

  /*
   * Look for a sibling window with
   * valid privates and window handle
   */
  while (pPrevWin
	 && !winGetWindowPriv(pPrevWin)
	 && !winGetWindowPriv(pPrevWin)->hWnd)
    pPrevWin = pPrevWin->prevSib;
      
  /* Check if we found a valid sibling */
  if (pPrevWin)
    {
      /* Valid sibling - get handle to insert window after */
      hInsertAfter = winGetWindowPriv(pPrevWin)->hWnd;
      uFlags = SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE;
  
      hWnd = GetNextWindow (pWinPriv->hWnd, GW_HWNDPREV);

      do
	{
	  if (GetProp (hWnd, WIN_WINDOW_PROP))
	    {
	      if (hWnd == winGetWindowPriv(pPrevWin)->hWnd)
		{
		  uFlags |= SWP_NOZORDER;
		}
	      break;
	    }
	  hWnd = GetNextWindow (hWnd, GW_HWNDPREV);
	}
      while (hWnd);
d462 3
a464 13
  else
    {
      /* No valid sibling - make this window the top window */
      hInsertAfter = HWND_TOP;
      uFlags = SWP_NOMOVE | SWP_NOSIZE;
    }
      
  /* Perform the restacking operation in Windows */
  SetWindowPos (pWinPriv->hWnd,
		hInsertAfter,
		0, 0,
		0, 0,
		uFlags);
a467 1

d473 1
a473 1
winCreateWindowsWindow (WindowPtr pWin)
d475 124
a598 30
  int                   iX, iY;
  int			iWidth;
  int			iHeight;
  HWND			hWnd;
  HWND			hFore = NULL;
  winWindowPriv(pWin);
  HICON			hIcon;
  HICON			hIconSmall;
  winPrivScreenPtr	pScreenPriv = pWinPriv->pScreenPriv;
  WinXSizeHints         hints;
  WindowPtr		pDaddy;
  DWORD dwStyle, dwExStyle;
  RECT rc;

  winInitMultiWindowClass();

  winDebug("winCreateWindowsTopLevelWindow - pWin:%08x XID:0x%x \n", pWin, pWin->drawable.id);

  iX = pWin->drawable.x + GetSystemMetrics (SM_XVIRTUALSCREEN);
  iY = pWin->drawable.y + GetSystemMetrics (SM_YVIRTUALSCREEN);

  iWidth = pWin->drawable.width;
  iHeight = pWin->drawable.height;

  /* If it's an InputOutput window, and so is going to end up being made visible,
     make sure the window actually ends up somewhere where it will be visible */
  if (pWin->drawable.class != InputOnly)
    {
      if ((iX < GetSystemMetrics (SM_XVIRTUALSCREEN)) || (iX > GetSystemMetrics (SM_CXVIRTUALSCREEN)))
        iX = CW_USEDEFAULT;
d600 1
a600 3
      if ((iY < GetSystemMetrics (SM_YVIRTUALSCREEN)) || (iY > GetSystemMetrics (SM_CYVIRTUALSCREEN)))
        iY = CW_USEDEFAULT;
    }
d602 2
a603 1
  winDebug("winCreateWindowsWindow - %dx%d @@ %dx%d\n", iWidth, iHeight, iX, iY);
d605 2
a606 88
  if (winMultiWindowGetTransientFor (pWin, &pDaddy))
    {
      if (pDaddy)
      {
        hFore = GetForegroundWindow();
        if (hFore && (pDaddy != (WindowPtr)GetProp(hFore, WIN_WID_PROP))) hFore = NULL;
      }
    }
  else
    {
      /* Default positions if none specified */
      if (!winMultiWindowGetWMNormalHints(pWin, &hints))
        hints.flags = 0;
      if (!(hints.flags & (USPosition|PPosition)) &&
          !pWin->overrideRedirect)
      {
        iX = CW_USEDEFAULT;
        iY = CW_USEDEFAULT;
      }
    }

  /* Make it WS_OVERLAPPED in create call since WS_POPUP doesn't support */
  /* CW_USEDEFAULT, change back to popup after creation */
  dwStyle = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
  dwExStyle = WS_EX_TOOLWINDOW;

  /*
     Calculate the window coordinates containing the requested client area,
     being careful to preseve CW_USEDEFAULT
  */
  rc.top = (iY != CW_USEDEFAULT) ? iY : 0;
  rc.left = (iX != CW_USEDEFAULT) ? iX : 0;
  rc.bottom = rc.top + iHeight;
  rc.right = rc.left + iWidth;
  AdjustWindowRectEx(&rc, dwStyle, FALSE, dwExStyle);
  if (iY != CW_USEDEFAULT) iY = rc.top;
  if (iX != CW_USEDEFAULT) iX = rc.left;
  iHeight = rc.bottom - rc.top;
  iWidth = rc.right - rc.left;

  winDebug("winCreateWindowsWindow - %dx%d @@ %dx%d\n", iWidth, iHeight, iX, iY);

  /* Create the window */
  hWnd = CreateWindowExA (dwExStyle,		/* Extended styles */
			  WINDOW_CLASS_X,	/* Class name */
			  WINDOW_TITLE_X,	/* Window name */
			  dwStyle,		/* Styles */
			  iX,			/* Horizontal position */
			  iY,			/* Vertical position */
			  iWidth,		/* Right edge */
			  iHeight,		/* Bottom edge */
			  hFore,		/* Null or Parent window if transient*/
			  (HMENU) NULL,		/* No menu */
			  GetModuleHandle (NULL), /* Instance handle */
			  pWin);		/* ScreenPrivates */
  if (hWnd == NULL)
    {
      ErrorF ("winCreateWindowsWindow - CreateWindowExA () failed: %d\n",
	      (int) GetLastError ());
    }
  pWinPriv->hWnd = hWnd;

  /* Set application or .XWinrc defined Icons */
  winSelectIcons(pWin, &hIcon, &hIconSmall);
  if (hIcon) SendMessage (hWnd, WM_SETICON, ICON_BIG, (LPARAM) hIcon);
  if (hIconSmall) SendMessage (hWnd, WM_SETICON, ICON_SMALL, (LPARAM) hIconSmall);
 
  /* Change style back to popup, already placed... */
  SetWindowLongPtr(hWnd, GWL_STYLE, WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS);
  SetWindowPos (hWnd, 0, 0, 0, 0, 0,
		SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

  /* Adjust the X window to match the window placement we actually got... */
  winAdjustXWindow (pWin, hWnd);

  /* Make sure it gets the proper system menu for a WS_POPUP, too */
  GetSystemMenu (hWnd, TRUE);

  /* Cause any .XWinrc menus to be added in main WNDPROC */
  PostMessage (hWnd, WM_INIT_SYS_MENU, 0, 0);
  
  SetProp (hWnd, WIN_WID_PROP, (HANDLE) winGetWindowID(pWin));

  /* Flag that this Windows window handles its own activation */
  SetProp (hWnd, WIN_NEEDMANAGE_PROP, (HANDLE) 0);

  /* Call engine-specific create window procedure */
  (*pScreenPriv->pwinFinishCreateWindowsWindow) (pWin);
d609 1
a610 1
Bool winInDestroyWindowsWindow = FALSE;
d616 1
a616 1
winDestroyWindowsWindow (WindowPtr pWin)
d618 1
a618 5
  MSG			msg;
  winWindowPriv(pWin);
  BOOL			oldstate = winInDestroyWindowsWindow;
  HICON hIcon;
  HICON hIconSm;
d620 4
a623 1
  winDebug("winDestroyWindowsWindow - pWin:%08x XID:0x%x \n", pWin, pWin->drawable.id);
d625 2
a626 3
  /* Bail out if the Windows window handle is invalid */
  if (pWinPriv->hWnd == NULL)
    return;
d628 3
a630 1
  winInDestroyWindowsWindow = TRUE;
d632 1
a632 3
  /* Store the info we need to destroy after this window is gone */
  hIcon = (HICON)SendMessage(pWinPriv->hWnd, WM_GETICON, ICON_BIG, 0);
  hIconSm = (HICON)SendMessage(pWinPriv->hWnd, WM_GETICON, ICON_SMALL, 0);
d634 3
a636 1
  SetProp (pWinPriv->hWnd, WIN_WINDOW_PROP, NULL);
d638 2
a639 2
  /* Destroy the Windows window */
  DestroyWindow (pWinPriv->hWnd);
d641 2
a642 2
  /* Null our handle to the Window so referencing it will cause an error */
  pWinPriv->hWnd = NULL;
d644 3
a646 3
  /* Destroy any icons we created for this window */
  winDestroyIcon(hIcon);
  winDestroyIcon(hIconSm);
d649 2
a650 2
  /* No longer note WGL used on this window */
  pWinPriv->fWglUsed = FALSE;
d653 5
a657 7
  /* Process all messages on our queue */
  while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
    {
      if (g_hDlgDepthChange == 0 || !IsDialogMessage (g_hDlgDepthChange, &msg))
	{
	  DispatchMessage (&msg);
	}
d660 1
a660 1
  winInDestroyWindowsWindow = oldstate;
d662 1
a662 1
  winDebug("winDestroyWindowsWindow - done\n");
a664 1

d671 1
a671 1
winUpdateWindowsWindow (WindowPtr pWin)
d673 2
a674 2
  winWindowPriv(pWin);
  HWND			hWnd = pWinPriv->hWnd;
d677 1
a677 1
  ErrorF ("winUpdateWindowsWindow\n");
d680 11
a690 15
  /* Check if the Windows window's parents have been destroyed */
  if (pWin->parent != NULL
      && pWin->parent->parent == NULL
      && pWin->mapped)
    {
      /* Create the Windows window if it has been destroyed */
      if (hWnd == NULL)
	{
	  winCreateWindowsWindow (pWin);
	  assert (pWinPriv->hWnd != NULL);
	}

      /* Display the window without activating it */
      if (pWin->drawable.class != InputOnly)
        ShowWindow (pWinPriv->hWnd, SW_SHOWNOACTIVATE);
d692 2
a693 2
      /* Send first paint message */
      UpdateWindow (pWinPriv->hWnd);
d695 4
a698 5
  else if (hWnd != NULL)
    {
      /* Destroy the Windows window if its parents are destroyed */
      winDestroyWindowsWindow (pWin);
      assert (pWinPriv->hWnd == NULL);
d702 1
a702 1
  ErrorF ("-winUpdateWindowsWindow\n");
a705 1

d711 1
a711 1
winGetWindowID (WindowPtr pWin)
d713 5
a717 5
  WindowIDPairRec	wi = {pWin, 0};
  ClientPtr		c = wClient(pWin);
  
  /* */
  FindClientResourcesByType (c, RT_WINDOW, winFindWindow, &wi);
d720 1
a720 1
  ErrorF ("winGetWindowID - Window ID: %d\n", wi.id);
d723 1
a723 1
  return wi.id;
a725 1

d731 1
a731 1
winFindWindow (pointer value, XID id, pointer cdata)
d733 1
a733 1
  WindowIDPairPtr	wi = (WindowIDPairPtr)cdata;
d735 2
a736 3
  if (value == wi->value)
    {
      wi->id = id;
a739 1

d745 1
a745 1
winReorderWindowsMultiWindow (void)
d747 7
a753 7
  HWND hwnd = NULL;
  WindowPtr pWin = NULL;
  WindowPtr pWinSib = NULL;
  XID vlist[2];
  static Bool fRestacking = FALSE; /* Avoid recusive calls to this function */
  DWORD dwCurrentProcessID = GetCurrentProcessId ();
  DWORD dwWindowProcessID = 0;
d756 1
a756 1
  winTrace ("winReorderWindowsMultiWindow\n");
d759 2
a760 3
  if (fRestacking)
    {
      /* It is a recusive call so immediately exit */
d762 2
a763 2
      ErrorF ("winReorderWindowsMultiWindow - "
	      "exit because fRestacking == TRUE\n");
d765 1
a765 1
      return;
d767 1
a767 1
  fRestacking = TRUE;
d769 20
a788 7
  /* Loop through top level Window windows, descending in Z order */
  for ( hwnd = GetTopWindow (NULL);
	hwnd;
	hwnd = GetNextWindow (hwnd, GW_HWNDNEXT) )
    {
      /* Don't take care of other Cygwin/X process's windows */
      GetWindowThreadProcessId (hwnd, &dwWindowProcessID);
d790 4
a793 22
      if ( GetProp (hwnd, WIN_WINDOW_PROP)
	   && (dwWindowProcessID == dwCurrentProcessID)
	   && !IsIconic (hwnd) ) /* ignore minimized windows */
	{
	  pWinSib = pWin;
	  pWin = GetProp (hwnd, WIN_WINDOW_PROP);
	      
	  if (!pWinSib)
	    { /* 1st window - raise to the top */
	      vlist[0] = Above;
		  
	      ConfigureWindow (pWin, CWStackMode, vlist, wClient(pWin));
	    }
	  else
	    { /* 2nd or deeper windows - just below the previous one */
	      vlist[0] = winGetWindowID (pWinSib);
	      vlist[1] = Below;

	      ConfigureWindow (pWin, CWSibling | CWStackMode,
			       vlist, wClient(pWin));
	    }
	}
d796 1
a796 1
  fRestacking = FALSE;
a798 1

d804 1
a804 1
winMinimizeWindow (Window id)
d806 3
a808 2
  WindowPtr		pWin;
  winPrivWinPtr	pWinPriv;
d810 1
a810 1
  win32RootlessWindowPtr pRLWinPriv;
d812 4
a815 4
  HWND hWnd;
  ScreenPtr pScreen = NULL;
  winPrivScreenPtr pScreenPriv = NULL;
  winScreenInfo *pScreenInfo = NULL;
d818 1
a818 1
  ErrorF ("winMinimizeWindow\n");
d821 6
a826 6
  dixLookupResourceByType((pointer) &pWin, id, RT_WINDOW, NullClient, DixUnknownAccess);
  if (!pWin) 
  { 
      ErrorF("%s: NULL pWin. Leaving\n", __FUNCTION__); 
      return; 
  }
d828 5
a832 3
  pScreen = pWin->drawable.pScreen;
  if (pScreen) pScreenPriv = winGetScreenPriv(pScreen);
  if (pScreenPriv) pScreenInfo = pScreenPriv->pScreenInfo;
d835 4
a838 4
  if (pScreenPriv && pScreenInfo->fInternalWM)
    {
      pRLWinPriv  = (win32RootlessWindowPtr) RootlessFrameForWindow (pWin, FALSE);
      hWnd = pRLWinPriv->hWnd;
d840 1
a840 1
  else
d842 1
a842 1
  if (pScreenPriv)
d845 2
a846 2
      pWinPriv = winGetWindowPriv (pWin);
      hWnd = pWinPriv->hWnd;
d849 1
a849 1
  ShowWindow (hWnd, SW_MINIMIZE);
a851 1

d856 1
a856 2
winCopyWindowMultiWindow (WindowPtr pWin, DDXPointRec oldpt,
			  RegionPtr oldRegion)
d858 3
a860 2
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winScreenPriv(pScreen);
d863 1
a863 1
  ErrorF ("CopyWindowMultiWindow\n");
d865 3
a867 3
  WIN_UNWRAP(CopyWindow); 
  (*pScreen->CopyWindow)(pWin, oldpt, oldRegion);
  WIN_WRAP(CopyWindow, winCopyWindowMultiWindow);
a869 1

d874 2
a875 2
winMoveWindowMultiWindow (WindowPtr pWin, int x, int y,
			  WindowPtr pSib, VTKind kind)
d877 3
a879 2
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winScreenPriv(pScreen);
d882 1
a882 1
  ErrorF ("MoveWindowMultiWindow to (%d, %d)\n", x, y);
d885 3
a887 3
  WIN_UNWRAP(MoveWindow); 
  (*pScreen->MoveWindow)(pWin, x, y, pSib, kind);
  WIN_WRAP(MoveWindow, winMoveWindowMultiWindow);
a889 1

d894 2
a895 2
winResizeWindowMultiWindow (WindowPtr pWin, int x, int y, unsigned int w,
			    unsigned int h, WindowPtr pSib)
d897 3
a899 2
  ScreenPtr		pScreen = pWin->drawable.pScreen;
  winScreenPriv(pScreen);
d902 1
a902 1
  ErrorF ("ResizeWindowMultiWindow to (%d, %d) - %dx%d\n", x, y, w, h);
d904 3
a906 3
  WIN_UNWRAP(ResizeWindow); 
  (*pScreen->ResizeWindow)(pWin, x, y, w, h, pSib);
  WIN_WRAP(ResizeWindow, winResizeWindowMultiWindow);
a908 1

d920 1
a920 1
winAdjustXWindow (WindowPtr pWin, HWND hwnd)
d922 6
a927 6
  RECT rcDraw; /* Rect made from pWin->drawable to be adjusted */
  RECT rcWin;  /* The source: WindowRect from hwnd */
  DrawablePtr pDraw;
  XID vlist[4];
  LONG dX, dY, dW, dH, x, y;
  DWORD dwStyle, dwExStyle;
d931 1
a931 1
  
d933 1
a933 1
  ErrorF ("winAdjustXWindow\n");
d936 1
a936 2
  if (IsIconic (hwnd))
    {
d938 1
a938 1
      ErrorF ("\timmediately return because the window is iconized\n");
d940 15
a954 15
      /*
       * If the Windows window is minimized, its WindowRect has
       * meaningless values so we don't adjust X window to it.
       */
      vlist[0] = 0;
      vlist[1] = 0;
      return ConfigureWindow (pWin, CWX | CWY, vlist, wClient(pWin));
    }
  
  pDraw = &pWin->drawable;

  /* Calculate the window rect from the drawable */
  x = pDraw->x + GetSystemMetrics (SM_XVIRTUALSCREEN);
  y = pDraw->y + GetSystemMetrics (SM_YVIRTUALSCREEN);
  SetRect (&rcDraw, x, y, x + pDraw->width, y + pDraw->height);
d956 3
a958 3
          winDebug("\tDrawable extend {%d, %d, %d, %d}, {%d, %d}\n", 
              rcDraw.left, rcDraw.top, rcDraw.right, rcDraw.bottom,
              rcDraw.right - rcDraw.left, rcDraw.bottom - rcDraw.top);
d960 2
a961 2
  dwExStyle = GetWindowLongPtr (hwnd, GWL_EXSTYLE);
  dwStyle = GetWindowLongPtr (hwnd, GWL_STYLE);
d963 1
a963 1
          winDebug("\tWindowStyle: %08x %08x\n", dwStyle, dwExStyle);
d965 1
a965 1
  AdjustWindowRectEx (&rcDraw, dwStyle, FALSE, dwExStyle);
d967 2
a968 2
  /* The source of adjust */
  GetWindowRect (hwnd, &rcWin);
d970 39
a1008 39
          winDebug("\tWindow extend {%d, %d, %d, %d}, {%d, %d}\n", 
              rcWin.left, rcWin.top, rcWin.right, rcWin.bottom,
              rcWin.right - rcWin.left, rcWin.bottom - rcWin.top);
          winDebug("\tDraw extend {%d, %d, %d, %d}, {%d, %d}\n", 
              rcDraw.left, rcDraw.top, rcDraw.right, rcDraw.bottom,
              rcDraw.right - rcDraw.left, rcDraw.bottom - rcDraw.top);
#endif

  if (EqualRect (&rcDraw, &rcWin)) {
    /* Bail if no adjust is needed */
#if CYGWINDOWING_DEBUG
    ErrorF ("\treturn because already adjusted\n");
#endif
    return 0;
  }
  
  /* Calculate delta values */
  dX = rcWin.left - rcDraw.left;
  dY = rcWin.top - rcDraw.top;
  dW = WIDTH(rcWin) - WIDTH(rcDraw);
  dH = HEIGHT(rcWin) - HEIGHT(rcDraw);

  /*
   * Adjust.
   * We may only need to move (vlist[0] and [1]), or only resize
   * ([2] and [3]) but currently we set all the parameters and leave
   * the decision to ConfigureWindow.  The reason is code simplicity.
  */
  vlist[0] = pDraw->x + dX - wBorderWidth(pWin);
  vlist[1] = pDraw->y + dY - wBorderWidth(pWin);
  vlist[2] = pDraw->width + dW;
  vlist[3] = pDraw->height + dH;
#if CYGWINDOWING_DEBUG
  ErrorF ("\tConfigureWindow to (%ld, %ld) - %ldx%ld\n", vlist[0], vlist[1],
	  vlist[2], vlist[3]);
#endif
  return ConfigureWindow (pWin, CWX | CWY | CWWidth | CWHeight,
			  vlist, wClient(pWin));
  
a1011 1

@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a40 10
#include "winprefs.h"

/*
 * External global variables
 */

extern HICON		g_hIconX;
extern HICON		g_hSmallIconX;
extern HWND		g_hDlgDepthChange;
extern Bool             g_fNativeGl;
d113 4
a116 1
 
d378 2
a379 3
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winReparentMultiWindow - pWin: %08x\n", pWin);
#endif
d498 2
d503 1
a503 3
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winCreateWindowsWindow - pWin: %08x\n", pWin);
#endif
d511 10
a520 3
  /* ensure window actually ends up somewhere visible */
  if (iX > GetSystemMetrics (SM_CXVIRTUALSCREEN))
    iX = CW_USEDEFAULT;
d522 1
a522 2
  if (iY > GetSystemMetrics (SM_CYVIRTUALSCREEN))
    iY = CW_USEDEFAULT;
d545 21
d567 1
a567 3
  /* Make it OVERLAPPED in create call since WS_POPUP doesn't support */
  /* CW_USEDEFAULT, change back to popup after creation */
  hWnd = CreateWindowExA (WS_EX_TOOLWINDOW,	/* Extended styles */
d570 1
a570 1
			  WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
d573 1
a573 1
			  iWidth,		/* Right edge */ 
d595 4
d626 4
a629 4
  
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winDestroyWindowsWindow\n");
#endif
d637 4
d642 1
d649 9
d669 1
a669 3
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("-winDestroyWindowsWindow\n");
#endif
d701 2
a702 1
      ShowWindow (pWinPriv->hWnd, SW_SHOWNOACTIVATE);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d50 1
d78 1
a78 1
    wcx.style = CS_HREDRAW | CS_VREDRAW;
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d3 1
d32 1
d47 3
a49 3
extern HWND			g_hDlgDepthChange;

extern void winSelectIcons(WindowPtr pWin, HICON *pIcon, HICON *pSmallIcon);
d67 5
a71 3
/*
 * Constant defines
 */
d73 15
a87 1
#define MOUSE_POLLING_INTERVAL		500
d89 3
d93 3
a95 12
/*
 * Macros
 */

#define SubSend(pWin) \
    ((pWin->eventMask|wOtherEventMasks(pWin)) & SubstructureNotifyMask)

#define StrSend(pWin) \
    ((pWin->eventMask|wOtherEventMasks(pWin)) & StructureNotifyMask)

#define SubStrSend(pWin,pParent) (StrSend(pWin) || SubSend(pParent))

a289 1
  winWindowPriv(pWin);
a381 1
  winWindowPriv(pWin);
d405 1
d410 1
a411 1
  winWindowPriv(pWin);
d498 1
a498 1
  WNDCLASSEX		wc;
a501 4
#define CLASS_NAME_LENGTH 512
  char                  pszClass[CLASS_NAME_LENGTH], pszWindowID[12];
  char                  *res_name, *res_class, *res_role;
  static int		s_iWindowID = 0;
d504 3
a514 11
  /* Default positions if none specified */
  if (!winMultiWindowGetWMNormalHints(pWin, &hints))
    hints.flags = 0;
  if ( !(hints.flags & (USPosition|PPosition)) &&
       !winMultiWindowGetTransientFor (pWin, NULL) &&
       !pWin->overrideRedirect )
    {
      iX = CW_USEDEFAULT;
      iY = CW_USEDEFAULT;
    }

d518 16
a533 6
  winSelectIcons(pWin, &hIcon, &hIconSmall); 

  /* Set standard class name prefix so we can identify window easily */
  strncpy (pszClass, WINDOW_CLASS_X, sizeof(pszClass));

  if (winMultiWindowGetClassHint (pWin, &res_name, &res_class))
d535 9
a543 19
      strncat (pszClass, "-", 1);
      strncat (pszClass, res_name, CLASS_NAME_LENGTH - strlen (pszClass));
      strncat (pszClass, "-", 1);
      strncat (pszClass, res_class, CLASS_NAME_LENGTH - strlen (pszClass));
      
      /* Check if a window class is provided by the WM_WINDOW_ROLE property,
       * if not use the WM_CLASS information.
       * For further information see:
       * http://tronche.com/gui/x/icccm/sec-5.html
       */ 
      if (winMultiWindowGetWindowRole (pWin, &res_role) )
	{
	  strcat (pszClass, "-");
	  strcat (pszClass, res_role);
	  free (res_role);
	}

      free (res_name);
      free (res_class);
a545 24
  /* Add incrementing window ID to make unique class name */
  snprintf (pszWindowID, sizeof(pszWindowID), "-%x", s_iWindowID++);
  pszWindowID[sizeof(pszWindowID)-1] = 0;
  strcat (pszClass, pszWindowID);

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winCreateWindowsWindow - Creating class: %s\n", pszClass);
#endif

  /* Setup our window class */
  wc.cbSize = sizeof(wc);
  wc.style = CS_HREDRAW | CS_VREDRAW;
  wc.lpfnWndProc = winTopLevelWindowProc;
  wc.cbClsExtra = 0;
  wc.cbWndExtra = 0;
  wc.hInstance = g_hInstance;
  wc.hIcon = hIcon;
  wc.hIconSm = hIconSmall;
  wc.hCursor = 0;
  wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
  wc.lpszMenuName = NULL;
  wc.lpszClassName = pszClass;
  RegisterClassEx (&wc);

d550 1
a550 1
			  pszClass,		/* Class name */
d557 1
a557 1
			  (HWND) NULL,		/* No parent or owner window */
d566 6
d574 1
a574 1
  SetWindowLong (hWnd, GWL_STYLE, WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS);
a579 2
  pWinPriv->hWnd = hWnd;

d583 1
a583 1
  SetProp (pWinPriv->hWnd, WIN_WID_PROP, (HANDLE) winGetWindowID(pWin));
d586 1
a586 1
  SetProp (pWinPriv->hWnd, WIN_NEEDMANAGE_PROP, (HANDLE) 0);
a602 5
  HICON			hiconClass;
  HICON			hiconSmClass;
  HMODULE		hInstance;
  int			iReturn;
  char			pszClass[512];
a614 6
  /* Store the info we need to destroy after this window is gone */
  hInstance = (HINSTANCE) GetClassLong (pWinPriv->hWnd, GCL_HMODULE);
  hiconClass = (HICON) GetClassLong (pWinPriv->hWnd, GCL_HICON);
  hiconSmClass = (HICON) GetClassLong (pWinPriv->hWnd, GCL_HICONSM);
  iReturn = GetClassName (pWinPriv->hWnd, pszClass, 512);
  
a630 16
  /* Only if we were able to get the name */
  if (iReturn)
    { 
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winDestroyWindowsWindow - Unregistering %s: ", pszClass);
#endif
      iReturn = UnregisterClass (pszClass, hInstance);
      
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winDestroyWindowsWindow - %d Deleting Icon: ", iReturn);
#endif
      
      winDestroyIcon(hiconClass);
      winDestroyIcon(hiconSmClass);
    }

d809 1
a809 1
  pWin = LookupIDByType (id, RT_WINDOW);
a846 1
  winWindowPriv(pWin);
a865 1
  winWindowPriv(pWin);
a885 1
  winWindowPriv(pWin);
@


1.1
log
@Initial revision
@
text
@a354 1
#ifdef SHAPE
a357 1
#endif
a982 2
       * Instead we put the X window to the bottom in Z order to
       * be obscured by other windows.
d984 3
a986 2
      vlist[0] = Below;
      return ConfigureWindow (pWin, CWStackMode, vlist, wClient(pWin));
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@d985 2
d988 2
a989 3
      vlist[0] = 0;
      vlist[1] = 0;
      return ConfigureWindow (pWin, CWX | CWY, vlist, wClient(pWin));
@

