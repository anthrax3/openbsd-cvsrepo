head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.21;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.21;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.03.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *Copyright (C) Colin Harrison 2005-2009
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Kensuke Matsuzaki
 *              Colin Harrison
 */

/* X headers */
#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#ifdef __CYGWIN__
#include <sys/select.h>
#endif
#include <fcntl.h>
#include <setjmp.h>
#define HANDLE void *
#include <pthread.h>
#undef HANDLE
#include <X11/X.h>
#include <X11/Xatom.h>
#include <X11/Xlib.h>
#include <X11/Xlocale.h>
#include <X11/Xproto.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <X11/Xwindows.h>

/* Local headers */
#include "winwindow.h"
#include "winprefs.h"
#include "window.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "winglobals.h"
#include "windisplay.h"

#ifdef XWIN_MULTIWINDOWEXTWM
#include <X11/extensions/windowswmstr.h>
#else
/* We need the native HWND atom for intWM, so for consistency use the
   same name as extWM would if we were building with enabled... */
#define WINDOWSWM_NATIVE_HWND "_WINDOWSWM_NATIVE_HWND"
#endif

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 255
#endif

extern void winDebug(const char *format, ...);
extern void winReshapeMultiWindow(WindowPtr pWin);
extern void winUpdateRgnMultiWindow(WindowPtr pWin);

#ifndef CYGDEBUG
#define CYGDEBUG NO
#endif

/*
 * Constant defines
 */

#define WIN_CONNECT_RETRIES	5
#define WIN_CONNECT_DELAY	5
#ifdef HAS_DEVWINDOWS
#define WIN_MSG_QUEUE_FNAME	"/dev/windows"
#endif
#define WIN_JMP_OKAY		0
#define WIN_JMP_ERROR_IO	2

/*
 * Local structures
 */

typedef struct _WMMsgNodeRec {
    winWMMessageRec msg;
    struct _WMMsgNodeRec *pNext;
} WMMsgNodeRec, *WMMsgNodePtr;

typedef struct _WMMsgQueueRec {
    struct _WMMsgNodeRec *pHead;
    struct _WMMsgNodeRec *pTail;
    pthread_mutex_t pmMutex;
    pthread_cond_t pcNotEmpty;
    int nQueueSize;
} WMMsgQueueRec, *WMMsgQueuePtr;

typedef struct _WMInfo {
    Display *pDisplay;
    WMMsgQueueRec wmMsgQueue;
    Atom atmWmProtos;
    Atom atmWmDelete;
    Atom atmWmTakeFocus;
    Atom atmPrivMap;
    Bool fAllowOtherWM;
} WMInfoRec, *WMInfoPtr;

typedef struct _WMProcArgRec {
    DWORD dwScreen;
    WMInfoPtr pWMInfo;
    pthread_mutex_t *ppmServerStarted;
} WMProcArgRec, *WMProcArgPtr;

typedef struct _XMsgProcArgRec {
    Display *pDisplay;
    DWORD dwScreen;
    WMInfoPtr pWMInfo;
    pthread_mutex_t *ppmServerStarted;
    HWND hwndScreen;
} XMsgProcArgRec, *XMsgProcArgPtr;

/*
 * Prototypes for local functions
 */

static void
 PushMessage(WMMsgQueuePtr pQueue, WMMsgNodePtr pNode);

static WMMsgNodePtr PopMessage(WMMsgQueuePtr pQueue, WMInfoPtr pWMInfo);

static Bool
 InitQueue(WMMsgQueuePtr pQueue);

static void
 GetWindowName(Display * pDpy, Window iWin, char **ppWindowName);

static int
 SendXMessage(Display * pDisplay, Window iWin, Atom atmType, long nData);

static void
 UpdateName(WMInfoPtr pWMInfo, Window iWindow);

static void *winMultiWindowWMProc(void *pArg);

static int
 winMultiWindowWMErrorHandler(Display * pDisplay, XErrorEvent * pErr);

static int
 winMultiWindowWMIOErrorHandler(Display * pDisplay);

static void *winMultiWindowXMsgProc(void *pArg);

static int
 winMultiWindowXMsgProcErrorHandler(Display * pDisplay, XErrorEvent * pErr);

static int
 winMultiWindowXMsgProcIOErrorHandler(Display * pDisplay);

static int
 winRedirectErrorHandler(Display * pDisplay, XErrorEvent * pErr);

static void
 winInitMultiWindowWM(WMInfoPtr pWMInfo, WMProcArgPtr pProcArg);

#if 0
static void
 PreserveWin32Stack(WMInfoPtr pWMInfo, Window iWindow, UINT direction);
#endif

static Bool

CheckAnotherWindowManager(Display * pDisplay, DWORD dwScreen,
                          Bool fAllowOtherWM);

static void
 winApplyHints(Display * pDisplay, Window iWindow, HWND hWnd, HWND * zstyle);

void
 winUpdateWindowPosition(HWND hWnd, HWND * zstyle);

/*
 * Local globals
 */

static jmp_buf g_jmpWMEntry;
static XIOErrorHandler g_winMultiWindowWMOldIOErrorHandler;
static pthread_t g_winMultiWindowWMThread;
static jmp_buf g_jmpXMsgProcEntry;
static XIOErrorHandler g_winMultiWindowXMsgProcOldIOErrorHandler;
static pthread_t g_winMultiWindowXMsgProcThread;
static Bool g_shutdown = FALSE;
static Bool redirectError = FALSE;
static Bool g_fAnotherWMRunning = FALSE;

/*
 * PushMessage - Push a message onto the queue
 */

static void
PushMessage(WMMsgQueuePtr pQueue, WMMsgNodePtr pNode)
{

    /* Lock the queue mutex */
    pthread_mutex_lock(&pQueue->pmMutex);

    pNode->pNext = NULL;

    if (pQueue->pTail != NULL) {
        pQueue->pTail->pNext = pNode;
    }
    pQueue->pTail = pNode;

    if (pQueue->pHead == NULL) {
        pQueue->pHead = pNode;
    }

#if 0
    switch (pNode->msg.msg) {
    case WM_WM_MOVE:
        ErrorF("\tWM_WM_MOVE\n");
        break;
    case WM_WM_SIZE:
        ErrorF("\tWM_WM_SIZE\n");
        break;
    case WM_WM_RAISE:
        ErrorF("\tWM_WM_RAISE\n");
        break;
    case WM_WM_LOWER:
        ErrorF("\tWM_WM_LOWER\n");
        break;
    case WM_WM_MAP:
        ErrorF("\tWM_WM_MAP\n");
        break;
    case WM_WM_MAP2:
        ErrorF("\tWM_WM_MAP2\n");
        break;
    case WM_WM_MAP3:
        ErrorF("\tWM_WM_MAP3\n");
        break;
    case WM_WM_UNMAP:
        ErrorF("\tWM_WM_UNMAP\n");
        break;
    case WM_WM_KILL:
        ErrorF("\tWM_WM_KILL\n");
        break;
    case WM_WM_ACTIVATE:
        ErrorF("\tWM_WM_ACTIVATE\n");
        break;
    default:
        ErrorF("\tUnknown Message.\n");
        break;
    }
#endif

    /* Increase the count of elements in the queue by one */
    ++(pQueue->nQueueSize);

    /* Release the queue mutex */
    pthread_mutex_unlock(&pQueue->pmMutex);

    /* Signal that the queue is not empty */
    pthread_cond_signal(&pQueue->pcNotEmpty);
}

#if CYGMULTIWINDOW_DEBUG
/*
 * QueueSize - Return the size of the queue
 */

static int
QueueSize(WMMsgQueuePtr pQueue)
{
    WMMsgNodePtr pNode;
    int nSize = 0;

    /* Loop through all elements in the queue */
    for (pNode = pQueue->pHead; pNode != NULL; pNode = pNode->pNext)
        ++nSize;

    return nSize;
}
#endif

/*
 * PopMessage - Pop a message from the queue
 */

static WMMsgNodePtr
PopMessage(WMMsgQueuePtr pQueue, WMInfoPtr pWMInfo)
{
    WMMsgNodePtr pNode;

    /* Lock the queue mutex */
    pthread_mutex_lock(&pQueue->pmMutex);

    /* Wait for --- */
    while (pQueue->pHead == NULL) {
        pthread_cond_wait(&pQueue->pcNotEmpty, &pQueue->pmMutex);
    }

    pNode = pQueue->pHead;
    if (pQueue->pHead != NULL) {
        pQueue->pHead = pQueue->pHead->pNext;
    }

    if (pQueue->pTail == pNode) {
        pQueue->pTail = NULL;
    }

    /* Drop the number of elements in the queue by one */
    --(pQueue->nQueueSize);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("Queue Size %d %d\n", pQueue->nQueueSize, QueueSize(pQueue));
#endif

    /* Release the queue mutex */
    pthread_mutex_unlock(&pQueue->pmMutex);

    return pNode;
}

#if 0
/*
 * HaveMessage -
 */

static Bool
HaveMessage(WMMsgQueuePtr pQueue, UINT msg, Window iWindow)
{
    WMMsgNodePtr pNode;

    for (pNode = pQueue->pHead; pNode != NULL; pNode = pNode->pNext) {
        if (pNode->msg.msg == msg && pNode->msg.iWindow == iWindow)
            return True;
    }

    return False;
}
#endif

/*
 * InitQueue - Initialize the Window Manager message queue
 */

static
    Bool
InitQueue(WMMsgQueuePtr pQueue)
{
    /* Check if the pQueue pointer is NULL */
    if (pQueue == NULL) {
        ErrorF("InitQueue - pQueue is NULL.  Exiting.\n");
        return FALSE;
    }

    /* Set the head and tail to NULL */
    pQueue->pHead = NULL;
    pQueue->pTail = NULL;

    /* There are no elements initially */
    pQueue->nQueueSize = 0;

#if CYGMULTIWINDOW_DEBUG
    winDebug("InitQueue - Queue Size %d %d\n", pQueue->nQueueSize,
             QueueSize(pQueue));
#endif

    winDebug("InitQueue - Calling pthread_mutex_init\n");

    /* Create synchronization objects */
    pthread_mutex_init(&pQueue->pmMutex, NULL);

    winDebug("InitQueue - pthread_mutex_init returned\n");
    winDebug("InitQueue - Calling pthread_cond_init\n");

    pthread_cond_init(&pQueue->pcNotEmpty, NULL);

    winDebug("InitQueue - pthread_cond_init returned\n");

    return TRUE;
}

static
char *
Xutf8TextPropertyToString(Display * pDisplay, XTextProperty * xtp)
{
    int nNum;
    char **ppList;
    char *pszReturnData;

    if (Xutf8TextPropertyToTextList(pDisplay, xtp, &ppList, &nNum) >= Success &&
        nNum > 0 && *ppList) {
        int i;
        int iLen = 0;

        for (i = 0; i < nNum; i++)
            iLen += strlen(ppList[i]);
        pszReturnData = malloc(iLen + 1);
        pszReturnData[0] = '\0';
        for (i = 0; i < nNum; i++)
            strcat(pszReturnData, ppList[i]);
        if (ppList)
            XFreeStringList(ppList);
    }
    else {
        pszReturnData = malloc(1);
        pszReturnData[0] = '\0';
    }

    return pszReturnData;
}

/*
 * GetWindowName - Retrieve the title of an X Window
 */

static void
GetWindowName(Display * pDisplay, Window iWin, char **ppWindowName)
{
    int nResult;
    XTextProperty xtpWindowName;
    XTextProperty xtpClientMachine;
    char *pszWindowName;
    char *pszClientMachine;
    char hostname[HOST_NAME_MAX + 1];

#if CYGMULTIWINDOW_DEBUG
    ErrorF("GetWindowName\n");
#endif

    /* Intialize ppWindowName to NULL */
    *ppWindowName = NULL;

    /* Try to get window name */
    nResult = XGetWMName(pDisplay, iWin, &xtpWindowName);
    if (!nResult || !xtpWindowName.value || !xtpWindowName.nitems) {
#if CYGMULTIWINDOW_DEBUG
        ErrorF("GetWindowName - XGetWMName failed.  No name.\n");
#endif
        return;
    }

    pszWindowName = Xutf8TextPropertyToString(pDisplay, &xtpWindowName);
    XFree(xtpWindowName.value);

    if (g_fHostInTitle) {
        /* Try to get client machine name */
        nResult = XGetWMClientMachine(pDisplay, iWin, &xtpClientMachine);
        if (nResult && xtpClientMachine.value && xtpClientMachine.nitems) {
            pszClientMachine =
                Xutf8TextPropertyToString(pDisplay, &xtpClientMachine);
            XFree(xtpClientMachine.value);

            /*
               If we have a client machine name
               and it's not the local host name
               and it's not already in the window title...
             */
            if (strlen(pszClientMachine) &&
                !gethostname(hostname, HOST_NAME_MAX + 1) &&
                strcmp(hostname, pszClientMachine) &&
                (strstr(pszWindowName, pszClientMachine) == 0)) {
                /* ... add '@@<clientmachine>' to end of window name */
                *ppWindowName =
                    malloc(strlen(pszWindowName) +
                           strlen(pszClientMachine) + 2);
                strcpy(*ppWindowName, pszWindowName);
                strcat(*ppWindowName, "@@");
                strcat(*ppWindowName, pszClientMachine);

                free(pszWindowName);
                free(pszClientMachine);

                return;
            }
        }
    }

    /* otherwise just return the window name */
    *ppWindowName = pszWindowName;
}

/*
 * Does the client support the specified WM_PROTOCOLS protocol?
 */

static Bool
IsWmProtocolAvailable(Display * pDisplay, Window iWindow, Atom atmProtocol)
{
  int i, n, found = 0;
  Atom *protocols;

  if (XGetWMProtocols(pDisplay, iWindow, &protocols, &n)) {
    for (i = 0; i < n; ++i)
      if (protocols[i] == atmProtocol)
        ++found;

    XFree(protocols);
  }

  return found > 0;
}

/*
 * Send a message to the X server from the WM thread
 */

static int
SendXMessage(Display * pDisplay, Window iWin, Atom atmType, long nData)
{
    XEvent e;

    /* Prepare the X event structure */
    e.type = ClientMessage;
    e.xclient.window = iWin;
    e.xclient.message_type = atmType;
    e.xclient.format = 32;
    e.xclient.data.l[0] = nData;
    e.xclient.data.l[1] = CurrentTime;

    /* Send the event to X */
    return XSendEvent(pDisplay, iWin, False, NoEventMask, &e);
}

/*
 * See if we can get the stored HWND for this window...
 */
static HWND
getHwnd(WMInfoPtr pWMInfo, Window iWindow)
{
    Atom atmType;
    int fmtRet;
    unsigned long items, remain;
    HWND *retHwnd, hWnd = NULL;

    if (XGetWindowProperty(pWMInfo->pDisplay,
                           iWindow,
                           pWMInfo->atmPrivMap,
                           0,
                           sizeof(HWND)/4,
                           False,
                           XA_INTEGER,
                           &atmType,
                           &fmtRet,
                           &items,
                           &remain, (unsigned char **) &retHwnd) == Success) {
        if (retHwnd) {
            hWnd = *retHwnd;
            XFree(retHwnd);
        }
    }

    /* Some sanity checks */
    if (!hWnd)
        return NULL;
    if (!IsWindow(hWnd))
        return NULL;

    return hWnd;
}

/*
 * Updates the name of a HWND according to its X WM_NAME property
 */

static void
UpdateName(WMInfoPtr pWMInfo, Window iWindow)
{
    HWND hWnd;
    XWindowAttributes attr;

    hWnd = getHwnd(pWMInfo, iWindow);
    if (!hWnd)
        return;

    /* If window isn't override-redirect */
    XGetWindowAttributes(pWMInfo->pDisplay, iWindow, &attr);
    if (!attr.override_redirect) {
        char *pszWindowName;

        /* Get the X windows window name */
        GetWindowName(pWMInfo->pDisplay, iWindow, &pszWindowName);

        if (pszWindowName) {
            /* Convert from UTF-8 to wide char */
            int iLen =
                MultiByteToWideChar(CP_UTF8, 0, pszWindowName, -1, NULL, 0);
            wchar_t *pwszWideWindowName =
                malloc(sizeof(wchar_t)*(iLen + 1));
            MultiByteToWideChar(CP_UTF8, 0, pszWindowName, -1,
                                pwszWideWindowName, iLen);

            /* Set the Windows window name */
            SetWindowTextW(hWnd, pwszWideWindowName);

            free(pwszWideWindowName);
            free(pszWindowName);
        }
    }
}

/*
 * Updates the icon of a HWND according to its X icon properties
 */

static void
UpdateIcon(WMInfoPtr pWMInfo, Window iWindow)
{
    HWND hWnd;
    HICON hIconNew = NULL;
    XWindowAttributes attr;

    hWnd = getHwnd(pWMInfo, iWindow);
    if (!hWnd)
        return;

    /* If window isn't override-redirect */
    XGetWindowAttributes(pWMInfo->pDisplay, iWindow, &attr);
    if (!attr.override_redirect) {
        XClassHint class_hint = { 0, 0 };
        char *window_name = 0;

        if (XGetClassHint(pWMInfo->pDisplay, iWindow, &class_hint)) {
            XFetchName(pWMInfo->pDisplay, iWindow, &window_name);

            hIconNew =
                (HICON) winOverrideIcon(class_hint.res_name,
                                        class_hint.res_class, window_name);

            if (class_hint.res_name)
                XFree(class_hint.res_name);
            if (class_hint.res_class)
                XFree(class_hint.res_class);
            if (window_name)
                XFree(window_name);
        }
    }

    winUpdateIcon(hWnd, pWMInfo->pDisplay, iWindow, hIconNew);
}

/*
 * Updates the style of a HWND according to its X style properties
 */

static void
UpdateStyle(WMInfoPtr pWMInfo, Window iWindow)
{
    HWND hWnd;
    HWND zstyle = HWND_NOTOPMOST;
    UINT flags;

    hWnd = getHwnd(pWMInfo, iWindow);
    if (!hWnd)
        return;

    /* Determine the Window style, which determines borders and clipping region... */
    winApplyHints(pWMInfo->pDisplay, iWindow, hWnd, &zstyle);
    winUpdateWindowPosition(hWnd, &zstyle);

    /* Apply the updated window style, without changing it's show or activation state */
    flags = SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE;
    if (zstyle == HWND_NOTOPMOST)
        flags |= SWP_NOZORDER | SWP_NOOWNERZORDER;
    SetWindowPos(hWnd, NULL, 0, 0, 0, 0, flags);

    /*
       Use the WS_EX_TOOLWINDOW style to remove window from Alt-Tab window switcher

       According to MSDN, this is supposed to remove the window from the taskbar as well,
       if we SW_HIDE before changing the style followed by SW_SHOW afterwards.

       But that doesn't seem to work reliably, and causes the window to flicker, so use
       the iTaskbarList interface to tell the taskbar to show or hide this window.
     */
    winShowWindowOnTaskbar(hWnd,
                           (GetWindowLongPtr(hWnd, GWL_EXSTYLE) &
                            WS_EX_APPWINDOW) ? TRUE : FALSE);
}

#if 0
/*
 * Fix up any differences between the X11 and Win32 window stacks
 * starting at the window passed in
 */
static void
PreserveWin32Stack(WMInfoPtr pWMInfo, Window iWindow, UINT direction)
{
    HWND hWnd;
    DWORD myWinProcID, winProcID;
    Window xWindow;
    WINDOWPLACEMENT wndPlace;

    hWnd = getHwnd(pWMInfo, iWindow);
    if (!hWnd)
        return;

    GetWindowThreadProcessId(hWnd, &myWinProcID);
    hWnd = GetNextWindow(hWnd, direction);

    while (hWnd) {
        GetWindowThreadProcessId(hWnd, &winProcID);
        if (winProcID == myWinProcID) {
            wndPlace.length = sizeof(WINDOWPLACEMENT);
            GetWindowPlacement(hWnd, &wndPlace);
            if (!(wndPlace.showCmd == SW_HIDE ||
                  wndPlace.showCmd == SW_MINIMIZE)) {
                xWindow = (Window) GetProp(hWnd, WIN_WID_PROP);
                if (xWindow) {
                    if (direction == GW_HWNDPREV)
                        XRaiseWindow(pWMInfo->pDisplay, xWindow);
                    else
                        XLowerWindow(pWMInfo->pDisplay, xWindow);
                }
            }
        }
        hWnd = GetNextWindow(hWnd, direction);
    }
}
#endif                          /* PreserveWin32Stack */

/*
 * winMultiWindowWMProc
 */

static void *
winMultiWindowWMProc(void *pArg)
{
    WMProcArgPtr pProcArg = (WMProcArgPtr) pArg;
    WMInfoPtr pWMInfo = pProcArg->pWMInfo;

    /* Initialize the Window Manager */
    winInitMultiWindowWM(pWMInfo, pProcArg);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("winMultiWindowWMProc ()\n");
#endif

    /* Loop until we explicitly break out */
    for (;;) {
        WMMsgNodePtr pNode;

        if (g_fAnotherWMRunning) {      /* Another Window manager exists. */
            Sleep(1000);
            continue;
        }

        /* Pop a message off of our queue */
        pNode = PopMessage(&pWMInfo->wmMsgQueue, pWMInfo);
        if (pNode == NULL) {
            /* Bail if PopMessage returns without a message */
            /* NOTE: Remember that PopMessage is a blocking function. */
            ErrorF("winMultiWindowWMProc - Queue is Empty?  Exiting.\n");
            pthread_exit(NULL);
        }

#if CYGMULTIWINDOW_DEBUG
        ErrorF("winMultiWindowWMProc - MSG: %d ID: %d\n",
               (int) pNode->msg.msg, (int) pNode->msg.dwID);
#endif

        /* Branch on the message type */
        switch (pNode->msg.msg) {
#if 0
        case WM_WM_MOVE:
            ErrorF("\tWM_WM_MOVE\n");
            break;

        case WM_WM_SIZE:
            ErrorF("\tWM_WM_SIZE\n");
            break;
#endif

        case WM_WM_RAISE:
#if CYGMULTIWINDOW_DEBUG
            ErrorF("\tWM_WM_RAISE\n");
#endif
            /* Raise the window */
            XRaiseWindow(pWMInfo->pDisplay, pNode->msg.iWindow);
#if 0
            PreserveWin32Stack(pWMInfo, pNode->msg.iWindow, GW_HWNDPREV);
#endif
            break;

        case WM_WM_LOWER:
#if CYGMULTIWINDOW_DEBUG
            ErrorF("\tWM_WM_LOWER\n");
#endif

            /* Lower the window */
            XLowerWindow(pWMInfo->pDisplay, pNode->msg.iWindow);
            break;

        case WM_WM_MAP:
#if CYGMULTIWINDOW_DEBUG
            ErrorF("\tWM_WM_MAP\n");
#endif
            /* Put a note as to the HWND associated with this Window */
            XChangeProperty(pWMInfo->pDisplay, pNode->msg.iWindow, pWMInfo->atmPrivMap, XA_INTEGER,
                            32,
                            PropModeReplace,
                            (unsigned char *) &(pNode->msg.hwndWindow), sizeof(HWND)/4);
            UpdateName(pWMInfo, pNode->msg.iWindow);
            UpdateIcon(pWMInfo, pNode->msg.iWindow);
            break;

        case WM_WM_MAP2:
#if CYGMULTIWINDOW_DEBUG
            ErrorF("\tWM_WM_MAP2\n");
#endif
            XChangeProperty(pWMInfo->pDisplay, pNode->msg.iWindow, pWMInfo->atmPrivMap, XA_INTEGER,
                            32,
                            PropModeReplace,
                            (unsigned char *) &(pNode->msg.hwndWindow), sizeof(HWND)/4);
            break;

        case WM_WM_MAP3:
#if CYGMULTIWINDOW_DEBUG
            ErrorF("\tWM_WM_MAP3\n");
#endif
            /* Put a note as to the HWND associated with this Window */
            XChangeProperty(pWMInfo->pDisplay, pNode->msg.iWindow, pWMInfo->atmPrivMap, XA_INTEGER,
                            32,
                            PropModeReplace,
                            (unsigned char *) &(pNode->msg.hwndWindow), sizeof(HWND)/4);
            UpdateName(pWMInfo, pNode->msg.iWindow);
            UpdateIcon(pWMInfo, pNode->msg.iWindow);
            UpdateStyle(pWMInfo, pNode->msg.iWindow);


            /* Reshape */
            {
                WindowPtr pWin =
                    GetProp(pNode->msg.hwndWindow, WIN_WINDOW_PROP);
                if (pWin) {
                    winReshapeMultiWindow(pWin);
                    winUpdateRgnMultiWindow(pWin);
                }
            }

            break;

        case WM_WM_UNMAP:
#if CYGMULTIWINDOW_DEBUG
            ErrorF("\tWM_WM_UNMAP\n");
#endif

            /* Unmap the window */
            XUnmapWindow(pWMInfo->pDisplay, pNode->msg.iWindow);
            break;

        case WM_WM_KILL:
#if CYGMULTIWINDOW_DEBUG
            ErrorF("\tWM_WM_KILL\n");
#endif
            {
                /* --- */
                if (IsWmProtocolAvailable(pWMInfo->pDisplay,
                                          pNode->msg.iWindow,
                                          pWMInfo->atmWmDelete))
                    SendXMessage(pWMInfo->pDisplay,
                                 pNode->msg.iWindow,
                                 pWMInfo->atmWmProtos, pWMInfo->atmWmDelete);
                else
                    XKillClient(pWMInfo->pDisplay, pNode->msg.iWindow);
            }
            break;

        case WM_WM_ACTIVATE:
#if CYGMULTIWINDOW_DEBUG
            ErrorF("\tWM_WM_ACTIVATE\n");
#endif
            /* Set the input focus */

            /*
               ICCCM 4.1.7 is pretty opaque, but it appears that the rules are
               actually quite simple:
               -- the WM_HINTS input field determines whether the WM should call
               XSetInputFocus()
               -- independently, the WM_TAKE_FOCUS protocol determines whether
               the WM should send a WM_TAKE_FOCUS ClientMessage.
            */
            {
              Bool neverFocus = FALSE;
              XWMHints *hints = XGetWMHints(pWMInfo->pDisplay, pNode->msg.iWindow);

              if (hints) {
                if (hints->flags & InputHint)
                  neverFocus = !hints->input;
                XFree(hints);
              }

              if (!neverFocus)
                XSetInputFocus(pWMInfo->pDisplay,
                               pNode->msg.iWindow,
                               RevertToPointerRoot, CurrentTime);

              if (IsWmProtocolAvailable(pWMInfo->pDisplay,
                                        pNode->msg.iWindow,
                                        pWMInfo->atmWmTakeFocus))
                SendXMessage(pWMInfo->pDisplay,
                             pNode->msg.iWindow,
                             pWMInfo->atmWmProtos, pWMInfo->atmWmTakeFocus);

            }
            break;

        case WM_WM_NAME_EVENT:
            UpdateName(pWMInfo, pNode->msg.iWindow);
            break;

        case WM_WM_ICON_EVENT:
            UpdateIcon(pWMInfo, pNode->msg.iWindow);
            break;

        case WM_WM_HINTS_EVENT:
            {
            XWindowAttributes attr;

            /* Don't do anything if this is an override-redirect window */
            XGetWindowAttributes (pWMInfo->pDisplay, pNode->msg.iWindow, &attr);
            if (attr.override_redirect)
              break;

            UpdateStyle(pWMInfo, pNode->msg.iWindow);
            }
            break;

        case WM_WM_CHANGE_STATE:
            /* Minimize the window in Windows */
            winMinimizeWindow(pNode->msg.iWindow);
            break;

        default:
            ErrorF("winMultiWindowWMProc - Unknown Message.  Exiting.\n");
            pthread_exit(NULL);
            break;
        }

        /* Free the retrieved message */
        free(pNode);

        /* Flush any pending events on our display */
        XFlush(pWMInfo->pDisplay);
    }

    /* Free the condition variable */
    pthread_cond_destroy(&pWMInfo->wmMsgQueue.pcNotEmpty);

    /* Free the mutex variable */
    pthread_mutex_destroy(&pWMInfo->wmMsgQueue.pmMutex);

    /* Free the passed-in argument */
    free(pProcArg);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("-winMultiWindowWMProc ()\n");
#endif
    return NULL;
}

/*
 * X message procedure
 */

static void *
winMultiWindowXMsgProc(void *pArg)
{
    winWMMessageRec msg;
    XMsgProcArgPtr pProcArg = (XMsgProcArgPtr) pArg;
    char pszDisplay[512];
    int iRetries;
    XEvent event;
    Atom atmWmName;
    Atom atmWmHints;
    Atom atmWmChange;
    Atom atmNetWmIcon;
    Atom atmWindowState, atmMotifWmHints, atmWindowType, atmNormalHints;
    int iReturn;
    XIconSize *xis;

    winDebug("winMultiWindowXMsgProc - Hello\n");

    /* Check that argument pointer is not invalid */
    if (pProcArg == NULL) {
        ErrorF("winMultiWindowXMsgProc - pProcArg is NULL.  Exiting.\n");
        pthread_exit(NULL);
    }

    ErrorF("winMultiWindowXMsgProc - Calling pthread_mutex_lock ()\n");

    /* Grab the server started mutex - pause until we get it */
    iReturn = pthread_mutex_lock(pProcArg->ppmServerStarted);
    if (iReturn != 0) {
        ErrorF("winMultiWindowXMsgProc - pthread_mutex_lock () failed: %d.  "
               "Exiting.\n", iReturn);
        pthread_exit(NULL);
    }

    ErrorF("winMultiWindowXMsgProc - pthread_mutex_lock () returned.\n");

    /* Allow multiple threads to access Xlib */
    if (XInitThreads() == 0) {
        ErrorF("winMultiWindowXMsgProc - XInitThreads () failed.  Exiting.\n");
        pthread_exit(NULL);
    }

    /* See if X supports the current locale */
    if (XSupportsLocale() == False) {
        ErrorF("winMultiWindowXMsgProc - Warning: locale not supported by X\n");
    }

    /* Release the server started mutex */
    pthread_mutex_unlock(pProcArg->ppmServerStarted);

    ErrorF("winMultiWindowXMsgProc - pthread_mutex_unlock () returned.\n");

    /* Install our error handler */
    XSetErrorHandler(winMultiWindowXMsgProcErrorHandler);
    g_winMultiWindowXMsgProcThread = pthread_self();
    g_winMultiWindowXMsgProcOldIOErrorHandler =
        XSetIOErrorHandler(winMultiWindowXMsgProcIOErrorHandler);

    /* Set jump point for IO Error exits */
    iReturn = setjmp(g_jmpXMsgProcEntry);

    /* Check if we should continue operations */
    if (iReturn != WIN_JMP_ERROR_IO && iReturn != WIN_JMP_OKAY) {
        /* setjmp returned an unknown value, exit */
        ErrorF("winInitMultiWindowXMsgProc - setjmp returned: %d.  Exiting.\n",
               iReturn);
        pthread_exit(NULL);
    }
    else if (iReturn == WIN_JMP_ERROR_IO) {
        ErrorF("winInitMultiWindowXMsgProc - Caught IO Error.  Exiting.\n");
        pthread_exit(NULL);
    }

    /* Setup the display connection string x */
    winGetDisplayName(pszDisplay, (int) pProcArg->dwScreen);

    /* Print the display connection string */
    ErrorF("winMultiWindowXMsgProc - DISPLAY=%s\n", pszDisplay);

    /* Use our generated cookie for authentication */
    winSetAuthorization();

    /* Initialize retry count */
    iRetries = 0;

    /* Open the X display */
    do {
        /* Try to open the display */
        pProcArg->pDisplay = XOpenDisplay(pszDisplay);
        if (pProcArg->pDisplay == NULL) {
            ErrorF("winMultiWindowXMsgProc - Could not open display, try: %d, "
                   "sleeping: %d\n", iRetries + 1, WIN_CONNECT_DELAY);
            ++iRetries;
            sleep(WIN_CONNECT_DELAY);
            continue;
        }
        else
            break;
    }
    while (pProcArg->pDisplay == NULL && iRetries < WIN_CONNECT_RETRIES);

    /* Make sure that the display opened */
    if (pProcArg->pDisplay == NULL) {
        ErrorF("winMultiWindowXMsgProc - Failed opening the display.  "
               "Exiting.\n");
        pthread_exit(NULL);
    }

    ErrorF("winMultiWindowXMsgProc - XOpenDisplay () returned and "
           "successfully opened the display.\n");

    /* Check if another window manager is already running */
    g_fAnotherWMRunning =
        CheckAnotherWindowManager(pProcArg->pDisplay, pProcArg->dwScreen,
                                  pProcArg->pWMInfo->fAllowOtherWM);

    if (g_fAnotherWMRunning && !pProcArg->pWMInfo->fAllowOtherWM) {
        ErrorF("winMultiWindowXMsgProc - "
               "another window manager is running.  Exiting.\n");
        pthread_exit(NULL);
    }

    /* Set up the supported icon sizes */
    xis = XAllocIconSize();
    if (xis) {
        xis->min_width = xis->min_height = 16;
        xis->max_width = xis->max_height = 48;
        xis->width_inc = xis->height_inc = 16;
        XSetIconSizes(pProcArg->pDisplay,
                      RootWindow(pProcArg->pDisplay, pProcArg->dwScreen),
                      xis, 1);
        XFree(xis);
    }

    atmWmName = XInternAtom(pProcArg->pDisplay, "WM_NAME", False);
    atmWmHints = XInternAtom(pProcArg->pDisplay, "WM_HINTS", False);
    atmWmChange = XInternAtom(pProcArg->pDisplay, "WM_CHANGE_STATE", False);
    atmNetWmIcon = XInternAtom(pProcArg->pDisplay, "_NET_WM_ICON", False);
    atmWindowState = XInternAtom(pProcArg->pDisplay, "_NET_WM_STATE", False);
    atmMotifWmHints = XInternAtom(pProcArg->pDisplay, "_MOTIF_WM_HINTS", False);
    atmWindowType = XInternAtom(pProcArg->pDisplay, "_NET_WM_WINDOW_TYPE", False);
    atmNormalHints = XInternAtom(pProcArg->pDisplay, "WM_NORMAL_HINTS", False);

    /*
       iiimxcf had a bug until 2009-04-27, assuming that the
       WM_STATE atom exists, causing clients to fail with
       a BadAtom X error if it doesn't.

       Since this is on in the default Solaris 10 install,
       workaround this by making sure it does exist...
     */
    XInternAtom(pProcArg->pDisplay, "WM_STATE", 0);

    /* Loop until we explicitly break out */
    while (1) {
        if (g_shutdown)
            break;

        if (pProcArg->pWMInfo->fAllowOtherWM && !XPending(pProcArg->pDisplay)) {
            if (CheckAnotherWindowManager
                (pProcArg->pDisplay, pProcArg->dwScreen, TRUE)) {
                if (!g_fAnotherWMRunning) {
                    g_fAnotherWMRunning = TRUE;
                    SendMessage(pProcArg->hwndScreen, WM_UNMANAGE, 0, 0);
                }
            }
            else {
                if (g_fAnotherWMRunning) {
                    g_fAnotherWMRunning = FALSE;
                    SendMessage(pProcArg->hwndScreen, WM_MANAGE, 0, 0);
                }
            }
            Sleep(500);
            continue;
        }

        /* Fetch next event */
        XNextEvent(pProcArg->pDisplay, &event);

        /* Branch on event type */
        if (event.type == CreateNotify) {
            XWindowAttributes attr;

            XSelectInput(pProcArg->pDisplay,
                         event.xcreatewindow.window, PropertyChangeMask);

            /* Get the window attributes */
            XGetWindowAttributes(pProcArg->pDisplay,
                                 event.xcreatewindow.window, &attr);

            if (!attr.override_redirect)
                XSetWindowBorderWidth(pProcArg->pDisplay,
                                      event.xcreatewindow.window, 0);
        }
        else if (event.type == MapNotify) {
            /* Fake a reparentNotify event as SWT/Motif expects a
               Window Manager to reparent a top-level window when
               it is mapped and waits until they do.

               We don't actually need to reparent, as the frame is
               a native window, not an X window

               We do this on MapNotify, not MapRequest like a real
               Window Manager would, so we don't have do get involved
               in actually mapping the window via it's (non-existent)
               parent...

               See sourceware bugzilla #9848
             */

            XWindowAttributes attr;
            Window root;
            Window parent;
            Window *children;
            unsigned int nchildren;

            if (XGetWindowAttributes(event.xmap.display,
                                     event.xmap.window,
                                     &attr) &&
                XQueryTree(event.xmap.display,
                           event.xmap.window,
                           &root, &parent, &children, &nchildren)) {
                if (children)
                    XFree(children);

                /*
                   It's a top-level window if the parent window is a root window
                   Only non-override_redirect windows can get reparented
                 */
                if ((attr.root == parent) && !event.xmap.override_redirect) {
                    XEvent event_send;

                    event_send.type = ReparentNotify;
                    event_send.xreparent.event = event.xmap.window;
                    event_send.xreparent.window = event.xmap.window;
                    event_send.xreparent.parent = parent;
                    event_send.xreparent.x = attr.x;
                    event_send.xreparent.y = attr.y;

                    XSendEvent(event.xmap.display,
                               event.xmap.window,
                               True, StructureNotifyMask, &event_send);
                }
            }
        }
        else if (event.type == ConfigureNotify) {
            if (!event.xconfigure.send_event) {
                /*
                   Java applications using AWT on JRE 1.6.0 break with non-reparenting WMs AWT
                   doesn't explicitly know about (See sun bug #6434227)

                   XDecoratedPeer.handleConfigureNotifyEvent() only processes non-synthetic
                   ConfigureNotify events to update window location if it's identified the
                   WM as a non-reparenting WM it knows about (compiz or lookingglass)

                   Rather than tell all sorts of lies to get XWM to recognize us as one of
                   those, simply send a synthetic ConfigureNotify for every non-synthetic one
                 */
                XEvent event_send = event;

                event_send.xconfigure.send_event = TRUE;
                event_send.xconfigure.event = event.xconfigure.window;
                XSendEvent(event.xconfigure.display,
                           event.xconfigure.window,
                           True, StructureNotifyMask, &event_send);
            }
        }
        else if (event.type == PropertyNotify) {
            if (event.xproperty.atom == atmWmName) {
                memset(&msg, 0, sizeof(msg));

                msg.msg = WM_WM_NAME_EVENT;
                msg.iWindow = event.xproperty.window;

                /* Other fields ignored */
                winSendMessageToWM(pProcArg->pWMInfo, &msg);
            }
            else {
                /*
                   Several properties are considered for WM hints, check if this property change affects any of them...
                   (this list needs to be kept in sync with winApplyHints())
                 */
                if ((event.xproperty.atom == atmWmHints) ||
                    (event.xproperty.atom == atmWindowState) ||
                    (event.xproperty.atom == atmMotifWmHints) ||
                    (event.xproperty.atom == atmWindowType) ||
                    (event.xproperty.atom == atmNormalHints)) {
                    memset(&msg, 0, sizeof(msg));
                    msg.msg = WM_WM_HINTS_EVENT;
                    msg.iWindow = event.xproperty.window;

                    /* Other fields ignored */
                    winSendMessageToWM(pProcArg->pWMInfo, &msg);
                }

                /* Not an else as WM_HINTS affects both style and icon */
                if ((event.xproperty.atom == atmWmHints) ||
                    (event.xproperty.atom == atmNetWmIcon)) {
                    memset(&msg, 0, sizeof(msg));
                    msg.msg = WM_WM_ICON_EVENT;
                    msg.iWindow = event.xproperty.window;

                    /* Other fields ignored */
                    winSendMessageToWM(pProcArg->pWMInfo, &msg);
                }
            }
        }
        else if (event.type == ClientMessage
                 && event.xclient.message_type == atmWmChange
                 && event.xclient.data.l[0] == IconicState) {
            ErrorF("winMultiWindowXMsgProc - WM_CHANGE_STATE - IconicState\n");

            memset(&msg, 0, sizeof(msg));

            msg.msg = WM_WM_CHANGE_STATE;
            msg.iWindow = event.xclient.window;

            winSendMessageToWM(pProcArg->pWMInfo, &msg);
        }
    }

    XCloseDisplay(pProcArg->pDisplay);
    pthread_exit(NULL);
    return NULL;
}

/*
 * winInitWM - Entry point for the X server to spawn
 * the Window Manager thread.  Called from
 * winscrinit.c/winFinishScreenInitFB ().
 */

Bool
winInitWM(void **ppWMInfo,
          pthread_t * ptWMProc,
          pthread_t * ptXMsgProc,
          pthread_mutex_t * ppmServerStarted,
          int dwScreen, HWND hwndScreen, BOOL allowOtherWM)
{
    WMProcArgPtr pArg = malloc(sizeof(WMProcArgRec));
    WMInfoPtr pWMInfo = malloc(sizeof(WMInfoRec));
    XMsgProcArgPtr pXMsgArg = malloc(sizeof(XMsgProcArgRec));

    /* Bail if the input parameters are bad */
    if (pArg == NULL || pWMInfo == NULL || pXMsgArg == NULL) {
        ErrorF("winInitWM - malloc failed.\n");
        free(pArg);
        free(pWMInfo);
        free(pXMsgArg);
        return FALSE;
    }

    /* Zero the allocated memory */
    ZeroMemory(pArg, sizeof(WMProcArgRec));
    ZeroMemory(pWMInfo, sizeof(WMInfoRec));
    ZeroMemory(pXMsgArg, sizeof(XMsgProcArgRec));

    /* Set a return pointer to the Window Manager info structure */
    *ppWMInfo = pWMInfo;
    pWMInfo->fAllowOtherWM = allowOtherWM;

    /* Setup the argument structure for the thread function */
    pArg->dwScreen = dwScreen;
    pArg->pWMInfo = pWMInfo;
    pArg->ppmServerStarted = ppmServerStarted;

    /* Intialize the message queue */
    if (!InitQueue(&pWMInfo->wmMsgQueue)) {
        ErrorF("winInitWM - InitQueue () failed.\n");
        return FALSE;
    }

    /* Spawn a thread for the Window Manager */
    if (pthread_create(ptWMProc, NULL, winMultiWindowWMProc, pArg)) {
        /* Bail if thread creation failed */
        ErrorF("winInitWM - pthread_create failed for Window Manager.\n");
        return FALSE;
    }

    /* Spawn the XNextEvent thread, will send messages to WM */
    pXMsgArg->dwScreen = dwScreen;
    pXMsgArg->pWMInfo = pWMInfo;
    pXMsgArg->ppmServerStarted = ppmServerStarted;
    pXMsgArg->hwndScreen = hwndScreen;
    if (pthread_create(ptXMsgProc, NULL, winMultiWindowXMsgProc, pXMsgArg)) {
        /* Bail if thread creation failed */
        ErrorF("winInitWM - pthread_create failed on XMSG.\n");
        return FALSE;
    }

#if CYGDEBUG || YES
    winDebug("winInitWM - Returning.\n");
#endif

    return TRUE;
}

/*
 * Window manager thread - setup
 */

static void
winInitMultiWindowWM(WMInfoPtr pWMInfo, WMProcArgPtr pProcArg)
{
    int iRetries = 0;
    char pszDisplay[512];
    int iReturn;

    winDebug("winInitMultiWindowWM - Hello\n");

    /* Check that argument pointer is not invalid */
    if (pProcArg == NULL) {
        ErrorF("winInitMultiWindowWM - pProcArg is NULL.  Exiting.\n");
        pthread_exit(NULL);
    }

    ErrorF("winInitMultiWindowWM - Calling pthread_mutex_lock ()\n");

    /* Grab our garbage mutex to satisfy pthread_cond_wait */
    iReturn = pthread_mutex_lock(pProcArg->ppmServerStarted);
    if (iReturn != 0) {
        ErrorF("winInitMultiWindowWM - pthread_mutex_lock () failed: %d.  "
               "Exiting.\n", iReturn);
        pthread_exit(NULL);
    }

    ErrorF("winInitMultiWindowWM - pthread_mutex_lock () returned.\n");

    /* Allow multiple threads to access Xlib */
    if (XInitThreads() == 0) {
        ErrorF("winInitMultiWindowWM - XInitThreads () failed.  Exiting.\n");
        pthread_exit(NULL);
    }

    /* See if X supports the current locale */
    if (XSupportsLocale() == False) {
        ErrorF("winInitMultiWindowWM - Warning: Locale not supported by X.\n");
    }

    /* Release the server started mutex */
    pthread_mutex_unlock(pProcArg->ppmServerStarted);

    ErrorF("winInitMultiWindowWM - pthread_mutex_unlock () returned.\n");

    /* Install our error handler */
    XSetErrorHandler(winMultiWindowWMErrorHandler);
    g_winMultiWindowWMThread = pthread_self();
    g_winMultiWindowWMOldIOErrorHandler =
        XSetIOErrorHandler(winMultiWindowWMIOErrorHandler);

    /* Set jump point for IO Error exits */
    iReturn = setjmp(g_jmpWMEntry);

    /* Check if we should continue operations */
    if (iReturn != WIN_JMP_ERROR_IO && iReturn != WIN_JMP_OKAY) {
        /* setjmp returned an unknown value, exit */
        ErrorF("winInitMultiWindowWM - setjmp returned: %d.  Exiting.\n",
               iReturn);
        pthread_exit(NULL);
    }
    else if (iReturn == WIN_JMP_ERROR_IO) {
        ErrorF("winInitMultiWindowWM - Caught IO Error.  Exiting.\n");
        pthread_exit(NULL);
    }

    /* Setup the display connection string x */
    winGetDisplayName(pszDisplay, (int) pProcArg->dwScreen);

    /* Print the display connection string */
    ErrorF("winInitMultiWindowWM - DISPLAY=%s\n", pszDisplay);

    /* Use our generated cookie for authentication */
    winSetAuthorization();

    /* Open the X display */
    do {
        /* Try to open the display */
        pWMInfo->pDisplay = XOpenDisplay(pszDisplay);
        if (pWMInfo->pDisplay == NULL) {
            ErrorF("winInitMultiWindowWM - Could not open display, try: %d, "
                   "sleeping: %d\n", iRetries + 1, WIN_CONNECT_DELAY);
            ++iRetries;
            sleep(WIN_CONNECT_DELAY);
            continue;
        }
        else
            break;
    }
    while (pWMInfo->pDisplay == NULL && iRetries < WIN_CONNECT_RETRIES);

    /* Make sure that the display opened */
    if (pWMInfo->pDisplay == NULL) {
        ErrorF("winInitMultiWindowWM - Failed opening the display.  "
               "Exiting.\n");
        pthread_exit(NULL);
    }

    ErrorF("winInitMultiWindowWM - XOpenDisplay () returned and "
           "successfully opened the display.\n");

    /* Create some atoms */
    pWMInfo->atmWmProtos = XInternAtom(pWMInfo->pDisplay,
                                       "WM_PROTOCOLS", False);
    pWMInfo->atmWmDelete = XInternAtom(pWMInfo->pDisplay,
                                       "WM_DELETE_WINDOW", False);
    pWMInfo->atmWmTakeFocus = XInternAtom(pWMInfo->pDisplay,
                                       "WM_TAKE_FOCUS", False);

    pWMInfo->atmPrivMap = XInternAtom(pWMInfo->pDisplay,
                                      WINDOWSWM_NATIVE_HWND, False);

    if (1) {
        Cursor cursor = XCreateFontCursor(pWMInfo->pDisplay, XC_left_ptr);

        if (cursor) {
            XDefineCursor(pWMInfo->pDisplay,
                          DefaultRootWindow(pWMInfo->pDisplay), cursor);
            XFreeCursor(pWMInfo->pDisplay, cursor);
        }
    }
}

/*
 * winSendMessageToWM - Send a message from the X thread to the WM thread
 */

void
winSendMessageToWM(void *pWMInfo, winWMMessagePtr pMsg)
{
    WMMsgNodePtr pNode;

#if CYGMULTIWINDOW_DEBUG
    ErrorF("winSendMessageToWM ()\n");
#endif

    pNode = malloc(sizeof(WMMsgNodeRec));
    if (pNode != NULL) {
        memcpy(&pNode->msg, pMsg, sizeof(winWMMessageRec));
        PushMessage(&((WMInfoPtr) pWMInfo)->wmMsgQueue, pNode);
    }
}

/*
 * Window manager error handler
 */

static int
winMultiWindowWMErrorHandler(Display * pDisplay, XErrorEvent * pErr)
{
    char pszErrorMsg[100];

    if (pErr->request_code == X_ChangeWindowAttributes
        && pErr->error_code == BadAccess) {
        ErrorF("winMultiWindowWMErrorHandler - ChangeWindowAttributes "
               "BadAccess.\n");
        return 0;
    }

    XGetErrorText(pDisplay, pErr->error_code, pszErrorMsg, sizeof(pszErrorMsg));
    ErrorF("winMultiWindowWMErrorHandler - ERROR: %s\n", pszErrorMsg);

    return 0;
}

/*
 * Window manager IO error handler
 */

static int
winMultiWindowWMIOErrorHandler(Display * pDisplay)
{
    ErrorF("winMultiWindowWMIOErrorHandler!\n");

    if (pthread_equal(pthread_self(), g_winMultiWindowWMThread)) {
        if (g_shutdown)
            pthread_exit(NULL);

        /* Restart at the main entry point */
        longjmp(g_jmpWMEntry, WIN_JMP_ERROR_IO);
    }

    if (g_winMultiWindowWMOldIOErrorHandler)
        g_winMultiWindowWMOldIOErrorHandler(pDisplay);

    return 0;
}

/*
 * X message procedure error handler
 */

static int
winMultiWindowXMsgProcErrorHandler(Display * pDisplay, XErrorEvent * pErr)
{
    char pszErrorMsg[100];

    XGetErrorText(pDisplay, pErr->error_code, pszErrorMsg, sizeof(pszErrorMsg));
#if CYGMULTIWINDOW_DEBUG
    ErrorF("winMultiWindowXMsgProcErrorHandler - ERROR: %s\n", pszErrorMsg);
#endif

    return 0;
}

/*
 * X message procedure IO error handler
 */

static int
winMultiWindowXMsgProcIOErrorHandler(Display * pDisplay)
{
    ErrorF("winMultiWindowXMsgProcIOErrorHandler!\n");

    if (pthread_equal(pthread_self(), g_winMultiWindowXMsgProcThread)) {
        /* Restart at the main entry point */
        longjmp(g_jmpXMsgProcEntry, WIN_JMP_ERROR_IO);
    }

    if (g_winMultiWindowXMsgProcOldIOErrorHandler)
        g_winMultiWindowXMsgProcOldIOErrorHandler(pDisplay);

    return 0;
}

/*
 * Catch RedirectError to detect other window manager running
 */

static int
winRedirectErrorHandler(Display * pDisplay, XErrorEvent * pErr)
{
    redirectError = TRUE;
    return 0;
}

/*
 * Check if another window manager is running
 */

static Bool
CheckAnotherWindowManager(Display * pDisplay, DWORD dwScreen,
                          Bool fAllowOtherWM)
{
    /*
       Try to select the events which only one client at a time is allowed to select.
       If this causes an error, another window manager is already running...
     */
    redirectError = FALSE;
    XSetErrorHandler(winRedirectErrorHandler);
    XSelectInput(pDisplay, RootWindow(pDisplay, dwScreen),
                 ResizeRedirectMask | SubstructureRedirectMask |
                 ButtonPressMask);
    XSync(pDisplay, 0);
    XSetErrorHandler(winMultiWindowXMsgProcErrorHandler);

    /*
       Side effect: select the events we are actually interested in...

       If other WMs are not allowed, also select one of the events which only one client
       at a time is allowed to select, so other window managers won't start...
     */
    XSelectInput(pDisplay, RootWindow(pDisplay, dwScreen),
                 SubstructureNotifyMask | (!fAllowOtherWM ? ButtonPressMask :
                                           0));
    XSync(pDisplay, 0);
    return redirectError;
}

/*
 * Notify the MWM thread we're exiting and not to reconnect
 */

void
winDeinitMultiWindowWM(void)
{
    ErrorF("winDeinitMultiWindowWM - Noting shutdown in progress\n");
    g_shutdown = TRUE;
}

/* Windows window styles */
#define HINT_NOFRAME	(1L<<0)
#define HINT_BORDER	(1L<<1)
#define HINT_SIZEBOX	(1L<<2)
#define HINT_CAPTION	(1L<<3)
#define HINT_NOMAXIMIZE (1L<<4)
#define HINT_NOMINIMIZE (1L<<5)
#define HINT_NOSYSMENU  (1L<<6)
#define HINT_SKIPTASKBAR (1L<<7)
/* These two are used on their own */
#define HINT_MAX	(1L<<0)
#define HINT_MIN	(1L<<1)

static void
winApplyHints(Display * pDisplay, Window iWindow, HWND hWnd, HWND * zstyle)
{
    static Atom windowState, motif_wm_hints, windowType;
    static Atom hiddenState, fullscreenState, belowState, aboveState,
        skiptaskbarState;
    static Atom dockWindow;
    static int generation;
    Atom type, *pAtom = NULL;
    int format;
    unsigned long hint = 0, maxmin = 0, nitems = 0, left = 0;
    unsigned long style, exStyle;
    MwmHints *mwm_hint = NULL;

    if (!hWnd)
        return;
    if (!IsWindow(hWnd))
        return;

    if (generation != serverGeneration) {
        generation = serverGeneration;
        windowState = XInternAtom(pDisplay, "_NET_WM_STATE", False);
        motif_wm_hints = XInternAtom(pDisplay, "_MOTIF_WM_HINTS", False);
        windowType = XInternAtom(pDisplay, "_NET_WM_WINDOW_TYPE", False);
        hiddenState = XInternAtom(pDisplay, "_NET_WM_STATE_HIDDEN", False);
        fullscreenState =
            XInternAtom(pDisplay, "_NET_WM_STATE_FULLSCREEN", False);
        belowState = XInternAtom(pDisplay, "_NET_WM_STATE_BELOW", False);
        aboveState = XInternAtom(pDisplay, "_NET_WM_STATE_ABOVE", False);
        dockWindow = XInternAtom(pDisplay, "_NET_WM_WINDOW_TYPE_DOCK", False);
        skiptaskbarState =
            XInternAtom(pDisplay, "_NET_WM_STATE_SKIP_TASKBAR", False);
    }

    if (XGetWindowProperty(pDisplay, iWindow, windowState, 0L,
                           MAXINT, False, XA_ATOM, &type, &format,
                           &nitems, &left,
                           (unsigned char **) &pAtom) == Success) {
        if (pAtom ) {
            unsigned long i;

            for (i = 0; i < nitems; i++) {
                if (pAtom[i] == skiptaskbarState)
                    hint |= HINT_SKIPTASKBAR;
                if (pAtom[i] == hiddenState)
                    maxmin |= HINT_MIN;
                else if (pAtom[i] == fullscreenState)
                    maxmin |= HINT_MAX;
                if (pAtom[i] == belowState)
                    *zstyle = HWND_BOTTOM;
                else if (pAtom[i] == aboveState)
                    *zstyle = HWND_TOPMOST;
            }

            XFree(pAtom);
        }
    }

    nitems = left = 0;
    if (XGetWindowProperty(pDisplay, iWindow, motif_wm_hints, 0L,
                           PropMwmHintsElements, False, motif_wm_hints, &type,
                           &format, &nitems, &left,
                           (unsigned char **) &mwm_hint) == Success) {
        if (mwm_hint && nitems == PropMwmHintsElements &&
            (mwm_hint->flags & MwmHintsDecorations)) {
            if (!mwm_hint->decorations)
                hint |= (HINT_NOFRAME | HINT_NOSYSMENU | HINT_NOMINIMIZE | HINT_NOMAXIMIZE);
            else if (!(mwm_hint->decorations & MwmDecorAll)) {
                if (mwm_hint->decorations & MwmDecorBorder)
                    hint |= HINT_BORDER;
                if (mwm_hint->decorations & MwmDecorHandle)
                    hint |= HINT_SIZEBOX;
                if (mwm_hint->decorations & MwmDecorTitle)
                    hint |= HINT_CAPTION;
                if (!(mwm_hint->decorations & MwmDecorMenu))
                    hint |= HINT_NOSYSMENU;
                if (!(mwm_hint->decorations & MwmDecorMinimize))
                    hint |= HINT_NOMINIMIZE;
                if (!(mwm_hint->decorations & MwmDecorMaximize))
                    hint |= HINT_NOMAXIMIZE;
            }
            else {
                /*
                   MwmDecorAll means all decorations *except* those specified by other flag
                   bits that are set.  Not yet implemented.
                 */
            }
        }
        if (mwm_hint)
            XFree(mwm_hint);
    }

    nitems = left = 0;
    pAtom = NULL;
    if (XGetWindowProperty(pDisplay, iWindow, windowType, 0L,
                           1L, False, XA_ATOM, &type, &format,
                           &nitems, &left,
                           (unsigned char **) &pAtom) == Success) {
        if (pAtom && nitems == 1) {
            if (*pAtom == dockWindow) {
                hint = (hint & ~HINT_NOFRAME) | HINT_SKIPTASKBAR | HINT_SIZEBOX;
                *zstyle = HWND_TOPMOST;
            }
        }
        if (pAtom)
            XFree(pAtom);
    }

    {
        XSizeHints *normal_hint = XAllocSizeHints();
        long supplied;

        if (normal_hint &&
            XGetWMNormalHints(pDisplay, iWindow, normal_hint, &supplied)) {
            if (normal_hint->flags & PMaxSize) {
                /* Not maximizable if a maximum size is specified */
                hint |= HINT_NOMAXIMIZE;

                if (normal_hint->flags & PMinSize) {
                    /*
                       If both minimum size and maximum size are specified and are the same,
                       don't bother with a resizing frame
                     */
                    if ((normal_hint->min_width == normal_hint->max_width)
                        && (normal_hint->min_height == normal_hint->max_height))
                        hint = (hint & ~HINT_SIZEBOX);
                }
            }
        }
        XFree(normal_hint);
    }

    /*
       Override hint settings from above with settings from config file and set
       application id for grouping.
     */
    {
        XClassHint class_hint = { 0, 0 };
        char *window_name = 0;
        char *application_id = 0;

        if (XGetClassHint(pDisplay, iWindow, &class_hint)) {
            XFetchName(pDisplay, iWindow, &window_name);

            style =
                winOverrideStyle(class_hint.res_name, class_hint.res_class,
                                 window_name);

#define APPLICATION_ID_FORMAT	"%s.xwin.%s"
#define APPLICATION_ID_UNKNOWN "unknown"
            if (class_hint.res_class) {
                asprintf(&application_id, APPLICATION_ID_FORMAT, XVENDORNAME,
                         class_hint.res_class);
            }
            else {
                asprintf(&application_id, APPLICATION_ID_FORMAT, XVENDORNAME,
                         APPLICATION_ID_UNKNOWN);
            }
            winSetAppUserModelID(hWnd, application_id);

            if (class_hint.res_name)
                XFree(class_hint.res_name);
            if (class_hint.res_class)
                XFree(class_hint.res_class);
            if (application_id)
                free(application_id);
            if (window_name)
                XFree(window_name);
        }
        else {
            style = STYLE_NONE;
        }
    }

    if (style & STYLE_TOPMOST)
        *zstyle = HWND_TOPMOST;
    else if (style & STYLE_MAXIMIZE)
        maxmin = (hint & ~HINT_MIN) | HINT_MAX;
    else if (style & STYLE_MINIMIZE)
        maxmin = (hint & ~HINT_MAX) | HINT_MIN;
    else if (style & STYLE_BOTTOM)
        *zstyle = HWND_BOTTOM;

    if (maxmin & HINT_MAX)
        SendMessage(hWnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
    else if (maxmin & HINT_MIN)
        SendMessage(hWnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);

    if (style & STYLE_NOTITLE)
        hint =
            (hint & ~HINT_NOFRAME & ~HINT_BORDER & ~HINT_CAPTION) |
            HINT_SIZEBOX;
    else if (style & STYLE_OUTLINE)
        hint =
            (hint & ~HINT_NOFRAME & ~HINT_SIZEBOX & ~HINT_CAPTION) |
            HINT_BORDER;
    else if (style & STYLE_NOFRAME)
        hint =
            (hint & ~HINT_BORDER & ~HINT_CAPTION & ~HINT_SIZEBOX) |
            HINT_NOFRAME;

    /* Now apply styles to window */
    style = GetWindowLongPtr(hWnd, GWL_STYLE);
    if (!style)
        return;                 /* GetWindowLongPointer returns 0 on failure, we hope this isn't a valid style */

    style &= ~WS_CAPTION & ~WS_SIZEBOX; /* Just in case */

    if (!(hint & ~HINT_SKIPTASKBAR))    /* No hints, default */
        style = style | WS_CAPTION | WS_SIZEBOX;
    else if (hint & HINT_NOFRAME)       /* No frame, no decorations */
        style = style & ~WS_CAPTION & ~WS_SIZEBOX;
    else
        style = style | ((hint & HINT_BORDER) ? WS_BORDER : 0) |
            ((hint & HINT_SIZEBOX) ? WS_SIZEBOX : 0) |
            ((hint & HINT_CAPTION) ? WS_CAPTION : 0);

    if (hint & HINT_NOMAXIMIZE)
        style = style & ~WS_MAXIMIZEBOX;

    if (hint & HINT_NOMINIMIZE)
        style = style & ~WS_MINIMIZEBOX;

    if (hint & HINT_NOSYSMENU)
        style = style & ~WS_SYSMENU;

    if (hint & HINT_SKIPTASKBAR)
        style = style & ~WS_MINIMIZEBOX;        /* window will become lost if minimized */

    SetWindowLongPtr(hWnd, GWL_STYLE, style);

    exStyle = GetWindowLongPtr(hWnd, GWL_EXSTYLE);
    if (hint & HINT_SKIPTASKBAR)
        exStyle = (exStyle & ~WS_EX_APPWINDOW) | WS_EX_TOOLWINDOW;
    else
        exStyle = (exStyle & ~WS_EX_TOOLWINDOW) | WS_EX_APPWINDOW;
    SetWindowLongPtr(hWnd, GWL_EXSTYLE, exStyle);

    winDebug
        ("winApplyHints: iWindow 0x%08x hints 0x%08x style 0x%08x exstyle 0x%08x\n",
         iWindow, hint, style, exStyle);
}

void
winUpdateWindowPosition(HWND hWnd, HWND * zstyle)
{
    int iX, iY, iWidth, iHeight;
    int iDx, iDy;
    RECT rcNew;
    WindowPtr pWin = GetProp(hWnd, WIN_WINDOW_PROP);
    DrawablePtr pDraw = NULL;

    if (!pWin)
        return;
    pDraw = &pWin->drawable;
    if (!pDraw)
        return;

    /* Get the X and Y location of the X window */
    iX = pWin->drawable.x + GetSystemMetrics(SM_XVIRTUALSCREEN);
    iY = pWin->drawable.y + GetSystemMetrics(SM_YVIRTUALSCREEN);

    /* Get the height and width of the X window */
    iWidth = pWin->drawable.width;
    iHeight = pWin->drawable.height;

    /* Setup a rectangle with the X window position and size */
    SetRect(&rcNew, iX, iY, iX + iWidth, iY + iHeight);

    winDebug("winUpdateWindowPosition - drawable extent (%d, %d)-(%d, %d)\n",
             rcNew.left, rcNew.top, rcNew.right, rcNew.bottom);

    AdjustWindowRectEx(&rcNew, GetWindowLongPtr(hWnd, GWL_STYLE), FALSE,
                       GetWindowLongPtr(hWnd, GWL_EXSTYLE));

    /* Don't allow window decoration to disappear off to top-left as a result of this adjustment */
    if (rcNew.left < GetSystemMetrics(SM_XVIRTUALSCREEN)) {
        iDx = GetSystemMetrics(SM_XVIRTUALSCREEN) - rcNew.left;
        rcNew.left += iDx;
        rcNew.right += iDx;
    }

    if (rcNew.top < GetSystemMetrics(SM_YVIRTUALSCREEN)) {
        iDy = GetSystemMetrics(SM_YVIRTUALSCREEN) - rcNew.top;
        rcNew.top += iDy;
        rcNew.bottom += iDy;
    }

    winDebug("winUpdateWindowPosition - Window extent (%d, %d)-(%d, %d)\n",
             rcNew.left, rcNew.top, rcNew.right, rcNew.bottom);

    /* Position the Windows window */
    SetWindowPos(hWnd, *zstyle, rcNew.left, rcNew.top,
                 rcNew.right - rcNew.left, rcNew.bottom - rcNew.top, 0);

}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d775 2
a776 2
        ErrorF("winMultiWindowWMProc - %d ms MSG: %d ID: %d\n",
               GetTickCount(), (int) pNode->msg.msg, (int) pNode->msg.dwID);
d1741 1
a1741 1
                hint |= HINT_NOFRAME;
d1775 1
a1775 1
                hint = (hint & ~HINT_NOFRAME) | HINT_SIZEBOX;   /* Xming puts a sizebox on dock windows */
d1788 1
a1788 2
            (XGetWMNormalHints(pDisplay, iWindow, normal_hint, &supplied) ==
             Success)) {
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d64 1
d342 1
a342 1
 * HaveMessage - 
d1057 1
a1057 2
    snprintf(pszDisplay,
             512, "127.0.0.1:%s.%d", display, (int) pProcArg->dwScreen);
d1449 1
a1449 2
    snprintf(pszDisplay,
             512, "127.0.0.1:%s.%d", display, (int) pProcArg->dwScreen);
@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d63 1
d73 4
d119 1
d414 1
a414 1
        pszReturnData = (char *) malloc(iLen + 1);
d422 1
a422 1
        pszReturnData = (char *) malloc(1);
d438 1
d440 2
d461 35
d500 21
d605 1
a605 1
                (wchar_t *) malloc(sizeof(wchar_t) * (iLen + 1));
a872 3
                int i, n, found = 0;
                Atom *protocols;

d874 3
a876 11
                if (XGetWMProtocols(pWMInfo->pDisplay,
                                    pNode->msg.iWindow, &protocols, &n)) {
                    for (i = 0; i < n; ++i)
                        if (protocols[i] == pWMInfo->atmWmDelete)
                            ++found;

                    XFree(protocols);
                }

                /* --- */
                if (found)
d889 13
d903 19
a921 4
            /* Set the input focus */
            XSetInputFocus(pWMInfo->pDisplay,
                           pNode->msg.iWindow,
                           RevertToPointerRoot, CurrentTime);
d1322 3
a1324 3
    WMProcArgPtr pArg = (WMProcArgPtr) malloc(sizeof(WMProcArgRec));
    WMInfoPtr pWMInfo = (WMInfoPtr) malloc(sizeof(WMInfoRec));
    XMsgProcArgPtr pXMsgArg = (XMsgProcArgPtr) malloc(sizeof(XMsgProcArgRec));
d1489 2
d1519 1
a1519 1
    pNode = (WMMsgNodePtr) malloc(sizeof(WMMsgNodeRec));
d1664 1
a1664 1
#define HINT_NOFRAME	(1l<<0)
d1666 2
a1667 2
#define HINT_SIZEBOX	(1l<<2)
#define HINT_CAPTION	(1l<<3)
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d491 1
a491 1
                           1,
d750 1
a750 1
            XChangeProperty(pWMInfo->pDisplay, pNode->msg.iWindow, pWMInfo->atmPrivMap, XA_INTEGER,     //pWMInfo->atmPrivMap,
d753 1
a753 1
                            (unsigned char *) &(pNode->msg.hwndWindow), 1);
d762 1
a762 1
            XChangeProperty(pWMInfo->pDisplay, pNode->msg.iWindow, pWMInfo->atmPrivMap, XA_INTEGER,     //pWMInfo->atmPrivMap,
d765 1
a765 1
                            (unsigned char *) &(pNode->msg.hwndWindow), 1);
d773 1
a773 1
            XChangeProperty(pWMInfo->pDisplay, pNode->msg.iWindow, pWMInfo->atmPrivMap, XA_INTEGER,     //pWMInfo->atmPrivMap,
d776 1
a776 1
                            (unsigned char *) &(pNode->msg.hwndWindow), 1);
d1064 1
a1064 2
                    SendMessage(*(HWND *) pProcArg->hwndScreen, WM_UNMANAGE, 0,
                                0);
d1070 1
a1070 2
                    SendMessage(*(HWND *) pProcArg->hwndScreen, WM_MANAGE, 0,
                                0);
d1471 1
a1471 1
    ErrorF("winMultiWindowWMIOErrorHandler!\n\n");
d1511 1
a1511 1
    ErrorF("winMultiWindowXMsgProcIOErrorHandler!\n\n");
d1627 1
a1627 1
                           1L, False, XA_ATOM, &type, &format,
d1630 17
a1646 11
        if (pAtom && nitems == 1) {
            if (*pAtom == skiptaskbarState)
                hint |= HINT_SKIPTASKBAR;
            if (*pAtom == hiddenState)
                maxmin |= HINT_MIN;
            else if (*pAtom == fullscreenState)
                maxmin |= HINT_MAX;
            if (*pAtom == belowState)
                *zstyle = HWND_BOTTOM;
            else if (*pAtom == aboveState)
                *zstyle = HWND_TOPMOST;
a1647 2
        if (pAtom)
            XFree(pAtom);
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a57 2
#include "objbase.h"
#include "ddraw.h"
a132 7
 * References to external symbols
 */

extern char *display;
extern void ErrorF(const char * /*f */ , ...);

/*
d145 1
a145 1
 GetWindowName(Display * pDpy, Window iWin, wchar_t ** ppName);
d189 1
a189 1
 winUpdateWindowPosition(HWND hWnd, Bool reshape, HWND * zstyle);
d374 2
a375 2
    ErrorF("InitQueue - Queue Size %d %d\n", pQueue->nQueueSize,
           QueueSize(pQueue));
d378 1
a378 1
    ErrorF("InitQueue - Calling pthread_mutex_init\n");
d383 2
a384 2
    ErrorF("InitQueue - pthread_mutex_init returned\n");
    ErrorF("InitQueue - Calling pthread_cond_init\n");
d388 1
a388 1
    ErrorF("InitQueue - pthread_cond_init returned\n");
d393 3
a395 6
/*
 * GetWindowName - Retrieve the title of an X Window
 */

static void
GetWindowName(Display * pDisplay, Window iWin, wchar_t ** ppName)
d397 1
a397 1
    int nResult, nNum;
a399 2
    int iLen, i;
    XTextProperty xtpName;
d401 4
a404 15
#if CYGMULTIWINDOW_DEBUG
    ErrorF("GetWindowName\n");
#endif

    /* Intialize ppName to NULL */
    *ppName = NULL;

    /* Try to get --- */
    nResult = XGetWMName(pDisplay, iWin, &xtpName);
    if (!nResult || !xtpName.value || !xtpName.nitems) {
#if CYGMULTIWINDOW_DEBUG
        ErrorF("GetWindowName - XGetWMName failed.  No name.\n");
#endif
        return;
    }
a405 3
    if (Xutf8TextPropertyToTextList(pDisplay, &xtpName, &ppList, &nNum) >=
        Success && nNum > 0 && *ppList) {
        iLen = 0;
a418 5
    iLen = MultiByteToWideChar(CP_UTF8, 0, pszReturnData, -1, NULL, 0);
    *ppName = (wchar_t *) malloc(sizeof(wchar_t) * (iLen + 1));
    MultiByteToWideChar(CP_UTF8, 0, pszReturnData, -1, *ppName, iLen);
    XFree(xtpName.value);
    free(pszReturnData);
d420 24
d445 1
a445 1
    ErrorF("GetWindowName - Returning\n");
d447 6
d477 1
a477 1
 * Updates the name of a HWND according to its X WM_NAME property
d479 2
a480 3

static void
UpdateName(WMInfoPtr pWMInfo, Window iWindow)
a481 1
    wchar_t *pszName;
d485 1
a485 2
    HWND *retHwnd, hWnd;
    XWindowAttributes attr;
d487 7
a493 4
    hWnd = 0;

    /* See if we can get the cached HWND for this window... */
    if (XGetWindowProperty(pWMInfo->pDisplay, iWindow, pWMInfo->atmPrivMap, 0, 1, False, XA_INTEGER,    //pWMInfo->atmPrivMap,
d506 1
a506 1
        return;
d508 17
d527 22
a548 8
    /* Set the Windows window name */
    GetWindowName(pWMInfo->pDisplay, iWindow, &pszName);
    if (pszName) {
        /* Get the window attributes */
        XGetWindowAttributes(pWMInfo->pDisplay, iWindow, &attr);
        if (!attr.override_redirect) {
            SetWindowTextW(hWnd, pszName);
            winUpdateIcon(iWindow);
d550 30
d581 7
a587 1
        free(pszName);
d589 41
d640 1
a640 4
    Atom atmType;
    int fmtRet;
    unsigned long items, remain;
    HWND hWnd, *retHwnd;
d645 1
a645 13
    hWnd = NULL;
    /* See if we can get the cached HWND for this window... */
    if (XGetWindowProperty(pWMInfo->pDisplay, iWindow, pWMInfo->atmPrivMap, 0, 1, False, XA_INTEGER,    //pWMInfo->atmPrivMap,
                           &atmType,
                           &fmtRet,
                           &items,
                           &remain, (unsigned char **) &retHwnd) == Success) {
        if (retHwnd) {
            hWnd = *retHwnd;
            XFree(retHwnd);
        }
    }

d755 1
a755 1
            winUpdateIcon(pNode->msg.iWindow);
d778 5
a782 1
            winUpdateIcon(pNode->msg.iWindow);
d784 7
a790 1
                HWND zstyle = HWND_NOTOPMOST;
a791 4
                winApplyHints(pWMInfo->pDisplay, pNode->msg.iWindow,
                              pNode->msg.hwndWindow, &zstyle);
                winUpdateWindowPosition(pNode->msg.hwndWindow, TRUE, &zstyle);
            }
d846 4
d851 10
a860 1
            winUpdateIcon(pNode->msg.iWindow);
d911 2
d916 1
a916 1
    ErrorF("winMultiWindowXMsgProc - Hello\n");
d1038 5
d1170 6
a1175 3
        else if (event.type == PropertyNotify
                 && event.xproperty.atom == atmWmName) {
            memset(&msg, 0, sizeof(msg));
d1177 16
a1192 2
            msg.msg = WM_WM_NAME_EVENT;
            msg.iWindow = event.xproperty.window;
d1194 3
a1196 6
            /* Other fields ignored */
            winSendMessageToWM(pProcArg->pWMInfo, &msg);
        }
        else if (event.type == PropertyNotify
                 && event.xproperty.atom == atmWmHints) {
            memset(&msg, 0, sizeof(msg));
d1198 6
a1203 2
            msg.msg = WM_WM_HINTS_EVENT;
            msg.iWindow = event.xproperty.window;
d1205 4
a1208 2
            /* Other fields ignored */
            winSendMessageToWM(pProcArg->pWMInfo, &msg);
d1311 1
a1311 1
    ErrorF("winInitMultiWindowWM - Hello\n");
d1589 1
d1598 2
a1599 1
    static Atom hiddenState, fullscreenState, belowState, aboveState;
d1604 2
a1605 1
    unsigned long hint = 0, maxmin = 0, style, nitems = 0, left = 0;
d1624 2
d1633 2
d1723 4
a1726 1
    /* Override hint settings from above with settings from config file */
d1730 1
d1739 12
d1755 2
d1793 1
a1793 1
    style = GetWindowLongPtr(hWnd, GWL_STYLE) & ~WS_CAPTION & ~WS_SIZEBOX;      /* Just in case */
d1795 3
a1797 1
        return;
d1799 1
a1799 1
    if (!hint)                  /* All on */
d1801 1
a1801 1
    else if (hint & HINT_NOFRAME)       /* All off */
d1817 3
d1821 11
d1835 1
a1835 1
winUpdateWindowPosition(HWND hWnd, Bool reshape, HWND * zstyle)
d1860 2
a1861 4
#if 0
    ErrorF("winUpdateWindowPosition - (%d, %d)-(%d, %d)\n",
           rcNew.left, rcNew.top, rcNew.right, rcNew.bottom);
#endif
d1864 1
a1864 1
                       WS_EX_APPWINDOW);
d1879 2
a1880 4
#if 0
    ErrorF("winUpdateWindowPosition - (%d, %d)-(%d, %d)\n",
           rcNew.left, rcNew.top, rcNew.right, rcNew.bottom);
#endif
a1885 4
    if (reshape) {
        winReshapeMultiWindow(pWin);
        winUpdateRgnMultiWindow(pWin);
    }
@


1.3
log
@Update to xserver 1.11.2
@
text
@d89 1
a89 1
# define WIN_MSG_QUEUE_FNAME	"/dev/windows"
d99 2
a100 2
  winWMMessageRec	msg;
  struct _WMMsgNodeRec	*pNext;
d104 5
a108 5
  struct _WMMsgNodeRec	*pHead;
  struct _WMMsgNodeRec	*pTail;
  pthread_mutex_t	pmMutex;
  pthread_cond_t	pcNotEmpty;
  int			nQueueSize;
d112 6
a117 6
  Display		*pDisplay;
  WMMsgQueueRec		wmMsgQueue;
  Atom			atmWmProtos;
  Atom			atmWmDelete;
  Atom			atmPrivMap;
  Bool			fAllowOtherWM;
d121 3
a123 3
  DWORD			dwScreen;
  WMInfoPtr		pWMInfo;
  pthread_mutex_t	*ppmServerStarted;
d127 5
a131 5
  Display		*pDisplay;
  DWORD			dwScreen;
  WMInfoPtr		pWMInfo;
  pthread_mutex_t	*ppmServerStarted;
  HWND			hwndScreen;
a133 1

d139 1
a139 1
extern void ErrorF (const char* /*f*/, ...);
d146 1
a146 1
PushMessage (WMMsgQueuePtr pQueue, WMMsgNodePtr pNode);
d148 1
a148 2
static WMMsgNodePtr
PopMessage (WMMsgQueuePtr pQueue, WMInfoPtr pWMInfo);
d151 1
a151 1
InitQueue (WMMsgQueuePtr pQueue);
d154 1
a154 1
GetWindowName (Display * pDpy, Window iWin, wchar_t **ppName);
d157 1
a157 1
SendXMessage (Display *pDisplay, Window iWin, Atom atmType, long nData);
d160 1
a160 1
UpdateName (WMInfoPtr pWMInfo, Window iWindow);
d162 1
a162 2
static void*
winMultiWindowWMProc (void* pArg);
d165 1
a165 1
winMultiWindowWMErrorHandler (Display *pDisplay, XErrorEvent *pErr);
d168 1
a168 1
winMultiWindowWMIOErrorHandler (Display *pDisplay);
d170 1
a170 2
static void *
winMultiWindowXMsgProc (void *pArg);
d173 1
a173 1
winMultiWindowXMsgProcErrorHandler (Display *pDisplay, XErrorEvent *pErr);
d176 1
a176 1
winMultiWindowXMsgProcIOErrorHandler (Display *pDisplay);
d179 1
a179 1
winRedirectErrorHandler (Display *pDisplay, XErrorEvent *pErr);
d182 1
a182 1
winInitMultiWindowWM (WMInfoPtr pWMInfo, WMProcArgPtr pProcArg);
d186 1
a186 1
PreserveWin32Stack(WMInfoPtr pWMInfo, Window iWindow, UINT direction);
d190 3
a192 1
CheckAnotherWindowManager (Display *pDisplay, DWORD dwScreen, Bool fAllowOtherWM);
d195 1
a195 1
winApplyHints (Display *pDisplay, Window iWindow, HWND hWnd, HWND *zstyle);
d198 1
a198 1
winUpdateWindowPosition (HWND hWnd, Bool reshape, HWND *zstyle);
d204 9
a212 5
static jmp_buf			g_jmpWMEntry;
static jmp_buf			g_jmpXMsgProcEntry;
static Bool			g_shutdown = FALSE;
static Bool			redirectError = FALSE;
static Bool			g_fAnotherWMRunning = FALSE;
d219 1
a219 1
PushMessage (WMMsgQueuePtr pQueue, WMMsgNodePtr pNode)
d222 2
a223 2
  /* Lock the queue mutex */
  pthread_mutex_lock (&pQueue->pmMutex);
d225 4
a228 5
  pNode->pNext = NULL;
  
  if (pQueue->pTail != NULL)
    {
      pQueue->pTail->pNext = pNode;
d230 4
a233 5
  pQueue->pTail = pNode;
  
  if (pQueue->pHead == NULL)
    {
      pQueue->pHead = pNode;
a235 1

d237 1
a237 2
  switch (pNode->msg.msg)
    {
d239 2
a240 2
      ErrorF ("\tWM_WM_MOVE\n");
      break;
d242 2
a243 2
      ErrorF ("\tWM_WM_SIZE\n");
      break;
d245 2
a246 2
      ErrorF ("\tWM_WM_RAISE\n");
      break;
d248 2
a249 2
      ErrorF ("\tWM_WM_LOWER\n");
      break;
d251 2
a252 2
      ErrorF ("\tWM_WM_MAP\n");
      break;
d254 2
a255 2
      ErrorF ("\tWM_WM_MAP2\n");
      break;
d257 2
a258 2
      ErrorF ("\tWM_WM_MAP3\n");
      break;
d260 2
a261 2
      ErrorF ("\tWM_WM_UNMAP\n");
      break;
d263 2
a264 2
      ErrorF ("\tWM_WM_KILL\n");
      break;
d266 2
a267 2
      ErrorF ("\tWM_WM_ACTIVATE\n");
      break;
d269 2
a270 2
      ErrorF ("\tUnknown Message.\n");
      break;
d274 2
a275 2
  /* Increase the count of elements in the queue by one */
  ++(pQueue->nQueueSize);
d277 2
a278 2
  /* Release the queue mutex */
  pthread_mutex_unlock (&pQueue->pmMutex);
d280 2
a281 2
  /* Signal that the queue is not empty */
  pthread_cond_signal (&pQueue->pcNotEmpty);
a283 1

d290 1
a290 1
QueueSize (WMMsgQueuePtr pQueue)
d292 6
a297 6
  WMMsgNodePtr		pNode;
  int			nSize = 0;
  
  /* Loop through all elements in the queue */
  for (pNode = pQueue->pHead; pNode != NULL; pNode = pNode->pNext)
    ++nSize;
d299 1
a299 1
  return nSize;
a302 1

d308 1
a308 1
PopMessage (WMMsgQueuePtr pQueue, WMInfoPtr pWMInfo)
d310 1
a310 1
  WMMsgNodePtr		pNode;
d312 2
a313 2
  /* Lock the queue mutex */
  pthread_mutex_lock (&pQueue->pmMutex);
d315 3
a317 4
  /* Wait for --- */
  while (pQueue->pHead == NULL)
    {
      pthread_cond_wait (&pQueue->pcNotEmpty, &pQueue->pmMutex);
d319 4
a322 5
  
  pNode = pQueue->pHead;
  if (pQueue->pHead != NULL)
    {
      pQueue->pHead = pQueue->pHead->pNext;
d325 2
a326 3
  if (pQueue->pTail == pNode)
    {
      pQueue->pTail = NULL;
d329 2
a330 2
  /* Drop the number of elements in the queue by one */
  --(pQueue->nQueueSize);
d333 1
a333 1
  ErrorF ("Queue Size %d %d\n", pQueue->nQueueSize, QueueSize(pQueue));
a334 3
  
  /* Release the queue mutex */
  pthread_mutex_unlock (&pQueue->pmMutex);
d336 4
a339 1
  return pNode;
a341 1

d348 1
a348 1
HaveMessage (WMMsgQueuePtr pQueue, UINT msg, Window iWindow)
d350 5
a354 6
  WMMsgNodePtr pNode;
  
  for (pNode = pQueue->pHead; pNode != NULL; pNode = pNode->pNext)
    {
      if (pNode->msg.msg==msg && pNode->msg.iWindow==iWindow)
	return True;
d356 2
a357 2
  
  return False;
a360 1

d366 2
a367 2
Bool
InitQueue (WMMsgQueuePtr pQueue)
d369 4
a372 5
  /* Check if the pQueue pointer is NULL */
  if (pQueue == NULL)
    {
      ErrorF ("InitQueue - pQueue is NULL.  Exiting.\n");
      return FALSE;
d375 3
a377 3
  /* Set the head and tail to NULL */
  pQueue->pHead = NULL;
  pQueue->pTail = NULL;
d379 2
a380 2
  /* There are no elements initially */
  pQueue->nQueueSize = 0;
d383 2
a384 2
  ErrorF ("InitQueue - Queue Size %d %d\n", pQueue->nQueueSize,
	  QueueSize(pQueue));
d387 1
a387 1
  ErrorF ("InitQueue - Calling pthread_mutex_init\n");
d389 2
a390 2
  /* Create synchronization objects */
  pthread_mutex_init (&pQueue->pmMutex, NULL);
d392 2
a393 2
  ErrorF ("InitQueue - pthread_mutex_init returned\n");
  ErrorF ("InitQueue - Calling pthread_cond_init\n");
d395 1
a395 1
  pthread_cond_init (&pQueue->pcNotEmpty, NULL);
d397 1
a397 1
  ErrorF ("InitQueue - pthread_cond_init returned\n");
d399 1
a399 1
  return TRUE;
a401 1

d407 1
a407 1
GetWindowName (Display *pDisplay, Window iWin, wchar_t **ppName)
d409 6
a414 6
  int			nResult, nNum;
  char			**ppList;
  char			*pszReturnData;
  int			iLen, i;
  XTextProperty		xtpName;
  
d416 1
a416 1
  ErrorF ("GetWindowName\n");
d419 2
a420 2
  /* Intialize ppName to NULL */
  *ppName = NULL;
d422 3
a424 4
  /* Try to get --- */
  nResult = XGetWMName (pDisplay, iWin, &xtpName);
  if (!nResult || !xtpName.value || !xtpName.nitems)
    {
d426 1
a426 1
      ErrorF ("GetWindowName - XGetWMName failed.  No name.\n");
d428 1
a428 1
      return;
d431 21
a451 19
   if (Xutf8TextPropertyToTextList (pDisplay, &xtpName, &ppList, &nNum) >= Success && nNum > 0 && *ppList)
   {
 	iLen = 0;
 	for (i = 0; i < nNum; i++) iLen += strlen(ppList[i]);
 	pszReturnData = (char *) malloc (iLen + 1);
 	pszReturnData[0] = '\0';
 	for (i = 0; i < nNum; i++) strcat (pszReturnData, ppList[i]);
 	if (ppList) XFreeStringList (ppList);
   }
   else
   {
 	pszReturnData = (char *) malloc (1);
 	pszReturnData[0] = '\0';
   }
   iLen = MultiByteToWideChar (CP_UTF8, 0, pszReturnData, -1, NULL, 0);
   *ppName = (wchar_t*)malloc(sizeof(wchar_t)*(iLen + 1));
   MultiByteToWideChar (CP_UTF8, 0, pszReturnData, -1, *ppName, iLen);
   XFree (xtpName.value);
   free (pszReturnData);
d454 1
a454 1
  ErrorF ("GetWindowName - Returning\n");
a457 1

d463 1
a463 1
SendXMessage (Display *pDisplay, Window iWin, Atom atmType, long nData)
d465 1
a465 1
  XEvent		e;
d467 7
a473 7
  /* Prepare the X event structure */
  e.type = ClientMessage;
  e.xclient.window = iWin;
  e.xclient.message_type = atmType;
  e.xclient.format = 32;
  e.xclient.data.l[0] = nData;
  e.xclient.data.l[1] = CurrentTime;
d475 2
a476 2
  /* Send the event to X */
  return XSendEvent (pDisplay, iWin, False, NoEventMask, &e);
a478 1

d484 1
a484 1
UpdateName (WMInfoPtr pWMInfo, Window iWindow)
d486 36
a521 47
  wchar_t		*pszName;
  Atom			atmType;
  int			fmtRet;
  unsigned long		items, remain;
  HWND			*retHwnd, hWnd;
  XWindowAttributes	attr;

  hWnd = 0;

  /* See if we can get the cached HWND for this window... */
  if (XGetWindowProperty (pWMInfo->pDisplay,
			  iWindow,
			  pWMInfo->atmPrivMap,
			  0,
			  1,
			  False,
			  XA_INTEGER,//pWMInfo->atmPrivMap,
			  &atmType,
			  &fmtRet,
			  &items,
			  &remain,
			  (unsigned char **) &retHwnd) == Success)
    {
      if (retHwnd)
	{
	  hWnd = *retHwnd;
	  XFree (retHwnd);
	}
    }
  
  /* Some sanity checks */
  if (!hWnd) return;
  if (!IsWindow (hWnd)) return;

  /* Set the Windows window name */
  GetWindowName (pWMInfo->pDisplay, iWindow, &pszName);
  if (pszName)
    {
      /* Get the window attributes */
      XGetWindowAttributes (pWMInfo->pDisplay,
			    iWindow,
			    &attr);
      if (!attr.override_redirect)
	{
	  SetWindowTextW (hWnd, pszName);
	  winUpdateIcon (iWindow);
	}
d523 1
a523 1
      free (pszName);
a526 1

d535 25
a559 54
  Atom                  atmType;
  int                   fmtRet;
  unsigned long         items, remain;
  HWND                  hWnd, *retHwnd;
  DWORD                 myWinProcID, winProcID;
  Window                xWindow;
  WINDOWPLACEMENT       wndPlace;
  
  hWnd = NULL;
  /* See if we can get the cached HWND for this window... */
  if (XGetWindowProperty (pWMInfo->pDisplay,
			  iWindow,
			  pWMInfo->atmPrivMap,
			  0,
			  1,
			  False,
			  XA_INTEGER,//pWMInfo->atmPrivMap,
			  &atmType,
			  &fmtRet,
			  &items,
			  &remain,
			  (unsigned char **) &retHwnd) == Success)
    {
      if (retHwnd)
	{
	  hWnd = *retHwnd;
	  XFree (retHwnd);
	}
    }
  
  if (!hWnd) return;
  
  GetWindowThreadProcessId (hWnd, &myWinProcID);
  hWnd = GetNextWindow (hWnd, direction);
  
  while (hWnd) {
    GetWindowThreadProcessId (hWnd, &winProcID);
    if (winProcID == myWinProcID)
      {
	wndPlace.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement (hWnd, &wndPlace);
	if ( !(wndPlace.showCmd==SW_HIDE ||
	       wndPlace.showCmd==SW_MINIMIZE) )
	  {
	    xWindow = (Window)GetProp (hWnd, WIN_WID_PROP);
	    if (xWindow)
	      {
		if (direction==GW_HWNDPREV)
		  XRaiseWindow (pWMInfo->pDisplay, xWindow);
		else
		  XLowerWindow (pWMInfo->pDisplay, xWindow);
	      }
	  }
      }
d561 19
a579 1
  }
d581 1
a581 2
#endif /* PreserveWin32Stack */

d588 1
a588 1
winMultiWindowWMProc (void *pArg)
d590 6
a595 6
  WMProcArgPtr		pProcArg = (WMProcArgPtr)pArg;
  WMInfoPtr		pWMInfo = pProcArg->pWMInfo;
  
  /* Initialize the Window Manager */
  winInitMultiWindowWM (pWMInfo, pProcArg);
  
d597 1
a597 1
  ErrorF ("winMultiWindowWMProc ()\n");
d600 8
a607 4
  /* Loop until we explicitly break out */
  for (;;)
    {
      WMMsgNodePtr	pNode;
d609 8
a616 15
      if(g_fAnotherWMRunning)/* Another Window manager exists. */
	{
	  Sleep (1000);
	  continue;
	}

      /* Pop a message off of our queue */
      pNode = PopMessage (&pWMInfo->wmMsgQueue, pWMInfo);
      if (pNode == NULL)
	{
	  /* Bail if PopMessage returns without a message */
	  /* NOTE: Remember that PopMessage is a blocking function. */
	  ErrorF ("winMultiWindowWMProc - Queue is Empty?  Exiting.\n");
	  pthread_exit (NULL);
	}
d619 2
a620 2
      ErrorF ("winMultiWindowWMProc - %d ms MSG: %d ID: %d\n",
	      GetTickCount (), (int)pNode->msg.msg, (int)pNode->msg.dwID);
d623 2
a624 3
      /* Branch on the message type */
      switch (pNode->msg.msg)
	{
d626 3
a628 3
	case WM_WM_MOVE:
	  ErrorF ("\tWM_WM_MOVE\n");
	  break;
d630 3
a632 3
	case WM_WM_SIZE:
	  ErrorF ("\tWM_WM_SIZE\n");
	  break;
d635 1
a635 1
	case WM_WM_RAISE:
d637 1
a637 1
	  ErrorF ("\tWM_WM_RAISE\n");
d639 2
a640 2
	  /* Raise the window */
	  XRaiseWindow (pWMInfo->pDisplay, pNode->msg.iWindow);
d642 1
a642 1
	  PreserveWin32Stack (pWMInfo, pNode->msg.iWindow, GW_HWNDPREV);
d644 1
a644 1
	  break;
d646 1
a646 1
	case WM_WM_LOWER:
d648 1
a648 1
	  ErrorF ("\tWM_WM_LOWER\n");
d651 3
a653 3
	  /* Lower the window */
	  XLowerWindow (pWMInfo->pDisplay, pNode->msg.iWindow);
	  break;
d655 1
a655 1
	case WM_WM_MAP:
d657 1
a657 1
	  ErrorF ("\tWM_WM_MAP\n");
d659 8
a666 12
	  /* Put a note as to the HWND associated with this Window */
	  XChangeProperty (pWMInfo->pDisplay,
			   pNode->msg.iWindow,
			   pWMInfo->atmPrivMap,
			   XA_INTEGER,//pWMInfo->atmPrivMap,
			   32,
			   PropModeReplace,
			   (unsigned char *) &(pNode->msg.hwndWindow),
			   1);
	  UpdateName (pWMInfo, pNode->msg.iWindow);
	  winUpdateIcon (pNode->msg.iWindow);
	  break;
d668 1
a668 1
	case WM_WM_MAP2:
d670 1
a670 1
	  ErrorF ("\tWM_WM_MAP2\n");
d672 5
a676 9
	  XChangeProperty (pWMInfo->pDisplay,
			   pNode->msg.iWindow,
			   pWMInfo->atmPrivMap,
			   XA_INTEGER,//pWMInfo->atmPrivMap,
			   32,
			   PropModeReplace,
			   (unsigned char *) &(pNode->msg.hwndWindow),
			   1);
	  break;
d678 1
a678 1
	case WM_WM_MAP3:
d680 1
a680 1
	  ErrorF ("\tWM_WM_MAP3\n");
d682 15
a696 17
	  /* Put a note as to the HWND associated with this Window */
	  XChangeProperty (pWMInfo->pDisplay,
			   pNode->msg.iWindow,
			   pWMInfo->atmPrivMap,
			   XA_INTEGER,//pWMInfo->atmPrivMap,
			   32,
			   PropModeReplace,
			   (unsigned char *) &(pNode->msg.hwndWindow),
			   1);
	  UpdateName (pWMInfo, pNode->msg.iWindow);
	  winUpdateIcon (pNode->msg.iWindow);
	  {
	    HWND zstyle = HWND_NOTOPMOST;
	    winApplyHints (pWMInfo->pDisplay, pNode->msg.iWindow, pNode->msg.hwndWindow, &zstyle);
	    winUpdateWindowPosition (pNode->msg.hwndWindow, TRUE, &zstyle);
	  }
	  break;
d698 1
a698 1
	case WM_WM_UNMAP:
d700 1
a700 1
	  ErrorF ("\tWM_WM_UNMAP\n");
a701 4
	  
	  /* Unmap the window */
	  XUnmapWindow (pWMInfo->pDisplay, pNode->msg.iWindow);
	  break;
d703 5
a707 1
	case WM_WM_KILL:
d709 1
a709 1
	  ErrorF ("\tWM_WM_KILL\n");
d711 23
a733 28
	  {
	    int				i, n, found = 0;
	    Atom			*protocols;
	    
	    /* --- */
	    if (XGetWMProtocols (pWMInfo->pDisplay,
				 pNode->msg.iWindow,
				 &protocols,
				 &n))
	      {
		for (i = 0; i < n; ++i)
		  if (protocols[i] == pWMInfo->atmWmDelete)
		    ++found;
		
		XFree (protocols);
	      }

	    /* --- */
	    if (found)
	      SendXMessage (pWMInfo->pDisplay,
			    pNode->msg.iWindow,
			    pWMInfo->atmWmProtos,
			    pWMInfo->atmWmDelete);
	    else
	      XKillClient (pWMInfo->pDisplay,
			   pNode->msg.iWindow);
	  }
	  break;
d735 1
a735 1
	case WM_WM_ACTIVATE:
d737 1
a737 1
	  ErrorF ("\tWM_WM_ACTIVATE\n");
d739 42
a780 43
	  
	  /* Set the input focus */
	  XSetInputFocus (pWMInfo->pDisplay,
			  pNode->msg.iWindow,
			  RevertToPointerRoot,
			  CurrentTime);
	  break;

	case WM_WM_NAME_EVENT:
	  UpdateName (pWMInfo, pNode->msg.iWindow);
	  break;

	case WM_WM_HINTS_EVENT:
	  winUpdateIcon (pNode->msg.iWindow);
	  break;

	case WM_WM_CHANGE_STATE:
	  /* Minimize the window in Windows */
	  winMinimizeWindow (pNode->msg.iWindow);
	  break;

	default:
	  ErrorF ("winMultiWindowWMProc - Unknown Message.  Exiting.\n");
	  pthread_exit (NULL);
	  break;
	}

      /* Free the retrieved message */
      free (pNode);

      /* Flush any pending events on our display */
      XFlush (pWMInfo->pDisplay);
    }

  /* Free the condition variable */
  pthread_cond_destroy (&pWMInfo->wmMsgQueue.pcNotEmpty);
  
  /* Free the mutex variable */
  pthread_mutex_destroy (&pWMInfo->wmMsgQueue.pmMutex);
  
  /* Free the passed-in argument */
  free (pProcArg);
  
d782 1
a782 1
  ErrorF("-winMultiWindowWMProc ()\n");
d784 1
a784 1
  return NULL;
a786 1

d792 1
a792 1
winMultiWindowXMsgProc (void *pArg)
d794 10
a803 10
  winWMMessageRec       msg;
  XMsgProcArgPtr	pProcArg = (XMsgProcArgPtr) pArg;
  char			pszDisplay[512];
  int                   iRetries;
  XEvent		event;
  Atom                  atmWmName;
  Atom                  atmWmHints;
  Atom			atmWmChange;
  int			iReturn;
  XIconSize		*xis;
d805 1
a805 1
  ErrorF ("winMultiWindowXMsgProc - Hello\n");
d807 4
a810 5
  /* Check that argument pointer is not invalid */
  if (pProcArg == NULL)
    {
      ErrorF ("winMultiWindowXMsgProc - pProcArg is NULL.  Exiting.\n");
      pthread_exit (NULL);
d813 1
a813 1
  ErrorF ("winMultiWindowXMsgProc - Calling pthread_mutex_lock ()\n");
d815 6
a820 8
  /* Grab the server started mutex - pause until we get it */
  iReturn = pthread_mutex_lock (pProcArg->ppmServerStarted);
  if (iReturn != 0)
    {
      ErrorF ("winMultiWindowXMsgProc - pthread_mutex_lock () failed: %d.  "
	      "Exiting.\n",
	      iReturn);
      pthread_exit (NULL);
d823 1
a823 1
  ErrorF ("winMultiWindowXMsgProc - pthread_mutex_lock () returned.\n");
d825 4
a828 5
  /* Allow multiple threads to access Xlib */
  if (XInitThreads () == 0)
    {
      ErrorF ("winMultiWindowXMsgProc - XInitThreads () failed.  Exiting.\n");
      pthread_exit (NULL);
d831 3
a833 4
  /* See if X supports the current locale */
  if (XSupportsLocale () == False)
    {
      ErrorF ("winMultiWindowXMsgProc - Warning: locale not supported by X\n");
d836 10
a845 2
  /* Release the server started mutex */
  pthread_mutex_unlock (pProcArg->ppmServerStarted);
d847 2
a848 1
  ErrorF ("winMultiWindowXMsgProc - pthread_mutex_unlock () returned.\n");
d850 6
a855 11
  /* Set jump point for IO Error exits */
  iReturn = setjmp (g_jmpXMsgProcEntry);
  
  /* Check if we should continue operations */
  if (iReturn != WIN_JMP_ERROR_IO
      && iReturn != WIN_JMP_OKAY)
    {
      /* setjmp returned an unknown value, exit */
      ErrorF ("winInitMultiWindowXMsgProc - setjmp returned: %d.  Exiting.\n",
	      iReturn);
      pthread_exit (NULL);
d857 3
a859 4
  else if (iReturn == WIN_JMP_ERROR_IO)
    {
      ErrorF ("winInitMultiWindowXMsgProc - Caught IO Error.  Exiting.\n");
      pthread_exit (NULL);
d862 3
a864 3
  /* Install our error handler */
  XSetErrorHandler (winMultiWindowXMsgProcErrorHandler);
  XSetIOErrorHandler (winMultiWindowXMsgProcIOErrorHandler);
d866 2
a867 3
  /* Setup the display connection string x */
  snprintf (pszDisplay,
	    512, "127.0.0.1:%s.%d", display, (int)pProcArg->dwScreen);
d869 2
a870 2
  /* Print the display connection string */
  ErrorF ("winMultiWindowXMsgProc - DISPLAY=%s\n", pszDisplay);
d872 2
a873 5
  /* Use our generated cookie for authentication */
  winSetAuthorization();
  
  /* Initialize retry count */
  iRetries = 0;
d875 13
a887 25
  /* Open the X display */
  do
    {
      /* Try to open the display */
      pProcArg->pDisplay = XOpenDisplay (pszDisplay);
      if (pProcArg->pDisplay == NULL)
	{
	  ErrorF ("winMultiWindowXMsgProc - Could not open display, try: %d, "
		  "sleeping: %d\n",
		  iRetries + 1, WIN_CONNECT_DELAY);
	  ++iRetries;
	  sleep (WIN_CONNECT_DELAY);
	  continue;
	}
      else
	break;
    }
  while (pProcArg->pDisplay == NULL && iRetries < WIN_CONNECT_RETRIES);
  
  /* Make sure that the display opened */
  if (pProcArg->pDisplay == NULL)
    {
      ErrorF ("winMultiWindowXMsgProc - Failed opening the display.  "
	      "Exiting.\n");
      pthread_exit (NULL);
d889 1
d891 71
a961 2
  ErrorF ("winMultiWindowXMsgProc - XOpenDisplay () returned and "
	  "successfully opened the display.\n");
d963 74
a1036 2
  /* Check if another window manager is already running */
  g_fAnotherWMRunning = CheckAnotherWindowManager (pProcArg->pDisplay, pProcArg->dwScreen, pProcArg->pWMInfo->fAllowOtherWM);
d1038 19
a1056 6
  if (g_fAnotherWMRunning && !pProcArg->pWMInfo->fAllowOtherWM)
    {
      ErrorF ("winMultiWindowXMsgProc - "
          "another window manager is running.  Exiting.\n");
      pthread_exit (NULL);
    }
d1058 2
a1059 33
  /* Set up the supported icon sizes */
  xis = XAllocIconSize ();
  if (xis)
    {
      xis->min_width = xis->min_height = 16;
      xis->max_width = xis->max_height = 48;
      xis->width_inc = xis->height_inc = 16;
      XSetIconSizes (pProcArg->pDisplay,
		     RootWindow (pProcArg->pDisplay, pProcArg->dwScreen),
		     xis,
		     1);
      XFree (xis);
    }

  atmWmName   = XInternAtom (pProcArg->pDisplay,
			     "WM_NAME",
			     False);
  atmWmHints   = XInternAtom (pProcArg->pDisplay,
			      "WM_HINTS",
			      False);
  atmWmChange  = XInternAtom (pProcArg->pDisplay,
			      "WM_CHANGE_STATE",
			      False);

  /*
    iiimxcf had a bug until 2009-04-27, assuming that the
    WM_STATE atom exists, causing clients to fail with
    a BadAtom X error if it doesn't.

    Since this is on in the default Solaris 10 install,
    workaround this by making sure it does exist...
   */
  XInternAtom(pProcArg->pDisplay, "WM_STATE", 0);
d1061 6
a1066 5
  /* Loop until we explicitly break out */
  while (1)
    {
      if (g_shutdown)
        break;
d1068 2
a1069 75
      if (pProcArg->pWMInfo->fAllowOtherWM && !XPending (pProcArg->pDisplay))
	{
	  if (CheckAnotherWindowManager (pProcArg->pDisplay, pProcArg->dwScreen, TRUE))
	    {
	      if (!g_fAnotherWMRunning)
		{
		  g_fAnotherWMRunning = TRUE;
		  SendMessage(*(HWND*)pProcArg->hwndScreen, WM_UNMANAGE, 0, 0);
		}
	    }
	  else
	    {
	      if (g_fAnotherWMRunning)
		{
		  g_fAnotherWMRunning = FALSE;
		  SendMessage(*(HWND*)pProcArg->hwndScreen, WM_MANAGE, 0, 0);
		}
	    }
	  Sleep (500);
	  continue;
	}

      /* Fetch next event */
      XNextEvent (pProcArg->pDisplay, &event);

      /* Branch on event type */
      if (event.type == CreateNotify)
	{
	  XWindowAttributes	attr;

	  XSelectInput (pProcArg->pDisplay,
			event.xcreatewindow.window,
			PropertyChangeMask);

	  /* Get the window attributes */
	  XGetWindowAttributes (pProcArg->pDisplay,
				event.xcreatewindow.window,
				&attr);

	  if (!attr.override_redirect)
	    XSetWindowBorderWidth(pProcArg->pDisplay,
				  event.xcreatewindow.window,
				  0);
	}
      else if (event.type == MapNotify)
        {
          /* Fake a reparentNotify event as SWT/Motif expects a
             Window Manager to reparent a top-level window when
             it is mapped and waits until they do.

             We don't actually need to reparent, as the frame is
             a native window, not an X window

             We do this on MapNotify, not MapRequest like a real
             Window Manager would, so we don't have do get involved
             in actually mapping the window via it's (non-existent)
             parent...

             See sourceware bugzilla #9848
          */

          XWindowAttributes attr;
          Window root;
          Window parent;
          Window *children;
          unsigned int nchildren;

          if (XGetWindowAttributes(event.xmap.display,
                                   event.xmap.window,
                                   &attr) &&
              XQueryTree(event.xmap.display,
                         event.xmap.window,
                         &root, &parent, &children, &nchildren))
            {
              if (children) XFree(children);
d1071 2
a1072 21
              /*
                It's a top-level window if the parent window is a root window
                Only non-override_redirect windows can get reparented
              */
              if ((attr.root == parent) && !event.xmap.override_redirect)
                {
                  XEvent event_send;

                  event_send.type = ReparentNotify;
                  event_send.xreparent.event = event.xmap.window;
                  event_send.xreparent.window = event.xmap.window;
                  event_send.xreparent.parent = parent;
                  event_send.xreparent.x = attr.x;
                  event_send.xreparent.y = attr.y;

                  XSendEvent(event.xmap.display,
                             event.xmap.window,
                             True, StructureNotifyMask,
                             &event_send);
                }
            }
d1074 11
a1084 23
      else if (event.type == ConfigureNotify)
        {
          if (!event.xconfigure.send_event)
            {
              /*
                Java applications using AWT on JRE 1.6.0 break with non-reparenting WMs AWT
                doesn't explicitly know about (See sun bug #6434227)

                XDecoratedPeer.handleConfigureNotifyEvent() only processes non-synthetic
                ConfigureNotify events to update window location if it's identified the
                WM as a non-reparenting WM it knows about (compiz or lookingglass)

                Rather than tell all sorts of lies to get XWM to recognize us as one of
                those, simply send a synthetic ConfigureNotify for every non-synthetic one
               */
              XEvent event_send = event;
              event_send.xconfigure.send_event = TRUE;
              event_send.xconfigure.event = event.xconfigure.window;
              XSendEvent(event.xconfigure.display,
                         event.xconfigure.window,
                         True, StructureNotifyMask,
                         &event_send);
            }
d1086 5
a1090 40
      else if (event.type == PropertyNotify
	       && event.xproperty.atom == atmWmName)
	{
	  memset (&msg, 0, sizeof (msg));

	  msg.msg = WM_WM_NAME_EVENT;
	  msg.iWindow = event.xproperty.window;

	  /* Other fields ignored */
	  winSendMessageToWM (pProcArg->pWMInfo, &msg);
	}
      else if (event.type == PropertyNotify
	       && event.xproperty.atom == atmWmHints)
	{
	  memset (&msg, 0, sizeof (msg));

	  msg.msg = WM_WM_HINTS_EVENT;
	  msg.iWindow = event.xproperty.window;

	  /* Other fields ignored */
	  winSendMessageToWM (pProcArg->pWMInfo, &msg);
	}
      else if (event.type == ClientMessage
	       && event.xclient.message_type == atmWmChange
	       && event.xclient.data.l[0] == IconicState)
	{
	  ErrorF ("winMultiWindowXMsgProc - WM_CHANGE_STATE - IconicState\n");

	  memset (&msg, 0, sizeof (msg));

	  msg.msg = WM_WM_CHANGE_STATE;
	  msg.iWindow = event.xclient.window;

	  winSendMessageToWM (pProcArg->pWMInfo, &msg);
	}
    }

  XCloseDisplay (pProcArg->pDisplay);
  pthread_exit (NULL);
  return NULL;
a1092 1

d1100 55
a1154 58
winInitWM (void **ppWMInfo,
	   pthread_t *ptWMProc,
	   pthread_t *ptXMsgProc,
	   pthread_mutex_t *ppmServerStarted,
	   int dwScreen,
	   HWND hwndScreen,
	   BOOL allowOtherWM)
{
  WMProcArgPtr		pArg = (WMProcArgPtr) malloc (sizeof(WMProcArgRec));
  WMInfoPtr		pWMInfo = (WMInfoPtr) malloc (sizeof(WMInfoRec));
  XMsgProcArgPtr	pXMsgArg = (XMsgProcArgPtr) malloc (sizeof(XMsgProcArgRec));

  /* Bail if the input parameters are bad */
  if (pArg == NULL || pWMInfo == NULL)
    {
      ErrorF ("winInitWM - malloc failed.\n");
      return FALSE;
    }
  
  /* Zero the allocated memory */
  ZeroMemory (pArg, sizeof (WMProcArgRec));
  ZeroMemory (pWMInfo, sizeof (WMInfoRec));
  ZeroMemory (pXMsgArg, sizeof (XMsgProcArgRec));

  /* Set a return pointer to the Window Manager info structure */
  *ppWMInfo = pWMInfo;
  pWMInfo->fAllowOtherWM = allowOtherWM;

  /* Setup the argument structure for the thread function */
  pArg->dwScreen = dwScreen;
  pArg->pWMInfo = pWMInfo;
  pArg->ppmServerStarted = ppmServerStarted;
  
  /* Intialize the message queue */
  if (!InitQueue (&pWMInfo->wmMsgQueue))
    {
      ErrorF ("winInitWM - InitQueue () failed.\n");
      return FALSE;
    }
  
  /* Spawn a thread for the Window Manager */
  if (pthread_create (ptWMProc, NULL, winMultiWindowWMProc, pArg))
    {
      /* Bail if thread creation failed */
      ErrorF ("winInitWM - pthread_create failed for Window Manager.\n");
      return FALSE;
    }

  /* Spawn the XNextEvent thread, will send messages to WM */
  pXMsgArg->dwScreen = dwScreen;
  pXMsgArg->pWMInfo = pWMInfo;
  pXMsgArg->ppmServerStarted = ppmServerStarted;
  pXMsgArg->hwndScreen = hwndScreen;
  if (pthread_create (ptXMsgProc, NULL, winMultiWindowXMsgProc, pXMsgArg))
    {
      /* Bail if thread creation failed */
      ErrorF ("winInitWM - pthread_create failed on XMSG.\n");
      return FALSE;
d1158 1
a1158 1
  winDebug ("winInitWM - Returning.\n");
d1161 1
a1161 1
  return TRUE;
a1163 1

d1169 1
a1169 1
winInitMultiWindowWM (WMInfoPtr pWMInfo, WMProcArgPtr pProcArg)
d1171 3
a1173 3
  int                   iRetries = 0;
  char			pszDisplay[512];
  int			iReturn;
d1175 1
a1175 1
  ErrorF ("winInitMultiWindowWM - Hello\n");
d1177 4
a1180 5
  /* Check that argument pointer is not invalid */
  if (pProcArg == NULL)
    {
      ErrorF ("winInitMultiWindowWM - pProcArg is NULL.  Exiting.\n");
      pthread_exit (NULL);
d1183 1
a1183 1
  ErrorF ("winInitMultiWindowWM - Calling pthread_mutex_lock ()\n");
d1185 6
a1190 8
  /* Grab our garbage mutex to satisfy pthread_cond_wait */
  iReturn = pthread_mutex_lock (pProcArg->ppmServerStarted);
  if (iReturn != 0)
    {
      ErrorF ("winInitMultiWindowWM - pthread_mutex_lock () failed: %d.  "
	      "Exiting.\n",
	      iReturn);
      pthread_exit (NULL);
d1193 1
a1193 1
  ErrorF ("winInitMultiWindowWM - pthread_mutex_lock () returned.\n");
d1195 9
a1203 5
  /* Allow multiple threads to access Xlib */
  if (XInitThreads () == 0)
    {
      ErrorF ("winInitMultiWindowWM - XInitThreads () failed.  Exiting.\n");
      pthread_exit (NULL);
d1206 24
a1229 4
  /* See if X supports the current locale */
  if (XSupportsLocale () == False)
    {
      ErrorF ("winInitMultiWindowWM - Warning: Locale not supported by X.\n");
d1232 3
a1234 2
  /* Release the server started mutex */
  pthread_mutex_unlock (pProcArg->ppmServerStarted);
d1236 2
a1237 1
  ErrorF ("winInitMultiWindowWM - pthread_mutex_unlock () returned.\n");
d1239 16
a1254 11
  /* Set jump point for IO Error exits */
  iReturn = setjmp (g_jmpWMEntry);
  
  /* Check if we should continue operations */
  if (iReturn != WIN_JMP_ERROR_IO
      && iReturn != WIN_JMP_OKAY)
    {
      /* setjmp returned an unknown value, exit */
      ErrorF ("winInitMultiWindowWM - setjmp returned: %d.  Exiting.\n",
	      iReturn);
      pthread_exit (NULL);
d1256 7
a1262 4
  else if (iReturn == WIN_JMP_ERROR_IO)
    {
      ErrorF ("winInitMultiWindowWM - Caught IO Error.  Exiting.\n");
      pthread_exit (NULL);
d1265 2
a1266 3
  /* Install our error handler */
  XSetErrorHandler (winMultiWindowWMErrorHandler);
  XSetIOErrorHandler (winMultiWindowWMIOErrorHandler);
d1268 5
a1272 6
  /* Setup the display connection string x */
  snprintf (pszDisplay,
	    512,
	    "127.0.0.1:%s.%d",
	    display,
	    (int) pProcArg->dwScreen);
d1274 2
a1275 2
  /* Print the display connection string */
  ErrorF ("winInitMultiWindowWM - DISPLAY=%s\n", pszDisplay);
d1277 2
a1278 2
  /* Use our generated cookie for authentication */
  winSetAuthorization();
d1280 5
a1284 50
  /* Open the X display */
  do
    {
      /* Try to open the display */
      pWMInfo->pDisplay = XOpenDisplay (pszDisplay);
      if (pWMInfo->pDisplay == NULL)
	{
	  ErrorF ("winInitMultiWindowWM - Could not open display, try: %d, "
		  "sleeping: %d\n",
		  iRetries + 1, WIN_CONNECT_DELAY);
	  ++iRetries;
	  sleep (WIN_CONNECT_DELAY);
	  continue;
	}
      else
	break;
    }
  while (pWMInfo->pDisplay == NULL && iRetries < WIN_CONNECT_RETRIES);
  
  /* Make sure that the display opened */
  if (pWMInfo->pDisplay == NULL)
    {
      ErrorF ("winInitMultiWindowWM - Failed opening the display.  "
	      "Exiting.\n");
      pthread_exit (NULL);
    }

  ErrorF ("winInitMultiWindowWM - XOpenDisplay () returned and "
	  "successfully opened the display.\n");
  

  /* Create some atoms */
  pWMInfo->atmWmProtos = XInternAtom (pWMInfo->pDisplay,
				      "WM_PROTOCOLS",
				      False);
  pWMInfo->atmWmDelete = XInternAtom (pWMInfo->pDisplay,
				      "WM_DELETE_WINDOW",
				      False);

  pWMInfo->atmPrivMap  = XInternAtom (pWMInfo->pDisplay,
				      WINDOWSWM_NATIVE_HWND,
				      False);


  if (1) {
    Cursor cursor = XCreateFontCursor (pWMInfo->pDisplay, XC_left_ptr);
    if (cursor)
    {
      XDefineCursor (pWMInfo->pDisplay, DefaultRootWindow(pWMInfo->pDisplay), cursor);
      XFreeCursor (pWMInfo->pDisplay, cursor);
a1285 1
  }
a1287 1

d1293 1
a1293 1
winSendMessageToWM (void *pWMInfo, winWMMessagePtr pMsg)
d1295 2
a1296 2
  WMMsgNodePtr pNode;
  
d1298 1
a1298 1
  ErrorF ("winSendMessageToWM ()\n");
d1300 5
a1304 6
  
  pNode = (WMMsgNodePtr)malloc(sizeof(WMMsgNodeRec));
  if (pNode != NULL)
    {
      memcpy (&pNode->msg, pMsg, sizeof(winWMMessageRec));
      PushMessage (&((WMInfoPtr)pWMInfo)->wmMsgQueue, pNode);
a1307 1

d1313 1
a1313 1
winMultiWindowWMErrorHandler (Display *pDisplay, XErrorEvent *pErr)
d1315 1
a1315 1
  char pszErrorMsg[100];
d1317 9
a1325 13
  if (pErr->request_code == X_ChangeWindowAttributes
      && pErr->error_code == BadAccess)
    {
      ErrorF ("winMultiWindowWMErrorHandler - ChangeWindowAttributes "
	      "BadAccess.\n");
      return 0;
    }
  
  XGetErrorText (pDisplay,
		 pErr->error_code,
		 pszErrorMsg,
		 sizeof (pszErrorMsg));
  ErrorF ("winMultiWindowWMErrorHandler - ERROR: %s\n", pszErrorMsg);
d1327 1
a1327 1
  return 0;
a1329 1

d1335 1
a1335 1
winMultiWindowWMIOErrorHandler (Display *pDisplay)
d1337 1
a1337 1
  ErrorF ("winMultiWindowWMIOErrorHandler!\n\n");
d1339 10
a1348 2
  if (g_shutdown)
    pthread_exit(NULL);
d1350 1
a1350 4
  /* Restart at the main entry point */
  longjmp (g_jmpWMEntry, WIN_JMP_ERROR_IO);
  
  return 0;
a1352 1

d1358 1
a1358 1
winMultiWindowXMsgProcErrorHandler (Display *pDisplay, XErrorEvent *pErr)
d1360 3
a1362 6
  char pszErrorMsg[100];
  
  XGetErrorText (pDisplay,
		 pErr->error_code,
		 pszErrorMsg,
		 sizeof (pszErrorMsg));
d1364 1
a1364 1
  ErrorF ("winMultiWindowXMsgProcErrorHandler - ERROR: %s\n", pszErrorMsg);
d1366 2
a1367 2
  
  return 0;
a1369 1

d1375 1
a1375 1
winMultiWindowXMsgProcIOErrorHandler (Display *pDisplay)
d1377 9
a1385 1
  ErrorF ("winMultiWindowXMsgProcIOErrorHandler!\n\n");
d1387 1
a1387 4
  /* Restart at the main entry point */
  longjmp (g_jmpXMsgProcEntry, WIN_JMP_ERROR_IO);
  
  return 0;
a1389 1

d1395 1
a1395 1
winRedirectErrorHandler (Display *pDisplay, XErrorEvent *pErr)
d1397 2
a1398 2
  redirectError = TRUE;
  return 0;
a1400 1

d1406 2
a1407 1
CheckAnotherWindowManager (Display *pDisplay, DWORD dwScreen, Bool fAllowOtherWM)
d1409 23
a1431 21
  /*
    Try to select the events which only one client at a time is allowed to select.
    If this causes an error, another window manager is already running...
   */
  redirectError = FALSE;
  XSetErrorHandler (winRedirectErrorHandler);
  XSelectInput(pDisplay, RootWindow (pDisplay, dwScreen),
               ResizeRedirectMask | SubstructureRedirectMask | ButtonPressMask);
  XSync (pDisplay, 0);
  XSetErrorHandler (winMultiWindowXMsgProcErrorHandler);

  /*
    Side effect: select the events we are actually interested in...

    If other WMs are not allowed, also select one of the events which only one client
    at a time is allowed to select, so other window managers won't start...
  */
  XSelectInput(pDisplay, RootWindow (pDisplay, dwScreen),
               SubstructureNotifyMask | ( !fAllowOtherWM ? ButtonPressMask : 0));
  XSync (pDisplay, 0);
  return redirectError;
d1439 1
a1439 1
winDeinitMultiWindowWM (void)
d1441 2
a1442 2
  ErrorF ("winDeinitMultiWindowWM - Noting shutdown in progress\n");
  g_shutdown = TRUE;
d1451 2
d1458 1
a1458 1
winApplyHints (Display *pDisplay, Window iWindow, HWND hWnd, HWND *zstyle)
d1460 95
a1554 29
  static Atom		windowState, motif_wm_hints, windowType;
  static Atom		hiddenState, fullscreenState, belowState, aboveState;
  static Atom		dockWindow;
  static int		generation;
  Atom			type, *pAtom = NULL;
  int			format;
  unsigned long		hint = 0, maxmin = 0, style, nitems = 0 , left = 0;
  MwmHints              *mwm_hint = NULL;

  if (!hWnd) return;
  if (!IsWindow (hWnd)) return;

  if (generation != serverGeneration) {
      generation = serverGeneration;
      windowState = XInternAtom(pDisplay, "_NET_WM_STATE", False);
      motif_wm_hints = XInternAtom(pDisplay, "_MOTIF_WM_HINTS", False);
      windowType = XInternAtom(pDisplay, "_NET_WM_WINDOW_TYPE", False);
      hiddenState = XInternAtom(pDisplay, "_NET_WM_STATE_HIDDEN", False);
      fullscreenState = XInternAtom(pDisplay, "_NET_WM_STATE_FULLSCREEN", False);
      belowState = XInternAtom(pDisplay, "_NET_WM_STATE_BELOW", False);
      aboveState = XInternAtom(pDisplay, "_NET_WM_STATE_ABOVE", False);
      dockWindow = XInternAtom(pDisplay, "_NET_WM_WINDOW_TYPE_DOCK", False);
  }

  if (XGetWindowProperty(pDisplay, iWindow, windowState, 0L,
			 1L, False, XA_ATOM, &type, &format,
			 &nitems, &left, (unsigned char **)&pAtom) == Success)
  {
    if (pAtom && nitems == 1)
d1556 25
a1580 14
      if (*pAtom == hiddenState) maxmin |= HINT_MIN;
      else if (*pAtom == fullscreenState) maxmin |= HINT_MAX;
      if (*pAtom == belowState) *zstyle = HWND_BOTTOM;
      else if (*pAtom == aboveState) *zstyle = HWND_TOPMOST;
    }
    if (pAtom) XFree(pAtom);
  }

  nitems = left = 0;
  if (XGetWindowProperty(pDisplay, iWindow, motif_wm_hints, 0L,
			 PropMwmHintsElements, False, motif_wm_hints, &type, &format,
			 &nitems, &left, (unsigned char **)&mwm_hint) == Success)
  {
    if (mwm_hint && nitems == PropMwmHintsElements && (mwm_hint->flags & MwmHintsDecorations))
d1582 21
a1602 37
      if (!mwm_hint->decorations) hint |= HINT_NOFRAME;
      else if (!(mwm_hint->decorations & MwmDecorAll))
      {
	if (mwm_hint->decorations & MwmDecorBorder) hint |= HINT_BORDER;
	if (mwm_hint->decorations & MwmDecorHandle) hint |= HINT_SIZEBOX;
	if (mwm_hint->decorations & MwmDecorTitle) hint |= HINT_CAPTION;
      }
    }
    if (mwm_hint) XFree(mwm_hint);
  }

  nitems = left = 0;
  pAtom = NULL;
  if (XGetWindowProperty(pDisplay, iWindow, windowType, 0L,
			 1L, False, XA_ATOM, &type, &format,
			 &nitems, &left, (unsigned char **)&pAtom) == Success)
  {
    if (pAtom && nitems == 1)
    {
      if (*pAtom == dockWindow)
      {
	hint = (hint & ~HINT_NOFRAME) | HINT_SIZEBOX; /* Xming puts a sizebox on dock windows */
	*zstyle = HWND_TOPMOST;
      }
    }
    if (pAtom) XFree(pAtom);
  }

  {
    XSizeHints *normal_hint = XAllocSizeHints();
    long supplied;
    if (normal_hint && (XGetWMNormalHints(pDisplay, iWindow, normal_hint, &supplied) == Success))
      {
        if (normal_hint->flags & PMaxSize)
          {
            /* Not maximizable if a maximum size is specified */
            hint |= HINT_NOMAXIMIZE;
d1604 36
a1639 30
            if (normal_hint->flags & PMinSize)
              {
                /*
                  If both minimum size and maximum size are specified and are the same,
                  don't bother with a resizing frame
                */
                if ((normal_hint->min_width == normal_hint->max_width)
                    && (normal_hint->min_height == normal_hint->max_height))
                  hint = (hint & ~HINT_SIZEBOX);
              }
          }
      }
    XFree(normal_hint);
  }

  /* Override hint settings from above with settings from config file */
  {
    XClassHint class_hint = {0,0};
    char *window_name = 0;

    if (XGetClassHint(pDisplay, iWindow, &class_hint))
      {
        XFetchName(pDisplay, iWindow, &window_name);

        style = winOverrideStyle(class_hint.res_name, class_hint.res_class, window_name);

        if (class_hint.res_name) XFree(class_hint.res_name);
        if (class_hint.res_class) XFree(class_hint.res_class);
        if (window_name) XFree(window_name);
      }
d1641 3
a1643 31
      {
        style = STYLE_NONE;
      }
  }

  if (style & STYLE_TOPMOST) *zstyle = HWND_TOPMOST;
  else if (style & STYLE_MAXIMIZE) maxmin = (hint & ~HINT_MIN) | HINT_MAX;
  else if (style & STYLE_MINIMIZE) maxmin = (hint & ~HINT_MAX) | HINT_MIN;
  else if (style & STYLE_BOTTOM) *zstyle = HWND_BOTTOM;

  if (maxmin & HINT_MAX) SendMessage(hWnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
  else if (maxmin & HINT_MIN) SendMessage(hWnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);

  if (style & STYLE_NOTITLE)
	hint = (hint & ~HINT_NOFRAME & ~HINT_BORDER & ~HINT_CAPTION) | HINT_SIZEBOX;
  else if (style & STYLE_OUTLINE)
	hint = (hint & ~HINT_NOFRAME & ~HINT_SIZEBOX & ~HINT_CAPTION) | HINT_BORDER;
  else if (style & STYLE_NOFRAME)
	hint = (hint & ~HINT_BORDER & ~HINT_CAPTION & ~HINT_SIZEBOX) | HINT_NOFRAME;

  /* Now apply styles to window */
  style = GetWindowLongPtr(hWnd, GWL_STYLE) & ~WS_CAPTION & ~WS_SIZEBOX; /* Just in case */
  if (!style) return;

  if (!hint) /* All on */
    style = style | WS_CAPTION | WS_SIZEBOX;
  else if (hint & HINT_NOFRAME) /* All off */
    style = style & ~WS_CAPTION & ~WS_SIZEBOX;
  else style = style | ((hint & HINT_BORDER) ? WS_BORDER : 0) |
		((hint & HINT_SIZEBOX) ? WS_SIZEBOX : 0) |
		((hint & HINT_CAPTION) ? WS_CAPTION : 0);
d1645 2
a1646 2
  if (hint & HINT_NOMAXIMIZE)
    style = style & ~WS_MAXIMIZEBOX;
d1648 7
a1654 1
  SetWindowLongPtr (hWnd, GWL_STYLE, style);
d1658 1
a1658 1
winUpdateWindowPosition (HWND hWnd, Bool reshape, HWND *zstyle)
d1660 19
a1678 17
  int iX, iY, iWidth, iHeight;
  int	iDx, iDy;
  RECT	rcNew;
  WindowPtr	pWin = GetProp (hWnd, WIN_WINDOW_PROP);
  DrawablePtr	pDraw = NULL;

  if (!pWin) return;
  pDraw = &pWin->drawable;
  if (!pDraw) return;

  /* Get the X and Y location of the X window */
  iX = pWin->drawable.x + GetSystemMetrics (SM_XVIRTUALSCREEN);
  iY = pWin->drawable.y + GetSystemMetrics (SM_YVIRTUALSCREEN);

  /* Get the height and width of the X window */
  iWidth = pWin->drawable.width;
  iHeight = pWin->drawable.height;
d1680 2
a1681 2
  /* Setup a rectangle with the X window position and size */
  SetRect (&rcNew, iX, iY, iX + iWidth, iY + iHeight);
d1684 2
a1685 3
  ErrorF ("winUpdateWindowPosition - (%d, %d)-(%d, %d)\n",
	  rcNew.left, rcNew.top,
	  rcNew.right, rcNew.bottom);
d1688 2
a1689 1
  AdjustWindowRectEx (&rcNew, GetWindowLongPtr (hWnd, GWL_STYLE), FALSE, WS_EX_APPWINDOW);
d1691 5
a1695 6
  /* Don't allow window decoration to disappear off to top-left as a result of this adjustment */
  if (rcNew.left < GetSystemMetrics(SM_XVIRTUALSCREEN))
    {
      iDx = GetSystemMetrics(SM_XVIRTUALSCREEN) - rcNew.left;
      rcNew.left += iDx;
      rcNew.right += iDx;
d1698 4
a1701 5
  if (rcNew.top < GetSystemMetrics(SM_YVIRTUALSCREEN))
    {
      iDy = GetSystemMetrics(SM_YVIRTUALSCREEN) - rcNew.top;
      rcNew.top += iDy;
      rcNew.bottom += iDy;
d1705 2
a1706 3
  ErrorF ("winUpdateWindowPosition - (%d, %d)-(%d, %d)\n",
	  rcNew.left, rcNew.top,
	  rcNew.right, rcNew.bottom);
d1709 8
a1716 10
  /* Position the Windows window */
  SetWindowPos (hWnd, *zstyle, rcNew.left, rcNew.top,
	rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
	0);

  if (reshape)
  {
    winReshapeMultiWindow(pWin);
    winUpdateRgnMultiWindow(pWin);
  }
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d637 1
a637 1
  /* Loop until we explicity break out */
d1117 24
d1579 1
a1579 1
  WindowPtr		pWin = GetProp (hWnd, WIN_WINDOW_PROP);
a1610 1
  MwmHints *mwm_hint = NULL;
d1671 20
a1690 1
  style = winOverrideStyle((unsigned long)pWin);
@


1.1
log
@Initial revision
@
text
@d3 1
d30 1
d55 1
a55 10

/* Windows headers */
#ifdef __CYGWIN__
/* Fixups to prevent collisions between Windows and X headers */
#define ATOM DWORD

#include <windows.h>
#else
#include <Xwindows.h>
#endif
d61 5
d67 5
a71 1
#include "windowswmstr.h"
d75 2
a93 1

a141 1

d156 1
a156 1
GetWindowName (Display * pDpy, Window iWin, char **ppName);
d194 1
a194 1
CheckAnotherWindowManager (Display *pDisplay, DWORD dwScreen);
d196 5
d210 1
a210 1
static Bool			g_fAnotherWMRunnig = FALSE;
d255 6
d419 1
a419 1
GetWindowName (Display *pDisplay, Window iWin, char **ppName)
d423 2
a442 13
  
  /* */
  if (xtpName.encoding == XA_STRING)
    {
      /* */
      if (xtpName.value)
	{
	  int size = xtpName.nitems * (xtpName.format >> 3);
	  *ppName = malloc(size + 1);
	  strncpy(*ppName, xtpName.value, size);
	  (*ppName)[size] = 0;
	  XFree (xtpName.value);
	}
d444 19
a462 21
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("GetWindowName - XA_STRING %s\n", *ppName);
#endif
    }
  else
    {
      XmbTextPropertyToTextList (pDisplay, &xtpName, &ppList, &nNum);

      /* */
      if (nNum && ppList && *ppList)
	{
	  *ppName = strdup (*ppList);
	  XFreeStringList (ppList);
	}
      XFree (xtpName.value);

#if CYGMULTIWINDOW_DEBUG
      ErrorF ("GetWindowName - %s %s\n",
	      XGetAtomName (pDisplay, xtpName.encoding), *ppName);
#endif
    }
d499 1
a499 1
  char			*pszName;
d543 1
a543 1
	  SetWindowText (hWnd, pszName);
d642 1
a642 1
      if(g_fAnotherWMRunnig)/* Another Window manager exists. */
d711 19
a729 3
#if 0
	  /* Handles the case where there are AOT windows above it in W32 */
	  PreserveWin32Stack (pWMInfo, pNode->msg.iWindow, GW_HWNDPREV);
d731 16
d841 1
d896 1
a896 3
      ErrorF ("winMultiWindowXMsgProc - Locale not supported by X.  "
	      "Exiting.\n");
      pthread_exit (NULL);
d932 3
d947 1
a947 1
		  "sleeping: %d\n\f",
d970 7
a976 16
  if (pProcArg->pWMInfo->fAllowOtherWM)
  {
    g_fAnotherWMRunnig = CheckAnotherWindowManager (pProcArg->pDisplay, pProcArg->dwScreen);
  } else {
    redirectError = FALSE;
    XSetErrorHandler (winRedirectErrorHandler); 	 
    XSelectInput(pProcArg->pDisplay, 	 
        RootWindow (pProcArg->pDisplay, pProcArg->dwScreen), 	 
        SubstructureNotifyMask | ButtonPressMask); 	 
    XSync (pProcArg->pDisplay, 0); 	 
    XSetErrorHandler (winMultiWindowXMsgProcErrorHandler); 	 
    if (redirectError) 	 
    { 	 
      ErrorF ("winMultiWindowXMsgProc - " 	 
          "another window manager is running.  Exiting.\n"); 	 
      pthread_exit (NULL); 	 
d978 1
a978 3
    g_fAnotherWMRunnig = FALSE;
  }
  
d1003 10
d1021 1
a1021 1
	  if (CheckAnotherWindowManager (pProcArg->pDisplay, pProcArg->dwScreen))
d1023 1
a1023 1
	      if (!g_fAnotherWMRunnig)
d1025 1
a1025 1
		  g_fAnotherWMRunnig = TRUE;
d1031 1
a1031 1
	      if (g_fAnotherWMRunnig)
d1033 1
a1033 1
		  g_fAnotherWMRunnig = FALSE;
d1063 54
d1156 1
a1156 1
 
d1279 1
a1279 2
      ErrorF ("winInitMultiWindowWM - Locale not supported by X.  Exiting.\n");
      pthread_exit (NULL);
d1318 4
a1321 1
  
d1330 1
a1330 1
		  "sleeping: %d\n\f",
d1360 1
a1360 1
#ifdef XWIN_MULTIWINDOWEXTWM
a1363 1
#endif
d1433 1
a1433 1
  ErrorF ("\nwinMultiWindowWMIOErrorHandler!\n\n");
d1458 1
d1460 1
d1473 1
a1473 1
  ErrorF ("\nwinMultiWindowXMsgProcIOErrorHandler!\n\n");
d1499 1
a1499 1
CheckAnotherWindowManager (Display *pDisplay, DWORD dwScreen)
d1501 4
d1508 1
a1508 4
	       // SubstructureNotifyMask | ButtonPressMask
	       ColormapChangeMask | EnterWindowMask | PropertyChangeMask |
	       SubstructureRedirectMask | KeyPressMask |
	       ButtonPressMask | ButtonReleaseMask);
d1511 7
d1519 1
a1519 1
	       SubstructureNotifyMask);
d1521 1
a1521 9
  if (redirectError)
    {
      //ErrorF ("CheckAnotherWindowManager() - another window manager is running.  Exiting.\n");
      return TRUE;
    }
  else
    {
      return FALSE;
    }
d1529 1
a1529 1
winDeinitMultiWindowWM ()
d1533 212
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d448 4
a451 1
      if (XmbTextPropertyToTextList (pDisplay, &xtpName, &ppList, &nNum) >= Success && nNum > 0 && *ppList)
@

