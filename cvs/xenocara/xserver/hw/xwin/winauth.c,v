head	1.7;
access;
symbols
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.6
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.2
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.19;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 2003-2004 Harold L Hunt II All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL HAROLD L HUNT II BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of Harold L Hunt II
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from Harold L Hunt II.
 *
 * Authors:	Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif

#include "win.h"

/* Includes for authorization */
#include "securitysrv.h"
#include "os/osdep.h"

/*
 * Constants
 */

#define AUTH_NAME	"MIT-MAGIC-COOKIE-1"

/*
 * Locals
 */

static XID g_authId = 0;
static unsigned int g_uiAuthDataLen = 0;
static char *g_pAuthData = NULL;

/*
 * Code to generate a MIT-MAGIC-COOKIE-1, copied from under XCSECURITY
 */

#ifndef XCSECURITY
void
GenerateRandomData(int len, char *buf)
{
    int fd;

    fd = open("/dev/urandom", O_RDONLY);
    read(fd, buf, len);
    close(fd);
}

static char cookie[16];         /* 128 bits */

XID
MitGenerateCookie(unsigned data_length,
                  const char *data,
                  XID id, unsigned *data_length_return, char **data_return)
{
    int i = 0;
    int status;

    while (data_length--) {
        cookie[i++] += *data++;
        if (i >= sizeof(cookie))
            i = 0;
    }
    GenerateRandomData(sizeof(cookie), cookie);
    status = MitAddCookie(sizeof(cookie), cookie, id);
    if (!status) {
        id = -1;
    }
    else {
        *data_return = cookie;
        *data_length_return = sizeof(cookie);
    }
    return id;
}

static
    XID
GenerateAuthorization(unsigned name_length,
                      const char *name,
                      unsigned data_length,
                      const char *data,
                      unsigned *data_length_return, char **data_return)
{
    return MitGenerateCookie(data_length, data,
                             FakeClientID(0), data_length_return, data_return);
}
#endif

/*
 * Generate authorization cookie for internal server clients
 */

Bool
winGenerateAuthorization(void)
{
    SecurityAuthorizationPtr pAuth = NULL;

    /* Call OS layer to generate authorization key */
    g_authId = GenerateAuthorization(strlen(AUTH_NAME),
                                     AUTH_NAME,
                                     0, NULL, &g_uiAuthDataLen, &g_pAuthData);
    if ((XID) ~0L == g_authId) {
        ErrorF("winGenerateAuthorization - GenerateAuthorization failed\n");
        return FALSE;
    }

    else {
        winDebug("winGenerateAuthorization - GenerateAuthorization success!\n"
                 "AuthDataLen: %d AuthData: %s\n",
                 g_uiAuthDataLen, g_pAuthData);
    }

#ifdef XCSECURITY
    /* Allocate structure for additional auth information */
    pAuth = (SecurityAuthorizationPtr)
        malloc(sizeof(SecurityAuthorizationRec));
    if (!(pAuth)) {
        ErrorF("winGenerateAuthorization - Failed allocating "
               "SecurityAuthorizationPtr.\n");
        return FALSE;
    }

    /* Fill in the auth fields */
    pAuth->id = g_authId;
    pAuth->timeout = 0;         /* live for x seconds after refcnt == 0 */
    pAuth->group = None;
    pAuth->trustLevel = XSecurityClientTrusted;
    pAuth->refcnt = 1;          /* this auth must stick around */
    pAuth->secondsRemaining = 0;
    pAuth->timer = NULL;
    pAuth->eventClients = NULL;

    /* Add the authorization to the server's auth list */
    if (!AddResource(g_authId, SecurityAuthorizationResType, pAuth)) {
        ErrorF("winGenerateAuthorization - AddResource failed for auth.\n");
        return FALSE;
    }
#endif

    return TRUE;
}

/* Use our generated cookie for authentication */
void
winSetAuthorization(void)
{
    XSetAuthorization(AUTH_NAME,
                      strlen(AUTH_NAME), g_pAuthData, g_uiAuthDataLen);
}
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a116 1
    Bool fFreeAuth = FALSE;
d125 1
a125 1
        goto auth_bailout;
d141 1
a141 1
        goto auth_bailout;
d157 1
a157 2
        fFreeAuth = TRUE;
        goto auth_bailout;
a158 3

    /* Don't free the auth data, since it is still used internally */
    pAuth = NULL;
a161 6

 auth_bailout:
    if (fFreeAuth)
        free(pAuth);

    return FALSE;
@


1.5
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d100 1
a100 1
                      char *name,
d102 1
a102 1
                      char *data,
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d39 1
d60 1
a60 2
static
    void
a72 1
    static
d74 1
a74 1
                  char *data,
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a39 1

a45 1

d60 2
a61 2
void
GenerateRandomData (int len, char *buf)
d70 1
a70 2

static char cookie[16]; /* 128 bits */
d73 4
a76 6
static MitGenerateCookie (
    unsigned	data_length,
    char	*data,
    XID		id,
    unsigned	*data_length_return,
    char	**data_return)
d81 13
a93 15
    while (data_length--)
    {
	cookie[i++] += *data++;
	if (i >= sizeof (cookie)) i = 0;
    }
    GenerateRandomData(sizeof (cookie), cookie);
    status = MitAddCookie(sizeof (cookie), cookie, id);
    if (!status)
    {
	id = -1;
    }
    else
    {
	*data_return = cookie;
	*data_length_return = sizeof (cookie);
d99 6
a104 8
XID
GenerateAuthorization(
	unsigned name_length,
	char	*name,
	unsigned data_length,
	char	*data,
	unsigned *data_length_return,
	char	**data_return)
d116 1
a116 1
winGenerateAuthorization (void)
d118 2
a119 2
  Bool				fFreeAuth = FALSE;
  SecurityAuthorizationPtr	pAuth = NULL;
d121 13
a133 18
  /* Call OS layer to generate authorization key */
  g_authId = GenerateAuthorization (strlen (AUTH_NAME),
				    AUTH_NAME,
				    0,
				    NULL,
				    &g_uiAuthDataLen,
				    &g_pAuthData);
  if ((XID) ~0L == g_authId)
    {
      ErrorF ("winGenerateAuthorization - GenerateAuthorization failed\n");
      goto auth_bailout;
    }

  else
    {
      winDebug("winGenerateAuthorization - GenerateAuthorization success!\n"
	      "AuthDataLen: %d AuthData: %s\n",
	      g_uiAuthDataLen, g_pAuthData);
d137 28
a164 32
  /* Allocate structure for additional auth information */
  pAuth = (SecurityAuthorizationPtr) 
    malloc(sizeof (SecurityAuthorizationRec));
  if (!(pAuth))
    {
      ErrorF ("winGenerateAuthorization - Failed allocating "
	      "SecurityAuthorizationPtr.\n");
      goto auth_bailout;
    }
  
  /* Fill in the auth fields */
  pAuth->id = g_authId;
  pAuth->timeout = 0; /* live for x seconds after refcnt == 0 */
  pAuth->group = None;
  pAuth->trustLevel = XSecurityClientTrusted;
  pAuth->refcnt = 1; /* this auth must stick around */
  pAuth->secondsRemaining = 0;
  pAuth->timer = NULL;
  pAuth->eventClients = NULL;
  
  /* Add the authorization to the server's auth list */
  if (!AddResource (g_authId,
		    SecurityAuthorizationResType,
		    pAuth))
    {
      ErrorF ("winGenerateAuthorization - AddResource failed for auth.\n");
      fFreeAuth = TRUE;
      goto auth_bailout;
    }
  
  /* Don't free the auth data, since it is still used internally */
  pAuth = NULL;
d167 1
a167 1
  return TRUE;
d170 4
a173 4
  if (fFreeAuth)
    free(pAuth);
  
  return FALSE;
d180 2
a181 4
  XSetAuthorization (AUTH_NAME,
		     strlen (AUTH_NAME),
		     g_pAuthData,
		     g_uiAuthDataLen);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d153 1
a153 1
    xalloc (sizeof (SecurityAuthorizationRec));
d189 1
a189 1
    xfree (pAuth);
@


1.1
log
@Initial revision
@
text
@a0 4
#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#if defined(XCSECURITY)
d31 4
a37 1
#include <X11/Xauth.h>
a38 1
#include <X11/extensions/securstr.h>
d49 9
a57 1
 * Globals
d60 44
a103 3
XID		g_authId = 0;
unsigned int	g_uiAuthDataLen = 0;
char		*g_pAuthData = NULL;
d105 14
d125 1
a125 1
winGenerateAuthorization ()
d142 1
a142 1
#if 0
d145 1
a145 1
      ErrorF ("winGenerateAuthorization - GenerateAuthorization success!\n"
d149 2
a150 2
#endif
  
d183 2
a184 1
  
d193 10
a202 1
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
