head	1.9;
access;
symbols
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.34;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.34;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.03.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Dakshinamurthy Karra
 *		Suhaib M Siddiqi
 *		Peter Busch
 *		Harold L Hunt II
 *		MATSUZAKI Kensuke
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include <commctrl.h>
#include "winprefs.h"
#include "winconfig.h"
#include "winmsg.h"
#include "winmonitors.h"
#include "inputstr.h"
#ifdef XWIN_CLIPBOARD
#include "winclipboard/winclipboard.h"
#endif

/*
 * Global variables
 */

Bool g_fCursor = TRUE;
Bool g_fButton[3] = { FALSE, FALSE, FALSE };

/*
 * Called by winWakeupHandler
 * Processes current Windows message
 */

LRESULT CALLBACK
winWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static winPrivScreenPtr s_pScreenPriv = NULL;
    static winScreenInfo *s_pScreenInfo = NULL;
    static ScreenPtr s_pScreen = NULL;
    static HWND s_hwndLastPrivates = NULL;
    static Bool s_fTracking = FALSE;
    static unsigned long s_ulServerGeneration = 0;
    static UINT s_uTaskbarRestart = 0;
    int iScanCode;
    int i;

#if CYGDEBUG
    winDebugWin32Message("winWindowProc", hwnd, message, wParam, lParam);
#endif

    /* Watch for server regeneration */
    if (g_ulServerGeneration != s_ulServerGeneration) {
        /* Store new server generation */
        s_ulServerGeneration = g_ulServerGeneration;
    }

    /* Only retrieve new privates pointers if window handle is null or changed */
    if ((s_pScreenPriv == NULL || hwnd != s_hwndLastPrivates)
        && (s_pScreenPriv = GetProp(hwnd, WIN_SCR_PROP)) != NULL) {
#if CYGDEBUG
        winDebug("winWindowProc - Setting privates handle\n");
#endif
        s_pScreenInfo = s_pScreenPriv->pScreenInfo;
        s_pScreen = s_pScreenInfo->pScreen;
        s_hwndLastPrivates = hwnd;
    }
    else if (s_pScreenPriv == NULL) {
        /* For safety, handle case that should never happen */
        s_pScreenInfo = NULL;
        s_pScreen = NULL;
        s_hwndLastPrivates = NULL;
    }

    /* Branch on message type */
    switch (message) {
    case WM_TRAYICON:
        return winHandleIconMessage(hwnd, message, wParam, lParam,
                                    s_pScreenPriv);

    case WM_CREATE:
#if CYGDEBUG
        winDebug("winWindowProc - WM_CREATE\n");
#endif

        /*
         * Add a property to our display window that references
         * this screens' privates.
         *
         * This allows the window procedure to refer to the
         * appropriate window DC and shadow DC for the window that
         * it is processing.  We use this to repaint exposed
         * areas of our display window.
         */
        s_pScreenPriv = ((LPCREATESTRUCT) lParam)->lpCreateParams;
        s_pScreenInfo = s_pScreenPriv->pScreenInfo;
        s_pScreen = s_pScreenInfo->pScreen;
        s_hwndLastPrivates = hwnd;
        s_uTaskbarRestart = RegisterWindowMessage(TEXT("TaskbarCreated"));
        SetProp(hwnd, WIN_SCR_PROP, s_pScreenPriv);

        /* Setup tray icon */
        if (!s_pScreenInfo->fNoTrayIcon) {
            /*
             * NOTE: The WM_CREATE message is processed before CreateWindowEx
             * returns, so s_pScreenPriv->hwndScreen is invalid at this point.
             * We go ahead and copy our hwnd parameter over top of the screen
             * privates hwndScreen so that we have a valid value for
             * that member.  Otherwise, the tray icon will disappear
             * the first time you move the mouse over top of it.
             */

            s_pScreenPriv->hwndScreen = hwnd;

            winInitNotifyIcon(s_pScreenPriv);
        }
        return 0;

    case WM_DISPLAYCHANGE:
        /*
           WM_DISPLAYCHANGE seems to be sent when the monitor layout or
           any monitor's resolution or depth changes, but it's lParam and
           wParam always indicate the resolution and bpp for the primary
           monitor (so ignore that as we could be on any monitor...)
         */

        /* We cannot handle a display mode change during initialization */
        if (s_pScreenInfo == NULL)
            FatalError("winWindowProc - WM_DISPLAYCHANGE - The display "
                       "mode changed while we were intializing.  This is "
                       "very bad and unexpected.  Exiting.\n");

        /*
         * We do not care about display changes with
         * fullscreen DirectDraw engines, because those engines set
         * their own mode when they become active.
         */
        if (s_pScreenInfo->fFullScreen
            || (s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL)) {
            break;
        }

        ErrorF("winWindowProc - WM_DISPLAYCHANGE - new width: %d "
               "new height: %d new bpp: %d\n",
               LOWORD(lParam), HIWORD(lParam), (int)wParam);

        /* 0 bpp has no defined meaning, ignore this message */
        if (wParam == 0)
            break;

        /*
         * Check for a disruptive change in depth.
         * We can only display a message for a disruptive depth change,
         * we cannot do anything to correct the situation.
         */
        /*
           XXX: maybe we need to check if GetSystemMetrics(SM_SAMEDISPLAYFORMAT)
           has changed as well...
         */
        if (s_pScreenInfo->dwBPP !=
            GetDeviceCaps(s_pScreenPriv->hdcScreen, BITSPIXEL)) {
            if (s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL) {
                /* Cannot display the visual until the depth is restored */
                ErrorF("winWindowProc - Disruptive change in depth\n");

                /* Display depth change dialog */
                winDisplayDepthChangeDialog(s_pScreenPriv);

                /* Flag that we have an invalid screen depth */
                s_pScreenPriv->fBadDepth = TRUE;

                /* Minimize the display window */
                ShowWindow(hwnd, SW_MINIMIZE);
            }
            else {
                /* For GDI, performance may suffer until original depth is restored */
                ErrorF
                    ("winWindowProc - Performance may be non-optimal after change in depth\n");
            }
        }
        else {
            /* Flag that we have a valid screen depth */
            s_pScreenPriv->fBadDepth = FALSE;
        }

        /*
           If we could cheaply check if this WM_DISPLAYCHANGE change
           affects the monitor(s) which this X screen is displayed on
           then we should do so here.  For the moment, assume it does.
           (this is probably usually the case so that might be an
           overoptimization)
         */
        {
            /*
               In rootless modes which are monitor or virtual desktop size
               use RandR to resize the X screen
             */
            if ((!s_pScreenInfo->fUserGaveHeightAndWidth) &&
                (s_pScreenInfo->iResizeMode == resizeWithRandr) && (FALSE
#ifdef XWIN_MULTIWINDOWEXTWM
                                                                    ||
                                                                    s_pScreenInfo->
                                                                    fMWExtWM
#endif
                                                                    ||
                                                                    s_pScreenInfo->
                                                                    fRootless
#ifdef XWIN_MULTIWINDOW
                                                                    ||
                                                                    s_pScreenInfo->
                                                                    fMultiWindow
#endif
                )) {
                DWORD dwWidth, dwHeight;

                if (s_pScreenInfo->fMultipleMonitors) {
                    /* resize to new virtual desktop size */
                    dwWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
                    dwHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);
                }
                else {
                    /* resize to new size of specified monitor */
                    struct GetMonitorInfoData data;

                    if (QueryMonitor(s_pScreenInfo->iMonitor, &data)) {
                        if (data.bMonitorSpecifiedExists == TRUE) {
                            dwWidth = data.monitorWidth;
                            dwHeight = data.monitorHeight;
                            /*
                               XXX: monitor may have changed position,
                               so we might need to update xinerama data
                             */
                        }
                        else {
                            ErrorF("Monitor number %d no longer exists!\n",
                                   s_pScreenInfo->iMonitor);
                        }
                    }
                }

                /*
                   XXX: probably a small bug here: we don't compute the work area
                   and allow for task bar

                   XXX: generally, we don't allow for the task bar being moved after
                   the server is started
                 */

                /* Set screen size to match new size, if it is different to current */
                if ((s_pScreenInfo->dwWidth != dwWidth) ||
                    (s_pScreenInfo->dwHeight != dwHeight)) {
                    winDoRandRScreenSetSize(s_pScreen,
                                            dwWidth,
                                            dwHeight,
                                            (dwWidth * 25.4) /
                                            monitorResolution,
                                            (dwHeight * 25.4) /
                                            monitorResolution);
                }
            }
            else {
                /*
                 * We can simply recreate the same-sized primary surface when
                 * the display dimensions change.
                 */

                /*
                 * NOTE: The non-DirectDraw engines set the ReleasePrimarySurface
                 * and CreatePrimarySurface function pointers to point
                 * to the no operation function, NoopDDA.  This allows us
                 * to blindly call these functions, even if they are not
                 * relevant to the current engine (e.g., Shadow GDI).
                 */

                winDebug
                    ("winWindowProc - WM_DISPLAYCHANGE - Releasing and recreating primary surface\n");

                /* Release the old primary surface */
                (*s_pScreenPriv->pwinReleasePrimarySurface) (s_pScreen);

                /* Create the new primary surface */
                (*s_pScreenPriv->pwinCreatePrimarySurface) (s_pScreen);
            }
        }

        break;

    case WM_SIZE:
    {
        SCROLLINFO si;
        RECT rcWindow;
        int iWidth, iHeight;

#if CYGDEBUG
        winDebug("winWindowProc - WM_SIZE\n");
#endif

        /* Break if we do not allow resizing */
        if ((s_pScreenInfo->iResizeMode == notAllowed)
            || !s_pScreenInfo->fDecoration
#ifdef XWIN_MULTIWINDOWEXTWM
            || s_pScreenInfo->fMWExtWM
#endif
            || s_pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOW
            || s_pScreenInfo->fMultiWindow
#endif
            || s_pScreenInfo->fFullScreen)
            break;

        /* No need to resize if we get minimized */
        if (wParam == SIZE_MINIMIZED)
            return 0;

        ErrorF("winWindowProc - WM_SIZE - new client area w: %d h: %d\n",
               LOWORD(lParam), HIWORD(lParam));

        if (s_pScreenInfo->iResizeMode == resizeWithRandr) {
            /* Actual resizing is done on WM_EXITSIZEMOVE */
            return 0;
        }

        /* Otherwise iResizeMode == resizeWithScrollbars */

        /*
         * Get the size of the whole window, including client area,
         * scrollbars, and non-client area decorations (caption, borders).
         * We do this because we need to check if the client area
         * without scrollbars is large enough to display the whole visual.
         * The new client area size passed by lParam already subtracts
         * the size of the scrollbars if they are currently displayed.
         * So checking is LOWORD(lParam) == visual_width and
         * HIWORD(lParam) == visual_height will never tell us to hide
         * the scrollbars because the client area would always be too small.
         * GetClientRect returns the same sizes given by lParam, so we
         * cannot use GetClientRect either.
         */
        GetWindowRect(hwnd, &rcWindow);
        iWidth = rcWindow.right - rcWindow.left;
        iHeight = rcWindow.bottom - rcWindow.top;

        /* Subtract the frame size from the window size. */
        iWidth -= 2 * GetSystemMetrics(SM_CXSIZEFRAME);
        iHeight -= (2 * GetSystemMetrics(SM_CYSIZEFRAME)
                    + GetSystemMetrics(SM_CYCAPTION));

        /*
         * Update scrollbar page sizes.
         * NOTE: If page size == range, then the scrollbar is
         * automatically hidden.
         */

        /* Is the naked client area large enough to show the whole visual? */
        if (iWidth < s_pScreenInfo->dwWidth
            || iHeight < s_pScreenInfo->dwHeight) {
            /* Client area too small to display visual, use scrollbars */
            iWidth -= GetSystemMetrics(SM_CXVSCROLL);
            iHeight -= GetSystemMetrics(SM_CYHSCROLL);
        }

        /* Set the horizontal scrollbar page size */
        si.cbSize = sizeof(si);
        si.fMask = SIF_PAGE | SIF_RANGE;
        si.nMin = 0;
        si.nMax = s_pScreenInfo->dwWidth - 1;
        si.nPage = iWidth;
        SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);

        /* Set the vertical scrollbar page size */
        si.cbSize = sizeof(si);
        si.fMask = SIF_PAGE | SIF_RANGE;
        si.nMin = 0;
        si.nMax = s_pScreenInfo->dwHeight - 1;
        si.nPage = iHeight;
        SetScrollInfo(hwnd, SB_VERT, &si, TRUE);

        /*
         * NOTE: Scrollbars may have moved if they were at the
         * far right/bottom, so we query their current position.
         */

        /* Get the horizontal scrollbar position and set the offset */
        si.cbSize = sizeof(si);
        si.fMask = SIF_POS;
        GetScrollInfo(hwnd, SB_HORZ, &si);
        s_pScreenInfo->dwXOffset = -si.nPos;

        /* Get the vertical scrollbar position and set the offset */
        si.cbSize = sizeof(si);
        si.fMask = SIF_POS;
        GetScrollInfo(hwnd, SB_VERT, &si);
        s_pScreenInfo->dwYOffset = -si.nPos;
    }
        return 0;

    case WM_SYSCOMMAND:
        if (s_pScreenInfo->iResizeMode == resizeWithRandr &&
            ((wParam & 0xfff0) == SC_MAXIMIZE ||
             (wParam & 0xfff0) == SC_RESTORE))
            PostMessage(hwnd, WM_EXITSIZEMOVE, 0, 0);
        break;

    case WM_ENTERSIZEMOVE:
        ErrorF("winWindowProc - WM_ENTERSIZEMOVE\n");
        break;

    case WM_EXITSIZEMOVE:
        ErrorF("winWindowProc - WM_EXITSIZEMOVE\n");

        if (s_pScreenInfo->iResizeMode == resizeWithRandr) {
            /* Set screen size to match new client area, if it is different to current */
            RECT rcClient;
            DWORD dwWidth, dwHeight;

            GetClientRect(hwnd, &rcClient);
            dwWidth = rcClient.right - rcClient.left;
            dwHeight = rcClient.bottom - rcClient.top;

            if ((s_pScreenInfo->dwWidth != dwWidth) ||
                (s_pScreenInfo->dwHeight != dwHeight)) {
                /* mm = dots * (25.4 mm / inch) / (dots / inch) */
                winDoRandRScreenSetSize(s_pScreen,
                                        dwWidth,
                                        dwHeight,
                                        (dwWidth * 25.4) / monitorResolution,
                                        (dwHeight * 25.4) / monitorResolution);
            }
        }

        break;

    case WM_VSCROLL:
    {
        SCROLLINFO si;
        int iVertPos;

#if CYGDEBUG
        winDebug("winWindowProc - WM_VSCROLL\n");
#endif

        /* Get vertical scroll bar info */
        si.cbSize = sizeof(si);
        si.fMask = SIF_ALL;
        GetScrollInfo(hwnd, SB_VERT, &si);

        /* Save the vertical position for comparison later */
        iVertPos = si.nPos;

        /*
         * Don't forget:
         * moving the scrollbar to the DOWN, scroll the content UP
         */
        switch (LOWORD(wParam)) {
        case SB_TOP:
            si.nPos = si.nMin;
            break;

        case SB_BOTTOM:
            si.nPos = si.nMax - si.nPage + 1;
            break;

        case SB_LINEUP:
            si.nPos -= 1;
            break;

        case SB_LINEDOWN:
            si.nPos += 1;
            break;

        case SB_PAGEUP:
            si.nPos -= si.nPage;
            break;

        case SB_PAGEDOWN:
            si.nPos += si.nPage;
            break;

        case SB_THUMBTRACK:
            si.nPos = si.nTrackPos;
            break;

        default:
            break;
        }

        /*
         * We retrieve the position after setting it,
         * because Windows may adjust it.
         */
        si.fMask = SIF_POS;
        SetScrollInfo(hwnd, SB_VERT, &si, TRUE);
        GetScrollInfo(hwnd, SB_VERT, &si);

        /* Scroll the window if the position has changed */
        if (si.nPos != iVertPos) {
            /* Save the new offset for bit block transfers, etc. */
            s_pScreenInfo->dwYOffset = -si.nPos;

            /* Change displayed region in the window */
            ScrollWindowEx(hwnd,
                           0,
                           iVertPos - si.nPos,
                           NULL, NULL, NULL, NULL, SW_INVALIDATE);

            /* Redraw the window contents */
            UpdateWindow(hwnd);
        }
    }
        return 0;

    case WM_HSCROLL:
    {
        SCROLLINFO si;
        int iHorzPos;

#if CYGDEBUG
        winDebug("winWindowProc - WM_HSCROLL\n");
#endif

        /* Get horizontal scroll bar info */
        si.cbSize = sizeof(si);
        si.fMask = SIF_ALL;
        GetScrollInfo(hwnd, SB_HORZ, &si);

        /* Save the horizontal position for comparison later */
        iHorzPos = si.nPos;

        /*
         * Don't forget:
         * moving the scrollbar to the RIGHT, scroll the content LEFT
         */
        switch (LOWORD(wParam)) {
        case SB_LEFT:
            si.nPos = si.nMin;
            break;

        case SB_RIGHT:
            si.nPos = si.nMax - si.nPage + 1;
            break;

        case SB_LINELEFT:
            si.nPos -= 1;
            break;

        case SB_LINERIGHT:
            si.nPos += 1;
            break;

        case SB_PAGELEFT:
            si.nPos -= si.nPage;
            break;

        case SB_PAGERIGHT:
            si.nPos += si.nPage;
            break;

        case SB_THUMBTRACK:
            si.nPos = si.nTrackPos;
            break;

        default:
            break;
        }

        /*
         * We retrieve the position after setting it,
         * because Windows may adjust it.
         */
        si.fMask = SIF_POS;
        SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);
        GetScrollInfo(hwnd, SB_HORZ, &si);

        /* Scroll the window if the position has changed */
        if (si.nPos != iHorzPos) {
            /* Save the new offset for bit block transfers, etc. */
            s_pScreenInfo->dwXOffset = -si.nPos;

            /* Change displayed region in the window */
            ScrollWindowEx(hwnd,
                           iHorzPos - si.nPos,
                           0, NULL, NULL, NULL, NULL, SW_INVALIDATE);

            /* Redraw the window contents */
            UpdateWindow(hwnd);
        }
    }
        return 0;

    case WM_GETMINMAXINFO:
    {
        MINMAXINFO *pMinMaxInfo = (MINMAXINFO *) lParam;
        int iCaptionHeight;
        int iBorderHeight, iBorderWidth;

#if CYGDEBUG
        winDebug("winWindowProc - WM_GETMINMAXINFO - pScreenInfo: %p\n",
                 s_pScreenInfo);
#endif

        /* Can't do anything without screen info */
        if (s_pScreenInfo == NULL
            || (s_pScreenInfo->iResizeMode != resizeWithScrollbars)
            || s_pScreenInfo->fFullScreen || !s_pScreenInfo->fDecoration
#ifdef XWIN_MULTIWINDOWEXTWM
            || s_pScreenInfo->fMWExtWM
#endif
            || s_pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOW
            || s_pScreenInfo->fMultiWindow
#endif
            )
            break;

        /*
         * Here we can override the maximum tracking size, which
         * is the largest size that can be assigned to our window
         * via the sizing border.
         */

        /*
         * FIXME: Do we only need to do this once, since our visual size
         * does not change?  Does Windows store this value statically
         * once we have set it once?
         */

        /* Get the border and caption sizes */
        iCaptionHeight = GetSystemMetrics(SM_CYCAPTION);
        iBorderWidth = 2 * GetSystemMetrics(SM_CXSIZEFRAME);
        iBorderHeight = 2 * GetSystemMetrics(SM_CYSIZEFRAME);

        /* Allow the full visual to be displayed */
        pMinMaxInfo->ptMaxTrackSize.x = s_pScreenInfo->dwWidth + iBorderWidth;
        pMinMaxInfo->ptMaxTrackSize.y
            = s_pScreenInfo->dwHeight + iBorderHeight + iCaptionHeight;
    }
        return 0;

    case WM_ERASEBKGND:
#if CYGDEBUG
        winDebug("winWindowProc - WM_ERASEBKGND\n");
#endif
        /*
         * Pretend that we did erase the background but we don't care,
         * the application uses the full window estate. This avoids some
         * flickering when resizing.
         */
        return TRUE;

    case WM_PAINT:
#if CYGDEBUG
        winDebug("winWindowProc - WM_PAINT\n");
#endif
        /* Only paint if we have privates and the server is enabled */
        if (s_pScreenPriv == NULL
            || !s_pScreenPriv->fEnabled
            || (s_pScreenInfo->fFullScreen && !s_pScreenPriv->fActive)
            || s_pScreenPriv->fBadDepth) {
            /* We don't want to paint */
            break;
        }

        /* Break out here if we don't have a valid paint routine */
        if (s_pScreenPriv->pwinBltExposedRegions == NULL)
            break;

        /* Call the engine dependent repainter */
        (*s_pScreenPriv->pwinBltExposedRegions) (s_pScreen);
        return 0;

    case WM_PALETTECHANGED:
    {
#if CYGDEBUG
        winDebug("winWindowProc - WM_PALETTECHANGED\n");
#endif
        /*
         * Don't process if we don't have privates or a colormap,
         * or if we have an invalid depth.
         */
        if (s_pScreenPriv == NULL
            || s_pScreenPriv->pcmapInstalled == NULL
            || s_pScreenPriv->fBadDepth)
            break;

        /* Return if we caused the palette to change */
        if ((HWND) wParam == hwnd) {
            /* Redraw the screen */
            (*s_pScreenPriv->pwinRedrawScreen) (s_pScreen);
            return 0;
        }

        /* Reinstall the windows palette */
        (*s_pScreenPriv->pwinRealizeInstalledPalette) (s_pScreen);

        /* Redraw the screen */
        (*s_pScreenPriv->pwinRedrawScreen) (s_pScreen);
        return 0;
    }

    case WM_MOUSEMOVE:
        /* We can't do anything without privates */
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;

        /* We can't do anything without g_pwinPointer */
        if (g_pwinPointer == NULL)
            break;

        /* Has the mouse pointer crossed screens? */
        if (s_pScreen != miPointerGetScreen(g_pwinPointer))
            miPointerSetScreen(g_pwinPointer, s_pScreenInfo->dwScreen,
                               GET_X_LPARAM(lParam) - s_pScreenInfo->dwXOffset,
                               GET_Y_LPARAM(lParam) - s_pScreenInfo->dwYOffset);

        /* Are we tracking yet? */
        if (!s_fTracking) {
            TRACKMOUSEEVENT tme;

            /* Setup data structure */
            ZeroMemory(&tme, sizeof(tme));
            tme.cbSize = sizeof(tme);
            tme.dwFlags = TME_LEAVE;
            tme.hwndTrack = hwnd;

            /* Call the tracking function */
            if (!TrackMouseEvent(&tme))
                ErrorF("winWindowProc - TrackMouseEvent failed\n");

            /* Flag that we are tracking now */
            s_fTracking = TRUE;
        }

        /* Hide or show the Windows mouse cursor */
        if (g_fSoftwareCursor && g_fCursor &&
            (s_pScreenPriv->fActive || s_pScreenInfo->fLessPointer)) {
            /* Hide Windows cursor */
            g_fCursor = FALSE;
            ShowCursor(FALSE);
        }
        else if (g_fSoftwareCursor && !g_fCursor && !s_pScreenPriv->fActive
                 && !s_pScreenInfo->fLessPointer) {
            /* Show Windows cursor */
            g_fCursor = TRUE;
            ShowCursor(TRUE);
        }

        /* Deliver absolute cursor position to X Server */
        winEnqueueMotion(GET_X_LPARAM(lParam) - s_pScreenInfo->dwXOffset,
                         GET_Y_LPARAM(lParam) - s_pScreenInfo->dwYOffset);
        return 0;

    case WM_NCMOUSEMOVE:
        /*
         * We break instead of returning 0 since we need to call
         * DefWindowProc to get the mouse cursor changes
         * and min/max/close button highlighting in Windows XP.
         * The Platform SDK says that you should return 0 if you
         * process this message, but it fails to mention that you
         * will give up any default functionality if you do return 0.
         */

        /* We can't do anything without privates */
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;

        /* Non-client mouse movement, show Windows cursor */
        if (g_fSoftwareCursor && !g_fCursor) {
            g_fCursor = TRUE;
            ShowCursor(TRUE);
        }
        break;

    case WM_MOUSELEAVE:
        /* Mouse has left our client area */

        /* Flag that we are no longer tracking */
        s_fTracking = FALSE;

        /* Show the mouse cursor, if necessary */
        if (g_fSoftwareCursor && !g_fCursor) {
            g_fCursor = TRUE;
            ShowCursor(TRUE);
        }
        return 0;

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;
        if (s_pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOWEXTWM
            || s_pScreenInfo->fMWExtWM
#endif
            )
            SetCapture(hwnd);
        return winMouseButtonsHandle(s_pScreen, ButtonPress, Button1, wParam);

    case WM_LBUTTONUP:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;
        if (s_pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOWEXTWM
            || s_pScreenInfo->fMWExtWM
#endif
            )
            ReleaseCapture();
        return winMouseButtonsHandle(s_pScreen, ButtonRelease, Button1, wParam);

    case WM_MBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;
        if (s_pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOWEXTWM
            || s_pScreenInfo->fMWExtWM
#endif
            )
            SetCapture(hwnd);
        return winMouseButtonsHandle(s_pScreen, ButtonPress, Button2, wParam);

    case WM_MBUTTONUP:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;
        if (s_pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOWEXTWM
            || s_pScreenInfo->fMWExtWM
#endif
            )
            ReleaseCapture();
        return winMouseButtonsHandle(s_pScreen, ButtonRelease, Button2, wParam);

    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;
        if (s_pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOWEXTWM
            || s_pScreenInfo->fMWExtWM
#endif
            )
            SetCapture(hwnd);
        return winMouseButtonsHandle(s_pScreen, ButtonPress, Button3, wParam);

    case WM_RBUTTONUP:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;
        if (s_pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOWEXTWM
            || s_pScreenInfo->fMWExtWM
#endif
            )
            ReleaseCapture();
        return winMouseButtonsHandle(s_pScreen, ButtonRelease, Button3, wParam);

    case WM_XBUTTONDBLCLK:
    case WM_XBUTTONDOWN:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;
        if (s_pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOWEXTWM
            || s_pScreenInfo->fMWExtWM
#endif
            )
            SetCapture(hwnd);
        return winMouseButtonsHandle(s_pScreen, ButtonPress, HIWORD(wParam) + 7,
                                     wParam);
    case WM_XBUTTONUP:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;
        if (s_pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOWEXTWM
            || s_pScreenInfo->fMWExtWM
#endif
            )
            ReleaseCapture();
        return winMouseButtonsHandle(s_pScreen, ButtonRelease,
                                     HIWORD(wParam) + 7, wParam);

    case WM_TIMER:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;

        /* Branch on the timer id */
        switch (wParam) {
        case WIN_E3B_TIMER_ID:
            /* Send delayed button press */
            winMouseButtonsSendEvent(ButtonPress,
                                     s_pScreenPriv->iE3BCachedPress);

            /* Kill this timer */
            KillTimer(s_pScreenPriv->hwndScreen, WIN_E3B_TIMER_ID);

            /* Clear screen privates flags */
            s_pScreenPriv->iE3BCachedPress = 0;
            break;

        case WIN_POLLING_MOUSE_TIMER_ID:
        {
            static POINT last_point;
            POINT point;
            WPARAM wL, wM, wR, wShift, wCtrl;
            LPARAM lPos;

            /* Get the current position of the mouse cursor */
            GetCursorPos(&point);

            /* Map from screen (-X, -Y) to root (0, 0) */
            point.x -= GetSystemMetrics(SM_XVIRTUALSCREEN);
            point.y -= GetSystemMetrics(SM_YVIRTUALSCREEN);

            /* If the mouse pointer has moved, deliver absolute cursor position to X Server */
            if (last_point.x != point.x || last_point.y != point.y) {
                winEnqueueMotion(point.x, point.y);
                last_point.x = point.x;
                last_point.y = point.y;
            }

            /* Check if a button was released but we didn't see it */
            GetCursorPos(&point);
            wL = (GetKeyState(VK_LBUTTON) & 0x8000) ? MK_LBUTTON : 0;
            wM = (GetKeyState(VK_MBUTTON) & 0x8000) ? MK_MBUTTON : 0;
            wR = (GetKeyState(VK_RBUTTON) & 0x8000) ? MK_RBUTTON : 0;
            wShift = (GetKeyState(VK_SHIFT) & 0x8000) ? MK_SHIFT : 0;
            wCtrl = (GetKeyState(VK_CONTROL) & 0x8000) ? MK_CONTROL : 0;
            lPos = MAKELPARAM(point.x, point.y);
            if (g_fButton[0] && !wL)
                PostMessage(hwnd, WM_LBUTTONUP, wCtrl | wM | wR | wShift, lPos);
            if (g_fButton[1] && !wM)
                PostMessage(hwnd, WM_MBUTTONUP, wCtrl | wL | wR | wShift, lPos);
            if (g_fButton[2] && !wR)
                PostMessage(hwnd, WM_RBUTTONUP, wCtrl | wL | wM | wShift, lPos);
        }
        }
        return 0;

    case WM_CTLCOLORSCROLLBAR:
        FatalError("winWindowProc - WM_CTLCOLORSCROLLBAR - We are not "
                   "supposed to get this message.  Exiting.\n");
        return 0;

    case WM_MOUSEWHEEL:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;
#if CYGDEBUG
        winDebug("winWindowProc - WM_MOUSEWHEEL\n");
#endif
        /* Button4 = WheelUp */
        /* Button5 = WheelDown */
        winMouseWheel(&(s_pScreenPriv->iDeltaZ), GET_WHEEL_DELTA_WPARAM(wParam), Button4, Button5);
        break;

    case WM_MOUSEHWHEEL:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;
#if CYGDEBUG
        winDebug("winWindowProc - WM_MOUSEHWHEEL\n");
#endif
        /* Button7 = TiltRight */
        /* Button6 = TiltLeft */
        winMouseWheel(&(s_pScreenPriv->iDeltaV), GET_WHEEL_DELTA_WPARAM(wParam), 7, 6);
        break;

    case WM_SETFOCUS:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;

        /* Restore the state of all mode keys */
        winRestoreModeKeyStates();

        /* Add the keyboard hook if possible */
        if (g_fKeyboardHookLL)
            g_fKeyboardHookLL = winInstallKeyboardHookLL();
        return 0;

    case WM_KILLFOCUS:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;

        /* Release any pressed keys */
        winKeybdReleaseKeys();

        /* Remove our keyboard hook if it is installed */
        winRemoveKeyboardHookLL();
        return 0;

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;

        /*
         * FIXME: Catching Alt-F4 like this is really terrible.  This should
         * be generalized to handle other Windows keyboard signals.  Actually,
         * the list keys to catch and the actions to perform when caught should
         * be configurable; that way user's can customize the keys that they
         * need to have passed through to their window manager or apps, or they
         * can remap certain actions to new key codes that do not conflict
         * with the X apps that they are using.  Yeah, that'll take awhile.
         */
        if ((s_pScreenInfo->fUseWinKillKey && wParam == VK_F4
             && (GetKeyState(VK_MENU) & 0x8000))
            || (s_pScreenInfo->fUseUnixKillKey && wParam == VK_BACK
                && (GetKeyState(VK_MENU) & 0x8000)
                && (GetKeyState(VK_CONTROL) & 0x8000))) {
            /*
             * Better leave this message here, just in case some unsuspecting
             * user enters Alt + F4 and is surprised when the application
             * quits.
             */
            ErrorF("winWindowProc - WM_*KEYDOWN - Closekey hit, quitting\n");

            /* Display Exit dialog */
            winDisplayExitDialog(s_pScreenPriv);
            return 0;
        }

        /*
         * Don't do anything for the Windows keys, as focus will soon
         * be returned to Windows.  We may be able to trap the Windows keys,
         * but we should determine if that is desirable before doing so.
         */
        if ((wParam == VK_LWIN || wParam == VK_RWIN) && !g_fKeyboardHookLL)
            break;

        /* Discard fake Ctrl_L events that precede AltGR on non-US keyboards */
        if (winIsFakeCtrl_L(message, wParam, lParam))
            return 0;

        /*
         * Discard presses generated from Windows auto-repeat
         */
        if (lParam & (1 << 30)) {
            switch (wParam) {
                /* ago: Pressing LControl while RControl is pressed is
                 * Indicated as repeat. Fix this!
                 */
            case VK_CONTROL:
            case VK_SHIFT:
                if (winCheckKeyPressed(wParam, lParam))
                    return 0;
                break;
            default:
                return 0;
            }
        }

        /* Translate Windows key code to X scan code */
        iScanCode = winTranslateKey(wParam, lParam);

        /* Ignore repeats for CapsLock */
        if (wParam == VK_CAPITAL)
            lParam = 1;

        /* Send the key event(s) */
        for (i = 0; i < LOWORD(lParam); ++i)
            winSendKeyEvent(iScanCode, TRUE);
        return 0;

    case WM_SYSKEYUP:
    case WM_KEYUP:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;

        /*
         * Don't do anything for the Windows keys, as focus will soon
         * be returned to Windows.  We may be able to trap the Windows keys,
         * but we should determine if that is desirable before doing so.
         */
        if ((wParam == VK_LWIN || wParam == VK_RWIN) && !g_fKeyboardHookLL)
            break;

        /* Ignore the fake Ctrl_L that follows an AltGr release */
        if (winIsFakeCtrl_L(message, wParam, lParam))
            return 0;

        /* Enqueue a keyup event */
        iScanCode = winTranslateKey(wParam, lParam);
        winSendKeyEvent(iScanCode, FALSE);

        /* Release all pressed shift keys */
        if (wParam == VK_SHIFT)
            winFixShiftKeys(iScanCode);
        return 0;

    case WM_HOTKEY:
        if (s_pScreenPriv == NULL)
            break;

        /* Call the engine-specific hot key handler */
        (*s_pScreenPriv->pwinHotKeyAltTab) (s_pScreen);
        return 0;

    case WM_ACTIVATE:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;

        /* TODO: Override display of window when we have a bad depth */
        if (LOWORD(wParam) != WA_INACTIVE && s_pScreenPriv->fBadDepth) {
            ErrorF("winWindowProc - WM_ACTIVATE - Bad depth, trying "
                   "to override window activation\n");

            /* Minimize the window */
            ShowWindow(hwnd, SW_MINIMIZE);

            /* Display dialog box */
            if (g_hDlgDepthChange != NULL) {
                /* Make the existing dialog box active */
                SetActiveWindow(g_hDlgDepthChange);
            }
            else {
                /* TODO: Recreate the dialog box and bring to the top */
                ShowWindow(g_hDlgDepthChange, SW_SHOWDEFAULT);
            }

            /* Don't do any other processing of this message */
            return 0;
        }

#if CYGDEBUG
        winDebug("winWindowProc - WM_ACTIVATE\n");
#endif

        /*
         * Focus is being changed to another window.
         * The other window may or may not belong to
         * our process.
         */

        /* Clear any lingering wheel delta */
        s_pScreenPriv->iDeltaZ = 0;
        s_pScreenPriv->iDeltaV = 0;

        /* Reshow the Windows mouse cursor if we are being deactivated */
        if (g_fSoftwareCursor && LOWORD(wParam) == WA_INACTIVE && !g_fCursor) {
            /* Show Windows cursor */
            g_fCursor = TRUE;
            ShowCursor(TRUE);
        }
        return 0;

    case WM_ACTIVATEAPP:
        if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
            break;

#if CYGDEBUG || TRUE
        winDebug("winWindowProc - WM_ACTIVATEAPP\n");
#endif

        /* Activate or deactivate */
        s_pScreenPriv->fActive = wParam;

        /* Reshow the Windows mouse cursor if we are being deactivated */
        if (g_fSoftwareCursor && !s_pScreenPriv->fActive && !g_fCursor) {
            /* Show Windows cursor */
            g_fCursor = TRUE;
            ShowCursor(TRUE);
        }

#ifdef XWIN_CLIPBOARD
        /* Make sure the clipboard chain is ok. */
        winFixClipboardChain();
#endif

        /* Call engine specific screen activation/deactivation function */
        (*s_pScreenPriv->pwinActivateApp) (s_pScreen);

#ifdef XWIN_MULTIWINDOWEXTWM
        if (s_pScreenPriv->fActive) {
            /* Restack all window unless using built-in wm. */
            if (s_pScreenInfo->fInternalWM && s_pScreenInfo->fAnotherWMRunning)
                winMWExtWMRestackWindows(s_pScreen);
        }
#endif

        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case ID_APP_EXIT:
            /* Display Exit dialog */
            winDisplayExitDialog(s_pScreenPriv);
            return 0;

#ifdef XWIN_MULTIWINDOW
        case ID_APP_HIDE_ROOT:
            if (s_pScreenPriv->fRootWindowShown)
                ShowWindow(s_pScreenPriv->hwndScreen, SW_HIDE);
            else
                ShowWindow(s_pScreenPriv->hwndScreen, SW_SHOW);
            s_pScreenPriv->fRootWindowShown = !s_pScreenPriv->fRootWindowShown;
            return 0;
#endif

#ifdef XWIN_CLIPBOARD
        case ID_APP_MONITOR_PRIMARY:
            fPrimarySelection = !fPrimarySelection;
            return 0;
#endif

        case ID_APP_ABOUT:
            /* Display the About box */
            winDisplayAboutDialog(s_pScreenPriv);
            return 0;

        default:
            /* It's probably one of the custom menus... */
            if (HandleCustomWM_COMMAND(0, LOWORD(wParam)))
                return 0;
        }
        break;

    case WM_GIVEUP:
        /* Tell X that we are giving up */
#ifdef XWIN_MULTIWINDOW
        if (s_pScreenInfo->fMultiWindow)
            winDeinitMultiWindowWM();
#endif
        GiveUp(0);
        return 0;

    case WM_CLOSE:
        /* Display Exit dialog */
        winDisplayExitDialog(s_pScreenPriv);
        return 0;

    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT) {
            if (!g_fSoftwareCursor)
                SetCursor(s_pScreenPriv->cursor.handle);
            return TRUE;
        }
        break;

#ifdef XWIN_MULTIWINDOWEXTWM
    case WM_MANAGE:
        ErrorF("winWindowProc - WM_MANAGE\n");
        s_pScreenInfo->fAnotherWMRunning = FALSE;

        if (s_pScreenInfo->fInternalWM) {
            EnumThreadWindows(g_dwCurrentThreadID, winMWExtWMDecorateWindow, 0);
            //RootlessRepositionWindows (s_pScreen);
        }
        break;

    case WM_UNMANAGE:
        ErrorF("winWindowProc - WM_UNMANAGE\n");
        s_pScreenInfo->fAnotherWMRunning = TRUE;

        if (s_pScreenInfo->fInternalWM) {
            EnumThreadWindows(g_dwCurrentThreadID, winMWExtWMDecorateWindow, 0);
            winMWExtWMRestackWindows(s_pScreen);
        }
        break;
#endif

    default:
        if (message == s_uTaskbarRestart) {
            winInitNotifyIcon(s_pScreenPriv);
        }
        break;
    }

    return DefWindowProc(hwnd, message, wParam, lParam);
}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d165 1
a165 2
            && (s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
                || s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL)) {
d171 1
a171 1
               LOWORD(lParam), HIWORD(lParam), wParam);
d188 1
a188 2
            if ((s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD ||
                 s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL)) {
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d45 3
d166 1
a166 5
                || s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
#ifdef XWIN_PRIMARYFB
                || s_pScreenInfo->dwEngine == WIN_SERVER_PRIMARY_DD
#endif
            )) {
d190 1
a190 5
                 s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
#ifdef XWIN_PRIMARYFB
                 || s_pScreenInfo->dwEngine == WIN_SERVER_PRIMARY_DD
#endif
                )) {
d406 1
a406 1
         * NOTE: Scrollbars may have moved if they were at the 
d624 1
a624 1
        winDebug("winWindowProc - WM_GETMINMAXINFO - pScreenInfo: %08x\n",
d1056 1
a1056 1
        /* 
d1061 1
a1061 1
                /* ago: Pressing LControl while RControl is pressed is 
d1218 6
@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d958 1
a958 1
            if (g_fButton[0] & !wL)
d960 1
a960 1
            if (g_fButton[1] & !wM)
d962 1
a962 1
            if (g_fButton[2] & !wR)
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a64 1
    static HINSTANCE s_hInstance;
a118 1
        s_hInstance = ((LPCREATESTRUCT) lParam)->hInstance;
d897 1
a897 1
        return winMouseButtonsHandle(s_pScreen, ButtonPress, HIWORD(wParam) + 5,
d909 1
a909 1
                                     HIWORD(wParam) + 5, wParam);
d979 14
a992 1
        winMouseWheel(s_pScreen, GET_WHEEL_DELTA_WPARAM(wParam));
d1080 1
a1080 1
        winTranslateKey(wParam, lParam, &iScanCode);
d1109 1
a1109 1
        winTranslateKey(wParam, lParam, &iScanCode);
d1163 1
a1237 1
    case WM_ENDSESSION:
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d431 7
d933 1
d945 6
a950 2
            /* Deliver absolute cursor position to X Server */
            winEnqueueMotion(point.x, point.y);
@


1.3
log
@Update to xserver 1.11.2
@
text
@d50 2
a51 3
Bool				g_fCursor = TRUE;
Bool				g_fButton[3] = { FALSE, FALSE, FALSE };

d59 1
a59 2
winWindowProc (HWND hwnd, UINT message, 
	       WPARAM wParam, LPARAM lParam)
d61 10
a70 10
  static winPrivScreenPtr	s_pScreenPriv = NULL;
  static winScreenInfo		*s_pScreenInfo = NULL;
  static ScreenPtr		s_pScreen = NULL;
  static HWND			s_hwndLastPrivates = NULL;
  static HINSTANCE		s_hInstance;
  static Bool			s_fTracking = FALSE;
  static unsigned long		s_ulServerGeneration = 0;
  static UINT			s_uTaskbarRestart = 0;
  int				iScanCode;
  int				i;
d73 1
a73 1
  winDebugWin32Message("winWindowProc", hwnd, message, wParam, lParam);
d75 5
a79 6
  
  /* Watch for server regeneration */
  if (g_ulServerGeneration != s_ulServerGeneration)
    {
      /* Store new server generation */
      s_ulServerGeneration = g_ulServerGeneration;
d82 3
a84 4
  /* Only retrieve new privates pointers if window handle is null or changed */
  if ((s_pScreenPriv == NULL || hwnd != s_hwndLastPrivates)
      && (s_pScreenPriv = GetProp (hwnd, WIN_SCR_PROP)) != NULL)
    {
d86 1
a86 1
      winDebug ("winWindowProc - Setting privates handle\n");
d88 3
a90 3
      s_pScreenInfo = s_pScreenPriv->pScreenInfo;
      s_pScreen = s_pScreenInfo->pScreen;
      s_hwndLastPrivates = hwnd;
d92 5
a96 6
  else if (s_pScreenPriv == NULL)
    {
      /* For safety, handle case that should never happen */
      s_pScreenInfo = NULL;
      s_pScreen = NULL;
      s_hwndLastPrivates = NULL;
d99 2
a100 3
  /* Branch on message type */
  switch (message)
    {
d102 2
a103 2
      return winHandleIconMessage (hwnd, message, wParam, lParam,
				   s_pScreenPriv);
d107 1
a107 1
      winDebug ("winWindowProc - WM_CREATE\n");
d109 34
a142 35
      
      /*
       * Add a property to our display window that references
       * this screens' privates.
       *
       * This allows the window procedure to refer to the
       * appropriate window DC and shadow DC for the window that
       * it is processing.  We use this to repaint exposed
       * areas of our display window.
       */
      s_pScreenPriv = ((LPCREATESTRUCT) lParam)->lpCreateParams;
      s_hInstance = ((LPCREATESTRUCT) lParam)->hInstance;
      s_pScreenInfo = s_pScreenPriv->pScreenInfo;
      s_pScreen = s_pScreenInfo->pScreen;
      s_hwndLastPrivates = hwnd;
      s_uTaskbarRestart = RegisterWindowMessage(TEXT("TaskbarCreated"));
      SetProp (hwnd, WIN_SCR_PROP, s_pScreenPriv);

      /* Setup tray icon */
      if (!s_pScreenInfo->fNoTrayIcon)
	{
	  /*
	   * NOTE: The WM_CREATE message is processed before CreateWindowEx
	   * returns, so s_pScreenPriv->hwndScreen is invalid at this point.
	   * We go ahead and copy our hwnd parameter over top of the screen
	   * privates hwndScreen so that we have a valid value for
	   * that member.  Otherwise, the tray icon will disappear
	   * the first time you move the mouse over top of it.
	   */
	  
	  s_pScreenPriv->hwndScreen = hwnd;

	  winInitNotifyIcon (s_pScreenPriv);
	}
      return 0;
d145 21
a165 21
      /*
        WM_DISPLAYCHANGE seems to be sent when the monitor layout or
        any monitor's resolution or depth changes, but it's lParam and
        wParam always indicate the resolution and bpp for the primary
        monitor (so ignore that as we could be on any monitor...)
       */

      /* We cannot handle a display mode change during initialization */
      if (s_pScreenInfo == NULL)
	FatalError ("winWindowProc - WM_DISPLAYCHANGE - The display "
		    "mode changed while we were intializing.  This is "
		    "very bad and unexpected.  Exiting.\n");

      /*
       * We do not care about display changes with
       * fullscreen DirectDraw engines, because those engines set
       * their own mode when they become active.
       */
      if (s_pScreenInfo->fFullScreen
	  && (s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
	      || s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
d167 1
a167 1
	      || s_pScreenInfo->dwEngine == WIN_SERVER_PRIMARY_DD
d169 25
a193 22
	      ))
	{
	  break;
	}

      ErrorF ("winWindowProc - WM_DISPLAYCHANGE - new width: %d "
	      "new height: %d new bpp: %d\n",
	      LOWORD (lParam), HIWORD (lParam), wParam);

      /*
       * Check for a disruptive change in depth.
       * We can only display a message for a disruptive depth change,
       * we cannot do anything to correct the situation.
       */
      /*
        XXX: maybe we need to check if GetSystemMetrics(SM_SAMEDISPLAYFORMAT)
        has changed as well...
      */
      if (s_pScreenInfo->dwBPP != GetDeviceCaps (s_pScreenPriv->hdcScreen, BITSPIXEL))
        {
          if ((s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
               || s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
d195 1
a195 1
               || s_pScreenInfo->dwEngine == WIN_SERVER_PRIMARY_DD
d197 3
a199 4
               ))
            {
              /* Cannot display the visual until the depth is restored */
              ErrorF ("winWindowProc - Disruptive change in depth\n");
d201 2
a202 2
              /* Display depth change dialog */
              winDisplayDepthChangeDialog (s_pScreenPriv);
d204 2
a205 2
              /* Flag that we have an invalid screen depth */
              s_pScreenPriv->fBadDepth = TRUE;
d207 2
a208 2
              /* Minimize the display window */
              ShowWindow (hwnd, SW_MINIMIZE);
d210 4
a213 4
          else
            {
              /* For GDI, performance may suffer until original depth is restored */
              ErrorF ("winWindowProc - Performance may be non-optimal after change in depth\n");
d216 3
a218 4
      else
        {
          /* Flag that we have a valid screen depth */
          s_pScreenPriv->fBadDepth = FALSE;
d221 14
a234 15
      /*
        If we could cheaply check if this WM_DISPLAYCHANGE change
        affects the monitor(s) which this X screen is displayed on
        then we should do so here.  For the moment, assume it does.
        (this is probably usually the case so that might be an
        overoptimization)
      */
	{
	  /*
             In rootless modes which are monitor or virtual desktop size
             use RandR to resize the X screen
          */
          if ((!s_pScreenInfo->fUserGaveHeightAndWidth) &&
              (s_pScreenInfo->iResizeMode == resizeWithRandr) &&
              (FALSE
d236 7
a242 3
               || s_pScreenInfo->fMWExtWM
#endif
               || s_pScreenInfo->fRootless
d244 11
a254 11
               || s_pScreenInfo->fMultiWindow
#endif
               ))
	    {
              DWORD dwWidth, dwHeight;

              if (s_pScreenInfo->fMultipleMonitors)
                {
                  /* resize to new virtual desktop size */
                  dwWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
                  dwHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);
d256 12
a267 14
              else
                {
                  /* resize to new size of specified monitor */
                  struct GetMonitorInfoData data;
                  if (QueryMonitor(s_pScreenInfo->iMonitor, &data))
                    {
                      if (data.bMonitorSpecifiedExists == TRUE)
                        {
                          dwWidth = data.monitorWidth;
                          dwHeight = data.monitorHeight;
                          /*
                             XXX: monitor may have changed position,
                             so we might need to update xinerama data
                          */
d269 3
a271 3
                      else
                        {
                          ErrorF ("Monitor number %d no longer exists!\n", s_pScreenInfo->iMonitor);
d276 18
a293 17
              /*
                XXX: probably a small bug here: we don't compute the work area
                and allow for task bar

                XXX: generally, we don't allow for the task bar being moved after
                the server is started
               */

              /* Set screen size to match new size, if it is different to current */
              if ((s_pScreenInfo->dwWidth != dwWidth) ||
                  (s_pScreenInfo->dwHeight != dwHeight))
                {
                  winDoRandRScreenSetSize(s_pScreen,
                                          dwWidth,
                                          dwHeight,
                                          (dwWidth * 25.4) / monitorResolution,
                                          (dwHeight * 25.4) / monitorResolution);
d295 14
a308 15
	    }
          else
            {
              /*
               * We can simply recreate the same-sized primary surface when
               * the display dimensions change.
               */

              /*
               * NOTE: The non-DirectDraw engines set the ReleasePrimarySurface
               * and CreatePrimarySurface function pointers to point
               * to the no operation function, NoopDDA.  This allows us
               * to blindly call these functions, even if they are not
               * relevant to the current engine (e.g., Shadow GDI).
               */
d310 2
a311 1
              winDebug ("winWindowProc - WM_DISPLAYCHANGE - Releasing and recreating primary surface\n");
d313 2
a314 2
              /* Release the old primary surface */
              (*s_pScreenPriv->pwinReleasePrimarySurface) (s_pScreen);
d316 2
a317 2
              /* Create the new primary surface */
              (*s_pScreenPriv->pwinCreatePrimarySurface) (s_pScreen);
d319 1
a319 1
	}
d321 1
a321 1
      break;
d324 4
a327 4
      {
	SCROLLINFO		si;
	RECT			rcWindow;
	int			iWidth, iHeight;
d330 1
a330 1
	winDebug ("winWindowProc - WM_SIZE\n");
d333 3
a335 3
	/* Break if we do not allow resizing */
	if ((s_pScreenInfo->iResizeMode == notAllowed)
	    || !s_pScreenInfo->fDecoration
d337 1
a337 1
	    || s_pScreenInfo->fMWExtWM
d339 1
a339 1
	    || s_pScreenInfo->fRootless
d341 1
a341 1
	    || s_pScreenInfo->fMultiWindow
d343 2
a344 2
	    || s_pScreenInfo->fFullScreen)
	  break;
d346 3
a348 3
	/* No need to resize if we get minimized */
	if (wParam == SIZE_MINIMIZED)
	  return 0;
d350 2
a351 2
        ErrorF ("winWindowProc - WM_SIZE - new client area w: %d h: %d\n",
                LOWORD (lParam), HIWORD (lParam));
d353 1
a353 2
        if (s_pScreenInfo->iResizeMode == resizeWithRandr)
          {
d356 1
a356 1
          }
d360 70
a429 71
	/*
	 * Get the size of the whole window, including client area,
	 * scrollbars, and non-client area decorations (caption, borders).
	 * We do this because we need to check if the client area
	 * without scrollbars is large enough to display the whole visual.
	 * The new client area size passed by lParam already subtracts
	 * the size of the scrollbars if they are currently displayed.
	 * So checking is LOWORD(lParam) == visual_width and
	 * HIWORD(lParam) == visual_height will never tell us to hide
	 * the scrollbars because the client area would always be too small.
	 * GetClientRect returns the same sizes given by lParam, so we
	 * cannot use GetClientRect either.
	 */
	GetWindowRect (hwnd, &rcWindow);
	iWidth = rcWindow.right - rcWindow.left;
	iHeight = rcWindow.bottom - rcWindow.top;

	/* Subtract the frame size from the window size. */
	iWidth -= 2 * GetSystemMetrics (SM_CXSIZEFRAME);
	iHeight -= (2 * GetSystemMetrics (SM_CYSIZEFRAME)
		    + GetSystemMetrics (SM_CYCAPTION));

	/*
	 * Update scrollbar page sizes.
	 * NOTE: If page size == range, then the scrollbar is
	 * automatically hidden.
	 */

	/* Is the naked client area large enough to show the whole visual? */
	if (iWidth < s_pScreenInfo->dwWidth
	    || iHeight < s_pScreenInfo->dwHeight)
	  {
	    /* Client area too small to display visual, use scrollbars */
	    iWidth -= GetSystemMetrics (SM_CXVSCROLL);
	    iHeight -= GetSystemMetrics (SM_CYHSCROLL);
	  }
	
	/* Set the horizontal scrollbar page size */
	si.cbSize = sizeof (si);
	si.fMask = SIF_PAGE | SIF_RANGE;
	si.nMin = 0;
	si.nMax = s_pScreenInfo->dwWidth - 1;
	si.nPage = iWidth;
	SetScrollInfo (hwnd, SB_HORZ, &si, TRUE);
	
	/* Set the vertical scrollbar page size */
	si.cbSize = sizeof (si);
	si.fMask = SIF_PAGE | SIF_RANGE;
	si.nMin = 0;
	si.nMax = s_pScreenInfo->dwHeight - 1;
	si.nPage = iHeight;
	SetScrollInfo (hwnd, SB_VERT, &si, TRUE);

	/*
	 * NOTE: Scrollbars may have moved if they were at the 
	 * far right/bottom, so we query their current position.
	 */
	
	/* Get the horizontal scrollbar position and set the offset */
	si.cbSize = sizeof (si);
	si.fMask = SIF_POS;
	GetScrollInfo (hwnd, SB_HORZ, &si);
	s_pScreenInfo->dwXOffset = -si.nPos;
	
	/* Get the vertical scrollbar position and set the offset */
	si.cbSize = sizeof (si);
	si.fMask = SIF_POS;
	GetScrollInfo (hwnd, SB_VERT, &si);
	s_pScreenInfo->dwYOffset = -si.nPos;
      }
      return 0;
d432 2
a433 2
      ErrorF("winWindowProc - WM_ENTERSIZEMOVE\n");
      break;
d436 1
a436 1
      ErrorF("winWindowProc - WM_EXITSIZEMOVE\n");
d438 17
a454 19
      if (s_pScreenInfo->iResizeMode == resizeWithRandr)
        {
          /* Set screen size to match new client area, if it is different to current */
          RECT rcClient;
          DWORD dwWidth, dwHeight;

          GetClientRect (hwnd, &rcClient);
          dwWidth = rcClient.right - rcClient.left;
          dwHeight = rcClient.bottom - rcClient.top;

          if ((s_pScreenInfo->dwWidth != dwWidth) ||
              (s_pScreenInfo->dwHeight != dwHeight))
            {
              /* mm = dots * (25.4 mm / inch) / (dots / inch) */
              winDoRandRScreenSetSize(s_pScreen,
                                      dwWidth,
                                      dwHeight,
                                      (dwWidth * 25.4) / monitorResolution,
                                      (dwHeight * 25.4) / monitorResolution);
d458 1
a458 1
      break;
d461 3
a463 3
      {
	SCROLLINFO		si;
	int			iVertPos;
d466 1
a466 1
	winDebug ("winWindowProc - WM_VSCROLL\n");
d468 70
a537 76
      
	/* Get vertical scroll bar info */
	si.cbSize = sizeof (si);
	si.fMask = SIF_ALL;
	GetScrollInfo (hwnd, SB_VERT, &si);

	/* Save the vertical position for comparison later */
	iVertPos = si.nPos;

	/*
	 * Don't forget:
	 * moving the scrollbar to the DOWN, scroll the content UP
	 */
	switch (LOWORD(wParam))
	  {
	  case SB_TOP:
	    si.nPos = si.nMin;
	    break;
	  
	  case SB_BOTTOM:
	    si.nPos = si.nMax - si.nPage + 1;
	    break;

	  case SB_LINEUP:
	    si.nPos -= 1;
	    break;
	  
	  case SB_LINEDOWN:
	    si.nPos += 1;
	    break;
	  
	  case SB_PAGEUP:
	    si.nPos -= si.nPage;
	    break;
	  
	  case SB_PAGEDOWN:
	    si.nPos += si.nPage;
	    break;

	  case SB_THUMBTRACK:
	    si.nPos = si.nTrackPos;
	    break;

	  default:
	    break;
	  }

	/*
	 * We retrieve the position after setting it,
	 * because Windows may adjust it.
	 */
	si.fMask = SIF_POS;
	SetScrollInfo (hwnd, SB_VERT, &si, TRUE);
	GetScrollInfo (hwnd, SB_VERT, &si);
      
	/* Scroll the window if the position has changed */
	if (si.nPos != iVertPos)
	  {
	    /* Save the new offset for bit block transfers, etc. */
	    s_pScreenInfo->dwYOffset = -si.nPos;

	    /* Change displayed region in the window */
	    ScrollWindowEx (hwnd,
			    0,
			    iVertPos - si.nPos,
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    SW_INVALIDATE);
	  
	    /* Redraw the window contents */
	    UpdateWindow (hwnd);
	  }
      }
      return 0;
d540 3
a542 3
      {
	SCROLLINFO		si;
	int			iHorzPos;
d545 1
a545 1
	winDebug ("winWindowProc - WM_HSCROLL\n");
d547 69
a615 76
      
	/* Get horizontal scroll bar info */
	si.cbSize = sizeof (si);
	si.fMask = SIF_ALL;
	GetScrollInfo (hwnd, SB_HORZ, &si);

	/* Save the horizontal position for comparison later */
	iHorzPos = si.nPos;

	/*
	 * Don't forget:
	 * moving the scrollbar to the RIGHT, scroll the content LEFT
	 */
	switch (LOWORD(wParam))
	  {
	  case SB_LEFT:
	    si.nPos = si.nMin;
	    break;
	  
	  case SB_RIGHT:
	    si.nPos = si.nMax - si.nPage + 1;
	    break;

	  case SB_LINELEFT:
	    si.nPos -= 1;
	    break;
	  
	  case SB_LINERIGHT:
	    si.nPos += 1;
	    break;
	  
	  case SB_PAGELEFT:
	    si.nPos -= si.nPage;
	    break;
	  
	  case SB_PAGERIGHT:
	    si.nPos += si.nPage;
	    break;

	  case SB_THUMBTRACK:
	    si.nPos = si.nTrackPos;
	    break;

	  default:
	    break;
	  }

	/*
	 * We retrieve the position after setting it,
	 * because Windows may adjust it.
	 */
	si.fMask = SIF_POS;
	SetScrollInfo (hwnd, SB_HORZ, &si, TRUE);
	GetScrollInfo (hwnd, SB_HORZ, &si);
      
	/* Scroll the window if the position has changed */
	if (si.nPos != iHorzPos)
	  {
	    /* Save the new offset for bit block transfers, etc. */
	    s_pScreenInfo->dwXOffset = -si.nPos;

	    /* Change displayed region in the window */
	    ScrollWindowEx (hwnd,
			    iHorzPos - si.nPos,
			    0,
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    SW_INVALIDATE);
	  
	    /* Redraw the window contents */
	    UpdateWindow (hwnd);
	  }
      }
      return 0;
d618 8
a625 8
      {
	MINMAXINFO		*pMinMaxInfo = (MINMAXINFO *) lParam;
	int			iCaptionHeight;
	int			iBorderHeight, iBorderWidth;

#if CYGDEBUG	
	winDebug ("winWindowProc - WM_GETMINMAXINFO - pScreenInfo: %08x\n",
		s_pScreenInfo);
d628 4
a631 5
	/* Can't do anything without screen info */
	if (s_pScreenInfo == NULL
	    || (s_pScreenInfo->iResizeMode != resizeWithScrollbars)
	    || s_pScreenInfo->fFullScreen
	    || !s_pScreenInfo->fDecoration
d633 1
a633 1
	    || s_pScreenInfo->fMWExtWM
d635 1
a635 1
	    || s_pScreenInfo->fRootless
d637 1
a637 1
	    || s_pScreenInfo->fMultiWindow
d639 2
a640 2
	    )
	  break;
d642 23
a664 24
	/*
	 * Here we can override the maximum tracking size, which
	 * is the largest size that can be assigned to our window
	 * via the sizing border.
	 */

	/*
	 * FIXME: Do we only need to do this once, since our visual size
	 * does not change?  Does Windows store this value statically
	 * once we have set it once?
	 */

	/* Get the border and caption sizes */
	iCaptionHeight = GetSystemMetrics (SM_CYCAPTION);
	iBorderWidth = 2 * GetSystemMetrics (SM_CXSIZEFRAME);
	iBorderHeight = 2 * GetSystemMetrics (SM_CYSIZEFRAME);
	
	/* Allow the full visual to be displayed */
	pMinMaxInfo->ptMaxTrackSize.x
	  = s_pScreenInfo->dwWidth + iBorderWidth;
	pMinMaxInfo->ptMaxTrackSize.y
	  = s_pScreenInfo->dwHeight + iBorderHeight + iCaptionHeight;
      }
      return 0;
d668 1
a668 1
      winDebug ("winWindowProc - WM_ERASEBKGND\n");
d670 6
a675 6
      /*
       * Pretend that we did erase the background but we don't care,
       * the application uses the full window estate. This avoids some
       * flickering when resizing.
       */
      return TRUE;
d679 1
a679 1
      winDebug ("winWindowProc - WM_PAINT\n");
d681 16
a696 17
      /* Only paint if we have privates and the server is enabled */
      if (s_pScreenPriv == NULL
	  || !s_pScreenPriv->fEnabled
	  || (s_pScreenInfo->fFullScreen && !s_pScreenPriv->fActive)
	  || s_pScreenPriv->fBadDepth)
	{
	  /* We don't want to paint */
	  break;
	}

      /* Break out here if we don't have a valid paint routine */
      if (s_pScreenPriv->pwinBltExposedRegions == NULL)
	break;
      
      /* Call the engine dependent repainter */
      (*s_pScreenPriv->pwinBltExposedRegions) (s_pScreen);
      return 0;
d699 1
a699 1
      {
d701 1
a701 1
	winDebug ("winWindowProc - WM_PALETTECHANGED\n");
d703 23
a725 24
	/*
	 * Don't process if we don't have privates or a colormap,
	 * or if we have an invalid depth.
	 */
	if (s_pScreenPriv == NULL
	    || s_pScreenPriv->pcmapInstalled == NULL
	    || s_pScreenPriv->fBadDepth)
	  break;

	/* Return if we caused the palette to change */
	if ((HWND) wParam == hwnd)
	  {
	    /* Redraw the screen */
	    (*s_pScreenPriv->pwinRedrawScreen) (s_pScreen);
	    return 0;
	  }
	
	/* Reinstall the windows palette */
	(*s_pScreenPriv->pwinRealizeInstalledPalette) (s_pScreen);
	
	/* Redraw the screen */
	(*s_pScreenPriv->pwinRedrawScreen) (s_pScreen);
	return 0;
      }
d728 31
a758 3
      /* We can't do anything without privates */
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
d760 13
a772 3
      /* We can't do anything without g_pwinPointer */
      if (g_pwinPointer == NULL)
        break;
d774 4
a777 44
      /* Has the mouse pointer crossed screens? */
      if (s_pScreen != miPointerGetScreen(g_pwinPointer))
	miPointerSetScreen (g_pwinPointer, s_pScreenInfo->dwScreen,
			       GET_X_LPARAM(lParam)-s_pScreenInfo->dwXOffset,
			       GET_Y_LPARAM(lParam)-s_pScreenInfo->dwYOffset);

      /* Are we tracking yet? */
      if (!s_fTracking)
	{
	  TRACKMOUSEEVENT		tme;
	  
	  /* Setup data structure */
	  ZeroMemory (&tme, sizeof (tme));
	  tme.cbSize = sizeof (tme);
	  tme.dwFlags = TME_LEAVE;
	  tme.hwndTrack = hwnd;

	  /* Call the tracking function */
	  if (!(*g_fpTrackMouseEvent) (&tme))
	    ErrorF ("winWindowProc - _TrackMouseEvent failed\n");

	  /* Flag that we are tracking now */
	  s_fTracking = TRUE;
	}

      /* Hide or show the Windows mouse cursor */
      if (g_fSoftwareCursor && g_fCursor && (s_pScreenPriv->fActive || s_pScreenInfo->fLessPointer))
	{
	  /* Hide Windows cursor */
	  g_fCursor = FALSE;
	  ShowCursor (FALSE);
	}
      else if (g_fSoftwareCursor && !g_fCursor && !s_pScreenPriv->fActive
	       && !s_pScreenInfo->fLessPointer)
	{
	  /* Show Windows cursor */
	  g_fCursor = TRUE;
	  ShowCursor (TRUE);
	}
      
      /* Deliver absolute cursor position to X Server */
      winEnqueueMotion(GET_X_LPARAM(lParam)-s_pScreenInfo->dwXOffset,
		       GET_Y_LPARAM(lParam)-s_pScreenInfo->dwYOffset);
      return 0;
d780 19
a798 20
      /*
       * We break instead of returning 0 since we need to call
       * DefWindowProc to get the mouse cursor changes
       * and min/max/close button highlighting in Windows XP.
       * The Platform SDK says that you should return 0 if you
       * process this message, but it fails to mention that you
       * will give up any default functionality if you do return 0.
       */
      
      /* We can't do anything without privates */
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      
      /* Non-client mouse movement, show Windows cursor */
      if (g_fSoftwareCursor && !g_fCursor)
	{
	  g_fCursor = TRUE;
	  ShowCursor (TRUE);
	}
      break;
d801 1
a801 1
      /* Mouse has left our client area */
d803 2
a804 2
      /* Flag that we are no longer tracking */
      s_fTracking = FALSE;
d806 6
a811 7
      /* Show the mouse cursor, if necessary */
      if (g_fSoftwareCursor && !g_fCursor)
	{
	  g_fCursor = TRUE;
	  ShowCursor (TRUE);
	}
      return 0;
d815 3
a817 3
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      if (s_pScreenInfo->fRootless
d819 1
a819 1
	  || s_pScreenInfo->fMWExtWM
d821 4
a824 4
	  )
	SetCapture (hwnd);
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button1, wParam);
      
d826 3
a828 3
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      if (s_pScreenInfo->fRootless
d830 1
a830 1
	  || s_pScreenInfo->fMWExtWM
d832 3
a834 3
	  )
	ReleaseCapture ();
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button1, wParam);
d838 3
a840 3
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      if (s_pScreenInfo->fRootless
d842 1
a842 1
	  || s_pScreenInfo->fMWExtWM
d844 4
a847 4
	  )
	SetCapture (hwnd);
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button2, wParam);
      
d849 3
a851 3
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      if (s_pScreenInfo->fRootless
d853 1
a853 1
	  || s_pScreenInfo->fMWExtWM
d855 4
a858 4
	  )
	ReleaseCapture ();
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button2, wParam);
      
d861 3
a863 3
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      if (s_pScreenInfo->fRootless
d865 1
a865 1
	  || s_pScreenInfo->fMWExtWM
d867 4
a870 4
	  )
	SetCapture (hwnd);
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button3, wParam);
      
d872 3
a874 3
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      if (s_pScreenInfo->fRootless
d876 1
a876 1
	  || s_pScreenInfo->fMWExtWM
d878 3
a880 3
	  )
	ReleaseCapture ();
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button3, wParam);
d884 3
a886 3
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      if (s_pScreenInfo->fRootless
d888 1
a888 1
	  || s_pScreenInfo->fMWExtWM
d890 4
a893 3
	  )
	SetCapture (hwnd);
      return winMouseButtonsHandle (s_pScreen, ButtonPress, HIWORD(wParam) + 5, wParam);
d895 3
a897 3
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      if (s_pScreenInfo->fRootless
d899 1
a899 1
	  || s_pScreenInfo->fMWExtWM
d901 4
a904 3
	  )
	ReleaseCapture ();
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, HIWORD(wParam) + 5, wParam);
d907 2
a908 2
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
d910 47
a956 48
      /* Branch on the timer id */
      switch (wParam)
	{
	case WIN_E3B_TIMER_ID:
	  /* Send delayed button press */
	  winMouseButtonsSendEvent (ButtonPress,
				    s_pScreenPriv->iE3BCachedPress);

	  /* Kill this timer */
	  KillTimer (s_pScreenPriv->hwndScreen, WIN_E3B_TIMER_ID);

	  /* Clear screen privates flags */
	  s_pScreenPriv->iE3BCachedPress = 0;
	  break;

	case WIN_POLLING_MOUSE_TIMER_ID:
	  {
	    POINT		point;
	    WPARAM		wL, wM, wR, wShift, wCtrl;
	    LPARAM		lPos;
	    
	    /* Get the current position of the mouse cursor */
	    GetCursorPos (&point);
	    
	    /* Map from screen (-X, -Y) to root (0, 0) */
	    point.x -= GetSystemMetrics (SM_XVIRTUALSCREEN);
	    point.y -= GetSystemMetrics (SM_YVIRTUALSCREEN);
	    
	    /* Deliver absolute cursor position to X Server */
	    winEnqueueMotion(point.x , point.y);

	    /* Check if a button was released but we didn't see it */
	    GetCursorPos (&point);
	    wL = (GetKeyState (VK_LBUTTON) & 0x8000)?MK_LBUTTON:0;
	    wM = (GetKeyState (VK_MBUTTON) & 0x8000)?MK_MBUTTON:0;
	    wR = (GetKeyState (VK_RBUTTON) & 0x8000)?MK_RBUTTON:0;
	    wShift = (GetKeyState (VK_SHIFT) & 0x8000)?MK_SHIFT:0;
	    wCtrl = (GetKeyState (VK_CONTROL) & 0x8000)?MK_CONTROL:0;
	    lPos = MAKELPARAM(point.x, point.y);
	    if (g_fButton[0] & !wL)
	    PostMessage (hwnd, WM_LBUTTONUP, wCtrl|wM|wR|wShift, lPos);
	    if (g_fButton[1] & !wM)
	      PostMessage (hwnd, WM_MBUTTONUP, wCtrl|wL|wR|wShift, lPos);
	    if (g_fButton[2] & !wR)
	      PostMessage (hwnd, WM_RBUTTONUP, wCtrl|wL|wM|wShift, lPos);
	  }
	}
      return 0;
d959 3
a961 3
      FatalError ("winWindowProc - WM_CTLCOLORSCROLLBAR - We are not "
		  "supposed to get this message.  Exiting.\n");
      return 0;
d964 2
a965 2
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
d967 1
a967 1
      winDebug ("winWindowProc - WM_MOUSEWHEEL\n");
d969 2
a970 2
      winMouseWheel (s_pScreen, GET_WHEEL_DELTA_WPARAM(wParam));
      break;
d973 2
a974 2
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
d976 2
a977 2
      /* Restore the state of all mode keys */
      winRestoreModeKeyStates ();
d979 4
a982 4
      /* Add the keyboard hook if possible */
      if (g_fKeyboardHookLL)
	g_fKeyboardHookLL = winInstallKeyboardHookLL ();
      return 0;
d985 2
a986 2
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
d988 2
a989 2
      /* Release any pressed keys */
      winKeybdReleaseKeys ();
d991 3
a993 3
      /* Remove our keyboard hook if it is installed */
      winRemoveKeyboardHookLL ();
      return 0;
d997 28
a1024 2
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
d1026 6
a1031 49
      /*
       * FIXME: Catching Alt-F4 like this is really terrible.  This should
       * be generalized to handle other Windows keyboard signals.  Actually,
       * the list keys to catch and the actions to perform when caught should
       * be configurable; that way user's can customize the keys that they
       * need to have passed through to their window manager or apps, or they
       * can remap certain actions to new key codes that do not conflict
       * with the X apps that they are using.  Yeah, that'll take awhile.
       */
      if ((s_pScreenInfo->fUseWinKillKey && wParam == VK_F4
	   && (GetKeyState (VK_MENU) & 0x8000))
	  || (s_pScreenInfo->fUseUnixKillKey && wParam == VK_BACK
	      && (GetKeyState (VK_MENU) & 0x8000)
	      && (GetKeyState (VK_CONTROL) & 0x8000)))
	{
	  /*
	   * Better leave this message here, just in case some unsuspecting
	   * user enters Alt + F4 and is surprised when the application
	   * quits.
	   */
	  ErrorF ("winWindowProc - WM_*KEYDOWN - Closekey hit, quitting\n");
	  
	  /* Display Exit dialog */
	  winDisplayExitDialog (s_pScreenPriv);
	  return 0;
	}
      
      /*
       * Don't do anything for the Windows keys, as focus will soon
       * be returned to Windows.  We may be able to trap the Windows keys,
       * but we should determine if that is desirable before doing so.
       */
      if ((wParam == VK_LWIN || wParam == VK_RWIN) && !g_fKeyboardHookLL)
	break;

      /* 
       * Discard presses generated from Windows auto-repeat
       */
      if (lParam & (1<<30))
      {
        switch (wParam)
        {
          /* ago: Pressing LControl while RControl is pressed is 
           * Indicated as repeat. Fix this!
           */
          case VK_CONTROL:
          case VK_SHIFT:
            if (winCheckKeyPressed(wParam, lParam))
              return 0;
d1033 3
a1035 1
          default:
d1037 17
d1055 12
a1066 17
      } 
      
      /* Discard fake Ctrl_L presses that precede AltGR on non-US keyboards */
      if (winIsFakeCtrl_L (message, wParam, lParam))
	return 0;
      
      /* Translate Windows key code to X scan code */
      winTranslateKey (wParam, lParam, &iScanCode);

      /* Ignore repeats for CapsLock */
      if (wParam == VK_CAPITAL)
	lParam = 1;

      /* Send the key event(s) */
      for (i = 0; i < LOWORD(lParam); ++i)
	winSendKeyEvent (iScanCode, TRUE);
      return 0;
d1070 10
a1079 2
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
d1081 12
a1092 20
      /*
       * Don't do anything for the Windows keys, as focus will soon
       * be returned to Windows.  We may be able to trap the Windows keys,
       * but we should determine if that is desirable before doing so.
       */
      if ((wParam == VK_LWIN || wParam == VK_RWIN) && !g_fKeyboardHookLL)
	break;

      /* Ignore the fake Ctrl_L that follows an AltGr release */
      if (winIsFakeCtrl_L (message, wParam, lParam))
	return 0;

      /* Enqueue a keyup event */
      winTranslateKey (wParam, lParam, &iScanCode);
      winSendKeyEvent (iScanCode, FALSE);

      /* Release all pressed shift keys */
      if (wParam == VK_SHIFT) 
        winFixShiftKeys (iScanCode);
      return 0;
d1095 2
a1096 2
      if (s_pScreenPriv == NULL)
	break;
d1098 3
a1100 3
      /* Call the engine-specific hot key handler */
      (*s_pScreenPriv->pwinHotKeyAltTab) (s_pScreen);
      return 0;
d1103 24
a1126 28
      if (s_pScreenPriv == NULL
	  || s_pScreenInfo->fIgnoreInput)
	break;

      /* TODO: Override display of window when we have a bad depth */
      if (LOWORD(wParam) != WA_INACTIVE && s_pScreenPriv->fBadDepth)
	{
	  ErrorF ("winWindowProc - WM_ACTIVATE - Bad depth, trying "
		  "to override window activation\n");

	  /* Minimize the window */
	  ShowWindow (hwnd, SW_MINIMIZE);

	  /* Display dialog box */
	  if (g_hDlgDepthChange != NULL)
	    {
	      /* Make the existing dialog box active */
	      SetActiveWindow (g_hDlgDepthChange);
	    }
	  else
	    {
	      /* TODO: Recreate the dialog box and bring to the top */
	      ShowWindow (g_hDlgDepthChange, SW_SHOWDEFAULT);
	    }

	  /* Don't do any other processing of this message */
	  return 0;
	}
d1129 1
a1129 1
      winDebug ("winWindowProc - WM_ACTIVATE\n");
d1132 16
a1147 18
      /*
       * Focus is being changed to another window.
       * The other window may or may not belong to
       * our process.
       */

      /* Clear any lingering wheel delta */
      s_pScreenPriv->iDeltaZ = 0;

      /* Reshow the Windows mouse cursor if we are being deactivated */
      if (g_fSoftwareCursor && LOWORD(wParam) == WA_INACTIVE
	  && !g_fCursor)
	{
	  /* Show Windows cursor */
	  g_fCursor = TRUE;
	  ShowCursor (TRUE);
	}
      return 0;
d1150 2
a1151 3
      if (s_pScreenPriv == NULL
	  || s_pScreenInfo->fIgnoreInput)
	break;
d1154 1
a1154 1
      winDebug ("winWindowProc - WM_ACTIVATEAPP\n");
d1157 2
a1158 2
      /* Activate or deactivate */
      s_pScreenPriv->fActive = wParam;
d1160 6
a1165 8
      /* Reshow the Windows mouse cursor if we are being deactivated */
      if (g_fSoftwareCursor && !s_pScreenPriv->fActive
	  && !g_fCursor)
	{
	  /* Show Windows cursor */
	  g_fCursor = TRUE;
	  ShowCursor (TRUE);
	}
d1168 2
a1169 2
      /* Make sure the clipboard chain is ok. */
      winFixClipboardChain ();
d1172 2
a1173 2
      /* Call engine specific screen activation/deactivation function */
      (*s_pScreenPriv->pwinActivateApp) (s_pScreen);
d1176 5
a1180 6
      if (s_pScreenPriv->fActive)
	{
	  /* Restack all window unless using built-in wm. */
	  if (s_pScreenInfo->fInternalWM && s_pScreenInfo->fAnotherWMRunning)
	    winMWExtWMRestackWindows (s_pScreen);
	}
d1183 1
a1183 1
      return 0;
d1186 5
a1190 6
      switch (LOWORD (wParam))
	{
	case ID_APP_EXIT:
	  /* Display Exit dialog */
	  winDisplayExitDialog (s_pScreenPriv);
	  return 0;
d1193 20
a1212 20
	case ID_APP_HIDE_ROOT:
	  if (s_pScreenPriv->fRootWindowShown)
	    ShowWindow (s_pScreenPriv->hwndScreen, SW_HIDE);
	  else
	    ShowWindow (s_pScreenPriv->hwndScreen, SW_SHOW);
	  s_pScreenPriv->fRootWindowShown = !s_pScreenPriv->fRootWindowShown;
	  return 0;
#endif

	case ID_APP_ABOUT:
	  /* Display the About box */
	  winDisplayAboutDialog (s_pScreenPriv);
	  return 0;

	default:
	  /* It's probably one of the custom menus... */
	  if (HandleCustomWM_COMMAND (0, LOWORD (wParam)))
	    return 0;
	}
      break;
d1216 1
a1216 1
      /* Tell X that we are giving up */
d1218 2
a1219 2
      if (s_pScreenInfo->fMultiWindow)
	winDeinitMultiWindowWM ();
d1221 2
a1222 2
      GiveUp (0);
      return 0;
d1225 3
a1227 3
      /* Display Exit dialog */
      winDisplayExitDialog (s_pScreenPriv);
      return 0;
d1230 6
a1235 6
      if (LOWORD(lParam) == HTCLIENT)
	{
	  if (!g_fSoftwareCursor) SetCursor (s_pScreenPriv->cursor.handle);
	  return TRUE;
	}
      break;
d1239 2
a1240 2
      ErrorF ("winWindowProc - WM_MANAGE\n");
      s_pScreenInfo->fAnotherWMRunning = FALSE;
d1242 5
a1246 6
      if (s_pScreenInfo->fInternalWM)
	{
	  EnumThreadWindows (g_dwCurrentThreadID, winMWExtWMDecorateWindow, 0);
	  //RootlessRepositionWindows (s_pScreen);
	}
      break;
d1249 2
a1250 2
      ErrorF ("winWindowProc - WM_UNMANAGE\n");
      s_pScreenInfo->fAnotherWMRunning = TRUE;
d1252 5
a1256 6
      if (s_pScreenInfo->fInternalWM)
	{
	  EnumThreadWindows (g_dwCurrentThreadID, winMWExtWMDecorateWindow, 0);
	  winMWExtWMRestackWindows (s_pScreen);
	}
      break;
d1260 4
a1263 5
      if(message == s_uTaskbarRestart)
	{
	  winInitNotifyIcon (s_pScreenPriv);
	}
      break;
d1266 1
a1266 1
  return DefWindowProc (hwnd, message, wParam, lParam);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d43 1
a54 12
 * References to external symbols
 */

extern Bool			g_fClipboard;
extern HWND			g_hDlgDepthChange;
extern Bool			g_fKeyboardHookLL;
extern HWND			g_hwndKeyboardFocus;
extern Bool			g_fSoftwareCursor;
extern DWORD			g_dwCurrentThreadID;


/*
d152 7
a177 9
	  /* 
	   * Store the new display dimensions and depth.
	   * We do this here for future compatibility in case we
	   * ever allow switching from fullscreen to windowed mode.
	   */
	  s_pScreenPriv->dwLastWindowsWidth = GetSystemMetrics (SM_CXSCREEN);
	  s_pScreenPriv->dwLastWindowsHeight = GetSystemMetrics (SM_CYSCREEN);
	  s_pScreenPriv->dwLastWindowsBitsPixel
	    = GetDeviceCaps (s_pScreenPriv->hdcScreen, BITSPIXEL);	  
a179 6
      
      ErrorF ("winWindowProc - WM_DISPLAYCHANGE - orig bpp: %d, last bpp: %d, "
	      "new bpp: %d\n",
	      (int) s_pScreenInfo->dwBPP,
	      (int) s_pScreenPriv->dwLastWindowsBitsPixel,
	      wParam);
d182 2
a183 24
	      "new height: %d\n",
	      LOWORD (lParam), HIWORD (lParam));

      /*
       * TrueColor --> TrueColor depth changes are disruptive for:
       *	Windowed:
       *		Shadow DirectDraw
       *		Shadow DirectDraw Non-Locking
       *		Primary DirectDraw
       *
       * TrueColor --> TrueColor depth changes are non-optimal for:
       *	Windowed:
       *		Shadow GDI
       *
       *	FullScreen:
       *		Shadow GDI
       *
       * TrueColor --> PseudoColor or vice versa are disruptive for:
       *	Windowed:
       *		Shadow DirectDraw
       *		Shadow DirectDraw Non-Locking
       *		Primary DirectDraw
       *		Shadow GDI
       */
d190 8
a197 3
      if ((s_pScreenInfo->dwBPP != wParam)
	  && (s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
	      || s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
d199 1
a199 1
	      || s_pScreenInfo->dwEngine == WIN_SERVER_PRIMARY_DD
d201 25
a225 7
	      ))
	{
	  /* Cannot display the visual until the depth is restored */
	  ErrorF ("winWindowProc - Disruptive change in depth\n");

	  /* Display Exit dialog */
	  winDisplayDepthChangeDialog (s_pScreenPriv);
a226 12
	  /* Flag that we have an invalid screen depth */
	  s_pScreenPriv->fBadDepth = TRUE;

	  /* Minimize the display window */
	  ShowWindow (hwnd, SW_MINIMIZE);
	}
      else
	{
	  /* Flag that we have a valid screen depth */
	  s_pScreenPriv->fBadDepth = FALSE;
	}
      
d228 6
a233 6
       * Check for a change in display dimensions.
       * We can simply recreate the same-sized primary surface when
       * the display dimensions change.
       */
      if (s_pScreenPriv->dwLastWindowsWidth != LOWORD (lParam)
	  || s_pScreenPriv->dwLastWindowsHeight != HIWORD (lParam))
d236 8
a243 9
	   * NOTE: The non-DirectDraw engines set the ReleasePrimarySurface
	   * and CreatePrimarySurface function pointers to point
	   * to the no operation function, NoopDDA.  This allows us
	   * to blindly call these functions, even if they are not
	   * relevant to the current engine (e.g., Shadow GDI).
	   */

#if CYGDEBUG
	  winDebug ("winWindowProc - WM_DISPLAYCHANGE - Dimensions changed\n");
d245 3
a247 7
	  
	  /* Release the old primary surface */
	  (*s_pScreenPriv->pwinReleasePrimarySurface) (s_pScreen);

#if CYGDEBUG
	  winDebug ("winWindowProc - WM_DISPLAYCHANGE - Released "
		  "primary surface\n");
d249 3
d253 46
a298 13
	  /* Create the new primary surface */
	  (*s_pScreenPriv->pwinCreatePrimarySurface) (s_pScreen);

#if CYGDEBUG
	  winDebug ("winWindowProc - WM_DISPLAYCHANGE - Recreated "
		  "primary surface\n");
#endif

#if 0
	  /* Multi-Window mode uses RandR for resizes */
	  if (s_pScreenInfo->fMultiWindow)
	    {
	      RRSetScreenConfig ();
d300 23
a322 8
#endif
	}
      else
	{
#if CYGDEBUG
	  winDebug ("winWindowProc - WM_DISPLAYCHANGE - Dimensions did not "
		  "change\n");
#endif
a324 17
      /* Store the new display dimensions and depth */
      if (s_pScreenInfo->fMultipleMonitors)
	{
	  s_pScreenPriv->dwLastWindowsWidth
	    = GetSystemMetrics (SM_CXVIRTUALSCREEN);
	  s_pScreenPriv->dwLastWindowsHeight
	    = GetSystemMetrics (SM_CYVIRTUALSCREEN);
	}
      else
	{
	  s_pScreenPriv->dwLastWindowsWidth
	    = GetSystemMetrics (SM_CXSCREEN);
	  s_pScreenPriv->dwLastWindowsHeight
	    = GetSystemMetrics (SM_CYSCREEN);
	}
      s_pScreenPriv->dwLastWindowsBitsPixel
	= GetDeviceCaps (s_pScreenPriv->hdcScreen, BITSPIXEL);
d337 2
a338 2
	/* Break if we do not use scrollbars */
	if (!s_pScreenInfo->fScrollbars
d354 11
a381 4
	ErrorF ("winWindowProc - WM_SIZE - window w: %d h: %d, "
		"new client area w: %d h: %d\n",
		iWidth, iHeight, LOWORD (lParam), HIWORD (lParam));

d437 31
d651 1
a651 1
	    || !s_pScreenInfo->fScrollbars
a1003 3
      /* Save handle of our main window that last received focus */
      g_hwndKeyboardFocus = hwnd;

a1014 3

      /* Clear handle of our main window that last received focus */
      g_hwndKeyboardFocus = NULL;
@


1.1
log
@Initial revision
@
text
@d43 1
a43 6

#ifdef XKB
extern BOOL winCheckKeyPressed(WPARAM wParam, LPARAM lParam);
#endif
extern void winFixShiftKeys (int iScanCode);

d720 4
d725 2
a726 2
      if (s_pScreen != miPointerCurrentScreen ())
	miPointerSetNewScreen (s_pScreenInfo->dwScreen,
d765 2
a766 3
      miPointerAbsoluteCursor (GET_X_LPARAM(lParam)-s_pScreenInfo->dwXOffset,
			       GET_Y_LPARAM(lParam)-s_pScreenInfo->dwYOffset,
			       g_c32LastInputEventTime = GetTickCount ());
d929 1
a929 2
	    miPointerAbsoluteCursor (point.x, point.y,
				     g_c32LastInputEventTime = GetTickCount());
a1031 1
#ifdef XKB
a1033 1
       * ago: Only discard them if XKB is not disabled 
d1035 1
a1035 1
      if (!g_winInfo.xkb.disable && (lParam & (1<<30)))
a1050 1
#endif 
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a42 1
#include "inputstr.h"
d726 2
a727 2
      if (s_pScreen != miPointerGetScreen(inputInfo.pointer))
	miPointerSetScreen (inputInfo.pointer, s_pScreenInfo->dwScreen,
@

