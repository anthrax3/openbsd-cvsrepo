head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.14
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.12
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.10
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.8
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.35;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.03.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Dakshinamurthy Karra
 *		Suhaib M Siddiqi
 *		Peter Busch
 *		Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

#include "inputstr.h"
#include "exevents.h"           /* for button/axes labels */
#include "xserver-properties.h"
#include "inpututils.h"

/* Peek the internal button mapping */
static CARD8 const *g_winMouseButtonMap = NULL;

/*
 * Local prototypes
 */

static void
 winMouseCtrl(DeviceIntPtr pDevice, PtrCtrl * pCtrl);

static void
winMouseCtrl(DeviceIntPtr pDevice, PtrCtrl * pCtrl)
{
}

/*
 * See Porting Layer Definition - p. 18
 * This is known as a DeviceProc
 */

int
winMouseProc(DeviceIntPtr pDeviceInt, int iState)
{
    int lngMouseButtons, i;
    int lngWheelEvents = 4;
    CARD8 *map;
    DevicePtr pDevice = (DevicePtr) pDeviceInt;
    Atom btn_labels[9];
    Atom axes_labels[2];

    switch (iState) {
    case DEVICE_INIT:
        /* Get number of mouse buttons */
        lngMouseButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);
        winMsg(X_PROBED, "%d mouse buttons found\n", lngMouseButtons);

        /* Mapping of windows events to X events:
         * LEFT:1 MIDDLE:2 RIGHT:3
         * SCROLL_UP:4 SCROLL_DOWN:5
         * TILT_LEFT:6 TILT_RIGHT:7
         * XBUTTON 1:8 XBUTTON 2:9 (most commonly 'back' and 'forward')
         * ...
         *
         * The current Windows API only defines 2 extra buttons, so we don't
         * expect more than 5 buttons to be reported, but more than that
         * should be handled correctly
         */

        /*
         * To map scroll wheel correctly we need at least the 3 normal buttons
         */
        if (lngMouseButtons < 3)
            lngMouseButtons = 3;

        /* allocate memory:
         * number of buttons + 4 x mouse wheel event + 1 extra (offset for map)
         */
        map = malloc(sizeof(CARD8) * (lngMouseButtons + lngWheelEvents + 1));

        /* initalize button map */
        map[0] = 0;
        for (i = 1; i <= lngMouseButtons + lngWheelEvents; i++)
            map[i] = i;

        btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
        btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
        btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
        btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
        btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
        btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
        btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
        btn_labels[7] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_BACK);
        btn_labels[8] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_FORWARD);

        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);

        InitPointerDeviceStruct(pDevice,
                                map,
                                lngMouseButtons + lngWheelEvents,
                                btn_labels,
                                winMouseCtrl,
                                GetMotionHistorySize(), 2, axes_labels);
        free(map);

        g_winMouseButtonMap = pDeviceInt->button->map;
        break;

    case DEVICE_ON:
        pDevice->on = TRUE;
        break;

    case DEVICE_CLOSE:
        g_winMouseButtonMap = NULL;

    case DEVICE_OFF:
        pDevice->on = FALSE;
        break;
    }
    return Success;
}

/* Handle the mouse wheel */
int
winMouseWheel(int *iTotalDeltaZ, int iDeltaZ, int iButtonUp, int iButtonDown)
{
    int button;

    /* Do we have any previous delta stored? */
    if ((*iTotalDeltaZ > 0 && iDeltaZ > 0)
        || (*iTotalDeltaZ < 0 && iDeltaZ < 0)) {
        /* Previous delta and of same sign as current delta */
        iDeltaZ += *iTotalDeltaZ;
        *iTotalDeltaZ = 0;
    }
    else {
        /*
         * Previous delta of different sign, or zero.
         * We will set it to zero for either case,
         * as blindly setting takes just as much time
         * as checking, then setting if necessary :)
         */
        *iTotalDeltaZ = 0;
    }

    /*
     * Only process this message if the wheel has moved further than
     * WHEEL_DELTA
     */
    if (iDeltaZ >= WHEEL_DELTA || (-1 * iDeltaZ) >= WHEEL_DELTA) {
        *iTotalDeltaZ = 0;

        /* Figure out how many whole deltas of the wheel we have */
        iDeltaZ /= WHEEL_DELTA;
    }
    else {
        /*
         * Wheel has not moved past WHEEL_DELTA threshold;
         * we will store the wheel delta until the threshold
         * has been reached.
         */
        *iTotalDeltaZ = iDeltaZ;
        return 0;
    }

    /* Set the button to indicate up or down wheel delta */
    if (iDeltaZ > 0) {
        button = iButtonUp;
    }
    else {
        button = iButtonDown;
    }

    /*
     * Flip iDeltaZ to positive, if negative,
     * because always need to generate a *positive* number of
     * button clicks for the Z axis.
     */
    if (iDeltaZ < 0) {
        iDeltaZ *= -1;
    }

    /* Generate X input messages for each wheel delta we have seen */
    while (iDeltaZ--) {
        /* Push the wheel button */
        winMouseButtonsSendEvent(ButtonPress, button);

        /* Release the wheel button */
        winMouseButtonsSendEvent(ButtonRelease, button);
    }

    return 0;
}

/*
 * Enqueue a mouse button event
 */

void
winMouseButtonsSendEvent(int iEventType, int iButton)
{
    ValuatorMask mask;

    if (g_winMouseButtonMap)
        iButton = g_winMouseButtonMap[iButton];

    valuator_mask_zero(&mask);
    QueuePointerEvents(g_pwinPointer, iEventType, iButton,
                       POINTER_RELATIVE, &mask);

#if CYGDEBUG
    ErrorF("winMouseButtonsSendEvent: iEventType: %d, iButton: %d\n",
           iEventType, iButton);
#endif
}

/*
 * Decide what to do with a Windows mouse message
 */

int
winMouseButtonsHandle(ScreenPtr pScreen,
                      int iEventType, int iButton, WPARAM wParam)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;

    /* Send button events right away if emulate 3 buttons is off */
    if (pScreenInfo->iE3BTimeout == WIN_E3B_OFF) {
        /* Emulate 3 buttons is off, send the button event */
        winMouseButtonsSendEvent(iEventType, iButton);
        return 0;
    }

    /* Emulate 3 buttons is on, let the fun begin */
    if (iEventType == ButtonPress
        && pScreenPriv->iE3BCachedPress == 0
        && !pScreenPriv->fE3BFakeButton2Sent) {
        /*
         * Button was pressed, no press is cached,
         * and there is no fake button 2 release pending.
         */

        /* Store button press type */
        pScreenPriv->iE3BCachedPress = iButton;

        /*
         * Set a timer to send this button press if the other button
         * is not pressed within the timeout time.
         */
        SetTimer(pScreenPriv->hwndScreen,
                 WIN_E3B_TIMER_ID, pScreenInfo->iE3BTimeout, NULL);
    }
    else if (iEventType == ButtonPress
             && pScreenPriv->iE3BCachedPress != 0
             && pScreenPriv->iE3BCachedPress != iButton
             && !pScreenPriv->fE3BFakeButton2Sent) {
        /*
         * Button press is cached, other button was pressed,
         * and there is no fake button 2 release pending.
         */

        /* Mouse button was cached and other button was pressed */
        KillTimer(pScreenPriv->hwndScreen, WIN_E3B_TIMER_ID);
        pScreenPriv->iE3BCachedPress = 0;

        /* Send fake middle button */
        winMouseButtonsSendEvent(ButtonPress, Button2);

        /* Indicate that a fake middle button event was sent */
        pScreenPriv->fE3BFakeButton2Sent = TRUE;
    }
    else if (iEventType == ButtonRelease
             && pScreenPriv->iE3BCachedPress == iButton) {
        /*
         * Cached button was released before timer ran out,
         * and before the other mouse button was pressed.
         */
        KillTimer(pScreenPriv->hwndScreen, WIN_E3B_TIMER_ID);
        pScreenPriv->iE3BCachedPress = 0;

        /* Send cached press, then send release */
        winMouseButtonsSendEvent(ButtonPress, iButton);
        winMouseButtonsSendEvent(ButtonRelease, iButton);
    }
    else if (iEventType == ButtonRelease
             && pScreenPriv->fE3BFakeButton2Sent && !(wParam & MK_LBUTTON)
             && !(wParam & MK_RBUTTON)) {
        /*
         * Fake button 2 was sent and both mouse buttons have now been released
         */
        pScreenPriv->fE3BFakeButton2Sent = FALSE;

        /* Send middle mouse button release */
        winMouseButtonsSendEvent(ButtonRelease, Button2);
    }
    else if (iEventType == ButtonRelease
             && pScreenPriv->iE3BCachedPress == 0
             && !pScreenPriv->fE3BFakeButton2Sent) {
        /*
         * Button was release, no button is cached,
         * and there is no fake button 2 release is pending.
         */
        winMouseButtonsSendEvent(ButtonRelease, iButton);
    }

    return 0;
}

/**
 * Enqueue a motion event.
 *
 */
void
winEnqueueMotion(int x, int y)
{
    int valuators[2];
    ValuatorMask mask;

    valuators[0] = x;
    valuators[1] = y;

    valuator_mask_set_range(&mask, 0, 2, valuators);
    QueuePointerEvents(g_pwinPointer, MotionNotify, 0,
                       POINTER_ABSOLUTE | POINTER_SCREEN, &mask);

}
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d68 1
a68 1
    int lngWheelEvents = 2;
d71 1
a71 1
    Atom *btn_labels;
d83 3
a85 1
         * XBUTTON 1:6 XBUTTON 2:7 ...
d87 6
d98 2
a99 2
        /* allocate memory: 
         * number of buttons + 2x mouse wheel event + 1 extra (offset for map) 
a107 1
        btn_labels = calloc((lngMouseButtons + lngWheelEvents), sizeof(Atom));
d113 4
a127 1
        free(btn_labels);
d148 1
a148 1
winMouseWheel(ScreenPtr pScreen, int iDeltaZ)
d150 1
a150 5
    winScreenPriv(pScreen);
    int button;                 /* Button4 or Button5 */

    /* Button4 = WheelUp */
    /* Button5 = WheelDown */
d153 2
a154 2
    if ((pScreenPriv->iDeltaZ > 0 && iDeltaZ > 0)
        || (pScreenPriv->iDeltaZ < 0 && iDeltaZ < 0)) {
d156 2
a157 2
        iDeltaZ += pScreenPriv->iDeltaZ;
        pScreenPriv->iDeltaZ = 0;
d166 1
a166 1
        pScreenPriv->iDeltaZ = 0;
d174 1
a174 1
        pScreenPriv->iDeltaZ = 0;
d185 1
a185 1
        pScreenPriv->iDeltaZ = iDeltaZ;
d191 1
a191 1
        button = Button4;
d194 1
a194 1
        button = Button5;
@


1.4
log
@Update to xserver 1.11.2
@
text
@d40 1
a40 1
#include "exevents.h" /* for button/axes labels */
a46 1

d52 1
a52 2
winMouseCtrl (DeviceIntPtr pDevice, PtrCtrl *pCtrl);

d55 1
a55 1
winMouseCtrl (DeviceIntPtr pDevice, PtrCtrl *pCtrl)
a58 1

d65 1
a65 1
winMouseProc (DeviceIntPtr pDeviceInt, int iState)
d67 6
a72 6
  int 			lngMouseButtons, i;
  int			lngWheelEvents = 2;
  CARD8			*map;
  DevicePtr		pDevice = (DevicePtr) pDeviceInt;
  Atom *btn_labels;
  Atom axes_labels[2];
d74 1
a74 2
  switch (iState)
    {
d76 42
a117 2
      /* Get number of mouse buttons */
      lngMouseButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);
d119 2
a120 44
      /* Mapping of windows events to X events:
       * LEFT:1 MIDDLE:2 RIGHT:3
       * SCROLL_UP:4 SCROLL_DOWN:5
       * XBUTTON 1:6 XBUTTON 2:7 ...
       *
       * To map scroll wheel correctly we need at least the 3 normal buttons
       */
      if (lngMouseButtons < 3)
        lngMouseButtons = 3;
      winMsg(X_PROBED, "%d mouse buttons found\n", lngMouseButtons);

      /* allocate memory: 
       * number of buttons + 2x mouse wheel event + 1 extra (offset for map) 
       */
      map = malloc(sizeof(CARD8) * (lngMouseButtons + lngWheelEvents + 1));
    
      /* initalize button map */ 
      map[0] = 0;
      for (i=1; i <= lngMouseButtons + lngWheelEvents; i++)
      	map[i] = i;

      btn_labels = calloc((lngMouseButtons + lngWheelEvents), sizeof(Atom));
      btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
      btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
      btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
      btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
      btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);

      axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
      axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);

      InitPointerDeviceStruct (pDevice,
			       map,
			       lngMouseButtons + lngWheelEvents,
			       btn_labels,
			       winMouseCtrl,
			       GetMotionHistorySize(),
			       2,
			       axes_labels);
      free(map);
      free(btn_labels);

      g_winMouseButtonMap = pDeviceInt->button->map;
      break;
d123 2
a124 2
      pDevice->on = TRUE;
      break;
d127 1
a127 1
      g_winMouseButtonMap = NULL;
d130 2
a131 2
      pDevice->on = FALSE;
      break;
d133 1
a133 1
  return Success;
a135 1

d138 1
a138 1
winMouseWheel (ScreenPtr pScreen, int iDeltaZ)
d140 2
a141 2
  winScreenPriv(pScreen);
  int button; /* Button4 or Button5 */
d143 2
a144 2
  /* Button4 = WheelUp */
  /* Button5 = WheelDown */
d146 58
a203 68
  /* Do we have any previous delta stored? */
  if ((pScreenPriv->iDeltaZ > 0
       && iDeltaZ > 0)
      || (pScreenPriv->iDeltaZ < 0
	  && iDeltaZ < 0))
    {
      /* Previous delta and of same sign as current delta */
      iDeltaZ += pScreenPriv->iDeltaZ;
      pScreenPriv->iDeltaZ = 0;
    }
  else
    {
      /*
       * Previous delta of different sign, or zero.
       * We will set it to zero for either case,
       * as blindly setting takes just as much time
       * as checking, then setting if necessary :)
       */
      pScreenPriv->iDeltaZ = 0;
    }

  /*
   * Only process this message if the wheel has moved further than
   * WHEEL_DELTA
   */
  if (iDeltaZ >= WHEEL_DELTA || (-1 * iDeltaZ) >= WHEEL_DELTA)
    {
      pScreenPriv->iDeltaZ = 0;
	  
      /* Figure out how many whole deltas of the wheel we have */
      iDeltaZ /= WHEEL_DELTA;
    }
  else
    {
      /*
       * Wheel has not moved past WHEEL_DELTA threshold;
       * we will store the wheel delta until the threshold
       * has been reached.
       */
      pScreenPriv->iDeltaZ = iDeltaZ;
      return 0;
    }

  /* Set the button to indicate up or down wheel delta */
  if (iDeltaZ > 0)
    {
      button = Button4;
    }
  else
    {
      button = Button5;
    }

  /*
   * Flip iDeltaZ to positive, if negative,
   * because always need to generate a *positive* number of
   * button clicks for the Z axis.
   */
  if (iDeltaZ < 0)
    {
      iDeltaZ *= -1;
    }

  /* Generate X input messages for each wheel delta we have seen */
  while (iDeltaZ--)
    {
      /* Push the wheel button */
      winMouseButtonsSendEvent (ButtonPress, button);
d205 2
a206 2
      /* Release the wheel button */
      winMouseButtonsSendEvent (ButtonRelease, button);
d209 1
a209 1
  return 0;
a211 1

d217 1
a217 1
winMouseButtonsSendEvent (int iEventType, int iButton)
d219 1
a219 1
  ValuatorMask mask;
d221 2
a222 2
  if (g_winMouseButtonMap)
    iButton = g_winMouseButtonMap[iButton];
d224 3
a226 3
  valuator_mask_zero(&mask);
  QueuePointerEvents(g_pwinPointer, iEventType, iButton,
		     POINTER_RELATIVE, &mask);
d229 2
a230 2
  ErrorF("winMouseButtonsSendEvent: iEventType: %d, iButton: %d\n",
          iEventType, iButton);
a233 1

d239 2
a240 3
winMouseButtonsHandle (ScreenPtr pScreen,
		       int iEventType, int iButton,
		       WPARAM wParam)
d242 2
a243 2
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
d245 77
a321 86
  /* Send button events right away if emulate 3 buttons is off */
  if (pScreenInfo->iE3BTimeout == WIN_E3B_OFF)
    {
      /* Emulate 3 buttons is off, send the button event */
      winMouseButtonsSendEvent (iEventType, iButton);
      return 0;
    }

  /* Emulate 3 buttons is on, let the fun begin */
  if (iEventType == ButtonPress
      && pScreenPriv->iE3BCachedPress == 0
      && !pScreenPriv->fE3BFakeButton2Sent)
    {
      /*
       * Button was pressed, no press is cached,
       * and there is no fake button 2 release pending.
       */

      /* Store button press type */
      pScreenPriv->iE3BCachedPress = iButton;

      /*
       * Set a timer to send this button press if the other button
       * is not pressed within the timeout time.
       */
      SetTimer (pScreenPriv->hwndScreen,
		WIN_E3B_TIMER_ID,
		pScreenInfo->iE3BTimeout,
		NULL);
    }
  else if (iEventType == ButtonPress
	   && pScreenPriv->iE3BCachedPress != 0
	   && pScreenPriv->iE3BCachedPress != iButton
	   && !pScreenPriv->fE3BFakeButton2Sent)
    {
      /*
       * Button press is cached, other button was pressed,
       * and there is no fake button 2 release pending.
       */

      /* Mouse button was cached and other button was pressed */
      KillTimer (pScreenPriv->hwndScreen, WIN_E3B_TIMER_ID);
      pScreenPriv->iE3BCachedPress = 0;

      /* Send fake middle button */
      winMouseButtonsSendEvent (ButtonPress, Button2);

      /* Indicate that a fake middle button event was sent */
      pScreenPriv->fE3BFakeButton2Sent = TRUE;
    }
  else if (iEventType == ButtonRelease
	   && pScreenPriv->iE3BCachedPress == iButton)
    {
      /*
       * Cached button was released before timer ran out,
       * and before the other mouse button was pressed.
       */
      KillTimer (pScreenPriv->hwndScreen, WIN_E3B_TIMER_ID);
      pScreenPriv->iE3BCachedPress = 0;

      /* Send cached press, then send release */
      winMouseButtonsSendEvent (ButtonPress, iButton);
      winMouseButtonsSendEvent (ButtonRelease, iButton);
    }
  else if (iEventType == ButtonRelease
	   && pScreenPriv->fE3BFakeButton2Sent
	   && !(wParam & MK_LBUTTON)
	   && !(wParam & MK_RBUTTON))
    {
      /*
       * Fake button 2 was sent and both mouse buttons have now been released
       */
      pScreenPriv->fE3BFakeButton2Sent = FALSE;
      
      /* Send middle mouse button release */
      winMouseButtonsSendEvent (ButtonRelease, Button2);
    }
  else if (iEventType == ButtonRelease
	   && pScreenPriv->iE3BCachedPress == 0
	   && !pScreenPriv->fE3BFakeButton2Sent)
    {
      /*
       * Button was release, no button is cached,
       * and there is no fake button 2 release is pending.
       */
      winMouseButtonsSendEvent (ButtonRelease, iButton);
d324 1
a324 1
  return 0;
a329 2
 *  XXX: miPointerMove does exactly this, but is static :-( (and uses a static buffer)
 *
d331 2
a332 1
void winEnqueueMotion(int x, int y)
d334 5
a338 2
  int valuators[2];
  ValuatorMask mask;
d340 3
a342 7
  miPointerSetPosition(g_pwinPointer, POINTER_RELATIVE, &x, &y);
  valuators[0] = x;
  valuators[1] = y;

  valuator_mask_set_range(&mask, 0, 2, valuators);
  QueuePointerEvents(g_pwinPointer, MotionNotify, 0,
		     POINTER_ABSOLUTE | POINTER_SCREEN, &mask);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a38 1
#if defined(XFree86Server)
d42 1
a45 1
#endif
a124 1
#if defined(XFree86Server)
a125 1
#endif
a132 1
#if defined(XFree86Server)
d134 1
a134 1
#endif
d237 1
a237 2
  EventListPtr events;
  int i, nevents;
a238 1
#if defined(XFree86Server)
a240 5
#endif

  GetEventList(&events);
  nevents = GetPointerEvents(events, g_pwinPointer, iEventType, iButton,
			     POINTER_RELATIVE, 0, 0, NULL);
d242 3
a244 2
  for (i = 0; i < nevents; i++)
    mieqEnqueue(g_pwinPointer, events[i].event);
d247 2
a248 2
  ErrorF("winMouseButtonsSendEvent: iEventType: %d, iButton: %d, nEvents %d\n",
          iEventType, iButton, nevents);
a363 1
  int i, nevents;
d365 1
a365 1
  EventListPtr events;
d367 1
a367 1
  miPointerSetPosition(g_pwinPointer, &x, &y);
d371 3
a373 3
  GetEventList(&events);
  nevents = GetPointerEvents(events, g_pwinPointer, MotionNotify, 0,
			     POINTER_ABSOLUTE | POINTER_SCREEN, 0, 2, valuators);
a374 2
  for (i = 0; i < nevents; i++)
    mieqEnqueue(g_pwinPointer, events[i].event);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d41 2
d75 2
d104 11
d118 1
a118 1
			       GetMotionHistory,
d121 2
a122 1
			       2);
d124 1
d241 2
a242 1
  xEvent		xCurrentEvent;
a243 2
  /* Load an xEvent and enqueue the event */
  xCurrentEvent.u.u.type = iEventType;
d246 13
a258 2
    xCurrentEvent.u.u.detail = g_winMouseButtonMap[iButton];
  else
a259 4
  xCurrentEvent.u.u.detail = iButton;
  xCurrentEvent.u.keyButtonPointer.time
    = g_c32LastInputEventTime = GetTickCount ();
  mieqEnqueue (&xCurrentEvent);
d364 24
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
#if defined(XFree86Server) && defined(XINPUT)
d103 1
a103 1
			       miPointerGetMotionEvents,
d105 2
a106 1
			       miPointerGetMotionBufferSize ());
d109 1
a109 1
#if defined(XFree86Server) && defined(XINPUT)
d119 1
a119 1
#if defined(XFree86Server) && defined(XINPUT)
d228 1
a228 1
#if defined(XFree86Server) && defined(XINPUT)
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d103 1
a103 1
			       GetMotionHistory,
d105 1
a105 2
			       GetMotionHistorySize(),
			       2);
@

