head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	Te1daavkBLskZ8gc;

1.5
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	cVXoV5PxI8YrEaVA;

1.4
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.28;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Dakshinamurthy Karra
 *		Suhaib M Siddiqi
 *		Peter Busch
 *		Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

/*
 * Local prototypes
 */

static int
 winListInstalledColormaps(ScreenPtr pScreen, Colormap * pmaps);

static void
 winStoreColors(ColormapPtr pmap, int ndef, xColorItem * pdefs);

static void
 winInstallColormap(ColormapPtr pmap);

static void
 winUninstallColormap(ColormapPtr pmap);

static void

winResolveColor(unsigned short *pred,
                unsigned short *pgreen,
                unsigned short *pblue, VisualPtr pVisual);

static Bool
 winCreateColormap(ColormapPtr pmap);

static void
 winDestroyColormap(ColormapPtr pmap);

static Bool
 winGetPaletteDIB(ScreenPtr pScreen, ColormapPtr pcmap);

static Bool
 winGetPaletteDD(ScreenPtr pScreen, ColormapPtr pcmap);

/*
 * Set screen functions for colormaps
 */

void
winSetColormapFunctions(ScreenPtr pScreen)
{
    pScreen->CreateColormap = winCreateColormap;
    pScreen->DestroyColormap = winDestroyColormap;
    pScreen->InstallColormap = winInstallColormap;
    pScreen->UninstallColormap = winUninstallColormap;
    pScreen->ListInstalledColormaps = winListInstalledColormaps;
    pScreen->StoreColors = winStoreColors;
    pScreen->ResolveColor = winResolveColor;
}

/* See Porting Layer Definition - p. 30 */
/*
 * Walk the list of installed colormaps, filling the pmaps list
 * with the resource ids of the installed maps, and return
 * a count of the total number of installed maps.
 */
static int
winListInstalledColormaps(ScreenPtr pScreen, Colormap * pmaps)
{
    winScreenPriv(pScreen);

    /*
     * There will only be one installed colormap, so we only need
     * to return one id, and the count of installed maps will always
     * be one.
     */
    *pmaps = pScreenPriv->pcmapInstalled->mid;
    return 1;
}

/* See Porting Layer Definition - p. 30 */
/* See Programming Windows - p. 663 */
static void
winInstallColormap(ColormapPtr pColormap)
{
    ScreenPtr pScreen = pColormap->pScreen;

    winScreenPriv(pScreen);
    ColormapPtr oldpmap = pScreenPriv->pcmapInstalled;

#if CYGDEBUG
    winDebug("winInstallColormap\n");
#endif

    /* Did the colormap actually change? */
    if (pColormap != oldpmap) {
#if CYGDEBUG
        winDebug("winInstallColormap - Colormap has changed, attempt "
                 "to install.\n");
#endif

        /* Was there a previous colormap? */
        if (oldpmap != (ColormapPtr) None) {
            /* There was a previous colormap; tell clients it is gone */
            WalkTree(pColormap->pScreen, TellLostMap, (char *) &oldpmap->mid);
        }

        /* Install new colormap */
        pScreenPriv->pcmapInstalled = pColormap;
        WalkTree(pColormap->pScreen, TellGainedMap, (char *) &pColormap->mid);

        /* Call the engine specific colormap install procedure */
        if (!((*pScreenPriv->pwinInstallColormap) (pColormap))) {
            winErrorFVerb(2,
                          "winInstallColormap - Screen specific colormap install "
                          "procedure failed.  Continuing, but colors may be "
                          "messed up from now on.\n");
        }
    }

    /* Save a pointer to the newly installed colormap */
    pScreenPriv->pcmapInstalled = pColormap;
}

/* See Porting Layer Definition - p. 30 */
static void
winUninstallColormap(ColormapPtr pmap)
{
    winScreenPriv(pmap->pScreen);
    ColormapPtr curpmap = pScreenPriv->pcmapInstalled;

#if CYGDEBUG
    winDebug("winUninstallColormap\n");
#endif

    /* Is the colormap currently installed? */
    if (pmap != curpmap) {
        /* Colormap not installed, nothing to do */
        return;
    }

    /* Clear the installed colormap flag */
    pScreenPriv->pcmapInstalled = NULL;

    /*
     * NOTE: The default colormap does not get "uninstalled" before
     * it is destroyed.
     */

    /* Install the default cmap in place of the cmap to be uninstalled */
    if (pmap->mid != pmap->pScreen->defColormap) {
        dixLookupResourceByType((void *) &curpmap, pmap->pScreen->defColormap,
                                RT_COLORMAP, NullClient, DixUnknownAccess);
        (*pmap->pScreen->InstallColormap) (curpmap);
    }
}

/* See Porting Layer Definition - p. 30 */
static void
winStoreColors(ColormapPtr pmap, int ndef, xColorItem * pdefs)
{
    ScreenPtr pScreen = pmap->pScreen;

    winScreenPriv(pScreen);
    winCmapPriv(pmap);
    int i;
    unsigned short nRed, nGreen, nBlue;

#if CYGDEBUG
    if (ndef != 1)
        winDebug("winStoreColors - ndef: %d\n", ndef);
#endif

    /* Save the new colors in the colormap privates */
    for (i = 0; i < ndef; ++i) {
        /* Adjust the colors from the X color spec to the Windows color spec */
        nRed = pdefs[i].red >> 8;
        nGreen = pdefs[i].green >> 8;
        nBlue = pdefs[i].blue >> 8;

        /* Copy the colors to a palette entry table */
        pCmapPriv->peColors[pdefs[0].pixel + i].peRed = nRed;
        pCmapPriv->peColors[pdefs[0].pixel + i].peGreen = nGreen;
        pCmapPriv->peColors[pdefs[0].pixel + i].peBlue = nBlue;

        /* Copy the colors to a RGBQUAD table */
        pCmapPriv->rgbColors[pdefs[0].pixel + i].rgbRed = nRed;
        pCmapPriv->rgbColors[pdefs[0].pixel + i].rgbGreen = nGreen;
        pCmapPriv->rgbColors[pdefs[0].pixel + i].rgbBlue = nBlue;

#if CYGDEBUG
        winDebug("winStoreColors - nRed %d nGreen %d nBlue %d\n",
                 nRed, nGreen, nBlue);
#endif
    }

    /* Call the engine specific store colors procedure */
    if (!((pScreenPriv->pwinStoreColors) (pmap, ndef, pdefs))) {
        winErrorFVerb(2,
                      "winStoreColors - Engine cpecific color storage procedure "
                      "failed.  Continuing, but colors may be messed up from now "
                      "on.\n");
    }
}

/* See Porting Layer Definition - p. 30 */
static void
winResolveColor(unsigned short *pred,
                unsigned short *pgreen,
                unsigned short *pblue, VisualPtr pVisual)
{
#if CYGDEBUG
    winDebug("winResolveColor ()\n");
#endif

    miResolveColor(pred, pgreen, pblue, pVisual);
}

/* See Porting Layer Definition - p. 29 */
static Bool
winCreateColormap(ColormapPtr pmap)
{
    winPrivCmapPtr pCmapPriv = NULL;
    ScreenPtr pScreen = pmap->pScreen;

    winScreenPriv(pScreen);

#if CYGDEBUG
    winDebug("winCreateColormap\n");
#endif

    /* Allocate colormap privates */
    if (!winAllocateCmapPrivates(pmap)) {
        ErrorF("winCreateColorma - Couldn't allocate cmap privates\n");
        return FALSE;
    }

    /* Get a pointer to the newly allocated privates */
    pCmapPriv = winGetCmapPriv(pmap);

    /*
     * FIXME: This is some evil hackery to help in handling some X clients
     * that expect the top pixel to be white.  This "help" only lasts until
     * some client overwrites the top colormap entry.
     *
     * We don't want to actually allocate the top entry, as that causes
     * problems with X clients that need 7 planes (128 colors) in the default
     * colormap, such as Magic 7.1.
     */
    pCmapPriv->rgbColors[WIN_NUM_PALETTE_ENTRIES - 1].rgbRed = 255;
    pCmapPriv->rgbColors[WIN_NUM_PALETTE_ENTRIES - 1].rgbGreen = 255;
    pCmapPriv->rgbColors[WIN_NUM_PALETTE_ENTRIES - 1].rgbBlue = 255;
    pCmapPriv->peColors[WIN_NUM_PALETTE_ENTRIES - 1].peRed = 255;
    pCmapPriv->peColors[WIN_NUM_PALETTE_ENTRIES - 1].peGreen = 255;
    pCmapPriv->peColors[WIN_NUM_PALETTE_ENTRIES - 1].peBlue = 255;

    /* Call the engine specific colormap initialization procedure */
    if (!((*pScreenPriv->pwinCreateColormap) (pmap))) {
        ErrorF("winCreateColormap - Engine specific colormap creation "
               "procedure failed.  Aborting.\n");
        return FALSE;
    }

    return TRUE;
}

/* See Porting Layer Definition - p. 29, 30 */
static void
winDestroyColormap(ColormapPtr pColormap)
{
    winScreenPriv(pColormap->pScreen);
    winCmapPriv(pColormap);

    /* Call the engine specific colormap destruction procedure */
    if (!((*pScreenPriv->pwinDestroyColormap) (pColormap))) {
        winErrorFVerb(2,
                      "winDestroyColormap - Engine specific colormap destruction "
                      "procedure failed.  Continuing, but it is possible that memory "
                      "was leaked, or that colors will be messed up from now on.\n");
    }

    /* Free the colormap privates */
    free(pCmapPriv);
    winSetCmapPriv(pColormap, NULL);

#if CYGDEBUG
    winDebug("winDestroyColormap - Returning\n");
#endif
}

/*
 * Internal function to load the palette used by the Shadow DIB
 */

static Bool
winGetPaletteDIB(ScreenPtr pScreen, ColormapPtr pcmap)
{
    winScreenPriv(pScreen);
    int i;
    Pixel pixel;                /* Pixel == CARD32 */
    CARD16 nRed, nGreen, nBlue; /* CARD16 == unsigned short */
    UINT uiColorsRetrieved = 0;
    RGBQUAD rgbColors[WIN_NUM_PALETTE_ENTRIES];

    /* Get the color table for the screen */
    uiColorsRetrieved = GetDIBColorTable(pScreenPriv->hdcScreen,
                                         0, WIN_NUM_PALETTE_ENTRIES, rgbColors);
    if (uiColorsRetrieved == 0) {
        ErrorF("winGetPaletteDIB - Could not retrieve screen color table\n");
        return FALSE;
    }

#if CYGDEBUG
    winDebug("winGetPaletteDIB - Retrieved %d colors from DIB\n",
             uiColorsRetrieved);
#endif

    /* Set the DIB color table to the default screen palette */
    if (SetDIBColorTable(pScreenPriv->hdcShadow,
                         0, uiColorsRetrieved, rgbColors) == 0) {
        ErrorF("winGetPaletteDIB - SetDIBColorTable () failed\n");
        return FALSE;
    }

    /* Alloc each color in the DIB color table */
    for (i = 0; i < uiColorsRetrieved; ++i) {
        pixel = i;

        /* Extract the color values for current palette entry */
        nRed = rgbColors[i].rgbRed << 8;
        nGreen = rgbColors[i].rgbGreen << 8;
        nBlue = rgbColors[i].rgbBlue << 8;

#if CYGDEBUG
        winDebug("winGetPaletteDIB - Allocating a color: %u; "
                 "%d %d %d\n", (unsigned int)pixel, nRed, nGreen, nBlue);
#endif

        /* Allocate a entry in the X colormap */
        if (AllocColor(pcmap, &nRed, &nGreen, &nBlue, &pixel, 0) != Success) {
            ErrorF("winGetPaletteDIB - AllocColor () failed, pixel %d\n", i);
            return FALSE;
        }

        if (i != pixel
            || nRed != rgbColors[i].rgbRed
            || nGreen != rgbColors[i].rgbGreen
            || nBlue != rgbColors[i].rgbBlue) {
            winDebug("winGetPaletteDIB - Got: %d; "
                     "%d %d %d\n", (int) pixel, nRed, nGreen, nBlue);
        }

        /* FIXME: Not sure that this bit is needed at all */
        pcmap->red[i].co.local.red = nRed;
        pcmap->red[i].co.local.green = nGreen;
        pcmap->red[i].co.local.blue = nBlue;
    }

    /* System is using a colormap */
    /* Set the black and white pixel indices */
    pScreen->whitePixel = uiColorsRetrieved - 1;
    pScreen->blackPixel = 0;

    return TRUE;
}

/*
 * Internal function to load the standard system palette being used by DD
 */

static Bool
winGetPaletteDD(ScreenPtr pScreen, ColormapPtr pcmap)
{
    int i;
    Pixel pixel;                /* Pixel == CARD32 */
    CARD16 nRed, nGreen, nBlue; /* CARD16 == unsigned short */
    UINT uiSystemPaletteEntries;
    LPPALETTEENTRY ppeColors = NULL;
    HDC hdc = NULL;

    /* Get a DC to obtain the default palette */
    hdc = GetDC(NULL);
    if (hdc == NULL) {
        ErrorF("winGetPaletteDD - Couldn't get a DC\n");
        return FALSE;
    }

    /* Get the number of entries in the system palette */
    uiSystemPaletteEntries = GetSystemPaletteEntries(hdc, 0, 0, NULL);
    if (uiSystemPaletteEntries == 0) {
        ErrorF("winGetPaletteDD - Unable to determine number of "
               "system palette entries\n");
        return FALSE;
    }

#if CYGDEBUG
    winDebug("winGetPaletteDD - uiSystemPaletteEntries %d\n",
             uiSystemPaletteEntries);
#endif

    /* Allocate palette entries structure */
    ppeColors = malloc(uiSystemPaletteEntries * sizeof(PALETTEENTRY));
    if (ppeColors == NULL) {
        ErrorF("winGetPaletteDD - malloc () for colormap failed\n");
        return FALSE;
    }

    /* Get system palette entries */
    GetSystemPaletteEntries(hdc, 0, uiSystemPaletteEntries, ppeColors);

    /* Allocate an X colormap entry for every system palette entry */
    for (i = 0; i < uiSystemPaletteEntries; ++i) {
        pixel = i;

        /* Extract the color values for current palette entry */
        nRed = ppeColors[i].peRed << 8;
        nGreen = ppeColors[i].peGreen << 8;
        nBlue = ppeColors[i].peBlue << 8;
#if CYGDEBUG
        winDebug("winGetPaletteDD - Allocating a color: %u; "
                 "%d %d %d\n", (unsigned int)pixel, nRed, nGreen, nBlue);
#endif
        if (AllocColor(pcmap, &nRed, &nGreen, &nBlue, &pixel, 0) != Success) {
            ErrorF("winGetPaletteDD - AllocColor () failed, pixel %d\n", i);
            free(ppeColors);
            ppeColors = NULL;
            return FALSE;
        }

        pcmap->red[i].co.local.red = nRed;
        pcmap->red[i].co.local.green = nGreen;
        pcmap->red[i].co.local.blue = nBlue;
    }

    /* System is using a colormap */
    /* Set the black and white pixel indices */
    pScreen->whitePixel = uiSystemPaletteEntries - 1;
    pScreen->blackPixel = 0;

    /* Free colormap */
    free(ppeColors);
    ppeColors = NULL;

    /* Free the DC */
    if (hdc != NULL) {
        ReleaseDC(NULL, hdc);
        hdc = NULL;
    }

    return TRUE;
}

/*
 * Install the standard fb colormap, or the GDI colormap,
 * depending on the current screen depth.
 */

Bool
winCreateDefColormap(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    unsigned short zero = 0, ones = 0xFFFF;
    VisualPtr pVisual = pScreenPriv->pRootVisual;
    ColormapPtr pcmap = NULL;
    Pixel wp, bp;

#if CYGDEBUG
    winDebug("winCreateDefColormap\n");
#endif

    /* Use standard fb colormaps for non palettized color modes */
    if (pScreenInfo->dwBPP > 8) {
        winDebug("winCreateDefColormap - Deferring to "
                 "fbCreateDefColormap ()\n");
        return fbCreateDefColormap(pScreen);
    }

    /*
     *  AllocAll for non-Dynamic visual classes,
     *  AllocNone for Dynamic visual classes.
     */

    /*
     * Dynamic visual classes allow the colors of the color map
     * to be changed by clients.
     */

#if CYGDEBUG
    winDebug("winCreateDefColormap - defColormap: %lu\n", pScreen->defColormap);
#endif

    /* Allocate an X colormap, owned by client 0 */
    if (CreateColormap(pScreen->defColormap,
                       pScreen,
                       pVisual,
                       &pcmap,
                       (pVisual->class & DynamicClass) ? AllocNone : AllocAll,
                       0) != Success) {
        ErrorF("winCreateDefColormap - CreateColormap failed\n");
        return FALSE;
    }
    if (pcmap == NULL) {
        ErrorF("winCreateDefColormap - Colormap could not be created\n");
        return FALSE;
    }

#if CYGDEBUG
    winDebug("winCreateDefColormap - Created a colormap\n");
#endif

    /* Branch on the visual class */
    if (!(pVisual->class & DynamicClass)) {
        /* Branch on engine type */
        if (pScreenInfo->dwEngine == WIN_SERVER_SHADOW_GDI) {
            /* Load the colors being used by the Shadow DIB */
            if (!winGetPaletteDIB(pScreen, pcmap)) {
                ErrorF("winCreateDefColormap - Couldn't get DIB colors\n");
                return FALSE;
            }
        }
        else {
            /* Load the colors from the default system palette */
            if (!winGetPaletteDD(pScreen, pcmap)) {
                ErrorF("winCreateDefColormap - Couldn't get colors "
                       "for DD\n");
                return FALSE;
            }
        }
    }
    else {
        wp = pScreen->whitePixel;
        bp = pScreen->blackPixel;

        /* Allocate a black and white pixel */
        if ((AllocColor(pcmap, &ones, &ones, &ones, &wp, 0) != Success)
            || (AllocColor(pcmap, &zero, &zero, &zero, &bp, 0) != Success)) {
            ErrorF("winCreateDefColormap - Couldn't allocate bp or wp\n");
            return FALSE;
        }

        pScreen->whitePixel = wp;
        pScreen->blackPixel = bp;

#if 0
        /* Have to reserve first 10 and last ten pixels in DirectDraw windowed */
        if (pScreenInfo->dwEngine != WIN_SERVER_SHADOW_GDI) {
            int k;
            Pixel p;

            for (k = 1; k < 10; ++k) {
                p = k;
                if (AllocColor(pcmap, &ones, &ones, &ones, &p, 0) != Success)
                    FatalError("Foo!\n");
            }

            for (k = 245; k < 255; ++k) {
                p = k;
                if (AllocColor(pcmap, &zero, &zero, &zero, &p, 0) != Success)
                    FatalError("Baz!\n");
            }
        }
#endif
    }

    /* Install the created colormap */
    (*pScreen->InstallColormap) (pcmap);

#if CYGDEBUG
    winDebug("winCreateDefColormap - Returning\n");
#endif

    return TRUE;
}
@


1.6
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d363 2
a364 2
        winDebug("winGetPaletteDIB - Allocating a color: %d; "
                 "%d %d %d\n", pixel, nRed, nGreen, nBlue);
d448 2
a449 2
        winDebug("winGetPaletteDD - Allocating a color: %d; "
                 "%d %d %d\n", pixel, nRed, nGreen, nBlue);
d518 1
a518 1
    winDebug("winCreateDefColormap - defColormap: %d\n", pScreen->defColormap);
@


1.5
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d273 1
a273 1
     * 
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d180 1
a180 1
        dixLookupResourceByType((pointer) &curpmap, pmap->pScreen->defColormap,
@


1.3
log
@Update to xserver 1.11.2
@
text
@a38 1

d44 1
a44 1
winListInstalledColormaps (ScreenPtr pScreen, Colormap *pmaps);
d47 1
a47 1
winStoreColors (ColormapPtr pmap, int ndef, xColorItem *pdefs);
d50 1
a50 1
winInstallColormap (ColormapPtr pmap);
d53 1
a53 1
winUninstallColormap (ColormapPtr pmap);
d56 4
a59 4
winResolveColor (unsigned short *pred,
		 unsigned short *pgreen,
		 unsigned short *pblue,
		 VisualPtr	pVisual);
d62 1
a62 1
winCreateColormap (ColormapPtr pmap);
d65 1
a65 1
winDestroyColormap (ColormapPtr pmap);
d68 1
a68 1
winGetPaletteDIB (ScreenPtr pScreen, ColormapPtr pcmap);
d71 1
a71 2
winGetPaletteDD (ScreenPtr pScreen, ColormapPtr pcmap);

d78 1
a78 1
winSetColormapFunctions (ScreenPtr pScreen)
d80 7
a86 7
  pScreen->CreateColormap = winCreateColormap;
  pScreen->DestroyColormap = winDestroyColormap;
  pScreen->InstallColormap = winInstallColormap;
  pScreen->UninstallColormap = winUninstallColormap;
  pScreen->ListInstalledColormaps = winListInstalledColormaps;
  pScreen->StoreColors = winStoreColors;
  pScreen->ResolveColor = winResolveColor;
a88 1

d96 1
a96 1
winListInstalledColormaps (ScreenPtr pScreen, Colormap *pmaps)
d98 1
a98 1
  winScreenPriv(pScreen);
d100 7
a106 7
  /*
   * There will only be one installed colormap, so we only need
   * to return one id, and the count of installed maps will always
   * be one.
   */
  *pmaps = pScreenPriv->pcmapInstalled->mid;
  return 1;
a108 1

d112 1
a112 1
winInstallColormap (ColormapPtr pColormap)
d114 33
a146 34
  ScreenPtr		pScreen = pColormap->pScreen;
  winScreenPriv(pScreen);
  ColormapPtr		oldpmap = pScreenPriv->pcmapInstalled;

#if CYGDEBUG
  winDebug ("winInstallColormap\n");
#endif
 
  /* Did the colormap actually change? */
  if (pColormap != oldpmap)
    {
#if CYGDEBUG
      winDebug ("winInstallColormap - Colormap has changed, attempt "
	      "to install.\n");
#endif
      
      /* Was there a previous colormap? */
      if (oldpmap != (ColormapPtr) None)
	{
	  /* There was a previous colormap; tell clients it is gone */
	  WalkTree (pColormap->pScreen, TellLostMap, (char *)&oldpmap->mid);
	}
      
      /* Install new colormap */
      pScreenPriv->pcmapInstalled = pColormap;
      WalkTree (pColormap->pScreen, TellGainedMap, (char *)&pColormap->mid);
      
      /* Call the engine specific colormap install procedure */
      if (!((*pScreenPriv->pwinInstallColormap) (pColormap)))
	{
	  winErrorFVerb (2, "winInstallColormap - Screen specific colormap install "
		  "procedure failed.  Continuing, but colors may be "
		  "messed up from now on.\n");
	}
d149 2
a150 2
  /* Save a pointer to the newly installed colormap */
  pScreenPriv->pcmapInstalled = pColormap;
a152 1

d155 1
a155 1
winUninstallColormap (ColormapPtr pmap)
d157 2
a158 2
  winScreenPriv(pmap->pScreen);
  ColormapPtr curpmap = pScreenPriv->pcmapInstalled;
d161 1
a161 1
  winDebug ("winUninstallColormap\n");
d164 19
a182 21
  /* Is the colormap currently installed? */
  if (pmap != curpmap)
    {
      /* Colormap not installed, nothing to do */
      return;
    }
  
  /* Clear the installed colormap flag */
  pScreenPriv->pcmapInstalled = NULL;
  
  /*
   * NOTE: The default colormap does not get "uninstalled" before
   * it is destroyed.
   */

  /* Install the default cmap in place of the cmap to be uninstalled */
  if (pmap->mid != pmap->pScreen->defColormap)
    {
      dixLookupResourceByType((pointer) &curpmap, pmap->pScreen->defColormap,
				RT_COLORMAP, NullClient, DixUnknownAccess);
      (*pmap->pScreen->InstallColormap) (curpmap);
a185 1

d188 34
a221 37
winStoreColors (ColormapPtr pmap,
		int ndef,
		xColorItem *pdefs)
{
  ScreenPtr		pScreen = pmap->pScreen;
  winScreenPriv(pScreen);
  winCmapPriv(pmap);
  int			i;
  unsigned short	nRed, nGreen, nBlue;

#if CYGDEBUG
  if (ndef != 1)
    winDebug ("winStoreColors - ndef: %d\n",
	    ndef);
#endif

  /* Save the new colors in the colormap privates */
  for (i = 0; i < ndef; ++i)
    {
      /* Adjust the colors from the X color spec to the Windows color spec */
      nRed = pdefs[i].red >> 8;
      nGreen = pdefs[i].green >> 8;
      nBlue = pdefs[i].blue >> 8;

      /* Copy the colors to a palette entry table */
      pCmapPriv->peColors[pdefs[0].pixel + i].peRed = nRed;
      pCmapPriv->peColors[pdefs[0].pixel + i].peGreen = nGreen;
      pCmapPriv->peColors[pdefs[0].pixel + i].peBlue = nBlue;
      
      /* Copy the colors to a RGBQUAD table */
      pCmapPriv->rgbColors[pdefs[0].pixel + i].rgbRed = nRed;
      pCmapPriv->rgbColors[pdefs[0].pixel + i].rgbGreen = nGreen;
      pCmapPriv->rgbColors[pdefs[0].pixel + i].rgbBlue = nBlue;

#if CYGDEBUG
      winDebug ("winStoreColors - nRed %d nGreen %d nBlue %d\n",
	      nRed, nGreen, nBlue);
d225 6
a230 6
  /* Call the engine specific store colors procedure */
  if (!((pScreenPriv->pwinStoreColors) (pmap, ndef, pdefs)))
    {
      winErrorFVerb (2, "winStoreColors - Engine cpecific color storage procedure "
	      "failed.  Continuing, but colors may be messed up from now "
	      "on.\n");
a233 1

d236 3
a238 4
winResolveColor (unsigned short *pred,
		 unsigned short *pgreen,
		 unsigned short *pblue,
		 VisualPtr	pVisual)
d241 1
a241 1
  winDebug ("winResolveColor ()\n");
d244 1
a244 1
  miResolveColor (pred, pgreen, pblue, pVisual);
a246 1

d249 1
a249 1
winCreateColormap (ColormapPtr pmap)
d251 39
a289 40
  winPrivCmapPtr	pCmapPriv = NULL;
  ScreenPtr		pScreen = pmap->pScreen;
  winScreenPriv(pScreen);

#if CYGDEBUG
  winDebug ("winCreateColormap\n");
#endif

  /* Allocate colormap privates */
  if (!winAllocateCmapPrivates (pmap))
    {
      ErrorF ("winCreateColorma - Couldn't allocate cmap privates\n");
      return FALSE;
    }

  /* Get a pointer to the newly allocated privates */
  pCmapPriv = winGetCmapPriv (pmap);

  /*
   * FIXME: This is some evil hackery to help in handling some X clients
   * that expect the top pixel to be white.  This "help" only lasts until
   * some client overwrites the top colormap entry.
   * 
   * We don't want to actually allocate the top entry, as that causes
   * problems with X clients that need 7 planes (128 colors) in the default
   * colormap, such as Magic 7.1.
   */
  pCmapPriv->rgbColors[WIN_NUM_PALETTE_ENTRIES - 1].rgbRed = 255;
  pCmapPriv->rgbColors[WIN_NUM_PALETTE_ENTRIES - 1].rgbGreen = 255;
  pCmapPriv->rgbColors[WIN_NUM_PALETTE_ENTRIES - 1].rgbBlue = 255;
  pCmapPriv->peColors[WIN_NUM_PALETTE_ENTRIES - 1].peRed = 255;
  pCmapPriv->peColors[WIN_NUM_PALETTE_ENTRIES - 1].peGreen = 255;
  pCmapPriv->peColors[WIN_NUM_PALETTE_ENTRIES - 1].peBlue = 255;

  /* Call the engine specific colormap initialization procedure */
  if (!((*pScreenPriv->pwinCreateColormap) (pmap)))
    {
      ErrorF ("winCreateColormap - Engine specific colormap creation "
	      "procedure failed.  Aborting.\n");
      return FALSE;
d292 1
a292 1
  return TRUE;
a294 1

d297 1
a297 1
winDestroyColormap (ColormapPtr pColormap)
d299 2
a300 2
  winScreenPriv(pColormap->pScreen);
  winCmapPriv(pColormap);
d302 6
a307 6
  /* Call the engine specific colormap destruction procedure */
  if (!((*pScreenPriv->pwinDestroyColormap) (pColormap)))
    {
      winErrorFVerb (2, "winDestroyColormap - Engine specific colormap destruction "
	      "procedure failed.  Continuing, but it is possible that memory "
	      "was leaked, or that colors will be messed up from now on.\n");
d310 3
a312 3
  /* Free the colormap privates */
  free (pCmapPriv);
  winSetCmapPriv (pColormap, NULL);
d315 1
a315 1
  winDebug ("winDestroyColormap - Returning\n");
a318 1

d324 1
a324 1
winGetPaletteDIB (ScreenPtr pScreen, ColormapPtr pcmap)
d326 35
a360 82
  winScreenPriv(pScreen);
  int			i;
  Pixel			pixel; /* Pixel == CARD32 */
  CARD16		nRed, nGreen, nBlue; /* CARD16 == unsigned short */
  UINT			uiColorsRetrieved = 0;
  RGBQUAD		rgbColors[WIN_NUM_PALETTE_ENTRIES];
      
  /* Get the color table for the screen */
  uiColorsRetrieved = GetDIBColorTable (pScreenPriv->hdcScreen,
					0,
					WIN_NUM_PALETTE_ENTRIES,
					rgbColors);
  if (uiColorsRetrieved == 0)
    {
      ErrorF ("winGetPaletteDIB - Could not retrieve screen color table\n");
      return FALSE;
    }

#if CYGDEBUG
  winDebug ("winGetPaletteDIB - Retrieved %d colors from DIB\n",
	  uiColorsRetrieved);
#endif

  /* Set the DIB color table to the default screen palette */
  if (SetDIBColorTable (pScreenPriv->hdcShadow,
			0,
			uiColorsRetrieved,
			rgbColors) == 0)
    {
      ErrorF ("winGetPaletteDIB - SetDIBColorTable () failed\n");
      return FALSE;
    }

  /* Alloc each color in the DIB color table */
  for (i = 0; i < uiColorsRetrieved; ++i)
    {
      pixel = i;

      /* Extract the color values for current palette entry */
      nRed = rgbColors[i].rgbRed << 8;
      nGreen = rgbColors[i].rgbGreen << 8;
      nBlue = rgbColors[i].rgbBlue << 8;

#if CYGDEBUG
      winDebug ("winGetPaletteDIB - Allocating a color: %d; "
	      "%d %d %d\n",
	      pixel, nRed, nGreen, nBlue);
#endif

      /* Allocate a entry in the X colormap */
      if (AllocColor (pcmap,
		      &nRed,
		      &nGreen,
		      &nBlue,
		      &pixel,
		      0) != Success)
	{
	  ErrorF ("winGetPaletteDIB - AllocColor () failed, pixel %d\n",
		  i);
	  return FALSE;
	}

      if (i != pixel
	  || nRed != rgbColors[i].rgbRed 
	  || nGreen != rgbColors[i].rgbGreen
	  || nBlue != rgbColors[i].rgbBlue)
	{
	  winDebug ("winGetPaletteDIB - Got: %d; "
		  "%d %d %d\n",
		  (int) pixel, nRed, nGreen, nBlue);
	}
	  
      /* FIXME: Not sure that this bit is needed at all */
      pcmap->red[i].co.local.red = nRed;
      pcmap->red[i].co.local.green = nGreen;
      pcmap->red[i].co.local.blue = nBlue;
    }

  /* System is using a colormap */
  /* Set the black and white pixel indices */
  pScreen->whitePixel = uiColorsRetrieved - 1;
  pScreen->blackPixel = 0;
d362 31
a392 1
  return TRUE;
a394 1

d400 1
a400 1
winGetPaletteDD (ScreenPtr pScreen, ColormapPtr pcmap)
d402 12
a413 89
  int			i;
  Pixel			pixel; /* Pixel == CARD32 */
  CARD16		nRed, nGreen, nBlue; /* CARD16 == unsigned short */
  UINT			uiSystemPaletteEntries;
  LPPALETTEENTRY	ppeColors = NULL;
  HDC			hdc = NULL;

  /* Get a DC to obtain the default palette */
  hdc = GetDC (NULL);
  if (hdc == NULL)
    {
      ErrorF ("winGetPaletteDD - Couldn't get a DC\n");
      return FALSE;
    }

  /* Get the number of entries in the system palette */
  uiSystemPaletteEntries = GetSystemPaletteEntries (hdc,
						    0, 0, NULL);
  if (uiSystemPaletteEntries == 0)
    {
      ErrorF ("winGetPaletteDD - Unable to determine number of "
	      "system palette entries\n");
      return FALSE;
    }

#if CYGDEBUG
  winDebug ("winGetPaletteDD - uiSystemPaletteEntries %d\n",
	  uiSystemPaletteEntries);
#endif
  
  /* Allocate palette entries structure */
  ppeColors = malloc (uiSystemPaletteEntries * sizeof (PALETTEENTRY));
  if (ppeColors == NULL)
    {
      ErrorF ("winGetPaletteDD - malloc () for colormap failed\n");
      return FALSE;
    }

  /* Get system palette entries */
  GetSystemPaletteEntries (hdc,
			   0, uiSystemPaletteEntries, ppeColors);

  /* Allocate an X colormap entry for every system palette entry */
  for (i = 0; i < uiSystemPaletteEntries; ++i)
    {
      pixel = i;

      /* Extract the color values for current palette entry */
      nRed = ppeColors[i].peRed << 8;
      nGreen = ppeColors[i].peGreen << 8;
      nBlue = ppeColors[i].peBlue << 8;
#if CYGDEBUG
      winDebug ("winGetPaletteDD - Allocating a color: %d; "
	      "%d %d %d\n",
	      pixel, nRed, nGreen, nBlue);
#endif
      if (AllocColor (pcmap,
		      &nRed,
		      &nGreen,
		      &nBlue,
		      &pixel,
		      0) != Success)
	{
	  ErrorF ("winGetPaletteDD - AllocColor () failed, pixel %d\n",
		  i);
	  free (ppeColors);
	  ppeColors = NULL;
	  return FALSE;
	}

      pcmap->red[i].co.local.red = nRed;
      pcmap->red[i].co.local.green = nGreen;
      pcmap->red[i].co.local.blue = nBlue;
    }

  /* System is using a colormap */
  /* Set the black and white pixel indices */
  pScreen->whitePixel = uiSystemPaletteEntries - 1;
  pScreen->blackPixel = 0;

  /* Free colormap */
  free(ppeColors);
  ppeColors = NULL;

  /* Free the DC */
  if (hdc != NULL)
    {
      ReleaseDC (NULL, hdc);
      hdc = NULL;
d416 63
a478 1
  return TRUE;
a480 1

d487 1
a487 1
winCreateDefColormap (ScreenPtr pScreen)
d489 83
a571 97
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  unsigned short	zero = 0, ones = 0xFFFF;
  VisualPtr		pVisual = pScreenPriv->pRootVisual;
  ColormapPtr		pcmap = NULL;
  Pixel			wp, bp;

#if CYGDEBUG
  winDebug ("winCreateDefColormap\n");
#endif

  /* Use standard fb colormaps for non palettized color modes */
  if (pScreenInfo->dwBPP > 8)
    {
      winDebug ("winCreateDefColormap - Deferring to " \
	      "fbCreateDefColormap ()\n");
      return fbCreateDefColormap (pScreen);
    }

  /*
   *  AllocAll for non-Dynamic visual classes,
   *  AllocNone for Dynamic visual classes.
   */

  /*
   * Dynamic visual classes allow the colors of the color map
   * to be changed by clients.
   */

#if CYGDEBUG
  winDebug ("winCreateDefColormap - defColormap: %d\n",
	  pScreen->defColormap);
#endif

  /* Allocate an X colormap, owned by client 0 */
  if (CreateColormap (pScreen->defColormap, 
		      pScreen,
		      pVisual,
		      &pcmap,
		      (pVisual->class & DynamicClass) ? AllocNone : AllocAll,
		      0) != Success)
    {
      ErrorF ("winCreateDefColormap - CreateColormap failed\n");
      return FALSE;
    }
  if (pcmap == NULL)
    {
      ErrorF ("winCreateDefColormap - Colormap could not be created\n");
      return FALSE;
    }

#if CYGDEBUG
  winDebug ("winCreateDefColormap - Created a colormap\n");
#endif

  /* Branch on the visual class */
  if (!(pVisual->class & DynamicClass))
    {
      /* Branch on engine type */
      if (pScreenInfo->dwEngine == WIN_SERVER_SHADOW_GDI)
	{
	  /* Load the colors being used by the Shadow DIB */
	  if (!winGetPaletteDIB (pScreen, pcmap))
	    {
	      ErrorF ("winCreateDefColormap - Couldn't get DIB colors\n");
	      return FALSE;
	    }
	}
      else
	{
	  /* Load the colors from the default system palette */
	  if (!winGetPaletteDD (pScreen, pcmap))
	    {
	      ErrorF ("winCreateDefColormap - Couldn't get colors "
		      "for DD\n");
	      return FALSE;
	    }
	}
    }
  else
    {
      wp = pScreen->whitePixel;
      bp = pScreen->blackPixel;
      
      /* Allocate a black and white pixel */
      if ((AllocColor (pcmap, &ones, &ones, &ones, &wp, 0) !=
	   Success)
	  ||
	  (AllocColor (pcmap, &zero, &zero, &zero, &bp, 0) !=
	   Success))
	{
	  ErrorF ("winCreateDefColormap - Couldn't allocate bp or wp\n");
	  return FALSE;
	}
      
      pScreen->whitePixel = wp;
      pScreen->blackPixel = bp;
d574 10
a583 5
      /* Have to reserve first 10 and last ten pixels in DirectDraw windowed */
      if (pScreenInfo->dwEngine != WIN_SERVER_SHADOW_GDI)
	{
	  int		k;
	  Pixel		p;
d585 6
a590 14
	  for (k = 1; k < 10; ++k)
	    {
	      p = k;
	      if (AllocColor (pcmap, &ones, &ones, &ones, &p, 0) != Success)
		FatalError ("Foo!\n");
	    }
	  
	  for (k = 245; k < 255; ++k)
	    {
	      p = k;
	      if (AllocColor (pcmap, &zero, &zero, &zero, &p, 0) != Success)
		FatalError ("Baz!\n");
	    }
	}
d594 2
a595 2
  /* Install the created colormap */
  (*pScreen->InstallColormap)(pcmap);
d598 1
a598 1
  winDebug ("winCreateDefColormap - Returning\n");
d601 1
a601 1
  return TRUE;
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d519 2
a520 5
  if (ppeColors != NULL)
    {
      free (ppeColors);
      ppeColors = NULL;
    }
@


1.1
log
@Initial revision
@
text
@d188 2
a189 2
      curpmap = (ColormapPtr) LookupIDByType(pmap->pScreen->defColormap,
					     RT_COLORMAP);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
