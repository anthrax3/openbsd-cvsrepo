head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.8
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.6
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	Te1daavkBLskZ8gc;

1.5
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.23;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 2001-2004 Harold L Hunt II All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL HAROLD L HUNT II BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of Harold L Hunt II
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from Harold L Hunt II.
 *
 * Authors:	Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include "shellapi.h"

/*
 * Local function prototypes
 */

static Bool
 winGetWorkArea(RECT * prcWorkArea, winScreenInfo * pScreenInfo);

static Bool
 winAdjustForAutoHide(RECT * prcWorkArea, winScreenInfo * pScreenInfo);

/*
 * Create a full screen window
 */

Bool
winCreateBoundingWindowFullScreen(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    int iX = pScreenInfo->dwInitialX;
    int iY = pScreenInfo->dwInitialY;
    int iWidth = pScreenInfo->dwWidth;
    int iHeight = pScreenInfo->dwHeight;
    HWND *phwnd = &pScreenPriv->hwndScreen;
    WNDCLASSEX wc;
    char szTitle[256];

#if CYGDEBUG
    winDebug("winCreateBoundingWindowFullScreen\n");
#endif

    /* Setup our window class */
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = winWindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInstance;
    wc.hIcon =
        (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,
                          GetSystemMetrics(SM_CXICON),
                          GetSystemMetrics(SM_CYICON), 0);
    wc.hCursor = 0;
    wc.hbrBackground = 0;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = WINDOW_CLASS;
    wc.hIconSm =
        (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,
                          GetSystemMetrics(SM_CXSMICON),
                          GetSystemMetrics(SM_CYSMICON), LR_DEFAULTSIZE);
    RegisterClassEx(&wc);

    /* Set display and screen-specific tooltip text */
    if (g_pszQueryHost != NULL)
        snprintf(szTitle,
                 sizeof(szTitle),
                 WINDOW_TITLE_XDMCP,
                 g_pszQueryHost, display, (int) pScreenInfo->dwScreen);
    else
        snprintf(szTitle,
                 sizeof(szTitle),
                 WINDOW_TITLE, display, (int) pScreenInfo->dwScreen);

    /* Create the window */
    *phwnd = CreateWindowExA(0, /* Extended styles */
                             WINDOW_CLASS,      /* Class name */
                             szTitle,   /* Window name */
                             WS_POPUP, iX,      /* Horizontal position */
                             iY,        /* Vertical position */
                             iWidth,    /* Right edge */
                             iHeight,   /* Bottom edge */
                             (HWND) NULL,       /* No parent or owner window */
                             (HMENU) NULL,      /* No menu */
                             GetModuleHandle(NULL),     /* Instance handle */
                             pScreenPriv);      /* ScreenPrivates */

    /* Hide the window */
    ShowWindow(*phwnd, SW_SHOWNORMAL);

    /* Send first paint message */
    UpdateWindow(*phwnd);

    /* Attempt to bring our window to the top of the display */
    BringWindowToTop(*phwnd);

    return TRUE;
}

/*
 * Create our primary Windows display window
 */

Bool
winCreateBoundingWindowWindowed(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    int iWidth = pScreenInfo->dwUserWidth;
    int iHeight = pScreenInfo->dwUserHeight;
    int iPosX;
    int iPosY;
    HWND *phwnd = &pScreenPriv->hwndScreen;
    WNDCLASSEX wc;
    RECT rcClient, rcWorkArea;
    DWORD dwWindowStyle;
    BOOL fForceShowWindow = FALSE;
    char szTitle[256];

    winDebug("winCreateBoundingWindowWindowed - User w: %d h: %d\n",
             (int) pScreenInfo->dwUserWidth, (int) pScreenInfo->dwUserHeight);
    winDebug("winCreateBoundingWindowWindowed - Current w: %d h: %d\n",
             (int) pScreenInfo->dwWidth, (int) pScreenInfo->dwHeight);

    /* Set the common window style flags */
    dwWindowStyle = WS_OVERLAPPED | WS_SYSMENU | WS_MINIMIZEBOX;

    /* Decorated or undecorated window */
    if (pScreenInfo->fDecoration
#ifdef XWIN_MULTIWINDOWEXTWM
        && !pScreenInfo->fMWExtWM
#endif
        && !pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOW
        && !pScreenInfo->fMultiWindow
#endif
        ) {
        /* Try to handle startup via run.exe. run.exe instructs Windows to
         * hide all created windows. Detect this case and make sure the
         * window is shown nevertheless */
        STARTUPINFO startupInfo;

        GetStartupInfo(&startupInfo);
        if (startupInfo.dwFlags & STARTF_USESHOWWINDOW &&
            startupInfo.wShowWindow == SW_HIDE) {
            fForceShowWindow = TRUE;
        }
        dwWindowStyle |= WS_CAPTION;
        if (pScreenInfo->iResizeMode != notAllowed)
            dwWindowStyle |= WS_THICKFRAME | WS_MAXIMIZEBOX;
    }
    else
        dwWindowStyle |= WS_POPUP;

    /* Setup our window class */
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = winWindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInstance;
    wc.hIcon =
        (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,
                          GetSystemMetrics(SM_CXICON),
                          GetSystemMetrics(SM_CYICON), 0);
    wc.hCursor = 0;
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = WINDOW_CLASS;
    wc.hIconSm =
        (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,
                          GetSystemMetrics(SM_CXSMICON),
                          GetSystemMetrics(SM_CYSMICON), LR_DEFAULTSIZE);
    RegisterClassEx(&wc);

    /* Get size of work area */
    winGetWorkArea(&rcWorkArea, pScreenInfo);

    /* Adjust for auto-hide taskbars */
    winAdjustForAutoHide(&rcWorkArea, pScreenInfo);

    /* Did the user specify a position? */
    if (pScreenInfo->fUserGavePosition) {
        iPosX = pScreenInfo->dwInitialX;
        iPosY = pScreenInfo->dwInitialY;
    }
    else {
        iPosX = rcWorkArea.left;
        iPosY = rcWorkArea.top;
    }

    /* Clean up the scrollbars flag, if necessary */
    if ((!pScreenInfo->fDecoration
#ifdef XWIN_MULTIWINDOWEXTWM
         || pScreenInfo->fMWExtWM
#endif
         || pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOW
         || pScreenInfo->fMultiWindow
#endif
        )
        && (pScreenInfo->iResizeMode == resizeWithScrollbars)) {
        /* We cannot have scrollbars if we do not have a window border */
        pScreenInfo->iResizeMode = notAllowed;
    }

    /* Did the user specify a height and width? */
    if (pScreenInfo->fUserGaveHeightAndWidth) {
        /* User gave a desired height and width, try to accomodate */
#if CYGDEBUG
        winDebug("winCreateBoundingWindowWindowed - User gave height "
                 "and width\n");
#endif

        /* Adjust the window width and height for borders and title bar */
        if (pScreenInfo->fDecoration
#ifdef XWIN_MULTIWINDOWEXTWM
            && !pScreenInfo->fMWExtWM
#endif
            && !pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOW
            && !pScreenInfo->fMultiWindow
#endif
            ) {
#if CYGDEBUG
            winDebug
                ("winCreateBoundingWindowWindowed - Window has decoration\n");
#endif

            /* Are we resizable */
            if (pScreenInfo->iResizeMode != notAllowed) {
#if CYGDEBUG
                winDebug
                    ("winCreateBoundingWindowWindowed - Window is resizable\n");
#endif

                iWidth += 2 * GetSystemMetrics(SM_CXSIZEFRAME);
                iHeight += 2 * GetSystemMetrics(SM_CYSIZEFRAME)
                    + GetSystemMetrics(SM_CYCAPTION);
            }
            else {
#if CYGDEBUG
                winDebug
                    ("winCreateBoundingWindowWindowed - Window is not resizable\n");
#endif

                iWidth += 2 * GetSystemMetrics(SM_CXFIXEDFRAME);
                iHeight += 2 * GetSystemMetrics(SM_CYFIXEDFRAME)
                    + GetSystemMetrics(SM_CYCAPTION);
            }
        }
    }
    else {
        /* By default, we are creating a window that is as large as possible */
#if CYGDEBUG
        winDebug("winCreateBoundingWindowWindowed - User did not give "
                 "height and width\n");
#endif
        /* Defaults are wrong if we have multiple monitors */
        if (pScreenInfo->fMultipleMonitors) {
            iWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
            iHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);
        }
    }

    /* Make sure window is no bigger than work area */
    if (TRUE
#ifdef XWIN_MULTIWINDOWEXTWM
        && !pScreenInfo->fMWExtWM
#endif
#ifdef XWIN_MULTIWINDOW
        && !pScreenInfo->fMultiWindow
#endif
        ) {
        /* Trim window width to fit work area */
        if (iWidth > (rcWorkArea.right - rcWorkArea.left))
            iWidth = rcWorkArea.right - rcWorkArea.left;

        /* Trim window height to fit work area */
        if (iHeight >= (rcWorkArea.bottom - rcWorkArea.top))
            iHeight = rcWorkArea.bottom - rcWorkArea.top;

#if CYGDEBUG
        winDebug("winCreateBoundingWindowWindowed - Adjusted width: %d "
                 "height: %d\n", iWidth, iHeight);
#endif
    }

    /* Set display and screen-specific tooltip text */
    if (g_pszQueryHost != NULL)
        snprintf(szTitle,
                 sizeof(szTitle),
                 WINDOW_TITLE_XDMCP,
                 g_pszQueryHost, display, (int) pScreenInfo->dwScreen);
    else
        snprintf(szTitle,
                 sizeof(szTitle),
                 WINDOW_TITLE, display, (int) pScreenInfo->dwScreen);

    /* Create the window */
    *phwnd = CreateWindowExA(0, /* Extended styles */
                             WINDOW_CLASS,      /* Class name */
                             szTitle,   /* Window name */
                             dwWindowStyle, iPosX,      /* Horizontal position */
                             iPosY,     /* Vertical position */
                             iWidth,    /* Right edge */
                             iHeight,   /* Bottom edge */
                             (HWND) NULL,       /* No parent or owner window */
                             (HMENU) NULL,      /* No menu */
                             GetModuleHandle(NULL),     /* Instance handle */
                             pScreenPriv);      /* ScreenPrivates */
    if (*phwnd == NULL) {
        ErrorF("winCreateBoundingWindowWindowed - CreateWindowEx () failed\n");
        return FALSE;
    }

#if CYGDEBUG
    winDebug("winCreateBoundingWindowWindowed - CreateWindowEx () returned\n");
#endif

    if (fForceShowWindow) {
        ErrorF
            ("winCreateBoundingWindowWindowed - Setting normal windowstyle\n");
        ShowWindow(*phwnd, SW_SHOW);
    }

    /* Get the client area coordinates */
    if (!GetClientRect(*phwnd, &rcClient)) {
        ErrorF("winCreateBoundingWindowWindowed - GetClientRect () "
               "failed\n");
        return FALSE;
    }

    winDebug("winCreateBoundingWindowWindowed - WindowClient "
             "w %d  h %d r %d l %d b %d t %d\n",
             (int)(rcClient.right - rcClient.left),
             (int)(rcClient.bottom - rcClient.top),
             (int)rcClient.right, (int)rcClient.left,
             (int)rcClient.bottom, (int)rcClient.top);

    /* We adjust the visual size if the user did not specify it */
    if (!
        ((pScreenInfo->iResizeMode == resizeWithScrollbars) &&
         pScreenInfo->fUserGaveHeightAndWidth)) {
        /*
         * User did not give a height and width with scrollbars enabled,
         * so we will resize the underlying visual to be as large as
         * the initial view port (page size).  This way scrollbars will
         * not appear until the user shrinks the window, if they ever do.
         *
         * NOTE: We have to store the viewport size here because
         * the user may have an autohide taskbar, which would
         * cause the viewport size to be one less in one dimension
         * than the viewport size that we calculated by subtracting
         * the size of the borders and caption.
         */
        pScreenInfo->dwWidth = rcClient.right - rcClient.left;
        pScreenInfo->dwHeight = rcClient.bottom - rcClient.top;
    }

#if 0
    /*
     * NOTE: For the uninitiated, the page size is the number of pixels
     * that we can display in the x or y direction at a time and the
     * range is the total number of pixels in the x or y direction that we
     * have available to display.  In other words, the page size is the
     * size of the window area minus the space the caption, borders, and
     * scrollbars (if any) occupy, and the range is the size of the
     * underlying X visual.  Notice that, contrary to what some of the
     * MSDN Library arcticles lead you to believe, the windows
     * ``client area'' size does not include the scrollbars.  In other words,
     * the whole client area size that is reported to you is drawable by
     * you; you do not have to subtract the size of the scrollbars from
     * the client area size, and if you did it would result in the size
     * of the scrollbars being double counted.
     */

    /* Setup scrollbar page and range, if scrollbars are enabled */
    if (pScreenInfo->fScrollbars) {
        SCROLLINFO si;

        /* Initialize the scrollbar info structure */
        si.cbSize = sizeof(si);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;

        /* Setup the width range and page size */
        si.nMax = pScreenInfo->dwWidth - 1;
        si.nPage = rcClient.right - rcClient.left;
        winDebug("winCreateBoundingWindowWindowed - HORZ nMax: %d nPage :%d\n",
                 si.nMax, si.nPage);
        SetScrollInfo(*phwnd, SB_HORZ, &si, TRUE);

        /* Setup the height range and page size */
        si.nMax = pScreenInfo->dwHeight - 1;
        si.nPage = rcClient.bottom - rcClient.top;
        winDebug("winCreateBoundingWindowWindowed - VERT nMax: %d nPage :%d\n",
                 si.nMax, si.nPage);
        SetScrollInfo(*phwnd, SB_VERT, &si, TRUE);
    }
#endif

    /* Show the window */
    if (FALSE
#ifdef XWIN_MULTIWINDOWEXTWM
        || pScreenInfo->fMWExtWM
#endif
#ifdef XWIN_MULTIWINDOW
        || pScreenInfo->fMultiWindow
#endif
        ) {
#if defined(XWIN_MULTIWINDOW) || defined(XWIN_MULTIWINDOWEXTWM)
        pScreenPriv->fRootWindowShown = FALSE;
#endif
        ShowWindow(*phwnd, SW_HIDE);
    }
    else
        ShowWindow(*phwnd, SW_SHOWNORMAL);
    if (!UpdateWindow(*phwnd)) {
        ErrorF("winCreateBoundingWindowWindowed - UpdateWindow () failed\n");
        return FALSE;
    }

    /* Attempt to bring our window to the top of the display */
    if (TRUE
#ifdef XWIN_MULTIWINDOWEXTWM
        && !pScreenInfo->fMWExtWM
#endif
        && !pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOW
        && !pScreenInfo->fMultiWindow
#endif
        ) {
        if (!BringWindowToTop(*phwnd)) {
            ErrorF("winCreateBoundingWindowWindowed - BringWindowToTop () "
                   "failed\n");
            return FALSE;
        }
    }

    winDebug("winCreateBoundingWindowWindowed -  Returning\n");

    return TRUE;
}

/*
 * Find the work area of all attached monitors
 */

static Bool
winGetWorkArea(RECT * prcWorkArea, winScreenInfo * pScreenInfo)
{
    int iPrimaryWidth, iPrimaryHeight;
    int iWidth, iHeight;
    int iLeft, iTop;
    int iPrimaryNonWorkAreaWidth, iPrimaryNonWorkAreaHeight;

    /* Use GetMonitorInfo to get work area for monitor */
    if (!pScreenInfo->fMultipleMonitors) {
        MONITORINFO mi;

        mi.cbSize = sizeof(MONITORINFO);
        if (GetMonitorInfo(pScreenInfo->hMonitor, &mi)) {
            *prcWorkArea = mi.rcWork;

            winDebug("winGetWorkArea - Monitor %d WorkArea: %d %d %d %d\n",
                     pScreenInfo->iMonitor,
                     (int) prcWorkArea->top, (int) prcWorkArea->left,
                     (int) prcWorkArea->bottom, (int) prcWorkArea->right);
        }
        else {
            ErrorF("winGetWorkArea - GetMonitorInfo() failed for monitor %d\n",
                   pScreenInfo->iMonitor);
        }

        /* Bail out here if we aren't using multiple monitors */
        return TRUE;
    }

    /* SPI_GETWORKAREA only gets the work area of the primary screen. */
    SystemParametersInfo(SPI_GETWORKAREA, 0, prcWorkArea, 0);

    winDebug("winGetWorkArea - Primary Monitor WorkArea: %d %d %d %d\n",
             (int) prcWorkArea->top, (int) prcWorkArea->left,
             (int) prcWorkArea->bottom, (int) prcWorkArea->right);

    /* Get size of full virtual screen */
    iWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    iHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    winDebug("winGetWorkArea - Virtual screen is %d x %d\n", iWidth, iHeight);

    /* Get origin of full virtual screen */
    iLeft = GetSystemMetrics(SM_XVIRTUALSCREEN);
    iTop = GetSystemMetrics(SM_YVIRTUALSCREEN);

    winDebug("winGetWorkArea - Virtual screen origin is %d, %d\n", iLeft, iTop);

    /* Get size of primary screen */
    iPrimaryWidth = GetSystemMetrics(SM_CXSCREEN);
    iPrimaryHeight = GetSystemMetrics(SM_CYSCREEN);

    winDebug("winGetWorkArea - Primary screen is %d x %d\n",
             iPrimaryWidth, iPrimaryHeight);

    /* Work out how much of the primary screen we aren't using */
    iPrimaryNonWorkAreaWidth = iPrimaryWidth - (prcWorkArea->right -
                                                prcWorkArea->left);
    iPrimaryNonWorkAreaHeight = iPrimaryHeight - (prcWorkArea->bottom
                                                  - prcWorkArea->top);

    /* Update the rectangle to include all monitors */
    if (iLeft < 0) {
        prcWorkArea->left = iLeft;
    }
    if (iTop < 0) {
        prcWorkArea->top = iTop;
    }
    prcWorkArea->right = prcWorkArea->left + iWidth - iPrimaryNonWorkAreaWidth;
    prcWorkArea->bottom = prcWorkArea->top + iHeight -
        iPrimaryNonWorkAreaHeight;

    winDebug("winGetWorkArea - Adjusted WorkArea for multiple "
             "monitors: %d %d %d %d\n",
             (int) prcWorkArea->top, (int) prcWorkArea->left,
             (int) prcWorkArea->bottom, (int) prcWorkArea->right);

    return TRUE;
}

static Bool
winTaskbarOnScreenEdge(unsigned int uEdge, winScreenInfo * pScreenInfo)
{
    APPBARDATA abd;
    HWND hwndAutoHide;

    ZeroMemory(&abd, sizeof(abd));
    abd.cbSize = sizeof(abd);
    abd.uEdge = uEdge;

    hwndAutoHide = (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, &abd);
    if (hwndAutoHide != NULL) {
        /*
           Found an autohide taskbar on that edge, but is it on the
           same monitor as the screen window?
         */
        if (pScreenInfo->fMultipleMonitors ||
            (MonitorFromWindow(hwndAutoHide, MONITOR_DEFAULTTONULL) ==
             pScreenInfo->hMonitor))
            return TRUE;
    }
    return FALSE;
}

/*
 * Adjust the client area so that any auto-hide toolbars
 * will work correctly.
 */

static Bool
winAdjustForAutoHide(RECT * prcWorkArea, winScreenInfo * pScreenInfo)
{
    APPBARDATA abd;

    winDebug("winAdjustForAutoHide - Original WorkArea: %d %d %d %d\n",
             (int) prcWorkArea->top, (int) prcWorkArea->left,
             (int) prcWorkArea->bottom, (int) prcWorkArea->right);

    /* Find out if the Windows taskbar is set to auto-hide */
    ZeroMemory(&abd, sizeof(abd));
    abd.cbSize = sizeof(abd);
    if (SHAppBarMessage(ABM_GETSTATE, &abd) & ABS_AUTOHIDE)
        winDebug("winAdjustForAutoHide - Taskbar is auto hide\n");

    /*
       Despite the forgoing, we are checking for any AppBar
       hiding along a monitor edge, not just the Windows TaskBar.
     */

    /* Look for a TOP auto-hide taskbar */
    if (winTaskbarOnScreenEdge(ABE_TOP, pScreenInfo)) {
        winDebug("winAdjustForAutoHide - Found TOP auto-hide taskbar\n");
        prcWorkArea->top += 1;
    }

    /* Look for a LEFT auto-hide taskbar */
    if (winTaskbarOnScreenEdge(ABE_LEFT, pScreenInfo)) {
        winDebug("winAdjustForAutoHide - Found LEFT auto-hide taskbar\n");
        prcWorkArea->left += 1;
    }

    /* Look for a BOTTOM auto-hide taskbar */
    if (winTaskbarOnScreenEdge(ABE_BOTTOM, pScreenInfo)) {
        winDebug("winAdjustForAutoHide - Found BOTTOM auto-hide taskbar\n");
        prcWorkArea->bottom -= 1;
    }

    /* Look for a RIGHT auto-hide taskbar */
    if (winTaskbarOnScreenEdge(ABE_RIGHT, pScreenInfo)) {
        winDebug("winAdjustForAutoHide - Found RIGHT auto-hide taskbar\n");
        prcWorkArea->right -= 1;
    }

    winDebug("winAdjustForAutoHide - Adjusted WorkArea: %d %d %d %d\n",
             (int) prcWorkArea->top, (int) prcWorkArea->left,
             (int) prcWorkArea->bottom, (int) prcWorkArea->right);

    return TRUE;
}
@


1.6
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d360 5
a364 4
             "w %ld h %ld r %ld l %ld b %ld t %ld\n",
             rcClient.right - rcClient.left,
             rcClient.bottom - rcClient.top,
             rcClient.right, rcClient.left, rcClient.bottom, rcClient.top);
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d113 2
a114 14
    /* Branch on the server engine */
    switch (pScreenInfo->dwEngine) {
#ifdef XWIN_NATIVEGDI
    case WIN_SERVER_SHADOW_GDI:
        /* Show the window */
        ShowWindow(*phwnd, SW_SHOWMAXIMIZED);
        break;
#endif

    default:
        /* Hide the window */
        ShowWindow(*phwnd, SW_SHOWNORMAL);
        break;
    }
d163 2
a164 2
        /* Try to handle startup via run.exe. run.exe instructs Windows to 
         * hide all created windows. Detect this case and make sure the 
a463 6

#ifdef XWIN_NATIVEGDI
    /* Paint window background blue */
    if (pScreenInfo->dwEngine == WIN_SERVER_NATIVE_GDI)
        winPaintBackground(*phwnd, RGB(0x00, 0x00, 0xFF));
#endif
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a36 4
#ifndef ABS_AUTOHIDE
#define ABS_AUTOHIDE 1
#endif

d45 1
a45 1
 winAdjustForAutoHide(RECT * prcWorkArea);
d217 1
a217 1
    winAdjustForAutoHide(&rcWorkArea);
d500 22
d525 1
a525 5
    /* Bail out here if we aren't using multiple monitors */
    if (!pScreenInfo->fMultipleMonitors)
        return TRUE;

    winDebug("winGetWorkArea - Original WorkArea: %d %d %d %d\n",
d573 24
d603 1
a603 1
winAdjustForAutoHide(RECT * prcWorkArea)
a605 1
    HWND hwndAutoHide;
d617 5
d623 1
a623 3
    abd.uEdge = ABE_TOP;
    hwndAutoHide = (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, &abd);
    if (hwndAutoHide != NULL) {
d629 1
a629 3
    abd.uEdge = ABE_LEFT;
    hwndAutoHide = (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, &abd);
    if (hwndAutoHide != NULL) {
d635 1
a635 3
    abd.uEdge = ABE_BOTTOM;
    hwndAutoHide = (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, &abd);
    if (hwndAutoHide != NULL) {
d641 1
a641 3
    abd.uEdge = ABE_RIGHT;
    hwndAutoHide = (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, &abd);
    if (hwndAutoHide != NULL) {
a648 9

#if 0
    /* Obtain the task bar window dimensions */
    abd.hWnd = hwndAutoHide;
    hwndAutoHide = (HWND) SHAppBarMessage(ABM_GETTASKBARPOS, &abd);
    winDebug("hwndAutoHide %08x abd.hWnd %08x %d %d %d %d\n",
             hwndAutoHide, abd.hWnd,
             abd.rc.top, abd.rc.left, abd.rc.bottom, abd.rc.right);
#endif
@


1.3
log
@Update to xserver 1.11.2
@
text
@d46 1
a46 1
winGetWorkArea (RECT *prcWorkArea, winScreenInfo *pScreenInfo);
d49 1
a49 2
winAdjustForAutoHide (RECT *prcWorkArea);

d56 1
a56 1
winCreateBoundingWindowFullScreen (ScreenPtr pScreen)
d58 9
a66 9
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  int			iX = pScreenInfo->dwInitialX;
  int			iY = pScreenInfo->dwInitialY;
  int			iWidth = pScreenInfo->dwWidth;
  int			iHeight = pScreenInfo->dwHeight;
  HWND			*phwnd = &pScreenPriv->hwndScreen;
  WNDCLASSEX		wc;
  char			szTitle[256];
d69 1
a69 1
  winDebug ("winCreateBoundingWindowFullScreen\n");
d72 47
a118 49
  /* Setup our window class */
  wc.cbSize=sizeof(WNDCLASSEX);
  wc.style = CS_HREDRAW | CS_VREDRAW;
  wc.lpfnWndProc = winWindowProc;
  wc.cbClsExtra = 0;
  wc.cbWndExtra = 0;
  wc.hInstance = g_hInstance;
  wc.hIcon = (HICON)LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,
		GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);
  wc.hCursor = 0;
  wc.hbrBackground = 0;
  wc.lpszMenuName = NULL;
  wc.lpszClassName = WINDOW_CLASS;
  wc.hIconSm = (HICON)LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,
		GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTSIZE);
  RegisterClassEx (&wc);

  /* Set display and screen-specific tooltip text */
  if (g_pszQueryHost != NULL)
    snprintf (szTitle,
	    sizeof (szTitle),
	    WINDOW_TITLE_XDMCP,
	    g_pszQueryHost,
	    display,
	    (int) pScreenInfo->dwScreen);
  else    
    snprintf (szTitle,
	    sizeof (szTitle),
	    WINDOW_TITLE,
	    display, 
	    (int) pScreenInfo->dwScreen);

  /* Create the window */
  *phwnd = CreateWindowExA (0,			/* Extended styles */
			    WINDOW_CLASS,	/* Class name */
			    szTitle,		/* Window name */
			    WS_POPUP,
			    iX,			/* Horizontal position */
			    iY,			/* Vertical position */
			    iWidth,		/* Right edge */ 
			    iHeight,		/* Bottom edge */
			    (HWND) NULL,	/* No parent or owner window */
			    (HMENU) NULL,	/* No menu */
			    GetModuleHandle (NULL),/* Instance handle */
			    pScreenPriv);	/* ScreenPrivates */

  /* Branch on the server engine */
  switch (pScreenInfo->dwEngine)
    {
d121 3
a123 3
      /* Show the window */
      ShowWindow (*phwnd, SW_SHOWMAXIMIZED);
      break;
d127 3
a129 3
      /* Hide the window */
      ShowWindow (*phwnd, SW_SHOWNORMAL);
      break;
d132 2
a133 2
  /* Send first paint message */
  UpdateWindow (*phwnd);
d135 2
a136 2
  /* Attempt to bring our window to the top of the display */
  BringWindowToTop (*phwnd);
d138 1
a138 1
  return TRUE;
a140 1

d146 1
a146 1
winCreateBoundingWindowWindowed (ScreenPtr pScreen)
d148 23
a170 23
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  int			iWidth = pScreenInfo->dwUserWidth;
  int			iHeight = pScreenInfo->dwUserHeight;
  int                   iPosX;
  int                   iPosY;
  HWND			*phwnd = &pScreenPriv->hwndScreen;
  WNDCLASSEX		wc;
  RECT			rcClient, rcWorkArea;
  DWORD			dwWindowStyle;
  BOOL			fForceShowWindow = FALSE;
  char			szTitle[256];
  
  winDebug ("winCreateBoundingWindowWindowed - User w: %d h: %d\n",
	  (int) pScreenInfo->dwUserWidth, (int) pScreenInfo->dwUserHeight);
  winDebug ("winCreateBoundingWindowWindowed - Current w: %d h: %d\n",
	  (int) pScreenInfo->dwWidth, (int) pScreenInfo->dwHeight);

  /* Set the common window style flags */
  dwWindowStyle = WS_OVERLAPPED | WS_SYSMENU | WS_MINIMIZEBOX;
  
  /* Decorated or undecorated window */
  if (pScreenInfo->fDecoration
d172 1
a172 1
      && !pScreenInfo->fMWExtWM
d174 1
a174 1
      && !pScreenInfo->fRootless
d176 1
a176 1
      && !pScreenInfo->fMultiWindow
d178 1
a178 2
      )
    {
d182 2
a183 1
        STARTUPINFO   startupInfo;
d185 4
a188 5
        if (startupInfo.dwFlags & STARTF_USESHOWWINDOW && 
                startupInfo.wShowWindow == SW_HIDE)
        {
          fForceShowWindow = TRUE;
        } 
d193 2
a194 2
  else
    dwWindowStyle |= WS_POPUP;
d196 35
a230 33
  /* Setup our window class */
  wc.cbSize=sizeof(WNDCLASSEX);
  wc.style = CS_HREDRAW | CS_VREDRAW;
  wc.lpfnWndProc = winWindowProc;
  wc.cbClsExtra = 0;
  wc.cbWndExtra = 0;
  wc.hInstance = g_hInstance;
  wc.hIcon = (HICON)LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,
		GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);
  wc.hCursor = 0;
  wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
  wc.lpszMenuName = NULL;
  wc.lpszClassName = WINDOW_CLASS;
  wc.hIconSm = (HICON)LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_XWIN), IMAGE_ICON,
		GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTSIZE);
  RegisterClassEx (&wc);

  /* Get size of work area */
  winGetWorkArea (&rcWorkArea, pScreenInfo);

  /* Adjust for auto-hide taskbars */
  winAdjustForAutoHide (&rcWorkArea);

  /* Did the user specify a position? */
  if (pScreenInfo->fUserGavePosition)
    {
      iPosX = pScreenInfo->dwInitialX;
      iPosY = pScreenInfo->dwInitialY;
    }
  else
    {
      iPosX = rcWorkArea.left;
      iPosY = rcWorkArea.top;
d233 2
a234 2
  /* Clean up the scrollbars flag, if necessary */
  if ((!pScreenInfo->fDecoration
d236 1
a236 1
       || pScreenInfo->fMWExtWM
d238 1
a238 1
       || pScreenInfo->fRootless
d240 1
a240 1
       || pScreenInfo->fMultiWindow
d242 4
a245 5
       )
      && (pScreenInfo->iResizeMode == resizeWithScrollbars))
    {
      /* We cannot have scrollbars if we do not have a window border */
      pScreenInfo->iResizeMode = notAllowed;
d248 3
a250 4
  /* Did the user specify a height and width? */
  if (pScreenInfo->fUserGaveHeightAndWidth)
    {
      /* User gave a desired height and width, try to accomodate */
d252 2
a253 2
      winDebug ("winCreateBoundingWindowWindowed - User gave height "
	      "and width\n");
d255 3
a257 3
      
      /* Adjust the window width and height for borders and title bar */
      if (pScreenInfo->fDecoration
d259 1
a259 1
	  && !pScreenInfo->fMWExtWM
d261 1
a261 1
	  && !pScreenInfo->fRootless
d263 1
a263 1
	  && !pScreenInfo->fMultiWindow
d265 1
a265 2
	  )
	{
d267 2
a268 1
	  winDebug ("winCreateBoundingWindowWindowed - Window has decoration\n");
d271 2
a272 3
          /* Are we resizable */
          if (pScreenInfo->iResizeMode != notAllowed)
	    {
d274 2
a275 1
	      winDebug ("winCreateBoundingWindowWindowed - Window is resizable\n");
d278 5
a282 6
	      iWidth += 2 * GetSystemMetrics (SM_CXSIZEFRAME);
	      iHeight += 2 * GetSystemMetrics (SM_CYSIZEFRAME) 
		+ GetSystemMetrics (SM_CYCAPTION);
	    }
	  else
	    {
d284 2
a285 1
	      winDebug ("winCreateBoundingWindowWindowed - Window is not resizable\n");
d288 8
a295 9
	      iWidth += 2 * GetSystemMetrics (SM_CXFIXEDFRAME);
	      iHeight += 2 * GetSystemMetrics (SM_CYFIXEDFRAME) 
		+ GetSystemMetrics (SM_CYCAPTION);
	    }
	}
    }
  else
    {
      /* By default, we are creating a window that is as large as possible */
d297 2
a298 2
      winDebug ("winCreateBoundingWindowWindowed - User did not give "
	      "height and width\n");
d300 5
a304 6
      /* Defaults are wrong if we have multiple monitors */
      if (pScreenInfo->fMultipleMonitors)
	{
	  iWidth = GetSystemMetrics (SM_CXVIRTUALSCREEN);
	  iHeight = GetSystemMetrics (SM_CYVIRTUALSCREEN);
	}
d307 2
a308 2
  /* Make sure window is no bigger than work area */
  if (TRUE 
d310 1
a310 1
       && !pScreenInfo->fMWExtWM
d313 1
a313 1
       && !pScreenInfo->fMultiWindow
d315 9
a323 10
     )
    {
      /* Trim window width to fit work area */
      if (iWidth > (rcWorkArea.right - rcWorkArea.left))
        iWidth = rcWorkArea.right - rcWorkArea.left;
  
      /* Trim window height to fit work area */
      if (iHeight >= (rcWorkArea.bottom - rcWorkArea.top))
        iHeight = rcWorkArea.bottom - rcWorkArea.top;
  
d325 2
a326 3
      winDebug ("winCreateBoundingWindowWindowed - Adjusted width: %d "\
	      "height: %d\n",
    	  iWidth, iHeight);
d330 26
a355 32
  /* Set display and screen-specific tooltip text */
  if (g_pszQueryHost != NULL)
    snprintf (szTitle,
	    sizeof (szTitle),
	    WINDOW_TITLE_XDMCP,
	    g_pszQueryHost,
	    display,
	    (int) pScreenInfo->dwScreen);
  else    
    snprintf (szTitle,
	    sizeof (szTitle),
	    WINDOW_TITLE,
	    display, 
	    (int) pScreenInfo->dwScreen);

  /* Create the window */
  *phwnd = CreateWindowExA (0,			/* Extended styles */
			    WINDOW_CLASS,	/* Class name */
			    szTitle,		/* Window name */
			    dwWindowStyle,
			    iPosX,	        /* Horizontal position */
			    iPosY,	        /* Vertical position */
			    iWidth,		/* Right edge */
			    iHeight,		/* Bottom edge */
			    (HWND) NULL,	/* No parent or owner window */
			    (HMENU) NULL,	/* No menu */
			    GetModuleHandle (NULL),/* Instance handle */
			    pScreenPriv);	/* ScreenPrivates */
  if (*phwnd == NULL)
    {
      ErrorF ("winCreateBoundingWindowWindowed - CreateWindowEx () failed\n");
      return FALSE;
d359 1
a359 1
  winDebug ("winCreateBoundingWindowWindowed - CreateWindowEx () returned\n");
d362 37
a398 38
  if (fForceShowWindow)
  {
      ErrorF("winCreateBoundingWindowWindowed - Setting normal windowstyle\n");
      ShowWindow(*phwnd, SW_SHOW);      
  }

  /* Get the client area coordinates */
  if (!GetClientRect (*phwnd, &rcClient))
    {
      ErrorF ("winCreateBoundingWindowWindowed - GetClientRect () "
	      "failed\n");
      return FALSE;
    }

  winDebug ("winCreateBoundingWindowWindowed - WindowClient "
	  "w %ld h %ld r %ld l %ld b %ld t %ld\n",
	  rcClient.right - rcClient.left,
	  rcClient.bottom - rcClient.top,
	  rcClient.right, rcClient.left,
	  rcClient.bottom, rcClient.top);
  
  /* We adjust the visual size if the user did not specify it */
  if (!((pScreenInfo->iResizeMode == resizeWithScrollbars) && pScreenInfo->fUserGaveHeightAndWidth))
    {
      /*
       * User did not give a height and width with scrollbars enabled,
       * so we will resize the underlying visual to be as large as
       * the initial view port (page size).  This way scrollbars will
       * not appear until the user shrinks the window, if they ever do.
       *
       * NOTE: We have to store the viewport size here because
       * the user may have an autohide taskbar, which would
       * cause the viewport size to be one less in one dimension
       * than the viewport size that we calculated by subtracting
       * the size of the borders and caption.
       */
      pScreenInfo->dwWidth = rcClient.right - rcClient.left;
      pScreenInfo->dwHeight = rcClient.bottom - rcClient.top;
d402 38
a439 39
  /*
   * NOTE: For the uninitiated, the page size is the number of pixels
   * that we can display in the x or y direction at a time and the
   * range is the total number of pixels in the x or y direction that we
   * have available to display.  In other words, the page size is the
   * size of the window area minus the space the caption, borders, and
   * scrollbars (if any) occupy, and the range is the size of the
   * underlying X visual.  Notice that, contrary to what some of the
   * MSDN Library arcticles lead you to believe, the windows
   * ``client area'' size does not include the scrollbars.  In other words,
   * the whole client area size that is reported to you is drawable by
   * you; you do not have to subtract the size of the scrollbars from
   * the client area size, and if you did it would result in the size
   * of the scrollbars being double counted.
   */

  /* Setup scrollbar page and range, if scrollbars are enabled */
  if (pScreenInfo->fScrollbars)
    {
      SCROLLINFO		si;
      
      /* Initialize the scrollbar info structure */
      si.cbSize = sizeof (si);
      si.fMask = SIF_RANGE | SIF_PAGE;
      si.nMin = 0;
      
      /* Setup the width range and page size */
      si.nMax = pScreenInfo->dwWidth - 1;
      si.nPage = rcClient.right - rcClient.left;
      winDebug ("winCreateBoundingWindowWindowed - HORZ nMax: %d nPage :%d\n",
	      si.nMax, si.nPage);
      SetScrollInfo (*phwnd, SB_HORZ, &si, TRUE);
      
      /* Setup the height range and page size */
      si.nMax = pScreenInfo->dwHeight - 1;
      si.nPage = rcClient.bottom - rcClient.top;
      winDebug ("winCreateBoundingWindowWindowed - VERT nMax: %d nPage :%d\n",
	      si.nMax, si.nPage);
      SetScrollInfo (*phwnd, SB_VERT, &si, TRUE);
d443 2
a444 2
  /* Show the window */
  if (FALSE
d446 1
a446 1
      || pScreenInfo->fMWExtWM
d449 1
a449 1
      || pScreenInfo->fMultiWindow
d451 1
a451 2
      )
    {
d453 1
a453 1
      pScreenPriv->fRootWindowShown = FALSE;
d455 7
a461 1
      ShowWindow (*phwnd, SW_HIDE);
d463 3
a465 10
  else
    ShowWindow (*phwnd, SW_SHOWNORMAL);
  if (!UpdateWindow (*phwnd))
    {
      ErrorF ("winCreateBoundingWindowWindowed - UpdateWindow () failed\n");
      return FALSE;
    }
  
  /* Attempt to bring our window to the top of the display */
  if (TRUE
d467 1
a467 1
      && !pScreenInfo->fMWExtWM
d469 1
a469 1
      && !pScreenInfo->fRootless
d471 1
a471 1
      && !pScreenInfo->fMultiWindow
d473 6
a478 8
      )
    {
      if (!BringWindowToTop (*phwnd))
	{
	  ErrorF ("winCreateBoundingWindowWindowed - BringWindowToTop () "
		  "failed\n");
	  return FALSE;
	}
d482 3
a484 3
  /* Paint window background blue */
  if (pScreenInfo->dwEngine == WIN_SERVER_NATIVE_GDI)
    winPaintBackground (*phwnd, RGB (0x00, 0x00, 0xFF));
d487 1
a487 1
  winDebug ("winCreateBoundingWindowWindowed -  Returning\n");
d489 1
a489 1
  return TRUE;
a491 1

d497 1
a497 1
winGetWorkArea (RECT *prcWorkArea, winScreenInfo *pScreenInfo)
d499 56
a554 4
  int			iPrimaryWidth, iPrimaryHeight;
  int			iWidth, iHeight;
  int			iLeft, iTop;
  int			iPrimaryNonWorkAreaWidth, iPrimaryNonWorkAreaHeight;
a555 5
  /* SPI_GETWORKAREA only gets the work area of the primary screen. */
  SystemParametersInfo (SPI_GETWORKAREA, 0, prcWorkArea, 0);

  /* Bail out here if we aren't using multiple monitors */
  if (!pScreenInfo->fMultipleMonitors)
a556 50
  
  winDebug ("winGetWorkArea - Original WorkArea: %d %d %d %d\n",
	  (int) prcWorkArea->top, (int) prcWorkArea->left,
	  (int) prcWorkArea->bottom, (int) prcWorkArea->right);

  /* Get size of full virtual screen */
  iWidth = GetSystemMetrics (SM_CXVIRTUALSCREEN);
  iHeight = GetSystemMetrics (SM_CYVIRTUALSCREEN);

  winDebug ("winGetWorkArea - Virtual screen is %d x %d\n", iWidth, iHeight);

  /* Get origin of full virtual screen */
  iLeft = GetSystemMetrics (SM_XVIRTUALSCREEN);
  iTop = GetSystemMetrics (SM_YVIRTUALSCREEN);

  winDebug ("winGetWorkArea - Virtual screen origin is %d, %d\n", iLeft, iTop);
  
  /* Get size of primary screen */
  iPrimaryWidth = GetSystemMetrics (SM_CXSCREEN);
  iPrimaryHeight = GetSystemMetrics (SM_CYSCREEN);

  winDebug ("winGetWorkArea - Primary screen is %d x %d\n",
	 iPrimaryWidth, iPrimaryHeight);
  
  /* Work out how much of the primary screen we aren't using */
  iPrimaryNonWorkAreaWidth = iPrimaryWidth - (prcWorkArea->right -
					      prcWorkArea->left);
  iPrimaryNonWorkAreaHeight = iPrimaryHeight - (prcWorkArea->bottom
						- prcWorkArea->top);
  
  /* Update the rectangle to include all monitors */
  if (iLeft < 0) 
    {
      prcWorkArea->left = iLeft;
    }
  if (iTop < 0) 
    {
      prcWorkArea->top = iTop;
    }
  prcWorkArea->right = prcWorkArea->left + iWidth -
    iPrimaryNonWorkAreaWidth;
  prcWorkArea->bottom = prcWorkArea->top + iHeight -
    iPrimaryNonWorkAreaHeight;
  
  winDebug ("winGetWorkArea - Adjusted WorkArea for multiple "
	  "monitors: %d %d %d %d\n",
	  (int) prcWorkArea->top, (int) prcWorkArea->left,
	  (int) prcWorkArea->bottom, (int) prcWorkArea->right);
  
  return TRUE;
a558 1

d565 1
a565 1
winAdjustForAutoHide (RECT *prcWorkArea)
d567 48
a614 2
  APPBARDATA		abd;
  HWND			hwndAutoHide;
a615 50
  winDebug ("winAdjustForAutoHide - Original WorkArea: %d %d %d %d\n",
	  (int) prcWorkArea->top, (int) prcWorkArea->left,
	  (int) prcWorkArea->bottom, (int) prcWorkArea->right);

  /* Find out if the Windows taskbar is set to auto-hide */
  ZeroMemory (&abd, sizeof (abd));
  abd.cbSize = sizeof (abd);
  if (SHAppBarMessage (ABM_GETSTATE, &abd) & ABS_AUTOHIDE)
    winDebug ("winAdjustForAutoHide - Taskbar is auto hide\n");

  /* Look for a TOP auto-hide taskbar */
  abd.uEdge = ABE_TOP;
  hwndAutoHide = (HWND) SHAppBarMessage (ABM_GETAUTOHIDEBAR, &abd);
  if (hwndAutoHide != NULL)
    {
      winDebug ("winAdjustForAutoHide - Found TOP auto-hide taskbar\n");
      prcWorkArea->top += 1;
    }

  /* Look for a LEFT auto-hide taskbar */
  abd.uEdge = ABE_LEFT;
  hwndAutoHide = (HWND) SHAppBarMessage (ABM_GETAUTOHIDEBAR, &abd);
  if (hwndAutoHide != NULL)
    {
      winDebug ("winAdjustForAutoHide - Found LEFT auto-hide taskbar\n");
      prcWorkArea->left += 1;
    }

  /* Look for a BOTTOM auto-hide taskbar */
  abd.uEdge = ABE_BOTTOM;
  hwndAutoHide = (HWND) SHAppBarMessage (ABM_GETAUTOHIDEBAR, &abd);
  if (hwndAutoHide != NULL)
    {
      winDebug ("winAdjustForAutoHide - Found BOTTOM auto-hide taskbar\n");
      prcWorkArea->bottom -= 1;
    }

  /* Look for a RIGHT auto-hide taskbar */
  abd.uEdge = ABE_RIGHT;
  hwndAutoHide = (HWND) SHAppBarMessage (ABM_GETAUTOHIDEBAR, &abd);
  if (hwndAutoHide != NULL)
    {
      winDebug ("winAdjustForAutoHide - Found RIGHT auto-hide taskbar\n");
      prcWorkArea->right -= 1;
    }

  winDebug ("winAdjustForAutoHide - Adjusted WorkArea: %d %d %d %d\n",
	  (int) prcWorkArea->top, (int) prcWorkArea->left,
	  (int) prcWorkArea->bottom, (int) prcWorkArea->right);
  
d617 6
a622 6
  /* Obtain the task bar window dimensions */
  abd.hWnd = hwndAutoHide;
  hwndAutoHide = (HWND) SHAppBarMessage (ABM_GETTASKBARPOS, &abd);
  winDebug ("hwndAutoHide %08x abd.hWnd %08x %d %d %d %d\n",
	  hwndAutoHide, abd.hWnd,
	  abd.rc.top, abd.rc.left, abd.rc.bottom, abd.rc.right);
d625 1
a625 1
  return TRUE;
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d195 1
a195 1
        if (pScreenInfo->fScrollbars)
d236 16
d275 3
a277 2
	  /* Are we using scrollbars? */
	  if (pScreenInfo->fScrollbars)
d280 1
a280 2
	      winDebug ("winCreateBoundingWindowWindowed - Window has "
		      "scrollbars\n");
d290 1
a290 2
	      winDebug ("winCreateBoundingWindowWindowed - Window does not have "
		      "scrollbars\n");
d314 1
a314 16
  /* Clean up the scrollbars flag, if necessary */
  if ((!pScreenInfo->fDecoration
#ifdef XWIN_MULTIWINDOWEXTWM
       || pScreenInfo->fMWExtWM
#endif
       || pScreenInfo->fRootless
#ifdef XWIN_MULTIWINDOW
       || pScreenInfo->fMultiWindow
#endif
       )
      && pScreenInfo->fScrollbars)
    {
      /* We cannot have scrollbars if we do not have a window border */
      pScreenInfo->fScrollbars = FALSE;
    }
 
d399 1
a399 1
  if (!(pScreenInfo->fScrollbars && pScreenInfo->fUserGaveHeightAndWidth))
@


1.1
log
@Initial revision
@
text
@d66 1
a66 1
  WNDCLASS		wc;
d74 1
d80 2
a81 1
  wc.hIcon = LoadIcon (g_hInstance, MAKEINTRESOURCE(IDI_XWIN));
d86 3
a88 1
  RegisterClass (&wc);
d95 3
a97 1
	    g_pszQueryHost); 
d159 1
a159 1
  WNDCLASS		wc;
d202 1
d208 2
a209 1
  wc.hIcon = LoadIcon (g_hInstance, MAKEINTRESOURCE(IDI_XWIN));
d214 3
a216 1
  RegisterClass (&wc);
d344 3
a346 1
	    g_pszQueryHost); 
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
