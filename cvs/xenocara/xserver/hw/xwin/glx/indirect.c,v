head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.2
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.10
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	s0SI41sEunLdyFfd;

1.8
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * File: indirect.c
 * Purpose: A GLX implementation that uses Windows OpenGL library
 *
 * Authors: Alexander Gottwald
 *          Jon TURNEY
 *
 * Copyright (c) Jon TURNEY 2009
 * Copyright (c) Alexander Gottwald 2004
 *
 * Portions of this file are copied from GL/apple/indirect.c,
 * which contains the following copyright:
 *
 * Copyright (c) 2007, 2008, 2009 Apple Inc.
 * Copyright (c) 2004 Torrey T. Lyons. All Rights Reserved.
 * Copyright (c) 2002 Greg Parker. All Rights Reserved.
 *
 * Portions of this file are copied from Mesa's xf86glx.c,
 * which contains the following copyright:
 *
 * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
  TODO:
  - hook up remaining unimplemented extensions
  - research what guarantees glXWaitX, glXWaitGL are supposed to offer, and implement then
    using GdiFlush and/or glFinish
  - pbuffer clobbering: we don't get async notification, but can we arrange to emit the
    event when we notice it's been clobbered? at the very least, check if it's been clobbered
    before using it?
  - XGetImage() doesn't work on pixmaps; need to do more work to make the format and location
    of the native pixmap compatible
  - implement GLX_EXT_texture_from_pixmap in terms of WGL_ARB_render_texture
    (not quite straightforward as we will have to create a pbuffer and copy the pixmap texture
     into it)
*/

/*
  Assumptions:
  - the __GLXConfig * we get handed back ones we are made (so we can extend the structure
    with privates) and never get created inside the GLX core
*/

/*
  MSDN clarifications:

  It says SetPixelFormat()'s PIXELFORMATDESCRIPTOR pointer argument has no effect
  except on metafiles, this seems to mean that as it's ok to supply NULL if the DC
  is not for a metafile

  wglMakeCurrent ignores the hdc if hglrc is NULL, so wglMakeCurrent(NULL, NULL)
  is used to make no context current

*/

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif

#include "glwindows.h"
#include <glx/glxserver.h>
#include <glx/glxutil.h>
#include <glx/extension_string.h>
#include <GL/glxtokens.h>

#include <winpriv.h>
#include <wgl_ext_api.h>
#include <winglobals.h>

#define NUM_ELEMENTS(x) (sizeof(x)/ sizeof(x[1]))

/* Not yet in w32api */
#ifndef PFD_SUPPORT_DIRECTDRAW
#define PFD_SUPPORT_DIRECTDRAW   0x00002000
#endif
#ifndef PFD_DIRECT3D_ACCELERATED
#define PFD_DIRECT3D_ACCELERATED 0x00004000
#endif
#ifndef PFD_SUPPORT_COMPOSITION
#define PFD_SUPPORT_COMPOSITION  0x00008000
#endif

/* ---------------------------------------------------------------------- */
/*
 *   structure definitions
 */

typedef struct __GLXWinContext __GLXWinContext;
typedef struct __GLXWinDrawable __GLXWinDrawable;
typedef struct __GLXWinScreen glxWinScreen;
typedef struct __GLXWinConfig GLXWinConfig;

struct __GLXWinContext {
    __GLXcontext base;
    HGLRC ctx;                  /* Windows GL Context */
    __GLXWinContext *shareContext;      /* Context with which we will share display lists and textures */
    HWND hwnd;                  /* For detecting when HWND has changed */
};

struct __GLXWinDrawable {
    __GLXdrawable base;
    __GLXWinContext *drawContext;
    __GLXWinContext *readContext;

    /* If this drawable is GLX_DRAWABLE_PBUFFER */
    HPBUFFERARB hPbuffer;

    /* If this drawable is GLX_DRAWABLE_PIXMAP */
    HDC dibDC;
    HBITMAP hDIB;
    HBITMAP hOldDIB;            /* original DIB for DC */
    void *pOldBits;             /* original pBits for this drawable's pixmap */
};

struct __GLXWinScreen {
    __GLXscreen base;

    /* Supported GLX extensions */
    unsigned char glx_enable_bits[__GLX_EXT_BYTES];

    Bool has_WGL_ARB_multisample;
    Bool has_WGL_ARB_pixel_format;
    Bool has_WGL_ARB_pbuffer;
    Bool has_WGL_ARB_render_texture;

    /* wrapped screen functions */
    RealizeWindowProcPtr RealizeWindow;
    UnrealizeWindowProcPtr UnrealizeWindow;
    CopyWindowProcPtr CopyWindow;
};

struct __GLXWinConfig {
    __GLXconfig base;
    int pixelFormatIndex;
};

/* ---------------------------------------------------------------------- */
/*
 * Various debug helpers
 */

#define GLWIN_DEBUG_HWND(hwnd)  \
    if (glxWinDebugSettings.dumpHWND) { \
        char buffer[1024]; \
        if (GetWindowText(hwnd, buffer, sizeof(buffer))==0) *buffer=0; \
        GLWIN_DEBUG_MSG("Got HWND %p for window '%s'", hwnd, buffer); \
    }

glxWinDebugSettingsRec glxWinDebugSettings = { 0, 0, 0, 0, 0, 0 };

static void
glxWinInitDebugSettings(void)
{
    char *envptr;

    envptr = getenv("GLWIN_ENABLE_DEBUG");
    if (envptr != NULL)
        glxWinDebugSettings.enableDebug = (atoi(envptr) == 1);

    envptr = getenv("GLWIN_ENABLE_TRACE");
    if (envptr != NULL)
        glxWinDebugSettings.enableTrace = (atoi(envptr) == 1);

    envptr = getenv("GLWIN_DUMP_PFD");
    if (envptr != NULL)
        glxWinDebugSettings.dumpPFD = (atoi(envptr) == 1);

    envptr = getenv("GLWIN_DUMP_HWND");
    if (envptr != NULL)
        glxWinDebugSettings.dumpHWND = (atoi(envptr) == 1);

    envptr = getenv("GLWIN_DUMP_DC");
    if (envptr != NULL)
        glxWinDebugSettings.dumpDC = (atoi(envptr) == 1);

    envptr = getenv("GLWIN_ENABLE_GLCALL_TRACE");
    if (envptr != NULL)
        glxWinDebugSettings.enableGLcallTrace = (atoi(envptr) == 1);

    envptr = getenv("GLWIN_ENABLE_WGLCALL_TRACE");
    if (envptr != NULL)
        glxWinDebugSettings.enableWGLcallTrace = (atoi(envptr) == 1);

    envptr = getenv("GLWIN_DEBUG_ALL");
    if (envptr != NULL) {
        glxWinDebugSettings.enableDebug = 1;
        glxWinDebugSettings.enableTrace = 1;
        glxWinDebugSettings.dumpPFD = 1;
        glxWinDebugSettings.dumpHWND = 1;
        glxWinDebugSettings.dumpDC = 1;
        glxWinDebugSettings.enableGLcallTrace = 1;
        glxWinDebugSettings.enableWGLcallTrace = 1;
    }
}

static
const char *
glxWinErrorMessage(void)
{
    static char errorbuffer[1024];
    unsigned int last_error = GetLastError();

    if (!FormatMessage
        (FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
         FORMAT_MESSAGE_MAX_WIDTH_MASK, NULL, last_error, 0,
         (LPTSTR) &errorbuffer, sizeof(errorbuffer), NULL)) {
        snprintf(errorbuffer, sizeof(errorbuffer), "Unknown error");
    }

    if ((errorbuffer[strlen(errorbuffer) - 1] == '\n') ||
        (errorbuffer[strlen(errorbuffer) - 1] == '\r'))
        errorbuffer[strlen(errorbuffer) - 1] = 0;

    sprintf(errorbuffer + strlen(errorbuffer), " (%08x)", last_error);

    return errorbuffer;
}

static void pfdOut(const PIXELFORMATDESCRIPTOR * pfd);

#define DUMP_PFD_FLAG(flag) \
    if (pfd->dwFlags & flag) { \
        ErrorF("%s%s", pipesym, #flag); \
        pipesym = " | "; \
    }

static void
pfdOut(const PIXELFORMATDESCRIPTOR * pfd)
{
    const char *pipesym = "";   /* will be set after first flag dump */

    ErrorF("PIXELFORMATDESCRIPTOR:\n");
    ErrorF("nSize = %u\n", pfd->nSize);
    ErrorF("nVersion = %u\n", pfd->nVersion);
    ErrorF("dwFlags = %u = {", (unsigned int)pfd->dwFlags);
    DUMP_PFD_FLAG(PFD_DOUBLEBUFFER);
    DUMP_PFD_FLAG(PFD_STEREO);
    DUMP_PFD_FLAG(PFD_DRAW_TO_WINDOW);
    DUMP_PFD_FLAG(PFD_DRAW_TO_BITMAP);
    DUMP_PFD_FLAG(PFD_SUPPORT_GDI);
    DUMP_PFD_FLAG(PFD_SUPPORT_OPENGL);
    DUMP_PFD_FLAG(PFD_GENERIC_FORMAT);
    DUMP_PFD_FLAG(PFD_NEED_PALETTE);
    DUMP_PFD_FLAG(PFD_NEED_SYSTEM_PALETTE);
    DUMP_PFD_FLAG(PFD_SWAP_EXCHANGE);
    DUMP_PFD_FLAG(PFD_SWAP_COPY);
    DUMP_PFD_FLAG(PFD_SWAP_LAYER_BUFFERS);
    DUMP_PFD_FLAG(PFD_GENERIC_ACCELERATED);
    DUMP_PFD_FLAG(PFD_SUPPORT_DIRECTDRAW);
    DUMP_PFD_FLAG(PFD_DIRECT3D_ACCELERATED);
    DUMP_PFD_FLAG(PFD_SUPPORT_COMPOSITION);
    DUMP_PFD_FLAG(PFD_DEPTH_DONTCARE);
    DUMP_PFD_FLAG(PFD_DOUBLEBUFFER_DONTCARE);
    DUMP_PFD_FLAG(PFD_STEREO_DONTCARE);
    ErrorF("}\n");

    ErrorF("iPixelType = %hu = %s\n", pfd->iPixelType,
           (pfd->iPixelType ==
            PFD_TYPE_RGBA ? "PFD_TYPE_RGBA" : "PFD_TYPE_COLORINDEX"));
    ErrorF("cColorBits = %hhu\n", pfd->cColorBits);
    ErrorF("cRedBits = %hhu\n", pfd->cRedBits);
    ErrorF("cRedShift = %hhu\n", pfd->cRedShift);
    ErrorF("cGreenBits = %hhu\n", pfd->cGreenBits);
    ErrorF("cGreenShift = %hhu\n", pfd->cGreenShift);
    ErrorF("cBlueBits = %hhu\n", pfd->cBlueBits);
    ErrorF("cBlueShift = %hhu\n", pfd->cBlueShift);
    ErrorF("cAlphaBits = %hhu\n", pfd->cAlphaBits);
    ErrorF("cAlphaShift = %hhu\n", pfd->cAlphaShift);
    ErrorF("cAccumBits = %hhu\n", pfd->cAccumBits);
    ErrorF("cAccumRedBits = %hhu\n", pfd->cAccumRedBits);
    ErrorF("cAccumGreenBits = %hhu\n", pfd->cAccumGreenBits);
    ErrorF("cAccumBlueBits = %hhu\n", pfd->cAccumBlueBits);
    ErrorF("cAccumAlphaBits = %hhu\n", pfd->cAccumAlphaBits);
    ErrorF("cDepthBits = %hhu\n", pfd->cDepthBits);
    ErrorF("cStencilBits = %hhu\n", pfd->cStencilBits);
    ErrorF("cAuxBuffers = %hhu\n", pfd->cAuxBuffers);
    ErrorF("iLayerType = %hhu\n", pfd->iLayerType);
    ErrorF("bReserved = %hhu\n", pfd->bReserved);
    ErrorF("dwLayerMask = %u\n", (unsigned int)pfd->dwLayerMask);
    ErrorF("dwVisibleMask = %u\n", (unsigned int)pfd->dwVisibleMask);
    ErrorF("dwDamageMask = %u\n", (unsigned int)pfd->dwDamageMask);
    ErrorF("\n");
}

static const char *
visual_class_name(int cls)
{
    switch (cls) {
    case GLX_STATIC_COLOR:
        return "StaticColor";
    case GLX_PSEUDO_COLOR:
        return "PseudoColor";
    case GLX_STATIC_GRAY:
        return "StaticGray";
    case GLX_GRAY_SCALE:
        return "GrayScale";
    case GLX_TRUE_COLOR:
        return "TrueColor";
    case GLX_DIRECT_COLOR:
        return "DirectColor";
    default:
        return "-none-";
    }
}

static const char *
swap_method_name(int mthd)
{
    switch (mthd) {
    case GLX_SWAP_EXCHANGE_OML:
        return "xchg";
    case GLX_SWAP_COPY_OML:
        return "copy";
    case GLX_SWAP_UNDEFINED_OML:
        return "    ";
    default:
        return "????";
    }
}

static void
fbConfigsDump(unsigned int n, __GLXconfig * c)
{
    LogMessage(X_INFO, "%d fbConfigs\n", n);

    if (g_iLogVerbose < 3)
        return;
    ErrorF("%d fbConfigs\n", n);
    ErrorF
        ("pxf vis  fb                      render         Ste                     aux    accum        MS    drawable             Group/\n");
    ErrorF
        ("idx  ID  ID VisualType Depth Lvl RGB CI DB Swap reo  R  G  B  A   Z  S  buf AR AG AB AA  bufs num  W P Pb  Float Trans Caveat\n");
    ErrorF
        ("-----------------------------------------------------------------------------------------------------------------------------\n");

    while (c != NULL) {
        unsigned int i = ((GLXWinConfig *) c)->pixelFormatIndex;

        ErrorF("%3d %3x %3x "
               "%-11s"
               " %3d %3d   %s   %s  %s %s  %s  "
               "%2d %2d %2d %2d  "
               "%2d %2d  "
               "%2d  "
               "%2d %2d %2d %2d"
               "   %2d   %2d"
               "  %s %s %s "
               "    %s   "
               "  %s   "
               "  %d %s"
               "\n",
               i, c->visualID, c->fbconfigID,
               visual_class_name(c->visualType),
               c->rgbBits ? c->rgbBits : c->indexBits,
               c->level,
               (c->renderType & GLX_RGBA_BIT) ? "y" : ".",
               (c->renderType & GLX_COLOR_INDEX_BIT) ? "y" : ".",
               c->doubleBufferMode ? "y" : ".",
               swap_method_name(c->swapMethod),
               c->stereoMode ? "y" : ".",
               c->redBits, c->greenBits, c->blueBits, c->alphaBits,
               c->depthBits, c->stencilBits,
               c->numAuxBuffers,
               c->accumRedBits, c->accumGreenBits, c->accumBlueBits,
               c->accumAlphaBits, c->sampleBuffers, c->samples,
               (c->drawableType & GLX_WINDOW_BIT) ? "y" : ".",
               (c->drawableType & GLX_PIXMAP_BIT) ? "y" : ".",
               (c->drawableType & GLX_PBUFFER_BIT) ? "y" : ".",
               (c->renderType & (GLX_RGBA_FLOAT_BIT_ARB |
                   GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT)) ? "y" : ".",
               (c->transparentPixel != GLX_NONE_EXT) ? "y" : ".",
               c->visualSelectGroup,
               (c->visualRating == GLX_SLOW_VISUAL_EXT) ? "*" : " ");

        c = c->next;
    }
}

/* ---------------------------------------------------------------------- */
/*
 * Forward declarations
 */

static __GLXscreen *glxWinScreenProbe(ScreenPtr pScreen);
static __GLXcontext *glxWinCreateContext(__GLXscreen * screen,
                                         __GLXconfig * modes,
                                         __GLXcontext * baseShareContext,
                                         unsigned num_attribs,
                                         const uint32_t * attribs, int *error);
static __GLXdrawable *glxWinCreateDrawable(ClientPtr client,
                                           __GLXscreen * screen,
                                           DrawablePtr pDraw,
                                           XID drawId,
                                           int type,
                                           XID glxDrawId, __GLXconfig * conf);

static Bool glxWinRealizeWindow(WindowPtr pWin);
static Bool glxWinUnrealizeWindow(WindowPtr pWin);
static void glxWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg,
                             RegionPtr prgnSrc);

static HDC glxWinMakeDC(__GLXWinContext * gc, __GLXWinDrawable * draw,
                        HDC * hdc, HWND * hwnd);
static void glxWinReleaseDC(HWND hwnd, HDC hdc, __GLXWinDrawable * draw);

static void glxWinCreateConfigs(HDC dc, glxWinScreen * screen);
static void glxWinCreateConfigsExt(HDC hdc, glxWinScreen * screen);
static int fbConfigToPixelFormat(__GLXconfig * mode,
                                 PIXELFORMATDESCRIPTOR * pfdret,
                                 int drawableTypeOverride);
static int fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig * mode,
                                      int drawableTypeOverride,
                                      glxWinScreen * winScreen);

/* ---------------------------------------------------------------------- */
/*
 * The GLX provider
 */

__GLXprovider __glXWGLProvider = {
    glxWinScreenProbe,
    "Win32 native WGL",
    NULL
};

void
glxWinPushNativeProvider(void)
{
    GlxPushProvider(&__glXWGLProvider);
}

/* ---------------------------------------------------------------------- */
/*
 * Screen functions
 */

static void
glxWinScreenDestroy(__GLXscreen * screen)
{
    GLWIN_DEBUG_MSG("glxWinScreenDestroy(%p)", screen);
    __glXScreenDestroy(screen);
    free(screen);
}

static int
glxWinScreenSwapInterval(__GLXdrawable * drawable, int interval)
{
    BOOL ret = wglSwapIntervalEXTWrapper(interval);

    if (!ret) {
        ErrorF("wglSwapIntervalEXT interval %d failed:%s\n", interval,
               glxWinErrorMessage());
    }
    return ret;
}

/*
  Report the extensions split and formatted to avoid overflowing a line
 */
static void
glxLogExtensions(const char *prefix, const char *extensions)
{
    int length = 0;
    const char *strl;
    char *str = strdup(extensions);

    if (str == NULL) {
        ErrorF("glxLogExtensions: xalloc error\n");
        return;
    }

    strl = strtok(str, " ");
    if (strl == NULL)
        strl = "";
    ErrorF("%s%s", prefix, strl);
    length = strlen(prefix) + strlen(strl);

    while (1) {
        strl = strtok(NULL, " ");
        if (strl == NULL)
            break;

        if (length + strlen(strl) + 1 > 120) {
            ErrorF("\n");
            ErrorF("%s", prefix);
            length = strlen(prefix);
        }
        else {
            ErrorF(" ");
            length++;
        }

        ErrorF("%s", strl);
        length = length + strlen(strl);
    }

    ErrorF("\n");

    free(str);
}

/* This is called by GlxExtensionInit() asking the GLX provider if it can handle the screen... */
static __GLXscreen *
glxWinScreenProbe(ScreenPtr pScreen)
{
    glxWinScreen *screen;
    const char *gl_extensions;
    const char *gl_renderer;
    const char *wgl_extensions;
    HWND hwnd;
    HDC hdc;
    HGLRC hglrc;

    GLWIN_DEBUG_MSG("glxWinScreenProbe");

    glxWinInitDebugSettings();

    if (pScreen == NULL)
        return NULL;

    if (!winCheckScreenAiglxIsSupported(pScreen)) {
        LogMessage(X_ERROR,
                   "AIGLX: No native OpenGL in modes with a root window\n");
        return NULL;
    }

    screen = calloc(1, sizeof(glxWinScreen));

    if (NULL == screen)
        return NULL;

    // Select the native GL implementation (WGL)
    if (glWinSelectImplementation(1))
        return NULL;

    // create window class
#define WIN_GL_TEST_WINDOW_CLASS "XWinGLTest"
    {
        static wATOM glTestWndClass = 0;

        if (glTestWndClass == 0) {
            WNDCLASSEX wc;

            wc.cbSize = sizeof(WNDCLASSEX);
            wc.style = CS_HREDRAW | CS_VREDRAW;
            wc.lpfnWndProc = DefWindowProc;
            wc.cbClsExtra = 0;
            wc.cbWndExtra = 0;
            wc.hInstance = GetModuleHandle(NULL);
            wc.hIcon = 0;
            wc.hCursor = 0;
            wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
            wc.lpszMenuName = NULL;
            wc.lpszClassName = WIN_GL_TEST_WINDOW_CLASS;
            wc.hIconSm = 0;
            RegisterClassEx(&wc);
        }
    }

    // create an invisible window for a scratch DC
    hwnd = CreateWindowExA(0,
                           WIN_GL_TEST_WINDOW_CLASS,
                           "XWin GL Renderer Capabilities Test Window",
                           0, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL),
                           NULL);
    if (hwnd == NULL)
        LogMessage(X_ERROR,
                   "AIGLX: Couldn't create a window for render capabilities testing\n");

    hdc = GetDC(hwnd);

    // we must set a pixel format before we can create a context, just use the first one...
    SetPixelFormat(hdc, 1, NULL);
    hglrc = wglCreateContext(hdc);
    wglMakeCurrent(hdc, hglrc);

    // initialize wgl extension proc pointers (don't call them before here...)
    // (but we need to have a current context for them to be resolvable)
    wglResolveExtensionProcs();

    /* Dump out some useful information about the native renderer */
    ErrorF("GL_VERSION:     %s\n", glGetString(GL_VERSION));
    ErrorF("GL_VENDOR:      %s\n", glGetString(GL_VENDOR));
    gl_renderer = (const char *) glGetString(GL_RENDERER);
    ErrorF("GL_RENDERER:    %s\n", gl_renderer);
    gl_extensions = (const char *) glGetString(GL_EXTENSIONS);
    wgl_extensions = wglGetExtensionsStringARBWrapper(hdc);
    if (!wgl_extensions)
        wgl_extensions = "";

    if (g_iLogVerbose >= 3) {
        glxLogExtensions("GL_EXTENSIONS:  ", gl_extensions);
        glxLogExtensions("WGL_EXTENSIONS: ", wgl_extensions);
    }

    if (strcasecmp(gl_renderer, "GDI Generic") == 0) {
        free(screen);
        LogMessage(X_ERROR,
                   "AIGLX: Won't use generic native renderer as it is not accelerated\n");
        goto error;
    }

    // Can you see the problem here?  The extensions string is DC specific
    // Different DCs for windows on a multimonitor system driven by multiple cards
    // might have completely different capabilities.  Of course, good luck getting
    // those screens to be accelerated in XP and earlier...

    {
        // testing facility to not use any WGL extensions
        char *envptr = getenv("GLWIN_NO_WGL_EXTENSIONS");

        if ((envptr != NULL) && (atoi(envptr) != 0)) {
            ErrorF("GLWIN_NO_WGL_EXTENSIONS is set, ignoring WGL_EXTENSIONS\n");
            wgl_extensions = "";
        }
    }

    {
        Bool glx_sgi_make_current_read = FALSE;

        //
        // Based on the WGL extensions available, enable various GLX extensions
        // XXX: make this table-driven ?
        //
        memset(screen->glx_enable_bits, 0, __GLX_EXT_BYTES);

        __glXEnableExtension(screen->glx_enable_bits, "GLX_EXT_visual_info");
        __glXEnableExtension(screen->glx_enable_bits, "GLX_EXT_visual_rating");
        __glXEnableExtension(screen->glx_enable_bits, "GLX_EXT_import_context");
        __glXEnableExtension(screen->glx_enable_bits, "GLX_OML_swap_method");
        __glXEnableExtension(screen->glx_enable_bits, "GLX_SGIX_fbconfig");

        if (strstr(wgl_extensions, "WGL_ARB_make_current_read")) {
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_SGI_make_current_read");
            LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_make_current_read\n");
            glx_sgi_make_current_read = TRUE;
        }

        if (strstr(gl_extensions, "GL_WIN_swap_hint")) {
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_MESA_copy_sub_buffer");
            LogMessage(X_INFO, "AIGLX: enabled GLX_MESA_copy_sub_buffer\n");
        }

        if (strstr(wgl_extensions, "WGL_EXT_swap_control")) {
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_SGI_swap_control");
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_MESA_swap_control");
            LogMessage(X_INFO,
                       "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
        }

/*       // Hmm?  screen->texOffset */
/*       if (strstr(wgl_extensions, "WGL_ARB_render_texture")) */
/*         { */
/*           __glXEnableExtension(screen->glx_enable_bits, "GLX_EXT_texture_from_pixmap"); */
/*           LogMessage(X_INFO, "AIGLX: GLX_EXT_texture_from_pixmap backed by buffer objects\n"); */
/*           screen->has_WGL_ARB_render_texture = TRUE; */
/*         } */

        if (strstr(wgl_extensions, "WGL_ARB_pbuffer")) {
            __glXEnableExtension(screen->glx_enable_bits, "GLX_SGIX_pbuffer");
            LogMessage(X_INFO, "AIGLX: enabled GLX_SGIX_pbuffer\n");
            screen->has_WGL_ARB_pbuffer = TRUE;
        }

        if (strstr(wgl_extensions, "WGL_ARB_multisample")) {
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_ARB_multisample");
            __glXEnableExtension(screen->glx_enable_bits,
                                 "GLX_SGIS_multisample");
            LogMessage(X_INFO,
                       "AIGLX: enabled GLX_ARB_multisample and GLX_SGIS_multisample\n");
            screen->has_WGL_ARB_multisample = TRUE;
        }

        screen->base.destroy = glxWinScreenDestroy;
        screen->base.createContext = glxWinCreateContext;
        screen->base.createDrawable = glxWinCreateDrawable;
        screen->base.swapInterval = glxWinScreenSwapInterval;
        screen->base.pScreen = pScreen;

        // Creating the fbConfigs initializes screen->base.fbconfigs and screen->base.numFBConfigs
        if (strstr(wgl_extensions, "WGL_ARB_pixel_format")) {
            glxWinCreateConfigsExt(hdc, screen);

            /*
               Some graphics drivers appear to advertise WGL_ARB_pixel_format,
               but it doesn't work usefully, so we have to be prepared for it
               to fail and fall back to using DescribePixelFormat()
             */
            if (screen->base.numFBConfigs > 0) {
                screen->has_WGL_ARB_pixel_format = TRUE;
            }
        }

        if (screen->base.numFBConfigs <= 0) {
            glxWinCreateConfigs(hdc, screen);
            screen->has_WGL_ARB_pixel_format = FALSE;
        }

        /*
           If we still didn't get any fbConfigs, we can't provide GLX for this screen
         */
        if (screen->base.numFBConfigs <= 0) {
            free(screen);
            LogMessage(X_ERROR,
                       "AIGLX: No fbConfigs could be made from native OpenGL pixel formats\n");
            goto error;
        }

        /* These will be set by __glXScreenInit */
        screen->base.visuals = NULL;
        screen->base.numVisuals = 0;

        __glXScreenInit(&screen->base, pScreen);

        // Generate the GLX extensions string (overrides that set by __glXScreenInit())
        {
            unsigned int buffer_size =
                __glXGetExtensionString(screen->glx_enable_bits, NULL);
            if (buffer_size > 0) {
                free(screen->base.GLXextensions);

                screen->base.GLXextensions = xnfalloc(buffer_size);
                __glXGetExtensionString(screen->glx_enable_bits,
                                        screen->base.GLXextensions);
            }
        }

        //
        // Override the GLX version (__glXScreenInit() sets it to "1.2")
        // if we have all the needed extensions to operate as a higher version
        //
        // SGIX_fbconfig && SGIX_pbuffer && SGI_make_current_read -> 1.3
        // ARB_multisample -> 1.4
        //
        if (screen->has_WGL_ARB_pbuffer && glx_sgi_make_current_read) {
            if (screen->has_WGL_ARB_multisample) {
                screen->base.GLXmajor = 1;
                screen->base.GLXminor = 4;
            }
            else {
                screen->base.GLXmajor = 1;
                screen->base.GLXminor = 3;
            }
        }
    }
    LogMessage(X_INFO, "AIGLX: Set GLX version to %d.%d\n",
               screen->base.GLXmajor, screen->base.GLXminor);

    wglMakeCurrent(NULL, NULL);
    wglDeleteContext(hglrc);
    ReleaseDC(hwnd, hdc);
    DestroyWindow(hwnd);

    // dump out fbConfigs now fbConfigIds and visualIDs have been assigned
    fbConfigsDump(screen->base.numFBConfigs, screen->base.fbconfigs);

    /* Wrap RealizeWindow, UnrealizeWindow and CopyWindow on this screen */
    screen->RealizeWindow = pScreen->RealizeWindow;
    pScreen->RealizeWindow = glxWinRealizeWindow;
    screen->UnrealizeWindow = pScreen->UnrealizeWindow;
    pScreen->UnrealizeWindow = glxWinUnrealizeWindow;
    screen->CopyWindow = pScreen->CopyWindow;
    pScreen->CopyWindow = glxWinCopyWindow;

    return &screen->base;

 error:
    // Something went wrong and we can't use the native GL implementation
    // so make sure the mesa GL implementation is selected instead
    glWinSelectImplementation(0);

    return NULL;
}

/* ---------------------------------------------------------------------- */
/*
 * Window functions
 */

static Bool
glxWinRealizeWindow(WindowPtr pWin)
{
    Bool result;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    glxWinScreen *screenPriv = (glxWinScreen *) glxGetScreen(pScreen);

    GLWIN_DEBUG_MSG("glxWinRealizeWindow");

    /* Allow the window to be created (RootlessRealizeWindow is inside our wrap) */
    pScreen->RealizeWindow = screenPriv->RealizeWindow;
    result = pScreen->RealizeWindow(pWin);
    pScreen->RealizeWindow = glxWinRealizeWindow;

    return result;
}

static void
glxWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    __GLXWinDrawable *pGlxDraw;
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    glxWinScreen *screenPriv = (glxWinScreen *) glxGetScreen(pScreen);

    GLWIN_TRACE_MSG("glxWinCopyWindow pWindow %p", pWindow);

    dixLookupResourceByType((void *) &pGlxDraw, pWindow->drawable.id,
                            __glXDrawableRes, NullClient, DixUnknownAccess);

    /*
       Discard any CopyWindow requests if a GL drawing context is pointing at the window

       For regions which are being drawn by GL, the shadow framebuffer doesn't have the
       correct bits, so we wish to avoid shadow framebuffer damage occuring, which will
       cause those incorrect bits to be transferred to the display....
     */
    if (pGlxDraw && pGlxDraw->drawContext) {
        GLWIN_DEBUG_MSG("glxWinCopyWindow: discarding");
        return;
    }

    GLWIN_DEBUG_MSG("glxWinCopyWindow - passing to hw layer");

    pScreen->CopyWindow = screenPriv->CopyWindow;
    pScreen->CopyWindow(pWindow, ptOldOrg, prgnSrc);
    pScreen->CopyWindow = glxWinCopyWindow;
}

static Bool
glxWinUnrealizeWindow(WindowPtr pWin)
{
    Bool result;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    glxWinScreen *screenPriv = (glxWinScreen *) glxGetScreen(pScreen);

    GLWIN_DEBUG_MSG("glxWinUnrealizeWindow");

    pScreen->UnrealizeWindow = screenPriv->UnrealizeWindow;
    result = pScreen->UnrealizeWindow(pWin);
    pScreen->UnrealizeWindow = glxWinUnrealizeWindow;

    return result;
}

/* ---------------------------------------------------------------------- */
/*
 * Drawable functions
 */

static GLboolean
glxWinDrawableSwapBuffers(ClientPtr client, __GLXdrawable * base)
{
    HDC dc;
    HWND hwnd;
    BOOL ret;
    __GLXWinDrawable *draw = (__GLXWinDrawable *) base;

    /* Swap buffers on the last active context for drawing on the drawable */
    if (draw->drawContext == NULL) {
        GLWIN_TRACE_MSG("glxWinSwapBuffers - no context for drawable");
        return GL_FALSE;
    }

    GLWIN_TRACE_MSG
        ("glxWinSwapBuffers on drawable %p, last context %p (native ctx %p)",
         base, draw->drawContext, draw->drawContext->ctx);

    dc = glxWinMakeDC(draw->drawContext, draw, &dc, &hwnd);
    if (dc == NULL)
        return GL_FALSE;

    ret = wglSwapLayerBuffers(dc, WGL_SWAP_MAIN_PLANE);

    glxWinReleaseDC(hwnd, dc, draw);

    if (!ret) {
        ErrorF("wglSwapBuffers failed: %s\n", glxWinErrorMessage());
        return GL_FALSE;
    }

    return GL_TRUE;
}

static void
glxWinDrawableCopySubBuffer(__GLXdrawable * drawable,
                            int x, int y, int w, int h)
{
    glAddSwapHintRectWINWrapper(x, y, w, h);
    glxWinDrawableSwapBuffers(NULL, drawable);
}

static void
glxWinDrawableDestroy(__GLXdrawable * base)
{
    __GLXWinDrawable *glxPriv = (__GLXWinDrawable *) base;

    if (glxPriv->hPbuffer)
        if (!wglDestroyPbufferARBWrapper(glxPriv->hPbuffer)) {
            ErrorF("wglDestroyPbufferARB failed: %s\n", glxWinErrorMessage());
        }

    if (glxPriv->dibDC) {
        // restore the default DIB
        SelectObject(glxPriv->dibDC, glxPriv->hOldDIB);

        if (!DeleteDC(glxPriv->dibDC)) {
            ErrorF("DeleteDC failed: %s\n", glxWinErrorMessage());
        }
    }

    if (glxPriv->hDIB) {
        if (!DeleteObject(glxPriv->hDIB)) {
            ErrorF("DeleteObject failed: %s\n", glxWinErrorMessage());
        }

        ((PixmapPtr) glxPriv->base.pDraw)->devPrivate.ptr = glxPriv->pOldBits;
    }

    GLWIN_DEBUG_MSG("glxWinDestroyDrawable");
    free(glxPriv);
}

static __GLXdrawable *
glxWinCreateDrawable(ClientPtr client,
                     __GLXscreen * screen,
                     DrawablePtr pDraw,
                     XID drawId, int type, XID glxDrawId, __GLXconfig * conf)
{
    __GLXWinDrawable *glxPriv;

    glxPriv = malloc(sizeof *glxPriv);

    if (glxPriv == NULL)
        return NULL;

    memset(glxPriv, 0, sizeof *glxPriv);

    if (!__glXDrawableInit
        (&glxPriv->base, screen, pDraw, type, glxDrawId, conf)) {
        free(glxPriv);
        return NULL;
    }

    glxPriv->base.destroy = glxWinDrawableDestroy;
    glxPriv->base.swapBuffers = glxWinDrawableSwapBuffers;
    glxPriv->base.copySubBuffer = glxWinDrawableCopySubBuffer;
    // glxPriv->base.waitX  what are these for?
    // glxPriv->base.waitGL

    GLWIN_DEBUG_MSG("glxWinCreateDrawable %p", glxPriv);

    return &glxPriv->base;
}

/* ---------------------------------------------------------------------- */
/*
 * Texture functions
 */

static
    int
glxWinBindTexImage(__GLXcontext * baseContext,
                   int buffer, __GLXdrawable * pixmap)
{
    ErrorF("glxWinBindTexImage: not implemented\n");
    return FALSE;
}

static
    int
glxWinReleaseTexImage(__GLXcontext * baseContext,
                      int buffer, __GLXdrawable * pixmap)
{
    ErrorF(" glxWinReleaseTexImage: not implemented\n");
    return FALSE;
}

/* ---------------------------------------------------------------------- */
/*
 * Lazy update context implementation
 *
 * WGL contexts are created for a specific HDC, so we cannot create the WGL
 * context in glxWinCreateContext(), we must defer creation until the context
 * is actually used on a specifc drawable which is connected to a native window,
 * pbuffer or DIB
 *
 * The WGL context may be used on other, compatible HDCs, so we don't need to
 * recreate it for every new native window
 *
 * XXX: I wonder why we can't create the WGL context on the screen HDC ?
 * Basically we assume all HDCs are compatible at the moment: if they are not
 * we are in a muddle, there was some code in the old implementation to attempt
 * to transparently migrate a context to a new DC by copying state and sharing
 * lists with the old one...
 */

static Bool
glxWinSetPixelFormat(__GLXWinContext * gc, HDC hdc, int bppOverride,
                     int drawableTypeOverride)
{
    __GLXscreen *screen = gc->base.pGlxScreen;
    glxWinScreen *winScreen = (glxWinScreen *) screen;

    __GLXconfig *config = gc->base.config;
    GLXWinConfig *winConfig = (GLXWinConfig *) config;

    GLWIN_DEBUG_MSG("glxWinSetPixelFormat: pixelFormatIndex %d",
                    winConfig->pixelFormatIndex);

    /*
       Normally, we can just use the the pixelFormatIndex corresponding
       to the fbconfig which has been specified by the client
     */

    if (!
        ((bppOverride &&
          (bppOverride !=
           (config->redBits + config->greenBits + config->blueBits)))
         || ((config->drawableType & drawableTypeOverride) == 0))) {
        if (!SetPixelFormat(hdc, winConfig->pixelFormatIndex, NULL)) {
            ErrorF("SetPixelFormat error: %s\n", glxWinErrorMessage());
            return FALSE;
        }

        return TRUE;
    }

    /*
       However, in certain special cases this pixel format will be incompatible with the
       use we are going to put it to, so we need to re-evaluate the pixel format to use:

       1) When PFD_DRAW_TO_BITMAP is set, ChoosePixelFormat() always returns a format with
       the cColorBits we asked for, so we need to ensure it matches the bpp of the bitmap

       2) Applications may assume that visuals selected with glXChooseVisual() work with
       pixmap drawables (there is no attribute to explicitly query for pixmap drawable
       support as there is for glXChooseFBConfig())
       (it's arguable this is an error in the application, but we try to make it work)

       pixmap rendering is always slow for us, so we don't want to choose those visuals
       by default, but if the actual drawable type we're trying to select the context
       on (drawableTypeOverride) isn't supported by the selected fbConfig, reconsider
       and see if we can find a suitable one...
     */
    ErrorF
        ("glxWinSetPixelFormat: having second thoughts: cColorbits %d, bppOveride %d; config->drawableType %d, drawableTypeOverride %d\n",
         (config->redBits + config->greenBits + config->blueBits), bppOverride,
         config->drawableType, drawableTypeOverride);

    if (!winScreen->has_WGL_ARB_pixel_format) {
        PIXELFORMATDESCRIPTOR pfd;
        int pixelFormat;

        /* convert fbConfig to PFD */
        if (fbConfigToPixelFormat(gc->base.config, &pfd, drawableTypeOverride)) {
            ErrorF("glxWinSetPixelFormat: fbConfigToPixelFormat failed\n");
            return FALSE;
        }

        if (glxWinDebugSettings.dumpPFD)
            pfdOut(&pfd);

        if (bppOverride) {
            GLWIN_DEBUG_MSG("glxWinSetPixelFormat: Forcing bpp from %d to %d\n",
                            pfd.cColorBits, bppOverride);
            pfd.cColorBits = bppOverride;
        }

        pixelFormat = ChoosePixelFormat(hdc, &pfd);
        if (pixelFormat == 0) {
            ErrorF("ChoosePixelFormat error: %s\n", glxWinErrorMessage());
            return FALSE;
        }

        GLWIN_DEBUG_MSG("ChoosePixelFormat: chose pixelFormatIndex %d",
                        pixelFormat);
        ErrorF
            ("ChoosePixelFormat: chose pixelFormatIndex %d (rather than %d as originally planned)\n",
             pixelFormat, winConfig->pixelFormatIndex);

        if (!SetPixelFormat(hdc, pixelFormat, &pfd)) {
            ErrorF("SetPixelFormat error: %s\n", glxWinErrorMessage());
            return FALSE;
        }
    }
    else {
        int pixelFormat =
            fbConfigToPixelFormatIndex(hdc, gc->base.config,
                                       drawableTypeOverride, winScreen);
        if (pixelFormat == 0) {
            return FALSE;
        }

        GLWIN_DEBUG_MSG("wglChoosePixelFormat: chose pixelFormatIndex %d",
                        pixelFormat);
        ErrorF
            ("wglChoosePixelFormat: chose pixelFormatIndex %d (rather than %d as originally planned)\n",
             pixelFormat, winConfig->pixelFormatIndex);

        if (!SetPixelFormat(hdc, pixelFormat, NULL)) {
            ErrorF("SetPixelFormat error: %s\n", glxWinErrorMessage());
            return FALSE;
        }
    }

    return TRUE;
}

static HDC
glxWinMakeDC(__GLXWinContext * gc, __GLXWinDrawable * draw, HDC * hdc,
             HWND * hwnd)
{
    *hdc = NULL;
    *hwnd = NULL;

    if (draw == NULL) {
        GLWIN_TRACE_MSG("No drawable for context %p (native ctx %p)", gc,
                        gc->ctx);
        return NULL;
    }

    switch (draw->base.type) {
    case GLX_DRAWABLE_WINDOW:
    {
        WindowPtr pWin;

        pWin = (WindowPtr) draw->base.pDraw;
        if (pWin == NULL) {
            GLWIN_TRACE_MSG("for drawable %p, no WindowPtr", pWin);
            return NULL;
        }

        *hwnd = winGetWindowInfo(pWin);

        if (*hwnd == NULL) {
            ErrorF("No HWND error: %s\n", glxWinErrorMessage());
            return NULL;
        }

        *hdc = GetDC(*hwnd);

        if (*hdc == NULL)
            ErrorF("GetDC error: %s\n", glxWinErrorMessage());

        /* Check if the hwnd has changed... */
        if (*hwnd != gc->hwnd) {
            if (glxWinDebugSettings.enableTrace)
                GLWIN_DEBUG_HWND(*hwnd);

            GLWIN_TRACE_MSG
                ("for context %p (native ctx %p), hWnd changed from %p to %p",
                 gc, gc->ctx, gc->hwnd, *hwnd);
            gc->hwnd = *hwnd;

            /* We must select a pixelformat, but SetPixelFormat can only be called once for a window... */
            if (!glxWinSetPixelFormat(gc, *hdc, 0, GLX_WINDOW_BIT)) {
                ErrorF("glxWinSetPixelFormat error: %s\n",
                       glxWinErrorMessage());
                ReleaseDC(*hwnd, *hdc);
                *hdc = NULL;
                return NULL;
            }
        }
    }
        break;

    case GLX_DRAWABLE_PBUFFER:
    {
        *hdc = wglGetPbufferDCARBWrapper(draw->hPbuffer);

        if (*hdc == NULL)
            ErrorF("GetDC (pbuffer) error: %s\n", glxWinErrorMessage());
    }
        break;

    case GLX_DRAWABLE_PIXMAP:
    {
        *hdc = draw->dibDC;
    }
        break;

    default:
    {
        ErrorF("glxWinMakeDC: tried to makeDC for unhandled drawable type %d\n",
               draw->base.type);
    }
    }

    if (glxWinDebugSettings.dumpDC)
        GLWIN_DEBUG_MSG("Got HDC %p", *hdc);

    return *hdc;
}

static void
glxWinReleaseDC(HWND hwnd, HDC hdc, __GLXWinDrawable * draw)
{
    switch (draw->base.type) {
    case GLX_DRAWABLE_WINDOW:
    {
        ReleaseDC(hwnd, hdc);
    }
        break;

    case GLX_DRAWABLE_PBUFFER:
    {
        if (!wglReleasePbufferDCARBWrapper(draw->hPbuffer, hdc)) {
            ErrorF("wglReleasePbufferDCARB error: %s\n", glxWinErrorMessage());
        }
    }
        break;

    case GLX_DRAWABLE_PIXMAP:
    {
        // don't release DC, the memory DC lives as long as the bitmap

        // We must ensure that all GDI drawing into the bitmap has completed
        // in case we subsequently access the bits from it
        GdiFlush();
    }
        break;

    default:
    {
        ErrorF
            ("glxWinReleaseDC: tried to releaseDC for unhandled drawable type %d\n",
             draw->base.type);
    }
    }
}

static void
glxWinDeferredCreateContext(__GLXWinContext * gc, __GLXWinDrawable * draw)
{
    HDC dc;
    HWND hwnd;

    GLWIN_DEBUG_MSG
        ("glxWinDeferredCreateContext: attach context %p to drawable %p", gc,
         draw);

    switch (draw->base.type) {
    case GLX_DRAWABLE_WINDOW:
    {
        WindowPtr pWin = (WindowPtr) draw->base.pDraw;

        if (!(gc->base.config->drawableType & GLX_WINDOW_BIT)) {
            ErrorF
                ("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_WINDOW_BIT to a GLX_DRAWABLE_WINDOW drawable\n");
        }

        if (pWin == NULL) {
            GLWIN_DEBUG_MSG("Deferring until X window is created");
            return;
        }

        GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: pWin %p", pWin);

        if (winGetWindowInfo(pWin) == NULL) {
            GLWIN_DEBUG_MSG("Deferring until native window is created");
            return;
        }
    }
        break;

    case GLX_DRAWABLE_PBUFFER:
    {
        if (draw->hPbuffer == NULL) {
            __GLXscreen *screen;
            glxWinScreen *winScreen;
            int pixelFormat;

            // XXX: which DC are we supposed to use???
            HDC screenDC = GetDC(NULL);

            if (!(gc->base.config->drawableType & GLX_PBUFFER_BIT)) {
                ErrorF
                    ("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_PBUFFER_BIT to a GLX_DRAWABLE_PBUFFER drawable\n");
            }

            screen = gc->base.pGlxScreen;
            winScreen = (glxWinScreen *) screen;

            pixelFormat =
                fbConfigToPixelFormatIndex(screenDC, gc->base.config,
                                           GLX_PBUFFER_BIT, winScreen);
            if (pixelFormat == 0) {
                return;
            }

            draw->hPbuffer =
                wglCreatePbufferARBWrapper(screenDC, pixelFormat,
                                           draw->base.pDraw->width,
                                           draw->base.pDraw->height, NULL);
            ReleaseDC(NULL, screenDC);

            if (draw->hPbuffer == NULL) {
                ErrorF("wglCreatePbufferARBWrapper error: %s\n",
                       glxWinErrorMessage());
                return;
            }

            GLWIN_DEBUG_MSG
                ("glxWinDeferredCreateContext: pBuffer %p created for drawable %p",
                 draw->hPbuffer, draw);
        }
    }
        break;

    case GLX_DRAWABLE_PIXMAP:
    {
        if (draw->dibDC == NULL) {
            BITMAPINFOHEADER bmpHeader;
            void *pBits;

            memset(&bmpHeader, 0, sizeof(BITMAPINFOHEADER));
            bmpHeader.biSize = sizeof(BITMAPINFOHEADER);
            bmpHeader.biWidth = draw->base.pDraw->width;
            bmpHeader.biHeight = draw->base.pDraw->height;
            bmpHeader.biPlanes = 1;
            bmpHeader.biBitCount = draw->base.pDraw->bitsPerPixel;
            bmpHeader.biCompression = BI_RGB;

            if (!(gc->base.config->drawableType & GLX_PIXMAP_BIT)) {
                ErrorF
                    ("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_PIXMAP_BIT to a GLX_DRAWABLE_PIXMAP drawable\n");
            }

            draw->dibDC = CreateCompatibleDC(NULL);
            if (draw->dibDC == NULL) {
                ErrorF("CreateCompatibleDC error: %s\n", glxWinErrorMessage());
                return;
            }

            draw->hDIB =
                CreateDIBSection(draw->dibDC, (BITMAPINFO *) &bmpHeader,
                                 DIB_RGB_COLORS, &pBits, 0, 0);
            if (draw->dibDC == NULL) {
                ErrorF("CreateDIBSection error: %s\n", glxWinErrorMessage());
                return;
            }

            // XXX: CreateDIBSection insists on allocating the bitmap memory for us, so we're going to
            // need some jiggery pokery to point the underlying X Drawable's bitmap at the same set of bits
            // so that they can be read with XGetImage as well as glReadPixels, assuming the formats are
            // even compatible ...
            draw->pOldBits = ((PixmapPtr) draw->base.pDraw)->devPrivate.ptr;
            ((PixmapPtr) draw->base.pDraw)->devPrivate.ptr = pBits;

            // Select the DIB into the DC
            draw->hOldDIB = SelectObject(draw->dibDC, draw->hDIB);
            if (!draw->hOldDIB) {
                ErrorF("SelectObject error: %s\n", glxWinErrorMessage());
            }

            // Set the pixel format of the bitmap
            glxWinSetPixelFormat(gc, draw->dibDC,
                                 draw->base.pDraw->bitsPerPixel,
                                 GLX_PIXMAP_BIT);

            GLWIN_DEBUG_MSG
                ("glxWinDeferredCreateContext: DIB bitmap %p created for drawable %p",
                 draw->hDIB, draw);
        }
    }
        break;

    default:
    {
        ErrorF
            ("glxWinDeferredCreateContext: tried to attach unhandled drawable type %d\n",
             draw->base.type);
        return;
    }
    }

    dc = glxWinMakeDC(gc, draw, &dc, &hwnd);
    gc->ctx = wglCreateContext(dc);
    glxWinReleaseDC(hwnd, dc, draw);

    if (gc->ctx == NULL) {
        ErrorF("wglCreateContext error: %s\n", glxWinErrorMessage());
        return;
    }

    GLWIN_DEBUG_MSG
        ("glxWinDeferredCreateContext: attached context %p to native context %p drawable %p",
         gc, gc->ctx, draw);

    // if the native context was created successfully, shareLists if needed
    if (gc->ctx && gc->shareContext) {
        GLWIN_DEBUG_MSG
            ("glxWinCreateContextReal shareLists with context %p (native ctx %p)",
             gc->shareContext, gc->shareContext->ctx);

        if (!wglShareLists(gc->shareContext->ctx, gc->ctx)) {
            ErrorF("wglShareLists error: %s\n", glxWinErrorMessage());
        }
    }
}

/* ---------------------------------------------------------------------- */
/*
 * Context functions
 */

/* Context manipulation routines should return TRUE on success, FALSE on failure */
static int
glxWinContextMakeCurrent(__GLXcontext * base)
{
    __GLXWinContext *gc = (__GLXWinContext *) base;
    BOOL ret;
    HDC drawDC;
    HDC readDC = NULL;
    __GLXdrawable *drawPriv;
    __GLXdrawable *readPriv = NULL;
    HWND hDrawWnd;
    HWND hReadWnd;

    GLWIN_TRACE_MSG("glxWinContextMakeCurrent context %p (native ctx %p)", gc,
                    gc->ctx);

    /* Keep a note of the last active context in the drawable */
    drawPriv = gc->base.drawPriv;
    ((__GLXWinDrawable *) drawPriv)->drawContext = gc;

    if (gc->ctx == NULL) {
        glxWinDeferredCreateContext(gc, (__GLXWinDrawable *) drawPriv);
    }

    if (gc->ctx == NULL) {
        ErrorF("glxWinContextMakeCurrent: Native context is NULL\n");
        return FALSE;
    }

    drawDC =
        glxWinMakeDC(gc, (__GLXWinDrawable *) drawPriv, &drawDC, &hDrawWnd);
    if (drawDC == NULL) {
        ErrorF("glxWinMakeDC failed for drawDC\n");
        return FALSE;
    }

    if ((gc->base.readPriv != NULL) && (gc->base.readPriv != gc->base.drawPriv)) {
        // XXX: should only occur with WGL_ARB_make_current_read
        /*
           If there is a separate read drawable, create a separate read DC, and
           use the wglMakeContextCurrent extension to make the context current drawing
           to one DC and reading from the other
         */
        readPriv = gc->base.readPriv;
        readDC =
            glxWinMakeDC(gc, (__GLXWinDrawable *) readPriv, &readDC, &hReadWnd);
        if (readDC == NULL) {
            ErrorF("glxWinMakeDC failed for readDC\n");
            glxWinReleaseDC(hDrawWnd, drawDC, (__GLXWinDrawable *) drawPriv);
            return FALSE;
        }

        ret = wglMakeContextCurrentARBWrapper(drawDC, readDC, gc->ctx);
        if (!ret) {
            ErrorF("wglMakeContextCurrentARBWrapper error: %s\n",
                   glxWinErrorMessage());
        }
    }
    else {
        /* Otherwise, just use wglMakeCurrent */
        ret = wglMakeCurrent(drawDC, gc->ctx);
        if (!ret) {
            ErrorF("wglMakeCurrent error: %s\n", glxWinErrorMessage());
        }
    }

    // apparently make current could fail if the context is current in a different thread,
    // but that shouldn't be able to happen in the current server...

    glxWinReleaseDC(hDrawWnd, drawDC, (__GLXWinDrawable *) drawPriv);
    if (readDC)
        glxWinReleaseDC(hReadWnd, readDC, (__GLXWinDrawable *) readPriv);

    return ret;
}

static int
glxWinContextLoseCurrent(__GLXcontext * base)
{
    BOOL ret;
    __GLXWinContext *gc = (__GLXWinContext *) base;

    GLWIN_TRACE_MSG("glxWinContextLoseCurrent context %p (native ctx %p)", gc,
                    gc->ctx);

    /*
       An error seems to be reported if we try to make no context current
       if there is already no current context, so avoid doing that...
     */
    if (wglGetCurrentContext() != NULL) {
        ret = wglMakeCurrent(NULL, NULL);       /* We don't need a DC when setting no current context */
        if (!ret)
            ErrorF("glxWinContextLoseCurrent error: %s\n",
                   glxWinErrorMessage());
    }

    return TRUE;
}

static int
glxWinContextCopy(__GLXcontext * dst_base, __GLXcontext * src_base,
                  unsigned long mask)
{
    __GLXWinContext *dst = (__GLXWinContext *) dst_base;
    __GLXWinContext *src = (__GLXWinContext *) src_base;
    BOOL ret;

    GLWIN_DEBUG_MSG("glxWinContextCopy");

    ret = wglCopyContext(src->ctx, dst->ctx, mask);
    if (!ret) {
        ErrorF("wglCopyContext error: %s\n", glxWinErrorMessage());
    }

    return ret;
}

static void
glxWinContextDestroy(__GLXcontext * base)
{
    __GLXWinContext *gc = (__GLXWinContext *) base;

    if (gc != NULL) {
        GLWIN_DEBUG_MSG("GLXcontext %p destroyed (native ctx %p)", base,
                        gc->ctx);

        if (gc->ctx) {
            /* It's bad style to delete the context while it's still current */
            if (wglGetCurrentContext() == gc->ctx) {
                wglMakeCurrent(NULL, NULL);
            }

            {
                BOOL ret = wglDeleteContext(gc->ctx);

                if (!ret)
                    ErrorF("wglDeleteContext error: %s\n",
                           glxWinErrorMessage());
            }

            gc->ctx = NULL;
        }

        free(gc);
    }
}

static __GLXcontext *
glxWinCreateContext(__GLXscreen * screen,
                    __GLXconfig * modes, __GLXcontext * baseShareContext,
                    unsigned num_attribs, const uint32_t * attribs, int *error)
{
    __GLXWinContext *context;
    __GLXWinContext *shareContext = (__GLXWinContext *) baseShareContext;

    static __GLXtextureFromPixmap glxWinTextureFromPixmap = {
        glxWinBindTexImage,
        glxWinReleaseTexImage
    };

    context = calloc(1, sizeof(__GLXWinContext));

    if (!context)
        return NULL;

    memset(context, 0, sizeof *context);
    context->base.destroy = glxWinContextDestroy;
    context->base.makeCurrent = glxWinContextMakeCurrent;
    context->base.loseCurrent = glxWinContextLoseCurrent;
    context->base.copy = glxWinContextCopy;
    context->base.textureFromPixmap = &glxWinTextureFromPixmap;
    context->base.config = modes;
    context->base.pGlxScreen = screen;

    // actual native GL context creation is deferred until attach()
    context->ctx = NULL;
    context->shareContext = shareContext;

    GLWIN_DEBUG_MSG("GLXcontext %p created", context);

    return &(context->base);
}

/* ---------------------------------------------------------------------- */
/*
 * Utility functions
 */

static int
GetShift(int mask)
{
    int shift = 0;

    while ((mask &1) == 0) {
        shift++;
        mask >>=1;
    }
    return shift;
}

static int
fbConfigToPixelFormat(__GLXconfig * mode, PIXELFORMATDESCRIPTOR * pfdret,
                      int drawableTypeOverride)
{
    PIXELFORMATDESCRIPTOR pfd = {
        sizeof(PIXELFORMATDESCRIPTOR),  /* size of this pfd */
        1,                      /* version number */
        PFD_SUPPORT_OPENGL,     /* support OpenGL */
        PFD_TYPE_RGBA,          /* RGBA type */
        24,                     /* 24-bit color depth */
        0, 0, 0, 0, 0, 0,       /* color bits ignored */
        0,                      /* no alpha buffer */
        0,                      /* shift bit ignored */
        0,                      /* no accumulation buffer */
        0, 0, 0, 0,             /* accum bits ignored */
        32,                     /* 32-bit z-buffer */
        0,                      /* no stencil buffer */
        0,                      /* no auxiliary buffer */
        PFD_MAIN_PLANE,         /* main layer */
        0,                      /* reserved */
        0, 0, 0                 /* layer masks ignored */
    };

    if ((mode->drawableType | drawableTypeOverride) & GLX_WINDOW_BIT)
        pfd.dwFlags |= PFD_DRAW_TO_WINDOW;      /* support window */

    if ((mode->drawableType | drawableTypeOverride) & GLX_PIXMAP_BIT)
        pfd.dwFlags |= (PFD_DRAW_TO_BITMAP | PFD_SUPPORT_GDI);  /* supports software rendering to bitmap */

    if (mode->stereoMode) {
        pfd.dwFlags |= PFD_STEREO;
    }
    if (mode->doubleBufferMode) {
        pfd.dwFlags |= PFD_DOUBLEBUFFER;
    }

    pfd.cColorBits = mode->redBits + mode->greenBits + mode->blueBits;
    pfd.cRedBits = mode->redBits;
    pfd.cRedShift = GetShift(mode->redMask);
    pfd.cGreenBits = mode->greenBits;
    pfd.cGreenShift = GetShift(mode->greenMask);
    pfd.cBlueBits = mode->blueBits;
    pfd.cBlueShift = GetShift(mode->blueMask);
    pfd.cAlphaBits = mode->alphaBits;
    pfd.cAlphaShift = GetShift(mode->alphaMask);

    if (mode->visualType == GLX_TRUE_COLOR) {
        pfd.iPixelType = PFD_TYPE_RGBA;
        pfd.dwVisibleMask =
            (pfd.cRedBits << pfd.cRedShift) | (pfd.cGreenBits << pfd.cGreenShift) |
            (pfd.cBlueBits << pfd.cBlueShift) | (pfd.cAlphaBits << pfd.cAlphaShift);
    }
    else {
        pfd.iPixelType = PFD_TYPE_COLORINDEX;
        pfd.dwVisibleMask = mode->transparentIndex;
    }

    pfd.cAccumBits =
        mode->accumRedBits + mode->accumGreenBits + mode->accumBlueBits +
        mode->accumAlphaBits;
    pfd.cAccumRedBits = mode->accumRedBits;
    pfd.cAccumGreenBits = mode->accumGreenBits;
    pfd.cAccumBlueBits = mode->accumBlueBits;
    pfd.cAccumAlphaBits = mode->accumAlphaBits;

    pfd.cDepthBits = mode->depthBits;
    pfd.cStencilBits = mode->stencilBits;
    pfd.cAuxBuffers = mode->numAuxBuffers;

    /* mode->level ? */

    *pfdret = pfd;

    return 0;
}

#define SET_ATTR_VALUE(attr, value) { attribList[i++] = attr; attribList[i++] = value; assert(i < NUM_ELEMENTS(attribList)); }

static int
fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig * mode,
                           int drawableTypeOverride, glxWinScreen * winScreen)
{
    UINT numFormats;
    unsigned int i = 0;

    /* convert fbConfig to attr-value list  */
    int attribList[60];

    SET_ATTR_VALUE(WGL_SUPPORT_OPENGL_ARB, TRUE);
    SET_ATTR_VALUE(WGL_PIXEL_TYPE_ARB,
                   (mode->visualType ==
                    GLX_TRUE_COLOR) ? WGL_TYPE_RGBA_ARB :
                   WGL_TYPE_COLORINDEX_ARB);
    SET_ATTR_VALUE(WGL_COLOR_BITS_ARB,
                   (mode->visualType ==
                    GLX_TRUE_COLOR) ? mode->rgbBits : mode->indexBits);
    SET_ATTR_VALUE(WGL_RED_BITS_ARB, mode->redBits);
    SET_ATTR_VALUE(WGL_GREEN_BITS_ARB, mode->greenBits);
    SET_ATTR_VALUE(WGL_BLUE_BITS_ARB, mode->blueBits);
    SET_ATTR_VALUE(WGL_ALPHA_BITS_ARB, mode->alphaBits);
    SET_ATTR_VALUE(WGL_ACCUM_RED_BITS_ARB, mode->accumRedBits);
    SET_ATTR_VALUE(WGL_ACCUM_GREEN_BITS_ARB, mode->accumGreenBits);
    SET_ATTR_VALUE(WGL_ACCUM_BLUE_BITS_ARB, mode->accumBlueBits);
    SET_ATTR_VALUE(WGL_ACCUM_ALPHA_BITS_ARB, mode->accumAlphaBits);
    SET_ATTR_VALUE(WGL_DEPTH_BITS_ARB, mode->depthBits);
    SET_ATTR_VALUE(WGL_STENCIL_BITS_ARB, mode->stencilBits);
    SET_ATTR_VALUE(WGL_AUX_BUFFERS_ARB, mode->numAuxBuffers);

    if (mode->doubleBufferMode)
        SET_ATTR_VALUE(WGL_DOUBLE_BUFFER_ARB, TRUE);

    if (mode->stereoMode)
        SET_ATTR_VALUE(WGL_STEREO_ARB, TRUE);

    // Some attributes are only added to the list if the value requested is not 'don't care', as exactly matching that is daft..
    if (mode->swapMethod == GLX_SWAP_EXCHANGE_OML)
        SET_ATTR_VALUE(WGL_SWAP_METHOD_ARB, WGL_SWAP_EXCHANGE_ARB);

    if (mode->swapMethod == GLX_SWAP_COPY_OML)
        SET_ATTR_VALUE(WGL_SWAP_METHOD_ARB, WGL_SWAP_COPY_ARB);

    // XXX: this should probably be the other way around, but that messes up drawableTypeOverride
    if (mode->visualRating == GLX_SLOW_VISUAL_EXT)
        SET_ATTR_VALUE(WGL_ACCELERATION_ARB, WGL_NO_ACCELERATION_ARB);

    // must support all the drawable types the mode supports
    if ((mode->drawableType | drawableTypeOverride) & GLX_WINDOW_BIT)
        SET_ATTR_VALUE(WGL_DRAW_TO_WINDOW_ARB, TRUE);

    // XXX: this is a horrible hacky heuristic, in fact this whole drawableTypeOverride thing is a bad idea
    // try to avoid asking for formats which don't exist (by not asking for all when adjusting the config to include the drawableTypeOverride)
    if (drawableTypeOverride == GLX_WINDOW_BIT) {
        if (mode->drawableType & GLX_PIXMAP_BIT)
            SET_ATTR_VALUE(WGL_DRAW_TO_BITMAP_ARB, TRUE);

        if (mode->drawableType & GLX_PBUFFER_BIT)
            if (winScreen->has_WGL_ARB_pbuffer)
                SET_ATTR_VALUE(WGL_DRAW_TO_PBUFFER_ARB, TRUE);
    }
    else {
        if (drawableTypeOverride & GLX_PIXMAP_BIT)
            SET_ATTR_VALUE(WGL_DRAW_TO_BITMAP_ARB, TRUE);

        if (drawableTypeOverride & GLX_PBUFFER_BIT)
            if (winScreen->has_WGL_ARB_pbuffer)
                SET_ATTR_VALUE(WGL_DRAW_TO_PBUFFER_ARB, TRUE);
    }

    SET_ATTR_VALUE(0, 0);       // terminator

    /* choose the first match */
    {
        int pixelFormatIndex;

        if (!wglChoosePixelFormatARBWrapper
            (hdc, attribList, NULL, 1, &pixelFormatIndex, &numFormats)) {
            ErrorF("wglChoosePixelFormat error: %s\n", glxWinErrorMessage());
        }
        else {
            if (numFormats > 0) {
                GLWIN_DEBUG_MSG
                    ("wglChoosePixelFormat: chose pixelFormatIndex %d)",
                     pixelFormatIndex);
                return pixelFormatIndex;
            }
            else
                ErrorF("wglChoosePixelFormat couldn't decide\n");
        }
    }

    return 0;
}

/* ---------------------------------------------------------------------- */

#define BITS_AND_SHIFT_TO_MASK(bits,mask) (((1<<(bits))-1) << (mask))

//
// Create the GLXconfigs using DescribePixelFormat()
//
static void
glxWinCreateConfigs(HDC hdc, glxWinScreen * screen)
{
    GLXWinConfig *c, *result, *prev = NULL;
    int numConfigs = 0;
    int i = 0;
    int n = 0;
    PIXELFORMATDESCRIPTOR pfd;

    GLWIN_DEBUG_MSG("glxWinCreateConfigs");

    screen->base.numFBConfigs = 0;
    screen->base.fbconfigs = NULL;

    // get the number of pixelformats
    numConfigs =
        DescribePixelFormat(hdc, 1, sizeof(PIXELFORMATDESCRIPTOR), NULL);
    LogMessage(X_INFO, "%d pixel formats reported by DescribePixelFormat\n",
               numConfigs);

    /* alloc */
    result = malloc(sizeof(GLXWinConfig) * numConfigs);

    if (NULL == result) {
        return;
    }

    memset(result, 0, sizeof(GLXWinConfig) * numConfigs);
    n = 0;

    /* fill in configs */
    for (i = 0; i < numConfigs; i++) {
        int rc;

        c = &(result[i]);
        c->base.next = NULL;
        c->pixelFormatIndex = i + 1;

        rc = DescribePixelFormat(hdc, i + 1, sizeof(PIXELFORMATDESCRIPTOR),
                                 &pfd);

        if (!rc) {
            ErrorF("DescribePixelFormat failed for index %d, error %s\n", i + 1,
                   glxWinErrorMessage());
            break;
        }

        if (glxWinDebugSettings.dumpPFD)
            pfdOut(&pfd);

        if (!(pfd.dwFlags & (PFD_DRAW_TO_WINDOW | PFD_DRAW_TO_BITMAP)) ||
            !(pfd.dwFlags & PFD_SUPPORT_OPENGL)) {
            GLWIN_DEBUG_MSG
                ("pixelFormat %d has unsuitable flags 0x%08x, skipping", i + 1,
                 (unsigned int)pfd.dwFlags);
            continue;
        }

        c->base.doubleBufferMode =
            (pfd.dwFlags & PFD_DOUBLEBUFFER) ? GL_TRUE : GL_FALSE;
        c->base.stereoMode = (pfd.dwFlags & PFD_STEREO) ? GL_TRUE : GL_FALSE;

        c->base.redBits = pfd.cRedBits;
        c->base.greenBits = pfd.cGreenBits;
        c->base.blueBits = pfd.cBlueBits;
        c->base.alphaBits = pfd.cAlphaBits;

        c->base.redMask = BITS_AND_SHIFT_TO_MASK(pfd.cRedBits, pfd.cRedShift);
        c->base.greenMask =
            BITS_AND_SHIFT_TO_MASK(pfd.cGreenBits, pfd.cGreenShift);
        c->base.blueMask =
            BITS_AND_SHIFT_TO_MASK(pfd.cBlueBits, pfd.cBlueShift);
        c->base.alphaMask =
            BITS_AND_SHIFT_TO_MASK(pfd.cAlphaBits, pfd.cAlphaShift);

        c->base.rgbBits = pfd.cColorBits;

        if (pfd.iPixelType == PFD_TYPE_COLORINDEX) {
            c->base.indexBits = pfd.cColorBits;
        }
        else {
            c->base.indexBits = 0;
        }

        c->base.accumRedBits = pfd.cAccumRedBits;
        c->base.accumGreenBits = pfd.cAccumGreenBits;
        c->base.accumBlueBits = pfd.cAccumBlueBits;
        c->base.accumAlphaBits = pfd.cAccumAlphaBits;
        //  pfd.cAccumBits;

        c->base.depthBits = pfd.cDepthBits;
        c->base.stencilBits = pfd.cStencilBits;
        c->base.numAuxBuffers = pfd.cAuxBuffers;

        // pfd.iLayerType; // ignored
        c->base.level = 0;
        // pfd.dwLayerMask; // ignored
        // pfd.dwDamageMask;  // ignored

        c->base.visualID = -1;  // will be set by __glXScreenInit()

        /* EXT_visual_rating / GLX 1.2 */
        if (pfd.dwFlags & PFD_GENERIC_FORMAT) {
            c->base.visualRating = GLX_SLOW_VISUAL_EXT;
        }
        else {
            // PFD_GENERIC_ACCELERATED is not considered, so this may be MCD or ICD acclerated...
            c->base.visualRating = GLX_NONE_EXT;
        }

        /* EXT_visual_info / GLX 1.2 */
        if (pfd.iPixelType == PFD_TYPE_COLORINDEX) {
            c->base.visualType = GLX_STATIC_COLOR;
            c->base.transparentRed = GLX_NONE;
            c->base.transparentGreen = GLX_NONE;
            c->base.transparentBlue = GLX_NONE;
            c->base.transparentAlpha = GLX_NONE;
            c->base.transparentIndex = pfd.dwVisibleMask;
            c->base.transparentPixel = GLX_TRANSPARENT_INDEX;
        }
        else {
            c->base.visualType = GLX_TRUE_COLOR;
            c->base.transparentRed =
                (pfd.dwVisibleMask & c->base.redMask) >> pfd.cRedShift;
            c->base.transparentGreen =
                (pfd.dwVisibleMask & c->base.greenMask) >> pfd.cGreenShift;
            c->base.transparentBlue =
                (pfd.dwVisibleMask & c->base.blueMask) >> pfd.cBlueShift;
            c->base.transparentAlpha =
                (pfd.dwVisibleMask & c->base.alphaMask) >> pfd.cAlphaShift;
            c->base.transparentIndex = GLX_NONE;
            c->base.transparentPixel = GLX_TRANSPARENT_RGB;
        }

        /* ARB_multisample / SGIS_multisample */
        c->base.sampleBuffers = 0;
        c->base.samples = 0;

        /* SGIX_fbconfig / GLX 1.3 */
        c->base.drawableType =
            (((pfd.dwFlags & PFD_DRAW_TO_WINDOW) ? GLX_WINDOW_BIT : 0)
             | ((pfd.dwFlags & PFD_DRAW_TO_BITMAP) ? GLX_PIXMAP_BIT : 0));

        if (pfd.iPixelType == PFD_TYPE_COLORINDEX) {
            c->base.renderType = GLX_RGBA_BIT | GLX_COLOR_INDEX_BIT;
        }
        else {
            c->base.renderType = GLX_RGBA_BIT;
        }

        c->base.xRenderable = GL_TRUE;
        c->base.fbconfigID = -1;        // will be set by __glXScreenInit()

        /* SGIX_pbuffer / GLX 1.3 */
        // XXX: How can we find these values out ???
        c->base.maxPbufferWidth = -1;
        c->base.maxPbufferHeight = -1;
        c->base.maxPbufferPixels = -1;
        c->base.optimalPbufferWidth = 0;        // there is no optimal value
        c->base.optimalPbufferHeight = 0;

        /* SGIX_visual_select_group */
        // arrange for visuals with the best acceleration to be preferred in selection
        switch (pfd.dwFlags & (PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED)) {
        case 0:
            c->base.visualSelectGroup = 2;
            break;

        case PFD_GENERIC_ACCELERATED:
            c->base.visualSelectGroup = 1;
            break;

        case PFD_GENERIC_FORMAT:
            c->base.visualSelectGroup = 0;
            break;

        default:
            ;
            // "can't happen"
        }

        /* OML_swap_method */
        if (pfd.dwFlags & PFD_SWAP_EXCHANGE)
            c->base.swapMethod = GLX_SWAP_EXCHANGE_OML;
        else if (pfd.dwFlags & PFD_SWAP_COPY)
            c->base.swapMethod = GLX_SWAP_COPY_OML;
        else
            c->base.swapMethod = GLX_SWAP_UNDEFINED_OML;

        /* EXT_texture_from_pixmap */
        c->base.bindToTextureRgb = -1;
        c->base.bindToTextureRgba = -1;
        c->base.bindToMipmapTexture = -1;
        c->base.bindToTextureTargets = -1;
        c->base.yInverted = -1;
        c->base.sRGBCapable = 0;

        n++;

        // update previous config to point to this config
        if (prev)
            prev->base.next = &(c->base);

        prev = c;
    }

    GLWIN_DEBUG_MSG
        ("found %d pixelFormats suitable for conversion to fbConfigs", n);

    screen->base.numFBConfigs = n;
    screen->base.fbconfigs = &(result->base);
}

// helper function to access an attribute value from an attribute value array by attribute
static
    int
getAttrValue(const int attrs[], int values[], unsigned int num, int attr,
             int fallback)
{
    unsigned int i;

    for (i = 0; i < num; i++) {
        if (attrs[i] == attr) {
            GLWIN_TRACE_MSG("getAttrValue attr 0x%x, value %d", attr,
                            values[i]);
            return values[i];
        }
    }

    ErrorF("getAttrValue failed to find attr 0x%x, using default value %d\n",
           attr, fallback);
    return fallback;
}

//
// Create the GLXconfigs using wglGetPixelFormatAttribfvARB() extension
//
static void
glxWinCreateConfigsExt(HDC hdc, glxWinScreen * screen)
{
    GLXWinConfig *c, *result, *prev = NULL;
    int i = 0;
    int n = 0;

    const int attr = WGL_NUMBER_PIXEL_FORMATS_ARB;
    int numConfigs;

    int attrs[50];
    unsigned int num_attrs = 0;

    GLWIN_DEBUG_MSG("glxWinCreateConfigsExt");

    screen->base.numFBConfigs = 0;
    screen->base.fbconfigs = NULL;

    if (!wglGetPixelFormatAttribivARBWrapper(hdc, 0, 0, 1, &attr, &numConfigs)) {
        ErrorF
            ("wglGetPixelFormatAttribivARB failed for WGL_NUMBER_PIXEL_FORMATS_ARB: %s\n",
             glxWinErrorMessage());
        return;
    }

    LogMessage(X_INFO,
               "%d pixel formats reported by wglGetPixelFormatAttribivARB\n",
               numConfigs);

    /* alloc */
    result = malloc(sizeof(GLXWinConfig) * numConfigs);

    if (NULL == result) {
        return;
    }

    memset(result, 0, sizeof(GLXWinConfig) * numConfigs);
    n = 0;

#define ADD_ATTR(a) { attrs[num_attrs++] = a; assert(num_attrs < NUM_ELEMENTS(attrs)); }

    ADD_ATTR(WGL_DRAW_TO_WINDOW_ARB);
    ADD_ATTR(WGL_DRAW_TO_BITMAP_ARB);
    ADD_ATTR(WGL_ACCELERATION_ARB);
    ADD_ATTR(WGL_SWAP_LAYER_BUFFERS_ARB);
    ADD_ATTR(WGL_NUMBER_OVERLAYS_ARB);
    ADD_ATTR(WGL_NUMBER_UNDERLAYS_ARB);
    ADD_ATTR(WGL_TRANSPARENT_ARB);
    ADD_ATTR(WGL_TRANSPARENT_RED_VALUE_ARB);
    ADD_ATTR(WGL_TRANSPARENT_GREEN_VALUE_ARB);
    ADD_ATTR(WGL_TRANSPARENT_GREEN_VALUE_ARB);
    ADD_ATTR(WGL_TRANSPARENT_ALPHA_VALUE_ARB);
    ADD_ATTR(WGL_SUPPORT_OPENGL_ARB);
    ADD_ATTR(WGL_DOUBLE_BUFFER_ARB);
    ADD_ATTR(WGL_STEREO_ARB);
    ADD_ATTR(WGL_PIXEL_TYPE_ARB);
    ADD_ATTR(WGL_COLOR_BITS_ARB);
    ADD_ATTR(WGL_RED_BITS_ARB);
    ADD_ATTR(WGL_RED_SHIFT_ARB);
    ADD_ATTR(WGL_GREEN_BITS_ARB);
    ADD_ATTR(WGL_GREEN_SHIFT_ARB);
    ADD_ATTR(WGL_BLUE_BITS_ARB);
    ADD_ATTR(WGL_BLUE_SHIFT_ARB);
    ADD_ATTR(WGL_ALPHA_BITS_ARB);
    ADD_ATTR(WGL_ALPHA_SHIFT_ARB);
    ADD_ATTR(WGL_ACCUM_RED_BITS_ARB);
    ADD_ATTR(WGL_ACCUM_GREEN_BITS_ARB);
    ADD_ATTR(WGL_ACCUM_BLUE_BITS_ARB);
    ADD_ATTR(WGL_ACCUM_ALPHA_BITS_ARB);
    ADD_ATTR(WGL_DEPTH_BITS_ARB);
    ADD_ATTR(WGL_STENCIL_BITS_ARB);
    ADD_ATTR(WGL_AUX_BUFFERS_ARB);
    ADD_ATTR(WGL_SWAP_METHOD_ARB);

    if (screen->has_WGL_ARB_multisample) {
        // we may not query these attrs if WGL_ARB_multisample is not offered
        ADD_ATTR(WGL_SAMPLE_BUFFERS_ARB);
        ADD_ATTR(WGL_SAMPLES_ARB);
    }

    if (screen->has_WGL_ARB_render_texture) {
        // we may not query these attrs if WGL_ARB_render_texture is not offered
        ADD_ATTR(WGL_BIND_TO_TEXTURE_RGB_ARB);
        ADD_ATTR(WGL_BIND_TO_TEXTURE_RGBA_ARB);
    }

    if (screen->has_WGL_ARB_pbuffer) {
        // we may not query these attrs if WGL_ARB_pbuffer is not offered
        ADD_ATTR(WGL_DRAW_TO_PBUFFER_ARB);
        ADD_ATTR(WGL_MAX_PBUFFER_PIXELS_ARB);
        ADD_ATTR(WGL_MAX_PBUFFER_WIDTH_ARB);
        ADD_ATTR(WGL_MAX_PBUFFER_HEIGHT_ARB);
    }

    /* fill in configs */
    for (i = 0; i < numConfigs; i++) {
        int values[num_attrs];

        c = &(result[i]);
        c->base.next = NULL;
        c->pixelFormatIndex = i + 1;

        if (!wglGetPixelFormatAttribivARBWrapper
            (hdc, i + 1, 0, num_attrs, attrs, values)) {
            ErrorF
                ("wglGetPixelFormatAttribivARB failed for index %d, error %s\n",
                 i + 1, glxWinErrorMessage());
            break;
        }

#define ATTR_VALUE(a, d) getAttrValue(attrs, values, num_attrs, (a), (d))

        if (!ATTR_VALUE(WGL_SUPPORT_OPENGL_ARB, 0)) {
            GLWIN_DEBUG_MSG
                ("pixelFormat %d isn't WGL_SUPPORT_OPENGL_ARB, skipping",
                 i + 1);
            continue;
        }

        c->base.doubleBufferMode =
            ATTR_VALUE(WGL_DOUBLE_BUFFER_ARB, 0) ? GL_TRUE : GL_FALSE;
        c->base.stereoMode = ATTR_VALUE(WGL_STEREO_ARB, 0) ? GL_TRUE : GL_FALSE;

        c->base.redBits = ATTR_VALUE(WGL_RED_BITS_ARB, 0);
        c->base.greenBits = ATTR_VALUE(WGL_GREEN_BITS_ARB, 0);
        c->base.blueBits = ATTR_VALUE(WGL_BLUE_BITS_ARB, 0);
        c->base.alphaBits = ATTR_VALUE(WGL_ALPHA_BITS_ARB, 0);

        c->base.redMask =
            BITS_AND_SHIFT_TO_MASK(c->base.redBits,
                                   ATTR_VALUE(WGL_RED_SHIFT_ARB, 0));
        c->base.greenMask =
            BITS_AND_SHIFT_TO_MASK(c->base.greenBits,
                                   ATTR_VALUE(WGL_GREEN_SHIFT_ARB, 0));
        c->base.blueMask =
            BITS_AND_SHIFT_TO_MASK(c->base.blueBits,
                                   ATTR_VALUE(WGL_BLUE_SHIFT_ARB, 0));
        c->base.alphaMask =
            BITS_AND_SHIFT_TO_MASK(c->base.alphaBits,
                                   ATTR_VALUE(WGL_ALPHA_SHIFT_ARB, 0));

        switch (ATTR_VALUE(WGL_PIXEL_TYPE_ARB, 0)) {
        case WGL_TYPE_COLORINDEX_ARB:
            c->base.indexBits = ATTR_VALUE(WGL_COLOR_BITS_ARB, 0);
            c->base.rgbBits = 0;
            c->base.visualType = GLX_STATIC_COLOR;
            break;

        case WGL_TYPE_RGBA_FLOAT_ARB:
            GLWIN_DEBUG_MSG
                ("pixelFormat %d is WGL_TYPE_RGBA_FLOAT_ARB, skipping", i + 1);
            continue;

        case WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT:
            GLWIN_DEBUG_MSG
                ("pixelFormat %d is WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT, skipping",
                 i + 1);
            continue;

        case WGL_TYPE_RGBA_ARB:
            c->base.indexBits = 0;
            c->base.rgbBits = ATTR_VALUE(WGL_COLOR_BITS_ARB, 0);
            c->base.visualType = GLX_TRUE_COLOR;
            break;

        default:
            ErrorF
                ("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_PIXEL_TYPE_ARB\n",
                 ATTR_VALUE(WGL_PIXEL_TYPE_ARB, 0));
            continue;
        }

        c->base.accumRedBits = ATTR_VALUE(WGL_ACCUM_RED_BITS_ARB, 0);
        c->base.accumGreenBits = ATTR_VALUE(WGL_ACCUM_GREEN_BITS_ARB, 0);
        c->base.accumBlueBits = ATTR_VALUE(WGL_ACCUM_BLUE_BITS_ARB, 0);
        c->base.accumAlphaBits = ATTR_VALUE(WGL_ACCUM_ALPHA_BITS_ARB, 0);

        c->base.depthBits = ATTR_VALUE(WGL_DEPTH_BITS_ARB, 0);
        c->base.stencilBits = ATTR_VALUE(WGL_STENCIL_BITS_ARB, 0);
        c->base.numAuxBuffers = ATTR_VALUE(WGL_AUX_BUFFERS_ARB, 0);

        {
            int layers =
                ATTR_VALUE(WGL_NUMBER_OVERLAYS_ARB,
                           0) + ATTR_VALUE(WGL_NUMBER_UNDERLAYS_ARB, 0);

            if (layers > 0) {
                ErrorF
                    ("pixelFormat %d: has %d overlay, %d underlays which aren't currently handled",
                     i, ATTR_VALUE(WGL_NUMBER_OVERLAYS_ARB, 0),
                     ATTR_VALUE(WGL_NUMBER_UNDERLAYS_ARB, 0));
                // XXX: need to iterate over layers?
            }
        }
        c->base.level = 0;

        c->base.visualID = -1;  // will be set by __glXScreenInit()

        /* EXT_visual_rating / GLX 1.2 */
        switch (ATTR_VALUE(WGL_ACCELERATION_ARB, 0)) {
        default:
            ErrorF
                ("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_ACCELERATION_ARB\n",
                 ATTR_VALUE(WGL_ACCELERATION_ARB, 0));

        case WGL_NO_ACCELERATION_ARB:
            c->base.visualRating = GLX_SLOW_VISUAL_EXT;
            break;

        case WGL_GENERIC_ACCELERATION_ARB:
        case WGL_FULL_ACCELERATION_ARB:
            c->base.visualRating = GLX_NONE_EXT;
            break;
        }

        /* EXT_visual_info / GLX 1.2 */
        // c->base.visualType is set above
        if (ATTR_VALUE(WGL_TRANSPARENT_ARB, 0)) {
            c->base.transparentPixel =
                (c->base.visualType ==
                 GLX_TRUE_COLOR) ? GLX_TRANSPARENT_RGB_EXT :
                GLX_TRANSPARENT_INDEX_EXT;
            c->base.transparentRed =
                ATTR_VALUE(WGL_TRANSPARENT_RED_VALUE_ARB, 0);
            c->base.transparentGreen =
                ATTR_VALUE(WGL_TRANSPARENT_GREEN_VALUE_ARB, 0);
            c->base.transparentBlue =
                ATTR_VALUE(WGL_TRANSPARENT_BLUE_VALUE_ARB, 0);
            c->base.transparentAlpha =
                ATTR_VALUE(WGL_TRANSPARENT_ALPHA_VALUE_ARB, 0);
            c->base.transparentIndex =
                ATTR_VALUE(WGL_TRANSPARENT_INDEX_VALUE_ARB, 0);
        }
        else {
            c->base.transparentPixel = GLX_NONE_EXT;
            c->base.transparentRed = GLX_NONE;
            c->base.transparentGreen = GLX_NONE;
            c->base.transparentBlue = GLX_NONE;
            c->base.transparentAlpha = GLX_NONE;
            c->base.transparentIndex = GLX_NONE;
        }

        /* ARB_multisample / SGIS_multisample */
        if (screen->has_WGL_ARB_multisample) {
            c->base.sampleBuffers = ATTR_VALUE(WGL_SAMPLE_BUFFERS_ARB, 0);
            c->base.samples = ATTR_VALUE(WGL_SAMPLES_ARB, 0);
        }
        else {
            c->base.sampleBuffers = 0;
            c->base.samples = 0;
        }

        /* SGIX_fbconfig / GLX 1.3 */
        c->base.drawableType =
            ((ATTR_VALUE(WGL_DRAW_TO_WINDOW_ARB, 0) ? GLX_WINDOW_BIT : 0)
             | (ATTR_VALUE(WGL_DRAW_TO_BITMAP_ARB, 0) ? GLX_PIXMAP_BIT : 0)
             | (ATTR_VALUE(WGL_DRAW_TO_PBUFFER_ARB, 0) ? GLX_PBUFFER_BIT : 0));

        /*
           Assume OpenGL RGBA rendering is available on all visuals
           (it is specified to render to red component in single-channel visuals,
           if supported, but there doesn't seem to be any mechanism to check if it
           is supported)

           Color index rendering is only supported on single-channel visuals
         */
        if (c->base.visualType == GLX_STATIC_COLOR) {
            c->base.renderType = GLX_RGBA_BIT | GLX_COLOR_INDEX_BIT;
        }
        else {
            c->base.renderType = GLX_RGBA_BIT;
        }

        c->base.xRenderable = GL_TRUE;
        c->base.fbconfigID = -1;        // will be set by __glXScreenInit()

        /* SGIX_pbuffer / GLX 1.3 */
        if (screen->has_WGL_ARB_pbuffer) {
            c->base.maxPbufferWidth = ATTR_VALUE(WGL_MAX_PBUFFER_WIDTH_ARB, -1);
            c->base.maxPbufferHeight =
                ATTR_VALUE(WGL_MAX_PBUFFER_HEIGHT_ARB, -1);
            c->base.maxPbufferPixels =
                ATTR_VALUE(WGL_MAX_PBUFFER_PIXELS_ARB, -1);
        }
        else {
            c->base.maxPbufferWidth = -1;
            c->base.maxPbufferHeight = -1;
            c->base.maxPbufferPixels = -1;
        }
        c->base.optimalPbufferWidth = 0;        // there is no optimal value
        c->base.optimalPbufferHeight = 0;

        /* SGIX_visual_select_group */
        // arrange for visuals with the best acceleration to be preferred in selection
        switch (ATTR_VALUE(WGL_ACCELERATION_ARB, 0)) {
        case WGL_FULL_ACCELERATION_ARB:
            c->base.visualSelectGroup = 2;
            break;

        case WGL_GENERIC_ACCELERATION_ARB:
            c->base.visualSelectGroup = 1;
            break;

        default:
        case WGL_NO_ACCELERATION_ARB:
            c->base.visualSelectGroup = 0;
            break;
        }

        /* OML_swap_method */
        switch (ATTR_VALUE(WGL_SWAP_METHOD_ARB, 0)) {
        case WGL_SWAP_EXCHANGE_ARB:
            c->base.swapMethod = GLX_SWAP_EXCHANGE_OML;
            break;

        case WGL_SWAP_COPY_ARB:
            c->base.swapMethod = GLX_SWAP_COPY_OML;
            break;

        default:
            ErrorF
                ("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_SWAP_METHOD_ARB\n",
                 ATTR_VALUE(WGL_SWAP_METHOD_ARB, 0));

        case WGL_SWAP_UNDEFINED_ARB:
            c->base.swapMethod = GLX_SWAP_UNDEFINED_OML;
        }

        /* EXT_texture_from_pixmap */
        /*
           Mesa's DRI configs always have bindToTextureRgb/Rgba TRUE (see driCreateConfigs(), so setting
           bindToTextureRgb/bindToTextureRgba to FALSE means that swrast can't find any fbConfigs to use,
           so setting these to 0, even if we know bindToTexture isn't available, isn't a good idea...
         */
        if (screen->has_WGL_ARB_render_texture) {
            c->base.bindToTextureRgb =
                ATTR_VALUE(WGL_BIND_TO_TEXTURE_RGB_ARB, -1);
            c->base.bindToTextureRgba =
                ATTR_VALUE(WGL_BIND_TO_TEXTURE_RGBA_ARB, -1);
        }
        else {
            c->base.bindToTextureRgb = -1;
            c->base.bindToTextureRgba = -1;
        }
        c->base.bindToMipmapTexture = -1;
        c->base.bindToTextureTargets =
            GLX_TEXTURE_1D_BIT_EXT | GLX_TEXTURE_2D_BIT_EXT |
            GLX_TEXTURE_RECTANGLE_BIT_EXT;
        c->base.yInverted = -1;
        c->base.sRGBCapable = 0;

        n++;

        // update previous config to point to this config
        if (prev)
            prev->base.next = &(c->base);

        prev = c;
    }

    screen->base.numFBConfigs = n;
    screen->base.fbconfigs = &(result->base);
}
@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d256 1
a256 1
    ErrorF("dwFlags = %lu = {", pfd->dwFlags);
d300 3
a302 3
    ErrorF("dwLayerMask = %lu\n", pfd->dwLayerMask);
    ErrorF("dwVisibleMask = %lu\n", pfd->dwVisibleMask);
    ErrorF("dwDamageMask = %lu\n", pfd->dwDamageMask);
d1865 2
a1866 2
                ("pixelFormat %d has unsuitable flags 0x%08lx, skipping", i + 1,
                 pfd.dwFlags);
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a740 3
        // Override the GL extensions string set by __glXScreenInit()
        screen->base.GLextensions = strdup(gl_extensions);

a892 7
    /*
       draw->drawContext->base.drawPriv will not be set if the context is not current anymore,
       but if it is, it should point to this drawable....
     */
    assert((draw->drawContext->base.drawPriv == NULL) ||
           (draw->drawContext->base.drawPriv == base));

a1115 1
            ErrorF("wglChoosePixelFormat error: %s\n", glxWinErrorMessage());
d1298 1
a1298 1
            // XXX: which DC are supposed to use???
d1311 1
a1311 1
                                           GLX_DRAWABLE_PBUFFER, winScreen);
a1312 2
                ErrorF("wglChoosePixelFormat error: %s\n",
                       glxWinErrorMessage());
d1751 1
a1751 1
        SET_ATTR_VALUE(WGL_SWAP_COPY_ARB, TRUE);
@


1.6
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d835 1
a835 1
    dixLookupResourceByType((pointer) &pGlxDraw, pWindow->drawable.id,
a931 11
    if (glxPriv->drawContext &&
        (__glXLastContext == &((glxPriv->drawContext)->base))) {
        // if this context is current and has unflushed commands, say we have flushed them
        // (don't actually flush them, the window is going away anyhow, and an implict flush occurs
        // on the next context change)
        // (GLX core considers it an error when we try to select a new current context if the old one
        // has unflushed commands, but the window has disappeared..)
        __glXLastContext->hasUnflushedCommands = FALSE;
        __glXLastContext = NULL;
    }

d1534 1
a1534 1
    if (__glXLastContext != NULL) {
d1605 1
a1605 1
    context = (__GLXWinContext *) calloc(1, sizeof(__GLXWinContext));
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d389 3
a391 1
               (c->drawableType & GLX_PBUFFER_BIT) ? "y" : ".", ".",
d553 3
a555 1
    /* Dump out some useful information about the native renderer */
d602 4
a605 3
    ErrorF("GL_VERSION:     %s\n", glGetStringWrapperNonstatic(GL_VERSION));
    ErrorF("GL_VENDOR:      %s\n", glGetStringWrapperNonstatic(GL_VENDOR));
    gl_renderer = (const char *) glGetStringWrapperNonstatic(GL_RENDERER);
d607 1
a607 1
    gl_extensions = (const char *) glGetStringWrapperNonstatic(GL_EXTENSIONS);
d621 1
a621 1
        return NULL;
d732 1
a732 1
            return NULL;
d795 7
d923 1
a923 1
    glAddSwapHintRectWINWrapperNonstatic(x, y, w, h);
a1470 1
    glWinCallDelta();
a1539 1
    glWinCallDelta();
a1633 2
    glWinSetupDispatchTable();

a1725 1
    /* mode->pixmapMode ? */
a1934 1
        c->base.pixmapMode = 0;
a2024 3
        /* EXT_import_context */
        c->base.screen = screen->base.pScreen->myNum;

d2031 1
a2268 1
        c->base.pixmapMode = 0; // ???
a2400 3
        /* EXT_import_context */
        c->base.screen = screen->base.pScreen->myNum;

d2422 1
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d89 1
d227 1
a227 1
         (LPTSTR) & errorbuffer, sizeof(errorbuffer), NULL)) {
d345 4
d406 3
a408 1
                                         __GLXcontext * baseShareContext);
d483 1
a483 1
    char *strl;
d492 2
d527 1
a550 8
    /* Wrap RealizeWindow, UnrealizeWindow and CopyWindow on this screen */
    screen->RealizeWindow = pScreen->RealizeWindow;
    pScreen->RealizeWindow = glxWinRealizeWindow;
    screen->UnrealizeWindow = pScreen->UnrealizeWindow;
    pScreen->UnrealizeWindow = glxWinUnrealizeWindow;
    screen->CopyWindow = pScreen->CopyWindow;
    pScreen->CopyWindow = glxWinCopyWindow;

d600 2
a601 1
    ErrorF("GL_RENDERER:    %s\n", glGetStringWrapperNonstatic(GL_RENDERER));
a602 1
    glxLogExtensions("GL_EXTENSIONS:  ", gl_extensions);
d606 12
a617 1
    glxLogExtensions("WGL_EXTENSIONS: ", wgl_extensions);
a735 3
        // dump out fbConfigs now fbConfigIds and visualIDs have been assigned
        fbConfigsDump(screen->base.numFBConfigs, screen->base.fbconfigs);

d778 11
d1373 1
a1373 1
                CreateDIBSection(draw->dibDC, (BITMAPINFO *) & bmpHeader,
d1595 2
a1596 1
                    __GLXconfig * modes, __GLXcontext * baseShareContext)
d1637 12
a1683 1
    pfd.iPixelType = PFD_TYPE_RGBA;
d1686 1
a1686 1
    pfd.cRedShift = 0;          /* FIXME */
d1688 1
a1688 1
    pfd.cGreenShift = 0;        /* FIXME  */
d1690 1
a1690 1
    pfd.cBlueShift = 0;         /* FIXME */
d1692 12
a1703 1
    pfd.cAlphaShift = 0;        /* FIXME */
d1846 2
a1847 2
    GLWIN_DEBUG_MSG("DescribePixelFormat says %d possible pixel formats",
                    numConfigs);
d1943 6
a1948 6

            if (!getenv("GLWIN_ENABLE_COLORINDEX_FBCONFIGS")) {
                GLWIN_DEBUG_MSG
                    ("pixelFormat %d is PFD_TYPE_COLORINDEX, skipping", i + 1);
                continue;
            }
d1952 10
a1963 8
        // pfd.dwVisibleMask; ???
        c->base.transparentPixel = GLX_NONE;
        c->base.transparentRed = GLX_NONE;
        c->base.transparentGreen = GLX_NONE;
        c->base.transparentBlue = GLX_NONE;
        c->base.transparentAlpha = GLX_NONE;
        c->base.transparentIndex = GLX_NONE;

d2094 3
a2096 3
    GLWIN_DEBUG_MSG
        ("wglGetPixelFormatAttribivARB says %d possible pixel formats",
         numConfigs);
a2214 8

            if (!getenv("GLWIN_ENABLE_COLORINDEX_FBCONFIGS")) {
                GLWIN_DEBUG_MSG
                    ("pixelFormat %d is WGL_TYPE_COLORINDEX_ARB, skipping",
                     i + 1);
                continue;
            }

@


1.3
log
@Update to xserver 1.11.2
@
text
@d108 1
a108 1
typedef struct __GLXWinContext  __GLXWinContext;
d114 4
a117 4
  __GLXcontext base;
  HGLRC ctx;                         /* Windows GL Context */
  __GLXWinContext *shareContext;     /* Context with which we will share display lists and textures */
  HWND hwnd;                         /* For detecting when HWND has changed */
d120 13
a132 14
struct __GLXWinDrawable
{
  __GLXdrawable base;
  __GLXWinContext *drawContext;
  __GLXWinContext *readContext;

  /* If this drawable is GLX_DRAWABLE_PBUFFER */
  HPBUFFERARB hPbuffer;

  /* If this drawable is GLX_DRAWABLE_PIXMAP */
  HDC dibDC;
  HBITMAP hDIB;
  HBITMAP hOldDIB; /* original DIB for DC */
  void *pOldBits; /* original pBits for this drawable's pixmap */
d135 2
a136 3
struct __GLXWinScreen
{
  __GLXscreen base;
d138 2
a139 2
  /* Supported GLX extensions */
  unsigned char glx_enable_bits[__GLX_EXT_BYTES];
d141 9
a149 9
  Bool has_WGL_ARB_multisample;
  Bool has_WGL_ARB_pixel_format;
  Bool has_WGL_ARB_pbuffer;
  Bool has_WGL_ARB_render_texture;

  /* wrapped screen functions */
  RealizeWindowProcPtr RealizeWindow;
  UnrealizeWindowProcPtr UnrealizeWindow;
  CopyWindowProcPtr CopyWindow;
d152 3
a154 4
struct __GLXWinConfig
{
  __GLXconfig base;
  int pixelFormatIndex;
d169 1
a169 1
glxWinDebugSettingsRec glxWinDebugSettings = { 0, 0, 0, 0, 0, 0};
d171 2
a172 1
static void glxWinInitDebugSettings(void)
d205 1
a205 2
    if (envptr != NULL)
      {
d213 1
a213 1
      }
d217 2
a218 1
const char *glxWinErrorMessage(void)
d220 2
a221 2
  static char errorbuffer[1024];
  unsigned int last_error = GetLastError();
d223 5
a227 10
  if (!FormatMessage(
                     FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                     NULL,
                     last_error,
                     0,
                     (LPTSTR) &errorbuffer,
                     sizeof(errorbuffer),
                     NULL ))
    {
      snprintf(errorbuffer, sizeof(errorbuffer), "Unknown error");
d230 3
a232 2
  if ((errorbuffer[strlen(errorbuffer)-1] == '\n') || (errorbuffer[strlen(errorbuffer)-1] == '\r'))
    errorbuffer[strlen(errorbuffer)-1] = 0;
d234 1
a234 1
  sprintf(errorbuffer + strlen(errorbuffer), " (%08x)", last_error);
d236 1
a236 1
  return errorbuffer;
d239 1
a239 1
static void pfdOut(const PIXELFORMATDESCRIPTOR *pfd);
d247 2
a248 1
static void pfdOut(const PIXELFORMATDESCRIPTOR *pfd)
d250 2
a251 1
    const char *pipesym = ""; /* will be set after first flag dump */
d256 19
a274 19
        DUMP_PFD_FLAG(PFD_DOUBLEBUFFER);
        DUMP_PFD_FLAG(PFD_STEREO);
        DUMP_PFD_FLAG(PFD_DRAW_TO_WINDOW);
        DUMP_PFD_FLAG(PFD_DRAW_TO_BITMAP);
        DUMP_PFD_FLAG(PFD_SUPPORT_GDI);
        DUMP_PFD_FLAG(PFD_SUPPORT_OPENGL);
        DUMP_PFD_FLAG(PFD_GENERIC_FORMAT);
        DUMP_PFD_FLAG(PFD_NEED_PALETTE);
        DUMP_PFD_FLAG(PFD_NEED_SYSTEM_PALETTE);
        DUMP_PFD_FLAG(PFD_SWAP_EXCHANGE);
        DUMP_PFD_FLAG(PFD_SWAP_COPY);
        DUMP_PFD_FLAG(PFD_SWAP_LAYER_BUFFERS);
        DUMP_PFD_FLAG(PFD_GENERIC_ACCELERATED);
        DUMP_PFD_FLAG(PFD_SUPPORT_DIRECTDRAW);
        DUMP_PFD_FLAG(PFD_DIRECT3D_ACCELERATED);
        DUMP_PFD_FLAG(PFD_SUPPORT_COMPOSITION);
        DUMP_PFD_FLAG(PFD_DEPTH_DONTCARE);
        DUMP_PFD_FLAG(PFD_DOUBLEBUFFER_DONTCARE);
        DUMP_PFD_FLAG(PFD_STEREO_DONTCARE);
d278 2
a279 1
            (pfd->iPixelType == PFD_TYPE_RGBA ? "PFD_TYPE_RGBA" : "PFD_TYPE_COLORINDEX"));
d308 16
a323 16
  switch (cls) {
  case GLX_STATIC_COLOR:
    return "StaticColor";
  case GLX_PSEUDO_COLOR:
    return "PseudoColor";
  case GLX_STATIC_GRAY:
    return "StaticGray";
  case GLX_GRAY_SCALE:
    return "GrayScale";
  case GLX_TRUE_COLOR:
     return "TrueColor";
  case GLX_DIRECT_COLOR:
     return "DirectColor";
  default:
    return "-none-";
  }
d329 1
a329 2
  switch (mthd)
    {
d331 1
a331 1
      return "xchg";
d333 1
a333 1
      return "copy";
d335 1
a335 1
      return "    ";
d337 1
a337 1
      return "????";
d342 1
a342 1
fbConfigsDump(unsigned int n, __GLXconfig *c)
d344 44
a387 42
  ErrorF("%d fbConfigs\n", n);
  ErrorF("pxf vis  fb                      render         Ste                     aux    accum        MS    drawable             Group/\n");
  ErrorF("idx  ID  ID VisualType Depth Lvl RGB CI DB Swap reo  R  G  B  A   Z  S  buf AR AG AB AA  bufs num  W P Pb  Float Trans Caveat\n");
  ErrorF("-----------------------------------------------------------------------------------------------------------------------------\n");

  while (c != NULL)
    {
      unsigned int i = ((GLXWinConfig *)c)->pixelFormatIndex;

      ErrorF("%3d %3x %3x "
             "%-11s"
             " %3d %3d   %s   %s  %s %s  %s  "
             "%2d %2d %2d %2d  "
             "%2d %2d  "
             "%2d  "
             "%2d %2d %2d %2d"
             "   %2d   %2d"
             "  %s %s %s "
             "    %s   "
             "  %s   "
             "  %d %s"
             "\n",
             i, c->visualID, c->fbconfigID,
             visual_class_name(c->visualType),
             c->rgbBits ? c->rgbBits : c->indexBits,
             c->level,
	     (c->renderType & GLX_RGBA_BIT) ? "y" : ".",
	     (c->renderType & GLX_COLOR_INDEX_BIT) ? "y" : ".",
	     c->doubleBufferMode ? "y" : ".",
             swap_method_name(c->swapMethod),
	     c->stereoMode ? "y" : ".",
             c->redBits, c->greenBits, c->blueBits, c->alphaBits,
             c->depthBits, c->stencilBits,
             c->numAuxBuffers,
             c->accumRedBits, c->accumGreenBits, c->accumBlueBits, c->accumAlphaBits,
             c->sampleBuffers, c->samples,
             (c->drawableType & GLX_WINDOW_BIT) ? "y" : ".",
             (c->drawableType & GLX_PIXMAP_BIT) ? "y" : ".",
             (c->drawableType & GLX_PBUFFER_BIT) ? "y" : ".",
             ".",
             (c->transparentPixel != GLX_NONE_EXT) ? "y" : ".",
             c->visualSelectGroup, (c->visualRating == GLX_SLOW_VISUAL_EXT) ? "*" : " ");
d389 1
a389 1
      c = c->next;
d399 3
a401 3
static __GLXcontext *glxWinCreateContext(__GLXscreen *screen,
                                        __GLXconfig *modes,
                                        __GLXcontext *baseShareContext);
d403 5
a407 6
                                          __GLXscreen *screen,
                                          DrawablePtr pDraw,
                                          XID drawId,
                                          int type,
                                          XID glxDrawId,
                                          __GLXconfig *conf);
d411 2
a412 1
static void glxWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
d414 12
a425 7
static HDC glxWinMakeDC(__GLXWinContext *gc, __GLXWinDrawable *draw, HDC *hdc, HWND *hwnd);
static void glxWinReleaseDC(HWND hwnd, HDC hdc, __GLXWinDrawable *draw);

static void glxWinCreateConfigs(HDC dc, glxWinScreen *screen);
static void glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen);
static int fbConfigToPixelFormat(__GLXconfig *mode, PIXELFORMATDESCRIPTOR *pfdret, int drawableTypeOverride);
static int fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig *mode, int drawableTypeOverride, glxWinScreen *winScreen);
d441 1
a441 1
  GlxPushProvider(&__glXWGLProvider);
d450 1
a450 1
glxWinScreenDestroy(__GLXscreen *screen)
d458 1
a458 1
glxWinScreenSwapInterval(__GLXdrawable *drawable, int interval)
d460 5
a464 4
  BOOL ret = wglSwapIntervalEXTWrapper(interval);
  if (!ret)
    {
      ErrorF("wglSwapIntervalEXT interval %d failed:%s\n", interval, glxWinErrorMessage());
d466 1
a466 1
  return ret;
d475 3
a477 3
  int length = 0;
  char *strl;
  char *str = strdup(extensions);
d479 3
a481 4
  if (str == NULL)
    {
      ErrorF("glxLogExtensions: xalloc error\n");
      return;
d484 17
a500 19
  strl = strtok(str, " ");
  ErrorF("%s%s", prefix, strl);
  length = strlen(prefix) + strlen(strl);

  while (1)
    {
      strl = strtok(NULL, " ");
      if (strl == NULL) break;

      if (length + strlen(strl) + 1 > 120)
        {
          ErrorF("\n");
          ErrorF("%s",prefix);
          length = strlen(prefix);
        }
      else
        {
          ErrorF(" ");
          length++;
d503 2
a504 2
      ErrorF("%s", strl);
      length = length + strlen(strl);
d507 1
a507 1
  ErrorF("\n");
d509 1
a509 1
  free(str);
d528 1
a528 1
	return NULL;
d530 3
a532 3
    if (!winCheckScreenAiglxIsSupported(pScreen))
      {
        LogMessage(X_ERROR,"AIGLX: No native OpenGL in modes with a root window\n");
d534 1
a534 1
      }
d539 1
a539 1
	return NULL;
d554 19
a572 18
      static wATOM glTestWndClass = 0;
      if (glTestWndClass == 0)
        {
          WNDCLASSEX wc;
          wc.cbSize = sizeof(WNDCLASSEX);
          wc.style = CS_HREDRAW | CS_VREDRAW;
          wc.lpfnWndProc = DefWindowProc;
          wc.cbClsExtra = 0;
          wc.cbWndExtra = 0;
          wc.hInstance = GetModuleHandle(NULL);
          wc.hIcon = 0;
          wc.hCursor = 0;
          wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
          wc.lpszMenuName = NULL;
          wc.lpszClassName = WIN_GL_TEST_WINDOW_CLASS;
          wc.hIconSm = 0;
          RegisterClassEx (&wc);
      }
d579 2
a580 1
                           0, 0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL), NULL);
d582 2
a583 1
      LogMessage(X_ERROR,"AIGLX: Couldn't create a window for render capabilities testing\n");
d599 1
a599 1
    gl_extensions = (const char *)glGetStringWrapperNonstatic(GL_EXTENSIONS);
d602 2
a603 1
    if (!wgl_extensions) wgl_extensions = "";
d612 6
a617 6
      // testing facility to not use any WGL extensions
      char *envptr = getenv("GLWIN_NO_WGL_EXTENSIONS");
      if ((envptr != NULL) && (atoi(envptr) != 0))
        {
          ErrorF("GLWIN_NO_WGL_EXTENSIONS is set, ignoring WGL_EXTENSIONS\n");
          wgl_extensions = "";
d622 1
a622 1
      Bool glx_sgi_make_current_read = FALSE;
d624 5
a628 11
      //
      // Based on the WGL extensions available, enable various GLX extensions
      // XXX: make this table-driven ?
      //
      memset(screen->glx_enable_bits, 0, __GLX_EXT_BYTES);

      __glXEnableExtension(screen->glx_enable_bits, "GLX_EXT_visual_info");
      __glXEnableExtension(screen->glx_enable_bits, "GLX_EXT_visual_rating");
      __glXEnableExtension(screen->glx_enable_bits, "GLX_EXT_import_context");
      __glXEnableExtension(screen->glx_enable_bits, "GLX_OML_swap_method");
      __glXEnableExtension(screen->glx_enable_bits, "GLX_SGIX_fbconfig");
d630 11
a640 5
      if (strstr(wgl_extensions, "WGL_ARB_make_current_read"))
        {
          __glXEnableExtension(screen->glx_enable_bits, "GLX_SGI_make_current_read");
          LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_make_current_read\n");
          glx_sgi_make_current_read = TRUE;
d643 4
a646 4
      if (strstr(gl_extensions, "GL_WIN_swap_hint"))
        {
          __glXEnableExtension(screen->glx_enable_bits, "GLX_MESA_copy_sub_buffer");
          LogMessage(X_INFO, "AIGLX: enabled GLX_MESA_copy_sub_buffer\n");
d649 7
a655 5
      if (strstr(wgl_extensions, "WGL_EXT_swap_control"))
        {
          __glXEnableExtension(screen->glx_enable_bits, "GLX_SGI_swap_control");
          __glXEnableExtension(screen->glx_enable_bits, "GLX_MESA_swap_control");
          LogMessage(X_INFO, "AIGLX: enabled GLX_SGI_swap_control and GLX_MESA_swap_control\n");
d666 39
a704 5
      if (strstr(wgl_extensions, "WGL_ARB_pbuffer"))
        {
          __glXEnableExtension(screen->glx_enable_bits, "GLX_SGIX_pbuffer");
          LogMessage(X_INFO, "AIGLX: enabled GLX_SGIX_pbuffer\n");
          screen->has_WGL_ARB_pbuffer = TRUE;
d707 8
a714 6
      if (strstr(wgl_extensions, "WGL_ARB_multisample"))
        {
          __glXEnableExtension(screen->glx_enable_bits, "GLX_ARB_multisample");
          __glXEnableExtension(screen->glx_enable_bits, "GLX_SGIS_multisample");
          LogMessage(X_INFO, "AIGLX: enabled GLX_ARB_multisample and GLX_SGIS_multisample\n");
          screen->has_WGL_ARB_multisample = TRUE;
d717 3
a719 5
      screen->base.destroy = glxWinScreenDestroy;
      screen->base.createContext = glxWinCreateContext;
      screen->base.createDrawable = glxWinCreateDrawable;
      screen->base.swapInterval = glxWinScreenSwapInterval;
      screen->base.pScreen = pScreen;
d721 9
a729 2
      // Creating the fbConfigs initializes screen->base.fbconfigs and screen->base.numFBConfigs
      if (strstr(wgl_extensions, "WGL_ARB_pixel_format"))
d731 4
a734 1
          glxWinCreateConfigsExt(hdc, screen);
d736 3
a738 8
          /*
            Some graphics drivers appear to advertise WGL_ARB_pixel_format,
            but it doesn't work usefully, so we have to be prepared for it
            to fail and fall back to using DescribePixelFormat()
          */
          if (screen->base.numFBConfigs > 0)
            {
              screen->has_WGL_ARB_pixel_format = TRUE;
d742 11
a752 53
      if (screen->base.numFBConfigs <= 0)
        {
          glxWinCreateConfigs(hdc, screen);
          screen->has_WGL_ARB_pixel_format = FALSE;
        }

      /*
        If we still didn't get any fbConfigs, we can't provide GLX for this screen
       */
      if (screen->base.numFBConfigs <= 0)
        {
          free(screen);
          LogMessage(X_ERROR,"AIGLX: No fbConfigs could be made from native OpenGL pixel formats\n");
          return NULL;
        }

      /* These will be set by __glXScreenInit */
      screen->base.visuals = NULL;
      screen->base.numVisuals = 0;

      __glXScreenInit(&screen->base, pScreen);

      // dump out fbConfigs now fbConfigIds and visualIDs have been assigned
      fbConfigsDump(screen->base.numFBConfigs, screen->base.fbconfigs);

      // Override the GL extensions string set by __glXScreenInit()
      screen->base.GLextensions = strdup(gl_extensions);

      // Generate the GLX extensions string (overrides that set by __glXScreenInit())
      {
        unsigned int buffer_size = __glXGetExtensionString(screen->glx_enable_bits, NULL);
        if (buffer_size > 0)
          {
            free(screen->base.GLXextensions);

            screen->base.GLXextensions = xnfalloc(buffer_size);
            __glXGetExtensionString(screen->glx_enable_bits, screen->base.GLXextensions);
          }
      }

      //
      // Override the GLX version (__glXScreenInit() sets it to "1.2")
      // if we have all the needed extensions to operate as a higher version
      //
      // SGIX_fbconfig && SGIX_pbuffer && SGI_make_current_read -> 1.3
      // ARB_multisample -> 1.4
      //
      if (screen->has_WGL_ARB_pbuffer && glx_sgi_make_current_read)
        {
          if (screen->has_WGL_ARB_multisample)
            {
              screen->base.GLXmajor = 1;
              screen->base.GLXminor = 4;
d754 3
a756 4
          else
            {
              screen->base.GLXmajor = 1;
              screen->base.GLXminor = 3;
d760 2
a761 1
    LogMessage(X_INFO, "AIGLX: Set GLX version to %d.%d\n", screen->base.GLXmajor, screen->base.GLXminor);
a792 1

d802 2
a803 3
    dixLookupResourceByType((pointer) &pGlxDraw, pWindow->drawable.id, __glXDrawableRes,
				NullClient, DixUnknownAccess);

d811 2
a812 3
    */
    if (pGlxDraw && pGlxDraw->drawContext)
      {
d815 1
a815 1
      }
d829 1
a829 1
    glxWinScreen *screenPriv = (glxWinScreen *)glxGetScreen(pScreen);
d846 1
a846 1
glxWinDrawableSwapBuffers(ClientPtr client, __GLXdrawable *base)
d851 1
a851 1
    __GLXWinDrawable *draw = (__GLXWinDrawable *)base;
d854 1
a854 2
    if (draw->drawContext == NULL)
      {
d857 1
a857 1
      }
d859 3
a861 1
    GLWIN_TRACE_MSG("glxWinSwapBuffers on drawable %p, last context %p (native ctx %p)", base, draw->drawContext, draw->drawContext->ctx);
d866 3
a868 2
    */
    assert((draw->drawContext->base.drawPriv == NULL) || (draw->drawContext->base.drawPriv == base));
d872 1
a872 1
      return GL_FALSE;
d878 1
a878 2
    if (!ret)
      {
d881 1
a881 1
      }
d887 1
a887 1
glxWinDrawableCopySubBuffer(__GLXdrawable *drawable,
d890 2
a891 2
  glAddSwapHintRectWINWrapperNonstatic(x, y, w, h);
  glxWinDrawableSwapBuffers(NULL, drawable);
d895 1
a895 1
glxWinDrawableDestroy(__GLXdrawable *base)
d897 12
a908 1
  __GLXWinDrawable *glxPriv = (__GLXWinDrawable *)base;
d910 4
a913 16
  if (glxPriv->drawContext && (__glXLastContext == &((glxPriv->drawContext)->base)))
    {
      // if this context is current and has unflushed commands, say we have flushed them
      // (don't actually flush them, the window is going away anyhow, and an implict flush occurs
      // on the next context change)
      // (GLX core considers it an error when we try to select a new current context if the old one
      // has unflushed commands, but the window has disappeared..)
      __glXLastContext->hasUnflushedCommands = FALSE;
      __glXLastContext = NULL;
    }

  if (glxPriv->hPbuffer)
    if (!wglDestroyPbufferARBWrapper(glxPriv->hPbuffer))
      {
        ErrorF("wglDestroyPbufferARB failed: %s\n", glxWinErrorMessage());
      }
d915 3
a917 4
  if (glxPriv->dibDC)
    {
      // restore the default DIB
      SelectObject(glxPriv->dibDC, glxPriv->hOldDIB);
d919 2
a920 3
      if (!DeleteDC(glxPriv->dibDC))
        {
          ErrorF("DeleteDC failed: %s\n", glxWinErrorMessage());
d924 3
a926 5
  if (glxPriv->hDIB)
    {
      if (!DeleteObject(glxPriv->hDIB))
        {
          ErrorF("DeleteObject failed: %s\n", glxWinErrorMessage());
d929 1
a929 1
      ((PixmapPtr)glxPriv->base.pDraw)->devPrivate.ptr = glxPriv->pOldBits;
d932 2
a933 2
  GLWIN_DEBUG_MSG("glxWinDestroyDrawable");
  free(glxPriv);
d938 3
a940 6
                    __GLXscreen *screen,
                    DrawablePtr pDraw,
                    XID drawId,
                    int type,
                    XID glxDrawId,
                    __GLXconfig *conf)
d942 1
a942 1
  __GLXWinDrawable *glxPriv;
d944 1
a944 1
  glxPriv = malloc(sizeof *glxPriv);
d946 2
a947 2
  if (glxPriv == NULL)
      return NULL;
d949 1
a949 1
  memset(glxPriv, 0, sizeof *glxPriv);
d951 5
a955 4
  if(!__glXDrawableInit(&glxPriv->base, screen, pDraw, type, glxDrawId, conf)) {
    free(glxPriv);
    return NULL;
  }
d957 5
a961 5
  glxPriv->base.destroy       = glxWinDrawableDestroy;
  glxPriv->base.swapBuffers   = glxWinDrawableSwapBuffers;
  glxPriv->base.copySubBuffer = glxWinDrawableCopySubBuffer;
  // glxPriv->base.waitX  what are these for?
  // glxPriv->base.waitGL
d963 1
a963 1
  GLWIN_DEBUG_MSG("glxWinCreateDrawable %p", glxPriv);
d965 1
a965 1
  return &glxPriv->base;
d974 3
a976 3
int glxWinBindTexImage(__GLXcontext  *baseContext,
                      int            buffer,
                      __GLXdrawable *pixmap)
d978 2
a979 2
  ErrorF("glxWinBindTexImage: not implemented\n");
  return FALSE;
d983 3
a985 3
int glxWinReleaseTexImage(__GLXcontext  *baseContext,
                         int            buffer,
                         __GLXdrawable *pixmap)
d987 2
a988 2
  ErrorF(" glxWinReleaseTexImage: not implemented\n");
  return FALSE;
d1011 2
a1012 1
glxWinSetPixelFormat(__GLXWinContext *gc, HDC hdc, int bppOverride, int drawableTypeOverride)
d1014 2
a1015 2
  __GLXscreen *screen = gc->base.pGlxScreen;
  glxWinScreen *winScreen = (glxWinScreen *)screen;
d1017 2
a1018 2
  __GLXconfig *config = gc->base.config;
  GLXWinConfig *winConfig = (GLXWinConfig *)config;
d1020 2
a1021 1
  GLWIN_DEBUG_MSG("glxWinSetPixelFormat: pixelFormatIndex %d", winConfig->pixelFormatIndex);
d1023 13
a1035 12
  /*
    Normally, we can just use the the pixelFormatIndex corresponding
    to the fbconfig which has been specified by the client
  */

  if (!((bppOverride && (bppOverride != (config->redBits + config->greenBits + config->blueBits) ))
        || ((config->drawableType & drawableTypeOverride) == 0)))
    {
      if (!SetPixelFormat(hdc, winConfig->pixelFormatIndex, NULL))
        {
          ErrorF("SetPixelFormat error: %s\n", glxWinErrorMessage());
          return FALSE;
d1038 1
a1038 1
      return TRUE;
d1041 3
a1043 3
  /*
    However, in certain special cases this pixel format will be incompatible with the
    use we are going to put it to, so we need to re-evaluate the pixel format to use:
d1045 1
a1045 1
    1) When PFD_DRAW_TO_BITMAP is set, ChoosePixelFormat() always returns a format with
d1048 1
a1048 1
    2) Applications may assume that visuals selected with glXChooseVisual() work with
d1057 5
a1061 3
   */
  ErrorF("glxWinSetPixelFormat: having second thoughts: cColorbits %d, bppOveride %d; config->drawableType %d, drawableTypeOverride %d\n",
         (config->redBits + config->greenBits + config->blueBits), bppOverride, config->drawableType, drawableTypeOverride);
d1063 3
a1065 4
  if (!winScreen->has_WGL_ARB_pixel_format)
    {
      PIXELFORMATDESCRIPTOR pfd;
      int pixelFormat;
d1067 4
a1070 5
      /* convert fbConfig to PFD */
      if (fbConfigToPixelFormat(gc->base.config, &pfd, drawableTypeOverride))
        {
          ErrorF("glxWinSetPixelFormat: fbConfigToPixelFormat failed\n");
          return FALSE;
d1073 2
a1074 2
      if (glxWinDebugSettings.dumpPFD)
        pfdOut(&pfd);
d1076 4
a1079 4
      if (bppOverride)
        {
          GLWIN_DEBUG_MSG("glxWinSetPixelFormat: Forcing bpp from %d to %d\n", pfd.cColorBits, bppOverride);
          pfd.cColorBits = bppOverride;
d1082 4
a1085 5
      pixelFormat = ChoosePixelFormat(hdc, &pfd);
      if (pixelFormat == 0)
        {
          ErrorF("ChoosePixelFormat error: %s\n", glxWinErrorMessage());
          return FALSE;
d1088 5
a1092 2
      GLWIN_DEBUG_MSG("ChoosePixelFormat: chose pixelFormatIndex %d", pixelFormat);
      ErrorF("ChoosePixelFormat: chose pixelFormatIndex %d (rather than %d as originally planned)\n", pixelFormat, winConfig->pixelFormatIndex);
d1094 3
a1096 4
      if (!SetPixelFormat(hdc, pixelFormat, &pfd))
        {
          ErrorF("SetPixelFormat error: %s\n", glxWinErrorMessage());
          return FALSE;
d1099 7
a1105 7
  else
    {
      int pixelFormat = fbConfigToPixelFormatIndex(hdc, gc->base.config, drawableTypeOverride, winScreen);
      if (pixelFormat == 0)
        {
          ErrorF("wglChoosePixelFormat error: %s\n", glxWinErrorMessage());
          return FALSE;
d1108 5
a1112 2
      GLWIN_DEBUG_MSG("wglChoosePixelFormat: chose pixelFormatIndex %d", pixelFormat);
      ErrorF("wglChoosePixelFormat: chose pixelFormatIndex %d (rather than %d as originally planned)\n", pixelFormat, winConfig->pixelFormatIndex);
d1114 3
a1116 4
      if (!SetPixelFormat(hdc, pixelFormat, NULL))
        {
          ErrorF("SetPixelFormat error: %s\n", glxWinErrorMessage());
          return FALSE;
d1120 1
a1120 1
  return TRUE;
d1124 2
a1125 1
glxWinMakeDC(__GLXWinContext *gc, __GLXWinDrawable *draw, HDC *hdc, HWND *hwnd)
d1127 2
a1128 2
  *hdc = NULL;
  *hwnd = NULL;
d1130 4
a1133 4
  if (draw == NULL)
    {
      GLWIN_TRACE_MSG("No drawable for context %p (native ctx %p)", gc, gc->ctx);
      return NULL;
d1136 1
a1136 2
  switch (draw->base.type)
  {
d1139 1
a1139 1
      WindowPtr pWin;
d1141 4
a1144 5
      pWin = (WindowPtr) draw->base.pDraw;
      if (pWin == NULL)
        {
          GLWIN_TRACE_MSG("for drawable %p, no WindowPtr", pWin);
          return NULL;
d1147 1
a1147 1
      *hwnd = winGetWindowInfo(pWin);
d1149 3
a1151 4
      if (*hwnd == NULL)
        {
          ErrorF("No HWND error: %s\n", glxWinErrorMessage());
          return NULL;
d1154 1
a1154 1
      *hdc = GetDC(*hwnd);
d1156 2
a1157 2
      if (*hdc == NULL)
        ErrorF("GetDC error: %s\n", glxWinErrorMessage());
d1159 4
a1162 5
      /* Check if the hwnd has changed... */
      if (*hwnd != gc->hwnd)
        {
          if (glxWinDebugSettings.enableTrace)
            GLWIN_DEBUG_HWND(*hwnd);
d1164 4
a1167 2
          GLWIN_TRACE_MSG("for context %p (native ctx %p), hWnd changed from %p to %p", gc, gc->ctx, gc->hwnd, *hwnd);
          gc->hwnd = *hwnd;
d1169 7
a1175 7
          /* We must select a pixelformat, but SetPixelFormat can only be called once for a window... */
          if (!glxWinSetPixelFormat(gc, *hdc, 0, GLX_WINDOW_BIT))
            {
              ErrorF("glxWinSetPixelFormat error: %s\n", glxWinErrorMessage());
              ReleaseDC(*hwnd, *hdc);
              *hdc = NULL;
              return NULL;
d1179 1
a1179 1
    break;
d1181 1
a1181 1
  case GLX_DRAWABLE_PBUFFER:
d1183 1
a1183 1
      *hdc = wglGetPbufferDCARBWrapper(draw->hPbuffer);
d1185 2
a1186 2
      if (*hdc == NULL)
        ErrorF("GetDC (pbuffer) error: %s\n", glxWinErrorMessage());
d1188 1
a1188 1
    break;
d1190 1
a1190 1
  case GLX_DRAWABLE_PIXMAP:
d1192 1
a1192 1
      *hdc = draw->dibDC;
d1194 1
a1194 1
    break;
d1196 1
a1196 1
  default:
d1198 3
a1200 1
      ErrorF("glxWinMakeDC: tried to makeDC for unhandled drawable type %d\n", draw->base.type);
a1201 1
  }
d1203 2
a1204 2
  if (glxWinDebugSettings.dumpDC)
    GLWIN_DEBUG_MSG("Got HDC %p", *hdc);
d1206 1
a1206 1
  return *hdc;
d1210 1
a1210 1
glxWinReleaseDC(HWND hwnd, HDC hdc,__GLXWinDrawable *draw)
d1212 1
a1212 2
  switch (draw->base.type)
  {
d1215 1
a1215 1
      ReleaseDC(hwnd, hdc);
d1217 1
a1217 1
    break;
d1219 1
a1219 1
  case GLX_DRAWABLE_PBUFFER:
d1221 2
a1222 3
      if (!wglReleasePbufferDCARBWrapper(draw->hPbuffer, hdc))
        {
          ErrorF("wglReleasePbufferDCARB error: %s\n", glxWinErrorMessage());
d1225 1
a1225 1
    break;
d1227 1
a1227 1
  case GLX_DRAWABLE_PIXMAP:
d1229 1
a1229 1
      // don't release DC, the memory DC lives as long as the bitmap
d1231 3
a1233 3
      // We must ensure that all GDI drawing into the bitmap has completed
      // in case we subsequently access the bits from it
      GdiFlush();
d1235 1
a1235 1
    break;
d1237 1
a1237 1
  default:
d1239 4
a1242 1
      ErrorF("glxWinReleaseDC: tried to releaseDC for unhandled drawable type %d\n", draw->base.type);
a1243 1
  }
d1247 1
a1247 1
glxWinDeferredCreateContext(__GLXWinContext *gc, __GLXWinDrawable *draw)
d1249 2
a1250 3
  HDC dc;
  HWND hwnd;
  GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: attach context %p to drawable %p", gc, draw);
d1252 5
a1256 2
  switch (draw->base.type)
  {
d1259 1
a1259 1
      WindowPtr pWin = (WindowPtr) draw->base.pDraw;
d1261 3
a1263 3
      if (!(gc->base.config->drawableType & GLX_WINDOW_BIT))
        {
          ErrorF("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_WINDOW_BIT to a GLX_DRAWABLE_WINDOW drawable\n");
d1266 3
a1268 4
      if (pWin == NULL)
        {
          GLWIN_DEBUG_MSG("Deferring until X window is created");
          return;
d1271 1
a1271 1
      GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: pWin %p", pWin);
d1273 3
a1275 4
      if (winGetWindowInfo(pWin) == NULL)
        {
          GLWIN_DEBUG_MSG("Deferring until native window is created");
          return;
d1278 1
a1278 1
    break;
d1282 11
a1292 11
      if (draw->hPbuffer == NULL)
        {
          __GLXscreen *screen;
          glxWinScreen *winScreen;
          int pixelFormat;
          // XXX: which DC are supposed to use???
          HDC screenDC = GetDC(NULL);

          if (!(gc->base.config->drawableType & GLX_PBUFFER_BIT))
            {
              ErrorF("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_PBUFFER_BIT to a GLX_DRAWABLE_PBUFFER drawable\n");
d1295 2
a1296 2
          screen = gc->base.pGlxScreen;
          winScreen = (glxWinScreen *)screen;
d1298 7
a1304 5
          pixelFormat = fbConfigToPixelFormatIndex(screenDC, gc->base.config, GLX_DRAWABLE_PBUFFER, winScreen);
          if (pixelFormat == 0)
            {
              ErrorF("wglChoosePixelFormat error: %s\n", glxWinErrorMessage());
              return;
d1307 10
a1316 7
          draw->hPbuffer = wglCreatePbufferARBWrapper(screenDC, pixelFormat, draw->base.pDraw->width, draw->base.pDraw->height, NULL);
          ReleaseDC(NULL, screenDC);

          if (draw->hPbuffer == NULL)
            {
              ErrorF("wglCreatePbufferARBWrapper error: %s\n", glxWinErrorMessage());
              return;
d1319 3
a1321 1
          GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: pBuffer %p created for drawable %p", draw->hPbuffer, draw);
d1324 1
a1324 1
    break;
d1328 15
a1342 16
      if (draw->dibDC == NULL)
        {
          BITMAPINFOHEADER bmpHeader;
          void *pBits;

          memset (&bmpHeader, 0, sizeof(BITMAPINFOHEADER));
          bmpHeader.biSize = sizeof(BITMAPINFOHEADER);
          bmpHeader.biWidth = draw->base.pDraw->width;
          bmpHeader.biHeight = draw->base.pDraw->height;
          bmpHeader.biPlanes = 1;
          bmpHeader.biBitCount = draw->base.pDraw->bitsPerPixel;
          bmpHeader.biCompression = BI_RGB;

          if (!(gc->base.config->drawableType & GLX_PIXMAP_BIT))
            {
              ErrorF("glxWinDeferredCreateContext: tried to attach a context whose fbConfig doesn't have drawableType GLX_PIXMAP_BIT to a GLX_DRAWABLE_PIXMAP drawable\n");
d1345 4
a1348 5
          draw->dibDC = CreateCompatibleDC(NULL);
          if (draw->dibDC == NULL)
            {
              ErrorF("CreateCompatibleDC error: %s\n", glxWinErrorMessage());
              return;
d1351 6
a1356 5
          draw->hDIB = CreateDIBSection(draw->dibDC, (BITMAPINFO *)&bmpHeader, DIB_RGB_COLORS, &pBits, 0, 0);
          if (draw->dibDC == NULL)
            {
              ErrorF("CreateDIBSection error: %s\n", glxWinErrorMessage());
              return;
d1359 11
a1369 12
          // XXX: CreateDIBSection insists on allocating the bitmap memory for us, so we're going to
          // need some jiggery pokery to point the underlying X Drawable's bitmap at the same set of bits
          // so that they can be read with XGetImage as well as glReadPixels, assuming the formats are
          // even compatible ...
          draw->pOldBits = ((PixmapPtr)draw->base.pDraw)->devPrivate.ptr;
          ((PixmapPtr)draw->base.pDraw)->devPrivate.ptr = pBits;

          // Select the DIB into the DC
          draw->hOldDIB = SelectObject(draw->dibDC, draw->hDIB);
          if (!draw->hOldDIB)
            {
              ErrorF("SelectObject error: %s\n", glxWinErrorMessage());
d1372 4
a1375 2
          // Set the pixel format of the bitmap
          glxWinSetPixelFormat(gc, draw->dibDC, draw->base.pDraw->bitsPerPixel, GLX_PIXMAP_BIT);
d1377 3
a1379 1
          GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: DIB bitmap %p created for drawable %p", draw->hDIB, draw);
d1382 1
a1382 1
    break;
d1386 5
a1390 2
      ErrorF("glxWinDeferredCreateContext: tried to attach unhandled drawable type %d\n", draw->base.type);
      return;
a1391 1
  }
d1393 3
a1395 3
  dc = glxWinMakeDC(gc, draw, &dc, &hwnd);
  gc->ctx = wglCreateContext(dc);
  glxWinReleaseDC(hwnd, dc, draw);
d1397 3
a1399 4
  if (gc->ctx == NULL)
    {
      ErrorF("wglCreateContext error: %s\n", glxWinErrorMessage());
      return;
d1402 9
a1410 6
  GLWIN_DEBUG_MSG("glxWinDeferredCreateContext: attached context %p to native context %p drawable %p", gc, gc->ctx, draw);

  // if the native context was created successfully, shareLists if needed
  if (gc->ctx && gc->shareContext)
    {
      GLWIN_DEBUG_MSG("glxWinCreateContextReal shareLists with context %p (native ctx %p)", gc->shareContext, gc->shareContext->ctx);
d1412 2
a1413 3
      if (!wglShareLists(gc->shareContext->ctx, gc->ctx))
        {
          ErrorF("wglShareLists error: %s\n", glxWinErrorMessage());
a1422 1

d1425 1
a1425 1
glxWinContextMakeCurrent(__GLXcontext *base)
d1427 8
a1434 15
  __GLXWinContext *gc = (__GLXWinContext *)base;
  BOOL ret;
  HDC drawDC;
  HDC readDC = NULL;
  __GLXdrawable *drawPriv;
  __GLXdrawable *readPriv = NULL;
  HWND hDrawWnd;
  HWND hReadWnd;

  GLWIN_TRACE_MSG("glxWinContextMakeCurrent context %p (native ctx %p)", gc, gc->ctx);
  glWinCallDelta();

  /* Keep a note of the last active context in the drawable */
  drawPriv = gc->base.drawPriv;
  ((__GLXWinDrawable *)drawPriv)->drawContext = gc;
d1436 10
a1445 3
  if (gc->ctx == NULL)
    {
      glxWinDeferredCreateContext(gc, (__GLXWinDrawable *)drawPriv);
d1448 3
a1450 4
  if (gc->ctx == NULL)
    {
      ErrorF("glxWinContextMakeCurrent: Native context is NULL\n");
      return FALSE;
d1453 5
a1457 5
  drawDC = glxWinMakeDC(gc, (__GLXWinDrawable *)drawPriv, &drawDC, &hDrawWnd);
  if (drawDC == NULL)
    {
      ErrorF("glxWinMakeDC failed for drawDC\n");
      return FALSE;
d1460 14
a1473 15
  if ((gc->base.readPriv != NULL) && (gc->base.readPriv != gc->base.drawPriv))
    {
      // XXX: should only occur with WGL_ARB_make_current_read
      /*
        If there is a separate read drawable, create a separate read DC, and
        use the wglMakeContextCurrent extension to make the context current drawing
        to one DC and reading from the other
      */
      readPriv = gc->base.readPriv;
      readDC = glxWinMakeDC(gc, (__GLXWinDrawable *)readPriv, &readDC, &hReadWnd);
      if (readDC == NULL)
        {
          ErrorF("glxWinMakeDC failed for readDC\n");
          glxWinReleaseDC(hDrawWnd, drawDC, (__GLXWinDrawable *)drawPriv);
          return FALSE;
d1476 4
a1479 4
      ret = wglMakeContextCurrentARBWrapper(drawDC, readDC, gc->ctx);
      if (!ret)
        {
          ErrorF("wglMakeContextCurrentARBWrapper error: %s\n", glxWinErrorMessage());
d1482 5
a1486 7
  else
    {
      /* Otherwise, just use wglMakeCurrent */
      ret = wglMakeCurrent(drawDC, gc->ctx);
      if (!ret)
        {
          ErrorF("wglMakeCurrent error: %s\n", glxWinErrorMessage());
d1490 2
a1491 2
  // apparently make current could fail if the context is current in a different thread,
  // but that shouldn't be able to happen in the current server...
d1493 3
a1495 3
  glxWinReleaseDC(hDrawWnd, drawDC, (__GLXWinDrawable *)drawPriv);
  if (readDC)
    glxWinReleaseDC(hReadWnd, readDC, (__GLXWinDrawable *)readPriv);
d1497 1
a1497 1
  return ret;
d1501 1
a1501 1
glxWinContextLoseCurrent(__GLXcontext *base)
d1503 2
a1504 2
  BOOL ret;
  __GLXWinContext *gc = (__GLXWinContext *)base;
d1506 3
a1508 2
  GLWIN_TRACE_MSG("glxWinContextLoseCurrent context %p (native ctx %p)", gc, gc->ctx);
  glWinCallDelta();
d1510 9
a1518 9
  /*
     An error seems to be reported if we try to make no context current
     if there is already no current context, so avoid doing that...
  */
  if (__glXLastContext != NULL)
    {
      ret = wglMakeCurrent(NULL, NULL); /* We don't need a DC when setting no current context */
      if (!ret)
        ErrorF("glxWinContextLoseCurrent error: %s\n", glxWinErrorMessage());
d1521 1
a1521 1
  return TRUE;
d1525 2
a1526 1
glxWinContextCopy(__GLXcontext *dst_base, __GLXcontext *src_base, unsigned long mask)
d1528 3
a1530 3
  __GLXWinContext *dst = (__GLXWinContext *)dst_base;
  __GLXWinContext *src = (__GLXWinContext *)src_base;
  BOOL ret;
d1532 1
a1532 1
  GLWIN_DEBUG_MSG("glxWinContextCopy");
d1534 3
a1536 4
  ret = wglCopyContext(src->ctx, dst->ctx, mask);
  if (!ret)
    {
      ErrorF("wglCopyContext error: %s\n", glxWinErrorMessage());
d1539 1
a1539 1
  return ret;
d1543 1
a1543 1
glxWinContextDestroy(__GLXcontext *base)
d1545 1
a1545 1
  __GLXWinContext *gc = (__GLXWinContext *)base;
d1547 9
a1555 3
  if (gc != NULL)
    {
      GLWIN_DEBUG_MSG("GLXcontext %p destroyed (native ctx %p)", base, gc->ctx);
a1556 4
      if (gc->ctx)
        {
          /* It's bad style to delete the context while it's still current */
          if (wglGetCurrentContext() == gc->ctx)
d1558 5
a1562 1
              wglMakeCurrent(NULL, NULL);
d1565 1
a1565 7
          {
            BOOL ret = wglDeleteContext(gc->ctx);
            if (!ret)
              ErrorF("wglDeleteContext error: %s\n", glxWinErrorMessage());
          }

          gc->ctx = NULL;
d1568 1
a1568 1
      free(gc);
d1573 2
a1574 3
glxWinCreateContext(__GLXscreen *screen,
                   __GLXconfig *modes,
                   __GLXcontext *baseShareContext)
d1577 1
a1577 1
    __GLXWinContext *shareContext = (__GLXWinContext *)baseShareContext;
d1579 1
a1579 2
    static __GLXtextureFromPixmap glxWinTextureFromPixmap =
      {
d1582 1
a1582 1
      };
d1584 1
a1584 1
    context = (__GLXWinContext *)calloc(1, sizeof(__GLXWinContext));
d1590 4
a1593 4
    context->base.destroy        = glxWinContextDestroy;
    context->base.makeCurrent    = glxWinContextMakeCurrent;
    context->base.loseCurrent    = glxWinContextLoseCurrent;
    context->base.copy           = glxWinContextCopy;
d1615 2
a1616 1
fbConfigToPixelFormat(__GLXconfig *mode, PIXELFORMATDESCRIPTOR *pfdret, int drawableTypeOverride)
d1619 16
a1634 16
      sizeof(PIXELFORMATDESCRIPTOR),   /* size of this pfd */
      1,                     /* version number */
      PFD_SUPPORT_OPENGL,    /* support OpenGL */
      PFD_TYPE_RGBA,         /* RGBA type */
      24,                    /* 24-bit color depth */
      0, 0, 0, 0, 0, 0,      /* color bits ignored */
      0,                     /* no alpha buffer */
      0,                     /* shift bit ignored */
      0,                     /* no accumulation buffer */
      0, 0, 0, 0,            /* accum bits ignored */
      32,                    /* 32-bit z-buffer */
      0,                     /* no stencil buffer */
      0,                     /* no auxiliary buffer */
      PFD_MAIN_PLANE,        /* main layer */
      0,                     /* reserved */
      0, 0, 0                /* layer masks ignored */
d1638 1
a1638 1
      pfd.dwFlags |= PFD_DRAW_TO_WINDOW; /* support window */
d1641 1
a1641 1
      pfd.dwFlags |= (PFD_DRAW_TO_BITMAP | PFD_SUPPORT_GDI); /* supports software rendering to bitmap */
d1653 1
a1653 1
    pfd.cRedShift = 0; /* FIXME */
d1655 1
a1655 1
    pfd.cGreenShift = 0; /* FIXME  */
d1657 1
a1657 1
    pfd.cBlueShift = 0; /* FIXME */
d1659 1
a1659 1
    pfd.cAlphaShift = 0; /* FIXME */
d1661 3
a1663 1
    pfd.cAccumBits = mode->accumRedBits + mode->accumGreenBits + mode->accumBlueBits + mode->accumAlphaBits;
d1684 2
a1685 1
fbConfigToPixelFormatIndex(HDC hdc, __GLXconfig *mode, int drawableTypeOverride, glxWinScreen *winScreen)
d1687 42
a1728 2
  UINT numFormats;
  unsigned int i = 0;
d1730 3
a1732 2
  /* convert fbConfig to attr-value list  */
  int attribList[60];
d1734 5
a1738 42
  SET_ATTR_VALUE(WGL_SUPPORT_OPENGL_ARB, TRUE);
  SET_ATTR_VALUE(WGL_PIXEL_TYPE_ARB, (mode->visualType == GLX_TRUE_COLOR) ? WGL_TYPE_RGBA_ARB : WGL_TYPE_COLORINDEX_ARB);
  SET_ATTR_VALUE(WGL_COLOR_BITS_ARB, (mode->visualType == GLX_TRUE_COLOR) ? mode->rgbBits : mode->indexBits);
  SET_ATTR_VALUE(WGL_RED_BITS_ARB, mode->redBits);
  SET_ATTR_VALUE(WGL_GREEN_BITS_ARB, mode->greenBits);
  SET_ATTR_VALUE(WGL_BLUE_BITS_ARB, mode->blueBits);
  SET_ATTR_VALUE(WGL_ALPHA_BITS_ARB, mode->alphaBits);
  SET_ATTR_VALUE(WGL_ACCUM_RED_BITS_ARB, mode->accumRedBits);
  SET_ATTR_VALUE(WGL_ACCUM_GREEN_BITS_ARB, mode->accumGreenBits);
  SET_ATTR_VALUE(WGL_ACCUM_BLUE_BITS_ARB, mode->accumBlueBits);
  SET_ATTR_VALUE(WGL_ACCUM_ALPHA_BITS_ARB, mode->accumAlphaBits);
  SET_ATTR_VALUE(WGL_DEPTH_BITS_ARB, mode->depthBits);
  SET_ATTR_VALUE(WGL_STENCIL_BITS_ARB, mode->stencilBits);
  SET_ATTR_VALUE(WGL_AUX_BUFFERS_ARB, mode->numAuxBuffers);

  if (mode->doubleBufferMode)
    SET_ATTR_VALUE(WGL_DOUBLE_BUFFER_ARB, TRUE);

  if (mode->stereoMode)
    SET_ATTR_VALUE(WGL_STEREO_ARB, TRUE);

  // Some attributes are only added to the list if the value requested is not 'don't care', as exactly matching that is daft..
  if (mode->swapMethod == GLX_SWAP_EXCHANGE_OML)
    SET_ATTR_VALUE(WGL_SWAP_METHOD_ARB, WGL_SWAP_EXCHANGE_ARB);

  if (mode->swapMethod == GLX_SWAP_COPY_OML)
    SET_ATTR_VALUE(WGL_SWAP_COPY_ARB, TRUE);

  // XXX: this should probably be the other way around, but that messes up drawableTypeOverride
  if (mode->visualRating == GLX_SLOW_VISUAL_EXT)
    SET_ATTR_VALUE(WGL_ACCELERATION_ARB, WGL_NO_ACCELERATION_ARB);

  // must support all the drawable types the mode supports
  if ((mode->drawableType | drawableTypeOverride) & GLX_WINDOW_BIT)
    SET_ATTR_VALUE(WGL_DRAW_TO_WINDOW_ARB,TRUE);

  // XXX: this is a horrible hacky heuristic, in fact this whole drawableTypeOverride thing is a bad idea
  // try to avoid asking for formats which don't exist (by not asking for all when adjusting the config to include the drawableTypeOverride)
  if (drawableTypeOverride == GLX_WINDOW_BIT)
    {
      if (mode->drawableType & GLX_PIXMAP_BIT)
        SET_ATTR_VALUE(WGL_DRAW_TO_BITMAP_ARB, TRUE);
d1740 3
a1742 3
      if (mode->drawableType & GLX_PBUFFER_BIT)
        if (winScreen->has_WGL_ARB_pbuffer)
          SET_ATTR_VALUE(WGL_DRAW_TO_PBUFFER_ARB, TRUE);
d1744 3
a1746 4
  else
    {
      if (drawableTypeOverride & GLX_PIXMAP_BIT)
        SET_ATTR_VALUE(WGL_DRAW_TO_BITMAP_ARB, TRUE);
d1748 3
a1750 3
      if (drawableTypeOverride & GLX_PBUFFER_BIT)
        if (winScreen->has_WGL_ARB_pbuffer)
          SET_ATTR_VALUE(WGL_DRAW_TO_PBUFFER_ARB, TRUE);
d1753 1
a1753 1
  SET_ATTR_VALUE(0, 0); // terminator
d1755 3
a1757 3
  /* choose the first match */
  {
    int pixelFormatIndex;
d1759 15
a1773 15
    if (!wglChoosePixelFormatARBWrapper(hdc, attribList, NULL, 1, &pixelFormatIndex, &numFormats))
      {
        ErrorF("wglChoosePixelFormat error: %s\n", glxWinErrorMessage());
      }
    else
      {
        if (numFormats > 0)
          {
            GLWIN_DEBUG_MSG("wglChoosePixelFormat: chose pixelFormatIndex %d)", pixelFormatIndex);
            return pixelFormatIndex;
          }
        else
          ErrorF("wglChoosePixelFormat couldn't decide\n");
      }
  }
d1775 1
a1775 1
  return 0;
d1786 1
a1786 1
glxWinCreateConfigs(HDC hdc, glxWinScreen *screen)
d1788 5
a1792 5
  GLXWinConfig *c, *result, *prev = NULL;
  int numConfigs = 0;
  int i = 0;
  int n = 0;
  PIXELFORMATDESCRIPTOR pfd;
d1794 1
a1794 1
  GLWIN_DEBUG_MSG("glxWinCreateConfigs");
d1796 2
a1797 2
  screen->base.numFBConfigs = 0;
  screen->base.fbconfigs = NULL;
d1799 5
a1803 3
  // get the number of pixelformats
  numConfigs = DescribePixelFormat(hdc, 1, sizeof(PIXELFORMATDESCRIPTOR), NULL);
  GLWIN_DEBUG_MSG("DescribePixelFormat says %d possible pixel formats", numConfigs);
d1805 2
a1806 2
  /* alloc */
  result = malloc(sizeof(GLXWinConfig) * numConfigs);
d1808 2
a1809 3
  if (NULL == result)
    {
      return;
d1812 2
a1813 2
  memset(result, 0, sizeof(GLXWinConfig) * numConfigs);
  n = 0;
d1815 3
a1817 4
  /* fill in configs */
  for (i = 0;  i < numConfigs; i++)
    {
      int rc;
d1819 3
a1821 3
      c = &(result[i]);
      c->base.next = NULL;
      c->pixelFormatIndex = i+1;
d1823 2
a1824 1
      rc = DescribePixelFormat(hdc, i+1, sizeof(PIXELFORMATDESCRIPTOR), &pfd);
d1826 4
a1829 4
      if (!rc)
        {
          ErrorF("DescribePixelFormat failed for index %d, error %s\n", i+1, glxWinErrorMessage());
          break;
d1832 2
a1833 2
      if (glxWinDebugSettings.dumpPFD)
        pfdOut(&pfd);
d1835 6
a1840 4
      if (!(pfd.dwFlags & (PFD_DRAW_TO_WINDOW | PFD_DRAW_TO_BITMAP)) || !(pfd.dwFlags & PFD_SUPPORT_OPENGL))
        {
          GLWIN_DEBUG_MSG("pixelFormat %d has unsuitable flags 0x%08lx, skipping", i+1, pfd.dwFlags);
          continue;
d1843 3
a1845 2
      c->base.doubleBufferMode = (pfd.dwFlags & PFD_DOUBLEBUFFER) ? GL_TRUE : GL_FALSE;
      c->base.stereoMode = (pfd.dwFlags & PFD_STEREO) ? GL_TRUE : GL_FALSE;
d1847 4
a1850 4
      c->base.redBits = pfd.cRedBits;
      c->base.greenBits = pfd.cGreenBits;
      c->base.blueBits = pfd.cBlueBits;
      c->base.alphaBits = pfd.cAlphaBits;
d1852 7
a1858 4
      c->base.redMask = BITS_AND_SHIFT_TO_MASK(pfd.cRedBits, pfd.cRedShift);
      c->base.greenMask =  BITS_AND_SHIFT_TO_MASK(pfd.cGreenBits, pfd.cGreenShift);
      c->base.blueMask = BITS_AND_SHIFT_TO_MASK(pfd.cBlueBits, pfd.cBlueShift);
      c->base.alphaMask = BITS_AND_SHIFT_TO_MASK(pfd.cAlphaBits, pfd.cAlphaShift);
d1860 1
a1860 1
      c->base.rgbBits = pfd.cColorBits;
d1862 2
a1863 3
      if (pfd.iPixelType == PFD_TYPE_COLORINDEX)
        {
          c->base.indexBits = pfd.cColorBits;
d1865 2
a1866 3
      else
        {
          c->base.indexBits = 0;
d1869 5
a1873 5
      c->base.accumRedBits = pfd.cAccumRedBits;
      c->base.accumGreenBits = pfd.cAccumGreenBits;
      c->base.accumBlueBits = pfd.cAccumBlueBits;
      c->base.accumAlphaBits = pfd.cAccumAlphaBits;
      //  pfd.cAccumBits;
d1875 3
a1877 3
      c->base.depthBits = pfd.cDepthBits;
      c->base.stencilBits = pfd.cStencilBits;
      c->base.numAuxBuffers = pfd.cAuxBuffers;
d1879 4
a1882 4
      // pfd.iLayerType; // ignored
      c->base.level = 0;
      // pfd.dwLayerMask; // ignored
      // pfd.dwDamageMask;  // ignored
d1884 2
a1885 2
      c->base.pixmapMode = 0;
      c->base.visualID = -1;  // will be set by __glXScreenInit()
d1887 3
a1889 4
      /* EXT_visual_rating / GLX 1.2 */
      if (pfd.dwFlags & PFD_GENERIC_FORMAT)
        {
          c->base.visualRating = GLX_SLOW_VISUAL_EXT;
d1891 3
a1893 4
      else
        {
          // PFD_GENERIC_ACCELERATED is not considered, so this may be MCD or ICD acclerated...
          c->base.visualRating = GLX_NONE_EXT;
d1896 3
a1898 4
      /* EXT_visual_info / GLX 1.2 */
      if (pfd.iPixelType == PFD_TYPE_COLORINDEX)
        {
          c->base.visualType = GLX_STATIC_COLOR;
d1900 4
a1903 4
          if (!getenv("GLWIN_ENABLE_COLORINDEX_FBCONFIGS"))
            {
              GLWIN_DEBUG_MSG("pixelFormat %d is PFD_TYPE_COLORINDEX, skipping", i+1);
              continue;
d1906 2
a1907 28
      else
        {
          c->base.visualType = GLX_TRUE_COLOR;
        }

      // pfd.dwVisibleMask; ???
      c->base.transparentPixel = GLX_NONE;
      c->base.transparentRed = GLX_NONE;
      c->base.transparentGreen = GLX_NONE;
      c->base.transparentBlue = GLX_NONE;
      c->base.transparentAlpha = GLX_NONE;
      c->base.transparentIndex = GLX_NONE;

      /* ARB_multisample / SGIS_multisample */
      c->base.sampleBuffers = 0;
      c->base.samples = 0;

      /* SGIX_fbconfig / GLX 1.3 */
      c->base.drawableType = (((pfd.dwFlags & PFD_DRAW_TO_WINDOW) ? GLX_WINDOW_BIT : 0)
                         | ((pfd.dwFlags & PFD_DRAW_TO_BITMAP) ? GLX_PIXMAP_BIT : 0));

      if (pfd.iPixelType == PFD_TYPE_COLORINDEX)
        {
          c->base.renderType = GLX_RGBA_BIT | GLX_COLOR_INDEX_BIT;
        }
      else
        {
          c->base.renderType = GLX_RGBA_BIT;
d1910 38
a1947 15
      c->base.xRenderable = GL_TRUE;
      c->base.fbconfigID = -1; // will be set by __glXScreenInit()

      /* SGIX_pbuffer / GLX 1.3 */
      // XXX: How can we find these values out ???
      c->base.maxPbufferWidth = -1;
      c->base.maxPbufferHeight = -1;
      c->base.maxPbufferPixels = -1;
      c->base.optimalPbufferWidth = 0; // there is no optimal value
      c->base.optimalPbufferHeight = 0;

      /* SGIX_visual_select_group */
      // arrange for visuals with the best acceleration to be preferred in selection
      switch (pfd.dwFlags & (PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED))
        {
d1949 2
a1950 2
          c->base.visualSelectGroup = 2;
          break;
d1953 2
a1954 2
          c->base.visualSelectGroup = 1;
          break;
d1957 2
a1958 2
          c->base.visualSelectGroup = 0;
          break;
d1961 2
a1962 2
          ;
          // "can't happen"
d1965 7
a1971 7
      /* OML_swap_method */
      if (pfd.dwFlags & PFD_SWAP_EXCHANGE)
        c->base.swapMethod = GLX_SWAP_EXCHANGE_OML;
      else if (pfd.dwFlags & PFD_SWAP_COPY)
        c->base.swapMethod = GLX_SWAP_COPY_OML;
      else
        c->base.swapMethod = GLX_SWAP_UNDEFINED_OML;
d1973 2
a1974 2
      /* EXT_import_context */
      c->base.screen = screen->base.pScreen->myNum;
d1976 6
a1981 6
      /* EXT_texture_from_pixmap */
      c->base.bindToTextureRgb = -1;
      c->base.bindToTextureRgba = -1;
      c->base.bindToMipmapTexture = -1;
      c->base.bindToTextureTargets = -1;
      c->base.yInverted = -1;
d1983 1
a1983 1
      n++;
d1985 3
a1987 3
      // update previous config to point to this config
      if (prev)
        prev->base.next = &(c->base);
d1989 1
a1989 1
      prev = c;
d1992 2
a1993 1
  GLWIN_DEBUG_MSG("found %d pixelFormats suitable for conversion to fbConfigs", n);
d1995 2
a1996 2
  screen->base.numFBConfigs = n;
  screen->base.fbconfigs = &(result->base);
d2001 3
a2003 1
int getAttrValue(const int attrs[], int values[], unsigned int num, int attr, int fallback)
d2005 7
a2011 7
  unsigned int i;
  for (i = 0; i < num; i++)
    {
      if (attrs[i] == attr)
        {
          GLWIN_TRACE_MSG("getAttrValue attr 0x%x, value %d", attr, values[i]);
          return values[i];
d2015 3
a2017 2
  ErrorF("getAttrValue failed to find attr 0x%x, using default value %d\n", attr, fallback);
  return fallback;
d2024 1
a2024 1
glxWinCreateConfigsExt(HDC hdc, glxWinScreen *screen)
d2026 3
a2028 3
  GLXWinConfig *c, *result, *prev = NULL;
  int i = 0;
  int n = 0;
d2030 2
a2031 2
  const int attr = WGL_NUMBER_PIXEL_FORMATS_ARB;
  int numConfigs;
d2033 2
a2034 2
  int attrs[50];
  unsigned int num_attrs = 0;
d2036 1
a2036 1
  GLWIN_DEBUG_MSG("glxWinCreateConfigsExt");
d2038 2
a2039 2
  screen->base.numFBConfigs = 0;
  screen->base.fbconfigs = NULL;
d2041 5
a2045 4
  if (!wglGetPixelFormatAttribivARBWrapper(hdc, 0, 0, 1, &attr, &numConfigs))
    {
      ErrorF("wglGetPixelFormatAttribivARB failed for WGL_NUMBER_PIXEL_FORMATS_ARB: %s\n", glxWinErrorMessage());
      return;
d2048 3
a2050 1
  GLWIN_DEBUG_MSG("wglGetPixelFormatAttribivARB says %d possible pixel formats", numConfigs);
d2052 2
a2053 2
  /* alloc */
  result = malloc(sizeof(GLXWinConfig) * numConfigs);
d2055 2
a2056 3
  if (NULL == result)
    {
      return;
d2059 2
a2060 2
  memset(result, 0, sizeof(GLXWinConfig) * numConfigs);
  n = 0;
d2064 67
a2130 69
  ADD_ATTR(WGL_DRAW_TO_WINDOW_ARB);
  ADD_ATTR(WGL_DRAW_TO_BITMAP_ARB);
  ADD_ATTR(WGL_ACCELERATION_ARB);
  ADD_ATTR(WGL_SWAP_LAYER_BUFFERS_ARB);
  ADD_ATTR(WGL_NUMBER_OVERLAYS_ARB);
  ADD_ATTR(WGL_NUMBER_UNDERLAYS_ARB);
  ADD_ATTR(WGL_TRANSPARENT_ARB);
  ADD_ATTR(WGL_TRANSPARENT_RED_VALUE_ARB);
  ADD_ATTR(WGL_TRANSPARENT_GREEN_VALUE_ARB);
  ADD_ATTR(WGL_TRANSPARENT_GREEN_VALUE_ARB);
  ADD_ATTR(WGL_TRANSPARENT_ALPHA_VALUE_ARB);
  ADD_ATTR(WGL_SUPPORT_OPENGL_ARB);
  ADD_ATTR(WGL_DOUBLE_BUFFER_ARB);
  ADD_ATTR(WGL_STEREO_ARB);
  ADD_ATTR(WGL_PIXEL_TYPE_ARB);
  ADD_ATTR(WGL_COLOR_BITS_ARB);
  ADD_ATTR(WGL_RED_BITS_ARB);
  ADD_ATTR(WGL_RED_SHIFT_ARB);
  ADD_ATTR(WGL_GREEN_BITS_ARB);
  ADD_ATTR(WGL_GREEN_SHIFT_ARB);
  ADD_ATTR(WGL_BLUE_BITS_ARB);
  ADD_ATTR(WGL_BLUE_SHIFT_ARB);
  ADD_ATTR(WGL_ALPHA_BITS_ARB);
  ADD_ATTR(WGL_ALPHA_SHIFT_ARB);
  ADD_ATTR(WGL_ACCUM_RED_BITS_ARB);
  ADD_ATTR(WGL_ACCUM_GREEN_BITS_ARB);
  ADD_ATTR(WGL_ACCUM_BLUE_BITS_ARB);
  ADD_ATTR(WGL_ACCUM_ALPHA_BITS_ARB);
  ADD_ATTR(WGL_DEPTH_BITS_ARB);
  ADD_ATTR(WGL_STENCIL_BITS_ARB);
  ADD_ATTR(WGL_AUX_BUFFERS_ARB);
  ADD_ATTR(WGL_SWAP_METHOD_ARB);

  if (screen->has_WGL_ARB_multisample)
    {
      // we may not query these attrs if WGL_ARB_multisample is not offered
      ADD_ATTR(WGL_SAMPLE_BUFFERS_ARB);
      ADD_ATTR(WGL_SAMPLES_ARB);
    }

  if (screen->has_WGL_ARB_render_texture)
    {
      // we may not query these attrs if WGL_ARB_render_texture is not offered
      ADD_ATTR(WGL_BIND_TO_TEXTURE_RGB_ARB);
      ADD_ATTR(WGL_BIND_TO_TEXTURE_RGBA_ARB);
    }

  if (screen->has_WGL_ARB_pbuffer)
    {
      // we may not query these attrs if WGL_ARB_pbuffer is not offered
      ADD_ATTR(WGL_DRAW_TO_PBUFFER_ARB);
      ADD_ATTR(WGL_MAX_PBUFFER_PIXELS_ARB);
      ADD_ATTR(WGL_MAX_PBUFFER_WIDTH_ARB);
      ADD_ATTR(WGL_MAX_PBUFFER_HEIGHT_ARB);
    }

  /* fill in configs */
  for (i = 0;  i < numConfigs; i++)
    {
      int values[num_attrs];

      c = &(result[i]);
      c->base.next = NULL;
      c->pixelFormatIndex = i+1;

      if (!wglGetPixelFormatAttribivARBWrapper(hdc, i+1, 0, num_attrs, attrs, values))
        {
          ErrorF("wglGetPixelFormatAttribivARB failed for index %d, error %s\n", i+1, glxWinErrorMessage());
          break;
d2135 28
a2162 13
      if (!ATTR_VALUE(WGL_SUPPORT_OPENGL_ARB, 0))
        {
          GLWIN_DEBUG_MSG("pixelFormat %d isn't WGL_SUPPORT_OPENGL_ARB, skipping", i+1);
          continue;
        }

      c->base.doubleBufferMode = ATTR_VALUE(WGL_DOUBLE_BUFFER_ARB, 0) ? GL_TRUE : GL_FALSE;
      c->base.stereoMode = ATTR_VALUE(WGL_STEREO_ARB, 0) ? GL_TRUE : GL_FALSE;

      c->base.redBits = ATTR_VALUE(WGL_RED_BITS_ARB, 0);
      c->base.greenBits = ATTR_VALUE(WGL_GREEN_BITS_ARB, 0);
      c->base.blueBits = ATTR_VALUE(WGL_BLUE_BITS_ARB, 0);
      c->base.alphaBits = ATTR_VALUE(WGL_ALPHA_BITS_ARB, 0);
d2164 1
a2164 7
      c->base.redMask = BITS_AND_SHIFT_TO_MASK(c->base.redBits, ATTR_VALUE(WGL_RED_SHIFT_ARB, 0));
      c->base.greenMask = BITS_AND_SHIFT_TO_MASK(c->base.greenBits, ATTR_VALUE(WGL_GREEN_SHIFT_ARB, 0));
      c->base.blueMask = BITS_AND_SHIFT_TO_MASK(c->base.blueBits, ATTR_VALUE(WGL_BLUE_SHIFT_ARB, 0));
      c->base.alphaMask = BITS_AND_SHIFT_TO_MASK(c->base.alphaBits, ATTR_VALUE(WGL_ALPHA_SHIFT_ARB, 0));

      switch (ATTR_VALUE(WGL_PIXEL_TYPE_ARB, 0))
        {
d2166 9
a2174 8
          c->base.indexBits = ATTR_VALUE(WGL_COLOR_BITS_ARB, 0);
          c->base.rgbBits = 0;
          c->base.visualType = GLX_STATIC_COLOR;

          if (!getenv("GLWIN_ENABLE_COLORINDEX_FBCONFIGS"))
            {
              GLWIN_DEBUG_MSG("pixelFormat %d is WGL_TYPE_COLORINDEX_ARB, skipping", i+1);
              continue;
d2177 1
a2177 1
          break;
d2180 3
a2182 2
          GLWIN_DEBUG_MSG("pixelFormat %d is WGL_TYPE_RGBA_FLOAT_ARB, skipping", i+1);
          continue;
d2185 4
a2188 2
          GLWIN_DEBUG_MSG("pixelFormat %d is WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT, skipping", i+1);
          continue;
d2191 4
a2194 4
          c->base.indexBits = 0;
          c->base.rgbBits = ATTR_VALUE(WGL_COLOR_BITS_ARB, 0);
          c->base.visualType = GLX_TRUE_COLOR;
          break;
d2197 27
a2223 2
          ErrorF("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_PIXEL_TYPE_ARB\n", ATTR_VALUE(WGL_PIXEL_TYPE_ARB, 0));
          continue;
d2225 1
d2227 2
a2228 22
      c->base.accumRedBits = ATTR_VALUE(WGL_ACCUM_RED_BITS_ARB, 0);
      c->base.accumGreenBits = ATTR_VALUE(WGL_ACCUM_GREEN_BITS_ARB, 0);
      c->base.accumBlueBits = ATTR_VALUE(WGL_ACCUM_BLUE_BITS_ARB, 0);
      c->base.accumAlphaBits = ATTR_VALUE(WGL_ACCUM_ALPHA_BITS_ARB, 0);

      c->base.depthBits = ATTR_VALUE(WGL_DEPTH_BITS_ARB, 0);
      c->base.stencilBits = ATTR_VALUE(WGL_STENCIL_BITS_ARB, 0);
      c->base.numAuxBuffers = ATTR_VALUE(WGL_AUX_BUFFERS_ARB, 0);

      {
        int layers = ATTR_VALUE(WGL_NUMBER_OVERLAYS_ARB,0) + ATTR_VALUE(WGL_NUMBER_UNDERLAYS_ARB, 0);

        if (layers > 0)
          {
            ErrorF("pixelFormat %d: has %d overlay, %d underlays which aren't currently handled", i, ATTR_VALUE(WGL_NUMBER_OVERLAYS_ARB,0), ATTR_VALUE(WGL_NUMBER_UNDERLAYS_ARB, 0));
            // XXX: need to iterate over layers?
          }
      }
      c->base.level = 0;

      c->base.pixmapMode = 0; // ???
      c->base.visualID = -1;  // will be set by __glXScreenInit()
d2230 2
a2231 3
      /* EXT_visual_rating / GLX 1.2 */
      switch (ATTR_VALUE(WGL_ACCELERATION_ARB, 0))
        {
d2233 3
a2235 1
          ErrorF("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_ACCELERATION_ARB\n", ATTR_VALUE(WGL_ACCELERATION_ARB, 0));
d2238 2
a2239 2
          c->base.visualRating = GLX_SLOW_VISUAL_EXT;
          break;
d2243 2
a2244 30
          c->base.visualRating = GLX_NONE_EXT;
          break;
        }

      /* EXT_visual_info / GLX 1.2 */
      // c->base.visualType is set above
      if (ATTR_VALUE(WGL_TRANSPARENT_ARB, 0))
        {
          c->base.transparentPixel = (c->base.visualType == GLX_TRUE_COLOR) ? GLX_TRANSPARENT_RGB_EXT : GLX_TRANSPARENT_INDEX_EXT;
          c->base.transparentRed = ATTR_VALUE(WGL_TRANSPARENT_RED_VALUE_ARB, 0);
          c->base.transparentGreen = ATTR_VALUE(WGL_TRANSPARENT_GREEN_VALUE_ARB, 0);
          c->base.transparentBlue = ATTR_VALUE(WGL_TRANSPARENT_BLUE_VALUE_ARB, 0);
          c->base.transparentAlpha = ATTR_VALUE(WGL_TRANSPARENT_ALPHA_VALUE_ARB, 0);
          c->base.transparentIndex = ATTR_VALUE(WGL_TRANSPARENT_INDEX_VALUE_ARB, 0);
        }
      else
        {
          c->base.transparentPixel = GLX_NONE_EXT;
          c->base.transparentRed = GLX_NONE;
          c->base.transparentGreen = GLX_NONE;
          c->base.transparentBlue = GLX_NONE;
          c->base.transparentAlpha = GLX_NONE;
          c->base.transparentIndex = GLX_NONE;
        }

      /* ARB_multisample / SGIS_multisample */
      if (screen->has_WGL_ARB_multisample)
        {
          c->base.sampleBuffers = ATTR_VALUE(WGL_SAMPLE_BUFFERS_ARB, 0);
          c->base.samples = ATTR_VALUE(WGL_SAMPLES_ARB, 0);
a2245 30
      else
        {
          c->base.sampleBuffers = 0;
          c->base.samples = 0;
        }

      /* SGIX_fbconfig / GLX 1.3 */
      c->base.drawableType = ((ATTR_VALUE(WGL_DRAW_TO_WINDOW_ARB, 0) ? GLX_WINDOW_BIT : 0)
                         | (ATTR_VALUE(WGL_DRAW_TO_BITMAP_ARB, 0) ? GLX_PIXMAP_BIT : 0)
                         | (ATTR_VALUE(WGL_DRAW_TO_PBUFFER_ARB, 0) ? GLX_PBUFFER_BIT : 0));

      /*
        Assume OpenGL RGBA rendering is available on all visuals
        (it is specified to render to red component in single-channel visuals,
        if supported, but there doesn't seem to be any mechanism to check if it
        is supported)

        Color index rendering is only supported on single-channel visuals
      */
      if (c->base.visualType == GLX_STATIC_COLOR)
        {
          c->base.renderType = GLX_RGBA_BIT | GLX_COLOR_INDEX_BIT;
        }
      else
        {
          c->base.renderType = GLX_RGBA_BIT;
        }

      c->base.xRenderable = GL_TRUE;
      c->base.fbconfigID = -1; // will be set by __glXScreenInit()
d2247 80
a2326 20
      /* SGIX_pbuffer / GLX 1.3 */
      if (screen->has_WGL_ARB_pbuffer)
        {
          c->base.maxPbufferWidth = ATTR_VALUE(WGL_MAX_PBUFFER_WIDTH_ARB, -1);
          c->base.maxPbufferHeight = ATTR_VALUE(WGL_MAX_PBUFFER_HEIGHT_ARB, -1);
          c->base.maxPbufferPixels =  ATTR_VALUE(WGL_MAX_PBUFFER_PIXELS_ARB, -1);
        }
      else
        {
          c->base.maxPbufferWidth = -1;
          c->base.maxPbufferHeight = -1;
          c->base.maxPbufferPixels =  -1;
        }
      c->base.optimalPbufferWidth = 0; // there is no optimal value
      c->base.optimalPbufferHeight = 0;

      /* SGIX_visual_select_group */
      // arrange for visuals with the best acceleration to be preferred in selection
      switch (ATTR_VALUE(WGL_ACCELERATION_ARB, 0))
        {
d2328 2
a2329 2
          c->base.visualSelectGroup = 2;
          break;
d2332 2
a2333 2
          c->base.visualSelectGroup = 1;
          break;
d2337 2
a2338 2
          c->base.visualSelectGroup = 0;
          break;
d2341 2
a2342 3
      /* OML_swap_method */
      switch (ATTR_VALUE(WGL_SWAP_METHOD_ARB, 0))
        {
d2344 2
a2345 2
          c->base.swapMethod = GLX_SWAP_EXCHANGE_OML;
          break;
d2348 2
a2349 2
          c->base.swapMethod = GLX_SWAP_COPY_OML;
          break;
d2352 3
a2354 1
          ErrorF("wglGetPixelFormatAttribivARB returned unknown value 0x%x for WGL_SWAP_METHOD_ARB\n", ATTR_VALUE(WGL_SWAP_METHOD_ARB, 0));
d2357 1
a2357 1
          c->base.swapMethod = GLX_SWAP_UNDEFINED_OML;
d2360 2
a2361 2
      /* EXT_import_context */
      c->base.screen = screen->base.pScreen->myNum;
d2363 11
a2373 10
      /* EXT_texture_from_pixmap */
      /*
         Mesa's DRI configs always have bindToTextureRgb/Rgba TRUE (see driCreateConfigs(), so setting
         bindToTextureRgb/bindToTextureRgba to FALSE means that swrast can't find any fbConfigs to use,
         so setting these to 0, even if we know bindToTexture isn't available, isn't a good idea...
       */
      if (screen->has_WGL_ARB_render_texture)
        {
          c->base.bindToTextureRgb = ATTR_VALUE(WGL_BIND_TO_TEXTURE_RGB_ARB, -1);
          c->base.bindToTextureRgba = ATTR_VALUE(WGL_BIND_TO_TEXTURE_RGBA_ARB, -1);
d2375 3
a2377 4
      else
        {
          c->base.bindToTextureRgb = -1;
          c->base.bindToTextureRgba = -1;
d2379 5
a2383 3
      c->base.bindToMipmapTexture = -1;
      c->base.bindToTextureTargets = GLX_TEXTURE_1D_BIT_EXT | GLX_TEXTURE_2D_BIT_EXT | GLX_TEXTURE_RECTANGLE_BIT_EXT;
      c->base.yInverted = -1;
d2385 1
a2385 1
      n++;
d2387 3
a2389 3
      // update previous config to point to this config
      if (prev)
        prev->base.next = &(c->base);
d2391 1
a2391 1
      prev = c;
d2394 2
a2395 2
  screen->base.numFBConfigs = n;
  screen->base.fbconfigs = &(result->base);
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d52 11
a62 2
  - are the __GLXConfig * we get handed back ones we are made (so we can extend the structure
    with privates?) Or are they created inside the GLX core as well?
d92 11
d223 1
d226 1
a226 1
                     FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
d228 2
a229 2
                     GetLastError(),
                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
d234 1
a234 1
      snprintf(errorbuffer, sizeof(errorbuffer), "Unknown error in FormatMessage: %08x!", (unsigned)GetLastError());
d237 1
a237 1
  if (errorbuffer[strlen(errorbuffer)-1] == '\n')
d240 2
d273 3
d357 1
a357 1
      ErrorF("%3d  %2x  %2x "
d473 1
a473 1
  char *str = malloc(strlen(extensions) + 1);
a480 3
  str[strlen(extensions)] = '\0';
  strncpy (str, extensions, strlen(extensions));

a677 2
      screen->base.hyperpipeFuncs = NULL;
      screen->base.swapBarrierFuncs = NULL;
d680 1
d684 10
a693 1
          screen->has_WGL_ARB_pixel_format = TRUE;
d695 2
a696 1
      else
d701 10
a710 1
      // Initializes screen->base.fbconfigs and screen->base.numFBConfigs
d729 1
a729 4
            if (screen->base.GLXextensions != NULL)
              {
                free(screen->base.GLXextensions);
              }
d738 1
a738 1
      // if we have all the needed extensionsto operate as a higher version
a744 2
          free(screen->base.GLXversion);

a746 1
              screen->base.GLXversion = strdup("1.4");
a751 1
              screen->base.GLXversion = strdup("1.3");
a754 1
          LogMessage(X_INFO, "AIGLX: Set GLX version to %s\n", screen->base.GLXversion);
d757 1
d904 1
a904 1
      __GLX_NOTE_FLUSHED_CMDS(__glXLastContext);
d1015 1
a1015 1
static void
d1037 1
a1037 1
          return;
d1040 1
a1040 1
      return;
d1072 1
a1072 1
          return;
d1088 1
a1088 1
          return;
d1097 1
a1097 1
          return;
d1106 1
a1106 1
          return;
d1115 1
a1115 1
          return;
d1118 2
d1170 7
a1176 1
          glxWinSetPixelFormat(gc, *hdc, 0, GLX_WINDOW_BIT);
a1532 7
static int
glxWinContextForceCurrent(__GLXcontext *base)
{
  /* wglMakeCurrent always flushes the previous context, so this is equivalent to glxWinContextMakeCurrent */
  return glxWinContextMakeCurrent(base);
}

a1586 1
    context->base.forceCurrent   = glxWinContextForceCurrent;
@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 8
a9 2
 * GLX implementation that uses Windows OpenGL library
 * (Indirect rendering path)
a10 3
 * Authors: Alexander Gottwald 
 */
/* 
d13 3
a15 1
 *  
a16 1
 * Copyright (c) 2002 Apple Computer, Inc.
d18 1
a18 1
 * Portions of this file are copied from xf86glx.c,
d24 1
a41 4
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
d44 18
d63 2
d66 4
a69 2
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
d73 4
a76 2
#include <glcontextmodes.h>
#include <stdint.h>
d79 65
d146 1
a146 1
    if (glWinDebugSettings.dumpHWND) { \
d149 1
a149 1
        GLWIN_DEBUG_MSG("Got HWND %s (%p)\n", buffer, hwnd); \
d152 1
d154 1
a154 6
/* ggs: needed to call back to glx with visual configs */
extern void GlxSetVisualConfigs(int nconfigs, __GLXvisualConfig *configs, void **configprivs);

glWinDebugSettingsRec glWinDebugSettings = { 1, 0, 0, 0, 0};

static void glWinInitDebugSettings(void) 
d160 1
a160 1
        glWinDebugSettings.enableDebug = (atoi(envptr) == 1);
d164 1
a164 1
        glWinDebugSettings.enableTrace = (atoi(envptr) == 1);
d168 2
a169 2
        glWinDebugSettings.dumpPFD = (atoi(envptr) == 1);
        
d172 1
a172 1
        glWinDebugSettings.dumpHWND = (atoi(envptr) == 1);
d176 9
a184 2
        glWinDebugSettings.dumpDC = (atoi(envptr) == 1);
}
d186 26
a211 12
static char errorbuffer[1024];
const char *glWinErrorMessage(void)
{
    if (!FormatMessage( 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR) &errorbuffer,
                sizeof(errorbuffer),
                NULL ))
d213 1
a213 1
        snprintf(errorbuffer, sizeof(errorbuffer), "Unknown error in FormatMessage: %08x!\n", (unsigned)GetLastError()); 
d215 5
a219 1
    return errorbuffer; 
d222 1
a222 3
/*
 * GLX implementation that uses Win32's OpenGL
 */
d224 5
a228 4
/*
 * Server-side GLX uses these functions which are normally defined
 * in the OpenGL SI.
 */
d230 1
a230 1
GLuint __glFloorLog2(GLuint val)
d232 22
a253 1
    int c = 0;
d255 26
a280 20
    while (val > 1) {
        c++;
        val >>= 1;
    }
    return c;
}

/* some prototypes */
static Bool glWinScreenProbe(int screen);
static Bool glWinInitVisuals(VisualPtr *visualp, DepthPtr *depthp,
                              int *nvisualp, int *ndepthp,
                              int *rootDepthp, VisualID *defaultVisp,
                              unsigned long sizes, int bitsPerRGB);
static void glWinSetVisualConfigs(int nconfigs, __GLXvisualConfig *configs,
                                   void **privates);
static __GLinterface *glWinCreateContext(__GLimports *imports,
                                          __GLcontextModes *mode,
                                          __GLinterface *shareGC);
static void glWinCreateBuffer(__GLXdrawablePrivate *glxPriv);
static void glWinResetExtension(void);
d282 19
a300 25
/*
 * This structure is statically allocated in the __glXScreens[]
 * structure.  This struct is not used anywhere other than in
 * __glXScreenInit to initialize each of the active screens
 * (__glXActiveScreens[]).  Several of the fields must be initialized by
 * the screenProbe routine before they are copied to the active screens
 * struct.  In particular, the contextCreate, pGlxVisual, numVisuals,
 * and numUsableVisuals fields must be initialized.
 */
static __GLXscreenInfo __glDDXScreenInfo = {
    glWinScreenProbe,   /* Must be generic and handle all screens */
    glWinCreateContext, /* Substitute screen's createContext routine */
    glWinCreateBuffer,  /* Substitute screen's createBuffer routine */
    NULL,                 /* Set up pGlxVisual in probe */
    NULL,                 /* Set up pVisualPriv in probe */
    0,                    /* Set up numVisuals in probe */
    0,                    /* Set up numUsableVisuals in probe */
    "Vendor String",      /* GLXvendor is overwritten by __glXScreenInit */
    "Version String",     /* GLXversion is overwritten by __glXScreenInit */
    "Extensions String",  /* GLXextensions is overwritten by __glXScreenInit */
    NULL                  /* WrappedPositionWindow is overwritten */
};

void *__glXglDDXScreenInfo(void) {
    return &__glDDXScreenInfo;
d303 14
a316 9
static __GLXextensionInfo __glDDXExtensionInfo = {
    GL_CORE_WINDOWS,
    glWinResetExtension,
    glWinInitVisuals,
    glWinSetVisualConfigs
};

void *__glXglDDXExtensionInfo(void) {
    return &__glDDXExtensionInfo;
d319 7
a325 1
/* prototypes */
d327 3
a329 17
static GLboolean glWinDestroyContext(__GLcontext *gc);
static GLboolean glWinLoseCurrent(__GLcontext *gc);
static GLboolean glWinMakeCurrent(__GLcontext *gc);
static GLboolean glWinShareContext(__GLcontext *gc, __GLcontext *gcShare);
static GLboolean glWinCopyContext(__GLcontext *dst, const __GLcontext *src,
                            GLuint mask);
static GLboolean glWinForceCurrent(__GLcontext *gc);

/* Drawing surface notification callbacks */
static GLboolean glWinNotifyResize(__GLcontext *gc);
static void glWinNotifyDestroy(__GLcontext *gc);
static void glWinNotifySwapBuffers(__GLcontext *gc);

/* Dispatch table override control for external agents like libGLS */
static struct __GLdispatchStateRec* glWinDispatchExec(__GLcontext *gc);
static void glWinBeginDispatchOverride(__GLcontext *gc);
static void glWinEndDispatchOverride(__GLcontext *gc);
d331 33
a363 2
/* Debug output */
static void pfdOut(const PIXELFORMATDESCRIPTOR *pfd);
d365 3
a367 16
static __GLexports glWinExports = {
    glWinDestroyContext,
    glWinLoseCurrent,
    glWinMakeCurrent,
    glWinShareContext,
    glWinCopyContext,
    glWinForceCurrent,

    glWinNotifyResize,
    glWinNotifyDestroy,
    glWinNotifySwapBuffers,

    glWinDispatchExec,
    glWinBeginDispatchOverride,
    glWinEndDispatchOverride
};
d369 4
a372 1
glWinScreenRec glWinScreens[MAXSCREENS];
d374 23
a396 5
/* __GLdrawablePrivate->private */
typedef struct {
    DrawablePtr pDraw;
  /*    xp_surface_id sid; */
} GLWinDrawableRec;
d398 4
a401 10
struct __GLcontextRec {
  struct __GLinterfaceRec interface; /* required to be first */

  HGLRC ctx;                         /* Windows GL Context */
  
  HDC dc;                            /* Windows Device Context */
  winWindowInfoRec winInfo;          /* Window info from XWin */
  
  PIXELFORMATDESCRIPTOR pfd;         /* Pixelformat flags */
  int pixelFormat;                   /* Pixelformat index */
d403 4
a406 1
  unsigned isAttached :1;            /* Flag to track if context is attached */
d409 2
a410 1
static HDC glWinMakeDC(__GLcontext *gc)
d412 2
a413 1
    HDC dc;
d415 4
a418 17
    /*if (gc->winInfo.hrgn == NULL) 
    {
        GLWIN_DEBUG_MSG("Creating region from RECT(%ld,%ld,%ld,%ld):",
                gc->winInfo.rect.left,
                gc->winInfo.rect.top,
                gc->winInfo.rect.right,
                gc->winInfo.rect.bottom);
        gc->winInfo.hrgn = CreateRectRgnIndirect(&gc->winInfo.rect);
        GLWIN_DEBUG_MSG2("%p\n", gc->winInfo.hrgn);
    }*/

    if (glWinDebugSettings.enableTrace)
        GLWIN_DEBUG_HWND(gc->winInfo.hwnd);

    dc = GetDC(gc->winInfo.hwnd); 
    /*dc = GetDCEx(gc->winInfo.hwnd, gc->winInfo.hrgn, 
            DCX_WINDOW | DCX_NORESETATTRS ); */
d420 6
a425 3
    if (dc == NULL)
        ErrorF("GetDC error: %s\n", glWinErrorMessage());
    return dc;
d428 2
a429 1
static void unattach(__GLcontext *gc)
d431 2
a432 3
    BOOL ret;
    GLWIN_DEBUG_MSG("unattach (ctx %p)\n", gc->ctx);
    if (!gc->isAttached) 
d434 1
a434 10
        ErrorF("called unattach on an unattached context\n");
        return;
    }

    if (gc->ctx) 
    {
        ret = wglDeleteContext(gc->ctx);
        if (!ret)
            ErrorF("wglDeleteContext error: %s\n", glWinErrorMessage());
        gc->ctx = NULL;
d436 1
a436 10

    if (gc->winInfo.hrgn)
    {
        ret = DeleteObject(gc->winInfo.hrgn);
        if (!ret)
            ErrorF("DeleteObject error: %s\n", glWinErrorMessage());
        gc->winInfo.hrgn = NULL;
    }

    gc->isAttached = 0;
d439 5
a443 1
static BOOL glWinAdjustHWND(__GLcontext *gc, WindowPtr pWin)
d445 3
a447 6
    HDC dc;
    BOOL ret;
    HGLRC newctx;
    HWND oldhwnd;

    GLWIN_DEBUG_MSG("glWinAdjustHWND (ctx %p, pWin %p)\n", gc->ctx, pWin);
d449 1
a449 1
    if (pWin == NULL)
d451 2
a452 2
        GLWIN_DEBUG_MSG("Deferring until window is created\n");
        return FALSE;
d455 6
a460 9
    oldhwnd = gc->winInfo.hwnd;
    winGetWindowInfo(pWin, &gc->winInfo);
    
    GLWIN_DEBUG_HWND(gc->winInfo.hwnd);
    if (gc->winInfo.hwnd == NULL)
    {
        GLWIN_DEBUG_MSG("Deferring until window is created\n");
        return FALSE;
    }
d462 1
a462 7
    dc = glWinMakeDC(gc);
    
    if (glWinDebugSettings.dumpDC)
        GLWIN_DEBUG_MSG("Got HDC %p\n", dc);
    
    gc->pixelFormat = ChoosePixelFormat(dc, &gc->pfd);
    if (gc->pixelFormat == 0)
d464 2
a465 20
        ErrorF("ChoosePixelFormat error: %s\n", glWinErrorMessage());
        ReleaseDC(gc->winInfo.hwnd, dc);
        return FALSE;  
    }
    
    ret = SetPixelFormat(dc, gc->pixelFormat, &gc->pfd);
    if (!ret) {
        ErrorF("SetPixelFormat error: %s\n", glWinErrorMessage());
        ReleaseDC(gc->winInfo.hwnd, dc);
        return FALSE;
    }
    
    newctx = wglCreateContext(dc);
    if (newctx == NULL) {
        ErrorF("wglCreateContext error: %s\n", glWinErrorMessage());
        ReleaseDC(gc->winInfo.hwnd, dc);
        return FALSE;
    }
    
    GLWIN_DEBUG_MSG("wglCreateContext (ctx %p)\n", newctx);
d467 7
a473 11
    if (!wglShareLists(gc->ctx, newctx))
    {
        ErrorF("wglShareLists error: %s\n", glWinErrorMessage());
        ReleaseDC(gc->winInfo.hwnd, dc);
        return FALSE;
    }
    
    if (oldhwnd != gc->winInfo.hwnd)
    {
        GLWIN_DEBUG_MSG("Trying wglCopyContext\n");
        if (!wglCopyContext(gc->ctx, newctx, GL_ALL_ATTRIB_BITS))
d475 2
a476 3
            ErrorF("wglCopyContext error: %s\n", glWinErrorMessage());
            ReleaseDC(gc->winInfo.hwnd, dc);
            return FALSE;
d478 3
d483 19
a501 4
    if (!wglDeleteContext(gc->ctx))
    {
        ErrorF("wglDeleteContext error: %s\n", glWinErrorMessage());
    }
d503 2
a504 1
    gc->ctx = newctx;
d506 5
a510 5
    if (!wglMakeCurrent(dc, gc->ctx)) {
        ErrorF("glMakeCurrent error: %s\n", glWinErrorMessage());
        ReleaseDC(gc->winInfo.hwnd, dc);
        return FALSE;
    }
d512 1
a512 1
    ReleaseDC(gc->winInfo.hwnd, dc);
d514 2
a515 2
    return TRUE;
}
d517 7
a523 4
static BOOL glWinCreateContextReal(__GLcontext *gc, WindowPtr pWin)
{
    HDC dc;
    BOOL ret;
d525 1
a525 1
    GLWIN_DEBUG_MSG("glWinCreateContextReal (pWin %p)\n", pWin);
d527 2
a528 1
    if (pWin == NULL)
d530 52
a581 3
        GLWIN_DEBUG_MSG("Deferring until window is created\n");
        return FALSE;
    }
a582 4
    winGetWindowInfo(pWin, &gc->winInfo);
    
    GLWIN_DEBUG_HWND(gc->winInfo.hwnd);
    if (gc->winInfo.hwnd == NULL)
d584 7
a590 2
        GLWIN_DEBUG_MSG("Deferring until window is created\n");
        return FALSE;
a592 8
    
    dc = glWinMakeDC(gc);
    
    if (glWinDebugSettings.dumpDC)
        GLWIN_DEBUG_MSG("Got HDC %p\n", dc);
    
    gc->pixelFormat = ChoosePixelFormat(dc, &gc->pfd);
    if (gc->pixelFormat == 0)
d594 13
a606 18
        ErrorF("ChoosePixelFormat error: %s\n", glWinErrorMessage());
        ReleaseDC(gc->winInfo.hwnd, dc);
        return FALSE;  
    }
    
    ret = SetPixelFormat(dc, gc->pixelFormat, &gc->pfd);
    if (!ret) {
        ErrorF("SetPixelFormat error: %s\n", glWinErrorMessage());
        ReleaseDC(gc->winInfo.hwnd, dc);
        return FALSE;
    }
    
    gc->ctx = wglCreateContext(dc);
    if (gc->ctx == NULL) {
        ErrorF("wglCreateContext error: %s\n", glWinErrorMessage());
        ReleaseDC(gc->winInfo.hwnd, dc);
        return FALSE;
    }
d608 6
a613 1
    GLWIN_DEBUG_MSG("glWinCreateContextReal (ctx %p)\n", gc->ctx);
d615 5
a619 5
    if (!wglMakeCurrent(dc, gc->ctx)) {
        ErrorF("glMakeCurrent error: %s\n", glWinErrorMessage());
        ReleaseDC(gc->winInfo.hwnd, dc);
        return FALSE;
    }
d621 6
a626 1
    ReleaseDC(gc->winInfo.hwnd, dc);
d628 7
a634 2
    return TRUE;
}
d636 6
a641 3
static void attach(__GLcontext *gc, __GLdrawablePrivate *glPriv)
{
    __GLXdrawablePrivate *glxPriv = (__GLXdrawablePrivate *)glPriv->other;
d643 7
a649 1
    GLWIN_DEBUG_MSG("attach (ctx %p)\n", gc->ctx);
d651 7
a657 5
    if (gc->isAttached)
    {
        ErrorF("called attach on an attached context\n");
        return;
    }
d659 6
a664 4
    if (glxPriv->type == DRAWABLE_WINDOW)
    {
        WindowPtr pWin = (WindowPtr) glxPriv->pDraw;
        if (pWin == NULL)
d666 40
a705 2
            GLWIN_DEBUG_MSG("Deferring ChoosePixelFormat until window is created\n");
        } else
d707 9
a715 1
            if (glWinCreateContextReal(gc, pWin))
d717 3
a719 2
                gc->isAttached = TRUE;
                GLWIN_DEBUG_MSG("attached\n");
d721 1
d724 7
d733 7
a739 1
static GLboolean glWinLoseCurrent(__GLcontext *gc)
d741 5
a745 1
    GLWIN_TRACE_MSG("glWinLoseCurrent (ctx %p)\n", gc->ctx);
d747 4
a750 1
    __glXLastContext = NULL; /* Mesa does this; why? */
d752 1
a752 1
    return GL_TRUE;
d755 3
a757 2
/* Context manipulation; return GL_FALSE on failure */
static GLboolean glWinDestroyContext(__GLcontext *gc)
d759 3
a761 1
    GLWIN_DEBUG_MSG("glWinDestroyContext (ctx %p)\n", gc->ctx);
d763 1
a763 8
    if (gc != NULL)
    {
        if (gc->isAttached)
            unattach(gc);
        if (gc->dc != NULL)
            DeleteDC(gc->dc);
        free(gc);
    }
d765 2
a766 2
    return GL_TRUE;
}
a767 5
static GLboolean glWinMakeCurrent(__GLcontext *gc)
{
    __GLdrawablePrivate *glPriv = gc->interface.imports.getDrawablePrivate(gc);
    BOOL ret;
    HDC dc;
d769 2
a770 1
    GLWIN_TRACE_MSG(" (ctx %p)\n", gc->ctx);
d772 9
a780 7
    if (!gc->isAttached)
        attach(gc, glPriv);

    if (gc->ctx == NULL) {
        ErrorF("Context is NULL\n");
        return GL_FALSE;
    }
d782 1
a782 5
    dc = glWinMakeDC(gc);
    ret = wglMakeCurrent(dc, gc->ctx);
    if (!ret)
        ErrorF("glMakeCurrent error: %s\n", glWinErrorMessage());
    ReleaseDC(gc->winInfo.hwnd, dc);
d784 3
a786 1
    return ret?GL_TRUE:GL_FALSE;
d789 2
a790 1
static GLboolean glWinShareContext(__GLcontext *gc, __GLcontext *gcShare)
d792 9
a800 1
  GLWIN_DEBUG_MSG("glWinShareContext unimplemented\n");
d802 1
a802 1
  return GL_TRUE;
d805 7
a811 2
static GLboolean glWinCopyContext(__GLcontext *dst, const __GLcontext *src,
                                   GLuint mask)
d813 2
d816 1
d818 4
a821 6
    GLWIN_DEBUG_MSG("glWinCopyContext\n");
    
    ret = wglCopyContext(src->ctx, dst->ctx, mask);
    if (!ret) 
    {
        ErrorF("wglCopyContext error: %s\n", glWinErrorMessage());
d823 1
a823 1
    }
d825 1
a825 2
    return GL_TRUE;
}
d827 11
a837 3
static GLboolean glWinForceCurrent(__GLcontext *gc)
{
    GLWIN_TRACE_MSG(" (ctx %p)\n", gc->ctx);
d839 1
a839 2
    return GL_TRUE;
}
d841 5
a845 1
/* Drawing surface notification callbacks */
a846 3
static GLboolean glWinNotifyResize(__GLcontext *gc)
{
    GLWIN_DEBUG_MSG("unimplemented glWinNotifyResize");
d850 3
a852 1
static void glWinNotifyDestroy(__GLcontext *gc)
d854 2
a855 1
    GLWIN_DEBUG_MSG("unimplemented glWinNotifyDestroy");
d858 2
a859 1
static void glWinNotifySwapBuffers(__GLcontext *gc)
d861 42
a902 1
    GLWIN_DEBUG_MSG("unimplemented glWinNotifySwapBuffers");
d905 8
a912 2
/* Dispatch table override control for external agents like libGLS */
static struct __GLdispatchStateRec* glWinDispatchExec(__GLcontext *gc)
d914 11
a924 1
    GLWIN_DEBUG_MSG("unimplemented glWinDispatchExec");
d926 11
d939 9
a947 1
static void glWinBeginDispatchOverride(__GLcontext *gc)
d949 2
a950 1
    GLWIN_DEBUG_MSG("unimplemented glWinBeginDispatchOverride");
d953 4
a956 1
static void glWinEndDispatchOverride(__GLcontext *gc)
d958 2
a959 1
    GLWIN_DEBUG_MSG("unimplemented glWinEndDispatchOverride");
d962 21
a982 7
#define DUMP_PFD_FLAG(flag) \
    if (pfd->dwFlags & flag) { \
        ErrorF("%s%s", pipesym, #flag); \
        pipesym = " | "; \
    }
        
static void pfdOut(const PIXELFORMATDESCRIPTOR *pfd)
d984 12
a995 52
    const char *pipesym = ""; /* will be set after first flag dump */
    ErrorF("PIXELFORMATDESCRIPTOR:\n");
    ErrorF("nSize = %u\n", pfd->nSize);
    ErrorF("nVersion = %u\n", pfd->nVersion);
    ErrorF("dwFlags = %lu = {", pfd->dwFlags);
        DUMP_PFD_FLAG(PFD_MAIN_PLANE);
        DUMP_PFD_FLAG(PFD_OVERLAY_PLANE);
        DUMP_PFD_FLAG(PFD_UNDERLAY_PLANE);
        DUMP_PFD_FLAG(PFD_DOUBLEBUFFER);
        DUMP_PFD_FLAG(PFD_STEREO);
        DUMP_PFD_FLAG(PFD_DRAW_TO_WINDOW);
        DUMP_PFD_FLAG(PFD_DRAW_TO_BITMAP);
        DUMP_PFD_FLAG(PFD_SUPPORT_GDI);
        DUMP_PFD_FLAG(PFD_SUPPORT_OPENGL);
        DUMP_PFD_FLAG(PFD_GENERIC_FORMAT);
        DUMP_PFD_FLAG(PFD_NEED_PALETTE);
        DUMP_PFD_FLAG(PFD_NEED_SYSTEM_PALETTE);
        DUMP_PFD_FLAG(PFD_SWAP_EXCHANGE);
        DUMP_PFD_FLAG(PFD_SWAP_COPY);
        DUMP_PFD_FLAG(PFD_SWAP_LAYER_BUFFERS);
        DUMP_PFD_FLAG(PFD_GENERIC_ACCELERATED);
        DUMP_PFD_FLAG(PFD_DEPTH_DONTCARE);
        DUMP_PFD_FLAG(PFD_DOUBLEBUFFER_DONTCARE);
        DUMP_PFD_FLAG(PFD_STEREO_DONTCARE);
    ErrorF("}\n");
    
    ErrorF("iPixelType = %hu = %s\n", pfd->iPixelType, 
            (pfd->iPixelType == PFD_TYPE_RGBA ? "PFD_TYPE_RGBA" : "PFD_TYPE_COLORINDEX"));
    ErrorF("cColorBits = %hhu\n", pfd->cColorBits);
    ErrorF("cRedBits = %hhu\n", pfd->cRedBits);
    ErrorF("cRedShift = %hhu\n", pfd->cRedShift);
    ErrorF("cGreenBits = %hhu\n", pfd->cGreenBits);
    ErrorF("cGreenShift = %hhu\n", pfd->cGreenShift);
    ErrorF("cBlueBits = %hhu\n", pfd->cBlueBits);
    ErrorF("cBlueShift = %hhu\n", pfd->cBlueShift);
    ErrorF("cAlphaBits = %hhu\n", pfd->cAlphaBits);
    ErrorF("cAlphaShift = %hhu\n", pfd->cAlphaShift);
    ErrorF("cAccumBits = %hhu\n", pfd->cAccumBits);
    ErrorF("cAccumRedBits = %hhu\n", pfd->cAccumRedBits);
    ErrorF("cAccumGreenBits = %hhu\n", pfd->cAccumGreenBits);
    ErrorF("cAccumBlueBits = %hhu\n", pfd->cAccumBlueBits);
    ErrorF("cAccumAlphaBits = %hhu\n", pfd->cAccumAlphaBits);
    ErrorF("cDepthBits = %hhu\n", pfd->cDepthBits);
    ErrorF("cStencilBits = %hhu\n", pfd->cStencilBits);
    ErrorF("cAuxBuffers = %hhu\n", pfd->cAuxBuffers);
    ErrorF("iLayerType = %hhu\n", pfd->iLayerType);
    ErrorF("bReserved = %hhu\n", pfd->bReserved);
    ErrorF("dwLayerMask = %lu\n", pfd->dwLayerMask);
    ErrorF("dwVisibleMask = %lu\n", pfd->dwVisibleMask);
    ErrorF("dwDamageMask = %lu\n", pfd->dwDamageMask);
    ErrorF("\n");
}    
d997 8
a1004 21
static int makeFormat(__GLcontextModes *mode, PIXELFORMATDESCRIPTOR *pfdret)
{
    PIXELFORMATDESCRIPTOR pfd = {
      sizeof(PIXELFORMATDESCRIPTOR),   /* size of this pfd */
      1,                     /* version number */
      PFD_DRAW_TO_WINDOW |   /* support window */
      PFD_SUPPORT_OPENGL,    /* support OpenGL */
      PFD_TYPE_RGBA,         /* RGBA type */
      24,                    /* 24-bit color depth */
      0, 0, 0, 0, 0, 0,      /* color bits ignored */
      0,                     /* no alpha buffer */
      0,                     /* shift bit ignored */
      0,                     /* no accumulation buffer */
      0, 0, 0, 0,            /* accum bits ignored */
      0,                     /* 32-bit z-buffer */
      0,                     /* no stencil buffer */
      0,                     /* no auxiliary buffer */
      PFD_MAIN_PLANE,        /* main layer */
      0,                     /* reserved */
      0, 0, 0                /* layer masks ignored */
    }, *result = &pfd;
d1006 1
a1006 9
    /* disable anything but rgba. must get rgba to work first */
    if (!mode->rgbMode) 
        return -1; 
    
    if (mode->stereoMode) {
        result->dwFlags |= PFD_STEREO;
    }
    if (mode->doubleBufferMode) {
        result->dwFlags |= PFD_DOUBLEBUFFER;
d1009 3
a1011 42
    if (mode->colorIndexMode) {
        /* ignored, see above */
        result->iPixelType = PFD_TYPE_COLORINDEX; 
        result->cColorBits = mode->redBits + mode->greenBits + mode->blueBits;
        result->cRedBits = mode->redBits;
        result->cRedShift = 0; /* FIXME */
        result->cGreenBits = mode->greenBits;
        result->cGreenShift = 0; /* FIXME  */
        result->cBlueBits = mode->blueBits;
        result->cBlueShift = 0; /* FIXME */
        result->cAlphaBits = mode->alphaBits;
        result->cAlphaShift = 0; /* FIXME */
    }

    if (mode->rgbMode) {
        result->iPixelType = PFD_TYPE_RGBA;
        result->cColorBits = mode->redBits + mode->greenBits + mode->blueBits;
        result->cRedBits = mode->redBits;
        result->cRedShift = 0; /* FIXME */
        result->cGreenBits = mode->greenBits;
        result->cGreenShift = 0; /* FIXME  */
        result->cBlueBits = mode->blueBits;
        result->cBlueShift = 0; /* FIXME */
        result->cAlphaBits = mode->alphaBits;
        result->cAlphaShift = 0; /* FIXME */
    }

    if (mode->haveAccumBuffer) {
        result->cAccumBits = mode->accumRedBits + mode->accumGreenBits
            + mode->accumBlueBits + mode->accumAlphaBits;
        result->cAccumRedBits = mode->accumRedBits;
        result->cAccumGreenBits = mode->accumGreenBits;
        result->cAccumBlueBits = mode->accumBlueBits;
        result->cAccumAlphaBits = mode->accumAlphaBits;
    }
    
    if (mode->haveDepthBuffer) {
        result->cDepthBits = mode->depthBits;
    }
    if (mode->haveStencilBuffer) {
        result->cStencilBits = mode->stencilBits;
    }
d1013 2
a1014 1
    /* result->cAuxBuffers = mode->numAuxBuffers; */
d1016 4
a1019 1
    /* mode->level ignored */
d1021 7
a1027 1
    /* mode->pixmapMode ? */
d1029 4
a1032 1
    *pfdret = pfd;
d1034 6
a1039 2
    return 0;
}
d1041 2
a1042 5
static __GLinterface *glWinCreateContext(__GLimports *imports,
                                          __GLcontextModes *mode,
                                          __GLinterface *shareGC)
{
    __GLcontext *result;
d1044 5
a1048 1
    GLWIN_DEBUG_MSG("glWinCreateContext\n");
d1050 6
a1055 3
    result = (__GLcontext *)calloc(1, sizeof(__GLcontext));
    if (!result) 
        return NULL;
d1057 2
a1058 2
    result->interface.imports = *imports;
    result->interface.exports = glWinExports;
d1060 7
a1066 1
    if (makeFormat(mode, &result->pfd))
d1068 6
a1073 4
        ErrorF("makeFormat failed\n");
        free(result);
        return NULL;
    }
d1075 2
a1076 2
    if (glWinDebugSettings.dumpPFD)
        pfdOut(&result->pfd);
d1078 6
a1083 2
    GLWIN_DEBUG_MSG("glWinCreateContext done\n");
    return (__GLinterface *)result;
d1086 2
a1087 2
Bool
glWinRealizeWindow(WindowPtr pWin)
d1089 2
a1090 6
    /* If this window has GL contexts, tell them to reattach */
    /* reattaching is bad: display lists and parameters get lost */
    Bool result;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    glWinScreenRec *screenPriv = &glWinScreens[pScreen->myNum];
    __GLXdrawablePrivate *glxPriv;
d1092 5
a1096 1
    GLWIN_DEBUG_MSG("glWinRealizeWindow\n");
d1098 5
a1102 4
    /* Allow the window to be created (RootlessRealizeWindow is inside our wrap) */
    pScreen->RealizeWindow = screenPriv->RealizeWindow;
    result = pScreen->RealizeWindow(pWin);
    pScreen->RealizeWindow = glWinRealizeWindow;
d1104 5
a1108 22
    /* Re-attach this window's GL contexts, if any. */
    glxPriv = __glXFindDrawablePrivate(pWin->drawable.id);
    if (glxPriv) {
        __GLXcontext *gx;
        __GLcontext *gc;
        __GLdrawablePrivate *glPriv = &glxPriv->glPriv;
        GLWIN_DEBUG_MSG("glWinRealizeWindow is GL drawable!\n");

        /* GL contexts bound to this window for drawing */
        for (gx = glxPriv->drawGlxc; gx != NULL; gx = gx->next) {
            gc = (__GLcontext *)gx->gc;
            if (gc->isAttached)
#if 1
            {
                GLWIN_DEBUG_MSG("context is already bound! Adjusting HWND.\n");
                glWinAdjustHWND(gc, pWin);
                continue;
            }
#else
                unattach(gc);
#endif
            attach(gc, glPriv);
d1111 6
a1116 14
        /* GL contexts bound to this window for reading */
        for (gx = glxPriv->readGlxc; gx != NULL; gx = gx->next) {
            gc = (__GLcontext *)gx->gc;
            if (gc->isAttached)
#if 1
            {
                GLWIN_DEBUG_MSG("context is already bound! Adjusting HWND.\n");
                glWinAdjustHWND(gc, pWin);
                continue;
            }
#else
                unattach(gc);
#endif
            attach(gc, glPriv);
a1117 1
    }
d1119 10
a1128 2
    return result;
}
d1130 2
d1133 2
a1134 27
void 
glWinCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    glWinScreenRec *screenPriv = &glWinScreens[pScreen->myNum];
    __GLXdrawablePrivate *glxPriv;
    
    GLWIN_TRACE_MSG(" (pWindow %p)\n", pWindow);
    
    /* Check if the window is attached and discard any drawing request */
    glxPriv = __glXFindDrawablePrivate(pWindow->drawable.id);
    if (glxPriv) {
        __GLXcontext *gx;

        /* GL contexts bound to this window for drawing */
        for (gx = glxPriv->drawGlxc; gx != NULL; gx = gx->next) {
/*            
            GLWIN_DEBUG_MSG("glWinCopyWindow - calling glDrawBuffer\n");
            glDrawBuffer(GL_FRONT);
 */           
 
            return;
        }

        /* GL contexts bound to this window for reading */
        for (gx = glxPriv->readGlxc; gx != NULL; gx = gx->next) {
            return;
d1137 1
d1139 3
a1141 1
    GLWIN_DEBUG_MSG("glWinCopyWindow - passing to hw layer\n");
d1143 4
a1146 4
    pScreen->CopyWindow = screenPriv->CopyWindow;
    pScreen->CopyWindow(pWindow, ptOldOrg, prgnSrc);
    pScreen->CopyWindow = glWinCopyWindow;
}
d1148 5
a1152 8
Bool
glWinUnrealizeWindow(WindowPtr pWin)
{
    /* If this window has GL contexts, tell them to unattach */
    Bool result;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    glWinScreenRec *screenPriv = &glWinScreens[pScreen->myNum];
    __GLXdrawablePrivate *glxPriv;
d1154 3
a1156 24
    GLWIN_DEBUG_MSG("glWinUnrealizeWindow\n");

    /* The Aqua window may have already been destroyed (windows
     * are unrealized from top down)
     */
    
    /* Unattach this window's GL contexts, if any. */
    glxPriv = __glXFindDrawablePrivate(pWin->drawable.id);
    if (glxPriv) {
        __GLXcontext *gx;
        __GLcontext *gc;
        GLWIN_DEBUG_MSG("glWinUnealizeWindow is GL drawable!\n");

        /* GL contexts bound to this window for drawing */
        for (gx = glxPriv->drawGlxc; gx != NULL; gx = gx->next) {
            gc = (__GLcontext *)gx->gc;
            unattach(gc);
        }

        /* GL contexts bound to this window for reading */
        for (gx = glxPriv->readGlxc; gx != NULL; gx = gx->next) {
            gc = (__GLcontext *)gx->gc;
            unattach(gc);
        }
d1158 1
d1160 2
a1161 3
    pScreen->UnrealizeWindow = screenPriv->UnrealizeWindow;
    result = pScreen->UnrealizeWindow(pWin);
    pScreen->UnrealizeWindow = glWinUnrealizeWindow;
d1163 1
a1163 1
    return result;
d1166 19
d1186 3
a1188 6
/*
 * In the case the driver has no GLX visuals we'll use these.
 * [0] = RGB, double buffered
 * [1] = RGB, double buffered, stencil, accum
 */
/* Originally copied from Mesa */
d1190 5
a1194 3
static int                 numConfigs     = 0;
static __GLXvisualConfig  *visualConfigs  = NULL;
static void              **visualPrivates = NULL;
d1196 4
a1199 39
#define NUM_FALLBACK_CONFIGS 2
static __GLXvisualConfig FallbackConfigs[NUM_FALLBACK_CONFIGS] = {
  {
    -1,                 /* vid */
    -1,                 /* class */
    True,               /* rgba */
    -1, -1, -1, 0,      /* rgba sizes */
    -1, -1, -1, 0,      /* rgba masks */
     0,  0,  0, 0,      /* rgba accum sizes */
    True,               /* doubleBuffer */
    False,              /* stereo */
    -1,                 /* bufferSize */
    16,                 /* depthSize */
    0,                  /* stencilSize */
    0,                  /* auxBuffers */
    0,                  /* level */
    GLX_NONE_EXT,       /* visualRating */
    0,                  /* transparentPixel */
    0, 0, 0, 0,         /* transparent rgba color (floats scaled to ints) */
    0                   /* transparentIndex */
  },
  {
    -1,                 /* vid */
    -1,                 /* class */
    True,               /* rgba */
    -1, -1, -1, 0,      /* rgba sizes */
    -1, -1, -1, 0,      /* rgba masks */
    16, 16, 16, 0,      /* rgba accum sizes */
    True,               /* doubleBuffer */
    False,              /* stereo */
    -1,                 /* bufferSize */
    16,                 /* depthSize */
    8,                  /* stencilSize */
    0,                  /* auxBuffers */
    0,                  /* level */
    GLX_NONE_EXT,       /* visualRating */
    0,                  /* transparentPixel */
    0, 0, 0, 0,         /* transparent rgba color (floats scaled to ints) */
    0                   /* transparentIndex */
d1201 1
a1201 1
};
d1203 2
a1204 21
static __GLXvisualConfig NullConfig = {
    -1,                 /* vid */
    -1,                 /* class */
    False,              /* rgba */
    -1, -1, -1, 0,      /* rgba sizes */
    -1, -1, -1, 0,      /* rgba masks */
     0,  0,  0, 0,      /* rgba accum sizes */
    False,              /* doubleBuffer */
    False,              /* stereo */
    -1,                 /* bufferSize */
    16,                 /* depthSize */
    0,                  /* stencilSize */
    0,                  /* auxBuffers */
    0,                  /* level */
    GLX_NONE_EXT,       /* visualRating */
    0,                  /* transparentPixel */
    0, 0, 0, 0,         /* transparent rgba color (floats scaled to ints) */
    0                   /* transparentIndex */
};

static inline int count_bits(uint32_t x)
d1206 3
a1208 28
    x = x - ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 63;
}

/* Mostly copied from Mesa's xf86glx.c */
static Bool init_visuals(int *nvisualp, VisualPtr *visualp,
                         VisualID *defaultVisp,
                         int ndepth, DepthPtr pdepth,
                         int rootDepth)
{
    int numRGBconfigs;
    int numCIconfigs;
    int numVisuals = *nvisualp;
    int numNewVisuals;
    int numNewConfigs;
    VisualPtr pVisual = *visualp;
    VisualPtr pVisualNew = NULL;
    VisualID *orig_vid = NULL;
    __GLcontextModes *modes = NULL;
    __GLXvisualConfig *pNewVisualConfigs = NULL;
    void **glXVisualPriv;
    void **pNewVisualPriv;
    int found_default;
    int i, j, k;
d1210 5
a1214 1
    GLWIN_DEBUG_MSG("init_visuals\n");
d1216 4
a1219 4
    if (numConfigs > 0)
        numNewConfigs = numConfigs;
    else
        numNewConfigs = NUM_FALLBACK_CONFIGS;
d1221 5
a1225 6
    /* Alloc space for the list of new GLX visuals */
    pNewVisualConfigs = (__GLXvisualConfig *)
                     __glXMalloc(numNewConfigs * sizeof(__GLXvisualConfig));
    if (!pNewVisualConfigs) {
        return FALSE;
    }
d1227 1
a1227 6
    /* Alloc space for the list of new GLX visual privates */
    pNewVisualPriv = (void **) __glXMalloc(numNewConfigs * sizeof(void *));
    if (!pNewVisualPriv) {
        __glXFree(pNewVisualConfigs);
        return FALSE;
    }
d1229 4
a1232 14
    /*
    ** If SetVisualConfigs was not called, then use default GLX
    ** visual configs.
    */
    if (numConfigs == 0) {
        memcpy(pNewVisualConfigs, FallbackConfigs,
               NUM_FALLBACK_CONFIGS * sizeof(__GLXvisualConfig));
        memset(pNewVisualPriv, 0, NUM_FALLBACK_CONFIGS * sizeof(void *));
    }
    else {
        /* copy driver's visual config info */
        for (i = 0; i < numConfigs; i++) {
            pNewVisualConfigs[i] = visualConfigs[i];
            pNewVisualPriv[i] = visualPrivates[i];
d1235 1
d1237 9
a1245 9
    /* Count the number of RGB and CI visual configs */
    numRGBconfigs = 0;
    numCIconfigs = 0;
    for (i = 0; i < numNewConfigs; i++) {
        if (pNewVisualConfigs[i].rgba)
            numRGBconfigs++;
        else
            numCIconfigs++;
    }
d1247 3
a1249 76
    /* Count the total number of visuals to compute */
    numNewVisuals = 0;
    for (i = 0; i < numVisuals; i++) {
        int count;

        count = ((pVisual[i].class == TrueColor
                  || pVisual[i].class == DirectColor)
                 ? numRGBconfigs : numCIconfigs);
        if (count == 0)
            count = 1;                  /* preserve the existing visual */

        numNewVisuals += count;
    }

    /* Reset variables for use with the next screen/driver's visual configs */
    visualConfigs = NULL;
    numConfigs = 0;

    /* Alloc temp space for the list of orig VisualIDs for each new visual */
    orig_vid = (VisualID *)__glXMalloc(numNewVisuals * sizeof(VisualID));
    if (!orig_vid) {
        __glXFree(pNewVisualPriv);
        __glXFree(pNewVisualConfigs);
        return FALSE;
    }

    /* Alloc space for the list of glXVisuals */
    modes = _gl_context_modes_create(numNewVisuals, sizeof(__GLcontextModes));
    if (modes == NULL) {
        __glXFree(orig_vid);
        __glXFree(pNewVisualPriv);
        __glXFree(pNewVisualConfigs);
        return FALSE;
    }

    /* Alloc space for the list of glXVisualPrivates */
    glXVisualPriv = (void **)__glXMalloc(numNewVisuals * sizeof(void *));
    if (!glXVisualPriv) {
        _gl_context_modes_destroy( modes );
        __glXFree(orig_vid);
        __glXFree(pNewVisualPriv);
        __glXFree(pNewVisualConfigs);
        return FALSE;
    }

    /* Alloc space for the new list of the X server's visuals */
    pVisualNew = (VisualPtr)__glXMalloc(numNewVisuals * sizeof(VisualRec));
    if (!pVisualNew) {
        __glXFree(glXVisualPriv);
        _gl_context_modes_destroy( modes );
        __glXFree(orig_vid);
        __glXFree(pNewVisualPriv);
        __glXFree(pNewVisualConfigs);
        return FALSE;
    }

    /* Initialize the new visuals */
    found_default = FALSE;
    glWinScreens[screenInfo.numScreens-1].modes = modes;
    for (i = j = 0; i < numVisuals; i++) {
        int is_rgb = (pVisual[i].class == TrueColor ||
                      pVisual[i].class == DirectColor);

        if (!is_rgb)
        {
            /* We don't support non-rgb visuals for GL. But we don't
               want to remove them either, so just pass them through
               with null glX configs */

            pVisualNew[j] = pVisual[i];
            pVisualNew[j].vid = FakeClientID(0);

            /* Check for the default visual */
            if (!found_default && pVisual[i].vid == *defaultVisp) {
                *defaultVisp = pVisualNew[j].vid;
                found_default = TRUE;
d1252 9
a1260 2
            /* Save the old VisualID */
            orig_vid[j] = pVisual[i].vid;
d1262 2
a1263 3
            /* Initialize the glXVisual */
            _gl_copy_visual_to_context_mode( modes, & NullConfig );
            modes->visualID = pVisualNew[j].vid;
d1265 5
a1269 1
            j++;
d1271 1
a1271 1
            continue;
d1273 2
d1276 6
a1281 3
        for (k = 0; k < numNewConfigs; k++) {
            if (pNewVisualConfigs[k].rgba != is_rgb)
                continue;
d1283 7
a1289 1
            assert( modes != NULL );
d1291 4
a1294 3
            /* Initialize the new visual */
            pVisualNew[j] = pVisual[i];
            pVisualNew[j].vid = FakeClientID(0);
d1296 5
a1300 4
            /* Check for the default visual */
            if (!found_default && pVisual[i].vid == *defaultVisp) {
                *defaultVisp = pVisualNew[j].vid;
                found_default = TRUE;
d1303 6
a1308 2
            /* Save the old VisualID */
            orig_vid[j] = pVisual[i].vid;
d1310 12
a1321 24
            /* Initialize the glXVisual */
            _gl_copy_visual_to_context_mode( modes, & pNewVisualConfigs[k] );
            modes->visualID = pVisualNew[j].vid;

            /*
             * If the class is -1, then assume the X visual information
             * is identical to what GLX needs, and take them from the X
             * visual.  NOTE: if class != -1, then all other fields MUST
             * be initialized.
             */
            if (modes->visualType == GLX_NONE) {
                modes->visualType = _gl_convert_from_x_visual_type( pVisual[i].class );
                modes->redBits    = count_bits(pVisual[i].redMask);
                modes->greenBits  = count_bits(pVisual[i].greenMask);
                modes->blueBits   = count_bits(pVisual[i].blueMask);
                modes->alphaBits  = modes->alphaBits;
                modes->redMask    = pVisual[i].redMask;
                modes->greenMask  = pVisual[i].greenMask;
                modes->blueMask   = pVisual[i].blueMask;
                modes->alphaMask  = modes->alphaMask;
                modes->rgbBits = (is_rgb)
                    ? (modes->redBits + modes->greenBits +
                       modes->blueBits + modes->alphaBits)
                    : rootDepth;
d1324 2
a1325 2
            /* Save the device-dependent private for this visual */
            glXVisualPriv[j] = pNewVisualPriv[k];
d1327 1
a1327 2
            j++;
            modes = modes->next;
d1330 1
d1332 6
a1337 1
    assert(j <= numNewVisuals);
d1339 3
a1341 3
    /* Save the GLX visuals in the screen structure */
    glWinScreens[screenInfo.numScreens-1].num_vis = numNewVisuals;
    glWinScreens[screenInfo.numScreens-1].priv = glXVisualPriv;
d1343 5
a1347 5
    /* Set up depth's VisualIDs */
    for (i = 0; i < ndepth; i++) {
        int numVids = 0;
        VisualID *pVids = NULL;
        int k, n = 0;
d1349 1
a1349 5
        /* Count the new number of VisualIDs at this depth */
        for (j = 0; j < pdepth[i].numVids; j++)
            for (k = 0; k < numNewVisuals; k++)
                if (pdepth[i].vids[j] == orig_vid[k])
                    numVids++;
d1351 4
a1354 2
        /* Allocate a new list of VisualIDs for this depth */
        pVids = (VisualID *)__glXMalloc(numVids * sizeof(VisualID));
d1356 43
a1398 5
        /* Initialize the new list of VisualIDs for this depth */
        for (j = 0; j < pdepth[i].numVids; j++)
            for (k = 0; k < numNewVisuals; k++)
                if (pdepth[i].vids[j] == orig_vid[k])
                    pVids[n++] = pVisualNew[k].vid;
d1400 5
a1404 4
        /* Update this depth's list of VisualIDs */
        __glXFree(pdepth[i].vids);
        pdepth[i].vids = pVids;
        pdepth[i].numVids = numVids;
d1407 16
a1422 3
    /* Update the X server's visuals */
    *nvisualp = numNewVisuals;
    *visualp = pVisualNew;
d1424 15
a1438 2
    /* Free the old list of the X server's visuals */
    __glXFree(pVisual);
d1440 2
a1441 4
    /* Clean up temporary allocations */
    __glXFree(orig_vid);
    __glXFree(pNewVisualPriv);
    __glXFree(pNewVisualConfigs);
d1443 3
a1445 4
    /* Free the private list created by DDX HW driver */
    if (visualPrivates)
        xfree(visualPrivates);
    visualPrivates = NULL;
d1447 1
a1447 1
    return TRUE;
d1450 22
d1473 2
a1474 1
static void fixup_visuals(int screen)
d1476 5
a1480 4
    ScreenPtr pScreen = screenInfo.screens[screen];
    glWinScreenRec *pScr = &glWinScreens[screen];
    __GLcontextModes *modes;
    int j;
d1482 8
a1489 1
    GLWIN_DEBUG_MSG("fixup_visuals\n");
d1491 6
a1496 4
    for (modes = pScr->modes; modes != NULL; modes = modes->next ) {
        const int vis_class = _gl_convert_to_x_visual_type( modes->visualType );
        const int nplanes = (modes->rgbBits - modes->alphaBits);
        VisualPtr pVis = pScreen->visuals;
d1498 4
a1501 4
        /* Find a visual that matches the GLX visual's class and size */
        for (j = 0; j < pScreen->numVisuals; j++) {
            if (pVis[j].class == vis_class &&
                pVis[j].nplanes == nplanes) {
d1503 3
a1505 4
                /* Fixup the masks */
                modes->redMask   = pVis[j].redMask;
                modes->greenMask = pVis[j].greenMask;
                modes->blueMask  = pVis[j].blueMask;
d1507 6
a1512 4
                /* Recalc the sizes */
                modes->redBits   = count_bits(modes->redMask);
                modes->greenBits = count_bits(modes->greenMask);
                modes->blueBits  = count_bits(modes->blueMask);
d1514 8
d1523 2
d1528 4
a1531 1
static void init_screen_visuals(int screen)
d1533 23
a1555 56
    ScreenPtr pScreen = screenInfo.screens[screen];
    __GLcontextModes *modes;
    int *used;
    int i, j;

    GLWIN_DEBUG_MSG("init_screen_visuals\n");

    used = (int *)__glXMalloc(pScreen->numVisuals * sizeof(int));
    __glXMemset(used, 0, pScreen->numVisuals * sizeof(int));

    i = 0;
    for ( modes = glWinScreens[screen].modes
          ; modes != NULL
          ; modes = modes->next) {
        const int vis_class = _gl_convert_to_x_visual_type( modes->visualType );
        const int nplanes = (modes->rgbBits - modes->alphaBits);
        const VisualPtr pVis = pScreen->visuals;

        for (j = 0; j < pScreen->numVisuals; j++) {

            if (pVis[j].class     == vis_class &&
                pVis[j].nplanes   == nplanes &&
                pVis[j].redMask   == modes->redMask &&
                pVis[j].greenMask == modes->greenMask &&
                pVis[j].blueMask  == modes->blueMask &&
                !used[j]) {

#if 0
                /* Create the XMesa visual */
                pXMesaVisual[i] =
                    XMesaCreateVisual(pScreen,
                                      pVis,
                                      modes->rgbMode,
                                      (modes->alphaBits > 0),
                                      modes->doubleBufferMode,
                                      modes->stereoMode,
                                      GL_TRUE, /* ximage_flag */
                                      modes->depthBits,
                                      modes->stencilBits,
                                      modes->accumRedBits,
                                      modes->accumGreenBits,
                                      modes->accumBlueBits,
                                      modes->accumAlphaBits,
                                      modes->samples,
                                      modes->level,
                                      modes->visualRating);
#endif
                
                /* Set the VisualID */
                modes->visualID = pVis[j].vid;

                /* Mark this visual used */
                used[j] = 1;
                break;
            }
        }
d1557 3
a1559 10
        if ( j == pScreen->numVisuals ) {
            ErrorF("No matching visual for __GLcontextMode with "
                   "visual class = %d (%d), nplanes = %u\n",
                   vis_class, 
                   modes->visualType,
                   (modes->rgbBits - modes->alphaBits) );
        }
        else if ( modes->visualID == -1 ) {
            FatalError( "Matching visual found, but visualID still -1!\n" );
        }
d1561 1
a1561 3
        i++;
        
    }
d1563 1
a1563 1
    __glXFree(used);
d1565 1
a1565 1
    /* glWinScreens[screen].xm_vis = pXMesaVisual; */
d1568 7
a1574 1
static Bool glWinScreenProbe(int screen)
d1576 18
a1593 2
    ScreenPtr pScreen;
    glWinScreenRec *screenPriv;
d1595 2
a1596 1
    GLWIN_DEBUG_MSG("glWinScreenProbe\n");
d1598 9
a1606 7
    /*
     * Set up the current screen's visuals.
     */
    __glDDXScreenInfo.modes = glWinScreens[screen].modes;
    __glDDXScreenInfo.pVisualPriv = glWinScreens[screen].priv;
    __glDDXScreenInfo.numVisuals =
        __glDDXScreenInfo.numUsableVisuals = glWinScreens[screen].num_vis;
d1608 20
a1627 5
    /*
     * Set the current screen's createContext routine.  This could be
     * wrapped by a DDX GLX context creation routine.
     */
    __glDDXScreenInfo.createContext = glWinCreateContext;
d1629 2
a1630 5
    /*
     * The ordering of the rgb compenents might have been changed by the
     * driver after mi initialized them.
     */
    fixup_visuals(screen);
d1632 1
a1632 15
    /*
     * Find the GLX visuals that are supported by this screen and create
     * XMesa's visuals.
     */
    init_screen_visuals(screen);

    /* Wrap RealizeWindow and UnrealizeWindow on this screen */
    pScreen = screenInfo.screens[screen];
    screenPriv = &glWinScreens[screen];
    screenPriv->RealizeWindow = pScreen->RealizeWindow;
    pScreen->RealizeWindow = glWinRealizeWindow;
    screenPriv->UnrealizeWindow = pScreen->UnrealizeWindow;
    pScreen->UnrealizeWindow = glWinUnrealizeWindow;
    screenPriv->CopyWindow = pScreen->CopyWindow;
    pScreen->CopyWindow = glWinCopyWindow;
d1634 1
a1634 1
    return TRUE;
d1637 4
a1640 1
static GLboolean glWinSwapBuffers(__GLXdrawablePrivate *glxPriv)
d1642 2
a1643 6
  /* swap buffers on only *one* of the contexts
   * (e.g. the last one for drawing)
   */
    __GLcontext *gc = (__GLcontext *)glxPriv->drawGlxc->gc;
    HDC dc;
    BOOL ret;
d1645 45
a1689 1
    GLWIN_TRACE_MSG("glWinSwapBuffers (ctx %p)\n", (gc!=NULL?gc->ctx:NULL));
d1691 5
a1695 1
    if (gc != NULL && gc->ctx != NULL)
d1697 6
a1702 11
        dc = glWinMakeDC(gc);
        if (dc == NULL)
            return GL_FALSE;

        ret = SwapBuffers(dc);
        if (!ret)
            ErrorF("SwapBuffers failed: %s\n", glWinErrorMessage());
        
        ReleaseDC(gc->winInfo.hwnd, dc);
        if (!ret)
            return GL_FALSE;
d1705 23
a1727 1
    return GL_TRUE;
d1730 9
a1738 1
static void glWinDestroyDrawablePrivate(__GLdrawablePrivate *glPriv)
d1740 64
a1803 1
    GLWIN_DEBUG_MSG("glWinDestroyDrawablePrivate\n");
d1805 1
a1805 3
    /* It doesn't work to call DRIDestroySurface here, the drawable's
       already gone.. But dri.c notices the window destruction and
       frees the surface itself. */
d1807 121
a1927 3
    free(glPriv->private);
    glPriv->private = NULL;
}
d1929 6
d1936 1
a1936 4
static void glWinCreateBuffer(__GLXdrawablePrivate *glxPriv)
{
    GLWinDrawableRec *winPriv = malloc(sizeof(GLWinDrawableRec));
    __GLdrawablePrivate *glPriv = &glxPriv->glPriv;
d1938 3
a1940 2
    /*winPriv->sid = 0; */
    winPriv->pDraw = NULL;
d1942 2
a1943 1
    GLWIN_DEBUG_MSG("glWinCreateBuffer\n");
d1945 1
a1945 2
    /* replace swapBuffers (original is never called) */
    glxPriv->swapBuffers = glWinSwapBuffers;
d1947 2
a1948 3
    /* stash private data */
    glPriv->private = winPriv;
    glPriv->freePrivate = glWinDestroyDrawablePrivate;
d1951 3
a1953 1
static void glWinResetExtension(void)
d1955 12
a1966 1
    GLWIN_DEBUG_MSG("glWinResetExtension\n");
d1969 3
a1971 1
/* based on code in apples/indirect.c which is based on i830_dri.c */
d1973 1
a1973 1
glWinInitVisualConfigs(void)
d1975 139
a2113 72
    int                 lclNumConfigs     = 0;
    __GLXvisualConfig  *lclVisualConfigs  = NULL;
    void              **lclVisualPrivates = NULL;

    int depth, aux, buffers, stencil, accum;
    int i = 0;

    GLWIN_DEBUG_MSG("glWinInitVisualConfigs ");
        
    /* count num configs:
        2 Z buffer (0, 24 bit)
        2 AUX buffer (0, 2)
        2 buffers (single, double)
        2 stencil (0, 8 bit)
        2 accum (0, 64 bit)
        = 32 configs */

    lclNumConfigs = 2 * 2 * 2 * 2 * 2; /* 32 */

    /* alloc */
    lclVisualConfigs = xcalloc(sizeof(__GLXvisualConfig), lclNumConfigs);
    lclVisualPrivates = xcalloc(sizeof(void *), lclNumConfigs);

    /* fill in configs */
    if (NULL != lclVisualConfigs) {
        i = 0; /* current buffer */
        for (depth = 0; depth < 2; depth++) {
            for (aux = 0; aux < 2; aux++) {
                for (buffers = 0; buffers < 2; buffers++) {
                    for (stencil = 0; stencil < 2; stencil++) {
                        for (accum = 0; accum < 2; accum++) {
                            lclVisualConfigs[i].vid = -1;
                            lclVisualConfigs[i].class = -1;
                            lclVisualConfigs[i].rgba = TRUE;
                            lclVisualConfigs[i].redSize = -1;
                            lclVisualConfigs[i].greenSize = -1;
                            lclVisualConfigs[i].blueSize = -1;
                            lclVisualConfigs[i].redMask = -1;
                            lclVisualConfigs[i].greenMask = -1;
                            lclVisualConfigs[i].blueMask = -1;
                            lclVisualConfigs[i].alphaMask = 0;
                            if (accum) {
                                lclVisualConfigs[i].accumRedSize = 16;
                                lclVisualConfigs[i].accumGreenSize = 16;
                                lclVisualConfigs[i].accumBlueSize = 16;
                                lclVisualConfigs[i].accumAlphaSize = 16;
                            }
                            else {
                                lclVisualConfigs[i].accumRedSize = 0;
                                lclVisualConfigs[i].accumGreenSize = 0;
                                lclVisualConfigs[i].accumBlueSize = 0;
                                lclVisualConfigs[i].accumAlphaSize = 0;
                            }
                            lclVisualConfigs[i].doubleBuffer = buffers ? TRUE : FALSE;
                            lclVisualConfigs[i].stereo = FALSE;
                            lclVisualConfigs[i].bufferSize = -1;
                            
                            lclVisualConfigs[i].depthSize = depth? 24 : 0;
                            lclVisualConfigs[i].stencilSize = stencil ? 8 : 0;
                            lclVisualConfigs[i].auxBuffers = aux ? 2 : 0;
                            lclVisualConfigs[i].level = 0;
                            lclVisualConfigs[i].visualRating = GLX_NONE_EXT;
                            lclVisualConfigs[i].transparentPixel = 0;
                            lclVisualConfigs[i].transparentRed = 0;
                            lclVisualConfigs[i].transparentGreen = 0;
                            lclVisualConfigs[i].transparentBlue = 0;
                            lclVisualConfigs[i].transparentAlpha = 0;
                            lclVisualConfigs[i].transparentIndex = 0;
                            i++;
                        }
                    }
                }
d2115 87
d2203 78
a2280 3
    }
    if (i != lclNumConfigs)
        GLWIN_DEBUG_MSG("glWinInitVisualConfigs failed to alloc visual configs");
d2282 3
a2284 2
    GlxSetVisualConfigs(lclNumConfigs, lclVisualConfigs, lclVisualPrivates);
}
d2286 2
a2287 5
/* Copied from Mesa */
static void glWinSetVisualConfigs(int nconfigs, __GLXvisualConfig *configs,
                                   void **privates)
{
    GLWIN_DEBUG_MSG("glWinSetVisualConfigs\n");
d2289 19
a2307 4
    numConfigs = nconfigs;
    visualConfigs = configs;
    visualPrivates = privates;
}
d2309 1
a2309 7
/* Copied from Mesa */
static Bool glWinInitVisuals(VisualPtr *visualp, DepthPtr *depthp,
                              int *nvisualp, int *ndepthp,
                              int *rootDepthp, VisualID *defaultVisp,
                              unsigned long sizes, int bitsPerRGB)
{
    glWinInitDebugSettings();
d2311 3
a2313 1
    GLWIN_DEBUG_MSG("glWinInitVisuals\n");
d2315 2
a2316 2
    if (0 == numConfigs) /* if no configs */
        glWinInitVisualConfigs(); /* ensure the visula configs are setup */
d2318 2
a2319 5
    /*
     * Setup the visuals supported by this particular screen.
     */
    return init_visuals(nvisualp, visualp, defaultVisp,
                        *ndepthp, *depthp, *rootDepthp);
@

