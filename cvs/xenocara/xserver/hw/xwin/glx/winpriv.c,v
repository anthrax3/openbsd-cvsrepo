head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.6
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.4
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.2
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.3.0.14
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.12
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.10
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	s0SI41sEunLdyFfd;

1.4
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.3;
commitid	Te1daavkBLskZ8gc;

1.3
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Export window information for the Windows-OpenGL GLX implementation.
 *
 * Authors: Alexander Gottwald
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include "winpriv.h"
#include "winwindow.h"

void
 winCreateWindowsWindow(WindowPtr pWin);

/**
 * Return size and handles of a window.
 * If pWin is NULL, then the information for the root window is requested.
 */
HWND
winGetWindowInfo(WindowPtr pWin)
{
    winTrace("%s: pWin %p XID 0x%x\n", __FUNCTION__, pWin, (unsigned int)pWin->drawable.id);

    /* a real window was requested */
    if (pWin != NULL) {
        /* Get the window and screen privates */
        ScreenPtr pScreen = pWin->drawable.pScreen;
        winPrivScreenPtr pWinScreen = winGetScreenPriv(pScreen);
        winScreenInfoPtr pScreenInfo = NULL;
        HWND hwnd = NULL;

        if (pWinScreen == NULL) {
            ErrorF("winGetWindowInfo: screen has no privates\n");
            return NULL;
        }

        hwnd = pWinScreen->hwndScreen;

        pScreenInfo = pWinScreen->pScreenInfo;
#ifdef XWIN_MULTIWINDOW
        /* check for multiwindow mode */
        if (pScreenInfo->fMultiWindow) {
            winWindowPriv(pWin);

            if (pWinPriv == NULL) {
                ErrorF("winGetWindowInfo: window has no privates\n");
                return hwnd;
            }

            if (pWinPriv->hWnd == NULL) {
                winCreateWindowsWindow(pWin);
                winDebug("winGetWindowInfo: forcing window to exist\n");
            }

            if (pWinPriv->hWnd != NULL) {
                /* copy window handle */
                hwnd = pWinPriv->hWnd;

                /* mark GLX active on that hwnd */
                pWinPriv->fWglUsed = TRUE;
            }

            return hwnd;
        }
#endif
#ifdef XWIN_MULTIWINDOWEXTWM
        /* check for multiwindow external wm mode */
        if (pScreenInfo->fMWExtWM) {
            win32RootlessWindowPtr pRLWinPriv
                = (win32RootlessWindowPtr) RootlessFrameForWindow(pWin, FALSE);

            if (pRLWinPriv == NULL) {
                ErrorF("winGetWindowInfo: window has no privates\n");
                return hwnd;
            }

            if (pRLWinPriv->hWnd != NULL) {
                /* copy window handle */
                hwnd = pRLWinPriv->hWnd;
            }
            return hwnd;
        }
#endif
    }
    else {
        ScreenPtr pScreen = g_ScreenInfo[0].pScreen;
        winPrivScreenPtr pWinScreen = winGetScreenPriv(pScreen);

        if (pWinScreen == NULL) {
            ErrorF("winGetWindowInfo: screen has no privates\n");
            return NULL;
        }

        ErrorF("winGetWindowInfo: returning root window\n");

        return pWinScreen->hwndScreen;
    }

    return NULL;
}

Bool
winCheckScreenAiglxIsSupported(ScreenPtr pScreen)
{
    winPrivScreenPtr pWinScreen = winGetScreenPriv(pScreen);
    winScreenInfoPtr pScreenInfo = pWinScreen->pScreenInfo;

#ifdef XWIN_MULTIWINDOW
    if (pScreenInfo->fMultiWindow)
        return TRUE;
#endif

#ifdef XWIN_MULTIWINDOWEXTWM
    if (pScreenInfo->fMWExtWM)
        return TRUE;
#endif

    return FALSE;
}
@


1.4
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d24 1
a24 1
    winTrace("%s: pWin %p XID 0x%x\n", __FUNCTION__, pWin, pWin->drawable.id);
@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d54 1
a54 1
                ErrorF("winGetWindowInfo: forcing window to exist...\n");
@


1.2
log
@Update to xserver 1.11.2
@
text
@d15 2
a16 1
winCreateWindowsWindow (WindowPtr pWin);
d21 2
a22 1
HWND winGetWindowInfo(WindowPtr pWin)
d27 1
a27 2
    if (pWin != NULL)
    {
d34 1
a34 2
        if (pWinScreen == NULL)
        {
d44 1
a44 2
        if (pScreenInfo->fMultiWindow)
        {
d47 1
a47 2
            if (pWinPriv == NULL)
            {
d52 3
a54 4
            if (pWinPriv->hWnd == NULL)
            {
              winCreateWindowsWindow(pWin);
              ErrorF("winGetWindowInfo: forcing window to exist...\n");
d57 1
a57 2
            if (pWinPriv->hWnd != NULL)
              {
d63 1
a63 1
              }
d70 1
a70 2
        if (pScreenInfo->fMWExtWM)
        {
d72 1
a72 1
                = (win32RootlessWindowPtr) RootlessFrameForWindow (pWin, FALSE);
d79 1
a79 2
            if (pRLWinPriv->hWnd != NULL)
            {
d87 1
a87 2
    else
    {
d91 1
a91 2
        if (pWinScreen == NULL)
        {
d107 2
a108 2
  winPrivScreenPtr pWinScreen = winGetScreenPriv(pScreen);
  winScreenInfoPtr pScreenInfo = pWinScreen->pScreenInfo;
d111 2
a112 2
  if (pScreenInfo->fMultiWindow)
    return TRUE;
d116 2
a117 2
  if (pScreenInfo->fMWExtWM)
    return TRUE;
d120 1
a120 1
  return FALSE;
@


1.1
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d22 1
a22 1
    winDebug("%s: pWin=%p\n", __FUNCTION__, pWin);
d64 3
@

