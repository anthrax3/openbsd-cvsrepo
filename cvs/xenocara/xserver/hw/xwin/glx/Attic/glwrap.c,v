head	1.5;
access;
symbols
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.6
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.0.10
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.6
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.2
	OPENBSD_4_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	2014.05.02.19.27.50;	author matthieu;	state dead;
branches;
next	1.4;

1.4
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * File: glwrap.c
 * Purpose: Wrapper functions for Win32 OpenGL functions
 *
 * Authors: Alexander Gottwald
 *          Jon TURNEY
 *
 * Copyright (c) Jon TURNEY 2009
 * Copyright (c) Alexander Gottwald 2004
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

// define USE_OPENGL32 makes gl.h declare gl*() function prototypes with stdcall linkage,
// so our generated wrappers will correctly link with the functions in opengl32.dll
#define USE_OPENGL32

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif

#include <X11/Xwindows.h>
#include <GL/gl.h>
#include <GL/glext.h>
#include <glx/glxserver.h>
#include <glx/glxext.h>
#include <glx/glapi.h>
#include <glx/dispatch.h>
#include <glwindows.h>

static unsigned int glWinIndirectProcCalls = 0;
static unsigned int glWinDirectProcCalls = 0;

void
glWinCallDelta(void)
{
    static unsigned int glWinIndirectProcCallsLast = 0;
    static unsigned int glWinDirectProcCallsLast = 0;

    if ((glWinIndirectProcCalls != glWinIndirectProcCallsLast) ||
        (glWinDirectProcCalls != glWinDirectProcCallsLast)) {
        if (glxWinDebugSettings.enableTrace) {
            ErrorF("after %d direct and %d indirect GL calls\n",
                   glWinDirectProcCalls - glWinDirectProcCallsLast,
                   glWinIndirectProcCalls - glWinIndirectProcCallsLast);
        }
        glWinDirectProcCallsLast = glWinDirectProcCalls;
        glWinIndirectProcCallsLast = glWinIndirectProcCalls;
    }
}

static PROC
glWinResolveHelper(PROC * cache, const char *symbol)
{
    PROC proc = NULL;

    /* If not yet cached, call wglGetProcAddress */
    if ((*cache) == NULL) {
        proc = wglGetProcAddress(symbol);
        if (proc == NULL) {
            ErrorF("glwrap: Can't resolve \"%s\"\n", symbol);
            (*cache) = (PROC) - 1;
        }
        else {
            ErrorF("glwrap: Resolved \"%s\"\n", symbol);
            (*cache) = proc;
        }
    }
    /* Cached wglGetProcAddress failure */
    else if ((*cache) == (PROC) - 1) {
        proc = 0;
    }
    /* Cached wglGetProcAddress result */
    else {
        proc = (*cache);
    }

    return proc;
}

#define RESOLVE_RET(proctype, symbol, retval) \
    static PROC cache = NULL; \
    __stdcall proctype proc = (proctype)glWinResolveHelper(&cache, symbol); \
    if (proc == NULL) { \
        __glXErrorCallBack(0); \
        return retval; \
    } \
    glWinIndirectProcCalls++;

#define RESOLVE(proctype, symbol) RESOLVE_RET(proctype, symbol,)

#define RESOLVED_PROC(proctype) proc

/*
  Include generated cdecl wrappers for stdcall gl*() functions in opengl32.dll

  OpenGL 1.2 and upward is treated as extensions, function address must
  found using wglGetProcAddress(), but also stdcall so still need wrappers...

  Include generated dispatch table setup function
*/

#include "generated_gl_wrappers.c"

/*
  Special non-static wrapper for glGetString for debug output
*/

const GLubyte *
glGetStringWrapperNonstatic(GLenum name)
{
    return glGetString(name);
}

/*
  Special non-static wrapper for glAddSwapHintRectWIN for copySubBuffers
*/

typedef void (__stdcall * PFNGLADDSWAPHINTRECTWIN) (GLint x, GLint y,
                                                    GLsizei width,
                                                    GLsizei height);

void
glAddSwapHintRectWINWrapperNonstatic(GLint x, GLint y, GLsizei width,
                                     GLsizei height)
{
    RESOLVE(PFNGLADDSWAPHINTRECTWIN, "glAddSwapHintRectWIN");
    proc(x, y, width, height);
}
@


1.4
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d70 1
a70 1
glWinResolveHelper(PROC * cache, char *symbol)
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d54 9
a62 10
  static unsigned int glWinIndirectProcCallsLast = 0;
  static unsigned int glWinDirectProcCallsLast = 0;
  if ((glWinIndirectProcCalls != glWinIndirectProcCallsLast) ||
      (glWinDirectProcCalls != glWinDirectProcCallsLast))
    {
      if (glxWinDebugSettings.enableTrace)
        {
          ErrorF("after %d direct and %d indirect GL calls\n",
                 glWinDirectProcCalls - glWinDirectProcCallsLast,
                 glWinIndirectProcCalls - glWinIndirectProcCallsLast);
d64 2
a65 2
      glWinDirectProcCallsLast = glWinDirectProcCalls;
      glWinIndirectProcCallsLast = glWinIndirectProcCalls;
d70 1
a70 1
glWinResolveHelper(PROC *cache, char *symbol)
d72 1
a72 1
  PROC proc = NULL;
d74 6
a79 8
  /* If not yet cached, call wglGetProcAddress */
  if ((*cache) == NULL)
    {
      proc = wglGetProcAddress(symbol);
      if (proc == NULL)
        {
          ErrorF("glwrap: Can't resolve \"%s\"\n", symbol);
          (*cache) = (PROC)-1;
d81 3
a83 4
      else
        {
          ErrorF("glwrap: Resolved \"%s\"\n", symbol);
          (*cache) = proc;
d86 3
a88 4
  /* Cached wglGetProcAddress failure */
  else if ((*cache) == (PROC)-1)
    {
      proc = 0;
d90 3
a92 4
  /* Cached wglGetProcAddress result */
  else
    {
      proc = (*cache);
d95 1
a95 1
  return proc;
d126 2
a127 1
const GLubyte* glGetStringWrapperNonstatic(GLenum name)
d129 1
a129 1
  return glGetString(name);
d136 7
a142 3
typedef void (__stdcall *PFNGLADDSWAPHINTRECTWIN)(GLint x, GLint y, GLsizei width, GLsizei height);

void glAddSwapHintRectWINWrapperNonstatic(GLint x, GLint y, GLsizei width, GLsizei height)
d144 2
a145 2
  RESOLVE(PFNGLADDSWAPHINTRECTWIN, "glAddSwapHintRectWIN");
  proc(x, y, width, height);
a146 1

@


1.1
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d2 2
a3 2
 * GLX implementation that uses Win32's OpenGL
 * Wrapper functions for Win32's OpenGL
d6 23
d31 6
a36 2
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
d42 25
a66 17
#include <glxserver.h>
#include <glxext.h>

#define RESOLVE_RET(procname, symbol, retval) \
    static Bool init = TRUE; \
    static procname proc = NULL; \
    if (init) { \
        proc = (procname)wglGetProcAddress(symbol); \
        init = FALSE; \
        if (proc == NULL) { \
            ErrorF("glwrap: Can't resolve \"%s\"\n", symbol); \
        } else \
            ErrorF("glwrap: resolved \"%s\"\n", symbol); \
    } \
    if (proc == NULL) { \
        __glXErrorCallBack(NULL, 0); \
        return retval; \
a67 14
#define RESOLVE(procname, symbol) RESOLVE_RET(procname, symbol,)
        
        
/*
 * GL_ARB_imaging
 */


GLAPI void GLAPIENTRY glColorTable( GLenum target, GLenum internalformat,
                                    GLsizei width, GLenum format,
                                    GLenum type, const GLvoid *table )
{
    RESOLVE(PFNGLCOLORTABLEPROC, "glColorTable");
    proc(target, internalformat, width, format, type, table);
d70 2
a71 4
GLAPI void GLAPIENTRY glColorSubTable( GLenum target,
                                       GLsizei start, GLsizei count,
                                       GLenum format, GLenum type,
                                       const GLvoid *data )
d73 1
a73 3
    RESOLVE(PFNGLCOLORSUBTABLEPROC, "glColorSubTable");
    proc(target, start, count, format, type, data);
}
d75 25
a99 6
GLAPI void GLAPIENTRY glColorTableParameteriv(GLenum target, GLenum pname,
                                              const GLint *params)
{
    RESOLVE(PFNGLCOLORTABLEPARAMETERIVPROC, "glColorTableParameteriv");
    proc(target, pname, params);
}
d101 1
a101 5
GLAPI void GLAPIENTRY glColorTableParameterfv(GLenum target, GLenum pname,
                                              const GLfloat *params)
{
    RESOLVE(PFNGLCOLORTABLEPARAMETERFVPROC, "glColorTableParameterfv");
    proc(target, pname, params);
d104 8
a111 6
GLAPI void GLAPIENTRY glCopyColorSubTable( GLenum target, GLsizei start,
                                           GLint x, GLint y, GLsizei width )
{
    RESOLVE(PFNGLCOPYCOLORSUBTABLEPROC, "glCopyColorSubTable");
    proc(target, start, x, y, width);
}
d113 1
a113 6
GLAPI void GLAPIENTRY glCopyColorTable( GLenum target, GLenum internalformat,
                                        GLint x, GLint y, GLsizei width )
{
    RESOLVE(PFNGLCOPYCOLORTABLEPROC, "glCopyColorTable");
    proc(target, internalformat, x, y, width);
}
d115 1
a115 199

GLAPI void GLAPIENTRY glGetColorTable( GLenum target, GLenum format,
                                       GLenum type, GLvoid *table )
{
    RESOLVE(PFNGLGETCOLORTABLEPROC, "glGetColorTable");
    proc(target, format, type, table);
}

GLAPI void GLAPIENTRY glGetColorTableParameterfv( GLenum target, GLenum pname,
                                                  GLfloat *params )
{
    RESOLVE(PFNGLGETCOLORTABLEPARAMETERFVPROC, "glGetColorTableParameterfv");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glGetColorTableParameteriv( GLenum target, GLenum pname,
                                                  GLint *params )
{
    RESOLVE(PFNGLGETCOLORTABLEPARAMETERIVPROC, "glGetColorTableParameteriv");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glBlendEquation( GLenum mode )
{
    RESOLVE(PFNGLBLENDEQUATIONPROC, "glBlendEquation");
    proc(mode);
}

GLAPI void GLAPIENTRY glBlendColor( GLclampf red, GLclampf green,
                                    GLclampf blue, GLclampf alpha )
{
    RESOLVE(PFNGLBLENDCOLORPROC, "glBlendColor");
    proc(red, green, blue, alpha);
}

GLAPI void GLAPIENTRY glHistogram( GLenum target, GLsizei width,
				   GLenum internalformat, GLboolean sink )
{
    RESOLVE(PFNGLHISTOGRAMPROC, "glHistogram");
    proc(target, width, internalformat, sink);
}

GLAPI void GLAPIENTRY glResetHistogram( GLenum target )
{
    RESOLVE(PFNGLRESETHISTOGRAMPROC, "glResetHistogram");
    proc(target);
}

GLAPI void GLAPIENTRY glGetHistogram( GLenum target, GLboolean reset,
				      GLenum format, GLenum type,
				      GLvoid *values )
{
    RESOLVE(PFNGLGETHISTOGRAMPROC, "glGetHistogram");
    proc(target, reset, format, type, values);
};

GLAPI void GLAPIENTRY glGetHistogramParameterfv( GLenum target, GLenum pname,
						 GLfloat *params )
{
    RESOLVE(PFNGLGETHISTOGRAMPARAMETERFVPROC, "glGetHistogramParameterfv");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glGetHistogramParameteriv( GLenum target, GLenum pname,
						 GLint *params )
{
    RESOLVE(PFNGLGETHISTOGRAMPARAMETERIVPROC, "glGetHistogramParameteriv");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glMinmax( GLenum target, GLenum internalformat,
				GLboolean sink )
{
    RESOLVE(PFNGLMINMAXPROC, "glMinmax");
    proc(target, internalformat, sink);
}

GLAPI void GLAPIENTRY glResetMinmax( GLenum target )
{
    RESOLVE(PFNGLRESETMINMAXPROC, "glResetMinmax");
    proc(target);
}

GLAPI void GLAPIENTRY glGetMinmax( GLenum target, GLboolean reset,
                                   GLenum format, GLenum types,
                                   GLvoid *values )
{
    RESOLVE(PFNGLGETMINMAXPROC, "glGetMinmax");
    proc(target, reset, format, types, values);
}

GLAPI void GLAPIENTRY glGetMinmaxParameterfv( GLenum target, GLenum pname,
					      GLfloat *params )
{
    RESOLVE(PFNGLGETMINMAXPARAMETERFVPROC, "glGetMinmaxParameterfv");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glGetMinmaxParameteriv( GLenum target, GLenum pname,
					      GLint *params )
{
    RESOLVE(PFNGLGETMINMAXPARAMETERIVPROC, "glGetMinmaxParameteriv");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glConvolutionFilter1D( GLenum target,
	GLenum internalformat, GLsizei width, GLenum format, GLenum type,
	const GLvoid *image )
{
    RESOLVE(PFNGLCONVOLUTIONFILTER1DPROC, "glConvolutionFilter1D");
    proc(target, internalformat, width, format, type, image);
}

GLAPI void GLAPIENTRY glConvolutionFilter2D( GLenum target,
	GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
	GLenum type, const GLvoid *image )
{
    RESOLVE(PFNGLCONVOLUTIONFILTER2DPROC, "glConvolutionFilter2D");
    proc(target, internalformat, width, height, format, type, image);
}

GLAPI void GLAPIENTRY glConvolutionParameterf( GLenum target, GLenum pname,
	GLfloat params )
{
    RESOLVE(PFNGLCONVOLUTIONPARAMETERFPROC, "glConvolutionParameterf");
    proc(target, pname, params); 
}

GLAPI void GLAPIENTRY glConvolutionParameterfv( GLenum target, GLenum pname,
	const GLfloat *params )
{
    RESOLVE(PFNGLCONVOLUTIONPARAMETERFVPROC, "glConvolutionParameterfv");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glConvolutionParameteri( GLenum target, GLenum pname,
	GLint params )
{
    RESOLVE(PFNGLCONVOLUTIONPARAMETERIPROC, "glConvolutionParameteri");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glConvolutionParameteriv( GLenum target, GLenum pname,
	const GLint *params )
{
    RESOLVE(PFNGLCONVOLUTIONPARAMETERIVPROC, "glConvolutionParameteriv");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glCopyConvolutionFilter1D( GLenum target,
	GLenum internalformat, GLint x, GLint y, GLsizei width )
{
    RESOLVE(PFNGLCOPYCONVOLUTIONFILTER1DPROC, "glCopyConvolutionFilter1D");
    proc(target, internalformat, x, y, width);
}

GLAPI void GLAPIENTRY glCopyConvolutionFilter2D( GLenum target,
	GLenum internalformat, GLint x, GLint y, GLsizei width,
	GLsizei height)
{
    RESOLVE(PFNGLCOPYCONVOLUTIONFILTER2DPROC, "glCopyConvolutionFilter2D");
    proc(target, internalformat, x, y, width, height);
}

GLAPI void GLAPIENTRY glGetConvolutionFilter( GLenum target, GLenum format,
	GLenum type, GLvoid *image )
{
    RESOLVE(PFNGLGETCONVOLUTIONFILTERPROC, "glGetConvolutionFilter");
    proc(target, format, type, image);
}

GLAPI void GLAPIENTRY glGetConvolutionParameterfv( GLenum target, GLenum pname,
	GLfloat *params )
{
    RESOLVE(PFNGLGETCONVOLUTIONPARAMETERFVPROC, "glGetConvolutionParameterfv");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glGetConvolutionParameteriv( GLenum target, GLenum pname,
	GLint *params )
{
    RESOLVE(PFNGLGETCONVOLUTIONPARAMETERIVPROC, "glGetConvolutionParameteriv");
    proc(target, pname, params);
}

GLAPI void GLAPIENTRY glSeparableFilter2D( GLenum target,
	GLenum internalformat, GLsizei width, GLsizei height, GLenum format,
	GLenum type, const GLvoid *row, const GLvoid *column )
{
    RESOLVE(PFNGLSEPARABLEFILTER2DPROC, "glSeparableFilter2D");
    proc(target, internalformat, width, height, format, type, row, column);
}

GLAPI void GLAPIENTRY glGetSeparableFilter( GLenum target, GLenum format,
	GLenum type, GLvoid *row, GLvoid *column, GLvoid *span )
{
    RESOLVE(PFNGLGETSEPARABLEFILTERPROC, "glGetSeparableFilter");
    proc(target, format, type, row, column, span);
}
d118 1
a118 2
 * OpenGL 1.2
 */
d120 2
a121 10
GLAPI void GLAPIENTRY glTexImage3D( GLenum target, GLint level,
                                      GLint internalFormat,
                                      GLsizei width, GLsizei height,
                                      GLsizei depth, GLint border,
                                      GLenum format, GLenum type,
                                      const GLvoid *pixels )
{
    RESOLVE(PFNGLTEXIMAGE3DPROC, "glTexImage3D");
    proc(target, level, internalFormat, width, height, depth, border, format, type, pixels);
}
d123 2
a124 20
GLAPI void GLAPIENTRY glTexSubImage3D( GLenum target, GLint level,
                                         GLint xoffset, GLint yoffset,
                                         GLint zoffset, GLsizei width,
                                         GLsizei height, GLsizei depth,
                                         GLenum format,
                                         GLenum type, const GLvoid *pixels)
{
    RESOLVE(PFNGLTEXSUBIMAGE3DPROC, "glTexSubImage3D");
    proc(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

GLAPI void GLAPIENTRY glCopyTexSubImage3D( GLenum target, GLint level,
                                             GLint xoffset, GLint yoffset,
                                             GLint zoffset, GLint x,
                                             GLint y, GLsizei width,
                                             GLsizei height )
{
    RESOLVE(PFNGLCOPYTEXSUBIMAGE3DPROC, "glCopyTexSubImage3D");
    proc(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}
d126 1
d129 2
a130 21
 * 20. GL_EXT_texture_object
 */
GLAPI void GLAPIENTRY glGenTexturesEXT( GLsizei n, GLuint *textures )
{
    glGenTextures(n, textures);
}

GLAPI void GLAPIENTRY glDeleteTexturesEXT( GLsizei n, const GLuint *textures)
{
    glDeleteTextures(n, textures);
}

GLAPI void GLAPIENTRY glBindTextureEXT( GLenum target, GLuint texture )
{
    glBindTexture(target, target);
}

GLAPI void GLAPIENTRY glPrioritizeTexturesEXT( GLsizei n, const GLuint *textures, const GLclampf *priorities )
{
    glPrioritizeTextures(n, textures, priorities);
}
d132 1
a132 1
GLAPI GLboolean GLAPIENTRY glAreTexturesResidentEXT( GLsizei n, const GLuint *textures, GLboolean *residences )
d134 1
a134 6
    return glAreTexturesResident(n, textures, residences);
}

GLAPI GLboolean GLAPIENTRY glIsTextureEXT( GLuint texture )
{
    return glIsTexture(texture); 
d138 2
a139 92
 * GL_ARB_multitexture (ARB extension 1 and OpenGL 1.2.1)
 */

GLAPI void GLAPIENTRY glActiveTextureARB(GLenum texture)
{
    RESOLVE(PFNGLACTIVETEXTUREARBPROC, "glActiveTextureARB");
    proc(texture);
}

GLAPI void GLAPIENTRY glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
{
    RESOLVE(PFNGLMULTITEXCOORD1DVARBPROC, "glMultiTexCoord1dvARB");
    proc(target, v);
}

GLAPI void GLAPIENTRY glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
{
    RESOLVE(PFNGLMULTITEXCOORD1FVARBPROC, "glMultiTexCoord1fvARB");
    proc(target, v);
}

GLAPI void GLAPIENTRY glMultiTexCoord1ivARB(GLenum target, const GLint *v)
{
    RESOLVE(PFNGLMULTITEXCOORD1IVARBPROC, "glMultiTexCoord1ivARB");
    proc(target, v);
}

GLAPI void GLAPIENTRY glMultiTexCoord1svARB(GLenum target, const GLshort *v)
{
    RESOLVE(PFNGLMULTITEXCOORD1SVARBPROC, "glMultiTexCoord1svARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
{
    RESOLVE(PFNGLMULTITEXCOORD2DVARBPROC, "glMultiTexCoord2dvARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
{
    RESOLVE(PFNGLMULTITEXCOORD2FVARBPROC, "glMultiTexCoord2fvARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord2ivARB(GLenum target, const GLint *v)
{
    RESOLVE(PFNGLMULTITEXCOORD2IVARBPROC, "glMultiTexCoord2ivARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord2svARB(GLenum target, const GLshort *v)
{
    RESOLVE(PFNGLMULTITEXCOORD1SVARBPROC, "glMultiTexCoord1svARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
{
    RESOLVE(PFNGLMULTITEXCOORD3DVARBPROC, "glMultiTexCoord3dvARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
{
    RESOLVE(PFNGLMULTITEXCOORD3FVARBPROC, "glMultiTexCoord3fvARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord3ivARB(GLenum target, const GLint *v)
{
    RESOLVE(PFNGLMULTITEXCOORD3IVARBPROC, "glMultiTexCoord3ivARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord3svARB(GLenum target, const GLshort *v)
{
    RESOLVE(PFNGLMULTITEXCOORD1SVARBPROC, "glMultiTexCoord1svARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
{
    RESOLVE(PFNGLMULTITEXCOORD4DVARBPROC, "glMultiTexCoord4dvARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
{
    RESOLVE(PFNGLMULTITEXCOORD4FVARBPROC, "glMultiTexCoord4fvARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord4ivARB(GLenum target, const GLint *v)
{
    RESOLVE(PFNGLMULTITEXCOORD4IVARBPROC, "glMultiTexCoord4ivARB");
    proc(target, v);
}
GLAPI void GLAPIENTRY glMultiTexCoord4svARB(GLenum target, const GLshort *v)
{
    RESOLVE(PFNGLMULTITEXCOORD1SVARBPROC, "glMultiTexCoord1svARB");
    proc(target, v);
}
d141 1
d143 1
a143 1
GLAPI void GLAPIENTRY glActiveStencilFaceEXT(GLenum face)
d145 2
a146 2
    RESOLVE(PFNGLACTIVESTENCILFACEEXTPROC, "glActiveStencilFaceEXT");
    proc(face);
a148 127
GLAPI void APIENTRY glPointParameterfARB(GLenum pname, GLfloat param)
{
    RESOLVE(PFNGLPOINTPARAMETERFARBPROC, "glPointParameterfARB");
    proc(pname, param);
}

GLAPI void APIENTRY glPointParameterfvARB(GLenum pname, const GLfloat *params)
{
    RESOLVE(PFNGLPOINTPARAMETERFVARBPROC, "glPointParameterfvARB");
    proc(pname, params);
}


GLAPI void APIENTRY glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
{
    RESOLVE(PFNGLWINDOWPOS3FARBPROC, "glWindowPos3fARB");
    proc(x, y, z);
}

GLAPI void APIENTRY glPointParameteri(GLenum pname, GLint param)
{
    RESOLVE(PFNGLPOINTPARAMETERIPROC, "glPointParameteri");
    proc(pname, param);
}

GLAPI void APIENTRY glPointParameteriv(GLenum pname, const GLint *params)
{
    RESOLVE(PFNGLPOINTPARAMETERIVPROC, "glPointParameteriv");
    proc(pname, params);
}

GLAPI void APIENTRY glPointParameteriNV(GLenum pname, GLint param)
{
    RESOLVE(PFNGLPOINTPARAMETERINVPROC, "glPointParameteriNV");
    proc(pname, param);
}

GLAPI void APIENTRY glPointParameterivNV(GLenum pname, const GLint *params)
{
    RESOLVE(PFNGLPOINTPARAMETERIVNVPROC, "glPointParameterivNV");
    proc(pname, params);
}

GLAPI void APIENTRY glSecondaryColor3bv(const GLbyte *v)
{
    RESOLVE(PFNGLSECONDARYCOLOR3BVPROC, "glSecondaryColor3bv");
    proc(v);
}
GLAPI void APIENTRY glSecondaryColor3dv(const GLdouble *v)
{
    RESOLVE(PFNGLSECONDARYCOLOR3DVPROC, "glSecondaryColor3dv");
    proc(v);
}
GLAPI void APIENTRY glSecondaryColor3fv(const GLfloat *v)
{
    RESOLVE(PFNGLSECONDARYCOLOR3FVPROC, "glSecondaryColor3fv");
    proc(v);
}
GLAPI void APIENTRY glSecondaryColor3iv(const GLint *v)
{
    RESOLVE(PFNGLSECONDARYCOLOR3IVPROC, "glSecondaryColor3iv");
    proc(v);
}
GLAPI void APIENTRY glSecondaryColor3sv(const GLshort *v)
{
    RESOLVE(PFNGLSECONDARYCOLOR3SVPROC, "glSecondaryColor3sv");
    proc(v);
}
GLAPI void APIENTRY glSecondaryColor3ubv(const GLubyte *v)
{
    RESOLVE(PFNGLSECONDARYCOLOR3UBVPROC, "glSecondaryColor3ubv");
    proc(v);
}
GLAPI void APIENTRY glSecondaryColor3uiv(const GLuint *v)
{
    RESOLVE(PFNGLSECONDARYCOLOR3UIVPROC, "glSecondaryColor3uiv");
    proc(v);
}
GLAPI void APIENTRY glSecondaryColor3usv(const GLushort *v)
{
    RESOLVE(PFNGLSECONDARYCOLOR3USVPROC, "glSecondaryColor3usv");
    proc(v);
}
GLAPI void APIENTRY glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RESOLVE(PFNGLSECONDARYCOLORPOINTERPROC, "glSecondaryColorPointer");
    proc(size, type, stride, pointer);
}


GLAPI void APIENTRY glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
    RESOLVE(PFNGLBLENDFUNCSEPARATEPROC, "glBlendFuncSeparate");
    proc(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}
GLAPI void APIENTRY glFogCoordfv(const GLfloat *coord)
{
    RESOLVE(PFNGLFOGCOORDFVPROC, "glFogCoordfv");
    proc(coord);
}
GLAPI void APIENTRY glFogCoorddv(const GLdouble *coord)
{
    RESOLVE(PFNGLFOGCOORDDVPROC, "glFogCoorddv");
    proc(coord);
}
GLAPI void APIENTRY glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RESOLVE(PFNGLFOGCOORDPOINTERPROC, "glFogCoordPointer");
    proc(type, stride, pointer);
}


GLAPI void APIENTRY glSampleCoverageARB(GLclampf value, GLboolean invert)
{
    RESOLVE(PFNGLSAMPLECOVERAGEARBPROC, "glSampleCoverageARB");
    proc(value, invert);
}
GLAPI void APIENTRY glSampleMaskSGIS(GLclampf value, GLboolean invert)
{
    RESOLVE(PFNGLSAMPLEMASKSGISPROC, "glSampleMaskSGIS");
    proc(value, invert);
}
GLAPI void APIENTRY glSamplePatternSGIS(GLenum pattern)
{
    RESOLVE(PFNGLSAMPLEPATTERNSGISPROC, "glSamplePatternSGIS");
    proc(pattern);
}
@

