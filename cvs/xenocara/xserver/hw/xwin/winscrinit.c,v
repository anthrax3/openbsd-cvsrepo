head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.19;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Dakshinamurthy Karra
 *		Suhaib M Siddiqi
 *		Peter Busch
 *		Harold L Hunt II
 *		Kensuke Matsuzaki
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include "winmsg.h"

#ifdef XWIN_MULTIWINDOWEXTWM
static RootlessFrameProcsRec winMWExtWMProcs = {
    winMWExtWMCreateFrame,
    winMWExtWMDestroyFrame,

    winMWExtWMMoveFrame,
    winMWExtWMResizeFrame,
    winMWExtWMRestackFrame,
    winMWExtWMReshapeFrame,
    winMWExtWMUnmapFrame,

    winMWExtWMStartDrawing,
    winMWExtWMStopDrawing,
    winMWExtWMUpdateRegion,
    winMWExtWMDamageRects,
    winMWExtWMRootlessSwitchWindow,
    NULL,                       //winMWExtWMDoReorderWindow,
    NULL,                       //winMWExtWMHideWindow,
    NULL,                       //winMWExtWMUpdateColorMap,

    NULL,                       //winMWExtWMCopyBytes,
    winMWExtWMCopyWindow
};
#endif

/*
 * Prototypes
 */

/*
 * Local functions
 */

static Bool
 winSaveScreen(ScreenPtr pScreen, int on);

/*
 * Determine what type of screen we are initializing
 * and call the appropriate procedure to intiailize
 * that type of screen.
 */

Bool
winScreenInit(ScreenPtr pScreen, int argc, char **argv)
{
    winScreenInfoPtr pScreenInfo = &g_ScreenInfo[pScreen->myNum];
    winPrivScreenPtr pScreenPriv;
    HDC hdc;
    DWORD dwInitialBPP;

#if CYGDEBUG || YES
    winDebug("winScreenInit - dwWidth: %u dwHeight: %u\n",
             (unsigned int)pScreenInfo->dwWidth, (unsigned int)pScreenInfo->dwHeight);
#endif

    /* Allocate privates for this screen */
    if (!winAllocatePrivates(pScreen)) {
        ErrorF("winScreenInit - Couldn't allocate screen privates\n");
        return FALSE;
    }

    /* Get a pointer to the privates structure that was allocated */
    pScreenPriv = winGetScreenPriv(pScreen);

    /* Save a pointer to this screen in the screen info structure */
    pScreenInfo->pScreen = pScreen;

    /* Save a pointer to the screen info in the screen privates structure */
    /* This allows us to get back to the screen info from a screen pointer */
    pScreenPriv->pScreenInfo = pScreenInfo;

    /*
     * Determine which engine to use.
     *
     * NOTE: This is done once per screen because each screen possibly has
     * a preferred engine specified on the command line.
     */
    if (!winSetEngine(pScreen)) {
        ErrorF("winScreenInit - winSetEngine () failed\n");
        return FALSE;
    }

    /* Horribly misnamed function: Allow engine to adjust BPP for screen */
    dwInitialBPP = pScreenInfo->dwBPP;

    if (!(*pScreenPriv->pwinAdjustVideoMode) (pScreen)) {
        ErrorF("winScreenInit - winAdjustVideoMode () failed\n");
        return FALSE;
    }

    if (dwInitialBPP == WIN_DEFAULT_BPP) {
        /* No -depth parameter was passed, let the user know the depth being used */
        ErrorF
            ("winScreenInit - Using Windows display depth of %d bits per pixel\n",
             (int) pScreenInfo->dwBPP);
    }
    else if (dwInitialBPP != pScreenInfo->dwBPP) {
        /* Warn user if engine forced a depth different to -depth parameter */
        ErrorF
            ("winScreenInit - Command line depth of %d bpp overidden by engine, using %d bpp\n",
             (int) dwInitialBPP, (int) pScreenInfo->dwBPP);
    }
    else {
        ErrorF("winScreenInit - Using command line depth of %d bpp\n",
               (int) pScreenInfo->dwBPP);
    }

    /* Check for supported display depth */
    if (!(WIN_SUPPORTED_BPPS & (1 << (pScreenInfo->dwBPP - 1)))) {
        ErrorF("winScreenInit - Unsupported display depth: %d\n"
               "Change your Windows display depth to 15, 16, 24, or 32 bits "
               "per pixel.\n", (int) pScreenInfo->dwBPP);
        ErrorF("winScreenInit - Supported depths: %08x\n", WIN_SUPPORTED_BPPS);
#if WIN_CHECK_DEPTH
        return FALSE;
#endif
    }

    /*
     * Check that all monitors have the same display depth if we are using
     * multiple monitors
     */
    if (pScreenInfo->fMultipleMonitors
        && !GetSystemMetrics(SM_SAMEDISPLAYFORMAT)) {
        ErrorF("winScreenInit - Monitors do not all have same pixel format / "
               "display depth.\n");
        if (pScreenInfo->dwEngine == WIN_SERVER_SHADOW_GDI) {
            ErrorF
                ("winScreenInit - Performance may suffer off primary display.\n");
        }
        else {
            ErrorF("winScreenInit - Using primary display only.\n");
            pScreenInfo->fMultipleMonitors = FALSE;
        }
    }

    /* Create display window */
    if (!(*pScreenPriv->pwinCreateBoundingWindow) (pScreen)) {
        ErrorF("winScreenInit - pwinCreateBoundingWindow () " "failed\n");
        return FALSE;
    }

    /* Get a device context */
    hdc = GetDC(pScreenPriv->hwndScreen);

    /* Are we using multiple monitors? */
    if (pScreenInfo->fMultipleMonitors) {
        /*
         * In this case, some of the defaults set in
         * winInitializeScreenDefaults() are not correct ...
         */
        if (!pScreenInfo->fUserGaveHeightAndWidth) {
            pScreenInfo->dwWidth = GetSystemMetrics(SM_CXVIRTUALSCREEN);
            pScreenInfo->dwHeight = GetSystemMetrics(SM_CYVIRTUALSCREEN);
        }
    }

    /* Release the device context */
    ReleaseDC(pScreenPriv->hwndScreen, hdc);

    /* Clear the visuals list */
    miClearVisualTypes();

    /* Call the engine dependent screen initialization procedure */
    if (!((*pScreenPriv->pwinFinishScreenInit) (pScreen->myNum, pScreen, argc, argv))) {
        ErrorF("winScreenInit - winFinishScreenInit () failed\n");

        /* call the engine dependent screen close procedure to clean up from a failure */
        pScreenPriv->pwinCloseScreen(pScreen);

        return FALSE;
    }

    if (!g_fSoftwareCursor)
        winInitCursor(pScreen);
    else
        winErrorFVerb(2, "winScreenInit - Using software cursor\n");

    if (!noPanoramiXExtension) {
        /*
           Note the screen origin in a normalized coordinate space where (0,0) is at the top left
           of the native virtual desktop area
         */
        pScreen->x =
            pScreenInfo->dwInitialX - GetSystemMetrics(SM_XVIRTUALSCREEN);
        pScreen->y =
            pScreenInfo->dwInitialY - GetSystemMetrics(SM_YVIRTUALSCREEN);

        ErrorF("Screen %d added at virtual desktop coordinate (%d,%d).\n",
               pScreen->myNum, pScreen->x, pScreen->y);
    }

#if CYGDEBUG || YES
    winDebug("winScreenInit - returning\n");
#endif

    return TRUE;
}

static Bool
winCreateScreenResources(ScreenPtr pScreen)
{
    winScreenPriv(pScreen);
    Bool result;

    result = pScreenPriv->pwinCreateScreenResources(pScreen);

    /* Now the screen bitmap has been wrapped in a pixmap,
       add that to the Shadow framebuffer */
    if (!shadowAdd(pScreen, pScreen->devPrivate,
                   pScreenPriv->pwinShadowUpdate, NULL, 0, 0)) {
        ErrorF("winCreateScreenResources - shadowAdd () failed\n");
        return FALSE;
    }

    return result;
}

/* See Porting Layer Definition - p. 20 */
Bool
winFinishScreenInitFB(int i, ScreenPtr pScreen, int argc, char **argv)
{
    winScreenPriv(pScreen);
    winScreenInfo *pScreenInfo = pScreenPriv->pScreenInfo;
    VisualPtr pVisual = NULL;

#if defined(XWIN_CLIPBOARD) || defined(XWIN_MULTIWINDOW)
    int iReturn;
#endif

    /* Create framebuffer */
    if (!(*pScreenPriv->pwinInitScreen) (pScreen)) {
        ErrorF("winFinishScreenInitFB - Could not allocate framebuffer\n");
        return FALSE;
    }

    /*
     * Calculate the number of bits that are used to represent color in each pixel,
     * the color depth for the screen
     */
    if (pScreenInfo->dwBPP == 8)
        pScreenInfo->dwDepth = 8;
    else
        pScreenInfo->dwDepth = winCountBits(pScreenPriv->dwRedMask)
            + winCountBits(pScreenPriv->dwGreenMask)
            + winCountBits(pScreenPriv->dwBlueMask);

    winErrorFVerb(2, "winFinishScreenInitFB - Masks: %08x %08x %08x\n",
                  (unsigned int) pScreenPriv->dwRedMask,
                  (unsigned int) pScreenPriv->dwGreenMask,
                  (unsigned int) pScreenPriv->dwBlueMask);

    /* Init visuals */
    if (!(*pScreenPriv->pwinInitVisuals) (pScreen)) {
        ErrorF("winFinishScreenInitFB - winInitVisuals failed\n");
        return FALSE;
    }

    /* Apparently we need this for the render extension */
    miSetPixmapDepths();

    /* Start fb initialization */
    if (!fbSetupScreen(pScreen,
                       pScreenInfo->pfb,
                       pScreenInfo->dwWidth, pScreenInfo->dwHeight,
                       monitorResolution, monitorResolution,
                       pScreenInfo->dwStride, pScreenInfo->dwBPP)) {
        ErrorF("winFinishScreenInitFB - fbSetupScreen failed\n");
        return FALSE;
    }

    /* Override default colormap routines if visual class is dynamic */
    if (pScreenInfo->dwDepth == 8
        && (pScreenInfo->dwEngine == WIN_SERVER_SHADOW_GDI
            || (pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
                && pScreenInfo->fFullScreen))) {
        winSetColormapFunctions(pScreen);

        /*
         * NOTE: Setting whitePixel to 255 causes Magic 7.1 to allocate its
         * own colormap, as it cannot allocate 7 planes in the default
         * colormap.  Setting whitePixel to 1 allows Magic to get 7
         * planes in the default colormap, so it doesn't create its
         * own colormap.  This latter situation is highly desireable,
         * as it keeps the Magic window viewable when switching to
         * other X clients that use the default colormap.
         */
        pScreen->blackPixel = 0;
        pScreen->whitePixel = 1;
    }

    /* Place our save screen function */
    pScreen->SaveScreen = winSaveScreen;

    /* Finish fb initialization */
    if (!fbFinishScreenInit(pScreen,
                            pScreenInfo->pfb,
                            pScreenInfo->dwWidth, pScreenInfo->dwHeight,
                            monitorResolution, monitorResolution,
                            pScreenInfo->dwStride, pScreenInfo->dwBPP)) {
        ErrorF("winFinishScreenInitFB - fbFinishScreenInit failed\n");
        return FALSE;
    }

    /* Save a pointer to the root visual */
    for (pVisual = pScreen->visuals;
         pVisual->vid != pScreen->rootVisual; pVisual++);
    pScreenPriv->pRootVisual = pVisual;

    /*
     * Setup points to the block and wakeup handlers.  Pass a pointer
     * to the current screen as pWakeupdata.
     */
    pScreen->BlockHandler = winBlockHandler;
    pScreen->WakeupHandler = winWakeupHandler;

    /* Render extension initialization, calls miPictureInit */
    if (!fbPictureInit(pScreen, NULL, 0)) {
        ErrorF("winFinishScreenInitFB - fbPictureInit () failed\n");
        return FALSE;
    }

#ifdef RANDR
    /* Initialize resize and rotate support */
    if (!winRandRInit(pScreen)) {
        ErrorF("winFinishScreenInitFB - winRandRInit () failed\n");
        return FALSE;
    }
#endif

    /* Setup the cursor routines */
#if CYGDEBUG
    winDebug("winFinishScreenInitFB - Calling miDCInitialize ()\n");
#endif
    miDCInitialize(pScreen, &g_winPointerCursorFuncs);

    /* KDrive does winCreateDefColormap right after miDCInitialize */
    /* Create a default colormap */
#if CYGDEBUG
    winDebug("winFinishScreenInitFB - Calling winCreateDefColormap ()\n");
#endif
    if (!winCreateDefColormap(pScreen)) {
        ErrorF("winFinishScreenInitFB - Could not create colormap\n");
        return FALSE;
    }

    /* Initialize the shadow framebuffer layer */
    if ((pScreenInfo->dwEngine == WIN_SERVER_SHADOW_GDI
         || pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL)
#ifdef XWIN_MULTIWINDOWEXTWM
        && !pScreenInfo->fMWExtWM
#endif
        ) {
#if CYGDEBUG
        winDebug("winFinishScreenInitFB - Calling shadowSetup ()\n");
#endif
        if (!shadowSetup(pScreen)) {
            ErrorF("winFinishScreenInitFB - shadowSetup () failed\n");
            return FALSE;
        }

        /* Wrap CreateScreenResources so we can add the screen pixmap
           to the Shadow framebuffer after it's been created */
        pScreenPriv->pwinCreateScreenResources = pScreen->CreateScreenResources;
        pScreen->CreateScreenResources = winCreateScreenResources;
    }

#ifdef XWIN_MULTIWINDOWEXTWM
    /* Handle multi-window external window manager mode */
    if (pScreenInfo->fMWExtWM) {
        winDebug("winScreenInit - MultiWindowExtWM - Calling RootlessInit\n");

        RootlessInit(pScreen, &winMWExtWMProcs);

        winDebug("winScreenInit - MultiWindowExtWM - RootlessInit returned\n");

        rootless_CopyBytes_threshold = 0;
        /* FIXME: How many? Profiling needed? */
        rootless_CopyWindow_threshold = 1;

        winWindowsWMExtensionInit();
    }
#endif

    /* Handle rootless mode */
    if (pScreenInfo->fRootless) {
        /* Define the WRAP macro temporarily for local use */
#define WRAP(a) \
    if (pScreen->a) { \
        pScreenPriv->a = pScreen->a; \
    } else { \
        winDebug("winScreenInit - null screen fn " #a "\n"); \
        pScreenPriv->a = NULL; \
    }

        /* Save a pointer to each lower-level window procedure */
        WRAP(CreateWindow);
        WRAP(DestroyWindow);
        WRAP(RealizeWindow);
        WRAP(UnrealizeWindow);
        WRAP(PositionWindow);
        WRAP(ChangeWindowAttributes);
        WRAP(SetShape);

        /* Assign rootless window procedures to be top level procedures */
        pScreen->CreateWindow = winCreateWindowRootless;
        pScreen->DestroyWindow = winDestroyWindowRootless;
        pScreen->PositionWindow = winPositionWindowRootless;
        /*pScreen->ChangeWindowAttributes = winChangeWindowAttributesRootless; */
        pScreen->RealizeWindow = winMapWindowRootless;
        pScreen->UnrealizeWindow = winUnmapWindowRootless;
        pScreen->SetShape = winSetShapeRootless;

        /* Undefine the WRAP macro, as it is not needed elsewhere */
#undef WRAP
    }

#ifdef XWIN_MULTIWINDOW
    /* Handle multi window mode */
    else if (pScreenInfo->fMultiWindow) {
        /* Define the WRAP macro temporarily for local use */
#define WRAP(a) \
    if (pScreen->a) { \
        pScreenPriv->a = pScreen->a; \
    } else { \
        winDebug("null screen fn " #a "\n"); \
        pScreenPriv->a = NULL; \
    }

        /* Save a pointer to each lower-level window procedure */
        WRAP(CreateWindow);
        WRAP(DestroyWindow);
        WRAP(RealizeWindow);
        WRAP(UnrealizeWindow);
        WRAP(PositionWindow);
        WRAP(ChangeWindowAttributes);
        WRAP(ReparentWindow);
        WRAP(RestackWindow);
        WRAP(ResizeWindow);
        WRAP(MoveWindow);
        WRAP(CopyWindow);
        WRAP(SetShape);

        /* Assign multi-window window procedures to be top level procedures */
        pScreen->CreateWindow = winCreateWindowMultiWindow;
        pScreen->DestroyWindow = winDestroyWindowMultiWindow;
        pScreen->PositionWindow = winPositionWindowMultiWindow;
        /*pScreen->ChangeWindowAttributes = winChangeWindowAttributesMultiWindow; */
        pScreen->RealizeWindow = winMapWindowMultiWindow;
        pScreen->UnrealizeWindow = winUnmapWindowMultiWindow;
        pScreen->ReparentWindow = winReparentWindowMultiWindow;
        pScreen->RestackWindow = winRestackWindowMultiWindow;
        pScreen->ResizeWindow = winResizeWindowMultiWindow;
        pScreen->MoveWindow = winMoveWindowMultiWindow;
        pScreen->CopyWindow = winCopyWindowMultiWindow;
        pScreen->SetShape = winSetShapeMultiWindow;

        /* Undefine the WRAP macro, as it is not needed elsewhere */
#undef WRAP
    }
#endif

    /* Wrap either fb's or shadow's CloseScreen with our CloseScreen */
    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = pScreenPriv->pwinCloseScreen;

#if defined(XWIN_CLIPBOARD) || defined(XWIN_MULTIWINDOW)
    /* Create a mutex for modules in separate threads to wait for */
    iReturn = pthread_mutex_init(&pScreenPriv->pmServerStarted, NULL);
    if (iReturn != 0) {
        ErrorF("winFinishScreenInitFB - pthread_mutex_init () failed: %d\n",
               iReturn);
        return FALSE;
    }

    /* Own the mutex for modules in separate threads */
    iReturn = pthread_mutex_lock(&pScreenPriv->pmServerStarted);
    if (iReturn != 0) {
        ErrorF("winFinishScreenInitFB - pthread_mutex_lock () failed: %d\n",
               iReturn);
        return FALSE;
    }

    /* Set the ServerStarted flag to false */
    pScreenPriv->fServerStarted = FALSE;
#endif

#ifdef XWIN_MULTIWINDOWEXTWM
    pScreenPriv->fRestacking = FALSE;
#endif

#if defined(XWIN_MULTIWINDOW) || defined(XWIN_MULTIWINDOWEXTWM)
    if (FALSE
#ifdef XWIN_MULTIWINDOW
        || pScreenInfo->fMultiWindow
#endif
#ifdef XWIN_MULTIWINDOWEXTWM
        || pScreenInfo->fInternalWM
#endif
        ) {
#if CYGDEBUG || YES
        winDebug("winFinishScreenInitFB - Calling winInitWM.\n");
#endif

        /* Initialize multi window mode */
        if (!winInitWM(&pScreenPriv->pWMInfo,
                       &pScreenPriv->ptWMProc,
                       &pScreenPriv->ptXMsgProc,
                       &pScreenPriv->pmServerStarted,
                       pScreenInfo->dwScreen, (HWND) &pScreenPriv->hwndScreen,
#ifdef XWIN_MULTIWINDOWEXTWM
                       pScreenInfo->fInternalWM ||
#endif
                       FALSE)) {
            ErrorF("winFinishScreenInitFB - winInitWM () failed.\n");
            return FALSE;
        }
    }
#endif

    /* Tell the server that we are enabled */
    pScreenPriv->fEnabled = TRUE;

    /* Tell the server that we have a valid depth */
    pScreenPriv->fBadDepth = FALSE;

#if CYGDEBUG || YES
    winDebug("winFinishScreenInitFB - returning\n");
#endif

    return TRUE;
}

/* See Porting Layer Definition - p. 33 */
static Bool
winSaveScreen(ScreenPtr pScreen, int on)
{
    return TRUE;
}
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d92 2
a93 2
    winDebug("winScreenInit - dwWidth: %ld dwHeight: %ld\n",
             pScreenInfo->dwWidth, pScreenInfo->dwHeight);
d219 9
a227 6
    /*
       Note the screen origin in a normalized coordinate space where (0,0) is at the top left
       of the native virtual desktop area
     */
    pScreen->x = pScreenInfo->dwInitialX - GetSystemMetrics(SM_XVIRTUALSCREEN);
    pScreen->y = pScreenInfo->dwInitialY - GetSystemMetrics(SM_YVIRTUALSCREEN);
d229 3
a231 2
    ErrorF("Screen %d added at virtual desktop coordinate (%d,%d).\n",
           pScreen->myNum, pScreen->x, pScreen->y);
a315 2
                && pScreenInfo->fFullScreen)
            || (pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
a388 1
         || pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d188 1
a188 1
        /* 
d348 1
a348 1
    /* 
a571 139

#ifdef XWIN_NATIVEGDI
/* See Porting Layer Definition - p. 20 */

Bool
winFinishScreenInitNativeGDI(int i,
                             ScreenPtr pScreen, int argc, char **argv)
{
    winScreenPriv(pScreen);
    winScreenInfoPtr pScreenInfo = &g_ScreenInfo[i];
    VisualPtr pVisuals = NULL;
    DepthPtr pDepths = NULL;
    VisualID rootVisual = 0;
    int nVisuals = 0, nDepths = 0, nRootDepth = 0;

    /* Ignore user input (mouse, keyboard) */
    pScreenInfo->fIgnoreInput = FALSE;

    /* Get device contexts for the screen and shadow bitmap */
    pScreenPriv->hdcScreen = GetDC(pScreenPriv->hwndScreen);
    if (pScreenPriv->hdcScreen == NULL)
        FatalError("winFinishScreenInitNativeGDI - Couldn't get a DC\n");

    /* Init visuals */
    if (!(*pScreenPriv->pwinInitVisuals) (pScreen)) {
        ErrorF("winFinishScreenInitNativeGDI - pwinInitVisuals failed\n");
        return FALSE;
    }

    /* Initialize the mi visuals */
    if (!miInitVisuals(&pVisuals, &pDepths, &nVisuals, &nDepths, &nRootDepth,
                       &rootVisual,
                       ((unsigned long) 1 << (pScreenInfo->dwDepth - 1)), 8,
                       TrueColor)) {
        ErrorF("winFinishScreenInitNativeGDI - miInitVisuals () failed\n");
        return FALSE;
    }

    /* Initialize the CloseScreen procedure pointer */
    pScreen->CloseScreen = NULL;

    /* Initialize the mi code */
    if (!miScreenInit(pScreen, NULL,    /* No framebuffer */
                      pScreenInfo->dwWidth, pScreenInfo->dwHeight,
                      monitorResolution, monitorResolution,
                      pScreenInfo->dwStride,
                      nRootDepth, nDepths, pDepths, rootVisual,
                      nVisuals, pVisuals)) {
        ErrorF("winFinishScreenInitNativeGDI - miScreenInit failed\n");
        return FALSE;
    }

    pScreen->defColormap = FakeClientID(0);

    /*
     * Register our block and wakeup handlers; these procedures
     * process messages in our Windows message queue; specifically,
     * they process mouse and keyboard input.
     */
    pScreen->BlockHandler = winBlockHandler;
    pScreen->WakeupHandler = winWakeupHandler;

    /* Place our save screen function */
    pScreen->SaveScreen = winSaveScreen;

    /* Pixmaps */
    pScreen->CreatePixmap = winCreatePixmapNativeGDI;
    pScreen->DestroyPixmap = winDestroyPixmapNativeGDI;

    /* Other Screen Routines */
    pScreen->QueryBestSize = winQueryBestSizeNativeGDI;
    pScreen->SaveScreen = winSaveScreen;
    pScreen->GetImage = miGetImage;
    pScreen->GetSpans = winGetSpansNativeGDI;

    /* Window Procedures */
    pScreen->CreateWindow = winCreateWindowNativeGDI;
    pScreen->DestroyWindow = winDestroyWindowNativeGDI;
    pScreen->PositionWindow = winPositionWindowNativeGDI;
    /*pScreen->ChangeWindowAttributes = winChangeWindowAttributesNativeGDI; */
    pScreen->RealizeWindow = winMapWindowNativeGDI;
    pScreen->UnrealizeWindow = winUnmapWindowNativeGDI;

    /* Paint window */
    pScreen->CopyWindow = winCopyWindowNativeGDI;

    /* Fonts */
    pScreen->RealizeFont = winRealizeFontNativeGDI;
    pScreen->UnrealizeFont = winUnrealizeFontNativeGDI;

    /* GC */
    pScreen->CreateGC = winCreateGCNativeGDI;

    /* Colormap Routines */
    pScreen->CreateColormap = miInitializeColormap;
    pScreen->DestroyColormap =
        (DestroyColormapProcPtr) (void (*)(void)) NoopDDA;
    pScreen->InstallColormap = miInstallColormap;
    pScreen->UninstallColormap = miUninstallColormap;
    pScreen->ListInstalledColormaps = miListInstalledColormaps;
    pScreen->StoreColors = (StoreColorsProcPtr) (void (*)(void)) NoopDDA;
    pScreen->ResolveColor = miResolveColor;

    /* Bitmap */
    pScreen->BitmapToRegion = winPixmapToRegionNativeGDI;

    ErrorF("winFinishScreenInitNativeGDI - calling miDCInitialize\n");

    /* Set the default white and black pixel positions */
    pScreen->whitePixel = pScreen->blackPixel = (Pixel) 0;

    /* Initialize the cursor */
    if (!miDCInitialize(pScreen, &g_winPointerCursorFuncs)) {
        ErrorF("winFinishScreenInitNativeGDI - miDCInitialize failed\n");
        return FALSE;
    }

    /* Create a default colormap */
    if (!miCreateDefColormap(pScreen)) {
        ErrorF("winFinishScreenInitNativeGDI - miCreateDefColormap () "
               "failed\n");
        return FALSE;
    }

    ErrorF("winFinishScreenInitNativeGDI - miCreateDefColormap () "
           "returned\n");

    /* mi doesn't use a CloseScreen procedure, so no need to wrap */
    pScreen->CloseScreen = pScreenPriv->pwinCloseScreen;

    /* Tell the server that we are enabled */
    pScreenPriv->fEnabled = TRUE;

    ErrorF("winFinishScreenInitNativeGDI - Successful addition of "
           "screen %p\n", pScreen);

    return TRUE;
}
#endif
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a261 1
    char *pbits = NULL;
a294 3
    /* Setup a local variable to point to the framebuffer */
    pbits = pScreenInfo->pfb;

d706 1
a706 1
           "screen %08x\n", (unsigned int) pScreen);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d84 1
a84 1
winScreenInit(int index, ScreenPtr pScreen, int argc, char **argv)
d86 1
a86 1
    winScreenInfoPtr pScreenInfo = &g_ScreenInfo[index];
d205 1
a205 1
    if (!((*pScreenPriv->pwinFinishScreenInit) (index, pScreen, argc, argv))) {
d209 1
a209 1
        pScreenPriv->pwinCloseScreen(index, pScreen);
d227 1
a227 1
           index, pScreen->x, pScreen->y);
d257 1
a257 1
winFinishScreenInitFB(int index, ScreenPtr pScreen, int argc, char **argv)
a357 2
    pScreen->blockData = pScreen;
    pScreen->wakeupData = pScreen;
d435 1
a435 1
        ErrorF("null screen fn " #a "\n"); \
d469 1
a469 1
        ErrorF("null screen fn " #a "\n"); \
d553 1
a553 1
                       pScreenInfo->dwScreen, (HWND) & pScreenPriv->hwndScreen,
d581 1
a581 1
winFinishScreenInitNativeGDI(int index,
d585 1
a585 1
    winScreenInfoPtr pScreenInfo = &g_ScreenInfo[index];
a636 2
    pScreen->blockData = pScreen;
    pScreen->wakeupData = pScreen;
@


1.6
log
@Update to xserver 1.11.2
@
text
@a40 1

d42 18
a59 19
static RootlessFrameProcsRec
winMWExtWMProcs = {	
  winMWExtWMCreateFrame,
  winMWExtWMDestroyFrame,
  
  winMWExtWMMoveFrame,
  winMWExtWMResizeFrame,
  winMWExtWMRestackFrame,
  winMWExtWMReshapeFrame,
  winMWExtWMUnmapFrame,
  
  winMWExtWMStartDrawing,
  winMWExtWMStopDrawing,
  winMWExtWMUpdateRegion,
  winMWExtWMDamageRects,
  winMWExtWMRootlessSwitchWindow,
  NULL,//winMWExtWMDoReorderWindow,
  NULL,//winMWExtWMHideWindow,
  NULL,//winMWExtWMUpdateColorMap,
d61 2
a62 2
  NULL,//winMWExtWMCopyBytes,
  winMWExtWMCopyWindow
d75 1
a75 2
winSaveScreen (ScreenPtr pScreen, int on);

d84 1
a84 3
winScreenInit (int index,
	       ScreenPtr pScreen,
	       int argc, char **argv)
d86 4
a89 4
  winScreenInfoPtr      pScreenInfo = &g_ScreenInfo[index];
  winPrivScreenPtr	pScreenPriv;
  HDC			hdc;
  DWORD dwInitialBPP;
d92 2
a93 2
  winDebug ("winScreenInit - dwWidth: %ld dwHeight: %ld\n",
	  pScreenInfo->dwWidth, pScreenInfo->dwHeight);
d96 58
a153 62
  /* Allocate privates for this screen */
  if (!winAllocatePrivates (pScreen))
    {
      ErrorF ("winScreenInit - Couldn't allocate screen privates\n");
      return FALSE;
    }

  /* Get a pointer to the privates structure that was allocated */
  pScreenPriv = winGetScreenPriv (pScreen);

  /* Save a pointer to this screen in the screen info structure */
  pScreenInfo->pScreen = pScreen;

  /* Save a pointer to the screen info in the screen privates structure */
  /* This allows us to get back to the screen info from a screen pointer */
  pScreenPriv->pScreenInfo = pScreenInfo;

  /*
   * Determine which engine to use.
   *
   * NOTE: This is done once per screen because each screen possibly has
   * a preferred engine specified on the command line.
   */
  if (!winSetEngine (pScreen))
    {
      ErrorF ("winScreenInit - winSetEngine () failed\n");
      return FALSE;
    }

  /* Horribly misnamed function: Allow engine to adjust BPP for screen */
  dwInitialBPP = pScreenInfo->dwBPP;

  if (!(*pScreenPriv->pwinAdjustVideoMode) (pScreen))
    {
      ErrorF ("winScreenInit - winAdjustVideoMode () failed\n");
      return FALSE;
    }

  if (dwInitialBPP == WIN_DEFAULT_BPP)
    {
      /* No -depth parameter was passed, let the user know the depth being used */
      ErrorF ("winScreenInit - Using Windows display depth of %d bits per pixel\n", (int) pScreenInfo->dwBPP);
    }
  else if (dwInitialBPP != pScreenInfo->dwBPP)
    {
      /* Warn user if engine forced a depth different to -depth parameter */
      ErrorF ("winScreenInit - Command line depth of %d bpp overidden by engine, using %d bpp\n", (int) dwInitialBPP, (int) pScreenInfo->dwBPP);
    }
  else
    {
      ErrorF ("winScreenInit - Using command line depth of %d bpp\n", (int) pScreenInfo->dwBPP);
    }

  /* Check for supported display depth */
  if (!(WIN_SUPPORTED_BPPS & (1 << (pScreenInfo->dwBPP - 1))))
    {
      ErrorF ("winScreenInit - Unsupported display depth: %d\n" \
	      "Change your Windows display depth to 15, 16, 24, or 32 bits "
	      "per pixel.\n",
	      (int) pScreenInfo->dwBPP);
      ErrorF ("winScreenInit - Supported depths: %08x\n",
	      WIN_SUPPORTED_BPPS);
d155 1
a155 1
      return FALSE;
d159 15
a173 12
  /*
   * Check that all monitors have the same display depth if we are using
   * multiple monitors
   */
  if (pScreenInfo->fMultipleMonitors
      && !GetSystemMetrics (SM_SAMEDISPLAYFORMAT))
    {
      ErrorF ("winScreenInit - Monitors do not all have same pixel format / "
	      "display depth.\n");
      if (pScreenInfo->dwEngine == WIN_SERVER_SHADOW_GDI)
        {
          ErrorF ("winScreenInit - Performance may suffer off primary display.\n");
d175 20
a194 4
      else
        {
          ErrorF ("winScreenInit - Using primary display only.\n");
          pScreenInfo->fMultipleMonitors = FALSE;
d198 2
a199 53
  /* Create display window */
  if (!(*pScreenPriv->pwinCreateBoundingWindow) (pScreen))
    {
      ErrorF ("winScreenInit - pwinCreateBoundingWindow () "
	      "failed\n");
      return FALSE;
    }

  /* Get a device context */
  hdc = GetDC (pScreenPriv->hwndScreen);

  /* Are we using multiple monitors? */
  if (pScreenInfo->fMultipleMonitors)
    {
      /* 
       * In this case, some of the defaults set in
       * winInitializeScreenDefaults() are not correct ...
       */
      if (!pScreenInfo->fUserGaveHeightAndWidth)
	{
	  pScreenInfo->dwWidth = GetSystemMetrics (SM_CXVIRTUALSCREEN);
	  pScreenInfo->dwHeight = GetSystemMetrics (SM_CYVIRTUALSCREEN);
	}
    }

  /* Release the device context */
  ReleaseDC (pScreenPriv->hwndScreen, hdc);
    
  /* Clear the visuals list */
  miClearVisualTypes ();

  /* Call the engine dependent screen initialization procedure */
  if (!((*pScreenPriv->pwinFinishScreenInit) (index, pScreen, argc, argv)))
    {
      ErrorF ("winScreenInit - winFinishScreenInit () failed\n");

      /* call the engine dependent screen close procedure to clean up from a failure */
      pScreenPriv->pwinCloseScreen(index, pScreen);

      return FALSE;
    }

  if (!g_fSoftwareCursor)
    winInitCursor(pScreen);
  else
    winErrorFVerb(2, "winScreenInit - Using software cursor\n");  

  /*
     Note the screen origin in a normalized coordinate space where (0,0) is at the top left
     of the native virtual desktop area
  */
  pScreen->x = pScreenInfo->dwInitialX - GetSystemMetrics(SM_XVIRTUALSCREEN);
  pScreen->y = pScreenInfo->dwInitialY - GetSystemMetrics(SM_YVIRTUALSCREEN);
d201 27
a227 2
  ErrorF("Screen %d added at virtual desktop coordinate (%d,%d).\n",
         index, pScreen->x, pScreen->y);
d230 1
a230 1
  winDebug ("winScreenInit - returning\n");
d233 1
a233 1
  return TRUE;
d239 2
a240 2
  winScreenPriv(pScreen);
  Bool result;
d242 1
a242 1
  result = pScreenPriv->pwinCreateScreenResources(pScreen);
d244 6
a249 7
  /* Now the screen bitmap has been wrapped in a pixmap,
     add that to the Shadow framebuffer */
  if (!shadowAdd(pScreen, pScreen->devPrivate,
		 pScreenPriv->pwinShadowUpdate, NULL, 0, 0))
    {
      ErrorF ("winCreateScreenResources - shadowAdd () failed\n");
      return FALSE;
d252 1
a252 1
  return result;
d257 1
a257 3
winFinishScreenInitFB (int index,
		       ScreenPtr pScreen,
		       int argc, char **argv)
d259 5
a263 4
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  VisualPtr		pVisual = NULL;
  char			*pbits = NULL;
d265 1
a265 1
  int			iReturn;
d268 97
a364 106
  /* Create framebuffer */
  if (!(*pScreenPriv->pwinInitScreen) (pScreen))
    {
      ErrorF ("winFinishScreenInitFB - Could not allocate framebuffer\n");
      return FALSE;
    }

  /*
   * Calculate the number of bits that are used to represent color in each pixel,
   * the color depth for the screen
   */
  if (pScreenInfo->dwBPP == 8)
    pScreenInfo->dwDepth = 8;
  else
    pScreenInfo->dwDepth = winCountBits (pScreenPriv->dwRedMask)
      + winCountBits (pScreenPriv->dwGreenMask)
      + winCountBits (pScreenPriv->dwBlueMask);

  winErrorFVerb (2, "winFinishScreenInitFB - Masks: %08x %08x %08x\n",
	  (unsigned int) pScreenPriv->dwRedMask,
	  (unsigned int) pScreenPriv->dwGreenMask,
	  (unsigned int) pScreenPriv->dwBlueMask);

  /* Init visuals */
  if (!(*pScreenPriv->pwinInitVisuals) (pScreen))
    {
      ErrorF ("winFinishScreenInitFB - winInitVisuals failed\n");
      return FALSE;
    }

  /* Setup a local variable to point to the framebuffer */
  pbits = pScreenInfo->pfb;
  
  /* Apparently we need this for the render extension */
  miSetPixmapDepths ();

  /* Start fb initialization */
  if (!fbSetupScreen (pScreen,
		      pScreenInfo->pfb,
		      pScreenInfo->dwWidth, pScreenInfo->dwHeight,
		      monitorResolution, monitorResolution,
		      pScreenInfo->dwStride,
		      pScreenInfo->dwBPP))
    {
      ErrorF ("winFinishScreenInitFB - fbSetupScreen failed\n");
      return FALSE;
    }

  /* Override default colormap routines if visual class is dynamic */
  if (pScreenInfo->dwDepth == 8
      && (pScreenInfo->dwEngine == WIN_SERVER_SHADOW_GDI
	  || (pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
	      && pScreenInfo->fFullScreen)
	  || (pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
	      && pScreenInfo->fFullScreen)))
    {
      winSetColormapFunctions (pScreen);

      /*
       * NOTE: Setting whitePixel to 255 causes Magic 7.1 to allocate its
       * own colormap, as it cannot allocate 7 planes in the default
       * colormap.  Setting whitePixel to 1 allows Magic to get 7
       * planes in the default colormap, so it doesn't create its
       * own colormap.  This latter situation is highly desireable,
       * as it keeps the Magic window viewable when switching to
       * other X clients that use the default colormap.
       */
      pScreen->blackPixel = 0;
      pScreen->whitePixel = 1;
    }

  /* Place our save screen function */
  pScreen->SaveScreen = winSaveScreen;

  /* Finish fb initialization */
  if (!fbFinishScreenInit (pScreen,
			   pScreenInfo->pfb,
			   pScreenInfo->dwWidth, pScreenInfo->dwHeight,
			   monitorResolution, monitorResolution,
			   pScreenInfo->dwStride,
			   pScreenInfo->dwBPP))
    {
      ErrorF ("winFinishScreenInitFB - fbFinishScreenInit failed\n");
      return FALSE;
    }

  /* Save a pointer to the root visual */
  for (pVisual = pScreen->visuals;
       pVisual->vid != pScreen->rootVisual;
       pVisual++);
  pScreenPriv->pRootVisual = pVisual;

  /* 
   * Setup points to the block and wakeup handlers.  Pass a pointer
   * to the current screen as pWakeupdata.
   */
  pScreen->BlockHandler = winBlockHandler;
  pScreen->WakeupHandler = winWakeupHandler;
  pScreen->blockData = pScreen;
  pScreen->wakeupData = pScreen;

  /* Render extension initialization, calls miPictureInit */
  if (!fbPictureInit (pScreen, NULL, 0))
    {
      ErrorF ("winFinishScreenInitFB - fbPictureInit () failed\n");
      return FALSE;
d368 4
a371 5
  /* Initialize resize and rotate support */
  if (!winRandRInit (pScreen))
    {
      ErrorF ("winFinishScreenInitFB - winRandRInit () failed\n");
      return FALSE;
d375 1
a375 1
  /* Setup the cursor routines */
d377 1
a377 1
  winDebug ("winFinishScreenInitFB - Calling miDCInitialize ()\n");
d379 1
a379 1
  miDCInitialize (pScreen, &g_winPointerCursorFuncs);
d381 2
a382 2
  /* KDrive does winCreateDefColormap right after miDCInitialize */
  /* Create a default colormap */
d384 1
a384 1
  winDebug ("winFinishScreenInitFB - Calling winCreateDefColormap ()\n");
d386 3
a388 4
  if (!winCreateDefColormap (pScreen))
    {
      ErrorF ("winFinishScreenInitFB - Could not create colormap\n");
      return FALSE;
d391 4
a394 4
  /* Initialize the shadow framebuffer layer */
  if ((pScreenInfo->dwEngine == WIN_SERVER_SHADOW_GDI
       || pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
       || pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL)
d396 1
a396 1
      && !pScreenInfo->fMWExtWM
d398 1
a398 2
      )
    {
d400 1
a400 1
      winDebug ("winFinishScreenInitFB - Calling shadowSetup ()\n");
d402 9
a410 10
      if (!shadowSetup(pScreen))
	{
	  ErrorF ("winFinishScreenInitFB - shadowSetup () failed\n");
	  return FALSE;
	}

      /* Wrap CreateScreenResources so we can add the screen pixmap
         to the Shadow framebuffer after it's been created */
      pScreenPriv->pwinCreateScreenResources = pScreen->CreateScreenResources;
      pScreen->CreateScreenResources = winCreateScreenResources;
d414 13
a426 14
  /* Handle multi-window external window manager mode */
  if (pScreenInfo->fMWExtWM)
    {
      winDebug ("winScreenInit - MultiWindowExtWM - Calling RootlessInit\n");
      
      RootlessInit(pScreen, &winMWExtWMProcs);
      
      winDebug ("winScreenInit - MultiWindowExtWM - RootlessInit returned\n");
      
      rootless_CopyBytes_threshold = 0;
      /* FIXME: How many? Profiling needed? */
      rootless_CopyWindow_threshold = 1;

      winWindowsWMExtensionInit ();
d430 3
a432 4
  /* Handle rootless mode */
  if (pScreenInfo->fRootless)
    {
      /* Define the WRAP macro temporarily for local use */
d441 17
a457 17
      /* Save a pointer to each lower-level window procedure */
      WRAP(CreateWindow);
      WRAP(DestroyWindow);
      WRAP(RealizeWindow);
      WRAP(UnrealizeWindow);
      WRAP(PositionWindow);
      WRAP(ChangeWindowAttributes);
      WRAP(SetShape);

      /* Assign rootless window procedures to be top level procedures */
      pScreen->CreateWindow = winCreateWindowRootless;
      pScreen->DestroyWindow = winDestroyWindowRootless;
      pScreen->PositionWindow = winPositionWindowRootless;
      /*pScreen->ChangeWindowAttributes = winChangeWindowAttributesRootless;*/
      pScreen->RealizeWindow = winMapWindowRootless;
      pScreen->UnrealizeWindow = winUnmapWindowRootless;
      pScreen->SetShape = winSetShapeRootless;
d459 1
a459 1
      /* Undefine the WRAP macro, as it is not needed elsewhere */
a462 1

d464 3
a466 4
  /* Handle multi window mode */
  else if (pScreenInfo->fMultiWindow)
    {
      /* Define the WRAP macro temporarily for local use */
d475 27
a501 27
      /* Save a pointer to each lower-level window procedure */
      WRAP(CreateWindow);
      WRAP(DestroyWindow);
      WRAP(RealizeWindow);
      WRAP(UnrealizeWindow);
      WRAP(PositionWindow);
      WRAP(ChangeWindowAttributes);
      WRAP(ReparentWindow);
      WRAP(RestackWindow);
      WRAP(ResizeWindow);
      WRAP(MoveWindow);
      WRAP(CopyWindow);
      WRAP(SetShape);

      /* Assign multi-window window procedures to be top level procedures */
      pScreen->CreateWindow = winCreateWindowMultiWindow;
      pScreen->DestroyWindow = winDestroyWindowMultiWindow;
      pScreen->PositionWindow = winPositionWindowMultiWindow;
      /*pScreen->ChangeWindowAttributes = winChangeWindowAttributesMultiWindow;*/
      pScreen->RealizeWindow = winMapWindowMultiWindow;
      pScreen->UnrealizeWindow = winUnmapWindowMultiWindow;
      pScreen->ReparentWindow = winReparentWindowMultiWindow;
      pScreen->RestackWindow = winRestackWindowMultiWindow;
      pScreen->ResizeWindow = winResizeWindowMultiWindow;
      pScreen->MoveWindow = winMoveWindowMultiWindow;
      pScreen->CopyWindow = winCopyWindowMultiWindow;
      pScreen->SetShape = winSetShapeMultiWindow;
d503 1
a503 1
      /* Undefine the WRAP macro, as it is not needed elsewhere */
d508 3
a510 3
  /* Wrap either fb's or shadow's CloseScreen with our CloseScreen */
  pScreenPriv->CloseScreen = pScreen->CloseScreen;
  pScreen->CloseScreen = pScreenPriv->pwinCloseScreen;
d513 14
a526 16
  /* Create a mutex for modules in separate threads to wait for */
  iReturn = pthread_mutex_init (&pScreenPriv->pmServerStarted, NULL);
  if (iReturn != 0)
    {
      ErrorF ("winFinishScreenInitFB - pthread_mutex_init () failed: %d\n",
	      iReturn);
      return FALSE;
    }

  /* Own the mutex for modules in separate threads */
  iReturn = pthread_mutex_lock (&pScreenPriv->pmServerStarted);
  if (iReturn != 0)
    {
      ErrorF ("winFinishScreenInitFB - pthread_mutex_lock () failed: %d\n",
	      iReturn);
      return FALSE;
d529 2
a530 2
  /* Set the ServerStarted flag to false */
  pScreenPriv->fServerStarted = FALSE;
d534 1
a534 1
  pScreenPriv->fRestacking = FALSE;
d538 1
a538 1
  if (FALSE
d540 1
a540 1
      || pScreenInfo->fMultiWindow
d543 1
a543 1
      || pScreenInfo->fInternalWM
d545 1
a545 2
      )
    { 
d547 1
a547 1
      winDebug ("winFinishScreenInitFB - Calling winInitWM.\n");
d550 6
a555 7
      /* Initialize multi window mode */
      if (!winInitWM (&pScreenPriv->pWMInfo,
		      &pScreenPriv->ptWMProc,
		      &pScreenPriv->ptXMsgProc,
		      &pScreenPriv->pmServerStarted,
		      pScreenInfo->dwScreen,
		      (HWND)&pScreenPriv->hwndScreen,
d557 1
a557 1
		      pScreenInfo->fInternalWM ||
d559 3
a561 4
		      FALSE))
        {
          ErrorF ("winFinishScreenInitFB - winInitWM () failed.\n");
          return FALSE;
d563 1
a563 1
    }      
d566 2
a567 2
  /* Tell the server that we are enabled */
  pScreenPriv->fEnabled = TRUE;
d569 2
a570 2
  /* Tell the server that we have a valid depth */
  pScreenPriv->fBadDepth = FALSE;
d573 1
a573 1
  winDebug ("winFinishScreenInitFB - returning\n");
d576 1
a576 1
  return TRUE;
d583 2
a584 3
winFinishScreenInitNativeGDI (int index,
			      ScreenPtr pScreen,
			      int argc, char **argv)
d586 126
a711 135
  winScreenPriv(pScreen);
  winScreenInfoPtr      pScreenInfo = &g_ScreenInfo[index];
  VisualPtr		pVisuals = NULL;
  DepthPtr		pDepths = NULL;
  VisualID		rootVisual = 0;
  int			nVisuals = 0, nDepths = 0, nRootDepth = 0;

  /* Ignore user input (mouse, keyboard) */
  pScreenInfo->fIgnoreInput = FALSE;

  /* Get device contexts for the screen and shadow bitmap */
  pScreenPriv->hdcScreen = GetDC (pScreenPriv->hwndScreen);
  if (pScreenPriv->hdcScreen == NULL)
    FatalError ("winFinishScreenInitNativeGDI - Couldn't get a DC\n");

  /* Init visuals */
  if (!(*pScreenPriv->pwinInitVisuals) (pScreen))
    {
      ErrorF ("winFinishScreenInitNativeGDI - pwinInitVisuals failed\n");
      return FALSE;
    }

  /* Initialize the mi visuals */
  if (!miInitVisuals (&pVisuals, &pDepths, &nVisuals, &nDepths, &nRootDepth,
		      &rootVisual,
		      ((unsigned long)1 << (pScreenInfo->dwDepth - 1)), 8,
		      TrueColor))
    {
      ErrorF ("winFinishScreenInitNativeGDI - miInitVisuals () failed\n");
      return FALSE;
    }

  /* Initialize the CloseScreen procedure pointer */
  pScreen->CloseScreen = NULL;

  /* Initialize the mi code */
  if (!miScreenInit (pScreen,
		     NULL, /* No framebuffer */
		     pScreenInfo->dwWidth, pScreenInfo->dwHeight,
		     monitorResolution, monitorResolution,
		     pScreenInfo->dwStride,
		     nRootDepth, nDepths, pDepths, rootVisual,
		     nVisuals, pVisuals))
    {
      ErrorF ("winFinishScreenInitNativeGDI - miScreenInit failed\n");
      return FALSE;
    }

  pScreen->defColormap = FakeClientID(0);

  /*
   * Register our block and wakeup handlers; these procedures
   * process messages in our Windows message queue; specifically,
   * they process mouse and keyboard input.
   */
  pScreen->BlockHandler = winBlockHandler;
  pScreen->WakeupHandler = winWakeupHandler;
  pScreen->blockData = pScreen;
  pScreen->wakeupData = pScreen;

  /* Place our save screen function */
  pScreen->SaveScreen = winSaveScreen;

  /* Pixmaps */
  pScreen->CreatePixmap = winCreatePixmapNativeGDI;
  pScreen->DestroyPixmap = winDestroyPixmapNativeGDI;

  /* Other Screen Routines */
  pScreen->QueryBestSize = winQueryBestSizeNativeGDI;
  pScreen->SaveScreen = winSaveScreen;  
  pScreen->GetImage = miGetImage;
  pScreen->GetSpans = winGetSpansNativeGDI;

  /* Window Procedures */
  pScreen->CreateWindow = winCreateWindowNativeGDI;
  pScreen->DestroyWindow = winDestroyWindowNativeGDI;
  pScreen->PositionWindow = winPositionWindowNativeGDI;
  /*pScreen->ChangeWindowAttributes = winChangeWindowAttributesNativeGDI;*/
  pScreen->RealizeWindow = winMapWindowNativeGDI;
  pScreen->UnrealizeWindow = winUnmapWindowNativeGDI;

  /* Paint window */
  pScreen->CopyWindow = winCopyWindowNativeGDI;

  /* Fonts */
  pScreen->RealizeFont = winRealizeFontNativeGDI;
  pScreen->UnrealizeFont = winUnrealizeFontNativeGDI;

  /* GC */
  pScreen->CreateGC = winCreateGCNativeGDI;

  /* Colormap Routines */
  pScreen->CreateColormap = miInitializeColormap;
  pScreen->DestroyColormap = (DestroyColormapProcPtr) (void (*)(void)) NoopDDA;
  pScreen->InstallColormap = miInstallColormap;
  pScreen->UninstallColormap = miUninstallColormap;
  pScreen->ListInstalledColormaps = miListInstalledColormaps;
  pScreen->StoreColors = (StoreColorsProcPtr) (void (*)(void)) NoopDDA;
  pScreen->ResolveColor = miResolveColor;

  /* Bitmap */
  pScreen->BitmapToRegion = winPixmapToRegionNativeGDI;

  ErrorF ("winFinishScreenInitNativeGDI - calling miDCInitialize\n");

  /* Set the default white and black pixel positions */
  pScreen->whitePixel = pScreen->blackPixel = (Pixel) 0;

  /* Initialize the cursor */
  if (!miDCInitialize (pScreen, &g_winPointerCursorFuncs))
    {
      ErrorF ("winFinishScreenInitNativeGDI - miDCInitialize failed\n");
      return FALSE;
    }
  
  /* Create a default colormap */
  if (!miCreateDefColormap (pScreen))
    {
        ErrorF ("winFinishScreenInitNativeGDI - miCreateDefColormap () "
		"failed\n");
	return FALSE;
    }

  ErrorF ("winFinishScreenInitNativeGDI - miCreateDefColormap () "
	  "returned\n");
  
  /* mi doesn't use a CloseScreen procedure, so no need to wrap */
  pScreen->CloseScreen = pScreenPriv->pwinCloseScreen;

  /* Tell the server that we are enabled */
  pScreenPriv->fEnabled = TRUE;

  ErrorF ("winFinishScreenInitNativeGDI - Successful addition of "
	  "screen %08x\n",
	  (unsigned int) pScreen);
d713 4
a716 1
  return TRUE;
a719 1

d722 1
a722 1
winSaveScreen (ScreenPtr pScreen, int on)
d724 1
a724 1
  return TRUE;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a56 1
#ifndef ROOTLESS_TRACK_DAMAGE
a57 1
#endif
a63 2
  NULL,//winMWExtWMFillBytes,
  NULL,//winMWExtWMCompositePixels,
a67 8

/*
 * References to external symbols
 */

extern Bool                     g_fSoftwareCursor;


a71 4
Bool
winRandRInit (ScreenPtr pScreen);


d94 1
d130 3
a132 1
  /* Adjust the video mode for our engine type */
d139 15
d172 1
a172 1
  if (pScreenInfo->fMultipleMonitors 
d176 10
a185 3
	      "display depth.\n"
	      "Using primary display only.\n");
      pScreenInfo->fMultipleMonitors = FALSE;
a198 1
  /* Store the initial height, width, and depth of the display */
a201 3
      pScreenPriv->dwLastWindowsWidth = GetSystemMetrics (SM_CXVIRTUALSCREEN);
      pScreenPriv->dwLastWindowsHeight = GetSystemMetrics (SM_CYVIRTUALSCREEN);

a209 4
	  pScreenInfo->dwWidth_mm = (pScreenInfo->dwWidth /
				     WIN_DEFAULT_DPI) * 25.4;
	  pScreenInfo->dwHeight_mm = (pScreenInfo->dwHeight /
				      WIN_DEFAULT_DPI) * 25.4;
a211 8
  else
    {
      pScreenPriv->dwLastWindowsWidth = GetSystemMetrics (SM_CXSCREEN);
      pScreenPriv->dwLastWindowsHeight = GetSystemMetrics (SM_CYSCREEN);
    }

  /* Save the original bits per pixel */
  pScreenPriv->dwLastWindowsBitsPixel = GetDeviceCaps (hdc, BITSPIXEL);
a217 4
  
  /* Set the padded screen width */
  pScreenInfo->dwPaddedWidth = PixmapBytePad (pScreenInfo->dwWidth,
					      pScreenInfo->dwBPP);
d223 4
d287 1
a287 1
  if (!(*pScreenPriv->pwinAllocateFB) (pScreen))
d294 2
a295 1
   * Grab the number of bits that are used to represent color in each pixel.
d303 1
a303 1
  
a402 7
  /*
   * Backing store support should reduce network traffic and increase
   * performance.
   */
  miInitializeBackingStore (pScreen);

  /* KDrive does miDCInitialize right after miInitializeBackingStore */
a454 2
      rootless_FillBytes_threshold = 0;
      rootless_CompositePixels_threshold = 0;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d199 1
a199 1
       * winInitializeDefaultScreens () are not correct ...
d246 2
a247 2
  dixScreenOrigins[index].x = pScreenInfo->dwInitialX - GetSystemMetrics(SM_XVIRTUALSCREEN);
  dixScreenOrigins[index].y = pScreenInfo->dwInitialY - GetSystemMetrics(SM_YVIRTUALSCREEN);
d250 1
a250 1
         index, dixScreenOrigins[index].x, dixScreenOrigins[index].y);
a392 1
#ifdef RENDER
a398 1
#endif
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a39 1
#include "safeAlpha.h"	
d61 4
a64 2
  NULL,//winWMExtWMDoReorderWindow,
  
d242 10
d259 19
a392 16
#ifdef XWIN_MULTIWINDOWEXTWM
  /*
   * Setup acceleration for multi-window external window manager mode.
   * To be compatible with the Damage extension, this must be done
   * before calling miDCInitialize, which calls DamageSetup.
   */
  if (pScreenInfo->fMWExtWM)
    {
      if (!RootlessAccelInit (pScreen))
        {
          ErrorF ("winFinishScreenInitFB - RootlessAccelInit () failed\n");
          return FALSE;
        }
    }
#endif

d445 1
a445 1
      winDebug ("winFinishScreenInitFB - Calling shadowInit ()\n");
d447 1
a447 3
      if (!shadowInit (pScreen,
		       pScreenPriv->pwinShadowUpdate,
		       NULL))
d449 1
a449 1
	  ErrorF ("winFinishScreenInitFB - shadowInit () failed\n");
d452 5
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a480 1
#ifdef SHAPE
a481 1
#endif
a489 1
#ifdef SHAPE
a490 1
#endif
a521 1
#ifdef SHAPE
a522 1
#endif
a535 1
#ifdef SHAPE
a536 1
#endif
@


1.1
log
@Initial revision
@
text
@a75 3
extern winScreenInfo		g_ScreenInfo[];
extern miPointerScreenFuncRec	g_winPointerCursorFuncs;
extern int			g_iScreenPrivateIndex;
a335 7
  /* Backing store functions */
  /*
   * FIXME: Backing store support still doesn't seem to be working.
   */
  pScreen->BackingStoreFuncs.SaveAreas = fbSaveAreas;
  pScreen->BackingStoreFuncs.RestoreAreas = fbRestoreAreas;

a716 2
  pScreen->PaintWindowBackground = miPaintWindow;
  pScreen->PaintWindowBorder = miPaintWindow;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
