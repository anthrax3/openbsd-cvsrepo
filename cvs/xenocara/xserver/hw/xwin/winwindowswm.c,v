head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.6
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.36;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.03.45;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/* WindowsWM extension is based on AppleWM extension */
/**************************************************************************

Copyright (c) 2002 Apple Computer, Inc. All Rights Reserved.
Copyright (c) 2003 Torrey T. Lyons. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

#include "misc.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "scrnintstr.h"
#include "servermd.h"
#include "swaprep.h"
#define _WINDOWSWM_SERVER_
#include <X11/extensions/windowswmstr.h>
#include "protocol-versions.h"

static int WMErrorBase;
static unsigned char WMReqCode = 0;
static int WMEventBase = 0;

static RESTYPE ClientType, eventResourceType;   /* resource types for event masks */
static XID eventResource;

/* Currently selected events */
static unsigned int eventMask = 0;

static int WMFreeClient(void *data, XID id);
static int WMFreeEvents(void *data, XID id);
static void SNotifyEvent(xWindowsWMNotifyEvent * from,
                         xWindowsWMNotifyEvent * to);

typedef struct _WMEvent *WMEventPtr;
typedef struct _WMEvent {
    WMEventPtr next;
    ClientPtr client;
    XID clientResource;
    unsigned int mask;
} WMEventRec;

static int
ProcWindowsWMQueryVersion(ClientPtr client)
{
    xWindowsWMQueryVersionReply rep;

    REQUEST_SIZE_MATCH(xWindowsWMQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_WINDOWSWM_MAJOR_VERSION;
    rep.minorVersion = SERVER_WINDOWSWM_MINOR_VERSION;
    rep.patchVersion = SERVER_WINDOWSWM_PATCH_VERSION;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
    }
    WriteToClient(client, sizeof(xWindowsWMQueryVersionReply), &rep);
    return Success;
}

/* events */

static inline void
updateEventMask(WMEventPtr * pHead)
{
    WMEventPtr pCur;

    eventMask = 0;
    for (pCur = *pHead; pCur != NULL; pCur = pCur->next)
        eventMask |= pCur->mask;
}

 /*ARGSUSED*/ static int
WMFreeClient(void *data, XID id)
{
    WMEventPtr pEvent;
    WMEventPtr *pHead, pCur, pPrev;

    pEvent = (WMEventPtr) data;
    dixLookupResourceByType((void *) &pHead, eventResource, eventResourceType,
                            NullClient, DixUnknownAccess);
    if (pHead) {
        pPrev = 0;
        for (pCur = *pHead; pCur && pCur != pEvent; pCur = pCur->next)
            pPrev = pCur;
        if (pCur) {
            if (pPrev)
                pPrev->next = pEvent->next;
            else
                *pHead = pEvent->next;
        }
        updateEventMask(pHead);
    }
    free((void *) pEvent);
    return 1;
}

 /*ARGSUSED*/ static int
WMFreeEvents(void *data, XID id)
{
    WMEventPtr *pHead, pCur, pNext;

    pHead = (WMEventPtr *) data;
    for (pCur = *pHead; pCur; pCur = pNext) {
        pNext = pCur->next;
        FreeResource(pCur->clientResource, ClientType);
        free((void *) pCur);
    }
    free((void *) pHead);
    eventMask = 0;
    return 1;
}

static int
ProcWindowsWMSelectInput(ClientPtr client)
{
    REQUEST(xWindowsWMSelectInputReq);
    WMEventPtr pEvent, pNewEvent, *pHead;
    XID clientResource;

    REQUEST_SIZE_MATCH(xWindowsWMSelectInputReq);
    dixLookupResourceByType((void *) &pHead, eventResource, eventResourceType,
                            client, DixWriteAccess);
    if (stuff->mask != 0) {
        if (pHead) {
            /* check for existing entry. */
            for (pEvent = *pHead; pEvent; pEvent = pEvent->next) {
                if (pEvent->client == client) {
                    pEvent->mask = stuff->mask;
                    updateEventMask(pHead);
                    return Success;
                }
            }
        }

        /* build the entry */
        pNewEvent = malloc(sizeof(WMEventRec));
        if (!pNewEvent)
            return BadAlloc;
        pNewEvent->next = 0;
        pNewEvent->client = client;
        pNewEvent->mask = stuff->mask;
        /*
         * add a resource that will be deleted when
         * the client goes away
         */
        clientResource = FakeClientID(client->index);
        pNewEvent->clientResource = clientResource;
        if (!AddResource(clientResource, ClientType, (void *) pNewEvent))
            return BadAlloc;
        /*
         * create a resource to contain a pointer to the list
         * of clients selecting input.  This must be indirect as
         * the list may be arbitrarily rearranged which cannot be
         * done through the resource database.
         */
        if (!pHead) {
            pHead = malloc(sizeof(WMEventPtr));
            if (!pHead ||
                !AddResource(eventResource, eventResourceType, (void *) pHead))
            {
                FreeResource(clientResource, RT_NONE);
                return BadAlloc;
            }
            *pHead = 0;
        }
        pNewEvent->next = *pHead;
        *pHead = pNewEvent;
        updateEventMask(pHead);
    }
    else if (stuff->mask == 0) {
        /* delete the interest */
        if (pHead) {
            pNewEvent = 0;
            for (pEvent = *pHead; pEvent; pEvent = pEvent->next) {
                if (pEvent->client == client)
                    break;
                pNewEvent = pEvent;
            }
            if (pEvent) {
                FreeResource(pEvent->clientResource, ClientType);
                if (pNewEvent)
                    pNewEvent->next = pEvent->next;
                else
                    *pHead = pEvent->next;
                free(pEvent);
                updateEventMask(pHead);
            }
        }
    }
    else {
        client->errorValue = stuff->mask;
        return BadValue;
    }
    return Success;
}

/*
 * deliver the event
 */

void
winWindowsWMSendEvent(int type, unsigned int mask, int which, int arg,
                      Window window, int x, int y, int w, int h)
{
    WMEventPtr *pHead, pEvent;
    ClientPtr client;
    xWindowsWMNotifyEvent se;

#if CYGMULTIWINDOW_DEBUG
    ErrorF("winWindowsWMSendEvent %d %d %d %d,  %d %d - %d %d\n",
           type, mask, which, arg, x, y, w, h);
#endif
    dixLookupResourceByType((void *) &pHead, eventResource, eventResourceType,
                            NullClient, DixUnknownAccess);
    if (!pHead)
        return;
    for (pEvent = *pHead; pEvent; pEvent = pEvent->next) {
        client = pEvent->client;
#if CYGMULTIWINDOW_DEBUG
        ErrorF("winWindowsWMSendEvent - %p\n", client);
#endif
        if ((pEvent->mask & mask) == 0) {
            continue;
        }
#if CYGMULTIWINDOW_DEBUG
        ErrorF("winWindowsWMSendEvent - send\n");
#endif
        se.type = type + WMEventBase;
        se.kind = which;
        se.window = window;
        se.arg = arg;
        se.x = x;
        se.y = y;
        se.w = w;
        se.h = h;
        se.time = currentTime.milliseconds;
        WriteEventsToClient(client, 1, (xEvent *) &se);
    }
}

/* general utility functions */

static int
ProcWindowsWMDisableUpdate(ClientPtr client)
{
    REQUEST_SIZE_MATCH(xWindowsWMDisableUpdateReq);

    //winDisableUpdate();

    return Success;
}

static int
ProcWindowsWMReenableUpdate(ClientPtr client)
{
    REQUEST_SIZE_MATCH(xWindowsWMReenableUpdateReq);

    //winEnableUpdate();

    return Success;
}

/* window functions */

static int
ProcWindowsWMSetFrontProcess(ClientPtr client)
{
    REQUEST_SIZE_MATCH(xWindowsWMSetFrontProcessReq);

    //QuartzMessageMainThread(kWindowsSetFrontProcess, NULL, 0);

    return Success;
}

/* frame functions */

static int
ProcWindowsWMFrameGetRect(ClientPtr client)
{
    xWindowsWMFrameGetRectReply rep;
    RECT rcNew;

    REQUEST(xWindowsWMFrameGetRectReq);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameGetRect %d %d\n",
           (sizeof(xWindowsWMFrameGetRectReq) >> 2), (int) client->req_len);
#endif

    REQUEST_SIZE_MATCH(xWindowsWMFrameGetRectReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

    if (stuff->frame_rect != 0) {
        ErrorF("ProcWindowsWMFrameGetRect - stuff->frame_rect != 0\n");
        return BadValue;
    }

    /* Store the origin, height, and width in a rectangle structure */
    SetRect(&rcNew, stuff->ix, stuff->iy,
            stuff->ix + stuff->iw, stuff->iy + stuff->ih);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameGetRect - %d %d %d %d\n",
           stuff->ix, stuff->iy, stuff->ix + stuff->iw, stuff->iy + stuff->ih);
#endif

    /*
     * Calculate the required size of the Windows window rectangle,
     * given the size of the Windows window client area.
     */
    AdjustWindowRectEx(&rcNew, stuff->frame_style, FALSE,
                       stuff->frame_style_ex);
    rep.x = rcNew.left;
    rep.y = rcNew.top;
    rep.w = rcNew.right - rcNew.left;
    rep.h = rcNew.bottom - rcNew.top;
#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameGetRect - %d %d %d %d\n",
           rep.x, rep.y, rep.w, rep.h);
#endif

    WriteToClient(client, sizeof(xWindowsWMFrameGetRectReply), &rep);
    return Success;
}

static int
ProcWindowsWMFrameDraw(ClientPtr client)
{
    REQUEST(xWindowsWMFrameDrawReq);
    WindowPtr pWin;
    win32RootlessWindowPtr pRLWinPriv;
    RECT rcNew;
    int nCmdShow, rc;
    RegionRec newShape;

    REQUEST_SIZE_MATCH(xWindowsWMFrameDrawReq);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameDraw\n");
#endif
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
    if (rc != Success)
        return rc;
#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameDraw - Window found\n");
#endif

    pRLWinPriv = (win32RootlessWindowPtr) RootlessFrameForWindow(pWin, TRUE);
    if (pRLWinPriv == 0)
        return BadWindow;

#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameDraw - HWND %p 0x%08x 0x%08x\n",
           pRLWinPriv->hWnd, (int) stuff->frame_style,
           (int) stuff->frame_style_ex);
    ErrorF("ProcWindowsWMFrameDraw - %d %d %d %d\n",
           stuff->ix, stuff->iy, stuff->iw, stuff->ih);
#endif

    /* Store the origin, height, and width in a rectangle structure */
    SetRect(&rcNew, stuff->ix, stuff->iy,
            stuff->ix + stuff->iw, stuff->iy + stuff->ih);

    /*
     * Calculate the required size of the Windows window rectangle,
     * given the size of the Windows window client area.
     */
    AdjustWindowRectEx(&rcNew, stuff->frame_style, FALSE,
                       stuff->frame_style_ex);

    /* Set the window extended style flags */
    if (!SetWindowLongPtr(pRLWinPriv->hWnd, GWL_EXSTYLE, stuff->frame_style_ex)) {
        return BadValue;
    }

    /* Set the window standard style flags */
    if (!SetWindowLongPtr(pRLWinPriv->hWnd, GWL_STYLE, stuff->frame_style)) {
        return BadValue;
    }

    /* Flush the window style */
    if (!SetWindowPos(pRLWinPriv->hWnd, NULL,
                      rcNew.left, rcNew.top,
                      rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
                      SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE)) {
        return BadValue;
    }
    if (!IsWindowVisible(pRLWinPriv->hWnd))
        nCmdShow = SW_HIDE;
    else
        nCmdShow = SW_SHOWNA;

    ShowWindow(pRLWinPriv->hWnd, nCmdShow);

    if (wBoundingShape(pWin) != NULL) {
        /* wBoundingShape is relative to *inner* origin of window.
           Translate by borderWidth to get the outside-relative position. */

        RegionNull(&newShape);
        RegionCopy(&newShape, wBoundingShape(pWin));
        RegionTranslate(&newShape, pWin->borderWidth, pWin->borderWidth);
        winMWExtWMReshapeFrame(pRLWinPriv, &newShape);
        RegionUninit(&newShape);
    }
#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameDraw - done\n");
#endif

    return Success;
}

static int
ProcWindowsWMFrameSetTitle(ClientPtr client)
{
    unsigned int title_length, title_max;
    char *title_bytes;

    REQUEST(xWindowsWMFrameSetTitleReq);
    WindowPtr pWin;
    win32RootlessWindowPtr pRLWinPriv;
    int rc;

#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameSetTitle\n");
#endif

    REQUEST_AT_LEAST_SIZE(xWindowsWMFrameSetTitleReq);

    rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
    if (rc != Success)
        return rc;
#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameSetTitle - Window found\n");
#endif

    title_length = stuff->title_length;
    title_max = (stuff->length << 2) - sizeof(xWindowsWMFrameSetTitleReq);

    if (title_max < title_length)
        return BadValue;

#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameSetTitle - length is valid\n");
#endif

    title_bytes = malloc(title_length + 1);
    strncpy(title_bytes, (char *) &stuff[1], title_length);
    title_bytes[title_length] = '\0';

    pRLWinPriv = (win32RootlessWindowPtr) RootlessFrameForWindow(pWin, FALSE);

    if (pRLWinPriv == 0) {
        free(title_bytes);
        return BadWindow;
    }

    /* Flush the window style */
    SetWindowText(pRLWinPriv->hWnd, title_bytes);

    free(title_bytes);

#if CYGMULTIWINDOW_DEBUG
    ErrorF("ProcWindowsWMFrameSetTitle - done\n");
#endif

    return Success;
}

/* dispatch */

static int
ProcWindowsWMDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_WindowsWMQueryVersion:
        return ProcWindowsWMQueryVersion(client);
    }

    if (!client->local)
        return WMErrorBase + WindowsWMClientNotLocal;

    switch (stuff->data) {
    case X_WindowsWMSelectInput:
        return ProcWindowsWMSelectInput(client);
    case X_WindowsWMDisableUpdate:
        return ProcWindowsWMDisableUpdate(client);
    case X_WindowsWMReenableUpdate:
        return ProcWindowsWMReenableUpdate(client);
    case X_WindowsWMSetFrontProcess:
        return ProcWindowsWMSetFrontProcess(client);
    case X_WindowsWMFrameGetRect:
        return ProcWindowsWMFrameGetRect(client);
    case X_WindowsWMFrameDraw:
        return ProcWindowsWMFrameDraw(client);
    case X_WindowsWMFrameSetTitle:
        return ProcWindowsWMFrameSetTitle(client);
    default:
        return BadRequest;
    }
}

static void
SNotifyEvent(xWindowsWMNotifyEvent * from, xWindowsWMNotifyEvent * to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->window, to->window);
    cpswapl(from->time, to->time);
    cpswapl(from->arg, to->arg);
}

static int
SProcWindowsWMQueryVersion(ClientPtr client)
{
    REQUEST(xWindowsWMQueryVersionReq);
    swaps(&stuff->length);
    return ProcWindowsWMQueryVersion(client);
}

static int
SProcWindowsWMDispatch(ClientPtr client)
{
    REQUEST(xReq);

    /* It is bound to be non-local when there is byte swapping */
    if (!client->local)
        return WMErrorBase + WindowsWMClientNotLocal;

    /* only local clients are allowed WM access */
    switch (stuff->data) {
    case X_WindowsWMQueryVersion:
        return SProcWindowsWMQueryVersion(client);
    default:
        return BadRequest;
    }
}

void
winWindowsWMExtensionInit(void)
{
    ExtensionEntry *extEntry;

    ClientType = CreateNewResourceType(WMFreeClient, "WMClient");
    eventResourceType = CreateNewResourceType(WMFreeEvents, "WMEvent");
    eventResource = FakeClientID(0);

    if (ClientType && eventResourceType &&
        (extEntry = AddExtension(WINDOWSWMNAME,
                                 WindowsWMNumberEvents,
                                 WindowsWMNumberErrors,
                                 ProcWindowsWMDispatch,
                                 SProcWindowsWMDispatch,
                                 NULL, StandardMinorOpcode))) {
        size_t i;

        WMReqCode = (unsigned char) extEntry->base;
        WMErrorBase = extEntry->errorBase;
        WMEventBase = extEntry->eventBase;
        for (i = 0; i < WindowsWMNumberEvents; i++)
            EventSwapVector[WMEventBase + i] = (EventSwapPtr) SNotifyEvent;
    }
}
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d287 1
a287 1
    //winEnableUpdate(); 
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d56 2
a57 2
static int WMFreeClient(pointer data, XID id);
static int WMFreeEvents(pointer data, XID id);
d102 1
a102 1
WMFreeClient(pointer data, XID id)
d108 1
a108 1
    dixLookupResourceByType((pointer) &pHead, eventResource, eventResourceType,
d122 1
a122 1
    free((pointer) pEvent);
d127 1
a127 1
WMFreeEvents(pointer data, XID id)
d135 1
a135 1
        free((pointer) pCur);
d137 1
a137 1
    free((pointer) pHead);
d150 1
a150 1
    dixLookupResourceByType((pointer) &pHead, eventResource, eventResourceType,
d165 1
a165 1
        pNewEvent = (WMEventPtr) malloc(sizeof(WMEventRec));
d177 1
a177 1
        if (!AddResource(clientResource, ClientType, (pointer) pNewEvent))
d186 1
a186 1
            pHead = (WMEventPtr *) malloc(sizeof(WMEventPtr));
d188 1
a188 1
                !AddResource(eventResource, eventResourceType, (pointer) pHead))
d242 1
a242 1
    dixLookupResourceByType((pointer) &pHead, eventResource, eventResourceType,
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a68 12
static inline BoxRec
make_box(int x, int y, int w, int h)
{
    BoxRec r;

    r.x1 = x;
    r.y1 = y;
    r.x2 = x + w;
    r.y2 = y + h;
    return r;
}

d249 1
a249 1
        ErrorF("winWindowsWMSendEvent - x%08x\n", (int) client);
a309 1
    BoxRec ir;
a323 2
    ir = make_box(stuff->ix, stuff->iy, stuff->iw, stuff->ih);

d384 2
a385 2
    ErrorF("ProcWindowsWMFrameDraw - HWND 0x%08x 0x%08x 0x%08x\n",
           (int) pRLWinPriv->hWnd, (int) stuff->frame_style,
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a84 1
    int n;
d97 1
a97 1
    WriteToClient(client, sizeof(xWindowsWMQueryVersionReply), (char *) &rep);
d368 1
a368 1
    WriteToClient(client, sizeof(xWindowsWMFrameGetRectReply), (char *) &rep);
a440 2
    winMWExtWMUpdateIcon(pWin->drawable.id);

d493 1
a493 1
    strncpy(title_bytes, (unsigned char *) &stuff[1], title_length);
d527 1
a527 1
    if (!LocalClient(client))
a563 2
    int n;

d575 1
a575 1
    if (!LocalClient(client))
@


1.5
log
@Update to xserver 1.11.2
@
text
@d50 1
a50 1
static RESTYPE ClientType, eventResourceType; /* resource types for event masks */
d56 4
a59 3
static int WMFreeClient (pointer data, XID id);
static int WMFreeEvents (pointer data, XID id);
static void SNotifyEvent(xWindowsWMNotifyEvent *from, xWindowsWMNotifyEvent *to);
d63 4
a66 4
  WMEventPtr      next;
  ClientPtr	    client;
  XID		    clientResource;
  unsigned int    mask;
d70 1
a70 1
make_box (int x, int y, int w, int h)
d72 7
a78 6
  BoxRec r;
  r.x1 = x;
  r.y1 = y;
  r.x2 = x + w;
  r.y2 = y + h;
  return r;
d84 2
a85 2
  xWindowsWMQueryVersionReply rep;
  int n;
d87 10
a96 11
  REQUEST_SIZE_MATCH(xWindowsWMQueryVersionReq);
  rep.type = X_Reply;
  rep.length = 0;
  rep.sequenceNumber = client->sequence;
  rep.majorVersion = SERVER_WINDOWSWM_MAJOR_VERSION;
  rep.minorVersion = SERVER_WINDOWSWM_MINOR_VERSION;
  rep.patchVersion = SERVER_WINDOWSWM_PATCH_VERSION;
  if (client->swapped)
    {
      swaps(&rep.sequenceNumber, n);
      swapl(&rep.length, n);
d98 2
a99 2
  WriteToClient(client, sizeof(xWindowsWMQueryVersionReply), (char *)&rep);
  return Success;
a101 1

d105 1
a105 1
updateEventMask (WMEventPtr *pHead)
d107 1
a107 1
  WMEventPtr pCur;
d109 126
a234 140
  eventMask = 0;
  for (pCur = *pHead; pCur != NULL; pCur = pCur->next)
    eventMask |= pCur->mask;
}

/*ARGSUSED*/
static int
WMFreeClient (pointer data, XID id)
{
  WMEventPtr   pEvent;
  WMEventPtr   *pHead, pCur, pPrev;

  pEvent = (WMEventPtr) data;
  dixLookupResourceByType((pointer) &pHead, eventResource, eventResourceType,
				NullClient, DixUnknownAccess);
  if (pHead)
    {
      pPrev = 0;
      for (pCur = *pHead; pCur && pCur != pEvent; pCur=pCur->next)
	pPrev = pCur;
      if (pCur)
	{
	  if (pPrev)
	    pPrev->next = pEvent->next;
	  else
	    *pHead = pEvent->next;
	}
      updateEventMask (pHead);
    }
  free((pointer) pEvent);
  return 1;
}

/*ARGSUSED*/
static int
WMFreeEvents (pointer data, XID id)
{
  WMEventPtr   *pHead, pCur, pNext;
  
  pHead = (WMEventPtr *) data;
  for (pCur = *pHead; pCur; pCur = pNext)
    {
      pNext = pCur->next;
      FreeResource (pCur->clientResource, ClientType);
      free((pointer) pCur);
    }
  free((pointer) pHead);
  eventMask = 0;
  return 1;
}

static int
ProcWindowsWMSelectInput (ClientPtr client)
{
  REQUEST(xWindowsWMSelectInputReq);
  WMEventPtr		pEvent, pNewEvent, *pHead;
  XID			clientResource;

  REQUEST_SIZE_MATCH (xWindowsWMSelectInputReq);
  dixLookupResourceByType((pointer) &pHead, eventResource, eventResourceType, client, DixWriteAccess);
  if (stuff->mask != 0)
    {
      if (pHead)
	{
	  /* check for existing entry. */
	  for (pEvent = *pHead; pEvent; pEvent = pEvent->next)
	    {
	      if (pEvent->client == client)
		{
		  pEvent->mask = stuff->mask;
		  updateEventMask (pHead);
		  return Success;
		}
	    }
	}
      
      /* build the entry */
      pNewEvent = (WMEventPtr) malloc(sizeof (WMEventRec));
      if (!pNewEvent)
	return BadAlloc;
      pNewEvent->next = 0;
      pNewEvent->client = client;
      pNewEvent->mask = stuff->mask;
      /*
       * add a resource that will be deleted when
       * the client goes away
       */
      clientResource = FakeClientID (client->index);
      pNewEvent->clientResource = clientResource;
      if (!AddResource (clientResource, ClientType, (pointer)pNewEvent))
	return BadAlloc;
      /*
       * create a resource to contain a pointer to the list
       * of clients selecting input.  This must be indirect as
       * the list may be arbitrarily rearranged which cannot be
       * done through the resource database.
       */
      if (!pHead)
	{
	  pHead = (WMEventPtr *) malloc(sizeof (WMEventPtr));
	  if (!pHead ||
	      !AddResource (eventResource, eventResourceType, (pointer)pHead))
	    {
	      FreeResource (clientResource, RT_NONE);
	      return BadAlloc;
	    }
	  *pHead = 0;
	}
      pNewEvent->next = *pHead;
      *pHead = pNewEvent;
      updateEventMask (pHead);
    }
  else if (stuff->mask == 0)
    {
      /* delete the interest */
      if (pHead)
	{
	  pNewEvent = 0;
	  for (pEvent = *pHead; pEvent; pEvent = pEvent->next)
	    {
	      if (pEvent->client == client)
		break;
	      pNewEvent = pEvent;
	    }
	  if (pEvent)
	    {
	      FreeResource (pEvent->clientResource, ClientType);
	      if (pNewEvent)
		pNewEvent->next = pEvent->next;
	      else
		*pHead = pEvent->next;
	      free(pEvent);
	      updateEventMask (pHead);
	    }
	}
    }
  else
    {
      client->errorValue = stuff->mask;
      return BadValue;
d236 1
a236 1
  return Success;
d244 2
a245 2
winWindowsWMSendEvent (int type, unsigned int mask, int which, int arg,
		       Window window, int x, int y, int w, int h)
d247 33
a279 34
  WMEventPtr		*pHead, pEvent;
  ClientPtr		client;
  xWindowsWMNotifyEvent se;
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winWindowsWMSendEvent %d %d %d %d,  %d %d - %d %d\n",
	  type, mask, which, arg, x, y, w, h);
#endif
  dixLookupResourceByType((pointer) &pHead, eventResource, eventResourceType,
				NullClient, DixUnknownAccess);
  if (!pHead)
    return;
  for (pEvent = *pHead; pEvent; pEvent = pEvent->next)
    {
      client = pEvent->client;
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winWindowsWMSendEvent - x%08x\n", (int) client);
#endif
      if ((pEvent->mask & mask) == 0)
	{
	  continue;
	}
#if CYGMULTIWINDOW_DEBUG 
      ErrorF ("winWindowsWMSendEvent - send\n");
#endif
      se.type = type + WMEventBase;
      se.kind = which;
      se.window = window;
      se.arg = arg;
      se.x = x;
      se.y = y;
      se.w = w;
      se.h = h;
      se.time = currentTime.milliseconds;
      WriteEventsToClient (client, 1, (xEvent *) &se);
d286 1
a286 1
ProcWindowsWMDisableUpdate (ClientPtr client)
d288 1
a288 1
  REQUEST_SIZE_MATCH(xWindowsWMDisableUpdateReq);
d290 1
a290 1
  //winDisableUpdate();
d292 1
a292 1
  return Success;
d296 1
a296 1
ProcWindowsWMReenableUpdate (ClientPtr client)
d298 1
a298 1
  REQUEST_SIZE_MATCH(xWindowsWMReenableUpdateReq);
d300 1
a300 1
  //winEnableUpdate(); 
d302 1
a302 1
  return Success;
a304 1

d308 1
a308 1
ProcWindowsWMSetFrontProcess (ClientPtr client)
d310 5
a314 5
  REQUEST_SIZE_MATCH(xWindowsWMSetFrontProcessReq);
  
  //QuartzMessageMainThread(kWindowsSetFrontProcess, NULL, 0);
  
  return Success;
a316 1

d320 1
a320 1
ProcWindowsWMFrameGetRect (ClientPtr client)
d322 5
a326 4
  xWindowsWMFrameGetRectReply rep;
  BoxRec ir;
  RECT rcNew;
  REQUEST(xWindowsWMFrameGetRectReq);
d329 2
a330 2
  ErrorF ("ProcWindowsWMFrameGetRect %d %d\n",
	  (sizeof(xWindowsWMFrameGetRectReq) >> 2), (int) client->req_len);
a331 5
  
  REQUEST_SIZE_MATCH(xWindowsWMFrameGetRectReq);
  rep.type = X_Reply;
  rep.length = 0;
  rep.sequenceNumber = client->sequence;
d333 6
a338 1
  ir = make_box (stuff->ix, stuff->iy, stuff->iw, stuff->ih);
d340 3
a342 4
  if (stuff->frame_rect != 0)
    {
      ErrorF ("ProcWindowsWMFrameGetRect - stuff->frame_rect != 0\n");
      return BadValue;
d345 4
a348 4
  /* Store the origin, height, and width in a rectangle structure */
  SetRect (&rcNew, stuff->ix, stuff->iy,
	   stuff->ix + stuff->iw, stuff->iy + stuff->ih);
    
d350 2
a351 2
  ErrorF ("ProcWindowsWMFrameGetRect - %d %d %d %d\n",
	  stuff->ix, stuff->iy, stuff->ix + stuff->iw, stuff->iy + stuff->ih);
d354 10
a363 9
  /*
   * Calculate the required size of the Windows window rectangle,
   * given the size of the Windows window client area.
   */
  AdjustWindowRectEx (&rcNew, stuff->frame_style, FALSE, stuff->frame_style_ex);
  rep.x = rcNew.left;
  rep.y = rcNew.top;
  rep.w = rcNew.right - rcNew.left;
  rep.h = rcNew.bottom - rcNew.top;
d365 2
a366 2
  ErrorF ("ProcWindowsWMFrameGetRect - %d %d %d %d\n",
	  rep.x, rep.y, rep.w, rep.h);
d369 2
a370 2
  WriteToClient(client, sizeof(xWindowsWMFrameGetRectReply), (char *)&rep);
  return Success;
a372 1

d374 1
a374 1
ProcWindowsWMFrameDraw (ClientPtr client)
d376 6
a381 6
  REQUEST(xWindowsWMFrameDrawReq);
  WindowPtr pWin;
  win32RootlessWindowPtr pRLWinPriv;
  RECT rcNew;
  int nCmdShow, rc;
  RegionRec newShape;
d383 1
a383 1
  REQUEST_SIZE_MATCH (xWindowsWMFrameDrawReq);
d386 1
a386 1
  ErrorF ("ProcWindowsWMFrameDraw\n");
d388 3
a390 3
  rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
  if (rc != Success)
      return rc;
d392 1
a392 1
  ErrorF ("ProcWindowsWMFrameDraw - Window found\n");
d395 3
a397 2
  pRLWinPriv = (win32RootlessWindowPtr) RootlessFrameForWindow (pWin, TRUE);
  if (pRLWinPriv == 0) return BadWindow;
d400 5
a404 5
  ErrorF ("ProcWindowsWMFrameDraw - HWND 0x%08x 0x%08x 0x%08x\n",
	  (int) pRLWinPriv->hWnd, (int) stuff->frame_style,
	  (int) stuff->frame_style_ex);
  ErrorF ("ProcWindowsWMFrameDraw - %d %d %d %d\n",
	  stuff->ix, stuff->iy, stuff->iw, stuff->ih);
d407 3
a409 3
  /* Store the origin, height, and width in a rectangle structure */
  SetRect (&rcNew, stuff->ix, stuff->iy,
	   stuff->ix + stuff->iw, stuff->iy + stuff->ih);
d411 10
a420 10
  /*
   * Calculate the required size of the Windows window rectangle,
   * given the size of the Windows window client area.
   */
  AdjustWindowRectEx (&rcNew, stuff->frame_style, FALSE, stuff->frame_style_ex);
  
  /* Set the window extended style flags */
  if (!SetWindowLongPtr (pRLWinPriv->hWnd, GWL_EXSTYLE, stuff->frame_style_ex))
    {
      return BadValue;
d423 3
a425 4
  /* Set the window standard style flags */
  if (!SetWindowLongPtr (pRLWinPriv->hWnd, GWL_STYLE, stuff->frame_style))
    {
      return BadValue;
d428 6
a433 7
  /* Flush the window style */
  if (!SetWindowPos (pRLWinPriv->hWnd, NULL,
		     rcNew.left, rcNew.top,
		     rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
		     SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE))
    {
      return BadValue;
d435 6
a440 4
  if (!IsWindowVisible(pRLWinPriv->hWnd))
    nCmdShow = SW_HIDE;
  else 
    nCmdShow = SW_SHOWNA;
d442 1
a442 1
  ShowWindow (pRLWinPriv->hWnd, nCmdShow);
d444 3
a446 1
  winMWExtWMUpdateIcon (pWin->drawable.id);
d448 5
a452 10
  if (wBoundingShape(pWin) != NULL)
    {
      /* wBoundingShape is relative to *inner* origin of window.
	 Translate by borderWidth to get the outside-relative position. */
      
      RegionNull(&newShape);
      RegionCopy(&newShape, wBoundingShape(pWin));
      RegionTranslate(&newShape, pWin->borderWidth, pWin->borderWidth);
      winMWExtWMReshapeFrame (pRLWinPriv, &newShape);
      RegionUninit(&newShape);
d455 1
a455 1
  ErrorF ("ProcWindowsWMFrameDraw - done\n");
d458 1
a458 1
  return Success;
d464 7
a470 6
  unsigned int title_length, title_max;
  char *title_bytes;
  REQUEST(xWindowsWMFrameSetTitleReq);
  WindowPtr pWin;
  win32RootlessWindowPtr pRLWinPriv;
  int rc;
d473 1
a473 1
  ErrorF ("ProcWindowsWMFrameSetTitle\n");
d476 1
a476 1
  REQUEST_AT_LEAST_SIZE(xWindowsWMFrameSetTitleReq);
d478 3
a480 3
  rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
  if (rc != Success)
      return rc;
d482 1
a482 1
  ErrorF ("ProcWindowsWMFrameSetTitle - Window found\n");
d485 2
a486 2
  title_length = stuff->title_length;
  title_max = (stuff->length << 2) - sizeof(xWindowsWMFrameSetTitleReq);
d488 2
a489 2
  if (title_max < title_length)
    return BadValue;
d492 1
a492 1
  ErrorF ("ProcWindowsWMFrameSetTitle - length is valid\n");
d495 3
a497 3
  title_bytes = malloc (title_length+1);
  strncpy (title_bytes, (unsigned char *) &stuff[1], title_length);
  title_bytes[title_length] = '\0';
d499 1
a499 1
  pRLWinPriv = (win32RootlessWindowPtr) RootlessFrameForWindow (pWin, FALSE);
d501 3
a503 4
  if (pRLWinPriv == 0)
    {
      free (title_bytes);
      return BadWindow;
a504 3
    
  /* Flush the window style */
  SetWindowText (pRLWinPriv->hWnd, title_bytes);
d506 4
a509 1
  free (title_bytes);
d512 1
a512 1
  ErrorF ("ProcWindowsWMFrameSetTitle - done\n");
d515 1
a515 1
  return Success;
a517 1

d521 1
a521 1
ProcWindowsWMDispatch (ClientPtr client)
d523 1
a523 1
  REQUEST(xReq);
d525 1
a525 2
  switch (stuff->data)
    {
d527 1
a527 1
      return ProcWindowsWMQueryVersion(client);
d530 2
a531 2
  if (!LocalClient(client))
    return WMErrorBase + WindowsWMClientNotLocal;
d533 1
a533 2
  switch (stuff->data)
    {
d535 1
a535 1
      return ProcWindowsWMSelectInput(client);
d537 1
a537 1
      return ProcWindowsWMDisableUpdate(client);
d539 1
a539 1
      return ProcWindowsWMReenableUpdate(client);
d541 1
a541 1
      return ProcWindowsWMSetFrontProcess(client);
d543 1
a543 1
      return ProcWindowsWMFrameGetRect(client);
d545 1
a545 1
      return ProcWindowsWMFrameDraw(client);
d547 1
a547 1
      return ProcWindowsWMFrameSetTitle(client);
d549 1
a549 1
      return BadRequest;
d554 1
a554 1
SNotifyEvent (xWindowsWMNotifyEvent *from, xWindowsWMNotifyEvent *to)
d556 6
a561 6
  to->type = from->type;
  to->kind = from->kind;
  cpswaps (from->sequenceNumber, to->sequenceNumber);
  cpswapl (from->window, to->window);
  cpswapl (from->time, to->time);
  cpswapl (from->arg, to->arg);
d565 1
a565 1
SProcWindowsWMQueryVersion (ClientPtr client)
d567 5
a571 4
  int n;
  REQUEST(xWindowsWMQueryVersionReq);
  swaps(&stuff->length, n);
  return ProcWindowsWMQueryVersion(client);
d575 1
a575 1
SProcWindowsWMDispatch (ClientPtr client)
d577 1
a577 1
  REQUEST(xReq);
d579 3
a581 3
  /* It is bound to be non-local when there is byte swapping */
  if (!LocalClient(client))
    return WMErrorBase + WindowsWMClientNotLocal;
d583 2
a584 3
  /* only local clients are allowed WM access */
  switch (stuff->data)
    {
d586 1
a586 1
      return SProcWindowsWMQueryVersion(client);
d588 1
a588 1
      return BadRequest;
d593 1
a593 1
winWindowsWMExtensionInit (void)
d595 1
a595 1
  ExtensionEntry* extEntry;
d597 18
a614 19
  ClientType = CreateNewResourceType(WMFreeClient, "WMClient");
  eventResourceType = CreateNewResourceType(WMFreeEvents, "WMEvent");
  eventResource = FakeClientID(0);

  if (ClientType && eventResourceType &&
      (extEntry = AddExtension(WINDOWSWMNAME,
			       WindowsWMNumberEvents,
			       WindowsWMNumberErrors,
			       ProcWindowsWMDispatch,
			       SProcWindowsWMDispatch,
			       NULL,
			       StandardMinorOpcode)))
    {
      size_t i;
      WMReqCode = (unsigned char)extEntry->base;
      WMErrorBase = extEntry->errorBase;
      WMEventBase = extEntry->eventBase;
      for (i=0; i < WindowsWMNumberEvents; i++)
        EventSwapVector[WMEventBase + i] = (EventSwapPtr) SNotifyEvent;
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a46 4

static DISPATCH_PROC(ProcWindowsWMDispatch);
static DISPATCH_PROC(SProcWindowsWMDispatch);

a78 25
void
winWindowsWMExtensionInit (void)
{
  ExtensionEntry* extEntry;

  ClientType = CreateNewResourceType(WMFreeClient, "WMClient");
  eventResourceType = CreateNewResourceType(WMFreeEvents, "WMEvent");
  eventResource = FakeClientID(0);

  if (ClientType && eventResourceType &&
      (extEntry = AddExtension(WINDOWSWMNAME,
			       WindowsWMNumberEvents,
			       WindowsWMNumberErrors,
			       ProcWindowsWMDispatch,
			       SProcWindowsWMDispatch,
			       NULL,
			       StandardMinorOpcode)))
    {
      WMReqCode = (unsigned char)extEntry->base;
      WMErrorBase = extEntry->errorBase;
      WMEventBase = extEntry->eventBase;
      EventSwapVector[WMEventBase] = (EventSwapPtr) SNotifyEvent;
    }
}

d80 1
a80 1
ProcWindowsWMQueryVersion(register ClientPtr client)
d83 1
a83 1
  register int n;
d161 1
a161 1
ProcWindowsWMSelectInput (register ClientPtr client)
d301 1
a301 1
ProcWindowsWMDisableUpdate (register ClientPtr client)
d311 1
a311 1
ProcWindowsWMReenableUpdate (register ClientPtr client)
d324 1
a324 1
ProcWindowsWMSetFrontProcess (register ClientPtr client)
d337 1
a337 1
ProcWindowsWMFrameGetRect (register ClientPtr client)
d391 1
a391 1
ProcWindowsWMFrameDraw (register ClientPtr client)
d481 1
a481 3
ProcWindowsWMFrameSetTitle(
			   register ClientPtr client
			   )
d484 1
a484 1
  unsigned char *title_bytes;
d541 1
a541 1
ProcWindowsWMDispatch (register ClientPtr client)
d587 1
a587 1
SProcWindowsWMQueryVersion (register ClientPtr client)
d589 1
a589 1
  register int n;
d596 1
a596 1
SProcWindowsWMDispatch (register ClientPtr client)
d611 27
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d127 1
a127 1
  return (client->noClientException);
d167 1
a167 1
  xfree ((pointer) pEvent);
d182 1
a182 1
      xfree ((pointer) pCur);
d184 1
a184 1
  xfree ((pointer) pHead);
d215 1
a215 1
      pNewEvent = (WMEventPtr) xalloc (sizeof (WMEventRec));
d237 1
a237 1
	  pHead = (WMEventPtr *) xalloc (sizeof (WMEventPtr));
d269 1
a269 1
	      xfree (pEvent);
d307 1
a307 2
      if ((pEvent->mask & mask) == 0
	  || client == serverClient || client->clientGone)
a321 1
      se.sequenceNumber = client->sequence;
d336 1
a336 1
  return (client->noClientException);
d346 1
a346 1
  return (client->noClientException);
d359 1
a359 1
  return (client->noClientException);
d415 1
a415 1
  return (client->noClientException);
a427 1
  ScreenPtr pScreen;
a492 1
      pScreen = pWin->drawable.pScreen;
d496 3
a498 3
      REGION_NULL(pScreen, &newShape);
      REGION_COPY(pScreen, &newShape, wBoundingShape(pWin));
      REGION_TRANSLATE(pScreen, &newShape, pWin->borderWidth, pWin->borderWidth);
d500 1
a500 1
      REGION_UNINIT(pScreen, &newShape);
d506 1
a506 1
  return (client->noClientException);
d565 1
a565 1
  return (client->noClientException);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a33 2
#define NEED_REPLIES
#define NEED_EVENTS
d43 2
a44 1
#include "windowswmstr.h"
d54 1
a54 1
static RESTYPE ClientType, EventType; /* resource types for event masks */
d84 1
a84 1
winWindowsWMExtensionInit ()
d88 2
a89 2
  ClientType = CreateNewResourceType(WMFreeClient);
  EventType = CreateNewResourceType(WMFreeEvents);
d92 1
a92 1
  if (ClientType && EventType &&
d118 3
a120 3
  rep.majorVersion = WINDOWS_WM_MAJOR_VERSION;
  rep.minorVersion = WINDOWS_WM_MINOR_VERSION;
  rep.patchVersion = WINDOWS_WM_PATCH_VERSION;
d151 2
a152 1
  pHead = (WMEventPtr *) LookupIDByType(eventResource, EventType);
d197 1
a197 2
  pHead = (WMEventPtr *)SecurityLookupIDByType(client, eventResource,
					       EventType, DixWriteAccess);
d239 1
a239 1
	      !AddResource (eventResource, EventType, (pointer)pHead))
d297 2
a298 1
  pHead = (WMEventPtr *) LookupIDByType(eventResource, EventType);
a327 8

/* Safe to call from any thread. */
unsigned int
WindowsWMSelectedEvents (void)
{
  return eventMask;
}

@


1.1
log
@Initial revision
@
text
@a51 2
static void WindowsWMResetProc(ExtensionEntry* extEntry);

d99 1
a99 1
			       WindowsWMResetProc,
a108 6
/*ARGSUSED*/
static void
WindowsWMResetProc (ExtensionEntry* extEntry)
{
}

d198 1
a198 1
					       EventType, SecurityWriteAccess);
d436 1
a436 1
  int nCmdShow;
d445 3
a447 5
  if (!(pWin = SecurityLookupWindow((Drawable)stuff->window,
				    client, SecurityReadAccess)))
    {
      return BadValue;
    }
d531 1
d539 3
a541 5
  if (!(pWin = SecurityLookupWindow((Drawable)stuff->window,
				    client, SecurityReadAccess)))
    {
      return BadValue;
    }
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d206 1
a206 1
					       EventType, DixWriteAccess);
d444 1
a444 1
  int nCmdShow, rc;
d453 5
a457 3
  rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
  if (rc != Success)
      return rc;
a540 1
  int rc;
d548 5
a552 3
  rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
  if (rc != Success)
      return rc;
@

