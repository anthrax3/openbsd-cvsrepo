head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.6
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.6
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.30;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Keith Packard, MIT X Consortium
 *		Harold L Hunt II
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"

/* See Porting Layer Definition - p. 58 */
/*
 * Allocate indexes for the privates that we use.
 * Allocate memory directly for the screen privates.
 * Reserve space in GCs and Pixmaps for our privates.
 * Colormap privates are handled in winAllocateCmapPrivates ()
 */

Bool
winAllocatePrivates(ScreenPtr pScreen)
{
    winPrivScreenPtr pScreenPriv;

#if CYGDEBUG
    winDebug("winAllocateScreenPrivates - g_ulServerGeneration: %lu "
             "serverGeneration: %lu\n", g_ulServerGeneration, serverGeneration);
#endif

    /* We need a new slot for our privates if the screen gen has changed */
    if (g_ulServerGeneration != serverGeneration) {
        g_ulServerGeneration = serverGeneration;
    }

    /* Allocate memory for the screen private structure */
    pScreenPriv = malloc(sizeof(winPrivScreenRec));
    if (!pScreenPriv) {
        ErrorF("winAllocateScreenPrivates - malloc () failed\n");
        return FALSE;
    }

    /* Initialize the memory of the private structure */
    ZeroMemory(pScreenPriv, sizeof(winPrivScreenRec));

    /* Intialize private structure members */
    pScreenPriv->fActive = TRUE;

    /* Register our screen private */
    if (!dixRegisterPrivateKey(g_iScreenPrivateKey, PRIVATE_SCREEN, 0)) {
        ErrorF("winAllocatePrivates - AllocateScreenPrivate () failed\n");
        return FALSE;
    }

    /* Save the screen private pointer */
    winSetScreenPriv(pScreen, pScreenPriv);

    /* Reserve GC memory for our privates */
    if (!dixRegisterPrivateKey
        (g_iGCPrivateKey, PRIVATE_GC, sizeof(winPrivGCRec))) {
        ErrorF("winAllocatePrivates - AllocateGCPrivate () failed\n");
        return FALSE;
    }

    /* Reserve Pixmap memory for our privates */
    if (!dixRegisterPrivateKey
        (g_iPixmapPrivateKey, PRIVATE_PIXMAP, sizeof(winPrivPixmapRec))) {
        ErrorF("winAllocatePrivates - AllocatePixmapPrivates () failed\n");
        return FALSE;
    }

    /* Reserve Window memory for our privates */
    if (!dixRegisterPrivateKey
        (g_iWindowPrivateKey, PRIVATE_WINDOW, sizeof(winPrivWinRec))) {
        ErrorF("winAllocatePrivates () - AllocateWindowPrivates () failed\n");
        return FALSE;
    }

    return TRUE;
}

/*
 * Colormap privates may be allocated after the default colormap has
 * already been created for some screens.  This initialization procedure
 * is called for each default colormap that is found.
 */

Bool
winInitCmapPrivates(ColormapPtr pcmap, int i)
{
#if CYGDEBUG
    winDebug("winInitCmapPrivates\n");
#endif

    /*
     * I see no way that this function can do anything useful
     * with only a ColormapPtr.  We don't have the index for
     * our dev privates yet, so we can't really initialize
     * anything.  Perhaps I am misunderstanding the purpose
     * of this function.
     */
    /*  That's definitely true.
     *  I therefore changed the API and added the index as argument.
     */
    return TRUE;
}

/*
 * Allocate memory for our colormap privates
 */

Bool
winAllocateCmapPrivates(ColormapPtr pCmap)
{
    winPrivCmapPtr pCmapPriv;
    static unsigned long s_ulPrivateGeneration = 0;

#if CYGDEBUG
    winDebug("winAllocateCmapPrivates\n");
#endif

    /* Get a new privates index when the server generation changes */
    if (s_ulPrivateGeneration != serverGeneration) {
        /* Save the new server generation */
        s_ulPrivateGeneration = serverGeneration;
    }

    /* Allocate memory for our private structure */
    pCmapPriv = malloc(sizeof(winPrivCmapRec));
    if (!pCmapPriv) {
        ErrorF("winAllocateCmapPrivates - malloc () failed\n");
        return FALSE;
    }

    /* Initialize the memory of the private structure */
    ZeroMemory(pCmapPriv, sizeof(winPrivCmapRec));

    /* Register our colourmap private */
    if (!dixRegisterPrivateKey(g_iCmapPrivateKey, PRIVATE_COLORMAP, 0)) {
        ErrorF("winAllocateCmapPrivates - AllocateCmapPrivate () failed\n");
        return FALSE;
    }

    /* Save the cmap private pointer */
    winSetCmapPriv(pCmap, pCmapPriv);

#if CYGDEBUG
    winDebug("winAllocateCmapPrivates - Returning\n");
#endif

    return TRUE;
}
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d51 2
a52 2
    winDebug("winAllocateScreenPrivates - g_ulServerGeneration: %d "
             "serverGeneration: %d\n", g_ulServerGeneration, serverGeneration);
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d61 1
a61 1
    pScreenPriv = (winPrivScreenPtr) malloc(sizeof(winPrivScreenRec));
d153 1
a153 1
    pCmapPriv = (winPrivCmapPtr) malloc(sizeof(winPrivCmapRec));
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d113 1
a113 1
winInitCmapPrivates(ColormapPtr pcmap, int index)
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a36 1

d46 1
a46 1
winAllocatePrivates (ScreenPtr pScreen)
d48 1
a48 1
  winPrivScreenPtr	pScreenPriv;
d51 2
a52 3
  winDebug ("winAllocateScreenPrivates - g_ulServerGeneration: %d "
	  "serverGeneration: %d\n",
	  g_ulServerGeneration, serverGeneration);
d55 3
a57 4
  /* We need a new slot for our privates if the screen gen has changed */
  if (g_ulServerGeneration != serverGeneration)
    {
      g_ulServerGeneration = serverGeneration;
d60 5
a64 6
  /* Allocate memory for the screen private structure */
  pScreenPriv = (winPrivScreenPtr) malloc (sizeof (winPrivScreenRec));
  if (!pScreenPriv)
    {
      ErrorF ("winAllocateScreenPrivates - malloc () failed\n");
      return FALSE;
d67 2
a68 2
  /* Initialize the memory of the private structure */
  ZeroMemory (pScreenPriv, sizeof (winPrivScreenRec));
d70 2
a71 2
  /* Intialize private structure members */
  pScreenPriv->fActive = TRUE;
d73 4
a76 5
  /* Register our screen private */
  if (!dixRegisterPrivateKey(g_iScreenPrivateKey, PRIVATE_SCREEN, 0))
    {
      ErrorF ("winAllocatePrivates - AllocateScreenPrivate () failed\n");
      return FALSE;
d79 2
a80 2
  /* Save the screen private pointer */
  winSetScreenPriv (pScreen, pScreenPriv);
d82 5
a86 5
  /* Reserve GC memory for our privates */
  if (!dixRegisterPrivateKey(g_iGCPrivateKey, PRIVATE_GC, sizeof (winPrivGCRec)))
    {
      ErrorF ("winAllocatePrivates - AllocateGCPrivate () failed\n");
      return FALSE;
d89 5
a93 5
  /* Reserve Pixmap memory for our privates */
  if (!dixRegisterPrivateKey(g_iPixmapPrivateKey, PRIVATE_PIXMAP, sizeof (winPrivPixmapRec)))
    {
      ErrorF ("winAllocatePrivates - AllocatePixmapPrivates () failed\n");
      return FALSE;
d96 6
a101 6
  /* Reserve Window memory for our privates */
  if (!dixRegisterPrivateKey(g_iWindowPrivateKey, PRIVATE_WINDOW, sizeof (winPrivWinRec)))
    {
      ErrorF ("winAllocatePrivates () - AllocateWindowPrivates () failed\n");
       return FALSE;
     }
d103 1
a103 1
  return TRUE;
a105 1

d113 1
a113 1
winInitCmapPrivates (ColormapPtr pcmap, int index)
d116 1
a116 1
  winDebug ("winInitCmapPrivates\n");
d118 12
a129 12
  
  /*
   * I see no way that this function can do anything useful
   * with only a ColormapPtr.  We don't have the index for
   * our dev privates yet, so we can't really initialize
   * anything.  Perhaps I am misunderstanding the purpose
   * of this function.
   */
  /*  That's definitely true.
   *  I therefore changed the API and added the index as argument.
   */
  return TRUE;
a131 1

d137 1
a137 1
winAllocateCmapPrivates (ColormapPtr pCmap)
d139 2
a140 2
  winPrivCmapPtr		pCmapPriv;
  static unsigned long		s_ulPrivateGeneration = 0;
d143 1
a143 1
  winDebug ("winAllocateCmapPrivates\n");
d146 4
a149 5
  /* Get a new privates index when the server generation changes */
  if (s_ulPrivateGeneration != serverGeneration)
    {
      /* Save the new server generation */
      s_ulPrivateGeneration = serverGeneration;
d152 5
a156 6
  /* Allocate memory for our private structure */
  pCmapPriv = (winPrivCmapPtr) malloc (sizeof (winPrivCmapRec));
  if (!pCmapPriv)
    {
      ErrorF ("winAllocateCmapPrivates - malloc () failed\n");
      return FALSE;
d159 2
a160 2
  /* Initialize the memory of the private structure */
  ZeroMemory (pCmapPriv, sizeof (winPrivCmapRec));
d162 4
a165 5
  /* Register our colourmap private */
  if (!dixRegisterPrivateKey(g_iCmapPrivateKey, PRIVATE_COLORMAP, 0))
    {
      ErrorF ("winAllocateCmapPrivates - AllocateCmapPrivate () failed\n");
      return FALSE;
d168 2
a169 2
  /* Save the cmap private pointer */
  winSetCmapPriv (pCmap, pCmapPriv);
d172 1
a172 1
  winDebug ("winAllocateCmapPrivates - Returning\n");
d175 1
a175 1
  return TRUE;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d77 7
d88 1
a88 1
  if (!dixRequestPrivate(g_iGCPrivateKey, sizeof (winPrivGCRec)))
d95 1
a95 1
  if (!dixRequestPrivate(g_iPixmapPrivateKey, sizeof (winPrivPixmapRec)))
d102 1
a102 1
  if (!dixRequestPrivate(g_iWindowPrivateKey, sizeof (winPrivWinRec)))
d170 7
@


1.1
log
@Initial revision
@
text
@a59 6
      /* Get an index that we can store our privates at */
      g_iScreenPrivateIndex = AllocateScreenPrivateIndex ();
      g_iGCPrivateIndex = AllocateGCPrivateIndex ();
      g_iPixmapPrivateIndex = AllocatePixmapPrivateIndex ();
      g_iWindowPrivateIndex = AllocateWindowPrivateIndex ();

d81 1
a81 2
  if (!AllocateGCPrivate (pScreen, g_iGCPrivateIndex,
			  sizeof (winPrivGCRec)))
d88 1
a88 2
  if (!AllocatePixmapPrivate (pScreen, g_iPixmapPrivateIndex,
			      sizeof (winPrivPixmapRec)))
d95 1
a95 2
  if (!AllocateWindowPrivate (pScreen, g_iWindowPrivateIndex,
			      sizeof (winPrivWinRec)))
a148 3
      /* Get an index that we can store our privates at */
      g_iCmapPrivateIndex = AllocateColormapPrivateIndex (winInitCmapPrivates);
      
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
