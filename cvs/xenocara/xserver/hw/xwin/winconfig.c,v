head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.24;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.03;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2013.06.07.17.28.54;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.29;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.56;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.09;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.36;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.22.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.22.22;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.03.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors: Alexander Gottwald	
 */

#ifdef HAVE_XWIN_CONFIG_H
#include <xwin-config.h>
#endif
#include "win.h"
#include "winconfig.h"
#include "winmsg.h"
#include "globals.h"

#include "xkbsrv.h"

#ifdef XWIN_XF86CONFIG
#ifndef CONFIGPATH
#define CONFIGPATH  "%A," "%R," \
                    "/etc/X11/%R," "%P/etc/X11/%R," \
                    "%E," "%F," \
                    "/etc/X11/%F," "%P/etc/X11/%F," \
                    "/etc/X11/%X-%M," "/etc/X11/%X," "/etc/%X," \
                    "%P/etc/X11/%X.%H," "%P/etc/X11/%X-%M," \
                    "%P/etc/X11/%X," \
                    "%P/lib/X11/%X.%H," "%P/lib/X11/%X-%M," \
                    "%P/lib/X11/%X"
#endif
#ifndef CONFIGDIRPATH
#define CONFIGDIRPATH  "/etc/X11/%X-%M," "/etc/X11/%X," "/etc/%X," \
                       "%P/etc/X11/%X.%H," "%P/etc/X11/%X-%M," \
                       "%P/etc/X11/%X," \
                       "%P/lib/X11/%X.%H," "%P/lib/X11/%X-%M," \
                       "%P/lib/X11/%X"
#endif

XF86ConfigPtr g_xf86configptr = NULL;
#endif

WinCmdlineRec g_cmdline = {
#ifdef XWIN_XF86CONFIG
    NULL,                       /* configFile */
    NULL,                       /* configDir */
#endif
    NULL,                       /* fontPath */
#ifdef XWIN_XF86CONFIG
    NULL,                       /* keyboard */
#endif
    NULL,                       /* xkbRules */
    NULL,                       /* xkbModel */
    NULL,                       /* xkbLayout */
    NULL,                       /* xkbVariant */
    NULL,                       /* xkbOptions */
    NULL,                       /* screenname */
    NULL,                       /* mousename */
    FALSE,                      /* emulate3Buttons */
    0                           /* emulate3Timeout */
};

winInfoRec g_winInfo = {
    {                           /* keyboard */
     0,                         /* leds */
     500,                       /* delay */
     30                         /* rate */
     }
    ,
    {                           /* xkb */
     NULL,                      /* rules */
     NULL,                      /* model */
     NULL,                      /* layout */
     NULL,                      /* variant */
     NULL,                      /* options */
     }
    ,
    {
     FALSE,
     50}
};

#define NULL_IF_EMPTY(x) (winNameCompare(x,"")?x:NULL)

#ifdef XWIN_XF86CONFIG
serverLayoutRec g_winConfigLayout;

static Bool ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p);
static Bool configLayout(serverLayoutPtr, XF86ConfLayoutPtr, char *);
static Bool configImpliedLayout(serverLayoutPtr, XF86ConfScreenPtr);
static Bool GetBoolValue(OptionInfoPtr p, const char *s);

Bool
winReadConfigfile()
{
    Bool retval = TRUE;
    char *filename, *dirname;
    MessageType filefrom = X_DEFAULT;
    MessageType dirfrom = X_DEFAULT;
    char *xf86ConfigFile = NULL;
    char *xf86ConfigDir = NULL;

    if (g_cmdline.configFile) {
        filefrom = X_CMDLINE;
        xf86ConfigFile = g_cmdline.configFile;
    }
    if (g_cmdline.configDir) {
        dirfrom = X_CMDLINE;
        xf86ConfigDir = g_cmdline.configDir;
    }

    /* Parse config file into data structure */
    xf86initConfigFiles();
    dirname = xf86openConfigDirFiles(CONFIGDIRPATH, xf86ConfigDir, PROJECTROOT);
    filename = xf86openConfigFile(CONFIGPATH, xf86ConfigFile, PROJECTROOT);

    /* Hack for backward compatibility */
    if (!filename && from == X_DEFAULT)
        filename = xf86openConfigFile(CONFIGPATH, "XF86Config", PROJECTROOT);

    if (filename) {
        winMsg(from, "Using config file: \"%s\"\n", filename);
    }
    else {
        winMsg(X_ERROR, "Unable to locate/open config file");
        if (xf86ConfigFile)
            ErrorF(": \"%s\"", xf86ConfigFile);
        ErrorF("\n");
    }
    if (dirname) {
        winMsg(from, "Using config directory: \"%s\"\n", dirname);
    }
    else {
        winMsg(X_ERROR, "Unable to locate/open config directory");
        if (xf86ConfigDir)
            ErrorF(": \"%s\"", xf86ConfigDir);
        ErrorF("\n");
    }
    if (!filename && !dirname) {
        return FALSE;
    }
    free(filename);
    free(dirname);
    if ((g_xf86configptr = xf86readConfigFile()) == NULL) {
        winMsg(X_ERROR, "Problem parsing the config file\n");
        return FALSE;
    }
    xf86closeConfigFile();

    LogPrintMarkers();

    /* set options from data structure */

    if (g_xf86configptr->conf_layout_lst == NULL ||
        g_cmdline.screenname != NULL) {
        if (g_cmdline.screenname == NULL) {
            winMsg(X_WARNING,
                   "No Layout section. Using the first Screen section.\n");
        }
        if (!configImpliedLayout(&g_winConfigLayout,
                                 g_xf86configptr->conf_screen_lst)) {
            winMsg(X_ERROR, "Unable to determine the screen layout\n");
            return FALSE;
        }
    }
    else {
        /* Check if layout is given in the config file */
        if (g_xf86configptr->conf_flags != NULL) {
            char *dfltlayout = NULL;
            void *optlist = g_xf86configptr->conf_flags->flg_option_lst;

            if (optlist && winFindOption(optlist, "defaultserverlayout"))
                dfltlayout =
                    winSetStrOption(optlist, "defaultserverlayout", NULL);

            if (!configLayout(&g_winConfigLayout,
                              g_xf86configptr->conf_layout_lst, dfltlayout)) {
                winMsg(X_ERROR, "Unable to determine the screen layout\n");
                return FALSE;
            }
        }
        else {
            if (!configLayout(&g_winConfigLayout,
                              g_xf86configptr->conf_layout_lst, NULL)) {
                winMsg(X_ERROR, "Unable to determine the screen layout\n");
                return FALSE;
            }
        }
    }

    /* setup special config files */
    winConfigFiles();
    return retval;
}
#endif

/* load layout definitions */
#include "winlayouts.h"

/* Set the keyboard configuration */
Bool
winConfigKeyboard(DeviceIntPtr pDevice)
{
    char layoutName[KL_NAMELENGTH];
    unsigned char layoutFriendlyName[256];
    unsigned int layoutNum = 0;
    unsigned int deviceIdentifier = 0;
    int keyboardType;

#ifdef XWIN_XF86CONFIG
    XF86ConfInputPtr kbd = NULL;
    XF86ConfInputPtr input_list = NULL;
    MessageType kbdfrom = X_CONFIG;
#endif
    MessageType from = X_DEFAULT;
    char *s = NULL;

    /* Setup defaults */
    XkbGetRulesDflts(&g_winInfo.xkb);

    /*
     * Query the windows autorepeat settings and change the xserver defaults.
     */
    {
        int kbd_delay;
        DWORD kbd_speed;

        if (SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &kbd_delay, 0) &&
            SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &kbd_speed, 0)) {
            switch (kbd_delay) {
            case 0:
                g_winInfo.keyboard.delay = 250;
                break;
            case 1:
                g_winInfo.keyboard.delay = 500;
                break;
            case 2:
                g_winInfo.keyboard.delay = 750;
                break;
            default:
            case 3:
                g_winInfo.keyboard.delay = 1000;
                break;
            }
            g_winInfo.keyboard.rate = (kbd_speed > 0) ? kbd_speed : 1;
            winMsgVerb(X_PROBED, 1, "Setting autorepeat to delay=%ld, rate=%ld\n",
                       g_winInfo.keyboard.delay, g_winInfo.keyboard.rate);
        }
    }

    keyboardType = GetKeyboardType(0);
    if (keyboardType > 0 && GetKeyboardLayoutName(layoutName)) {
        WinKBLayoutPtr pLayout;
        Bool bfound = FALSE;
        int pass;

        layoutNum = strtoul(layoutName, (char **) NULL, 16);
        if ((layoutNum & 0xffff) == 0x411) {
            if (keyboardType == 7) {
                /* Japanese layouts have problems with key event messages
                   such as the lack of WM_KEYUP for Caps Lock key.
                   Loading US layout fixes this problem. */
                if (LoadKeyboardLayout("00000409", KLF_ACTIVATE) != NULL)
                    winMsg(X_INFO, "Loading US keyboard layout.\n");
                else
                    winMsg(X_ERROR, "LoadKeyboardLayout failed.\n");
            }
        }

        /* Discover the friendly name of the current layout */
        {
            HKEY regkey = NULL;
            const char regtempl[] =
                "SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts\\";
            char *regpath;
            DWORD namesize = sizeof(layoutFriendlyName);

            regpath = malloc(sizeof(regtempl) + KL_NAMELENGTH + 1);
            strcpy(regpath, regtempl);
            strcat(regpath, layoutName);

            if (!RegOpenKey(HKEY_LOCAL_MACHINE, regpath, &regkey))
                RegQueryValueEx(regkey, "Layout Text", 0, NULL,
                                layoutFriendlyName, &namesize);

            /* Close registry key */
            if (regkey)
                RegCloseKey(regkey);
            free(regpath);
        }

        winMsg(X_PROBED,
               "Windows keyboard layout: \"%s\" (%08x) \"%s\", type %d\n",
               layoutName, layoutNum, layoutFriendlyName, keyboardType);

        deviceIdentifier = layoutNum >> 16;
        for (pass = 0; pass < 2; pass++) {
            /* If we didn't find an exact match for the input locale identifer,
               try to find an match on the language identifier part only  */
            if (pass == 1)
                layoutNum = (layoutNum & 0xffff);

            for (pLayout = winKBLayouts; pLayout->winlayout != -1; pLayout++) {
                if (pLayout->winlayout != layoutNum)
                    continue;
                if (pLayout->winkbtype > 0 && pLayout->winkbtype != keyboardType)
                    continue;

                bfound = TRUE;
                winMsg(X_PROBED,
                       "Found matching XKB configuration \"%s\"\n",
                       pLayout->layoutname);

                winMsg(X_PROBED,
                       "Model = \"%s\" Layout = \"%s\""
                       " Variant = \"%s\" Options = \"%s\"\n",
                       pLayout->xkbmodel ? pLayout->xkbmodel : "none",
                       pLayout->xkblayout ? pLayout->xkblayout : "none",
                       pLayout->xkbvariant ? pLayout->xkbvariant : "none",
                       pLayout->xkboptions ? pLayout->xkboptions : "none");

                g_winInfo.xkb.model = pLayout->xkbmodel;
                g_winInfo.xkb.layout = pLayout->xkblayout;
                g_winInfo.xkb.variant = pLayout->xkbvariant;
                g_winInfo.xkb.options = pLayout->xkboptions;

                if (deviceIdentifier == 0xa000) {
                    winMsg(X_PROBED, "Windows keyboard layout device identifier indicates Macintosh, setting Model = \"macintosh\"");
                    g_winInfo.xkb.model = "macintosh";
                }

                break;
            }

            if (bfound)
                break;
        }

        if (!bfound) {
            winMsg(X_ERROR,
                   "Keyboardlayout \"%s\" (%s) is unknown, using X server default layout\n",
                   layoutFriendlyName, layoutName);
        }
    }

    /* parse the configuration */
#ifdef XWIN_XF86CONFIG
    if (g_cmdline.keyboard)
        kbdfrom = X_CMDLINE;

    /*
     * Until the layout code is finished, I search for the keyboard
     * device and configure the server with it.
     */

    if (g_xf86configptr != NULL)
        input_list = g_xf86configptr->conf_input_lst;

    while (input_list != NULL) {
        if (winNameCompare(input_list->inp_driver, "keyboard") == 0) {
            /* Check if device name matches requested name */
            if (g_cmdline.keyboard && winNameCompare(input_list->inp_identifier,
                                                     g_cmdline.keyboard))
                continue;
            kbd = input_list;
        }
        input_list = input_list->list.next;
    }

    if (kbd != NULL) {

        if (kbd->inp_identifier)
            winMsg(kbdfrom, "Using keyboard \"%s\" as primary keyboard\n",
                   kbd->inp_identifier);

        if ((s = winSetStrOption(kbd->inp_option_lst, "AutoRepeat", NULL))) {
            if ((sscanf(s, "%ld %ld", &g_winInfo.keyboard.delay,
                        &g_winInfo.keyboard.rate) != 2) ||
                (g_winInfo.keyboard.delay < 1) ||
                (g_winInfo.keyboard.rate == 0) ||
                (1000 / g_winInfo.keyboard.rate) < 1) {
                winErrorFVerb(2, "\"%s\" is not a valid AutoRepeat value", s);
                free(s);
                return FALSE;
            }
            free(s);
            winMsg(X_CONFIG, "AutoRepeat: %ld %ld\n",
                   g_winInfo.keyboard.delay, g_winInfo.keyboard.rate);
        }
#endif

        s = NULL;
        if (g_cmdline.xkbRules) {
            s = g_cmdline.xkbRules;
            from = X_CMDLINE;
        }
#ifdef XWIN_XF86CONFIG
        else {
            s = winSetStrOption(kbd->inp_option_lst, "XkbRules", NULL);
            from = X_CONFIG;
        }
#endif
        if (s) {
            g_winInfo.xkb.rules = NULL_IF_EMPTY(s);
            winMsg(from, "XKB: rules: \"%s\"\n", s);
        }

        s = NULL;
        if (g_cmdline.xkbModel) {
            s = g_cmdline.xkbModel;
            from = X_CMDLINE;
        }
#ifdef XWIN_XF86CONFIG
        else {
            s = winSetStrOption(kbd->inp_option_lst, "XkbModel", NULL);
            from = X_CONFIG;
        }
#endif
        if (s) {
            g_winInfo.xkb.model = NULL_IF_EMPTY(s);
            winMsg(from, "XKB: model: \"%s\"\n", s);
        }

        s = NULL;
        if (g_cmdline.xkbLayout) {
            s = g_cmdline.xkbLayout;
            from = X_CMDLINE;
        }
#ifdef XWIN_XF86CONFIG
        else {
            s = winSetStrOption(kbd->inp_option_lst, "XkbLayout", NULL);
            from = X_CONFIG;
        }
#endif
        if (s) {
            g_winInfo.xkb.layout = NULL_IF_EMPTY(s);
            winMsg(from, "XKB: layout: \"%s\"\n", s);
        }

        s = NULL;
        if (g_cmdline.xkbVariant) {
            s = g_cmdline.xkbVariant;
            from = X_CMDLINE;
        }
#ifdef XWIN_XF86CONFIG
        else {
            s = winSetStrOption(kbd->inp_option_lst, "XkbVariant", NULL);
            from = X_CONFIG;
        }
#endif
        if (s) {
            g_winInfo.xkb.variant = NULL_IF_EMPTY(s);
            winMsg(from, "XKB: variant: \"%s\"\n", s);
        }

        s = NULL;
        if (g_cmdline.xkbOptions) {
            s = g_cmdline.xkbOptions;
            from = X_CMDLINE;
        }
#ifdef XWIN_XF86CONFIG
        else {
            s = winSetStrOption(kbd->inp_option_lst, "XkbOptions", NULL);
            from = X_CONFIG;
        }
#endif
        if (s) {
            g_winInfo.xkb.options = NULL_IF_EMPTY(s);
            winMsg(from, "XKB: options: \"%s\"\n", s);
        }

#ifdef XWIN_XF86CONFIG
    }
#endif

    return TRUE;
}

#ifdef XWIN_XF86CONFIG
Bool
winConfigMouse(DeviceIntPtr pDevice)
{
    MessageType mousefrom = X_CONFIG;

    XF86ConfInputPtr mouse = NULL;
    XF86ConfInputPtr input_list = NULL;

    if (g_cmdline.mouse)
        mousefrom = X_CMDLINE;

    if (g_xf86configptr != NULL)
        input_list = g_xf86configptr->conf_input_lst;

    while (input_list != NULL) {
        if (winNameCompare(input_list->inp_driver, "mouse") == 0) {
            /* Check if device name matches requested name */
            if (g_cmdline.mouse && winNameCompare(input_list->inp_identifier,
                                                  g_cmdline.mouse))
                continue;
            mouse = input_list;
        }
        input_list = input_list->list.next;
    }

    if (mouse != NULL) {
        if (mouse->inp_identifier)
            winMsg(mousefrom, "Using pointer \"%s\" as primary pointer\n",
                   mouse->inp_identifier);

        g_winInfo.pointer.emulate3Buttons =
            winSetBoolOption(mouse->inp_option_lst, "Emulate3Buttons", FALSE);
        if (g_cmdline.emulate3buttons)
            g_winInfo.pointer.emulate3Buttons = g_cmdline.emulate3buttons;

        g_winInfo.pointer.emulate3Timeout =
            winSetIntOption(mouse->inp_option_lst, "Emulate3Timeout", 50);
        if (g_cmdline.emulate3timeout)
            g_winInfo.pointer.emulate3Timeout = g_cmdline.emulate3timeout;
    }
    else {
        winMsg(X_ERROR, "No primary pointer configured\n");
        winMsg(X_DEFAULT, "Using compiletime defaults for pointer\n");
    }

    return TRUE;
}

Bool
winConfigFiles()
{
    MessageType from;
    XF86ConfFilesPtr filesptr = NULL;

    /* set some shortcuts */
    if (g_xf86configptr != NULL) {
        filesptr = g_xf86configptr->conf_files;
    }

    /* Fontpath */
    from = X_DEFAULT;

    if (g_cmdline.fontPath) {
        from = X_CMDLINE;
        defaultFontPath = g_cmdline.fontPath;
    }
    else if (filesptr != NULL && filesptr->file_fontpath) {
        from = X_CONFIG;
        defaultFontPath = strdup(filesptr->file_fontpath);
    }
    winMsg(from, "FontPath set to \"%s\"\n", defaultFontPath);

    return TRUE;
}
#else
Bool
winConfigFiles(void)
{
    /* Fontpath */
    if (g_cmdline.fontPath) {
        defaultFontPath = g_cmdline.fontPath;
        winMsg(X_CMDLINE, "FontPath set to \"%s\"\n", defaultFontPath);
    }

    return TRUE;
}
#endif

Bool
winConfigOptions(void)
{
    return TRUE;
}

Bool
winConfigScreens(void)
{
    return TRUE;
}

#ifdef XWIN_XF86CONFIG
char *
winSetStrOption(void *optlist, const char *name, char *deflt)
{
    OptionInfoRec o;

    o.name = name;
    o.type = OPTV_STRING;
    if (ParseOptionValue(-1, optlist, &o))
        deflt = o.value.str;
    if (deflt)
        return strdup(deflt);
    else
        return NULL;
}

int
winSetBoolOption(void *optlist, const char *name, int deflt)
{
    OptionInfoRec o;

    o.name = name;
    o.type = OPTV_BOOLEAN;
    if (ParseOptionValue(-1, optlist, &o))
        deflt = o.value.bool;
    return deflt;
}

int
winSetIntOption(void *optlist, const char *name, int deflt)
{
    OptionInfoRec o;

    o.name = name;
    o.type = OPTV_INTEGER;
    if (ParseOptionValue(-1, optlist, &o))
        deflt = o.value.num;
    return deflt;
}

double
winSetRealOption(void *optlist, const char *name, double deflt)
{
    OptionInfoRec o;

    o.name = name;
    o.type = OPTV_REAL;
    if (ParseOptionValue(-1, optlist, &o))
        deflt = o.value.realnum;
    return deflt;
}

double
winSetPercentOption(void *optlist, const char *name, double deflt)
{
    OptionInfoRec o;

    o.name = name;
    o.type = OPTV_PERCENT;
    if (ParseOptionValue(-1, optlist, &o))
        deflt = o.value.realnum;
    return deflt;
}
#endif

/*
 * Compare two strings for equality. This is caseinsensitive  and
 * The characters '_', ' ' (space) and '\t' (tab) are treated as
 * not existing.
 */

int
winNameCompare(const char *s1, const char *s2)
{
    char c1, c2;

    if (!s1 || *s1 == 0) {
        if (!s2 || *s2 == 0)
            return 0;
        else
            return 1;
    }

    while (*s1 == '_' || *s1 == ' ' || *s1 == '\t')
        s1++;
    while (*s2 == '_' || *s2 == ' ' || *s2 == '\t')
        s2++;

    c1 = (isupper((int) *s1) ? tolower((int) *s1) : *s1);
    c2 = (isupper((int) *s2) ? tolower((int) *s2) : *s2);

    while (c1 == c2) {
        if (c1 == 0)
            return 0;
        s1++;
        s2++;

        while (*s1 == '_' || *s1 == ' ' || *s1 == '\t')
            s1++;
        while (*s2 == '_' || *s2 == ' ' || *s2 == '\t')
            s2++;

        c1 = (isupper((int) *s1) ? tolower((int) *s1) : *s1);
        c2 = (isupper((int) *s2) ? tolower((int) *s2) : *s2);
    }
    return c1 - c2;
}

#ifdef XWIN_XF86CONFIG
/*
 * Find the named option in the list.
 * @@return the pointer to the option record, or NULL if not found.
 */

XF86OptionPtr
winFindOption(XF86OptionPtr list, const char *name)
{
    while (list) {
        if (winNameCompare(list->opt_name, name) == 0)
            return list;
        list = list->list.next;
    }
    return NULL;
}

/*
 * Find the Value of an named option.
 * @@return The option value or NULL if not found.
 */

char *
winFindOptionValue(XF86OptionPtr list, const char *name)
{
    list = winFindOption(list, name);
    if (list) {
        if (list->opt_val)
            return list->opt_val;
        else
            return "";
    }
    return NULL;
}

/*
 * Parse the option.
 */

static Bool
ParseOptionValue(int scrnIndex, void *options, OptionInfoPtr p)
{
    char *s, *end;

    if ((s = winFindOptionValue(options, p->name)) != NULL) {
        switch (p->type) {
        case OPTV_INTEGER:
            if (*s == '\0') {
                winDrvMsg(scrnIndex, X_WARNING,
                          "Option \"%s\" requires an integer value\n", p->name);
                p->found = FALSE;
            }
            else {
                p->value.num = strtoul(s, &end, 0);
                if (*end == '\0') {
                    p->found = TRUE;
                }
                else {
                    winDrvMsg(scrnIndex, X_WARNING,
                              "Option \"%s\" requires an integer value\n",
                              p->name);
                    p->found = FALSE;
                }
            }
            break;
        case OPTV_STRING:
            if (*s == '\0') {
                winDrvMsg(scrnIndex, X_WARNING,
                          "Option \"%s\" requires a string value\n", p->name);
                p->found = FALSE;
            }
            else {
                p->value.str = s;
                p->found = TRUE;
            }
            break;
        case OPTV_ANYSTR:
            p->value.str = s;
            p->found = TRUE;
            break;
        case OPTV_REAL:
            if (*s == '\0') {
                winDrvMsg(scrnIndex, X_WARNING,
                          "Option \"%s\" requires a floating point value\n",
                          p->name);
                p->found = FALSE;
            }
            else {
                p->value.realnum = strtod(s, &end);
                if (*end == '\0') {
                    p->found = TRUE;
                }
                else {
                    winDrvMsg(scrnIndex, X_WARNING,
                              "Option \"%s\" requires a floating point value\n",
                              p->name);
                    p->found = FALSE;
                }
            }
            break;
        case OPTV_BOOLEAN:
            if (GetBoolValue(p, s)) {
                p->found = TRUE;
            }
            else {
                winDrvMsg(scrnIndex, X_WARNING,
                          "Option \"%s\" requires a boolean value\n", p->name);
                p->found = FALSE;
            }
            break;
        case OPTV_PERCENT:
            if (*s == '\0') {
                winDrvMsg(scrnIndex, X_WARNING,
                          "Option \"%s\" requires a percent value\n", p->name);
                p->found = FALSE;
            }
            else {
                double percent = strtod(s, &end);

                if (end != s && winNameCompare(end, "%")) {
                    p->found = TRUE;
                    p->value.realnum = percent;
                }
                else {
                    winDrvMsg(scrnIndex, X_WARNING,
                              "Option \"%s\" requires a frequency value\n",
                              p->name);
                    p->found = FALSE;
                }
            }
        case OPTV_FREQ:
            if (*s == '\0') {
                winDrvMsg(scrnIndex, X_WARNING,
                          "Option \"%s\" requires a frequency value\n",
                          p->name);
                p->found = FALSE;
            }
            else {
                double freq = strtod(s, &end);
                int units = 0;

                if (end != s) {
                    p->found = TRUE;
                    if (!winNameCompare(end, "Hz"))
                        units = 1;
                    else if (!winNameCompare(end, "kHz") ||
                             !winNameCompare(end, "k"))
                        units = 1000;
                    else if (!winNameCompare(end, "MHz") ||
                             !winNameCompare(end, "M"))
                        units = 1000000;
                    else {
                        winDrvMsg(scrnIndex, X_WARNING,
                                  "Option \"%s\" requires a frequency value\n",
                                  p->name);
                        p->found = FALSE;
                    }
                    if (p->found)
                        freq *= (double) units;
                }
                else {
                    winDrvMsg(scrnIndex, X_WARNING,
                              "Option \"%s\" requires a frequency value\n",
                              p->name);
                    p->found = FALSE;
                }
                if (p->found) {
                    p->value.freq.freq = freq;
                    p->value.freq.units = units;
                }
            }
            break;
        case OPTV_NONE:
            /* Should never get here */
            p->found = FALSE;
            break;
        }
        if (p->found) {
            winDrvMsgVerb(scrnIndex, X_CONFIG, 2, "Option \"%s\"", p->name);
            if (!(p->type == OPTV_BOOLEAN && *s == 0)) {
                winErrorFVerb(2, " \"%s\"", s);
            }
            winErrorFVerb(2, "\n");
        }
    }
    else if (p->type == OPTV_BOOLEAN) {
        /* Look for matches with options with or without a "No" prefix. */
        char *n, *newn;
        OptionInfoRec opt;

        n = winNormalizeName(p->name);
        if (!n) {
            p->found = FALSE;
            return FALSE;
        }
        if (strncmp(n, "no", 2) == 0) {
            newn = n + 2;
        }
        else {
            free(n);
            n = malloc(strlen(p->name) + 2 + 1);
            if (!n) {
                p->found = FALSE;
                return FALSE;
            }
            strcpy(n, "No");
            strcat(n, p->name);
            newn = n;
        }
        if ((s = winFindOptionValue(options, newn)) != NULL) {
            if (GetBoolValue(&opt, s)) {
                p->value.bool = !opt.value.bool;
                p->found = TRUE;
            }
            else {
                winDrvMsg(scrnIndex, X_WARNING,
                          "Option \"%s\" requires a boolean value\n", newn);
                p->found = FALSE;
            }
        }
        else {
            p->found = FALSE;
        }
        if (p->found) {
            winDrvMsgVerb(scrnIndex, X_CONFIG, 2, "Option \"%s\"", newn);
            if (*s != 0) {
                winErrorFVerb(2, " \"%s\"", s);
            }
            winErrorFVerb(2, "\n");
        }
        free(n);
    }
    else {
        p->found = FALSE;
    }
    return p->found;
}

static Bool
configLayout(serverLayoutPtr servlayoutp, XF86ConfLayoutPtr conf_layout,
             char *default_layout)
{
#if 0
#pragma warn UNIMPLEMENTED
#endif
    return TRUE;
}

static Bool
configImpliedLayout(serverLayoutPtr servlayoutp, XF86ConfScreenPtr conf_screen)
{
#if 0
#pragma warn UNIMPLEMENTED
#endif
    return TRUE;
}

static Bool
GetBoolValue(OptionInfoPtr p, const char *s)
{
    if (*s == 0) {
        p->value.bool = TRUE;
    }
    else {
        if (winNameCompare(s, "1") == 0)
            p->value.bool = TRUE;
        else if (winNameCompare(s, "on") == 0)
            p->value.bool = TRUE;
        else if (winNameCompare(s, "true") == 0)
            p->value.bool = TRUE;
        else if (winNameCompare(s, "yes") == 0)
            p->value.bool = TRUE;
        else if (winNameCompare(s, "0") == 0)
            p->value.bool = FALSE;
        else if (winNameCompare(s, "off") == 0)
            p->value.bool = FALSE;
        else if (winNameCompare(s, "false") == 0)
            p->value.bool = FALSE;
        else if (winNameCompare(s, "no") == 0)
            p->value.bool = FALSE;
    }
    return TRUE;
}
#endif

char *
winNormalizeName(const char *s)
{
    char *ret, *q;
    const char *p;

    if (s == NULL)
        return NULL;

    ret = malloc(strlen(s) + 1);
    for (p = s, q = ret; *p != 0; p++) {
        switch (*p) {
        case '_':
        case ' ':
        case '\t':
            continue;
        default:
            if (isupper((int) *p))
                *q++ = tolower((int) *p);
            else
                *q++ = *p;
        }
    }
    *q = '\0';
    return ret;
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d227 2
a228 1
    static unsigned int layoutNum = 0;
d267 1
a267 1
            winMsgVerb(X_PROBED, 1, "Setting autorepeat to delay=%d, rate=%d\n",
d276 1
d278 1
a278 2
        if (!layoutNum)
            layoutNum = strtoul(layoutName, (char **) NULL, 16);
a279 5
            /* The japanese layouts know a lot of different IMEs which all have
               different layout numbers set. Map them to a single entry.
               Same might apply for chinese, korean and other symbol languages
               too */
            layoutNum = (layoutNum & 0xffff);
d317 35
a351 23
        for (pLayout = winKBLayouts; pLayout->winlayout != -1; pLayout++) {
            if (pLayout->winlayout != layoutNum)
                continue;
            if (pLayout->winkbtype > 0 && pLayout->winkbtype != keyboardType)
                continue;

            bfound = TRUE;
            winMsg(X_PROBED,
                   "Found matching XKB configuration \"%s\"\n",
                   pLayout->layoutname);

            winMsg(X_PROBED,
                   "Model = \"%s\" Layout = \"%s\""
                   " Variant = \"%s\" Options = \"%s\"\n",
                   pLayout->xkbmodel ? pLayout->xkbmodel : "none",
                   pLayout->xkblayout ? pLayout->xkblayout : "none",
                   pLayout->xkbvariant ? pLayout->xkbvariant : "none",
                   pLayout->xkboptions ? pLayout->xkboptions : "none");

            g_winInfo.xkb.model = pLayout->xkbmodel;
            g_winInfo.xkb.layout = pLayout->xkblayout;
            g_winInfo.xkb.variant = pLayout->xkbvariant;
            g_winInfo.xkb.options = pLayout->xkboptions;
d353 5
a357 1
            break;
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d242 1
a242 1
     * Query the windows autorepeat settings and change the xserver defaults.   
d280 1
a280 1
               different layout numbers set. Map them to a single entry. 
d361 1
a361 1
     * Until the layout code is finished, I search for the keyboard 
d656 1
a656 1
 * The characters '_', ' ' (space) and '\t' (tab) are treated as 
d699 1
a699 1
 * Find the named option in the list. 
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d109 1
a109 1
static Bool ParseOptionValue(int scrnIndex, pointer options, OptionInfoPtr p);
d191 1
a191 1
            pointer optlist = g_xf86configptr->conf_flags->flg_option_lst;
d591 1
a591 1
winSetStrOption(pointer optlist, const char *name, char *deflt)
d606 1
a606 1
winSetBoolOption(pointer optlist, const char *name, int deflt)
d618 1
a618 1
winSetIntOption(pointer optlist, const char *name, int deflt)
d630 1
a630 1
winSetRealOption(pointer optlist, const char *name, double deflt)
d642 1
a642 1
winSetPercentOption(pointer optlist, const char *name, double deflt)
d737 1
a737 1
ParseOptionValue(int scrnIndex, pointer options, OptionInfoPtr p)
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d765 1
a765 1
                          "Option \"%s\" requires an string value\n", p->name);
@


1.5
log
@Update to xserver 1.11.2
@
text
@d66 2
a67 2
  NULL,				/* configFile */
  NULL,				/* configDir */
d69 1
a69 1
  NULL,				/* fontPath */
d71 1
a71 1
  NULL,				/* keyboard */
d73 9
a81 9
  NULL,             /* xkbRules */
  NULL,             /* xkbModel */
  NULL,             /* xkbLayout */
  NULL,             /* xkbVariant */
  NULL,             /* xkbOptions */
  NULL,				/* screenname */
  NULL,				/* mousename */
  FALSE,			/* emulate3Buttons */
  0				/* emulate3Timeout */
d85 17
a101 17
  {				/* keyboard */
   0,				/* leds */
   500,				/* delay */
   30				/* rate */
   }
  ,
  {				/* xkb */
   NULL,			/* rules */
   NULL,			/* model */
   NULL,			/* layout */
   NULL,			/* variant */
   NULL,			/* options */
   }
  ,
  {
   FALSE,
   50}
d109 4
a112 6
static Bool ParseOptionValue (int scrnIndex, pointer options,
			      OptionInfoPtr p);
static Bool configLayout (serverLayoutPtr, XF86ConfLayoutPtr, char *);
static Bool configImpliedLayout (serverLayoutPtr, XF86ConfScreenPtr);
static Bool GetBoolValue (OptionInfoPtr p, const char *s);

d115 1
a115 1
winReadConfigfile ()
d117 69
a185 11
  Bool		retval = TRUE;
  const char	*filename, *dirname;
  MessageType	filefrom = X_DEFAULT;
  MessageType	dirfrom = X_DEFAULT;
  char		*xf86ConfigFile = NULL;
  char		*xf86ConfigDir = NULL;

  if (g_cmdline.configFile)
    {
      filefrom = X_CMDLINE;
      xf86ConfigFile = g_cmdline.configFile;
d187 23
a209 40
  if (g_cmdline.configDir)
    {
      dirfrom = X_CMDLINE;
      xf86ConfigDir = g_cmdline.configDir;
    }

  /* Parse config file into data structure */
  xf86initConfigFiles();
  dirname = xf86openConfigDirFiles (CONFIGDIRPATH, xf86ConfigDir, PROJECTROOT);
  filename = xf86openConfigFile (CONFIGPATH, xf86ConfigFile, PROJECTROOT);

  /* Hack for backward compatibility */
  if (!filename && from == X_DEFAULT)
    filename = xf86openConfigFile (CONFIGPATH, "XF86Config", PROJECTROOT);

  if (filename)
    {
      winMsg (from, "Using config file: \"%s\"\n", filename);
    }
  else
    {
      winMsg (X_ERROR, "Unable to locate/open config file");
      if (xf86ConfigFile)
	ErrorF (": \"%s\"", xf86ConfigFile);
      ErrorF ("\n");
    }
  if (dirname)
    {
      winMsg (from, "Using config directory: \"%s\"\n", dirname);
    }
  else
    {
      winMsg (X_ERROR, "Unable to locate/open config directory");
      if (xf86ConfigDir)
	ErrorF (": \"%s\"", xf86ConfigDir);
      ErrorF ("\n");
    }
  if (!filename && !dirname)
    {
      return FALSE;
a210 8
  if ((g_xf86configptr = xf86readConfigFile ()) == NULL)
    {
      winMsg (X_ERROR, "Problem parsing the config file\n");
      return FALSE;
    }
  xf86closeConfigFile ();

  LogPrintMarkers();
d212 3
a214 51
  /* set options from data structure */

  if (g_xf86configptr->conf_layout_lst == NULL || g_cmdline.screenname != NULL)
    {
      if (g_cmdline.screenname == NULL)
	{
	  winMsg (X_WARNING,
		  "No Layout section. Using the first Screen section.\n");
	}
      if (!configImpliedLayout (&g_winConfigLayout,
				g_xf86configptr->conf_screen_lst))
	{
	  winMsg (X_ERROR, "Unable to determine the screen layout\n");
	  return FALSE;
	}
    }
  else
    {
      /* Check if layout is given in the config file */
      if (g_xf86configptr->conf_flags != NULL)
	{
	  char *dfltlayout = NULL;
	  pointer optlist = g_xf86configptr->conf_flags->flg_option_lst;

	  if (optlist && winFindOption (optlist, "defaultserverlayout"))
	    dfltlayout =
	      winSetStrOption (optlist, "defaultserverlayout", NULL);

	  if (!configLayout (&g_winConfigLayout,
			     g_xf86configptr->conf_layout_lst,
			     dfltlayout))
	    {
	      winMsg (X_ERROR, "Unable to determine the screen layout\n");
	      return FALSE;
	    }
	}
      else
	{
	  if (!configLayout (&g_winConfigLayout,
			     g_xf86configptr->conf_layout_lst,
			     NULL))
	    {
	      winMsg (X_ERROR, "Unable to determine the screen layout\n");
	      return FALSE;
	    }
	}
    }

  /* setup special config files */
  winConfigFiles ();
  return retval;
d223 1
a223 1
winConfigKeyboard (DeviceIntPtr pDevice)
d225 35
a259 29
  char                          layoutName[KL_NAMELENGTH];
  unsigned char                 layoutFriendlyName[256];
  static unsigned int           layoutNum = 0;
  int                           keyboardType;
#ifdef XWIN_XF86CONFIG
  XF86ConfInputPtr		kbd = NULL;
  XF86ConfInputPtr		input_list = NULL;
  MessageType			kbdfrom = X_CONFIG;
#endif
  MessageType			from = X_DEFAULT;
  char				*s = NULL;

  /* Setup defaults */
  XkbGetRulesDflts(&g_winInfo.xkb);

  /*
   * Query the windows autorepeat settings and change the xserver defaults.   
   */
  {
    int kbd_delay;
    DWORD kbd_speed;
    if (SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &kbd_delay, 0) &&
        SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &kbd_speed, 0))
      {
        switch (kbd_delay) 
          {
            case 0:  g_winInfo.keyboard.delay = 250; break;
            case 1:  g_winInfo.keyboard.delay = 500; break;
            case 2:  g_winInfo.keyboard.delay = 750; break;
d261 8
a268 33
            case 3:  g_winInfo.keyboard.delay = 1000; break;
          }
        g_winInfo.keyboard.rate = (kbd_speed>0)?kbd_speed:1;
        winMsgVerb(X_PROBED, 1, "Setting autorepeat to delay=%d, rate=%d\n",
                g_winInfo.keyboard.delay, g_winInfo.keyboard.rate);
      }
  }
  

  keyboardType = GetKeyboardType (0);
  if (keyboardType > 0 && GetKeyboardLayoutName (layoutName)) 
  {
    WinKBLayoutPtr	pLayout;
    Bool                bfound = FALSE;

    if (! layoutNum)
      layoutNum = strtoul (layoutName, (char **)NULL, 16);
    if ((layoutNum & 0xffff) == 0x411) {
        /* The japanese layouts know a lot of different IMEs which all have
	   different layout numbers set. Map them to a single entry. 
	   Same might apply for chinese, korean and other symbol languages
	   too */
        layoutNum = (layoutNum & 0xffff);
	if (keyboardType == 7)
	  {
	    /* Japanese layouts have problems with key event messages
	       such as the lack of WM_KEYUP for Caps Lock key.
	       Loading US layout fixes this problem. */
	    if (LoadKeyboardLayout("00000409", KLF_ACTIVATE) != NULL)
	      winMsg (X_INFO, "Loading US keyboard layout.\n");
	    else
	      winMsg (X_ERROR, "LoadKeyboardLayout failed.\n");
	  }
d271 45
a315 34
    /* Discover the friendly name of the current layout */
    {
      HKEY                regkey = NULL;
      const char          regtempl[] = "SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts\\";
      char                *regpath;
      DWORD               namesize = sizeof(layoutFriendlyName);

      regpath = malloc(sizeof(regtempl) + KL_NAMELENGTH + 1);
      strcpy(regpath, regtempl);
      strcat(regpath, layoutName);

      if (!RegOpenKey(HKEY_LOCAL_MACHINE, regpath, &regkey))
          RegQueryValueEx(regkey, "Layout Text", 0, NULL, layoutFriendlyName, &namesize);

      /* Close registry key */
      if (regkey)
        RegCloseKey (regkey);
      free(regpath);
    }

    winMsg (X_PROBED, "Windows keyboard layout: \"%s\" (%08x) \"%s\", type %d\n",
            layoutName, layoutNum, layoutFriendlyName, keyboardType);

    for (pLayout = winKBLayouts; pLayout->winlayout != -1; pLayout++)
      {
	if (pLayout->winlayout != layoutNum)
	  continue;
	if (pLayout->winkbtype > 0 && pLayout->winkbtype != keyboardType)
	  continue;

        bfound = TRUE;
	winMsg (X_PROBED,
		"Found matching XKB configuration \"%s\"\n",
		pLayout->layoutname);
d318 2
a319 21
               "Model = \"%s\" Layout = \"%s\""
               " Variant = \"%s\" Options = \"%s\"\n",
               pLayout->xkbmodel ? pLayout->xkbmodel : "none",
               pLayout->xkblayout ? pLayout->xkblayout : "none",
               pLayout->xkbvariant ? pLayout->xkbvariant : "none",
               pLayout->xkboptions ? pLayout->xkboptions : "none");

	g_winInfo.xkb.model = pLayout->xkbmodel;
	g_winInfo.xkb.layout = pLayout->xkblayout;
	g_winInfo.xkb.variant = pLayout->xkbvariant;
	g_winInfo.xkb.options = pLayout->xkboptions;


	break;
      }

    if (!bfound)
      {
        winMsg (X_ERROR, "Keyboardlayout \"%s\" (%s) is unknown, using X server default layout\n", layoutFriendlyName, layoutName);
      }
  }
d321 23
a343 4
  /* parse the configuration */
#ifdef XWIN_XF86CONFIG
  if (g_cmdline.keyboard)
    kbdfrom = X_CMDLINE;
d345 2
a346 4
  /*
   * Until the layout code is finished, I search for the keyboard 
   * device and configure the server with it.
   */
d348 6
a353 2
  if (g_xf86configptr != NULL)
    input_list = g_xf86configptr->conf_input_lst;
d355 22
a376 11
  while (input_list != NULL)
    {
      if (winNameCompare (input_list->inp_driver, "keyboard") == 0)
	{
	  /* Check if device name matches requested name */
	  if (g_cmdline.keyboard && winNameCompare (input_list->inp_identifier,
						    g_cmdline.keyboard))
	    continue;
	  kbd = input_list;
	}
      input_list = input_list->list.next;
d379 1
a379 2
  if (kbd != NULL)
    {
d381 17
a397 19
      if (kbd->inp_identifier)
	winMsg (kbdfrom, "Using keyboard \"%s\" as primary keyboard\n",
		kbd->inp_identifier);

      if ((s = winSetStrOption(kbd->inp_option_lst, "AutoRepeat", NULL)))
        {
          if ((sscanf(s, "%ld %ld", &g_winInfo.keyboard.delay, 
                      &g_winInfo.keyboard.rate) != 2) ||
                  (g_winInfo.keyboard.delay < 1) || 
                  (g_winInfo.keyboard.rate == 0) || 
                  (1000 / g_winInfo.keyboard.rate) < 1) 
            {
              winErrorFVerb (2, "\"%s\" is not a valid AutoRepeat value", s);
              free(s);
              return FALSE;
            }
          free(s);
          winMsg (X_CONFIG, "AutoRepeat: %ld %ld\n", 
                  g_winInfo.keyboard.delay, g_winInfo.keyboard.rate);
d400 1
a400 1
      
d402 1
a402 2
        if (g_cmdline.xkbRules)
          {
d405 1
a405 1
          }
d407 2
a408 3
        else
          {
            s = winSetStrOption (kbd->inp_option_lst, "XkbRules", NULL);
d410 1
a410 1
          }
d412 5
a416 6
        if (s)
          {
            g_winInfo.xkb.rules = NULL_IF_EMPTY (s);
            winMsg (from, "XKB: rules: \"%s\"\n", s);
	  }
          
d418 1
a418 2
        if (g_cmdline.xkbModel)
          {
d421 1
a421 1
          }
d423 2
a424 3
        else
          {
            s = winSetStrOption (kbd->inp_option_lst, "XkbModel", NULL);
d426 1
a426 1
          }
d428 4
a431 5
        if (s)
	  {
	    g_winInfo.xkb.model = NULL_IF_EMPTY (s);
	    winMsg (from, "XKB: model: \"%s\"\n", s);
	  }
d434 1
a434 2
        if (g_cmdline.xkbLayout)
          {
d437 1
a437 1
          }
d439 2
a440 3
        else
          {
            s = winSetStrOption (kbd->inp_option_lst, "XkbLayout", NULL);
d442 1
a442 1
          }
d444 4
a447 5
        if (s)
          {
	    g_winInfo.xkb.layout = NULL_IF_EMPTY (s);
	    winMsg (from, "XKB: layout: \"%s\"\n", s);
	  }
d450 1
a450 2
        if (g_cmdline.xkbVariant)
          {
d453 1
a453 1
          }
d455 2
a456 3
        else
          {
            s = winSetStrOption (kbd->inp_option_lst, "XkbVariant", NULL);
d458 1
a458 1
          }
d460 4
a463 5
	if (s)
	  {
	    g_winInfo.xkb.variant = NULL_IF_EMPTY (s);
	    winMsg (from, "XKB: variant: \"%s\"\n", s);
	  }
d466 1
a466 2
        if (g_cmdline.xkbOptions)
          {
d469 1
a469 1
          }
d471 2
a472 3
        else
          {
            s = winSetStrOption (kbd->inp_option_lst, "XkbOptions", NULL);
d474 1
a474 1
          }
d476 4
a479 5
        if (s)
	  {
	    g_winInfo.xkb.options = NULL_IF_EMPTY (s);
	    winMsg (from, "XKB: options: \"%s\"\n", s);
	  }
d485 1
a485 1
  return TRUE;
a487 1

d490 1
a490 1
winConfigMouse (DeviceIntPtr pDevice)
d492 1
a492 1
  MessageType			mousefrom = X_CONFIG;
d494 2
a495 2
  XF86ConfInputPtr		mouse = NULL;
  XF86ConfInputPtr		input_list = NULL;
d497 16
a512 2
  if (g_cmdline.mouse)
    mousefrom = X_CMDLINE;
d514 4
a517 2
  if (g_xf86configptr != NULL)
    input_list = g_xf86configptr->conf_input_lst;
d519 4
a522 12
  while (input_list != NULL)
    {
      if (winNameCompare (input_list->inp_driver, "mouse") == 0)
	{
	  /* Check if device name matches requested name */
	  if (g_cmdline.mouse && winNameCompare (input_list->inp_identifier,
						 g_cmdline.mouse))
	    continue;
	  mouse = input_list;
	}
      input_list = input_list->list.next;
    }
d524 4
a527 15
  if (mouse != NULL)
    {
      if (mouse->inp_identifier)
	winMsg (mousefrom, "Using pointer \"%s\" as primary pointer\n",
		mouse->inp_identifier);

      g_winInfo.pointer.emulate3Buttons =
	winSetBoolOption (mouse->inp_option_lst, "Emulate3Buttons", FALSE);
      if (g_cmdline.emulate3buttons)
	g_winInfo.pointer.emulate3Buttons = g_cmdline.emulate3buttons;

      g_winInfo.pointer.emulate3Timeout =
	winSetIntOption (mouse->inp_option_lst, "Emulate3Timeout", 50);
      if (g_cmdline.emulate3timeout)
	g_winInfo.pointer.emulate3Timeout = g_cmdline.emulate3timeout;
d529 3
a531 4
  else
    {
      winMsg (X_ERROR, "No primary pointer configured\n");
      winMsg (X_DEFAULT, "Using compiletime defaults for pointer\n");
d534 1
a534 1
  return TRUE;
a536 1

d538 1
a538 1
winConfigFiles ()
d540 2
a541 2
  MessageType from;
  XF86ConfFilesPtr filesptr = NULL;
d543 3
a545 4
  /* set some shortcuts */
  if (g_xf86configptr != NULL)
    {
      filesptr = g_xf86configptr->conf_files;
d548 2
d551 3
a553 7
  /* Fontpath */
  from = X_DEFAULT;

  if (g_cmdline.fontPath)
    {
      from = X_CMDLINE;
      defaultFontPath = g_cmdline.fontPath;
d555 3
a557 4
  else if (filesptr != NULL && filesptr->file_fontpath)
    {
      from = X_CONFIG;
      defaultFontPath = strdup (filesptr->file_fontpath);
d559 1
a559 1
  winMsg (from, "FontPath set to \"%s\"\n", defaultFontPath);
d561 1
a561 1
  return TRUE;
d565 1
a565 1
winConfigFiles (void)
d567 4
a570 5
  /* Fontpath */
  if (g_cmdline.fontPath)
    {
      defaultFontPath = g_cmdline.fontPath;
      winMsg (X_CMDLINE, "FontPath set to \"%s\"\n", defaultFontPath);
d573 1
a573 1
  return TRUE;
a576 1

d578 1
a578 1
winConfigOptions (void)
d580 1
a580 1
  return TRUE;
a582 1

d584 1
a584 1
winConfigScreens (void)
d586 1
a586 1
  return TRUE;
a588 1

d591 1
a591 1
winSetStrOption (pointer optlist, const char *name, char *deflt)
d593 1
a593 1
  OptionInfoRec o;
d595 8
a602 8
  o.name = name;
  o.type = OPTV_STRING;
  if (ParseOptionValue (-1, optlist, &o))
    deflt = o.value.str;
  if (deflt)
    return strdup (deflt);
  else
    return NULL;
a604 1

d606 1
a606 1
winSetBoolOption (pointer optlist, const char *name, int deflt)
d608 1
a608 1
  OptionInfoRec o;
d610 5
a614 5
  o.name = name;
  o.type = OPTV_BOOLEAN;
  if (ParseOptionValue (-1, optlist, &o))
    deflt = o.value.bool;
  return deflt;
a616 1

d618 1
a618 1
winSetIntOption (pointer optlist, const char *name, int deflt)
d620 1
a620 1
  OptionInfoRec o;
d622 5
a626 5
  o.name = name;
  o.type = OPTV_INTEGER;
  if (ParseOptionValue (-1, optlist, &o))
    deflt = o.value.num;
  return deflt;
a628 1

d630 1
a630 1
winSetRealOption (pointer optlist, const char *name, double deflt)
d632 1
a632 1
  OptionInfoRec o;
d634 5
a638 5
  o.name = name;
  o.type = OPTV_REAL;
  if (ParseOptionValue (-1, optlist, &o))
    deflt = o.value.realnum;
  return deflt;
d642 1
a642 1
winSetPercentOption (pointer optlist, const char *name, double deflt)
d644 1
a644 1
  OptionInfoRec o;
d646 5
a650 5
  o.name = name;
  o.type = OPTV_PERCENT;
  if (ParseOptionValue (-1, optlist, &o))
    deflt = o.value.realnum;
  return deflt;
a653 1

d661 1
a661 1
winNameCompare (const char *s1, const char *s2)
d663 1
a663 1
  char c1, c2;
d665 5
a669 6
  if (!s1 || *s1 == 0)
    {
      if (!s2 || *s2 == 0)
	return 0;
      else
	return 1;
d672 7
a678 4
  while (*s1 == '_' || *s1 == ' ' || *s1 == '\t')
    s1++;
  while (*s2 == '_' || *s2 == ' ' || *s2 == '\t')
    s2++;
d680 5
a684 2
  c1 = (isupper ((int)*s1) ? tolower ((int)*s1) : *s1);
  c2 = (isupper ((int)*s2) ? tolower ((int)*s2) : *s2);
d686 4
a689 11
  while (c1 == c2)
    {
      if (c1 == 0)
	return 0;
      s1++;
      s2++;

      while (*s1 == '_' || *s1 == ' ' || *s1 == '\t')
	s1++;
      while (*s2 == '_' || *s2 == ' ' || *s2 == '\t')
	s2++;
d691 2
a692 2
      c1 = (isupper ((int)*s1) ? tolower ((int)*s1) : *s1);
      c2 = (isupper ((int)*s2) ? tolower ((int)*s2) : *s2);
d694 1
a694 1
  return c1 - c2;
a696 1

d704 1
a704 1
winFindOption (XF86OptionPtr list, const char *name)
d706 4
a709 5
  while (list)
    {
      if (winNameCompare (list->opt_name, name) == 0)
	return list;
      list = list->list.next;
d711 1
a711 1
  return NULL;
a713 1

d720 1
a720 1
winFindOptionValue (XF86OptionPtr list, const char *name)
d722 6
a727 7
  list = winFindOption (list, name);
  if (list)
    {
      if (list->opt_val)
	return list->opt_val;
      else
	return "";
d729 1
a729 1
  return NULL;
a731 1

d737 1
a737 1
ParseOptionValue (int scrnIndex, pointer options, OptionInfoPtr p)
d739 76
a814 1
  char *s, *end;
d816 65
a880 168
  if ((s = winFindOptionValue (options, p->name)) != NULL)
    {
      switch (p->type)
	{
	case OPTV_INTEGER:
	  if (*s == '\0')
	    {
	      winDrvMsg (scrnIndex, X_WARNING,
			 "Option \"%s\" requires an integer value\n",
			 p->name);
	      p->found = FALSE;
	    }
	  else
	    {
	      p->value.num = strtoul (s, &end, 0);
	      if (*end == '\0')
		{
		  p->found = TRUE;
		}
	      else
		{
		  winDrvMsg (scrnIndex, X_WARNING,
			     "Option \"%s\" requires an integer value\n",
			     p->name);
		  p->found = FALSE;
		}
	    }
	  break;
	case OPTV_STRING:
	  if (*s == '\0')
	    {
	      winDrvMsg (scrnIndex, X_WARNING,
			 "Option \"%s\" requires an string value\n", p->name);
	      p->found = FALSE;
	    }
	  else
	    {
	      p->value.str = s;
	      p->found = TRUE;
	    }
	  break;
	case OPTV_ANYSTR:
	  p->value.str = s;
	  p->found = TRUE;
	  break;
	case OPTV_REAL:
	  if (*s == '\0')
	    {
	      winDrvMsg (scrnIndex, X_WARNING,
			 "Option \"%s\" requires a floating point value\n",
			 p->name);
	      p->found = FALSE;
	    }
	  else
	    {
	      p->value.realnum = strtod (s, &end);
	      if (*end == '\0')
		{
		  p->found = TRUE;
		}
	      else
		{
		  winDrvMsg (scrnIndex, X_WARNING,
			     "Option \"%s\" requires a floating point value\n",
			     p->name);
		  p->found = FALSE;
		}
	    }
	  break;
	case OPTV_BOOLEAN:
	  if (GetBoolValue (p, s))
	    {
	      p->found = TRUE;
	    }
	  else
	    {
	      winDrvMsg (scrnIndex, X_WARNING,
			 "Option \"%s\" requires a boolean value\n", p->name);
	      p->found = FALSE;
	    }
	  break;
	case OPTV_PERCENT:
	  if (*s == '\0')
	    {
	      winDrvMsg (scrnIndex, X_WARNING,
			 "Option \"%s\" requires a percent value\n",
			 p->name);
	      p->found = FALSE;
	    }
	  else
	    {
	       double percent = strtod (s, &end);

	       if (end != s && winNameCompare (end, "%"))
		 {
		   p->found = TRUE;
		   p->value.realnum = percent;
		 }
	       else
		 {
		   winDrvMsg (scrnIndex, X_WARNING,
			      "Option \"%s\" requires a frequency value\n",
			       p->name);
		   p->found = FALSE;
		 }
	    }
	case OPTV_FREQ:
	  if (*s == '\0')
	    {
	      winDrvMsg (scrnIndex, X_WARNING,
			 "Option \"%s\" requires a frequency value\n",
			 p->name);
	      p->found = FALSE;
	    }
	  else
	    {
	      double freq = strtod (s, &end);
	      int units = 0;

	      if (end != s)
		{
		  p->found = TRUE;
		  if (!winNameCompare (end, "Hz"))
		    units = 1;
		  else if (!winNameCompare (end, "kHz") ||
			   !winNameCompare (end, "k"))
		    units = 1000;
		  else if (!winNameCompare (end, "MHz") ||
			   !winNameCompare (end, "M"))
		    units = 1000000;
		  else
		    {
		      winDrvMsg (scrnIndex, X_WARNING,
				 "Option \"%s\" requires a frequency value\n",
				 p->name);
		      p->found = FALSE;
		    }
		  if (p->found)
		    freq *= (double) units;
		}
	      else
		{
		  winDrvMsg (scrnIndex, X_WARNING,
			     "Option \"%s\" requires a frequency value\n",
			     p->name);
		  p->found = FALSE;
		}
	      if (p->found)
		{
		  p->value.freq.freq = freq;
		  p->value.freq.units = units;
		}
	    }
	  break;
	case OPTV_NONE:
	  /* Should never get here */
	  p->found = FALSE;
	  break;
	}
      if (p->found)
	{
	  winDrvMsgVerb (scrnIndex, X_CONFIG, 2, "Option \"%s\"", p->name);
	  if (!(p->type == OPTV_BOOLEAN && *s == 0))
	    {
	      winErrorFVerb (2, " \"%s\"", s);
	    }
	  winErrorFVerb (2, "\n");
	}
d882 46
a927 57
  else if (p->type == OPTV_BOOLEAN)
    {
      /* Look for matches with options with or without a "No" prefix. */
      char *n, *newn;
      OptionInfoRec opt;

      n = winNormalizeName (p->name);
      if (!n)
	{
	  p->found = FALSE;
	  return FALSE;
	}
      if (strncmp (n, "no", 2) == 0)
	{
	  newn = n + 2;
	}
      else
	{
	  free (n);
	  n = malloc (strlen (p->name) + 2 + 1);
	  if (!n)
	    {
	      p->found = FALSE;
	      return FALSE;
	    }
	  strcpy (n, "No");
	  strcat (n, p->name);
	  newn = n;
	}
      if ((s = winFindOptionValue (options, newn)) != NULL)
	{
	  if (GetBoolValue (&opt, s))
	    {
	      p->value.bool = !opt.value.bool;
	      p->found = TRUE;
	    }
	  else
	    {
	      winDrvMsg (scrnIndex, X_WARNING,
			 "Option \"%s\" requires a boolean value\n", newn);
	      p->found = FALSE;
	    }
	}
      else
	{
	  p->found = FALSE;
	}
      if (p->found)
	{
	  winDrvMsgVerb (scrnIndex, X_CONFIG, 2, "Option \"%s\"", newn);
	  if (*s != 0)
	    {
	      winErrorFVerb (2, " \"%s\"", s);
	    }
	  winErrorFVerb (2, "\n");
	}
      free (n);
d929 2
a930 3
  else
    {
      p->found = FALSE;
d932 1
a932 1
  return p->found;
a934 1

d936 2
a937 2
configLayout (serverLayoutPtr servlayoutp, XF86ConfLayoutPtr conf_layout,
	      char *default_layout)
d942 1
a942 1
  return TRUE;
a944 1

d946 1
a946 2
configImpliedLayout (serverLayoutPtr servlayoutp,
		     XF86ConfScreenPtr conf_screen)
d951 1
a951 1
  return TRUE;
a953 1

d955 1
a955 1
GetBoolValue (OptionInfoPtr p, const char *s)
d957 2
a958 3
  if (*s == 0)
    {
      p->value.bool = TRUE;
d960 17
a976 18
  else
    {
      if (winNameCompare (s, "1") == 0)
	p->value.bool = TRUE;
      else if (winNameCompare (s, "on") == 0)
	p->value.bool = TRUE;
      else if (winNameCompare (s, "true") == 0)
	p->value.bool = TRUE;
      else if (winNameCompare (s, "yes") == 0)
	p->value.bool = TRUE;
      else if (winNameCompare (s, "0") == 0)
	p->value.bool = FALSE;
      else if (winNameCompare (s, "off") == 0)
	p->value.bool = FALSE;
      else if (winNameCompare (s, "false") == 0)
	p->value.bool = FALSE;
      else if (winNameCompare (s, "no") == 0)
	p->value.bool = FALSE;
d978 1
a978 1
  return TRUE;
a981 1

d983 1
a983 1
winNormalizeName (const char *s)
d985 2
a986 2
  char *ret, *q;
  const char *p;
d988 2
a989 2
  if (s == NULL)
    return NULL;
d991 13
a1003 15
  ret = malloc (strlen (s) + 1);
  for (p = s, q = ret; *p != 0; p++)
    {
      switch (*p)
	{
	case '_':
	case ' ':
	case '\t':
	  continue;
	default:
	  if (isupper ((int)*p))
	    *q++ = tolower ((int)*p);
	  else
	    *q++ = *p;
	}
d1005 2
a1006 2
  *q = '\0';
  return ret;
a1007 1

@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d243 1
d303 1
a303 1
	      winMsg (X_ERROR, "LoadKeyboardLaout failed.\n");
d306 23
a328 2
    winMsg (X_PROBED, "winConfigKeyboard - Layout: \"%s\" (%08x) \n", 
            layoutName, layoutNum);
d336 1
a336 1
	
d339 11
a349 3
		"Using preset keyboard for \"%s\" (%x), type \"%d\"\n",
		pLayout->layoutname, pLayout->winlayout, keyboardType);
	
d353 3
a355 1
	g_winInfo.xkb.options = pLayout->xkboptions; 
d358 1
a358 1
    
d361 1
a361 22
        HKEY                regkey = NULL;
        const char          regtempl[] = 
          "SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts\\";
        char                *regpath;
        unsigned char       lname[256];
        DWORD               namesize = sizeof(lname);

        regpath = malloc(sizeof(regtempl) + KL_NAMELENGTH + 1);
        strcpy(regpath, regtempl);
        strcat(regpath, layoutName);

        if (!RegOpenKey(HKEY_LOCAL_MACHINE, regpath, &regkey) &&
          !RegQueryValueEx(regkey, "Layout Text", 0, NULL, lname, &namesize))
          {
	    winMsg (X_ERROR,
		"Keyboardlayout \"%s\" (%s) is unknown\n", lname, layoutName);
          }

	/* Close registry key */
	if (regkey)
	  RegCloseKey (regkey);
        free(regpath);
d363 2
a364 2
  }  
  
d726 2
a727 2
  c1 = (isupper (*s1) ? tolower (*s1) : *s1);
  c2 = (isupper (*s2) ? tolower (*s2) : *s2);
d741 2
a742 2
      c1 = (isupper (*s1) ? tolower (*s1) : *s1);
      c2 = (isupper (*s2) ? tolower (*s2) : *s2);
d1103 2
a1104 2
	  if (isupper (*p))
	    *q++ = tolower (*p);
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d396 1
a396 1
              xfree(s);
d399 1
a399 1
          xfree(s);
d586 1
a586 1
      defaultFontPath = xstrdup (filesptr->file_fontpath);
d633 1
a633 1
    return xstrdup (deflt);
d676 12
d733 1
a733 1
  return (c1 - c2);
d768 1
a768 1
	return (list->opt_val);
d772 1
a772 1
  return (NULL);
d866 25
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d39 1
a39 6
#ifdef XKB
#ifndef XKB_IN_SERVER
#define XKB_IN_SERVER
#endif
#include <xkbsrv.h>
#endif
d53 7
d67 1
a72 3
#ifdef XKB
  FALSE,			/* noXkbExtension */
  NULL,				/* xkbMap */
a77 1
#endif
a88 1
#ifdef XKB
a91 1
   FALSE,			/* disable */
a96 8
   NULL,			/* initialMap */
   NULL,			/* keymap */
   NULL,			/* types */
   NULL,			/* compat */
   NULL,			/* keycodes */
   NULL,			/* symbols */
   NULL				/* geometry */
#endif
d120 3
a122 2
  const char	*filename;
  MessageType	from = X_DEFAULT;
d124 1
d128 1
a128 1
      from = X_CMDLINE;
d131 5
d138 3
a141 2
  filename = xf86openConfigFile (CONFIGPATH, xf86ConfigFile, PROJECTROOT);
    
d156 14
a241 1
#ifdef XKB
a244 1
#endif
d254 1
a254 15
#ifdef XKB
  g_winInfo.xkb.disable = FALSE;
# ifdef PC98 /* japanese */	/* not implemented */
  g_winInfo.xkb.rules = "xfree98";
  g_winInfo.xkb.model = "pc98";
  g_winInfo.xkb.layout = "nex/jp";
  g_winInfo.xkb.variant = NULL;
  g_winInfo.xkb.options = NULL;
# else
  g_winInfo.xkb.rules = "xorg";
  g_winInfo.xkb.model = "pc101";
  g_winInfo.xkb.layout = "us";
  g_winInfo.xkb.variant = NULL;
  g_winInfo.xkb.options = NULL;
# endif	/* PC98 */
a257 2
   * If XKB is disabled then windows handles the autorepeat and the special 
   * treatment is not needed
d333 1
a333 1
        char                lname[256];
a353 9
  g_winInfo.xkb.initialMap = NULL;
  g_winInfo.xkb.keymap = NULL;
  g_winInfo.xkb.types = NULL;
  g_winInfo.xkb.compat = NULL;
  g_winInfo.xkb.keycodes = NULL;
  g_winInfo.xkb.symbols = NULL;
  g_winInfo.xkb.geometry = NULL;
#endif /* XKB */

d405 6
a410 7
#ifdef XKB
      from = X_DEFAULT;
      if (g_cmdline.noXkbExtension)
	{
	  from = X_CMDLINE;
	  g_winInfo.xkb.disable = TRUE;
	}
d412 5
a416 9
      else if (kbd->inp_option_lst)
	{
	  int b = winSetBoolOption (kbd->inp_option_lst, "XkbDisable", FALSE);
	  if (b)
	    {
	      from = X_CONFIG;
	      g_winInfo.xkb.disable = TRUE;
	    }
	}
d418 5
a422 24
      if (g_winInfo.xkb.disable)
	{
	  winMsg (from, "XkbExtension disabled\n");
	}
      else
	{
          s = NULL;  
          if (g_cmdline.xkbRules)
            {
              s = g_cmdline.xkbRules;
              from = X_CMDLINE;  
            }
#ifdef XWIN_XF86CONFIG
          else 
            {
              s = winSetStrOption (kbd->inp_option_lst, "XkbRules", NULL);
              from = X_CONFIG;  
            }
#endif
          if (s)
	    {
	      g_winInfo.xkb.rules = NULL_IF_EMPTY (s);
	      winMsg (from, "XKB: rules: \"%s\"\n", s);
	    }
d424 6
a429 6
          s = NULL;
          if (g_cmdline.xkbModel)
            {
              s = g_cmdline.xkbModel;
              from = X_CMDLINE;
            }
d431 5
a435 5
          else
            {
              s = winSetStrOption (kbd->inp_option_lst, "XkbModel", NULL);
              from = X_CONFIG;
            }  
d437 5
a441 5
	  if (s)
	    {
	      g_winInfo.xkb.model = NULL_IF_EMPTY (s);
	      winMsg (from, "XKB: model: \"%s\"\n", s);
	    }
d443 6
a448 6
          s = NULL;
          if (g_cmdline.xkbLayout)
            {
              s = g_cmdline.xkbLayout;
              from = X_CMDLINE;
            }
d450 5
a454 5
          else
            {
              s = winSetStrOption (kbd->inp_option_lst, "XkbLayout", NULL);
              from = X_CONFIG;
            }
d456 5
a460 5
          if (s)  
	    {
	      g_winInfo.xkb.layout = NULL_IF_EMPTY (s);
	      winMsg (from, "XKB: layout: \"%s\"\n", s);
	    }
d462 6
a467 6
          s = NULL;
          if (g_cmdline.xkbVariant)
            {
              s = g_cmdline.xkbVariant;
              from = X_CMDLINE;
            }
d469 5
a473 5
          else
            { 
              s = winSetStrOption (kbd->inp_option_lst, "XkbVariant", NULL);
              from = X_CONFIG;
            }
d475 5
a479 5
	  if (s)
	    {
	      g_winInfo.xkb.variant = NULL_IF_EMPTY (s);
	      winMsg (from, "XKB: variant: \"%s\"\n", s);
	    }
d481 6
a486 6
          s = NULL;
          if (g_cmdline.xkbOptions)
            {
              s = g_cmdline.xkbOptions;
              from = X_CMDLINE;
            }
d488 5
a492 5
          else
            { 
              s = winSetStrOption (kbd->inp_option_lst, "XkbOptions", NULL);
              from = X_CONFIG;
            }
d494 5
a498 27
          if (s)
	    {
	      g_winInfo.xkb.options = NULL_IF_EMPTY (s);
	      winMsg (from, "XKB: options: \"%s\"\n", s);
	    }

#ifdef XWIN_XF86CONFIG
	  from = X_CMDLINE;

	  if ((s = winSetStrOption (kbd->inp_option_lst, "XkbKeymap", NULL)))
	    {
	      g_winInfo.xkb.keymap = NULL_IF_EMPTY (s);
	      winMsg (X_CONFIG, "XKB: keymap: \"%s\" "
		      " (overrides other XKB settings)\n", s);
	    }

	  if ((s = winSetStrOption (kbd->inp_option_lst, "XkbCompat", NULL)))
	    {
	      g_winInfo.xkb.compat = NULL_IF_EMPTY (s);
	      winMsg (X_CONFIG, "XKB: compat: \"%s\"\n", s);
	    }

	  if ((s = winSetStrOption (kbd->inp_option_lst, "XkbTypes", NULL)))
	    {
	      g_winInfo.xkb.types = NULL_IF_EMPTY (s);
	      winMsg (X_CONFIG, "XKB: types: \"%s\"\n", s);
	    }
a499 22
	  if ((s =
	       winSetStrOption (kbd->inp_option_lst, "XkbKeycodes", NULL)))
	    {
	      g_winInfo.xkb.keycodes = NULL_IF_EMPTY (s);
	      winMsg (X_CONFIG, "XKB: keycodes: \"%s\"\n", s);
	    }

	  if ((s =
	       winSetStrOption (kbd->inp_option_lst, "XkbGeometry", NULL)))
	    {
	      g_winInfo.xkb.geometry = NULL_IF_EMPTY (s);
	      winMsg (X_CONFIG, "XKB: geometry: \"%s\"\n", s);
	    }

	  if ((s = winSetStrOption (kbd->inp_option_lst, "XkbSymbols", NULL)))
	    {
	      g_winInfo.xkb.symbols = NULL_IF_EMPTY (s);
	      winMsg (X_CONFIG, "XKB: symbols: \"%s\"\n", s);
	    }
#endif
#endif
	}
d594 1
a594 1
winConfigFiles ()
a595 2
  MessageType from;

d609 1
a609 1
winConfigOptions ()
d616 1
a616 1
winConfigScreens ()
@


1.1
log
@Initial revision
@
text
@d43 1
a43 1
#include <X11/extensions/XKBsrv.h>
a51 1
                    "%D/%X," \
a66 1
  NULL,				/* rgbPath */
a673 14
  /* RGBPath */
  from = X_DEFAULT;
  if (g_cmdline.rgbPath)
    {
      from = X_CMDLINE;
      rgbPath = g_cmdline.rgbPath;
    }
  else if (filesptr != NULL && filesptr->file_rgbpath)
    {
      from = X_CONFIG;
      rgbPath = xstrdup (filesptr->file_rgbpath);
    }
  winMsg (from, "RgbPath set to \"%s\"\n", rgbPath);

a686 8
    }

  /* RGBPath */
  if (g_cmdline.rgbPath)
    {
      from = X_CMDLINE;
      rgbPath = g_cmdline.rgbPath;
      winMsg (X_CMDLINE, "RgbPath set to \"%s\"\n", rgbPath);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d43 1
a43 1
#include <xkbsrv.h>
@

