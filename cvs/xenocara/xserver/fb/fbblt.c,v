head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.8
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.6
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.12
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.8
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.44;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.30;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright Â© 1998 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>
#include "fb.h"

#define InitializeShifts(sx,dx,ls,rs) { \
    if (sx != dx) { \
	if (sx > dx) { \
	    ls = sx - dx; \
	    rs = FB_UNIT - ls; \
	} else { \
	    rs = dx - sx; \
	    ls = FB_UNIT - rs; \
	} \
    } \
}

void
fbBlt(FbBits * srcLine,
      FbStride srcStride,
      int srcX,
      FbBits * dstLine,
      FbStride dstStride,
      int dstX,
      int width,
      int height, int alu, FbBits pm, int bpp, Bool reverse, Bool upsidedown)
{
    FbBits *src, *dst;
    int leftShift, rightShift;
    FbBits startmask, endmask;
    FbBits bits, bits1;
    int n, nmiddle;
    Bool destInvarient;
    int startbyte, endbyte;

    FbDeclareMergeRop();

    if (alu == GXcopy && pm == FB_ALLONES &&
        !(srcX & 7) && !(dstX & 7) && !(width & 7))
    {
        CARD8           *src_byte = (CARD8 *) srcLine + (srcX >> 3);
        CARD8           *dst_byte = (CARD8 *) dstLine + (dstX >> 3);
        FbStride        src_byte_stride = srcStride << (FB_SHIFT - 3);
        FbStride        dst_byte_stride = dstStride << (FB_SHIFT - 3);
        int             width_byte = (width >> 3);

        /* Make sure there's no overlap; we can't use memcpy in that
         * case as it's not well defined, so fall through to the
         * general code
         */
        if (src_byte + width_byte <= dst_byte ||
            dst_byte + width_byte <= src_byte)
        {
            int i;

            if (!upsidedown)
                for (i = 0; i < height; i++)
                    MEMCPY_WRAPPED(dst_byte + i * dst_byte_stride,
                                   src_byte + i * src_byte_stride,
                                   width_byte);
            else
                for (i = height - 1; i >= 0; i--)
                    MEMCPY_WRAPPED(dst_byte + i * dst_byte_stride,
                                   src_byte + i * src_byte_stride,
                                   width_byte);

            return;
        }
    }

    if (bpp == 24 && !FbCheck24Pix(pm)) {
        fbBlt24(srcLine, srcStride, srcX, dstLine, dstStride, dstX,
                width, height, alu, pm, reverse, upsidedown);
        return;
    }

    FbInitializeMergeRop(alu, pm);
    destInvarient = FbDestInvarientMergeRop();
    if (upsidedown) {
        srcLine += (height - 1) * (srcStride);
        dstLine += (height - 1) * (dstStride);
        srcStride = -srcStride;
        dstStride = -dstStride;
    }
    FbMaskBitsBytes(dstX, width, destInvarient, startmask, startbyte,
                    nmiddle, endmask, endbyte);
    if (reverse) {
        srcLine += ((srcX + width - 1) >> FB_SHIFT) + 1;
        dstLine += ((dstX + width - 1) >> FB_SHIFT) + 1;
        srcX = (srcX + width - 1) & FB_MASK;
        dstX = (dstX + width - 1) & FB_MASK;
    }
    else {
        srcLine += srcX >> FB_SHIFT;
        dstLine += dstX >> FB_SHIFT;
        srcX &= FB_MASK;
        dstX &= FB_MASK;
    }
    if (srcX == dstX) {
        while (height--) {
            src = srcLine;
            srcLine += srcStride;
            dst = dstLine;
            dstLine += dstStride;
            if (reverse) {
                if (endmask) {
                    bits = READ(--src);
                    --dst;
                    FbDoRightMaskByteMergeRop(dst, bits, endbyte, endmask);
                }
                n = nmiddle;
                if (destInvarient) {
                    while (n--)
                        WRITE(--dst, FbDoDestInvarientMergeRop(READ(--src)));
                }
                else {
                    while (n--) {
                        bits = READ(--src);
                        --dst;
                        WRITE(dst, FbDoMergeRop(bits, READ(dst)));
                    }
                }
                if (startmask) {
                    bits = READ(--src);
                    --dst;
                    FbDoLeftMaskByteMergeRop(dst, bits, startbyte, startmask);
                }
            }
            else {
                if (startmask) {
                    bits = READ(src++);
                    FbDoLeftMaskByteMergeRop(dst, bits, startbyte, startmask);
                    dst++;
                }
                n = nmiddle;
                if (destInvarient) {
#if 0
                    /*
                     * This provides some speedup on screen->screen blts
                     * over the PCI bus, usually about 10%.  But fb
                     * isn't usually used for this operation...
                     */
                    if (_ca2 + 1 == 0 && _cx2 == 0) {
                        FbBits t1, t2, t3, t4;

                        while (n >= 4) {
                            t1 = *src++;
                            t2 = *src++;
                            t3 = *src++;
                            t4 = *src++;
                            *dst++ = t1;
                            *dst++ = t2;
                            *dst++ = t3;
                            *dst++ = t4;
                            n -= 4;
                        }
                    }
#endif
                    while (n--)
                        WRITE(dst++, FbDoDestInvarientMergeRop(READ(src++)));
                }
                else {
                    while (n--) {
                        bits = READ(src++);
                        WRITE(dst, FbDoMergeRop(bits, READ(dst)));
                        dst++;
                    }
                }
                if (endmask) {
                    bits = READ(src);
                    FbDoRightMaskByteMergeRop(dst, bits, endbyte, endmask);
                }
            }
        }
    }
    else {
        if (srcX > dstX) {
            leftShift = srcX - dstX;
            rightShift = FB_UNIT - leftShift;
        }
        else {
            rightShift = dstX - srcX;
            leftShift = FB_UNIT - rightShift;
        }
        while (height--) {
            src = srcLine;
            srcLine += srcStride;
            dst = dstLine;
            dstLine += dstStride;

            bits1 = 0;
            if (reverse) {
                if (srcX < dstX)
                    bits1 = READ(--src);
                if (endmask) {
                    bits = FbScrRight(bits1, rightShift);
                    if (FbScrRight(endmask, leftShift)) {
                        bits1 = READ(--src);
                        bits |= FbScrLeft(bits1, leftShift);
                    }
                    --dst;
                    FbDoRightMaskByteMergeRop(dst, bits, endbyte, endmask);
                }
                n = nmiddle;
                if (destInvarient) {
                    while (n--) {
                        bits = FbScrRight(bits1, rightShift);
                        bits1 = READ(--src);
                        bits |= FbScrLeft(bits1, leftShift);
                        --dst;
                        WRITE(dst, FbDoDestInvarientMergeRop(bits));
                    }
                }
                else {
                    while (n--) {
                        bits = FbScrRight(bits1, rightShift);
                        bits1 = READ(--src);
                        bits |= FbScrLeft(bits1, leftShift);
                        --dst;
                        WRITE(dst, FbDoMergeRop(bits, READ(dst)));
                    }
                }
                if (startmask) {
                    bits = FbScrRight(bits1, rightShift);
                    if (FbScrRight(startmask, leftShift)) {
                        bits1 = READ(--src);
                        bits |= FbScrLeft(bits1, leftShift);
                    }
                    --dst;
                    FbDoLeftMaskByteMergeRop(dst, bits, startbyte, startmask);
                }
            }
            else {
                if (srcX > dstX)
                    bits1 = READ(src++);
                if (startmask) {
                    bits = FbScrLeft(bits1, leftShift);
                    if (FbScrLeft(startmask, rightShift)) {
                        bits1 = READ(src++);
                        bits |= FbScrRight(bits1, rightShift);
                    }
                    FbDoLeftMaskByteMergeRop(dst, bits, startbyte, startmask);
                    dst++;
                }
                n = nmiddle;
                if (destInvarient) {
                    while (n--) {
                        bits = FbScrLeft(bits1, leftShift);
                        bits1 = READ(src++);
                        bits |= FbScrRight(bits1, rightShift);
                        WRITE(dst, FbDoDestInvarientMergeRop(bits));
                        dst++;
                    }
                }
                else {
                    while (n--) {
                        bits = FbScrLeft(bits1, leftShift);
                        bits1 = READ(src++);
                        bits |= FbScrRight(bits1, rightShift);
                        WRITE(dst, FbDoMergeRop(bits, READ(dst)));
                        dst++;
                    }
                }
                if (endmask) {
                    bits = FbScrLeft(bits1, leftShift);
                    if (FbScrLeft(endmask, rightShift)) {
                        bits1 = READ(src);
                        bits |= FbScrRight(bits1, rightShift);
                    }
                    FbDoRightMaskByteMergeRop(dst, bits, endbyte, endmask);
                }
            }
        }
    }
}

#undef DEBUG_BLT24
#ifdef DEBUG_BLT24

static unsigned long
getPixel(char *src, int x)
{
    unsigned long l;

    l = 0;
    memcpy(&l, src + x * 3, 3);
    return l;
}
#endif

static void
fbBlt24Line(FbBits * src,
            int srcX,
            FbBits * dst, int dstX, int width, int alu, FbBits pm, Bool reverse)
{
#ifdef DEBUG_BLT24
    char *origDst = (char *) dst;
    FbBits *origLine = dst + ((dstX >> FB_SHIFT) - 1);
    int origNlw = ((width + FB_MASK) >> FB_SHIFT) + 3;
    int origX = dstX / 24;
#endif

    int leftShift, rightShift;
    FbBits startmask, endmask;
    int n;

    FbBits bits, bits1;
    FbBits mask;

    int rot;

    FbDeclareMergeRop();

    FbInitializeMergeRop(alu, FB_ALLONES);
    FbMaskBits(dstX, width, startmask, n, endmask);
#ifdef DEBUG_BLT24
    ErrorF("dstX %d width %d reverse %d\n", dstX, width, reverse);
#endif
    if (reverse) {
        src += ((srcX + width - 1) >> FB_SHIFT) + 1;
        dst += ((dstX + width - 1) >> FB_SHIFT) + 1;
        rot = FbFirst24Rot(((dstX + width - 8) & FB_MASK));
        rot = FbPrev24Rot(rot);
#ifdef DEBUG_BLT24
        ErrorF("dstX + width - 8: %d rot: %d\n", (dstX + width - 8) & FB_MASK,
               rot);
#endif
        srcX = (srcX + width - 1) & FB_MASK;
        dstX = (dstX + width - 1) & FB_MASK;
    }
    else {
        src += srcX >> FB_SHIFT;
        dst += dstX >> FB_SHIFT;
        srcX &= FB_MASK;
        dstX &= FB_MASK;
        rot = FbFirst24Rot(dstX);
#ifdef DEBUG_BLT24
        ErrorF("dstX: %d rot: %d\n", dstX, rot);
#endif
    }
    mask = FbRot24(pm, rot);
#ifdef DEBUG_BLT24
    ErrorF("pm 0x%x mask 0x%x\n", pm, mask);
#endif
    if (srcX == dstX) {
        if (reverse) {
            if (endmask) {
                bits = READ(--src);
                --dst;
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & endmask));
                mask = FbPrev24Pix(mask);
            }
            while (n--) {
                bits = READ(--src);
                --dst;
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask));
                mask = FbPrev24Pix(mask);
            }
            if (startmask) {
                bits = READ(--src);
                --dst;
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & startmask));
            }
        }
        else {
            if (startmask) {
                bits = READ(src++);
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & startmask));
                dst++;
                mask = FbNext24Pix(mask);
            }
            while (n--) {
                bits = READ(src++);
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask));
                dst++;
                mask = FbNext24Pix(mask);
            }
            if (endmask) {
                bits = READ(src);
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & endmask));
            }
        }
    }
    else {
        if (srcX > dstX) {
            leftShift = srcX - dstX;
            rightShift = FB_UNIT - leftShift;
        }
        else {
            rightShift = dstX - srcX;
            leftShift = FB_UNIT - rightShift;
        }

        bits1 = 0;
        if (reverse) {
            if (srcX < dstX)
                bits1 = READ(--src);
            if (endmask) {
                bits = FbScrRight(bits1, rightShift);
                if (FbScrRight(endmask, leftShift)) {
                    bits1 = READ(--src);
                    bits |= FbScrLeft(bits1, leftShift);
                }
                --dst;
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & endmask));
                mask = FbPrev24Pix(mask);
            }
            while (n--) {
                bits = FbScrRight(bits1, rightShift);
                bits1 = READ(--src);
                bits |= FbScrLeft(bits1, leftShift);
                --dst;
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask));
                mask = FbPrev24Pix(mask);
            }
            if (startmask) {
                bits = FbScrRight(bits1, rightShift);
                if (FbScrRight(startmask, leftShift)) {
                    bits1 = READ(--src);
                    bits |= FbScrLeft(bits1, leftShift);
                }
                --dst;
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & startmask));
            }
        }
        else {
            if (srcX > dstX)
                bits1 = READ(src++);
            if (startmask) {
                bits = FbScrLeft(bits1, leftShift);
                bits1 = READ(src++);
                bits |= FbScrRight(bits1, rightShift);
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & startmask));
                dst++;
                mask = FbNext24Pix(mask);
            }
            while (n--) {
                bits = FbScrLeft(bits1, leftShift);
                bits1 = READ(src++);
                bits |= FbScrRight(bits1, rightShift);
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask));
                dst++;
                mask = FbNext24Pix(mask);
            }
            if (endmask) {
                bits = FbScrLeft(bits1, leftShift);
                if (FbScrLeft(endmask, rightShift)) {
                    bits1 = READ(src);
                    bits |= FbScrRight(bits1, rightShift);
                }
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & endmask));
            }
        }
    }
#ifdef DEBUG_BLT24
    {
        int firstx, lastx, x;

        firstx = origX;
        if (firstx)
            firstx--;
        lastx = origX + width / 24 + 1;
        for (x = firstx; x <= lastx; x++)
            ErrorF("%06x ", getPixel(origDst, x));
        ErrorF("\n");
        while (origNlw--)
            ErrorF("%08x ", *origLine++);
        ErrorF("\n");
    }
#endif
}

void
fbBlt24(FbBits * srcLine,
        FbStride srcStride,
        int srcX,
        FbBits * dstLine,
        FbStride dstStride,
        int dstX,
        int width,
        int height, int alu, FbBits pm, Bool reverse, Bool upsidedown)
{
    if (upsidedown) {
        srcLine += (height - 1) * srcStride;
        dstLine += (height - 1) * dstStride;
        srcStride = -srcStride;
        dstStride = -dstStride;
    }
    while (height--) {
        fbBlt24Line(srcLine, srcX, dstLine, dstX, width, alu, pm, reverse);
        srcLine += srcStride;
        dstLine += dstStride;
    }
#ifdef DEBUG_BLT24
    ErrorF("\n");
#endif
}

void
fbBltStip(FbStip * src, FbStride srcStride,     /* in FbStip units, not FbBits units */
          int srcX, FbStip * dst, FbStride dstStride,   /* in FbStip units, not FbBits units */
          int dstX, int width, int height, int alu, FbBits pm, int bpp)
{
    fbBlt((FbBits *) src, FbStipStrideToBitsStride(srcStride), srcX,
          (FbBits *) dst, FbStipStrideToBitsStride(dstStride), dstX,
          width, height, alu, pm, bpp, FALSE, FALSE);
}
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a522 226
#if FB_SHIFT == FB_STIP_SHIFT + 1

/*
 * Could be generalized to FB_SHIFT > FB_STIP_SHIFT + 1 by
 * creating an ring of values stepped through for each line
 */

void
fbBltOdd(FbBits * srcLine,
         FbStride srcStrideEven,
         FbStride srcStrideOdd,
         int srcXEven,
         int srcXOdd,
         FbBits * dstLine,
         FbStride dstStrideEven,
         FbStride dstStrideOdd,
         int dstXEven,
         int dstXOdd, int width, int height, int alu, FbBits pm, int bpp)
{
    FbBits *src;
    int leftShiftEven, rightShiftEven;
    FbBits startmaskEven, endmaskEven;
    int nmiddleEven;

    FbBits *dst;
    int leftShiftOdd, rightShiftOdd;
    FbBits startmaskOdd, endmaskOdd;
    int nmiddleOdd;

    int leftShift, rightShift;
    FbBits startmask, endmask;
    int nmiddle;

    int srcX, dstX;

    FbBits bits, bits1;
    int n;

    Bool destInvarient;
    Bool even;

    FbDeclareMergeRop();

    FbInitializeMergeRop(alu, pm);
    destInvarient = FbDestInvarientMergeRop();

    srcLine += srcXEven >> FB_SHIFT;
    dstLine += dstXEven >> FB_SHIFT;
    srcXEven &= FB_MASK;
    dstXEven &= FB_MASK;
    srcXOdd &= FB_MASK;
    dstXOdd &= FB_MASK;

    FbMaskBits(dstXEven, width, startmaskEven, nmiddleEven, endmaskEven);
    FbMaskBits(dstXOdd, width, startmaskOdd, nmiddleOdd, endmaskOdd);

    even = TRUE;
    InitializeShifts(srcXEven, dstXEven, leftShiftEven, rightShiftEven);
    InitializeShifts(srcXOdd, dstXOdd, leftShiftOdd, rightShiftOdd);
    while (height--) {
        src = srcLine;
        dst = dstLine;
        if (even) {
            srcX = srcXEven;
            dstX = dstXEven;
            startmask = startmaskEven;
            endmask = endmaskEven;
            nmiddle = nmiddleEven;
            leftShift = leftShiftEven;
            rightShift = rightShiftEven;
            srcLine += srcStrideEven;
            dstLine += dstStrideEven;
            even = FALSE;
        }
        else {
            srcX = srcXOdd;
            dstX = dstXOdd;
            startmask = startmaskOdd;
            endmask = endmaskOdd;
            nmiddle = nmiddleOdd;
            leftShift = leftShiftOdd;
            rightShift = rightShiftOdd;
            srcLine += srcStrideOdd;
            dstLine += dstStrideOdd;
            even = TRUE;
        }
        if (srcX == dstX) {
            if (startmask) {
                bits = READ(src++);
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), startmask));
                dst++;
            }
            n = nmiddle;
            if (destInvarient) {
                while (n--) {
                    bits = READ(src++);
                    WRITE(dst, FbDoDestInvarientMergeRop(bits));
                    dst++;
                }
            }
            else {
                while (n--) {
                    bits = READ(src++);
                    WRITE(dst, FbDoMergeRop(bits, READ(dst)));
                    dst++;
                }
            }
            if (endmask) {
                bits = READ(src);
                WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), endmask));
            }
        }
        else {
            bits = 0;
            if (srcX > dstX)
                bits = READ(src++);
            if (startmask) {
                bits1 = FbScrLeft(bits, leftShift);
                bits = READ(src++);
                bits1 |= FbScrRight(bits, rightShift);
                WRITE(dst, FbDoMaskMergeRop(bits1, READ(dst), startmask));
                dst++;
            }
            n = nmiddle;
            if (destInvarient) {
                while (n--) {
                    bits1 = FbScrLeft(bits, leftShift);
                    bits = READ(src++);
                    bits1 |= FbScrRight(bits, rightShift);
                    WRITE(dst, FbDoDestInvarientMergeRop(bits1));
                    dst++;
                }
            }
            else {
                while (n--) {
                    bits1 = FbScrLeft(bits, leftShift);
                    bits = READ(src++);
                    bits1 |= FbScrRight(bits, rightShift);
                    WRITE(dst, FbDoMergeRop(bits1, READ(dst)));
                    dst++;
                }
            }
            if (endmask) {
                bits1 = FbScrLeft(bits, leftShift);
                if (FbScrLeft(endmask, rightShift)) {
                    bits = READ(src);
                    bits1 |= FbScrRight(bits, rightShift);
                }
                WRITE(dst, FbDoMaskMergeRop(bits1, READ(dst), endmask));
            }
        }
    }
}

void
fbBltOdd24(FbBits * srcLine,
           FbStride srcStrideEven,
           FbStride srcStrideOdd,
           int srcXEven,
           int srcXOdd,
           FbBits * dstLine,
           FbStride dstStrideEven,
           FbStride dstStrideOdd,
           int dstXEven, int dstXOdd, int width, int height, int alu, FbBits pm)
{
    Bool even = TRUE;

    while (height--) {
        if (even) {
            fbBlt24Line(srcLine, srcXEven, dstLine, dstXEven,
                        width, alu, pm, FALSE);
            srcLine += srcStrideEven;
            dstLine += dstStrideEven;
            even = FALSE;
        }
        else {
            fbBlt24Line(srcLine, srcXOdd, dstLine, dstXOdd,
                        width, alu, pm, FALSE);
            srcLine += srcStrideOdd;
            dstLine += dstStrideOdd;
            even = TRUE;
        }
    }
}

#endif

#if FB_STIP_SHIFT != FB_SHIFT
void
fbSetBltOdd(FbStip * stip,
            FbStride stipStride,
            int srcX,
            FbBits ** bits,
            FbStride * strideEven,
            FbStride * strideOdd, int *srcXEven, int *srcXOdd)
{
    int srcAdjust;
    int strideAdjust;

    /*
     * bytes needed to align source
     */
    srcAdjust = (((int) stip) & (FB_MASK >> 3));
    /*
     * FbStip units needed to align stride
     */
    strideAdjust = stipStride & (FB_MASK >> FB_STIP_SHIFT);

    *bits = (FbBits *) ((char *) stip - srcAdjust);
    if (srcAdjust) {
        *strideEven = FbStipStrideToBitsStride(stipStride + 1);
        *strideOdd = FbStipStrideToBitsStride(stipStride);

        *srcXEven = srcX + (srcAdjust << 3);
        *srcXOdd = srcX + (srcAdjust << 3) - (strideAdjust << FB_STIP_SHIFT);
    }
    else {
        *strideEven = FbStipStrideToBitsStride(stipStride);
        *strideOdd = FbStipStrideToBitsStride(stipStride + 1);

        *srcXEven = srcX;
        *srcXOdd = srcX + (strideAdjust << FB_STIP_SHIFT);
    }
}
#endif

d528 3
a530 42
#if FB_STIP_SHIFT != FB_SHIFT
    if (FB_STIP_ODDSTRIDE(srcStride) || FB_STIP_ODDPTR(src) ||
        FB_STIP_ODDSTRIDE(dstStride) || FB_STIP_ODDPTR(dst)) {
        FbStride srcStrideEven, srcStrideOdd;
        FbStride dstStrideEven, dstStrideOdd;
        int srcXEven, srcXOdd;
        int dstXEven, dstXOdd;
        FbBits *s, *d;
        int sx, dx;

        src += srcX >> FB_STIP_SHIFT;
        srcX &= FB_STIP_MASK;
        dst += dstX >> FB_STIP_SHIFT;
        dstX &= FB_STIP_MASK;

        fbSetBltOdd(src, srcStride, srcX,
                    &s, &srcStrideEven, &srcStrideOdd, &srcXEven, &srcXOdd);

        fbSetBltOdd(dst, dstStride, dstX,
                    &d, &dstStrideEven, &dstStrideOdd, &dstXEven, &dstXOdd);

        if (bpp == 24 && !FbCheck24Pix(pm)) {
            fbBltOdd24(s, srcStrideEven, srcStrideOdd,
                       srcXEven, srcXOdd,
                       d, dstStrideEven, dstStrideOdd,
                       dstXEven, dstXOdd, width, height, alu, pm);
        }
        else {
            fbBltOdd(s, srcStrideEven, srcStrideOdd,
                     srcXEven, srcXOdd,
                     d, dstStrideEven, dstStrideOdd,
                     dstXEven, dstXOdd, width, height, alu, pm, bpp);
        }
    }
    else
#endif
    {
        fbBlt((FbBits *) src, FbStipStrideToBitsStride(srcStride),
              srcX,
              (FbBits *) dst, FbStipStrideToBitsStride(dstStride),
              dstX, width, height, alu, pm, bpp, FALSE, FALSE);
    }
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a58 1
    int careful;
d62 33
a97 26
        return;
    }

    careful = !((srcLine < dstLine && srcLine + width * (bpp >> 3) > dstLine) ||
                (dstLine < srcLine && dstLine + width * (bpp >> 3) > srcLine))
        || (bpp & 7);

    if (alu == GXcopy && pm == FB_ALLONES && !careful &&
        !(srcX & 7) && !(dstX & 7) && !(width & 7)) {
        int i;
        CARD8 *tmpsrc = (CARD8 *) srcLine;
        CARD8 *tmpdst = (CARD8 *) dstLine;

        srcStride *= sizeof(FbBits);
        dstStride *= sizeof(FbBits);
        width >>= 3;
        tmpsrc += (srcX >> 3);
        tmpdst += (dstX >> 3);

        if (!upsidedown)
            for (i = 0; i < height; i++)
                MEMCPY_WRAPPED(tmpdst + i * dstStride, tmpsrc + i * srcStride, width);
        else
            for (i = height - 1; i >= 0; i--)
                MEMCPY_WRAPPED(tmpdst + i * dstStride, tmpsrc + i * srcStride, width);

@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d76 2
a77 2
        CARD8 *src = (CARD8 *) srcLine;
        CARD8 *dst = (CARD8 *) dstLine;
d82 2
a83 2
        src += (srcX >> 3);
        dst += (dstX >> 3);
d87 1
a87 1
                MEMCPY_WRAPPED(dst + i * dstStride, src + i * srcStride, width);
d90 1
a90 1
                MEMCPY_WRAPPED(dst + i * dstStride, src + i * srcStride, width);
@


1.3
log
@Update to xserver 1.11.2
@
text
@d43 8
a50 17
fbBlt (FbBits   *srcLine,
       FbStride	srcStride,
       int	srcX,
       
       FbBits   *dstLine,
       FbStride dstStride,
       int	dstX,
       
       int	width, 
       int	height,
       
       int	alu,
       FbBits	pm,
       int	bpp,
       
       Bool	reverse,
       Bool	upsidedown)
d52 15
a66 15
    FbBits  *src, *dst;
    int	    leftShift, rightShift;
    FbBits  startmask, endmask;
    FbBits  bits, bits1;
    int	    n, nmiddle;
    Bool    destInvarient;
    int	    startbyte, endbyte;
    int     careful;
    FbDeclareMergeRop ();

    if (bpp == 24 && !FbCheck24Pix (pm))
    {
	fbBlt24 (srcLine, srcStride, srcX, dstLine, dstStride, dstX,
		 width, height, alu, pm, reverse, upsidedown);
	return;
d69 3
a71 3
    careful = !((srcLine < dstLine && srcLine + width * (bpp>>3) > dstLine) ||
                (dstLine < srcLine && dstLine + width * (bpp>>3) > srcLine)) ||
              (bpp & 7);
d74 1
a74 1
            !(srcX & 7) && !(dstX & 7) && !(width & 7)) {
d97 58
a154 72
    if (upsidedown)
    {
	srcLine += (height - 1) * (srcStride);
	dstLine += (height - 1) * (dstStride);
	srcStride = -srcStride;
	dstStride = -dstStride;
    }
    FbMaskBitsBytes (dstX, width, destInvarient, startmask, startbyte,
		     nmiddle, endmask, endbyte);
    if (reverse)
    {
	srcLine += ((srcX + width - 1) >> FB_SHIFT) + 1;
	dstLine += ((dstX + width - 1) >> FB_SHIFT) + 1;
	srcX = (srcX + width - 1) & FB_MASK;
	dstX = (dstX + width - 1) & FB_MASK;
    }
    else
    {
	srcLine += srcX >> FB_SHIFT;
	dstLine += dstX >> FB_SHIFT;
	srcX &= FB_MASK;
	dstX &= FB_MASK;
    }
    if (srcX == dstX)
    {
	while (height--)
	{
	    src = srcLine;
	    srcLine += srcStride;
	    dst = dstLine;
	    dstLine += dstStride;
	    if (reverse)
	    {
		if (endmask)
		{
		    bits = READ(--src);
		    --dst;
		    FbDoRightMaskByteMergeRop(dst, bits, endbyte, endmask);
		}
		n = nmiddle;
		if (destInvarient)
		{
		    while (n--)
			WRITE(--dst, FbDoDestInvarientMergeRop(READ(--src)));
		}
		else
		{
		    while (n--)
		    {
			bits = READ(--src);
			--dst;
			WRITE(dst, FbDoMergeRop (bits, READ(dst)));
		    }
		}
		if (startmask)
		{
		    bits = READ(--src);
		    --dst;
		    FbDoLeftMaskByteMergeRop(dst, bits, startbyte, startmask);
		}
	    }
	    else
	    {
		if (startmask)
		{
		    bits = READ(src++);
		    FbDoLeftMaskByteMergeRop(dst, bits, startbyte, startmask);
		    dst++;
		}
		n = nmiddle;
		if (destInvarient)
		{
d156 136
a291 162
		    /*
		     * This provides some speedup on screen->screen blts
		     * over the PCI bus, usually about 10%.  But fb
		     * isn't usually used for this operation...
		     */
		    if (_ca2 + 1 == 0 && _cx2 == 0)
		    {
			FbBits	t1, t2, t3, t4;
			while (n >= 4)
			{
			    t1 = *src++;
			    t2 = *src++;
			    t3 = *src++;
			    t4 = *src++;
			    *dst++ = t1;
			    *dst++ = t2;
			    *dst++ = t3;
			    *dst++ = t4;
			    n -= 4;
			}
		    }
#endif
		    while (n--)
			WRITE(dst++, FbDoDestInvarientMergeRop(READ(src++)));
		}
		else
		{
		    while (n--)
		    {
			bits = READ(src++);
			WRITE(dst, FbDoMergeRop (bits, READ(dst)));
			dst++;
		    }
		}
		if (endmask)
		{
		    bits = READ(src);
		    FbDoRightMaskByteMergeRop(dst, bits, endbyte, endmask);
		}
	    }
	}
    }
    else
    {
	if (srcX > dstX)
	{
	    leftShift = srcX - dstX;
	    rightShift = FB_UNIT - leftShift;
	}
	else
	{
	    rightShift = dstX - srcX;
	    leftShift = FB_UNIT - rightShift;
	}
	while (height--)
	{
	    src = srcLine;
	    srcLine += srcStride;
	    dst = dstLine;
	    dstLine += dstStride;
	    
	    bits1 = 0;
	    if (reverse)
	    {
		if (srcX < dstX)
		    bits1 = READ(--src);
		if (endmask)
		{
		    bits = FbScrRight(bits1, rightShift); 
		    if (FbScrRight(endmask, leftShift))
		    {
			bits1 = READ(--src);
			bits |= FbScrLeft(bits1, leftShift);
		    }
		    --dst;
		    FbDoRightMaskByteMergeRop(dst, bits, endbyte, endmask);
		}
		n = nmiddle;
		if (destInvarient)
		{
		    while (n--)
		    {
			bits = FbScrRight(bits1, rightShift); 
			bits1 = READ(--src);
			bits |= FbScrLeft(bits1, leftShift);
			--dst;
			WRITE(dst, FbDoDestInvarientMergeRop(bits));
		    }
		}
		else
		{
		    while (n--)
		    {
			bits = FbScrRight(bits1, rightShift); 
			bits1 = READ(--src);
			bits |= FbScrLeft(bits1, leftShift);
			--dst;
			WRITE(dst, FbDoMergeRop(bits, READ(dst)));
		    }
		}
		if (startmask)
		{
		    bits = FbScrRight(bits1, rightShift); 
		    if (FbScrRight(startmask, leftShift))
		    {
			bits1 = READ(--src);
			bits |= FbScrLeft(bits1, leftShift);
		    }
		    --dst;
		    FbDoLeftMaskByteMergeRop (dst, bits, startbyte, startmask);
		}
	    }
	    else
	    {
		if (srcX > dstX)
		    bits1 = READ(src++);
		if (startmask)
		{
		    bits = FbScrLeft(bits1, leftShift); 
		    if (FbScrLeft(startmask, rightShift))
		    {
			bits1 = READ(src++);
			bits |= FbScrRight(bits1, rightShift);
		    }
		    FbDoLeftMaskByteMergeRop (dst, bits, startbyte, startmask);
		    dst++;
		}
		n = nmiddle;
		if (destInvarient)
		{
		    while (n--)
		    {
			bits = FbScrLeft(bits1, leftShift); 
			bits1 = READ(src++);
			bits |= FbScrRight(bits1, rightShift);
			WRITE(dst, FbDoDestInvarientMergeRop(bits));
			dst++;
		    }
		}
		else
		{
		    while (n--)
		    {
			bits = FbScrLeft(bits1, leftShift); 
			bits1 = READ(src++);
			bits |= FbScrRight(bits1, rightShift);
			WRITE(dst, FbDoMergeRop(bits, READ(dst)));
			dst++;
		    }
		}
		if (endmask)
		{
		    bits = FbScrLeft(bits1, leftShift); 
		    if (FbScrLeft(endmask, rightShift))
		    {
			bits1 = READ(src);
			bits |= FbScrRight(bits1, rightShift);
		    }
		    FbDoRightMaskByteMergeRop (dst, bits, endbyte, endmask);
		}
	    }
	}
a294 1

d299 1
a299 1
getPixel (char *src, int x)
d301 1
a301 1
    unsigned long   l;
d304 1
a304 1
    memcpy (&l, src + x * 3, 3);
d310 10
a319 2
fbBlt24Line (FbBits	    *src,
	     int	    srcX,
d321 3
a323 2
	     FbBits	    *dst,
	     int	    dstX,
d325 2
a326 1
	     int	    width,
d328 5
a332 23
	     int	    alu,
	     FbBits	    pm,
	 
	     Bool	    reverse)
{
#ifdef DEBUG_BLT24
    char    *origDst = (char *) dst;
    FbBits  *origLine = dst + ((dstX >> FB_SHIFT) - 1);
    int	    origNlw = ((width + FB_MASK) >> FB_SHIFT) + 3;
    int	    origX = dstX / 24;
#endif
    
    int	    leftShift, rightShift;
    FbBits  startmask, endmask;
    int	    n;
    
    FbBits  bits, bits1;
    FbBits  mask;

    int	    rot;
    FbDeclareMergeRop ();
    
    FbInitializeMergeRop (alu, FB_ALLONES);
d335 1
a335 1
    ErrorF ("dstX %d width %d reverse %d\n", dstX, width, reverse);
d337 5
a341 6
    if (reverse)
    {
	src += ((srcX + width - 1) >> FB_SHIFT) + 1;
	dst += ((dstX + width - 1) >> FB_SHIFT) + 1;
	rot = FbFirst24Rot (((dstX + width - 8) & FB_MASK));
	rot = FbPrev24Rot(rot);
d343 2
a344 1
	ErrorF ("dstX + width - 8: %d rot: %d\n", (dstX + width - 8) & FB_MASK, rot);
d346 2
a347 2
	srcX = (srcX + width - 1) & FB_MASK;
	dstX = (dstX + width - 1) & FB_MASK;
d349 6
a354 7
    else
    {
	src += srcX >> FB_SHIFT;
	dst += dstX >> FB_SHIFT;
	srcX &= FB_MASK;
	dstX &= FB_MASK;
	rot = FbFirst24Rot (dstX);
d356 1
a356 1
	ErrorF ("dstX: %d rot: %d\n", dstX, rot);
d359 1
a359 1
    mask = FbRot24(pm,rot);
d361 1
a361 1
    ErrorF ("pm 0x%x mask 0x%x\n", pm, mask);
d363 109
a471 132
    if (srcX == dstX)
    {
	if (reverse)
	{
	    if (endmask)
	    {
		bits = READ(--src);
		--dst;
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & endmask));
		mask = FbPrev24Pix (mask);
	    }
	    while (n--)
	    {
		bits = READ(--src);
		--dst;
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask));
		mask = FbPrev24Pix (mask);
	    }
	    if (startmask)
	    {
		bits = READ(--src);
		--dst;
		WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & startmask));
	    }
	}
	else
	{
	    if (startmask)
	    {
		bits = READ(src++);
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & startmask));
		dst++;
		mask = FbNext24Pix(mask);
	    }
	    while (n--)
	    {
		bits = READ(src++);
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask));
		dst++;
		mask = FbNext24Pix(mask);
	    }
	    if (endmask)
	    {
		bits = READ(src);
		WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & endmask));
	    }
	}
    }
    else
    {
	if (srcX > dstX)
	{
	    leftShift = srcX - dstX;
	    rightShift = FB_UNIT - leftShift;
	}
	else
	{
	    rightShift = dstX - srcX;
	    leftShift = FB_UNIT - rightShift;
	}
	
	bits1 = 0;
	if (reverse)
	{
	    if (srcX < dstX)
		bits1 = READ(--src);
	    if (endmask)
	    {
		bits = FbScrRight(bits1, rightShift); 
		if (FbScrRight(endmask, leftShift))
		{
		    bits1 = READ(--src);
		    bits |= FbScrLeft(bits1, leftShift);
		}
		--dst;
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & endmask));
		mask = FbPrev24Pix(mask);
	    }
	    while (n--)
	    {
		bits = FbScrRight(bits1, rightShift); 
		bits1 = READ(--src);
		bits |= FbScrLeft(bits1, leftShift);
		--dst;
		WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask));
		mask = FbPrev24Pix(mask);
	    }
	    if (startmask)
	    {
		bits = FbScrRight(bits1, rightShift); 
		if (FbScrRight(startmask, leftShift))
		{
		    bits1 = READ(--src);
		    bits |= FbScrLeft(bits1, leftShift);
		}
		--dst;
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & startmask));
	    }
	}
	else
	{
	    if (srcX > dstX)
		bits1 = READ(src++);
	    if (startmask)
	    {
		bits = FbScrLeft(bits1, leftShift); 
		bits1 = READ(src++);
		bits |= FbScrRight(bits1, rightShift);
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & startmask));
		dst++;
		mask = FbNext24Pix(mask);
	    }
	    while (n--)
	    {
		bits = FbScrLeft(bits1, leftShift); 
		bits1 = READ(src++);
		bits |= FbScrRight(bits1, rightShift);
		WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask));
		dst++;
		mask = FbNext24Pix(mask);
	    }
	    if (endmask)
	    {
		bits = FbScrLeft(bits1, leftShift); 
		if (FbScrLeft(endmask, rightShift))
		{
		    bits1 = READ(src);
		    bits |= FbScrRight(bits1, rightShift);
		}
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & endmask));
	    }
	}
d475 1
a475 1
	int firstx, lastx, x;
d477 10
a486 10
	firstx = origX;
	if (firstx)
	    firstx--;
	lastx = origX + width/24 + 1;
	for (x = firstx; x <= lastx; x++)
	    ErrorF ("%06x ", getPixel (origDst, x));
	ErrorF ("\n");
	while (origNlw--)
	    ErrorF ("%08x ", *origLine++);
	ErrorF ("\n");
d492 8
a499 16
fbBlt24 (FbBits	    *srcLine,
	 FbStride   srcStride,
	 int	    srcX,

	 FbBits	    *dstLine,
	 FbStride   dstStride,
	 int	    dstX,

	 int	    width, 
	 int	    height,

	 int	    alu,
	 FbBits	    pm,

	 Bool	    reverse,
	 Bool	    upsidedown)
d501 10
a510 12
    if (upsidedown)
    {
	srcLine += (height-1) * srcStride;
	dstLine += (height-1) * dstStride;
	srcStride = -srcStride;
	dstStride = -dstStride;
    }
    while (height--)
    {
	fbBlt24Line (srcLine, srcX, dstLine, dstX, width, alu, pm, reverse);
	srcLine += srcStride;
	dstLine += dstStride;
d513 1
a513 1
    ErrorF ("\n");
d525 10
a534 18
fbBltOdd (FbBits    *srcLine,
	  FbStride  srcStrideEven,
	  FbStride  srcStrideOdd,
	  int	    srcXEven,
	  int	    srcXOdd,

	  FbBits    *dstLine,
	  FbStride  dstStrideEven,
	  FbStride  dstStrideOdd,
	  int	    dstXEven,
	  int	    dstXOdd,

	  int	    width,
	  int	    height,

	  int	    alu,
	  FbBits    pm,
	  int	    bpp)
d536 21
a556 22
    FbBits  *src;
    int	    leftShiftEven, rightShiftEven;
    FbBits  startmaskEven, endmaskEven;
    int	    nmiddleEven;
    
    FbBits  *dst;
    int	    leftShiftOdd, rightShiftOdd;
    FbBits  startmaskOdd, endmaskOdd;
    int	    nmiddleOdd;

    int	    leftShift, rightShift;
    FbBits  startmask, endmask;
    int	    nmiddle;
    
    int	    srcX, dstX;
    
    FbBits  bits, bits1;
    int	    n;
    
    Bool    destInvarient;
    Bool    even;
    FbDeclareMergeRop ();
d558 3
a560 1
    FbInitializeMergeRop (alu, pm);
d572 1
a572 1
    
d576 92
a667 110
    while (height--)
    {
	src = srcLine;
	dst = dstLine;
	if (even)
	{
	    srcX = srcXEven;
	    dstX = dstXEven;
	    startmask = startmaskEven;
	    endmask = endmaskEven;
	    nmiddle = nmiddleEven;
	    leftShift = leftShiftEven;
	    rightShift = rightShiftEven;
	    srcLine += srcStrideEven;
	    dstLine += dstStrideEven;
	    even = FALSE;
	}
	else
	{
	    srcX = srcXOdd;
	    dstX = dstXOdd;
	    startmask = startmaskOdd;
	    endmask = endmaskOdd;
	    nmiddle = nmiddleOdd;
	    leftShift = leftShiftOdd;
	    rightShift = rightShiftOdd;
	    srcLine += srcStrideOdd;
	    dstLine += dstStrideOdd;
	    even = TRUE;
	}
	if (srcX == dstX)
	{
	    if (startmask)
	    {
		bits = READ(src++);
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), startmask));
		dst++;
	    }
	    n = nmiddle;
	    if (destInvarient)
	    {
		while (n--)
		{
		    bits = READ(src++);
		    WRITE(dst, FbDoDestInvarientMergeRop(bits));
		    dst++;
		}
	    }
	    else
	    {
		while (n--)
		{
		    bits = READ(src++);
		    WRITE(dst, FbDoMergeRop (bits, READ(dst)));
		    dst++;
		}
	    }
	    if (endmask)
	    {
		bits = READ(src);
		WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), endmask));
	    }
	}
	else
	{
	    bits = 0;
	    if (srcX > dstX)
		bits = READ(src++);
	    if (startmask)
	    {
		bits1 = FbScrLeft(bits, leftShift);
		bits = READ(src++);
		bits1 |= FbScrRight(bits, rightShift);
		WRITE(dst, FbDoMaskMergeRop (bits1, READ(dst), startmask));
		dst++;
	    }
	    n = nmiddle;
	    if (destInvarient)
	    {
		while (n--)
		{
		    bits1 = FbScrLeft(bits, leftShift);
		    bits = READ(src++);
		    bits1 |= FbScrRight(bits, rightShift);
		    WRITE(dst, FbDoDestInvarientMergeRop(bits1));
		    dst++;
		}
	    }
	    else
	    {
		while (n--)
		{
		    bits1 = FbScrLeft(bits, leftShift);
		    bits = READ(src++);
		    bits1 |= FbScrRight(bits, rightShift);
		    WRITE(dst, FbDoMergeRop(bits1, READ(dst)));
		    dst++;
		}
	    }
	    if (endmask)
	    {
		bits1 = FbScrLeft(bits, leftShift);
		if (FbScrLeft(endmask, rightShift))
		{
		    bits = READ(src);
		    bits1 |= FbScrRight(bits, rightShift);
		}
		WRITE(dst, FbDoMaskMergeRop (bits1, READ(dst), endmask));
	    }
	}
d672 11
a682 14
fbBltOdd24 (FbBits	*srcLine,
	    FbStride	srcStrideEven,
	    FbStride	srcStrideOdd,
	    int		srcXEven,
	    int		srcXOdd,

	    FbBits	*dstLine,
	    FbStride	dstStrideEven,
	    FbStride	dstStrideOdd,
	    int		dstXEven,
	    int		dstXOdd,

	    int		width,
	    int		height,
d684 15
a698 23
	    int		alu,
	    FbBits	pm)
{
    Bool    even = TRUE;
    
    while (height--)
    {
	if (even)
	{
	    fbBlt24Line (srcLine, srcXEven, dstLine, dstXEven,
			 width, alu, pm, FALSE);
	    srcLine += srcStrideEven;
	    dstLine += dstStrideEven;
	    even = FALSE;
	}
	else
	{
	    fbBlt24Line (srcLine, srcXOdd, dstLine, dstXOdd,
			 width, alu, pm, FALSE);
	    srcLine += srcStrideOdd;
	    dstLine += dstStrideOdd;
	    even = TRUE;
	}
d706 6
a711 8
fbSetBltOdd (FbStip	*stip,
	     FbStride	stipStride,
	     int	srcX,
	     FbBits	**bits,
	     FbStride	*strideEven,
	     FbStride	*strideOdd,
	     int	*srcXEven,
	     int	*srcXOdd)
d713 2
a714 2
    int	    srcAdjust;
    int	    strideAdjust;
d726 10
a735 4
    if (srcAdjust)
    {
	*strideEven = FbStipStrideToBitsStride (stipStride + 1);
	*strideOdd = FbStipStrideToBitsStride (stipStride);
d737 2
a738 10
	*srcXEven = srcX + (srcAdjust << 3);
	*srcXOdd = srcX + (srcAdjust << 3) - (strideAdjust << FB_STIP_SHIFT);
    }
    else
    {
	*strideEven = FbStipStrideToBitsStride (stipStride);
	*strideOdd = FbStipStrideToBitsStride (stipStride + 1);
	
	*srcXEven = srcX;
	*srcXOdd = srcX + (strideAdjust << FB_STIP_SHIFT);
d744 3
a746 14
fbBltStip (FbStip   *src,
	   FbStride srcStride,	    /* in FbStip units, not FbBits units */
	   int	    srcX,
	   
	   FbStip   *dst,
	   FbStride dstStride,	    /* in FbStip units, not FbBits units */
	   int	    dstX,

	   int	    width, 
	   int	    height,

	   int	    alu,
	   FbBits   pm,
	   int	    bpp)
d750 31
a780 44
	FB_STIP_ODDSTRIDE(dstStride) || FB_STIP_ODDPTR(dst))
    {
	FbStride    srcStrideEven, srcStrideOdd;
	FbStride    dstStrideEven, dstStrideOdd;
	int	    srcXEven, srcXOdd;
	int	    dstXEven, dstXOdd;
	FbBits	    *s, *d;
	int	    sx, dx;
	
	src += srcX >> FB_STIP_SHIFT;
	srcX &= FB_STIP_MASK;
	dst += dstX >> FB_STIP_SHIFT;
	dstX &= FB_STIP_MASK;
	
	fbSetBltOdd (src, srcStride, srcX,
		     &s,
		     &srcStrideEven, &srcStrideOdd,
		     &srcXEven, &srcXOdd);
		     
	fbSetBltOdd (dst, dstStride, dstX,
		     &d,
		     &dstStrideEven, &dstStrideOdd,
		     &dstXEven, &dstXOdd);
		     
	if (bpp == 24 && !FbCheck24Pix (pm))
	{
	    fbBltOdd24  (s, srcStrideEven, srcStrideOdd,
			 srcXEven, srcXOdd,

			 d, dstStrideEven, dstStrideOdd,
			 dstXEven, dstXOdd,

			 width, height, alu, pm);
	}
	else
	{
	    fbBltOdd (s, srcStrideEven, srcStrideOdd,
		      srcXEven, srcXOdd,
    
		      d, dstStrideEven, dstStrideOdd,
		      dstXEven, dstXOdd,
    
		      width, height, alu, pm, bpp);
	}
d785 4
a788 6
	fbBlt ((FbBits *) src, FbStipStrideToBitsStride (srcStride), 
	       srcX, 
	       (FbBits *) dst, FbStipStrideToBitsStride (dstStride), 
	       dstX, 
	       width, height,
	       alu, pm, bpp, FALSE, FALSE);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d68 1
a70 1
#ifdef FB_24BIT
a76 1
#endif
d78 5
a82 1
    if (alu == GXcopy && pm == FB_ALLONES && !reverse &&
d87 1
a87 1
        
a343 1
#ifdef FB_24BIT
a607 1
#endif /* FB_24BIT */
a787 1
#ifdef FB_24BIT
a828 1
#endif
a916 1
#ifdef FB_24BIT
a927 1
#endif
@


1.1
log
@Initial revision
@
text
@a1 2
 * Id: fbblt.c,v 1.1 1999/11/02 03:54:45 keithp Exp $
 *
d93 1
a93 1
                memcpy(dst + i * dstStride, src + i * srcStride, width);
d96 1
a96 1
                memcpy(dst + i * dstStride, src + i * srcStride, width);
d138 1
a138 1
		    bits = *--src;
d146 1
a146 1
			*--dst = FbDoDestInvarientMergeRop(*--src);
d152 1
a152 1
			bits = *--src;
d154 1
a154 1
			*dst = FbDoMergeRop (bits, *dst);
d159 1
a159 1
		    bits = *--src;
d168 1
a168 1
		    bits = *src++;
d199 1
a199 1
			*dst++ = FbDoDestInvarientMergeRop(*src++);
d205 2
a206 2
			bits = *src++;
			*dst = FbDoMergeRop (bits, *dst);
d212 1
a212 1
		    bits = *src;
d241 1
a241 1
		    bits1 = *--src;
d247 1
a247 1
			bits1 = *--src;
d259 1
a259 1
			bits1 = *--src;
d262 1
a262 1
			*dst = FbDoDestInvarientMergeRop(bits);
d270 1
a270 1
			bits1 = *--src;
d273 1
a273 1
			*dst = FbDoMergeRop(bits, *dst);
d281 1
a281 1
			bits1 = *--src;
d291 1
a291 1
		    bits1 = *src++;
d297 1
a297 1
			bits1 = *src++;
d309 1
a309 1
			bits1 = *src++;
d311 1
a311 1
			*dst = FbDoDestInvarientMergeRop(bits);
d320 1
a320 1
			bits1 = *src++;
d322 1
a322 1
			*dst = FbDoMergeRop(bits, *dst);
d331 1
a331 1
			bits1 = *src;
d426 1
a426 1
		bits = *--src;
d428 1
a428 1
		*dst = FbDoMaskMergeRop (bits, *dst, mask & endmask);
d433 1
a433 1
		bits = *--src;
d435 1
a435 1
		*dst = FbDoMaskMergeRop (bits, *dst, mask);
d440 1
a440 1
		bits = *--src;
d442 1
a442 1
		*dst = FbDoMaskMergeRop(bits, *dst, mask & startmask);
d449 2
a450 2
		bits = *src++;
		*dst = FbDoMaskMergeRop (bits, *dst, mask & startmask);
d456 2
a457 2
		bits = *src++;
		*dst = FbDoMaskMergeRop (bits, *dst, mask);
d463 2
a464 2
		bits = *src;
		*dst = FbDoMaskMergeRop(bits, *dst, mask & endmask);
d485 1
a485 1
		bits1 = *--src;
d491 1
a491 1
		    bits1 = *--src;
d495 1
a495 1
		*dst = FbDoMaskMergeRop (bits, *dst, mask & endmask);
d501 1
a501 1
		bits1 = *--src;
d504 1
a504 1
		*dst = FbDoMaskMergeRop(bits, *dst, mask);
d512 1
a512 1
		    bits1 = *--src;
d516 1
a516 1
		*dst = FbDoMaskMergeRop (bits, *dst, mask & startmask);
d522 1
a522 1
		bits1 = *src++;
d526 1
a526 1
		bits1 = *src++;
d528 1
a528 1
		*dst = FbDoMaskMergeRop (bits, *dst, mask & startmask);
d535 1
a535 1
		bits1 = *src++;
d537 1
a537 1
		*dst = FbDoMaskMergeRop(bits, *dst, mask);
d546 1
a546 1
		    bits1 = *src;
d549 1
a549 1
		*dst = FbDoMaskMergeRop (bits, *dst, mask & endmask);
d708 2
a709 2
		bits = *src++;
		*dst = FbDoMaskMergeRop (bits, *dst, startmask);
d717 2
a718 2
		    bits = *src++;
		    *dst = FbDoDestInvarientMergeRop(bits);
d726 2
a727 2
		    bits = *src++;
		    *dst = FbDoMergeRop (bits, *dst);
d733 2
a734 2
		bits = *src;
		*dst = FbDoMaskMergeRop(bits, *dst, endmask);
d741 1
a741 1
		bits = *src++;
d745 1
a745 1
		bits = *src++;
d747 1
a747 1
		*dst = FbDoMaskMergeRop (bits1, *dst, startmask);
d756 1
a756 1
		    bits = *src++;
d758 1
a758 1
		    *dst = FbDoDestInvarientMergeRop(bits1);
d767 1
a767 1
		    bits = *src++;
d769 1
a769 1
		    *dst = FbDoMergeRop(bits1, *dst);
d778 1
a778 1
		    bits = *src;
d781 1
a781 1
		*dst = FbDoMaskMergeRop (bits1, *dst, endmask);
a827 3
#if 0
    fprintf (stderr, "\n");
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d95 1
a95 1
                MEMCPY_WRAPPED(dst + i * dstStride, src + i * srcStride, width);
d98 1
a98 1
                MEMCPY_WRAPPED(dst + i * dstStride, src + i * srcStride, width);
d140 1
a140 1
		    bits = READ(--src);
d148 1
a148 1
			WRITE(--dst, FbDoDestInvarientMergeRop(READ(--src)));
d154 1
a154 1
			bits = READ(--src);
d156 1
a156 1
			WRITE(dst, FbDoMergeRop (bits, READ(dst)));
d161 1
a161 1
		    bits = READ(--src);
d170 1
a170 1
		    bits = READ(src++);
d201 1
a201 1
			WRITE(dst++, FbDoDestInvarientMergeRop(READ(src++)));
d207 2
a208 2
			bits = READ(src++);
			WRITE(dst, FbDoMergeRop (bits, READ(dst)));
d214 1
a214 1
		    bits = READ(src);
d243 1
a243 1
		    bits1 = READ(--src);
d249 1
a249 1
			bits1 = READ(--src);
d261 1
a261 1
			bits1 = READ(--src);
d264 1
a264 1
			WRITE(dst, FbDoDestInvarientMergeRop(bits));
d272 1
a272 1
			bits1 = READ(--src);
d275 1
a275 1
			WRITE(dst, FbDoMergeRop(bits, READ(dst)));
d283 1
a283 1
			bits1 = READ(--src);
d293 1
a293 1
		    bits1 = READ(src++);
d299 1
a299 1
			bits1 = READ(src++);
d311 1
a311 1
			bits1 = READ(src++);
d313 1
a313 1
			WRITE(dst, FbDoDestInvarientMergeRop(bits));
d322 1
a322 1
			bits1 = READ(src++);
d324 1
a324 1
			WRITE(dst, FbDoMergeRop(bits, READ(dst)));
d333 1
a333 1
			bits1 = READ(src);
d428 1
a428 1
		bits = READ(--src);
d430 1
a430 1
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & endmask));
d435 1
a435 1
		bits = READ(--src);
d437 1
a437 1
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask));
d442 1
a442 1
		bits = READ(--src);
d444 1
a444 1
		WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & startmask));
d451 2
a452 2
		bits = READ(src++);
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & startmask));
d458 2
a459 2
		bits = READ(src++);
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask));
d465 2
a466 2
		bits = READ(src);
		WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask & endmask));
d487 1
a487 1
		bits1 = READ(--src);
d493 1
a493 1
		    bits1 = READ(--src);
d497 1
a497 1
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & endmask));
d503 1
a503 1
		bits1 = READ(--src);
d506 1
a506 1
		WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask));
d514 1
a514 1
		    bits1 = READ(--src);
d518 1
a518 1
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & startmask));
d524 1
a524 1
		bits1 = READ(src++);
d528 1
a528 1
		bits1 = READ(src++);
d530 1
a530 1
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & startmask));
d537 1
a537 1
		bits1 = READ(src++);
d539 1
a539 1
		WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), mask));
d548 1
a548 1
		    bits1 = READ(src);
d551 1
a551 1
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), mask & endmask));
d710 2
a711 2
		bits = READ(src++);
		WRITE(dst, FbDoMaskMergeRop (bits, READ(dst), startmask));
d719 2
a720 2
		    bits = READ(src++);
		    WRITE(dst, FbDoDestInvarientMergeRop(bits));
d728 2
a729 2
		    bits = READ(src++);
		    WRITE(dst, FbDoMergeRop (bits, READ(dst)));
d735 2
a736 2
		bits = READ(src);
		WRITE(dst, FbDoMaskMergeRop(bits, READ(dst), endmask));
d743 1
a743 1
		bits = READ(src++);
d747 1
a747 1
		bits = READ(src++);
d749 1
a749 1
		WRITE(dst, FbDoMaskMergeRop (bits1, READ(dst), startmask));
d758 1
a758 1
		    bits = READ(src++);
d760 1
a760 1
		    WRITE(dst, FbDoDestInvarientMergeRop(bits1));
d769 1
a769 1
		    bits = READ(src++);
d771 1
a771 1
		    WRITE(dst, FbDoMergeRop(bits1, READ(dst)));
d780 1
a780 1
		    bits = READ(src);
d783 1
a783 1
		WRITE(dst, FbDoMaskMergeRop (bits1, READ(dst), endmask));
@

