head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.8
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.6
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.4
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.14
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.12
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	Te1daavkBLskZ8gc;

1.4
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.39;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright Â© 1998 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "fb.h"

static void
fbTile(FbBits * dst, FbStride dstStride, int dstX, int width, int height,
       FbBits * tile, FbStride tileStride, int tileWidth, int tileHeight,
       int alu, FbBits pm, int bpp, int xRot, int yRot)
{
    int tileX, tileY;
    int widthTmp;
    int h, w;
    int x, y;

    modulus(-yRot, tileHeight, tileY);
    y = 0;
    while (height) {
        h = tileHeight - tileY;
        if (h > height)
            h = height;
        height -= h;
        widthTmp = width;
        x = dstX;
        modulus(dstX - xRot, tileWidth, tileX);
        while (widthTmp) {
            w = tileWidth - tileX;
            if (w > widthTmp)
                w = widthTmp;
            widthTmp -= w;
            fbBlt(tile + tileY * tileStride,
                  tileStride,
                  tileX,
                  dst + y * dstStride,
                  dstStride, x, w, h, alu, pm, bpp, FALSE, FALSE);
            x += w;
            tileX = 0;
        }
        y += h;
        tileY = 0;
    }
}

static void
fbStipple(FbBits * dst, FbStride dstStride,
          int dstX, int dstBpp,
          int width, int height,
          FbStip * stip, FbStride stipStride,
          int stipWidth, int stipHeight,
          FbBits fgand, FbBits fgxor,
          FbBits bgand, FbBits bgxor,
          int xRot, int yRot)
{
    int stipX, stipY, sx;
    int widthTmp;
    int h, w;
    int x, y;

    modulus(-yRot, stipHeight, stipY);
    modulus(dstX / dstBpp - xRot, stipWidth, stipX);
    y = 0;
    while (height) {
        h = stipHeight - stipY;
        if (h > height)
            h = height;
        height -= h;
        widthTmp = width;
        x = dstX;
        sx = stipX;
        while (widthTmp) {
            w = (stipWidth - sx) * dstBpp;
            if (w > widthTmp)
                w = widthTmp;
            widthTmp -= w;
            fbBltOne(stip + stipY * stipStride,
                     stipStride,
                     sx,
                     dst + y * dstStride,
                     dstStride, x, dstBpp, w, h, fgand, fgxor, bgand, bgxor);
            x += w;
            sx = 0;
        }
        y += h;
        stipY = 0;
    }
}

void
fbFill(DrawablePtr pDrawable, GCPtr pGC, int x, int y, int width, int height)
{
    FbBits *dst;
    FbStride dstStride;
    int dstBpp;
    int dstXoff, dstYoff;
    FbGCPrivPtr pPriv = fbGetGCPrivate(pGC);

    fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);

    switch (pGC->fillStyle) {
    case FillSolid:
#ifndef FB_ACCESS_WRAPPER
        if (pPriv->and || !pixman_fill((uint32_t *) dst, dstStride, dstBpp,
                                       x + dstXoff, y + dstYoff,
                                       width, height, pPriv->xor))
#endif
            fbSolid(dst + (y + dstYoff) * dstStride,
                    dstStride,
                    (x + dstXoff) * dstBpp,
                    dstBpp, width * dstBpp, height, pPriv->and, pPriv->xor);
        break;
    case FillStippled:
    case FillOpaqueStippled:{
        PixmapPtr pStip = pGC->stipple;
        int stipWidth = pStip->drawable.width;
        int stipHeight = pStip->drawable.height;

        if (dstBpp == 1) {
            int alu;
            FbBits *stip;
            FbStride stipStride;
            int stipBpp;
            _X_UNUSED int stipXoff, stipYoff;

            if (pGC->fillStyle == FillStippled)
                alu = FbStipple1Rop(pGC->alu, pGC->fgPixel);
            else
                alu = FbOpaqueStipple1Rop(pGC->alu, pGC->fgPixel, pGC->bgPixel);
            fbGetDrawable(&pStip->drawable, stip, stipStride, stipBpp, stipXoff,
                          stipYoff);
            fbTile(dst + (y + dstYoff) * dstStride, dstStride, x + dstXoff,
                   width, height, stip, stipStride, stipWidth, stipHeight, alu,
                   pPriv->pm, dstBpp, (pGC->patOrg.x + pDrawable->x + dstXoff),
                   pGC->patOrg.y + pDrawable->y - y);
            fbFinishAccess(&pStip->drawable);
        }
        else {
            FbStip *stip;
            FbStride stipStride;
            int stipBpp;
            _X_UNUSED int stipXoff, stipYoff;
            FbBits fgand, fgxor, bgand, bgxor;

            fgand = pPriv->and;
            fgxor = pPriv->xor;
            if (pGC->fillStyle == FillStippled) {
                bgand = fbAnd(GXnoop, (FbBits) 0, FB_ALLONES);
                bgxor = fbXor(GXnoop, (FbBits) 0, FB_ALLONES);
            }
            else {
                bgand = pPriv->bgand;
                bgxor = pPriv->bgxor;
            }

            fbGetStipDrawable(&pStip->drawable, stip, stipStride, stipBpp,
                              stipXoff, stipYoff);
            fbStipple(dst + (y + dstYoff) * dstStride, dstStride,
                      (x + dstXoff) * dstBpp, dstBpp, width * dstBpp, height,
                      stip, stipStride, stipWidth, stipHeight,
                      fgand, fgxor, bgand, bgxor,
                      pGC->patOrg.x + pDrawable->x + dstXoff,
                      pGC->patOrg.y + pDrawable->y - y);
            fbFinishAccess(&pStip->drawable);
        }
        break;
    }
    case FillTiled:{
        PixmapPtr pTile = pGC->tile.pixmap;
        FbBits *tile;
        FbStride tileStride;
        int tileBpp;
        int tileWidth;
        int tileHeight;
        _X_UNUSED int tileXoff, tileYoff;

        fbGetDrawable(&pTile->drawable, tile, tileStride, tileBpp, tileXoff,
                      tileYoff);
        tileWidth = pTile->drawable.width;
        tileHeight = pTile->drawable.height;
        fbTile(dst + (y + dstYoff) * dstStride,
               dstStride,
               (x + dstXoff) * dstBpp,
               width * dstBpp, height,
               tile,
               tileStride,
               tileWidth * tileBpp,
               tileHeight,
               pGC->alu,
               pPriv->pm,
               dstBpp,
               (pGC->patOrg.x + pDrawable->x + dstXoff) * dstBpp,
               pGC->patOrg.y + pDrawable->y - y);
        fbFinishAccess(&pTile->drawable);
        break;
    }
    }
    fbValidateDrawable(pDrawable);
    fbFinishAccess(pDrawable);
}

void
fbSolidBoxClipped(DrawablePtr pDrawable,
                  RegionPtr pClip,
                  int x1, int y1, int x2, int y2, FbBits and, FbBits xor)
{
    FbBits *dst;
    FbStride dstStride;
    int dstBpp;
    int dstXoff, dstYoff;
    BoxPtr pbox;
    int nbox;
    int partX1, partX2, partY1, partY2;

    fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);

    for (nbox = RegionNumRects(pClip), pbox = RegionRects(pClip);
         nbox--; pbox++) {
        partX1 = pbox->x1;
        if (partX1 < x1)
            partX1 = x1;

        partX2 = pbox->x2;
        if (partX2 > x2)
            partX2 = x2;

        if (partX2 <= partX1)
            continue;

        partY1 = pbox->y1;
        if (partY1 < y1)
            partY1 = y1;

        partY2 = pbox->y2;
        if (partY2 > y2)
            partY2 = y2;

        if (partY2 <= partY1)
            continue;

#ifndef FB_ACCESS_WRAPPER
        if (and || !pixman_fill((uint32_t *) dst, dstStride, dstBpp,
                                partX1 + dstXoff, partY1 + dstYoff,
                                (partX2 - partX1), (partY2 - partY1), xor))
#endif
            fbSolid(dst + (partY1 + dstYoff) * dstStride,
                    dstStride,
                    (partX1 + dstXoff) * dstBpp,
                    dstBpp,
                    (partX2 - partX1) * dstBpp, (partY2 - partY1), and, xor);
    }
    fbFinishAccess(pDrawable);
}
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d29 82
d182 1
a182 1
                      pPriv->evenStipple, fgand, fgxor, bgand, bgxor,
@


1.3
log
@Update to xserver 1.11.2
@
text
@d30 1
a30 6
fbFill (DrawablePtr pDrawable,
	GCPtr	    pGC,
	int	    x,
	int	    y,
	int	    width,
	int	    height)
d32 7
a38 7
    FbBits	    *dst;
    FbStride	    dstStride;
    int		    dstBpp;
    int		    dstXoff, dstYoff;
    FbGCPrivPtr	    pPriv = fbGetGCPrivate(pGC);
    
    fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
d43 9
a51 12
	if (pPriv->and || !pixman_fill ((uint32_t *)dst, dstStride, dstBpp,
					x + dstXoff, y + dstYoff,
					width, height,
					pPriv->xor))
#endif	    
	    fbSolid (dst + (y + dstYoff) * dstStride, 
		     dstStride, 
		     (x + dstXoff) * dstBpp,
		     dstBpp,
		     width * dstBpp, height,
		     pPriv->and, pPriv->xor);
	break;
d53 53
a105 73
    case FillOpaqueStippled: {
	PixmapPtr   pStip = pGC->stipple;
	int	    stipWidth = pStip->drawable.width;
	int	    stipHeight = pStip->drawable.height;
	
	if (dstBpp == 1)
	{
	    int		alu;
	    FbBits	*stip;
	    FbStride    stipStride;
	    int		stipBpp;
	    _X_UNUSED int	stipXoff, stipYoff;

	    if (pGC->fillStyle == FillStippled)
		alu = FbStipple1Rop(pGC->alu,pGC->fgPixel);
	    else
		alu = FbOpaqueStipple1Rop(pGC->alu,pGC->fgPixel,pGC->bgPixel);
	    fbGetDrawable (&pStip->drawable, stip, stipStride, stipBpp, stipXoff, stipYoff);
	    fbTile (dst + (y + dstYoff) * dstStride,
		    dstStride,
		    x + dstXoff,
		    width, height,
		    stip,
		    stipStride,
		    stipWidth,
		    stipHeight,
		    alu,
		    pPriv->pm,
		    dstBpp,
		    
		    (pGC->patOrg.x + pDrawable->x + dstXoff),
		    pGC->patOrg.y + pDrawable->y - y);
	    fbFinishAccess (&pStip->drawable);
	}
	else
	{
	    FbStip	*stip;
	    FbStride    stipStride;
	    int		stipBpp;
	    _X_UNUSED int	stipXoff, stipYoff;
	    FbBits	fgand, fgxor, bgand, bgxor;

	    fgand = pPriv->and;
	    fgxor = pPriv->xor;
	    if (pGC->fillStyle == FillStippled)
	    {
		bgand = fbAnd(GXnoop,(FbBits) 0,FB_ALLONES);
		bgxor = fbXor(GXnoop,(FbBits) 0,FB_ALLONES);
	    }
	    else
	    {
		bgand = pPriv->bgand;
		bgxor = pPriv->bgxor;
	    }

	    fbGetStipDrawable (&pStip->drawable, stip, stipStride, stipBpp, stipXoff, stipYoff);
	    fbStipple (dst + (y + dstYoff) * dstStride, 
		       dstStride, 
		       (x + dstXoff) * dstBpp,
		       dstBpp,
		       width * dstBpp, height,
		       stip,
		       stipStride,
		       stipWidth,
		       stipHeight,
		       pPriv->evenStipple,
		       fgand, fgxor,
		       bgand, bgxor,
		       pGC->patOrg.x + pDrawable->x + dstXoff,
		       pGC->patOrg.y + pDrawable->y - y);
	    fbFinishAccess (&pStip->drawable);
	}
	break;
d107 28
a134 27
    case FillTiled: {
	PixmapPtr   pTile = pGC->tile.pixmap;
	FbBits	    *tile;
	FbStride    tileStride;
	int	    tileBpp;
	int	    tileWidth;
	int	    tileHeight;
	_X_UNUSED int	tileXoff, tileYoff;
	
	fbGetDrawable (&pTile->drawable, tile, tileStride, tileBpp, tileXoff, tileYoff);
	tileWidth = pTile->drawable.width;
	tileHeight = pTile->drawable.height;
	fbTile (dst + (y + dstYoff) * dstStride, 
		dstStride, 
		(x + dstXoff) * dstBpp, 
		width * dstBpp, height,
		tile,
		tileStride,
		tileWidth * tileBpp,
		tileHeight,
		pGC->alu,
		pPriv->pm,
		dstBpp,
		(pGC->patOrg.x + pDrawable->x + dstXoff) * dstBpp,
		pGC->patOrg.y + pDrawable->y - y);
	fbFinishAccess (&pTile->drawable);
	break;
d137 2
a138 2
    fbValidateDrawable (pDrawable);
    fbFinishAccess (pDrawable);
d142 3
a144 8
fbSolidBoxClipped (DrawablePtr	pDrawable,
		   RegionPtr	pClip,
		   int		x1,
		   int		y1,
		   int		x2,
		   int		y2,
		   FbBits	and,
		   FbBits	xor)
d146 9
a154 7
    FbBits	*dst;
    FbStride	dstStride;
    int		dstBpp;
    int		dstXoff, dstYoff;
    BoxPtr	pbox;
    int		nbox;
    int		partX1, partX2, partY1, partY2;
a155 2
    fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
    
d157 22
a178 24
	 nbox--; 
	 pbox++)
    {
	partX1 = pbox->x1;
	if (partX1 < x1)
	    partX1 = x1;
	
	partX2 = pbox->x2;
	if (partX2 > x2)
	    partX2 = x2;
	
	if (partX2 <= partX1)
	    continue;
	
	partY1 = pbox->y1;
	if (partY1 < y1)
	    partY1 = y1;
	
	partY2 = pbox->y2;
	if (partY2 > y2)
	    partY2 = y2;
	
	if (partY2 <= partY1)
	    continue;
d181 3
a183 4
	if (and || !pixman_fill ((uint32_t *)dst, dstStride, dstBpp,
				 partX1 + dstXoff, partY1 + dstYoff,
				 (partX2 - partX1), (partY2 - partY1),
				 xor))
d185 5
a189 8
	    fbSolid (dst + (partY1 + dstYoff) * dstStride,
		     dstStride,
		     (partX1 + dstXoff) * dstBpp,
		     dstBpp,
		     
		     (partX2 - partX1) * dstBpp,
		     (partY2 - partY1),
		     and, xor);
d191 1
a191 1
    fbFinishAccess (pDrawable);
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d72 1
a72 1
	    int		stipXoff, stipYoff; /* XXX assumed to be zero */
d100 1
a100 1
	    int		stipXoff, stipYoff; /* XXX assumed to be zero */
d142 1
a142 1
	int	    tileXoff, tileYoff; /* XXX assumed to be zero */
@


1.1
log
@Initial revision
@
text
@a1 2
 * Id: fbfill.c,v 1.1 1999/11/02 03:54:45 keithp Exp $
 *
a27 1
#include "fbmmx.h"
d47 5
a51 4
#ifdef USE_MMX
	if (!pPriv->and && fbHaveMMX())
	    if (fbSolidFillmmx (pDrawable, x, y, width, height, pPriv->xor))
		return;
d53 6
a58 6
	fbSolid (dst + (y + dstYoff) * dstStride, 
		 dstStride, 
		 (x + dstXoff) * dstBpp,
		 dstBpp,
		 width * dstBpp, height,
		 pPriv->and, pPriv->xor);
d93 1
d131 1
d160 1
d165 1
d188 1
a188 1
    for (nbox = REGION_NUM_RECTS(pClip), pbox = REGION_RECTS(pClip); 
d214 5
a218 9
#ifdef USE_MMX
	if (!and && fbHaveMMX())
	{
		if (fbSolidFillmmx (pDrawable,
		                    partX1, partY1,
				    (partX2 - partX1), (partY2 - partY1),
				    xor))
			return;
	}
d220 8
a227 8
	fbSolid (dst + (partY1 + dstYoff) * dstStride,
		 dstStride,
		 (partX1 + dstXoff) * dstBpp,
		 dstBpp,

		 (partX2 - partX1) * dstBpp,
		 (partY2 - partY1),
		 and, xor);
d229 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d30 1
d50 4
a53 5
#ifndef FB_ACCESS_WRAPPER
	if (pPriv->and || !pixman_fill ((uint32_t *)dst, dstStride, dstBpp,
					x + dstXoff, y + dstYoff,
					width, height,
					pPriv->xor))
d55 6
a60 6
	    fbSolid (dst + (y + dstYoff) * dstStride, 
		     dstStride, 
		     (x + dstXoff) * dstBpp,
		     dstBpp,
		     width * dstBpp, height,
		     pPriv->and, pPriv->xor);
a94 1
	    fbFinishAccess (&pStip->drawable);
a131 1
	    fbFinishAccess (&pStip->drawable);
a159 1
	fbFinishAccess (&pTile->drawable);
a163 1
    fbFinishAccess (pDrawable);
d212 9
a220 5
#ifndef FB_ACCESS_WRAPPER
	if (and || !pixman_fill ((uint32_t *)dst, dstStride, dstBpp,
				 partX1 + dstXoff, partY1 + dstYoff,
				 (partX2 - partX1), (partY2 - partY1),
				 xor))
d222 8
a229 8
	    fbSolid (dst + (partY1 + dstYoff) * dstStride,
		     dstStride,
		     (partX1 + dstXoff) * dstBpp,
		     dstBpp,
		     
		     (partX2 - partX1) * dstBpp,
		     (partY2 - partY1),
		     and, xor);
a230 1
    fbFinishAccess (pDrawable);
@

