head	1.4;
access;
symbols
	OPENBSD_6_0:1.4.0.18
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.16
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.14
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.12
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.35;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.35;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@/*
 * Copyright Â© 1998 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include "fb.h"

void
fbPutImage(DrawablePtr pDrawable,
           GCPtr pGC,
           int depth,
           int x, int y, int w, int h, int leftPad, int format, char *pImage)
{
    FbGCPrivPtr pPriv = fbGetGCPrivate(pGC);
    unsigned long i;
    FbStride srcStride;
    FbStip *src = (FbStip *) pImage;

    x += pDrawable->x;
    y += pDrawable->y;

    switch (format) {
    case XYBitmap:
        srcStride = BitmapBytePad(w + leftPad) / sizeof(FbStip);
        fbPutXYImage(pDrawable,
                     fbGetCompositeClip(pGC),
                     pPriv->fg,
                     pPriv->bg,
                     pPriv->pm,
                     pGC->alu, TRUE, x, y, w, h, src, srcStride, leftPad);
        break;
    case XYPixmap:
        srcStride = BitmapBytePad(w + leftPad) / sizeof(FbStip);
        for (i = (unsigned long) 1 << (pDrawable->depth - 1); i; i >>= 1) {
            if (i & pGC->planemask) {
                fbPutXYImage(pDrawable,
                             fbGetCompositeClip(pGC),
                             FB_ALLONES,
                             0,
                             fbReplicatePixel(i, pDrawable->bitsPerPixel),
                             pGC->alu,
                             TRUE, x, y, w, h, src, srcStride, leftPad);
                src += srcStride * h;
            }
        }
        break;
    case ZPixmap:
        if (pDrawable->bitsPerPixel != BitsPerPixel(pDrawable->depth)) {
            srcStride = PixmapBytePad(w, pDrawable->depth);
            fb24_32PutZImage(pDrawable,
                             fbGetCompositeClip(pGC),
                             pGC->alu,
                             (FbBits) pGC->planemask,
                             x, y, w, h, (CARD8 *) pImage, srcStride);
        }
        else {
            srcStride = PixmapBytePad(w, pDrawable->depth) / sizeof(FbStip);
            fbPutZImage(pDrawable,
                        fbGetCompositeClip(pGC),
                        pGC->alu, pPriv->pm, x, y, w, h, src, srcStride);
        }
    }
}

void
fbPutZImage(DrawablePtr pDrawable,
            RegionPtr pClip,
            int alu,
            FbBits pm,
            int x,
            int y, int width, int height, FbStip * src, FbStride srcStride)
{
    FbStip *dst;
    FbStride dstStride;
    int dstBpp;
    int dstXoff, dstYoff;
    int nbox;
    BoxPtr pbox;
    int x1, y1, x2, y2;

    fbGetStipDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);

    for (nbox = RegionNumRects(pClip),
         pbox = RegionRects(pClip); nbox--; pbox++) {
        x1 = x;
        y1 = y;
        x2 = x + width;
        y2 = y + height;
        if (x1 < pbox->x1)
            x1 = pbox->x1;
        if (y1 < pbox->y1)
            y1 = pbox->y1;
        if (x2 > pbox->x2)
            x2 = pbox->x2;
        if (y2 > pbox->y2)
            y2 = pbox->y2;
        if (x1 >= x2 || y1 >= y2)
            continue;
        fbBltStip(src + (y1 - y) * srcStride,
                  srcStride,
                  (x1 - x) * dstBpp,
                  dst + (y1 + dstYoff) * dstStride,
                  dstStride,
                  (x1 + dstXoff) * dstBpp,
                  (x2 - x1) * dstBpp, (y2 - y1), alu, pm, dstBpp);
    }

    fbFinishAccess(pDrawable);
}

void
fbPutXYImage(DrawablePtr pDrawable,
             RegionPtr pClip,
             FbBits fg,
             FbBits bg,
             FbBits pm,
             int alu,
             Bool opaque,
             int x,
             int y,
             int width, int height, FbStip * src, FbStride srcStride, int srcX)
{
    FbBits *dst;
    FbStride dstStride;
    int dstBpp;
    int dstXoff, dstYoff;
    int nbox;
    BoxPtr pbox;
    int x1, y1, x2, y2;
    FbBits fgand = 0, fgxor = 0, bgand = 0, bgxor = 0;

    fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);

    if (dstBpp == 1) {
        if (opaque)
            alu = FbOpaqueStipple1Rop(alu, fg, bg);
        else
            alu = FbStipple1Rop(alu, fg);
    }
    else {
        fgand = fbAnd(alu, fg, pm);
        fgxor = fbXor(alu, fg, pm);
        if (opaque) {
            bgand = fbAnd(alu, bg, pm);
            bgxor = fbXor(alu, bg, pm);
        }
        else {
            bgand = fbAnd(GXnoop, (FbBits) 0, FB_ALLONES);
            bgxor = fbXor(GXnoop, (FbBits) 0, FB_ALLONES);
        }
    }

    for (nbox = RegionNumRects(pClip),
         pbox = RegionRects(pClip); nbox--; pbox++) {
        x1 = x;
        y1 = y;
        x2 = x + width;
        y2 = y + height;
        if (x1 < pbox->x1)
            x1 = pbox->x1;
        if (y1 < pbox->y1)
            y1 = pbox->y1;
        if (x2 > pbox->x2)
            x2 = pbox->x2;
        if (y2 > pbox->y2)
            y2 = pbox->y2;
        if (x1 >= x2 || y1 >= y2)
            continue;
        if (dstBpp == 1) {
            fbBltStip(src + (y1 - y) * srcStride,
                      srcStride,
                      (x1 - x) + srcX,
                      (FbStip *) (dst + (y1 + dstYoff) * dstStride),
                      FbBitsStrideToStipStride(dstStride),
                      (x1 + dstXoff) * dstBpp,
                      (x2 - x1) * dstBpp, (y2 - y1), alu, pm, dstBpp);
        }
        else {
            fbBltOne(src + (y1 - y) * srcStride,
                     srcStride,
                     (x1 - x) + srcX,
                     dst + (y1 + dstYoff) * dstStride,
                     dstStride,
                     (x1 + dstXoff) * dstBpp,
                     dstBpp,
                     (x2 - x1) * dstBpp, (y2 - y1), fgand, fgxor, bgand, bgxor);
        }
    }

    fbFinishAccess(pDrawable);
}

void
fbGetImage(DrawablePtr pDrawable,
           int x,
           int y,
           int w, int h, unsigned int format, unsigned long planeMask, char *d)
{
    FbBits *src;
    FbStride srcStride;
    int srcBpp;
    int srcXoff, srcYoff;
    FbStip *dst;
    FbStride dstStride;

    /*
     * XFree86 DDX empties the root borderClip when the VT is
     * switched away; this checks for that case
     */
    if (!fbDrawableEnabled(pDrawable))
        return;

    if (format == ZPixmap &&
        pDrawable->bitsPerPixel != BitsPerPixel(pDrawable->depth)) {
        fb24_32GetImage(pDrawable, x, y, w, h, format, planeMask, d);
        return;
    }

    fbGetDrawable(pDrawable, src, srcStride, srcBpp, srcXoff, srcYoff);

    x += pDrawable->x;
    y += pDrawable->y;

    dst = (FbStip *) d;
    if (format == ZPixmap || srcBpp == 1) {
        FbBits pm;

        pm = fbReplicatePixel(planeMask, srcBpp);
        dstStride = PixmapBytePad(w, pDrawable->depth);
        if (pm != FB_ALLONES)
            memset(d, 0, dstStride * h);
        dstStride /= sizeof(FbStip);
        fbBltStip((FbStip *) (src + (y + srcYoff) * srcStride),
                  FbBitsStrideToStipStride(srcStride),
                  (x + srcXoff) * srcBpp,
                  dst, dstStride, 0, w * srcBpp, h, GXcopy, pm, srcBpp);
    }
    else {
        dstStride = BitmapBytePad(w) / sizeof(FbStip);
        fbBltPlane(src + (y + srcYoff) * srcStride,
                   srcStride,
                   (x + srcXoff) * srcBpp,
                   srcBpp,
                   dst,
                   dstStride,
                   0,
                   w * srcBpp, h,
                   fbAndStip(GXcopy, FB_STIP_ALLONES, FB_STIP_ALLONES),
                   fbXorStip(GXcopy, FB_STIP_ALLONES, FB_STIP_ALLONES),
                   fbAndStip(GXcopy, 0, FB_STIP_ALLONES),
                   fbXorStip(GXcopy, 0, FB_STIP_ALLONES), planeMask);
    }

    fbFinishAccess(pDrawable);
}
@


1.3
log
@Update to xserver 1.11.2
@
text
@d32 4
a35 10
fbPutImage (DrawablePtr	pDrawable,
	    GCPtr	pGC,
	    int		depth,
	    int		x,
	    int		y,
	    int		w,
	    int		h,
	    int		leftPad,
	    int		format,
	    char	*pImage)
d37 5
a41 5
    FbGCPrivPtr	    pPriv = fbGetGCPrivate(pGC);
    unsigned long   i;
    FbStride	    srcStride;
    FbStip	    *src = (FbStip *) pImage;
    
d44 2
a45 3
    
    switch (format)
    {
d47 8
a54 13
	srcStride = BitmapBytePad(w + leftPad) / sizeof (FbStip);
	fbPutXYImage (pDrawable,
		      fbGetCompositeClip(pGC),
		      pPriv->fg,
		      pPriv->bg,
		      pPriv->pm,
		      pGC->alu,
		      TRUE,
		      x, y, w, h,
		      src,
		      srcStride,
		      leftPad);
	break;
d56 14
a69 20
	srcStride = BitmapBytePad(w + leftPad) / sizeof (FbStip);
	for (i = (unsigned long)1 << (pDrawable->depth - 1); i; i >>= 1)
	{
	    if (i & pGC->planemask)
	    {
		fbPutXYImage (pDrawable,
			      fbGetCompositeClip(pGC),
			      FB_ALLONES,
			      0,
			      fbReplicatePixel (i, pDrawable->bitsPerPixel),
			      pGC->alu,
			      TRUE,
			      x, y, w, h,
			      src,
			      srcStride,
			      leftPad);
		src += srcStride * h;
	    }
	}
	break;
d71 14
a84 21
	if (pDrawable->bitsPerPixel != BitsPerPixel(pDrawable->depth))
	{
	    srcStride = PixmapBytePad(w, pDrawable->depth);
	    fb24_32PutZImage (pDrawable,
			      fbGetCompositeClip(pGC),
			      pGC->alu,
			      (FbBits) pGC->planemask,
			      x, y, w, h,
			      (CARD8 *) pImage,
			      srcStride);
	}
	else
	{
	    srcStride = PixmapBytePad(w, pDrawable->depth) / sizeof (FbStip);
	    fbPutZImage (pDrawable,
			 fbGetCompositeClip(pGC),
			 pGC->alu,
			 pPriv->pm,
			 x, y, w, h, 
			 src, srcStride);
	}
d89 6
a94 10
fbPutZImage (DrawablePtr	pDrawable,
	     RegionPtr		pClip,
	     int		alu,
	     FbBits		pm,
	     int		x,
	     int		y,
	     int		width,
	     int		height,
	     FbStip		*src,
	     FbStride		srcStride)
d96 33
a128 43
    FbStip	*dst;
    FbStride	dstStride;
    int		dstBpp;
    int		dstXoff, dstYoff;
    int		nbox;
    BoxPtr	pbox;
    int		x1, y1, x2, y2;

    fbGetStipDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);

    for (nbox = RegionNumRects (pClip),
	 pbox = RegionRects(pClip);
	 nbox--;
	 pbox++)
    {
	x1 = x;
	y1 = y;
	x2 = x + width;
	y2 = y + height;
	if (x1 < pbox->x1)
	    x1 = pbox->x1;
	if (y1 < pbox->y1)
	    y1 = pbox->y1;
	if (x2 > pbox->x2)
	    x2 = pbox->x2;
	if (y2 > pbox->y2)
	    y2 = pbox->y2;
	if (x1 >= x2 || y1 >= y2)
	    continue;
	fbBltStip (src + (y1 - y) * srcStride,
		   srcStride,
		   (x1 - x) * dstBpp,

		   dst + (y1 + dstYoff) * dstStride,
		   dstStride,
		   (x1 + dstXoff) * dstBpp,

		   (x2 - x1) * dstBpp,
		   (y2 - y1),

		   alu,
		   pm,
		   dstBpp);
d131 1
a131 1
    fbFinishAccess (pDrawable);
d133 1
a133 1
	     
d135 10
a144 16
fbPutXYImage (DrawablePtr	pDrawable,
	      RegionPtr		pClip,
	      FbBits		fg,
	      FbBits		bg,
	      FbBits		pm,
	      int		alu,
	      Bool		opaque,
	      
	      int		x,
	      int		y,
	      int		width,
	      int		height,

	      FbStip		*src,
	      FbStride		srcStride,
	      int		srcX)
d146 65
a210 86
    FbBits	*dst;
    FbStride	dstStride;
    int		dstBpp;
    int		dstXoff, dstYoff;
    int		nbox;
    BoxPtr	pbox;
    int		x1, y1, x2, y2;
    FbBits	fgand = 0, fgxor = 0, bgand = 0, bgxor = 0;

    fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);

    if (dstBpp == 1)
    {
	if (opaque)
	    alu = FbOpaqueStipple1Rop(alu,fg,bg);
	else
	    alu = FbStipple1Rop(alu,fg);
    }
    else
    {
	fgand = fbAnd(alu,fg,pm);
	fgxor = fbXor(alu,fg,pm);
	if (opaque)
	{
	    bgand = fbAnd(alu,bg,pm);
	    bgxor = fbXor(alu,bg,pm);
	}
	else
	{
	    bgand = fbAnd(GXnoop,(FbBits)0,FB_ALLONES);
	    bgxor = fbXor(GXnoop,(FbBits)0,FB_ALLONES);
	}
    }

    for (nbox = RegionNumRects (pClip),
	 pbox = RegionRects(pClip);
	 nbox--;
	 pbox++)
    {
	x1 = x;
	y1 = y;
	x2 = x + width;
	y2 = y + height;
	if (x1 < pbox->x1)
	    x1 = pbox->x1;
	if (y1 < pbox->y1)
	    y1 = pbox->y1;
	if (x2 > pbox->x2)
	    x2 = pbox->x2;
	if (y2 > pbox->y2)
	    y2 = pbox->y2;
	if (x1 >= x2 || y1 >= y2)
	    continue;
	if (dstBpp == 1)
	{
	    fbBltStip (src + (y1 - y) * srcStride,
		       srcStride,
		       (x1 - x) + srcX,

		       (FbStip *) (dst + (y1 + dstYoff) * dstStride),
		       FbBitsStrideToStipStride(dstStride),
		       (x1 + dstXoff) * dstBpp,

		       (x2 - x1) * dstBpp,
		       (y2 - y1),

		       alu,
		       pm,
		       dstBpp);
	}
	else
	{
	    fbBltOne (src + (y1 - y) * srcStride,
		      srcStride,
		      (x1 - x) + srcX,

		      dst + (y1 + dstYoff) * dstStride,
		      dstStride,
		      (x1 + dstXoff) * dstBpp,
		      dstBpp,

		      (x2 - x1) * dstBpp,
		      (y2 - y1),

		      fgand, fgxor, bgand, bgxor);
	}
d213 1
a213 1
    fbFinishAccess (pDrawable);
d217 4
a220 8
fbGetImage (DrawablePtr	    pDrawable,
	    int		    x,
	    int		    y,
	    int		    w,
	    int		    h,
	    unsigned int    format,
	    unsigned long   planeMask,
	    char	    *d)
d222 7
a228 7
    FbBits	    *src;
    FbStride	    srcStride;
    int		    srcBpp;
    int		    srcXoff, srcYoff;
    FbStip	    *dst;
    FbStride	    dstStride;
    
d234 2
a235 2
	return;
    
d237 3
a239 4
	pDrawable->bitsPerPixel != BitsPerPixel (pDrawable->depth))
    {
	fb24_32GetImage (pDrawable, x, y, w, h, format, planeMask, d);
	return;
d241 3
a243 3
    
    fbGetDrawable (pDrawable, src, srcStride, srcBpp, srcXoff, srcYoff);
    
d246 1
a246 1
    
d248 27
a274 42
    if (format == ZPixmap || srcBpp == 1)
    {
	FbBits	pm;

	pm = fbReplicatePixel (planeMask, srcBpp);
	dstStride = PixmapBytePad(w, pDrawable->depth);
	if (pm != FB_ALLONES)
	    memset (d, 0, dstStride * h);
	dstStride /= sizeof (FbStip);
	fbBltStip ((FbStip *) (src + (y + srcYoff) * srcStride), 
		   FbBitsStrideToStipStride(srcStride),
		   (x + srcXoff) * srcBpp,
		   
		   dst,
		   dstStride,
		   0,
		   
		   w * srcBpp, h,

		   GXcopy,
		   pm,
		   srcBpp);
    }
    else
    {
	dstStride = BitmapBytePad(w) / sizeof (FbStip);
	fbBltPlane (src + (y + srcYoff) * srcStride,
		    srcStride, 
		    (x + srcXoff) * srcBpp,
		    srcBpp,

		    dst,
		    dstStride,
		    0,
		    
		    w * srcBpp, h,

		    fbAndStip(GXcopy,FB_STIP_ALLONES,FB_STIP_ALLONES),
		    fbXorStip(GXcopy,FB_STIP_ALLONES,FB_STIP_ALLONES),
		    fbAndStip(GXcopy,0,FB_STIP_ALLONES),
		    fbXorStip(GXcopy,0,FB_STIP_ALLONES),
		    planeMask);
d277 1
a277 1
    fbFinishAccess (pDrawable);
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a88 1
#ifdef FB_24_32BIT
a100 1
#endif
a305 1
#ifdef FB_24_32BIT
a311 1
#endif
@


1.1
log
@Initial revision
@
text
@a1 2
 * Id: fbimage.c,v 1.1 1999/11/02 03:54:45 keithp Exp $
 *
d137 2
a138 2
    for (nbox = REGION_NUM_RECTS (pClip),
	 pbox = REGION_RECTS(pClip);
d171 2
d227 2
a228 2
    for (nbox = REGION_NUM_RECTS (pClip),
	 pbox = REGION_RECTS(pClip);
d280 2
d366 2
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
a172 2

    fbFinishAccess (pDrawable);
a279 2

    fbFinishAccess (pDrawable);
a363 2

    fbFinishAccess (pDrawable);
@

