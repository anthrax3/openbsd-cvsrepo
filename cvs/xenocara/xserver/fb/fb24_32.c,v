head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.8
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.6
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.41;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.29;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright Â© 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include "fb.h"

/* X apps don't like 24bpp images, this code exposes 32bpp images */

/*
 * These two functions do a full CopyArea while reformatting
 * the data between 24 and 32bpp.  They try to go a bit faster
 * by reading/writing aligned CARD32s where it's easy
 */

#define Get8(a)	((CARD32) READ(a))

#if BITMAP_BIT_ORDER == MSBFirst
#define Get24(a)    ((Get8(a) << 16) | (Get8((a)+1) << 8) | Get8((a)+2))
#define Put24(a,p)  ((WRITE((a+0), (CARD8) ((p) >> 16))), \
		     (WRITE((a+1), (CARD8) ((p) >> 8))), \
		     (WRITE((a+2), (CARD8) (p))))
#else
#define Get24(a)    (Get8(a) | (Get8((a)+1) << 8) | (Get8((a)+2)<<16))
#define Put24(a,p)  ((WRITE((a+0), (CARD8) (p))), \
		     (WRITE((a+1), (CARD8) ((p) >> 8))), \
		     (WRITE((a+2), (CARD8) ((p) >> 16))))
#endif

typedef void (*fb24_32BltFunc) (CARD8 *srcLine,
                                FbStride srcStride,
                                int srcX,
                                CARD8 *dstLine,
                                FbStride dstStride,
                                int dstX,
                                int width, int height, int alu, FbBits pm);

static void
fb24_32BltDown(CARD8 *srcLine,
               FbStride srcStride,
               int srcX,
               CARD8 *dstLine,
               FbStride dstStride,
               int dstX, int width, int height, int alu, FbBits pm)
{
    CARD32 *src;
    CARD8 *dst;
    int w;
    Bool destInvarient;
    CARD32 pixel, dpixel;

    FbDeclareMergeRop();

    srcLine += srcX * 4;
    dstLine += dstX * 3;

    FbInitializeMergeRop(alu, (pm | ~(FbBits) 0xffffff));
    destInvarient = FbDestInvarientMergeRop();

    while (height--) {
        src = (CARD32 *) srcLine;
        dst = dstLine;
        srcLine += srcStride;
        dstLine += dstStride;
        w = width;
        if (destInvarient) {
            while (((long) dst & 3) && w) {
                w--;
                pixel = READ(src++);
                pixel = FbDoDestInvarientMergeRop(pixel);
                Put24(dst, pixel);
                dst += 3;
            }
            /* Do four aligned pixels at a time */
            while (w >= 4) {
                CARD32 s0, s1;

                s0 = READ(src++);
                s0 = FbDoDestInvarientMergeRop(s0);
                s1 = READ(src++);
                s1 = FbDoDestInvarientMergeRop(s1);
#if BITMAP_BIT_ORDER == LSBFirst
                WRITE((CARD32 *) dst, (s0 & 0xffffff) | (s1 << 24));
#else
                WRITE((CARD32 *) dst, (s0 << 8) | ((s1 & 0xffffff) >> 16));
#endif
                s0 = READ(src++);
                s0 = FbDoDestInvarientMergeRop(s0);
#if BITMAP_BIT_ORDER == LSBFirst
                WRITE((CARD32 *) (dst + 4),
                      ((s1 & 0xffffff) >> 8) | (s0 << 16));
#else
                WRITE((CARD32 *) (dst + 4),
                      (s1 << 16) | ((s0 & 0xffffff) >> 8));
#endif
                s1 = READ(src++);
                s1 = FbDoDestInvarientMergeRop(s1);
#if BITMAP_BIT_ORDER == LSBFirst
                WRITE((CARD32 *) (dst + 8),
                      ((s0 & 0xffffff) >> 16) | (s1 << 8));
#else
                WRITE((CARD32 *) (dst + 8), (s0 << 24) | (s1 & 0xffffff));
#endif
                dst += 12;
                w -= 4;
            }
            while (w--) {
                pixel = READ(src++);
                pixel = FbDoDestInvarientMergeRop(pixel);
                Put24(dst, pixel);
                dst += 3;
            }
        }
        else {
            while (w--) {
                pixel = READ(src++);
                dpixel = Get24(dst);
                pixel = FbDoMergeRop(pixel, dpixel);
                Put24(dst, pixel);
                dst += 3;
            }
        }
    }
}

static void
fb24_32BltUp(CARD8 *srcLine,
             FbStride srcStride,
             int srcX,
             CARD8 *dstLine,
             FbStride dstStride,
             int dstX, int width, int height, int alu, FbBits pm)
{
    CARD8 *src;
    CARD32 *dst;
    int w;
    Bool destInvarient;
    CARD32 pixel;

    FbDeclareMergeRop();

    FbInitializeMergeRop(alu, (pm | (~(FbBits) 0xffffff)));
    destInvarient = FbDestInvarientMergeRop();

    srcLine += srcX * 3;
    dstLine += dstX * 4;

    while (height--) {
        w = width;
        src = srcLine;
        dst = (CARD32 *) dstLine;
        srcLine += srcStride;
        dstLine += dstStride;
        if (destInvarient) {
            while (((long) src & 3) && w) {
                w--;
                pixel = Get24(src);
                src += 3;
                WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
            }
            /* Do four aligned pixels at a time */
            while (w >= 4) {
                CARD32 s0, s1;

                s0 = READ((CARD32 *) src);
#if BITMAP_BIT_ORDER == LSBFirst
                pixel = s0 & 0xffffff;
#else
                pixel = s0 >> 8;
#endif
                WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
                s1 = READ((CARD32 *) (src + 4));
#if BITMAP_BIT_ORDER == LSBFirst
                pixel = (s0 >> 24) | ((s1 << 8) & 0xffffff);
#else
                pixel = ((s0 << 16) & 0xffffff) | (s1 >> 16);
#endif
                WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
                s0 = READ((CARD32 *) (src + 8));
#if BITMAP_BIT_ORDER == LSBFirst
                pixel = (s1 >> 16) | ((s0 << 16) & 0xffffff);
#else
                pixel = ((s1 << 8) & 0xffffff) | (s0 >> 24);
#endif
                WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
#if BITMAP_BIT_ORDER == LSBFirst
                pixel = s0 >> 8;
#else
                pixel = s0 & 0xffffff;
#endif
                WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
                src += 12;
                w -= 4;
            }
            while (w) {
                w--;
                pixel = Get24(src);
                src += 3;
                WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
            }
        }
        else {
            while (w--) {
                pixel = Get24(src);
                src += 3;
                WRITE(dst, FbDoMergeRop(pixel, READ(dst)));
                dst++;
            }
        }
    }
}

/*
 * Spans functions; probably unused.
 */
void
fb24_32GetSpans(DrawablePtr pDrawable,
                int wMax,
                DDXPointPtr ppt, int *pwidth, int nspans, char *pchardstStart)
{
    FbBits *srcBits;
    CARD8 *src;
    FbStride srcStride;
    int srcBpp;
    int srcXoff, srcYoff;
    CARD8 *dst;

    fbGetDrawable(pDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);
    src = (CARD8 *) srcBits;
    srcStride *= sizeof(FbBits);

    while (nspans--) {
        dst = (CARD8 *) pchardstStart;
        fb24_32BltUp(src + (ppt->y + srcYoff) * srcStride, srcStride,
                     ppt->x + srcXoff,
                     dst, 1, 0, *pwidth, 1, GXcopy, FB_ALLONES);

        pchardstStart += PixmapBytePad(*pwidth, pDrawable->depth);
        ppt++;
        pwidth++;
    }

    fbFinishAccess(pDrawable);
}

void
fb24_32SetSpans(DrawablePtr pDrawable,
                GCPtr pGC,
                char *src,
                DDXPointPtr ppt, int *pwidth, int nspans, int fSorted)
{
    FbGCPrivPtr pPriv = fbGetGCPrivate(pGC);
    RegionPtr pClip = fbGetCompositeClip(pGC);
    FbBits *dstBits;
    CARD8 *dst, *d, *s;
    FbStride dstStride;
    int dstBpp;
    int dstXoff, dstYoff;
    BoxPtr pbox;
    int n;
    int x1, x2;

    fbGetDrawable(pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);
    dst = (CARD8 *) dstBits;
    dstStride *= sizeof(FbBits);
    while (nspans--) {
        d = dst + (ppt->y + dstYoff) * dstStride;
        s = (CARD8 *) src;
        n = RegionNumRects(pClip);
        pbox = RegionRects(pClip);
        while (n--) {
            if (pbox->y1 > ppt->y)
                break;
            if (pbox->y2 > ppt->y) {
                x1 = ppt->x;
                x2 = x1 + *pwidth;
                if (pbox->x1 > x1)
                    x1 = pbox->x1;
                if (pbox->x2 < x2)
                    x2 = pbox->x2;
                if (x1 < x2)
                    fb24_32BltDown(s,
                                   0,
                                   (x1 - ppt->x),
                                   d,
                                   dstStride,
                                   x1 + dstXoff,
                                   (x2 - x1), 1, pGC->alu, pPriv->pm);
            }
        }
        src += PixmapBytePad(*pwidth, pDrawable->depth);
        ppt++;
        pwidth++;
    }

    fbFinishAccess(pDrawable);
}

/*
 * Clip and put 32bpp Z-format images to a 24bpp drawable
 */
void
fb24_32PutZImage(DrawablePtr pDrawable,
                 RegionPtr pClip,
                 int alu,
                 FbBits pm,
                 int x,
                 int y, int width, int height, CARD8 *src, FbStride srcStride)
{
    FbBits *dstBits;
    CARD8 *dst;
    FbStride dstStride;
    int dstBpp;
    int dstXoff, dstYoff;
    int nbox;
    BoxPtr pbox;
    int x1, y1, x2, y2;

    fbGetDrawable(pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);
    dstStride *= sizeof(FbBits);
    dst = (CARD8 *) dstBits;

    for (nbox = RegionNumRects(pClip),
         pbox = RegionRects(pClip); nbox--; pbox++) {
        x1 = x;
        y1 = y;
        x2 = x + width;
        y2 = y + height;
        if (x1 < pbox->x1)
            x1 = pbox->x1;
        if (y1 < pbox->y1)
            y1 = pbox->y1;
        if (x2 > pbox->x2)
            x2 = pbox->x2;
        if (y2 > pbox->y2)
            y2 = pbox->y2;
        if (x1 >= x2 || y1 >= y2)
            continue;
        fb24_32BltDown(src + (y1 - y) * srcStride,
                       srcStride,
                       (x1 - x),
                       dst + (y1 + dstYoff) * dstStride,
                       dstStride, x1 + dstXoff, (x2 - x1), (y2 - y1), alu, pm);
    }

    fbFinishAccess(pDrawable);
}

void
fb24_32GetImage(DrawablePtr pDrawable,
                int x,
                int y,
                int w,
                int h, unsigned int format, unsigned long planeMask, char *d)
{
    FbBits *srcBits;
    CARD8 *src;
    FbStride srcStride;
    int srcBpp;
    int srcXoff, srcYoff;
    FbStride dstStride;
    FbBits pm;

    fbGetDrawable(pDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);
    src = (CARD8 *) srcBits;
    srcStride *= sizeof(FbBits);

    x += pDrawable->x;
    y += pDrawable->y;

    pm = fbReplicatePixel(planeMask, 32);
    dstStride = PixmapBytePad(w, pDrawable->depth);
    if (pm != FB_ALLONES)
        memset(d, 0, dstStride * h);
    fb24_32BltUp(src + (y + srcYoff) * srcStride, srcStride, x + srcXoff,
                 (CARD8 *) d, dstStride, 0, w, h, GXcopy, pm);

    fbFinishAccess(pDrawable);
}

void
fb24_32CopyMtoN(DrawablePtr pSrcDrawable,
                DrawablePtr pDstDrawable,
                GCPtr pGC,
                BoxPtr pbox,
                int nbox,
                int dx,
                int dy,
                Bool reverse, Bool upsidedown, Pixel bitplane, void *closure)
{
    FbGCPrivPtr pPriv = fbGetGCPrivate(pGC);
    FbBits *srcBits;
    CARD8 *src;
    FbStride srcStride;
    int srcBpp;
    FbBits *dstBits;
    CARD8 *dst;
    FbStride dstStride;
    int dstBpp;
    fb24_32BltFunc blt;
    int srcXoff, srcYoff;
    int dstXoff, dstYoff;

    fbGetDrawable(pSrcDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);
    src = (CARD8 *) srcBits;
    srcStride *= sizeof(FbBits);
    fbGetDrawable(pDstDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);
    dst = (CARD8 *) dstBits;
    dstStride *= sizeof(FbBits);
    if (srcBpp == 24)
        blt = fb24_32BltUp;
    else
        blt = fb24_32BltDown;

    while (nbox--) {
        (*blt) (src + (pbox->y1 + dy + srcYoff) * srcStride,
                srcStride,
                (pbox->x1 + dx + srcXoff),
                dst + (pbox->y1 + dstYoff) * dstStride,
                dstStride,
                (pbox->x1 + dstXoff),
                (pbox->x2 - pbox->x1),
                (pbox->y2 - pbox->y1), pGC->alu, pPriv->pm);
        pbox++;
    }

    fbFinishAccess(pSrcDrawable);
    fbFinishAccess(pDstDrawable);
}

PixmapPtr
fb24_32ReformatTile(PixmapPtr pOldTile, int bitsPerPixel)
{
    ScreenPtr pScreen = pOldTile->drawable.pScreen;
    PixmapPtr pNewTile;
    FbBits *old, *new;
    FbStride oldStride, newStride;
    int oldBpp, newBpp;
    fb24_32BltFunc blt;
    _X_UNUSED int oldXoff, oldYoff;
    _X_UNUSED int newXoff, newYoff;

    pNewTile = pScreen->CreatePixmap(pScreen, pOldTile->drawable.width,
                                     pOldTile->drawable.height,
                                     pOldTile->drawable.depth,
                                     pOldTile->usage_hint);
    if (!pNewTile)
        return 0;
    fbGetDrawable(&pOldTile->drawable,
                  old, oldStride, oldBpp, oldXoff, oldYoff);
    fbGetDrawable(&pNewTile->drawable,
                  new, newStride, newBpp, newXoff, newYoff);
    if (oldBpp == 24)
        blt = fb24_32BltUp;
    else
        blt = fb24_32BltDown;

    (*blt) ((CARD8 *) old,
            oldStride * sizeof(FbBits),
            0,
            (CARD8 *) new,
            newStride * sizeof(FbBits),
            0,
            pOldTile->drawable.width,
            pOldTile->drawable.height, GXcopy, FB_ALLONES);

    fbFinishAccess(&pOldTile->drawable);
    fbFinishAccess(&pNewTile->drawable);

    return pNewTile;
}

typedef struct {
    void *pbits;
    int width;
} miScreenInitParmsRec, *miScreenInitParmsPtr;

Bool
fb24_32CreateScreenResources(ScreenPtr pScreen)
{
    miScreenInitParmsPtr pScrInitParms;
    int pitch;
    Bool retval;

    /* get the pitch before mi destroys it */
    pScrInitParms = (miScreenInitParmsPtr) pScreen->devPrivate;
    pitch = BitmapBytePad(pScrInitParms->width * 24);

    if ((retval = miCreateScreenResources(pScreen))) {
        /* fix the screen pixmap */
        PixmapPtr pPix = (PixmapPtr) pScreen->devPrivate;

        pPix->drawable.bitsPerPixel = 24;
        pPix->devKind = pitch;
    }

    return retval;
}

Bool
fb24_32ModifyPixmapHeader(PixmapPtr pPixmap,
                          int width,
                          int height,
                          int depth,
                          int bitsPerPixel, int devKind, void *pPixData)
{
    int bpp, w;

    if (!pPixmap)
        return FALSE;
    bpp = bitsPerPixel;
    if (bpp <= 0)
        bpp = pPixmap->drawable.bitsPerPixel;
    if (bpp == 24) {
        if (devKind < 0) {
            w = width;
            if (w <= 0)
                w = pPixmap->drawable.width;
            devKind = BitmapBytePad(w * 24);
        }
    }
    return miModifyPixmapHeader(pPixmap, width, height, depth, bitsPerPixel,
                                devKind, pPixData);
}
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d18 1
a18 1
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d498 1
a498 1
    pointer pbits;
d529 1
a529 1
                          int bitsPerPixel, int devKind, pointer pPixData)
@


1.4
log
@Update to xserver 1.11.2
@
text
@d54 7
a60 13
typedef void (*fb24_32BltFunc) (CARD8	    *srcLine,
				FbStride    srcStride,
				int	    srcX,

				CARD8	    *dstLine,
				FbStride    dstStride,
				int	    dstX,

				int	    width, 
				int	    height,

				int	    alu,
				FbBits	    pm);
d63 12
a74 7
fb24_32BltDown (CARD8	    *srcLine,
		FbStride    srcStride,
		int	    srcX,

		CARD8	    *dstLine,
		FbStride    dstStride,
		int	    dstX,
d76 1
a76 2
		int	    width, 
		int	    height,
a77 10
		int	    alu,
		FbBits	    pm)
{
    CARD32  *src;
    CARD8   *dst;
    int	    w;
    Bool    destInvarient;
    CARD32  pixel, dpixel;
    FbDeclareMergeRop ();
    
d84 22
a105 25
    while (height--)
    {
	src = (CARD32 *) srcLine;
	dst = dstLine;
	srcLine += srcStride;
	dstLine += dstStride;
	w = width;
	if (destInvarient)
	{
	    while (((long) dst & 3) && w)
	    {
		w--;
		pixel = READ(src++);
		pixel = FbDoDestInvarientMergeRop(pixel);
		Put24 (dst, pixel);
		dst += 3;
	    }
	    /* Do four aligned pixels at a time */
	    while (w >= 4)
	    {
		CARD32  s0, s1;
		s0 = READ(src++);
		s0 = FbDoDestInvarientMergeRop(s0);
		s1 = READ(src++);
		s1 = FbDoDestInvarientMergeRop(s1);
d107 1
a107 1
		WRITE((CARD32 *)dst, (s0 & 0xffffff) | (s1 << 24));
d109 1
a109 1
		WRITE((CARD32 *)dst, (s0 << 8) | ((s1 & 0xffffff) >> 16));
d111 2
a112 2
		s0 = READ(src++);
		s0 = FbDoDestInvarientMergeRop(s0);
d114 2
a115 1
		WRITE((CARD32 *)(dst+4), ((s1 & 0xffffff) >> 8) | (s0 << 16));
d117 2
a118 1
		WRITE((CARD32 *)(dst+4), (s1 << 16) | ((s0 & 0xffffff) >> 8));
d120 2
a121 2
		s1 = READ(src++);
		s1 = FbDoDestInvarientMergeRop(s1);
d123 2
a124 1
		WRITE((CARD32 *)(dst+8), ((s0 & 0xffffff) >> 16) | (s1 << 8));
d126 1
a126 1
		WRITE((CARD32 *)(dst+8), (s0 << 24) | (s1 & 0xffffff));
d128 19
a146 22
		dst += 12;
		w -= 4;
	    }
	    while (w--)
	    {
		pixel = READ(src++);
		pixel = FbDoDestInvarientMergeRop(pixel);
		Put24 (dst, pixel);
		dst += 3;
	    }
	}
	else
	{
	    while (w--)
	    {
		pixel = READ(src++);
		dpixel = Get24 (dst);
		pixel = FbDoMergeRop(pixel, dpixel);
		Put24 (dst, pixel);
		dst += 3;
	    }
	}
d151 12
a162 7
fb24_32BltUp (CARD8	    *srcLine,
	      FbStride	    srcStride,
	      int	    srcX,

	      CARD8	    *dstLine,
	      FbStride	    dstStride,
	      int	    dstX,
d164 1
a164 2
	      int	    width, 
	      int	    height,
a165 10
	      int	    alu,
	      FbBits	    pm)
{
    CARD8   *src;
    CARD32  *dst;
    int	    w;
    Bool    destInvarient;
    CARD32  pixel;
    FbDeclareMergeRop ();
    
d172 16
a187 20
    while (height--)
    {
	w = width;
	src = srcLine;
	dst = (CARD32 *) dstLine;
	srcLine += srcStride;
	dstLine += dstStride;
	if (destInvarient)
	{
	    while (((long) src & 3) && w)
	    {
		w--;
		pixel = Get24(src);
		src += 3;
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
	    }
	    /* Do four aligned pixels at a time */
	    while (w >= 4)
	    {
		CARD32  s0, s1;
d189 1
a189 1
		s0 = READ((CARD32 *)src);
d191 1
a191 1
		pixel = s0 & 0xffffff;
d193 1
a193 1
		pixel = s0 >> 8;
d195 2
a196 2
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
		s1 = READ((CARD32 *)(src+4));
d198 1
a198 1
		pixel = (s0 >> 24) | ((s1 << 8) & 0xffffff);
d200 1
a200 1
		pixel = ((s0 << 16) & 0xffffff) | (s1 >> 16);
d202 2
a203 2
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
		s0 = READ((CARD32 *)(src+8));
d205 1
a205 1
		pixel = (s1 >> 16) | ((s0 << 16) & 0xffffff);
d207 1
a207 1
		pixel = ((s1 << 8) & 0xffffff) | (s0 >> 24);
d209 1
a209 1
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
d211 1
a211 1
		pixel = s0 >> 8;
d213 1
a213 1
		pixel = s0 & 0xffffff;
d215 19
a233 22
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
		src += 12;
		w -= 4;
	    }
	    while (w)
	    {
		w--;
		pixel = Get24(src);
		src += 3;
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
	    }
	}
	else
	{
	    while (w--)
	    {
		pixel = Get24(src);
		src += 3;
		WRITE(dst, FbDoMergeRop(pixel, READ(dst)));
		dst++;
	    }
	}
d241 3
a243 6
fb24_32GetSpans(DrawablePtr	pDrawable, 
		int		wMax, 
		DDXPointPtr	ppt, 
		int		*pwidth, 
		int		nspans, 
		char		*pchardstStart)
d245 8
a252 8
    FbBits	    *srcBits;
    CARD8	    *src;
    FbStride	    srcStride;
    int		    srcBpp;
    int		    srcXoff, srcYoff;
    CARD8	    *dst;
    
    fbGetDrawable (pDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);
d254 11
a264 21
    srcStride *= sizeof (FbBits);
    
    while (nspans--)
    {
	dst = (CARD8 *) pchardstStart;
	fb24_32BltUp (src + (ppt->y + srcYoff) * srcStride, srcStride,
		      ppt->x + srcXoff,
	       
		      dst,
		      1,
		      0,

		      *pwidth,
		      1,

		      GXcopy,
		      FB_ALLONES);
	
	pchardstStart += PixmapBytePad(*pwidth, pDrawable->depth);
	ppt++;
	pwidth++;
d267 1
a267 1
    fbFinishAccess (pDrawable);
d271 4
a274 7
fb24_32SetSpans (DrawablePtr	    pDrawable,
		 GCPtr		    pGC,
		 char		    *src,
		 DDXPointPtr	    ppt,
		 int		    *pwidth,
		 int		    nspans,
		 int		    fSorted)
d276 10
a285 10
    FbGCPrivPtr	    pPriv = fbGetGCPrivate (pGC);
    RegionPtr	    pClip = fbGetCompositeClip(pGC);
    FbBits	    *dstBits;
    CARD8	    *dst, *d, *s;
    FbStride	    dstStride;
    int		    dstBpp;
    int		    dstXoff, dstYoff;
    BoxPtr	    pbox;
    int		    n;
    int		    x1, x2;
d287 1
a287 1
    fbGetDrawable (pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);
d289 29
a317 36
    dstStride *= sizeof (FbBits);
    while (nspans--)
    {
	d = dst + (ppt->y + dstYoff) * dstStride;
	s = (CARD8 *) src;
	n = RegionNumRects(pClip);
	pbox = RegionRects (pClip);
	while (n--)
	{
	    if (pbox->y1 > ppt->y)
		break;
	    if (pbox->y2 > ppt->y)
	    {
		x1 = ppt->x;
		x2 = x1 + *pwidth;
		if (pbox->x1 > x1)
		    x1 = pbox->x1;
		if (pbox->x2 < x2)
		    x2 = pbox->x2;
		if (x1 < x2)
		    fb24_32BltDown (s,
				    0,
				    (x1 - ppt->x),
				    d,
				    dstStride,
				    x1 + dstXoff,

				    (x2 - x1),
				    1,
				    pGC->alu,
				    pPriv->pm);
	    }
	}
	src += PixmapBytePad (*pwidth, pDrawable->depth);
	ppt++;
	pwidth++;
d320 1
a320 1
    fbFinishAccess (pDrawable);
d327 6
a332 10
fb24_32PutZImage (DrawablePtr	pDrawable,
		  RegionPtr	pClip,
		  int		alu,
		  FbBits	pm,
		  int		x,
		  int		y,
		  int		width,
		  int		height,
		  CARD8		*src,
		  FbStride	srcStride)
d334 8
a341 8
    FbBits	*dstBits;
    CARD8	*dst;
    FbStride	dstStride;
    int		dstBpp;
    int		dstXoff, dstYoff;
    int		nbox;
    BoxPtr	pbox;
    int		x1, y1, x2, y2;
d343 1
a343 1
    fbGetDrawable (pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);
d347 21
a367 32
    for (nbox = RegionNumRects (pClip),
	 pbox = RegionRects(pClip);
	 nbox--;
	 pbox++)
    {
	x1 = x;
	y1 = y;
	x2 = x + width;
	y2 = y + height;
	if (x1 < pbox->x1)
	    x1 = pbox->x1;
	if (y1 < pbox->y1)
	    y1 = pbox->y1;
	if (x2 > pbox->x2)
	    x2 = pbox->x2;
	if (y2 > pbox->y2)
	    y2 = pbox->y2;
	if (x1 >= x2 || y1 >= y2)
	    continue;
	fb24_32BltDown (src + (y1 - y) * srcStride,
			srcStride,
			(x1 - x),

			dst + (y1 + dstYoff) * dstStride,
			dstStride,
			x1 + dstXoff,

			(x2 - x1),
			(y2 - y1),

			alu,
			pm);
d370 1
a370 1
    fbFinishAccess (pDrawable);
d374 5
a378 8
fb24_32GetImage (DrawablePtr     pDrawable,
		 int             x,
		 int             y,
		 int             w,
		 int             h,
		 unsigned int    format,
		 unsigned long   planeMask,
		 char            *d)
d380 7
a386 7
    FbBits	    *srcBits;
    CARD8	    *src;
    FbStride	    srcStride;
    int		    srcBpp;
    int		    srcXoff, srcYoff;
    FbStride	    dstStride;
    FbBits	    pm;
d388 1
a388 1
    fbGetDrawable (pDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);
d390 1
a390 1
    srcStride *= sizeof (FbBits);
d394 2
a395 2
    
    pm = fbReplicatePixel (planeMask, 32);
d398 3
a400 4
	memset (d, 0, dstStride * h);
    fb24_32BltUp (src + (y + srcYoff) * srcStride, srcStride, x + srcXoff,
		  (CARD8 *) d, dstStride, 0,
		  w, h, GXcopy, pm);
d402 1
a402 1
    fbFinishAccess (pDrawable);
d406 8
a413 11
fb24_32CopyMtoN (DrawablePtr pSrcDrawable,
		 DrawablePtr pDstDrawable,
		 GCPtr       pGC,
		 BoxPtr      pbox,
		 int         nbox,
		 int         dx,
		 int         dy,
		 Bool        reverse,
		 Bool        upsidedown,
		 Pixel       bitplane,
		 void        *closure)
d415 14
a428 14
    FbGCPrivPtr	pPriv = fbGetGCPrivate(pGC);
    FbBits	*srcBits;
    CARD8	*src;
    FbStride	srcStride;
    int		srcBpp;
    FbBits	*dstBits;
    CARD8	*dst;
    FbStride	dstStride;
    int		dstBpp;
    fb24_32BltFunc  blt;
    int		srcXoff, srcYoff;
    int		dstXoff, dstYoff;
    
    fbGetDrawable (pSrcDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);
d430 2
a431 2
    srcStride *= sizeof (FbBits);
    fbGetDrawable (pDstDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);
d433 1
a433 1
    dstStride *= sizeof (FbBits);
d435 1
a435 1
	blt = fb24_32BltUp;
d437 12
a448 18
	blt = fb24_32BltDown;
    
    while (nbox--)
    {
	(*blt) (src + (pbox->y1 + dy + srcYoff) * srcStride,
		srcStride,
		(pbox->x1 + dx + srcXoff),

		dst + (pbox->y1 + dstYoff) * dstStride,
		dstStride,
		(pbox->x1 + dstXoff),

		(pbox->x2 - pbox->x1),
		(pbox->y2 - pbox->y1),

		pGC->alu,
		pPriv->pm);
	pbox++;
d451 2
a452 2
    fbFinishAccess (pSrcDrawable);
    fbFinishAccess (pDstDrawable);
d458 8
a465 8
    ScreenPtr	pScreen = pOldTile->drawable.pScreen;
    PixmapPtr	pNewTile;
    FbBits	*old, *new;
    FbStride	oldStride, newStride;
    int		oldBpp, newBpp;
    fb24_32BltFunc  blt;
    _X_UNUSED int   oldXoff, oldYoff;
    _X_UNUSED int   newXoff, newYoff;
d468 3
a470 3
				     pOldTile->drawable.height,
				     pOldTile->drawable.depth,
				     pOldTile->usage_hint);
d472 5
a476 5
	return 0;
    fbGetDrawable (&pOldTile->drawable, 
		   old, oldStride, oldBpp, oldXoff, oldYoff);
    fbGetDrawable (&pNewTile->drawable, 
		   new, newStride, newBpp, newXoff, newYoff);
d478 1
a478 1
	blt = fb24_32BltUp;
d480 1
a480 1
	blt = fb24_32BltDown;
d483 7
a489 2
	    oldStride * sizeof (FbBits),
	    0,
d491 2
a492 12
	    (CARD8 *) new,
	    newStride * sizeof (FbBits),
	    0,

	    pOldTile->drawable.width,
	    pOldTile->drawable.height,

	    GXcopy,
	    FB_ALLONES);

    fbFinishAccess (&pOldTile->drawable);
    fbFinishAccess (&pNewTile->drawable);
d498 2
a499 2
    pointer pbits; 
    int width;   
d510 1
a510 1
    pScrInitParms = (miScreenInitParmsPtr)pScreen->devPrivate;
d513 6
a518 5
    if((retval = miCreateScreenResources(pScreen))) {
	/* fix the screen pixmap */
	PixmapPtr pPix = (PixmapPtr)pScreen->devPrivate;
	pPix->drawable.bitsPerPixel = 24;
	pPix->devKind = pitch;
d525 5
a529 7
fb24_32ModifyPixmapHeader (PixmapPtr   pPixmap,
			   int         width,
			   int         height,
			   int         depth,
			   int         bitsPerPixel,
			   int         devKind,
			   pointer     pPixData)
d531 1
a531 1
    int	    bpp, w;
d534 1
a534 1
	return FALSE;
d537 8
a544 10
	bpp = pPixmap->drawable.bitsPerPixel;
    if (bpp == 24)
    {
	if (devKind < 0)
	{
	    w = width;
	    if (w <= 0)
		w = pPixmap->drawable.width;
	    devKind = BitmapBytePad(w * 24);
	}
d547 2
a548 2
				devKind, pPixData);	
}		
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d543 2
a544 2
    int		oldXoff, oldYoff;
    int		newXoff, newYoff;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d338 2
a339 2
	n = REGION_NUM_RECTS(pClip);
	pbox = REGION_RECTS (pClip);
d402 2
a403 2
    for (nbox = REGION_NUM_RECTS (pClip),
	 pbox = REGION_RECTS(pClip);
@


1.1
log
@Initial revision
@
text
@a1 1
 *
d40 1
a40 1
#define Get8(a)	((CARD32) *(a))
d44 3
a46 3
#define Put24(a,p)  (((a)[0] = (CARD8) ((p) >> 16)), \
		     ((a)[1] = (CARD8) ((p) >> 8)), \
		     ((a)[2] = (CARD8) (p)))
d49 3
a51 3
#define Put24(a,p)  (((a)[0] = (CARD8) (p)), \
		     ((a)[1] = (CARD8) ((p) >> 8)), \
		     ((a)[2] = (CARD8) ((p) >> 16)))
d108 1
a108 1
		pixel = *src++;
d117 1
a117 1
		s0 = *src++;
d119 1
a119 1
		s1 = *src++;
d122 1
a122 1
		*(CARD32 *)(dst) = (s0 & 0xffffff) | (s1 << 24);
d124 1
a124 1
		*(CARD32 *)(dst) = (s0 << 8) | ((s1 & 0xffffff) >> 16);
d126 1
a126 1
		s0 = *src++;
d129 1
a129 1
		*(CARD32 *)(dst+4) = ((s1 & 0xffffff) >> 8) | (s0 << 16);
d131 1
a131 1
		*(CARD32 *)(dst+4) = (s1 << 16) | ((s0 & 0xffffff) >> 8);
d133 1
a133 1
		s1 = *src++;
d136 1
a136 1
		*(CARD32 *)(dst+8) = ((s0 & 0xffffff) >> 16) | (s1 << 8);
d138 1
a138 1
		*(CARD32 *)(dst+8) = (s0 << 24) | (s1 & 0xffffff);
d145 1
a145 1
		pixel = *src++;
d155 1
a155 1
		pixel = *src++;
d207 1
a207 1
		*dst++ = FbDoDestInvarientMergeRop(pixel);
d214 1
a214 1
		s0 = *(CARD32 *)(src);
d220 2
a221 2
		*dst++ = FbDoDestInvarientMergeRop(pixel);
		s1 = *(CARD32 *)(src+4);
d227 2
a228 2
		*dst++ = FbDoDestInvarientMergeRop(pixel);
		s0 = *(CARD32 *)(src+8);
d234 1
a234 1
		*dst++ = FbDoDestInvarientMergeRop(pixel);
d240 1
a240 1
		*dst++ = FbDoDestInvarientMergeRop(pixel);
d249 1
a249 1
		*dst++ = FbDoDestInvarientMergeRop(pixel);
d258 1
a258 1
		*dst = FbDoMergeRop(pixel, *dst);
d307 2
d370 2
d435 2
d471 2
d529 3
d546 4
a549 5
    pNewTile = fbCreatePixmapBpp (pScreen,
				  pOldTile->drawable.width,
				  pOldTile->drawable.height,
				  pOldTile->drawable.depth,
				  bitsPerPixel);
d574 3
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d41 1
a41 1
#define Get8(a)	((CARD32) READ(a))
d45 3
a47 3
#define Put24(a,p)  ((WRITE((a+0), (CARD8) ((p) >> 16))), \
		     (WRITE((a+1), (CARD8) ((p) >> 8))), \
		     (WRITE((a+2), (CARD8) (p))))
d50 3
a52 3
#define Put24(a,p)  ((WRITE((a+0), (CARD8) (p))), \
		     (WRITE((a+1), (CARD8) ((p) >> 8))), \
		     (WRITE((a+2), (CARD8) ((p) >> 16))))
d109 1
a109 1
		pixel = READ(src++);
d118 1
a118 1
		s0 = READ(src++);
d120 1
a120 1
		s1 = READ(src++);
d123 1
a123 1
		WRITE((CARD32 *)dst, (s0 & 0xffffff) | (s1 << 24));
d125 1
a125 1
		WRITE((CARD32 *)dst, (s0 << 8) | ((s1 & 0xffffff) >> 16));
d127 1
a127 1
		s0 = READ(src++);
d130 1
a130 1
		WRITE((CARD32 *)(dst+4), ((s1 & 0xffffff) >> 8) | (s0 << 16));
d132 1
a132 1
		WRITE((CARD32 *)(dst+4), (s1 << 16) | ((s0 & 0xffffff) >> 8));
d134 1
a134 1
		s1 = READ(src++);
d137 1
a137 1
		WRITE((CARD32 *)(dst+8), ((s0 & 0xffffff) >> 16) | (s1 << 8));
d139 1
a139 1
		WRITE((CARD32 *)(dst+8), (s0 << 24) | (s1 & 0xffffff));
d146 1
a146 1
		pixel = READ(src++);
d156 1
a156 1
		pixel = READ(src++);
d208 1
a208 1
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
d215 1
a215 1
		s0 = READ((CARD32 *)src);
d221 2
a222 2
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
		s1 = READ((CARD32 *)(src+4));
d228 2
a229 2
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
		s0 = READ((CARD32 *)(src+8));
d235 1
a235 1
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
d241 1
a241 1
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
d250 1
a250 1
		WRITE(dst++, FbDoDestInvarientMergeRop(pixel));
d259 1
a259 1
		WRITE(dst, FbDoMergeRop(pixel, READ(dst)));
a307 2

    fbFinishAccess (pDrawable);
a368 2

    fbFinishAccess (pDrawable);
a431 2

    fbFinishAccess (pDrawable);
a465 2

    fbFinishAccess (pDrawable);
a521 3

    fbFinishAccess (pSrcDrawable);
    fbFinishAccess (pDstDrawable);
a564 3

    fbFinishAccess (&pOldTile->drawable);
    fbFinishAccess (&pNewTile->drawable);
@

