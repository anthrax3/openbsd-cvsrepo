head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.8
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.6
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.4
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.14
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.12
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	Te1daavkBLskZ8gc;

1.4
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.32;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright Â© 1998 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "fb.h"

static void
fbZeroLine(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt, DDXPointPtr ppt)
{
    int x1, y1, x2, y2;
    int x, y;
    int dashOffset;

    x = pDrawable->x;
    y = pDrawable->y;
    x1 = ppt->x;
    y1 = ppt->y;
    dashOffset = pGC->dashOffset;
    while (--npt) {
        ++ppt;
        x2 = ppt->x;
        y2 = ppt->y;
        if (mode == CoordModePrevious) {
            x2 += x1;
            y2 += y1;
        }
        fbSegment(pDrawable, pGC, x1 + x, y1 + y,
                  x2 + x, y2 + y,
                  npt == 1 && pGC->capStyle != CapNotLast, &dashOffset);
        x1 = x2;
        y1 = y2;
    }
}

static void
fbZeroSegment(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pSegs)
{
    int dashOffset;
    int x, y;
    Bool drawLast = pGC->capStyle != CapNotLast;

    x = pDrawable->x;
    y = pDrawable->y;
    while (nseg--) {
        dashOffset = pGC->dashOffset;
        fbSegment(pDrawable, pGC,
                  pSegs->x1 + x, pSegs->y1 + y,
                  pSegs->x2 + x, pSegs->y2 + y, drawLast, &dashOffset);
        pSegs++;
    }
}

void
fbFixCoordModePrevious(int npt, DDXPointPtr ppt)
{
    int x, y;

    x = ppt->x;
    y = ppt->y;
    npt--;
    while (npt--) {
        ppt++;
        x = (ppt->x += x);
        y = (ppt->y += y);
    }
}

void
fbPolyLine(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt, DDXPointPtr ppt)
{
    void (*line) (DrawablePtr, GCPtr, int mode, int npt, DDXPointPtr ppt);

    if (pGC->lineWidth == 0) {
        line = fbZeroLine;
        if (pGC->fillStyle == FillSolid &&
            pGC->lineStyle == LineSolid &&
            RegionNumRects(fbGetCompositeClip(pGC)) == 1) {
            switch (pDrawable->bitsPerPixel) {
            case 8:
                line = fbPolyline8;
                break;
            case 16:
                line = fbPolyline16;
                break;
            case 24:
                line = fbPolyline24;
                break;
            case 32:
                line = fbPolyline32;
                break;
            }
        }
    }
    else {
        if (pGC->lineStyle != LineSolid)
            line = miWideDash;
        else
            line = miWideLine;
    }
    (*line) (pDrawable, pGC, mode, npt, ppt);
}

void
fbPolySegment(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pseg)
{
    void (*seg) (DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pseg);

    if (pGC->lineWidth == 0) {
        seg = fbZeroSegment;
        if (pGC->fillStyle == FillSolid &&
            pGC->lineStyle == LineSolid &&
            RegionNumRects(fbGetCompositeClip(pGC)) == 1) {
            switch (pDrawable->bitsPerPixel) {
            case 8:
                seg = fbPolySegment8;
                break;
            case 16:
                seg = fbPolySegment16;
                break;
            case 24:
                seg = fbPolySegment24;
                break;
            case 32:
                seg = fbPolySegment32;
                break;
            }
        }
    }
    else {
        seg = miPolySegment;
    }
    (*seg) (pDrawable, pGC, nseg, pseg);
}
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d29 1
a29 1
void
d57 1
a57 1
void
@


1.3
log
@Update to xserver 1.11.2
@
text
@d30 1
a30 5
fbZeroLine (DrawablePtr	pDrawable,
	    GCPtr	pGC,
	    int		mode,
	    int		npt,
	    DDXPointPtr	ppt)
d32 3
a34 3
    int		    x1, y1, x2, y2;
    int		    x, y;
    int		    dashOffset;
d41 13
a53 16
    while (--npt)
    {
	++ppt;
	x2 = ppt->x;
	y2 = ppt->y;
	if (mode == CoordModePrevious)
	{
	    x2 += x1;
	    y2 += y1;
	}
	fbSegment (pDrawable, pGC, x1 + x, y1 + y, 
		   x2 + x, y2 + y, 
		   npt == 1 && pGC->capStyle != CapNotLast,
		   &dashOffset);
	x1 = x2;
	y1 = y2;
d58 1
a58 4
fbZeroSegment (DrawablePtr  pDrawable,
	       GCPtr	    pGC,
	       int	    nseg,
	       xSegment	    *pSegs)
d60 4
a63 4
    int	    dashOffset;
    int	    x, y;
    Bool    drawLast = pGC->capStyle != CapNotLast;
    
d66 6
a71 9
    while (nseg--)
    {
	dashOffset = pGC->dashOffset;
	fbSegment (pDrawable, pGC, 
		   pSegs->x1 + x, pSegs->y1 + y,
		   pSegs->x2 + x, pSegs->y2 + y,
		   drawLast,
		   &dashOffset);
	pSegs++;
d76 1
a76 2
fbFixCoordModePrevious (int	    npt,
			DDXPointPtr ppt)
d78 1
a78 1
    int	    x, y;
d83 4
a86 5
    while (npt--)
    {
	ppt++;
	x = (ppt->x += x);
	y = (ppt->y += y);
d91 1
a91 5
fbPolyLine (DrawablePtr	pDrawable,
	    GCPtr	pGC,
	    int		mode,
	    int		npt,
	    DDXPointPtr	ppt)
d93 28
a120 23
    void	(*line) (DrawablePtr, GCPtr, int mode, int npt, DDXPointPtr ppt);
    
    if (pGC->lineWidth == 0)
    {
	line = fbZeroLine;
	if (pGC->fillStyle == FillSolid &&
	    pGC->lineStyle == LineSolid &&
	    RegionNumRects (fbGetCompositeClip(pGC)) == 1)
	{
	    switch (pDrawable->bitsPerPixel) {
	    case 8:  line = fbPolyline8; break;
	    case 16: line = fbPolyline16; break;
	    case 24: line = fbPolyline24; break;
	    case 32: line = fbPolyline32; break;
	    }
	}
    }
    else
    {
	if (pGC->lineStyle != LineSolid)
	    line = miWideDash;
	else
	    line = miWideLine;
d126 1
a126 4
fbPolySegment (DrawablePtr  pDrawable,
	       GCPtr	    pGC,
	       int	    nseg,
	       xSegment	    *pseg)
d128 1
a128 1
    void    (*seg) (DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment *pseg);
d130 23
a152 18
    if (pGC->lineWidth == 0)
    {
	seg = fbZeroSegment;
	if (pGC->fillStyle == FillSolid &&
	    pGC->lineStyle == LineSolid &&
	    RegionNumRects (fbGetCompositeClip(pGC)) == 1)
	{
	    switch (pDrawable->bitsPerPixel) {
	    case 8:  seg = fbPolySegment8; break;
	    case 16: seg = fbPolySegment16; break;
	    case 24: seg = fbPolySegment24; break;
	    case 32: seg = fbPolySegment32; break;
	    }
	}
    }
    else
    {
	seg = miPolySegment;
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a116 1
#ifndef FBNOPIXADDR
a123 1
#ifdef FB_24BIT
a124 1
#endif
a127 1
#endif
a149 1
#ifndef FBNOPIXADDR
a156 1
#ifdef FB_24BIT
a157 1
#endif
a160 1
#endif
@


1.1
log
@Initial revision
@
text
@a1 2
 * $XFree86$
 *
d120 1
a120 1
	    REGION_NUM_RECTS (fbGetCompositeClip(pGC)) == 1)
d157 1
a157 1
	    REGION_NUM_RECTS (fbGetCompositeClip(pGC)) == 1)
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
@

