head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.22;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.43;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.32;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *
 * Copyright Â© 2000 SuSE, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of SuSE not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  SuSE makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
 * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Author:  Keith Packard, SuSE, Inc.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include "fb.h"
#include "fboverlay.h"
#include "shmint.h"

static DevPrivateKeyRec fbOverlayScreenPrivateKeyRec;

#define fbOverlayScreenPrivateKey (&fbOverlayScreenPrivateKeyRec)

DevPrivateKey
fbOverlayGetScreenPrivateKey(void)
{
    return fbOverlayScreenPrivateKey;
}

/*
 * Replace this if you want something supporting
 * multiple overlays with the same depth
 */
Bool
fbOverlayCreateWindow(WindowPtr pWin)
{
    FbOverlayScrPrivPtr pScrPriv = fbOverlayGetScrPriv(pWin->drawable.pScreen);
    int i;
    PixmapPtr pPixmap;

    if (pWin->drawable.class != InputOutput)
        return TRUE;

    if (pWin->drawable.bitsPerPixel == 32)
        pWin->drawable.bitsPerPixel =
            fbGetScreenPrivate(pWin->drawable.pScreen)->win32bpp;

    for (i = 0; i < pScrPriv->nlayers; i++) {
        pPixmap = pScrPriv->layer[i].u.run.pixmap;
        if (pWin->drawable.depth == pPixmap->drawable.depth) {
            dixSetPrivate(&pWin->devPrivates, fbGetWinPrivateKey(pWin), pPixmap);
            /*
             * Make sure layer keys are written correctly by
             * having non-root layers set to full while the
             * root layer is set to empty.  This will cause
             * all of the layers to get painted when the root
             * is mapped
             */
            if (!pWin->parent) {
                RegionEmpty(&pScrPriv->layer[i].u.run.region);
            }
            return TRUE;
        }
    }
    return FALSE;
}

Bool
fbOverlayCloseScreen(ScreenPtr pScreen)
{
    FbOverlayScrPrivPtr pScrPriv = fbOverlayGetScrPriv(pScreen);
    int i;

    for (i = 0; i < pScrPriv->nlayers; i++) {
        (*pScreen->DestroyPixmap) (pScrPriv->layer[i].u.run.pixmap);
        RegionUninit(&pScrPriv->layer[i].u.run.region);
    }
    return TRUE;
}

/*
 * Return layer containing this window
 */
int
fbOverlayWindowLayer(WindowPtr pWin)
{
    FbOverlayScrPrivPtr pScrPriv = fbOverlayGetScrPriv(pWin->drawable.pScreen);
    int i;

    for (i = 0; i < pScrPriv->nlayers; i++)
        if (dixLookupPrivate(&pWin->devPrivates, fbGetWinPrivateKey(pWin)) ==
            (void *) pScrPriv->layer[i].u.run.pixmap)
            return i;
    return 0;
}

Bool
fbOverlayCreateScreenResources(ScreenPtr pScreen)
{
    int i;
    FbOverlayScrPrivPtr pScrPriv = fbOverlayGetScrPriv(pScreen);
    PixmapPtr pPixmap;
    void *pbits;
    int width;
    int depth;
    BoxRec box;

    if (!miCreateScreenResources(pScreen))
        return FALSE;

    box.x1 = 0;
    box.y1 = 0;
    box.x2 = pScreen->width;
    box.y2 = pScreen->height;
    for (i = 0; i < pScrPriv->nlayers; i++) {
        pbits = pScrPriv->layer[i].u.init.pbits;
        width = pScrPriv->layer[i].u.init.width;
        depth = pScrPriv->layer[i].u.init.depth;
        pPixmap = (*pScreen->CreatePixmap) (pScreen, 0, 0, depth, 0);
        if (!pPixmap)
            return FALSE;
        if (!(*pScreen->ModifyPixmapHeader) (pPixmap, pScreen->width,
                                             pScreen->height, depth,
                                             BitsPerPixel(depth),
                                             PixmapBytePad(width, depth),
                                             pbits))
            return FALSE;
        pScrPriv->layer[i].u.run.pixmap = pPixmap;
        RegionInit(&pScrPriv->layer[i].u.run.region, &box, 0);
    }
    pScreen->devPrivate = pScrPriv->layer[0].u.run.pixmap;
    return TRUE;
}

void
fbOverlayPaintKey(DrawablePtr pDrawable,
                  RegionPtr pRegion, CARD32 pixel, int layer)
{
    fbFillRegionSolid(pDrawable, pRegion, 0,
                      fbReplicatePixel(pixel, pDrawable->bitsPerPixel));
}

/*
 * Track visible region for each layer
 */
void
fbOverlayUpdateLayerRegion(ScreenPtr pScreen, int layer, RegionPtr prgn)
{
    FbOverlayScrPrivPtr pScrPriv = fbOverlayGetScrPriv(pScreen);
    int i;
    RegionRec rgnNew;

    if (!prgn || !RegionNotEmpty(prgn))
        return;
    for (i = 0; i < pScrPriv->nlayers; i++) {
        if (i == layer) {
            /* add new piece to this fb */
            RegionUnion(&pScrPriv->layer[i].u.run.region,
                        &pScrPriv->layer[i].u.run.region, prgn);
        }
        else if (RegionNotEmpty(&pScrPriv->layer[i].u.run.region)) {
            /* paint new piece with chroma key */
            RegionNull(&rgnNew);
            RegionIntersect(&rgnNew, prgn, &pScrPriv->layer[i].u.run.region);
            (*pScrPriv->PaintKey) (&pScrPriv->layer[i].u.run.pixmap->drawable,
                                   &rgnNew, pScrPriv->layer[i].key, i);
            RegionUninit(&rgnNew);
            /* remove piece from other fbs */
            RegionSubtract(&pScrPriv->layer[i].u.run.region,
                           &pScrPriv->layer[i].u.run.region, prgn);
        }
    }
}

/*
 * Copy only areas in each layer containing real bits
 */
void
fbOverlayCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    FbOverlayScrPrivPtr pScrPriv = fbOverlayGetScrPriv(pScreen);
    RegionRec rgnDst;
    int dx, dy;
    int i;
    RegionRec layerRgn[FB_OVERLAY_MAX];
    PixmapPtr pPixmap;

    dx = ptOldOrg.x - pWin->drawable.x;
    dy = ptOldOrg.y - pWin->drawable.y;

    /*
     * Clip to existing bits
     */
    RegionTranslate(prgnSrc, -dx, -dy);
    RegionNull(&rgnDst);
    RegionIntersect(&rgnDst, &pWin->borderClip, prgnSrc);
    RegionTranslate(&rgnDst, dx, dy);
    /*
     * Compute the portion of each fb affected by this copy
     */
    for (i = 0; i < pScrPriv->nlayers; i++) {
        RegionNull(&layerRgn[i]);
        RegionIntersect(&layerRgn[i], &rgnDst,
                        &pScrPriv->layer[i].u.run.region);
        if (RegionNotEmpty(&layerRgn[i])) {
            RegionTranslate(&layerRgn[i], -dx, -dy);
            pPixmap = pScrPriv->layer[i].u.run.pixmap;
            miCopyRegion(&pPixmap->drawable, &pPixmap->drawable,
                         0,
                         &layerRgn[i], dx, dy, pScrPriv->CopyWindow, 0,
                         (void *) (long) i);
        }
    }
    /*
     * Update regions
     */
    for (i = 0; i < pScrPriv->nlayers; i++) {
        if (RegionNotEmpty(&layerRgn[i]))
            fbOverlayUpdateLayerRegion(pScreen, i, &layerRgn[i]);

        RegionUninit(&layerRgn[i]);
    }
    RegionUninit(&rgnDst);
}

void
fbOverlayWindowExposures(WindowPtr pWin, RegionPtr prgn)
{
    fbOverlayUpdateLayerRegion(pWin->drawable.pScreen,
                               fbOverlayWindowLayer(pWin), prgn);
    miWindowExposures(pWin, prgn);
}

Bool
fbOverlaySetupScreen(ScreenPtr pScreen,
                     void *pbits1,
                     void *pbits2,
                     int xsize,
                     int ysize,
                     int dpix,
                     int dpiy, int width1, int width2, int bpp1, int bpp2)
{
    return fbSetupScreen(pScreen,
                         pbits1, xsize, ysize, dpix, dpiy, width1, bpp1);
}

static Bool
fb24_32OverlayCreateScreenResources(ScreenPtr pScreen)
{
    FbOverlayScrPrivPtr pScrPriv = fbOverlayGetScrPriv(pScreen);
    int pitch;
    Bool retval;
    int i;

    if ((retval = fbOverlayCreateScreenResources(pScreen))) {
        for (i = 0; i < pScrPriv->nlayers; i++) {
            /* fix the screen pixmap */
            PixmapPtr pPix = (PixmapPtr) pScrPriv->layer[i].u.run.pixmap;

            if (pPix->drawable.bitsPerPixel == 32) {
                pPix->drawable.bitsPerPixel = 24;
                pitch = BitmapBytePad(pPix->drawable.width * 24);
                pPix->devKind = pitch;
            }
        }
    }

    return retval;
}

Bool
fbOverlayFinishScreenInit(ScreenPtr pScreen,
                          void *pbits1,
                          void *pbits2,
                          int xsize,
                          int ysize,
                          int dpix,
                          int dpiy,
                          int width1,
                          int width2,
                          int bpp1, int bpp2, int depth1, int depth2)
{
    VisualPtr visuals;
    DepthPtr depths;
    int nvisuals;
    int ndepths;
    int bpp = 0, imagebpp = 32;
    VisualID defaultVisual;
    FbOverlayScrPrivPtr pScrPriv;

    if (!dixRegisterPrivateKey
        (&fbOverlayScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    pScrPriv = malloc(sizeof(FbOverlayScrPrivRec));
    if (!pScrPriv)
        return FALSE;

    if (bpp1 == 32 || bpp2 == 32)
        bpp = 32;
    else if (bpp1 == 24 || bpp2 == 24)
        bpp = 24;

    if (bpp == 24) {
        int f;

        imagebpp = 32;
        /*
         * Check to see if we're advertising a 24bpp image format,
         * in which case windows will use it in preference to a 32 bit
         * format.
         */
        for (f = 0; f < screenInfo.numPixmapFormats; f++) {
            if (screenInfo.formats[f].bitsPerPixel == 24) {
                imagebpp = 24;
                break;
            }
        }
    }
    if (imagebpp == 32) {
        fbGetScreenPrivate(pScreen)->win32bpp = bpp;
        fbGetScreenPrivate(pScreen)->pix32bpp = bpp;
    }
    else {
        fbGetScreenPrivate(pScreen)->win32bpp = 32;
        fbGetScreenPrivate(pScreen)->pix32bpp = 32;
    }

    if (!fbInitVisuals(&visuals, &depths, &nvisuals, &ndepths, &depth1,
                       &defaultVisual, ((unsigned long) 1 << (bpp1 - 1)) |
                       ((unsigned long) 1 << (bpp2 - 1)), 8)) {
        free(pScrPriv);
        return FALSE;
    }
    if (!miScreenInit(pScreen, 0, xsize, ysize, dpix, dpiy, 0,
                      depth1, ndepths, depths,
                      defaultVisual, nvisuals, visuals)) {
        free(pScrPriv);
        return FALSE;
    }
    /* MI thinks there's no frame buffer */
#ifdef MITSHM
    ShmRegisterFbFuncs(pScreen);
#endif
    pScreen->minInstalledCmaps = 1;
    pScreen->maxInstalledCmaps = 2;

    pScrPriv->nlayers = 2;
    pScrPriv->PaintKey = fbOverlayPaintKey;
    pScrPriv->CopyWindow = fbCopyWindowProc;
    pScrPriv->layer[0].u.init.pbits = pbits1;
    pScrPriv->layer[0].u.init.width = width1;
    pScrPriv->layer[0].u.init.depth = depth1;

    pScrPriv->layer[1].u.init.pbits = pbits2;
    pScrPriv->layer[1].u.init.width = width2;
    pScrPriv->layer[1].u.init.depth = depth2;
    dixSetPrivate(&pScreen->devPrivates, fbOverlayScreenPrivateKey, pScrPriv);

    /* overwrite miCloseScreen with our own */
    pScreen->CloseScreen = fbOverlayCloseScreen;
    pScreen->CreateScreenResources = fbOverlayCreateScreenResources;
    pScreen->CreateWindow = fbOverlayCreateWindow;
    pScreen->WindowExposures = fbOverlayWindowExposures;
    pScreen->CopyWindow = fbOverlayCopyWindow;
    if (bpp == 24 && imagebpp == 32) {
        pScreen->ModifyPixmapHeader = fb24_32ModifyPixmapHeader;
        pScreen->CreateScreenResources = fb24_32OverlayCreateScreenResources;
    }

    return TRUE;
}
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d19 1
a19 1
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
d243 1
a243 2
fbOverlayWindowExposures(WindowPtr pWin,
                         RegionPtr prgn, RegionPtr other_exposed)
d247 1
a247 1
    miWindowExposures(pWin, prgn, other_exposed);
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d107 1
a107 1
            (pointer) pScrPriv->layer[i].u.run.pixmap)
d118 1
a118 1
    pointer pbits;
d253 2
a254 2
                     pointer pbits1,
                     pointer pbits2,
d290 2
a291 2
                          pointer pbits1,
                          pointer pbits2,
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d66 1
a66 1
            dixSetPrivate(&pWin->devPrivates, fbGetWinPrivateKey(), pPixmap);
d84 1
a84 1
fbOverlayCloseScreen(int iScreen, ScreenPtr pScreen)
d106 1
a106 1
        if (dixLookupPrivate(&pWin->devPrivates, fbGetWinPrivateKey()) ==
@


1.6
log
@Update to xserver 1.11.2
@
text
@a24 1

d36 1
d39 2
a40 1
DevPrivateKey fbOverlayGetScreenPrivateKey(void)
d52 4
a55 4
    FbOverlayScrPrivPtr	pScrPriv = fbOverlayGetScrPriv(pWin->drawable.pScreen);
    int			i;
    PixmapPtr		pPixmap;
    
d57 1
a57 1
	return TRUE;
d60 2
a61 1
	pWin->drawable.bitsPerPixel = fbGetScreenPrivate(pWin->drawable.pScreen)->win32bpp;
d63 16
a78 19
    for (i = 0; i < pScrPriv->nlayers; i++)
    {
	pPixmap = pScrPriv->layer[i].u.run.pixmap;
	if (pWin->drawable.depth == pPixmap->drawable.depth)
	{
	    dixSetPrivate(&pWin->devPrivates, fbGetWinPrivateKey(), pPixmap);
	    /*
	     * Make sure layer keys are written correctly by
	     * having non-root layers set to full while the
	     * root layer is set to empty.  This will cause
	     * all of the layers to get painted when the root
	     * is mapped
	     */
	    if (!pWin->parent)
	    {
		RegionEmpty(&pScrPriv->layer[i].u.run.region);
	    }
	    return TRUE;
	}
d84 1
a84 1
fbOverlayCloseScreen (int iScreen, ScreenPtr pScreen)
d86 2
a87 2
    FbOverlayScrPrivPtr	pScrPriv = fbOverlayGetScrPriv(pScreen);
    int			i;
d89 3
a91 4
    for (i = 0; i < pScrPriv->nlayers; i++)
    {
	(*pScreen->DestroyPixmap)(pScrPriv->layer[i].u.run.pixmap);
	RegionUninit(&pScrPriv->layer[i].u.run.region);
d103 1
a103 1
    int                 i;
d106 3
a108 3
	if (dixLookupPrivate(&pWin->devPrivates, fbGetWinPrivateKey()) ==
	    (pointer) pScrPriv->layer[i].u.run.pixmap)
	    return i;
d115 8
a122 8
    int			i;
    FbOverlayScrPrivPtr	pScrPriv = fbOverlayGetScrPriv(pScreen);
    PixmapPtr		pPixmap;
    pointer		pbits;
    int			width;
    int			depth;
    BoxRec		box;
    
d124 1
a124 1
	return FALSE;
d130 15
a144 16
    for (i = 0; i < pScrPriv->nlayers; i++)
    {
	pbits = pScrPriv->layer[i].u.init.pbits;
	width = pScrPriv->layer[i].u.init.width;
	depth = pScrPriv->layer[i].u.init.depth;
	pPixmap = (*pScreen->CreatePixmap)(pScreen, 0, 0, depth, 0);
	if (!pPixmap)
	    return FALSE;
	if (!(*pScreen->ModifyPixmapHeader)(pPixmap, pScreen->width,
					    pScreen->height, depth,
					    BitsPerPixel(depth),
					    PixmapBytePad(width, depth),
					    pbits))
	    return FALSE;
	pScrPriv->layer[i].u.run.pixmap = pPixmap;
	RegionInit(&pScrPriv->layer[i].u.run.region, &box, 0);
d151 2
a152 4
fbOverlayPaintKey (DrawablePtr	pDrawable,
		   RegionPtr	pRegion,
		   CARD32	pixel,
		   int		layer)
d154 2
a155 2
    fbFillRegionSolid (pDrawable, pRegion, 0, 
		       fbReplicatePixel (pixel, pDrawable->bitsPerPixel));
d162 1
a162 3
fbOverlayUpdateLayerRegion (ScreenPtr	pScreen,
			    int		layer,
			    RegionPtr	prgn)
d165 3
a167 3
    int			i;
    RegionRec		rgnNew;
    
d169 18
a186 26
	return;
    for (i = 0; i < pScrPriv->nlayers; i++)
    {
	if (i == layer)
	{
	    /* add new piece to this fb */
	    RegionUnion(&pScrPriv->layer[i].u.run.region,
			&pScrPriv->layer[i].u.run.region,
			prgn);
	}
	else if (RegionNotEmpty(&pScrPriv->layer[i].u.run.region))
	{
	    /* paint new piece with chroma key */
	    RegionNull(&rgnNew);
	    RegionIntersect(&rgnNew, prgn,
			    &pScrPriv->layer[i].u.run.region);
	    (*pScrPriv->PaintKey) (&pScrPriv->layer[i].u.run.pixmap->drawable,
				   &rgnNew,
				   pScrPriv->layer[i].key,
				   i);
	    RegionUninit(&rgnNew);
	    /* remove piece from other fbs */
	    RegionSubtract(&pScrPriv->layer[i].u.run.region,
			   &pScrPriv->layer[i].u.run.region,
			   prgn);
	}
d194 9
a202 11
fbOverlayCopyWindow(WindowPtr	pWin,
		    DDXPointRec	ptOldOrg,
		    RegionPtr	prgnSrc)
{
    ScreenPtr		pScreen = pWin->drawable.pScreen;
    FbOverlayScrPrivPtr	pScrPriv = fbOverlayGetScrPriv(pScreen);
    RegionRec		rgnDst;
    int			dx, dy;
    int			i;
    RegionRec		layerRgn[FB_OVERLAY_MAX];
    PixmapPtr		pPixmap;
d217 12
a228 14
    for (i = 0; i < pScrPriv->nlayers; i++)
    {
	RegionNull(&layerRgn[i]);
	RegionIntersect(&layerRgn[i], &rgnDst,
			 &pScrPriv->layer[i].u.run.region);
	if (RegionNotEmpty(&layerRgn[i]))
	{
	    RegionTranslate(&layerRgn[i], -dx, -dy);
	    pPixmap = pScrPriv->layer[i].u.run.pixmap;
	    miCopyRegion (&pPixmap->drawable, &pPixmap->drawable,
			  0,
			  &layerRgn[i], dx, dy, pScrPriv->CopyWindow, 0,
			  (void *)(long) i);
	}
d233 3
a235 4
    for (i = 0; i < pScrPriv->nlayers; i++)
    {
	if (RegionNotEmpty(&layerRgn[i]))
	    fbOverlayUpdateLayerRegion (pScreen, i, &layerRgn[i]);
d237 1
a237 1
	RegionUninit(&layerRgn[i]);
d240 1
a240 1
}   
d243 5
a247 7
fbOverlayWindowExposures (WindowPtr	pWin,
			  RegionPtr	prgn,
			  RegionPtr	other_exposed)
{
    fbOverlayUpdateLayerRegion (pWin->drawable.pScreen,
				fbOverlayWindowLayer (pWin),
				prgn);
d252 10
a261 20
fbOverlaySetupScreen(ScreenPtr	pScreen,
		     pointer	pbits1,
		     pointer	pbits2,
		     int	xsize,
		     int	ysize,
		     int	dpix,
		     int	dpiy,
		     int	width1,
		     int	width2,
		     int	bpp1,
		     int	bpp2)
{
    return fbSetupScreen (pScreen,
			  pbits1,
			  xsize,
			  ysize,
			  dpix,
			  dpiy,
			  width1,
			  bpp1);
d267 1
a267 1
    FbOverlayScrPrivPtr	pScrPriv = fbOverlayGetScrPriv(pScreen);
d272 11
a282 11
    if((retval = fbOverlayCreateScreenResources(pScreen))) {
	for (i = 0; i < pScrPriv->nlayers; i++)
	{
	    /* fix the screen pixmap */
	    PixmapPtr pPix = (PixmapPtr) pScrPriv->layer[i].u.run.pixmap;
	    if (pPix->drawable.bitsPerPixel == 32) {
		pPix->drawable.bitsPerPixel = 24;
		pitch = BitmapBytePad(pPix->drawable.width * 24);
		pPix->devKind = pitch;
	    }
	}
d289 22
a310 21
fbOverlayFinishScreenInit(ScreenPtr	pScreen,
			  pointer	pbits1,
			  pointer	pbits2,
			  int		xsize,
			  int		ysize,
			  int		dpix,
			  int		dpiy,
			  int		width1,
			  int		width2,
			  int		bpp1,
			  int		bpp2,
			  int		depth1,
			  int		depth2)
{
    VisualPtr	visuals;
    DepthPtr	depths;
    int		nvisuals;
    int		ndepths;
    int		bpp = 0, imagebpp = 32;
    VisualID	defaultVisual;
    FbOverlayScrPrivPtr	pScrPriv;
d312 3
a314 2
    if (!dixRegisterPrivateKey(&fbOverlayScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;
a315 4
    pScrPriv = malloc(sizeof (FbOverlayScrPrivRec));
    if (!pScrPriv)
	return FALSE;
 
d317 1
a317 1
	bpp = 32;
d319 1
a319 1
	bpp = 24;
d321 36
a356 41
    if (bpp == 24)
    {
	int	f;
	
	imagebpp = 32;
	/*
	 * Check to see if we're advertising a 24bpp image format,
	 * in which case windows will use it in preference to a 32 bit
	 * format.
	 */
	for (f = 0; f < screenInfo.numPixmapFormats; f++)
	{
	    if (screenInfo.formats[f].bitsPerPixel == 24)
	    {
		imagebpp = 24;
		break;
	    }
	}	    
    }
    if (imagebpp == 32)
    {
	fbGetScreenPrivate(pScreen)->win32bpp = bpp;
	fbGetScreenPrivate(pScreen)->pix32bpp = bpp;
    }
    else
    {
	fbGetScreenPrivate(pScreen)->win32bpp = 32;
	fbGetScreenPrivate(pScreen)->pix32bpp = 32;
    }
   
    if (!fbInitVisuals (&visuals, &depths, &nvisuals, &ndepths, &depth1,
			&defaultVisual, ((unsigned long)1<<(bpp1-1)) |
			((unsigned long)1<<(bpp2-1)), 8)) {
	free(pScrPriv);
	return FALSE;
    }
    if (! miScreenInit(pScreen, 0, xsize, ysize, dpix, dpiy, 0,
			depth1, ndepths, depths,
			defaultVisual, nvisuals, visuals)) {
	free(pScrPriv);
	return FALSE;
d364 1
a364 1
    
d376 1
a376 1
    
d383 3
a385 4
    if (bpp == 24 && imagebpp == 32)
    {
	pScreen->ModifyPixmapHeader = fb24_32ModifyPixmapHeader;
  	pScreen->CreateScreenResources = fb24_32OverlayCreateScreenResources;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a57 1
#ifdef FB_SCREEN_PRIVATE
a59 1
#endif
a349 1
#ifdef FB_24_32BIT
a373 2
#endif
#ifdef FB_SCREEN_PRIVATE
a383 1
#endif
d387 2
a388 1
			((unsigned long)1<<(bpp2-1)), 8))
d390 1
d393 2
a394 1
			defaultVisual, nvisuals, visuals))
d396 1
a421 1
#ifdef FB_24_32BIT
a426 1
#endif
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d36 2
a37 2
static int fbOverlayScreenPrivateKeyIndex;
static DevPrivateKey fbOverlayScreenPrivateKey = &fbOverlayScreenPrivateKeyIndex;
d78 1
a78 2
		REGION_EMPTY (pWin->drawable.pScreen,
			      &pScrPriv->layer[i].u.run.region);
d95 1
a95 1
	REGION_UNINIT (pScreen, &pScrPriv->layer[i].u.run.region);
d149 1
a149 1
	REGION_INIT(pScreen, &pScrPriv->layer[i].u.run.region, &box, 0);
d177 1
a177 1
    if (!prgn || !REGION_NOTEMPTY(pScreen, prgn))
d184 3
a186 4
	    REGION_UNION (pScreen,
			  &pScrPriv->layer[i].u.run.region,
			  &pScrPriv->layer[i].u.run.region,
			  prgn);
d188 1
a188 2
	else if (REGION_NOTEMPTY (pScreen, 
				  &pScrPriv->layer[i].u.run.region))
d191 3
a193 5
	    REGION_NULL (pScreen, &rgnNew);
	    REGION_INTERSECT (pScreen,
			      &rgnNew, 
			      prgn, 
			      &pScrPriv->layer[i].u.run.region);
d198 1
a198 1
	    REGION_UNINIT(pScreen, &rgnNew);
d200 3
a202 4
	    REGION_SUBTRACT (pScreen,
			     &pScrPriv->layer[i].u.run.region,
			     &pScrPriv->layer[i].u.run.region,
			     prgn);
d216 1
a216 1
    FbOverlayScrPrivPtr	pScrPriv = fbOverlayGetScrPriv(pWin->drawable.pScreen);
d229 4
a232 4
    REGION_TRANSLATE(pScreen, prgnSrc, -dx, -dy);
    REGION_NULL (pScreen, &rgnDst);
    REGION_INTERSECT(pScreen, &rgnDst, &pWin->borderClip, prgnSrc);
    REGION_TRANSLATE(pScreen, &rgnDst, dx, dy);
d238 2
a239 2
	REGION_NULL (pScreen, &layerRgn[i]);
	REGION_INTERSECT(pScreen, &layerRgn[i], &rgnDst,
d241 1
a241 1
	if (REGION_NOTEMPTY (pScreen, &layerRgn[i]))
d243 1
a243 1
	    REGION_TRANSLATE(pScreen, &layerRgn[i], -dx, -dy);
d256 1
a256 1
	if (REGION_NOTEMPTY (pScreen, &layerRgn[i]))
d259 1
a259 1
	REGION_UNINIT(pScreen, &layerRgn[i]);
d261 1
a261 1
    REGION_UNINIT(pScreen, &rgnDst);
d345 4
a348 1
    pScrPriv = xalloc (sizeof (FbOverlayScrPrivRec));
a415 1
    
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d251 1
a251 1
	    fbCopyRegion (&pPixmap->drawable, &pPixmap->drawable,
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d36 2
a37 1
static DevPrivateKey fbOverlayScreenPrivateKey = &fbOverlayScreenPrivateKey;
@


1.1
log
@Initial revision
@
text
@d36 1
a36 2
int	fbOverlayGeneration;
int	fbOverlayScreenPrivateIndex = -1;
d38 1
a38 1
int fbOverlayGetScreenPrivateIndex(void)
d40 1
a40 1
    return fbOverlayScreenPrivateIndex;
d67 1
a67 1
	    pWin->devPrivates[fbWinPrivateIndex].ptr = (pointer) pPixmap;
d110 1
a110 1
	if (pWin->devPrivates[fbWinPrivateIndex].ptr ==
d139 1
a139 1
	pPixmap = (*pScreen->CreatePixmap)(pScreen, 0, 0, depth);
a279 10
void
fbOverlayPaintWindow(WindowPtr pWin, RegionPtr pRegion, int what)
{
    if (what == PW_BORDER)
	fbOverlayUpdateLayerRegion (pWin->drawable.pScreen,
				    fbOverlayWindowLayer (pWin),
				    pRegion);
    fbPaintWindow (pWin, pRegion, what);
}

a349 6
    if (fbOverlayGeneration != serverGeneration)
    {
	fbOverlayScreenPrivateIndex = AllocateScreenPrivateIndex ();
	fbOverlayGeneration = serverGeneration;
    }

d399 1
a399 5
			defaultVisual, nvisuals, visuals
#ifdef FB_OLD_MISCREENINIT
		       , (miBSFuncPtr) 0
#endif
		       ))
d419 1
a419 1
    pScreen->devPrivates[fbOverlayScreenPrivateIndex].ptr = (pointer) pScrPriv;
a426 1
    pScreen->PaintWindowBorder = fbOverlayPaintWindow;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d416 5
a420 1
			defaultVisual, nvisuals, visuals))
@

