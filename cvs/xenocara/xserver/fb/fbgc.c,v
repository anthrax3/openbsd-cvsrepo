head	1.6;
access;
symbols
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.8
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	Te1daavkBLskZ8gc;

1.5
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.36;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.36;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright Â© 1998 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include "fb.h"

const GCFuncs fbGCFuncs = {
    fbValidateGC,
    miChangeGC,
    miCopyGC,
    miDestroyGC,
    miChangeClip,
    miDestroyClip,
    miCopyClip,
};

const GCOps fbGCOps = {
    fbFillSpans,
    fbSetSpans,
    fbPutImage,
    fbCopyArea,
    fbCopyPlane,
    fbPolyPoint,
    fbPolyLine,
    fbPolySegment,
    fbPolyRectangle,
    fbPolyArc,
    miFillPolygon,
    fbPolyFillRect,
    fbPolyFillArc,
    miPolyText8,
    miPolyText16,
    miImageText8,
    miImageText16,
    fbImageGlyphBlt,
    fbPolyGlyphBlt,
    fbPushPixels
};

Bool
fbCreateGC(GCPtr pGC)
{
    pGC->ops = (GCOps *) &fbGCOps;
    pGC->funcs = (GCFuncs *) &fbGCFuncs;

    /* fb wants to translate before scan conversion */
    pGC->miTranslate = 1;
    pGC->fExpose = 1;

    fbGetGCPrivate(pGC)->bpp = BitsPerPixel(pGC->depth);
    return TRUE;
}

/*
 * Pad pixmap to FB_UNIT bits wide
 */
void
fbPadPixmap(PixmapPtr pPixmap)
{
    int width;
    FbBits *bits;
    FbBits b;
    FbBits mask;
    int height;
    int w;
    int stride;
    int bpp;
    _X_UNUSED int xOff, yOff;

    fbGetDrawable(&pPixmap->drawable, bits, stride, bpp, xOff, yOff);

    width = pPixmap->drawable.width * pPixmap->drawable.bitsPerPixel;
    height = pPixmap->drawable.height;
    mask = FbBitsMask(0, width);
    while (height--) {
        b = READ(bits) & mask;
        w = width;
        while (w < FB_UNIT) {
            b = b | FbScrRight(b, w);
            w <<= 1;
        }
        WRITE(bits, b);
        bits += stride;
    }

    fbFinishAccess(&pPixmap->drawable);
}

void
fbValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDrawable)
{
    FbGCPrivPtr pPriv = fbGetGCPrivate(pGC);
    FbBits mask;

    /*
     * if the client clip is different or moved OR the subwindowMode has
     * changed OR the window's clip has changed since the last validation
     * we need to recompute the composite clip
     */

    if ((changes &
         (GCClipXOrigin | GCClipYOrigin | GCClipMask | GCSubwindowMode)) ||
        (pDrawable->serialNumber != (pGC->serialNumber & DRAWABLE_SERIAL_BITS))
        ) {
        miComputeCompositeClip(pGC, pDrawable);
    }

    if (pPriv->bpp != pDrawable->bitsPerPixel) {
        changes |= GCStipple | GCForeground | GCBackground | GCPlaneMask;
        pPriv->bpp = pDrawable->bitsPerPixel;
    }
    if ((changes & GCTile) && fbGetRotatedPixmap(pGC)) {
        (*pGC->pScreen->DestroyPixmap) (fbGetRotatedPixmap(pGC));
        fbGetRotatedPixmap(pGC) = 0;
    }

    if (pGC->fillStyle == FillTiled) {
        PixmapPtr pOldTile, pNewTile;

        pOldTile = pGC->tile.pixmap;
        if (pOldTile->drawable.bitsPerPixel != pDrawable->bitsPerPixel) {
            pNewTile = fbGetRotatedPixmap(pGC);
            if (!pNewTile ||
                pNewTile->drawable.bitsPerPixel != pDrawable->bitsPerPixel) {
                if (pNewTile)
                    (*pGC->pScreen->DestroyPixmap) (pNewTile);
                pNewTile =
                    fb24_32ReformatTile(pOldTile, pDrawable->bitsPerPixel);
            }
            if (pNewTile) {
                fbGetRotatedPixmap(pGC) = pOldTile;
                pGC->tile.pixmap = pNewTile;
                changes |= GCTile;
            }
        }
    }
    if (changes & GCTile) {
        if (!pGC->tileIsPixel &&
            FbEvenTile(pGC->tile.pixmap->drawable.width *
                       pDrawable->bitsPerPixel))
            fbPadPixmap(pGC->tile.pixmap);
    }
    if (changes & GCStipple) {
        if (pGC->stipple) {
            if (pGC->stipple->drawable.width * pDrawable->bitsPerPixel <
                FB_UNIT)
                fbPadPixmap(pGC->stipple);
        }
    }
    /*
     * Recompute reduced rop values
     */
    if (changes & (GCForeground | GCBackground | GCPlaneMask | GCFunction)) {
        int s;
        FbBits depthMask;

        mask = FbFullMask(pDrawable->bitsPerPixel);
        depthMask = FbFullMask(pDrawable->depth);

        pPriv->fg = pGC->fgPixel & mask;
        pPriv->bg = pGC->bgPixel & mask;

        if ((pGC->planemask & depthMask) == depthMask)
            pPriv->pm = mask;
        else
            pPriv->pm = pGC->planemask & mask;

        s = pDrawable->bitsPerPixel;
        while (s < FB_UNIT) {
            pPriv->fg |= pPriv->fg << s;
            pPriv->bg |= pPriv->bg << s;
            pPriv->pm |= pPriv->pm << s;
            s <<= 1;
        }
        pPriv->and = fbAnd(pGC->alu, pPriv->fg, pPriv->pm);
        pPriv->xor = fbXor(pGC->alu, pPriv->fg, pPriv->pm);
        pPriv->bgand = fbAnd(pGC->alu, pPriv->bg, pPriv->pm);
        pPriv->bgxor = fbXor(pGC->alu, pPriv->bg, pPriv->pm);
    }
    if (changes & GCDashList) {
        unsigned short n = pGC->numInDashList;
        unsigned char *dash = pGC->dash;
        unsigned int dashLength = 0;

        while (n--)
            dashLength += (unsigned int) *dash++;
        pPriv->dashLength = dashLength;
    }
}
@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a112 74
/*
 * Verify that 'bits' repeats every 'len' bits
 */
static Bool
fbBitsRepeat(FbBits bits, int len, int width)
{
    FbBits mask = FbBitsMask(0, len);
    FbBits orig = bits & mask;
    int i;

    if (width > FB_UNIT)
        width = FB_UNIT;
    for (i = 0; i < width / len; i++) {
        if ((bits & mask) != orig)
            return FALSE;
        bits = FbScrLeft(bits, len);
    }
    return TRUE;
}

/*
 * Check whether an entire bitmap line is a repetition of
 * the first 'len' bits
 */
static Bool
fbLineRepeat(FbBits * bits, int len, int width)
{
    FbBits first = bits[0];

    if (!fbBitsRepeat(first, len, width))
        return FALSE;
    width = (width + FB_UNIT - 1) >> FB_SHIFT;
    bits++;
    while (--width)
        if (READ(bits) != first)
            return FALSE;
    return TRUE;
}

/*
 * The even stipple code wants the first FB_UNIT/bpp bits on
 * each scanline to represent the entire stipple
 */
static Bool
fbCanEvenStipple(PixmapPtr pStipple, int bpp)
{
    int len = FB_UNIT / bpp;
    FbBits *bits;
    int stride;
    int stip_bpp;
    _X_UNUSED int stipXoff, stipYoff;
    int h;

    /* can't even stipple 24bpp drawables */
    if ((bpp & (bpp - 1)) != 0)
        return FALSE;
    /* make sure the stipple width is a multiple of the even stipple width */
    if (pStipple->drawable.width % len != 0)
        return FALSE;
    fbGetDrawable(&pStipple->drawable, bits, stride, stip_bpp, stipXoff,
                  stipYoff);
    h = pStipple->drawable.height;
    /* check to see that the stipple repeats horizontally */
    while (h--) {
        if (!fbLineRepeat(bits, len, pStipple->drawable.width)) {
            fbFinishAccess(&pStipple->drawable);
            return FALSE;
        }
        bits += stride;
    }
    fbFinishAccess(&pStipple->drawable);
    return TRUE;
}

d122 1
a122 1
     * we need to recompute the composite clip 
a167 2
        pPriv->evenStipple = FALSE;

a168 7

            /* can we do an even stipple ?? */
            if (FbEvenStip(pGC->stipple->drawable.width,
                           pDrawable->bitsPerPixel) &&
                (fbCanEvenStipple(pGC->stipple, pDrawable->bitsPerPixel)))
                pPriv->evenStipple = TRUE;

@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d67 2
a68 2
    pGC->ops = (GCOps *) & fbGCOps;
    pGC->funcs = (GCFuncs *) & fbGCFuncs;
@


1.3
log
@Update to xserver 1.11.2
@
text
@d41 1
a41 1
const GCOps	fbGCOps = {
d67 2
a68 2
    pGC->ops = (GCOps *) &fbGCOps;
    pGC->funcs = (GCFuncs *) &fbGCFuncs;
d74 1
a74 1
    fbGetGCPrivate(pGC)->bpp = BitsPerPixel (pGC->depth);
d82 1
a82 1
fbPadPixmap (PixmapPtr pPixmap)
d84 8
a91 8
    int	    width;
    FbBits  *bits;
    FbBits  b;
    FbBits  mask;
    int	    height;
    int	    w;
    int     stride;
    int     bpp;
d94 1
a94 1
    fbGetDrawable (&pPixmap->drawable, bits, stride, bpp, xOff, yOff);
d98 10
a107 12
    mask = FbBitsMask (0, width);
    while (height--)
    {
	b = READ(bits) & mask;
	w = width;
	while (w < FB_UNIT)
	{
	    b = b | FbScrRight(b, w);
	    w <<= 1;
	}
	WRITE(bits, b);
	bits += stride;
d110 1
a110 1
    fbFinishAccess (&pPixmap->drawable);
d117 1
a117 1
fbBitsRepeat (FbBits bits, int len, int width)
d119 4
a122 4
    FbBits  mask = FbBitsMask(0, len);
    FbBits  orig = bits & mask;
    int	    i;
    
d124 5
a128 6
	width = FB_UNIT;
    for (i = 0; i < width / len; i++)
    {
	if ((bits & mask) != orig)
	    return FALSE;
	bits = FbScrLeft(bits,len);
d138 1
a138 1
fbLineRepeat (FbBits *bits, int len, int width)
d140 5
a144 5
    FbBits  first = bits[0];
    
    if (!fbBitsRepeat (first, len, width))
	return FALSE;
    width = (width + FB_UNIT-1) >> FB_SHIFT;
d147 2
a148 2
	if (READ(bits) != first)
	    return FALSE;
d157 1
a157 1
fbCanEvenStipple (PixmapPtr pStipple, int bpp)
d159 4
a162 4
    int	    len = FB_UNIT / bpp;
    FbBits  *bits;
    int	    stride;
    int	    stip_bpp;
d164 1
a164 1
    int	    h;
d167 2
a168 2
    if ((bpp & (bpp-1)) != 0)
	return FALSE;
d171 3
a173 2
	return FALSE;
    fbGetDrawable (&pStipple->drawable, bits, stride, stip_bpp, stipXoff, stipYoff);
d176 6
a181 7
    while (h--)
    {
	if (!fbLineRepeat (bits, len, pStipple->drawable.width)) {
	    fbFinishAccess (&pStipple->drawable);
	    return FALSE;
	}
	bits += stride;
d183 1
a183 1
    fbFinishAccess (&pStipple->drawable);
d190 2
a191 2
    FbGCPrivPtr	pPriv = fbGetGCPrivate(pGC);
    FbBits	mask;
d199 57
a255 62
    if ((changes & (GCClipXOrigin|GCClipYOrigin|GCClipMask|GCSubwindowMode)) ||
	(pDrawable->serialNumber != (pGC->serialNumber & DRAWABLE_SERIAL_BITS))
	)
    {
	miComputeCompositeClip (pGC, pDrawable);
    }
    
    if (pPriv->bpp != pDrawable->bitsPerPixel)
    {
	changes |= GCStipple|GCForeground|GCBackground|GCPlaneMask;
	pPriv->bpp = pDrawable->bitsPerPixel;
    }
    if ((changes & GCTile) && fbGetRotatedPixmap(pGC))
    {
	(*pGC->pScreen->DestroyPixmap) (fbGetRotatedPixmap(pGC));
	fbGetRotatedPixmap(pGC) = 0;
    }
	
    if (pGC->fillStyle == FillTiled)
    {
	PixmapPtr	pOldTile, pNewTile;

	pOldTile = pGC->tile.pixmap;
	if (pOldTile->drawable.bitsPerPixel != pDrawable->bitsPerPixel)
	{
	    pNewTile = fbGetRotatedPixmap(pGC);
	    if (!pNewTile || pNewTile ->drawable.bitsPerPixel != pDrawable->bitsPerPixel)
	    {
		if (pNewTile)
		    (*pGC->pScreen->DestroyPixmap) (pNewTile);
		pNewTile = fb24_32ReformatTile (pOldTile, pDrawable->bitsPerPixel);
	    }
	    if (pNewTile)
	    {
		fbGetRotatedPixmap(pGC) = pOldTile;
		pGC->tile.pixmap = pNewTile;
		changes |= GCTile;
	    }
	}
    }
    if (changes & GCTile)
    {
	if (!pGC->tileIsPixel && 
	    FbEvenTile (pGC->tile.pixmap->drawable.width *
			pDrawable->bitsPerPixel))
	    fbPadPixmap (pGC->tile.pixmap);
    }
    if (changes & GCStipple)
    {
	pPriv->evenStipple = FALSE;

	if (pGC->stipple) {

	    /* can we do an even stipple ?? */
	    if (FbEvenStip (pGC->stipple->drawable.width,
						pDrawable->bitsPerPixel) &&
	       (fbCanEvenStipple (pGC->stipple, pDrawable->bitsPerPixel)))
	   	pPriv->evenStipple = TRUE;

	    if (pGC->stipple->drawable.width * pDrawable->bitsPerPixel < FB_UNIT)
		fbPadPixmap (pGC->stipple);
	}
d260 35
a294 38
    if (changes & (GCForeground|GCBackground|GCPlaneMask|GCFunction))
    {
	int	s;
	FbBits	depthMask;
	
	mask = FbFullMask(pDrawable->bitsPerPixel);
	depthMask = FbFullMask(pDrawable->depth);
	
	pPriv->fg = pGC->fgPixel & mask;
	pPriv->bg = pGC->bgPixel & mask;
	
	if ((pGC->planemask & depthMask) == depthMask)
	    pPriv->pm = mask;
	else
	    pPriv->pm = pGC->planemask & mask;    
	
	s = pDrawable->bitsPerPixel;
	while (s < FB_UNIT)
	{
	    pPriv->fg |= pPriv->fg << s;
	    pPriv->bg |= pPriv->bg << s;
	    pPriv->pm |= pPriv->pm << s;
	    s <<= 1;
	}
	pPriv->and = fbAnd(pGC->alu, pPriv->fg, pPriv->pm);
	pPriv->xor = fbXor(pGC->alu, pPriv->fg, pPriv->pm);
	pPriv->bgand = fbAnd(pGC->alu, pPriv->bg, pPriv->pm);
	pPriv->bgxor = fbXor(pGC->alu, pPriv->bg, pPriv->pm);
    }
    if (changes & GCDashList)
    {
	unsigned short	n = pGC->numInDashList;
	unsigned char	*dash = pGC->dash;
	unsigned int	dashLength = 0;

	while (n--)
	    dashLength += (unsigned int ) *dash++;
	pPriv->dashLength = dashLength;
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a66 3
    pGC->clientClip = NULL;
    pGC->clientClipType = CT_NONE;

d72 1
a73 4
    fbGetRotatedPixmap(pGC) = 0;
    fbGetExpose(pGC) = 1;
    fbGetFreeCompClip(pGC) = 0;
    fbGetCompositeClip(pGC) = 0;
d92 1
a92 1
    int     xOff, yOff;
d166 1
a166 1
    int	    stipXoff, stipYoff;
a195 3
    pGC->lastWinOrg.x = pDrawable->x;
    pGC->lastWinOrg.y = pDrawable->y;

a206 1
	pPriv->oneRect = RegionNumRects(fbGetCompositeClip(pGC)) == 1;
a208 1
#ifdef FB_24_32BIT    
a241 1
#endif
@


1.1
log
@Initial revision
@
text
@a1 2
 * Id: fbgc.c,v 1.1 1999/11/02 03:54:45 keithp Exp $
 *
d107 1
a107 1
	b = *bits & mask;
d114 1
a114 1
	*bits = b;
d117 2
d156 1
a156 1
	if (*bits != first)
d186 2
a187 1
	if (!fbLineRepeat (bits, len, pStipple->drawable.width))
d189 1
d192 1
d216 1
a216 1
	pPriv->oneRect = REGION_NUM_RECTS(fbGetCompositeClip(pGC)) == 1;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d109 1
a109 1
	b = READ(bits) & mask;
d116 1
a116 1
	WRITE(bits, b);
a118 2

    fbFinishAccess (&pPixmap->drawable);
d156 1
a156 1
	if (READ(bits) != first)
d186 1
a186 2
	if (!fbLineRepeat (bits, len, pStipple->drawable.width)) {
	    fbFinishAccess (&pStipple->drawable);
a187 1
	}
a189 1
    fbFinishAccess (&pStipple->drawable);
@

