head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.2
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.10
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	Te1daavkBLskZ8gc;

1.7
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	cVXoV5PxI8YrEaVA;

1.6
date	2013.09.28.15.36.34;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.41;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.32;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * Copyright Â© 1998 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include "fb.h"

PixmapPtr
fbCreatePixmapBpp(ScreenPtr pScreen, int width, int height, int depth, int bpp,
                  unsigned usage_hint)
{
    PixmapPtr pPixmap;
    size_t datasize;
    size_t paddedWidth;
    int adjust;
    int base;

    paddedWidth = ((width * bpp + FB_MASK) >> FB_SHIFT) * sizeof(FbBits);
    if (paddedWidth / 4 > 32767 || height > 32767)
        return NullPixmap;
    datasize = height * paddedWidth;
    base = pScreen->totalPixmapSize;
    adjust = 0;
    if (base & 7)
        adjust = 8 - (base & 7);
    datasize += adjust;
#ifdef FB_DEBUG
    datasize += 2 * paddedWidth;
#endif
    pPixmap = AllocatePixmap(pScreen, datasize);
    if (!pPixmap)
        return NullPixmap;
    pPixmap->drawable.type = DRAWABLE_PIXMAP;
    pPixmap->drawable.class = 0;
    pPixmap->drawable.pScreen = pScreen;
    pPixmap->drawable.depth = depth;
    pPixmap->drawable.bitsPerPixel = bpp;
    pPixmap->drawable.id = 0;
    pPixmap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
    pPixmap->drawable.x = 0;
    pPixmap->drawable.y = 0;
    pPixmap->drawable.width = width;
    pPixmap->drawable.height = height;
    pPixmap->devKind = paddedWidth;
    pPixmap->refcnt = 1;
    pPixmap->devPrivate.ptr = (void *) ((char *) pPixmap + base + adjust);
    pPixmap->master_pixmap = NULL;

#ifdef FB_DEBUG
    pPixmap->devPrivate.ptr =
        (void *) ((char *) pPixmap->devPrivate.ptr + paddedWidth);
    fbInitializeDrawable(&pPixmap->drawable);
#endif

#ifdef COMPOSITE
    pPixmap->screen_x = 0;
    pPixmap->screen_y = 0;
#endif

    pPixmap->usage_hint = usage_hint;

    return pPixmap;
}

PixmapPtr
fbCreatePixmap(ScreenPtr pScreen, int width, int height, int depth,
               unsigned usage_hint)
{
    int bpp;

    bpp = BitsPerPixel(depth);
    if (bpp == 32 && depth <= 24)
        bpp = fbGetScreenPrivate(pScreen)->pix32bpp;
    return fbCreatePixmapBpp(pScreen, width, height, depth, bpp, usage_hint);
}

Bool
fbDestroyPixmap(PixmapPtr pPixmap)
{
    if (--pPixmap->refcnt)
        return TRUE;
    FreePixmap(pPixmap);
    return TRUE;
}

#define ADDRECT(reg,r,fr,rx1,ry1,rx2,ry2)			\
if (((rx1) < (rx2)) && ((ry1) < (ry2)) &&			\
    (!((reg)->data->numRects &&					\
       ((r-1)->y1 == (ry1)) &&					\
       ((r-1)->y2 == (ry2)) &&					\
       ((r-1)->x1 <= (rx1)) &&					\
       ((r-1)->x2 >= (rx2)))))					\
{								\
    if ((reg)->data->numRects == (reg)->data->size)		\
    {								\
	RegionRectAlloc(reg, 1);					\
	fr = RegionBoxptr(reg);				\
	r = fr + (reg)->data->numRects;				\
    }								\
    r->x1 = (rx1);						\
    r->y1 = (ry1);						\
    r->x2 = (rx2);						\
    r->y2 = (ry2);						\
    (reg)->data->numRects++;					\
    if(r->x1 < (reg)->extents.x1)				\
	(reg)->extents.x1 = r->x1;				\
    if(r->x2 > (reg)->extents.x2)				\
	(reg)->extents.x2 = r->x2;				\
    r++;							\
}

/* Convert bitmap clip mask into clipping region.
 * First, goes through each line and makes boxes by noting the transitions
 * from 0 to 1 and 1 to 0.
 * Then it coalesces the current line with the previous if they have boxes
 * at the same X coordinates.
 */
RegionPtr
fbPixmapToRegion(PixmapPtr pPix)
{
    register RegionPtr pReg;
    FbBits *pw, w;
    register int ib;
    int width, h, base, rx1 = 0, crects;
    FbBits *pwLineEnd;
    int irectPrevStart, irectLineStart;
    register BoxPtr prectO, prectN;
    BoxPtr FirstRect, rects, prectLineStart;
    Bool fInBox, fSame;
    register FbBits mask0 = FB_ALLONES & ~FbScrRight(FB_ALLONES, 1);
    FbBits *pwLine;
    int nWidth;

    pReg = RegionCreate(NULL, 1);
    if (!pReg)
        return NullRegion;
    FirstRect = RegionBoxptr(pReg);
    rects = FirstRect;

    fbPrepareAccess(&pPix->drawable);

    pwLine = (FbBits *) pPix->devPrivate.ptr;
    nWidth = pPix->devKind >> (FB_SHIFT - 3);

    width = pPix->drawable.width;
    pReg->extents.x1 = width - 1;
    pReg->extents.x2 = 0;
    irectPrevStart = -1;
    for (h = 0; h < pPix->drawable.height; h++) {
        pw = pwLine;
        pwLine += nWidth;
        irectLineStart = rects - FirstRect;
        /* If the Screen left most bit of the word is set, we're starting in
         * a box */
        if (READ(pw) & mask0) {
            fInBox = TRUE;
            rx1 = 0;
        }
        else
            fInBox = FALSE;
        /* Process all words which are fully in the pixmap */
        pwLineEnd = pw + (width >> FB_SHIFT);
        for (base = 0; pw < pwLineEnd; base += FB_UNIT) {
            w = READ(pw++);
            if (fInBox) {
                if (!~w)
                    continue;
            }
            else {
                if (!w)
                    continue;
            }
            for (ib = 0; ib < FB_UNIT; ib++) {
                /* If the Screen left most bit of the word is set, we're
                 * starting a box */
                if (w & mask0) {
                    if (!fInBox) {
                        rx1 = base + ib;
                        /* start new box */
                        fInBox = TRUE;
                    }
                }
                else {
                    if (fInBox) {
                        /* end box */
                        ADDRECT(pReg, rects, FirstRect,
                                rx1, h, base + ib, h + 1);
                        fInBox = FALSE;
                    }
                }
                /* Shift the word VISUALLY left one. */
                w = FbScrLeft(w, 1);
            }
        }
        if (width & FB_MASK) {
            /* Process final partial word on line */
            w = READ(pw++);
            for (ib = 0; ib < (width & FB_MASK); ib++) {
                /* If the Screen left most bit of the word is set, we're
                 * starting a box */
                if (w & mask0) {
                    if (!fInBox) {
                        rx1 = base + ib;
                        /* start new box */
                        fInBox = TRUE;
                    }
                }
                else {
                    if (fInBox) {
                        /* end box */
                        ADDRECT(pReg, rects, FirstRect,
                                rx1, h, base + ib, h + 1);
                        fInBox = FALSE;
                    }
                }
                /* Shift the word VISUALLY left one. */
                w = FbScrLeft(w, 1);
            }
        }
        /* If scanline ended with last bit set, end the box */
        if (fInBox) {
            ADDRECT(pReg, rects, FirstRect,
                    rx1, h, base + (width & FB_MASK), h + 1);
        }
        /* if all rectangles on this line have the same x-coords as
         * those on the previous line, then add 1 to all the previous  y2s and
         * throw away all the rectangles from this line
         */
        fSame = FALSE;
        if (irectPrevStart != -1) {
            crects = irectLineStart - irectPrevStart;
            if (crects == ((rects - FirstRect) - irectLineStart)) {
                prectO = FirstRect + irectPrevStart;
                prectN = prectLineStart = FirstRect + irectLineStart;
                fSame = TRUE;
                while (prectO < prectLineStart) {
                    if ((prectO->x1 != prectN->x1) ||
                        (prectO->x2 != prectN->x2)) {
                        fSame = FALSE;
                        break;
                    }
                    prectO++;
                    prectN++;
                }
                if (fSame) {
                    prectO = FirstRect + irectPrevStart;
                    while (prectO < prectLineStart) {
                        prectO->y2 += 1;
                        prectO++;
                    }
                    rects -= crects;
                    pReg->data->numRects -= crects;
                }
            }
        }
        if (!fSame)
            irectPrevStart = irectLineStart;
    }
    if (!pReg->data->numRects)
        pReg->extents.x1 = pReg->extents.x2 = 0;
    else {
        pReg->extents.y1 = RegionBoxptr(pReg)->y1;
        pReg->extents.y2 = RegionEnd(pReg)->y2;
        if (pReg->data->numRects == 1) {
            free(pReg->data);
            pReg->data = (RegDataPtr) NULL;
        }
    }

    fbFinishAccess(&pPix->drawable);
#ifdef DEBUG
    if (!RegionIsValid(pReg))
        FatalError("Assertion failed file %s, line %d: expr\n", __FILE__,
                   __LINE__);
#endif
    return pReg;
}

#ifdef FB_DEBUG

#ifndef WIN32
#include <stdio.h>
#else
#include <dbg.h>
#endif

static Bool
fbValidateBits(FbStip * bits, int stride, FbStip data)
{
    while (stride--) {
        if (*bits != data) {
#ifdef WIN32
            NCD_DEBUG((DEBUG_FAILURE,
                       "fdValidateBits failed at 0x%x (is 0x%x want 0x%x)",
                       bits, *bits, data));
#else
            fprintf(stderr, "fbValidateBits failed\n");
#endif
            return FALSE;
        }
        bits++;
    }
}

void
fbValidateDrawable(DrawablePtr pDrawable)
{
    FbStip *bits, *first, *last;
    int stride, bpp;
    int xoff, yoff;
    int height;
    Bool failed;

    if (pDrawable->type != DRAWABLE_PIXMAP)
        pDrawable = (DrawablePtr) fbGetWindowPixmap(pDrawable);
    fbGetStipDrawable(pDrawable, bits, stride, bpp, xoff, yoff);
    first = bits - stride;
    last = bits + stride * pDrawable->height;
    if (!fbValidateBits(first, stride, FB_HEAD_BITS) ||
        !fbValidateBits(last, stride, FB_TAIL_BITS))
        fbInitializeDrawable(pDrawable);
    fbFinishAccess(pDrawable);
}

void
fbSetBits(FbStip * bits, int stride, FbStip data)
{
    while (stride--)
        *bits++ = data;
}

void
fbInitializeDrawable(DrawablePtr pDrawable)
{
    FbStip *bits, *first, *last;
    int stride, bpp;
    int xoff, yoff;

    fbGetStipDrawable(pDrawable, bits, stride, bpp, xoff, yoff);
    first = bits - stride;
    last = bits + stride * pDrawable->height;
    fbSetBits(first, stride, FB_HEAD_BITS);
    fbSetBits(last, stride, FB_TAIL_BITS);
    fbFinishAccess(pDrawable);
}
#endif                          /* FB_DEBUG */
@


1.7
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d135 1
a135 1
/* Convert bitmap clip mask into clipping region. 
d249 2
a250 2
         * those on the previous line, then add 1 to all the previous  y2s and 
         * throw away all the rectangles from this line 
@


1.6
log
@Update to xserver 1.14.3
@
text
@d69 1
a69 1
    pPixmap->devPrivate.ptr = (pointer) ((char *) pPixmap + base + adjust);
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d70 1
@


1.4
log
@Update to xserver 1.11.2
@
text
@d32 2
a33 2
fbCreatePixmapBpp (ScreenPtr pScreen, int width, int height, int depth, int bpp,
		   unsigned usage_hint)
d35 5
a39 5
    PixmapPtr	pPixmap;
    size_t	datasize;
    size_t	paddedWidth;
    int		adjust;
    int		base;
d41 1
a41 1
    paddedWidth = ((width * bpp + FB_MASK) >> FB_SHIFT) * sizeof (FbBits);
d43 1
a43 1
	return NullPixmap;
d48 1
a48 1
	adjust = 8 - (base & 7);
d55 1
a55 1
	return NullPixmap;
d69 1
a69 1
    pPixmap->devPrivate.ptr = (pointer) ((char *)pPixmap + base + adjust);
d72 3
a74 2
    pPixmap->devPrivate.ptr = (void *) ((char *) pPixmap->devPrivate.ptr + paddedWidth);
    fbInitializeDrawable (&pPixmap->drawable);
d88 2
a89 2
fbCreatePixmap (ScreenPtr pScreen, int width, int height, int depth,
		unsigned usage_hint)
d91 3
a93 2
    int	bpp;
    bpp = BitsPerPixel (depth);
d95 2
a96 2
	bpp = fbGetScreenPrivate(pScreen)->pix32bpp;
    return fbCreatePixmapBpp (pScreen, width, height, depth, bpp, usage_hint);
d100 1
a100 1
fbDestroyPixmap (PixmapPtr pPixmap)
d102 2
a103 2
    if(--pPixmap->refcnt)
	return TRUE;
d143 13
a155 13
    register RegionPtr	pReg;
    FbBits		*pw, w;
    register int	ib;
    int			width, h, base, rx1 = 0, crects;
    FbBits		*pwLineEnd;
    int			irectPrevStart, irectLineStart;
    register BoxPtr	prectO, prectN;
    BoxPtr		FirstRect, rects, prectLineStart;
    Bool		fInBox, fSame;
    register FbBits	mask0 = FB_ALLONES & ~FbScrRight(FB_ALLONES, 1);
    FbBits		*pwLine;
    int			nWidth;
    
d157 2
a158 2
    if(!pReg)
	return NullRegion;
d165 1
a165 1
    nWidth = pPix->devKind >> (FB_SHIFT-3);
d171 109
a279 131
    for(h = 0; h < pPix->drawable.height; h++)
    {
	pw = pwLine;
	pwLine += nWidth;
	irectLineStart = rects - FirstRect;
	/* If the Screen left most bit of the word is set, we're starting in
	 * a box */
	if(READ(pw) & mask0)
	{
	    fInBox = TRUE;
	    rx1 = 0;
	}
	else
	    fInBox = FALSE;
	/* Process all words which are fully in the pixmap */
	pwLineEnd = pw + (width >> FB_SHIFT);
	for (base = 0; pw < pwLineEnd; base += FB_UNIT)
	{
	    w = READ(pw++);
	    if (fInBox)
	    {
		if (!~w)
		    continue;
	    }
	    else
	    {
		if (!w)
		    continue;
	    }
	    for(ib = 0; ib < FB_UNIT; ib++)
	    {
	        /* If the Screen left most bit of the word is set, we're
		 * starting a box */
		if(w & mask0)
		{
		    if(!fInBox)
		    {
			rx1 = base + ib;
			/* start new box */
			fInBox = TRUE;
		    }
		}
		else
		{
		    if(fInBox)
		    {
			/* end box */
			ADDRECT(pReg, rects, FirstRect,
				rx1, h, base + ib, h + 1);
			fInBox = FALSE;
		    }
		}
		/* Shift the word VISUALLY left one. */
		w = FbScrLeft(w, 1);
	    }
	}
	if(width & FB_MASK)
	{
	    /* Process final partial word on line */
	    w = READ(pw++);
	    for(ib = 0; ib < (width & FB_MASK); ib++)
	    {
	        /* If the Screen left most bit of the word is set, we're
		 * starting a box */
		if(w & mask0)
		{
		    if(!fInBox)
		    {
			rx1 = base + ib;
			/* start new box */
			fInBox = TRUE;
		    }
		}
		else
		{
		    if(fInBox)
		    {
			/* end box */
			ADDRECT(pReg, rects, FirstRect,
				rx1, h, base + ib, h + 1);
			fInBox = FALSE;
		    }
		}
		/* Shift the word VISUALLY left one. */
		w = FbScrLeft(w, 1);
	    }
	}
	/* If scanline ended with last bit set, end the box */
	if(fInBox)
	{
	    ADDRECT(pReg, rects, FirstRect,
		    rx1, h, base + (width & FB_MASK), h + 1);
	}
	/* if all rectangles on this line have the same x-coords as
	 * those on the previous line, then add 1 to all the previous  y2s and 
	 * throw away all the rectangles from this line 
	 */
	fSame = FALSE;
	if(irectPrevStart != -1)
	{
	    crects = irectLineStart - irectPrevStart;
	    if(crects == ((rects - FirstRect) - irectLineStart))
	    {
	        prectO = FirstRect + irectPrevStart;
	        prectN = prectLineStart = FirstRect + irectLineStart;
		fSame = TRUE;
	        while(prectO < prectLineStart)
		{
		    if((prectO->x1 != prectN->x1) || (prectO->x2 != prectN->x2))
		    {
			  fSame = FALSE;
			  break;
		    }
		    prectO++;
		    prectN++;
		}
		if (fSame)
		{
		    prectO = FirstRect + irectPrevStart;
		    while(prectO < prectLineStart)
		    {
			prectO->y2 += 1;
			prectO++;
		    }
		    rects -= crects;
		    pReg->data->numRects -= crects;
		}
	    }
	}
	if(!fSame)
	    irectPrevStart = irectLineStart;
d282 8
a289 10
	pReg->extents.x1 = pReg->extents.x2 = 0;
    else
    {
	pReg->extents.y1 = RegionBoxptr(pReg)->y1;
	pReg->extents.y2 = RegionEnd(pReg)->y2;
	if (pReg->data->numRects == 1)
	{
	    free(pReg->data);
	    pReg->data = (RegDataPtr)NULL;
	}
d295 2
a296 1
	FatalError("Assertion failed file %s, line %d: expr\n", __FILE__, __LINE__);
d310 1
a310 1
fbValidateBits (FbStip *bits, int stride, FbStip data)
d312 2
a313 4
    while (stride--)
    {
	if (*bits != data)
	{
d315 3
a317 2
	    NCD_DEBUG ((DEBUG_FAILURE, "fdValidateBits failed at 0x%x (is 0x%x want 0x%x)",
			bits, *bits, data));
d319 1
a319 1
	    fprintf (stderr, "fbValidateBits failed\n");
d321 3
a323 3
	    return FALSE;
	}
	bits++;
d328 1
a328 1
fbValidateDrawable (DrawablePtr pDrawable)
d330 6
a335 6
    FbStip	*bits, *first, *last;
    int		stride, bpp;
    int		xoff, yoff;
    int		height;
    Bool	failed;
    
d337 1
a337 1
	pDrawable = (DrawablePtr) fbGetWindowPixmap(pDrawable);
d341 4
a344 4
    if (!fbValidateBits (first, stride, FB_HEAD_BITS) ||
	!fbValidateBits (last, stride, FB_TAIL_BITS))
	fbInitializeDrawable(pDrawable);
    fbFinishAccess (pDrawable);
d348 1
a348 1
fbSetBits (FbStip *bits, int stride, FbStip data)
d351 1
a351 1
	*bits++ = data;
d355 1
a355 1
fbInitializeDrawable (DrawablePtr pDrawable)
d357 4
a360 4
    FbStip  *bits, *first, *last;
    int	    stride, bpp;
    int	    xoff, yoff;
    
d364 3
a366 3
    fbSetBits (first, stride, FB_HEAD_BITS);
    fbSetBits (last, stride, FB_TAIL_BITS);
    fbFinishAccess (pDrawable);
d368 1
a368 1
#endif /* FB_DEBUG */
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a91 1
#ifdef FB_SCREEN_PRIVATE
a93 1
#endif
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d70 1
d104 1
a104 2
    dixFreePrivates(pPixmap->devPrivates);
    xfree(pPixmap);
d118 2
a119 2
	miRectAlloc(reg, 1);					\
	fr = REGION_BOXPTR(reg);				\
d156 1
a156 1
    pReg = REGION_CREATE(pPix->drawable.pScreen, NULL, 1);
d159 1
a159 1
    FirstRect = REGION_BOXPTR(pReg);
d307 2
a308 2
	pReg->extents.y1 = REGION_BOXPTR(pReg)->y1;
	pReg->extents.y2 = REGION_END(pReg)->y2;
d311 1
a311 1
	    xfree(pReg->data);
d318 1
a318 1
    if (!miValidRegion(pReg))
d321 1
a321 1
    return(pReg);
@


1.1
log
@Initial revision
@
text
@a1 2
 * Id: fbpixmap.c,v 1.1 1999/11/02 03:54:45 keithp Exp $
 *
d32 2
a33 1
fbCreatePixmapBpp (ScreenPtr pScreen, int width, int height, int depth, int bpp)
a44 1
#ifdef PIXPRIV
a45 3
#else
    base = sizeof (PixmapRec);
#endif
d80 2
d86 2
a87 1
fbCreatePixmap (ScreenPtr pScreen, int width, int height, int depth)
d95 1
a95 1
    return fbCreatePixmapBpp (pScreen, width, height, depth, bpp);
d103 1
d162 2
d178 1
a178 1
	if(*pw & mask0)
d189 1
a189 1
	    w = *pw++;
d230 1
a230 1
	    w = *pw++;
d315 2
d368 1
d390 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d46 1
d48 3
a162 2
    fbPrepareAccess(&pPix->drawable);

d177 1
a177 1
	if(READ(pw) & mask0)
d188 1
a188 1
	    w = READ(pw++);
d229 1
a229 1
	    w = READ(pw++);
a313 2

    fbFinishAccess(&pPix->drawable);
a364 1
    fbFinishAccess (pDrawable);
a385 1
    fbFinishAccess (pDrawable);
@

