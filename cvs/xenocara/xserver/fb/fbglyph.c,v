head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.8
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.6
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	Te1daavkBLskZ8gc;

1.5
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	cVXoV5PxI8YrEaVA;

1.4
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.41;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.41;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.31;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *
 * Copyright Â© 1998 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "fb.h"
#include	<X11/fonts/fontstruct.h>
#include	"dixfontstr.h"

static Bool
fbGlyphIn(RegionPtr pRegion, int x, int y, int width, int height)
{
    BoxRec box;
    BoxPtr pExtents = RegionExtents(pRegion);

    /*
     * Check extents by hand to avoid 16 bit overflows
     */
    if (x < (int) pExtents->x1)
        return FALSE;
    if ((int) pExtents->x2 < x + width)
        return FALSE;
    if (y < (int) pExtents->y1)
        return FALSE;
    if ((int) pExtents->y2 < y + height)
        return FALSE;
    box.x1 = x;
    box.x2 = x + width;
    box.y1 = y;
    box.y2 = y + height;
    return RegionContainsRect(pRegion, &box) == rgnIN;
}

#define WRITE1(d,n,fg)	WRITE((d) + (n), (CARD8) fg)
#define WRITE2(d,n,fg)	WRITE((CARD16 *) &(d[n]), (CARD16) fg)
#define WRITE4(d,n,fg)	WRITE((CARD32 *) &(d[n]), (CARD32) fg)
#define WRITE8(d)	WRITE4(d,0,_ABCA), WRITE4(d,4,_BCAB)

/*
 * This is a bit tricky, but it's brief.  Write 12 bytes worth
 * of dest, which is four pixels, at a time.  This gives constant
 * code for each pattern as they're always aligned the same
 *
 *  a b c d  a b c d  a b c d	bytes
 *  A B C A  B C A B  C A B C	pixels
 *
 *    f0        f1       f2
 *  A B C A  B C A B  C A B C	pixels LSB
 *  C A B C  A B C A  B C A B	pixels MSB
 *
 *		LSB	MSB
 *  A		f0	f1
 *  B		f1	f2
 *  C		f2	f0
 *  A B		f0	f2
 *  B C		f1	f0
 *  C A		f2	f1
 *  A B C A	f0	f1
 *  B C A B	f1    	f2
 *  C A B C	f2	f0
 */

#undef _A
#undef _B
#undef _C
#undef _AB
#undef _BC
#undef _CA
#undef _ABCA
#undef _BCAB
#undef _CABC

#if IMAGE_BYTE_ORDER == MSBFirst
#define _A	f1
#define _B	f2
#define _C	f0
#define _AB	f2
#define _BC	f0
#define _CA	f1
#define _ABCA	f1
#define _BCAB	f2
#define _CABC	f0
#define CASE(a,b,c,d)	((a << 3) | (b << 2) | (c << 1) | d)
#else
#define _A	f0
#define _B	f1
#define _C	f2
#define _AB	f0
#define _BC	f1
#define _CA	f2
#define _ABCA	f0
#define _BCAB	f1
#define _CABC	f2
#define CASE(a,b,c,d)	(a | (b << 1) | (c << 2) | (d << 3))
#endif

static void
fbGlyph24(FbBits * dstBits,
          FbStride dstStride,
          int dstBpp, FbStip * stipple, FbBits fg, int x, int height)
{
    int lshift;
    FbStip bits;
    CARD8 *dstLine;
    CARD8 *dst;
    FbStip f0, f1, f2;
    int n;
    int shift;

    f0 = fg;
    f1 = FbRot24(f0, 16);
    f2 = FbRot24(f0, 8);

    dstLine = (CARD8 *) dstBits;
    dstLine += (x & ~3) * 3;
    dstStride *= (sizeof(FbBits) / sizeof(CARD8));
    shift = x & 3;
    lshift = 4 - shift;
    while (height--) {
        bits = READ(stipple++);
        n = lshift;
        dst = dstLine;
        while (bits) {
            switch (FbStipMoveLsb(FbLeftStipBits(bits, n), 4, n)) {
            case CASE(0, 0, 0, 0):
                break;
            case CASE(1, 0, 0, 0):
                WRITE2(dst, 0, _AB);
                WRITE1(dst, 2, _C);
                break;
            case CASE(0, 1, 0, 0):
                WRITE1(dst, 3, _A);
                WRITE2(dst, 4, _BC);
                break;
            case CASE(1, 1, 0, 0):
                WRITE4(dst, 0, _ABCA);
                WRITE2(dst, 4, _BC);
                break;
            case CASE(0, 0, 1, 0):
                WRITE2(dst, 6, _AB);
                WRITE1(dst, 8, _C);
                break;
            case CASE(1, 0, 1, 0):
                WRITE2(dst, 0, _AB);
                WRITE1(dst, 2, _C);

                WRITE2(dst, 6, _AB);
                WRITE1(dst, 8, _C);
                break;
            case CASE(0, 1, 1, 0):
                WRITE1(dst, 3, _A);
                WRITE4(dst, 4, _BCAB);
                WRITE1(dst, 8, _C);
                break;
            case CASE(1, 1, 1, 0):
                WRITE8(dst);
                WRITE1(dst, 8, _C);
                break;
            case CASE(0, 0, 0, 1):
                WRITE1(dst, 9, _A);
                WRITE2(dst, 10, _BC);
                break;
            case CASE(1, 0, 0, 1):
                WRITE2(dst, 0, _AB);
                WRITE1(dst, 2, _C);

                WRITE1(dst, 9, _A);
                WRITE2(dst, 10, _BC);
                break;
            case CASE(0, 1, 0, 1):
                WRITE1(dst, 3, _A);
                WRITE2(dst, 4, _BC);

                WRITE1(dst, 9, _A);
                WRITE2(dst, 10, _BC);
                break;
            case CASE(1, 1, 0, 1):
                WRITE4(dst, 0, _ABCA);
                WRITE2(dst, 4, _BC);

                WRITE1(dst, 9, _A);
                WRITE2(dst, 10, _BC);
                break;
            case CASE(0, 0, 1, 1):
                WRITE2(dst, 6, _AB);
                WRITE4(dst, 8, _CABC);
                break;
            case CASE(1, 0, 1, 1):
                WRITE2(dst, 0, _AB);
                WRITE1(dst, 2, _C);

                WRITE2(dst, 6, _AB);
                WRITE4(dst, 8, _CABC);
                break;
            case CASE(0, 1, 1, 1):
                WRITE1(dst, 3, _A);
                WRITE4(dst, 4, _BCAB);
                WRITE4(dst, 8, _CABC);
                break;
            case CASE(1, 1, 1, 1):
                WRITE8(dst);
                WRITE4(dst, 8, _CABC);
                break;
            }
            bits = FbStipLeft(bits, n);
            n = 4;
            dst += 12;
        }
        dstLine += dstStride;
    }
}

void
fbPolyGlyphBlt(DrawablePtr pDrawable,
               GCPtr pGC,
               int x,
               int y,
               unsigned int nglyph, CharInfoPtr * ppci, void *pglyphBase)
{
    FbGCPrivPtr pPriv = fbGetGCPrivate(pGC);
    CharInfoPtr pci;
    unsigned char *pglyph;      /* pointer bits in glyph */
    int gx, gy;
    int gWidth, gHeight;        /* width and height of glyph */
    FbStride gStride;           /* stride of glyph */
    void (*glyph) (FbBits *, FbStride, int, FbStip *, FbBits, int, int);
    FbBits *dst = 0;
    FbStride dstStride = 0;
    int dstBpp = 0;
    int dstXoff = 0, dstYoff = 0;

    glyph = 0;
    if (pGC->fillStyle == FillSolid && pPriv->and == 0) {
        dstBpp = pDrawable->bitsPerPixel;
        switch (dstBpp) {
        case 8:
            glyph = fbGlyph8;
            break;
        case 16:
            glyph = fbGlyph16;
            break;
        case 24:
            glyph = fbGlyph24;
            break;
        case 32:
            glyph = fbGlyph32;
            break;
        }
    }
    x += pDrawable->x;
    y += pDrawable->y;

    while (nglyph--) {
        pci = *ppci++;
        pglyph = FONTGLYPHBITS(pglyphBase, pci);
        gWidth = GLYPHWIDTHPIXELS(pci);
        gHeight = GLYPHHEIGHTPIXELS(pci);
        if (gWidth && gHeight) {
            gx = x + pci->metrics.leftSideBearing;
            gy = y - pci->metrics.ascent;
            if (glyph && gWidth <= sizeof(FbStip) * 8 &&
                fbGlyphIn(fbGetCompositeClip(pGC), gx, gy, gWidth, gHeight)) {
                fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff,
                              dstYoff);
                (*glyph) (dst + (gy + dstYoff) * dstStride, dstStride, dstBpp,
                          (FbStip *) pglyph, pPriv->xor, gx + dstXoff, gHeight);
                fbFinishAccess(pDrawable);
            }
            else {
                gStride = GLYPHWIDTHBYTESPADDED(pci) / sizeof(FbStip);
                fbPushImage(pDrawable,
                            pGC,
                            (FbStip *) pglyph,
                            gStride, 0, gx, gy, gWidth, gHeight);
            }
        }
        x += pci->metrics.characterWidth;
    }
}

void
fbImageGlyphBlt(DrawablePtr pDrawable,
                GCPtr pGC,
                int x,
                int y,
                unsigned int nglyph, CharInfoPtr * ppciInit, void *pglyphBase)
{
    FbGCPrivPtr pPriv = fbGetGCPrivate(pGC);
    CharInfoPtr *ppci;
    CharInfoPtr pci;
    unsigned char *pglyph;      /* pointer bits in glyph */
    int gWidth, gHeight;        /* width and height of glyph */
    FbStride gStride;           /* stride of glyph */
    Bool opaque;
    int n;
    int gx, gy;
    void (*glyph) (FbBits *, FbStride, int, FbStip *, FbBits, int, int);
    FbBits *dst = 0;
    FbStride dstStride = 0;
    int dstBpp = 0;
    int dstXoff = 0, dstYoff = 0;

    glyph = 0;
    if (pPriv->and == 0) {
        dstBpp = pDrawable->bitsPerPixel;
        switch (dstBpp) {
        case 8:
            glyph = fbGlyph8;
            break;
        case 16:
            glyph = fbGlyph16;
            break;
        case 24:
            glyph = fbGlyph24;
            break;
        case 32:
            glyph = fbGlyph32;
            break;
        }
    }

    x += pDrawable->x;
    y += pDrawable->y;

    if (TERMINALFONT(pGC->font)
        && !glyph) {
        opaque = TRUE;
    }
    else {
        int xBack, widthBack;
        int yBack, heightBack;

        ppci = ppciInit;
        n = nglyph;
        widthBack = 0;
        while (n--)
            widthBack += (*ppci++)->metrics.characterWidth;

        xBack = x;
        if (widthBack < 0) {
            xBack += widthBack;
            widthBack = -widthBack;
        }
        yBack = y - FONTASCENT(pGC->font);
        heightBack = FONTASCENT(pGC->font) + FONTDESCENT(pGC->font);
        fbSolidBoxClipped(pDrawable,
                          fbGetCompositeClip(pGC),
                          xBack,
                          yBack,
                          xBack + widthBack,
                          yBack + heightBack,
                          fbAnd(GXcopy, pPriv->bg, pPriv->pm),
                          fbXor(GXcopy, pPriv->bg, pPriv->pm));
        opaque = FALSE;
    }

    ppci = ppciInit;
    while (nglyph--) {
        pci = *ppci++;
        pglyph = FONTGLYPHBITS(pglyphBase, pci);
        gWidth = GLYPHWIDTHPIXELS(pci);
        gHeight = GLYPHHEIGHTPIXELS(pci);
        if (gWidth && gHeight) {
            gx = x + pci->metrics.leftSideBearing;
            gy = y - pci->metrics.ascent;
            if (glyph && gWidth <= sizeof(FbStip) * 8 &&
                fbGlyphIn(fbGetCompositeClip(pGC), gx, gy, gWidth, gHeight)) {
                fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff,
                              dstYoff);
                (*glyph) (dst + (gy + dstYoff) * dstStride, dstStride, dstBpp,
                          (FbStip *) pglyph, pPriv->fg, gx + dstXoff, gHeight);
                fbFinishAccess(pDrawable);
            }
            else {
                gStride = GLYPHWIDTHBYTESPADDED(pci) / sizeof(FbStip);
                fbPutXYImage(pDrawable,
                             fbGetCompositeClip(pGC),
                             pPriv->fg,
                             pPriv->bg,
                             pPriv->pm,
                             GXcopy,
                             opaque,
                             gx,
                             gy,
                             gWidth, gHeight, (FbStip *) pglyph, gStride, 0);
            }
        }
        x += pci->metrics.characterWidth;
    }
}
@


1.5
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d32 1
a32 1
Bool
a58 3
#if FB_UNIT == 6 && IMAGE_BYTE_ORDER == LSBFirst
#define WRITE8(d)	WRITE((FbBits *) &(d[0]), fg)
#else
a59 1
#endif
d68 1
a68 1
 * 
d119 1
a119 1
void
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d244 1
a244 1
               unsigned int nglyph, CharInfoPtr * ppci, pointer pglyphBase)
d312 1
a312 1
                unsigned int nglyph, CharInfoPtr * ppciInit, pointer pglyphBase)
@


1.3
log
@Update to xserver 1.11.2
@
text
@d33 1
a33 5
fbGlyphIn (RegionPtr	pRegion,
	   int		x,
	   int		y,
	   int		width,
	   int		height)
d35 2
a36 2
    BoxRec  box;
    BoxPtr  pExtents = RegionExtents(pRegion);
d41 4
a44 4
    if (x < (int) pExtents->x1) 
	return FALSE;
    if ((int) pExtents->x2 < x + width) 
	return FALSE;
d46 1
a46 1
	return FALSE;
d48 1
a48 1
	return FALSE;
a55 1

d64 1
a64 1
			 
d124 3
a126 7
fbGlyph24 (FbBits   *dstBits,
	   FbStride dstStride,
	   int	    dstBpp,
	   FbStip   *stipple,
	   FbBits   fg,
	   int	    x,
	   int	    height)
d128 7
a134 7
    int	    lshift;
    FbStip  bits;
    CARD8   *dstLine;
    CARD8   *dst;
    FbStip  f0, f1, f2;
    int	    n;
    int	    shift;
d137 3
a139 3
    f1 = FbRot24(f0,16);
    f2 = FbRot24(f0,8);
    
d142 1
a142 1
    dstStride *= (sizeof (FbBits) / sizeof (CARD8));
d145 91
a235 93
    while (height--)
    {
	bits = READ(stipple++);
	n = lshift;
	dst = dstLine;
	while (bits)
	{
	    switch (FbStipMoveLsb (FbLeftStipBits (bits, n), 4, n)) {
	    case CASE(0,0,0,0):
		break;
	    case CASE(1,0,0,0):
		WRITE2(dst,0,_AB);
		WRITE1(dst,2,_C);
		break;
	    case CASE(0,1,0,0):
		WRITE1(dst,3,_A);
		WRITE2(dst,4,_BC);
		break;
	    case CASE(1,1,0,0):
		WRITE4(dst,0,_ABCA);
		WRITE2(dst,4,_BC);
		break;
	    case CASE(0,0,1,0):
		WRITE2(dst,6,_AB);
		WRITE1(dst,8,_C);
		break;
	    case CASE(1,0,1,0):
		WRITE2(dst,0,_AB);
		WRITE1(dst,2,_C);
		
		WRITE2(dst,6,_AB);
		WRITE1(dst,8,_C);
		break;
	    case CASE(0,1,1,0):
		WRITE1(dst,3,_A);
		WRITE4(dst,4,_BCAB);
		WRITE1(dst,8,_C);
		break;
	    case CASE(1,1,1,0):
		WRITE8(dst);
		WRITE1(dst,8,_C);
		break;
	    case CASE(0,0,0,1):
		WRITE1(dst,9,_A);
		WRITE2(dst,10,_BC);
		break;
	    case CASE(1,0,0,1):
		WRITE2(dst,0,_AB);
		WRITE1(dst,2,_C);
		
		WRITE1(dst,9,_A);
		WRITE2(dst,10,_BC);
		break;
	    case CASE(0,1,0,1):
		WRITE1(dst,3,_A);
		WRITE2(dst,4,_BC);
		
		WRITE1(dst,9,_A);
		WRITE2(dst,10,_BC);
		break;
	    case CASE(1,1,0,1):
		WRITE4(dst,0,_ABCA);
		WRITE2(dst,4,_BC);
		
		WRITE1(dst,9,_A);
		WRITE2(dst,10,_BC);
		break;
	    case CASE(0,0,1,1):
		WRITE2(dst,6,_AB);
		WRITE4(dst,8,_CABC);
		break;
	    case CASE(1,0,1,1):
		WRITE2(dst,0,_AB);
		WRITE1(dst,2,_C);
		
		WRITE2(dst,6,_AB);
		WRITE4(dst,8,_CABC);
		break;
	    case CASE(0,1,1,1):
		WRITE1(dst,3,_A);
		WRITE4(dst,4,_BCAB);
		WRITE4(dst,8,_CABC);
		break;
	    case CASE(1,1,1,1):
		WRITE8(dst);
		WRITE4(dst,8,_CABC);
		break;
	    }
	    bits = FbStipLeft (bits, n);
	    n = 4;
	    dst += 12;
	}
	dstLine += dstStride;
d240 5
a244 7
fbPolyGlyphBlt (DrawablePtr	pDrawable,
		GCPtr		pGC,
		int		x, 
		int		y,
		unsigned int	nglyph,
		CharInfoPtr	*ppci,
		pointer		pglyphBase)
d246 12
a257 18
    FbGCPrivPtr	    pPriv = fbGetGCPrivate (pGC);
    CharInfoPtr	    pci;
    unsigned char   *pglyph;		/* pointer bits in glyph */
    int		    gx, gy;
    int		    gWidth, gHeight;	/* width and height of glyph */
    FbStride	    gStride;		/* stride of glyph */
    void	    (*glyph) (FbBits *,
			      FbStride,
			      int,
			      FbStip *,
			      FbBits,
			      int,
			      int);
    FbBits	    *dst = 0;
    FbStride	    dstStride = 0;
    int		    dstBpp = 0;
    int		    dstXoff = 0, dstYoff = 0;
    
d259 16
a274 9
    if (pGC->fillStyle == FillSolid && pPriv->and == 0)
    {
	dstBpp = pDrawable->bitsPerPixel;
	switch (dstBpp) {
	case 8:	    glyph = fbGlyph8; break;
	case 16:    glyph = fbGlyph16; break;
	case 24:    glyph = fbGlyph24; break;
	case 32:    glyph = fbGlyph32; break;
	}
d279 25
a303 39
    while (nglyph--)
    {
	pci = *ppci++;
	pglyph = FONTGLYPHBITS(pglyphBase, pci);
	gWidth = GLYPHWIDTHPIXELS(pci);
	gHeight = GLYPHHEIGHTPIXELS(pci);
	if (gWidth && gHeight)
	{
	    gx = x + pci->metrics.leftSideBearing;
	    gy = y - pci->metrics.ascent; 
	    if (glyph && gWidth <= sizeof (FbStip) * 8 &&
		fbGlyphIn (fbGetCompositeClip(pGC), gx, gy, gWidth, gHeight))
	    {
		fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
		(*glyph) (dst + (gy + dstYoff) * dstStride,
			  dstStride,
			  dstBpp,
			  (FbStip *) pglyph,
			  pPriv->xor,
			  gx + dstXoff,
			  gHeight);
		fbFinishAccess (pDrawable);
	    }
	    else
	    {
		gStride = GLYPHWIDTHBYTESPADDED(pci) / sizeof (FbStip);
		fbPushImage (pDrawable,
			     pGC,
    
			     (FbStip *) pglyph,
			     gStride,
			     0,
    
			     gx,
			     gy,
			     gWidth, gHeight);
	    }
	}
	x += pci->metrics.characterWidth;
a306 1

d308 5
a312 7
fbImageGlyphBlt (DrawablePtr	pDrawable,
		 GCPtr		pGC,
		 int		x, 
		 int		y,
		 unsigned int	nglyph,
		 CharInfoPtr	*ppciInit,
		 pointer	pglyphBase)
d314 15
a328 21
    FbGCPrivPtr	    pPriv = fbGetGCPrivate(pGC);
    CharInfoPtr	    *ppci;
    CharInfoPtr	    pci;
    unsigned char   *pglyph;		/* pointer bits in glyph */
    int		    gWidth, gHeight;	/* width and height of glyph */
    FbStride	    gStride;		/* stride of glyph */
    Bool	    opaque;
    int		    n;
    int		    gx, gy;
    void	    (*glyph) (FbBits *,
			      FbStride,
			      int,
			      FbStip *,
			      FbBits,
			      int,
			      int);
    FbBits	    *dst = 0;
    FbStride	    dstStride = 0;
    int		    dstBpp = 0;
    int		    dstXoff = 0, dstYoff = 0;
    
d330 16
a345 9
    if (pPriv->and == 0)
    {
	dstBpp = pDrawable->bitsPerPixel;
	switch (dstBpp) {
	case 8:	    glyph = fbGlyph8; break;
	case 16:    glyph = fbGlyph16; break;
	case 24:    glyph = fbGlyph24; break;
	case 32:    glyph = fbGlyph32; break;
	}
d347 1
a347 1
    
d351 3
a353 5
    if (TERMINALFONT (pGC->font)
	&& !glyph
	)
    {
	opaque = TRUE;
d355 10
a364 11
    else
    {
	int		xBack, widthBack;
	int		yBack, heightBack;
	
	ppci = ppciInit;
	n = nglyph;
	widthBack = 0;
	while (n--)
	    widthBack += (*ppci++)->metrics.characterWidth;
	
d366 15
a380 16
	if (widthBack < 0)
	{
	    xBack += widthBack;
	    widthBack = -widthBack;
	}
	yBack = y - FONTASCENT(pGC->font);
	heightBack = FONTASCENT(pGC->font) + FONTDESCENT(pGC->font);
	fbSolidBoxClipped (pDrawable,
			   fbGetCompositeClip(pGC),
			   xBack,
			   yBack,
			   xBack + widthBack,
			   yBack + heightBack,
			   fbAnd(GXcopy,pPriv->bg,pPriv->pm),
			   fbXor(GXcopy,pPriv->bg,pPriv->pm));
	opaque = FALSE;
d384 31
a414 44
    while (nglyph--)
    {
	pci = *ppci++;
	pglyph = FONTGLYPHBITS(pglyphBase, pci);
	gWidth = GLYPHWIDTHPIXELS(pci);
	gHeight = GLYPHHEIGHTPIXELS(pci);
	if (gWidth && gHeight)
	{
	    gx = x + pci->metrics.leftSideBearing;
	    gy = y - pci->metrics.ascent; 
	    if (glyph && gWidth <= sizeof (FbStip) * 8 &&
		fbGlyphIn (fbGetCompositeClip(pGC), gx, gy, gWidth, gHeight))
	    {
		fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
		(*glyph) (dst + (gy + dstYoff) * dstStride,
			  dstStride,
			  dstBpp,
			  (FbStip *) pglyph,
			  pPriv->fg,
			  gx + dstXoff,
			  gHeight);
		fbFinishAccess (pDrawable);
	    }
	    else
	    {
		gStride = GLYPHWIDTHBYTESPADDED(pci) / sizeof (FbStip);
		fbPutXYImage (pDrawable,
			      fbGetCompositeClip(pGC),
			      pPriv->fg,
			      pPriv->bg,
			      pPriv->pm,
			      GXcopy,
			      opaque,
    
			      gx,
			      gy,
			      gWidth, gHeight,
    
			      (FbStip *) pglyph,
			      gStride,
			      0);
	    }
	}
	x += pci->metrics.characterWidth;
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a59 2
#ifdef FB_24BIT
#ifndef FBNOPIXADDR
a248 2
#endif
#endif
a264 1
#ifndef FBNOPIXADDR
a283 1
#ifdef FB_24BIT
a284 1
#endif
a287 1
#endif
a300 1
#ifndef FBNOPIXADDR
a314 1
#endif
a351 1
#ifndef FBNOPIXADDR
a370 1
#ifdef FB_24BIT
a371 1
#endif
a374 1
#endif
a379 1
#ifndef FBNOPIXADDR
a380 1
#endif
a425 1
#ifndef FBNOPIXADDR
a439 1
#endif
@


1.1
log
@Initial revision
@
text
@a31 2
#define dummyScreen screenInfo.screens[0]
      
d40 1
a40 1
    BoxPtr  pExtents = REGION_EXTENTS (dummyScreen, pRegion);
d57 1
a57 1
    return RECT_IN_REGION (dummyScreen, pRegion, &box) == rgnIN;
d63 3
a65 3
#define WRITE1(d,n,fg)	((d)[n] = (CARD8) fg)
#define WRITE2(d,n,fg)	(*(CARD16 *) &(d[n]) = (CARD16) fg)
#define WRITE4(d,n,fg)	(*(CARD32 *) &(d[n]) = (CARD32) fg)
d67 1
a67 1
#define WRITE8(d)	(*(FbBits *) &(d[0]) = fg)
d158 1
a158 1
	bits = *stipple++;
d285 1
a285 1
	fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
d313 1
d321 1
d378 1
a378 1
	fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
d446 1
d454 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d65 3
a67 3
#define WRITE1(d,n,fg)	WRITE((d) + (n), (CARD8) fg)
#define WRITE2(d,n,fg)	WRITE((CARD16 *) &(d[n]), (CARD16) fg)
#define WRITE4(d,n,fg)	WRITE((CARD32 *) &(d[n]), (CARD32) fg)
d69 1
a69 1
#define WRITE8(d)	WRITE((FbBits *) &(d[0]), fg)
d160 1
a160 1
	bits = READ(stipple++);
d287 1
a287 1
	dstBpp = pDrawable->bitsPerPixel;
a314 1
		fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
a321 1
		fbFinishAccess (pDrawable);
d378 1
a378 1
	dstBpp = pDrawable->bitsPerPixel;
a445 1
		fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
a452 1
		fbFinishAccess (pDrawable);
@

