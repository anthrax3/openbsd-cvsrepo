head	1.3;
access;
symbols
	OPENBSD_6_0:1.3.0.18
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.16
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.14
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.12
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.10
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.8
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2
	OPENBSD_5_0:1.1.1.2.0.16
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.12
	OPENBSD_4_9_BASE:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.39;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.39;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.33;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@/*
 * Copyright Â© 1998 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#define FbSelectPart(xor,o,t)    xor

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "fb.h"

void
fbSolid(FbBits * dst,
        FbStride dstStride,
        int dstX, int bpp, int width, int height, FbBits and, FbBits xor)
{
    FbBits startmask, endmask;
    int n, nmiddle;
    int startbyte, endbyte;

    if (bpp == 24 && (!FbCheck24Pix(and) || !FbCheck24Pix(xor))) {
        fbSolid24(dst, dstStride, dstX, width, height, and, xor);
        return;
    }
    dst += dstX >> FB_SHIFT;
    dstX &= FB_MASK;
    FbMaskBitsBytes(dstX, width, and == 0, startmask, startbyte,
                    nmiddle, endmask, endbyte);
    if (startmask)
        dstStride--;
    dstStride -= nmiddle;
    while (height--) {
        if (startmask) {
            FbDoLeftMaskByteRRop(dst, startbyte, startmask, and, xor);
            dst++;
        }
        n = nmiddle;
        if (!and)
            while (n--)
                WRITE(dst++, xor);
        else
            while (n--) {
                WRITE(dst, FbDoRRop(READ(dst), and, xor));
                dst++;
            }
        if (endmask)
            FbDoRightMaskByteRRop(dst, endbyte, endmask, and, xor);
        dst += dstStride;
    }
}

void
fbSolid24(FbBits * dst,
          FbStride dstStride,
          int dstX, int width, int height, FbBits and, FbBits xor)
{
    FbBits startmask, endmask;
    FbBits xor0 = 0, xor1 = 0, xor2 = 0;
    FbBits and0 = 0, and1 = 0, and2 = 0;
    FbBits xorS = 0, andS = 0, xorE = 0, andE = 0;
    int n, nmiddle;
    int rotS, rot;

    dst += dstX >> FB_SHIFT;
    dstX &= FB_MASK;
    /*
     * Rotate pixel values this far across the word to align on
     * screen pixel boundaries
     */
    rot = FbFirst24Rot(dstX);
    FbMaskBits(dstX, width, startmask, nmiddle, endmask);
    if (startmask)
        dstStride--;
    dstStride -= nmiddle;

    /*
     * Precompute rotated versions of the rasterop values
     */
    rotS = rot;
    xor = FbRot24(xor, rotS);
    and = FbRot24(and, rotS);
    if (startmask) {
        xorS = xor;
        andS = and;
        xor = FbNext24Pix(xor);
        and = FbNext24Pix(and);
    }

    if (nmiddle) {
        xor0 = xor;
        and0 = and;
        xor1 = FbNext24Pix(xor0);
        and1 = FbNext24Pix(and0);
        xor2 = FbNext24Pix(xor1);
        and2 = FbNext24Pix(and1);
    }

    if (endmask) {
        switch (nmiddle % 3) {
        case 0:
            xorE = xor;
            andE = and;
            break;
        case 1:
            xorE = xor1;
            andE = and1;
            break;
        case 2:
            xorE = xor2;
            andE = and2;
            break;
        }
    }

    while (height--) {
        if (startmask) {
            WRITE(dst, FbDoMaskRRop(READ(dst), andS, xorS, startmask));
            dst++;
        }
        n = nmiddle;
        if (!and0) {
            while (n >= 3) {
                WRITE(dst++, xor0);
                WRITE(dst++, xor1);
                WRITE(dst++, xor2);
                n -= 3;
            }
            if (n) {
                WRITE(dst++, xor0);
                n--;
                if (n) {
                    WRITE(dst++, xor1);
                }
            }
        }
        else {
            while (n >= 3) {
                WRITE(dst, FbDoRRop(READ(dst), and0, xor0));
                dst++;
                WRITE(dst, FbDoRRop(READ(dst), and1, xor1));
                dst++;
                WRITE(dst, FbDoRRop(READ(dst), and2, xor2));
                dst++;
                n -= 3;
            }
            if (n) {
                WRITE(dst, FbDoRRop(READ(dst), and0, xor0));
                dst++;
                n--;
                if (n) {
                    WRITE(dst, FbDoRRop(READ(dst), and1, xor1));
                    dst++;
                }
            }
        }
        if (endmask)
            WRITE(dst, FbDoMaskRRop(READ(dst), andE, xorE, endmask));
        dst += dstStride;
    }
}
@


1.2
log
@Update to xserver 1.11.2
@
text
@d32 3
a34 10
fbSolid (FbBits	    *dst,
	 FbStride   dstStride,
	 int	    dstX,
	 int	    bpp,

	 int	    width,
	 int	    height,

	 FbBits	    and,
	 FbBits	    xor)
d36 7
a42 8
    FbBits  startmask, endmask;
    int	    n, nmiddle;
    int	    startbyte, endbyte;

    if (bpp == 24 && (!FbCheck24Pix(and) || !FbCheck24Pix(xor)))
    {
	fbSolid24 (dst, dstStride, dstX, width, height, and, xor);
	return;
d46 2
a47 2
    FbMaskBitsBytes(dstX, width, and == 0, startmask, startbyte, 
		    nmiddle, endmask, endbyte);
d49 1
a49 1
	dstStride--;
d51 12
a62 15
    while (height--)
    {
	if (startmask)
	{
	    FbDoLeftMaskByteRRop(dst,startbyte,startmask,and,xor);
	    dst++;
	}
	n = nmiddle;
	if (!and)
	    while (n--)
		WRITE(dst++, xor);
	else
	    while (n--)
	    {
		WRITE(dst, FbDoRRop (READ(dst), and, xor));
d64 4
a67 4
	    }
	if (endmask)
	    FbDoRightMaskByteRRop(dst,endbyte,endmask,and,xor);
	dst += dstStride;
d72 3
a74 9
fbSolid24 (FbBits   *dst,
	   FbStride dstStride,
	   int	    dstX,

	   int	    width,
	   int	    height,

	   FbBits   and,
	   FbBits   xor)
d76 6
a81 6
    FbBits  startmask, endmask;
    FbBits  xor0 = 0, xor1 = 0, xor2 = 0;
    FbBits  and0 = 0, and1 = 0, and2 = 0;
    FbBits  xorS = 0, andS = 0, xorE = 0, andE = 0;
    int	    n, nmiddle;
    int	    rotS, rot;
d89 2
a90 2
    rot = FbFirst24Rot (dstX);
    FbMaskBits (dstX, width, startmask, nmiddle, endmask);
d92 1
a92 1
	dstStride--;
d94 1
a94 1
    
d99 7
a105 8
    xor = FbRot24(xor,rotS);
    and = FbRot24(and,rotS);
    if (startmask)
    {
	xorS = xor;
	andS = and;
	xor = FbNext24Pix(xor);
	and = FbNext24Pix(and);
d107 8
a114 9
    
    if (nmiddle)
    {
	xor0 = xor;
	and0 = and;
	xor1 = FbNext24Pix(xor0);
	and1 = FbNext24Pix(and0);
	xor2 = FbNext24Pix(xor1);
	and2 = FbNext24Pix(and1);
d116 16
a131 17
    
    if (endmask)
    {
	switch (nmiddle % 3) {
	case 0:
	    xorE = xor;
	    andE = and;
	    break;
	case 1:
	    xorE = xor1;
	    andE = and1;
	    break;
	case 2:
	    xorE = xor2;
	    andE = and2;
	    break;
	}
d133 4
a136 6
    
    while (height--)
    {
	if (startmask)
	{
	    WRITE(dst, FbDoMaskRRop(READ(dst), andS, xorS, startmask));
d138 20
a157 26
	}
	n = nmiddle;
	if (!and0)
	{
	    while (n >= 3)
	    {
		WRITE(dst++, xor0);
		WRITE(dst++, xor1);
		WRITE(dst++, xor2);
		n -= 3;
	    }
	    if (n)
	    {
		WRITE(dst++, xor0);
		n--;
		if (n)
		{
		    WRITE(dst++, xor1);
		}
	    }
	}
	else
	{
	    while (n >= 3)
	    {
		WRITE(dst, FbDoRRop (READ(dst), and0, xor0));
d159 1
a159 1
		WRITE(dst, FbDoRRop (READ(dst), and1, xor1));
d161 1
a161 1
		WRITE(dst, FbDoRRop (READ(dst), and2, xor2));
d163 4
a166 5
		n -= 3;
	    }
	    if (n)
	    {
		WRITE(dst, FbDoRRop (READ(dst), and0, xor0));
d168 3
a170 4
		n--;
		if (n)
		{
		    WRITE(dst, FbDoRRop (READ(dst), and1, xor1));
d172 6
a177 6
		}
	    }
	}
	if (endmask)
	    WRITE(dst, FbDoMaskRRop (READ(dst), andE, xorE, endmask));
	dst += dstStride;
@


1.1
log
@Initial revision
@
text
@a1 2
 * $XFree86$
 *
a46 1
#ifdef FB_24BIT
a51 1
#endif
d69 1
a69 1
		*dst++ = xor;
d73 2
a74 2
		*dst = FbDoRRop (*dst, and, xor);
		dst++;
a81 1
#ifdef FB_24BIT
d158 2
a159 2
	    *dst = FbDoMaskRRop(*dst, andS, xorS, startmask);
	    dst++;
d166 3
a168 3
		*dst++ = xor0;
		*dst++ = xor1;
		*dst++ = xor2;
d173 1
a173 1
		*dst++ = xor0;
d177 1
a177 1
		    *dst++ = xor1;
d185 6
a190 6
		*dst = FbDoRRop (*dst, and0, xor0);
		dst++;
		*dst = FbDoRRop (*dst, and1, xor1);
		dst++;
		*dst = FbDoRRop (*dst, and2, xor2);
		dst++;
d195 2
a196 2
		*dst = FbDoRRop (*dst, and0, xor0);
		dst++;
d200 2
a201 2
		    *dst = FbDoRRop (*dst, and1, xor1);
		    dst++;
d206 1
a206 1
	    *dst = FbDoMaskRRop (*dst, andE, xorE, endmask);
a209 1
#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d73 1
a73 1
		WRITE(dst++, xor);
d77 2
a78 2
		WRITE(dst, FbDoRRop (READ(dst), and, xor));
                dst++;
d163 2
a164 2
	    WRITE(dst, FbDoMaskRRop(READ(dst), andS, xorS, startmask));
            dst++;
d171 3
a173 3
		WRITE(dst++, xor0);
		WRITE(dst++, xor1);
		WRITE(dst++, xor2);
d178 1
a178 1
		WRITE(dst++, xor0);
d182 1
a182 1
		    WRITE(dst++, xor1);
d190 6
a195 6
		WRITE(dst, FbDoRRop (READ(dst), and0, xor0));
                dst++;
		WRITE(dst, FbDoRRop (READ(dst), and1, xor1));
                dst++;
		WRITE(dst, FbDoRRop (READ(dst), and2, xor2));
                dst++;
d200 2
a201 2
		WRITE(dst, FbDoRRop (READ(dst), and0, xor0));
                dst++;
d205 2
a206 2
		    WRITE(dst, FbDoRRop (READ(dst), and1, xor1));
                    dst++;
d211 1
a211 1
	    WRITE(dst, FbDoMaskRRop (READ(dst), andE, xorE, endmask));
@

