head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.19.0.2
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.2
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	v1_2_0:1.1.1.2
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	s0SI41sEunLdyFfd;

1.21
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	7pAEtF6Y5EgemkuY;

1.20
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.19;
commitid	Te1daavkBLskZ8gc;

1.19
date	2015.06.20.10.03.57;	author matthieu;	state Exp;
branches;
next	1.18;
commitid	jjm2dnFUTn6INJSK;

1.18
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	cVXoV5PxI8YrEaVA;

1.17
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2011.10.18.14.58.36;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.02.16.08.40;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.20.07.26.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.24.19.04.06;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.03.11.31.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.11;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.11;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.03.03.11.11.55;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.24.17.57.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
Copyright 1994 Quarterdeck Office Systems.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital and
Quarterdeck not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.

DIGITAL AND QUARTERDECK DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT
OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
OR PERFORMANCE OF THIS SOFTWARE.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef __CYGWIN__
#include <stdlib.h>
#include <signal.h>
/*
   Sigh... We really need a prototype for this to know it is stdcall,
   but #include-ing <windows.h> here is not a good idea...
*/
__stdcall unsigned long GetTickCount(void);
#endif

#if defined(WIN32) && !defined(__CYGWIN__)
#include <X11/Xwinsock.h>
#endif
#include <X11/Xos.h>
#include <stdio.h>
#include <time.h>
#if !defined(WIN32) || !defined(__MINGW32__)
#include <sys/time.h>
#include <sys/resource.h>
# define SMART_SCHEDULE_POSSIBLE
#endif
#include "misc.h"
#include <X11/X.h>
#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#include "input.h"
#include "dixfont.h"
#include <X11/fonts/fontutil.h>
#include "osdep.h"
#include "extension.h"
#ifdef X_POSIX_C_SOURCE
#define _POSIX_C_SOURCE X_POSIX_C_SOURCE
#include <signal.h>
#undef _POSIX_C_SOURCE
#else
#if defined(_POSIX_SOURCE)
#include <signal.h>
#else
#define _POSIX_SOURCE
#include <signal.h>
#undef _POSIX_SOURCE
#endif
#endif
#ifndef WIN32
#include <sys/wait.h>
#endif
#if !defined(SYSV) && !defined(WIN32)
#include <sys/resource.h>
#endif
#include <sys/stat.h>
#include <ctype.h>              /* for isspace */
#include <stdarg.h>

#include <stdlib.h>             /* for malloc() */

#if defined(TCPCONN) || defined(STREAMSCONN)
#ifndef WIN32
#include <netdb.h>
#endif
#endif

#include "opaque.h"

#include "dixstruct.h"

#include "xkbsrv.h"

#include "picture.h"

Bool noTestExtensions;

#ifdef COMPOSITE
Bool noCompositeExtension = FALSE;
#endif

#ifdef DAMAGE
Bool noDamageExtension = FALSE;
#endif
#ifdef DBE
Bool noDbeExtension = FALSE;
#endif
#ifdef DPMSExtension
Bool noDPMSExtension = FALSE;
#endif
#ifdef GLXEXT
Bool noGlxExtension = FALSE;
#endif
#ifdef SCREENSAVER
Bool noScreenSaverExtension = FALSE;
#endif
#ifdef MITSHM
Bool noMITShmExtension = FALSE;
#endif
#ifdef RANDR
Bool noRRExtension = FALSE;
#endif
Bool noRenderExtension = FALSE;

#ifdef XCSECURITY
Bool noSecurityExtension = FALSE;
#endif
#ifdef RES
Bool noResExtension = FALSE;
#endif
#ifdef XF86BIGFONT
Bool noXFree86BigfontExtension = FALSE;
#endif
#ifdef XFreeXDGA
Bool noXFree86DGAExtension = FALSE;
#endif
#ifdef XF86DRI
Bool noXFree86DRIExtension = FALSE;
#endif
#ifdef XF86VIDMODE
Bool noXFree86VidModeExtension = FALSE;
#endif
Bool noXFixesExtension = FALSE;
#ifdef PANORAMIX
/* Xinerama is disabled by default unless enabled via +xinerama */
Bool noPanoramiXExtension = TRUE;
#endif
#ifdef XSELINUX
Bool noSELinuxExtension = FALSE;
int selinuxEnforcingState = SELINUX_MODE_DEFAULT;
#endif
#ifdef XV
Bool noXvExtension = FALSE;
#endif
#ifdef DRI2
Bool noDRI2Extension = FALSE;
#endif

Bool noGEExtension = FALSE;

#define X_INCLUDE_NETDB_H
#include <X11/Xos_r.h>

#include <errno.h>

Bool CoreDump;

Bool enableIndirectGLX = FALSE;

#ifdef PANORAMIX
Bool PanoramiXExtensionDisabledHack = FALSE;
#endif

int auditTrailLevel = 1;

char *SeatId = NULL;

sig_atomic_t inSignalContext = FALSE;

#if defined(SVR4) || defined(__linux__) || defined(CSRG_BASED)
#define HAS_SAVED_IDS_AND_SETEUID
#endif

OsSigHandlerPtr
OsSignal(int sig, OsSigHandlerPtr handler)
{
#if defined(WIN32) && !defined(__CYGWIN__)
    return signal(sig, handler);
#else
    struct sigaction act, oact;

    sigemptyset(&act.sa_mask);
    if (handler != SIG_IGN)
        sigaddset(&act.sa_mask, sig);
    act.sa_flags = 0;
    act.sa_handler = handler;
    if (sigaction(sig, &act, &oact))
        perror("sigaction");
    return oact.sa_handler;
#endif
}

/*
 * Explicit support for a server lock file like the ones used for UUCP.
 * For architectures with virtual terminals that can run more than one
 * server at a time.  This keeps the servers from stomping on each other
 * if the user forgets to give them different display numbers.
 */
#define LOCK_DIR "/tmp"
#define LOCK_TMP_PREFIX "/.tX"
#define LOCK_PREFIX "/.X"
#define LOCK_SUFFIX "-lock"

#if !defined(WIN32) || defined(__CYGWIN__)
#define LOCK_SERVER
#endif

#ifndef LOCK_SERVER
void
LockServer(void)
{}

void
UnlockServer(void)
{}
#else /* LOCK_SERVER */
static Bool StillLocking = FALSE;
static char LockFile[PATH_MAX];
static Bool nolock = FALSE;

/*
 * LockServer --
 *      Check if the server lock file exists.  If so, check if the PID
 *      contained inside is valid.  If so, then die.  Otherwise, create
 *      the lock file containing the PID.
 */
void
LockServer(void)
{
    char tmp[PATH_MAX], pid_str[12];
    int lfd, i, haslock, l_pid, t;
    const char *tmppath = LOCK_DIR;
    int len;
    char port[20];

    if (nolock || NoListenAll)
        return;
    /*
     * Path names
     */
    snprintf(port, sizeof(port), "%d", atoi(display));
    len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :
        strlen(LOCK_TMP_PREFIX);
    len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;
    if (len > sizeof(LockFile))
        FatalError("Display name `%s' is too long\n", port);
    (void) sprintf(tmp, "%s" LOCK_TMP_PREFIX "%s" LOCK_SUFFIX, tmppath, port);
    (void) sprintf(LockFile, "%s" LOCK_PREFIX "%s" LOCK_SUFFIX, tmppath, port);

    /*
     * Create a temporary file containing our PID.  Attempt three times
     * to create the file.
     */
    StillLocking = TRUE;
    i = 0;
    do {
        i++;
        lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
        if (lfd < 0)
            sleep(2);
        else
            break;
    } while (i < 3);
    if (lfd < 0) {
        unlink(tmp);
        i = 0;
        do {
            i++;
            lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
            if (lfd < 0)
                sleep(2);
            else
                break;
        } while (i < 3);
    }
    if (lfd < 0)
        FatalError("Could not create lock file in %s\n", tmp);
    snprintf(pid_str, sizeof(pid_str), "%10ld\n", (long) getpid());
    if (write(lfd, pid_str, 11) != 11)
        FatalError("Could not write pid to lock file in %s\n", tmp);
#ifdef __OpenBSD__
    /* if possible give away the lock file to the real uid/gid */
    fchown(lfd, getuid(), getgid());
#endif
    (void) fchmod(lfd, 0444);
    (void) close(lfd);

    /*
     * OK.  Now the tmp file exists.  Try three times to move it in place
     * for the lock.
     */
    i = 0;
    haslock = 0;
    while ((!haslock) && (i++ < 3)) {
        haslock = (link(tmp, LockFile) == 0);
        if (haslock) {
            /*
             * We're done.
             */
            break;
        }
        else {
            /*
             * Read the pid from the existing file
             */
            lfd = open(LockFile, O_RDONLY | O_NOFOLLOW);
            if (lfd < 0) {
                unlink(tmp);
                FatalError("Can't read lock file %s\n", LockFile);
            }
            pid_str[0] = '\0';
            if (read(lfd, pid_str, 11) != 11) {
                /*
                 * Bogus lock file.
                 */
                unlink(LockFile);
                close(lfd);
                continue;
            }
            pid_str[11] = '\0';
            sscanf(pid_str, "%d", &l_pid);
            close(lfd);

            /*
             * Now try to kill the PID to see if it exists.
             */
            errno = 0;
            t = kill(l_pid, 0);
            if ((t < 0) && (errno == ESRCH)) {
                /*
                 * Stale lock file.
                 */
                unlink(LockFile);
                continue;
            }
            else if (((t < 0) && (errno == EPERM)) || (t == 0)) {
                /*
                 * Process is still active.
                 */
                unlink(tmp);
                FatalError
                    ("Server is already active for display %s\n%s %s\n%s\n",
                     port, "\tIf this server is no longer running, remove",
                     LockFile, "\tand start again.");
            }
        }
    }
    unlink(tmp);
    if (!haslock)
        FatalError("Could not create server lock file: %s\n", LockFile);
    StillLocking = FALSE;
}

/*
 * UnlockServer --
 *      Remove the server lock file.
 */
void
UnlockServer(void)
{
    if (nolock || NoListenAll)
        return;

    if (!StillLocking) {

        (void) unlink(LockFile);
    }
}
#endif /* LOCK_SERVER */

#ifdef X_PRIVSEP
int
ChownLock(uid_t uid, gid_t gid)
{
	return chown(LockFile, uid, gid);
}
#endif

/* Force connections to close on SIGHUP from init */

void
AutoResetServer(int sig)
{
    int olderrno = errno;

    dispatchException |= DE_RESET;
    isItTimeToYield = TRUE;
    errno = olderrno;
}

/* Force connections to close and then exit on SIGTERM, SIGINT */

void
GiveUp(int sig)
{
    int olderrno = errno;

    dispatchException |= DE_TERMINATE;
    isItTimeToYield = TRUE;
    errno = olderrno;
}

#if (defined WIN32 && defined __MINGW32__) || defined(__CYGWIN__)
CARD32
GetTimeInMillis(void)
{
    return GetTickCount();
}
CARD64
GetTimeInMicros(void)
{
    return (CARD64) GetTickCount() * 1000;
}
#else
CARD32
GetTimeInMillis(void)
{
    struct timeval tv;

#ifdef MONOTONIC_CLOCK
    struct timespec tp;
    static clockid_t clockid;

    if (!clockid) {
#ifdef CLOCK_MONOTONIC_COARSE
        if (clock_getres(CLOCK_MONOTONIC_COARSE, &tp) == 0 &&
            (tp.tv_nsec / 1000) <= 1000 &&
            clock_gettime(CLOCK_MONOTONIC_COARSE, &tp) == 0)
            clockid = CLOCK_MONOTONIC_COARSE;
        else
#endif
        if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0)
            clockid = CLOCK_MONOTONIC;
        else
            clockid = ~0L;
    }
    if (clockid != ~0L && clock_gettime(clockid, &tp) == 0)
        return (tp.tv_sec * 1000) + (tp.tv_nsec / 1000000L);
#endif

    X_GETTIMEOFDAY(&tv);
    return (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
}

CARD64
GetTimeInMicros(void)
{
    struct timeval tv;
#ifdef MONOTONIC_CLOCK
    struct timespec tp;
    static clockid_t clockid;

    if (!clockid) {
        if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0)
            clockid = CLOCK_MONOTONIC;
        else
            clockid = ~0L;
    }
    if (clockid != ~0L && clock_gettime(clockid, &tp) == 0)
        return (CARD64) tp.tv_sec * (CARD64)1000000 + tp.tv_nsec / 1000;
#endif

    X_GETTIMEOFDAY(&tv);
    return (CARD64) tv.tv_sec * (CARD64)1000000000 + (CARD64) tv.tv_usec * 1000;
}
#endif

void
AdjustWaitForDelay(void *waitTime, unsigned long newdelay)
{
    static struct timeval delay_val;
    struct timeval **wt = (struct timeval **) waitTime;
    unsigned long olddelay;

    if (*wt == NULL) {
        delay_val.tv_sec = newdelay / 1000;
        delay_val.tv_usec = 1000 * (newdelay % 1000);
        *wt = &delay_val;
    }
    else {
        olddelay = (*wt)->tv_sec * 1000 + (*wt)->tv_usec / 1000;
        if (newdelay < olddelay) {
            (*wt)->tv_sec = newdelay / 1000;
            (*wt)->tv_usec = 1000 * (newdelay % 1000);
        }
    }
}

void
UseMsg(void)
{
    ErrorF("use: X [:<display>] [option]\n");
    ErrorF("-a #                   default pointer acceleration (factor)\n");
    ErrorF("-ac                    disable access control restrictions\n");
    ErrorF("-audit int             set audit trail level\n");
    ErrorF("-auth file             select authorization file\n");
    ErrorF("-br                    create root window with black background\n");
    ErrorF("+bs                    enable any backing store support\n");
    ErrorF("-bs                    disable any backing store support\n");
    ErrorF("-c                     turns off key-click\n");
    ErrorF("c #                    key-click volume (0-100)\n");
    ErrorF("-cc int                default color visual class\n");
    ErrorF("-nocursor              disable the cursor\n");
    ErrorF("-core                  generate core dump on fatal error\n");
    ErrorF("-displayfd fd          file descriptor to write display number to when ready to connect\n");
    ErrorF("-dpi int               screen resolution in dots per inch\n");
#ifdef DPMSExtension
    ErrorF("-dpms                  disables VESA DPMS monitor control\n");
#endif
    ErrorF
        ("-deferglyphs [none|all|16] defer loading of [no|all|16-bit] glyphs\n");
    ErrorF("-f #                   bell base (0-100)\n");
    ErrorF("-fc string             cursor font\n");
    ErrorF("-fn string             default font name\n");
    ErrorF("-fp string             default font path\n");
    ErrorF("-help                  prints message with these options\n");
    ErrorF("+iglx                  Allow creating indirect GLX contexts\n");
    ErrorF("-iglx                  Prohibit creating indirect GLX contexts (default)\n");
    ErrorF("-I                     ignore all remaining arguments\n");
#ifdef RLIMIT_DATA
    ErrorF("-ld int                limit data space to N Kb\n");
#endif
#ifdef RLIMIT_NOFILE
    ErrorF("-lf int                limit number of open files to N\n");
#endif
#ifdef RLIMIT_STACK
    ErrorF("-ls int                limit stack space to N Kb\n");
#endif
#ifdef LOCK_SERVER
    ErrorF("-nolock                disable the locking mechanism\n");
#endif
    ErrorF("-maxclients n          set maximum number of clients (power of two)\n");
    ErrorF("-nolisten string       don't listen on protocol\n");
    ErrorF("-listen string         listen on protocol\n");
    ErrorF("-noreset               don't reset after last client exists\n");
    ErrorF("-background [none]     create root window with no background\n");
    ErrorF("-reset                 reset after last client exists\n");
    ErrorF("-p #                   screen-saver pattern duration (minutes)\n");
    ErrorF("-pn                    accept failure to listen on all ports\n");
    ErrorF("-nopn                  reject failure to listen on all ports\n");
    ErrorF("-r                     turns off auto-repeat\n");
    ErrorF("r                      turns on auto-repeat \n");
    ErrorF("-render [default|mono|gray|color] set render color alloc policy\n");
#ifndef __OpenBSD__
    ErrorF("-retro                 start with classic stipple and cursor\n");
#else
    ErrorF("-retard		   start with black background and no cursor\n");
#endif
    ErrorF("-s #                   screen-saver timeout (minutes)\n");
    ErrorF("-seat string           seat to run on\n");
    ErrorF("-t #                   default pointer threshold (pixels/t)\n");
    ErrorF("-terminate             terminate at server reset\n");
    ErrorF("-to #                  connection time out\n");
    ErrorF("-tst                   disable testing extensions\n");
    ErrorF("ttyxx                  server started from init on /dev/ttyxx\n");
    ErrorF("v                      video blanking for screen-saver\n");
    ErrorF("-v                     screen-saver without video blanking\n");
    ErrorF("-wm                    WhenMapped default backing-store\n");
    ErrorF("-wr                    create root window with white background\n");
    ErrorF("-maxbigreqsize         set maximal bigrequest size \n");
#ifdef PANORAMIX
    ErrorF("+xinerama              Enable XINERAMA extension\n");
    ErrorF("-xinerama              Disable XINERAMA extension\n");
#endif
    ErrorF
        ("-dumbSched             Disable smart scheduling, enable old behavior\n");
    ErrorF("-schedInterval int     Set scheduler interval in msec\n");
    ErrorF("-sigstop               Enable SIGSTOP based startup\n");
    ErrorF("+extension name        Enable extension\n");
    ErrorF("-extension name        Disable extension\n");
#ifdef XDMCP
    XdmcpUseMsg();
#endif
    XkbUseMsg();
    ddxUseMsg();
}

/*  This function performs a rudimentary sanity check
 *  on the display name passed in on the command-line,
 *  since this string is used to generate filenames.
 *  It is especially important that the display name
 *  not contain a "/" and not start with a "-".
 *                                            --kvajk
 */
static int
VerifyDisplayName(const char *d)
{
    int i;
    int period_found = FALSE;
    int after_period = 0;

    if (d == (char *) 0)
        return 0;               /*  null  */
    if (*d == '\0')
        return 0;               /*  empty  */
    if (*d == '-')
        return 0;               /*  could be confused for an option  */
    if (*d == '.')
        return 0;               /*  must not equal "." or ".."  */
    if (strchr(d, '/') != (char *) 0)
        return 0;               /*  very important!!!  */

    /* Since we run atoi() on the display later, only allow
       for digits, or exception of :0.0 and similar (two decimal points max)
       */
    for (i = 0; i < strlen(d); i++) {
        if (!isdigit(d[i])) {
            if (d[i] != '.' || period_found)
                return 0;
            period_found = TRUE;
        } else if (period_found)
            after_period++;

        if (after_period > 2)
            return 0;
    }

    /* don't allow for :0. */
    if (period_found && after_period == 0)
        return 0;

    if (atol(d) > INT_MAX)
        return 0;

    return 1;
}

static const char *defaultNoListenList[] = {
#ifndef LISTEN_TCP
    "tcp",
#endif
#ifndef LISTEN_UNIX
    "unix",
#endif
#ifndef LISTEN_LOCAL
    "local",
#endif
    NULL
};

/*
 * This function parses the command line. Handles device-independent fields
 * and allows ddx to handle additional fields.  It is not allowed to modify
 * argc or any of the strings pointed to by argv.
 */
void
ProcessCommandLine(int argc, char *argv[])
{
    int i, skip;

    defaultKeyboardControl.autoRepeat = TRUE;

#ifdef NO_PART_NET
    PartialNetwork = FALSE;
#else
    PartialNetwork = TRUE;
#endif

    for (i = 0; defaultNoListenList[i] != NULL; i++) {
        if (_XSERVTransNoListen(defaultNoListenList[i]))
                    ErrorF("Failed to disable listen for %s transport",
                           defaultNoListenList[i]);
    }

    for (i = 1; i < argc; i++) {
        /* call ddx first, so it can peek/override if it wants */
        if ((skip = ddxProcessArgument(argc, argv, i))) {
            i += (skip - 1);
        }
        else if (argv[i][0] == ':') {
            /* initialize display */
            display = argv[i];
            explicit_display = TRUE;
            display++;
            if (!VerifyDisplayName(display)) {
                ErrorF("Bad display name: %s\n", display);
                UseMsg();
                FatalError("Bad display name, exiting: %s\n", display);
            }
        }
        else if (strcmp(argv[i], "-a") == 0) {
            if (++i < argc)
                defaultPointerControl.num = atoi(argv[i]);
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-ac") == 0) {
            defeatAccessControl = TRUE;
        }
        else if (strcmp(argv[i], "-audit") == 0) {
            if (++i < argc)
                auditTrailLevel = atoi(argv[i]);
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-auth") == 0) {
            if (++i < argc)
                InitAuthorization(argv[i]);
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-br") == 0);  /* default */
        else if (strcmp(argv[i], "+bs") == 0)
            enableBackingStore = TRUE;
        else if (strcmp(argv[i], "-bs") == 0)
            disableBackingStore = TRUE;
        else if (strcmp(argv[i], "c") == 0) {
            if (++i < argc)
                defaultKeyboardControl.click = atoi(argv[i]);
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-c") == 0) {
            defaultKeyboardControl.click = 0;
        }
        else if (strcmp(argv[i], "-cc") == 0) {
            if (++i < argc)
                defaultColorVisualClass = atoi(argv[i]);
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-core") == 0) {
#if !defined(WIN32) || !defined(__MINGW32__)
            struct rlimit core_limit;

            getrlimit(RLIMIT_CORE, &core_limit);
            core_limit.rlim_cur = core_limit.rlim_max;
            setrlimit(RLIMIT_CORE, &core_limit);
#endif
            CoreDump = TRUE;
        }
        else if (strcmp(argv[i], "-nocursor") == 0) {
            EnableCursor = FALSE;
        }
        else if (strcmp(argv[i], "-dpi") == 0) {
            if (++i < argc)
                monitorResolution = atoi(argv[i]);
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-displayfd") == 0) {
            if (++i < argc) {
                displayfd = atoi(argv[i]);
#ifdef LOCK_SERVER
                nolock = TRUE;
#endif
            }
            else
                UseMsg();
        }
#ifdef DPMSExtension
        else if (strcmp(argv[i], "dpms") == 0)
            /* ignored for compatibility */ ;
        else if (strcmp(argv[i], "-dpms") == 0)
            DPMSDisabledSwitch = TRUE;
#endif
        else if (strcmp(argv[i], "-deferglyphs") == 0) {
            if (++i >= argc || !ParseGlyphCachingMode(argv[i]))
                UseMsg();
        }
        else if (strcmp(argv[i], "-f") == 0) {
            if (++i < argc)
                defaultKeyboardControl.bell = atoi(argv[i]);
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-fc") == 0) {
            if (++i < argc)
                defaultCursorFont = argv[i];
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-fn") == 0) {
            if (++i < argc)
                defaultTextFont = argv[i];
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-fp") == 0) {
            if (++i < argc) {
                defaultFontPath = argv[i];
            }
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-help") == 0) {
            UseMsg();
            exit(0);
        }
        else if (strcmp(argv[i], "+iglx") == 0)
            enableIndirectGLX = TRUE;
        else if (strcmp(argv[i], "-iglx") == 0)
            enableIndirectGLX = FALSE;
        else if ((skip = XkbProcessArguments(argc, argv, i)) != 0) {
            if (skip > 0)
                i += skip - 1;
            else
                UseMsg();
        }
#ifdef RLIMIT_DATA
        else if (strcmp(argv[i], "-ld") == 0) {
            if (++i < argc) {
                limitDataSpace = atoi(argv[i]);
                if (limitDataSpace > 0)
                    limitDataSpace *= 1024;
            }
            else
                UseMsg();
        }
#endif
#ifdef RLIMIT_NOFILE
        else if (strcmp(argv[i], "-lf") == 0) {
            if (++i < argc)
                limitNoFile = atoi(argv[i]);
            else
                UseMsg();
        }
#endif
#ifdef RLIMIT_STACK
        else if (strcmp(argv[i], "-ls") == 0) {
            if (++i < argc) {
                limitStackSpace = atoi(argv[i]);
                if (limitStackSpace > 0)
                    limitStackSpace *= 1024;
            }
            else
                UseMsg();
        }
#endif
#ifdef LOCK_SERVER
        else if (strcmp(argv[i], "-nolock") == 0) {
#if !defined(WIN32) && !defined(__CYGWIN__)
            if (getuid() != 0)
                ErrorF
                    ("Warning: the -nolock option can only be used by root\n");
            else
#endif
                nolock = TRUE;
        }
#endif
	else if ( strcmp( argv[i], "-maxclients") == 0)
	{
	    if (++i < argc) {
		LimitClients = atoi(argv[i]);
		if (LimitClients != 64 &&
		    LimitClients != 128 &&
		    LimitClients != 256 &&
		    LimitClients != 512) {
		    FatalError("maxclients must be one of 64, 128, 256 or 512\n");
		}
	    } else
		UseMsg();
	}
        else if (strcmp(argv[i], "-nolisten") == 0) {
            if (++i < argc) {
                if (_XSERVTransNoListen(argv[i]))
                    ErrorF("Failed to disable listen for %s transport",
                           argv[i]);
            }
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-listen") == 0) {
            if (++i < argc) {
                if (_XSERVTransListen(argv[i]))
                    ErrorF("Failed to enable listen for %s transport",
                           argv[i]);
            }
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-noreset") == 0) {
            dispatchExceptionAtReset = 0;
        }
        else if (strcmp(argv[i], "-reset") == 0) {
            dispatchExceptionAtReset = DE_RESET;
        }
        else if (strcmp(argv[i], "-p") == 0) {
            if (++i < argc)
                defaultScreenSaverInterval = ((CARD32) atoi(argv[i])) *
                    MILLI_PER_MIN;
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-pogo") == 0) {
            dispatchException = DE_TERMINATE;
        }
        else if (strcmp(argv[i], "-pn") == 0)
            PartialNetwork = TRUE;
        else if (strcmp(argv[i], "-nopn") == 0)
            PartialNetwork = FALSE;
        else if (strcmp(argv[i], "r") == 0)
            defaultKeyboardControl.autoRepeat = TRUE;
        else if (strcmp(argv[i], "-r") == 0)
            defaultKeyboardControl.autoRepeat = FALSE;
#ifndef __OpenBSD__
	else if ( strcmp( argv[i], "-retro") == 0)
            party_like_its_1989 = TRUE;
#else
	else if ( strcmp( argv[i], "-retard") == 0)
	    party_like_its_1989 = FALSE;
#endif
        else if (strcmp(argv[i], "-s") == 0) {
            if (++i < argc)
                defaultScreenSaverTime = ((CARD32) atoi(argv[i])) *
                    MILLI_PER_MIN;
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-seat") == 0) {
            if (++i < argc)
                SeatId = argv[i];
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-t") == 0) {
            if (++i < argc)
                defaultPointerControl.threshold = atoi(argv[i]);
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-terminate") == 0) {
            dispatchExceptionAtReset = DE_TERMINATE;
        }
        else if (strcmp(argv[i], "-to") == 0) {
            if (++i < argc)
                TimeOutValue = ((CARD32) atoi(argv[i])) * MILLI_PER_SECOND;
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-tst") == 0) {
            noTestExtensions = TRUE;
        }
        else if (strcmp(argv[i], "v") == 0)
            defaultScreenSaverBlanking = PreferBlanking;
        else if (strcmp(argv[i], "-v") == 0)
            defaultScreenSaverBlanking = DontPreferBlanking;
        else if (strcmp(argv[i], "-wm") == 0)
            defaultBackingStore = WhenMapped;
        else if (strcmp(argv[i], "-wr") == 0)
            whiteRoot = TRUE;
        else if (strcmp(argv[i], "-background") == 0) {
            if (++i < argc) {
                if (!strcmp(argv[i], "none"))
                    bgNoneRoot = TRUE;
                else
                    UseMsg();
            }
        }
        else if (strcmp(argv[i], "-maxbigreqsize") == 0) {
            if (++i < argc) {
                long reqSizeArg = atol(argv[i]);

                /* Request size > 128MB does not make much sense... */
                if (reqSizeArg > 0L && reqSizeArg < 128L) {
                    maxBigRequestSize = (reqSizeArg * 1048576L) - 1L;
                }
                else {
                    UseMsg();
                }
            }
            else {
                UseMsg();
            }
        }
#ifdef PANORAMIX
        else if (strcmp(argv[i], "+xinerama") == 0) {
            noPanoramiXExtension = FALSE;
        }
        else if (strcmp(argv[i], "-xinerama") == 0) {
            noPanoramiXExtension = TRUE;
        }
        else if (strcmp(argv[i], "-disablexineramaextension") == 0) {
            PanoramiXExtensionDisabledHack = TRUE;
        }
#endif
        else if (strcmp(argv[i], "-I") == 0) {
            /* ignore all remaining arguments */
            break;
        }
        else if (strncmp(argv[i], "tty", 3) == 0) {
            /* init supplies us with this useless information */
        }
#ifdef XDMCP
        else if ((skip = XdmcpOptions(argc, argv, i)) != i) {
            i = skip - 1;
        }
#endif
#ifdef SMART_SCHEDULE_POSSIBLE
        else if (strcmp(argv[i], "-dumbSched") == 0) {
            SmartScheduleDisable = TRUE;
        }
        else if (strcmp(argv[i], "-schedInterval") == 0) {
            if (++i < argc) {
                SmartScheduleInterval = atoi(argv[i]);
                SmartScheduleSlice = SmartScheduleInterval;
            }
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-schedMax") == 0) {
            if (++i < argc) {
                SmartScheduleMaxSlice = atoi(argv[i]);
            }
            else
                UseMsg();
        }
#endif
        else if (strcmp(argv[i], "-render") == 0) {
            if (++i < argc) {
                int policy = PictureParseCmapPolicy(argv[i]);

                if (policy != PictureCmapPolicyInvalid)
                    PictureCmapPolicy = policy;
                else
                    UseMsg();
            }
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-sigstop") == 0) {
            RunFromSigStopParent = TRUE;
        }
        else if (strcmp(argv[i], "+extension") == 0) {
            if (++i < argc) {
                if (!EnableDisableExtension(argv[i], TRUE))
                    EnableDisableExtensionError(argv[i], TRUE);
            }
            else
                UseMsg();
        }
        else if (strcmp(argv[i], "-extension") == 0) {
            if (++i < argc) {
                if (!EnableDisableExtension(argv[i], FALSE))
                    EnableDisableExtensionError(argv[i], FALSE);
            }
            else
                UseMsg();
        }
        else {
            ErrorF("Unrecognized option: %s\n", argv[i]);
            UseMsg();
            FatalError("Unrecognized option: %s\n", argv[i]);
        }
    }
}

/* Implement a simple-minded font authorization scheme.  The authorization
   name is "hp-hostname-1", the contents are simply the host name. */
int
set_font_authorizations(char **authorizations, int *authlen, void *client)
{
#define AUTHORIZATION_NAME "hp-hostname-1"
#if defined(TCPCONN) || defined(STREAMSCONN)
    static char *result = NULL;
    static char *p = NULL;

    if (p == NULL) {
        char hname[1024], *hnameptr;
        unsigned int len;

#if defined(IPv6) && defined(AF_INET6)
        struct addrinfo hints, *ai = NULL;
#else
        struct hostent *host;

#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
        _Xgethostbynameparams hparams;
#endif
#endif

        gethostname(hname, 1024);
#if defined(IPv6) && defined(AF_INET6)
        memset(&hints, 0, sizeof(hints));
        hints.ai_flags = AI_CANONNAME;
        if (getaddrinfo(hname, NULL, &hints, &ai) == 0) {
            hnameptr = ai->ai_canonname;
        }
        else {
            hnameptr = hname;
        }
#else
        host = _XGethostbyname(hname, hparams);
        if (host == NULL)
            hnameptr = hname;
        else
            hnameptr = host->h_name;
#endif

        len = strlen(hnameptr) + 1;
        result = malloc(len + sizeof(AUTHORIZATION_NAME) + 4);

        p = result;
        *p++ = sizeof(AUTHORIZATION_NAME) >> 8;
        *p++ = sizeof(AUTHORIZATION_NAME) & 0xff;
        *p++ = (len) >> 8;
        *p++ = (len & 0xff);

        memmove(p, AUTHORIZATION_NAME, sizeof(AUTHORIZATION_NAME));
        p += sizeof(AUTHORIZATION_NAME);
        memmove(p, hnameptr, len);
        p += len;
#if defined(IPv6) && defined(AF_INET6)
        if (ai) {
            freeaddrinfo(ai);
        }
#endif
    }
    *authlen = p - result;
    *authorizations = result;
    return 1;
#else                           /* TCPCONN */
    return 0;
#endif                          /* TCPCONN */
}

void *
XNFalloc(unsigned long amount)
{
    void *ptr = malloc(amount);

    if (!ptr)
        FatalError("Out of memory");
    return ptr;
}

/* The original XNFcalloc was used with the xnfcalloc macro which multiplied
 * the arguments at the call site without allowing calloc to check for overflow.
 * XNFcallocarray was added to fix that without breaking ABI.
 */
void *
XNFcalloc(unsigned long amount)
{
    return XNFcallocarray(1, amount);
}

void *
XNFcallocarray(size_t nmemb, size_t size)
{
    void *ret = calloc(nmemb, size);

    if (!ret)
        FatalError("XNFcalloc: Out of memory");
    return ret;
}

void *
XNFrealloc(void *ptr, unsigned long amount)
{
    void *ret = realloc(ptr, amount);

    if (!ret)
        FatalError("XNFrealloc: Out of memory");
    return ret;
}

void *
XNFreallocarray(void *ptr, size_t nmemb, size_t size)
{
    void *ret = reallocarray(ptr, nmemb, size);

    if (!ret)
        FatalError("XNFreallocarray: Out of memory");
    return ret;
}

char *
Xstrdup(const char *s)
{
    if (s == NULL)
        return NULL;
    return strdup(s);
}

char *
XNFstrdup(const char *s)
{
    char *ret;

    if (s == NULL)
        return NULL;

    ret = strdup(s);
    if (!ret)
        FatalError("XNFstrdup: Out of memory");
    return ret;
}

void
SmartScheduleStopTimer(void)
{
#ifdef SMART_SCHEDULE_POSSIBLE
    struct itimerval timer;

    if (SmartScheduleDisable)
        return;
    timer.it_interval.tv_sec = 0;
    timer.it_interval.tv_usec = 0;
    timer.it_value.tv_sec = 0;
    timer.it_value.tv_usec = 0;
    (void) setitimer(ITIMER_REAL, &timer, 0);
#endif
}

void
SmartScheduleStartTimer(void)
{
#ifdef SMART_SCHEDULE_POSSIBLE
    struct itimerval timer;

    if (SmartScheduleDisable)
        return;
    timer.it_interval.tv_sec = 0;
    timer.it_interval.tv_usec = SmartScheduleInterval * 1000;
    timer.it_value.tv_sec = 0;
    timer.it_value.tv_usec = SmartScheduleInterval * 1000;
    setitimer(ITIMER_REAL, &timer, 0);
#endif
}

static void
SmartScheduleTimer(int sig)
{
    SmartScheduleTime += SmartScheduleInterval;
}

static int
SmartScheduleEnable(void)
{
    int ret = 0;
#ifdef SMART_SCHEDULE_POSSIBLE
    struct sigaction act;

    if (SmartScheduleDisable)
        return 0;

    memset((char *) &act, 0, sizeof(struct sigaction));

    /* Set up the timer signal function */
    act.sa_flags = SA_RESTART;
    act.sa_handler = SmartScheduleTimer;
    sigemptyset(&act.sa_mask);
    sigaddset(&act.sa_mask, SIGALRM);
    ret = sigaction(SIGALRM, &act, 0);
#endif
    return ret;
}

static int
SmartSchedulePause(void)
{
    int ret = 0;
#ifdef SMART_SCHEDULE_POSSIBLE
    struct sigaction act;

    if (SmartScheduleDisable)
        return 0;

    memset((char *) &act, 0, sizeof(struct sigaction));

    act.sa_handler = SIG_IGN;
    sigemptyset(&act.sa_mask);
    ret = sigaction(SIGALRM, &act, 0);
#endif
    return ret;
}

void
SmartScheduleInit(void)
{
    if (SmartScheduleDisable)
        return;

    if (SmartScheduleEnable() < 0) {
        perror("sigaction for smart scheduler");
        SmartScheduleDisable = TRUE;
    }
}

#ifdef SIG_BLOCK
static sigset_t PreviousSignalMask;
static int BlockedSignalCount;
#endif

void
OsBlockSignals(void)
{
#ifdef SIG_BLOCK
    if (BlockedSignalCount++ == 0) {
        sigset_t set;

#ifdef SIGIO
        OsBlockSIGIO();
#endif
        sigemptyset(&set);
        sigaddset(&set, SIGALRM);
        sigaddset(&set, SIGVTALRM);
#ifdef SIGWINCH
        sigaddset(&set, SIGWINCH);
#endif
        sigaddset(&set, SIGTSTP);
        sigaddset(&set, SIGTTIN);
        sigaddset(&set, SIGTTOU);
        sigaddset(&set, SIGCHLD);
        sigprocmask(SIG_BLOCK, &set, &PreviousSignalMask);
    }
#endif
}

#ifdef SIG_BLOCK
static sig_atomic_t sigio_blocked;
static sigset_t PreviousSigIOMask;
#endif

/**
 * returns zero if this call caused SIGIO to be blocked now, non-zero if it
 * was already blocked by a previous call to this function.
 */
int
OsBlockSIGIO(void)
{
#ifdef SIGIO
#ifdef SIG_BLOCK
    if (sigio_blocked++ == 0) {
        sigset_t set;
        int ret;

        sigemptyset(&set);
        sigaddset(&set, SIGIO);
        sigprocmask(SIG_BLOCK, &set, &PreviousSigIOMask);
        ret = sigismember(&PreviousSigIOMask, SIGIO);
        return ret;
    }
#endif
#endif
    return 1;
}

void
OsReleaseSIGIO(void)
{
#ifdef SIGIO
#ifdef SIG_BLOCK
    if (--sigio_blocked == 0) {
        sigprocmask(SIG_SETMASK, &PreviousSigIOMask, 0);
    } else if (sigio_blocked < 0) {
        BUG_WARN(sigio_blocked < 0);
        sigio_blocked = 0;
    }
#endif
#endif
}

void
OsReleaseSignals(void)
{
#ifdef SIG_BLOCK
    if (--BlockedSignalCount == 0) {
        sigprocmask(SIG_SETMASK, &PreviousSignalMask, 0);
        OsReleaseSIGIO();
    }
#endif
}

void
OsResetSignals(void)
{
#ifdef SIG_BLOCK
    while (BlockedSignalCount > 0)
        OsReleaseSignals();
#ifdef SIGIO
    while (sigio_blocked > 0)
        OsReleaseSIGIO();
#endif
#endif
}

/*
 * Pending signals may interfere with core dumping. Provide a
 * mechanism to block signals when aborting.
 */

void
OsAbort(void)
{
#ifndef __APPLE__
    OsBlockSignals();
#endif
    abort();
}

#if !defined(WIN32)
/*
 * "safer" versions of system(3), popen(3) and pclose(3) which give up
 * all privs before running a command.
 *
 * This is based on the code in FreeBSD 2.2 libc.
 *
 * XXX It'd be good to redirect stderr so that it ends up in the log file
 * as well.  As it is now, xkbcomp messages don't end up in the log file.
 */

int
System(const char *command)
{
    int pid, p;
    void (*csig) (int);
    int status;

    if (!command)
        return 1;

    csig = signal(SIGCHLD, SIG_DFL);
    if (csig == SIG_ERR) {
        perror("signal");
        return -1;
    }
    DebugF("System: `%s'\n", command);

    switch (pid = fork()) {
    case -1:                   /* error */
        p = -1;
        break;
    case 0:                    /* child */
        if (setgid(getgid()) == -1)
            _exit(127);
        if (setuid(getuid()) == -1)
            _exit(127);
        execl("/bin/sh", "sh", "-c", command, (char *) NULL);
        _exit(127);
    default:                   /* parent */
        do {
            p = waitpid(pid, &status, 0);
        } while (p == -1 && errno == EINTR);

    }

    if (signal(SIGCHLD, csig) == SIG_ERR) {
        perror("signal");
        return -1;
    }

    return p == -1 ? -1 : status;
}

static struct pid {
    struct pid *next;
    FILE *fp;
    int pid;
} *pidlist;

void *
Popen(const char *command, const char *type)
{
    struct pid *cur;
    FILE *iop;
    int pdes[2], pid;

    if (command == NULL || type == NULL)
        return NULL;

    if ((*type != 'r' && *type != 'w') || type[1])
        return NULL;

    if ((cur = malloc(sizeof(struct pid))) == NULL)
        return NULL;

    if (pipe(pdes) < 0) {
        free(cur);
        return NULL;
    }

    /* Ignore the smart scheduler while this is going on */
    if (SmartSchedulePause() < 0) {
        close(pdes[0]);
        close(pdes[1]);
        free(cur);
        perror("signal");
        return NULL;
    }

    switch (pid = fork()) {
    case -1:                   /* error */
        close(pdes[0]);
        close(pdes[1]);
        free(cur);
        if (SmartScheduleEnable() < 0)
            perror("signal");
        return NULL;
    case 0:                    /* child */
        if (setgid(getgid()) == -1)
            _exit(127);
        if (setuid(getuid()) == -1)
            _exit(127);
        if (*type == 'r') {
            if (pdes[1] != 1) {
                /* stdout */
                dup2(pdes[1], 1);
                close(pdes[1]);
            }
            close(pdes[0]);
        }
        else {
            if (pdes[0] != 0) {
                /* stdin */
                dup2(pdes[0], 0);
                close(pdes[0]);
            }
            close(pdes[1]);
        }
        execl("/bin/sh", "sh", "-c", command, (char *) NULL);
        _exit(127);
    }

    /* Avoid EINTR during stdio calls */
    OsBlockSignals();

    /* parent */
    if (*type == 'r') {
        iop = fdopen(pdes[0], type);
        close(pdes[1]);
    }
    else {
        iop = fdopen(pdes[1], type);
        close(pdes[0]);
    }

    cur->fp = iop;
    cur->pid = pid;
    cur->next = pidlist;
    pidlist = cur;

    DebugF("Popen: `%s', fp = %p\n", command, iop);

    return iop;
}

/* fopen that drops privileges */
void *
Fopen(const char *file, const char *type)
{
    FILE *iop;

#ifndef HAS_SAVED_IDS_AND_SETEUID
    struct pid *cur;
    int pdes[2], pid;

    if (file == NULL || type == NULL)
        return NULL;

    if ((*type != 'r' && *type != 'w') || type[1])
        return NULL;

    if ((cur = malloc(sizeof(struct pid))) == NULL)
        return NULL;

    if (pipe(pdes) < 0) {
        free(cur);
        return NULL;
    }

    switch (pid = fork()) {
    case -1:                   /* error */
        close(pdes[0]);
        close(pdes[1]);
        free(cur);
        return NULL;
    case 0:                    /* child */
        if (setgid(getgid()) == -1)
            _exit(127);
        if (setuid(getuid()) == -1)
            _exit(127);
        if (*type == 'r') {
            if (pdes[1] != 1) {
                /* stdout */
                dup2(pdes[1], 1);
                close(pdes[1]);
            }
            close(pdes[0]);
        }
        else {
            if (pdes[0] != 0) {
                /* stdin */
                dup2(pdes[0], 0);
                close(pdes[0]);
            }
            close(pdes[1]);
        }
        execl("/bin/cat", "cat", file, (char *) NULL);
        _exit(127);
    }

    /* Avoid EINTR during stdio calls */
    OsBlockSignals();

    /* parent */
    if (*type == 'r') {
        iop = fdopen(pdes[0], type);
        close(pdes[1]);
    }
    else {
        iop = fdopen(pdes[1], type);
        close(pdes[0]);
    }

    cur->fp = iop;
    cur->pid = pid;
    cur->next = pidlist;
    pidlist = cur;

    DebugF("Fopen(%s), fp = %p\n", file, iop);

    return iop;
#else
    int ruid, euid;

    ruid = getuid();
    euid = geteuid();

    if (seteuid(ruid) == -1) {
        return NULL;
    }
    iop = fopen(file, type);

    if (seteuid(euid) == -1) {
        fclose(iop);
        return NULL;
    }
    return iop;
#endif                          /* HAS_SAVED_IDS_AND_SETEUID */
}

int
Pclose(void *iop)
{
    struct pid *cur, *last;
    int pstat;
    int pid;

    DebugF("Pclose: fp = %p\n", iop);
    fclose(iop);

    for (last = NULL, cur = pidlist; cur; last = cur, cur = cur->next)
        if (cur->fp == iop)
            break;
    if (cur == NULL)
        return -1;

    do {
        pid = waitpid(cur->pid, &pstat, 0);
    } while (pid == -1 && errno == EINTR);

    if (last == NULL)
        pidlist = cur->next;
    else
        last->next = cur->next;
    free(cur);

    /* allow EINTR again */
    OsReleaseSignals();

    if (SmartScheduleEnable() < 0) {
        perror("signal");
        return -1;
    }

    return pid == -1 ? -1 : pstat;
}

int
Fclose(void *iop)
{
#ifdef HAS_SAVED_IDS_AND_SETEUID
    return fclose(iop);
#else
    return Pclose(iop);
#endif
}

#endif                          /* !WIN32 */

#ifdef WIN32

#include <X11/Xwindows.h>

const char *
Win32TempDir(void)
{
    static char buffer[PATH_MAX];

    if (GetTempPath(sizeof(buffer), buffer)) {
        int len;

        buffer[sizeof(buffer) - 1] = 0;
        len = strlen(buffer);
        if (len > 0)
            if (buffer[len - 1] == '\\')
                buffer[len - 1] = 0;
        return buffer;
    }
    if (getenv("TEMP") != NULL)
        return getenv("TEMP");
    else if (getenv("TMP") != NULL)
        return getenv("TMP");
    else
        return "/tmp";
}

int
System(const char *cmdline)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD dwExitCode;
    char *cmd = strdup(cmdline);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    if (!CreateProcess(NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
        LPVOID buffer;

        if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_SYSTEM |
                           FORMAT_MESSAGE_IGNORE_INSERTS,
                           NULL,
                           GetLastError(),
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPTSTR) &buffer, 0, NULL)) {
            ErrorF("[xkb] Starting '%s' failed!\n", cmdline);
        }
        else {
            ErrorF("[xkb] Starting '%s' failed: %s", cmdline, (char *) buffer);
            LocalFree(buffer);
        }

        free(cmd);
        return -1;
    }
    /* Wait until child process exits. */
    WaitForSingleObject(pi.hProcess, INFINITE);

    GetExitCodeProcess(pi.hProcess, &dwExitCode);

    /* Close process and thread handles. */
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    free(cmd);

    return dwExitCode;
}
#endif

/*
 * CheckUserParameters: check for long command line arguments and long
 * environment variables.  By default, these checks are only done when
 * the server's euid != ruid.  In 3.3.x, these checks were done in an
 * external wrapper utility.
 */

/* Consider LD* variables insecure? */
#ifndef REMOVE_ENV_LD
#define REMOVE_ENV_LD 1
#endif

/* Remove long environment variables? */
#ifndef REMOVE_LONG_ENV
#define REMOVE_LONG_ENV 1
#endif

/*
 * Disallow stdout or stderr as pipes?  It's possible to block the X server
 * when piping stdout+stderr to a pipe.
 *
 * Don't enable this because it looks like it's going to cause problems.
 */
#ifndef NO_OUTPUT_PIPES
#define NO_OUTPUT_PIPES 0
#endif

/* Check args and env only if running setuid (euid == 0 && euid != uid) ? */
#ifndef CHECK_EUID
#ifndef WIN32
#define CHECK_EUID 1
#else
#define CHECK_EUID 0
#endif
#endif

/*
 * Maybe the locale can be faked to make isprint(3) report that everything
 * is printable?  Avoid it by default.
 */
#ifndef USE_ISPRINT
#define USE_ISPRINT 0
#endif

#define MAX_ARG_LENGTH          128
#define MAX_ENV_LENGTH          256
#define MAX_ENV_PATH_LENGTH     2048    /* Limit for *PATH and TERMCAP */

#if USE_ISPRINT
#include <ctype.h>
#define checkPrintable(c) isprint(c)
#else
#define checkPrintable(c) (((c) & 0x7f) >= 0x20 && ((c) & 0x7f) != 0x7f)
#endif

enum BadCode {
    NotBad = 0,
    UnsafeArg,
    ArgTooLong,
    UnprintableArg,
    EnvTooLong,
    OutputIsPipe,
    InternalError
};

#if defined(VENDORSUPPORT)
#define BUGADDRESS VENDORSUPPORT
#elif defined(BUILDERADDR)
#define BUGADDRESS BUILDERADDR
#else
#define BUGADDRESS "xorg@@freedesktop.org"
#endif

void
CheckUserParameters(int argc, char **argv, char **envp)
{
    enum BadCode bad = NotBad;
    int i = 0, j;
    char *a, *e = NULL;

#if CHECK_EUID
    if (geteuid() == 0 && getuid() != geteuid())
#endif
    {
        /* Check each argv[] */
        for (i = 1; i < argc; i++) {
            if (strcmp(argv[i], "-fp") == 0) {
                i++;            /* continue with next argument. skip the length check */
                if (i >= argc)
                    break;
            }
            else {
                if (strlen(argv[i]) > MAX_ARG_LENGTH) {
                    bad = ArgTooLong;
                    break;
                }
            }
            a = argv[i];
            while (*a) {
                if (checkPrintable(*a) == 0) {
                    bad = UnprintableArg;
                    break;
                }
                a++;
            }
            if (bad)
                break;
        }
        if (!bad) {
            /* Check each envp[] */
            for (i = 0; envp[i]; i++) {

                /* Check for bad environment variables and values */
#if REMOVE_ENV_LD
                while (envp[i] && (strncmp(envp[i], "LD", 2) == 0)) {
                    for (j = i; envp[j]; j++) {
                        envp[j] = envp[j + 1];
                    }
                }
#endif
                if (envp[i] && (strlen(envp[i]) > MAX_ENV_LENGTH)) {
#if REMOVE_LONG_ENV
                    for (j = i; envp[j]; j++) {
                        envp[j] = envp[j + 1];
                    }
                    i--;
#else
                    char *eq;
                    int len;

                    eq = strchr(envp[i], '=');
                    if (!eq)
                        continue;
                    len = eq - envp[i];
                    e = strndup(envp[i], len);
                    if (!e) {
                        bad = InternalError;
                        break;
                    }
                    if (len >= 4 &&
                        (strcmp(e + len - 4, "PATH") == 0 ||
                         strcmp(e, "TERMCAP") == 0)) {
                        if (strlen(envp[i]) > MAX_ENV_PATH_LENGTH) {
                            bad = EnvTooLong;
                            break;
                        }
                        else {
                            free(e);
                        }
                    }
                    else {
                        bad = EnvTooLong;
                        break;
                    }
#endif
                }
            }
        }
#if NO_OUTPUT_PIPES
        if (!bad) {
            struct stat buf;

            if (fstat(fileno(stdout), &buf) == 0 && S_ISFIFO(buf.st_mode))
                bad = OutputIsPipe;
            if (fstat(fileno(stderr), &buf) == 0 && S_ISFIFO(buf.st_mode))
                bad = OutputIsPipe;
        }
#endif
    }
    switch (bad) {
    case NotBad:
        return;
    case UnsafeArg:
        ErrorF("Command line argument number %d is unsafe\n", i);
        break;
    case ArgTooLong:
        ErrorF("Command line argument number %d is too long\n", i);
        break;
    case UnprintableArg:
        ErrorF("Command line argument number %d contains unprintable"
               " characters\n", i);
        break;
    case EnvTooLong:
        ErrorF("Environment variable `%s' is too long\n", e);
        break;
    case OutputIsPipe:
        ErrorF("Stdout and/or stderr is a pipe\n");
        break;
    case InternalError:
        ErrorF("Internal Error\n");
        break;
    default:
        ErrorF("Unknown error\n");
        break;
    }
    FatalError("X server aborted because of unsafe environment\n");
}

/*
 * CheckUserAuthorization: check if the user is allowed to start the
 * X server.  This usually means some sort of PAM checking, and it is
 * usually only done for setuid servers (uid != euid).
 */

#ifdef USE_PAM
#include <security/pam_appl.h>
#include <security/pam_misc.h>
#include <pwd.h>
#endif                          /* USE_PAM */

void
CheckUserAuthorization(void)
{
#ifdef USE_PAM
    static struct pam_conv conv = {
        misc_conv,
        NULL
    };

    pam_handle_t *pamh = NULL;
    struct passwd *pw;
    int retval;

    if (getuid() != geteuid()) {
        pw = getpwuid(getuid());
        if (pw == NULL)
            FatalError("getpwuid() failed for uid %d\n", getuid());

        retval = pam_start("xserver", pw->pw_name, &conv, &pamh);
        if (retval != PAM_SUCCESS)
            FatalError("pam_start() failed.\n"
                       "\tMissing or mangled PAM config file or module?\n");

        retval = pam_authenticate(pamh, 0);
        if (retval != PAM_SUCCESS) {
            pam_end(pamh, retval);
            FatalError("PAM authentication failed, cannot start X server.\n"
                       "\tPerhaps you do not have console ownership?\n");
        }

        retval = pam_acct_mgmt(pamh, 0);
        if (retval != PAM_SUCCESS) {
            pam_end(pamh, retval);
            FatalError("PAM authentication failed, cannot start X server.\n"
                       "\tPerhaps you do not have console ownership?\n");
        }

        /* this is not a session, so do not do session management */
        pam_end(pamh, PAM_SUCCESS);
    }
#endif
}

/*
 * Tokenize a string into a NULL terminated array of strings. Always returns
 * an allocated array unless an error occurs.
 */
char **
xstrtokenize(const char *str, const char *separators)
{
    char **list, **nlist;
    char *tok, *tmp;
    unsigned num = 0, n;

    if (!str)
        return NULL;
    list = calloc(1, sizeof(*list));
    if (!list)
        return NULL;
    tmp = strdup(str);
    if (!tmp)
        goto error;
    for (tok = strtok(tmp, separators); tok; tok = strtok(NULL, separators)) {
        nlist = reallocarray(list, num + 2, sizeof(*list));
        if (!nlist)
            goto error;
        list = nlist;
        list[num] = strdup(tok);
        if (!list[num])
            goto error;
        list[++num] = NULL;
    }
    free(tmp);
    return list;

 error:
    free(tmp);
    for (n = 0; n < num; n++)
        free(list[n]);
    free(list);
    return NULL;
}

/* Format a signed number into a string in a signal safe manner. The string
 * should be at least 21 characters in order to handle all int64_t values.
 */
void
FormatInt64(int64_t num, char *string)
{
    if (num < 0) {
        string[0] = '-';
        num *= -1;
        string++;
    }
    FormatUInt64(num, string);
}

/* Format a number into a string in a signal safe manner. The string should be
 * at least 21 characters in order to handle all uint64_t values. */
void
FormatUInt64(uint64_t num, char *string)
{
    uint64_t divisor;
    int len;
    int i;

    for (len = 1, divisor = 10;
         len < 20 && num / divisor;
         len++, divisor *= 10);

    for (i = len, divisor = 1; i > 0; i--, divisor *= 10)
        string[i - 1] = '0' + ((num / divisor) % 10);

    string[len] = '\0';
}

/**
 * Format a double number as %.2f.
 */
void
FormatDouble(double dbl, char *string)
{
    int slen = 0;
    uint64_t frac;

    frac = (dbl > 0 ? dbl : -dbl) * 100.0 + 0.5;
    frac %= 100;

    /* write decimal part to string */
    if (dbl < 0 && dbl > -1)
        string[slen++] = '-';
    FormatInt64((int64_t)dbl, &string[slen]);

    while(string[slen] != '\0')
        slen++;

    /* append fractional part, but only if we have enough characters. We
     * expect string to be 21 chars (incl trailing \0) */
    if (slen <= 17) {
        string[slen++] = '.';
        if (frac < 10)
            string[slen++] = '0';

        FormatUInt64(frac, &string[slen]);
    }
}


/* Format a number into a hexadecimal string in a signal safe manner. The string
 * should be at least 17 characters in order to handle all uint64_t values. */
void
FormatUInt64Hex(uint64_t num, char *string)
{
    uint64_t divisor;
    int len;
    int i;

    for (len = 1, divisor = 0x10;
         len < 16 && num / divisor;
         len++, divisor *= 0x10);

    for (i = len, divisor = 1; i > 0; i--, divisor *= 0x10) {
        int val = (num / divisor) % 0x10;

        if (val < 10)
            string[i - 1] = '0' + val;
        else
            string[i - 1] = 'a' + val - 10;
    }

    string[len] = '\0';
}

#if !defined(WIN32) || defined(__CYGWIN__)
/* Move a file descriptor out of the way of our select mask; this
 * is useful for file descriptors which will never appear in the
 * select mask to avoid reducing the number of clients that can
 * connect to the server
 */
int
os_move_fd(int fd)
{
    int newfd;

#ifdef F_DUPFD_CLOEXEC
    newfd = fcntl(fd, F_DUPFD_CLOEXEC, MAXCLIENTS);
#else
    newfd = fcntl(fd, F_DUPFD, MAXCLIENTS);
#endif
    if (newfd < 0)
        return fd;
#ifndef F_DUPFD_CLOEXEC
    fcntl(newfd, F_SETFD, FD_CLOEXEC);
#endif
    close(fd);
    return newfd;
}
#endif
@


1.21
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d84 1
d572 1
d881 13
d1167 4
d1174 7
a1180 1
    void *ret = calloc(1, amount);
d1197 10
d1727 1
a1727 1
Win32TempDir()
d2068 1
a2068 1
        nlist = realloc(list, (num + 2) * sizeof(*list));
@


1.20
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d1232 2
a1233 2
void
SmartScheduleInit(void)
d1235 1
d1240 1
a1240 1
        return;
d1245 1
d1249 31
a1279 1
    if (sigaction(SIGALRM, &act, 0) < 0) {
a1282 1
#endif
a1456 2
OsSigHandlerPtr old_alarm = NULL;       /* XXX horrible awful hack */

d1479 1
a1479 2
    old_alarm = OsSignal(SIGALRM, SIG_IGN);
    if (old_alarm == SIG_ERR) {
d1492 1
a1492 1
        if (OsSignal(SIGALRM, old_alarm) == SIG_ERR)
d1667 1
a1667 1
    if (old_alarm && OsSignal(SIGALRM, old_alarm) == SIG_ERR) {
@


1.19
log
@Merge from upstream: Don't listen to 'tcp' by default. Add '-listen' option.

commit cc59be38b7eff52a1d003b390f2994c73ee0b3e9
Author: Keith Packard <keithp@@keithp.com>
Date:   Fri Sep 12 11:33:48 2014 -0700

    os: Don't listen to 'tcp' by default. Add '-listen' option. [v2]

    This disables the tcp listen socket by default. Then, it
    uses a new xtrans interface, TRANS(Listen), to provide a command line
    option to re-enable those if desired.

    v2: Leave unix socket enabled by default. Add configure options.

    Signed-off-by: Keith Packard <keithp@@keithp.com>
    Reviewed-by: Hans de Goede <hdegoede@@redhat.com>
@
text
@d197 1
a197 1
Bool enableIndirectGLX = TRUE;
d556 2
a557 2
    ErrorF("+iglx                  Allow creating indirect GLX contexts (default)\n");
    ErrorF("-iglx                  Prohibit creating indirect GLX contexts\n");
a1142 18
Xalloc(unsigned long amount)
{
    /*
     * Xalloc used to return NULL when large amount of memory is requested. In
     * order to catch the buggy callers this warning has been added, slated to
     * removal by anyone who touches this code (or just looks at it) in 2011.
     *
     * -- Mikhail Gusarov
     */
    if ((long) amount <= 0)
        ErrorF("Warning: Xalloc: "
               "requesting unpleasantly large amount of memory: %lu bytes.\n",
               amount);

    return malloc(amount);
}

void *
a1152 6
Xcalloc(unsigned long amount)
{
    return calloc(1, amount);
}

void *
a1162 18
Xrealloc(void *ptr, unsigned long amount)
{
    /*
     * Xrealloc used to return NULL when large amount of memory is requested. In
     * order to catch the buggy callers this warning has been added, slated to
     * removal by anyone who touches this code (or just looks at it) in 2011.
     *
     * -- Mikhail Gusarov
     */
    if ((long) amount <= 0)
        ErrorF("Warning: Xrealloc: "
               "requesting unpleasantly large amount of memory: %lu bytes.\n",
               amount);

    return realloc(ptr, amount);
}

void *
a1171 6
void
Xfree(void *ptr)
{
    free(ptr);
}

d1397 1
d2115 1
d2139 1
@


1.18
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d572 1
d666 13
d697 6
d883 9
@


1.17
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d197 2
d275 1
a275 1
    if (nolock)
d318 2
a319 1
    (void) write(lfd, pid_str, 11);
d400 1
a400 1
    if (nolock)
d508 1
a508 1
AdjustWaitForDelay(pointer waitTime, unsigned long newdelay)
d544 1
d556 2
d691 1
a761 1
                display = NULL;
d808 4
d1047 1
a1047 1
set_font_authorizations(char **authorizations, int *authlen, pointer client)
d1446 1
a1446 1
pointer
d1534 1
a1534 1
pointer
d1629 1
a1629 1
Pclose(pointer iop)
d1666 1
a1666 1
Fclose(pointer iop)
@


1.16
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a171 1
#ifdef XFIXES
a172 1
#endif
d445 5
d480 22
d619 4
d633 23
d2121 24
@


1.15
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d74 1
a141 1
Bool noGlxVisualInit = FALSE;
d207 2
d216 3
d229 1
d243 13
d286 2
a287 4
    (void) snprintf(tmp, sizeof(tmp),
                    "%s" LOCK_TMP_PREFIX "%s" LOCK_SUFFIX, tmppath, port);
    (void) snprintf(LockFile, sizeof(LockFile),
                   "%s" LOCK_PREFIX "%s" LOCK_SUFFIX, tmppath, port);
d407 1
d413 1
a413 1
    return chown(LockFile, uid, gid);
d537 1
d539 1
d553 1
a553 2
    ErrorF("-retard                start with black background "
           "and no cursor\n");
d700 11
d786 1
d796 1
d800 2
a801 2
                    FatalError("Failed to disable listen for %s transport",
                               argv[i]);
d831 1
a831 1
        else if (strcmp(argv[i], "-retro") == 0)
d834 2
a835 2
        else if ( strcmp( argv[i], "-retard") == 0)
            party_like_its_1989 = FALSE;
d923 1
d942 1
d1154 1
d1164 1
d1170 1
d1180 1
d1192 1
d1208 1
d1223 3
a1231 3
#ifdef SIGIO
        sigaddset(&set, SIGIO);
#endif
d1241 44
d1291 1
d1296 13
d1615 73
d1979 90
@


1.14
log
@Update to xserver 1.11.2
@
text
@a26 1

d101 1
a101 1
#if !defined(SYSV) && !defined(WIN32) 
d105 1
a105 1
#include <ctype.h>    /* for isspace */
d108 1
a108 1
#include <stdlib.h>	/* for malloc() */
d111 3
a113 3
# ifndef WIN32
#  include <netdb.h>
# endif
d125 1
d153 1
d205 2
d218 1
a218 1
	sigaddset(&act.sa_mask, sig);
d222 1
a222 1
      perror("sigaction");
d250 27
a276 39
  char tmp[PATH_MAX], pid_str[12];
  int lfd, i, haslock, l_pid, t;
  char *tmppath = NULL;
  int len;
  char port[20];

  if (nolock) return;
  /*
   * Path names
   */
  tmppath = LOCK_DIR;

  snprintf(port, sizeof(port), "%d", atoi(display));
  len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :
						strlen(LOCK_TMP_PREFIX);
  len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;
  if (len > sizeof(LockFile))
    FatalError("Display name `%s' is too long\n", port);
  (void)snprintf(tmp, sizeof(tmp), 
      "%s" LOCK_TMP_PREFIX "%s" LOCK_SUFFIX, tmppath, port);
  (void)snprintf(LockFile, sizeof(LockFile), 
      "%s" LOCK_PREFIX "%s" LOCK_SUFFIX, tmppath, port);

  /*
   * Create a temporary file containing our PID.  Attempt three times
   * to create the file.
   */
  StillLocking = TRUE;
  i = 0;
  do {
    i++;
    lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
    if (lfd < 0)
       sleep(2);
    else
       break;
  } while (i < 3);
  if (lfd < 0) {
    unlink(tmp);
d279 6
a284 6
      i++;
      lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);
      if (lfd < 0)
         sleep(2);
      else
         break;
d286 16
a301 5
  }
  if (lfd < 0)
    FatalError("Could not create lock file in %s\n", tmp);
  (void) snprintf(pid_str, sizeof(pid_str), "%10ld\n", (long)getpid());
  (void) write(lfd, pid_str, 11);
d303 2
a304 2
  /* if possible give away the lock file to the real uid/gid */
  fchown(lfd, getuid(), getgid());
d306 2
a307 2
  (void) fchmod(lfd, 0444);
  (void) close(lfd);
d309 59
a367 13
  /*
   * OK.  Now the tmp file exists.  Try three times to move it in place
   * for the lock.
   */
  i = 0;
  haslock = 0;
  while ((!haslock) && (i++ < 3)) {
    haslock = (link(tmp,LockFile) == 0);
    if (haslock) {
      /*
       * We're done.
       */
      break;
d369 4
a372 49
    else {
      /*
       * Read the pid from the existing file
       */
      lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);
      if (lfd < 0) {
        unlink(tmp);
        FatalError("Can't read lock file %s\n", LockFile);
      }
      pid_str[0] = '\0';
      if (read(lfd, pid_str, 11) != 11) {
        /*
         * Bogus lock file.
         */
        unlink(LockFile);
        close(lfd);
        continue;
      }
      pid_str[11] = '\0';
      sscanf(pid_str, "%d", &l_pid);
      close(lfd);

      /*
       * Now try to kill the PID to see if it exists.
       */
      errno = 0;
      t = kill(l_pid, 0);
      if ((t< 0) && (errno == ESRCH)) {
        /*
         * Stale lock file.
         */
        unlink(LockFile);
        continue;
      }
      else if (((t < 0) && (errno == EPERM)) || (t == 0)) {
        /*
         * Process is still active.
         */
        unlink(tmp);
	FatalError("Server is already active for display %s\n%s %s\n%s\n",
		   port, "\tIf this server is no longer running, remove",
		   LockFile, "\tand start again.");
      }
    }
  }
  unlink(tmp);
  if (!haslock)
    FatalError("Could not create server lock file: %s\n", LockFile);
  StillLocking = FALSE;
d382 2
a383 1
  if (nolock) return;
d385 1
a385 1
  if (!StillLocking){
d387 2
a388 2
  (void) unlink(LockFile);
  }
d395 1
a395 1
	return chown(LockFile, uid, gid);
d402 1
a402 1
AutoResetServer (int sig)
d425 1
a425 1
GetTimeInMillis (void)
d427 1
a427 1
  return GetTickCount ();
d438 1
d457 1
a457 1
    return(tv.tv_sec * 1000) + (tv.tv_usec / 1000);
d462 1
a462 1
AdjustWaitForDelay (pointer waitTime, unsigned long newdelay)
d464 8
a471 9
    static struct timeval   delay_val;
    struct timeval	    **wt = (struct timeval **) waitTime;
    unsigned long	    olddelay;

    if (*wt == NULL)
    {
	delay_val.tv_sec = newdelay / 1000;
	delay_val.tv_usec = 1000 * (newdelay % 1000);
	*wt = &delay_val;
d473 6
a478 8
    else
    {
	olddelay = (*wt)->tv_sec * 1000 + (*wt)->tv_usec / 1000;
	if (newdelay < olddelay)
	{
	    (*wt)->tv_sec = newdelay / 1000;
	    (*wt)->tv_usec = 1000 * (newdelay % 1000);
	}
d482 2
a483 1
void UseMsg(void)
d488 2
a489 2
    ErrorF("-audit int             set audit trail level\n");	
    ErrorF("-auth file             select authorization file\n");	
d502 2
a503 1
    ErrorF("-deferglyphs [none|all|16] defer loading of [no|all|16-bit] glyphs\n");
d533 2
a534 1
    ErrorF("-retard		   start with black background and no cursor\n");
d537 1
d552 2
a553 1
    ErrorF("-dumbSched             Disable smart scheduling, enable old behavior\n");
d572 1
a572 1
static int 
d575 10
a584 5
    if ( d == (char *)0 ) return 0;  /*  null  */
    if ( *d == '\0' ) return 0;  /*  empty  */
    if ( *d == '-' ) return 0;  /*  could be confused for an option  */
    if ( *d == '.' ) return 0;  /*  must not equal "." or ".."  */
    if ( strchr(d, '/') != (char *)0 ) return 0;  /*  very important!!!  */
d606 10
a615 13
    for ( i = 1; i < argc; i++ )
    {
	/* call ddx first, so it can peek/override if it wants */
        if((skip = ddxProcessArgument(argc, argv, i)))
	{
	    i += (skip - 1);
	}
	else if(argv[i][0] ==  ':')  
	{
	    /* initialize display */
	    display = argv[i];
	    display++;
            if( ! VerifyDisplayName( display ) ) {
d618 1
a618 1
		FatalError("Bad display name, exiting: %s\n", display);
d620 43
a662 51
	}
	else if ( strcmp( argv[i], "-a") == 0)
	{
	    if(++i < argc)
	        defaultPointerControl.num = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-ac") == 0)
	{
	    defeatAccessControl = TRUE;
	}
	else if ( strcmp( argv[i], "-audit") == 0)
	{
	    if(++i < argc)
	        auditTrailLevel = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-auth") == 0)
	{
	    if(++i < argc)
	        InitAuthorization (argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-br") == 0) ; /* default */
	else if ( strcmp( argv[i], "+bs") == 0)
	    enableBackingStore = TRUE;
	else if ( strcmp( argv[i], "-bs") == 0)
	    disableBackingStore = TRUE;
	else if ( strcmp( argv[i], "c") == 0)
	{
	    if(++i < argc)
	        defaultKeyboardControl.click = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-c") == 0)
	{
	    defaultKeyboardControl.click = 0;
	}
	else if ( strcmp( argv[i], "-cc") == 0)
	{
	    if(++i < argc)
	        defaultColorVisualClass = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-core") == 0)
	{
d664 9
a672 9
	    struct rlimit   core_limit;
	    getrlimit (RLIMIT_CORE, &core_limit);
	    core_limit.rlim_cur = core_limit.rlim_max;
	    setrlimit (RLIMIT_CORE, &core_limit);
#endif
	    CoreDump = TRUE;
	}
        else if ( strcmp( argv[i], "-nocursor") == 0)
        {
d675 6
a680 7
        else if ( strcmp( argv[i], "-dpi") == 0)
	{
	    if(++i < argc)
	        monitorResolution = atoi(argv[i]);
	    else
		UseMsg();
	}
d682 44
a725 50
	else if ( strcmp( argv[i], "dpms") == 0)
	    /* ignored for compatibility */ ;
	else if ( strcmp( argv[i], "-dpms") == 0)
	    DPMSDisabledSwitch = TRUE;
#endif
	else if ( strcmp( argv[i], "-deferglyphs") == 0)
	{
	    if(++i >= argc || !ParseGlyphCachingMode(argv[i]))
		UseMsg();
	}
	else if ( strcmp( argv[i], "-f") == 0)
	{
	    if(++i < argc)
	        defaultKeyboardControl.bell = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-fc") == 0)
	{
	    if(++i < argc)
	        defaultCursorFont = argv[i];
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-fn") == 0)
	{
	    if(++i < argc)
	        defaultTextFont = argv[i];
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-fp") == 0)
	{
	    if(++i < argc)
	    {
	        defaultFontPath = argv[i];
	    }
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-help") == 0)
	{
	    UseMsg();
	    exit(0);
	}
        else if ( (skip=XkbProcessArguments(argc,argv,i))!=0 ) {
	    if (skip>0)
		 i+= skip-1;
	    else UseMsg();
	}
d727 9
a735 11
	else if ( strcmp( argv[i], "-ld") == 0)
	{
	    if(++i < argc)
	    {
	        limitDataSpace = atoi(argv[i]);
		if (limitDataSpace > 0)
		    limitDataSpace *= 1024;
	    }
	    else
		UseMsg();
	}
d738 6
a743 7
	else if ( strcmp( argv[i], "-lf") == 0)
	{
	    if(++i < argc)
	        limitNoFile = atoi(argv[i]);
	    else
		UseMsg();
	}
d746 9
a754 11
	else if ( strcmp( argv[i], "-ls") == 0)
	{
	    if(++i < argc)
	    {
	        limitStackSpace = atoi(argv[i]);
		if (limitStackSpace > 0)
		    limitStackSpace *= 1024;
	    }
	    else
		UseMsg();
	}
d756 1
a756 2
	else if ( strcmp ( argv[i], "-nolock") == 0)
	{
d758 40
a797 43
	  if (getuid() != 0)
	    ErrorF("Warning: the -nolock option can only be used by root\n");
	  else
#endif
	    nolock = TRUE;
	}
	else if ( strcmp( argv[i], "-nolisten") == 0)
	{
            if(++i < argc) {
		if (_XSERVTransNoListen(argv[i])) 
		    FatalError ("Failed to disable listen for %s transport",
				argv[i]);
	   } else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-noreset") == 0)
	{
	    dispatchExceptionAtReset = 0;
	}
	else if ( strcmp( argv[i], "-reset") == 0)
	{
	    dispatchExceptionAtReset = DE_RESET;
	}
	else if ( strcmp( argv[i], "-p") == 0)
	{
	    if(++i < argc)
	        defaultScreenSaverInterval = ((CARD32)atoi(argv[i])) *
					     MILLI_PER_MIN;
	    else
		UseMsg();
	}
	else if (strcmp(argv[i], "-pogo") == 0)
	{
	    dispatchException = DE_TERMINATE;
	}
	else if ( strcmp( argv[i], "-pn") == 0)
	    PartialNetwork = TRUE;
	else if ( strcmp( argv[i], "-nopn") == 0)
	    PartialNetwork = FALSE;
	else if ( strcmp( argv[i], "r") == 0)
	    defaultKeyboardControl.autoRepeat = TRUE;
	else if ( strcmp( argv[i], "-r") == 0)
	    defaultKeyboardControl.autoRepeat = FALSE;
d799 2
a800 2
	else if ( strcmp( argv[i], "-retro") == 0)
	    party_like_its_1989 = TRUE;
d802 2
a803 2
	else if ( strcmp( argv[i], "-retard") == 0)
	    party_like_its_1989 = FALSE;
d805 38
a842 37
	else if ( strcmp( argv[i], "-s") == 0)
	{
	    if(++i < argc)
	        defaultScreenSaverTime = ((CARD32)atoi(argv[i])) *
					 MILLI_PER_MIN;
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-t") == 0)
	{
	    if(++i < argc)
	        defaultPointerControl.threshold = atoi(argv[i]);
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-terminate") == 0)
	{
	    dispatchExceptionAtReset = DE_TERMINATE;
	}
	else if ( strcmp( argv[i], "-to") == 0)
	{
	    if(++i < argc)
		TimeOutValue = ((CARD32)atoi(argv[i])) * MILLI_PER_SECOND;
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-tst") == 0)
	{
	    noTestExtensions = TRUE;
	}
	else if ( strcmp( argv[i], "v") == 0)
	    defaultScreenSaverBlanking = PreferBlanking;
	else if ( strcmp( argv[i], "-v") == 0)
	    defaultScreenSaverBlanking = DontPreferBlanking;
	else if ( strcmp( argv[i], "-wm") == 0)
	    defaultBackingStore = WhenMapped;
        else if ( strcmp( argv[i], "-wr") == 0)
d844 3
a846 3
        else if ( strcmp( argv[i], "-background") == 0) {
            if(++i < argc) {
                if (!strcmp ( argv[i], "none"))
d852 16
a867 18
        else if ( strcmp( argv[i], "-maxbigreqsize") == 0) {
             if(++i < argc) {
                 long reqSizeArg = atol(argv[i]);

                 /* Request size > 128MB does not make much sense... */
                 if( reqSizeArg > 0L && reqSizeArg < 128L ) {
                     maxBigRequestSize = (reqSizeArg * 1048576L) - 1L;
                 }
                 else
                 {
                     UseMsg();
                 }
             }
             else
             {
                 UseMsg();
             }
         }
d869 15
a883 17
	else if ( strcmp( argv[i], "+xinerama") == 0){
	    noPanoramiXExtension = FALSE;
	}
	else if ( strcmp( argv[i], "-xinerama") == 0){
	    noPanoramiXExtension = TRUE;
	}
	else if ( strcmp( argv[i], "-disablexineramaextension") == 0){
	    PanoramiXExtensionDisabledHack = TRUE;
	}
#endif
	else if ( strcmp( argv[i], "-I") == 0)
	{
	    /* ignore all remaining arguments */
	    break;
	}
	else if (strncmp (argv[i], "tty", 3) == 0)
	{
d885 1
a885 1
	}
d887 57
a943 71
	else if ((skip = XdmcpOptions(argc, argv, i)) != i)
	{
	    i = skip - 1;
	}
#endif
	else if ( strcmp( argv[i], "-dumbSched") == 0)
	{
	    SmartScheduleDisable = TRUE;
	}
	else if ( strcmp( argv[i], "-schedInterval") == 0)
	{
	    if (++i < argc)
	    {
		SmartScheduleInterval = atoi(argv[i]);
		SmartScheduleSlice = SmartScheduleInterval;
	    }
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-schedMax") == 0)
	{
	    if (++i < argc)
	    {
		SmartScheduleMaxSlice = atoi(argv[i]);
	    }
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-render" ) == 0)
	{
	    if (++i < argc)
	    {
		int policy = PictureParseCmapPolicy (argv[i]);

		if (policy != PictureCmapPolicyInvalid)
		    PictureCmapPolicy = policy;
		else
		    UseMsg ();
	    }
	    else
		UseMsg ();
	}
	else if ( strcmp( argv[i], "-sigstop") == 0)
	{
	    RunFromSigStopParent = TRUE;
	}
	else if ( strcmp( argv[i], "+extension") == 0)
	{
	    if (++i < argc)
	    {
		if (!EnableDisableExtension(argv[i], TRUE))
		    EnableDisableExtensionError(argv[i], TRUE);
	    }
	    else
		UseMsg();
	}
	else if ( strcmp( argv[i], "-extension") == 0)
	{
	    if (++i < argc)
	    {
		if (!EnableDisableExtension(argv[i], FALSE))
		    EnableDisableExtensionError(argv[i], FALSE);
	    }
	    else
		UseMsg();
	}
 	else
 	{
	    ErrorF("Unrecognized option: %s\n", argv[i]);
	    UseMsg();
	    FatalError("Unrecognized option: %s\n", argv[i]);
d958 4
a961 4
    if (p == NULL)
    {
	char hname[1024], *hnameptr;
	unsigned int len;
d963 1
a963 1
	struct addrinfo hints, *ai = NULL;
d965 2
a966 1
	struct hostent *host;
d968 1
a968 1
	_Xgethostbynameparams hparams;
d972 1
a972 1
	gethostname(hname, 1024);
d974 8
a981 7
	memset(&hints, 0, sizeof(hints));
	hints.ai_flags = AI_CANONNAME;
	if (getaddrinfo(hname, NULL, &hints, &ai) == 0) {
	    hnameptr = ai->ai_canonname;
	} else {
	    hnameptr = hname;
	}
d983 5
a987 5
	host = _XGethostbyname(hname, hparams);
	if (host == NULL)
	    hnameptr = hname;
	else
	    hnameptr = host->h_name;
d990 2
a991 2
	len = strlen(hnameptr) + 1;
	result = malloc(len + sizeof(AUTHORIZATION_NAME) + 4);
d993 1
a993 1
	p = result;
d999 4
a1002 4
	memmove(p, AUTHORIZATION_NAME, sizeof(AUTHORIZATION_NAME));
	p += sizeof(AUTHORIZATION_NAME);
	memmove(p, hnameptr, len);
	p += len;
d1004 3
a1006 3
	if (ai) {
	    freeaddrinfo(ai);
	}
d1012 1
a1012 1
#else /* TCPCONN */
d1014 1
a1014 1
#endif /* TCPCONN */
d1027 3
a1029 3
    if ((long)amount <= 0)
	ErrorF("Warning: Xalloc: "
	       "requesting unpleasantly large amount of memory: %lu bytes.\n",
d1039 1
d1055 1
d1071 3
a1073 3
    if ((long)amount <= 0)
	ErrorF("Warning: Xrealloc: "
	       "requesting unpleasantly large amount of memory: %lu bytes.\n",
d1083 1
d1085 1
a1085 1
	FatalError("XNFrealloc: Out of memory");
a1094 1

d1099 1
a1099 1
	return NULL;
d1109 1
a1109 1
	return NULL;
d1113 1
a1113 1
	FatalError("XNFstrdup: Out of memory");
d1118 1
a1118 1
SmartScheduleStopTimer (void)
d1120 2
a1121 2
    struct itimerval	timer;
    
d1123 1
a1123 1
	return;
d1128 1
a1128 1
    (void) setitimer (ITIMER_REAL, &timer, 0);
d1132 1
a1132 1
SmartScheduleStartTimer (void)
d1134 2
a1135 2
    struct itimerval	timer;
    
d1137 1
a1137 1
	return;
d1142 1
a1142 1
    setitimer (ITIMER_REAL, &timer, 0);
d1146 1
a1146 1
SmartScheduleTimer (int sig)
d1152 1
a1152 1
SmartScheduleInit (void)
d1154 1
a1154 1
    struct sigaction	act;
d1157 1
a1157 1
	return;
d1163 5
a1167 6
    sigemptyset (&act.sa_mask);
    sigaddset (&act.sa_mask, SIGALRM);
    if (sigaction (SIGALRM, &act, 0) < 0)
    {
	perror ("sigaction for smart scheduler");
	SmartScheduleDisable = TRUE;
d1172 2
a1173 2
static sigset_t	PreviousSignalMask;
static int	BlockedSignalCount;
d1177 1
a1177 1
OsBlockSignals (void)
d1180 6
a1185 7
    if (BlockedSignalCount++ == 0)
    {
	sigset_t    set;
	
	sigemptyset (&set);
	sigaddset (&set, SIGALRM);
	sigaddset (&set, SIGVTALRM);
d1187 1
a1187 1
	sigaddset (&set, SIGWINCH);
d1190 1
a1190 1
	sigaddset (&set, SIGIO);
d1192 5
a1196 5
	sigaddset (&set, SIGTSTP);
	sigaddset (&set, SIGTTIN);
	sigaddset (&set, SIGTTOU);
	sigaddset (&set, SIGCHLD);
	sigprocmask (SIG_BLOCK, &set, &PreviousSignalMask);
d1202 1
a1202 1
OsReleaseSignals (void)
d1205 2
a1206 3
    if (--BlockedSignalCount == 0)
    {
	sigprocmask (SIG_SETMASK, &PreviousSignalMask, 0);
d1217 1
a1217 1
OsAbort (void)
d1237 1
a1237 1
System(char *command)
d1240 1
a1240 1
    void (*csig)(int);
d1244 1
a1244 1
	return 1;
d1248 2
a1249 2
      perror("signal");
      return -1;
d1254 14
a1267 14
    case -1:	/* error */
	p = -1;
    case 0:	/* child */
	if (setgid(getgid()) == -1)
	    _exit(127);
	if (setuid(getuid()) == -1)
	    _exit(127);
	execl("/bin/sh", "sh", "-c", command, (char *)NULL);
	_exit(127);
    default:	/* parent */
	do {
	    p = waitpid(pid, &status, 0);
	} while (p == -1 && errno == EINTR);
	
d1271 2
a1272 2
      perror("signal");
      return -1;
d1284 1
a1284 1
OsSigHandlerPtr old_alarm = NULL; /* XXX horrible awful hack */
d1287 1
a1287 1
Popen(char *command, char *type)
d1294 1
a1294 1
	return NULL;
d1297 1
a1297 1
	return NULL;
d1300 1
a1300 1
	return NULL;
d1303 2
a1304 2
	free(cur);
	return NULL;
d1310 5
a1314 5
      close(pdes[0]);
      close(pdes[1]);
      free(cur);
      perror("signal");
      return NULL;
d1318 30
a1347 29
    case -1: 	/* error */
	close(pdes[0]);
	close(pdes[1]);
	free(cur);
	if (OsSignal(SIGALRM, old_alarm) == SIG_ERR)
	  perror("signal");
	return NULL;
    case 0:	/* child */
	if (setgid(getgid()) == -1)
	    _exit(127);
	if (setuid(getuid()) == -1)
	    _exit(127);
	if (*type == 'r') {
	    if (pdes[1] != 1) {
		/* stdout */
		dup2(pdes[1], 1);
		close(pdes[1]);
	    }
	    close(pdes[0]);
	} else {
	    if (pdes[0] != 0) {
		/* stdin */
		dup2(pdes[0], 0);
		close(pdes[0]);
	    }
	    close(pdes[1]);
	}
	execl("/bin/sh", "sh", "-c", command, (char *)NULL);
	_exit(127);
d1351 2
a1352 2
    OsBlockSignals ();
    
d1355 6
a1360 5
	iop = fdopen(pdes[0], type);
	close(pdes[1]);
    } else {
	iop = fdopen(pdes[1], type);
	close(pdes[0]);
d1375 1
a1375 1
Fopen(char *file, char *type)
d1378 1
d1384 1
a1384 1
	return NULL;
d1387 1
a1387 1
	return NULL;
d1390 1
a1390 1
	return NULL;
d1393 2
a1394 2
	free(cur);
	return NULL;
d1398 28
a1425 27
    case -1: 	/* error */
	close(pdes[0]);
	close(pdes[1]);
	free(cur);
	return NULL;
    case 0:	/* child */
	if (setgid(getgid()) == -1)
	    _exit(127);
	if (setuid(getuid()) == -1)
	    _exit(127);
	if (*type == 'r') {
	    if (pdes[1] != 1) {
		/* stdout */
		dup2(pdes[1], 1);
		close(pdes[1]);
	    }
	    close(pdes[0]);
	} else {
	    if (pdes[0] != 0) {
		/* stdin */
		dup2(pdes[0], 0);
		close(pdes[0]);
	    }
	    close(pdes[1]);
	}
	execl("/bin/cat", "cat", file, (char *)NULL);
	_exit(127);
d1429 2
a1430 2
    OsBlockSignals ();
    
d1433 6
a1438 5
	iop = fdopen(pdes[0], type);
	close(pdes[1]);
    } else {
	iop = fdopen(pdes[1], type);
	close(pdes[0]);
d1454 1
a1454 1
    
d1456 1
a1456 1
	    return NULL;
d1461 2
a1462 2
	    fclose(iop);
	    return NULL;
d1465 1
a1465 1
#endif /* HAS_SAVED_IDS_AND_SETEUID */
d1479 2
a1480 2
	if (cur->fp == iop)
	    break;
d1482 1
a1482 1
	return -1;
d1485 1
a1485 1
	pid = waitpid(cur->pid, &pstat, 0);
d1489 1
a1489 1
	pidlist = cur->next;
d1491 1
a1491 1
	last->next = cur->next;
d1495 2
a1496 2
    OsReleaseSignals ();
    
d1498 2
a1499 2
      perror("signal");
      return -1;
d1515 1
a1515 2
#endif /* !WIN32 */

a1543 1

d1563 1
a1563 1
#define MAX_ENV_PATH_LENGTH     2048	/* Limit for *PATH and TERMCAP */
d1601 27
a1627 28
	/* Check each argv[] */
	for (i = 1; i < argc; i++) {
	    if (strcmp(argv[i], "-fp") == 0)
	    {
		i++; /* continue with next argument. skip the length check */
		if (i >= argc)
		    break;
	    } else
	    {
		if (strlen(argv[i]) > MAX_ARG_LENGTH) {
		    bad = ArgTooLong;
		    break;
		}
	    }
	    a = argv[i];
	    while (*a) {
		if (checkPrintable(*a) == 0) {
		    bad = UnprintableArg;
		    break;
		}
		a++;
	    }
	    if (bad)
		break;
	}
	if (!bad) {
	    /* Check each envp[] */
	    for (i = 0; envp[i]; i++) {
d1629 1
a1629 1
		/* Check for bad environment variables and values */
d1631 7
a1637 7
		while (envp[i] && (strncmp(envp[i], "LD", 2) == 0)) {
		    for (j = i; envp[j]; j++) {
			envp[j] = envp[j+1];
		    }
		}
#endif   
		if (envp[i] && (strlen(envp[i]) > MAX_ENV_LENGTH)) {
d1639 4
a1642 4
		    for (j = i; envp[j]; j++) {
			envp[j] = envp[j+1];
		    }
		    i--;
d1644 2
a1645 2
		    char *eq;
		    int len;
d1647 28
a1674 28
		    eq = strchr(envp[i], '=');
		    if (!eq)
			continue;
		    len = eq - envp[i];
		    e = malloc(len + 1);
		    if (!e) {
			bad = InternalError;
			break;
		    }
		    strncpy(e, envp[i], len);
		    e[len] = 0;
		    if (len >= 4 &&
			(strcmp(e + len - 4, "PATH") == 0 ||
			 strcmp(e, "TERMCAP") == 0)) {
			if (strlen(envp[i]) > MAX_ENV_PATH_LENGTH) {
			    bad = EnvTooLong;
			    break;
			} else {
			    free(e);
			}
		    } else {
			bad = EnvTooLong;
			break;
		    }
#endif
		}
	    }
	}
d1676 2
a1677 2
	if (!bad) {
	    struct stat buf;
d1679 5
a1683 5
	    if (fstat(fileno(stdout), &buf) == 0 && S_ISFIFO(buf.st_mode))
		bad = OutputIsPipe;
	    if (fstat(fileno(stderr), &buf) == 0 && S_ISFIFO(buf.st_mode))
		bad = OutputIsPipe;
	}
d1688 1
a1688 1
	return;
d1690 2
a1691 2
	ErrorF("Command line argument number %d is unsafe\n", i);
	break;
d1693 2
a1694 2
	ErrorF("Command line argument number %d is too long\n", i);
	break;
d1696 3
a1698 3
	ErrorF("Command line argument number %d contains unprintable"
		" characters\n", i);
	break;
d1700 2
a1701 2
	ErrorF("Environment variable `%s' is too long\n", e);
	break;
d1703 2
a1704 2
	ErrorF("Stdout and/or stderr is a pipe\n");
	break;
d1706 2
a1707 2
	ErrorF("Internal Error\n");
	break;
d1709 2
a1710 2
	ErrorF("Unknown error\n");
	break;
d1725 1
a1725 1
#endif /* USE_PAM */
d1732 2
a1733 2
	misc_conv,
	NULL
d1741 22
a1762 22
	pw = getpwuid(getuid());
	if (pw == NULL)
	    FatalError("getpwuid() failed for uid %d\n", getuid());

	retval = pam_start("xserver", pw->pw_name, &conv, &pamh);
	if (retval != PAM_SUCCESS)
	    FatalError("pam_start() failed.\n"
			"\tMissing or mangled PAM config file or module?\n");

	retval = pam_authenticate(pamh, 0);
	if (retval != PAM_SUCCESS) {
	    pam_end(pamh, retval);
	    FatalError("PAM authentication failed, cannot start X server.\n"
			"\tPerhaps you do not have console ownership?\n");
	}

	retval = pam_acct_mgmt(pamh, 0);
	if (retval != PAM_SUCCESS) {
	    pam_end(pamh, retval);
	    FatalError("PAM authentication failed, cannot start X server.\n"
			"\tPerhaps you do not have console ownership?\n");
	}
d1764 2
a1765 2
	/* this is not a session, so do not do session management */
	pam_end(pamh, PAM_SUCCESS);
d1774 1
a1774 1
char**
d1802 1
a1802 1
error:
@


1.13
log
@Fix CVE-2011-4028: File disclosure vulnerability.
use O_NOFOLLOW to open the existing lock file, so symbolic links
aren't followed, thus avoid revealing if it point to an existing file.

Note that xserver on OpenBSD isn't affected by CVE-2011-4029.
@
text
@a233 11
#ifndef PATH_MAX
#include <sys/param.h>
#ifndef PATH_MAX
#ifdef MAXPATHLEN
#define PATH_MAX MAXPATHLEN
#else
#define PATH_MAX 1024
#endif
#endif
#endif

a303 1
#ifndef USE_CHMOD
a304 3
#else
  (void) chmod(tmp, 0444);
#endif
a515 4
#ifndef NOLOGOHACK
    ErrorF("-logo                  enable logo in screen saver\n");
    ErrorF("nologo                 disable logo in screen saver\n");
#endif
d518 1
d548 1
a775 10
#ifndef NOLOGOHACK
	else if ( strcmp( argv[i], "-logo") == 0)
	{
	    logoScreenSaver = 1;
	}
	else if ( strcmp( argv[i], "nologo") == 0)
	{
	    logoScreenSaver = 0;
	}
#endif
d858 8
d947 4
a1144 10

#ifdef SIGVTALRM
#define SMART_SCHEDULE_POSSIBLE
#endif

#ifdef SMART_SCHEDULE_POSSIBLE
#define SMART_SCHEDULE_SIGNAL		SIGALRM
#define SMART_SCHEDULE_TIMER		ITIMER_REAL
#endif

a1147 1
#ifdef SMART_SCHEDULE_POSSIBLE
a1156 1
#endif
a1161 1
#ifdef SMART_SCHEDULE_POSSIBLE
a1170 1
#endif
a1172 1
#ifdef SMART_SCHEDULE_POSSIBLE
a1177 1
#endif
d1179 1
a1179 1
Bool
a1181 1
#ifdef SMART_SCHEDULE_POSSIBLE
d1185 2
a1186 2
	return TRUE;
    
d1192 2
a1193 2
    sigaddset (&act.sa_mask, SMART_SCHEDULE_SIGNAL);
    if (sigaction (SMART_SCHEDULE_SIGNAL, &act, 0) < 0)
d1196 1
a1196 1
	return FALSE;
a1197 4
    return TRUE;
#else
    return FALSE;
#endif
a1213 1
#ifdef SIGALRM
a1214 2
#endif
#ifdef SIGVTALRM
a1215 1
#endif
a1221 1
#ifdef SIGTSTP
a1222 2
#endif
#ifdef SIGTTIN
a1223 2
#endif
#ifdef SIGTTOU
a1224 2
#endif
#ifdef SIGCHLD
a1225 1
#endif
a1270 1
#ifdef SIGCHLD
a1271 1
#endif
a1276 1
#ifdef SIGCHLD
d1282 1
a1282 5
#endif

#ifdef DEBUG
    ErrorF("System: `%s'\n", command);
#endif
a1300 1
#ifdef SIGCHLD
a1304 1
#endif
d1341 3
d1397 1
a1397 3
#ifdef DEBUG
    ErrorF("Popen: `%s', fp = %p\n", command, iop);
#endif
d1472 1
a1472 3
#ifdef DEBUG
    ErrorF("Fopen(%s), fp = %p\n", file, iop);
#endif
d1501 1
a1501 4
#ifdef DEBUG
    ErrorF("Pclose: fp = %p\n", iop);
#endif

@


1.12
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d340 1
a340 1
      lfd = open(LockFile, O_RDONLY);
@


1.11
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d448 15
a462 1
    if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0)
@


1.10
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a122 1
#ifdef RENDER
a123 1
#endif
a148 3
#ifdef MULTIBUFFER
Bool noMultibufferExtension = FALSE;
#endif
a151 1
#ifdef RENDER
a152 1
#endif
a207 2
static char *dev_tty_from_init = NULL;	/* since we need to parse it anyway */

a528 1
#ifdef RENDER
a529 1
#endif
d571 6
a576 6
    if ( d == (char *)0 ) return( 0 );  /*  null  */
    if ( *d == '\0' ) return( 0 );  /*  empty  */
    if ( *d == '-' ) return( 0 );  /*  could be confused for an option  */
    if ( *d == '.' ) return( 0 );  /*  must not equal "." or ".."  */
    if ( strchr(d, '/') != (char *)0 ) return( 0 );  /*  very important!!!  */
    return( 1 );
d907 1
a907 2
	    /* just in case any body is interested */
	    dev_tty_from_init = argv[i];
a937 1
#ifdef RENDER
a951 1
#endif
d1006 1
a1006 1
	bzero(&hints, sizeof(hints));
d1022 1
a1022 1
	result = xalloc(len + sizeof(AUTHORIZATION_NAME) + 4);
d1051 11
a1061 1
    void *ptr;
d1063 1
a1063 7
    if ((long)amount <= 0) {
	return NULL;
    }
    /* aligned extra on long word boundary */
    amount = (amount + (sizeof(long) - 1)) & ~(sizeof(long) - 1);
    ptr = malloc(amount);
    return ptr;
a1065 5
/*****************
 * XNFalloc 
 * "no failure" realloc
 *****************/

d1069 1
a1069 7
    void *ptr;

    if ((long)amount <= 0)
        return NULL;
    /* aligned extra on long word boundary */
    amount = (amount + (sizeof(long) - 1)) & ~(sizeof(long) - 1);
    ptr = malloc(amount);
a1074 4
/*****************
 * Xcalloc
 *****************/

d1078 1
a1078 6
    void *ret;

    ret = Xalloc (amount);
    if (ret)
	bzero (ret, (int) amount);
    return ret;
a1080 4
/*****************
 * XNFcalloc
 *****************/

d1084 3
a1086 7
    void *ret;

    ret = Xalloc (amount);
    if (ret)
	bzero (ret, (int) amount);
    else if ((long)amount > 0)
        FatalError("Out of memory");
a1089 4
/*****************
 * Xrealloc
 *****************/

d1091 1
a1091 1
Xrealloc(pointer ptr, unsigned long amount)
d1093 7
d1101 3
a1103 10
    {
	if (ptr && !amount)
	    free(ptr);
	return NULL;
    }
    amount = (amount + (sizeof(long) - 1)) & ~(sizeof(long) - 1);
    if (ptr)
        ptr = realloc(ptr, amount);
    else
	ptr = malloc(amount);
d1105 1
a1105 1
    return ptr;
a1106 5
                    
/*****************
 * XNFrealloc 
 * "no failure" realloc
 *****************/
d1109 1
a1109 1
XNFrealloc(pointer ptr, unsigned long amount)
d1111 4
a1114 6
    if ((ptr = Xrealloc(ptr, amount)) == NULL)
    {
	if ((long)amount > 0)
            FatalError( "Out of memory" );
    }
    return ptr;
a1116 5
/*****************
 *  Xfree
 *    calls free 
 *****************/    

d1118 1
a1118 1
Xfree(pointer ptr)
d1120 1
a1120 2
    if (ptr)
	free(ptr); 
a1126 3
    char *sd;
    size_t len;

d1129 1
a1129 6
    
    len = strlen(s) + 1;
    sd = (char *)Xalloc(len);
    if (sd != NULL)
	strlcpy(sd, s, len);
    return sd;
a1131 1

d1135 1
a1135 2
    char *sd;
    size_t len;
d1139 5
a1143 5
    
    len = strlen(s) + 1;
    sd = (char *)XNFalloc(len);
    strlcpy(sd, s, len);
    return sd;
d1205 1
a1205 1
    bzero ((char *) &act, sizeof(struct sigaction));
d1311 1
a1311 1
	return(1);
d1373 1
a1373 1
    if ((cur = xalloc(sizeof(struct pid))) == NULL)
d1377 1
a1377 1
	xfree(cur);
d1392 1
a1392 1
	xfree(cur);
d1459 1
a1459 1
    if ((cur = xalloc(sizeof(struct pid))) == NULL)
d1463 1
a1463 1
	xfree(cur);
d1471 1
a1471 1
	xfree(cur);
d1565 1
a1565 1
    xfree(cur);
a1884 50

#ifdef __SCO__
#include <fcntl.h>

static void
lockit (int fd, short what)
{
  struct flock lck;

  lck.l_whence = 0;
  lck.l_start = 0;
  lck.l_len = 1;
  lck.l_type = what;

  (void)fcntl (fd, F_SETLKW, &lck);
}

/* SCO OpenServer 5 lacks pread/pwrite. Emulate them. */
ssize_t
pread (int fd, void *buf, size_t nbytes, off_t offset)
{
  off_t saved;
  ssize_t ret;

  lockit (fd, F_RDLCK);
  saved = lseek (fd, 0, SEEK_CUR);
  lseek (fd, offset, SEEK_SET);
  ret = read (fd, buf, nbytes);
  lseek (fd, saved, SEEK_SET);
  lockit (fd, F_UNLCK);

  return ret;
}

ssize_t
pwrite (int fd, const void *buf, size_t nbytes, off_t offset)
{
  off_t saved;
  ssize_t ret;

  lockit (fd, F_WRLCK);
  saved = lseek (fd, 0, SEEK_CUR);
  lseek (fd, offset, SEEK_SET);
  ret = write (fd, buf, nbytes);
  lseek (fd, saved, SEEK_SET);
  lockit (fd, F_UNLCK);

  return ret;
}
#endif /* __SCO__ */
@


1.9
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d59 5
d121 1
a121 3
#ifdef XKB
#include <xkbsrv.h>
#endif
d127 1
a127 1
_X_EXPORT Bool noTestExtensions;
d129 1
a129 1
_X_EXPORT Bool noCompositeExtension = FALSE;
d133 1
a133 1
_X_EXPORT Bool noDamageExtension = FALSE;
d136 1
a136 1
_X_EXPORT Bool noDbeExtension = FALSE;
d139 1
a139 1
_X_EXPORT Bool noDPMSExtension = FALSE;
d142 2
a143 2
_X_EXPORT Bool noGlxExtension = FALSE;
_X_EXPORT Bool noGlxVisualInit = FALSE;
d146 1
a146 1
_X_EXPORT Bool noScreenSaverExtension = FALSE;
d149 1
a149 1
_X_EXPORT Bool noMITShmExtension = FALSE;
d152 1
a152 1
_X_EXPORT Bool noMultibufferExtension = FALSE;
d155 1
a155 1
_X_EXPORT Bool noRRExtension = FALSE;
d158 1
a158 1
_X_EXPORT Bool noRenderExtension = FALSE;
d161 1
a161 1
_X_EXPORT Bool noSecurityExtension = FALSE;
d164 1
a164 1
_X_EXPORT Bool noResExtension = FALSE;
d167 1
a167 1
_X_EXPORT Bool noXFree86BigfontExtension = FALSE;
d170 1
a170 1
_X_EXPORT Bool noXFree86DGAExtension = FALSE;
d173 1
a173 1
_X_EXPORT Bool noXFree86DRIExtension = FALSE;
d176 1
a176 1
_X_EXPORT Bool noXFree86VidModeExtension = FALSE;
d179 1
a179 1
_X_EXPORT Bool noXFixesExtension = FALSE;
a180 1
/* |noXkbExtension| is defined in xc/programs/Xserver/xkb/xkbInit.c */
d183 1
a183 1
_X_EXPORT Bool noPanoramiXExtension = TRUE;
d186 2
a187 2
_X_EXPORT Bool noSELinuxExtension = FALSE;
_X_EXPORT int selinuxEnforcingState = SELINUX_MODE_DEFAULT;
d190 1
a190 1
_X_EXPORT Bool noXvExtension = FALSE;
d193 1
a193 1
_X_EXPORT Bool noDRI2Extension = FALSE;
d196 1
a196 1
_X_EXPORT Bool noGEExtension = FALSE;
d218 1
a218 3
OsSignal(sig, handler)
    int sig;
    OsSigHandlerPtr handler;
d421 1
a421 2
/*ARGSUSED*/
SIGVAL
d433 1
a433 2
/*ARGSUSED*/
_X_EXPORT SIGVAL
d443 2
a444 2
#if defined WIN32 && defined __MINGW32__
_X_EXPORT CARD32
d450 1
a450 1
_X_EXPORT CARD32
d466 1
a466 1
_X_EXPORT void
d493 1
a493 1
    ErrorF("-a #                   mouse acceleration (pixels)\n");
d503 1
a506 1
    ErrorF("dpms                   enables VESA DPMS monitor control\n");
a524 1
#ifdef SERVER_LOCK
a525 1
#endif
d547 1
a547 1
    ErrorF("-t #                   mouse threshold (pixels)\n");
a555 1
    ErrorF("-x string              loads named extension at init time \n");
a567 1
#ifdef XKB
a568 1
#endif
d684 5
a688 1
	else if ( strcmp( argv[i], "-dpi") == 0)
d697 1
a697 1
	    DPMSEnabledSwitch = TRUE;
a740 1
#ifdef XKB
a745 1
#endif
a780 1
#ifdef SERVER_LOCK
a789 1
#endif
a910 8
	else if ( strcmp( argv[i], "-x") == 0)
	{
	    if(++i >= argc)
		UseMsg();
	    /* For U**x, which doesn't support dynamic loading, there's nothing
	     * to do when we see a -x.  Either the extension is linked in or
	     * it isn't */
	}
d1062 1
a1062 3
#ifndef INTERNAL_MALLOC

_X_EXPORT void * 
d1081 1
a1081 1
_X_EXPORT void *
d1100 1
a1100 1
_X_EXPORT void *
d1115 1
a1115 1
_X_EXPORT void *
d1132 1
a1132 1
_X_EXPORT void *
d1155 1
a1155 1
_X_EXPORT void *
d1171 1
a1171 1
_X_EXPORT void
a1176 1
#endif /* !INTERNAL_MALLOC */
d1196 1
a1196 1
_X_EXPORT char *
d1341 14
d1438 1
a1438 1
    if ((cur = (struct pid *)xalloc(sizeof(struct pid))) == NULL)
d1524 1
a1524 1
    if ((cur = (struct pid *)xalloc(sizeof(struct pid))) == NULL)
d1643 1
a1643 1
int 
d1909 40
@


1.8
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d86 1
a86 1
#if defined(X_NOT_POSIX) || defined(_POSIX_SOURCE)
d97 1
a97 1
#if !defined(SYSV) && !defined(WIN32) && !defined(Lynx) && !defined(QNX4)
a103 5
#if defined(DGUX)
#include <sys/resource.h>
#include <netdb.h>
#endif

a113 1
#ifdef SMART_SCHEDULE
a114 1
#endif
a123 4
#ifdef XPRINT
#include "DiPrint.h"
#endif

a124 3
#ifdef BIGREQS
_X_EXPORT Bool noBigReqExtension = FALSE;
#endif
a137 6
#ifdef EVI
_X_EXPORT Bool noEVIExtension = FALSE;
#endif
#ifdef FONTCACHE
_X_EXPORT Bool noFontCacheExtension = FALSE;
#endif
a147 3
#ifdef MITMISC
_X_EXPORT Bool noMITMiscExtension = FALSE;
#endif
a156 3
#ifdef SHAPE
_X_EXPORT Bool noShapeExtension = FALSE;
#endif
a159 6
#ifdef XSYNC
_X_EXPORT Bool noSyncExtension = FALSE;
#endif
#ifdef TOGCUP
_X_EXPORT Bool noXcupExtension = FALSE;
#endif
a162 11
#ifdef XAPPGROUP
_X_EXPORT Bool noXagExtension = FALSE;
#endif
#ifdef XCMISC
_X_EXPORT Bool noXCMiscExtension = FALSE;
#endif
#ifdef XEVIE
/* Xevie is disabled by default for now until the
 * interface is stable */
_X_EXPORT Bool noXevieExtension = TRUE;
#endif
a171 3
#ifdef XF86MISC
_X_EXPORT Bool noXFree86MiscExtension = FALSE;
#endif
a182 6
#ifdef XINPUT
_X_EXPORT Bool noXInputExtension = FALSE;
#endif
#ifdef XIDLE
_X_EXPORT Bool noXIdleExtension = FALSE;
#endif
d184 1
a184 1
_X_EXPORT Bool noSELinuxExtension = TRUE;
d194 2
a208 7
_X_EXPORT Bool Must_have_memory = FALSE;

#ifdef AIXV3
int SyncOn  = 0;
extern int SelectWaitTime;
#endif

a212 6
#ifdef MEMBUG
#define MEM_FAIL_SCALE 100000
long Memory_fail = 0;
#include <stdlib.h>  /* for random() */
#endif

a219 3
#ifdef X_NOT_POSIX
    return signal(sig, handler);
#else
a229 1
#endif
d231 1
a231 2
	
#ifdef SERVER_LOCK
a242 5
#if defined(DGUX)
#include <limits.h>
#include <sys/param.h>
#endif

a243 1
#ifndef Lynx
a244 3
#else
#include <param.h>
#endif
a417 1
#endif /* SERVER_LOCK */
a428 7
#ifdef GPROF
    chdir ("/tmp");
    exit (0);
#endif
#if defined(SYSV) && defined(X_NOT_POSIX)
    OsSignal (SIGHUP, AutoResetServer);
#endif
a441 4
#if defined(SYSV) && defined(X_NOT_POSIX)
    if (sig)
	OsSignal(sig, SIG_IGN);
#endif
a493 1
#if !defined(AIXrt) && !defined(AIX386)
a496 3
#ifdef MEMBUG
    ErrorF("-alloc int             chance alloc should fail\n");
#endif
a504 3
#ifdef COMMANDLINE_CHALLENGED_OPERATING_SYSTEMS
    ErrorF("-config file           read options from file\n");
#endif
d545 5
a550 4
#ifdef XPRINT
    PrinterUseMsg();
#endif
    ErrorF("-su                    disable any save under support\n");
a565 1
#ifdef SMART_SCHEDULE
a567 1
#endif
a572 1
#endif /* !AIXrt && ! AIX386 */
a597 11
 * This function is responsible for doing initalisation of any global
 * variables at an very early point of server startup (even before
 * |ProcessCommandLine()|. 
 */
void InitGlobals(void)
{
    ddxInitGlobals();
}


/*
a643 9
#ifdef MEMBUG
	else if ( strcmp( argv[i], "-alloc") == 0)
	{
	    if(++i < argc)
	        Memory_fail = atoi(argv[i]);
	    else
		UseMsg();
	}
#endif
d658 1
a658 2
	else if ( strcmp( argv[i], "-br") == 0)
	    blackRoot = TRUE;
d844 7
a858 2
	else if ( strcmp( argv[i], "-su") == 0)
	    disableSaveUnders = TRUE;
a941 20
#ifdef XPRINT
	else if ((skip = PrinterOptions(argc, argv, i)) != i)
	{
	    i = skip - 1;
	}
#endif
#ifdef AIXV3
        else if ( strcmp( argv[i], "-timeout") == 0)
        {
            if(++i < argc)
                SelectWaitTime = atoi(argv[i]);
            else
                UseMsg();
        }
        else if ( strcmp( argv[i], "-sync") == 0)
        {
            SyncOn++;
        }
#endif
#ifdef SMART_SCHEDULE
a964 1
#endif
a1009 112
#ifdef COMMANDLINE_CHALLENGED_OPERATING_SYSTEMS
static void
InsertFileIntoCommandLine(
    int *resargc, char ***resargv, 
    int prefix_argc, char **prefix_argv,
    char *filename, 
    int suffix_argc, char **suffix_argv)
{
    struct stat     st;
    FILE           *f;
    char           *p;
    char           *q;
    int             insert_argc;
    char           *buf;
    int             len;
    int             i;

    f = fopen(filename, "r");
    if (!f)
	FatalError("Can't open option file %s\n", filename);

    fstat(fileno(f), &st);

    buf = (char *) xalloc((unsigned) st.st_size + 1);
    if (!buf)
	FatalError("Out of Memory\n");

    len = fread(buf, 1, (unsigned) st.st_size, f);

    fclose(f);

    if (len < 0)
	FatalError("Error reading option file %s\n", filename);

    buf[len] = '\0';

    p = buf;
    q = buf;
    insert_argc = 0;

    while (*p)
    {
	while (isspace(*p))
	    p++;
	if (!*p)
	    break;
	if (*p == '#')
	{
	    while (*p && *p != '\n')
		p++;
	} else
	{
	    while (*p && !isspace(*p))
		*q++ = *p++;
	    /* Since p and q might still be pointing at the same place, we	 */
	    /* need to step p over the whitespace now before we add the null.	 */
	    if (*p)
		p++;
	    *q++ = '\0';
	    insert_argc++;
	}
    }

    buf = (char *) xrealloc(buf, q - buf);
    if (!buf)
	FatalError("Out of memory reallocing option buf\n");

    *resargc = prefix_argc + insert_argc + suffix_argc;
    *resargv = (char **) xalloc((*resargc + 1) * sizeof(char *));
    if (!*resargv)
	FatalError("Out of Memory\n");

    memcpy(*resargv, prefix_argv, prefix_argc * sizeof(char *));

    p = buf;
    for (i = 0; i < insert_argc; i++)
    {
	(*resargv)[prefix_argc + i] = p;
	p += strlen(p) + 1;
    }

    memcpy(*resargv + prefix_argc + insert_argc,
	   suffix_argv, suffix_argc * sizeof(char *));

    (*resargv)[*resargc] = NULL;
} /* end InsertFileIntoCommandLine */


void
ExpandCommandLine(int *pargc, char ***pargv)
{
    int i;

#if !defined(WIN32) && !defined(__CYGWIN__)
    if (getuid() != geteuid())
	return;
#endif

    for (i = 1; i < *pargc; i++)
    {
	if ( (0 == strcmp((*pargv)[i], "-config")) && (i < (*pargc - 1)) )
	{
	    InsertFileIntoCommandLine(pargc, pargv,
					  i, *pargv,
					  (*pargv)[i+1], /* filename */
					  *pargc - i - 2, *pargv + i + 2);
	    i--;
	}
    }
} /* end ExpandCommandLine */
#endif

a1076 12
/* XALLOC -- X's internal memory allocator.  Why does it return unsigned
 * long * instead of the more common char *?  Well, if you read K&R you'll
 * see they say that alloc must return a pointer "suitable for conversion"
 * to whatever type you really want.  In a full-blown generic allocator
 * there's no way to solve the alignment problems without potentially
 * wasting lots of space.  But we have a more limited problem. We know
 * we're only ever returning pointers to structures which will have to
 * be long word aligned.  So we are making a stronger guarantee.  It might
 * have made sense to make Xalloc return char * to conform with people's
 * expectations of malloc, but this makes lint happier.
 */

d1082 2
a1083 2
    register pointer  ptr;
	
d1085 1
a1085 1
	return (unsigned long *)NULL;
d1089 2
a1090 11
#ifdef MEMBUG
    if (!Must_have_memory && Memory_fail &&
	((random() % MEM_FAIL_SCALE) < Memory_fail))
	return (unsigned long *)NULL;
#endif
    if ((ptr = (pointer)malloc(amount))) {
	return (unsigned long *)ptr;
    }
    if (Must_have_memory)
	FatalError("Out of memory");
    return (unsigned long *)NULL;
d1095 1
a1095 1
 * "no failure" realloc, alternate interface to Xalloc w/o Must_have_memory
d1101 1
a1101 1
    register pointer ptr;
d1104 1
a1104 3
    {
        return (unsigned long *)NULL;
    }
d1107 1
a1107 1
    ptr = (pointer)malloc(amount);
a1108 1
    {
d1110 1
a1110 2
    }
    return ((unsigned long *)ptr);
d1120 1
a1120 1
    unsigned long   *ret;
d1124 1
a1124 1
	bzero ((char *) ret, (int) amount);
d1135 1
a1135 1
    unsigned long   *ret;
d1139 1
a1139 1
	bzero ((char *) ret, (int) amount);
a1151 5
#ifdef MEMBUG
    if (!Must_have_memory && Memory_fail &&
	((random() % MEM_FAIL_SCALE) < Memory_fail))
	return (unsigned long *)NULL;
#endif
d1156 1
a1156 1
	return (unsigned long *)NULL;
d1160 1
a1160 1
        ptr = (pointer)realloc((char *)ptr, amount);
d1162 3
a1164 6
	ptr = (pointer)malloc(amount);
    if (ptr)
        return (unsigned long *)ptr;
    if (Must_have_memory)
	FatalError("Out of memory");
    return (unsigned long *)NULL;
d1169 1
a1169 1
 * "no failure" realloc, alternate interface to Xrealloc w/o Must_have_memory
d1175 1
a1175 1
    if (( ptr = (pointer)Xrealloc( ptr, amount ) ) == NULL)
d1180 1
a1180 1
    return ((unsigned long *)ptr);
d1192 1
a1192 15
	free((char *)ptr); 
}

void
OsInitAllocator (void)
{
#ifdef MEMBUG
    static int	been_here;

    /* Check the memory system after each generation */
    if (been_here)
	CheckMemory ();
    else
	been_here = 1;
#endif
a1228 1
#ifdef SMART_SCHEDULE
a1303 1
#endif
a1739 3
#if defined(__QNX__) && !defined(__QNXNTO__)
    char cmd_name[64];
#endif
@


1.7
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d1723 1
a1723 1
void (*old_alarm)(int) = NULL; /* XXX horrible awful hack */
d1747 1
a1747 1
    old_alarm = signal(SIGALRM, SIG_IGN);
d1758 1
a1758 1
	if (signal(SIGALRM, old_alarm) == SIG_ERR)
d1935 1
a1935 1
    if (old_alarm && signal(SIGALRM, old_alarm) == SIG_ERR) {
@


1.6
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@a125 3
#ifdef XCSECURITY
#include "securitysrv.h"
#endif
d160 1
d235 4
d242 3
a597 1
    ErrorF("-co file               color database file\n");
a641 3
#ifdef XCSECURITY
    ErrorF("-sp file               security policy file\n");
#endif
a799 8
	else if ( strcmp( argv[i], "-co") == 0)
	{
	    if(++i < argc) {
		if (strlen(argv[i]) < MAXPATHLEN) 
		    rgbPath = argv[i];
	    } else
		UseMsg();
	}
d951 4
a1061 6
#ifdef XCSECURITY
	else if ((skip = XSecurityOptions(argc, argv, i)) != i)
	{
	    i = skip - 1;
	}
#endif
a1524 4
unsigned long	SmartScheduleIdleCount;
Bool		SmartScheduleIdle;
Bool		SmartScheduleTimerStopped;

d1534 1
a1534 1
static void
d1540 2
a1546 1
    SmartScheduleTimerStopped = TRUE;
d1550 1
a1550 1
Bool
d1556 2
a1557 1
    SmartScheduleTimerStopped = FALSE;
d1562 1
a1562 1
    return setitimer (ITIMER_REAL, &timer, 0) >= 0;
a1563 1
    return FALSE;
a1569 2
    int olderrno = errno;

a1570 5
    if (SmartScheduleIdle)
    {
	SmartScheduleStopTimer ();
    }
    errno = olderrno;
a1593 8
    /* Set up the virtual timer */
    if (!SmartScheduleStartTimer ())
    {
	perror ("scheduling timer");
	return FALSE;
    }
    /* stop the timer and wait for WaitForSomething to start it */
    SmartScheduleStopTimer ();
a2029 12
#define ARGMSG \
    "\nIf the arguments used are valid, and have been rejected incorrectly\n" \
      "please send details of the arguments and why they are valid to\n" \
      "%s.  In the meantime, you can start the Xserver as\n" \
      "the \"super user\" (root).\n"   

#define ENVMSG \
    "\nIf the environment is valid, and have been rejected incorrectly\n" \
      "please send details of the environment and why it is valid to\n" \
      "%s.  In the meantime, you can start the Xserver as\n" \
      "the \"super user\" (root).\n"

a2075 4
#ifdef ENVDEBUG
		    ErrorF("CheckUserParameters: removing %s from the "
			   "environment\n", strtok(envp[i], "="));
#endif
a2082 4
#ifdef ENVDEBUG
		    ErrorF("CheckUserParameters: removing %s from the "
			   "environment\n", strtok(envp[i], "="));
#endif
a2134 1
	ErrorF(ARGMSG, BUGADDRESS);
a2137 1
	ErrorF(ARGMSG, BUGADDRESS);
a2141 1
	ErrorF(ARGMSG, BUGADDRESS);
a2144 1
	ErrorF(ENVMSG, BUGADDRESS);
a2153 2
	ErrorF(ARGMSG, BUGADDRESS);
	ErrorF(ENVMSG, BUGADDRESS);
@


1.5
log
@Fix build with gcc 2.95. ok todd@@.
@
text
@d288 2
a289 1
    sigaction(sig, &act, &oact);
d1707 4
d1735 4
a1738 1
    signal(SIGCHLD, csig);
d1750 2
d1773 7
d1785 2
d1962 5
@


1.4
log
@merge xserver 1.4, 1st pass
@
text
@a807 1
	    CoreDump = TRUE;
d814 1
@


1.3
log
@merge xserver 1.2.0
@
text
@d67 4
d124 1
a124 1
#include <X11/extensions/XKBsrv.h>
d143 1
a143 4
 /* COMPOSITE is disabled by default for now until the
  * interface is stable */
 #define COMPOSITE_DEFAULT FALSE
_X_EXPORT Bool noCompositeExtension = !COMPOSITE_DEFAULT;
a248 4
Bool PanoramiXVisibilityNotifySent = FALSE;
Bool PanoramiXMapped = FALSE;
Bool PanoramiXWindowExposureSent = FALSE;
Bool PanoramiXOneExposeRequest = FALSE;
d271 1
a271 1
char *dev_tty_from_init = NULL;		/* since we need to parse it anyway */
a299 1
#ifndef __UNIXOS2__
a300 1
#endif
a309 4
#ifdef __UNIXOS2__
#define link rename
#endif

a347 1
#ifndef __UNIXOS2__
a348 6
#else
  /* OS/2 uses TMP directory, must also prepare for 8.3 names */
  tmppath = getenv("TMP");
  if (!tmppath)
    FatalError("No TMP dir found\n");
#endif
a394 1
#ifndef __UNIXOS2__
a399 1
#endif
a477 3
#ifdef __UNIXOS2__
  (void) chmod(LockFile,S_IREAD|S_IWRITE);
#endif /* __UNIXOS2__ */
d528 7
d549 1
d807 1
d809 7
d914 1
a914 1
#if !defined(WIN32) && !defined(__UNIXOS2__) && !defined(__CYGWIN__)
d1246 1
a1246 1
#if !defined(WIN32) && !defined(__UNIXOS2__) && !defined(__CYGWIN__)
d1681 1
a1681 1
#if !defined(WIN32) && !defined(__UNIXOS2__)
d1888 1
a1888 1
    ErrorF("Popen: `%s', fp = %p\n", command, iop);
d1956 1
a1956 1
#endif /* !WIN32 && !__UNIXOS2__ */
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@a55 17
/* The world's most shocking hack, to ensure we get clock_gettime() and
 * CLOCK_MONOTONIC. */
#ifdef sun              /* Needed to tell Solaris headers not to restrict to */
#define __EXTENSIONS__  /* only the functions defined in POSIX 199309.       */
#endif

#ifdef _POSIX_C_SOURCE
#define _SAVED_POSIX_C_SOURCE _POSIX_C_SOURCE
#undef _POSIX_C_SOURCE
#endif
#define _POSIX_C_SOURCE 199309L
#include <time.h>
#undef _POSIX_C_SOURCE
#ifdef _SAVED_POSIX_C_SOURCE
#define _POSIX_C_SOURCE _SAVED_POSIX_C_SOURCE
#endif

d66 1
@


1.1
log
@Initial revision
@
text
@d382 1
a382 1
  sprintf(port, "%d", atoi(display));
d388 4
a391 2
  (void)sprintf(tmp, "%s" LOCK_TMP_PREFIX "%s" LOCK_SUFFIX, tmppath, port);
  (void)sprintf(LockFile, "%s" LOCK_PREFIX "%s" LOCK_SUFFIX, tmppath, port);
d421 1
a421 1
  (void) sprintf(pid_str, "%10ld\n", (long)getpid());
d423 4
d518 8
d829 4
a832 3
	    if(++i < argc)
	        rgbPath = argv[i];
	    else
d1524 1
d1528 3
a1530 2

    sd = (char *)Xalloc(strlen(s) + 1);
d1532 1
a1532 1
	strcpy(sd, s);
d1541 1
d1545 4
a1548 3

    sd = (char *)XNFalloc(strlen(s) + 1);
    strcpy(sd, s);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@Import xserver version 1.2.0 (X.Org 7.2 final).
@
text
@d56 17
a82 1
#include <time.h>
@


1.1.1.3
log
@xserver 1.4
@
text
@a66 4
#if !defined(WIN32) || !defined(__MINGW32__)
#include <sys/time.h>
#include <sys/resource.h>
#endif
d120 1
a120 1
#include <xkbsrv.h>
d139 4
a142 1
_X_EXPORT Bool noCompositeExtension = FALSE;
d248 4
d274 1
a274 1
static char *dev_tty_from_init = NULL;	/* since we need to parse it anyway */
d303 1
d305 1
d315 4
d357 1
d359 6
d405 1
d411 1
d490 3
a534 7
#if defined WIN32 && defined __MINGW32__
_X_EXPORT CARD32
GetTimeInMillis (void)
{
  return GetTickCount ();
}
#else
a548 1
#endif
a804 1
	{
a805 7
#if !defined(WIN32) || !defined(__MINGW32__)
	    struct rlimit   core_limit;
	    getrlimit (RLIMIT_CORE, &core_limit);
	    core_limit.rlim_cur = core_limit.rlim_max;
	    setrlimit (RLIMIT_CORE, &core_limit);
#endif
	}
d904 1
a904 1
#if !defined(WIN32) && !defined(__CYGWIN__)
d1236 1
a1236 1
#if !defined(WIN32) && !defined(__CYGWIN__)
d1667 1
a1667 1
#if !defined(WIN32)
d1874 1
a1874 1
    ErrorF("Fopen(%s), fp = %p\n", file, iop);
d1942 1
a1942 1
#endif /* !WIN32 */
@


