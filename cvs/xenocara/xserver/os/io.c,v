head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.8
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.6
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.2
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	Te1daavkBLskZ8gc;

1.13
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.24.19.44.51;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.21.20.10.49;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.06;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.12;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/***********************************************************

Copyright 1987, 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
/*****************************************************************
 * i/o functions
 *
 *   WriteToClient, ReadRequestFromClient
 *   InsertFakeRequest, ResetCurrentRequest
 *
 *****************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#undef DEBUG_COMMUNICATION

#ifdef WIN32
#include <X11/Xwinsock.h>
#endif
#include <stdio.h>
#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#include <X11/Xmd.h>
#include <errno.h>
#if !defined(WIN32)
#include <sys/uio.h>
#endif
#include <X11/X.h>
#include <X11/Xproto.h>
#include "os.h"
#include "osdep.h"
#include <X11/Xpoll.h>
#include "opaque.h"
#include "dixstruct.h"
#include "misc.h"

CallbackListPtr ReplyCallback;
CallbackListPtr FlushCallback;

typedef struct _connectionInput {
    struct _connectionInput *next;
    char *buffer;               /* contains current client input */
    char *bufptr;               /* pointer to current start of data */
    int bufcnt;                 /* count of bytes in buffer */
    int lenLastReq;
    int size;
    unsigned int ignoreBytes;   /* bytes to ignore before the next request */
} ConnectionInput;

typedef struct _connectionOutput {
    struct _connectionOutput *next;
    unsigned char *buf;
    int size;
    int count;
} ConnectionOutput;

static ConnectionInputPtr AllocateInputBuffer(void);
static ConnectionOutputPtr AllocateOutputBuffer(void);

/* If EAGAIN and EWOULDBLOCK are distinct errno values, then we check errno
 * for both EAGAIN and EWOULDBLOCK, because some supposedly POSIX
 * systems are broken and return EWOULDBLOCK when they should return EAGAIN
 */
#ifndef WIN32
# if (EAGAIN != EWOULDBLOCK)
#  define ETEST(err) (err == EAGAIN || err == EWOULDBLOCK)
# else
#  define ETEST(err) (err == EAGAIN)
# endif
#else   /* WIN32 The socket errorcodes differ from the normal errors */
#define ETEST(err) (err == EAGAIN || err == WSAEWOULDBLOCK)
#endif

static Bool CriticalOutputPending;
static int timesThisConnection = 0;
static ConnectionInputPtr FreeInputs = (ConnectionInputPtr) NULL;
static ConnectionOutputPtr FreeOutputs = (ConnectionOutputPtr) NULL;
static OsCommPtr AvailableInput = (OsCommPtr) NULL;

#define get_req_len(req,cli) ((cli)->swapped ? \
			      lswaps((req)->length) : (req)->length)

#include <X11/extensions/bigreqsproto.h>

#define get_big_req_len(req,cli) ((cli)->swapped ? \
				  lswapl(((xBigReq *)(req))->length) : \
				  ((xBigReq *)(req))->length)

#define MAX_TIMES_PER         10
#define BUFSIZE 4096
#define BUFWATERMARK 8192

/*
 *   A lot of the code in this file manipulates a ConnectionInputPtr:
 *
 *    -----------------------------------------------
 *   |------- bufcnt ------->|           |           |
 *   |           |- gotnow ->|           |           |
 *   |           |-------- needed ------>|           |
 *   |-----------+--------- size --------+---------->|
 *    -----------------------------------------------
 *   ^           ^
 *   |           |
 *   buffer   bufptr
 *
 *  buffer is a pointer to the start of the buffer.
 *  bufptr points to the start of the current request.
 *  bufcnt counts how many bytes are in the buffer.
 *  size is the size of the buffer in bytes.
 *
 *  In several of the functions, gotnow and needed are local variables
 *  that do the following:
 *
 *  gotnow is the number of bytes of the request that we're
 *  trying to read that are currently in the buffer.
 *  Typically, gotnow = (buffer + bufcnt) - bufptr
 *
 *  needed = the length of the request that we're trying to
 *  read.  Watch out: needed sometimes counts bytes and sometimes
 *  counts CARD32's.
 */

/*****************************************************************
 * ReadRequestFromClient
 *    Returns one request in client->requestBuffer.  The request
 *    length will be in client->req_len.  Return status is:
 *
 *    > 0  if  successful, specifies length in bytes of the request
 *    = 0  if  entire request is not yet available
 *    < 0  if  client should be terminated
 *
 *    The request returned must be contiguous so that it can be
 *    cast in the dispatcher to the correct request type.  Because requests
 *    are variable length, ReadRequestFromClient() must look at the first 4
 *    or 8 bytes of a request to determine the length (the request length is
 *    in the 3rd and 4th bytes of the request unless it is a Big Request
 *    (see the Big Request Extension), in which case the 3rd and 4th bytes
 *    are zero and the following 4 bytes are the request length.
 *
 *    Note: in order to make the server scheduler (WaitForSomething())
 *    "fair", the ClientsWithInput mask is used.  This mask tells which
 *    clients have FULL requests left in their buffers.  Clients with
 *    partial requests require a read.  Basically, client buffers
 *    are drained before select() is called again.  But, we can't keep
 *    reading from a client that is sending buckets of data (or has
 *    a partial request) because others clients need to be scheduled.
 *****************************************************************/

static void
YieldControl(void)
{
    isItTimeToYield = TRUE;
    timesThisConnection = 0;
}

static void
YieldControlNoInput(int fd)
{
    YieldControl();
    FD_CLR(fd, &ClientsWithInput);
}

static void
YieldControlDeath(void)
{
    timesThisConnection = 0;
}

/* If an input buffer was empty, either free it if it is too big or link it
 * into our list of free input buffers.  This means that different clients can
 * share the same input buffer (at different times).  This was done to save
 * memory.
 */
static void
NextAvailableInput(OsCommPtr oc)
{
    if (AvailableInput) {
        if (AvailableInput != oc) {
            ConnectionInputPtr aci = AvailableInput->input;

            if (aci->size > BUFWATERMARK) {
                free(aci->buffer);
                free(aci);
            }
            else {
                aci->next = FreeInputs;
                FreeInputs = aci;
            }
            AvailableInput->input = NULL;
        }
        AvailableInput = NULL;
    }
}

int
ReadRequestFromClient(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr) client->osPrivate;
    ConnectionInputPtr oci = oc->input;
    int fd = oc->fd;
    unsigned int gotnow, needed;
    int result;
    register xReq *request;
    Bool need_header;
    Bool move_header;

    NextAvailableInput(oc);

    /* make sure we have an input buffer */

    if (!oci) {
        if ((oci = FreeInputs)) {
            FreeInputs = oci->next;
        }
        else if (!(oci = AllocateInputBuffer())) {
            YieldControlDeath();
            return -1;
        }
        oc->input = oci;
    }

#if XTRANS_SEND_FDS
    /* Discard any unused file descriptors */
    while (client->req_fds > 0) {
        int req_fd = ReadFdFromClient(client);
        if (req_fd >= 0)
            close(req_fd);
    }
#endif
    /* advance to start of next request */

    oci->bufptr += oci->lenLastReq;

    need_header = FALSE;
    move_header = FALSE;
    gotnow = oci->bufcnt + oci->buffer - oci->bufptr;

    if (oci->ignoreBytes > 0) {
        if (oci->ignoreBytes > oci->size)
            needed = oci->size;
        else
            needed = oci->ignoreBytes;
    }
    else if (gotnow < sizeof(xReq)) {
        /* We don't have an entire xReq yet.  Can't tell how big
         * the request will be until we get the whole xReq.
         */
        needed = sizeof(xReq);
        need_header = TRUE;
    }
    else {
        /* We have a whole xReq.  We can tell how big the whole
         * request will be unless it is a Big Request.
         */
        request = (xReq *) oci->bufptr;
        needed = get_req_len(request, client);
        if (!needed && client->big_requests) {
            /* It's a Big Request. */
            move_header = TRUE;
            if (gotnow < sizeof(xBigReq)) {
                /* Still need more data to tell just how big. */
                needed = bytes_to_int32(sizeof(xBigReq));       /* needed is in CARD32s now */
                need_header = TRUE;
            }
            else
                needed = get_big_req_len(request, client);
        }
        client->req_len = needed;
        needed <<= 2;           /* needed is in bytes now */
    }
    if (gotnow < needed) {
        /* Need to read more data, either so that we can get a
         * complete xReq (if need_header is TRUE), a complete
         * xBigReq (if move_header is TRUE), or the rest of the
         * request (if need_header and move_header are both FALSE).
         */

        oci->lenLastReq = 0;
        if (needed > maxBigRequestSize << 2) {
            /* request is too big for us to handle */
            /*
             * Mark the rest of it as needing to be ignored, and then return
             * the full size.  Dispatch() will turn it into a BadLength error.
             */
            oci->ignoreBytes = needed - gotnow;
            oci->lenLastReq = gotnow;
            return needed;
        }
        if ((gotnow == 0) || ((oci->bufptr - oci->buffer + needed) > oci->size)) {
            /* no data, or the request is too big to fit in the buffer */

            if ((gotnow > 0) && (oci->bufptr != oci->buffer))
                /* save the data we've already read */
                memmove(oci->buffer, oci->bufptr, gotnow);
            if (needed > oci->size) {
                /* make buffer bigger to accomodate request */
                char *ibuf;

                ibuf = (char *) realloc(oci->buffer, needed);
                if (!ibuf) {
                    YieldControlDeath();
                    return -1;
                }
                oci->size = needed;
                oci->buffer = ibuf;
            }
            oci->bufptr = oci->buffer;
            oci->bufcnt = gotnow;
        }
        /*  XXX this is a workaround.  This function is sometimes called
         *  after the trans_conn has been freed.  In this case trans_conn
         *  will be null.  Really ought to restructure things so that we
         *  never get here in those circumstances.
         */
        if (!oc->trans_conn) {
            /*  treat as if an error occured on the read, which is what
             *  used to happen
             */
            YieldControlDeath();
            return -1;
        }
        result = _XSERVTransRead(oc->trans_conn, oci->buffer + oci->bufcnt,
                                 oci->size - oci->bufcnt);
        if (result <= 0) {
            if ((result < 0) && ETEST(errno)) {
#if defined(SVR4) && defined(__i386__) && !defined(sun)
                if (0)
#endif
                {
                    YieldControlNoInput(fd);
                    return 0;
                }
            }
            YieldControlDeath();
            return -1;
        }
        oci->bufcnt += result;
        gotnow += result;
        /* free up some space after huge requests */
        if ((oci->size > BUFWATERMARK) &&
            (oci->bufcnt < BUFSIZE) && (needed < BUFSIZE)) {
            char *ibuf;

            ibuf = (char *) realloc(oci->buffer, BUFSIZE);
            if (ibuf) {
                oci->size = BUFSIZE;
                oci->buffer = ibuf;
                oci->bufptr = ibuf + oci->bufcnt - gotnow;
            }
        }
        if (need_header && gotnow >= needed) {
            /* We wanted an xReq, now we've gotten it. */
            request = (xReq *) oci->bufptr;
            needed = get_req_len(request, client);
            if (!needed && client->big_requests) {
                move_header = TRUE;
                if (gotnow < sizeof(xBigReq))
                    needed = bytes_to_int32(sizeof(xBigReq));
                else
                    needed = get_big_req_len(request, client);
            }
            client->req_len = needed;
            needed <<= 2;
        }
        if (gotnow < needed) {
            /* Still don't have enough; punt. */
            YieldControlNoInput(fd);
            return 0;
        }
    }
    if (needed == 0) {
        if (client->big_requests)
            needed = sizeof(xBigReq);
        else
            needed = sizeof(xReq);
    }

    /* If there are bytes to ignore, ignore them now. */

    if (oci->ignoreBytes > 0) {
        assert(needed == oci->ignoreBytes || needed == oci->size);
        /*
         * The _XSERVTransRead call above may return more or fewer bytes than we
         * want to ignore.  Ignore the smaller of the two sizes.
         */
        if (gotnow < needed) {
            oci->ignoreBytes -= gotnow;
            oci->bufptr += gotnow;
            gotnow = 0;
        }
        else {
            oci->ignoreBytes -= needed;
            oci->bufptr += needed;
            gotnow -= needed;
        }
        needed = 0;
    }

    oci->lenLastReq = needed;

    /*
     *  Check to see if client has at least one whole request in the
     *  buffer beyond the request we're returning to the caller.
     *  If there is only a partial request, treat like buffer
     *  is empty so that select() will be called again and other clients
     *  can get into the queue.
     */

    gotnow -= needed;
    if (gotnow >= sizeof(xReq)) {
        request = (xReq *) (oci->bufptr + needed);
        if (gotnow >= (result = (get_req_len(request, client) << 2))
            && (result ||
                (client->big_requests &&
                 (gotnow >= sizeof(xBigReq) &&
                  gotnow >= (get_big_req_len(request, client) << 2))))
            )
            FD_SET(fd, &ClientsWithInput);
        else {
            if (!SmartScheduleDisable)
                FD_CLR(fd, &ClientsWithInput);
            else
                YieldControlNoInput(fd);
        }
    }
    else {
        if (!gotnow)
            AvailableInput = oc;
        if (!SmartScheduleDisable)
            FD_CLR(fd, &ClientsWithInput);
        else
            YieldControlNoInput(fd);
    }
    if (SmartScheduleDisable)
        if (++timesThisConnection >= MAX_TIMES_PER)
            YieldControl();
    if (move_header) {
        request = (xReq *) oci->bufptr;
        oci->bufptr += (sizeof(xBigReq) - sizeof(xReq));
        *(xReq *) oci->bufptr = *request;
        oci->lenLastReq -= (sizeof(xBigReq) - sizeof(xReq));
        client->req_len -= bytes_to_int32(sizeof(xBigReq) - sizeof(xReq));
    }
    client->requestBuffer = (void *) oci->bufptr;
#ifdef DEBUG_COMMUNICATION
    {
        xReq *req = client->requestBuffer;

        ErrorF("REQUEST: ClientIDX: %i, type: 0x%x data: 0x%x len: %i\n",
               client->index, req->reqType, req->data, req->length);
    }
#endif
    return needed;
}

#if XTRANS_SEND_FDS
int
ReadFdFromClient(ClientPtr client)
{
    int fd = -1;

    if (client->req_fds > 0) {
        OsCommPtr oc = (OsCommPtr) client->osPrivate;

        --client->req_fds;
        fd = _XSERVTransRecvFd(oc->trans_conn);
    } else
        LogMessage(X_ERROR, "Request asks for FD without setting req_fds\n");
    return fd;
}

int
WriteFdToClient(ClientPtr client, int fd, Bool do_close)
{
    OsCommPtr oc = (OsCommPtr) client->osPrivate;

    return _XSERVTransSendFd(oc->trans_conn, fd, do_close);
}
#endif

/*****************************************************************
 * InsertFakeRequest
 *    Splice a consed up (possibly partial) request in as the next request.
 *
 **********************/

Bool
InsertFakeRequest(ClientPtr client, char *data, int count)
{
    OsCommPtr oc = (OsCommPtr) client->osPrivate;
    ConnectionInputPtr oci = oc->input;
    int fd = oc->fd;
    int gotnow, moveup;

    NextAvailableInput(oc);

    if (!oci) {
        if ((oci = FreeInputs))
            FreeInputs = oci->next;
        else if (!(oci = AllocateInputBuffer()))
            return FALSE;
        oc->input = oci;
    }
    oci->bufptr += oci->lenLastReq;
    oci->lenLastReq = 0;
    gotnow = oci->bufcnt + oci->buffer - oci->bufptr;
    if ((gotnow + count) > oci->size) {
        char *ibuf;

        ibuf = (char *) realloc(oci->buffer, gotnow + count);
        if (!ibuf)
            return FALSE;
        oci->size = gotnow + count;
        oci->buffer = ibuf;
        oci->bufptr = ibuf + oci->bufcnt - gotnow;
    }
    moveup = count - (oci->bufptr - oci->buffer);
    if (moveup > 0) {
        if (gotnow > 0)
            memmove(oci->bufptr + moveup, oci->bufptr, gotnow);
        oci->bufptr += moveup;
        oci->bufcnt += moveup;
    }
    memmove(oci->bufptr - count, data, count);
    oci->bufptr -= count;
    gotnow += count;
    if ((gotnow >= sizeof(xReq)) &&
        (gotnow >= (int) (get_req_len((xReq *) oci->bufptr, client) << 2)))
        FD_SET(fd, &ClientsWithInput);
    else
        YieldControlNoInput(fd);
    return TRUE;
}

/*****************************************************************
 * ResetRequestFromClient
 *    Reset to reexecute the current request, and yield.
 *
 **********************/

void
ResetCurrentRequest(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr) client->osPrivate;
    register ConnectionInputPtr oci = oc->input;
    int fd = oc->fd;
    register xReq *request;
    int gotnow, needed;

    if (AvailableInput == oc)
        AvailableInput = (OsCommPtr) NULL;
    oci->lenLastReq = 0;
    gotnow = oci->bufcnt + oci->buffer - oci->bufptr;
    if (gotnow < sizeof(xReq)) {
        YieldControlNoInput(fd);
    }
    else {
        request = (xReq *) oci->bufptr;
        needed = get_req_len(request, client);
        if (!needed && client->big_requests) {
            oci->bufptr -= sizeof(xBigReq) - sizeof(xReq);
            *(xReq *) oci->bufptr = *request;
            ((xBigReq *) oci->bufptr)->length = client->req_len;
            if (client->swapped) {
                swapl(&((xBigReq *) oci->bufptr)->length);
            }
        }
        if (gotnow >= (needed << 2)) {
            if (FD_ISSET(fd, &AllClients)) {
                FD_SET(fd, &ClientsWithInput);
            }
            else {
                FD_SET(fd, &IgnoredClientsWithInput);
            }
            YieldControl();
        }
        else
            YieldControlNoInput(fd);
    }
}

 /********************
 * FlushAllOutput()
 *    Flush all clients with output.  However, if some client still
 *    has input in the queue (more requests), then don't flush.  This
 *    will prevent the output queue from being flushed every time around
 *    the round robin queue.  Now, some say that it SHOULD be flushed
 *    every time around, but...
 *
 **********************/

void
FlushAllOutput(void)
{
    register int index, base;
    register fd_mask mask;      /* raphael */
    OsCommPtr oc;
    register ClientPtr client;
    Bool newoutput = NewOutputPending;

#if defined(WIN32)
    fd_set newOutputPending;
#endif

    if (FlushCallback)
        CallCallbacks(&FlushCallback, NULL);

    if (!newoutput)
        return;

    /*
     * It may be that some client still has critical output pending,
     * but he is not yet ready to receive it anyway, so we will
     * simply wait for the select to tell us when he's ready to receive.
     */
    CriticalOutputPending = FALSE;
    NewOutputPending = FALSE;

#ifndef WIN32
    for (base = 0; base < howmany(XFD_SETSIZE, NFDBITS); base++) {
        mask = OutputPending.fds_bits[base];
        OutputPending.fds_bits[base] = 0;
        while (mask) {
            index = ffs(mask) - 1;
            mask &= ~lowbit(mask);
            if ((index =
                 ConnectionTranslation[(base * (sizeof(fd_mask) * 8)) +
                                       index]) == 0)
                continue;
            client = clients[index];
            if (client->clientGone)
                continue;
            oc = (OsCommPtr) client->osPrivate;
            if (FD_ISSET(oc->fd, &ClientsWithInput)) {
                FD_SET(oc->fd, &OutputPending); /* set the bit again */
                NewOutputPending = TRUE;
            }
            else
                (void) FlushClient(client, oc, (char *) NULL, 0);
        }
    }
#else                           /* WIN32 */
    FD_ZERO(&newOutputPending);
    for (base = 0; base < XFD_SETCOUNT(&OutputPending); base++) {
        index = XFD_FD(&OutputPending, base);
        if ((index = GetConnectionTranslation(index)) == 0)
            continue;
        client = clients[index];
        if (client->clientGone)
            continue;
        oc = (OsCommPtr) client->osPrivate;
        if (FD_ISSET(oc->fd, &ClientsWithInput)) {
            FD_SET(oc->fd, &newOutputPending);  /* set the bit again */
            NewOutputPending = TRUE;
        }
        else
            (void) FlushClient(client, oc, (char *) NULL, 0);
    }
    XFD_COPYSET(&newOutputPending, &OutputPending);
#endif                          /* WIN32 */
}

void
FlushIfCriticalOutputPending(void)
{
    if (CriticalOutputPending)
        FlushAllOutput();
}

void
SetCriticalOutputPending(void)
{
    CriticalOutputPending = TRUE;
}

/*****************
 * WriteToClient
 *    Copies buf into ClientPtr.buf if it fits (with padding), else
 *    flushes ClientPtr.buf and buf to client.  As of this writing,
 *    every use of WriteToClient is cast to void, and the result
 *    is ignored.  Potentially, this could be used by requests
 *    that are sending several chunks of data and want to break
 *    out of a loop on error.  Thus, we will leave the type of
 *    this routine as int.
 *****************/

int
WriteToClient(ClientPtr who, int count, const void *__buf)
{
    OsCommPtr oc;
    ConnectionOutputPtr oco;
    int padBytes;
    const char *buf = __buf;

#ifdef DEBUG_COMMUNICATION
    Bool multicount = FALSE;
#endif
    if (!count || !who || who == serverClient || who->clientGone)
        return 0;
    oc = who->osPrivate;
    oco = oc->output;
#ifdef DEBUG_COMMUNICATION
    {
        char info[128];
        xError *err;
        xGenericReply *rep;
        xEvent *ev;

        if (!who->replyBytesRemaining) {
            switch (buf[0]) {
            case X_Reply:
                rep = (xGenericReply *) buf;
                if (rep->sequenceNumber == who->sequence) {
                    snprintf(info, 127, "Xreply: type: 0x%x data: 0x%x "
                             "len: %i seq#: 0x%x", rep->type, rep->data1,
                             rep->length, rep->sequenceNumber);
                    multicount = TRUE;
                }
                break;
            case X_Error:
                err = (xError *) buf;
                snprintf(info, 127, "Xerror: Code: 0x%x resID: 0x%x maj: 0x%x "
                         "min: %x", err->errorCode, err->resourceID,
                         err->minorCode, err->majorCode);
                break;
            default:
                if ((buf[0] & 0x7f) == KeymapNotify)
                    snprintf(info, 127, "KeymapNotifyEvent: %i", buf[0]);
                else {
                    ev = (xEvent *) buf;
                    snprintf(info, 127, "XEvent: type: 0x%x detail: 0x%x "
                             "seq#: 0x%x", ev->u.u.type, ev->u.u.detail,
                             ev->u.u.sequenceNumber);
                }
            }
            ErrorF("REPLY: ClientIDX: %i %s\n", who->index, info);
        }
        else
            multicount = TRUE;
    }
#endif

    if (!oco) {
        if ((oco = FreeOutputs)) {
            FreeOutputs = oco->next;
        }
        else if (!(oco = AllocateOutputBuffer())) {
            if (oc->trans_conn) {
                _XSERVTransDisconnect(oc->trans_conn);
                _XSERVTransClose(oc->trans_conn);
                oc->trans_conn = NULL;
            }
            MarkClientException(who);
            return -1;
        }
        oc->output = oco;
    }

    padBytes = padding_for_int32(count);

    if (ReplyCallback) {
        ReplyInfoRec replyinfo;

        replyinfo.client = who;
        replyinfo.replyData = buf;
        replyinfo.dataLenBytes = count + padBytes;
        replyinfo.padBytes = padBytes;
        if (who->replyBytesRemaining) { /* still sending data of an earlier reply */
            who->replyBytesRemaining -= count + padBytes;
            replyinfo.startOfReply = FALSE;
            replyinfo.bytesRemaining = who->replyBytesRemaining;
            CallCallbacks((&ReplyCallback), (void *) &replyinfo);
        }
        else if (who->clientState == ClientStateRunning && buf[0] == X_Reply) { /* start of new reply */
            CARD32 replylen;
            unsigned long bytesleft;

            replylen = ((const xGenericReply *) buf)->length;
            if (who->swapped)
                swapl(&replylen);
            bytesleft = (replylen * 4) + SIZEOF(xReply) - count - padBytes;
            replyinfo.startOfReply = TRUE;
            replyinfo.bytesRemaining = who->replyBytesRemaining = bytesleft;
            CallCallbacks((&ReplyCallback), (void *) &replyinfo);
        }
    }
#ifdef DEBUG_COMMUNICATION
    else if (multicount) {
        if (who->replyBytesRemaining) {
            who->replyBytesRemaining -= (count + padBytes);
        }
        else {
            CARD32 replylen;

            replylen = ((xGenericReply *) buf)->length;
            who->replyBytesRemaining =
                (replylen * 4) + SIZEOF(xReply) - count - padBytes;
        }
    }
#endif
    if (oco->count == 0 || oco->count + count + padBytes > oco->size) {
        FD_CLR(oc->fd, &OutputPending);
        if (!XFD_ANYSET(&OutputPending)) {
            CriticalOutputPending = FALSE;
            NewOutputPending = FALSE;
        }

        if (FlushCallback)
            CallCallbacks(&FlushCallback, NULL);

        return FlushClient(who, oc, buf, count);
    }

    NewOutputPending = TRUE;
    FD_SET(oc->fd, &OutputPending);
    memmove((char *) oco->buf + oco->count, buf, count);
    oco->count += count;
    if (padBytes) {
        memset(oco->buf + oco->count, '\0', padBytes);
        oco->count += padBytes;
    }
    return count;
}

 /********************
 * FlushClient()
 *    If the client isn't keeping up with us, then we try to continue
 *    buffering the data and set the apropriate bit in ClientsWritable
 *    (which is used by WaitFor in the select).  If the connection yields
 *    a permanent error, or we can't allocate any more space, we then
 *    close the connection.
 *
 **********************/

int
FlushClient(ClientPtr who, OsCommPtr oc, const void *__extraBuf, int extraCount)
{
    ConnectionOutputPtr oco = oc->output;
    int connection = oc->fd;
    XtransConnInfo trans_conn = oc->trans_conn;
    struct iovec iov[3];
    static char padBuffer[3];
    const char *extraBuf = __extraBuf;
    long written;
    long padsize;
    long notWritten;
    long todo;

    if (!oco)
	return 0;
    written = 0;
    padsize = padding_for_int32(extraCount);
    notWritten = oco->count + extraCount + padsize;
    if (!notWritten)
        return 0;

    todo = notWritten;
    while (notWritten) {
        long before = written;  /* amount of whole thing written */
        long remain = todo;     /* amount to try this time, <= notWritten */
        int i = 0;
        long len;

        /* You could be very general here and have "in" and "out" iovecs
         * and write a loop without using a macro, but what the heck.  This
         * translates to:
         *
         *     how much of this piece is new?
         *     if more new then we are trying this time, clamp
         *     if nothing new
         *         then bump down amount already written, for next piece
         *         else put new stuff in iovec, will need all of next piece
         *
         * Note that todo had better be at least 1 or else we'll end up
         * writing 0 iovecs.
         */
#define InsertIOV(pointer, length) \
	len = (length) - before; \
	if (len > remain) \
	    len = remain; \
	if (len <= 0) { \
	    before = (-len); \
	} else { \
	    iov[i].iov_len = len; \
	    iov[i].iov_base = (pointer) + before;	\
	    i++; \
	    remain -= len; \
	    before = 0; \
	}

        InsertIOV((char *) oco->buf, oco->count)
            InsertIOV((char *) extraBuf, extraCount)
            InsertIOV(padBuffer, padsize)

            errno = 0;
        if (trans_conn && (len = _XSERVTransWritev(trans_conn, iov, i)) >= 0) {
            written += len;
            notWritten -= len;
            todo = notWritten;
        }
        else if (ETEST(errno)
#ifdef SUNSYSV                  /* check for another brain-damaged OS bug */
                 || (errno == 0)
#endif
#ifdef EMSGSIZE                 /* check for another brain-damaged OS bug */
                 || ((errno == EMSGSIZE) && (todo == 1))
#endif
            ) {
            /* If we've arrived here, then the client is stuffed to the gills
               and not ready to accept more.  Make a note of it and buffer
               the rest. */
            FD_SET(connection, &ClientsWriteBlocked);
            AnyClientsWriteBlocked = TRUE;

            if (written < oco->count) {
                if (written > 0) {
                    oco->count -= written;
                    memmove((char *) oco->buf,
                            (char *) oco->buf + written, oco->count);
                    written = 0;
                }
            }
            else {
                written -= oco->count;
                oco->count = 0;
            }

            if (notWritten > oco->size) {
                unsigned char *obuf = NULL;

                if (notWritten + BUFSIZE <= INT_MAX) {
                    obuf = realloc(oco->buf, notWritten + BUFSIZE);
                }
                if (!obuf) {
                    _XSERVTransDisconnect(oc->trans_conn);
                    _XSERVTransClose(oc->trans_conn);
                    oc->trans_conn = NULL;
                    MarkClientException(who);
                    oco->count = 0;
                    return -1;
                }
                oco->size = notWritten + BUFSIZE;
                oco->buf = obuf;
            }

            /* If the amount written extended into the padBuffer, then the
               difference "extraCount - written" may be less than 0 */
            if ((len = extraCount - written) > 0)
                memmove((char *) oco->buf + oco->count,
                        extraBuf + written, len);

            oco->count = notWritten;    /* this will include the pad */
            /* return only the amount explicitly requested */
            return extraCount;
        }
#ifdef EMSGSIZE                 /* check for another brain-damaged OS bug */
        else if (errno == EMSGSIZE) {
            todo >>= 1;
        }
#endif
        else {
            if (oc->trans_conn) {
                _XSERVTransDisconnect(oc->trans_conn);
                _XSERVTransClose(oc->trans_conn);
                oc->trans_conn = NULL;
            }
            MarkClientException(who);
            oco->count = 0;
            return -1;
        }
    }

    /* everything was flushed out */
    oco->count = 0;
    /* check to see if this client was write blocked */
    if (AnyClientsWriteBlocked) {
        FD_CLR(oc->fd, &ClientsWriteBlocked);
        if (!XFD_ANYSET(&ClientsWriteBlocked))
            AnyClientsWriteBlocked = FALSE;
    }
    if (oco->size > BUFWATERMARK) {
        free(oco->buf);
        free(oco);
    }
    else {
        oco->next = FreeOutputs;
        FreeOutputs = oco;
    }
    oc->output = (ConnectionOutputPtr) NULL;
    return extraCount;          /* return only the amount explicitly requested */
}

static ConnectionInputPtr
AllocateInputBuffer(void)
{
    ConnectionInputPtr oci;

    oci = malloc(sizeof(ConnectionInput));
    if (!oci)
        return NULL;
    oci->buffer = malloc(BUFSIZE);
    if (!oci->buffer) {
        free(oci);
        return NULL;
    }
    oci->size = BUFSIZE;
    oci->bufptr = oci->buffer;
    oci->bufcnt = 0;
    oci->lenLastReq = 0;
    oci->ignoreBytes = 0;
    return oci;
}

static ConnectionOutputPtr
AllocateOutputBuffer(void)
{
    ConnectionOutputPtr oco;

    oco = malloc(sizeof(ConnectionOutput));
    if (!oco)
        return NULL;
    oco->buf = calloc(1, BUFSIZE);
    if (!oco->buf) {
        free(oco);
        return NULL;
    }
    oco->size = BUFSIZE;
    oco->count = 0;
    return oco;
}

void
FreeOsBuffers(OsCommPtr oc)
{
    ConnectionInputPtr oci;
    ConnectionOutputPtr oco;

    if (AvailableInput == oc)
        AvailableInput = (OsCommPtr) NULL;
    if ((oci = oc->input)) {
        if (FreeInputs) {
            free(oci->buffer);
            free(oci);
        }
        else {
            FreeInputs = oci;
            oci->next = (ConnectionInputPtr) NULL;
            oci->bufptr = oci->buffer;
            oci->bufcnt = 0;
            oci->lenLastReq = 0;
            oci->ignoreBytes = 0;
        }
    }
    if ((oco = oc->output)) {
        if (FreeOutputs) {
            free(oco->buf);
            free(oco);
        }
        else {
            FreeOutputs = oco;
            oco->next = (ConnectionOutputPtr) NULL;
            oco->count = 0;
        }
    }
}

void
ResetOsBuffers(void)
{
    ConnectionInputPtr oci;
    ConnectionOutputPtr oco;

    while ((oci = FreeInputs)) {
        FreeInputs = oci->next;
        free(oci->buffer);
        free(oci);
    }
    while ((oco = FreeOutputs)) {
        FreeOutputs = oco->next;
        free(oco->buf);
        free(oco);
    }
}
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
d451 1
a451 1
     *  can get into the queue.   
d974 1
a974 1
                unsigned char *obuf;
d976 3
a978 2
                obuf = (unsigned char *) realloc(oco->buf,
                                                 notWritten + BUFSIZE);
@


1.12
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d105 2
a106 1
/* check for both EAGAIN and EWOULDBLOCK, because some supposedly POSIX
d110 6
a115 2
#define ETEST(err) (err == EAGAIN || err == EWOULDBLOCK)
#else                           /* WIN32 The socket errorcodes differ from the normal errors */
d489 1
a489 1
    client->requestBuffer = (pointer) oci->bufptr;
d817 1
a817 1
            CallCallbacks((&ReplyCallback), (pointer) &replyinfo);
d829 1
a829 1
            CallCallbacks((&ReplyCallback), (pointer) &replyinfo);
@


1.11
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d209 7
a215 2
int
ReadRequestFromClient(ClientPtr client)
a216 15
    OsCommPtr oc = (OsCommPtr) client->osPrivate;
    ConnectionInputPtr oci = oc->input;
    int fd = oc->fd;
    unsigned int gotnow, needed;
    int result;
    register xReq *request;
    Bool need_header;
    Bool move_header;

    /* If an input buffer was empty, either free it if it is too big
     * or link it into our list of free input buffers.  This means that
     * different clients can share the same input buffer (at different
     * times).  This was done to save memory.
     */

d219 1
a219 1
            register ConnectionInputPtr aci = AvailableInput->input;
d229 1
a229 1
            AvailableInput->input = (ConnectionInputPtr) NULL;
d231 1
a231 1
        AvailableInput = (OsCommPtr) NULL;
d233 15
d262 8
d496 25
d535 1
a535 3
    if (AvailableInput) {
        if (AvailableInput != oc) {
            ConnectionInputPtr aci = AvailableInput->input;
a536 12
            if (aci->size > BUFWATERMARK) {
                free(aci->buffer);
                free(aci);
            }
            else {
                aci->next = FreeInputs;
                FreeInputs = aci;
            }
            AvailableInput->input = (ConnectionInputPtr) NULL;
        }
        AvailableInput = (OsCommPtr) NULL;
    }
d841 1
a841 1
    if (oco->count + count + padBytes > oco->size) {
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d1066 1
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d85 17
a597 2
static const int padlength[4] = { 0, 3, 2, 1 };

d775 1
a775 1
    padBytes = padlength[count & 3];
d833 5
a837 1
    oco->count += count + padBytes;
d866 1
a866 1
        return 0;
d868 1
a868 1
    padsize = padlength[extraCount & 3];
d870 3
@


1.8
log
@Bugfix Update to xserver 1.11.3
@
text
@a24 1

a44 1

d82 2
a83 2
CallbackListPtr       ReplyCallback;
CallbackListPtr       FlushCallback;
d93 1
a93 1
#else /* WIN32 The socket errorcodes differ from the normal errors*/
d99 3
a101 3
static ConnectionInputPtr FreeInputs = (ConnectionInputPtr)NULL;
static ConnectionOutputPtr FreeOutputs = (ConnectionOutputPtr)NULL;
static OsCommPtr AvailableInput = (OsCommPtr)NULL;
d113 2
a145 1

d195 1
a195 1
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
d210 15
a224 18
    if (AvailableInput)
    {
	if (AvailableInput != oc)
	{
	    register ConnectionInputPtr aci = AvailableInput->input;
	    if (aci->size > BUFWATERMARK)
	    {
		free(aci->buffer);
		free(aci);
	    }
	    else
	    {
		aci->next = FreeInputs;
		FreeInputs = aci;
	    }
	    AvailableInput->input = (ConnectionInputPtr)NULL;
	}
	AvailableInput = (OsCommPtr)NULL;
d229 9
a237 12
    if (!oci)
    {
	if ((oci = FreeInputs))
	{
	    FreeInputs = oci->next;
	}
	else if (!(oci = AllocateInputBuffer()))
	{
	    YieldControlDeath();
	    return -1;
	}
	oc->input = oci;
d249 87
a335 100
	if (oci->ignoreBytes > oci->size)
	    needed = oci->size;
	else
	    needed = oci->ignoreBytes;
    }
    else if (gotnow < sizeof(xReq))
    {
	/* We don't have an entire xReq yet.  Can't tell how big
	 * the request will be until we get the whole xReq.
	 */
	needed = sizeof(xReq);
	need_header = TRUE;
    }
    else
    {
	/* We have a whole xReq.  We can tell how big the whole
	 * request will be unless it is a Big Request.
	 */
	request = (xReq *)oci->bufptr;
	needed = get_req_len(request, client);
	if (!needed && client->big_requests)
	{
	    /* It's a Big Request. */
	    move_header = TRUE;
	    if (gotnow < sizeof(xBigReq))
	    {
		/* Still need more data to tell just how big. */
		needed = bytes_to_int32(sizeof(xBigReq)); /* needed is in CARD32s now */
		need_header = TRUE;
	    }
	    else
		needed = get_big_req_len(request, client);
	}
	client->req_len = needed;
	needed <<= 2; /* needed is in bytes now */
    }
    if (gotnow < needed)
    {
	/* Need to read more data, either so that we can get a
	 * complete xReq (if need_header is TRUE), a complete
	 * xBigReq (if move_header is TRUE), or the rest of the
	 * request (if need_header and move_header are both FALSE).
	 */

	oci->lenLastReq = 0;
	if (needed > maxBigRequestSize << 2)
	{
	    /* request is too big for us to handle */
	    /*
	     * Mark the rest of it as needing to be ignored, and then return
	     * the full size.  Dispatch() will turn it into a BadLength error.
	     */
	    oci->ignoreBytes = needed - gotnow;
	    oci->lenLastReq = gotnow;
	    return needed;
	}
	if ((gotnow == 0) ||
	    ((oci->bufptr - oci->buffer + needed) > oci->size))
	{
	    /* no data, or the request is too big to fit in the buffer */

	    if ((gotnow > 0) && (oci->bufptr != oci->buffer))
		/* save the data we've already read */
		memmove(oci->buffer, oci->bufptr, gotnow);
	    if (needed > oci->size)
	    {
		/* make buffer bigger to accomodate request */
		char *ibuf;

		ibuf = (char *)realloc(oci->buffer, needed);
		if (!ibuf)
		{
		    YieldControlDeath();
		    return -1;
		}
		oci->size = needed;
		oci->buffer = ibuf;
	    }
	    oci->bufptr = oci->buffer;
	    oci->bufcnt = gotnow;
	}
	/*  XXX this is a workaround.  This function is sometimes called
	 *  after the trans_conn has been freed.  In this case trans_conn
	 *  will be null.  Really ought to restructure things so that we
	 *  never get here in those circumstances.
	 */
	if (!oc->trans_conn)
	{
	    /*  treat as if an error occured on the read, which is what
	     *  used to happen
	     */
	    YieldControlDeath();
	    return -1;
	}
	    result = _XSERVTransRead(oc->trans_conn, oci->buffer + oci->bufcnt,
				     oci->size - oci->bufcnt); 
	if (result <= 0)
	{
	    if ((result < 0) && ETEST(errno))
	    {
d337 1
a337 1
		if (0)
d339 47
a385 53
		{
		    YieldControlNoInput(fd);
		    return 0;
		}
	    }
	    YieldControlDeath();
	    return -1;
	}
	oci->bufcnt += result;
	gotnow += result;
	/* free up some space after huge requests */
	if ((oci->size > BUFWATERMARK) &&
	    (oci->bufcnt < BUFSIZE) && (needed < BUFSIZE))
	{
	    char *ibuf;

	    ibuf = (char *)realloc(oci->buffer, BUFSIZE);
	    if (ibuf)
	    {
		oci->size = BUFSIZE;
		oci->buffer = ibuf;
		oci->bufptr = ibuf + oci->bufcnt - gotnow;
	    }
	}
	if (need_header && gotnow >= needed)
	{
	    /* We wanted an xReq, now we've gotten it. */
	    request = (xReq *)oci->bufptr;
	    needed = get_req_len(request, client);
	    if (!needed && client->big_requests)
	    {
		move_header = TRUE;
		if (gotnow < sizeof(xBigReq))
		    needed = bytes_to_int32(sizeof(xBigReq));
		else
		    needed = get_big_req_len(request, client);
	    }
	    client->req_len = needed;
	    needed <<= 2;
	}
	if (gotnow < needed)
	{
	    /* Still don't have enough; punt. */
	    YieldControlNoInput(fd);
	    return 0;
	}
    }
    if (needed == 0)
    {
	if (client->big_requests)
	    needed = sizeof(xBigReq);
	else
	    needed = sizeof(xReq);
d391 16
a406 15
	assert(needed == oci->ignoreBytes || needed == oci->size);
	/*
	 * The _XSERVTransRead call above may return more or fewer bytes than we
	 * want to ignore.  Ignore the smaller of the two sizes.
	 */
	if (gotnow < needed) {
	    oci->ignoreBytes -= gotnow;
	    oci->bufptr += gotnow;
	    gotnow = 0;
	} else {
	    oci->ignoreBytes -= needed;
	    oci->bufptr += needed;
	    gotnow -= needed;
	}
	needed = 0;
d420 23
a442 26
    if (gotnow >= sizeof(xReq)) 
    {
	request = (xReq *)(oci->bufptr + needed);
	if (gotnow >= (result = (get_req_len(request, client) << 2))
	    && (result ||
		(client->big_requests &&
		 (gotnow >= sizeof(xBigReq) &&
		  gotnow >= (get_big_req_len(request, client) << 2))))
	    )
	    FD_SET(fd, &ClientsWithInput);
	else
	{
	    if (!SmartScheduleDisable)
		FD_CLR(fd, &ClientsWithInput);
	    else
		YieldControlNoInput(fd);
	}
    }
    else
    {
	if (!gotnow)
	    AvailableInput = oc;
	if (!SmartScheduleDisable)
	    FD_CLR(fd, &ClientsWithInput);
	else
	    YieldControlNoInput(fd);
d445 8
a452 9
    if (++timesThisConnection >= MAX_TIMES_PER)
	YieldControl();
    if (move_header)
    {
	request = (xReq *)oci->bufptr;
	oci->bufptr += (sizeof(xBigReq) - sizeof(xReq));
	*(xReq *)oci->bufptr = *request;
	oci->lenLastReq -= (sizeof(xBigReq) - sizeof(xReq));
	client->req_len -= bytes_to_int32(sizeof(xBigReq) - sizeof(xReq));
d454 1
a454 1
    client->requestBuffer = (pointer)oci->bufptr;
d457 4
a460 3
	xReq *req = client->requestBuffer;
	ErrorF("REQUEST: ClientIDX: %i, type: 0x%x data: 0x%x len: %i\n",
	       client->index,req->reqType,req->data,req->length);
d475 1
a475 1
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
d480 22
a501 26
    if (AvailableInput)
    {
	if (AvailableInput != oc)
	{
	    ConnectionInputPtr aci = AvailableInput->input;
	    if (aci->size > BUFWATERMARK)
	    {
		free(aci->buffer);
		free(aci);
	    }
	    else
	    {
		aci->next = FreeInputs;
		FreeInputs = aci;
	    }
	    AvailableInput->input = (ConnectionInputPtr)NULL;
	}
	AvailableInput = (OsCommPtr)NULL;
    }
    if (!oci)
    {
	if ((oci = FreeInputs))
	    FreeInputs = oci->next;
	else if (!(oci = AllocateInputBuffer()))
	    return FALSE;
	oc->input = oci;
d506 2
a507 3
    if ((gotnow + count) > oci->size)
    {
	char *ibuf;
d509 6
a514 6
	ibuf = (char *)realloc(oci->buffer, gotnow + count);
	if (!ibuf)
	    return FALSE;
	oci->size = gotnow + count;
	oci->buffer = ibuf;
	oci->bufptr = ibuf + oci->bufcnt - gotnow;
d517 5
a521 6
    if (moveup > 0)
    {
	if (gotnow > 0)
	    memmove(oci->bufptr + moveup, oci->bufptr, gotnow);
	oci->bufptr += moveup;
	oci->bufcnt += moveup;
d527 2
a528 2
	(gotnow >= (int)(get_req_len((xReq *)oci->bufptr, client) << 2)))
	FD_SET(fd, &ClientsWithInput);
d530 1
a530 1
	YieldControlNoInput(fd);
d543 1
a543 1
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
d548 1
d550 1
a550 1
	AvailableInput = (OsCommPtr)NULL;
d553 2
a554 3
    if (gotnow < sizeof(xReq))
    {
	YieldControlNoInput(fd);
d556 22
a577 29
    else
    {
	request = (xReq *)oci->bufptr;
	needed = get_req_len(request, client);
	if (!needed && client->big_requests)
	{
	    oci->bufptr -= sizeof(xBigReq) - sizeof(xReq);
	    *(xReq *)oci->bufptr = *request;
	    ((xBigReq *)oci->bufptr)->length = client->req_len;
	    if (client->swapped)
	    {
		char n;
		swapl(&((xBigReq *)oci->bufptr)->length, n);
	    }
	}
	if (gotnow >= (needed << 2))
	{
	    if (FD_ISSET(fd, &AllClients))
	    {
		FD_SET(fd, &ClientsWithInput);
	    }
	    else
	    {
		FD_SET(fd, &IgnoredClientsWithInput);
	    }
	    YieldControl();
	}
	else
	    YieldControlNoInput(fd);
d581 1
a581 1
static const int padlength[4] = {0, 3, 2, 1};
d597 1
a597 1
    register fd_mask mask; /* raphael */
d601 1
d607 1
a607 1
	CallCallbacks(&FlushCallback, NULL);
d610 1
a610 1
	return;
d621 21
a641 22
    for (base = 0; base < howmany(XFD_SETSIZE, NFDBITS); base++)
    {
	mask = OutputPending.fds_bits[ base ];
	OutputPending.fds_bits[ base ] = 0;
	while (mask)
	{
	    index = ffs(mask) - 1;
	    mask &= ~lowbit(mask);
	    if ((index = ConnectionTranslation[(base * (sizeof(fd_mask)*8)) + index]) == 0)
		continue;
	    client = clients[index];
	    if (client->clientGone)
		continue;
	    oc = (OsCommPtr)client->osPrivate;
	    if (FD_ISSET(oc->fd, &ClientsWithInput))
	    {
		FD_SET(oc->fd, &OutputPending); /* set the bit again */
		NewOutputPending = TRUE;
	    }
	    else
		(void)FlushClient(client, oc, (char *)NULL, 0);
	}
d643 1
a643 1
#else  /* WIN32 */
d645 14
a658 16
    for (base = 0; base < XFD_SETCOUNT(&OutputPending); base++)
    {
	    index = XFD_FD(&OutputPending, base);
	    if ((index = GetConnectionTranslation(index)) == 0)
		continue;
	    client = clients[index];
	    if (client->clientGone)
		continue;
	    oc = (OsCommPtr)client->osPrivate;
	    if (FD_ISSET(oc->fd, &ClientsWithInput))
	    {
		FD_SET(oc->fd, &newOutputPending); /* set the bit again */
		NewOutputPending = TRUE;
	    }
	    else
		(void)FlushClient(client, oc, (char *)NULL, 0);
d661 1
a661 1
#endif /* WIN32 */
d668 1
a668 1
	FlushAllOutput();
d689 1
a689 1
WriteToClient (ClientPtr who, int count, const void *__buf)
d695 1
d700 1
a700 1
	return 0;
d705 36
a740 35
	char info[128];
	xError *err;
	xGenericReply *rep;
	xEvent *ev;
	
	if (!who->replyBytesRemaining) {
	    switch(buf[0]) {
	    case X_Reply:
		rep = (xGenericReply*)buf;
		if (rep->sequenceNumber == who->sequence) {
		    snprintf(info,127,"Xreply: type: 0x%x data: 0x%x "
			     "len: %i seq#: 0x%x", rep->type, rep->data1,
			     rep->length, rep->sequenceNumber);
		    multicount = TRUE;
		}
		break;
	    case X_Error:
		err = (xError*)buf;
		snprintf(info,127,"Xerror: Code: 0x%x resID: 0x%x maj: 0x%x "
			 "min: %x", err->errorCode,err->resourceID,
			 err->minorCode,err->majorCode);
		break;
	    default:
		if ((buf[0] & 0x7f) == KeymapNotify) 
		    snprintf(info,127,"KeymapNotifyEvent: %i",buf[0]);
		else {
		    ev = (xEvent*)buf;
		    snprintf(info,127,"XEvent: type: 0x%x detail: 0x%x "
			     "seq#: 0x%x",  ev->u.u.type, ev->u.u.detail,
			     ev->u.u.sequenceNumber);
		}
	    }
	    ErrorF("REPLY: ClientIDX: %i %s\n",who->index, info);
	} else
	    multicount = TRUE;
d744 14
a757 17
    if (!oco)
    {
	if ((oco = FreeOutputs))
	{
	    FreeOutputs = oco->next;
	}
	else if (!(oco = AllocateOutputBuffer()))
	{
	    if (oc->trans_conn) {
		_XSERVTransDisconnect(oc->trans_conn);
		_XSERVTransClose(oc->trans_conn);
		oc->trans_conn = NULL;
	    }
	    MarkClientException(who);
	    return -1;
	}
	oc->output = oco;
d762 1
a762 2
    if(ReplyCallback)
    {
d765 22
a786 26
	replyinfo.client = who;
	replyinfo.replyData = buf;
	replyinfo.dataLenBytes = count + padBytes;
	replyinfo.padBytes = padBytes;
	if (who->replyBytesRemaining)
	{ /* still sending data of an earlier reply */
	    who->replyBytesRemaining -= count + padBytes;
	    replyinfo.startOfReply = FALSE;
	    replyinfo.bytesRemaining = who->replyBytesRemaining;
	    CallCallbacks((&ReplyCallback), (pointer)&replyinfo);
	}
	else if (who->clientState == ClientStateRunning
		 && buf[0] == X_Reply)
        { /* start of new reply */
	    CARD32 replylen;
	    unsigned long bytesleft;
	    char n;

	    replylen = ((xGenericReply *)buf)->length;
	    if (who->swapped)
		swapl(&replylen, n);
	    bytesleft = (replylen * 4) + SIZEOF(xReply) - count - padBytes;
	    replyinfo.startOfReply = TRUE;
	    replyinfo.bytesRemaining = who->replyBytesRemaining = bytesleft;
	    CallCallbacks((&ReplyCallback), (pointer)&replyinfo);
	} 	                      
d790 10
a799 8
	if (who->replyBytesRemaining) {
	    who->replyBytesRemaining -= (count + padBytes);
	} else {
	    CARD32 replylen;
	    replylen = ((xGenericReply *)buf)->length;
	    who->replyBytesRemaining =
		(replylen * 4) + SIZEOF(xReply) - count - padBytes;
	}
d802 6
a807 7
    if (oco->count + count + padBytes > oco->size)
    {
	FD_CLR(oc->fd, &OutputPending);
	if(!XFD_ANYSET(&OutputPending)) {
	  CriticalOutputPending = FALSE;
	  NewOutputPending = FALSE;
	}
d809 2
a810 2
	if (FlushCallback)
	    CallCallbacks(&FlushCallback, NULL);
d812 1
a812 1
	return FlushClient(who, oc, buf, count);
d817 1
a817 1
    memmove((char *)oco->buf + oco->count, buf, count);
d847 1
a847 1
	return 0;
d853 18
a870 18
	long before = written;	/* amount of whole thing written */
	long remain = todo;	/* amount to try this time, <= notWritten */
	int i = 0;
	long len;
	
	/* You could be very general here and have "in" and "out" iovecs
	 * and write a loop without using a macro, but what the heck.  This
	 * translates to:
	 *
	 *     how much of this piece is new?
	 *     if more new then we are trying this time, clamp
	 *     if nothing new
	 *         then bump down amount already written, for next piece
	 *         else put new stuff in iovec, will need all of next piece
	 *
	 * Note that todo had better be at least 1 or else we'll end up
	 * writing 0 iovecs.
	 */
d885 13
a897 14
	InsertIOV ((char *)oco->buf, oco->count)
	InsertIOV ((char *)extraBuf, extraCount)
	InsertIOV (padBuffer, padsize)

	errno = 0;
	if (trans_conn && (len = _XSERVTransWritev(trans_conn, iov, i)) >= 0)
	{
	    written += len;
	    notWritten -= len;
	    todo = notWritten;
	}
	else if (ETEST(errno)
#ifdef SUNSYSV /* check for another brain-damaged OS bug */
		 || (errno == 0)
d899 2
a900 2
#ifdef EMSGSIZE /* check for another brain-damaged OS bug */
		 || ((errno == EMSGSIZE) && (todo == 1))
d902 51
a952 60
		)
	{
	    /* If we've arrived here, then the client is stuffed to the gills
	       and not ready to accept more.  Make a note of it and buffer
	       the rest. */
	    FD_SET(connection, &ClientsWriteBlocked);
	    AnyClientsWriteBlocked = TRUE;

	    if (written < oco->count)
	    {
		if (written > 0)
		{
		    oco->count -= written;
		    memmove((char *)oco->buf,
			    (char *)oco->buf + written,
			  oco->count);
		    written = 0;
		}
	    }
	    else
	    {
		written -= oco->count;
		oco->count = 0;
	    }

	    if (notWritten > oco->size)
	    {
		unsigned char *obuf;

		obuf = (unsigned char *)realloc(oco->buf,
						 notWritten + BUFSIZE);
		if (!obuf)
		{
		    _XSERVTransDisconnect(oc->trans_conn);
		    _XSERVTransClose(oc->trans_conn);
		    oc->trans_conn = NULL;
		    MarkClientException(who);
		    oco->count = 0;
		    return -1;
		}
		oco->size = notWritten + BUFSIZE;
		oco->buf = obuf;
	    }

	    /* If the amount written extended into the padBuffer, then the
	       difference "extraCount - written" may be less than 0 */
	    if ((len = extraCount - written) > 0)
		memmove ((char *)oco->buf + oco->count,
			 extraBuf + written,
		       len);

	    oco->count = notWritten; /* this will include the pad */
	    /* return only the amount explicitly requested */
	    return extraCount;
	}
#ifdef EMSGSIZE /* check for another brain-damaged OS bug */
	else if (errno == EMSGSIZE)
	{
	    todo >>= 1;
	}
d954 10
a963 12
	else
	{
	    if (oc->trans_conn)
	    {
		_XSERVTransDisconnect(oc->trans_conn);
		_XSERVTransClose(oc->trans_conn);
		oc->trans_conn = NULL;
	    }
	    MarkClientException(who);
	    oco->count = 0;
	    return -1;
	}
d969 12
a980 10
    if (AnyClientsWriteBlocked)
    {
	FD_CLR(oc->fd, &ClientsWriteBlocked);
 	if (! XFD_ANYSET(&ClientsWriteBlocked))
	    AnyClientsWriteBlocked = FALSE;
    }
    if (oco->size > BUFWATERMARK)
    {
	free(oco->buf);
	free(oco);
d982 2
a983 7
    else
    {
	oco->next = FreeOutputs;
	FreeOutputs = oco;
    }
    oc->output = (ConnectionOutputPtr)NULL;
    return extraCount; /* return only the amount explicitly requested */
d993 1
a993 1
	return NULL;
d995 3
a997 4
    if (!oci->buffer)
    {
	free(oci);
	return NULL;
d1014 1
a1014 1
	return NULL;
d1016 3
a1018 4
    if (!oco->buf)
    {
	free(oco);
	return NULL;
d1032 24
a1055 30
	AvailableInput = (OsCommPtr)NULL;
    if ((oci = oc->input))
    {
	if (FreeInputs)
	{
	    free(oci->buffer);
	    free(oci);
	}
	else
	{
	    FreeInputs = oci;
	    oci->next = (ConnectionInputPtr)NULL;
	    oci->bufptr = oci->buffer;
	    oci->bufcnt = 0;
	    oci->lenLastReq = 0;
	}
    }
    if ((oco = oc->output))
    {
	if (FreeOutputs)
	{
	    free(oco->buf);
	    free(oco);
	}
	else
	{
	    FreeOutputs = oco;
	    oco->next = (ConnectionOutputPtr)NULL;
	    oco->count = 0;
	}
d1065 9
a1073 11
    while ((oci = FreeInputs))
    {
	FreeInputs = oci->next;
	free(oci->buffer);
	free(oci);
    }
    while ((oco = FreeOutputs))
    {
	FreeOutputs = oco->next;
	free(oco->buf);
	free(oco);
@


1.7
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d813 1
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a412 1
    oci->lenLastReq = needed;
d418 14
a431 2
	oci->ignoreBytes -= gotnow;
	needed = gotnow = 0;
d433 2
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d218 2
a219 2
		xfree(aci->buffer);
		xfree(aci);
d254 8
a261 1
    if (gotnow < sizeof(xReq))
d304 7
a310 2
	    YieldControlDeath();
	    return -1;
d325 1
a325 1
		ibuf = (char *)xrealloc(oci->buffer, needed);
d375 1
a375 1
	    ibuf = (char *)xrealloc(oci->buffer, BUFSIZE);
d415 8
d502 2
a503 2
		xfree(aci->buffer);
		xfree(aci);
d529 1
a529 1
	ibuf = (char *)xrealloc(oci->buffer, gotnow + count);
d531 1
a531 1
	    return(FALSE);
d552 1
a552 1
    return(TRUE);
d721 2
a722 2
    OsCommPtr oc = (OsCommPtr)who->osPrivate;
    ConnectionOutputPtr oco = oc->output;
d728 4
a731 2
    if (!count)
	return(0);
d842 4
d853 1
a853 1
    return(count);
d966 1
a966 1
		obuf = (unsigned char *)xrealloc(oco->buf,
d975 1
a975 1
		    return(-1);
d1008 1
a1008 1
	    return(-1);
d1023 2
a1024 2
	xfree(oco->buf);
	xfree(oco);
d1040 1
a1040 1
    oci = xalloc(sizeof(ConnectionInput));
d1043 1
a1043 1
    oci->buffer = xalloc(BUFSIZE);
d1046 1
a1046 1
	xfree(oci);
d1053 1
d1062 1
a1062 1
    oco = xalloc(sizeof(ConnectionOutput));
d1065 1
a1065 1
    oco->buf = xcalloc(1, BUFSIZE);
d1068 1
a1068 1
	xfree(oco);
d1088 2
a1089 2
	    xfree(oci->buffer);
	    xfree(oci);
d1104 2
a1105 2
	    xfree(oco->buf);
	    xfree(oco);
d1125 2
a1126 2
	xfree(oci->buffer);
	xfree(oci);
d1131 2
a1132 2
	xfree(oco->buf);
	xfree(oco);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a75 1
#define NEED_REPLIES
d84 2
a85 2
_X_EXPORT CallbackListPtr       ReplyCallback;
_X_EXPORT CallbackListPtr       FlushCallback;
d108 1
a108 1
#include <X11/extensions/bigreqstr.h>
d276 1
a276 1
		needed = sizeof(xBigReq) >> 2; /* needed is in CARD32s now */
d380 1
a380 1
		    needed = sizeof(xBigReq) >> 2;
d448 1
a448 1
	client->req_len -= (sizeof(xBigReq) - sizeof(xReq)) >> 2;
d541 1
a541 1
_X_EXPORT void
d681 1
a681 1
_X_EXPORT void
d698 1
a698 1
_X_EXPORT int
d1014 1
a1014 1
    oci = (ConnectionInputPtr)xalloc(sizeof(ConnectionInput));
d1016 2
a1017 2
	return (ConnectionInputPtr)NULL;
    oci->buffer = (char *)xalloc(BUFSIZE);
d1021 1
a1021 1
	return (ConnectionInputPtr)NULL;
d1035 1
a1035 1
    oco = (ConnectionOutputPtr)xalloc(sizeof(ConnectionOutput));
d1037 2
a1038 2
	return (ConnectionOutputPtr)NULL;
    oco->buf = (unsigned char *) xcalloc(1, BUFSIZE);
d1042 1
a1042 1
	return (ConnectionOutputPtr)NULL;
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a72 1
#ifndef Lynx
a73 3
#else
#include <uio.h>
#endif
a94 1
#if defined(EAGAIN) && defined(EWOULDBLOCK)
a95 7
#else
#ifdef EAGAIN
#define ETEST(err) (err == EAGAIN)
#else
#define ETEST(err) (err == EWOULDBLOCK)
#endif
#endif
a108 1
#ifdef BIGREQS
a113 1
#endif
d174 19
a192 8
#define YieldControl()				\
        { isItTimeToYield = TRUE;		\
	  timesThisConnection = 0; }
#define YieldControlNoInput()			\
        { YieldControl();			\
	  FD_CLR(fd, &ClientsWithInput); }
#define YieldControlDeath()			\
        { timesThisConnection = 0; }
a203 1
#ifdef BIGREQS
a204 1
#endif
a252 1
#ifdef BIGREQS
a253 1
#endif
a269 1
#ifdef BIGREQS
a282 1
#endif
a294 1
#ifdef BIGREQS
a300 1
#endif
d349 1
a349 1
		    YieldControlNoInput();
a376 1
#ifdef BIGREQS
a384 1
#endif
d391 1
a391 1
	    YieldControlNoInput();
a396 1
#ifdef BIGREQS
a399 1
#endif
a416 1
#ifdef BIGREQS
a420 1
#endif
a424 1
#ifdef SMART_SCHEDULE
d428 1
a428 2
#endif
		YieldControlNoInput();
a434 1
#ifdef SMART_SCHEDULE
d438 1
a438 2
#endif
	    YieldControlNoInput();
a439 1
#ifdef SMART_SCHEDULE
a440 1
#endif
a442 1
#ifdef BIGREQS
a450 1
#endif
d532 1
a532 1
	YieldControlNoInput();
d556 1
a556 1
	YieldControlNoInput();
a561 1
#ifdef BIGREQS
a572 1
#endif
d586 1
a586 1
	    YieldControlNoInput();
d590 1
a590 7


_X_EXPORT CallbackListPtr SkippedRequestsCallback = NULL;

    /* lookup table for adding padding bytes to data that is read from
    	or written to the X socket.  */
static int padlength[4] = {0, 3, 2, 1};
d700 1
a700 1
WriteToClient (ClientPtr who, int count, char *buf)
d705 1
d842 1
a842 1
FlushClient(ClientPtr who, OsCommPtr oc, char *extraBuf, int extraCount)
d849 1
d888 1
a888 1
	    iov[i].iov_base = (pointer) + before; \
d895 1
a895 1
	InsertIOV (extraBuf, extraCount)
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d60 2
a61 3
#if 0
#define DEBUG_COMMUNICATION
#endif
a93 2
static xReqPtr PeekNextRequest(xReqPtr req, ClientPtr client, Bool readmore);
static void SkipRequests(xReqPtr req, ClientPtr client, int numskipped);
d356 1
a356 1
#if defined(SVR4) && defined(i386) && !defined(sun)
a618 79
/*****************************************************************
 *  PeekNextRequest and SkipRequests were implemented to support DBE 
 *  idioms, but can certainly be used outside of DBE.  There are two 
 *  related macros in os.h, ReqLen and CastxReq.  See the porting 
 *  layer document for more details.
 *
 **********************/


/*****************************************************************
 *  PeekNextRequest
 *      lets you look ahead at the unexecuted requests in a 
 *      client's request buffer.
 *
 *      Note: this implementation of PeekNextRequest ignores the
 *      readmore parameter.
 *
 **********************/

static xReqPtr
PeekNextRequest(
    xReqPtr req,	/* request we're starting from */
    ClientPtr client,	/* client whose requests we're skipping */
    Bool readmore)	/* attempt to read more if next request isn't there? */
{
    register ConnectionInputPtr oci = ((OsCommPtr)client->osPrivate)->input;
    xReqPtr pnextreq;
    int needed, gotnow, reqlen;

    if (!oci) return NULL;

    if (!req)
    {
	/* caller wants the request after the one currently being executed */
	pnextreq = (xReqPtr)
	    (((CARD32 *)client->requestBuffer) + client->req_len);
    }
    else
    {
	/* caller wants the request after the one specified by req */
	reqlen = get_req_len(req, client);
#ifdef BIGREQS
	if (!reqlen) reqlen = get_big_req_len(req, client);
#endif
	pnextreq = (xReqPtr)(((char *)req) + (reqlen << 2));
    }

    /* see how much of the next request we have available */

    gotnow = oci->bufcnt - (((char *)pnextreq) - oci->buffer);

    if (gotnow < sizeof(xReq))
	return NULL;

    needed = get_req_len(pnextreq, client) << 2;
#ifdef BIGREQS
    if (!needed)
    {
	/* it's a big request */
	if (gotnow < sizeof(xBigReq))
	    return NULL;
	needed = get_big_req_len(pnextreq, client) << 2;
    }
#endif

    /* if we have less than we need, return NULL */

    return (gotnow < needed) ? NULL : pnextreq;
}

/*****************************************************************
 *  SkipRequests 
 *      lets you skip over some of the requests in a client's
 *      request buffer.  Presumably the caller has used PeekNextRequest
 *      to examine the requests being skipped and has performed whatever 
 *      actions they dictate.
 *
 **********************/

a619 48

static void
SkipRequests(
    xReqPtr req,	/* last request being skipped */
    ClientPtr client,   /* client whose requests we're skipping */
    int numskipped)	/* how many requests we're skipping */
{
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
    register ConnectionInputPtr oci = oc->input;
    int reqlen;

    /* see if anyone wants to snoop the skipped requests */

    if (SkippedRequestsCallback)
    {
	SkippedRequestInfoRec skipinfo;
	skipinfo.req = req;
	skipinfo.client = client;
	skipinfo.numskipped = numskipped;
	CallCallbacks(&SkippedRequestsCallback, &skipinfo);
    }

    /* adjust the sequence number */
    client->sequence += numskipped;

    /* twiddle the oci to skip over the requests */

    reqlen = get_req_len(req, client);
#ifdef BIGREQS
    if (!reqlen) reqlen = get_big_req_len(req, client);
#endif
    reqlen <<= 2;
    oci->bufptr = (char *)req;
    oci->lenLastReq = reqlen;

    /* see if any requests left in the buffer */

    if ( ((char *)req + reqlen) == (oci->buffer + oci->bufcnt) )
    {
	/* no requests; mark input buffer as available and client
	 * as having no input
	 */
	int fd = oc->fd;
	AvailableInput = oc;
	YieldControlNoInput();
    }
}

@


1.1
log
@Initial revision
@
text
@d73 1
a73 1
#if !defined(__UNIXOS2__) && !defined(WIN32)
d93 5
a100 1
#ifndef __UNIXOS2__
a113 3
#else /* __UNIXOS2__  Writing to full pipes may return ENOSPC */
#define ETEST(err) (err == EAGAIN || err == EWOULDBLOCK || err == ENOSPC)
#endif
d115 5
a119 5
Bool CriticalOutputPending;
int timesThisConnection = 0;
ConnectionInputPtr FreeInputs = (ConnectionInputPtr)NULL;
ConnectionOutputPtr FreeOutputs = (ConnectionOutputPtr)NULL;
OsCommPtr AvailableInput = (OsCommPtr)NULL;
d307 2
a308 1
	if (needed > MAXBUFSIZE)
d314 1
d641 1
a641 1
xReqPtr
d703 1
a703 1
void
d1171 1
a1171 1
ConnectionInputPtr
d1192 1
a1192 1
ConnectionOutputPtr
d1200 1
a1200 1
    oco->buf = (unsigned char *) xalloc(BUFSIZE);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d73 1
a73 1
#if !defined(WIN32)
a92 5
static ConnectionInputPtr AllocateInputBuffer(void);
static ConnectionOutputPtr AllocateOutputBuffer(void);
static xReqPtr PeekNextRequest(xReqPtr req, ClientPtr client, Bool readmore);
static void SkipRequests(xReqPtr req, ClientPtr client, int numskipped);

d96 1
d110 3
d114 5
a118 5
static Bool CriticalOutputPending;
static int timesThisConnection = 0;
static ConnectionInputPtr FreeInputs = (ConnectionInputPtr)NULL;
static ConnectionOutputPtr FreeOutputs = (ConnectionOutputPtr)NULL;
static OsCommPtr AvailableInput = (OsCommPtr)NULL;
d306 1
a306 2
#ifdef BIGREQS
	if (needed > maxBigRequestSize << 2)
a311 1
#endif
d638 1
a638 1
static xReqPtr
d700 1
a700 1
static void
d1168 1
a1168 1
static ConnectionInputPtr
d1189 1
a1189 1
static ConnectionOutputPtr
@

