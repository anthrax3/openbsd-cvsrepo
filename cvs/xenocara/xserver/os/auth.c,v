head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.2
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2017.03.01.19.22.36;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	q2mUKFEmFLjxJcEL;

1.9
date	2017.02.28.18.32.53;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	6xpw3GnpAs1ESHxb;

1.8
date	2017.02.28.18.27.40;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	yXk0iA5IXqVhXDK8;

1.7
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.12;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.12;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.11;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Fix arc4random_buf(3) detection. Noticed by Eric Engestrom on
the xorg-devel list. Thanks
@
text
@/*

Copyright 1988, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/*
 * authorization hooks for the server
 * Author:  Keith Packard, MIT X Consortium
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include   <X11/X.h>
#include   <X11/Xauth.h>
#include   "misc.h"
#include   "osdep.h"
#include   "dixstruct.h"
#include   <sys/types.h>
#include   <sys/stat.h>
#ifdef WIN32
#include    <X11/Xw32defs.h>
#endif
#ifdef HAVE_LIBBSD
#include   <bsd/stdlib.h>       /* for arc4random_buf() */
#endif

struct protocol {
    unsigned short name_length;
    const char *name;
    AuthAddCFunc Add;           /* new authorization data */
    AuthCheckFunc Check;        /* verify client authorization data */
    AuthRstCFunc Reset;         /* delete all authorization data entries */
    AuthFromIDFunc FromID;      /* convert ID to cookie */
    AuthRemCFunc Remove;        /* remove a specific cookie */
#ifdef XCSECURITY
    AuthGenCFunc Generate;
#endif
};

static struct protocol protocols[] = {
    {(unsigned short) 18, "MIT-MAGIC-COOKIE-1",
     MitAddCookie, MitCheckCookie, MitResetCookie,
     MitFromID, MitRemoveCookie,
#ifdef XCSECURITY
     MitGenerateCookie
#endif
     },
#ifdef HASXDMAUTH
    {(unsigned short) 19, "XDM-AUTHORIZATION-1",
     XdmAddCookie, XdmCheckCookie, XdmResetCookie,
     XdmFromID, XdmRemoveCookie,
#ifdef XCSECURITY
     NULL
#endif
     },
#endif
#ifdef SECURE_RPC
    {(unsigned short) 9, "SUN-DES-1",
     SecureRPCAdd, SecureRPCCheck, SecureRPCReset,
     SecureRPCFromID, SecureRPCRemove,
#ifdef XCSECURITY
     NULL
#endif
     },
#endif
};

#define NUM_AUTHORIZATION  (sizeof (protocols) /\
			     sizeof (struct protocol))

/*
 * Initialize all classes of authorization by reading the
 * specified authorization file
 */

static const char *authorization_file = NULL;

static Bool ShouldLoadAuth = TRUE;

void
InitAuthorization(const char *file_name)
{
    authorization_file = file_name;
}

static int
LoadAuthorization(void)
{
    FILE *f;
    Xauth *auth;
    int i;
    int count = 0;

    ShouldLoadAuth = FALSE;
    if (!authorization_file)
        return 0;

    f = Fopen(authorization_file, "r");
    if (!f)
        return -1;

    while ((auth = XauReadAuth(f)) != 0) {
        for (i = 0; i < NUM_AUTHORIZATION; i++) {
            if (protocols[i].name_length == auth->name_length &&
                memcmp(protocols[i].name, auth->name,
                       (int) auth->name_length) == 0 && protocols[i].Add) {
                ++count;
                (*protocols[i].Add) (auth->data_length, auth->data,
                                     FakeClientID(0));
            }
        }
        XauDisposeAuth(auth);
    }

    Fclose(f);
    return count;
}

#ifdef XDMCP
/*
 * XdmcpInit calls this function to discover all authorization
 * schemes supported by the display
 */
void
RegisterAuthorizations(void)
{
    int i;

    for (i = 0; i < NUM_AUTHORIZATION; i++)
        XdmcpRegisterAuthorization(protocols[i].name,
                                   (int) protocols[i].name_length);
}
#endif

XID
CheckAuthorization(unsigned int name_length,
                   const char *name,
                   unsigned int data_length,
                   const char *data, ClientPtr client, const char **reason)
{                               /* failure message.  NULL for default msg */
    int i;
    struct stat buf;
    static time_t lastmod = 0;
    static Bool loaded = FALSE;

    if (!authorization_file || stat(authorization_file, &buf)) {
        if (lastmod != 0) {
            lastmod = 0;
            ShouldLoadAuth = TRUE;      /* stat lost, so force reload */
        }
    }
    else if (buf.st_mtime > lastmod) {
        lastmod = buf.st_mtime;
        ShouldLoadAuth = TRUE;
    }
    if (ShouldLoadAuth) {
        int loadauth = LoadAuthorization();

        /*
         * If the authorization file has at least one entry for this server,
         * disable local access. (loadauth > 0)
         *
         * If there are zero entries (either initially or when the
         * authorization file is later reloaded), or if a valid
         * authorization file was never loaded, enable local access.
         * (loadauth == 0 || !loaded)
         *
         * If the authorization file was loaded initially (with valid
         * entries for this server), and reloading it later fails, don't
         * change anything. (loadauth == -1 && loaded)
         */

        if (loadauth > 0) {
            DisableLocalAccess(); /* got at least one */
            loaded = TRUE;
        }
        else if (loadauth == 0 || !loaded)
            EnableLocalAccess();
    }
    if (name_length) {
        for (i = 0; i < NUM_AUTHORIZATION; i++) {
            if (protocols[i].name_length == name_length &&
                memcmp(protocols[i].name, name, (int) name_length) == 0) {
                return (*protocols[i].Check) (data_length, data, client,
                                              reason);
            }
            *reason = "Protocol not supported by server\n";
        }
    }
    else
        *reason = "No protocol specified\n";
    return (XID) ~0L;
}

void
ResetAuthorization(void)
{
    int i;

    for (i = 0; i < NUM_AUTHORIZATION; i++)
        if (protocols[i].Reset)
            (*protocols[i].Reset) ();
    ShouldLoadAuth = TRUE;
}

int
AuthorizationFromID(XID id,
                    unsigned short *name_lenp,
                    const char **namep, unsigned short *data_lenp, char **datap)
{
    int i;

    for (i = 0; i < NUM_AUTHORIZATION; i++) {
        if (protocols[i].FromID &&
            (*protocols[i].FromID) (id, data_lenp, datap)) {
            *name_lenp = protocols[i].name_length;
            *namep = protocols[i].name;
            return 1;
        }
    }
    return 0;
}

int
RemoveAuthorization(unsigned short name_length,
                    const char *name,
                    unsigned short data_length, const char *data)
{
    int i;

    for (i = 0; i < NUM_AUTHORIZATION; i++) {
        if (protocols[i].name_length == name_length &&
            memcmp(protocols[i].name, name, (int) name_length) == 0 &&
            protocols[i].Remove) {
            return (*protocols[i].Remove) (data_length, data);
        }
    }
    return 0;
}

int
AddAuthorization(unsigned name_length, const char *name,
                 unsigned data_length, char *data)
{
    int i;

    for (i = 0; i < NUM_AUTHORIZATION; i++) {
        if (protocols[i].name_length == name_length &&
            memcmp(protocols[i].name, name, (int) name_length) == 0 &&
            protocols[i].Add) {
            return (*protocols[i].Add) (data_length, data, FakeClientID(0));
        }
    }
    return 0;
}

#ifdef XCSECURITY

XID
GenerateAuthorization(unsigned name_length,
                      const char *name,
                      unsigned data_length,
                      const char *data,
                      unsigned *data_length_return, char **data_return)
{
    int i;

    for (i = 0; i < NUM_AUTHORIZATION; i++) {
        if (protocols[i].name_length == name_length &&
            memcmp(protocols[i].name, name, (int) name_length) == 0 &&
            protocols[i].Generate) {
            return (*protocols[i].Generate) (data_length, data,
                                             FakeClientID(0),
                                             data_length_return, data_return);
        }
    }
    return -1;
}

void
GenerateRandomData(int len, char *buf)
{
#ifndef HAVE_ARC4RANDOM_BUF
    int fd;

    fd = open("/dev/urandom", O_RDONLY);
    read(fd, buf, len);
    close(fd);
#else
    arc4random_buf(buf, len);
#endif
}

#endif                          /* XCSECURITY */
@


1.9
log
@auth: remove AuthToIDFunc and associated functions. Not used anymore.
And the current code for MitToId has a use-after-free() issue.
Advisory X41-2017-001: Multiple Vulnerabilities in X.Org
@
text
@d308 1
a308 1
#ifndef HAVE_ARC4RANDOMBUF
@


1.8
log
@MFC: Use arc4random_buf(3) if available to generate cookies.
Advisory X41-2017-001: Multiple Vulnerabilities in X.Org.
@
text
@a57 1
    AuthToIDFunc ToID;          /* convert cookie to ID */
d68 1
a68 1
     MitToID, MitFromID, MitRemoveCookie,
d76 1
a76 1
     XdmToID, XdmFromID, XdmRemoveCookie,
d85 1
a85 1
     SecureRPCToID, SecureRPCFromID, SecureRPCRemove,
@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d48 3
d309 1
d315 3
@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d184 1
a184 1
         * disable local host access. (loadauth > 0)
d188 1
a188 1
         * authorization file was never loaded, enable local host access.
d197 1
a197 1
            DisableLocalHost(); /* got at least one */
d201 1
a201 1
            EnableLocalHost();
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d99 1
a99 1
static char *authorization_file = (char *) NULL;
d104 1
a104 1
InitAuthorization(char *file_name)
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d38 7
a44 7
# include   <X11/X.h>
# include   <X11/Xauth.h>
# include   "misc.h"
# include   "osdep.h"
# include   "dixstruct.h"
# include   <sys/types.h>
# include   <sys/stat.h>
d50 8
a57 8
    unsigned short   name_length;
    char    *name;
    AuthAddCFunc	Add;	/* new authorization data */
    AuthCheckFunc	Check;	/* verify client authorization data */
    AuthRstCFunc	Reset;	/* delete all authorization data entries */
    AuthToIDFunc	ToID;	/* convert cookie to ID */
    AuthFromIDFunc	FromID;	/* convert ID to cookie */
    AuthRemCFunc	Remove;	/* remove a specific cookie */
d59 1
a59 1
    AuthGenCFunc	Generate;
d63 4
a66 4
static struct protocol   protocols[] = {
{   (unsigned short) 18,    "MIT-MAGIC-COOKIE-1",
		MitAddCookie,	MitCheckCookie,	MitResetCookie,
		MitToID,	MitFromID,	MitRemoveCookie,
d68 1
a68 1
		MitGenerateCookie
d70 1
a70 1
},
d72 3
a74 3
{   (unsigned short) 19,    "XDM-AUTHORIZATION-1",
		XdmAddCookie,	XdmCheckCookie,	XdmResetCookie,
		XdmToID,	XdmFromID,	XdmRemoveCookie,
d76 1
a76 1
		NULL
d78 1
a78 1
},
d81 3
a83 3
{   (unsigned short) 9,    "SUN-DES-1",
		SecureRPCAdd,	SecureRPCCheck,	SecureRPCReset,
		SecureRPCToID,	SecureRPCFromID,SecureRPCRemove,
d85 1
a85 1
		NULL
d87 1
a87 1
},
d91 1
a91 1
# define NUM_AUTHORIZATION  (sizeof (protocols) /\
d99 1
a99 1
static char *authorization_file = (char *)NULL;
d104 1
a104 1
InitAuthorization (char *file_name)
d110 1
a110 1
LoadAuthorization (void)
d112 4
a115 4
    FILE    *f;
    Xauth   *auth;
    int	    i;
    int	    count = 0;
d119 1
a119 1
	return 0;
d121 1
a121 1
    f = Fopen (authorization_file, "r");
d123 1
a123 1
	return -1;
d125 11
a135 12
    while ((auth = XauReadAuth (f)) != 0) {
	for (i = 0; i < NUM_AUTHORIZATION; i++) {
	    if (protocols[i].name_length == auth->name_length &&
		memcmp (protocols[i].name, auth->name, (int) auth->name_length) == 0 &&
		protocols[i].Add)
	    {
		++count;
		(*protocols[i].Add) (auth->data_length, auth->data,
					 FakeClientID(0));
	    }
	}
	XauDisposeAuth (auth);
d138 1
a138 1
    Fclose (f);
d148 1
a148 1
RegisterAuthorizations (void)
d150 1
a150 1
    int	    i;
d153 2
a154 2
	XdmcpRegisterAuthorization (protocols[i].name,
				    (int)protocols[i].name_length);
d159 6
a164 9
CheckAuthorization (
    unsigned int name_length,
    const char	*name,
    unsigned int data_length,
    const char	*data,
    ClientPtr client,
    char	**reason)	/* failure message.  NULL for default msg */
{
    int	i;
d169 5
a173 6
    if (!authorization_file || stat(authorization_file, &buf))
    {
	if (lastmod != 0) {
	    lastmod = 0;
	    ShouldLoadAuth = TRUE;	/* stat lost, so force reload */
	}
d175 3
a177 4
    else if (buf.st_mtime > lastmod)
    {
	lastmod = buf.st_mtime;
	ShouldLoadAuth = TRUE;
d179 23
a201 25
    if (ShouldLoadAuth)
    {
	int loadauth = LoadAuthorization();

	/*
	 * If the authorization file has at least one entry for this server,
	 * disable local host access. (loadauth > 0)
	 *
	 * If there are zero entries (either initially or when the
	 * authorization file is later reloaded), or if a valid
	 * authorization file was never loaded, enable local host access.
	 * (loadauth == 0 || !loaded)
	 *
	 * If the authorization file was loaded initially (with valid
	 * entries for this server), and reloading it later fails, don't
	 * change anything. (loadauth == -1 && loaded)
	 */
	
	if (loadauth > 0)
	{
	    DisableLocalHost(); /* got at least one */
	    loaded = TRUE;
	}
	else if (loadauth == 0 || !loaded)
	    EnableLocalHost ();
d204 11
a214 9
	for (i = 0; i < NUM_AUTHORIZATION; i++) {
	    if (protocols[i].name_length == name_length &&
		memcmp (protocols[i].name, name, (int) name_length) == 0)
	    {
		return (*protocols[i].Check) (data_length, data, client, reason);
	    }
	    *reason = "Protocol not supported by server\n";
	}
    } else *reason = "No protocol specified\n";
d219 1
a219 1
ResetAuthorization (void)
d221 1
a221 1
    int	i;
d224 2
a225 2
	if (protocols[i].Reset)
	    (*protocols[i].Reset)();
d230 3
a232 6
AuthorizationFromID (
	XID 		id,
	unsigned short	*name_lenp,
	char		**namep,
	unsigned short	*data_lenp,
	char		**datap)
d234 1
a234 1
    int	i;
d237 6
a242 6
	if (protocols[i].FromID &&
	    (*protocols[i].FromID) (id, data_lenp, datap)) {
	    *name_lenp = protocols[i].name_length;
	    *namep = protocols[i].name;
	    return 1;
	}
d248 3
a250 5
RemoveAuthorization (
	unsigned short	name_length,
	const char	*name,
	unsigned short	data_length,
	const char	*data)
d252 1
a252 1
    int	i;
d255 5
a259 6
    	if (protocols[i].name_length == name_length &&
	    memcmp (protocols[i].name, name, (int) name_length) == 0 &&
	    protocols[i].Remove)
    	{
	    return (*protocols[i].Remove) (data_length, data);
    	}
d265 2
a266 2
AddAuthorization (unsigned name_length, const char *name,
		  unsigned data_length, char *data)
d268 1
a268 1
    int	i;
d271 5
a275 6
    	if (protocols[i].name_length == name_length &&
	    memcmp (protocols[i].name, name, (int) name_length) == 0 &&
	    protocols[i].Add)
    	{
	    return (*protocols[i].Add) (data_length, data, FakeClientID(0));
    	}
d283 5
a287 7
GenerateAuthorization(
	unsigned name_length,
	const char	*name,
	unsigned data_length,
	const char	*data,
	unsigned *data_length_return,
	char	**data_return)
d289 1
a289 1
    int	i;
d292 7
a298 7
    	if (protocols[i].name_length == name_length &&
	    memcmp (protocols[i].name, name, (int) name_length) == 0 &&
	    protocols[i].Generate)
    	{
	    return (*protocols[i].Generate) (data_length, data,
			FakeClientID(0), data_length_return, data_return);
    	}
d304 1
a304 1
GenerateRandomData (int len, char *buf)
d313 1
a313 1
#endif /* XCSECURITY */
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d162 1
a162 1
    char	*name,
d164 1
a164 1
    char	*data,
d259 1
a259 1
	char		*name,
d261 1
a261 1
	char		*data)
d277 2
a278 1
AddAuthorization (unsigned name_length, char *name, unsigned data_length, char *data)
d298 1
a298 1
	char	*name,
d300 1
a300 1
	char	*data,
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a316 2
#ifdef HAVE_URANDOM

a325 41

#else /* !HAVE_URANDOM */

/* A random number generator that is more unpredictable
   than that shipped with some systems.
   This code is taken from the C standard. */

static unsigned long int next = 1;

static int
xdm_rand(void)
{
    next = next * 1103515245 + 12345;
    return (unsigned int)(next/65536) % 32768;
}

static void
xdm_srand(unsigned int seed)
{
    next = seed;
}

void
GenerateRandomData (int len, char *buf)
{
    static int seed;
    int value;
    int i;

    seed += GetTimeInMillis();
    xdm_srand (seed);
    for (i = 0; i < len; i++)
    {
	value = xdm_rand ();
	buf[i] ^= (value & 0xff00) >> 8;
    }

    /* XXX add getrusage, popen("ps -ale") */
}

#endif /* HAVE_URANDOM */
@


1.1
log
@Initial revision
@
text
@a37 3
#ifdef K5AUTH
# include   <krb5/krb5.h>
#endif
a44 3
#ifdef XCSECURITY
# include   "securitysrv.h"
#endif
a88 17
#ifdef K5AUTH
{   (unsigned short) 14, "MIT-KERBEROS-5",
		K5Add, K5Check, K5Reset,
		K5ToID, K5FromID, K5Remove,
#ifdef XCSECURITY
		NULL
#endif
},
#endif
#ifdef XCSECURITY
{   (unsigned short) XSecurityAuthorizationNameLen,
	XSecurityAuthorizationName,
		NULL, AuthSecurityCheck, NULL,
		NULL, NULL, NULL,
		NULL
},
#endif
a234 20
XID
AuthorizationToID (
	unsigned short	name_length,
	char		*name,
	unsigned short	data_length,
	char		*data)
{
    int	i;

    for (i = 0; i < NUM_AUTHORIZATION; i++) {
    	if (protocols[i].name_length == name_length &&
	    memcmp (protocols[i].name, name, (int) name_length) == 0 &&
	    protocols[i].ToID)
    	{
	    return (*protocols[i].ToID) (data_length, data);
    	}
    }
    return (XID) ~0L;
}

d317 14
d367 2
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d38 3
d95 9
d256 20
@

