head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.8
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.6
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	7pAEtF6Y5EgemkuY;

1.12
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2013.12.08.10.53.02;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.06;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.12;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.12;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.15;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/*
 * Copyright 1989 Network Computing Devices, Inc., Mountain View, California.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of N.C.D. not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  N.C.D. makes no representations about the
 * suitability of this software for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef WIN32
#include <X11/Xwinsock.h>
#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#endif

#include <X11/Xos.h>

#if !defined(WIN32)
#include <sys/param.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <X11/X.h>
#include <X11/Xmd.h>
#include "misc.h"
#include <X11/Xpoll.h>
#include "osdep.h"
#include "input.h"
#include "dixstruct.h"
#include "opaque.h"
#include "site.h"

#ifdef STREAMSCONN
#include <tiuser.h>
#include <netconfig.h>
#include <netdir.h>
#endif

#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>

#ifdef XDMCP
#undef REQUEST

#ifdef XDMCP_NO_IPV6
#undef IPv6
#endif

#include <X11/Xdmcp.h>

#define X_INCLUDE_NETDB_H
#include <X11/Xos_r.h>

static const char *defaultDisplayClass = COMPILEDDISPLAYCLASS;

static int xdmcpSocket, sessionSocket;
static xdmcp_states state;

#if defined(IPv6) && defined(AF_INET6)
static int xdmcpSocket6;
static struct sockaddr_storage req_sockaddr;
#else
static struct sockaddr_in req_sockaddr;
#endif
static int req_socklen;
static CARD32 SessionID;
static CARD32 timeOutTime;
static int timeOutRtx;
static CARD16 DisplayNumber;
static xdmcp_states XDM_INIT_STATE = XDM_OFF;

#ifdef HASXDMAUTH
static char *xdmAuthCookie;
#endif

static XdmcpBuffer buffer;

#if defined(IPv6) && defined(AF_INET6)

static struct addrinfo *mgrAddr;
static struct addrinfo *mgrAddrFirst;

#define SOCKADDR_TYPE		struct sockaddr_storage
#define SOCKADDR_FAMILY(s)	((struct sockaddr *)&(s))->sa_family

#ifdef BSD44SOCKETS
#define SOCKLEN_FIELD(s)	((struct sockaddr *)&(s))->sa_len
#define SOCKLEN_TYPE 		unsigned char
#else
#define SOCKLEN_TYPE 		unsigned int
#endif

#else

#define SOCKADDR_TYPE		struct sockaddr_in
#define SOCKADDR_FAMILY(s)	(s).sin_family

#ifdef BSD44SOCKETS
#define SOCKLEN_FIELD(s)	(s).sin_len
#define SOCKLEN_TYPE		unsigned char
#else
#define SOCKLEN_TYPE		size_t
#endif

#endif

static SOCKADDR_TYPE ManagerAddress;
static SOCKADDR_TYPE FromAddress;

#ifdef SOCKLEN_FIELD
#define ManagerAddressLen	SOCKLEN_FIELD(ManagerAddress)
#define FromAddressLen		SOCKLEN_FIELD(FromAddress)
#else
static SOCKLEN_TYPE ManagerAddressLen, FromAddressLen;
#endif

#if defined(IPv6) && defined(AF_INET6)
static struct multicastinfo {
    struct multicastinfo *next;
    struct addrinfo *ai;
    int hops;
} *mcastlist;
#endif

static void XdmcpAddHost(const struct sockaddr *from,
                         int fromlen,
                         ARRAY8Ptr AuthenticationName,
                         ARRAY8Ptr hostname, ARRAY8Ptr status);

static void XdmcpSelectHost(const struct sockaddr *host_sockaddr,
                            int host_len, ARRAY8Ptr AuthenticationName);

static void get_xdmcp_sock(void);

static void send_query_msg(void);

static void recv_willing_msg(struct sockaddr    *from,
                             int                fromlen,
                             unsigned           length);

static void send_request_msg(void);

static void recv_accept_msg(unsigned    length);

static void recv_decline_msg(unsigned   length);

static void send_manage_msg(void);

static void recv_refuse_msg(unsigned    length);

static void recv_failed_msg(unsigned    length);

static void send_keepalive_msg(void);

static void recv_alive_msg(unsigned     length );

static void XdmcpFatal(const char       *type,
                       ARRAY8Ptr        status);

static void XdmcpWarning(const char     *str);

static void get_manager_by_name(int     argc,
                                char    **argv,
                                int     i);

static void get_fromaddr_by_name(int    argc,
                                 char   **argv,
                                 int    i);

#if defined(IPv6) && defined(AF_INET6)
static int get_mcast_options(int        argc,
                             char       **argv,
                             int        i);
#endif

static void receive_packet(int socketfd);

static void send_packet(void);

static void timeout(void);

static void XdmcpBlockHandler(void              *data ,
                              struct timeval    **wt,
                              void              *LastSelectMask);

static void XdmcpWakeupHandler(void             *data,
                               int              i,
                               void             *LastSelectMask);

/*
 * Register the Manufacturer display ID
 */

static ARRAY8 ManufacturerDisplayID;

static void
XdmcpRegisterManufacturerDisplayID(const char *name, int length)
{
    int i;

    XdmcpDisposeARRAY8(&ManufacturerDisplayID);
    if (!XdmcpAllocARRAY8(&ManufacturerDisplayID, length))
        return;
    for (i = 0; i < length; i++)
        ManufacturerDisplayID.data[i] = (CARD8) name[i];
}

static unsigned short xdm_udp_port = XDM_UDP_PORT;
static Bool OneSession = FALSE;
static const char *xdm_from = NULL;

void
XdmcpUseMsg(void)
{
    ErrorF("-query host-name       contact named host for XDMCP\n");
    ErrorF("-broadcast             broadcast for XDMCP\n");
#if defined(IPv6) && defined(AF_INET6)
    ErrorF("-multicast [addr [hops]] IPv6 multicast for XDMCP\n");
#endif
    ErrorF("-indirect host-name    contact named host for indirect XDMCP\n");
    ErrorF("-port port-num         UDP port number to send messages to\n");
    ErrorF
        ("-from local-address    specify the local address to connect from\n");
    ErrorF("-once                  Terminate server after one session\n");
    ErrorF("-class display-class   specify display class to send in manage\n");
#ifdef HASXDMAUTH
    ErrorF("-cookie xdm-auth-bits  specify the magic cookie for XDMCP\n");
#endif
    ErrorF("-displayID display-id  manufacturer display ID for request\n");
}

static void
XdmcpDefaultListen(void)
{
    /* Even when configured --disable-listen-tcp, we should listen on tcp in
       XDMCP modes */
    _XSERVTransListen("tcp");
}

int
XdmcpOptions(int argc, char **argv, int i)
{
    if (strcmp(argv[i], "-query") == 0) {
        get_manager_by_name(argc, argv, i++);
        XDM_INIT_STATE = XDM_QUERY;
        AccessUsingXdmcp();
        XdmcpDefaultListen();
        return i + 1;
    }
    if (strcmp(argv[i], "-broadcast") == 0) {
        XDM_INIT_STATE = XDM_BROADCAST;
        AccessUsingXdmcp();
        XdmcpDefaultListen();
        return i + 1;
    }
#if defined(IPv6) && defined(AF_INET6)
    if (strcmp(argv[i], "-multicast") == 0) {
        i = get_mcast_options(argc, argv, ++i);
        XDM_INIT_STATE = XDM_MULTICAST;
        AccessUsingXdmcp();
        XdmcpDefaultListen();
        return i + 1;
    }
#endif
    if (strcmp(argv[i], "-indirect") == 0) {
        get_manager_by_name(argc, argv, i++);
        XDM_INIT_STATE = XDM_INDIRECT;
        AccessUsingXdmcp();
        XdmcpDefaultListen();
        return i + 1;
    }
    if (strcmp(argv[i], "-port") == 0) {
        if (++i == argc) {
            FatalError("Xserver: missing port number in command line\n");
        }
        xdm_udp_port = (unsigned short) atoi(argv[i]);
        return i + 1;
    }
    if (strcmp(argv[i], "-from") == 0) {
        get_fromaddr_by_name(argc, argv, ++i);
        return i + 1;
    }
    if (strcmp(argv[i], "-once") == 0) {
        OneSession = TRUE;
        return i + 1;
    }
    if (strcmp(argv[i], "-class") == 0) {
        if (++i == argc) {
            FatalError("Xserver: missing class name in command line\n");
        }
        defaultDisplayClass = argv[i];
        return i + 1;
    }
#ifdef HASXDMAUTH
    if (strcmp(argv[i], "-cookie") == 0) {
        if (++i == argc) {
            FatalError("Xserver: missing cookie data in command line\n");
        }
        xdmAuthCookie = argv[i];
        return i + 1;
    }
#endif
    if (strcmp(argv[i], "-displayID") == 0) {
        if (++i == argc) {
            FatalError("Xserver: missing displayID in command line\n");
        }
        XdmcpRegisterManufacturerDisplayID(argv[i], strlen(argv[i]));
        return i + 1;
    }
    return i;
}

/*
 * This section is a collection of routines for
 * registering server-specific data with the XDMCP
 * state machine.
 */

/*
 * Save all broadcast addresses away so BroadcastQuery
 * packets get sent everywhere
 */

#define MAX_BROADCAST	10

/* This stays sockaddr_in since IPv6 doesn't support broadcast */
static struct sockaddr_in BroadcastAddresses[MAX_BROADCAST];
static int NumBroadcastAddresses;

void
XdmcpRegisterBroadcastAddress(const struct sockaddr_in *addr)
{
    struct sockaddr_in *bcast;

    if (NumBroadcastAddresses >= MAX_BROADCAST)
        return;
    bcast = &BroadcastAddresses[NumBroadcastAddresses++];
    memset(bcast, 0, sizeof(struct sockaddr_in));
#ifdef BSD44SOCKETS
    bcast->sin_len = addr->sin_len;
#endif
    bcast->sin_family = addr->sin_family;
    bcast->sin_port = htons(xdm_udp_port);
    bcast->sin_addr = addr->sin_addr;
}

/*
 * Each authentication type is registered here; Validator
 * will be called to check all access attempts using
 * the specified authentication type
 */

static ARRAYofARRAY8 AuthenticationNames, AuthenticationDatas;
typedef struct _AuthenticationFuncs {
    ValidatorFunc Validator;
    GeneratorFunc Generator;
    AddAuthorFunc AddAuth;
} AuthenticationFuncsRec, *AuthenticationFuncsPtr;

static AuthenticationFuncsPtr AuthenticationFuncsList;

void
XdmcpRegisterAuthentication(const char *name,
                            int namelen,
                            const char *data,
                            int datalen,
                            ValidatorFunc Validator,
                            GeneratorFunc Generator, AddAuthorFunc AddAuth)
{
    int i;
    ARRAY8 AuthenticationName, AuthenticationData;
    static AuthenticationFuncsPtr newFuncs;

    if (!XdmcpAllocARRAY8(&AuthenticationName, namelen))
        return;
    if (!XdmcpAllocARRAY8(&AuthenticationData, datalen)) {
        XdmcpDisposeARRAY8(&AuthenticationName);
        return;
    }
    for (i = 0; i < namelen; i++)
        AuthenticationName.data[i] = name[i];
    for (i = 0; i < datalen; i++)
        AuthenticationData.data[i] = data[i];
    if (!(XdmcpReallocARRAYofARRAY8(&AuthenticationNames,
                                    AuthenticationNames.length + 1) &&
          XdmcpReallocARRAYofARRAY8(&AuthenticationDatas,
                                    AuthenticationDatas.length + 1) &&
          (newFuncs =
           malloc((AuthenticationNames.length +
                   1) * sizeof(AuthenticationFuncsRec))))) {
        XdmcpDisposeARRAY8(&AuthenticationName);
        XdmcpDisposeARRAY8(&AuthenticationData);
        return;
    }
    for (i = 0; i < AuthenticationNames.length - 1; i++)
        newFuncs[i] = AuthenticationFuncsList[i];
    newFuncs[AuthenticationNames.length - 1].Validator = Validator;
    newFuncs[AuthenticationNames.length - 1].Generator = Generator;
    newFuncs[AuthenticationNames.length - 1].AddAuth = AddAuth;
    free(AuthenticationFuncsList);
    AuthenticationFuncsList = newFuncs;
    AuthenticationNames.data[AuthenticationNames.length - 1] =
        AuthenticationName;
    AuthenticationDatas.data[AuthenticationDatas.length - 1] =
        AuthenticationData;
}

/*
 * Select the authentication type to be used; this is
 * set by the manager of the host to be connected to.
 */

static ARRAY8 noAuthenticationName = { (CARD16) 0, (CARD8Ptr) 0 };
static ARRAY8 noAuthenticationData = { (CARD16) 0, (CARD8Ptr) 0 };

static ARRAY8Ptr AuthenticationName = &noAuthenticationName;
static ARRAY8Ptr AuthenticationData = &noAuthenticationData;
static AuthenticationFuncsPtr AuthenticationFuncs;

static void
XdmcpSetAuthentication(const ARRAY8Ptr name)
{
    int i;

    for (i = 0; i < AuthenticationNames.length; i++)
        if (XdmcpARRAY8Equal(&AuthenticationNames.data[i], name)) {
            AuthenticationName = &AuthenticationNames.data[i];
            AuthenticationData = &AuthenticationDatas.data[i];
            AuthenticationFuncs = &AuthenticationFuncsList[i];
            break;
        }
}

/*
 * Register the host address for the display
 */

static ARRAY16 ConnectionTypes;
static ARRAYofARRAY8 ConnectionAddresses;
static long xdmcpGeneration;

void
XdmcpRegisterConnection(int type, const char *address, int addrlen)
{
    int i;
    CARD8 *newAddress;

    if (xdmcpGeneration != serverGeneration) {
        XdmcpDisposeARRAY16(&ConnectionTypes);
        XdmcpDisposeARRAYofARRAY8(&ConnectionAddresses);
        xdmcpGeneration = serverGeneration;
    }
    if (xdm_from != NULL) {     /* Only register the requested address */
        const void *regAddr = address;
        const void *fromAddr = NULL;
        int regAddrlen = addrlen;

        if (addrlen == sizeof(struct in_addr)) {
            if (SOCKADDR_FAMILY(FromAddress) == AF_INET) {
                fromAddr = &((struct sockaddr_in *) &FromAddress)->sin_addr;
            }
#if defined(IPv6) && defined(AF_INET6)
            else if ((SOCKADDR_FAMILY(FromAddress) == AF_INET6) &&
                     IN6_IS_ADDR_V4MAPPED(&
                                          ((struct sockaddr_in6 *)
                                           &FromAddress)->sin6_addr)) {
                fromAddr =
                    &((struct sockaddr_in6 *) &FromAddress)->sin6_addr.
                    s6_addr[12];
            }
#endif
        }
#if defined(IPv6) && defined(AF_INET6)
        else if (addrlen == sizeof(struct in6_addr)) {
            if (SOCKADDR_FAMILY(FromAddress) == AF_INET6) {
                fromAddr = &((struct sockaddr_in6 *) &FromAddress)->sin6_addr;
            }
            else if ((SOCKADDR_FAMILY(FromAddress) == AF_INET) &&
                     IN6_IS_ADDR_V4MAPPED((const struct in6_addr *) address)) {
                fromAddr = &((struct sockaddr_in *) &FromAddress)->sin_addr;
                regAddr =
                    &((struct sockaddr_in6 *) &address)->sin6_addr.s6_addr[12];
                regAddrlen = sizeof(struct in_addr);
            }
        }
#endif
        if (!fromAddr || memcmp(regAddr, fromAddr, regAddrlen) != 0) {
            return;
        }
    }
    if (ConnectionAddresses.length + 1 == 256)
        return;
    newAddress = malloc(addrlen * sizeof(CARD8));
    if (!newAddress)
        return;
    if (!XdmcpReallocARRAY16(&ConnectionTypes, ConnectionTypes.length + 1)) {
        free(newAddress);
        return;
    }
    if (!XdmcpReallocARRAYofARRAY8(&ConnectionAddresses,
                                   ConnectionAddresses.length + 1)) {
        free(newAddress);
        return;
    }
    ConnectionTypes.data[ConnectionTypes.length - 1] = (CARD16) type;
    for (i = 0; i < addrlen; i++)
        newAddress[i] = address[i];
    ConnectionAddresses.data[ConnectionAddresses.length - 1].data = newAddress;
    ConnectionAddresses.data[ConnectionAddresses.length - 1].length = addrlen;
}

/*
 * Register an Authorization Name.  XDMCP advertises this list
 * to the manager.
 */

static ARRAYofARRAY8 AuthorizationNames;

void
XdmcpRegisterAuthorizations(void)
{
    XdmcpDisposeARRAYofARRAY8(&AuthorizationNames);
    RegisterAuthorizations();
}

void
XdmcpRegisterAuthorization(const char *name, int namelen)
{
    ARRAY8 authName;
    int i;

    authName.data = malloc(namelen * sizeof(CARD8));
    if (!authName.data)
        return;
    if (!XdmcpReallocARRAYofARRAY8
        (&AuthorizationNames, AuthorizationNames.length + 1)) {
        free(authName.data);
        return;
    }
    for (i = 0; i < namelen; i++)
        authName.data[i] = (CARD8) name[i];
    authName.length = namelen;
    AuthorizationNames.data[AuthorizationNames.length - 1] = authName;
}

/*
 * Register the DisplayClass string
 */

static ARRAY8 DisplayClass;

static void
XdmcpRegisterDisplayClass(const char *name, int length)
{
    int i;

    XdmcpDisposeARRAY8(&DisplayClass);
    if (!XdmcpAllocARRAY8(&DisplayClass, length))
        return;
    for (i = 0; i < length; i++)
        DisplayClass.data[i] = (CARD8) name[i];
}

/*
 * initialize XDMCP; create the socket, compute the display
 * number, set up the state machine
 */

void
XdmcpInit(void)
{
    state = XDM_INIT_STATE;
#ifdef HASXDMAUTH
    if (xdmAuthCookie)
        XdmAuthenticationInit(xdmAuthCookie, strlen(xdmAuthCookie));
#endif
    if (state != XDM_OFF) {
        XdmcpRegisterAuthorizations();
        XdmcpRegisterDisplayClass(defaultDisplayClass,
                                  strlen(defaultDisplayClass));
        AccessUsingXdmcp();
        RegisterBlockAndWakeupHandlers(XdmcpBlockHandler, XdmcpWakeupHandler,
                                       (void *) 0);
        timeOutRtx = 0;
        DisplayNumber = (CARD16) atoi(display);
        get_xdmcp_sock();
        send_packet();
    }
}

void
XdmcpReset(void)
{
    state = XDM_INIT_STATE;
    if (state != XDM_OFF) {
        RegisterBlockAndWakeupHandlers(XdmcpBlockHandler, XdmcpWakeupHandler,
                                       (void *) 0);
        timeOutRtx = 0;
        send_packet();
    }
}

/*
 * Called whenever a new connection is created; notices the
 * first connection and saves it to terminate the session
 * when it is closed
 */

void
XdmcpOpenDisplay(int sock)
{
    if (state != XDM_AWAIT_MANAGE_RESPONSE)
        return;
    state = XDM_RUN_SESSION;
    timeOutTime = GetTimeInMillis() + XDM_DEF_DORMANCY * 1000;
    sessionSocket = sock;
}

void
XdmcpCloseDisplay(int sock)
{
    if ((state != XDM_RUN_SESSION && state != XDM_AWAIT_ALIVE_RESPONSE)
        || sessionSocket != sock)
        return;
    state = XDM_INIT_STATE;
    if (OneSession)
        dispatchException |= DE_TERMINATE;
    else
        dispatchException |= DE_RESET;
    isItTimeToYield = TRUE;
}

/*
 * called before going to sleep, this routine
 * may modify the timeout value about to be sent
 * to select; in this way XDMCP can do appropriate things
 * dynamically while starting up
 */

 /*ARGSUSED*/ static void
XdmcpBlockHandler(void *data, /* unused */
                  struct timeval **wt, void *pReadmask)
{
    fd_set *last_select_mask = (fd_set *) pReadmask;
    CARD32 millisToGo;

    if (state == XDM_OFF)
        return;
    FD_SET(xdmcpSocket, last_select_mask);
#if defined(IPv6) && defined(AF_INET6)
    if (xdmcpSocket6 >= 0)
        FD_SET(xdmcpSocket6, last_select_mask);
#endif
    if (timeOutTime == 0)
        return;
    millisToGo = timeOutTime - GetTimeInMillis();
    if ((int) millisToGo < 0)
        millisToGo = 0;
    AdjustWaitForDelay(wt, millisToGo);
}

/*
 * called after select returns; this routine will
 * recognise when XDMCP packets await and
 * process them appropriately
 */

 /*ARGSUSED*/ static void
XdmcpWakeupHandler(void *data,        /* unused */
                   int i, void *pReadmask)
{
    fd_set *last_select_mask = (fd_set *) pReadmask;

    if (state == XDM_OFF)
        return;
    if (i > 0) {
        if (FD_ISSET(xdmcpSocket, last_select_mask)) {
            receive_packet(xdmcpSocket);
            FD_CLR(xdmcpSocket, last_select_mask);
        }
#if defined(IPv6) && defined(AF_INET6)
        if (xdmcpSocket6 >= 0 && FD_ISSET(xdmcpSocket6, last_select_mask)) {
            receive_packet(xdmcpSocket6);
            FD_CLR(xdmcpSocket6, last_select_mask);
        }
#endif
    }
    else if (timeOutTime && (int) (GetTimeInMillis() - timeOutTime) >= 0) {
        if (state == XDM_RUN_SESSION) {
            state = XDM_KEEPALIVE;
            send_packet();
        }
        else
            timeout();
    }
}

/*
 * This routine should be called from the routine that drives the
 * user's host menu when the user selects a host
 */

static void
XdmcpSelectHost(const struct sockaddr *host_sockaddr,
                int host_len, ARRAY8Ptr auth_name)
{
    state = XDM_START_CONNECTION;
    memmove(&req_sockaddr, host_sockaddr, host_len);
    req_socklen = host_len;
    XdmcpSetAuthentication(auth_name);
    send_packet();
}

/*
 * !!! this routine should be replaced by a routine that adds
 * the host to the user's host menu. the current version just
 * selects the first host to respond with willing message.
 */

 /*ARGSUSED*/ static void
XdmcpAddHost(const struct sockaddr *from,
             int fromlen,
             ARRAY8Ptr auth_name, ARRAY8Ptr hostname, ARRAY8Ptr status)
{
    XdmcpSelectHost(from, fromlen, auth_name);
}

/*
 * A message is queued on the socket; read it and
 * do the appropriate thing
 */

static ARRAY8 UnwillingMessage = { (CARD8) 14, (CARD8 *) "Host unwilling" };

static void
receive_packet(int socketfd)
{
#if defined(IPv6) && defined(AF_INET6)
    struct sockaddr_storage from;
#else
    struct sockaddr_in from;
#endif
    int fromlen = sizeof(from);
    XdmcpHeader header;

    /* read message off socket */
    if (!XdmcpFill(socketfd, &buffer, (XdmcpNetaddr) &from, &fromlen))
        return;

    /* reset retransmission backoff */
    timeOutRtx = 0;

    if (!XdmcpReadHeader(&buffer, &header))
        return;

    if (header.version != XDM_PROTOCOL_VERSION)
        return;

    switch (header.opcode) {
    case WILLING:
        recv_willing_msg((struct sockaddr *) &from, fromlen, header.length);
        break;
    case UNWILLING:
        XdmcpFatal("Manager unwilling", &UnwillingMessage);
        break;
    case ACCEPT:
        recv_accept_msg(header.length);
        break;
    case DECLINE:
        recv_decline_msg(header.length);
        break;
    case REFUSE:
        recv_refuse_msg(header.length);
        break;
    case FAILED:
        recv_failed_msg(header.length);
        break;
    case ALIVE:
        recv_alive_msg(header.length);
        break;
    }
}

/*
 * send the appropriate message given the current state
 */

static void
send_packet(void)
{
    int rtx;

    switch (state) {
    case XDM_QUERY:
    case XDM_BROADCAST:
    case XDM_INDIRECT:
#if defined(IPv6)  && defined(AF_INET6)
    case XDM_MULTICAST:
#endif
        send_query_msg();
        break;
    case XDM_START_CONNECTION:
        send_request_msg();
        break;
    case XDM_MANAGE:
        send_manage_msg();
        break;
    case XDM_KEEPALIVE:
        send_keepalive_msg();
        break;
    default:
        break;
    }
    rtx = (XDM_MIN_RTX << timeOutRtx);
    if (rtx > XDM_MAX_RTX)
        rtx = XDM_MAX_RTX;
    timeOutTime = GetTimeInMillis() + rtx * 1000;
}

/*
 * The session is declared dead for some reason; too many
 * timeouts, or Keepalive failure.
 */

static void
XdmcpDeadSession(const char *reason)
{
    ErrorF("XDM: %s, declaring session dead\n", reason);
    state = XDM_INIT_STATE;
    isItTimeToYield = TRUE;
    dispatchException |= DE_RESET;
    timeOutTime = 0;
    timeOutRtx = 0;
    send_packet();
}

/*
 * Timeout waiting for an XDMCP response.
 */

static void
timeout(void)
{
    timeOutRtx++;
    if (state == XDM_AWAIT_ALIVE_RESPONSE && timeOutRtx >= XDM_KA_RTX_LIMIT) {
        XdmcpDeadSession("too many keepalive retransmissions");
        return;
    }
    else if (timeOutRtx >= XDM_RTX_LIMIT) {
        /* Quit if "-once" specified, otherwise reset and try again. */
        if (OneSession) {
            dispatchException |= DE_TERMINATE;
            ErrorF("XDM: too many retransmissions\n");
        }
        else {
            XdmcpDeadSession("too many retransmissions");
        }
        return;
    }

#if defined(IPv6) && defined(AF_INET6)
    if (state == XDM_COLLECT_QUERY || state == XDM_COLLECT_INDIRECT_QUERY) {
        /* Try next address */
        for (mgrAddr = mgrAddr->ai_next;; mgrAddr = mgrAddr->ai_next) {
            if (mgrAddr == NULL) {
                mgrAddr = mgrAddrFirst;
            }
            if (mgrAddr->ai_family == AF_INET || mgrAddr->ai_family == AF_INET6)
                break;
        }
#ifndef SIN6_LEN
        ManagerAddressLen = mgrAddr->ai_addrlen;
#endif
        memcpy(&ManagerAddress, mgrAddr->ai_addr, mgrAddr->ai_addrlen);
    }
#endif

    switch (state) {
    case XDM_COLLECT_QUERY:
        state = XDM_QUERY;
        break;
    case XDM_COLLECT_BROADCAST_QUERY:
        state = XDM_BROADCAST;
        break;
#if defined(IPv6) && defined(AF_INET6)
    case XDM_COLLECT_MULTICAST_QUERY:
        state = XDM_MULTICAST;
        break;
#endif
    case XDM_COLLECT_INDIRECT_QUERY:
        state = XDM_INDIRECT;
        break;
    case XDM_AWAIT_REQUEST_RESPONSE:
        state = XDM_START_CONNECTION;
        break;
    case XDM_AWAIT_MANAGE_RESPONSE:
        state = XDM_MANAGE;
        break;
    case XDM_AWAIT_ALIVE_RESPONSE:
        state = XDM_KEEPALIVE;
        break;
    default:
        break;
    }
    send_packet();
}

static int
XdmcpCheckAuthentication(ARRAY8Ptr Name, ARRAY8Ptr Data, int packet_type)
{
    return (XdmcpARRAY8Equal(Name, AuthenticationName) &&
            (AuthenticationName->length == 0 ||
             (*AuthenticationFuncs->Validator) (AuthenticationData, Data,
                                                packet_type)));
}

static int
XdmcpAddAuthorization(ARRAY8Ptr name, ARRAY8Ptr data)
{
    AddAuthorFunc AddAuth;

    if (AuthenticationFuncs && AuthenticationFuncs->AddAuth)
        AddAuth = AuthenticationFuncs->AddAuth;
    else
        AddAuth = AddAuthorization;
    return (*AddAuth) ((unsigned short) name->length,
                       (char *) name->data,
                       (unsigned short) data->length, (char *) data->data);
}

/*
 * from here to the end of this file are routines private
 * to the state machine.
 */

static void
get_xdmcp_sock(void)
{
#ifdef STREAMSCONN
    struct netconfig *nconf;

    if ((xdmcpSocket = t_open("/dev/udp", O_RDWR, 0)) < 0) {
        XdmcpWarning("t_open() of /dev/udp failed");
        return;
    }

    if (t_bind(xdmcpSocket, NULL, NULL) < 0) {
        XdmcpWarning("UDP socket creation failed");
        t_error("t_bind(xdmcpSocket) failed");
        t_close(xdmcpSocket);
        return;
    }

    /*
     * This part of the code looks contrived. It will actually fit in nicely
     * when the CLTS part of Xtrans is implemented.
     */

    if ((nconf = getnetconfigent("udp")) == NULL) {
        XdmcpWarning("UDP socket creation failed: getnetconfigent()");
        t_unbind(xdmcpSocket);
        t_close(xdmcpSocket);
        return;
    }

    if (netdir_options(nconf, ND_SET_BROADCAST, xdmcpSocket, NULL)) {
        XdmcpWarning("UDP set broadcast option failed: netdir_options()");
        freenetconfigent(nconf);
        t_unbind(xdmcpSocket);
        t_close(xdmcpSocket);
        return;
    }

    freenetconfigent(nconf);
#else
    int soopts = 1;

#if defined(IPv6) && defined(AF_INET6)
    if ((xdmcpSocket6 = socket(AF_INET6, SOCK_DGRAM, 0)) < 0)
        XdmcpWarning("INET6 UDP socket creation failed");
#endif
    if ((xdmcpSocket = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
        XdmcpWarning("UDP socket creation failed");
#ifdef SO_BROADCAST
    else if (setsockopt(xdmcpSocket, SOL_SOCKET, SO_BROADCAST, (char *) &soopts,
                        sizeof(soopts)) < 0)
        XdmcpWarning("UDP set broadcast socket-option failed");
#endif                          /* SO_BROADCAST */
    if (xdmcpSocket >= 0 && xdm_from != NULL) {
        if (bind(xdmcpSocket, (struct sockaddr *) &FromAddress,
                 FromAddressLen) < 0) {
            FatalError("Xserver: failed to bind to -from address: %s\n",
                       xdm_from);
        }
    }
#endif                          /* STREAMSCONN */
}

static void
send_query_msg(void)
{
    XdmcpHeader header;
    Bool broadcast = FALSE;

#if defined(IPv6) && defined(AF_INET6)
    Bool multicast = FALSE;
#endif
    int i;
    int socketfd = xdmcpSocket;

    header.version = XDM_PROTOCOL_VERSION;
    switch (state) {
    case XDM_QUERY:
        header.opcode = (CARD16) QUERY;
        state = XDM_COLLECT_QUERY;
        break;
    case XDM_BROADCAST:
        header.opcode = (CARD16) BROADCAST_QUERY;
        state = XDM_COLLECT_BROADCAST_QUERY;
        broadcast = TRUE;
        break;
#if defined(IPv6) && defined(AF_INET6)
    case XDM_MULTICAST:
        header.opcode = (CARD16) BROADCAST_QUERY;
        state = XDM_COLLECT_MULTICAST_QUERY;
        multicast = TRUE;
        break;
#endif
    case XDM_INDIRECT:
        header.opcode = (CARD16) INDIRECT_QUERY;
        state = XDM_COLLECT_INDIRECT_QUERY;
        break;
    default:
        break;
    }
    header.length = 1;
    for (i = 0; i < AuthenticationNames.length; i++)
        header.length += 2 + AuthenticationNames.data[i].length;

    XdmcpWriteHeader(&buffer, &header);
    XdmcpWriteARRAYofARRAY8(&buffer, &AuthenticationNames);
    if (broadcast) {
        for (i = 0; i < NumBroadcastAddresses; i++)
            XdmcpFlush(xdmcpSocket, &buffer,
                       (XdmcpNetaddr) &BroadcastAddresses[i],
                       sizeof(struct sockaddr_in));
    }
#if defined(IPv6) && defined(AF_INET6)
    else if (multicast) {
        struct multicastinfo *mcl;
        struct addrinfo *ai;

        for (mcl = mcastlist; mcl != NULL; mcl = mcl->next) {
            for (ai = mcl->ai; ai != NULL; ai = ai->ai_next) {
                if (ai->ai_family == AF_INET) {
                    unsigned char hopflag = (unsigned char) mcl->hops;

                    socketfd = xdmcpSocket;
                    setsockopt(socketfd, IPPROTO_IP, IP_MULTICAST_TTL,
                               &hopflag, sizeof(hopflag));
                }
                else if (ai->ai_family == AF_INET6) {
                    int hopflag6 = mcl->hops;

                    socketfd = xdmcpSocket6;
                    setsockopt(socketfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
                               &hopflag6, sizeof(hopflag6));
                }
                else {
                    continue;
                }
                XdmcpFlush(socketfd, &buffer,
                           (XdmcpNetaddr) ai->ai_addr, ai->ai_addrlen);
                break;
            }
        }
    }
#endif
    else {
#if defined(IPv6) && defined(AF_INET6)
        if (SOCKADDR_FAMILY(ManagerAddress) == AF_INET6)
            socketfd = xdmcpSocket6;
#endif
        XdmcpFlush(socketfd, &buffer, (XdmcpNetaddr) &ManagerAddress,
                   ManagerAddressLen);
    }
}

static void
recv_willing_msg(struct sockaddr *from, int fromlen, unsigned length)
{
    ARRAY8 authenticationName;
    ARRAY8 hostname;
    ARRAY8 status;

    authenticationName.data = 0;
    hostname.data = 0;
    status.data = 0;
    if (XdmcpReadARRAY8(&buffer, &authenticationName) &&
        XdmcpReadARRAY8(&buffer, &hostname) &&
        XdmcpReadARRAY8(&buffer, &status)) {
        if (length == 6 + authenticationName.length +
            hostname.length + status.length) {
            switch (state) {
            case XDM_COLLECT_QUERY:
                XdmcpSelectHost(from, fromlen, &authenticationName);
                break;
            case XDM_COLLECT_BROADCAST_QUERY:
#if defined(IPv6) && defined(AF_INET6)
            case XDM_COLLECT_MULTICAST_QUERY:
#endif
            case XDM_COLLECT_INDIRECT_QUERY:
                XdmcpAddHost(from, fromlen, &authenticationName, &hostname,
                             &status);
                break;
            default:
                break;
            }
        }
    }
    XdmcpDisposeARRAY8(&authenticationName);
    XdmcpDisposeARRAY8(&hostname);
    XdmcpDisposeARRAY8(&status);
}

static void
send_request_msg(void)
{
    XdmcpHeader header;
    int length;
    int i;
    CARD16 XdmcpConnectionType;
    ARRAY8 authenticationData;
    int socketfd = xdmcpSocket;

    switch (SOCKADDR_FAMILY(ManagerAddress)) {
    case AF_INET:
        XdmcpConnectionType = FamilyInternet;
        break;
#if defined(IPv6) && defined(AF_INET6)
    case AF_INET6:
        XdmcpConnectionType = FamilyInternet6;
        break;
#endif
    default:
        XdmcpConnectionType = 0xffff;
        break;
    }

    header.version = XDM_PROTOCOL_VERSION;
    header.opcode = (CARD16) REQUEST;

    length = 2;                 /* display number */
    length += 1 + 2 * ConnectionTypes.length;   /* connection types */
    length += 1;                /* connection addresses */
    for (i = 0; i < ConnectionAddresses.length; i++)
        length += 2 + ConnectionAddresses.data[i].length;
    authenticationData.length = 0;
    authenticationData.data = 0;
    if (AuthenticationFuncs) {
        (*AuthenticationFuncs->Generator) (AuthenticationData,
                                           &authenticationData, REQUEST);
    }
    length += 2 + AuthenticationName->length;   /* authentication name */
    length += 2 + authenticationData.length;    /* authentication data */
    length += 1;                /* authorization names */
    for (i = 0; i < AuthorizationNames.length; i++)
        length += 2 + AuthorizationNames.data[i].length;
    length += 2 + ManufacturerDisplayID.length; /* display ID */
    header.length = length;

    if (!XdmcpWriteHeader(&buffer, &header)) {
        XdmcpDisposeARRAY8(&authenticationData);
        return;
    }
    XdmcpWriteCARD16(&buffer, DisplayNumber);
    XdmcpWriteCARD8(&buffer, ConnectionTypes.length);

    /* The connection array is send reordered, so that connections of   */
    /* the same address type as the XDMCP manager connection are send   */
    /* first. This works around a bug in xdm. mario@@klebsch.de          */
    for (i = 0; i < (int) ConnectionTypes.length; i++)
        if (ConnectionTypes.data[i] == XdmcpConnectionType)
            XdmcpWriteCARD16(&buffer, ConnectionTypes.data[i]);
    for (i = 0; i < (int) ConnectionTypes.length; i++)
        if (ConnectionTypes.data[i] != XdmcpConnectionType)
            XdmcpWriteCARD16(&buffer, ConnectionTypes.data[i]);

    XdmcpWriteCARD8(&buffer, ConnectionAddresses.length);
    for (i = 0; i < (int) ConnectionAddresses.length; i++)
        if ((i < ConnectionTypes.length) &&
            (ConnectionTypes.data[i] == XdmcpConnectionType))
            XdmcpWriteARRAY8(&buffer, &ConnectionAddresses.data[i]);
    for (i = 0; i < (int) ConnectionAddresses.length; i++)
        if ((i >= ConnectionTypes.length) ||
            (ConnectionTypes.data[i] != XdmcpConnectionType))
            XdmcpWriteARRAY8(&buffer, &ConnectionAddresses.data[i]);

    XdmcpWriteARRAY8(&buffer, AuthenticationName);
    XdmcpWriteARRAY8(&buffer, &authenticationData);
    XdmcpDisposeARRAY8(&authenticationData);
    XdmcpWriteARRAYofARRAY8(&buffer, &AuthorizationNames);
    XdmcpWriteARRAY8(&buffer, &ManufacturerDisplayID);
#if defined(IPv6) && defined(AF_INET6)
    if (SOCKADDR_FAMILY(req_sockaddr) == AF_INET6)
        socketfd = xdmcpSocket6;
#endif
    if (XdmcpFlush(socketfd, &buffer,
                   (XdmcpNetaddr) &req_sockaddr, req_socklen))
        state = XDM_AWAIT_REQUEST_RESPONSE;
}

static void
recv_accept_msg(unsigned length)
{
    CARD32 AcceptSessionID;
    ARRAY8 AcceptAuthenticationName, AcceptAuthenticationData;
    ARRAY8 AcceptAuthorizationName, AcceptAuthorizationData;

    if (state != XDM_AWAIT_REQUEST_RESPONSE)
        return;
    AcceptAuthenticationName.data = 0;
    AcceptAuthenticationData.data = 0;
    AcceptAuthorizationName.data = 0;
    AcceptAuthorizationData.data = 0;
    if (XdmcpReadCARD32(&buffer, &AcceptSessionID) &&
        XdmcpReadARRAY8(&buffer, &AcceptAuthenticationName) &&
        XdmcpReadARRAY8(&buffer, &AcceptAuthenticationData) &&
        XdmcpReadARRAY8(&buffer, &AcceptAuthorizationName) &&
        XdmcpReadARRAY8(&buffer, &AcceptAuthorizationData)) {
        if (length == 12 + AcceptAuthenticationName.length +
            AcceptAuthenticationData.length +
            AcceptAuthorizationName.length + AcceptAuthorizationData.length) {
            if (!XdmcpCheckAuthentication(&AcceptAuthenticationName,
                                          &AcceptAuthenticationData, ACCEPT)) {
                XdmcpFatal("Authentication Failure", &AcceptAuthenticationName);
            }
            /* permit access control manipulations from this host */
            AugmentSelf(&req_sockaddr, req_socklen);
            /* if the authorization specified in the packet fails
             * to be acceptable, enable the local addresses
             */
            if (!XdmcpAddAuthorization(&AcceptAuthorizationName,
                                       &AcceptAuthorizationData)) {
                AddLocalHosts();
            }
            SessionID = AcceptSessionID;
            state = XDM_MANAGE;
            send_packet();
        }
    }
    XdmcpDisposeARRAY8(&AcceptAuthenticationName);
    XdmcpDisposeARRAY8(&AcceptAuthenticationData);
    XdmcpDisposeARRAY8(&AcceptAuthorizationName);
    XdmcpDisposeARRAY8(&AcceptAuthorizationData);
}

static void
recv_decline_msg(unsigned length)
{
    ARRAY8 status, DeclineAuthenticationName, DeclineAuthenticationData;

    status.data = 0;
    DeclineAuthenticationName.data = 0;
    DeclineAuthenticationData.data = 0;
    if (XdmcpReadARRAY8(&buffer, &status) &&
        XdmcpReadARRAY8(&buffer, &DeclineAuthenticationName) &&
        XdmcpReadARRAY8(&buffer, &DeclineAuthenticationData)) {
        if (length == 6 + status.length +
            DeclineAuthenticationName.length +
            DeclineAuthenticationData.length &&
            XdmcpCheckAuthentication(&DeclineAuthenticationName,
                                     &DeclineAuthenticationData, DECLINE)) {
            XdmcpFatal("Session declined", &status);
        }
    }
    XdmcpDisposeARRAY8(&status);
    XdmcpDisposeARRAY8(&DeclineAuthenticationName);
    XdmcpDisposeARRAY8(&DeclineAuthenticationData);
}

static void
send_manage_msg(void)
{
    XdmcpHeader header;
    int socketfd = xdmcpSocket;

    header.version = XDM_PROTOCOL_VERSION;
    header.opcode = (CARD16) MANAGE;
    header.length = 8 + DisplayClass.length;

    if (!XdmcpWriteHeader(&buffer, &header))
        return;
    XdmcpWriteCARD32(&buffer, SessionID);
    XdmcpWriteCARD16(&buffer, DisplayNumber);
    XdmcpWriteARRAY8(&buffer, &DisplayClass);
    state = XDM_AWAIT_MANAGE_RESPONSE;
#if defined(IPv6) && defined(AF_INET6)
    if (SOCKADDR_FAMILY(req_sockaddr) == AF_INET6)
        socketfd = xdmcpSocket6;
#endif
    XdmcpFlush(socketfd, &buffer, (XdmcpNetaddr) &req_sockaddr, req_socklen);
}

static void
recv_refuse_msg(unsigned length)
{
    CARD32 RefusedSessionID;

    if (state != XDM_AWAIT_MANAGE_RESPONSE)
        return;
    if (length != 4)
        return;
    if (XdmcpReadCARD32(&buffer, &RefusedSessionID)) {
        if (RefusedSessionID == SessionID) {
            state = XDM_START_CONNECTION;
            send_packet();
        }
    }
}

static void
recv_failed_msg(unsigned length)
{
    CARD32 FailedSessionID;
    ARRAY8 status;

    if (state != XDM_AWAIT_MANAGE_RESPONSE)
        return;
    status.data = 0;
    if (XdmcpReadCARD32(&buffer, &FailedSessionID) &&
        XdmcpReadARRAY8(&buffer, &status)) {
        if (length == 6 + status.length && SessionID == FailedSessionID) {
            XdmcpFatal("Session failed", &status);
        }
    }
    XdmcpDisposeARRAY8(&status);
}

static void
send_keepalive_msg(void)
{
    XdmcpHeader header;
    int socketfd = xdmcpSocket;

    header.version = XDM_PROTOCOL_VERSION;
    header.opcode = (CARD16) KEEPALIVE;
    header.length = 6;

    XdmcpWriteHeader(&buffer, &header);
    XdmcpWriteCARD16(&buffer, DisplayNumber);
    XdmcpWriteCARD32(&buffer, SessionID);

    state = XDM_AWAIT_ALIVE_RESPONSE;
#if defined(IPv6) && defined(AF_INET6)
    if (SOCKADDR_FAMILY(req_sockaddr) == AF_INET6)
        socketfd = xdmcpSocket6;
#endif
    XdmcpFlush(socketfd, &buffer, (XdmcpNetaddr) &req_sockaddr, req_socklen);
}

static void
recv_alive_msg(unsigned length)
{
    CARD8 SessionRunning;
    CARD32 AliveSessionID;

    if (state != XDM_AWAIT_ALIVE_RESPONSE)
        return;
    if (length != 5)
        return;
    if (XdmcpReadCARD8(&buffer, &SessionRunning) &&
        XdmcpReadCARD32(&buffer, &AliveSessionID)) {
        if (SessionRunning && AliveSessionID == SessionID) {
            state = XDM_RUN_SESSION;
            timeOutTime = GetTimeInMillis() + XDM_DEF_DORMANCY * 1000;
        }
        else {
            XdmcpDeadSession("Alive response indicates session dead");
        }
    }
}

_X_NORETURN
static void
XdmcpFatal(const char *type, ARRAY8Ptr status)
{
    FatalError("XDMCP fatal error: %s %*.*s\n", type,
               status->length, status->length, status->data);
}

static void
XdmcpWarning(const char *str)
{
    ErrorF("XDMCP warning: %s\n", str);
}

static void
get_addr_by_name(const char *argtype,
                 const char *namestr,
                 int port,
                 int socktype, SOCKADDR_TYPE * addr, SOCKLEN_TYPE * addrlen
#if defined(IPv6) && defined(AF_INET6)
                 , struct addrinfo **aip, struct addrinfo **aifirstp
#endif
    )
{
#if defined(IPv6) && defined(AF_INET6)
    struct addrinfo *ai;
    struct addrinfo hints;
    char portstr[6];
    char *pport = portstr;
    int gaierr;

    memset(&hints, 0, sizeof(hints));
    hints.ai_socktype = socktype;

    if (port == 0) {
        pport = NULL;
    }
    else if (port > 0 && port < 65535) {
        snprintf(portstr, sizeof(portstr), "%d", port);
    }
    else {
        FatalError("Xserver: port out of range: %d\n", port);
    }

    if (*aifirstp != NULL) {
        freeaddrinfo(*aifirstp);
        *aifirstp = NULL;
    }

    if ((gaierr = getaddrinfo(namestr, pport, &hints, aifirstp)) == 0) {
        for (ai = *aifirstp; ai != NULL; ai = ai->ai_next) {
            if (ai->ai_family == AF_INET || ai->ai_family == AF_INET6)
                break;
        }
        if ((ai == NULL) || (ai->ai_addrlen > sizeof(SOCKADDR_TYPE))) {
            FatalError("Xserver: %s host %s not on supported network type\n",
                       argtype, namestr);
        }
        else {
            *aip = ai;
            *addrlen = ai->ai_addrlen;
            memcpy(addr, ai->ai_addr, ai->ai_addrlen);
        }
    }
    else {
        FatalError("Xserver: %s: %s %s\n", gai_strerror(gaierr), argtype,
                   namestr);
    }
#else
    struct hostent *hep;

#ifdef XTHREADS_NEEDS_BYNAMEPARAMS
    _Xgethostbynameparams hparams;
#endif
#if defined(WIN32) && defined(TCPCONN)
    _XSERVTransWSAStartup();
#endif
    if (!(hep = _XGethostbyname(namestr, hparams))) {
        FatalError("Xserver: %s unknown host: %s\n", argtype, namestr);
    }
    if (hep->h_length == sizeof(struct in_addr)) {
        memmove(&addr->sin_addr, hep->h_addr, hep->h_length);
        *addrlen = sizeof(struct sockaddr_in);
        addr->sin_family = AF_INET;
        addr->sin_port = htons(port);
    }
    else {
        FatalError("Xserver: %s host on strange network %s\n", argtype,
                   namestr);
    }
#endif
}

static void
get_manager_by_name(int argc, char **argv, int i)
{

    if ((i + 1) == argc) {
        FatalError("Xserver: missing %s host name in command line\n", argv[i]);
    }

    get_addr_by_name(argv[i], argv[i + 1], xdm_udp_port, SOCK_DGRAM,
                     &ManagerAddress, &ManagerAddressLen
#if defined(IPv6) && defined(AF_INET6)
                     , &mgrAddr, &mgrAddrFirst
#endif
        );
}

static void
get_fromaddr_by_name(int argc, char **argv, int i)
{
#if defined(IPv6) && defined(AF_INET6)
    struct addrinfo *ai = NULL;
    struct addrinfo *aifirst = NULL;
#endif
    if (i == argc) {
        FatalError("Xserver: missing -from host name in command line\n");
    }
    get_addr_by_name("-from", argv[i], 0, 0, &FromAddress, &FromAddressLen
#if defined(IPv6) && defined(AF_INET6)
                     , &ai, &aifirst
#endif
        );
#if defined(IPv6) && defined(AF_INET6)
    if (aifirst != NULL)
        freeaddrinfo(aifirst);
#endif
    xdm_from = argv[i];
}

#if defined(IPv6) && defined(AF_INET6)
static int
get_mcast_options(int argc, char **argv, int i)
{
    const char *address = XDM_DEFAULT_MCAST_ADDR6;
    int hopcount = 1;
    struct addrinfo hints;
    char portstr[6];
    int gaierr;
    struct addrinfo *ai, *firstai;

    if ((i < argc) && (argv[i][0] != '-') && (argv[i][0] != '+')) {
        address = argv[i++];
        if ((i < argc) && (argv[i][0] != '-') && (argv[i][0] != '+')) {
            hopcount = strtol(argv[i++], NULL, 10);
            if ((hopcount < 1) || (hopcount > 255)) {
                FatalError("Xserver: multicast hop count out of range: %d\n",
                           hopcount);
            }
        }
    }

    if (xdm_udp_port > 0 && xdm_udp_port < 65535) {
        snprintf(portstr, sizeof(portstr), "%d", xdm_udp_port);
    }
    else {
        FatalError("Xserver: port out of range: %d\n", xdm_udp_port);
    }
    memset(&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_DGRAM;

    if ((gaierr = getaddrinfo(address, portstr, &hints, &firstai)) == 0) {
        for (ai = firstai; ai != NULL; ai = ai->ai_next) {
            if (((ai->ai_family == AF_INET) &&
                 IN_MULTICAST(((struct sockaddr_in *) ai->ai_addr)
                              ->sin_addr.s_addr))
                || ((ai->ai_family == AF_INET6) &&
                    IN6_IS_ADDR_MULTICAST(&((struct sockaddr_in6 *) ai->ai_addr)
                                          ->sin6_addr)))
                break;
        }
        if (ai == NULL) {
            FatalError("Xserver: address not supported multicast type %s\n",
                       address);
        }
        else {
            struct multicastinfo *mcastinfo, *mcl;

            mcastinfo = malloc(sizeof(struct multicastinfo));
            mcastinfo->next = NULL;
            mcastinfo->ai = firstai;
            mcastinfo->hops = hopcount;

            if (mcastlist == NULL) {
                mcastlist = mcastinfo;
            }
            else {
                for (mcl = mcastlist; mcl->next != NULL; mcl = mcl->next) {
                    /* Do nothing  - just find end of list */
                }
                mcl->next = mcastinfo;
            }
        }
    }
    else {
        FatalError("Xserver: %s: %s\n", gai_strerror(gaierr), address);
    }
    return i;
}
#endif

#else
static int xdmcp_non_empty;     /* avoid complaint by ranlib */
#endif                          /* XDMCP */
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a86 2
static CARD32 defaultKeepaliveDormancy = XDM_DEF_DORMANCY;
static CARD32 keepaliveDormancy = XDM_DEF_DORMANCY;
a199 2
static void restart(void);

d633 1
a690 1
    fd_set devicesReadable;
a704 9
        XFD_ANDSET(&devicesReadable, last_select_mask, &EnabledDevices);
        if (XFD_ANYSET(&devicesReadable)) {
            if (state == XDM_AWAIT_USER_INPUT)
                restart();
            else if (state == XDM_RUN_SESSION)
                keepaliveDormancy = defaultKeepaliveDormancy;
        }
        if (XFD_ANYSET(&AllClients) && state == XDM_RUN_SESSION)
            timeOutTime = GetTimeInMillis() + keepaliveDormancy * 1000;
a925 8
static void
restart(void)
{
    state = XDM_INIT_STATE;
    timeOutRtx = 0;
    send_packet();
}

a1392 1
            /* backoff dormancy period */
d1394 1
a1394 7
            if ((GetTimeInMillis() - LastEventTime(XIAllDevices).milliseconds) >
                keepaliveDormancy * 1000) {
                keepaliveDormancy <<= 1;
                if (keepaliveDormancy > XDM_MAX_DORMANCY)
                    keepaliveDormancy = XDM_MAX_DORMANCY;
            }
            timeOutTime = GetTimeInMillis() + keepaliveDormancy * 1000;
d1402 1
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d22 4
d55 5
d254 8
d269 1
d275 1
d283 1
d291 1
d586 1
a586 1
/* 
@


1.10
log
@Update to xserver 1.14.4
@
text
@d148 3
a150 3
static void recv_willing_msg(struct sockaddr * /*from */ ,
                             int /*fromlen */ ,
                             unsigned /*length */ );
d154 1
a154 1
static void recv_accept_msg(unsigned /*length */ );
d156 1
a156 1
static void recv_decline_msg(unsigned /*length */ );
d160 1
a160 1
static void recv_refuse_msg(unsigned /*length */ );
d162 1
a162 1
static void recv_failed_msg(unsigned /*length */ );
d166 1
a166 1
static void recv_alive_msg(unsigned /*length */ );
d168 2
a169 2
static void XdmcpFatal(const char * /*type */ ,
                       ARRAY8Ptr /*status */ );
d171 1
a171 1
static void XdmcpWarning(const char * /*str */ );
d173 3
a175 3
static void get_manager_by_name(int /*argc */ ,
                                char ** /*argv */ ,
                                int /*i */ );
d177 3
a179 2
static void get_fromaddr_by_name(int /*argc */ , char ** /*argv */ ,
                                 int /*i */ );
d182 3
a184 1
static int get_mcast_options(int /*argc */ , char ** /*argv */ , int /*i */ );
d187 1
a187 1
static void receive_packet(int /*socketfd */ );
d195 7
a201 7
static void XdmcpBlockHandler(pointer /*data */ ,
                              struct timeval ** /*wt */ ,
                              pointer /*LastSelectMask */ );

static void XdmcpWakeupHandler(pointer /*data */ ,
                               int /*i */ ,
                               pointer /*LastSelectMask */ );
d584 1
a584 1
                                       (pointer) 0);
d598 1
a598 1
                                       (pointer) 0);
d641 2
a642 2
XdmcpBlockHandler(pointer data, /* unused */
                  struct timeval **wt, pointer pReadmask)
d644 1
a644 1
    fd_set *LastSelectMask = (fd_set *) pReadmask;
d649 1
a649 1
    FD_SET(xdmcpSocket, LastSelectMask);
d652 1
a652 1
        FD_SET(xdmcpSocket6, LastSelectMask);
d669 2
a670 2
XdmcpWakeupHandler(pointer data,        /* unused */
                   int i, pointer pReadmask)
d672 1
a672 1
    fd_set *LastSelectMask = (fd_set *) pReadmask;
d678 1
a678 1
        if (FD_ISSET(xdmcpSocket, LastSelectMask)) {
d680 1
a680 1
            FD_CLR(xdmcpSocket, LastSelectMask);
d683 1
a683 1
        if (xdmcpSocket6 >= 0 && FD_ISSET(xdmcpSocket6, LastSelectMask)) {
d685 1
a685 1
            FD_CLR(xdmcpSocket6, LastSelectMask);
d688 1
a688 1
        XFD_ANDSET(&devicesReadable, LastSelectMask, &EnabledDevices);
d715 1
a715 1
                int host_len, ARRAY8Ptr AuthenticationName)
d720 1
a720 1
    XdmcpSetAuthentication(AuthenticationName);
d733 1
a733 1
             ARRAY8Ptr AuthenticationName, ARRAY8Ptr hostname, ARRAY8Ptr status)
d735 1
a735 1
    XdmcpSelectHost(from, fromlen, AuthenticationName);
a1060 2
        int i;

@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d1394 1
a1394 1
            if ((GetTimeInMillis() - lastDeviceEventTime[XIAllDevices].milliseconds) >
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d754 1
a754 1
    if (!XdmcpFill(socketfd, &buffer, (XdmcpNetaddr) & from, &fromlen))
d1062 1
a1062 1
                       (XdmcpNetaddr) & BroadcastAddresses[i],
d1101 1
a1101 1
        XdmcpFlush(socketfd, &buffer, (XdmcpNetaddr) & ManagerAddress,
d1226 1
a1226 1
                   (XdmcpNetaddr) & req_sockaddr, req_socklen))
d1319 1
a1319 1
    XdmcpFlush(socketfd, &buffer, (XdmcpNetaddr) & req_sockaddr, req_socklen);
d1376 1
a1376 1
    XdmcpFlush(socketfd, &buffer, (XdmcpNetaddr) & req_sockaddr, req_socklen);
d1394 1
a1394 1
            if ((GetTimeInMillis() - lastDeviceEventTime.milliseconds) >
@


1.7
log
@Update to xserver 1.11.2
@
text
@d63 4
a66 1
static char *defaultDisplayClass = COMPILEDDISPLAYCLASS;
a67 2
static int		    xdmcpSocket, sessionSocket;
static xdmcp_states	    state;
d69 1
a69 1
static int		    xdmcpSocket6;
d72 1
a72 1
static struct sockaddr_in   req_sockaddr;
d74 9
a82 8
static int		    req_socklen;
static CARD32		    SessionID;
static CARD32		    timeOutTime;
static int		    timeOutRtx;
static CARD32		    defaultKeepaliveDormancy = XDM_DEF_DORMANCY;
static CARD32		    keepaliveDormancy = XDM_DEF_DORMANCY;
static CARD16		    DisplayNumber;
static xdmcp_states	    XDM_INIT_STATE = XDM_OFF;
d84 1
a84 1
static char		    *xdmAuthCookie;
d87 1
a87 1
static XdmcpBuffer	    buffer;
d118 2
a119 2
static SOCKADDR_TYPE		ManagerAddress;
static SOCKADDR_TYPE		FromAddress;
d130 3
a132 3
    struct multicastinfo	*next;
    struct addrinfo		*ai;
    int				 hops;
d136 7
a142 11
static void XdmcpAddHost(
    const struct sockaddr    *from,
    int			fromlen,
    ARRAY8Ptr		AuthenticationName,
    ARRAY8Ptr		hostname,
    ARRAY8Ptr		status);

static void XdmcpSelectHost(
    const struct sockaddr *host_sockaddr,
    int			host_len,
    ARRAY8Ptr		AuthenticationName);
d148 3
a150 4
static void recv_willing_msg(
    struct sockaddr * /*from*/,
    int /*fromlen*/,
    unsigned /*length*/);
d154 1
a154 1
static void recv_accept_msg(unsigned /*length*/);
d156 1
a156 1
static void recv_decline_msg(unsigned /*length*/);
d160 1
a160 1
static void recv_refuse_msg(unsigned /*length*/);
d162 1
a162 1
static void recv_failed_msg(unsigned /*length*/);
d166 1
a166 1
static void recv_alive_msg(unsigned /*length*/);
d168 2
a169 5
static void XdmcpFatal(
    const char * /*type*/,
    ARRAY8Ptr /*status*/);
 
static void XdmcpWarning(const char * /*str*/);
d171 1
a171 4
static void get_manager_by_name(
    int /*argc*/,
    char ** /*argv*/,
    int /*i*/);
d173 6
a178 1
static void get_fromaddr_by_name(int /*argc*/, char ** /*argv*/, int /*i*/);
d181 1
a181 1
static int get_mcast_options(int /*argc*/, char ** /*argv*/, int /*i*/);
d184 1
a184 1
static void receive_packet(int /*socketfd*/);
d192 7
a198 9
static void XdmcpBlockHandler(
    pointer /*data*/,
    struct timeval ** /*wt*/,
    pointer /*LastSelectMask*/);

static void XdmcpWakeupHandler(
    pointer /*data*/,
    int /*i*/,
    pointer /*LastSelectMask*/);
d207 1
a207 1
XdmcpRegisterManufacturerDisplayID (const char *name, int length)
d209 1
a209 1
    int	    i;
d211 3
a213 3
    XdmcpDisposeARRAY8 (&ManufacturerDisplayID);
    if (!XdmcpAllocARRAY8 (&ManufacturerDisplayID, length))
	return;
d215 1
a215 1
	ManufacturerDisplayID.data[i] = (CARD8) name[i];
d218 3
a220 3
static unsigned short	xdm_udp_port = XDM_UDP_PORT;
static Bool	OneSession = FALSE;
static const char 	*xdm_from = NULL;
d223 1
a223 1
XdmcpUseMsg (void)
d232 2
a233 1
    ErrorF("-from local-address    specify the local address to connect from\n");
d242 1
a242 1
int 
d246 4
a249 4
	get_manager_by_name(argc, argv, i++);
	XDM_INIT_STATE = XDM_QUERY;
	AccessUsingXdmcp ();
	return i + 1;
d252 3
a254 3
	XDM_INIT_STATE = XDM_BROADCAST;
	AccessUsingXdmcp ();
	return i + 1;
d258 4
a261 4
	i = get_mcast_options(argc, argv, ++i);
	XDM_INIT_STATE = XDM_MULTICAST;
	AccessUsingXdmcp ();
	return i + 1;
d265 4
a268 4
	get_manager_by_name(argc, argv, i++);
	XDM_INIT_STATE = XDM_INDIRECT;
	AccessUsingXdmcp ();
	return i + 1;
d271 5
a275 5
        if (++i == argc)  {
	    FatalError("Xserver: missing port number in command line\n");
	}
	xdm_udp_port = (unsigned short) atoi(argv[i]);
	return i + 1;
d278 2
a279 2
	get_fromaddr_by_name(argc, argv, ++i);
	return i + 1;
d282 2
a283 2
	OneSession = TRUE;
	return i + 1;
d286 5
a290 5
        if (++i == argc)  {
	    FatalError("Xserver: missing class name in command line\n");
	}
	defaultDisplayClass = argv[i];
	return i + 1;
d294 5
a298 5
        if (++i == argc)  {
	    FatalError("Xserver: missing cookie data in command line\n");
	}
	xdmAuthCookie = argv[i];
	return i + 1;
d302 5
a306 5
        if (++i == argc)  {
	    FatalError("Xserver: missing displayID in command line\n");
	}
	XdmcpRegisterManufacturerDisplayID (argv[i], strlen (argv[i]));
	return i + 1;
a316 1

d325 2
a326 2
static struct sockaddr_in   BroadcastAddresses[MAX_BROADCAST];
static int		    NumBroadcastAddresses;
d329 1
a329 1
XdmcpRegisterBroadcastAddress (const struct sockaddr_in *addr)
d331 2
a332 1
    struct sockaddr_in	*bcast;
d334 1
a334 1
	return;
d336 1
a336 1
    memset(bcast, 0, sizeof (struct sockaddr_in));
d341 1
a341 1
    bcast->sin_port = htons (xdm_udp_port);
d351 1
a351 1
static ARRAYofARRAY8	AuthenticationNames, AuthenticationDatas;
d353 3
a355 3
    ValidatorFunc    Validator;
    GeneratorFunc    Generator;
    AddAuthorFunc    AddAuth;
d358 1
a358 1
static AuthenticationFuncsPtr	AuthenticationFuncsList;
d361 16
a376 19
XdmcpRegisterAuthentication (
    const char    *name,
    int	    namelen,
    const char    *data,
    int	    datalen,
    ValidatorFunc Validator,
    GeneratorFunc Generator,
    AddAuthorFunc AddAuth)
{
    int	    i;
    ARRAY8  AuthenticationName, AuthenticationData;
    static AuthenticationFuncsPtr	newFuncs;

    if (!XdmcpAllocARRAY8 (&AuthenticationName, namelen))
	return;
    if (!XdmcpAllocARRAY8 (&AuthenticationData, datalen))
    {
	XdmcpDisposeARRAY8 (&AuthenticationName);
	return;
d379 1
a379 1
	AuthenticationName.data[i] = name[i];
d381 11
a391 10
	AuthenticationData.data[i] = data[i];
    if (!(XdmcpReallocARRAYofARRAY8 (&AuthenticationNames,
				     AuthenticationNames.length + 1) &&
	  XdmcpReallocARRAYofARRAY8 (&AuthenticationDatas,
				     AuthenticationDatas.length + 1) &&
	  (newFuncs = malloc((AuthenticationNames.length + 1) * sizeof (AuthenticationFuncsRec)))))
    {
	XdmcpDisposeARRAY8 (&AuthenticationName);
	XdmcpDisposeARRAY8 (&AuthenticationData);
	return;
d394 4
a397 4
	newFuncs[i] = AuthenticationFuncsList[i];
    newFuncs[AuthenticationNames.length-1].Validator = Validator;
    newFuncs[AuthenticationNames.length-1].Generator = Generator;
    newFuncs[AuthenticationNames.length-1].AddAuth = AddAuth;
d400 4
a403 2
    AuthenticationNames.data[AuthenticationNames.length-1] = AuthenticationName;
    AuthenticationDatas.data[AuthenticationDatas.length-1] = AuthenticationData;
d411 6
a416 5
static ARRAY8		noAuthenticationName = {(CARD16) 0, (CARD8Ptr) 0};
static ARRAY8		noAuthenticationData = {(CARD16) 0, (CARD8Ptr) 0};
static ARRAY8Ptr	AuthenticationName = &noAuthenticationName;
static ARRAY8Ptr	AuthenticationData = &noAuthenticationData;
static AuthenticationFuncsPtr	AuthenticationFuncs;
d419 1
a419 1
XdmcpSetAuthentication (const ARRAY8Ptr name)
d421 1
a421 1
    int	i;
d424 6
a429 7
	if (XdmcpARRAY8Equal (&AuthenticationNames.data[i], name))
	{
	    AuthenticationName = &AuthenticationNames.data[i];
	    AuthenticationData = &AuthenticationDatas.data[i];
	    AuthenticationFuncs = &AuthenticationFuncsList[i];
	    break;
	}
d436 3
a438 3
static ARRAY16		ConnectionTypes;
static ARRAYofARRAY8	ConnectionAddresses;
static long		xdmcpGeneration;
d441 47
a487 46
XdmcpRegisterConnection (
    int	    type,
    const char    *address,
    int	    addrlen)
{
    int	    i;
    CARD8   *newAddress;

    if (xdmcpGeneration != serverGeneration)
    {
	XdmcpDisposeARRAY16 (&ConnectionTypes);
	XdmcpDisposeARRAYofARRAY8 (&ConnectionAddresses);
	xdmcpGeneration = serverGeneration;
    }
    if (xdm_from != NULL) {	/* Only register the requested address */
	const void *regAddr = address;
	const void *fromAddr = NULL;
	int regAddrlen = addrlen;

	if (addrlen == sizeof(struct in_addr)) {
	    if (SOCKADDR_FAMILY(FromAddress) == AF_INET) {
		fromAddr = &((struct sockaddr_in *)&FromAddress)->sin_addr;
	    } 
#if defined(IPv6) && defined(AF_INET6)
	    else if ((SOCKADDR_FAMILY(FromAddress) == AF_INET6) &&
	      IN6_IS_ADDR_V4MAPPED(
		  &((struct sockaddr_in6 *)&FromAddress)->sin6_addr)) {
		fromAddr = &((struct sockaddr_in6 *)&FromAddress)->sin6_addr.s6_addr[12];
	    } 
#endif
	}
#if defined(IPv6) && defined(AF_INET6)
	else if (addrlen == sizeof(struct in6_addr)) {
	    if (SOCKADDR_FAMILY(FromAddress) == AF_INET6) {
		fromAddr = &((struct sockaddr_in6 *)&FromAddress)->sin6_addr;
	    } else if ((SOCKADDR_FAMILY(FromAddress) == AF_INET) &&
	      IN6_IS_ADDR_V4MAPPED((struct in6_addr *) address)) {
		fromAddr = &((struct sockaddr_in *)&FromAddress)->sin_addr;
		regAddr = &((struct sockaddr_in6 *)&address)->sin6_addr.s6_addr[12];
		regAddrlen = sizeof(struct in_addr);
	    }
	}
#endif
	if (!fromAddr || memcmp(regAddr, fromAddr, regAddrlen) != 0) {
	    return;
	}
d490 2
a491 2
	return;
    newAddress = malloc(addrlen * sizeof (CARD8));
d493 9
a501 11
	return;
    if (!XdmcpReallocARRAY16 (&ConnectionTypes, ConnectionTypes.length + 1))
    {
	free(newAddress);
	return;
    }
    if (!XdmcpReallocARRAYofARRAY8 (&ConnectionAddresses,
				    ConnectionAddresses.length +  1))
    {
	free(newAddress);
	return;
d505 3
a507 3
	newAddress[i] = address[i];
    ConnectionAddresses.data[ConnectionAddresses.length-1].data = newAddress;
    ConnectionAddresses.data[ConnectionAddresses.length-1].length = addrlen;
d515 1
a515 1
static ARRAYofARRAY8	AuthorizationNames;
d518 1
a518 1
XdmcpRegisterAuthorizations (void)
d520 2
a521 2
    XdmcpDisposeARRAYofARRAY8 (&AuthorizationNames);
    RegisterAuthorizations ();
d525 1
a525 1
XdmcpRegisterAuthorization (const char *name, int namelen)
d527 2
a528 2
    ARRAY8  authName;
    int	    i;
d530 1
a530 1
    authName.data = malloc(namelen * sizeof (CARD8));
d532 5
a536 5
	return;
    if (!XdmcpReallocARRAYofARRAY8 (&AuthorizationNames, AuthorizationNames.length +1))
    {
	free(authName.data);
	return;
d539 1
a539 1
	authName.data[i] = (CARD8) name[i];
d541 1
a541 1
    AuthorizationNames.data[AuthorizationNames.length-1] = authName;
d548 1
a548 1
static ARRAY8	DisplayClass;
d551 1
a551 1
XdmcpRegisterDisplayClass (const char *name, int length)
d553 1
a553 1
    int	    i;
d555 3
a557 3
    XdmcpDisposeARRAY8 (&DisplayClass);
    if (!XdmcpAllocARRAY8 (&DisplayClass, length))
	return;
d559 1
a559 1
	DisplayClass.data[i] = (CARD8) name[i];
d567 1
a567 1
void 
d573 1
a573 1
	XdmAuthenticationInit (xdmAuthCookie, strlen (xdmAuthCookie));
d575 11
a585 11
    if (state != XDM_OFF)
    {
	XdmcpRegisterAuthorizations();
	XdmcpRegisterDisplayClass (defaultDisplayClass, strlen (defaultDisplayClass));
	AccessUsingXdmcp();
	RegisterBlockAndWakeupHandlers (XdmcpBlockHandler, XdmcpWakeupHandler,
				        (pointer) 0);
    	timeOutRtx = 0;
    	DisplayNumber = (CARD16) atoi(display);
    	get_xdmcp_sock();
    	send_packet();
d590 1
a590 1
XdmcpReset (void)
d593 5
a597 6
    if (state != XDM_OFF)
    {
	RegisterBlockAndWakeupHandlers (XdmcpBlockHandler, XdmcpWakeupHandler,
				        (pointer) 0);
    	timeOutRtx = 0;
    	send_packet();
d611 1
a611 1
	return;
d616 1
a616 1
void 
d620 2
a621 2
	|| sessionSocket != sock)
	    return;
d624 1
a624 1
	dispatchException |= DE_TERMINATE;
d626 1
a626 1
	dispatchException |= DE_RESET;
d637 3
a639 6
/*ARGSUSED*/
static void
XdmcpBlockHandler(
    pointer	    data,   /* unused */
    struct timeval  **wt,
    pointer	    pReadmask)
d641 1
a641 1
    fd_set *LastSelectMask = (fd_set*)pReadmask;
d645 1
a645 1
	return;
d649 1
a649 1
	FD_SET(xdmcpSocket6, LastSelectMask);
d652 1
a652 1
	return;
d655 2
a656 2
	millisToGo = 0;
    AdjustWaitForDelay (wt, millisToGo);
d665 3
a667 6
/*ARGSUSED*/
static void
XdmcpWakeupHandler(
    pointer data,   /* unused */
    int	    i,
    pointer pReadmask)
d669 2
a670 2
    fd_set* LastSelectMask = (fd_set*)pReadmask;
    fd_set   devicesReadable;
d673 29
a701 35
	return;
    if (i > 0)
    {
	if (FD_ISSET(xdmcpSocket, LastSelectMask))
	{
	    receive_packet(xdmcpSocket);
	    FD_CLR(xdmcpSocket, LastSelectMask);
	} 
#if defined(IPv6) && defined(AF_INET6)
	if (xdmcpSocket6 >= 0 && FD_ISSET(xdmcpSocket6, LastSelectMask))
	{
	    receive_packet(xdmcpSocket6);
	    FD_CLR(xdmcpSocket6, LastSelectMask);
	} 
#endif
	XFD_ANDSET(&devicesReadable, LastSelectMask, &EnabledDevices);
	if (XFD_ANYSET(&devicesReadable))
	{
	    if (state == XDM_AWAIT_USER_INPUT)
		restart();
	    else if (state == XDM_RUN_SESSION)
		keepaliveDormancy = defaultKeepaliveDormancy;
	}
	if (XFD_ANYSET(&AllClients) && state == XDM_RUN_SESSION)
	    timeOutTime = GetTimeInMillis() +  keepaliveDormancy * 1000;
    }
    else if (timeOutTime && (int) (GetTimeInMillis() - timeOutTime) >= 0)
    {
    	if (state == XDM_RUN_SESSION)
    	{
	    state = XDM_KEEPALIVE;
	    send_packet();
    	}
    	else
	    timeout();
d711 2
a712 4
XdmcpSelectHost(
    const struct sockaddr	*host_sockaddr,
    int			host_len,
    ARRAY8Ptr		AuthenticationName)
d717 1
a717 1
    XdmcpSetAuthentication (AuthenticationName);
d727 4
a730 8
/*ARGSUSED*/
static void
XdmcpAddHost(
    const struct sockaddr    *from,
    int			fromlen,
    ARRAY8Ptr		AuthenticationName,
    ARRAY8Ptr		hostname,
    ARRAY8Ptr		status)
d740 1
a740 1
static ARRAY8	UnwillingMessage = { (CARD8) 14, (CARD8 *) "Host unwilling" };
d751 1
a751 1
    XdmcpHeader	header;
d754 2
a755 2
    if (!XdmcpFill (socketfd, &buffer, (XdmcpNetaddr) &from, &fromlen))
	return;
d760 2
a761 2
    if (!XdmcpReadHeader (&buffer, &header))
	return;
d764 1
a764 1
	return;
d768 2
a769 2
	recv_willing_msg((struct sockaddr *) &from, fromlen, header.length);
	break;
d771 2
a772 2
	XdmcpFatal("Manager unwilling", &UnwillingMessage);
	break;
d774 2
a775 2
	recv_accept_msg(header.length);
	break;
d777 2
a778 2
	recv_decline_msg(header.length);
	break;
d780 2
a781 2
	recv_refuse_msg(header.length);
	break;
d783 2
a784 2
	recv_failed_msg(header.length);
	break;
d786 2
a787 2
	recv_alive_msg(header.length);
	break;
d799 1
d807 2
a808 2
	send_query_msg();
	break;
d810 2
a811 2
	send_request_msg();
	break;
d813 2
a814 2
	send_manage_msg();
	break;
d816 2
a817 2
	send_keepalive_msg();
	break;
d819 1
a819 1
	break;
d823 1
a823 1
	rtx = XDM_MAX_RTX;
d833 1
a833 1
XdmcpDeadSession (const char *reason)
d835 1
a835 1
    ErrorF ("XDM: %s, declaring session dead\n", reason);
d852 6
a857 8
    if (state == XDM_AWAIT_ALIVE_RESPONSE && timeOutRtx >= XDM_KA_RTX_LIMIT )
    {
	XdmcpDeadSession ("too many keepalive retransmissions");
	return;
    }
    else if (timeOutRtx >= XDM_RTX_LIMIT)
    {
	/* Quit if "-once" specified, otherwise reset and try again. */
d859 7
a865 6
	    dispatchException |= DE_TERMINATE;
	    ErrorF("XDM: too many retransmissions\n");
	} else { 
	    XdmcpDeadSession("too many retransmissions");
	}
	return;
d870 8
a877 9
	/* Try next address */
	for (mgrAddr = mgrAddr->ai_next; ; mgrAddr = mgrAddr->ai_next) {
	    if (mgrAddr == NULL) {
		mgrAddr = mgrAddrFirst;
	    }
	    if (mgrAddr->ai_family == AF_INET 
	      || mgrAddr->ai_family == AF_INET6)
		break;
	}
d879 1
a879 1
	ManagerAddressLen = mgrAddr->ai_addrlen;
d881 1
a881 1
	memcpy(&ManagerAddress, mgrAddr->ai_addr, mgrAddr->ai_addrlen);
d887 2
a888 2
	state = XDM_QUERY;
	break;
d890 2
a891 2
	state = XDM_BROADCAST;
	break;
d894 2
a895 2
	state = XDM_MULTICAST;
	break;
d898 2
a899 2
	state = XDM_INDIRECT;
	break;
d901 2
a902 2
	state = XDM_START_CONNECTION;
	break;
d904 2
a905 2
	state = XDM_MANAGE;
	break;
d907 2
a908 2
	state = XDM_KEEPALIVE;
	break;
d910 1
a910 1
	break;
d924 1
a924 1
XdmcpCheckAuthentication (ARRAY8Ptr Name, ARRAY8Ptr Data, int packet_type)
d926 4
a929 3
    return (XdmcpARRAY8Equal (Name, AuthenticationName) &&
	    (AuthenticationName->length == 0 ||
	     (*AuthenticationFuncs->Validator) (AuthenticationData, Data, packet_type)));
d933 1
a933 1
XdmcpAddAuthorization (ARRAY8Ptr name, ARRAY8Ptr data)
d938 1
a938 1
	AddAuth = AuthenticationFuncs->AddAuth;
d940 4
a943 5
	AddAuth = AddAuthorization;
    return (*AddAuth) ((unsigned short)name->length,
		       (char *)name->data,
		       (unsigned short)data->length,
		       (char *)data->data);
d958 2
a959 2
	XdmcpWarning("t_open() of /dev/udp failed");
	return;
d962 5
a966 5
    if( t_bind(xdmcpSocket,NULL,NULL) < 0 ) {
	XdmcpWarning("UDP socket creation failed");
	t_error("t_bind(xdmcpSocket) failed" );
	t_close(xdmcpSocket);
	return;
d973 6
a978 14
 
    if( (nconf=getnetconfigent("udp")) == NULL ) {
	XdmcpWarning("UDP socket creation failed: getnetconfigent()");
	t_unbind(xdmcpSocket);
	t_close(xdmcpSocket);
	return;
    }
 
    if( netdir_options(nconf, ND_SET_BROADCAST, xdmcpSocket, NULL) ) {
	XdmcpWarning("UDP set broadcast option failed: netdir_options()");
	freenetconfigent(nconf);
	t_unbind(xdmcpSocket);
	t_close(xdmcpSocket);
	return;
d980 9
a988 1
 
d995 1
a995 1
	XdmcpWarning("INET6 UDP socket creation failed");
d998 1
a998 1
	XdmcpWarning("UDP socket creation failed");
d1000 4
a1003 4
    else if (setsockopt(xdmcpSocket, SOL_SOCKET, SO_BROADCAST, (char *)&soopts,
	sizeof(soopts)) < 0)
	    XdmcpWarning("UDP set broadcast socket-option failed");
#endif /* SO_BROADCAST */
d1005 5
a1009 4
	if (bind(xdmcpSocket, (struct sockaddr *)&FromAddress, 
		 FromAddressLen) < 0) {
	    FatalError("Xserver: failed to bind to -from address: %s\n", xdm_from);
	}
d1011 1
a1011 1
#endif /* STREAMSCONN */
d1017 3
a1019 2
    XdmcpHeader	header;
    Bool	broadcast = FALSE;
d1021 1
a1021 1
    Bool	multicast = FALSE;
d1023 2
a1024 2
    int		i;
    int 	socketfd = xdmcpSocket;
d1027 1
a1027 1
    switch(state){
d1029 3
a1031 3
	header.opcode = (CARD16) QUERY; 
	state = XDM_COLLECT_QUERY;
	break;
d1033 4
a1036 4
	header.opcode = (CARD16) BROADCAST_QUERY;
	state = XDM_COLLECT_BROADCAST_QUERY;
	broadcast = TRUE;
	break;
d1039 4
a1042 4
	header.opcode = (CARD16) BROADCAST_QUERY;
	state = XDM_COLLECT_MULTICAST_QUERY;
	multicast = TRUE;
	break;
d1045 3
a1047 3
	header.opcode = (CARD16) INDIRECT_QUERY;
	state = XDM_COLLECT_INDIRECT_QUERY;
	break;
d1049 1
a1049 1
	break;
d1053 6
a1058 1
	header.length += 2 + AuthenticationNames.data[i].length;
d1060 34
a1093 36
    XdmcpWriteHeader (&buffer, &header);
    XdmcpWriteARRAYofARRAY8 (&buffer, &AuthenticationNames);
    if (broadcast)
    {
	int i;

	for (i = 0; i < NumBroadcastAddresses; i++)
	    XdmcpFlush (xdmcpSocket, &buffer, (XdmcpNetaddr) &BroadcastAddresses[i],
			sizeof (struct sockaddr_in));
    }
#if defined(IPv6) && defined(AF_INET6)
    else if (multicast)
    {
	struct multicastinfo *mcl;
	struct addrinfo *ai;

	for (mcl = mcastlist; mcl != NULL; mcl = mcl->next) {
	    for (ai = mcl->ai ; ai != NULL; ai = ai->ai_next) {
		if (ai->ai_family == AF_INET) {
		    unsigned char hopflag = (unsigned char) mcl->hops;
		    socketfd = xdmcpSocket;
		    setsockopt(socketfd, IPPROTO_IP, IP_MULTICAST_TTL,
		      &hopflag, sizeof(hopflag));
		} else if (ai->ai_family == AF_INET6) {
		    int hopflag6 = mcl->hops;
		    socketfd = xdmcpSocket6;
		    setsockopt(socketfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
		      &hopflag6, sizeof(hopflag6));
		} else {
		    continue;
		}
		XdmcpFlush (socketfd, &buffer, 
		  	    (XdmcpNetaddr) ai->ai_addr, ai->ai_addrlen);
		break;
	    }
	}
d1096 1
a1096 2
    else
    {
d1098 5
a1102 5
	if (SOCKADDR_FAMILY(ManagerAddress) == AF_INET6)
	    socketfd = xdmcpSocket6;
#endif	
	XdmcpFlush (socketfd, &buffer, (XdmcpNetaddr) &ManagerAddress,
		    ManagerAddressLen);
d1107 1
a1107 4
recv_willing_msg(
    struct sockaddr	*from,
    int			fromlen,
    unsigned		length)
d1109 3
a1111 3
    ARRAY8	authenticationName;
    ARRAY8	hostname;
    ARRAY8	status;
d1116 25
a1140 27
    if (XdmcpReadARRAY8 (&buffer, &authenticationName) &&
	XdmcpReadARRAY8 (&buffer, &hostname) &&
	XdmcpReadARRAY8 (&buffer, &status))
    {
    	if (length == 6 + authenticationName.length +
		      hostname.length + status.length)
    	{
	    switch (state)
	    {
	    case XDM_COLLECT_QUERY:
	    	XdmcpSelectHost(from, fromlen, &authenticationName);
	    	break;
	    case XDM_COLLECT_BROADCAST_QUERY:
#if defined(IPv6) && defined(AF_INET6)
	    case XDM_COLLECT_MULTICAST_QUERY:
#endif
	    case XDM_COLLECT_INDIRECT_QUERY:
	    	XdmcpAddHost(from, fromlen, &authenticationName, &hostname, &status);
	    	break;
	    default:
		break;
    	    }
    	}
    }
    XdmcpDisposeARRAY8 (&authenticationName);
    XdmcpDisposeARRAY8 (&hostname);
    XdmcpDisposeARRAY8 (&status);
d1146 15
a1160 12
    XdmcpHeader	    header;
    int		    length;
    int		    i;
    CARD16	    XdmcpConnectionType;
    ARRAY8	    authenticationData;
    int		    socketfd = xdmcpSocket;

    switch (SOCKADDR_FAMILY(ManagerAddress))
    {
    case AF_INET:	XdmcpConnectionType=FamilyInternet; break;
#if defined(IPv6) && defined(AF_INET6)
    case AF_INET6:	XdmcpConnectionType=FamilyInternet6; break;
d1162 3
a1164 1
    default:		XdmcpConnectionType=0xffff; break;
d1170 3
a1172 3
    length = 2;					    /* display number */
    length += 1 + 2 * ConnectionTypes.length;	    /* connection types */
    length += 1;				    /* connection addresses */
d1174 1
a1174 1
	length += 2 + ConnectionAddresses.data[i].length;
d1177 7
a1183 9
    if (AuthenticationFuncs)
    {
	(*AuthenticationFuncs->Generator) (AuthenticationData,
					   &authenticationData,
 					   REQUEST);
    }
    length += 2 + AuthenticationName->length;	    /* authentication name */
    length += 2 + authenticationData.length;	    /* authentication data */
    length += 1;				    /* authorization names */
d1185 2
a1186 2
	length += 2 + AuthorizationNames.data[i].length;
    length += 2 + ManufacturerDisplayID.length;	    /* display ID */
d1189 32
a1220 33
    if (!XdmcpWriteHeader (&buffer, &header))
    {
	XdmcpDisposeARRAY8 (&authenticationData);
	return;
    }
    XdmcpWriteCARD16 (&buffer, DisplayNumber);
    XdmcpWriteCARD8 (&buffer, ConnectionTypes.length);

    /* The connection array is send reordered, so that connections of	*/
    /* the same address type as the XDMCP manager connection are send	*/
    /* first. This works around a bug in xdm. mario@@klebsch.de 		*/
    for (i = 0; i < (int)ConnectionTypes.length; i++)
	if (ConnectionTypes.data[i]==XdmcpConnectionType)
	    XdmcpWriteCARD16 (&buffer, ConnectionTypes.data[i]);
    for (i = 0; i < (int)ConnectionTypes.length; i++)
	if (ConnectionTypes.data[i]!=XdmcpConnectionType)
	    XdmcpWriteCARD16 (&buffer, ConnectionTypes.data[i]);

    XdmcpWriteCARD8 (&buffer, ConnectionAddresses.length);
    for (i = 0; i < (int)ConnectionAddresses.length; i++)
	if ( (i<ConnectionTypes.length) && 
	     (ConnectionTypes.data[i]==XdmcpConnectionType) )
	    XdmcpWriteARRAY8 (&buffer, &ConnectionAddresses.data[i]);
    for (i = 0; i < (int)ConnectionAddresses.length; i++)
	if ( (i>=ConnectionTypes.length) ||
	     (ConnectionTypes.data[i]!=XdmcpConnectionType) )
	    XdmcpWriteARRAY8 (&buffer, &ConnectionAddresses.data[i]);

    XdmcpWriteARRAY8 (&buffer, AuthenticationName);
    XdmcpWriteARRAY8 (&buffer, &authenticationData);
    XdmcpDisposeARRAY8 (&authenticationData);
    XdmcpWriteARRAYofARRAY8 (&buffer, &AuthorizationNames);
    XdmcpWriteARRAY8 (&buffer, &ManufacturerDisplayID);
d1223 1
a1223 1
	socketfd = xdmcpSocket6;
d1225 3
a1227 3
    if (XdmcpFlush (socketfd, &buffer, 
			(XdmcpNetaddr) &req_sockaddr, req_socklen))
	state = XDM_AWAIT_REQUEST_RESPONSE;
d1233 3
a1235 3
    CARD32  AcceptSessionID;
    ARRAY8  AcceptAuthenticationName, AcceptAuthenticationData;
    ARRAY8  AcceptAuthorizationName, AcceptAuthorizationData;
d1238 1
a1238 1
	return;
d1243 30
a1272 35
    if (XdmcpReadCARD32 (&buffer, &AcceptSessionID) &&
	XdmcpReadARRAY8 (&buffer, &AcceptAuthenticationName) &&
	XdmcpReadARRAY8 (&buffer, &AcceptAuthenticationData) &&
	XdmcpReadARRAY8 (&buffer, &AcceptAuthorizationName) &&
	XdmcpReadARRAY8 (&buffer, &AcceptAuthorizationData))
    {
    	if (length == 12 + AcceptAuthenticationName.length +
		      	   AcceptAuthenticationData.length +
		      	   AcceptAuthorizationName.length +
 		      	   AcceptAuthorizationData.length)
    	{
	    if (!XdmcpCheckAuthentication (&AcceptAuthenticationName,
				      &AcceptAuthenticationData, ACCEPT))
	    {
		XdmcpFatal ("Authentication Failure", &AcceptAuthenticationName);
	    }
	    /* permit access control manipulations from this host */
	    AugmentSelf (&req_sockaddr, req_socklen);
	    /* if the authorization specified in the packet fails
	     * to be acceptable, enable the local addresses
	     */
	    if (!XdmcpAddAuthorization (&AcceptAuthorizationName,
					&AcceptAuthorizationData))
	    {
		AddLocalHosts ();
	    }
	    SessionID = AcceptSessionID;
    	    state = XDM_MANAGE;
    	    send_packet();
    	}
    }
    XdmcpDisposeARRAY8 (&AcceptAuthenticationName);
    XdmcpDisposeARRAY8 (&AcceptAuthenticationData);
    XdmcpDisposeARRAY8 (&AcceptAuthorizationName);
    XdmcpDisposeARRAY8 (&AcceptAuthorizationData);
d1278 1
a1278 1
    ARRAY8  status, DeclineAuthenticationName, DeclineAuthenticationData;
d1283 14
a1296 16
    if (XdmcpReadARRAY8 (&buffer, &status) &&
	XdmcpReadARRAY8 (&buffer, &DeclineAuthenticationName) &&
	XdmcpReadARRAY8 (&buffer, &DeclineAuthenticationData))
    {
    	if (length == 6 + status.length +
		      	  DeclineAuthenticationName.length +
 		      	  DeclineAuthenticationData.length &&
	    XdmcpCheckAuthentication (&DeclineAuthenticationName,
				      &DeclineAuthenticationData, DECLINE))
    	{
	    XdmcpFatal ("Session declined", &status);
    	}
    }
    XdmcpDisposeARRAY8 (&status);
    XdmcpDisposeARRAY8 (&DeclineAuthenticationName);
    XdmcpDisposeARRAY8 (&DeclineAuthenticationData);
d1302 1
a1302 1
    XdmcpHeader	header;
d1309 5
a1313 5
    if (!XdmcpWriteHeader (&buffer, &header))
	return;
    XdmcpWriteCARD32 (&buffer, SessionID);
    XdmcpWriteCARD16 (&buffer, DisplayNumber);
    XdmcpWriteARRAY8 (&buffer, &DisplayClass);
d1317 1
a1317 1
	socketfd = xdmcpSocket6;
d1319 1
a1319 1
    XdmcpFlush (socketfd, &buffer, (XdmcpNetaddr) &req_sockaddr, req_socklen);
d1325 1
a1325 1
    CARD32  RefusedSessionID;
d1328 1
a1328 1
	return;
d1330 6
a1335 8
	return;
    if (XdmcpReadCARD32 (&buffer, &RefusedSessionID))
    {
	if (RefusedSessionID == SessionID)
	{
    	    state = XDM_START_CONNECTION;
    	    send_packet();
	}
d1342 2
a1343 2
    CARD32  FailedSessionID;
    ARRAY8  status;
d1346 1
a1346 1
	return;
d1348 5
a1352 8
    if (XdmcpReadCARD32 (&buffer, &FailedSessionID) &&
	XdmcpReadARRAY8 (&buffer, &status))
    {
    	if (length == 6 + status.length &&
	    SessionID == FailedSessionID)
	{
	    XdmcpFatal ("Session failed", &status);
	}
d1354 1
a1354 1
    XdmcpDisposeARRAY8 (&status);
d1360 1
a1360 1
    XdmcpHeader	header;
d1367 3
a1369 3
    XdmcpWriteHeader (&buffer, &header);
    XdmcpWriteCARD16 (&buffer, DisplayNumber);
    XdmcpWriteCARD32 (&buffer, SessionID);
d1374 1
a1374 1
	socketfd = xdmcpSocket6;
d1376 1
a1376 1
    XdmcpFlush (socketfd, &buffer, (XdmcpNetaddr) &req_sockaddr, req_socklen);
d1380 1
a1380 1
recv_alive_msg (unsigned length)
d1382 2
a1383 2
    CARD8   SessionRunning;
    CARD32  AliveSessionID;
d1386 1
a1386 1
	return;
d1388 17
a1404 21
	return;
    if (XdmcpReadCARD8 (&buffer, &SessionRunning) &&
	XdmcpReadCARD32 (&buffer, &AliveSessionID))
    {
    	if (SessionRunning && AliveSessionID == SessionID)
    	{
	    /* backoff dormancy period */
	    state = XDM_RUN_SESSION;
	    if ((GetTimeInMillis() - lastDeviceEventTime.milliseconds) >
		keepaliveDormancy * 1000)
	    {
		keepaliveDormancy <<= 1;
		if (keepaliveDormancy > XDM_MAX_DORMANCY)
		    keepaliveDormancy = XDM_MAX_DORMANCY;
	    }
	    timeOutTime = GetTimeInMillis() + keepaliveDormancy * 1000;
    	}
	else
    	{
	    XdmcpDeadSession ("Alive response indicates session dead");
    	}
d1408 2
a1409 4
static  void
XdmcpFatal (
    const char	*type,
    ARRAY8Ptr	status)
d1411 2
a1412 2
    FatalError ("XDMCP fatal error: %s %*.*s\n", type,
	   status->length, status->length, status->data);
d1415 1
a1415 1
static  void
d1422 6
a1427 11
get_addr_by_name(
    const char *argtype,
    const char *namestr,
    int		port,
    int		socktype,
    SOCKADDR_TYPE *addr,
    SOCKLEN_TYPE *addrlen
#if defined(IPv6) && defined(AF_INET6)
      ,
    struct addrinfo **aip,
    struct addrinfo **aifirstp
d1442 7
a1448 5
	pport = NULL;
    } else if (port > 0 && port < 65535) {
	snprintf(portstr, sizeof(portstr), "%d", port);
    } else {
	FatalError("Xserver: port out of range: %d\n", port);
d1452 2
a1453 2
	freeaddrinfo(*aifirstp);	
	*aifirstp = NULL;
d1457 18
a1474 15
	for (ai = *aifirstp; ai != NULL; ai = ai->ai_next) {
	    if (ai->ai_family == AF_INET || ai->ai_family == AF_INET6)
		break;
	}
	if ((ai == NULL) || (ai->ai_addrlen > sizeof(SOCKADDR_TYPE))) {
	    FatalError ("Xserver: %s host %s not on supported network type\n", 
	      argtype, namestr);
	} else {
	    *aip = ai;
	    *addrlen = ai->ai_addrlen;
	    memcpy(addr, ai->ai_addr, ai->ai_addrlen);
	}
    } else {
	FatalError("Xserver: %s: %s %s\n", gai_strerror(gaierr), argtype, namestr);
    }    
d1477 1
d1482 1
a1482 1
    _XSERVTransWSAStartup(); 
d1484 8
a1491 10
    if (!(hep = _XGethostbyname(namestr, hparams)))
    {
	FatalError("Xserver: %s unknown host: %s\n", argtype, namestr);
    }
    if (hep->h_length == sizeof (struct in_addr))
    {
	memmove(&addr->sin_addr, hep->h_addr, hep->h_length);
	*addrlen = sizeof(struct sockaddr_in);
	addr->sin_family = AF_INET;
	addr->sin_port = htons (port);
d1493 3
a1495 3
    else
    {
	FatalError("Xserver: %s host on strange network %s\n", argtype, namestr);
d1501 1
a1501 4
get_manager_by_name(
    int	    argc,
    char    **argv,
    int	    i)
d1504 2
a1505 3
    if ((i + 1) == argc)
    {
	FatalError("Xserver: missing %s host name in command line\n", argv[i]);
d1508 2
a1509 2
    get_addr_by_name(argv[i], argv[i+1], xdm_udp_port, SOCK_DGRAM, 
      &ManagerAddress, &ManagerAddressLen
d1511 1
a1511 1
      , &mgrAddr, &mgrAddrFirst
d1513 1
a1513 1
	);
a1515 1

d1517 1
a1517 4
get_fromaddr_by_name(
    int	    argc,
    char    **argv,
    int	    i)
d1523 2
a1524 3
    if (i == argc)
    {
	FatalError("Xserver: missing -from host name in command line\n");
d1528 1
a1528 1
      , &ai, &aifirst
d1530 1
a1530 1
	);
d1533 1
a1533 1
	freeaddrinfo(aifirst);
a1537 1

d1542 1
a1542 1
    char *address = XDM_DEFAULT_MCAST_ADDR6;
d1550 8
a1557 8
	address = argv[i++];
	if ((i < argc) && (argv[i][0] != '-') && (argv[i][0] != '+')) {
	    hopcount = strtol(argv[i++], NULL, 10);
	    if ((hopcount < 1) || (hopcount > 255)) {
		FatalError("Xserver: multicast hop count out of range: %d\n",
		  hopcount);
	    }
	}
d1561 4
a1564 3
	snprintf(portstr, sizeof(portstr), "%d", xdm_udp_port);
    } else {
	FatalError("Xserver: port out of range: %d\n", xdm_udp_port);
d1570 35
a1604 32
	for (ai = firstai; ai != NULL; ai = ai->ai_next) {
	    if (((ai->ai_family == AF_INET) && 
	      	IN_MULTICAST(((struct sockaddr_in *) ai->ai_addr)
							  ->sin_addr.s_addr))
		|| ((ai->ai_family == AF_INET6) && 
		  IN6_IS_ADDR_MULTICAST(&((struct sockaddr_in6 *) ai->ai_addr)
							    ->sin6_addr)))
		break;
	}
	if (ai == NULL) {
	    FatalError ("Xserver: address not supported multicast type %s\n", 
	      address);
	} else {
	    struct multicastinfo	*mcastinfo, *mcl;
	    
	    mcastinfo = malloc(sizeof(struct multicastinfo));
	    mcastinfo->next = NULL;
	    mcastinfo->ai = firstai;
	    mcastinfo->hops = hopcount;

	    if (mcastlist == NULL) {
		mcastlist = mcastinfo;
	    } else {
		for (mcl = mcastlist; mcl->next != NULL; mcl = mcl->next) {
		    /* Do nothing  - just find end of list */
		}
		mcl->next = mcastinfo;
	    }
	}
    } else {
	FatalError("Xserver: %s: %s\n", gai_strerror(gaierr), address);
    }    
d1610 2
a1611 2
static int xdmcp_non_empty; /* avoid complaint by ranlib */
#endif /* XDMCP */
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d489 1
a489 1
	if (fromAddr && memcmp(regAddr, fromAddr, regAddrlen) != 0) {
d1523 1
a1523 1
#if defined(WIN32) && (defined(TCPCONN) || defined(DNETCONN))
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d135 1
a135 1
    struct sockaddr    *from,
d142 1
a142 1
    struct sockaddr	*host_sockaddr,
d172 1
a172 1
    char * /*type*/,
d175 1
a175 1
static void XdmcpWarning(char * /*str*/);
d213 1
a213 1
XdmcpRegisterManufacturerDisplayID (char *name, int length)
d254 1
a254 1
	return (i + 1);
d259 1
a259 1
	return (i + 1);
d266 1
a266 1
	return (i + 1);
d273 1
a273 1
	return (i + 1);
d280 1
a280 1
	return (i + 1);
d284 1
a284 1
	return (i + 1);
d288 1
a288 1
	return (i + 1);
d295 1
a295 1
	return (i + 1);
d303 1
a303 1
	return (i + 1);
d311 1
a311 1
	return (i + 1);
d313 1
a313 1
    return (i);
d335 1
a335 1
XdmcpRegisterBroadcastAddress (struct sockaddr_in *addr)
d341 1
a341 1
    bzero (bcast, sizeof (struct sockaddr_in));
d367 1
a367 1
    char    *name,
d369 1
a369 1
    char    *data,
d394 1
a394 1
	  (newFuncs = xalloc ((AuthenticationNames.length + 1) * sizeof (AuthenticationFuncsRec)))))
d405 1
a405 1
    xfree (AuthenticationFuncsList);
d423 1
a423 1
XdmcpSetAuthentication (ARRAY8Ptr name)
d448 1
a448 1
    char    *address,
d495 1
a495 1
    newAddress = xalloc (addrlen * sizeof (CARD8));
d500 1
a500 1
	xfree (newAddress);
d506 1
a506 1
	xfree (newAddress);
d531 1
a531 1
XdmcpRegisterAuthorization (char *name, int namelen)
d536 1
a536 1
    authName.data = xalloc (namelen * sizeof (CARD8));
d541 1
a541 1
	xfree (authName.data);
d557 1
a557 1
XdmcpRegisterDisplayClass (char *name, int length)
d731 1
a731 1
    struct sockaddr	*host_sockaddr,
d751 1
a751 1
    struct sockaddr    *from,
d857 1
a857 1
XdmcpDeadSession (char *reason)
d1451 1
a1451 1
    char	*type,
d1459 1
a1459 1
XdmcpWarning(char *str)
d1466 2
a1467 2
    char *	argtype,
    char *	namestr,
d1486 1
a1486 1
    bzero(&hints, sizeof(hints));
d1619 1
a1619 1
    bzero(&hints, sizeof(hints));
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d394 1
a394 2
	  (newFuncs = (AuthenticationFuncsPtr) xalloc (
			(AuthenticationNames.length + 1) * sizeof (AuthenticationFuncsRec)))))
d536 1
a536 1
    authName.data = (CARD8 *) xalloc (namelen * sizeof (CARD8));
d1594 1
a1594 3
get_mcast_options(argc, argv, i)
    int	    argc, i;
    char    **argv;
@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@a26 1
#ifndef Lynx
a28 3
#else
#include <socket.h>
#endif
d43 1
a43 5

#if defined(DGUX)
#include <net/net_ioctl.h>
#include <sys/ioctl.h>
#endif
d63 1
a63 1
extern char *defaultDisplayClass;
d494 3
a496 1
    newAddress = (CARD8 *) xalloc (addrlen * sizeof (CARD8));
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@a199 2
extern void XdmcpDeadSession(char * /*reason*/);

d214 10
a223 3
void XdmcpRegisterManufacturerDisplayID(
    char    * /*name*/,
    int	    /*length*/);
d225 6
d425 5
a429 5
ARRAY8		noAuthenticationName = {(CARD16) 0, (CARD8Ptr) 0};
ARRAY8		noAuthenticationData = {(CARD16) 0, (CARD8Ptr) 0};
ARRAY8Ptr	AuthenticationName = &noAuthenticationName;
ARRAY8Ptr	AuthenticationData = &noAuthenticationData;
AuthenticationFuncsPtr	AuthenticationFuncs;
d431 1
a431 1
void
d561 1
a561 1
ARRAY8	DisplayClass;
d563 1
a563 1
void
a574 18
/*
 * Register the Manufacturer display ID
 */

ARRAY8 ManufacturerDisplayID;

void
XdmcpRegisterManufacturerDisplayID (char *name, int length)
{
    int	    i;

    XdmcpDisposeARRAY8 (&ManufacturerDisplayID);
    if (!XdmcpAllocARRAY8 (&ManufacturerDisplayID, length))
	return;
    for (i = 0; i < length; i++)
	ManufacturerDisplayID.data[i] = (CARD8) name[i];
}

d772 1
a772 1
ARRAY8	UnwillingMessage = { (CARD8) 14, (CARD8 *) "Host unwilling" };
d863 1
a863 1
void
d956 2
a957 5
int
XdmcpCheckAuthentication (
    ARRAY8Ptr	Name,
    ARRAY8Ptr	Data,
    int	packet_type)
d964 2
a965 4
int
XdmcpAddAuthorization (
    ARRAY8Ptr	name,
    ARRAY8Ptr	data)
@


1.1
log
@Initial revision
@
text
@d1511 1
a1511 1
	sprintf(portstr, "%d", port);
d1636 1
a1636 1
	sprintf(portstr, "%d", xdm_udp_port);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d200 2
d216 3
a218 10
/*
 * Register the Manufacturer display ID
 */

static ARRAY8 ManufacturerDisplayID;

static void
XdmcpRegisterManufacturerDisplayID (char *name, int length)
{
    int	    i;
a219 6
    XdmcpDisposeARRAY8 (&ManufacturerDisplayID);
    if (!XdmcpAllocARRAY8 (&ManufacturerDisplayID, length))
	return;
    for (i = 0; i < length; i++)
	ManufacturerDisplayID.data[i] = (CARD8) name[i];
}
d414 5
a418 5
static ARRAY8		noAuthenticationName = {(CARD16) 0, (CARD8Ptr) 0};
static ARRAY8		noAuthenticationData = {(CARD16) 0, (CARD8Ptr) 0};
static ARRAY8Ptr	AuthenticationName = &noAuthenticationName;
static ARRAY8Ptr	AuthenticationData = &noAuthenticationData;
static AuthenticationFuncsPtr	AuthenticationFuncs;
d420 1
a420 1
static void
d550 1
a550 1
static ARRAY8	DisplayClass;
d552 1
a552 1
static void
d564 18
d779 1
a779 1
static ARRAY8	UnwillingMessage = { (CARD8) 14, (CARD8 *) "Host unwilling" };
d870 1
a870 1
static void
d963 5
a967 2
static int
XdmcpCheckAuthentication (ARRAY8Ptr Name, ARRAY8Ptr Data, int packet_type)
d974 4
a977 2
static int
XdmcpAddAuthorization (ARRAY8Ptr name, ARRAY8Ptr data)
@

