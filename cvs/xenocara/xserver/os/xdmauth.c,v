head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.10
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2017.02.28.23.05.46;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	nkyHp6MD1y4dj2qR;

1.7
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	7pAEtF6Y5EgemkuY;

1.6
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.5;
commitid	cVXoV5PxI8YrEaVA;

1.5
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.12;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.12;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Oops, in previous commit I forgot to remove the actual implementation
of the unused *ToID functions(). Spotted by Adam Jackson on xorg-devel
list.  Thanks.
@
text
@/*

Copyright 1988, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/*
 * XDM-AUTHENTICATION-1 (XDMCP authentication) and
 * XDM-AUTHORIZATION-1 (client authorization) protocols
 *
 * Author:  Keith Packard, MIT X Consortium
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#include "os.h"
#include "osdep.h"
#include "dixstruct.h"

#ifdef HASXDMAUTH

static Bool authFromXDMCP;

#ifdef XDMCP
#include <X11/Xmd.h>
#undef REQUEST
#include <X11/Xdmcp.h>

/* XDM-AUTHENTICATION-1 */

static XdmAuthKeyRec privateKey;
static char XdmAuthenticationName[] = "XDM-AUTHENTICATION-1";

#define XdmAuthenticationNameLen (sizeof XdmAuthenticationName - 1)
static XdmAuthKeyRec global_rho;

static Bool
XdmAuthenticationValidator(ARRAY8Ptr privateData, ARRAY8Ptr incomingData,
                           xdmOpCode packet_type)
{
    XdmAuthKeyPtr incoming;

    XdmcpUnwrap(incomingData->data, (unsigned char *) &privateKey,
                incomingData->data, incomingData->length);
    if (packet_type == ACCEPT) {
        if (incomingData->length != 8)
            return FALSE;
        incoming = (XdmAuthKeyPtr) incomingData->data;
        XdmcpDecrementKey(incoming);
        return XdmcpCompareKeys(incoming, &global_rho);
    }
    return FALSE;
}

static Bool
XdmAuthenticationGenerator(ARRAY8Ptr privateData, ARRAY8Ptr outgoingData,
                           xdmOpCode packet_type)
{
    outgoingData->length = 0;
    outgoingData->data = 0;
    if (packet_type == REQUEST) {
        if (XdmcpAllocARRAY8(outgoingData, 8))
            XdmcpWrap((unsigned char *) &global_rho, (unsigned char *) &privateKey,
                      outgoingData->data, 8);
    }
    return TRUE;
}

static Bool
XdmAuthenticationAddAuth(int name_len, const char *name,
                         int data_len, char *data)
{
    Bool ret;

    XdmcpUnwrap((unsigned char *) data, (unsigned char *) &privateKey,
                (unsigned char *) data, data_len);
    authFromXDMCP = TRUE;
    ret = AddAuthorization(name_len, name, data_len, data);
    authFromXDMCP = FALSE;
    return ret;
}

#define atox(c)	('0' <= c && c <= '9' ? c - '0' : \
		 'a' <= c && c <= 'f' ? c - 'a' + 10 : \
		 'A' <= c && c <= 'F' ? c - 'A' + 10 : -1)

static int
HexToBinary(const char *in, char *out, int len)
{
    int top, bottom;

    while (len > 0) {
        top = atox(in[0]);
        if (top == -1)
            return 0;
        bottom = atox(in[1]);
        if (bottom == -1)
            return 0;
        *out++ = (top << 4) | bottom;
        in += 2;
        len -= 2;
    }
    if (len)
        return 0;
    *out++ = '\0';
    return 1;
}

void
XdmAuthenticationInit(const char *cookie, int cookie_len)
{
    memset(privateKey.data, 0, 8);
    if (!strncmp(cookie, "0x", 2) || !strncmp(cookie, "0X", 2)) {
        if (cookie_len > 2 + 2 * 8)
            cookie_len = 2 + 2 * 8;
        HexToBinary(cookie + 2, (char *) privateKey.data, cookie_len - 2);
    }
    else {
        if (cookie_len > 7)
            cookie_len = 7;
        memmove(privateKey.data + 1, cookie, cookie_len);
    }
    XdmcpGenerateKey(&global_rho);
    XdmcpRegisterAuthentication(XdmAuthenticationName, XdmAuthenticationNameLen,
                                (char *) &global_rho,
                                sizeof(global_rho),
                                (ValidatorFunc) XdmAuthenticationValidator,
                                (GeneratorFunc) XdmAuthenticationGenerator,
                                (AddAuthorFunc) XdmAuthenticationAddAuth);
}

#endif                          /* XDMCP */

/* XDM-AUTHORIZATION-1 */
typedef struct _XdmAuthorization {
    struct _XdmAuthorization *next;
    XdmAuthKeyRec rho;
    XdmAuthKeyRec key;
    XID id;
} XdmAuthorizationRec, *XdmAuthorizationPtr;

static XdmAuthorizationPtr xdmAuth;

typedef struct _XdmClientAuth {
    struct _XdmClientAuth *next;
    XdmAuthKeyRec rho;
    char client[6];
    long time;
} XdmClientAuthRec, *XdmClientAuthPtr;

static XdmClientAuthPtr xdmClients;
static long clockOffset;
static Bool gotClock;

#define TwentyMinutes	(20 * 60)
#define TwentyFiveMinutes (25 * 60)

static Bool
XdmClientAuthCompare(const XdmClientAuthPtr a, const XdmClientAuthPtr b)
{
    int i;

    if (!XdmcpCompareKeys(&a->rho, &b->rho))
        return FALSE;
    for (i = 0; i < 6; i++)
        if (a->client[i] != b->client[i])
            return FALSE;
    return a->time == b->time;
}

static void
XdmClientAuthDecode(const unsigned char *plain, XdmClientAuthPtr auth)
{
    int i, j;

    j = 0;
    for (i = 0; i < 8; i++) {
        auth->rho.data[i] = plain[j];
        ++j;
    }
    for (i = 0; i < 6; i++) {
        auth->client[i] = plain[j];
        ++j;
    }
    auth->time = 0;
    for (i = 0; i < 4; i++) {
        auth->time |= plain[j] << ((3 - i) << 3);
        j++;
    }
}

static void
XdmClientAuthTimeout(long now)
{
    XdmClientAuthPtr client, next, prev;

    prev = 0;
    for (client = xdmClients; client; client = next) {
        next = client->next;
        if (labs(now - client->time) > TwentyFiveMinutes) {
            if (prev)
                prev->next = next;
            else
                xdmClients = next;
            free(client);
        }
        else
            prev = client;
    }
}

static XdmClientAuthPtr
XdmAuthorizationValidate(unsigned char *plain, int length,
                         XdmAuthKeyPtr rho, ClientPtr xclient,
                         const char **reason)
{
    XdmClientAuthPtr client, existing;
    long now;
    int i;

    if (length != (192 / 8)) {
        if (reason)
            *reason = "Bad XDM authorization key length";
        return NULL;
    }
    client = malloc(sizeof(XdmClientAuthRec));
    if (!client)
        return NULL;
    XdmClientAuthDecode(plain, client);
    if (!XdmcpCompareKeys(&client->rho, rho)) {
        free(client);
        if (reason)
            *reason = "Invalid XDM-AUTHORIZATION-1 key (failed key comparison)";
        return NULL;
    }
    for (i = 18; i < 24; i++)
        if (plain[i] != 0) {
            free(client);
            if (reason)
                *reason = "Invalid XDM-AUTHORIZATION-1 key (failed NULL check)";
            return NULL;
        }
    if (xclient) {
        int family, addr_len;
        Xtransaddr *addr;

        if (_XSERVTransGetPeerAddr(((OsCommPtr) xclient->osPrivate)->trans_conn,
                                   &family, &addr_len, &addr) == 0
            && _XSERVTransConvertAddress(&family, &addr_len, &addr) == 0) {
#if defined(TCPCONN) || defined(STREAMSCONN)
            if (family == FamilyInternet &&
                memcmp((char *) addr, client->client, 4) != 0) {
                free(client);
                free(addr);
                if (reason)
                    *reason =
                        "Invalid XDM-AUTHORIZATION-1 key (failed address comparison)";
                return NULL;

            }
#endif
            free(addr);
        }
    }
    now = time(0);
    if (!gotClock) {
        clockOffset = client->time - now;
        gotClock = TRUE;
    }
    now += clockOffset;
    XdmClientAuthTimeout(now);
    if (labs(client->time - now) > TwentyMinutes) {
        free(client);
        if (reason)
            *reason = "Excessive XDM-AUTHORIZATION-1 time offset";
        return NULL;
    }
    for (existing = xdmClients; existing; existing = existing->next) {
        if (XdmClientAuthCompare(existing, client)) {
            free(client);
            if (reason)
                *reason = "XDM authorization key matches an existing client!";
            return NULL;
        }
    }
    return client;
}

int
XdmAddCookie(unsigned short data_length, const char *data, XID id)
{
    XdmAuthorizationPtr new;
    unsigned char *rho_bits, *key_bits;

    switch (data_length) {
    case 16:                   /* auth from files is 16 bytes long */
#ifdef XDMCP
        if (authFromXDMCP) {
            /* R5 xdm sent bogus authorization data in the accept packet,
             * but we can recover */
            rho_bits = global_rho.data;
            key_bits = (unsigned char *) data;
            key_bits[0] = '\0';
        }
        else
#endif
        {
            rho_bits = (unsigned char *) data;
            key_bits = (unsigned char *) (data + 8);
        }
        break;
#ifdef XDMCP
    case 8:                    /* auth from XDMCP is 8 bytes long */
        rho_bits = global_rho.data;
        key_bits = (unsigned char *) data;
        break;
#endif
    default:
        return 0;
    }
    /* the first octet of the key must be zero */
    if (key_bits[0] != '\0')
        return 0;
    new = malloc(sizeof(XdmAuthorizationRec));
    if (!new)
        return 0;
    new->next = xdmAuth;
    xdmAuth = new;
    memmove(new->key.data, key_bits, (int) 8);
    memmove(new->rho.data, rho_bits, (int) 8);
    new->id = id;
    return 1;
}

XID
XdmCheckCookie(unsigned short cookie_length, const char *cookie,
               ClientPtr xclient, const char **reason)
{
    XdmAuthorizationPtr auth;
    XdmClientAuthPtr client;
    unsigned char *plain;

    /* Auth packets must be a multiple of 8 bytes long */
    if (cookie_length & 7)
        return (XID) -1;
    plain = malloc(cookie_length);
    if (!plain)
        return (XID) -1;
    for (auth = xdmAuth; auth; auth = auth->next) {
        XdmcpUnwrap((unsigned char *) cookie, (unsigned char *) &auth->key,
                    plain, cookie_length);
        if ((client =
             XdmAuthorizationValidate(plain, cookie_length, &auth->rho, xclient,
                                      reason)) != NULL) {
            client->next = xdmClients;
            xdmClients = client;
            free(plain);
            return auth->id;
        }
    }
    free(plain);
    return (XID) -1;
}

int
XdmResetCookie(void)
{
    XdmAuthorizationPtr auth, next_auth;
    XdmClientAuthPtr client, next_client;

    for (auth = xdmAuth; auth; auth = next_auth) {
        next_auth = auth->next;
        free(auth);
    }
    xdmAuth = 0;
    for (client = xdmClients; client; client = next_client) {
        next_client = client->next;
        free(client);
    }
    xdmClients = (XdmClientAuthPtr) 0;
    return 1;
}

int
XdmFromID(XID id, unsigned short *data_lenp, char **datap)
{
    XdmAuthorizationPtr auth;

    for (auth = xdmAuth; auth; auth = auth->next) {
        if (id == auth->id) {
            *data_lenp = 16;
            *datap = (char *) &auth->rho;
            return 1;
        }
    }
    return 0;
}

int
XdmRemoveCookie(unsigned short data_length, const char *data)
{
    XdmAuthorizationPtr auth;
    XdmAuthKeyPtr key_bits, rho_bits;

    switch (data_length) {
    case 16:
        rho_bits = (XdmAuthKeyPtr) data;
        key_bits = (XdmAuthKeyPtr) (data + 8);
        break;
#ifdef XDMCP
    case 8:
        rho_bits = &global_rho;
        key_bits = (XdmAuthKeyPtr) data;
        break;
#endif
    default:
        return 0;
    }
    for (auth = xdmAuth; auth; auth = auth->next) {
        if (XdmcpCompareKeys(rho_bits, &auth->rho) &&
            XdmcpCompareKeys(key_bits, &auth->key)) {
            xdmAuth = auth->next;
            free(auth);
            return 1;
        }
    }
    return 0;
}

#endif
@


1.7
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@a413 27
XID
XdmToID(unsigned short cookie_length, char *cookie)
{
    XdmAuthorizationPtr auth;
    XdmClientAuthPtr client;
    unsigned char *plain;

    plain = malloc(cookie_length);
    if (!plain)
        return (XID) -1;
    for (auth = xdmAuth; auth; auth = auth->next) {
        XdmcpUnwrap((unsigned char *) cookie, (unsigned char *) &auth->key,
                    plain, cookie_length);
        if ((client =
             XdmAuthorizationValidate(plain, cookie_length, &auth->rho, NULL,
                                      NULL)) != NULL) {
            free(client);
            free(cookie);
            free(plain);
            return auth->id;
        }
    }
    free(cookie);
    free(plain);
    return (XID) -1;
}

@


1.6
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d230 1
a230 1
        if (abs(now - client->time) > TwentyFiveMinutes) {
d302 1
a302 1
    if (abs(client->time - now) > TwentyMinutes) {
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d65 1
a65 1
static XdmAuthKeyRec rho;
d80 1
a80 1
        return XdmcpCompareKeys(incoming, &rho);
d93 1
a93 1
            XdmcpWrap((unsigned char *) &rho, (unsigned char *) &privateKey,
d153 1
a153 1
    XdmcpGenerateKey(&rho);
d155 2
a156 2
                                (char *) &rho,
                                sizeof(rho),
d331 1
a331 1
            rho_bits = rho.data;
d344 1
a344 1
        rho_bits = rho.data;
d469 1
a469 1
        rho_bits = &rho;
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d61 1
a61 1
static XdmAuthKeyRec	privateKey;
d63 1
d65 1
a65 1
static XdmAuthKeyRec	rho;
d67 3
a69 3
static Bool 
XdmAuthenticationValidator (ARRAY8Ptr privateData, ARRAY8Ptr incomingData, 
    xdmOpCode packet_type)
d71 1
a71 1
    XdmAuthKeyPtr	incoming;
d73 2
a74 2
    XdmcpUnwrap (incomingData->data, (unsigned char *)&privateKey,
			      incomingData->data,incomingData->length);
d76 5
a80 5
    	if (incomingData->length != 8)
	    return FALSE;
    	incoming = (XdmAuthKeyPtr) incomingData->data;
    	XdmcpDecrementKey (incoming);
    	return XdmcpCompareKeys (incoming, &rho);
d86 2
a87 2
XdmAuthenticationGenerator (ARRAY8Ptr privateData, ARRAY8Ptr outgoingData, 
    xdmOpCode packet_type)
d92 3
a94 3
	if (XdmcpAllocARRAY8 (outgoingData, 8))
	    XdmcpWrap ((unsigned char *)&rho, (unsigned char *)&privateKey,
		       outgoingData->data, 8);
d100 2
a101 2
XdmAuthenticationAddAuth (int name_len, const char *name,
    int data_len, char *data)
d103 4
a106 3
    Bool    ret;
    XdmcpUnwrap ((unsigned char *)data, (unsigned char *)&privateKey,
		 (unsigned char *)data, data_len);
d108 1
a108 1
    ret = AddAuthorization (name_len, name, data_len, data);
a112 1

d118 1
a118 1
HexToBinary (const char *in, char *out, int len)
d120 1
a120 1
    int	    top, bottom;
d122 10
a131 11
    while (len > 0)
    {
	top = atox(in[0]);
	if (top == -1)
	    return 0;
	bottom = atox(in[1]);
	if (bottom == -1)
	    return 0;
	*out++ = (top << 4) | bottom;
	in += 2;
	len -= 2;
d134 1
a134 1
	return 0;
d140 1
a140 1
XdmAuthenticationInit (const char *cookie, int cookie_len)
d143 17
a159 19
    if (!strncmp (cookie, "0x", 2) || !strncmp (cookie, "0X", 2))
    {
	if (cookie_len > 2 + 2 * 8)
	    cookie_len = 2 + 2 * 8;
	HexToBinary (cookie + 2, (char *)privateKey.data, cookie_len - 2);
    }
    else
    {
    	if (cookie_len > 7)
	    cookie_len = 7;
    	memmove (privateKey.data + 1, cookie, cookie_len);
    }
    XdmcpGenerateKey (&rho);
    XdmcpRegisterAuthentication (XdmAuthenticationName, XdmAuthenticationNameLen,
				 (char *)&rho,
				 sizeof (rho),
				 (ValidatorFunc)XdmAuthenticationValidator,
				 (GeneratorFunc)XdmAuthenticationGenerator,
				 (AddAuthorFunc)XdmAuthenticationAddAuth);
d162 1
a162 1
#endif /* XDMCP */
d166 4
a169 4
    struct _XdmAuthorization	*next;
    XdmAuthKeyRec		rho;
    XdmAuthKeyRec		key;
    XID				id;
d175 4
a178 4
    struct _XdmClientAuth   *next;
    XdmAuthKeyRec	    rho;
    char		    client[6];
    long		    time;
d181 3
a183 3
static XdmClientAuthPtr    xdmClients;
static long	    clockOffset;
static Bool	    gotClock;
d189 1
a189 1
XdmClientAuthCompare (const XdmClientAuthPtr a, const XdmClientAuthPtr b)
d191 1
a191 1
    int	i;
d193 2
a194 2
    if (!XdmcpCompareKeys (&a->rho, &b->rho))
	return FALSE;
d196 2
a197 2
	if (a->client[i] != b->client[i])
	    return FALSE;
d202 1
a202 1
XdmClientAuthDecode (const unsigned char *plain, XdmClientAuthPtr auth)
d204 1
a204 1
    int	    i, j;
d207 7
a213 9
    for (i = 0; i < 8; i++)
    {
	auth->rho.data[i] = plain[j];
	++j;
    }
    for (i = 0; i < 6; i++)
    {
	auth->client[i] = plain[j];
	++j;
d216 3
a218 4
    for (i = 0; i < 4; i++)
    {
	auth->time |= plain[j] << ((3 - i) << 3);
	j++;
d223 1
a223 1
XdmClientAuthTimeout (long now)
d225 1
a225 1
    XdmClientAuthPtr	client, next, prev;
d228 11
a238 13
    for (client = xdmClients; client; client=next)
    {
	next = client->next;
	if (abs (now - client->time) > TwentyFiveMinutes)
	{
	    if (prev)
		prev->next = next;
	    else
		xdmClients = next;
	    free(client);
	}
	else
	    prev = client;
d243 7
a249 6
XdmAuthorizationValidate (unsigned char *plain, int length, 
    XdmAuthKeyPtr rho, ClientPtr xclient, char **reason)
{
    XdmClientAuthPtr	client, existing;
    long		now;
    int			i;
d252 3
a254 3
	if (reason)
	    *reason = "Bad XDM authorization key length";
	return NULL;
d256 1
a256 1
    client = malloc(sizeof (XdmClientAuthRec));
d258 7
a264 8
	return NULL;
    XdmClientAuthDecode (plain, client);
    if (!XdmcpCompareKeys (&client->rho, rho))
    {
	free(client);
	if (reason)
	    *reason = "Invalid XDM-AUTHORIZATION-1 key (failed key comparison)";
	return NULL;
d267 6
a272 6
	if (plain[i] != 0) {
	    free(client);
	    if (reason)
		*reason = "Invalid XDM-AUTHORIZATION-1 key (failed NULL check)";
	    return NULL;
	}
d274 2
a275 2
	int family, addr_len;
	Xtransaddr *addr;
d277 3
a279 3
	if (_XSERVTransGetPeerAddr(((OsCommPtr)xclient->osPrivate)->trans_conn,
				   &family, &addr_len, &addr) == 0
	    && _XSERVTransConvertAddress(&family, &addr_len, &addr) == 0) {
d281 8
a288 7
	    if (family == FamilyInternet &&
		memcmp((char *)addr, client->client, 4) != 0) {
		free(client);
		free(addr);
		if (reason)
		    *reason = "Invalid XDM-AUTHORIZATION-1 key (failed address comparison)";
		return NULL;
d290 1
a290 1
	    }
d292 2
a293 2
	    free(addr);
	}
d296 3
a298 4
    if (!gotClock)
    {
	clockOffset = client->time - now;
	gotClock = TRUE;
d301 14
a314 17
    XdmClientAuthTimeout (now);
    if (abs (client->time - now) > TwentyMinutes)
    {
	free(client);
	if (reason)
	    *reason = "Excessive XDM-AUTHORIZATION-1 time offset";
	return NULL;
    }
    for (existing = xdmClients; existing; existing=existing->next)
    {
	if (XdmClientAuthCompare (existing, client))
	{
	    free(client);
	    if (reason)
		*reason = "XDM authorization key matches an existing client!";
	    return NULL;
	}
d320 1
a320 1
XdmAddCookie (unsigned short data_length, const char *data, XID id)
d322 2
a323 2
    XdmAuthorizationPtr	new;
    unsigned char	*rho_bits, *key_bits;
d325 2
a326 3
    switch (data_length)
    {
    case 16:		    /* auth from files is 16 bytes long */
d328 8
a335 9
	if (authFromXDMCP)
	{
	    /* R5 xdm sent bogus authorization data in the accept packet,
	     * but we can recover */
	    rho_bits = rho.data;
	    key_bits = (unsigned char *) data;
	    key_bits[0] = '\0';
	}
	else
d337 5
a341 5
	{
	    rho_bits = (unsigned char *) data;
	    key_bits = (unsigned char *) (data + 8);
	}
	break;
d343 4
a346 4
    case 8:		    /* auth from XDMCP is 8 bytes long */
	rho_bits = rho.data;
	key_bits = (unsigned char *) data;
	break;
d349 1
a349 1
	return 0;
d353 2
a354 2
	return 0;
    new = malloc(sizeof (XdmAuthorizationRec));
d356 1
a356 1
	return 0;
d359 2
a360 2
    memmove (new->key.data, key_bits, (int) 8);
    memmove (new->rho.data, rho_bits, (int) 8);
d366 2
a367 2
XdmCheckCookie (unsigned short cookie_length, const char *cookie,
    ClientPtr xclient, char **reason)
d369 3
a371 3
    XdmAuthorizationPtr	auth;
    XdmClientAuthPtr	client;
    unsigned char	*plain;
d375 1
a375 1
	return (XID) -1;
d378 12
a389 10
	return (XID) -1;
    for (auth = xdmAuth; auth; auth=auth->next) {
	XdmcpUnwrap ((unsigned char *)cookie, (unsigned char *)&auth->key, plain, cookie_length);
	if ((client = XdmAuthorizationValidate (plain, cookie_length, &auth->rho, xclient, reason)) != NULL)
	{
	    client->next = xdmClients;
	    xdmClients = client;
	    free(plain);
	    return auth->id;
	}
d396 1
a396 1
XdmResetCookie (void)
d398 2
a399 2
    XdmAuthorizationPtr	auth, next_auth;
    XdmClientAuthPtr	client, next_client;
d401 3
a403 4
    for (auth = xdmAuth; auth; auth=next_auth)
    {
	next_auth = auth->next;
	free(auth);
d406 3
a408 4
    for (client = xdmClients; client; client=next_client)
    {
	next_client = client->next;
	free(client);
d415 1
a415 1
XdmToID (unsigned short cookie_length, char *cookie)
d417 3
a419 3
    XdmAuthorizationPtr	auth;
    XdmClientAuthPtr	client;
    unsigned char	*plain;
d423 12
a434 10
	return (XID) -1;
    for (auth = xdmAuth; auth; auth=auth->next) {
	XdmcpUnwrap ((unsigned char *)cookie, (unsigned char *)&auth->key, plain, cookie_length);
	if ((client = XdmAuthorizationValidate (plain, cookie_length, &auth->rho, NULL, NULL)) != NULL)
	{
	    free(client);
	    free(cookie);
	    free(plain);
	    return auth->id;
	}
d442 1
a442 1
XdmFromID (XID id, unsigned short *data_lenp, char **datap)
d444 1
a444 1
    XdmAuthorizationPtr	auth;
d446 6
a451 6
    for (auth = xdmAuth; auth; auth=auth->next) {
	if (id == auth->id) {
	    *data_lenp = 16;
	    *datap = (char *) &auth->rho;
	    return 1;
	}
d457 1
a457 1
XdmRemoveCookie (unsigned short data_length, const char *data)
d459 2
a460 2
    XdmAuthorizationPtr	auth;
    XdmAuthKeyPtr	key_bits, rho_bits;
d462 1
a462 2
    switch (data_length)
    {
d464 3
a466 3
	rho_bits = (XdmAuthKeyPtr) data;
	key_bits = (XdmAuthKeyPtr) (data + 8);
	break;
d469 3
a471 3
	rho_bits = &rho;
	key_bits = (XdmAuthKeyPtr) data;
	break;
d474 1
a474 1
	return 0;
d476 7
a482 8
    for (auth = xdmAuth; auth; auth=auth->next) {
	if (XdmcpCompareKeys (rho_bits, &auth->rho) &&
	    XdmcpCompareKeys (key_bits, &auth->key))
 	{
	    xdmAuth = auth->next;
	    free(auth);
	    return 1;
	}
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d99 1
a99 1
XdmAuthenticationAddAuth (int name_len, char *name, 
d117 1
a117 1
HexToBinary (char *in, char *out, int len)
d140 1
a140 1
XdmAuthenticationInit (char *cookie, int cookie_len)
d142 1
a142 1
    bzero (privateKey.data, 8);
d191 1
a191 1
XdmClientAuthCompare (XdmClientAuthPtr a, XdmClientAuthPtr b)
d204 1
a204 1
XdmClientAuthDecode (unsigned char *plain, XdmClientAuthPtr auth)
d242 1
a242 1
	    xfree (client);
d262 1
a262 1
    client = xalloc (sizeof (XdmClientAuthRec));
d268 1
a268 1
	xfree (client);
d275 1
a275 1
	    xfree (client);
d290 2
a291 2
		xfree (client);
		xfree (addr);
d298 1
a298 1
	    xfree (addr);
d311 1
a311 1
	xfree (client);
d320 1
a320 1
	    xfree (client);
d330 1
a330 1
XdmAddCookie (unsigned short data_length, char *data, XID id)
d366 1
a366 1
    new = xalloc (sizeof (XdmAuthorizationRec));
d378 1
a378 1
XdmCheckCookie (unsigned short cookie_length, char *cookie, 
d388 1
a388 1
    plain = xalloc (cookie_length);
d397 1
a397 1
	    xfree (plain);
d401 1
a401 1
    xfree (plain);
d414 1
a414 1
	xfree (auth);
d420 1
a420 1
	xfree (client);
d433 1
a433 1
    plain = xalloc (cookie_length);
d440 3
a442 3
	    xfree (client);
	    xfree (cookie);
	    xfree (plain);
d446 2
a447 2
    xfree (cookie);
    xfree (plain);
d467 1
a467 1
XdmRemoveCookie (unsigned short data_length, char *data)
d492 1
a492 1
	    xfree (auth);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d262 1
a262 1
    client = (XdmClientAuthPtr) xalloc (sizeof (XdmClientAuthRec));
d366 1
a366 1
    new = (XdmAuthorizationPtr) xalloc (sizeof (XdmAuthorizationRec));
d388 1
a388 1
    plain = (unsigned char *) xalloc (cookie_length);
d433 1
a433 1
    plain = (unsigned char *) xalloc (cookie_length);
@


1.1
log
@Initial revision
@
text
@d72 1
a72 1
    XdmcpUnwrap (incomingData->data, &privateKey,
d92 2
a93 1
	    XdmcpWrap (&rho, &privateKey, outgoingData->data, 8);
d103 2
a104 1
    XdmcpUnwrap (data, (unsigned char *)&privateKey, data, data_len);
d157 1
a157 1
				 (unsigned char *)&rho,
d392 1
a392 1
	XdmcpUnwrap (cookie, (unsigned char *)&auth->key, plain, cookie_length);
d437 1
a437 1
	XdmcpUnwrap (cookie, (unsigned char *)&auth->key, plain, cookie_length);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
