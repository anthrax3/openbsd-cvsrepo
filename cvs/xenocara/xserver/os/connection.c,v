head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.2
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.2
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.2
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.12.0.2
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.18;
commitid	s0SI41sEunLdyFfd;

1.18
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	7pAEtF6Y5EgemkuY;

1.17
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	Te1daavkBLskZ8gc;

1.16
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	cVXoV5PxI8YrEaVA;

1.15
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2012.08.07.20.15.23;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.13.21.48.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.24.19.04.06;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.18.22.21.17;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.07;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.11;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.07.34;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/***********************************************************

Copyright 1987, 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
/*****************************************************************
 *  Stuff to create connections --- OS dependent
 *
 *      EstablishNewConnections, CreateWellKnownSockets, ResetWellKnownSockets,
 *      CloseDownConnection, CheckConnections, AddEnabledDevice,
 *	RemoveEnabledDevice, OnlyListToOneClient,
 *      ListenToAllClients,
 *
 *      (WaitForSomething is in its own file)
 *
 *      In this implementation, a client socket table is not kept.
 *      Instead, what would be the index into the table is just the
 *      file descriptor of the socket.  This won't work for if the
 *      socket ids aren't small nums (0 - 2^8)
 *
 *****************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef WIN32
#include <X11/Xwinsock.h>
#endif
#include <X11/X.h>
#include <X11/Xproto.h>
#define XSERV_t
#define TRANS_SERVER
#define TRANS_REOPEN
#include <X11/Xtrans/Xtrans.h>
#include <X11/Xtrans/Xtransint.h>
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef WIN32
#include <sys/socket.h>

#if defined(TCPCONN) || defined(STREAMSCONN)
#include <netinet/in.h>
#include <arpa/inet.h>
#ifdef apollo
#ifndef NO_TCP_H
#include <netinet/tcp.h>
#endif
#else
#ifdef CSRG_BASED
#include <sys/param.h>
#endif
#include <netinet/tcp.h>
#endif
#include <arpa/inet.h>
#endif

#include <sys/uio.h>

#endif                          /* WIN32 */
#include "misc.h"               /* for typedef of pointer */
#include "osdep.h"
#include <X11/Xpoll.h>
#include "opaque.h"
#include "dixstruct.h"
#include "xace.h"

#define Pid_t pid_t

#ifdef HAVE_GETPEERUCRED
#include <ucred.h>
#include <zone.h>
#else
#define zoneid_t int
#endif

#include "probes.h"

static int lastfdesc;           /* maximum file descriptor */

fd_set WellKnownConnections;    /* Listener mask */
fd_set EnabledDevices;          /* mask for input devices that are on */
fd_set AllSockets;              /* select on this */
fd_set AllClients;              /* available clients */
fd_set LastSelectMask;          /* mask returned from last select call */
fd_set ClientsWithInput;        /* clients with FULL requests in buffer */
fd_set ClientsWriteBlocked;     /* clients who cannot receive output */
fd_set OutputPending;           /* clients with reply/event data ready to go */
int MaxClients = 0;
Bool NewOutputPending;          /* not yet attempted to write some new output */
Bool AnyClientsWriteBlocked;    /* true if some client blocked on write */
Bool NoListenAll;               /* Don't establish any listening sockets */

static Bool RunFromSmartParent; /* send SIGUSR1 to parent process */
Bool RunFromSigStopParent;      /* send SIGSTOP to our own process; Upstart (or
                                   equivalent) will send SIGCONT back. */
static char dynamic_display[7]; /* display name */
Bool PartialNetwork;            /* continue even if unable to bind all addrs */
static Pid_t ParentProcess;

static Bool debug_conns = FALSE;

fd_set IgnoredClientsWithInput;
static fd_set GrabImperviousClients;
static fd_set SavedAllClients;
static fd_set SavedAllSockets;
static fd_set SavedClientsWithInput;
int GrabInProgress = 0;

#if !defined(WIN32)
int *ConnectionTranslation = NULL;
#else
/*
 * On NT fds are not between 0 and MAXSOCKS, they are unrelated, and there is
 * not even a known maximum value, so use something quite arbitrary for now.
 * Do storage is a hash table of size 256. Collisions are handled in a linked
 * list.
 */

#undef MAXSOCKS
#define MAXSOCKS 512
#undef MAXSELECT
#define MAXSELECT 512

struct _ct_node {
    struct _ct_node *next;
    int key;
    int value;
};

struct _ct_node *ct_head[256];

void
InitConnectionTranslation(void)
{
    memset(ct_head, 0, sizeof(ct_head));
}

int
GetConnectionTranslation(int conn)
{
    struct _ct_node *node = ct_head[conn & 0xff];

    while (node != NULL) {
        if (node->key == conn)
            return node->value;
        node = node->next;
    }
    return 0;
}

void
SetConnectionTranslation(int conn, int client)
{
    struct _ct_node **node = ct_head + (conn & 0xff);

    if (client == 0) {          /* remove entry */
        while (*node != NULL) {
            if ((*node)->key == conn) {
                struct _ct_node *temp = *node;

                *node = (*node)->next;
                free(temp);
                return;
            }
            node = &((*node)->next);
        }
        return;
    }
    else {
        while (*node != NULL) {
            if ((*node)->key == conn) {
                (*node)->value = client;
                return;
            }
            node = &((*node)->next);
        }
        *node = malloc(sizeof(struct _ct_node));
        (*node)->next = NULL;
        (*node)->key = conn;
        (*node)->value = client;
        return;
    }
}

void
ClearConnectionTranslation(void)
{
    unsigned i;

    for (i = 0; i < 256; i++) {
        struct _ct_node *node = ct_head[i];

        while (node != NULL) {
            struct _ct_node *temp = node;

            node = node->next;
            free(temp);
        }
    }
}
#endif

static XtransConnInfo *ListenTransConns = NULL;
static int *ListenTransFds = NULL;
static int ListenTransCount;

static void ErrorConnMax(XtransConnInfo /* trans_conn */ );

static XtransConnInfo
lookup_trans_conn(int fd)
{
    if (ListenTransFds) {
        int i;

        for (i = 0; i < ListenTransCount; i++)
            if (ListenTransFds[i] == fd)
                return ListenTransConns[i];
    }

    return NULL;
}

/* Set MaxClients and lastfdesc, and allocate ConnectionTranslation */

void
InitConnectionLimits(void)
{
    lastfdesc = -1;

#ifndef __CYGWIN__

#if !defined(XNO_SYSCONF) && defined(_SC_OPEN_MAX)
    lastfdesc = sysconf(_SC_OPEN_MAX) - 1;
#endif

#ifdef HAVE_GETDTABLESIZE
    if (lastfdesc < 0)
        lastfdesc = getdtablesize() - 1;
#endif

#ifdef _NFILE
    if (lastfdesc < 0)
        lastfdesc = _NFILE - 1;
#endif

#endif                          /* __CYGWIN__ */

    /* This is the fallback */
    if (lastfdesc < 0)
        lastfdesc = MAXSOCKS;

    if (lastfdesc > MAXSELECT)
        lastfdesc = MAXSELECT;

    if (lastfdesc > MAXCLIENTS) {
        lastfdesc = MAXCLIENTS;
        if (debug_conns)
            ErrorF("REACHED MAXIMUM CLIENTS LIMIT %d\n", LimitClients);
    }
    MaxClients = lastfdesc;

#ifdef DEBUG
    ErrorF("InitConnectionLimits: MaxClients = %d\n", MaxClients);
#endif

#if !defined(WIN32)
    if (!ConnectionTranslation)
        ConnectionTranslation = xnfallocarray(lastfdesc + 1, sizeof(int));
#else
    InitConnectionTranslation();
#endif
}

/*
 * If SIGUSR1 was set to SIG_IGN when the server started, assume that either
 *
 *  a- The parent process is ignoring SIGUSR1
 *
 * or
 *
 *  b- The parent process is expecting a SIGUSR1
 *     when the server is ready to accept connections
 *
 * In the first case, the signal will be harmless, in the second case,
 * the signal will be quite useful.
 */
static void
InitParentProcess(void)
{
#if !defined(WIN32)
    OsSigHandlerPtr handler;

    handler = OsSignal(SIGUSR1, SIG_IGN);
    if (handler == SIG_IGN)
        RunFromSmartParent = TRUE;
    OsSignal(SIGUSR1, handler);
    ParentProcess = getppid();
#ifdef X_PRIVSEP
    priv_init_parent_process(ParentProcess);
#endif
#endif
}

void
NotifyParentProcess(void)
{
#if !defined(WIN32)
    if (displayfd >= 0) {
        if (write(displayfd, display, strlen(display)) != strlen(display))
            FatalError("Cannot write display number to fd %d\n", displayfd);
        if (write(displayfd, "\n", 1) != 1)
            FatalError("Cannot write display number to fd %d\n", displayfd);
        close(displayfd);
        displayfd = -1;
    }
    if (RunFromSmartParent) {
	if (ParentProcess > 1) {
#ifdef X_PRIVSEP
            priv_signal_parent();
#else
            kill (ParentProcess, SIGUSR1);
#endif
	}
    }
    if (RunFromSigStopParent)
        raise(SIGSTOP);
#endif
}

static Bool
TryCreateSocket(int num, int *partial)
{
    char port[20];

    snprintf(port, sizeof(port), "%d", num);

    return (_XSERVTransMakeAllCOTSServerListeners(port, partial,
                                                  &ListenTransCount,
                                                  &ListenTransConns) >= 0);
}

/*****************
 * CreateWellKnownSockets
 *    At initialization, create the sockets to listen on for new clients.
 *****************/

void
CreateWellKnownSockets(void)
{
    int i;
    int partial;

    FD_ZERO(&AllSockets);
    FD_ZERO(&AllClients);
    FD_ZERO(&LastSelectMask);
    FD_ZERO(&ClientsWithInput);

#if !defined(WIN32)
    for (i = 0; i < MaxClients; i++)
        ConnectionTranslation[i] = 0;
#else
    ClearConnectionTranslation();
#endif

    FD_ZERO(&WellKnownConnections);

    /* display is initialized to "0" by main(). It is then set to the display
     * number if specified on the command line. */

    if (NoListenAll) {
        ListenTransCount = 0;
    }
    else if ((displayfd < 0) || explicit_display) {
        if (TryCreateSocket(atoi(display), &partial) &&
            ListenTransCount >= 1)
            if (!PartialNetwork && partial)
                FatalError ("Failed to establish all listening sockets");
    }
    else { /* -displayfd and no explicit display number */
        Bool found = 0;
        for (i = 0; i < 65536 - X_TCP_PORT; i++) {
            if (TryCreateSocket(i, &partial) && !partial) {
                found = 1;
                break;
            }
            else
                CloseWellKnownConnections();
        }
        if (!found)
            FatalError("Failed to find a socket to listen on");
        snprintf(dynamic_display, sizeof(dynamic_display), "%d", i);
        display = dynamic_display;
        LogSetDisplay();
    }

    ListenTransFds = xallocarray(ListenTransCount, sizeof (int));
    if (ListenTransFds == NULL)
        FatalError ("Failed to create listening socket array");

    for (i = 0; i < ListenTransCount; i++) {
        int fd = _XSERVTransGetConnectionNumber(ListenTransConns[i]);

        ListenTransFds[i] = fd;
        FD_SET(fd, &WellKnownConnections);

        if (!_XSERVTransIsLocal(ListenTransConns[i]))
            DefineSelf (fd);
    }

    if (!XFD_ANYSET(&WellKnownConnections) && !NoListenAll)
        FatalError
            ("Cannot establish any listening sockets - Make sure an X server isn't already running");

#if !defined(WIN32)
    OsSignal(SIGPIPE, SIG_IGN);
    OsSignal(SIGHUP, AutoResetServer);
#endif
    OsSignal(SIGINT, GiveUp);
    OsSignal(SIGTERM, GiveUp);
    XFD_COPYSET(&WellKnownConnections, &AllSockets);
    ResetHosts(display);

    InitParentProcess();

#ifdef XDMCP
    XdmcpInit();
#endif
}

void
ResetWellKnownSockets(void)
{
    int i;

    ResetOsBuffers();

    for (i = 0; i < ListenTransCount; i++) {
        int status = _XSERVTransResetListener(ListenTransConns[i]);

        if (status != TRANS_RESET_NOOP) {
            if (status == TRANS_RESET_FAILURE) {
                /*
                 * ListenTransConns[i] freed by xtrans.
                 * Remove it from out list.
                 */

                FD_CLR(ListenTransFds[i], &WellKnownConnections);
                ListenTransFds[i] = ListenTransFds[ListenTransCount - 1];
                ListenTransConns[i] = ListenTransConns[ListenTransCount - 1];
                ListenTransCount -= 1;
                i -= 1;
            }
            else if (status == TRANS_RESET_NEW_FD) {
                /*
                 * A new file descriptor was allocated (the old one was closed)
                 */

                int newfd = _XSERVTransGetConnectionNumber(ListenTransConns[i]);

                FD_CLR(ListenTransFds[i], &WellKnownConnections);
                ListenTransFds[i] = newfd;
                FD_SET(newfd, &WellKnownConnections);
            }
        }
    }

    ResetAuthorization();
    ResetHosts(display);
    /*
     * restart XDMCP
     */
#ifdef XDMCP
    XdmcpReset();
#endif
}

void
CloseWellKnownConnections(void)
{
    int i;

    for (i = 0; i < ListenTransCount; i++) {
        if (ListenTransConns[i] != NULL) {
            _XSERVTransClose(ListenTransConns[i]);
            ListenTransConns[i] = NULL;
        }
    }
    ListenTransCount = 0;
}

static void
AuthAudit(ClientPtr client, Bool letin,
          struct sockaddr *saddr, int len,
          unsigned int proto_n, char *auth_proto, int auth_id)
{
    char addr[128];
    char client_uid_string[64];
    LocalClientCredRec *lcc;

#ifdef XSERVER_DTRACE
    pid_t client_pid = -1;
    zoneid_t client_zid = -1;
#endif

    if (!len)
        strlcpy(addr, "local host", sizeof(addr));
    else
        switch (saddr->sa_family) {
        case AF_UNSPEC:
#if defined(UNIXCONN) || defined(LOCALCONN)
        case AF_UNIX:
#endif
            strlcpy(addr, "local host", sizeof(addr));
            break;
#if defined(TCPCONN) || defined(STREAMSCONN)
        case AF_INET:
            snprintf(addr, sizeof(addr), "IP %s",
                     inet_ntoa(((struct sockaddr_in *) saddr)->sin_addr));
            break;
#if defined(IPv6) && defined(AF_INET6)
        case AF_INET6:{
            char ipaddr[INET6_ADDRSTRLEN];

            inet_ntop(AF_INET6, &((struct sockaddr_in6 *) saddr)->sin6_addr,
                      ipaddr, sizeof(ipaddr));
            snprintf(addr, sizeof(addr), "IP %s", ipaddr);
        }
            break;
#endif
#endif
        default:
            strlcpy(addr, "unknown address", sizeof(addr));
        }

    if (GetLocalClientCreds(client, &lcc) != -1) {
        int slen;               /* length written to client_uid_string */

        strcpy(client_uid_string, " ( ");
        slen = 3;

        if (lcc->fieldsSet & LCC_UID_SET) {
            snprintf(client_uid_string + slen,
                     sizeof(client_uid_string) - slen,
                     "uid=%ld ", (long) lcc->euid);
            slen = strlen(client_uid_string);
        }

        if (lcc->fieldsSet & LCC_GID_SET) {
            snprintf(client_uid_string + slen,
                     sizeof(client_uid_string) - slen,
                     "gid=%ld ", (long) lcc->egid);
            slen = strlen(client_uid_string);
        }

        if (lcc->fieldsSet & LCC_PID_SET) {
#ifdef XSERVER_DTRACE
            client_pid = lcc->pid;
#endif
            snprintf(client_uid_string + slen,
                     sizeof(client_uid_string) - slen,
                     "pid=%ld ", (long) lcc->pid);
            slen = strlen(client_uid_string);
        }

        if (lcc->fieldsSet & LCC_ZID_SET) {
#ifdef XSERVER_DTRACE
            client_zid = lcc->zoneid;
#endif
            snprintf(client_uid_string + slen,
                     sizeof(client_uid_string) - slen,
                     "zoneid=%ld ", (long) lcc->zoneid);
            slen = strlen(client_uid_string);
        }

        snprintf(client_uid_string + slen, sizeof(client_uid_string) - slen,
                 ")");
        FreeLocalClientCreds(lcc);
    }
    else {
        client_uid_string[0] = '\0';
    }

#ifdef XSERVER_DTRACE
    XSERVER_CLIENT_AUTH(client->index, addr, client_pid, client_zid);
#endif
    if (auditTrailLevel > 1) {
        if (proto_n)
            AuditF("client %d %s from %s%s\n  Auth name: %.*s ID: %d\n",
                   client->index, letin ? "connected" : "rejected", addr,
                   client_uid_string, (int) proto_n, auth_proto, auth_id);
        else
            AuditF("client %d %s from %s%s\n",
                   client->index, letin ? "connected" : "rejected", addr,
                   client_uid_string);

    }
}

XID
AuthorizationIDOfClient(ClientPtr client)
{
    if (client->osPrivate)
        return ((OsCommPtr) client->osPrivate)->auth_id;
    else
        return None;
}

/*****************************************************************
 * ClientAuthorized
 *
 *    Sent by the client at connection setup:
 *                typedef struct _xConnClientPrefix {
 *                   CARD8	byteOrder;
 *                   BYTE	pad;
 *                   CARD16	majorVersion, minorVersion;
 *                   CARD16	nbytesAuthProto;
 *                   CARD16	nbytesAuthString;
 *                 } xConnClientPrefix;
 *
 *     	It is hoped that eventually one protocol will be agreed upon.  In the
 *        mean time, a server that implements a different protocol than the
 *        client expects, or a server that only implements the host-based
 *        mechanism, will simply ignore this information.
 *
 *****************************************************************/

const char *
ClientAuthorized(ClientPtr client,
                 unsigned int proto_n, char *auth_proto,
                 unsigned int string_n, char *auth_string)
{
    OsCommPtr priv;
    Xtransaddr *from = NULL;
    int family;
    int fromlen;
    XID auth_id;
    const char *reason = NULL;
    XtransConnInfo trans_conn;

    priv = (OsCommPtr) client->osPrivate;
    trans_conn = priv->trans_conn;

    /* Allow any client to connect without authorization on a launchd socket,
       because it is securely created -- this prevents a race condition on launch */
    if (trans_conn->flags & TRANS_NOXAUTH) {
        auth_id = (XID) 0L;
    }
    else {
        auth_id =
            CheckAuthorization(proto_n, auth_proto, string_n, auth_string,
                               client, &reason);
    }

    if (auth_id == (XID) ~0L) {
        if (_XSERVTransGetPeerAddr(trans_conn, &family, &fromlen, &from) != -1) {
            if (InvalidHost((struct sockaddr *) from, fromlen, client))
                AuthAudit(client, FALSE, (struct sockaddr *) from,
                          fromlen, proto_n, auth_proto, auth_id);
            else {
                auth_id = (XID) 0;
#ifdef XSERVER_DTRACE
                if ((auditTrailLevel > 1) || XSERVER_CLIENT_AUTH_ENABLED())
#else
                if (auditTrailLevel > 1)
#endif
                    AuthAudit(client, TRUE,
                              (struct sockaddr *) from, fromlen,
                              proto_n, auth_proto, auth_id);
            }

            free(from);
        }

        if (auth_id == (XID) ~0L) {
            if (reason)
                return reason;
            else
                return "Client is not authorized to connect to Server";
        }
    }
#ifdef XSERVER_DTRACE
    else if ((auditTrailLevel > 1) || XSERVER_CLIENT_AUTH_ENABLED())
#else
    else if (auditTrailLevel > 1)
#endif
    {
        if (_XSERVTransGetPeerAddr(trans_conn, &family, &fromlen, &from) != -1) {
            AuthAudit(client, TRUE, (struct sockaddr *) from, fromlen,
                      proto_n, auth_proto, auth_id);

            free(from);
        }
    }
    priv->auth_id = auth_id;
    priv->conn_time = 0;

#ifdef XDMCP
    /* indicate to Xdmcp protocol that we've opened new client */
    XdmcpOpenDisplay(priv->fd);
#endif                          /* XDMCP */

    XaceHook(XACE_AUTH_AVAIL, client, auth_id);

    /* At this point, if the client is authorized to change the access control
     * list, we should getpeername() information, and add the client to
     * the selfhosts list.  It's not really the host machine, but the
     * true purpose of the selfhosts list is to see who may change the
     * access control list.
     */
    return ((char *) NULL);
}

static ClientPtr
AllocNewConnection(XtransConnInfo trans_conn, int fd, CARD32 conn_time)
{
    OsCommPtr oc;
    ClientPtr client;

    if (
#ifndef WIN32
           fd >= lastfdesc
#else
           XFD_SETCOUNT(&AllClients) >= MaxClients
#endif
        )
        return NullClient;
    oc = malloc(sizeof(OsCommRec));
    if (!oc)
        return NullClient;
    oc->trans_conn = trans_conn;
    oc->fd = fd;
    oc->input = (ConnectionInputPtr) NULL;
    oc->output = (ConnectionOutputPtr) NULL;
    oc->auth_id = None;
    oc->conn_time = conn_time;
    if (!(client = NextAvailableClient((void *) oc))) {
        free(oc);
        return NullClient;
    }
    client->local = ComputeLocalClient(client);
#if !defined(WIN32)
    ConnectionTranslation[fd] = client->index;
#else
    SetConnectionTranslation(fd, client->index);
#endif
    if (GrabInProgress) {
        FD_SET(fd, &SavedAllClients);
        FD_SET(fd, &SavedAllSockets);
    }
    else {
        FD_SET(fd, &AllClients);
        FD_SET(fd, &AllSockets);
    }

#ifdef DEBUG
    ErrorF("AllocNewConnection: client index = %d, socket fd = %d\n",
           client->index, fd);
#endif
#ifdef XSERVER_DTRACE
    XSERVER_CLIENT_CONNECT(client->index, fd);
#endif

    return client;
}

/*****************
 * EstablishNewConnections
 *    If anyone is waiting on listened sockets, accept them.
 *    Returns a mask with indices of new clients.  Updates AllClients
 *    and AllSockets.
 *****************/

 /*ARGSUSED*/ Bool
EstablishNewConnections(ClientPtr clientUnused, void *closure)
{
    fd_set readyconnections;    /* set of listeners that are ready */
    int curconn;                /* fd of listener that's ready */
    register int newconn;       /* fd of new client */
    CARD32 connect_time;
    register int i;
    register ClientPtr client;
    register OsCommPtr oc;
    fd_set tmask;

    XFD_ANDSET(&tmask, (fd_set *) closure, &WellKnownConnections);
    XFD_COPYSET(&tmask, &readyconnections);
    if (!XFD_ANYSET(&readyconnections))
        return TRUE;
    connect_time = GetTimeInMillis();
    /* kill off stragglers */
    for (i = 1; i < currentMaxClients; i++) {
        if ((client = clients[i])) {
            oc = (OsCommPtr) (client->osPrivate);
            if ((oc && (oc->conn_time != 0) &&
                 (connect_time - oc->conn_time) >= TimeOutValue) ||
                (client->noClientException != Success && !client->clientGone))
                CloseDownClient(client);
        }
    }
#ifndef WIN32
    for (i = 0; i < howmany(XFD_SETSIZE, NFDBITS); i++) {
        while (readyconnections.fds_bits[i])
#else
    for (i = 0; i < XFD_SETCOUNT(&readyconnections); i++)
#endif
    {
        XtransConnInfo trans_conn, new_trans_conn;
        int status;

#ifndef WIN32
        curconn = mffs(readyconnections.fds_bits[i]) - 1;
        readyconnections.fds_bits[i] &= ~((fd_mask) 1 << curconn);
        curconn += (i * (sizeof(fd_mask) * 8));
#else
        curconn = XFD_FD(&readyconnections, i);
#endif

        if ((trans_conn = lookup_trans_conn(curconn)) == NULL)
            continue;

        if ((new_trans_conn = _XSERVTransAccept(trans_conn, &status)) == NULL)
            continue;

        newconn = _XSERVTransGetConnectionNumber(new_trans_conn);

        if (newconn < lastfdesc) {
            int clientid;

#if !defined(WIN32)
            clientid = ConnectionTranslation[newconn];
#else
            clientid = GetConnectionTranslation(newconn);
#endif
            if (clientid && (client = clients[clientid]))
                CloseDownClient(client);
        }

        _XSERVTransSetOption(new_trans_conn, TRANS_NONBLOCKING, 1);

        if (trans_conn->flags & TRANS_NOXAUTH)
            new_trans_conn->flags = new_trans_conn->flags | TRANS_NOXAUTH;

        if (!AllocNewConnection(new_trans_conn, newconn, connect_time)) {
            ErrorConnMax(new_trans_conn);
            _XSERVTransClose(new_trans_conn);
        }
    }
#ifndef WIN32
}
#endif
return TRUE;
}

#define NOROOM "Maximum number of clients reached"

/************
 *   ErrorConnMax
 *     Fail a connection due to lack of client or file descriptor space
 ************/

#define BOTIMEOUT 200           /* in milliseconds */

static void
ErrorConnMax(XtransConnInfo trans_conn)
{
    int fd = _XSERVTransGetConnectionNumber(trans_conn);
    xConnSetupPrefix csp;
    char pad[3] = { 0, 0, 0 };
    struct iovec iov[3];
    char order = 0;
    int whichbyte = 1;
    struct timeval waittime;
    fd_set mask;

    /* if these seems like a lot of trouble to go to, it probably is */
    waittime.tv_sec = BOTIMEOUT / MILLI_PER_SECOND;
    waittime.tv_usec = (BOTIMEOUT % MILLI_PER_SECOND) *
        (1000000 / MILLI_PER_SECOND);
    FD_ZERO(&mask);
    FD_SET(fd, &mask);
    (void) Select(fd + 1, &mask, NULL, NULL, &waittime);
    /* try to read the byte-order of the connection */
    (void) _XSERVTransRead(trans_conn, &order, 1);
    if (order == 'l' || order == 'B' || order == 'r' || order == 'R') {
        csp.success = xFalse;
        csp.lengthReason = sizeof(NOROOM) - 1;
        csp.length = (sizeof(NOROOM) + 2) >> 2;
        csp.majorVersion = X_PROTOCOL;
        csp.minorVersion = X_PROTOCOL_REVISION;
	if (((*(char *) &whichbyte) && (order == 'B' || order == 'R')) ||
	    (!(*(char *) &whichbyte) && (order == 'l' || order == 'r'))) {
            swaps(&csp.majorVersion);
            swaps(&csp.minorVersion);
            swaps(&csp.length);
        }
        iov[0].iov_len = sz_xConnSetupPrefix;
        iov[0].iov_base = (char *) &csp;
        iov[1].iov_len = csp.lengthReason;
        iov[1].iov_base = (void *) NOROOM;
        iov[2].iov_len = (4 - (csp.lengthReason & 3)) & 3;
        iov[2].iov_base = pad;
        (void) _XSERVTransWritev(trans_conn, iov, 3);
    }
}

/************
 *   CloseDownFileDescriptor:
 *     Remove this file descriptor and it's I/O buffers, etc.
 ************/

static void
CloseDownFileDescriptor(OsCommPtr oc)
{
    int connection = oc->fd;

    if (oc->trans_conn) {
        _XSERVTransDisconnect(oc->trans_conn);
        _XSERVTransClose(oc->trans_conn);
    }
#ifndef WIN32
    ConnectionTranslation[connection] = 0;
#else
    SetConnectionTranslation(connection, 0);
#endif
    FD_CLR(connection, &AllSockets);
    FD_CLR(connection, &AllClients);
    FD_CLR(connection, &ClientsWithInput);
    FD_CLR(connection, &GrabImperviousClients);
    if (GrabInProgress) {
        FD_CLR(connection, &SavedAllSockets);
        FD_CLR(connection, &SavedAllClients);
        FD_CLR(connection, &SavedClientsWithInput);
    }
    FD_CLR(connection, &ClientsWriteBlocked);
    if (!XFD_ANYSET(&ClientsWriteBlocked))
        AnyClientsWriteBlocked = FALSE;
    FD_CLR(connection, &OutputPending);
}

/*****************
 * CheckConnections
 *    Some connection has died, go find which one and shut it down
 *    The file descriptor has been closed, but is still in AllClients.
 *    If would truly be wonderful if select() would put the bogus
 *    file descriptors in the exception mask, but nooooo.  So we have
 *    to check each and every socket individually.
 *****************/

void
CheckConnections(void)
{
#ifndef WIN32
    fd_mask mask;
#endif
    fd_set tmask;
    int curclient, curoff;
    int i;
    struct timeval notime;
    int r;

#ifdef WIN32
    fd_set savedAllClients;
#endif

    notime.tv_sec = 0;
    notime.tv_usec = 0;

#ifndef WIN32
    for (i = 0; i < howmany(XFD_SETSIZE, NFDBITS); i++) {
        mask = AllClients.fds_bits[i];
        while (mask) {
            curoff = mffs(mask) - 1;
            curclient = curoff + (i * (sizeof(fd_mask) * 8));
            FD_ZERO(&tmask);
            FD_SET(curclient, &tmask);
            do {
                r = Select(curclient + 1, &tmask, NULL, NULL, &notime);
            } while (r < 0 && (errno == EINTR || errno == EAGAIN));
            if (r < 0)
                if (ConnectionTranslation[curclient] > 0)
                    CloseDownClient(clients[ConnectionTranslation[curclient]]);
            mask &= ~((fd_mask) 1 << curoff);
        }
    }
#else
    XFD_COPYSET(&AllClients, &savedAllClients);
    for (i = 0; i < XFD_SETCOUNT(&savedAllClients); i++) {
        curclient = XFD_FD(&savedAllClients, i);
        FD_ZERO(&tmask);
        FD_SET(curclient, &tmask);
        do {
            r = Select(curclient + 1, &tmask, NULL, NULL, &notime);
        } while (r < 0 && (errno == EINTR || errno == EAGAIN));
        if (r < 0)
            if (GetConnectionTranslation(curclient) > 0)
                CloseDownClient(clients[GetConnectionTranslation(curclient)]);
    }
#endif
}

/*****************
 * CloseDownConnection
 *    Delete client from AllClients and free resources
 *****************/

void
CloseDownConnection(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr) client->osPrivate;

    if (FlushCallback)
        CallCallbacks(&FlushCallback, NULL);

    if (oc->output)
	FlushClient(client, oc, (char *) NULL, 0);
#ifdef XDMCP
    XdmcpCloseDisplay(oc->fd);
#endif
    CloseDownFileDescriptor(oc);
    FreeOsBuffers(oc);
    free(client->osPrivate);
    client->osPrivate = (void *) NULL;
    if (auditTrailLevel > 1)
        AuditF("client %d disconnected\n", client->index);
}

void
AddGeneralSocket(int fd)
{
    FD_SET(fd, &AllSockets);
    if (GrabInProgress)
        FD_SET(fd, &SavedAllSockets);
}

void
AddEnabledDevice(int fd)
{
    FD_SET(fd, &EnabledDevices);
    AddGeneralSocket(fd);
}

void
RemoveGeneralSocket(int fd)
{
    FD_CLR(fd, &AllSockets);
    if (GrabInProgress)
        FD_CLR(fd, &SavedAllSockets);
}

void
RemoveEnabledDevice(int fd)
{
    FD_CLR(fd, &EnabledDevices);
    RemoveGeneralSocket(fd);
}

/*****************
 * OnlyListenToOneClient:
 *    Only accept requests from  one client.  Continue to handle new
 *    connections, but don't take any protocol requests from the new
 *    ones.  Note that if GrabInProgress is set, EstablishNewConnections
 *    needs to put new clients into SavedAllSockets and SavedAllClients.
 *    Note also that there is no timeout for this in the protocol.
 *    This routine is "undone" by ListenToAllClients()
 *****************/

int
OnlyListenToOneClient(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr) client->osPrivate;
    int rc, connection = oc->fd;

    rc = XaceHook(XACE_SERVER_ACCESS, client, DixGrabAccess);
    if (rc != Success)
        return rc;

    if (!GrabInProgress) {
        XFD_COPYSET(&ClientsWithInput, &SavedClientsWithInput);
        XFD_ANDSET(&ClientsWithInput,
                   &ClientsWithInput, &GrabImperviousClients);
        if (FD_ISSET(connection, &SavedClientsWithInput)) {
            FD_CLR(connection, &SavedClientsWithInput);
            FD_SET(connection, &ClientsWithInput);
        }
        XFD_UNSET(&SavedClientsWithInput, &GrabImperviousClients);
        XFD_COPYSET(&AllSockets, &SavedAllSockets);
        XFD_COPYSET(&AllClients, &SavedAllClients);
        XFD_UNSET(&AllSockets, &AllClients);
        XFD_ANDSET(&AllClients, &AllClients, &GrabImperviousClients);
        FD_SET(connection, &AllClients);
        XFD_ORSET(&AllSockets, &AllSockets, &AllClients);
        GrabInProgress = client->index;
    }
    return rc;
}

/****************
 * ListenToAllClients:
 *    Undoes OnlyListentToOneClient()
 ****************/

void
ListenToAllClients(void)
{
    if (GrabInProgress) {
        XFD_ORSET(&AllSockets, &AllSockets, &SavedAllSockets);
        XFD_ORSET(&AllClients, &AllClients, &SavedAllClients);
        XFD_ORSET(&ClientsWithInput, &ClientsWithInput, &SavedClientsWithInput);
        GrabInProgress = 0;
    }
}

/****************
 * IgnoreClient
 *    Removes one client from input masks.
 *    Must have cooresponding call to AttendClient.
 ****************/

void
IgnoreClient(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr) client->osPrivate;
    int connection = oc->fd;

    client->ignoreCount++;
    if (client->ignoreCount > 1)
        return;

    isItTimeToYield = TRUE;
    if (!GrabInProgress || FD_ISSET(connection, &AllClients)) {
        if (FD_ISSET(connection, &ClientsWithInput))
            FD_SET(connection, &IgnoredClientsWithInput);
        else
            FD_CLR(connection, &IgnoredClientsWithInput);
        FD_CLR(connection, &ClientsWithInput);
        FD_CLR(connection, &AllSockets);
        FD_CLR(connection, &AllClients);
        FD_CLR(connection, &LastSelectMask);
    }
    else {
        if (FD_ISSET(connection, &SavedClientsWithInput))
            FD_SET(connection, &IgnoredClientsWithInput);
        else
            FD_CLR(connection, &IgnoredClientsWithInput);
        FD_CLR(connection, &SavedClientsWithInput);
        FD_CLR(connection, &SavedAllSockets);
        FD_CLR(connection, &SavedAllClients);
    }
}

/****************
 * AttendClient
 *    Adds one client back into the input masks.
 ****************/

void
AttendClient(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr) client->osPrivate;
    int connection = oc->fd;

    client->ignoreCount--;
    if (client->ignoreCount)
        return;

    if (!GrabInProgress || GrabInProgress == client->index ||
        FD_ISSET(connection, &GrabImperviousClients)) {
        FD_SET(connection, &AllClients);
        FD_SET(connection, &AllSockets);
        FD_SET(connection, &LastSelectMask);
        if (FD_ISSET(connection, &IgnoredClientsWithInput))
            FD_SET(connection, &ClientsWithInput);
    }
    else {
        FD_SET(connection, &SavedAllClients);
        FD_SET(connection, &SavedAllSockets);
        if (FD_ISSET(connection, &IgnoredClientsWithInput))
            FD_SET(connection, &SavedClientsWithInput);
    }
}

/* make client impervious to grabs; assume only executing client calls this */

void
MakeClientGrabImpervious(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr) client->osPrivate;
    int connection = oc->fd;

    FD_SET(connection, &GrabImperviousClients);

    if (ServerGrabCallback) {
        ServerGrabInfoRec grabinfo;

        grabinfo.client = client;
        grabinfo.grabstate = CLIENT_IMPERVIOUS;
        CallCallbacks(&ServerGrabCallback, &grabinfo);
    }
}

/* make client pervious to grabs; assume only executing client calls this */

void
MakeClientGrabPervious(ClientPtr client)
{
    OsCommPtr oc = (OsCommPtr) client->osPrivate;
    int connection = oc->fd;

    FD_CLR(connection, &GrabImperviousClients);
    if (GrabInProgress && (GrabInProgress != client->index)) {
        if (FD_ISSET(connection, &ClientsWithInput)) {
            FD_SET(connection, &SavedClientsWithInput);
            FD_CLR(connection, &ClientsWithInput);
        }
        FD_CLR(connection, &AllSockets);
        FD_CLR(connection, &AllClients);
        isItTimeToYield = TRUE;
    }

    if (ServerGrabCallback) {
        ServerGrabInfoRec grabinfo;

        grabinfo.client = client;
        grabinfo.grabstate = CLIENT_PERVIOUS;
        CallCallbacks(&ServerGrabCallback, &grabinfo);
    }
}

/* Add a fd (from launchd or similar) to our listeners */
void
ListenOnOpenFD(int fd, int noxauth)
{
    char port[256];
    XtransConnInfo ciptr;
    const char *display_env = getenv("DISPLAY");

    if (display_env && (strncmp(display_env, "/tmp/launch", 11) == 0)) {
        /* Make the path the launchd socket if our DISPLAY is set right */
        strcpy(port, display_env);
    }
    else {
        /* Just some default so things don't break and die. */
        snprintf(port, sizeof(port), ":%d", atoi(display));
    }

    /* Make our XtransConnInfo
     * TRANS_SOCKET_LOCAL_INDEX = 5 from Xtrans.c
     */
    ciptr = _XSERVTransReopenCOTSServer(5, fd, port);
    if (ciptr == NULL) {
        ErrorF("Got NULL while trying to Reopen listen port.\n");
        return;
    }

    if (noxauth)
        ciptr->flags = ciptr->flags | TRANS_NOXAUTH;

    /* Allocate space to store it */
    ListenTransFds =
        xnfreallocarray(ListenTransFds, ListenTransCount + 1, sizeof(int));
    ListenTransConns =
        xnfreallocarray(ListenTransConns, ListenTransCount + 1,
                        sizeof(XtransConnInfo));

    /* Store it */
    ListenTransConns[ListenTransCount] = ciptr;
    ListenTransFds[ListenTransCount] = fd;

    FD_SET(fd, &WellKnownConnections);
    FD_SET(fd, &AllSockets);

    /* Increment the count */
    ListenTransCount++;
}

/* based on TRANS(SocketUNIXAccept) (XtransConnInfo ciptr, int *status) */
Bool
AddClientOnOpenFD(int fd)
{
    XtransConnInfo ciptr;
    CARD32 connect_time;
    char port[20];

    snprintf(port, sizeof(port), ":%d", atoi(display));
    ciptr = _XSERVTransReopenCOTSServer(5, fd, port);
    if (ciptr == NULL)
        return FALSE;

    _XSERVTransSetOption(ciptr, TRANS_NONBLOCKING, 1);
    ciptr->flags |= TRANS_NOXAUTH;

    connect_time = GetTimeInMillis();

    if (!AllocNewConnection(ciptr, fd, connect_time)) {
        ErrorConnMax(ciptr);
        _XSERVTransClose(ciptr);
        return FALSE;
    }

    return TRUE;
}
@


1.18
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d164 1
a164 1
#define MAXSOCKS 500
d166 1
a166 1
#define MAXSELECT 500
d302 1
a302 1
            ErrorF("REACHED MAXIMUM CLIENTS LIMIT %d\n", MAXCLIENTS);
d312 1
a312 1
        ConnectionTranslation = (int *) xnfalloc(sizeof(int) * (lastfdesc + 1));
d437 1
d440 3
a442 1
    ListenTransFds = malloc(ListenTransCount * sizeof (int));
d1304 1
a1304 1
        (int *) realloc(ListenTransFds, (ListenTransCount + 1) * sizeof(int));
d1306 2
a1307 3
        (XtransConnInfo *) realloc(ListenTransConns,
                                   (ListenTransCount +
                                    1) * sizeof(XtransConnInfo));
@


1.17
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d116 2
d120 1
a120 9
#ifdef XSERVER_DTRACE
#include <sys/types.h>
typedef const char *string;

#ifndef HAVE_GETPEERUCRED
#define zoneid_t int
#endif
#include "../dix/Xserver-dtrace.h"
#endif
@


1.16
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
d431 1
a431 1
        for (i = 0; i < 65535 - X_TCP_PORT; i++) {
d529 7
a535 2
    for (i = 0; i < ListenTransCount; i++)
        _XSERVTransClose(ListenTransConns[i]);
d663 2
a664 2
 *                   CARD16	nbytesAuthProto;    
 *                   CARD16	nbytesAuthString;   
d989 1
a989 1
 *    Some connection has died, go find which one and shut it down 
d1050 1
a1050 1
 *    Delete client from AllClients and free resources 
@


1.15
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
d32 1
a32 1
both that copyright notice and this permission notice appear in
d35 1
a35 1
software without specific, written prior permission.
d141 1
d358 5
a362 3
    if (dynamic_display[0]) {
        write(displayfd, dynamic_display, strlen(dynamic_display));
        write(displayfd, "\n", 1);
d364 1
d418 6
a423 3
     * number if specified on the command line, or to NULL when the -displayfd
     * option is used. */
    if (display) {
d429 1
a429 1
    else { /* -displayfd */
d457 1
a457 1
    if (!XFD_ANYSET(&WellKnownConnections))
d460 1
d658 2
a659 2
 *                   CARD16	nbytesAuthProto;
 *                   CARD16	nbytesAuthString;
d778 1
a778 1
    if (!(client = NextAvailableClient((pointer) oc))) {
d816 1
a816 1
EstablishNewConnections(ClientPtr clientUnused, pointer closure)
d984 1
a984 1
 *    Some connection has died, go find which one and shut it down
d1045 1
a1045 1
 *    Delete client from AllClients and free resources
d1064 1
a1064 1
    client->osPrivate = (pointer) NULL;
d1271 1
a1271 2
#ifdef XQUARTZ
/* Add a fd (from launchd) to our listeners */
d1293 1
a1293 1
        ErrorF("Got NULL while trying to Reopen launchd port.\n");
d1317 17
d1335 9
a1343 6
    /* This *might* not be needed... /shrug */
    ResetAuthorization();
    ResetHosts(display);
#ifdef XDMCP
    XdmcpReset();
#endif
a1344 2

#endif
@


1.14
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d933 1
a933 1
        iov[1].iov_base = NOROOM;
@


1.13
log
@In non-privilege sepration mode, avoid accidentally sending
a SIGUSR1 signal to init(8).

It can happen that xdm dies before the X server that it started.
In that case X's is reparented by init...

This is handled correctly when privilege separation is not compiled
but got overlooked in the privilege separation case.
@
text
@d145 1
d357 5
d363 1
a363 1
        if (ParentProcess > 1) {
d369 1
a369 1
        }
d376 12
a397 1
    char port[20];
d413 15
a427 21
    snprintf(port, sizeof(port), "%d", atoi(display));

    if ((_XSERVTransMakeAllCOTSServerListeners(port, &partial,
                                               &ListenTransCount,
                                               &ListenTransConns) >= 0) &&
        (ListenTransCount >= 1)) {
        if (!PartialNetwork && partial) {
            FatalError("Failed to establish all listening sockets");
        }
        else {
            ListenTransFds = malloc(ListenTransCount * sizeof(int));

            for (i = 0; i < ListenTransCount; i++) {
                int fd = _XSERVTransGetConnectionNumber(ListenTransConns[i]);

                ListenTransFds[i] = fd;
                FD_SET(fd, &WellKnownConnections);

                if (!_XSERVTransIsLocal(ListenTransConns[i])) {
                    DefineSelf(fd);
                }
d429 2
d432 16
d774 1
a774 1
    oc->local_client = ComputeLocalClient(client);
d902 1
a902 1
    char pad[3];
d904 1
a904 1
    char byteOrder = 0;
d917 2
a918 2
    (void) _XSERVTransRead(trans_conn, &byteOrder, 1);
    if ((byteOrder == 'l') || (byteOrder == 'B')) {
d924 2
a925 2
        if (((*(char *) &whichbyte) && (byteOrder == 'B')) ||
            (!(*(char *) &whichbyte) && (byteOrder == 'l'))) {
d1048 2
a1049 2
    if (oc->output && oc->output->count)
        FlushClient(client, oc, (char *) NULL, 0);
@


1.12
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d346 3
@


1.11
log
@Update to xserver 1.11.2
@
text
@a24 1

d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
a84 2


d86 13
a98 13
# include <netinet/in.h>
# include <arpa/inet.h>
#  ifdef apollo
#   ifndef NO_TCP_H
#    include <netinet/tcp.h>
#   endif
#  else
#   ifdef CSRG_BASED
#    include <sys/param.h>
#   endif
#   include <netinet/tcp.h>
#  endif
# include <arpa/inet.h>
d103 2
a104 2
#endif /* WIN32 */
#include "misc.h"		/* for typedef of pointer */
d113 3
a115 4

#ifdef HAS_GETPEERUCRED
# include <ucred.h>
# include <zone.h>
d119 1
a119 1
# include <sys/types.h>
d121 17
a137 16
# ifndef HAS_GETPEERUCRED
#  define zoneid_t int
# endif
# include "../dix/Xserver-dtrace.h"
#endif

static int lastfdesc;		/* maximum file descriptor */

fd_set WellKnownConnections;	/* Listener mask */
fd_set EnabledDevices;		/* mask for input devices that are on */
fd_set AllSockets;		/* select on this */
fd_set AllClients;		/* available clients */
fd_set LastSelectMask;		/* mask returned from last select call */
fd_set ClientsWithInput;	/* clients with FULL requests in buffer */
fd_set ClientsWriteBlocked;	/* clients who cannot receive output */
fd_set OutputPending;		/* clients with reply/event data ready to go */
d139 2
a140 2
Bool NewOutputPending;		/* not yet attempted to write some new output */
Bool AnyClientsWriteBlocked;	/* true if some client blocked on write */
d142 4
a145 4
static Bool RunFromSmartParent;	/* send SIGUSR1 to parent process */
Bool RunFromSigStopParent;	/* send SIGSTOP to our own process; Upstart (or
				   equivalent) will send SIGCONT back. */
Bool PartialNetwork;	/* continue even if unable to bind all addrs */
d180 2
a181 1
void InitConnectionTranslation(void)
d186 2
a187 1
int GetConnectionTranslation(int conn)
d190 2
a191 2
    while (node != NULL)
    {
d199 2
a200 1
void SetConnectionTranslation(int conn, int client)
d203 4
a206 6
    if (client == 0) /* remove entry */
    {
        while (*node != NULL)
        {
            if ((*node)->key == conn)
            {
d208 1
d216 4
a219 6
    } else 
    {
        while (*node != NULL)
        {
            if ((*node)->key == conn)
            {
d233 2
a234 1
void ClearConnectionTranslation(void)
d237 2
a238 2
    for (i = 0; i < 256; i++)
    {
d240 2
a241 2
        while (node != NULL)
        {
d243 1
d251 3
a253 3
static XtransConnInfo 	*ListenTransConns = NULL;
static int	       	*ListenTransFds = NULL;
static int		ListenTransCount;
d255 1
a255 1
static void ErrorConnMax(XtransConnInfo /* trans_conn */);
d258 1
a258 1
lookup_trans_conn (int fd)
d260 6
a265 6
    if (ListenTransFds)
    {
	int i;
	for (i = 0; i < ListenTransCount; i++)
	    if (ListenTransFds[i] == fd)
		return ListenTransConns[i];
d284 1
a284 1
#ifdef HAS_GETDTABLESIZE
d286 1
a286 1
	lastfdesc = getdtablesize() - 1;
d291 1
a291 1
	lastfdesc = _NFILE - 1;
d294 1
a294 1
#endif /* __CYGWIN__ */
d298 1
a298 1
	lastfdesc = MAXSOCKS;
d301 1
a301 1
	lastfdesc = MAXSELECT;
d303 4
a306 5
    if (lastfdesc > MAXCLIENTS)
    {
	lastfdesc = MAXCLIENTS;
	if (debug_conns)
	    ErrorF( "REACHED MAXIMUM CLIENTS LIMIT %d\n", MAXCLIENTS);
d316 1
a316 1
        ConnectionTranslation = (int *)xnfalloc(sizeof(int)*(lastfdesc + 1));
d340 4
a343 3
    handler = OsSignal (SIGUSR1, SIG_IGN);
    if ( handler == SIG_IGN)
	RunFromSmartParent = TRUE;
d345 1
a345 1
    ParentProcess = getppid ();
d354 1
a354 1
	if (ParentProcess > 1) {
d356 1
a356 1
	    priv_signal_parent();
d358 1
a358 1
	    kill (ParentProcess, SIGUSR1);
d360 1
a360 1
	}
d363 1
a363 1
	raise (SIGSTOP);
d375 3
a377 3
    int		i;
    int		partial;
    char 	port[20];
d385 2
a386 1
    for (i=0; i<MaxClients; i++) ConnectionTranslation[i] = 0;
d391 1
a391 1
    FD_ZERO (&WellKnownConnections);
d393 1
a393 1
    snprintf (port, sizeof(port), "%d", atoi (display));
d395 21
a415 25
    if ((_XSERVTransMakeAllCOTSServerListeners (port, &partial,
	&ListenTransCount, &ListenTransConns) >= 0) &&
	(ListenTransCount >= 1))
    {
	if (!PartialNetwork && partial)
	{
	    FatalError ("Failed to establish all listening sockets");
	}
	else
	{
	    ListenTransFds = malloc(ListenTransCount * sizeof (int));

	    for (i = 0; i < ListenTransCount; i++)
	    {
		int fd = _XSERVTransGetConnectionNumber (ListenTransConns[i]);
		
		ListenTransFds[i] = fd;
		FD_SET (fd, &WellKnownConnections);

		if (!_XSERVTransIsLocal (ListenTransConns[i]))
		{
		    DefineSelf (fd);
		}
	    }
	}
d418 3
a420 2
    if (!XFD_ANYSET (&WellKnownConnections))
        FatalError ("Cannot establish any listening sockets - Make sure an X server isn't already running");
d422 2
a423 2
    OsSignal (SIGPIPE, SIG_IGN);
    OsSignal (SIGHUP, AutoResetServer);
d425 3
a427 3
    OsSignal (SIGINT, GiveUp);
    OsSignal (SIGTERM, GiveUp);
    XFD_COPYSET (&WellKnownConnections, &AllSockets);
d433 1
a433 1
    XdmcpInit ();
d438 1
a438 1
ResetWellKnownSockets (void)
d444 2
a445 3
    for (i = 0; i < ListenTransCount; i++)
    {
	int status = _XSERVTransResetListener (ListenTransConns[i]);
d447 25
a471 28
	if (status != TRANS_RESET_NOOP)
	{
	    if (status == TRANS_RESET_FAILURE)
	    {
		/*
		 * ListenTransConns[i] freed by xtrans.
		 * Remove it from out list.
		 */

		FD_CLR (ListenTransFds[i], &WellKnownConnections);
		ListenTransFds[i] = ListenTransFds[ListenTransCount - 1];
		ListenTransConns[i] = ListenTransConns[ListenTransCount - 1];
		ListenTransCount -= 1;
		i -= 1;
	    }
	    else if (status == TRANS_RESET_NEW_FD)
	    {
		/*
		 * A new file descriptor was allocated (the old one was closed)
		 */

		int newfd = _XSERVTransGetConnectionNumber (ListenTransConns[i]);

		FD_CLR (ListenTransFds[i], &WellKnownConnections);
		ListenTransFds[i] = newfd;
		FD_SET(newfd, &WellKnownConnections);
	    }
	}
d474 1
a474 1
    ResetAuthorization ();
d480 1
a480 1
    XdmcpReset ();
d490 1
a490 1
	_XSERVTransClose (ListenTransConns[i]);
d494 3
a496 3
AuthAudit (ClientPtr client, Bool letin, 
    struct sockaddr *saddr, int len, 
    unsigned int proto_n, char *auth_proto, int auth_id)
a498 1
    char *out = addr;
d501 1
d508 1
a508 1
        strlcpy(out, "local host", sizeof(addr));
d510 2
a511 3
	switch (saddr->sa_family)
	{
	case AF_UNSPEC:
d513 1
a513 1
	case AF_UNIX:
d515 2
a516 2
	  strlcpy(out, "local host", sizeof(addr));
	  break;
d518 4
a521 4
	case AF_INET:
	    snprintf(out, sizeof(addr), "IP %s",
		inet_ntoa(((struct sockaddr_in *) saddr)->sin_addr));
	    break;
d523 8
a530 7
	case AF_INET6: {
	    char ipaddr[INET6_ADDRSTRLEN];
	    inet_ntop(AF_INET6, &((struct sockaddr_in6 *) saddr)->sin6_addr,
	      ipaddr, sizeof(ipaddr));
	    snprintf(out, sizeof(addr), "IP %s", ipaddr);
	}
	    break;
d533 3
a535 3
	default:
	    strlcpy(out, "unknown address", sizeof(addr));
	}
d538 4
a541 1
	int slen; /* length written to client_uid_string */
d543 13
a555 2
	strcpy(client_uid_string, " ( ");
	slen = 3;
d557 1
a557 25
	if (lcc->fieldsSet & LCC_UID_SET) {
	    snprintf(client_uid_string + slen,
		     sizeof(client_uid_string) - slen,
		     "uid=%ld ", (long) lcc->euid);
	    slen = strlen(client_uid_string);
	}

	if (lcc->fieldsSet & LCC_GID_SET) {
	    snprintf(client_uid_string + slen,
		     sizeof(client_uid_string) - slen,
		     "gid=%ld ", (long) lcc->egid);
	    slen = strlen(client_uid_string);
	}

	if (lcc->fieldsSet & LCC_PID_SET) {
#ifdef XSERVER_DTRACE	    
	    client_pid = lcc->pid;
#endif
	    snprintf(client_uid_string + slen,
		     sizeof(client_uid_string) - slen,
		     "pid=%ld ", (long) lcc->pid);
	    slen = strlen(client_uid_string);
	}
	
	if (lcc->fieldsSet & LCC_ZID_SET) {
d559 21
a579 11
	    client_zid = lcc->zoneid;
#endif	    
	    snprintf(client_uid_string + slen,
		     sizeof(client_uid_string) - slen,
		     "zoneid=%ld ", (long) lcc->zoneid);
	    slen = strlen(client_uid_string);
	}

	snprintf(client_uid_string + slen, sizeof(client_uid_string) - slen,
		 ")");
	FreeLocalClientCreds(lcc);
d582 1
a582 1
	client_uid_string[0] = '\0';
d584 1
a584 1
    
d589 8
a596 8
      if (proto_n)
	AuditF("client %d %s from %s%s\n  Auth name: %.*s ID: %d\n", 
	       client->index, letin ? "connected" : "rejected", addr,
	       client_uid_string, (int)proto_n, auth_proto, auth_id);
      else 
	AuditF("client %d %s from %s%s\n", 
	       client->index, letin ? "connected" : "rejected", addr,
	       client_uid_string);
d605 1
a605 1
	return ((OsCommPtr)client->osPrivate)->auth_id;
d607 1
a607 1
	return None;
a609 1

d618 2
a619 2
 *                   CARD16	nbytesAuthProto;    
 *                   CARD16	nbytesAuthString;   
d629 12
a640 12
char *
ClientAuthorized(ClientPtr client, 
    unsigned int proto_n, char *auth_proto, 
    unsigned int string_n, char *auth_string)
{
    OsCommPtr 		priv;
    Xtransaddr		*from = NULL;
    int 		family;
    int			fromlen;
    XID	 		auth_id;
    char	 	*reason = NULL;
    XtransConnInfo	trans_conn;
d642 1
a642 1
    priv = (OsCommPtr)client->osPrivate;
d647 1
a647 1
    if(trans_conn->flags & TRANS_NOXAUTH) {
d649 5
a653 2
    } else {
        auth_id = CheckAuthorization (proto_n, auth_proto, string_n, auth_string, client, &reason);
d656 7
a662 10
    if (auth_id == (XID) ~0L)
    {
	if (_XSERVTransGetPeerAddr(trans_conn, &family, &fromlen, &from) != -1)
	{
	    if (InvalidHost ((struct sockaddr *) from, fromlen, client))
		AuthAudit(client, FALSE, (struct sockaddr *) from,
			  fromlen, proto_n, auth_proto, auth_id);
	    else
	    {
		auth_id = (XID) 0;
d664 1
a664 1
		if ((auditTrailLevel > 1) || XSERVER_CLIENT_AUTH_ENABLED())
d666 1
a666 1
		if (auditTrailLevel > 1)
d668 14
a681 14
		    AuthAudit(client, TRUE,
			(struct sockaddr *) from, fromlen,
			proto_n, auth_proto, auth_id);
	    }

	    free(from);
	}

	if (auth_id == (XID) ~0L) {
	    if (reason)
		return reason;
	    else
		return "Client is not authorized to connect to Server";
	}
d689 3
a691 5
	if (_XSERVTransGetPeerAddr (trans_conn,
	    &family, &fromlen, &from) != -1)
	{
	    AuthAudit(client, TRUE, (struct sockaddr *) from, fromlen,
		      proto_n, auth_proto, auth_id);
d693 2
a694 2
	    free(from);
	}
d702 1
a702 1
#endif /* XDMCP */
d712 1
a712 1
    return((char *)NULL);
d716 1
a716 1
AllocNewConnection (XtransConnInfo trans_conn, int fd, CARD32 conn_time)
d718 3
a720 3
    OsCommPtr	oc;
    ClientPtr	client;
    
d723 1
a723 1
	fd >= lastfdesc
d725 1
a725 1
	XFD_SETCOUNT(&AllClients) >= MaxClients
d727 2
a728 2
	)
	return NullClient;
d731 1
a731 1
	return NullClient;
d734 2
a735 2
    oc->input = (ConnectionInputPtr)NULL;
    oc->output = (ConnectionOutputPtr)NULL;
d738 3
a740 4
    if (!(client = NextAvailableClient((pointer)oc)))
    {
	free(oc);
	return NullClient;
d748 1
a748 2
    if (GrabInProgress)
    {
d752 1
a752 2
    else
    {
d759 1
a759 1
	   client->index, fd);
d763 1
a763 1
#endif	
d775 1
a775 2
/*ARGSUSED*/
Bool
d778 3
a780 3
    fd_set  readyconnections;     /* set of listeners that are ready */
    int curconn;                  /* fd of listener that's ready */
    register int newconn;         /* fd of new client */
d787 1
a787 1
    XFD_ANDSET (&tmask, (fd_set*)closure, &WellKnownConnections);
d790 1
a790 1
	return TRUE;
d793 8
a800 10
    for (i=1; i<currentMaxClients; i++)
    {
	if ((client = clients[i]))
	{
	    oc = (OsCommPtr)(client->osPrivate);
	    if ((oc && (oc->conn_time != 0) &&
		(connect_time - oc->conn_time) >= TimeOutValue) || 
		(client->noClientException != Success && !client->clientGone))
		CloseDownClient(client);     
	}
d803 2
a804 3
    for (i = 0; i < howmany(XFD_SETSIZE, NFDBITS); i++)
    {
      while (readyconnections.fds_bits[i])
d806 1
a806 1
      for (i = 0; i < XFD_SETCOUNT(&readyconnections); i++) 
d808 3
a810 3
      {
	XtransConnInfo trans_conn, new_trans_conn;
	int status;
d813 3
a815 3
	curconn = mffs (readyconnections.fds_bits[i]) - 1;
	readyconnections.fds_bits[i] &= ~((fd_mask)1 << curconn);
	curconn += (i * (sizeof(fd_mask)*8));
d817 1
a817 1
	curconn = XFD_FD(&readyconnections, i);
d820 2
a821 2
	if ((trans_conn = lookup_trans_conn (curconn)) == NULL)
	    continue;
d823 2
a824 2
	if ((new_trans_conn = _XSERVTransAccept (trans_conn, &status)) == NULL)
	    continue;
d826 4
a829 1
	newconn = _XSERVTransGetConnectionNumber (new_trans_conn);
a830 3
	if (newconn < lastfdesc)
	{
		int clientid;
d832 1
a832 1
  		clientid = ConnectionTranslation[newconn];
d834 1
a834 1
  		clientid = GetConnectionTranslation(newconn);
d836 14
a849 15
		if(clientid && (client = clients[clientid]))
 			CloseDownClient(client);
	}

	_XSERVTransSetOption(new_trans_conn, TRANS_NONBLOCKING, 1);

	if(trans_conn->flags & TRANS_NOXAUTH)
	    new_trans_conn->flags = new_trans_conn->flags | TRANS_NOXAUTH;

	if (!AllocNewConnection (new_trans_conn, newconn, connect_time))
	{
	    ErrorConnMax(new_trans_conn);
	    _XSERVTransClose(new_trans_conn);
	}
      }
d851 1
a851 1
    }
d853 1
a853 1
    return TRUE;
d863 2
d868 1
a868 1
    int fd = _XSERVTransGetConnectionNumber (trans_conn);
d880 1
a880 1
		       (1000000 / MILLI_PER_SECOND);
d883 1
a883 1
    (void)Select(fd + 1, &mask, NULL, NULL, &waittime);
d885 20
a904 22
    (void)_XSERVTransRead(trans_conn, &byteOrder, 1);
    if ((byteOrder == 'l') || (byteOrder == 'B'))
    {
	csp.success = xFalse;
	csp.lengthReason = sizeof(NOROOM) - 1;
	csp.length = (sizeof(NOROOM) + 2) >> 2;
	csp.majorVersion = X_PROTOCOL;
	csp.minorVersion = X_PROTOCOL_REVISION;
	if (((*(char *) &whichbyte) && (byteOrder == 'B')) ||
	    (!(*(char *) &whichbyte) && (byteOrder == 'l')))
	{
	    swaps(&csp.majorVersion, whichbyte);
	    swaps(&csp.minorVersion, whichbyte);
	    swaps(&csp.length, whichbyte);
	}
	iov[0].iov_len = sz_xConnSetupPrefix;
	iov[0].iov_base = (char *) &csp;
	iov[1].iov_len = csp.lengthReason;
	iov[1].iov_base = NOROOM;
	iov[2].iov_len = (4 - (csp.lengthReason & 3)) & 3;
	iov[2].iov_base = pad;
	(void)_XSERVTransWritev(trans_conn, iov, 3);
d919 2
a920 2
	_XSERVTransDisconnect(oc->trans_conn);
	_XSERVTransClose(oc->trans_conn);
d926 1
a926 1
#endif    
d931 4
a934 5
    if (GrabInProgress)
    {
	FD_CLR(connection, &SavedAllSockets);
	FD_CLR(connection, &SavedAllClients);
	FD_CLR(connection, &SavedClientsWithInput);
d938 1
a938 1
    	AnyClientsWriteBlocked = FALSE;
d944 1
a944 1
 *    Some connection has died, go find which one and shut it down 
d955 1
a955 1
    fd_mask		mask;
d957 4
a960 4
    fd_set		tmask; 
    int			curclient, curoff;
    int			i;
    struct timeval	notime;
d962 1
d971 5
a975 7
    for (i=0; i<howmany(XFD_SETSIZE, NFDBITS); i++)
    {
	mask = AllClients.fds_bits[i];
        while (mask)
    	{
	    curoff = mffs (mask) - 1;
	    curclient = curoff + (i * (sizeof(fd_mask)*8));
d979 1
a979 1
                r = Select (curclient + 1, &tmask, NULL, NULL, &notime);
d984 3
a986 3
	    mask &= ~((fd_mask)1 << curoff);
	}
    }	
d989 4
a992 5
    for (i = 0; i < XFD_SETCOUNT(&savedAllClients); i++)
    {
	curclient = XFD_FD(&savedAllClients, i);
	FD_ZERO(&tmask);
	FD_SET(curclient, &tmask);
d994 1
a994 1
            r = Select (curclient + 1, &tmask, NULL, NULL, &notime);
d996 1
a996 1
	if (r < 0)
d999 1
a999 1
    }	
a1002 1

d1005 1
a1005 1
 *    Delete client from AllClients and free resources 
d1011 1
a1011 1
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
d1014 1
a1014 1
	CallCallbacks(&FlushCallback, NULL);
d1017 1
a1017 1
	FlushClient(client, oc, (char *)NULL, 0);
d1024 1
a1024 1
    client->osPrivate = (pointer)NULL;
d1026 1
a1026 1
	AuditF("client %d disconnected\n", client->index);
d1034 1
a1034 1
	FD_SET(fd, &SavedAllSockets);
d1049 1
a1049 1
	FD_CLR(fd, &SavedAllSockets);
d1072 1
a1072 1
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
d1077 1
a1077 1
	return rc;
d1079 16
a1094 18
    if (! GrabInProgress)
    {
	XFD_COPYSET(&ClientsWithInput, &SavedClientsWithInput);
	XFD_ANDSET(&ClientsWithInput,
		       &ClientsWithInput, &GrabImperviousClients);
	if (FD_ISSET(connection, &SavedClientsWithInput))
	{
	    FD_CLR(connection, &SavedClientsWithInput);
	    FD_SET(connection, &ClientsWithInput);
	}
	XFD_UNSET(&SavedClientsWithInput, &GrabImperviousClients);
	XFD_COPYSET(&AllSockets, &SavedAllSockets);
	XFD_COPYSET(&AllClients, &SavedAllClients);
	XFD_UNSET(&AllSockets, &AllClients);
	XFD_ANDSET(&AllClients, &AllClients, &GrabImperviousClients);
	FD_SET(connection, &AllClients);
	XFD_ORSET(&AllSockets, &AllSockets, &AllClients);
	GrabInProgress = client->index;
d1107 6
a1112 7
    if (GrabInProgress)
    {
	XFD_ORSET(&AllSockets, &AllSockets, &SavedAllSockets);
	XFD_ORSET(&AllClients, &AllClients, &SavedAllClients);
	XFD_ORSET(&ClientsWithInput, &ClientsWithInput, &SavedClientsWithInput);
	GrabInProgress = 0;
    }	
d1122 1
a1122 1
IgnoreClient (ClientPtr client)
d1124 1
a1124 1
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
d1129 1
a1129 1
	return;
d1132 9
a1140 10
    if (!GrabInProgress || FD_ISSET(connection, &AllClients))
    {
    	if (FD_ISSET (connection, &ClientsWithInput))
	    FD_SET(connection, &IgnoredClientsWithInput);
    	else
	    FD_CLR(connection, &IgnoredClientsWithInput);
    	FD_CLR(connection, &ClientsWithInput);
    	FD_CLR(connection, &AllSockets);
    	FD_CLR(connection, &AllClients);
	FD_CLR(connection, &LastSelectMask);
d1142 8
a1149 9
    else
    {
    	if (FD_ISSET (connection, &SavedClientsWithInput))
	    FD_SET(connection, &IgnoredClientsWithInput);
    	else
	    FD_CLR(connection, &IgnoredClientsWithInput);
	FD_CLR(connection, &SavedClientsWithInput);
	FD_CLR(connection, &SavedAllSockets);
	FD_CLR(connection, &SavedAllClients);
d1159 1
a1159 1
AttendClient (ClientPtr client)
d1161 1
a1161 1
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
d1166 1
a1166 1
	return;
d1169 6
a1174 7
	FD_ISSET(connection, &GrabImperviousClients))
    {
    	FD_SET(connection, &AllClients);
    	FD_SET(connection, &AllSockets);
	FD_SET(connection, &LastSelectMask);
    	if (FD_ISSET (connection, &IgnoredClientsWithInput))
	    FD_SET(connection, &ClientsWithInput);
d1176 5
a1180 6
    else
    {
	FD_SET(connection, &SavedAllClients);
	FD_SET(connection, &SavedAllSockets);
	if (FD_ISSET(connection, &IgnoredClientsWithInput))
	    FD_SET(connection, &SavedClientsWithInput);
d1189 1
a1189 1
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
d1194 6
a1199 6
    if (ServerGrabCallback)
    {
	ServerGrabInfoRec grabinfo;
	grabinfo.client = client;
	grabinfo.grabstate  = CLIENT_IMPERVIOUS;
	CallCallbacks(&ServerGrabCallback, &grabinfo);
d1208 1
a1208 1
    OsCommPtr oc = (OsCommPtr)client->osPrivate;
d1212 8
a1219 10
    if (GrabInProgress && (GrabInProgress != client->index))
    {
	if (FD_ISSET(connection, &ClientsWithInput))
	{
	    FD_SET(connection, &SavedClientsWithInput);
	    FD_CLR(connection, &ClientsWithInput);
	}
	FD_CLR(connection, &AllSockets);
	FD_CLR(connection, &AllClients);
	isItTimeToYield = TRUE;
d1222 6
a1227 6
    if (ServerGrabCallback)
    {
	ServerGrabInfoRec grabinfo;
	grabinfo.client = client;
	grabinfo.grabstate  = CLIENT_PERVIOUS;
	CallCallbacks(&ServerGrabCallback, &grabinfo);
d1233 3
a1235 1
void ListenOnOpenFD(int fd, int noxauth) {
d1240 1
a1240 1
    if(display_env && (strncmp(display_env, "/tmp/launch", 11) == 0)) {
d1243 2
a1244 1
    } else {
d1246 1
a1246 1
        sprintf(port, ":%d", atoi(display));
d1253 1
a1253 1
    if(ciptr == NULL) {
d1257 2
a1258 2
    
    if(noxauth)
d1262 7
a1268 3
    ListenTransFds = (int *) realloc(ListenTransFds, (ListenTransCount + 1) * sizeof (int));
    ListenTransConns = (XtransConnInfo *) realloc(ListenTransConns, (ListenTransCount + 1) * sizeof (XtransConnInfo));
    
d1275 1
a1275 1
    
@


1.10
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a115 3
#ifdef DNETCONN
#include <netdnet/dn.h>
#endif /* DNETCONN */
d146 2
d363 2
d525 1
a525 1
#if defined(TCPCONN) || defined(STREAMSCONN) || defined(MNX_TCPCONN)
a539 6
#ifdef DNETCONN
	case AF_DECnet:
	    snprintf(out, sizeof(addr), "DN %s",
		    dnet_ntoa(&((struct sockaddr_dn *) saddr)->sdn_add));
	    break;
#endif
d753 1
d859 3
a866 4

	if(trans_conn->flags & TRANS_NOXAUTH)
	    new_trans_conn->flags = new_trans_conn->flags | TRANS_NOXAUTH;

@


1.9
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d186 1
a186 1
    bzero(ct_head, sizeof(ct_head));
d229 1
a229 1
        *node = xalloc(sizeof(struct _ct_node));
d247 1
a247 1
            xfree(temp);
d270 1
a270 1
    return (NULL);
d404 1
a404 1
	    ListenTransFds = xalloc (ListenTransCount * sizeof (int));
d686 1
a686 1
	    xfree (from);
d708 1
a708 1
	    xfree (from);
d744 1
a744 1
    oc = xalloc(sizeof(OsCommRec));
d755 1
a755 1
	xfree (oc);
d1040 3
d1050 1
a1050 1
    xfree(client->osPrivate);
d1157 4
d1195 5
d1295 2
a1296 2
    ListenTransFds = (int *) xrealloc(ListenTransFds, (ListenTransCount + 1) * sizeof (int));
    ListenTransConns = (XtransConnInfo *) xrealloc(ListenTransConns, (ListenTransCount + 1) * sizeof (XtransConnInfo));
@


1.8
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d149 1
a149 1
Bool PartialNetwork;		/* continue even if unable to bind all addrs */
d159 1
a159 1
_X_EXPORT int GrabInProgress = 0;
a174 1
#define MAXFD 500
d229 1
a229 1
        *node = (struct _ct_node*)xalloc(sizeof(struct _ct_node));
a347 9
#ifdef __UNIXOS2__
    /*
     * fg030505: under OS/2, xinit is not the parent process but
     * the "grant parent" process of the server because execvpe()
     * presents us an additional process number;
     * GetPPID(pid) is part of libemxfix
     */
    ParentProcess = GetPPID (ParentProcess);
#endif /* __UNIXOS2__ */
d404 1
a404 1
	    ListenTransFds = (int *) xalloc (ListenTransCount * sizeof (int));
d642 1
a642 1
char * 
d686 1
a686 1
	    xfree ((char *) from);
d708 1
a708 1
	    xfree ((char *) from);
d744 1
a744 1
    oc = (OsCommPtr)xalloc(sizeof(OsCommRec));
d834 1
a834 1
	curconn = ffs (readyconnections.fds_bits[i]) - 1;
d999 1
a999 1
	    curoff = ffs (mask) - 1;
d1053 1
a1053 1
_X_EXPORT void
d1061 1
a1061 1
_X_EXPORT void
d1068 1
a1068 1
_X_EXPORT void
d1076 1
a1076 1
_X_EXPORT void
d1148 1
a1148 1
_X_EXPORT void
d1183 1
a1183 1
_X_EXPORT void
d1257 1
a1257 1
_X_EXPORT void ListenOnOpenFD(int fd, int noxauth) {
d1260 1
d1262 1
a1262 1
    if(!strncmp(getenv("DISPLAY"), "/tmp/launch", 11)) {
d1264 1
a1264 1
        strcpy(port, getenv("DISPLAY"));
@


1.7
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a76 1
#ifdef HAVE_LAUNCHD
a77 1
#endif
a83 3
#if defined(Lynx)
#include <socket.h>
#else
a84 1
#endif
a85 4
#ifdef hpux
#include <sys/utsname.h>
#include <sys/ioctl.h>
#endif
a86 15
#if defined(DGUX)
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <sys/param.h>
#include <unistd.h>
#endif


#ifdef AIXV3
#include <sys/ioctl.h>
#endif
a90 1
# if !defined(hpux)
a100 1
# endif
a103 1
#ifndef Lynx
d105 1
a105 3
#else
#include <uio.h>
#endif
a111 3
#ifdef XAPPGROUP
#include "appgroup.h"
#endif
a113 3
#ifdef X_NOT_POSIX
#define Pid_t int
#else
a114 1
#endif
d609 1
a610 1
#endif
a619 1
#ifdef XSERVER_DTRACE
a620 1
#endif	
a663 3
#ifdef HAVE_LAUNCHD
    struct sockaddr     *saddr;
#endif
a667 2
#ifdef HAVE_LAUNCHD
    saddr = (struct sockaddr *) (trans_conn->addr);
d670 5
a674 6
    if (saddr->sa_len > 11 && saddr->sa_family == AF_UNIX &&
        !strncmp(saddr->sa_data, "/tmp/launch", 11)) goto done;
#endif

    auth_id = CheckAuthorization (proto_n, auth_proto,
				  string_n, auth_string, client, &reason);
a721 1
 done:
d878 4
d1218 1
a1218 1
_X_EXPORT void
d1237 1
a1237 1
_X_EXPORT void
d1265 49
@


1.6
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d77 3
a145 3
#ifdef XCSECURITY
#include "securitysrv.h"
#endif
d363 50
a424 1
    OsSigHandlerPtr handler;
d478 3
a480 31
    /*
     * Magic:  If SIGUSR1 was set to SIG_IGN when
     * the server started, assume that either
     *
     *  a- The parent process is ignoring SIGUSR1
     *
     * or
     *
     *  b- The parent process is expecting a SIGUSR1
     *     when the server is ready to accept connections
     *
     * In the first case, the signal will be harmless,
     * in the second case, the signal will be quite
     * useful
     */
#if !defined(WIN32)
    handler = OsSignal (SIGUSR1, SIG_IGN);
    if ( handler == SIG_IGN)
	RunFromSmartParent = TRUE;
    OsSignal(SIGUSR1, handler);
    ParentProcess = getppid ();
    if (RunFromSmartParent) {
	if (ParentProcess > 1) {
#ifdef X_PRIVSEP
	    priv_signal_parent();
#else
	    kill (ParentProcess, SIGUSR1);
#endif
	}
    }
#endif
a529 10
     * See above in CreateWellKnownSockets about SIGUSR1
     */
#if !defined(WIN32)
    if (RunFromSmartParent) {
	if (ParentProcess > 1) {
	    kill (ParentProcess, SIGUSR1);
	}
    }
#endif
    /*
a552 1
    int client_uid;
d554 2
a555 4
#ifdef HAS_GETPEERUCRED
    ucred_t *peercred = NULL;
#endif
#if defined(HAS_GETPEERUCRED) || defined(XSERVER_DTRACE)    
d596 43
a638 15
#ifdef HAS_GETPEERUCRED
    if (getpeerucred(((OsCommPtr)client->osPrivate)->fd, &peercred) >= 0) {
	client_uid = ucred_geteuid(peercred);
	client_pid = ucred_getpid(peercred);
	client_zid = ucred_getzoneid(peercred);

	ucred_free(peercred);
	snprintf(client_uid_string, sizeof(client_uid_string),
		 " (uid %ld, pid %ld, zone %ld)",
		 (long) client_uid, (long) client_pid, (long) client_zid);
    }
#else    
    if (LocalClientCred(client, &client_uid, NULL) != -1) {
	snprintf(client_uid_string, sizeof(client_uid_string),
		 " (uid %d)", client_uid);
a639 1
#endif
d703 3
d710 8
d723 1
a723 7
	if (
#ifdef XCSECURITY	    
	    (proto_n == 0 ||
	    strncmp (auth_proto, XSecurityAuthorizationName, proto_n) != 0) &&
#endif
	    _XSERVTransGetPeerAddr (trans_conn,
	        &family, &fromlen, &from) != -1)
d767 1
d1145 1
a1145 1
void
d1149 5
a1153 1
    int connection = oc->fd;
d1174 1
@


1.5
log
@Merge xserver 1.4.0.90. This includes fixes for some of the regressions
introduced by xserver 1.4, such as the keyboad caps/num-lock leds updates.
Tested by many.
@
text
@d356 2
a357 1
    ConnectionTranslation = (int *)xnfalloc(sizeof(int)*(lastfdesc + 1));
@


1.4
log
@merge xserver 1.4, 1st pass
@
text
@d1013 3
a1015 1
            r = Select (curclient + 1, &tmask, NULL, NULL, &notime);
d1017 2
a1018 1
		CloseDownClient(clients[ConnectionTranslation[curclient]]);
d1029 6
a1034 3
	r = Select (curclient + 1, &tmask, NULL, NULL, &notime);
	if (r < 0 && GetConnectionTranslation(curclient) > 0)
	    CloseDownClient(clients[GetConnectionTranslation(curclient)]);
@


1.3
log
@plug memory leak on client disconnect. From X.Org git.
@
text
@a109 5
#ifdef __UNIXOS2__
#define select(n,r,w,x,t) os2PseudoSelect(n,r,w,x,t)
extern __const__ int _nfiles;
#endif

d122 1
a122 3
#    ifndef __UNIXOS2__
#     include <netinet/tcp.h>
#    endif
a127 1
#if !defined(__UNIXOS2__)
a132 1
#endif
a141 1
#ifdef XACE
a142 1
#endif
d162 10
a171 1
int lastfdesc;			/* maximum file descriptor */
d185 1
a185 1
Bool RunFromSmartParent;	/* send SIGUSR1 to parent process */
a187 3
#ifdef __UNIXOS2__
Pid_t GetPPID(Pid_t pid);
#endif
d291 3
a293 3
XtransConnInfo 	*ListenTransConns = NULL;
int	       	*ListenTransFds = NULL;
int		ListenTransCount;
a319 2
#ifndef __UNIXOS2__

a333 4
#else /* __UNIXOS2__ */
    lastfdesc = _nfiles - 1;
#endif

a448 9
#ifdef __UNIXOS2__
    /*
     * fg030505: under OS/2, xinit is not the parent process but
     * the "grant parent" process of the server because execvpe()
     * presents us an additional process number;
     * GetPPID(pid) is part of libemxfix
     */
    ParentProcess = GetPPID (ParentProcess);
#endif /* __UNIXOS2__ */
d545 2
d557 1
a557 1
#if defined(UNIXCONN) || defined(LOCALCONN) || defined(OS2PIPECONN)
d608 5
a612 1
    if (proto_n)
d616 1
a616 1
    else 
d620 4
d690 3
d694 1
d710 3
d714 1
d732 1
a732 1
#ifdef XACE
d734 1
a734 1
#endif
d792 3
d1062 1
a1062 1
        FD_SET(fd, &SavedAllSockets);
d1077 1
a1077 1
        FD_CLR(fd, &SavedAllSockets);
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@d1049 2
@


1.1
log
@Initial revision
@
text
@d400 1
a400 1
    sprintf (port, "%d", atoi (display));
d471 3
d475 1
d570 1
a570 1
        strcpy(out, "local host");
d578 2
a579 2
	    strcpy(out, "local host");
	    break;
d582 1
a582 1
	    sprintf(out, "IP %s",
d590 1
a590 1
	    sprintf(out, "IP %s", ipaddr);
d597 1
a597 1
	    sprintf(out, "DN %s",
d602 1
a602 1
	    strcpy(out, "unknown address");
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d110 5
d127 3
a129 1
#   include <netinet/tcp.h>
d135 1
d141 1
d151 1
d153 1
d173 1
a173 10
#ifdef XSERVER_DTRACE
# include <sys/types.h>
typedef const char *string;
# ifndef HAS_GETPEERUCRED
#  define zoneid_t int
# endif
# include "../dix/Xserver-dtrace.h"
#endif

static int lastfdesc;		/* maximum file descriptor */
d187 1
a187 1
static Bool RunFromSmartParent;	/* send SIGUSR1 to parent process */
d190 3
d296 3
a298 3
static XtransConnInfo 	*ListenTransConns = NULL;
static int	       	*ListenTransFds = NULL;
static int		ListenTransCount;
d325 2
d341 4
d460 9
a560 2
#endif
#if defined(HAS_GETPEERUCRED) || defined(XSERVER_DTRACE)    
d571 1
a571 1
#if defined(UNIXCONN) || defined(LOCALCONN)
d622 1
a622 5
#ifdef XSERVER_DTRACE
    XSERVER_CLIENT_AUTH(client->index, addr, client_pid, client_zid);
    if (auditTrailLevel > 1) {
#endif
      if (proto_n)
d626 1
a626 1
      else 
a629 4

#ifdef XSERVER_DTRACE
    }
#endif	
a695 3
#ifdef XSERVER_DTRACE
		if ((auditTrailLevel > 1) || XSERVER_CLIENT_AUTH_ENABLED())
#else
a696 1
#endif
a711 3
#ifdef XSERVER_DTRACE
    else if ((auditTrailLevel > 1) || XSERVER_CLIENT_AUTH_ENABLED())
#else
a712 1
#endif
d730 1
a730 1

d732 1
a732 1

a789 3
#ifdef XSERVER_DTRACE
    XSERVER_CLIENT_CONNECT(client->index, fd);
#endif	
a1044 2
    FreeOsBuffers(oc);
    xfree(client->osPrivate);
d1055 1
a1055 1
	FD_SET(fd, &SavedAllSockets);
d1070 1
a1070 1
	FD_CLR(fd, &SavedAllSockets);
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@d1009 1
a1009 3
            do {
                r = Select (curclient + 1, &tmask, NULL, NULL, &notime);
            } while (r < 0 && (errno == EINTR || errno == EAGAIN));
d1011 1
a1011 2
                if (ConnectionTranslation[curclient] > 0)
                    CloseDownClient(clients[ConnectionTranslation[curclient]]);
d1022 3
a1024 6
        do {
            r = Select (curclient + 1, &tmask, NULL, NULL, &notime);
        } while (r < 0 && (errno == EINTR || errno == EAGAIN));
	if (r < 0)
            if (GetConnectionTranslation(curclient) > 0)
                CloseDownClient(clients[GetConnectionTranslation(curclient)]);
@


