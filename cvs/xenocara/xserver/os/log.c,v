head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.4
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.2
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.4
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	s0SI41sEunLdyFfd;

1.15
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	Te1daavkBLskZ8gc;

1.14
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	cVXoV5PxI8YrEaVA;

1.13
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.08.24.19.44.51;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.21.20.10.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.30.19.59.59;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.06;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.16.09;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.16.09;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.14;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
Copyright 1994 Quarterdeck Office Systems.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital and
Quarterdeck not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.

DIGITAL AND QUARTERDECK DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT
OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
OR PERFORMANCE OF THIS SOFTWARE.

*/

/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/Xos.h>
#include <stdio.h>
#include <time.h>
#include <sys/stat.h>
#include <stdarg.h>
#include <stdlib.h>             /* for malloc() */
#include <errno.h>

#include "input.h"
#include "site.h"
#include "opaque.h"

#ifdef WIN32
#include <process.h>
#define getpid(x) _getpid(x)
#endif

#ifdef XF86BIGFONT
#include "xf86bigfontsrv.h"
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wformat-nonliteral"
#endif

#ifdef DDXOSVERRORF
void (*OsVendorVErrorFProc) (const char *, va_list args) = NULL;
#endif

static FILE *logFile = NULL;
static int logFileFd = -1;
static Bool logFlush = FALSE;
static Bool logSync = FALSE;
static int logVerbosity = DEFAULT_LOG_VERBOSITY;
static int logFileVerbosity = DEFAULT_LOG_FILE_VERBOSITY;

/* Buffer to information logged before the log file is opened. */
static char *saveBuffer = NULL;
static int bufferSize = 0, bufferUnused = 0, bufferPos = 0;
static Bool needBuffer = TRUE;

#ifdef __APPLE__
#include <AvailabilityMacros.h>

static char __crashreporter_info_buff__[4096] = { 0 };

static const char *__crashreporter_info__ __attribute__ ((__used__)) =
    &__crashreporter_info_buff__[0];
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1050
// This is actually a toolchain requirement, but I'm not sure the correct check,
// but it should be fine to just only include it for Leopard and later.  This line
// just tells the linker to never strip this symbol (such as for space optimization)
asm(".desc ___crashreporter_info__, 0x10");
#endif
#endif

/* Prefix strings for log messages. */
#ifndef X_UNKNOWN_STRING
#define X_UNKNOWN_STRING		"(\?\?)"
#endif
#ifndef X_PROBE_STRING
#define X_PROBE_STRING			"(--)"
#endif
#ifndef X_CONFIG_STRING
#define X_CONFIG_STRING			"(**)"
#endif
#ifndef X_DEFAULT_STRING
#define X_DEFAULT_STRING		"(==)"
#endif
#ifndef X_CMDLINE_STRING
#define X_CMDLINE_STRING		"(++)"
#endif
#ifndef X_NOTICE_STRING
#define X_NOTICE_STRING			"(!!)"
#endif
#ifndef X_ERROR_STRING
#define X_ERROR_STRING			"(EE)"
#endif
#ifndef X_WARNING_STRING
#define X_WARNING_STRING		"(WW)"
#endif
#ifndef X_INFO_STRING
#define X_INFO_STRING			"(II)"
#endif
#ifndef X_NOT_IMPLEMENTED_STRING
#define X_NOT_IMPLEMENTED_STRING	"(NI)"
#endif
#ifndef X_DEBUG_STRING
#define X_DEBUG_STRING			"(DB)"
#endif
#ifndef X_NONE_STRING
#define X_NONE_STRING			""
#endif

static size_t
strlen_sigsafe(const char *s)
{
    size_t len;
    for (len = 0; s[len]; len++);
    return len;
}

/*
 * LogFilePrep is called to setup files for logging, including getting
 * an old file out of the way, but it doesn't actually open the file,
 * since it may be used for renaming a file we're already logging to.
 */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-nonliteral"

static char *
LogFilePrep(const char *fname, const char *backup, const char *idstring)
{
    char *logFileName = NULL;

    if (asprintf(&logFileName, fname, idstring) == -1)
        FatalError("Cannot allocate space for the log file name\n");

    if (backup && *backup) {
        struct stat buf;

        if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {
            char *suffix;
            char *oldLog;

            if ((asprintf(&suffix, backup, idstring) == -1) ||
                (asprintf(&oldLog, "%s%s", logFileName, suffix) == -1)) {
                FatalError("Cannot allocate space for the log file name\n");
            }
            free(suffix);

            if (rename(logFileName, oldLog) == -1) {
                FatalError("Cannot move old log file \"%s\" to \"%s\"\n",
                           logFileName, oldLog);
            }
            free(oldLog);
        }
    }
    else {
        if (remove(logFileName) != 0 && errno != ENOENT) {
            FatalError("Cannot remove old log file \"%s\": %s\n",
                       logFileName, strerror(errno));
        }
    }

    return logFileName;
}
#pragma GCC diagnostic pop

/*
 * LogInit is called to start logging to a file.  It is also called (with
 * NULL arguments) when logging to a file is not wanted.  It must always be
 * called, otherwise log messages will continue to accumulate in a buffer.
 *
 * %s, if present in the fname or backup strings, is expanded to the display
 * string (or to a string containing the pid if the display is not yet set).
 */

static char *saved_log_fname;
static char *saved_log_backup;
static char *saved_log_tempname;

const char *
LogInit(const char *fname, const char *backup)
{
    char *logFileName = NULL;

    if (fname && *fname) {
        if (displayfd != -1) {
            /* Display isn't set yet, so we can't use it in filenames yet. */
            char pidstring[32];
            snprintf(pidstring, sizeof(pidstring), "pid-%ld",
                     (unsigned long) getpid());
            logFileName = LogFilePrep(fname, backup, pidstring);
            saved_log_tempname = logFileName;

            /* Save the patterns for use when the display is named. */
            saved_log_fname = strdup(fname);
            if (backup == NULL)
                saved_log_backup = NULL;
            else
                saved_log_backup = strdup(backup);
        } else
            logFileName = LogFilePrep(fname, backup, display);
        if ((logFile = fopen(logFileName, "w")) == NULL)
            FatalError("Cannot open log file \"%s\"\n", logFileName);
        setvbuf(logFile, NULL, _IONBF, 0);

        logFileFd = fileno(logFile);

        /* Flush saved log information. */
        if (saveBuffer && bufferSize > 0) {
            fwrite(saveBuffer, bufferPos, 1, logFile);
            fflush(logFile);
#ifndef WIN32
            fsync(fileno(logFile));
#endif
        }
    }

    /*
     * Unconditionally free the buffer, and flag that the buffer is no longer
     * needed.
     */
    if (saveBuffer && bufferSize > 0) {
        free(saveBuffer);
        saveBuffer = NULL;
        bufferSize = 0;
    }
    needBuffer = FALSE;

    return logFileName;
}

void
LogSetDisplay(void)
{
    if (saved_log_fname) {
        char *logFileName;

        logFileName = LogFilePrep(saved_log_fname, saved_log_backup, display);

        if (rename(saved_log_tempname, logFileName) == 0) {
            LogMessageVerb(X_PROBED, 0,
                           "Log file renamed from \"%s\" to \"%s\"\n",
                           saved_log_tempname, logFileName);

            if (strlen(saved_log_tempname) >= strlen(logFileName))
                strncpy(saved_log_tempname, logFileName,
                        strlen(saved_log_tempname));
        }
        else {
            ErrorF("Failed to rename log file \"%s\" to \"%s\": %s\n",
                   saved_log_tempname, logFileName, strerror(errno));
        }

        /* free newly allocated string - can't free old one since existing
           pointers to it may exist in DDX callers. */
        free(logFileName);
        free(saved_log_fname);
        free(saved_log_backup);
    }
}

void
LogClose(enum ExitCode error)
{
    if (logFile) {
        int msgtype = (error == EXIT_NO_ERROR) ? X_INFO : X_ERROR;
        LogMessageVerbSigSafe(msgtype, -1,
                "Server terminated %s (%d). Closing log file.\n",
                (error == EXIT_NO_ERROR) ? "successfully" : "with error",
                error);
        fclose(logFile);
        logFile = NULL;
        logFileFd = -1;
    }
}

Bool
LogSetParameter(LogParameter param, int value)
{
    switch (param) {
    case XLOG_FLUSH:
        logFlush = value ? TRUE : FALSE;
        return TRUE;
    case XLOG_SYNC:
        logSync = value ? TRUE : FALSE;
        return TRUE;
    case XLOG_VERBOSITY:
        logVerbosity = value;
        return TRUE;
    case XLOG_FILE_VERBOSITY:
        logFileVerbosity = value;
        return TRUE;
    default:
        return FALSE;
    }
}

enum {
    LMOD_LONG     = 0x1,
    LMOD_LONGLONG = 0x2,
    LMOD_SHORT    = 0x4,
    LMOD_SIZET    = 0x8,
};

/**
 * Parse non-digit length modifiers and set the corresponding flag in
 * flags_return.
 *
 * @@return the number of bytes parsed
 */
static int parse_length_modifier(const char *format, size_t len, int *flags_return)
{
    int idx = 0;
    int length_modifier = 0;

    while (idx < len) {
        switch (format[idx]) {
            case 'l':
                BUG_RETURN_VAL(length_modifier & LMOD_SHORT, 0);

                if (length_modifier & LMOD_LONG)
                    length_modifier |= LMOD_LONGLONG;
                else
                    length_modifier |= LMOD_LONG;
                break;
            case 'h':
                BUG_RETURN_VAL(length_modifier & (LMOD_LONG|LMOD_LONGLONG), 0);
                length_modifier |= LMOD_SHORT;
                /* gcc says 'short int' is promoted to 'int' when
                 * passed through '...', so ignored during
                 * processing */
                break;
            case 'z':
                length_modifier |= LMOD_SIZET;
                break;
            default:
                goto out;
        }
        idx++;
    }

out:
    *flags_return = length_modifier;
    return idx;
}

/**
 * Signal-safe snprintf, with some limitations over snprintf. Be careful
 * which directives you use.
 */
static int
vpnprintf(char *string, int size_in, const char *f, va_list args)
{
    int f_idx = 0;
    int s_idx = 0;
    int f_len = strlen_sigsafe(f);
    char *string_arg;
    char number[21];
    int p_len;
    int i;
    uint64_t ui;
    int64_t si;
    size_t size = size_in;
    int precision;

    for (; f_idx < f_len && s_idx < size - 1; f_idx++) {
        int length_modifier = 0;
        if (f[f_idx] != '%') {
            string[s_idx++] = f[f_idx];
            continue;
        }

        f_idx++;

        /* silently swallow minimum field width */
        if (f[f_idx] == '*') {
            f_idx++;
            va_arg(args, int);
        } else {
            while (f_idx < f_len && ((f[f_idx] >= '0' && f[f_idx] <= '9')))
                f_idx++;
        }

        /* is there a precision? */
        precision = size;
        if (f[f_idx] == '.') {
            f_idx++;
            if (f[f_idx] == '*') {
                f_idx++;
                /* precision is supplied in an int argument */
                precision = va_arg(args, int);
            } else {
                /* silently swallow precision digits */
                while (f_idx < f_len && ((f[f_idx] >= '0' && f[f_idx] <= '9')))
                    f_idx++;
            }
        }

        /* non-digit length modifiers */
        if (f_idx < f_len) {
            int parsed_bytes = parse_length_modifier(&f[f_idx], f_len - f_idx, &length_modifier);
            if (parsed_bytes < 0)
                return 0;
            f_idx += parsed_bytes;
        }

        if (f_idx >= f_len)
            break;

        switch (f[f_idx]) {
        case 's':
            string_arg = va_arg(args, char*);

            for (i = 0; string_arg[i] != 0 && s_idx < size - 1 && s_idx < precision; i++)
                string[s_idx++] = string_arg[i];
            break;

        case 'u':
            if (length_modifier & LMOD_LONGLONG)
                ui = va_arg(args, unsigned long long);
            else if (length_modifier & LMOD_LONG)
                ui = va_arg(args, unsigned long);
            else if (length_modifier & LMOD_SIZET)
                ui = va_arg(args, size_t);
            else
                ui = va_arg(args, unsigned);

            FormatUInt64(ui, number);
            p_len = strlen_sigsafe(number);

            for (i = 0; i < p_len && s_idx < size - 1; i++)
                string[s_idx++] = number[i];
            break;
        case 'i':
        case 'd':
            if (length_modifier & LMOD_LONGLONG)
                si = va_arg(args, long long);
            else if (length_modifier & LMOD_LONG)
                si = va_arg(args, long);
            else if (length_modifier & LMOD_SIZET)
                si = va_arg(args, ssize_t);
            else
                si = va_arg(args, int);

            FormatInt64(si, number);
            p_len = strlen_sigsafe(number);

            for (i = 0; i < p_len && s_idx < size - 1; i++)
                string[s_idx++] = number[i];
            break;

        case 'p':
            string[s_idx++] = '0';
            if (s_idx < size - 1)
                string[s_idx++] = 'x';
            ui = (uintptr_t)va_arg(args, void*);
            FormatUInt64Hex(ui, number);
            p_len = strlen_sigsafe(number);

            for (i = 0; i < p_len && s_idx < size - 1; i++)
                string[s_idx++] = number[i];
            break;

        case 'x':
            if (length_modifier & LMOD_LONGLONG)
                ui = va_arg(args, unsigned long long);
            else if (length_modifier & LMOD_LONG)
                ui = va_arg(args, unsigned long);
            else if (length_modifier & LMOD_SIZET)
                ui = va_arg(args, size_t);
            else
                ui = va_arg(args, unsigned);

            FormatUInt64Hex(ui, number);
            p_len = strlen_sigsafe(number);

            for (i = 0; i < p_len && s_idx < size - 1; i++)
                string[s_idx++] = number[i];
            break;
        case 'f':
            {
                double d = va_arg(args, double);
                FormatDouble(d, number);
                p_len = strlen_sigsafe(number);

                for (i = 0; i < p_len && s_idx < size - 1; i++)
                    string[s_idx++] = number[i];
            }
            break;
        case 'c':
            {
                char c = va_arg(args, int);
                if (s_idx < size - 1)
                    string[s_idx++] = c;
            }
            break;
        case '%':
            string[s_idx++] = '%';
            break;
        default:
            BUG_WARN_MSG(f[f_idx], "Unsupported printf directive '%c'\n", f[f_idx]);
            va_arg(args, char*);
            string[s_idx++] = '%';
            if (s_idx < size - 1)
                string[s_idx++] = f[f_idx];
            break;
        }
    }

    string[s_idx] = '\0';

    return s_idx;
}

static int
pnprintf(char *string, int size, const char *f, ...)
{
    int rc;
    va_list args;

    va_start(args, f);
    rc = vpnprintf(string, size, f, args);
    va_end(args);

    return rc;
}

/* This function does the actual log message writes. It must be signal safe.
 * When attempting to call non-signal-safe functions, guard them with a check
 * of the inSignalContext global variable. */
static void
LogSWrite(int verb, const char *buf, size_t len, Bool end_line)
{
    static Bool newline = TRUE;
    int ret;

    if (verb < 0 || logVerbosity >= verb)
        ret = write(2, buf, len);

    if (verb < 0 || logFileVerbosity >= verb) {
        if (inSignalContext && logFileFd >= 0) {
            ret = write(logFileFd, buf, len);
#ifndef WIN32
            if (logFlush && logSync)
                fsync(logFileFd);
#endif
        }
        else if (!inSignalContext && logFile) {
            if (newline)
                fprintf(logFile, "[%10.3f] ", GetTimeInMillis() / 1000.0);
            newline = end_line;
            fwrite(buf, len, 1, logFile);
            if (logFlush) {
                fflush(logFile);
#ifndef WIN32
                if (logSync)
                    fsync(fileno(logFile));
#endif
            }
        }
        else if (!inSignalContext && needBuffer) {
            if (len > bufferUnused) {
                bufferSize += 1024;
                bufferUnused += 1024;
                saveBuffer = realloc(saveBuffer, bufferSize);
                if (!saveBuffer)
                    FatalError("realloc() failed while saving log messages\n");
            }
            bufferUnused -= len;
            memcpy(saveBuffer + bufferPos, buf, len);
            bufferPos += len;
        }
    }

    /* There's no place to log an error message if the log write
     * fails...
     */
    (void) ret;
}

void
LogVWrite(int verb, const char *f, va_list args)
{
    return LogVMessageVerb(X_NONE, verb, f, args);
}

void
LogWrite(int verb, const char *f, ...)
{
    va_list args;

    va_start(args, f);
    LogVWrite(verb, f, args);
    va_end(args);
}

/* Returns the Message Type string to prepend to a logging message, or NULL
 * if the message will be dropped due to insufficient verbosity. */
static const char *
LogMessageTypeVerbString(MessageType type, int verb)
{
    if (type == X_ERROR)
        verb = 0;

    if (logVerbosity < verb && logFileVerbosity < verb)
        return NULL;

    switch (type) {
    case X_PROBED:
        return X_PROBE_STRING;
    case X_CONFIG:
        return X_CONFIG_STRING;
    case X_DEFAULT:
        return X_DEFAULT_STRING;
    case X_CMDLINE:
        return X_CMDLINE_STRING;
    case X_NOTICE:
        return X_NOTICE_STRING;
    case X_ERROR:
        return X_ERROR_STRING;
    case X_WARNING:
        return X_WARNING_STRING;
    case X_INFO:
        return X_INFO_STRING;
    case X_NOT_IMPLEMENTED:
        return X_NOT_IMPLEMENTED_STRING;
    case X_UNKNOWN:
        return X_UNKNOWN_STRING;
    case X_NONE:
        return X_NONE_STRING;
    case X_DEBUG:
        return X_DEBUG_STRING;
    default:
        return X_UNKNOWN_STRING;
    }
}

void
LogVMessageVerb(MessageType type, int verb, const char *format, va_list args)
{
    const char *type_str;
    char buf[1024];
    const size_t size = sizeof(buf);
    Bool newline;
    size_t len = 0;

    if (inSignalContext) {
        LogVMessageVerbSigSafe(type, verb, format, args);
        return;
    }

    type_str = LogMessageTypeVerbString(type, verb);
    if (!type_str)
        return;

    /* if type_str is not "", prepend it and ' ', to message */
    if (type_str[0] != '\0')
        len += Xscnprintf(&buf[len], size - len, "%s ", type_str);

    if (size - len > 1)
        len += Xvscnprintf(&buf[len], size - len, format, args);

    /* Force '\n' at end of truncated line */
    if (size - len == 1)
        buf[len - 1] = '\n';

    newline = (buf[len - 1] == '\n');
    LogSWrite(verb, buf, len, newline);
}

/* Log message with verbosity level specified. */
void
LogMessageVerb(MessageType type, int verb, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    LogVMessageVerb(type, verb, format, ap);
    va_end(ap);
}

/* Log a message with the standard verbosity level of 1. */
void
LogMessage(MessageType type, const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    LogVMessageVerb(type, 1, format, ap);
    va_end(ap);
}

/* Log a message using only signal safe functions. */
void
LogMessageVerbSigSafe(MessageType type, int verb, const char *format, ...)
{
    va_list ap;
    va_start(ap, format);
    LogVMessageVerbSigSafe(type, verb, format, ap);
    va_end(ap);
}

void
LogVMessageVerbSigSafe(MessageType type, int verb, const char *format, va_list args)
{
    const char *type_str;
    char buf[1024];
    int len;
    Bool newline;

    type_str = LogMessageTypeVerbString(type, verb);
    if (!type_str)
        return;

    /* if type_str is not "", prepend it and ' ', to message */
    if (type_str[0] != '\0') {
        LogSWrite(verb, type_str, strlen_sigsafe(type_str), FALSE);
        LogSWrite(verb, " ", 1, FALSE);
    }

    len = vpnprintf(buf, sizeof(buf), format, args);

    /* Force '\n' at end of truncated line */
    if (sizeof(buf) - len == 1)
        buf[len - 1] = '\n';

    newline = (len > 0 && buf[len - 1] == '\n');
    LogSWrite(verb, buf, len, newline);
}

void
LogVHdrMessageVerb(MessageType type, int verb, const char *msg_format,
                   va_list msg_args, const char *hdr_format, va_list hdr_args)
{
    const char *type_str;
    char buf[1024];
    const size_t size = sizeof(buf);
    Bool newline;
    size_t len = 0;
    int (*vprintf_func)(char *, int, const char* _X_RESTRICT_KYWD f, va_list args)
            _X_ATTRIBUTE_PRINTF(3, 0);
    int (*printf_func)(char *, int, const char* _X_RESTRICT_KYWD f, ...)
            _X_ATTRIBUTE_PRINTF(3, 4);

    type_str = LogMessageTypeVerbString(type, verb);
    if (!type_str)
        return;

    if (inSignalContext) {
        vprintf_func = vpnprintf;
        printf_func = pnprintf;
    } else {
        vprintf_func = Xvscnprintf;
        printf_func = Xscnprintf;
    }

    /* if type_str is not "", prepend it and ' ', to message */
    if (type_str[0] != '\0')
        len += printf_func(&buf[len], size - len, "%s ", type_str);

    if (hdr_format && size - len > 1)
        len += vprintf_func(&buf[len], size - len, hdr_format, hdr_args);

    if (msg_format && size - len > 1)
        len += vprintf_func(&buf[len], size - len, msg_format, msg_args);

    /* Force '\n' at end of truncated line */
    if (size - len == 1)
        buf[len - 1] = '\n';

    newline = (buf[len - 1] == '\n');
    LogSWrite(verb, buf, len, newline);
}

void
LogHdrMessageVerb(MessageType type, int verb, const char *msg_format,
                  va_list msg_args, const char *hdr_format, ...)
{
    va_list hdr_args;

    va_start(hdr_args, hdr_format);
    LogVHdrMessageVerb(type, verb, msg_format, msg_args, hdr_format, hdr_args);
    va_end(hdr_args);
}

void
LogHdrMessage(MessageType type, const char *msg_format, va_list msg_args,
              const char *hdr_format, ...)
{
    va_list hdr_args;

    va_start(hdr_args, hdr_format);
    LogVHdrMessageVerb(type, 1, msg_format, msg_args, hdr_format, hdr_args);
    va_end(hdr_args);
}

void
AbortServer(void)
    _X_NORETURN;

void
AbortServer(void)
{
#ifdef XF86BIGFONT
    XF86BigfontCleanup();
#endif
    CloseWellKnownConnections();
    OsCleanup(TRUE);
    AbortDevices();
    AbortDDX(EXIT_ERR_ABORT);
    fflush(stderr);
    if (CoreDump)
        OsAbort();
    exit(1);
}

#define AUDIT_PREFIX "AUDIT: %s: %ld: "
#ifndef AUDIT_TIMEOUT
#define AUDIT_TIMEOUT ((CARD32)(120 * 1000))    /* 2 mn */
#endif

static int nrepeat = 0;
static int oldlen = -1;
static OsTimerPtr auditTimer = NULL;

void
FreeAuditTimer(void)
{
    if (auditTimer != NULL) {
        /* Force output of pending messages */
        TimerForce(auditTimer);
        TimerFree(auditTimer);
        auditTimer = NULL;
    }
}

static char *
AuditPrefix(void)
{
    time_t tm;
    char *autime, *s;
    char *tmpBuf;
    int len;

    time(&tm);
    autime = ctime(&tm);
    if ((s = strchr(autime, '\n')))
        *s = '\0';
    len = strlen(AUDIT_PREFIX) + strlen(autime) + 10 + 1;
    tmpBuf = malloc(len);
    if (!tmpBuf)
        return NULL;
    snprintf(tmpBuf, len, AUDIT_PREFIX, autime, (unsigned long) getpid());
    return tmpBuf;
}

void
AuditF(const char *f, ...)
{
    va_list args;

    va_start(args, f);

    VAuditF(f, args);
    va_end(args);
}

static CARD32
AuditFlush(OsTimerPtr timer, CARD32 now, void *arg)
{
    char *prefix;

    if (nrepeat > 0) {
        prefix = AuditPrefix();
        ErrorF("%slast message repeated %d times\n",
               prefix != NULL ? prefix : "", nrepeat);
        nrepeat = 0;
        free(prefix);
        return AUDIT_TIMEOUT;
    }
    else {
        /* if the timer expires without anything to print, flush the message */
        oldlen = -1;
        return 0;
    }
}

void
VAuditF(const char *f, va_list args)
{
    char *prefix;
    char buf[1024];
    int len;
    static char oldbuf[1024];

    prefix = AuditPrefix();
    len = vsnprintf(buf, sizeof(buf), f, args);

    if (len == oldlen && strcmp(buf, oldbuf) == 0) {
        /* Message already seen */
        nrepeat++;
    }
    else {
        /* new message */
        if (auditTimer != NULL)
            TimerForce(auditTimer);
        ErrorF("%s%s", prefix != NULL ? prefix : "", buf);
        strlcpy(oldbuf, buf, sizeof(oldbuf));
        oldlen = len;
        nrepeat = 0;
        auditTimer = TimerSet(auditTimer, 0, AUDIT_TIMEOUT, AuditFlush, NULL);
    }
    free(prefix);
}

void
FatalError(const char *f, ...)
{
    va_list args;
    va_list args2;
    static Bool beenhere = FALSE;

    if (beenhere)
        ErrorFSigSafe("\nFatalError re-entered, aborting\n");
    else
        ErrorFSigSafe("\nFatal server error:\n");

    va_start(args, f);

    /* Make a copy for OsVendorFatalError */
    va_copy(args2, args);

#ifdef __APPLE__
    {
        va_list apple_args;

        va_copy(apple_args, args);
        (void)vsnprintf(__crashreporter_info_buff__,
                        sizeof(__crashreporter_info_buff__), f, apple_args);
        va_end(apple_args);
    }
#endif
    VErrorFSigSafe(f, args);
    va_end(args);
    ErrorFSigSafe("\n");
    if (!beenhere)
        OsVendorFatalError(f, args2);
    va_end(args2);
    if (!beenhere) {
        beenhere = TRUE;
        AbortServer();
    }
    else
        OsAbort();
 /*NOTREACHED*/}

void
VErrorF(const char *f, va_list args)
{
#ifdef DDXOSVERRORF
    if (OsVendorVErrorFProc)
        OsVendorVErrorFProc(f, args);
    else
        LogVWrite(-1, f, args);
#else
    LogVWrite(-1, f, args);
#endif
}

void
ErrorF(const char *f, ...)
{
    va_list args;

    va_start(args, f);
    VErrorF(f, args);
    va_end(args);
}

void
VErrorFSigSafe(const char *f, va_list args)
{
    LogVMessageVerbSigSafe(X_ERROR, -1, f, args);
}

void
ErrorFSigSafe(const char *f, ...)
{
    va_list args;

    va_start(args, f);
    VErrorFSigSafe(f, args);
    va_end(args);
}

void
LogPrintMarkers(void)
{
    /* Show what the message marker symbols mean. */
    LogWrite(0, "Markers: ");
    LogMessageVerb(X_PROBED, 0, "probed, ");
    LogMessageVerb(X_CONFIG, 0, "from config file, ");
    LogMessageVerb(X_DEFAULT, 0, "default setting,\n\t");
    LogMessageVerb(X_CMDLINE, 0, "from command line, ");
    LogMessageVerb(X_NOTICE, 0, "notice, ");
    LogMessageVerb(X_INFO, 0, "informational,\n\t");
    LogMessageVerb(X_WARNING, 0, "warning, ");
    LogMessageVerb(X_ERROR, 0, "error, ");
    LogMessageVerb(X_NOT_IMPLEMENTED, 0, "not implemented, ");
    LogMessageVerb(X_UNKNOWN, 0, "unknown.\n");
}
@


1.15
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d88 1
d185 47
d237 1
a237 1
 * string.
d240 3
a242 2
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wformat-nonliteral"
d250 16
a265 24
        if (asprintf(&logFileName, fname, display) == -1)
            FatalError("Cannot allocate space for the log file name\n");

        if (backup && *backup) {
            struct stat buf;

            if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {
                char *suffix;
                char *oldLog;

                if ((asprintf(&suffix, backup, display) == -1) ||
                    (asprintf(&oldLog, "%s%s", logFileName, suffix) == -1))
                    FatalError("Cannot allocate space for the log file name\n");
                free(suffix);
                if (rename(logFileName, oldLog) == -1) {
                    FatalError("Cannot move old log file \"%s\" to \"%s\"\n",
                               logFileName, oldLog);
                }
                free(oldLog);
            }
        }
        else {
            unlink(logFileName);
        }
d295 30
a324 1
#pragma GCC diagnostic pop
@


1.14
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d130 1
a130 1
// This is actually a toolchain requirement, but I'm not sure the correct check,        
d192 3
a200 3
#if __GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ > 2
#pragma GCC diagnostic ignored "-Wformat-nonliteral"
#endif
a210 3
#if __GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ > 2
#pragma GCC diagnostic ignored "-Wformat-nonliteral"
#endif
d254 1
d260 5
a264 2
        ErrorFSigSafe("Server terminated %s (%d). Closing log file.\n",
               (error == EXIT_NO_ERROR) ? "successfully" : "with error", error);
d358 1
d369 2
a370 2
        /* silently swallow digit length modifiers */
        while (f_idx < f_len && ((f[f_idx] >= '0' && f[f_idx] <= '9') || f[f_idx] == '.'))
d372 20
a406 1
            p_len = strlen_sigsafe(string_arg);
d408 1
a408 1
            for (i = 0; i < p_len && s_idx < size - 1; i++)
@


1.13
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d198 3
d211 3
d345 1
a345 1
pnprintf(char *string, size_t size, const char *f, va_list args)
d356 1
d488 13
d508 1
d511 1
a511 1
        write(2, buf, len);
d515 1
a515 1
            write(logFileFd, buf, len);
d547 5
a613 1
    static unsigned int warned;
d621 2
a622 11
        if (warned < 3) {
            BUG_WARN_MSG(inSignalContext,
                         "Warning: attempting to log data in a signal unsafe "
                         "manner while in signal context.\nPlease update to check "
                         "inSignalContext and/or use LogMessageVerbSigSafe() or "
                         "ErrorFSigSafe().\nThe offending log format message is:\n"
                         "%s\n", format);
            warned++;
            if (warned == 3)
                LogMessageVerbSigSafe(X_WARNING, -1, "Warned %u times about sigsafe logging. Will be quiet now.\n", warned);
        }
d694 1
a694 1
    len = pnprintf(buf, sizeof(buf), format, args);
d700 1
a700 1
    newline = (buf[len - 1] == '\n');
a707 1
    static unsigned int warned;
d713 4
a716 14

    if (inSignalContext) {
        if (warned < 3) {
            BUG_WARN_MSG(inSignalContext,
                         "Warning: attempting to log data in a signal unsafe "
                         "manner while in signal context.\nPlease update to check "
                         "inSignalContext and/or use LogMessageVerbSigSafe().\nThe "
                         "offending header and log message formats are:\n%s %s\n",
                         hdr_format, msg_format);
            warned++;
            if (warned == 3)
                LogMessageVerbSigSafe(X_WARNING, -1, "Warned %u times about sigsafe logging. Will be quiet now.\n", warned);
        }
    }
d722 8
d732 1
a732 1
        len += Xscnprintf(&buf[len], size - len, "%s ", type_str);
d735 1
a735 1
        len += Xvscnprintf(&buf[len], size - len, hdr_format, hdr_args);
d738 1
a738 1
        len += Xvscnprintf(&buf[len], size - len, msg_format, msg_args);
d842 1
a842 1
AuditFlush(OsTimerPtr timer, CARD32 now, pointer arg)
@


1.12
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d219 3
@


1.11
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d253 1
a253 1
        ErrorF("Server terminated %s (%d). Closing log file.\n",
d282 53
d349 1
d357 1
a357 1
        /* silently swallow length modifiers */
d361 8
d382 9
a390 1
            ui = va_arg(args, unsigned);
d399 9
a407 1
            si = va_arg(args, int);
d428 9
a436 1
            ui = va_arg(args, unsigned);
d453 10
d464 1
d881 1
a881 1
        ErrorF("\nFatalError re-entered, aborting\n");
d883 1
a883 1
        ErrorF("\nFatal server error:\n");
d900 1
a900 1
    VErrorF(f, args);
d902 1
a902 1
    ErrorF("\n");
@


1.10
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d111 1
d168 3
d175 8
d223 2
d257 1
d282 102
a383 1
/* This function does the actual log message writes. */
d390 2
a391 1
        fwrite(buf, len, 1, stderr);
d393 8
a400 1
        if (logFile) {
d413 1
a413 1
        else if (needBuffer) {
d478 2
d488 1
d495 14
d550 38
d592 1
d599 14
d669 1
a669 1
    CloseDownDevices();
d780 1
d789 4
d795 1
a795 1
        va_list args2;
d797 4
a800 4
        va_copy(args2, args);
        (void) vsnprintf(__crashreporter_info_buff__,
                         sizeof(__crashreporter_info_buff__), f, args2);
        va_end(args2);
d807 2
a808 1
        OsVendorFatalError();
d837 16
@


1.9
log
@Update to xserver 1.11.2
@
text
@a26 1

a77 1

d87 1
a87 2
#include <stdlib.h>	/* for malloc() */
#include <errno.h>
d107 1
a107 1
void (*OsVendorVErrorFProc)(const char *, va_list args) = NULL;
d124 4
a127 2
static char __crashreporter_info_buff__[4096] = {0};
static const char *__crashreporter_info__ __attribute__((__used__)) = &__crashreporter_info_buff__[0];
d132 1
a132 1
asm (".desc ___crashreporter_info__, 0x10");
d167 3
d186 2
a187 2
	if (asprintf(&logFileName, fname, display) == -1)
	    FatalError("Cannot allocate space for the log file name\n");
d189 2
a190 2
	if (backup && *backup) {
	    struct stat buf;
d192 23
a214 23
	    if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {
		char *suffix;
		char *oldLog;

		if ((asprintf(&suffix, backup, display) == -1) ||
		    (asprintf(&oldLog, "%s%s", logFileName, suffix) == -1))
		    FatalError("Cannot allocate space for the log file name\n");
		free(suffix);
		if (rename(logFileName, oldLog) == -1) {
		    FatalError("Cannot move old log file \"%s\" to \"%s\"\n",
			       logFileName, oldLog);
		}
		free(oldLog);
	    }
	}
	if ((logFile = fopen(logFileName, "w")) == NULL)
	    FatalError("Cannot open log file \"%s\"\n", logFileName);
	setvbuf(logFile, NULL, _IONBF, 0);

	/* Flush saved log information. */
	if (saveBuffer && bufferSize > 0) {
	    fwrite(saveBuffer, bufferPos, 1, logFile);
	    fflush(logFile);
d216 1
a216 1
	    fsync(fileno(logFile));
d218 1
a218 1
	}
d226 3
a228 3
	free(saveBuffer);	/* Must be free(), not free() */
	saveBuffer = NULL;
	bufferSize = 0;
d239 4
a242 4
	ErrorF("Server terminated %s (%d). Closing log file.\n",
		(error == EXIT_NO_ERROR) ? "successfully" : "with error", error);
	fclose(logFile);
	logFile = NULL;
d251 2
a252 2
	logFlush = value ? TRUE : FALSE;
	return TRUE;
d254 2
a255 2
	logSync = value ? TRUE : FALSE;
	return TRUE;
d257 2
a258 2
	logVerbosity = value;
	return TRUE;
d260 2
a261 2
	logFileVerbosity = value;
	return TRUE;
d263 1
a263 1
	return FALSE;
d268 2
a269 3

void
LogVWrite(int verb, const char *f, va_list args)
a270 2
    static char tmpBuffer[1024];
    int len = 0;
d273 10
a282 22
    if (newline) {
	sprintf(tmpBuffer, "[%10.3f] ", GetTimeInMillis() / 1000.0);
	len = strlen(tmpBuffer);
	if (logFile)
	    fwrite(tmpBuffer, len, 1, logFile);
    }

    /*
     * Since a va_list can only be processed once, write the string to a
     * buffer, and then write the buffer out to the appropriate output
     * stream(s).
     */
    if (verb < 0 || logFileVerbosity >= verb || logVerbosity >= verb) {
	vsnprintf(tmpBuffer, sizeof(tmpBuffer), f, args);
	len = strlen(tmpBuffer);
    }
    newline = (tmpBuffer[len-1] == '\n');
    if ((verb < 0 || logVerbosity >= verb) && len > 0)
	write(2, tmpBuffer, len);
    if ((verb < 0 || logFileVerbosity >= verb) && len > 0) {
	if (logFile) {
	    write(fileno(logFile), tmpBuffer, len);
d284 2
a285 2
	    if (logFlush && logSync)
		fsync(fileno(logFile));
d287 14
a300 12
	} else if (needBuffer) {
	    if (len > bufferUnused) {
		bufferSize += 1024;
		bufferUnused += 1024;
		saveBuffer = realloc(saveBuffer, bufferSize);
		if (!saveBuffer)
		    FatalError("realloc() failed while saving log messages\n");
	    }
	    bufferUnused -= len;
	    memcpy(saveBuffer + bufferPos, tmpBuffer, len);
	    bufferPos += len;
	}
d305 6
d320 39
d362 20
a381 2
    const char *s  = X_UNKNOWN_STRING;
    char tmpBuf[1024];
d383 2
a384 46
    /* Ignore verbosity for X_ERROR */
    if (logVerbosity >= verb || logFileVerbosity >= verb || type == X_ERROR) {
	switch (type) {
	case X_PROBED:
	    s = X_PROBE_STRING;
	    break;
	case X_CONFIG:
	    s = X_CONFIG_STRING;
	    break;
	case X_DEFAULT:
	    s = X_DEFAULT_STRING;
	    break;
	case X_CMDLINE:
	    s = X_CMDLINE_STRING;
	    break;
	case X_NOTICE:
	    s = X_NOTICE_STRING;
	    break;
	case X_ERROR:
	    s = X_ERROR_STRING;
	    if (verb > 0)
		verb = 0;
	    break;
	case X_WARNING:
	    s = X_WARNING_STRING;
	    break;
	case X_INFO:
	    s = X_INFO_STRING;
	    break;
	case X_NOT_IMPLEMENTED:
	    s = X_NOT_IMPLEMENTED_STRING;
	    break;
	case X_UNKNOWN:
	    s = X_UNKNOWN_STRING;
	    break;
	case X_NONE:
	    s = NULL;
	    break;
	}

        /* if s is not NULL we need a space before format */
        snprintf(tmpBuf, sizeof(tmpBuf), "%s%s%s", s ? s : "",
                                                   s ? " " : "",
                                                   format);
        LogVWrite(verb, tmpBuf, args);
    }
d410 56
a465 1
AbortServer(void) _X_NORETURN;
d479 2
a480 2
	OsAbort();
    exit (1);
d485 1
a485 1
#define AUDIT_TIMEOUT ((CARD32)(120 * 1000)) /* 2 mn */
d496 4
a499 4
	/* Force output of pending messages */
	TimerForce(auditTimer);
	TimerFree(auditTimer);
	auditTimer = NULL;
d514 1
a514 1
	*s = '\0';
d518 2
a519 2
	return NULL;
    snprintf(tmpBuf, len, AUDIT_PREFIX, autime, (unsigned long)getpid());
d524 1
a524 1
AuditF(const char * f, ...)
d540 11
a550 10
	prefix = AuditPrefix();
	ErrorF("%slast message repeated %d times\n",
	       prefix != NULL ? prefix : "", nrepeat);
	nrepeat = 0;
	free(prefix);
	return AUDIT_TIMEOUT;
    } else {
	/* if the timer expires without anything to print, flush the message */
	oldlen = -1;
	return 0;
d566 12
a577 11
	/* Message already seen */
	nrepeat++;
    } else {
	/* new message */
	if (auditTimer != NULL)
	    TimerForce(auditTimer);
	ErrorF("%s%s", prefix != NULL ? prefix : "", buf);
	strlcpy(oldbuf, buf, sizeof(oldbuf));
	oldlen = len;
	nrepeat = 0;
	auditTimer = TimerSet(auditTimer, 0, AUDIT_TIMEOUT, AuditFlush, NULL);
d589 1
a589 1
	ErrorF("\nFatalError re-entered, aborting\n");
d591 1
a591 1
	ErrorF("\nFatal server error:\n");
d597 1
d599 2
a600 1
        (void)vsnprintf(__crashreporter_info_buff__, sizeof(__crashreporter_info_buff__), f, args2);
d608 1
a608 1
	OsVendorFatalError();
d610 6
a615 6
	beenhere = TRUE;
	AbortServer();
    } else
	OsAbort();
    /*NOTREACHED*/
}
d622 1
a622 1
	OsVendorVErrorFProc(f, args);
d624 1
a624 1
	LogVWrite(-1, f, args);
d631 1
a631 1
ErrorF(const char * f, ...)
a639 13
/* A perror() workalike. */

void
Error(const char *str)
{
    const char *err = strerror(errno);

    if (str)
	LogWrite(-1, "%s: %s", str, err);
    else
	LogWrite(-1, "%s", err);
}

a655 1

@


1.8
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d105 4
a181 1
    size_t len1, len2;
d184 1
a184 4
	/* xalloc() can't be used yet. */
	len1 = strlen(fname) + strlen(display) + 1;
	logFileName = malloc(len1);
	if (!logFileName)
a185 1
	snprintf(logFileName, len1, fname, display);
d194 2
a195 6
		len1 = strlen(logFileName) + strlen(backup) +
		       strlen(display) + 1;
		len2 = strlen(backup) + strlen(display) + 1;
		oldLog = malloc(len1);
		suffix = malloc(len2);
		if (!oldLog || !suffix)
a196 2
		snprintf(suffix, len2, backup, display);
		snprintf(oldLog, len1, "%s%s", logFileName, suffix);
d234 1
a234 1
LogClose(void)
d237 2
a300 4
	    /*
	     * Note, this code is used before OsInit() has been called, so
	     * malloc() and friends can't be used.
	     */
d304 1
a304 4
		if (saveBuffer)
		    saveBuffer = realloc(saveBuffer, bufferSize);
		else
		    saveBuffer = malloc(bufferSize);
d413 1
a413 1
    AbortDDX();
d481 1
a481 2
	if (prefix != NULL)
	    free(prefix);
d514 1
a514 2
    if (prefix != NULL)
	free(prefix);
d530 6
a535 1
    (void)vsnprintf(__crashreporter_info_buff__, sizeof(__crashreporter_info_buff__), f, args);
d576 1
a576 1
Error(char *str)
d578 6
a583 15
    char *err = NULL;
    int saveErrno = errno;
    size_t len;

    if (str) {
	len = strlen(strerror(saveErrno)) + strlen(str) + 2 + 1;
	err = malloc(len);
	if (!err)
	    return;
	snprintf(err, len, "%s: ", str);
	strlcat(err, strerror(saveErrno), len);
	LogWrite(-1, err);
	free(err);
    } else
	LogWrite(-1, "%s", strerror(saveErrno));
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d124 1
a124 1
static const char *__crashreporter_info__ = &__crashreporter_info_buff__[0];
@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d231 1
a231 1
	free(saveBuffer);	/* Must be free(), not xfree() */
d308 1
a308 2
	     * xalloc() and friends can't be used.
	     * And it should not be called inside a signal handler.
d413 2
a414 3
#ifdef __GNUC__
void AbortServer(void) __attribute__((noreturn));
#endif
@


1.5
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d101 3
d120 13
d206 1
a206 1
		    FatalError("Cannot move old log file (\"%s\" to \"%s\"\n",
d272 1
a272 1
_X_EXPORT void
d277 8
d295 1
d328 1
a328 1
_X_EXPORT void
d338 1
a338 1
_X_EXPORT void
d393 1
a393 1
_X_EXPORT void
d404 1
a404 1
_X_EXPORT void
d421 3
d430 1
a430 1
	abort();
d443 1
a443 1
void 
d533 1
a533 1
_X_EXPORT void
d545 3
d557 1
a557 1
	abort();
d561 1
a561 1
_X_EXPORT void
d574 1
a574 1
_X_EXPORT void
d586 1
a586 1
_X_EXPORT void
d600 1
a600 1
	LogWrite(-1, "%s", err);
d610 11
a620 11
    ErrorF("Markers: ");
    LogMessageVerb(X_PROBED, -1, "probed, ");
    LogMessageVerb(X_CONFIG, -1, "from config file, ");
    LogMessageVerb(X_DEFAULT, -1, "default setting,\n\t");
    LogMessageVerb(X_CMDLINE, -1, "from command line, ");
    LogMessageVerb(X_NOTICE, -1, "notice, ");
    LogMessageVerb(X_INFO, -1, "informational,\n\t");
    LogMessageVerb(X_WARNING, -1, "warning, ");
    LogMessageVerb(X_ERROR, -1, "error, ");
    LogMessageVerb(X_NOT_IMPLEMENTED, -1, "not implemented, ");
    LogMessageVerb(X_UNKNOWN, -1, "unknown.\n");
@


1.4
log
@Close well known connections in ServerAbort().

Gets rid of dangling /tmp/.X11-unix/X0 sockets after server crash.
@
text
@d317 1
d359 5
a363 29
	/*
	 * Prefix the format string with the message type.  We do it this way
	 * so that LogVWrite() is only called once per message.
	 */
	if (s != NULL) {
	    char stackBuf[BUFSIZ];
	    char *tmpBuf = NULL;
	    size_t len;

	    len = strlen(format) + strlen(s) + 1 + 1;
	    if (len <= sizeof(stackBuf)) {
		/*
		 * avoid malloc() for short strings, since this may be called
		 * from a signal handler 
		 */
		tmpBuf = stackBuf;
	    } else {
		tmpBuf = malloc(len);
		/* Silently return if malloc fails here. */
		if (tmpBuf == NULL) 
		    return;
	    }
	    /* snprintf() is safe in signal handlers on OpenBSD */
	    snprintf(tmpBuf, len, "%s %s", s, format);
	    LogVWrite(verb, tmpBuf, args);
	    if (tmpBuf != stackBuf)
		    free(tmpBuf);
	} else
	    LogVWrite(verb, format, args);
d406 1
a406 3
#ifndef AUDIT_PREFIX
#define AUDIT_PREFIX "AUDIT: %s: %ld %s: "
#endif
d438 1
a438 5
    if ((s = strrchr(argvGlobal[0], '/')))
	s++;
    else
	s = argvGlobal[0];
    len = strlen(AUDIT_PREFIX) + strlen(autime) + 10 + strlen(s) + 1;
d442 1
a442 1
    snprintf(tmpBuf, len, AUDIT_PREFIX, autime, (unsigned long)getpid(), s);
a487 9
#if 1
    /* XXX Compressing duplicated messages is temporarily disabled to
     * work around bugzilla 964:
     *     https://freedesktop.org/bugzilla/show_bug.cgi?id=964
     */
    ErrorF("%s%s", prefix != NULL ? prefix : "", buf);
    oldlen = -1;
    nrepeat = 0;
#else
a500 1
#endif
a519 1
#ifdef DDXOSFATALERROR
a521 4
#endif
#ifdef ABORTONFATALERROR
    abort();
#endif
a554 15
#ifndef NEED_STRERROR
#ifdef SYSV
#if !defined(ISC) || defined(ISC202) || defined(ISC22)
#define NEED_STRERROR
#endif
#endif
#endif

#if defined(NEED_STRERROR) && !defined(strerror)
extern char *sys_errlist[];
extern int sys_nerr;
#define strerror(n) \
	((n) >= 0 && (n) < sys_nerr) ? sys_errlist[(n)] : "unknown error"
#endif

d569 2
a570 1
	LogWrite(-1, err);
d572 1
a572 1
	LogWrite(-1, strerror(saveErrno));
@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@d419 1
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@d92 1
a188 3
#ifdef __UNIXOS2__
		remove(oldLog);
#endif
d225 1
a225 1
LogClose()
d420 1
d633 1
a633 1
LogPrintMarkers()
@


1.1
log
@Initial revision
@
text
@d161 1
d165 2
a166 1
	logFileName = malloc(strlen(fname) + strlen(display) + 1);
d169 1
a169 1
	sprintf(logFileName, fname, display);
d178 5
a182 3
		oldLog = malloc(strlen(logFileName) + strlen(backup) +
				strlen(display) + 1);
		suffix = malloc(strlen(backup) + strlen(display) + 1);
d185 2
a186 2
		sprintf(suffix, backup, display);
		sprintf(oldLog, "%s%s", logFileName, suffix);
d274 1
a274 1
	fwrite(tmpBuffer, len, 1, stderr);
d277 1
a277 3
	    fwrite(tmpBuffer, len, 1, logFile);
	    if (logFlush) {
		fflush(logFile);
d279 2
a280 2
		if (logSync)
		    fsync(fileno(logFile));
a281 1
	    }
d286 1
a318 1
    char *tmpBuf = NULL;
d364 20
a383 7
	if (s) {
	    tmpBuf = malloc(strlen(format) + strlen(s) + 1 + 1);
	    /* Silently return if malloc fails here. */
	    if (!tmpBuf)
		return;
	    sprintf(tmpBuf, "%s ", s);
	    strcat(tmpBuf, format);
d385 2
a386 1
	    free(tmpBuf);
d619 1
d622 2
a623 1
	err = malloc(strlen(strerror(saveErrno)) + strlen(str) + 2 + 1);
d626 2
a627 2
	sprintf(err, "%s: ", str);
	strcat(err, strerror(saveErrno));
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a91 1
#include "input.h"
d184 3
d223 1
a223 1
LogClose(void)
a406 1
    CloseDownDevices();
d617 1
a617 1
LogPrintMarkers(void)
@

