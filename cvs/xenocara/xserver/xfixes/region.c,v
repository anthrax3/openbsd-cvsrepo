head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.6
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.26;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.53.05;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.51;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.56;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.58;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.11;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.38;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.38;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.34;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.09;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.09;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.18.06.05;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "xfixesint.h"
#include "scrnintstr.h"
#include <picturestr.h>

#include <regionstr.h>
#include <gcstruct.h>
#include <window.h>

RESTYPE RegionResType;

static int
RegionResFree(void *data, XID id)
{
    RegionPtr pRegion = (RegionPtr) data;

    RegionDestroy(pRegion);
    return Success;
}

RegionPtr
XFixesRegionCopy(RegionPtr pRegion)
{
    RegionPtr pNew = RegionCreate(RegionExtents(pRegion),
                                  RegionNumRects(pRegion));

    if (!pNew)
        return 0;
    if (!RegionCopy(pNew, pRegion)) {
        RegionDestroy(pNew);
        return 0;
    }
    return pNew;
}

Bool
XFixesRegionInit(void)
{
    RegionResType = CreateNewResourceType(RegionResFree, "XFixesRegion");

    return RegionResType != 0;
}

int
ProcXFixesCreateRegion(ClientPtr client)
{
    int things;
    RegionPtr pRegion;

    REQUEST(xXFixesCreateRegionReq);

    REQUEST_AT_LEAST_SIZE(xXFixesCreateRegionReq);
    LEGAL_NEW_RESOURCE(stuff->region, client);

    things = (client->req_len << 2) - sizeof(xXFixesCreateRegionReq);
    if (things & 4)
        return BadLength;
    things >>= 3;

    pRegion = RegionFromRects(things, (xRectangle *) (stuff + 1), CT_UNSORTED);
    if (!pRegion)
        return BadAlloc;
    if (!AddResource(stuff->region, RegionResType, (void *) pRegion))
        return BadAlloc;

    return Success;
}

int
SProcXFixesCreateRegion(ClientPtr client)
{
    REQUEST(xXFixesCreateRegionReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xXFixesCreateRegionReq);
    swapl(&stuff->region);
    SwapRestS(stuff);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromBitmap(ClientPtr client)
{
    RegionPtr pRegion;
    PixmapPtr pPixmap;
    int rc;

    REQUEST(xXFixesCreateRegionFromBitmapReq);

    REQUEST_SIZE_MATCH(xXFixesCreateRegionFromBitmapReq);
    LEGAL_NEW_RESOURCE(stuff->region, client);

    rc = dixLookupResourceByType((void **) &pPixmap, stuff->bitmap, RT_PIXMAP,
                                 client, DixReadAccess);
    if (rc != Success) {
        client->errorValue = stuff->bitmap;
        return rc;
    }
    if (pPixmap->drawable.depth != 1)
        return BadMatch;

    pRegion = BitmapToRegion(pPixmap->drawable.pScreen, pPixmap);

    if (!pRegion)
        return BadAlloc;

    if (!AddResource(stuff->region, RegionResType, (void *) pRegion))
        return BadAlloc;

    return Success;
}

int
SProcXFixesCreateRegionFromBitmap(ClientPtr client)
{
    REQUEST(xXFixesCreateRegionFromBitmapReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesCreateRegionFromBitmapReq);
    swapl(&stuff->region);
    swapl(&stuff->bitmap);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromWindow(ClientPtr client)
{
    RegionPtr pRegion;
    Bool copy = TRUE;
    WindowPtr pWin;
    int rc;

    REQUEST(xXFixesCreateRegionFromWindowReq);

    REQUEST_SIZE_MATCH(xXFixesCreateRegionFromWindowReq);
    LEGAL_NEW_RESOURCE(stuff->region, client);
    rc = dixLookupResourceByType((void **) &pWin, stuff->window, RT_WINDOW,
                                 client, DixGetAttrAccess);
    if (rc != Success) {
        client->errorValue = stuff->window;
        return rc;
    }
    switch (stuff->kind) {
    case WindowRegionBounding:
        pRegion = wBoundingShape(pWin);
        if (!pRegion) {
            pRegion = CreateBoundingShape(pWin);
            copy = FALSE;
        }
        break;
    case WindowRegionClip:
        pRegion = wClipShape(pWin);
        if (!pRegion) {
            pRegion = CreateClipShape(pWin);
            copy = FALSE;
        }
        break;
    default:
        client->errorValue = stuff->kind;
        return BadValue;
    }
    if (copy && pRegion)
        pRegion = XFixesRegionCopy(pRegion);
    if (!pRegion)
        return BadAlloc;
    if (!AddResource(stuff->region, RegionResType, (void *) pRegion))
        return BadAlloc;

    return Success;
}

int
SProcXFixesCreateRegionFromWindow(ClientPtr client)
{
    REQUEST(xXFixesCreateRegionFromWindowReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesCreateRegionFromWindowReq);
    swapl(&stuff->region);
    swapl(&stuff->window);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromGC(ClientPtr client)
{
    RegionPtr pRegion, pClip;
    GCPtr pGC;
    int rc;

    REQUEST(xXFixesCreateRegionFromGCReq);

    REQUEST_SIZE_MATCH(xXFixesCreateRegionFromGCReq);
    LEGAL_NEW_RESOURCE(stuff->region, client);

    rc = dixLookupGC(&pGC, stuff->gc, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    if (pGC->clientClip) {
        pClip = (RegionPtr) pGC->clientClip;
        pRegion = XFixesRegionCopy(pClip);
        if (!pRegion)
            return BadAlloc;
    } else {
        return BadMatch;
    }

    if (!AddResource(stuff->region, RegionResType, (void *) pRegion))
        return BadAlloc;

    return Success;
}

int
SProcXFixesCreateRegionFromGC(ClientPtr client)
{
    REQUEST(xXFixesCreateRegionFromGCReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesCreateRegionFromGCReq);
    swapl(&stuff->region);
    swapl(&stuff->gc);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCreateRegionFromPicture(ClientPtr client)
{
    RegionPtr pRegion;
    PicturePtr pPicture;

    REQUEST(xXFixesCreateRegionFromPictureReq);

    REQUEST_SIZE_MATCH(xXFixesCreateRegionFromPictureReq);
    LEGAL_NEW_RESOURCE(stuff->region, client);

    VERIFY_PICTURE(pPicture, stuff->picture, client, DixGetAttrAccess);

    if (!pPicture->pDrawable)
        return RenderErrBase + BadPicture;

    if (pPicture->clientClip) {
        pRegion = XFixesRegionCopy((RegionPtr) pPicture->clientClip);
        if (!pRegion)
            return BadAlloc;
    } else {
        return BadMatch;
    }

    if (!AddResource(stuff->region, RegionResType, (void *) pRegion))
        return BadAlloc;

    return Success;
}

int
SProcXFixesCreateRegionFromPicture(ClientPtr client)
{
    REQUEST(xXFixesCreateRegionFromPictureReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesCreateRegionFromPictureReq);
    swapl(&stuff->region);
    swapl(&stuff->picture);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesDestroyRegion(ClientPtr client)
{
    REQUEST(xXFixesDestroyRegionReq);
    RegionPtr pRegion;

    REQUEST_SIZE_MATCH(xXFixesDestroyRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);
    FreeResource(stuff->region, RT_NONE);
    return Success;
}

int
SProcXFixesDestroyRegion(ClientPtr client)
{
    REQUEST(xXFixesDestroyRegionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesDestroyRegionReq);
    swapl(&stuff->region);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetRegion(ClientPtr client)
{
    int things;
    RegionPtr pRegion, pNew;

    REQUEST(xXFixesSetRegionReq);

    REQUEST_AT_LEAST_SIZE(xXFixesSetRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);

    things = (client->req_len << 2) - sizeof(xXFixesCreateRegionReq);
    if (things & 4)
        return BadLength;
    things >>= 3;

    pNew = RegionFromRects(things, (xRectangle *) (stuff + 1), CT_UNSORTED);
    if (!pNew)
        return BadAlloc;
    if (!RegionCopy(pRegion, pNew)) {
        RegionDestroy(pNew);
        return BadAlloc;
    }
    RegionDestroy(pNew);
    return Success;
}

int
SProcXFixesSetRegion(ClientPtr client)
{
    REQUEST(xXFixesSetRegionReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xXFixesSetRegionReq);
    swapl(&stuff->region);
    SwapRestS(stuff);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCopyRegion(ClientPtr client)
{
    RegionPtr pSource, pDestination;

    REQUEST(xXFixesCopyRegionReq);

    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);

    if (!RegionCopy(pDestination, pSource))
        return BadAlloc;

    return Success;
}

int
SProcXFixesCopyRegion(ClientPtr client)
{
    REQUEST(xXFixesCopyRegionReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xXFixesCopyRegionReq);
    swapl(&stuff->source);
    swapl(&stuff->destination);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesCombineRegion(ClientPtr client)
{
    RegionPtr pSource1, pSource2, pDestination;

    REQUEST(xXFixesCombineRegionReq);

    REQUEST_SIZE_MATCH(xXFixesCombineRegionReq);
    VERIFY_REGION(pSource1, stuff->source1, client, DixReadAccess);
    VERIFY_REGION(pSource2, stuff->source2, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);

    switch (stuff->xfixesReqType) {
    case X_XFixesUnionRegion:
        if (!RegionUnion(pDestination, pSource1, pSource2))
            return BadAlloc;
        break;
    case X_XFixesIntersectRegion:
        if (!RegionIntersect(pDestination, pSource1, pSource2))
            return BadAlloc;
        break;
    case X_XFixesSubtractRegion:
        if (!RegionSubtract(pDestination, pSource1, pSource2))
            return BadAlloc;
        break;
    }

    return Success;
}

int
SProcXFixesCombineRegion(ClientPtr client)
{
    REQUEST(xXFixesCombineRegionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesCombineRegionReq);
    swapl(&stuff->source1);
    swapl(&stuff->source2);
    swapl(&stuff->destination);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesInvertRegion(ClientPtr client)
{
    RegionPtr pSource, pDestination;
    BoxRec bounds;

    REQUEST(xXFixesInvertRegionReq);

    REQUEST_SIZE_MATCH(xXFixesInvertRegionReq);
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);

    /* Compute bounds, limit to 16 bits */
    bounds.x1 = stuff->x;
    bounds.y1 = stuff->y;
    if ((int) stuff->x + (int) stuff->width > MAXSHORT)
        bounds.x2 = MAXSHORT;
    else
        bounds.x2 = stuff->x + stuff->width;

    if ((int) stuff->y + (int) stuff->height > MAXSHORT)
        bounds.y2 = MAXSHORT;
    else
        bounds.y2 = stuff->y + stuff->height;

    if (!RegionInverse(pDestination, pSource, &bounds))
        return BadAlloc;

    return Success;
}

int
SProcXFixesInvertRegion(ClientPtr client)
{
    REQUEST(xXFixesInvertRegionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesInvertRegionReq);
    swapl(&stuff->source);
    swaps(&stuff->x);
    swaps(&stuff->y);
    swaps(&stuff->width);
    swaps(&stuff->height);
    swapl(&stuff->destination);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesTranslateRegion(ClientPtr client)
{
    RegionPtr pRegion;

    REQUEST(xXFixesTranslateRegionReq);

    REQUEST_SIZE_MATCH(xXFixesTranslateRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);

    RegionTranslate(pRegion, stuff->dx, stuff->dy);
    return Success;
}

int
SProcXFixesTranslateRegion(ClientPtr client)
{
    REQUEST(xXFixesTranslateRegionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesTranslateRegionReq);
    swapl(&stuff->region);
    swaps(&stuff->dx);
    swaps(&stuff->dy);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesRegionExtents(ClientPtr client)
{
    RegionPtr pSource, pDestination;

    REQUEST(xXFixesRegionExtentsReq);

    REQUEST_SIZE_MATCH(xXFixesRegionExtentsReq);
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);

    RegionReset(pDestination, RegionExtents(pSource));

    return Success;
}

int
SProcXFixesRegionExtents(ClientPtr client)
{
    REQUEST(xXFixesRegionExtentsReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesRegionExtentsReq);
    swapl(&stuff->source);
    swapl(&stuff->destination);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesFetchRegion(ClientPtr client)
{
    RegionPtr pRegion;
    xXFixesFetchRegionReply *reply;
    xRectangle *pRect;
    BoxPtr pExtent;
    BoxPtr pBox;
    int i, nBox;

    REQUEST(xXFixesFetchRegionReq);

    REQUEST_SIZE_MATCH(xXFixesFetchRegionReq);
    VERIFY_REGION(pRegion, stuff->region, client, DixReadAccess);

    pExtent = RegionExtents(pRegion);
    pBox = RegionRects(pRegion);
    nBox = RegionNumRects(pRegion);

    reply = calloc(sizeof(xXFixesFetchRegionReply) + nBox * sizeof(xRectangle),
                   1);
    if (!reply)
        return BadAlloc;
    reply->type = X_Reply;
    reply->sequenceNumber = client->sequence;
    reply->length = nBox << 1;
    reply->x = pExtent->x1;
    reply->y = pExtent->y1;
    reply->width = pExtent->x2 - pExtent->x1;
    reply->height = pExtent->y2 - pExtent->y1;

    pRect = (xRectangle *) (reply + 1);
    for (i = 0; i < nBox; i++) {
        pRect[i].x = pBox[i].x1;
        pRect[i].y = pBox[i].y1;
        pRect[i].width = pBox[i].x2 - pBox[i].x1;
        pRect[i].height = pBox[i].y2 - pBox[i].y1;
    }
    if (client->swapped) {
        swaps(&reply->sequenceNumber);
        swapl(&reply->length);
        swaps(&reply->x);
        swaps(&reply->y);
        swaps(&reply->width);
        swaps(&reply->height);
        SwapShorts((INT16 *) pRect, nBox * 4);
    }
    WriteToClient(client, sizeof(xXFixesFetchRegionReply) +
                         nBox * sizeof(xRectangle), (char *) reply);
    free(reply);
    return Success;
}

int
SProcXFixesFetchRegion(ClientPtr client)
{
    REQUEST(xXFixesFetchRegionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesFetchRegionReq);
    swapl(&stuff->region);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetGCClipRegion(ClientPtr client)
{
    GCPtr pGC;
    RegionPtr pRegion;
    ChangeGCVal vals[2];
    int rc;

    REQUEST(xXFixesSetGCClipRegionReq);
    REQUEST_SIZE_MATCH(xXFixesSetGCClipRegionReq);

    rc = dixLookupGC(&pGC, stuff->gc, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;

    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, DixReadAccess);

    if (pRegion) {
        pRegion = XFixesRegionCopy(pRegion);
        if (!pRegion)
            return BadAlloc;
    }

    vals[0].val = stuff->xOrigin;
    vals[1].val = stuff->yOrigin;
    ChangeGC(NullClient, pGC, GCClipXOrigin | GCClipYOrigin, vals);
    (*pGC->funcs->ChangeClip) (pGC, pRegion ? CT_REGION : CT_NONE,
                               (void *) pRegion, 0);

    return Success;
}

int
SProcXFixesSetGCClipRegion(ClientPtr client)
{
    REQUEST(xXFixesSetGCClipRegionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesSetGCClipRegionReq);
    swapl(&stuff->gc);
    swapl(&stuff->region);
    swaps(&stuff->xOrigin);
    swaps(&stuff->yOrigin);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

typedef RegionPtr (*CreateDftPtr) (WindowPtr pWin);

int
ProcXFixesSetWindowShapeRegion(ClientPtr client)
{
    WindowPtr pWin;
    RegionPtr pRegion;
    RegionPtr *pDestRegion;
    int rc;

    REQUEST(xXFixesSetWindowShapeRegionReq);

    REQUEST_SIZE_MATCH(xXFixesSetWindowShapeRegionReq);
    rc = dixLookupResourceByType((void **) &pWin, stuff->dest, RT_WINDOW,
                                 client, DixSetAttrAccess);
    if (rc != Success) {
        client->errorValue = stuff->dest;
        return rc;
    }
    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, DixWriteAccess);
    switch (stuff->destKind) {
    case ShapeBounding:
    case ShapeClip:
    case ShapeInput:
        break;
    default:
        client->errorValue = stuff->destKind;
        return BadValue;
    }
    if (pRegion) {
        pRegion = XFixesRegionCopy(pRegion);
        if (!pRegion)
            return BadAlloc;
        if (!pWin->optional)
            MakeWindowOptional(pWin);
        switch (stuff->destKind) {
        default:
        case ShapeBounding:
            pDestRegion = &pWin->optional->boundingShape;
            break;
        case ShapeClip:
            pDestRegion = &pWin->optional->clipShape;
            break;
        case ShapeInput:
            pDestRegion = &pWin->optional->inputShape;
            break;
        }
        if (stuff->xOff || stuff->yOff)
            RegionTranslate(pRegion, stuff->xOff, stuff->yOff);
    }
    else {
        if (pWin->optional) {
            switch (stuff->destKind) {
            default:
            case ShapeBounding:
                pDestRegion = &pWin->optional->boundingShape;
                break;
            case ShapeClip:
                pDestRegion = &pWin->optional->clipShape;
                break;
            case ShapeInput:
                pDestRegion = &pWin->optional->inputShape;
                break;
            }
        }
        else
            pDestRegion = &pRegion;     /* a NULL region pointer */
    }
    if (*pDestRegion)
        RegionDestroy(*pDestRegion);
    *pDestRegion = pRegion;
    (*pWin->drawable.pScreen->SetShape) (pWin, stuff->destKind);
    SendShapeNotify(pWin, stuff->destKind);
    return Success;
}

int
SProcXFixesSetWindowShapeRegion(ClientPtr client)
{
    REQUEST(xXFixesSetWindowShapeRegionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesSetWindowShapeRegionReq);
    swapl(&stuff->dest);
    swaps(&stuff->xOff);
    swaps(&stuff->yOff);
    swapl(&stuff->region);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesSetPictureClipRegion(ClientPtr client)
{
    PicturePtr pPicture;
    RegionPtr pRegion;

    REQUEST(xXFixesSetPictureClipRegionReq);

    REQUEST_SIZE_MATCH(xXFixesSetPictureClipRegionReq);
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixSetAttrAccess);
    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, DixReadAccess);

    if (!pPicture->pDrawable)
        return RenderErrBase + BadPicture;

    return SetPictureClipRegion(pPicture, stuff->xOrigin, stuff->yOrigin,
                                pRegion);
}

int
SProcXFixesSetPictureClipRegion(ClientPtr client)
{
    REQUEST(xXFixesSetPictureClipRegionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesSetPictureClipRegionReq);
    swapl(&stuff->picture);
    swapl(&stuff->region);
    swaps(&stuff->xOrigin);
    swaps(&stuff->yOrigin);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

int
ProcXFixesExpandRegion(ClientPtr client)
{
    RegionPtr pSource, pDestination;

    REQUEST(xXFixesExpandRegionReq);
    BoxPtr pTmp;
    BoxPtr pSrc;
    int nBoxes;
    int i;

    REQUEST_SIZE_MATCH(xXFixesExpandRegionReq);
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);

    nBoxes = RegionNumRects(pSource);
    pSrc = RegionRects(pSource);
    if (nBoxes) {
        pTmp = xallocarray(nBoxes, sizeof(BoxRec));
        if (!pTmp)
            return BadAlloc;
        for (i = 0; i < nBoxes; i++) {
            pTmp[i].x1 = pSrc[i].x1 - stuff->left;
            pTmp[i].x2 = pSrc[i].x2 + stuff->right;
            pTmp[i].y1 = pSrc[i].y1 - stuff->top;
            pTmp[i].y2 = pSrc[i].y2 + stuff->bottom;
        }
        RegionEmpty(pDestination);
        for (i = 0; i < nBoxes; i++) {
            RegionRec r;

            RegionInit(&r, &pTmp[i], 0);
            RegionUnion(pDestination, pDestination, &r);
        }
        free(pTmp);
    }
    return Success;
}

int
SProcXFixesExpandRegion(ClientPtr client)
{
    REQUEST(xXFixesExpandRegionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXFixesExpandRegionReq);
    swapl(&stuff->source);
    swapl(&stuff->destination);
    swaps(&stuff->left);
    swaps(&stuff->right);
    swaps(&stuff->top);
    swaps(&stuff->bottom);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"

int
PanoramiXFixesSetGCClipRegion(ClientPtr client)
{
    REQUEST(xXFixesSetGCClipRegionReq);
    int result = Success, j;
    PanoramiXRes *gc;

    REQUEST_SIZE_MATCH(xXFixesSetGCClipRegionReq);

    if ((result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                          client, DixWriteAccess))) {
        client->errorValue = stuff->gc;
        return result;
    }

    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = gc->info[j].id;
        result = (*PanoramiXSaveXFixesVector[X_XFixesSetGCClipRegion]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXFixesSetWindowShapeRegion(ClientPtr client)
{
    int result = Success, j;
    PanoramiXRes *win;
    RegionPtr reg = NULL;

    REQUEST(xXFixesSetWindowShapeRegionReq);

    REQUEST_SIZE_MATCH(xXFixesSetWindowShapeRegionReq);

    if ((result = dixLookupResourceByType((void **) &win, stuff->dest,
                                          XRT_WINDOW, client,
                                          DixWriteAccess))) {
        client->errorValue = stuff->dest;
        return result;
    }

    if (win->u.win.root)
        VERIFY_REGION_OR_NONE(reg, stuff->region, client, DixReadAccess);

    FOR_NSCREENS_FORWARD(j) {
        ScreenPtr screen = screenInfo.screens[j];
        stuff->dest = win->info[j].id;

        if (reg)
            RegionTranslate(reg, -screen->x, -screen->y);

        result =
            (*PanoramiXSaveXFixesVector[X_XFixesSetWindowShapeRegion]) (client);

        if (reg)
            RegionTranslate(reg, screen->x, screen->y);

        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXFixesSetPictureClipRegion(ClientPtr client)
{
    REQUEST(xXFixesSetPictureClipRegionReq);
    int result = Success, j;
    PanoramiXRes *pict;
    RegionPtr reg = NULL;

    REQUEST_SIZE_MATCH(xXFixesSetPictureClipRegionReq);

    if ((result = dixLookupResourceByType((void **) &pict, stuff->picture,
                                          XRT_PICTURE, client,
                                          DixWriteAccess))) {
        client->errorValue = stuff->picture;
        return result;
    }

    if (pict->u.pict.root)
        VERIFY_REGION_OR_NONE(reg, stuff->region, client, DixReadAccess);

    FOR_NSCREENS_BACKWARD(j) {
        ScreenPtr screen = screenInfo.screens[j];
        stuff->picture = pict->info[j].id;

        if (reg)
            RegionTranslate(reg, -screen->x, -screen->y);

        result =
            (*PanoramiXSaveXFixesVector[X_XFixesSetPictureClipRegion]) (client);

        if (reg)
            RegionTranslate(reg, screen->x, screen->y);

        if (result != Success)
            break;
    }

    return result;
}

#endif
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d780 1
a780 1
        pTmp = malloc(nBoxes * sizeof(BoxRec));
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d225 1
a225 7
    switch (pGC->clientClipType) {
    case CT_PIXMAP:
        pRegion = BitmapToRegion(pGC->pScreen, (PixmapPtr) pGC->clientClip);
        if (!pRegion)
            return BadAlloc;
        break;
    case CT_REGION:
d230 2
a231 3
        break;
    default:
        return BadImplementation;       /* assume sane server bits */
d268 1
a268 8
    switch (pPicture->clientClipType) {
    case CT_PIXMAP:
        pRegion = BitmapToRegion(pPicture->pDrawable->pScreen,
                                 (PixmapPtr) pPicture->clientClip);
        if (!pRegion)
            return BadAlloc;
        break;
    case CT_REGION:
d272 2
a273 3
        break;
    default:
        return BadImplementation;       /* assume sane server bits */
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d38 1
a38 1
RegionResFree(pointer data, XID id)
d88 1
a88 1
    if (!AddResource(stuff->region, RegionResType, (pointer) pRegion))
d118 1
a118 1
    rc = dixLookupResourceByType((pointer *) &pPixmap, stuff->bitmap, RT_PIXMAP,
d132 1
a132 1
    if (!AddResource(stuff->region, RegionResType, (pointer) pRegion))
d162 1
a162 1
    rc = dixLookupResourceByType((pointer *) &pWin, stuff->window, RT_WINDOW,
d191 1
a191 1
    if (!AddResource(stuff->region, RegionResType, (pointer) pRegion))
d241 1
a241 1
    if (!AddResource(stuff->region, RegionResType, (pointer) pRegion))
d272 3
d291 1
a291 1
    if (!AddResource(stuff->region, RegionResType, (pointer) pRegion))
d635 1
a635 1
                               (pointer) pRegion, 0);
d667 1
a667 1
    rc = dixLookupResourceByType((pointer *) &pWin, stuff->dest, RT_WINDOW,
d755 3
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d860 1
d873 3
d877 1
d879 4
d885 4
d902 1
d913 3
d917 1
d919 4
d925 4
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a29 1
extern int RenderErrBase;
d560 2
a561 1
    reply = malloc(sizeof(xXFixesFetchRegionReply) + nBox * sizeof(xRectangle));
d588 1
a588 1
    (void) WriteToClient(client, sizeof(xXFixesFetchRegionReply) +
@


1.6
log
@Update to xserver 1.11.2
@
text
@d31 1
d39 1
a39 1
RegionResFree (pointer data, XID id)
d41 1
a41 1
    RegionPtr    pRegion = (RegionPtr) data;
d48 1
a48 1
XFixesRegionCopy (RegionPtr pRegion)
d50 3
a52 2
    RegionPtr   pNew = RegionCreate(RegionExtents(pRegion),
				      RegionNumRects(pRegion));
d54 4
a57 5
	return 0;
    if (!RegionCopy(pNew, pRegion))
    {
	RegionDestroy(pNew);
	return 0;
d63 1
a63 1
XFixesRegionInit (void)
d71 1
a71 1
ProcXFixesCreateRegion (ClientPtr client)
d73 5
a77 4
    int		things;
    RegionPtr	pRegion;
    REQUEST (xXFixesCreateRegionReq);
    
d79 3
a81 3
    LEGAL_NEW_RESOURCE (stuff->region, client);
    
    things = (client->req_len << 2) - sizeof (xXFixesCreateRegionReq);
d83 1
a83 1
	return BadLength;
d88 4
a91 4
	return BadAlloc;
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
d96 1
a96 1
SProcXFixesCreateRegion (ClientPtr client)
a97 1
    register int n;
d99 2
a100 2
    
    swaps(&stuff->length, n);
d102 1
a102 1
    swapl(&stuff->region, n);
d108 1
a108 1
ProcXFixesCreateRegionFromBitmap (ClientPtr client)
d110 2
a111 2
    RegionPtr	pRegion;
    PixmapPtr	pPixmap;
a112 1
    REQUEST (xXFixesCreateRegionFromBitmapReq);
d114 4
a117 2
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromBitmapReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);
d119 5
a123 6
    rc = dixLookupResourceByType((pointer *)&pPixmap, stuff->bitmap, RT_PIXMAP,
			   client, DixReadAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->bitmap;
	return rc;
d126 1
a126 1
	return BadMatch;
d131 5
a135 5
	return BadAlloc;
    
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
d140 1
a140 1
SProcXFixesCreateRegionFromBitmap (ClientPtr client)
d142 1
a142 2
    int n;
    REQUEST (xXFixesCreateRegionFromBitmapReq);
d144 4
a147 4
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromBitmapReq);
    swapl(&stuff->region, n);
    swapl(&stuff->bitmap, n);
d152 1
a152 1
ProcXFixesCreateRegionFromWindow (ClientPtr client)
d154 3
a156 3
    RegionPtr	pRegion;
    Bool	copy = TRUE;
    WindowPtr	pWin;
d158 10
a167 10
    REQUEST (xXFixesCreateRegionFromWindowReq);
    
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromWindowReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->window, RT_WINDOW,
			   client, DixGetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->window;
	return rc;
d171 6
a176 7
	pRegion = wBoundingShape(pWin);
	if (!pRegion)
	{
	    pRegion = CreateBoundingShape (pWin);
	    copy = FALSE;
	}
	break;
d178 6
a183 7
	pRegion = wClipShape(pWin);
	if (!pRegion)
	{
	    pRegion = CreateClipShape (pWin);
	    copy = FALSE;
	}
	break;
d185 2
a186 2
	client->errorValue = stuff->kind;
	return BadValue;
d189 1
a189 1
	pRegion = XFixesRegionCopy (pRegion);
d191 4
a194 4
	return BadAlloc;
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
d199 1
a199 1
SProcXFixesCreateRegionFromWindow (ClientPtr client)
d201 1
a201 2
    int n;
    REQUEST (xXFixesCreateRegionFromWindowReq);
d203 4
a206 4
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromWindowReq);
    swapl(&stuff->region, n);
    swapl(&stuff->window, n);
d211 1
a211 1
ProcXFixesCreateRegionFromGC (ClientPtr client)
d213 5
a217 4
    RegionPtr	pRegion, pClip;
    GCPtr	pGC;
    int 	rc;
    REQUEST (xXFixesCreateRegionFromGCReq);
d219 2
a220 2
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromGCReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);
d224 2
a225 2
	return rc;
    
d228 4
a231 4
	pRegion = BitmapToRegion(pGC->pScreen, (PixmapPtr) pGC->clientClip);
	if (!pRegion)
	    return BadAlloc;
	break;
d233 5
a237 5
	pClip = (RegionPtr) pGC->clientClip;
	pRegion = XFixesRegionCopy (pClip);
	if (!pRegion)
	    return BadAlloc;
	break;
d239 1
a239 1
	return BadImplementation;   /* assume sane server bits */
d241 4
a244 4
    
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
d249 1
a249 1
SProcXFixesCreateRegionFromGC (ClientPtr client)
d251 1
a251 2
    int n;
    REQUEST (xXFixesCreateRegionFromGCReq);
d253 4
a256 4
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromGCReq);
    swapl(&stuff->region, n);
    swapl(&stuff->gc, n);
d261 1
a261 1
ProcXFixesCreateRegionFromPicture (ClientPtr client)
d263 2
a264 3
    RegionPtr	pRegion;
    PicturePtr	pPicture;
    REQUEST (xXFixesCreateRegionFromPictureReq);
d266 4
a269 2
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromPictureReq);
    LEGAL_NEW_RESOURCE (stuff->region, client);
d272 1
a272 1
    
d275 5
a279 5
	pRegion = BitmapToRegion(pPicture->pDrawable->pScreen,
				   (PixmapPtr) pPicture->clientClip);
	if (!pRegion)
	    return BadAlloc;
	break;
d281 4
a284 4
	pRegion = XFixesRegionCopy ((RegionPtr) pPicture->clientClip);
	if (!pRegion)
	    return BadAlloc;
	break;
d286 1
a286 1
	return BadImplementation;   /* assume sane server bits */
d288 4
a291 4
    
    if (!AddResource (stuff->region, RegionResType, (pointer) pRegion))
	return BadAlloc;
    
d296 1
a296 1
SProcXFixesCreateRegionFromPicture (ClientPtr client)
d298 1
a298 2
    int n;
    REQUEST (xXFixesCreateRegionFromPictureReq);
d300 4
a303 4
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCreateRegionFromPictureReq);
    swapl(&stuff->region, n);
    swapl(&stuff->picture, n);
d308 1
a308 1
ProcXFixesDestroyRegion (ClientPtr client)
d310 2
a311 2
    REQUEST (xXFixesDestroyRegionReq);
    RegionPtr	pRegion;
d315 1
a315 1
    FreeResource (stuff->region, RT_NONE);
d320 1
a320 1
SProcXFixesDestroyRegion (ClientPtr client)
d322 1
a322 2
    int n;
    REQUEST (xXFixesDestroyRegionReq);
d324 1
a324 1
    swaps (&stuff->length, n);
d326 1
a326 1
    swapl (&stuff->region, n);
d331 1
a331 1
ProcXFixesSetRegion (ClientPtr client)
d333 4
a336 3
    int		things;
    RegionPtr	pRegion, pNew;
    REQUEST (xXFixesSetRegionReq);
d340 2
a341 2
    
    things = (client->req_len << 2) - sizeof (xXFixesCreateRegionReq);
d343 1
a343 1
	return BadLength;
d348 4
a351 5
	return BadAlloc;
    if (!RegionCopy(pRegion, pNew))
    {
	RegionDestroy(pNew);
	return BadAlloc;
d358 1
a358 1
SProcXFixesSetRegion (ClientPtr client)
d360 1
a360 2
    int n;
    REQUEST (xXFixesSetRegionReq);
d362 1
a362 1
    swaps (&stuff->length, n);
d364 1
a364 1
    swapl (&stuff->region, n);
d370 1
a370 1
ProcXFixesCopyRegion (ClientPtr client)
d372 4
a375 3
    RegionPtr	pSource, pDestination;
    REQUEST (xXFixesCopyRegionReq);
    
d378 1
a378 1
    
d380 1
a380 1
	return BadAlloc;
d386 1
a386 1
SProcXFixesCopyRegion (ClientPtr client)
d388 1
a388 2
    int n;
    REQUEST (xXFixesCopyRegionReq);
d390 1
a390 1
    swaps (&stuff->length, n);
d392 2
a393 2
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
d398 1
a398 1
ProcXFixesCombineRegion (ClientPtr client)
d400 1
a400 2
    RegionPtr	pSource1, pSource2, pDestination;
    REQUEST (xXFixesCombineRegionReq);
d402 3
a404 1
    REQUEST_SIZE_MATCH (xXFixesCombineRegionReq);
d408 1
a408 1
    
d411 3
a413 3
	if (!RegionUnion(pDestination, pSource1, pSource2))
	    return BadAlloc;
	break;
d415 3
a417 3
	if (!RegionIntersect(pDestination, pSource1, pSource2))
	    return BadAlloc;
	break;
d419 3
a421 3
	if (!RegionSubtract(pDestination, pSource1, pSource2))
	    return BadAlloc;
	break;
d423 1
a423 1
    
d428 1
a428 1
SProcXFixesCombineRegion (ClientPtr client)
d430 1
a430 2
    int n;
    REQUEST (xXFixesCombineRegionReq);
d432 5
a436 5
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesCombineRegionReq);
    swapl (&stuff->source1, n);
    swapl (&stuff->source2, n);
    swapl (&stuff->destination, n);
d441 1
a441 1
ProcXFixesInvertRegion (ClientPtr client)
d443 3
a445 2
    RegionPtr	pSource, pDestination;
    BoxRec	bounds;
d456 1
a456 1
	bounds.x2 = MAXSHORT;
d458 2
a459 2
	bounds.x2 = stuff->x + stuff->width;
    
d461 1
a461 1
	bounds.y2 = MAXSHORT;
d463 1
a463 1
	bounds.y2 = stuff->y + stuff->height;
d466 1
a466 1
	return BadAlloc;
d472 1
a472 1
SProcXFixesInvertRegion (ClientPtr client)
a473 1
    int n;
d476 1
a476 1
    swaps (&stuff->length, n);
d478 6
a483 6
    swapl (&stuff->source, n);
    swaps (&stuff->x, n);
    swaps (&stuff->y, n);
    swaps (&stuff->width, n);
    swaps (&stuff->height, n);
    swapl (&stuff->destination, n);
d488 1
a488 1
ProcXFixesTranslateRegion (ClientPtr client)
d490 2
a491 1
    RegionPtr	pRegion;
d502 1
a502 1
SProcXFixesTranslateRegion (ClientPtr client)
a503 1
    int n;
d506 1
a506 1
    swaps (&stuff->length, n);
d508 3
a510 3
    swapl (&stuff->region, n);
    swaps (&stuff->dx, n);
    swaps (&stuff->dy, n);
d515 1
a515 1
ProcXFixesRegionExtents (ClientPtr client)
d517 2
a518 1
    RegionPtr	pSource, pDestination;
d531 1
a531 1
SProcXFixesRegionExtents (ClientPtr client)
a532 1
    int n;
d534 2
a535 2
    
    swaps (&stuff->length, n);
d537 2
a538 2
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
d543 1
a543 1
ProcXFixesFetchRegion (ClientPtr client)
d545 1
a545 1
    RegionPtr		    pRegion;
d547 5
a551 4
    xRectangle		    *pRect;
    BoxPtr		    pExtent;
    BoxPtr		    pBox;
    int			    i, nBox;
d558 4
a561 5
    pBox = RegionRects (pRegion);
    nBox = RegionNumRects (pRegion);
    
    reply = malloc(sizeof (xXFixesFetchRegionReply) +
		    nBox * sizeof (xRectangle));
d563 1
a563 1
	return BadAlloc;
d573 14
a586 17
    for (i = 0; i < nBox; i++)
    {
	pRect[i].x = pBox[i].x1;
	pRect[i].y = pBox[i].y1;
	pRect[i].width = pBox[i].x2 - pBox[i].x1;
	pRect[i].height = pBox[i].y2 - pBox[i].y1;
    }
    if (client->swapped)
    {
	int n;
	swaps (&reply->sequenceNumber, n);
	swapl (&reply->length, n);
	swaps (&reply->x, n);
	swaps (&reply->y, n);
	swaps (&reply->width, n);
	swaps (&reply->height, n);
	SwapShorts ((INT16 *) pRect, nBox * 4);
d588 2
a589 2
    (void) WriteToClient(client, sizeof (xXFixesFetchRegionReply) +
			 nBox * sizeof (xRectangle), (char *) reply);
d595 1
a595 1
SProcXFixesFetchRegion (ClientPtr client)
a596 1
    int n;
d599 1
a599 1
    swaps (&stuff->length, n);
d601 1
a601 1
    swapl (&stuff->region, n);
d606 1
a606 1
ProcXFixesSetGCClipRegion (ClientPtr client)
d608 5
a612 4
    GCPtr	pGC;
    RegionPtr	pRegion;
    ChangeGCVal	vals[2];
    int		rc;
d618 1
a618 1
	return rc;
d620 1
a620 1
    VERIFY_REGION_OR_NONE (pRegion, stuff->region, client, DixReadAccess);
d622 4
a625 5
    if (pRegion)
    {
	pRegion = XFixesRegionCopy (pRegion);
	if (!pRegion)
	    return BadAlloc;
d627 1
a627 1
    
d630 3
a632 2
    ChangeGC (NullClient, pGC, GCClipXOrigin|GCClipYOrigin, vals);
    (*pGC->funcs->ChangeClip)(pGC, pRegion ? CT_REGION : CT_NONE, (pointer)pRegion, 0);
d638 1
a638 1
SProcXFixesSetGCClipRegion (ClientPtr client)
a639 1
    int n;
d642 1
a642 1
    swaps (&stuff->length, n);
d644 4
a647 4
    swapl (&stuff->gc, n);
    swapl (&stuff->region, n);
    swaps (&stuff->xOrigin, n);
    swaps (&stuff->yOrigin, n);
d651 1
a651 1
typedef	RegionPtr (*CreateDftPtr)(WindowPtr pWin);
d654 1
a654 1
ProcXFixesSetWindowShapeRegion (ClientPtr client)
d656 3
a658 3
    WindowPtr	    pWin;
    RegionPtr	    pRegion;
    RegionPtr	    *pDestRegion;
d660 1
d664 5
a668 6
    rc = dixLookupResourceByType((pointer *)&pWin, stuff->dest, RT_WINDOW,
			   client, DixSetAttrAccess);
    if (rc != Success)
    {
	client->errorValue = stuff->dest;
	return rc;
d675 1
a675 1
	break;
d677 2
a678 2
	client->errorValue = stuff->destKind;
	return BadValue;
d680 38
a717 41
    if (pRegion)
    {
	pRegion = XFixesRegionCopy (pRegion);
	if (!pRegion)
	    return BadAlloc;
	if (!pWin->optional)
	    MakeWindowOptional (pWin);
	switch (stuff->destKind) {
	default:
	case ShapeBounding:
	    pDestRegion = &pWin->optional->boundingShape;
	    break;
	case ShapeClip:
	    pDestRegion = &pWin->optional->clipShape;
	    break;
	case ShapeInput:
	    pDestRegion = &pWin->optional->inputShape;
	    break;
	}
	if (stuff->xOff || stuff->yOff)
	    RegionTranslate(pRegion, stuff->xOff, stuff->yOff);
    }
    else
    {
	if (pWin->optional)
	{
	    switch (stuff->destKind) {
	    default:
	    case ShapeBounding:
		pDestRegion = &pWin->optional->boundingShape;
		break;
	    case ShapeClip:
		pDestRegion = &pWin->optional->clipShape;
		break;
	    case ShapeInput:
		pDestRegion = &pWin->optional->inputShape;
		break;
	    }
	}
	else
	    pDestRegion = &pRegion; /* a NULL region pointer */
d720 1
a720 1
	RegionDestroy(*pDestRegion);
d723 1
a723 1
    SendShapeNotify (pWin, stuff->destKind);
d728 1
a728 1
SProcXFixesSetWindowShapeRegion (ClientPtr client)
a729 1
    int n;
d732 1
a732 1
    swaps (&stuff->length, n);
d734 4
a737 4
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    swapl (&stuff->region, n);
d742 1
a742 1
ProcXFixesSetPictureClipRegion (ClientPtr client)
d744 3
a746 2
    PicturePtr		pPicture;
    RegionPtr		pRegion;
d748 2
a749 2
    
    REQUEST_SIZE_MATCH (xXFixesSetPictureClipRegionReq);
d752 3
a754 3
    
    return SetPictureClipRegion (pPicture, stuff->xOrigin, stuff->yOrigin,
				 pRegion);
d758 1
a758 1
SProcXFixesSetPictureClipRegion (ClientPtr client)
a759 1
    int n;
d761 7
a767 7
    
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesSetPictureClipRegionReq);
    swapl (&stuff->picture, n);
    swapl (&stuff->region, n);
    swaps (&stuff->xOrigin, n);
    swaps (&stuff->yOrigin, n);
d772 1
a772 1
ProcXFixesExpandRegion (ClientPtr client)
d774 7
a780 6
    RegionPtr	pSource, pDestination;
    REQUEST (xXFixesExpandRegionReq);
    BoxPtr	pTmp;
    BoxPtr	pSrc;
    int		nBoxes;
    int		i;
d782 1
a782 1
    REQUEST_SIZE_MATCH (xXFixesExpandRegionReq);
d785 1
a785 1
    
d788 18
a805 20
    if (nBoxes)
    {
	pTmp = malloc(nBoxes * sizeof (BoxRec));
	if (!pTmp)
	    return BadAlloc;
	for (i = 0; i < nBoxes; i++)
	{
	    pTmp[i].x1 = pSrc[i].x1 - stuff->left;
	    pTmp[i].x2 = pSrc[i].x2 + stuff->right;
	    pTmp[i].y1 = pSrc[i].y1 - stuff->top;
	    pTmp[i].y2 = pSrc[i].y2 + stuff->bottom;
	}
	RegionEmpty(pDestination);
	for (i = 0; i < nBoxes; i++)
	{
	    RegionRec	r;
	    RegionInit(&r, &pTmp[i], 0);
	    RegionUnion(pDestination, pDestination, &r);
	}
	free(pTmp);
d811 12
a822 13
SProcXFixesExpandRegion (ClientPtr client)
{
    int n;
    REQUEST (xXFixesExpandRegionReq);

    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xXFixesExpandRegionReq);
    swapl (&stuff->source, n);
    swapl (&stuff->destination, n);
    swaps (&stuff->left, n);
    swaps (&stuff->right, n);
    swaps (&stuff->top, n);
    swaps (&stuff->bottom, n);
d831 1
a831 1
PanoramiXFixesSetGCClipRegion (ClientPtr client)
d834 3
a836 2
    int		    result = Success, j;
    PanoramiXRes    *gc;
d839 4
a842 4
    if ((result = dixLookupResourceByType((void **)&gc, stuff->gc, XRT_GC,
					  client, DixWriteAccess))) {
	client->errorValue = stuff->gc;
	return result;
d848 2
a849 1
        if(result != Success) break;
d856 1
a856 1
PanoramiXFixesSetWindowShapeRegion (ClientPtr client)
d858 3
a860 2
    int		    result = Success, j;
    PanoramiXRes    *win;
d865 5
a869 5
    if ((result = dixLookupResourceByType((void **)&win, stuff->dest,
					  XRT_WINDOW, client,
					  DixWriteAccess))) {
	client->errorValue = stuff->dest;
	return result;
d873 5
a877 3
	stuff->dest = win->info[j].id;
	result = (*PanoramiXSaveXFixesVector[X_XFixesSetWindowShapeRegion]) (client);
        if(result != Success) break;
d884 1
a884 1
PanoramiXFixesSetPictureClipRegion (ClientPtr client)
d887 2
a888 2
    int		    result = Success, j;
    PanoramiXRes    *pict;
d890 1
a890 1
    REQUEST_SIZE_MATCH (xXFixesSetPictureClipRegionReq);
d892 5
a896 5
    if ((result = dixLookupResourceByType((void **)&pict, stuff->picture,
					  XRT_PICTURE, client,
					  DixWriteAccess))) {
	client->errorValue = stuff->picture;
	return result;
d901 4
a904 2
	result = (*PanoramiXSaveXFixesVector[X_XFixesSetPictureClipRegion]) (client);
        if(result != Success) break;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a758 2
    ScreenPtr		pScreen;
    PictureScreenPtr	ps;
a762 2
    pScreen = pPicture->pDrawable->pScreen;
    ps = GetPictureScreen (pScreen);
d841 78
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a28 1
#ifdef RENDER
a30 1
#endif
d42 1
a42 1
    REGION_DESTROY (0, pRegion);
d49 2
a50 2
    RegionPtr   pNew = REGION_CREATE (0, REGION_EXTENTS(0, pRegion),
				      REGION_NUM_RECTS(pRegion));
d53 1
a53 1
    if (!REGION_COPY (0, pNew, pRegion))
d55 1
a55 1
	REGION_DESTROY (0, pNew);
d66 1
a66 1
    return (RegionResType != 0);
d84 1
a84 1
    pRegion = RECTS_TO_REGION(0, things, (xRectangle *) (stuff + 1), CT_UNSORTED);
d90 1
a90 1
    return(client->noClientException);
d122 1
a122 1
	return (rc == BadValue) ? BadPixmap : rc;
d127 1
a127 1
    pRegion = BITMAP_TO_REGION(pPixmap->drawable.pScreen, pPixmap);
d135 1
a135 1
    return(client->noClientException);
d167 1
a167 1
	return (rc == BadValue) ? BadWindow : rc;
d197 1
a197 1
    return(client->noClientException);
d230 1
a230 1
	pRegion = BITMAP_TO_REGION(pGC->pScreen, (PixmapPtr) pGC->clientClip);
d247 1
a247 1
    return(client->noClientException);
a265 1
#ifdef RENDER
d273 1
a273 2
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixGetAttrAccess,
		   RenderErrBase + BadPicture);
d277 1
a277 1
	pRegion = BITMAP_TO_REGION(pPicture->pDrawable->pScreen,
d294 1
a294 4
    return(client->noClientException);
#else
    return BadRequest;
#endif
d319 1
a319 1
    return(client->noClientException);
d349 1
a349 1
    pNew = RECTS_TO_REGION(0, things, (xRectangle *) (stuff + 1), CT_UNSORTED);
d352 1
a352 1
    if (!REGION_COPY (0, pRegion, pNew))
d354 1
a354 1
	REGION_DESTROY (0, pNew);
d357 2
a358 2
    REGION_DESTROY (0, pNew);
    return(client->noClientException);
d383 1
a383 1
    if (!REGION_COPY(pScreen, pDestination, pSource))
d386 1
a386 1
    return(client->noClientException);
a405 1
    int		ret = Success;
d415 2
a416 2
	if (!REGION_UNION (0, pDestination, pSource1, pSource2))
	    ret = BadAlloc;
d419 2
a420 2
	if (!REGION_INTERSECT (0, pDestination, pSource1, pSource2))
	    ret = BadAlloc;
d423 2
a424 2
	if (!REGION_SUBTRACT (0, pDestination, pSource1, pSource2))
	    ret = BadAlloc;
d428 1
a428 3
    if (ret == Success) 
	ret = client->noClientException;
    return ret;
a449 1
    int		ret = Success;
d469 2
a470 2
    if (!REGION_INVERSE(0, pDestination, pSource, &bounds))
	ret = BadAlloc;
d472 1
a472 3
    if (ret == Success)
	ret = client->noClientException;
    return ret;
d501 2
a502 2
    REGION_TRANSLATE(pScreen, pRegion, stuff->dx, stuff->dy);
    return (client->noClientException);
d529 1
a529 1
    REGION_RESET (0, pDestination, REGION_EXTENTS (0, pSource));
d531 1
a531 1
    return (client->noClientException);
d561 3
a563 3
    pExtent = REGION_EXTENTS (0, pRegion);
    pBox = REGION_RECTS (pRegion);
    nBox = REGION_NUM_RECTS (pRegion);
d565 1
a565 1
    reply = xalloc (sizeof (xXFixesFetchRegionReply) +
d598 2
a599 2
    xfree (reply);
    return (client->noClientException);
d619 1
a619 1
    XID		vals[2];
d637 3
a639 3
    vals[0] = stuff->xOrigin;
    vals[1] = stuff->yOrigin;
    DoChangeGC (pGC, GCClipXOrigin|GCClipYOrigin, vals, 0);
d642 1
a642 1
    return (client->noClientException);
a665 1
    ScreenPtr	    pScreen;
d677 1
a677 1
	return (rc == BadValue) ? BadWindow : rc;
a679 1
    pScreen = pWin->drawable.pScreen;
d709 1
a709 1
	    REGION_TRANSLATE (0, pRegion, stuff->xOff, stuff->yOff);
d732 1
a732 1
	REGION_DESTROY(pScreen, *pDestRegion);
d734 1
a734 1
    (*pScreen->SetShape) (pWin);
d736 1
a736 1
    return (client->noClientException);
a756 1
#ifdef RENDER
d764 1
a764 2
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixSetAttrAccess,
		   RenderErrBase + BadPicture);
a770 3
#else
    return BadRequest;
#endif
a791 1
    int		ret = Success;
d802 2
a803 2
    nBoxes = REGION_NUM_RECTS(pSource);
    pSrc = REGION_RECTS(pSource);
d806 1
a806 1
	pTmp = xalloc (nBoxes * sizeof (BoxRec));
d816 1
a816 1
	REGION_EMPTY (pScreen, pDestination);
d820 2
a821 2
	    REGION_INIT (pScreen, &r, &pTmp[i], 0);
	    REGION_UNION (pScreen, pDestination, pDestination, &r);
d823 1
a823 1
	xfree(pTmp);
d825 1
a825 3
    if (ret == Success) 
	ret = client->noClientException;
    return ret;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d37 1
a37 1
RESTYPE	    RegionResType;
d66 3
a68 2
    RegionResType = CreateNewResourceType(RegionResFree);
    return TRUE;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d118 1
a118 1
    rc = dixLookupResource((pointer *)&pPixmap, stuff->bitmap, RT_PIXMAP,
d163 1
a163 1
    rc = dixLookupResource((pointer *)&pWin, stuff->window, RT_WINDOW,
a171 1
#ifdef SHAPE
a173 1
#endif
a179 1
#ifdef SHAPE
a181 1
#endif
a676 1
#ifdef SHAPE
d685 1
a685 1
    rc = dixLookupResource((pointer *)&pWin, stuff->dest, RT_WINDOW,
a750 3
#else
    return BadRequest;
#endif
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d112 1
d118 3
a120 4
    pPixmap = (PixmapPtr) SecurityLookupIDByType (client, stuff->bitmap,
						  RT_PIXMAP,
						  SecurityReadAccess);
    if (!pPixmap)
d123 1
a123 1
	return BadPixmap;
d158 1
d163 3
a165 2
    pWin = (WindowPtr) LookupIDByType (stuff->window, RT_WINDOW);
    if (!pWin)
d168 1
a168 1
	return BadWindow;
d223 1
d229 3
a231 1
    SECURITY_VERIFY_GC(pGC, stuff->gc, client, SecurityReadAccess);
d279 1
a279 1
    VERIFY_PICTURE(pPicture, stuff->picture, client, SecurityReadAccess,
d327 1
a327 1
    VERIFY_REGION(pRegion, stuff->region, client, SecurityWriteAccess);
d352 1
a352 1
    VERIFY_REGION(pRegion, stuff->region, client, SecurityWriteAccess);
d390 2
a391 2
    VERIFY_REGION(pSource, stuff->source, client, SecurityReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, SecurityWriteAccess);
d420 3
a422 3
    VERIFY_REGION(pSource1, stuff->source1, client, SecurityReadAccess);
    VERIFY_REGION(pSource2, stuff->source2, client, SecurityReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, SecurityWriteAccess);
d467 2
a468 2
    VERIFY_REGION(pSource, stuff->source, client, SecurityReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, SecurityWriteAccess);
d515 1
a515 1
    VERIFY_REGION(pRegion, stuff->region, client, SecurityWriteAccess);
d542 2
a543 2
    VERIFY_REGION(pSource, stuff->source, client, SecurityReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, SecurityWriteAccess);
d575 1
a575 1
    VERIFY_REGION(pRegion, stuff->region, client, SecurityReadAccess);
d636 1
d638 1
d640 5
a644 3
    REQUEST_SIZE_MATCH(xXFixesSetGCClipRegionReq);
    SECURITY_VERIFY_GC(pGC, stuff->gc, client, SecurityWriteAccess);
    VERIFY_REGION_OR_NONE (pRegion, stuff->region, client, SecurityReadAccess);
d686 1
d690 3
a692 2
    pWin = (WindowPtr) LookupIDByType (stuff->dest, RT_WINDOW);
    if (!pWin)
d695 1
a695 1
	return BadWindow;
d697 1
a697 1
    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, SecurityWriteAccess);
d787 1
a787 1
    VERIFY_PICTURE(pPicture, stuff->picture, client, SecurityWriteAccess,
d791 1
a791 1
    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, SecurityReadAccess);
d827 2
a828 2
    VERIFY_REGION(pSource, stuff->source, client, SecurityReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, SecurityWriteAccess);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
d121 1
a121 1
						  DixReadAccess);
a222 1
    int 	rc;
d228 1
a228 3
    rc = dixLookupGC(&pGC, stuff->gc, client, DixReadAccess);
    if (rc != Success)
	return rc;
d276 1
a276 1
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixReadAccess,
d324 1
a324 1
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);
d349 1
a349 1
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);
d387 2
a388 2
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
d417 3
a419 3
    VERIFY_REGION(pSource1, stuff->source1, client, DixReadAccess);
    VERIFY_REGION(pSource2, stuff->source2, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
d464 2
a465 2
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
d512 1
a512 1
    VERIFY_REGION(pRegion, stuff->region, client, DixWriteAccess);
d539 2
a540 2
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
d572 1
a572 1
    VERIFY_REGION(pRegion, stuff->region, client, DixReadAccess);
a632 1
    int		rc;
d634 1
d636 2
a637 6

    rc = dixLookupGC(&pGC, stuff->gc, client, DixWriteAccess);
    if (rc != Success)
	return rc;

    VERIFY_REGION_OR_NONE (pRegion, stuff->region, client, DixReadAccess);
d688 1
a688 1
    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, DixWriteAccess);
d778 1
a778 1
    VERIFY_PICTURE(pPicture, stuff->picture, client, DixWriteAccess,
d782 1
a782 1
    VERIFY_REGION_OR_NONE(pRegion, stuff->region, client, DixReadAccess);
d818 2
a819 2
    VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);
    VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);
@

