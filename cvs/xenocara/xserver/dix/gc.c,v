head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.20;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.20;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.22;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xmd.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "resource.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "dixfontstr.h"
#include "scrnintstr.h"
#include "region.h"
#include "dixstruct.h"

#include "privates.h"
#include "dix.h"
#include "xace.h"
#include <assert.h>

extern FontPtr defaultFont;

static Bool CreateDefaultTile(GCPtr pGC);

static unsigned char DefaultDash[2] = { 4, 4 };

void
ValidateGC(DrawablePtr pDraw, GC * pGC)
{
    (*pGC->funcs->ValidateGC) (pGC, pGC->stateChanges, pDraw);
    pGC->stateChanges = 0;
    pGC->serialNumber = pDraw->serialNumber;
}

/*
 * ChangeGC/ChangeGCXIDs:
 *
 * The client performing the gc change must be passed so that access
 * checks can be performed on any tiles, stipples, or fonts that are
 * specified.  ddxen can call this too; they should normally pass
 * NullClient for the client since any access checking should have
 * already been done at a higher level.
 *
 * If you have any XIDs, you must use ChangeGCXIDs:
 *
 *     CARD32 v[2];
 *     v[0] = FillTiled;
 *     v[1] = pid;
 *     ChangeGCXIDs(client, pGC, GCFillStyle|GCTile, v);
 *
 * However, if you need to pass a pointer to a pixmap or font, you must
 * use ChangeGC:
 *
 *     ChangeGCVal v[2];
 *     v[0].val = FillTiled;
 *     v[1].ptr = pPixmap;
 *     ChangeGC(client, pGC, GCFillStyle|GCTile, v);
 *
 * If you have neither XIDs nor pointers, you can use either function,
 * but ChangeGC will do less work.
 *
 *     ChangeGCVal v[2];
 *     v[0].val = foreground;
 *     v[1].val = background;
 *     ChangeGC(client, pGC, GCForeground|GCBackground, v);
 */

#define NEXTVAL(_type, _var) { \
	_var = (_type)(pUnion->val); pUnion++; \
    }

#define NEXT_PTR(_type, _var) { \
    _var = (_type)pUnion->ptr; pUnion++; }

int
ChangeGC(ClientPtr client, GC * pGC, BITS32 mask, ChangeGCValPtr pUnion)
{
    BITS32 index2;
    int error = 0;
    PixmapPtr pPixmap;
    BITS32 maskQ;

    assert(pUnion);
    pGC->serialNumber |= GC_CHANGE_SERIAL_BIT;

    maskQ = mask;               /* save these for when we walk the GCque */
    while (mask && !error) {
        index2 = (BITS32) lowbit(mask);
        mask &= ~index2;
        pGC->stateChanges |= index2;
        switch (index2) {
        case GCFunction:
        {
            CARD8 newalu;
            NEXTVAL(CARD8, newalu);

            if (newalu <= GXset)
                pGC->alu = newalu;
            else {
                if (client)
                    client->errorValue = newalu;
                error = BadValue;
            }
            break;
        }
        case GCPlaneMask:
            NEXTVAL(unsigned long, pGC->planemask);

            break;
        case GCForeground:
            NEXTVAL(unsigned long, pGC->fgPixel);

            /*
             * this is for CreateGC
             */
            if (!pGC->tileIsPixel && !pGC->tile.pixmap) {
                pGC->tileIsPixel = TRUE;
                pGC->tile.pixel = pGC->fgPixel;
            }
            break;
        case GCBackground:
            NEXTVAL(unsigned long, pGC->bgPixel);

            break;
        case GCLineWidth:      /* ??? line width is a CARD16 */
            NEXTVAL(CARD16, pGC->lineWidth);

            break;
        case GCLineStyle:
        {
            unsigned int newlinestyle;
            NEXTVAL(unsigned int, newlinestyle);

            if (newlinestyle <= LineDoubleDash)
                pGC->lineStyle = newlinestyle;
            else {
                if (client)
                    client->errorValue = newlinestyle;
                error = BadValue;
            }
            break;
        }
        case GCCapStyle:
        {
            unsigned int newcapstyle;
            NEXTVAL(unsigned int, newcapstyle);

            if (newcapstyle <= CapProjecting)
                pGC->capStyle = newcapstyle;
            else {
                if (client)
                    client->errorValue = newcapstyle;
                error = BadValue;
            }
            break;
        }
        case GCJoinStyle:
        {
            unsigned int newjoinstyle;
            NEXTVAL(unsigned int, newjoinstyle);

            if (newjoinstyle <= JoinBevel)
                pGC->joinStyle = newjoinstyle;
            else {
                if (client)
                    client->errorValue = newjoinstyle;
                error = BadValue;
            }
            break;
        }
        case GCFillStyle:
        {
            unsigned int newfillstyle;
            NEXTVAL(unsigned int, newfillstyle);

            if (newfillstyle <= FillOpaqueStippled)
                pGC->fillStyle = newfillstyle;
            else {
                if (client)
                    client->errorValue = newfillstyle;
                error = BadValue;
            }
            break;
        }
        case GCFillRule:
        {
            unsigned int newfillrule;
            NEXTVAL(unsigned int, newfillrule);

            if (newfillrule <= WindingRule)
                pGC->fillRule = newfillrule;
            else {
                if (client)
                    client->errorValue = newfillrule;
                error = BadValue;
            }
            break;
        }
        case GCTile:
            NEXT_PTR(PixmapPtr, pPixmap);

            if ((pPixmap->drawable.depth != pGC->depth) ||
                (pPixmap->drawable.pScreen != pGC->pScreen)) {
                error = BadMatch;
            }
            else {
                pPixmap->refcnt++;
                if (!pGC->tileIsPixel)
                    (*pGC->pScreen->DestroyPixmap) (pGC->tile.pixmap);
                pGC->tileIsPixel = FALSE;
                pGC->tile.pixmap = pPixmap;
            }
            break;
        case GCStipple:
            NEXT_PTR(PixmapPtr, pPixmap);

            if (pPixmap && ((pPixmap->drawable.depth != 1) ||
                            (pPixmap->drawable.pScreen != pGC->pScreen)))
            {
                error = BadMatch;
            }
            else {
                if (pPixmap)
                    pPixmap->refcnt++;
                if (pGC->stipple)
                    (*pGC->pScreen->DestroyPixmap) (pGC->stipple);
                pGC->stipple = pPixmap;
            }
            break;
        case GCTileStipXOrigin:
            NEXTVAL(INT16, pGC->patOrg.x);

            break;
        case GCTileStipYOrigin:
            NEXTVAL(INT16, pGC->patOrg.y);

            break;
        case GCFont:
        {
            FontPtr pFont;
            NEXT_PTR(FontPtr, pFont);

            pFont->refcnt++;
            if (pGC->font)
                CloseFont(pGC->font, (Font) 0);
            pGC->font = pFont;
            break;
        }
        case GCSubwindowMode:
        {
            unsigned int newclipmode;
            NEXTVAL(unsigned int, newclipmode);

            if (newclipmode <= IncludeInferiors)
                pGC->subWindowMode = newclipmode;
            else {
                if (client)
                    client->errorValue = newclipmode;
                error = BadValue;
            }
            break;
        }
        case GCGraphicsExposures:
        {
            unsigned int newge;
            NEXTVAL(unsigned int, newge);

            if (newge <= xTrue)
                pGC->graphicsExposures = newge;
            else {
                if (client)
                    client->errorValue = newge;
                error = BadValue;
            }
            break;
        }
        case GCClipXOrigin:
            NEXTVAL(INT16, pGC->clipOrg.x);

            break;
        case GCClipYOrigin:
            NEXTVAL(INT16, pGC->clipOrg.y);

            break;
        case GCClipMask:
            NEXT_PTR(PixmapPtr, pPixmap);

            if (pPixmap) {
                if ((pPixmap->drawable.depth != 1) ||
                    (pPixmap->drawable.pScreen != pGC->pScreen)) {
                    error = BadMatch;
                    break;
                }
                pPixmap->refcnt++;
            }
            (*pGC->funcs->ChangeClip) (pGC, pPixmap ? CT_PIXMAP : CT_NONE,
                                       (void *) pPixmap, 0);
            break;
        case GCDashOffset:
            NEXTVAL(INT16, pGC->dashOffset);

            break;
        case GCDashList:
        {
            CARD8 newdash;
            NEXTVAL(CARD8, newdash);

            if (newdash == 4) {
                if (pGC->dash != DefaultDash) {
                    free(pGC->dash);
                    pGC->numInDashList = 2;
                    pGC->dash = DefaultDash;
                }
            }
            else if (newdash != 0) {
                unsigned char *dash;

                dash = malloc(2 * sizeof(unsigned char));
                if (dash) {
                    if (pGC->dash != DefaultDash)
                        free(pGC->dash);
                    pGC->numInDashList = 2;
                    pGC->dash = dash;
                    dash[0] = newdash;
                    dash[1] = newdash;
                }
                else
                    error = BadAlloc;
            }
            else {
                if (client)
                    client->errorValue = newdash;
                error = BadValue;
            }
            break;
        }
        case GCArcMode:
        {
            unsigned int newarcmode;
            NEXTVAL(unsigned int, newarcmode);

            if (newarcmode <= ArcPieSlice)
                pGC->arcMode = newarcmode;
            else {
                if (client)
                    client->errorValue = newarcmode;
                error = BadValue;
            }
            break;
        }
        default:
            if (client)
                client->errorValue = maskQ;
            error = BadValue;
            break;
        }
    }                           /* end while mask && !error */

    if (pGC->fillStyle == FillTiled && pGC->tileIsPixel) {
        if (!CreateDefaultTile(pGC)) {
            pGC->fillStyle = FillSolid;
            error = BadAlloc;
        }
    }
    (*pGC->funcs->ChangeGC) (pGC, maskQ);
    return error;
}

#undef NEXTVAL
#undef NEXT_PTR

static const struct {
    BITS32 mask;
    RESTYPE type;
    Mask access_mode;
} xidfields[] = {
    {GCTile, RT_PIXMAP, DixReadAccess},
    {GCStipple, RT_PIXMAP, DixReadAccess},
    {GCFont, RT_FONT, DixUseAccess},
    {GCClipMask, RT_PIXMAP, DixReadAccess},
};

int
ChangeGCXIDs(ClientPtr client, GC * pGC, BITS32 mask, CARD32 *pC32)
{
    ChangeGCVal vals[GCLastBit + 1];
    int i;

    if (mask & ~GCAllBits) {
        client->errorValue = mask;
        return BadValue;
    }
    for (i = Ones(mask); i--;)
        vals[i].val = pC32[i];
    for (i = 0; i < sizeof(xidfields) / sizeof(*xidfields); ++i) {
        int offset, rc;

        if (!(mask & xidfields[i].mask))
            continue;
        offset = Ones(mask & (xidfields[i].mask - 1));
        if (xidfields[i].mask == GCClipMask && vals[offset].val == None) {
            vals[offset].ptr = NullPixmap;
            continue;
        }
        rc = dixLookupResourceByType(&vals[offset].ptr, vals[offset].val,
                                     xidfields[i].type, client,
                                     xidfields[i].access_mode);
        if (rc != Success) {
            client->errorValue = vals[offset].val;
            return rc;
        }
    }
    return ChangeGC(client, pGC, mask, vals);
}

static GCPtr
NewGCObject(ScreenPtr pScreen, int depth)
{
    GCPtr pGC;

    pGC = dixAllocateScreenObjectWithPrivates(pScreen, GC, PRIVATE_GC);
    if (!pGC) {
        return (GCPtr) NULL;
    }

    pGC->pScreen = pScreen;
    pGC->depth = depth;
    pGC->alu = GXcopy;          /* dst <- src */
    pGC->planemask = ~0;
    pGC->serialNumber = 0;
    pGC->funcs = 0;
    pGC->fgPixel = 0;
    pGC->bgPixel = 1;
    pGC->lineWidth = 0;
    pGC->lineStyle = LineSolid;
    pGC->capStyle = CapButt;
    pGC->joinStyle = JoinMiter;
    pGC->fillStyle = FillSolid;
    pGC->fillRule = EvenOddRule;
    pGC->arcMode = ArcPieSlice;
    pGC->tile.pixel = 0;
    pGC->tile.pixmap = NullPixmap;

    pGC->tileIsPixel = TRUE;
    pGC->patOrg.x = 0;
    pGC->patOrg.y = 0;
    pGC->subWindowMode = ClipByChildren;
    pGC->graphicsExposures = TRUE;
    pGC->clipOrg.x = 0;
    pGC->clipOrg.y = 0;
    pGC->clientClip = (void *) NULL;
    pGC->numInDashList = 2;
    pGC->dash = DefaultDash;
    pGC->dashOffset = 0;

    /* use the default font and stipple */
    pGC->font = defaultFont;
    if (pGC->font)              /* necessary, because open of default font could fail */
        pGC->font->refcnt++;
    pGC->stipple = pGC->pScreen->PixmapPerDepth[0];
    if (pGC->stipple)
        pGC->stipple->refcnt++;

    /* this is not a scratch GC */
    pGC->scratch_inuse = FALSE;
    return pGC;
}

/* CreateGC(pDrawable, mask, pval, pStatus)
   creates a default GC for the given drawable, using mask to fill
   in any non-default values.
   Returns a pointer to the new GC on success, NULL otherwise.
   returns status of non-default fields in pStatus
BUG:
   should check for failure to create default tile

*/
GCPtr
CreateGC(DrawablePtr pDrawable, BITS32 mask, XID *pval, int *pStatus,
         XID gcid, ClientPtr client)
{
    GCPtr pGC;

    pGC = NewGCObject(pDrawable->pScreen, pDrawable->depth);
    if (!pGC) {
        *pStatus = BadAlloc;
        return (GCPtr) NULL;
    }

    pGC->serialNumber = GC_CHANGE_SERIAL_BIT;
    if (mask & GCForeground) {
        /*
         * magic special case -- ChangeGC checks for this condition
         * and snags the Foreground value to create a pseudo default-tile
         */
        pGC->tileIsPixel = FALSE;
    }
    else {
        pGC->tileIsPixel = TRUE;
    }

    /* security creation/labeling check */
    *pStatus = XaceHook(XACE_RESOURCE_ACCESS, client, gcid, RT_GC, pGC,
                        RT_NONE, NULL, DixCreateAccess | DixSetAttrAccess);
    if (*pStatus != Success)
        goto out;

    pGC->stateChanges = GCAllBits;
    if (!(*pGC->pScreen->CreateGC) (pGC))
        *pStatus = BadAlloc;
    else if (mask)
        *pStatus = ChangeGCXIDs(client, pGC, mask, pval);
    else
        *pStatus = Success;

 out:
    if (*pStatus != Success) {
        if (!pGC->tileIsPixel && !pGC->tile.pixmap)
            pGC->tileIsPixel = TRUE;    /* undo special case */
        FreeGC(pGC, (XID) 0);
        pGC = (GCPtr) NULL;
    }

    return pGC;
}

static Bool
CreateDefaultTile(GCPtr pGC)
{
    ChangeGCVal tmpval[3];
    PixmapPtr pTile;
    GCPtr pgcScratch;
    xRectangle rect;
    CARD16 w, h;

    w = 1;
    h = 1;
    (*pGC->pScreen->QueryBestSize) (TileShape, &w, &h, pGC->pScreen);
    pTile = (PixmapPtr)
        (*pGC->pScreen->CreatePixmap) (pGC->pScreen, w, h, pGC->depth, 0);
    pgcScratch = GetScratchGC(pGC->depth, pGC->pScreen);
    if (!pTile || !pgcScratch) {
        if (pTile)
            (*pTile->drawable.pScreen->DestroyPixmap) (pTile);
        if (pgcScratch)
            FreeScratchGC(pgcScratch);
        return FALSE;
    }
    tmpval[0].val = GXcopy;
    tmpval[1].val = pGC->tile.pixel;
    tmpval[2].val = FillSolid;
    (void) ChangeGC(NullClient, pgcScratch,
                    GCFunction | GCForeground | GCFillStyle, tmpval);
    ValidateGC((DrawablePtr) pTile, pgcScratch);
    rect.x = 0;
    rect.y = 0;
    rect.width = w;
    rect.height = h;
    (*pgcScratch->ops->PolyFillRect) ((DrawablePtr) pTile, pgcScratch, 1,
                                      &rect);
    /* Always remember to free the scratch graphics context after use. */
    FreeScratchGC(pgcScratch);

    pGC->tileIsPixel = FALSE;
    pGC->tile.pixmap = pTile;
    return TRUE;
}

int
CopyGC(GC * pgcSrc, GC * pgcDst, BITS32 mask)
{
    BITS32 index2;
    BITS32 maskQ;
    int error = 0;

    if (pgcSrc == pgcDst)
        return Success;
    pgcDst->serialNumber |= GC_CHANGE_SERIAL_BIT;
    pgcDst->stateChanges |= mask;
    maskQ = mask;
    while (mask) {
        index2 = (BITS32) lowbit(mask);
        mask &= ~index2;
        switch (index2) {
        case GCFunction:
            pgcDst->alu = pgcSrc->alu;
            break;
        case GCPlaneMask:
            pgcDst->planemask = pgcSrc->planemask;
            break;
        case GCForeground:
            pgcDst->fgPixel = pgcSrc->fgPixel;
            break;
        case GCBackground:
            pgcDst->bgPixel = pgcSrc->bgPixel;
            break;
        case GCLineWidth:
            pgcDst->lineWidth = pgcSrc->lineWidth;
            break;
        case GCLineStyle:
            pgcDst->lineStyle = pgcSrc->lineStyle;
            break;
        case GCCapStyle:
            pgcDst->capStyle = pgcSrc->capStyle;
            break;
        case GCJoinStyle:
            pgcDst->joinStyle = pgcSrc->joinStyle;
            break;
        case GCFillStyle:
            pgcDst->fillStyle = pgcSrc->fillStyle;
            break;
        case GCFillRule:
            pgcDst->fillRule = pgcSrc->fillRule;
            break;
        case GCTile:
        {
            if (EqualPixUnion(pgcDst->tileIsPixel,
                              pgcDst->tile,
                              pgcSrc->tileIsPixel, pgcSrc->tile)) {
                break;
            }
            if (!pgcDst->tileIsPixel)
                (*pgcDst->pScreen->DestroyPixmap) (pgcDst->tile.pixmap);
            pgcDst->tileIsPixel = pgcSrc->tileIsPixel;
            pgcDst->tile = pgcSrc->tile;
            if (!pgcDst->tileIsPixel)
                pgcDst->tile.pixmap->refcnt++;
            break;
        }
        case GCStipple:
        {
            if (pgcDst->stipple == pgcSrc->stipple)
                break;
            if (pgcDst->stipple)
                (*pgcDst->pScreen->DestroyPixmap) (pgcDst->stipple);
            pgcDst->stipple = pgcSrc->stipple;
            if (pgcDst->stipple)
                pgcDst->stipple->refcnt++;
            break;
        }
        case GCTileStipXOrigin:
            pgcDst->patOrg.x = pgcSrc->patOrg.x;
            break;
        case GCTileStipYOrigin:
            pgcDst->patOrg.y = pgcSrc->patOrg.y;
            break;
        case GCFont:
            if (pgcDst->font == pgcSrc->font)
                break;
            if (pgcDst->font)
                CloseFont(pgcDst->font, (Font) 0);
            if ((pgcDst->font = pgcSrc->font) != NullFont)
                (pgcDst->font)->refcnt++;
            break;
        case GCSubwindowMode:
            pgcDst->subWindowMode = pgcSrc->subWindowMode;
            break;
        case GCGraphicsExposures:
            pgcDst->graphicsExposures = pgcSrc->graphicsExposures;
            break;
        case GCClipXOrigin:
            pgcDst->clipOrg.x = pgcSrc->clipOrg.x;
            break;
        case GCClipYOrigin:
            pgcDst->clipOrg.y = pgcSrc->clipOrg.y;
            break;
        case GCClipMask:
            (*pgcDst->funcs->CopyClip) (pgcDst, pgcSrc);
            break;
        case GCDashOffset:
            pgcDst->dashOffset = pgcSrc->dashOffset;
            break;
        case GCDashList:
            if (pgcSrc->dash == DefaultDash) {
                if (pgcDst->dash != DefaultDash) {
                    free(pgcDst->dash);
                    pgcDst->numInDashList = pgcSrc->numInDashList;
                    pgcDst->dash = pgcSrc->dash;
                }
            }
            else {
                unsigned char *dash;
                unsigned int i;

                dash = malloc(pgcSrc->numInDashList * sizeof(unsigned char));
                if (dash) {
                    if (pgcDst->dash != DefaultDash)
                        free(pgcDst->dash);
                    pgcDst->numInDashList = pgcSrc->numInDashList;
                    pgcDst->dash = dash;
                    for (i = 0; i < pgcSrc->numInDashList; i++)
                        dash[i] = pgcSrc->dash[i];
                }
                else
                    error = BadAlloc;
            }
            break;
        case GCArcMode:
            pgcDst->arcMode = pgcSrc->arcMode;
            break;
        default:
            FatalError("CopyGC: Unhandled mask!\n");
        }
    }
    if (pgcDst->fillStyle == FillTiled && pgcDst->tileIsPixel) {
        if (!CreateDefaultTile(pgcDst)) {
            pgcDst->fillStyle = FillSolid;
            error = BadAlloc;
        }
    }
    (*pgcDst->funcs->CopyGC) (pgcSrc, maskQ, pgcDst);
    return error;
}

/**
 * does the diX part of freeing the characteristics in the GC.
 *
 *  \param value  must conform to DeleteType
 */
int
FreeGC(void *value, XID gid)
{
    GCPtr pGC = (GCPtr) value;

    CloseFont(pGC->font, (Font) 0);
    (*pGC->funcs->DestroyClip) (pGC);

    if (!pGC->tileIsPixel)
        (*pGC->pScreen->DestroyPixmap) (pGC->tile.pixmap);
    if (pGC->stipple)
        (*pGC->pScreen->DestroyPixmap) (pGC->stipple);

    (*pGC->funcs->DestroyGC) (pGC);
    if (pGC->dash != DefaultDash)
        free(pGC->dash);
    dixFreeObjectWithPrivates(pGC, PRIVATE_GC);
    return Success;
}

/* CreateScratchGC(pScreen, depth)
    like CreateGC, but doesn't do the default tile or stipple,
since we can't create them without already having a GC.  any code
using the tile or stipple has to set them explicitly anyway,
since the state of the scratch gc is unknown.  This is OK
because ChangeGC() has to be able to deal with NULL tiles and
stipples anyway (in case the CreateGC() call has provided a
value for them -- we can't set the default tile until the
client-supplied attributes are installed, since the fgPixel
is what fills the default tile.  (maybe this comment should
go with CreateGC() or ChangeGC().)
*/

static GCPtr
CreateScratchGC(ScreenPtr pScreen, unsigned depth)
{
    GCPtr pGC;

    pGC = NewGCObject(pScreen, depth);
    if (!pGC)
        return (GCPtr) NULL;

    pGC->stateChanges = GCAllBits;
    if (!(*pScreen->CreateGC) (pGC)) {
        FreeGC(pGC, (XID) 0);
        pGC = (GCPtr) NULL;
    }
    return pGC;
}

void
FreeGCperDepth(int screenNum)
{
    int i;
    ScreenPtr pScreen;
    GCPtr *ppGC;

    pScreen = screenInfo.screens[screenNum];
    ppGC = pScreen->GCperDepth;

    for (i = 0; i <= pScreen->numDepths; i++) {
        (void) FreeGC(ppGC[i], (XID) 0);
        ppGC[i] = NULL;
    }
}

Bool
CreateGCperDepth(int screenNum)
{
    int i;
    ScreenPtr pScreen;
    DepthPtr pDepth;
    GCPtr *ppGC;

    pScreen = screenInfo.screens[screenNum];
    ppGC = pScreen->GCperDepth;
    /* do depth 1 separately because it's not included in list */
    if (!(ppGC[0] = CreateScratchGC(pScreen, 1)))
        return FALSE;
    ppGC[0]->graphicsExposures = FALSE;
    /* Make sure we don't overflow GCperDepth[] */
    if (pScreen->numDepths > MAXFORMATS)
        return FALSE;

    pDepth = pScreen->allowedDepths;
    for (i = 0; i < pScreen->numDepths; i++, pDepth++) {
        if (!(ppGC[i + 1] = CreateScratchGC(pScreen, pDepth->depth))) {
            for (; i >= 0; i--)
                (void) FreeGC(ppGC[i], (XID) 0);
            return FALSE;
        }
        ppGC[i + 1]->graphicsExposures = FALSE;
    }
    return TRUE;
}

Bool
CreateDefaultStipple(int screenNum)
{
    ScreenPtr pScreen;
    ChangeGCVal tmpval[3];
    xRectangle rect;
    CARD16 w, h;
    GCPtr pgcScratch;

    pScreen = screenInfo.screens[screenNum];

    w = 16;
    h = 16;
    (*pScreen->QueryBestSize) (StippleShape, &w, &h, pScreen);
    if (!(pScreen->PixmapPerDepth[0] =
          (*pScreen->CreatePixmap) (pScreen, w, h, 1, 0)))
        return FALSE;
    /* fill stipple with 1 */
    tmpval[0].val = GXcopy;
    tmpval[1].val = 1;
    tmpval[2].val = FillSolid;
    pgcScratch = GetScratchGC(1, pScreen);
    if (!pgcScratch) {
        (*pScreen->DestroyPixmap) (pScreen->PixmapPerDepth[0]);
        return FALSE;
    }
    (void) ChangeGC(NullClient, pgcScratch,
                    GCFunction | GCForeground | GCFillStyle, tmpval);
    ValidateGC((DrawablePtr) pScreen->PixmapPerDepth[0], pgcScratch);
    rect.x = 0;
    rect.y = 0;
    rect.width = w;
    rect.height = h;
    (*pgcScratch->ops->PolyFillRect) ((DrawablePtr) pScreen->PixmapPerDepth[0],
                                      pgcScratch, 1, &rect);
    FreeScratchGC(pgcScratch);
    return TRUE;
}

void
FreeDefaultStipple(int screenNum)
{
    ScreenPtr pScreen = screenInfo.screens[screenNum];

    (*pScreen->DestroyPixmap) (pScreen->PixmapPerDepth[0]);
}

int
SetDashes(GCPtr pGC, unsigned offset, unsigned ndash, unsigned char *pdash)
{
    long i;
    unsigned char *p, *indash;
    BITS32 maskQ = 0;

    i = ndash;
    p = pdash;
    while (i--) {
        if (!*p++) {
            /* dash segment must be > 0 */
            return BadValue;
        }
    }

    if (ndash & 1)
        p = malloc(2 * ndash * sizeof(unsigned char));
    else
        p = malloc(ndash * sizeof(unsigned char));
    if (!p)
        return BadAlloc;

    pGC->serialNumber |= GC_CHANGE_SERIAL_BIT;
    if (offset != pGC->dashOffset) {
        pGC->dashOffset = offset;
        pGC->stateChanges |= GCDashOffset;
        maskQ |= GCDashOffset;
    }

    if (pGC->dash != DefaultDash)
        free(pGC->dash);
    pGC->numInDashList = ndash;
    pGC->dash = p;
    if (ndash & 1) {
        pGC->numInDashList += ndash;
        indash = pdash;
        i = ndash;
        while (i--)
            *p++ = *indash++;
    }
    while (ndash--)
        *p++ = *pdash++;
    pGC->stateChanges |= GCDashList;
    maskQ |= GCDashList;

    if (pGC->funcs->ChangeGC)
        (*pGC->funcs->ChangeGC) (pGC, maskQ);
    return Success;
}

int
VerifyRectOrder(int nrects, xRectangle *prects, int ordering)
{
    xRectangle *prectP, *prectN;
    int i;

    switch (ordering) {
    case Unsorted:
        return CT_UNSORTED;
    case YSorted:
        if (nrects > 1) {
            for (i = 1, prectP = prects, prectN = prects + 1;
                 i < nrects; i++, prectP++, prectN++)
                if (prectN->y < prectP->y)
                    return -1;
        }
        return CT_YSORTED;
    case YXSorted:
        if (nrects > 1) {
            for (i = 1, prectP = prects, prectN = prects + 1;
                 i < nrects; i++, prectP++, prectN++)
                if ((prectN->y < prectP->y) ||
                    ((prectN->y == prectP->y) && (prectN->x < prectP->x)))
                    return -1;
        }
        return CT_YXSORTED;
    case YXBanded:
        if (nrects > 1) {
            for (i = 1, prectP = prects, prectN = prects + 1;
                 i < nrects; i++, prectP++, prectN++)
                if ((prectN->y != prectP->y &&
                     prectN->y < prectP->y + (int) prectP->height) ||
                    ((prectN->y == prectP->y) &&
                     (prectN->height != prectP->height ||
                      prectN->x < prectP->x + (int) prectP->width)))
                    return -1;
        }
        return CT_YXBANDED;
    }
    return -1;
}

int
SetClipRects(GCPtr pGC, int xOrigin, int yOrigin, int nrects,
             xRectangle *prects, int ordering)
{
    int newct, size;
    xRectangle *prectsNew;

    newct = VerifyRectOrder(nrects, prects, ordering);
    if (newct < 0)
        return BadMatch;
    size = nrects * sizeof(xRectangle);
    prectsNew = malloc(size);
    if (!prectsNew && size)
        return BadAlloc;

    pGC->serialNumber |= GC_CHANGE_SERIAL_BIT;
    pGC->clipOrg.x = xOrigin;
    pGC->stateChanges |= GCClipXOrigin;

    pGC->clipOrg.y = yOrigin;
    pGC->stateChanges |= GCClipYOrigin;

    if (size)
        memmove((char *) prectsNew, (char *) prects, size);
    (*pGC->funcs->ChangeClip) (pGC, newct, (void *) prectsNew, nrects);
    if (pGC->funcs->ChangeGC)
        (*pGC->funcs->ChangeGC) (pGC,
                                 GCClipXOrigin | GCClipYOrigin | GCClipMask);
    return Success;
}

/*
   sets reasonable defaults
   if we can get a pre-allocated one, use it and mark it as used.
   if we can't, create one out of whole cloth (The Velveteen GC -- if
   you use it often enough it will become real.)
*/
GCPtr
GetScratchGC(unsigned depth, ScreenPtr pScreen)
{
    int i;
    GCPtr pGC;

    for (i = 0; i <= pScreen->numDepths; i++) {
        pGC = pScreen->GCperDepth[i];
        if (pGC && pGC->depth == depth && !pGC->scratch_inuse) {
            pGC->scratch_inuse = TRUE;

            pGC->alu = GXcopy;
            pGC->planemask = ~0;
            pGC->serialNumber = 0;
            pGC->fgPixel = 0;
            pGC->bgPixel = 1;
            pGC->lineWidth = 0;
            pGC->lineStyle = LineSolid;
            pGC->capStyle = CapButt;
            pGC->joinStyle = JoinMiter;
            pGC->fillStyle = FillSolid;
            pGC->fillRule = EvenOddRule;
            pGC->arcMode = ArcChord;
            pGC->patOrg.x = 0;
            pGC->patOrg.y = 0;
            pGC->subWindowMode = ClipByChildren;
            pGC->graphicsExposures = FALSE;
            pGC->clipOrg.x = 0;
            pGC->clipOrg.y = 0;
            if (pGC->clientClip)
                (*pGC->funcs->ChangeClip) (pGC, CT_NONE, NULL, 0);
            pGC->stateChanges = GCAllBits;
            return pGC;
        }
    }
    /* if we make it this far, need to roll our own */
    pGC = CreateScratchGC(pScreen, depth);
    if (pGC)
        pGC->graphicsExposures = FALSE;
    return pGC;
}

/*
   if the gc to free is in the table of pre-existing ones,
mark it as available.
   if not, free it for real
*/
void
FreeScratchGC(GCPtr pGC)
{
    if (pGC->scratch_inuse)
        pGC->scratch_inuse = FALSE;
    else
        FreeGC(pGC, (GContext) 0);
}
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
d90 1
a90 1
 * 
d92 1
a92 1
 * 
d97 1
a97 1
 * 
d100 1
a100 1
 * 
d105 1
a105 1
 * 
a497 1
    pGC->clientClipType = CT_NONE;
d793 1
a793 1
stipples anyway (in case the CreateGC() call has provided a 
d1035 1
a1035 1
   sets reasonable defaults 
d1069 1
a1069 1
            if (pGC->clientClipType != CT_NONE)
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d264 3
a266 2
            if ((pPixmap->drawable.depth != 1) ||
                (pPixmap->drawable.pScreen != pGC->pScreen)) {
d270 2
a271 1
                pPixmap->refcnt++;
d344 1
a344 1
                                       (pointer) pPixmap, 0);
d499 1
a499 1
    pGC->clientClip = (pointer) NULL;
d769 1
a769 1
FreeGC(pointer value, XID gid)
d1028 1
a1028 1
    (*pGC->funcs->ChangeClip) (pGC, newct, (pointer) prectsNew, nrects);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d422 5
a426 5
    {
    GCTile, RT_PIXMAP, DixReadAccess}, {
    GCStipple, RT_PIXMAP, DixReadAccess}, {
    GCFont, RT_FONT, DixUseAccess}, {
GCClipMask, RT_PIXMAP, DixReadAccess},};
d461 2
a462 12
/* CreateGC(pDrawable, mask, pval, pStatus)
   creates a default GC for the given drawable, using mask to fill
   in any non-default values.
   Returns a pointer to the new GC on success, NULL otherwise.
   returns status of non-default fields in pStatus
BUG:
   should check for failure to create default tile

*/
GCPtr
CreateGC(DrawablePtr pDrawable, BITS32 mask, XID *pval, int *pStatus,
         XID gcid, ClientPtr client)
d466 1
a466 1
    pGC = dixAllocateObjectWithPrivates(GC, PRIVATE_GC);
a467 1
        *pStatus = BadAlloc;
d471 2
a472 2
    pGC->pScreen = pDrawable->pScreen;
    pGC->depth = pDrawable->depth;
d475 1
a475 1
    pGC->serialNumber = GC_CHANGE_SERIAL_BIT;
a487 10
    if (mask & GCForeground) {
        /*
         * magic special case -- ChangeGC checks for this condition
         * and snags the Foreground value to create a pseudo default-tile
         */
        pGC->tileIsPixel = FALSE;
    }
    else {
        pGC->tileIsPixel = TRUE;
    }
d489 1
d504 2
a505 1
    defaultFont->refcnt++;
d507 2
a508 1
    pGC->stipple->refcnt++;
d512 35
d804 1
a804 1
    pGC = dixAllocateObjectWithPrivates(GC, PRIVATE_GC);
a806 35

    pGC->pScreen = pScreen;
    pGC->depth = depth;
    pGC->alu = GXcopy;          /* dst <- src */
    pGC->planemask = ~0;
    pGC->serialNumber = 0;
    pGC->fgPixel = 0;
    pGC->bgPixel = 1;
    pGC->lineWidth = 0;
    pGC->lineStyle = LineSolid;
    pGC->capStyle = CapButt;
    pGC->joinStyle = JoinMiter;
    pGC->fillStyle = FillSolid;
    pGC->fillRule = EvenOddRule;
    pGC->arcMode = ArcPieSlice;
    pGC->font = defaultFont;
    if (pGC->font)              /* necessary, because open of default font could fail */
        pGC->font->refcnt++;
    pGC->tileIsPixel = TRUE;
    pGC->tile.pixel = 0;
    pGC->tile.pixmap = NullPixmap;
    pGC->stipple = NullPixmap;
    pGC->patOrg.x = 0;
    pGC->patOrg.y = 0;
    pGC->subWindowMode = ClipByChildren;
    pGC->graphicsExposures = TRUE;
    pGC->clipOrg.x = 0;
    pGC->clipOrg.y = 0;
    pGC->clientClipType = CT_NONE;
    pGC->dashOffset = 0;
    pGC->numInDashList = 2;
    pGC->dash = DefaultDash;

    /* scratch GCs in the GCperDepth pool start off unused */
    pGC->scratch_inuse = FALSE;
@


1.6
log
@Update to xserver 1.11.2
@
text
@a24 1

a46 1

d72 1
a72 1
static unsigned char DefaultDash[2] = {4, 4};
d75 1
a75 1
ValidateGC(DrawablePtr pDraw, GC *pGC)
a81 1

d123 1
a123 1
ChangeGC(ClientPtr client, GC *pGC, BITS32 mask, ChangeGCValPtr pUnion)
d125 4
a128 4
    BITS32 	index2;
    int 	error = 0;
    PixmapPtr 	pPixmap;
    BITS32	maskQ;
d133 276
a408 278
    maskQ = mask;	/* save these for when we walk the GCque */
    while (mask && !error) 
    {
	index2 = (BITS32) lowbit (mask);
	mask &= ~index2;
	pGC->stateChanges |= index2;
	switch (index2)
	{
	    case GCFunction:
	    {
		CARD8 newalu;
		NEXTVAL(CARD8, newalu);
		if (newalu <= GXset)
		    pGC->alu = newalu;
		else
		{
		    if (client)
			client->errorValue = newalu;
		    error = BadValue;
		}
		break;
	    }
	    case GCPlaneMask:
		NEXTVAL(unsigned long, pGC->planemask);
		break;
	    case GCForeground:
		NEXTVAL(unsigned long, pGC->fgPixel);
		/*
		 * this is for CreateGC
		 */
		if (!pGC->tileIsPixel && !pGC->tile.pixmap)
		{
		    pGC->tileIsPixel = TRUE;
		    pGC->tile.pixel = pGC->fgPixel;
		}
		break;
	    case GCBackground:
		NEXTVAL(unsigned long, pGC->bgPixel);
		break;
	    case GCLineWidth:		/* ??? line width is a CARD16 */
		 NEXTVAL(CARD16, pGC->lineWidth);
		break;
	    case GCLineStyle:
	    {
		unsigned int newlinestyle;
		NEXTVAL(unsigned int, newlinestyle);
		if (newlinestyle <= LineDoubleDash)
		    pGC->lineStyle = newlinestyle;
		else
		{
		    if (client)
			client->errorValue = newlinestyle;
		    error = BadValue;
		}
		break;
	    }
	    case GCCapStyle:
	    {
		unsigned int newcapstyle;
		NEXTVAL(unsigned int, newcapstyle);
		if (newcapstyle <= CapProjecting)
		    pGC->capStyle = newcapstyle;
		else
		{
		    if (client)
			client->errorValue = newcapstyle;
		    error = BadValue;
		}
		break;
	    }
	    case GCJoinStyle:
	    {
		unsigned int newjoinstyle;
		NEXTVAL(unsigned int, newjoinstyle);
		if (newjoinstyle <= JoinBevel)
		    pGC->joinStyle = newjoinstyle;
		else
		{
		    if (client)
			client->errorValue = newjoinstyle;
		    error = BadValue;
		}
		break;
	    }
	    case GCFillStyle:
	    {
		unsigned int newfillstyle;
		NEXTVAL(unsigned int, newfillstyle);
		if (newfillstyle <= FillOpaqueStippled)
		    pGC->fillStyle = newfillstyle;
		else
		{
		    if (client)
			client->errorValue = newfillstyle;
		    error = BadValue;
		}
		break;
	    }
	    case GCFillRule:
	    {
		unsigned int newfillrule;
		NEXTVAL(unsigned int, newfillrule);
		if (newfillrule <= WindingRule)
		    pGC->fillRule = newfillrule;
		else
		{
		    if (client)
			client->errorValue = newfillrule;
		    error = BadValue;
		}
		break;
	    }
	    case GCTile:
		NEXT_PTR(PixmapPtr, pPixmap);
		if ((pPixmap->drawable.depth != pGC->depth) ||
		    (pPixmap->drawable.pScreen != pGC->pScreen))
		{
		    error = BadMatch;
		}
		else
		{
		    pPixmap->refcnt++;
		    if (!pGC->tileIsPixel)
			(* pGC->pScreen->DestroyPixmap)(pGC->tile.pixmap);
		    pGC->tileIsPixel = FALSE;
		    pGC->tile.pixmap = pPixmap;
		}
		break;
	    case GCStipple:
		NEXT_PTR(PixmapPtr, pPixmap);
		if ((pPixmap->drawable.depth != 1) ||
		    (pPixmap->drawable.pScreen != pGC->pScreen))
		{
		    error = BadMatch;
		}
		else
		{
		    pPixmap->refcnt++;
		    if (pGC->stipple)
			(* pGC->pScreen->DestroyPixmap)(pGC->stipple);
		    pGC->stipple = pPixmap;
		}
		break;
	    case GCTileStipXOrigin:
		NEXTVAL(INT16, pGC->patOrg.x);
		break;
	    case GCTileStipYOrigin:
		NEXTVAL(INT16, pGC->patOrg.y);
		break;
	    case GCFont:
    	    {
		FontPtr	pFont;
		NEXT_PTR(FontPtr, pFont);
		pFont->refcnt++;
		if (pGC->font)
		    CloseFont(pGC->font, (Font)0);
		pGC->font = pFont;
		break;
	    }
	    case GCSubwindowMode:
	    {
		unsigned int newclipmode;
		NEXTVAL(unsigned int, newclipmode);
		if (newclipmode <= IncludeInferiors)
		    pGC->subWindowMode = newclipmode;
		else
		{
		    if (client)
			client->errorValue = newclipmode;
		    error = BadValue;
		}
		break;
	    }
	    case GCGraphicsExposures:
    	    {
		unsigned int newge;
		NEXTVAL(unsigned int, newge);
		if (newge <= xTrue)
		    pGC->graphicsExposures = newge;
		else
		{
		    if (client)
			client->errorValue = newge;
		    error = BadValue;
		}
		break;
	    }
	    case GCClipXOrigin:
		NEXTVAL(INT16, pGC->clipOrg.x);
		break;
	    case GCClipYOrigin:
		NEXTVAL(INT16, pGC->clipOrg.y);
		break;
	    case GCClipMask:
		NEXT_PTR(PixmapPtr, pPixmap);
		if (pPixmap)
		{
		    if ((pPixmap->drawable.depth != 1) ||
			(pPixmap->drawable.pScreen != pGC->pScreen))
		    {
			error = BadMatch;
			break;
		    }
		    pPixmap->refcnt++;
		}
		(*pGC->funcs->ChangeClip)(pGC, pPixmap ? CT_PIXMAP : CT_NONE,
					  (pointer)pPixmap, 0);
		break;
	    case GCDashOffset:
		NEXTVAL(INT16, pGC->dashOffset);
		break;
	    case GCDashList:
	    {
		CARD8 newdash;
		NEXTVAL(CARD8, newdash);
		if (newdash == 4)
		{
		    if (pGC->dash != DefaultDash)
		    {
			free(pGC->dash);
			pGC->numInDashList = 2;
			pGC->dash = DefaultDash;
		    }
		}
		else if (newdash != 0)
 		{
		    unsigned char *dash;

		    dash = malloc(2 * sizeof(unsigned char));
		    if (dash)
		    {
			if (pGC->dash != DefaultDash)
			    free(pGC->dash);
			pGC->numInDashList = 2;
			pGC->dash = dash;
			dash[0] = newdash;
			dash[1] = newdash;
		    }
		    else
			error = BadAlloc;
		}
 		else
		{
		   if (client)
			client->errorValue = newdash;
		   error = BadValue;
		}
		break;
	    }
	    case GCArcMode:
	    {
		unsigned int newarcmode;
		NEXTVAL(unsigned int, newarcmode);
		if (newarcmode <= ArcPieSlice)
		    pGC->arcMode = newarcmode;
		else
		{
		    if (client)
			client->errorValue = newarcmode;
		    error = BadValue;
		}
		break;
	    }
	    default:
		if (client)
		    client->errorValue = maskQ;
		error = BadValue;
		break;
	}
    } /* end while mask && !error */

    if (pGC->fillStyle == FillTiled && pGC->tileIsPixel)
    {
	if (!CreateDefaultTile (pGC))
	{
	    pGC->fillStyle = FillSolid;
	    error = BadAlloc;
	}
d410 1
a410 1
    (*pGC->funcs->ChangeGC)(pGC, maskQ);
d422 5
a426 5
    { GCTile, RT_PIXMAP, DixReadAccess },
    { GCStipple, RT_PIXMAP, DixReadAccess },
    { GCFont, RT_FONT, DixUseAccess },
    { GCClipMask, RT_PIXMAP, DixReadAccess },
};
d429 1
a429 1
ChangeGCXIDs(ClientPtr client, GC *pGC, BITS32 mask, CARD32 *pC32)
d433 4
a436 4
    if (mask & ~GCAllBits)
    {
	client->errorValue = mask;
	return BadValue;
d438 19
a456 20
    for (i = Ones(mask); i--; )
	vals[i].val = pC32[i];
    for (i = 0; i < sizeof(xidfields) / sizeof(*xidfields); ++i)
    {
	int offset, rc;
	if (!(mask & xidfields[i].mask))
	    continue;
	offset = Ones(mask & (xidfields[i].mask - 1));
	if (xidfields[i].mask == GCClipMask && vals[offset].val == None)
	{
	    vals[offset].ptr = NullPixmap;
	    continue;
	}
	rc = dixLookupResourceByType(&vals[offset].ptr, vals[offset].val,
		xidfields[i].type, client, xidfields[i].access_mode);
	if (rc != Success)
	{
	    client->errorValue = vals[offset].val;
	    return rc;
	}
d472 1
a472 1
	 XID gcid, ClientPtr client)
d477 3
a479 4
    if (!pGC)
    {
	*pStatus = BadAlloc;
	return (GCPtr)NULL;
d484 1
a484 1
    pGC->alu = GXcopy; /* dst <- src */
d499 6
a504 7
    if (mask & GCForeground)
    {
	/*
	 * magic special case -- ChangeGC checks for this condition
	 * and snags the Foreground value to create a pseudo default-tile
	 */
	pGC->tileIsPixel = FALSE;
d506 2
a507 3
    else
    {
	pGC->tileIsPixel = TRUE;
d517 1
a517 1
    pGC->clientClip = (pointer)NULL;
d533 1
a533 1
			RT_NONE, NULL, DixCreateAccess|DixSetAttrAccess);
d535 1
a535 1
	goto out;
d538 2
a539 2
    if (!(*pGC->pScreen->CreateGC)(pGC))
	*pStatus = BadAlloc;
d543 1
a543 1
	*pStatus = Success;
d545 6
a550 7
out:
    if (*pStatus != Success)
    {
	if (!pGC->tileIsPixel && !pGC->tile.pixmap)
	    pGC->tileIsPixel = TRUE; /* undo special case */
	FreeGC(pGC, (XID)0);
	pGC = (GCPtr)NULL;
d557 1
a557 1
CreateDefaultTile (GCPtr pGC)
d559 5
a563 5
    ChangeGCVal	tmpval[3];
    PixmapPtr 	pTile;
    GCPtr	pgcScratch;
    xRectangle	rect;
    CARD16	w, h;
d567 1
a567 1
    (*pGC->pScreen->QueryBestSize)(TileShape, &w, &h, pGC->pScreen);
d569 1
a569 2
	    (*pGC->pScreen->CreatePixmap)(pGC->pScreen,
					  w, h, pGC->depth, 0);
d571 6
a576 7
    if (!pTile || !pgcScratch)
    {
	if (pTile)
	    (*pTile->drawable.pScreen->DestroyPixmap)(pTile);
	if (pgcScratch)
	    FreeScratchGC(pgcScratch);
	return FALSE;
d581 3
a583 2
    (void)ChangeGC(NullClient, pgcScratch, GCFunction | GCForeground | GCFillStyle, tmpval);
    ValidateGC((DrawablePtr)pTile, pgcScratch);
d588 2
a589 1
    (*pgcScratch->ops->PolyFillRect)((DrawablePtr)pTile, pgcScratch, 1, &rect);
d599 1
a599 1
CopyGC(GC *pgcSrc, GC *pgcDst, BITS32 mask)
d601 3
a603 3
    BITS32	index2;
    BITS32	maskQ;
    int 	error = 0;
d606 1
a606 1
	return Success;
d610 123
a732 131
    while (mask)
    {
	index2 = (BITS32) lowbit (mask);
	mask &= ~index2;
	switch (index2)
	{
	    case GCFunction:
		pgcDst->alu = pgcSrc->alu;
		break;
	    case GCPlaneMask:
		pgcDst->planemask = pgcSrc->planemask;
		break;
	    case GCForeground:
		pgcDst->fgPixel = pgcSrc->fgPixel;
		break;
	    case GCBackground:
		pgcDst->bgPixel = pgcSrc->bgPixel;
		break;
	    case GCLineWidth:
		pgcDst->lineWidth = pgcSrc->lineWidth;
		break;
	    case GCLineStyle:
		pgcDst->lineStyle = pgcSrc->lineStyle;
		break;
	    case GCCapStyle:
		pgcDst->capStyle = pgcSrc->capStyle;
		break;
	    case GCJoinStyle:
		pgcDst->joinStyle = pgcSrc->joinStyle;
		break;
	    case GCFillStyle:
		pgcDst->fillStyle = pgcSrc->fillStyle;
		break;
	    case GCFillRule:
		pgcDst->fillRule = pgcSrc->fillRule;
		break;
	    case GCTile:
		{
		    if (EqualPixUnion(pgcDst->tileIsPixel,
				      pgcDst->tile,
				      pgcSrc->tileIsPixel,
				      pgcSrc->tile))
		    {
			break;
		    }
		    if (!pgcDst->tileIsPixel)
			(* pgcDst->pScreen->DestroyPixmap)(pgcDst->tile.pixmap);
		    pgcDst->tileIsPixel = pgcSrc->tileIsPixel;
		    pgcDst->tile = pgcSrc->tile;
		    if (!pgcDst->tileIsPixel)
		       pgcDst->tile.pixmap->refcnt++;
		    break;
		}
	    case GCStipple:
		{
		    if (pgcDst->stipple == pgcSrc->stipple)
			break;
		    if (pgcDst->stipple)
			(* pgcDst->pScreen->DestroyPixmap)(pgcDst->stipple);
		    pgcDst->stipple = pgcSrc->stipple;
		    if (pgcDst->stipple)
			pgcDst->stipple->refcnt ++;
		    break;
		}
	    case GCTileStipXOrigin:
		pgcDst->patOrg.x = pgcSrc->patOrg.x;
		break;
	    case GCTileStipYOrigin:
		pgcDst->patOrg.y = pgcSrc->patOrg.y;
		break;
	    case GCFont:
		if (pgcDst->font == pgcSrc->font)
		    break;
		if (pgcDst->font)
		    CloseFont(pgcDst->font, (Font)0);
		if ((pgcDst->font = pgcSrc->font) != NullFont)
		    (pgcDst->font)->refcnt++;
		break;
	    case GCSubwindowMode:
		pgcDst->subWindowMode = pgcSrc->subWindowMode;
		break;
	    case GCGraphicsExposures:
		pgcDst->graphicsExposures = pgcSrc->graphicsExposures;
		break;
	    case GCClipXOrigin:
		pgcDst->clipOrg.x = pgcSrc->clipOrg.x;
		break;
	    case GCClipYOrigin:
		pgcDst->clipOrg.y = pgcSrc->clipOrg.y;
		break;
	    case GCClipMask:
		(* pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
		break;
	    case GCDashOffset:
		pgcDst->dashOffset = pgcSrc->dashOffset;
		break;
	    case GCDashList:
		if (pgcSrc->dash == DefaultDash)
		{
		    if (pgcDst->dash != DefaultDash)
		    {
			free(pgcDst->dash);
			pgcDst->numInDashList = pgcSrc->numInDashList;
			pgcDst->dash = pgcSrc->dash;
		    }
		}
		else
		{
		    unsigned char *dash;
		    unsigned int i;

		    dash = malloc(pgcSrc->numInDashList * sizeof(unsigned char));
		    if (dash)
		    {
			if (pgcDst->dash != DefaultDash)
			    free(pgcDst->dash);
			pgcDst->numInDashList = pgcSrc->numInDashList;
			pgcDst->dash = dash;
			for (i=0; i<pgcSrc->numInDashList; i++)
			    dash[i] = pgcSrc->dash[i];
		    }
		    else
			error = BadAlloc;
		}
		break;
	    case GCArcMode:
		pgcDst->arcMode = pgcSrc->arcMode;
		break;
	    default:
		FatalError ("CopyGC: Unhandled mask!\n");
	}
d734 5
a738 7
    if (pgcDst->fillStyle == FillTiled && pgcDst->tileIsPixel)
    {
	if (!CreateDefaultTile (pgcDst))
	{
	    pgcDst->fillStyle = FillSolid;
	    error = BadAlloc;
	}
d752 1
a752 1
    GCPtr pGC = (GCPtr)value;
d754 2
a755 2
    CloseFont(pGC->font, (Font)0);
    (* pGC->funcs->DestroyClip)(pGC);
d758 1
a758 1
	(* pGC->pScreen->DestroyPixmap)(pGC->tile.pixmap);
d760 1
a760 1
	(* pGC->pScreen->DestroyPixmap)(pGC->stipple);
d764 1
a764 1
	free(pGC->dash);
d789 1
a789 1
	return (GCPtr)NULL;
d793 1
a793 1
    pGC->alu = GXcopy; /* dst <- src */
d806 2
a807 2
    if ( pGC->font)  /* necessary, because open of default font could fail */
	pGC->font->refcnt++;
d827 3
a829 4
    if (!(*pScreen->CreateGC)(pGC))
    {
	FreeGC(pGC, (XID)0);
	pGC = (GCPtr)NULL;
d844 3
a846 4
    for (i = 0; i <= pScreen->numDepths; i++)
    {
	(void)FreeGC(ppGC[i], (XID)0);
	ppGC[i] = NULL;
a849 1

d862 1
a862 1
	return FALSE;
d865 2
a866 2
    if( pScreen->numDepths > MAXFORMATS )
	    return FALSE;
d869 7
a875 9
    for (i=0; i<pScreen->numDepths; i++, pDepth++)
    {
	if (!(ppGC[i+1] = CreateScratchGC(pScreen, pDepth->depth)))
	{
	    for (; i >= 0; i--)
		(void)FreeGC(ppGC[i], (XID)0);
	    return FALSE;
	}
	ppGC[i+1]->graphicsExposures = FALSE;
d893 1
a893 1
    (* pScreen->QueryBestSize)(StippleShape, &w, &h, pScreen);
d895 2
a896 2
			(*pScreen->CreatePixmap)(pScreen, w, h, 1, 0)))
	return FALSE;
d902 3
a904 4
    if (!pgcScratch)
    {
	(*pScreen->DestroyPixmap)(pScreen->PixmapPerDepth[0]);
	return FALSE;
d906 3
a908 2
    (void)ChangeGC(NullClient, pgcScratch, GCFunction|GCForeground|GCFillStyle, tmpval);
    ValidateGC((DrawablePtr)pScreen->PixmapPerDepth[0], pgcScratch);
d913 2
a914 2
    (*pgcScratch->ops->PolyFillRect)((DrawablePtr)pScreen->PixmapPerDepth[0], 
				     pgcScratch, 1, &rect);
d923 2
a924 1
    (*pScreen->DestroyPixmap)(pScreen->PixmapPerDepth[0]);
d936 5
a940 7
    while (i--)
    {
	if (!*p++)
	{
	    /* dash segment must be > 0 */
	    return BadValue;
	}
d944 1
a944 1
	p = malloc(2 * ndash * sizeof(unsigned char));
d946 1
a946 1
	p = malloc(ndash * sizeof(unsigned char));
d948 1
a948 1
	return BadAlloc;
d951 4
a954 5
    if (offset != pGC->dashOffset)
    {
	pGC->dashOffset = offset;
	pGC->stateChanges |= GCDashOffset;
	maskQ |= GCDashOffset;
d958 1
a958 1
	free(pGC->dash);
d961 6
a966 7
    if (ndash & 1)
    {
	pGC->numInDashList += ndash;
	indash = pdash;
	i = ndash;
	while (i--)
	    *p++ = *indash++;
d968 2
a969 2
    while(ndash--)
	*p++ = *pdash++;
d974 1
a974 1
	(*pGC->funcs->ChangeGC) (pGC, maskQ);
d981 2
a982 2
    xRectangle	*prectP, *prectN;
    int	i;
d984 32
a1015 40
    switch(ordering)
    {
      case Unsorted:
	  return CT_UNSORTED;
      case YSorted:
	  if(nrects > 1)
	  {
	      for(i = 1, prectP = prects, prectN = prects + 1;
		  i < nrects;
		  i++, prectP++, prectN++)
		  if(prectN->y < prectP->y)
		      return -1;
	  }
	  return CT_YSORTED;
      case YXSorted:
	  if(nrects > 1)
	  {
	      for(i = 1, prectP = prects, prectN = prects + 1;
		  i < nrects;
		  i++, prectP++, prectN++)
		  if((prectN->y < prectP->y) ||
		      ( (prectN->y == prectP->y) &&
		        (prectN->x < prectP->x) ) )
		      return -1;
	  }
	  return CT_YXSORTED;
      case YXBanded:
	  if(nrects > 1)
	  {
	      for(i = 1, prectP = prects, prectN = prects + 1;
		  i < nrects;
		  i++, prectP++, prectN++)
		  if((prectN->y != prectP->y &&
 		      prectN->y < prectP->y + (int) prectP->height) ||
		     ((prectN->y == prectP->y) &&
		      (prectN->height != prectP->height ||
		       prectN->x < prectP->x + (int) prectP->width)))
		      return -1;
	  }
	  return CT_YXBANDED;
d1021 1
a1021 1
SetClipRects(GCPtr pGC, int xOrigin, int yOrigin, int nrects, 
d1024 2
a1025 2
    int			newct, size;
    xRectangle 		*prectsNew;
d1029 1
a1029 1
	return BadMatch;
d1033 1
a1033 1
	return BadAlloc;
d1038 1
a1038 1
		 
d1043 2
a1044 2
	memmove((char *)prectsNew, (char *)prects, size);
    (*pGC->funcs->ChangeClip)(pGC, newct, (pointer)prectsNew, nrects);
d1046 2
a1047 1
	(*pGC->funcs->ChangeGC) (pGC, GCClipXOrigin|GCClipYOrigin|GCClipMask);
a1050 1

d1063 28
a1090 30
    for (i=0; i<=pScreen->numDepths; i++)
    {
	pGC = pScreen->GCperDepth[i];
	if (pGC && pGC->depth == depth && !pGC->scratch_inuse)
	{
	    pGC->scratch_inuse = TRUE;

	    pGC->alu = GXcopy;
	    pGC->planemask = ~0;
	    pGC->serialNumber = 0;
	    pGC->fgPixel = 0;
	    pGC->bgPixel = 1;
	    pGC->lineWidth = 0;
	    pGC->lineStyle = LineSolid;
	    pGC->capStyle = CapButt;
	    pGC->joinStyle = JoinMiter;
	    pGC->fillStyle = FillSolid;
	    pGC->fillRule = EvenOddRule;
	    pGC->arcMode = ArcChord;
	    pGC->patOrg.x = 0;
	    pGC->patOrg.y = 0;
	    pGC->subWindowMode = ClipByChildren;
	    pGC->graphicsExposures = FALSE;
	    pGC->clipOrg.x = 0;
	    pGC->clipOrg.y = 0;
	    if (pGC->clientClipType != CT_NONE)
		(*pGC->funcs->ChangeClip) (pGC, CT_NONE, NULL, 0);
	    pGC->stateChanges = GCAllBits;
	    return pGC;
	}
d1095 1
a1095 1
	pGC->graphicsExposures = FALSE;
d1108 1
a1108 1
	pGC->scratch_inuse = FALSE;
d1110 1
a1110 1
	FreeGC(pGC, (GContext)0);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a529 2
    pGC->lastWinOrg.x = 0;
    pGC->lastWinOrg.y = 0;
d802 1
a802 1
GCPtr
a841 2
    pGC->lastWinOrg.x = 0;
    pGC->lastWinOrg.y = 0;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d63 1
a69 1
extern XID clientErrorValue;
d85 7
a91 7
/* dixChangeGC(client, pGC, mask, pC32, pUnion)
 * 
 * This function was created as part of the Security extension
 * implementation.  The client performing the gc change must be passed so
 * that access checks can be performed on any tiles, stipples, or fonts
 * that are specified.  ddxen can call this too; they should normally
 * pass NullClient for the client since any access checking should have
d94 1
a94 5
 * Since we had to create a new function anyway, we decided to change the
 * way the list of gc values is passed to eliminate the compiler warnings
 * caused by the DoChangeGC interface.  You can pass the values via pC32
 * or pUnion, but not both; one of them must be NULL.  If you don't need
 * to pass any pointers, you can use either one:
a95 2
 *     example calling dixChangeGC using pC32 parameter
 *
d97 3
a99 3
 *     v[0] = foreground;
 *     v[1] = background;
 *     dixChangeGC(client, pGC, GCForeground|GCBackground, v, NULL);
d101 2
a102 10
 *     example calling dixChangeGC using pUnion parameter;
 *     same effect as above
 *
 *     ChangeGCVal v[2];
 *     v[0].val = foreground;
 *     v[1].val = background;
 *     dixChangeGC(client, pGC, GCForeground|GCBackground, NULL, v);
 * 
 * However, if you need to pass a pointer to a pixmap or font, you MUST
 * use the pUnion parameter.
a103 3
 *     example calling dixChangeGC passing pointers in the value list
 *     v[1].ptr is a pointer to a pixmap
 *
d107 1
a107 1
 *     dixChangeGC(client, pGC, GCFillStyle|GCTile, NULL, v);
d109 7
a115 10
 * Note: we could have gotten by with just the pUnion parameter, but on
 * 64 bit machines that would have forced us to copy the value list that
 * comes in the ChangeGC request.
 * 
 * Ideally, we'd change all the DoChangeGC calls to dixChangeGC, but this
 * is far too many changes to consider at this time, so we've only
 * changed the ones that caused compiler warnings.  New code should use
 * dixChangeGC.
 * 
 * dpw
a118 2
      if (pC32) _var = (_type)*pC32++; \
      else { \
a119 1
      } \
d123 1
a123 1
    assert(pUnion); _var = (_type)pUnion->ptr; pUnion++; }
d126 1
a126 1
dixChangeGC(ClientPtr client, GC *pGC, BITS32 mask, CARD32 *pC32, ChangeGCValPtr pUnion)
d129 1
a129 1
    int 	rc, error = 0;
d133 1
a133 1
    assert( (pC32 && !pUnion) || (!pC32 && pUnion) );
d152 2
a153 1
		    clientErrorValue = newalu;
d186 2
a187 1
		    clientErrorValue = newlinestyle;
d200 2
a201 1
		    clientErrorValue = newcapstyle;
d214 2
a215 1
		    clientErrorValue = newjoinstyle;
d228 2
a229 1
		    clientErrorValue = newfillstyle;
d242 2
a243 1
		    clientErrorValue = newfillrule;
d249 3
a251 3
	    {
		XID newpix = 0;
		if (pUnion)
d253 1
a253 24
		    NEXT_PTR(PixmapPtr, pPixmap);
		    rc = Success;
		}
		else
		{
		    NEXTVAL(XID, newpix);
		    rc = dixLookupResourceByType((pointer *)&pPixmap, newpix,
					   RT_PIXMAP, client, DixReadAccess);
		}
		if (rc == Success)
		{
		    if ((pPixmap->drawable.depth != pGC->depth) ||
			(pPixmap->drawable.pScreen != pGC->pScreen))
		    {
			error = BadMatch;
		    }
		    else
		    {
			pPixmap->refcnt++;
			if (!pGC->tileIsPixel)
			    (* pGC->pScreen->DestroyPixmap)(pGC->tile.pixmap);
			pGC->tileIsPixel = FALSE;
			pGC->tile.pixmap = pPixmap;
		    }
d257 5
a261 2
		    clientErrorValue = newpix;
		    error = (rc == BadValue) ? BadPixmap : rc;
a263 1
	    }
d265 3
a267 3
	    {
		XID newstipple = 0;
		if (pUnion)
d269 1
a269 23
		    NEXT_PTR(PixmapPtr, pPixmap);
		    rc = Success;
		}
		else
		{
		    NEXTVAL(XID, newstipple)
		    rc = dixLookupResourceByType((pointer *)&pPixmap, newstipple,
					   RT_PIXMAP, client, DixReadAccess);
		}
		if (rc == Success)
		{
		    if ((pPixmap->drawable.depth != 1) ||
			(pPixmap->drawable.pScreen != pGC->pScreen))
		    {
			error = BadMatch;
		    }
		    else
		    {
			pPixmap->refcnt++;
			if (pGC->stipple)
			    (* pGC->pScreen->DestroyPixmap)(pGC->stipple);
			pGC->stipple = pPixmap;
		    }
d273 4
a276 2
		    clientErrorValue = newstipple;
		    error = (rc == BadValue) ? BadPixmap : rc;
a278 1
	    }
d288 5
a292 24
		XID newfont = 0;
		if (pUnion)
		{
		    NEXT_PTR(FontPtr, pFont);
		    rc = Success;
		}
		else
		{
		    NEXTVAL(XID, newfont)
		    rc = dixLookupResourceByType((pointer *)&pFont, newfont,
					   RT_FONT, client, DixUseAccess);
		}
		if (rc == Success)
		{
		    pFont->refcnt++;
		    if (pGC->font)
    		        CloseFont(pGC->font, (Font)0);
		    pGC->font = pFont;
		 }
		else
		{
		    clientErrorValue = newfont;
		    error = (rc == BadValue) ? BadFont : rc;
		}
d303 2
a304 1
		    clientErrorValue = newclipmode;
d317 2
a318 1
		    clientErrorValue = newge;
d330 1
a330 27
	    {
		Pixmap pid = 0;
		int    clipType = 0;

		if (pUnion)
		{
		    NEXT_PTR(PixmapPtr, pPixmap);
		}
		else
		{
		    NEXTVAL(Pixmap, pid)
		    if (pid == None)
		    {
			clipType = CT_NONE;
			pPixmap = NullPixmap;
		    }
		    else {
			rc = dixLookupResourceByType((pointer *)&pPixmap, pid,
					       RT_PIXMAP, client,
					       DixReadAccess);
			if (rc != Success) {
			    clientErrorValue = pid;
			    error = (rc == BadValue) ? BadPixmap : rc;
			}
		    }
		}

d337 1
d339 1
a339 10
		    else
		    {
			clipType = CT_PIXMAP;
			pPixmap->refcnt++;
		    }
		}
		if(error == Success)
		{
		    (*pGC->funcs->ChangeClip)(pGC, clipType,
					      (pointer)pPixmap, 0);
d341 2
a343 1
	    }
d355 1
a355 1
			xfree(pGC->dash);
d364 1
a364 1
		    dash = xalloc(2 * sizeof(unsigned char));
d368 1
a368 1
			    xfree(pGC->dash);
d379 2
a380 1
		   clientErrorValue = newdash;
d393 2
a394 1
		    clientErrorValue = newarcmode;
d400 2
a401 1
		clientErrorValue = maskQ;
d422 10
a431 7
/* Publically defined entry to ChangeGC.  Just calls dixChangeGC and tells
 * it that all of the entries are constants or IDs */
int
ChangeGC(GC *pGC, BITS32 mask, XID *pval)
{
    return (dixChangeGC(NullClient, pGC, mask, pval, NULL));
}
a432 20
/* DoChangeGC(pGC, mask, pval, fPointer)
   mask is a set of bits indicating which values to change.
   pval contains an appropriate value for each mask.
   fPointer is true if the values for tiles, stipples, fonts or clipmasks
   are pointers instead of IDs.  Note: if you are passing pointers you
   MUST declare the array of values as type pointer!  Other data types
   may not be large enough to hold pointers on some machines.  Yes,
   this means you have to cast to (XID *) when you pass the array to
   DoChangeGC.  Similarly, if you are not passing pointers (fPointer = 0) you
   MUST declare the array as type XID (not unsigned long!), or again the wrong
   size data type may be used.  To avoid this cruftiness, use dixChangeGC
   above.

   if there is an error, the value is marked as changed 
   anyway, which is probably wrong, but infrequent.

NOTE:
	all values sent over the protocol for ChangeGC requests are
32 bits long
*/
d434 1
a434 1
DoChangeGC(GC *pGC, BITS32 mask, XID *pval, int fPointer)
d436 29
a464 5
    if (fPointer)
    /* XXX might be a problem on 64 bit big-endian servers */
	return dixChangeGC(NullClient, pGC, mask, NULL, (ChangeGCValPtr)pval);
    else
	return dixChangeGC(NullClient, pGC, mask, pval, NULL);
a466 1

d482 1
a482 1
    pGC = xalloc(sizeof(GC));
a494 1
    pGC->devPrivates = NULL;
d539 3
d548 1
a548 1
    pGC->stateChanges = (1 << (GCLastBit+1)) - 1;
d552 1
a552 1
        *pStatus = ChangeGC(pGC, mask, pval);
d565 1
a565 1
    return (pGC);
d571 1
a571 1
    XID		tmpval[3];
d592 4
a595 5
    tmpval[0] = GXcopy;
    tmpval[1] = pGC->tile.pixel;
    tmpval[2] = FillSolid;
    (void)ChangeGC(pgcScratch, GCFunction | GCForeground | GCFillStyle, 
		   tmpval);
d723 1
a723 1
			xfree(pgcDst->dash);
d733 1
a733 1
		    dash = xalloc(pgcSrc->numInDashList * sizeof(unsigned char));
d737 1
a737 1
			    xfree(pgcDst->dash);
d751 1
a751 3
		clientErrorValue = maskQ;
		error = BadValue;
		break;
d786 3
a788 4
	xfree(pGC->dash);
    dixFreePrivates(pGC->devPrivates);
    xfree(pGC);
    return(Success);
d809 1
a809 1
    pGC = xalloc(sizeof(GC));
a817 1
    pGC->devPrivates = NULL;
d847 4
a850 1
    pGC->stateChanges = (1 << (GCLastBit+1)) - 1;
d870 1
d872 2
a873 1
    pScreen->rgf = ~0L;
a885 1
    pScreen->rgf = 0;
d913 1
a913 1
    XID tmpval[3];
d927 3
a929 1
    tmpval[0] = GXcopy; tmpval[1] = 1; tmpval[2] = FillSolid;
d936 1
a936 1
    (void)ChangeGC(pgcScratch, GCFunction|GCForeground|GCFillStyle, tmpval);
a968 1
	    clientErrorValue = 0;
d974 1
a974 1
	p = xalloc(2 * ndash * sizeof(unsigned char));
d976 1
a976 1
	p = xalloc(ndash * sizeof(unsigned char));
d989 1
a989 1
	xfree(pGC->dash);
d1069 1
a1069 1
	return(BadMatch);
d1071 1
a1071 1
    prectsNew = xalloc(size);
d1104 3
a1106 3
        if ( pScreen->GCperDepth[i]->depth == depth &&
	     !(pScreen->rgf & (1L << (i+1)))
	   )
d1108 1
a1108 2
	    pScreen->rgf |= (1L << (i+1));
            pGC = (pScreen->GCperDepth[i]);
d1130 1
a1130 1
	    pGC->stateChanges = (1 << (GCLastBit+1)) - 1;
d1133 1
d1149 4
a1152 12
    ScreenPtr pScreen = pGC->pScreen;
    int i;

    for (i=0; i<=pScreen->numDepths; i++)
    {
        if ( pScreen->GCperDepth[i] == pGC)
	{
	    pScreen->rgf &= ~(1L << (i+1));
	    return;
	}
    }
    (void)FreeGC(pGC, (GContext)0);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d76 1
a76 1
_X_EXPORT void
d148 1
a148 1
_X_EXPORT int
d473 1
a473 1
		    dash = (unsigned char *)xalloc(2 * sizeof(unsigned char));
d530 1
a530 1
_X_EXPORT int
d556 1
a556 1
_X_EXPORT int
d576 1
a576 1
_X_EXPORT GCPtr
d582 1
a582 1
    pGC = (GCPtr)xalloc(sizeof(GC));
d605 2
a613 1
	pGC->tile.pixmap = NullPixmap;
a617 1
	pGC->tile.pixel = 0;
d709 1
a709 1
_X_EXPORT int
d832 1
a832 2
		    dash = (unsigned char *)xalloc(pgcSrc->numInDashList *
						   sizeof(unsigned char));
d872 1
a872 1
_X_EXPORT int
d906 1
a906 1
_X_EXPORT GCPtr
d911 1
a911 1
    pGC = (GCPtr)xalloc(sizeof(GC));
d935 1
d1072 1
a1072 1
	p = (unsigned char *)xalloc(2 * ndash * sizeof(unsigned char));
d1074 1
a1074 1
	p = (unsigned char *)xalloc(ndash * sizeof(unsigned char));
d1108 1
a1108 1
_X_EXPORT int
d1169 1
a1169 1
    prectsNew = (xRectangle *) xalloc(size);
d1195 1
a1195 1
_X_EXPORT GCPtr
d1244 1
a1244 1
_X_EXPORT void
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d276 1
a276 1
		    rc = dixLookupResource((pointer *)&pPixmap, newpix,
d313 1
a313 1
		    rc = dixLookupResource((pointer *)&pPixmap, newstipple,
d356 1
a356 1
		    rc = dixLookupResource((pointer *)&pFont, newfont,
d423 1
a423 1
			rc = dixLookupResource((pointer *)&pPixmap, pid,
d1052 1
a1052 1
_X_EXPORT int
d1158 1
a1158 1
_X_EXPORT int
@


1.1
log
@Initial revision
@
text
@d64 1
d66 1
d74 1
a74 1
unsigned char DefaultDash[2] = {4, 4};
d149 1
a149 1
dixChangeGC(ClientPtr client, register GC *pGC, register BITS32 mask, CARD32 *pC32, ChangeGCValPtr pUnion)
d151 4
a154 4
    register BITS32 	index2;
    register int 	error = 0;
    PixmapPtr 		pPixmap;
    BITS32		maskQ;
d271 1
d276 2
a277 2
		    pPixmap = (PixmapPtr)SecurityLookupIDByType(client,
					newpix, RT_PIXMAP, SecurityReadAccess);
d279 1
a279 1
		if (pPixmap)
d298 1
a298 1
		    error = BadPixmap;
d308 1
d313 2
a314 2
		    pPixmap = (PixmapPtr)SecurityLookupIDByType(client,
				newstipple, RT_PIXMAP, SecurityReadAccess);
d316 1
a316 1
		if (pPixmap)
d334 1
a334 1
		    error = BadPixmap;
d351 1
d356 2
a357 2
		    pFont = (FontPtr)SecurityLookupIDByType(client, newfont,
						RT_FONT, SecurityReadAccess);
d359 1
a359 1
		if (pFont)
d369 1
a369 1
		    error = BadFont;
d422 9
a430 3
		    else
		        pPixmap = (PixmapPtr)SecurityLookupIDByType(client,
					pid, RT_PIXMAP, SecurityReadAccess);
a445 5
		else if (!pUnion && (pid != None))
		{
		    clientErrorValue = pid;
		    error = BadPixmap;
		}
d531 1
a531 1
ChangeGC(register GC *pGC, register BITS32 mask, XID *pval)
d557 1
a557 1
DoChangeGC(register GC *pGC, register BITS32 mask, XID *pval, int fPointer)
d576 3
a578 3

static GCPtr
AllocateGC(ScreenPtr pScreen)
a580 26
    register char *ptr;
    register DevUnion *ppriv;
    register unsigned *sizes;
    register unsigned size;
    register int i;

    pGC = (GCPtr)xalloc(pScreen->totalGCSize);
    if (pGC)
    {
	ppriv = (DevUnion *)(pGC + 1);
	pGC->devPrivates = ppriv;
	sizes = pScreen->GCPrivateSizes;
	ptr = (char *)(ppriv + pScreen->GCPrivateLen);
	for (i = pScreen->GCPrivateLen; --i >= 0; ppriv++, sizes++)
	{
	    if ( (size = *sizes) )
	    {
		ppriv->ptr = (pointer)ptr;
		ptr += size;
	    }
	    else
		ppriv->ptr = (pointer)NULL;
	}
    }
    return pGC;
}
d582 1
a582 6
_X_EXPORT GCPtr
CreateGC(DrawablePtr pDrawable, BITS32 mask, XID *pval, int *pStatus)
{
    register GCPtr pGC;

    pGC = AllocateGC(pDrawable->pScreen);
d595 1
a595 1

d640 6
d653 2
d680 1
a680 1
					  w, h, pGC->depth);
d710 1
a710 1
CopyGC(register GC *pgcSrc, register GC *pgcDst, register BITS32 mask)
d712 3
a714 3
    register BITS32	index2;
    BITS32		maskQ;
    int 		error = 0;
d889 1
a893 11
void
SetGCMask(GCPtr pGC, Mask selectMask, Mask newDataMask)
{
    pGC->stateChanges = (~selectMask & pGC->stateChanges) |
		        (selectMask & newDataMask);
    if (selectMask & newDataMask)
        pGC->serialNumber |= GC_CHANGE_SERIAL_BIT;        
}



d910 1
a910 1
    register GCPtr pGC;
d912 1
a912 1
    pGC = AllocateGC(pScreen);
d921 1
a921 1

d962 2
a963 2
    register int i;
    register ScreenPtr pScreen;
d978 2
a979 2
    register int i;
    register ScreenPtr pScreen;
d1011 1
a1011 1
    register ScreenPtr pScreen;
d1023 1
a1023 1
			(*pScreen->CreatePixmap)(pScreen, w, h, 1)))
d1053 1
a1053 1
SetDashes(register GCPtr pGC, unsigned offset, unsigned ndash, unsigned char *pdash)
d1055 2
a1056 2
    register long i;
    register unsigned char *p, *indash;
d1111 2
a1112 2
    register xRectangle	*prectP, *prectN;
    register int	i;
d1196 1
a1196 1
GetScratchGC(register unsigned depth, register ScreenPtr pScreen)
d1198 2
a1199 2
    register int i;
    register GCPtr pGC;
d1245 1
a1245 1
FreeScratchGC(register GCPtr pGC)
d1247 2
a1248 2
    register ScreenPtr pScreen = pGC->pScreen;
    register int i;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d72 1
a72 1
static unsigned char DefaultDash[2] = {4, 4};
d147 1
a147 1
dixChangeGC(ClientPtr client, GC *pGC, BITS32 mask, CARD32 *pC32, ChangeGCValPtr pUnion)
d149 4
a152 4
    BITS32 	index2;
    int 	error = 0;
    PixmapPtr 	pPixmap;
    BITS32	maskQ;
d274 1
a274 1
					newpix, RT_PIXMAP, DixReadAccess);
d310 1
a310 1
				newstipple, RT_PIXMAP, DixReadAccess);
d352 1
a352 1
						RT_FONT, DixReadAccess);
d419 1
a419 1
					pid, RT_PIXMAP, DixReadAccess);
d525 1
a525 1
ChangeGC(GC *pGC, BITS32 mask, XID *pval)
d551 1
a551 1
DoChangeGC(GC *pGC, BITS32 mask, XID *pval, int fPointer)
d575 5
a579 5
    char *ptr;
    DevUnion *ppriv;
    unsigned *sizes;
    unsigned size;
    int i;
d605 1
a605 1
    GCPtr pGC;
d727 1
a727 1
CopyGC(GC *pgcSrc, GC *pgcDst, BITS32 mask)
d729 3
a731 3
    BITS32	index2;
    BITS32	maskQ;
    int 	error = 0;
d910 11
d937 1
a937 1
    GCPtr pGC;
d989 2
a990 2
    int i;
    ScreenPtr pScreen;
d1005 2
a1006 2
    int i;
    ScreenPtr pScreen;
d1038 1
a1038 1
    ScreenPtr pScreen;
d1080 1
a1080 1
SetDashes(GCPtr pGC, unsigned offset, unsigned ndash, unsigned char *pdash)
d1082 2
a1083 2
    long i;
    unsigned char *p, *indash;
d1138 2
a1139 2
    xRectangle	*prectP, *prectN;
    int	i;
d1223 1
a1223 1
GetScratchGC(unsigned depth, ScreenPtr pScreen)
d1225 2
a1226 2
    int i;
    GCPtr pGC;
d1272 1
a1272 1
FreeScratchGC(GCPtr pGC)
d1274 2
a1275 2
    ScreenPtr pScreen = pGC->pScreen;
    int i;
@

