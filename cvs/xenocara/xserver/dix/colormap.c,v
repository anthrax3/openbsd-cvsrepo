head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.15;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include "misc.h"
#include "dix.h"
#include "dixstruct.h"
#include "colormapst.h"
#include "os.h"
#include "scrnintstr.h"
#include "resource.h"
#include "windowstr.h"
#include "privates.h"
#include "xace.h"

typedef int (*ColorCompareProcPtr) (EntryPtr /*pent */ ,
                                    xrgb * /*prgb */ );

static Pixel FindBestPixel(EntryPtr /*pentFirst */ ,
                           int /*size */ ,
                           xrgb * /*prgb */ ,
                           int  /*channel */
    );

static int AllComp(EntryPtr /*pent */ ,
                   xrgb *       /*prgb */
    );

static int RedComp(EntryPtr /*pent */ ,
                   xrgb *       /*prgb */
    );

static int GreenComp(EntryPtr /*pent */ ,
                     xrgb *     /*prgb */
    );

static int BlueComp(EntryPtr /*pent */ ,
                    xrgb *      /*prgb */
    );

static void FreePixels(ColormapPtr /*pmap */ ,
                       int      /*client */
    );

static void CopyFree(int /*channel */ ,
                     int /*client */ ,
                     ColormapPtr /*pmapSrc */ ,
                     ColormapPtr        /*pmapDst */
    );

static void FreeCell(ColormapPtr /*pmap */ ,
                     Pixel /*i */ ,
                     int        /*channel */
    );

static void UpdateColors(ColormapPtr    /*pmap */
    );

static int AllocDirect(int /*client */ ,
                       ColormapPtr /*pmap */ ,
                       int /*c */ ,
                       int /*r */ ,
                       int /*g */ ,
                       int /*b */ ,
                       Bool /*contig */ ,
                       Pixel * /*pixels */ ,
                       Pixel * /*prmask */ ,
                       Pixel * /*pgmask */ ,
                       Pixel *  /*pbmask */
    );

static int AllocPseudo(int /*client */ ,
                       ColormapPtr /*pmap */ ,
                       int /*c */ ,
                       int /*r */ ,
                       Bool /*contig */ ,
                       Pixel * /*pixels */ ,
                       Pixel * /*pmask */ ,
                       Pixel ** /*pppixFirst */
    );

static Bool AllocCP(ColormapPtr /*pmap */ ,
                    EntryPtr /*pentFirst */ ,
                    int /*count */ ,
                    int /*planes */ ,
                    Bool /*contig */ ,
                    Pixel * /*pixels */ ,
                    Pixel *     /*pMask */
    );

static Bool AllocShared(ColormapPtr /*pmap */ ,
                        Pixel * /*ppix */ ,
                        int /*c */ ,
                        int /*r */ ,
                        int /*g */ ,
                        int /*b */ ,
                        Pixel /*rmask */ ,
                        Pixel /*gmask */ ,
                        Pixel /*bmask */ ,
                        Pixel * /*ppixFirst */
    );

static int FreeCo(ColormapPtr /*pmap */ ,
                  int /*client */ ,
                  int /*color */ ,
                  int /*npixIn */ ,
                  Pixel * /*ppixIn */ ,
                  Pixel         /*mask */
    );

static int TellNoMap(WindowPtr /*pwin */ ,
                     Colormap * /*pmid */
    );

static void FindColorInRootCmap(ColormapPtr /* pmap */ ,
                                EntryPtr /* pentFirst */ ,
                                int /* size */ ,
                                xrgb * /* prgb */ ,
                                Pixel * /* pPixel */ ,
                                int /* channel */ ,
                                ColorCompareProcPtr     /* comp */
    );

#define NUMRED(vis) ((vis->redMask >> vis->offsetRed) + 1)
#define NUMGREEN(vis) ((vis->greenMask >> vis->offsetGreen) + 1)
#define NUMBLUE(vis) ((vis->blueMask >> vis->offsetBlue) + 1)
#if COMPOSITE
#define ALPHAMASK(vis)	((vis)->nplanes < 32 ? 0 : \
			 (CARD32) ~((vis)->redMask|(vis)->greenMask|(vis)->blueMask))
#else
#define ALPHAMASK(vis)	0
#endif

#define RGBMASK(vis) (vis->redMask | vis->greenMask | vis->blueMask | ALPHAMASK(vis))

/* GetNextBitsOrBreak(bits, mask, base)  --
 * (Suggestion: First read the macro, then read this explanation.
 *
 * Either generate the next value to OR in to a pixel or break out of this
 * while loop
 *
 * This macro is used when we're trying to generate all 2^n combinations of
 * bits in mask.  What we're doing here is counting in binary, except that
 * the bits we use to count may not be contiguous.  This macro will be
 * called 2^n times, returning a different value in bits each time. Then
 * it will cause us to break out of a surrounding loop. (It will always be
 * called from within a while loop.)
 * On call: mask is the value we want to find all the combinations for
 * base has 1 bit set where the least significant bit of mask is set
 *
 * For example,if mask is 01010, base should be 0010 and we count like this:
 * 00010 (see this isn't so hard),
 *     then we add base to bits and get 0100. (bits & ~mask) is (0100 & 0100) so
 *      we add that to bits getting (0100 + 0100) =
 * 01000 for our next value.
 *      then we add 0010 to get
 * 01010 and we're done (easy as 1, 2, 3)
 */
#define GetNextBitsOrBreak(bits, mask, base)	\
	    if((bits) == (mask)) 		\
		break;		 		\
	    (bits) += (base);		 	\
	    while((bits) & ~(mask))		\
		(bits) += ((bits) & ~(mask));
/* ID of server as client */
#define SERVER_ID	0

typedef struct _colorResource {
    Colormap mid;
    int client;
} colorResource;

/* Invariants:
 * refcnt == 0 means entry is empty
 * refcnt > 0 means entry is useable by many clients, so it can't be changed
 * refcnt == AllocPrivate means entry owned by one client only
 * fShared should only be set if refcnt == AllocPrivate, and only in red map
 */

/**
 * Create and initialize the color map
 *
 * \param mid    resource to use for this colormap
 * \param alloc  1 iff all entries are allocated writable
 */
int
CreateColormap(Colormap mid, ScreenPtr pScreen, VisualPtr pVisual,
               ColormapPtr *ppcmap, int alloc, int client)
{
    int class, size;
    unsigned long sizebytes;
    ColormapPtr pmap;
    EntryPtr pent;
    int i;
    Pixel *ppix, **pptr;

    class = pVisual->class;
    if (!(class & DynamicClass) && (alloc != AllocNone) &&
        (client != SERVER_ID))
        return BadMatch;

    size = pVisual->ColormapEntries;
    sizebytes = (size * sizeof(Entry)) +
        (LimitClients * sizeof(Pixel *)) + (LimitClients * sizeof(int));
    if ((class | DynamicClass) == DirectColor)
        sizebytes *= 3;
    sizebytes += sizeof(ColormapRec);
    if (mid == pScreen->defColormap) {
        pmap = malloc(sizebytes);
        if (!pmap)
            return BadAlloc;
        if (!dixAllocatePrivates(&pmap->devPrivates, PRIVATE_COLORMAP)) {
            free(pmap);
            return BadAlloc;
        }
    }
    else {
        pmap = _dixAllocateObjectWithPrivates(sizebytes, sizebytes,
                                              offsetof(ColormapRec,
                                                       devPrivates),
                                              PRIVATE_COLORMAP);
        if (!pmap)
            return BadAlloc;
    }
    pmap->red = (EntryPtr) ((char *) pmap + sizeof(ColormapRec));
    sizebytes = size * sizeof(Entry);
    pmap->clientPixelsRed = (Pixel **) ((char *) pmap->red + sizebytes);
    pmap->numPixelsRed = (int *) ((char *) pmap->clientPixelsRed +
                                  (LimitClients * sizeof(Pixel *)));
    pmap->mid = mid;
    pmap->flags = 0;            /* start out with all flags clear */
    if (mid == pScreen->defColormap)
        pmap->flags |= IsDefault;
    pmap->pScreen = pScreen;
    pmap->pVisual = pVisual;
    pmap->class = class;
    if ((class | DynamicClass) == DirectColor)
        size = NUMRED(pVisual);
    pmap->freeRed = size;
    memset((char *) pmap->red, 0, (int) sizebytes);
    memset((char *) pmap->numPixelsRed, 0, LimitClients * sizeof(int));
    for (pptr = &pmap->clientPixelsRed[LimitClients];
         --pptr >= pmap->clientPixelsRed;)
        *pptr = (Pixel *) NULL;
    if (alloc == AllocAll) {
        if (class & DynamicClass)
            pmap->flags |= AllAllocated;
        for (pent = &pmap->red[size - 1]; pent >= pmap->red; pent--)
            pent->refcnt = AllocPrivate;
        pmap->freeRed = 0;
        ppix = xallocarray(size, sizeof(Pixel));
        if (!ppix) {
            free(pmap);
            return BadAlloc;
        }
        pmap->clientPixelsRed[client] = ppix;
        for (i = 0; i < size; i++)
            ppix[i] = i;
        pmap->numPixelsRed[client] = size;
    }

    if ((class | DynamicClass) == DirectColor) {
        pmap->freeGreen = NUMGREEN(pVisual);
        pmap->green = (EntryPtr) ((char *) pmap->numPixelsRed +
                                  (LimitClients * sizeof(int)));
        pmap->clientPixelsGreen = (Pixel **) ((char *) pmap->green + sizebytes);
        pmap->numPixelsGreen = (int *) ((char *) pmap->clientPixelsGreen +
                                        (LimitClients * sizeof(Pixel *)));
        pmap->freeBlue = NUMBLUE(pVisual);
        pmap->blue = (EntryPtr) ((char *) pmap->numPixelsGreen +
                                 (LimitClients * sizeof(int)));
        pmap->clientPixelsBlue = (Pixel **) ((char *) pmap->blue + sizebytes);
        pmap->numPixelsBlue = (int *) ((char *) pmap->clientPixelsBlue +
                                       (LimitClients * sizeof(Pixel *)));

        memset((char *) pmap->green, 0, (int) sizebytes);
        memset((char *) pmap->blue, 0, (int) sizebytes);

        memmove((char *) pmap->clientPixelsGreen,
                (char *) pmap->clientPixelsRed, LimitClients * sizeof(Pixel *));
        memmove((char *) pmap->clientPixelsBlue,
                (char *) pmap->clientPixelsRed, LimitClients * sizeof(Pixel *));
        memset((char *) pmap->numPixelsGreen, 0, LimitClients * sizeof(int));
        memset((char *) pmap->numPixelsBlue, 0, LimitClients * sizeof(int));

        /* If every cell is allocated, mark its refcnt */
        if (alloc == AllocAll) {
            size = pmap->freeGreen;
            for (pent = &pmap->green[size - 1]; pent >= pmap->green; pent--)
                pent->refcnt = AllocPrivate;
            pmap->freeGreen = 0;
            ppix = xallocarray(size, sizeof(Pixel));
            if (!ppix) {
                free(pmap->clientPixelsRed[client]);
                free(pmap);
                return BadAlloc;
            }
            pmap->clientPixelsGreen[client] = ppix;
            for (i = 0; i < size; i++)
                ppix[i] = i;
            pmap->numPixelsGreen[client] = size;

            size = pmap->freeBlue;
            for (pent = &pmap->blue[size - 1]; pent >= pmap->blue; pent--)
                pent->refcnt = AllocPrivate;
            pmap->freeBlue = 0;
            ppix = xallocarray(size, sizeof(Pixel));
            if (!ppix) {
                free(pmap->clientPixelsGreen[client]);
                free(pmap->clientPixelsRed[client]);
                free(pmap);
                return BadAlloc;
            }
            pmap->clientPixelsBlue[client] = ppix;
            for (i = 0; i < size; i++)
                ppix[i] = i;
            pmap->numPixelsBlue[client] = size;
        }
    }
    pmap->flags |= BeingCreated;

    if (!AddResource(mid, RT_COLORMAP, (void *) pmap))
        return BadAlloc;

    /*
     * Security creation/labeling check
     */
    i = XaceHook(XACE_RESOURCE_ACCESS, clients[client], mid, RT_COLORMAP,
                 pmap, RT_NONE, NULL, DixCreateAccess);
    if (i != Success) {
        FreeResource(mid, RT_NONE);
        return i;
    }

    /* If the device wants a chance to initialize the colormap in any way,
     * this is it.  In specific, if this is a Static colormap, this is the
     * time to fill in the colormap's values */
    if (!(*pScreen->CreateColormap) (pmap)) {
        FreeResource(mid, RT_NONE);
        return BadAlloc;
    }
    pmap->flags &= ~BeingCreated;
    *ppcmap = pmap;
    return Success;
}

/**
 *
 * \param value  must conform to DeleteType
 */
int
FreeColormap(void *value, XID mid)
{
    int i;
    EntryPtr pent;
    ColormapPtr pmap = (ColormapPtr) value;

    if (CLIENT_ID(mid) != SERVER_ID) {
        (*pmap->pScreen->UninstallColormap) (pmap);
        WalkTree(pmap->pScreen, (VisitWindowProcPtr) TellNoMap, (void *) &mid);
    }

    /* This is the device's chance to undo anything it needs to, especially
     * to free any storage it allocated */
    (*pmap->pScreen->DestroyColormap) (pmap);

    if (pmap->clientPixelsRed) {
        for (i = 0; i < LimitClients; i++)
            free(pmap->clientPixelsRed[i]);
    }

    if ((pmap->class == PseudoColor) || (pmap->class == GrayScale)) {
        for (pent = &pmap->red[pmap->pVisual->ColormapEntries - 1];
             pent >= pmap->red; pent--) {
            if (pent->fShared) {
                if (--pent->co.shco.red->refcnt == 0)
                    free(pent->co.shco.red);
                if (--pent->co.shco.green->refcnt == 0)
                    free(pent->co.shco.green);
                if (--pent->co.shco.blue->refcnt == 0)
                    free(pent->co.shco.blue);
            }
        }
    }
    if ((pmap->class | DynamicClass) == DirectColor) {
        for (i = 0; i < LimitClients; i++) {
            free(pmap->clientPixelsGreen[i]);
            free(pmap->clientPixelsBlue[i]);
        }
    }

    if (pmap->flags & IsDefault) {
        dixFreePrivates(pmap->devPrivates, PRIVATE_COLORMAP);
        free(pmap);
    }
    else
        dixFreeObjectWithPrivates(pmap, PRIVATE_COLORMAP);
    return Success;
}

/* Tell window that pmid has disappeared */
static int
TellNoMap(WindowPtr pwin, Colormap * pmid)
{
    if (wColormap(pwin) == *pmid) {
        /* This should be call to DeliverEvent */
        xEvent xE = {
            .u.colormap.window = pwin->drawable.id,
            .u.colormap.colormap = None,
            .u.colormap.new = TRUE,
            .u.colormap.state = ColormapUninstalled
        };
        xE.u.u.type = ColormapNotify;
#ifdef PANORAMIX
        if (noPanoramiXExtension || !pwin->drawable.pScreen->myNum)
#endif
            DeliverEvents(pwin, &xE, 1, (WindowPtr) NULL);
        if (pwin->optional) {
            pwin->optional->colormap = None;
            CheckWindowOptionalNeed(pwin);
        }
    }

    return WT_WALKCHILDREN;
}

/* Tell window that pmid got uninstalled */
int
TellLostMap(WindowPtr pwin, void *value)
{
    Colormap *pmid = (Colormap *) value;

#ifdef PANORAMIX
    if (!noPanoramiXExtension && pwin->drawable.pScreen->myNum)
        return WT_STOPWALKING;
#endif
    if (wColormap(pwin) == *pmid) {
        /* This should be call to DeliverEvent */
        xEvent xE = {
            .u.colormap.window = pwin->drawable.id,
            .u.colormap.colormap = *pmid,
            .u.colormap.new = FALSE,
            .u.colormap.state = ColormapUninstalled
        };
        xE.u.u.type = ColormapNotify;
        DeliverEvents(pwin, &xE, 1, (WindowPtr) NULL);
    }

    return WT_WALKCHILDREN;
}

/* Tell window that pmid got installed */
int
TellGainedMap(WindowPtr pwin, void *value)
{
    Colormap *pmid = (Colormap *) value;

#ifdef PANORAMIX
    if (!noPanoramiXExtension && pwin->drawable.pScreen->myNum)
        return WT_STOPWALKING;
#endif
    if (wColormap(pwin) == *pmid) {
        /* This should be call to DeliverEvent */
        xEvent xE = {
            .u.colormap.window = pwin->drawable.id,
            .u.colormap.colormap = *pmid,
            .u.colormap.new = FALSE,
            .u.colormap.state = ColormapInstalled
        };
        xE.u.u.type = ColormapNotify;
        DeliverEvents(pwin, &xE, 1, (WindowPtr) NULL);
    }

    return WT_WALKCHILDREN;
}

int
CopyColormapAndFree(Colormap mid, ColormapPtr pSrc, int client)
{
    ColormapPtr pmap = (ColormapPtr) NULL;
    int result, alloc, size;
    Colormap midSrc;
    ScreenPtr pScreen;
    VisualPtr pVisual;

    pScreen = pSrc->pScreen;
    pVisual = pSrc->pVisual;
    midSrc = pSrc->mid;
    alloc = ((pSrc->flags & AllAllocated) && CLIENT_ID(midSrc) == client) ?
        AllocAll : AllocNone;
    size = pVisual->ColormapEntries;

    /* If the create returns non-0, it failed */
    result = CreateColormap(mid, pScreen, pVisual, &pmap, alloc, client);
    if (result != Success)
        return result;
    if (alloc == AllocAll) {
        memmove((char *) pmap->red, (char *) pSrc->red, size * sizeof(Entry));
        if ((pmap->class | DynamicClass) == DirectColor) {
            memmove((char *) pmap->green, (char *) pSrc->green,
                    size * sizeof(Entry));
            memmove((char *) pmap->blue, (char *) pSrc->blue,
                    size * sizeof(Entry));
        }
        pSrc->flags &= ~AllAllocated;
        FreePixels(pSrc, client);
        UpdateColors(pmap);
        return Success;
    }

    CopyFree(REDMAP, client, pSrc, pmap);
    if ((pmap->class | DynamicClass) == DirectColor) {
        CopyFree(GREENMAP, client, pSrc, pmap);
        CopyFree(BLUEMAP, client, pSrc, pmap);
    }
    if (pmap->class & DynamicClass)
        UpdateColors(pmap);
    /* XXX should worry about removing any RT_CMAPENTRY resource */
    return Success;
}

/* Helper routine for freeing large numbers of cells from a map */
static void
CopyFree(int channel, int client, ColormapPtr pmapSrc, ColormapPtr pmapDst)
{
    int z, npix;
    EntryPtr pentSrcFirst, pentDstFirst;
    EntryPtr pentSrc, pentDst;
    Pixel *ppix;
    int nalloc;

    switch (channel) {
    default:         /* so compiler can see that everything gets initialized */
    case REDMAP:
        ppix = (pmapSrc->clientPixelsRed)[client];
        npix = (pmapSrc->numPixelsRed)[client];
        pentSrcFirst = pmapSrc->red;
        pentDstFirst = pmapDst->red;
        break;
    case GREENMAP:
        ppix = (pmapSrc->clientPixelsGreen)[client];
        npix = (pmapSrc->numPixelsGreen)[client];
        pentSrcFirst = pmapSrc->green;
        pentDstFirst = pmapDst->green;
        break;
    case BLUEMAP:
        ppix = (pmapSrc->clientPixelsBlue)[client];
        npix = (pmapSrc->numPixelsBlue)[client];
        pentSrcFirst = pmapSrc->blue;
        pentDstFirst = pmapDst->blue;
        break;
    }
    nalloc = 0;
    if (pmapSrc->class & DynamicClass) {
        for (z = npix; --z >= 0; ppix++) {
            /* Copy entries */
            pentSrc = pentSrcFirst + *ppix;
            pentDst = pentDstFirst + *ppix;
            if (pentDst->refcnt > 0) {
                pentDst->refcnt++;
            }
            else {
                *pentDst = *pentSrc;
                nalloc++;
                if (pentSrc->refcnt > 0)
                    pentDst->refcnt = 1;
                else
                    pentSrc->fShared = FALSE;
            }
            FreeCell(pmapSrc, *ppix, channel);
        }
    }

    /* Note that FreeCell has already fixed pmapSrc->free{Color} */
    switch (channel) {
    case REDMAP:
        pmapDst->freeRed -= nalloc;
        (pmapDst->clientPixelsRed)[client] = (pmapSrc->clientPixelsRed)[client];
        (pmapSrc->clientPixelsRed)[client] = (Pixel *) NULL;
        (pmapDst->numPixelsRed)[client] = (pmapSrc->numPixelsRed)[client];
        (pmapSrc->numPixelsRed)[client] = 0;
        break;
    case GREENMAP:
        pmapDst->freeGreen -= nalloc;
        (pmapDst->clientPixelsGreen)[client] =
            (pmapSrc->clientPixelsGreen)[client];
        (pmapSrc->clientPixelsGreen)[client] = (Pixel *) NULL;
        (pmapDst->numPixelsGreen)[client] = (pmapSrc->numPixelsGreen)[client];
        (pmapSrc->numPixelsGreen)[client] = 0;
        break;
    case BLUEMAP:
        pmapDst->freeBlue -= nalloc;
        pmapDst->clientPixelsBlue[client] = pmapSrc->clientPixelsBlue[client];
        pmapSrc->clientPixelsBlue[client] = (Pixel *) NULL;
        pmapDst->numPixelsBlue[client] = pmapSrc->numPixelsBlue[client];
        pmapSrc->numPixelsBlue[client] = 0;
        break;
    }
}

/* Free the ith entry in a color map.  Must handle freeing of
 * colors allocated through AllocColorPlanes */
static void
FreeCell(ColormapPtr pmap, Pixel i, int channel)
{
    EntryPtr pent;
    int *pCount;

    switch (channel) {
    default:         /* so compiler can see that everything gets initialized */
    case PSEUDOMAP:
    case REDMAP:
        pent = (EntryPtr) &pmap->red[i];
        pCount = &pmap->freeRed;
        break;
    case GREENMAP:
        pent = (EntryPtr) &pmap->green[i];
        pCount = &pmap->freeGreen;
        break;
    case BLUEMAP:
        pent = (EntryPtr) &pmap->blue[i];
        pCount = &pmap->freeBlue;
        break;
    }
    /* If it's not privately allocated and it's not time to free it, just
     * decrement the count */
    if (pent->refcnt > 1)
        pent->refcnt--;
    else {
        /* If the color type is shared, find the sharedcolor. If decremented
         * refcnt is 0, free the shared cell. */
        if (pent->fShared) {
            if (--pent->co.shco.red->refcnt == 0)
                free(pent->co.shco.red);
            if (--pent->co.shco.green->refcnt == 0)
                free(pent->co.shco.green);
            if (--pent->co.shco.blue->refcnt == 0)
                free(pent->co.shco.blue);
            pent->fShared = FALSE;
        }
        pent->refcnt = 0;
        *pCount += 1;
    }
}

static void
UpdateColors(ColormapPtr pmap)
{
    xColorItem *defs;
    xColorItem *pdef;
    EntryPtr pent;
    VisualPtr pVisual;
    int i, n, size;

    pVisual = pmap->pVisual;
    size = pVisual->ColormapEntries;
    defs = xallocarray(size, sizeof(xColorItem));
    if (!defs)
        return;
    n = 0;
    pdef = defs;
    if (pmap->class == DirectColor) {
        for (i = 0; i < size; i++) {
            if (!pmap->red[i].refcnt &&
                !pmap->green[i].refcnt && !pmap->blue[i].refcnt)
                continue;
            pdef->pixel = ((Pixel) i << pVisual->offsetRed) |
                ((Pixel) i << pVisual->offsetGreen) |
                ((Pixel) i << pVisual->offsetBlue);
            pdef->red = pmap->red[i].co.local.red;
            pdef->green = pmap->green[i].co.local.green;
            pdef->blue = pmap->blue[i].co.local.blue;
            pdef->flags = DoRed | DoGreen | DoBlue;
            pdef++;
            n++;
        }
    }
    else {
        for (i = 0, pent = pmap->red; i < size; i++, pent++) {
            if (!pent->refcnt)
                continue;
            pdef->pixel = i;
            if (pent->fShared) {
                pdef->red = pent->co.shco.red->color;
                pdef->green = pent->co.shco.green->color;
                pdef->blue = pent->co.shco.blue->color;
            }
            else {
                pdef->red = pent->co.local.red;
                pdef->green = pent->co.local.green;
                pdef->blue = pent->co.local.blue;
            }
            pdef->flags = DoRed | DoGreen | DoBlue;
            pdef++;
            n++;
        }
    }
    if (n)
        (*pmap->pScreen->StoreColors) (pmap, n, defs);
    free(defs);
}

/* Tries to find a color in pmap that exactly matches the one requested in prgb
 * if it can't it allocates one.
 * Starts looking at pentFirst + *pPixel, so if you want a specific pixel,
 * load *pPixel with that value, otherwise set it to 0
 */
static int
FindColor(ColormapPtr pmap, EntryPtr pentFirst, int size, xrgb * prgb,
          Pixel * pPixel, int channel, int client, ColorCompareProcPtr comp)
{
    EntryPtr pent;
    Bool foundFree;
    Pixel pixel, Free = 0;
    int npix, count, *nump = NULL;
    Pixel **pixp = NULL, *ppix;
    xColorItem def;

    foundFree = FALSE;

    if ((pixel = *pPixel) >= size)
        pixel = 0;
    /* see if there is a match, and also look for a free entry */
    for (pent = pentFirst + pixel, count = size; --count >= 0;) {
        if (pent->refcnt > 0) {
            if ((*comp) (pent, prgb)) {
                if (client >= 0)
                    pent->refcnt++;
                *pPixel = pixel;
                switch (channel) {
                case REDMAP:
                    *pPixel <<= pmap->pVisual->offsetRed;
                case PSEUDOMAP:
                    break;
                case GREENMAP:
                    *pPixel <<= pmap->pVisual->offsetGreen;
                    break;
                case BLUEMAP:
                    *pPixel <<= pmap->pVisual->offsetBlue;
                    break;
                }
                goto gotit;
            }
        }
        else if (!foundFree && pent->refcnt == 0) {
            Free = pixel;
            foundFree = TRUE;
            /* If we're initializing the colormap, then we are looking for
             * the first free cell we can find, not to minimize the number
             * of entries we use.  So don't look any further. */
            if (pmap->flags & BeingCreated)
                break;
        }
        pixel++;
        if (pixel >= size) {
            pent = pentFirst;
            pixel = 0;
        }
        else
            pent++;
    }

    /* If we got here, we didn't find a match.  If we also didn't find
     * a free entry, we're out of luck.  Otherwise, we'll usurp a free
     * entry and fill it in */
    if (!foundFree)
        return BadAlloc;
    pent = pentFirst + Free;
    pent->fShared = FALSE;
    pent->refcnt = (client >= 0) ? 1 : AllocTemporary;

    switch (channel) {
    case PSEUDOMAP:
        pent->co.local.red = prgb->red;
        pent->co.local.green = prgb->green;
        pent->co.local.blue = prgb->blue;
        def.red = prgb->red;
        def.green = prgb->green;
        def.blue = prgb->blue;
        def.flags = (DoRed | DoGreen | DoBlue);
        if (client >= 0)
            pmap->freeRed--;
        def.pixel = Free;
        break;

    case REDMAP:
        pent->co.local.red = prgb->red;
        def.red = prgb->red;
        def.green = pmap->green[0].co.local.green;
        def.blue = pmap->blue[0].co.local.blue;
        def.flags = DoRed;
        if (client >= 0)
            pmap->freeRed--;
        def.pixel = Free << pmap->pVisual->offsetRed;
        break;

    case GREENMAP:
        pent->co.local.green = prgb->green;
        def.red = pmap->red[0].co.local.red;
        def.green = prgb->green;
        def.blue = pmap->blue[0].co.local.blue;
        def.flags = DoGreen;
        if (client >= 0)
            pmap->freeGreen--;
        def.pixel = Free << pmap->pVisual->offsetGreen;
        break;

    case BLUEMAP:
        pent->co.local.blue = prgb->blue;
        def.red = pmap->red[0].co.local.red;
        def.green = pmap->green[0].co.local.green;
        def.blue = prgb->blue;
        def.flags = DoBlue;
        if (client >= 0)
            pmap->freeBlue--;
        def.pixel = Free << pmap->pVisual->offsetBlue;
        break;
    }
    (*pmap->pScreen->StoreColors) (pmap, 1, &def);
    pixel = Free;
    *pPixel = def.pixel;

 gotit:
    if (pmap->flags & BeingCreated || client == -1)
        return Success;
    /* Now remember the pixel, for freeing later */
    switch (channel) {
    case PSEUDOMAP:
    case REDMAP:
        nump = pmap->numPixelsRed;
        pixp = pmap->clientPixelsRed;
        break;

    case GREENMAP:
        nump = pmap->numPixelsGreen;
        pixp = pmap->clientPixelsGreen;
        break;

    case BLUEMAP:
        nump = pmap->numPixelsBlue;
        pixp = pmap->clientPixelsBlue;
        break;
    }
    npix = nump[client];
    ppix = reallocarray(pixp[client], npix + 1, sizeof(Pixel));
    if (!ppix) {
        pent->refcnt--;
        if (!pent->fShared)
            switch (channel) {
            case PSEUDOMAP:
            case REDMAP:
                pmap->freeRed++;
                break;
            case GREENMAP:
                pmap->freeGreen++;
                break;
            case BLUEMAP:
                pmap->freeBlue++;
                break;
            }
        return BadAlloc;
    }
    ppix[npix] = pixel;
    pixp[client] = ppix;
    nump[client]++;

    return Success;
}

/* Get a read-only color from a ColorMap (probably slow for large maps)
 * Returns by changing the value in pred, pgreen, pblue and pPix
 */
int
AllocColor(ColormapPtr pmap,
           unsigned short *pred, unsigned short *pgreen, unsigned short *pblue,
           Pixel * pPix, int client)
{
    Pixel pixR, pixG, pixB;
    int entries;
    xrgb rgb;
    int class;
    VisualPtr pVisual;
    int npix;
    Pixel *ppix;

    pVisual = pmap->pVisual;
    (*pmap->pScreen->ResolveColor) (pred, pgreen, pblue, pVisual);
    rgb.red = *pred;
    rgb.green = *pgreen;
    rgb.blue = *pblue;
    class = pmap->class;
    entries = pVisual->ColormapEntries;

    /* If the colormap is being created, then we want to be able to change
     * the colormap, even if it's a static type. Otherwise, we'd never be
     * able to initialize static colormaps
     */
    if (pmap->flags & BeingCreated)
        class |= DynamicClass;

    /* If this is one of the static storage classes, and we're not initializing
     * it, the best we can do is to find the closest color entry to the
     * requested one and return that.
     */
    switch (class) {
    case StaticColor:
    case StaticGray:
        /* Look up all three components in the same pmap */
        *pPix = pixR = FindBestPixel(pmap->red, entries, &rgb, PSEUDOMAP);
        *pred = pmap->red[pixR].co.local.red;
        *pgreen = pmap->red[pixR].co.local.green;
        *pblue = pmap->red[pixR].co.local.blue;
        npix = pmap->numPixelsRed[client];
        ppix = reallocarray(pmap->clientPixelsRed[client],
                            npix + 1, sizeof(Pixel));
        if (!ppix)
            return BadAlloc;
        ppix[npix] = pixR;
        pmap->clientPixelsRed[client] = ppix;
        pmap->numPixelsRed[client]++;
        break;

    case TrueColor:
        /* Look up each component in its own map, then OR them together */
        pixR = FindBestPixel(pmap->red, NUMRED(pVisual), &rgb, REDMAP);
        pixG = FindBestPixel(pmap->green, NUMGREEN(pVisual), &rgb, GREENMAP);
        pixB = FindBestPixel(pmap->blue, NUMBLUE(pVisual), &rgb, BLUEMAP);
        *pPix = (pixR << pVisual->offsetRed) |
            (pixG << pVisual->offsetGreen) |
            (pixB << pVisual->offsetBlue) | ALPHAMASK(pVisual);

        *pred = pmap->red[pixR].co.local.red;
        *pgreen = pmap->green[pixG].co.local.green;
        *pblue = pmap->blue[pixB].co.local.blue;
        npix = pmap->numPixelsRed[client];
        ppix = reallocarray(pmap->clientPixelsRed[client],
                            npix + 1, sizeof(Pixel));
        if (!ppix)
            return BadAlloc;
        ppix[npix] = pixR;
        pmap->clientPixelsRed[client] = ppix;
        npix = pmap->numPixelsGreen[client];
        ppix = reallocarray(pmap->clientPixelsGreen[client],
                            npix + 1, sizeof(Pixel));
        if (!ppix)
            return BadAlloc;
        ppix[npix] = pixG;
        pmap->clientPixelsGreen[client] = ppix;
        npix = pmap->numPixelsBlue[client];
        ppix = reallocarray(pmap->clientPixelsBlue[client],
                            npix + 1, sizeof(Pixel));
        if (!ppix)
            return BadAlloc;
        ppix[npix] = pixB;
        pmap->clientPixelsBlue[client] = ppix;
        pmap->numPixelsRed[client]++;
        pmap->numPixelsGreen[client]++;
        pmap->numPixelsBlue[client]++;
        break;

    case GrayScale:
    case PseudoColor:
        if (pmap->mid != pmap->pScreen->defColormap &&
            pmap->pVisual->vid == pmap->pScreen->rootVisual) {
            ColormapPtr prootmap;

            dixLookupResourceByType((void **) &prootmap,
                                    pmap->pScreen->defColormap, RT_COLORMAP,
                                    clients[client], DixReadAccess);

            if (pmap->class == prootmap->class)
                FindColorInRootCmap(prootmap, prootmap->red, entries, &rgb,
                                    pPix, PSEUDOMAP, AllComp);
        }
        if (FindColor(pmap, pmap->red, entries, &rgb, pPix, PSEUDOMAP,
                      client, AllComp) != Success)
            return BadAlloc;
        break;

    case DirectColor:
        if (pmap->mid != pmap->pScreen->defColormap &&
            pmap->pVisual->vid == pmap->pScreen->rootVisual) {
            ColormapPtr prootmap;

            dixLookupResourceByType((void **) &prootmap,
                                    pmap->pScreen->defColormap, RT_COLORMAP,
                                    clients[client], DixReadAccess);

            if (pmap->class == prootmap->class) {
                pixR = (*pPix & pVisual->redMask) >> pVisual->offsetRed;
                FindColorInRootCmap(prootmap, prootmap->red, entries, &rgb,
                                    &pixR, REDMAP, RedComp);
                pixG = (*pPix & pVisual->greenMask) >> pVisual->offsetGreen;
                FindColorInRootCmap(prootmap, prootmap->green, entries, &rgb,
                                    &pixG, GREENMAP, GreenComp);
                pixB = (*pPix & pVisual->blueMask) >> pVisual->offsetBlue;
                FindColorInRootCmap(prootmap, prootmap->blue, entries, &rgb,
                                    &pixB, BLUEMAP, BlueComp);
                *pPix = pixR | pixG | pixB;
            }
        }

        pixR = (*pPix & pVisual->redMask) >> pVisual->offsetRed;
        if (FindColor(pmap, pmap->red, NUMRED(pVisual), &rgb, &pixR, REDMAP,
                      client, RedComp) != Success)
            return BadAlloc;
        pixG = (*pPix & pVisual->greenMask) >> pVisual->offsetGreen;
        if (FindColor(pmap, pmap->green, NUMGREEN(pVisual), &rgb, &pixG,
                      GREENMAP, client, GreenComp) != Success) {
            (void) FreeCo(pmap, client, REDMAP, 1, &pixR, (Pixel) 0);
            return BadAlloc;
        }
        pixB = (*pPix & pVisual->blueMask) >> pVisual->offsetBlue;
        if (FindColor(pmap, pmap->blue, NUMBLUE(pVisual), &rgb, &pixB, BLUEMAP,
                      client, BlueComp) != Success) {
            (void) FreeCo(pmap, client, GREENMAP, 1, &pixG, (Pixel) 0);
            (void) FreeCo(pmap, client, REDMAP, 1, &pixR, (Pixel) 0);
            return BadAlloc;
        }
        *pPix = pixR | pixG | pixB | ALPHAMASK(pVisual);

        break;
    }

    /* if this is the client's first pixel in this colormap, tell the
     * resource manager that the client has pixels in this colormap which
     * should be freed when the client dies */
    if ((pmap->numPixelsRed[client] == 1) &&
        (CLIENT_ID(pmap->mid) != client) && !(pmap->flags & BeingCreated)) {
        colorResource *pcr;

        pcr = malloc(sizeof(colorResource));
        if (!pcr) {
            (void) FreeColors(pmap, client, 1, pPix, (Pixel) 0);
            return BadAlloc;
        }
        pcr->mid = pmap->mid;
        pcr->client = client;
        if (!AddResource(FakeClientID(client), RT_CMAPENTRY, (void *) pcr))
            return BadAlloc;
    }
    return Success;
}

/*
 * FakeAllocColor -- fake an AllocColor request by
 * returning a free pixel if availible, otherwise returning
 * the closest matching pixel.  This is used by the mi
 * software sprite code to recolor cursors.  A nice side-effect
 * is that this routine will never return failure.
 */

void
FakeAllocColor(ColormapPtr pmap, xColorItem * item)
{
    Pixel pixR, pixG, pixB;
    Pixel temp;
    int entries;
    xrgb rgb;
    int class;
    VisualPtr pVisual;

    pVisual = pmap->pVisual;
    rgb.red = item->red;
    rgb.green = item->green;
    rgb.blue = item->blue;
    (*pmap->pScreen->ResolveColor) (&rgb.red, &rgb.green, &rgb.blue, pVisual);
    class = pmap->class;
    entries = pVisual->ColormapEntries;

    switch (class) {
    case GrayScale:
    case PseudoColor:
        temp = 0;
        item->pixel = 0;
        if (FindColor(pmap, pmap->red, entries, &rgb, &temp, PSEUDOMAP,
                      -1, AllComp) == Success) {
            item->pixel = temp;
            break;
        }
        /* fall through ... */
    case StaticColor:
    case StaticGray:
        item->pixel = FindBestPixel(pmap->red, entries, &rgb, PSEUDOMAP);
        break;

    case DirectColor:
        /* Look up each component in its own map, then OR them together */
        pixR = (item->pixel & pVisual->redMask) >> pVisual->offsetRed;
        pixG = (item->pixel & pVisual->greenMask) >> pVisual->offsetGreen;
        pixB = (item->pixel & pVisual->blueMask) >> pVisual->offsetBlue;
        if (FindColor(pmap, pmap->red, NUMRED(pVisual), &rgb, &pixR, REDMAP,
                      -1, RedComp) != Success)
            pixR = FindBestPixel(pmap->red, NUMRED(pVisual), &rgb, REDMAP)
                << pVisual->offsetRed;
        if (FindColor(pmap, pmap->green, NUMGREEN(pVisual), &rgb, &pixG,
                      GREENMAP, -1, GreenComp) != Success)
            pixG = FindBestPixel(pmap->green, NUMGREEN(pVisual), &rgb,
                                 GREENMAP) << pVisual->offsetGreen;
        if (FindColor(pmap, pmap->blue, NUMBLUE(pVisual), &rgb, &pixB, BLUEMAP,
                      -1, BlueComp) != Success)
            pixB = FindBestPixel(pmap->blue, NUMBLUE(pVisual), &rgb, BLUEMAP)
                << pVisual->offsetBlue;
        item->pixel = pixR | pixG | pixB;
        break;

    case TrueColor:
        /* Look up each component in its own map, then OR them together */
        pixR = FindBestPixel(pmap->red, NUMRED(pVisual), &rgb, REDMAP);
        pixG = FindBestPixel(pmap->green, NUMGREEN(pVisual), &rgb, GREENMAP);
        pixB = FindBestPixel(pmap->blue, NUMBLUE(pVisual), &rgb, BLUEMAP);
        item->pixel = (pixR << pVisual->offsetRed) |
            (pixG << pVisual->offsetGreen) | (pixB << pVisual->offsetBlue);
        break;
    }
}

/* free a pixel value obtained from FakeAllocColor */
void
FakeFreeColor(ColormapPtr pmap, Pixel pixel)
{
    VisualPtr pVisual;
    Pixel pixR, pixG, pixB;

    switch (pmap->class) {
    case GrayScale:
    case PseudoColor:
        if (pmap->red[pixel].refcnt == AllocTemporary)
            pmap->red[pixel].refcnt = 0;
        break;
    case DirectColor:
        pVisual = pmap->pVisual;
        pixR = (pixel & pVisual->redMask) >> pVisual->offsetRed;
        pixG = (pixel & pVisual->greenMask) >> pVisual->offsetGreen;
        pixB = (pixel & pVisual->blueMask) >> pVisual->offsetBlue;
        if (pmap->red[pixR].refcnt == AllocTemporary)
            pmap->red[pixR].refcnt = 0;
        if (pmap->green[pixG].refcnt == AllocTemporary)
            pmap->green[pixG].refcnt = 0;
        if (pmap->blue[pixB].refcnt == AllocTemporary)
            pmap->blue[pixB].refcnt = 0;
        break;
    }
}

typedef unsigned short BigNumUpper;
typedef unsigned long BigNumLower;

#define BIGNUMLOWERBITS	24
#define BIGNUMUPPERBITS	16
#define BIGNUMLOWER (1 << BIGNUMLOWERBITS)
#define BIGNUMUPPER (1 << BIGNUMUPPERBITS)
#define UPPERPART(i)	((i) >> BIGNUMLOWERBITS)
#define LOWERPART(i)	((i) & (BIGNUMLOWER - 1))

typedef struct _bignum {
    BigNumUpper upper;
    BigNumLower lower;
} BigNumRec, *BigNumPtr;

#define BigNumGreater(x,y) (((x)->upper > (y)->upper) ||\
			    ((x)->upper == (y)->upper && (x)->lower > (y)->lower))

#define UnsignedToBigNum(u,r)	(((r)->upper = UPPERPART(u)), \
				 ((r)->lower = LOWERPART(u)))

#define MaxBigNum(r)		(((r)->upper = BIGNUMUPPER-1), \
				 ((r)->lower = BIGNUMLOWER-1))

static void
BigNumAdd(BigNumPtr x, BigNumPtr y, BigNumPtr r)
{
    BigNumLower lower, carry = 0;

    lower = x->lower + y->lower;
    if (lower >= BIGNUMLOWER) {
        lower -= BIGNUMLOWER;
        carry = 1;
    }
    r->lower = lower;
    r->upper = x->upper + y->upper + carry;
}

static Pixel
FindBestPixel(EntryPtr pentFirst, int size, xrgb * prgb, int channel)
{
    EntryPtr pent;
    Pixel pixel, final;
    long dr, dg, db;
    unsigned long sq;
    BigNumRec minval, sum, temp;

    final = 0;
    MaxBigNum(&minval);
    /* look for the minimal difference */
    for (pent = pentFirst, pixel = 0; pixel < size; pent++, pixel++) {
        dr = dg = db = 0;
        switch (channel) {
        case PSEUDOMAP:
            dg = (long) pent->co.local.green - prgb->green;
            db = (long) pent->co.local.blue - prgb->blue;
        case REDMAP:
            dr = (long) pent->co.local.red - prgb->red;
            break;
        case GREENMAP:
            dg = (long) pent->co.local.green - prgb->green;
            break;
        case BLUEMAP:
            db = (long) pent->co.local.blue - prgb->blue;
            break;
        }
        sq = dr * dr;
        UnsignedToBigNum(sq, &sum);
        sq = dg * dg;
        UnsignedToBigNum(sq, &temp);
        BigNumAdd(&sum, &temp, &sum);
        sq = db * db;
        UnsignedToBigNum(sq, &temp);
        BigNumAdd(&sum, &temp, &sum);
        if (BigNumGreater(&minval, &sum)) {
            final = pixel;
            minval = sum;
        }
    }
    return final;
}

static void
FindColorInRootCmap(ColormapPtr pmap, EntryPtr pentFirst, int size,
                    xrgb * prgb, Pixel * pPixel, int channel,
                    ColorCompareProcPtr comp)
{
    EntryPtr pent;
    Pixel pixel;
    int count;

    if ((pixel = *pPixel) >= size)
        pixel = 0;
    for (pent = pentFirst + pixel, count = size; --count >= 0; pent++, pixel++) {
        if (pent->refcnt > 0 && (*comp) (pent, prgb)) {
            switch (channel) {
            case REDMAP:
                pixel <<= pmap->pVisual->offsetRed;
                break;
            case GREENMAP:
                pixel <<= pmap->pVisual->offsetGreen;
                break;
            case BLUEMAP:
                pixel <<= pmap->pVisual->offsetBlue;
                break;
            default:           /* PSEUDOMAP */
                break;
            }
            *pPixel = pixel;
        }
    }
}

/* Comparison functions -- passed to FindColor to determine if an
 * entry is already the color we're looking for or not */
static int
AllComp(EntryPtr pent, xrgb * prgb)
{
    if ((pent->co.local.red == prgb->red) &&
        (pent->co.local.green == prgb->green) &&
        (pent->co.local.blue == prgb->blue))
        return 1;
    return 0;
}

static int
RedComp(EntryPtr pent, xrgb * prgb)
{
    if (pent->co.local.red == prgb->red)
        return 1;
    return 0;
}

static int
GreenComp(EntryPtr pent, xrgb * prgb)
{
    if (pent->co.local.green == prgb->green)
        return 1;
    return 0;
}

static int
BlueComp(EntryPtr pent, xrgb * prgb)
{
    if (pent->co.local.blue == prgb->blue)
        return 1;
    return 0;
}

/* Read the color value of a cell */

int
QueryColors(ColormapPtr pmap, int count, Pixel * ppixIn, xrgb * prgbList,
            ClientPtr client)
{
    Pixel *ppix, pixel;
    xrgb *prgb;
    VisualPtr pVisual;
    EntryPtr pent;
    Pixel i;
    int errVal = Success;

    pVisual = pmap->pVisual;
    if ((pmap->class | DynamicClass) == DirectColor) {
        int numred, numgreen, numblue;
        Pixel rgbbad;

        numred = NUMRED(pVisual);
        numgreen = NUMGREEN(pVisual);
        numblue = NUMBLUE(pVisual);
        rgbbad = ~RGBMASK(pVisual);
        for (ppix = ppixIn, prgb = prgbList; --count >= 0; ppix++, prgb++) {
            pixel = *ppix;
            if (pixel & rgbbad) {
                client->errorValue = pixel;
                errVal = BadValue;
                continue;
            }
            i = (pixel & pVisual->redMask) >> pVisual->offsetRed;
            if (i >= numred) {
                client->errorValue = pixel;
                errVal = BadValue;
                continue;
            }
            prgb->red = pmap->red[i].co.local.red;
            i = (pixel & pVisual->greenMask) >> pVisual->offsetGreen;
            if (i >= numgreen) {
                client->errorValue = pixel;
                errVal = BadValue;
                continue;
            }
            prgb->green = pmap->green[i].co.local.green;
            i = (pixel & pVisual->blueMask) >> pVisual->offsetBlue;
            if (i >= numblue) {
                client->errorValue = pixel;
                errVal = BadValue;
                continue;
            }
            prgb->blue = pmap->blue[i].co.local.blue;
        }
    }
    else {
        for (ppix = ppixIn, prgb = prgbList; --count >= 0; ppix++, prgb++) {
            pixel = *ppix;
            if (pixel >= pVisual->ColormapEntries) {
                client->errorValue = pixel;
                errVal = BadValue;
            }
            else {
                pent = (EntryPtr) &pmap->red[pixel];
                if (pent->fShared) {
                    prgb->red = pent->co.shco.red->color;
                    prgb->green = pent->co.shco.green->color;
                    prgb->blue = pent->co.shco.blue->color;
                }
                else {
                    prgb->red = pent->co.local.red;
                    prgb->green = pent->co.local.green;
                    prgb->blue = pent->co.local.blue;
                }
            }
        }
    }
    return errVal;
}

static void
FreePixels(ColormapPtr pmap, int client)
{
    Pixel *ppix, *ppixStart;
    int n;
    int class;

    class = pmap->class;
    ppixStart = pmap->clientPixelsRed[client];
    if (class & DynamicClass) {
        n = pmap->numPixelsRed[client];
        for (ppix = ppixStart; --n >= 0;) {
            FreeCell(pmap, *ppix, REDMAP);
            ppix++;
        }
    }

    free(ppixStart);
    pmap->clientPixelsRed[client] = (Pixel *) NULL;
    pmap->numPixelsRed[client] = 0;
    if ((class | DynamicClass) == DirectColor) {
        ppixStart = pmap->clientPixelsGreen[client];
        if (class & DynamicClass)
            for (ppix = ppixStart, n = pmap->numPixelsGreen[client]; --n >= 0;)
                FreeCell(pmap, *ppix++, GREENMAP);
        free(ppixStart);
        pmap->clientPixelsGreen[client] = (Pixel *) NULL;
        pmap->numPixelsGreen[client] = 0;

        ppixStart = pmap->clientPixelsBlue[client];
        if (class & DynamicClass)
            for (ppix = ppixStart, n = pmap->numPixelsBlue[client]; --n >= 0;)
                FreeCell(pmap, *ppix++, BLUEMAP);
        free(ppixStart);
        pmap->clientPixelsBlue[client] = (Pixel *) NULL;
        pmap->numPixelsBlue[client] = 0;
    }
}

/**
 * Frees all of a client's colors and cells.
 *
 *  \param value  must conform to DeleteType
 *  \unused fakeid
 */
int
FreeClientPixels(void *value, XID fakeid)
{
    void *pmap;
    colorResource *pcr = value;
    int rc;

    rc = dixLookupResourceByType(&pmap, pcr->mid, RT_COLORMAP, serverClient,
                                 DixRemoveAccess);
    if (rc == Success)
        FreePixels((ColormapPtr) pmap, pcr->client);
    free(pcr);
    return Success;
}

int
AllocColorCells(int client, ColormapPtr pmap, int colors, int planes,
                Bool contig, Pixel * ppix, Pixel * masks)
{
    Pixel rmask, gmask, bmask, *ppixFirst, r, g, b;
    int n, class;
    int ok;
    int oldcount;
    colorResource *pcr = (colorResource *) NULL;

    class = pmap->class;
    if (!(class & DynamicClass))
        return BadAlloc;        /* Shouldn't try on this type */
    oldcount = pmap->numPixelsRed[client];
    if (pmap->class == DirectColor)
        oldcount += pmap->numPixelsGreen[client] + pmap->numPixelsBlue[client];
    if (!oldcount && (CLIENT_ID(pmap->mid) != client)) {
        pcr = malloc(sizeof(colorResource));
        if (!pcr)
            return BadAlloc;
    }

    if (pmap->class == DirectColor) {
        ok = AllocDirect(client, pmap, colors, planes, planes, planes,
                         contig, ppix, &rmask, &gmask, &bmask);
        if (ok == Success) {
            for (r = g = b = 1, n = planes; --n >= 0; r += r, g += g, b += b) {
                while (!(rmask & r))
                    r += r;
                while (!(gmask & g))
                    g += g;
                while (!(bmask & b))
                    b += b;
                *masks++ = r | g | b;
            }
        }
    }
    else {
        ok = AllocPseudo(client, pmap, colors, planes, contig, ppix, &rmask,
                         &ppixFirst);
        if (ok == Success) {
            for (r = 1, n = planes; --n >= 0; r += r) {
                while (!(rmask & r))
                    r += r;
                *masks++ = r;
            }
        }
    }

    /* if this is the client's first pixels in this colormap, tell the
     * resource manager that the client has pixels in this colormap which
     * should be freed when the client dies */
    if ((ok == Success) && pcr) {
        pcr->mid = pmap->mid;
        pcr->client = client;
        if (!AddResource(FakeClientID(client), RT_CMAPENTRY, (void *) pcr))
            ok = BadAlloc;
    }
    else
        free(pcr);

    return ok;
}

int
AllocColorPlanes(int client, ColormapPtr pmap, int colors,
                 int r, int g, int b, Bool contig, Pixel * pixels,
                 Pixel * prmask, Pixel * pgmask, Pixel * pbmask)
{
    int ok;
    Pixel mask, *ppixFirst;
    Pixel shift;
    int i;
    int class;
    int oldcount;
    colorResource *pcr = (colorResource *) NULL;

    class = pmap->class;
    if (!(class & DynamicClass))
        return BadAlloc;        /* Shouldn't try on this type */
    oldcount = pmap->numPixelsRed[client];
    if (class == DirectColor)
        oldcount += pmap->numPixelsGreen[client] + pmap->numPixelsBlue[client];
    if (!oldcount && (CLIENT_ID(pmap->mid) != client)) {
        pcr = malloc(sizeof(colorResource));
        if (!pcr)
            return BadAlloc;
    }

    if (class == DirectColor) {
        ok = AllocDirect(client, pmap, colors, r, g, b, contig, pixels,
                         prmask, pgmask, pbmask);
    }
    else {
        /* Allocate the proper pixels */
        /* XXX This is sort of bad, because of contig is set, we force all
         * r + g + b bits to be contiguous.  Should only force contiguity
         * per mask
         */
        ok = AllocPseudo(client, pmap, colors, r + g + b, contig, pixels,
                         &mask, &ppixFirst);

        if (ok == Success) {
            /* now split that mask into three */
            *prmask = *pgmask = *pbmask = 0;
            shift = 1;
            for (i = r; --i >= 0; shift += shift) {
                while (!(mask & shift))
                    shift += shift;
                *prmask |= shift;
            }
            for (i = g; --i >= 0; shift += shift) {
                while (!(mask & shift))
                    shift += shift;
                *pgmask |= shift;
            }
            for (i = b; --i >= 0; shift += shift) {
                while (!(mask & shift))
                    shift += shift;
                *pbmask |= shift;
            }

            /* set up the shared color cells */
            if (!AllocShared(pmap, pixels, colors, r, g, b,
                             *prmask, *pgmask, *pbmask, ppixFirst)) {
                (void) FreeColors(pmap, client, colors, pixels, mask);
                ok = BadAlloc;
            }
        }
    }

    /* if this is the client's first pixels in this colormap, tell the
     * resource manager that the client has pixels in this colormap which
     * should be freed when the client dies */
    if ((ok == Success) && pcr) {
        pcr->mid = pmap->mid;
        pcr->client = client;
        if (!AddResource(FakeClientID(client), RT_CMAPENTRY, (void *) pcr))
            ok = BadAlloc;
    }
    else
        free(pcr);

    return ok;
}

static int
AllocDirect(int client, ColormapPtr pmap, int c, int r, int g, int b,
            Bool contig, Pixel * pixels, Pixel * prmask, Pixel * pgmask,
            Pixel * pbmask)
{
    Pixel *ppixRed, *ppixGreen, *ppixBlue;
    Pixel *ppix, *pDst, *p;
    int npix, npixR, npixG, npixB;
    Bool okR, okG, okB;
    Pixel *rpix = 0, *gpix = 0, *bpix = 0;

    npixR = c << r;
    npixG = c << g;
    npixB = c << b;
    if ((r >= 32) || (g >= 32) || (b >= 32) ||
        (npixR > pmap->freeRed) || (npixR < c) ||
        (npixG > pmap->freeGreen) || (npixG < c) ||
        (npixB > pmap->freeBlue) || (npixB < c))
        return BadAlloc;

    /* start out with empty pixels */
    for (p = pixels; p < pixels + c; p++)
        *p = 0;

    ppixRed = xallocarray(npixR, sizeof(Pixel));
    ppixGreen = xallocarray(npixG, sizeof(Pixel));
    ppixBlue = xallocarray(npixB, sizeof(Pixel));
    if (!ppixRed || !ppixGreen || !ppixBlue) {
        free(ppixBlue);
        free(ppixGreen);
        free(ppixRed);
        return BadAlloc;
    }

    okR = AllocCP(pmap, pmap->red, c, r, contig, ppixRed, prmask);
    okG = AllocCP(pmap, pmap->green, c, g, contig, ppixGreen, pgmask);
    okB = AllocCP(pmap, pmap->blue, c, b, contig, ppixBlue, pbmask);

    if (okR && okG && okB) {
        rpix = reallocarray(pmap->clientPixelsRed[client],
                            pmap->numPixelsRed[client] + (c << r),
                            sizeof(Pixel));
        if (rpix)
            pmap->clientPixelsRed[client] = rpix;
        gpix = reallocarray(pmap->clientPixelsGreen[client],
                            pmap->numPixelsGreen[client] + (c << g),
                            sizeof(Pixel));
        if (gpix)
            pmap->clientPixelsGreen[client] = gpix;
        bpix = reallocarray(pmap->clientPixelsBlue[client],
                            pmap->numPixelsBlue[client] + (c << b),
                            sizeof(Pixel));
        if (bpix)
            pmap->clientPixelsBlue[client] = bpix;
    }

    if (!okR || !okG || !okB || !rpix || !gpix || !bpix) {
        if (okR)
            for (ppix = ppixRed, npix = npixR; --npix >= 0; ppix++)
                pmap->red[*ppix].refcnt = 0;
        if (okG)
            for (ppix = ppixGreen, npix = npixG; --npix >= 0; ppix++)
                pmap->green[*ppix].refcnt = 0;
        if (okB)
            for (ppix = ppixBlue, npix = npixB; --npix >= 0; ppix++)
                pmap->blue[*ppix].refcnt = 0;
        free(ppixBlue);
        free(ppixGreen);
        free(ppixRed);
        return BadAlloc;
    }

    *prmask <<= pmap->pVisual->offsetRed;
    *pgmask <<= pmap->pVisual->offsetGreen;
    *pbmask <<= pmap->pVisual->offsetBlue;

    ppix = rpix + pmap->numPixelsRed[client];
    for (pDst = pixels, p = ppixRed; p < ppixRed + npixR; p++) {
        *ppix++ = *p;
        if (p < ppixRed + c)
            *pDst++ |= *p << pmap->pVisual->offsetRed;
    }
    pmap->numPixelsRed[client] += npixR;
    pmap->freeRed -= npixR;

    ppix = gpix + pmap->numPixelsGreen[client];
    for (pDst = pixels, p = ppixGreen; p < ppixGreen + npixG; p++) {
        *ppix++ = *p;
        if (p < ppixGreen + c)
            *pDst++ |= *p << pmap->pVisual->offsetGreen;
    }
    pmap->numPixelsGreen[client] += npixG;
    pmap->freeGreen -= npixG;

    ppix = bpix + pmap->numPixelsBlue[client];
    for (pDst = pixels, p = ppixBlue; p < ppixBlue + npixB; p++) {
        *ppix++ = *p;
        if (p < ppixBlue + c)
            *pDst++ |= *p << pmap->pVisual->offsetBlue;
    }
    pmap->numPixelsBlue[client] += npixB;
    pmap->freeBlue -= npixB;

    for (pDst = pixels; pDst < pixels + c; pDst++)
        *pDst |= ALPHAMASK(pmap->pVisual);

    free(ppixBlue);
    free(ppixGreen);
    free(ppixRed);

    return Success;
}

static int
AllocPseudo(int client, ColormapPtr pmap, int c, int r, Bool contig,
            Pixel * pixels, Pixel * pmask, Pixel ** pppixFirst)
{
    Pixel *ppix, *p, *pDst, *ppixTemp;
    int npix;
    Bool ok;

    npix = c << r;
    if ((r >= 32) || (npix > pmap->freeRed) || (npix < c))
        return BadAlloc;
    if (!(ppixTemp = xallocarray(npix, sizeof(Pixel))))
        return BadAlloc;
    ok = AllocCP(pmap, pmap->red, c, r, contig, ppixTemp, pmask);

    if (ok) {

        /* all the allocated pixels are added to the client pixel list,
         * but only the unique ones are returned to the client */
        ppix = reallocarray(pmap->clientPixelsRed[client],
                            pmap->numPixelsRed[client] + npix, sizeof(Pixel));
        if (!ppix) {
            for (p = ppixTemp; p < ppixTemp + npix; p++)
                pmap->red[*p].refcnt = 0;
            free(ppixTemp);
            return BadAlloc;
        }
        pmap->clientPixelsRed[client] = ppix;
        ppix += pmap->numPixelsRed[client];
        *pppixFirst = ppix;
        pDst = pixels;
        for (p = ppixTemp; p < ppixTemp + npix; p++) {
            *ppix++ = *p;
            if (p < ppixTemp + c)
                *pDst++ = *p;
        }
        pmap->numPixelsRed[client] += npix;
        pmap->freeRed -= npix;
    }
    free(ppixTemp);
    return ok ? Success : BadAlloc;
}

/* Allocates count << planes pixels from colormap pmap for client. If
 * contig, then the plane mask is made of consecutive bits.  Returns
 * all count << pixels in the array pixels. The first count of those
 * pixels are the unique pixels.  *pMask has the mask to Or with the
 * unique pixels to get the rest of them.
 *
 * Returns True iff all pixels could be allocated
 * All cells allocated will have refcnt set to AllocPrivate and shared to FALSE
 * (see AllocShared for why we care)
 */
static Bool
AllocCP(ColormapPtr pmap, EntryPtr pentFirst, int count, int planes,
        Bool contig, Pixel * pixels, Pixel * pMask)
{
    EntryPtr ent;
    Pixel pixel, base, entries, maxp, save;
    int dplanes, found;
    Pixel *ppix;
    Pixel mask;
    Pixel finalmask;

    dplanes = pmap->pVisual->nplanes;

    /* Easy case.  Allocate pixels only */
    if (planes == 0) {
        /* allocate writable entries */
        ppix = pixels;
        ent = pentFirst;
        pixel = 0;
        while (--count >= 0) {
            /* Just find count unallocated cells */
            while (ent->refcnt) {
                ent++;
                pixel++;
            }
            ent->refcnt = AllocPrivate;
            *ppix++ = pixel;
            ent->fShared = FALSE;
        }
        *pMask = 0;
        return TRUE;
    }
    else if (planes > dplanes) {
        return FALSE;
    }

    /* General case count pixels * 2 ^ planes cells to be allocated */

    /* make room for new pixels */
    ent = pentFirst;

    /* first try for contiguous planes, since it's fastest */
    for (mask = (((Pixel) 1) << planes) - 1, base = 1, dplanes -= (planes - 1);
         --dplanes >= 0; mask += mask, base += base) {
        ppix = pixels;
        found = 0;
        pixel = 0;
        entries = pmap->pVisual->ColormapEntries - mask;
        while (pixel < entries) {
            save = pixel;
            maxp = pixel + mask + base;
            /* check if all are free */
            while (pixel != maxp && ent[pixel].refcnt == 0)
                pixel += base;
            if (pixel == maxp) {
                /* this one works */
                *ppix++ = save;
                found++;
                if (found == count) {
                    /* found enough, allocate them all */
                    while (--count >= 0) {
                        pixel = pixels[count];
                        maxp = pixel + mask;
                        while (1) {
                            ent[pixel].refcnt = AllocPrivate;
                            ent[pixel].fShared = FALSE;
                            if (pixel == maxp)
                                break;
                            pixel += base;
                            *ppix++ = pixel;
                        }
                    }
                    *pMask = mask;
                    return TRUE;
                }
            }
            pixel = save + 1;
            if (pixel & mask)
                pixel += mask;
        }
    }

    dplanes = pmap->pVisual->nplanes;
    if (contig || planes == 1 || dplanes < 3)
        return FALSE;

    /* this will be very slow for large maps, need a better algorithm */

    /*
       we can generate the smallest and largest numbers that fits in dplanes
       bits and contain exactly planes bits set as follows. First, we need to
       check that it is possible to generate such a mask at all.
       (Non-contiguous masks need one more bit than contiguous masks). Then
       the smallest such mask consists of the rightmost planes-1 bits set, then
       a zero, then a one in position planes + 1. The formula is
       (3 << (planes-1)) -1
       The largest such masks consists of the leftmost planes-1 bits set, then
       a zero, then a one bit in position dplanes-planes-1. If dplanes is
       smaller than 32 (the number of bits in a word) then the formula is:
       (1<<dplanes) - (1<<(dplanes-planes+1) + (1<<dplanes-planes-1)
       If dplanes = 32, then we can't calculate (1<<dplanes) and we have
       to use:
       ( (1<<(planes-1)) - 1) << (dplanes-planes+1) + (1<<(dplanes-planes-1))

       << Thank you, Loretta>>>

     */

    finalmask =
        (((((Pixel) 1) << (planes - 1)) - 1) << (dplanes - planes + 1)) +
        (((Pixel) 1) << (dplanes - planes - 1));
    for (mask = (((Pixel) 3) << (planes - 1)) - 1; mask <= finalmask; mask++) {
        /* next 3 magic statements count number of ones (HAKMEM #169) */
        pixel = (mask >> 1) & 033333333333;
        pixel = mask - pixel - ((pixel >> 1) & 033333333333);
        if ((((pixel + (pixel >> 3)) & 030707070707) % 077) != planes)
            continue;
        ppix = pixels;
        found = 0;
        entries = pmap->pVisual->ColormapEntries - mask;
        base = lowbit(mask);
        for (pixel = 0; pixel < entries; pixel++) {
            if (pixel & mask)
                continue;
            maxp = 0;
            /* check if all are free */
            while (ent[pixel + maxp].refcnt == 0) {
                GetNextBitsOrBreak(maxp, mask, base);
            }
            if ((maxp < mask) || (ent[pixel + mask].refcnt != 0))
                continue;
            /* this one works */
            *ppix++ = pixel;
            found++;
            if (found < count)
                continue;
            /* found enough, allocate them all */
            while (--count >= 0) {
                pixel = (pixels)[count];
                maxp = 0;
                while (1) {
                    ent[pixel + maxp].refcnt = AllocPrivate;
                    ent[pixel + maxp].fShared = FALSE;
                    GetNextBitsOrBreak(maxp, mask, base);
                    *ppix++ = pixel + maxp;
                }
            }

            *pMask = mask;
            return TRUE;
        }
    }
    return FALSE;
}

/**
 *
 *  \param ppixFirst  First of the client's new pixels
 */
static Bool
AllocShared(ColormapPtr pmap, Pixel * ppix, int c, int r, int g, int b,
            Pixel rmask, Pixel gmask, Pixel bmask, Pixel * ppixFirst)
{
    Pixel *pptr, *cptr;
    int npix, z, npixClientNew, npixShared;
    Pixel basemask, base, bits, common;
    SHAREDCOLOR *pshared, **ppshared, **psharedList;

    npixClientNew = c << (r + g + b);
    npixShared = (c << r) + (c << g) + (c << b);
    psharedList = xallocarray(npixShared, sizeof(SHAREDCOLOR *));
    if (!psharedList)
        return FALSE;
    ppshared = psharedList;
    for (z = npixShared; --z >= 0;) {
        if (!(ppshared[z] = malloc(sizeof(SHAREDCOLOR)))) {
            for (z++; z < npixShared; z++)
                free(ppshared[z]);
            free(psharedList);
            return FALSE;
        }
    }
    for (pptr = ppix, npix = c; --npix >= 0; pptr++) {
        basemask = ~(gmask | bmask);
        common = *pptr & basemask;
        if (rmask) {
            bits = 0;
            base = lowbit(rmask);
            while (1) {
                pshared = *ppshared++;
                pshared->refcnt = 1 << (g + b);
                for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++) {
                    if ((*cptr & basemask) == (common | bits)) {
                        pmap->red[*cptr].fShared = TRUE;
                        pmap->red[*cptr].co.shco.red = pshared;
                    }
                }
                GetNextBitsOrBreak(bits, rmask, base);
            }
        }
        else {
            pshared = *ppshared++;
            pshared->refcnt = 1 << (g + b);
            for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++) {
                if ((*cptr & basemask) == common) {
                    pmap->red[*cptr].fShared = TRUE;
                    pmap->red[*cptr].co.shco.red = pshared;
                }
            }
        }
        basemask = ~(rmask | bmask);
        common = *pptr & basemask;
        if (gmask) {
            bits = 0;
            base = lowbit(gmask);
            while (1) {
                pshared = *ppshared++;
                pshared->refcnt = 1 << (r + b);
                for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++) {
                    if ((*cptr & basemask) == (common | bits)) {
                        pmap->red[*cptr].co.shco.green = pshared;
                    }
                }
                GetNextBitsOrBreak(bits, gmask, base);
            }
        }
        else {
            pshared = *ppshared++;
            pshared->refcnt = 1 << (g + b);
            for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++) {
                if ((*cptr & basemask) == common) {
                    pmap->red[*cptr].co.shco.green = pshared;
                }
            }
        }
        basemask = ~(rmask | gmask);
        common = *pptr & basemask;
        if (bmask) {
            bits = 0;
            base = lowbit(bmask);
            while (1) {
                pshared = *ppshared++;
                pshared->refcnt = 1 << (r + g);
                for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++) {
                    if ((*cptr & basemask) == (common | bits)) {
                        pmap->red[*cptr].co.shco.blue = pshared;
                    }
                }
                GetNextBitsOrBreak(bits, bmask, base);
            }
        }
        else {
            pshared = *ppshared++;
            pshared->refcnt = 1 << (g + b);
            for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++) {
                if ((*cptr & basemask) == common) {
                    pmap->red[*cptr].co.shco.blue = pshared;
                }
            }
        }
    }
    free(psharedList);
    return TRUE;
}

/** FreeColors
 * Free colors and/or cells (probably slow for large numbers)
 */
int
FreeColors(ColormapPtr pmap, int client, int count, Pixel * pixels, Pixel mask)
{
    int rval, result, class;
    Pixel rmask;

    class = pmap->class;
    if (pmap->flags & AllAllocated)
        return BadAccess;
    if ((class | DynamicClass) == DirectColor) {
        rmask = mask & RGBMASK(pmap->pVisual);
        result = FreeCo(pmap, client, REDMAP, count, pixels,
                        mask & pmap->pVisual->redMask);
        /* If any of the three calls fails, we must report that, if more
         * than one fails, it's ok that we report the last one */
        rval = FreeCo(pmap, client, GREENMAP, count, pixels,
                      mask & pmap->pVisual->greenMask);
        if (rval != Success)
            result = rval;
        rval = FreeCo(pmap, client, BLUEMAP, count, pixels,
                      mask & pmap->pVisual->blueMask);
        if (rval != Success)
            result = rval;
    }
    else {
        rmask = mask & ((((Pixel) 1) << pmap->pVisual->nplanes) - 1);
        result = FreeCo(pmap, client, PSEUDOMAP, count, pixels, rmask);
    }
    if ((mask != rmask) && count) {
        clients[client]->errorValue = *pixels | mask;
        result = BadValue;
    }
    /* XXX should worry about removing any RT_CMAPENTRY resource */
    return result;
}

/**
 * Helper for FreeColors -- frees all combinations of *newpixels and mask bits
 * which the client has allocated in channel colormap cells of pmap.
 * doesn't change newpixels if it doesn't need to
 *
 *  \param pmap   which colormap head
 *  \param color  which sub-map, eg, RED, BLUE, PSEUDO
 *  \param npixIn number of pixels passed in
 *  \param ppixIn number of base pixels
 *  \param mask   mask client gave us
 */
static int
FreeCo(ColormapPtr pmap, int client, int color, int npixIn, Pixel * ppixIn,
       Pixel mask)
{
    Pixel *ppixClient, pixTest;
    int npixClient, npixNew, npix;
    Pixel bits, base, cmask, rgbbad;
    Pixel *pptr, *cptr;
    int n, zapped;
    int errVal = Success;
    int offset, numents;

    if (npixIn == 0)
        return errVal;
    bits = 0;
    zapped = 0;
    base = lowbit(mask);

    switch (color) {
    case REDMAP:
        cmask = pmap->pVisual->redMask;
        rgbbad = ~RGBMASK(pmap->pVisual);
        offset = pmap->pVisual->offsetRed;
        numents = (cmask >> offset) + 1;
        ppixClient = pmap->clientPixelsRed[client];
        npixClient = pmap->numPixelsRed[client];
        break;
    case GREENMAP:
        cmask = pmap->pVisual->greenMask;
        rgbbad = ~RGBMASK(pmap->pVisual);
        offset = pmap->pVisual->offsetGreen;
        numents = (cmask >> offset) + 1;
        ppixClient = pmap->clientPixelsGreen[client];
        npixClient = pmap->numPixelsGreen[client];
        break;
    case BLUEMAP:
        cmask = pmap->pVisual->blueMask;
        rgbbad = ~RGBMASK(pmap->pVisual);
        offset = pmap->pVisual->offsetBlue;
        numents = (cmask >> offset) + 1;
        ppixClient = pmap->clientPixelsBlue[client];
        npixClient = pmap->numPixelsBlue[client];
        break;
    default:        /* so compiler can see that everything gets initialized */
    case PSEUDOMAP:
        cmask = ~((Pixel) 0);
        rgbbad = 0;
        offset = 0;
        numents = pmap->pVisual->ColormapEntries;
        ppixClient = pmap->clientPixelsRed[client];
        npixClient = pmap->numPixelsRed[client];
        break;
    }

    /* zap all pixels which match */
    while (1) {
        /* go through pixel list */
        for (pptr = ppixIn, n = npixIn; --n >= 0; pptr++) {
            pixTest = ((*pptr | bits) & cmask) >> offset;
            if ((pixTest >= numents) || (*pptr & rgbbad)) {
                clients[client]->errorValue = *pptr | bits;
                errVal = BadValue;
                continue;
            }

            /* find match in client list */
            for (cptr = ppixClient, npix = npixClient;
                 --npix >= 0 && *cptr != pixTest; cptr++);

            if (npix >= 0) {
                if (pmap->class & DynamicClass) {
                    FreeCell(pmap, pixTest, color);
                }
                *cptr = ~((Pixel) 0);
                zapped++;
            }
            else
                errVal = BadAccess;
        }
        /* generate next bits value */
        GetNextBitsOrBreak(bits, mask, base);
    }

    /* delete freed pixels from client pixel list */
    if (zapped) {
        npixNew = npixClient - zapped;
        if (npixNew) {
            /* Since the list can only get smaller, we can do a copy in
             * place and then realloc to a smaller size */
            pptr = cptr = ppixClient;

            /* If we have all the new pixels, we don't have to examine the
             * rest of the old ones */
            for (npix = 0; npix < npixNew; cptr++) {
                if (*cptr != ~((Pixel) 0)) {
                    *pptr++ = *cptr;
                    npix++;
                }
            }
            pptr = reallocarray(ppixClient, npixNew, sizeof(Pixel));
            if (pptr)
                ppixClient = pptr;
            npixClient = npixNew;
        }
        else {
            npixClient = 0;
            free(ppixClient);
            ppixClient = (Pixel *) NULL;
        }
        switch (color) {
        case PSEUDOMAP:
        case REDMAP:
            pmap->clientPixelsRed[client] = ppixClient;
            pmap->numPixelsRed[client] = npixClient;
            break;
        case GREENMAP:
            pmap->clientPixelsGreen[client] = ppixClient;
            pmap->numPixelsGreen[client] = npixClient;
            break;
        case BLUEMAP:
            pmap->clientPixelsBlue[client] = ppixClient;
            pmap->numPixelsBlue[client] = npixClient;
            break;
        }
    }
    return errVal;
}

/* Redefine color values */
int
StoreColors(ColormapPtr pmap, int count, xColorItem * defs, ClientPtr client)
{
    Pixel pix;
    xColorItem *pdef;
    EntryPtr pent, pentT, pentLast;
    VisualPtr pVisual;
    SHAREDCOLOR *pred, *pgreen, *pblue;
    int n, ChgRed, ChgGreen, ChgBlue, idef;
    int class, errVal = Success;
    int ok;

    class = pmap->class;
    if (!(class & DynamicClass) && !(pmap->flags & BeingCreated)) {
        return BadAccess;
    }
    pVisual = pmap->pVisual;

    idef = 0;
    if ((class | DynamicClass) == DirectColor) {
        int numred, numgreen, numblue;
        Pixel rgbbad;

        numred = NUMRED(pVisual);
        numgreen = NUMGREEN(pVisual);
        numblue = NUMBLUE(pVisual);
        rgbbad = ~RGBMASK(pVisual);
        for (pdef = defs, n = 0; n < count; pdef++, n++) {
            ok = TRUE;
            (*pmap->pScreen->ResolveColor)
                (&pdef->red, &pdef->green, &pdef->blue, pmap->pVisual);

            if (pdef->pixel & rgbbad) {
                errVal = BadValue;
                client->errorValue = pdef->pixel;
                continue;
            }
            pix = (pdef->pixel & pVisual->redMask) >> pVisual->offsetRed;
            if (pix >= numred) {
                errVal = BadValue;
                ok = FALSE;
            }
            else if (pmap->red[pix].refcnt != AllocPrivate) {
                errVal = BadAccess;
                ok = FALSE;
            }
            else if (pdef->flags & DoRed) {
                pmap->red[pix].co.local.red = pdef->red;
            }
            else {
                pdef->red = pmap->red[pix].co.local.red;
            }

            pix = (pdef->pixel & pVisual->greenMask) >> pVisual->offsetGreen;
            if (pix >= numgreen) {
                errVal = BadValue;
                ok = FALSE;
            }
            else if (pmap->green[pix].refcnt != AllocPrivate) {
                errVal = BadAccess;
                ok = FALSE;
            }
            else if (pdef->flags & DoGreen) {
                pmap->green[pix].co.local.green = pdef->green;
            }
            else {
                pdef->green = pmap->green[pix].co.local.green;
            }

            pix = (pdef->pixel & pVisual->blueMask) >> pVisual->offsetBlue;
            if (pix >= numblue) {
                errVal = BadValue;
                ok = FALSE;
            }
            else if (pmap->blue[pix].refcnt != AllocPrivate) {
                errVal = BadAccess;
                ok = FALSE;
            }
            else if (pdef->flags & DoBlue) {
                pmap->blue[pix].co.local.blue = pdef->blue;
            }
            else {
                pdef->blue = pmap->blue[pix].co.local.blue;
            }
            /* If this is an o.k. entry, then it gets added to the list
             * to be sent to the hardware.  If not, skip it.  Once we've
             * skipped one, we have to copy all the others.
             */
            if (ok) {
                if (idef != n)
                    defs[idef] = defs[n];
                idef++;
            }
            else
                client->errorValue = pdef->pixel;
        }
    }
    else {
        for (pdef = defs, n = 0; n < count; pdef++, n++) {

            ok = TRUE;
            if (pdef->pixel >= pVisual->ColormapEntries) {
                client->errorValue = pdef->pixel;
                errVal = BadValue;
                ok = FALSE;
            }
            else if (pmap->red[pdef->pixel].refcnt != AllocPrivate) {
                errVal = BadAccess;
                ok = FALSE;
            }

            /* If this is an o.k. entry, then it gets added to the list
             * to be sent to the hardware.  If not, skip it.  Once we've
             * skipped one, we have to copy all the others.
             */
            if (ok) {
                if (idef != n)
                    defs[idef] = defs[n];
                idef++;
            }
            else
                continue;

            (*pmap->pScreen->ResolveColor)
                (&pdef->red, &pdef->green, &pdef->blue, pmap->pVisual);

            pent = &pmap->red[pdef->pixel];

            if (pdef->flags & DoRed) {
                if (pent->fShared) {
                    pent->co.shco.red->color = pdef->red;
                    if (pent->co.shco.red->refcnt > 1)
                        ok = FALSE;
                }
                else
                    pent->co.local.red = pdef->red;
            }
            else {
                if (pent->fShared)
                    pdef->red = pent->co.shco.red->color;
                else
                    pdef->red = pent->co.local.red;
            }
            if (pdef->flags & DoGreen) {
                if (pent->fShared) {
                    pent->co.shco.green->color = pdef->green;
                    if (pent->co.shco.green->refcnt > 1)
                        ok = FALSE;
                }
                else
                    pent->co.local.green = pdef->green;
            }
            else {
                if (pent->fShared)
                    pdef->green = pent->co.shco.green->color;
                else
                    pdef->green = pent->co.local.green;
            }
            if (pdef->flags & DoBlue) {
                if (pent->fShared) {
                    pent->co.shco.blue->color = pdef->blue;
                    if (pent->co.shco.blue->refcnt > 1)
                        ok = FALSE;
                }
                else
                    pent->co.local.blue = pdef->blue;
            }
            else {
                if (pent->fShared)
                    pdef->blue = pent->co.shco.blue->color;
                else
                    pdef->blue = pent->co.local.blue;
            }

            if (!ok) {
                /* have to run through the colormap and change anybody who
                 * shares this value */
                pred = pent->co.shco.red;
                pgreen = pent->co.shco.green;
                pblue = pent->co.shco.blue;
                ChgRed = pdef->flags & DoRed;
                ChgGreen = pdef->flags & DoGreen;
                ChgBlue = pdef->flags & DoBlue;
                pentLast = pmap->red + pVisual->ColormapEntries;

                for (pentT = pmap->red; pentT < pentLast; pentT++) {
                    if (pentT->fShared && (pentT != pent)) {
                        xColorItem defChg;

                        /* There are, alas, devices in this world too dumb
                         * to read their own hardware colormaps.  Sick, but
                         * true.  So we're going to be really nice and load
                         * the xColorItem with the proper value for all the
                         * fields.  We will only set the flags for those
                         * fields that actually change.  Smart devices can
                         * arrange to change only those fields.  Dumb devices
                         * can rest assured that we have provided for them,
                         * and can change all three fields */

                        defChg.flags = 0;
                        if (ChgRed && pentT->co.shco.red == pred) {
                            defChg.flags |= DoRed;
                        }
                        if (ChgGreen && pentT->co.shco.green == pgreen) {
                            defChg.flags |= DoGreen;
                        }
                        if (ChgBlue && pentT->co.shco.blue == pblue) {
                            defChg.flags |= DoBlue;
                        }
                        if (defChg.flags != 0) {
                            defChg.pixel = pentT - pmap->red;
                            defChg.red = pentT->co.shco.red->color;
                            defChg.green = pentT->co.shco.green->color;
                            defChg.blue = pentT->co.shco.blue->color;
                            (*pmap->pScreen->StoreColors) (pmap, 1, &defChg);
                        }
                    }
                }

            }
        }
    }
    /* Note that we use idef, the count of acceptable entries, and not
     * count, the count of proposed entries */
    if (idef != 0)
        (*pmap->pScreen->StoreColors) (pmap, idef, defs);
    return errVal;
}

int
IsMapInstalled(Colormap map, WindowPtr pWin)
{
    Colormap *pmaps;
    int imap, nummaps, found;

    pmaps = xallocarray(pWin->drawable.pScreen->maxInstalledCmaps,
                        sizeof(Colormap));
    if (!pmaps)
        return FALSE;
    nummaps = (*pWin->drawable.pScreen->ListInstalledColormaps)
        (pWin->drawable.pScreen, pmaps);
    found = FALSE;
    for (imap = 0; imap < nummaps; imap++) {
        if (pmaps[imap] == map) {
            found = TRUE;
            break;
        }
    }
    free(pmaps);
    return found;
}

struct colormap_lookup_data {
    ScreenPtr pScreen;
    VisualPtr visuals;
};

static void
_colormap_find_resource(void *value, XID id, void *cdata)
{
    struct colormap_lookup_data *cmap_data = cdata;
    VisualPtr visuals = cmap_data->visuals;
    ScreenPtr pScreen = cmap_data->pScreen;
    ColormapPtr cmap = value;
    int j;

    if (pScreen != cmap->pScreen)
        return;

    j = cmap->pVisual - pScreen->visuals;
    cmap->pVisual = &visuals[j];
}

/* something has realloced the visuals, instead of breaking
   ABI fix it up here - glx and compsite did this wrong */
Bool
ResizeVisualArray(ScreenPtr pScreen, int new_visual_count, DepthPtr depth)
{
    struct colormap_lookup_data cdata;
    int numVisuals;
    VisualPtr visuals;
    XID *vids, vid;
    int first_new_vid, first_new_visual, i;

    first_new_vid = depth->numVids;
    first_new_visual = pScreen->numVisuals;

    vids = reallocarray(depth->vids, depth->numVids + new_visual_count,
                        sizeof(XID));
    if (!vids)
        return FALSE;

    /* its realloced now no going back if we fail the next one */
    depth->vids = vids;

    numVisuals = pScreen->numVisuals + new_visual_count;
    visuals = reallocarray(pScreen->visuals, numVisuals, sizeof(VisualRec));
    if (!visuals) {
        return FALSE;
    }

    cdata.visuals = visuals;
    cdata.pScreen = pScreen;
    FindClientResourcesByType(serverClient, RT_COLORMAP,
                              _colormap_find_resource, &cdata);

    pScreen->visuals = visuals;

    for (i = 0; i < new_visual_count; i++) {
        vid = FakeClientID(0);
        pScreen->visuals[first_new_visual + i].vid = vid;
        vids[first_new_vid + i] = vid;
    }

    depth->numVids += new_visual_count;
    pScreen->numVisuals += new_visual_count;

    return TRUE;
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d67 3
d255 1
a255 1
        (MAXCLIENTS * sizeof(Pixel *)) + (MAXCLIENTS * sizeof(int));
d280 1
a280 1
                                  (MAXCLIENTS * sizeof(Pixel *)));
d292 2
a293 2
    memset((char *) pmap->numPixelsRed, 0, MAXCLIENTS * sizeof(int));
    for (pptr = &pmap->clientPixelsRed[MAXCLIENTS];
d302 1
a302 1
        ppix = malloc(size * sizeof(Pixel));
d316 1
a316 1
                                  (MAXCLIENTS * sizeof(int)));
d319 1
a319 1
                                        (MAXCLIENTS * sizeof(Pixel *)));
d322 1
a322 1
                                 (MAXCLIENTS * sizeof(int)));
d325 1
a325 1
                                       (MAXCLIENTS * sizeof(Pixel *)));
d331 1
a331 1
                (char *) pmap->clientPixelsRed, MAXCLIENTS * sizeof(Pixel *));
d333 3
a335 3
                (char *) pmap->clientPixelsRed, MAXCLIENTS * sizeof(Pixel *));
        memset((char *) pmap->numPixelsGreen, 0, MAXCLIENTS * sizeof(int));
        memset((char *) pmap->numPixelsBlue, 0, MAXCLIENTS * sizeof(int));
d343 1
a343 1
            ppix = malloc(size * sizeof(Pixel));
d358 1
a358 1
            ppix = malloc(size * sizeof(Pixel));
d419 1
a419 1
        for (i = 0; i < MAXCLIENTS; i++)
d437 1
a437 1
        for (i = 0; i < MAXCLIENTS; i++) {
d708 1
a708 1
    defs = malloc(size * sizeof(xColorItem));
d754 167
d965 2
a966 2
        ppix = (Pixel *) realloc(pmap->clientPixelsRed[client],
                                 (npix + 1) * sizeof(Pixel));
d987 2
a988 2
        ppix = (Pixel *) realloc(pmap->clientPixelsRed[client],
                                 (npix + 1) * sizeof(Pixel));
d994 2
a995 2
        ppix = (Pixel *) realloc(pmap->clientPixelsGreen[client],
                                 (npix + 1) * sizeof(Pixel));
d1001 2
a1002 2
        ppix = (Pixel *) realloc(pmap->clientPixelsBlue[client],
                                 (npix + 1) * sizeof(Pixel));
a1309 167
/* Tries to find a color in pmap that exactly matches the one requested in prgb
 * if it can't it allocates one.
 * Starts looking at pentFirst + *pPixel, so if you want a specific pixel,
 * load *pPixel with that value, otherwise set it to 0
 */
int
FindColor(ColormapPtr pmap, EntryPtr pentFirst, int size, xrgb * prgb,
          Pixel * pPixel, int channel, int client, ColorCompareProcPtr comp)
{
    EntryPtr pent;
    Bool foundFree;
    Pixel pixel, Free = 0;
    int npix, count, *nump = NULL;
    Pixel **pixp = NULL, *ppix;
    xColorItem def;

    foundFree = FALSE;

    if ((pixel = *pPixel) >= size)
        pixel = 0;
    /* see if there is a match, and also look for a free entry */
    for (pent = pentFirst + pixel, count = size; --count >= 0;) {
        if (pent->refcnt > 0) {
            if ((*comp) (pent, prgb)) {
                if (client >= 0)
                    pent->refcnt++;
                *pPixel = pixel;
                switch (channel) {
                case REDMAP:
                    *pPixel <<= pmap->pVisual->offsetRed;
                case PSEUDOMAP:
                    break;
                case GREENMAP:
                    *pPixel <<= pmap->pVisual->offsetGreen;
                    break;
                case BLUEMAP:
                    *pPixel <<= pmap->pVisual->offsetBlue;
                    break;
                }
                goto gotit;
            }
        }
        else if (!foundFree && pent->refcnt == 0) {
            Free = pixel;
            foundFree = TRUE;
            /* If we're initializing the colormap, then we are looking for
             * the first free cell we can find, not to minimize the number
             * of entries we use.  So don't look any further. */
            if (pmap->flags & BeingCreated)
                break;
        }
        pixel++;
        if (pixel >= size) {
            pent = pentFirst;
            pixel = 0;
        }
        else
            pent++;
    }

    /* If we got here, we didn't find a match.  If we also didn't find
     * a free entry, we're out of luck.  Otherwise, we'll usurp a free
     * entry and fill it in */
    if (!foundFree)
        return BadAlloc;
    pent = pentFirst + Free;
    pent->fShared = FALSE;
    pent->refcnt = (client >= 0) ? 1 : AllocTemporary;

    switch (channel) {
    case PSEUDOMAP:
        pent->co.local.red = prgb->red;
        pent->co.local.green = prgb->green;
        pent->co.local.blue = prgb->blue;
        def.red = prgb->red;
        def.green = prgb->green;
        def.blue = prgb->blue;
        def.flags = (DoRed | DoGreen | DoBlue);
        if (client >= 0)
            pmap->freeRed--;
        def.pixel = Free;
        break;

    case REDMAP:
        pent->co.local.red = prgb->red;
        def.red = prgb->red;
        def.green = pmap->green[0].co.local.green;
        def.blue = pmap->blue[0].co.local.blue;
        def.flags = DoRed;
        if (client >= 0)
            pmap->freeRed--;
        def.pixel = Free << pmap->pVisual->offsetRed;
        break;

    case GREENMAP:
        pent->co.local.green = prgb->green;
        def.red = pmap->red[0].co.local.red;
        def.green = prgb->green;
        def.blue = pmap->blue[0].co.local.blue;
        def.flags = DoGreen;
        if (client >= 0)
            pmap->freeGreen--;
        def.pixel = Free << pmap->pVisual->offsetGreen;
        break;

    case BLUEMAP:
        pent->co.local.blue = prgb->blue;
        def.red = pmap->red[0].co.local.red;
        def.green = pmap->green[0].co.local.green;
        def.blue = prgb->blue;
        def.flags = DoBlue;
        if (client >= 0)
            pmap->freeBlue--;
        def.pixel = Free << pmap->pVisual->offsetBlue;
        break;
    }
    (*pmap->pScreen->StoreColors) (pmap, 1, &def);
    pixel = Free;
    *pPixel = def.pixel;

 gotit:
    if (pmap->flags & BeingCreated || client == -1)
        return Success;
    /* Now remember the pixel, for freeing later */
    switch (channel) {
    case PSEUDOMAP:
    case REDMAP:
        nump = pmap->numPixelsRed;
        pixp = pmap->clientPixelsRed;
        break;

    case GREENMAP:
        nump = pmap->numPixelsGreen;
        pixp = pmap->clientPixelsGreen;
        break;

    case BLUEMAP:
        nump = pmap->numPixelsBlue;
        pixp = pmap->clientPixelsBlue;
        break;
    }
    npix = nump[client];
    ppix = (Pixel *) realloc(pixp[client], (npix + 1) * sizeof(Pixel));
    if (!ppix) {
        pent->refcnt--;
        if (!pent->fShared)
            switch (channel) {
            case PSEUDOMAP:
            case REDMAP:
                pmap->freeRed++;
                break;
            case GREENMAP:
                pmap->freeGreen++;
                break;
            case BLUEMAP:
                pmap->freeBlue++;
                break;
            }
        return BadAlloc;
    }
    ppix[npix] = pixel;
    pixp[client] = ppix;
    nump[client]++;

    return Success;
}

d1653 3
a1655 3
    ppixRed = malloc(npixR * sizeof(Pixel));
    ppixGreen = malloc(npixG * sizeof(Pixel));
    ppixBlue = malloc(npixB * sizeof(Pixel));
d1668 3
a1670 3
        rpix = (Pixel *) realloc(pmap->clientPixelsRed[client],
                                 (pmap->numPixelsRed[client] + (c << r)) *
                                 sizeof(Pixel));
d1673 3
a1675 3
        gpix = (Pixel *) realloc(pmap->clientPixelsGreen[client],
                                 (pmap->numPixelsGreen[client] + (c << g)) *
                                 sizeof(Pixel));
d1678 3
a1680 3
        bpix = (Pixel *) realloc(pmap->clientPixelsBlue[client],
                                 (pmap->numPixelsBlue[client] + (c << b)) *
                                 sizeof(Pixel));
d1753 1
a1753 1
    if (!(ppixTemp = malloc(npix * sizeof(Pixel))))
d1761 2
a1762 3
        ppix = (Pixel *) realloc(pmap->clientPixelsRed[client],
                                 (pmap->numPixelsRed[client] +
                                  npix) * sizeof(Pixel));
d1965 1
a1965 1
    psharedList = malloc(npixShared * sizeof(SHAREDCOLOR *));
d2209 1
a2209 1
            pptr = (Pixel *) realloc(ppixClient, npixNew * sizeof(Pixel));
d2474 2
a2475 2
    pmaps =
        malloc(pWin->drawable.pScreen->maxInstalledCmaps * sizeof(Colormap));
d2526 2
a2527 2
    vids =
        realloc(depth->vids, (depth->numVids + new_visual_count) * sizeof(XID));
d2535 1
a2535 1
    visuals = realloc(pScreen->visuals, numVisuals * sizeof(VisualRec));
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
d184 1
a184 1
/* GetNextBitsOrBreak(bits, mask, base)  -- 
d188 1
a188 1
 * while loop 
d200 1
a200 1
 * 00010 (see this isn't so hard), 
d204 1
a204 1
 *      then we add 0010 to get 
d228 3
a230 3
/** 
 * Create and initialize the color map 
 * 
d373 1
a373 1
    /*  
d1459 1
a1459 1
/** 
d1577 1
a1577 1
         * per mask 
d1789 1
a1789 1
 * Returns True iff all pixels could be allocated 
d2059 1
a2059 1
 * Free colors and/or cells (probably slow for large numbers) 
d2100 1
a2100 1
 * doesn't change newpixels if it doesn't need to 
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d370 1
a370 1
    if (!AddResource(mid, RT_COLORMAP, (pointer) pmap))
d400 1
a400 1
FreeColormap(pointer value, XID mid)
d408 1
a408 1
        WalkTree(pmap->pScreen, (VisitWindowProcPtr) TellNoMap, (pointer) &mid);
d477 1
a477 1
TellLostMap(WindowPtr pwin, pointer value)
d502 1
a502 1
TellGainedMap(WindowPtr pwin, pointer value)
d848 1
a848 1
            dixLookupResourceByType((pointer *) &prootmap,
d866 1
a866 1
            dixLookupResourceByType((pointer *) &prootmap,
d920 1
a920 1
        if (!AddResource(FakeClientID(client), RT_CMAPENTRY, (pointer) pcr))
d1466 1
a1466 1
FreeClientPixels(pointer value, XID fakeid)
d1468 1
a1468 1
    pointer pmap;
d1535 1
a1535 1
        if (!AddResource(FakeClientID(client), RT_CMAPENTRY, (pointer) pcr))
d1617 1
a1617 1
        if (!AddResource(FakeClientID(client), RT_CMAPENTRY, (pointer) pcr))
d2495 1
a2495 1
_colormap_find_resource(pointer value, XID id, pointer cdata)
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a452 2
    xEvent xE;

d455 6
a461 4
        xE.u.colormap.window = pwin->drawable.id;
        xE.u.colormap.colormap = None;
        xE.u.colormap.new = TRUE;
        xE.u.colormap.state = ColormapUninstalled;
a479 1
    xEvent xE;
d487 6
a493 4
        xE.u.colormap.window = pwin->drawable.id;
        xE.u.colormap.colormap = *pmid;
        xE.u.colormap.new = FALSE;
        xE.u.colormap.state = ColormapUninstalled;
a504 1
    xEvent xE;
d512 6
a518 4
        xE.u.colormap.window = pwin->drawable.id;
        xE.u.colormap.colormap = *pmid;
        xE.u.colormap.new = FALSE;
        xE.u.colormap.state = ColormapInstalled;
d581 1
a581 1
    default:                   /* so compiler can see that everything gets initialized */
d658 1
a658 1
    default:                   /* so compiler can see that everything gets initialized */
d661 1
a661 1
        pent = (EntryPtr) & pmap->red[i];
d665 1
a665 1
        pent = (EntryPtr) & pmap->green[i];
d669 1
a669 1
        pent = (EntryPtr) & pmap->blue[i];
d1403 1
a1403 1
                pent = (EntryPtr) & pmap->red[pixel];
d2151 1
a2151 1
    default:                   /* so compiler can see that everything gets initialized */
@


1.5
log
@Update to xserver 1.11.2
@
text
@a24 1

a46 1

d67 104
a170 120
static Pixel FindBestPixel(
    EntryPtr /*pentFirst*/,
    int /*size*/,
    xrgb * /*prgb*/,
    int /*channel*/
);

static int AllComp(
    EntryPtr /*pent*/,
    xrgb * /*prgb*/
);

static int RedComp(
    EntryPtr /*pent*/,
    xrgb * /*prgb*/
);

static int GreenComp(
    EntryPtr /*pent*/,
    xrgb * /*prgb*/
);

static int BlueComp(
    EntryPtr /*pent*/,
    xrgb * /*prgb*/
);

static void FreePixels(
    ColormapPtr /*pmap*/,
    int /*client*/
);

static void CopyFree(
    int /*channel*/,
    int /*client*/,
    ColormapPtr /*pmapSrc*/,
    ColormapPtr /*pmapDst*/
);

static void FreeCell(
    ColormapPtr /*pmap*/,
    Pixel /*i*/,
    int /*channel*/
);

static void UpdateColors(
    ColormapPtr /*pmap*/
);

static int AllocDirect(
    int /*client*/,
    ColormapPtr /*pmap*/,
    int /*c*/,
    int /*r*/,
    int /*g*/,
    int /*b*/,
    Bool /*contig*/,
    Pixel * /*pixels*/,
    Pixel * /*prmask*/,
    Pixel * /*pgmask*/,
    Pixel * /*pbmask*/
);

static int AllocPseudo(
    int /*client*/,
    ColormapPtr /*pmap*/,
    int /*c*/,
    int /*r*/,
    Bool /*contig*/,
    Pixel * /*pixels*/,
    Pixel * /*pmask*/,
    Pixel ** /*pppixFirst*/
);

static Bool AllocCP(
    ColormapPtr /*pmap*/,
    EntryPtr /*pentFirst*/,
    int /*count*/,
    int /*planes*/,
    Bool /*contig*/,
    Pixel * /*pixels*/,
    Pixel * /*pMask*/
);

static Bool AllocShared(
    ColormapPtr /*pmap*/,
    Pixel * /*ppix*/,
    int /*c*/,
    int /*r*/,
    int /*g*/,
    int /*b*/,
    Pixel /*rmask*/,
    Pixel /*gmask*/,
    Pixel /*bmask*/,
    Pixel * /*ppixFirst*/
);

static int FreeCo(
    ColormapPtr /*pmap*/,
    int /*client*/,
    int /*color*/,
    int /*npixIn*/,
    Pixel * /*ppixIn*/,
    Pixel /*mask*/
);

static int   TellNoMap(
    WindowPtr	/*pwin*/,
    Colormap 	* /*pmid*/
);

static void FindColorInRootCmap (
    ColormapPtr	/* pmap */,
    EntryPtr	/* pentFirst */,
    int		/* size */,
    xrgb*	/* prgb */,
    Pixel*	/* pPixel */,
    int		/* channel */,
    ColorCompareProcPtr /* comp */
);
d212 1
a212 1
		(bits) += ((bits) & ~(mask));	
d216 3
a218 4
typedef struct _colorResource
{
	Colormap	mid;
	int		client;
a227 1

d235 2
a236 2
CreateColormap (Colormap mid, ScreenPtr pScreen, VisualPtr pVisual, 
                ColormapPtr *ppcmap, int alloc, int client)
d238 1
a238 1
    int		class, size;
d240 4
a243 4
    ColormapPtr	pmap;
    EntryPtr	pent;
    int		i;
    Pixel	*ppix, **pptr;
d246 3
a248 2
    if(!(class & DynamicClass) && (alloc != AllocNone) && (client != SERVER_ID))
	return BadMatch;
d252 1
a252 2
		(MAXCLIENTS * sizeof(Pixel *)) +
		(MAXCLIENTS * sizeof(int));
d254 1
a254 1
	sizebytes *= 3;
d257 17
a273 21
	pmap = malloc(sizebytes);
	if (!pmap)
	    return BadAlloc;
	if (!dixAllocatePrivates(&pmap->devPrivates, PRIVATE_COLORMAP)) {
	    free (pmap);
	    return BadAlloc;
	}
    } else {
	pmap = _dixAllocateObjectWithPrivates(sizebytes, sizebytes,
					      offsetof(ColormapRec, devPrivates), PRIVATE_COLORMAP);
	if (!pmap)
	    return BadAlloc;
    }
#if defined(_XSERVER64)
    pmap->pad0 = 0;
    pmap->pad1 = 0;
#if (X_BYTE_ORDER == X_LITTLE_ENDIAN)
    pmap->pad2 = 0;
#endif
#endif
    pmap->red = (EntryPtr)((char *)pmap + sizeof(ColormapRec));    
d275 3
a277 3
    pmap->clientPixelsRed = (Pixel **)((char *)pmap->red + sizebytes);
    pmap->numPixelsRed = (int *)((char *)pmap->clientPixelsRed +
				 (MAXCLIENTS * sizeof(Pixel *)));
d279 3
a281 3
    pmap->flags = 0; 	/* start out with all flags clear */
    if(mid == pScreen->defColormap)
	pmap->flags |= IsDefault;
d286 1
a286 1
	size = NUMRED(pVisual);
d288 1
a288 1
    memset((char *) pmap->red, 0, (int)sizebytes);
d290 18
a307 19
    for (pptr = &pmap->clientPixelsRed[MAXCLIENTS]; --pptr >= pmap->clientPixelsRed; )
	*pptr = (Pixel *)NULL;
    if (alloc == AllocAll)
    {
	if (class & DynamicClass)
	    pmap->flags |= AllAllocated;
	for (pent = &pmap->red[size - 1]; pent >= pmap->red; pent--)
	    pent->refcnt = AllocPrivate;
	pmap->freeRed = 0;
	ppix = malloc(size * sizeof(Pixel));
	if (!ppix)
	{
	    free(pmap);
	    return BadAlloc;
	}
	pmap->clientPixelsRed[client] = ppix;
	for(i = 0; i < size; i++)
	    ppix[i] = i;
	pmap->numPixelsRed[client] = size;
d310 57
a366 63
    if ((class | DynamicClass) == DirectColor)
    {
	pmap->freeGreen = NUMGREEN(pVisual);
	pmap->green = (EntryPtr)((char *)pmap->numPixelsRed +
				 (MAXCLIENTS * sizeof(int)));
	pmap->clientPixelsGreen = (Pixel **)((char *)pmap->green + sizebytes);
	pmap->numPixelsGreen = (int *)((char *)pmap->clientPixelsGreen +
				       (MAXCLIENTS * sizeof(Pixel *)));
	pmap->freeBlue = NUMBLUE(pVisual);
	pmap->blue = (EntryPtr)((char *)pmap->numPixelsGreen +
				(MAXCLIENTS * sizeof(int)));
	pmap->clientPixelsBlue = (Pixel **)((char *)pmap->blue + sizebytes);
	pmap->numPixelsBlue = (int *)((char *)pmap->clientPixelsBlue +
				      (MAXCLIENTS * sizeof(Pixel *)));

	memset((char *) pmap->green, 0, (int)sizebytes);
	memset((char *) pmap->blue, 0, (int)sizebytes);

	memmove((char *) pmap->clientPixelsGreen,
		(char *) pmap->clientPixelsRed,
	      MAXCLIENTS * sizeof(Pixel *));
	memmove((char *) pmap->clientPixelsBlue,
		(char *) pmap->clientPixelsRed,
	      MAXCLIENTS * sizeof(Pixel *));
	memset((char *) pmap->numPixelsGreen, 0, MAXCLIENTS * sizeof(int));
	memset((char *) pmap->numPixelsBlue, 0, MAXCLIENTS * sizeof(int));

	/* If every cell is allocated, mark its refcnt */
	if (alloc == AllocAll)
	{
	    size = pmap->freeGreen;
	    for(pent = &pmap->green[size-1]; pent >= pmap->green; pent--)
		pent->refcnt = AllocPrivate;
	    pmap->freeGreen = 0;
	    ppix = malloc(size * sizeof(Pixel));
	    if (!ppix)
	    {
		free(pmap->clientPixelsRed[client]);
		free(pmap);
		return BadAlloc;
	    }
	    pmap->clientPixelsGreen[client] = ppix;
	    for(i = 0; i < size; i++)
		ppix[i] = i;
	    pmap->numPixelsGreen[client] = size;

	    size = pmap->freeBlue;
	    for(pent = &pmap->blue[size-1]; pent >= pmap->blue; pent--)
		pent->refcnt = AllocPrivate;
	    pmap->freeBlue = 0;
	    ppix = malloc(size * sizeof(Pixel));
	    if (!ppix)
	    {
		free(pmap->clientPixelsGreen[client]);
		free(pmap->clientPixelsRed[client]);
		free(pmap);
		return BadAlloc;
	    }
	    pmap->clientPixelsBlue[client] = ppix;
	    for(i = 0; i < size; i++)
		ppix[i] = i;
	    pmap->numPixelsBlue[client] = size;
	}
d370 2
a371 2
    if (!AddResource(mid, RT_COLORMAP, (pointer)pmap))
	return BadAlloc;
d377 1
a377 1
		 pmap, RT_NONE, NULL, DixCreateAccess);
d379 2
a380 2
	FreeResource(mid, RT_NONE);
	return i;
d386 3
a388 4
    if (!(*pScreen->CreateColormap)(pmap))
    {
	FreeResource (mid, RT_NONE);
	return BadAlloc;
d400 1
a400 1
FreeColormap (pointer value, XID mid)
d402 1
a402 1
    int	i;
d404 1
a404 1
    ColormapPtr	pmap = (ColormapPtr)value;
d406 1
a406 2
    if(CLIENT_ID(mid) != SERVER_ID)
    {
d408 1
a408 1
        WalkTree(pmap->pScreen, (VisitWindowProcPtr)TellNoMap, (pointer) &mid);
d413 1
a413 1
    (*pmap->pScreen->DestroyColormap)(pmap);
d415 20
a434 27
    if(pmap->clientPixelsRed)
    {
	for(i = 0; i < MAXCLIENTS; i++)
	    free(pmap->clientPixelsRed[i]);
    }

    if ((pmap->class == PseudoColor) || (pmap->class == GrayScale))
    {
	for(pent = &pmap->red[pmap->pVisual->ColormapEntries - 1];
	    pent >= pmap->red;
	    pent--)
	{
	    if(pent->fShared)
	    {
		if (--pent->co.shco.red->refcnt == 0)
		    free(pent->co.shco.red);
		if (--pent->co.shco.green->refcnt == 0)
		    free(pent->co.shco.green);
		if (--pent->co.shco.blue->refcnt == 0)
		    free(pent->co.shco.blue);
	    }
	}
    }
    if((pmap->class | DynamicClass) == DirectColor)
    {
        for(i = 0; i < MAXCLIENTS; i++)
	{
d441 5
a445 4
	dixFreePrivates(pmap->devPrivates, PRIVATE_COLORMAP);
	free(pmap);
    } else
	dixFreeObjectWithPrivates(pmap, PRIVATE_COLORMAP);
d451 1
a451 1
TellNoMap (WindowPtr pwin, Colormap *pmid)
d453 1
a453 1
    xEvent 	xE;
d455 7
a461 8
    if (wColormap(pwin) == *pmid)
    {
	/* This should be call to DeliverEvent */
	xE.u.u.type = ColormapNotify;
	xE.u.colormap.window = pwin->drawable.id;
	xE.u.colormap.colormap = None;
	xE.u.colormap.new = TRUE;
	xE.u.colormap.state = ColormapUninstalled;
d463 1
a463 1
        if(noPanoramiXExtension || !pwin->drawable.pScreen->myNum)
d465 5
a469 5
	   DeliverEvents(pwin, &xE, 1, (WindowPtr)NULL);
	if (pwin->optional) {
	    pwin->optional->colormap = None;
	    CheckWindowOptionalNeed (pwin);
	}
d477 1
a477 1
TellLostMap (WindowPtr pwin, pointer value)
d479 2
a480 2
    Colormap 	*pmid = (Colormap *)value;
    xEvent 	xE;
d483 2
a484 2
    if(!noPanoramiXExtension && pwin->drawable.pScreen->myNum)
	return WT_STOPWALKING;
d486 8
a493 9
    if (wColormap(pwin) == *pmid)
    {
	/* This should be call to DeliverEvent */
	xE.u.u.type = ColormapNotify;
	xE.u.colormap.window = pwin->drawable.id;
	xE.u.colormap.colormap = *pmid;
	xE.u.colormap.new = FALSE;
	xE.u.colormap.state = ColormapUninstalled;
	DeliverEvents(pwin, &xE, 1, (WindowPtr)NULL);
d501 1
a501 1
TellGainedMap (WindowPtr pwin, pointer value)
d503 2
a504 2
    Colormap 	*pmid = (Colormap *)value;
    xEvent 	xE;
d507 2
a508 2
    if(!noPanoramiXExtension && pwin->drawable.pScreen->myNum)
	return WT_STOPWALKING;
d510 8
a517 9
    if (wColormap (pwin) == *pmid)
    {
	/* This should be call to DeliverEvent */
	xE.u.u.type = ColormapNotify;
	xE.u.colormap.window = pwin->drawable.id;
	xE.u.colormap.colormap = *pmid;
	xE.u.colormap.new = FALSE;
	xE.u.colormap.state = ColormapInstalled;
	DeliverEvents(pwin, &xE, 1, (WindowPtr)NULL);
a522 1
  
d524 1
a524 1
CopyColormapAndFree (Colormap mid, ColormapPtr pSrc, int client)
d526 5
a530 5
    ColormapPtr	pmap = (ColormapPtr) NULL;
    int		result, alloc, size;
    Colormap	midSrc;
    ScreenPtr	pScreen;
    VisualPtr	pVisual;
d536 1
a536 1
            AllocAll : AllocNone;
d540 2
a541 2
    result = CreateColormap (mid, pScreen, pVisual, &pmap, alloc, client);
    if(result != Success)
d543 12
a554 12
    if(alloc == AllocAll)
    {
	memmove((char *)pmap->red, (char *)pSrc->red, size * sizeof(Entry));
	if((pmap->class | DynamicClass) == DirectColor)
	{
	    memmove((char *)pmap->green, (char *)pSrc->green, size * sizeof(Entry));
	    memmove((char *)pmap->blue, (char *)pSrc->blue, size * sizeof(Entry));
	}
	pSrc->flags &= ~AllAllocated;
	FreePixels(pSrc, client);
	UpdateColors(pmap);
	return Success;
d558 3
a560 4
    if ((pmap->class | DynamicClass) == DirectColor)
    {
	CopyFree(GREENMAP, client, pSrc, pmap);
	CopyFree(BLUEMAP, client, pSrc, pmap);
d563 1
a563 1
	UpdateColors(pmap);
d570 1
a570 1
CopyFree (int channel, int client, ColormapPtr pmapSrc, ColormapPtr pmapDst)
d572 26
a597 27
    int		z, npix;
    EntryPtr	pentSrcFirst, pentDstFirst;
    EntryPtr	pentSrc, pentDst;
    Pixel	*ppix;
    int		nalloc;

    switch(channel)
    {
      default:	/* so compiler can see that everything gets initialized */
      case REDMAP:
	ppix = (pmapSrc->clientPixelsRed)[client];
	npix = (pmapSrc->numPixelsRed)[client];
	pentSrcFirst = pmapSrc->red;
	pentDstFirst = pmapDst->red;
	break;
      case GREENMAP:
	ppix = (pmapSrc->clientPixelsGreen)[client];
	npix = (pmapSrc->numPixelsGreen)[client];
	pentSrcFirst = pmapSrc->green;
	pentDstFirst = pmapDst->green;
	break;
      case BLUEMAP:
	ppix = (pmapSrc->clientPixelsBlue)[client];
	npix = (pmapSrc->numPixelsBlue)[client];
	pentSrcFirst = pmapSrc->blue;
	pentDstFirst = pmapDst->blue;
	break;
d600 18
a617 22
    if (pmapSrc->class & DynamicClass)
    {
	for(z = npix; --z >= 0; ppix++)
	{
	    /* Copy entries */
	    pentSrc = pentSrcFirst + *ppix;
	    pentDst = pentDstFirst + *ppix;
	    if (pentDst->refcnt > 0)
	    {
		pentDst->refcnt++;
	    }
	    else
	    {
		*pentDst = *pentSrc;
		nalloc++;
		if (pentSrc->refcnt > 0)
		    pentDst->refcnt = 1;
		else
		    pentSrc->fShared = FALSE;
	    }
	    FreeCell(pmapSrc, *ppix, channel);
	}
d621 2
a622 3
    switch(channel)
    {
      case REDMAP:
d624 1
a624 2
        (pmapDst->clientPixelsRed)[client] =
	    (pmapSrc->clientPixelsRed)[client];
d628 2
a629 2
	break;
      case GREENMAP:
d632 1
a632 1
	    (pmapSrc->clientPixelsGreen)[client];
d636 2
a637 2
	break;
      case BLUEMAP:
d643 1
a643 1
	break;
d650 1
a650 1
FreeCell (ColormapPtr pmap, Pixel i, int channel)
d653 1
a653 1
    int	*pCount;
d655 15
a669 17

    switch (channel)
    {
      default:	/* so compiler can see that everything gets initialized */
      case PSEUDOMAP:
      case REDMAP:
          pent = (EntryPtr) &pmap->red[i];
	  pCount = &pmap->freeRed;
	  break;
      case GREENMAP:
          pent = (EntryPtr) &pmap->green[i];
	  pCount = &pmap->freeGreen;
	  break;
      case BLUEMAP:
          pent = (EntryPtr) &pmap->blue[i];
	  pCount = &pmap->freeBlue;
	  break;
d674 2
a675 3
	pent->refcnt--;
    else
    {
d678 11
a688 12
        if (pent->fShared)
	{
	    if(--pent->co.shco.red->refcnt == 0)
		free(pent->co.shco.red);
	    if(--pent->co.shco.green->refcnt == 0)
		free(pent->co.shco.green);
	    if(--pent->co.shco.blue->refcnt == 0)
		free(pent->co.shco.blue);
	    pent->fShared = FALSE;
	}
	pent->refcnt = 0;
	*pCount += 1;
d693 1
a693 1
UpdateColors (ColormapPtr pmap)
d695 1
a695 1
    xColorItem		*defs;
d697 3
a699 3
    EntryPtr 	pent;
    VisualPtr	pVisual;
    int			i, n, size;
d705 1
a705 1
	return;
d708 15
a722 18
    if (pmap->class == DirectColor)
    {
        for (i = 0; i < size; i++)
	{
	    if (!pmap->red[i].refcnt &&
		!pmap->green[i].refcnt &&
		!pmap->blue[i].refcnt)
		continue;
	    pdef->pixel = ((Pixel)i << pVisual->offsetRed) |
			  ((Pixel)i << pVisual->offsetGreen) |
			  ((Pixel)i << pVisual->offsetBlue);
	    pdef->red = pmap->red[i].co.local.red;
	    pdef->green = pmap->green[i].co.local.green;
	    pdef->blue = pmap->blue[i].co.local.blue;
	    pdef->flags = DoRed|DoGreen|DoBlue;
	    pdef++;
	    n++;
	}
d724 19
a742 23
    else
    {
        for (i = 0, pent = pmap->red; i < size; i++, pent++)
	{
	    if (!pent->refcnt)
		continue;
	    pdef->pixel = i;
	    if(pent->fShared)
	    {
		pdef->red = pent->co.shco.red->color;
		pdef->green = pent->co.shco.green->color;
		pdef->blue = pent->co.shco.blue->color;
	    }
	    else
	    {
		pdef->red = pent->co.local.red;
		pdef->green = pent->co.local.green;
		pdef->blue = pent->co.local.blue;
	    }
	    pdef->flags = DoRed|DoGreen|DoBlue;
	    pdef++;
	    n++;
	}
d745 1
a745 1
	(*pmap->pScreen->StoreColors)(pmap, n, defs);
d753 11
a763 11
AllocColor (ColormapPtr pmap, 
            unsigned short *pred, unsigned short *pgreen, unsigned short *pblue, 
            Pixel *pPix, int client)
{
    Pixel	pixR, pixG, pixB;
    int		entries;
    xrgb	rgb;
    int		class;
    VisualPtr	pVisual;
    int		npix;
    Pixel	*ppix;
d777 2
a778 2
    if(pmap->flags & BeingCreated)
	class |= DynamicClass;
d787 14
a800 14
	/* Look up all three components in the same pmap */
	*pPix = pixR = FindBestPixel(pmap->red, entries, &rgb, PSEUDOMAP);
	*pred = pmap->red[pixR].co.local.red;
	*pgreen = pmap->red[pixR].co.local.green;
	*pblue = pmap->red[pixR].co.local.blue;
	npix = pmap->numPixelsRed[client];
	ppix = (Pixel *) realloc(pmap->clientPixelsRed[client],
				  (npix + 1) * sizeof(Pixel));
	if (!ppix)
	    return BadAlloc;
	ppix[npix] = pixR;
	pmap->clientPixelsRed[client] = ppix;
	pmap->numPixelsRed[client]++;
	break;
d803 36
a838 37
	/* Look up each component in its own map, then OR them together */
	pixR = FindBestPixel(pmap->red, NUMRED(pVisual), &rgb, REDMAP);
	pixG = FindBestPixel(pmap->green, NUMGREEN(pVisual), &rgb, GREENMAP);
	pixB = FindBestPixel(pmap->blue, NUMBLUE(pVisual), &rgb, BLUEMAP);
	*pPix = (pixR << pVisual->offsetRed) |
		(pixG << pVisual->offsetGreen) |
		(pixB << pVisual->offsetBlue) |
		ALPHAMASK(pVisual);
	
	*pred = pmap->red[pixR].co.local.red;
	*pgreen = pmap->green[pixG].co.local.green;
	*pblue = pmap->blue[pixB].co.local.blue;
	npix = pmap->numPixelsRed[client];
	ppix = (Pixel *) realloc(pmap->clientPixelsRed[client],
				  (npix + 1) * sizeof(Pixel));
	if (!ppix)
	    return BadAlloc;
	ppix[npix] = pixR;
	pmap->clientPixelsRed[client] = ppix;
	npix = pmap->numPixelsGreen[client];
	ppix = (Pixel *) realloc(pmap->clientPixelsGreen[client],
				  (npix + 1) * sizeof(Pixel));
	if (!ppix)
	    return BadAlloc;
	ppix[npix] = pixG;
	pmap->clientPixelsGreen[client] = ppix;
	npix = pmap->numPixelsBlue[client];
	ppix = (Pixel *) realloc(pmap->clientPixelsBlue[client],
				  (npix + 1) * sizeof(Pixel));
	if (!ppix)
	    return BadAlloc;
	ppix[npix] = pixB;
	pmap->clientPixelsBlue[client] = ppix;
	pmap->numPixelsRed[client]++;
	pmap->numPixelsGreen[client]++;
	pmap->numPixelsBlue[client]++;
	break;
d842 15
a856 14
	if (pmap->mid != pmap->pScreen->defColormap &&
	    pmap->pVisual->vid == pmap->pScreen->rootVisual)
	{
	    ColormapPtr prootmap;
	    dixLookupResourceByType((pointer *)&prootmap, pmap->pScreen->defColormap,
				    RT_COLORMAP, clients[client], DixReadAccess);

	    if (pmap->class == prootmap->class)
		FindColorInRootCmap (prootmap, prootmap->red, entries, &rgb, 
			pPix, PSEUDOMAP, AllComp);
	}
	if (FindColor(pmap, pmap->red, entries, &rgb, pPix, PSEUDOMAP,
		      client, AllComp) != Success)
	    return BadAlloc;
d860 40
a899 42
	if (pmap->mid != pmap->pScreen->defColormap &&
	    pmap->pVisual->vid == pmap->pScreen->rootVisual)
	{
	    ColormapPtr prootmap;
	    dixLookupResourceByType((pointer *)&prootmap, pmap->pScreen->defColormap,
				    RT_COLORMAP, clients[client], DixReadAccess);

	    if (pmap->class == prootmap->class)
	    {
		pixR = (*pPix & pVisual->redMask) >> pVisual->offsetRed; 
		FindColorInRootCmap (prootmap, prootmap->red, entries, &rgb, 
			&pixR, REDMAP, RedComp);
		pixG = (*pPix & pVisual->greenMask) >> pVisual->offsetGreen; 
		FindColorInRootCmap (prootmap, prootmap->green, entries, &rgb, 
			&pixG, GREENMAP, GreenComp);
		pixB = (*pPix & pVisual->blueMask) >> pVisual->offsetBlue; 
		FindColorInRootCmap (prootmap, prootmap->blue, entries, &rgb, 
			&pixB, BLUEMAP, BlueComp);
		*pPix = pixR | pixG | pixB;
	    }
	}

	pixR = (*pPix & pVisual->redMask) >> pVisual->offsetRed; 
	if (FindColor(pmap, pmap->red, NUMRED(pVisual), &rgb, &pixR, REDMAP,
		      client, RedComp) != Success)
	    return BadAlloc;
	pixG = (*pPix & pVisual->greenMask) >> pVisual->offsetGreen; 
	if (FindColor(pmap, pmap->green, NUMGREEN(pVisual), &rgb, &pixG,
		      GREENMAP, client, GreenComp) != Success)
	{
	    (void)FreeCo(pmap, client, REDMAP, 1, &pixR, (Pixel)0);
	    return BadAlloc;
	}
	pixB = (*pPix & pVisual->blueMask) >> pVisual->offsetBlue; 
	if (FindColor(pmap, pmap->blue, NUMBLUE(pVisual), &rgb, &pixB, BLUEMAP,
		      client, BlueComp) != Success)
	{
	    (void)FreeCo(pmap, client, GREENMAP, 1, &pixG, (Pixel)0);
	    (void)FreeCo(pmap, client, REDMAP, 1, &pixR, (Pixel)0);
	    return BadAlloc;
	}
	*pPix = pixR | pixG | pixB | ALPHAMASK(pVisual);
d901 1
a901 1
	break;
d908 12
a919 15
	(CLIENT_ID(pmap->mid) != client) &&
	!(pmap->flags & BeingCreated))
    {
	colorResource	*pcr;

	pcr = malloc(sizeof(colorResource));
	if (!pcr)
	{
	    (void)FreeColors(pmap, client, 1, pPix, (Pixel)0);
	    return BadAlloc;
	}
	pcr->mid = pmap->mid;
	pcr->client = client;
	if (!AddResource(FakeClientID(client), RT_CMAPENTRY, (pointer)pcr))
	    return BadAlloc;
d933 1
a933 1
FakeAllocColor (ColormapPtr pmap, xColorItem *item)
d937 1
a937 1
    int	entries;
d939 1
a939 1
    int	class;
d953 8
a960 8
	temp = 0;
	item->pixel = 0;
	if (FindColor(pmap, pmap->red, entries, &rgb, &temp, PSEUDOMAP,
		      -1, AllComp) == Success) {
	    item->pixel = temp;
	    break;
	}
	/* fall through ... */
d963 2
a964 2
	item->pixel = FindBestPixel(pmap->red, entries, &rgb, PSEUDOMAP);
	break;
d967 18
a984 18
	/* Look up each component in its own map, then OR them together */
	pixR = (item->pixel & pVisual->redMask) >> pVisual->offsetRed; 
	pixG = (item->pixel & pVisual->greenMask) >> pVisual->offsetGreen; 
	pixB = (item->pixel & pVisual->blueMask) >> pVisual->offsetBlue; 
	if (FindColor(pmap, pmap->red, NUMRED(pVisual), &rgb, &pixR, REDMAP,
		      -1, RedComp) != Success)
	    pixR = FindBestPixel(pmap->red, NUMRED(pVisual), &rgb, REDMAP)
			<< pVisual->offsetRed;
	if (FindColor(pmap, pmap->green, NUMGREEN(pVisual), &rgb, &pixG,
		      GREENMAP, -1, GreenComp) != Success)
	    pixG = FindBestPixel(pmap->green, NUMGREEN(pVisual), &rgb,
				 GREENMAP) << pVisual->offsetGreen;
	if (FindColor(pmap, pmap->blue, NUMBLUE(pVisual), &rgb, &pixB, BLUEMAP,
		      -1, BlueComp) != Success)
	    pixB = FindBestPixel(pmap->blue, NUMBLUE(pVisual), &rgb, BLUEMAP)
			<< pVisual->offsetBlue;
	item->pixel = pixR | pixG | pixB;
	break;
d987 7
a993 8
	/* Look up each component in its own map, then OR them together */
	pixR = FindBestPixel(pmap->red, NUMRED(pVisual), &rgb, REDMAP);
	pixG = FindBestPixel(pmap->green, NUMGREEN(pVisual), &rgb, GREENMAP);
	pixB = FindBestPixel(pmap->blue, NUMBLUE(pVisual), &rgb, BLUEMAP);
	item->pixel = (pixR << pVisual->offsetRed) |
		      (pixG << pVisual->offsetGreen) |
		      (pixB << pVisual->offsetBlue);
	break;
d1007 3
a1009 3
	if (pmap->red[pixel].refcnt == AllocTemporary)
	    pmap->red[pixel].refcnt = 0;
	break;
d1011 11
a1021 11
	pVisual = pmap->pVisual;
	pixR = (pixel & pVisual->redMask) >> pVisual->offsetRed; 
	pixG = (pixel & pVisual->greenMask) >> pVisual->offsetGreen; 
	pixB = (pixel & pVisual->blueMask) >> pVisual->offsetBlue; 
	if (pmap->red[pixR].refcnt == AllocTemporary)
	    pmap->red[pixR].refcnt = 0;
	if (pmap->green[pixG].refcnt == AllocTemporary)
	    pmap->green[pixG].refcnt = 0;
	if (pmap->blue[pixB].refcnt == AllocTemporary)
	    pmap->blue[pixB].refcnt = 0;
	break;
d1025 2
a1026 2
typedef unsigned short	BigNumUpper;
typedef unsigned long	BigNumLower;
d1036 2
a1037 2
    BigNumUpper	upper;
    BigNumLower	lower;
d1050 1
a1050 1
BigNumAdd (BigNumPtr x, BigNumPtr y, BigNumPtr r)
d1052 1
a1052 1
    BigNumLower	lower, carry = 0;
d1056 2
a1057 2
	lower -= BIGNUMLOWER;
	carry = 1;
d1064 1
a1064 1
FindBestPixel(EntryPtr pentFirst, int size, xrgb *prgb, int channel)
d1066 5
a1070 5
    EntryPtr	pent;
    Pixel	pixel, final;
    long	dr, dg, db;
    unsigned long   sq;
    BigNumRec	minval, sum, temp;
d1075 28
a1102 31
    for (pent = pentFirst, pixel = 0; pixel < size; pent++, pixel++)
    {
	dr = dg = db = 0;
	switch(channel)
	{
	  case PSEUDOMAP:
	      dg = (long) pent->co.local.green - prgb->green;
	      db = (long) pent->co.local.blue - prgb->blue;
	  case REDMAP:
	      dr = (long) pent->co.local.red - prgb->red;
	      break;
	  case GREENMAP:
	      dg = (long) pent->co.local.green - prgb->green;
	      break;
	  case BLUEMAP:
	      db = (long) pent->co.local.blue - prgb->blue;
	      break;
	}
	sq = dr * dr;
	UnsignedToBigNum (sq, &sum);
	sq = dg * dg;
	UnsignedToBigNum (sq, &temp);
	BigNumAdd (&sum, &temp, &sum);
	sq = db * db;
	UnsignedToBigNum (sq, &temp);
	BigNumAdd (&sum, &temp, &sum);
	if (BigNumGreater (&minval, &sum))
	{
	    final = pixel;
	    minval = sum;
	}
d1108 7
a1114 7
FindColorInRootCmap (ColormapPtr pmap, EntryPtr pentFirst, int size, 
                     xrgb *prgb, Pixel *pPixel, int channel, 
                     ColorCompareProcPtr comp)
{
    EntryPtr    pent;
    Pixel	pixel;
    int         count;
d1117 18
a1134 21
	pixel = 0;
    for (pent = pentFirst + pixel, count = size; --count >= 0; pent++, pixel++)
    {
	if (pent->refcnt > 0 && (*comp) (pent, prgb))
	{
	    switch (channel)
	    {
	    case REDMAP:
		pixel <<= pmap->pVisual->offsetRed;
		break;
	    case GREENMAP:
		pixel <<= pmap->pVisual->offsetGreen;
		break;
	    case BLUEMAP:
		pixel <<= pmap->pVisual->offsetBlue;
		break;
	    default: /* PSEUDOMAP */
		break;
	    }
	    *pPixel = pixel;
	}
d1144 9
a1152 10
FindColor (ColormapPtr pmap, EntryPtr pentFirst, int size, xrgb *prgb, 
           Pixel *pPixel, int channel, int client, 
           ColorCompareProcPtr comp)
{
    EntryPtr	pent;
    Bool	foundFree;
    Pixel	pixel, Free = 0;
    int		npix, count, *nump = NULL;
    Pixel	**pixp = NULL, *ppix;
    xColorItem	def;
d1156 2
a1157 2
    if((pixel = *pPixel) >= size)
	pixel = 0;
d1159 37
a1195 43
    for (pent = pentFirst + pixel, count = size; --count >= 0; )
    {
        if (pent->refcnt > 0)
	{
    	    if ((*comp) (pent, prgb))
	    {
		if (client >= 0)
		    pent->refcnt++;
		*pPixel = pixel;
		switch(channel)
		{
		  case REDMAP:
		    *pPixel <<= pmap->pVisual->offsetRed;
		  case PSEUDOMAP:
		    break;
		  case GREENMAP:
		    *pPixel <<= pmap->pVisual->offsetGreen;
		    break;
		  case BLUEMAP:
		    *pPixel <<= pmap->pVisual->offsetBlue;
		    break;
		}
		goto gotit;
    	    }
        }
	else if (!foundFree && pent->refcnt == 0)
	{
	    Free = pixel;
	    foundFree = TRUE;
	    /* If we're initializing the colormap, then we are looking for
	     * the first free cell we can find, not to minimize the number
	     * of entries we use.  So don't look any further. */
	    if(pmap->flags & BeingCreated)
		break;
	}
	pixel++;
	if(pixel >= size)
	{
	    pent = pentFirst;
	    pixel = 0;
	}
	else
	    pent++;
d1202 1
a1202 1
	return BadAlloc;
d1207 2
a1208 3
    switch (channel)
    {
      case PSEUDOMAP:
d1213 7
a1219 7
	def.green = prgb->green;
	def.blue = prgb->blue;
	def.flags = (DoRed|DoGreen|DoBlue);
	if (client >= 0)
	    pmap->freeRed--;
	def.pixel = Free;
	break;
d1221 1
a1221 1
      case REDMAP:
d1224 11
a1234 11
	def.green = pmap->green[0].co.local.green;
	def.blue = pmap->blue[0].co.local.blue;
	def.flags = DoRed;
	if (client >= 0)
	    pmap->freeRed--;
	def.pixel = Free << pmap->pVisual->offsetRed;
	break;

      case GREENMAP:
	pent->co.local.green = prgb->green;
	def.red = pmap->red[0].co.local.red;
d1236 17
a1252 17
	def.blue = pmap->blue[0].co.local.blue;
	def.flags = DoGreen;
	if (client >= 0)
	    pmap->freeGreen--;
	def.pixel = Free << pmap->pVisual->offsetGreen;
	break;

      case BLUEMAP:
	pent->co.local.blue = prgb->blue;
	def.red = pmap->red[0].co.local.red;
	def.green = pmap->green[0].co.local.green;
	def.blue = prgb->blue;
	def.flags = DoBlue;
	if (client >= 0)
	    pmap->freeBlue--;
	def.pixel = Free << pmap->pVisual->offsetBlue;
	break;
d1255 1
a1255 1
    pixel = Free;	
d1258 1
a1258 1
gotit:
d1260 1
a1260 1
	return Success;
d1262 16
a1277 17
    switch (channel)
    {
      case PSEUDOMAP:
      case REDMAP:
	nump = pmap->numPixelsRed;
	pixp = pmap->clientPixelsRed;
	break;

      case GREENMAP:
	nump = pmap->numPixelsGreen;
	pixp = pmap->clientPixelsGreen;
	break;

      case BLUEMAP:
	nump = pmap->numPixelsBlue;
	pixp = pmap->clientPixelsBlue;
	break;
d1281 16
a1296 18
    if (!ppix)
    {
	pent->refcnt--;
	if (!pent->fShared)
	    switch (channel)
	    {
	      case PSEUDOMAP:
	      case REDMAP:
		pmap->freeRed++;
		break;
	      case GREENMAP:
		pmap->freeGreen++;
		break;
	      case BLUEMAP:
		pmap->freeBlue++;
		break;
	    }
	return BadAlloc;
d1308 1
a1308 1
AllComp (EntryPtr pent, xrgb *prgb)
d1310 4
a1313 4
    if((pent->co.local.red == prgb->red) &&
       (pent->co.local.green == prgb->green) &&
       (pent->co.local.blue == prgb->blue) )
       return 1;
d1318 1
a1318 1
RedComp (EntryPtr pent, xrgb *prgb)
d1320 2
a1321 2
    if (pent->co.local.red == prgb->red) 
	return 1;
d1326 1
a1326 1
GreenComp (EntryPtr pent, xrgb *prgb)
d1328 2
a1329 2
    if (pent->co.local.green == prgb->green) 
	return 1;
d1334 1
a1334 1
BlueComp (EntryPtr pent, xrgb *prgb)
d1336 2
a1337 2
    if (pent->co.local.blue == prgb->blue) 
	return 1;
a1340 1

d1344 2
a1345 1
QueryColors (ColormapPtr pmap, int count, Pixel *ppixIn, xrgb *prgbList, ClientPtr client)
d1347 6
a1352 6
    Pixel	*ppix, pixel;
    xrgb	*prgb;
    VisualPtr	pVisual;
    EntryPtr	pent;
    Pixel	i;
    int		errVal = Success;
d1355 37
a1391 42
    if ((pmap->class | DynamicClass) == DirectColor)
    {
	int numred, numgreen, numblue;
	Pixel rgbbad;

	numred = NUMRED(pVisual);
	numgreen = NUMGREEN(pVisual);
	numblue = NUMBLUE(pVisual);
	rgbbad = ~RGBMASK(pVisual);
	for( ppix = ppixIn, prgb = prgbList; --count >= 0; ppix++, prgb++)
	{
	    pixel = *ppix;
	    if (pixel & rgbbad) {
		client->errorValue = pixel;
		errVal =  BadValue;
		continue;
	    }
	    i  = (pixel & pVisual->redMask) >> pVisual->offsetRed;
	    if (i >= numred)
	    {
		client->errorValue = pixel;
		errVal =  BadValue;
		continue;
	    }
	    prgb->red = pmap->red[i].co.local.red;
	    i  = (pixel & pVisual->greenMask) >> pVisual->offsetGreen;
	    if (i >= numgreen)
	    {
		client->errorValue = pixel;
		errVal =  BadValue;
		continue;
	    }
	    prgb->green = pmap->green[i].co.local.green;
	    i  = (pixel & pVisual->blueMask) >> pVisual->offsetBlue;
	    if (i >= numblue)
	    {
		client->errorValue = pixel;
		errVal =  BadValue;
		continue;
	    }
	    prgb->blue = pmap->blue[i].co.local.blue;
	}
d1393 21
a1413 27
    else
    {
	for( ppix = ppixIn, prgb = prgbList; --count >= 0; ppix++, prgb++)
	{
	    pixel = *ppix;
	    if (pixel >= pVisual->ColormapEntries)
	    {
		client->errorValue = pixel;
		errVal = BadValue;
	    }
	    else
	    {
		pent = (EntryPtr)&pmap->red[pixel];
		if (pent->fShared)
		{
		    prgb->red = pent->co.shco.red->color;
		    prgb->green = pent->co.shco.green->color;
		    prgb->blue = pent->co.shco.blue->color;
		}
		else
		{
		    prgb->red = pent->co.local.red;
		    prgb->green = pent->co.local.green;
		    prgb->blue = pent->co.local.blue;
		}
	    }
	}
d1423 1
a1423 1
    int	class;
d1427 6
a1432 8
    if (class & DynamicClass)
    {
	n = pmap->numPixelsRed[client];
	for (ppix = ppixStart; --n >= 0; )
	{
	    FreeCell(pmap, *ppix, REDMAP);
	    ppix++;
	}
d1438 1
a1438 2
    if ((class | DynamicClass) == DirectColor) 
    {
d1440 6
a1445 6
	if (class & DynamicClass)
	    for (ppix = ppixStart, n = pmap->numPixelsGreen[client]; --n >= 0;)
		FreeCell(pmap, *ppix++, GREENMAP);
	free(ppixStart);
	pmap->clientPixelsGreen[client] = (Pixel *) NULL;
	pmap->numPixelsGreen[client] = 0;
d1448 6
a1453 6
	if (class & DynamicClass)
	    for (ppix = ppixStart, n = pmap->numPixelsBlue[client]; --n >= 0; )
		FreeCell(pmap, *ppix++, BLUEMAP);
	free(ppixStart);
	pmap->clientPixelsBlue[client] = (Pixel *) NULL;
	pmap->numPixelsBlue[client] = 0;
d1464 1
a1464 1
FreeClientPixels (pointer value, XID fakeid)
d1471 1
a1471 1
				 DixRemoveAccess);
d1473 1
a1473 1
	FreePixels((ColormapPtr)pmap, pcr->client);
d1479 2
a1480 2
AllocColorCells (int client, ColormapPtr pmap, int colors, int planes, 
                 Bool contig, Pixel *ppix, Pixel *masks)
d1482 5
a1486 5
    Pixel	rmask, gmask, bmask, *ppixFirst, r, g, b;
    int		n, class;
    int		ok;
    int		oldcount;
    colorResource *pcr = (colorResource *)NULL;
d1490 1
a1490 1
	return BadAlloc; /* Shouldn't try on this type */
d1493 21
a1513 6
	oldcount += pmap->numPixelsGreen[client] + pmap->numPixelsBlue[client];
    if (!oldcount && (CLIENT_ID(pmap->mid) != client))
    {
	pcr = malloc(sizeof(colorResource));
	if (!pcr)
	    return BadAlloc;
d1515 10
a1524 32

    if (pmap->class == DirectColor)
    {
        ok = AllocDirect (client, pmap, colors, planes, planes, planes,
			  contig, ppix, &rmask, &gmask, &bmask);
	if(ok == Success)
	{
	    for (r = g = b = 1, n = planes; --n >= 0; r += r, g += g, b += b)
	    {
		while(!(rmask & r))
		    r += r;
		while(!(gmask & g))
		    g += g;
		while(!(bmask & b))
		    b += b;
		*masks++ = r | g | b;
	    }
	}
    }
    else
    {
        ok = AllocPseudo (client, pmap, colors, planes, contig, ppix, &rmask,
			  &ppixFirst);
	if(ok == Success)
	{
	    for (r = 1, n = planes; --n >= 0; r += r)
	    {
		while(!(rmask & r))
		    r += r;
		*masks++ = r;
	    }
	}
d1530 8
a1537 7
    if ((ok == Success) && pcr)
    {
	pcr->mid = pmap->mid;
	pcr->client = client;
	if (!AddResource(FakeClientID(client), RT_CMAPENTRY, (pointer)pcr))
	    ok = BadAlloc;
    } else free(pcr);
a1541 1

d1543 3
a1545 3
AllocColorPlanes (int client, ColormapPtr pmap, int colors, 
                  int r, int g, int b, Bool contig, Pixel *pixels, 
                  Pixel *prmask, Pixel *pgmask, Pixel *pbmask)
d1547 2
a1548 2
    int		ok;
    Pixel	mask, *ppixFirst;
d1551 3
a1553 3
    int		class;
    int		oldcount;
    colorResource *pcr = (colorResource *)NULL;
d1557 1
a1557 1
	return BadAlloc; /* Shouldn't try on this type */
d1560 47
a1606 55
	oldcount += pmap->numPixelsGreen[client] + pmap->numPixelsBlue[client];
    if (!oldcount && (CLIENT_ID(pmap->mid) != client))
    {
	pcr = malloc(sizeof(colorResource));
	if (!pcr)
	    return BadAlloc;
    }

    if (class == DirectColor)
    {
        ok = AllocDirect (client, pmap, colors, r, g, b, contig, pixels,
			  prmask, pgmask, pbmask);
    }
    else
    {
	/* Allocate the proper pixels */
	/* XXX This is sort of bad, because of contig is set, we force all
	 * r + g + b bits to be contiguous.  Should only force contiguity
	 * per mask 
	 */
        ok = AllocPseudo (client, pmap, colors, r + g + b, contig, pixels,
			  &mask, &ppixFirst);

	if(ok == Success)
	{
	    /* now split that mask into three */
	    *prmask = *pgmask = *pbmask = 0;
	    shift = 1;
	    for (i = r; --i >= 0; shift += shift)
	    {
		while (!(mask & shift))
		    shift += shift;
		*prmask |= shift;
	    }
	    for (i = g; --i >= 0; shift += shift)
	    {
		while (!(mask & shift))
		    shift += shift;
		*pgmask |= shift;
	    }
	    for (i = b; --i >= 0; shift += shift)
	    {
		while (!(mask & shift))
		    shift += shift;
		*pbmask |= shift;
	    }

	    /* set up the shared color cells */
	    if (!AllocShared(pmap, pixels, colors, r, g, b,
			     *prmask, *pgmask, *pbmask, ppixFirst))
	    {
		(void)FreeColors(pmap, client, colors, pixels, mask);
		ok = BadAlloc;
	    }
	}
d1612 8
a1619 7
    if ((ok == Success) && pcr)
    {
	pcr->mid = pmap->mid;
	pcr->client = client;
	if (!AddResource(FakeClientID(client), RT_CMAPENTRY, (pointer)pcr))
	    ok = BadAlloc;
    } else free(pcr);
d1625 9
a1633 8
AllocDirect (int client, ColormapPtr pmap, int c, int r, int g, int b, Bool contig, 
             Pixel *pixels, Pixel *prmask, Pixel *pgmask, Pixel *pbmask)
{
    Pixel	*ppixRed, *ppixGreen, *ppixBlue;
    Pixel	*ppix, *pDst, *p;
    int		npix, npixR, npixG, npixB;
    Bool	okR, okG, okB;
    Pixel	*rpix = 0, *gpix = 0, *bpix = 0;
d1639 4
a1642 4
	(npixR > pmap->freeRed) || (npixR < c) ||
	(npixG > pmap->freeGreen) || (npixG < c) ||
	(npixB > pmap->freeBlue) || (npixB < c))
	return BadAlloc;
d1645 2
a1646 2
    for(p = pixels; p < pixels + c; p++)
	*p = 0;
d1651 5
a1655 6
    if (!ppixRed || !ppixGreen || !ppixBlue)
    {
	free(ppixBlue);
	free(ppixGreen);
	free(ppixRed);
	return BadAlloc;
d1662 32
a1693 34
    if (okR && okG && okB)
    {
	rpix = (Pixel *) realloc(pmap->clientPixelsRed[client],
				  (pmap->numPixelsRed[client] + (c << r)) *
				  sizeof(Pixel));
	if (rpix)
	    pmap->clientPixelsRed[client] = rpix;
	gpix = (Pixel *) realloc(pmap->clientPixelsGreen[client],
				  (pmap->numPixelsGreen[client] + (c << g)) *
				  sizeof(Pixel));
	if (gpix)
	    pmap->clientPixelsGreen[client] = gpix;
	bpix = (Pixel *) realloc(pmap->clientPixelsBlue[client],
				  (pmap->numPixelsBlue[client] + (c << b)) *
				  sizeof(Pixel));
	if (bpix)
	    pmap->clientPixelsBlue[client] = bpix;
    }

    if (!okR || !okG || !okB || !rpix || !gpix || !bpix)
    {
	if (okR)
	    for(ppix = ppixRed, npix = npixR; --npix >= 0; ppix++)
		pmap->red[*ppix].refcnt = 0;
	if (okG)
	    for(ppix = ppixGreen, npix = npixG; --npix >= 0; ppix++)
		pmap->green[*ppix].refcnt = 0;
	if (okB)
	    for(ppix = ppixBlue, npix = npixB; --npix >= 0; ppix++)
		pmap->blue[*ppix].refcnt = 0;
	free(ppixBlue);
	free(ppixGreen);
	free(ppixRed);
	return BadAlloc;
d1701 4
a1704 5
    for (pDst = pixels, p = ppixRed; p < ppixRed + npixR; p++)
    {
	*ppix++ = *p;
	if(p < ppixRed + c)
	    *pDst++ |= *p << pmap->pVisual->offsetRed;
d1710 4
a1713 5
    for (pDst = pixels, p = ppixGreen; p < ppixGreen + npixG; p++)
    {
	*ppix++ = *p;
	if(p < ppixGreen + c)
	    *pDst++ |= *p << pmap->pVisual->offsetGreen;
d1719 4
a1722 5
    for (pDst = pixels, p = ppixBlue; p < ppixBlue + npixB; p++)
    {
	*ppix++ = *p;
	if(p < ppixBlue + c)
	    *pDst++ |= *p << pmap->pVisual->offsetBlue;
a1726 1

d1728 1
a1728 1
	*pDst |= ALPHAMASK(pmap->pVisual);
d1738 2
a1739 2
AllocPseudo (int client, ColormapPtr pmap, int c, int r, Bool contig, 
             Pixel *pixels, Pixel *pmask, Pixel **pppixFirst)
d1741 3
a1743 3
    Pixel	*ppix, *p, *pDst, *ppixTemp;
    int		npix;
    Bool	ok;
d1747 3
a1749 3
	return BadAlloc;
    if(!(ppixTemp = malloc(npix * sizeof(Pixel))))
	return BadAlloc;
d1752 1
a1752 2
    if (ok)
    {
d1754 22
a1775 23
	/* all the allocated pixels are added to the client pixel list,
	 * but only the unique ones are returned to the client */
	ppix = (Pixel *)realloc(pmap->clientPixelsRed[client],
			 (pmap->numPixelsRed[client] + npix) * sizeof(Pixel));
	if (!ppix)
	{
	    for (p = ppixTemp; p < ppixTemp + npix; p++)
		pmap->red[*p].refcnt = 0;
	    free(ppixTemp);
	    return BadAlloc;
	}
	pmap->clientPixelsRed[client] = ppix;
	ppix += pmap->numPixelsRed[client];
	*pppixFirst = ppix;
	pDst = pixels;
	for (p = ppixTemp; p < ppixTemp + npix; p++)
	{
	    *ppix++ = *p;
	    if(p < ppixTemp + c)
	        *pDst++ = *p;
	}
	pmap->numPixelsRed[client] += npix;
	pmap->freeRed -= npix;
d1792 2
a1793 2
AllocCP (ColormapPtr pmap, EntryPtr pentFirst, int count, int planes, 
         Bool contig, Pixel *pixels, Pixel *pMask)
d1795 6
a1800 6
    EntryPtr	ent;
    Pixel	pixel, base, entries, maxp, save;
    int		dplanes, found;
    Pixel	*ppix;
    Pixel	mask;
    Pixel	finalmask;
d1805 1
a1805 2
    if (planes == 0)
    {
d1807 1
a1807 1
	ppix = pixels;
d1810 1
a1810 2
        while (--count >= 0)
	{
d1812 7
a1818 8
    	    while (ent->refcnt)
	    {
    	        ent++;
    	        pixel++;
    	    }
    	    ent->refcnt = AllocPrivate;
    	    *ppix++ = pixel;
	    ent->fShared = FALSE;
d1823 2
a1824 3
    else if (planes > dplanes)
    {
	return FALSE;
d1833 2
a1834 4
    for (mask = (((Pixel)1) << planes) - 1, base = 1, dplanes -= (planes - 1);
         --dplanes >= 0;
         mask += mask, base += base)
    {
d1839 31
a1869 36
        while (pixel < entries)
	{
    	    save = pixel;
    	    maxp = pixel + mask + base;
    	    /* check if all are free */
    	    while (pixel != maxp && ent[pixel].refcnt == 0)
    	        pixel += base;
	    if (pixel == maxp)
		{
		    /* this one works */
		    *ppix++ = save;
		    found++;
		    if (found == count)
		    {
			/* found enough, allocate them all */
			while (--count >= 0)
			{
			    pixel = pixels[count];
			    maxp = pixel + mask;
			    while (1)
			    {
				ent[pixel].refcnt = AllocPrivate;
				ent[pixel].fShared = FALSE;
				if (pixel == maxp)
				    break;
				pixel += base;
				*ppix++ = pixel;
			    }
			}
			*pMask = mask;
			return TRUE;
		    }
		}
    	    pixel = save + 1;
    	    if (pixel & mask)
    	        pixel += mask;
d1875 1
a1875 1
	return FALSE;
d1886 1
a1886 1
         (3 << (planes-1)) -1
d1890 1
a1890 1
         (1<<dplanes) - (1<<(dplanes-planes+1) + (1<<dplanes-planes-1)
d1893 1
a1893 3
         ( (1<<(planes-1)) - 1) << (dplanes-planes+1) + (1<<(dplanes-planes-1))
	  
	  << Thank you, Loretta>>>
d1895 3
a1897 1
    */
d1900 3
a1902 4
        (((((Pixel)1)<<(planes-1)) - 1) << (dplanes-planes+1)) +
	  (((Pixel)1)<<(dplanes-planes-1));
    for (mask = (((Pixel)3) << (planes -1)) - 1; mask <= finalmask; mask++)
    {
d1907 1
a1907 1
    	    continue;
d1911 31
a1941 35
        base = lowbit (mask);
        for (pixel = 0; pixel < entries; pixel++)
	{
	    if (pixel & mask)
	        continue;
	    maxp = 0;
	    /* check if all are free */
	    while (ent[pixel + maxp].refcnt == 0)
	    {
		GetNextBitsOrBreak(maxp, mask, base);
	    }
	    if ((maxp < mask) || (ent[pixel + mask].refcnt != 0))
		continue;
	    /* this one works */
	    *ppix++ = pixel;
	    found++;
	    if (found < count)
		continue;
	    /* found enough, allocate them all */
	    while (--count >= 0)
	    {
		pixel = (pixels)[count];
		maxp = 0;
		while (1)
		{
		    ent[pixel + maxp].refcnt = AllocPrivate;
		    ent[pixel + maxp].fShared = FALSE;
		    GetNextBitsOrBreak(maxp, mask, base);
		    *ppix++ = pixel + maxp;
		}
	    }

	    *pMask = mask;
	    return TRUE;
	}
d1951 2
a1952 2
AllocShared (ColormapPtr pmap, Pixel *ppix, int c, int r, int g, int b, 
             Pixel rmask, Pixel gmask, Pixel bmask, Pixel *ppixFirst)
d1954 3
a1956 3
    Pixel	*pptr, *cptr;
    int		npix, z, npixClientNew, npixShared;
    Pixel	basemask, base, bits, common;
d1963 1
a1963 1
	return FALSE;
d1965 86
a2050 110
    for (z = npixShared; --z >= 0; )
    {
	if (!(ppshared[z] = malloc(sizeof(SHAREDCOLOR))))
	{
	    for (z++ ; z < npixShared; z++)
		free(ppshared[z]);
	    free(psharedList);
	    return FALSE;
	}
    }
    for(pptr = ppix, npix = c; --npix >= 0; pptr++)
    {
	basemask = ~(gmask | bmask);
	common = *pptr & basemask;
	if (rmask)
	{
	    bits = 0;
	    base = lowbit (rmask);
	    while(1)
	    {
		pshared = *ppshared++;
		pshared->refcnt = 1 << (g + b);
		for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++)
		{
		    if ((*cptr & basemask) == (common | bits))
		    {
			pmap->red[*cptr].fShared = TRUE;
			pmap->red[*cptr].co.shco.red = pshared;
		    }
		}
		GetNextBitsOrBreak(bits, rmask, base);
	    }
	}
	else
	{
	    pshared = *ppshared++;
	    pshared->refcnt = 1 << (g + b);
	    for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++)
	    {
		if ((*cptr & basemask) == common)
		{
		    pmap->red[*cptr].fShared = TRUE;
		    pmap->red[*cptr].co.shco.red = pshared;
		}
	    }
	}
	basemask = ~(rmask | bmask);
	common = *pptr & basemask;
	if (gmask)
	{
	    bits = 0;
	    base = lowbit (gmask);
	    while(1)
	    {
		pshared = *ppshared++;
		pshared->refcnt = 1 << (r + b);
		for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++)
		{
		    if ((*cptr & basemask) == (common | bits))
		    {
			pmap->red[*cptr].co.shco.green = pshared;
		    }
		}
		GetNextBitsOrBreak(bits, gmask, base);
	    }
	}
	else
	{
	    pshared = *ppshared++;
	    pshared->refcnt = 1 << (g + b);
	    for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++)
	    {
		if ((*cptr & basemask) == common)
		{
		    pmap->red[*cptr].co.shco.green = pshared;
		}
	    }
	}
	basemask = ~(rmask | gmask);
	common = *pptr & basemask;
	if (bmask)
	{
	    bits = 0;
	    base = lowbit (bmask);
	    while(1)
	    {
		pshared = *ppshared++;
		pshared->refcnt = 1 << (r + g);
		for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++)
		{
		    if ((*cptr & basemask) == (common | bits))
		    {
			pmap->red[*cptr].co.shco.blue = pshared;
		    }
		}
		GetNextBitsOrBreak(bits, bmask, base);
	    }
	}
	else
	{
	    pshared = *ppshared++;
	    pshared->refcnt = 1 << (g + b);
	    for (cptr = ppixFirst, z = npixClientNew; --z >= 0; cptr++)
	    {
		if ((*cptr & basemask) == common)
		{
		    pmap->red[*cptr].co.shco.blue = pshared;
		}
	    }
	}
a2055 1

d2060 1
a2060 1
FreeColors (ColormapPtr pmap, int client, int count, Pixel *pixels, Pixel mask)
d2062 2
a2063 2
    int		rval, result, class;
    Pixel	rmask;
d2067 3
a2069 4
	return BadAccess;
    if ((class | DynamicClass) == DirectColor)
    {
	rmask = mask & RGBMASK(pmap->pVisual);
d2071 3
a2073 3
			mask & pmap->pVisual->redMask);
	/* If any of the three calls fails, we must report that, if more
	 * than one fails, it's ok that we report the last one */
d2075 7
a2081 7
		      mask & pmap->pVisual->greenMask);
	if(rval != Success)
	    result = rval;
	rval = FreeCo(pmap, client, BLUEMAP, count, pixels,
		      mask & pmap->pVisual->blueMask);
	if(rval != Success)
	    result = rval;
d2083 2
a2084 3
    else
    {
	rmask = mask & ((((Pixel)1) << pmap->pVisual->nplanes) - 1);
d2087 3
a2089 4
    if ((mask != rmask) && count)
    {
	clients[client]->errorValue = *pixels | mask;
	result = BadValue;
d2107 2
a2108 1
FreeCo (ColormapPtr pmap, int client, int color, int npixIn, Pixel *ppixIn, Pixel mask)
d2110 7
a2116 7
    Pixel	*ppixClient, pixTest;
    int		npixClient, npixNew, npix;
    Pixel	bits, base, cmask, rgbbad;
    Pixel	*pptr, *cptr;
    int 	n, zapped;
    int		errVal = Success;
    int		offset, numents;
d2122 1
a2122 1
    base = lowbit (mask);
d2124 34
a2157 35
    switch(color)
    {
      case REDMAP:
	cmask = pmap->pVisual->redMask;
	rgbbad = ~RGBMASK(pmap->pVisual);
	offset = pmap->pVisual->offsetRed;
	numents = (cmask >> offset) + 1;
	ppixClient = pmap->clientPixelsRed[client];
	npixClient = pmap->numPixelsRed[client];
	break;
      case GREENMAP:
	cmask = pmap->pVisual->greenMask;
	rgbbad = ~RGBMASK(pmap->pVisual);
	offset = pmap->pVisual->offsetGreen;
	numents = (cmask >> offset) + 1;
	ppixClient = pmap->clientPixelsGreen[client];
	npixClient = pmap->numPixelsGreen[client];
	break;
      case BLUEMAP:
	cmask = pmap->pVisual->blueMask;
	rgbbad = ~RGBMASK(pmap->pVisual);
	offset = pmap->pVisual->offsetBlue;
	numents = (cmask >> offset) + 1;
	ppixClient = pmap->clientPixelsBlue[client];
	npixClient = pmap->numPixelsBlue[client];
	break;
      default:	/* so compiler can see that everything gets initialized */
      case PSEUDOMAP:
	cmask = ~((Pixel)0);
	rgbbad = 0;
	offset = 0;
	numents = pmap->pVisual->ColormapEntries;
	ppixClient = pmap->clientPixelsRed[client];
	npixClient = pmap->numPixelsRed[client];
	break;
a2159 1

d2161 1
a2161 2
    while (1)
    {
d2163 22
a2184 27
        for (pptr = ppixIn, n = npixIn; --n >= 0; pptr++)
	{
	    pixTest = ((*pptr | bits) & cmask) >> offset;
	    if ((pixTest >= numents) || (*pptr & rgbbad))
	    {
		clients[client]->errorValue = *pptr | bits;
		errVal = BadValue;
		continue;
	    }

	    /* find match in client list */
	    for (cptr = ppixClient, npix = npixClient;
	         --npix >= 0 && *cptr != pixTest;
		 cptr++) ;

	    if (npix >= 0)
	    {
		if (pmap->class & DynamicClass)
		{
		    FreeCell(pmap, pixTest, color);
		}
		*cptr = ~((Pixel)0);
		zapped++;
	    }
	    else
		errVal = BadAccess;
	}
d2186 1
a2186 1
	GetNextBitsOrBreak(bits, mask, base);
d2190 1
a2190 2
    if (zapped)
    {
d2192 38
a2229 43
        if (npixNew)
	{
	    /* Since the list can only get smaller, we can do a copy in
	     * place and then realloc to a smaller size */
    	    pptr = cptr = ppixClient;

	    /* If we have all the new pixels, we don't have to examine the
	     * rest of the old ones */
	    for(npix = 0; npix < npixNew; cptr++)
	    {
    	        if (*cptr != ~((Pixel)0))
		{
    		    *pptr++ = *cptr;
		    npix++;
    	        }
    	    }
	    pptr = (Pixel *)realloc(ppixClient, npixNew * sizeof(Pixel));
	    if (pptr)
		ppixClient = pptr;
	    npixClient = npixNew;
        }
	else
	{
	    npixClient = 0;
	    free(ppixClient);
    	    ppixClient = (Pixel *)NULL;
	}
	switch(color)
	{
	  case PSEUDOMAP:
	  case REDMAP:
	    pmap->clientPixelsRed[client] = ppixClient;
	    pmap->numPixelsRed[client] = npixClient;
	    break;
	  case GREENMAP:
	    pmap->clientPixelsGreen[client] = ppixClient;
	    pmap->numPixelsGreen[client] = npixClient;
	    break;
	  case BLUEMAP:
	    pmap->clientPixelsBlue[client] = ppixClient;
	    pmap->numPixelsBlue[client] = npixClient;
	    break;
	}
a2233 2


d2236 1
a2236 1
StoreColors (ColormapPtr pmap, int count, xColorItem *defs, ClientPtr client)
d2238 1
a2238 1
    Pixel 	pix;
d2240 6
a2245 7
    EntryPtr 	pent, pentT, pentLast;
    VisualPtr	pVisual;
    SHAREDCOLOR		*pred, *pgreen, *pblue;
    int			n, ChgRed, ChgGreen, ChgBlue, idef;
    int			class, errVal = Success;
    int			ok;

d2248 2
a2249 3
    if(!(class & DynamicClass) && !(pmap->flags & BeingCreated))
    {
	return BadAccess;
d2254 10
a2263 12
    if((class | DynamicClass) == DirectColor)
    {
	int numred, numgreen, numblue;
	Pixel rgbbad;

	numred = NUMRED(pVisual);
	numgreen = NUMGREEN(pVisual);
	numblue = NUMBLUE(pVisual);
	rgbbad = ~RGBMASK(pVisual);
        for (pdef = defs, n = 0; n < count; pdef++, n++)
	{
	    ok = TRUE;
d2265 1
a2265 1
	        (&pdef->red, &pdef->green, &pdef->blue, pmap->pVisual);
d2267 64
a2330 77
	    if (pdef->pixel & rgbbad)
	    {
		errVal = BadValue;
		client->errorValue = pdef->pixel;
		continue;
	    }
	    pix = (pdef->pixel & pVisual->redMask) >> pVisual->offsetRed;
	    if (pix >= numred)
	    {
		errVal = BadValue;
		ok = FALSE;
	    }
	    else if (pmap->red[pix].refcnt != AllocPrivate)
	    {
		errVal = BadAccess;
		ok = FALSE;
	    }
	    else if (pdef->flags & DoRed)
	    {
		pmap->red[pix].co.local.red = pdef->red;
	    }
	    else
	    {
		pdef->red = pmap->red[pix].co.local.red;
	    }

	    pix = (pdef->pixel & pVisual->greenMask) >> pVisual->offsetGreen;
	    if (pix >= numgreen)
	    {
		errVal = BadValue;
		ok = FALSE;
	    }
	    else if (pmap->green[pix].refcnt != AllocPrivate)
	    {
		errVal = BadAccess;
		ok = FALSE;
	    }
	    else if (pdef->flags & DoGreen)
	    {
		pmap->green[pix].co.local.green = pdef->green;
	    }
	    else
	    {
		pdef->green = pmap->green[pix].co.local.green;
	    }

	    pix = (pdef->pixel & pVisual->blueMask) >> pVisual->offsetBlue;
	    if (pix >= numblue)
	    {
		errVal = BadValue;
		ok = FALSE;
	    }
	    else if (pmap->blue[pix].refcnt != AllocPrivate)
	    {
		errVal = BadAccess;
		ok = FALSE;
	    }
	    else if (pdef->flags & DoBlue)
	    {
		pmap->blue[pix].co.local.blue = pdef->blue;
	    }
	    else
	    {
		pdef->blue = pmap->blue[pix].co.local.blue;
	    }
	    /* If this is an o.k. entry, then it gets added to the list
	     * to be sent to the hardware.  If not, skip it.  Once we've
	     * skipped one, we have to copy all the others.
	     */
	    if(ok)
	    {
		if(idef != n)
		    defs[idef] = defs[n];
		idef++;
	    } else
		client->errorValue = pdef->pixel;
	}
d2332 25
a2356 30
    else
    {
        for (pdef = defs, n = 0; n < count; pdef++, n++)
	{

	    ok = TRUE;
	    if (pdef->pixel >= pVisual->ColormapEntries)
	    {
		client->errorValue = pdef->pixel;
	        errVal = BadValue;
		ok = FALSE;
	    }
	    else if (pmap->red[pdef->pixel].refcnt != AllocPrivate)
	    {
		errVal = BadAccess;
		ok = FALSE;
	    }

	    /* If this is an o.k. entry, then it gets added to the list
	     * to be sent to the hardware.  If not, skip it.  Once we've
	     * skipped one, we have to copy all the others.
	     */
	    if(ok)
	    {
		if(idef != n)
		    defs[idef] = defs[n];
		idef++;
	    }
	    else
		continue;
d2359 1
a2359 1
	        (&pdef->red, &pdef->green, &pdef->blue, pmap->pVisual);
d2361 1
a2361 1
	    pent = &pmap->red[pdef->pixel];
d2363 45
a2407 54
	    if(pdef->flags & DoRed)
	    {
		if(pent->fShared)
		{
		    pent->co.shco.red->color = pdef->red;
		    if (pent->co.shco.red->refcnt > 1)
			ok = FALSE;
		}
		else
		    pent->co.local.red = pdef->red;
	    }
	    else
	    {
		if(pent->fShared)
		    pdef->red = pent->co.shco.red->color;
		else
		    pdef->red = pent->co.local.red;
	    }
	    if(pdef->flags & DoGreen)
	    {
		if(pent->fShared)
		{
		    pent->co.shco.green->color = pdef->green;
		    if (pent->co.shco.green->refcnt > 1)
			ok = FALSE;
		}
		else
		    pent->co.local.green = pdef->green;
	    }
	    else
	    {
		if(pent->fShared)
		    pdef->green = pent->co.shco.green->color;
		else
		    pdef->green = pent->co.local.green;
	    }
	    if(pdef->flags & DoBlue)
	    {
		if(pent->fShared)
		{
		    pent->co.shco.blue->color = pdef->blue;
		    if (pent->co.shco.blue->refcnt > 1)
			ok = FALSE;
		}
		else
		    pent->co.local.blue = pdef->blue;
	    }
	    else
	    {
		if(pent->fShared)
		    pdef->blue = pent->co.shco.blue->color;
		else
		    pdef->blue = pent->co.local.blue;
	    }
d2409 1
a2409 2
	    if(!ok)
	    {
d2411 42
a2452 48
		 * shares this value */
	        pred = pent->co.shco.red;
	        pgreen = pent->co.shco.green;
	        pblue = pent->co.shco.blue;
	        ChgRed = pdef->flags & DoRed;
	        ChgGreen = pdef->flags & DoGreen;
	        ChgBlue = pdef->flags & DoBlue;
	        pentLast = pmap->red + pVisual->ColormapEntries;

	        for(pentT = pmap->red; pentT < pentLast; pentT++)
		{
		    if(pentT->fShared && (pentT != pent))
		    {
			xColorItem	defChg;

			/* There are, alas, devices in this world too dumb
			 * to read their own hardware colormaps.  Sick, but
			 * true.  So we're going to be really nice and load
			 * the xColorItem with the proper value for all the
			 * fields.  We will only set the flags for those
			 * fields that actually change.  Smart devices can
			 * arrange to change only those fields.  Dumb devices
			 * can rest assured that we have provided for them,
			 * and can change all three fields */

			defChg.flags = 0;
			if(ChgRed && pentT->co.shco.red == pred)
			{
			    defChg.flags |= DoRed;
			}
			if(ChgGreen && pentT->co.shco.green == pgreen)
			{
			    defChg.flags |= DoGreen;
			}
			if(ChgBlue && pentT->co.shco.blue == pblue)
			{
			    defChg.flags |= DoBlue;
			}
			if(defChg.flags != 0)
			{
			    defChg.pixel = pentT - pmap->red;
			    defChg.red = pentT->co.shco.red->color;
			    defChg.green = pentT->co.shco.green->color;
			    defChg.blue = pentT->co.shco.blue->color;
			    (*pmap->pScreen->StoreColors) (pmap, 1, &defChg);
			}
		    }
		}
d2454 2
a2455 2
	    }
	}
d2460 1
a2460 1
	( *pmap->pScreen->StoreColors) (pmap, idef, defs);
d2467 2
a2468 2
    Colormap	*pmaps;
    int		imap, nummaps, found;
d2470 4
a2473 3
    pmaps = malloc(pWin->drawable.pScreen->maxInstalledCmaps*sizeof(Colormap));
    if(!pmaps)
	return FALSE;
d2477 5
a2481 7
    for(imap = 0; imap < nummaps; imap++)
    {
	if(pmaps[imap] == map)
	{
	    found = TRUE;
	    break;
	}
d2492 2
a2493 2
static void _colormap_find_resource(pointer value, XID id,
				    pointer cdata)
d2502 1
a2502 1
	return;
d2511 1
a2511 2
ResizeVisualArray(ScreenPtr pScreen, int new_visual_count,
		  DepthPtr depth)
d2522 2
a2523 1
    vids = realloc(depth->vids, (depth->numVids + new_visual_count) * sizeof(XID));
d2533 1
a2533 1
	return FALSE;
d2538 2
a2539 1
    FindClientResourcesByType(serverClient, RT_COLORMAP, _colormap_find_resource, &cdata);
d2544 3
a2546 3
	vid = FakeClientID(0);
	pScreen->visuals[first_new_visual + i].vid = vid;
	vids[first_new_vid + i] = vid;
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d1882 1
d2108 1
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d60 1
a68 2
extern XID clientErrorValue;

d267 1
a267 1
	return (BadMatch);
d276 14
a289 3
    pmap = xalloc(sizebytes);
    if (!pmap)
	return (BadAlloc);
d312 2
a313 2
    bzero ((char *) pmap->red, (int)sizebytes);
    bzero((char *) pmap->numPixelsRed, MAXCLIENTS * sizeof(int));
d323 1
a323 1
	ppix = xalloc(size * sizeof(Pixel));
d326 2
a327 2
	    xfree(pmap);
	    return (BadAlloc);
d350 2
a351 2
	bzero ((char *) pmap->green, (int)sizebytes);
	bzero ((char *) pmap->blue, (int)sizebytes);
d359 2
a360 2
	bzero((char *) pmap->numPixelsGreen, MAXCLIENTS * sizeof(int));
	bzero((char *) pmap->numPixelsBlue, MAXCLIENTS * sizeof(int));
d369 1
a369 1
	    ppix = xalloc(size * sizeof(Pixel));
d372 3
a374 3
		xfree(pmap->clientPixelsRed[client]);
		xfree(pmap);
		return(BadAlloc);
d385 1
a385 1
	    ppix = xalloc(size * sizeof(Pixel));
d388 4
a391 4
		xfree(pmap->clientPixelsGreen[client]);
		xfree(pmap->clientPixelsRed[client]);
		xfree(pmap);
		return(BadAlloc);
a398 1
    pmap->devPrivates = NULL;
d402 1
a402 1
	return (BadAlloc);
d424 1
a424 1
    return (Success);
d451 1
a451 1
	    xfree(pmap->clientPixelsRed[i]);
d463 1
a463 1
		    xfree(pent->co.shco.red);
d465 1
a465 1
		    xfree(pent->co.shco.green);
d467 1
a467 1
		    xfree(pent->co.shco.blue);
d475 2
a476 2
            xfree(pmap->clientPixelsGreen[i]);
            xfree(pmap->clientPixelsBlue[i]);
d480 6
a485 3
    dixFreePrivates(pmap->devPrivates);
    xfree(pmap);
    return(Success);
d512 1
a512 1
    return (WT_WALKCHILDREN);
d537 1
a537 1
    return (WT_WALKCHILDREN);
d562 1
a562 1
    return (WT_WALKCHILDREN);
d585 1
a585 1
        return(result);
d597 1
a597 1
	return(Success);
d609 1
a609 1
    return(Success);
d735 1
a735 1
		xfree(pent->co.shco.red);
d737 1
a737 1
		xfree(pent->co.shco.green);
d739 1
a739 1
		xfree(pent->co.shco.blue);
d758 1
a758 1
    defs = xalloc(size * sizeof(xColorItem));
d808 1
a808 1
    xfree(defs);
d855 1
a855 1
	ppix = (Pixel *) xrealloc(pmap->clientPixelsRed[client],
d858 1
a858 1
	    return (BadAlloc);
d878 1
a878 1
	ppix = (Pixel *) xrealloc(pmap->clientPixelsRed[client],
d881 1
a881 1
	    return (BadAlloc);
d885 1
a885 1
	ppix = (Pixel *) xrealloc(pmap->clientPixelsGreen[client],
d888 1
a888 1
	    return (BadAlloc);
d892 1
a892 1
	ppix = (Pixel *) xrealloc(pmap->clientPixelsBlue[client],
d895 1
a895 1
	    return (BadAlloc);
d918 1
a918 1
	    return (BadAlloc);
d947 1
a947 1
	    return (BadAlloc);
d953 1
a953 1
	    return (BadAlloc);
d961 1
a961 1
	    return (BadAlloc);
d977 1
a977 1
	pcr = xalloc(sizeof(colorResource));
d981 1
a981 1
	    return (BadAlloc);
d986 1
a986 1
	    return (BadAlloc);
d988 1
a988 1
    return (Success);
d1175 1
a1175 1
    return(final);
d1283 1
a1283 1
	return (BadAlloc);
d1342 1
a1342 1
	return(Success);
d1363 1
a1363 1
    ppix = (Pixel *) xrealloc (pixp[client], (npix + 1) * sizeof(Pixel));
d1381 1
a1381 1
	return(BadAlloc);
d1387 1
a1387 1
    return(Success);
d1398 2
a1399 2
       return (1);
    return (0);
d1406 2
a1407 2
	return (1);
    return (0);
d1414 2
a1415 2
	return (1);
    return (0);
d1422 2
a1423 2
	return (1);
    return (0);
d1430 1
a1430 1
QueryColors (ColormapPtr pmap, int count, Pixel *ppixIn, xrgb *prgbList)
d1453 1
a1453 1
		clientErrorValue = pixel;
d1460 1
a1460 1
		clientErrorValue = pixel;
d1468 1
a1468 1
		clientErrorValue = pixel;
d1476 1
a1476 1
		clientErrorValue = pixel;
d1490 1
a1490 1
		clientErrorValue = pixel;
d1511 1
a1511 1
    return (errVal);
d1533 1
a1533 1
    xfree(ppixStart);
d1542 1
a1542 1
	xfree(ppixStart);
d1550 1
a1550 1
	xfree(ppixStart);
d1573 1
a1573 1
    xfree(pcr);
d1589 1
a1589 1
	return (BadAlloc); /* Shouldn't try on this type */
d1595 1
a1595 1
	pcr = xalloc(sizeof(colorResource));
d1597 1
a1597 1
	    return (BadAlloc);
d1642 1
a1642 2
    } else if (pcr)
	xfree(pcr);
d1644 1
a1644 1
    return (ok);
d1663 1
a1663 1
	return (BadAlloc); /* Shouldn't try on this type */
d1669 1
a1669 1
	pcr = xalloc(sizeof(colorResource));
d1671 1
a1671 1
	    return (BadAlloc);
d1732 1
a1732 2
    } else if (pcr)
	xfree(pcr);
d1734 1
a1734 1
    return (ok);
d1760 3
a1762 3
    ppixRed = xalloc(npixR * sizeof(Pixel));
    ppixGreen = xalloc(npixG * sizeof(Pixel));
    ppixBlue = xalloc(npixB * sizeof(Pixel));
d1765 4
a1768 4
	if (ppixBlue) xfree(ppixBlue);
	if (ppixGreen) xfree(ppixGreen);
	if (ppixRed) xfree(ppixRed);
	return(BadAlloc);
d1777 1
a1777 1
	rpix = (Pixel *) xrealloc(pmap->clientPixelsRed[client],
d1782 1
a1782 1
	gpix = (Pixel *) xrealloc(pmap->clientPixelsGreen[client],
d1787 1
a1787 1
	bpix = (Pixel *) xrealloc(pmap->clientPixelsBlue[client],
d1805 4
a1808 4
	xfree(ppixBlue);
	xfree(ppixGreen);
	xfree(ppixRed);
	return(BadAlloc);
d1849 3
a1851 3
    xfree(ppixBlue);
    xfree(ppixGreen);
    xfree(ppixRed);
d1853 1
a1853 1
    return (Success);
d1866 3
a1868 3
	return(BadAlloc);
    if(!(ppixTemp = xalloc(npix * sizeof(Pixel))))
	return(BadAlloc);
d1876 1
a1876 1
	ppix = (Pixel *)xrealloc(pmap->clientPixelsRed[client],
d1882 1
a1882 1
	    return (BadAlloc);
d1897 2
a1898 2
    xfree(ppixTemp);
    return (ok ? Success : BadAlloc);
d1944 1
a1944 1
        return (TRUE);
d1948 1
a1948 1
	return (FALSE);
d1995 1
a1995 1
			return (TRUE);
d2006 1
a2006 1
	return (FALSE);
d2076 1
a2076 1
	    return (TRUE);
d2079 1
a2079 1
    return (FALSE);
d2097 1
a2097 1
    psharedList = xalloc(npixShared * sizeof(SHAREDCOLOR *));
d2103 1
a2103 1
	if (!(ppshared[z] = xalloc(sizeof(SHAREDCOLOR))))
d2106 1
a2106 1
		xfree(ppshared[z]);
d2211 1
a2211 1
    xfree(psharedList);
d2227 1
a2227 1
	return(BadAccess);
d2251 1
a2251 1
	clientErrorValue = *pixels | mask;
d2255 1
a2255 1
    return (result);
d2281 1
a2281 1
        return (errVal);
d2333 1
a2333 1
		clientErrorValue = *pptr | bits;
d2379 1
a2379 1
	    pptr = (Pixel *)xrealloc(ppixClient, npixNew * sizeof(Pixel));
d2387 1
a2387 1
	    xfree(ppixClient);
d2407 1
a2407 1
    return (errVal);
d2414 1
a2414 1
StoreColors (ColormapPtr pmap, int count, xColorItem *defs)
d2429 1
a2429 1
	return(BadAccess);
d2452 1
a2452 1
		clientErrorValue = pdef->pixel;
d2524 1
a2524 1
		clientErrorValue = pdef->pixel;
d2535 1
a2535 1
		clientErrorValue = pdef->pixel;
d2677 1
a2677 1
    return (errVal);
d2686 1
a2686 1
    pmaps = xalloc(pWin->drawable.pScreen->maxInstalledCmaps*sizeof(Colormap));
d2688 1
a2688 1
	return(FALSE);
d2700 2
a2701 2
    xfree(pmaps);
    return (found);
d2740 1
a2740 1
    vids = xrealloc(depth->vids, (depth->numVids + new_visual_count) * sizeof(XID));
d2748 1
a2748 1
    visuals = xrealloc(pScreen->visuals, numVisuals * sizeof(VisualRec));
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a53 1
#define NEED_EVENTS
d255 1
a255 1
_X_EXPORT int 
d277 1
a277 1
    pmap = (ColormapPtr) xalloc(sizebytes);
d313 1
a313 1
	ppix = (Pixel *)xalloc(size * sizeof(Pixel));
d359 1
a359 1
	    ppix = (Pixel *) xalloc(size * sizeof(Pixel));
d375 1
a375 1
	    ppix = (Pixel *) xalloc(size * sizeof(Pixel));
d504 1
a504 1
_X_EXPORT int
d529 1
a529 1
_X_EXPORT int
d746 1
a746 1
    defs = (xColorItem *)xalloc(size * sizeof(xColorItem));
d802 1
a802 1
_X_EXPORT int
d896 3
a898 3
	    ColormapPtr prootmap = (ColormapPtr)
		SecurityLookupIDByType (clients[client], pmap->pScreen->defColormap,
					 RT_COLORMAP, DixReadAccess);
d913 3
a915 3
	    ColormapPtr prootmap = (ColormapPtr)
		SecurityLookupIDByType (clients[client], pmap->pScreen->defColormap,
					 RT_COLORMAP, DixReadAccess);
d965 1
a965 1
	pcr = (colorResource *) xalloc(sizeof(colorResource));
d987 1
a987 1
_X_EXPORT void
d1054 1
a1054 1
_X_EXPORT void
d1417 1
a1417 1
_X_EXPORT int
d1553 8
a1560 6
    ColormapPtr pmap;
    colorResource *pcr = (colorResource *)value;

    pmap = (ColormapPtr) LookupIDByType(pcr->mid, RT_COLORMAP);
    if (pmap)
	FreePixels(pmap, pcr->client);
d1583 1
a1583 1
	pcr = (colorResource *) xalloc(sizeof(colorResource));
d1658 1
a1658 1
	pcr = (colorResource *) xalloc(sizeof(colorResource));
d1750 3
a1752 3
    ppixRed = (Pixel *)xalloc(npixR * sizeof(Pixel));
    ppixGreen = (Pixel *)xalloc(npixG * sizeof(Pixel));
    ppixBlue = (Pixel *)xalloc(npixB * sizeof(Pixel));
d1857 1
a1857 1
    if(!(ppixTemp = (Pixel *)xalloc(npix * sizeof(Pixel))))
d2087 1
a2087 2
    psharedList = (SHAREDCOLOR **)xalloc(npixShared *
						 sizeof(SHAREDCOLOR *));
d2093 1
a2093 1
	if (!(ppshared[z] = (SHAREDCOLOR *)xalloc(sizeof(SHAREDCOLOR))))
d2209 1
a2209 1
_X_EXPORT int
d2403 1
a2403 1
_X_EXPORT int
d2676 1
a2676 2
    pmaps = (Colormap *) xalloc( 
             pWin->drawable.pScreen->maxInstalledCmaps * sizeof(Colormap));
d2692 67
@


1.1
log
@Initial revision
@
text
@d66 2
a69 1
extern int colormapPrivateCount;
d99 2
a100 2
    register ColormapPtr /*pmap*/,
    register int /*client*/
d263 1
a263 1
    register	EntryPtr	pent;
d265 1
a265 1
    register	Pixel	*ppix, **pptr;
d390 3
a394 5
    /* If the device wants a chance to initialize the colormap in any way,
     * this is it.  In specific, if this is a Static colormap, this is the
     * time to fill in the colormap's values */
    pmap->flags |= BeingCreated;

d396 2
a397 2
    /*
     * Allocate the array of devPrivate's for this colormap.
d399 5
a403 12

    if (colormapPrivateCount == 0)
	pmap->devPrivates = NULL;
    else
    {
	pmap->devPrivates = (DevUnion *) xcalloc (
	    sizeof(DevUnion), colormapPrivateCount);
	if (!pmap->devPrivates)
	{
	    FreeResource (mid, RT_NONE);
	    return BadAlloc;
	}
d406 3
d426 2
a427 2
    int		i;
    register EntryPtr pent;
d472 1
a472 3
    if (pmap->devPrivates)
	xfree(pmap->devPrivates);

d740 3
a742 3
    register xColorItem *pdef;
    register EntryPtr 	pent;
    register VisualPtr	pVisual;
d747 1
a747 1
    defs = (xColorItem *)ALLOCATE_LOCAL(size * sizeof(xColorItem));
d797 1
a797 1
    DEALLOCATE_LOCAL(defs);
d899 1
a899 1
					 RT_COLORMAP, SecurityReadAccess);
d916 1
a916 1
					 RT_COLORMAP, SecurityReadAccess);
d989 1
a989 1
FakeAllocColor (register ColormapPtr pmap, register xColorItem *item)
d991 6
a996 6
    Pixel	pixR, pixG, pixB;
    Pixel	temp;
    int		entries;
    xrgb	rgb;
    int		class;
    register VisualPtr	pVisual;
d1009 1
d1056 1
a1056 1
FakeFreeColor(register ColormapPtr pmap, Pixel pixel)
d1058 1
a1058 1
    register VisualPtr pVisual;
d1504 1
a1504 1
FreePixels(register ColormapPtr pmap, register int client)
d1506 3
a1508 3
    register Pixel		*ppix, *ppixStart;
    register int 		n;
    int				class;
d1643 2
a1644 2
    register Pixel shift;
    register int i;
d1749 3
a1751 3
    ppixRed = (Pixel *)ALLOCATE_LOCAL(npixR * sizeof(Pixel));
    ppixGreen = (Pixel *)ALLOCATE_LOCAL(npixG * sizeof(Pixel));
    ppixBlue = (Pixel *)ALLOCATE_LOCAL(npixB * sizeof(Pixel));
d1754 3
a1756 3
	if (ppixBlue) DEALLOCATE_LOCAL(ppixBlue);
	if (ppixGreen) DEALLOCATE_LOCAL(ppixGreen);
	if (ppixRed) DEALLOCATE_LOCAL(ppixRed);
d1794 3
a1796 3
	DEALLOCATE_LOCAL(ppixBlue);
	DEALLOCATE_LOCAL(ppixGreen);
	DEALLOCATE_LOCAL(ppixRed);
d1838 3
a1840 3
    DEALLOCATE_LOCAL(ppixBlue);
    DEALLOCATE_LOCAL(ppixGreen);
    DEALLOCATE_LOCAL(ppixRed);
d1856 1
a1856 1
    if(!(ppixTemp = (Pixel *)ALLOCATE_LOCAL(npix * sizeof(Pixel))))
d1886 1
a1886 1
    DEALLOCATE_LOCAL(ppixTemp);
d2086 1
a2086 1
    psharedList = (SHAREDCOLOR **)ALLOCATE_LOCAL(npixShared *
d2201 1
a2201 1
    DEALLOCATE_LOCAL(psharedList);
d2406 4
a2409 4
    register Pixel 	pix;
    register xColorItem *pdef;
    register EntryPtr 	pent, pentT, pentLast;
    register VisualPtr	pVisual;
d2676 1
a2676 1
    pmaps = (Colormap *) ALLOCATE_LOCAL( 
d2691 1
a2691 1
    DEALLOCATE_LOCAL(pmaps);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d98 2
a99 2
    ColormapPtr /*pmap*/,
    int /*client*/
d262 1
a262 1
    EntryPtr	pent;
d264 1
a264 1
    Pixel	*ppix, **pptr;
d431 2
a432 2
    int	i;
    EntryPtr pent;
d747 3
a749 3
    xColorItem *pdef;
    EntryPtr 	pent;
    VisualPtr	pVisual;
d906 1
a906 1
					 RT_COLORMAP, DixReadAccess);
d923 1
a923 1
					 RT_COLORMAP, DixReadAccess);
d996 1
a996 1
FakeAllocColor (ColormapPtr pmap, xColorItem *item)
d998 6
a1003 6
    Pixel pixR, pixG, pixB;
    Pixel temp;
    int	entries;
    xrgb rgb;
    int	class;
    VisualPtr pVisual;
d1062 1
a1062 1
FakeFreeColor(ColormapPtr pmap, Pixel pixel)
d1064 1
a1064 1
    VisualPtr pVisual;
d1510 1
a1510 1
FreePixels(ColormapPtr pmap, int client)
d1512 3
a1514 3
    Pixel *ppix, *ppixStart;
    int n;
    int	class;
d1649 2
a1650 2
    Pixel shift;
    int i;
d2412 4
a2415 4
    Pixel 	pix;
    xColorItem *pdef;
    EntryPtr 	pent, pentT, pentLast;
    VisualPtr	pVisual;
@

