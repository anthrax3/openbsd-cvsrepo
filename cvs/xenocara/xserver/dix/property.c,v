head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.24;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.24;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "windowstr.h"
#include "propertyst.h"
#include "dixstruct.h"
#include "dispatch.h"
#include "swaprep.h"
#include "xace.h"

/*****************************************************************
 * Property Stuff
 *
 *    dixLookupProperty, dixChangeProperty, DeleteProperty
 *
 *   Properties belong to windows.  The list of properties should not be
 *   traversed directly.  Instead, use the three functions listed above.
 *
 *****************************************************************/

#ifdef notdef
static void
PrintPropertys(WindowPtr pWin)
{
    PropertyPtr pProp;
    int j;

    pProp = pWin->userProps;
    while (pProp) {
        ErrorF("[dix] %x %x\n", pProp->propertyName, pProp->type);
        ErrorF("[dix] property format: %d\n", pProp->format);
        ErrorF("[dix] property data: \n");
        for (j = 0; j < (pProp->format / 8) * pProp->size; j++)
            ErrorF("[dix] %c\n", pProp->data[j]);
        pProp = pProp->next;
    }
}
#endif

int
dixLookupProperty(PropertyPtr *result, WindowPtr pWin, Atom propertyName,
                  ClientPtr client, Mask access_mode)
{
    PropertyPtr pProp;
    int rc = BadMatch;

    client->errorValue = propertyName;

    for (pProp = wUserProps(pWin); pProp; pProp = pProp->next)
        if (pProp->propertyName == propertyName)
            break;

    if (pProp)
        rc = XaceHookPropertyAccess(client, pWin, &pProp, access_mode);
    *result = pProp;
    return rc;
}

static void
deliverPropertyNotifyEvent(WindowPtr pWin, int state, Atom atom)
{
    xEvent event = {
        .u.property.window = pWin->drawable.id,
        .u.property.state = state,
        .u.property.atom = atom,
        .u.property.time = currentTime.milliseconds
    };
    event.u.u.type = PropertyNotify;
    DeliverEvents(pWin, &event, 1, (WindowPtr) NULL);
}

int
ProcRotateProperties(ClientPtr client)
{
    int i, j, delta, rc;

    REQUEST(xRotatePropertiesReq);
    WindowPtr pWin;
    Atom *atoms;
    PropertyPtr *props;         /* array of pointer */
    PropertyPtr pProp, saved;

    REQUEST_FIXED_SIZE(xRotatePropertiesReq, stuff->nAtoms << 2);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pWin, stuff->window, client, DixSetPropAccess);
    if (rc != Success || stuff->nAtoms <= 0)
        return rc;

    atoms = (Atom *) &stuff[1];
    props = xallocarray(stuff->nAtoms, sizeof(PropertyPtr));
    saved = xallocarray(stuff->nAtoms, sizeof(PropertyRec));
    if (!props || !saved) {
        rc = BadAlloc;
        goto out;
    }

    for (i = 0; i < stuff->nAtoms; i++) {
        if (!ValidAtom(atoms[i])) {
            rc = BadAtom;
            client->errorValue = atoms[i];
            goto out;
        }
        for (j = i + 1; j < stuff->nAtoms; j++)
            if (atoms[j] == atoms[i]) {
                rc = BadMatch;
                goto out;
            }

        rc = dixLookupProperty(&pProp, pWin, atoms[i], client,
                               DixReadAccess | DixWriteAccess);
        if (rc != Success)
            goto out;

        props[i] = pProp;
        saved[i] = *pProp;
    }
    delta = stuff->nPositions;

    /* If the rotation is a complete 360 degrees, then moving the properties
       around and generating PropertyNotify events should be skipped. */

    if (abs(delta) % stuff->nAtoms) {
        while (delta < 0)       /* faster if abs value is small */
            delta += stuff->nAtoms;
        for (i = 0; i < stuff->nAtoms; i++) {
            j = (i + delta) % stuff->nAtoms;
            deliverPropertyNotifyEvent(pWin, PropertyNewValue, atoms[i]);

            /* Preserve name and devPrivates */
            props[j]->type = saved[i].type;
            props[j]->format = saved[i].format;
            props[j]->size = saved[i].size;
            props[j]->data = saved[i].data;
        }
    }
 out:
    free(saved);
    free(props);
    return rc;
}

int
ProcChangeProperty(ClientPtr client)
{
    WindowPtr pWin;
    char format, mode;
    unsigned long len;
    int sizeInBytes, totalSize, err;

    REQUEST(xChangePropertyReq);

    REQUEST_AT_LEAST_SIZE(xChangePropertyReq);
    UpdateCurrentTime();
    format = stuff->format;
    mode = stuff->mode;
    if ((mode != PropModeReplace) && (mode != PropModeAppend) &&
        (mode != PropModePrepend)) {
        client->errorValue = mode;
        return BadValue;
    }
    if ((format != 8) && (format != 16) && (format != 32)) {
        client->errorValue = format;
        return BadValue;
    }
    len = stuff->nUnits;
    if (len > bytes_to_int32(0xffffffff - sizeof(xChangePropertyReq)))
        return BadLength;
    sizeInBytes = format >> 3;
    totalSize = len * sizeInBytes;
    REQUEST_FIXED_SIZE(xChangePropertyReq, totalSize);

    err = dixLookupWindow(&pWin, stuff->window, client, DixSetPropAccess);
    if (err != Success)
        return err;
    if (!ValidAtom(stuff->property)) {
        client->errorValue = stuff->property;
        return BadAtom;
    }
    if (!ValidAtom(stuff->type)) {
        client->errorValue = stuff->type;
        return BadAtom;
    }

    err = dixChangeWindowProperty(client, pWin, stuff->property, stuff->type,
                                  (int) format, (int) mode, len, &stuff[1],
                                  TRUE);
    if (err != Success)
        return err;
    else
        return Success;
}

int
dixChangeWindowProperty(ClientPtr pClient, WindowPtr pWin, Atom property,
                        Atom type, int format, int mode, unsigned long len,
                        void *value, Bool sendevent)
{
    PropertyPtr pProp;
    PropertyRec savedProp;
    int sizeInBytes, totalSize, rc;
    unsigned char *data;
    Mask access_mode;

    sizeInBytes = format >> 3;
    totalSize = len * sizeInBytes;
    access_mode = (mode == PropModeReplace) ? DixWriteAccess : DixBlendAccess;

    /* first see if property already exists */
    rc = dixLookupProperty(&pProp, pWin, property, pClient, access_mode);

    if (rc == BadMatch) {       /* just add to list */
        if (!pWin->optional && !MakeWindowOptional(pWin))
            return BadAlloc;
        pProp = dixAllocateObjectWithPrivates(PropertyRec, PRIVATE_PROPERTY);
        if (!pProp)
            return BadAlloc;
        data = malloc(totalSize);
        if (!data && len) {
            dixFreeObjectWithPrivates(pProp, PRIVATE_PROPERTY);
            return BadAlloc;
        }
        memcpy(data, value, totalSize);
        pProp->propertyName = property;
        pProp->type = type;
        pProp->format = format;
        pProp->data = data;
        pProp->size = len;
        rc = XaceHookPropertyAccess(pClient, pWin, &pProp,
                                    DixCreateAccess | DixWriteAccess);
        if (rc != Success) {
            free(data);
            dixFreeObjectWithPrivates(pProp, PRIVATE_PROPERTY);
            pClient->errorValue = property;
            return rc;
        }
        pProp->next = pWin->optional->userProps;
        pWin->optional->userProps = pProp;
    }
    else if (rc == Success) {
        /* To append or prepend to a property the request format and type
           must match those of the already defined property.  The
           existing format and type are irrelevant when using the mode
           "PropModeReplace" since they will be written over. */

        if ((format != pProp->format) && (mode != PropModeReplace))
            return BadMatch;
        if ((pProp->type != type) && (mode != PropModeReplace))
            return BadMatch;

        /* save the old values for later */
        savedProp = *pProp;

        if (mode == PropModeReplace) {
            data = malloc(totalSize);
            if (!data && len)
                return BadAlloc;
            memcpy(data, value, totalSize);
            pProp->data = data;
            pProp->size = len;
            pProp->type = type;
            pProp->format = format;
        }
        else if (len == 0) {
            /* do nothing */
        }
        else if (mode == PropModeAppend) {
            data = xallocarray(pProp->size + len, sizeInBytes);
            if (!data)
                return BadAlloc;
            memcpy(data, pProp->data, pProp->size * sizeInBytes);
            memcpy(data + pProp->size * sizeInBytes, value, totalSize);
            pProp->data = data;
            pProp->size += len;
        }
        else if (mode == PropModePrepend) {
            data = xallocarray(len + pProp->size, sizeInBytes);
            if (!data)
                return BadAlloc;
            memcpy(data + totalSize, pProp->data, pProp->size * sizeInBytes);
            memcpy(data, value, totalSize);
            pProp->data = data;
            pProp->size += len;
        }

        /* Allow security modules to check the new content */
        access_mode |= DixPostAccess;
        rc = XaceHookPropertyAccess(pClient, pWin, &pProp, access_mode);
        if (rc == Success) {
            if (savedProp.data != pProp->data)
                free(savedProp.data);
        }
        else {
            if (savedProp.data != pProp->data)
                free(pProp->data);
            *pProp = savedProp;
            return rc;
        }
    }
    else
        return rc;

    if (sendevent)
        deliverPropertyNotifyEvent(pWin, PropertyNewValue, pProp->propertyName);

    return Success;
}

int
ChangeWindowProperty(WindowPtr pWin, Atom property, Atom type, int format,
                     int mode, unsigned long len, void *value, Bool sendevent)
{
    return dixChangeWindowProperty(serverClient, pWin, property, type, format,
                                   mode, len, value, sendevent);
}

int
DeleteProperty(ClientPtr client, WindowPtr pWin, Atom propName)
{
    PropertyPtr pProp, prevProp;
    int rc;

    rc = dixLookupProperty(&pProp, pWin, propName, client, DixDestroyAccess);
    if (rc == BadMatch)
        return Success;         /* Succeed if property does not exist */

    if (rc == Success) {
        if (pWin->optional->userProps == pProp) {
            /* Takes care of head */
            if (!(pWin->optional->userProps = pProp->next))
                CheckWindowOptionalNeed(pWin);
        }
        else {
            /* Need to traverse to find the previous element */
            prevProp = pWin->optional->userProps;
            while (prevProp->next != pProp)
                prevProp = prevProp->next;
            prevProp->next = pProp->next;
        }

        deliverPropertyNotifyEvent(pWin, PropertyDelete, pProp->propertyName);
        free(pProp->data);
        dixFreeObjectWithPrivates(pProp, PRIVATE_PROPERTY);
    }
    return rc;
}

void
DeleteAllWindowProperties(WindowPtr pWin)
{
    PropertyPtr pProp, pNextProp;

    pProp = wUserProps(pWin);
    while (pProp) {
        deliverPropertyNotifyEvent(pWin, PropertyDelete, pProp->propertyName);
        pNextProp = pProp->next;
        free(pProp->data);
        dixFreeObjectWithPrivates(pProp, PRIVATE_PROPERTY);
        pProp = pNextProp;
    }

    if (pWin->optional)
        pWin->optional->userProps = NULL;
}

static int
NullPropertyReply(ClientPtr client, ATOM propertyType, int format)
{
    xGetPropertyReply reply = {
        .type = X_Reply,
        .format = format,
        .sequenceNumber = client->sequence,
        .length = 0,
        .propertyType = propertyType,
        .bytesAfter = 0,
        .nItems = 0
    };
    WriteReplyToClient(client, sizeof(xGenericReply), &reply);
    return Success;
}

/*****************
 * GetProperty
 *    If type Any is specified, returns the property from the specified
 *    window regardless of its type.  If a type is specified, returns the
 *    property only if its type equals the specified type.
 *    If delete is True and a property is returned, the property is also
 *    deleted from the window and a PropertyNotify event is generated on the
 *    window.
 *****************/

int
ProcGetProperty(ClientPtr client)
{
    PropertyPtr pProp, prevProp;
    unsigned long n, len, ind;
    int rc;
    WindowPtr pWin;
    xGetPropertyReply reply;
    Mask win_mode = DixGetPropAccess, prop_mode = DixReadAccess;

    REQUEST(xGetPropertyReq);

    REQUEST_SIZE_MATCH(xGetPropertyReq);
    if (stuff->delete) {
        UpdateCurrentTime();
        win_mode |= DixSetPropAccess;
        prop_mode |= DixDestroyAccess;
    }
    rc = dixLookupWindow(&pWin, stuff->window, client, win_mode);
    if (rc != Success)
        return rc;

    if (!ValidAtom(stuff->property)) {
        client->errorValue = stuff->property;
        return BadAtom;
    }
    if ((stuff->delete != xTrue) && (stuff->delete != xFalse)) {
        client->errorValue = stuff->delete;
        return BadValue;
    }
    if ((stuff->type != AnyPropertyType) && !ValidAtom(stuff->type)) {
        client->errorValue = stuff->type;
        return BadAtom;
    }

    rc = dixLookupProperty(&pProp, pWin, stuff->property, client, prop_mode);
    if (rc == BadMatch)
        return NullPropertyReply(client, None, 0);
    else if (rc != Success)
        return rc;

    /* If the request type and actual type don't match. Return the
       property information, but not the data. */

    if (((stuff->type != pProp->type) && (stuff->type != AnyPropertyType))
        ) {
        reply = (xGetPropertyReply) {
            .type = X_Reply,
            .sequenceNumber = client->sequence,
            .bytesAfter = pProp->size,
            .format = pProp->format,
            .length = 0,
            .nItems = 0,
            .propertyType = pProp->type
        };
        WriteReplyToClient(client, sizeof(xGenericReply), &reply);
        return Success;
    }

/*
 *  Return type, format, value to client
 */
    n = (pProp->format / 8) * pProp->size;      /* size (bytes) of prop */
    ind = stuff->longOffset << 2;

    /* If longOffset is invalid such that it causes "len" to
       be negative, it's a value error. */

    if (n < ind) {
        client->errorValue = stuff->longOffset;
        return BadValue;
    }

    len = min(n - ind, 4 * stuff->longLength);

    reply = (xGetPropertyReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .bytesAfter = n - (ind + len),
        .format = pProp->format,
        .length = bytes_to_int32(len),
        .nItems = len / (pProp->format / 8),
        .propertyType = pProp->type
    };

    if (stuff->delete && (reply.bytesAfter == 0))
        deliverPropertyNotifyEvent(pWin, PropertyDelete, pProp->propertyName);

    WriteReplyToClient(client, sizeof(xGenericReply), &reply);
    if (len) {
        switch (reply.format) {
        case 32:
            client->pSwapReplyFunc = (ReplySwapPtr) CopySwap32Write;
            break;
        case 16:
            client->pSwapReplyFunc = (ReplySwapPtr) CopySwap16Write;
            break;
        default:
            client->pSwapReplyFunc = (ReplySwapPtr) WriteToClient;
            break;
        }
        WriteSwappedDataToClient(client, len, (char *) pProp->data + ind);
    }

    if (stuff->delete && (reply.bytesAfter == 0)) {
        /* Delete the Property */
        if (pWin->optional->userProps == pProp) {
            /* Takes care of head */
            if (!(pWin->optional->userProps = pProp->next))
                CheckWindowOptionalNeed(pWin);
        }
        else {
            /* Need to traverse to find the previous element */
            prevProp = pWin->optional->userProps;
            while (prevProp->next != pProp)
                prevProp = prevProp->next;
            prevProp->next = pProp->next;
        }

        free(pProp->data);
        dixFreeObjectWithPrivates(pProp, PRIVATE_PROPERTY);
    }
    return Success;
}

int
ProcListProperties(ClientPtr client)
{
    Atom *pAtoms = NULL, *temppAtoms;
    xListPropertiesReply xlpr;
    int rc, numProps = 0;
    WindowPtr pWin;
    PropertyPtr pProp, realProp;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupWindow(&pWin, stuff->id, client, DixListPropAccess);
    if (rc != Success)
        return rc;

    for (pProp = wUserProps(pWin); pProp; pProp = pProp->next)
        numProps++;

    if (numProps && !(pAtoms = xallocarray(numProps, sizeof(Atom))))
        return BadAlloc;

    numProps = 0;
    temppAtoms = pAtoms;
    for (pProp = wUserProps(pWin); pProp; pProp = pProp->next) {
        realProp = pProp;
        rc = XaceHookPropertyAccess(client, pWin, &realProp, DixGetAttrAccess);
        if (rc == Success && realProp == pProp) {
            *temppAtoms++ = pProp->propertyName;
            numProps++;
        }
    }

    xlpr = (xListPropertiesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(numProps * sizeof(Atom)),
        .nProperties = numProps
    };
    WriteReplyToClient(client, sizeof(xGenericReply), &xlpr);
    if (numProps) {
        client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
        WriteSwappedDataToClient(client, numProps * sizeof(Atom), pAtoms);
    }
    free(pAtoms);
    return Success;
}

int
ProcDeleteProperty(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xDeletePropertyReq);
    int result;

    REQUEST_SIZE_MATCH(xDeletePropertyReq);
    UpdateCurrentTime();
    result = dixLookupWindow(&pWin, stuff->window, client, DixSetPropAccess);
    if (result != Success)
        return result;
    if (!ValidAtom(stuff->property)) {
        client->errorValue = stuff->property;
        return BadAtom;
    }

    return DeleteProperty(client, pWin, stuff->property);
}
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d139 2
a140 2
    props = malloc(stuff->nAtoms * sizeof(PropertyPtr));
    saved = malloc(stuff->nAtoms * sizeof(PropertyRec));
d316 1
a316 1
            data = malloc((pProp->size + len) * sizeInBytes);
d325 1
a325 1
            data = malloc(sizeInBytes * (len + pProp->size));
d584 1
a584 1
    if (numProps && !(pAtoms = malloc(numProps * sizeof(Atom))))
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d245 1
a245 1
                        pointer value, Bool sendevent)
d359 1
a359 1
                     int mode, unsigned long len, pointer value, Bool sendevent)
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d111 6
a116 3
    xEvent event;

    memset(&event, 0, sizeof(xEvent));
a117 4
    event.u.property.window = pWin->drawable.id;
    event.u.property.state = state;
    event.u.property.atom = atom;
    event.u.property.time = currentTime.milliseconds;
d415 1
a415 2
NullPropertyReply(ClientPtr client,
                  ATOM propertyType, int format, xGetPropertyReply * reply)
d417 10
a426 6
    reply->nItems = 0;
    reply->length = 0;
    reply->bytesAfter = 0;
    reply->propertyType = propertyType;
    reply->format = format;
    WriteReplyToClient(client, sizeof(xGenericReply), reply);
a474 4
    memset(&reply, 0, sizeof(xGetPropertyReply));
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;

d477 1
a477 1
        return NullPropertyReply(client, None, 0, &reply);
d486 9
a494 5
        reply.bytesAfter = pProp->size;
        reply.format = pProp->format;
        reply.length = 0;
        reply.nItems = 0;
        reply.propertyType = pProp->type;
d515 9
a523 5
    reply.bytesAfter = n - (ind + len);
    reply.format = pProp->format;
    reply.length = bytes_to_int32(len);
    reply.nItems = len / (pProp->format / 8);
    reply.propertyType = pProp->type;
d598 6
a603 4
    xlpr.type = X_Reply;
    xlpr.nProperties = numProps;
    xlpr.length = bytes_to_int32(numProps * sizeof(Atom));
    xlpr.sequenceNumber = client->sequence;
@


1.6
log
@Update to xserver 1.11.2
@
text
@a24 1

d78 1
a78 2
    while (pProp)
    {
d82 2
a83 2
        for (j=0; j<(pProp->format/8)*pProp->size; j++)
           ErrorF("[dix] %c\n", pProp->data[j]);
d91 1
a91 1
		  ClientPtr client, Mask access_mode)
d95 1
d99 2
a100 2
	if (pProp->propertyName == propertyName)
	    break;
d103 1
a103 1
	rc = XaceHookPropertyAccess(client, pWin, &pProp, access_mode);
d119 1
a119 1
    DeliverEvents(pWin, &event, 1, (WindowPtr)NULL);
d125 2
a126 1
    int     i, j, delta, rc;
d129 2
a130 2
    Atom * atoms;
    PropertyPtr * props;               /* array of pointer */
d139 1
a139 1
    atoms = (Atom *) & stuff[1];
d143 2
a144 2
	rc = BadAlloc;
	goto out;
d147 1
a147 2
    for (i = 0; i < stuff->nAtoms; i++)
    {
d149 3
a151 3
	    rc = BadAtom;
	    client->errorValue = atoms[i];
	    goto out;
d154 3
a156 4
            if (atoms[j] == atoms[i])
            {
		rc = BadMatch;
		goto out;
d159 4
a162 4
	rc = dixLookupProperty(&pProp, pWin, atoms[i], client,
			       DixReadAccess|DixWriteAccess);
	if (rc != Success)
	    goto out;
d165 1
a165 1
	saved[i] = *pProp;
d170 1
a170 1
	around and generating PropertyNotify events should be skipped. */
d172 2
a173 3
    if (abs(delta) % stuff->nAtoms)
    {
	while (delta < 0)                  /* faster if abs value is small */
d175 10
a184 11
    	for (i = 0; i < stuff->nAtoms; i++)
 	{
	    j = (i + delta) % stuff->nAtoms;
	    deliverPropertyNotifyEvent(pWin, PropertyNewValue, atoms[i]);

	    /* Preserve name and devPrivates */
	    props[j]->type = saved[i].type;
	    props[j]->format = saved[i].format;
	    props[j]->size = saved[i].size;
	    props[j]->data = saved[i].data;
	}
d186 1
a186 1
out:
d192 1
a192 1
int 
d194 1
a194 1
{	      
d199 1
d207 6
a212 8
	(mode != PropModePrepend))
    {
	client->errorValue = mode;
	return BadValue;
    }
    if ((format != 8) && (format != 16) && (format != 32))
    {
	client->errorValue = format;
d217 2
a218 2
	return BadLength;
    sizeInBytes = format>>3;
d224 8
a231 10
	return err;
    if (!ValidAtom(stuff->property))
    {
	client->errorValue = stuff->property;
	return BadAtom;
    }
    if (!ValidAtom(stuff->type))
    {
	client->errorValue = stuff->type;
	return BadAtom;
d235 2
a236 2
				  (int)format, (int)mode, len, &stuff[1],
				  TRUE);
d238 1
a238 1
	return err;
d240 1
a240 1
	return Success;
d245 2
a246 2
			Atom type, int format, int mode, unsigned long len,
			pointer value, Bool sendevent)
d254 1
a254 1
    sizeInBytes = format>>3;
d261 6
a266 7
    if (rc == BadMatch)   /* just add to list */
    {
	if (!pWin->optional && !MakeWindowOptional (pWin))
	    return BadAlloc;
	pProp = dixAllocateObjectWithPrivates(PropertyRec, PRIVATE_PROPERTY);
	if (!pProp)
	    return BadAlloc;
d268 4
a271 5
	if (!data && len)
	{
	    dixFreeObjectWithPrivates(pProp, PRIVATE_PROPERTY);
	    return BadAlloc;
	}
d277 9
a285 9
	pProp->size = len;
	rc = XaceHookPropertyAccess(pClient, pWin, &pProp,
				    DixCreateAccess|DixWriteAccess);
	if (rc != Success) {
	    free(data);
	    dixFreeObjectWithPrivates(pProp, PRIVATE_PROPERTY);
	    pClient->errorValue = property;
	    return rc;
	}
d289 5
a293 6
    else if (rc == Success)
    {
	/* To append or prepend to a property the request format and type
		must match those of the already defined property.  The
		existing format and type are irrelevant when using the mode
		"PropModeReplace" since they will be written over. */
d296 1
a296 1
	    return BadMatch;
d300 2
a301 2
	/* save the old values for later */
	savedProp = *pProp;
d303 19
a321 22
        if (mode == PropModeReplace)
        {
	    data = malloc(totalSize);
	    if (!data && len)
		return BadAlloc;
	    memcpy(data, value, totalSize);
	    pProp->data = data;
	    pProp->size = len;
    	    pProp->type = type;
	    pProp->format = format;
	}
	else if (len == 0)
	{
	    /* do nothing */
	}
        else if (mode == PropModeAppend)
        {
	    data = malloc((pProp->size + len) * sizeInBytes);
	    if (!data)
		return BadAlloc;
	    memcpy(data, pProp->data, pProp->size * sizeInBytes);
	    memcpy(data + pProp->size * sizeInBytes, value, totalSize);
d324 2
a325 3
	}
        else if (mode == PropModePrepend)
        {
d327 2
a328 2
	    if (!data)
		return BadAlloc;
d333 1
a333 1
	}
d335 13
a347 15
	/* Allow security modules to check the new content */
	access_mode |= DixPostAccess;
	rc = XaceHookPropertyAccess(pClient, pWin, &pProp, access_mode);
	if (rc == Success)
	{
	    if (savedProp.data != pProp->data)
		free(savedProp.data);
	}
	else
	{
	    if (savedProp.data != pProp->data)
		free(pProp->data);
	    *pProp = savedProp;
	    return rc;
	}
d350 1
a350 1
	return rc;
d353 1
a353 1
	deliverPropertyNotifyEvent(pWin, PropertyNewValue, pProp->propertyName);
d359 2
a360 3
ChangeWindowProperty(WindowPtr pWin, Atom property, Atom type, int format, 
		     int mode, unsigned long len, pointer value, 
		     Bool sendevent)
d363 1
a363 1
				   mode, len, value, sendevent);
d374 1
a374 1
	return Success; /* Succeed if property does not exist */
d377 2
a378 2
	if (pWin->optional->userProps == pProp) {
	    /* Takes care of head */
d380 13
a392 12
		CheckWindowOptionalNeed (pWin);
	} else {
	    /* Need to traverse to find the previous element */
	    prevProp = pWin->optional->userProps;
	    while (prevProp->next != pProp)
		prevProp = prevProp->next;
	    prevProp->next = pProp->next;
	}

	deliverPropertyNotifyEvent(pWin, PropertyDelete, pProp->propertyName);
	free(pProp->data);
	dixFreeObjectWithPrivates(pProp, PRIVATE_PROPERTY);
d402 4
a405 5
    pProp = wUserProps (pWin);
    while (pProp)
    {
	deliverPropertyNotifyEvent(pWin, PropertyDelete, pProp->propertyName);
	pNextProp = pProp->next;
d407 2
a408 2
	dixFreeObjectWithPrivates(pProp, PRIVATE_PROPERTY);
	pProp = pNextProp;
d416 2
a417 5
NullPropertyReply(
    ClientPtr client,
    ATOM propertyType,
    int format,
    xGetPropertyReply *reply)
d447 1
d452 3
a454 3
	UpdateCurrentTime();
	win_mode |= DixSetPropAccess;
	prop_mode |= DixDestroyAccess;
d458 1
a458 1
	return (rc == BadMatch) ? BadWindow : rc;
d460 11
a470 14
    if (!ValidAtom(stuff->property))
    {
	client->errorValue = stuff->property;
	return BadAtom;
    }
    if ((stuff->delete != xTrue) && (stuff->delete != xFalse))
    {
	client->errorValue = stuff->delete;
	return BadValue;
    }
    if ((stuff->type != AnyPropertyType) && !ValidAtom(stuff->type))
    {
	client->errorValue = stuff->type;
	return BadAtom;
d479 1
a479 1
	return NullPropertyReply(client, None, 0, &reply);
d481 1
a481 1
	return rc;
d484 1
a484 1
    property information, but not the data. */
d486 9
a494 11
    if (((stuff->type != pProp->type) &&
	 (stuff->type != AnyPropertyType))
       )
    {
	reply.bytesAfter = pProp->size;
	reply.format = pProp->format;
	reply.length = 0;
	reply.nItems = 0;
	reply.propertyType = pProp->type;
	WriteReplyToClient(client, sizeof(xGenericReply), &reply);
	return Success;
d500 2
a501 2
    n = (pProp->format/8) * pProp->size; /* size (bytes) of prop */
    ind = stuff->longOffset << 2;        
d503 2
a504 2
   /* If longOffset is invalid such that it causes "len" to
	    be negative, it's a value error. */
d506 3
a508 4
    if (n < ind)
    {
	client->errorValue = stuff->longOffset;
	return BadValue;
d516 1
a516 1
    reply.nItems = len / (pProp->format / 8 );
d520 1
a520 1
	deliverPropertyNotifyEvent(pWin, PropertyDelete, pProp->propertyName);
d523 13
a535 9
    if (len)
    {
	switch (reply.format) {
	case 32: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap32Write; break;
	case 16: client->pSwapReplyFunc = (ReplySwapPtr)CopySwap16Write; break;
	default: client->pSwapReplyFunc = (ReplySwapPtr)WriteToClient; break;
	}
	WriteSwappedDataToClient(client, len,
				 (char *)pProp->data + ind);
d539 3
a541 3
	/* Delete the Property */
	if (pWin->optional->userProps == pProp) {
	    /* Takes care of head */
d543 9
a551 8
		CheckWindowOptionalNeed (pWin);
	} else {
	    /* Need to traverse to find the previous element */
	    prevProp = pWin->optional->userProps;
	    while (prevProp->next != pProp)
		prevProp = prevProp->next;
	    prevProp->next = pProp->next;
	}
d553 2
a554 2
	free(pProp->data);
	dixFreeObjectWithPrivates(pProp, PRIVATE_PROPERTY);
d564 1
a564 1
    int	rc, numProps = 0;
d567 1
d576 1
a576 1
	numProps++;
d579 1
a579 1
	return BadAlloc;
d584 6
a589 6
	realProp = pProp;
	rc = XaceHookPropertyAccess(client, pWin, &realProp, DixGetAttrAccess);
	if (rc == Success && realProp == pProp) {
	    *temppAtoms++ = pProp->propertyName;
	    numProps++;
	}
d597 2
a598 3
    if (numProps)
    {
        client->pSwapReplyFunc = (ReplySwapPtr)Swap32Write;
d605 1
a605 1
int 
d609 1
d612 1
a612 1
              
d618 3
a620 4
    if (!ValidAtom(stuff->property))
    {
	client->errorValue = stuff->property;
	return BadAtom;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d427 3
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d140 2
a141 2
    props = xalloc(stuff->nAtoms * sizeof(PropertyPtr));
    saved = xalloc(stuff->nAtoms * sizeof(PropertyRec));
d191 2
a192 2
    xfree(saved);
    xfree(props);
d233 1
a233 1
	return(BadAtom);
d238 1
a238 1
	return(BadAtom);
d247 1
a247 1
	return client->noClientException;
d271 2
a272 2
	    return(BadAlloc);
        pProp = xalloc(sizeof(PropertyRec));
d274 2
a275 2
	    return(BadAlloc);
        data = xalloc(totalSize);
d278 2
a279 2
	    xfree(pProp);
	    return(BadAlloc);
a286 1
	pProp->devPrivates = NULL;
d290 2
a291 2
	    xfree(data);
	    xfree(pProp);
d306 1
a306 1
	    return(BadMatch);
d308 1
a308 1
            return(BadMatch);
d315 1
a315 1
	    data = xalloc(totalSize);
d317 1
a317 1
		return(BadAlloc);
d330 1
a330 1
	    data = xalloc((pProp->size + len) * sizeInBytes);
d332 1
a332 1
		return(BadAlloc);
d340 1
a340 1
            data = xalloc(sizeInBytes * (len + pProp->size));
d342 1
a342 1
		return(BadAlloc);
d355 1
a355 1
		xfree(savedProp.data);
d360 1
a360 1
		xfree(pProp->data);
d371 1
a371 1
    return(Success);
d407 2
a408 3
	dixFreePrivates(pProp->devPrivates);
	xfree(pProp->data);
        xfree(pProp);
d423 2
a424 3
	dixFreePrivates(pProp->devPrivates);
        xfree(pProp->data);
        xfree(pProp);
d442 1
a442 1
    return(client->noClientException);
d479 1
a479 1
	return(BadAtom);
d484 1
a484 1
	return(BadValue);
d489 1
a489 1
	return(BadAtom);
d515 1
a515 1
	return(Success);
d570 2
a571 3
	dixFreePrivates(pProp->devPrivates);
	xfree(pProp->data);
	xfree(pProp);
d573 1
a573 1
    return(client->noClientException);
d594 1
a594 1
    if (numProps && !(pAtoms = xalloc(numProps * sizeof(Atom))))
d618 2
a619 2
    xfree(pAtoms);
    return(client->noClientException);
d637 1
a637 1
	return (BadAtom);
d640 1
a640 5
    result = DeleteProperty(client, pWin, stuff->property);
    if (client->noClientException != Success)
	return(client->noClientException);
    else
	return(result);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a52 2
#define NEED_REPLIES
#define NEED_EVENTS
d91 1
a91 1
_X_EXPORT int
d114 1
d140 2
a141 2
    props = (PropertyPtr *)xalloc(stuff->nAtoms * sizeof(PropertyPtr));
    saved = (PropertyPtr)xalloc(stuff->nAtoms * sizeof(PropertyRec));
d221 1
a221 1
    if (len > ((0xffffffff - sizeof(xChangePropertyReq)) >> 2))
d250 1
a250 1
_X_EXPORT int
d256 1
d258 1
a258 1
    pointer data;
d272 1
a272 1
        pProp = (PropertyPtr)xalloc(sizeof(PropertyRec));
d275 1
a275 1
        data = (pointer)xalloc(totalSize);
d281 1
a285 2
	if (len)
	    memmove((char *)data, (char *)value, totalSize);
d310 4
d316 5
a320 9
	    if (totalSize != pProp->size * (pProp->format >> 3))
	    {
	    	data = (pointer)xrealloc(pProp->data, totalSize);
	    	if (!data && len)
		    return(BadAlloc);
            	pProp->data = data;
	    }
	    if (len)
		memmove((char *)pProp->data, (char *)value, totalSize);
d331 1
a331 2
	    data = (pointer)xrealloc(pProp->data,
				     sizeInBytes * (len + pProp->size));
d334 2
a336 3
	    memmove(&((char *)data)[pProp->size * sizeInBytes], 
		    (char *)value,
		  totalSize);
d341 1
a341 1
            data = (pointer)xalloc(sizeInBytes * (len + pProp->size));
d344 2
a345 4
	    memmove(&((char *)data)[totalSize], (char *)pProp->data, 
		  (int)(pProp->size * sizeInBytes));
            memmove((char *)data, (char *)value, totalSize);
	    xfree(pProp->data);
d349 16
d375 1
a375 1
_X_EXPORT int
d477 1
a477 1
	return rc;
d495 1
d540 1
a540 1
    reply.length = (len + 3) >> 2;
d598 1
a598 1
    if (numProps && !(pAtoms = (Atom *)xalloc(numProps * sizeof(Atom))))
d614 1
a614 1
    xlpr.length = (numProps * sizeof(Atom)) >> 2;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d83 3
a85 3
        ErrorF(  "%x %x\n", pProp->propertyName, pProp->type);
        ErrorF("property format: %d\n", pProp->format);
        ErrorF("property data: \n");
d87 1
a87 1
           ErrorF("%c\n", pProp->data[j]);
@


1.1
log
@Initial revision
@
text
@a60 1
#ifdef XACE
a61 1
#endif
d66 1
a66 2
 *    ChangeProperty, DeleteProperty, GetProperties,
 *    ListProperties
d68 2
a69 2
 *   Properties below to windows.  A allocate slots each time
 *   a property is added.  No fancy searching done.
d78 1
a78 1
    register int j;
d93 31
d127 1
a127 1
    int     i, j, delta;
d130 1
a130 1
    register    Atom * atoms;
d132 1
a132 2
    PropertyPtr pProp;
    xEvent event;
d136 4
a139 6
    pWin = (WindowPtr) SecurityLookupWindow(stuff->window, client,
					    SecurityWriteAccess);
    if (!pWin)
        return(BadWindow);
    if (!stuff->nAtoms)
	return(Success);
d141 7
a147 3
    props = (PropertyPtr *)ALLOCATE_LOCAL(stuff->nAtoms * sizeof(PropertyPtr));
    if (!props)
	return(BadAlloc);
d150 2
a151 11
#ifdef XACE
	char action = XaceHook(XACE_PROPERTY_ACCESS, client, pWin, atoms[i],
				SecurityReadAccess|SecurityWriteAccess);
#endif
        if (!ValidAtom(atoms[i])
#ifdef XACE
	    || (SecurityErrorOperation == action)
#endif
	   )
        {
            DEALLOCATE_LOCAL(props);
d153 1
a153 1
            return BadAtom;
a154 7
#ifdef XACE
	if (SecurityIgnoreOperation == action)
        {
            DEALLOCATE_LOCAL(props);
	    return Success;
	}
#endif
d158 2
a159 2
                DEALLOCATE_LOCAL(props);
                return BadMatch;
d161 6
a166 10
        pProp = wUserProps (pWin);
        while (pProp)
        {
            if (pProp->propertyName == atoms[i])
                goto found;
	    pProp = pProp->next;
        }
        DEALLOCATE_LOCAL(props);
        return BadMatch;
found: 
d168 1
d175 1
a175 1
    if ( (stuff->nAtoms != 0) && (abs(delta) % stuff->nAtoms) != 0 ) 
d181 8
a188 11
	    /* Generate a PropertyNotify event for each property whose value
		is changed in the order in which they appear in the request. */
 
 	    event.u.u.type = PropertyNotify;
            event.u.property.window = pWin->drawable.id;
    	    event.u.property.state = PropertyNewValue;
	    event.u.property.atom = props[i]->propertyName;	
	    event.u.property.time = currentTime.milliseconds;
	    DeliverEvents(pWin, &event, 1, (WindowPtr)NULL);
	
            props[i]->propertyName = atoms[(i + delta) % stuff->nAtoms];
d191 4
a194 2
    DEALLOCATE_LOCAL(props);
    return Success;
d203 1
a203 3
    int sizeInBytes;
    int totalSize;
    int err;
d228 3
a230 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityWriteAccess);
    if (!pWin)
	return(BadWindow);
d242 3
a244 14
#ifdef XACE
    switch (XaceHook(XACE_PROPERTY_ACCESS, client, pWin, stuff->property,
					SecurityWriteAccess))
    {
	case SecurityErrorOperation:
	    client->errorValue = stuff->property;
	    return BadAtom;
	case SecurityIgnoreOperation:
	    return Success;
    }
#endif

    err = ChangeWindowProperty(pWin, stuff->property, stuff->type, (int)format,
			       (int)mode, len, (pointer)&stuff[1], TRUE);
d252 3
a254 3
ChangeWindowProperty(WindowPtr pWin, Atom property, Atom type, int format, 
                     int mode, unsigned long len, pointer value, 
                     Bool sendevent)
d257 1
a257 3
    xEvent event;
    int sizeInBytes;
    int totalSize;
d259 1
d263 1
d266 1
d268 1
a268 8
    pProp = wUserProps (pWin);
    while (pProp)
    {
	if (pProp->propertyName == property)
	    break;
	pProp = pProp->next;
    }
    if (!pProp)   /* just add to list */
d288 9
d300 1
a300 1
    else
d355 3
d359 2
a360 8
    {
	event.u.u.type = PropertyNotify;
	event.u.property.window = pWin->drawable.id;
	event.u.property.state = PropertyNewValue;
	event.u.property.atom = pProp->propertyName;
	event.u.property.time = currentTime.milliseconds;
	DeliverEvents(pWin, &event, 1, (WindowPtr)NULL);
    }
d364 9
d374 1
a374 1
DeleteProperty(WindowPtr pWin, Atom propName)
d377 1
a377 1
    xEvent event;
d379 7
a385 14
    if (!(pProp = wUserProps (pWin)))
	return(Success);
    prevProp = (PropertyPtr)NULL;
    while (pProp)
    {
	if (pProp->propertyName == propName)
	    break;
        prevProp = pProp;
	pProp = pProp->next;
    }
    if (pProp) 
    {		    
        if (prevProp == (PropertyPtr)NULL)      /* takes care of head */
        {
d388 10
a397 11
        }
	else
        {
            prevProp->next = pProp->next;
        }
	event.u.u.type = PropertyNotify;
	event.u.property.window = pWin->drawable.id;
	event.u.property.state = PropertyDelete;
        event.u.property.atom = pProp->propertyName;
	event.u.property.time = currentTime.milliseconds;
	DeliverEvents(pWin, &event, 1, (WindowPtr)NULL);
d401 1
a401 1
    return(Success);
a407 1
    xEvent event;
d412 1
a412 6
	event.u.u.type = PropertyNotify;
	event.u.property.window = pWin->drawable.id;
	event.u.property.state = PropertyDelete;
	event.u.property.atom = pProp->propertyName;
	event.u.property.time = currentTime.milliseconds;
	DeliverEvents(pWin, &event, 1, (WindowPtr)NULL);
d414 1
d452 1
d455 1
d459 1
a459 1
    if (stuff->delete)
d461 6
a466 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityReadAccess);
    if (!pWin)
	return BadWindow;
a483 10
    pProp = wUserProps (pWin);
    prevProp = (PropertyPtr)NULL;
    while (pProp)
    {
	if (pProp->propertyName == stuff->property) 
	    break;
	prevProp = pProp;
	pProp = pProp->next;
    }

d486 3
a488 1
    if (!pProp) 
d490 2
a492 18
#ifdef XACE
    {
	Mask access_mode = SecurityReadAccess;

	if (stuff->delete)
	    access_mode |= SecurityDestroyAccess;
	switch(XaceHook(XACE_PROPERTY_ACCESS, client, pWin, stuff->property,
					   access_mode))
	{
	    case SecurityErrorOperation:
		client->errorValue = stuff->property;
		return BadAtom;;
	    case SecurityIgnoreOperation:
		return NullPropertyReply(client, pProp->type, pProp->format,
					 &reply);
	}
    }
#endif
d533 1
a533 10
    { /* send the event */
	xEvent event;

	event.u.u.type = PropertyNotify;
	event.u.property.window = pWin->drawable.id;
	event.u.property.state = PropertyDelete;
	event.u.property.atom = pProp->propertyName;
	event.u.property.time = currentTime.milliseconds;
	DeliverEvents(pWin, &event, 1, (WindowPtr)NULL);
    }
d547 5
a551 5
    if (stuff->delete && (reply.bytesAfter == 0))
    { /* delete the Property */
	if (prevProp == (PropertyPtr)NULL) /* takes care of head */
	{
	    if (!(pWin->optional->userProps = pProp->next))
d553 6
d560 2
a561 2
	else
	    prevProp->next = pProp->next;
d573 1
a573 1
    int	numProps = 0;
d575 1
a575 1
    PropertyPtr pProp;
d579 3
a581 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->id, client,
					   SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
d583 1
a583 4
    pProp = wUserProps (pWin);
    while (pProp)
    {        
        pProp = pProp->next;
d585 13
a598 3
    if (numProps)
        if(!(pAtoms = (Atom *)ALLOCATE_LOCAL(numProps * sizeof(Atom))))
            return(BadAlloc);
a603 7
    pProp = wUserProps (pWin);
    temppAtoms = pAtoms;
    while (pProp)
    {
	*temppAtoms++ = pProp->propertyName;
	pProp = pProp->next;
    }
a608 1
        DEALLOCATE_LOCAL(pAtoms);
d610 1
d615 1
a615 1
ProcDeleteProperty(register ClientPtr client)
d623 3
a625 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityWriteAccess);
    if (!pWin)
        return(BadWindow);
d632 1
a632 13
#ifdef XACE
    switch(XaceHook(XACE_PROPERTY_ACCESS, client, pWin, stuff->property,
				       SecurityDestroyAccess))
    {
	case SecurityErrorOperation:
	    client->errorValue = stuff->property;
	    return BadAtom;;
	case SecurityIgnoreOperation:
	    return Success;
    }
#endif

    result = DeleteProperty(pWin, stuff->property);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d61 1
d63 1
d81 1
a81 1
    int j;
a95 13
static void
deliverPropertyNotifyEvent(WindowPtr pWin, int state, Atom atom)
{
    xEvent event;

    event.u.u.type = PropertyNotify;
    event.u.property.window = pWin->drawable.id;
    event.u.property.state = state;
    event.u.property.atom = atom;
    event.u.property.time = currentTime.milliseconds;
    DeliverEvents(pWin, &event, 1, (WindowPtr)NULL);
}

d99 1
a99 1
    int     i, j, delta, rc;
d102 1
a102 1
    Atom * atoms;
d105 1
d109 4
a112 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (rc != Success)
        return rc;
d121 1
d123 8
a130 3
				DixReadAccess|DixWriteAccess);

        if (!ValidAtom(atoms[i]) || (XaceErrorOperation == action)) {
d135 3
a137 1
	if (XaceIgnoreOperation == action) {
d141 1
a141 1

d171 2
a172 2
	    deliverPropertyNotifyEvent(pWin, PropertyNewValue,
				       props[i]->propertyName);
d174 7
d194 3
a196 1
    int sizeInBytes, totalSize, err;
d221 4
a224 3
    err = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (err != Success)
	return err;
d236 1
d238 1
a238 1
		     DixWriteAccess))
d240 5
a244 5
    case XaceErrorOperation:
	client->errorValue = stuff->property;
	return BadAtom;
    case XaceIgnoreOperation:
	return Success;
d246 1
d262 1
a356 1

d358 8
a365 2
	deliverPropertyNotifyEvent(pWin, PropertyNewValue, pProp->propertyName);

d373 1
d396 6
a401 1
	deliverPropertyNotifyEvent(pWin, PropertyDelete, pProp->propertyName);
d412 1
d417 6
a422 1
	deliverPropertyNotifyEvent(pWin, PropertyDelete, pProp->propertyName);
d460 1
a460 1
    unsigned long n, len, ind, rc;
a462 1
    Mask access_mode = DixReadAccess;
d468 4
a471 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
    if (rc != Success)
	return rc;
d504 1
a504 4
    if (stuff->delete)
	access_mode |= DixDestroyAccess;
    switch (XaceHook(XACE_PROPERTY_ACCESS, client, pWin, stuff->property,
		     access_mode))
d506 14
a519 5
    case XaceErrorOperation:
	client->errorValue = stuff->property;
	return BadAtom;;
    case XaceIgnoreOperation:
	return NullPropertyReply(client, pProp->type, pProp->format, &reply);
d521 1
a521 1

d562 10
a571 1
	deliverPropertyNotifyEvent(pWin, PropertyDelete, pProp->propertyName);
d605 1
a605 1
    int	rc, numProps = 0;
d611 4
a614 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixReadAccess);
    if (rc != Success)
        return rc;
d648 1
a648 1
ProcDeleteProperty(ClientPtr client)
d656 4
a659 3
    result = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (result != Success)
        return result;
d666 9
a674 8
    switch (XaceHook(XACE_PROPERTY_ACCESS, client, pWin, stuff->property,
		     DixDestroyAccess))
    {
    case XaceErrorOperation:
	client->errorValue = stuff->property;
	return BadAtom;;
    case XaceIgnoreOperation:
	return Success;
d676 1
@

