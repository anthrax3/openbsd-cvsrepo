head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.31.07.52.35;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.28;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.28;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.19;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*

(c)Copyright 1988,1991 Adobe Systems Incorporated. All rights reserved.

Permission to use, copy, modify, distribute, and sublicense this software and its
documentation for any purpose and without fee is hereby granted, provided that
the above copyright notices appear in all copies and that both those copyright
notices and this permission notice appear in supporting documentation and that
the name of Adobe Systems Incorporated not be used in advertising or publicity
pertaining to distribution of the software without specific, written prior
permission.  No trademark license to use the Adobe trademarks is hereby
granted.  If the Adobe trademark "Display PostScript"(tm) is used to describe
this software, its functionality or for any other purpose, such use shall be
limited to a statement that this software works in conjunction with the Display
PostScript system.  Proper trademark attribution to reflect Adobe's ownership
of the trademark shall be given whenever any such reference to the Display
PostScript system is made.

ADOBE MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THE SOFTWARE FOR ANY
PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.  ADOBE
DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-
INFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO EVENT SHALL ADOBE BE LIABLE TO YOU
OR ANY OTHER PARTY FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
DAMAGES WHATSOEVER WHETHER IN AN ACTION OF CONTRACT,NEGLIGENCE, STRICT
LIABILITY OR ANY OTHER ACTION ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.  ADOBE WILL NOT PROVIDE ANY TRAINING OR OTHER
SUPPORT FOR THE SOFTWARE.

Adobe, PostScript, and Display PostScript are trademarks of Adobe Systems
Incorporated which may be registered in certain jurisdictions.

Author:  Adobe Systems Incorporated

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xmd.h>
#include "misc.h"
#include "windowstr.h"
#include "dixstruct.h"
#include "pixmapstr.h"
#include "gcstruct.h"
#include "scrnintstr.h"
#define  XK_LATIN1
#include <X11/keysymdef.h>
#include "xace.h"

/*
 * CompareTimeStamps returns -1, 0, or +1 depending on if the first
 * argument is less than, equal to or greater than the second argument.
 */

int
CompareTimeStamps(TimeStamp a, TimeStamp b)
{
    if (a.months < b.months)
        return EARLIER;
    if (a.months > b.months)
        return LATER;
    if (a.milliseconds < b.milliseconds)
        return EARLIER;
    if (a.milliseconds > b.milliseconds)
        return LATER;
    return SAMETIME;
}

/*
 * convert client times to server TimeStamps
 */

#define HALFMONTH ((unsigned long) 1<<31)
TimeStamp
ClientTimeToServerTime(CARD32 c)
{
    TimeStamp ts;

    if (c == CurrentTime)
        return currentTime;
    ts.months = currentTime.months;
    ts.milliseconds = c;
    if (c > currentTime.milliseconds) {
        if (((unsigned long) c - currentTime.milliseconds) > HALFMONTH)
            ts.months -= 1;
    }
    else if (c < currentTime.milliseconds) {
        if (((unsigned long) currentTime.milliseconds - c) > HALFMONTH)
            ts.months += 1;
    }
    return ts;
}

/*
 * ISO Latin-1 case conversion routine
 *
 * this routine always null-terminates the result, so
 * beware of too-small buffers
 */

static unsigned char
ISOLatin1ToLower(unsigned char source)
{
    unsigned char dest;

    if ((source >= XK_A) && (source <= XK_Z))
        dest = source + (XK_a - XK_A);
    else if ((source >= XK_Agrave) && (source <= XK_Odiaeresis))
        dest = source + (XK_agrave - XK_Agrave);
    else if ((source >= XK_Ooblique) && (source <= XK_Thorn))
        dest = source + (XK_oslash - XK_Ooblique);
    else
        dest = source;
    return dest;
}

int
CompareISOLatin1Lowered(const unsigned char *s1, int s1len,
                        const unsigned char *s2, int s2len)
{
    unsigned char c1, c2;

    for (;;) {
        /* note -- compare against zero so that -1 ignores len */
        c1 = s1len-- ? *s1++ : '\0';
        c2 = s2len-- ? *s2++ : '\0';
        if (!c1 ||
            (c1 != c2 &&
             (c1 = ISOLatin1ToLower(c1)) != (c2 = ISOLatin1ToLower(c2))))
            break;
    }
    return (int) c1 - (int) c2;
}

/*
 * dixLookupWindow and dixLookupDrawable:
 * Look up the window/drawable taking into account the client doing the
 * lookup, the type of drawable desired, and the type of access desired.
 * Return Success with *pDraw set if the window/drawable exists and the client
 * is allowed access, else return an error code with *pDraw set to NULL.  The
 * access mask values are defined in resource.h.  The type mask values are
 * defined in pixmap.h, with zero equivalent to M_DRAWABLE.
 */
int
dixLookupDrawable(DrawablePtr *pDraw, XID id, ClientPtr client,
                  Mask type, Mask access)
{
    DrawablePtr pTmp;
    int rc;

    *pDraw = NULL;

    rc = dixLookupResourceByClass((void **) &pTmp, id, RC_DRAWABLE, client,
                                  access);

    if (rc != Success)
        client->errorValue = id;

    if (rc == BadValue)
        return BadDrawable;
    if (rc != Success)
        return rc;
    if (!((1 << pTmp->type) & (type ? type : M_DRAWABLE)))
        return BadMatch;

    *pDraw = pTmp;
    return Success;
}

int
dixLookupWindow(WindowPtr *pWin, XID id, ClientPtr client, Mask access)
{
    int rc;

    rc = dixLookupDrawable((DrawablePtr *) pWin, id, client, M_WINDOW, access);
    /* dixLookupDrawable returns BadMatch iff id is a valid Drawable
       but is not a Window. Users of dixLookupWindow expect a BadWindow
       error in this case; they don't care that it's a valid non-Window XID */
    if (rc == BadMatch)
        rc = BadWindow;
    /* Similarly, users of dixLookupWindow don't want BadDrawable. */
    if (rc == BadDrawable)
        rc = BadWindow;
    return rc;
}

int
dixLookupGC(GCPtr *pGC, XID id, ClientPtr client, Mask access)
{
    return dixLookupResourceByType((void **) pGC, id, RT_GC, client, access);
}

int
dixLookupFontable(FontPtr *pFont, XID id, ClientPtr client, Mask access)
{
    int rc;
    GC *pGC;

    client->errorValue = id;    /* EITHER font or gc */
    rc = dixLookupResourceByType((void **) pFont, id, RT_FONT, client,
                                 access);
    if (rc != BadFont)
        return rc;
    rc = dixLookupResourceByType((void **) &pGC, id, RT_GC, client, access);
    if (rc == BadGC)
        return BadFont;
    if (rc == Success)
        *pFont = pGC->font;
    return rc;
}

int
dixLookupClient(ClientPtr *pClient, XID rid, ClientPtr client, Mask access)
{
    void *pRes;
    int rc = BadValue, clientIndex = CLIENT_ID(rid);

    if (!clientIndex || !clients[clientIndex] || (rid & SERVER_BIT))
        goto bad;

    rc = dixLookupResourceByClass(&pRes, rid, RC_ANY, client, DixGetAttrAccess);
    if (rc != Success)
        goto bad;

    rc = XaceHook(XACE_CLIENT_ACCESS, client, clients[clientIndex], access);
    if (rc != Success)
        goto bad;

    *pClient = clients[clientIndex];
    return Success;
 bad:
    if (client)
        client->errorValue = rid;
    *pClient = NULL;
    return rc;
}

int
AlterSaveSetForClient(ClientPtr client, WindowPtr pWin, unsigned mode,
                      Bool toRoot, Bool map)
{
    int numnow;
    SaveSetElt *pTmp = NULL;
    int j;

    numnow = client->numSaved;
    j = 0;
    if (numnow) {
        pTmp = client->saveSet;
        while ((j < numnow) && (SaveSetWindow(pTmp[j]) != (void *) pWin))
            j++;
    }
    if (mode == SetModeInsert) {
        if (j < numnow)         /* duplicate */
            return Success;
        numnow++;
        pTmp = (SaveSetElt *) realloc(client->saveSet, sizeof(*pTmp) * numnow);
        if (!pTmp)
            return BadAlloc;
        client->saveSet = pTmp;
        client->numSaved = numnow;
        SaveSetAssignWindow(client->saveSet[numnow - 1], pWin);
        SaveSetAssignToRoot(client->saveSet[numnow - 1], toRoot);
        SaveSetAssignMap(client->saveSet[numnow - 1], map);
        return Success;
    }
    else if ((mode == SetModeDelete) && (j < numnow)) {
        while (j < numnow - 1) {
            pTmp[j] = pTmp[j + 1];
            j++;
        }
        numnow--;
        if (numnow) {
            pTmp =
                (SaveSetElt *) realloc(client->saveSet, sizeof(*pTmp) * numnow);
            if (pTmp)
                client->saveSet = pTmp;
        }
        else {
            free(client->saveSet);
            client->saveSet = (SaveSetElt *) NULL;
        }
        client->numSaved = numnow;
        return Success;
    }
    return Success;
}

void
DeleteWindowFromAnySaveSet(WindowPtr pWin)
{
    int i;
    ClientPtr client;

    for (i = 0; i < currentMaxClients; i++) {
        client = clients[i];
        if (client && client->numSaved)
            (void) AlterSaveSetForClient(client, pWin, SetModeDelete, FALSE,
                                         TRUE);
    }
}

/* No-op Don't Do Anything : sometimes we need to be able to call a procedure
 * that doesn't do anything.  For example, on screen with only static
 * colormaps, if someone calls install colormap, it's easier to have a dummy
 * procedure to call than to check if there's a procedure
 */
void
NoopDDA(void)
{
}

typedef struct _BlockHandler {
    BlockHandlerProcPtr BlockHandler;
    WakeupHandlerProcPtr WakeupHandler;
    void *blockData;
    Bool deleted;
} BlockHandlerRec, *BlockHandlerPtr;

static BlockHandlerPtr handlers;
static int numHandlers;
static int sizeHandlers;
static Bool inHandler;
static Bool handlerDeleted;

/**
 *
 *  \param pTimeout   DIX doesn't want to know how OS represents time
 *  \param pReadMask  nor how it represents the det of descriptors
 */
void
BlockHandler(void *pTimeout, void *pReadmask)
{
    int i, j;

    ++inHandler;
    for (i = 0; i < screenInfo.numScreens; i++)
        (*screenInfo.screens[i]->BlockHandler) (screenInfo.screens[i],
                                                pTimeout, pReadmask);
    for (i = 0; i < screenInfo.numGPUScreens; i++)
        (*screenInfo.gpuscreens[i]->BlockHandler) (screenInfo.gpuscreens[i],
                                                   pTimeout, pReadmask);
    for (i = 0; i < numHandlers; i++)
        if (!handlers[i].deleted)
            (*handlers[i].BlockHandler) (handlers[i].blockData,
                                         pTimeout, pReadmask);
    if (handlerDeleted) {
        for (i = 0; i < numHandlers;)
            if (handlers[i].deleted) {
                for (j = i; j < numHandlers - 1; j++)
                    handlers[j] = handlers[j + 1];
                numHandlers--;
            }
            else
                i++;
        handlerDeleted = FALSE;
    }
    --inHandler;
}

/**
 *
 *  \param result    32 bits of undefined result from the wait
 *  \param pReadmask the resulting descriptor mask
 */
void
WakeupHandler(int result, void *pReadmask)
{
    int i, j;

    ++inHandler;
    for (i = numHandlers - 1; i >= 0; i--)
        if (!handlers[i].deleted)
            (*handlers[i].WakeupHandler) (handlers[i].blockData,
                                          result, pReadmask);
    for (i = 0; i < screenInfo.numScreens; i++)
        (*screenInfo.screens[i]->WakeupHandler) (screenInfo.screens[i],
                                                 result, pReadmask);
    for (i = 0; i < screenInfo.numGPUScreens; i++)
        (*screenInfo.gpuscreens[i]->WakeupHandler) (screenInfo.gpuscreens[i],
                                                    result, pReadmask);
    if (handlerDeleted) {
        for (i = 0; i < numHandlers;)
            if (handlers[i].deleted) {
                for (j = i; j < numHandlers - 1; j++)
                    handlers[j] = handlers[j + 1];
                numHandlers--;
            }
            else
                i++;
        handlerDeleted = FALSE;
    }
    --inHandler;
}

/**
 * Reentrant with BlockHandler and WakeupHandler, except wakeup won't
 * get called until next time
 */
Bool
RegisterBlockAndWakeupHandlers(BlockHandlerProcPtr blockHandler,
                               WakeupHandlerProcPtr wakeupHandler,
                               void *blockData)
{
    BlockHandlerPtr new;

    if (numHandlers >= sizeHandlers) {
        new = (BlockHandlerPtr) realloc(handlers, (numHandlers + 1) *
                                        sizeof(BlockHandlerRec));
        if (!new)
            return FALSE;
        handlers = new;
        sizeHandlers = numHandlers + 1;
    }
    handlers[numHandlers].BlockHandler = blockHandler;
    handlers[numHandlers].WakeupHandler = wakeupHandler;
    handlers[numHandlers].blockData = blockData;
    handlers[numHandlers].deleted = FALSE;
    numHandlers = numHandlers + 1;
    return TRUE;
}

void
RemoveBlockAndWakeupHandlers(BlockHandlerProcPtr blockHandler,
                             WakeupHandlerProcPtr wakeupHandler,
                             void *blockData)
{
    int i;

    for (i = 0; i < numHandlers; i++)
        if (handlers[i].BlockHandler == blockHandler &&
            handlers[i].WakeupHandler == wakeupHandler &&
            handlers[i].blockData == blockData) {
            if (inHandler) {
                handlerDeleted = TRUE;
                handlers[i].deleted = TRUE;
            }
            else {
                for (; i < numHandlers - 1; i++)
                    handlers[i] = handlers[i + 1];
                numHandlers--;
            }
            break;
        }
}

void
InitBlockAndWakeupHandlers(void)
{
    free(handlers);
    handlers = (BlockHandlerPtr) 0;
    numHandlers = 0;
    sizeHandlers = 0;
}

/*
 * A general work queue.  Perform some task before the server
 * sleeps for input.
 */

WorkQueuePtr workQueue;
static WorkQueuePtr *workQueueLast = &workQueue;

void
ProcessWorkQueue(void)
{
    WorkQueuePtr q, *p;

    p = &workQueue;
    /*
     * Scan the work queue once, calling each function.  Those
     * which return TRUE are removed from the queue, otherwise
     * they will be called again.  This must be reentrant with
     * QueueWorkProc.
     */
    while ((q = *p)) {
        if ((*q->function) (q->client, q->closure)) {
            /* remove q from the list */
            *p = q->next;       /* don't fetch until after func called */
            free(q);
        }
        else {
            p = &q->next;       /* don't fetch until after func called */
        }
    }
    workQueueLast = p;
}

void
ProcessWorkQueueZombies(void)
{
    WorkQueuePtr q, *p;

    p = &workQueue;
    while ((q = *p)) {
        if (q->client && q->client->clientGone) {
            (void) (*q->function) (q->client, q->closure);
            /* remove q from the list */
            *p = q->next;       /* don't fetch until after func called */
            free(q);
        }
        else {
            p = &q->next;       /* don't fetch until after func called */
        }
    }
    workQueueLast = p;
}

Bool
QueueWorkProc(Bool (*function) (ClientPtr pClient, void *closure),
              ClientPtr client, void *closure)
{
    WorkQueuePtr q;

    q = malloc(sizeof *q);
    if (!q)
        return FALSE;
    q->function = function;
    q->client = client;
    q->closure = closure;
    q->next = NULL;
    *workQueueLast = q;
    workQueueLast = &q->next;
    return TRUE;
}

/*
 * Manage a queue of sleeping clients, awakening them
 * when requested, by using the OS functions IgnoreClient
 * and AttendClient.  Note that this *ignores* the troubles
 * with request data interleaving itself with events, but
 * we'll leave that until a later time.
 */

typedef struct _SleepQueue {
    struct _SleepQueue *next;
    ClientPtr client;
    ClientSleepProcPtr function;
    void *closure;
} SleepQueueRec, *SleepQueuePtr;

static SleepQueuePtr sleepQueue = NULL;

Bool
ClientSleep(ClientPtr client, ClientSleepProcPtr function, void *closure)
{
    SleepQueuePtr q;

    q = malloc(sizeof *q);
    if (!q)
        return FALSE;

    IgnoreClient(client);
    q->next = sleepQueue;
    q->client = client;
    q->function = function;
    q->closure = closure;
    sleepQueue = q;
    return TRUE;
}

Bool
ClientSignal(ClientPtr client)
{
    SleepQueuePtr q;

    for (q = sleepQueue; q; q = q->next)
        if (q->client == client) {
            return QueueWorkProc(q->function, q->client, q->closure);
        }
    return FALSE;
}

int
ClientSignalAll(ClientPtr client, ClientSleepProcPtr function, void *closure)
{
    SleepQueuePtr q;
    int count = 0;

    for (q = sleepQueue; q; q = q->next) {
        if (!(client == CLIENT_SIGNAL_ANY || q->client == client))
            continue;

        if (!(function == CLIENT_SIGNAL_ANY || q->function == function))
            continue;

        if (!(closure == CLIENT_SIGNAL_ANY || q->closure == closure))
            continue;

        count += QueueWorkProc(q->function, q->client, q->closure);
    }

    return count;
}

void
ClientWakeup(ClientPtr client)
{
    SleepQueuePtr q, *prev;

    prev = &sleepQueue;
    while ((q = *prev)) {
        if (q->client == client) {
            *prev = q->next;
            free(q);
            if (client->clientGone)
                /* Oops -- new zombie cleanup code ensures this only
                 * happens from inside CloseDownClient; don't want to
                 * recurse here...
                 */
                /* CloseDownClient(client) */ ;
            else
                AttendClient(client);
            break;
        }
        prev = &q->next;
    }
}

Bool
ClientIsAsleep(ClientPtr client)
{
    SleepQueuePtr q;

    for (q = sleepQueue; q; q = q->next)
        if (q->client == client)
            return TRUE;
    return FALSE;
}

/*
 *  Generic Callback Manager
 */

/* ===== Private Procedures ===== */

static int numCallbackListsToCleanup = 0;
static CallbackListPtr **listsToCleanup = NULL;

static Bool
_AddCallback(CallbackListPtr *pcbl, CallbackProcPtr callback, void *data)
{
    CallbackPtr cbr;

    cbr = malloc(sizeof(CallbackRec));
    if (!cbr)
        return FALSE;
    cbr->proc = callback;
    cbr->data = data;
    cbr->next = (*pcbl)->list;
    cbr->deleted = FALSE;
    (*pcbl)->list = cbr;
    return TRUE;
}

static Bool
_DeleteCallback(CallbackListPtr *pcbl, CallbackProcPtr callback, void *data)
{
    CallbackListPtr cbl = *pcbl;
    CallbackPtr cbr, pcbr;

    for (pcbr = NULL, cbr = cbl->list; cbr != NULL; pcbr = cbr, cbr = cbr->next) {
        if ((cbr->proc == callback) && (cbr->data == data))
            break;
    }
    if (cbr != NULL) {
        if (cbl->inCallback) {
            ++(cbl->numDeleted);
            cbr->deleted = TRUE;
        }
        else {
            if (pcbr == NULL)
                cbl->list = cbr->next;
            else
                pcbr->next = cbr->next;
            free(cbr);
        }
        return TRUE;
    }
    return FALSE;
}

void
_CallCallbacks(CallbackListPtr *pcbl, void *call_data)
{
    CallbackListPtr cbl = *pcbl;
    CallbackPtr cbr, pcbr;

    ++(cbl->inCallback);
    for (cbr = cbl->list; cbr != NULL; cbr = cbr->next) {
        (*(cbr->proc)) (pcbl, cbr->data, call_data);
    }
    --(cbl->inCallback);

    if (cbl->inCallback)
        return;

    /* Was the entire list marked for deletion? */

    if (cbl->deleted) {
        DeleteCallbackList(pcbl);
        return;
    }

    /* Were some individual callbacks on the list marked for deletion?
     * If so, do the deletions.
     */

    if (cbl->numDeleted) {
        for (pcbr = NULL, cbr = cbl->list; (cbr != NULL) && cbl->numDeleted;) {
            if (cbr->deleted) {
                if (pcbr) {
                    cbr = cbr->next;
                    free(pcbr->next);
                    pcbr->next = cbr;
                }
                else {
                    cbr = cbr->next;
                    free(cbl->list);
                    cbl->list = cbr;
                }
                cbl->numDeleted--;
            }
            else {              /* this one wasn't deleted */

                pcbr = cbr;
                cbr = cbr->next;
            }
        }
    }
}

static void
_DeleteCallbackList(CallbackListPtr *pcbl)
{
    CallbackListPtr cbl = *pcbl;
    CallbackPtr cbr, nextcbr;
    int i;

    if (cbl->inCallback) {
        cbl->deleted = TRUE;
        return;
    }

    for (i = 0; i < numCallbackListsToCleanup; i++) {
        if (listsToCleanup[i] == pcbl) {
            listsToCleanup[i] = NULL;
            break;
        }
    }

    for (cbr = cbl->list; cbr != NULL; cbr = nextcbr) {
        nextcbr = cbr->next;
        free(cbr);
    }
    free(cbl);
    *pcbl = NULL;
}

static Bool
CreateCallbackList(CallbackListPtr *pcbl)
{
    CallbackListPtr cbl;
    int i;

    if (!pcbl)
        return FALSE;
    cbl = malloc(sizeof(CallbackListRec));
    if (!cbl)
        return FALSE;
    cbl->inCallback = 0;
    cbl->deleted = FALSE;
    cbl->numDeleted = 0;
    cbl->list = NULL;
    *pcbl = cbl;

    for (i = 0; i < numCallbackListsToCleanup; i++) {
        if (!listsToCleanup[i]) {
            listsToCleanup[i] = pcbl;
            return TRUE;
        }
    }

    listsToCleanup = (CallbackListPtr **) xnfrealloc(listsToCleanup,
                                                     sizeof(CallbackListPtr *) *
                                                     (numCallbackListsToCleanup
                                                      + 1));
    listsToCleanup[numCallbackListsToCleanup] = pcbl;
    numCallbackListsToCleanup++;
    return TRUE;
}

/* ===== Public Procedures ===== */

Bool
AddCallback(CallbackListPtr *pcbl, CallbackProcPtr callback, void *data)
{
    if (!pcbl)
        return FALSE;
    if (!*pcbl) {               /* list hasn't been created yet; go create it */
        if (!CreateCallbackList(pcbl))
            return FALSE;
    }
    return _AddCallback(pcbl, callback, data);
}

Bool
DeleteCallback(CallbackListPtr *pcbl, CallbackProcPtr callback, void *data)
{
    if (!pcbl || !*pcbl)
        return FALSE;
    return _DeleteCallback(pcbl, callback, data);
}

void
DeleteCallbackList(CallbackListPtr *pcbl)
{
    if (!pcbl || !*pcbl)
        return;
    _DeleteCallbackList(pcbl);
}

void
DeleteCallbackManager(void)
{
    int i;

    for (i = 0; i < numCallbackListsToCleanup; i++) {
        DeleteCallbackList(listsToCleanup[i]);
    }
    free(listsToCleanup);

    numCallbackListsToCleanup = 0;
    listsToCleanup = NULL;
}

void
InitCallbackManager(void)
{
    DeleteCallbackManager();
}

/**
 * Coordinates the global GL context used by modules in the X Server
 * doing rendering with OpenGL.
 *
 * When setting a GL context (glXMakeCurrent() or eglMakeCurrent()),
 * there is an expensive implied glFlush() required by the GLX and EGL
 * APIs, so modules don't want to have to do it on every request.  But
 * the individual modules using GL also don't know about each other,
 * so they have to coordinate who owns the current context.
 *
 * When you're about to do a MakeCurrent, you should set this variable
 * to your context's address, and you can skip MakeCurrent if it's
 * already set to yours.
 *
 * When you're about to do a DestroyContext, you should set this to
 * NULL if it's set to your context.
 *
 * When you're about to do an unbindContext on a DRI driver, you
 * should set this to NULL.  Despite the unbindContext interface
 * sounding like it only unbinds the passed in context, it actually
 * unconditionally clears the dispatch table even if the given
 * context wasn't current.
 */
void *lastGLContext = NULL;
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d623 22
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
d355 1
a355 1
 * procedure to call than to check if there's a procedure 
d376 1
a376 1
 * 
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d202 1
a202 1
    rc = dixLookupResourceByClass((pointer *) &pTmp, id, RC_DRAWABLE, client,
d239 1
a239 1
    return dixLookupResourceByType((pointer *) pGC, id, RT_GC, client, access);
d249 1
a249 1
    rc = dixLookupResourceByType((pointer *) pFont, id, RT_FONT, client,
d253 1
a253 1
    rc = dixLookupResourceByType((pointer *) &pGC, id, RT_GC, client, access);
d264 1
a264 1
    pointer pRes;
d299 1
a299 1
        while ((j < numnow) && (SaveSetWindow(pTmp[j]) != (pointer) pWin))
d365 1
a365 1
    pointer blockData;
d381 1
a381 1
BlockHandler(pointer pTimeout, pointer pReadmask)
d416 1
a416 1
WakeupHandler(int result, pointer pReadmask)
d452 1
a452 1
                               pointer blockData)
d475 1
a475 1
                             pointer blockData)
d559 2
a560 3
QueueWorkProc(Bool (*function)
              (ClientPtr /* pClient */ , pointer /* closure */ ),
              ClientPtr client, pointer closure)
d588 1
a588 1
    pointer closure;
d594 1
a594 1
ClientSleep(ClientPtr client, ClientSleepProcPtr function, pointer closure)
d668 1
a668 1
_AddCallback(CallbackListPtr *pcbl, CallbackProcPtr callback, pointer data)
d684 1
a684 1
_DeleteCallback(CallbackListPtr *pcbl, CallbackProcPtr callback, pointer data)
d711 1
a711 1
_CallCallbacks(CallbackListPtr *pcbl, pointer call_data)
d823 1
a823 1
AddCallback(CallbackListPtr *pcbl, CallbackProcPtr callback, pointer data)
d835 1
a835 1
DeleteCallback(CallbackListPtr *pcbl, CallbackProcPtr callback, pointer data)
d869 25
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d852 1
a852 1
InitCallbackManager(void)
d863 6
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d387 5
a391 3
        (*screenInfo.screens[i]->BlockHandler) (i,
                                                screenInfo.screens[i]->
                                                blockData, pTimeout, pReadmask);
d426 5
a430 3
        (*screenInfo.screens[i]->WakeupHandler) (i,
                                                 screenInfo.screens[i]->
                                                 wakeupData, result, pReadmask);
@


1.7
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@a24 1

a82 1

d108 1
a108 1
	return EARLIER;
d110 1
a110 1
	return LATER;
d112 1
a112 1
	return EARLIER;
d114 1
a114 1
	return LATER;
d127 1
d129 1
a129 1
	return currentTime;
d132 7
a138 9
    if (c > currentTime.milliseconds)
    {
	if (((unsigned long) c - currentTime.milliseconds) > HALFMONTH)
	    ts.months -= 1;
    }
    else if (c < currentTime.milliseconds)
    {
	if (((unsigned long)currentTime.milliseconds - c) > HALFMONTH)
	    ts.months += 1;
d151 1
a151 1
ISOLatin1ToLower (unsigned char source)
d153 2
a154 1
    unsigned char   dest;
d156 1
a156 1
       dest = source + (XK_a - XK_A);
d158 1
a158 1
       dest = source + (XK_agrave - XK_Agrave);
d160 1
a160 1
       dest = source + (XK_oslash - XK_Ooblique);
d162 1
a162 1
       dest = source;
a165 1

d167 2
a168 2
CompareISOLatin1Lowered(unsigned char *s1, int s1len, 
			unsigned char *s2, int s2len)
d170 10
a179 11
    unsigned char   c1, c2;
    
    for (;;) 
    {
	/* note -- compare against zero so that -1 ignores len */
	c1 = s1len-- ? *s1++ : '\0';
	c2 = s2len-- ? *s2++ : '\0';
	if (!c1 || 
	    (c1 != c2 && 
	     (c1 = ISOLatin1ToLower (c1)) != (c2 = ISOLatin1ToLower (c2))))
	    break;
d195 1
a195 1
		  Mask type, Mask access)
d202 2
a203 1
    rc = dixLookupResourceByClass((pointer *)&pTmp, id, RC_DRAWABLE, client, access);
d206 1
a206 1
	client->errorValue = id;
d209 1
a209 1
	return BadDrawable;
d211 1
a211 1
	return rc;
d213 1
a213 1
	return BadMatch;
d223 11
a233 2
    rc = dixLookupDrawable((DrawablePtr*)pWin, id, client, M_WINDOW, access);
    return (rc == BadDrawable) ? BadWindow : rc;
d239 1
a239 1
    return dixLookupResourceByType((pointer *)pGC, id, RT_GC, client, access);
d247 4
a250 2
    client->errorValue = id;		/* EITHER font or gc */
    rc = dixLookupResourceByType((pointer *) pFont, id, RT_FONT, client, access);
d252 1
a252 1
	return rc;
d255 1
a255 1
	return BadFont;
d257 1
a257 1
	*pFont = pGC->font;
d268 1
a268 1
	goto bad;
d272 1
a272 1
	goto bad;
d276 1
a276 1
	goto bad;
d280 2
a281 2
bad:
    if(client)
d297 32
a328 37
    if (numnow)
    {
	pTmp = client->saveSet;
	while ((j < numnow) && (SaveSetWindow(pTmp[j]) != (pointer)pWin))
	    j++;
    }
    if (mode == SetModeInsert)
    {
	if (j < numnow)         /* duplicate */
	   return Success;
	numnow++;
	pTmp = (SaveSetElt *)realloc(client->saveSet, sizeof(*pTmp) * numnow);
	if (!pTmp)
	    return BadAlloc;
	client->saveSet = pTmp;
       	client->numSaved = numnow;
	SaveSetAssignWindow(client->saveSet[numnow - 1], pWin);
	SaveSetAssignToRoot(client->saveSet[numnow - 1], toRoot);
	SaveSetAssignMap(client->saveSet[numnow - 1], map);
	return Success;
    }
    else if ((mode == SetModeDelete) && (j < numnow))
    {
	while (j < numnow-1)
	{
           pTmp[j] = pTmp[j+1];
	   j++;
	}
	numnow--;
        if (numnow)
	{
	    pTmp = (SaveSetElt *)realloc(client->saveSet, sizeof(*pTmp) * numnow);
	    if (pTmp)
		client->saveSet = pTmp;
	}
        else
        {
d330 4
a333 4
	    client->saveSet = (SaveSetElt *)NULL;
	}
	client->numSaved = numnow;
	return Success;
d343 6
a348 6
    
    for (i = 0; i< currentMaxClients; i++)
    {    
	client = clients[i];
	if (client && client->numSaved)
	    (void)AlterSaveSetForClient(client, pWin, SetModeDelete, FALSE, TRUE);
d366 1
a366 1
    Bool    deleted;
d369 5
a373 5
static BlockHandlerPtr	handlers;
static int		numHandlers;
static int		sizeHandlers;
static Bool		inHandler;
static Bool		handlerDeleted;
d384 1
a384 1
    
d387 3
a389 3
	(* screenInfo.screens[i]->BlockHandler)(i, 
				screenInfo.screens[i]->blockData,
				pTimeout, pReadmask);
d391 13
a403 15
	if (!handlers[i].deleted)
		(*handlers[i].BlockHandler) (handlers[i].blockData,
					     pTimeout, pReadmask);
    if (handlerDeleted)
    {
	for (i = 0; i < numHandlers;)
	    if (handlers[i].deleted)
	    {
	    	for (j = i; j < numHandlers - 1; j++)
		    handlers[j] = handlers[j+1];
	    	numHandlers--;
	    }
	    else
		i++;
	handlerDeleted = FALSE;
d420 3
a422 3
	if (!handlers[i].deleted)
		(*handlers[i].WakeupHandler) (handlers[i].blockData,
					      result, pReadmask);
d424 13
a436 15
	(* screenInfo.screens[i]->WakeupHandler)(i, 
				screenInfo.screens[i]->wakeupData,
				result, pReadmask);
    if (handlerDeleted)
    {
	for (i = 0; i < numHandlers;)
	    if (handlers[i].deleted)
	    {
	    	for (j = i; j < numHandlers - 1; j++)
		    handlers[j] = handlers[j+1];
	    	numHandlers--;
	    }
	    else
		i++;
	handlerDeleted = FALSE;
d446 3
a448 3
RegisterBlockAndWakeupHandlers (BlockHandlerProcPtr blockHandler, 
                                WakeupHandlerProcPtr wakeupHandler, 
                                pointer blockData)
d452 1
a452 2
    if (numHandlers >= sizeHandlers)
    {
d454 5
a458 5
				      	  sizeof (BlockHandlerRec));
    	if (!new)
	    return FALSE;
    	handlers = new;
	sizeHandlers = numHandlers + 1;
d469 3
a471 3
RemoveBlockAndWakeupHandlers (BlockHandlerProcPtr blockHandler, 
                              WakeupHandlerProcPtr wakeupHandler, 
                              pointer blockData)
d473 1
a473 1
    int	    i;
d476 14
a489 17
	if (handlers[i].BlockHandler == blockHandler &&
	    handlers[i].WakeupHandler == wakeupHandler &&
	    handlers[i].blockData == blockData)
	{
	    if (inHandler)
	    {
		handlerDeleted = TRUE;
		handlers[i].deleted = TRUE;
	    }
	    else
	    {
	    	for (; i < numHandlers - 1; i++)
		    handlers[i] = handlers[i+1];
	    	numHandlers--;
	    }
	    break;
	}
d493 1
a493 1
InitBlockAndWakeupHandlers (void)
d506 2
a507 2
WorkQueuePtr		workQueue;
static WorkQueuePtr	*workQueueLast = &workQueue;
d512 1
a512 1
    WorkQueuePtr    q, *p;
d521 9
a529 12
    while ((q = *p))
    {
	if ((*q->function) (q->client, q->closure))
	{
	    /* remove q from the list */
	    *p = q->next;    /* don't fetch until after func called */
	    free(q);
	}
	else
	{
	    p = &q->next;    /* don't fetch until after func called */
	}
d537 1
a537 1
    WorkQueuePtr    q, *p;
d540 10
a549 13
    while ((q = *p))
    {
	if (q->client && q->client->clientGone)
	{
	    (void) (*q->function) (q->client, q->closure);
	    /* remove q from the list */
	    *p = q->next;    /* don't fetch until after func called */
	    free(q);
	}
	else
	{
	    p = &q->next;    /* don't fetch until after func called */
	}
d555 3
a557 3
QueueWorkProc (
    Bool (*function)(ClientPtr /* pClient */, pointer /* closure */),
    ClientPtr client, pointer closure)
d559 1
a559 1
    WorkQueuePtr    q;
d563 1
a563 1
	return FALSE;
d582 4
a585 4
    struct _SleepQueue	*next;
    ClientPtr		client;
    ClientSleepProcPtr  function;
    pointer		closure;
d588 1
a588 1
static SleepQueuePtr	sleepQueue = NULL;
d591 1
a591 1
ClientSleep (ClientPtr client, ClientSleepProcPtr function, pointer closure)
d593 1
a593 1
    SleepQueuePtr   q;
d597 1
a597 1
	return FALSE;
d599 1
a599 1
    IgnoreClient (client);
d609 1
a609 1
ClientSignal (ClientPtr client)
d611 1
a611 1
    SleepQueuePtr   q;
d614 3
a616 4
	if (q->client == client)
	{
	    return QueueWorkProc (q->function, q->client, q->closure);
	}
d621 1
a621 1
ClientWakeup (ClientPtr client)
d623 1
a623 1
    SleepQueuePtr   q, *prev;
d626 15
a640 17
    while ( (q = *prev) )
    {
	if (q->client == client)
	{
	    *prev = q->next;
	    free(q);
	    if (client->clientGone)
		/* Oops -- new zombie cleanup code ensures this only
		 * happens from inside CloseDownClient; don't want to
		 * recurse here...
		 */
		/* CloseDownClient(client) */;
	    else
		AttendClient (client);
	    break;
	}
	prev = &q->next;
d645 1
a645 1
ClientIsAsleep (ClientPtr client)
d647 1
a647 1
    SleepQueuePtr   q;
d650 2
a651 2
	if (q->client == client)
	    return TRUE;
d665 1
a665 4
_AddCallback(
    CallbackListPtr *pcbl,
    CallbackProcPtr callback,
    pointer         data)
d667 1
a667 1
    CallbackPtr     cbr;
d671 1
a671 1
	return FALSE;
d680 2
a681 5
static Bool 
_DeleteCallback(
    CallbackListPtr *pcbl,
    CallbackProcPtr callback,
    pointer         data)
d684 1
a684 1
    CallbackPtr     cbr, pcbr;
d686 17
a702 23
    for (pcbr = NULL, cbr = cbl->list;
	 cbr != NULL;
	 pcbr = cbr, cbr = cbr->next)
    {
	if ((cbr->proc == callback) && (cbr->data == data))
	    break;
    }
    if (cbr != NULL)
    {
	if (cbl->inCallback)
	{
	    ++(cbl->numDeleted);
	    cbr->deleted = TRUE;
	}
	else
	{
	    if (pcbr == NULL)
		cbl->list = cbr->next;
	    else
		pcbr->next = cbr->next;
	    free(cbr);
	}
	return TRUE;
d707 2
a708 4
void 
_CallCallbacks(
    CallbackListPtr    *pcbl,
    pointer	    call_data)
d711 1
a711 1
    CallbackPtr     cbr, pcbr;
d714 2
a715 3
    for (cbr = cbl->list; cbr != NULL; cbr = cbr->next)
    {
	(*(cbr->proc)) (pcbl, cbr->data, call_data);
d719 2
a720 1
    if (cbl->inCallback) return;
d724 3
a726 4
    if (cbl->deleted)
    {
	DeleteCallbackList(pcbl);
	return;
d733 21
a753 25
    if (cbl->numDeleted)
    {
	for (pcbr = NULL, cbr = cbl->list; (cbr != NULL) && cbl->numDeleted; )
	{
	    if (cbr->deleted)
	    {
		if (pcbr)
		{
		    cbr = cbr->next;
		    free(pcbr->next);
		    pcbr->next = cbr;
		} else
		{
		    cbr = cbr->next;
		    free(cbl->list);
		    cbl->list = cbr;
		}
		cbl->numDeleted--;
	    }
	    else /* this one wasn't deleted */
	    {
		pcbr = cbr;
		cbr = cbr->next;
	    }
	}
d758 1
a758 2
_DeleteCallbackList(
    CallbackListPtr    *pcbl)
d761 1
a761 1
    CallbackPtr     cbr, nextcbr;
d764 15
a778 19
    if (cbl->inCallback)
    {
	cbl->deleted = TRUE;
	return;
    }

    for (i = 0; i < numCallbackListsToCleanup; i++)
    {
	if (listsToCleanup[i] == pcbl)
	{
	    listsToCleanup[i] = NULL;
	    break;
	}
    }

    for (cbr = cbl->list; cbr != NULL; cbr = nextcbr)
    {
	nextcbr = cbr->next;
	free(cbr);
d787 1
a787 1
    CallbackListPtr  cbl;
d790 2
a791 1
    if (!pcbl) return FALSE;
d793 2
a794 1
    if (!cbl) return FALSE;
d801 5
a805 7
    for (i = 0; i < numCallbackListsToCleanup; i++)
    {
	if (!listsToCleanup[i])
	{
	    listsToCleanup[i] = pcbl;
	    return TRUE;
	}    
d808 4
a811 2
    listsToCleanup = (CallbackListPtr **)xnfrealloc(listsToCleanup,
		sizeof(CallbackListPtr *) * (numCallbackListsToCleanup+1));
d822 5
a826 5
    if (!pcbl) return FALSE;
    if (!*pcbl)
    {	/* list hasn't been created yet; go create it */
	if (!CreateCallbackList(pcbl))
	    return FALSE;
d834 2
a835 1
    if (!pcbl || !*pcbl) return FALSE;
d842 2
a843 1
    if (!pcbl || !*pcbl) return;
d852 2
a853 3
    for (i = 0; i < numCallbackListsToCleanup; i++)
    {
	DeleteCallbackList(listsToCleanup[i]);
@


1.6
log
@Update to xserver 1.11.2
@
text
@a204 1
    client->errorValue = id;
d206 1
a206 2
    if (id == INVALID)
	return BadDrawable;
d208 2
a209 1
    rc = dixLookupResourceByClass((pointer *)&pTmp, id, RC_DRAWABLE, client, access);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d389 3
a391 2
	(*handlers[i].BlockHandler) (handlers[i].blockData,
				     pTimeout, pReadmask);
d420 3
a422 2
	(*handlers[i].WakeupHandler) (handlers[i].blockData,
				      result, pReadmask);
d734 1
a734 1
static void 
a872 7
}

void
CallCallbacks(CallbackListPtr *pcbl, pointer call_data)
{
    if (!pcbl || !*pcbl) return;
    _CallCallbacks(pcbl, call_data);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d95 1
d234 6
d241 11
a251 2
    rc = dixLookupResourceByType((pointer *)pGC, id, RT_GC, client, access);
    return (rc == BadValue) ? BadGC : rc;
d299 1
a299 1
	   return(Success);
d301 1
a301 1
	pTmp = (SaveSetElt *)xrealloc(client->saveSet, sizeof(*pTmp) * numnow);
d303 1
a303 1
	    return(BadAlloc);
d309 1
a309 1
	return(Success);
d321 1
a321 1
	    pTmp = (SaveSetElt *)xrealloc(client->saveSet, sizeof(*pTmp) * numnow);
d327 1
a327 1
            xfree(client->saveSet);
d331 1
a331 1
	return(Success);
d333 1
a333 1
    return(Success);
d454 1
a454 1
    	new = (BlockHandlerPtr) xrealloc (handlers, (numHandlers + 1) *
d499 1
a499 1
    xfree (handlers);
d531 1
a531 1
	    xfree (q);
d554 1
a554 1
	    xfree (q);
d571 1
a571 1
    q = xalloc (sizeof *q);
d605 1
a605 1
    q = xalloc (sizeof *q);
d642 1
a642 1
	    xfree (q);
d685 1
a685 1
    cbr = xalloc(sizeof(CallbackRec));
d725 1
a725 1
	    xfree(cbr);
d770 1
a770 1
		    xfree(pcbr->next);
d775 1
a775 1
		    xfree(cbl->list);
d815 1
a815 1
	xfree(cbr);
d817 1
a817 1
    xfree(cbl);
d828 1
a828 1
    cbl = xalloc(sizeof(CallbackListRec));
d896 1
a896 1
    if (listsToCleanup) xfree(listsToCleanup);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d105 1
a105 1
_X_EXPORT int
d124 1
a124 1
_X_EXPORT TimeStamp
a167 10
_X_EXPORT void
CopyISOLatin1Lowered(unsigned char *dest, unsigned char *source, int length)
{
    int i;

    for (i = 0; i < length; i++, source++, dest++)
	*dest = ISOLatin1ToLower (*source);
    *dest = '\0';
}

d196 1
a196 1
_X_EXPORT int
d222 1
a222 1
_X_EXPORT int
d230 1
a230 1
_X_EXPORT int
d233 3
a235 8
    GCPtr pTmp = (GCPtr)SecurityLookupIDByType(client, id, RT_GC, access);
    if (pTmp) {
	*pGC = pTmp;
	return Success;
    }
    client->errorValue = id;
    *pGC = NULL;
    return BadGC;
d238 1
a238 1
_X_EXPORT int
d339 1
a339 1
_X_EXPORT void
d429 1
a429 1
_X_EXPORT Bool
d453 1
a453 1
_X_EXPORT void
d548 1
a548 1
_X_EXPORT Bool
d555 1
a555 1
    q = (WorkQueuePtr) xalloc (sizeof *q);
d584 1
a584 1
_X_EXPORT Bool
d589 1
a589 1
    q = (SleepQueuePtr) xalloc (sizeof *q);
d615 1
a615 1
_X_EXPORT void
d661 1
a661 1
static Bool 
d669 1
a669 1
    cbr = (CallbackPtr) xalloc(sizeof(CallbackRec));
d812 1
a812 1
    cbl = (CallbackListPtr) xalloc(sizeof(CallbackListRec));
d838 1
a838 1
_X_EXPORT Bool 
d850 1
a850 1
_X_EXPORT Bool 
d857 1
a857 1
void 
d871 1
a871 1
void 
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d219 1
a219 1
    rc = dixLookupResource((pointer *)&pTmp, id, RC_DRAWABLE, client, access);
d262 1
a262 1
    rc = dixLookupResource(&pRes, rid, RC_ANY, client, DixGetAttrAccess);
d273 2
a274 1
    client->errorValue = rid;
d281 1
a281 1
                      Bool toRoot, Bool remap)
d307 1
a307 1
	SaveSetAssignRemap(client->saveSet[numnow - 1], remap);
@


1.1
log
@Initial revision
@
text
@a97 1
#ifdef XACE
a98 1
#endif
d171 1
a171 1
    register int i;
d197 8
a204 9
#ifdef XACE

/* SecurityLookupWindow and SecurityLookupDrawable:
 * Look up the window/drawable taking into account the client doing
 * the lookup and the type of access desired.  Return the window/drawable
 * if it exists and the client is allowed access, else return NULL.
 * Most Proc* functions should be calling these instead of
 * LookupWindow and LookupDrawable, which do no access checks.
 * XACE note: need to see if client->lastDrawableID can still be used here.
d206 3
a208 3

_X_EXPORT WindowPtr
SecurityLookupWindow(XID rid, ClientPtr client, Mask access_mode)
d210 2
a211 5
    client->errorValue = rid;
    if(rid == INVALID)
	return NULL;
    return (WindowPtr)SecurityLookupIDByType(client, rid, RT_WINDOW, access_mode);
}
d213 2
d216 2
a217 4
_X_EXPORT pointer
SecurityLookupDrawable(XID rid, ClientPtr client, Mask access_mode)
{
    register DrawablePtr pDraw;
d219 1
a219 8
    if(rid == INVALID)
	return (pointer) NULL;
    pDraw = (DrawablePtr)SecurityLookupIDByClass(client, rid, RC_DRAWABLE,
						 access_mode);
    if (pDraw && (pDraw->type != UNDRAWABLE_WINDOW))
        return (pointer)pDraw;		
    return (pointer)NULL;
}
d221 6
a226 3
/* We can't replace the LookupWindow and LookupDrawable functions with
 * macros because of compatibility with loadable servers.
 */
d228 2
a229 4
_X_EXPORT WindowPtr
LookupWindow(XID rid, ClientPtr client)
{
    return SecurityLookupWindow(rid, client, SecurityUnknownAccess);
d232 2
a233 2
_X_EXPORT pointer
LookupDrawable(XID rid, ClientPtr client)
d235 3
a237 1
    return SecurityLookupDrawable(rid, client, SecurityUnknownAccess);
d240 2
a241 4
#else /* not XACE */

WindowPtr
LookupWindow(XID rid, ClientPtr client)
d243 8
a250 19
    WindowPtr	pWin;

    client->errorValue = rid;
    if(rid == INVALID)
	return NULL;
    if (client->lastDrawableID == rid)
    {
        if (client->lastDrawable->type == DRAWABLE_WINDOW)
            return ((WindowPtr) client->lastDrawable);
        return (WindowPtr) NULL;
    }
    pWin = (WindowPtr)LookupIDByType(rid, RT_WINDOW);
    if (pWin && pWin->drawable.type == DRAWABLE_WINDOW) {
	client->lastDrawable = (DrawablePtr) pWin;
	client->lastDrawableID = rid;
	client->lastGCID = INVALID;
	client->lastGC = (GCPtr)NULL;
    }
    return pWin;
d253 2
a254 3

pointer
LookupDrawable(XID rid, ClientPtr client)
d256 2
a257 1
    register DrawablePtr pDraw;
d259 2
a260 9
    if(rid == INVALID)
	return (pointer) NULL;
    if (client->lastDrawableID == rid)
	return ((pointer) client->lastDrawable);
    pDraw = (DrawablePtr)LookupIDByClass(rid, RC_DRAWABLE);
    if (pDraw && (pDraw->type != UNDRAWABLE_WINDOW))
        return (pointer)pDraw;		
    return (pointer)NULL;
}
d262 3
a264 1
#endif /* XACE */
d266 3
a268 6
_X_EXPORT ClientPtr
LookupClient(XID rid, ClientPtr client)
{
    pointer pRes = (pointer)SecurityLookupIDByClass(client, rid, RC_ANY,
						    SecurityReadAccess);
    int clientIndex = CLIENT_ID(rid);
d270 6
a275 5
    if (clientIndex && pRes && clients[clientIndex] && !(rid & SERVER_BIT))
    {
	return clients[clientIndex];
    }
    return (ClientPtr)NULL;
a277 1

d337 2
a338 2
    register int i;
    register ClientPtr client;
d379 1
a379 1
    register int i, j;
d413 1
a413 1
    register int i, j;
d495 1
a495 1
InitBlockAndWakeupHandlers ()
d803 1
a803 1
	if ((listsToCleanup[i] = pcbl) != 0)
d819 2
a820 12
static CallbackFuncsRec default_cbfuncs =
{
    _AddCallback,
    _DeleteCallback,
    _CallCallbacks,
    _DeleteCallbackList
};

/* ===== Public Procedures ===== */

Bool
CreateCallbackList(CallbackListPtr *pcbl, CallbackFuncsPtr cbfuncs)
a827 1
    cbl->funcs = cbfuncs ? *cbfuncs : default_cbfuncs;
d850 2
d858 1
a858 1
	if (!CreateCallbackList(pcbl, (CallbackFuncsPtr)NULL))
d861 1
a861 1
    return ((*(*pcbl)->funcs.AddCallback) (pcbl, callback, data));
d868 1
a868 1
    return ((*(*pcbl)->funcs.DeleteCallback) (pcbl, callback, data));
d875 1
a875 1
    (*(*pcbl)->funcs.CallCallbacks) (pcbl, call_data);
d882 1
a882 1
    (*(*pcbl)->funcs.DeleteCallbackList) (pcbl);
d886 1
a886 1
InitCallbackManager()
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d98 1
d100 1
d173 1
a173 1
    int i;
d199 9
a207 8
/*
 * dixLookupWindow and dixLookupDrawable:
 * Look up the window/drawable taking into account the client doing the
 * lookup, the type of drawable desired, and the type of access desired.
 * Return Success with *pDraw set if the window/drawable exists and the client
 * is allowed access, else return an error code with *pDraw set to NULL.  The
 * access mask values are defined in resource.h.  The type mask values are
 * defined in pixmap.h, with zero equivalent to M_DRAWABLE.
a208 36
_X_EXPORT int
dixLookupDrawable(DrawablePtr *pDraw, XID id, ClientPtr client,
		  Mask type, Mask access)
{
    DrawablePtr pTmp;
    RESTYPE rtype;
    *pDraw = NULL;
    client->errorValue = id;

    if (id == INVALID)
	return BadDrawable;

    if (id == client->lastDrawableID) {
	pTmp = client->lastDrawable;

	/* an access check is required for cached drawables */
	rtype = (type & M_WINDOW) ? RT_WINDOW : RT_PIXMAP;
	if (!XaceHook(XACE_RESOURCE_ACCESS, client, id, rtype, access, pTmp))
	    return BadDrawable;
    } else
	pTmp = (DrawablePtr)SecurityLookupIDByClass(client, id, RC_DRAWABLE,
						   access);
    if (!pTmp)
	return BadDrawable;
    if (!((1 << pTmp->type) & (type ? type : M_DRAWABLE)))
	return BadMatch;

    if (type & M_DRAWABLE) {
	client->lastDrawable = pTmp;
	client->lastDrawableID = id;
	client->lastGCID = INVALID;
	client->lastGC = (GCPtr)NULL;
    }
    *pDraw = pTmp;
    return Success;
}
d210 2
a211 2
_X_EXPORT int
dixLookupWindow(WindowPtr *pWin, XID id, ClientPtr client, Mask access)
d213 4
a216 3
    int rc;
    rc = dixLookupDrawable((DrawablePtr*)pWin, id, client, M_WINDOW, access);
    return (rc == BadDrawable) ? BadWindow : rc;
a218 12
_X_EXPORT int
dixLookupGC(GCPtr *pGC, XID id, ClientPtr client, Mask access)
{
    GCPtr pTmp = (GCPtr)SecurityLookupIDByType(client, id, RT_GC, access);
    if (pTmp) {
	*pGC = pTmp;
	return Success;
    }
    client->errorValue = id;
    *pGC = NULL;
    return BadGC;
}
d220 2
a221 2
_X_EXPORT int
dixLookupClient(ClientPtr *pClient, XID rid, ClientPtr client, Mask access)
d223 1
a223 4
    pointer pRes = (pointer)SecurityLookupIDByClass(client, rid, RC_ANY,
						    access);
    int clientIndex = CLIENT_ID(rid);
    client->errorValue = rid;
d225 7
a231 6
    if (clientIndex && pRes && clients[clientIndex] && !(rid & SERVER_BIT)) {
	*pClient = clients[clientIndex];
	return Success;
    }
    *pClient = NULL;
    return BadValue;
d234 2
a235 3
/*
 * These are deprecated compatibility functions and will be removed soon!
 * Please use the new dixLookup*() functions above.
d237 3
a239 2
_X_EXPORT _X_DEPRECATED WindowPtr
SecurityLookupWindow(XID id, ClientPtr client, Mask access_mode)
d241 1
a241 8
    WindowPtr pWin;
    int i = dixLookupWindow(&pWin, id, client, access_mode);
    static int warn = 1;
    if (warn-- > 0)
	ErrorF("Warning: LookupWindow()/SecurityLookupWindow() "
	       "are deprecated.  Please convert your driver/module "
	       "to use dixLookupWindow().\n");
    return (i == Success) ? pWin : NULL;
d244 2
a245 2
_X_EXPORT _X_DEPRECATED WindowPtr
LookupWindow(XID id, ClientPtr client)
d247 1
a247 1
    return SecurityLookupWindow(id, client, DixUnknownAccess);
d250 4
a253 2
_X_EXPORT _X_DEPRECATED pointer
SecurityLookupDrawable(XID id, ClientPtr client, Mask access_mode)
d255 19
a273 8
    DrawablePtr pDraw;
    int i = dixLookupDrawable(&pDraw, id, client, M_DRAWABLE, access_mode);
    static int warn = 1;
    if (warn-- > 0)
	ErrorF("Warning: LookupDrawable()/SecurityLookupDrawable() "
	       "are deprecated.  Please convert your driver/module "
	       "to use dixLookupDrawable().\n");
    return (i == Success) ? pDraw : NULL;
d276 3
a278 2
_X_EXPORT _X_DEPRECATED pointer
LookupDrawable(XID id, ClientPtr client)
d280 10
a289 1
    return SecurityLookupDrawable(id, client, DixUnknownAccess);
d292 4
a295 2
_X_EXPORT _X_DEPRECATED ClientPtr
LookupClient(XID id, ClientPtr client)
d297 9
a305 7
    ClientPtr pClient;
    int i = dixLookupClient(&pClient, id, client, DixUnknownAccess);
    static int warn = 1;
    if (warn-- > 0)
	ErrorF("Warning: LookupClient() is deprecated.  Please convert your "
	       "driver/module to use dixLookupClient().\n");
    return (i == Success) ? pClient : NULL;
a307 1
/* end deprecated functions */
d368 2
a369 2
    int i;
    ClientPtr client;
d410 1
a410 1
    int i, j;
d444 1
a444 1
    int i, j;
d526 1
a526 1
InitBlockAndWakeupHandlers (void)
d858 3
a860 1
static Bool
a891 2
/* ===== Public Procedures ===== */

d926 1
a926 1
InitCallbackManager(void)
@

