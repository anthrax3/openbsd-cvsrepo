head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.2
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.12
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.10
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.8
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2016.08.09.18.59.51;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	6HLO5qdN5N4nPDjW;

1.7
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	s0SI41sEunLdyFfd;

1.6
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 * Copyright Â© 2008 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Peter Hutterer
 *
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/extensions/XI2.h>
#include <X11/extensions/XIproto.h>
#include <X11/extensions/XI2proto.h>
#include "inputstr.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "exglobals.h"
#include "enterleave.h"
#include "eventconvert.h"
#include "xkbsrv.h"
#include "inpututils.h"

/**
 * @@file
 * This file describes the model for sending core enter/leave events and
 * focus in/out in the case of multiple pointers/keyboard foci.
 *
 * Since we can't send more than one Enter or Leave/Focus in or out event per
 * window to a core client without confusing it, this is a rather complicated
 * approach.
 *
 * For a full description of the enter/leave model from a window's
 * perspective, see
 * http://lists.freedesktop.org/archives/xorg/2008-August/037606.html
 *
 * For a full description of the focus in/out model from a window's
 * perspective, see
 * http://lists.freedesktop.org/archives/xorg/2008-December/041740.html
 *
 * Additional notes:
 * - The core protocol spec says that "In a LeaveNotify event, if a child of the
 * event window contains the initial position of the pointer, then the child
 * component is set to that child. Otherwise, it is None.  For an EnterNotify
 * event, if a child of the event window contains the final pointer position,
 * then the child component is set to that child. Otherwise, it is None."
 *
 * By inference, this means that only NotifyVirtual or NotifyNonlinearVirtual
 * events may have a subwindow set to other than None.
 *
 * - NotifyPointer events may be sent if the focus changes from window A to
 * B. The assumption used in this model is that NotifyPointer events are only
 * sent for the pointer paired with the keyboard that is involved in the focus
 * events. For example, if F(W) changes because of keyboard 2, then
 * NotifyPointer events are only sent for pointer 2.
 */

static WindowPtr PointerWindows[MAXDEVICES];
static WindowPtr FocusWindows[MAXDEVICES];

/**
 * Return TRUE if 'win' has a pointer within its boundaries, excluding child
 * window.
 */
static BOOL
HasPointer(DeviceIntPtr dev, WindowPtr win)
{
    int i;

    /* FIXME: The enter/leave model does not cater for grabbed devices. For
     * now, a quickfix: if the device about to send an enter/leave event to
     * a window is grabbed, assume there is no pointer in that window.
     * Fixes fdo 27804.
     * There isn't enough beer in my fridge to fix this properly.
     */
    if (dev->deviceGrab.grab)
        return FALSE;

    for (i = 0; i < MAXDEVICES; i++)
        if (PointerWindows[i] == win)
            return TRUE;

    return FALSE;
}

/**
 * Return TRUE if at least one keyboard focus is set to 'win' (excluding
 * descendants of win).
 */
static BOOL
HasFocus(WindowPtr win)
{
    int i;

    for (i = 0; i < MAXDEVICES; i++)
        if (FocusWindows[i] == win)
            return TRUE;

    return FALSE;
}

/**
 * Return the window the device dev is currently on.
 */
static WindowPtr
PointerWin(DeviceIntPtr dev)
{
    return PointerWindows[dev->id];
}

/**
 * Search for the first window below 'win' that has a pointer directly within
 * it's boundaries (excluding boundaries of its own descendants).
 *
 * @@return The child window that has the pointer within its boundaries or
 *         NULL.
 */
static WindowPtr
FirstPointerChild(WindowPtr win)
{
    int i;

    for (i = 0; i < MAXDEVICES; i++) {
        if (PointerWindows[i] && IsParent(win, PointerWindows[i]))
            return PointerWindows[i];
    }

    return NULL;
}

/**
 * Search for the first window below 'win' that has a focus directly within
 * it's boundaries (excluding boundaries of its own descendants).
 *
 * @@return The child window that has the pointer within its boundaries or
 *         NULL.
 */
static WindowPtr
FirstFocusChild(WindowPtr win)
{
    int i;

    for (i = 0; i < MAXDEVICES; i++) {
        if (FocusWindows[i] && FocusWindows[i] != PointerRootWin &&
            IsParent(win, FocusWindows[i]))
            return FocusWindows[i];
    }

    return NULL;
}

/**
 * Set the presence flag for dev to mark that it is now in 'win'.
 */
void
EnterWindow(DeviceIntPtr dev, WindowPtr win, int mode)
{
    PointerWindows[dev->id] = win;
}

/**
 * Unset the presence flag for dev to mark that it is not in 'win' anymore.
 */
void
LeaveWindow(DeviceIntPtr dev)
{
    PointerWindows[dev->id] = NULL;
}

/**
 * Set the presence flag for dev to mark that it is now in 'win'.
 */
void
SetFocusIn(DeviceIntPtr dev, WindowPtr win)
{
    FocusWindows[dev->id] = win;
}

/**
 * Unset the presence flag for dev to mark that it is not in 'win' anymore.
 */
void
SetFocusOut(DeviceIntPtr dev)
{
    FocusWindows[dev->id] = NULL;
}

/**
 * Return the common ancestor of 'a' and 'b' (if one exists).
 * @@param a A window with the same ancestor as b.
 * @@param b A window with the same ancestor as a.
 * @@return The window that is the first ancestor of both 'a' and 'b', or the
 *         NullWindow if they do not have a common ancestor.
 */
static WindowPtr
CommonAncestor(WindowPtr a, WindowPtr b)
{
    for (b = b->parent; b; b = b->parent)
        if (IsParent(b, a))
            return b;
    return NullWindow;
}

/**
 * Send enter notifies to all windows between 'ancestor' and 'child' (excluding
 * both). Events are sent running up the window hierarchy. This function
 * recurses.
 */
static void
DeviceEnterNotifies(DeviceIntPtr dev,
                    int sourceid,
                    WindowPtr ancestor, WindowPtr child, int mode, int detail)
{
    WindowPtr parent = child->parent;

    if (ancestor == parent)
        return;
    DeviceEnterNotifies(dev, sourceid, ancestor, parent, mode, detail);
    DeviceEnterLeaveEvent(dev, sourceid, XI_Enter, mode, detail, parent,
                          child->drawable.id);
}

/**
 * Send enter notifies to all windows between 'ancestor' and 'child' (excluding
 * both). Events are sent running down the window hierarchy. This function
 * recurses.
 */
static void
CoreEnterNotifies(DeviceIntPtr dev,
                  WindowPtr ancestor, WindowPtr child, int mode, int detail)
{
    WindowPtr parent = child->parent;

    if (ancestor == parent)
        return;
    CoreEnterNotifies(dev, ancestor, parent, mode, detail);

    /* Case 3:
       A is above W, B is a descendant

       Classically: The move generates an EnterNotify on W with a detail of
       Virtual or NonlinearVirtual

       MPX:
       Case 3A: There is at least one other pointer on W itself
       P(W) doesn't change, so the event should be suppressed
       Case 3B: Otherwise, if there is at least one other pointer in a
       descendant
       P(W) stays on the same descendant, or changes to a different
       descendant. The event should be suppressed.
       Case 3C: Otherwise:
       P(W) moves from a window above W to a descendant. The subwindow
       field is set to the child containing the descendant. The detail
       may need to be changed from Virtual to NonlinearVirtual depending
       on the previous P(W). */

    if (!HasPointer(dev, parent) && !FirstPointerChild(parent))
        CoreEnterLeaveEvent(dev, EnterNotify, mode, detail, parent,
                            child->drawable.id);
}

static void
CoreLeaveNotifies(DeviceIntPtr dev,
                  WindowPtr child, WindowPtr ancestor, int mode, int detail)
{
    WindowPtr win;

    if (ancestor == child)
        return;

    for (win = child->parent; win != ancestor; win = win->parent) {
        /*Case 7:
           A is a descendant of W, B is above W

           Classically: A LeaveNotify is generated on W with a detail of Virtual
           or NonlinearVirtual.

           MPX:
           Case 3A: There is at least one other pointer on W itself
           P(W) doesn't change, the event should be suppressed.
           Case 3B: Otherwise, if there is at least one other pointer in a
           descendant
           P(W) stays on the same descendant, or changes to a different
           descendant. The event should be suppressed.
           Case 3C: Otherwise:
           P(W) changes from the descendant of W to a window above W.
           The detail may need to be changed from Virtual to NonlinearVirtual
           or vice-versa depending on the new P(W). */

        /* If one window has a pointer or a child with a pointer, skip some
         * work and exit. */
        if (HasPointer(dev, win) || FirstPointerChild(win))
            return;

        CoreEnterLeaveEvent(dev, LeaveNotify, mode, detail, win,
                            child->drawable.id);

        child = win;
    }
}

/**
 * Send leave notifies to all windows between 'child' and 'ancestor'.
 * Events are sent running up the hierarchy.
 */
static void
DeviceLeaveNotifies(DeviceIntPtr dev,
                    int sourceid,
                    WindowPtr child, WindowPtr ancestor, int mode, int detail)
{
    WindowPtr win;

    if (ancestor == child)
        return;
    for (win = child->parent; win != ancestor; win = win->parent) {
        DeviceEnterLeaveEvent(dev, sourceid, XI_Leave, mode, detail, win,
                              child->drawable.id);
        child = win;
    }
}

/**
 * Pointer dev moves from A to B and A neither a descendant of B nor is
 * B a descendant of A.
 */
static void
CoreEnterLeaveNonLinear(DeviceIntPtr dev, WindowPtr A, WindowPtr B, int mode)
{
    WindowPtr X = CommonAncestor(A, B);

    /* Case 4:
       A is W, B is above W

       Classically: The move generates a LeaveNotify on W with a detail of
       Ancestor or Nonlinear

       MPX:
       Case 3A: There is at least one other pointer on W itself
       P(W) doesn't change, the event should be suppressed
       Case 3B: Otherwise, if there is at least one other pointer in a
       descendant of W
       P(W) changes from W to a descendant of W. The subwindow field
       is set to the child containing the new P(W), the detail field
       is set to Inferior
       Case 3C: Otherwise:
       The pointer window moves from W to a window above W.
       The detail may need to be changed from Ancestor to Nonlinear or
       vice versa depending on the the new P(W)
     */

    if (!HasPointer(dev, A)) {
        WindowPtr child = FirstPointerChild(A);

        if (child)
            CoreEnterLeaveEvent(dev, LeaveNotify, mode, NotifyInferior, A,
                                None);
        else
            CoreEnterLeaveEvent(dev, LeaveNotify, mode, NotifyNonlinear, A,
                                None);
    }

    CoreLeaveNotifies(dev, A, X, mode, NotifyNonlinearVirtual);

    /*
       Case 9:
       A is a descendant of W, B is a descendant of W

       Classically: No events are generated on W
       MPX: The pointer window stays the same or moves to a different
       descendant of W. No events should be generated on W.

       Therefore, no event to X.
     */

    CoreEnterNotifies(dev, X, B, mode, NotifyNonlinearVirtual);

    /* Case 2:
       A is above W, B=W

       Classically: The move generates an EnterNotify on W with a detail of
       Ancestor or Nonlinear

       MPX:
       Case 2A: There is at least one other pointer on W itself
       P(W) doesn't change, so the event should be suppressed
       Case 2B: Otherwise, if there is at least one other pointer in a
       descendant
       P(W) moves from a descendant to W. detail is changed to Inferior,
       subwindow is set to the child containing the previous P(W)
       Case 2C: Otherwise:
       P(W) changes from a window above W to W itself.
       The detail may need to be changed from Ancestor to Nonlinear
       or vice-versa depending on the previous P(W). */

    if (!HasPointer(dev, B)) {
        WindowPtr child = FirstPointerChild(B);

        if (child)
            CoreEnterLeaveEvent(dev, EnterNotify, mode, NotifyInferior, B,
                                None);
        else
            CoreEnterLeaveEvent(dev, EnterNotify, mode, NotifyNonlinear, B,
                                None);
    }
}

/**
 * Pointer dev moves from A to B and A is a descendant of B.
 */
static void
CoreEnterLeaveToAncestor(DeviceIntPtr dev, WindowPtr A, WindowPtr B, int mode)
{
    /* Case 4:
       A is W, B is above W

       Classically: The move generates a LeaveNotify on W with a detail of
       Ancestor or Nonlinear

       MPX:
       Case 3A: There is at least one other pointer on W itself
       P(W) doesn't change, the event should be suppressed
       Case 3B: Otherwise, if there is at least one other pointer in a
       descendant of W
       P(W) changes from W to a descendant of W. The subwindow field
       is set to the child containing the new P(W), the detail field
       is set to Inferior
       Case 3C: Otherwise:
       The pointer window moves from W to a window above W.
       The detail may need to be changed from Ancestor to Nonlinear or
       vice versa depending on the the new P(W)
     */
    if (!HasPointer(dev, A)) {
        WindowPtr child = FirstPointerChild(A);

        if (child)
            CoreEnterLeaveEvent(dev, LeaveNotify, mode, NotifyInferior, A,
                                None);
        else
            CoreEnterLeaveEvent(dev, LeaveNotify, mode, NotifyAncestor, A,
                                None);
    }

    CoreLeaveNotifies(dev, A, B, mode, NotifyVirtual);

    /* Case 8:
       A is a descendant of W, B is W

       Classically: A EnterNotify is generated on W with a detail of
       NotifyInferior

       MPX:
       Case 3A: There is at least one other pointer on W itself
       P(W) doesn't change, the event should be suppressed
       Case 3B: Otherwise:
       P(W) changes from a descendant to W itself. The subwindow
       field should be set to the child containing the old P(W) <<< WRONG */

    if (!HasPointer(dev, B))
        CoreEnterLeaveEvent(dev, EnterNotify, mode, NotifyInferior, B, None);

}

/**
 * Pointer dev moves from A to B and B is a descendant of A.
 */
static void
CoreEnterLeaveToDescendant(DeviceIntPtr dev, WindowPtr A, WindowPtr B, int mode)
{
    /* Case 6:
       A is W, B is a descendant of W

       Classically: A LeaveNotify is generated on W with a detail of
       NotifyInferior

       MPX:
       Case 3A: There is at least one other pointer on W itself
       P(W) doesn't change, the event should be suppressed
       Case 3B: Otherwise:
       P(W) changes from W to a descendant of W. The subwindow field
       is set to the child containing the new P(W) <<< THIS IS WRONG */

    if (!HasPointer(dev, A))
        CoreEnterLeaveEvent(dev, LeaveNotify, mode, NotifyInferior, A, None);

    CoreEnterNotifies(dev, A, B, mode, NotifyVirtual);

    /* Case 2:
       A is above W, B=W

       Classically: The move generates an EnterNotify on W with a detail of
       Ancestor or Nonlinear

       MPX:
       Case 2A: There is at least one other pointer on W itself
       P(W) doesn't change, so the event should be suppressed
       Case 2B: Otherwise, if there is at least one other pointer in a
       descendant
       P(W) moves from a descendant to W. detail is changed to Inferior,
       subwindow is set to the child containing the previous P(W)
       Case 2C: Otherwise:
       P(W) changes from a window above W to W itself.
       The detail may need to be changed from Ancestor to Nonlinear
       or vice-versa depending on the previous P(W). */

    if (!HasPointer(dev, B)) {
        WindowPtr child = FirstPointerChild(B);

        if (child)
            CoreEnterLeaveEvent(dev, EnterNotify, mode, NotifyInferior, B,
                                None);
        else
            CoreEnterLeaveEvent(dev, EnterNotify, mode, NotifyAncestor, B,
                                None);
    }
}

static void
CoreEnterLeaveEvents(DeviceIntPtr dev, WindowPtr from, WindowPtr to, int mode)
{
    if (!IsMaster(dev))
        return;

    LeaveWindow(dev);

    if (IsParent(from, to))
        CoreEnterLeaveToDescendant(dev, from, to, mode);
    else if (IsParent(to, from))
        CoreEnterLeaveToAncestor(dev, from, to, mode);
    else
        CoreEnterLeaveNonLinear(dev, from, to, mode);

    EnterWindow(dev, to, mode);
}

static void
DeviceEnterLeaveEvents(DeviceIntPtr dev,
                       int sourceid, WindowPtr from, WindowPtr to, int mode)
{
    if (IsParent(from, to)) {
        DeviceEnterLeaveEvent(dev, sourceid, XI_Leave, mode, NotifyInferior,
                              from, None);
        DeviceEnterNotifies(dev, sourceid, from, to, mode, NotifyVirtual);
        DeviceEnterLeaveEvent(dev, sourceid, XI_Enter, mode, NotifyAncestor, to,
                              None);
    }
    else if (IsParent(to, from)) {
        DeviceEnterLeaveEvent(dev, sourceid, XI_Leave, mode, NotifyAncestor,
                              from, None);
        DeviceLeaveNotifies(dev, sourceid, from, to, mode, NotifyVirtual);
        DeviceEnterLeaveEvent(dev, sourceid, XI_Enter, mode, NotifyInferior, to,
                              None);
    }
    else {                      /* neither from nor to is descendent of the other */
        WindowPtr common = CommonAncestor(to, from);

        /* common == NullWindow ==> different screens */
        DeviceEnterLeaveEvent(dev, sourceid, XI_Leave, mode, NotifyNonlinear,
                              from, None);
        DeviceLeaveNotifies(dev, sourceid, from, common, mode,
                            NotifyNonlinearVirtual);
        DeviceEnterNotifies(dev, sourceid, common, to, mode,
                            NotifyNonlinearVirtual);
        DeviceEnterLeaveEvent(dev, sourceid, XI_Enter, mode, NotifyNonlinear,
                              to, None);
    }
}

/**
 * Figure out if enter/leave events are necessary and send them to the
 * appropriate windows.
 *
 * @@param fromWin Window the sprite moved out of.
 * @@param toWin Window the sprite moved into.
 */
void
DoEnterLeaveEvents(DeviceIntPtr pDev,
                   int sourceid, WindowPtr fromWin, WindowPtr toWin, int mode)
{
    if (!IsPointerDevice(pDev))
        return;

    if (fromWin == toWin)
        return;

    if (mode != XINotifyPassiveGrab && mode != XINotifyPassiveUngrab)
        CoreEnterLeaveEvents(pDev, fromWin, toWin, mode);
    DeviceEnterLeaveEvents(pDev, sourceid, fromWin, toWin, mode);
}

static void
FixDeviceValuator(DeviceIntPtr dev, deviceValuator * ev, ValuatorClassPtr v,
                  int first)
{
    int nval = v->numAxes - first;

    ev->type = DeviceValuator;
    ev->deviceid = dev->id;
    ev->num_valuators = nval < 3 ? nval : 3;
    ev->first_valuator = first;
    switch (ev->num_valuators) {
    case 3:
        ev->valuator2 = v->axisVal[first + 2];
    case 2:
        ev->valuator1 = v->axisVal[first + 1];
    case 1:
        ev->valuator0 = v->axisVal[first];
        break;
    }
    first += ev->num_valuators;
}

static void
FixDeviceStateNotify(DeviceIntPtr dev, deviceStateNotify * ev, KeyClassPtr k,
                     ButtonClassPtr b, ValuatorClassPtr v, int first)
{
    ev->type = DeviceStateNotify;
    ev->deviceid = dev->id;
    ev->time = currentTime.milliseconds;
    ev->classes_reported = 0;
    ev->num_keys = 0;
    ev->num_buttons = 0;
    ev->num_valuators = 0;

    if (b) {
        ev->classes_reported |= (1 << ButtonClass);
        ev->num_buttons = b->numButtons;
        memcpy((char *) ev->buttons, (char *) b->down, 4);
    }
    else if (k) {
        ev->classes_reported |= (1 << KeyClass);
        ev->num_keys = k->xkbInfo->desc->max_key_code -
            k->xkbInfo->desc->min_key_code;
        memmove((char *) &ev->keys[0], (char *) k->down, 4);
    }
    if (v) {
        int nval = v->numAxes - first;

        ev->classes_reported |= (1 << ValuatorClass);
        ev->classes_reported |= valuator_get_mode(dev, 0) << ModeBitsShift;
        ev->num_valuators = nval < 3 ? nval : 3;
        switch (ev->num_valuators) {
        case 3:
            ev->valuator2 = v->axisVal[first + 2];
        case 2:
            ev->valuator1 = v->axisVal[first + 1];
        case 1:
            ev->valuator0 = v->axisVal[first];
            break;
        }
    }
}


static void
DeliverStateNotifyEvent(DeviceIntPtr dev, WindowPtr win)
{
    int evcount = 1;
    deviceStateNotify *ev, *sev;
    deviceKeyStateNotify *kev;
    deviceButtonStateNotify *bev;

    KeyClassPtr k;
    ButtonClassPtr b;
    ValuatorClassPtr v;
    int nval = 0, nkeys = 0, nbuttons = 0, first = 0;

    if (!(wOtherInputMasks(win)) ||
        !(wOtherInputMasks(win)->inputEvents[dev->id] & DeviceStateNotifyMask))
        return;

    if ((b = dev->button) != NULL) {
        nbuttons = b->numButtons;
        if (nbuttons > 32)
            evcount++;
    }
    if ((k = dev->key) != NULL) {
        nkeys = k->xkbInfo->desc->max_key_code - k->xkbInfo->desc->min_key_code;
        if (nkeys > 32)
            evcount++;
        if (nbuttons > 0) {
            evcount++;
        }
    }
    if ((v = dev->valuator) != NULL) {
        nval = v->numAxes;

        if (nval > 3)
            evcount++;
        if (nval > 6) {
            if (!(k && b))
                evcount++;
            if (nval > 9)
                evcount += ((nval - 7) / 3);
        }
    }

    sev = ev = xallocarray(evcount, sizeof(xEvent));
    FixDeviceStateNotify(dev, ev, NULL, NULL, NULL, first);

    if (b != NULL) {
        FixDeviceStateNotify(dev, ev++, NULL, b, v, first);
        first += 3;
        nval -= 3;
        if (nbuttons > 32) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            bev = (deviceButtonStateNotify *) ev++;
            bev->type = DeviceButtonStateNotify;
            bev->deviceid = dev->id;
            memcpy((char *) &bev->buttons[4], (char *) &b->down[4],
                   DOWN_LENGTH - 4);
        }
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    if (k != NULL) {
        FixDeviceStateNotify(dev, ev++, k, NULL, v, first);
        first += 3;
        nval -= 3;
        if (nkeys > 32) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            kev = (deviceKeyStateNotify *) ev++;
            kev->type = DeviceKeyStateNotify;
            kev->deviceid = dev->id;
            memmove((char *) &kev->keys[0], (char *) &k->down[4], 28);
        }
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    while (nval > 0) {
        FixDeviceStateNotify(dev, ev++, NULL, NULL, v, first);
        first += 3;
        nval -= 3;
        if (nval > 0) {
            (ev - 1)->deviceid |= MORE_EVENTS;
            FixDeviceValuator(dev, (deviceValuator *) ev++, v, first);
            first += 3;
            nval -= 3;
        }
    }

    DeliverEventsToWindow(dev, win, (xEvent *) sev, evcount,
                          DeviceStateNotifyMask, NullGrab);
    free(sev);
}

void
DeviceFocusEvent(DeviceIntPtr dev, int type, int mode, int detail,
                 WindowPtr pWin)
{
    deviceFocus event;
    xXIFocusInEvent *xi2event;
    DeviceIntPtr mouse;
    int btlen, len, i;

    mouse = IsFloating(dev) ? dev : GetMaster(dev, MASTER_POINTER);

    /* XI 2 event */
    btlen = (mouse->button) ? bits_to_bytes(mouse->button->numButtons) : 0;
    btlen = bytes_to_int32(btlen);
    len = sizeof(xXIFocusInEvent) + btlen * 4;

    xi2event = calloc(1, len);
    xi2event->type = GenericEvent;
    xi2event->extension = IReqCode;
    xi2event->evtype = type;
    xi2event->length = bytes_to_int32(len - sizeof(xEvent));
    xi2event->buttons_len = btlen;
    xi2event->detail = detail;
    xi2event->time = currentTime.milliseconds;
    xi2event->deviceid = dev->id;
    xi2event->sourceid = dev->id;       /* a device doesn't change focus by itself */
    xi2event->mode = mode;
    xi2event->root_x = double_to_fp1616(mouse->spriteInfo->sprite->hot.x);
    xi2event->root_y = double_to_fp1616(mouse->spriteInfo->sprite->hot.y);

    for (i = 0; mouse && mouse->button && i < mouse->button->numButtons; i++)
        if (BitIsOn(mouse->button->down, i))
            SetBit(&xi2event[1], mouse->button->map[i]);

    if (dev->key) {
        xi2event->mods.base_mods = dev->key->xkbInfo->state.base_mods;
        xi2event->mods.latched_mods = dev->key->xkbInfo->state.latched_mods;
        xi2event->mods.locked_mods = dev->key->xkbInfo->state.locked_mods;
        xi2event->mods.effective_mods = dev->key->xkbInfo->state.mods;

        xi2event->group.base_group = dev->key->xkbInfo->state.base_group;
        xi2event->group.latched_group = dev->key->xkbInfo->state.latched_group;
        xi2event->group.locked_group = dev->key->xkbInfo->state.locked_group;
        xi2event->group.effective_group = dev->key->xkbInfo->state.group;
    }

    FixUpEventFromWindow(dev->spriteInfo->sprite, (xEvent *) xi2event, pWin,
                         None, FALSE);

    DeliverEventsToWindow(dev, pWin, (xEvent *) xi2event, 1,
                          GetEventFilter(dev, (xEvent *) xi2event), NullGrab);

    free(xi2event);

    /* XI 1.x event */
    event = (deviceFocus) {
        .deviceid = dev->id,
        .mode = mode,
        .type = (type == XI_FocusIn) ? DeviceFocusIn : DeviceFocusOut,
        .detail = detail,
        .window = pWin->drawable.id,
        .time = currentTime.milliseconds
    };

    DeliverEventsToWindow(dev, pWin, (xEvent *) &event, 1,
                          DeviceFocusChangeMask, NullGrab);

    if (event.type == DeviceFocusIn)
        DeliverStateNotifyEvent(dev, pWin);
}

/**
 * Send focus out events to all windows between 'child' and 'ancestor'.
 * Events are sent running up the hierarchy.
 */
static void
DeviceFocusOutEvents(DeviceIntPtr dev,
                     WindowPtr child, WindowPtr ancestor, int mode, int detail)
{
    WindowPtr win;

    if (ancestor == child)
        return;
    for (win = child->parent; win != ancestor; win = win->parent)
        DeviceFocusEvent(dev, XI_FocusOut, mode, detail, win);
}

/**
 * Send enter notifies to all windows between 'ancestor' and 'child' (excluding
 * both). Events are sent running up the window hierarchy. This function
 * recurses.
 */
static void
DeviceFocusInEvents(DeviceIntPtr dev,
                    WindowPtr ancestor, WindowPtr child, int mode, int detail)
{
    WindowPtr parent = child->parent;

    if (ancestor == parent || !parent)
        return;
    DeviceFocusInEvents(dev, ancestor, parent, mode, detail);
    DeviceFocusEvent(dev, XI_FocusIn, mode, detail, parent);
}

/**
 * Send FocusIn events to all windows between 'ancestor' and 'child' (excluding
 * both). Events are sent running down the window hierarchy. This function
 * recurses.
 */
static void
CoreFocusInEvents(DeviceIntPtr dev,
                  WindowPtr ancestor, WindowPtr child, int mode, int detail)
{
    WindowPtr parent = child->parent;

    if (ancestor == parent)
        return;
    CoreFocusInEvents(dev, ancestor, parent, mode, detail);

    /* Case 3:
       A is above W, B is a descendant

       Classically: The move generates an FocusIn on W with a detail of
       Virtual or NonlinearVirtual

       MPX:
       Case 3A: There is at least one other focus on W itself
       F(W) doesn't change, so the event should be suppressed
       Case 3B: Otherwise, if there is at least one other focus in a
       descendant
       F(W) stays on the same descendant, or changes to a different
       descendant. The event should be suppressed.
       Case 3C: Otherwise:
       F(W) moves from a window above W to a descendant. The detail may
       need to be changed from Virtual to NonlinearVirtual depending
       on the previous F(W). */

    if (!HasFocus(parent) && !FirstFocusChild(parent))
        CoreFocusEvent(dev, FocusIn, mode, detail, parent);
}

static void
CoreFocusOutEvents(DeviceIntPtr dev,
                   WindowPtr child, WindowPtr ancestor, int mode, int detail)
{
    WindowPtr win;

    if (ancestor == child)
        return;

    for (win = child->parent; win != ancestor; win = win->parent) {
        /*Case 7:
           A is a descendant of W, B is above W

           Classically: A FocusOut is generated on W with a detail of Virtual
           or NonlinearVirtual.

           MPX:
           Case 3A: There is at least one other focus on W itself
           F(W) doesn't change, the event should be suppressed.
           Case 3B: Otherwise, if there is at least one other focus in a
           descendant
           F(W) stays on the same descendant, or changes to a different
           descendant. The event should be suppressed.
           Case 3C: Otherwise:
           F(W) changes from the descendant of W to a window above W.
           The detail may need to be changed from Virtual to NonlinearVirtual
           or vice-versa depending on the new P(W). */

        /* If one window has a focus or a child with a focuspointer, skip some
         * work and exit. */
        if (HasFocus(win) || FirstFocusChild(win))
            return;

        CoreFocusEvent(dev, FocusOut, mode, detail, win);
    }
}

/**
 * Send FocusOut(NotifyPointer) events from the current pointer window (which
 * is a descendant of pwin_parent) up to (excluding) pwin_parent.
 *
 * NotifyPointer events are only sent for the device paired with dev.
 *
 * If the current pointer window is a descendant of 'exclude' or an ancestor of
 * 'exclude', no events are sent. If the current pointer IS 'exclude', events
 * are sent!
 */
static void
CoreFocusOutNotifyPointerEvents(DeviceIntPtr dev,
                                WindowPtr pwin_parent,
                                WindowPtr exclude, int mode, int inclusive)
{
    WindowPtr P, stopAt;

    P = PointerWin(GetMaster(dev, POINTER_OR_FLOAT));

    if (!P)
        return;
    if (!IsParent(pwin_parent, P))
        if (!(pwin_parent == P && inclusive))
            return;

    if (exclude != None && exclude != PointerRootWin &&
        (IsParent(exclude, P) || IsParent(P, exclude)))
        return;

    stopAt = (inclusive) ? pwin_parent->parent : pwin_parent;

    for (; P && P != stopAt; P = P->parent)
        CoreFocusEvent(dev, FocusOut, mode, NotifyPointer, P);
}

/**
 * DO NOT CALL DIRECTLY.
 * Recursion helper for CoreFocusInNotifyPointerEvents.
 */
static void
CoreFocusInRecurse(DeviceIntPtr dev,
                   WindowPtr win, WindowPtr stopAt, int mode, int inclusive)
{
    if ((!inclusive && win == stopAt) || !win)
        return;

    CoreFocusInRecurse(dev, win->parent, stopAt, mode, inclusive);
    CoreFocusEvent(dev, FocusIn, mode, NotifyPointer, win);
}

/**
 * Send FocusIn(NotifyPointer) events from pwin_parent down to
 * including the current pointer window (which is a descendant of pwin_parent).
 *
 * @@param pwin The pointer window.
 * @@param exclude If the pointer window is a child of 'exclude', no events are
 *                sent.
 * @@param inclusive If TRUE, pwin_parent will receive the event too.
 */
static void
CoreFocusInNotifyPointerEvents(DeviceIntPtr dev,
                               WindowPtr pwin_parent,
                               WindowPtr exclude, int mode, int inclusive)
{
    WindowPtr P;

    P = PointerWin(GetMaster(dev, POINTER_OR_FLOAT));

    if (!P || P == exclude || (pwin_parent != P && !IsParent(pwin_parent, P)))
        return;

    if (exclude != None && (IsParent(exclude, P) || IsParent(P, exclude)))
        return;

    CoreFocusInRecurse(dev, P, pwin_parent, mode, inclusive);
}

/**
 * Focus of dev moves from A to B and A neither a descendant of B nor is
 * B a descendant of A.
 */
static void
CoreFocusNonLinear(DeviceIntPtr dev, WindowPtr A, WindowPtr B, int mode)
{
    WindowPtr X = CommonAncestor(A, B);

    /* Case 4:
       A is W, B is above W

       Classically: The change generates a FocusOut on W with a detail of
       Ancestor or Nonlinear

       MPX:
       Case 3A: There is at least one other focus on W itself
       F(W) doesn't change, the event should be suppressed
       Case 3B: Otherwise, if there is at least one other focus in a
       descendant of W
       F(W) changes from W to a descendant of W. The detail field
       is set to Inferior
       Case 3C: Otherwise:
       The focus window moves from W to a window above W.
       The detail may need to be changed from Ancestor to Nonlinear or
       vice versa depending on the the new F(W)
     */

    if (!HasFocus(A)) {
        WindowPtr child = FirstFocusChild(A);

        if (child) {
            /* NotifyPointer P-A unless P is child or below */
            CoreFocusOutNotifyPointerEvents(dev, A, child, mode, FALSE);
            CoreFocusEvent(dev, FocusOut, mode, NotifyInferior, A);
        }
        else {
            /* NotifyPointer P-A */
            CoreFocusOutNotifyPointerEvents(dev, A, None, mode, FALSE);
            CoreFocusEvent(dev, FocusOut, mode, NotifyNonlinear, A);
        }
    }

    CoreFocusOutEvents(dev, A, X, mode, NotifyNonlinearVirtual);

    /*
       Case 9:
       A is a descendant of W, B is a descendant of W

       Classically: No events are generated on W
       MPX: The focus window stays the same or moves to a different
       descendant of W. No events should be generated on W.

       Therefore, no event to X.
     */

    CoreFocusInEvents(dev, X, B, mode, NotifyNonlinearVirtual);

    /* Case 2:
       A is above W, B=W

       Classically: The move generates an EnterNotify on W with a detail of
       Ancestor or Nonlinear

       MPX:
       Case 2A: There is at least one other focus on W itself
       F(W) doesn't change, so the event should be suppressed
       Case 2B: Otherwise, if there is at least one other focus in a
       descendant
       F(W) moves from a descendant to W. detail is changed to Inferior.
       Case 2C: Otherwise:
       F(W) changes from a window above W to W itself.
       The detail may need to be changed from Ancestor to Nonlinear
       or vice-versa depending on the previous F(W). */

    if (!HasFocus(B)) {
        WindowPtr child = FirstFocusChild(B);

        if (child) {
            CoreFocusEvent(dev, FocusIn, mode, NotifyInferior, B);
            /* NotifyPointer B-P unless P is child or below. */
            CoreFocusInNotifyPointerEvents(dev, B, child, mode, FALSE);
        }
        else {
            CoreFocusEvent(dev, FocusIn, mode, NotifyNonlinear, B);
            /* NotifyPointer B-P unless P is child or below. */
            CoreFocusInNotifyPointerEvents(dev, B, None, mode, FALSE);
        }
    }
}

/**
 * Focus of dev moves from A to B and A is a descendant of B.
 */
static void
CoreFocusToAncestor(DeviceIntPtr dev, WindowPtr A, WindowPtr B, int mode)
{
    /* Case 4:
       A is W, B is above W

       Classically: The change generates a FocusOut on W with a detail of
       Ancestor or Nonlinear

       MPX:
       Case 3A: There is at least one other focus on W itself
       F(W) doesn't change, the event should be suppressed
       Case 3B: Otherwise, if there is at least one other focus in a
       descendant of W
       F(W) changes from W to a descendant of W. The detail field
       is set to Inferior
       Case 3C: Otherwise:
       The focus window moves from W to a window above W.
       The detail may need to be changed from Ancestor to Nonlinear or
       vice versa depending on the the new F(W)
     */
    if (!HasFocus(A)) {
        WindowPtr child = FirstFocusChild(A);

        if (child) {
            /* NotifyPointer P-A unless P is child or below */
            CoreFocusOutNotifyPointerEvents(dev, A, child, mode, FALSE);
            CoreFocusEvent(dev, FocusOut, mode, NotifyInferior, A);
        }
        else
            CoreFocusEvent(dev, FocusOut, mode, NotifyAncestor, A);
    }

    CoreFocusOutEvents(dev, A, B, mode, NotifyVirtual);

    /* Case 8:
       A is a descendant of W, B is W

       Classically: A FocusOut is generated on W with a detail of
       NotifyInferior

       MPX:
       Case 3A: There is at least one other focus on W itself
       F(W) doesn't change, the event should be suppressed
       Case 3B: Otherwise:
       F(W) changes from a descendant to W itself. */

    if (!HasFocus(B)) {
        CoreFocusEvent(dev, FocusIn, mode, NotifyInferior, B);
        /* NotifyPointer B-P unless P is A or below. */
        CoreFocusInNotifyPointerEvents(dev, B, A, mode, FALSE);
    }
}

/**
 * Focus of dev moves from A to B and B is a descendant of A.
 */
static void
CoreFocusToDescendant(DeviceIntPtr dev, WindowPtr A, WindowPtr B, int mode)
{
    /* Case 6:
       A is W, B is a descendant of W

       Classically: A FocusOut is generated on W with a detail of
       NotifyInferior

       MPX:
       Case 3A: There is at least one other focus on W itself
       F(W) doesn't change, the event should be suppressed
       Case 3B: Otherwise:
       F(W) changes from W to a descendant of W. */

    if (!HasFocus(A)) {
        /* NotifyPointer P-A unless P is B or below */
        CoreFocusOutNotifyPointerEvents(dev, A, B, mode, FALSE);
        CoreFocusEvent(dev, FocusOut, mode, NotifyInferior, A);
    }

    CoreFocusInEvents(dev, A, B, mode, NotifyVirtual);

    /* Case 2:
       A is above W, B=W

       Classically: The move generates an FocusIn on W with a detail of
       Ancestor or Nonlinear

       MPX:
       Case 2A: There is at least one other focus on W itself
       F(W) doesn't change, so the event should be suppressed
       Case 2B: Otherwise, if there is at least one other focus in a
       descendant
       F(W) moves from a descendant to W. detail is changed to Inferior.
       Case 2C: Otherwise:
       F(W) changes from a window above W to W itself.
       The detail may need to be changed from Ancestor to Nonlinear
       or vice-versa depending on the previous F(W). */

    if (!HasFocus(B)) {
        WindowPtr child = FirstFocusChild(B);

        if (child) {
            CoreFocusEvent(dev, FocusIn, mode, NotifyInferior, B);
            /* NotifyPointer B-P unless P is child or below. */
            CoreFocusInNotifyPointerEvents(dev, B, child, mode, FALSE);
        }
        else
            CoreFocusEvent(dev, FocusIn, mode, NotifyAncestor, B);
    }
}

static BOOL
HasOtherPointer(WindowPtr win, DeviceIntPtr exclude)
{
    int i;

    for (i = 0; i < MAXDEVICES; i++)
        if (i != exclude->id && PointerWindows[i] == win)
            return TRUE;

    return FALSE;
}

/**
 * Focus moves from PointerRoot to None or from None to PointerRoot.
 * Assumption: Neither A nor B are valid windows.
 */
static void
CoreFocusPointerRootNoneSwitch(DeviceIntPtr dev,
                               WindowPtr A,     /* PointerRootWin or NoneWin */
                               WindowPtr B,     /* NoneWin or PointerRootWin */
                               int mode)
{
    WindowPtr root;
    int i;
    int nscreens = screenInfo.numScreens;

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        nscreens = 1;
#endif

    for (i = 0; i < nscreens; i++) {
        root = screenInfo.screens[i]->root;
        if (!HasOtherPointer(root, GetMaster(dev, POINTER_OR_FLOAT)) &&
            !FirstFocusChild(root)) {
            /* If pointer was on PointerRootWin and changes to NoneWin, and
             * the pointer paired with dev is below the current root window,
             * do a NotifyPointer run. */
            if (dev->focus && dev->focus->win == PointerRootWin &&
                B != PointerRootWin) {
                WindowPtr ptrwin = PointerWin(GetMaster(dev, POINTER_OR_FLOAT));

                if (ptrwin && IsParent(root, ptrwin))
                    CoreFocusOutNotifyPointerEvents(dev, root, None, mode,
                                                    TRUE);
            }
            CoreFocusEvent(dev, FocusOut, mode,
                           A ? NotifyPointerRoot : NotifyDetailNone, root);
            CoreFocusEvent(dev, FocusIn, mode,
                           B ? NotifyPointerRoot : NotifyDetailNone, root);
            if (B == PointerRootWin)
                CoreFocusInNotifyPointerEvents(dev, root, None, mode, TRUE);
        }

    }
}

/**
 * Focus moves from window A to PointerRoot or to None.
 * Assumption: A is a valid window and not PointerRoot or None.
 */
static void
CoreFocusToPointerRootOrNone(DeviceIntPtr dev, WindowPtr A,
                             WindowPtr B,        /* PointerRootWin or NoneWin */
                             int mode)
{
    WindowPtr root;
    int i;
    int nscreens = screenInfo.numScreens;

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        nscreens = 1;
#endif

    if (!HasFocus(A)) {
        WindowPtr child = FirstFocusChild(A);

        if (child) {
            /* NotifyPointer P-A unless P is B or below */
            CoreFocusOutNotifyPointerEvents(dev, A, B, mode, FALSE);
            CoreFocusEvent(dev, FocusOut, mode, NotifyInferior, A);
        }
        else {
            /* NotifyPointer P-A */
            CoreFocusOutNotifyPointerEvents(dev, A, None, mode, FALSE);
            CoreFocusEvent(dev, FocusOut, mode, NotifyNonlinear, A);
        }
    }

    /* NullWindow means we include the root window */
    CoreFocusOutEvents(dev, A, NullWindow, mode, NotifyNonlinearVirtual);

    for (i = 0; i < nscreens; i++) {
        root = screenInfo.screens[i]->root;
        if (!HasFocus(root) && !FirstFocusChild(root)) {
            CoreFocusEvent(dev, FocusIn, mode,
                           B ? NotifyPointerRoot : NotifyDetailNone, root);
            if (B == PointerRootWin)
                CoreFocusInNotifyPointerEvents(dev, root, None, mode, TRUE);
        }
    }
}

/**
 * Focus moves from PointerRoot or None to a window B.
 * Assumption: B is a valid window and not PointerRoot or None.
 */
static void
CoreFocusFromPointerRootOrNone(DeviceIntPtr dev,
                               WindowPtr A,   /* PointerRootWin or NoneWin */
                               WindowPtr B, int mode)
{
    WindowPtr root;
    int i;
    int nscreens = screenInfo.numScreens;

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        nscreens = 1;
#endif

    for (i = 0; i < nscreens; i++) {
        root = screenInfo.screens[i]->root;
        if (!HasFocus(root) && !FirstFocusChild(root)) {
            /* If pointer was on PointerRootWin and changes to NoneWin, and
             * the pointer paired with dev is below the current root window,
             * do a NotifyPointer run. */
            if (dev->focus && dev->focus->win == PointerRootWin &&
                B != PointerRootWin) {
                WindowPtr ptrwin = PointerWin(GetMaster(dev, POINTER_OR_FLOAT));

                if (ptrwin)
                    CoreFocusOutNotifyPointerEvents(dev, root, None, mode,
                                                    TRUE);
            }
            CoreFocusEvent(dev, FocusOut, mode,
                           A ? NotifyPointerRoot : NotifyDetailNone, root);
        }
    }

    root = B;                   /* get B's root window */
    while (root->parent)
        root = root->parent;

    if (B != root) {
        CoreFocusEvent(dev, FocusIn, mode, NotifyNonlinearVirtual, root);
        CoreFocusInEvents(dev, root, B, mode, NotifyNonlinearVirtual);
    }

    if (!HasFocus(B)) {
        WindowPtr child = FirstFocusChild(B);

        if (child) {
            CoreFocusEvent(dev, FocusIn, mode, NotifyInferior, B);
            /* NotifyPointer B-P unless P is child or below. */
            CoreFocusInNotifyPointerEvents(dev, B, child, mode, FALSE);
        }
        else {
            CoreFocusEvent(dev, FocusIn, mode, NotifyNonlinear, B);
            /* NotifyPointer B-P unless P is child or below. */
            CoreFocusInNotifyPointerEvents(dev, B, None, mode, FALSE);
        }
    }

}

static void
CoreFocusEvents(DeviceIntPtr dev, WindowPtr from, WindowPtr to, int mode)
{
    if (!IsMaster(dev))
        return;

    SetFocusOut(dev);

    if (((to == NullWindow) || (to == PointerRootWin)) &&
        ((from == NullWindow) || (from == PointerRootWin)))
        CoreFocusPointerRootNoneSwitch(dev, from, to, mode);
    else if ((to == NullWindow) || (to == PointerRootWin))
        CoreFocusToPointerRootOrNone(dev, from, to, mode);
    else if ((from == NullWindow) || (from == PointerRootWin))
        CoreFocusFromPointerRootOrNone(dev, from, to, mode);
    else if (IsParent(from, to))
        CoreFocusToDescendant(dev, from, to, mode);
    else if (IsParent(to, from))
        CoreFocusToAncestor(dev, from, to, mode);
    else
        CoreFocusNonLinear(dev, from, to, mode);

    SetFocusIn(dev, to);
}

static void
DeviceFocusEvents(DeviceIntPtr dev, WindowPtr from, WindowPtr to, int mode)
{
    int out, in;                /* for holding details for to/from
                                   PointerRoot/None */
    int i;
    int nscreens = screenInfo.numScreens;
    SpritePtr sprite = dev->spriteInfo->sprite;

    if (from == to)
        return;
    out = (from == NoneWin) ? NotifyDetailNone : NotifyPointerRoot;
    in = (to == NoneWin) ? NotifyDetailNone : NotifyPointerRoot;
    /* wrong values if neither, but then not referenced */

#ifdef PANORAMIX
    if (!noPanoramiXExtension)
        nscreens = 1;
#endif

    if ((to == NullWindow) || (to == PointerRootWin)) {
        if ((from == NullWindow) || (from == PointerRootWin)) {
            if (from == PointerRootWin) {
                DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyPointer,
                                 sprite->win);
                DeviceFocusOutEvents(dev, sprite->win,
                                     GetCurrentRootWindow(dev), mode,
                                     NotifyPointer);
            }
            /* Notify all the roots */
            for (i = 0; i < nscreens; i++)
                DeviceFocusEvent(dev, XI_FocusOut, mode, out,
                                 screenInfo.screens[i]->root);
        }
        else {
            if (IsParent(from, sprite->win)) {
                DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyPointer,
                                 sprite->win);
                DeviceFocusOutEvents(dev, sprite->win, from, mode,
                                     NotifyPointer);
            }
            DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyNonlinear, from);
            /* next call catches the root too, if the screen changed */
            DeviceFocusOutEvents(dev, from, NullWindow, mode,
                                 NotifyNonlinearVirtual);
        }
        /* Notify all the roots */
        for (i = 0; i < nscreens; i++)
            DeviceFocusEvent(dev, XI_FocusIn, mode, in,
                             screenInfo.screens[i]->root);
        if (to == PointerRootWin) {
            DeviceFocusInEvents(dev, GetCurrentRootWindow(dev), sprite->win,
                                mode, NotifyPointer);
            DeviceFocusEvent(dev, XI_FocusIn, mode, NotifyPointer, sprite->win);
        }
    }
    else {
        if ((from == NullWindow) || (from == PointerRootWin)) {
            if (from == PointerRootWin) {
                DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyPointer,
                                 sprite->win);
                DeviceFocusOutEvents(dev, sprite->win,
                                     GetCurrentRootWindow(dev), mode,
                                     NotifyPointer);
            }
            for (i = 0; i < nscreens; i++)
                DeviceFocusEvent(dev, XI_FocusOut, mode, out,
                                 screenInfo.screens[i]->root);
            if (to->parent != NullWindow)
                DeviceFocusInEvents(dev, GetCurrentRootWindow(dev), to, mode,
                                    NotifyNonlinearVirtual);
            DeviceFocusEvent(dev, XI_FocusIn, mode, NotifyNonlinear, to);
            if (IsParent(to, sprite->win))
                DeviceFocusInEvents(dev, to, sprite->win, mode, NotifyPointer);
        }
        else {
            if (IsParent(to, from)) {
                DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyAncestor, from);
                DeviceFocusOutEvents(dev, from, to, mode, NotifyVirtual);
                DeviceFocusEvent(dev, XI_FocusIn, mode, NotifyInferior, to);
                if ((IsParent(to, sprite->win)) &&
                    (sprite->win != from) &&
                    (!IsParent(from, sprite->win)) &&
                    (!IsParent(sprite->win, from)))
                    DeviceFocusInEvents(dev, to, sprite->win, mode,
                                        NotifyPointer);
            }
            else if (IsParent(from, to)) {
                if ((IsParent(from, sprite->win)) &&
                    (sprite->win != from) &&
                    (!IsParent(to, sprite->win)) &&
                    (!IsParent(sprite->win, to))) {
                    DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyPointer,
                                     sprite->win);
                    DeviceFocusOutEvents(dev, sprite->win, from, mode,
                                         NotifyPointer);
                }
                DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyInferior, from);
                DeviceFocusInEvents(dev, from, to, mode, NotifyVirtual);
                DeviceFocusEvent(dev, XI_FocusIn, mode, NotifyAncestor, to);
            }
            else {
                /* neither from or to is child of other */
                WindowPtr common = CommonAncestor(to, from);

                /* common == NullWindow ==> different screens */
                if (IsParent(from, sprite->win))
                    DeviceFocusOutEvents(dev, sprite->win, from, mode,
                                         NotifyPointer);
                DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyNonlinear, from);
                if (from->parent != NullWindow)
                    DeviceFocusOutEvents(dev, from, common, mode,
                                         NotifyNonlinearVirtual);
                if (to->parent != NullWindow)
                    DeviceFocusInEvents(dev, common, to, mode,
                                        NotifyNonlinearVirtual);
                DeviceFocusEvent(dev, XI_FocusIn, mode, NotifyNonlinear, to);
                if (IsParent(to, sprite->win))
                    DeviceFocusInEvents(dev, to, sprite->win, mode,
                                        NotifyPointer);
            }
        }
    }
}

/**
 * Figure out if focus events are necessary and send them to the
 * appropriate windows.
 *
 * @@param from Window the focus moved out of.
 * @@param to Window the focus moved into.
 */
void
DoFocusEvents(DeviceIntPtr pDev, WindowPtr from, WindowPtr to, int mode)
{
    if (!IsKeyboardDevice(pDev))
        return;

    if (from == to)
        return;

    CoreFocusEvents(pDev, from, to, mode);
    DeviceFocusEvents(pDev, from, to, mode);
}
@


1.7
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d1449 3
a1451 1
            if (from == PointerRootWin)
d1455 1
d1462 3
a1464 1
            if (IsParent(from, sprite->win))
d1467 1
d1485 3
a1487 1
            if (from == PointerRootWin)
d1491 1
d1518 3
a1520 1
                    (!IsParent(sprite->win, to)))
d1523 1
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d215 1
a215 1
WindowPtr
d717 1
a717 1
    sev = ev = (deviceStateNotify *) malloc(evcount * sizeof(xEvent));
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d33 2
d40 3
d610 237
d1252 2
a1253 1
CoreFocusPointerRootNoneSwitch(DeviceIntPtr dev, WindowPtr A,   /* PointerRootWin or NoneWin */
d1297 2
a1298 1
CoreFocusToPointerRootOrNone(DeviceIntPtr dev, WindowPtr A, WindowPtr B,        /* PointerRootWin or NoneWin */
d1344 2
a1345 1
CoreFocusFromPointerRootOrNone(DeviceIntPtr dev, WindowPtr A,   /* PointerRootWin or NoneWin */
@


1.4
log
@Update to xserver 1.11.2
@
text
@d109 1
d137 2
a138 2
    for (i = 0; i < MAXDEVICES; i++)
    {
d157 2
a158 2
    for (i = 0; i < MAXDEVICES; i++)
    {
a202 3



d211 1
a211 3
CommonAncestor(
    WindowPtr a,
    WindowPtr b)
d214 2
a215 1
	if (IsParent(b, a)) return b;
a218 1

d226 2
a227 5
              int sourceid,
              WindowPtr ancestor,
              WindowPtr child,
              int mode,
              int detail)
d229 1
a229 1
    WindowPtr	parent = child->parent;
d232 1
a232 1
	return;
d245 1
a245 4
                  WindowPtr ancestor,
                  WindowPtr child,
                  int mode,
                  int detail)
d247 2
a248 1
    WindowPtr	parent = child->parent;
d250 1
a250 1
	return;
a252 1

d254 1
a254 1
     A is above W, B is a descendant
d256 2
a257 2
      Classically: The move generates an EnterNotify on W with a detail of
        Virtual or NonlinearVirtual
d259 12
a270 12
     MPX:
        Case 3A: There is at least one other pointer on W itself
          P(W) doesn't change, so the event should be suppressed
        Case 3B: Otherwise, if there is at least one other pointer in a
          descendant
          P(W) stays on the same descendant, or changes to a different
          descendant. The event should be suppressed.
        Case 3C: Otherwise:
          P(W) moves from a window above W to a descendant. The subwindow
          field is set to the child containing the descendant. The detail
          may need to be changed from Virtual to NonlinearVirtual depending
          on the previous P(W). */
d273 2
a274 2
            CoreEnterLeaveEvent(dev, EnterNotify, mode, detail, parent,
                                child->drawable.id);
d279 1
a279 4
                  WindowPtr child,
                  WindowPtr ancestor,
                  int mode,
                  int detail)
d281 1
a281 1
    WindowPtr  win;
d286 1
a286 2
    for (win = child->parent; win != ancestor; win = win->parent)
    {
d288 1
a288 1
        A is a descendant of W, B is above W
d290 2
a291 2
        Classically: A LeaveNotify is generated on W with a detail of Virtual
          or NonlinearVirtual.
d293 11
a303 11
        MPX:
            Case 3A: There is at least one other pointer on W itself
              P(W) doesn't change, the event should be suppressed.
            Case 3B: Otherwise, if there is at least one other pointer in a
            descendant
             P(W) stays on the same descendant, or changes to a different
              descendant. The event should be suppressed.
            Case 3C: Otherwise:
              P(W) changes from the descendant of W to a window above W.
              The detail may need to be changed from Virtual to NonlinearVirtual
              or vice-versa depending on the new P(W).*/
d310 2
a311 1
        CoreEnterLeaveEvent(dev, LeaveNotify, mode, detail, win, child->drawable.id);
d323 2
a324 5
              int sourceid,
              WindowPtr child,
              WindowPtr ancestor,
              int mode,
              int detail)
d326 1
a326 1
    WindowPtr  win;
d329 2
a330 3
	return;
    for (win = child->parent; win != ancestor; win = win->parent)
    {
d332 1
a332 1
                                  child->drawable.id);
d342 1
a342 4
CoreEnterLeaveNonLinear(DeviceIntPtr dev,
                        WindowPtr A,
                        WindowPtr B,
                        int mode)
d345 1
d347 1
a347 1
     A is W, B is above W
d349 1
a349 1
    Classically: The move generates a LeaveNotify on W with a detail of
d352 12
a363 12
     MPX:
        Case 3A: There is at least one other pointer on W itself
          P(W) doesn't change, the event should be suppressed
        Case 3B: Otherwise, if there is at least one other pointer in a
        descendant of W
          P(W) changes from W to a descendant of W. The subwindow field
          is set to the child containing the new P(W), the detail field
          is set to Inferior
        Case 3C: Otherwise:
          The pointer window moves from W to a window above W.
          The detail may need to be changed from Ancestor to Nonlinear or
          vice versa depending on the the new P(W)
d366 1
a366 2
    if (!HasPointer(dev, A))
    {
d368 1
d370 2
a371 1
            CoreEnterLeaveEvent(dev, LeaveNotify, mode, NotifyInferior, A, None);
d373 2
a374 1
            CoreEnterLeaveEvent(dev, LeaveNotify, mode, NotifyNonlinear, A, None);
a376 1

d380 2
a381 6
      Case 9:
        A is a descendant of W, B is a descendant of W

        Classically: No events are generated on W
        MPX: The pointer window stays the same or moves to a different
          descendant of W. No events should be generated on W.
d383 3
d388 1
a388 1
    */
d393 16
a408 1
      A is above W, B=W
d410 2
a411 2
      Classically: The move generates an EnterNotify on W with a detail of
        Ancestor or Nonlinear
d413 7
a419 20
      MPX:
        Case 2A: There is at least one other pointer on W itself
          P(W) doesn't change, so the event should be suppressed
        Case 2B: Otherwise, if there is at least one other pointer in a
          descendant
          P(W) moves from a descendant to W. detail is changed to Inferior,
          subwindow is set to the child containing the previous P(W)
        Case 2C: Otherwise:
          P(W) changes from a window above W to W itself.
          The detail may need to be changed from Ancestor to Nonlinear
          or vice-versa depending on the previous P(W). */

     if (!HasPointer(dev, B))
     {
         WindowPtr child = FirstPointerChild(B);
         if (child)
             CoreEnterLeaveEvent(dev, EnterNotify, mode, NotifyInferior, B, None);
         else
             CoreEnterLeaveEvent(dev, EnterNotify, mode, NotifyNonlinear, B, None);
     }
d426 1
a426 4
CoreEnterLeaveToAncestor(DeviceIntPtr dev,
                         WindowPtr A,
                         WindowPtr B,
                         int mode)
d429 1
a429 1
     A is W, B is above W
d431 1
a431 1
    Classically: The move generates a LeaveNotify on W with a detail of
d434 12
a445 12
     MPX:
        Case 3A: There is at least one other pointer on W itself
          P(W) doesn't change, the event should be suppressed
        Case 3B: Otherwise, if there is at least one other pointer in a
        descendant of W
          P(W) changes from W to a descendant of W. The subwindow field
          is set to the child containing the new P(W), the detail field
          is set to Inferior
        Case 3C: Otherwise:
          The pointer window moves from W to a window above W.
          The detail may need to be changed from Ancestor to Nonlinear or
          vice versa depending on the the new P(W)
d447 1
a447 2
    if (!HasPointer(dev, A))
    {
d449 1
d451 2
a452 1
            CoreEnterLeaveEvent(dev, LeaveNotify, mode, NotifyInferior, A, None);
d454 2
a455 1
            CoreEnterLeaveEvent(dev, LeaveNotify, mode, NotifyAncestor, A, None);
d461 1
a461 1
    A is a descendant of W, B is W
d463 2
a464 2
    Classically: A EnterNotify is generated on W with a detail of
        NotifyInferior
d466 6
a471 6
    MPX:
        Case 3A: There is at least one other pointer on W itself
          P(W) doesn't change, the event should be suppressed
        Case 3B: Otherwise:
          P(W) changes from a descendant to W itself. The subwindow
          field should be set to the child containing the old P(W) <<< WRONG */
a477 1

d482 1
a482 4
CoreEnterLeaveToDescendant(DeviceIntPtr dev,
                           WindowPtr A,
                           WindowPtr B,
                           int mode)
d485 1
a485 1
    A is W, B is a descendant of W
d487 1
a487 1
    Classically: A LeaveNotify is generated on W with a detail of
d490 6
a495 6
    MPX:
        Case 3A: There is at least one other pointer on W itself
          P(W) doesn't change, the event should be suppressed
        Case 3B: Otherwise:
          P(W) changes from W to a descendant of W. The subwindow field
          is set to the child containing the new P(W) <<< THIS IS WRONG */
a499 1

d503 1
a503 1
      A is above W, B=W
d505 17
a521 2
      Classically: The move generates an EnterNotify on W with a detail of
        Ancestor or Nonlinear
d523 7
a529 20
      MPX:
        Case 2A: There is at least one other pointer on W itself
          P(W) doesn't change, so the event should be suppressed
        Case 2B: Otherwise, if there is at least one other pointer in a
          descendant
          P(W) moves from a descendant to W. detail is changed to Inferior,
          subwindow is set to the child containing the previous P(W)
        Case 2C: Otherwise:
          P(W) changes from a window above W to W itself.
          The detail may need to be changed from Ancestor to Nonlinear
          or vice-versa depending on the previous P(W). */

     if (!HasPointer(dev, B))
     {
         WindowPtr child = FirstPointerChild(B);
         if (child)
             CoreEnterLeaveEvent(dev, EnterNotify, mode, NotifyInferior, B, None);
         else
             CoreEnterLeaveEvent(dev, EnterNotify, mode, NotifyAncestor, B, None);
     }
d533 1
a533 4
CoreEnterLeaveEvents(DeviceIntPtr dev,
                     WindowPtr from,
                     WindowPtr to,
                     int mode)
d552 1
a552 4
                       int          sourceid,
                       WindowPtr    from,
                       WindowPtr    to,
                       int          mode)
d554 3
a556 3
    if (IsParent(from, to))
    {
        DeviceEnterLeaveEvent(dev, sourceid, XI_Leave, mode, NotifyInferior, from, None);
d558 2
a559 7
        DeviceEnterLeaveEvent(dev, sourceid, XI_Enter, mode, NotifyAncestor, to, None);
    }
    else if (IsParent(to, from))
    {
	DeviceEnterLeaveEvent(dev, sourceid, XI_Leave, mode, NotifyAncestor, from, None);
	DeviceLeaveNotifies(dev, sourceid, from, to, mode, NotifyVirtual);
	DeviceEnterLeaveEvent(dev, sourceid, XI_Enter, mode, NotifyInferior, to, None);
d561 19
a579 8
    else
    { /* neither from nor to is descendent of the other */
	WindowPtr common = CommonAncestor(to, from);
	/* common == NullWindow ==> different screens */
        DeviceEnterLeaveEvent(dev, sourceid, XI_Leave, mode, NotifyNonlinear, from, None);
        DeviceLeaveNotifies(dev, sourceid, from, common, mode, NotifyNonlinearVirtual);
        DeviceEnterNotifies(dev, sourceid, common, to, mode, NotifyNonlinearVirtual);
        DeviceEnterLeaveEvent(dev, sourceid, XI_Enter, mode, NotifyNonlinear, to, None);
d592 1
a592 4
        int sourceid,
        WindowPtr fromWin,
        WindowPtr toWin,
        int mode)
d598 1
a598 1
	return;
d611 1
a611 4
                     WindowPtr child,
                     WindowPtr ancestor,
                     int mode,
                     int detail)
d613 1
a613 1
    WindowPtr  win;
d616 1
a616 1
	return;
a620 1

d628 1
a628 4
                    WindowPtr ancestor,
                    WindowPtr child,
                    int mode,
                    int detail)
d630 1
a630 1
    WindowPtr	parent = child->parent;
d633 1
a633 1
	return;
d645 1
a645 4
                  WindowPtr ancestor,
                  WindowPtr child,
                  int mode,
                  int detail)
d647 2
a648 1
    WindowPtr	parent = child->parent;
d650 1
a650 1
	return;
a652 1

d654 1
a654 1
     A is above W, B is a descendant
d656 2
a657 2
      Classically: The move generates an FocusIn on W with a detail of
        Virtual or NonlinearVirtual
d659 11
a669 11
     MPX:
        Case 3A: There is at least one other focus on W itself
          F(W) doesn't change, so the event should be suppressed
        Case 3B: Otherwise, if there is at least one other focus in a
          descendant
          F(W) stays on the same descendant, or changes to a different
          descendant. The event should be suppressed.
        Case 3C: Otherwise:
          F(W) moves from a window above W to a descendant. The detail may
          need to be changed from Virtual to NonlinearVirtual depending
          on the previous F(W). */
d672 1
a672 1
            CoreFocusEvent(dev, FocusIn, mode, detail, parent);
d677 1
a677 4
                   WindowPtr child,
                   WindowPtr ancestor,
                   int mode,
                   int detail)
d679 1
a679 1
    WindowPtr  win;
d684 1
a684 2
    for (win = child->parent; win != ancestor; win = win->parent)
    {
d686 1
a686 1
        A is a descendant of W, B is above W
d688 2
a689 2
        Classically: A FocusOut is generated on W with a detail of Virtual
          or NonlinearVirtual.
d691 11
a701 11
        MPX:
            Case 3A: There is at least one other focus on W itself
              F(W) doesn't change, the event should be suppressed.
            Case 3B: Otherwise, if there is at least one other focus in a
            descendant
             F(W) stays on the same descendant, or changes to a different
              descendant. The event should be suppressed.
            Case 3C: Otherwise:
              F(W) changes from the descendant of W to a window above W.
              The detail may need to be changed from Virtual to NonlinearVirtual
              or vice-versa depending on the new P(W).*/
d725 1
a725 3
                                WindowPtr exclude,
                                int mode,
                                int inclusive)
d729 1
a729 1
    P = PointerWin(GetPairedDevice(dev));
d753 1
a753 4
                   WindowPtr win,
                   WindowPtr stopAt,
                   int mode,
                   int inclusive)
a761 1

d774 1
a774 3
                               WindowPtr exclude,
                               int mode,
                               int inclusive)
d778 1
a778 1
    P = PointerWin(GetPairedDevice(dev));
a788 1

d794 1
a794 4
CoreFocusNonLinear(DeviceIntPtr dev,
                   WindowPtr A,
                   WindowPtr B,
                   int mode)
d799 1
a799 1
     A is W, B is above W
d801 1
a801 1
    Classically: The change generates a FocusOut on W with a detail of
d804 11
a814 11
     MPX:
        Case 3A: There is at least one other focus on W itself
          F(W) doesn't change, the event should be suppressed
        Case 3B: Otherwise, if there is at least one other focus in a
        descendant of W
          F(W) changes from W to a descendant of W. The detail field
          is set to Inferior
        Case 3C: Otherwise:
          The focus window moves from W to a window above W.
          The detail may need to be changed from Ancestor to Nonlinear or
          vice versa depending on the the new F(W)
d817 1
a817 2
    if (!HasFocus(A))
    {
d819 3
a821 3
        if (child)
        {
            /* NotifyPointer P-A unless P is child or below*/
d824 2
a825 2
        } else
        {
a831 1

d835 2
a836 6
      Case 9:
        A is a descendant of W, B is a descendant of W

        Classically: No events are generated on W
        MPX: The focus window stays the same or moves to a different
          descendant of W. No events should be generated on W.
d838 3
d843 1
a843 1
    */
d848 1
a848 1
      A is above W, B=W
d850 16
a865 2
      Classically: The move generates an EnterNotify on W with a detail of
        Ancestor or Nonlinear
d867 11
a877 25
      MPX:
        Case 2A: There is at least one other focus on W itself
          F(W) doesn't change, so the event should be suppressed
        Case 2B: Otherwise, if there is at least one other focus in a
          descendant
          F(W) moves from a descendant to W. detail is changed to Inferior.
        Case 2C: Otherwise:
          F(W) changes from a window above W to W itself.
          The detail may need to be changed from Ancestor to Nonlinear
          or vice-versa depending on the previous F(W). */

     if (!HasFocus(B))
     {
         WindowPtr child = FirstFocusChild(B);
         if (child)
         {
             CoreFocusEvent(dev, FocusIn, mode, NotifyInferior, B);
             /* NotifyPointer B-P unless P is child or below. */
             CoreFocusInNotifyPointerEvents(dev, B, child, mode, FALSE);
         } else {
             CoreFocusEvent(dev, FocusIn, mode, NotifyNonlinear, B);
             /* NotifyPointer B-P unless P is child or below. */
             CoreFocusInNotifyPointerEvents(dev, B, None, mode, FALSE);
         }
     }
a879 1

d884 1
a884 4
CoreFocusToAncestor(DeviceIntPtr dev,
                    WindowPtr A,
                    WindowPtr B,
                    int mode)
d887 1
a887 1
     A is W, B is above W
d889 1
a889 1
    Classically: The change generates a FocusOut on W with a detail of
d892 11
a902 11
     MPX:
        Case 3A: There is at least one other focus on W itself
          F(W) doesn't change, the event should be suppressed
        Case 3B: Otherwise, if there is at least one other focus in a
        descendant of W
          F(W) changes from W to a descendant of W. The detail field
          is set to Inferior
        Case 3C: Otherwise:
          The focus window moves from W to a window above W.
          The detail may need to be changed from Ancestor to Nonlinear or
          vice versa depending on the the new F(W)
d904 1
a904 2
    if (!HasFocus(A))
    {
d906 3
a908 3
        if (child)
        {
            /* NotifyPointer P-A unless P is child or below*/
d911 2
a912 1
        } else
d919 1
a919 1
    A is a descendant of W, B is W
d921 2
a922 2
    Classically: A FocusOut is generated on W with a detail of
        NotifyInferior
d924 5
a928 5
    MPX:
        Case 3A: There is at least one other focus on W itself
          F(W) doesn't change, the event should be suppressed
        Case 3B: Otherwise:
          F(W) changes from a descendant to W itself. */
d930 1
a930 2
    if (!HasFocus(B))
    {
d941 1
a941 4
CoreFocusToDescendant(DeviceIntPtr dev,
                      WindowPtr A,
                      WindowPtr B,
                      int mode)
d944 1
a944 1
    A is W, B is a descendant of W
d946 1
a946 1
    Classically: A FocusOut is generated on W with a detail of
d949 8
a956 9
    MPX:
        Case 3A: There is at least one other focus on W itself
          F(W) doesn't change, the event should be suppressed
        Case 3B: Otherwise:
          F(W) changes from W to a descendant of W. */

    if (!HasFocus(A))
    {
        /* NotifyPointer P-A unless P is B or below*/
a960 1

d964 1
a964 1
      A is above W, B=W
d966 16
a981 2
      Classically: The move generates an FocusIn on W with a detail of
        Ancestor or Nonlinear
d983 8
a990 22
      MPX:
        Case 2A: There is at least one other focus on W itself
          F(W) doesn't change, so the event should be suppressed
        Case 2B: Otherwise, if there is at least one other focus in a
          descendant
          F(W) moves from a descendant to W. detail is changed to Inferior.
        Case 2C: Otherwise:
          F(W) changes from a window above W to W itself.
          The detail may need to be changed from Ancestor to Nonlinear
          or vice-versa depending on the previous F(W). */

     if (!HasFocus(B))
     {
         WindowPtr child = FirstFocusChild(B);
         if (child)
         {
             CoreFocusEvent(dev, FocusIn, mode, NotifyInferior, B);
             /* NotifyPointer B-P unless P is child or below. */
             CoreFocusInNotifyPointerEvents(dev, B, child, mode, FALSE);
         } else
             CoreFocusEvent(dev, FocusIn, mode, NotifyAncestor, B);
     }
d1010 2
a1011 3
CoreFocusPointerRootNoneSwitch(DeviceIntPtr dev,
                               WindowPtr A, /* PointerRootWin or NoneWin */
                               WindowPtr B, /* NoneWin or PointerRootWin */
d1023 1
a1023 2
    for (i = 0; i < nscreens; i++)
    {
d1025 2
a1026 2
        if (!HasOtherPointer(root, GetPairedDevice(dev)) && !FirstFocusChild(root))
        {
d1031 3
a1033 3
                B != PointerRootWin)
            {
                WindowPtr ptrwin = PointerWin(GetPairedDevice(dev));
d1035 2
a1036 1
                    CoreFocusOutNotifyPointerEvents(dev, root, None, mode, TRUE);
d1038 4
a1041 2
            CoreFocusEvent(dev, FocusOut, mode, A ? NotifyPointerRoot : NotifyDetailNone, root);
            CoreFocusEvent(dev, FocusIn, mode, B ? NotifyPointerRoot : NotifyDetailNone, root);
d1054 2
a1055 4
CoreFocusToPointerRootOrNone(DeviceIntPtr dev,
                       WindowPtr A,
                       WindowPtr B, /* PointerRootWin or NoneWin */
                       int mode)
d1066 1
a1066 2
    if (!HasFocus(A))
    {
d1068 3
a1070 3
        if (child)
        {
            /* NotifyPointer P-A unless P is B or below*/
d1073 2
a1074 1
        } else {
d1084 1
a1084 2
    for (i = 0; i < nscreens; i++)
    {
d1086 3
a1088 3
        if (!HasFocus(root) && !FirstFocusChild(root))
        {
            CoreFocusEvent(dev, FocusIn, mode, B ? NotifyPointerRoot : NotifyDetailNone, root);
d1100 2
a1101 4
CoreFocusFromPointerRootOrNone(DeviceIntPtr dev,
                               WindowPtr A, /* PointerRootWin or NoneWin */
                               WindowPtr B,
                               int mode)
d1112 1
a1112 2
    for (i = 0; i < nscreens; i++)
    {
d1114 1
a1114 2
        if (!HasFocus(root) && !FirstFocusChild(root))
        {
d1119 3
a1121 3
                B != PointerRootWin)
            {
                WindowPtr ptrwin = PointerWin(GetPairedDevice(dev));
d1123 2
a1124 1
                    CoreFocusOutNotifyPointerEvents(dev, root, None, mode, TRUE);
d1126 2
a1127 1
            CoreFocusEvent(dev, FocusOut, mode, A ? NotifyPointerRoot : NotifyDetailNone, root);
d1131 2
a1132 2
    root = B; /* get B's root window */
    while(root->parent)
d1135 1
a1135 2
    if (B != root)
    {
d1140 2
d1143 6
a1148 9
    if (!HasFocus(B))
    {
        WindowPtr child = FirstFocusChild(B);
        if (child)
        {
             CoreFocusEvent(dev, FocusIn, mode, NotifyInferior, B);
             /* NotifyPointer B-P unless P is child or below. */
             CoreFocusInNotifyPointerEvents(dev, B, child, mode, FALSE);
        } else {
d1158 1
a1158 4
CoreFocusEvents(DeviceIntPtr dev,
                WindowPtr from,
                WindowPtr to,
                int mode)
d1183 1
a1183 4
DeviceFocusEvents(DeviceIntPtr dev,
                  WindowPtr from,
                  WindowPtr to,
                  int mode)
d1185 2
a1186 2
    int out, in;		       /* for holding details for to/from
                                          PointerRoot/None */
d1189 1
a1189 1
    SpritePtr sprite  = dev->spriteInfo->sprite;
d1202 2
a1203 4
    if ((to == NullWindow) || (to == PointerRootWin))
    {
        if ((from == NullWindow) || (from == PointerRootWin))
        {
d1205 3
a1207 2
                DeviceFocusOutEvents(dev, sprite->win, GetCurrentRootWindow(dev), mode,
                        NotifyPointer);
d1210 2
a1211 1
                DeviceFocusEvent(dev, XI_FocusOut, mode, out, screenInfo.screens[i]->root);
d1213 1
a1213 2
        else
        {
d1216 1
a1216 1
                        NotifyPointer);
d1219 2
a1220 2
            DeviceFocusOutEvents(dev, from->parent, NullWindow, mode,
                    NotifyNonlinearVirtual);
d1224 7
a1230 3
            DeviceFocusEvent(dev, XI_FocusIn, mode, in, screenInfo.screens[i]->root);
        if (to == PointerRootWin)
            DeviceFocusInEvents(dev, GetCurrentRootWindow(dev), sprite->win, mode, NotifyPointer);
d1232 2
a1233 4
    else
    {
        if ((from == NullWindow) || (from == PointerRootWin))
        {
d1235 3
a1237 2
                DeviceFocusOutEvents(dev, sprite->win, GetCurrentRootWindow(dev), mode,
                        NotifyPointer);
d1239 2
a1240 1
                DeviceFocusEvent(dev, XI_FocusOut, mode, out, screenInfo.screens[i]->root);
d1242 2
a1243 1
                DeviceFocusInEvents(dev, GetCurrentRootWindow(dev), to, mode, NotifyNonlinearVirtual);
d1248 2
a1249 4
        else
        {
            if (IsParent(to, from))
            {
d1251 1
a1251 2
                DeviceFocusOutEvents(dev, from->parent, to, mode,
                        NotifyVirtual);
d1254 36
a1289 4
                        (sprite->win != from) &&
                        (!IsParent(from, sprite->win)) &&
                        (!IsParent(sprite->win, from)))
                    DeviceFocusInEvents(dev, to, sprite->win, mode, NotifyPointer);
a1290 31
            else
                if (IsParent(from, to))
                {
                    if ((IsParent(from, sprite->win)) &&
                            (sprite->win != from) &&
                            (!IsParent(to, sprite->win)) &&
                            (!IsParent(sprite->win, to)))
                        DeviceFocusOutEvents(dev, sprite->win, from, mode,
                                NotifyPointer);
                    DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyInferior, from);
                    DeviceFocusInEvents(dev, from, to, mode, NotifyVirtual);
                    DeviceFocusEvent(dev, XI_FocusIn, mode, NotifyAncestor, to);
                }
                else
                {
                    /* neither from or to is child of other */
                    WindowPtr common = CommonAncestor(to, from);
                    /* common == NullWindow ==> different screens */
                    if (IsParent(from, sprite->win))
                        DeviceFocusOutEvents(dev, sprite->win, from, mode,
                                NotifyPointer);
                    DeviceFocusEvent(dev, XI_FocusOut, mode, NotifyNonlinear, from);
                    if (from->parent != NullWindow)
                        DeviceFocusOutEvents(dev, from->parent, common, mode,
                                NotifyNonlinearVirtual);
                    if (to->parent != NullWindow)
                        DeviceFocusInEvents(dev, common, to, mode, NotifyNonlinearVirtual);
                    DeviceFocusEvent(dev, XI_FocusIn, mode, NotifyNonlinear, to);
                    if (IsParent(to, sprite->win))
                        DeviceFocusInEvents(dev, to, sprite->win, mode, NotifyPointer);
                }
d1303 1
a1303 4
DoFocusEvents(DeviceIntPtr pDev,
              WindowPtr from,
              WindowPtr to,
              int mode)
d1309 1
a1309 1
	return;
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a1253 5
/**
 * The root window the given device is currently on.
 */
#define RootWindow(dev) dev->spriteInfo->sprite->spriteTrace[0]

d1282 1
a1282 1
                DeviceFocusOutEvents(dev, sprite->win, RootWindow(dev), mode,
d1302 1
a1302 1
            DeviceFocusInEvents(dev, RootWindow(dev), sprite->win, mode, NotifyPointer);
d1309 1
a1309 1
                DeviceFocusOutEvents(dev, sprite->win, RootWindow(dev), mode,
d1314 1
a1314 1
                DeviceFocusInEvents(dev, RootWindow(dev), to, mode, NotifyNonlinearVirtual);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d81 1
a81 1
HasPointer(WindowPtr win)
d85 9
d282 1
a282 1
    if (!HasPointer(parent) && !FirstPointerChild(parent))
d321 1
a321 1
        if (HasPointer(win) || FirstPointerChild(win))
d385 1
a385 1
    if (!HasPointer(A))
d429 1
a429 1
     if (!HasPointer(B))
d467 1
a467 1
    if (!HasPointer(A))
d491 1
a491 1
    if (!HasPointer(B))
d519 1
a519 1
    if (!HasPointer(A))
d543 1
a543 1
     if (!HasPointer(B))
d1089 1
a1089 1
        root = WindowTable[i];
d1150 1
a1150 1
        root = WindowTable[i];
d1181 1
a1181 1
        root = WindowTable[i];
d1291 1
a1291 1
                DeviceFocusEvent(dev, XI_FocusOut, mode, out, WindowTable[i]);
d1305 1
a1305 1
            DeviceFocusEvent(dev, XI_FocusIn, mode, in, WindowTable[i]);
d1317 1
a1317 1
                DeviceFocusEvent(dev, XI_FocusOut, mode, out, WindowTable[i]);
@


1.1
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d32 2
d39 5
a43 2
/* @@file This file describes the model for sending core enter/leave events and
 * focus in/out in the case of multiple pointers/keyboard foci
d57 1
a57 1
 * -) The core protocol spec says that "In a LeaveNotify event, if a child of the
d66 1
a66 1
 * -) NotifyPointer events may be sent if the focus changes from window A to
d77 1
a77 1
 * Return TRUE if @@win has a pointer within its boundaries, excluding child
d93 1
a93 1
 * Return TRUE if at least one keyboard focus is set to @@win (excluding
d108 1
a108 1
 * Return the window the device @@dev is currently on.
d117 1
a117 1
 * Search for the first window below @@win that has a pointer directly within
d137 1
a137 1
 * Search for the first window below @@win that has a focus directly within
d158 1
a158 1
 * Set the presence flag for @@dev to mark that it is now in @@win.
d167 1
a167 1
 * Unset the presence flag for @@dev to mark that it is not in @@win anymore.
d169 2
a170 2
static void
LeaveWindow(DeviceIntPtr dev, WindowPtr win, int mode)
d176 1
a176 1
 * Set the presence flag for @@dev to mark that it is now in @@win.
d185 1
a185 1
 * Unset the presence flag for @@dev to mark that it is not in @@win anymore.
d188 1
a188 1
SetFocusOut(DeviceIntPtr dev, WindowPtr win)
d197 5
a201 1
 * @@return The window that is the first ancestor of both a and b.
a213 1
#if 0
d215 1
a215 1
 * Send enter notifies to all windows between @@ancestor and @@child (excluding
a217 1
 * If @@core is TRUE, core events are sent, otherwise XI events will be sent.
d221 1
d231 2
a232 2
    DeviceEnterNotifies(dev, ancestor, parent, mode, detail);
    DeviceEnterLeaveEvent(dev, DeviceEnterNotify, mode, detail, parent,
a234 1
#endif
d237 1
a237 1
 * Send enter notifies to all windows between @@ancestor and @@child (excluding
a320 1
#if 0
d322 1
a322 1
 * Send leave notifies to all windows between @@child and @@ancestor.
d327 1
d339 1
a339 1
        DeviceEnterLeaveEvent(dev, DeviceLeaveNotify, mode, detail, win,
a343 1
#endif
d346 2
a347 2
 * Pointer @@dev moves from @@A to @@B and @@A neither a descendant of @@B nor is
 * @@B a descendant of @@A.
d431 1
a431 1
 * Pointer @@dev moves from @@A to @@B and @@A is a descendant of @@B.
d489 1
a489 1
 * Pointer @@dev moves from @@A to @@B and @@B is a descendant of @@A.
d550 1
a550 1
    if (!dev->isMaster)
d553 1
a553 1
    LeaveWindow(dev, from, mode);
a564 1
#if 0
d567 1
d574 3
a576 3
        DeviceEnterLeaveEvent(dev, DeviceLeaveNotify, mode, NotifyInferior, from, None);
        DeviceEnterNotifies(dev, from, to, mode, NotifyVirtual);
        DeviceEnterLeaveEvent(dev, DeviceEnterNotify, mode, NotifyAncestor, to, None);
d580 3
a582 3
	DeviceEnterLeaveEvent(dev, DeviceLeaveNotify, mode, NotifyAncestor, from, None);
	DeviceLeaveNotifies(dev, from, to, mode, NotifyVirtual);
	DeviceEnterLeaveEvent(dev, DeviceEnterNotify, mode, NotifyInferior, to, None);
d588 4
a591 4
        DeviceEnterLeaveEvent(dev, DeviceLeaveNotify, mode, NotifyNonlinear, from, None);
        DeviceLeaveNotifies(dev, from, common, mode, NotifyNonlinearVirtual);
        DeviceEnterNotifies(dev, common, to, mode, NotifyNonlinearVirtual);
        DeviceEnterLeaveEvent(dev, DeviceEnterNotify, mode, NotifyNonlinear, to, None);
a593 1
#endif
d604 1
d615 3
a617 4
    CoreEnterLeaveEvents(pDev, fromWin, toWin, mode);
#if 0
    DeviceEnterLeaveEvents(pDev, fromWin, toWin, mode);
#endif
d621 1
a621 1
 * Send focus out events to all windows between @@child and @@ancestor.
d636 1
a636 1
        DeviceFocusEvent(dev, DeviceFocusOut, mode, detail, win);
d641 1
a641 1
 * Send enter notifies to all windows between @@ancestor and @@child (excluding
d657 1
a657 1
    DeviceFocusEvent(dev, DeviceFocusIn, mode, detail, parent);
d661 1
a661 1
 * Send FocusIn events to all windows between @@ancestor and @@child (excluding
d743 1
a743 1
 * is a descendant of @@pwin_parent) up to (excluding) @@pwin_parent.
d745 1
a745 1
 * NotifyPointer events are only sent for the device paired with @@dev.
d747 3
a749 3
 * If the current pointer window is a descendat of @@exclude or an ancestor of
 * @@exclude, no events are sent. Note: If the current pointer IS @@exclude,
 * events are sent!
d798 2
a799 5
 * Send FocusIn(NotifyPointer) events from @@pwin_parent down to
 * including the current pointer window (which is a descendant of @@pwin_parent).
 * If @@inclusive is TRUE, @@pwin_parent will receive the event too.
 *
 * @@pwin is the pointer window.
d801 4
a804 1
 * If the current pointer window is a child of @@exclude, no events are sent.
d828 2
a829 2
 * Focus of @@dev moves from @@A to @@B and @@A neither a descendant of @@B nor is
 * @@B a descendant of @@A.
d926 1
a926 1
 * Focus of @@dev moves from @@A to @@B and @@A is a descendant of @@B.
d987 1
a987 1
 * Focus of @@dev moves from @@A to @@B and @@B is a descendant of @@A.
d1084 1
a1084 1
             * the pointer paired with @@dev is below the current root window,
d1093 2
a1094 2
            CoreFocusEvent(dev, FocusOut, mode, ((int)A) ? NotifyPointerRoot : NotifyDetailNone, root);
            CoreFocusEvent(dev, FocusIn, mode, ((int)B) ? NotifyPointerRoot : NotifyDetailNone, root);
d1103 2
a1104 2
 * Focus moves from window @@A to PointerRoot or to None.
 * Assumption: @@A is a valid window and not PointerRoot or None.
d1144 1
a1144 1
            CoreFocusEvent(dev, FocusIn, mode, ((int)B) ? NotifyPointerRoot : NotifyDetailNone, root);
d1152 2
a1153 2
 * Focus moves from PointerRoot or None to a window @@to.
 * Assumption: @@to is a valid window and not PointerRoot or None.
d1176 1
a1176 1
             * the pointer paired with @@dev is below the current root window,
d1185 1
a1185 1
            CoreFocusEvent(dev, FocusOut, mode, ((int)A) ? NotifyPointerRoot : NotifyDetailNone, root);
d1223 1
a1223 1
    if (!dev->isMaster)
d1226 1
a1226 1
    SetFocusOut(dev, from);
d1245 3
d1282 1
a1282 1
                DeviceFocusEvent(dev, FocusOut, mode, out, WindowTable[i]);
d1289 1
a1289 1
            DeviceFocusEvent(dev, FocusOut, mode, NotifyNonlinear, from);
d1296 1
a1296 1
            DeviceFocusEvent(dev, FocusIn, mode, in, WindowTable[i]);
d1308 1
a1308 1
                DeviceFocusEvent(dev, FocusOut, mode, out, WindowTable[i]);
d1311 1
a1311 1
            DeviceFocusEvent(dev, FocusIn, mode, NotifyNonlinear, to);
d1319 1
a1319 1
                DeviceFocusEvent(dev, FocusOut, mode, NotifyAncestor, from);
d1322 1
a1322 1
                DeviceFocusEvent(dev, FocusIn, mode, NotifyInferior, to);
d1338 1
a1338 1
                    DeviceFocusEvent(dev, FocusOut, mode, NotifyInferior, from);
d1340 1
a1340 1
                    DeviceFocusEvent(dev, FocusIn, mode, NotifyAncestor, to);
d1350 1
a1350 1
                    DeviceFocusEvent(dev, FocusOut, mode, NotifyNonlinear, from);
d1356 1
a1356 1
                    DeviceFocusEvent(dev, FocusIn, mode, NotifyNonlinear, to);
@

