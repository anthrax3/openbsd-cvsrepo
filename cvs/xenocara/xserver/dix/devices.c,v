head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.4
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.2
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.2
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.2
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.4
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.4
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.08.09.18.59.51;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	6HLO5qdN5N4nPDjW;

1.21
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	s0SI41sEunLdyFfd;

1.20
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.19;
commitid	Te1daavkBLskZ8gc;

1.19
date	2014.11.22.08.33.46;	author matthieu;	state Exp;
branches;
next	1.18;
commitid	qWPhfcRCIbHxIFHp;

1.18
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.17;
commitid	cVXoV5PxI8YrEaVA;

1.17
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2013.09.28.15.36.33;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2013.08.24.19.44.30;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2011.12.18.16.08.59;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.13.21.47.50;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.25.15.32.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.11.24.19.04.01;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.20.29.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.16;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.16.56;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/************************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include "misc.h"
#include "resource.h"
#include <X11/Xproto.h>
#include <X11/Xatom.h>
#include "windowstr.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include "cursorstr.h"
#include "dixstruct.h"
#include "ptrveloc.h"
#include "site.h"
#include "xkbsrv.h"
#include "privates.h"
#include "xace.h"
#include "mi.h"

#include "dispatch.h"
#include "swaprep.h"
#include "dixevents.h"
#include "mipointer.h"
#include "eventstr.h"
#include "dixgrabs.h"

#include <X11/extensions/XI.h>
#include <X11/extensions/XI2.h>
#include <X11/extensions/XIproto.h>
#include <math.h>
#include <pixman.h>
#include "exglobals.h"
#include "exevents.h"
#include "xiquerydevice.h"      /* for SizeDeviceClasses */
#include "xiproperty.h"
#include "enterleave.h"         /* for EnterWindow() */
#include "xserver-properties.h"
#include "xichangehierarchy.h"  /* For XISendDeviceHierarchyEvent */
#include "syncsrv.h"

/** @@file
 * This file handles input device-related stuff.
 */

static void RecalculateMasterButtons(DeviceIntPtr slave);

static void
DeviceSetTransform(DeviceIntPtr dev, float *transform_data)
{
    struct pixman_f_transform scale;
    struct pixman_f_transform transform;
    double sx, sy;
    int x, y;

    /**
     * calculate combined transformation matrix:
     *
     * M = InvScale * Transform * Scale
     *
     * So we can later transform points using M * p
     *
     * Where:
     *  Scale scales coordinates into 0..1 range
     *  Transform is the user supplied (affine) transform
     *  InvScale scales coordinates back up into their native range
     */
    sx = dev->valuator->axes[0].max_value - dev->valuator->axes[0].min_value + 1;
    sy = dev->valuator->axes[1].max_value - dev->valuator->axes[1].min_value + 1;

    /* invscale */
    pixman_f_transform_init_scale(&scale, sx, sy);
    scale.m[0][2] = dev->valuator->axes[0].min_value;
    scale.m[1][2] = dev->valuator->axes[1].min_value;

    /* transform */
    for (y = 0; y < 3; y++)
        for (x = 0; x < 3; x++)
            transform.m[y][x] = *transform_data++;

    pixman_f_transform_multiply(&dev->scale_and_transform, &scale, &transform);

    /* scale */
    pixman_f_transform_init_scale(&scale, 1.0 / sx, 1.0 / sy);
    scale.m[0][2] = -dev->valuator->axes[0].min_value / sx;
    scale.m[1][2] = -dev->valuator->axes[1].min_value / sy;

    pixman_f_transform_multiply(&dev->scale_and_transform, &dev->scale_and_transform, &scale);

    /* remove translation component for relative movements */
    dev->relative_transform = transform;
    dev->relative_transform.m[0][2] = 0;
    dev->relative_transform.m[1][2] = 0;
}

/**
 * DIX property handler.
 */
static int
DeviceSetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
                  BOOL checkonly)
{
    if (property == XIGetKnownProperty(XI_PROP_ENABLED)) {
        if (prop->format != 8 || prop->type != XA_INTEGER || prop->size != 1)
            return BadValue;

        /* Don't allow disabling of VCP/VCK or XTest devices */
        if ((dev == inputInfo.pointer ||
             dev == inputInfo.keyboard ||
             IsXTestDevice(dev, NULL))
            &&!(*(CARD8 *) prop->data))
            return BadAccess;

        if (!checkonly) {
            if ((*((CARD8 *) prop->data)) && !dev->enabled)
                EnableDevice(dev, TRUE);
            else if (!(*((CARD8 *) prop->data)) && dev->enabled)
                DisableDevice(dev, TRUE);
        }
    }
    else if (property == XIGetKnownProperty(XI_PROP_TRANSFORM)) {
        float *f = (float *) prop->data;
        int i;

        if (prop->format != 32 || prop->size != 9 ||
            prop->type != XIGetKnownProperty(XATOM_FLOAT))
            return BadValue;

        for (i = 0; i < 9; i++)
            if (!isfinite(f[i]))
                return BadValue;

        if (!dev->valuator)
            return BadMatch;

        if (!checkonly)
            DeviceSetTransform(dev, f);
    }

    return Success;
}

/* Pair the keyboard to the pointer device. Keyboard events will follow the
 * pointer sprite. Only applicable for master devices.
 */
static int
PairDevices(DeviceIntPtr ptr, DeviceIntPtr kbd)
{
    if (!ptr)
        return BadDevice;

    /* Don't allow pairing for slave devices */
    if (!IsMaster(ptr) || !IsMaster(kbd))
        return BadDevice;

    if (ptr->spriteInfo->paired)
        return BadDevice;

    if (kbd->spriteInfo->spriteOwner) {
        free(kbd->spriteInfo->sprite);
        kbd->spriteInfo->sprite = NULL;
        kbd->spriteInfo->spriteOwner = FALSE;
    }

    kbd->spriteInfo->sprite = ptr->spriteInfo->sprite;
    kbd->spriteInfo->paired = ptr;
    ptr->spriteInfo->paired = kbd;
    return Success;
}

/**
 * Find and return the next unpaired MD pointer device.
 */
static DeviceIntPtr
NextFreePointerDevice(void)
{
    DeviceIntPtr dev;

    for (dev = inputInfo.devices; dev; dev = dev->next)
        if (IsMaster(dev) &&
            dev->spriteInfo->spriteOwner && !dev->spriteInfo->paired)
            return dev;
    return NULL;
}

/**
 * Create a new input device and init it to sane values. The device is added
 * to the server's off_devices list.
 *
 * @@param deviceProc Callback for device control function (switch dev on/off).
 * @@return The newly created device.
 */
DeviceIntPtr
AddInputDevice(ClientPtr client, DeviceProc deviceProc, Bool autoStart)
{
    DeviceIntPtr dev, *prev;    /* not a typo */
    DeviceIntPtr devtmp;
    int devid;
    char devind[MAXDEVICES];
    BOOL enabled;
    float transform[9];

    /* Find next available id, 0 and 1 are reserved */
    memset(devind, 0, sizeof(char) * MAXDEVICES);
    for (devtmp = inputInfo.devices; devtmp; devtmp = devtmp->next)
        devind[devtmp->id]++;
    for (devtmp = inputInfo.off_devices; devtmp; devtmp = devtmp->next)
        devind[devtmp->id]++;
    for (devid = 2; devid < MAXDEVICES && devind[devid]; devid++);

    if (devid >= MAXDEVICES)
        return (DeviceIntPtr) NULL;
    dev = calloc(1,
                 sizeof(DeviceIntRec) +
                 sizeof(SpriteInfoRec));
    if (!dev)
        return (DeviceIntPtr) NULL;

    if (!dixAllocatePrivates(&dev->devPrivates, PRIVATE_DEVICE)) {
        free(dev);
        return NULL;
    }

    if (!dev)
        return (DeviceIntPtr) NULL;

    dev->last.scroll = NULL;
    dev->last.touches = NULL;
    dev->id = devid;
    dev->public.processInputProc = ProcessOtherEvent;
    dev->public.realInputProc = ProcessOtherEvent;
    dev->public.enqueueInputProc = EnqueueEvent;
    dev->deviceProc = deviceProc;
    dev->startup = autoStart;

    /* device grab defaults */
    dev->deviceGrab.grabTime = currentTime;
    dev->deviceGrab.ActivateGrab = ActivateKeyboardGrab;
    dev->deviceGrab.DeactivateGrab = DeactivateKeyboardGrab;
    dev->deviceGrab.sync.event = calloc(1, sizeof(DeviceEvent));

    XkbSetExtension(dev, ProcessKeyboardEvent);

    dev->coreEvents = TRUE;

    /* sprite defaults */
    dev->spriteInfo = (SpriteInfoPtr) &dev[1];

    /*  security creation/labeling check
     */
    if (XaceHook(XACE_DEVICE_ACCESS, client, dev, DixCreateAccess)) {
        dixFreePrivates(dev->devPrivates, PRIVATE_DEVICE);
        free(dev);
        return NULL;
    }

    inputInfo.numDevices++;

    for (prev = &inputInfo.off_devices; *prev; prev = &(*prev)->next);
    *prev = dev;
    dev->next = NULL;

    enabled = FALSE;
    XIChangeDeviceProperty(dev, XIGetKnownProperty(XI_PROP_ENABLED),
                           XA_INTEGER, 8, PropModeReplace, 1, &enabled, FALSE);
    XISetDevicePropertyDeletable(dev, XIGetKnownProperty(XI_PROP_ENABLED),
                                 FALSE);

    /* unity matrix */
    memset(transform, 0, sizeof(transform));
    transform[0] = transform[4] = transform[8] = 1.0f;
    dev->relative_transform.m[0][0] = 1.0;
    dev->relative_transform.m[1][1] = 1.0;
    dev->relative_transform.m[2][2] = 1.0;
    dev->scale_and_transform = dev->relative_transform;

    XIChangeDeviceProperty(dev, XIGetKnownProperty(XI_PROP_TRANSFORM),
                           XIGetKnownProperty(XATOM_FLOAT), 32,
                           PropModeReplace, 9, transform, FALSE);
    XISetDevicePropertyDeletable(dev, XIGetKnownProperty(XI_PROP_TRANSFORM),
                                 FALSE);

    XIRegisterPropertyHandler(dev, DeviceSetProperty, NULL, NULL);

    return dev;
}

void
SendDevicePresenceEvent(int deviceid, int type)
{
    DeviceIntRec dummyDev = { .id =  XIAllDevices };
    devicePresenceNotify ev = {
        .type = DevicePresenceNotify,
        .time = currentTime.milliseconds,
        .devchange = type,
        .deviceid = deviceid
    };

    SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                          (xEvent *) &ev, 1);
}

/**
 * Enable the device through the driver, add the device to the device list.
 * Switch device ON through the driver and push it onto the global device
 * list. Initialize the DIX sprite or pair the device. All clients are
 * notified about the device being enabled.
 *
 * A master pointer device needs to be enabled before a master keyboard
 * device.
 *
 * @@param The device to be enabled.
 * @@param sendevent True if an XI2 event should be sent.
 * @@return TRUE on success or FALSE otherwise.
 */
Bool
EnableDevice(DeviceIntPtr dev, BOOL sendevent)
{
    DeviceIntPtr *prev;
    int ret;
    DeviceIntPtr other;
    BOOL enabled;
    int flags[MAXDEVICES] = { 0 };

    for (prev = &inputInfo.off_devices;
         *prev && (*prev != dev); prev = &(*prev)->next);

    if (!dev->spriteInfo->sprite) {
        if (IsMaster(dev)) {
            /* Sprites appear on first root window, so we can hardcode it */
            if (dev->spriteInfo->spriteOwner) {
                InitializeSprite(dev, screenInfo.screens[0]->root);
                /* mode doesn't matter */
                EnterWindow(dev, screenInfo.screens[0]->root, NotifyAncestor);
            }
            else {
                other = NextFreePointerDevice();
                BUG_RETURN_VAL_MSG(other == NULL, FALSE,
                                   "[dix] cannot find pointer to pair with.\n");
                PairDevices(other, dev);
            }
        }
        else {
            if (dev->coreEvents)
                other = (IsPointerDevice(dev)) ? inputInfo.pointer:
                    inputInfo.keyboard;
            else
                other = NULL;   /* auto-float non-core devices */
            AttachDevice(NULL, dev, other);
        }
    }

    if ((*prev != dev) || !dev->inited ||
        ((ret = (*dev->deviceProc) (dev, DEVICE_ON)) != Success)) {
        ErrorF("[dix] couldn't enable device %d\n", dev->id);
        return FALSE;
    }
    dev->enabled = TRUE;
    *prev = dev->next;

    for (prev = &inputInfo.devices; *prev; prev = &(*prev)->next);
    *prev = dev;
    dev->next = NULL;

    enabled = TRUE;
    XIChangeDeviceProperty(dev, XIGetKnownProperty(XI_PROP_ENABLED),
                           XA_INTEGER, 8, PropModeReplace, 1, &enabled, TRUE);

    SendDevicePresenceEvent(dev->id, DeviceEnabled);
    if (sendevent) {
        flags[dev->id] |= XIDeviceEnabled;
        XISendDeviceHierarchyEvent(flags);
    }

    if (!IsMaster(dev) && !IsFloating(dev))
        XkbPushLockedStateToSlaves(GetMaster(dev, MASTER_KEYBOARD), 0, 0);
    RecalculateMasterButtons(dev);

    /* initialise an idle timer for this device*/
    dev->idle_counter = SyncInitDeviceIdleTime(dev);

    return TRUE;
}


/**
 * Switch a device off through the driver and push it onto the off_devices
 * list. A device will not send events while disabled. All clients are
 * notified about the device being disabled.
 *
 * Master keyboard devices have to be disabled before master pointer devices
 * otherwise things turn bad.
 *
 * @@param sendevent True if an XI2 event should be sent.
 * @@return TRUE on success or FALSE otherwise.
 */
Bool
DisableDevice(DeviceIntPtr dev, BOOL sendevent)
{
    DeviceIntPtr *prev, other;
    BOOL enabled;
    int flags[MAXDEVICES] = { 0 };

    if (!dev->enabled)
        return TRUE;

    for (prev = &inputInfo.devices;
         *prev && (*prev != dev); prev = &(*prev)->next);
    if (*prev != dev)
        return FALSE;

    TouchEndPhysicallyActiveTouches(dev);
    ReleaseButtonsAndKeys(dev);
    SyncRemoveDeviceIdleTime(dev->idle_counter);
    dev->idle_counter = NULL;

    /* float attached devices */
    if (IsMaster(dev)) {
        for (other = inputInfo.devices; other; other = other->next) {
            if (!IsMaster(other) && GetMaster(other, MASTER_ATTACHED) == dev) {
                AttachDevice(NULL, other, NULL);
                flags[other->id] |= XISlaveDetached;
            }
        }
    }
    else {
        for (other = inputInfo.devices; other; other = other->next) {
            if (IsMaster(other) && other->lastSlave == dev)
                other->lastSlave = NULL;
        }
    }

    if (IsMaster(dev) && dev->spriteInfo->sprite) {
        for (other = inputInfo.devices; other; other = other->next)
            if (other->spriteInfo->paired == dev && !other->spriteInfo->spriteOwner)
                DisableDevice(other, sendevent);
    }

    if (dev->spriteInfo->paired)
        dev->spriteInfo->paired = NULL;

    (void) (*dev->deviceProc) (dev, DEVICE_OFF);
    dev->enabled = FALSE;

    FreeSprite(dev);

    /* now that the device is disabled, we can reset the signal handler's
     * last.slave */
    OsBlockSignals();
    for (other = inputInfo.devices; other; other = other->next) {
        if (other->last.slave == dev)
            other->last.slave = NULL;
    }
    OsReleaseSignals();

    LeaveWindow(dev);
    SetFocusOut(dev);

    *prev = dev->next;
    dev->next = inputInfo.off_devices;
    inputInfo.off_devices = dev;

    enabled = FALSE;
    XIChangeDeviceProperty(dev, XIGetKnownProperty(XI_PROP_ENABLED),
                           XA_INTEGER, 8, PropModeReplace, 1, &enabled, TRUE);

    SendDevicePresenceEvent(dev->id, DeviceDisabled);
    if (sendevent) {
        flags[dev->id] = XIDeviceDisabled;
        XISendDeviceHierarchyEvent(flags);
    }

    RecalculateMasterButtons(dev);

    return TRUE;
}

void
DisableAllDevices(void)
{
    DeviceIntPtr dev, tmp;

    /* Disable slave devices first, excluding XTest devices */
    nt_list_for_each_entry_safe(dev, tmp, inputInfo.devices, next) {
        if (!IsXTestDevice(dev, NULL) && !IsMaster(dev))
            DisableDevice(dev, FALSE);
    }
    /* Disable XTest devices */
    nt_list_for_each_entry_safe(dev, tmp, inputInfo.devices, next) {
        if (!IsMaster(dev))
            DisableDevice(dev, FALSE);
    }
    /* master keyboards need to be disabled first */
    nt_list_for_each_entry_safe(dev, tmp, inputInfo.devices, next) {
        if (dev->enabled && IsMaster(dev) && IsKeyboardDevice(dev))
            DisableDevice(dev, FALSE);
    }
    nt_list_for_each_entry_safe(dev, tmp, inputInfo.devices, next) {
        if (dev->enabled)
            DisableDevice(dev, FALSE);
    }
}

/**
 * Initialise a new device through the driver and tell all clients about the
 * new device.
 *
 * Must be called before EnableDevice.
 * The device will NOT send events until it is enabled!
 *
 * @@param sendevent True if an XI2 event should be sent.
 * @@return Success or an error code on failure.
 */
int
ActivateDevice(DeviceIntPtr dev, BOOL sendevent)
{
    int ret = Success;
    ScreenPtr pScreen = screenInfo.screens[0];

    if (!dev || !dev->deviceProc)
        return BadImplementation;

    ret = (*dev->deviceProc) (dev, DEVICE_INIT);
    dev->inited = (ret == Success);
    if (!dev->inited)
        return ret;

    /* Initialize memory for sprites. */
    if (IsMaster(dev) && dev->spriteInfo->spriteOwner)
        if (!pScreen->DeviceCursorInitialize(dev, pScreen))
            ret = BadAlloc;

    SendDevicePresenceEvent(dev->id, DeviceAdded);
    if (sendevent) {
        int flags[MAXDEVICES] = { 0 };
        flags[dev->id] = XISlaveAdded;
        XISendDeviceHierarchyEvent(flags);
    }
    return ret;
}

/**
 * Ring the bell.
 * The actual task of ringing the bell is the job of the DDX.
 */
static void
CoreKeyboardBell(int volume, DeviceIntPtr pDev, void *arg, int something)
{
    KeybdCtrl *ctrl = arg;

    DDXRingBell(volume, ctrl->bell_pitch, ctrl->bell_duration);
}

static void
CoreKeyboardCtl(DeviceIntPtr pDev, KeybdCtrl * ctrl)
{
    return;
}

/**
 * Device control function for the Virtual Core Keyboard.
 */
int
CoreKeyboardProc(DeviceIntPtr pDev, int what)
{

    switch (what) {
    case DEVICE_INIT:
        if (!InitKeyboardDeviceStruct(pDev, NULL, CoreKeyboardBell,
                                      CoreKeyboardCtl)) {
            ErrorF("Keyboard initialization failed. This could be a missing "
                   "or incorrect setup of xkeyboard-config.\n");
            return BadValue;
        }
        return Success;

    case DEVICE_ON:
    case DEVICE_OFF:
        return Success;

    case DEVICE_CLOSE:
        return Success;
    }

    return BadMatch;
}

/**
 * Device control function for the Virtual Core Pointer.
 */
int
CorePointerProc(DeviceIntPtr pDev, int what)
{
#define NBUTTONS 10
#define NAXES 2
    BYTE map[NBUTTONS + 1];
    int i = 0;
    Atom btn_labels[NBUTTONS] = { 0 };
    Atom axes_labels[NAXES] = { 0 };
    ScreenPtr scr = screenInfo.screens[0];

    switch (what) {
    case DEVICE_INIT:
        for (i = 1; i <= NBUTTONS; i++)
            map[i] = i;

        btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
        btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
        btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
        btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
        btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
        btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
        btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
        /* don't know about the rest */

        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);

        if (!InitPointerDeviceStruct
            ((DevicePtr) pDev, map, NBUTTONS, btn_labels,
             (PtrCtrlProcPtr) NoopDDA, GetMotionHistorySize(), NAXES,
             axes_labels)) {
            ErrorF("Could not initialize device '%s'. Out of memory.\n",
                   pDev->name);
            return BadAlloc;    /* IPDS only fails on allocs */
        }
        /* axisVal is per-screen, last.valuators is desktop-wide */
        pDev->valuator->axisVal[0] = scr->width / 2;
        pDev->last.valuators[0] = pDev->valuator->axisVal[0] + scr->x;
        pDev->valuator->axisVal[1] = scr->height / 2;
        pDev->last.valuators[1] = pDev->valuator->axisVal[1] + scr->y;
        break;

    case DEVICE_CLOSE:
        break;

    default:
        break;
    }

    return Success;

#undef NBUTTONS
#undef NAXES
}

/**
 * Initialise the two core devices, VCP and VCK (see events.c).
 * Both devices are not tied to physical devices, but guarantee that there is
 * always a keyboard and a pointer present and keep the protocol semantics.
 *
 * Note that the server MUST have two core devices at all times, even if there
 * is no physical device connected.
 */
void
InitCoreDevices(void)
{
    if (AllocDevicePair(serverClient, "Virtual core",
                        &inputInfo.pointer, &inputInfo.keyboard,
                        CorePointerProc, CoreKeyboardProc, TRUE) != Success)
         FatalError("Failed to allocate core devices");

    if (ActivateDevice(inputInfo.pointer, TRUE) != Success ||
        ActivateDevice(inputInfo.keyboard, TRUE) != Success)
         FatalError("Failed to activate core devices.");
    if (!EnableDevice(inputInfo.pointer, TRUE) ||
        !EnableDevice(inputInfo.keyboard, TRUE))
         FatalError("Failed to enable core devices.");

    InitXTestDevices();
}

/**
 * Activate all switched-off devices and then enable all those devices.
 *
 * Will return an error if no core keyboard or core pointer is present.
 * In theory this should never happen if you call InitCoreDevices() first.
 *
 * InitAndStartDevices needs to be called AFTER the windows are initialized.
 * Devices will start sending events after InitAndStartDevices() has
 * completed.
 *
 * @@return Success or error code on failure.
 */
int
InitAndStartDevices(void)
{
    DeviceIntPtr dev, next;

    for (dev = inputInfo.off_devices; dev; dev = dev->next) {
        DebugF("(dix) initialising device %d\n", dev->id);
        if (!dev->inited)
            ActivateDevice(dev, TRUE);
    }

    /* enable real devices */
    for (dev = inputInfo.off_devices; dev; dev = next) {
        DebugF("(dix) enabling device %d\n", dev->id);
        next = dev->next;
        if (dev->inited && dev->startup)
            EnableDevice(dev, TRUE);
    }

    return Success;
}

/**
 * Free the given device class and reset the pointer to NULL.
 */
static void
FreeDeviceClass(int type, void **class)
{
    if (!(*class))
        return;

    switch (type) {
    case KeyClass:
    {
        KeyClassPtr *k = (KeyClassPtr *) class;

        if ((*k)->xkbInfo) {
            XkbFreeInfo((*k)->xkbInfo);
            (*k)->xkbInfo = NULL;
        }
        free((*k));
        break;
    }
    case ButtonClass:
    {
        ButtonClassPtr *b = (ButtonClassPtr *) class;

        free((*b)->xkb_acts);
        free((*b));
        break;
    }
    case ValuatorClass:
    {
        ValuatorClassPtr *v = (ValuatorClassPtr *) class;

        free((*v)->motion);
        free((*v));
        break;
    }
    case XITouchClass:
    {
        TouchClassPtr *t = (TouchClassPtr *) class;
        int i;

        for (i = 0; i < (*t)->num_touches; i++) {
            free((*t)->touches[i].sprite.spriteTrace);
            free((*t)->touches[i].listeners);
            free((*t)->touches[i].valuators);
        }

        free((*t)->touches);
        free((*t));
        break;
    }
    case FocusClass:
    {
        FocusClassPtr *f = (FocusClassPtr *) class;

        free((*f)->trace);
        free((*f));
        break;
    }
    case ProximityClass:
    {
        ProximityClassPtr *p = (ProximityClassPtr *) class;

        free((*p));
        break;
    }
    }
    *class = NULL;
}

static void
FreeFeedbackClass(int type, void **class)
{
    if (!(*class))
        return;

    switch (type) {
    case KbdFeedbackClass:
    {
        KbdFeedbackPtr *kbdfeed = (KbdFeedbackPtr *) class;
        KbdFeedbackPtr k, knext;

        for (k = (*kbdfeed); k; k = knext) {
            knext = k->next;
            if (k->xkb_sli)
                XkbFreeSrvLedInfo(k->xkb_sli);
            free(k);
        }
        break;
    }
    case PtrFeedbackClass:
    {
        PtrFeedbackPtr *ptrfeed = (PtrFeedbackPtr *) class;
        PtrFeedbackPtr p, pnext;

        for (p = (*ptrfeed); p; p = pnext) {
            pnext = p->next;
            free(p);
        }
        break;
    }
    case IntegerFeedbackClass:
    {
        IntegerFeedbackPtr *intfeed = (IntegerFeedbackPtr *) class;
        IntegerFeedbackPtr i, inext;

        for (i = (*intfeed); i; i = inext) {
            inext = i->next;
            free(i);
        }
        break;
    }
    case StringFeedbackClass:
    {
        StringFeedbackPtr *stringfeed = (StringFeedbackPtr *) class;
        StringFeedbackPtr s, snext;

        for (s = (*stringfeed); s; s = snext) {
            snext = s->next;
            free(s->ctrl.symbols_supported);
            free(s->ctrl.symbols_displayed);
            free(s);
        }
        break;
    }
    case BellFeedbackClass:
    {
        BellFeedbackPtr *bell = (BellFeedbackPtr *) class;
        BellFeedbackPtr b, bnext;

        for (b = (*bell); b; b = bnext) {
            bnext = b->next;
            free(b);
        }
        break;
    }
    case LedFeedbackClass:
    {
        LedFeedbackPtr *leds = (LedFeedbackPtr *) class;
        LedFeedbackPtr l, lnext;

        for (l = (*leds); l; l = lnext) {
            lnext = l->next;
            if (l->xkb_sli)
                XkbFreeSrvLedInfo(l->xkb_sli);
            free(l);
        }
        break;
    }
    }
    *class = NULL;
}

static void
FreeAllDeviceClasses(ClassesPtr classes)
{
    if (!classes)
        return;

    FreeDeviceClass(KeyClass, (void *) &classes->key);
    FreeDeviceClass(ValuatorClass, (void *) &classes->valuator);
    FreeDeviceClass(XITouchClass, (void *) &classes->touch);
    FreeDeviceClass(ButtonClass, (void *) &classes->button);
    FreeDeviceClass(FocusClass, (void *) &classes->focus);
    FreeDeviceClass(ProximityClass, (void *) &classes->proximity);

    FreeFeedbackClass(KbdFeedbackClass, (void *) &classes->kbdfeed);
    FreeFeedbackClass(PtrFeedbackClass, (void *) &classes->ptrfeed);
    FreeFeedbackClass(IntegerFeedbackClass, (void *) &classes->intfeed);
    FreeFeedbackClass(StringFeedbackClass, (void *) &classes->stringfeed);
    FreeFeedbackClass(BellFeedbackClass, (void *) &classes->bell);
    FreeFeedbackClass(LedFeedbackClass, (void *) &classes->leds);

}

/**
 * Close down a device and free all resources.
 * Once closed down, the driver will probably not expect you that you'll ever
 * enable it again and free associated structs. If you want the device to just
 * be disabled, DisableDevice().
 * Don't call this function directly, use RemoveDevice() instead.
 */
static void
CloseDevice(DeviceIntPtr dev)
{
    ScreenPtr screen = screenInfo.screens[0];
    ClassesPtr classes;
    int j;

    if (!dev)
        return;

    XIDeleteAllDeviceProperties(dev);

    if (dev->inited)
        (void) (*dev->deviceProc) (dev, DEVICE_CLOSE);

    FreeSprite(dev);

    if (IsMaster(dev))
        screen->DeviceCursorCleanup(dev, screen);

    /* free acceleration info */
    if (dev->valuator && dev->valuator->accelScheme.AccelCleanupProc)
        dev->valuator->accelScheme.AccelCleanupProc(dev);

    while (dev->xkb_interest)
        XkbRemoveResourceClient((DevicePtr) dev, dev->xkb_interest->resource);

    free(dev->name);

    classes = (ClassesPtr) &dev->key;
    FreeAllDeviceClasses(classes);

    if (IsMaster(dev)) {
        classes = dev->unused_classes;
        FreeAllDeviceClasses(classes);
        free(classes);
    }

    /* a client may have the device set as client pointer */
    for (j = 0; j < currentMaxClients; j++) {
        if (clients[j] && clients[j]->clientPtr == dev) {
            clients[j]->clientPtr = NULL;
            clients[j]->clientPtr = PickPointer(clients[j]);
        }
    }

    if (dev->deviceGrab.grab)
        FreeGrab(dev->deviceGrab.grab);
    free(dev->deviceGrab.sync.event);
    free(dev->config_info);     /* Allocated in xf86ActivateDevice. */
    free(dev->last.scroll);
    for (j = 0; j < dev->last.num_touches; j++)
        free(dev->last.touches[j].valuators);
    free(dev->last.touches);
    dev->config_info = NULL;
    dixFreePrivates(dev->devPrivates, PRIVATE_DEVICE);
    free(dev);
}

/**
 * Shut down all devices of one list and free all resources.
 */
static
    void
CloseDeviceList(DeviceIntPtr *listHead)
{
    /* Used to mark devices that we tried to free */
    Bool freedIds[MAXDEVICES];
    DeviceIntPtr dev;
    int i;

    if (listHead == NULL)
        return;

    for (i = 0; i < MAXDEVICES; i++)
        freedIds[i] = FALSE;

    dev = *listHead;
    while (dev != NULL) {
        freedIds[dev->id] = TRUE;
        DeleteInputDeviceRequest(dev);

        dev = *listHead;
        while (dev != NULL && freedIds[dev->id])
            dev = dev->next;
    }
}

/**
 * Shut down all devices, free all resources, etc.
 * Only useful if you're shutting down the server!
 */
void
CloseDownDevices(void)
{
    DeviceIntPtr dev;

    OsBlockSignals();

    /* Float all SDs before closing them. Note that at this point resources
     * (e.g. cursors) have been freed already, so we can't just call
     * AttachDevice(NULL, dev, NULL). Instead, we have to forcibly set master
     * to NULL and pretend nothing happened.
     */
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (!IsMaster(dev) && !IsFloating(dev))
            dev->master = NULL;
    }

    CloseDeviceList(&inputInfo.devices);
    CloseDeviceList(&inputInfo.off_devices);

    CloseDevice(inputInfo.pointer);

    CloseDevice(inputInfo.keyboard);

    inputInfo.devices = NULL;
    inputInfo.off_devices = NULL;
    inputInfo.keyboard = NULL;
    inputInfo.pointer = NULL;

    XkbDeleteRulesDflts();
    XkbDeleteRulesUsed();

    OsReleaseSignals();
}

/**
 * Signal all devices that we're in the process of aborting.
 * This function is called from a signal handler.
 */
void
AbortDevices(void)
{
    DeviceIntPtr dev;
    nt_list_for_each_entry(dev, inputInfo.devices, next) {
        if (!IsMaster(dev))
            (*dev->deviceProc) (dev, DEVICE_ABORT);
    }

    nt_list_for_each_entry(dev, inputInfo.off_devices, next) {
        if (!IsMaster(dev))
            (*dev->deviceProc) (dev, DEVICE_ABORT);
    }
}

/**
 * Remove the cursor sprite for all devices. This needs to be done before any
 * resources are freed or any device is deleted.
 */
void
UndisplayDevices(void)
{
    DeviceIntPtr dev;
    ScreenPtr screen = screenInfo.screens[0];

    for (dev = inputInfo.devices; dev; dev = dev->next)
        screen->DisplayCursor(dev, screen, NullCursor);
}

/**
 * Remove a device from the device list, closes it and thus frees all
 * resources.
 * Removes both enabled and disabled devices and notifies all devices about
 * the removal of the device.
 *
 * No PresenceNotify is sent for device that the client never saw. This can
 * happen if a malloc fails during the addition of master devices. If
 * dev->init is FALSE it means the client never received a DeviceAdded event,
 * so let's not send a DeviceRemoved event either.
 *
 * @@param sendevent True if an XI2 event should be sent.
 */
int
RemoveDevice(DeviceIntPtr dev, BOOL sendevent)
{
    DeviceIntPtr prev, tmp, next;
    int ret = BadMatch;
    ScreenPtr screen = screenInfo.screens[0];
    int deviceid;
    int initialized;
    int flags[MAXDEVICES] = { 0 };

    DebugF("(dix) removing device %d\n", dev->id);

    if (!dev || dev == inputInfo.keyboard || dev == inputInfo.pointer)
        return BadImplementation;

    initialized = dev->inited;
    deviceid = dev->id;

    if (initialized) {
        if (DevHasCursor(dev))
            screen->DisplayCursor(dev, screen, NullCursor);

        DisableDevice(dev, sendevent);
        flags[dev->id] = XIDeviceDisabled;
    }

    prev = NULL;
    for (tmp = inputInfo.devices; tmp; (prev = tmp), (tmp = next)) {
        next = tmp->next;
        if (tmp == dev) {

            if (prev == NULL)
                inputInfo.devices = next;
            else
                prev->next = next;

            flags[tmp->id] = IsMaster(tmp) ? XIMasterRemoved : XISlaveRemoved;
            CloseDevice(tmp);
            ret = Success;
        }
    }

    prev = NULL;
    for (tmp = inputInfo.off_devices; tmp; (prev = tmp), (tmp = next)) {
        next = tmp->next;
        if (tmp == dev) {
            flags[tmp->id] = IsMaster(tmp) ? XIMasterRemoved : XISlaveRemoved;
            CloseDevice(tmp);

            if (prev == NULL)
                inputInfo.off_devices = next;
            else
                prev->next = next;

            ret = Success;
        }
    }

    if (ret == Success && initialized) {
        inputInfo.numDevices--;
        SendDevicePresenceEvent(deviceid, DeviceRemoved);
        if (sendevent)
            XISendDeviceHierarchyEvent(flags);
    }

    return ret;
}

int
NumMotionEvents(void)
{
    /* only called to fill data in initial connection reply.
     * VCP is ok here, it is the only fixed device we have. */
    return inputInfo.pointer->valuator->numMotionEvents;
}

int
dixLookupDevice(DeviceIntPtr *pDev, int id, ClientPtr client, Mask access_mode)
{
    DeviceIntPtr dev;
    int rc;

    *pDev = NULL;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (dev->id == id)
            goto found;
    }
    for (dev = inputInfo.off_devices; dev; dev = dev->next) {
        if (dev->id == id)
            goto found;
    }
    return BadDevice;

 found:
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, access_mode);
    if (rc == Success)
        *pDev = dev;
    return rc;
}

void
QueryMinMaxKeyCodes(KeyCode *minCode, KeyCode *maxCode)
{
    if (inputInfo.keyboard) {
        *minCode = inputInfo.keyboard->key->xkbInfo->desc->min_key_code;
        *maxCode = inputInfo.keyboard->key->xkbInfo->desc->max_key_code;
    }
}

Bool
InitButtonClassDeviceStruct(DeviceIntPtr dev, int numButtons, Atom *labels,
                            CARD8 *map)
{
    ButtonClassPtr butc;
    int i;

    BUG_RETURN_VAL(dev == NULL, FALSE);
    BUG_RETURN_VAL(dev->button != NULL, FALSE);
    BUG_RETURN_VAL(numButtons >= MAX_BUTTONS, FALSE);

    butc = calloc(1, sizeof(ButtonClassRec));
    if (!butc)
        return FALSE;
    butc->numButtons = numButtons;
    butc->sourceid = dev->id;
    for (i = 1; i <= numButtons; i++)
        butc->map[i] = map[i];
    for (i = numButtons + 1; i < MAP_LENGTH; i++)
        butc->map[i] = i;
    memcpy(butc->labels, labels, numButtons * sizeof(Atom));
    dev->button = butc;
    return TRUE;
}

/**
 * Allocate a valuator class and set up the pointers for the axis values
 * appropriately.
 *
 * @@param src If non-NULL, the memory is reallocated from src. If NULL, the
 * memory is calloc'd.
 * @@parma numAxes Number of axes to allocate.
 * @@return The allocated valuator struct.
 */
ValuatorClassPtr
AllocValuatorClass(ValuatorClassPtr src, int numAxes)
{
    ValuatorClassPtr v;

    /* force alignment with double */
    union align_u {
        ValuatorClassRec valc;
        double d;
    } *align;
    int size;

    size =
        sizeof(union align_u) + numAxes * (sizeof(double) + sizeof(AxisInfo));
    align = (union align_u *) realloc(src, size);

    if (!align)
        return NULL;

    if (!src)
        memset(align, 0, size);

    v = &align->valc;
    v->numAxes = numAxes;
    v->axisVal = (double *) (align + 1);
    v->axes = (AxisInfoPtr) (v->axisVal + numAxes);

    return v;
}

Bool
InitValuatorClassDeviceStruct(DeviceIntPtr dev, int numAxes, Atom *labels,
                              int numMotionEvents, int mode)
{
    int i;
    ValuatorClassPtr valc;

    BUG_RETURN_VAL(dev == NULL, FALSE);

    if (numAxes > MAX_VALUATORS) {
        LogMessage(X_WARNING,
                   "Device '%s' has %d axes, only using first %d.\n",
                   dev->name, numAxes, MAX_VALUATORS);
        numAxes = MAX_VALUATORS;
    }

    valc = AllocValuatorClass(NULL, numAxes);
    if (!valc)
        return FALSE;

    dev->last.scroll = valuator_mask_new(numAxes);
    if (!dev->last.scroll) {
        free(valc);
        return FALSE;
    }

    valc->sourceid = dev->id;
    valc->motion = NULL;
    valc->first_motion = 0;
    valc->last_motion = 0;
    valc->h_scroll_axis = -1;
    valc->v_scroll_axis = -1;

    valc->numMotionEvents = numMotionEvents;
    valc->motionHintWindow = NullWindow;

    if ((mode & OutOfProximity) && !dev->proximity)
        InitProximityClassDeviceStruct(dev);

    dev->valuator = valc;

    AllocateMotionHistory(dev);

    for (i = 0; i < numAxes; i++) {
        InitValuatorAxisStruct(dev, i, labels[i], NO_AXIS_LIMITS,
                               NO_AXIS_LIMITS, 0, 0, 0, mode);
        valc->axisVal[i] = 0;
    }

    dev->last.numValuators = numAxes;

    if (IsMaster(dev) ||        /* do not accelerate master or xtest devices */
        IsXTestDevice(dev, NULL))
        InitPointerAccelerationScheme(dev, PtrAccelNoOp);
    else
        InitPointerAccelerationScheme(dev, PtrAccelDefault);
    return TRUE;
}

/* global list of acceleration schemes */
ValuatorAccelerationRec pointerAccelerationScheme[] = {
    {PtrAccelNoOp, NULL, NULL, NULL, NULL},
    {PtrAccelPredictable, acceleratePointerPredictable, NULL,
     InitPredictableAccelerationScheme, AccelerationDefaultCleanup},
    {PtrAccelLightweight, acceleratePointerLightweight, NULL, NULL, NULL},
    {-1, NULL, NULL, NULL, NULL}        /* terminator */
};

/**
 * install an acceleration scheme. returns TRUE on success, and should not
 * change anything if unsuccessful.
 */
Bool
InitPointerAccelerationScheme(DeviceIntPtr dev, int scheme)
{
    int x, i = -1;
    ValuatorClassPtr val;

    val = dev->valuator;

    if (!val)
        return FALSE;

    if (IsMaster(dev) && scheme != PtrAccelNoOp)
        return FALSE;

    for (x = 0; pointerAccelerationScheme[x].number >= 0; x++) {
        if (pointerAccelerationScheme[x].number == scheme) {
            i = x;
            break;
        }
    }

    if (-1 == i)
        return FALSE;

    if (val->accelScheme.AccelCleanupProc)
        val->accelScheme.AccelCleanupProc(dev);

    if (pointerAccelerationScheme[i].AccelInitProc) {
        if (!pointerAccelerationScheme[i].AccelInitProc(dev,
                                            &pointerAccelerationScheme[i])) {
            return FALSE;
        }
    }
    else {
        val->accelScheme = pointerAccelerationScheme[i];
    }
    return TRUE;
}

Bool
InitFocusClassDeviceStruct(DeviceIntPtr dev)
{
    FocusClassPtr focc;

    BUG_RETURN_VAL(dev == NULL, FALSE);
    BUG_RETURN_VAL(dev->focus != NULL, FALSE);

    focc = malloc(sizeof(FocusClassRec));
    if (!focc)
        return FALSE;
    focc->win = PointerRootWin;
    focc->revert = None;
    focc->time = currentTime;
    focc->trace = (WindowPtr *) NULL;
    focc->traceSize = 0;
    focc->traceGood = 0;
    focc->sourceid = dev->id;
    dev->focus = focc;
    return TRUE;
}

Bool
InitPtrFeedbackClassDeviceStruct(DeviceIntPtr dev, PtrCtrlProcPtr controlProc)
{
    PtrFeedbackPtr feedc;

    BUG_RETURN_VAL(dev == NULL, FALSE);

    feedc = malloc(sizeof(PtrFeedbackClassRec));
    if (!feedc)
        return FALSE;
    feedc->CtrlProc = controlProc;
    feedc->ctrl = defaultPointerControl;
    feedc->ctrl.id = 0;
    if ((feedc->next = dev->ptrfeed))
        feedc->ctrl.id = dev->ptrfeed->ctrl.id + 1;
    dev->ptrfeed = feedc;
    (*controlProc) (dev, &feedc->ctrl);
    return TRUE;
}

static LedCtrl defaultLedControl = {
    DEFAULT_LEDS, DEFAULT_LEDS_MASK, 0
};

static BellCtrl defaultBellControl = {
    DEFAULT_BELL,
    DEFAULT_BELL_PITCH,
    DEFAULT_BELL_DURATION,
    0
};

static IntegerCtrl defaultIntegerControl = {
    DEFAULT_INT_RESOLUTION,
    DEFAULT_INT_MIN_VALUE,
    DEFAULT_INT_MAX_VALUE,
    DEFAULT_INT_DISPLAYED,
    0
};

Bool
InitStringFeedbackClassDeviceStruct(DeviceIntPtr dev,
                                    StringCtrlProcPtr controlProc,
                                    int max_symbols, int num_symbols_supported,
                                    KeySym * symbols)
{
    int i;
    StringFeedbackPtr feedc;

    BUG_RETURN_VAL(dev == NULL, FALSE);

    feedc = malloc(sizeof(StringFeedbackClassRec));
    if (!feedc)
        return FALSE;
    feedc->CtrlProc = controlProc;
    feedc->ctrl.num_symbols_supported = num_symbols_supported;
    feedc->ctrl.num_symbols_displayed = 0;
    feedc->ctrl.max_symbols = max_symbols;
    feedc->ctrl.symbols_supported =
        xallocarray(num_symbols_supported, sizeof(KeySym));
    feedc->ctrl.symbols_displayed = xallocarray(max_symbols, sizeof(KeySym));
    if (!feedc->ctrl.symbols_supported || !feedc->ctrl.symbols_displayed) {
        free(feedc->ctrl.symbols_supported);
        free(feedc->ctrl.symbols_displayed);
        free(feedc);
        return FALSE;
    }
    for (i = 0; i < num_symbols_supported; i++)
        *(feedc->ctrl.symbols_supported + i) = *symbols++;
    for (i = 0; i < max_symbols; i++)
        *(feedc->ctrl.symbols_displayed + i) = (KeySym) 0;
    feedc->ctrl.id = 0;
    if ((feedc->next = dev->stringfeed))
        feedc->ctrl.id = dev->stringfeed->ctrl.id + 1;
    dev->stringfeed = feedc;
    (*controlProc) (dev, &feedc->ctrl);
    return TRUE;
}

Bool
InitBellFeedbackClassDeviceStruct(DeviceIntPtr dev, BellProcPtr bellProc,
                                  BellCtrlProcPtr controlProc)
{
    BellFeedbackPtr feedc;

    BUG_RETURN_VAL(dev == NULL, FALSE);

    feedc = malloc(sizeof(BellFeedbackClassRec));
    if (!feedc)
        return FALSE;
    feedc->CtrlProc = controlProc;
    feedc->BellProc = bellProc;
    feedc->ctrl = defaultBellControl;
    feedc->ctrl.id = 0;
    if ((feedc->next = dev->bell))
        feedc->ctrl.id = dev->bell->ctrl.id + 1;
    dev->bell = feedc;
    (*controlProc) (dev, &feedc->ctrl);
    return TRUE;
}

Bool
InitLedFeedbackClassDeviceStruct(DeviceIntPtr dev, LedCtrlProcPtr controlProc)
{
    LedFeedbackPtr feedc;

    BUG_RETURN_VAL(dev == NULL, FALSE);

    feedc = malloc(sizeof(LedFeedbackClassRec));
    if (!feedc)
        return FALSE;
    feedc->CtrlProc = controlProc;
    feedc->ctrl = defaultLedControl;
    feedc->ctrl.id = 0;
    if ((feedc->next = dev->leds))
        feedc->ctrl.id = dev->leds->ctrl.id + 1;
    feedc->xkb_sli = NULL;
    dev->leds = feedc;
    (*controlProc) (dev, &feedc->ctrl);
    return TRUE;
}

Bool
InitIntegerFeedbackClassDeviceStruct(DeviceIntPtr dev,
                                     IntegerCtrlProcPtr controlProc)
{
    IntegerFeedbackPtr feedc;

    BUG_RETURN_VAL(dev == NULL, FALSE);

    feedc = malloc(sizeof(IntegerFeedbackClassRec));
    if (!feedc)
        return FALSE;
    feedc->CtrlProc = controlProc;
    feedc->ctrl = defaultIntegerControl;
    feedc->ctrl.id = 0;
    if ((feedc->next = dev->intfeed))
        feedc->ctrl.id = dev->intfeed->ctrl.id + 1;
    dev->intfeed = feedc;
    (*controlProc) (dev, &feedc->ctrl);
    return TRUE;
}

Bool
InitPointerDeviceStruct(DevicePtr device, CARD8 *map, int numButtons,
                        Atom *btn_labels, PtrCtrlProcPtr controlProc,
                        int numMotionEvents, int numAxes, Atom *axes_labels)
{
    DeviceIntPtr dev = (DeviceIntPtr) device;

    BUG_RETURN_VAL(dev == NULL, FALSE);
    BUG_RETURN_VAL(dev->button != NULL, FALSE);
    BUG_RETURN_VAL(dev->valuator != NULL, FALSE);
    BUG_RETURN_VAL(dev->ptrfeed != NULL, FALSE);

    return (InitButtonClassDeviceStruct(dev, numButtons, btn_labels, map) &&
            InitValuatorClassDeviceStruct(dev, numAxes, axes_labels,
                                          numMotionEvents, Relative) &&
            InitPtrFeedbackClassDeviceStruct(dev, controlProc));
}

/**
 * Sets up multitouch capabilities on @@device.
 *
 * @@max_touches The maximum number of simultaneous touches, or 0 for unlimited.
 * @@mode The mode of the touch device (XIDirectTouch or XIDependentTouch).
 * @@num_axes The number of touch valuator axes.
 */
Bool
InitTouchClassDeviceStruct(DeviceIntPtr device, unsigned int max_touches,
                           unsigned int mode, unsigned int num_axes)
{
    TouchClassPtr touch;
    int i;

    BUG_RETURN_VAL(device == NULL, FALSE);
    BUG_RETURN_VAL(device->touch != NULL, FALSE);
    BUG_RETURN_VAL(device->valuator == NULL, FALSE);

    /* Check the mode is valid, and at least X and Y axes. */
    BUG_RETURN_VAL(mode != XIDirectTouch && mode != XIDependentTouch, FALSE);
    BUG_RETURN_VAL(num_axes < 2, FALSE);

    if (num_axes > MAX_VALUATORS) {
        LogMessage(X_WARNING,
                   "Device '%s' has %d touch axes, only using first %d.\n",
                   device->name, num_axes, MAX_VALUATORS);
        num_axes = MAX_VALUATORS;
    }

    touch = calloc(1, sizeof(*touch));
    if (!touch)
        return FALSE;

    touch->max_touches = max_touches;
    if (max_touches == 0)
        max_touches = 5;        /* arbitrary number plucked out of the air */
    touch->touches = calloc(max_touches, sizeof(*touch->touches));
    if (!touch->touches)
        goto err;
    touch->num_touches = max_touches;
    for (i = 0; i < max_touches; i++)
        TouchInitTouchPoint(touch, device->valuator, i);

    touch->mode = mode;
    touch->sourceid = device->id;

    device->touch = touch;
    device->last.touches = calloc(max_touches, sizeof(*device->last.touches));
    device->last.num_touches = touch->num_touches;
    for (i = 0; i < touch->num_touches; i++)
        TouchInitDDXTouchPoint(device, &device->last.touches[i]);

    return TRUE;

 err:
    for (i = 0; i < touch->num_touches; i++)
        TouchFreeTouchPoint(device, i);

    free(touch->touches);
    free(touch);

    return FALSE;
}

/*
 * Check if the given buffer contains elements between low (inclusive) and
 * high (inclusive) only.
 *
 * @@return TRUE if the device map is invalid, FALSE otherwise.
 */
Bool
BadDeviceMap(BYTE * buff, int length, unsigned low, unsigned high, XID *errval)
{
    int i;

    for (i = 0; i < length; i++)
        if (buff[i]) {          /* only check non-zero elements */
            if ((low > buff[i]) || (high < buff[i])) {
                *errval = buff[i];
                return TRUE;
            }
        }
    return FALSE;
}

int
ProcSetModifierMapping(ClientPtr client)
{
    xSetModifierMappingReply rep;
    int rc;

    REQUEST(xSetModifierMappingReq);
    REQUEST_AT_LEAST_SIZE(xSetModifierMappingReq);

    if (client->req_len != ((stuff->numKeyPerModifier << 1) +
                            bytes_to_int32(sizeof(xSetModifierMappingReq))))
        return BadLength;

    rep = (xSetModifierMappingReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };

    rc = change_modmap(client, PickKeyboard(client), (KeyCode *) &stuff[1],
                       stuff->numKeyPerModifier);
    if (rc == MappingFailed || rc == -1)
        return BadValue;
    if (rc != MappingSuccess && rc != MappingFailed && rc != MappingBusy)
        return rc;

    rep.success = rc;

    WriteReplyToClient(client, sizeof(xSetModifierMappingReply), &rep);
    return Success;
}

int
ProcGetModifierMapping(ClientPtr client)
{
    xGetModifierMappingReply rep;
    int max_keys_per_mod = 0;
    KeyCode *modkeymap = NULL;

    REQUEST_SIZE_MATCH(xReq);

    generate_modkeymap(client, PickKeyboard(client), &modkeymap,
                       &max_keys_per_mod);

    rep = (xGetModifierMappingReply) {
        .type = X_Reply,
        .numKeyPerModifier = max_keys_per_mod,
        .sequenceNumber = client->sequence,
    /* length counts 4 byte quantities - there are 8 modifiers 1 byte big */
        .length = max_keys_per_mod << 1
    };

    WriteReplyToClient(client, sizeof(xGetModifierMappingReply), &rep);
    WriteToClient(client, max_keys_per_mod * 8, modkeymap);

    free(modkeymap);

    return Success;
}

int
ProcChangeKeyboardMapping(ClientPtr client)
{
    REQUEST(xChangeKeyboardMappingReq);
    unsigned len;
    KeySymsRec keysyms;
    DeviceIntPtr pDev, tmp;
    int rc;

    REQUEST_AT_LEAST_SIZE(xChangeKeyboardMappingReq);

    len = client->req_len - bytes_to_int32(sizeof(xChangeKeyboardMappingReq));
    if (len != (stuff->keyCodes * stuff->keySymsPerKeyCode))
        return BadLength;

    pDev = PickKeyboard(client);

    if ((stuff->firstKeyCode < pDev->key->xkbInfo->desc->min_key_code) ||
        (stuff->firstKeyCode > pDev->key->xkbInfo->desc->max_key_code)) {
        client->errorValue = stuff->firstKeyCode;
        return BadValue;

    }
    if (((unsigned) (stuff->firstKeyCode + stuff->keyCodes - 1) >
         pDev->key->xkbInfo->desc->max_key_code) ||
        (stuff->keySymsPerKeyCode == 0)) {
        client->errorValue = stuff->keySymsPerKeyCode;
        return BadValue;
    }

    keysyms.minKeyCode = stuff->firstKeyCode;
    keysyms.maxKeyCode = stuff->firstKeyCode + stuff->keyCodes - 1;
    keysyms.mapWidth = stuff->keySymsPerKeyCode;
    keysyms.map = (KeySym *) &stuff[1];

    rc = XaceHook(XACE_DEVICE_ACCESS, client, pDev, DixManageAccess);
    if (rc != Success)
        return rc;

    XkbApplyMappingChange(pDev, &keysyms, stuff->firstKeyCode,
                          stuff->keyCodes, NULL, client);

    for (tmp = inputInfo.devices; tmp; tmp = tmp->next) {
        if (IsMaster(tmp) || GetMaster(tmp, MASTER_KEYBOARD) != pDev)
            continue;
        if (!tmp->key)
            continue;

        rc = XaceHook(XACE_DEVICE_ACCESS, client, pDev, DixManageAccess);
        if (rc != Success)
            continue;

        XkbApplyMappingChange(tmp, &keysyms, stuff->firstKeyCode,
                              stuff->keyCodes, NULL, client);
    }

    return Success;
}

int
ProcSetPointerMapping(ClientPtr client)
{
    BYTE *map;
    int ret;
    int i, j;
    DeviceIntPtr ptr = PickPointer(client);
    xSetPointerMappingReply rep;

    REQUEST(xSetPointerMappingReq);
    REQUEST_AT_LEAST_SIZE(xSetPointerMappingReq);

    if (client->req_len !=
        bytes_to_int32(sizeof(xSetPointerMappingReq) + stuff->nElts))
        return BadLength;

    rep = (xSetPointerMappingReply) {
        .type = X_Reply,
        .success = MappingSuccess,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    map = (BYTE *) &stuff[1];

    /* So we're bounded here by the number of core buttons.  This check
     * probably wants disabling through XFixes. */
    /* MPX: With ClientPointer, we can return the right number of buttons.
     * Let's just hope nobody changed ClientPointer between GetPointerMapping
     * and SetPointerMapping
     */
    if (stuff->nElts != ptr->button->numButtons) {
        client->errorValue = stuff->nElts;
        return BadValue;
    }

    /* Core protocol specs don't allow for duplicate mappings; this check
     * almost certainly wants disabling through XFixes too. */
    for (i = 0; i < stuff->nElts; i++) {
        for (j = i + 1; j < stuff->nElts; j++) {
            if (map[i] && map[i] == map[j]) {
                client->errorValue = map[i];
                return BadValue;
            }
        }
    }

    ret = ApplyPointerMapping(ptr, map, stuff->nElts, client);
    if (ret == MappingBusy)
        rep.success = ret;
    else if (ret == -1)
        return BadValue;
    else if (ret != Success)
        return ret;

    WriteReplyToClient(client, sizeof(xSetPointerMappingReply), &rep);
    return Success;
}

int
ProcGetKeyboardMapping(ClientPtr client)
{
    xGetKeyboardMappingReply rep;
    DeviceIntPtr kbd = PickKeyboard(client);
    XkbDescPtr xkb;
    KeySymsPtr syms;
    int rc;

    REQUEST(xGetKeyboardMappingReq);
    REQUEST_SIZE_MATCH(xGetKeyboardMappingReq);

    rc = XaceHook(XACE_DEVICE_ACCESS, client, kbd, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    xkb = kbd->key->xkbInfo->desc;

    if ((stuff->firstKeyCode < xkb->min_key_code) ||
        (stuff->firstKeyCode > xkb->max_key_code)) {
        client->errorValue = stuff->firstKeyCode;
        return BadValue;
    }
    if (stuff->firstKeyCode + stuff->count > xkb->max_key_code + 1) {
        client->errorValue = stuff->count;
        return BadValue;
    }

    syms = XkbGetCoreMap(kbd);
    if (!syms)
        return BadAlloc;

    rep = (xGetKeyboardMappingReply) {
        .type = X_Reply,
        .keySymsPerKeyCode = syms->mapWidth,
        .sequenceNumber = client->sequence,
        /* length is a count of 4 byte quantities and KeySyms are 4 bytes */
        .length = syms->mapWidth * stuff->count
    };
    WriteReplyToClient(client, sizeof(xGetKeyboardMappingReply), &rep);
    client->pSwapReplyFunc = (ReplySwapPtr) CopySwap32Write;
    WriteSwappedDataToClient(client,
                             syms->mapWidth * stuff->count * sizeof(KeySym),
                             &syms->map[syms->mapWidth * (stuff->firstKeyCode -
                                                          syms->minKeyCode)]);
    free(syms->map);
    free(syms);

    return Success;
}

int
ProcGetPointerMapping(ClientPtr client)
{
    xGetPointerMappingReply rep;

    /* Apps may get different values each time they call GetPointerMapping as
     * the ClientPointer could change. */
    DeviceIntPtr ptr = PickPointer(client);
    ButtonClassPtr butc = ptr->button;
    int nElts;
    int rc;

    REQUEST_SIZE_MATCH(xReq);

    rc = XaceHook(XACE_DEVICE_ACCESS, client, ptr, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    nElts = (butc) ? butc->numButtons : 0;
    rep = (xGetPointerMappingReply) {
        .type = X_Reply,
        .nElts = nElts,
        .sequenceNumber = client->sequence,
        .length = ((unsigned) nElts + (4 - 1)) / 4
    };
    WriteReplyToClient(client, sizeof(xGetPointerMappingReply), &rep);
    if (butc)
        WriteToClient(client, nElts, &butc->map[1]);
    return Success;
}

void
NoteLedState(DeviceIntPtr keybd, int led, Bool on)
{
    KeybdCtrl *ctrl = &keybd->kbdfeed->ctrl;

    if (on)
        ctrl->leds |= ((Leds) 1 << (led - 1));
    else
        ctrl->leds &= ~((Leds) 1 << (led - 1));
}

int
Ones(unsigned long mask)
{                               /* HACKMEM 169 */
    unsigned long y;

    y = (mask >> 1) & 033333333333;
    y = mask - y - ((y >> 1) & 033333333333);
    return (((y + (y >> 3)) & 030707070707) % 077);
}

static int
DoChangeKeyboardControl(ClientPtr client, DeviceIntPtr keybd, XID *vlist,
                        BITS32 vmask)
{
#define DO_ALL    (-1)
    KeybdCtrl ctrl;
    int t;
    int led = DO_ALL;
    int key = DO_ALL;
    BITS32 index2;
    int mask = vmask, i;
    XkbEventCauseRec cause;

    ctrl = keybd->kbdfeed->ctrl;
    while (vmask) {
        index2 = (BITS32) lowbit(vmask);
        vmask &= ~index2;
        switch (index2) {
        case KBKeyClickPercent:
            t = (INT8) *vlist;
            vlist++;
            if (t == -1) {
                t = defaultKeyboardControl.click;
            }
            else if (t < 0 || t > 100) {
                client->errorValue = t;
                return BadValue;
            }
            ctrl.click = t;
            break;
        case KBBellPercent:
            t = (INT8) *vlist;
            vlist++;
            if (t == -1) {
                t = defaultKeyboardControl.bell;
            }
            else if (t < 0 || t > 100) {
                client->errorValue = t;
                return BadValue;
            }
            ctrl.bell = t;
            break;
        case KBBellPitch:
            t = (INT16) *vlist;
            vlist++;
            if (t == -1) {
                t = defaultKeyboardControl.bell_pitch;
            }
            else if (t < 0) {
                client->errorValue = t;
                return BadValue;
            }
            ctrl.bell_pitch = t;
            break;
        case KBBellDuration:
            t = (INT16) *vlist;
            vlist++;
            if (t == -1)
                t = defaultKeyboardControl.bell_duration;
            else if (t < 0) {
                client->errorValue = t;
                return BadValue;
            }
            ctrl.bell_duration = t;
            break;
        case KBLed:
            led = (CARD8) *vlist;
            vlist++;
            if (led < 1 || led > 32) {
                client->errorValue = led;
                return BadValue;
            }
            if (!(mask & KBLedMode))
                return BadMatch;
            break;
        case KBLedMode:
            t = (CARD8) *vlist;
            vlist++;
            if (t == LedModeOff) {
                if (led == DO_ALL)
                    ctrl.leds = 0x0;
                else
                    ctrl.leds &= ~(((Leds) (1)) << (led - 1));
            }
            else if (t == LedModeOn) {
                if (led == DO_ALL)
                    ctrl.leds = ~0L;
                else
                    ctrl.leds |= (((Leds) (1)) << (led - 1));
            }
            else {
                client->errorValue = t;
                return BadValue;
            }

            XkbSetCauseCoreReq(&cause, X_ChangeKeyboardControl, client);
            XkbSetIndicators(keybd, ((led == DO_ALL) ? ~0L : (1L << (led - 1))),
                             ctrl.leds, &cause);
            ctrl.leds = keybd->kbdfeed->ctrl.leds;

            break;
        case KBKey:
            key = (KeyCode) *vlist;
            vlist++;
            if ((KeyCode) key < keybd->key->xkbInfo->desc->min_key_code ||
                (KeyCode) key > keybd->key->xkbInfo->desc->max_key_code) {
                client->errorValue = key;
                return BadValue;
            }
            if (!(mask & KBAutoRepeatMode))
                return BadMatch;
            break;
        case KBAutoRepeatMode:
            i = (key >> 3);
            mask = (1 << (key & 7));
            t = (CARD8) *vlist;
            vlist++;
            if (key != DO_ALL)
                XkbDisableComputedAutoRepeats(keybd, key);
            if (t == AutoRepeatModeOff) {
                if (key == DO_ALL)
                    ctrl.autoRepeat = FALSE;
                else
                    ctrl.autoRepeats[i] &= ~mask;
            }
            else if (t == AutoRepeatModeOn) {
                if (key == DO_ALL)
                    ctrl.autoRepeat = TRUE;
                else
                    ctrl.autoRepeats[i] |= mask;
            }
            else if (t == AutoRepeatModeDefault) {
                if (key == DO_ALL)
                    ctrl.autoRepeat = defaultKeyboardControl.autoRepeat;
                else
                    ctrl.autoRepeats[i] =
                        (ctrl.autoRepeats[i] & ~mask) |
                        (defaultKeyboardControl.autoRepeats[i] & mask);
            }
            else {
                client->errorValue = t;
                return BadValue;
            }
            break;
        default:
            client->errorValue = mask;
            return BadValue;
        }
    }
    keybd->kbdfeed->ctrl = ctrl;

    /* The XKB RepeatKeys control and core protocol global autorepeat */
    /* value are linked */
    XkbSetRepeatKeys(keybd, key, keybd->kbdfeed->ctrl.autoRepeat);

    return Success;

#undef DO_ALL
}

/**
 * Changes kbd control on the ClientPointer and all attached SDs.
 */
int
ProcChangeKeyboardControl(ClientPtr client)
{
    XID *vlist;
    BITS32 vmask;
    int ret = Success, error = Success;
    DeviceIntPtr pDev = NULL, keyboard;

    REQUEST(xChangeKeyboardControlReq);

    REQUEST_AT_LEAST_SIZE(xChangeKeyboardControlReq);

    vmask = stuff->mask;
    vlist = (XID *) &stuff[1];

    if (client->req_len !=
        (sizeof(xChangeKeyboardControlReq) >> 2) + Ones(vmask))
        return BadLength;

    keyboard = PickKeyboard(client);

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if ((pDev == keyboard ||
             (!IsMaster(pDev) && GetMaster(pDev, MASTER_KEYBOARD) == keyboard))
            && pDev->kbdfeed && pDev->kbdfeed->CtrlProc) {
            ret = XaceHook(XACE_DEVICE_ACCESS, client, pDev, DixManageAccess);
            if (ret != Success)
                return ret;
        }
    }

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if ((pDev == keyboard ||
             (!IsMaster(pDev) && GetMaster(pDev, MASTER_KEYBOARD) == keyboard))
            && pDev->kbdfeed && pDev->kbdfeed->CtrlProc) {
            ret = DoChangeKeyboardControl(client, pDev, vlist, vmask);
            if (ret != Success)
                error = ret;
        }
    }

    return error;
}

int
ProcGetKeyboardControl(ClientPtr client)
{
    int rc, i;
    DeviceIntPtr kbd = PickKeyboard(client);
    KeybdCtrl *ctrl = &kbd->kbdfeed->ctrl;
    xGetKeyboardControlReply rep;

    REQUEST_SIZE_MATCH(xReq);

    rc = XaceHook(XACE_DEVICE_ACCESS, client, kbd, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep = (xGetKeyboardControlReply) {
        .type = X_Reply,
        .globalAutoRepeat = ctrl->autoRepeat,
        .sequenceNumber = client->sequence,
        .length = 5,
        .ledMask = ctrl->leds,
        .keyClickPercent = ctrl->click,
        .bellPercent = ctrl->bell,
        .bellPitch = ctrl->bell_pitch,
        .bellDuration = ctrl->bell_duration
    };
    for (i = 0; i < 32; i++)
        rep.map[i] = ctrl->autoRepeats[i];
    WriteReplyToClient(client, sizeof(xGetKeyboardControlReply), &rep);
    return Success;
}

int
ProcBell(ClientPtr client)
{
    DeviceIntPtr dev, keybd = PickKeyboard(client);
    int base = keybd->kbdfeed->ctrl.bell;
    int newpercent;
    int rc;

    REQUEST(xBellReq);
    REQUEST_SIZE_MATCH(xBellReq);

    if (stuff->percent < -100 || stuff->percent > 100) {
        client->errorValue = stuff->percent;
        return BadValue;
    }

    newpercent = (base * stuff->percent) / 100;
    if (stuff->percent < 0)
        newpercent = base + newpercent;
    else
        newpercent = base - newpercent + stuff->percent;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if ((dev == keybd ||
             (!IsMaster(dev) && GetMaster(dev, MASTER_KEYBOARD) == keybd)) &&
            ((dev->kbdfeed && dev->kbdfeed->BellProc) || dev->xkb_interest)) {

            rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixBellAccess);
            if (rc != Success)
                return rc;
            XkbHandleBell(FALSE, FALSE, dev, newpercent,
                          &dev->kbdfeed->ctrl, 0, None, NULL, client);
        }
    }

    return Success;
}

int
ProcChangePointerControl(ClientPtr client)
{
    DeviceIntPtr dev, mouse = PickPointer(client);
    PtrCtrl ctrl;               /* might get BadValue part way through */
    int rc;

    REQUEST(xChangePointerControlReq);
    REQUEST_SIZE_MATCH(xChangePointerControlReq);

    ctrl = mouse->ptrfeed->ctrl;
    if ((stuff->doAccel != xTrue) && (stuff->doAccel != xFalse)) {
        client->errorValue = stuff->doAccel;
        return BadValue;
    }
    if ((stuff->doThresh != xTrue) && (stuff->doThresh != xFalse)) {
        client->errorValue = stuff->doThresh;
        return BadValue;
    }
    if (stuff->doAccel) {
        if (stuff->accelNum == -1) {
            ctrl.num = defaultPointerControl.num;
        }
        else if (stuff->accelNum < 0) {
            client->errorValue = stuff->accelNum;
            return BadValue;
        }
        else {
            ctrl.num = stuff->accelNum;
        }

        if (stuff->accelDenum == -1) {
            ctrl.den = defaultPointerControl.den;
        }
        else if (stuff->accelDenum <= 0) {
            client->errorValue = stuff->accelDenum;
            return BadValue;
        }
        else {
            ctrl.den = stuff->accelDenum;
        }
    }
    if (stuff->doThresh) {
        if (stuff->threshold == -1) {
            ctrl.threshold = defaultPointerControl.threshold;
        }
        else if (stuff->threshold < 0) {
            client->errorValue = stuff->threshold;
            return BadValue;
        }
        else {
            ctrl.threshold = stuff->threshold;
        }
    }

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if ((dev == mouse ||
             (!IsMaster(dev) && GetMaster(dev, MASTER_POINTER) == mouse)) &&
            dev->ptrfeed) {
            rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixManageAccess);
            if (rc != Success)
                return rc;
        }
    }

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if ((dev == mouse ||
             (!IsMaster(dev) && GetMaster(dev, MASTER_POINTER) == mouse)) &&
            dev->ptrfeed) {
            dev->ptrfeed->ctrl = ctrl;
        }
    }

    return Success;
}

int
ProcGetPointerControl(ClientPtr client)
{
    DeviceIntPtr ptr = PickPointer(client);
    PtrCtrl *ctrl = &ptr->ptrfeed->ctrl;
    xGetPointerControlReply rep;
    int rc;

    REQUEST_SIZE_MATCH(xReq);

    rc = XaceHook(XACE_DEVICE_ACCESS, client, ptr, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep = (xGetPointerControlReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .accelNumerator = ctrl->num,
        .accelDenominator = ctrl->den,
        .threshold = ctrl->threshold
    };
    WriteReplyToClient(client, sizeof(xGenericReply), &rep);
    return Success;
}

void
MaybeStopHint(DeviceIntPtr dev, ClientPtr client)
{
    GrabPtr grab = dev->deviceGrab.grab;

    if ((grab && SameClient(grab, client) &&
         ((grab->eventMask & PointerMotionHintMask) ||
          (grab->ownerEvents &&
           (EventMaskForClient(dev->valuator->motionHintWindow, client) &
            PointerMotionHintMask)))) ||
        (!grab &&
         (EventMaskForClient(dev->valuator->motionHintWindow, client) &
          PointerMotionHintMask)))
        dev->valuator->motionHintWindow = NullWindow;
}

int
ProcGetMotionEvents(ClientPtr client)
{
    WindowPtr pWin;
    xTimecoord *coords = (xTimecoord *) NULL;
    xGetMotionEventsReply rep;
    int i, count, xmin, xmax, ymin, ymax, rc;
    unsigned long nEvents;
    DeviceIntPtr mouse = PickPointer(client);
    TimeStamp start, stop;

    REQUEST(xGetMotionEventsReq);
    REQUEST_SIZE_MATCH(xGetMotionEventsReq);

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    rc = XaceHook(XACE_DEVICE_ACCESS, client, mouse, DixReadAccess);
    if (rc != Success)
        return rc;

    if (mouse->valuator->motionHintWindow)
        MaybeStopHint(mouse, client);
    rep = (xGetMotionEventsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence
    };
    nEvents = 0;
    start = ClientTimeToServerTime(stuff->start);
    stop = ClientTimeToServerTime(stuff->stop);
    if ((CompareTimeStamps(start, stop) != LATER) &&
        (CompareTimeStamps(start, currentTime) != LATER) &&
        mouse->valuator->numMotionEvents) {
        if (CompareTimeStamps(stop, currentTime) == LATER)
            stop = currentTime;
        count = GetMotionHistory(mouse, &coords, start.milliseconds,
                                 stop.milliseconds, pWin->drawable.pScreen,
                                 TRUE);
        xmin = pWin->drawable.x - wBorderWidth(pWin);
        xmax = pWin->drawable.x + (int) pWin->drawable.width +
            wBorderWidth(pWin);
        ymin = pWin->drawable.y - wBorderWidth(pWin);
        ymax = pWin->drawable.y + (int) pWin->drawable.height +
            wBorderWidth(pWin);
        for (i = 0; i < count; i++)
            if ((xmin <= coords[i].x) && (coords[i].x < xmax) &&
                (ymin <= coords[i].y) && (coords[i].y < ymax)) {
                coords[nEvents].time = coords[i].time;
                coords[nEvents].x = coords[i].x - pWin->drawable.x;
                coords[nEvents].y = coords[i].y - pWin->drawable.y;
                nEvents++;
            }
    }
    rep.length = nEvents * bytes_to_int32(sizeof(xTimecoord));
    rep.nEvents = nEvents;
    WriteReplyToClient(client, sizeof(xGetMotionEventsReply), &rep);
    if (nEvents) {
        client->pSwapReplyFunc = (ReplySwapPtr) SwapTimeCoordWrite;
        WriteSwappedDataToClient(client, nEvents * sizeof(xTimecoord),
                                 (char *) coords);
    }
    free(coords);
    return Success;
}

int
ProcQueryKeymap(ClientPtr client)
{
    xQueryKeymapReply rep;
    int rc, i;
    DeviceIntPtr keybd = PickKeyboard(client);
    CARD8 *down = keybd->key->down;

    REQUEST_SIZE_MATCH(xReq);
    rep = (xQueryKeymapReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 2
    };

    rc = XaceHook(XACE_DEVICE_ACCESS, client, keybd, DixReadAccess);
    /* If rc is Success, we're allowed to copy out the keymap.
     * If it's BadAccess, we leave it empty & lie to the client.
     */
    if (rc == Success) {
        for (i = 0; i < 32; i++)
            rep.map[i] = down[i];
    }
    else if (rc != BadAccess)
        return rc;

    WriteReplyToClient(client, sizeof(xQueryKeymapReply), &rep);

    return Success;
}

/**
 * Recalculate the number of buttons for the master device. The number of
 * buttons on the master device is equal to the number of buttons on the
 * slave device with the highest number of buttons.
 */
static void
RecalculateMasterButtons(DeviceIntPtr slave)
{
    DeviceIntPtr dev, master;
    int maxbuttons = 0;

    if (!slave->button || IsMaster(slave))
        return;

    master = GetMaster(slave, MASTER_POINTER);
    if (!master)
        return;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if (IsMaster(dev) ||
            GetMaster(dev, MASTER_ATTACHED) != master || !dev->button)
            continue;

        maxbuttons = max(maxbuttons, dev->button->numButtons);
    }

    if (master->button && master->button->numButtons != maxbuttons) {
        int i;
        DeviceChangedEvent event = {
            .header = ET_Internal,
            .type = ET_DeviceChanged,
            .time = GetTimeInMillis(),
            .deviceid = master->id,
            .flags = DEVCHANGE_POINTER_EVENT | DEVCHANGE_DEVICE_CHANGE,
            .buttons.num_buttons = maxbuttons
        };

        master->button->numButtons = maxbuttons;

        memcpy(&event.buttons.names, master->button->labels, maxbuttons *
               sizeof(Atom));

        if (master->valuator) {
            event.num_valuators = master->valuator->numAxes;
            for (i = 0; i < event.num_valuators; i++) {
                event.valuators[i].min = master->valuator->axes[i].min_value;
                event.valuators[i].max = master->valuator->axes[i].max_value;
                event.valuators[i].resolution =
                    master->valuator->axes[i].resolution;
                event.valuators[i].mode = master->valuator->axes[i].mode;
                event.valuators[i].name = master->valuator->axes[i].label;
            }
        }

        if (master->key) {
            event.keys.min_keycode = master->key->xkbInfo->desc->min_key_code;
            event.keys.max_keycode = master->key->xkbInfo->desc->max_key_code;
        }

        XISendDeviceChangedEvent(master, &event);
    }
}

/**
 * Generate release events for all keys/button currently down on this
 * device.
 */
void
ReleaseButtonsAndKeys(DeviceIntPtr dev)
{
    InternalEvent *eventlist = InitEventList(GetMaximumEventsNum());
    ButtonClassPtr b = dev->button;
    KeyClassPtr k = dev->key;
    int i, j, nevents;

    if (!eventlist)             /* no release events for you */
        return;

    /* Release all buttons */
    for (i = 0; b && i < b->numButtons; i++) {
        if (BitIsOn(b->down, i)) {
            nevents =
                GetPointerEvents(eventlist, dev, ButtonRelease, i, 0, NULL);
            for (j = 0; j < nevents; j++)
                mieqProcessDeviceEvent(dev, &eventlist[j], NULL);
        }
    }

    /* Release all keys */
    for (i = 0; k && i < MAP_LENGTH; i++) {
        if (BitIsOn(k->down, i)) {
            nevents = GetKeyboardEvents(eventlist, dev, KeyRelease, i);
            for (j = 0; j < nevents; j++)
                mieqProcessDeviceEvent(dev, &eventlist[j], NULL);
        }
    }

    FreeEventList(eventlist, GetMaximumEventsNum());
}

/**
 * Attach device 'dev' to device 'master'.
 * Client is set to the client that issued the request, or NULL if it comes
 * from some internal automatic pairing.
 *
 * Master may be NULL to set the device floating.
 *
 * We don't allow multi-layer hierarchies right now. You can't attach a slave
 * to another slave.
 */
int
AttachDevice(ClientPtr client, DeviceIntPtr dev, DeviceIntPtr master)
{
    ScreenPtr screen;

    if (!dev || IsMaster(dev))
        return BadDevice;

    if (master && !IsMaster(master))    /* can't attach to slaves */
        return BadDevice;

    /* set from floating to floating? */
    if (IsFloating(dev) && !master && dev->enabled)
        return Success;

    /* free the existing sprite. */
    if (IsFloating(dev) && dev->spriteInfo->paired == dev) {
        screen = miPointerGetScreen(dev);
        screen->DeviceCursorCleanup(dev, screen);
        free(dev->spriteInfo->sprite);
    }

    dev->master = master;

    /* If device is set to floating, we need to create a sprite for it,
     * otherwise things go bad. However, we don't want to render the cursor,
     * so we reset spriteOwner.
     * Sprite has to be forced to NULL first, otherwise InitializeSprite won't
     * alloc new memory but overwrite the previous one.
     */
    if (!master) {
        WindowPtr currentRoot;

        if (dev->spriteInfo->sprite)
            currentRoot = GetCurrentRootWindow(dev);
        else                    /* new device auto-set to floating */
            currentRoot = screenInfo.screens[0]->root;

        /* we need to init a fake sprite */
        screen = currentRoot->drawable.pScreen;
        screen->DeviceCursorInitialize(dev, screen);
        dev->spriteInfo->sprite = NULL;
        InitializeSprite(dev, currentRoot);
        dev->spriteInfo->spriteOwner = FALSE;
        dev->spriteInfo->paired = dev;
    }
    else {
        dev->spriteInfo->sprite = master->spriteInfo->sprite;
        dev->spriteInfo->paired = master;
        dev->spriteInfo->spriteOwner = FALSE;

        XkbPushLockedStateToSlaves(GetMaster(dev, MASTER_KEYBOARD), 0, 0);
        RecalculateMasterButtons(master);
    }

    /* XXX: in theory, the MD should change back to its old, original
     * classes when the last SD is detached. Thanks to the XTEST devices,
     * we'll always have an SD attached until the MD is removed.
     * So let's not worry about that.
     */

    return Success;
}

/**
 * Return the device paired with the given device or NULL.
 * Returns the device paired with the parent master if the given device is a
 * slave device.
 */
DeviceIntPtr
GetPairedDevice(DeviceIntPtr dev)
{
    if (!IsMaster(dev) && !IsFloating(dev))
        dev = GetMaster(dev, MASTER_ATTACHED);

    return dev->spriteInfo->paired;
}

/**
 * Returns the requested master for this device.
 * The return values are:
 * - MASTER_ATTACHED: the master for this device or NULL for a floating
 *   slave.
 * - MASTER_KEYBOARD: the master keyboard for this device or NULL for a
 *   floating slave
 * - MASTER_POINTER: the master pointer for this device or NULL for a
 *   floating slave
 * - POINTER_OR_FLOAT: the master pointer for this device or the device for
 *   a floating slave
 * - KEYBOARD_OR_FLOAT: the master keyboard for this device or the device for
 *   a floating slave
 *
 * @@param which ::MASTER_KEYBOARD or ::MASTER_POINTER, ::MASTER_ATTACHED,
 * ::POINTER_OR_FLOAT or ::KEYBOARD_OR_FLOAT.
 * @@return The requested master device
 */
DeviceIntPtr
GetMaster(DeviceIntPtr dev, int which)
{
    DeviceIntPtr master;

    if (IsMaster(dev))
        master = dev;
    else {
        master = dev->master;
        if (!master &&
            (which == POINTER_OR_FLOAT || which == KEYBOARD_OR_FLOAT))
            return dev;
    }

    if (master && which != MASTER_ATTACHED) {
        if (which == MASTER_KEYBOARD || which == KEYBOARD_OR_FLOAT) {
            if (master->type != MASTER_KEYBOARD)
                master = GetPairedDevice(master);
        }
        else {
            if (master->type != MASTER_POINTER)
                master = GetPairedDevice(master);
        }
    }

    return master;
}

/**
 * Create a new device pair (== one pointer, one keyboard device).
 * Only allocates the devices, you will need to call ActivateDevice() and
 * EnableDevice() manually.
 * Either a master or a slave device can be created depending on
 * the value for master.
 */
int
AllocDevicePair(ClientPtr client, const char *name,
                DeviceIntPtr *ptr,
                DeviceIntPtr *keybd,
                DeviceProc ptr_proc, DeviceProc keybd_proc, Bool master)
{
    DeviceIntPtr pointer;
    DeviceIntPtr keyboard;
    char *dev_name;

    *ptr = *keybd = NULL;

    XkbInitPrivates();

    pointer = AddInputDevice(client, ptr_proc, TRUE);

    if (!pointer)
        return BadAlloc;

    if (asprintf(&dev_name, "%s pointer", name) == -1) {
        RemoveDevice(pointer, FALSE);

        return BadAlloc;
    }
    pointer->name = dev_name;

    pointer->public.processInputProc = ProcessOtherEvent;
    pointer->public.realInputProc = ProcessOtherEvent;
    XkbSetExtension(pointer, ProcessPointerEvent);
    pointer->deviceGrab.ActivateGrab = ActivatePointerGrab;
    pointer->deviceGrab.DeactivateGrab = DeactivatePointerGrab;
    pointer->coreEvents = TRUE;
    pointer->spriteInfo->spriteOwner = TRUE;

    pointer->lastSlave = NULL;
    pointer->last.slave = NULL;
    pointer->type = (master) ? MASTER_POINTER : SLAVE;

    keyboard = AddInputDevice(client, keybd_proc, TRUE);
    if (!keyboard) {
        RemoveDevice(pointer, FALSE);

        return BadAlloc;
    }

    if (asprintf(&dev_name, "%s keyboard", name) == -1) {
        RemoveDevice(keyboard, FALSE);
        RemoveDevice(pointer, FALSE);

        return BadAlloc;
    }
    keyboard->name = dev_name;

    keyboard->public.processInputProc = ProcessOtherEvent;
    keyboard->public.realInputProc = ProcessOtherEvent;
    XkbSetExtension(keyboard, ProcessKeyboardEvent);
    keyboard->deviceGrab.ActivateGrab = ActivateKeyboardGrab;
    keyboard->deviceGrab.DeactivateGrab = DeactivateKeyboardGrab;
    keyboard->coreEvents = TRUE;
    keyboard->spriteInfo->spriteOwner = FALSE;

    keyboard->lastSlave = NULL;
    keyboard->last.slave = NULL;
    keyboard->type = (master) ? MASTER_KEYBOARD : SLAVE;

    /* The ClassesRec stores the device classes currently not used. */
    if (IsMaster(pointer)) {
        pointer->unused_classes = calloc(1, sizeof(ClassesRec));
        keyboard->unused_classes = calloc(1, sizeof(ClassesRec));
    }

    *ptr = pointer;

    *keybd = keyboard;

    return Success;
}

/**
 * Return Relative or Absolute for the device.
 */
int
valuator_get_mode(DeviceIntPtr dev, int axis)
{
    return (dev->valuator->axes[axis].mode & DeviceMode);
}

/**
 * Set the given mode for the axis. If axis is VALUATOR_MODE_ALL_AXES, then
 * set the mode for all axes.
 */
void
valuator_set_mode(DeviceIntPtr dev, int axis, int mode)
{
    if (axis != VALUATOR_MODE_ALL_AXES)
        dev->valuator->axes[axis].mode = mode;
    else {
        int i;

        for (i = 0; i < dev->valuator->numAxes; i++)
            dev->valuator->axes[i].mode = mode;
    }
}
@


1.21
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d1685 1
a1685 2
    if (rc != Success && rc != MappingSuccess && rc != MappingFailed &&
        rc != MappingBusy)
@


1.20
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d180 2
a181 2
	if (!dev->valuator)
		return BadMatch;
d1475 2
a1476 2
        malloc(sizeof(KeySym) * num_symbols_supported);
    feedc->ctrl.symbols_displayed = malloc(sizeof(KeySym) * max_symbols);
d2524 1
a2524 1
            nevents = GetKeyboardEvents(eventlist, dev, KeyRelease, i, NULL);
@


1.19
log
@Update to xserver 1.16.2
@
text
@d180 3
a1219 57
/* Notably, this function does not expand the destination's keycode range, or
 * notify clients. */
Bool
SetKeySymsMap(KeySymsPtr dst, KeySymsPtr src)
{
    int i, j;
    KeySym *tmp;
    int rowDif = src->minKeyCode - dst->minKeyCode;

    /* if keysym map size changes, grow map first */
    if (src->mapWidth < dst->mapWidth) {
        for (i = src->minKeyCode; i <= src->maxKeyCode; i++) {
#define SI(r, c) (((r - src->minKeyCode) * src->mapWidth) + (c))
#define DI(r, c) (((r - dst->minKeyCode) * dst->mapWidth) + (c))
            for (j = 0; j < src->mapWidth; j++)
                dst->map[DI(i, j)] = src->map[SI(i, j)];
            for (j = src->mapWidth; j < dst->mapWidth; j++)
                dst->map[DI(i, j)] = NoSymbol;
#undef SI
#undef DI
        }
        return TRUE;
    }
    else if (src->mapWidth > dst->mapWidth) {
        i = sizeof(KeySym) * src->mapWidth *
            (dst->maxKeyCode - dst->minKeyCode + 1);
        tmp = calloc(sizeof(KeySym), i);
        if (!tmp)
            return FALSE;

        if (dst->map) {
            for (i = 0; i <= dst->maxKeyCode - dst->minKeyCode; i++)
                memmove(&tmp[i * src->mapWidth], &dst->map[i * dst->mapWidth],
                        dst->mapWidth * sizeof(KeySym));
            free(dst->map);
        }
        dst->mapWidth = src->mapWidth;
        dst->map = tmp;
    }
    else if (!dst->map) {
        i = sizeof(KeySym) * src->mapWidth *
            (dst->maxKeyCode - dst->minKeyCode + 1);
        tmp = calloc(sizeof(KeySym), i);
        if (!tmp)
            return FALSE;

        dst->map = tmp;
        dst->mapWidth = src->mapWidth;
    }

    memmove(&dst->map[rowDif * dst->mapWidth], src->map,
            (src->maxKeyCode - src->minKeyCode + 1) *
            dst->mapWidth * sizeof(KeySym));

    return TRUE;
}

d2206 1
a2206 1
            dev->kbdfeed && dev->kbdfeed->BellProc) {
d2628 1
a2628 1
 * - MASTER_POINTER: the master keyboard for this device or NULL for a
@


1.18
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d419 1
a419 1
    if (!IsMaster(dev))
@


1.17
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d389 1
a389 1
                other = (IsPointerDevice(dev)) ? inputInfo.pointer :
d419 2
d591 1
a591 1
CoreKeyboardBell(int volume, DeviceIntPtr pDev, pointer arg, int something)
d755 1
a755 1
FreeDeviceClass(int type, pointer *class)
d823 1
a823 1
FreeFeedbackClass(int type, pointer *class)
d911 13
a923 13
    FreeDeviceClass(KeyClass, (pointer) &classes->key);
    FreeDeviceClass(ValuatorClass, (pointer) &classes->valuator);
    FreeDeviceClass(XITouchClass, (pointer) &classes->touch);
    FreeDeviceClass(ButtonClass, (pointer) &classes->button);
    FreeDeviceClass(FocusClass, (pointer) &classes->focus);
    FreeDeviceClass(ProximityClass, (pointer) &classes->proximity);

    FreeFeedbackClass(KbdFeedbackClass, (pointer) &classes->kbdfeed);
    FreeFeedbackClass(PtrFeedbackClass, (pointer) &classes->ptrfeed);
    FreeFeedbackClass(IntegerFeedbackClass, (pointer) &classes->intfeed);
    FreeFeedbackClass(StringFeedbackClass, (pointer) &classes->stringfeed);
    FreeFeedbackClass(BellFeedbackClass, (pointer) &classes->bell);
    FreeFeedbackClass(LedFeedbackClass, (pointer) &classes->leds);
d949 3
a951 2
    /* free sprite memory */
    if (IsMaster(dev) && dev->spriteInfo->sprite)
a971 2
    FreeSprite(dev);

a1476 1
    BUG_RETURN_VAL(dev->ptrfeed != NULL, FALSE);
a1519 1
    BUG_RETURN_VAL(dev->stringfeed != NULL, FALSE);
a1555 1
    BUG_RETURN_VAL(dev->bell != NULL, FALSE);
a1576 1
    BUG_RETURN_VAL(dev->leds != NULL, FALSE);
a1598 1
    BUG_RETURN_VAL(dev->intfeed != NULL, FALSE);
d2648 1
d2736 1
d2747 1
a2747 2
    if (asprintf(&pointer->name, "%s pointer", name) == -1) {
        pointer->name = NULL;
d2752 1
d2773 1
a2773 2
    if (asprintf(&keyboard->name, "%s keyboard", name) == -1) {
        keyboard->name = NULL;
d2779 1
@


1.16
log
@Update to xserver 1.14.3
@
text
@d1055 1
d1280 4
d1344 1
a1344 2
    if (!dev)
        return FALSE;
d1453 3
d1475 3
d1519 3
d1556 3
d1578 3
d1601 3
d1624 5
d1649 3
a1651 2
    if (device->touch || !device->valuator)
        return FALSE;
d1654 2
a1655 4
    if (mode != XIDirectTouch && mode != XIDependentTouch)
        return FALSE;
    if (num_axes < 2)
        return FALSE;
d2796 4
a2799 3
    pointer->unused_classes = calloc(1, sizeof(ClassesRec));

    keyboard->unused_classes = calloc(1, sizeof(ClassesRec));
@


1.15
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@a283 1
    dev->deviceGrab.activeGrab = AllocGrab();
d979 2
a980 1
    FreeGrab(dev->deviceGrab.activeGrab);
@


1.14
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d115 2
a116 2
    sx = dev->valuator->axes[0].max_value - dev->valuator->axes[0].min_value;
    sy = dev->valuator->axes[1].max_value - dev->valuator->axes[1].min_value;
d798 1
d1369 1
a1369 1
    if (mode & OutOfProximity)
@


1.13
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d87 1
d96 1
a96 1
DeviceSetTransform(DeviceIntPtr dev, float *transform)
d99 1
d126 1
a126 1
            dev->transform.m[y][x] = *transform++;
d128 1
a128 1
    pixman_f_transform_multiply(&dev->transform, &scale, &dev->transform);
d135 6
a140 1
    pixman_f_transform_multiply(&dev->transform, &dev->transform, &scale);
d154 5
a158 3
        /* Don't allow disabling of VCP/VCK */
        if ((dev == inputInfo.pointer ||dev ==
             inputInfo.keyboard) &&!(*(CARD8 *) prop->data))
a188 3
 * If the client is set, the request to pair comes from some client. In this
 * case, we need to check for access. If the client is NULL, it's from an
 * internal automatic pairing, we must always permit this.
d191 1
a191 1
PairDevices(ClientPtr client, DeviceIntPtr ptr, DeviceIntPtr kbd)
d257 11
a267 7
    dev =
        _dixAllocateObjectWithPrivates(sizeof(DeviceIntRec) +
                                       sizeof(SpriteInfoRec),
                                       sizeof(DeviceIntRec) +
                                       sizeof(SpriteInfoRec),
                                       offsetof(DeviceIntRec, devPrivates),
                                       PRIVATE_DEVICE);
d292 1
a292 1
    dev->spriteInfo = (SpriteInfoPtr) & dev[1];
d297 1
d317 4
d336 7
a342 2
    DeviceIntRec dummyDev;
    devicePresenceNotify ev;
a343 6
    memset(&dummyDev, 0, sizeof(DeviceIntRec));
    ev.type = DevicePresenceNotify;
    ev.time = currentTime.milliseconds;
    ev.devchange = type;
    ev.deviceid = deviceid;
    dummyDev.id = XIAllDevices;
d381 5
a385 4
            else if ((other = NextFreePointerDevice()) == NULL) {
                ErrorF("[dix] cannot find pointer to pair with. "
                       "This is a bug.\n");
                return FALSE;
a386 2
            else
                PairDevices(NULL, other, dev);
d422 3
d428 1
d447 3
d455 5
d477 3
a479 7
        for (other = inputInfo.devices; other; other = other->next) {
            if (other->spriteInfo->paired == dev) {
                ErrorF("[dix] cannot disable device, still paired. "
                       "This is a bug. \n");
                return FALSE;
            }
        }
d482 3
d488 2
d521 26
d960 1
a960 1
    classes = (ClassesPtr) & dev->key;
d969 1
a969 6
    if (DevHasCursor(dev) && dev->spriteInfo->sprite) {
        if (dev->spriteInfo->sprite->current)
            FreeCursor(dev->spriteInfo->sprite->current, None);
        free(dev->spriteInfo->sprite->spriteTrace);
        free(dev->spriteInfo->sprite);
    }
d987 2
a988 1
    dixFreeObjectWithPrivates(dev, PRIVATE_DEVICE);
d1059 19
d1393 1
a1393 2
    {PtrAccelNoOp, NULL, NULL, NULL, NULL}
    ,
d1395 2
a1396 4
     InitPredictableAccelerationScheme, AccelerationDefaultCleanup}
    ,
    {PtrAccelLightweight, acceleratePointerLightweight, NULL, NULL, NULL}
    ,
d1433 1
a1433 2
                                                        &pointerAccelerationScheme
                                                        [i])) {
d1706 5
a1710 3
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d1738 4
a1741 4
    memset(&rep, 0, sizeof(xGetModifierMappingReply));
    rep.type = X_Reply;
    rep.numKeyPerModifier = max_keys_per_mod;
    rep.sequenceNumber = client->sequence;
d1743 2
a1744 1
    rep.length = max_keys_per_mod << 1;
d1747 1
a1747 1
    (void) WriteToClient(client, max_keys_per_mod * 8, (char *) modkeymap);
d1828 7
a1834 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.success = MappingSuccess;
d1903 7
a1909 6
    memset(&rep, 0, sizeof(xGetKeyboardMappingReply));
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.keySymsPerKeyCode = syms->mapWidth;
    /* length is a count of 4 byte quantities and KeySyms are 4 bytes */
    rep.length = syms->mapWidth * stuff->count;
d1931 1
d1940 7
a1946 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.nElts = (butc) ? butc->numButtons : 0;
    rep.length = ((unsigned) rep.nElts + (4 - 1)) / 4;
d1949 1
a1949 1
        WriteToClient(client, (int) rep.nElts, (char *) &butc->map[1]);
d2195 11
a2205 9
    rep.type = X_Reply;
    rep.length = 5;
    rep.sequenceNumber = client->sequence;
    rep.globalAutoRepeat = ctrl->autoRepeat;
    rep.keyClickPercent = ctrl->click;
    rep.bellPercent = ctrl->bell;
    rep.bellPitch = ctrl->bell_pitch;
    rep.bellDuration = ctrl->bell_duration;
    rep.ledMask = ctrl->leds;
d2340 8
a2347 6
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.threshold = ctrl->threshold;
    rep.accelNumerator = ctrl->num;
    rep.accelDenominator = ctrl->den;
d2391 4
a2394 2
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
d2442 5
a2446 3
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 2;
d2449 8
a2456 1
    if (rc != Success && rc != BadAccess)
a2458 6
    for (i = 0; i < 32; i++)
        rep.map[i] = down[i];

    if (rc == BadAccess)
        memset(rep.map, 0, 32);

d2492 8
a2499 3
        DeviceChangedEvent event;

        memset(&event, 0, sizeof(event));
a2502 6
        event.header = ET_Internal;
        event.type = ET_DeviceChanged;
        event.time = GetTimeInMillis();
        event.deviceid = master->id;
        event.flags = DEVCHANGE_POINTER_EVENT | DEVCHANGE_DEVICE_CHANGE;
        event.buttons.num_buttons = maxbuttons;
d2714 2
@


1.12
log
@Bugfix Update to xserver 1.11.3
@
text
@a24 1

a46 2


d73 1
d82 1
a82 1
#include "xiquerydevice.h" /* for SizeDeviceClasses */
d84 1
a84 1
#include "enterleave.h" /* for EnterWindow() */
d86 1
a86 1
#include "xichangehierarchy.h" /* For XISendDeviceHierarchyEvent */
d122 2
a123 2
    for (y=0; y<3; y++)
        for (x=0; x<3; x++)
d143 1
a143 2
    if (property == XIGetKnownProperty(XI_PROP_ENABLED))
    {
d148 2
a149 2
        if ((dev == inputInfo.pointer || dev == inputInfo.keyboard) &&
            !(*(CARD8*)prop->data))
d152 2
a153 3
        if (!checkonly)
        {
            if ((*((CARD8*)prop->data)) && !dev->enabled)
d155 1
a155 1
            else if (!(*((CARD8*)prop->data)) && dev->enabled)
d158 3
a160 3
    } else if (property == XIGetKnownProperty(XI_PROP_TRANSFORM))
    {
        float *f = (float*)prop->data;
d167 1
a167 1
        for (i=0; i<9; i++)
d197 1
a197 2
    if (kbd->spriteInfo->spriteOwner)
    {
a208 1

d216 1
d219 1
a219 2
                dev->spriteInfo->spriteOwner &&
                !dev->spriteInfo->paired)
d234 1
a234 1
    DeviceIntPtr dev, *prev; /* not a typo */
d242 1
a242 1
    memset(devind, 0, sizeof(char)*MAXDEVICES);
d244 1
a244 1
	devind[devtmp->id]++;
d246 2
a247 3
	devind[devtmp->id]++;
    for (devid = 2; devid < MAXDEVICES && devind[devid]; devid++)
	;
d250 8
a257 4
	return (DeviceIntPtr)NULL;
    dev =  _dixAllocateObjectWithPrivates(sizeof(DeviceIntRec) + sizeof(SpriteInfoRec),
					  sizeof(DeviceIntRec) + sizeof(SpriteInfoRec),
					  offsetof(DeviceIntRec, devPrivates), PRIVATE_DEVICE);
d259 4
a262 1
	return (DeviceIntPtr)NULL;
d274 2
d282 1
a282 1
    dev->spriteInfo = (SpriteInfoPtr)&dev[1];
d287 2
a288 2
	free(dev);
	return NULL;
d293 1
a293 2
    for (prev = &inputInfo.off_devices; *prev; prev = &(*prev)->next)
        ;
d299 3
a301 3
                           XA_INTEGER, 8, PropModeReplace, 1, &enabled,
                           FALSE);
    XISetDevicePropertyDeletable(dev, XIGetKnownProperty(XI_PROP_ENABLED), FALSE);
d331 1
a331 1
                          (xEvent*)&ev, 1);
d354 1
a354 1
    int flags[MAXDEVICES] = {0};
d357 1
a357 3
	 *prev && (*prev != dev);
	 prev = &(*prev)->next)
	;
d359 2
a360 4
    if (!dev->spriteInfo->sprite)
    {
        if (IsMaster(dev))
        {
d362 1
a362 2
            if (dev->spriteInfo->spriteOwner)
            {
d364 1
a364 1
                                                 /* mode doesn't matter */
d367 1
a367 2
            else if ((other = NextFreePointerDevice()) == NULL)
            {
d371 2
a372 1
            } else
d374 2
a375 2
        } else
        {
d380 1
a380 1
                other = NULL; /* auto-float non-core devices */
d386 1
a386 1
	((ret = (*dev->deviceProc)(dev, DEVICE_ON)) != Success)) {
d388 1
a388 1
	return FALSE;
d393 1
a393 2
    for (prev = &inputInfo.devices; *prev; prev = &(*prev)->next)
        ;
d399 1
a399 2
                           XA_INTEGER, 8, PropModeReplace, 1, &enabled,
                           TRUE);
d402 1
a402 2
    if (sendevent)
    {
d428 1
a428 1
    int flags[MAXDEVICES] = {0};
d431 1
a431 3
	 *prev && (*prev != dev);
	 prev = &(*prev)->next)
	;
d433 1
a433 1
	return FALSE;
d436 3
a438 6
    if (IsMaster(dev))
    {
        for (other = inputInfo.devices; other; other = other->next)
        {
            if (!IsMaster(other) && GetMaster(other, MASTER_ATTACHED) == dev)
            {
d444 5
a448 7
    else
    {
        for (other = inputInfo.devices; other; other = other->next)
        {
	    if (IsMaster(other) && other->lastSlave == dev)
		other->lastSlave = NULL;
	}
d451 3
a453 6
    if (IsMaster(dev) && dev->spriteInfo->sprite)
    {
        for (other = inputInfo.devices; other; other = other->next)
        {
            if (other->spriteInfo->paired == dev)
            {
d455 1
a455 1
                        "This is a bug. \n");
d461 1
a461 1
    (void)(*dev->deviceProc)(dev, DEVICE_OFF);
d467 1
a467 2
    for (other = inputInfo.devices; other; other = other->next)
    {
d482 1
a482 2
                           XA_INTEGER, 8, PropModeReplace, 1, &enabled,
                           TRUE);
d485 1
a485 2
    if (sendevent)
    {
d525 2
a526 3
    if (sendevent)
    {
        int flags[MAXDEVICES] = {0};
d546 1
a546 1
CoreKeyboardCtl(DeviceIntPtr pDev, KeybdCtrl *ctrl)
d561 1
a561 2
                                      CoreKeyboardCtl))
        {
d589 3
a591 2
    Atom btn_labels[NBUTTONS] = {0};
    Atom axes_labels[NAXES] = {0};
d598 16
a613 16
	btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
	btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
	btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
	btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
	btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
	btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
	btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
	/* don't know about the rest */

	axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
	axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);

        if (!InitPointerDeviceStruct((DevicePtr)pDev, map, NBUTTONS, btn_labels,
                                (PtrCtrlProcPtr)NoopDDA,
                                GetMotionHistorySize(), NAXES, axes_labels))
        {
d616 1
a616 1
            return BadAlloc; /* IPDS only fails on allocs */
d618 5
a622 4
        pDev->valuator->axisVal[0] = screenInfo.screens[0]->width / 2;
        pDev->last.valuators[0] = pDev->valuator->axisVal[0];
        pDev->valuator->axisVal[1] = screenInfo.screens[0]->height / 2;
        pDev->last.valuators[1] = pDev->valuator->axisVal[1];
d651 2
a652 3
                        CorePointerProc, CoreKeyboardProc,
                        TRUE) != Success)
        FatalError("Failed to allocate core devices");
d656 1
a656 1
        FatalError("Failed to activate core devices.");
d659 1
a659 1
        FatalError("Failed to enable core devices.");
d688 1
a688 2
    for (dev = inputInfo.off_devices; dev; dev = next)
    {
d690 3
a692 3
	next = dev->next;
	if (dev->inited && dev->startup)
	    EnableDevice(dev, TRUE);
d707 2
a708 1
    switch(type)
d710 54
a763 39
        case KeyClass:
            {
                KeyClassPtr* k = (KeyClassPtr*)class;
                if ((*k)->xkbInfo)
                {
                    XkbFreeInfo((*k)->xkbInfo);
                    (*k)->xkbInfo = NULL;
                }
                free((*k));
                break;
            }
        case ButtonClass:
            {
                ButtonClassPtr *b = (ButtonClassPtr*)class;
                free((*b)->xkb_acts);
                free((*b));
                break;
            }
        case ValuatorClass:
            {
                ValuatorClassPtr *v = (ValuatorClassPtr*)class;

                free((*v)->motion);
                free((*v));
                break;
            }
        case FocusClass:
            {
                FocusClassPtr *f = (FocusClassPtr*)class;
                free((*f)->trace);
                free((*f));
                break;
            }
        case ProximityClass:
            {
                ProximityClassPtr *p = (ProximityClassPtr*)class;
                free((*p));
                break;
            }
d774 2
a775 1
    switch(type)
d777 70
a846 71
        case KbdFeedbackClass:
            {
                KbdFeedbackPtr *kbdfeed = (KbdFeedbackPtr*)class;
                KbdFeedbackPtr k, knext;
                for (k = (*kbdfeed); k; k = knext) {
                    knext = k->next;
                    if (k->xkb_sli)
                        XkbFreeSrvLedInfo(k->xkb_sli);
                    free(k);
                }
                break;
            }
        case PtrFeedbackClass:
            {
                PtrFeedbackPtr *ptrfeed = (PtrFeedbackPtr*)class;
                PtrFeedbackPtr p, pnext;

                for (p = (*ptrfeed); p; p = pnext) {
                    pnext = p->next;
                    free(p);
                }
                break;
            }
        case IntegerFeedbackClass:
            {
                IntegerFeedbackPtr *intfeed = (IntegerFeedbackPtr*)class;
                IntegerFeedbackPtr i, inext;

                for (i = (*intfeed); i; i = inext) {
                    inext = i->next;
                    free(i);
                }
                break;
            }
        case StringFeedbackClass:
            {
                StringFeedbackPtr *stringfeed = (StringFeedbackPtr*)class;
                StringFeedbackPtr s, snext;

                for (s = (*stringfeed); s; s = snext) {
                    snext = s->next;
                    free(s->ctrl.symbols_supported);
                    free(s->ctrl.symbols_displayed);
                    free(s);
                }
                break;
            }
        case BellFeedbackClass:
            {
                BellFeedbackPtr *bell = (BellFeedbackPtr*)class;
                BellFeedbackPtr b, bnext;

                for (b = (*bell); b; b = bnext) {
                    bnext = b->next;
                    free(b);
                }
                break;
            }
        case LedFeedbackClass:
            {
                LedFeedbackPtr *leds = (LedFeedbackPtr*)class;
                LedFeedbackPtr l, lnext;

                for (l = (*leds); l; l = lnext) {
                    lnext = l->next;
                    if (l->xkb_sli)
                        XkbFreeSrvLedInfo(l->xkb_sli);
                    free(l);
                }
                break;
            }
d857 13
a869 12
    FreeDeviceClass(KeyClass, (pointer)&classes->key);
    FreeDeviceClass(ValuatorClass, (pointer)&classes->valuator);
    FreeDeviceClass(ButtonClass, (pointer)&classes->button);
    FreeDeviceClass(FocusClass, (pointer)&classes->focus);
    FreeDeviceClass(ProximityClass, (pointer)&classes->proximity);

    FreeFeedbackClass(KbdFeedbackClass, (pointer)&classes->kbdfeed);
    FreeFeedbackClass(PtrFeedbackClass, (pointer)&classes->ptrfeed);
    FreeFeedbackClass(IntegerFeedbackClass, (pointer)&classes->intfeed);
    FreeFeedbackClass(StringFeedbackClass, (pointer)&classes->stringfeed);
    FreeFeedbackClass(BellFeedbackClass, (pointer)&classes->bell);
    FreeFeedbackClass(LedFeedbackClass, (pointer)&classes->leds);
d893 1
a893 1
	(void)(*dev->deviceProc)(dev, DEVICE_CLOSE);
d900 2
a901 2
    if(dev->valuator && dev->valuator->accelScheme.AccelCleanupProc)
	dev->valuator->accelScheme.AccelCleanupProc(dev);
d904 1
a904 1
	XkbRemoveResourceClient((DevicePtr)dev,dev->xkb_interest->resource);
d908 1
a908 1
    classes = (ClassesPtr)&dev->key;
d911 1
a911 2
    if (IsMaster(dev))
    {
d914 1
a914 1
	free(classes);
d918 2
a919 2
	if (dev->spriteInfo->sprite->current)
	    FreeCursor(dev->spriteInfo->sprite->current, None);
d925 2
a926 4
    for (j = 0; j < currentMaxClients; j++)
    {
        if (clients[j] && clients[j]->clientPtr == dev)
        {
d932 1
d935 4
d947 1
a947 1
void
d962 1
a962 2
    while (dev != NULL)
    {
d988 1
a988 2
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
d997 1
d1004 1
d1040 1
a1040 1
    DeviceIntPtr prev,tmp,next;
d1045 1
a1045 1
    int flags[MAXDEVICES] = {0};
d1055 1
a1055 2
    if (initialized)
    {
d1065 7
a1071 2
	next = tmp->next;
	if (tmp == dev) {
d1073 4
a1076 9
	    if (prev==NULL)
		inputInfo.devices = next;
	    else
		prev->next = next;

	    flags[tmp->id] = IsMaster(tmp) ? XIMasterRemoved : XISlaveRemoved;
	    CloseDevice(tmp);
	    ret = Success;
	}
d1081 9
a1089 9
	next = tmp->next;
	if (tmp == dev) {
	    flags[tmp->id] = IsMaster(tmp) ? XIMasterRemoved : XISlaveRemoved;
	    CloseDevice(tmp);

	    if (prev == NULL)
		inputInfo.off_devices = next;
	    else
		prev->next = next;
d1092 1
a1092 1
	}
d1118 1
d1121 1
a1121 1
    for (dev=inputInfo.devices; dev; dev=dev->next) {
d1125 1
a1125 1
    for (dev=inputInfo.off_devices; dev; dev=dev->next) {
d1127 1
a1127 1
	    goto found;
d1131 1
a1131 1
found:
d1134 1
a1134 1
	*pDev = dev;
d1142 2
a1143 2
	*minCode = inputInfo.keyboard->key->xkbInfo->desc->min_key_code;
	*maxCode = inputInfo.keyboard->key->xkbInfo->desc->max_key_code;
d1161 4
a1164 4
	    for (j = 0; j < src->mapWidth; j++)
		dst->map[DI(i, j)] = src->map[SI(i, j)];
	    for (j = src->mapWidth; j < dst->mapWidth; j++)
		dst->map[DI(i, j)] = NoSymbol;
d1167 2
a1168 2
	}
	return TRUE;
d1172 1
a1172 1
             (dst->maxKeyCode - dst->minKeyCode + 1);
d1178 1
a1178 1
            for (i = 0; i <= dst->maxKeyCode-dst->minKeyCode; i++)
d1188 1
a1188 1
             (dst->maxKeyCode - dst->minKeyCode + 1);
d1205 1
a1205 1
InitButtonClassDeviceStruct(DeviceIntPtr dev, int numButtons, Atom* labels,
d1213 1
a1213 1
	return FALSE;
d1217 1
a1217 1
	butc->map[i] = map[i];
d1238 1
d1240 4
a1243 1
    union align_u { ValuatorClassRec valc; double d; } *align;
d1246 2
a1247 1
    size = sizeof(union align_u) + numAxes * (sizeof(double) + sizeof(AxisInfo));
d1258 2
a1259 2
    v->axisVal = (double*)(align + 1);
    v->axes = (AxisInfoPtr)(v->axisVal + numAxes);
d1274 1
a1274 2
    if (numAxes > MAX_VALUATORS)
    {
d1285 6
d1295 2
d1308 4
a1311 4
    for (i=0; i<numAxes; i++) {
        InitValuatorAxisStruct(dev, i, labels[i], NO_AXIS_LIMITS, NO_AXIS_LIMITS,
                               0, 0, 0, mode);
	valc->axisVal[i]=0;
d1316 1
a1316 1
    if (IsMaster(dev) || /* do not accelerate master or xtest devices */
d1318 1
a1318 1
	InitPointerAccelerationScheme(dev, PtrAccelNoOp);
d1320 1
a1320 1
	InitPointerAccelerationScheme(dev, PtrAccelDefault);
d1326 2
a1327 1
    {PtrAccelNoOp, NULL, NULL, NULL, NULL},
d1329 5
a1333 3
        InitPredictableAccelerationScheme, AccelerationDefaultCleanup},
    {PtrAccelLightweight, acceleratePointerLightweight, NULL, NULL, NULL},
    {-1, NULL, NULL, NULL, NULL} /* terminator */
d1341 1
a1341 2
InitPointerAccelerationScheme(DeviceIntPtr dev,
                              int scheme)
d1355 1
a1355 1
        if(pointerAccelerationScheme[x].number == scheme){
d1369 2
a1370 1
                                            &pointerAccelerationScheme[i])) {
d1373 2
a1374 1
    } else {
d1387 1
a1387 1
	return FALSE;
d1391 1
a1391 1
    focc->trace = (WindowPtr *)NULL;
d1406 1
a1406 1
	return FALSE;
d1410 1
a1410 1
    if ( (feedc->next = dev->ptrfeed) )
d1413 1
a1413 1
    (*controlProc)(dev, &feedc->ctrl);
a1416 1

d1418 2
a1419 1
	DEFAULT_LEDS, DEFAULT_LEDS_MASK, 0};
d1422 5
a1426 4
	DEFAULT_BELL,
	DEFAULT_BELL_PITCH,
	DEFAULT_BELL_DURATION,
	0};
d1429 6
a1434 5
	DEFAULT_INT_RESOLUTION,
	DEFAULT_INT_MIN_VALUE,
	DEFAULT_INT_MAX_VALUE,
	DEFAULT_INT_DISPLAYED,
	0};
d1437 4
a1440 3
InitStringFeedbackClassDeviceStruct (
      DeviceIntPtr dev, StringCtrlProcPtr controlProc,
      int max_symbols, int num_symbols_supported, KeySym *symbols)
d1447 1
a1447 1
	return FALSE;
d1452 13
a1464 13
    feedc->ctrl.symbols_supported = malloc(sizeof (KeySym) * num_symbols_supported);
    feedc->ctrl.symbols_displayed = malloc(sizeof (KeySym) * max_symbols);
    if (!feedc->ctrl.symbols_supported || !feedc->ctrl.symbols_displayed)
    {
	free(feedc->ctrl.symbols_supported);
	free(feedc->ctrl.symbols_displayed);
	free(feedc);
	return FALSE;
    }
    for (i=0; i<num_symbols_supported; i++)
	*(feedc->ctrl.symbols_supported+i) = *symbols++;
    for (i=0; i<max_symbols; i++)
	*(feedc->ctrl.symbols_displayed+i) = (KeySym) 0;
d1466 2
a1467 2
    if ( (feedc->next = dev->stringfeed) )
	feedc->ctrl.id = dev->stringfeed->ctrl.id + 1;
d1469 1
a1469 1
    (*controlProc)(dev, &feedc->ctrl);
d1474 2
a1475 2
InitBellFeedbackClassDeviceStruct (DeviceIntPtr dev, BellProcPtr bellProc,
                                   BellCtrlProcPtr controlProc)
d1481 1
a1481 1
	return FALSE;
d1486 2
a1487 2
    if ( (feedc->next = dev->bell) )
	feedc->ctrl.id = dev->bell->ctrl.id + 1;
d1489 1
a1489 1
    (*controlProc)(dev, &feedc->ctrl);
d1494 1
a1494 1
InitLedFeedbackClassDeviceStruct (DeviceIntPtr dev, LedCtrlProcPtr controlProc)
d1500 1
a1500 1
	return FALSE;
d1504 3
a1506 3
    if ( (feedc->next = dev->leds) )
	feedc->ctrl.id = dev->leds->ctrl.id + 1;
    feedc->xkb_sli= NULL;
d1508 1
a1508 1
    (*controlProc)(dev, &feedc->ctrl);
d1513 2
a1514 1
InitIntegerFeedbackClassDeviceStruct (DeviceIntPtr dev, IntegerCtrlProcPtr controlProc)
d1520 1
a1520 1
	return FALSE;
d1524 2
a1525 2
    if ( (feedc->next = dev->intfeed) )
	feedc->ctrl.id = dev->intfeed->ctrl.id + 1;
d1527 1
a1527 1
    (*controlProc)(dev, &feedc->ctrl);
d1532 75
a1606 10
InitPointerDeviceStruct(DevicePtr device, CARD8 *map, int numButtons, Atom* btn_labels,
                        PtrCtrlProcPtr controlProc, int numMotionEvents,
                        int numAxes, Atom *axes_labels)
{
    DeviceIntPtr dev = (DeviceIntPtr)device;

    return(InitButtonClassDeviceStruct(dev, numButtons, btn_labels, map) &&
	   InitValuatorClassDeviceStruct(dev, numAxes, axes_labels,
					 numMotionEvents, Relative) &&
	   InitPtrFeedbackClassDeviceStruct(dev, controlProc));
d1616 1
a1616 1
BadDeviceMap(BYTE *buff, int length, unsigned low, unsigned high, XID *errval)
d1621 6
a1626 8
	if (buff[i])		       /* only check non-zero elements */
	{
	    if ((low > buff[i]) || (high < buff[i]))
	    {
		*errval = buff[i];
		return TRUE;
	    }
	}
d1635 1
d1640 2
a1641 2
                bytes_to_int32(sizeof(xSetModifierMappingReq))))
	return BadLength;
d1647 1
a1647 1
    rc = change_modmap(client, PickKeyboard(client), (KeyCode *)&stuff[1],
d1653 1
a1653 1
	return rc;
d1667 1
d1681 1
a1681 1
    (void)WriteToClient(client, max_keys_per_mod * 8, (char *) modkeymap);
d1696 1
d1701 1
a1701 1
            return BadLength;
d1706 3
a1708 3
	(stuff->firstKeyCode > pDev->key->xkbInfo->desc->max_key_code)) {
	    client->errorValue = stuff->firstKeyCode;
	    return BadValue;
d1711 2
a1712 2
    if (((unsigned)(stuff->firstKeyCode + stuff->keyCodes - 1) >
          pDev->key->xkbInfo->desc->max_key_code) ||
d1714 2
a1715 2
	    client->errorValue = stuff->keySymsPerKeyCode;
	    return BadValue;
d1755 1
d1760 2
a1761 2
            bytes_to_int32(sizeof(xSetPointerMappingReq) + stuff->nElts))
	return BadLength;
d1766 1
a1766 1
    map = (BYTE *)&stuff[1];
d1775 2
a1776 2
	client->errorValue = stuff->nElts;
	return BadValue;
d1810 1
d1816 1
a1816 1
	return rc;
d1822 2
a1823 2
	client->errorValue = stuff->firstKeyCode;
	return BadValue;
d1826 1
a1826 1
	client->errorValue = stuff->count;
d1856 1
d1862 1
d1867 1
a1867 1
	return rc;
d1872 1
a1872 1
    rep.length = ((unsigned)rep.nElts + (4-1))/4;
d1875 1
a1875 1
        WriteToClient(client, (int)rep.nElts, (char *)&butc->map[1]);
d1883 1
d1885 1
a1885 1
	ctrl->leds |= ((Leds)1 << (led - 1));
d1887 1
a1887 1
	ctrl->leds &= ~((Leds)1 << (led - 1));
d1891 2
a1892 2
Ones(unsigned long mask)             /* HACKMEM 169 */
{
d1895 2
a1896 2
    y = (mask >> 1) &033333333333;
    y = mask - y - ((y >>1) & 033333333333);
d1901 2
a1902 2
DoChangeKeyboardControl (ClientPtr client, DeviceIntPtr keybd, XID *vlist,
                         BITS32 vmask)
d1915 83
a1997 83
	index2 = (BITS32) lowbit (vmask);
	vmask &= ~index2;
	switch (index2) {
	case KBKeyClickPercent:
	    t = (INT8)*vlist;
	    vlist++;
	    if (t == -1) {
		t = defaultKeyboardControl.click;
            }
	    else if (t < 0 || t > 100) {
		client->errorValue = t;
		return BadValue;
	    }
	    ctrl.click = t;
	    break;
	case KBBellPercent:
	    t = (INT8)*vlist;
	    vlist++;
	    if (t == -1) {
		t = defaultKeyboardControl.bell;
            }
	    else if (t < 0 || t > 100) {
		client->errorValue = t;
		return BadValue;
	    }
	    ctrl.bell = t;
	    break;
	case KBBellPitch:
	    t = (INT16)*vlist;
	    vlist++;
	    if (t == -1) {
		t = defaultKeyboardControl.bell_pitch;
            }
	    else if (t < 0) {
		client->errorValue = t;
		return BadValue;
	    }
	    ctrl.bell_pitch = t;
	    break;
	case KBBellDuration:
	    t = (INT16)*vlist;
	    vlist++;
	    if (t == -1)
		t = defaultKeyboardControl.bell_duration;
	    else if (t < 0) {
		client->errorValue = t;
		return BadValue;
	    }
	    ctrl.bell_duration = t;
	    break;
	case KBLed:
	    led = (CARD8)*vlist;
	    vlist++;
	    if (led < 1 || led > 32) {
		client->errorValue = led;
		return BadValue;
	    }
	    if (!(mask & KBLedMode))
		return BadMatch;
	    break;
	case KBLedMode:
	    t = (CARD8)*vlist;
	    vlist++;
	    if (t == LedModeOff) {
		if (led == DO_ALL)
		    ctrl.leds = 0x0;
		else
		    ctrl.leds &= ~(((Leds)(1)) << (led - 1));
	    }
	    else if (t == LedModeOn) {
		if (led == DO_ALL)
		    ctrl.leds = ~0L;
		else
		    ctrl.leds |= (((Leds)(1)) << (led - 1));
	    }
	    else {
		client->errorValue = t;
		return BadValue;
	    }

            XkbSetCauseCoreReq(&cause,X_ChangeKeyboardControl,client);
            XkbSetIndicators(keybd,((led == DO_ALL) ? ~0L : (1L<<(led-1))),
 			     ctrl.leds, &cause);
d2000 17
a2016 17
	    break;
	case KBKey:
	    key = (KeyCode)*vlist;
	    vlist++;
	    if ((KeyCode)key < keybd->key->xkbInfo->desc->min_key_code ||
		(KeyCode)key > keybd->key->xkbInfo->desc->max_key_code) {
		client->errorValue = key;
		return BadValue;
	    }
	    if (!(mask & KBAutoRepeatMode))
		return BadMatch;
	    break;
	case KBAutoRepeatMode:
	    i = (key >> 3);
	    mask = (1 << (key & 7));
	    t = (CARD8)*vlist;
	    vlist++;
d2018 30
a2047 30
                XkbDisableComputedAutoRepeats(keybd,key);
	    if (t == AutoRepeatModeOff) {
		if (key == DO_ALL)
		    ctrl.autoRepeat = FALSE;
		else
		    ctrl.autoRepeats[i] &= ~mask;
	    }
	    else if (t == AutoRepeatModeOn) {
		if (key == DO_ALL)
		    ctrl.autoRepeat = TRUE;
		else
		    ctrl.autoRepeats[i] |= mask;
	    }
	    else if (t == AutoRepeatModeDefault) {
		if (key == DO_ALL)
		    ctrl.autoRepeat = defaultKeyboardControl.autoRepeat;
		else
		    ctrl.autoRepeats[i] =
			    (ctrl.autoRepeats[i] & ~mask) |
			    (defaultKeyboardControl.autoRepeats[i] & mask);
	    }
	    else {
		client->errorValue = t;
		return BadValue;
	    }
	    break;
	default:
	    client->errorValue = mask;
	    return BadValue;
	}
d2052 1
a2052 1
    /* value are linked	*/
d2064 1
a2064 1
ProcChangeKeyboardControl (ClientPtr client)
d2070 1
d2076 1
a2076 1
    vlist = (XID *)&stuff[1];
d2078 3
a2080 2
    if (client->req_len != (sizeof(xChangeKeyboardControlReq)>>2)+Ones(vmask))
	return BadLength;
d2086 2
a2087 2
	     (!IsMaster(pDev) && GetMaster(pDev, MASTER_KEYBOARD) == keyboard))
	    && pDev->kbdfeed && pDev->kbdfeed->CtrlProc) {
d2089 1
a2089 1
	    if (ret != Success)
d2096 2
a2097 2
	     (!IsMaster(pDev) && GetMaster(pDev, MASTER_KEYBOARD) == keyboard))
	    && pDev->kbdfeed && pDev->kbdfeed->CtrlProc) {
d2108 1
a2108 1
ProcGetKeyboardControl (ClientPtr client)
d2114 1
d2119 1
a2119 1
	return rc;
d2131 1
a2131 1
	rep.map[i] = ctrl->autoRepeats[i];
d2143 1
d2148 2
a2149 2
	client->errorValue = stuff->percent;
	return BadValue;
d2156 1
a2156 1
	newpercent = base - newpercent + stuff->percent;
d2160 1
a2160 1
	     (!IsMaster(dev) && GetMaster(dev, MASTER_KEYBOARD) == keybd)) &&
d2163 3
a2165 3
	    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixBellAccess);
	    if (rc != Success)
		return rc;
d2178 1
a2178 1
    PtrCtrl ctrl;		/* might get BadValue part way through */
d2180 1
d2186 2
a2187 2
	client->errorValue = stuff->doAccel;
	return BadValue;
d2190 2
a2191 2
	client->errorValue = stuff->doThresh;
	return BadValue;
d2194 2
a2195 2
	if (stuff->accelNum == -1) {
	    ctrl.num = defaultPointerControl.num;
d2197 5
a2201 5
	else if (stuff->accelNum < 0) {
	    client->errorValue = stuff->accelNum;
	    return BadValue;
	}
	else {
d2205 2
a2206 2
	if (stuff->accelDenum == -1) {
	    ctrl.den = defaultPointerControl.den;
d2208 5
a2212 5
	else if (stuff->accelDenum <= 0) {
	    client->errorValue = stuff->accelDenum;
	    return BadValue;
	}
	else {
d2217 6
a2222 2
	if (stuff->threshold == -1) {
	    ctrl.threshold = defaultPointerControl.threshold;
d2224 1
a2224 5
	else if (stuff->threshold < 0) {
	    client->errorValue = stuff->threshold;
	    return BadValue;
	}
	else {
d2231 1
a2231 1
	     (!IsMaster(dev) && GetMaster(dev, MASTER_POINTER) == mouse)) &&
d2233 4
a2236 4
	    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixManageAccess);
	    if (rc != Success)
		return rc;
	}
d2241 1
a2241 1
	     (!IsMaster(dev) && GetMaster(dev, MASTER_POINTER) == mouse)) &&
d2257 1
d2262 1
a2262 1
	return rc;
d2280 8
a2287 8
	 ((grab->eventMask & PointerMotionHintMask) ||
	  (grab->ownerEvents &&
	   (EventMaskForClient(dev->valuator->motionHintWindow, client) &
	    PointerMotionHintMask)))) ||
	(!grab &&
	 (EventMaskForClient(dev->valuator->motionHintWindow, client) &
	  PointerMotionHintMask)))
	dev->valuator->motionHintWindow = NullWindow;
d2294 1
a2294 1
    xTimecoord * coords = (xTimecoord *) NULL;
d2300 1
d2306 1
a2306 1
	return rc;
d2309 1
a2309 1
	return rc;
d2312 1
a2312 1
	MaybeStopHint(mouse, client);
d2319 6
a2324 7
	(CompareTimeStamps(start, currentTime) != LATER) &&
	mouse->valuator->numMotionEvents)
    {
	if (CompareTimeStamps(stop, currentTime) == LATER)
	    stop = currentTime;
	count = GetMotionHistory(mouse, &coords, start.milliseconds,
				 stop.milliseconds, pWin->drawable.pScreen,
d2326 14
a2339 15
	xmin = pWin->drawable.x - wBorderWidth (pWin);
	xmax = pWin->drawable.x + (int)pWin->drawable.width +
		wBorderWidth (pWin);
	ymin = pWin->drawable.y - wBorderWidth (pWin);
	ymax = pWin->drawable.y + (int)pWin->drawable.height +
		wBorderWidth (pWin);
	for (i = 0; i < count; i++)
	    if ((xmin <= coords[i].x) && (coords[i].x < xmax) &&
		    (ymin <= coords[i].y) && (coords[i].y < ymax))
	    {
		coords[nEvents].time = coords[i].time;
		coords[nEvents].x = coords[i].x - pWin->drawable.x;
		coords[nEvents].y = coords[i].y - pWin->drawable.y;
		nEvents++;
	    }
d2344 4
a2347 5
    if (nEvents)
    {
	client->pSwapReplyFunc = (ReplySwapPtr) SwapTimeCoordWrite;
	WriteSwappedDataToClient(client, nEvents * sizeof(xTimecoord),
				 (char *)coords);
d2368 1
a2368 1
	return rc;
d2370 2
a2371 2
    for (i = 0; i<32; i++)
	rep.map[i] = down[i];
d2374 1
a2374 1
	memset(rep.map, 0, 32);
d2378 1
a2378 1
   return Success;
a2380 1

d2399 1
a2399 2
    for (dev = inputInfo.devices; dev; dev = dev->next)
    {
d2401 1
a2401 2
            GetMaster(dev, MASTER_ATTACHED) != master ||
            !dev->button)
d2407 1
a2407 2
    if (master->button && master->button->numButtons != maxbuttons)
    {
d2422 1
a2422 1
                sizeof(Atom));
d2424 1
a2424 2
        if (master->valuator)
        {
d2426 1
a2426 2
            for (i = 0; i < event.num_valuators; i++)
            {
d2429 2
a2430 1
                event.valuators[i].resolution = master->valuator->axes[i].resolution;
d2436 1
a2436 2
        if (master->key)
        {
d2441 1
a2441 1
        XISendDeviceChangedEvent(master, master, &event);
d2452 4
a2455 4
    InternalEvent*      eventlist = InitEventList(GetMaximumEventsNum());
    ButtonClassPtr      b = dev->button;
    KeyClassPtr         k = dev->key;
    int                 i, j, nevents;
d2457 1
a2457 1
    if (!eventlist) /* no release events for you */
d2461 4
a2464 5
    for (i = 0; b && i < b->numButtons; i++)
    {
        if (BitIsOn(b->down, i))
        {
            nevents = GetPointerEvents(eventlist, dev, ButtonRelease, i, 0, NULL);
d2471 2
a2472 4
    for (i = 0; k && i < MAP_LENGTH; i++)
    {
        if (BitIsOn(k->down, i))
        {
d2496 1
a2496 1
    DeviceIntPtr oldmaster;
d2500 1
a2500 1
    if (master && !IsMaster(master)) /* can't attach to slaves */
d2508 1
a2508 2
    if (IsFloating(dev) && dev->spriteInfo->paired == dev)
    {
a2513 1
    oldmaster = GetMaster(dev, MASTER_ATTACHED);
d2522 1
a2522 2
    if (!master)
    {
d2527 1
a2527 1
        else /* new device auto-set to floating */
d2537 2
a2538 2
    } else
    {
a2568 1

d2570 12
a2581 5
 * Returns the right master for the type of event needed. If the event is a
 * keyboard event.
 * This function may be called with a master device as argument. If so, the
 * returned master is either the device itself or the paired master device.
 * If dev is a floating slave device, NULL is returned.
d2583 3
a2585 4
 * @@type ::MASTER_KEYBOARD or ::MASTER_POINTER or ::MASTER_ATTACHED
 * @@return The requested master device. In the case of MASTER_ATTACHED, this
 * is the directly attached master to this device, regardless of the type.
 * Otherwise, it is either the master keyboard or pointer for this device.
d2594 1
a2594 1
    else
d2596 4
d2601 2
a2602 4
    if (master && which != MASTER_ATTACHED)
    {
        if (which == MASTER_KEYBOARD)
        {
d2605 2
a2606 2
        } else
        {
d2623 4
a2626 6
AllocDevicePair (ClientPtr client, char* name,
                 DeviceIntPtr* ptr,
                 DeviceIntPtr* keybd,
                 DeviceProc ptr_proc,
                 DeviceProc keybd_proc,
                 Bool master)
d2634 1
d2641 1
d2658 1
a2658 2
    if (!keyboard)
    {
d2660 1
d2668 1
d2686 1
d2690 1
d2699 2
a2700 1
int valuator_get_mode(DeviceIntPtr dev, int axis)
d2709 2
a2710 1
void valuator_set_mode(DeviceIntPtr dev, int axis, int mode)
d2716 1
@


1.11
log
@Update to xserver 1.11.2
@
text
@d985 2
d1009 2
@


1.10
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d264 2
a265 2
    dev->public.processInputProc = (ProcessInputProc)NoopDDA;
    dev->public.realInputProc = (ProcessInputProc)NoopDDA;
d275 2
d449 1
a449 1
            if (other->u.master == dev)
d460 2
a461 2
	    if (IsMaster(other) && other->u.lastSlave == dev)
		other->u.lastSlave = NULL;
d941 2
d992 2
a993 2
        if (!IsMaster(dev) && dev->u.master)
            dev->u.master = NULL;
a1112 12
void
RegisterPointerDevice(DeviceIntPtr device)
{
    RegisterOtherDevice(device);
}

void
RegisterKeyboardDevice(DeviceIntPtr device)
{
    RegisterOtherDevice(device);
}

d1224 34
d1276 1
a1276 3
    valc = (ValuatorClassPtr)calloc(1, sizeof(ValuatorClassRec) +
				    numAxes * sizeof(AxisInfo) +
				    numAxes * sizeof(double));
d1278 1
a1278 1
	return FALSE;
d1287 4
a1290 4
    valc->numAxes = numAxes;
    valc->mode = mode;
    valc->axes = (AxisInfoPtr)(valc + 1);
    valc->axisVal = (double *)(valc->axes + numAxes);
d1297 1
a1297 1
                               0, 0, 0);
d1313 5
a1317 4
    {PtrAccelNoOp,        NULL, NULL, NULL},
    {PtrAccelPredictable, acceleratePointerPredictable, NULL, AccelerationDefaultCleanup},
    {PtrAccelLightweight, acceleratePointerLightweight, NULL, NULL},
    {-1, NULL, NULL, NULL} /* terminator */
a1328 1
    void* data = NULL;
d1333 2
a1334 2
    if(!val)
	return FALSE;
d1336 1
a1336 1
    if(IsMaster(dev) && scheme != PtrAccelNoOp)
d1339 1
a1339 1
    for(x = 0; pointerAccelerationScheme[x].number >= 0; x++) {
d1346 1
a1346 1
    if(-1 == i)
d1352 4
a1355 11
    /* init scheme-specific data */
    switch(scheme){
        case PtrAccelPredictable:
        {
            DeviceVelocityPtr s;
            s = malloc(sizeof(DeviceVelocityRec));
            if(!s)
        	return FALSE;
            InitVelocityData(s);
            data = s;
            break;
d1357 2
a1358 15
        default:
            break;
    }

    val->accelScheme = pointerAccelerationScheme[i];
    val->accelScheme.accelData = data;

    /* post-init scheme */
    switch(scheme){
        case PtrAccelPredictable:
            InitializePredictableAccelerationProperties(dev);
            break;

        default:
            break;
a1359 34

    return TRUE;
}

Bool
InitAbsoluteClassDeviceStruct(DeviceIntPtr dev)
{
    AbsoluteClassPtr abs;

    abs = malloc(sizeof(AbsoluteClassRec));
    if (!abs)
        return FALSE;

    /* we don't do anything sensible with these, but should */
    abs->min_x = NO_AXIS_LIMITS;
    abs->min_y = NO_AXIS_LIMITS;
    abs->max_x = NO_AXIS_LIMITS;
    abs->max_y = NO_AXIS_LIMITS;
    abs->flip_x = 0;
    abs->flip_y = 0;
    abs->rotation = 0;
    abs->button_threshold = 0;

    abs->offset_x = 0;
    abs->offset_y = 0;
    abs->width = NO_AXIS_LIMITS;
    abs->height = NO_AXIS_LIMITS;
    abs->following = 0;
    abs->screen = 0;

    abs->sourceid = dev->id;

    dev->absolute = abs;

d1644 1
a1644 1
        if (IsMaster(tmp) || tmp->u.master != pDev)
d1991 3
a1993 2
        if ((pDev == keyboard || (!IsMaster(pDev) && pDev->u.master == keyboard)) &&
            pDev->kbdfeed && pDev->kbdfeed->CtrlProc) {
d2001 3
a2003 2
        if ((pDev == keyboard || (!IsMaster(pDev) && pDev->u.master == keyboard)) &&
            pDev->kbdfeed && pDev->kbdfeed->CtrlProc) {
d2063 2
a2064 1
        if ((dev == keybd || (!IsMaster(dev) && dev->u.master == keybd)) &&
d2133 2
a2134 1
        if ((dev == mouse || (!IsMaster(dev) && dev->u.master == mouse)) &&
d2143 2
a2144 1
        if ((dev == mouse || (!IsMaster(dev) && dev->u.master == mouse)) &&
d2307 1
a2307 1
            dev->u.master != master ||
d2340 1
a2340 2
                /* This should, eventually, be a per-axis mode */
                event.valuators[i].mode = master->valuator->mode;
d2356 40
d2417 1
a2417 1
    if (!dev->u.master && !master && dev->enabled)
d2421 1
a2421 1
    if (!dev->u.master && dev->spriteInfo->paired == dev)
d2428 2
a2429 2
    oldmaster = dev->u.master;
    dev->u.master = master;
d2442 1
a2442 1
            currentRoot = dev->spriteInfo->sprite->spriteTrace[0];
d2479 2
a2480 2
    if (!IsMaster(dev) && dev->u.master)
        dev = dev->u.master;
d2493 4
a2496 1
 * @@type ::MASTER_KEYBOARD or ::MASTER_POINTER
d2506 1
a2506 1
        master = dev->u.master;
d2508 1
a2508 1
    if (master)
a2540 1
    size_t len;
d2547 6
a2552 3
    len = strlen(name) + strlen(" pointer") + 1;
    pointer->name = calloc(len,  sizeof(char));
    snprintf(pointer->name, len, "%s pointer", name);
d2562 1
a2562 1
    pointer->u.lastSlave = NULL;
d2573 6
a2578 3
    len = strlen(name) + strlen(" keyboard") + 1;
    keyboard->name = calloc(len, sizeof(char));
    snprintf(keyboard->name, len, "%s keyboard", name);
d2588 1
a2588 1
    keyboard->u.lastSlave = NULL;
d2602 22
@


1.9
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d80 2
d94 1
a94 5
static int CoreDevicePrivateKeyIndex;
DevPrivateKey CoreDevicePrivateKey = &CoreDevicePrivateKeyIndex;
/* Used to store classes currently not in use by an MD */
static int UnusedClassesPrivateKeyIndex;
DevPrivateKey UnusedClassesPrivateKey = &UnusedClassesPrivateKeyIndex;
d96 21
d118 19
a136 1
static void RecalculateMasterButtons(DeviceIntPtr slave);
d162 15
d203 1
a203 1
        xfree(kbd->spriteInfo->sprite);
d245 1
d258 3
a260 1
    dev =  xcalloc(sizeof(DeviceIntRec) + sizeof(SpriteInfoRec), 1);
d283 1
a283 1
	xfree(dev);
d299 11
d365 1
a365 1
                InitializeSprite(dev, WindowTable[0]);
d367 1
a367 1
                EnterWindow(dev, WindowTable[0], NotifyAncestor);
d737 1
a737 1
                xfree((*k));
d743 2
a744 3
                if ((*b)->xkb_acts)
                    xfree((*b)->xkb_acts);
                xfree((*b));
d751 2
a752 3
                if ((*v)->motion)
                    xfree((*v)->motion);
                xfree((*v));
d758 2
a759 2
                xfree((*f)->trace);
                xfree((*f));
d765 1
a765 1
                xfree((*p));
d788 1
a788 1
                    xfree(k);
d799 1
a799 1
                    xfree(p);
d810 1
a810 1
                    xfree(i);
d821 3
a823 3
                    xfree(s->ctrl.symbols_supported);
                    xfree(s->ctrl.symbols_displayed);
                    xfree(s);
d834 1
a834 1
                    xfree(b);
d847 1
a847 1
                    xfree(l);
d909 1
a909 1
    xfree(dev->name);
d916 1
a916 1
        classes = dixLookupPrivate(&dev->devPrivates, UnusedClassesPrivateKey);
d918 1
d924 2
a925 2
        xfree(dev->spriteInfo->sprite->spriteTrace);
        xfree(dev->spriteInfo->sprite);
d938 2
a939 3
    xfree(dev->deviceGrab.sync.event);
    dixFreePrivates(dev->devPrivates);
    xfree(dev);
d1180 1
a1180 1
        tmp = xcalloc(sizeof(KeySym), i);
d1188 1
a1188 1
            xfree(dst->map);
d1196 1
a1196 1
        tmp = xcalloc(sizeof(KeySym), i);
d1218 1
a1218 1
    butc = xcalloc(1, sizeof(ButtonClassRec));
d1242 1
a1242 1
    if (numAxes >= MAX_VALUATORS)
d1250 1
a1250 1
    valc = (ValuatorClassPtr)xcalloc(1, sizeof(ValuatorClassRec) +
d1333 1
a1333 1
            s = xalloc(sizeof(DeviceVelocityRec));
d1365 1
a1365 1
    abs = xalloc(sizeof(AbsoluteClassRec));
d1398 1
a1398 1
    focc = xalloc(sizeof(FocusClassRec));
d1417 1
a1417 1
    feedc = xalloc(sizeof(PtrFeedbackClassRec));
d1455 1
a1455 1
    feedc = xalloc(sizeof(StringFeedbackClassRec));
d1462 2
a1463 2
    feedc->ctrl.symbols_supported = xalloc (sizeof (KeySym) * num_symbols_supported);
    feedc->ctrl.symbols_displayed = xalloc (sizeof (KeySym) * max_symbols);
d1466 3
a1468 5
	if (feedc->ctrl.symbols_supported)
	    xfree(feedc->ctrl.symbols_supported);
	if (feedc->ctrl.symbols_displayed)
	    xfree(feedc->ctrl.symbols_displayed);
	xfree(feedc);
d1489 1
a1489 1
    feedc = xalloc(sizeof(BellFeedbackClassRec));
d1508 1
a1508 1
    feedc = xalloc(sizeof(LedFeedbackClassRec));
d1527 1
a1527 1
    feedc = xalloc(sizeof(IntegerFeedbackClassRec));
d1603 1
a1603 1
    return client->noClientException;
d1627 1
a1627 1
    xfree(modkeymap);
d1629 1
a1629 1
    return client->noClientException;
d1687 1
a1687 1
    return client->noClientException;
d1787 2
a1788 2
    xfree(syms->map);
    xfree(syms);
d1790 1
a1790 1
    return client->noClientException;
a2113 3
    if (!mouse->ptrfeed->CtrlProc)
        return BadDevice;

d2117 1
a2117 1
	return(BadValue);
d2121 1
a2121 1
	return(BadValue);
d2161 1
a2161 1
            dev->ptrfeed && dev->ptrfeed->CtrlProc) {
d2170 1
a2170 1
            dev->ptrfeed && dev->ptrfeed->CtrlProc) {
a2171 1
            (*dev->ptrfeed->CtrlProc)(dev, &mouse->ptrfeed->ctrl);
d2278 1
a2278 2
    if (coords)
	xfree(coords);
d2339 1
a2339 1
    if (master->button->numButtons != maxbuttons)
d2350 1
a2350 1
        event.time = CurrentTime;
d2411 1
a2411 1
        xfree(dev->spriteInfo->sprite);
d2430 1
a2430 1
            currentRoot = WindowTable[0];
a2523 1
    ClassesPtr classes;
a2530 1

d2532 1
a2532 1
    pointer->name = xcalloc(len, sizeof(char));
d2555 1
a2555 1
    keyboard->name = xcalloc(len, sizeof(char));
a2569 1

d2571 2
a2572 4
    classes = xcalloc(1, sizeof(ClassesRec));
    dixSetPrivate(&pointer->devPrivates, UnusedClassesPrivateKey, classes);
    classes = xcalloc(1, sizeof(ClassesRec));
    dixSetPrivate(&keyboard->devPrivates, UnusedClassesPrivateKey, classes);
@


1.8
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a56 2
#define NEED_EVENTS
#define NEED_REPLIES
d66 1
a66 6
#ifndef XKB_IN_SERVER
#define	XKB_IN_SERVER
#endif
#ifdef XKB
#include <xkbsrv.h>
#endif
d75 1
d78 1
d82 1
a82 1
#include "listdev.h" /* for CopySwapXXXClass */
d86 1
d94 1
a94 1
/* Used to sture classes currently not in use by an MD */
d99 2
d121 1
a121 1
                EnableDevice(dev);
d123 1
a123 1
                DisableDevice(dev);
d143 1
a143 1
    if (!ptr->isMaster || !kbd->isMaster)
d171 1
a171 1
        if (dev->isMaster &&
d194 1
a194 1
    /* Find next available id */
d200 1
a200 1
    for (devid = 0; devid < MAXDEVICES && devind[devid]; devid++)
d249 16
d275 1
d279 1
a279 1
EnableDevice(DeviceIntPtr dev)
a282 1
    DeviceIntRec dummyDev;
a283 5
    devicePresenceNotify ev;
    int namelen = 0; /* dummy */
    int evsize  = sizeof(xEvent);
    int listlen;
    EventListPtr evlist;
d285 1
d294 1
a294 1
        if (dev->isMaster)
d312 5
a316 2
            other = (IsPointerDevice(dev)) ? inputInfo.pointer :
                inputInfo.keyboard;
a320 14
    /* Before actually enabling the device, we need to make sure the event
     * list's events have enough memory for a ClassesChangedEvent from the
     * device
     */

    SizeDeviceInfo(dev, &namelen, &evsize);

    listlen = GetEventList(&evlist);
    OsBlockSignals();
    SetMinimumEventSize(evlist, listlen, evsize);
    mieqResizeEvents(evsize);
    OsReleaseSignals();


d339 8
a346 7
    ev.type = DevicePresenceNotify;
    ev.time = currentTime.milliseconds;
    ev.devchange = DeviceEnabled;
    ev.deviceid = dev->id;
    dummyDev.id = MAXDEVICES;
    SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                          (xEvent *) &ev, 1);
d359 1
d363 1
a363 1
DisableDevice(DeviceIntPtr dev)
a365 2
    DeviceIntRec dummyDev;
    devicePresenceNotify ev;
d367 1
d377 1
a377 1
    if (dev->isMaster)
d382 1
d384 2
d392 1
a392 1
	    if (other->isMaster && other->u.lastSlave == dev)
d397 1
a397 1
    if (dev->isMaster && dev->spriteInfo->sprite)
d412 14
d435 8
a442 7
    ev.type = DevicePresenceNotify;
    ev.time = currentTime.milliseconds;
    ev.devchange = DeviceDisabled;
    ev.deviceid = dev->id;
    dummyDev.id = MAXDEVICES;
    SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                          (xEvent *) &ev, 1);
d454 1
d458 1
a458 1
ActivateDevice(DeviceIntPtr dev)
a460 2
    devicePresenceNotify ev;
    DeviceIntRec dummyDev;
d472 11
a482 13
    if (dev->isMaster && dev->spriteInfo->spriteOwner)
        pScreen->DeviceCursorInitialize(dev, pScreen);

    ev.type = DevicePresenceNotify;
    ev.time = currentTime.milliseconds;
    ev.devchange = DeviceAdded;
    ev.deviceid = dev->id;

    memset(&dummyDev, 0, sizeof(DeviceIntRec));
    dummyDev.id = MAXDEVICES;
    SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                          (xEvent *) &ev, 1);

d507 1
a507 1
static int
a509 6
    CARD8 *modMap;
    KeySymsRec keySyms;
#ifdef XKB
    XkbComponentNamesRec names;
#endif
    ClassesPtr classes;
d513 2
a514 1
        if (!(classes = xcalloc(1, sizeof(ClassesRec))))
d516 3
a518 2
            ErrorF("[dix] Could not allocate device classes.\n");
            return BadAlloc;
d520 1
d522 3
a524 37
        keySyms.minKeyCode = 8;
        keySyms.maxKeyCode = 255;
        keySyms.mapWidth = 4;
        keySyms.map = (KeySym *)xcalloc(sizeof(KeySym),
                                        (keySyms.maxKeyCode -
                                         keySyms.minKeyCode + 1) *
                                        keySyms.mapWidth);
        if (!keySyms.map) {
            ErrorF("[dix] Couldn't allocate core keymap\n");
            xfree(classes);
            return BadAlloc;
        }

        modMap = xcalloc(1, MAP_LENGTH);
        if (!modMap) {
            ErrorF("[dix] Couldn't allocate core modifier map\n");
            xfree(classes);
            return BadAlloc;
        }

#ifdef XKB
        if (!noXkbExtension) {
            bzero(&names, sizeof(names));
            XkbInitKeyboardDeviceStruct(pDev, &names, &keySyms, modMap,
                                        CoreKeyboardBell, CoreKeyboardCtl);
        }
        else
#endif
        {
            /* FIXME Our keymap here isn't exactly useful. */
            InitKeyboardDeviceStruct((DevicePtr)pDev, &keySyms, modMap,
                                     CoreKeyboardBell, CoreKeyboardCtl);
        }

        xfree(keySyms.map);
        xfree(modMap);
        break;
d527 2
a528 1
        break;
d530 1
a530 4
    default:
        break;
    }
    return Success;
a534 3
 *
 * Aside from initialisation, it backs up the original device classes into the
 * devicePrivates. This only needs to be done for master devices.
d536 1
a536 1
static int
d539 3
a541 1
    BYTE map[33];
d543 2
a544 1
    ClassesPtr classes;
d548 2
a549 2
        if (!(classes = xcalloc(1, sizeof(ClassesRec))))
            return BadAlloc;
d551 13
a563 3
        for (i = 1; i <= 32; i++)
            map[i] = i;
        InitPointerDeviceStruct((DevicePtr)pDev, map, 32,
d565 6
a570 1
                                GetMotionHistorySize(), 2);
d585 3
d601 4
a604 3
    if (AllocMasterDevice(serverClient, "Virtual core",
                          &inputInfo.pointer,
                          &inputInfo.keyboard) != Success)
d607 6
a612 4
    ActivateDevice(inputInfo.pointer);
    ActivateDevice(inputInfo.keyboard);
    EnableDevice(inputInfo.pointer);
    EnableDevice(inputInfo.keyboard);
d614 1
d630 1
a630 1
InitAndStartDevices()
d637 1
a637 1
            ActivateDevice(dev);
d646 1
a646 1
	    (void)EnableDevice(dev);
a665 1
#ifdef XKB
a670 3
#endif
                xfree((*k)->curKeySyms.map);
                xfree((*k)->modifierKeyMap);
a676 1
#ifdef XKB
a678 1
#endif
a685 1
                /* Counterpart to 'biggest hack ever' in init. */
a721 1
#ifdef XKB
a723 1
#endif
a780 1
#ifdef XKB
a782 1
#endif
d835 1
a835 1
    if (dev->isMaster && dev->spriteInfo->sprite)
d842 3
d850 1
a850 1
    if (dev->isMaster)
a855 6

#ifdef XKB
    while (dev->xkb_interest)
	XkbRemoveResourceClient((DevicePtr)dev,dev->xkb_interest->resource);
#endif

d857 2
d879 30
d915 1
a915 1
    DeviceIntPtr dev, next;
d924 1
a924 1
        if (!dev->isMaster && dev->u.master)
d928 5
a932 10
    for (dev = inputInfo.devices; dev; dev = next)
    {
	next = dev->next;
        DeleteInputDeviceRequest(dev);
    }
    for (dev = inputInfo.off_devices; dev; dev = next)
    {
	next = dev->next;
        DeleteInputDeviceRequest(dev);
    }
a937 1
#ifdef XKB
a938 1
#endif
d946 1
a946 1
UndisplayDevices()
d965 2
d969 1
a969 1
RemoveDevice(DeviceIntPtr dev)
a972 2
    devicePresenceNotify ev;
    DeviceIntRec dummyDev;
d976 1
d984 6
a989 2
    if (DevHasCursor(dev))
        screen->DisplayCursor(dev, screen, NullCursor);
d991 3
a993 2
    deviceid = dev->id;
    DisableDevice(dev);
d1005 1
d1015 1
d1029 3
a1031 7
        ev.type = DevicePresenceNotify;
        ev.time = currentTime.milliseconds;
        ev.devchange = DeviceRemoved;
        ev.deviceid = deviceid;
        dummyDev.id = MAXDEVICES;
        SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                              (xEvent *) &ev, 1);
d1065 1
a1065 1
        if (dev->id == (CARD8)id)
d1069 1
a1069 1
        if (dev->id == (CARD8)id)
d1085 2
a1086 2
	*minCode = inputInfo.keyboard->key->curKeySyms.minKeyCode;
	*maxCode = inputInfo.keyboard->key->curKeySyms.maxKeyCode;
d1090 2
d1096 1
d1100 4
a1103 6
    if (src->mapWidth < dst->mapWidth)
    {
        for (i = src->minKeyCode; i <= src->maxKeyCode; i++)
	{
#define SI(r, c) (((r-src->minKeyCode)*src->mapWidth) + (c))
#define DI(r, c) (((r - dst->minKeyCode)*dst->mapWidth) + (c))
d1113 8
a1120 10
    else if (src->mapWidth > dst->mapWidth)
    {
        KeySym *map;
	int bytes = sizeof(KeySym) * src->mapWidth *
		    (dst->maxKeyCode - dst->minKeyCode + 1);
        map = (KeySym *)xcalloc(1, bytes);
	if (!map)
	    return FALSE;
        if (dst->map)
	{
d1122 4
a1125 16
		memmove((char *)&map[i*src->mapWidth],
			(char *)&dst->map[i*dst->mapWidth],
		      dst->mapWidth * sizeof(KeySym));
	    xfree(dst->map);
	}
	dst->mapWidth = src->mapWidth;
	dst->map = map;
    } else if (!dst->map)
    {
        KeySym *map;
	int bytes = sizeof(KeySym) * src->mapWidth *
		    (dst->maxKeyCode - dst->minKeyCode + 1);
        map = (KeySym *)xcalloc(1, bytes);
        if (!map)
            return FALSE;
        dst->map = map;
d1127 1
d1129 6
a1134 6
    memmove((char *)&dst->map[rowDif * dst->mapWidth],
	    (char *)src->map,
	  (int)(src->maxKeyCode - src->minKeyCode + 1) *
	  dst->mapWidth * sizeof(KeySym));
    return TRUE;
}
d1136 2
a1137 20
static Bool
InitModMap(KeyClassPtr keyc)
{
    int i, j;
    CARD8 keysPerModifier[8];
    CARD8 mask;

    keyc->maxKeysPerModifier = 0;
    for (i = 0; i < 8; i++)
	keysPerModifier[i] = 0;
    for (i = 8; i < MAP_LENGTH; i++)
    {
	for (j = 0, mask = 1; j < 8; j++, mask <<= 1)
	{
	    if (mask & keyc->modifierMap[i])
	    {
		if (++keysPerModifier[j] > keyc->maxKeysPerModifier)
		    keyc->maxKeysPerModifier = keysPerModifier[j];
	    }
	}
a1138 19
    keyc->modifierKeyMap = xcalloc(8, keyc->maxKeysPerModifier);
    if (!keyc->modifierKeyMap && keyc->maxKeysPerModifier)
	return (FALSE);
    for (i = 0; i < 8; i++)
	keysPerModifier[i] = 0;
    for (i = 8; i < MAP_LENGTH; i++)
    {
	for (j = 0, mask = 1; j < 8; j++, mask <<= 1)
	{
	    if (mask & keyc->modifierMap[i])
	    {
		keyc->modifierKeyMap[(j*keyc->maxKeysPerModifier) +
				     keysPerModifier[j]] = i;
		keysPerModifier[j]++;
	    }
	}
    }
    return TRUE;
}
d1140 3
a1142 4
_X_EXPORT Bool
InitKeyClassDeviceStruct(DeviceIntPtr dev, KeySymsPtr pKeySyms, CARD8 pModifiers[])
{
    KeyClassPtr keyc;
a1143 19
    keyc = xcalloc(1, sizeof(KeyClassRec));
    if (!keyc)
	return FALSE;
    keyc->curKeySyms.minKeyCode = pKeySyms->minKeyCode;
    keyc->curKeySyms.maxKeyCode = pKeySyms->maxKeyCode;
    if (pModifiers)
	memmove((char *)keyc->modifierMap, (char *)pModifiers, MAP_LENGTH);
    if (!SetKeySymsMap(&keyc->curKeySyms, pKeySyms) || !InitModMap(keyc))
    {
	xfree(keyc->curKeySyms.map);
	xfree(keyc->modifierKeyMap);
	xfree(keyc);
	return FALSE;
    }
    dev->key = keyc;
#ifdef XKB
    dev->key->xkbInfo= NULL;
    if (!noXkbExtension) XkbInitDevice(dev);
#endif
d1147 2
a1148 2
_X_EXPORT Bool
InitButtonClassDeviceStruct(DeviceIntPtr dev, int numButtons,
d1158 1
d1161 3
d1168 2
a1169 2
_X_EXPORT Bool
InitValuatorClassDeviceStruct(DeviceIntPtr dev, int numAxes,
d1178 8
d1188 1
a1188 1
				    numAxes * sizeof(unsigned int));
d1192 1
d1202 1
a1202 1
    valc->axisVal = (int *)(valc->axes + numAxes);
d1208 1
a1208 1
        InitValuatorAxisStruct(dev, i, NO_AXIS_LIMITS, NO_AXIS_LIMITS,
d1214 3
a1216 1
    if(dev->isMaster) /* master devs do not accelerate */
d1235 1
a1235 1
_X_EXPORT Bool
d1248 2
a1249 2
    if(dev->isMaster && (scheme != PtrAccelNoOp))
        scheme = PtrAccelNoOp; /* no accel for master devices */
d1261 2
d1269 1
a1269 1
            s = (DeviceVelocityPtr)xalloc(sizeof(DeviceVelocityRec));
d1283 10
d1296 1
a1296 1
_X_EXPORT Bool
d1301 1
a1301 1
    abs = (AbsoluteClassPtr)xalloc(sizeof(AbsoluteClassRec));
d1322 2
d1329 1
a1329 1
_X_EXPORT Bool
d1334 1
a1334 1
    focc = (FocusClassPtr)xalloc(sizeof(FocusClassRec));
d1343 1
d1348 1
a1348 29
_X_EXPORT Bool
InitKbdFeedbackClassDeviceStruct(DeviceIntPtr dev, BellProcPtr bellProc,
                                 KbdCtrlProcPtr controlProc)
{
    KbdFeedbackPtr feedc;

    feedc = (KbdFeedbackPtr)xalloc(sizeof(KbdFeedbackClassRec));
    if (!feedc)
	return FALSE;
    feedc->BellProc = bellProc;
    feedc->CtrlProc = controlProc;
#ifdef XKB
    defaultKeyboardControl.autoRepeat = TRUE;
#endif
    feedc->ctrl = defaultKeyboardControl;
    feedc->ctrl.id = 0;
    if ((feedc->next = dev->kbdfeed) != 0)
	feedc->ctrl.id = dev->kbdfeed->ctrl.id + 1;
    dev->kbdfeed = feedc;
#ifdef XKB
    feedc->xkb_sli= NULL;
    if (!noXkbExtension)
	XkbFinishDeviceInit(dev);
#endif
    (*dev->kbdfeed->CtrlProc)(dev,&dev->kbdfeed->ctrl);
    return TRUE;
}

_X_EXPORT Bool
d1353 1
a1353 1
    feedc = (PtrFeedbackPtr)xalloc(sizeof(PtrFeedbackClassRec));
d1383 1
a1383 1
_X_EXPORT Bool
d1391 1
a1391 1
    feedc = (StringFeedbackPtr)xalloc(sizeof(StringFeedbackClassRec));
d1398 2
a1399 4
    feedc->ctrl.symbols_supported = (KeySym *)
	xalloc (sizeof (KeySym) * num_symbols_supported);
    feedc->ctrl.symbols_displayed = (KeySym *)
	xalloc (sizeof (KeySym) * max_symbols);
d1412 1
a1412 1
	*(feedc->ctrl.symbols_displayed+i) = (KeySym) NULL;
d1421 1
a1421 1
_X_EXPORT Bool
d1427 1
a1427 1
    feedc = (BellFeedbackPtr)xalloc(sizeof(BellFeedbackClassRec));
d1441 1
a1441 1
_X_EXPORT Bool
d1446 1
a1446 1
    feedc = (LedFeedbackPtr)xalloc(sizeof(LedFeedbackClassRec));
a1453 1
#ifdef XKB
a1454 1
#endif
d1460 1
a1460 1
_X_EXPORT Bool
d1465 1
a1465 1
    feedc = (IntegerFeedbackPtr)xalloc(sizeof(IntegerFeedbackClassRec));
d1478 2
a1479 2
_X_EXPORT Bool
InitPointerDeviceStruct(DevicePtr device, CARD8 *map, int numButtons,
d1481 1
a1481 1
                        int numAxes)
d1485 3
a1487 3
    return(InitButtonClassDeviceStruct(dev, numButtons, map) &&
	   InitValuatorClassDeviceStruct(dev, numAxes,
					 numMotionEvents, 0) &&
a1490 51
_X_EXPORT Bool
InitKeyboardDeviceStruct(DevicePtr device, KeySymsPtr pKeySyms,
                         CARD8 pModifiers[], BellProcPtr bellProc,
                         KbdCtrlProcPtr controlProc)
{
    DeviceIntPtr dev = (DeviceIntPtr)device;

    return(InitKeyClassDeviceStruct(dev, pKeySyms, pModifiers) &&
	   InitFocusClassDeviceStruct(dev) &&
	   InitKbdFeedbackClassDeviceStruct(dev, bellProc, controlProc));
}

_X_EXPORT void
SendMappingNotify(DeviceIntPtr pDev, unsigned request, unsigned firstKeyCode,
        unsigned count, ClientPtr client)
{
    int i;
    xEvent event;

    event.u.u.type = MappingNotify;
    event.u.mappingNotify.request = request;
    if (request == MappingKeyboard)
    {
        event.u.mappingNotify.firstKeyCode = firstKeyCode;
        event.u.mappingNotify.count = count;
    }
#ifdef XKB
    if (!noXkbExtension &&
	((request == MappingKeyboard) || (request == MappingModifier))) {
	XkbApplyMappingChange(pDev,request,firstKeyCode,count, client);
    }
#endif

   /* 0 is the server client */
    for (i=1; i<currentMaxClients; i++)
    {
	if (clients[i] && clients[i]->clientState == ClientStateRunning)
	{
#ifdef XKB
	    if (!noXkbExtension &&
		(request == MappingKeyboard) &&
		(clients[i]->xkbClientFlags != 0) &&
		(clients[i]->mapNotifyMask&XkbKeySymsMask))
		continue;
#endif
	    event.u.u.sequenceNumber = clients[i]->sequence;
	    WriteEventsToClient(clients[i], 1, &event);
	}
    }
}

a1513 100
Bool
AllModifierKeysAreUp(dev, map1, per1, map2, per2)
    DeviceIntPtr dev;
    CARD8 *map1, *map2;
    int per1, per2;
{
    int i, j, k;
    CARD8 *down = dev->key->down;

    for (i = 8; --i >= 0; map2 += per2)
    {
	for (j = per1; --j >= 0; map1++)
	{
	    if (*map1 && BitIsOn(down, *map1))
	    {
		for (k = per2; (--k >= 0) && (*map1 != map2[k]);)
		  ;
		if (k < 0)
		    return FALSE;
	    }
	}
    }
    return TRUE;
}

static int
DoSetModifierMapping(ClientPtr client, KeyCode *inputMap,
                     int numKeyPerModifier, xSetModifierMappingReply *rep)
{
    DeviceIntPtr pDev = NULL;
    DeviceIntPtr cp = PickKeyboard(client); /* ClientPointer keyboard */
    int rc, i = 0, inputMapLen = numKeyPerModifier * 8;

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if (pDev == cp || (!pDev->isMaster && (pDev->u.master == cp) && pDev->key)) {
            for (i = 0; i < inputMapLen; i++) {
                /* Check that all the new modifiers fall within the advertised
                 * keycode range, and are okay with the DDX. */
                if (inputMap[i] && ((inputMap[i] < pDev->key->curKeySyms.minKeyCode ||
                                    inputMap[i] > pDev->key->curKeySyms.maxKeyCode) ||
                                    !LegalModifier(inputMap[i], pDev))) {
                    client->errorValue = inputMap[i];
                    return BadValue;
                }
            }

	    rc = XaceHook(XACE_DEVICE_ACCESS, client, pDev, DixManageAccess);
	    if (rc != Success)
		return rc;

            /* None of the modifiers (old or new) may be down while we change
             * the map. */
            if (!AllModifierKeysAreUp(pDev, pDev->key->modifierKeyMap,
                                      pDev->key->maxKeysPerModifier,
                                      inputMap, numKeyPerModifier) ||
                !AllModifierKeysAreUp(pDev, inputMap, numKeyPerModifier,
                                      pDev->key->modifierKeyMap,
                                      pDev->key->maxKeysPerModifier)) {
		rep->success = MappingBusy;
                return Success;
            }
        }
    }

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {

        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key) {
            bzero(pDev->key->modifierMap, MAP_LENGTH);

            /* Annoyingly, we lack a modifierKeyMap size, so we have to just free
             * and re-alloc it every time. */
            if (pDev->key->modifierKeyMap)
                xfree(pDev->key->modifierKeyMap);

            if (inputMapLen) {
                pDev->key->modifierKeyMap = (KeyCode *) xalloc(inputMapLen);
                if (!pDev->key->modifierKeyMap)
                    return BadAlloc;

                memcpy(pDev->key->modifierKeyMap, inputMap, inputMapLen);
                pDev->key->maxKeysPerModifier = numKeyPerModifier;

                for (i = 0; i < inputMapLen; i++) {
                    if (inputMap[i]) {
                        pDev->key->modifierMap[inputMap[i]] |=
                            (1 << (((unsigned int)i) / numKeyPerModifier));
                    }
                }
            }
            else {
                pDev->key->modifierKeyMap = NULL;
                pDev->key->maxKeysPerModifier = 0;
            }
        }
    }

    rep->success = Success;
    return Success;
}

a1517 1
    DeviceIntPtr dev;
d1523 1
a1523 1
			    (sizeof (xSetModifierMappingReq) >> 2)))
d1530 6
a1535 3
    rc = DoSetModifierMapping(client, (KeyCode *)&stuff[1],
			      stuff->numKeyPerModifier, &rep);
    if (rc != Success)
d1538 2
a1539 3
    for (dev = inputInfo.devices; dev; dev = dev->next)
        if (dev->key && dev->coreEvents)
            SendDeviceMappingNotify(client, MappingModifier, 0, 0, dev);
d1548 2
a1549 3
    DeviceIntPtr dev = PickKeyboard(client);
    KeyClassPtr keyc = dev->key;
    int rc;
d1552 2
a1553 3
    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixGetAttrAccess);
    if (rc != Success)
	return rc;
d1555 1
d1557 1
a1557 1
    rep.numKeyPerModifier = keyc->maxKeysPerModifier;
d1560 1
a1560 1
    rep.length = keyc->maxKeysPerModifier << 1;
d1563 3
a1566 3
    /* Use the (modified by DDX) map that SetModifierMapping passed in */
    (void)WriteToClient(client, (int)(keyc->maxKeysPerModifier << 3),
			(char *)keyc->modifierKeyMap);
d1576 1
a1576 2
    KeySymsPtr curKeySyms = &PickKeyboard(client)->key->curKeySyms;
    DeviceIntPtr pDev = NULL;
d1580 1
a1580 1
    len = client->req_len - (sizeof(xChangeKeyboardMappingReq) >> 2);
d1584 4
a1587 2
    if ((stuff->firstKeyCode < curKeySyms->minKeyCode) ||
	(stuff->firstKeyCode > curKeySyms->maxKeyCode)) {
d1593 2
a1594 1
        curKeySyms->maxKeyCode) || (stuff->keySymsPerKeyCode == 0)) {
a1598 8
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key) {
            rc = XaceHook(XACE_DEVICE_ACCESS, client, pDev, DixManageAccess);
	    if (rc != Success)
                return rc;
        }
    }

d1602 1
a1602 11
    keysyms.map = (KeySym *)&stuff[1];
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key)
            if (!SetKeySymsMap(&pDev->key->curKeySyms, &keysyms))
                return BadAlloc;

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
        if (pDev->key && pDev->coreEvents)
            SendDeviceMappingNotify(client, MappingKeyboard,
                                    stuff->firstKeyCode, stuff->keyCodes,
                                    pDev);
d1604 3
a1606 7
    return client->noClientException;
}

static int
DoSetPointerMapping(ClientPtr client, DeviceIntPtr device, BYTE *map, int n)
{
    int rc, i = 0;
d1608 2
a1609 2
    if (!device || !device->button)
        return BadDevice;
d1611 9
a1619 3
    rc = XaceHook(XACE_DEVICE_ACCESS, client, device, DixManageAccess);
    if (rc != Success)
        return rc;
d1621 2
a1622 5
    for (i = 0; i < n; i++) {
        if ((device->button->map[i + 1] != map[i]) &&
            BitIsOn(device->button->down, i + 1)) {
            return MappingBusy;
        }
d1625 1
a1625 4
    for (i = 0; i < n; i++)
        device->button->map[i + 1] = map[i];

    return Success;
d1639 2
a1640 1
    if (client->req_len != (sizeof(xSetPointerMappingReq)+stuff->nElts+3) >> 2)
a1657 2
    if (BadDeviceMap(&map[0], (int)stuff->nElts, 1, 255, &client->errorValue))
	return BadValue;
d1659 5
a1663 7
    /* core protocol specs don't allow for duplicate mappings. */
    for (i = 0; i < stuff->nElts; i++)
    {
        for (j = i + 1; j < stuff->nElts; j++)
        {
            if (map[i] && map[i] == map[j])
            {
d1670 2
a1671 2
    ret = DoSetPointerMapping(client, ptr, map, stuff->nElts);
    if (ret != Success) {
d1673 4
a1676 3
        WriteReplyToClient(client, sizeof(xSetPointerMappingReply), &rep);
        return Success;
    }
a1677 1
    SendMappingNotify(ptr, MappingPointer, 0, 0, client);
d1687 2
a1688 1
    KeySymsPtr curKeySyms = &kbd->key->curKeySyms;
d1697 4
a1700 2
    if ((stuff->firstKeyCode < curKeySyms->minKeyCode) ||
        (stuff->firstKeyCode > curKeySyms->maxKeyCode)) {
d1704 1
a1704 2
    if (stuff->firstKeyCode + stuff->count >
	(unsigned)(curKeySyms->maxKeyCode + 1)) {
d1709 5
d1716 1
a1716 1
    rep.keySymsPerKeyCode = curKeySyms->mapWidth;
d1718 1
a1718 1
    rep.length = (curKeySyms->mapWidth * stuff->count);
d1721 6
a1726 5
    WriteSwappedDataToClient(
	client,
	curKeySyms->mapWidth * stuff->count * sizeof(KeySym),
	&curKeySyms->map[(stuff->firstKeyCode - curKeySyms->minKeyCode) *
			 curKeySyms->mapWidth]);
d1748 1
a1748 1
    rep.nElts = butc->numButtons;
d1751 2
a1752 1
    (void)WriteToClient(client, (int)rep.nElts, (char *)&butc->map[1]);
d1766 1
a1766 1
_X_EXPORT int
d1787 1
d1870 6
a1875 9
#ifdef XKB
            if (!noXkbExtension) {
                XkbEventCauseRec cause;
                XkbSetCauseCoreReq(&cause,X_ChangeKeyboardControl,client);
                XkbSetIndicators(keybd,((led == DO_ALL) ? ~0L : (1L<<(led-1))),
				 			ctrl.leds, &cause);
                ctrl.leds = keybd->kbdfeed->ctrl.leds;
            }
#endif
d1880 2
a1881 2
	    if ((KeyCode)key < keybd->key->curKeySyms.minKeyCode ||
		(KeyCode)key > keybd->key->curKeySyms.maxKeyCode) {
d1893 1
a1893 2
#ifdef XKB
            if (!noXkbExtension && key != DO_ALL)
a1894 1
#endif
a1926 1
#ifdef XKB
d1929 1
a1929 5
    if (!noXkbExtension)
        XkbSetRepeatKeys(keybd, key, keybd->kbdfeed->ctrl.autoRepeat);
    else
#endif
        (*keybd->kbdfeed->CtrlProc)(keybd, &keybd->kbdfeed->ctrl);
d1936 3
d1945 1
a1945 1
    DeviceIntPtr pDev = NULL;
d1956 2
d1959 1
a1959 1
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) &&
d1968 1
a1968 1
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) &&
d2010 1
a2010 1
    DeviceIntPtr keybd = PickKeyboard(client);
a2016 8
    /* Seems like no keyboard actually has the BellProc set. Returning
     * BadDevice (previous code) will make apps crash badly. The man pages
     * doesn't say anything about a BadDevice being returned either.
     * So just quietly do nothing and pretend everything has worked.
     */
    if (!keybd->kbdfeed->BellProc)
        return Success;

d2028 3
a2030 3
    for (keybd = inputInfo.devices; keybd; keybd = keybd->next) {
        if ((keybd->coreEvents || keybd == inputInfo.keyboard) &&
            keybd->kbdfeed && keybd->kbdfeed->BellProc) {
d2032 1
a2032 1
	    rc = XaceHook(XACE_DEVICE_ACCESS, client, keybd, DixBellAccess);
d2035 2
a2036 8
#ifdef XKB
            if (!noXkbExtension)
                XkbHandleBell(FALSE, FALSE, keybd, newpercent,
                              &keybd->kbdfeed->ctrl, 0, None, NULL, client);
            else
#endif
                (*keybd->kbdfeed->BellProc)(newpercent, keybd,
                                            &keybd->kbdfeed->ctrl, 0);
d2046 1
a2046 1
    DeviceIntPtr mouse = PickPointer(client);
d2100 4
a2103 4
    for (mouse = inputInfo.devices; mouse; mouse = mouse->next) {
        if ((mouse->coreEvents || mouse == inputInfo.pointer) &&
            mouse->ptrfeed && mouse->ptrfeed->CtrlProc) {
	    rc = XaceHook(XACE_DEVICE_ACCESS, client, mouse, DixManageAccess);
d2109 5
a2113 5
    for (mouse = inputInfo.devices; mouse; mouse = mouse->next) {
        if ((mouse->coreEvents || mouse == PickPointer(client)) &&
            mouse->ptrfeed && mouse->ptrfeed->CtrlProc) {
            mouse->ptrfeed->ctrl = ctrl;
            (*mouse->ptrfeed->CtrlProc)(mouse, &mouse->ptrfeed->ctrl);
d2211 1
a2211 1
    rep.length = nEvents * (sizeof(xTimecoord) >> 2);
d2239 1
a2239 1
    if (rc != Success)
d2245 3
d2253 71
d2339 1
a2339 1
    if (!dev || dev->isMaster)
d2342 1
a2342 1
    if (master && !master->isMaster) /* can't attach to slaves */
d2346 1
a2346 1
    if (!dev->u.master && !master)
d2368 7
a2374 1
        WindowPtr currentRoot = dev->spriteInfo->sprite->spriteTrace[0];
a2381 1

d2387 2
d2391 4
a2394 2
    /* If we were connected to master device before, this MD may need to
     * change back to it's original classes.
a2395 7
    if (oldmaster)
    {
        DeviceIntPtr it;
        for (it = inputInfo.devices; it; it = it->next)
            if (!it->isMaster && it->u.master == oldmaster)
                break;
    }
d2405 1
a2405 1
_X_EXPORT DeviceIntPtr
d2408 1
a2408 1
    if (!dev->isMaster && dev->u.master)
d2416 36
a2451 1
 * Create a new master device (== one pointer, one keyboard device).
d2454 2
d2458 6
a2463 1
AllocMasterDevice(ClientPtr client, char* name, DeviceIntPtr* ptr, DeviceIntPtr* keybd)
d2472 1
a2472 1
    pointer = AddInputDevice(client, CorePointerProc, TRUE);
a2479 1
#ifdef XKB
d2482 1
a2482 6
    if (!noXkbExtension)
        XkbSetExtension(pointer, ProcessPointerEvent);
#else
    pointer->public.processInputProc = ProcessPointerEvent;
    pointer->public.realInputProc = ProcessPointerEvent;
#endif
d2489 2
a2490 1
    pointer->isMaster = TRUE;
d2492 1
a2492 1
    keyboard = AddInputDevice(client, CoreKeyboardProc, TRUE);
d2495 1
a2495 1
        RemoveDevice(pointer);
a2502 1
#ifdef XKB
d2505 1
a2505 6
    if (!noXkbExtension)
        XkbSetExtension(keyboard, ProcessKeyboardEvent);
#else
    keyboard->public.processInputProc = ProcessKeyboardEvent;
    keyboard->public.realInputProc = ProcessKeyboardEvent;
#endif
d2512 2
a2513 1
    keyboard->isMaster = TRUE;
d2527 1
@


1.7
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d30 2
a31 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d33 1
a33 1
both that copyright notice and this permission notice appear in 
d36 1
a36 1
software without specific, written prior permission.  
d60 1
d66 1
d76 1
d81 1
d87 4
d96 83
a178 1
DevPrivateKey CoreDevicePrivateKey = &CoreDevicePrivateKey;
d188 1
a188 1
AddInputDevice(DeviceProc deviceProc, Bool autoStart)
d193 2
a194 1
    char devind[MAX_DEVICES];
d197 1
a197 1
    memset(devind, 0, sizeof(char)*MAX_DEVICES);
d202 1
a202 1
    for (devid = 0; devid < MAX_DEVICES && devind[devid]; devid++)
d205 1
a205 1
    if (devid >= MAX_DEVICES)
d207 1
a207 1
    dev = (DeviceIntPtr) xcalloc(sizeof(DeviceIntRec), 1);
a209 2
    dev->name = (char *)NULL;
    dev->type = 0;
a210 1
    dev->public.on = FALSE;
d216 6
a221 26
    dev->sync.frozen = FALSE;
    dev->sync.other = NullGrab;
    dev->sync.state = NOT_GRABBED;
    dev->sync.event = (xEvent *) NULL;
    dev->sync.evcount = 0;
    dev->grab = NullGrab;
    dev->grabTime = currentTime;
    dev->fromPassiveGrab = FALSE;
    dev->key = (KeyClassPtr)NULL;
    dev->valuator = (ValuatorClassPtr)NULL;
    dev->button = (ButtonClassPtr)NULL;
    dev->focus = (FocusClassPtr)NULL;
    dev->proximity = (ProximityClassPtr)NULL;
    dev->absolute = (AbsoluteClassPtr)NULL;
    dev->kbdfeed = (KbdFeedbackPtr)NULL;
    dev->ptrfeed = (PtrFeedbackPtr)NULL;
    dev->intfeed = (IntegerFeedbackPtr)NULL;
    dev->stringfeed = (StringFeedbackPtr)NULL;
    dev->bell = (BellFeedbackPtr)NULL;
    dev->leds = (LedFeedbackPtr)NULL;
#ifdef XKB
    dev->xkb_interest = NULL;
#endif
    dev->config_info = NULL;
    dev->devPrivates = NULL;
    dev->unwrapProc = NULL;
d223 3
a225 2
    dev->inited = FALSE;
    dev->enabled = FALSE;
d229 1
a229 1
    if (XaceHook(XACE_DEVICE_ACCESS, serverClient, dev, DixCreateAccess)) {
d241 7
d252 1
d254 2
a255 1
 * list. All clients are notified about the device being enabled.
d257 2
a258 1
 * A device will send events once enabled.
d269 1
d271 5
d281 41
d324 1
a324 1
        ErrorF("couldn't enable device %d\n", dev->id);
d335 5
d344 1
a344 1
    dummyDev.id = 0;
d356 3
d364 1
a364 1
    DeviceIntPtr *prev;
d367 1
d375 32
d413 5
d422 1
a422 1
    dummyDev.id = 0;
d432 2
a433 1
 * 
d444 1
d451 7
a457 1
    
d462 3
a464 1
    dummyDev.id = 0;
d490 1
a490 1
 * Device control function for the Virtual Core Keyboard. 
d500 1
d504 6
d518 2
a519 1
            ErrorF("Couldn't allocate core keymap\n");
d523 1
a523 1
        modMap = (CARD8 *)xalloc(MAP_LENGTH);
d525 2
a526 1
            ErrorF("Couldn't allocate core modifier map\n");
a528 1
        bzero((char *)modMap, MAP_LENGTH);
a532 1
            XkbSetRulesDflts("xorg", "pc105", "us", NULL, NULL);
a545 1

a548 1
	dixSetPrivate(&pDev->devPrivates, CoreDevicePrivateKey, NULL);
d559 3
d568 1
d572 3
d578 1
a578 1
                                GetMotionHistory, (PtrCtrlProcPtr)NoopDDA,
d581 1
a581 1
        pDev->valuator->lastx = pDev->valuator->axisVal[0];
d583 1
a583 1
        pDev->valuator->lasty = pDev->valuator->axisVal[1];
a586 1
	dixSetPrivate(&pDev->devPrivates, CoreDevicePrivateKey, NULL);
d598 3
a600 1
 * The devices are activated but not enabled.
d607 9
a615 1
    DeviceIntPtr dev;
a616 41
    if (!inputInfo.keyboard) {
        dev = AddInputDevice(CoreKeyboardProc, TRUE);
        if (!dev)
            FatalError("Failed to allocate core keyboard");
        dev->name = strdup("Virtual core keyboard");
#ifdef XKB
        dev->public.processInputProc = CoreProcessKeyboardEvent;
        dev->public.realInputProc = CoreProcessKeyboardEvent;
        if (!noXkbExtension)
           XkbSetExtension(dev, ProcessKeyboardEvent);
#else
        dev->public.processInputProc = ProcessKeyboardEvent;
        dev->public.realInputProc = ProcessKeyboardEvent;
#endif
        dev->ActivateGrab = ActivateKeyboardGrab;
        dev->DeactivateGrab = DeactivateKeyboardGrab;
        dev->coreEvents = FALSE;
        (void)ActivateDevice(dev);
        inputInfo.keyboard = dev;
    }

    if (!inputInfo.pointer) {
        dev = AddInputDevice(CorePointerProc, TRUE);
        if (!dev)
            FatalError("Failed to allocate core pointer");
        dev->name = strdup("Virtual core pointer");
#ifdef XKB
        dev->public.processInputProc = CoreProcessPointerEvent;
        dev->public.realInputProc = CoreProcessPointerEvent;
        if (!noXkbExtension)
           XkbSetExtension(dev, ProcessPointerEvent);
#else
        dev->public.processInputProc = ProcessPointerEvent;
        dev->public.realInputProc = ProcessPointerEvent;
#endif
        dev->ActivateGrab = ActivatePointerGrab;
        dev->DeactivateGrab = DeactivatePointerGrab;
        dev->coreEvents = FALSE;
        (void)ActivateDevice(dev);
        inputInfo.pointer = dev;
    }
d621 1
a621 1
 * 
d624 5
a628 1
 * 
d632 1
a632 1
InitAndStartDevices(void)
d641 2
d650 1
a650 16
    for (dev = inputInfo.devices;
	 dev && (dev != inputInfo.keyboard);
	 dev = dev->next)
	;
    if (!dev || (dev != inputInfo.keyboard)) {
	ErrorF("No core keyboard\n");
	return BadImplementation;
    }
    for (dev = inputInfo.devices;
	 dev && (dev != inputInfo.pointer);
	 dev = dev->next)
	;
    if (!dev || (dev != inputInfo.pointer)) {
	ErrorF("No core pointer\n");
	return BadImplementation;
    }
d655 1
a655 5
 * Close down a device and free all resources. 
 * Once closed down, the driver will probably not expect you that you'll ever
 * enable it again and free associated structs. If you want the device to just
 * be disabled, DisableDevice().
 * Don't call this function directly, use RemoveDevice() instead.
d658 1
a658 1
CloseDevice(DeviceIntPtr dev)
d660 2
a661 6
    KbdFeedbackPtr k, knext;
    PtrFeedbackPtr p, pnext;
    IntegerFeedbackPtr i, inext;
    StringFeedbackPtr s, snext;
    BellFeedbackPtr b, bnext;
    LedFeedbackPtr l, lnext;
d663 53
a715 2
    if (dev->inited)
	(void)(*dev->deviceProc)(dev, DEVICE_CLOSE);
d717 5
a721 1
    xfree(dev->name);
d723 8
a730 1
    if (dev->key) {
d732 2
a733 2
	if (dev->key->xkbInfo)
	    XkbFreeInfo(dev->key->xkbInfo);
d735 54
a788 6
        dev->key->xkbInfo = NULL;
	xfree(dev->key->curKeySyms.map);
	xfree(dev->key->modifierKeyMap);
	xfree(dev->key);
        dev->key = NULL;
    }
d790 2
a791 9
    if (dev->valuator) {
        /* Counterpart to 'biggest hack ever' in init. */
        if (dev->valuator->motion &&
            dev->valuator->GetMotionProc == GetMotionHistory)
            xfree(dev->valuator->motion);
        xfree(dev->valuator);
    }

    if (dev->button) {
d793 2
a794 2
        if (dev->button->xkb_acts)
            xfree(dev->button->xkb_acts);
d796 4
a799 1
        xfree(dev->button);
d801 37
d839 4
a842 4
    if (dev->focus) {
	xfree(dev->focus->trace);
	xfree(dev->focus);
    }
d844 2
a845 2
    if (dev->proximity)
        xfree(dev->proximity);
d847 7
a853 8
    for (k = dev->kbdfeed; k; k = knext) {
	knext = k->next;
#ifdef XKB
	if (k->xkb_sli)
	    XkbFreeSrvLedInfo(k->xkb_sli);
#endif
	xfree(k);
    }
d855 1
a855 9
    for (p = dev->ptrfeed; p; p = pnext) {
	pnext = p->next;
	xfree(p);
    }
    
    for (i = dev->intfeed; i; i = inext) {
	inext = i->next;
	xfree(i);
    }
d857 2
a858 6
    for (s = dev->stringfeed; s; s = snext) {
	snext = s->next;
	xfree(s->ctrl.symbols_supported);
	xfree(s->ctrl.symbols_displayed);
	xfree(s);
    }
d860 4
a863 3
    for (b = dev->bell; b; b = bnext) {
	bnext = b->next;
	xfree(b);
a865 8
    for (l = dev->leds; l; l = lnext) {
	lnext = l->next;
#ifdef XKB
	if (l->xkb_sli)
	    XkbFreeSrvLedInfo(l->xkb_sli);
#endif
	xfree(l);
    }
d872 16
a887 1
    xfree(dev->sync.event);
d893 1
a893 1
 * Shut down all devices, free all resources, etc. 
d901 11
d922 1
d927 17
d948 1
a948 1
 * resources. 
d951 5
d964 1
d966 1
d973 4
a983 1
	    CloseDevice(tmp);
d990 1
d1009 2
a1010 2
    
    if (ret == Success) {
d1016 1
a1016 1
        dummyDev.id = 0;
d1027 2
d1104 1
a1104 1
        map = (KeySym *)xalloc(bytes);
a1106 1
	bzero((char *)map, bytes);
d1117 10
d1156 1
a1156 1
    keyc->modifierKeyMap = (KeyCode *)xalloc(8*keyc->maxKeysPerModifier);
a1158 1
    bzero((char *)keyc->modifierKeyMap, 8*(int)keyc->maxKeysPerModifier);
a1178 1
    int i;
d1180 2
a1181 2
    
    keyc = (KeyClassPtr)xalloc(sizeof(KeyClassRec));
a1183 2
    keyc->curKeySyms.map = (KeySym *)NULL;
    keyc->curKeySyms.mapWidth = 0;
a1185 3
    keyc->modifierKeyMap = (KeyCode *)NULL;
    keyc->state = 0;
    keyc->prev_state = 0;
a1187 6
    else
	bzero((char *)keyc->modifierMap, MAP_LENGTH);
    bzero((char *)keyc->down, DOWN_LENGTH);
    bzero((char *)keyc->postdown, DOWN_LENGTH);
    for (i = 0; i < 8; i++)
	keyc->modifierKeyCount[i] = 0;
d1204 1
a1204 1
InitButtonClassDeviceStruct(DeviceIntPtr dev, int numButtons, 
d1210 1
a1210 1
    butc = (ButtonClassPtr)xalloc(sizeof(ButtonClassRec));
a1215 7
    butc->buttonsDown = 0;
    butc->state = 0;
    butc->motionMask = 0;
    bzero((char *)butc->down, DOWN_LENGTH);
#ifdef XKB
    butc->xkb_acts=	NULL;
#endif
d1221 1
a1221 2
InitValuatorClassDeviceStruct(DeviceIntPtr dev, int numAxes, 
                              ValuatorMotionProcPtr motionProc, 
d1230 1
a1230 1
    valc = (ValuatorClassPtr)xalloc(sizeof(ValuatorClassRec) +
a1238 1
    valc->GetMotionProc = motionProc;
a1245 4
    valc->lastx = 0;
    valc->lasty = 0;
    valc->dxremaind = 0;
    valc->dyremaind = 0;
d1248 1
a1248 3
    /* biggest hack ever. */
    if (motionProc == GetMotionHistory)
        AllocateMotionHistory(dev);
d1251 2
a1252 1
        InitValuatorAxisStruct(dev, i, 0, -1, 0, 0, 0);
d1255 67
d1335 4
a1338 4
    abs->min_x = -1;
    abs->min_y = -1;
    abs->max_x = -1;
    abs->max_y = -1;
d1346 2
a1347 2
    abs->width = -1;
    abs->height = -1;
d1375 1
a1375 1
InitKbdFeedbackClassDeviceStruct(DeviceIntPtr dev, BellProcPtr bellProc, 
d1439 1
a1439 1
      DeviceIntPtr dev, StringCtrlProcPtr controlProc, 
d1452 1
a1452 1
    feedc->ctrl.symbols_supported = (KeySym *) 
d1454 1
a1454 1
    feedc->ctrl.symbols_displayed = (KeySym *) 
d1478 1
a1478 1
InitBellFeedbackClassDeviceStruct (DeviceIntPtr dev, BellProcPtr bellProc, 
d1537 1
a1537 2
InitPointerDeviceStruct(DevicePtr device, CARD8 *map, int numButtons, 
                        ValuatorMotionProcPtr motionProc, 
d1544 1
a1544 1
	   InitValuatorClassDeviceStruct(dev, numAxes, motionProc,
d1550 3
a1552 3
InitKeyboardDeviceStruct(DevicePtr device, KeySymsPtr pKeySyms, 
                         CARD8 pModifiers[], BellProcPtr bellProc, 
                         KbdCtrlProcPtr controlProc) 
d1562 2
a1563 2
SendMappingNotify(unsigned request, unsigned firstKeyCode, unsigned count, 
                  ClientPtr client)
d1577 3
a1579 3
	((request == MappingKeyboard) || (request == MappingModifier)))
        XkbApplyMappingChange(inputInfo.keyboard, request, firstKeyCode, count,
                              client);
d1601 4
a1604 2
 * n-squared algorithm. n < 255 and don't want to copy the whole thing and
 * sort it to do the checking. How often is it called? Just being lazy?
d1609 1
a1609 1
    int i, j;
a1618 6
	    for (j = i + 1; j < length; j++)
		if (buff[i] == buff[j])
		{
		    *errval = buff[i];
		    return TRUE;
		}
d1653 1
d1657 1
a1657 1
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key) {
d1723 1
a1723 1
int 
a1744 1
    SendMappingNotify(MappingModifier, 0, 0, client);
d1756 2
a1757 1
    KeyClassPtr keyc = inputInfo.keyboard->key;
d1761 1
a1761 2
    rc = XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard,
		  DixGetAttrAccess);
d1785 1
a1785 1
    KeySymsPtr curKeySyms = &inputInfo.keyboard->key->curKeySyms;
d1790 1
a1790 1
    len = client->req_len - (sizeof(xChangeKeyboardMappingReq) >> 2);  
a1822 2
    SendMappingNotify(MappingKeyboard, stuff->firstKeyCode, stuff->keyCodes,
                      client);
a1835 1
    DeviceIntPtr dev = NULL;
d1840 3
a1842 7
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if ((dev->coreEvents || dev == inputInfo.pointer) && dev->button) {
	    rc = XaceHook(XACE_DEVICE_ACCESS, client, dev, DixManageAccess);
	    if (rc != Success)
		return rc;
	}
    }
d1844 4
a1847 8
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if ((dev->coreEvents || dev == inputInfo.pointer) && dev->button) {
            for (i = 0; i < n; i++) {
                if ((device->button->map[i + 1] != map[i]) &&
                    BitIsOn(device->button->down, i + 1)) {
                    return MappingBusy;
                }
            }
d1851 2
a1852 6
    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if ((dev->coreEvents || dev == inputInfo.pointer) && dev->button) {
            for (i = 0; i < n; i++)
                dev->button->map[i + 1] = map[i];
        }
    }
d1862 2
d1875 1
a1875 1
    
d1878 5
a1882 1
    if (stuff->nElts != inputInfo.pointer->button->numButtons) {
d1889 14
a1902 1
    ret = DoSetPointerMapping(client, inputInfo.pointer, map, stuff->nElts);
d1909 1
a1909 2
    /* FIXME: Send mapping notifies for all the extended devices as well. */
    SendMappingNotify(MappingPointer, 0, 0, client);
d1918 2
a1919 1
    KeySymsPtr curKeySyms = &inputInfo.keyboard->key->curKeySyms;
d1924 1
a1924 2
    rc = XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard,
		  DixGetAttrAccess);
d1959 4
a1962 1
    ButtonClassPtr butc = inputInfo.pointer->button;
d1966 1
a1966 2
    rc = XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.pointer,
		  DixGetAttrAccess);
d1976 1
a1976 1
    return Success;    
d2016 1
a2016 1
	case KBKeyClickPercent: 
d2105 2
a2106 2
	    if ((KeyCode)key < inputInfo.keyboard->key->curKeySyms.minKeyCode ||
		(KeyCode)key > inputInfo.keyboard->key->curKeySyms.maxKeyCode) {
d2166 1
a2166 1
} 
d2210 2
a2211 1
    KeybdCtrl *ctrl = &inputInfo.keyboard->kbdfeed->ctrl;
d2215 1
a2215 2
    rc = XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard,
		  DixGetAttrAccess);
d2232 1
a2232 1
} 
d2237 1
a2237 1
    DeviceIntPtr keybd = inputInfo.keyboard;
d2244 5
d2250 2
a2251 2
        return BadDevice;
    
d2261 1
a2261 1
    	newpercent = base - newpercent + stuff->percent;
d2282 1
a2282 1
} 
d2287 1
a2287 1
    DeviceIntPtr mouse = inputInfo.pointer;
d2292 1
a2292 1
    
d2295 1
a2295 1
    
d2351 1
a2351 1
        if ((mouse->coreEvents || mouse == inputInfo.pointer) &&
d2359 1
a2359 1
} 
d2364 2
a2365 1
    PtrCtrl *ctrl = &inputInfo.pointer->ptrfeed->ctrl;
d2370 1
a2370 2
    rc = XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.pointer,
		  DixGetAttrAccess);
d2387 1
a2387 1
    GrabPtr grab = dev->grab;
d2408 1
a2408 1
    DeviceIntPtr mouse = inputInfo.pointer;
d2433 3
a2435 8
	coords = (xTimecoord *)xalloc(mouse->valuator->numMotionEvents
					      * sizeof(xTimecoord));
	if (!coords)
	    return BadAlloc;
	count = (*mouse->valuator->GetMotionProc) (mouse, coords,
						   start.milliseconds,
						   stop.milliseconds,
						   pWin->drawable.pScreen);
d2471 2
a2472 1
    CARD8 *down = inputInfo.keyboard->key->down;
d2479 1
a2479 2
    rc = XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard,
		  DixReadAccess);
d2487 171
@


1.6
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d72 1
d88 1
a88 2
int CoreDevicePrivatesIndex = 0;
static int CoreDevicePrivatesGeneration = -1;
a121 1
    inputInfo.numDevices++;
a151 1
    dev->nPrivates = 0;
d158 9
d361 1
a361 1
        pDev->devPrivates[CoreDevicePrivatesIndex].ptr = NULL;
d393 1
a393 1
        pDev->devPrivates[CoreDevicePrivatesIndex].ptr = NULL;
a413 5
    if (CoreDevicePrivatesGeneration != serverGeneration) {
        CoreDevicePrivatesIndex = AllocateDevicePrivateIndex();
        CoreDevicePrivatesGeneration = serverGeneration;
    }

a430 3
        if (!AllocateDevicePrivate(dev, CoreDevicePrivatesIndex))
            FatalError("Couldn't allocate keyboard devPrivates\n");
        dev->devPrivates[CoreDevicePrivatesIndex].ptr = NULL;
a451 3
        if (!AllocateDevicePrivate(dev, CoreDevicePrivatesIndex))
            FatalError("Couldn't allocate pointer devPrivates\n");
        dev->devPrivates[CoreDevicePrivatesIndex].ptr = NULL;
d532 1
a603 3
    if (dev->devPrivates)
	xfree(dev->devPrivates);

d605 1
d621 1
a621 1
	CloseDevice(dev);
d626 1
a626 1
	CloseDevice(dev);
d719 2
a720 14
_X_EXPORT DevicePtr
LookupKeyboardDevice(void)
{
    return inputInfo.keyboard ? &inputInfo.keyboard->public : NULL;
}

_X_EXPORT DevicePtr
LookupPointerDevice(void)
{
    return inputInfo.pointer ? &inputInfo.pointer->public : NULL;
}

DevicePtr
LookupDevice(int id)
d723 2
d728 1
a728 1
            return (DevicePtr)dev;
d732 1
a732 1
            return (DevicePtr)dev;
d734 7
a740 1
    return NULL;
d1281 1
a1281 1
                     int numKeyPerModifier)
d1284 1
a1284 1
    int i = 0, inputMapLen = numKeyPerModifier * 8;
d1299 3
a1301 2
            if (!XaceHook(XACE_DEVICE_ACCESS, client, pDev, TRUE))
                return BadAccess;
d1311 2
a1312 1
                return MappingBusy;
d1349 1
d1358 1
a1359 1
    
d1370 4
a1373 2
    rep.success = DoSetModifierMapping(client, (KeyCode *)&stuff[1],
                                       stuff->numKeyPerModifier);
d1388 7
a1395 1
    REQUEST_SIZE_MATCH(xReq);
d1418 1
d1439 3
a1441 2
            if (!XaceHook(XACE_DEVICE_ACCESS, client, pDev, TRUE))
                return BadAccess;
d1466 1
a1466 1
DoSetPointerMapping(DeviceIntPtr device, BYTE *map, int n)
d1468 1
a1468 1
    int i = 0;
d1476 8
a1505 1
    REQUEST(xSetPointerMappingReq);
d1509 2
a1511 1
    REQUEST_AT_LEAST_SIZE(xSetPointerMappingReq);
d1529 1
a1529 1
    ret = DoSetPointerMapping(inputInfo.pointer, map, stuff->nElts);
d1546 2
d1549 1
a1549 1
    KeySymsPtr curKeySyms = &inputInfo.keyboard->key->curKeySyms;
d1551 4
a1554 1
    REQUEST_SIZE_MATCH(xGetKeyboardMappingReq);
d1588 7
a1595 1
    REQUEST_SIZE_MATCH(xReq);
d1814 3
a1816 2
            if (!XaceHook(XACE_DEVICE_ACCESS, client, pDev, TRUE))
                return BadAccess;
d1835 1
a1835 1
    int i;
d1838 6
a1844 1
    REQUEST_SIZE_MATCH(xReq);
d1866 1
d1887 4
d1910 1
a1911 1

d1962 8
d1987 7
a1994 1
    REQUEST_SIZE_MATCH(xReq);
d2032 1
d2034 4
a2037 2
    REQUEST_SIZE_MATCH(xGetMotionEventsReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
d2040 1
d2054 1
a2054 1
	coords = (xTimecoord *)ALLOCATE_LOCAL(mouse->valuator->numMotionEvents
d2088 1
a2088 1
	DEALLOCATE_LOCAL(coords);
d2096 1
a2096 1
    int i;
d2104 7
a2110 5
    if (XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard, TRUE))
	for (i = 0; i<32; i++)
	    rep.map[i] = down[i];
    else
	bzero((char *)&rep.map[0], 32);
@


1.5
log
@Merge xserver 1.4.0.90. This includes fixes for some of the regressions
introduced by xserver 1.4, such as the keyboad caps/num-lock leds updates.
Tested by many.
@
text
@d476 2
a477 1
	ActivateDevice(dev);
@


1.4
log
@OpenBSD's still using the old xkb data files. So rules are called "xorg" not
"base".
@
text
@d531 1
d1212 3
a1214 4
	((request == MappingKeyboard) || (request == MappingModifier))) {
	XkbApplyMappingChange(inputInfo.keyboard,request,firstKeyCode,count,
									client);
    }
d1362 1
a1377 1
    /* FIXME: Send mapping notifies for all the extended devices as well. */
d1379 3
d1444 2
a1445 2
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key) {
a1447 2
        }
    }
a1448 1
    /* FIXME: Send mapping notifies for all the extended devices as well. */
d1451 6
@


1.3
log
@merge xserver 1.4, 1st pass
@
text
@d336 1
a336 1
            XkbSetRulesDflts("base", "pc105", "us", NULL, NULL);
@


1.2
log
@OpenBSD local modifications:
- privilege separation
- some snprintf/strlc{at,py} conversions
- support for more architectures
- signal handler fixes
- default mouse wheel support in config tools
- sunmouse protocol
@
text
@d70 1
a70 1
#include <X11/extensions/XKBsrv.h>
a71 1
#ifdef XACE
a72 1
#endif
d78 19
d100 13
a112 1
    register DeviceIntPtr dev;
d114 1
a114 1
    if (inputInfo.numDevices >= MAX_DEVICES)
d116 1
a116 1
    dev = (DeviceIntPtr) xalloc(sizeof(DeviceIntRec));
d121 1
a121 1
    dev->id = inputInfo.numDevices;
d142 1
a148 1
    dev->next = inputInfo.off_devices;
d150 1
a150 1
    dev->xkb_interest= NULL;
d152 1
d156 9
a164 1
    inputInfo.off_devices = dev;
d168 9
d178 1
a178 1
EnableDevice(register DeviceIntPtr dev)
d180 4
a183 1
    register DeviceIntPtr *prev;
d190 2
a191 1
	((*dev->deviceProc)(dev, DEVICE_ON) != Success))
d193 2
d196 14
a209 2
    dev->next = inputInfo.devices;
    inputInfo.devices = dev;
d213 7
d221 1
a221 1
DisableDevice(register DeviceIntPtr dev)
d223 3
a225 1
    register DeviceIntPtr *prev;
d234 1
d238 9
d250 219
d470 1
a470 1
InitAndStartDevices()
d472 1
a472 1
    register DeviceIntPtr dev, next;
d474 4
a477 2
    for (dev = inputInfo.off_devices; dev; dev = dev->next)
	dev->inited = ((*dev->deviceProc)(dev, DEVICE_INIT) == Success);
d480 1
d504 7
d512 1
a512 1
CloseDevice(register DeviceIntPtr dev)
d523 1
d525 2
a526 2
    if (dev->key)
    {
d535 10
a544 1
    xfree(dev->valuator);
d546 2
a547 2
    if ((dev->button)&&(dev->button->xkb_acts))
	xfree(dev->button->xkb_acts);
d549 4
a552 3
    xfree(dev->button);
    if (dev->focus)
    {
d556 5
a560 3
    xfree(dev->proximity);
    for (k=dev->kbdfeed; k; k=knext)
    {
d568 2
a569 2
    for (p=dev->ptrfeed; p; p=pnext)
    {
d573 2
a574 2
    for (i=dev->intfeed; i; i=inext)
    {
d578 2
a579 2
    for (s=dev->stringfeed; s; s=snext)
    {
d585 2
a586 2
    for (b=dev->bell; b; b=bnext)
    {
d590 2
a591 2
    for (l=dev->leds; l; l=lnext)
    {
d599 1
d601 1
a601 1
    while (dev->xkb_interest) {
a602 1
    }
d604 4
d612 4
d617 1
a617 1
CloseDownDevices()
d619 1
a619 1
    register DeviceIntPtr dev, next;
d637 8
a644 2
void
RemoveDevice(register DeviceIntPtr dev)
d646 7
a652 1
    register DeviceIntPtr prev,tmp,next;
d654 8
a661 2
    prev= NULL;
    for (tmp= inputInfo.devices; tmp; (prev = tmp), (tmp = next)) {
d663 1
a663 1
	if (tmp==dev) {
d665 1
d670 2
a671 6
	    inputInfo.numDevices--;
	    if (inputInfo.keyboard == tmp)
	        inputInfo.keyboard = NULL;
	    else if (inputInfo.pointer == tmp)
	        inputInfo.pointer = NULL;
	    return;
d675 2
a676 2
    prev= NULL;
    for (tmp= inputInfo.off_devices; tmp; (prev = tmp), (tmp = next)) {
d678 1
a678 1
	if (tmp==dev) {
d680 2
a681 1
	    if (prev==NULL)
d685 2
a686 6
	    inputInfo.numDevices--;
	    if (inputInfo.keyboard == tmp)
	        inputInfo.keyboard = NULL;
	    else if (inputInfo.pointer == tmp)
	        inputInfo.pointer = NULL;
	    return;
d689 13
a701 2
    ErrorF("Internal Error! Attempt to remove a non-existent device\n");
    return;
d705 1
a705 1
NumMotionEvents()
d713 1
a713 20
    inputInfo.pointer = device;
#ifdef XKB
    device->public.processInputProc = CoreProcessPointerEvent;
    device->public.realInputProc = CoreProcessPointerEvent;
    if (!noXkbExtension)
       XkbSetExtension(device,ProcessPointerEvent);
#else
    device->public.processInputProc = ProcessPointerEvent;
    device->public.realInputProc = ProcessPointerEvent;
#endif
    device->ActivateGrab = ActivatePointerGrab;
    device->DeactivateGrab = DeactivatePointerGrab;
    if (!device->name)
    {
	char *p = "pointer";
	size_t buflen = strlen(p) + 1;

	device->name = (char *)xalloc(buflen);
	strlcpy(device->name, p, buflen);
    }
d719 1
a719 19
    inputInfo.keyboard = device;
#ifdef XKB
    device->public.processInputProc = CoreProcessKeyboardEvent;
    device->public.realInputProc = CoreProcessKeyboardEvent;
    if (!noXkbExtension)
       XkbSetExtension(device,ProcessKeyboardEvent);
#else
    device->public.processInputProc = ProcessKeyboardEvent;
    device->public.realInputProc = ProcessKeyboardEvent;
#endif
    device->ActivateGrab = ActivateKeyboardGrab;
    device->DeactivateGrab = DeactivateKeyboardGrab;
    if (!device->name)
    {
	char *k = "keyboard";
	size_t buflen = strlen(k) + 1;
	device->name = (char *)xalloc(buflen);
	strlcpy(device->name, k, buflen);
    }
d723 1
a723 1
LookupKeyboardDevice()
d729 1
a729 1
LookupPointerDevice()
d760 1
a760 1
SetKeySymsMap(register KeySymsPtr dst, register KeySymsPtr src)
a763 1
           /* if keysym map size changes, grow map first */
d765 1
d809 1
a809 1
InitModMap(register KeyClassPtr keyc)
d854 2
a855 2
    register KeyClassPtr keyc;

d871 1
d890 1
a890 1
InitButtonClassDeviceStruct(register DeviceIntPtr dev, int numButtons, 
d893 1
a893 1
    register ButtonClassPtr butc;
d919 4
a922 1
    register ValuatorClassPtr valc;
d929 4
d934 1
d941 12
a952 1
    for (i=0; i<numAxes; i++)
d954 32
a985 1
    dev->valuator = valc;
d992 1
a992 1
    register FocusClassPtr focc;
d1011 1
a1011 1
    register KbdFeedbackPtr feedc;
d1038 1
a1038 1
    register PtrFeedbackPtr feedc;
d1054 1
a1054 1
LedCtrl defaultLedControl = {
d1057 1
a1057 1
BellCtrl defaultBellControl = {
d1063 1
a1063 1
IntegerCtrl defaultIntegerControl = {
d1076 1
a1076 1
    register StringFeedbackPtr feedc;
d1114 1
a1114 1
    register BellFeedbackPtr feedc;
d1133 1
a1133 1
    register LedFeedbackPtr feedc;
d1154 1
a1154 1
    register IntegerFeedbackPtr feedc;
d1172 2
a1173 1
                        PtrCtrlProcPtr controlProc, int numMotionEvents)
d1178 1
a1178 1
	   InitValuatorClassDeviceStruct(dev, 2, motionProc,
d1240 1
a1240 1
BadDeviceMap(register BYTE *buff, int length, unsigned low, unsigned high, XID *errval)
d1242 1
a1242 1
    register int     i, j;
d1264 2
a1265 2
    register DeviceIntPtr dev;
    register CARD8 *map1, *map2;
d1268 2
a1269 2
    register int i, j, k;
    register CARD8 *down = dev->key->down;
d1287 71
a1362 5
    KeyCode *inputMap;
    int inputMapLen;
    register int i;
    DeviceIntPtr keybd = inputInfo.keyboard;
    register KeyClassPtr keyc = keybd->key;
d1366 2
a1367 2
    if (client->req_len != ((stuff->numKeyPerModifier<<1) +
			    (sizeof (xSetModifierMappingReq)>>2)))
a1369 25
    inputMapLen = 8*stuff->numKeyPerModifier;
    inputMap = (KeyCode *)&stuff[1];

    /*
     *	Now enforce the restriction that "all of the non-zero keycodes must be
     *	in the range specified by min-keycode and max-keycode in the
     *	connection setup (else a Value error)"
     */
    i = inputMapLen;
    while (i--)
    {
	if (inputMap[i]
	    && (inputMap[i] < keyc->curKeySyms.minKeyCode
		|| inputMap[i] > keyc->curKeySyms.maxKeyCode))
	{
	    client->errorValue = inputMap[i];
	    return BadValue;
	}
    }

#ifdef XACE
    if (!XaceHook(XACE_DEVICE_ACCESS, client, keybd, TRUE))
	return BadAccess;
#endif 

a1372 1
    rep.success = MappingSuccess;
d1374 2
a1375 55
    /*
     *	Now enforce the restriction that none of the old or new
     *	modifier keys may be down while we change the mapping,  and
     *	that the DDX layer likes the choice.
     */
    if (!AllModifierKeysAreUp(keybd, keyc->modifierKeyMap,
			      (int)keyc->maxKeysPerModifier,
			      inputMap, (int)stuff->numKeyPerModifier)
	    ||
	!AllModifierKeysAreUp(keybd, inputMap, (int)stuff->numKeyPerModifier,
			      keyc->modifierKeyMap,
			      (int)keyc->maxKeysPerModifier))
    {
	rep.success = MappingBusy;
    }
    else
    {
	for (i = 0; i < inputMapLen; i++)
	{
	    if (inputMap[i] && !LegalModifier(inputMap[i], (DevicePtr)keybd))
	    {
		rep.success = MappingFailed;
		break;
	    }
	}
    }

    if (rep.success == MappingSuccess)
    {
	KeyCode *map;
	/*
	 *	Now build the keyboard's modifier bitmap from the
	 *	list of keycodes.
	 */
	map = (KeyCode *)xalloc(inputMapLen);
	if (!map && inputMapLen)
	    return BadAlloc;
	if (keyc->modifierKeyMap)
	    xfree(keyc->modifierKeyMap);
	keyc->modifierKeyMap = map;
	memmove((char *)map, (char *)inputMap, inputMapLen);

	keyc->maxKeysPerModifier = stuff->numKeyPerModifier;
	for (i = 0; i < MAP_LENGTH; i++)
	    keyc->modifierMap[i] = 0;
	for (i = 0; i < inputMapLen; i++)
	{
	    if (inputMap[i])
		keyc->modifierMap[inputMap[i]] |=
		    (1<<(((unsigned int)i)/keyc->maxKeysPerModifier));
	}
    }

    if (rep.success == MappingSuccess)
        SendMappingNotify(MappingModifier, 0, 0, client);
d1377 2
d1380 1
a1380 2

    return(client->noClientException);
d1387 1
a1387 1
    register KeyClassPtr keyc = inputInfo.keyboard->key;
d1410 2
a1411 1
    register KeySymsPtr curKeySyms = &inputInfo.keyboard->key->curKeySyms;
d1417 1
d1419 1
a1419 2
	(stuff->firstKeyCode > curKeySyms->maxKeyCode))
    {
d1422 1
d1424 2
a1425 4
    if ( ((unsigned)(stuff->firstKeyCode + stuff->keyCodes - 1) >
	  curKeySyms->maxKeyCode) ||
	(stuff->keySymsPerKeyCode == 0))
    {
d1429 8
a1436 4
#ifdef XACE
    if (!XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard, TRUE))
	return BadAccess;
#endif 
d1441 8
a1448 2
    if (!SetKeySymsMap(curKeySyms, &keysyms))
	return BadAlloc;
d1450 1
a1450 1
									client);
d1452 10
d1463 19
d1489 1
a1490 2
    register unsigned int i;
    DeviceIntPtr mouse = inputInfo.pointer;
d1500 4
a1503 2
    if (stuff->nElts != mouse->button->numButtons)
    {
d1509 9
a1517 10
    for (i=0; i < stuff->nElts; i++)
	if ((mouse->button->map[i + 1] != map[i]) &&
	    BitIsOn(mouse->button->down, i + 1))
	{
    	    rep.success = MappingBusy;
	    WriteReplyToClient(client, sizeof(xSetPointerMappingReply), &rep);
            return Success;
	}
    for (i = 0; i < stuff->nElts; i++)
	mouse->button->map[i + 1] = map[i];
d1533 1
a1533 2
        (stuff->firstKeyCode > curKeySyms->maxKeyCode))
    {
d1538 1
a1538 2
	(unsigned)(curKeySyms->maxKeyCode + 1))
    {
d1588 1
a1588 1
    register unsigned long y;
d1595 3
a1597 2
int
ProcChangeKeyboardControl (ClientPtr client)
a1600 2
    DeviceIntPtr keybd = inputInfo.keyboard;
    XID *vlist;
d1604 2
a1605 3
    BITS32 vmask, index2;
    int mask, i;
    REQUEST(xChangeKeyboardControlReq);
a1606 9
    REQUEST_AT_LEAST_SIZE(xChangeKeyboardControlReq);
    vmask = stuff->mask;
    if (client->req_len != (sizeof(xChangeKeyboardControlReq)>>2)+Ones(vmask))
	return BadLength;
#ifdef XACE
    if (!XaceHook(XACE_DEVICE_ACCESS, client, keybd, TRUE))
	return BadAccess;
#endif 
    vlist = (XID *)&stuff[1];		/* first word of values */
d1608 1
a1608 2
    while (vmask)
    {
d1611 1
a1611 2
	switch (index2)
	{
d1615 1
a1615 1
	    if (t == -1)
d1617 2
a1618 2
	    else if (t < 0 || t > 100)
	    {
d1627 1
a1627 1
	    if (t == -1)
d1629 2
a1630 2
	    else if (t < 0 || t > 100)
	    {
d1639 1
a1639 1
	    if (t == -1)
d1641 2
a1642 2
	    else if (t < 0)
	    {
d1653 1
a1653 2
	    else if (t < 0)
	    {
d1662 1
a1662 2
	    if (led < 1 || led > 32)
	    {
d1666 1
a1666 1
	    if (!(stuff->mask & KBLedMode))
d1672 1
a1672 2
	    if (t == LedModeOff)
	    {
d1678 1
a1678 2
	    else if (t == LedModeOn)
	    {
d1684 1
a1684 2
	    else
	    {
d1689 4
a1692 4
	    if (!noXkbExtension) {
		XkbEventCauseRec	cause;
		XkbSetCauseCoreReq(&cause,X_ChangeKeyboardControl,client);
		XkbSetIndicators(keybd,((led == DO_ALL) ? ~0L : (1L<<(led-1))),
d1694 2
a1695 2
		ctrl.leds = keybd->kbdfeed->ctrl.leds;
	    }
d1702 1
a1702 2
		(KeyCode)key > inputInfo.keyboard->key->curKeySyms.maxKeyCode)
	    {
d1706 1
a1706 1
	    if (!(stuff->mask & KBAutoRepeatMode))
d1715 2
a1716 2
	    if (!noXkbExtension && key != DO_ALL)
		XkbDisableComputedAutoRepeats(keybd,key);
d1718 1
a1718 2
	    if (t == AutoRepeatModeOff)
	    {
d1724 1
a1724 2
	    else if (t == AutoRepeatModeOn)
	    {
d1730 1
a1730 2
	    else if (t == AutoRepeatModeDefault)
	    {
d1738 1
a1738 2
	    else
	    {
d1744 1
a1744 1
	    client->errorValue = stuff->mask;
d1749 1
d1753 2
a1754 3
    if (!noXkbExtension) {
	XkbSetRepeatKeys(keybd,key,keybd->kbdfeed->ctrl.autoRepeat);
    }
d1757 2
a1758 1
    (*keybd->kbdfeed->CtrlProc)(keybd, &keybd->kbdfeed->ctrl);
d1760 1
d1765 37
d1805 1
a1805 1
    register KeybdCtrl *ctrl = &inputInfo.keyboard->kbdfeed->ctrl;
d1827 1
a1827 1
    register DeviceIntPtr keybd = inputInfo.keyboard;
d1832 5
a1836 2
    if (stuff->percent < -100 || stuff->percent > 100)
    {
d1840 1
d1846 4
d1851 10
a1860 7
    if (!noXkbExtension)
	XkbHandleBell(FALSE,FALSE, keybd, newpercent, &keybd->kbdfeed->ctrl, 0, 
		      None, NULL, client);
	else
#endif
    (*keybd->kbdfeed->BellProc)(newpercent, keybd,
				(pointer) &keybd->kbdfeed->ctrl, 0);
d1872 4
d1877 1
a1877 2
    if ((stuff->doAccel != xTrue) && (stuff->doAccel != xFalse))
    {
d1881 1
a1881 2
    if ((stuff->doThresh != xTrue) && (stuff->doThresh != xFalse))
    {
d1885 2
a1886 3
    if (stuff->doAccel)
    {
	if (stuff->accelNum == -1)
d1888 2
a1889 2
	else if (stuff->accelNum < 0)
	{
d1893 5
a1897 2
	else ctrl.num = stuff->accelNum;
	if (stuff->accelDenum == -1)
d1899 2
a1900 2
	else if (stuff->accelDenum <= 0)
	{
d1904 3
a1906 1
	else ctrl.den = stuff->accelDenum;
d1908 2
a1909 3
    if (stuff->doThresh)
    {
	if (stuff->threshold == -1)
d1911 2
a1912 2
	else if (stuff->threshold < 0)
	{
d1916 12
a1927 1
	else ctrl.threshold = stuff->threshold;
d1929 1
a1929 2
    mouse->ptrfeed->ctrl = ctrl;
    (*mouse->ptrfeed->CtrlProc)(mouse, &mouse->ptrfeed->ctrl);
d1936 1
a1936 1
    register PtrCtrl *ctrl = &inputInfo.pointer->ptrfeed->ctrl;
d1951 1
a1951 1
MaybeStopHint(register DeviceIntPtr dev, ClientPtr client)
d1972 1
a1972 1
    int     i, count, xmin, xmax, ymin, ymax;
d1979 3
a1981 3
    pWin = SecurityLookupWindow(stuff->window, client, TRUE);
    if (!pWin)
	return BadWindow;
d2044 5
a2048 3
#ifdef XACE
    if (!XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard, TRUE))
    {
d2050 1
a2050 5
    }
    else
#endif
    for (i = 0; i<32; i++)
	rep.map[i] = down[i];
@


1.1
log
@Initial revision
@
text
@d371 4
a374 2
	device->name = (char *)xalloc(strlen(p) + 1);
	strcpy(device->name, p);
d396 3
a398 2
	device->name = (char *)xalloc(strlen(k) + 1);
	strcpy(device->name, k);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d70 1
a70 1
#include <xkbsrv.h>
d72 1
d74 1
a79 19
#include <X11/extensions/XI.h>
#include <X11/extensions/XIproto.h>
#include "exglobals.h"
#include "exevents.h"

/** @@file
 * This file handles input device-related stuff.
 */

int CoreDevicePrivatesIndex = 0;
static int CoreDevicePrivatesGeneration = -1;

/**
 * Create a new input device and init it to sane values. The device is added
 * to the server's off_devices list.
 *
 * @@param deviceProc Callback for device control function (switch dev on/off).
 * @@return The newly created device.
 */
d83 1
a83 13
    DeviceIntPtr dev, *prev; /* not a typo */
    DeviceIntPtr devtmp;
    int devid;
    char devind[MAX_DEVICES];

    /* Find next available id */
    memset(devind, 0, sizeof(char)*MAX_DEVICES);
    for (devtmp = inputInfo.devices; devtmp; devtmp = devtmp->next)
	devind[devtmp->id]++;
    for (devtmp = inputInfo.off_devices; devtmp; devtmp = devtmp->next)
	devind[devtmp->id]++;
    for (devid = 0; devid < MAX_DEVICES && devind[devid]; devid++)
	;
d85 1
a85 1
    if (devid >= MAX_DEVICES)
d87 1
a87 1
    dev = (DeviceIntPtr) xcalloc(sizeof(DeviceIntRec), 1);
d92 1
a92 1
    dev->id = devid;
a112 1
    dev->absolute = (AbsoluteClassPtr)NULL;
d119 1
d121 1
a121 1
    dev->xkb_interest = NULL;
a122 1
    dev->config_info = NULL;
d126 1
a126 9
    dev->coreEvents = TRUE;
    dev->inited = FALSE;
    dev->enabled = FALSE;

    for (prev = &inputInfo.off_devices; *prev; prev = &(*prev)->next)
        ;
    *prev = dev;
    dev->next = NULL;

a129 9
/**
 * Switch device ON through the driver and push it onto the global device
 * list. All clients are notified about the device being enabled.
 *
 * A device will send events once enabled.
 *
 * @@param The device to be enabled.
 * @@return TRUE on success or FALSE otherwise.
 */
d131 1
a131 1
EnableDevice(DeviceIntPtr dev)
d133 1
a133 4
    DeviceIntPtr *prev;
    int ret;
    DeviceIntRec dummyDev;
    devicePresenceNotify ev;
d140 1
a140 2
	((ret = (*dev->deviceProc)(dev, DEVICE_ON)) != Success)) {
        ErrorF("couldn't enable device %d\n", dev->id);
a141 2
    }
    dev->enabled = TRUE;
d143 2
a144 14

    for (prev = &inputInfo.devices; *prev; prev = &(*prev)->next)
        ;
    *prev = dev;
    dev->next = NULL;

    ev.type = DevicePresenceNotify;
    ev.time = currentTime.milliseconds;
    ev.devchange = DeviceEnabled;
    ev.deviceid = dev->id;
    dummyDev.id = 0;
    SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                          (xEvent *) &ev, 1);

a147 7
/**
 * Switch a device off through the driver and push it onto the off_devices
 * list. A device will not send events while disabled. All clients are
 * notified about the device being disabled.
 *
 * @@return TRUE on success or FALSE otherwise.
 */
d149 1
a149 1
DisableDevice(DeviceIntPtr dev)
d151 1
a151 3
    DeviceIntPtr *prev;
    DeviceIntRec dummyDev;
    devicePresenceNotify ev;
a159 1
    dev->enabled = FALSE;
a162 9

    ev.type = DevicePresenceNotify;
    ev.time = currentTime.milliseconds;
    ev.devchange = DeviceDisabled;
    ev.deviceid = dev->id;
    dummyDev.id = 0;
    SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                          (xEvent *) &ev, 1);

a165 219
/**
 * Initialise a new device through the driver and tell all clients about the
 * new device.
 * 
 * The device will NOT send events until it is enabled!
 *
 * @@return Success or an error code on failure.
 */
int
ActivateDevice(DeviceIntPtr dev)
{
    int ret = Success;
    devicePresenceNotify ev;
    DeviceIntRec dummyDev;

    if (!dev || !dev->deviceProc)
        return BadImplementation;

    ret = (*dev->deviceProc) (dev, DEVICE_INIT);
    dev->inited = (ret == Success);
    
    ev.type = DevicePresenceNotify;
    ev.time = currentTime.milliseconds;
    ev.devchange = DeviceAdded;
    ev.deviceid = dev->id;
    dummyDev.id = 0;
    SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                          (xEvent *) &ev, 1);

    return ret;
}

/**
 * Ring the bell.
 * The actual task of ringing the bell is the job of the DDX.
 */
static void
CoreKeyboardBell(int volume, DeviceIntPtr pDev, pointer arg, int something)
{
    KeybdCtrl *ctrl = arg;

    DDXRingBell(volume, ctrl->bell_pitch, ctrl->bell_duration);
}

static void
CoreKeyboardCtl(DeviceIntPtr pDev, KeybdCtrl *ctrl)
{
    return;
}

/**
 * Device control function for the Virtual Core Keyboard. 
 */
static int
CoreKeyboardProc(DeviceIntPtr pDev, int what)
{
    CARD8 *modMap;
    KeySymsRec keySyms;
#ifdef XKB
    XkbComponentNamesRec names;
#endif

    switch (what) {
    case DEVICE_INIT:
        keySyms.minKeyCode = 8;
        keySyms.maxKeyCode = 255;
        keySyms.mapWidth = 4;
        keySyms.map = (KeySym *)xcalloc(sizeof(KeySym),
                                        (keySyms.maxKeyCode -
                                         keySyms.minKeyCode + 1) *
                                        keySyms.mapWidth);
        if (!keySyms.map) {
            ErrorF("Couldn't allocate core keymap\n");
            return BadAlloc;
        }

        modMap = (CARD8 *)xalloc(MAP_LENGTH);
        if (!modMap) {
            ErrorF("Couldn't allocate core modifier map\n");
            return BadAlloc;
        }
        bzero((char *)modMap, MAP_LENGTH);

#ifdef XKB
        if (!noXkbExtension) {
            bzero(&names, sizeof(names));
            XkbSetRulesDflts("base", "pc105", "us", NULL, NULL);
            XkbInitKeyboardDeviceStruct(pDev, &names, &keySyms, modMap,
                                        CoreKeyboardBell, CoreKeyboardCtl);
        }
        else
#endif
        {
            /* FIXME Our keymap here isn't exactly useful. */
            InitKeyboardDeviceStruct((DevicePtr)pDev, &keySyms, modMap,
                                     CoreKeyboardBell, CoreKeyboardCtl);
        }

        xfree(keySyms.map);
        xfree(modMap);

        break;

    case DEVICE_CLOSE:
        pDev->devPrivates[CoreDevicePrivatesIndex].ptr = NULL;
        break;

    default:
        break;
    }
    return Success;
}

/**
 * Device control function for the Virtual Core Pointer.
 */
static int
CorePointerProc(DeviceIntPtr pDev, int what)
{
    BYTE map[33];
    int i = 0;

    switch (what) {
    case DEVICE_INIT:
        for (i = 1; i <= 32; i++)
            map[i] = i;
        InitPointerDeviceStruct((DevicePtr)pDev, map, 32,
                                GetMotionHistory, (PtrCtrlProcPtr)NoopDDA,
                                GetMotionHistorySize(), 2);
        pDev->valuator->axisVal[0] = screenInfo.screens[0]->width / 2;
        pDev->valuator->lastx = pDev->valuator->axisVal[0];
        pDev->valuator->axisVal[1] = screenInfo.screens[0]->height / 2;
        pDev->valuator->lasty = pDev->valuator->axisVal[1];
        break;

    case DEVICE_CLOSE:
        pDev->devPrivates[CoreDevicePrivatesIndex].ptr = NULL;
        break;

    default:
        break;
    }

    return Success;
}

/**
 * Initialise the two core devices, VCP and VCK (see events.c).
 * The devices are activated but not enabled.
 * Note that the server MUST have two core devices at all times, even if there
 * is no physical device connected.
 */
void
InitCoreDevices(void)
{
    DeviceIntPtr dev;

    if (CoreDevicePrivatesGeneration != serverGeneration) {
        CoreDevicePrivatesIndex = AllocateDevicePrivateIndex();
        CoreDevicePrivatesGeneration = serverGeneration;
    }

    if (!inputInfo.keyboard) {
        dev = AddInputDevice(CoreKeyboardProc, TRUE);
        if (!dev)
            FatalError("Failed to allocate core keyboard");
        dev->name = strdup("Virtual core keyboard");
#ifdef XKB
        dev->public.processInputProc = CoreProcessKeyboardEvent;
        dev->public.realInputProc = CoreProcessKeyboardEvent;
        if (!noXkbExtension)
           XkbSetExtension(dev, ProcessKeyboardEvent);
#else
        dev->public.processInputProc = ProcessKeyboardEvent;
        dev->public.realInputProc = ProcessKeyboardEvent;
#endif
        dev->ActivateGrab = ActivateKeyboardGrab;
        dev->DeactivateGrab = DeactivateKeyboardGrab;
        dev->coreEvents = FALSE;
        if (!AllocateDevicePrivate(dev, CoreDevicePrivatesIndex))
            FatalError("Couldn't allocate keyboard devPrivates\n");
        dev->devPrivates[CoreDevicePrivatesIndex].ptr = NULL;
        (void)ActivateDevice(dev);
        inputInfo.keyboard = dev;
    }

    if (!inputInfo.pointer) {
        dev = AddInputDevice(CorePointerProc, TRUE);
        if (!dev)
            FatalError("Failed to allocate core pointer");
        dev->name = strdup("Virtual core pointer");
#ifdef XKB
        dev->public.processInputProc = CoreProcessPointerEvent;
        dev->public.realInputProc = CoreProcessPointerEvent;
        if (!noXkbExtension)
           XkbSetExtension(dev, ProcessPointerEvent);
#else
        dev->public.processInputProc = ProcessPointerEvent;
        dev->public.realInputProc = ProcessPointerEvent;
#endif
        dev->ActivateGrab = ActivatePointerGrab;
        dev->DeactivateGrab = DeactivatePointerGrab;
        dev->coreEvents = FALSE;
        if (!AllocateDevicePrivate(dev, CoreDevicePrivatesIndex))
            FatalError("Couldn't allocate pointer devPrivates\n");
        dev->devPrivates[CoreDevicePrivatesIndex].ptr = NULL;
        (void)ActivateDevice(dev);
        inputInfo.pointer = dev;
    }
}

/**
 * Activate all switched-off devices and then enable all those devices.
 * 
 * Will return an error if no core keyboard or core pointer is present.
 * In theory this should never happen if you call InitCoreDevices() first.
 * 
 * @@return Success or error code on failure.
 */
d167 1
a167 1
InitAndStartDevices(void)
d169 1
a169 1
    DeviceIntPtr dev, next;
d171 2
a172 4
    for (dev = inputInfo.off_devices; dev; dev = dev->next) {
        DebugF("(dix) initialising device %d\n", dev->id);
	ActivateDevice(dev);
    }
a174 1
        DebugF("(dix) enabling device %d\n", dev->id);
a197 7
/**
 * Close down a device and free all resources. 
 * Once closed down, the driver will probably not expect you that you'll ever
 * enable it again and free associated structs. If you want the device to just
 * be disabled, DisableDevice().
 * Don't call this function directly, use RemoveDevice() instead.
 */
d199 1
a199 1
CloseDevice(DeviceIntPtr dev)
a209 1

d211 2
a212 2

    if (dev->key) {
d221 1
a221 10

    if (dev->valuator) {
        /* Counterpart to 'biggest hack ever' in init. */
        if (dev->valuator->motion &&
            dev->valuator->GetMotionProc == GetMotionHistory)
            xfree(dev->valuator->motion);
        xfree(dev->valuator);
    }

    if (dev->button) {
d223 2
a224 2
        if (dev->button->xkb_acts)
            xfree(dev->button->xkb_acts);
d226 3
a228 4
        xfree(dev->button);
    }

    if (dev->focus) {
d232 3
a234 5

    if (dev->proximity)
        xfree(dev->proximity);

    for (k = dev->kbdfeed; k; k = knext) {
d242 2
a243 2

    for (p = dev->ptrfeed; p; p = pnext) {
d247 2
a248 2
    
    for (i = dev->intfeed; i; i = inext) {
d252 2
a253 2

    for (s = dev->stringfeed; s; s = snext) {
d259 2
a260 2

    for (b = dev->bell; b; b = bnext) {
d264 2
a265 2

    for (l = dev->leds; l; l = lnext) {
a272 1

d274 1
a274 1
    while (dev->xkb_interest)
d276 1
a277 4

    if (dev->devPrivates)
	xfree(dev->devPrivates);

a281 4
/**
 * Shut down all devices, free all resources, etc. 
 * Only useful if you're shutting down the server!
 */
d283 1
a283 1
CloseDownDevices(void)
d285 1
a285 1
    DeviceIntPtr dev, next;
d303 2
a304 8
/**
 * Remove a device from the device list, closes it and thus frees all
 * resources. 
 * Removes both enabled and disabled devices and notifies all devices about
 * the removal of the device.
 */
int
RemoveDevice(DeviceIntPtr dev)
d306 1
a306 7
    DeviceIntPtr prev,tmp,next;
    int ret = BadMatch;
    devicePresenceNotify ev;
    DeviceIntRec dummyDev;
    int deviceid;

    DebugF("(dix) removing device %d\n", dev->id);
d308 2
a309 8
    if (!dev || dev == inputInfo.keyboard || dev == inputInfo.pointer)
        return BadImplementation;

    deviceid = dev->id;
    DisableDevice(dev);

    prev = NULL;
    for (tmp = inputInfo.devices; tmp; (prev = tmp), (tmp = next)) {
d311 1
a311 1
	if (tmp == dev) {
a312 1

d317 6
a322 2

	    ret = Success;
d326 2
a327 2
    prev = NULL;
    for (tmp = inputInfo.off_devices; tmp; (prev = tmp), (tmp = next)) {
d329 1
a329 1
	if (tmp == dev) {
d331 1
a331 2

	    if (prev == NULL)
d335 6
a340 2

            ret = Success;
d343 2
a344 13
    
    if (ret == Success) {
        inputInfo.numDevices--;
        ev.type = DevicePresenceNotify;
        ev.time = currentTime.milliseconds;
        ev.devchange = DeviceRemoved;
        ev.deviceid = deviceid;
        dummyDev.id = 0;
        SendEventToAllWindows(&dummyDev, DevicePresenceNotifyMask,
                              (xEvent *) &ev, 1);
    }

    return ret;
d348 1
a348 1
NumMotionEvents(void)
d356 18
a373 1
    RegisterOtherDevice(device);
d379 18
a396 1
    RegisterOtherDevice(device);
d400 1
a400 1
LookupKeyboardDevice(void)
d406 1
a406 1
LookupPointerDevice(void)
d437 1
a437 1
SetKeySymsMap(KeySymsPtr dst, KeySymsPtr src)
d441 1
a442 1
    /* if keysym map size changes, grow map first */
d486 1
a486 1
InitModMap(KeyClassPtr keyc)
d531 2
a532 2
    KeyClassPtr keyc;
    
a547 1
    bzero((char *)keyc->postdown, DOWN_LENGTH);
d566 1
a566 1
InitButtonClassDeviceStruct(DeviceIntPtr dev, int numButtons, 
d569 1
a569 1
    ButtonClassPtr butc;
d595 1
a595 4
    ValuatorClassPtr valc;

    if (!dev)
        return FALSE;
a601 4

    valc->motion = NULL;
    valc->first_motion = 0;
    valc->last_motion = 0;
a602 1

d609 2
a610 4
    valc->lastx = 0;
    valc->lasty = 0;
    valc->dxremaind = 0;
    valc->dyremaind = 0;
a611 40

    /* biggest hack ever. */
    if (motionProc == GetMotionHistory)
        AllocateMotionHistory(dev);

    for (i=0; i<numAxes; i++) {
        InitValuatorAxisStruct(dev, i, 0, -1, 0, 0, 0);
	valc->axisVal[i]=0;
    }
    return TRUE;
}

_X_EXPORT Bool
InitAbsoluteClassDeviceStruct(DeviceIntPtr dev)
{
    AbsoluteClassPtr abs;

    abs = (AbsoluteClassPtr)xalloc(sizeof(AbsoluteClassRec));
    if (!abs)
        return FALSE;

    /* we don't do anything sensible with these, but should */
    abs->min_x = -1;
    abs->min_y = -1;
    abs->max_x = -1;
    abs->max_y = -1;
    abs->flip_x = 0;
    abs->flip_y = 0;
    abs->rotation = 0;
    abs->button_threshold = 0;

    abs->offset_x = 0;
    abs->offset_y = 0;
    abs->width = -1;
    abs->height = -1;
    abs->following = 0;
    abs->screen = 0;

    dev->absolute = abs;

d618 1
a618 1
    FocusClassPtr focc;
d637 1
a637 1
    KbdFeedbackPtr feedc;
d664 1
a664 1
    PtrFeedbackPtr feedc;
d680 1
a680 1
static LedCtrl defaultLedControl = {
d683 1
a683 1
static BellCtrl defaultBellControl = {
d689 1
a689 1
static IntegerCtrl defaultIntegerControl = {
d702 1
a702 1
    StringFeedbackPtr feedc;
d740 1
a740 1
    BellFeedbackPtr feedc;
d759 1
a759 1
    LedFeedbackPtr feedc;
d780 1
a780 1
    IntegerFeedbackPtr feedc;
d798 1
a798 2
                        PtrCtrlProcPtr controlProc, int numMotionEvents,
                        int numAxes)
d803 1
a803 1
	   InitValuatorClassDeviceStruct(dev, numAxes, motionProc,
d865 1
a865 1
BadDeviceMap(BYTE *buff, int length, unsigned low, unsigned high, XID *errval)
d867 1
a867 1
    int i, j;
d889 2
a890 2
    DeviceIntPtr dev;
    CARD8 *map1, *map2;
d893 2
a894 2
    int i, j, k;
    CARD8 *down = dev->key->down;
a911 71
static int
DoSetModifierMapping(ClientPtr client, KeyCode *inputMap,
                     int numKeyPerModifier)
{
    DeviceIntPtr pDev = NULL;
    int i = 0, inputMapLen = numKeyPerModifier * 8;

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key) {
            for (i = 0; i < inputMapLen; i++) {
                /* Check that all the new modifiers fall within the advertised
                 * keycode range, and are okay with the DDX. */
                if (inputMap[i] && ((inputMap[i] < pDev->key->curKeySyms.minKeyCode ||
                                    inputMap[i] > pDev->key->curKeySyms.maxKeyCode) ||
                                    !LegalModifier(inputMap[i], pDev))) {
                    client->errorValue = inputMap[i];
                    return BadValue;
                }
            }

            if (!XaceHook(XACE_DEVICE_ACCESS, client, pDev, TRUE))
                return BadAccess;

            /* None of the modifiers (old or new) may be down while we change
             * the map. */
            if (!AllModifierKeysAreUp(pDev, pDev->key->modifierKeyMap,
                                      pDev->key->maxKeysPerModifier,
                                      inputMap, numKeyPerModifier) ||
                !AllModifierKeysAreUp(pDev, inputMap, numKeyPerModifier,
                                      pDev->key->modifierKeyMap,
                                      pDev->key->maxKeysPerModifier)) {
                return MappingBusy;
            }
        }
    }

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {

        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key) {
            bzero(pDev->key->modifierMap, MAP_LENGTH);

            /* Annoyingly, we lack a modifierKeyMap size, so we have to just free
             * and re-alloc it every time. */
            if (pDev->key->modifierKeyMap)
                xfree(pDev->key->modifierKeyMap);

            if (inputMapLen) {
                pDev->key->modifierKeyMap = (KeyCode *) xalloc(inputMapLen);
                if (!pDev->key->modifierKeyMap)
                    return BadAlloc;

                memcpy(pDev->key->modifierKeyMap, inputMap, inputMapLen);
                pDev->key->maxKeysPerModifier = numKeyPerModifier;

                for (i = 0; i < inputMapLen; i++) {
                    if (inputMap[i]) {
                        pDev->key->modifierMap[inputMap[i]] |=
                            (1 << (((unsigned int)i) / numKeyPerModifier));
                    }
                }
            }
            else {
                pDev->key->modifierKeyMap = NULL;
                pDev->key->maxKeysPerModifier = 0;
            }
        }
    }

    return Success;
}

d917 5
d925 2
a926 2
    if (client->req_len != ((stuff->numKeyPerModifier << 1) +
			    (sizeof (xSetModifierMappingReq) >> 2)))
d929 25
d957 1
d959 55
a1013 2
    rep.success = DoSetModifierMapping(client, (KeyCode *)&stuff[1],
                                       stuff->numKeyPerModifier);
a1014 2
    /* FIXME: Send mapping notifies for all the extended devices as well. */
    SendMappingNotify(MappingModifier, 0, 0, client);
d1016 2
a1017 1
    return client->noClientException;
d1024 1
a1024 1
    KeyClassPtr keyc = inputInfo.keyboard->key;
d1047 1
a1047 2
    KeySymsPtr curKeySyms = &inputInfo.keyboard->key->curKeySyms;
    DeviceIntPtr pDev = NULL;
a1052 1

d1054 2
a1055 1
	(stuff->firstKeyCode > curKeySyms->maxKeyCode)) {
a1057 1

d1059 4
a1062 2
    if (((unsigned)(stuff->firstKeyCode + stuff->keyCodes - 1) >
        curKeySyms->maxKeyCode) || (stuff->keySymsPerKeyCode == 0)) {
d1066 4
a1069 8

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key) {
            if (!XaceHook(XACE_DEVICE_ACCESS, client, pDev, TRUE))
                return BadAccess;
        }
    }

d1074 2
a1075 8
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key) {
            if (!SetKeySymsMap(&pDev->key->curKeySyms, &keysyms))
                return BadAlloc;
        }
    }

    /* FIXME: Send mapping notifies for all the extended devices as well. */
d1077 1
a1077 1
                      client);
a1078 7
}

static int
DoSetPointerMapping(DeviceIntPtr device, BYTE *map, int n)
{
    int i = 0;
    DeviceIntPtr dev = NULL;
a1079 22
    if (!device || !device->button)
        return BadDevice;

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if ((dev->coreEvents || dev == inputInfo.pointer) && dev->button) {
            for (i = 0; i < n; i++) {
                if ((device->button->map[i + 1] != map[i]) &&
                    BitIsOn(device->button->down, i + 1)) {
                    return MappingBusy;
                }
            }
        }
    }

    for (dev = inputInfo.devices; dev; dev = dev->next) {
        if ((dev->coreEvents || dev == inputInfo.pointer) && dev->button) {
            for (i = 0; i < n; i++)
                dev->button->map[i + 1] = map[i];
        }
    }

    return Success;
a1086 1
    int ret;
d1088 2
d1099 2
a1100 4
    
    /* So we're bounded here by the number of core buttons.  This check
     * probably wants disabling through XFixes. */
    if (stuff->nElts != inputInfo.pointer->button->numButtons) {
d1106 10
a1115 9

    ret = DoSetPointerMapping(inputInfo.pointer, map, stuff->nElts);
    if (ret != Success) {
        rep.success = ret;
        WriteReplyToClient(client, sizeof(xSetPointerMappingReply), &rep);
        return Success;
    }

    /* FIXME: Send mapping notifies for all the extended devices as well. */
d1131 2
a1132 1
        (stuff->firstKeyCode > curKeySyms->maxKeyCode)) {
d1137 2
a1138 1
	(unsigned)(curKeySyms->maxKeyCode + 1)) {
d1188 1
a1188 1
    unsigned long y;
d1195 2
a1196 3
static int
DoChangeKeyboardControl (ClientPtr client, DeviceIntPtr keybd, XID *vlist,
                         BITS32 vmask)
d1200 2
d1205 3
a1207 2
    BITS32 index2;
    int mask = vmask, i;
d1209 9
d1219 2
a1220 1
    while (vmask) {
d1223 2
a1224 1
	switch (index2) {
d1228 1
a1228 1
	    if (t == -1) {
d1230 2
a1231 2
            }
	    else if (t < 0 || t > 100) {
d1240 1
a1240 1
	    if (t == -1) {
d1242 2
a1243 2
            }
	    else if (t < 0 || t > 100) {
d1252 1
a1252 1
	    if (t == -1) {
d1254 2
a1255 2
            }
	    else if (t < 0) {
d1266 2
a1267 1
	    else if (t < 0) {
d1276 2
a1277 1
	    if (led < 1 || led > 32) {
d1281 1
a1281 1
	    if (!(mask & KBLedMode))
d1287 2
a1288 1
	    if (t == LedModeOff) {
d1294 2
a1295 1
	    else if (t == LedModeOn) {
d1301 2
a1302 1
	    else {
d1307 4
a1310 4
            if (!noXkbExtension) {
                XkbEventCauseRec cause;
                XkbSetCauseCoreReq(&cause,X_ChangeKeyboardControl,client);
                XkbSetIndicators(keybd,((led == DO_ALL) ? ~0L : (1L<<(led-1))),
d1312 2
a1313 2
                ctrl.leds = keybd->kbdfeed->ctrl.leds;
            }
d1320 2
a1321 1
		(KeyCode)key > inputInfo.keyboard->key->curKeySyms.maxKeyCode) {
d1325 1
a1325 1
	    if (!(mask & KBAutoRepeatMode))
d1334 2
a1335 2
            if (!noXkbExtension && key != DO_ALL)
                XkbDisableComputedAutoRepeats(keybd,key);
d1337 2
a1338 1
	    if (t == AutoRepeatModeOff) {
d1344 2
a1345 1
	    else if (t == AutoRepeatModeOn) {
d1351 2
a1352 1
	    else if (t == AutoRepeatModeDefault) {
d1360 2
a1361 1
	    else {
d1367 1
a1367 1
	    client->errorValue = mask;
a1371 1

d1375 3
a1377 2
    if (!noXkbExtension)
        XkbSetRepeatKeys(keybd, key, keybd->kbdfeed->ctrl.autoRepeat);
d1380 1
a1380 2
        (*keybd->kbdfeed->CtrlProc)(keybd, &keybd->kbdfeed->ctrl);

a1381 1

a1385 37
ProcChangeKeyboardControl (ClientPtr client)
{
    XID *vlist;
    BITS32 vmask;
    int ret = Success, error = Success;
    DeviceIntPtr pDev = NULL;
    REQUEST(xChangeKeyboardControlReq);

    REQUEST_AT_LEAST_SIZE(xChangeKeyboardControlReq);

    vmask = stuff->mask;
    vlist = (XID *)&stuff[1];

    if (client->req_len != (sizeof(xChangeKeyboardControlReq)>>2)+Ones(vmask))
	return BadLength;

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) &&
            pDev->kbdfeed && pDev->kbdfeed->CtrlProc) {
            if (!XaceHook(XACE_DEVICE_ACCESS, client, pDev, TRUE))
                return BadAccess;
        }
    }

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) &&
            pDev->kbdfeed && pDev->kbdfeed->CtrlProc) {
            ret = DoChangeKeyboardControl(client, pDev, vlist, vmask);
            if (ret != Success)
                error = ret;
        }
    }

    return error;
}

int
d1389 1
a1389 1
    KeybdCtrl *ctrl = &inputInfo.keyboard->kbdfeed->ctrl;
d1411 1
a1411 1
    DeviceIntPtr keybd = inputInfo.keyboard;
d1416 2
a1417 5

    if (!keybd->kbdfeed->BellProc)
        return BadDevice;
    
    if (stuff->percent < -100 || stuff->percent > 100) {
a1420 1

a1425 4

    for (keybd = inputInfo.devices; keybd; keybd = keybd->next) {
        if ((keybd->coreEvents || keybd == inputInfo.keyboard) &&
            keybd->kbdfeed && keybd->kbdfeed->BellProc) {
d1427 7
a1433 10
            if (!noXkbExtension)
                XkbHandleBell(FALSE, FALSE, keybd, newpercent,
                              &keybd->kbdfeed->ctrl, 0, None, NULL, client);
            else
#endif
                (*keybd->kbdfeed->BellProc)(newpercent, keybd,
                                            &keybd->kbdfeed->ctrl, 0);
        }
    }

a1444 4
    
    if (!mouse->ptrfeed->CtrlProc)
        return BadDevice;
    
d1446 2
a1447 1
    if ((stuff->doAccel != xTrue) && (stuff->doAccel != xFalse)) {
d1451 2
a1452 1
    if ((stuff->doThresh != xTrue) && (stuff->doThresh != xFalse)) {
d1456 3
a1458 2
    if (stuff->doAccel) {
	if (stuff->accelNum == -1) {
d1460 2
a1461 2
        }
	else if (stuff->accelNum < 0) {
d1465 2
a1466 5
	else {
            ctrl.num = stuff->accelNum;
        }

	if (stuff->accelDenum == -1) {
d1468 2
a1469 2
        }
	else if (stuff->accelDenum <= 0) {
d1473 1
a1473 3
	else {
            ctrl.den = stuff->accelDenum;
        }
d1475 3
a1477 2
    if (stuff->doThresh) {
	if (stuff->threshold == -1) {
d1479 2
a1480 2
        }
	else if (stuff->threshold < 0) {
d1484 1
a1484 12
	else {
            ctrl.threshold = stuff->threshold;
        }
    }


    for (mouse = inputInfo.devices; mouse; mouse = mouse->next) {
        if ((mouse->coreEvents || mouse == inputInfo.pointer) &&
            mouse->ptrfeed && mouse->ptrfeed->CtrlProc) {
            mouse->ptrfeed->ctrl = ctrl;
            (*mouse->ptrfeed->CtrlProc)(mouse, &mouse->ptrfeed->ctrl);
        }
d1486 2
a1487 1

d1494 1
a1494 1
    PtrCtrl *ctrl = &inputInfo.pointer->ptrfeed->ctrl;
d1509 1
a1509 1
MaybeStopHint(DeviceIntPtr dev, ClientPtr client)
d1530 1
a1530 1
    int i, count, xmin, xmax, ymin, ymax, rc;
d1537 3
a1539 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
    if (rc != Success)
	return rc;
d1602 5
a1606 4

    if (XaceHook(XACE_DEVICE_ACCESS, client, inputInfo.keyboard, TRUE))
	for (i = 0; i<32; i++)
	    rep.map[i] = down[i];
d1608 3
a1610 2
	bzero((char *)&rep.map[0], 32);

@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@a530 1
        dev->key->xkbInfo = NULL;
d1211 4
a1214 3
	((request == MappingKeyboard) || (request == MappingModifier)))
        XkbApplyMappingChange(inputInfo.keyboard, request, firstKeyCode, count,
                              client);
a1361 1
    DeviceIntPtr dev;
d1377 1
a1378 3
    for (dev = inputInfo.devices; dev; dev = dev->next)
        if (dev->key && dev->coreEvents)
            SendDeviceMappingNotify(client, MappingModifier, 0, 0, dev);
d1441 2
a1442 2
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
        if ((pDev->coreEvents || pDev == inputInfo.keyboard) && pDev->key)
d1445 2
d1448 1
a1450 6
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
        if (pDev->key && pDev->coreEvents)
            SendDeviceMappingNotify(client, MappingKeyboard,
                                    stuff->firstKeyCode, stuff->keyCodes,
                                    pDev);

@


