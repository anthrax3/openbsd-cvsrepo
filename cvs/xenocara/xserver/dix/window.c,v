head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	s0SI41sEunLdyFfd;

1.15
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	Te1daavkBLskZ8gc;

1.14
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	cVXoV5PxI8YrEaVA;

1.13
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.12.08.10.53.01;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.09.28.15.36.34;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.21.20.10.46;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.02.20.21.25.15;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.30;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.30;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.27;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*

Copyright (c) 2006, Red Hat, Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,

			All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

*/

/* The panoramix components contained the following notice */
/*****************************************************************

Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "misc.h"
#include "scrnintstr.h"
#include "os.h"
#include "regionstr.h"
#include "validate.h"
#include "windowstr.h"
#include "propertyst.h"
#include "input.h"
#include "inputstr.h"
#include "resource.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "dixstruct.h"
#include "gcstruct.h"
#include "servermd.h"
#include "mivalidate.h"
#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif
#include "dixevents.h"
#include "globals.h"
#include "mi.h"                 /* miPaintWindow */
#ifdef COMPOSITE
#include "compint.h"
#endif
#include "selection.h"
#include "inpututils.h"

#include "privates.h"
#include "xace.h"
#include "exevents.h"

#include <X11/Xatom.h>          /* must come after server includes */

/******
 * Window stuff for server
 *
 *    CreateRootWindow, CreateWindow, ChangeWindowAttributes,
 *    GetWindowAttributes, DeleteWindow, DestroySubWindows,
 *    HandleSaveSet, ReparentWindow, MapWindow, MapSubWindows,
 *    UnmapWindow, UnmapSubWindows, ConfigureWindow, CirculateWindow,
 *    ChangeWindowDeviceCursor
 ******/

Bool bgNoneRoot = FALSE;

static unsigned char _back_lsb[4] = { 0x88, 0x22, 0x44, 0x11 };
static unsigned char _back_msb[4] = { 0x11, 0x44, 0x22, 0x88 };

static Bool WindowParentHasDeviceCursor(WindowPtr pWin,
                                        DeviceIntPtr pDev, CursorPtr pCurs);
static Bool

WindowSeekDeviceCursor(WindowPtr pWin,
                       DeviceIntPtr pDev,
                       DevCursNodePtr * pNode, DevCursNodePtr * pPrev);

int screenIsSaved = SCREEN_SAVER_OFF;

static Bool TileScreenSaver(ScreenPtr pScreen, int kind);

#define INPUTONLY_LEGAL_MASK (CWWinGravity | CWEventMask | \
			      CWDontPropagate | CWOverrideRedirect | CWCursor )

#define BOXES_OVERLAP(b1, b2) \
      (!( ((b1)->x2 <= (b2)->x1)  || \
	( ((b1)->x1 >= (b2)->x2)) || \
	( ((b1)->y2 <= (b2)->y1)) || \
	( ((b1)->y1 >= (b2)->y2)) ) )

#define RedirectSend(pWin) \
    ((pWin->eventMask|wOtherEventMasks(pWin)) & SubstructureRedirectMask)

#define SubSend(pWin) \
    ((pWin->eventMask|wOtherEventMasks(pWin)) & SubstructureNotifyMask)

#define StrSend(pWin) \
    ((pWin->eventMask|wOtherEventMasks(pWin)) & StructureNotifyMask)

#define SubStrSend(pWin,pParent) (StrSend(pWin) || SubSend(pParent))

#ifdef COMPOSITE
static const char *overlay_win_name = "<composite overlay>";
#endif

static const char *
get_window_name(WindowPtr pWin)
{
#define WINDOW_NAME_BUF_LEN 512
    PropertyPtr prop;
    static char buf[WINDOW_NAME_BUF_LEN];
    int len;

#ifdef COMPOSITE
    CompScreenPtr comp_screen = GetCompScreen(pWin->drawable.pScreen);

    if (comp_screen && pWin == comp_screen->pOverlayWin)
        return overlay_win_name;
#endif

    for (prop = wUserProps(pWin); prop; prop = prop->next) {
        if (prop->propertyName == XA_WM_NAME && prop->type == XA_STRING &&
            prop->data) {
            len = min(prop->size, WINDOW_NAME_BUF_LEN - 1);
            memcpy(buf, prop->data, len);
            buf[len] = '\0';
            return buf;
        }
    }

    return NULL;
#undef WINDOW_NAME_BUF_LEN
}

static void
log_window_info(WindowPtr pWin, int depth)
{
    int i;
    const char *win_name, *visibility;
    BoxPtr rects;

    for (i = 0; i < (depth << 2); i++)
        ErrorF(" ");

    win_name = get_window_name(pWin);
    ErrorF("win 0x%.8x (%s), [%d, %d] to [%d, %d]",
           (unsigned) pWin->drawable.id,
           win_name ? win_name : "no name",
           pWin->drawable.x, pWin->drawable.y,
           pWin->drawable.x + pWin->drawable.width,
           pWin->drawable.y + pWin->drawable.height);

    if (pWin->overrideRedirect)
        ErrorF(" (override redirect)");
#ifdef COMPOSITE
    if (pWin->redirectDraw)
        ErrorF(" (%s compositing: pixmap %x)",
               (pWin->redirectDraw == RedirectDrawAutomatic) ?
               "automatic" : "manual",
               (unsigned) pWin->drawable.pScreen->GetWindowPixmap(pWin)->drawable.id);
#endif

    switch (pWin->visibility) {
    case VisibilityUnobscured:
        visibility = "unobscured";
        break;
    case VisibilityPartiallyObscured:
        visibility = "partially obscured";
        break;
    case VisibilityFullyObscured:
        visibility = "fully obscured";
        break;
    case VisibilityNotViewable:
        visibility = "unviewable";
        break;
    }
    ErrorF(", %s", visibility);

    if (RegionNotEmpty(&pWin->clipList)) {
        ErrorF(", clip list:");
        rects = RegionRects(&pWin->clipList);
        for (i = 0; i < RegionNumRects(&pWin->clipList); i++)
            ErrorF(" [(%d, %d) to (%d, %d)]",
                   rects[i].x1, rects[i].y1, rects[i].x2, rects[i].y2);
        ErrorF("; extents [(%d, %d) to (%d, %d)]",
               pWin->clipList.extents.x1, pWin->clipList.extents.y1,
               pWin->clipList.extents.x2, pWin->clipList.extents.y2);
    }

    ErrorF("\n");
}

static const char*
grab_grabtype_to_text(GrabPtr pGrab)
{
    switch (pGrab->grabtype) {
        case XI2:
            return "xi2";
        case CORE:
            return "core";
        default:
            return "xi1";
    }
}

static const char*
grab_type_to_text(GrabPtr pGrab)
{
    switch (pGrab->type) {
        case ButtonPress:
            return "ButtonPress";
        case KeyPress:
            return "KeyPress";
        case XI_Enter:
            return "XI_Enter";
        case XI_FocusIn:
            return "XI_FocusIn";
        default:
            return "unknown?!";
    }
}

static void
log_grab_info(void *value, XID id, void *cdata)
{
    int i, j;
    GrabPtr pGrab = (GrabPtr)value;

    ErrorF("  grab 0x%lx (%s), type '%s' on window 0x%lx\n",
           (unsigned long) pGrab->resource,
           grab_grabtype_to_text(pGrab),
           grab_type_to_text(pGrab),
           (unsigned long) pGrab->window->drawable.id);
    ErrorF("    detail %d (mask %lu), modifiersDetail %d (mask %lu)\n",
           pGrab->detail.exact,
           pGrab->detail.pMask ? (unsigned long) *(pGrab->detail.pMask) : 0,
           pGrab->modifiersDetail.exact,
           pGrab->modifiersDetail.pMask ?
           (unsigned long) *(pGrab->modifiersDetail.pMask) :
           (unsigned long) 0);
    ErrorF("    device '%s' (%d), modifierDevice '%s' (%d)\n",
           pGrab->device->name, pGrab->device->id,
           pGrab->modifierDevice->name, pGrab->modifierDevice->id);
    if (pGrab->grabtype == CORE) {
        ErrorF("    core event mask 0x%lx\n",
               (unsigned long) pGrab->eventMask);
    }
    else if (pGrab->grabtype == XI) {
        ErrorF("    xi1 event mask 0x%lx\n",
               (unsigned long) pGrab->eventMask);
    }
    else if (pGrab->grabtype == XI2) {
        for (i = 0; i < xi2mask_num_masks(pGrab->xi2mask); i++) {
            const unsigned char *mask;
            int print;

            print = 0;
            for (j = 0; j < XI2MASKSIZE; j++) {
                mask = xi2mask_get_one_mask(pGrab->xi2mask, i);
                if (mask[j]) {
                    print = 1;
                    break;
                }
            }
            if (!print)
                continue;
            ErrorF("      xi2 event mask 0x");
            for (j = 0; j < xi2mask_mask_size(pGrab->xi2mask); j++)
                ErrorF("%x ", mask[j]);
            ErrorF("\n");
        }
    }
    ErrorF("    owner-events %s, kb %d ptr %d, confine 0x%lx, cursor 0x%lx\n",
           pGrab->ownerEvents ? "true" : "false",
           pGrab->keyboardMode, pGrab->pointerMode,
           pGrab->confineTo ? (unsigned long) pGrab->confineTo->drawable.id : 0,
           pGrab->cursor ? (unsigned long) pGrab->cursor->id : 0);
}

void
PrintPassiveGrabs(void)
{
    int i;
    LocalClientCredRec *lcc;
    pid_t clientpid;
    const char *cmdname;
    const char *cmdargs;

    ErrorF("Printing all currently registered grabs\n");

    for (i = 1; i < currentMaxClients; i++) {
        if (!clients[i] || clients[i]->clientState != ClientStateRunning)
            continue;

        clientpid = GetClientPid(clients[i]);
        cmdname = GetClientCmdName(clients[i]);
        cmdargs = GetClientCmdArgs(clients[i]);
        if ((clientpid > 0) && (cmdname != NULL)) {
            ErrorF("  Printing all registered grabs of client pid %ld %s %s\n",
                   (long) clientpid, cmdname, cmdargs ? cmdargs : "");
        } else {
            if (GetLocalClientCreds(clients[i], &lcc) == -1) {
                ErrorF("  GetLocalClientCreds() failed\n");
                continue;
            }
            ErrorF("  Printing all registered grabs of client pid %ld uid %ld gid %ld\n",
                   (lcc->fieldsSet & LCC_PID_SET) ? (long) lcc->pid : 0,
                   (lcc->fieldsSet & LCC_UID_SET) ? (long) lcc->euid : 0,
                   (lcc->fieldsSet & LCC_GID_SET) ? (long) lcc->egid : 0);
            FreeLocalClientCreds(lcc);
        }

        FindClientResourcesByType(clients[i], RT_PASSIVEGRAB, log_grab_info, NULL);
    }
    ErrorF("End list of registered passive grabs\n");
}

void
PrintWindowTree(void)
{
    int scrnum, depth;
    ScreenPtr pScreen;
    WindowPtr pWin;

    for (scrnum = 0; scrnum < screenInfo.numScreens; scrnum++) {
        pScreen = screenInfo.screens[scrnum];
        ErrorF("[dix] Dumping windows for screen %d (pixmap %x):\n", scrnum,
               (unsigned) pScreen->GetScreenPixmap(pScreen)->drawable.id);
        pWin = pScreen->root;
        depth = 1;
        while (pWin) {
            log_window_info(pWin, depth);
            if (pWin->firstChild) {
                pWin = pWin->firstChild;
                depth++;
                continue;
            }
            while (pWin && !pWin->nextSib) {
                pWin = pWin->parent;
                depth--;
            }
            if (!pWin)
                break;
            pWin = pWin->nextSib;
        }
    }
}

int
TraverseTree(WindowPtr pWin, VisitWindowProcPtr func, void *data)
{
    int result;
    WindowPtr pChild;

    if (!(pChild = pWin))
        return WT_NOMATCH;
    while (1) {
        result = (*func) (pChild, data);
        if (result == WT_STOPWALKING)
            return WT_STOPWALKING;
        if ((result == WT_WALKCHILDREN) && pChild->firstChild) {
            pChild = pChild->firstChild;
            continue;
        }
        while (!pChild->nextSib && (pChild != pWin))
            pChild = pChild->parent;
        if (pChild == pWin)
            break;
        pChild = pChild->nextSib;
    }
    return WT_NOMATCH;
}

/*****
 * WalkTree
 *   Walk the window tree, for SCREEN, preforming FUNC(pWin, data) on
 *   each window.  If FUNC returns WT_WALKCHILDREN, traverse the children,
 *   if it returns WT_DONTWALKCHILDREN, dont.  If it returns WT_STOPWALKING
 *   exit WalkTree.  Does depth-first traverse.
 *****/

int
WalkTree(ScreenPtr pScreen, VisitWindowProcPtr func, void *data)
{
    return (TraverseTree(pScreen->root, func, data));
}

/* hack for forcing backing store on all windows */
int defaultBackingStore = NotUseful;

/* hack to force no backing store */
Bool disableBackingStore = FALSE;
Bool enableBackingStore = FALSE;

static void
SetWindowToDefaults(WindowPtr pWin)
{
    pWin->prevSib = NullWindow;
    pWin->firstChild = NullWindow;
    pWin->lastChild = NullWindow;

    pWin->valdata = NULL;
    pWin->optional = NULL;
    pWin->cursorIsNone = TRUE;

    pWin->backingStore = NotUseful;
    pWin->backStorage = 0;

    pWin->mapped = FALSE;       /* off */
    pWin->realized = FALSE;     /* off */
    pWin->viewable = FALSE;
    pWin->visibility = VisibilityNotViewable;
    pWin->overrideRedirect = FALSE;
    pWin->saveUnder = FALSE;

    pWin->bitGravity = ForgetGravity;
    pWin->winGravity = NorthWestGravity;

    pWin->eventMask = 0;
    pWin->deliverableEvents = 0;
    pWin->dontPropagate = 0;
    pWin->forcedBS = FALSE;
    pWin->redirectDraw = RedirectDrawNone;
    pWin->forcedBG = FALSE;
    pWin->unhittable = FALSE;

#ifdef COMPOSITE
    pWin->damagedDescendants = FALSE;
#endif
}

static void
MakeRootTile(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    GCPtr pGC;
    unsigned char back[128];
    int len = BitmapBytePad(sizeof(long));
    unsigned char *from, *to;
    int i, j;

    pWin->background.pixmap = (*pScreen->CreatePixmap) (pScreen, 4, 4,
                                                        pScreen->rootDepth, 0);

    pWin->backgroundState = BackgroundPixmap;
    pGC = GetScratchGC(pScreen->rootDepth, pScreen);
    if (!pWin->background.pixmap || !pGC)
        FatalError("could not create root tile");

    {
        ChangeGCVal attributes[2];

        attributes[0].val = pScreen->whitePixel;
        attributes[1].val = pScreen->blackPixel;

        (void) ChangeGC(NullClient, pGC, GCForeground | GCBackground,
                        attributes);
    }

    ValidateGC((DrawablePtr) pWin->background.pixmap, pGC);

    from = (screenInfo.bitmapBitOrder == LSBFirst) ? _back_lsb : _back_msb;
    to = back;

    for (i = 4; i > 0; i--, from++)
        for (j = len; j > 0; j--)
            *to++ = *from;

    (*pGC->ops->PutImage) ((DrawablePtr) pWin->background.pixmap, pGC, 1,
                           0, 0, len, 4, 0, XYBitmap, (char *) back);

    FreeScratchGC(pGC);

}

/*****
 * CreateRootWindow
 *    Makes a window at initialization time for specified screen
 *****/

Bool
CreateRootWindow(ScreenPtr pScreen)
{
    WindowPtr pWin;
    BoxRec box;
    PixmapFormatRec *format;

    pWin = dixAllocateScreenObjectWithPrivates(pScreen, WindowRec, PRIVATE_WINDOW);
    if (!pWin)
        return FALSE;

    pScreen->screensaver.pWindow = NULL;
    pScreen->screensaver.wid = FakeClientID(0);
    pScreen->screensaver.ExternalScreenSaver = NULL;
    screenIsSaved = SCREEN_SAVER_OFF;

    pScreen->root = pWin;

    pWin->drawable.pScreen = pScreen;
    pWin->drawable.type = DRAWABLE_WINDOW;

    pWin->drawable.depth = pScreen->rootDepth;
    for (format = screenInfo.formats;
         format->depth != pScreen->rootDepth; format++);
    pWin->drawable.bitsPerPixel = format->bitsPerPixel;

    pWin->drawable.serialNumber = NEXT_SERIAL_NUMBER;

    pWin->parent = NullWindow;
    SetWindowToDefaults(pWin);

    pWin->optional = malloc(sizeof(WindowOptRec));
    if (!pWin->optional)
        return FALSE;

    pWin->optional->dontPropagateMask = 0;
    pWin->optional->otherEventMasks = 0;
    pWin->optional->otherClients = NULL;
    pWin->optional->passiveGrabs = NULL;
    pWin->optional->userProps = NULL;
    pWin->optional->backingBitPlanes = ~0L;
    pWin->optional->backingPixel = 0;
    pWin->optional->boundingShape = NULL;
    pWin->optional->clipShape = NULL;
    pWin->optional->inputShape = NULL;
    pWin->optional->inputMasks = NULL;
    pWin->optional->deviceCursors = NULL;
    pWin->optional->colormap = pScreen->defColormap;
    pWin->optional->visual = pScreen->rootVisual;

    pWin->nextSib = NullWindow;

    pWin->drawable.id = FakeClientID(0);

    pWin->origin.x = pWin->origin.y = 0;
    pWin->drawable.height = pScreen->height;
    pWin->drawable.width = pScreen->width;
    pWin->drawable.x = pWin->drawable.y = 0;

    box.x1 = 0;
    box.y1 = 0;
    box.x2 = pScreen->width;
    box.y2 = pScreen->height;
    RegionInit(&pWin->clipList, &box, 1);
    RegionInit(&pWin->winSize, &box, 1);
    RegionInit(&pWin->borderSize, &box, 1);
    RegionInit(&pWin->borderClip, &box, 1);

    pWin->drawable.class = InputOutput;
    pWin->optional->visual = pScreen->rootVisual;

    pWin->backgroundState = BackgroundPixel;
    pWin->background.pixel = pScreen->whitePixel;

    pWin->borderIsPixel = TRUE;
    pWin->border.pixel = pScreen->blackPixel;
    pWin->borderWidth = 0;

    /*  security creation/labeling check
     */
    if (XaceHook(XACE_RESOURCE_ACCESS, serverClient, pWin->drawable.id,
                 RT_WINDOW, pWin, RT_NONE, NULL, DixCreateAccess))
        return FALSE;

    if (!AddResource(pWin->drawable.id, RT_WINDOW, (void *) pWin))
        return FALSE;

    if (disableBackingStore)
        pScreen->backingStoreSupport = NotUseful;
    if (enableBackingStore)
        pScreen->backingStoreSupport = WhenMapped;
#ifdef COMPOSITE
    if (noCompositeExtension)
        pScreen->backingStoreSupport = NotUseful;
#endif

    pScreen->saveUnderSupport = NotUseful;

    return TRUE;
}

void
InitRootWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    int backFlag = CWBorderPixel | CWCursor | CWBackingStore;

    if (!(*pScreen->CreateWindow) (pWin))
        return;                 /* XXX */
    (*pScreen->PositionWindow) (pWin, 0, 0);

    pWin->cursorIsNone = FALSE;
    pWin->optional->cursor = RefCursor(rootCursor);

    if (party_like_its_1989) {
        MakeRootTile(pWin);
        backFlag |= CWBackPixmap;
    }
    else if (pScreen->canDoBGNoneRoot && bgNoneRoot) {
        pWin->backgroundState = XaceBackgroundNoneState(pWin);
        pWin->background.pixel = pScreen->whitePixel;
        backFlag |= CWBackPixmap;
    }
    else {
        pWin->backgroundState = BackgroundPixel;
        if (whiteRoot)
            pWin->background.pixel = pScreen->whitePixel;
        else
            pWin->background.pixel = pScreen->blackPixel;
        backFlag |= CWBackPixel;
    }

    pWin->backingStore = defaultBackingStore;
    pWin->forcedBS = (defaultBackingStore != NotUseful);
    /* We SHOULD check for an error value here XXX */
    (*pScreen->ChangeWindowAttributes) (pWin, backFlag);

    MapWindow(pWin, serverClient);
}

/* Set the region to the intersection of the rectangle and the
 * window's winSize.  The window is typically the parent of the
 * window from which the region came.
 */

static void
ClippedRegionFromBox(WindowPtr pWin, RegionPtr Rgn, int x, int y, int w, int h)
{
    BoxRec box = *RegionExtents(&pWin->winSize);

    /* we do these calculations to avoid overflows */
    if (x > box.x1)
        box.x1 = x;
    if (y > box.y1)
        box.y1 = y;
    x += w;
    if (x < box.x2)
        box.x2 = x;
    y += h;
    if (y < box.y2)
        box.y2 = y;
    if (box.x1 > box.x2)
        box.x2 = box.x1;
    if (box.y1 > box.y2)
        box.y2 = box.y1;
    RegionReset(Rgn, &box);
    RegionIntersect(Rgn, Rgn, &pWin->winSize);
}

static RealChildHeadProc realChildHeadProc = NULL;

void
RegisterRealChildHeadProc(RealChildHeadProc proc)
{
    realChildHeadProc = proc;
}

WindowPtr
RealChildHead(WindowPtr pWin)
{
    if (realChildHeadProc) {
        return realChildHeadProc(pWin);
    }

    if (!pWin->parent &&
        (screenIsSaved == SCREEN_SAVER_ON) &&
        (HasSaverWindow(pWin->drawable.pScreen)))
        return pWin->firstChild;
    else
        return NullWindow;
}

/*****
 * CreateWindow
 *    Makes a window in response to client request
 *****/

WindowPtr
CreateWindow(Window wid, WindowPtr pParent, int x, int y, unsigned w,
             unsigned h, unsigned bw, unsigned class, Mask vmask, XID *vlist,
             int depth, ClientPtr client, VisualID visual, int *error)
{
    WindowPtr pWin;
    WindowPtr pHead;
    ScreenPtr pScreen;
    int idepth, ivisual;
    Bool fOK;
    DepthPtr pDepth;
    PixmapFormatRec *format;
    WindowOptPtr ancwopt;

    if (class == CopyFromParent)
        class = pParent->drawable.class;

    if ((class != InputOutput) && (class != InputOnly)) {
        *error = BadValue;
        client->errorValue = class;
        return NullWindow;
    }

    if ((class != InputOnly) && (pParent->drawable.class == InputOnly)) {
        *error = BadMatch;
        return NullWindow;
    }

    if ((class == InputOnly) && ((bw != 0) || (depth != 0))) {
        *error = BadMatch;
        return NullWindow;
    }

    pScreen = pParent->drawable.pScreen;
    if ((class == InputOutput) && (depth == 0))
        depth = pParent->drawable.depth;
    ancwopt = pParent->optional;
    if (!ancwopt)
        ancwopt = FindWindowWithOptional(pParent)->optional;
    if (visual == CopyFromParent) {
        visual = ancwopt->visual;
    }

    /* Find out if the depth and visual are acceptable for this Screen */
    if ((visual != ancwopt->visual) || (depth != pParent->drawable.depth)) {
        fOK = FALSE;
        for (idepth = 0; idepth < pScreen->numDepths; idepth++) {
            pDepth = (DepthPtr) &pScreen->allowedDepths[idepth];
            if ((depth == pDepth->depth) || (depth == 0)) {
                for (ivisual = 0; ivisual < pDepth->numVids; ivisual++) {
                    if (visual == pDepth->vids[ivisual]) {
                        fOK = TRUE;
                        break;
                    }
                }
            }
        }
        if (fOK == FALSE) {
            *error = BadMatch;
            return NullWindow;
        }
    }

    if (((vmask & (CWBorderPixmap | CWBorderPixel)) == 0) &&
        (class != InputOnly) && (depth != pParent->drawable.depth)) {
        *error = BadMatch;
        return NullWindow;
    }

    if (((vmask & CWColormap) == 0) &&
        (class != InputOnly) &&
        ((visual != ancwopt->visual) || (ancwopt->colormap == None))) {
        *error = BadMatch;
        return NullWindow;
    }

    pWin = dixAllocateScreenObjectWithPrivates(pScreen, WindowRec, PRIVATE_WINDOW);
    if (!pWin) {
        *error = BadAlloc;
        return NullWindow;
    }
    pWin->drawable = pParent->drawable;
    pWin->drawable.depth = depth;
    if (depth == pParent->drawable.depth)
        pWin->drawable.bitsPerPixel = pParent->drawable.bitsPerPixel;
    else {
        for (format = screenInfo.formats; format->depth != depth; format++);
        pWin->drawable.bitsPerPixel = format->bitsPerPixel;
    }
    if (class == InputOnly)
        pWin->drawable.type = (short) UNDRAWABLE_WINDOW;
    pWin->drawable.serialNumber = NEXT_SERIAL_NUMBER;

    pWin->drawable.id = wid;
    pWin->drawable.class = class;

    pWin->parent = pParent;
    SetWindowToDefaults(pWin);

    if (visual != ancwopt->visual) {
        if (!MakeWindowOptional(pWin)) {
            dixFreeObjectWithPrivates(pWin, PRIVATE_WINDOW);
            *error = BadAlloc;
            return NullWindow;
        }
        pWin->optional->visual = visual;
        pWin->optional->colormap = None;
    }

    pWin->borderWidth = bw;

    /*  security creation/labeling check
     */
    *error = XaceHook(XACE_RESOURCE_ACCESS, client, wid, RT_WINDOW, pWin,
                      RT_WINDOW, pWin->parent,
                      DixCreateAccess | DixSetAttrAccess);
    if (*error != Success) {
        dixFreeObjectWithPrivates(pWin, PRIVATE_WINDOW);
        return NullWindow;
    }

    pWin->backgroundState = XaceBackgroundNoneState(pWin);
    pWin->background.pixel = pScreen->whitePixel;

    pWin->borderIsPixel = pParent->borderIsPixel;
    pWin->border = pParent->border;
    if (pWin->borderIsPixel == FALSE)
        pWin->border.pixmap->refcnt++;

    pWin->origin.x = x + (int) bw;
    pWin->origin.y = y + (int) bw;
    pWin->drawable.width = w;
    pWin->drawable.height = h;
    pWin->drawable.x = pParent->drawable.x + x + (int) bw;
    pWin->drawable.y = pParent->drawable.y + y + (int) bw;

    /* set up clip list correctly for unobscured WindowPtr */
    RegionNull(&pWin->clipList);
    RegionNull(&pWin->borderClip);
    RegionNull(&pWin->winSize);
    RegionNull(&pWin->borderSize);

    pHead = RealChildHead(pParent);
    if (pHead) {
        pWin->nextSib = pHead->nextSib;
        if (pHead->nextSib)
            pHead->nextSib->prevSib = pWin;
        else
            pParent->lastChild = pWin;
        pHead->nextSib = pWin;
        pWin->prevSib = pHead;
    }
    else {
        pWin->nextSib = pParent->firstChild;
        if (pParent->firstChild)
            pParent->firstChild->prevSib = pWin;
        else
            pParent->lastChild = pWin;
        pParent->firstChild = pWin;
    }

    SetWinSize(pWin);
    SetBorderSize(pWin);

    /* We SHOULD check for an error value here XXX */
    if (!(*pScreen->CreateWindow) (pWin)) {
        *error = BadAlloc;
        DeleteWindow(pWin, None);
        return NullWindow;
    }
    /* We SHOULD check for an error value here XXX */
    (*pScreen->PositionWindow) (pWin, pWin->drawable.x, pWin->drawable.y);

    if (!(vmask & CWEventMask))
        RecalculateDeliverableEvents(pWin);

    if (vmask)
        *error = ChangeWindowAttributes(pWin, vmask, vlist, wClient(pWin));
    else
        *error = Success;

    if (*error != Success) {
        DeleteWindow(pWin, None);
        return NullWindow;
    }
    if (!(vmask & CWBackingStore) && (defaultBackingStore != NotUseful)) {
        XID value = defaultBackingStore;

        (void) ChangeWindowAttributes(pWin, CWBackingStore, &value,
                                      wClient(pWin));
        pWin->forcedBS = TRUE;
    }

    if (SubSend(pParent)) {
        xEvent event = {
            .u.createNotify.window = wid,
            .u.createNotify.parent = pParent->drawable.id,
            .u.createNotify.x = x,
            .u.createNotify.y = y,
            .u.createNotify.width = w,
            .u.createNotify.height = h,
            .u.createNotify.borderWidth = bw,
            .u.createNotify.override = pWin->overrideRedirect
        };
        event.u.u.type = CreateNotify;
        DeliverEvents(pParent, &event, 1, NullWindow);
    }
    return pWin;
}

static void
DisposeWindowOptional(WindowPtr pWin)
{
    if (!pWin->optional)
        return;
    /*
     * everything is peachy.  Delete the optional record
     * and clean up
     */
    if (pWin->optional->cursor) {
        FreeCursor(pWin->optional->cursor, (Cursor) 0);
        pWin->cursorIsNone = FALSE;
    }
    else
        pWin->cursorIsNone = TRUE;

    if (pWin->optional->deviceCursors) {
        DevCursorList pList;
        DevCursorList pPrev;

        pList = pWin->optional->deviceCursors;
        while (pList) {
            if (pList->cursor)
                FreeCursor(pList->cursor, (XID) 0);
            pPrev = pList;
            pList = pList->next;
            free(pPrev);
        }
        pWin->optional->deviceCursors = NULL;
    }

    free(pWin->optional);
    pWin->optional = NULL;
}

static void
FreeWindowResources(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    DeleteWindowFromAnySaveSet(pWin);
    DeleteWindowFromAnySelections(pWin);
    DeleteWindowFromAnyEvents(pWin, TRUE);
    RegionUninit(&pWin->clipList);
    RegionUninit(&pWin->winSize);
    RegionUninit(&pWin->borderClip);
    RegionUninit(&pWin->borderSize);
    if (wBoundingShape(pWin))
        RegionDestroy(wBoundingShape(pWin));
    if (wClipShape(pWin))
        RegionDestroy(wClipShape(pWin));
    if (wInputShape(pWin))
        RegionDestroy(wInputShape(pWin));
    if (pWin->borderIsPixel == FALSE)
        (*pScreen->DestroyPixmap) (pWin->border.pixmap);
    if (pWin->backgroundState == BackgroundPixmap)
        (*pScreen->DestroyPixmap) (pWin->background.pixmap);

    DeleteAllWindowProperties(pWin);
    /* We SHOULD check for an error value here XXX */
    (*pScreen->DestroyWindow) (pWin);
    DisposeWindowOptional(pWin);
}

static void
CrushTree(WindowPtr pWin)
{
    WindowPtr pChild, pSib, pParent;
    UnrealizeWindowProcPtr UnrealizeWindow;

    if (!(pChild = pWin->firstChild))
        return;
    UnrealizeWindow = pWin->drawable.pScreen->UnrealizeWindow;
    while (1) {
        if (pChild->firstChild) {
            pChild = pChild->firstChild;
            continue;
        }
        while (1) {
            pParent = pChild->parent;
            if (SubStrSend(pChild, pParent)) {
                xEvent event = { .u.u.type = DestroyNotify };
                event.u.destroyNotify.window = pChild->drawable.id;
                DeliverEvents(pChild, &event, 1, NullWindow);
            }
            FreeResource(pChild->drawable.id, RT_WINDOW);
            pSib = pChild->nextSib;
            pChild->viewable = FALSE;
            if (pChild->realized) {
                pChild->realized = FALSE;
                (*UnrealizeWindow) (pChild);
            }
            FreeWindowResources(pChild);
            dixFreeObjectWithPrivates(pChild, PRIVATE_WINDOW);
            if ((pChild = pSib))
                break;
            pChild = pParent;
            pChild->firstChild = NullWindow;
            pChild->lastChild = NullWindow;
            if (pChild == pWin)
                return;
        }
    }
}

/*****
 *  DeleteWindow
 *	 Deletes child of window then window itself
 *	 If wid is None, don't send any events
 *****/

int
DeleteWindow(void *value, XID wid)
{
    WindowPtr pParent;
    WindowPtr pWin = (WindowPtr) value;

    UnmapWindow(pWin, FALSE);

    CrushTree(pWin);

    pParent = pWin->parent;
    if (wid && pParent && SubStrSend(pWin, pParent)) {
        xEvent event = { .u.u.type = DestroyNotify };
        event.u.destroyNotify.window = pWin->drawable.id;
        DeliverEvents(pWin, &event, 1, NullWindow);
    }

    FreeWindowResources(pWin);
    if (pParent) {
        if (pParent->firstChild == pWin)
            pParent->firstChild = pWin->nextSib;
        if (pParent->lastChild == pWin)
            pParent->lastChild = pWin->prevSib;
        if (pWin->nextSib)
            pWin->nextSib->prevSib = pWin->prevSib;
        if (pWin->prevSib)
            pWin->prevSib->nextSib = pWin->nextSib;
    }
    else
        pWin->drawable.pScreen->root = NULL;
    dixFreeObjectWithPrivates(pWin, PRIVATE_WINDOW);
    return Success;
}

int
DestroySubwindows(WindowPtr pWin, ClientPtr client)
{
    /* XXX
     * The protocol is quite clear that each window should be
     * destroyed in turn, however, unmapping all of the first
     * eliminates most of the calls to ValidateTree.  So,
     * this implementation is incorrect in that all of the
     * UnmapNotifies occur before all of the DestroyNotifies.
     * If you care, simply delete the call to UnmapSubwindows.
     */
    UnmapSubwindows(pWin);
    while (pWin->lastChild) {
        int rc = XaceHook(XACE_RESOURCE_ACCESS, client,
                          pWin->lastChild->drawable.id, RT_WINDOW,
                          pWin->lastChild, RT_NONE, NULL, DixDestroyAccess);

        if (rc != Success)
            return rc;
        FreeResource(pWin->lastChild->drawable.id, RT_NONE);
    }
    return Success;
}

static void
SetRootWindowBackground(WindowPtr pWin, ScreenPtr pScreen, Mask *index2)
{
    /* following the protocol: "Changing the background of a root window to
     * None or ParentRelative restores the default background pixmap" */
    if (bgNoneRoot) {
        pWin->backgroundState = XaceBackgroundNoneState(pWin);
        pWin->background.pixel = pScreen->whitePixel;
    }
    else if (party_like_its_1989)
        MakeRootTile(pWin);
    else {
        pWin->backgroundState = BackgroundPixel;
        if (whiteRoot)
            pWin->background.pixel = pScreen->whitePixel;
        else
            pWin->background.pixel = pScreen->blackPixel;
        *index2 = CWBackPixel;
    }
}

/*****
 *  ChangeWindowAttributes
 *
 *  The value-mask specifies which attributes are to be changed; the
 *  value-list contains one value for each one bit in the mask, from least
 *  to most significant bit in the mask.
 *****/

int
ChangeWindowAttributes(WindowPtr pWin, Mask vmask, XID *vlist, ClientPtr client)
{
    XID *pVlist;
    PixmapPtr pPixmap;
    Pixmap pixID;
    CursorPtr pCursor, pOldCursor;
    Cursor cursorID;
    WindowPtr pChild;
    Colormap cmap;
    ColormapPtr pCmap;
    xEvent xE;
    int error, rc;
    ScreenPtr pScreen;
    Mask index2, tmask, vmaskCopy = 0;
    unsigned int val;
    Bool checkOptional = FALSE, borderRelative = FALSE;

    if ((pWin->drawable.class == InputOnly) &&
        (vmask & (~INPUTONLY_LEGAL_MASK)))
        return BadMatch;

    error = Success;
    pScreen = pWin->drawable.pScreen;
    pVlist = vlist;
    tmask = vmask;
    while (tmask) {
        index2 = (Mask) lowbit(tmask);
        tmask &= ~index2;
        switch (index2) {
        case CWBackPixmap:
            pixID = (Pixmap) * pVlist;
            pVlist++;
            if (pWin->backgroundState == ParentRelative)
                borderRelative = TRUE;
            if (pixID == None) {
                if (pWin->backgroundState == BackgroundPixmap)
                    (*pScreen->DestroyPixmap) (pWin->background.pixmap);
                if (!pWin->parent)
                    SetRootWindowBackground(pWin, pScreen, &index2);
                else {
                    pWin->backgroundState = XaceBackgroundNoneState(pWin);
                    pWin->background.pixel = pScreen->whitePixel;
                }
            }
            else if (pixID == ParentRelative) {
                if (pWin->parent &&
                    pWin->drawable.depth != pWin->parent->drawable.depth) {
                    error = BadMatch;
                    goto PatchUp;
                }
                if (pWin->backgroundState == BackgroundPixmap)
                    (*pScreen->DestroyPixmap) (pWin->background.pixmap);
                if (!pWin->parent)
                    SetRootWindowBackground(pWin, pScreen, &index2);
                else
                    pWin->backgroundState = ParentRelative;
                borderRelative = TRUE;
                /* Note that the parent's backgroundTile's refcnt is NOT
                 * incremented. */
            }
            else {
                rc = dixLookupResourceByType((void **) &pPixmap, pixID,
                                             RT_PIXMAP, client, DixReadAccess);
                if (rc == Success) {
                    if ((pPixmap->drawable.depth != pWin->drawable.depth) ||
                        (pPixmap->drawable.pScreen != pScreen)) {
                        error = BadMatch;
                        goto PatchUp;
                    }
                    if (pWin->backgroundState == BackgroundPixmap)
                        (*pScreen->DestroyPixmap) (pWin->background.pixmap);
                    pWin->backgroundState = BackgroundPixmap;
                    pWin->background.pixmap = pPixmap;
                    pPixmap->refcnt++;
                }
                else {
                    error = rc;
                    client->errorValue = pixID;
                    goto PatchUp;
                }
            }
            break;
        case CWBackPixel:
            if (pWin->backgroundState == ParentRelative)
                borderRelative = TRUE;
            if (pWin->backgroundState == BackgroundPixmap)
                (*pScreen->DestroyPixmap) (pWin->background.pixmap);
            pWin->backgroundState = BackgroundPixel;
            pWin->background.pixel = (CARD32) *pVlist;
            /* background pixel overrides background pixmap,
               so don't let the ddx layer see both bits */
            vmaskCopy &= ~CWBackPixmap;
            pVlist++;
            break;
        case CWBorderPixmap:
            pixID = (Pixmap) * pVlist;
            pVlist++;
            if (pixID == CopyFromParent) {
                if (!pWin->parent ||
                    (pWin->drawable.depth != pWin->parent->drawable.depth)) {
                    error = BadMatch;
                    goto PatchUp;
                }
                if (pWin->parent->borderIsPixel == TRUE) {
                    if (pWin->borderIsPixel == FALSE)
                        (*pScreen->DestroyPixmap) (pWin->border.pixmap);
                    pWin->border = pWin->parent->border;
                    pWin->borderIsPixel = TRUE;
                    index2 = CWBorderPixel;
                    break;
                }
                else {
                    pixID = pWin->parent->border.pixmap->drawable.id;
                }
            }
            rc = dixLookupResourceByType((void **) &pPixmap, pixID, RT_PIXMAP,
                                         client, DixReadAccess);
            if (rc == Success) {
                if ((pPixmap->drawable.depth != pWin->drawable.depth) ||
                    (pPixmap->drawable.pScreen != pScreen)) {
                    error = BadMatch;
                    goto PatchUp;
                }
                if (pWin->borderIsPixel == FALSE)
                    (*pScreen->DestroyPixmap) (pWin->border.pixmap);
                pWin->borderIsPixel = FALSE;
                pWin->border.pixmap = pPixmap;
                pPixmap->refcnt++;
            }
            else {
                error = rc;
                client->errorValue = pixID;
                goto PatchUp;
            }
            break;
        case CWBorderPixel:
            if (pWin->borderIsPixel == FALSE)
                (*pScreen->DestroyPixmap) (pWin->border.pixmap);
            pWin->borderIsPixel = TRUE;
            pWin->border.pixel = (CARD32) *pVlist;
            /* border pixel overrides border pixmap,
               so don't let the ddx layer see both bits */
            vmaskCopy &= ~CWBorderPixmap;
            pVlist++;
            break;
        case CWBitGravity:
            val = (CARD8) *pVlist;
            pVlist++;
            if (val > StaticGravity) {
                error = BadValue;
                client->errorValue = val;
                goto PatchUp;
            }
            pWin->bitGravity = val;
            break;
        case CWWinGravity:
            val = (CARD8) *pVlist;
            pVlist++;
            if (val > StaticGravity) {
                error = BadValue;
                client->errorValue = val;
                goto PatchUp;
            }
            pWin->winGravity = val;
            break;
        case CWBackingStore:
            val = (CARD8) *pVlist;
            pVlist++;
            if ((val != NotUseful) && (val != WhenMapped) && (val != Always)) {
                error = BadValue;
                client->errorValue = val;
                goto PatchUp;
            }
            pWin->backingStore = val;
            pWin->forcedBS = FALSE;
            break;
        case CWBackingPlanes:
            if (pWin->optional || ((CARD32) *pVlist != (CARD32) ~0L)) {
                if (!pWin->optional && !MakeWindowOptional(pWin)) {
                    error = BadAlloc;
                    goto PatchUp;
                }
                pWin->optional->backingBitPlanes = (CARD32) *pVlist;
                if ((CARD32) *pVlist == (CARD32) ~0L)
                    checkOptional = TRUE;
            }
            pVlist++;
            break;
        case CWBackingPixel:
            if (pWin->optional || (CARD32) *pVlist) {
                if (!pWin->optional && !MakeWindowOptional(pWin)) {
                    error = BadAlloc;
                    goto PatchUp;
                }
                pWin->optional->backingPixel = (CARD32) *pVlist;
                if (!*pVlist)
                    checkOptional = TRUE;
            }
            pVlist++;
            break;
        case CWSaveUnder:
            val = (BOOL) * pVlist;
            pVlist++;
            if ((val != xTrue) && (val != xFalse)) {
                error = BadValue;
                client->errorValue = val;
                goto PatchUp;
            }
            pWin->saveUnder = val;
            break;
        case CWEventMask:
            rc = EventSelectForWindow(pWin, client, (Mask) *pVlist);
            if (rc) {
                error = rc;
                goto PatchUp;
            }
            pVlist++;
            break;
        case CWDontPropagate:
            rc = EventSuppressForWindow(pWin, client, (Mask) *pVlist,
                                        &checkOptional);
            if (rc) {
                error = rc;
                goto PatchUp;
            }
            pVlist++;
            break;
        case CWOverrideRedirect:
            val = (BOOL) * pVlist;
            pVlist++;
            if ((val != xTrue) && (val != xFalse)) {
                error = BadValue;
                client->errorValue = val;
                goto PatchUp;
            }
            if (val == xTrue) {
                rc = XaceHook(XACE_RESOURCE_ACCESS, client, pWin->drawable.id,
                              RT_WINDOW, pWin, RT_NONE, NULL, DixGrabAccess);
                if (rc != Success) {
                    error = rc;
                    client->errorValue = pWin->drawable.id;
                    goto PatchUp;
                }
            }
            pWin->overrideRedirect = val;
            break;
        case CWColormap:
            cmap = (Colormap) * pVlist;
            pVlist++;
            if (cmap == CopyFromParent) {
                if (pWin->parent &&
                    (!pWin->optional ||
                     pWin->optional->visual == wVisual(pWin->parent))) {
                    cmap = wColormap(pWin->parent);
                }
                else
                    cmap = None;
            }
            if (cmap == None) {
                error = BadMatch;
                goto PatchUp;
            }
            rc = dixLookupResourceByType((void **) &pCmap, cmap, RT_COLORMAP,
                                         client, DixUseAccess);
            if (rc != Success) {
                error = rc;
                client->errorValue = cmap;
                goto PatchUp;
            }
            if (pCmap->pVisual->vid != wVisual(pWin) ||
                pCmap->pScreen != pScreen) {
                error = BadMatch;
                goto PatchUp;
            }
            if (cmap != wColormap(pWin)) {
                if (!pWin->optional) {
                    if (!MakeWindowOptional(pWin)) {
                        error = BadAlloc;
                        goto PatchUp;
                    }
                }
                else if (pWin->parent && cmap == wColormap(pWin->parent))
                    checkOptional = TRUE;

                /*
                 * propagate the original colormap to any children
                 * inheriting it
                 */

                for (pChild = pWin->firstChild; pChild;
                     pChild = pChild->nextSib) {
                    if (!pChild->optional && !MakeWindowOptional(pChild)) {
                        error = BadAlloc;
                        goto PatchUp;
                    }
                }

                pWin->optional->colormap = cmap;

                /*
                 * check on any children now matching the new colormap
                 */

                for (pChild = pWin->firstChild; pChild;
                     pChild = pChild->nextSib) {
                    if (pChild->optional->colormap == cmap)
                        CheckWindowOptionalNeed(pChild);
                }

                xE = (xEvent) {
                    .u.colormap.window = pWin->drawable.id,
                    .u.colormap.colormap = cmap,
                    .u.colormap.new = xTrue,
                    .u.colormap.state = IsMapInstalled(cmap, pWin)
                };
                xE.u.u.type = ColormapNotify;
                DeliverEvents(pWin, &xE, 1, NullWindow);
            }
            break;
        case CWCursor:
            cursorID = (Cursor) * pVlist;
            pVlist++;
            /*
             * install the new
             */
            if (cursorID == None) {
                if (pWin == pWin->drawable.pScreen->root)
                    pCursor = rootCursor;
                else
                    pCursor = (CursorPtr) None;
            }
            else {
                rc = dixLookupResourceByType((void **) &pCursor, cursorID,
                                             RT_CURSOR, client, DixUseAccess);
                if (rc != Success) {
                    error = rc;
                    client->errorValue = cursorID;
                    goto PatchUp;
                }
            }

            if (pCursor != wCursor(pWin)) {
                /*
                 * patch up child windows so they don't lose cursors.
                 */

                for (pChild = pWin->firstChild; pChild;
                     pChild = pChild->nextSib) {
                    if (!pChild->optional && !pChild->cursorIsNone &&
                        !MakeWindowOptional(pChild)) {
                        error = BadAlloc;
                        goto PatchUp;
                    }
                }

                pOldCursor = 0;
                if (pCursor == (CursorPtr) None) {
                    pWin->cursorIsNone = TRUE;
                    if (pWin->optional) {
                        pOldCursor = pWin->optional->cursor;
                        pWin->optional->cursor = (CursorPtr) None;
                        checkOptional = TRUE;
                    }
                }
                else {
                    if (!pWin->optional) {
                        if (!MakeWindowOptional(pWin)) {
                            error = BadAlloc;
                            goto PatchUp;
                        }
                    }
                    else if (pWin->parent && pCursor == wCursor(pWin->parent))
                        checkOptional = TRUE;
                    pOldCursor = pWin->optional->cursor;
                    pWin->optional->cursor = RefCursor(pCursor);
                    pWin->cursorIsNone = FALSE;
                    /*
                     * check on any children now matching the new cursor
                     */

                    for (pChild = pWin->firstChild; pChild;
                         pChild = pChild->nextSib) {
                        if (pChild->optional &&
                            (pChild->optional->cursor == pCursor))
                            CheckWindowOptionalNeed(pChild);
                    }
                }

                CursorVisible = TRUE;

                if (pWin->realized)
                    WindowHasNewCursor(pWin);

                /* Can't free cursor until here - old cursor
                 * is needed in WindowHasNewCursor
                 */
                if (pOldCursor)
                    FreeCursor(pOldCursor, (Cursor) 0);
            }
            break;
        default:
            error = BadValue;
            client->errorValue = vmask;
            goto PatchUp;
        }
        vmaskCopy |= index2;
    }
 PatchUp:
    if (checkOptional)
        CheckWindowOptionalNeed(pWin);

    /* We SHOULD check for an error value here XXX */
    (*pScreen->ChangeWindowAttributes) (pWin, vmaskCopy);

    /*
       If the border contents have changed, redraw the border.
       Note that this has to be done AFTER pScreen->ChangeWindowAttributes
       for the tile to be rotated, and the correct function selected.
     */
    if (((vmaskCopy & (CWBorderPixel | CWBorderPixmap)) || borderRelative)
        && pWin->viewable && HasBorder(pWin)) {
        RegionRec exposed;

        RegionNull(&exposed);
        RegionSubtract(&exposed, &pWin->borderClip, &pWin->winSize);
        pWin->drawable.pScreen->PaintWindow(pWin, &exposed, PW_BORDER);
        RegionUninit(&exposed);
    }
    return error;
}

/*****
 * GetWindowAttributes
 *    Notice that this is different than ChangeWindowAttributes
 *****/

void
GetWindowAttributes(WindowPtr pWin, ClientPtr client,
                    xGetWindowAttributesReply * wa)
{
    wa->type = X_Reply;
    wa->bitGravity = pWin->bitGravity;
    wa->winGravity = pWin->winGravity;
    if (pWin->forcedBS && pWin->backingStore != Always)
        wa->backingStore = NotUseful;
    else
        wa->backingStore = pWin->backingStore;
    wa->length = bytes_to_int32(sizeof(xGetWindowAttributesReply) -
                                sizeof(xGenericReply));
    wa->sequenceNumber = client->sequence;
    wa->backingBitPlanes = wBackingBitPlanes(pWin);
    wa->backingPixel = wBackingPixel(pWin);
    wa->saveUnder = (BOOL) pWin->saveUnder;
    wa->override = pWin->overrideRedirect;
    if (!pWin->mapped)
        wa->mapState = IsUnmapped;
    else if (pWin->realized)
        wa->mapState = IsViewable;
    else
        wa->mapState = IsUnviewable;

    wa->colormap = wColormap(pWin);
    wa->mapInstalled = (wa->colormap == None) ? xFalse
        : IsMapInstalled(wa->colormap, pWin);

    wa->yourEventMask = EventMaskForClient(pWin, client);
    wa->allEventMasks = pWin->eventMask | wOtherEventMasks(pWin);
    wa->doNotPropagateMask = wDontPropagateMask(pWin);
    wa->class = pWin->drawable.class;
    wa->visualID = wVisual(pWin);
}

WindowPtr
MoveWindowInStack(WindowPtr pWin, WindowPtr pNextSib)
{
    WindowPtr pParent = pWin->parent;
    WindowPtr pFirstChange = pWin;      /* highest window where list changes */

    if (pWin->nextSib != pNextSib) {
        WindowPtr pOldNextSib = pWin->nextSib;

        if (!pNextSib) {        /* move to bottom */
            if (pParent->firstChild == pWin)
                pParent->firstChild = pWin->nextSib;
            /* if (pWin->nextSib) *//* is always True: pNextSib == NULL
             * and pWin->nextSib != pNextSib
             * therefore pWin->nextSib != NULL */
            pFirstChange = pWin->nextSib;
            pWin->nextSib->prevSib = pWin->prevSib;
            if (pWin->prevSib)
                pWin->prevSib->nextSib = pWin->nextSib;
            pParent->lastChild->nextSib = pWin;
            pWin->prevSib = pParent->lastChild;
            pWin->nextSib = NullWindow;
            pParent->lastChild = pWin;
        }
        else if (pParent->firstChild == pNextSib) {     /* move to top */
            pFirstChange = pWin;
            if (pParent->lastChild == pWin)
                pParent->lastChild = pWin->prevSib;
            if (pWin->nextSib)
                pWin->nextSib->prevSib = pWin->prevSib;
            if (pWin->prevSib)
                pWin->prevSib->nextSib = pWin->nextSib;
            pWin->nextSib = pParent->firstChild;
            pWin->prevSib = NULL;
            pNextSib->prevSib = pWin;
            pParent->firstChild = pWin;
        }
        else {                  /* move in middle of list */

            WindowPtr pOldNext = pWin->nextSib;

            pFirstChange = NullWindow;
            if (pParent->firstChild == pWin)
                pFirstChange = pParent->firstChild = pWin->nextSib;
            if (pParent->lastChild == pWin) {
                pFirstChange = pWin;
                pParent->lastChild = pWin->prevSib;
            }
            if (pWin->nextSib)
                pWin->nextSib->prevSib = pWin->prevSib;
            if (pWin->prevSib)
                pWin->prevSib->nextSib = pWin->nextSib;
            pWin->nextSib = pNextSib;
            pWin->prevSib = pNextSib->prevSib;
            if (pNextSib->prevSib)
                pNextSib->prevSib->nextSib = pWin;
            pNextSib->prevSib = pWin;
            if (!pFirstChange) {        /* do we know it yet? */
                pFirstChange = pParent->firstChild;     /* no, search from top */
                while ((pFirstChange != pWin) && (pFirstChange != pOldNext))
                    pFirstChange = pFirstChange->nextSib;
            }
        }
        if (pWin->drawable.pScreen->RestackWindow)
            (*pWin->drawable.pScreen->RestackWindow) (pWin, pOldNextSib);
    }

#ifdef ROOTLESS
    /*
     * In rootless mode we can't optimize away window restacks.
     * There may be non-X windows around, so even if the window
     * is in the correct position from X's point of view,
     * the underlying window system may want to reorder it.
     */
    else if (pWin->drawable.pScreen->RestackWindow)
        (*pWin->drawable.pScreen->RestackWindow) (pWin, pWin->nextSib);
#endif

    return pFirstChange;
}

void
SetWinSize(WindowPtr pWin)
{
#ifdef COMPOSITE
    if (pWin->redirectDraw != RedirectDrawNone) {
        BoxRec box;

        /*
         * Redirected clients get clip list equal to their
         * own geometry, not clipped to their parent
         */
        box.x1 = pWin->drawable.x;
        box.y1 = pWin->drawable.y;
        box.x2 = pWin->drawable.x + pWin->drawable.width;
        box.y2 = pWin->drawable.y + pWin->drawable.height;
        RegionReset(&pWin->winSize, &box);
    }
    else
#endif
        ClippedRegionFromBox(pWin->parent, &pWin->winSize,
                             pWin->drawable.x, pWin->drawable.y,
                             (int) pWin->drawable.width,
                             (int) pWin->drawable.height);
    if (wBoundingShape(pWin) || wClipShape(pWin)) {
        RegionTranslate(&pWin->winSize, -pWin->drawable.x, -pWin->drawable.y);
        if (wBoundingShape(pWin))
            RegionIntersect(&pWin->winSize, &pWin->winSize,
                            wBoundingShape(pWin));
        if (wClipShape(pWin))
            RegionIntersect(&pWin->winSize, &pWin->winSize, wClipShape(pWin));
        RegionTranslate(&pWin->winSize, pWin->drawable.x, pWin->drawable.y);
    }
}

void
SetBorderSize(WindowPtr pWin)
{
    int bw;

    if (HasBorder(pWin)) {
        bw = wBorderWidth(pWin);
#ifdef COMPOSITE
        if (pWin->redirectDraw != RedirectDrawNone) {
            BoxRec box;

            /*
             * Redirected clients get clip list equal to their
             * own geometry, not clipped to their parent
             */
            box.x1 = pWin->drawable.x - bw;
            box.y1 = pWin->drawable.y - bw;
            box.x2 = pWin->drawable.x + pWin->drawable.width + bw;
            box.y2 = pWin->drawable.y + pWin->drawable.height + bw;
            RegionReset(&pWin->borderSize, &box);
        }
        else
#endif
            ClippedRegionFromBox(pWin->parent, &pWin->borderSize,
                                 pWin->drawable.x - bw, pWin->drawable.y - bw,
                                 (int) (pWin->drawable.width + (bw << 1)),
                                 (int) (pWin->drawable.height + (bw << 1)));
        if (wBoundingShape(pWin)) {
            RegionTranslate(&pWin->borderSize, -pWin->drawable.x,
                            -pWin->drawable.y);
            RegionIntersect(&pWin->borderSize, &pWin->borderSize,
                            wBoundingShape(pWin));
            RegionTranslate(&pWin->borderSize, pWin->drawable.x,
                            pWin->drawable.y);
            RegionUnion(&pWin->borderSize, &pWin->borderSize, &pWin->winSize);
        }
    }
    else {
        RegionCopy(&pWin->borderSize, &pWin->winSize);
    }
}

/**
 *
 *  \param x,y          new window position
 *  \param oldx,oldy    old window position
 *  \param destx,desty  position relative to gravity
 */

void
GravityTranslate(int x, int y, int oldx, int oldy,
                 int dw, int dh, unsigned gravity, int *destx, int *desty)
{
    switch (gravity) {
    case NorthGravity:
        *destx = x + dw / 2;
        *desty = y;
        break;
    case NorthEastGravity:
        *destx = x + dw;
        *desty = y;
        break;
    case WestGravity:
        *destx = x;
        *desty = y + dh / 2;
        break;
    case CenterGravity:
        *destx = x + dw / 2;
        *desty = y + dh / 2;
        break;
    case EastGravity:
        *destx = x + dw;
        *desty = y + dh / 2;
        break;
    case SouthWestGravity:
        *destx = x;
        *desty = y + dh;
        break;
    case SouthGravity:
        *destx = x + dw / 2;
        *desty = y + dh;
        break;
    case SouthEastGravity:
        *destx = x + dw;
        *desty = y + dh;
        break;
    case StaticGravity:
        *destx = oldx;
        *desty = oldy;
        break;
    default:
        *destx = x;
        *desty = y;
        break;
    }
}

/* XXX need to retile border on each window with ParentRelative origin */
void
ResizeChildrenWinSize(WindowPtr pWin, int dx, int dy, int dw, int dh)
{
    ScreenPtr pScreen;
    WindowPtr pSib, pChild;
    Bool resized = (dw || dh);

    pScreen = pWin->drawable.pScreen;

    for (pSib = pWin->firstChild; pSib; pSib = pSib->nextSib) {
        if (resized && (pSib->winGravity > NorthWestGravity)) {
            int cwsx, cwsy;

            cwsx = pSib->origin.x;
            cwsy = pSib->origin.y;
            GravityTranslate(cwsx, cwsy, cwsx - dx, cwsy - dy, dw, dh,
                             pSib->winGravity, &cwsx, &cwsy);
            if (cwsx != pSib->origin.x || cwsy != pSib->origin.y) {
                xEvent event = {
                    .u.gravity.window = pSib->drawable.id,
                    .u.gravity.x = cwsx - wBorderWidth(pSib),
                    .u.gravity.y = cwsy - wBorderWidth(pSib)
                };
                event.u.u.type = GravityNotify;
                DeliverEvents(pSib, &event, 1, NullWindow);
                pSib->origin.x = cwsx;
                pSib->origin.y = cwsy;
            }
        }
        pSib->drawable.x = pWin->drawable.x + pSib->origin.x;
        pSib->drawable.y = pWin->drawable.y + pSib->origin.y;
        SetWinSize(pSib);
        SetBorderSize(pSib);
        (*pScreen->PositionWindow) (pSib, pSib->drawable.x, pSib->drawable.y);

        if ((pChild = pSib->firstChild)) {
            while (1) {
                pChild->drawable.x = pChild->parent->drawable.x +
                    pChild->origin.x;
                pChild->drawable.y = pChild->parent->drawable.y +
                    pChild->origin.y;
                SetWinSize(pChild);
                SetBorderSize(pChild);
                (*pScreen->PositionWindow) (pChild,
                                            pChild->drawable.x,
                                            pChild->drawable.y);
                if (pChild->firstChild) {
                    pChild = pChild->firstChild;
                    continue;
                }
                while (!pChild->nextSib && (pChild != pSib))
                    pChild = pChild->parent;
                if (pChild == pSib)
                    break;
                pChild = pChild->nextSib;
            }
        }
    }
}

#define GET_INT16(m, f) \
	if (m & mask) \
	  { \
	     f = (INT16) *pVlist;\
	    pVlist++; \
	 }
#define GET_CARD16(m, f) \
	if (m & mask) \
	 { \
	    f = (CARD16) *pVlist;\
	    pVlist++;\
	 }

#define GET_CARD8(m, f) \
	if (m & mask) \
	 { \
	    f = (CARD8) *pVlist;\
	    pVlist++;\
	 }

#define ChangeMask ((Mask)(CWX | CWY | CWWidth | CWHeight))

/*
 * IsSiblingAboveMe
 *     returns Above if pSib above pMe in stack or Below otherwise
 */

static int
IsSiblingAboveMe(WindowPtr pMe, WindowPtr pSib)
{
    WindowPtr pWin;

    pWin = pMe->parent->firstChild;
    while (pWin) {
        if (pWin == pSib)
            return Above;
        else if (pWin == pMe)
            return Below;
        pWin = pWin->nextSib;
    }
    return Below;
}

static BoxPtr
WindowExtents(WindowPtr pWin, BoxPtr pBox)
{
    pBox->x1 = pWin->drawable.x - wBorderWidth(pWin);
    pBox->y1 = pWin->drawable.y - wBorderWidth(pWin);
    pBox->x2 = pWin->drawable.x + (int) pWin->drawable.width
        + wBorderWidth(pWin);
    pBox->y2 = pWin->drawable.y + (int) pWin->drawable.height
        + wBorderWidth(pWin);
    return pBox;
}

#define IS_SHAPED(pWin)	(wBoundingShape (pWin) != NULL)

static RegionPtr
MakeBoundingRegion(WindowPtr pWin, BoxPtr pBox)
{
    RegionPtr pRgn = RegionCreate(pBox, 1);

    if (wBoundingShape(pWin)) {
        RegionTranslate(pRgn, -pWin->origin.x, -pWin->origin.y);
        RegionIntersect(pRgn, pRgn, wBoundingShape(pWin));
        RegionTranslate(pRgn, pWin->origin.x, pWin->origin.y);
    }
    return pRgn;
}

static Bool
ShapeOverlap(WindowPtr pWin, BoxPtr pWinBox, WindowPtr pSib, BoxPtr pSibBox)
{
    RegionPtr pWinRgn, pSibRgn;
    Bool ret;

    if (!IS_SHAPED(pWin) && !IS_SHAPED(pSib))
        return TRUE;
    pWinRgn = MakeBoundingRegion(pWin, pWinBox);
    pSibRgn = MakeBoundingRegion(pSib, pSibBox);
    RegionIntersect(pWinRgn, pWinRgn, pSibRgn);
    ret = RegionNotEmpty(pWinRgn);
    RegionDestroy(pWinRgn);
    RegionDestroy(pSibRgn);
    return ret;
}

static Bool
AnyWindowOverlapsMe(WindowPtr pWin, WindowPtr pHead, BoxPtr box)
{
    WindowPtr pSib;
    BoxRec sboxrec;
    BoxPtr sbox;

    for (pSib = pWin->prevSib; pSib != pHead; pSib = pSib->prevSib) {
        if (pSib->mapped) {
            sbox = WindowExtents(pSib, &sboxrec);
            if (BOXES_OVERLAP(sbox, box)
                && ShapeOverlap(pWin, box, pSib, sbox))
                return TRUE;
        }
    }
    return FALSE;
}

static Bool
IOverlapAnyWindow(WindowPtr pWin, BoxPtr box)
{
    WindowPtr pSib;
    BoxRec sboxrec;
    BoxPtr sbox;

    for (pSib = pWin->nextSib; pSib; pSib = pSib->nextSib) {
        if (pSib->mapped) {
            sbox = WindowExtents(pSib, &sboxrec);
            if (BOXES_OVERLAP(sbox, box)
                && ShapeOverlap(pWin, box, pSib, sbox))
                return TRUE;
        }
    }
    return FALSE;
}

/*
 *   WhereDoIGoInTheStack()
 *	  Given pWin and pSib and the relationshipe smode, return
 *	  the window that pWin should go ABOVE.
 *	  If a pSib is specified:
 *	      Above:  pWin is placed just above pSib
 *	      Below:  pWin is placed just below pSib
 *	      TopIf:  if pSib occludes pWin, then pWin is placed
 *		      at the top of the stack
 *	      BottomIf:	 if pWin occludes pSib, then pWin is
 *			 placed at the bottom of the stack
 *	      Opposite: if pSib occludes pWin, then pWin is placed at the
 *			top of the stack, else if pWin occludes pSib, then
 *			pWin is placed at the bottom of the stack
 *
 *	  If pSib is NULL:
 *	      Above:  pWin is placed at the top of the stack
 *	      Below:  pWin is placed at the bottom of the stack
 *	      TopIf:  if any sibling occludes pWin, then pWin is placed at
 *		      the top of the stack
 *	      BottomIf: if pWin occludes any sibline, then pWin is placed at
 *			the bottom of the stack
 *	      Opposite: if any sibling occludes pWin, then pWin is placed at
 *			the top of the stack, else if pWin occludes any
 *			sibling, then pWin is placed at the bottom of the stack
 *
 */

static WindowPtr
WhereDoIGoInTheStack(WindowPtr pWin,
                     WindowPtr pSib,
                     short x,
                     short y, unsigned short w, unsigned short h, int smode)
{
    BoxRec box;
    WindowPtr pHead, pFirst;

    if ((pWin == pWin->parent->firstChild) && (pWin == pWin->parent->lastChild))
        return NULL;
    pHead = RealChildHead(pWin->parent);
    pFirst = pHead ? pHead->nextSib : pWin->parent->firstChild;
    box.x1 = x;
    box.y1 = y;
    box.x2 = x + (int) w;
    box.y2 = y + (int) h;
    switch (smode) {
    case Above:
        if (pSib)
            return pSib;
        else if (pWin == pFirst)
            return pWin->nextSib;
        else
            return pFirst;
    case Below:
        if (pSib)
            if (pSib->nextSib != pWin)
                return pSib->nextSib;
            else
                return pWin->nextSib;
        else
            return NullWindow;
    case TopIf:
        if ((!pWin->mapped || (pSib && !pSib->mapped)))
            return pWin->nextSib;
        else if (pSib) {
            if ((IsSiblingAboveMe(pWin, pSib) == Above) &&
                (RegionContainsRect(&pSib->borderSize, &box) != rgnOUT))
                return pFirst;
            else
                return pWin->nextSib;
        }
        else if (AnyWindowOverlapsMe(pWin, pHead, &box))
            return pFirst;
        else
            return pWin->nextSib;
    case BottomIf:
        if ((!pWin->mapped || (pSib && !pSib->mapped)))
            return pWin->nextSib;
        else if (pSib) {
            if ((IsSiblingAboveMe(pWin, pSib) == Below) &&
                (RegionContainsRect(&pSib->borderSize, &box) != rgnOUT))
                return NullWindow;
            else
                return pWin->nextSib;
        }
        else if (IOverlapAnyWindow(pWin, &box))
            return NullWindow;
        else
            return pWin->nextSib;
    case Opposite:
        if ((!pWin->mapped || (pSib && !pSib->mapped)))
            return pWin->nextSib;
        else if (pSib) {
            if (RegionContainsRect(&pSib->borderSize, &box) != rgnOUT) {
                if (IsSiblingAboveMe(pWin, pSib) == Above)
                    return pFirst;
                else
                    return NullWindow;
            }
            else
                return pWin->nextSib;
        }
        else if (AnyWindowOverlapsMe(pWin, pHead, &box)) {
            /* If I'm occluded, I can't possibly be the first child
             * if (pWin == pWin->parent->firstChild)
             *    return pWin->nextSib;
             */
            return pFirst;
        }
        else if (IOverlapAnyWindow(pWin, &box))
            return NullWindow;
        else
            return pWin->nextSib;
    default:
    {
        /* should never happen; make something up. */
        return pWin->nextSib;
    }
    }
}

static void
ReflectStackChange(WindowPtr pWin, WindowPtr pSib, VTKind kind)
{
/* Note that pSib might be NULL */

    Bool WasViewable = (Bool) pWin->viewable;
    Bool anyMarked;
    WindowPtr pFirstChange;
    WindowPtr pLayerWin;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    /* if this is a root window, can't be restacked */
    if (!pWin->parent)
        return;

    pFirstChange = MoveWindowInStack(pWin, pSib);

    if (WasViewable) {
        anyMarked = (*pScreen->MarkOverlappedWindows) (pWin, pFirstChange,
                                                       &pLayerWin);
        if (pLayerWin != pWin)
            pFirstChange = pLayerWin;
        if (anyMarked) {
            (*pScreen->ValidateTree) (pLayerWin->parent, pFirstChange, kind);
            (*pScreen->HandleExposures) (pLayerWin->parent);
            if (pWin->drawable.pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pLayerWin->parent, pFirstChange,
                                              kind);
        }
    }
    if (pWin->realized)
        WindowsRestructured();
}

/*****
 * ConfigureWindow
 *****/

int
ConfigureWindow(WindowPtr pWin, Mask mask, XID *vlist, ClientPtr client)
{
#define RESTACK_WIN    0
#define MOVE_WIN       1
#define RESIZE_WIN     2
#define REBORDER_WIN   3
    WindowPtr pSib = NullWindow;
    WindowPtr pParent = pWin->parent;
    Window sibwid = 0;
    Mask index2, tmask;
    XID *pVlist;
    short x, y, beforeX, beforeY;
    unsigned short w = pWin->drawable.width,
        h = pWin->drawable.height, bw = pWin->borderWidth;
    int rc, action, smode = Above;

    if ((pWin->drawable.class == InputOnly) && (mask & CWBorderWidth))
        return BadMatch;

    if ((mask & CWSibling) && !(mask & CWStackMode))
        return BadMatch;

    pVlist = vlist;

    if (pParent) {
        x = pWin->drawable.x - pParent->drawable.x - (int) bw;
        y = pWin->drawable.y - pParent->drawable.y - (int) bw;
    }
    else {
        x = pWin->drawable.x;
        y = pWin->drawable.y;
    }
    beforeX = x;
    beforeY = y;
    action = RESTACK_WIN;
    if ((mask & (CWX | CWY)) && (!(mask & (CWHeight | CWWidth)))) {
        GET_INT16(CWX, x);
        GET_INT16(CWY, y);
        action = MOVE_WIN;
    }
    /* or should be resized */
    else if (mask & (CWX | CWY | CWWidth | CWHeight)) {
        GET_INT16(CWX, x);
        GET_INT16(CWY, y);
        GET_CARD16(CWWidth, w);
        GET_CARD16(CWHeight, h);
        if (!w || !h) {
            client->errorValue = 0;
            return BadValue;
        }
        action = RESIZE_WIN;
    }
    tmask = mask & ~ChangeMask;
    while (tmask) {
        index2 = (Mask) lowbit(tmask);
        tmask &= ~index2;
        switch (index2) {
        case CWBorderWidth:
            GET_CARD16(CWBorderWidth, bw);
            break;
        case CWSibling:
            sibwid = (Window) *pVlist;
            pVlist++;
            rc = dixLookupWindow(&pSib, sibwid, client, DixGetAttrAccess);
            if (rc != Success) {
                client->errorValue = sibwid;
                return rc;
            }
            if (pSib->parent != pParent)
                return BadMatch;
            if (pSib == pWin)
                return BadMatch;
            break;
        case CWStackMode:
            GET_CARD8(CWStackMode, smode);
            if ((smode != TopIf) && (smode != BottomIf) &&
                (smode != Opposite) && (smode != Above) && (smode != Below)) {
                client->errorValue = smode;
                return BadValue;
            }
            break;
        default:
            client->errorValue = mask;
            return BadValue;
        }
    }
    /* root really can't be reconfigured, so just return */
    if (!pParent)
        return Success;

    /* Figure out if the window should be moved.  Doesnt
       make the changes to the window if event sent */

    if (mask & CWStackMode)
        pSib = WhereDoIGoInTheStack(pWin, pSib, pParent->drawable.x + x,
                                    pParent->drawable.y + y,
                                    w + (bw << 1), h + (bw << 1), smode);
    else
        pSib = pWin->nextSib;

    if ((!pWin->overrideRedirect) && (RedirectSend(pParent))) {
        xEvent event = {
            .u.configureRequest.window = pWin->drawable.id,
            .u.configureRequest.sibling = (mask & CWSibling) ? sibwid : None,
            .u.configureRequest.x = x,
            .u.configureRequest.y = y,
            .u.configureRequest.width = w,
            .u.configureRequest.height = h,
            .u.configureRequest.borderWidth = bw,
            .u.configureRequest.valueMask = mask,
            .u.configureRequest.parent = pParent->drawable.id
        };
        event.u.u.type = ConfigureRequest;
        event.u.u.detail = (mask & CWStackMode) ? smode : Above;
#ifdef PANORAMIX
        if (!noPanoramiXExtension && (!pParent || !pParent->parent)) {
            event.u.configureRequest.x += screenInfo.screens[0]->x;
            event.u.configureRequest.y += screenInfo.screens[0]->y;
        }
#endif
        if (MaybeDeliverEventsToClient(pParent, &event, 1,
                                       SubstructureRedirectMask, client) == 1)
            return Success;
    }
    if (action == RESIZE_WIN) {
        Bool size_change = (w != pWin->drawable.width)
            || (h != pWin->drawable.height);

        if (size_change &&
            ((pWin->eventMask | wOtherEventMasks(pWin)) & ResizeRedirectMask)) {
            xEvent eventT = {
                .u.resizeRequest.window = pWin->drawable.id,
                .u.resizeRequest.width = w,
                .u.resizeRequest.height = h
            };
            eventT.u.u.type = ResizeRequest;
            if (MaybeDeliverEventsToClient(pWin, &eventT, 1,
                                           ResizeRedirectMask, client) == 1) {
                /* if event is delivered, leave the actual size alone. */
                w = pWin->drawable.width;
                h = pWin->drawable.height;
                size_change = FALSE;
            }
        }
        if (!size_change) {
            if (mask & (CWX | CWY))
                action = MOVE_WIN;
            else if (mask & (CWStackMode | CWBorderWidth))
                action = RESTACK_WIN;
            else                /* really nothing to do */
                return (Success);
        }
    }

    if (action == RESIZE_WIN)
        /* we've already checked whether there's really a size change */
        goto ActuallyDoSomething;
    if ((mask & CWX) && (x != beforeX))
        goto ActuallyDoSomething;
    if ((mask & CWY) && (y != beforeY))
        goto ActuallyDoSomething;
    if ((mask & CWBorderWidth) && (bw != wBorderWidth(pWin)))
        goto ActuallyDoSomething;
    if (mask & CWStackMode) {
#ifndef ROOTLESS
        /* See above for why we always reorder in rootless mode. */
        if (pWin->nextSib != pSib)
#endif
            goto ActuallyDoSomething;
    }
    return Success;

 ActuallyDoSomething:
    if (pWin->drawable.pScreen->ConfigNotify) {
        int ret;

        ret =
            (*pWin->drawable.pScreen->ConfigNotify) (pWin, x, y, w, h, bw,
                                                     pSib);
        if (ret) {
            client->errorValue = 0;
            return ret;
        }
    }

    if (SubStrSend(pWin, pParent)) {
        xEvent event = {
            .u.configureNotify.window = pWin->drawable.id,
            .u.configureNotify.aboveSibling = pSib ? pSib->drawable.id : None,
            .u.configureNotify.x = x,
            .u.configureNotify.y = y,
            .u.configureNotify.width = w,
            .u.configureNotify.height = h,
            .u.configureNotify.borderWidth = bw,
            .u.configureNotify.override = pWin->overrideRedirect
        };
        event.u.u.type = ConfigureNotify;
#ifdef PANORAMIX
        if (!noPanoramiXExtension && (!pParent || !pParent->parent)) {
            event.u.configureNotify.x += screenInfo.screens[0]->x;
            event.u.configureNotify.y += screenInfo.screens[0]->y;
        }
#endif
        DeliverEvents(pWin, &event, 1, NullWindow);
    }
    if (mask & CWBorderWidth) {
        if (action == RESTACK_WIN) {
            action = MOVE_WIN;
            pWin->borderWidth = bw;
        }
        else if ((action == MOVE_WIN) &&
                 (beforeX + wBorderWidth(pWin) == x + (int) bw) &&
                 (beforeY + wBorderWidth(pWin) == y + (int) bw)) {
            action = REBORDER_WIN;
            (*pWin->drawable.pScreen->ChangeBorderWidth) (pWin, bw);
        }
        else
            pWin->borderWidth = bw;
    }
    if (action == MOVE_WIN)
        (*pWin->drawable.pScreen->MoveWindow) (pWin, x, y, pSib,
                                               (mask & CWBorderWidth) ? VTOther
                                               : VTMove);
    else if (action == RESIZE_WIN)
        (*pWin->drawable.pScreen->ResizeWindow) (pWin, x, y, w, h, pSib);
    else if (mask & CWStackMode)
        ReflectStackChange(pWin, pSib, VTOther);

    if (action != RESTACK_WIN)
        CheckCursorConfinement(pWin);
    return Success;
#undef RESTACK_WIN
#undef MOVE_WIN
#undef RESIZE_WIN
#undef REBORDER_WIN
}

/******
 *
 * CirculateWindow
 *    For RaiseLowest, raises the lowest mapped child (if any) that is
 *    obscured by another child to the top of the stack.  For LowerHighest,
 *    lowers the highest mapped child (if any) that is obscuring another
 *    child to the bottom of the stack.	 Exposure processing is performed
 *
 ******/

int
CirculateWindow(WindowPtr pParent, int direction, ClientPtr client)
{
    WindowPtr pWin, pHead, pFirst;
    xEvent event;
    BoxRec box;

    pHead = RealChildHead(pParent);
    pFirst = pHead ? pHead->nextSib : pParent->firstChild;
    if (direction == RaiseLowest) {
        for (pWin = pParent->lastChild;
             (pWin != pHead) &&
             !(pWin->mapped &&
               AnyWindowOverlapsMe(pWin, pHead, WindowExtents(pWin, &box)));
             pWin = pWin->prevSib);
        if (pWin == pHead)
            return Success;
    }
    else {
        for (pWin = pFirst;
             pWin &&
             !(pWin->mapped &&
               IOverlapAnyWindow(pWin, WindowExtents(pWin, &box)));
             pWin = pWin->nextSib);
        if (!pWin)
            return Success;
    }

    event = (xEvent) {
        .u.circulate.window = pWin->drawable.id,
        .u.circulate.parent = pParent->drawable.id,
        .u.circulate.event = pParent->drawable.id,
        .u.circulate.place = (direction == RaiseLowest) ?
                              PlaceOnTop : PlaceOnBottom,
    };

    if (RedirectSend(pParent)) {
        event.u.u.type = CirculateRequest;
        if (MaybeDeliverEventsToClient(pParent, &event, 1,
                                       SubstructureRedirectMask, client) == 1)
            return Success;
    }

    event.u.u.type = CirculateNotify;
    DeliverEvents(pWin, &event, 1, NullWindow);
    ReflectStackChange(pWin,
                       (direction == RaiseLowest) ? pFirst : NullWindow,
                       VTStack);

    return Success;
}

static int
CompareWIDs(WindowPtr pWin, void *value)
{                               /* must conform to VisitWindowProcPtr */
    Window *wid = (Window *) value;

    if (pWin->drawable.id == *wid)
        return WT_STOPWALKING;
    else
        return WT_WALKCHILDREN;
}

/*****
 *  ReparentWindow
 *****/

int
ReparentWindow(WindowPtr pWin, WindowPtr pParent,
               int x, int y, ClientPtr client)
{
    WindowPtr pPrev, pPriorParent;
    Bool WasMapped = (Bool) (pWin->mapped);
    xEvent event;
    int bw = wBorderWidth(pWin);
    ScreenPtr pScreen;

    pScreen = pWin->drawable.pScreen;
    if (TraverseTree(pWin, CompareWIDs, (void *) &pParent->drawable.id) ==
        WT_STOPWALKING)
        return BadMatch;
    if (!MakeWindowOptional(pWin))
        return BadAlloc;

    if (WasMapped)
        UnmapWindow(pWin, FALSE);

    event = (xEvent) {
        .u.reparent.window = pWin->drawable.id,
        .u.reparent.parent = pParent->drawable.id,
        .u.reparent.x = x,
        .u.reparent.y = y,
        .u.reparent.override = pWin->overrideRedirect
    };
    event.u.u.type = ReparentNotify;
#ifdef PANORAMIX
    if (!noPanoramiXExtension && !pParent->parent) {
        event.u.reparent.x += screenInfo.screens[0]->x;
        event.u.reparent.y += screenInfo.screens[0]->y;
    }
#endif
    DeliverEvents(pWin, &event, 1, pParent);

    /* take out of sibling chain */

    pPriorParent = pPrev = pWin->parent;
    if (pPrev->firstChild == pWin)
        pPrev->firstChild = pWin->nextSib;
    if (pPrev->lastChild == pWin)
        pPrev->lastChild = pWin->prevSib;

    if (pWin->nextSib)
        pWin->nextSib->prevSib = pWin->prevSib;
    if (pWin->prevSib)
        pWin->prevSib->nextSib = pWin->nextSib;

    /* insert at begining of pParent */
    pWin->parent = pParent;
    pPrev = RealChildHead(pParent);
    if (pPrev) {
        pWin->nextSib = pPrev->nextSib;
        if (pPrev->nextSib)
            pPrev->nextSib->prevSib = pWin;
        else
            pParent->lastChild = pWin;
        pPrev->nextSib = pWin;
        pWin->prevSib = pPrev;
    }
    else {
        pWin->nextSib = pParent->firstChild;
        pWin->prevSib = NullWindow;
        if (pParent->firstChild)
            pParent->firstChild->prevSib = pWin;
        else
            pParent->lastChild = pWin;
        pParent->firstChild = pWin;
    }

    pWin->origin.x = x + bw;
    pWin->origin.y = y + bw;
    pWin->drawable.x = x + bw + pParent->drawable.x;
    pWin->drawable.y = y + bw + pParent->drawable.y;

    /* clip to parent */
    SetWinSize(pWin);
    SetBorderSize(pWin);

    if (pScreen->ReparentWindow)
        (*pScreen->ReparentWindow) (pWin, pPriorParent);
    (*pScreen->PositionWindow) (pWin, pWin->drawable.x, pWin->drawable.y);
    ResizeChildrenWinSize(pWin, 0, 0, 0, 0);

    CheckWindowOptionalNeed(pWin);

    if (WasMapped)
        MapWindow(pWin, client);
    RecalculateDeliverableEvents(pWin);
    return Success;
}

static void
RealizeTree(WindowPtr pWin)
{
    WindowPtr pChild;
    RealizeWindowProcPtr Realize;

    Realize = pWin->drawable.pScreen->RealizeWindow;
    pChild = pWin;
    while (1) {
        if (pChild->mapped) {
            pChild->realized = TRUE;
            pChild->viewable = (pChild->drawable.class == InputOutput);
            (*Realize) (pChild);
            if (pChild->firstChild) {
                pChild = pChild->firstChild;
                continue;
            }
        }
        while (!pChild->nextSib && (pChild != pWin))
            pChild = pChild->parent;
        if (pChild == pWin)
            return;
        pChild = pChild->nextSib;
    }
}

static Bool
MaybeDeliverMapRequest(WindowPtr pWin, WindowPtr pParent, ClientPtr client)
{
    xEvent event = {
        .u.mapRequest.window = pWin->drawable.id,
        .u.mapRequest.parent = pParent->drawable.id
    };
    event.u.u.type = MapRequest;

    return MaybeDeliverEventsToClient(pParent, &event, 1,
                                      SubstructureRedirectMask,
                                      client) == 1;
}

static void
DeliverMapNotify(WindowPtr pWin)
{
    xEvent event = {
        .u.mapNotify.window = pWin->drawable.id,
        .u.mapNotify.override = pWin->overrideRedirect,
    };
    event.u.u.type = MapNotify;
    DeliverEvents(pWin, &event, 1, NullWindow);
}

/*****
 * MapWindow
 *    If some other client has selected SubStructureReDirect on the parent
 *    and override-redirect is xFalse, then a MapRequest event is generated,
 *    but the window remains unmapped.	Otherwise, the window is mapped and a
 *    MapNotify event is generated.
 *****/

int
MapWindow(WindowPtr pWin, ClientPtr client)
{
    ScreenPtr pScreen;

    WindowPtr pParent;
    WindowPtr pLayerWin;

    if (pWin->mapped)
        return Success;

    /* general check for permission to map window */
    if (XaceHook(XACE_RESOURCE_ACCESS, client, pWin->drawable.id, RT_WINDOW,
                 pWin, RT_NONE, NULL, DixShowAccess) != Success)
        return Success;

    pScreen = pWin->drawable.pScreen;
    if ((pParent = pWin->parent)) {
        Bool anyMarked;

        if ((!pWin->overrideRedirect) && (RedirectSend(pParent)))
            if (MaybeDeliverMapRequest(pWin, pParent, client))
                return Success;

        pWin->mapped = TRUE;
        if (SubStrSend(pWin, pParent))
            DeliverMapNotify(pWin);

        if (!pParent->realized)
            return Success;
        RealizeTree(pWin);
        if (pWin->viewable) {
            anyMarked = (*pScreen->MarkOverlappedWindows) (pWin, pWin,
                                                           &pLayerWin);
            if (anyMarked) {
                (*pScreen->ValidateTree) (pLayerWin->parent, pLayerWin, VTMap);
                (*pScreen->HandleExposures) (pLayerWin->parent);
                if (pScreen->PostValidateTree)
                    (*pScreen->PostValidateTree) (pLayerWin->parent, pLayerWin,
                                                  VTMap);
            }
        }
        WindowsRestructured();
    }
    else {
        RegionRec temp;

        pWin->mapped = TRUE;
        pWin->realized = TRUE;  /* for roots */
        pWin->viewable = pWin->drawable.class == InputOutput;
        /* We SHOULD check for an error value here XXX */
        (*pScreen->RealizeWindow) (pWin);
        if (pScreen->ClipNotify)
            (*pScreen->ClipNotify) (pWin, 0, 0);
        if (pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (NullWindow, pWin, VTMap);
        RegionNull(&temp);
        RegionCopy(&temp, &pWin->clipList);
        (*pScreen->WindowExposures) (pWin, &temp);
        RegionUninit(&temp);
    }

    return Success;
}

/*****
 * MapSubwindows
 *    Performs a MapWindow all unmapped children of the window, in top
 *    to bottom stacking order.
 *****/

void
MapSubwindows(WindowPtr pParent, ClientPtr client)
{
    WindowPtr pWin;
    WindowPtr pFirstMapped = NullWindow;
    ScreenPtr pScreen;
    Mask parentRedirect;
    Mask parentNotify;
    Bool anyMarked;
    WindowPtr pLayerWin;

    pScreen = pParent->drawable.pScreen;
    parentRedirect = RedirectSend(pParent);
    parentNotify = SubSend(pParent);
    anyMarked = FALSE;
    for (pWin = pParent->firstChild; pWin; pWin = pWin->nextSib) {
        if (!pWin->mapped) {
            if (parentRedirect && !pWin->overrideRedirect)
                if (MaybeDeliverMapRequest(pWin, pParent, client))
                    continue;

            pWin->mapped = TRUE;
            if (parentNotify || StrSend(pWin))
                DeliverMapNotify(pWin);

            if (!pFirstMapped)
                pFirstMapped = pWin;
            if (pParent->realized) {
                RealizeTree(pWin);
                if (pWin->viewable) {
                    anyMarked |= (*pScreen->MarkOverlappedWindows) (pWin, pWin,
                                                                    NULL);
                }
            }
        }
    }

    if (pFirstMapped) {
        pLayerWin = (*pScreen->GetLayerWindow) (pParent);
        if (pLayerWin->parent != pParent) {
            anyMarked |= (*pScreen->MarkOverlappedWindows) (pLayerWin,
                                                            pLayerWin, NULL);
            pFirstMapped = pLayerWin;
        }
        if (anyMarked) {
            (*pScreen->ValidateTree) (pLayerWin->parent, pFirstMapped, VTMap);
            (*pScreen->HandleExposures) (pLayerWin->parent);
            if (pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pLayerWin->parent, pFirstMapped,
                                              VTMap);
        }
        WindowsRestructured();
    }
}

static void
UnrealizeTree(WindowPtr pWin, Bool fromConfigure)
{
    WindowPtr pChild;
    UnrealizeWindowProcPtr Unrealize;
    MarkUnrealizedWindowProcPtr MarkUnrealizedWindow;

    Unrealize = pWin->drawable.pScreen->UnrealizeWindow;
    MarkUnrealizedWindow = pWin->drawable.pScreen->MarkUnrealizedWindow;
    pChild = pWin;
    while (1) {
        if (pChild->realized) {
            pChild->realized = FALSE;
            pChild->visibility = VisibilityNotViewable;
#ifdef PANORAMIX
            if (!noPanoramiXExtension && !pChild->drawable.pScreen->myNum) {
                PanoramiXRes *win;
                int rc = dixLookupResourceByType((void **) &win,
                                                 pChild->drawable.id,
                                                 XRT_WINDOW,
                                                 serverClient, DixWriteAccess);

                if (rc == Success)
                    win->u.win.visibility = VisibilityNotViewable;
            }
#endif
            (*Unrealize) (pChild);
            DeleteWindowFromAnyEvents(pChild, FALSE);
            if (pChild->viewable) {
                pChild->viewable = FALSE;
                (*MarkUnrealizedWindow) (pChild, pWin, fromConfigure);
                pChild->drawable.serialNumber = NEXT_SERIAL_NUMBER;
            }
            if (pChild->firstChild) {
                pChild = pChild->firstChild;
                continue;
            }
        }
        while (!pChild->nextSib && (pChild != pWin))
            pChild = pChild->parent;
        if (pChild == pWin)
            return;
        pChild = pChild->nextSib;
    }
}

static void
DeliverUnmapNotify(WindowPtr pWin, Bool fromConfigure)
{
    xEvent event = {
        .u.unmapNotify.window = pWin->drawable.id,
        .u.unmapNotify.fromConfigure = fromConfigure
    };
    event.u.u.type = UnmapNotify;
    DeliverEvents(pWin, &event, 1, NullWindow);
}

/*****
 * UnmapWindow
 *    If the window is already unmapped, this request has no effect.
 *    Otherwise, the window is unmapped and an UnMapNotify event is
 *    generated.  Cannot unmap a root window.
 *****/

int
UnmapWindow(WindowPtr pWin, Bool fromConfigure)
{
    WindowPtr pParent;
    Bool wasRealized = (Bool) pWin->realized;
    Bool wasViewable = (Bool) pWin->viewable;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    WindowPtr pLayerWin = pWin;

    if ((!pWin->mapped) || (!(pParent = pWin->parent)))
        return Success;
    if (SubStrSend(pWin, pParent))
        DeliverUnmapNotify(pWin, fromConfigure);
    if (wasViewable && !fromConfigure) {
        pWin->valdata = UnmapValData;
        (*pScreen->MarkOverlappedWindows) (pWin, pWin->nextSib, &pLayerWin);
        (*pScreen->MarkWindow) (pLayerWin->parent);
    }
    pWin->mapped = FALSE;
    if (wasRealized)
        UnrealizeTree(pWin, fromConfigure);
    if (wasViewable) {
        if (!fromConfigure) {
            (*pScreen->ValidateTree) (pLayerWin->parent, pWin, VTUnmap);
            (*pScreen->HandleExposures) (pLayerWin->parent);
            if (pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pLayerWin->parent, pWin, VTUnmap);
        }
    }
    if (wasRealized && !fromConfigure) {
        WindowsRestructured();
        WindowGone(pWin);
    }
    return Success;
}

/*****
 * UnmapSubwindows
 *    Performs an UnmapWindow request with the specified mode on all mapped
 *    children of the window, in bottom to top stacking order.
 *****/

void
UnmapSubwindows(WindowPtr pWin)
{
    WindowPtr pChild, pHead;
    Bool wasRealized = (Bool) pWin->realized;
    Bool wasViewable = (Bool) pWin->viewable;
    Bool anyMarked = FALSE;
    Mask parentNotify;
    WindowPtr pLayerWin = NULL;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    if (!pWin->firstChild)
        return;
    parentNotify = SubSend(pWin);
    pHead = RealChildHead(pWin);

    if (wasViewable)
        pLayerWin = (*pScreen->GetLayerWindow) (pWin);

    for (pChild = pWin->lastChild; pChild != pHead; pChild = pChild->prevSib) {
        if (pChild->mapped) {
            if (parentNotify || StrSend(pChild))
                DeliverUnmapNotify(pChild, xFalse);
            if (pChild->viewable) {
                pChild->valdata = UnmapValData;
                anyMarked = TRUE;
            }
            pChild->mapped = FALSE;
            if (pChild->realized)
                UnrealizeTree(pChild, FALSE);
        }
    }
    if (wasViewable) {
        if (anyMarked) {
            if (pLayerWin->parent == pWin)
                (*pScreen->MarkWindow) (pWin);
            else {
                WindowPtr ptmp;

                (*pScreen->MarkOverlappedWindows) (pWin, pLayerWin, NULL);
                (*pScreen->MarkWindow) (pLayerWin->parent);

                /* Windows between pWin and pLayerWin may not have been marked */
                ptmp = pWin;

                while (ptmp != pLayerWin->parent) {
                    (*pScreen->MarkWindow) (ptmp);
                    ptmp = ptmp->parent;
                }
                pHead = pWin->firstChild;
            }
            (*pScreen->ValidateTree) (pLayerWin->parent, pHead, VTUnmap);
            (*pScreen->HandleExposures) (pLayerWin->parent);
            if (pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pLayerWin->parent, pHead,
                                              VTUnmap);
        }
    }
    if (wasRealized) {
        WindowsRestructured();
        WindowGone(pWin);
    }
}

void
HandleSaveSet(ClientPtr client)
{
    WindowPtr pParent, pWin;
    int j;

    for (j = 0; j < client->numSaved; j++) {
        pWin = SaveSetWindow(client->saveSet[j]);
        if (SaveSetToRoot(client->saveSet[j]))
            pParent = pWin->drawable.pScreen->root;
        else
        {
            pParent = pWin->parent;
            while (pParent && (wClient(pParent) == client))
                pParent = pParent->parent;
        }
        if (pParent) {
            if (pParent != pWin->parent) {
                /* unmap first so that ReparentWindow doesn't remap */
                if (!SaveSetShouldMap(client->saveSet[j]))
                    UnmapWindow(pWin, FALSE);
                ReparentWindow(pWin, pParent,
                               pWin->drawable.x - wBorderWidth(pWin) -
                               pParent->drawable.x,
                               pWin->drawable.y - wBorderWidth(pWin) -
                               pParent->drawable.y, client);
                if (!pWin->realized && pWin->mapped)
                    pWin->mapped = FALSE;
            }
            if (SaveSetShouldMap(client->saveSet[j]))
                MapWindow(pWin, client);
        }
    }
    free(client->saveSet);
    client->numSaved = 0;
    client->saveSet = NULL;
}

/**
 *
 * \param x,y  in root
 */
Bool
PointInWindowIsVisible(WindowPtr pWin, int x, int y)
{
    BoxRec box;

    if (!pWin->realized)
        return FALSE;
    if (RegionContainsPoint(&pWin->borderClip, x, y, &box)
        && (!wInputShape(pWin) ||
            RegionContainsPoint(wInputShape(pWin),
                                x - pWin->drawable.x,
                                y - pWin->drawable.y, &box)))
        return TRUE;
    return FALSE;
}

RegionPtr
NotClippedByChildren(WindowPtr pWin)
{
    RegionPtr pReg = RegionCreate(NullBox, 1);

    if (pWin->parent ||
        screenIsSaved != SCREEN_SAVER_ON ||
        !HasSaverWindow(pWin->drawable.pScreen)) {
        RegionIntersect(pReg, &pWin->borderClip, &pWin->winSize);
    }
    return pReg;
}

void
SendVisibilityNotify(WindowPtr pWin)
{
    xEvent event;
    unsigned int visibility = pWin->visibility;

#ifdef PANORAMIX
    /* This is not quite correct yet, but it's close */
    if (!noPanoramiXExtension) {
        PanoramiXRes *win;
        WindowPtr pWin2;
        int rc, i, Scrnum;

        Scrnum = pWin->drawable.pScreen->myNum;

        win = PanoramiXFindIDByScrnum(XRT_WINDOW, pWin->drawable.id, Scrnum);

        if (!win || (win->u.win.visibility == visibility))
            return;

        switch (visibility) {
        case VisibilityUnobscured:
        FOR_NSCREENS(i) {
            if (i == Scrnum)
                continue;

            rc = dixLookupWindow(&pWin2, win->info[i].id, serverClient,
                                 DixWriteAccess);

            if (rc == Success) {
                if (pWin2->visibility == VisibilityPartiallyObscured)
                    return;

                if (!i)
                    pWin = pWin2;
            }
        }
            break;
        case VisibilityPartiallyObscured:
            if (Scrnum) {
                rc = dixLookupWindow(&pWin2, win->info[0].id, serverClient,
                                     DixWriteAccess);
                if (rc == Success)
                    pWin = pWin2;
            }
            break;
        case VisibilityFullyObscured:
        FOR_NSCREENS(i) {
            if (i == Scrnum)
                continue;

            rc = dixLookupWindow(&pWin2, win->info[i].id, serverClient,
                                 DixWriteAccess);

            if (rc == Success) {
                if (pWin2->visibility != VisibilityFullyObscured)
                    return;

                if (!i)
                    pWin = pWin2;
            }
        }
            break;
        }

        win->u.win.visibility = visibility;
    }
#endif

    event = (xEvent) {
        .u.visibility.window = pWin->drawable.id,
        .u.visibility.state = visibility
    };
    event.u.u.type = VisibilityNotify;
    DeliverEvents(pWin, &event, 1, NullWindow);
}

#define RANDOM_WIDTH 32
int
dixSaveScreens(ClientPtr client, int on, int mode)
{
    int rc, i, what, type;

    if (on == SCREEN_SAVER_FORCER) {
        if (mode == ScreenSaverReset)
            what = SCREEN_SAVER_OFF;
        else
            what = SCREEN_SAVER_ON;
        type = what;
    }
    else {
        what = on;
        type = what;
        if (what == screenIsSaved)
            type = SCREEN_SAVER_CYCLE;
    }

    for (i = 0; i < screenInfo.numScreens; i++) {
        rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, screenInfo.screens[i],
                      DixShowAccess | DixHideAccess);
        if (rc != Success)
            return rc;
    }
    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen = screenInfo.screens[i];

        if (on == SCREEN_SAVER_FORCER)
            (*pScreen->SaveScreen) (pScreen, on);
        if (pScreen->screensaver.ExternalScreenSaver) {
            if ((*pScreen->screensaver.ExternalScreenSaver)
                (pScreen, type, on == SCREEN_SAVER_FORCER))
                continue;
        }
        if (type == screenIsSaved)
            continue;
        switch (type) {
        case SCREEN_SAVER_OFF:
            if (pScreen->screensaver.blanked == SCREEN_IS_BLANKED) {
                (*pScreen->SaveScreen) (pScreen, what);
            }
            else if (HasSaverWindow(pScreen)) {
                pScreen->screensaver.pWindow = NullWindow;
                FreeResource(pScreen->screensaver.wid, RT_NONE);
            }
            break;
        case SCREEN_SAVER_CYCLE:
            if (pScreen->screensaver.blanked == SCREEN_IS_TILED) {
                WindowPtr pWin = pScreen->screensaver.pWindow;

                /* make it look like screen saver is off, so that
                 * NotClippedByChildren will compute a clip list
                 * for the root window, so PaintWindow works
                 */
                screenIsSaved = SCREEN_SAVER_OFF;
                (*pWin->drawable.pScreen->MoveWindow) (pWin,
                                                       (short) (-
                                                                (rand() %
                                                                 RANDOM_WIDTH)),
                                                       (short) (-
                                                                (rand() %
                                                                 RANDOM_WIDTH)),
                                                       pWin->nextSib, VTMove);
                screenIsSaved = SCREEN_SAVER_ON;
            }
            /*
             * Call the DDX saver in case it wants to do something
             * at cycle time
             */
            else if (pScreen->screensaver.blanked == SCREEN_IS_BLANKED) {
                (*pScreen->SaveScreen) (pScreen, type);
            }
            break;
        case SCREEN_SAVER_ON:
            if (ScreenSaverBlanking != DontPreferBlanking) {
                if ((*pScreen->SaveScreen) (pScreen, what)) {
                    pScreen->screensaver.blanked = SCREEN_IS_BLANKED;
                    continue;
                }
                if ((ScreenSaverAllowExposures != DontAllowExposures) &&
                    TileScreenSaver(pScreen, SCREEN_IS_BLACK)) {
                    pScreen->screensaver.blanked = SCREEN_IS_BLACK;
                    continue;
                }
            }
            if ((ScreenSaverAllowExposures != DontAllowExposures) &&
                TileScreenSaver(pScreen, SCREEN_IS_TILED)) {
                pScreen->screensaver.blanked = SCREEN_IS_TILED;
            }
            else
                pScreen->screensaver.blanked = SCREEN_ISNT_SAVED;
            break;
        }
    }
    screenIsSaved = what;
    if (mode == ScreenSaverReset) {
        if (on == SCREEN_SAVER_FORCER) {
            DeviceIntPtr dev;
            UpdateCurrentTimeIf();
            nt_list_for_each_entry(dev, inputInfo.devices, next)
                NoticeTime(dev, currentTime);
        }
        SetScreenSaverTimer();
    }
    return Success;
}

int
SaveScreens(int on, int mode)
{
    return dixSaveScreens(serverClient, on, mode);
}

static Bool
TileScreenSaver(ScreenPtr pScreen, int kind)
{
    int j;
    int result;
    XID attributes[3];
    Mask mask;
    WindowPtr pWin;
    CursorMetricRec cm;
    unsigned char *srcbits, *mskbits;
    CursorPtr cursor;
    XID cursorID = 0;
    int attri;

    mask = 0;
    attri = 0;
    switch (kind) {
    case SCREEN_IS_TILED:
        switch (pScreen->root->backgroundState) {
        case BackgroundPixel:
            attributes[attri++] = pScreen->root->background.pixel;
            mask |= CWBackPixel;
            break;
        case BackgroundPixmap:
            attributes[attri++] = None;
            mask |= CWBackPixmap;
            break;
        default:
            break;
        }
        break;
    case SCREEN_IS_BLACK:
        attributes[attri++] = pScreen->root->drawable.pScreen->blackPixel;
        mask |= CWBackPixel;
        break;
    }
    mask |= CWOverrideRedirect;
    attributes[attri++] = xTrue;

    /*
     * create a blank cursor
     */

    cm.width = 16;
    cm.height = 16;
    cm.xhot = 8;
    cm.yhot = 8;
    srcbits = malloc(BitmapBytePad(32) * 16);
    mskbits = malloc(BitmapBytePad(32) * 16);
    if (!srcbits || !mskbits) {
        free(srcbits);
        free(mskbits);
        cursor = 0;
    }
    else {
        for (j = 0; j < BitmapBytePad(32) * 16; j++)
            srcbits[j] = mskbits[j] = 0x0;
        result = AllocARGBCursor(srcbits, mskbits, NULL, &cm, 0, 0, 0, 0, 0, 0,
                                 &cursor, serverClient, (XID) 0);
        if (cursor) {
            cursorID = FakeClientID(0);
            if (AddResource(cursorID, RT_CURSOR, (void *) cursor)) {
                attributes[attri] = cursorID;
                mask |= CWCursor;
            }
            else
                cursor = 0;
        }
        else {
            free(srcbits);
            free(mskbits);
        }
    }

    pWin = pScreen->screensaver.pWindow =
        CreateWindow(pScreen->screensaver.wid,
                     pScreen->root,
                     -RANDOM_WIDTH, -RANDOM_WIDTH,
                     (unsigned short) pScreen->width + RANDOM_WIDTH,
                     (unsigned short) pScreen->height + RANDOM_WIDTH,
                     0, InputOutput, mask, attributes, 0, serverClient,
                     wVisual(pScreen->root), &result);

    if (cursor)
        FreeResource(cursorID, RT_NONE);

    if (!pWin)
        return FALSE;

    if (!AddResource(pWin->drawable.id, RT_WINDOW,
                     (void *) pScreen->screensaver.pWindow))
        return FALSE;

    if (mask & CWBackPixmap) {
        MakeRootTile(pWin);
        (*pWin->drawable.pScreen->ChangeWindowAttributes) (pWin, CWBackPixmap);
    }
    MapWindow(pWin, serverClient);
    return TRUE;
}

/*
 * FindWindowWithOptional
 *
 * search ancestors of the given window for an entry containing
 * a WindowOpt structure.  Assumptions:	 some parent will
 * contain the structure.
 */

WindowPtr
FindWindowWithOptional(WindowPtr w)
{
    do
        w = w->parent;
    while (!w->optional);
    return w;
}

/*
 * CheckWindowOptionalNeed
 *
 * check each optional entry in the given window to see if
 * the value is satisfied by the default rules.	 If so,
 * release the optional record
 */

void
CheckWindowOptionalNeed(WindowPtr w)
{
    WindowOptPtr optional;
    WindowOptPtr parentOptional;

    if (!w->parent || !w->optional)
        return;
    optional = w->optional;
    if (optional->dontPropagateMask != DontPropagateMasks[w->dontPropagate])
        return;
    if (optional->otherEventMasks != 0)
        return;
    if (optional->otherClients != NULL)
        return;
    if (optional->passiveGrabs != NULL)
        return;
    if (optional->userProps != NULL)
        return;
    if (optional->backingBitPlanes != (CARD32)~0L)
        return;
    if (optional->backingPixel != 0)
        return;
    if (optional->boundingShape != NULL)
        return;
    if (optional->clipShape != NULL)
        return;
    if (optional->inputShape != NULL)
        return;
    if (optional->inputMasks != NULL)
        return;
    if (optional->deviceCursors != NULL) {
        DevCursNodePtr pNode = optional->deviceCursors;

        while (pNode) {
            if (pNode->cursor != None)
                return;
            pNode = pNode->next;
        }
    }

    parentOptional = FindWindowWithOptional(w)->optional;
    if (optional->visual != parentOptional->visual)
        return;
    if (optional->cursor != None &&
        (optional->cursor != parentOptional->cursor || w->parent->cursorIsNone))
        return;
    if (optional->colormap != parentOptional->colormap)
        return;
    DisposeWindowOptional(w);
}

/*
 * MakeWindowOptional
 *
 * create an optional record and initialize it with the default
 * values.
 */

Bool
MakeWindowOptional(WindowPtr pWin)
{
    WindowOptPtr optional;
    WindowOptPtr parentOptional;

    if (pWin->optional)
        return TRUE;
    optional = malloc(sizeof(WindowOptRec));
    if (!optional)
        return FALSE;
    optional->dontPropagateMask = DontPropagateMasks[pWin->dontPropagate];
    optional->otherEventMasks = 0;
    optional->otherClients = NULL;
    optional->passiveGrabs = NULL;
    optional->userProps = NULL;
    optional->backingBitPlanes = ~0L;
    optional->backingPixel = 0;
    optional->boundingShape = NULL;
    optional->clipShape = NULL;
    optional->inputShape = NULL;
    optional->inputMasks = NULL;
    optional->deviceCursors = NULL;

    parentOptional = FindWindowWithOptional(pWin)->optional;
    optional->visual = parentOptional->visual;
    if (!pWin->cursorIsNone) {
        optional->cursor = RefCursor(parentOptional->cursor);
    }
    else {
        optional->cursor = None;
    }
    optional->colormap = parentOptional->colormap;
    pWin->optional = optional;
    return TRUE;
}

/*
 * Changes the cursor struct for the given device and the given window.
 * A cursor that does not have a device cursor set will use whatever the
 * standard cursor is for the window. If all devices have a cursor set,
 * changing the window cursor (e.g. using XDefineCursor()) will not have any
 * visible effect. Only when one of the device cursors is set to None again,
 * this device's cursor will display the changed standard cursor.
 *
 * CursorIsNone of the window struct is NOT modified if you set a device
 * cursor.
 *
 * Assumption: If there is a node for a device in the list, the device has a
 * cursor. If the cursor is set to None, it is inherited by the parent.
 */
int
ChangeWindowDeviceCursor(WindowPtr pWin, DeviceIntPtr pDev, CursorPtr pCursor)
{
    DevCursNodePtr pNode, pPrev;
    CursorPtr pOldCursor = NULL;
    ScreenPtr pScreen;
    WindowPtr pChild;

    if (!pWin->optional && !MakeWindowOptional(pWin))
        return BadAlloc;

    /* 1) Check if window has device cursor set
     *  Yes: 1.1) swap cursor with given cursor if parent does not have same
     *            cursor, free old cursor
     *       1.2) free old cursor, use parent cursor
     *  No: 1.1) add node to beginning of list.
     *      1.2) add cursor to node if parent does not have same cursor
     *      1.3) use parent cursor if parent does not have same cursor
     *  2) Patch up children if child has a devcursor
     *  2.1) if child has cursor None, it inherited from parent, set to old
     *  cursor
     *  2.2) if child has same cursor as new cursor, remove and set to None
     */

    pScreen = pWin->drawable.pScreen;

    if (WindowSeekDeviceCursor(pWin, pDev, &pNode, &pPrev)) {
        /* has device cursor */

        if (pNode->cursor == pCursor)
            return Success;

        pOldCursor = pNode->cursor;

        if (!pCursor) {         /* remove from list */
            if (pPrev)
                pPrev->next = pNode->next;
            else
                /* first item in list */
                pWin->optional->deviceCursors = pNode->next;

            free(pNode);
            goto out;
        }

    }
    else {
        /* no device cursor yet */
        DevCursNodePtr pNewNode;

        if (!pCursor)
            return Success;

        pNewNode = malloc(sizeof(DevCursNodeRec));
        pNewNode->dev = pDev;
        pNewNode->next = pWin->optional->deviceCursors;
        pWin->optional->deviceCursors = pNewNode;
        pNode = pNewNode;

    }

    if (pCursor && WindowParentHasDeviceCursor(pWin, pDev, pCursor))
        pNode->cursor = None;
    else {
        pNode->cursor = RefCursor(pCursor);
    }

    pNode = pPrev = NULL;
    /* fix up children */
    for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
        if (WindowSeekDeviceCursor(pChild, pDev, &pNode, &pPrev)) {
            if (pNode->cursor == None) {        /* inherited from parent */
                pNode->cursor = RefCursor(pOldCursor);
            }
            else if (pNode->cursor == pCursor) {
                pNode->cursor = None;
                FreeCursor(pCursor, (Cursor) 0);        /* fix up refcnt */
            }
        }
    }

 out:
    CursorVisible = TRUE;

    if (pWin->realized)
        WindowHasNewCursor(pWin);

    if (pOldCursor)
        FreeCursor(pOldCursor, (Cursor) 0);

    /* FIXME: We SHOULD check for an error value here XXX
       (comment taken from ChangeWindowAttributes) */
    (*pScreen->ChangeWindowAttributes) (pWin, CWCursor);

    return Success;
}

/* Get device cursor for given device or None if none is set */
CursorPtr
WindowGetDeviceCursor(WindowPtr pWin, DeviceIntPtr pDev)
{
    DevCursorList pList;

    if (!pWin->optional || !pWin->optional->deviceCursors)
        return NULL;

    pList = pWin->optional->deviceCursors;

    while (pList) {
        if (pList->dev == pDev) {
            if (pList->cursor == None)  /* inherited from parent */
                return WindowGetDeviceCursor(pWin->parent, pDev);
            else
                return pList->cursor;
        }
        pList = pList->next;
    }
    return NULL;
}

/* Searches for a DevCursorNode for the given window and device. If one is
 * found, return True and set pNode and pPrev to the node and to the node
 * before the node respectively. Otherwise return False.
 * If the device is the first in list, pPrev is set to NULL.
 */
static Bool
WindowSeekDeviceCursor(WindowPtr pWin,
                       DeviceIntPtr pDev,
                       DevCursNodePtr * pNode, DevCursNodePtr * pPrev)
{
    DevCursorList pList;

    if (!pWin->optional)
        return FALSE;

    pList = pWin->optional->deviceCursors;

    if (pList && pList->dev == pDev) {
        *pNode = pList;
        *pPrev = NULL;
        return TRUE;
    }

    while (pList) {
        if (pList->next) {
            if (pList->next->dev == pDev) {
                *pNode = pList->next;
                *pPrev = pList;
                return TRUE;
            }
        }
        pList = pList->next;
    }
    return FALSE;
}

/* Return True if a parent has the same device cursor set or False if
 * otherwise
 */
static Bool
WindowParentHasDeviceCursor(WindowPtr pWin,
                            DeviceIntPtr pDev, CursorPtr pCursor)
{
    WindowPtr pParent;
    DevCursNodePtr pParentNode, pParentPrev;

    pParent = pWin->parent;
    while (pParent) {
        if (WindowSeekDeviceCursor(pParent, pDev, &pParentNode, &pParentPrev)) {
            /* if there is a node in the list, the win has a dev cursor */
            if (!pParentNode->cursor)   /* inherited. */
                pParent = pParent->parent;
            else if (pParentNode->cursor == pCursor)    /* inherit */
                return TRUE;
            else                /* different cursor */
                return FALSE;
        }
        else
            /* parent does not have a device cursor for our device */
            return FALSE;
    }
    return FALSE;
}

/*
 * SetRootClip --
 *	Enable or disable rendering to the screen by
 *	setting the root clip list and revalidating
 *	all of the windows
 */
void
SetRootClip(ScreenPtr pScreen, int enable)
{
    WindowPtr pWin = pScreen->root;
    WindowPtr pChild;
    Bool WasViewable;
    Bool anyMarked = FALSE;
    WindowPtr pLayerWin;
    BoxRec box;
    enum RootClipMode mode = enable;

    if (!pWin)
        return;
    WasViewable = (Bool) (pWin->viewable);
    if (WasViewable) {
        for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
            (void) (*pScreen->MarkOverlappedWindows) (pChild,
                                                      pChild, &pLayerWin);
        }
        (*pScreen->MarkWindow) (pWin);
        anyMarked = TRUE;
        if (pWin->valdata) {
            if (HasBorder(pWin)) {
                RegionPtr borderVisible;

                borderVisible = RegionCreate(NullBox, 1);
                RegionSubtract(borderVisible,
                               &pWin->borderClip, &pWin->winSize);
                pWin->valdata->before.borderVisible = borderVisible;
            }
            pWin->valdata->before.resized = TRUE;
        }
    }

    if (mode != ROOT_CLIP_NONE) {
        pWin->drawable.width = pScreen->width;
        pWin->drawable.height = pScreen->height;

        box.x1 = 0;
        box.y1 = 0;
        box.x2 = pScreen->width;
        box.y2 = pScreen->height;

        RegionInit(&pWin->winSize, &box, 1);
        RegionInit(&pWin->borderSize, &box, 1);

        /*
         * Use REGION_BREAK to avoid optimizations in ValidateTree
         * that assume the root borderClip can't change well, normally
         * it doesn't...)
         */
        RegionBreak(&pWin->clipList);

	/* For INPUT_ONLY, empty the borderClip so no rendering will ever
	 * be attempted to the screen pixmap (only redirected windows),
	 * but we keep borderSize as full regardless. */
        if (WasViewable && mode == ROOT_CLIP_FULL)
            RegionReset(&pWin->borderClip, &box);
        else
            RegionEmpty(&pWin->borderClip);
    }
    else {
        RegionEmpty(&pWin->borderClip);
        RegionBreak(&pWin->clipList);
    }

    ResizeChildrenWinSize(pWin, 0, 0, 0, 0);

    if (WasViewable) {
        if (pWin->firstChild) {
            anyMarked |= (*pScreen->MarkOverlappedWindows) (pWin->firstChild,
                                                            pWin->firstChild,
                                                            NULL);
        }
        else {
            (*pScreen->MarkWindow) (pWin);
            anyMarked = TRUE;
        }

        if (anyMarked) {
            (*pScreen->ValidateTree) (pWin, NullWindow, VTOther);
            (*pScreen->HandleExposures) (pWin);
            if (pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pWin, NullWindow, VTOther);
        }
    }
    if (pWin->realized)
        WindowsRestructured();
    FlushAllOutput();
}

VisualPtr
WindowGetVisual(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    VisualID vid = wVisual(pWin);
    int i;

    for (i = 0; i < pScreen->numVisuals; i++)
        if (pScreen->visuals[i].vid == vid)
            return &pScreen->visuals[i];
    return 0;
}
@


1.15
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d130 1
a223 1
    ScreenPtr pScreen = pWin->drawable.pScreen;
d243 1
a243 1
               (unsigned) pScreen->GetWindowPixmap(pWin)->drawable.id);
d262 1
a262 1
    if (REGION_NOTEMPTY(pScreen, &pWin->clipList)) {
d264 2
a265 2
        rects = REGION_RECTS(&pWin->clipList);
        for (i = 0; i < REGION_NUM_RECTS(&pWin->clipList); i++)
d276 125
d508 1
a508 4

#ifdef ROOTLESS
    pWin->rootlessUnhittable = FALSE;
#endif
d1595 1
a1595 1
        miPaintWindow(pWin, &exposed, PW_BORDER);
d3162 1
a3162 1
                 * for the root window, so miPaintWindow works
d3650 1
a3650 1
SetRootClip(ScreenPtr pScreen, Bool enable)
d3658 1
d3683 4
a3686 6
    /*
     * Use REGION_BREAK to avoid optimizations in ValidateTree
     * that assume the root borderClip can't change well, normally
     * it doesn't...)
     */
    if (enable) {
d3691 1
d3694 12
a3705 1
        if (WasViewable)
d3707 2
a3708 3
        pWin->drawable.width = pScreen->width;
        pWin->drawable.height = pScreen->height;
        RegionBreak(&pWin->clipList);
@


1.14
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d52 2
a53 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d55 1
a55 1
both that copyright notice and this permission notice appear in 
d58 1
a58 1
software without specific, written prior permission.  
d138 1
a138 1
 * Window stuff for server 
d360 2
a361 2
    pWin->valdata = (ValidatePtr) NULL;
    pWin->optional = (WindowOptPtr) NULL;
d365 1
a365 2
    pWin->DIXsaveUnder = FALSE;
    pWin->backStorage = (void *) NULL;
d636 1
a636 1
 *    Makes a window in response to client request 
d1041 1
a1041 1
 *   
d1044 1
a1044 1
 *  to most significant bit in the mask.  
d1462 2
a1463 2
    /* 
       If the border contents have changed, redraw the border. 
d1553 1
a1553 1
            pWin->prevSib = (WindowPtr) NULL;
a1814 2
#define IllegalInputOnlyConfigureMask (CWBorderWidth)

d1817 1
a1817 1
 *     returns Above if pSib above pMe in stack or Below otherwise 
d1848 1
a1848 1
#define IS_SHAPED(pWin)	(wBoundingShape (pWin) != (RegionPtr) NULL)
d1917 1
a1917 1
 *   WhereDoIGoInTheStack() 
d1925 1
a1925 1
 *	      BottomIf:	 if pWin occludes pSib, then pWin is 
d1954 1
a1954 1
        return ((WindowPtr) NULL);
d2062 3
a2065 3
        if (anyMarked && pWin->drawable.pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pLayerWin->parent, pFirstChange,
                                          kind);
d2092 1
a2092 2
    if ((pWin->drawable.class == InputOnly) &&
        (mask & IllegalInputOnlyConfigureMask))
d2319 1
a2319 1
 *    child to the bottom of the stack.	 Exposure processing is performed 
d2579 3
a2582 3
            if (anyMarked && pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pLayerWin->parent, pLayerWin,
                                              VTMap);
d2600 1
a2600 1
        (*pScreen->WindowExposures) (pWin, &temp, NullRegion);
d2644 1
a2644 2
                                                                    (WindowPtr
                                                                     *) NULL);
d2654 1
a2654 2
                                                            pLayerWin,
                                                            (WindowPtr *) NULL);
d2660 3
a2663 3
        if (anyMarked && pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pLayerWin->parent, pFirstMapped,
                                          VTMap);
d2757 2
a2759 2
        if (!fromConfigure && pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pLayerWin->parent, pWin, VTUnmap);
a2803 2
            if (wasViewable) {
            }
d2813 1
a2813 2
                (*pScreen->MarkOverlappedWindows) (pWin, pLayerWin,
                                                   (WindowPtr *) NULL);
d2827 3
a2830 2
        if (anyMarked && pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pLayerWin->parent, pHead, VTUnmap);
d2873 1
a2873 1
    client->saveSet = (SaveSetElt *) NULL;
d3246 1
a3246 1
    if (optional->backingBitPlanes != ~0L)
d3330 1
a3330 1
 * 
d3332 1
a3332 1
 * cursor. 
d3427 1
a3427 1
    /* FIXME: We SHOULD check for an error value here XXX  
d3494 1
a3494 1
 * otherwise 
d3589 1
a3589 1
                                                            (WindowPtr *) NULL);
d3596 1
a3596 1
        if (anyMarked)
a3597 4
    }

    if (WasViewable) {
        if (anyMarked)
d3599 3
a3601 2
        if (anyMarked && pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pWin, NullWindow, VTOther);
@


1.13
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d230 1
a230 1
           pWin->drawable.id,
d243 1
a243 1
               pScreen->GetWindowPixmap(pWin)->drawable.id);
d286 1
a286 1
               pScreen->GetScreenPixmap(pScreen)->drawable.id);
d308 1
a308 1
TraverseTree(WindowPtr pWin, VisitWindowProcPtr func, pointer data)
d341 1
a341 1
WalkTree(ScreenPtr pScreen, VisitWindowProcPtr func, pointer data)
d366 1
a366 1
    pWin->backStorage = (pointer) NULL;
d527 1
a527 1
    if (!AddResource(pWin->drawable.id, RT_WINDOW, (pointer) pWin))
d962 1
a962 1
DeleteWindow(pointer value, XID wid)
d1110 1
a1110 1
                rc = dixLookupResourceByType((pointer *) &pPixmap, pixID,
d1164 1
a1164 1
            rc = dixLookupResourceByType((pointer *) &pPixmap, pixID, RT_PIXMAP,
d1311 1
a1311 1
            rc = dixLookupResourceByType((pointer *) &pCmap, cmap, RT_COLORMAP,
d1381 1
a1381 1
                rc = dixLookupResourceByType((pointer *) &pCursor, cursorID,
d2380 1
a2380 1
CompareWIDs(WindowPtr pWin, pointer value)
d2405 1
a2405 1
    if (TraverseTree(pWin, CompareWIDs, (pointer) &pParent->drawable.id) ==
d2691 1
a2691 1
                int rc = dixLookupResourceByType((pointer *) &win,
d3170 1
a3170 1
            if (AddResource(cursorID, RT_CURSOR, (pointer) cursor)) {
d3199 1
a3199 1
                     (pointer) pScreen->screensaver.pWindow))
@


1.12
log
@Update to xserver 1.14.4
@
text
@d533 5
a537 1
        pScreen->backingStoreSupport = Always;
d1437 2
a2853 1
#ifdef XFIXES
a2856 1
#endif
a2863 1
#ifdef XFIXES
a2866 1
#endif
a2874 1
#ifdef XFIXES
a2875 1
#endif
d3427 2
@


1.11
log
@Update to xserver 1.14.3
@
text
@d129 1
d3096 1
a3096 3
                lastDeviceEventTime[dev->id] = currentTime;
            lastDeviceEventTime[XIAllDevices] = currentTime;
            lastDeviceEventTime[XIAllMasterDevices] = currentTime;
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d550 1
a550 2
    pWin->optional->cursor = rootCursor;
    rootCursor->refcnt++;
d1418 1
a1418 2
                    pWin->optional->cursor = pCursor;
                    pCursor->refcnt++;
d3322 1
a3322 2
        optional->cursor = parentOptional->cursor;
        optional->cursor->refcnt++;
d3410 1
a3410 2
        pNode->cursor = pCursor;
        pCursor->refcnt++;
d3418 1
a3418 2
                pNode->cursor = pOldCursor;
                pOldCursor->refcnt++;
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d449 1
a449 1
    pWin = dixAllocateObjectWithPrivates(WindowRec, PRIVATE_WINDOW);
a643 1
    xEvent event;
d683 1
a683 1
            pDepth = (DepthPtr) & pScreen->allowedDepths[idepth];
d712 1
a712 1
    pWin = dixAllocateObjectWithPrivates(WindowRec, PRIVATE_WINDOW);
d830 10
a839 1
        memset(&event, 0, sizeof(xEvent));
a840 8
        event.u.createNotify.window = wid;
        event.u.createNotify.parent = pParent->drawable.id;
        event.u.createNotify.x = x;
        event.u.createNotify.y = y;
        event.u.createNotify.width = w;
        event.u.createNotify.height = h;
        event.u.createNotify.borderWidth = bw;
        event.u.createNotify.override = pWin->overrideRedirect;
a914 1
    xEvent event;
d927 1
a927 2
                memset(&event, 0, sizeof(xEvent));
                event.u.u.type = DestroyNotify;
a961 1
    xEvent event;
d969 1
a969 2
        memset(&event, 0, sizeof(xEvent));
        event.u.u.type = DestroyNotify;
d1354 6
a1360 4
                xE.u.colormap.window = pWin->drawable.id;
                xE.u.colormap.colormap = cmap;
                xE.u.colormap.new = xTrue;
                xE.u.colormap.state = IsMapInstalled(cmap, pWin);
d1747 5
a1751 2
                xEvent event;

a1752 3
                event.u.gravity.window = pSib->drawable.id;
                event.u.gravity.x = cwsx - wBorderWidth(pSib);
                event.u.gravity.y = cwsy - wBorderWidth(pSib);
d1889 1
a1889 2
                && ShapeOverlap(pWin, box, pSib, sbox)
                )
d1907 1
a1907 2
                && ShapeOverlap(pWin, box, pSib, sbox)
                )
a2088 1
    xEvent event;
d2175 12
a2186 3
    if ((!pWin->overrideRedirect) && (RedirectSend(pParent)
        )) {
        memset(&event, 0, sizeof(xEvent));
d2188 1
a2188 11
        event.u.configureRequest.window = pWin->drawable.id;
        if (mask & CWSibling)
            event.u.configureRequest.sibling = sibwid;
        else
            event.u.configureRequest.sibling = None;
        if (mask & CWStackMode)
            event.u.u.detail = smode;
        else
            event.u.u.detail = Above;
        event.u.configureRequest.x = x;
        event.u.configureRequest.y = y;
a2194 5
        event.u.configureRequest.width = w;
        event.u.configureRequest.height = h;
        event.u.configureRequest.borderWidth = bw;
        event.u.configureRequest.valueMask = mask;
        event.u.configureRequest.parent = pParent->drawable.id;
d2205 5
a2209 3
            xEvent eventT;

            memset(&eventT, 0, sizeof(xEvent));
a2210 3
            eventT.u.resizeRequest.window = pWin->drawable.id;
            eventT.u.resizeRequest.width = w;
            eventT.u.resizeRequest.height = h;
d2261 10
a2270 1
        memset(&event, 0, sizeof(xEvent));
a2271 7
        event.u.configureNotify.window = pWin->drawable.id;
        if (pSib)
            event.u.configureNotify.aboveSibling = pSib->drawable.id;
        else
            event.u.configureNotify.aboveSibling = None;
        event.u.configureNotify.x = x;
        event.u.configureNotify.y = y;
a2277 4
        event.u.configureNotify.width = w;
        event.u.configureNotify.height = h;
        event.u.configureNotify.borderWidth = bw;
        event.u.configureNotify.override = pWin->overrideRedirect;
d2350 7
a2356 7
    event.u.circulate.window = pWin->drawable.id;
    event.u.circulate.parent = pParent->drawable.id;
    event.u.circulate.event = pParent->drawable.id;
    if (direction == RaiseLowest)
        event.u.circulate.place = PlaceOnTop;
    else
        event.u.circulate.place = PlaceOnBottom;
d2409 7
a2415 1
    memset(&event, 0, sizeof(xEvent));
a2416 4
    event.u.reparent.window = pWin->drawable.id;
    event.u.reparent.parent = pParent->drawable.id;
    event.u.reparent.x = x;
    event.u.reparent.y = y;
a2422 1
    event.u.reparent.override = pWin->overrideRedirect;
d2508 2
a2509 4
static WindowPtr windowDisableMapUnmapEvents;

void
DisableMapUnmapEvents(WindowPtr pWin)
d2511 9
a2519 3
    assert(windowDisableMapUnmapEvents == NULL);

    windowDisableMapUnmapEvents = pWin;
d2522 2
a2523 2
void
EnableMapUnmapEvents(WindowPtr pWin)
d2525 6
a2530 9
    assert(windowDisableMapUnmapEvents != NULL);

    windowDisableMapUnmapEvents = NULL;
}

static Bool
MapUnmapEventsEnabled(WindowPtr pWin)
{
    return pWin != windowDisableMapUnmapEvents;
d2552 1
a2552 1
    /*  general check for permission to map window */
a2558 1
        xEvent event;
d2561 2
a2562 10
        if ((!pWin->overrideRedirect) && (RedirectSend(pParent)
            )) {
            memset(&event, 0, sizeof(xEvent));
            event.u.u.type = MapRequest;
            event.u.mapRequest.window = pWin->drawable.id;
            event.u.mapRequest.parent = pParent->drawable.id;

            if (MaybeDeliverEventsToClient(pParent, &event, 1,
                                           SubstructureRedirectMask,
                                           client) == 1)
a2563 1
        }
d2566 2
a2567 7
        if (SubStrSend(pWin, pParent) && MapUnmapEventsEnabled(pWin)) {
            memset(&event, 0, sizeof(xEvent));
            event.u.u.type = MapNotify;
            event.u.mapNotify.window = pWin->drawable.id;
            event.u.mapNotify.override = pWin->overrideRedirect;
            DeliverEvents(pWin, &event, 1, NullWindow);
        }
a2619 1
    xEvent event;
d2629 2
a2630 9
            if (parentRedirect && !pWin->overrideRedirect) {
                memset(&event, 0, sizeof(xEvent));
                event.u.u.type = MapRequest;
                event.u.mapRequest.window = pWin->drawable.id;
                event.u.mapRequest.parent = pParent->drawable.id;

                if (MaybeDeliverEventsToClient(pParent, &event, 1,
                                               SubstructureRedirectMask,
                                               client) == 1)
a2631 1
            }
d2634 2
a2635 7
            if (parentNotify || StrSend(pWin)) {
                memset(&event, 0, sizeof(xEvent));
                event.u.u.type = MapNotify;
                event.u.mapNotify.window = pWin->drawable.id;
                event.u.mapNotify.override = pWin->overrideRedirect;
                DeliverEvents(pWin, &event, 1, NullWindow);
            }
d2696 1
a2696 2
            if (MapUnmapEventsEnabled(pWin))
                DeleteWindowFromAnyEvents(pChild, FALSE);
d2715 11
a2736 1
    xEvent event;
d2744 2
a2745 7
    if (SubStrSend(pWin, pParent) && MapUnmapEventsEnabled(pWin)) {
        memset(&event, 0, sizeof(xEvent));
        event.u.u.type = UnmapNotify;
        event.u.unmapNotify.window = pWin->drawable.id;
        event.u.unmapNotify.fromConfigure = fromConfigure;
        DeliverEvents(pWin, &event, 1, NullWindow);
    }
a2778 1
    xEvent event;
d2796 2
a2797 6
            if (parentNotify || StrSend(pChild)) {
                event.u.u.type = UnmapNotify;
                event.u.unmapNotify.window = pChild->drawable.id;
                event.u.unmapNotify.fromConfigure = xFalse;
                DeliverEvents(pChild, &event, 1, NullWindow);
            }
a2923 2
    if (!MapUnmapEventsEnabled(pWin))
        return;
d2987 4
a2990 1
    memset(&event, 0, sizeof(xEvent));
a2991 2
    event.u.visibility.window = pWin->drawable.id;
    event.u.visibility.state = visibility;
d3094 1
d3096 4
a3099 1
            lastDeviceEventTime = currentTime;
d3621 13
@


1.8
log
@Update to xserver 1.11.2
@
text
@a47 1

a98 1

d125 1
a125 1
#include "mi.h" /* miPaintWindow */
d132 1
d134 1
a134 1
#include <X11/Xatom.h> /* must come after server includes */
d148 6
a153 2
static unsigned char _back_lsb[4] = {0x88, 0x22, 0x44, 0x11};
static unsigned char _back_msb[4] = {0x11, 0x44, 0x22, 0x88};
d155 3
a157 8
static Bool WindowParentHasDeviceCursor(WindowPtr pWin, 
                                        DeviceIntPtr pDev, 
                                        CursorPtr pCurs);
static Bool 
WindowSeekDeviceCursor(WindowPtr pWin, 
                       DeviceIntPtr pDev, 
                       DevCursNodePtr* pNode, 
                       DevCursNodePtr* pPrev);
d194 1
d202 1
a202 2
    for (prop = wUserProps(pWin); prop; prop = prop->next)
    {
d204 1
a204 2
            prop->data)
        {
d216 2
a217 1
static void log_window_info(WindowPtr pWin, int depth)
d241 1
a241 1
                "automatic" : "manual",
d245 1
a245 2
    switch (pWin->visibility)
    {
d247 2
a248 2
         visibility = "unobscured";
         break;
d250 2
a251 2
         visibility = "partially obscured";
         break;
d253 2
a254 2
         visibility = "fully obscured";
         break;
d256 2
a257 2
         visibility = "unviewable";
         break;
d261 1
a261 2
    if (REGION_NOTEMPTY(pScreen, &pWin->clipList))
    {
d266 1
a266 2
                   rects[i].x1, rects[i].y1,
                   rects[i].x2, rects[i].y2);
d282 1
a282 2
    for (scrnum = 0; scrnum < screenInfo.numScreens; scrnum++)
    {
d288 1
a288 2
        while (pWin)
        {
d290 1
a290 2
            if (pWin->firstChild)
            {
d295 1
a295 2
            while (pWin && !pWin->nextSib)
            {
d302 1
a302 1
	}
d313 14
a326 16
       return WT_NOMATCH;
    while (1)
    {
	result = (* func)(pChild, data);
	if (result == WT_STOPWALKING)
	    return WT_STOPWALKING;
	if ((result == WT_WALKCHILDREN) && pChild->firstChild)
	{
	    pChild = pChild->firstChild;
	    continue;
	}
	while (!pChild->nextSib && (pChild != pWin))
	    pChild = pChild->parent;
	if (pChild == pWin)
	    break;
	pChild = pChild->nextSib;
d342 1
a342 1
    return(TraverseTree(pScreen->root, func, data));
d346 2
a347 1
int	defaultBackingStore = NotUseful;
d349 2
a350 2
Bool	disableBackingStore = FALSE;
Bool	enableBackingStore = FALSE;
d359 2
a360 2
    pWin->valdata = (ValidatePtr)NULL;
    pWin->optional = (WindowOptPtr)NULL;
d367 2
a368 2
    pWin->mapped = FALSE;	    /* off */
    pWin->realized = FALSE;	/* off */
d403 2
a404 2
    pWin->background.pixmap = (*pScreen->CreatePixmap)(pScreen, 4, 4,
						    pScreen->rootDepth, 0);
d409 1
a409 1
	FatalError("could not create root tile");
d412 1
a412 1
	ChangeGCVal attributes[2];
d414 2
a415 2
	attributes[0].val = pScreen->whitePixel;
	attributes[1].val = pScreen->blackPixel;
d417 2
a418 1
	(void)ChangeGC(NullClient, pGC, GCForeground | GCBackground, attributes);
d421 1
a421 1
   ValidateGC((DrawablePtr)pWin->background.pixmap, pGC);
d423 2
a424 2
   from = (screenInfo.bitmapBitOrder == LSBFirst) ? _back_lsb : _back_msb;
   to = back;
d426 3
a428 3
   for (i = 4; i > 0; i--, from++)
	for (j = len; j > 0; j--)
	    *to++ = *from;
d430 2
a431 2
   (*pGC->ops->PutImage)((DrawablePtr)pWin->background.pixmap, pGC, 1,
		    0, 0, len, 4, 0, XYBitmap, (char *)back);
d433 1
a433 1
   FreeScratchGC(pGC);
d445 2
a446 2
    WindowPtr	pWin;
    BoxRec	box;
d451 1
a451 1
	return FALSE;
d465 1
a465 3
	 format->depth != pScreen->rootDepth;
	 format++)
	;
d473 1
a473 1
    pWin->optional = malloc(sizeof (WindowOptRec));
d523 2
a524 2
		 RT_WINDOW, pWin, RT_NONE, NULL, DixCreateAccess))
	return FALSE;
d526 2
a527 2
    if (!AddResource(pWin->drawable.id, RT_WINDOW, (pointer)pWin))
	return FALSE;
d530 1
a530 1
	pScreen->backingStoreSupport = NotUseful;
d532 1
a532 1
	pScreen->backingStoreSupport = Always;
d545 3
a547 3
    if (!(*pScreen->CreateWindow)(pWin))
	return; /* XXX */
    (*pScreen->PositionWindow)(pWin, 0, 0);
a552 1

d556 2
a557 1
    } else if (pScreen->canDoBGNoneRoot && bgNoneRoot) {
d561 2
a562 1
    } else {
d564 1
a564 1
	if (whiteRoot)
d569 1
a569 1
    } 
d574 1
a574 1
    (*pScreen->ChangeWindowAttributes)(pWin, backFlag);
d585 1
a585 3
ClippedRegionFromBox(WindowPtr pWin, RegionPtr Rgn,
                     int x, int y,
                     int w, int h)
d591 1
a591 1
	box.x1 = x;
d593 1
a593 1
	box.y1 = y;
d596 1
a596 1
	box.x2 = x;
d599 1
a599 1
	box.y2 = y;
d601 1
a601 1
	box.x2 = box.x1;
d603 1
a603 1
	box.y2 = box.y1;
d611 1
a611 1
RegisterRealChildHeadProc (RealChildHeadProc proc)
a615 1

d620 1
a620 1
	return realChildHeadProc (pWin);
d624 3
a626 3
	(screenIsSaved == SCREEN_SAVER_ON) &&
	(HasSaverWindow (pWin->drawable.pScreen)))
	return pWin->firstChild;
d628 1
a628 1
	return NullWindow;
d652 1
a652 1
	class = pParent->drawable.class;
d654 4
a657 5
    if ((class != InputOutput) && (class != InputOnly))
    {
	*error = BadValue;
	client->errorValue = class;
	return NullWindow;
d660 3
a662 4
    if ((class != InputOnly) && (pParent->drawable.class == InputOnly))
    {
	*error = BadMatch;
	return NullWindow;
d665 3
a667 4
    if ((class == InputOnly) && ((bw != 0) || (depth != 0)))
    {
	*error = BadMatch;
	return NullWindow;
d672 1
a672 1
	 depth = pParent->drawable.depth;
d675 1
a675 1
	ancwopt = FindWindowWithOptional(pParent)->optional;
d677 1
a677 1
	visual = ancwopt->visual;
d681 17
a697 23
    if ((visual != ancwopt->visual) || (depth != pParent->drawable.depth))
    {
	fOK = FALSE;
	for(idepth = 0; idepth < pScreen->numDepths; idepth++)
	{
	    pDepth = (DepthPtr) &pScreen->allowedDepths[idepth];
	    if ((depth == pDepth->depth) || (depth == 0))
	    {
		for (ivisual = 0; ivisual < pDepth->numVids; ivisual++)
		{
		    if (visual == pDepth->vids[ivisual])
		    {
			fOK = TRUE;
			break;
		    }
		}
	    }
	}
	if (fOK == FALSE)
	{
	    *error = BadMatch;
	    return NullWindow;
	}
d701 3
a703 5
	(class != InputOnly) &&
	(depth != pParent->drawable.depth))
    {
	*error = BadMatch;
	return NullWindow;
d707 4
a710 5
	(class != InputOnly) &&
	((visual != ancwopt->visual) || (ancwopt->colormap == None)))
    {
	*error = BadMatch;
	return NullWindow;
d714 3
a716 4
    if (!pWin)
    {
	*error = BadAlloc;
	return NullWindow;
d721 4
a724 6
	pWin->drawable.bitsPerPixel = pParent->drawable.bitsPerPixel;
    else
    {
	for (format = screenInfo.formats; format->depth != depth; format++)
	    ;
	pWin->drawable.bitsPerPixel = format->bitsPerPixel;
d727 1
a727 1
	pWin->drawable.type = (short) UNDRAWABLE_WINDOW;
d736 8
a743 10
    if (visual != ancwopt->visual)
    {
	if (!MakeWindowOptional (pWin))
	{
	    dixFreeObjectWithPrivates(pWin, PRIVATE_WINDOW);
	    *error = BadAlloc;
	    return NullWindow;
	}
	pWin->optional->visual = visual;
	pWin->optional->colormap = None;
d751 2
a752 1
		RT_WINDOW, pWin->parent, DixCreateAccess|DixSetAttrAccess);
d754 2
a755 2
	dixFreeObjectWithPrivates(pWin, PRIVATE_WINDOW);
	return NullWindow;
d764 4
a767 4
	pWin->border.pixmap->refcnt++;
		
    pWin->origin.x = x + (int)bw;
    pWin->origin.y = y + (int)bw;
d770 2
a771 2
    pWin->drawable.x = pParent->drawable.x + x + (int)bw;
    pWin->drawable.y = pParent->drawable.y + y + (int)bw;
d773 1
a773 1
	/* set up clip list correctly for unobscured WindowPtr */
d780 8
a787 9
    if (pHead)
    {
	pWin->nextSib = pHead->nextSib;
	if (pHead->nextSib)
	    pHead->nextSib->prevSib = pWin;
	else
	    pParent->lastChild = pWin;
	pHead->nextSib = pWin;
	pWin->prevSib = pHead;
d789 7
a795 8
    else
    {
	pWin->nextSib = pParent->firstChild;
	if (pParent->firstChild)
	    pParent->firstChild->prevSib = pWin;
	else
	    pParent->lastChild = pWin;
	pParent->firstChild = pWin;
d798 2
a799 2
    SetWinSize (pWin);
    SetBorderSize (pWin);
d802 4
a805 5
    if (!(*pScreen->CreateWindow)(pWin))
    {
	*error = BadAlloc;
	DeleteWindow(pWin, None);
	return NullWindow;
d808 1
a808 1
    (*pScreen->PositionWindow)(pWin, pWin->drawable.x, pWin->drawable.y);
d811 1
a811 1
	RecalculateDeliverableEvents(pWin);
d814 1
a814 1
	*error = ChangeWindowAttributes(pWin, vmask, vlist, wClient (pWin));
d816 1
a816 1
	*error = Success;
d818 3
a820 10
    if (*error != Success)
    {
	DeleteWindow(pWin, None);
	return NullWindow;
    }
    if (!(vmask & CWBackingStore) && (defaultBackingStore != NotUseful))
    {
	XID value = defaultBackingStore;
	(void)ChangeWindowAttributes(pWin, CWBackingStore, &value, wClient (pWin));
	pWin->forcedBS = TRUE;
d822 2
d825 17
a841 13
    if (SubSend(pParent))
    {
	memset(&event, 0, sizeof(xEvent));
	event.u.u.type = CreateNotify;
	event.u.createNotify.window = wid;
	event.u.createNotify.parent = pParent->drawable.id;
	event.u.createNotify.x = x;
	event.u.createNotify.y = y;
	event.u.createNotify.width = w;
	event.u.createNotify.height = h;
	event.u.createNotify.borderWidth = bw;
	event.u.createNotify.override = pWin->overrideRedirect;
	DeliverEvents(pParent, &event, 1, NullWindow);		
d847 1
a847 1
DisposeWindowOptional (WindowPtr pWin)
d850 1
a850 1
	return;
d855 3
a857 4
    if (pWin->optional->cursor)
    {
	FreeCursor (pWin->optional->cursor, (Cursor)0);
	pWin->cursorIsNone = FALSE;
d860 1
a860 1
	pWin->cursorIsNone = TRUE;
d862 1
a862 2
    if (pWin->optional->deviceCursors)
    {
d865 1
d867 1
a867 2
        while(pList)
        {
d869 1
a869 1
                FreeCursor(pList->cursor, (XID)0);
d893 6
a898 6
    if (wBoundingShape (pWin))
	RegionDestroy(wBoundingShape (pWin));
    if (wClipShape (pWin))
	RegionDestroy(wClipShape (pWin));
    if (wInputShape (pWin))
	RegionDestroy(wInputShape (pWin));
d900 1
a900 1
	(*pScreen->DestroyPixmap)(pWin->border.pixmap);
d902 1
a902 1
	(*pScreen->DestroyPixmap)(pWin->background.pixmap);
d906 2
a907 2
    (*pScreen->DestroyWindow)(pWin);
    DisposeWindowOptional (pWin);
d918 1
a918 1
	return;
d920 30
a949 35
    while (1)
    {
	if (pChild->firstChild)
	{
	    pChild = pChild->firstChild;
	    continue;
	}
	while (1)
	{
	    pParent = pChild->parent;
	    if (SubStrSend(pChild, pParent))
	    {
		memset(&event, 0, sizeof(xEvent));
		event.u.u.type = DestroyNotify;
		event.u.destroyNotify.window = pChild->drawable.id;
		DeliverEvents(pChild, &event, 1, NullWindow);
	    }
	    FreeResource(pChild->drawable.id, RT_WINDOW);
	    pSib = pChild->nextSib;
	    pChild->viewable = FALSE;
	    if (pChild->realized)
	    {
		pChild->realized = FALSE;
		(*UnrealizeWindow)(pChild);
	    }
	    FreeWindowResources(pChild);
	    dixFreeObjectWithPrivates(pChild, PRIVATE_WINDOW);
	    if ( (pChild = pSib) )
		break;
	    pChild = pParent;
	    pChild->firstChild = NullWindow;
	    pChild->lastChild = NullWindow;
	    if (pChild == pWin)
		return;
	}
d952 1
a952 1
	
d961 1
a961 1
 {
d963 1
a963 1
    WindowPtr pWin = (WindowPtr)value;
d971 5
a975 6
    if (wid && pParent && SubStrSend(pWin, pParent))
    {
	memset(&event, 0, sizeof(xEvent));
	event.u.u.type = DestroyNotify;
	event.u.destroyNotify.window = pWin->drawable.id;
	DeliverEvents(pWin, &event, 1, NullWindow);
d979 9
a987 10
    if (pParent)
    {
	if (pParent->firstChild == pWin)
	    pParent->firstChild = pWin->nextSib;
	if (pParent->lastChild == pWin)
	    pParent->lastChild = pWin->prevSib;
	if (pWin->nextSib)
	    pWin->nextSib->prevSib = pWin->prevSib;
	if (pWin->prevSib)
	    pWin->prevSib->nextSib = pWin->nextSib;
d990 1
a990 1
	pWin->drawable.pScreen->root = NULL;
d1008 7
a1014 6
	int rc = XaceHook(XACE_RESOURCE_ACCESS, client,
			  pWin->lastChild->drawable.id, RT_WINDOW,
			  pWin->lastChild, RT_NONE, NULL, DixDestroyAccess);
	if (rc != Success)
	    return rc;
	FreeResource(pWin->lastChild->drawable.id, RT_NONE);
d1025 2
a1026 2
	pWin->backgroundState = XaceBackgroundNoneState(pWin);
	pWin->background.pixel = pScreen->whitePixel;
d1029 1
a1029 1
	MakeRootTile(pWin);
d1032 5
a1036 5
	if (whiteRoot)
	    pWin->background.pixel = pScreen->whitePixel;
	else
	    pWin->background.pixel = pScreen->blackPixel;
	*index2 = CWBackPixel;
d1047 1
a1047 1
 
d1058 1
a1058 1
    ColormapPtr	pCmap;
d1066 3
a1068 2
    if ((pWin->drawable.class == InputOnly) && (vmask & (~INPUTONLY_LEGAL_MASK)))
	return BadMatch;
d1074 378
a1451 419
    while (tmask)
    {
	index2 = (Mask) lowbit (tmask);
	tmask &= ~index2;
	switch (index2)
	{
	  case CWBackPixmap:
	    pixID = (Pixmap )*pVlist;
	    pVlist++;
	    if (pWin->backgroundState == ParentRelative)
		borderRelative = TRUE;
	    if (pixID == None)
	    {
		if (pWin->backgroundState == BackgroundPixmap)
		    (*pScreen->DestroyPixmap)(pWin->background.pixmap);
		if (!pWin->parent)
		    SetRootWindowBackground(pWin, pScreen, &index2);
		else {
		    pWin->backgroundState = XaceBackgroundNoneState(pWin);
		    pWin->background.pixel = pScreen->whitePixel;
		}
	    }
	    else if (pixID == ParentRelative)
	    {
		if (pWin->parent &&
		    pWin->drawable.depth != pWin->parent->drawable.depth)
		{
		    error = BadMatch;
		    goto PatchUp;
		}
		if (pWin->backgroundState == BackgroundPixmap)
		    (*pScreen->DestroyPixmap)(pWin->background.pixmap);
		if (!pWin->parent)
		    SetRootWindowBackground(pWin, pScreen, &index2);
		else
		    pWin->backgroundState = ParentRelative;
		borderRelative = TRUE;
		/* Note that the parent's backgroundTile's refcnt is NOT
		 * incremented. */
	    }
	    else
	    {	
		rc = dixLookupResourceByType((pointer *)&pPixmap, pixID, RT_PIXMAP,
				       client, DixReadAccess);
		if (rc == Success)
		{
		    if	((pPixmap->drawable.depth != pWin->drawable.depth) ||
			 (pPixmap->drawable.pScreen != pScreen))
		    {
			error = BadMatch;
			goto PatchUp;
		    }
		    if (pWin->backgroundState == BackgroundPixmap)
			(*pScreen->DestroyPixmap)(pWin->background.pixmap);
		    pWin->backgroundState = BackgroundPixmap;
		    pWin->background.pixmap = pPixmap;
		    pPixmap->refcnt++;
		}
		else
		{
		    error = rc;
		    client->errorValue = pixID;
		    goto PatchUp;
		}
	    }
	    break;
	  case CWBackPixel:
	    if (pWin->backgroundState == ParentRelative)
		borderRelative = TRUE;
	    if (pWin->backgroundState == BackgroundPixmap)
		(*pScreen->DestroyPixmap)(pWin->background.pixmap);
	    pWin->backgroundState = BackgroundPixel;
	    pWin->background.pixel = (CARD32 ) *pVlist;
		   /* background pixel overrides background pixmap,
		      so don't let the ddx layer see both bits */
	    vmaskCopy &= ~CWBackPixmap;
	    pVlist++;
	    break;
	  case CWBorderPixmap:
	    pixID = (Pixmap ) *pVlist;
	    pVlist++;
	    if (pixID == CopyFromParent)
	    {
		if (!pWin->parent ||
		    (pWin->drawable.depth != pWin->parent->drawable.depth))
		{
		    error = BadMatch;
		    goto PatchUp;
		}
		if (pWin->parent->borderIsPixel == TRUE) {
		    if (pWin->borderIsPixel == FALSE)
			(*pScreen->DestroyPixmap)(pWin->border.pixmap);
		    pWin->border = pWin->parent->border;
		    pWin->borderIsPixel = TRUE;
		    index2 = CWBorderPixel;
		    break;
		}
		else
		{
		    pixID = pWin->parent->border.pixmap->drawable.id;
		}
	    }
	    rc = dixLookupResourceByType((pointer *)&pPixmap, pixID, RT_PIXMAP,
				   client, DixReadAccess);
	    if (rc == Success)
	    {
		if ((pPixmap->drawable.depth != pWin->drawable.depth) ||
		    (pPixmap->drawable.pScreen != pScreen))
		{
		    error = BadMatch;
		    goto PatchUp;
		}
		if (pWin->borderIsPixel == FALSE)
		    (*pScreen->DestroyPixmap)(pWin->border.pixmap);
		pWin->borderIsPixel = FALSE;
		pWin->border.pixmap = pPixmap;
		pPixmap->refcnt++;
	    }
	    else
	    {
		error = rc;
		client->errorValue = pixID;
		goto PatchUp;
	    }
	    break;
	  case CWBorderPixel:
	    if (pWin->borderIsPixel == FALSE)
		(*pScreen->DestroyPixmap)(pWin->border.pixmap);
	    pWin->borderIsPixel = TRUE;
	    pWin->border.pixel = (CARD32) *pVlist;
		    /* border pixel overrides border pixmap,
		       so don't let the ddx layer see both bits */
	    vmaskCopy &= ~CWBorderPixmap;
	    pVlist++;
	    break;
	  case CWBitGravity:
	    val = (CARD8 )*pVlist;
	    pVlist++;
	    if (val > StaticGravity)
	    {
		error = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    pWin->bitGravity = val;
	    break;
	  case CWWinGravity:
	    val = (CARD8 )*pVlist;
	    pVlist++;
	    if (val > StaticGravity)
	    {
		error = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    pWin->winGravity = val;
	    break;
	  case CWBackingStore:
	    val = (CARD8 )*pVlist;
	    pVlist++;
	    if ((val != NotUseful) && (val != WhenMapped) && (val != Always))
	    {
		error = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    pWin->backingStore = val;
	    pWin->forcedBS = FALSE;
	    break;
	  case CWBackingPlanes:
	    if (pWin->optional || ((CARD32)*pVlist != (CARD32)~0L)) {
		if (!pWin->optional && !MakeWindowOptional (pWin))
		{
		    error = BadAlloc;
		    goto PatchUp;
		}
		pWin->optional->backingBitPlanes = (CARD32) *pVlist;
		if ((CARD32)*pVlist == (CARD32)~0L)
		    checkOptional = TRUE;
	    }
	    pVlist++;
	    break;
	  case CWBackingPixel:
	    if (pWin->optional || (CARD32) *pVlist) {
		if (!pWin->optional && !MakeWindowOptional (pWin))
		{
		    error = BadAlloc;
		    goto PatchUp;
		}
		pWin->optional->backingPixel = (CARD32) *pVlist;
		if (!*pVlist)
		    checkOptional = TRUE;
	    }
	    pVlist++;
	    break;
	  case CWSaveUnder:
	    val = (BOOL) *pVlist;
	    pVlist++;
	    if ((val != xTrue) && (val != xFalse))
	    {
		error = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    pWin->saveUnder = val;
	    break;
	  case CWEventMask:
	    rc = EventSelectForWindow(pWin, client, (Mask )*pVlist);
	    if (rc)
	    {
		error = rc;
		goto PatchUp;
	    }
	    pVlist++;
	    break;
	  case CWDontPropagate:
	    rc = EventSuppressForWindow(pWin, client, (Mask )*pVlist,
					    &checkOptional);
	    if (rc)
	    {
		error = rc;
		goto PatchUp;
	    }
	    pVlist++;
	    break;
	  case CWOverrideRedirect:
	    val = (BOOL ) *pVlist;
	    pVlist++;
	    if ((val != xTrue) && (val != xFalse))
	    {
		error = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    if (val == xTrue) {
		rc = XaceHook(XACE_RESOURCE_ACCESS, client, pWin->drawable.id,
			      RT_WINDOW, pWin, RT_NONE, NULL, DixGrabAccess);
		if (rc != Success) {
		    error = rc;
		    client->errorValue = pWin->drawable.id;
		    goto PatchUp;
		}
	    }
	    pWin->overrideRedirect = val;
	    break;
	  case CWColormap:
	    cmap = (Colormap) *pVlist;
	    pVlist++;
	    if (cmap == CopyFromParent)
	    {
		if (pWin->parent &&
		    (!pWin->optional ||
		     pWin->optional->visual == wVisual (pWin->parent)))
		{
		    cmap = wColormap (pWin->parent);
		}
		else
		    cmap = None;
	    }
	    if (cmap == None)
	    {
		error = BadMatch;
		goto PatchUp;
	    }
	    rc = dixLookupResourceByType((pointer *)&pCmap, cmap, RT_COLORMAP,
				   client, DixUseAccess);
	    if (rc != Success)
	    {
		error = rc;
		client->errorValue = cmap;
		goto PatchUp;
	    }
	    if (pCmap->pVisual->vid != wVisual (pWin) ||
		pCmap->pScreen != pScreen)
	    {
		error = BadMatch;
		goto PatchUp;
	    }
	    if (cmap != wColormap (pWin))
	    {
		if (!pWin->optional)
		{
		    if (!MakeWindowOptional (pWin))
		    {
			error = BadAlloc;
			goto PatchUp;
		    }
		}
		else if (pWin->parent && cmap == wColormap (pWin->parent))
		    checkOptional = TRUE;

		/*
		 * propagate the original colormap to any children
		 * inheriting it
		 */

		for (pChild = pWin->firstChild; pChild; pChild=pChild->nextSib)
		{
		    if (!pChild->optional && !MakeWindowOptional (pChild))
		    {
			error = BadAlloc;
			goto PatchUp;
		    }
		}

		pWin->optional->colormap = cmap;

		/*
		 * check on any children now matching the new colormap
		 */

		for (pChild = pWin->firstChild; pChild; pChild=pChild->nextSib)
		{
		    if (pChild->optional->colormap == cmap)
			CheckWindowOptionalNeed (pChild);
		}
	
		xE.u.u.type = ColormapNotify;
		xE.u.colormap.window = pWin->drawable.id;
		xE.u.colormap.colormap = cmap;
		xE.u.colormap.new = xTrue;
		xE.u.colormap.state = IsMapInstalled(cmap, pWin);
		DeliverEvents(pWin, &xE, 1, NullWindow);
	    }
	    break;
	  case CWCursor:
	    cursorID = (Cursor ) *pVlist;
	    pVlist++;
	    /*
	     * install the new
	     */
	    if ( cursorID == None)
	    {
		if (pWin == pWin->drawable.pScreen->root)
		    pCursor = rootCursor;
		else
		    pCursor = (CursorPtr) None;
	    }
	    else
	    {
		rc = dixLookupResourceByType((pointer *)&pCursor, cursorID,
				       RT_CURSOR, client, DixUseAccess);
		if (rc != Success)
		{
		    error = rc;
		    client->errorValue = cursorID;
		    goto PatchUp;
		}
	    }

	    if (pCursor != wCursor (pWin))
	    {
		/*
		 * patch up child windows so they don't lose cursors.
		 */

		for (pChild = pWin->firstChild; pChild; pChild=pChild->nextSib)
		{
		    if (!pChild->optional && !pChild->cursorIsNone &&
			!MakeWindowOptional (pChild))
		    {
			error = BadAlloc;
			goto PatchUp;
		    }
		}

		pOldCursor = 0;
		if (pCursor == (CursorPtr) None)
		{
		    pWin->cursorIsNone = TRUE;
		    if (pWin->optional)
		    {
			pOldCursor = pWin->optional->cursor;
			pWin->optional->cursor = (CursorPtr) None;
			checkOptional = TRUE;
		    }
		} else {
		    if (!pWin->optional)
		    {
			if (!MakeWindowOptional (pWin))
			{
			    error = BadAlloc;
			    goto PatchUp;
			}
		    }
		    else if (pWin->parent && pCursor == wCursor (pWin->parent))
			checkOptional = TRUE;
		    pOldCursor = pWin->optional->cursor;
		    pWin->optional->cursor = pCursor;
		    pCursor->refcnt++;
		    pWin->cursorIsNone = FALSE;
		    /*
		     * check on any children now matching the new cursor
		     */

		    for (pChild=pWin->firstChild; pChild; pChild=pChild->nextSib)
		    {
			if (pChild->optional &&
			    (pChild->optional->cursor == pCursor))
			    CheckWindowOptionalNeed (pChild);
		    }
		}

		if (pWin->realized)
		    WindowHasNewCursor( pWin);

		/* Can't free cursor until here - old cursor
		 * is needed in WindowHasNewCursor
		 */
		if (pOldCursor)
		    FreeCursor (pOldCursor, (Cursor)0);
	    }
	    break;
	 default:
	    error = BadValue;
	    client->errorValue = vmask;
	    goto PatchUp;
      }
      vmaskCopy |= index2;
d1453 1
a1453 1
PatchUp:
d1455 1
a1455 1
	CheckWindowOptionalNeed (pWin);
d1457 2
a1458 2
	/* We SHOULD check for an error value here XXX */
    (*pScreen->ChangeWindowAttributes)(pWin, vmaskCopy);
d1461 4
a1464 4
	If the border contents have changed, redraw the border. 
	Note that this has to be done AFTER pScreen->ChangeWindowAttributes
	for the tile to be rotated, and the correct function selected.
    */
d1466 2
a1467 3
	&& pWin->viewable && HasBorder (pWin))
    {
	RegionRec exposed;
d1469 4
a1472 4
	RegionNull(&exposed);
	RegionSubtract(&exposed, &pWin->borderClip, &pWin->winSize);
	miPaintWindow(pWin, &exposed, PW_BORDER);
	RegionUninit(&exposed);
a1476 1

d1483 2
a1484 1
GetWindowAttributes(WindowPtr pWin, ClientPtr client, xGetWindowAttributesReply *wa)
d1490 1
a1490 1
	wa->backingStore = NotUseful;
d1492 1
a1492 1
	wa->backingStore = pWin->backingStore;
d1494 1
a1494 1
		 sizeof(xGenericReply));
d1496 3
a1498 3
    wa->backingBitPlanes =  wBackingBitPlanes (pWin);
    wa->backingPixel =  wBackingPixel (pWin);
    wa->saveUnder = (BOOL)pWin->saveUnder;
d1501 1
a1501 1
	wa->mapState = IsUnmapped;
d1503 1
a1503 1
	wa->mapState = IsViewable;
d1505 1
a1505 1
	wa->mapState = IsUnviewable;
d1507 1
a1507 1
    wa->colormap =  wColormap (pWin);
d1509 1
a1509 1
				: IsMapInstalled(wa->colormap, pWin);
d1512 2
a1513 2
    wa->allEventMasks = pWin->eventMask | wOtherEventMasks (pWin);
    wa->doNotPropagateMask = wDontPropagateMask (pWin);
d1515 1
a1515 1
    wa->visualID = wVisual (pWin);
a1517 1

d1522 4
a1525 1
    WindowPtr pFirstChange = pWin; /* highest window where list changes */
d1527 31
a1557 3
    if (pWin->nextSib != pNextSib)
    {
	WindowPtr pOldNextSib = pWin->nextSib;
d1559 24
a1582 58
	if (!pNextSib)	      /* move to bottom */
	{
	    if (pParent->firstChild == pWin)
		pParent->firstChild = pWin->nextSib;
	    /* if (pWin->nextSib) */	 /* is always True: pNextSib == NULL
					  * and pWin->nextSib != pNextSib
					  * therefore pWin->nextSib != NULL */
	    pFirstChange = pWin->nextSib;
	    pWin->nextSib->prevSib = pWin->prevSib;
	    if (pWin->prevSib)
		pWin->prevSib->nextSib = pWin->nextSib;
	    pParent->lastChild->nextSib = pWin;
	    pWin->prevSib = pParent->lastChild;
	    pWin->nextSib = NullWindow;
	    pParent->lastChild = pWin;
	}
	else if (pParent->firstChild == pNextSib) /* move to top */
	{
	    pFirstChange = pWin;
	    if (pParent->lastChild == pWin)
	       pParent->lastChild = pWin->prevSib;
	    if (pWin->nextSib)
		pWin->nextSib->prevSib = pWin->prevSib;
	    if (pWin->prevSib)
		pWin->prevSib->nextSib = pWin->nextSib;
	    pWin->nextSib = pParent->firstChild;
	    pWin->prevSib = (WindowPtr ) NULL;
	    pNextSib->prevSib = pWin;
	    pParent->firstChild = pWin;
	}
	else			/* move in middle of list */
	{
	    WindowPtr pOldNext = pWin->nextSib;

	    pFirstChange = NullWindow;
	    if (pParent->firstChild == pWin)
		pFirstChange = pParent->firstChild = pWin->nextSib;
	    if (pParent->lastChild == pWin) {
	       pFirstChange = pWin;
	       pParent->lastChild = pWin->prevSib;
	    }
	    if (pWin->nextSib)
		pWin->nextSib->prevSib = pWin->prevSib;
	    if (pWin->prevSib)
		pWin->prevSib->nextSib = pWin->nextSib;
	    pWin->nextSib = pNextSib;
	    pWin->prevSib = pNextSib->prevSib;
	    if (pNextSib->prevSib)
		pNextSib->prevSib->nextSib = pWin;
	    pNextSib->prevSib = pWin;
	    if (!pFirstChange) {		     /* do we know it yet? */
		pFirstChange = pParent->firstChild;  /* no, search from top */
		while ((pFirstChange != pWin) && (pFirstChange != pOldNext))
		     pFirstChange = pFirstChange->nextSib;
	    }
	}
	if(pWin->drawable.pScreen->RestackWindow)
	    (*pWin->drawable.pScreen->RestackWindow)(pWin, pOldNextSib);
d1593 1
a1593 1
        (*pWin->drawable.pScreen->RestackWindow)(pWin, pWin->nextSib);
d1600 1
a1600 1
SetWinSize (WindowPtr pWin)
d1603 2
a1604 3
    if (pWin->redirectDraw != RedirectDrawNone)
    {
	BoxRec	box;
d1606 9
a1614 9
	/*
	 * Redirected clients get clip list equal to their
	 * own geometry, not clipped to their parent
	 */
	box.x1 = pWin->drawable.x;
	box.y1 = pWin->drawable.y;
	box.x2 = pWin->drawable.x + pWin->drawable.width;
	box.y2 = pWin->drawable.y + pWin->drawable.height;
	RegionReset(&pWin->winSize, &box);
d1618 12
a1629 15
    ClippedRegionFromBox(pWin->parent, &pWin->winSize,
			 pWin->drawable.x, pWin->drawable.y,
			 (int)pWin->drawable.width,
			 (int)pWin->drawable.height);
    if (wBoundingShape (pWin) || wClipShape (pWin)) {
	RegionTranslate(&pWin->winSize, - pWin->drawable.x,
			 - pWin->drawable.y);
	if (wBoundingShape (pWin))
	    RegionIntersect(&pWin->winSize, &pWin->winSize,
			     wBoundingShape (pWin));
	if (wClipShape (pWin))
	    RegionIntersect(&pWin->winSize, &pWin->winSize,
			     wClipShape (pWin));
	RegionTranslate(&pWin->winSize, pWin->drawable.x,
			 pWin->drawable.y);
d1634 1
a1634 1
SetBorderSize (WindowPtr pWin)
d1636 1
a1636 1
    int	bw;
d1638 2
a1639 2
    if (HasBorder (pWin)) {
	bw = wBorderWidth (pWin);
d1641 14
a1654 15
	if (pWin->redirectDraw != RedirectDrawNone)
	{
	    BoxRec	box;

	    /*
	     * Redirected clients get clip list equal to their
	     * own geometry, not clipped to their parent
	     */
	    box.x1 = pWin->drawable.x - bw;
	    box.y1 = pWin->drawable.y - bw;
	    box.x2 = pWin->drawable.x + pWin->drawable.width + bw;
	    box.y2 = pWin->drawable.y + pWin->drawable.height + bw;
	    RegionReset(&pWin->borderSize, &box);
	}
	else
d1656 16
a1671 16
	ClippedRegionFromBox(pWin->parent, &pWin->borderSize,
		pWin->drawable.x - bw, pWin->drawable.y - bw,
		(int)(pWin->drawable.width + (bw<<1)),
		(int)(pWin->drawable.height + (bw<<1)));
	if (wBoundingShape (pWin)) {
	    RegionTranslate(&pWin->borderSize, - pWin->drawable.x,
			     - pWin->drawable.y);
	    RegionIntersect(&pWin->borderSize, &pWin->borderSize,
			     wBoundingShape (pWin));
	    RegionTranslate(&pWin->borderSize, pWin->drawable.x,
			     pWin->drawable.y);
	    RegionUnion(&pWin->borderSize, &pWin->borderSize,
			 &pWin->winSize);
	}
    } else {
	RegionCopy(&pWin->borderSize, &pWin->winSize);
d1683 2
a1684 3
GravityTranslate (int x, int y, int oldx, int oldy,
                  int dw, int dh, unsigned gravity,
                  int *destx, int *desty)
d1688 3
a1690 3
	*destx = x + dw / 2;
	*desty = y;
	break;
d1692 3
a1694 3
	*destx = x + dw;
	*desty = y;
	break;
d1696 3
a1698 3
	*destx = x;
	*desty = y + dh / 2;
	break;
d1700 3
a1702 3
	*destx = x + dw / 2;
	*desty = y + dh / 2;
	break;
d1704 3
a1706 3
	*destx = x + dw;
	*desty = y + dh / 2;
	break;
d1708 3
a1710 3
	*destx = x;
	*desty = y + dh;
	break;
d1712 3
a1714 3
	*destx = x + dw / 2;
	*desty = y + dh;
	break;
d1716 3
a1718 3
	*destx = x + dw;
	*desty = y + dh;
	break;
d1720 3
a1722 3
	*destx = oldx;
	*desty = oldy;
	break;
d1724 3
a1726 3
	*destx = x;
	*desty = y;
	break;
d1740 48
a1787 53
    for (pSib = pWin->firstChild; pSib; pSib = pSib->nextSib)
    {
	if (resized && (pSib->winGravity > NorthWestGravity))
	{
	    int cwsx, cwsy;

	    cwsx = pSib->origin.x;
	    cwsy = pSib->origin.y;
	    GravityTranslate (cwsx, cwsy, cwsx - dx, cwsy - dy, dw, dh,
			pSib->winGravity, &cwsx, &cwsy);
	    if (cwsx != pSib->origin.x || cwsy != pSib->origin.y)
	    {
		xEvent event;

		event.u.u.type = GravityNotify;
		event.u.gravity.window = pSib->drawable.id;
		event.u.gravity.x = cwsx - wBorderWidth (pSib);
		event.u.gravity.y = cwsy - wBorderWidth (pSib);
		DeliverEvents (pSib, &event, 1, NullWindow);
		pSib->origin.x = cwsx;
		pSib->origin.y = cwsy;
	    }
	}
	pSib->drawable.x = pWin->drawable.x + pSib->origin.x;
	pSib->drawable.y = pWin->drawable.y + pSib->origin.y;
	SetWinSize (pSib);
	SetBorderSize (pSib);
	(*pScreen->PositionWindow)(pSib, pSib->drawable.x, pSib->drawable.y);

	if ( (pChild = pSib->firstChild) )
	{
	    while (1)
	    {
		pChild->drawable.x = pChild->parent->drawable.x +
				     pChild->origin.x;
		pChild->drawable.y = pChild->parent->drawable.y +
				     pChild->origin.y;
		SetWinSize (pChild);
		SetBorderSize (pChild);
		(*pScreen->PositionWindow)(pChild,
				    pChild->drawable.x, pChild->drawable.y);
		if (pChild->firstChild)
		{
		    pChild = pChild->firstChild;
		    continue;
		}
		while (!pChild->nextSib && (pChild != pSib))
		    pChild = pChild->parent;
		if (pChild == pSib)
		    break;
		pChild = pChild->nextSib;
	    }
	}
d1821 1
a1821 3
IsSiblingAboveMe(
    WindowPtr pMe,
    WindowPtr pSib)
d1826 6
a1831 7
    while (pWin)
    {
	if (pWin == pSib)
	    return Above;
	else if (pWin == pMe)
	    return Below;
	pWin = pWin->nextSib;
d1837 8
a1844 10
WindowExtents(
    WindowPtr pWin,
    BoxPtr pBox)
{
    pBox->x1 = pWin->drawable.x - wBorderWidth (pWin);
    pBox->y1 = pWin->drawable.y - wBorderWidth (pWin);
    pBox->x2 = pWin->drawable.x + (int)pWin->drawable.width
	       + wBorderWidth (pWin);
    pBox->y2 = pWin->drawable.y + (int)pWin->drawable.height
	       + wBorderWidth (pWin);
d1851 8
a1858 9
MakeBoundingRegion (
    WindowPtr	pWin,
    BoxPtr	pBox)
{
    RegionPtr	pRgn = RegionCreate(pBox, 1);
    if (wBoundingShape (pWin)) {
	RegionTranslate(pRgn, -pWin->origin.x, -pWin->origin.y);
	RegionIntersect(pRgn, pRgn, wBoundingShape (pWin));
	RegionTranslate(pRgn, pWin->origin.x, pWin->origin.y);
d1864 1
a1864 5
ShapeOverlap (
    WindowPtr	pWin,
    BoxPtr	pWinBox,
    WindowPtr	pSib,
    BoxPtr	pSibBox)
d1866 2
a1867 2
    RegionPtr	pWinRgn, pSibRgn;
    Bool	ret;
d1870 3
a1872 3
	return TRUE;
    pWinRgn = MakeBoundingRegion (pWin, pWinBox);
    pSibRgn = MakeBoundingRegion (pSib, pSibBox);
d1881 1
a1881 4
AnyWindowOverlapsMe(
    WindowPtr pWin,
    WindowPtr pHead,
    BoxPtr box)
d1887 8
a1894 10
    for (pSib = pWin->prevSib; pSib != pHead; pSib = pSib->prevSib)
    {
	if (pSib->mapped)
	{
	    sbox = WindowExtents(pSib, &sboxrec);
	    if (BOXES_OVERLAP(sbox, box)
	    && ShapeOverlap (pWin, box, pSib, sbox)
	    )
		return TRUE;
	}
d1900 1
a1900 3
IOverlapAnyWindow(
    WindowPtr pWin,
    BoxPtr box)
d1906 8
a1913 10
    for (pSib = pWin->nextSib; pSib; pSib = pSib->nextSib)
    {
	if (pSib->mapped)
	{
	    sbox = WindowExtents(pSib, &sboxrec);
	    if (BOXES_OVERLAP(sbox, box)
	    && ShapeOverlap (pWin, box, pSib, sbox)
	    )
		return TRUE;
	}
d1947 4
a1950 8
WhereDoIGoInTheStack(
    WindowPtr pWin,
    WindowPtr pSib,
    short x,
    short y,
    unsigned short w,
    unsigned short h,
    int smode)
d1955 2
a1956 3
    if ((pWin == pWin->parent->firstChild) &&
	(pWin == pWin->parent->lastChild))
	return((WindowPtr ) NULL);
d1961 71
a2031 3
    box.x2 = x + (int)w;
    box.y2 = y + (int)h;
    switch (smode)
d2033 3
a2035 77
      case Above:
	if (pSib)
	   return pSib;
	else if (pWin == pFirst)
	    return pWin->nextSib;
	else
	    return pFirst;
      case Below:
	if (pSib)
	    if (pSib->nextSib != pWin)
		return pSib->nextSib;
	    else
		return pWin->nextSib;
	else
	    return NullWindow;
      case TopIf:
	if ((!pWin->mapped || (pSib && !pSib->mapped)))
	    return pWin->nextSib;
	else if (pSib)
	{
	    if ((IsSiblingAboveMe(pWin, pSib) == Above) &&
		(RegionContainsRect(&pSib->borderSize, &box) != rgnOUT))
		return pFirst;
	    else
		return pWin->nextSib;
	}
	else if (AnyWindowOverlapsMe(pWin, pHead, &box))
	    return pFirst;
	else
	    return pWin->nextSib;
      case BottomIf:
	if ((!pWin->mapped || (pSib && !pSib->mapped)))
	    return pWin->nextSib;
	else if (pSib)
	{
	    if ((IsSiblingAboveMe(pWin, pSib) == Below) &&
		(RegionContainsRect(&pSib->borderSize, &box) != rgnOUT))
		return NullWindow;
	    else
		return pWin->nextSib;
	}
	else if (IOverlapAnyWindow(pWin, &box))
	    return NullWindow;
	else
	    return pWin->nextSib;
      case Opposite:
	if ((!pWin->mapped || (pSib && !pSib->mapped)))
	    return pWin->nextSib;
	else if (pSib)
	{
	    if (RegionContainsRect(&pSib->borderSize, &box) != rgnOUT)
	    {
		if (IsSiblingAboveMe(pWin, pSib) == Above)
		    return pFirst;
		else
		    return NullWindow;
	    }
	    else
		return pWin->nextSib;
	}
	else if (AnyWindowOverlapsMe(pWin, pHead, &box))
	{
	    /* If I'm occluded, I can't possibly be the first child
	     * if (pWin == pWin->parent->firstChild)
	     *	  return pWin->nextSib;
	     */
	    return pFirst;
	}
	else if (IOverlapAnyWindow(pWin, &box))
	    return NullWindow;
	else
	    return pWin->nextSib;
      default:
      {
	/* should never happen; make something up. */
	return pWin->nextSib;
      }
d2040 1
a2040 4
ReflectStackChange(
    WindowPtr pWin,
    WindowPtr pSib,
    VTKind  kind)
d2044 1
a2044 1
    Bool WasViewable = (Bool)pWin->viewable;
d2047 1
a2047 1
    WindowPtr  pLayerWin;
d2052 1
a2052 1
	return;
d2056 12
a2067 12
    if (WasViewable)
    {
	anyMarked = (*pScreen->MarkOverlappedWindows)(pWin, pFirstChange,
						      &pLayerWin);
	if (pLayerWin != pWin) pFirstChange = pLayerWin;
	if (anyMarked)
	{
	    (*pScreen->ValidateTree)(pLayerWin->parent, pFirstChange, kind);
	    (*pScreen->HandleExposures)(pLayerWin->parent);
	}
	if (anyMarked && pWin->drawable.pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pLayerWin->parent, pFirstChange, kind);
d2070 1
a2070 1
	WindowsRestructured ();
d2089 1
a2089 1
    short x,   y, beforeX, beforeY;
d2091 1
a2091 2
		   h = pWin->drawable.height,
		   bw = pWin->borderWidth;
d2095 3
a2097 2
    if ((pWin->drawable.class == InputOnly) && (mask & IllegalInputOnlyConfigureMask))
	return BadMatch;
d2100 1
a2100 1
	return BadMatch;
d2104 3
a2106 4
    if (pParent)
    {
	x = pWin->drawable.x - pParent->drawable.x - (int)bw;
	y = pWin->drawable.y - pParent->drawable.y - (int)bw;
d2108 3
a2110 4
    else
    {
	x = pWin->drawable.x;
	y = pWin->drawable.y;
d2114 17
a2130 20
    action = RESTACK_WIN;	
    if ((mask & (CWX | CWY)) && (!(mask & (CWHeight | CWWidth))))
    {
	GET_INT16(CWX, x);
	GET_INT16(CWY, y);
	action = MOVE_WIN;
    }
	/* or should be resized */
    else if (mask & (CWX |  CWY | CWWidth | CWHeight))
    {
	GET_INT16(CWX, x);
	GET_INT16(CWY, y);
	GET_CARD16(CWWidth, w);
	GET_CARD16 (CWHeight, h);
	if (!w || !h)
	{
	    client->errorValue = 0;
	    return BadValue;
	}
	action = RESIZE_WIN;
d2133 32
a2164 36
    while (tmask)
    {
	index2 = (Mask)lowbit (tmask);
	tmask &= ~index2;
	switch (index2)
	{
	  case CWBorderWidth:
	    GET_CARD16(CWBorderWidth, bw);
	    break;
	  case CWSibling:
	    sibwid = (Window ) *pVlist;
	    pVlist++;
	    rc = dixLookupWindow(&pSib, sibwid, client, DixGetAttrAccess);
	    if (rc != Success)
	    {
		client->errorValue = sibwid;
		return rc;
	    }
	    if (pSib->parent != pParent)
		return BadMatch;
	    if (pSib == pWin)
		return BadMatch;
	    break;
	  case CWStackMode:
	    GET_CARD8(CWStackMode, smode);
	    if ((smode != TopIf) && (smode != BottomIf) &&
		(smode != Opposite) && (smode != Above) && (smode != Below))
	    {
		client->errorValue = smode;
		return BadValue;
	    }
	    break;
	  default:
	    client->errorValue = mask;
	    return BadValue;
	}
d2166 1
a2166 1
	/* root really can't be reconfigured, so just return */
d2168 1
a2168 1
	return Success;
d2170 2
a2171 2
	/* Figure out if the window should be moved.  Doesnt
	   make the changes to the window if event sent */
d2174 21
a2194 24
	pSib = WhereDoIGoInTheStack(pWin, pSib, pParent->drawable.x + x,
				    pParent->drawable.y + y,
				    w + (bw << 1), h + (bw << 1), smode);
    else
	pSib = pWin->nextSib;


    if ((!pWin->overrideRedirect) && 
	(RedirectSend(pParent)
	))
    {
	memset(&event, 0, sizeof(xEvent));
	event.u.u.type = ConfigureRequest;
	event.u.configureRequest.window = pWin->drawable.id;
	if (mask & CWSibling)
	   event.u.configureRequest.sibling = sibwid;
	else
	    event.u.configureRequest.sibling = None;
	if (mask & CWStackMode)
	   event.u.u.detail = smode;
	else
	    event.u.u.detail = Above;
	event.u.configureRequest.x = x;
	event.u.configureRequest.y = y;
d2196 1
a2196 1
	if(!noPanoramiXExtension && (!pParent || !pParent->parent)) {
d2199 1
a2199 1
	}
d2201 8
a2208 8
	event.u.configureRequest.width = w;
	event.u.configureRequest.height = h;
	event.u.configureRequest.borderWidth = bw;
	event.u.configureRequest.valueMask = mask;
	event.u.configureRequest.parent = pParent->drawable.id;
	if (MaybeDeliverEventsToClient(pParent, &event, 1,
		SubstructureRedirectMask, client) == 1)
	    return Success;
d2210 29
a2238 30
    if (action == RESIZE_WIN)
    {
	Bool size_change = (w != pWin->drawable.width)
			|| (h != pWin->drawable.height);
	if (size_change && ((pWin->eventMask|wOtherEventMasks(pWin)) & ResizeRedirectMask))
	{
	    xEvent eventT;
	    memset(&eventT, 0, sizeof(xEvent));
	    eventT.u.u.type = ResizeRequest;
	    eventT.u.resizeRequest.window = pWin->drawable.id;
	    eventT.u.resizeRequest.width = w;
	    eventT.u.resizeRequest.height = h;
	    if (MaybeDeliverEventsToClient(pWin, &eventT, 1,
				       ResizeRedirectMask, client) == 1)
	    {
		/* if event is delivered, leave the actual size alone. */
		w = pWin->drawable.width;
		h = pWin->drawable.height;
		size_change = FALSE;
	    }
	}
	if (!size_change)
	{
	    if (mask & (CWX | CWY))
		action = MOVE_WIN;
	    else if (mask & (CWStackMode | CWBorderWidth))
		action = RESTACK_WIN;
	    else   /* really nothing to do */
		return(Success) ;
	}
d2242 2
a2243 2
	    /* we've already checked whether there's really a size change */
	    goto ActuallyDoSomething;
d2245 1
a2245 1
	    goto ActuallyDoSomething;
d2247 4
a2250 5
	    goto ActuallyDoSomething;
    if ((mask & CWBorderWidth) && (bw != wBorderWidth (pWin)))
	    goto ActuallyDoSomething;
    if (mask & CWStackMode)
    {
d2253 1
a2253 1
	if (pWin->nextSib != pSib)
d2255 1
a2255 1
	    goto ActuallyDoSomething;
d2259 11
a2269 9
ActuallyDoSomething:
    if (pWin->drawable.pScreen->ConfigNotify)
    {
	int ret;
	ret = (*pWin->drawable.pScreen->ConfigNotify)(pWin, x, y, w, h, bw, pSib);
	if (ret) {
	    client->errorValue = 0;
	    return ret;
	}
d2272 10
a2281 11
    if (SubStrSend(pWin, pParent))
    {
	memset(&event, 0, sizeof(xEvent));
	event.u.u.type = ConfigureNotify;
	event.u.configureNotify.window = pWin->drawable.id;
	if (pSib)
	    event.u.configureNotify.aboveSibling = pSib->drawable.id;
	else
	    event.u.configureNotify.aboveSibling = None;
	event.u.configureNotify.x = x;
	event.u.configureNotify.y = y;
d2283 4
a2286 4
	if(!noPanoramiXExtension && (!pParent || !pParent->parent)) {
	    event.u.configureNotify.x += screenInfo.screens[0]->x;
	    event.u.configureNotify.y += screenInfo.screens[0]->y;
	}
d2288 19
a2306 22
	event.u.configureNotify.width = w;
	event.u.configureNotify.height = h;
	event.u.configureNotify.borderWidth = bw;
	event.u.configureNotify.override = pWin->overrideRedirect;
	DeliverEvents(pWin, &event, 1, NullWindow);
    }
    if (mask & CWBorderWidth)
    {
	if (action == RESTACK_WIN)
	{
	    action = MOVE_WIN;
	    pWin->borderWidth = bw;
	}
	else if ((action == MOVE_WIN) &&
		 (beforeX + wBorderWidth (pWin) == x + (int)bw) &&
		 (beforeY + wBorderWidth (pWin) == y + (int)bw))
	{
	    action = REBORDER_WIN;
	    (*pWin->drawable.pScreen->ChangeBorderWidth)(pWin, bw);
	}
	else
	    pWin->borderWidth = bw;
d2309 3
a2311 2
	(*pWin->drawable.pScreen->MoveWindow)(pWin, x, y, pSib,
		   (mask & CWBorderWidth) ? VTOther : VTMove);
d2313 1
a2313 1
	(*pWin->drawable.pScreen->ResizeWindow)(pWin, x, y, w, h, pSib);
d2315 1
a2315 1
	ReflectStackChange(pWin, pSib, VTOther);
d2318 1
a2318 1
	CheckCursorConfinement(pWin);
a2325 1

d2345 8
a2352 9
    if (direction == RaiseLowest)
    {
	for (pWin = pParent->lastChild;
	     (pWin != pHead) &&
	     !(pWin->mapped &&
	       AnyWindowOverlapsMe(pWin, pHead, WindowExtents(pWin, &box)));
	     pWin = pWin->prevSib) ;
	if (pWin == pHead)
	    return Success;
d2354 8
a2361 9
    else
    {
	for (pWin = pFirst;
	     pWin &&
	     !(pWin->mapped &&
	       IOverlapAnyWindow(pWin, WindowExtents(pWin, &box)));
	     pWin = pWin->nextSib) ;
	if (!pWin)
	    return Success;
d2368 1
a2368 1
	event.u.circulate.place = PlaceOnTop;
d2370 1
a2370 1
	event.u.circulate.place = PlaceOnBottom;
d2372 5
a2376 6
    if (RedirectSend(pParent))
    {
	event.u.u.type = CirculateRequest;
	if (MaybeDeliverEventsToClient(pParent, &event, 1,
		SubstructureRedirectMask, client) == 1)
	    return Success;
d2382 2
a2383 2
		       (direction == RaiseLowest) ? pFirst : NullWindow,
		       VTStack);
d2389 3
a2391 5
CompareWIDs(
    WindowPtr pWin,
    pointer   value) /* must conform to VisitWindowProcPtr */
{
    Window *wid = (Window *)value;
d2394 1
a2394 1
       return WT_STOPWALKING;
d2396 1
a2396 1
       return WT_WALKCHILDREN;
d2408 1
a2408 1
    Bool WasMapped = (Bool)(pWin->mapped);
d2410 1
a2410 1
    int bw = wBorderWidth (pWin);
d2414 3
a2416 2
    if (TraverseTree(pWin, CompareWIDs, (pointer)&pParent->drawable.id) == WT_STOPWALKING)
	return BadMatch;
d2418 1
a2418 1
	return BadAlloc;
d2421 1
a2421 1
       UnmapWindow(pWin, FALSE);
d2430 3
a2432 3
    if(!noPanoramiXExtension && !pParent->parent) {
	event.u.reparent.x += screenInfo.screens[0]->x;
	event.u.reparent.y += screenInfo.screens[0]->y;
d2442 1
a2442 1
	pPrev->firstChild = pWin->nextSib;
d2444 1
a2444 1
	pPrev->lastChild = pWin->prevSib;
d2447 1
a2447 1
	pWin->nextSib->prevSib = pWin->prevSib;
d2449 1
a2449 1
	pWin->prevSib->nextSib = pWin->nextSib;
d2454 8
a2461 9
    if (pPrev)
    {
	pWin->nextSib = pPrev->nextSib;
	if (pPrev->nextSib)
	    pPrev->nextSib->prevSib = pWin;
	else
	    pParent->lastChild = pWin;
	pPrev->nextSib = pWin;
	pWin->prevSib = pPrev;
d2463 8
a2470 9
    else
    {
	pWin->nextSib = pParent->firstChild;
	pWin->prevSib = NullWindow;
	if (pParent->firstChild)
	    pParent->firstChild->prevSib = pWin;
	else
	    pParent->lastChild = pWin;
	pParent->firstChild = pWin;
d2479 2
a2480 2
    SetWinSize (pWin);
    SetBorderSize (pWin);
d2483 2
a2484 2
	(*pScreen->ReparentWindow)(pWin, pPriorParent);
    (*pScreen->PositionWindow)(pWin, pWin->drawable.x, pWin->drawable.y);
d2490 1
a2490 1
	MapWindow(pWin, client);
d2503 15
a2517 18
    while (1)
    {
	if (pChild->mapped)
	{
	    pChild->realized = TRUE;
	    pChild->viewable = (pChild->drawable.class == InputOutput);
	    (* Realize)(pChild);
	    if (pChild->firstChild)
	    {
		pChild = pChild->firstChild;
		continue;
	    }
	}
	while (!pChild->nextSib && (pChild != pWin))
	    pChild = pChild->parent;
	if (pChild == pWin)
	    return;
	pChild = pChild->nextSib;
d2526 2
a2527 2
    assert (windowDisableMapUnmapEvents == NULL);
    
d2534 1
a2534 1
    assert (windowDisableMapUnmapEvents != NULL);
d2559 1
a2559 1
    WindowPtr  pLayerWin;
d2562 1
a2562 1
	return Success;
d2566 2
a2567 2
		 pWin, RT_NONE, NULL, DixShowAccess) != Success)
	return Success;
d2570 25
a2594 4
    if ( (pParent = pWin->parent) )
    {
	xEvent event;
	Bool anyMarked;
d2596 15
a2610 40
	if ((!pWin->overrideRedirect) && 
	    (RedirectSend(pParent)
	))
	{
	    memset(&event, 0, sizeof(xEvent));
	    event.u.u.type = MapRequest;
	    event.u.mapRequest.window = pWin->drawable.id;
	    event.u.mapRequest.parent = pParent->drawable.id;

	    if (MaybeDeliverEventsToClient(pParent, &event, 1,
		SubstructureRedirectMask, client) == 1)
		return Success;
	}

	pWin->mapped = TRUE;
	if (SubStrSend(pWin, pParent) && MapUnmapEventsEnabled(pWin))
	{
	    memset(&event, 0, sizeof(xEvent));
	    event.u.u.type = MapNotify;
	    event.u.mapNotify.window = pWin->drawable.id;
	    event.u.mapNotify.override = pWin->overrideRedirect;
	    DeliverEvents(pWin, &event, 1, NullWindow);
	}

	if (!pParent->realized)
	    return Success;
	RealizeTree(pWin);
	if (pWin->viewable)
	{
	    anyMarked = (*pScreen->MarkOverlappedWindows)(pWin, pWin,
							  &pLayerWin);
	    if (anyMarked)
	    {
		(*pScreen->ValidateTree)(pLayerWin->parent, pLayerWin, VTMap);
		(*pScreen->HandleExposures)(pLayerWin->parent);
	    }
	if (anyMarked && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pLayerWin->parent, pLayerWin, VTMap);
	}
	WindowsRestructured ();
d2612 2
a2613 3
    else
    {
	RegionRec   temp;
d2615 13
a2627 13
	pWin->mapped = TRUE;
	pWin->realized = TRUE;	   /* for roots */
	pWin->viewable = pWin->drawable.class == InputOutput;
	/* We SHOULD check for an error value here XXX */
	(*pScreen->RealizeWindow)(pWin);
	if (pScreen->ClipNotify)
	    (*pScreen->ClipNotify) (pWin, 0, 0);
	if (pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(NullWindow, pWin, VTMap);
	RegionNull(&temp);
	RegionCopy(&temp, &pWin->clipList);
	(*pScreen->WindowExposures) (pWin, &temp, NullRegion);
	RegionUninit(&temp);
a2632 1

d2642 8
a2649 8
    WindowPtr	pWin;
    WindowPtr	pFirstMapped = NullWindow;
    ScreenPtr	pScreen;
    Mask	parentRedirect;
    Mask	parentNotify;
    xEvent	event;
    Bool	anyMarked;
    WindowPtr		pLayerWin;
d2655 34
a2688 38
    for (pWin = pParent->firstChild; pWin; pWin = pWin->nextSib)
    {
	if (!pWin->mapped)
	{
	    if (parentRedirect && !pWin->overrideRedirect)
	    {
		memset(&event, 0, sizeof(xEvent));
		event.u.u.type = MapRequest;
		event.u.mapRequest.window = pWin->drawable.id;
		event.u.mapRequest.parent = pParent->drawable.id;
    
		if (MaybeDeliverEventsToClient(pParent, &event, 1,
		    SubstructureRedirectMask, client) == 1)
		    continue;
	    }
    
	    pWin->mapped = TRUE;
	    if (parentNotify || StrSend(pWin))
	    {
		memset(&event, 0, sizeof(xEvent));
		event.u.u.type = MapNotify;
		event.u.mapNotify.window = pWin->drawable.id;
		event.u.mapNotify.override = pWin->overrideRedirect;
		DeliverEvents(pWin, &event, 1, NullWindow);
	    }
    
	    if (!pFirstMapped)
		pFirstMapped = pWin;
	    if (pParent->realized)
	    {
		RealizeTree(pWin);
		if (pWin->viewable)
		{
		    anyMarked |= (*pScreen->MarkOverlappedWindows)(pWin, pWin,
							(WindowPtr *)NULL);
		}
	    }
	}
d2691 12
a2702 14
    if (pFirstMapped)
    {
	pLayerWin = (*pScreen->GetLayerWindow)(pParent);
	if (pLayerWin->parent != pParent) {
	    anyMarked |= (*pScreen->MarkOverlappedWindows)(pLayerWin,
							   pLayerWin,
							   (WindowPtr *)NULL);
	    pFirstMapped = pLayerWin;
	}
        if (anyMarked)
        {
	    (*pScreen->ValidateTree)(pLayerWin->parent, pFirstMapped, VTMap);
	    (*pScreen->HandleExposures)(pLayerWin->parent);
	}
d2704 3
a2706 3
	    (*pScreen->PostValidateTree)(pLayerWin->parent, pFirstMapped,
					 VTMap);
        WindowsRestructured ();
d2711 1
a2711 3
UnrealizeTree(
    WindowPtr pWin,
    Bool fromConfigure)
d2720 4
a2723 6
    while (1)
    {
	if (pChild->realized)
	{
	    pChild->realized = FALSE;
	    pChild->visibility = VisibilityNotViewable;
d2725 10
a2734 8
	    if(!noPanoramiXExtension && !pChild->drawable.pScreen->myNum) {
		PanoramiXRes *win;
		int rc = dixLookupResourceByType((pointer *)&win,
					     pChild->drawable.id, XRT_WINDOW,
					     serverClient, DixWriteAccess);
		if (rc == Success)
		   win->u.win.visibility = VisibilityNotViewable;
	    } 
d2736 18
a2753 20
	    (* Unrealize)(pChild);
	    if (MapUnmapEventsEnabled(pWin))
		DeleteWindowFromAnyEvents(pChild, FALSE);
	    if (pChild->viewable)
	    {
		pChild->viewable = FALSE;
		(* MarkUnrealizedWindow)(pChild, pWin, fromConfigure);
		pChild->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	    }
	    if (pChild->firstChild)
	    {
		pChild = pChild->firstChild;
		continue;
	    }
	}
	while (!pChild->nextSib && (pChild != pWin))
	    pChild = pChild->parent;
	if (pChild == pWin)
	    return;
	pChild = pChild->nextSib;
d2769 2
a2770 2
    Bool wasRealized = (Bool)pWin->realized;
    Bool wasViewable = (Bool)pWin->viewable;
d2775 12
a2786 14
	return Success;
    if (SubStrSend(pWin, pParent) && MapUnmapEventsEnabled(pWin))
    {
	memset(&event, 0, sizeof(xEvent));
	event.u.u.type = UnmapNotify;
	event.u.unmapNotify.window = pWin->drawable.id;
	event.u.unmapNotify.fromConfigure = fromConfigure;
	DeliverEvents(pWin, &event, 1, NullWindow);
    }
    if (wasViewable && !fromConfigure)
    {
	pWin->valdata = UnmapValData;
	(*pScreen->MarkOverlappedWindows)(pWin, pWin->nextSib, &pLayerWin);
	(*pScreen->MarkWindow)(pLayerWin->parent);
d2790 12
a2801 10
	UnrealizeTree(pWin, fromConfigure);
    if (wasViewable)
    {
	if (!fromConfigure)
	{
	    (*pScreen->ValidateTree)(pLayerWin->parent, pWin, VTUnmap);
	    (*pScreen->HandleExposures)(pLayerWin->parent);
	}
	if (!fromConfigure && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pLayerWin->parent, pWin, VTUnmap);
a2802 2
    if (wasRealized && !fromConfigure)
	WindowsRestructured ();
d2817 2
a2818 2
    Bool wasRealized = (Bool)pWin->realized;
    Bool wasViewable = (Bool)pWin->viewable;
d2825 1
a2825 1
	return;
d2830 1
a2830 1
	pLayerWin = (*pScreen->GetLayerWindow)(pWin);
d2832 18
a2849 23
    for (pChild = pWin->lastChild; pChild != pHead; pChild = pChild->prevSib)
    {
	if (pChild->mapped)
	{
	    if (parentNotify || StrSend(pChild))
	    {
		event.u.u.type = UnmapNotify;
		event.u.unmapNotify.window = pChild->drawable.id;
		event.u.unmapNotify.fromConfigure = xFalse;
		DeliverEvents(pChild, &event, 1, NullWindow);
	    }
	    if (pChild->viewable)
	    {
		pChild->valdata = UnmapValData;
		anyMarked = TRUE;
	    }
	    pChild->mapped = FALSE;
	    if (pChild->realized)
		UnrealizeTree(pChild, FALSE);
	    if (wasViewable)
	    {
	    }
	}
d2851 18
a2868 21
    if (wasViewable)
    {
	if (anyMarked)
	{
	    if (pLayerWin->parent == pWin)
		(*pScreen->MarkWindow)(pWin);
	    else
	    {
		WindowPtr ptmp;
                (*pScreen->MarkOverlappedWindows)(pWin, pLayerWin,
						  (WindowPtr *)NULL);
		(*pScreen->MarkWindow)(pLayerWin->parent);
		
		/* Windows between pWin and pLayerWin may not have been marked */
		ptmp = pWin;
 
		while (ptmp != pLayerWin->parent)
		{
		    (*pScreen->MarkWindow)(ptmp);
		    ptmp = ptmp->parent;
		}
d2870 10
a2879 6
	    }
	    (*pScreen->ValidateTree)(pLayerWin->parent, pHead, VTUnmap);
	    (*pScreen->HandleExposures)(pLayerWin->parent);
	}
	if (anyMarked && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pLayerWin->parent, pHead, VTUnmap);
a2880 2
    if (wasRealized)
	WindowsRestructured ();
a2882 1

d2889 2
a2890 3
    for (j=0; j<client->numSaved; j++)
    {
	pWin = SaveSetWindow(client->saveSet[j]);
d2892 3
a2894 3
	if (SaveSetToRoot(client->saveSet[j]))
	    pParent = pWin->drawable.pScreen->root;
	else
d2896 7
a2902 9
	{
	    pParent = pWin->parent;
	    while (pParent && (wClient (pParent) == client))
		pParent = pParent->parent;
	}
	if (pParent)
	{
	    if (pParent != pWin->parent)
	    {
d2904 3
a2906 3
		/* unmap first so that ReparentWindow doesn't remap */
		if (!SaveSetShouldMap (client->saveSet[j]))
		    UnmapWindow(pWin, FALSE);
d2908 8
a2915 7
		ReparentWindow(pWin, pParent,
			       pWin->drawable.x - wBorderWidth (pWin) - pParent->drawable.x,
			       pWin->drawable.y - wBorderWidth (pWin) - pParent->drawable.y,
			       client);
		if(!pWin->realized && pWin->mapped)
		    pWin->mapped = FALSE;
	    }
d2917 1
a2917 1
	    if (SaveSetShouldMap (client->saveSet[j]))
d2919 2
a2920 2
		MapWindow(pWin, client);
	}
d2924 1
a2924 1
    client->saveSet = (SaveSetElt *)NULL;
d2937 7
a2943 8
	return FALSE;
    if (RegionContainsPoint(&pWin->borderClip,
						  x, y, &box)
	&& (!wInputShape(pWin) ||
	    RegionContainsPoint(wInputShape(pWin),
				x - pWin->drawable.x,
				y - pWin->drawable.y, &box)))
	return TRUE;
a2946 1

d2951 1
d2953 3
a2955 4
	screenIsSaved != SCREEN_SAVER_ON ||
	!HasSaverWindow (pWin->drawable.pScreen))
    {
	RegionIntersect(pReg, &pWin->borderClip, &pWin->winSize);
d2970 58
a3027 53
    if(!noPanoramiXExtension) {
	PanoramiXRes *win;
	WindowPtr pWin2;
	int rc, i, Scrnum;

	Scrnum = pWin->drawable.pScreen->myNum;
	
	win = PanoramiXFindIDByScrnum(XRT_WINDOW, pWin->drawable.id, Scrnum);

	if(!win || (win->u.win.visibility == visibility))
	    return;

	switch(visibility) {
	case VisibilityUnobscured:
	    FOR_NSCREENS(i) {
		if(i == Scrnum) continue;

		rc = dixLookupWindow(&pWin2, win->info[i].id, serverClient,
				     DixWriteAccess);

		if (rc == Success) {
		    if(pWin2->visibility == VisibilityPartiallyObscured)
		   	return;

		    if(!i) pWin = pWin2;
		}
	    }
	    break;
	case VisibilityPartiallyObscured:
	    if(Scrnum) {
		rc = dixLookupWindow(&pWin2, win->info[0].id, serverClient,
				     DixWriteAccess);
		if (rc == Success) pWin = pWin2;
	    }
	    break;
	case VisibilityFullyObscured:
	    FOR_NSCREENS(i) {
		if(i == Scrnum) continue;

		rc = dixLookupWindow(&pWin2, win->info[i].id, serverClient,
				     DixWriteAccess);
		
		if (rc == Success) {
		    if(pWin2->visibility != VisibilityFullyObscured)
		    	return;

		    if(!i) pWin = pWin2;
		}
	    }
	    break;
	}
	
	win->u.win.visibility = visibility;
d3044 6
a3049 7
    if (on == SCREEN_SAVER_FORCER)
    {
	if (mode == ScreenSaverReset)
	    what = SCREEN_SAVER_OFF;
	else
	    what = SCREEN_SAVER_ON;
	type = what;
d3051 5
a3055 6
    else
    {
	what = on;
	type = what;
	if (what == screenIsSaved)
	    type = SCREEN_SAVER_CYCLE;
d3059 4
a3062 4
	rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, screenInfo.screens[i],
		      DixShowAccess | DixHideAccess);
	if (rc != Success)
	    return rc;
d3064 69
a3132 73
    for (i = 0; i < screenInfo.numScreens; i++)
    {
	ScreenPtr pScreen = screenInfo.screens[i];
	if (on == SCREEN_SAVER_FORCER)
	   (* pScreen->SaveScreen) (pScreen, on);
	if (pScreen->screensaver.ExternalScreenSaver)
	{
	    if ((*pScreen->screensaver.ExternalScreenSaver)
		(pScreen, type, on == SCREEN_SAVER_FORCER))
		continue;
	}
	if (type == screenIsSaved)
	    continue;
	switch (type) {
	case SCREEN_SAVER_OFF:
	    if (pScreen->screensaver.blanked == SCREEN_IS_BLANKED)
	    {
	       (* pScreen->SaveScreen) (pScreen, what);
	    }
	    else if (HasSaverWindow (pScreen))
	    {
		pScreen->screensaver.pWindow = NullWindow;
		FreeResource(pScreen->screensaver.wid, RT_NONE);
	    }
	    break;
	case SCREEN_SAVER_CYCLE:
	    if (pScreen->screensaver.blanked == SCREEN_IS_TILED)
	    {
		WindowPtr pWin = pScreen->screensaver.pWindow;
		/* make it look like screen saver is off, so that
		 * NotClippedByChildren will compute a clip list
		 * for the root window, so miPaintWindow works
		 */
		screenIsSaved = SCREEN_SAVER_OFF;
		(*pWin->drawable.pScreen->MoveWindow)(pWin,
			   (short)(-(rand() % RANDOM_WIDTH)),
			   (short)(-(rand() % RANDOM_WIDTH)),
			   pWin->nextSib, VTMove);
		screenIsSaved = SCREEN_SAVER_ON;
	    }
	    /*
	     * Call the DDX saver in case it wants to do something
	     * at cycle time
	     */
	    else if (pScreen->screensaver.blanked == SCREEN_IS_BLANKED)
	    {
		(* pScreen->SaveScreen) (pScreen, type);
	    }
	    break;
	case SCREEN_SAVER_ON:
	    if (ScreenSaverBlanking != DontPreferBlanking)
	    {
		if ((* pScreen->SaveScreen) (pScreen, what))
		{
		   pScreen->screensaver.blanked = SCREEN_IS_BLANKED;
		   continue;
		}
		if ((ScreenSaverAllowExposures != DontAllowExposures) &&
		    TileScreenSaver(pScreen, SCREEN_IS_BLACK))
		{
		    pScreen->screensaver.blanked = SCREEN_IS_BLACK;
		    continue;
		}
	    }
	    if ((ScreenSaverAllowExposures != DontAllowExposures) &&
		TileScreenSaver(pScreen, SCREEN_IS_TILED))
	    {
		pScreen->screensaver.blanked = SCREEN_IS_TILED;
	    }
	    else
		pScreen->screensaver.blanked = SCREEN_ISNT_SAVED;
	    break;
	}
d3136 5
a3140 5
	if (on == SCREEN_SAVER_FORCER) {
	    UpdateCurrentTimeIf();
	    lastDeviceEventTime = currentTime;
	}
	SetScreenSaverTimer();
d3158 1
a3158 1
    WindowPtr pWin;		
d3162 2
a3163 2
    XID	cursorID = 0;
    int	attri;
d3169 13
a3181 13
	switch (pScreen->root->backgroundState) {
	case BackgroundPixel:
	    attributes[attri++] = pScreen->root->background.pixel;
	    mask |= CWBackPixel;
	    break;
	case BackgroundPixmap:
	    attributes[attri++] = None;
	    mask |= CWBackPixmap;
	    break;
	default:
	    break;
	}
	break;
d3183 3
a3185 3
	attributes[attri++] = pScreen->root->drawable.pScreen->blackPixel;
	mask |= CWBackPixel;
	break;
d3194 10
a3203 11
    cm.width=16;
    cm.height=16;
    cm.xhot=8;
    cm.yhot=8;
    srcbits = malloc( BitmapBytePad(32)*16);
    mskbits = malloc( BitmapBytePad(32)*16);
    if (!srcbits || !mskbits)
    {
	free(srcbits);
	free(mskbits);
	cursor = 0;
d3205 18
a3222 22
    else
    {
	for (j=0; j<BitmapBytePad(32)*16; j++)
	    srcbits[j] = mskbits[j] = 0x0;
	result = AllocARGBCursor(srcbits, mskbits, NULL, &cm, 0, 0, 0, 0, 0, 0,
				 &cursor, serverClient, (XID)0);
	if (cursor)
	{
	    cursorID = FakeClientID(0);
	    if (AddResource (cursorID, RT_CURSOR, (pointer) cursor))
	    {
		attributes[attri] = cursorID;
		mask |= CWCursor;
	    }
	    else
		cursor = 0;
	}
	else
	{
	    free(srcbits);
	    free(mskbits);
	}
d3226 7
a3232 7
	 CreateWindow(pScreen->screensaver.wid,
	      pScreen->root,
	      -RANDOM_WIDTH, -RANDOM_WIDTH,
	      (unsigned short)pScreen->width + RANDOM_WIDTH,
	      (unsigned short)pScreen->height + RANDOM_WIDTH,
	      0, InputOutput, mask, attributes, 0, serverClient,
	      wVisual (pScreen->root), &result);
d3235 1
a3235 1
	FreeResource (cursorID, RT_NONE);
d3238 1
a3238 1
	return FALSE;
d3241 2
a3242 2
		     (pointer)pScreen->screensaver.pWindow))
	return FALSE;
d3244 3
a3246 4
    if (mask & CWBackPixmap)
    {
	MakeRootTile (pWin);
	(*pWin->drawable.pScreen->ChangeWindowAttributes)(pWin, CWBackPixmap);
d3261 1
a3261 1
FindWindowWithOptional (WindowPtr w)
d3264 1
a3264 1
	w = w->parent;
d3278 1
a3278 1
CheckWindowOptionalNeed (WindowPtr w)
d3284 1
a3284 1
	return;
d3287 1
a3287 1
	return;
d3289 1
a3289 1
	return;
d3291 1
a3291 1
	return;
d3293 1
a3293 1
	return;
d3295 1
a3295 1
	return;
d3297 1
a3297 1
	return;
d3299 1
a3299 1
	return;
d3301 1
a3301 1
	return;
d3303 1
a3303 1
	return;
d3305 1
a3305 1
	return;
d3307 2
a3308 3
	return;
    if (optional->deviceCursors != NULL)
    {
d3310 2
a3311 2
        while(pNode)
        {
d3320 1
a3320 1
	return;
d3322 2
a3323 3
	(optional->cursor != parentOptional->cursor ||
	 w->parent->cursorIsNone))
	return;
d3325 2
a3326 2
	return;
    DisposeWindowOptional (w);
d3337 1
a3337 1
MakeWindowOptional (WindowPtr pWin)
d3343 2
a3344 2
	return TRUE;
    optional = malloc(sizeof (WindowOptRec));
d3346 1
a3346 1
	return FALSE;
d3362 3
a3364 4
    if (!pWin->cursorIsNone)
    {
	optional->cursor = parentOptional->cursor;
	optional->cursor->refcnt++;
d3366 2
a3367 3
    else
    {
	optional->cursor = None;
d3389 1
a3389 3
ChangeWindowDeviceCursor(WindowPtr pWin, 
                         DeviceIntPtr pDev, 
                         CursorPtr pCursor) 
d3414 1
a3414 2
    if (WindowSeekDeviceCursor(pWin, pDev, &pNode, &pPrev))
    {
d3422 6
a3427 7
        if (!pCursor) /* remove from list */
        {
                if(pPrev)
                    pPrev->next = pNode->next;
                else
                    /* first item in list */
                    pWin->optional->deviceCursors = pNode->next;
d3433 2
a3434 2
    } else
    {
d3451 1
a3451 2
    else
    {
d3458 3
a3460 6
    for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib)
    {
        if (WindowSeekDeviceCursor(pChild, pDev, &pNode, &pPrev))
        {
            if (pNode->cursor == None) /* inherited from parent */
            {
d3463 2
a3464 2
            } else if (pNode->cursor == pCursor)
            {
d3466 1
a3466 1
                FreeCursor(pCursor, (Cursor)0); /* fix up refcnt */
d3471 1
a3471 1
out:
d3476 1
a3476 1
        FreeCursor(pOldCursor, (Cursor)0);
d3480 1
a3480 1
    (*pScreen->ChangeWindowAttributes)(pWin, CWCursor);
d3496 3
a3498 5
    while(pList)
    {
        if (pList->dev == pDev)
        {
            if (pList->cursor == None) /* inherited from parent */
d3513 4
a3516 5
static Bool 
WindowSeekDeviceCursor(WindowPtr pWin, 
                       DeviceIntPtr pDev, 
                       DevCursNodePtr* pNode, 
                       DevCursNodePtr* pPrev)
d3525 1
a3525 2
    if (pList && pList->dev == pDev)
    {
d3531 3
a3533 6
    while(pList)
    {
        if (pList->next)
        {
            if (pList->next->dev == pDev)
            {
d3546 4
a3549 5
 */ 
static Bool 
WindowParentHasDeviceCursor(WindowPtr pWin, 
                            DeviceIntPtr pDev, 
                            CursorPtr pCursor)
d3555 2
a3556 5
    while(pParent)
    {
        if (WindowSeekDeviceCursor(pParent, pDev, 
                    &pParentNode, &pParentPrev))
        {
d3558 1
a3558 1
            if (!pParentNode->cursor) /* inherited. */
d3560 1
a3560 1
            else if (pParentNode->cursor == pCursor) /* inherit */
d3562 1
a3562 1
            else  /* different cursor */
d3564 2
a3565 2
        } 
        else 
d3581 6
a3586 6
    WindowPtr	pWin = pScreen->root;
    WindowPtr	pChild;
    Bool	WasViewable;
    Bool	anyMarked = FALSE;
    WindowPtr   pLayerWin;
    BoxRec	box;
d3589 20
a3608 25
	return;
    WasViewable = (Bool)(pWin->viewable);
    if (WasViewable)
    {
	for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib)
	{
	    (void) (*pScreen->MarkOverlappedWindows)(pChild,
						     pChild,
						     &pLayerWin);
	}
	(*pScreen->MarkWindow) (pWin);
	anyMarked = TRUE;
	if (pWin->valdata)
	{
	    if (HasBorder (pWin))
	    {
		RegionPtr	borderVisible;

		borderVisible = RegionCreate(NullBox, 1);
		RegionSubtract(borderVisible,
				&pWin->borderClip, &pWin->winSize);
		pWin->valdata->before.borderVisible = borderVisible;
	    }
	    pWin->valdata->before.resized = TRUE;
	}
d3616 12
a3627 13
    if (enable)
    {
	box.x1 = 0;
	box.y1 = 0;
	box.x2 = pScreen->width;
	box.y2 = pScreen->height;
	RegionInit(&pWin->winSize, &box, 1);
	RegionInit(&pWin->borderSize, &box, 1);
	if (WasViewable)
	    RegionReset(&pWin->borderClip, &box);
	pWin->drawable.width = pScreen->width;
	pWin->drawable.height = pScreen->height;
	RegionBreak(&pWin->clipList);
d3629 3
a3631 4
    else
    {
	RegionEmpty(&pWin->borderClip);
	RegionBreak(&pWin->clipList);
d3634 1
a3634 1
    ResizeChildrenWinSize (pWin, 0, 0, 0, 0);
d3636 10
a3645 13
    if (WasViewable)
    {
	if (pWin->firstChild)
	{
	    anyMarked |= (*pScreen->MarkOverlappedWindows)(pWin->firstChild,
							   pWin->firstChild,
							   (WindowPtr *)NULL);
	}
	else
	{
	    (*pScreen->MarkWindow) (pWin);
	    anyMarked = TRUE;
	}
d3647 2
a3648 3

	if (anyMarked)
	    (*pScreen->ValidateTree)(pWin, NullWindow, VTOther);
d3651 5
a3655 6
    if (WasViewable)
    {
	if (anyMarked)
	    (*pScreen->HandleExposures)(pWin);
	if (anyMarked && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pWin, NullWindow, VTOther);
d3658 1
a3658 1
	WindowsRestructured ();   
@


1.7
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d111 1
d120 1
d128 3
d135 2
d147 2
d185 33
a217 5
#ifdef DEBUG
/******
 * PrintWindowTree
 *    For debugging only
 ******/
d219 1
a219 2
static void
PrintChildren(WindowPtr p1, int indent)
a220 1
    WindowPtr p2;
d222 6
d229 19
a247 1
    while (p1)
d249 26
a274 7
	p2 = p1->firstChild;
        ErrorF("[dix] ");
	for (i=0; i<indent; i++) ErrorF(" ");
	ErrorF("%lx\n", p1->drawable.id);
	RegionPrint(&p1->clipList);
	PrintChildren(p2, indent+4);
	p1 = p1->nextSib;
d276 2
d280 1
a280 1
static void
d283 3
a285 2
    int i;
    WindowPtr pWin, p1;
d287 1
a287 1
    for (i=0; i<screenInfo.numScreens; i++)
d289 23
a311 5
	ErrorF("[dix] WINDOW %d\n", i);
	pWin = screenInfo.screens[i]->root;
	RegionPrint(&pWin->clipList);
	p1 = pWin->firstChild;
	PrintChildren(p1, 4);
a313 1
#endif
d397 4
d568 4
d573 1
d1060 21
d1130 1
a1130 1
		    MakeRootTile(pWin);
d1147 1
a1147 1
		    MakeRootTile(pWin);
d3168 1
a3168 1
	    for(i = 0; i < PanoramiXNumScreens; i++) {
d3190 1
a3190 1
	    for(i = 0; i < PanoramiXNumScreens; i++) {
a3217 7

#ifndef NOLOGOHACK
static void DrawLogo(
    WindowPtr pWin
);
#endif

a3278 4
#ifndef NOLOGOHACK
		if (logoScreenSaver)
		    (*pWin->drawable.pScreen->ClearToBackground)(pWin, 0, 0, 0, 0, FALSE);
#endif
a3282 4
#ifndef NOLOGOHACK
		if (logoScreenSaver)
		    DrawLogo(pWin);
#endif
a3439 4
#ifndef NOLOGOHACK
    if (kind == SCREEN_IS_TILED && logoScreenSaver)
	DrawLogo(pWin);
#endif
d3786 8
a3793 3
#ifndef NOLOGOHACK
static void
DrawLogo(WindowPtr pWin)
d3795 8
a3802 20
    DrawablePtr pDraw;
    ScreenPtr pScreen;
    int x, y;
    unsigned int width, height, size;
    GC *pGC;
    int rc, thin, gap, d31;
    DDXPointRec poly[4];
    ChangeGCVal fore[2], back[2];
    xrgb rgb[2];
    BITS32 fmask, bmask;
    ColormapPtr cmap;

    pDraw = (DrawablePtr)pWin;
    pScreen = pDraw->pScreen;
    x = -pWin->origin.x;
    y = -pWin->origin.y;
    width = pScreen->width;
    height = pScreen->height;
    pGC = GetScratchGC(pScreen->rootDepth, pScreen);
    if (!pGC)
d3804 16
d3821 4
a3824 20
    if ((rand() % 100) <= 17) /* make the probability for white fairly low */
	fore[0].val = pScreen->whitePixel;
    else
	fore[0].val = pScreen->blackPixel;
    if (pWin->backgroundState == BackgroundPixel) {
	rc = dixLookupResourceByType((pointer *)&cmap, wColormap(pWin),
				     RT_COLORMAP, serverClient, DixReadAccess);
	if (rc == Success) {
	    Pixel querypixels[2];

	    querypixels[0] = fore[0].val;
	    querypixels[1] = pWin->background.pixel;
	    QueryColors(cmap, 2, querypixels, rgb, serverClient);
	    if ((rgb[0].red == rgb[1].red) &&
		(rgb[0].green == rgb[1].green) &&
		(rgb[0].blue == rgb[1].blue)) {
		if (fore[0].val == pScreen->blackPixel)
		    fore[0].val = pScreen->whitePixel;
		else
		    fore[0].val = pScreen->blackPixel;
d3826 1
a3828 24
    fore[1].val = FillSolid;
    fmask = GCForeground|GCFillStyle;
    if (pWin->backgroundState == BackgroundPixel) {
	back[0].val = pWin->background.pixel;
	back[1].val = FillSolid;
	bmask = GCForeground|GCFillStyle;
    } else {
	back[0].val = 0;
	back[1].val = 0;
	ChangeGC(NullClient, pGC, GCTileStipXOrigin|GCTileStipYOrigin, back);
	back[0].val = FillTiled;
	back[1].ptr = pWin->background.pixmap;
	bmask = GCFillStyle|GCTile;
    }

    /* should be the same as the reference function XmuDrawLogo() */

    size = width;
    if (height < width)
	 size = height;
    size = RANDOM_WIDTH + rand() % (size - RANDOM_WIDTH);
    size &= ~1;
    x += rand() % (width - size);
    y += rand() % (height - size);
d3830 24
a3853 13
/*
 * Draw what will be the thin strokes.
 *
 *           -----
 *          /    /
 *         /    /
 *        /    /
 *       /    /
 *      /____/
 *           d
 *
 * Point d is 9/44 (~1/5) of the way across.
 */
d3855 1
a3855 11
    thin = (size / 11);
    if (thin < 1) thin = 1;
    gap = (thin+3) / 4;
    d31 = thin + thin + gap;
    poly[0].x = x + size;	       poly[0].y = y;
    poly[1].x = x + size-d31;	       poly[1].y = y;
    poly[2].x = x + 0;		       poly[2].y = y + size;
    poly[3].x = x + d31;	       poly[3].y = y + size;
    ChangeGC(NullClient, pGC, fmask, fore);
    ValidateGC(pDraw, pGC);
    (*pGC->ops->FillPolygon)(pDraw, pGC, Convex, CoordModeOrigin, 4, poly);
d3857 13
a3869 10
/*
 * Erase area not needed for lower thin stroke.
 *
 *           ------
 *          /	  /
 *         /  __ /
 *        /  /	/
 *       /  /  /
 *      /__/__/
 */
a3870 7
    poly[0].x = x + d31/2;			 poly[0].y = y + size;
    poly[1].x = x + size / 2;			 poly[1].y = y + size/2;
    poly[2].x = x + (size/2)+(d31-(d31/2));	 poly[2].y = y + size/2;
    poly[3].x = x + d31;			 poly[3].y = y + size;
    ChangeGC(NullClient, pGC, bmask, back);
    ValidateGC(pDraw, pGC);
    (*pGC->ops->FillPolygon)(pDraw, pGC, Convex, CoordModeOrigin, 4, poly);
d3872 3
a3874 10
/*
 * Erase area not needed for upper thin stroke.
 *
 *	     ------
 *	    /  /  /
 *	   /--/	 /
 *	  /	/
 *	 /     /
 *	/_____/
 */
d3876 10
a3885 47
    poly[0].x = x + size - d31/2;		 poly[0].y = y;
    poly[1].x = x + size / 2;			 poly[1].y = y + size/2;
    poly[2].x = x + (size/2)-(d31-(d31/2));	 poly[2].y = y + size/2;
    poly[3].x = x + size - d31;			 poly[3].y = y;
    ValidateGC(pDraw, pGC);
    (*pGC->ops->FillPolygon)(pDraw, pGC, Convex, CoordModeOrigin, 4, poly);

/*
 * Draw thick stroke.
 * Point b is 1/4 of the way across.
 *
 *      b
 * -----
 * \	\
 *  \	 \
 *   \	  \
 *    \	   \
 *     \____\
 */

    poly[0].x = x;		       poly[0].y = y;
    poly[1].x = x + size/4;	       poly[1].y = y;
    poly[2].x = x + size;	       poly[2].y = y + size;
    poly[3].x = x + size - size/4;     poly[3].y = y + size;
    ChangeGC(NullClient, pGC, fmask, fore);
    ValidateGC(pDraw, pGC);
    (*pGC->ops->FillPolygon)(pDraw, pGC, Convex, CoordModeOrigin, 4, poly);

/*
 * Erase to create gap.
 *
 *	    /
 *	   /
 *	  /
 *	 /
 *	/
 */

    poly[0].x = x + size- thin;	      poly[0].y = y;
    poly[1].x = x + size-( thin+gap);  poly[1].y = y;
    poly[2].x = x + thin;	      poly[2].y = y + size;
    poly[3].x = x + thin + gap;	      poly[3].y = y + size;
    ChangeGC(NullClient, pGC, bmask, back);
    ValidateGC(pDraw, pGC);
    (*pGC->ops->FillPolygon)(pDraw, pGC, Convex, CoordModeOrigin, 4, poly);

    FreeScratchGC(pGC);
a3886 2

#endif
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d3663 3
a3665 3
            if (!pParentNode->cursor) /* inherited. loop needs to cont. */
            {
            } else if (pParentNode->cursor == pCursor) /* inherit */
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d154 1
a154 7
ScreenSaverStuffRec savedScreenInfo[MAXSCREENS];

static int FocusPrivatesKeyIndex;
DevPrivateKey FocusPrivatesKey = &FocusPrivatesKeyIndex;

static Bool TileScreenSaver(int i, int kind);

d194 1
a194 1
	miPrintRegion(&p1->clipList);
d209 2
a210 2
	pWin = WindowTable[i];
	miPrintRegion(&pWin->clipList);
d224 1
a224 1
       return(WT_NOMATCH);
d229 1
a229 1
	    return(WT_STOPWALKING);
d241 1
a241 1
    return(WT_NOMATCH);
d255 1
a255 1
    return(TraverseTree(WindowTable[pScreen->myNum], func, data));
d320 1
a320 1
	CARD32 attributes[2];
d322 2
a323 2
	attributes[0] = pScreen->whitePixel;
	attributes[1] = pScreen->blackPixel;
d325 1
a325 1
	(void)ChangeGC(pGC, GCForeground | GCBackground, attributes);
d356 1
a356 1
    pWin = xalloc(sizeof(WindowRec));
d360 3
a362 3
    savedScreenInfo[pScreen->myNum].pWindow = NULL;
    savedScreenInfo[pScreen->myNum].wid = FakeClientID(0);
    savedScreenInfo[pScreen->myNum].ExternalScreenSaver = NULL;
d365 1
a365 1
    WindowTable[pScreen->myNum] = pWin;
a368 1
    pWin->devPrivates = NULL;
d382 1
a382 1
    pWin->optional = xalloc (sizeof (WindowOptRec));
d414 4
a417 4
    REGION_INIT(pScreen, &pWin->clipList, &box, 1);
    REGION_INIT(pScreen, &pWin->winSize, &box, 1);
    REGION_INIT(pScreen, &pWin->borderSize, &box, 1);
    REGION_INIT(pScreen, &pWin->borderClip, &box, 1);
d492 1
a492 4
    ScreenPtr pScreen;
    BoxRec box;

    pScreen = pWin->drawable.pScreen;
a493 1
    box = *(REGION_EXTENTS(pScreen, &pWin->winSize));
d509 2
a510 2
    REGION_RESET(pScreen, Rgn, &box);
    REGION_INTERSECT(pScreen, Rgn, Rgn, &pWin->winSize);
d531 2
a532 2
	(HasSaverWindow (pWin->drawable.pScreen->myNum)))
	return (pWin->firstChild);
d534 1
a534 1
	return (NullWindow);
d631 1
a631 1
    pWin = xalloc(sizeof(WindowRec));
a637 1
    pWin->devPrivates = NULL;
d661 1
a661 1
	    xfree (pWin);
d676 1
a676 1
	xfree(pWin);
d696 4
a699 4
    REGION_NULL(pScreen, &pWin->clipList);
    REGION_NULL(pScreen, &pWin->borderClip);
    REGION_NULL(pScreen, &pWin->winSize);
    REGION_NULL(pScreen, &pWin->borderSize);
d800 1
a800 1
            xfree(pPrev);
d805 1
a805 1
    xfree (pWin->optional);
d817 4
a820 4
    REGION_UNINIT(pScreen, &pWin->clipList);
    REGION_UNINIT(pScreen, &pWin->winSize);
    REGION_UNINIT(pScreen, &pWin->borderClip);
    REGION_UNINIT(pScreen, &pWin->borderSize);
d822 1
a822 1
	REGION_DESTROY(pScreen, wBoundingShape (pWin));
d824 1
a824 1
	REGION_DESTROY(pScreen, wClipShape (pWin));
d826 1
a826 1
	REGION_DESTROY(pScreen, wInputShape (pWin));
d874 1
a874 2
	    dixFreePrivates(pChild->devPrivates);
	    xfree(pChild);
d924 3
a926 3
    xfree(dixLookupPrivate(&pWin->devPrivates, FocusPrivatesKey));
    dixFreePrivates(pWin->devPrivates);
    xfree(pWin);
d1046 1
a1046 1
		    error = (rc == BadValue) ? BadPixmap : rc;
d1106 1
a1106 1
		error = (rc == BadValue) ? BadPixmap : rc;
d1254 1
a1254 1
		error = (rc == BadValue) ? BadColor : rc;
d1319 1
a1319 1
		if (pWin == WindowTable[pWin->drawable.pScreen->myNum])
d1330 1
a1330 1
		    error = (rc == BadValue) ? BadCursor : rc;
d1423 2
a1424 2
	REGION_NULL(pScreen, &exposed);
	REGION_SUBTRACT(pScreen, &exposed, &pWin->borderClip, &pWin->winSize);
d1426 1
a1426 1
	REGION_UNINIT(pScreen, &exposed);
d1554 1
a1554 1
    return( pFirstChange );
d1573 1
a1573 1
	REGION_RESET (pScreen, &pWin->winSize, &box);
d1582 1
a1582 4
	ScreenPtr pScreen;
        pScreen = pWin->drawable.pScreen;

	REGION_TRANSLATE(pScreen, &pWin->winSize, - pWin->drawable.x,
d1585 1
a1585 1
	    REGION_INTERSECT(pScreen, &pWin->winSize, &pWin->winSize,
d1588 1
a1588 1
	    REGION_INTERSECT(pScreen, &pWin->winSize, &pWin->winSize,
d1590 1
a1590 1
	REGION_TRANSLATE(pScreen, &pWin->winSize, pWin->drawable.x,
d1615 1
a1615 1
	    REGION_RESET (pScreen, &pWin->borderSize, &box);
d1624 1
a1624 4
	    ScreenPtr pScreen;
            pScreen = pWin->drawable.pScreen;

	    REGION_TRANSLATE(pScreen, &pWin->borderSize, - pWin->drawable.x,
d1626 1
a1626 1
	    REGION_INTERSECT(pScreen, &pWin->borderSize, &pWin->borderSize,
d1628 1
a1628 1
	    REGION_TRANSLATE(pScreen, &pWin->borderSize, pWin->drawable.x,
d1630 1
a1630 1
	    REGION_UNION(pScreen, &pWin->borderSize, &pWin->borderSize,
d1634 1
a1634 2
	REGION_COPY(pWin->drawable.pScreen, &pWin->borderSize,
					       &pWin->winSize);
d1800 1
a1800 1
	    return(Above);
d1802 1
a1802 1
	    return(Below);
d1805 1
a1805 1
    return(Below);
d1819 1
a1819 1
    return(pBox);
d1829 1
a1829 5
    RegionPtr	pRgn;
    ScreenPtr   pScreen;
    pScreen = pWin->drawable.pScreen;

    pRgn = REGION_CREATE(pScreen, pBox, 1);
d1831 3
a1833 5
	    REGION_TRANSLATE(pScreen, pRgn, -pWin->origin.x,
						  -pWin->origin.y);
	    REGION_INTERSECT(pScreen, pRgn, pRgn, wBoundingShape (pWin));
	    REGION_TRANSLATE(pScreen, pRgn, pWin->origin.x,
						  pWin->origin.y);
a1845 1
    ScreenPtr	pScreen;
a1849 1
    pScreen = pWin->drawable.pScreen;
d1852 4
a1855 4
    REGION_INTERSECT(pScreen, pWinRgn, pWinRgn, pSibRgn);
    ret = REGION_NOTEMPTY(pScreen, pWinRgn);
    REGION_DESTROY(pScreen, pWinRgn);
    REGION_DESTROY(pScreen, pSibRgn);
d1877 1
a1877 1
		return(TRUE);
d1880 1
a1880 1
    return(FALSE);
d1900 1
a1900 1
		return(TRUE);
d1903 1
a1903 1
    return(FALSE);
a1944 1
    ScreenPtr pScreen;
a1951 1
    pScreen = pWin->drawable.pScreen;
d1960 1
a1960 1
	   return(pSib);
d1962 1
a1962 1
	    return(pWin->nextSib);
d1964 1
a1964 1
	    return(pFirst);
d1968 1
a1968 1
		return(pSib->nextSib);
d1970 1
a1970 1
		return(pWin->nextSib);
d1975 1
a1975 1
	    return(pWin->nextSib);
d1979 2
a1980 2
		(RECT_IN_REGION(pScreen, &pSib->borderSize, &box) != rgnOUT))
		return(pFirst);
d1982 1
a1982 1
		return(pWin->nextSib);
d1985 1
a1985 1
	    return(pFirst);
d1987 1
a1987 1
	    return(pWin->nextSib);
d1990 1
a1990 1
	    return(pWin->nextSib);
d1994 1
a1994 1
		(RECT_IN_REGION(pScreen, &pSib->borderSize, &box) != rgnOUT))
d1997 1
a1997 1
		return(pWin->nextSib);
d2002 1
a2002 1
	    return(pWin->nextSib);
d2005 1
a2005 1
	    return(pWin->nextSib);
d2008 1
a2008 1
	    if (RECT_IN_REGION(pScreen, &pSib->borderSize, &box) != rgnOUT)
d2011 1
a2011 1
		    return(pFirst);
d2016 1
a2016 1
		return(pWin->nextSib);
d2024 1
a2024 1
	    return(pFirst);
d2099 1
a2099 1
	return(BadMatch);
d2102 1
a2102 1
	return(BadMatch);
d2159 1
a2159 1
		return(BadMatch);
d2161 1
a2161 1
		return(BadMatch);
d2169 1
a2169 1
		return(BadValue);
d2174 1
a2174 1
	    return(BadValue);
d2211 2
a2212 2
            event.u.configureRequest.x += panoramiXdataPtr[0].x;
            event.u.configureRequest.y += panoramiXdataPtr[0].y;
d2222 1
a2222 1
	    return(Success);
d2273 1
a2273 1
    return(Success);
d2277 8
a2284 1
	(*pWin->drawable.pScreen->ConfigNotify)(pWin, x, y, w, h, bw, pSib);
d2299 2
a2300 2
	    event.u.configureNotify.x += panoramiXdataPtr[0].x;
            event.u.configureNotify.y += panoramiXdataPtr[0].y;
d2336 1
a2336 1
    return(Success);
d2397 1
a2397 1
	    return(Success);
d2406 1
a2406 1
    return(Success);
d2417 1
a2417 1
       return(WT_STOPWALKING);
d2419 1
a2419 1
       return(WT_WALKCHILDREN);
d2438 1
a2438 1
	return(BadMatch);		
d2440 1
a2440 1
	return(BadAlloc);
d2453 2
a2454 2
	event.u.reparent.x += panoramiXdataPtr[0].x;
	event.u.reparent.y += panoramiXdataPtr[0].y;
d2516 1
a2516 1
    return(Success);
d2589 1
a2589 1
	return(Success);
d2613 1
a2613 1
		return(Success);
d2627 1
a2627 1
	    return(Success);
d2656 2
a2657 2
	REGION_NULL(pScreen, &temp);
	REGION_COPY(pScreen, &temp, &pWin->clipList);
d2659 1
a2659 1
	REGION_UNINIT(pScreen, &temp);
d2662 1
a2662 1
    return(Success);
a2756 1
    int rc;
d2770 1
a2770 1
		rc = dixLookupResourceByType((pointer *)&win,
d2818 1
a2818 1
	return(Success);
d2848 1
a2848 1
    return(Success);
d2946 1
a2946 1
	    pParent = WindowTable[pWin->drawable.pScreen->myNum];
d2976 1
a2976 1
    xfree(client->saveSet);
d2991 2
a2992 2
	return (FALSE);
    if (POINT_IN_REGION(pWin->drawable.pScreen, &pWin->borderClip,
d2995 5
a2999 6
	    POINT_IN_REGION(pWin->drawable.pScreen,
			    wInputShape(pWin),
			    x - pWin->drawable.x, 
			    y - pWin->drawable.y, &box)))
	return(TRUE);
    return(FALSE);
d3006 1
a3006 5
    ScreenPtr pScreen;
    RegionPtr pReg;

    pScreen = pWin->drawable.pScreen;
    pReg = REGION_CREATE(pScreen, NullBox, 1);
d3009 1
a3009 1
	!HasSaverWindow (pWin->drawable.pScreen->myNum))
d3011 1
a3011 1
	REGION_INTERSECT(pScreen, pReg, &pWin->borderClip, &pWin->winSize);
d3013 1
a3013 1
    return(pReg);
a3019 1
#ifndef NO_XINERAMA_PORT
d3021 1
a3021 1
#endif
d3126 1
d3128 2
a3129 2
	   (* screenInfo.screens[i]->SaveScreen) (screenInfo.screens[i], on);
	if (savedScreenInfo[i].ExternalScreenSaver)
d3131 2
a3132 2
	    if ((*savedScreenInfo[i].ExternalScreenSaver)
		(screenInfo.screens[i], type, on == SCREEN_SAVER_FORCER))
d3139 1
a3139 1
	    if (savedScreenInfo[i].blanked == SCREEN_IS_BLANKED)
d3141 1
a3141 2
	       (* screenInfo.screens[i]->SaveScreen) (screenInfo.screens[i],
						      what);
d3143 1
a3143 1
	    else if (HasSaverWindow (i))
d3145 2
a3146 2
		savedScreenInfo[i].pWindow = NullWindow;
		FreeResource(savedScreenInfo[i].wid, RT_NONE);
d3150 1
a3150 1
	    if (savedScreenInfo[i].blanked == SCREEN_IS_TILED)
d3152 1
a3152 1
		WindowPtr pWin = savedScreenInfo[i].pWindow;
d3176 1
a3176 1
	    else if (savedScreenInfo[i].blanked == SCREEN_IS_BLANKED)
d3178 1
a3178 2
		(* screenInfo.screens[i]->SaveScreen) (screenInfo.screens[i],
						       type);
d3184 1
a3184 2
		if ((* screenInfo.screens[i]->SaveScreen)
		   (screenInfo.screens[i], what))
d3186 1
a3186 1
		   savedScreenInfo[i].blanked = SCREEN_IS_BLANKED;
d3190 1
a3190 1
		    TileScreenSaver(i, SCREEN_IS_BLACK))
d3192 1
a3192 1
		    savedScreenInfo[i].blanked = SCREEN_IS_BLACK;
d3197 1
a3197 1
		TileScreenSaver(i, SCREEN_IS_TILED))
d3199 1
a3199 1
		savedScreenInfo[i].blanked = SCREEN_IS_TILED;
d3202 1
a3202 1
		savedScreenInfo[i].blanked = SCREEN_ISNT_SAVED;
d3224 1
a3224 1
TileScreenSaver(int i, int kind)
d3241 1
a3241 1
	switch (WindowTable[i]->backgroundState) {
d3243 1
a3243 1
	    attributes[attri++] = WindowTable[i]->background.pixel;
d3255 1
a3255 1
	attributes[attri++] = WindowTable[i]->drawable.pScreen->blackPixel;
d3270 2
a3271 2
    srcbits = xalloc( BitmapBytePad(32)*16);
    mskbits = xalloc( BitmapBytePad(32)*16);
d3274 2
a3275 2
	xfree(srcbits);
	xfree(mskbits);
d3297 2
a3298 2
	    xfree (srcbits);
	    xfree (mskbits);
d3302 3
a3304 3
    pWin = savedScreenInfo[i].pWindow =
	 CreateWindow(savedScreenInfo[i].wid,
	      WindowTable[i],
d3306 2
a3307 2
	      (unsigned short)screenInfo.screens[i]->width + RANDOM_WIDTH,
	      (unsigned short)screenInfo.screens[i]->height + RANDOM_WIDTH,
d3309 1
a3309 1
	      wVisual (WindowTable[i]), &result);
d3318 1
a3318 1
		     (pointer)savedScreenInfo[i].pWindow))
d3428 1
a3428 1
    optional = xalloc (sizeof (WindowOptRec));
d3519 1
a3519 1
            xfree(pNode);
d3531 1
a3531 1
        pNewNode = xalloc(sizeof(DevCursNodeRec));
d3715 1
a3715 1
	    QueryColors(cmap, 2, querypixels, rgb);
d3735 1
a3735 2
	dixChangeGC(NullClient, pGC, GCTileStipXOrigin|GCTileStipYOrigin,
		    NULL, back);
d3773 1
a3773 1
    dixChangeGC(NullClient, pGC, fmask, NULL, fore);
d3792 1
a3792 1
    dixChangeGC(NullClient, pGC, bmask, NULL, back);
d3831 1
a3831 1
    dixChangeGC(NullClient, pGC, fmask, NULL, fore);
d3849 1
a3849 1
    dixChangeGC(NullClient, pGC, bmask, NULL, back);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d5 10
a14 8
Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
d18 5
a22 8
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL 
RED HAT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Red Hat shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from Red Hat.
d152 1
a152 1
_X_EXPORT int screenIsSaved = SCREEN_SAVER_OFF;
d154 1
a154 1
_X_EXPORT ScreenSaverStuffRec savedScreenInfo[MAXSCREENS];
d157 1
a157 1
_X_EXPORT DevPrivateKey FocusPrivatesKey = &FocusPrivatesKeyIndex;
d223 1
a223 1
_X_EXPORT int
d258 1
a258 1
_X_EXPORT int
d362 1
a362 1
    pWin = (WindowPtr)xalloc(sizeof(WindowRec));
d389 1
a389 1
    pWin->optional = (WindowOptRec *) xalloc (sizeof (WindowOptRec));
a404 13
    pWin->optional->geMasks = (GenericClientMasksPtr)xcalloc(1, sizeof(GenericClientMasksRec));
    if (!pWin->optional->geMasks)
    {
        xfree(pWin->optional);
        return FALSE;
    }

    pWin->optional->access.perm = NULL;
    pWin->optional->access.deny = NULL;
    pWin->optional->access.nperm = 0;
    pWin->optional->access.ndeny = 0;
    pWin->optional->access.defaultRule = 0;

d553 1
a553 1
_X_EXPORT WindowPtr
d642 1
a642 1
    pWin = (WindowPtr)xalloc(sizeof(WindowRec));
d769 1
a786 2
    GenericMaskPtr gmask = NULL, next = NULL;

a816 14
    xfree(pWin->optional->access.perm);
    xfree(pWin->optional->access.deny);

    /* Remove generic event mask allocations */
    if (pWin->optional->geMasks)
        gmask = pWin->optional->geMasks->geClients;
    while(gmask)
    {
        next = gmask->next;
        xfree(gmask);
        gmask = next;
    }
    xfree (pWin->optional->geMasks);

d872 1
d875 1
a875 1
		DeliverEvents(pChild, &event, 1, NullWindow);		
d919 1
d922 1
a922 1
	DeliverEvents(pWin, &event, 1, NullWindow);		
a965 3
#define DeviceEventMasks (KeyPressMask | KeyReleaseMask | ButtonPressMask | \
    ButtonReleaseMask | PointerMotionMask)

d974 1
a974 1
_X_EXPORT int
d1460 2
a1461 2
    wa->length = (sizeof(xGetWindowAttributesReply) -
		 sizeof(xGenericReply)) >> 2;
a1569 26
_X_EXPORT RegionPtr
CreateUnclippedWinSize (WindowPtr pWin)
{
    RegionPtr	pRgn;
    BoxRec	box;

    box.x1 = pWin->drawable.x;
    box.y1 = pWin->drawable.y;
    box.x2 = pWin->drawable.x + (int) pWin->drawable.width;
    box.y2 = pWin->drawable.y + (int) pWin->drawable.height;
    pRgn = REGION_CREATE(pWin->drawable.pScreen, &box, 1);
    if (wBoundingShape (pWin) || wClipShape (pWin)) {
	ScreenPtr pScreen;
        pScreen = pWin->drawable.pScreen;

	REGION_TRANSLATE(pScreen, pRgn, - pWin->drawable.x,
			 - pWin->drawable.y);
	if (wBoundingShape (pWin))
	    REGION_INTERSECT(pScreen, pRgn, pRgn, wBoundingShape (pWin));
	if (wClipShape (pWin))
	    REGION_INTERSECT(pScreen, pRgn, pRgn, wClipShape (pWin));
	REGION_TRANSLATE(pScreen, pRgn, pWin->drawable.x, pWin->drawable.y);
    }
    return pRgn;
}

d1665 1
a1665 1
_X_EXPORT void
d2226 1
d2261 1
d2306 3
d2311 1
d2468 1
d2603 1
a2603 1
_X_EXPORT int
d2629 1
d2642 1
d2717 1
d2730 1
d2780 1
d2794 4
a2797 3
		win = (PanoramiXRes*)LookupIDByType(pChild->drawable.id,
							XRT_WINDOW);
		if(win)
d2831 1
a2831 1
_X_EXPORT int
d2845 1
d3028 1
a3028 1
_X_EXPORT RegionPtr
d3059 1
a3059 1
	int i, Scrnum;
d3073 2
a3074 1
		pWin2 = (WindowPtr)LookupIDByType(win->info[i].id, RT_WINDOW);
d3076 1
a3076 1
		if (pWin2) {
d3086 3
a3088 2
	        pWin2 = (WindowPtr)LookupIDByType(win->info[0].id, RT_WINDOW);
		if (pWin2) pWin = pWin2;
d3095 2
a3096 1
		pWin2 = (WindowPtr)LookupIDByType(win->info[i].id, RT_WINDOW);
d3098 1
a3098 1
		if (pWin2) {
d3112 1
d3127 1
a3127 1
_X_EXPORT int
d3239 7
a3245 2
    if (mode == ScreenSaverReset)
       SetScreenSaverTimer();
d3249 1
a3249 1
_X_EXPORT int
d3302 2
a3303 2
    srcbits = (unsigned char *)xalloc( BitmapBytePad(32)*16);
    mskbits = (unsigned char *)xalloc( BitmapBytePad(32)*16);
d3374 1
a3374 1
_X_EXPORT WindowPtr
d3391 1
a3391 1
_X_EXPORT void
d3397 1
a3397 1
    if (!w->parent)
a3431 6
    if (optional->access.nperm != 0 ||
            optional->access.ndeny != 0)
        return;

    if (optional->geMasks != NULL)
        return;
d3452 1
a3452 1
_X_EXPORT Bool
d3460 1
a3460 1
    optional = (WindowOptPtr) xalloc (sizeof (WindowOptRec));
a3475 18
    optional->geMasks = 
        (GenericClientMasksPtr)xalloc(sizeof(GenericClientMasksRec));
    if (!optional->geMasks)
    {
        xfree(optional);
        return FALSE;
    } else {
        int i;
        optional->geMasks->geClients = 0;
        for (i = 0; i < MAXEXTENSIONS; i++)
            optional->geMasks->eventMasks[i] = 0;
    }

    optional->access.nperm = 0;
    optional->access.ndeny = 0;
    optional->access.perm = NULL;
    optional->access.deny = NULL;
    optional->access.defaultRule = 0;
d3506 1
a3506 1
_X_EXPORT int
d3552 1
a3552 1
            return Success;
d3563 1
a3563 1
        pNewNode = (DevCursNodePtr)xalloc(sizeof(DevCursNodeRec));
d3597 1
d3612 1
a3612 1
_X_EXPORT CursorPtr 
d3718 1
a3718 1
    int thin, gap, d31;
d3739 17
a3755 14
    if ((pWin->backgroundState == BackgroundPixel) &&
	(cmap = (ColormapPtr)LookupIDByType(wColormap (pWin), RT_COLORMAP))) {
	Pixel querypixels[2];

	querypixels[0] = fore[0].val;
	querypixels[1] = pWin->background.pixel;
	QueryColors(cmap, 2, querypixels, rgb);
	if ((rgb[0].red == rgb[1].red) &&
	    (rgb[0].green == rgb[1].green) &&
	    (rgb[0].blue == rgb[1].blue)) {
	    if (fore[0].val == pScreen->blackPixel)
		fore[0].val = pScreen->whitePixel;
	    else
		fore[0].val = pScreen->blackPixel;
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d113 1
d126 1
a127 3
#ifdef XAPPGROUP
#include "appgroup.h"
#endif
d138 1
a138 1
 *
d144 9
d157 3
a182 3
_X_EXPORT int numSaveUndersViewable = 0;
_X_EXPORT int deltaSaveUndersViewable = 0;

d198 3
a200 2
	for (i=0; i<indent; i++) ErrorF( " ");
	ErrorF( "%lx\n", p1->drawable.id);
d215 1
a215 1
	ErrorF( "WINDOW %d\n", i);
a269 2
/* hack to force no save unders */
Bool	disableSaveUnders = FALSE;
d302 4
a400 1
#ifdef SHAPE
a403 2
#endif
#ifdef XINPUT
d405 14
a418 1
#endif
d464 1
a464 14
#ifdef DO_SAVE_UNDERS
    if ((pScreen->backingStoreSupport != NotUseful) &&
	(pScreen->saveUnderSupport == NotUseful))
    {
	/*
	 * If the screen has backing-store but no save-unders, let the
	 * clients know we can support save-unders using backing-store.
	 */
	pScreen->saveUnderSupport = USE_DIX_SAVE_UNDERS;
    }
#endif /* DO_SAVE_UNDERS */
		
    if (disableSaveUnders)
	pScreen->saveUnderSupport = NotUseful;
d483 2
a484 1
    if (!blackRoot && !whiteRoot) {
d487 4
a490 3
    }
    else {
        if (blackRoot)
a491 2
        else
            pWin->background.pixel = pScreen->whitePixel;
a610 8
#ifdef XAPPGROUP
	VisualID ag_visual;

	if (client->appgroup && !pParent->parent &&
	    (ag_visual = XagRootVisual (client)))
	    visual = ag_visual;
	else
#endif
d800 2
d815 31
a861 1
#ifdef SHAPE
a867 1
#endif
a906 4
#ifdef DO_SAVE_UNDERS
	    if (pChild->saveUnder && pChild->viewable)
		deltaSaveUndersViewable--;
#endif
d964 1
d1012 1
a1012 1
    WindowPtr pChild, pLayerWin;
d1071 1
a1071 1
		rc = dixLookupResource((pointer *)&pPixmap, pixID, RT_PIXMAP,
d1131 1
a1131 1
	    rc = dixLookupResource((pointer *)&pPixmap, pixID, RT_PIXMAP,
a1232 39
#ifdef DO_SAVE_UNDERS
	    if (pWin->parent && (pWin->saveUnder != val) && (pWin->viewable) &&
		DO_SAVE_UNDERS(pWin))
	    {
		/*
		 * Re-check all siblings and inferiors for obscurity or
		 * exposition (hee hee).
		 */
		if (pWin->saveUnder)
		    deltaSaveUndersViewable--;
		else
		    deltaSaveUndersViewable++;
		pWin->saveUnder = val;

		if (pWin->firstChild)
		{
                    pLayerWin = (*pScreen->GetLayerWindow)(pWin);
                   if ((*pScreen->ChangeSaveUnder)(pLayerWin->parent, pWin->nextSib))
                       (*pScreen->PostChangeSaveUnder)(pLayerWin->parent,
                                                       pWin->nextSib);
               }
               else
               {
                   if ((*pScreen->ChangeSaveUnder)(pWin, pWin->nextSib))
                       (*pScreen->PostChangeSaveUnder)(pWin,
                                                       pWin->nextSib);
               }                                   
	    }
	    else
	    {
		/*  If we're changing the saveUnder attribute of the root 
		 *  window, all we do is set pWin->saveUnder so that
		 *  GetWindowAttributes returns the right value.  We don't
		 *  do the "normal" save-under processing (as above).
		 *  Hope that doesn't cause any problems.
		 */
		pWin->saveUnder = val;
	    }
#else
a1233 1
#endif /* DO_SAVE_UNDERS */
a1278 16
#ifdef XAPPGROUP
		Colormap ag_colormap;
		ClientPtr win_owner;

		/*
		 * win_owner == client for CreateWindow, other clients
		 * can ChangeWindowAttributes
		 */
		win_owner = clients[CLIENT_ID(pWin->drawable.id)];

		if ( win_owner && win_owner->appgroup &&
		    !pWin->parent->parent &&
		    (ag_colormap = XagDefaultColormap (win_owner)))
		    cmap = ag_colormap;
		else
#endif
d1293 1
a1293 1
	    rc = dixLookupResource((pointer *)&pCmap, cmap, RT_COLORMAP,
d1369 1
a1369 1
		rc = dixLookupResource((pointer *)&pCursor, cursorID,
d1516 1
a1516 1
_X_EXPORT WindowPtr
a1610 1
#ifdef SHAPE
a1622 1
#endif
d1626 1
a1626 1
_X_EXPORT void
a1649 1
#ifdef SHAPE
a1664 1
#endif
d1667 1
a1667 1
_X_EXPORT void
a1694 1
#ifdef SHAPE
a1707 1
#endif
d1771 1
a1771 1
_X_EXPORT void
a1897 1
#ifdef SHAPE
a1941 1
#endif
a1958 1
#ifdef SHAPE
a1959 1
#endif
a1981 1
#ifdef SHAPE
a1982 1
#endif
a2134 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a2148 6
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	{
	    dosave = (*pScreen->ChangeSaveUnder)(pLayerWin, pFirstChange);
	}
#endif /* DO_SAVE_UNDERS */
a2153 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pLayerWin, pFirstChange);
#endif /* DO_SAVE_UNDERS */
a2181 4
#ifdef XAPPGROUP
    ClientPtr win_owner;
    ClientPtr ag_leader = NULL;
#endif
a2276 4
#ifdef XAPPGROUP
    win_owner = clients[CLIENT_ID(pWin->drawable.id)];
    ag_leader = XagLeader (win_owner);
#endif
a2279 4
#ifdef XAPPGROUP
	|| (win_owner->appgroup && ag_leader && 
	    XagIsControlledRoot (client, pParent))
#endif
a2303 10
#ifdef XAPPGROUP
	/* make sure if the ag_leader maps the window it goes to the wm */
	if (ag_leader && ag_leader != client && 
	    XagIsControlledRoot (client, pParent)) {
	    event.u.configureRequest.parent = XagId (win_owner);
	    (void) TryClientEvents (ag_leader, &event, 1,
				    NoEventMask, NoEventMask, NullGrab);
	    return Success;
	}
#endif
a2603 4
#ifdef DO_SAVE_UNDERS
	    if (pChild->saveUnder)
		deltaSaveUndersViewable++;
#endif
a2657 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a2672 4
#ifdef XAPPGROUP
	ClientPtr win_owner = clients[CLIENT_ID(pWin->drawable.id)];
	ClientPtr ag_leader = XagLeader (win_owner);
#endif
a2675 4
#ifdef XAPPGROUP
	    || (win_owner->appgroup && ag_leader &&
		XagIsControlledRoot (client, pParent))
#endif
a2679 10
#ifdef XAPPGROUP
	    /* make sure if the ag_leader maps the window it goes to the wm */
	    if (ag_leader && ag_leader != client &&
		XagIsControlledRoot (client, pParent)) {
		event.u.mapRequest.parent = XagId (win_owner);
		(void) TryClientEvents (ag_leader, &event, 1,
					NoEventMask, NoEventMask, NullGrab);
		return Success;
	    }
#endif
a2702 6
#ifdef DO_SAVE_UNDERS
	    if (DO_SAVE_UNDERS(pWin))
	    {
		dosave = (*pScreen->ChangeSaveUnder)(pLayerWin, pWin->nextSib);
	    }
#endif /* DO_SAVE_UNDERS */
a2707 4
#ifdef DO_SAVE_UNDERS
	    if (dosave)
		(*pScreen->PostChangeSaveUnder)(pLayerWin, pWin->nextSib);
#endif /* DO_SAVE_UNDERS */
a2746 3
#ifdef DO_SAVE_UNDERS
    WindowPtr	pFirstSaveUndered = NullWindow;
#endif
a2751 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a2790 6
#ifdef DO_SAVE_UNDERS
		    if (DO_SAVE_UNDERS(pWin))
		    {
			dosave = TRUE;
		    }
#endif /* DO_SAVE_UNDERS */
a2806 24
#ifdef DO_SAVE_UNDERS
	    if (pLayerWin->parent != pParent)
	    {
		if (dosave || (DO_SAVE_UNDERS(pLayerWin)))
		{
		    dosave = (*pScreen->ChangeSaveUnder)(pLayerWin,
							 pLayerWin);
		}
	    }
	    else if (dosave)
	    {
		dosave = FALSE;
		for (pWin = pParent->firstChild; pWin; pWin = pWin->nextSib)
		{
		    if (DO_SAVE_UNDERS(pWin))
		    {
			dosave |= (*pScreen->ChangeSaveUnder)(pWin,
							      pWin->nextSib);
			if (dosave && !pFirstSaveUndered)
			    pFirstSaveUndered = pWin;
		    }
		}
            }
#endif /* DO_SAVE_UNDERS */
a2809 5
#ifdef DO_SAVE_UNDERS
        if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pLayerWin,
					    pFirstSaveUndered->nextSib);
#endif /* DO_SAVE_UNDERS */
a2848 4
#ifdef DO_SAVE_UNDERS
		if (pChild->saveUnder)
		    deltaSaveUndersViewable--;
#endif
a2908 10
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	{
	    if ( (*pScreen->ChangeSaveUnder)(pLayerWin, pWin->nextSib) )
	    {
		(*pScreen->PostChangeSaveUnder)(pLayerWin, pWin->nextSib);
	    }
	}
	pWin->DIXsaveUnder = FALSE;
#endif /* DO_SAVE_UNDERS */
a2963 3
#ifdef DO_SAVE_UNDERS
		pChild->DIXsaveUnder = FALSE;
#endif /* DO_SAVE_UNDERS */
a2992 7
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	{
	    if ( (*pScreen->ChangeSaveUnder)(pLayerWin, pLayerWin))
		(*pScreen->PostChangeSaveUnder)(pLayerWin, pLayerWin);
	}
#endif /* DO_SAVE_UNDERS */
d3024 5
d3037 1
a3037 1
	    if (SaveSetRemap (client->saveSet[j]))
d3087 1
a3087 1
_X_EXPORT void
d3094 2
a3171 2
	UpdateCurrentTimeIf();
	lastDeviceEventTime = currentTime;
a3446 1
#ifdef SHAPE
a3452 2
#endif
#ifdef XINPUT
d3455 17
a3471 1
#endif
a3508 1
#ifdef SHAPE
a3511 2
#endif
#ifdef XINPUT
d3513 20
a3532 1
#endif
d3547 216
@


1.2
log
@Fix for CVE-2007-3069 from X.Org git repository:

    Don't break grab and focus state for a window when redirecting it.

    Composite uses an unmap/map cycle to trigger backing pixmap allocation
    and cliprect recomputation when a window is redirected or unredirected.
    To avoid protocol visible side effects, map and unmap events are
    disabled temporarily.  However, when a window is unmapped it is also
    removed from grabs and loses focus, but these state changes are not
    disabled.

    This change supresses the unmap side effects during the composite
    unmap/map cycle and fixes a bug where a compositing window manager
     would cause the screensaver to lose its grab when it unredirects the
    fullscreen lock window.
@
text
@d129 1
a148 7
#if 0
extern void DeleteWindowFromAnyEvents();
extern Mask EventMaskForClient();
extern void WindowHasNewCursor();
extern void RecalculateDeliverableEvents();
#endif

a171 1

a292 1
#ifdef COMPOSITE
d294 1
a294 1
#endif
d308 1
a308 1
						    pScreen->rootDepth);
a339 35
WindowPtr
AllocateWindow(ScreenPtr pScreen)
{
    WindowPtr pWin;
    char *ptr;
    DevUnion *ppriv;
    unsigned *sizes;
    unsigned size;
    int i;

    pWin = (WindowPtr)xalloc(pScreen->totalWindowSize);
    if (pWin)
    {
	ppriv = (DevUnion *)(pWin + 1);
	pWin->devPrivates = ppriv;
	sizes = pScreen->WindowPrivateSizes;
	ptr = (char *)(ppriv + pScreen->WindowPrivateLen);
	for (i = pScreen->WindowPrivateLen; --i >= 0; ppriv++, sizes++)
	{
	    if ( (size = *sizes) )
	    {
		ppriv->ptr = (pointer)ptr;
		ptr += size;
	    }
	    else
		ppriv->ptr = (pointer)NULL;
	}
#if _XSERVER64
	pWin->drawable.pad0 = 0;
        pWin->drawable.pad1 = 0;
#endif
    }
    return pWin;
}

d352 1
a352 1
    pWin = AllocateWindow(pScreen);
d365 1
d429 6
a491 2
    XaceHook(XACE_WINDOW_INIT, serverClient, pWin);

d656 1
a656 1
    pWin = AllocateWindow(pScreen);
d663 1
d697 1
a697 2
    /*  can't let untrusted clients have background None windows;
     *  they make it too easy to steal window contents
d699 5
a703 5
    if (XaceHook(XACE_BACKGRND_ACCESS, client, pWin))
	pWin->backgroundState = None;
    else {
	pWin->backgroundState = BackgroundPixel;
	pWin->background.pixel = 0;
d706 3
a726 2
    XaceHook(XACE_WINDOW_INIT, client, pWin);

d887 1
d937 1
d942 1
a942 1
void
d954 6
a959 1
    while (pWin->lastChild)
d961 2
a978 1
    Mask index2;
d984 1
a984 1
    WindowPtr pChild;
d988 1
a988 1
    int result;
d990 1
a990 2
    Mask vmaskCopy = 0;
    Mask tmask;
d992 1
a992 4
    int error;
    Bool checkOptional = FALSE;
    Bool borderRelative = FALSE;
    WindowPtr pLayerWin;
d1014 7
a1020 11
		/*  can't let untrusted clients have background None windows */
		if (XaceHook(XACE_BACKGRND_ACCESS, client, pWin)) {
		    if (pWin->backgroundState == BackgroundPixmap)
			(*pScreen->DestroyPixmap)(pWin->background.pixmap);
		    if (!pWin->parent)
			MakeRootTile(pWin);
		    else
			pWin->backgroundState = None;
		} else {
		    /* didn't change the backgrnd to None, so don't tell ddx */
		    index2 = 0; 
d1043 3
a1045 3
		pPixmap = (PixmapPtr)SecurityLookupIDByType(client, pixID,
						RT_PIXMAP, DixReadAccess);
		if (pPixmap != (PixmapPtr) NULL)
d1061 1
a1061 1
		    error = BadPixmap;
d1090 5
a1094 5
		if (pWin->borderIsPixel == FALSE)
		    (*pScreen->DestroyPixmap)(pWin->border.pixmap);
		pWin->border = pWin->parent->border;
		if ((pWin->borderIsPixel = pWin->parent->borderIsPixel) == TRUE)
		{
d1096 1
d1100 1
a1100 1
		    pWin->parent->border.pixmap->refcnt++;
d1103 6
a1108 5
	    else
	    {	
		pPixmap = (PixmapPtr)SecurityLookupIDByType(client, pixID,
					RT_PIXMAP, DixReadAccess);
		if (pPixmap)
d1110 1
a1110 16
		    if	((pPixmap->drawable.depth != pWin->drawable.depth) ||
			 (pPixmap->drawable.pScreen != pScreen))
		    {
			error = BadMatch;
			goto PatchUp;
		    }
		    if (pWin->borderIsPixel == FALSE)
			(*pScreen->DestroyPixmap)(pWin->border.pixmap);
		    pWin->borderIsPixel = FALSE;
		    pWin->border.pixmap = pPixmap;
		    pPixmap->refcnt++;
		}
		else
		{
		    error = BadPixmap;
		    client->errorValue = pixID;
d1113 11
d1248 2
a1249 2
	    result = EventSelectForWindow(pWin, client, (Mask )*pVlist);
	    if (result)
d1251 1
a1251 1
		error = result;
d1257 1
a1257 1
	    result = EventSuppressForWindow(pWin, client, (Mask )*pVlist,
d1259 1
a1259 1
	    if (result)
d1261 1
a1261 1
		error = result;
d1275 9
d1321 3
a1323 3
	    pCmap = (ColormapPtr)SecurityLookupIDByType(client, cmap,
					      RT_COLORMAP, DixReadAccess);
	    if (!pCmap)
d1325 1
a1325 1
		error = BadColor;
d1397 3
a1399 3
		pCursor = (CursorPtr)SecurityLookupIDByType(client, cursorID,
						RT_CURSOR, DixReadAccess);
		if (!pCursor)
d1401 1
a1401 1
		    error = BadCursor;
d1496 1
a1496 1
	(*pWin->drawable.pScreen->PaintWindowBorder)(pWin, &exposed, PW_BORDER);
d2158 1
a2158 1
	ErrorF("Internal error in ConfigureWindow, smode == %d\n",smode );
d2234 1
a2234 1
    int action, smode = Above;
d2295 2
a2296 3
	    pSib = (WindowPtr )SecurityLookupIDByType(client, sibwid,
						RT_WINDOW, DixReadAccess);
	    if (!pSib)
d2299 1
a2299 1
		return(BadWindow);
d2746 3
a2748 2
    if (!XaceHook(XACE_MAP_ACCESS, client, pWin))
	 return Success;
a3004 3
		if (pChild->backStorage)
		    (*pChild->drawable.pScreen->SaveDoomedAreas)(
					    pChild, &pChild->clipList, 0, 0);
a3131 3
		if (pChild->backStorage)
		    (*pScreen->SaveDoomedAreas)(
					    pChild, &pChild->clipList, 0, 0);
d3333 2
a3334 2
_X_EXPORT void
SaveScreens(int on, int mode)
d3336 1
a3336 3
    int i;
    int what;
    int type;
d3355 7
d3449 7
d3517 2
a3518 1
	cursor = AllocCursor(srcbits, mskbits, &cm, 0, 0, 0, 0, 0, 0);
@


1.1
log
@Initial revision
@
text
@a128 1
#ifdef XACE
a129 1
#endif
d188 1
a188 1
int
d198 1
a198 1
	ErrorF( "%x\n", p1->drawable.id);
d205 2
a206 1
PrintWindowTree()
d223 1
a223 1
TraverseTree(register WindowPtr pWin, VisitWindowProcPtr func, pointer data)
d225 2
a226 2
    register int result;
    register WindowPtr pChild;
d272 1
a272 1
SetWindowToDefaults(register WindowPtr pWin)
a299 4
#ifdef NEED_DBE_BUF_BITS
    pWin->srcBuffer = DBE_FRONT_BUFFER;
    pWin->dstBuffer = DBE_FRONT_BUFFER;
#endif
d301 1
a301 1
    pWin->redirectDraw = 0;
d312 2
a313 2
    register unsigned char *from, *to;
    register int i, j;
d352 5
a356 5
    register char *ptr;
    register DevUnion *ppriv;
    register unsigned *sizes;
    register unsigned size;
    register int i;
a527 1
#ifdef XACE
a528 1
#endif
d538 4
a541 4
void
ClippedRegionFromBox(register WindowPtr pWin, RegionPtr Rgn,
                     register int x, register int y,
                     register int w, register int h)
d543 1
a543 1
    ScreenPtr pScreen = pWin->drawable.pScreen;
d546 2
d578 1
a578 1
RealChildHead(register WindowPtr pWin)
d598 2
a599 2
CreateWindow(Window wid, register WindowPtr pParent, int x, int y, unsigned w,
             unsigned h, unsigned bw, unsigned class, register Mask vmask, XID *vlist,
d602 1
a602 1
    register WindowPtr pWin;
d604 1
a604 1
    register ScreenPtr pScreen;
d610 1
a610 1
    register WindowOptPtr ancwopt;
d733 1
a733 1
#ifdef XACE
d737 3
a739 2
    if (!XaceHook(XACE_BACKGRND_ACCESS, client, pWin))
    {
a742 3
    else
#endif
    pWin->backgroundState = None;
a761 1
#ifdef XACE
a762 1
#endif
d835 21
a855 1
FreeWindowResources(register WindowPtr pWin)
d857 1
a857 1
    register ScreenPtr pScreen = pWin->drawable.pScreen;
d888 1
a888 1
    register WindowPtr pChild, pSib, pParent;
d945 2
a946 2
    register WindowPtr pParent;
    register WindowPtr pWin = (WindowPtr)value;
d978 1
a978 1
DestroySubwindows(register WindowPtr pWin, ClientPtr client)
d1005 1
a1005 1
ChangeWindowAttributes(register WindowPtr pWin, Mask vmask, XID *vlist, ClientPtr client)
d1007 2
a1008 2
    register Mask index2;
    register XID *pVlist;
d1018 1
a1018 1
    register ScreenPtr pScreen;
d1020 1
a1020 1
    register Mask tmask;
a1046 1
#ifdef XACE
d1048 9
a1056 13
		if (XaceHook(XACE_BACKGRND_ACCESS, client, pWin))
		{
#endif
		if (pWin->backgroundState == BackgroundPixmap)
		    (*pScreen->DestroyPixmap)(pWin->background.pixmap);
		if (!pWin->parent)
		    MakeRootTile(pWin);
		else
		    pWin->backgroundState = None;
#ifdef XACE
		}
		else
		{ /* didn't change the background to None, so don't tell ddx */
a1058 1
#endif
d1081 1
a1081 1
						RT_PIXMAP, SecurityReadAccess);
d1142 1
a1142 1
					RT_PIXMAP, SecurityReadAccess);
d1352 1
a1352 1
					      RT_COLORMAP, SecurityReadAccess);
d1428 1
a1428 1
						RT_CURSOR, SecurityReadAccess);
d1539 1
a1539 1
GetWindowAttributes(register WindowPtr pWin, ClientPtr client, xGetWindowAttributesReply *wa)
d1575 1
a1575 1
MoveWindowInStack(register WindowPtr pWin, register WindowPtr pNextSib)
d1577 1
a1577 1
    register WindowPtr pParent = pWin->parent;
d1659 1
a1659 1
CreateUnclippedWinSize (register WindowPtr pWin)
d1671 2
a1672 1
	ScreenPtr pScreen = pWin->drawable.pScreen;
d1687 1
a1687 1
SetWinSize (register WindowPtr pWin)
d1690 1
a1690 1
    if (pWin->redirectDraw)
d1694 4
d1712 2
a1713 1
	ScreenPtr pScreen = pWin->drawable.pScreen;
d1730 1
a1730 1
SetBorderSize (register WindowPtr pWin)
d1737 1
a1737 1
	if (pWin->redirectDraw)
d1741 4
d1759 2
a1760 1
	    ScreenPtr pScreen = pWin->drawable.pScreen;
d1786 1
a1786 1
GravityTranslate (register int x, register int y, int oldx, int oldy,
d1788 1
a1788 1
                  register int *destx, register int *desty)
d1836 1
a1836 1
ResizeChildrenWinSize(register WindowPtr pWin, int dx, int dy, int dw, int dh)
d1838 2
a1839 2
    register ScreenPtr pScreen;
    register WindowPtr pSib, pChild;
d1931 2
a1932 2
    register WindowPtr pMe,
    register WindowPtr pSib)
d1934 1
a1934 1
    register WindowPtr pWin;
d1950 2
a1951 2
    register WindowPtr pWin,
    register BoxPtr pBox)
d1967 1
a1967 1
    register WindowPtr	pWin,
d1971 2
a1972 1
    ScreenPtr   pScreen = pWin->drawable.pScreen;
d1993 1
a1993 1
    register ScreenPtr	pScreen;
d2013 1
a2013 1
    register BoxPtr box)
d2015 1
a2015 1
    register WindowPtr pSib;
d2017 1
a2017 1
    register BoxPtr sbox;
d2038 1
a2038 1
    register BoxPtr box)
d2040 1
a2040 1
    register WindowPtr pSib;
d2042 1
a2042 1
    register BoxPtr sbox;
d2090 2
a2091 2
    register WindowPtr pWin,
    register WindowPtr pSib,
d2099 1
a2099 1
    register ScreenPtr pScreen;
d2196 2
a2197 2
    register WindowPtr pWin,
    register WindowPtr pSib,
d2249 1
a2249 1
ConfigureWindow(register WindowPtr pWin, register Mask mask, XID *vlist, ClientPtr client)
d2255 2
a2256 2
    register WindowPtr pSib = NullWindow;
    register WindowPtr pParent = pWin->parent;
d2259 1
a2259 1
    register XID *pVlist;
d2326 1
a2326 1
						RT_WINDOW, SecurityReadAccess);
d2536 1
a2536 1
    register WindowPtr pWin, pHead, pFirst;
d2606 1
a2606 1
ReparentWindow(register WindowPtr pWin, register WindowPtr pParent,
d2613 1
a2613 1
    register ScreenPtr pScreen;
d2700 1
a2700 1
    register WindowPtr pChild;
d2730 24
d2763 1
a2763 1
MapWindow(register WindowPtr pWin, ClientPtr client)
d2765 1
a2765 1
    register ScreenPtr pScreen;
d2767 1
a2767 1
    register WindowPtr pParent;
a2775 1
#ifdef XACE
a2778 1
#endif	
d2883 1
a2883 1
MapSubwindows(register WindowPtr pParent, ClientPtr client)
d2885 2
a2886 2
    register WindowPtr	pWin;
    WindowPtr		pFirstMapped = NullWindow;
d2888 1
a2888 1
    WindowPtr		pFirstSaveUndered = NullWindow;
d2890 5
a2894 5
    register ScreenPtr	pScreen;
    register Mask	parentRedirect;
    register Mask	parentNotify;
    xEvent		event;
    Bool		anyMarked;
d3003 1
a3003 1
    register WindowPtr pChild;
d3026 2
a3027 1
	    DeleteWindowFromAnyEvents(pChild, FALSE);
d3063 1
a3063 1
UnmapWindow(register WindowPtr pWin, Bool fromConfigure)
d3065 1
a3065 1
    register WindowPtr pParent;
d3122 1
a3122 1
UnmapSubwindows(register WindowPtr pWin)
d3124 1
a3124 1
    register WindowPtr pChild, pHead;
d3213 1
a3213 1
HandleSaveSet(register ClientPtr client)
d3215 2
a3216 2
    register WindowPtr pParent, pWin;
    register int j;
a3254 15
 *  \param x,y  in root
 *  \param box  "return" value
 */
Bool
VisibleBoundingBoxFromPoint(register WindowPtr pWin, int x, int y, BoxPtr box)
{
    if (!pWin->realized)
	return (FALSE);
    if (POINT_IN_REGION(pWin->drawable.pScreen, &pWin->clipList, x, y, box))
	return(TRUE);
    return(FALSE);
}

/**
 *
d3258 1
a3258 1
PointInWindowIsVisible(register WindowPtr pWin, int x, int y)
d3277 1
a3277 1
NotClippedByChildren(register WindowPtr pWin)
d3279 1
a3279 1
    register ScreenPtr pScreen;
a3360 24
static WindowPtr windowDisableMapUnmapEvents;

void
DisableMapUnmapEvents(WindowPtr pWin)
{
    assert (windowDisableMapUnmapEvents == NULL);
    
    windowDisableMapUnmapEvents = pWin;
}

void
EnableMapUnmapEvents(WindowPtr pWin)
{
    assert (windowDisableMapUnmapEvents != NULL);

    windowDisableMapUnmapEvents = NULL;
}

Bool
MapUnmapEventsEnabled(WindowPtr pWin)
{
    return pWin != windowDisableMapUnmapEvents;
}

d3601 1
a3601 1
FindWindowWithOptional (register WindowPtr w)
d3618 1
a3618 1
CheckWindowOptionalNeed (register WindowPtr w)
d3620 2
a3621 2
    register WindowOptPtr optional;
    register WindowOptPtr parentOptional;
d3672 1
a3672 1
MakeWindowOptional (register WindowPtr pWin)
d3674 2
a3675 2
    register WindowOptPtr optional;
    register WindowOptPtr parentOptional;
a3710 35
}

void
DisposeWindowOptional (register WindowPtr pWin)
{
    if (!pWin->optional)
	return;
    /*
     * everything is peachy.  Delete the optional record
     * and clean up
     */
    /*
     * TOG changed this code to:
     *
     *	    if (pWin->cursorIsNone == FALSE)
     *		FreeCursor (pWin->optional->cursor, (Cursor)0);
     *	    pWin->cursorIsNone = TRUE;
     *
     * This is blatently wrong; windows without optionals can have
     * two different cursor values, either None or sharing their
     * parents cursor.  This difference is controlled by the
     * cursorIsNone value; when TRUE, the window has no cursor,
     * when false, it shares its cursor with its parent; TOG
     * made it impossible for a window to have a cursor without
     * an optional record.
     */
    if (pWin->optional->cursor)
    {
	FreeCursor (pWin->optional->cursor, (Cursor)0);
	pWin->cursorIsNone = FALSE;
    }
    else
	pWin->cursorIsNone = TRUE;
    xfree (pWin->optional);
    pWin->optional = NULL;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d129 1
d131 1
d190 1
a190 1
static void
d200 1
a200 1
	ErrorF( "%lx\n", p1->drawable.id);
d207 1
a207 2
static void
PrintWindowTree(void)
d224 1
a224 1
TraverseTree(WindowPtr pWin, VisitWindowProcPtr func, pointer data)
d226 2
a227 2
    int result;
    WindowPtr pChild;
d273 1
a273 1
SetWindowToDefaults(WindowPtr pWin)
d301 4
d306 1
a306 1
    pWin->redirectDraw = RedirectDrawNone;
d317 2
a318 2
    unsigned char *from, *to;
    int i, j;
d357 5
a361 5
    char *ptr;
    DevUnion *ppriv;
    unsigned *sizes;
    unsigned size;
    int i;
d533 1
d535 1
d545 4
a548 4
static void
ClippedRegionFromBox(WindowPtr pWin, RegionPtr Rgn,
                     int x, int y,
                     int w, int h)
d550 1
a550 1
    ScreenPtr pScreen;
a552 2
    pScreen = pWin->drawable.pScreen;

d583 1
a583 1
RealChildHead(WindowPtr pWin)
d603 2
a604 2
CreateWindow(Window wid, WindowPtr pParent, int x, int y, unsigned w,
             unsigned h, unsigned bw, unsigned class, Mask vmask, XID *vlist,
d607 1
a607 1
    WindowPtr pWin;
d609 1
a609 1
    ScreenPtr pScreen;
d615 1
a615 1
    WindowOptPtr ancwopt;
d738 1
a738 1

d742 2
a743 3
    if (XaceHook(XACE_BACKGRND_ACCESS, client, pWin))
	pWin->backgroundState = None;
    else {
d747 3
d769 1
d771 1
d844 1
a844 21
DisposeWindowOptional (WindowPtr pWin)
{
    if (!pWin->optional)
	return;
    /*
     * everything is peachy.  Delete the optional record
     * and clean up
     */
    if (pWin->optional->cursor)
    {
	FreeCursor (pWin->optional->cursor, (Cursor)0);
	pWin->cursorIsNone = FALSE;
    }
    else
	pWin->cursorIsNone = TRUE;
    xfree (pWin->optional);
    pWin->optional = NULL;
}

static void
FreeWindowResources(WindowPtr pWin)
d846 1
a846 1
    ScreenPtr pScreen = pWin->drawable.pScreen;
d877 1
a877 1
    WindowPtr pChild, pSib, pParent;
d934 2
a935 2
    WindowPtr pParent;
    WindowPtr pWin = (WindowPtr)value;
d967 1
a967 1
DestroySubwindows(WindowPtr pWin, ClientPtr client)
d994 1
a994 1
ChangeWindowAttributes(WindowPtr pWin, Mask vmask, XID *vlist, ClientPtr client)
d996 2
a997 2
    Mask index2;
    XID *pVlist;
d1007 1
a1007 1
    ScreenPtr pScreen;
d1009 1
a1009 1
    Mask tmask;
d1036 1
d1038 13
a1050 9
		if (XaceHook(XACE_BACKGRND_ACCESS, client, pWin)) {
		    if (pWin->backgroundState == BackgroundPixmap)
			(*pScreen->DestroyPixmap)(pWin->background.pixmap);
		    if (!pWin->parent)
			MakeRootTile(pWin);
		    else
			pWin->backgroundState = None;
		} else {
		    /* didn't change the backgrnd to None, so don't tell ddx */
d1053 1
d1076 1
a1076 1
						RT_PIXMAP, DixReadAccess);
d1137 1
a1137 1
					RT_PIXMAP, DixReadAccess);
d1347 1
a1347 1
					      RT_COLORMAP, DixReadAccess);
d1423 1
a1423 1
						RT_CURSOR, DixReadAccess);
d1534 1
a1534 1
GetWindowAttributes(WindowPtr pWin, ClientPtr client, xGetWindowAttributesReply *wa)
d1570 1
a1570 1
MoveWindowInStack(WindowPtr pWin, WindowPtr pNextSib)
d1572 1
a1572 1
    WindowPtr pParent = pWin->parent;
d1654 1
a1654 1
CreateUnclippedWinSize (WindowPtr pWin)
d1666 1
a1666 2
	ScreenPtr pScreen;
        pScreen = pWin->drawable.pScreen;
d1681 1
a1681 1
SetWinSize (WindowPtr pWin)
d1684 1
a1684 1
    if (pWin->redirectDraw != RedirectDrawNone)
a1687 4
	/*
	 * Redirected clients get clip list equal to their
	 * own geometry, not clipped to their parent
	 */
d1702 1
a1702 2
	ScreenPtr pScreen;
        pScreen = pWin->drawable.pScreen;
d1719 1
a1719 1
SetBorderSize (WindowPtr pWin)
d1726 1
a1726 1
	if (pWin->redirectDraw != RedirectDrawNone)
a1729 4
	    /*
	     * Redirected clients get clip list equal to their
	     * own geometry, not clipped to their parent
	     */
d1744 1
a1744 2
	    ScreenPtr pScreen;
            pScreen = pWin->drawable.pScreen;
d1770 1
a1770 1
GravityTranslate (int x, int y, int oldx, int oldy,
d1772 1
a1772 1
                  int *destx, int *desty)
d1820 1
a1820 1
ResizeChildrenWinSize(WindowPtr pWin, int dx, int dy, int dw, int dh)
d1822 2
a1823 2
    ScreenPtr pScreen;
    WindowPtr pSib, pChild;
d1915 2
a1916 2
    WindowPtr pMe,
    WindowPtr pSib)
d1918 1
a1918 1
    WindowPtr pWin;
d1934 2
a1935 2
    WindowPtr pWin,
    BoxPtr pBox)
d1951 1
a1951 1
    WindowPtr	pWin,
d1955 1
a1955 2
    ScreenPtr   pScreen;
    pScreen = pWin->drawable.pScreen;
d1976 1
a1976 1
    ScreenPtr	pScreen;
d1996 1
a1996 1
    BoxPtr box)
d1998 1
a1998 1
    WindowPtr pSib;
d2000 1
a2000 1
    BoxPtr sbox;
d2021 1
a2021 1
    BoxPtr box)
d2023 1
a2023 1
    WindowPtr pSib;
d2025 1
a2025 1
    BoxPtr sbox;
d2073 2
a2074 2
    WindowPtr pWin,
    WindowPtr pSib,
d2082 1
a2082 1
    ScreenPtr pScreen;
d2179 2
a2180 2
    WindowPtr pWin,
    WindowPtr pSib,
d2232 1
a2232 1
ConfigureWindow(WindowPtr pWin, Mask mask, XID *vlist, ClientPtr client)
d2238 2
a2239 2
    WindowPtr pSib = NullWindow;
    WindowPtr pParent = pWin->parent;
d2242 1
a2242 1
    XID *pVlist;
d2309 1
a2309 1
						RT_WINDOW, DixReadAccess);
d2519 1
a2519 1
    WindowPtr pWin, pHead, pFirst;
d2589 1
a2589 1
ReparentWindow(WindowPtr pWin, WindowPtr pParent,
d2596 1
a2596 1
    ScreenPtr pScreen;
d2683 1
a2683 1
    WindowPtr pChild;
a2712 24
static WindowPtr windowDisableMapUnmapEvents;

void
DisableMapUnmapEvents(WindowPtr pWin)
{
    assert (windowDisableMapUnmapEvents == NULL);
    
    windowDisableMapUnmapEvents = pWin;
}

void
EnableMapUnmapEvents(WindowPtr pWin)
{
    assert (windowDisableMapUnmapEvents != NULL);

    windowDisableMapUnmapEvents = NULL;
}

static Bool
MapUnmapEventsEnabled(WindowPtr pWin)
{
    return pWin != windowDisableMapUnmapEvents;
}

d2722 1
a2722 1
MapWindow(WindowPtr pWin, ClientPtr client)
d2724 1
a2724 1
    ScreenPtr pScreen;
d2726 1
a2726 1
    WindowPtr pParent;
d2735 1
d2739 1
d2844 1
a2844 1
MapSubwindows(WindowPtr pParent, ClientPtr client)
d2846 2
a2847 2
    WindowPtr	pWin;
    WindowPtr	pFirstMapped = NullWindow;
d2849 1
a2849 1
    WindowPtr	pFirstSaveUndered = NullWindow;
d2851 5
a2855 5
    ScreenPtr	pScreen;
    Mask	parentRedirect;
    Mask	parentNotify;
    xEvent	event;
    Bool	anyMarked;
d2964 1
a2964 1
    WindowPtr pChild;
d3023 1
a3023 1
UnmapWindow(WindowPtr pWin, Bool fromConfigure)
d3025 1
a3025 1
    WindowPtr pParent;
d3082 1
a3082 1
UnmapSubwindows(WindowPtr pWin)
d3084 1
a3084 1
    WindowPtr pChild, pHead;
d3173 1
a3173 1
HandleSaveSet(ClientPtr client)
d3175 2
a3176 2
    WindowPtr pParent, pWin;
    int j;
d3215 15
d3233 1
a3233 1
PointInWindowIsVisible(WindowPtr pWin, int x, int y)
d3252 1
a3252 1
NotClippedByChildren(WindowPtr pWin)
d3254 1
a3254 1
    ScreenPtr pScreen;
d3336 24
d3600 1
a3600 1
FindWindowWithOptional (WindowPtr w)
d3617 1
a3617 1
CheckWindowOptionalNeed (WindowPtr w)
d3619 2
a3620 2
    WindowOptPtr optional;
    WindowOptPtr parentOptional;
d3671 1
a3671 1
MakeWindowOptional (WindowPtr pWin)
d3673 2
a3674 2
    WindowOptPtr optional;
    WindowOptPtr parentOptional;
d3710 35
@

