head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	7pAEtF6Y5EgemkuY;

1.10
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.24;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/*

Copyright 1993, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/
/*
 * Copyright © 2010, Keith Packard
 * Copyright © 2010, Jamey Sharp
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stddef.h>
#include "windowstr.h"
#include "resource.h"
#include "privates.h"
#include "gcstruct.h"
#include "cursorstr.h"
#include "colormapst.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include "extnsionst.h"
#include "inputstr.h"

static DevPrivateSetRec global_keys[PRIVATE_LAST];

static const Bool xselinux_private[PRIVATE_LAST] = {
    [PRIVATE_SCREEN] = TRUE,
    [PRIVATE_CLIENT] = TRUE,
    [PRIVATE_WINDOW] = TRUE,
    [PRIVATE_PIXMAP] = TRUE,
    [PRIVATE_GC] = TRUE,
    [PRIVATE_CURSOR] = TRUE,
    [PRIVATE_COLORMAP] = TRUE,
    [PRIVATE_DEVICE] = TRUE,
    [PRIVATE_EXTENSION] = TRUE,
    [PRIVATE_SELECTION] = TRUE,
    [PRIVATE_PROPERTY] = TRUE,
    [PRIVATE_PICTURE] = TRUE,
    [PRIVATE_GLYPHSET] = TRUE,
};

static const char *key_names[PRIVATE_LAST] = {
    /* XSELinux uses the same private keys for numerous objects */
    [PRIVATE_XSELINUX] = "XSELINUX",

    /* Otherwise, you get a private in just the requested structure
     */
    /* These can have objects created before all of the keys are registered */
    [PRIVATE_SCREEN] = "SCREEN",
    [PRIVATE_EXTENSION] = "EXTENSION",
    [PRIVATE_COLORMAP] = "COLORMAP",
    [PRIVATE_DEVICE] = "DEVICE",

    /* These cannot have any objects before all relevant keys are registered */
    [PRIVATE_CLIENT] = "CLIENT",
    [PRIVATE_PROPERTY] = "PROPERTY",
    [PRIVATE_SELECTION] = "SELECTION",
    [PRIVATE_WINDOW] = "WINDOW",
    [PRIVATE_PIXMAP] = "PIXMAP",
    [PRIVATE_GC] = "GC",
    [PRIVATE_CURSOR] = "CURSOR",
    [PRIVATE_CURSOR_BITS] = "CURSOR_BITS",

    /* extension privates */
    [PRIVATE_DAMAGE] = "DAMAGE",
    [PRIVATE_GLYPH] = "GLYPH",
    [PRIVATE_GLYPHSET] = "GLYPHSET",
    [PRIVATE_PICTURE] = "PICTURE",
    [PRIVATE_SYNC_FENCE] = "SYNC_FENCE",
};

static const Bool screen_specific_private[PRIVATE_LAST] = {
    [PRIVATE_SCREEN] = FALSE,
    [PRIVATE_CLIENT] = FALSE,
    [PRIVATE_WINDOW] = TRUE,
    [PRIVATE_PIXMAP] = TRUE,
    [PRIVATE_GC] = TRUE,
    [PRIVATE_CURSOR] = FALSE,
    [PRIVATE_COLORMAP] = FALSE,
    [PRIVATE_DEVICE] = FALSE,
    [PRIVATE_EXTENSION] = FALSE,
    [PRIVATE_SELECTION] = FALSE,
    [PRIVATE_PROPERTY] = FALSE,
    [PRIVATE_PICTURE] = TRUE,
    [PRIVATE_GLYPHSET] = FALSE,
};

typedef Bool (*FixupFunc) (PrivatePtr *privates, int offset, unsigned bytes);

typedef enum { FixupMove, FixupRealloc } FixupType;

static Bool
dixReallocPrivates(PrivatePtr *privates, int old_offset, unsigned bytes)
{
    void *new_privates;

    new_privates = realloc(*privates, old_offset + bytes);
    if (!new_privates)
        return FALSE;
    memset((char *) new_privates + old_offset, '\0', bytes);
    *privates = new_privates;
    return TRUE;
}

static Bool
dixMovePrivates(PrivatePtr *privates, int new_offset, unsigned bytes)
{
    memmove((char *) *privates + bytes, *privates, new_offset - bytes);
    memset(*privates, '\0', bytes);
    return TRUE;
}

static Bool
fixupOneScreen(ScreenPtr pScreen, FixupFunc fixup, unsigned bytes)
{
    intptr_t        dist;
    char            *old;
    char            *new;
    DevPrivateKey   *keyp, key;
    DevPrivateType  type;
    int             size;

    old = (char *) pScreen->devPrivates;
    size = global_keys[PRIVATE_SCREEN].offset;
    if (!fixup (&pScreen->devPrivates, size, bytes))
        return FALSE;

    /* Screen privates can contain screen-specific private keys
     * for other types. When they move, the linked list we use to
     * track them gets scrambled. Fix that by computing the change
     * in the location of each private adjusting our linked list
     * pointers to match
     */

    new = (char *) pScreen->devPrivates;

    /* Moving means everyone shifts up in the privates by 'bytes' amount,
     * realloc means the base pointer moves
     */
    if (fixup == dixMovePrivates)
        new += bytes;

    dist = new - old;

    if (dist) {
        for (type = PRIVATE_XSELINUX; type < PRIVATE_LAST; type++)

            /* Walk the privates list, being careful as the
             * pointers are scrambled before we patch them.
             */
            for (keyp = &pScreen->screenSpecificPrivates[type].key;
                 (key = *keyp) != NULL;
                 keyp = &key->next)
            {

                /* Only mangle things if the private structure
                 * is contained within the allocation. Privates
                 * stored elsewhere will be left alone
                 */
                if (old <= (char *) key && (char *) key < old + size)
                {
                    /* Compute new location of key */
                    key = (DevPrivateKey) ((char *) key + dist);

                    /* Patch the list */
                    *keyp = key;
                }
            }
    }
    return TRUE;
}

static Bool
fixupScreens(FixupFunc fixup, unsigned bytes)
{
    int s;

    for (s = 0; s < screenInfo.numScreens; s++)
        if (!fixupOneScreen (screenInfo.screens[s], fixup, bytes))
            return FALSE;

    for (s = 0; s < screenInfo.numGPUScreens; s++)
        if (!fixupOneScreen (screenInfo.gpuscreens[s], fixup, bytes))
            return FALSE;
    return TRUE;
}

static Bool
fixupServerClient(FixupFunc fixup, unsigned bytes)
{
    if (serverClient)
        return fixup(&serverClient->devPrivates, global_keys[PRIVATE_CLIENT].offset,
                     bytes);
    return TRUE;
}

static Bool
fixupExtensions(FixupFunc fixup, unsigned bytes)
{
    unsigned char major;
    ExtensionEntry *extension;

    for (major = EXTENSION_BASE; (extension = GetExtensionEntry(major));
         major++)
        if (!fixup
            (&extension->devPrivates, global_keys[PRIVATE_EXTENSION].offset, bytes))
            return FALSE;
    return TRUE;
}

static Bool
fixupDefaultColormaps(FixupFunc fixup, unsigned bytes)
{
    int s;

    for (s = 0; s < screenInfo.numScreens; s++) {
        ColormapPtr cmap;

        dixLookupResourceByType((void **) &cmap,
                                screenInfo.screens[s]->defColormap, RT_COLORMAP,
                                serverClient, DixCreateAccess);
        if (cmap &&
            !fixup(&cmap->devPrivates, screenInfo.screens[s]->screenSpecificPrivates[PRIVATE_COLORMAP].offset, bytes))
            return FALSE;
    }
    return TRUE;
}

static Bool
fixupDeviceList(DeviceIntPtr device, FixupFunc fixup, unsigned bytes)
{
    while (device) {
        if (!fixup(&device->devPrivates, global_keys[PRIVATE_DEVICE].offset, bytes))
            return FALSE;
        device = device->next;
    }
    return TRUE;
}

static Bool
fixupDevices(FixupFunc fixup, unsigned bytes)
{
    return (fixupDeviceList(inputInfo.devices, fixup, bytes) &&
            fixupDeviceList(inputInfo.off_devices, fixup, bytes));
}

static Bool (*const allocated_early[PRIVATE_LAST]) (FixupFunc, unsigned) = {
    [PRIVATE_SCREEN] = fixupScreens,
    [PRIVATE_CLIENT] = fixupServerClient,
    [PRIVATE_EXTENSION] = fixupExtensions,
    [PRIVATE_COLORMAP] = fixupDefaultColormaps,
    [PRIVATE_DEVICE] = fixupDevices,
};

static void
grow_private_set(DevPrivateSetPtr set, unsigned bytes)
{
    DevPrivateKey       k;

    for (k = set->key; k; k = k->next)
        k->offset += bytes;
    set->offset += bytes;
}

static void
grow_screen_specific_set(DevPrivateType type, unsigned bytes)
{
    int s;

    /* Update offsets for all screen-specific keys */
    for (s = 0; s < screenInfo.numScreens; s++) {
        ScreenPtr       pScreen = screenInfo.screens[s];

        grow_private_set(&pScreen->screenSpecificPrivates[type], bytes);
    }
    for (s = 0; s < screenInfo.numGPUScreens; s++) {
        ScreenPtr       pScreen = screenInfo.gpuscreens[s];

        grow_private_set(&pScreen->screenSpecificPrivates[type], bytes);
    }
}

/*
 * Register a private key. This takes the type of object the key will
 * be used with, which may be PRIVATE_ALL indicating that this key
 * will be used with all of the private objects. If 'size' is
 * non-zero, then the specified amount of space will be allocated in
 * the private storage. Otherwise, space for a single pointer will
 * be allocated which can be set with dixSetPrivate
 */
Bool
dixRegisterPrivateKey(DevPrivateKey key, DevPrivateType type, unsigned size)
{
    DevPrivateType t;
    int offset;
    unsigned bytes;

    if (key->initialized) {
        assert(size == key->size);
        return TRUE;
    }

    /* Compute required space */
    bytes = size;
    if (size == 0)
        bytes = sizeof(void *);

    /* align to pointer size */
    bytes = (bytes + sizeof(void *) - 1) & ~(sizeof(void *) - 1);

    /* Update offsets for all affected keys */
    if (type == PRIVATE_XSELINUX) {

        /* Resize if we can, or make sure nothing's allocated if we can't
         */
        for (t = PRIVATE_XSELINUX; t < PRIVATE_LAST; t++)
            if (xselinux_private[t]) {
                if (!allocated_early[t])
                    assert(!global_keys[t].created);
                else if (!allocated_early[t] (dixReallocPrivates, bytes))
                    return FALSE;
            }

        /* Move all existing keys up in the privates space to make
         * room for this new global key
         */
        for (t = PRIVATE_XSELINUX; t < PRIVATE_LAST; t++) {
            if (xselinux_private[t]) {
                grow_private_set(&global_keys[t], bytes);
                grow_screen_specific_set(t, bytes);
                if (allocated_early[t])
                    allocated_early[t] (dixMovePrivates, bytes);
            }

        }

        offset = 0;
    }
    else {
        /* Resize if we can, or make sure nothing's allocated if we can't */
        if (!allocated_early[type])
            assert(!global_keys[type].created);
        else if (!allocated_early[type] (dixReallocPrivates, bytes))
            return FALSE;
        offset = global_keys[type].offset;
        global_keys[type].offset += bytes;
        grow_screen_specific_set(type, bytes);
    }

    /* Setup this key */
    key->offset = offset;
    key->size = size;
    key->initialized = TRUE;
    key->type = type;
    key->allocated = FALSE;
    key->next = global_keys[type].key;
    global_keys[type].key = key;

    return TRUE;
}

Bool
dixRegisterScreenPrivateKey(DevScreenPrivateKey screenKey, ScreenPtr pScreen,
                            DevPrivateType type, unsigned size)
{
    DevPrivateKey key;

    if (!dixRegisterPrivateKey(&screenKey->screenKey, PRIVATE_SCREEN, 0))
        return FALSE;
    key = dixGetPrivate(&pScreen->devPrivates, &screenKey->screenKey);
    if (key != NULL) {
        assert(key->size == size);
        assert(key->type == type);
        return TRUE;
    }
    key = calloc(sizeof(DevPrivateKeyRec), 1);
    if (!key)
        return FALSE;
    if (!dixRegisterPrivateKey(key, type, size)) {
        free(key);
        return FALSE;
    }
    key->allocated = TRUE;
    dixSetPrivate(&pScreen->devPrivates, &screenKey->screenKey, key);
    return TRUE;
}

DevPrivateKey
_dixGetScreenPrivateKey(const DevScreenPrivateKey key, ScreenPtr pScreen)
{
    return dixGetPrivate(&pScreen->devPrivates, &key->screenKey);
}

/*
 * Initialize privates by zeroing them
 */
void
_dixInitPrivates(PrivatePtr *privates, void *addr, DevPrivateType type)
{
    assert (!screen_specific_private[type]);

    global_keys[type].created++;
    if (xselinux_private[type])
        global_keys[PRIVATE_XSELINUX].created++;
    if (global_keys[type].offset == 0)
        addr = 0;
    *privates = addr;
    memset(addr, '\0', global_keys[type].offset);
}

/*
 * Clean up privates
 */
void
_dixFiniPrivates(PrivatePtr privates, DevPrivateType type)
{
    global_keys[type].created--;
    if (xselinux_private[type])
        global_keys[PRIVATE_XSELINUX].created--;
}

/*
 * Allocate new object with privates.
 *
 * This is expected to be invoked from the
 * dixAllocateObjectWithPrivates macro
 */
void *
_dixAllocateObjectWithPrivates(unsigned baseSize, unsigned clear,
                               unsigned offset, DevPrivateType type)
{
    unsigned totalSize;
    void *object;
    PrivatePtr privates;
    PrivatePtr *devPrivates;

    assert(type > PRIVATE_SCREEN && type < PRIVATE_LAST);
    assert(!screen_specific_private[type]);

    /* round up so that void * is aligned */
    baseSize = (baseSize + sizeof(void *) - 1) & ~(sizeof(void *) - 1);
    totalSize = baseSize + global_keys[type].offset;
    object = malloc(totalSize);
    if (!object)
        return NULL;

    memset(object, '\0', clear);
    privates = (PrivatePtr) (((char *) object) + baseSize);
    devPrivates = (PrivatePtr *) ((char *) object + offset);

    _dixInitPrivates(devPrivates, privates, type);

    return object;
}

/*
 * Allocate privates separately from containing object.
 * Used for clients and screens.
 */
Bool
dixAllocatePrivates(PrivatePtr *privates, DevPrivateType type)
{
    unsigned size;
    PrivatePtr p;

    assert(type > PRIVATE_XSELINUX && type < PRIVATE_LAST);
    assert(!screen_specific_private[type]);

    size = global_keys[type].offset;
    if (!size) {
        p = NULL;
    }
    else {
        if (!(p = malloc(size)))
            return FALSE;
    }

    _dixInitPrivates(privates, p, type);
    ++global_keys[type].allocated;

    return TRUE;
}

/*
 * Free an object that has privates
 *
 * This is expected to be invoked from the
 * dixFreeObjectWithPrivates macro
 */
void
_dixFreeObjectWithPrivates(void *object, PrivatePtr privates,
                           DevPrivateType type)
{
    _dixFiniPrivates(privates, type);
    free(object);
}

/*
 * Called to free screen or client privates
 */
void
dixFreePrivates(PrivatePtr privates, DevPrivateType type)
{
    _dixFiniPrivates(privates, type);
    --global_keys[type].allocated;
    free(privates);
}

/*
 * Return size of privates for the specified type
 */
extern _X_EXPORT int
dixPrivatesSize(DevPrivateType type)
{
    assert(type >= PRIVATE_SCREEN && type < PRIVATE_LAST);
    assert (!screen_specific_private[type]);

    return global_keys[type].offset;
}

/* Table of devPrivates offsets */
static const int offsets[] = {
    -1,                         /* RT_NONE */
    offsetof(WindowRec, devPrivates),   /* RT_WINDOW */
    offsetof(PixmapRec, devPrivates),   /* RT_PIXMAP */
    offsetof(GC, devPrivates),  /* RT_GC */
    -1,                         /* RT_FONT */
    offsetof(CursorRec, devPrivates),   /* RT_CURSOR */
    offsetof(ColormapRec, devPrivates), /* RT_COLORMAP */
};

#define NUM_OFFSETS	(sizeof (offsets) / sizeof (offsets[0]))

int
dixLookupPrivateOffset(RESTYPE type)
{
    /*
     * Special kludge for DBE which registers a new resource type that
     * points at pixmaps (thanks, DBE)
     */
    if (type & RC_DRAWABLE) {
        if (type == RT_WINDOW)
            return offsets[RT_WINDOW & TypeMask];
        else
            return offsets[RT_PIXMAP & TypeMask];
    }
    type = type & TypeMask;
    if (type < NUM_OFFSETS)
        return offsets[type];
    return -1;
}

/*
 * Screen-specific privates
 */

extern _X_EXPORT Bool
dixRegisterScreenSpecificPrivateKey(ScreenPtr pScreen, DevPrivateKey key,
                                    DevPrivateType type, unsigned size)
{
    int offset;
    unsigned bytes;

    if (!screen_specific_private[type])
        FatalError("Attempt to allocate screen-specific private storage for type %s\n",
                   key_names[type]);

    if (key->initialized) {
        assert(size == key->size);
        return TRUE;
    }

    /* Compute required space */
    bytes = size;
    if (size == 0)
        bytes = sizeof(void *);

    /* align to void * size */
    bytes = (bytes + sizeof(void *) - 1) & ~(sizeof(void *) - 1);

    assert (!allocated_early[type]);
    assert (!pScreen->screenSpecificPrivates[type].created);
    offset = pScreen->screenSpecificPrivates[type].offset;
    pScreen->screenSpecificPrivates[type].offset += bytes;

    /* Setup this key */
    key->offset = offset;
    key->size = size;
    key->initialized = TRUE;
    key->type = type;
    key->allocated = FALSE;
    key->next = pScreen->screenSpecificPrivates[type].key;
    pScreen->screenSpecificPrivates[type].key = key;

    return TRUE;
}

/* Clean up screen-specific privates before CloseScreen */
void
dixFreeScreenSpecificPrivates(ScreenPtr pScreen)
{
    DevPrivateType t;

    for (t = PRIVATE_XSELINUX; t < PRIVATE_LAST; t++) {
        DevPrivateKey key;

        for (key = pScreen->screenSpecificPrivates[t].key; key; key = key->next) {
            key->initialized = FALSE;
        }
    }
}

/* Initialize screen-specific privates in AddScreen */
void
dixInitScreenSpecificPrivates(ScreenPtr pScreen)
{
    DevPrivateType      t;

    for (t = PRIVATE_XSELINUX; t < PRIVATE_LAST; t++)
        pScreen->screenSpecificPrivates[t].offset = global_keys[t].offset;
}

/* Initialize screen-specific privates in AddScreen */
void
_dixInitScreenPrivates(ScreenPtr pScreen, PrivatePtr *privates, void *addr, DevPrivateType type)
{
    int privates_size;
    assert (screen_specific_private[type]);

    if (pScreen) {
        privates_size = pScreen->screenSpecificPrivates[type].offset;
        pScreen->screenSpecificPrivates[type].created++;
    }
    else
        privates_size = global_keys[type].offset;

    global_keys[type].created++;
    if (xselinux_private[type])
        global_keys[PRIVATE_XSELINUX].created++;
    if (privates_size == 0)
        addr = 0;
    *privates = addr;
    memset(addr, '\0', privates_size);
}

void *
_dixAllocateScreenObjectWithPrivates(ScreenPtr pScreen,
                                     unsigned baseSize,
                                     unsigned clear,
                                     unsigned offset,
                                     DevPrivateType type)
{
    unsigned totalSize;
    void *object;
    PrivatePtr privates;
    PrivatePtr *devPrivates;
    int privates_size;

    assert(type > PRIVATE_SCREEN && type < PRIVATE_LAST);
    assert (screen_specific_private[type]);

    if (pScreen)
        privates_size = pScreen->screenSpecificPrivates[type].offset;
    else
        privates_size = global_keys[type].offset;
    /* round up so that pointer is aligned */
    baseSize = (baseSize + sizeof(void *) - 1) & ~(sizeof(void *) - 1);
    totalSize = baseSize + privates_size;
    object = malloc(totalSize);
    if (!object)
        return NULL;

    memset(object, '\0', clear);
    privates = (PrivatePtr) (((char *) object) + baseSize);
    devPrivates = (PrivatePtr *) ((char *) object + offset);

    _dixInitScreenPrivates(pScreen, devPrivates, privates, type);

    return object;
}

int
dixScreenSpecificPrivatesSize(ScreenPtr pScreen, DevPrivateType type)
{
    assert(type >= PRIVATE_SCREEN && type < PRIVATE_LAST);

    if (screen_specific_private[type])
        return pScreen->screenSpecificPrivates[type].offset;
    else
        return global_keys[type].offset;
}

void
dixPrivateUsage(void)
{
    int objects = 0;
    int bytes = 0;
    int alloc = 0;
    DevPrivateType t;

    for (t = PRIVATE_XSELINUX + 1; t < PRIVATE_LAST; t++) {
        if (global_keys[t].offset) {
            ErrorF
                ("%s: %d objects of %d bytes = %d total bytes %d private allocs\n",
                 key_names[t], global_keys[t].created, global_keys[t].offset,
                 global_keys[t].created * global_keys[t].offset, global_keys[t].allocated);
            bytes += global_keys[t].created * global_keys[t].offset;
            objects += global_keys[t].created;
            alloc += global_keys[t].allocated;
        }
    }
    ErrorF("TOTAL: %d objects, %d bytes, %d allocs\n", objects, bytes, alloc);
}

void
dixResetPrivates(void)
{
    DevPrivateType t;

    for (t = PRIVATE_XSELINUX; t < PRIVATE_LAST; t++) {
        DevPrivateKey key, next;

        for (key = global_keys[t].key; key; key = next) {
            next = key->next;
            key->offset = 0;
            key->initialized = FALSE;
            key->size = 0;
            key->type = 0;
            if (key->allocated)
                free(key);
        }
        if (global_keys[t].created) {
            ErrorF("%d %ss still allocated at reset\n",
                   global_keys[t].created, key_names[t]);
            dixPrivateUsage();
        }
        global_keys[t].key = NULL;
        global_keys[t].offset = 0;
        global_keys[t].created = 0;
        global_keys[t].allocated = 0;
    }
}
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d645 9
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d262 1
a262 1
        dixLookupResourceByType((pointer *) &cmap,
d351 1
a351 1
    /* align to void * size */
d700 1
a700 1
    /* round up so that void * is aligned */
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a107 1
    [PRIVATE_DBE_WINDOW] = "DBE_WINDOW",
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d65 1
d67 1
a67 6
static struct {
    DevPrivateKey key;
    unsigned offset;
    int created;
    int allocated;
} keys[PRIVATE_LAST];
d85 47
d134 2
d158 60
d223 5
a227 3
        if (!fixup
            (&screenInfo.screens[s]->devPrivates, keys[PRIVATE_SCREEN].offset,
             bytes))
d236 1
a236 1
        return fixup(&serverClient->devPrivates, keys[PRIVATE_CLIENT].offset,
d250 1
a250 1
            (&extension->devPrivates, keys[PRIVATE_EXTENSION].offset, bytes))
d267 11
a277 1
            !fixup(&cmap->devPrivates, keys[PRIVATE_COLORMAP].offset, bytes))
d279 1
d284 7
d292 34
a325 4
[PRIVATE_SCREEN] = fixupScreens,
        [PRIVATE_CLIENT] = fixupServerClient,
        [PRIVATE_EXTENSION] = fixupExtensions,
        [PRIVATE_COLORMAP] = fixupDefaultColormaps,};
a356 1
        DevPrivateKey k;
d363 1
a363 1
                    assert(!keys[t].created);
d373 2
a374 3
                for (k = keys[t].key; k; k = k->next)
                    k->offset += bytes;
                keys[t].offset += bytes;
d378 1
d386 1
a386 1
            assert(!keys[type].created);
d389 3
a391 2
        offset = keys[type].offset;
        keys[type].offset += bytes;
d400 2
a401 2
    key->next = keys[type].key;
    keys[type].key = key;
d444 3
a446 1
    keys[type].created++;
d448 2
a449 2
        keys[PRIVATE_XSELINUX].created++;
    if (keys[type].offset == 0)
d452 1
a452 1
    memset(addr, '\0', keys[type].offset);
d461 1
a461 1
    keys[type].created--;
d463 1
a463 1
        keys[PRIVATE_XSELINUX].created--;
d482 1
d486 1
a486 1
    totalSize = baseSize + keys[type].offset;
d511 1
d513 1
a513 1
    size = keys[type].offset;
d523 1
a523 1
    ++keys[type].allocated;
d549 1
a549 1
    --keys[type].allocated;
d560 1
d562 1
a562 1
    return keys[type].offset;
d597 116
a712 3
static const char *key_names[PRIVATE_LAST] = {
    /* XSELinux uses the same private keys for numerous objects */
    [PRIVATE_XSELINUX] = "XSELINUX",
d714 2
a715 6
    /* Otherwise, you get a private in just the requested structure
     */
    /* These can have objects created before all of the keys are registered */
    [PRIVATE_SCREEN] = "SCREEN",
    [PRIVATE_EXTENSION] = "EXTENSION",
    [PRIVATE_COLORMAP] = "COLORMAP",
d717 4
a720 10
    /* These cannot have any objects before all relevant keys are registered */
    [PRIVATE_DEVICE] = "DEVICE",
    [PRIVATE_CLIENT] = "CLIENT",
    [PRIVATE_PROPERTY] = "PROPERTY",
    [PRIVATE_SELECTION] = "SELECTION",
    [PRIVATE_WINDOW] = "WINDOW",
    [PRIVATE_PIXMAP] = "PIXMAP",
    [PRIVATE_GC] = "GC",
    [PRIVATE_CURSOR] = "CURSOR",
    [PRIVATE_CURSOR_BITS] = "CURSOR_BITS",
d722 5
a726 8
    /* extension privates */
    [PRIVATE_DBE_WINDOW] = "DBE_WINDOW",
    [PRIVATE_DAMAGE] = "DAMAGE",
    [PRIVATE_GLYPH] = "GLYPH",
    [PRIVATE_GLYPHSET] = "GLYPHSET",
    [PRIVATE_PICTURE] = "PICTURE",
    [PRIVATE_SYNC_FENCE] = "SYNC_FENCE",
};
d737 1
a737 1
        if (keys[t].offset) {
d740 5
a744 5
                 key_names[t], keys[t].created, keys[t].offset,
                 keys[t].created * keys[t].offset, keys[t].allocated);
            bytes += keys[t].created * keys[t].offset;
            objects += keys[t].created;
            alloc += keys[t].allocated;
d758 1
a758 1
        for (key = keys[t].key; key; key = next) {
d767 1
a767 1
        if (keys[t].created) {
d769 1
a769 1
                   keys[t].created, key_names[t]);
d772 4
a775 4
        keys[t].key = NULL;
        keys[t].offset = 0;
        keys[t].created = 0;
        keys[t].allocated = 0;
@


1.6
log
@Update to xserver 1.11.2
@
text
@d67 4
a70 4
    DevPrivateKey	key;
    unsigned		offset;
    int			created;
    int			allocated;
d89 1
a89 1
typedef Bool (*FixupFunc)(PrivatePtr *privates, int offset, unsigned bytes);
d94 1
a94 1
    void	*new_privates;
d98 1
a98 1
	return FALSE;
d116 1
d118 4
a121 2
	if (!fixup(&screenInfo.screens[s]->devPrivates, keys[PRIVATE_SCREEN].offset, bytes))
	    return FALSE;
d129 2
a130 1
	return fixup(&serverClient->devPrivates, keys[PRIVATE_CLIENT].offset, bytes);
d137 8
a144 5
    unsigned char 	major;
    ExtensionEntry	*extension;
    for (major = EXTENSION_BASE; (extension = GetExtensionEntry(major)); major++)
	if (!fixup(&extension->devPrivates, keys[PRIVATE_EXTENSION].offset, bytes))
	    return FALSE;
d152 1
d154 8
a161 5
	ColormapPtr cmap;
	dixLookupResourceByType((pointer *) &cmap, screenInfo.screens[s]->defColormap,
	                        RT_COLORMAP, serverClient, DixCreateAccess);
	if (cmap && !fixup(&cmap->devPrivates, keys[PRIVATE_COLORMAP].offset, bytes))
	    return FALSE;
d166 5
a170 6
static Bool (* const allocated_early[PRIVATE_LAST])(FixupFunc, unsigned) = {
    [PRIVATE_SCREEN] = fixupScreens,
    [PRIVATE_CLIENT] = fixupServerClient,
    [PRIVATE_EXTENSION] = fixupExtensions,
    [PRIVATE_COLORMAP] = fixupDefaultColormaps,
};
d183 3
a185 3
    DevPrivateType	t;
    int			offset;
    unsigned		bytes;
d188 2
a189 2
	assert (size == key->size);
	return TRUE;
d195 1
a195 1
	bytes = sizeof (void *);
d198 1
a198 1
    bytes = (bytes + sizeof (void *) - 1) & ~(sizeof (void *) - 1);
d202 24
a225 1
	DevPrivateKey	k;
d227 10
a236 32
	/* Resize if we can, or make sure nothing's allocated if we can't
	 */
	for (t = PRIVATE_XSELINUX; t < PRIVATE_LAST; t++)
	    if (xselinux_private[t]) {
		if (!allocated_early[t])
		    assert (!keys[t].created);
		else if (!allocated_early[t](dixReallocPrivates, bytes))
		    return FALSE;
	    }

	/* Move all existing keys up in the privates space to make
	 * room for this new global key
	 */
	for (t = PRIVATE_XSELINUX; t < PRIVATE_LAST; t++) {
	    if (xselinux_private[t]) {
		for (k = keys[t].key; k; k = k->next)
		    k->offset += bytes;
		keys[t].offset += bytes;
		if (allocated_early[t])
		    allocated_early[t](dixMovePrivates, bytes);
	    }
	}

	offset = 0;
    } else {
	/* Resize if we can, or make sure nothing's allocated if we can't */
	if (!allocated_early[type])
	    assert(!keys[type].created);
	else if (!allocated_early[type](dixReallocPrivates, bytes))
	    return FALSE;
	offset = keys[type].offset;
	keys[type].offset += bytes;
d252 2
a253 1
dixRegisterScreenPrivateKey(DevScreenPrivateKey screenKey, ScreenPtr pScreen, DevPrivateType type, unsigned size)
d255 1
a255 1
    DevPrivateKey	key;
d258 1
a258 1
	return FALSE;
d261 3
a263 3
	assert(key->size == size);
	assert(key->type == type);
	return TRUE;
d265 1
a265 1
    key = calloc(sizeof (DevPrivateKeyRec), 1);
d267 1
a267 1
	return FALSE;
d269 2
a270 2
	free(key);
	return FALSE;
d291 1
a291 1
	keys[PRIVATE_XSELINUX].created++;
d293 1
a293 1
	addr = 0;
d306 1
a306 1
	keys[PRIVATE_XSELINUX].created--;
d316 2
a317 1
_dixAllocateObjectWithPrivates(unsigned baseSize, unsigned clear, unsigned offset, DevPrivateType type)
d319 4
a322 4
    unsigned		totalSize;
    void		*object;
    PrivatePtr		privates;
    PrivatePtr		*devPrivates;
d324 1
a324 1
    assert (type > PRIVATE_SCREEN && type < PRIVATE_LAST);
d327 1
a327 1
    baseSize = (baseSize + sizeof (void *) - 1) & ~(sizeof (void *) - 1);
d331 1
a331 1
	return NULL;
d349 2
a350 2
    unsigned 	size;
    PrivatePtr	p;
d352 1
a352 1
    assert (type > PRIVATE_XSELINUX && type < PRIVATE_LAST);
d356 5
a360 4
	p = NULL;
    } else {
	if (!(p = malloc(size)))
	    return FALSE;
d376 2
a377 1
_dixFreeObjectWithPrivates(void *object, PrivatePtr privates, DevPrivateType type)
d400 1
a400 1
    assert (type >= PRIVATE_SCREEN && type < PRIVATE_LAST);
d407 7
a413 7
    -1,					/* RT_NONE */
    offsetof(WindowRec, devPrivates),	/* RT_WINDOW */
    offsetof(PixmapRec, devPrivates),	/* RT_PIXMAP */
    offsetof(GC, devPrivates),		/* RT_GC */
    -1,		    			/* RT_FONT */
    offsetof(CursorRec, devPrivates),	/* RT_CURSOR */
    offsetof(ColormapRec, devPrivates),	/* RT_COLORMAP */
d426 4
a429 4
	if (type == RT_WINDOW)
	    return offsets[RT_WINDOW & TypeMask];
	else
	    return offsets[RT_PIXMAP & TypeMask];
d433 1
a433 1
	return offsets[type];
d472 1
a472 1
    int	bytes = 0;
d477 9
a485 8
	if (keys[t].offset) {
	    ErrorF("%s: %d objects of %d bytes = %d total bytes %d private allocs\n",
		   key_names[t], keys[t].created, keys[t].offset, keys[t].created * keys[t].offset,
		   keys[t].allocated);
	    bytes += keys[t].created * keys[t].offset;
	    objects += keys[t].created;
	    alloc += keys[t].allocated;
	}
d487 1
a487 2
    ErrorF("TOTAL: %d objects, %d bytes, %d allocs\n",
	   objects, bytes, alloc);
d493 1
a493 1
    DevPrivateType	t;
d496 1
a496 1
	DevPrivateKey	key, next;
d498 18
a515 18
	for (key = keys[t].key; key; key = next) {
	    next = key->next;
	    key->offset = 0;
	    key->initialized = FALSE;
	    key->size = 0;
	    key->type = 0;
	    if (key->allocated)
		free(key);
	}
	if (keys[t].created) {
	    ErrorF("%d %ss still allocated at reset\n",
		   keys[t].created, key_names[t]);
	    dixPrivateUsage();
	}
	keys[t].key = NULL;
	keys[t].offset = 0;
	keys[t].created = 0;
	keys[t].allocated = 0;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d240 2
a241 10
/*
 * Allocate a new private key.
 *
 * This manages the storage of the key object itself, freeing it when the
 * privates system is restarted at server reset time. All other keys
 * are expected to be statically allocated as the privates must be
 * reset after all objects have been freed
 */
DevPrivateKey
dixCreatePrivateKey(DevPrivateType type, unsigned size)
d245 8
d255 1
a255 1
	return NULL;
d258 1
a258 1
	return NULL;
d261 8
a268 1
    return key;
d450 1
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d28 22
d63 2
d66 21
a86 3
struct _Private {
    int state;
    pointer value;
d89 32
a120 25
typedef struct _PrivateDesc {
    DevPrivateKey key;
    unsigned size;
    CallbackListPtr initfuncs;
    CallbackListPtr deletefuncs;
} PrivateDescRec;

#define PRIV_MAX 256
#define PRIV_STEP 16

/* list of all allocated privates */
static PrivateDescRec items[PRIV_MAX];
static int nextPriv;

static PrivateDescRec *
findItem(const DevPrivateKey key)
{
    if (!*key) {
	if (nextPriv >= PRIV_MAX)
	    return NULL;

	items[nextPriv].key = key;
	*key = nextPriv;
	nextPriv++;
    }
d122 6
a127 1
    return items + *key;
d130 2
a131 2
static _X_INLINE int
privateExists(PrivateRec **privates, const DevPrivateKey key)
d133 6
a138 3
    return *key && *privates &&
	(*privates)[0].state > *key &&
	(*privates)[*key].state;
d141 2
a142 5
/*
 * Request pre-allocated space.
 */
int
dixRequestPrivate(const DevPrivateKey key, unsigned size)
d144 8
a151 5
    PrivateDescRec *item = findItem(key);
    if (!item)
	return FALSE;
    if (size > item->size)
	item->size = size;
d155 7
d163 6
a168 1
 * Allocate a private and attach it to an existing object.
d170 2
a171 2
pointer *
dixAllocatePrivate(PrivateRec **privates, const DevPrivateKey key)
d173 3
a175 5
    PrivateDescRec *item = findItem(key);
    PrivateCallbackRec calldata;
    PrivateRec *ptr;
    pointer value;
    int oldsize, newsize;
d177 3
a179 13
    newsize = (*key / PRIV_STEP + 1) * PRIV_STEP;

    /* resize or init privates array */
    if (!item)
	return NULL;

    /* initialize privates array if necessary */
    if (!*privates) {
	ptr = xcalloc(newsize, sizeof(*ptr));
	if (!ptr)
	    return NULL;
	*privates = ptr;
	(*privates)[0].state = newsize;
d182 21
a202 1
    oldsize = (*privates)[0].state;
d204 12
a215 9
    /* resize privates array if necessary */
    if (*key >= oldsize) {
	ptr = xrealloc(*privates, newsize * sizeof(*ptr));
	if (!ptr)
	    return NULL;
	memset(ptr + oldsize, 0, (newsize - oldsize) * sizeof(*ptr));
	*privates = ptr;
	(*privates)[0].state = newsize;
    }
d217 9
a225 8
    /* initialize slot */
    ptr = *privates + *key;
    ptr->state = 1;
    if (item->size) {
	value = xcalloc(item->size, 1);
	if (!value)
	    return NULL;
	ptr->value = value;
d228 8
a235 3
    calldata.key = key;
    calldata.value = &ptr->value;
    CallCallbacks(&item->initfuncs, &calldata);
d237 1
a237 1
    return &ptr->value;
d241 6
a246 1
 * Look up a private pointer.
d248 2
a249 2
pointer
dixLookupPrivate(PrivateRec **privates, const DevPrivateKey key)
d251 1
a251 1
    pointer *ptr;
d253 10
a262 2
    if (privateExists(privates, key))
	return (*privates)[*key].value;
d264 13
a276 2
    ptr = dixAllocatePrivate(privates, key);
    return ptr ? *ptr : NULL;
d280 1
a280 1
 * Look up the address of a private pointer.
d282 2
a283 2
pointer *
dixLookupPrivateAddr(PrivateRec **privates, const DevPrivateKey key)
d285 4
a288 2
    if (privateExists(privates, key))
	return &(*privates)[*key].value;
d290 30
a319 1
    return dixAllocatePrivate(privates, key);
d323 2
a324 1
 * Set a private pointer.
d326 2
a327 2
int
dixSetPrivate(PrivateRec **privates, const DevPrivateKey key, pointer val)
d329 11
a339 4
 top:
    if (privateExists(privates, key)) {
	(*privates)[*key].value = val;
	return TRUE;
d342 4
a345 3
    if (!dixAllocatePrivate(privates, key))
	return FALSE;
    goto top;
d349 4
a352 1
 * Called to free privates at object deletion time.
d355 1
a355 1
dixFreePrivates(PrivateRec *privates)
d357 2
a358 17
    int i;
    PrivateCallbackRec calldata;

    if (privates)
	for (i = 1; i < privates->state; i++)
	    if (privates[i].state) {
		/* call the delete callbacks */
		calldata.key = items[i].key;
		calldata.value = &privates[i].value;
		CallCallbacks(&items[i].deletefuncs, &calldata);

		/* free pre-allocated memory */
		if (items[i].size)
		    xfree(privates[i].value);
	    }

    xfree(privates);
d362 1
a362 1
 * Callback registration
d364 2
a365 3
int
dixRegisterPrivateInitFunc(const DevPrivateKey key,
			   CallbackProcPtr callback, pointer data)
d367 3
a369 5
    PrivateDescRec *item = findItem(key);
    if (!item)
	return FALSE;

    return AddCallback(&item->initfuncs, callback, data);
d372 5
a376 3
int
dixRegisterPrivateDeleteFunc(const DevPrivateKey key,
			     CallbackProcPtr callback, pointer data)
d378 1
a378 3
    PrivateDescRec *item = findItem(key);
    if (!item)
	return FALSE;
d380 1
a380 1
    return AddCallback(&item->deletefuncs, callback, data);
d384 1
a384 1
static const int offsetDefaults[] = {
a391 3
    -1,			  		/* RT_CMAPENTRY */
    -1,					/* RT_OTHERCLIENT */
    -1					/* RT_PASSIVEGRAB */
a392 3
    
static int *offsets = NULL;
static int offsetsSize = 0;
d394 2
a395 3
/*
 * Specify where the devPrivates field is located in a structure type
 */
d397 1
a397 1
dixRegisterPrivateOffset(RESTYPE type, int offset)
d399 10
d410 34
d445 16
a460 7
    /* resize offsets table if necessary */
    while (type >= offsetsSize) {
	unsigned i = offsetsSize * 2 * sizeof(int);
	offsets = (int *)xrealloc(offsets, i);
	if (!offsets) {
	    offsetsSize = 0;
	    return FALSE;
a461 3
	for (i=offsetsSize; i < 2*offsetsSize; i++)
	    offsets[i] = -1;
	offsetsSize *= 2;
d463 2
a464 3

    offsets[type] = offset;
    return TRUE;
d467 2
a468 2
int
dixLookupPrivateOffset(RESTYPE type)
d470 1
a470 4
    type = type & TypeMask;
    assert(type < offsetsSize);
    return offsets[type];
}
d472 2
a473 4
int
dixResetPrivates(void)
{
    int i;
d475 18
a492 6
    /* reset private descriptors */
    for (i = 1; i < nextPriv; i++) {
	*items[i].key = 0;
	items[i].size = 0;
	DeleteCallbackList(&items[i].initfuncs);
	DeleteCallbackList(&items[i].deletefuncs);
a493 12
    nextPriv = 1;

    /* reset offsets */
    if (offsets)
	xfree(offsets);
    offsetsSize = sizeof(offsetDefaults);
    offsets = xalloc(offsetsSize);
    offsetsSize /= sizeof(int);
    if (!offsets)
	return FALSE;
    memcpy(offsets, offsetDefaults, sizeof(offsetDefaults));
    return TRUE;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d87 1
a87 1
_X_EXPORT int
d101 1
a101 1
_X_EXPORT pointer *
d157 1
a157 1
_X_EXPORT pointer
d172 1
a172 1
_X_EXPORT pointer *
d184 1
a184 1
_X_EXPORT int
d201 1
a201 1
_X_EXPORT void
d226 1
a226 1
_X_EXPORT int
d237 1
a237 1
_X_EXPORT int
d268 1
a268 1
_X_EXPORT int
d290 1
a290 1
_X_EXPORT int
d306 1
d316 1
a316 1
    offsets = (int *)xalloc(offsetsSize);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d43 2
a44 3
    DevPrivateKey      key;
    pointer            value;
    struct _Private    *next;
a51 1
    struct _PrivateDesc *next;
d54 3
d58 2
a59 1
static PrivateDescRec *items = NULL;
d61 1
a61 1
static _X_INLINE PrivateDescRec *
d64 7
a70 5
    PrivateDescRec *item = items;
    while (item) {
	if (item->key == key)
	    return item;
	item = item->next;
d72 10
a81 1
    return NULL;
d91 3
a93 11
    if (item) {
	if (size > item->size)
	    item->size = size;
    } else {
	item = (PrivateDescRec *)xalloc(sizeof(PrivateDescRec));
	if (!item)
	    return FALSE;
	memset(item, 0, sizeof(PrivateDescRec));

	/* add privates descriptor */
	item->key = key;
a94 3
	item->next = items;
	items = item;
    }
d105 1
d107 4
a110 4
    unsigned size = sizeof(PrivateRec);
    
    if (item)
	size += item->size;
d112 2
a113 2
    ptr = (PrivateRec *)xcalloc(size, 1);
    if (!ptr)
d115 36
a150 10
    ptr->key = key;
    ptr->value = (size > sizeof(PrivateRec)) ? (ptr + 1) : NULL;
    ptr->next = *privates;
    *privates = ptr;

    /* call any init funcs and return */
    if (item) {
	PrivateCallbackRec calldata = { key, &ptr->value };
	CallCallbacks(&item->initfuncs, &calldata);
    }
a159 1
    PrivateRec *rec = *privates;
d162 2
a163 5
    while (rec) {
	if (rec->key == key)
	    return rec->value;
	rec = rec->next;
    }
d175 2
a176 7
    PrivateRec *rec = *privates;

    while (rec) {
	if (rec->key == key)
	    return &rec->value;
	rec = rec->next;
    }
a186 2
    PrivateRec *rec;

d188 3
a190 7
    rec = *privates;
    while (rec) {
	if (rec->key == key) {
	    rec->value = val;
	    return TRUE;
	}
	rec = rec->next;
d204 1
a204 2
    PrivateRec *ptr, *next;
    PrivateDescRec *item;
d207 14
a220 17
    /* first pass calls the delete callbacks */
    for (ptr = privates; ptr; ptr = ptr->next) {
	item = findItem(ptr->key);
	if (item) {
	    calldata.key = ptr->key;
	    calldata.value = &ptr->value;
	    CallCallbacks(&item->deletefuncs, &calldata);
	}
    }
	
    /* second pass frees the memory */
    ptr = privates;
    while (ptr) {
	next = ptr->next;
	xfree(ptr);
	ptr = next;
    }
d231 3
a233 5
    if (!item) {
	if (!dixRequestPrivate(key, 0))
	    return FALSE;
	item = findItem(key);
    }
d242 3
a244 5
    if (!item) {
	if (!dixRequestPrivate(key, 0))
	    return FALSE;
	item = findItem(key);
    }
d301 1
a301 1
    PrivateDescRec *next;
d303 5
a307 7
    /* reset internal structures */
    while (items) {
	next = items->next;
	DeleteCallbackList(&items->initfuncs);
	DeleteCallbackList(&items->deletefuncs);
	xfree(items);
	items = next;
d309 3
@


1.1
log
@Initial revision
@
text
@d33 1
a33 4
#include <X11/X.h>
#include "scrnintstr.h"
#include "misc.h"
#include "os.h"
d36 1
a36 1
#include "dixstruct.h"
d38 1
a39 2
#include "servermd.h"
#include "site.h"
a40 1
#include "extnsionst.h"
d42 28
a69 5
/*
 *  See the Wrappers and devPrivates section in "Definition of the
 *  Porting Layer for the X v11 Sample Server" (doc/Server/ddx.tbl.ms)
 *  for information on how to use devPrivates.
 */
d72 1
a72 1
 *  extension private machinery
a73 17

static int  extensionPrivateCount;
int extensionPrivateLen;
unsigned *extensionPrivateSizes;
unsigned totalExtensionSize;

void
ResetExtensionPrivates()
{
    extensionPrivateCount = 0;
    extensionPrivateLen = 0;
    xfree(extensionPrivateSizes);
    extensionPrivateSizes = (unsigned *)NULL;
    totalExtensionSize =
	((sizeof(ExtensionEntry) + sizeof(long) - 1) / sizeof(long)) * sizeof(long);
}

d75 1
a75 1
AllocateExtensionPrivateIndex()
d77 9
a85 10
    return extensionPrivateCount++;
}

_X_EXPORT Bool
AllocateExtensionPrivate(int index2, unsigned amount)
{
    unsigned oldamount;

    /* Round up sizes for proper alignment */
    amount = ((amount + (sizeof(long) - 1)) / sizeof(long)) * sizeof(long);
d87 5
a91 19
    if (index2 >= extensionPrivateLen)
    {
	unsigned *nsizes;
	nsizes = (unsigned *)xrealloc(extensionPrivateSizes,
				      (index2 + 1) * sizeof(unsigned));
	if (!nsizes)
	    return FALSE;
	while (extensionPrivateLen <= index2)
	{
	    nsizes[extensionPrivateLen++] = 0;
	    totalExtensionSize += sizeof(DevUnion);
	}
	extensionPrivateSizes = nsizes;
    }
    oldamount = extensionPrivateSizes[index2];
    if (amount > oldamount)
    {
	extensionPrivateSizes[index2] = amount;
	totalExtensionSize += (amount - oldamount);
d97 1
a97 1
 *  client private machinery
d99 2
a100 19

static int  clientPrivateCount;
int clientPrivateLen;
unsigned *clientPrivateSizes;
unsigned totalClientSize;

void
ResetClientPrivates()
{
    clientPrivateCount = 0;
    clientPrivateLen = 0;
    xfree(clientPrivateSizes);
    clientPrivateSizes = (unsigned *)NULL;
    totalClientSize =
	((sizeof(ClientRec) + sizeof(long) - 1) / sizeof(long)) * sizeof(long);
}

_X_EXPORT int
AllocateClientPrivateIndex()
d102 21
a122 1
    return clientPrivateCount++;
d125 5
a129 2
_X_EXPORT Bool
AllocateClientPrivate(int index2, unsigned amount)
d131 2
a132 1
    unsigned oldamount;
d134 5
a138 2
    /* Round up sizes for proper alignment */
    amount = ((amount + (sizeof(long) - 1)) / sizeof(long)) * sizeof(long);
d140 2
a141 21
    if (index2 >= clientPrivateLen)
    {
	unsigned *nsizes;
	nsizes = (unsigned *)xrealloc(clientPrivateSizes,
				      (index2 + 1) * sizeof(unsigned));
	if (!nsizes)
	    return FALSE;
	while (clientPrivateLen <= index2)
	{
	    nsizes[clientPrivateLen++] = 0;
	    totalClientSize += sizeof(DevUnion);
	}
	clientPrivateSizes = nsizes;
    }
    oldamount = clientPrivateSizes[index2];
    if (amount > oldamount)
    {
	clientPrivateSizes[index2] = amount;
	totalClientSize += (amount - oldamount);
    }
    return TRUE;
d145 1
a145 1
 *  screen private machinery
d147 4
d152 5
a156 1
int  screenPrivateCount;
d158 1
a158 4
void
ResetScreenPrivates()
{
    screenPrivateCount = 0;
d161 2
a162 2
/* this can be called after some screens have been created,
 * so we have to worry about resizing existing devPrivates
d165 1
a165 1
AllocateScreenPrivateIndex()
d167 8
a174 15
    int		idx;
    int		i;
    ScreenPtr	pScreen;
    DevUnion	*nprivs;

    idx = screenPrivateCount++;
    for (i = 0; i < screenInfo.numScreens; i++)
    {
	pScreen = screenInfo.screens[i];
	nprivs = (DevUnion *)xrealloc(pScreen->devPrivates,
				      screenPrivateCount * sizeof(DevUnion));
	if (!nprivs)
	{
	    screenPrivateCount--;
	    return -1;
d176 1
a176 3
	/* Zero the new private */
	bzero(&nprivs[idx], sizeof(DevUnion));
	pScreen->devPrivates = nprivs;
d178 4
a181 1
    return idx;
a183 1

d185 1
a185 1
 *  window private machinery
d187 2
a188 5

static int  windowPrivateCount;

void
ResetWindowPrivates()
d190 11
a200 28
    windowPrivateCount = 0;
}

_X_EXPORT int
AllocateWindowPrivateIndex()
{
    return windowPrivateCount++;
}

_X_EXPORT Bool
AllocateWindowPrivate(register ScreenPtr pScreen, int index2, unsigned amount)
{
    unsigned oldamount;

    /* Round up sizes for proper alignment */
    amount = ((amount + (sizeof(long) - 1)) / sizeof(long)) * sizeof(long);

    if (index2 >= pScreen->WindowPrivateLen)
    {
	unsigned *nsizes;
	nsizes = (unsigned *)xrealloc(pScreen->WindowPrivateSizes,
				      (index2 + 1) * sizeof(unsigned));
	if (!nsizes)
	    return FALSE;
	while (pScreen->WindowPrivateLen <= index2)
	{
	    nsizes[pScreen->WindowPrivateLen++] = 0;
	    pScreen->totalWindowSize += sizeof(DevUnion);
a201 1
	pScreen->WindowPrivateSizes = nsizes;
d203 7
a209 5
    oldamount = pScreen->WindowPrivateSizes[index2];
    if (amount > oldamount)
    {
	pScreen->WindowPrivateSizes[index2] = amount;
	pScreen->totalWindowSize += (amount - oldamount);
a210 1
    return TRUE;
a212 1

d214 1
a214 1
 *  gc private machinery 
a215 9

static int  gcPrivateCount;

void
ResetGCPrivates()
{
    gcPrivateCount = 0;
}

d217 2
a218 7
AllocateGCPrivateIndex()
{
    return gcPrivateCount++;
}

_X_EXPORT Bool
AllocateGCPrivate(register ScreenPtr pScreen, int index2, unsigned amount)
d220 3
a222 11
    unsigned oldamount;

    /* Round up sizes for proper alignment */
    amount = ((amount + (sizeof(long) - 1)) / sizeof(long)) * sizeof(long);

    if (index2 >= pScreen->GCPrivateLen)
    {
	unsigned *nsizes;
	nsizes = (unsigned *)xrealloc(pScreen->GCPrivateSizes,
				      (index2 + 1) * sizeof(unsigned));
	if (!nsizes)
d224 1
a224 6
	while (pScreen->GCPrivateLen <= index2)
	{
	    nsizes[pScreen->GCPrivateLen++] = 0;
	    pScreen->totalGCSize += sizeof(DevUnion);
	}
	pScreen->GCPrivateSizes = nsizes;
d226 1
a226 20
    oldamount = pScreen->GCPrivateSizes[index2];
    if (amount > oldamount)
    {
	pScreen->GCPrivateSizes[index2] = amount;
	pScreen->totalGCSize += (amount - oldamount);
    }
    return TRUE;
}


/*
 *  pixmap private machinery
 */
#ifdef PIXPRIV
static int  pixmapPrivateCount;

void
ResetPixmapPrivates()
{
    pixmapPrivateCount = 0;
d230 2
a231 1
AllocatePixmapPrivateIndex()
d233 3
a235 17
    return pixmapPrivateCount++;
}

_X_EXPORT Bool
AllocatePixmapPrivate(register ScreenPtr pScreen, int index2, unsigned amount)
{
    unsigned oldamount;

    /* Round up sizes for proper alignment */
    amount = ((amount + (sizeof(long) - 1)) / sizeof(long)) * sizeof(long);

    if (index2 >= pScreen->PixmapPrivateLen)
    {
	unsigned *nsizes;
	nsizes = (unsigned *)xrealloc(pScreen->PixmapPrivateSizes,
				      (index2 + 1) * sizeof(unsigned));
	if (!nsizes)
d237 1
a237 6
	while (pScreen->PixmapPrivateLen <= index2)
	{
	    nsizes[pScreen->PixmapPrivateLen++] = 0;
	    pScreen->totalPixmapSize += sizeof(DevUnion);
	}
	pScreen->PixmapPrivateSizes = nsizes;
d239 1
a239 8
    oldamount = pScreen->PixmapPrivateSizes[index2];
    if (amount > oldamount)
    {
	pScreen->PixmapPrivateSizes[index2] = amount;
	pScreen->totalPixmapSize += (amount - oldamount);
    }
    pScreen->totalPixmapSize = BitmapBytePad(pScreen->totalPixmapSize * 8);
    return TRUE;
a240 1
#endif
d242 16
d260 1
a260 1
 *  colormap private machinery
d262 2
a263 5

int  colormapPrivateCount;

void
ResetColormapPrivates()
d265 1
a265 2
    colormapPrivateCount = 0;
}
d267 7
a273 43

_X_EXPORT int
AllocateColormapPrivateIndex (InitCmapPrivFunc initPrivFunc)
{
    int		index;
    int		i;
    ColormapPtr	pColormap;
    DevUnion	*privs;

    index = colormapPrivateCount++;

    for (i = 0; i < screenInfo.numScreens; i++)
    {
	/*
	 * AllocateColormapPrivateIndex may be called after the
	 * default colormap has been created on each screen!
	 *
	 * We must resize the devPrivates array for the default
	 * colormap on each screen, making room for this new private.
	 * We also call the initialization function 'initPrivFunc' on
	 * the new private allocated for each default colormap.
	 */

	ScreenPtr pScreen = screenInfo.screens[i];

	pColormap = (ColormapPtr) LookupIDByType (
	    pScreen->defColormap, RT_COLORMAP);

	if (pColormap)
	{
	    privs = (DevUnion *) xrealloc (pColormap->devPrivates,
		colormapPrivateCount * sizeof(DevUnion));
	    if (!privs) {
		colormapPrivateCount--;
		return -1;
	    }
	    bzero(&privs[index], sizeof(DevUnion));
	    pColormap->devPrivates = privs;
	    if (!(*initPrivFunc)(pColormap,index))
	    {
		colormapPrivateCount--;
		return -1;
	    }
d275 3
d280 2
a281 1
    return index;
a283 6
/*
 *  device private machinery
 */

static int devicePrivateIndex = 0;

d285 1
a285 1
AllocateDevicePrivateIndex()
d287 27
a313 25
    return devicePrivateIndex++;
}

_X_EXPORT Bool
AllocateDevicePrivate(DeviceIntPtr device, int index)
{
    if (device->nPrivates < ++index) {
	DevUnion *nprivs = (DevUnion *) xrealloc(device->devPrivates,
						 index * sizeof(DevUnion));
	if (!nprivs)
	    return FALSE;
	device->devPrivates = nprivs;
	bzero(&nprivs[device->nPrivates], sizeof(DevUnion)
	      * (index - device->nPrivates));
	device->nPrivates = index;
	return TRUE;
    } else {
	return TRUE;
    }
}

void
ResetDevicePrivateIndex(void)
{
    devicePrivateIndex = 0;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d63 1
a63 1
ResetExtensionPrivates(void)
d74 1
a74 1
AllocateExtensionPrivateIndex(void)
d120 1
a120 1
ResetClientPrivates(void)
d131 1
a131 1
AllocateClientPrivateIndex(void)
d174 1
a174 1
ResetScreenPrivates(void)
d183 1
a183 1
AllocateScreenPrivateIndex(void)
d216 1
a216 1
ResetWindowPrivates(void)
d222 1
a222 1
AllocateWindowPrivateIndex(void)
d228 1
a228 1
AllocateWindowPrivate(ScreenPtr pScreen, int index2, unsigned amount)
d266 1
a266 1
ResetGCPrivates(void)
d272 1
a272 1
AllocateGCPrivateIndex(void)
d278 1
a278 1
AllocateGCPrivate(ScreenPtr pScreen, int index2, unsigned amount)
d312 1
d316 1
a316 1
ResetPixmapPrivates(void)
d322 1
a322 1
AllocatePixmapPrivateIndex(void)
d328 1
a328 1
AllocatePixmapPrivate(ScreenPtr pScreen, int index2, unsigned amount)
d358 1
d368 1
a368 1
ResetColormapPrivates(void)
d429 1
a429 1
AllocateDevicePrivateIndex(void)
@

