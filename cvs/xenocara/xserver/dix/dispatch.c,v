head	1.17;
access;
symbols
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.2
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	s0SI41sEunLdyFfd;

1.16
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	7pAEtF6Y5EgemkuY;

1.15
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	Te1daavkBLskZ8gc;

1.14
date	2015.02.11.20.58.46;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	dgcmwPGRv39E4MF9;

1.13
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	vcnjRBuLQw44cPHf;

1.12
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	cVXoV5PxI8YrEaVA;

1.11
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2013.09.28.15.36.33;	author matthieu;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.31.07.52.35;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.12;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.22;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.22;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.18;	author matthieu;	state Exp;
branches;
next	;

1.10.2.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.11.2.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.17
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/************************************************************

Copyright 1987, 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

********************************************************/

/* The panoramix components contained the following notice */
/*****************************************************************

Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.

******************************************************************/

/* XSERVER_DTRACE additions:
 * Copyright (c) 2005-2006, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#include <version-config.h>
#endif

#ifdef PANORAMIX_DEBUG
#include <stdio.h>
int ProcInitialConnection();
#endif

#include "windowstr.h"
#include <X11/fonts/fontstruct.h>
#include <X11/fonts/fontutil.h>
#include "dixfontstr.h"
#include "gcstruct.h"
#include "selection.h"
#include "colormapst.h"
#include "cursorstr.h"
#include "scrnintstr.h"
#include "opaque.h"
#include "input.h"
#include "servermd.h"
#include "extnsionst.h"
#include "dixfont.h"
#include "dispatch.h"
#include "swaprep.h"
#include "swapreq.h"
#include "privates.h"
#include "xace.h"
#include "inputstr.h"
#include "xkbsrv.h"
#include "site.h"
#include "client.h"

#ifdef XSERVER_DTRACE
#include "registry.h"
#include "probes.h"
#endif

#define mskcnt ((MAXCLIENTS + 31) / 32)
#define BITMASK(i) (1U << ((i) & 31))
#define MASKIDX(i) ((i) >> 5)
#define MASKWORD(buf, i) buf[MASKIDX(i)]
#define BITSET(buf, i) MASKWORD(buf, i) |= BITMASK(i)
#define BITCLEAR(buf, i) MASKWORD(buf, i) &= ~BITMASK(i)
#define GETBIT(buf, i) (MASKWORD(buf, i) & BITMASK(i))

xConnSetupPrefix connSetupPrefix;

PaddingInfo PixmapWidthPaddingInfo[33];

static ClientPtr grabClient;

#define GrabNone 0
#define GrabActive 1
#define GrabKickout 2
static int grabState = GrabNone;
static long grabWaiters[mskcnt];
CallbackListPtr ServerGrabCallback = NULL;
HWEventQueuePtr checkForInput[2];
int connBlockScreenStart;

static void KillAllClients(void);

static int nextFreeClientID;    /* always MIN free client ID */

static int nClients;            /* number of authorized clients */

CallbackListPtr ClientStateCallback;

/* dispatchException & isItTimeToYield must be declared volatile since they
 * are modified by signal handlers - otherwise optimizer may assume it doesn't
 * need to actually check value in memory when used and may miss changes from
 * signal handlers.
 */
volatile char dispatchException = 0;
volatile char isItTimeToYield;

#define SAME_SCREENS(a, b) (\
    (a.pScreen == b.pScreen))

void
SetInputCheck(HWEventQueuePtr c0, HWEventQueuePtr c1)
{
    checkForInput[0] = c0;
    checkForInput[1] = c1;
}

void
UpdateCurrentTime(void)
{
    TimeStamp systime;

    /* To avoid time running backwards, we must call GetTimeInMillis before
     * calling ProcessInputEvents.
     */
    systime.months = currentTime.months;
    systime.milliseconds = GetTimeInMillis();
    if (systime.milliseconds < currentTime.milliseconds)
        systime.months++;
    if (*checkForInput[0] != *checkForInput[1])
        ProcessInputEvents();
    if (CompareTimeStamps(systime, currentTime) == LATER)
        currentTime = systime;
}

/* Like UpdateCurrentTime, but can't call ProcessInputEvents */
void
UpdateCurrentTimeIf(void)
{
    TimeStamp systime;

    systime.months = currentTime.months;
    systime.milliseconds = GetTimeInMillis();
    if (systime.milliseconds < currentTime.milliseconds)
        systime.months++;
    if (CompareTimeStamps(systime, currentTime) == LATER)
        currentTime = systime;
}

#undef SMART_DEBUG

/* in milliseconds */
#define SMART_SCHEDULE_DEFAULT_INTERVAL	5
#define SMART_SCHEDULE_MAX_SLICE	15

#if defined(WIN32) && !defined(__CYGWIN__)
Bool SmartScheduleDisable = TRUE;
#else
Bool SmartScheduleDisable = FALSE;
#endif
long SmartScheduleSlice = SMART_SCHEDULE_DEFAULT_INTERVAL;
long SmartScheduleInterval = SMART_SCHEDULE_DEFAULT_INTERVAL;
long SmartScheduleMaxSlice = SMART_SCHEDULE_MAX_SLICE;
long SmartScheduleTime;
int SmartScheduleLatencyLimited = 0;
static ClientPtr SmartLastClient;
static int SmartLastIndex[SMART_MAX_PRIORITY - SMART_MIN_PRIORITY + 1];

#ifdef SMART_DEBUG
long SmartLastPrint;
#endif

void Dispatch(void);

static int
SmartScheduleClient(int *clientReady, int nready)
{
    ClientPtr pClient;
    int i;
    int client;
    int bestPrio, best = 0;
    int bestRobin, robin;
    long now = SmartScheduleTime;
    long idle;

    bestPrio = -0x7fffffff;
    bestRobin = 0;
    idle = 2 * SmartScheduleSlice;
    for (i = 0; i < nready; i++) {
        client = clientReady[i];
        pClient = clients[client];
        /* Praise clients which haven't run in a while */
        if ((now - pClient->smart_stop_tick) >= idle) {
            if (pClient->smart_priority < 0)
                pClient->smart_priority++;
        }

        /* check priority to select best client */
        robin =
            (pClient->index -
             SmartLastIndex[pClient->smart_priority -
                            SMART_MIN_PRIORITY]) & 0xff;
        if (pClient->smart_priority > bestPrio ||
            (pClient->smart_priority == bestPrio && robin > bestRobin)) {
            bestPrio = pClient->smart_priority;
            bestRobin = robin;
            best = client;
        }
#ifdef SMART_DEBUG
        if ((now - SmartLastPrint) >= 5000)
            fprintf(stderr, " %2d: %3d", client, pClient->smart_priority);
#endif
    }
#ifdef SMART_DEBUG
    if ((now - SmartLastPrint) >= 5000) {
        fprintf(stderr, " use %2d\n", best);
        SmartLastPrint = now;
    }
#endif
    pClient = clients[best];
    SmartLastIndex[bestPrio - SMART_MIN_PRIORITY] = pClient->index;
    /*
     * Set current client pointer
     */
    if (SmartLastClient != pClient) {
        pClient->smart_start_tick = now;
        SmartLastClient = pClient;
    }
    /*
     * Adjust slice
     */
    if (nready == 1 && SmartScheduleLatencyLimited == 0) {
        /*
         * If it's been a long time since another client
         * has run, bump the slice up to get maximal
         * performance from a single client
         */
        if ((now - pClient->smart_start_tick) > 1000 &&
            SmartScheduleSlice < SmartScheduleMaxSlice) {
            SmartScheduleSlice += SmartScheduleInterval;
        }
    }
    else {
        SmartScheduleSlice = SmartScheduleInterval;
    }
    return best;
}

void
EnableLimitedSchedulingLatency(void)
{
    ++SmartScheduleLatencyLimited;
    SmartScheduleSlice = SmartScheduleInterval;
}

void
DisableLimitedSchedulingLatency(void)
{
    --SmartScheduleLatencyLimited;

    /* protect against bugs */
    if (SmartScheduleLatencyLimited < 0)
        SmartScheduleLatencyLimited = 0;
}

void
Dispatch(void)
{
    int *clientReady;           /* array of request ready clients */
    int result;
    ClientPtr client;
    int nready;
    HWEventQueuePtr *icheck = checkForInput;
    long start_tick;

    nextFreeClientID = 1;
    nClients = 0;

    clientReady = xallocarray(MaxClients, sizeof(int));
    if (!clientReady)
        return;

    SmartScheduleSlice = SmartScheduleInterval;
    while (!dispatchException) {
        if (*icheck[0] != *icheck[1]) {
            ProcessInputEvents();
            FlushIfCriticalOutputPending();
        }

        nready = WaitForSomething(clientReady);

        if (nready && !SmartScheduleDisable) {
            clientReady[0] = SmartScheduleClient(clientReady, nready);
            nready = 1;
        }
       /*****************
	*  Handle events in round robin fashion, doing input between
	*  each round
	*****************/

        while (!dispatchException && (--nready >= 0)) {
            client = clients[clientReady[nready]];
            if (!client) {
                /* KillClient can cause this to happen */
                continue;
            }
            /* GrabServer activation can cause this to be true */
            if (grabState == GrabKickout) {
                grabState = GrabActive;
                break;
            }
            isItTimeToYield = FALSE;

            start_tick = SmartScheduleTime;
            while (!isItTimeToYield) {
                if (*icheck[0] != *icheck[1])
                    ProcessInputEvents();

                FlushIfCriticalOutputPending();
                if (!SmartScheduleDisable &&
                    (SmartScheduleTime - start_tick) >= SmartScheduleSlice) {
                    /* Penalize clients which consume ticks */
                    if (client->smart_priority > SMART_MIN_PRIORITY)
                        client->smart_priority--;
                    break;
                }
                /* now, finally, deal with client requests */

                /* Update currentTime so request time checks, such as for input
                 * device grabs, are calculated correctly */
                UpdateCurrentTimeIf();
                result = ReadRequestFromClient(client);
                if (result <= 0) {
                    if (result < 0)
                        CloseDownClient(client);
                    break;
                }

                client->sequence++;
                client->majorOp = ((xReq *) client->requestBuffer)->reqType;
                client->minorOp = 0;
                if (client->majorOp >= EXTENSION_BASE) {
                    ExtensionEntry *ext = GetExtensionEntry(client->majorOp);

                    if (ext)
                        client->minorOp = ext->MinorOpcode(client);
                }
#ifdef XSERVER_DTRACE
                if (XSERVER_REQUEST_START_ENABLED())
                    XSERVER_REQUEST_START(LookupMajorName(client->majorOp),
                                          client->majorOp,
                                          ((xReq *) client->requestBuffer)->length,
                                          client->index,
                                          client->requestBuffer);
#endif
                if (result > (maxBigRequestSize << 2))
                    result = BadLength;
                else {
                    result = XaceHookDispatch(client, client->majorOp);
                    if (result == Success)
                        result =
                            (*client->requestVector[client->majorOp]) (client);
                    XaceHookAuditEnd(client, result);
                }
#ifdef XSERVER_DTRACE
                if (XSERVER_REQUEST_DONE_ENABLED())
                    XSERVER_REQUEST_DONE(LookupMajorName(client->majorOp),
                                         client->majorOp, client->sequence,
                                         client->index, result);
#endif

                if (client->noClientException != Success) {
                    CloseDownClient(client);
                    break;
                }
                else if (result != Success) {
                    SendErrorToClient(client, client->majorOp,
                                      client->minorOp,
                                      client->errorValue, result);
                    break;
                }
            }
            FlushAllOutput();
            client = clients[clientReady[nready]];
            if (client)
                client->smart_stop_tick = SmartScheduleTime;
        }
        dispatchException &= ~DE_PRIORITYCHANGE;
    }
#if defined(DDXBEFORERESET)
    ddxBeforeReset();
#endif
    KillAllClients();
    free(clientReady);
    dispatchException &= ~DE_RESET;
    SmartScheduleLatencyLimited = 0;
    ResetOsBuffers();
}

static int VendorRelease = VENDOR_RELEASE;
static const char *VendorString = VENDOR_NAME;

void
SetVendorRelease(int release)
{
    VendorRelease = release;
}

void
SetVendorString(const char *vendor)
{
    VendorString = vendor;
}

Bool
CreateConnectionBlock(void)
{
    xConnSetup setup;
    xWindowRoot root;
    xDepth depth;
    xVisualType visual;
    xPixmapFormat format;
    unsigned long vid;
    int i, j, k, lenofblock, sizesofar = 0;
    char *pBuf;

    memset(&setup, 0, sizeof(xConnSetup));
    /* Leave off the ridBase and ridMask, these must be sent with
       connection */

    setup.release = VendorRelease;
    /*
     * per-server image and bitmap parameters are defined in Xmd.h
     */
    setup.imageByteOrder = screenInfo.imageByteOrder;

    setup.bitmapScanlineUnit = screenInfo.bitmapScanlineUnit;
    setup.bitmapScanlinePad = screenInfo.bitmapScanlinePad;

    setup.bitmapBitOrder = screenInfo.bitmapBitOrder;
    setup.motionBufferSize = NumMotionEvents();
    setup.numRoots = screenInfo.numScreens;
    setup.nbytesVendor = strlen(VendorString);
    setup.numFormats = screenInfo.numPixmapFormats;
    setup.maxRequestSize = MAX_REQUEST_SIZE;
    QueryMinMaxKeyCodes(&setup.minKeyCode, &setup.maxKeyCode);

    lenofblock = sizeof(xConnSetup) +
        pad_to_int32(setup.nbytesVendor) +
        (setup.numFormats * sizeof(xPixmapFormat)) +
        (setup.numRoots * sizeof(xWindowRoot));
    ConnectionInfo = malloc(lenofblock);
    if (!ConnectionInfo)
        return FALSE;

    memmove(ConnectionInfo, (char *) &setup, sizeof(xConnSetup));
    sizesofar = sizeof(xConnSetup);
    pBuf = ConnectionInfo + sizeof(xConnSetup);

    memmove(pBuf, VendorString, (int) setup.nbytesVendor);
    sizesofar += setup.nbytesVendor;
    pBuf += setup.nbytesVendor;
    i = padding_for_int32(setup.nbytesVendor);
    sizesofar += i;
    while (--i >= 0)
        *pBuf++ = 0;

    memset(&format, 0, sizeof(xPixmapFormat));
    for (i = 0; i < screenInfo.numPixmapFormats; i++) {
        format.depth = screenInfo.formats[i].depth;
        format.bitsPerPixel = screenInfo.formats[i].bitsPerPixel;
        format.scanLinePad = screenInfo.formats[i].scanlinePad;
        memmove(pBuf, (char *) &format, sizeof(xPixmapFormat));
        pBuf += sizeof(xPixmapFormat);
        sizesofar += sizeof(xPixmapFormat);
    }

    connBlockScreenStart = sizesofar;
    memset(&depth, 0, sizeof(xDepth));
    memset(&visual, 0, sizeof(xVisualType));
    for (i = 0; i < screenInfo.numScreens; i++) {
        ScreenPtr pScreen;
        DepthPtr pDepth;
        VisualPtr pVisual;

        pScreen = screenInfo.screens[i];
        root.windowId = pScreen->root->drawable.id;
        root.defaultColormap = pScreen->defColormap;
        root.whitePixel = pScreen->whitePixel;
        root.blackPixel = pScreen->blackPixel;
        root.currentInputMask = 0;      /* filled in when sent */
        root.pixWidth = pScreen->width;
        root.pixHeight = pScreen->height;
        root.mmWidth = pScreen->mmWidth;
        root.mmHeight = pScreen->mmHeight;
        root.minInstalledMaps = pScreen->minInstalledCmaps;
        root.maxInstalledMaps = pScreen->maxInstalledCmaps;
        root.rootVisualID = pScreen->rootVisual;
        root.backingStore = pScreen->backingStoreSupport;
        root.saveUnders = FALSE;
        root.rootDepth = pScreen->rootDepth;
        root.nDepths = pScreen->numDepths;
        memmove(pBuf, (char *) &root, sizeof(xWindowRoot));
        sizesofar += sizeof(xWindowRoot);
        pBuf += sizeof(xWindowRoot);

        pDepth = pScreen->allowedDepths;
        for (j = 0; j < pScreen->numDepths; j++, pDepth++) {
            lenofblock += sizeof(xDepth) +
                (pDepth->numVids * sizeof(xVisualType));
            pBuf = (char *) realloc(ConnectionInfo, lenofblock);
            if (!pBuf) {
                free(ConnectionInfo);
                return FALSE;
            }
            ConnectionInfo = pBuf;
            pBuf += sizesofar;
            depth.depth = pDepth->depth;
            depth.nVisuals = pDepth->numVids;
            memmove(pBuf, (char *) &depth, sizeof(xDepth));
            pBuf += sizeof(xDepth);
            sizesofar += sizeof(xDepth);
            for (k = 0; k < pDepth->numVids; k++) {
                vid = pDepth->vids[k];
                for (pVisual = pScreen->visuals;
                     pVisual->vid != vid; pVisual++);
                visual.visualID = vid;
                visual.class = pVisual->class;
                visual.bitsPerRGB = pVisual->bitsPerRGBValue;
                visual.colormapEntries = pVisual->ColormapEntries;
                visual.redMask = pVisual->redMask;
                visual.greenMask = pVisual->greenMask;
                visual.blueMask = pVisual->blueMask;
                memmove(pBuf, (char *) &visual, sizeof(xVisualType));
                pBuf += sizeof(xVisualType);
                sizesofar += sizeof(xVisualType);
            }
        }
    }
    connSetupPrefix.success = xTrue;
    connSetupPrefix.length = lenofblock / 4;
    connSetupPrefix.majorVersion = X_PROTOCOL;
    connSetupPrefix.minorVersion = X_PROTOCOL_REVISION;
    return TRUE;
}

int
ProcBadRequest(ClientPtr client)
{
    return BadRequest;
}

int
ProcCreateWindow(ClientPtr client)
{
    WindowPtr pParent, pWin;

    REQUEST(xCreateWindowReq);
    int len, rc;

    REQUEST_AT_LEAST_SIZE(xCreateWindowReq);

    LEGAL_NEW_RESOURCE(stuff->wid, client);
    rc = dixLookupWindow(&pParent, stuff->parent, client, DixAddAccess);
    if (rc != Success)
        return rc;
    len = client->req_len - bytes_to_int32(sizeof(xCreateWindowReq));
    if (Ones(stuff->mask) != len)
        return BadLength;
    if (!stuff->width || !stuff->height) {
        client->errorValue = 0;
        return BadValue;
    }
    pWin = CreateWindow(stuff->wid, pParent, stuff->x,
                        stuff->y, stuff->width, stuff->height,
                        stuff->borderWidth, stuff->class,
                        stuff->mask, (XID *) &stuff[1],
                        (int) stuff->depth, client, stuff->visual, &rc);
    if (pWin) {
        Mask mask = pWin->eventMask;

        pWin->eventMask = 0;    /* subterfuge in case AddResource fails */
        if (!AddResource(stuff->wid, RT_WINDOW, (void *) pWin))
            return BadAlloc;
        pWin->eventMask = mask;
    }
    return rc;
}

int
ProcChangeWindowAttributes(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xChangeWindowAttributesReq);
    int len, rc;
    Mask access_mode = 0;

    REQUEST_AT_LEAST_SIZE(xChangeWindowAttributesReq);
    access_mode |= (stuff->valueMask & CWEventMask) ? DixReceiveAccess : 0;
    access_mode |= (stuff->valueMask & ~CWEventMask) ? DixSetAttrAccess : 0;
    rc = dixLookupWindow(&pWin, stuff->window, client, access_mode);
    if (rc != Success)
        return rc;
    len = client->req_len - bytes_to_int32(sizeof(xChangeWindowAttributesReq));
    if (len != Ones(stuff->valueMask))
        return BadLength;
    return ChangeWindowAttributes(pWin,
                                  stuff->valueMask, (XID *) &stuff[1], client);
}

int
ProcGetWindowAttributes(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xResourceReq);
    xGetWindowAttributesReply wa;
    int rc;

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupWindow(&pWin, stuff->id, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    memset(&wa, 0, sizeof(xGetWindowAttributesReply));
    GetWindowAttributes(pWin, client, &wa);
    WriteReplyToClient(client, sizeof(xGetWindowAttributesReply), &wa);
    return Success;
}

int
ProcDestroyWindow(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xResourceReq);
    int rc;

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupWindow(&pWin, stuff->id, client, DixDestroyAccess);
    if (rc != Success)
        return rc;
    if (pWin->parent) {
        rc = dixLookupWindow(&pWin, pWin->parent->drawable.id, client,
                             DixRemoveAccess);
        if (rc != Success)
            return rc;
        FreeResource(stuff->id, RT_NONE);
    }
    return Success;
}

int
ProcDestroySubwindows(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xResourceReq);
    int rc;

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupWindow(&pWin, stuff->id, client, DixRemoveAccess);
    if (rc != Success)
        return rc;
    DestroySubwindows(pWin, client);
    return Success;
}

int
ProcChangeSaveSet(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xChangeSaveSetReq);
    int rc;

    REQUEST_SIZE_MATCH(xChangeSaveSetReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixManageAccess);
    if (rc != Success)
        return rc;
    if (client->clientAsMask == (CLIENT_BITS(pWin->drawable.id)))
        return BadMatch;
    if ((stuff->mode == SetModeInsert) || (stuff->mode == SetModeDelete))
        return AlterSaveSetForClient(client, pWin, stuff->mode, FALSE, TRUE);
    client->errorValue = stuff->mode;
    return BadValue;
}

int
ProcReparentWindow(ClientPtr client)
{
    WindowPtr pWin, pParent;

    REQUEST(xReparentWindowReq);
    int rc;

    REQUEST_SIZE_MATCH(xReparentWindowReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixManageAccess);
    if (rc != Success)
        return rc;
    rc = dixLookupWindow(&pParent, stuff->parent, client, DixAddAccess);
    if (rc != Success)
        return rc;
    if (!SAME_SCREENS(pWin->drawable, pParent->drawable))
        return BadMatch;
    if ((pWin->backgroundState == ParentRelative) &&
        (pParent->drawable.depth != pWin->drawable.depth))
        return BadMatch;
    if ((pWin->drawable.class != InputOnly) &&
        (pParent->drawable.class == InputOnly))
        return BadMatch;
    return ReparentWindow(pWin, pParent,
                          (short) stuff->x, (short) stuff->y, client);
}

int
ProcMapWindow(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xResourceReq);
    int rc;

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupWindow(&pWin, stuff->id, client, DixShowAccess);
    if (rc != Success)
        return rc;
    MapWindow(pWin, client);
    /* update cache to say it is mapped */
    return Success;
}

int
ProcMapSubwindows(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xResourceReq);
    int rc;

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupWindow(&pWin, stuff->id, client, DixListAccess);
    if (rc != Success)
        return rc;
    MapSubwindows(pWin, client);
    /* update cache to say it is mapped */
    return Success;
}

int
ProcUnmapWindow(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xResourceReq);
    int rc;

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupWindow(&pWin, stuff->id, client, DixHideAccess);
    if (rc != Success)
        return rc;
    UnmapWindow(pWin, FALSE);
    /* update cache to say it is mapped */
    return Success;
}

int
ProcUnmapSubwindows(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xResourceReq);
    int rc;

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupWindow(&pWin, stuff->id, client, DixListAccess);
    if (rc != Success)
        return rc;
    UnmapSubwindows(pWin);
    return Success;
}

int
ProcConfigureWindow(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xConfigureWindowReq);
    int len, rc;

    REQUEST_AT_LEAST_SIZE(xConfigureWindowReq);
    rc = dixLookupWindow(&pWin, stuff->window, client,
                         DixManageAccess | DixSetAttrAccess);
    if (rc != Success)
        return rc;
    len = client->req_len - bytes_to_int32(sizeof(xConfigureWindowReq));
    if (Ones((Mask) stuff->mask) != len)
        return BadLength;
    return ConfigureWindow(pWin, (Mask) stuff->mask, (XID *) &stuff[1], client);
}

int
ProcCirculateWindow(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xCirculateWindowReq);
    int rc;

    REQUEST_SIZE_MATCH(xCirculateWindowReq);
    if ((stuff->direction != RaiseLowest) && (stuff->direction != LowerHighest)) {
        client->errorValue = stuff->direction;
        return BadValue;
    }
    rc = dixLookupWindow(&pWin, stuff->window, client, DixManageAccess);
    if (rc != Success)
        return rc;
    CirculateWindow(pWin, (int) stuff->direction, client);
    return Success;
}

static int
GetGeometry(ClientPtr client, xGetGeometryReply * rep)
{
    DrawablePtr pDraw;
    int rc;

    REQUEST(xResourceReq);
    REQUEST_SIZE_MATCH(xResourceReq);

    rc = dixLookupDrawable(&pDraw, stuff->id, client, M_ANY, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep->type = X_Reply;
    rep->length = 0;
    rep->sequenceNumber = client->sequence;
    rep->root = pDraw->pScreen->root->drawable.id;
    rep->depth = pDraw->depth;
    rep->width = pDraw->width;
    rep->height = pDraw->height;

    if (WindowDrawable(pDraw->type)) {
        WindowPtr pWin = (WindowPtr) pDraw;

        rep->x = pWin->origin.x - wBorderWidth(pWin);
        rep->y = pWin->origin.y - wBorderWidth(pWin);
        rep->borderWidth = pWin->borderWidth;
    }
    else {                      /* DRAWABLE_PIXMAP */

        rep->x = rep->y = rep->borderWidth = 0;
    }

    return Success;
}

int
ProcGetGeometry(ClientPtr client)
{
    xGetGeometryReply rep = { .type = X_Reply };
    int status;

    if ((status = GetGeometry(client, &rep)) != Success)
        return status;

    WriteReplyToClient(client, sizeof(xGetGeometryReply), &rep);
    return Success;
}

int
ProcQueryTree(ClientPtr client)
{
    xQueryTreeReply reply;
    int rc, numChildren = 0;
    WindowPtr pChild, pWin, pHead;
    Window *childIDs = (Window *) NULL;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupWindow(&pWin, stuff->id, client, DixListAccess);
    if (rc != Success)
        return rc;

    reply = (xQueryTreeReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .root = pWin->drawable.pScreen->root->drawable.id,
        .parent = (pWin->parent) ? pWin->parent->drawable.id : (Window) None
    };
    pHead = RealChildHead(pWin);
    for (pChild = pWin->lastChild; pChild != pHead; pChild = pChild->prevSib)
        numChildren++;
    if (numChildren) {
        int curChild = 0;

        childIDs = xallocarray(numChildren, sizeof(Window));
        if (!childIDs)
            return BadAlloc;
        for (pChild = pWin->lastChild; pChild != pHead;
             pChild = pChild->prevSib)
            childIDs[curChild++] = pChild->drawable.id;
    }

    reply.nChildren = numChildren;
    reply.length = bytes_to_int32(numChildren * sizeof(Window));

    WriteReplyToClient(client, sizeof(xQueryTreeReply), &reply);
    if (numChildren) {
        client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
        WriteSwappedDataToClient(client, numChildren * sizeof(Window),
                                 childIDs);
        free(childIDs);
    }

    return Success;
}

int
ProcInternAtom(ClientPtr client)
{
    Atom atom;
    char *tchar;

    REQUEST(xInternAtomReq);

    REQUEST_FIXED_SIZE(xInternAtomReq, stuff->nbytes);
    if ((stuff->onlyIfExists != xTrue) && (stuff->onlyIfExists != xFalse)) {
        client->errorValue = stuff->onlyIfExists;
        return BadValue;
    }
    tchar = (char *) &stuff[1];
    atom = MakeAtom(tchar, stuff->nbytes, !stuff->onlyIfExists);
    if (atom != BAD_RESOURCE) {
        xInternAtomReply reply = {
            .type = X_Reply,
            .sequenceNumber = client->sequence,
            .length = 0,
            .atom = atom
        };
        WriteReplyToClient(client, sizeof(xInternAtomReply), &reply);
        return Success;
    }
    else
        return BadAlloc;
}

int
ProcGetAtomName(ClientPtr client)
{
    const char *str;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    if ((str = NameForAtom(stuff->id))) {
        int len = strlen(str);
        xGetAtomNameReply reply = {
            .type = X_Reply,
            .sequenceNumber = client->sequence,
            .length = bytes_to_int32(len),
            .nameLength = len
        };

        WriteReplyToClient(client, sizeof(xGetAtomNameReply), &reply);
        WriteToClient(client, len, str);
        return Success;
    }
    else {
        client->errorValue = stuff->id;
        return BadAtom;
    }
}

int
ProcGrabServer(ClientPtr client)
{
    int rc;

    REQUEST_SIZE_MATCH(xReq);
    if (grabState != GrabNone && client != grabClient) {
        ResetCurrentRequest(client);
        client->sequence--;
        BITSET(grabWaiters, client->index);
        IgnoreClient(client);
        return Success;
    }
    rc = OnlyListenToOneClient(client);
    if (rc != Success)
        return rc;
    grabState = GrabKickout;
    grabClient = client;

    if (ServerGrabCallback) {
        ServerGrabInfoRec grabinfo;

        grabinfo.client = client;
        grabinfo.grabstate = SERVER_GRABBED;
        CallCallbacks(&ServerGrabCallback, (void *) &grabinfo);
    }

    return Success;
}

static void
UngrabServer(ClientPtr client)
{
    int i;

    grabState = GrabNone;
    ListenToAllClients();
    for (i = mskcnt; --i >= 0 && !grabWaiters[i];);
    if (i >= 0) {
        i <<= 5;
        while (!GETBIT(grabWaiters, i))
            i++;
        BITCLEAR(grabWaiters, i);
        AttendClient(clients[i]);
    }

    if (ServerGrabCallback) {
        ServerGrabInfoRec grabinfo;

        grabinfo.client = client;
        grabinfo.grabstate = SERVER_UNGRABBED;
        CallCallbacks(&ServerGrabCallback, (void *) &grabinfo);
    }
}

int
ProcUngrabServer(ClientPtr client)
{
    REQUEST_SIZE_MATCH(xReq);
    UngrabServer(client);
    return Success;
}

int
ProcTranslateCoords(ClientPtr client)
{
    REQUEST(xTranslateCoordsReq);

    WindowPtr pWin, pDst;
    xTranslateCoordsReply rep;
    int rc;

    REQUEST_SIZE_MATCH(xTranslateCoordsReq);
    rc = dixLookupWindow(&pWin, stuff->srcWid, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    rc = dixLookupWindow(&pDst, stuff->dstWid, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep = (xTranslateCoordsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    if (!SAME_SCREENS(pWin->drawable, pDst->drawable)) {
        rep.sameScreen = xFalse;
        rep.child = None;
        rep.dstX = rep.dstY = 0;
    }
    else {
        INT16 x, y;

        rep.sameScreen = xTrue;
        rep.child = None;
        /* computing absolute coordinates -- adjust to destination later */
        x = pWin->drawable.x + stuff->srcX;
        y = pWin->drawable.y + stuff->srcY;
        pWin = pDst->firstChild;
        while (pWin) {
            BoxRec box;

            if ((pWin->mapped) &&
                (x >= pWin->drawable.x - wBorderWidth(pWin)) &&
                (x < pWin->drawable.x + (int) pWin->drawable.width +
                 wBorderWidth(pWin)) &&
                (y >= pWin->drawable.y - wBorderWidth(pWin)) &&
                (y < pWin->drawable.y + (int) pWin->drawable.height +
                 wBorderWidth(pWin))
                /* When a window is shaped, a further check
                 * is made to see if the point is inside
                 * borderSize
                 */
                && (!wBoundingShape(pWin) ||
                    RegionContainsPoint(&pWin->borderSize, x, y, &box))

                && (!wInputShape(pWin) ||
                    RegionContainsPoint(wInputShape(pWin),
                                        x - pWin->drawable.x,
                                        y - pWin->drawable.y, &box))
                ) {
                rep.child = pWin->drawable.id;
                pWin = (WindowPtr) NULL;
            }
            else
                pWin = pWin->nextSib;
        }
        /* adjust to destination coordinates */
        rep.dstX = x - pDst->drawable.x;
        rep.dstY = y - pDst->drawable.y;
    }
    WriteReplyToClient(client, sizeof(xTranslateCoordsReply), &rep);
    return Success;
}

int
ProcOpenFont(ClientPtr client)
{
    int err;

    REQUEST(xOpenFontReq);

    REQUEST_FIXED_SIZE(xOpenFontReq, stuff->nbytes);
    client->errorValue = stuff->fid;
    LEGAL_NEW_RESOURCE(stuff->fid, client);
    err = OpenFont(client, stuff->fid, (Mask) 0,
                   stuff->nbytes, (char *) &stuff[1]);
    if (err == Success) {
        return Success;
    }
    else
        return err;
}

int
ProcCloseFont(ClientPtr client)
{
    FontPtr pFont;
    int rc;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupResourceByType((void **) &pFont, stuff->id, RT_FONT,
                                 client, DixDestroyAccess);
    if (rc == Success) {
        FreeResource(stuff->id, RT_NONE);
        return Success;
    }
    else {
        client->errorValue = stuff->id;
        return rc;
    }
}

int
ProcQueryFont(ClientPtr client)
{
    xQueryFontReply *reply;
    FontPtr pFont;
    int rc;

    REQUEST(xResourceReq);
    REQUEST_SIZE_MATCH(xResourceReq);

    rc = dixLookupFontable(&pFont, stuff->id, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    {
        xCharInfo *pmax = FONTINKMAX(pFont);
        xCharInfo *pmin = FONTINKMIN(pFont);
        int nprotoxcistructs;
        int rlength;

        nprotoxcistructs = (pmax->rightSideBearing == pmin->rightSideBearing &&
                            pmax->leftSideBearing == pmin->leftSideBearing &&
                            pmax->descent == pmin->descent &&
                            pmax->ascent == pmin->ascent &&
                            pmax->characterWidth == pmin->characterWidth) ?
            0 : N2dChars(pFont);

        rlength = sizeof(xQueryFontReply) +
            FONTINFONPROPS(FONTCHARSET(pFont)) * sizeof(xFontProp) +
            nprotoxcistructs * sizeof(xCharInfo);
        reply = calloc(1, rlength);
        if (!reply) {
            return BadAlloc;
        }

        reply->type = X_Reply;
        reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
        reply->sequenceNumber = client->sequence;
        QueryFont(pFont, reply, nprotoxcistructs);

        WriteReplyToClient(client, rlength, reply);
        free(reply);
        return Success;
    }
}

int
ProcQueryTextExtents(ClientPtr client)
{
    xQueryTextExtentsReply reply;
    FontPtr pFont;
    ExtentInfoRec info;
    unsigned long length;
    int rc;

    REQUEST(xQueryTextExtentsReq);
    REQUEST_AT_LEAST_SIZE(xQueryTextExtentsReq);

    rc = dixLookupFontable(&pFont, stuff->fid, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    length = client->req_len - bytes_to_int32(sizeof(xQueryTextExtentsReq));
    length = length << 1;
    if (stuff->oddLength) {
        if (length == 0)
            return BadLength;
        length--;
    }
    if (!QueryTextExtents(pFont, length, (unsigned char *) &stuff[1], &info))
        return BadAlloc;
    reply = (xQueryTextExtentsReply) {
        .type = X_Reply,
        .drawDirection = info.drawDirection,
        .sequenceNumber = client->sequence,
        .length = 0,
        .fontAscent = info.fontAscent,
        .fontDescent = info.fontDescent,
        .overallAscent = info.overallAscent,
        .overallDescent = info.overallDescent,
        .overallWidth = info.overallWidth,
        .overallLeft = info.overallLeft,
        .overallRight = info.overallRight
    };
    WriteReplyToClient(client, sizeof(xQueryTextExtentsReply), &reply);
    return Success;
}

int
ProcListFonts(ClientPtr client)
{
    REQUEST(xListFontsReq);

    REQUEST_FIXED_SIZE(xListFontsReq, stuff->nbytes);

    return ListFonts(client, (unsigned char *) &stuff[1], stuff->nbytes,
                     stuff->maxNames);
}

int
ProcListFontsWithInfo(ClientPtr client)
{
    REQUEST(xListFontsWithInfoReq);

    REQUEST_FIXED_SIZE(xListFontsWithInfoReq, stuff->nbytes);

    return StartListFontsWithInfo(client, stuff->nbytes,
                                  (unsigned char *) &stuff[1], stuff->maxNames);
}

/**
 *
 *  \param value must conform to DeleteType
 */
int
dixDestroyPixmap(void *value, XID pid)
{
    PixmapPtr pPixmap = (PixmapPtr) value;

    return (*pPixmap->drawable.pScreen->DestroyPixmap) (pPixmap);
}

int
ProcCreatePixmap(ClientPtr client)
{
    PixmapPtr pMap;
    DrawablePtr pDraw;

    REQUEST(xCreatePixmapReq);
    DepthPtr pDepth;
    int i, rc;

    REQUEST_SIZE_MATCH(xCreatePixmapReq);
    client->errorValue = stuff->pid;
    LEGAL_NEW_RESOURCE(stuff->pid, client);

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
                           DixGetAttrAccess);
    if (rc != Success)
        return rc;

    if (!stuff->width || !stuff->height) {
        client->errorValue = 0;
        return BadValue;
    }
    if (stuff->width > 32767 || stuff->height > 32767) {
        /* It is allowed to try and allocate a pixmap which is larger than
         * 32767 in either dimension. However, all of the framebuffer code
         * is buggy and does not reliably draw to such big pixmaps, basically
         * because the Region data structure operates with signed shorts
         * for the rectangles in it.
         *
         * Furthermore, several places in the X server computes the
         * size in bytes of the pixmap and tries to store it in an
         * integer. This integer can overflow and cause the allocated size
         * to be much smaller.
         *
         * So, such big pixmaps are rejected here with a BadAlloc
         */
        return BadAlloc;
    }
    if (stuff->depth != 1) {
        pDepth = pDraw->pScreen->allowedDepths;
        for (i = 0; i < pDraw->pScreen->numDepths; i++, pDepth++)
            if (pDepth->depth == stuff->depth)
                goto CreatePmap;
        client->errorValue = stuff->depth;
        return BadValue;
    }
 CreatePmap:
    pMap = (PixmapPtr) (*pDraw->pScreen->CreatePixmap)
        (pDraw->pScreen, stuff->width, stuff->height, stuff->depth, 0);
    if (pMap) {
        pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
        pMap->drawable.id = stuff->pid;
        /* security creation/labeling check */
        rc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, RT_PIXMAP,
                      pMap, RT_NONE, NULL, DixCreateAccess);
        if (rc != Success) {
            (*pDraw->pScreen->DestroyPixmap) (pMap);
            return rc;
        }
        if (AddResource(stuff->pid, RT_PIXMAP, (void *) pMap))
            return Success;
    }
    return BadAlloc;
}

int
ProcFreePixmap(ClientPtr client)
{
    PixmapPtr pMap;
    int rc;

    REQUEST(xResourceReq);
    REQUEST_SIZE_MATCH(xResourceReq);

    rc = dixLookupResourceByType((void **) &pMap, stuff->id, RT_PIXMAP,
                                 client, DixDestroyAccess);
    if (rc == Success) {
        FreeResource(stuff->id, RT_NONE);
        return Success;
    }
    else {
        client->errorValue = stuff->id;
        return rc;
    }
}

int
ProcCreateGC(ClientPtr client)
{
    int error, rc;
    GC *pGC;
    DrawablePtr pDraw;
    unsigned len;

    REQUEST(xCreateGCReq);

    REQUEST_AT_LEAST_SIZE(xCreateGCReq);
    client->errorValue = stuff->gc;
    LEGAL_NEW_RESOURCE(stuff->gc, client);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
                           DixGetAttrAccess);
    if (rc != Success)
        return rc;

    len = client->req_len - bytes_to_int32(sizeof(xCreateGCReq));
    if (len != Ones(stuff->mask))
        return BadLength;
    pGC = (GC *) CreateGC(pDraw, stuff->mask, (XID *) &stuff[1], &error,
                          stuff->gc, client);
    if (error != Success)
        return error;
    if (!AddResource(stuff->gc, RT_GC, (void *) pGC))
        return BadAlloc;
    return Success;
}

int
ProcChangeGC(ClientPtr client)
{
    GC *pGC;
    int result;
    unsigned len;

    REQUEST(xChangeGCReq);
    REQUEST_AT_LEAST_SIZE(xChangeGCReq);

    result = dixLookupGC(&pGC, stuff->gc, client, DixSetAttrAccess);
    if (result != Success)
        return result;

    len = client->req_len - bytes_to_int32(sizeof(xChangeGCReq));
    if (len != Ones(stuff->mask))
        return BadLength;

    return ChangeGCXIDs(client, pGC, stuff->mask, (CARD32 *) &stuff[1]);
}

int
ProcCopyGC(ClientPtr client)
{
    GC *dstGC;
    GC *pGC;
    int result;

    REQUEST(xCopyGCReq);
    REQUEST_SIZE_MATCH(xCopyGCReq);

    result = dixLookupGC(&pGC, stuff->srcGC, client, DixGetAttrAccess);
    if (result != Success)
        return result;
    result = dixLookupGC(&dstGC, stuff->dstGC, client, DixSetAttrAccess);
    if (result != Success)
        return result;
    if ((dstGC->pScreen != pGC->pScreen) || (dstGC->depth != pGC->depth))
        return BadMatch;
    if (stuff->mask & ~GCAllBits) {
        client->errorValue = stuff->mask;
        return BadValue;
    }
    return CopyGC(pGC, dstGC, stuff->mask);
}

int
ProcSetDashes(ClientPtr client)
{
    GC *pGC;
    int result;

    REQUEST(xSetDashesReq);

    REQUEST_FIXED_SIZE(xSetDashesReq, stuff->nDashes);
    if (stuff->nDashes == 0) {
        client->errorValue = 0;
        return BadValue;
    }

    result = dixLookupGC(&pGC, stuff->gc, client, DixSetAttrAccess);
    if (result != Success)
        return result;

    /* If there's an error, either there's no sensible errorValue,
     * or there was a dash segment of 0. */
    client->errorValue = 0;
    return SetDashes(pGC, stuff->dashOffset, stuff->nDashes,
                     (unsigned char *) &stuff[1]);
}

int
ProcSetClipRectangles(ClientPtr client)
{
    int nr, result;
    GC *pGC;

    REQUEST(xSetClipRectanglesReq);

    REQUEST_AT_LEAST_SIZE(xSetClipRectanglesReq);
    if ((stuff->ordering != Unsorted) && (stuff->ordering != YSorted) &&
        (stuff->ordering != YXSorted) && (stuff->ordering != YXBanded)) {
        client->errorValue = stuff->ordering;
        return BadValue;
    }
    result = dixLookupGC(&pGC, stuff->gc, client, DixSetAttrAccess);
    if (result != Success)
        return result;

    nr = (client->req_len << 2) - sizeof(xSetClipRectanglesReq);
    if (nr & 4)
        return BadLength;
    nr >>= 3;
    return SetClipRects(pGC, stuff->xOrigin, stuff->yOrigin,
                        nr, (xRectangle *) &stuff[1], (int) stuff->ordering);
}

int
ProcFreeGC(ClientPtr client)
{
    GC *pGC;
    int rc;

    REQUEST(xResourceReq);
    REQUEST_SIZE_MATCH(xResourceReq);

    rc = dixLookupGC(&pGC, stuff->id, client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->id, RT_NONE);
    return Success;
}

int
ProcClearToBackground(ClientPtr client)
{
    REQUEST(xClearAreaReq);
    WindowPtr pWin;
    int rc;

    REQUEST_SIZE_MATCH(xClearAreaReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (rc != Success)
        return rc;
    if (pWin->drawable.class == InputOnly) {
        client->errorValue = stuff->window;
        return BadMatch;
    }
    if ((stuff->exposures != xTrue) && (stuff->exposures != xFalse)) {
        client->errorValue = stuff->exposures;
        return BadValue;
    }
    (*pWin->drawable.pScreen->ClearToBackground) (pWin, stuff->x, stuff->y,
                                                  stuff->width, stuff->height,
                                                  (Bool) stuff->exposures);
    return Success;
}

/* send GraphicsExpose events, or a NoExpose event, based on the region */
void
SendGraphicsExpose(ClientPtr client, RegionPtr pRgn, XID drawable,
                     int major, int minor)
{
    if (pRgn && !RegionNil(pRgn)) {
        xEvent *pEvent;
        xEvent *pe;
        BoxPtr pBox;
        int i;
        int numRects;

        numRects = RegionNumRects(pRgn);
        pBox = RegionRects(pRgn);
        if (!(pEvent = calloc(numRects, sizeof(xEvent))))
            return;
        pe = pEvent;

        for (i = 1; i <= numRects; i++, pe++, pBox++) {
            pe->u.u.type = GraphicsExpose;
            pe->u.graphicsExposure.drawable = drawable;
            pe->u.graphicsExposure.x = pBox->x1;
            pe->u.graphicsExposure.y = pBox->y1;
            pe->u.graphicsExposure.width = pBox->x2 - pBox->x1;
            pe->u.graphicsExposure.height = pBox->y2 - pBox->y1;
            pe->u.graphicsExposure.count = numRects - i;
            pe->u.graphicsExposure.majorEvent = major;
            pe->u.graphicsExposure.minorEvent = minor;
        }
        /* GraphicsExpose is a "critical event", which TryClientEvents
         * handles specially. */
        TryClientEvents(client, NULL, pEvent, numRects,
                        (Mask) 0, NoEventMask, NullGrab);
        free(pEvent);
    }
    else {
        xEvent event = {
            .u.noExposure.drawable = drawable,
            .u.noExposure.majorEvent = major,
            .u.noExposure.minorEvent = minor
        };
        event.u.u.type = NoExpose;
        WriteEventsToClient(client, 1, &event);
    }
}

int
ProcCopyArea(ClientPtr client)
{
    DrawablePtr pDst;
    DrawablePtr pSrc;
    GC *pGC;

    REQUEST(xCopyAreaReq);
    RegionPtr pRgn;
    int rc;

    REQUEST_SIZE_MATCH(xCopyAreaReq);

    VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pDst, DixWriteAccess);
    if (stuff->dstDrawable != stuff->srcDrawable) {
        rc = dixLookupDrawable(&pSrc, stuff->srcDrawable, client, 0,
                               DixReadAccess);
        if (rc != Success)
            return rc;
        if ((pDst->pScreen != pSrc->pScreen) || (pDst->depth != pSrc->depth)) {
            client->errorValue = stuff->dstDrawable;
            return BadMatch;
        }
    }
    else
        pSrc = pDst;

    pRgn = (*pGC->ops->CopyArea) (pSrc, pDst, pGC, stuff->srcX, stuff->srcY,
                                  stuff->width, stuff->height,
                                  stuff->dstX, stuff->dstY);
    if (pGC->graphicsExposures) {
        SendGraphicsExpose(client, pRgn, stuff->dstDrawable, X_CopyArea, 0);
        if (pRgn)
            RegionDestroy(pRgn);
    }

    return Success;
}

int
ProcCopyPlane(ClientPtr client)
{
    DrawablePtr psrcDraw, pdstDraw;
    GC *pGC;

    REQUEST(xCopyPlaneReq);
    RegionPtr pRgn;
    int rc;

    REQUEST_SIZE_MATCH(xCopyPlaneReq);

    VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pdstDraw, DixWriteAccess);
    if (stuff->dstDrawable != stuff->srcDrawable) {
        rc = dixLookupDrawable(&psrcDraw, stuff->srcDrawable, client, 0,
                               DixReadAccess);
        if (rc != Success)
            return rc;

        if (pdstDraw->pScreen != psrcDraw->pScreen) {
            client->errorValue = stuff->dstDrawable;
            return BadMatch;
        }
    }
    else
        psrcDraw = pdstDraw;

    /* Check to see if stuff->bitPlane has exactly ONE good bit set */
    if (stuff->bitPlane == 0 || (stuff->bitPlane & (stuff->bitPlane - 1)) ||
        (stuff->bitPlane > (1L << (psrcDraw->depth - 1)))) {
        client->errorValue = stuff->bitPlane;
        return BadValue;
    }

    pRgn =
        (*pGC->ops->CopyPlane) (psrcDraw, pdstDraw, pGC, stuff->srcX,
                                stuff->srcY, stuff->width, stuff->height,
                                stuff->dstX, stuff->dstY, stuff->bitPlane);
    if (pGC->graphicsExposures) {
        SendGraphicsExpose(client, pRgn, stuff->dstDrawable, X_CopyPlane, 0);
        if (pRgn)
            RegionDestroy(pRgn);
    }
    return Success;
}

int
ProcPolyPoint(ClientPtr client)
{
    int npoint;
    GC *pGC;
    DrawablePtr pDraw;

    REQUEST(xPolyPointReq);

    REQUEST_AT_LEAST_SIZE(xPolyPointReq);
    if ((stuff->coordMode != CoordModeOrigin) &&
        (stuff->coordMode != CoordModePrevious)) {
        client->errorValue = stuff->coordMode;
        return BadValue;
    }
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    npoint = bytes_to_int32((client->req_len << 2) - sizeof(xPolyPointReq));
    if (npoint)
        (*pGC->ops->PolyPoint) (pDraw, pGC, stuff->coordMode, npoint,
                                (xPoint *) &stuff[1]);
    return Success;
}

int
ProcPolyLine(ClientPtr client)
{
    int npoint;
    GC *pGC;
    DrawablePtr pDraw;

    REQUEST(xPolyLineReq);

    REQUEST_AT_LEAST_SIZE(xPolyLineReq);
    if ((stuff->coordMode != CoordModeOrigin) &&
        (stuff->coordMode != CoordModePrevious)) {
        client->errorValue = stuff->coordMode;
        return BadValue;
    }
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    npoint = bytes_to_int32((client->req_len << 2) - sizeof(xPolyLineReq));
    if (npoint > 1)
        (*pGC->ops->Polylines) (pDraw, pGC, stuff->coordMode, npoint,
                                (DDXPointPtr) &stuff[1]);
    return Success;
}

int
ProcPolySegment(ClientPtr client)
{
    int nsegs;
    GC *pGC;
    DrawablePtr pDraw;

    REQUEST(xPolySegmentReq);

    REQUEST_AT_LEAST_SIZE(xPolySegmentReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    nsegs = (client->req_len << 2) - sizeof(xPolySegmentReq);
    if (nsegs & 4)
        return BadLength;
    nsegs >>= 3;
    if (nsegs)
        (*pGC->ops->PolySegment) (pDraw, pGC, nsegs, (xSegment *) &stuff[1]);
    return Success;
}

int
ProcPolyRectangle(ClientPtr client)
{
    int nrects;
    GC *pGC;
    DrawablePtr pDraw;

    REQUEST(xPolyRectangleReq);

    REQUEST_AT_LEAST_SIZE(xPolyRectangleReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    nrects = (client->req_len << 2) - sizeof(xPolyRectangleReq);
    if (nrects & 4)
        return BadLength;
    nrects >>= 3;
    if (nrects)
        (*pGC->ops->PolyRectangle) (pDraw, pGC,
                                    nrects, (xRectangle *) &stuff[1]);
    return Success;
}

int
ProcPolyArc(ClientPtr client)
{
    int narcs;
    GC *pGC;
    DrawablePtr pDraw;

    REQUEST(xPolyArcReq);

    REQUEST_AT_LEAST_SIZE(xPolyArcReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    narcs = (client->req_len << 2) - sizeof(xPolyArcReq);
    if (narcs % sizeof(xArc))
        return BadLength;
    narcs /= sizeof(xArc);
    if (narcs)
        (*pGC->ops->PolyArc) (pDraw, pGC, narcs, (xArc *) &stuff[1]);
    return Success;
}

int
ProcFillPoly(ClientPtr client)
{
    int things;
    GC *pGC;
    DrawablePtr pDraw;

    REQUEST(xFillPolyReq);

    REQUEST_AT_LEAST_SIZE(xFillPolyReq);
    if ((stuff->shape != Complex) && (stuff->shape != Nonconvex) &&
        (stuff->shape != Convex)) {
        client->errorValue = stuff->shape;
        return BadValue;
    }
    if ((stuff->coordMode != CoordModeOrigin) &&
        (stuff->coordMode != CoordModePrevious)) {
        client->errorValue = stuff->coordMode;
        return BadValue;
    }

    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    things = bytes_to_int32((client->req_len << 2) - sizeof(xFillPolyReq));
    if (things)
        (*pGC->ops->FillPolygon) (pDraw, pGC, stuff->shape,
                                  stuff->coordMode, things,
                                  (DDXPointPtr) &stuff[1]);
    return Success;
}

int
ProcPolyFillRectangle(ClientPtr client)
{
    int things;
    GC *pGC;
    DrawablePtr pDraw;

    REQUEST(xPolyFillRectangleReq);

    REQUEST_AT_LEAST_SIZE(xPolyFillRectangleReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    things = (client->req_len << 2) - sizeof(xPolyFillRectangleReq);
    if (things & 4)
        return BadLength;
    things >>= 3;

    if (things)
        (*pGC->ops->PolyFillRect) (pDraw, pGC, things,
                                   (xRectangle *) &stuff[1]);
    return Success;
}

int
ProcPolyFillArc(ClientPtr client)
{
    int narcs;
    GC *pGC;
    DrawablePtr pDraw;

    REQUEST(xPolyFillArcReq);

    REQUEST_AT_LEAST_SIZE(xPolyFillArcReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    narcs = (client->req_len << 2) - sizeof(xPolyFillArcReq);
    if (narcs % sizeof(xArc))
        return BadLength;
    narcs /= sizeof(xArc);
    if (narcs)
        (*pGC->ops->PolyFillArc) (pDraw, pGC, narcs, (xArc *) &stuff[1]);
    return Success;
}

#ifdef MATCH_CLIENT_ENDIAN

int
ServerOrder(void)
{
    int whichbyte = 1;

    if (*((char *) &whichbyte))
        return LSBFirst;
    return MSBFirst;
}

#define ClientOrder(client) ((client)->swapped ? !ServerOrder() : ServerOrder())

void
ReformatImage(char *base, int nbytes, int bpp, int order)
{
    switch (bpp) {
    case 1:                    /* yuck */
        if (BITMAP_BIT_ORDER != order)
            BitOrderInvert((unsigned char *) base, nbytes);
#if IMAGE_BYTE_ORDER != BITMAP_BIT_ORDER && BITMAP_SCANLINE_UNIT != 8
        ReformatImage(base, nbytes, BITMAP_SCANLINE_UNIT, order);
#endif
        break;
    case 4:
        break;                  /* yuck */
    case 8:
        break;
    case 16:
        if (IMAGE_BYTE_ORDER != order)
            TwoByteSwap((unsigned char *) base, nbytes);
        break;
    case 32:
        if (IMAGE_BYTE_ORDER != order)
            FourByteSwap((unsigned char *) base, nbytes);
        break;
    }
}
#else
#define ReformatImage(b,n,bpp,o)
#endif

/* 64-bit server notes: the protocol restricts padding of images to
 * 8-, 16-, or 32-bits. We would like to have 64-bits for the server
 * to use internally. Removes need for internal alignment checking.
 * All of the PutImage functions could be changed individually, but
 * as currently written, they call other routines which require things
 * to be 64-bit padded on scanlines, so we changed things here.
 * If an image would be padded differently for 64- versus 32-, then
 * copy each scanline to a 64-bit padded scanline.
 * Also, we need to make sure that the image is aligned on a 64-bit
 * boundary, even if the scanlines are padded to our satisfaction.
 */
int
ProcPutImage(ClientPtr client)
{
    GC *pGC;
    DrawablePtr pDraw;
    long length;                /* length of scanline server padded */
    long lengthProto;           /* length of scanline protocol padded */
    char *tmpImage;

    REQUEST(xPutImageReq);

    REQUEST_AT_LEAST_SIZE(xPutImageReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    if (stuff->format == XYBitmap) {
        if ((stuff->depth != 1) ||
            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))
            return BadMatch;
        length = BitmapBytePad(stuff->width + stuff->leftPad);
    }
    else if (stuff->format == XYPixmap) {
        if ((pDraw->depth != stuff->depth) ||
            (stuff->leftPad >= (unsigned int) screenInfo.bitmapScanlinePad))
            return BadMatch;
        length = BitmapBytePad(stuff->width + stuff->leftPad);
        length *= stuff->depth;
    }
    else if (stuff->format == ZPixmap) {
        if ((pDraw->depth != stuff->depth) || (stuff->leftPad != 0))
            return BadMatch;
        length = PixmapBytePad(stuff->width, stuff->depth);
    }
    else {
        client->errorValue = stuff->format;
        return BadValue;
    }

    tmpImage = (char *) &stuff[1];
    lengthProto = length;

    if (stuff->height != 0 && lengthProto >= (INT32_MAX / stuff->height))
        return BadLength;

    if ((bytes_to_int32(lengthProto * stuff->height) +
         bytes_to_int32(sizeof(xPutImageReq))) != client->req_len)
        return BadLength;

    ReformatImage(tmpImage, lengthProto * stuff->height,
                  stuff->format == ZPixmap ? BitsPerPixel(stuff->depth) : 1,
                  ClientOrder(client));

    (*pGC->ops->PutImage) (pDraw, pGC, stuff->depth, stuff->dstX, stuff->dstY,
                           stuff->width, stuff->height,
                           stuff->leftPad, stuff->format, tmpImage);

    return Success;
}

static int
DoGetImage(ClientPtr client, int format, Drawable drawable,
           int x, int y, int width, int height,
           Mask planemask)
{
    DrawablePtr pDraw, pBoundingDraw;
    int nlines, linesPerBuf, rc;
    int linesDone;

    /* coordinates relative to the bounding drawable */
    int relx, rely;
    long widthBytesLine, length;
    Mask plane = 0;
    char *pBuf;
    xGetImageReply xgi;
    RegionPtr pVisibleRegion = NULL;

    if ((format != XYPixmap) && (format != ZPixmap)) {
        client->errorValue = format;
        return BadValue;
    }
    rc = dixLookupDrawable(&pDraw, drawable, client, 0, DixReadAccess);
    if (rc != Success)
        return rc;

    memset(&xgi, 0, sizeof(xGetImageReply));

    relx = x;
    rely = y;

    if (pDraw->type == DRAWABLE_WINDOW) {
        WindowPtr pWin = (WindowPtr) pDraw;

        /* "If the drawable is a window, the window must be viewable ... or a
         * BadMatch error results" */
        if (!pWin->viewable)
            return BadMatch;

        /* If the drawable is a window, the rectangle must be contained within
         * its bounds (including the border). */
        if (x < -wBorderWidth(pWin) ||
            x + width > wBorderWidth(pWin) + (int) pDraw->width ||
            y < -wBorderWidth(pWin) ||
            y + height > wBorderWidth(pWin) + (int) pDraw->height)
            return BadMatch;

        relx += pDraw->x;
        rely += pDraw->y;

        if (pDraw->pScreen->GetWindowPixmap) {
            PixmapPtr pPix = (*pDraw->pScreen->GetWindowPixmap) (pWin);

            pBoundingDraw = &pPix->drawable;
#ifdef COMPOSITE
            relx -= pPix->screen_x;
            rely -= pPix->screen_y;
#endif
        }
        else {
            pBoundingDraw = (DrawablePtr) pDraw->pScreen->root;
        }

        xgi.visual = wVisual(pWin);
    }
    else {
        pBoundingDraw = pDraw;
        xgi.visual = None;
    }

    /* "If the drawable is a pixmap, the given rectangle must be wholly
     *  contained within the pixmap, or a BadMatch error results.  If the
     *  drawable is a window [...] it must be the case that if there were no
     *  inferiors or overlapping windows, the specified rectangle of the window
     *  would be fully visible on the screen and wholly contained within the
     *  outside edges of the window, or a BadMatch error results."
     *
     * We relax the window case slightly to mean that the rectangle must exist
     * within the bounds of the window's backing pixmap.  In particular, this
     * means that a GetImage request may succeed or fail with BadMatch depending
     * on whether any of its ancestor windows are redirected.  */
    if (relx < 0 || relx + width > (int) pBoundingDraw->width ||
        rely < 0 || rely + height > (int) pBoundingDraw->height)
        return BadMatch;

    xgi.type = X_Reply;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;
    if (format == ZPixmap) {
        widthBytesLine = PixmapBytePad(width, pDraw->depth);
        length = widthBytesLine * height;

    }
    else {
        widthBytesLine = BitmapBytePad(width);
        plane = ((Mask) 1) << (pDraw->depth - 1);
        /* only planes asked for */
        length = widthBytesLine * height *
            Ones(planemask & (plane | (plane - 1)));

    }

    xgi.length = length;

    xgi.length = bytes_to_int32(xgi.length);
    if (widthBytesLine == 0 || height == 0)
        linesPerBuf = 0;
    else if (widthBytesLine >= IMAGE_BUFSIZE)
        linesPerBuf = 1;
    else {
        linesPerBuf = IMAGE_BUFSIZE / widthBytesLine;
        if (linesPerBuf > height)
            linesPerBuf = height;
    }
    length = linesPerBuf * widthBytesLine;
    if (linesPerBuf < height) {
        /* we have to make sure intermediate buffers don't need padding */
        while ((linesPerBuf > 1) &&
               (length & ((1L << LOG2_BYTES_PER_SCANLINE_PAD) - 1))) {
            linesPerBuf--;
            length -= widthBytesLine;
        }
        while (length & ((1L << LOG2_BYTES_PER_SCANLINE_PAD) - 1)) {
            linesPerBuf++;
            length += widthBytesLine;
        }
    }
    if (!(pBuf = calloc(1, length)))
        return BadAlloc;
    WriteReplyToClient(client, sizeof(xGetImageReply), &xgi);

    if (pDraw->type == DRAWABLE_WINDOW) {
        pVisibleRegion = NotClippedByChildren((WindowPtr) pDraw);
        if (pVisibleRegion) {
            RegionTranslate(pVisibleRegion, -pDraw->x, -pDraw->y);
        }
    }

    if (linesPerBuf == 0) {
        /* nothing to do */
    }
    else if (format == ZPixmap) {
        linesDone = 0;
        while (height - linesDone > 0) {
            nlines = min(linesPerBuf, height - linesDone);
            (*pDraw->pScreen->GetImage) (pDraw,
                                         x,
                                         y + linesDone,
                                         width,
                                         nlines,
                                         format, planemask, (void *) pBuf);
            if (pVisibleRegion)
                XaceCensorImage(client, pVisibleRegion, widthBytesLine,
                                pDraw, x, y + linesDone, width,
                                nlines, format, pBuf);

            /* Note that this is NOT a call to WriteSwappedDataToClient,
               as we do NOT byte swap */
            ReformatImage(pBuf, (int) (nlines * widthBytesLine),
                          BitsPerPixel(pDraw->depth), ClientOrder(client));

            WriteToClient(client, (int) (nlines * widthBytesLine), pBuf);
            linesDone += nlines;
        }
    }
    else {                      /* XYPixmap */

        for (; plane; plane >>= 1) {
            if (planemask & plane) {
                linesDone = 0;
                while (height - linesDone > 0) {
                    nlines = min(linesPerBuf, height - linesDone);
                    (*pDraw->pScreen->GetImage) (pDraw,
                                                 x,
                                                 y + linesDone,
                                                 width,
                                                 nlines,
                                                 format, plane, (void *) pBuf);
                    if (pVisibleRegion)
                        XaceCensorImage(client, pVisibleRegion,
                                        widthBytesLine,
                                        pDraw, x, y + linesDone, width,
                                        nlines, format, pBuf);

                    /* Note: NOT a call to WriteSwappedDataToClient,
                       as we do NOT byte swap */
                    ReformatImage(pBuf, (int) (nlines * widthBytesLine),
                                  1, ClientOrder(client));

                    WriteToClient(client, (int)(nlines * widthBytesLine), pBuf);
                    linesDone += nlines;
                }
            }
        }
    }
    if (pVisibleRegion)
        RegionDestroy(pVisibleRegion);
    free(pBuf);
    return Success;
}

int
ProcGetImage(ClientPtr client)
{
    REQUEST(xGetImageReq);

    REQUEST_SIZE_MATCH(xGetImageReq);

    return DoGetImage(client, stuff->format, stuff->drawable,
                      stuff->x, stuff->y,
                      (int) stuff->width, (int) stuff->height,
                      stuff->planeMask);
}

int
ProcPolyText(ClientPtr client)
{
    int err;

    REQUEST(xPolyTextReq);
    DrawablePtr pDraw;
    GC *pGC;

    REQUEST_AT_LEAST_SIZE(xPolyTextReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);

    err = PolyText(client,
                   pDraw,
                   pGC,
                   (unsigned char *) &stuff[1],
                   ((unsigned char *) stuff) + (client->req_len << 2),
                   stuff->x, stuff->y, stuff->reqType, stuff->drawable);

    if (err == Success) {
        return Success;
    }
    else
        return err;
}

int
ProcImageText8(ClientPtr client)
{
    int err;
    DrawablePtr pDraw;
    GC *pGC;

    REQUEST(xImageTextReq);

    REQUEST_FIXED_SIZE(xImageTextReq, stuff->nChars);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);

    err = ImageText(client,
                    pDraw,
                    pGC,
                    stuff->nChars,
                    (unsigned char *) &stuff[1],
                    stuff->x, stuff->y, stuff->reqType, stuff->drawable);

    if (err == Success) {
        return Success;
    }
    else
        return err;
}

int
ProcImageText16(ClientPtr client)
{
    int err;
    DrawablePtr pDraw;
    GC *pGC;

    REQUEST(xImageTextReq);

    REQUEST_FIXED_SIZE(xImageTextReq, stuff->nChars << 1);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);

    err = ImageText(client,
                    pDraw,
                    pGC,
                    stuff->nChars,
                    (unsigned char *) &stuff[1],
                    stuff->x, stuff->y, stuff->reqType, stuff->drawable);

    if (err == Success) {
        return Success;
    }
    else
        return err;
}

int
ProcCreateColormap(ClientPtr client)
{
    VisualPtr pVisual;
    ColormapPtr pmap;
    Colormap mid;
    WindowPtr pWin;
    ScreenPtr pScreen;

    REQUEST(xCreateColormapReq);
    int i, result;

    REQUEST_SIZE_MATCH(xCreateColormapReq);

    if ((stuff->alloc != AllocNone) && (stuff->alloc != AllocAll)) {
        client->errorValue = stuff->alloc;
        return BadValue;
    }
    mid = stuff->mid;
    LEGAL_NEW_RESOURCE(mid, client);
    result = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (result != Success)
        return result;

    pScreen = pWin->drawable.pScreen;
    for (i = 0, pVisual = pScreen->visuals;
         i < pScreen->numVisuals; i++, pVisual++) {
        if (pVisual->vid != stuff->visual)
            continue;
        return CreateColormap(mid, pScreen, pVisual, &pmap,
                              (int) stuff->alloc, client->index);
    }
    client->errorValue = stuff->visual;
    return BadMatch;
}

int
ProcFreeColormap(ClientPtr client)
{
    ColormapPtr pmap;
    int rc;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupResourceByType((void **) &pmap, stuff->id, RT_COLORMAP,
                                 client, DixDestroyAccess);
    if (rc == Success) {
        /* Freeing a default colormap is a no-op */
        if (!(pmap->flags & IsDefault))
            FreeResource(stuff->id, RT_NONE);
        return Success;
    }
    else {
        client->errorValue = stuff->id;
        return rc;
    }
}

int
ProcCopyColormapAndFree(ClientPtr client)
{
    Colormap mid;
    ColormapPtr pSrcMap;

    REQUEST(xCopyColormapAndFreeReq);
    int rc;

    REQUEST_SIZE_MATCH(xCopyColormapAndFreeReq);
    mid = stuff->mid;
    LEGAL_NEW_RESOURCE(mid, client);
    rc = dixLookupResourceByType((void **) &pSrcMap, stuff->srcCmap,
                                 RT_COLORMAP, client,
                                 DixReadAccess | DixRemoveAccess);
    if (rc == Success)
        return CopyColormapAndFree(mid, pSrcMap, client->index);
    client->errorValue = stuff->srcCmap;
    return rc;
}

int
ProcInstallColormap(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xResourceReq);
    REQUEST_SIZE_MATCH(xResourceReq);

    rc = dixLookupResourceByType((void **) &pcmp, stuff->id, RT_COLORMAP,
                                 client, DixInstallAccess);
    if (rc != Success)
        goto out;

    rc = XaceHook(XACE_SCREEN_ACCESS, client, pcmp->pScreen, DixSetAttrAccess);
    if (rc != Success) {
        if (rc == BadValue)
            rc = BadColor;
        goto out;
    }

    (*(pcmp->pScreen->InstallColormap)) (pcmp);
    return Success;

 out:
    client->errorValue = stuff->id;
    return rc;
}

int
ProcUninstallColormap(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xResourceReq);
    REQUEST_SIZE_MATCH(xResourceReq);

    rc = dixLookupResourceByType((void **) &pcmp, stuff->id, RT_COLORMAP,
                                 client, DixUninstallAccess);
    if (rc != Success)
        goto out;

    rc = XaceHook(XACE_SCREEN_ACCESS, client, pcmp->pScreen, DixSetAttrAccess);
    if (rc != Success) {
        if (rc == BadValue)
            rc = BadColor;
        goto out;
    }

    if (pcmp->mid != pcmp->pScreen->defColormap)
        (*(pcmp->pScreen->UninstallColormap)) (pcmp);
    return Success;

 out:
    client->errorValue = stuff->id;
    return rc;
}

int
ProcListInstalledColormaps(ClientPtr client)
{
    xListInstalledColormapsReply *preply;
    int nummaps, rc;
    WindowPtr pWin;

    REQUEST(xResourceReq);
    REQUEST_SIZE_MATCH(xResourceReq);

    rc = dixLookupWindow(&pWin, stuff->id, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rc = XaceHook(XACE_SCREEN_ACCESS, client, pWin->drawable.pScreen,
                  DixGetAttrAccess);
    if (rc != Success)
        return rc;

    preply = malloc(sizeof(xListInstalledColormapsReply) +
                    pWin->drawable.pScreen->maxInstalledCmaps *
                    sizeof(Colormap));
    if (!preply)
        return BadAlloc;

    preply->type = X_Reply;
    preply->sequenceNumber = client->sequence;
    nummaps = (*pWin->drawable.pScreen->ListInstalledColormaps)
        (pWin->drawable.pScreen, (Colormap *) &preply[1]);
    preply->nColormaps = nummaps;
    preply->length = nummaps;
    WriteReplyToClient(client, sizeof(xListInstalledColormapsReply), preply);
    client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
    WriteSwappedDataToClient(client, nummaps * sizeof(Colormap), &preply[1]);
    free(preply);
    return Success;
}

int
ProcAllocColor(ClientPtr client)
{
    ColormapPtr pmap;
    int rc;

    REQUEST(xAllocColorReq);

    REQUEST_SIZE_MATCH(xAllocColorReq);
    rc = dixLookupResourceByType((void **) &pmap, stuff->cmap, RT_COLORMAP,
                                 client, DixAddAccess);
    if (rc == Success) {
        xAllocColorReply acr = {
            .type = X_Reply,
            .sequenceNumber = client->sequence,
            .length = 0,
            .red = stuff->red,
            .green = stuff->green,
            .blue = stuff->blue,
            .pixel = 0
        };
        if ((rc = AllocColor(pmap, &acr.red, &acr.green, &acr.blue,
                             &acr.pixel, client->index)))
            return rc;
#ifdef PANORAMIX
        if (noPanoramiXExtension || !pmap->pScreen->myNum)
#endif
            WriteReplyToClient(client, sizeof(xAllocColorReply), &acr);
        return Success;

    }
    else {
        client->errorValue = stuff->cmap;
        return rc;
    }
}

int
ProcAllocNamedColor(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xAllocNamedColorReq);

    REQUEST_FIXED_SIZE(xAllocNamedColorReq, stuff->nbytes);
    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,
                                 client, DixAddAccess);
    if (rc == Success) {
        xAllocNamedColorReply ancr = {
            .type = X_Reply,
            .sequenceNumber = client->sequence,
            .length = 0
        };
        if (OsLookupColor
            (pcmp->pScreen->myNum, (char *) &stuff[1], stuff->nbytes,
             &ancr.exactRed, &ancr.exactGreen, &ancr.exactBlue)) {
            ancr.screenRed = ancr.exactRed;
            ancr.screenGreen = ancr.exactGreen;
            ancr.screenBlue = ancr.exactBlue;
            ancr.pixel = 0;
            if ((rc = AllocColor(pcmp,
                                 &ancr.screenRed, &ancr.screenGreen,
                                 &ancr.screenBlue, &ancr.pixel, client->index)))
                return rc;
#ifdef PANORAMIX
            if (noPanoramiXExtension || !pcmp->pScreen->myNum)
#endif
                WriteReplyToClient(client, sizeof(xAllocNamedColorReply),
                                   &ancr);
            return Success;
        }
        else
            return BadName;

    }
    else {
        client->errorValue = stuff->cmap;
        return rc;
    }
}

int
ProcAllocColorCells(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xAllocColorCellsReq);

    REQUEST_SIZE_MATCH(xAllocColorCellsReq);
    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,
                                 client, DixAddAccess);
    if (rc == Success) {
        int npixels, nmasks;
        long length;
        Pixel *ppixels, *pmasks;

        npixels = stuff->colors;
        if (!npixels) {
            client->errorValue = npixels;
            return BadValue;
        }
        if (stuff->contiguous != xTrue && stuff->contiguous != xFalse) {
            client->errorValue = stuff->contiguous;
            return BadValue;
        }
        nmasks = stuff->planes;
        length = ((long) npixels + (long) nmasks) * sizeof(Pixel);
        ppixels = malloc(length);
        if (!ppixels)
            return BadAlloc;
        pmasks = ppixels + npixels;

        if ((rc = AllocColorCells(client->index, pcmp, npixels, nmasks,
                                  (Bool) stuff->contiguous, ppixels, pmasks))) {
            free(ppixels);
            return rc;
        }
#ifdef PANORAMIX
        if (noPanoramiXExtension || !pcmp->pScreen->myNum)
#endif
        {
            xAllocColorCellsReply accr = {
                .type = X_Reply,
                .sequenceNumber = client->sequence,
                .length = bytes_to_int32(length),
                .nPixels = npixels,
                .nMasks = nmasks
            };
            WriteReplyToClient(client, sizeof(xAllocColorCellsReply), &accr);
            client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
            WriteSwappedDataToClient(client, length, ppixels);
        }
        free(ppixels);
        return Success;
    }
    else {
        client->errorValue = stuff->cmap;
        return rc;
    }
}

int
ProcAllocColorPlanes(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xAllocColorPlanesReq);

    REQUEST_SIZE_MATCH(xAllocColorPlanesReq);
    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,
                                 client, DixAddAccess);
    if (rc == Success) {
        xAllocColorPlanesReply acpr;
        int npixels;
        long length;
        Pixel *ppixels;

        npixels = stuff->colors;
        if (!npixels) {
            client->errorValue = npixels;
            return BadValue;
        }
        if (stuff->contiguous != xTrue && stuff->contiguous != xFalse) {
            client->errorValue = stuff->contiguous;
            return BadValue;
        }
        acpr = (xAllocColorPlanesReply) {
            .type = X_Reply,
            .sequenceNumber = client->sequence,
            .nPixels = npixels
        };
        length = (long) npixels *sizeof(Pixel);

        ppixels = malloc(length);
        if (!ppixels)
            return BadAlloc;
        if ((rc = AllocColorPlanes(client->index, pcmp, npixels,
                                   (int) stuff->red, (int) stuff->green,
                                   (int) stuff->blue, (Bool) stuff->contiguous,
                                   ppixels, &acpr.redMask, &acpr.greenMask,
                                   &acpr.blueMask))) {
            free(ppixels);
            return rc;
        }
        acpr.length = bytes_to_int32(length);
#ifdef PANORAMIX
        if (noPanoramiXExtension || !pcmp->pScreen->myNum)
#endif
        {
            WriteReplyToClient(client, sizeof(xAllocColorPlanesReply), &acpr);
            client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
            WriteSwappedDataToClient(client, length, ppixels);
        }
        free(ppixels);
        return Success;
    }
    else {
        client->errorValue = stuff->cmap;
        return rc;
    }
}

int
ProcFreeColors(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xFreeColorsReq);

    REQUEST_AT_LEAST_SIZE(xFreeColorsReq);
    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,
                                 client, DixRemoveAccess);
    if (rc == Success) {
        int count;

        if (pcmp->flags & AllAllocated)
            return BadAccess;
        count = bytes_to_int32((client->req_len << 2) - sizeof(xFreeColorsReq));
        return FreeColors(pcmp, client->index, count,
                          (Pixel *) &stuff[1], (Pixel) stuff->planeMask);
    }
    else {
        client->errorValue = stuff->cmap;
        return rc;
    }
}

int
ProcStoreColors(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xStoreColorsReq);

    REQUEST_AT_LEAST_SIZE(xStoreColorsReq);
    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,
                                 client, DixWriteAccess);
    if (rc == Success) {
        int count;

        count = (client->req_len << 2) - sizeof(xStoreColorsReq);
        if (count % sizeof(xColorItem))
            return BadLength;
        count /= sizeof(xColorItem);
        return StoreColors(pcmp, count, (xColorItem *) &stuff[1], client);
    }
    else {
        client->errorValue = stuff->cmap;
        return rc;
    }
}

int
ProcStoreNamedColor(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xStoreNamedColorReq);

    REQUEST_FIXED_SIZE(xStoreNamedColorReq, stuff->nbytes);
    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,
                                 client, DixWriteAccess);
    if (rc == Success) {
        xColorItem def;

        if (OsLookupColor(pcmp->pScreen->myNum, (char *) &stuff[1],
                          stuff->nbytes, &def.red, &def.green, &def.blue)) {
            def.flags = stuff->flags;
            def.pixel = stuff->pixel;
            return StoreColors(pcmp, 1, &def, client);
        }
        return BadName;
    }
    else {
        client->errorValue = stuff->cmap;
        return rc;
    }
}

int
ProcQueryColors(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xQueryColorsReq);

    REQUEST_AT_LEAST_SIZE(xQueryColorsReq);
    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,
                                 client, DixReadAccess);
    if (rc == Success) {
        int count;
        xrgb *prgbs;
        xQueryColorsReply qcr;

        count =
            bytes_to_int32((client->req_len << 2) - sizeof(xQueryColorsReq));
        prgbs = calloc(count, sizeof(xrgb));
        if (!prgbs && count)
            return BadAlloc;
        if ((rc =
             QueryColors(pcmp, count, (Pixel *) &stuff[1], prgbs, client))) {
            free(prgbs);
            return rc;
        }
        qcr = (xQueryColorsReply) {
            .type = X_Reply,
            .sequenceNumber = client->sequence,
            .length = bytes_to_int32(count * sizeof(xrgb)),
            .nColors = count
        };
        WriteReplyToClient(client, sizeof(xQueryColorsReply), &qcr);
        if (count) {
            client->pSwapReplyFunc = (ReplySwapPtr) SQColorsExtend;
            WriteSwappedDataToClient(client, count * sizeof(xrgb), prgbs);
        }
        free(prgbs);
        return Success;

    }
    else {
        client->errorValue = stuff->cmap;
        return rc;
    }
}

int
ProcLookupColor(ClientPtr client)
{
    ColormapPtr pcmp;
    int rc;

    REQUEST(xLookupColorReq);

    REQUEST_FIXED_SIZE(xLookupColorReq, stuff->nbytes);
    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,
                                 client, DixReadAccess);
    if (rc == Success) {
        CARD16 exactRed, exactGreen, exactBlue;

        if (OsLookupColor
            (pcmp->pScreen->myNum, (char *) &stuff[1], stuff->nbytes,
             &exactRed, &exactGreen, &exactBlue)) {
            xLookupColorReply lcr = {
                .type = X_Reply,
                .sequenceNumber = client->sequence,
                .length = 0,
                .exactRed = exactRed,
                .exactGreen = exactGreen,
                .exactBlue = exactBlue,
                .screenRed = exactRed,
                .screenGreen = exactGreen,
                .screenBlue = exactBlue
            };
            (*pcmp->pScreen->ResolveColor) (&lcr.screenRed,
                                            &lcr.screenGreen,
                                            &lcr.screenBlue, pcmp->pVisual);
            WriteReplyToClient(client, sizeof(xLookupColorReply), &lcr);
            return Success;
        }
        return BadName;
    }
    else {
        client->errorValue = stuff->cmap;
        return rc;
    }
}

int
ProcCreateCursor(ClientPtr client)
{
    CursorPtr pCursor;
    PixmapPtr src;
    PixmapPtr msk;
    unsigned char *srcbits;
    unsigned char *mskbits;
    unsigned short width, height;
    long n;
    CursorMetricRec cm;
    int rc;

    REQUEST(xCreateCursorReq);

    REQUEST_SIZE_MATCH(xCreateCursorReq);
    LEGAL_NEW_RESOURCE(stuff->cid, client);

    rc = dixLookupResourceByType((void **) &src, stuff->source, RT_PIXMAP,
                                 client, DixReadAccess);
    if (rc != Success) {
        client->errorValue = stuff->source;
        return rc;
    }

    if (src->drawable.depth != 1)
        return (BadMatch);

    /* Find and validate cursor mask pixmap, if one is provided */
    if (stuff->mask != None) {
        rc = dixLookupResourceByType((void **) &msk, stuff->mask, RT_PIXMAP,
                                     client, DixReadAccess);
        if (rc != Success) {
            client->errorValue = stuff->mask;
            return rc;
        }

        if (src->drawable.width != msk->drawable.width
            || src->drawable.height != msk->drawable.height
            || src->drawable.depth != 1 || msk->drawable.depth != 1)
            return BadMatch;
    }
    else
        msk = NULL;

    width = src->drawable.width;
    height = src->drawable.height;

    if (stuff->x > width || stuff->y > height)
        return BadMatch;

    srcbits = calloc(BitmapBytePad(width), height);
    if (!srcbits)
        return BadAlloc;
    n = BitmapBytePad(width) * height;
    mskbits = malloc(n);
    if (!mskbits) {
        free(srcbits);
        return BadAlloc;
    }

    (*src->drawable.pScreen->GetImage) ((DrawablePtr) src, 0, 0, width, height,
                                        XYPixmap, 1, (void *) srcbits);
    if (msk == (PixmapPtr) NULL) {
        unsigned char *bits = mskbits;

        while (--n >= 0)
            *bits++ = ~0;
    }
    else {
        /* zeroing the (pad) bits helps some ddx cursor handling */
        memset((char *) mskbits, 0, n);
        (*msk->drawable.pScreen->GetImage) ((DrawablePtr) msk, 0, 0, width,
                                            height, XYPixmap, 1,
                                            (void *) mskbits);
    }
    cm.width = width;
    cm.height = height;
    cm.xhot = stuff->x;
    cm.yhot = stuff->y;
    rc = AllocARGBCursor(srcbits, mskbits, NULL, &cm,
                         stuff->foreRed, stuff->foreGreen, stuff->foreBlue,
                         stuff->backRed, stuff->backGreen, stuff->backBlue,
                         &pCursor, client, stuff->cid);

    if (rc != Success)
        goto bail;
    if (!AddResource(stuff->cid, RT_CURSOR, (void *) pCursor)) {
        rc = BadAlloc;
        goto bail;
    }

    return Success;
 bail:
    free(srcbits);
    free(mskbits);
    return rc;
}

int
ProcCreateGlyphCursor(ClientPtr client)
{
    CursorPtr pCursor;
    int res;

    REQUEST(xCreateGlyphCursorReq);

    REQUEST_SIZE_MATCH(xCreateGlyphCursorReq);
    LEGAL_NEW_RESOURCE(stuff->cid, client);

    res = AllocGlyphCursor(stuff->source, stuff->sourceChar,
                           stuff->mask, stuff->maskChar,
                           stuff->foreRed, stuff->foreGreen, stuff->foreBlue,
                           stuff->backRed, stuff->backGreen, stuff->backBlue,
                           &pCursor, client, stuff->cid);
    if (res != Success)
        return res;
    if (AddResource(stuff->cid, RT_CURSOR, (void *) pCursor))
        return Success;
    return BadAlloc;
}

int
ProcFreeCursor(ClientPtr client)
{
    CursorPtr pCursor;
    int rc;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupResourceByType((void **) &pCursor, stuff->id, RT_CURSOR,
                                 client, DixDestroyAccess);
    if (rc == Success) {
        FreeResource(stuff->id, RT_NONE);
        return Success;
    }
    else {
        client->errorValue = stuff->id;
        return rc;
    }
}

int
ProcQueryBestSize(ClientPtr client)
{
    xQueryBestSizeReply reply;
    DrawablePtr pDraw;
    ScreenPtr pScreen;
    int rc;

    REQUEST(xQueryBestSizeReq);
    REQUEST_SIZE_MATCH(xQueryBestSizeReq);

    if ((stuff->class != CursorShape) &&
        (stuff->class != TileShape) && (stuff->class != StippleShape)) {
        client->errorValue = stuff->class;
        return BadValue;
    }

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
                           DixGetAttrAccess);
    if (rc != Success)
        return rc;
    if (stuff->class != CursorShape && pDraw->type == UNDRAWABLE_WINDOW)
        return BadMatch;
    pScreen = pDraw->pScreen;
    rc = XaceHook(XACE_SCREEN_ACCESS, client, pScreen, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    (*pScreen->QueryBestSize) (stuff->class, &stuff->width,
                               &stuff->height, pScreen);
    reply = (xQueryBestSizeReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .width = stuff->width,
        .height = stuff->height
    };
    WriteReplyToClient(client, sizeof(xQueryBestSizeReply), &reply);
    return Success;
}

int
ProcSetScreenSaver(ClientPtr client)
{
    int rc, i, blankingOption, exposureOption;

    REQUEST(xSetScreenSaverReq);
    REQUEST_SIZE_MATCH(xSetScreenSaverReq);

    for (i = 0; i < screenInfo.numScreens; i++) {
        rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, screenInfo.screens[i],
                      DixSetAttrAccess);
        if (rc != Success)
            return rc;
    }

    blankingOption = stuff->preferBlank;
    if ((blankingOption != DontPreferBlanking) &&
        (blankingOption != PreferBlanking) &&
        (blankingOption != DefaultBlanking)) {
        client->errorValue = blankingOption;
        return BadValue;
    }
    exposureOption = stuff->allowExpose;
    if ((exposureOption != DontAllowExposures) &&
        (exposureOption != AllowExposures) &&
        (exposureOption != DefaultExposures)) {
        client->errorValue = exposureOption;
        return BadValue;
    }
    if (stuff->timeout < -1) {
        client->errorValue = stuff->timeout;
        return BadValue;
    }
    if (stuff->interval < -1) {
        client->errorValue = stuff->interval;
        return BadValue;
    }

    if (blankingOption == DefaultBlanking)
        ScreenSaverBlanking = defaultScreenSaverBlanking;
    else
        ScreenSaverBlanking = blankingOption;
    if (exposureOption == DefaultExposures)
        ScreenSaverAllowExposures = defaultScreenSaverAllowExposures;
    else
        ScreenSaverAllowExposures = exposureOption;

    if (stuff->timeout >= 0)
        ScreenSaverTime = stuff->timeout * MILLI_PER_SECOND;
    else
        ScreenSaverTime = defaultScreenSaverTime;
    if (stuff->interval >= 0)
        ScreenSaverInterval = stuff->interval * MILLI_PER_SECOND;
    else
        ScreenSaverInterval = defaultScreenSaverInterval;

    SetScreenSaverTimer();
    return Success;
}

int
ProcGetScreenSaver(ClientPtr client)
{
    xGetScreenSaverReply rep;
    int rc, i;

    REQUEST_SIZE_MATCH(xReq);

    for (i = 0; i < screenInfo.numScreens; i++) {
        rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, screenInfo.screens[i],
                      DixGetAttrAccess);
        if (rc != Success)
            return rc;
    }

    rep = (xGetScreenSaverReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .timeout = ScreenSaverTime / MILLI_PER_SECOND,
        .interval = ScreenSaverInterval / MILLI_PER_SECOND,
        .preferBlanking = ScreenSaverBlanking,
        .allowExposures = ScreenSaverAllowExposures
    };
    WriteReplyToClient(client, sizeof(xGetScreenSaverReply), &rep);
    return Success;
}

int
ProcChangeHosts(ClientPtr client)
{
    REQUEST(xChangeHostsReq);

    REQUEST_FIXED_SIZE(xChangeHostsReq, stuff->hostLength);

    if (stuff->mode == HostInsert)
        return AddHost(client, (int) stuff->hostFamily,
                       stuff->hostLength, (void *) &stuff[1]);
    if (stuff->mode == HostDelete)
        return RemoveHost(client, (int) stuff->hostFamily,
                          stuff->hostLength, (void *) &stuff[1]);
    client->errorValue = stuff->mode;
    return BadValue;
}

int
ProcListHosts(ClientPtr client)
{
    xListHostsReply reply;
    int len, nHosts, result;
    BOOL enabled;
    void *pdata;

    /* REQUEST(xListHostsReq); */

    REQUEST_SIZE_MATCH(xListHostsReq);

    /* untrusted clients can't list hosts */
    result = XaceHook(XACE_SERVER_ACCESS, client, DixReadAccess);
    if (result != Success)
        return result;

    result = GetHosts(&pdata, &nHosts, &len, &enabled);
    if (result != Success)
        return result;

    reply = (xListHostsReply) {
        .type = X_Reply,
        .enabled = enabled,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(len),
        .nHosts = nHosts
    };
    WriteReplyToClient(client, sizeof(xListHostsReply), &reply);
    if (nHosts) {
        client->pSwapReplyFunc = (ReplySwapPtr) SLHostsExtend;
        WriteSwappedDataToClient(client, len, pdata);
    }
    free(pdata);
    return Success;
}

int
ProcChangeAccessControl(ClientPtr client)
{
    REQUEST(xSetAccessControlReq);

    REQUEST_SIZE_MATCH(xSetAccessControlReq);
    if ((stuff->mode != EnableAccess) && (stuff->mode != DisableAccess)) {
        client->errorValue = stuff->mode;
        return BadValue;
    }
    return ChangeAccessControl(client, stuff->mode == EnableAccess);
}

/*********************
 * CloseDownRetainedResources
 *
 *    Find all clients that are gone and have terminated in RetainTemporary
 *    and destroy their resources.
 *********************/

static void
CloseDownRetainedResources(void)
{
    int i;
    ClientPtr client;

    for (i = 1; i < currentMaxClients; i++) {
        client = clients[i];
        if (client && (client->closeDownMode == RetainTemporary)
            && (client->clientGone))
            CloseDownClient(client);
    }
}

int
ProcKillClient(ClientPtr client)
{
    REQUEST(xResourceReq);
    ClientPtr killclient;
    int rc;

    REQUEST_SIZE_MATCH(xResourceReq);
    if (stuff->id == AllTemporary) {
        CloseDownRetainedResources();
        return Success;
    }

    rc = dixLookupClient(&killclient, stuff->id, client, DixDestroyAccess);
    if (rc == Success) {
        CloseDownClient(killclient);
        if (client == killclient) {
            /* force yield and return Success, so that Dispatch()
             * doesn't try to touch client
             */
            isItTimeToYield = TRUE;
        }
        return Success;
    }
    else
        return rc;
}

int
ProcSetFontPath(ClientPtr client)
{
    unsigned char *ptr;
    unsigned long nbytes, total;
    long nfonts;
    int n;

    REQUEST(xSetFontPathReq);

    REQUEST_AT_LEAST_SIZE(xSetFontPathReq);

    nbytes = (client->req_len << 2) - sizeof(xSetFontPathReq);
    total = nbytes;
    ptr = (unsigned char *) &stuff[1];
    nfonts = stuff->nFonts;
    while (--nfonts >= 0) {
        if ((total == 0) || (total < (n = (*ptr + 1))))
            return BadLength;
        total -= n;
        ptr += n;
    }
    if (total >= 4)
        return BadLength;
    return SetFontPath(client, stuff->nFonts, (unsigned char *) &stuff[1]);
}

int
ProcGetFontPath(ClientPtr client)
{
    xGetFontPathReply reply;
    int rc, stringLens, numpaths;
    unsigned char *bufferStart;

    /* REQUEST (xReq); */

    REQUEST_SIZE_MATCH(xReq);
    rc = GetFontPath(client, &numpaths, &stringLens, &bufferStart);
    if (rc != Success)
        return rc;

    reply = (xGetFontPathReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(stringLens + numpaths),
        .nPaths = numpaths
    };

    WriteReplyToClient(client, sizeof(xGetFontPathReply), &reply);
    if (stringLens || numpaths)
        WriteToClient(client, stringLens + numpaths, bufferStart);
    return Success;
}

int
ProcChangeCloseDownMode(ClientPtr client)
{
    int rc;

    REQUEST(xSetCloseDownModeReq);
    REQUEST_SIZE_MATCH(xSetCloseDownModeReq);

    rc = XaceHook(XACE_CLIENT_ACCESS, client, client, DixManageAccess);
    if (rc != Success)
        return rc;

    if ((stuff->mode == AllTemporary) ||
        (stuff->mode == RetainPermanent) || (stuff->mode == RetainTemporary)) {
        client->closeDownMode = stuff->mode;
        return Success;
    }
    else {
        client->errorValue = stuff->mode;
        return BadValue;
    }
}

int
ProcForceScreenSaver(ClientPtr client)
{
    int rc;

    REQUEST(xForceScreenSaverReq);

    REQUEST_SIZE_MATCH(xForceScreenSaverReq);

    if ((stuff->mode != ScreenSaverReset) && (stuff->mode != ScreenSaverActive)) {
        client->errorValue = stuff->mode;
        return BadValue;
    }
    rc = dixSaveScreens(client, SCREEN_SAVER_FORCER, (int) stuff->mode);
    if (rc != Success)
        return rc;
    return Success;
}

int
ProcNoOperation(ClientPtr client)
{
    REQUEST_AT_LEAST_SIZE(xReq);

    /* noop -- don't do anything */
    return Success;
}

/**********************
 * CloseDownClient
 *
 *  Client can either mark his resources destroy or retain.  If retained and
 *  then killed again, the client is really destroyed.
 *********************/

char dispatchExceptionAtReset = DE_RESET;

void
CloseDownClient(ClientPtr client)
{
    Bool really_close_down = client->clientGone ||
        client->closeDownMode == DestroyAll;

    if (!client->clientGone) {
        /* ungrab server if grabbing client dies */
        if (grabState != GrabNone && grabClient == client) {
            UngrabServer(client);
        }
        BITCLEAR(grabWaiters, client->index);
        DeleteClientFromAnySelections(client);
        ReleaseActiveGrabs(client);
        DeleteClientFontStuff(client);
        if (!really_close_down) {
            /*  This frees resources that should never be retained
             *  no matter what the close down mode is.  Actually we
             *  could do this unconditionally, but it's probably
             *  better not to traverse all the client's resources
             *  twice (once here, once a few lines down in
             *  FreeClientResources) in the common case of
             *  really_close_down == TRUE.
             */
            FreeClientNeverRetainResources(client);
            client->clientState = ClientStateRetained;
            if (ClientStateCallback) {
                NewClientInfoRec clientinfo;

                clientinfo.client = client;
                clientinfo.prefix = (xConnSetupPrefix *) NULL;
                clientinfo.setup = (xConnSetup *) NULL;
                CallCallbacks((&ClientStateCallback), (void *) &clientinfo);
            }
        }
        client->clientGone = TRUE;      /* so events aren't sent to client */
        if (ClientIsAsleep(client))
            ClientSignal(client);
        ProcessWorkQueueZombies();
        CloseDownConnection(client);

        /* If the client made it to the Running stage, nClients has
         * been incremented on its behalf, so we need to decrement it
         * now.  If it hasn't gotten to Running, nClients has *not*
         * been incremented, so *don't* decrement it.
         */
        if (client->clientState != ClientStateInitial) {
            --nClients;
        }
    }

    if (really_close_down) {
        if (client->clientState == ClientStateRunning && nClients == 0)
            dispatchException |= dispatchExceptionAtReset;

        client->clientState = ClientStateGone;
        if (ClientStateCallback) {
            NewClientInfoRec clientinfo;

            clientinfo.client = client;
            clientinfo.prefix = (xConnSetupPrefix *) NULL;
            clientinfo.setup = (xConnSetup *) NULL;
            CallCallbacks((&ClientStateCallback), (void *) &clientinfo);
        }
        TouchListenerGone(client->clientAsMask);
        FreeClientResources(client);
        /* Disable client ID tracking. This must be done after
         * ClientStateCallback. */
        ReleaseClientIds(client);
#ifdef XSERVER_DTRACE
        XSERVER_CLIENT_DISCONNECT(client->index);
#endif
        if (client->index < nextFreeClientID)
            nextFreeClientID = client->index;
        clients[client->index] = NullClient;
        SmartLastClient = NullClient;
        dixFreeObjectWithPrivates(client, PRIVATE_CLIENT);

        while (!clients[currentMaxClients - 1])
            currentMaxClients--;
    }
}

static void
KillAllClients(void)
{
    int i;

    for (i = 1; i < currentMaxClients; i++)
        if (clients[i]) {
            /* Make sure Retained clients are released. */
            clients[i]->closeDownMode = DestroyAll;
            CloseDownClient(clients[i]);
        }
}

void
InitClient(ClientPtr client, int i, void *ospriv)
{
    client->index = i;
    client->clientAsMask = ((Mask) i) << CLIENTOFFSET;
    client->closeDownMode = i ? DestroyAll : RetainPermanent;
    client->requestVector = InitialVector;
    client->osPrivate = ospriv;
    QueryMinMaxKeyCodes(&client->minKC, &client->maxKC);
    client->smart_start_tick = SmartScheduleTime;
    client->smart_stop_tick = SmartScheduleTime;
    client->clientIds = NULL;
}

/************************
 * int NextAvailableClient(ospriv)
 *
 * OS dependent portion can't assign client id's because of CloseDownModes.
 * Returns NULL if there are no free clients.
 *************************/

ClientPtr
NextAvailableClient(void *ospriv)
{
    int i;
    ClientPtr client;
    xReq data;

    i = nextFreeClientID;
    if (i == LimitClients)
        return (ClientPtr) NULL;
    clients[i] = client =
        dixAllocateObjectWithPrivates(ClientRec, PRIVATE_CLIENT);
    if (!client)
        return (ClientPtr) NULL;
    InitClient(client, i, ospriv);
    if (!InitClientResources(client)) {
        dixFreeObjectWithPrivates(client, PRIVATE_CLIENT);
        return (ClientPtr) NULL;
    }
    data.reqType = 1;
    data.length = bytes_to_int32(sz_xReq + sz_xConnClientPrefix);
    if (!InsertFakeRequest(client, (char *) &data, sz_xReq)) {
        FreeClientResources(client);
        dixFreeObjectWithPrivates(client, PRIVATE_CLIENT);
        return (ClientPtr) NULL;
    }
    if (i == currentMaxClients)
        currentMaxClients++;
    while ((nextFreeClientID < LimitClients) && clients[nextFreeClientID])
        nextFreeClientID++;

    /* Enable client ID tracking. This must be done before
     * ClientStateCallback. */
    ReserveClientIds(client);

    if (ClientStateCallback) {
        NewClientInfoRec clientinfo;

        clientinfo.client = client;
        clientinfo.prefix = (xConnSetupPrefix *) NULL;
        clientinfo.setup = (xConnSetup *) NULL;
        CallCallbacks((&ClientStateCallback), (void *) &clientinfo);
    }
    return client;
}

int
ProcInitialConnection(ClientPtr client)
{
    REQUEST(xReq);
    xConnClientPrefix *prefix;
    int whichbyte = 1;
    char order;

    prefix = (xConnClientPrefix *) ((char *)stuff + sz_xReq);
    order = prefix->byteOrder;
    if (order != 'l' && order != 'B' && order != 'r' && order != 'R')
	return client->noClientException = -1;
    if (((*(char *) &whichbyte) && (order == 'B' || order == 'R')) ||
	(!(*(char *) &whichbyte) && (order == 'l' || order == 'r'))) {
	client->swapped = TRUE;
	SwapConnClientPrefix(prefix);
    }
    stuff->reqType = 2;
    stuff->length += bytes_to_int32(prefix->nbytesAuthProto) +
        bytes_to_int32(prefix->nbytesAuthString);
    if (client->swapped) {
        swaps(&stuff->length);
    }
    if (order == 'r' || order == 'R') {
	client->local = FALSE;
    }
    ResetCurrentRequest(client);
    return Success;
}

static int
SendConnSetup(ClientPtr client, const char *reason)
{
    xWindowRoot *root;
    int i;
    int numScreens;
    char *lConnectionInfo;
    xConnSetupPrefix *lconnSetupPrefix;

    if (reason) {
        xConnSetupPrefix csp;

        csp.success = xFalse;
        csp.lengthReason = strlen(reason);
        csp.length = bytes_to_int32(csp.lengthReason);
        csp.majorVersion = X_PROTOCOL;
        csp.minorVersion = X_PROTOCOL_REVISION;
        if (client->swapped)
            WriteSConnSetupPrefix(client, &csp);
        else
            WriteToClient(client, sz_xConnSetupPrefix, &csp);
        WriteToClient(client, (int) csp.lengthReason, reason);
        return client->noClientException = -1;
    }

    numScreens = screenInfo.numScreens;
    lConnectionInfo = ConnectionInfo;
    lconnSetupPrefix = &connSetupPrefix;

    /* We're about to start speaking X protocol back to the client by
     * sending the connection setup info.  This means the authorization
     * step is complete, and we can count the client as an
     * authorized one.
     */
    nClients++;

    client->requestVector = client->swapped ? SwappedProcVector : ProcVector;
    client->sequence = 0;
    ((xConnSetup *) lConnectionInfo)->ridBase = client->clientAsMask;
    ((xConnSetup *) lConnectionInfo)->ridMask = RESOURCE_ID_MASK;
#ifdef MATCH_CLIENT_ENDIAN
    ((xConnSetup *) lConnectionInfo)->imageByteOrder = ClientOrder(client);
    ((xConnSetup *) lConnectionInfo)->bitmapBitOrder = ClientOrder(client);
#endif
    /* fill in the "currentInputMask" */
    root = (xWindowRoot *) (lConnectionInfo + connBlockScreenStart);
#ifdef PANORAMIX
    if (noPanoramiXExtension)
        numScreens = screenInfo.numScreens;
    else
        numScreens = ((xConnSetup *) ConnectionInfo)->numRoots;
#endif

    for (i = 0; i < numScreens; i++) {
        unsigned int j;
        xDepth *pDepth;
        WindowPtr pRoot = screenInfo.screens[i]->root;

        root->currentInputMask = pRoot->eventMask | wOtherEventMasks(pRoot);
        pDepth = (xDepth *) (root + 1);
        for (j = 0; j < root->nDepths; j++) {
            pDepth = (xDepth *) (((char *) (pDepth + 1)) +
                                 pDepth->nVisuals * sizeof(xVisualType));
        }
        root = (xWindowRoot *) pDepth;
    }

    if (client->swapped) {
        WriteSConnSetupPrefix(client, lconnSetupPrefix);
        WriteSConnectionInfo(client,
                             (unsigned long) (lconnSetupPrefix->length << 2),
                             lConnectionInfo);
    }
    else {
        WriteToClient(client, sizeof(xConnSetupPrefix), lconnSetupPrefix);
        WriteToClient(client, (int) (lconnSetupPrefix->length << 2),
		      lConnectionInfo);
    }
    client->clientState = ClientStateRunning;
    if (ClientStateCallback) {
        NewClientInfoRec clientinfo;

        clientinfo.client = client;
        clientinfo.prefix = lconnSetupPrefix;
        clientinfo.setup = (xConnSetup *) lConnectionInfo;
        CallCallbacks((&ClientStateCallback), (void *) &clientinfo);
    }
    return Success;
}

int
ProcEstablishConnection(ClientPtr client)
{
    const char *reason;
    char *auth_proto, *auth_string;
    xConnClientPrefix *prefix;

    REQUEST(xReq);

    prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);
    auth_proto = (char *) prefix + sz_xConnClientPrefix;
    auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);
    if ((prefix->majorVersion != X_PROTOCOL) ||
        (prefix->minorVersion != X_PROTOCOL_REVISION))
        reason = "Protocol version mismatch";
    else
        reason = ClientAuthorized(client,
                                  (unsigned short) prefix->nbytesAuthProto,
                                  auth_proto,
                                  (unsigned short) prefix->nbytesAuthString,
                                  auth_string);

    return (SendConnSetup(client, reason));
}

void
SendErrorToClient(ClientPtr client, unsigned majorCode, unsigned minorCode,
                  XID resId, int errorCode)
{
    xError rep = {
        .type = X_Error,
        .errorCode = errorCode,
        .resourceID = resId,
        .minorCode = minorCode,
        .majorCode = majorCode
    };

    WriteEventsToClient(client, 1, (xEvent *) &rep);
}

void
MarkClientException(ClientPtr client)
{
    client->noClientException = -1;
}

/*
 * This array encodes the answer to the question "what is the log base 2
 * of the number of pixels that fit in a scanline pad unit?"
 * Note that ~0 is an invalid entry (mostly for the benefit of the reader).
 */
static int answer[6][4] = {
    /* pad   pad   pad     pad */
    /*  8     16    32    64 */

    {3, 4, 5, 6},               /* 1 bit per pixel */
    {1, 2, 3, 4},               /* 4 bits per pixel */
    {0, 1, 2, 3},               /* 8 bits per pixel */
    {~0, 0, 1, 2},              /* 16 bits per pixel */
    {~0, ~0, 0, 1},             /* 24 bits per pixel */
    {~0, ~0, 0, 1}              /* 32 bits per pixel */
};

/*
 * This array gives the answer to the question "what is the first index for
 * the answer array above given the number of bits per pixel?"
 * Note that ~0 is an invalid entry (mostly for the benefit of the reader).
 */
static int indexForBitsPerPixel[33] = {
    ~0, 0, ~0, ~0,              /* 1 bit per pixel */
    1, ~0, ~0, ~0,              /* 4 bits per pixel */
    2, ~0, ~0, ~0,              /* 8 bits per pixel */
    ~0, ~0, ~0, ~0,
    3, ~0, ~0, ~0,              /* 16 bits per pixel */
    ~0, ~0, ~0, ~0,
    4, ~0, ~0, ~0,              /* 24 bits per pixel */
    ~0, ~0, ~0, ~0,
    5                           /* 32 bits per pixel */
};

/*
 * This array gives the bytesperPixel value for cases where the number
 * of bits per pixel is a multiple of 8 but not a power of 2.
 */
static int answerBytesPerPixel[33] = {
    ~0, 0, ~0, ~0,              /* 1 bit per pixel */
    0, ~0, ~0, ~0,              /* 4 bits per pixel */
    0, ~0, ~0, ~0,              /* 8 bits per pixel */
    ~0, ~0, ~0, ~0,
    0, ~0, ~0, ~0,              /* 16 bits per pixel */
    ~0, ~0, ~0, ~0,
    3, ~0, ~0, ~0,              /* 24 bits per pixel */
    ~0, ~0, ~0, ~0,
    0                           /* 32 bits per pixel */
};

/*
 * This array gives the answer to the question "what is the second index for
 * the answer array above given the number of bits per scanline pad unit?"
 * Note that ~0 is an invalid entry (mostly for the benefit of the reader).
 */
static int indexForScanlinePad[65] = {
    ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    0, ~0, ~0, ~0,              /* 8 bits per scanline pad unit */
    ~0, ~0, ~0, ~0,
    1, ~0, ~0, ~0,              /* 16 bits per scanline pad unit */
    ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    2, ~0, ~0, ~0,              /* 32 bits per scanline pad unit */
    ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    ~0, ~0, ~0, ~0,
    3                           /* 64 bits per scanline pad unit */
};

/*
	grow the array of screenRecs if necessary.
	call the device-supplied initialization procedure
with its screen number, a pointer to its ScreenRec, argc, and argv.
	return the number of successfully installed screens.

*/

static int init_screen(ScreenPtr pScreen, int i, Bool gpu)
{
    int scanlinepad, format, depth, bitsPerPixel, j, k;

    dixInitScreenSpecificPrivates(pScreen);

    if (!dixAllocatePrivates(&pScreen->devPrivates, PRIVATE_SCREEN)) {
        return -1;
    }
    pScreen->myNum = i;
    if (gpu) {
        pScreen->myNum += GPU_SCREEN_OFFSET;
        pScreen->isGPU = TRUE;
    }
    pScreen->totalPixmapSize = 0;       /* computed in CreateScratchPixmapForScreen */
    pScreen->ClipNotify = 0;    /* for R4 ddx compatibility */
    pScreen->CreateScreenResources = 0;

    xorg_list_init(&pScreen->pixmap_dirty_list);
    xorg_list_init(&pScreen->unattached_list);
    xorg_list_init(&pScreen->output_slave_list);
    xorg_list_init(&pScreen->offload_slave_list);

    /*
     * This loop gets run once for every Screen that gets added,
     * but thats ok.  If the ddx layer initializes the formats
     * one at a time calling AddScreen() after each, then each
     * iteration will make it a little more accurate.  Worst case
     * we do this loop N * numPixmapFormats where N is # of screens.
     * Anyway, this must be called after InitOutput and before the
     * screen init routine is called.
     */
    for (format = 0; format < screenInfo.numPixmapFormats; format++) {
        depth = screenInfo.formats[format].depth;
        bitsPerPixel = screenInfo.formats[format].bitsPerPixel;
        scanlinepad = screenInfo.formats[format].scanlinePad;
        j = indexForBitsPerPixel[bitsPerPixel];
        k = indexForScanlinePad[scanlinepad];
        PixmapWidthPaddingInfo[depth].padPixelsLog2 = answer[j][k];
        PixmapWidthPaddingInfo[depth].padRoundUp =
            (scanlinepad / bitsPerPixel) - 1;
        j = indexForBitsPerPixel[8];    /* bits per byte */
        PixmapWidthPaddingInfo[depth].padBytesLog2 = answer[j][k];
        PixmapWidthPaddingInfo[depth].bitsPerPixel = bitsPerPixel;
        if (answerBytesPerPixel[bitsPerPixel]) {
            PixmapWidthPaddingInfo[depth].notPower2 = 1;
            PixmapWidthPaddingInfo[depth].bytesPerPixel =
                answerBytesPerPixel[bitsPerPixel];
        }
        else {
            PixmapWidthPaddingInfo[depth].notPower2 = 0;
        }
    }
    return 0;
}

int
AddScreen(Bool (*pfnInit) (ScreenPtr /*pScreen */ ,
                           int /*argc */ ,
                           char **      /*argv */
          ), int argc, char **argv)
{

    int i;
    ScreenPtr pScreen;
    Bool ret;

    i = screenInfo.numScreens;
    if (i == MAXSCREENS)
        return -1;

    pScreen = (ScreenPtr) calloc(1, sizeof(ScreenRec));
    if (!pScreen)
        return -1;

    ret = init_screen(pScreen, i, FALSE);
    if (ret != 0) {
        free(pScreen);
        return ret;
    }
    /* This is where screen specific stuff gets initialized.  Load the
       screen structure, call the hardware, whatever.
       This is also where the default colormap should be allocated and
       also pixel values for blackPixel, whitePixel, and the cursor
       Note that InitScreen is NOT allowed to modify argc, argv, or
       any of the strings pointed to by argv.  They may be passed to
       multiple screens.
     */
    screenInfo.screens[i] = pScreen;
    screenInfo.numScreens++;
    if (!(*pfnInit) (pScreen, argc, argv)) {
        dixFreeScreenSpecificPrivates(pScreen);
        dixFreePrivates(pScreen->devPrivates, PRIVATE_SCREEN);
        free(pScreen);
        screenInfo.numScreens--;
        return -1;
    }

    update_desktop_dimensions();

    dixRegisterScreenPrivateKey(&cursorScreenDevPriv, pScreen, PRIVATE_CURSOR,
                                0);

    return i;
}

int
AddGPUScreen(Bool (*pfnInit) (ScreenPtr /*pScreen */ ,
                              int /*argc */ ,
                              char **      /*argv */
                              ),
             int argc, char **argv)
{
    int i;
    ScreenPtr pScreen;
    Bool ret;

    i = screenInfo.numGPUScreens;
    if (i == MAXGPUSCREENS)
        return -1;

    pScreen = (ScreenPtr) calloc(1, sizeof(ScreenRec));
    if (!pScreen)
        return -1;

    ret = init_screen(pScreen, i, TRUE);
    if (ret != 0) {
        free(pScreen);
        return ret;
    }

    /* This is where screen specific stuff gets initialized.  Load the
       screen structure, call the hardware, whatever.
       This is also where the default colormap should be allocated and
       also pixel values for blackPixel, whitePixel, and the cursor
       Note that InitScreen is NOT allowed to modify argc, argv, or
       any of the strings pointed to by argv.  They may be passed to
       multiple screens.
     */
    screenInfo.gpuscreens[i] = pScreen;
    screenInfo.numGPUScreens++;
    if (!(*pfnInit) (pScreen, argc, argv)) {
        dixFreePrivates(pScreen->devPrivates, PRIVATE_SCREEN);
        free(pScreen);
        screenInfo.numGPUScreens--;
        return -1;
    }

    update_desktop_dimensions();

    return i;
}

void
RemoveGPUScreen(ScreenPtr pScreen)
{
    int idx, j;
    if (!pScreen->isGPU)
        return;

    idx = pScreen->myNum - GPU_SCREEN_OFFSET;
    for (j = idx; j < screenInfo.numGPUScreens - 1; j++) {
        screenInfo.gpuscreens[j] = screenInfo.gpuscreens[j + 1];
        screenInfo.gpuscreens[j]->myNum = j + GPU_SCREEN_OFFSET;
    }
    screenInfo.numGPUScreens--;

    /* this gets freed later in the resource list, but without
     * the screen existing it causes crashes - so remove it here */
    if (pScreen->defColormap)
        FreeResource(pScreen->defColormap, RT_COLORMAP);
    free(pScreen);

}

void
AttachUnboundGPU(ScreenPtr pScreen, ScreenPtr new)
{
    assert(new->isGPU);
    assert(!new->current_master);
    xorg_list_add(&new->unattached_head, &pScreen->unattached_list);
    new->current_master = pScreen;
}

void
DetachUnboundGPU(ScreenPtr slave)
{
    assert(slave->isGPU);
    xorg_list_del(&slave->unattached_head);
    slave->current_master = NULL;
}

void
AttachOutputGPU(ScreenPtr pScreen, ScreenPtr new)
{
    assert(new->isGPU);
    xorg_list_add(&new->output_head, &pScreen->output_slave_list);
    new->current_master = pScreen;
}

void
DetachOutputGPU(ScreenPtr slave)
{
    assert(slave->isGPU);
    xorg_list_del(&slave->output_head);
    slave->current_master = NULL;
}

void
AttachOffloadGPU(ScreenPtr pScreen, ScreenPtr new)
{
    assert(new->isGPU);
    xorg_list_add(&new->offload_head, &pScreen->offload_slave_list);
    new->current_master = pScreen;
}

void
DetachOffloadGPU(ScreenPtr slave)
{
    assert(slave->isGPU);
    xorg_list_del(&slave->offload_head);
    slave->current_master = NULL;
}

@


1.16
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d111 1
d348 1
a348 1
    clientReady = malloc(sizeof(int) * MaxClients);
d967 1
a967 1
        childIDs = malloc(numChildren * sizeof(Window));
d2790 1
a2790 1
        prgbs = calloc(1, count * sizeof(xrgb));
d2912 1
a2912 2
    n = BitmapBytePad(width) * height;
    srcbits = calloc(1, n);
d2915 1
d3487 1
a3487 1
    if (i == MAXCLIENTS)
d3507 1
a3507 1
    while ((nextFreeClientID < MAXCLIENTS) && clients[nextFreeClientID])
@


1.15
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d134 1
a134 4
#include <sys/types.h>
typedef const char *string;

#include "Xserver-dtrace.h"
@


1.14
log
@Update to xserver 1.16.4.
Contains fix for CVE-2015-0255. ok dcoppa@@
@
text
@d29 2
a30 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d32 1
a32 1
both that copyright notice and this permission notice appear in 
d35 1
a35 1
software without specific, written prior permission.  
d367 3
a369 3
       /***************** 
	*  Handle events in round robin fashion, doing input between 
	*  each round 
d1600 46
d1677 1
a1677 2
        (*pDst->pScreen->SendGraphicsExpose)
            (client, pRgn, stuff->dstDrawable, X_CopyArea, 0);
d1724 1
a1724 2
        (*pdstDraw->pScreen->SendGraphicsExpose)
            (client, pRgn, stuff->dstDrawable, X_CopyPlane, 0);
d3204 1
a3204 1
 *    Find all clients that are gone and have terminated in RetainTemporary 
d3238 1
a3238 2
        /* if an LBX proxy gets killed, isItTimeToYield will be set */
        if (isItTimeToYield || (client == killclient)) {
a3242 1
            return Success;
@


1.13
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d1959 1
a1959 1
    if (lengthProto >= (INT32_MAX / stuff->height))
@


1.12
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1959 3
@


1.11
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d263 2
a264 2
        /* Praise clients which are idle */
        if ((now - pClient->smart_check_tick) >= idle) {
a267 1
        pClient->smart_check_tick = now;
d472 1
a472 1
static char *VendorString = VENDOR_NAME;
d481 1
a481 1
SetVendorString(char *string)
d483 1
a483 1
    VendorString = string;
d654 1
a654 1
        if (!AddResource(stuff->wid, RT_WINDOW, (pointer) pWin))
d1071 1
a1071 1
        CallCallbacks(&ServerGrabCallback, (pointer) &grabinfo);
d1098 1
a1098 1
        CallCallbacks(&ServerGrabCallback, (pointer) &grabinfo);
d1210 1
a1210 1
    rc = dixLookupResourceByType((pointer *) &pFont, stuff->id, RT_FONT,
d1337 1
a1337 1
dixDestroyPixmap(pointer value, XID pid)
d1404 1
a1404 1
        if (AddResource(stuff->pid, RT_PIXMAP, (pointer) pMap))
d1419 1
a1419 1
    rc = dixLookupResourceByType((pointer *) &pMap, stuff->id, RT_PIXMAP,
d1456 1
a1456 1
    if (!AddResource(stuff->gc, RT_GC, (pointer) pGC))
d2123 1
a2123 1
                                         format, planemask, (pointer) pBuf);
d2150 1
a2150 1
                                                 format, plane, (pointer) pBuf);
d2310 1
a2310 1
    rc = dixLookupResourceByType((pointer *) &pmap, stuff->id, RT_COLORMAP,
d2336 1
a2336 1
    rc = dixLookupResourceByType((pointer *) &pSrcMap, stuff->srcCmap,
d2354 1
a2354 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->id, RT_COLORMAP,
d2383 1
a2383 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->id, RT_COLORMAP,
d2451 1
a2451 1
    rc = dixLookupResourceByType((pointer *) &pmap, stuff->cmap, RT_COLORMAP,
d2488 1
a2488 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->cmap, RT_COLORMAP,
d2533 1
a2533 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->cmap, RT_COLORMAP,
d2594 1
a2594 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->cmap, RT_COLORMAP,
d2656 1
a2656 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->cmap, RT_COLORMAP,
d2682 1
a2682 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->cmap, RT_COLORMAP,
d2708 1
a2708 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->cmap, RT_COLORMAP,
d2736 1
a2736 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->cmap, RT_COLORMAP,
d2783 1
a2783 1
    rc = dixLookupResourceByType((pointer *) &pcmp, stuff->cmap, RT_COLORMAP,
d2834 1
a2834 1
    rc = dixLookupResourceByType((pointer *) &src, stuff->source, RT_PIXMAP,
d2846 1
a2846 1
        rc = dixLookupResourceByType((pointer *) &msk, stuff->mask, RT_PIXMAP,
d2878 1
a2878 1
                                        XYPixmap, 1, (pointer) srcbits);
d2890 1
a2890 1
                                            (pointer) mskbits);
d2903 1
a2903 1
    if (!AddResource(stuff->cid, RT_CURSOR, (pointer) pCursor)) {
d2933 1
a2933 1
    if (AddResource(stuff->cid, RT_CURSOR, (pointer) pCursor))
d2947 1
a2947 1
    rc = dixLookupResourceByType((pointer *) &pCursor, stuff->id, RT_CURSOR,
d3096 1
a3096 1
                       stuff->hostLength, (pointer) &stuff[1]);
d3099 1
a3099 1
                          stuff->hostLength, (pointer) &stuff[1]);
d3110 1
a3110 1
    pointer pdata;
d3351 1
a3351 1
                CallCallbacks((&ClientStateCallback), (pointer) &clientinfo);
d3381 1
a3381 1
            CallCallbacks((&ClientStateCallback), (pointer) &clientinfo);
d3416 1
a3416 1
InitClient(ClientPtr client, int i, pointer ospriv)
a3425 1
    client->smart_check_tick = SmartScheduleTime;
d3437 1
a3437 1
NextAvailableClient(pointer ospriv)
d3477 1
a3477 1
        CallCallbacks((&ClientStateCallback), (pointer) &clientinfo);
d3597 1
a3597 1
        CallCallbacks((&ClientStateCallback), (pointer) &clientinfo);
@


1.11.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a1959 3
    if (lengthProto >= (INT32_MAX / stuff->height))
        return BadLength;

@


1.10
log
@Update to xserver 1.14.3
@
text
@d223 3
a225 2
#define SMART_SCHEDULE_DEFAULT_INTERVAL	20      /* ms */
#define SMART_SCHEDULE_MAX_SLICE	200     /* ms */
d469 1
d1978 1
a1978 1
           Mask planemask, xGetImageReply ** im_return)
d2078 8
a2085 7
    if (im_return) {
        pBuf = calloc(1, sz_xGetImageReply + length);
        if (!pBuf)
            return BadAlloc;
        if (widthBytesLine == 0)
            linesPerBuf = 0;
        else
a2086 3
        *im_return = (xGetImageReply *) pBuf;
        *(xGetImageReply *) pBuf = xgi;
        pBuf += sz_xGetImageReply;
d2088 11
a2098 23
    else {
        xgi.length = bytes_to_int32(xgi.length);
        if (widthBytesLine == 0 || height == 0)
            linesPerBuf = 0;
        else if (widthBytesLine >= IMAGE_BUFSIZE)
            linesPerBuf = 1;
        else {
            linesPerBuf = IMAGE_BUFSIZE / widthBytesLine;
            if (linesPerBuf > height)
                linesPerBuf = height;
        }
        length = linesPerBuf * widthBytesLine;
        if (linesPerBuf < height) {
            /* we have to make sure intermediate buffers don't need padding */
            while ((linesPerBuf > 1) &&
                   (length & ((1L << LOG2_BYTES_PER_SCANLINE_PAD) - 1))) {
                linesPerBuf--;
                length -= widthBytesLine;
            }
            while (length & ((1L << LOG2_BYTES_PER_SCANLINE_PAD) - 1)) {
                linesPerBuf++;
                length += widthBytesLine;
            }
a2099 3
        if (!(pBuf = calloc(1, length)))
            return BadAlloc;
        WriteReplyToClient(client, sizeof(xGetImageReply), &xgi);
d2101 3
d2132 2
a2133 3
            if (!im_return) {
                ReformatImage(pBuf, (int) (nlines * widthBytesLine),
                              BitsPerPixel(pDraw->depth), ClientOrder(client));
d2135 1
a2135 3
/* Don't split me, gcc pukes when you do */
                WriteToClient(client, (int) (nlines * widthBytesLine), pBuf);
            }
d2160 4
a2163 12
                    if (im_return) {
                        pBuf += nlines * widthBytesLine;
                    }
                    else {
                        ReformatImage(pBuf,
                                      (int) (nlines * widthBytesLine),
                                      1, ClientOrder(client));

/* Don't split me, gcc pukes when you do */
                        WriteToClient(client, (int) (nlines * widthBytesLine),
				      pBuf);
                    }
d2171 1
a2171 2
    if (!im_return)
        free(pBuf);
d2185 1
a2185 1
                      stuff->planeMask, (xGetImageReply **) NULL);
d2842 8
a2849 4
    rc = dixLookupResourceByType((pointer *) &msk, stuff->mask, RT_PIXMAP,
                                 client, DixReadAccess);
    if (rc != Success) {
        if (stuff->mask != None) {
d2853 5
d2859 2
a2860 4
    else if (src->drawable.width != msk->drawable.width
             || src->drawable.height != msk->drawable.height
             || src->drawable.depth != 1 || msk->drawable.depth != 1)
        return BadMatch;
@


1.10.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a1957 3
    if (lengthProto >= (INT32_MAX / stuff->height))
        return BadLength;

@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d3401 1
a3945 1
    assert(!new->current_master);
a3961 1
    assert(!new->current_master);
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d226 3
d230 1
a472 2
static const int padlength[4] = { 0, 3, 2, 1 };

d533 1
a533 1
    i = padlength[setup.nbytesVendor & 3];
d931 1
a931 1
    xGetGeometryReply rep;
a933 1
    memset(&rep, 0, sizeof(xGetGeometryReply));
d955 7
a961 8
    memset(&reply, 0, sizeof(xQueryTreeReply));
    reply.type = X_Reply;
    reply.root = pWin->drawable.pScreen->root->drawable.id;
    reply.sequenceNumber = client->sequence;
    if (pWin->parent)
        reply.parent = pWin->parent->drawable.id;
    else
        reply.parent = (Window) None;
d1006 6
a1011 7
        xInternAtomReply reply;

        memset(&reply, 0, sizeof(xInternAtomReply));
        reply.type = X_Reply;
        reply.length = 0;
        reply.sequenceNumber = client->sequence;
        reply.atom = atom;
a1022 2
    xGetAtomNameReply reply;
    int len;
d1028 8
a1035 6
        len = strlen(str);
        memset(&reply, 0, sizeof(xGetAtomNameReply));
        reply.type = X_Reply;
        reply.length = bytes_to_int32(len);
        reply.sequenceNumber = client->sequence;
        reply.nameLength = len;
d1037 1
a1037 1
        (void) WriteToClient(client, len, str);
d1125 6
a1130 4
    memset(&rep, 0, sizeof(xTranslateCoordsReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d1292 13
a1304 11
    reply.type = X_Reply;
    reply.length = 0;
    reply.sequenceNumber = client->sequence;
    reply.drawDirection = info.drawDirection;
    reply.fontAscent = info.fontAscent;
    reply.fontDescent = info.fontDescent;
    reply.overallAscent = info.overallAscent;
    reply.overallDescent = info.overallDescent;
    reply.overallWidth = info.overallWidth;
    reply.overallLeft = info.overallLeft;
    reply.overallRight = info.overallRight;
d2149 1
a2149 2
                (void) WriteToClient(client,
                                     (int) (nlines * widthBytesLine), pBuf);
d2184 2
a2185 3
                        (void) WriteToClient(client,
                                             (int) (nlines * widthBytesLine),
                                             pBuf);
d2457 1
a2457 1
        (pWin->drawable.pScreen, (Colormap *) & preply[1]);
a2471 1
    xAllocColorReply acr;
d2479 9
a2487 7
        acr.type = X_Reply;
        acr.length = 0;
        acr.sequenceNumber = client->sequence;
        acr.red = stuff->red;
        acr.green = stuff->green;
        acr.blue = stuff->blue;
        acr.pixel = 0;
d2516 5
a2520 6
        xAllocNamedColorReply ancr;

        ancr.type = X_Reply;
        ancr.length = 0;
        ancr.sequenceNumber = client->sequence;

a2560 1
        xAllocColorCellsReply accr;
d2590 7
a2596 5
            accr.type = X_Reply;
            accr.length = bytes_to_int32(length);
            accr.sequenceNumber = client->sequence;
            accr.nPixels = npixels;
            accr.nMasks = nmasks;
d2636 5
a2640 3
        acpr.type = X_Reply;
        acpr.sequenceNumber = client->sequence;
        acpr.nPixels = npixels;
d2778 6
a2783 5
        memset(&qcr, 0, sizeof(xQueryColorsReply));
        qcr.type = X_Reply;
        qcr.length = bytes_to_int32(count * sizeof(xrgb));
        qcr.sequenceNumber = client->sequence;
        qcr.nColors = count;
d2811 1
a2811 1
        xLookupColorReply lcr;
d2815 12
a2826 7
             &lcr.exactRed, &lcr.exactGreen, &lcr.exactBlue)) {
            lcr.type = X_Reply;
            lcr.length = 0;
            lcr.sequenceNumber = client->sequence;
            lcr.screenRed = lcr.exactRed;
            lcr.screenGreen = lcr.exactGreen;
            lcr.screenBlue = lcr.exactBlue;
d3006 7
a3012 6
    memset(&reply, 0, sizeof(xQueryBestSizeReply));
    reply.type = X_Reply;
    reply.length = 0;
    reply.sequenceNumber = client->sequence;
    reply.width = stuff->width;
    reply.height = stuff->height;
d3092 9
a3100 7
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.timeout = ScreenSaverTime / MILLI_PER_SECOND;
    rep.interval = ScreenSaverInterval / MILLI_PER_SECOND;
    rep.preferBlanking = ScreenSaverBlanking;
    rep.allowExposures = ScreenSaverAllowExposures;
d3127 1
d3139 1
a3139 1
    result = GetHosts(&pdata, &nHosts, &len, &reply.enabled);
d3142 8
a3149 4
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.nHosts = nHosts;
    reply.length = bytes_to_int32(len);
d3264 6
a3269 4
    reply.type = X_Reply;
    reply.sequenceNumber = client->sequence;
    reply.length = bytes_to_int32(stringLens + numpaths);
    reply.nPaths = numpaths;
d3273 1
a3273 2
        (void) WriteToClient(client, stringLens + numpaths,
                             (char *) bufferStart);
d3506 1
d3508 8
a3515 7
    prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);
    if ((prefix->byteOrder != 'l') && (prefix->byteOrder != 'B'))
        return client->noClientException = -1;
    if (((*(char *) &whichbyte) && (prefix->byteOrder == 'B')) ||
        (!(*(char *) &whichbyte) && (prefix->byteOrder == 'l'))) {
        client->swapped = TRUE;
        SwapConnClientPrefix(prefix);
d3523 3
d3550 2
a3551 2
            (void) WriteToClient(client, sz_xConnSetupPrefix, (char *) &csp);
        (void) WriteToClient(client, (int) csp.lengthReason, reason);
d3604 3
a3606 4
        (void) WriteToClient(client, sizeof(xConnSetupPrefix),
                             (char *) lconnSetupPrefix);
        (void) WriteToClient(client, (int) (lconnSetupPrefix->length << 2),
                             lConnectionInfo);
d3649 7
a3655 8
    xError rep;

    memset(&rep, 0, sizeof(xError));
    rep.type = X_Error;
    rep.errorCode = errorCode;
    rep.majorCode = majorCode;
    rep.minorCode = minorCode;
    rep.resourceID = resId;
d3749 1
a3749 6
int
AddScreen(Bool (*pfnInit) (int /*index */ ,
                           ScreenPtr /*pScreen */ ,
                           int /*argc */ ,
                           char **      /*argv */
          ), int argc, char **argv)
a3750 2

    int i;
a3751 1
    ScreenPtr pScreen;
d3753 1
a3753 7
    i = screenInfo.numScreens;
    if (i == MAXSCREENS)
        return -1;

    pScreen = (ScreenPtr) calloc(1, sizeof(ScreenRec));
    if (!pScreen)
        return -1;
a3755 1
        free(pScreen);
d3759 4
d3767 5
d3802 2
d3805 24
d3839 2
a3840 1
    if (!(*pfnInit) (i, pScreen, argc, argv)) {
d3854 121
@


1.7
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@a24 1

a98 2


d136 1
d153 1
d165 1
a165 1
static int nextFreeClientID; /* always MIN free client ID */
d167 1
a167 1
static int	nClients;	/* number of authorized clients */
d200 1
a200 1
	systime.months++;
d202 1
a202 1
	ProcessInputEvents();
d204 1
a204 1
	currentTime = systime;
d216 3
a218 3
	systime.months++;
    if (*checkForInput[0] == *checkForInput[1])
	currentTime = systime;
a220 1

d223 2
a224 2
#define SMART_SCHEDULE_DEFAULT_INTERVAL	20	    /* ms */
#define SMART_SCHEDULE_MAX_SLICE	200	    /* ms */
d232 2
a233 2
static ClientPtr   SmartLastClient;
static int	   SmartLastIndex[SMART_MAX_PRIORITY-SMART_MIN_PRIORITY+1];
d236 1
a236 1
long	    SmartLastPrint;
d239 1
a239 1
void        Dispatch(void);
d242 1
a242 1
SmartScheduleClient (int *clientReady, int nready)
d244 7
a250 7
    ClientPtr	pClient;
    int		i;
    int		client;
    int		bestPrio, best = 0;
    int		bestRobin, robin;
    long	now = SmartScheduleTime;
    long	idle;
d255 21
a275 21
    for (i = 0; i < nready; i++)
    {
	client = clientReady[i];
	pClient = clients[client];
	/* Praise clients which are idle */
	if ((now - pClient->smart_check_tick) >= idle)
	{
	    if (pClient->smart_priority < 0)
		pClient->smart_priority++;
	}
	pClient->smart_check_tick = now;
	
	/* check priority to select best client */
	robin = (pClient->index - SmartLastIndex[pClient->smart_priority-SMART_MIN_PRIORITY]) & 0xff;
	if (pClient->smart_priority > bestPrio ||
	    (pClient->smart_priority == bestPrio && robin > bestRobin))
	{
	    bestPrio = pClient->smart_priority;
	    bestRobin = robin;
	    best = client;
	}
d277 2
a278 2
	if ((now - SmartLastPrint) >= 5000)
	    fprintf (stderr, " %2d: %3d", client, pClient->smart_priority);
d282 3
a284 4
    if ((now - SmartLastPrint) >= 5000)
    {
	fprintf (stderr, " use %2d\n", best);
	SmartLastPrint = now;
d288 1
a288 1
    SmartLastIndex[bestPrio-SMART_MIN_PRIORITY] = pClient->index;
d292 3
a294 4
    if (SmartLastClient != pClient)
    {
	pClient->smart_start_tick = now;
	SmartLastClient = pClient;
d299 10
a308 12
    if (nready == 1 && SmartScheduleLatencyLimited == 0)
    {
	/*
	 * If it's been a long time since another client
	 * has run, bump the slice up to get maximal
	 * performance from a single client
	 */
	if ((now - pClient->smart_start_tick) > 1000 &&
	    SmartScheduleSlice < SmartScheduleMaxSlice)
	{
	    SmartScheduleSlice += SmartScheduleInterval;
	}
d310 2
a311 3
    else
    {
	SmartScheduleSlice = SmartScheduleInterval;
d330 1
a330 1
	SmartScheduleLatencyLimited = 0;
d336 6
a341 6
    int        *clientReady;     /* array of request ready clients */
    int	result;
    ClientPtr	client;
    int	nready;
    HWEventQueuePtr* icheck = checkForInput;
    long			start_tick;
d348 1
a348 1
	return;
d351 12
a362 15
    while (!dispatchException)
    {
        if (*icheck[0] != *icheck[1])
	{
	    ProcessInputEvents();
	    FlushIfCriticalOutputPending();
	}

	nready = WaitForSomething(clientReady);

	if (nready && !SmartScheduleDisable)
	{
	    clientReady[0] = SmartScheduleClient (clientReady, nready);
	    nready = 1;
	}
d368 47
a414 49
	while (!dispatchException && (--nready >= 0))
	{
	    client = clients[clientReady[nready]];
	    if (! client)
	    {
		/* KillClient can cause this to happen */
		continue;
	    }
	    /* GrabServer activation can cause this to be true */
	    if (grabState == GrabKickout)
	    {
		grabState = GrabActive;
		break;
	    }
	    isItTimeToYield = FALSE;
 
	    start_tick = SmartScheduleTime;
	    while (!isItTimeToYield)
	    {
	        if (*icheck[0] != *icheck[1])
		    ProcessInputEvents();
		
		FlushIfCriticalOutputPending();
		if (!SmartScheduleDisable && 
		    (SmartScheduleTime - start_tick) >= SmartScheduleSlice)
		{
		    /* Penalize clients which consume ticks */
		    if (client->smart_priority > SMART_MIN_PRIORITY)
			client->smart_priority--;
		    break;
		}
		/* now, finally, deal with client requests */

	        result = ReadRequestFromClient(client);
	        if (result <= 0) 
	        {
		    if (result < 0)
			CloseDownClient(client);
		    break;
	        }

		client->sequence++;
		client->majorOp = ((xReq *)client->requestBuffer)->reqType;
		client->minorOp = 0;
		if (client->majorOp >= EXTENSION_BASE) {
		    ExtensionEntry *ext = GetExtensionEntry(client->majorOp);
		    if (ext)
			client->minorOp = ext->MinorOpcode(client);
		}
d416 6
a421 5
		if (XSERVER_REQUEST_START_ENABLED())
		    XSERVER_REQUEST_START(LookupMajorName(client->majorOp),
					  client->majorOp,
					  ((xReq *)client->requestBuffer)->length,
					  client->index, client->requestBuffer);
d423 9
a431 8
		if (result > (maxBigRequestSize << 2))
		    result = BadLength;
		else {
		    result = XaceHookDispatch(client, client->majorOp);
		    if (result == Success)
			result = (* client->requestVector[client->majorOp])(client);
		    XaceHookAuditEnd(client, result);
		}
d433 4
a436 4
		if (XSERVER_REQUEST_DONE_ENABLED())
		    XSERVER_REQUEST_DONE(LookupMajorName(client->majorOp),
					 client->majorOp, client->sequence,
					 client->index, result);
d439 17
a455 19
		if (client->noClientException != Success)
		{
		    CloseDownClient(client);
		    break;
		}
		else if (result != Success)
		{
		    SendErrorToClient(client, client->majorOp,
				      client->minorOp,
				      client->errorValue, result);
		    break;
		}
	    }
	    FlushAllOutput();
	    client = clients[clientReady[nready]];
	    if (client)
		client->smart_stop_tick = SmartScheduleTime;
	}
	dispatchException &= ~DE_PRIORITYCHANGE;
d458 1
a458 1
    ddxBeforeReset ();
d466 1
a466 1
static int  VendorRelease = VENDOR_RELEASE;
d469 1
a469 1
static const int padlength[4] = {0, 3, 2, 1};
d488 1
a488 1
    xDepth	depth;
d492 1
a492 3
    int i, j, k,
        lenofblock,
        sizesofar = 0;
a494 1

d517 3
a519 3
            pad_to_int32(setup.nbytesVendor) +
	    (setup.numFormats * sizeof(xPixmapFormat)) +
            (setup.numRoots * sizeof(xWindowRoot));
d522 1
a522 1
	return FALSE;
d524 1
a524 1
    memmove(ConnectionInfo, (char *)&setup, sizeof(xConnSetup));
d528 1
a528 1
    memmove(pBuf, VendorString, (int)setup.nbytesVendor);
d534 1
a534 1
	*pBuf++ = 0;
d537 7
a543 8
    for (i=0; i<screenInfo.numPixmapFormats; i++)
    {
	format.depth = screenInfo.formats[i].depth;
	format.bitsPerPixel = screenInfo.formats[i].bitsPerPixel;
	format.scanLinePad = screenInfo.formats[i].scanlinePad;
	memmove(pBuf, (char *)&format, sizeof(xPixmapFormat));
	pBuf += sizeof(xPixmapFormat);
	sizesofar += sizeof(xPixmapFormat);
d549 58
a606 64
    for (i=0; i<screenInfo.numScreens; i++)
    {
	ScreenPtr	pScreen;
	DepthPtr	pDepth;
	VisualPtr	pVisual;

	pScreen = screenInfo.screens[i];
	root.windowId = pScreen->root->drawable.id;
	root.defaultColormap = pScreen->defColormap;
	root.whitePixel = pScreen->whitePixel;
	root.blackPixel = pScreen->blackPixel;
	root.currentInputMask = 0;    /* filled in when sent */
	root.pixWidth = pScreen->width;
	root.pixHeight = pScreen->height;
	root.mmWidth = pScreen->mmWidth;
	root.mmHeight = pScreen->mmHeight;
	root.minInstalledMaps = pScreen->minInstalledCmaps;
	root.maxInstalledMaps = pScreen->maxInstalledCmaps;
	root.rootVisualID = pScreen->rootVisual;
	root.backingStore = pScreen->backingStoreSupport;
	root.saveUnders = FALSE;
	root.rootDepth = pScreen->rootDepth;
	root.nDepths = pScreen->numDepths;
	memmove(pBuf, (char *)&root, sizeof(xWindowRoot));
	sizesofar += sizeof(xWindowRoot);
	pBuf += sizeof(xWindowRoot);

	pDepth = pScreen->allowedDepths;
	for(j = 0; j < pScreen->numDepths; j++, pDepth++)
	{
	    lenofblock += sizeof(xDepth) +
		    (pDepth->numVids * sizeof(xVisualType));
	    pBuf = (char *)realloc(ConnectionInfo, lenofblock);
	    if (!pBuf)
	    {
		free(ConnectionInfo);
		return FALSE;
	    }
	    ConnectionInfo = pBuf;
	    pBuf += sizesofar;
	    depth.depth = pDepth->depth;
	    depth.nVisuals = pDepth->numVids;
	    memmove(pBuf, (char *)&depth, sizeof(xDepth));
	    pBuf += sizeof(xDepth);
	    sizesofar += sizeof(xDepth);
	    for(k = 0; k < pDepth->numVids; k++)
	    {
		vid = pDepth->vids[k];
		for (pVisual = pScreen->visuals;
		     pVisual->vid != vid;
		     pVisual++)
		    ;
		visual.visualID = vid;
		visual.class = pVisual->class;
		visual.bitsPerRGB = pVisual->bitsPerRGBValue;
		visual.colormapEntries = pVisual->ColormapEntries;
		visual.redMask = pVisual->redMask;
		visual.greenMask = pVisual->greenMask;
		visual.blueMask = pVisual->blueMask;
		memmove(pBuf, (char *)&visual, sizeof(xVisualType));
		pBuf += sizeof(xVisualType);
		sizesofar += sizeof(xVisualType);
	    }
	}
d609 1
a609 1
    connSetupPrefix.length = lenofblock/4;
a614 1

d625 1
d630 1
a630 1
    
d638 2
a639 3
    if (!stuff->width || !stuff->height)
    {
	client->errorValue = 0;
d643 6
a648 8
			      stuff->y, stuff->width, stuff->height, 
			      stuff->borderWidth, stuff->class,
			      stuff->mask, (XID *) &stuff[1], 
			      (int)stuff->depth, 
			      client, stuff->visual, &rc);
    if (pWin)
    {
	Mask mask = pWin->eventMask;
d650 4
a653 4
	pWin->eventMask = 0; /* subterfuge in case AddResource fails */
	if (!AddResource(stuff->wid, RT_WINDOW, (pointer)pWin))
	    return BadAlloc;
	pWin->eventMask = mask;
d662 1
d677 1
a677 3
				  stuff->valueMask, 
				  (XID *) &stuff[1], 
				  client);
d684 1
d692 1
a692 1
	return rc;
d703 1
d710 1
a710 1
	return rc;
d712 5
a716 5
	rc = dixLookupWindow(&pWin, pWin->parent->drawable.id, client,
			     DixRemoveAccess);
	if (rc != Success)
	    return rc;
	FreeResource(stuff->id, RT_NONE);
d725 1
d732 1
a732 1
	return rc;
d741 1
d744 1
a744 1
		  
d761 1
d773 1
a773 1
	return BadMatch;
d775 2
a776 2
	(pParent->drawable.depth != pWin->drawable.depth))
	return BadMatch;
d778 2
a779 2
	(pParent->drawable.class == InputOnly))
	return BadMatch;
d781 1
a781 1
		     (short)stuff->x, (short)stuff->y, client);
d788 1
d797 1
a797 1
           /* update cache to say it is mapped */
d805 1
d814 1
a814 1
           /* update cache to say it is mapped */
d822 1
d831 1
a831 1
           /* update cache to say it is mapped */
d839 1
d855 1
d861 1
a861 1
			 DixManageAccess|DixSetAttrAccess);
d865 1
a865 1
    if (Ones((Mask)stuff->mask) != len)
d867 1
a867 1
    return ConfigureWindow(pWin, (Mask)stuff->mask, (XID *) &stuff[1], client);
d874 1
d879 2
a880 4
    if ((stuff->direction != RaiseLowest) &&
	(stuff->direction != LowerHighest))
    {
	client->errorValue = stuff->direction;
d886 1
a886 1
    CirculateWindow(pWin, (int)stuff->direction, client);
d891 1
a891 1
GetGeometry(ClientPtr client, xGetGeometryReply *rep)
d895 1
d901 1
a901 1
	return rc;
d911 6
a916 6
    if (WindowDrawable(pDraw->type))
    {
        WindowPtr pWin = (WindowPtr)pDraw;
	rep->x = pWin->origin.x - wBorderWidth (pWin);
	rep->y = pWin->origin.y - wBorderWidth (pWin);
	rep->borderWidth = pWin->borderWidth;
d918 3
a920 3
    else /* DRAWABLE_PIXMAP */
    {
	rep->x = rep->y = rep->borderWidth = 0;
a925 1

d934 1
a934 1
	return status;
a939 1

d946 2
a947 1
    Window  *childIDs = (Window *)NULL;
d959 1
a959 1
	reply.parent = pWin->parent->drawable.id;
d961 1
a961 1
        reply.parent = (Window)None;
d964 3
a966 4
	numChildren++;
    if (numChildren)
    {
	int curChild = 0;
d968 6
a973 5
	childIDs = malloc(numChildren * sizeof(Window));
	if (!childIDs)
	    return BadAlloc;
	for (pChild = pWin->lastChild; pChild != pHead; pChild = pChild->prevSib)
	    childIDs[curChild++] = pChild->drawable.id;
d975 1
a975 1
    
d978 1
a978 1
    
d980 5
a984 5
    if (numChildren)
    {
    	client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
	WriteSwappedDataToClient(client, numChildren * sizeof(Window), childIDs);
	free(childIDs);
d995 1
d999 2
a1000 3
    if ((stuff->onlyIfExists != xTrue) && (stuff->onlyIfExists != xFalse))
    {
	client->errorValue = stuff->onlyIfExists;
d1005 10
a1014 10
    if (atom != BAD_RESOURCE)
    {
	xInternAtomReply reply;
	memset(&reply, 0, sizeof(xInternAtomReply));
	reply.type = X_Reply;
	reply.length = 0;
	reply.sequenceNumber = client->sequence;
	reply.atom = atom;
	WriteReplyToClient(client, sizeof(xInternAtomReply), &reply);
	return Success;
d1017 1
a1017 1
	return BadAlloc;
d1026 1
d1030 14
a1043 16
    if ( (str = NameForAtom(stuff->id)) )
    {
	len = strlen(str);
	memset(&reply, 0, sizeof(xGetAtomNameReply));
	reply.type = X_Reply;
	reply.length = bytes_to_int32(len);
	reply.sequenceNumber = client->sequence;
	reply.nameLength = len;
	WriteReplyToClient(client, sizeof(xGetAtomNameReply), &reply);
	(void)WriteToClient(client, len, str);
	return Success;
    }
    else 
    { 
	client->errorValue = stuff->id;
	return BadAtom;
d1051 1
d1053 6
a1058 7
    if (grabState != GrabNone && client != grabClient)
    {
	ResetCurrentRequest(client);
	client->sequence--;
	BITSET(grabWaiters, client->index);
	IgnoreClient(client);
	return Success;
d1062 1
a1062 1
	return rc;
d1066 6
a1071 6
    if (ServerGrabCallback)
    {
	ServerGrabInfoRec grabinfo;
	grabinfo.client = client;
	grabinfo.grabstate  = SERVER_GRABBED;
	CallCallbacks(&ServerGrabCallback, (pointer)&grabinfo);
d1084 7
a1090 9
    for (i = mskcnt; --i >= 0 && !grabWaiters[i]; )
	;
    if (i >= 0)
    {
	i <<= 5;
	while (!GETBIT(grabWaiters, i))
	    i++;
	BITCLEAR(grabWaiters, i);
	AttendClient(clients[i]);
d1093 6
a1098 6
    if (ServerGrabCallback)
    {
	ServerGrabInfoRec grabinfo;
	grabinfo.client = client;
	grabinfo.grabstate  = SERVER_UNGRABBED;
	CallCallbacks(&ServerGrabCallback, (pointer)&grabinfo);
d1130 2
a1131 3
    if (!SAME_SCREENS(pWin->drawable, pDst->drawable))
    {
	rep.sameScreen = xFalse;
d1133 1
a1133 1
	rep.dstX = rep.dstY = 0;
d1135 40
a1174 41
    else
    {
	INT16 x, y;
	rep.sameScreen = xTrue;
	rep.child = None;
	/* computing absolute coordinates -- adjust to destination later */
	x = pWin->drawable.x + stuff->srcX;
	y = pWin->drawable.y + stuff->srcY;
	pWin = pDst->firstChild;
	while (pWin)
	{
	    BoxRec  box;
	    if ((pWin->mapped) &&
		(x >= pWin->drawable.x - wBorderWidth (pWin)) &&
		(x < pWin->drawable.x + (int)pWin->drawable.width +
		 wBorderWidth (pWin)) &&
		(y >= pWin->drawable.y - wBorderWidth (pWin)) &&
		(y < pWin->drawable.y + (int)pWin->drawable.height +
		 wBorderWidth (pWin))
		/* When a window is shaped, a further check
		 * is made to see if the point is inside
		 * borderSize
		 */
		&& (!wBoundingShape(pWin) ||
		    RegionContainsPoint(&pWin->borderSize, x, y, &box))
		
		&& (!wInputShape(pWin) ||
		    RegionContainsPoint(wInputShape(pWin),
					x - pWin->drawable.x,
					y - pWin->drawable.y, &box))
		)
            {
		rep.child = pWin->drawable.id;
		pWin = (WindowPtr) NULL;
	    }
	    else
		pWin = pWin->nextSib;
	}
	/* adjust to destination coordinates */
	rep.dstX = x - pDst->drawable.x;
	rep.dstY = y - pDst->drawable.y;
d1183 2
a1184 1
    int	err;
d1191 3
a1193 4
		stuff->nbytes, (char *)&stuff[1]);
    if (err == Success)
    {
	return Success;
d1196 1
a1196 1
	return err;
d1204 1
d1208 3
a1210 4
    rc = dixLookupResourceByType((pointer *)&pFont, stuff->id, RT_FONT,
				 client, DixDestroyAccess);
    if (rc == Success)
    {
d1212 1
a1212 1
	return Success;
d1214 2
a1215 3
    else
    {
	client->errorValue = stuff->id;
d1223 1
a1223 1
    xQueryFontReply	*reply;
d1226 1
d1232 1
a1232 1
	return rc;
d1235 24
a1258 26
	xCharInfo	*pmax = FONTINKMAX(pFont);
	xCharInfo	*pmin = FONTINKMIN(pFont);
	int		nprotoxcistructs;
	int		rlength;

	nprotoxcistructs = (
	   pmax->rightSideBearing == pmin->rightSideBearing &&
	   pmax->leftSideBearing == pmin->leftSideBearing &&
	   pmax->descent == pmin->descent &&
	   pmax->ascent == pmin->ascent &&
	   pmax->characterWidth == pmin->characterWidth) ?
		0 : N2dChars(pFont);

	rlength = sizeof(xQueryFontReply) +
	             FONTINFONPROPS(FONTCHARSET(pFont)) * sizeof(xFontProp)  +
		     nprotoxcistructs * sizeof(xCharInfo);
	reply = calloc(1, rlength);
	if(!reply)
	{
	    return BadAlloc;
	}

	reply->type = X_Reply;
	reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
	reply->sequenceNumber = client->sequence;
	QueryFont( pFont, reply, nprotoxcistructs);
d1261 2
a1262 2
	free(reply);
	return Success;
d1274 1
d1277 1
a1277 1
        
d1280 1
a1280 1
	return rc;
d1284 3
a1286 4
    if (stuff->oddLength)
    {
	if (length == 0)
	    return BadLength;
d1289 2
a1290 2
    if (!QueryTextExtents(pFont, length, (unsigned char *)&stuff[1], &info))
	return BadAlloc;
d1313 2
a1314 2
    return ListFonts(client, (unsigned char *) &stuff[1], stuff->nbytes, 
	stuff->maxNames);
d1325 1
a1325 1
				  (unsigned char *) &stuff[1], stuff->maxNames);
d1335 3
a1337 2
    PixmapPtr pPixmap = (PixmapPtr)value;
    return (*pPixmap->drawable.pScreen->DestroyPixmap)(pPixmap);
d1345 1
d1353 1
a1353 1
    
d1355 1
a1355 1
			   DixGetAttrAccess);
d1357 1
a1357 1
	return rc;
d1359 2
a1360 3
    if (!stuff->width || !stuff->height)
    {
	client->errorValue = 0;
d1363 15
a1377 16
    if (stuff->width > 32767 || stuff->height > 32767)
    {
	/* It is allowed to try and allocate a pixmap which is larger than
	 * 32767 in either dimension. However, all of the framebuffer code
	 * is buggy and does not reliably draw to such big pixmaps, basically
	 * because the Region data structure operates with signed shorts
	 * for the rectangles in it.
	 *
	 * Furthermore, several places in the X server computes the
	 * size in bytes of the pixmap and tries to store it in an
	 * integer. This integer can overflow and cause the allocated size
	 * to be much smaller.
	 *
	 * So, such big pixmaps are rejected here with a BadAlloc
	 */
	return BadAlloc;
d1379 1
a1379 2
    if (stuff->depth != 1)
    {
d1381 21
a1401 23
        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)
	   if (pDepth->depth == stuff->depth)
               goto CreatePmap;
	client->errorValue = stuff->depth;
        return BadValue;
    }
CreatePmap:
    pMap = (PixmapPtr)(*pDraw->pScreen->CreatePixmap)
		(pDraw->pScreen, stuff->width,
		 stuff->height, stuff->depth, 0);
    if (pMap)
    {
	pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	pMap->drawable.id = stuff->pid;
	/* security creation/labeling check */
	rc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, RT_PIXMAP,
		      pMap, RT_NONE, NULL, DixCreateAccess);
	if (rc != Success) {
	    (*pDraw->pScreen->DestroyPixmap)(pMap);
	    return rc;
	}
	if (AddResource(stuff->pid, RT_PIXMAP, (pointer)pMap))
	    return Success;
d1411 1
d1415 5
a1419 6
    rc = dixLookupResourceByType((pointer *)&pMap, stuff->id, RT_PIXMAP, client,
			   DixDestroyAccess);
    if (rc == Success)
    {
	FreeResource(stuff->id, RT_NONE);
	return Success;
d1421 3
a1423 4
    else 
    {
	client->errorValue = stuff->id;
	return rc;
d1434 1
d1441 1
a1441 1
			   DixGetAttrAccess);
d1443 1
a1443 1
	return rc;
d1445 1
a1445 1
    len = client->req_len -  bytes_to_int32(sizeof(xCreateGCReq));
d1448 2
a1449 2
    pGC = (GC *)CreateGC(pDraw, stuff->mask, (XID *) &stuff[1], &error,
			 stuff->gc, client);
d1452 2
a1453 2
    if (!AddResource(stuff->gc, RT_GC, (pointer)pGC))
	return BadAlloc;
d1463 1
d1469 1
a1469 1
	return result;
d1471 1
a1471 1
    len = client->req_len -  bytes_to_int32(sizeof(xChangeGCReq));
d1484 1
d1490 1
a1490 1
	return result;
d1493 1
a1493 1
	return result;
d1496 3
a1498 4
    if (stuff->mask & ~GCAllBits)
    {
	client->errorValue = stuff->mask;
	return BadValue;
d1508 1
d1512 3
a1514 4
    if (stuff->nDashes == 0)
    {
	 client->errorValue = 0;
         return BadValue;
d1517 1
a1517 1
    result = dixLookupGC(&pGC,stuff->gc, client, DixSetAttrAccess);
d1519 1
a1519 1
	return result;
d1525 1
a1525 1
		       (unsigned char *)&stuff[1]);
d1531 1
a1531 1
    int	nr, result;
d1533 1
d1538 2
a1539 3
	(stuff->ordering != YXSorted) && (stuff->ordering != YXBanded))
    {
	client->errorValue = stuff->ordering;
d1542 1
a1542 1
    result = dixLookupGC(&pGC,stuff->gc, client, DixSetAttrAccess);
d1544 2
a1545 2
	return result;
		 
d1548 1
a1548 1
	return BadLength;
d1551 1
a1551 1
			  nr, (xRectangle *)&stuff[1], (int)stuff->ordering);
d1559 1
d1565 1
a1565 1
	return rc;
d1582 6
a1587 8
    if (pWin->drawable.class == InputOnly)
    {
	client->errorValue = stuff->window;
	return BadMatch;
    }		    
    if ((stuff->exposures != xTrue) && (stuff->exposures != xFalse))
    {
	client->errorValue = stuff->exposures;
d1590 3
a1592 3
    (*pWin->drawable.pScreen->ClearToBackground)(pWin, stuff->x, stuff->y,
			       stuff->width, stuff->height,
			       (Bool)stuff->exposures);
d1602 1
d1609 10
a1618 12
    VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pDst, DixWriteAccess); 
    if (stuff->dstDrawable != stuff->srcDrawable)
    {
	rc = dixLookupDrawable(&pSrc, stuff->srcDrawable, client, 0,
				 DixReadAccess);
	if (rc != Success)
	    return rc;
	if ((pDst->pScreen != pSrc->pScreen) || (pDst->depth != pSrc->depth))
	{
	    client->errorValue = stuff->dstDrawable;
	    return BadMatch;
	}
d1623 8
a1630 9
    pRgn = (*pGC->ops->CopyArea)(pSrc, pDst, pGC, stuff->srcX, stuff->srcY,
				 stuff->width, stuff->height, 
				 stuff->dstX, stuff->dstY);
    if (pGC->graphicsExposures)
    {
	(*pDst->pScreen->SendGraphicsExpose)
 		(client, pRgn, stuff->dstDrawable, X_CopyArea, 0);
	if (pRgn)
	    RegionDestroy(pRgn);
d1641 1
d1649 10
a1658 12
    if (stuff->dstDrawable != stuff->srcDrawable)
    {
	rc = dixLookupDrawable(&psrcDraw, stuff->srcDrawable, client, 0,
			       DixReadAccess);
	if (rc != Success)
	    return rc;

	if (pdstDraw->pScreen != psrcDraw->pScreen)
	{
	    client->errorValue = stuff->dstDrawable;
	    return BadMatch;
	}
d1664 4
a1667 5
    if(stuff->bitPlane == 0 || (stuff->bitPlane & (stuff->bitPlane - 1)) ||
       (stuff->bitPlane > (1L << (psrcDraw->depth - 1))))
    {
       client->errorValue = stuff->bitPlane;
       return BadValue;
d1670 9
a1678 9
    pRgn = (*pGC->ops->CopyPlane)(psrcDraw, pdstDraw, pGC, stuff->srcX, stuff->srcY,
				 stuff->width, stuff->height, 
				 stuff->dstX, stuff->dstY, stuff->bitPlane);
    if (pGC->graphicsExposures)
    {
	(*pdstDraw->pScreen->SendGraphicsExpose)
 		(client, pRgn, stuff->dstDrawable, X_CopyPlane, 0);
	if (pRgn)
	    RegionDestroy(pRgn);
d1689 1
d1693 3
a1695 4
    if ((stuff->coordMode != CoordModeOrigin) && 
	(stuff->coordMode != CoordModePrevious))
    {
	client->errorValue = stuff->coordMode;
d1698 1
a1698 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess); 
d1701 2
a1702 2
        (*pGC->ops->PolyPoint)(pDraw, pGC, stuff->coordMode, npoint,
			  (xPoint *) &stuff[1]);
d1712 1
d1716 3
a1718 4
    if ((stuff->coordMode != CoordModeOrigin) && 
	(stuff->coordMode != CoordModePrevious))
    {
	client->errorValue = stuff->coordMode;
d1724 2
a1725 2
	(*pGC->ops->Polylines)(pDraw, pGC, stuff->coordMode, npoint, 
			      (DDXPointPtr) &stuff[1]);
d1735 1
d1742 1
a1742 1
	return BadLength;
d1745 1
a1745 1
        (*pGC->ops->PolySegment)(pDraw, pGC, nsegs, (xSegment *) &stuff[1]);
d1750 1
a1750 1
ProcPolyRectangle (ClientPtr client)
d1755 1
d1762 1
a1762 1
	return BadLength;
d1765 2
a1766 2
        (*pGC->ops->PolyRectangle)(pDraw, pGC, 
		    nrects, (xRectangle *) &stuff[1]);
d1773 1
a1773 1
    int		narcs;
d1776 1
d1783 1
a1783 1
	return BadLength;
d1786 1
a1786 1
        (*pGC->ops->PolyArc)(pDraw, pGC, narcs, (xArc *) &stuff[1]);
d1793 1
a1793 1
    int          things;
d1796 1
d1800 3
a1802 4
    if ((stuff->shape != Complex) && (stuff->shape != Nonconvex) &&  
	(stuff->shape != Convex))
    {
	client->errorValue = stuff->shape;
d1805 3
a1807 4
    if ((stuff->coordMode != CoordModeOrigin) && 
	(stuff->coordMode != CoordModePrevious))
    {
	client->errorValue = stuff->coordMode;
d1815 2
a1816 2
			 stuff->coordMode, things,
			 (DDXPointPtr) &stuff[1]);
d1823 1
a1823 1
    int             things;
d1826 1
d1833 1
a1833 1
	return BadLength;
d1838 1
a1838 1
		      (xRectangle *) &stuff[1]);
d1845 1
a1845 1
    int		narcs;
d1848 1
d1855 1
a1855 1
	return BadLength;
d1865 1
a1865 1
ServerOrder (void)
d1867 1
a1867 1
    int	    whichbyte = 1;
d1870 1
a1870 1
	return LSBFirst;
d1877 1
a1877 1
ReformatImage (char *base, int nbytes, int bpp, int order)
d1880 3
a1882 3
    case 1:	/* yuck */
	if (BITMAP_BIT_ORDER != order)
	    BitOrderInvert ((unsigned char *) base, nbytes);
d1884 1
a1884 1
	ReformatImage (base, nbytes, BITMAP_SCANLINE_UNIT, order);
d1886 1
a1886 1
	break;
d1888 1
a1888 1
	break;  /* yuck */
d1890 1
a1890 1
	break;
d1892 3
a1894 3
	if (IMAGE_BYTE_ORDER != order)
	    TwoByteSwap ((unsigned char *) base, nbytes);
	break;
d1896 3
a1898 3
	if (IMAGE_BYTE_ORDER != order)
	    FourByteSwap ((unsigned char *) base, nbytes);
	break;
d1921 4
a1924 3
    long	length; 	/* length of scanline server padded */
    long 	lengthProto; 	/* length of scanline protocol padded */
    char	*tmpImage;
d1929 1
a1929 2
    if (stuff->format == XYBitmap)
    {
d1931 1
a1931 1
	    (stuff->leftPad >= (unsigned int)screenInfo.bitmapScanlinePad))
d1933 1
a1933 1
        length 	    = BitmapBytePad(stuff->width + stuff->leftPad);
d1935 3
a1937 4
    else if (stuff->format == XYPixmap)
    {
        if ((pDraw->depth != stuff->depth) || 
	    (stuff->leftPad >= (unsigned int)screenInfo.bitmapScanlinePad))
d1939 2
a1940 2
        length      = BitmapBytePad(stuff->width + stuff->leftPad);
	length      *= stuff->depth;
d1942 1
a1942 2
    else if (stuff->format == ZPixmap)
    {
d1945 1
a1945 1
        length      = PixmapBytePad(stuff->width, stuff->depth);
d1947 2
a1948 3
    else
    {
	client->errorValue = stuff->format;
d1952 1
a1952 1
    tmpImage = (char *)&stuff[1];
d1954 1
a1954 1
	
d1956 6
a1961 2
	bytes_to_int32(sizeof(xPutImageReq))) != client->req_len)
	return BadLength;
a1962 4
    ReformatImage (tmpImage, lengthProto * stuff->height, 
		   stuff->format == ZPixmap ? BitsPerPixel (stuff->depth) : 1,
		   ClientOrder(client));
    
d1964 2
a1965 2
		  stuff->width, stuff->height, 
		  stuff->leftPad, stuff->format, tmpImage);
d1967 1
a1967 1
     return Success;
d1971 8
a1978 7
DoGetImage(ClientPtr client, int format, Drawable drawable, 
           int x, int y, int width, int height, 
           Mask planemask, xGetImageReply **im_return)
{
    DrawablePtr		pDraw, pBoundingDraw;
    int			nlines, linesPerBuf, rc;
    int			linesDone;
d1980 5
a1984 5
    int			relx, rely;
    long		widthBytesLine, length;
    Mask		plane = 0;
    char		*pBuf;
    xGetImageReply	xgi;
d1987 2
a1988 3
    if ((format != XYPixmap) && (format != ZPixmap))
    {
	client->errorValue = format;
d1993 1
a1993 1
	return rc;
d2000 7
a2006 3
    if(pDraw->type == DRAWABLE_WINDOW)
    {
	WindowPtr pWin = (WindowPtr)pDraw;
d2008 7
a2014 4
	/* "If the drawable is a window, the window must be viewable ... or a
	 * BadMatch error results" */
	if (!pWin->viewable)
	    return BadMatch;
d2016 2
a2017 2
	relx += pDraw->x;
	rely += pDraw->y;
d2019 2
a2020 2
	if (pDraw->pScreen->GetWindowPixmap) {
	    PixmapPtr pPix = (*pDraw->pScreen->GetWindowPixmap) (pWin);
d2022 1
a2022 1
	    pBoundingDraw = &pPix->drawable;
d2024 2
a2025 2
	    relx -= pPix->screen_x;
	    rely -= pPix->screen_y;
d2027 4
a2030 5
	}
	else
	{
	    pBoundingDraw = (DrawablePtr)pDraw->pScreen->root;
	}
d2032 1
a2032 1
	xgi.visual = wVisual (pWin);
d2034 3
a2036 4
    else
    {
	pBoundingDraw = pDraw;
	xgi.visual = None;
d2050 3
a2052 3
    if(relx < 0 || relx + width > (int)pBoundingDraw->width ||
       rely < 0 || rely + height > (int)pBoundingDraw->height)
	return BadMatch;
d2057 3
a2059 4
    if(format == ZPixmap)
    {
	widthBytesLine = PixmapBytePad(width, pDraw->depth);
	length = widthBytesLine * height;
d2062 6
a2067 7
    else 
    {
	widthBytesLine = BitmapBytePad(width);
	plane = ((Mask)1) << (pDraw->depth - 1);
	/* only planes asked for */
	length = widthBytesLine * height *
		 Ones(planemask & (plane | (plane - 1)));
d2074 38
a2111 41
	pBuf = calloc(1, sz_xGetImageReply + length);
	if (!pBuf)
	    return BadAlloc;
	if (widthBytesLine == 0)
	    linesPerBuf = 0;
	else
	    linesPerBuf = height;
	*im_return = (xGetImageReply *)pBuf;
	*(xGetImageReply *)pBuf = xgi;
	pBuf += sz_xGetImageReply;
    } else {
	xgi.length = bytes_to_int32(xgi.length);
	if (widthBytesLine == 0 || height == 0)
	    linesPerBuf = 0;
	else if (widthBytesLine >= IMAGE_BUFSIZE)
	    linesPerBuf = 1;
	else
	{
	    linesPerBuf = IMAGE_BUFSIZE / widthBytesLine;
	    if (linesPerBuf > height)
		linesPerBuf = height;
	}
	length = linesPerBuf * widthBytesLine;
	if (linesPerBuf < height)
	{
	    /* we have to make sure intermediate buffers don't need padding */
	    while ((linesPerBuf > 1) &&
		   (length & ((1L << LOG2_BYTES_PER_SCANLINE_PAD)-1)))
	    {
		linesPerBuf--;
		length -= widthBytesLine;
	    }
	    while (length & ((1L << LOG2_BYTES_PER_SCANLINE_PAD)-1))
	    {
		linesPerBuf++;
		length += widthBytesLine;
	    }
	}
	if(!(pBuf = calloc(1, length)))
	    return BadAlloc;
	WriteReplyToClient(client, sizeof (xGetImageReply), &xgi);
d2114 5
a2118 7
    if (pDraw->type == DRAWABLE_WINDOW)
    {
	pVisibleRegion = NotClippedByChildren((WindowPtr)pDraw);
	if (pVisibleRegion)
	{
	    RegionTranslate(pVisibleRegion, -pDraw->x, -pDraw->y);
	}
d2121 2
a2122 3
    if (linesPerBuf == 0)
    {
	/* nothing to do */
d2124 1
a2124 2
    else if (format == ZPixmap)
    {
d2126 12
a2137 15
        while (height - linesDone > 0)
        {
	    nlines = min(linesPerBuf, height - linesDone);
	    (*pDraw->pScreen->GetImage) (pDraw,
	                                 x,
				         y + linesDone,
				         width, 
				         nlines,
				         format,
				         planemask,
				         (pointer) pBuf);
	    if (pVisibleRegion)
		XaceCensorImage(client, pVisibleRegion, widthBytesLine,
			pDraw, x, y + linesDone, width, 
			nlines, format, pBuf);
d2139 1
a2139 1
	    /* Note that this is NOT a call to WriteSwappedDataToClient,
d2141 3
a2143 5
	    if (!im_return)
	    {
		ReformatImage (pBuf, (int)(nlines * widthBytesLine),
			       BitsPerPixel (pDraw->depth),
			       ClientOrder(client));
d2146 4
a2149 5
		(void)WriteToClient(client,
				    (int)(nlines * widthBytesLine),
				    pBuf);
	    }
	    linesDone += nlines;
d2152 28
a2179 33
    else /* XYPixmap */
    {
        for (; plane; plane >>= 1)
	{
	    if (planemask & plane)
	    {
	        linesDone = 0;
	        while (height - linesDone > 0)
	        {
		    nlines = min(linesPerBuf, height - linesDone);
	            (*pDraw->pScreen->GetImage) (pDraw,
	                                         x,
				                 y + linesDone,
				                 width, 
				                 nlines,
				                 format,
				                 plane,
				                 (pointer)pBuf);
		    if (pVisibleRegion)
			XaceCensorImage(client, pVisibleRegion,
				widthBytesLine,
				pDraw, x, y + linesDone, width, 
				nlines, format, pBuf);

		    /* Note: NOT a call to WriteSwappedDataToClient,
		       as we do NOT byte swap */
		    if (im_return) {
			pBuf += nlines * widthBytesLine;
		    } else {
			ReformatImage (pBuf, 
				       (int)(nlines * widthBytesLine), 
				       1,
				       ClientOrder (client));
d2182 6
a2187 6
			(void)WriteToClient(client,
					(int)(nlines * widthBytesLine),
					pBuf);
		    }
		    linesDone += nlines;
		}
d2189 1
a2189 1
	}
d2192 1
a2192 1
	RegionDestroy(pVisibleRegion);
d2194 1
a2194 1
	free(pBuf);
d2206 3
a2208 3
		      stuff->x, stuff->y,
		      (int)stuff->width, (int)stuff->height,
		      stuff->planeMask, (xGetImageReply **)NULL);
d2214 2
a2215 1
    int	err;
d2224 5
a2228 8
		   pDraw,
		   pGC,
		   (unsigned char *)&stuff[1],
		   ((unsigned char *) stuff) + (client->req_len << 2),
		   stuff->x,
		   stuff->y,
		   stuff->reqType,
		   stuff->drawable);
d2230 2
a2231 3
    if (err == Success)
    {
	return Success;
d2234 1
a2234 1
	return err;
d2240 1
a2240 1
    int	err;
d2250 5
a2254 8
		    pDraw,
		    pGC,
		    stuff->nChars,
		    (unsigned char *)&stuff[1],
		    stuff->x,
		    stuff->y,
		    stuff->reqType,
		    stuff->drawable);
d2256 2
a2257 3
    if (err == Success)
    {
	return Success;
d2260 1
a2260 1
	return err;
d2266 1
a2266 1
    int	err;
d2276 5
a2280 8
		    pDraw,
		    pGC,
		    stuff->nChars,
		    (unsigned char *)&stuff[1],
		    stuff->x,
		    stuff->y,
		    stuff->reqType,
		    stuff->drawable);
d2282 2
a2283 3
    if (err == Success)
    {
	return Success;
d2286 1
a2286 1
	return err;
a2288 1

d2292 4
a2295 4
    VisualPtr	pVisual;
    ColormapPtr	pmap;
    Colormap	mid;
    WindowPtr   pWin;
d2297 1
d2303 2
a2304 3
    if ((stuff->alloc != AllocNone) && (stuff->alloc != AllocAll))
    {
	client->errorValue = stuff->alloc;
d2315 5
a2319 7
	 i < pScreen->numVisuals;
	 i++, pVisual++)
    {
	if (pVisual->vid != stuff->visual)
	    continue;
	return CreateColormap(mid, pScreen, pVisual, &pmap,
				 (int)stuff->alloc, client->index);
d2330 1
d2334 7
a2340 8
    rc = dixLookupResourceByType((pointer *)&pmap, stuff->id, RT_COLORMAP, client,
			   DixDestroyAccess);
    if (rc == Success)
    {
	/* Freeing a default colormap is a no-op */
	if (!(pmap->flags & IsDefault))
	    FreeResource(stuff->id, RT_NONE);
	return Success;
d2342 3
a2344 4
    else 
    {
	client->errorValue = stuff->id;
	return rc;
a2347 1

d2351 3
a2353 2
    Colormap	mid;
    ColormapPtr	pSrcMap;
d2360 3
a2362 2
    rc = dixLookupResourceByType((pointer *)&pSrcMap, stuff->srcCmap, RT_COLORMAP,
			   client, DixReadAccess|DixRemoveAccess);
d2364 1
a2364 1
	return CopyColormapAndFree(mid, pSrcMap, client->index);
d2374 1
d2378 2
a2379 2
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->id, RT_COLORMAP, client,
			   DixInstallAccess);
d2381 1
a2381 1
	goto out;
d2385 3
a2387 3
	if (rc == BadValue)
	    rc = BadColor;
	goto out;
d2393 1
a2393 1
out:
d2403 1
d2407 2
a2408 2
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->id, RT_COLORMAP, client,
			   DixUninstallAccess);
d2410 1
a2410 1
	goto out;
d2414 3
a2416 3
	if (rc == BadValue)
	    rc = BadColor;
	goto out;
d2419 2
a2420 2
    if(pcmp->mid != pcmp->pScreen->defColormap)
	(*(pcmp->pScreen->UninstallColormap)) (pcmp);
d2423 1
a2423 1
out:
d2431 1
a2431 1
    xListInstalledColormapsReply *preply; 
d2434 1
d2440 1
a2440 1
	return rc;
d2443 1
a2443 1
		  DixGetAttrAccess);
d2445 1
a2445 1
	return rc;
d2448 3
a2450 3
		     pWin->drawable.pScreen->maxInstalledCmaps *
		     sizeof(Colormap));
    if(!preply)
d2456 1
a2456 1
        (pWin->drawable.pScreen, (Colormap *)&preply[1]);
d2459 1
a2459 1
    WriteReplyToClient(client, sizeof (xListInstalledColormapsReply), preply);
d2467 1
a2467 1
ProcAllocColor (ClientPtr client)
d2472 1
d2476 13
a2488 14
    rc = dixLookupResourceByType((pointer *)&pmap, stuff->cmap, RT_COLORMAP, client,
			   DixAddAccess);
    if (rc == Success)
    {
	acr.type = X_Reply;
	acr.length = 0;
	acr.sequenceNumber = client->sequence;
	acr.red = stuff->red;
	acr.green = stuff->green;
	acr.blue = stuff->blue;
	acr.pixel = 0;
	if( (rc = AllocColor(pmap, &acr.red, &acr.green, &acr.blue,
	                       &acr.pixel, client->index)) )
	    return rc;
d2490 1
a2490 1
	if (noPanoramiXExtension || !pmap->pScreen->myNum)
d2492 2
a2493 2
        WriteReplyToClient(client, sizeof(xAllocColorReply), &acr);
	return Success;
d2496 1
a2496 2
    else
    {
d2503 1
a2503 1
ProcAllocNamedColor (ClientPtr client)
d2507 1
d2511 4
a2514 5
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
			   DixAddAccess);
    if (rc == Success)
    {
	xAllocNamedColorReply ancr;
d2516 15
a2530 15
	ancr.type = X_Reply;
	ancr.length = 0;
	ancr.sequenceNumber = client->sequence;

	if(OsLookupColor(pcmp->pScreen->myNum, (char *)&stuff[1], stuff->nbytes,
	                 &ancr.exactRed, &ancr.exactGreen, &ancr.exactBlue))
	{
	    ancr.screenRed = ancr.exactRed;
	    ancr.screenGreen = ancr.exactGreen;
	    ancr.screenBlue = ancr.exactBlue;
	    ancr.pixel = 0;
	    if( (rc = AllocColor(pcmp,
	                 &ancr.screenRed, &ancr.screenGreen, &ancr.screenBlue,
			 &ancr.pixel, client->index)) )
		return rc;
d2532 1
a2532 1
	    if (noPanoramiXExtension || !pcmp->pScreen->myNum)
d2534 7
a2540 6
            WriteReplyToClient(client, sizeof (xAllocNamedColorReply), &ancr);
	    return Success;
	}
	else
	    return BadName;
	
d2542 1
a2542 2
    else
    {
d2549 1
a2549 1
ProcAllocColorCells (ClientPtr client)
d2553 1
d2557 21
a2577 24
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
			   DixAddAccess);
    if (rc == Success)
    {
	xAllocColorCellsReply	accr;
	int			npixels, nmasks;
	long			length;
	Pixel			*ppixels, *pmasks;

	npixels = stuff->colors;
	if (!npixels)
	{
	    client->errorValue = npixels;
	    return BadValue;
	}
	if (stuff->contiguous != xTrue && stuff->contiguous != xFalse)
	{
	    client->errorValue = stuff->contiguous;
	    return BadValue;
	}
	nmasks = stuff->planes;
	length = ((long)npixels + (long)nmasks) * sizeof(Pixel);
	ppixels = malloc(length);
	if(!ppixels)
d2579 1
a2579 1
	pmasks = ppixels + npixels;
d2581 5
a2585 6
	if( (rc = AllocColorCells(client->index, pcmp, npixels, nmasks, 
				    (Bool)stuff->contiguous, ppixels, pmasks)) )
	{
	    free(ppixels);
	    return rc;
	}
d2587 1
a2587 1
	if (noPanoramiXExtension || !pcmp->pScreen->myNum)
d2589 11
a2599 11
	{
	    accr.type = X_Reply;
	    accr.length = bytes_to_int32(length);
	    accr.sequenceNumber = client->sequence;
	    accr.nPixels = npixels;
	    accr.nMasks = nmasks;
	    WriteReplyToClient(client, sizeof (xAllocColorCellsReply), &accr);
	    client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
	    WriteSwappedDataToClient(client, length, ppixels);
	}
	free(ppixels);
d2602 1
a2602 2
    else
    {
d2613 1
d2617 24
a2640 26
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
			   DixAddAccess);
    if (rc == Success)
    {
	xAllocColorPlanesReply	acpr;
	int			npixels;
	long			length;
	Pixel			*ppixels;

	npixels = stuff->colors;
	if (!npixels)
	{
	    client->errorValue = npixels;
	    return BadValue;
	}
	if (stuff->contiguous != xTrue && stuff->contiguous != xFalse)
	{
	    client->errorValue = stuff->contiguous;
	    return BadValue;
	}
	acpr.type = X_Reply;
	acpr.sequenceNumber = client->sequence;
	acpr.nPixels = npixels;
	length = (long)npixels * sizeof(Pixel);
	ppixels = malloc(length);
	if(!ppixels)
d2642 5
a2646 5
	if( (rc = AllocColorPlanes(client->index, pcmp, npixels,
	    (int)stuff->red, (int)stuff->green, (int)stuff->blue,
	    (Bool)stuff->contiguous, ppixels,
	    &acpr.redMask, &acpr.greenMask, &acpr.blueMask)) )
	{
d2648 3
a2650 3
	    return rc;
	}
	acpr.length = bytes_to_int32(length);
d2652 1
a2652 1
	if (noPanoramiXExtension || !pcmp->pScreen->myNum)
d2654 6
a2659 6
	{
	    WriteReplyToClient(client, sizeof(xAllocColorPlanesReply), &acpr);
	    client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;
	    WriteSwappedDataToClient(client, length, ppixels);
	}
	free(ppixels);
d2662 1
a2662 2
    else
    {
d2673 1
d2677 4
a2680 5
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
			   DixRemoveAccess);
    if (rc == Success)
    {
	int	count;
d2682 5
a2686 5
	if(pcmp->flags & AllAllocated)
	    return BadAccess;
	count = bytes_to_int32((client->req_len << 2) - sizeof(xFreeColorsReq));
	return FreeColors(pcmp, client->index, count,
	    (Pixel *)&stuff[1], (Pixel)stuff->planeMask);
d2688 1
a2688 2
    else
    {
d2695 1
a2695 1
ProcStoreColors (ClientPtr client)
d2699 1
d2703 4
a2706 5
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
			   DixWriteAccess);
    if (rc == Success)
    {
	int	count;
d2709 4
a2712 4
	if (count % sizeof(xColorItem))
	    return BadLength;
	count /= sizeof(xColorItem);
	return StoreColors(pcmp, count, (xColorItem *)&stuff[1], client);
d2714 1
a2714 2
    else
    {
d2721 1
a2721 1
ProcStoreNamedColor (ClientPtr client)
d2725 1
d2729 4
a2732 5
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
			   DixWriteAccess);
    if (rc == Success)
    {
	xColorItem	def;
d2734 6
a2739 7
	if(OsLookupColor(pcmp->pScreen->myNum, (char *)&stuff[1],
	                 stuff->nbytes, &def.red, &def.green, &def.blue))
	{
	    def.flags = stuff->flags;
	    def.pixel = stuff->pixel;
	    return StoreColors(pcmp, 1, &def, client);
	}
d2742 1
a2742 2
    else
    {
d2753 1
d2757 11
a2767 11
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
			   DixReadAccess);
    if (rc == Success)
    {
	int			count;
	xrgb 			*prgbs;
	xQueryColorsReply	qcr;

	count = bytes_to_int32((client->req_len << 2) - sizeof(xQueryColorsReq));
	prgbs = calloc(1, count * sizeof(xrgb));
	if(!prgbs && count)
d2769 18
a2786 19
	if( (rc = QueryColors(pcmp, count, (Pixel *)&stuff[1], prgbs, client)) )
	{
	    free(prgbs);
	    return rc;
	}
	memset(&qcr, 0, sizeof(xQueryColorsReply));
	qcr.type = X_Reply;
	qcr.length = bytes_to_int32(count * sizeof(xrgb));
	qcr.sequenceNumber = client->sequence;
	qcr.nColors = count;
	WriteReplyToClient(client, sizeof(xQueryColorsReply), &qcr);
	if (count)
	{
	    client->pSwapReplyFunc = (ReplySwapPtr) SQColorsExtend;
	    WriteSwappedDataToClient(client, count * sizeof(xrgb), prgbs);
	}
	free(prgbs);
	return Success;
	
d2788 1
a2788 2
    else
    {
d2792 1
a2792 1
} 
d2799 1
d2803 4
a2806 5
    rc = dixLookupResourceByType((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
			   DixReadAccess);
    if (rc == Success)
    {
	xLookupColorReply lcr;
d2808 15
a2822 16
	if(OsLookupColor(pcmp->pScreen->myNum, (char *)&stuff[1], stuff->nbytes,
	                 &lcr.exactRed, &lcr.exactGreen, &lcr.exactBlue))
	{
	    lcr.type = X_Reply;
	    lcr.length = 0;
	    lcr.sequenceNumber = client->sequence;
	    lcr.screenRed = lcr.exactRed;
	    lcr.screenGreen = lcr.exactGreen;
	    lcr.screenBlue = lcr.exactBlue;
	    (*pcmp->pScreen->ResolveColor)(&lcr.screenRed,
	                                   &lcr.screenGreen,
					   &lcr.screenBlue,
					   pcmp->pVisual);
	    WriteReplyToClient(client, sizeof(xLookupColorReply), &lcr);
	    return Success;
	}
d2825 1
a2825 2
    else
    {
d2832 1
a2832 1
ProcCreateCursor (ClientPtr client)
d2834 8
a2841 8
    CursorPtr		pCursor;
    PixmapPtr 		src;
    PixmapPtr 		msk;
    unsigned char *	srcbits;
    unsigned char *	mskbits;
    unsigned short	width, height;
    long		n;
    CursorMetricRec 	cm;
d2849 2
a2850 2
    rc = dixLookupResourceByType((pointer *)&src, stuff->source, RT_PIXMAP, client,
			   DixReadAccess);
d2852 2
a2853 2
	client->errorValue = stuff->source;
	return rc;
d2856 12
a2867 15
    rc = dixLookupResourceByType((pointer *)&msk, stuff->mask, RT_PIXMAP, client,
			   DixReadAccess);
    if (rc != Success)
    {
	if (stuff->mask != None)
	{
	    client->errorValue = stuff->mask;
	    return rc;
	}
    }
    else if (  src->drawable.width != msk->drawable.width
	    || src->drawable.height != msk->drawable.height
	    || src->drawable.depth != 1
	    || msk->drawable.depth != 1)
	return BadMatch;
d2872 2
a2873 3
    if ( stuff->x > width 
      || stuff->y > height )
	return BadMatch;
d2875 1
a2875 1
    n = BitmapBytePad(width)*height;
d2878 1
a2878 1
	return BadAlloc;
d2880 3
a2882 4
    if (!mskbits)
    {
	free(srcbits);
	return BadAlloc;
d2885 14
a2898 14
    (* src->drawable.pScreen->GetImage)( (DrawablePtr)src, 0, 0, width, height,
					 XYPixmap, 1, (pointer)srcbits);
    if ( msk == (PixmapPtr)NULL)
    {
	unsigned char *bits = mskbits;
	while (--n >= 0)
	    *bits++ = ~0;
    }
    else
    {
	/* zeroing the (pad) bits helps some ddx cursor handling */
	memset((char *)mskbits, 0, n);
	(* msk->drawable.pScreen->GetImage)( (DrawablePtr)msk, 0, 0, width,
					height, XYPixmap, 1, (pointer)mskbits);
d2905 3
a2907 3
			 stuff->foreRed, stuff->foreGreen, stuff->foreBlue,
			 stuff->backRed, stuff->backGreen, stuff->backBlue,
			 &pCursor, client, stuff->cid);
d2910 4
a2913 4
	goto bail;
    if (!AddResource(stuff->cid, RT_CURSOR, (pointer)pCursor)) {
	rc = BadAlloc;
	goto bail;
d2917 1
a2917 1
bail:
d2924 1
a2924 1
ProcCreateGlyphCursor (ClientPtr client)
d2935 4
a2938 4
			   stuff->mask, stuff->maskChar,
			   stuff->foreRed, stuff->foreGreen, stuff->foreBlue,
			   stuff->backRed, stuff->backGreen, stuff->backBlue,
			   &pCursor, client, stuff->cid);
d2940 3
a2942 3
	return res;
    if (AddResource(stuff->cid, RT_CURSOR, (pointer)pCursor))
	return Success;
a2945 1

d2947 1
a2947 1
ProcFreeCursor (ClientPtr client)
d2951 1
d2955 5
a2959 6
    rc = dixLookupResourceByType((pointer *)&pCursor, stuff->id, RT_CURSOR, client,
			   DixDestroyAccess);
    if (rc == Success) 
    {
	FreeResource(stuff->id, RT_NONE);
	return Success;
d2961 3
a2963 4
    else 
    {
	client->errorValue = stuff->id;
	return rc;
d2968 1
a2968 1
ProcQueryBestSize (ClientPtr client)
d2970 1
a2970 1
    xQueryBestSizeReply	reply;
d2974 1
d2978 3
a2980 5
    if ((stuff->class != CursorShape) && 
	(stuff->class != TileShape) && 
	(stuff->class != StippleShape))
    {
	client->errorValue = stuff->class;
d2985 1
a2985 1
			   DixGetAttrAccess);
d2987 1
a2987 1
	return rc;
d2989 1
a2989 1
	return BadMatch;
d2993 3
a2995 3
	return rc;
    (* pScreen->QueryBestSize)(stuff->class, &stuff->width,
			       &stuff->height, pScreen);
a3005 1

d3007 1
a3007 1
ProcSetScreenSaver (ClientPtr client)
d3010 1
d3015 4
a3018 4
	rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, screenInfo.screens[i],
		      DixSetAttrAccess);
	if (rc != Success)
	    return rc;
d3024 2
a3025 3
        (blankingOption != DefaultBlanking))
    {
	client->errorValue = blankingOption;
d3031 2
a3032 3
        (exposureOption != DefaultExposures))
    {
	client->errorValue = exposureOption;
d3035 2
a3036 3
    if (stuff->timeout < -1)
    {
	client->errorValue = stuff->timeout;
d3039 2
a3040 3
    if (stuff->interval < -1)
    {
	client->errorValue = stuff->interval;
d3045 1
a3045 1
	ScreenSaverBlanking = defaultScreenSaverBlanking;
d3047 1
a3047 1
	ScreenSaverBlanking = blankingOption; 
d3049 1
a3049 1
	ScreenSaverAllowExposures = defaultScreenSaverAllowExposures;
d3051 1
a3051 1
	ScreenSaverAllowExposures = exposureOption;
d3054 3
a3056 3
	ScreenSaverTime = stuff->timeout * MILLI_PER_SECOND;
    else 
	ScreenSaverTime = defaultScreenSaverTime;
d3058 1
a3058 1
	ScreenSaverInterval = stuff->interval * MILLI_PER_SECOND;
d3060 1
a3060 1
	ScreenSaverInterval = defaultScreenSaverInterval;
d3071 1
d3075 4
a3078 4
	rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, screenInfo.screens[i],
		      DixGetAttrAccess);
	if (rc != Success)
	    return rc;
d3099 3
a3101 3
    if(stuff->mode == HostInsert)
	return AddHost(client, (int)stuff->hostFamily,
			 stuff->hostLength, (pointer)&stuff[1]);
d3103 2
a3104 2
	return RemoveHost(client, (int)stuff->hostFamily,
			    stuff->hostLength, (pointer)&stuff[1]);  
d3113 3
a3115 2
    int	len, nHosts, result;
    pointer	pdata;
d3123 1
a3123 1
	return result;
d3127 1
a3127 1
	return result;
d3133 3
a3135 4
    if (nHosts)
    {
	client->pSwapReplyFunc = (ReplySwapPtr) SLHostsExtend;
	WriteSwappedDataToClient(client, len, pdata);
d3147 2
a3148 3
    if ((stuff->mode != EnableAccess) && (stuff->mode != DisableAccess))
    {
	client->errorValue = stuff->mode;
d3167 1
a3167 2
    for (i=1; i<currentMaxClients; i++)
    {
d3170 2
a3171 2
	    && (client->clientGone))
	    CloseDownClient(client);
d3183 2
a3184 3
    if (stuff->id == AllTemporary)
    {
	CloseDownRetainedResources();
d3190 10
a3199 11
	CloseDownClient(killclient);
	/* if an LBX proxy gets killed, isItTimeToYield will be set */
	if (isItTimeToYield || (client == killclient))
	{
	    /* force yield and return Success, so that Dispatch()
	     * doesn't try to touch client
	     */
	    isItTimeToYield = TRUE;
	    return Success;
	}
	return Success;
d3202 1
a3202 1
	return rc;
d3212 1
d3214 1
a3214 1
    
d3216 1
a3216 1
    
d3219 1
a3219 1
    ptr = (unsigned char *)&stuff[1];
d3221 5
a3225 6
    while (--nfonts >= 0)
    {
	if ((total == 0) || (total < (n = (*ptr + 1))))
	    return BadLength;
	total -= n;
	ptr += n;
d3228 2
a3229 2
	return BadLength;
    return SetFontPath(client, stuff->nFonts, (unsigned char *)&stuff[1]);
d3238 1
d3244 1
a3244 1
	return rc;
d3253 2
a3254 1
	(void)WriteToClient(client, stringLens + numpaths, (char *)bufferStart);
d3262 1
d3268 1
a3268 1
	return rc;
d3271 3
a3273 5
	(stuff->mode == RetainPermanent) ||
	(stuff->mode == RetainTemporary))
    {
	client->closeDownMode = stuff->mode;
	return Success;
d3275 3
a3277 4
    else   
    {
	client->errorValue = stuff->mode;
	return BadValue;
d3281 3
a3283 2
int ProcForceScreenSaver(ClientPtr client)
{    
d3285 1
d3289 3
a3291 5
    
    if ((stuff->mode != ScreenSaverReset) && 
	(stuff->mode != ScreenSaverActive))
    {
	client->errorValue = stuff->mode;
d3294 1
a3294 1
    rc = dixSaveScreens(client, SCREEN_SAVER_FORCER, (int)stuff->mode);
d3296 1
a3296 1
	return rc;
d3300 2
a3301 1
int ProcNoOperation(ClientPtr client)
d3304 1
a3304 1
    
d3322 1
a3322 1
			     client->closeDownMode == DestroyAll;
d3324 43
a3366 49
    if (!client->clientGone)
    {
	/* ungrab server if grabbing client dies */
	if (grabState != GrabNone && grabClient == client)
	{
	    UngrabServer(client);
	}
	BITCLEAR(grabWaiters, client->index);
	DeleteClientFromAnySelections(client);
	ReleaseActiveGrabs(client);
	DeleteClientFontStuff(client);
	if (!really_close_down)
	{
	    /*  This frees resources that should never be retained
	     *  no matter what the close down mode is.  Actually we
	     *  could do this unconditionally, but it's probably
	     *  better not to traverse all the client's resources
	     *  twice (once here, once a few lines down in
	     *  FreeClientResources) in the common case of
	     *  really_close_down == TRUE.
	     */
	    FreeClientNeverRetainResources(client);
	    client->clientState = ClientStateRetained;
  	    if (ClientStateCallback)
            {
		NewClientInfoRec clientinfo;

		clientinfo.client = client; 
		clientinfo.prefix = (xConnSetupPrefix *)NULL;  
		clientinfo.setup = (xConnSetup *) NULL;
		CallCallbacks((&ClientStateCallback), (pointer)&clientinfo);
            } 
	}
	client->clientGone = TRUE;  /* so events aren't sent to client */
	if (ClientIsAsleep(client))
	    ClientSignal (client);
	ProcessWorkQueueZombies();
	CloseDownConnection(client);

	/* If the client made it to the Running stage, nClients has
	 * been incremented on its behalf, so we need to decrement it
	 * now.  If it hasn't gotten to Running, nClients has *not*
	 * been incremented, so *don't* decrement it.
	 */
	if (client->clientState != ClientStateInitial &&
	    client->clientState != ClientStateAuthenticating )
	{
	    --nClients;
	}
d3369 17
a3385 19
    if (really_close_down)
    {
	if (client->clientState == ClientStateRunning && nClients == 0)
	    dispatchException |= dispatchExceptionAtReset;

	client->clientState = ClientStateGone;
	if (ClientStateCallback)
	{
	    NewClientInfoRec clientinfo;

	    clientinfo.client = client; 
	    clientinfo.prefix = (xConnSetupPrefix *)NULL;  
	    clientinfo.setup = (xConnSetup *) NULL;
	    CallCallbacks((&ClientStateCallback), (pointer)&clientinfo);
	} 	    
	FreeClientResources(client);
	/* Disable client ID tracking. This must be done after
	 * ClientStateCallback. */
	ReleaseClientIds(client);
d3387 7
a3393 7
	XSERVER_CLIENT_DISCONNECT(client->index);
#endif	
	if (client->index < nextFreeClientID)
	    nextFreeClientID = client->index;
	clients[client->index] = NullClient;
	SmartLastClient = NullClient;
	dixFreeObjectWithPrivates(client, PRIVATE_CLIENT);
d3395 2
a3396 2
	while (!clients[currentMaxClients-1])
	    currentMaxClients--;
d3404 2
a3405 1
    for (i=1; i<currentMaxClients; i++)
d3409 1
a3409 1
            CloseDownClient(clients[i]);     
d3413 2
a3414 1
void InitClient(ClientPtr client, int i, pointer ospriv)
d3417 1
a3417 1
    client->clientAsMask = ((Mask)i) << CLIENTOFFSET;
d3421 1
a3421 1
    QueryMinMaxKeyCodes(&client->minKC,&client->maxKC);
d3435 2
a3436 1
ClientPtr NextAvailableClient(pointer ospriv)
d3444 3
a3446 2
	return (ClientPtr)NULL;
    clients[i] = client = dixAllocateObjectWithPrivates(ClientRec, PRIVATE_CLIENT);
d3448 1
a3448 1
	return (ClientPtr)NULL;
d3450 3
a3452 4
    if (!InitClientResources(client))
    {
	dixFreeObjectWithPrivates(client, PRIVATE_CLIENT);
	return (ClientPtr)NULL;
d3456 4
a3459 5
    if (!InsertFakeRequest(client, (char *)&data, sz_xReq))
    {
	FreeClientResources(client);
	dixFreeObjectWithPrivates(client, PRIVATE_CLIENT);
	return (ClientPtr)NULL;
d3462 1
a3462 1
	currentMaxClients++;
d3464 1
a3464 1
	nextFreeClientID++;
d3470 2
a3471 3
    if (ClientStateCallback)
    {
	NewClientInfoRec clientinfo;
d3473 2
a3474 2
        clientinfo.client = client; 
        clientinfo.prefix = (xConnSetupPrefix *)NULL;  
d3476 2
a3477 2
	CallCallbacks((&ClientStateCallback), (pointer)&clientinfo);
    } 	
d3488 1
a3488 1
    prefix = (xConnClientPrefix *)((char *)stuff + sz_xReq);
d3490 1
a3490 1
	return client->noClientException = -1;
d3492 3
a3494 4
	(!(*(char *) &whichbyte) && (prefix->byteOrder == 'l')))
    {
	client->swapped = TRUE;
	SwapConnClientPrefix(prefix);
d3498 3
a3500 4
		     bytes_to_int32(prefix->nbytesAuthString);
    if (client->swapped)
    {
	swaps(&stuff->length, whichbyte);
d3507 1
a3507 1
SendConnSetup(ClientPtr client, char *reason)
d3512 2
a3513 2
    char* lConnectionInfo;
    xConnSetupPrefix* lconnSetupPrefix;
d3515 2
a3516 3
    if (reason)
    {
	xConnSetupPrefix csp;
d3518 11
a3528 11
	csp.success = xFalse;
	csp.lengthReason = strlen(reason);
	csp.length = bytes_to_int32(csp.lengthReason);
	csp.majorVersion = X_PROTOCOL;
	csp.minorVersion = X_PROTOCOL_REVISION;
	if (client->swapped)
	    WriteSConnSetupPrefix(client, &csp);
	else
	    (void)WriteToClient(client, sz_xConnSetupPrefix, (char *) &csp);
        (void)WriteToClient(client, (int)csp.lengthReason, reason);
	return client->noClientException = -1;
d3544 2
a3545 2
    ((xConnSetup *)lConnectionInfo)->ridBase = client->clientAsMask;
    ((xConnSetup *)lConnectionInfo)->ridMask = RESOURCE_ID_MASK;
d3547 2
a3548 2
    ((xConnSetup *)lConnectionInfo)->imageByteOrder = ClientOrder (client);
    ((xConnSetup *)lConnectionInfo)->bitmapBitOrder = ClientOrder (client);
d3551 1
a3551 1
    root = (xWindowRoot *)(lConnectionInfo + connBlockScreenStart);
d3554 3
a3556 3
	numScreens = screenInfo.numScreens;
    else 
        numScreens = ((xConnSetup *)ConnectionInfo)->numRoots;
d3559 4
a3562 5
    for (i=0; i<numScreens; i++) 
    {
	unsigned int j;
	xDepth *pDepth;
	WindowPtr pRoot = screenInfo.screens[i]->root;
d3565 6
a3570 7
	pDepth = (xDepth *)(root + 1);
	for (j = 0; j < root->nDepths; j++)
	{
	    pDepth = (xDepth *)(((char *)(pDepth + 1)) +
				pDepth->nVisuals * sizeof(xVisualType));
	}
	root = (xWindowRoot *)pDepth;
d3573 11
a3583 13
    if (client->swapped)
    {
	WriteSConnSetupPrefix(client, lconnSetupPrefix);
	WriteSConnectionInfo(client,
			     (unsigned long)(lconnSetupPrefix->length << 2),
			     lConnectionInfo);
    }
    else
    {
	(void)WriteToClient(client, sizeof(xConnSetupPrefix),
			    (char *) lconnSetupPrefix);
	(void)WriteToClient(client, (int)(lconnSetupPrefix->length << 2),
			    lConnectionInfo);
d3586 2
a3587 3
    if (ClientStateCallback)
    {
	NewClientInfoRec clientinfo;
d3589 5
a3593 5
        clientinfo.client = client; 
        clientinfo.prefix = lconnSetupPrefix;  
        clientinfo.setup = (xConnSetup *)lConnectionInfo;
	CallCallbacks((&ClientStateCallback), (pointer)&clientinfo);
    } 	
d3600 2
a3601 1
    char *reason, *auth_proto, *auth_string;
d3603 1
d3606 2
a3607 2
    prefix = (xConnClientPrefix *)((char *)stuff + sz_xReq);
    auth_proto = (char *)prefix + sz_xConnClientPrefix;
d3610 2
a3611 2
	(prefix->minorVersion != X_PROTOCOL_REVISION))
	reason = "Protocol version mismatch";
d3613 7
a3619 18
	reason = ClientAuthorized(client,
				  (unsigned short)prefix->nbytesAuthProto,
				  auth_proto,
				  (unsigned short)prefix->nbytesAuthString,
				  auth_string);
    /*
     * If Kerberos is being used for this client, the clientState
     * will be set to ClientStateAuthenticating at this point.
     * More messages need to be exchanged among the X server, Kerberos
     * server, and client to figure out if everyone is authorized.
     * So we don't want to send the connection setup info yet, since
     * the auth step isn't really done.
     */
    if (client->clientState == ClientStateCheckingSecurity)
	client->clientState = ClientStateCheckedSecurity;
    else if (client->clientState != ClientStateAuthenticating)
	return(SendConnSetup(client, reason));
    return Success;
d3623 1
a3623 1
SendErrorToClient(ClientPtr client, unsigned majorCode, unsigned minorCode, 
d3635 1
a3635 1
    WriteEventsToClient (client, 1, (xEvent *)&rep);
d3650 2
a3651 2
	/* pad   pad   pad     pad*/
	/*  8     16    32    64 */
d3653 6
a3658 6
	{   3,     4,    5 ,   6 },	/* 1 bit per pixel */
	{   1,     2,    3 ,   4 },	/* 4 bits per pixel */
	{   0,     1,    2 ,   3 },	/* 8 bits per pixel */
	{   ~0,    0,    1 ,   2 },	/* 16 bits per pixel */
	{   ~0,    ~0,   0 ,   1 },	/* 24 bits per pixel */
	{   ~0,    ~0,   0 ,   1 }	/* 32 bits per pixel */
d3666 10
a3675 10
static int indexForBitsPerPixel[ 33 ] = {
	~0, 0, ~0, ~0,	/* 1 bit per pixel */
	1, ~0, ~0, ~0,	/* 4 bits per pixel */
	2, ~0, ~0, ~0,	/* 8 bits per pixel */
	~0,~0, ~0, ~0,
	3, ~0, ~0, ~0,	/* 16 bits per pixel */
	~0,~0, ~0, ~0,
	4, ~0, ~0, ~0,	/* 24 bits per pixel */
	~0,~0, ~0, ~0,
	5		/* 32 bits per pixel */
d3682 10
a3691 10
static int answerBytesPerPixel[ 33 ] = {
	~0, 0, ~0, ~0,	/* 1 bit per pixel */
	0, ~0, ~0, ~0,	/* 4 bits per pixel */
	0, ~0, ~0, ~0,	/* 8 bits per pixel */
	~0,~0, ~0, ~0,
	0, ~0, ~0, ~0,	/* 16 bits per pixel */
	~0,~0, ~0, ~0,
	3, ~0, ~0, ~0,	/* 24 bits per pixel */
	~0,~0, ~0, ~0,
	0		/* 32 bits per pixel */
d3699 18
a3716 18
static int indexForScanlinePad[ 65 ] = {
	~0, ~0, ~0, ~0,
	~0, ~0, ~0, ~0,
	 0, ~0, ~0, ~0,	/* 8 bits per scanline pad unit */
	~0, ~0, ~0, ~0,
	 1, ~0, ~0, ~0,	/* 16 bits per scanline pad unit */
	~0, ~0, ~0, ~0,
	~0, ~0, ~0, ~0,
	~0, ~0, ~0, ~0,
	 2, ~0, ~0, ~0,	/* 32 bits per scanline pad unit */
	~0, ~0, ~0, ~0,
	~0, ~0, ~0, ~0,
	~0, ~0, ~0, ~0,
	~0, ~0, ~0, ~0,
	~0, ~0, ~0, ~0,
	~0, ~0, ~0, ~0,
	~0, ~0, ~0, ~0,
	 3		/* 64 bits per scanline pad unit */
d3728 5
a3732 9
AddScreen(
    Bool	(* pfnInit)(
	int /*index*/,
	ScreenPtr /*pScreen*/,
	int /*argc*/,
	char ** /*argv*/
		),
    int argc,
    char **argv)
d3741 1
a3741 1
	return -1;
d3745 1
a3745 1
	return -1;
d3748 2
a3749 2
	free (pScreen);
	return -1;
d3752 2
a3753 2
    pScreen->totalPixmapSize = 0;	/* computed in CreateScratchPixmapForScreen */
    pScreen->ClipNotify = 0;	/* for R4 ddx compatibility */
d3765 20
a3784 23
    for (format=0; format<screenInfo.numPixmapFormats; format++)
    {
	depth = screenInfo.formats[format].depth;
	bitsPerPixel = screenInfo.formats[format].bitsPerPixel;
	scanlinepad = screenInfo.formats[format].scanlinePad;
	j = indexForBitsPerPixel[ bitsPerPixel ];
	k = indexForScanlinePad[ scanlinepad ];
	PixmapWidthPaddingInfo[ depth ].padPixelsLog2 = answer[j][k];
	PixmapWidthPaddingInfo[ depth ].padRoundUp =
	    (scanlinepad/bitsPerPixel) - 1;
	j = indexForBitsPerPixel[ 8 ]; /* bits per byte */
	PixmapWidthPaddingInfo[ depth ].padBytesLog2 = answer[j][k];
	PixmapWidthPaddingInfo[ depth ].bitsPerPixel = bitsPerPixel;
	if (answerBytesPerPixel[bitsPerPixel])
	{
	    PixmapWidthPaddingInfo[ depth ].notPower2 = 1;
	    PixmapWidthPaddingInfo[ depth ].bytesPerPixel =
		answerBytesPerPixel[bitsPerPixel];
	}
	else
	{
	    PixmapWidthPaddingInfo[ depth ].notPower2 = 0;
	}
d3794 1
a3794 1
    */
d3797 5
a3801 6
    if (!(*pfnInit)(i, pScreen, argc, argv))
    {
	dixFreePrivates(pScreen->devPrivates, PRIVATE_SCREEN);
	free(pScreen);
	screenInfo.numScreens--;
	return -1;
d3804 4
a3807 1
    dixRegisterPrivateKey(&cursorScreenDevPriv[i], PRIVATE_CURSOR, 0);
@


1.6
log
@Update to xserver 1.11.2
@
text
@a339 2
#define MAJOROP ((xReq *)client->requestBuffer)->reqType

d420 7
d428 5
a432 3
		XSERVER_REQUEST_START(LookupMajorName(MAJOROP), MAJOROP,
			      ((xReq *)client->requestBuffer)->length,
			      client->index, client->requestBuffer);
d437 1
a437 1
		    result = XaceHookDispatch(client, MAJOROP);
d439 1
a439 1
			result = (* client->requestVector[MAJOROP])(client);
d443 4
a446 2
		XSERVER_REQUEST_DONE(LookupMajorName(MAJOROP), MAJOROP,
			      client->sequence, client->index, result);
d456 2
a457 2
		    SendErrorToClient(client, MAJOROP,
				      MinorOpcodeOfRequest(client),
a476 2

#undef MAJOROP
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d78 1
a78 1
 * Copyright 2005-2006 Sun Microsystems, Inc.  All rights reserved.
d133 1
a241 1
void        InitProcVectors(void);
d920 1
a920 10
    /* XXX - Because the pixmap-implementation of the multibuffer extension 
     *       may have the buffer-id's drawable resource value be a pointer
     *       to the buffer's window instead of the buffer itself
     *       (this happens if the buffer is the displayed buffer),
     *       we also have to check that the id matches before we can
     *       truly say that it is a DRAWABLE_WINDOW.
     */

    if ((pDraw->type == UNDRAWABLE_WINDOW) ||
        ((pDraw->type == DRAWABLE_WINDOW) && (stuff->id == pDraw->id)))
d927 1
a927 1
    else /* DRAWABLE_PIXMAP or DRAWABLE_BUFFER */
a1421 1
	(*pDraw->pScreen->DestroyPixmap)(pMap);
d2978 5
a2982 3
	return rc;
    if (!AddResource(stuff->cid, RT_CURSOR, (pointer)pCursor))
	return BadAlloc;
d2985 4
a3385 19
void
InitProcVectors(void)
{
    int i;
    for (i = 0; i<256; i++)
    {
	if(!ProcVector[i])
	{
            ProcVector[i] = SwappedProcVector[i] = ProcBadRequest;
	    ReplySwapVector[i] = ReplyNotSwappd;
	}
    }
    for(i = LASTEvent; i < 128; i++)
    {
	EventSwapVector[i] = NotImplemented;
    }
    
}

d3468 3
d3508 1
d3548 5
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a178 7
/* Various of the DIX function interfaces were not designed to allow
 * the client->errorValue to be set on BadValue and other errors.
 * Rather than changing interfaces and breaking untold code we introduce
 * a new global that dispatch can use.
 */
XID clientErrorValue;   /* XXX this is a kludge */

d355 1
a355 1
    clientReady = xalloc(sizeof(int) * MaxClients);
d440 6
a445 1
		if (result != Success) 
d447 3
a449 6
		    if (client->noClientException != Success)
                        CloseDownClient(client);
                    else
		        SendErrorToClient(client, MAJOROP,
					  MinorOpcodeOfRequest(client),
					  client->errorValue, result);
d451 1
a451 1
	        }
d464 1
a464 1
    xfree(clientReady);
d528 1
a528 1
    ConnectionInfo = xalloc(lenofblock);
d565 1
a565 1
	root.windowId = WindowTable[i]->drawable.id;
d590 1
a590 1
	    pBuf = (char *)xrealloc(ConnectionInfo, lenofblock);
d593 1
a593 1
		xfree(ConnectionInfo);
d634 1
a634 1
    return (BadRequest);
d673 1
a673 4
    if (client->noClientException != Success)
        return(client->noClientException);
    else
        return rc;
d681 1
a681 1
    int result, len, rc;
d693 1
a693 1
    result =  ChangeWindowAttributes(pWin, 
a696 4
    if (client->noClientException != Success)
        return(client->noClientException);
    else
        return(result);
d714 1
a714 1
    return(client->noClientException);
d735 1
a735 1
    return(client->noClientException);
d750 1
a750 1
    return(client->noClientException);
d758 1
a758 1
    int result, rc;
d767 3
a769 12
    {
        result = AlterSaveSetForClient(client, pWin, stuff->mode, FALSE, TRUE);
	if (client->noClientException != Success)
	    return(client->noClientException);
	else
            return(result);
    }
    else
    {
	client->errorValue = stuff->mode;
	return( BadValue );
    }
d777 1
a777 1
    int result, rc;
d786 10
a795 17
    if (SAME_SCREENS(pWin->drawable, pParent->drawable))
    {
        if ((pWin->backgroundState == ParentRelative) &&
            (pParent->drawable.depth != pWin->drawable.depth))
            return BadMatch;
	if ((pWin->drawable.class != InputOnly) &&
	    (pParent->drawable.class == InputOnly))
	    return BadMatch;
        result =  ReparentWindow(pWin, pParent, 
			 (short)stuff->x, (short)stuff->y, client);
	if (client->noClientException != Success)
            return(client->noClientException);
	else
            return(result);
    }
    else 
        return (BadMatch);
d811 1
a811 1
    return(client->noClientException);
d827 1
a827 1
    return(client->noClientException);
d843 1
a843 1
    return(client->noClientException);
d858 1
a858 1
    return(client->noClientException);
a865 1
    int result;
d876 1
a876 6
    result =  ConfigureWindow(pWin, (Mask)stuff->mask, (XID *) &stuff[1], 
			      client);
    if (client->noClientException != Success)
        return(client->noClientException);
    else
        return(result);
d897 1
a897 1
    return(client->noClientException);
d915 1
a915 1
    rep->root = WindowTable[pDraw->pScreen->myNum]->drawable.id;
d956 1
a956 1
    return(client->noClientException);
d975 1
a975 1
    reply.root = WindowTable[pWin->drawable.pScreen->myNum]->drawable.id;
d988 1
a988 1
	childIDs = xalloc(numChildren * sizeof(Window));
d1003 1
a1003 1
	xfree(childIDs);
d1006 1
a1006 1
    return(client->noClientException);
d1020 1
a1020 1
        return(BadValue);
d1033 1
a1033 1
	return(client->noClientException);
d1036 1
a1036 1
	return (BadAlloc);
d1058 1
a1058 1
	return(client->noClientException);
d1063 1
a1063 1
	return (BadAtom);
d1078 1
a1078 1
	return(client->noClientException);
d1094 1
a1094 1
    return(client->noClientException);
d1129 1
a1129 1
    return(client->noClientException);
d1182 1
a1182 2
		    POINT_IN_REGION(pWin->drawable.pScreen, 
					&pWin->borderSize, x, y, &box))
d1185 3
a1187 4
		    POINT_IN_REGION(pWin->drawable.pScreen,
				    wInputShape(pWin),
				    x - pWin->drawable.x,
				    y - pWin->drawable.y, &box))
d1201 1
a1201 1
    return(client->noClientException);
d1217 1
a1217 1
	return(client->noClientException);
d1236 1
a1236 1
	return(client->noClientException);
d1241 1
a1241 1
        return (rc == BadValue) ? BadFont : rc;
a1249 1
    GC *pGC;
d1254 1
a1254 9
    client->errorValue = stuff->id;		/* EITHER font or gc */
    rc = dixLookupResourceByType((pointer *)&pFont, stuff->id, RT_FONT, client,
				 DixGetAttrAccess);
    if (rc == BadValue) {
	rc = dixLookupResourceByType((pointer *)&pGC, stuff->id, RT_GC, client,
				     DixGetAttrAccess);
	if (rc == Success)
	    pFont = pGC->font;
    }
d1256 1
a1256 1
	return (rc == BadValue) ? BadFont: rc;
d1275 1
a1275 1
	reply = xcalloc(1, rlength);
d1278 1
a1278 1
	    return(BadAlloc);
d1287 2
a1288 2
	xfree(reply);
	return(client->noClientException);
a1296 1
    GC *pGC;
d1303 1
a1303 9
    client->errorValue = stuff->fid;		/* EITHER font or gc */
    rc = dixLookupResourceByType((pointer *)&pFont, stuff->fid, RT_FONT, client,
				 DixGetAttrAccess);
    if (rc == BadValue) {
	rc = dixLookupResourceByType((pointer *)&pGC, stuff->fid, RT_GC, client,
			       DixGetAttrAccess);
	if (rc == Success)
	    pFont = pGC->font;
    }
d1305 1
a1305 1
	return (rc == BadValue) ? BadFont: rc;
d1312 1
a1312 1
	    return(BadLength);
d1316 1
a1316 1
	return(BadAlloc);
d1329 1
a1329 1
    return(client->noClientException);
d1430 1
a1430 1
	    return(client->noClientException);
d1433 1
a1433 1
    return (BadAlloc);
d1449 1
a1449 1
	return(client->noClientException);
d1454 1
a1454 1
	return (rc == BadValue) ? BadPixmap : rc;
d1483 2
a1484 2
	return (BadAlloc);
    return(client->noClientException);
d1504 1
a1504 8
    result = dixChangeGC(client, pGC, stuff->mask, (CARD32 *) &stuff[1], 0);
    if (client->noClientException != Success)
        return(client->noClientException);
    else
    {
	client->errorValue = clientErrorValue;
        return(result);
    }
d1523 2
a1524 5
        return (BadMatch);    
    result = CopyGC(pGC, dstGC, stuff->mask);
    if (client->noClientException != Success)
        return(client->noClientException);
    else
d1526 2
a1527 2
	client->errorValue = clientErrorValue;
        return(result);
d1529 1
d1550 4
a1553 1
    result = SetDashes(pGC, stuff->dashOffset, stuff->nDashes,
a1554 7
    if (client->noClientException != Success)
        return(client->noClientException);
    else
    {
	client->errorValue = clientErrorValue;
        return(result);
    }
d1577 1
a1577 1
	return(BadLength);
d1579 1
a1579 1
    result = SetClipRects(pGC, stuff->xOrigin, stuff->yOrigin,
a1580 4
    if (client->noClientException != Success)
        return(client->noClientException);
    else
        return(result);
d1596 1
a1596 1
    return(client->noClientException);
d1613 1
a1613 1
	return (BadMatch);
d1618 1
a1618 1
        return(BadValue);
d1623 1
a1623 1
    return(client->noClientException);
d1648 1
a1648 1
	    return (BadMatch);
d1662 1
a1662 1
	    REGION_DESTROY(pDst->pScreen, pRgn);
d1665 1
a1665 1
    return(client->noClientException);
d1690 1
a1690 1
	    return (BadMatch);
d1701 1
a1701 1
       return(BadValue);
d1712 1
a1712 1
	    REGION_DESTROY(pdstDraw->pScreen, pRgn);
d1714 1
a1714 1
    return(client->noClientException);
d1737 1
a1737 1
    return (client->noClientException);
d1760 1
a1760 1
    return(client->noClientException);
d1775 1
a1775 1
	return(BadLength);
d1779 1
a1779 1
    return (client->noClientException);
d1794 1
a1794 1
	return(BadLength);
d1799 1
a1799 1
    return(client->noClientException);
d1814 1
a1814 1
	return(BadLength);
d1818 1
a1818 1
    return (client->noClientException);
d1849 1
a1849 1
    return(client->noClientException);
d1864 1
a1864 1
	return(BadLength);
d1870 1
a1870 1
    return (client->noClientException);
d1885 1
a1885 1
	return(BadLength);
d1889 1
a1889 1
    return (client->noClientException);
d2000 1
a2000 1
     return (client->noClientException);
d2022 1
a2022 1
        return(BadValue);
d2056 1
a2056 1
	    pBoundingDraw = (DrawablePtr)WindowTable[pDraw->pScreen->myNum];
d2104 1
a2104 1
	pBuf = xcalloc(1, sz_xGetImageReply + length);
d2106 1
a2106 1
	    return (BadAlloc);
d2142 2
a2143 2
	if(!(pBuf = xcalloc(1, length)))
	    return (BadAlloc);
d2152 1
a2152 2
	    REGION_TRANSLATE(pDraw->pScreen, pVisibleRegion,
			     -pDraw->x, -pDraw->y);
d2240 1
a2240 1
	REGION_DESTROY(pDraw->pScreen, pVisibleRegion);
d2242 2
a2243 2
	xfree(pBuf);
    return (client->noClientException);
d2282 1
a2282 1
	return(client->noClientException);
d2312 1
a2312 1
	return(client->noClientException);
d2342 1
a2342 1
	return(client->noClientException);
d2365 1
a2365 1
        return(BadValue);
d2380 1
a2380 1
	result =  CreateColormap(mid, pScreen, pVisual, &pmap,
a2381 4
	if (client->noClientException != Success)
	    return(client->noClientException);
	else
	    return(result);
d2384 1
a2384 1
    return(BadMatch);
d2402 1
a2402 1
	return (client->noClientException);
d2407 1
a2407 1
	return (rc == BadValue) ? BadColor : rc;
d2426 3
a2428 12
    {
	rc = CopyColormapAndFree(mid, pSrcMap, client->index);
	if (client->noClientException != Success)
            return(client->noClientException);
	else
            return rc;
    }
    else
    {
	client->errorValue = stuff->srcCmap;
	return (rc == BadValue) ? BadColor : rc;
    }
d2445 3
a2447 1
    if (rc != Success)
d2449 1
d2452 1
a2453 1
    rc = client->noClientException;
d2456 1
a2456 1
    return (rc == BadValue) ? BadColor : rc;
d2473 3
a2475 1
    if (rc != Success)
d2477 1
d2481 1
a2482 1
    rc = client->noClientException;
d2485 1
a2485 1
    return (rc == BadValue) ? BadColor : rc;
d2499 1
a2499 1
	goto out;
d2504 1
a2504 1
	goto out;
d2506 1
a2506 1
    preply = xalloc(sizeof(xListInstalledColormapsReply) +
d2510 1
a2510 1
        return(BadAlloc);
d2521 2
a2522 4
    xfree(preply);
    rc = client->noClientException;
out:
    return rc;
d2547 1
a2547 6
	{
            if (client->noClientException != Success)
                return(client->noClientException);
	    else
	        return rc;
	}
d2552 1
a2552 1
	return (client->noClientException);
d2558 1
a2558 1
        return (rc == BadValue) ? BadColor : rc;
d2590 1
a2590 6
	    {
                if (client->noClientException != Success)
                    return(client->noClientException);
                else
		    return rc;
	    }
d2595 1
a2595 1
	    return (client->noClientException);
d2598 1
a2598 1
	    return(BadName);
d2604 1
a2604 1
        return (rc == BadValue) ? BadColor : rc;
d2629 1
a2629 1
	    return (BadValue);
d2634 1
a2634 1
	    return (BadValue);
d2638 1
a2638 1
	ppixels = xalloc(length);
d2640 1
a2640 1
            return(BadAlloc);
d2646 2
a2647 5
	    xfree(ppixels);
            if (client->noClientException != Success)
                return(client->noClientException);
	    else
	        return rc;
d2662 2
a2663 2
	xfree(ppixels);
        return (client->noClientException);        
d2668 1
a2668 1
        return (rc == BadValue) ? BadColor : rc;
d2693 1
a2693 1
	    return (BadValue);
d2698 1
a2698 1
	    return (BadValue);
d2704 1
a2704 1
	ppixels = xalloc(length);
d2706 1
a2706 1
            return(BadAlloc);
d2712 2
a2713 5
            xfree(ppixels);
            if (client->noClientException != Success)
                return(client->noClientException);
	    else
	        return rc;
d2724 2
a2725 2
	xfree(ppixels);
        return (client->noClientException);        
d2730 1
a2730 1
        return (rc == BadValue) ? BadColor : rc;
d2749 1
a2749 1
	    return(BadAccess);
d2751 1
a2751 1
	rc = FreeColors(pcmp, client->index, count,
a2752 8
        if (client->noClientException != Success)
            return(client->noClientException);
        else
	{
	    client->errorValue = clientErrorValue;
            return rc;
	}

d2757 1
a2757 1
        return (rc == BadValue) ? BadColor : rc;
d2777 1
a2777 1
	    return(BadLength);
d2779 1
a2779 8
	rc = StoreColors(pcmp, count, (xColorItem *)&stuff[1]);
        if (client->noClientException != Success)
            return(client->noClientException);
        else
	{
	    client->errorValue = clientErrorValue;
            return rc;
	}
d2784 1
a2784 1
        return (rc == BadValue) ? BadColor : rc;
d2807 1
a2807 5
	    rc = StoreColors(pcmp, 1, &def);
            if (client->noClientException != Success)
                return(client->noClientException);
	    else
		return rc;
d2809 1
a2809 1
        return (BadName);        
d2814 1
a2814 1
        return (rc == BadValue) ? BadColor : rc;
d2835 1
a2835 1
	prgbs = xcalloc(1, count * sizeof(xrgb));
d2837 2
a2838 2
            return(BadAlloc);
	if( (rc = QueryColors(pcmp, count, (Pixel *)&stuff[1], prgbs)) )
d2840 2
a2841 8
   	    if (prgbs) xfree(prgbs);
	    if (client->noClientException != Success)
                return(client->noClientException);
	    else
	    {
		client->errorValue = clientErrorValue;
	        return rc;
	    }
d2854 2
a2855 2
	if (prgbs) xfree(prgbs);
	return(client->noClientException);
d2861 1
a2861 1
        return (rc == BadValue) ? BadColor : rc;
d2893 1
a2893 1
	    return(client->noClientException);
d2895 1
a2895 1
        return (BadName);        
d2900 1
a2900 1
        return (rc == BadValue) ? BadColor : rc;
d2926 1
a2926 1
	return (rc == BadValue) ? BadPixmap : rc;
d2936 1
a2936 1
	    return (rc == BadValue) ? BadPixmap : rc;
d2943 1
a2943 1
	return (BadMatch);
d2950 1
a2950 1
	return (BadMatch);
d2953 1
a2953 1
    srcbits = xcalloc(1, n);
d2955 2
a2956 2
	return (BadAlloc);
    mskbits = xalloc(n);
d2959 2
a2960 2
	xfree(srcbits);
	return (BadAlloc);
d2974 1
a2974 1
	bzero((char *)mskbits, n);
d2992 1
a2992 1
    return client->noClientException;
d3014 1
a3014 1
	return client->noClientException;
d3032 1
a3032 1
	return (client->noClientException);
d3037 1
a3037 1
	return (rc == BadValue) ? BadCursor : rc;
d3056 1
a3056 1
        return(BadValue);
d3064 1
a3064 1
	return (BadMatch);
d3078 1
a3078 1
    return (client->noClientException);
d3142 1
a3142 1
    return (client->noClientException);
d3167 1
a3167 1
    return (client->noClientException);
a3173 1
    int result;
d3178 1
a3178 1
	result = AddHost(client, (int)stuff->hostFamily,
d3180 2
a3181 2
    else if (stuff->mode == HostDelete)
	result = RemoveHost(client, (int)stuff->hostFamily, 
d3183 2
a3184 8
    else
    {
	client->errorValue = stuff->mode;
        return BadValue;
    }
    if (!result)
	result = client->noClientException;
    return (result);
d3204 1
a3204 1
	return(result);
d3215 2
a3216 2
    xfree(pdata);
    return (client->noClientException);
a3221 1
    int result;
d3230 1
a3230 4
    result = ChangeAccessControl(client, stuff->mode == EnableAccess);
    if (!result)
	result = client->noClientException;
    return (result);
d3266 1
a3266 1
        return (client->noClientException);
d3279 1
a3279 1
	    return (Success);
d3281 1
a3281 1
	return (client->noClientException);
d3293 1
a3293 2
    int n, result;
    int error;
d3305 1
a3305 1
	    return(BadLength);
d3310 2
a3311 9
	return(BadLength);
    result = SetFontPath(client, stuff->nFonts, (unsigned char *)&stuff[1],
			 &error);
    if (!result)
    {
	result = client->noClientException;
	client->errorValue = error;
    }
    return (result);
d3335 1
a3335 1
    return(client->noClientException);
d3354 1
a3354 1
	return (client->noClientException);
d3359 1
a3359 1
	return (BadValue);
d3379 1
a3379 1
    return client->noClientException;
d3387 1
a3387 1
    return(client->noClientException);
d3498 1
a3498 2
	dixFreePrivates(client->devPrivates);
	xfree(client);
a3518 1
    memset(client, 0, sizeof(*client));
d3546 1
a3546 1
    clients[i] = client = xalloc(sizeof(ClientRec));
d3552 1
a3552 1
	xfree(client);
d3560 1
a3560 1
	xfree(client);
d3576 1
a3576 1
    return(client);
d3588 1
a3588 1
	return (client->noClientException = -1);
d3603 1
a3603 1
    return (client->noClientException);
d3629 1
a3629 1
	return (client->noClientException = -1);
d3664 1
d3666 1
a3666 2
        root->currentInputMask = WindowTable[i]->eventMask |
			         wOtherEventMasks (WindowTable[i]);
d3700 1
a3700 1
    return (client->noClientException);
d3734 1
a3734 1
    return(client->noClientException);
a3744 1
    rep.sequenceNumber = client->sequence;
d3862 1
a3862 1
    pScreen = (ScreenPtr) xcalloc(1, sizeof(ScreenRec));
d3866 4
a3869 1
    pScreen->devPrivates = NULL;
d3871 1
a3871 1
    pScreen->totalPixmapSize = BitmapBytePad(sizeof(PixmapRec)*8);
a3916 2
    pScreen->rgf = ~0L;  /* there are no scratch GCs yet*/
    WindowTable[i] = NullWindow;
d3921 2
a3922 2
	dixFreePrivates(pScreen->devPrivates);
	xfree(pScreen);
d3926 3
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d81 17
a97 23
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
d104 1
a127 4
#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif
a129 4
#ifdef XKB
#ifndef XKB_IN_SERVER
#define XKB_IN_SERVER
#endif
d131 2
a132 2
#include <xkbsrv.h>
#endif
d149 3
a151 1
extern xConnSetupPrefix connSetupPrefix;
d159 1
a159 1
_X_EXPORT CallbackListPtr ServerGrabCallback = NULL;
d161 1
a161 1
extern int connBlockScreenStart;
d169 1
a169 1
_X_EXPORT CallbackListPtr ClientStateCallback;
d176 2
a177 2
_X_EXPORT volatile char dispatchException = 0;
_X_EXPORT volatile char isItTimeToYield;
d196 1
a196 1
_X_EXPORT void
d215 1
a215 1
_X_EXPORT void
d234 6
a239 6
Bool	    SmartScheduleDisable = FALSE;
long	    SmartScheduleSlice = SMART_SCHEDULE_DEFAULT_INTERVAL;
long	    SmartScheduleInterval = SMART_SCHEDULE_DEFAULT_INTERVAL;
long	    SmartScheduleMaxSlice = SMART_SCHEDULE_MAX_SLICE;
long	    SmartScheduleTime;
int	    SmartScheduleLatencyLimited = 0;
d362 1
a362 1
    clientReady = (int *) xalloc(sizeof(int) * MaxClients);
a428 6
#ifdef DEBUG
		if (client->requestLogIndex == MAX_REQUEST_LOG)
		    client->requestLogIndex = 0;
		client->requestLog[client->requestLogIndex] = MAJOROP;
		client->requestLogIndex++;
#endif
d476 161
a636 1
_X_EXPORT int
d655 1
a655 1
    len = client->req_len - (sizeof(xCreateWindowReq) >> 2);
d698 1
a698 1
    len = client->req_len - (sizeof(xChangeWindowAttributesReq) >> 2);
d723 1
d902 1
a902 1
    len = client->req_len - (sizeof(xConfigureWindowReq) >> 2);
d985 1
d1007 1
d1022 1
a1022 1
	childIDs = (Window *) xalloc(numChildren * sizeof(Window));
d1030 1
a1030 1
    reply.length = (numChildren * sizeof(Window)) >> 2;
d1061 1
d1076 1
a1076 1
    char *str;
d1085 1
d1087 1
a1087 1
	reply.length = (len + 3) >> 2;
d1182 1
d1263 1
d1267 3
a1269 3
    pFont = (FontPtr)SecurityLookupIDByType(client, stuff->id, RT_FONT,
					    DixDestroyAccess);
    if ( pFont != (FontPtr)NULL)	/* id was valid */
d1277 1
a1277 1
        return (BadFont);
d1320 1
a1320 1
	reply = (xQueryFontReply *)xalloc(rlength);
d1327 1
a1327 1
	reply->length = (rlength - sizeof(xGenericReply)) >> 2;
d1361 1
a1361 1
    length = client->req_len - (sizeof(xQueryTextExtentsReq) >> 2);
d1529 1
a1529 1
    len = client->req_len -  (sizeof(xCreateGCReq) >> 2);
d1554 1
a1554 1
    len = client->req_len -  (sizeof(xChangeGCReq) >> 2);
d1804 1
a1804 1
    npoint = ((client->req_len << 2) - sizeof(xPolyPointReq)) >> 2;
d1827 1
a1827 1
    npoint = ((client->req_len << 2) - sizeof(xPolyLineReq)) >> 2;
d1915 1
a1915 1
    things = ((client->req_len << 2) - sizeof(xFillPolyReq)) >> 2;
d2059 2
a2060 2
    if (((((lengthProto * stuff->height) + (unsigned)3) >> 2) + 
	(sizeof(xPutImageReq) >> 2)) != client->req_len)
d2079 1
a2079 1
    DrawablePtr		pDraw;
d2081 3
a2083 1
    int	linesDone;
d2099 5
d2106 25
a2130 15
      if( /* check for being viewable */
	 !((WindowPtr) pDraw)->realized ||
	  /* check for being on screen */
         pDraw->x + x < 0 ||
 	 pDraw->x + x + width > pDraw->pScreen->width ||
         pDraw->y + y < 0 ||
         pDraw->y + y + height > pDraw->pScreen->height ||
          /* check for being inside of border */
         x < - wBorderWidth((WindowPtr)pDraw) ||
         x + width > wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
         y < -wBorderWidth((WindowPtr)pDraw) ||
         y + height > wBorderWidth ((WindowPtr)pDraw) + (int)pDraw->height
        )
	    return(BadMatch);
	xgi.visual = wVisual (((WindowPtr) pDraw));
d2134 1
a2134 6
      if(x < 0 ||
         x+width > (int)pDraw->width ||
         y < 0 ||
         y+height > (int)pDraw->height
        )
	    return(BadMatch);
d2138 15
d2175 1
a2175 1
	pBuf = (char *)xalloc(sz_xGetImageReply + length);
d2186 1
a2186 1
	xgi.length = (xgi.length + 3) >> 2;
d2213 1
a2213 1
	if(!(pBuf = (char *) xalloc(length)))
d2585 1
a2585 2
    preply = (xListInstalledColormapsReply *) 
		xalloc(sizeof(xListInstalledColormapsReply) +
d2729 1
a2729 1
	ppixels = (Pixel *)xalloc(length);
d2748 1
a2748 1
	    accr.length = length >> 2;
d2798 1
a2798 1
	ppixels = (Pixel *)xalloc(length);
d2812 1
a2812 1
	acpr.length = length >> 2;
d2847 1
a2847 1
	count = ((client->req_len << 2)- sizeof(xFreeColorsReq)) >> 2;
d2950 2
a2951 2
	count = ((client->req_len << 2) - sizeof(xQueryColorsReq)) >> 2;
	prgbs = (xrgb *)xalloc(count * sizeof(xrgb));
d2965 1
d2967 1
a2967 1
	qcr.length = (count * sizeof(xrgb)) >> 2;
d3193 1
d3337 1
a3337 1
    reply.length = len >> 2;
d3470 1
a3470 1
    reply.length = (stringLens + numpaths + 3) >> 2;
d3661 1
a3662 1
    client->sequence = 0; 
a3663 1
    client->clientGone = FALSE;
a3664 6
    client->numSaved = 0;
    client->saveSet = (SaveSetElt *)NULL;
    client->noClientException = Success;
#ifdef DEBUG
    client->requestLogIndex = 0;
#endif
d3667 1
a3667 17
    client->swapped = FALSE;
    client->big_requests = FALSE;
    client->priority = 0;
    client->clientState = ClientStateInitial;
    client->devPrivates = NULL;
#ifdef XKB
    if (!noXkbExtension) {
	client->xkbClientFlags = 0;
	client->mapNotifyMask = 0;
	client->newKeyboardNotifyMask = 0;
	client->vMinor = client->vMajor = 0;
	QueryMinMaxKeyCodes(&client->minKC,&client->maxKC);
    }
#endif
    client->replyBytesRemaining = 0;
    client->fontResFunc = NULL;
    client->smart_priority = 0;
a3670 2

    client->clientPtr = NULL;
d3689 1
a3689 1
    clients[i] = client = (ClientPtr)xalloc(sizeof(ClientRec));
d3699 1
a3699 1
    data.length = (sz_xReq + sz_xConnClientPrefix) >> 2;
d3739 2
a3740 2
    stuff->length += ((prefix->nbytesAuthProto + (unsigned)3) >> 2) +
		     ((prefix->nbytesAuthString + (unsigned)3) >> 2);
d3764 1
a3764 1
	csp.length = (csp.lengthReason + (unsigned)3) >> 2;
d3855 1
a3855 1
    auth_string = auth_proto + ((prefix->nbytesAuthProto + 3) & ~3);
d3880 1
a3880 1
_X_EXPORT void
d3886 1
d3901 169
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a138 3
#ifdef XAPPGROUP
#include "appgroup.h"
#endif
a162 1
extern char *ConnectionInfo;
d200 1
a200 1
_X_EXPORT void
a238 1
#ifdef SMART_SCHEDULE
d250 1
d321 1
a321 1
    if (nready == 1)
d340 17
a356 1
#endif
a367 1
#ifdef SMART_SCHEDULE
a368 1
#endif
d377 1
a387 1
#ifdef SMART_SCHEDULE
a392 1
#endif
a413 4
#ifdef XPRINT
            requestingClient = client;
#endif
#ifdef SMART_SCHEDULE
a414 1
#endif
a420 1
#ifdef SMART_SCHEDULE
a428 1
#endif
a475 1
#ifdef SMART_SCHEDULE
a478 4
#endif
#ifdef XPRINT
	    requestingClient = NULL;
#endif
d488 1
a1053 1
#ifdef SHAPE
a1054 1
#endif
a1061 1
#ifdef SHAPE
a1074 1
#endif
d1142 2
a1143 2
    rc = dixLookupResource((pointer *)&pFont, stuff->id, RT_FONT, client,
			   DixGetAttrAccess);
d1145 2
a1146 2
	rc = dixLookupResource((pointer *)&pGC, stuff->id, RT_GC, client,
			       DixGetAttrAccess);
d1200 2
a1201 2
    rc = dixLookupResource((pointer *)&pFont, stuff->fid, RT_FONT, client,
			   DixGetAttrAccess);
d1203 1
a1203 1
	rc = dixLookupResource((pointer *)&pGC, stuff->fid, RT_GC, client,
d1348 1
a1348 1
    rc = dixLookupResource((pointer *)&pMap, stuff->id, RT_PIXMAP, client,
d2294 1
a2294 1
    rc = dixLookupResource((pointer *)&pmap, stuff->id, RT_COLORMAP, client,
d2322 1
a2322 1
    rc = dixLookupResource((pointer *)&pSrcMap, stuff->srcCmap, RT_COLORMAP,
d2347 1
a2347 1
    rc = dixLookupResource((pointer *)&pcmp, stuff->id, RT_COLORMAP, client,
d2372 1
a2372 1
    rc = dixLookupResource((pointer *)&pcmp, stuff->id, RT_COLORMAP, client,
d2439 1
a2439 1
    rc = dixLookupResource((pointer *)&pmap, stuff->cmap, RT_COLORMAP, client,
d2480 1
a2480 1
    rc = dixLookupResource((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
d2531 1
a2531 1
    rc = dixLookupResource((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
d2598 1
a2598 1
    rc = dixLookupResource((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
d2663 1
a2663 1
    rc = dixLookupResource((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
d2698 1
a2698 1
    rc = dixLookupResource((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
d2732 1
a2732 1
    rc = dixLookupResource((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
d2766 1
a2766 1
    rc = dixLookupResource((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
d2818 1
a2818 1
    rc = dixLookupResource((pointer *)&pcmp, stuff->cmap, RT_COLORMAP, client,
d2867 1
a2867 1
    rc = dixLookupResource((pointer *)&src, stuff->source, RT_PIXMAP, client,
d2874 1
a2874 1
    rc = dixLookupResource((pointer *)&msk, stuff->mask, RT_PIXMAP, client,
d2898 1
a2898 1
    srcbits = (unsigned char *)xalloc(n);
d2901 1
a2901 1
    mskbits = (unsigned char *)xalloc(n);
a2907 2
    /* zeroing the (pad) bits helps some ddx cursor handling */
    bzero((char *)srcbits, n);
d2972 1
a2972 1
    rc = dixLookupResource((pointer *)&pCursor, stuff->id, RT_CURSOR, client,
a3459 1
#ifdef SMART_SCHEDULE
a3460 1
#endif
d3505 2
a3510 3
#ifdef XAPPGROUP
    client->appgroup = NULL;
#endif
a3511 1
#ifdef SMART_SCHEDULE
d3516 2
a3517 1
#endif
a3634 3
#ifdef XAPPGROUP
    XagConnectionInfo (client, &lconnSetupPrefix, &lConnectionInfo, &numScreens);
#endif
@


1.1
log
@Initial revision
@
text
@d77 30
d137 1
a137 1
#ifdef XACE
a138 1
#endif
d147 8
a154 1
#include <X11/extensions/XKBsrv.h>
a167 4
_X_EXPORT Selection *CurrentSelections;
_X_EXPORT int NumCurrentSelections;
CallbackListPtr SelectionCallback = NULL;

a179 2
static void DeleteClientFromAnySelections(ClientPtr client);

d212 1
a212 1
UpdateCurrentTime()
d231 1
a231 1
UpdateCurrentTimeIf()
a242 36
void
InitSelections()
{
    if (CurrentSelections)
	xfree(CurrentSelections);
    CurrentSelections = (Selection *)NULL;
    NumCurrentSelections = 0;
}

void 
FlushClientCaches(XID id)
{
    int i;
    register ClientPtr client;

    client = clients[CLIENT_ID(id)];
    if (client == NullClient)
        return ;
    for (i=0; i<currentMaxClients; i++)
    {
	client = clients[i];
        if (client != NullClient)
	{
            if (client->lastDrawableID == id)
	    {
		client->lastDrawableID = WindowTable[0]->drawable.id;
		client->lastDrawable = (DrawablePtr)WindowTable[0];
	    }
            else if (client->lastGCID == id)
	    {
                client->lastGCID = INVALID;
		client->lastGC = (GCPtr)NULL;
	    }
	}
    }
}
d255 2
a256 3
ClientPtr   SmartLastClient;
int	    SmartLastIndex[SMART_MAX_PRIORITY-SMART_MIN_PRIORITY+1];
int         SmartScheduleClient(int *clientReady, int nready);
d265 1
a265 1
int
d351 5
a355 5
    register int        *clientReady;     /* array of request ready clients */
    register int	result;
    register ClientPtr	client;
    register int	nready;
    register HWEventQueuePtr* icheck = checkForInput;
a360 1
    InitSelections();
d363 1
a363 1
    clientReady = (int *) ALLOCATE_LOCAL(sizeof(int) * MaxClients);
d405 1
d407 1
a413 1
		{
d415 2
a416 2
		    FlushIfCriticalOutputPending();
		}
d444 5
d451 5
a455 6
		else
#ifdef XACE
		{
		    XaceHook(XACE_AUDIT_BEGIN, client);
		    result = (* client->requestVector[MAJOROP])(client);
		    XaceHook(XACE_AUDIT_END, client, result);
d457 5
a461 4
#else
    		    result = (* client->requestVector[MAJOROP])(client);
#endif /* XACE */
	    
a471 3
#ifdef DAMAGEEXT
		FlushIfCriticalOutputPending ();
#endif
d479 1
d481 1
d489 1
a489 1
    DEALLOCATE_LOCAL(clientReady);
d504 1
a504 1
    register WindowPtr pParent, pWin;
d506 1
a506 2
    int result;
    int len;
d511 3
a513 3
    if (!(pParent = (WindowPtr)SecurityLookupWindow(stuff->parent, client,
						    SecurityWriteAccess)))
        return BadWindow;
d527 1
a527 1
			      client, stuff->visual, &result);
d540 1
a540 1
        return(result);
d544 1
a544 1
ProcChangeWindowAttributes(register ClientPtr client)
d546 1
a546 1
    register WindowPtr pWin;
d548 2
a549 2
    register int result;
    int len;
d552 5
a556 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityWriteAccess);
    if (!pWin)
        return(BadWindow);
d571 1
a571 1
ProcGetWindowAttributes(register ClientPtr client)
d573 1
a573 1
    register WindowPtr pWin;
d576 1
d579 3
a581 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->id, client,
					   SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
d588 1
a588 1
ProcDestroyWindow(register ClientPtr client)
d590 1
a590 1
    register WindowPtr pWin;
d592 1
d595 8
a602 5
    pWin = (WindowPtr)SecurityLookupWindow(stuff->id, client,
					   SecurityDestroyAccess);
    if (!pWin)
        return(BadWindow);
    if (pWin->parent)
d604 1
d609 1
a609 1
ProcDestroySubwindows(register ClientPtr client)
d611 1
a611 1
    register WindowPtr pWin;
d613 1
d616 3
a618 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->id, client,
					   SecurityDestroyAccess);
    if (!pWin)
        return(BadWindow);
d624 1
a624 1
ProcChangeSaveSet(register ClientPtr client)
d626 1
a626 1
    register WindowPtr pWin;
d628 1
a628 1
    register int result;
d631 3
a633 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
d652 1
a652 1
ProcReparentWindow(register ClientPtr client)
d654 1
a654 1
    register WindowPtr pWin, pParent;
d656 1
a656 1
    register int result;
d659 6
a664 8
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityWriteAccess);
    if (!pWin)
        return(BadWindow);
    pParent = (WindowPtr)SecurityLookupWindow(stuff->parent, client,
					      SecurityWriteAccess);
    if (!pParent)
        return(BadWindow);
d685 1
a685 1
ProcMapWindow(register ClientPtr client)
d687 1
a687 1
    register WindowPtr pWin;
d689 1
d692 3
a694 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->id, client,
					   SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
d701 1
a701 1
ProcMapSubwindows(register ClientPtr client)
d703 1
a703 1
    register WindowPtr pWin;
d705 1
d708 3
a710 4
    pWin = (WindowPtr)SecurityLookupWindow( stuff->id, client,
					    SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
d717 1
a717 1
ProcUnmapWindow(register ClientPtr client)
d719 1
a719 1
    register WindowPtr pWin;
d721 1
d724 3
a726 4
    pWin = (WindowPtr)SecurityLookupWindow( stuff->id, client,
					    SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
d733 1
a733 1
ProcUnmapSubwindows(register ClientPtr client)
d735 1
a735 1
    register WindowPtr pWin;
d737 1
d740 3
a742 4
    pWin = (WindowPtr)SecurityLookupWindow( stuff->id, client,
					    SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
d748 1
a748 1
ProcConfigureWindow(register ClientPtr client)
d750 1
a750 1
    register WindowPtr pWin;
d752 2
a753 2
    register int result;
    int len;
d756 4
a759 4
    pWin = (WindowPtr)SecurityLookupWindow( stuff->window, client,
					    SecurityWriteAccess);
    if (!pWin)
        return(BadWindow);
d772 1
a772 1
ProcCirculateWindow(register ClientPtr client)
d774 1
a774 1
    register WindowPtr pWin;
d776 1
d785 3
a787 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityWriteAccess);
    if (!pWin)
        return(BadWindow);
d792 2
a793 2
int
GetGeometry(register ClientPtr client, xGetGeometryReply *rep)
d795 2
a796 1
    register DrawablePtr pDraw;
d798 5
a803 2
    REQUEST_SIZE_MATCH(xResourceReq);
    SECURITY_VERIFY_GEOMETRABLE (pDraw, stuff->id, client, SecurityReadAccess);
d823 1
a823 1
        register WindowPtr pWin = (WindowPtr)pDraw;
d838 1
a838 1
ProcGetGeometry(register ClientPtr client)
d852 1
a852 1
ProcQueryTree(register ClientPtr client)
d855 2
a856 2
    int numChildren = 0;
    register WindowPtr pChild, pWin, pHead;
d861 3
a863 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->id, client,
					   SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
d878 1
a878 1
	childIDs = (Window *) ALLOCATE_LOCAL(numChildren * sizeof(Window));
d893 1
a893 1
	DEALLOCATE_LOCAL(childIDs);
d900 1
a900 1
ProcInternAtom(register ClientPtr client)
d929 1
a929 1
ProcGetAtomName(register ClientPtr client)
a954 4
#ifdef K5AUTH
extern int k5_bad();
#endif

d956 1
a956 191
ProcSetSelectionOwner(register ClientPtr client)
{
    WindowPtr pWin;
    TimeStamp time;
    REQUEST(xSetSelectionOwnerReq);

    REQUEST_SIZE_MATCH(xSetSelectionOwnerReq);
    UpdateCurrentTime();
    time = ClientTimeToServerTime(stuff->time);

    /* If the client's time stamp is in the future relative to the server's
	time stamp, do not set the selection, just return success. */
    if (CompareTimeStamps(time, currentTime) == LATER)
    	return Success;
    if (stuff->window != None)
    {
        pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					       SecurityReadAccess);
        if (!pWin)
            return(BadWindow);
    }
    else
        pWin = (WindowPtr)None;
    if (ValidAtom(stuff->selection))
    {
	int i = 0;

	/*
	 * First, see if the selection is already set... 
	 */
	while ((i < NumCurrentSelections) && 
	       CurrentSelections[i].selection != stuff->selection) 
            i++;
        if (i < NumCurrentSelections)
        {        
	    xEvent event;

	    /* If the timestamp in client's request is in the past relative
		to the time stamp indicating the last time the owner of the
		selection was set, do not set the selection, just return 
		success. */
            if (CompareTimeStamps(time, CurrentSelections[i].lastTimeChanged)
		== EARLIER)
		return Success;
	    if (CurrentSelections[i].client &&
		(!pWin || (CurrentSelections[i].client != client)))
	    {
		event.u.u.type = SelectionClear;
		event.u.selectionClear.time = time.milliseconds;
		event.u.selectionClear.window = CurrentSelections[i].window;
		event.u.selectionClear.atom = CurrentSelections[i].selection;
		(void) TryClientEvents (CurrentSelections[i].client, &event, 1,
				NoEventMask, NoEventMask /* CantBeFiltered */,
				NullGrab);
	    }
	}
	else
	{
	    /*
	     * It doesn't exist, so add it...
	     */
	    Selection *newsels;

	    if (i == 0)
		newsels = (Selection *)xalloc(sizeof(Selection));
	    else
		newsels = (Selection *)xrealloc(CurrentSelections,
			    (NumCurrentSelections + 1) * sizeof(Selection));
	    if (!newsels)
		return BadAlloc;
	    NumCurrentSelections++;
	    CurrentSelections = newsels;
	    CurrentSelections[i].selection = stuff->selection;
	}
        CurrentSelections[i].lastTimeChanged = time;
	CurrentSelections[i].window = stuff->window;
	CurrentSelections[i].pWin = pWin;
	CurrentSelections[i].client = (pWin ? client : NullClient);
	if (SelectionCallback)
	{
	    SelectionInfoRec	info;

	    info.selection = &CurrentSelections[i];
	    info.kind= SelectionSetOwner;
	    CallCallbacks(&SelectionCallback, &info);
	}
	return (client->noClientException);
    }
    else 
    {
	client->errorValue = stuff->selection;
        return (BadAtom);
    }
}

int
ProcGetSelectionOwner(register ClientPtr client)
{
    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    if (ValidAtom(stuff->id))
    {
	int i;
        xGetSelectionOwnerReply reply;

	i = 0;
        while ((i < NumCurrentSelections) && 
	       CurrentSelections[i].selection != stuff->id) i++;
        reply.type = X_Reply;
	reply.length = 0;
	reply.sequenceNumber = client->sequence;
        if (i < NumCurrentSelections)
            reply.owner = CurrentSelections[i].window;
        else
            reply.owner = None;
        WriteReplyToClient(client, sizeof(xGetSelectionOwnerReply), &reply);
        return(client->noClientException);
    }
    else            
    {
	client->errorValue = stuff->id;
        return (BadAtom); 
    }
}

int
ProcConvertSelection(register ClientPtr client)
{
    Bool paramsOkay;
    xEvent event;
    WindowPtr pWin;
    REQUEST(xConvertSelectionReq);

    REQUEST_SIZE_MATCH(xConvertSelectionReq);
    pWin = (WindowPtr)SecurityLookupWindow(stuff->requestor, client,
					   SecurityReadAccess);
    if (!pWin)
        return(BadWindow);

    paramsOkay = (ValidAtom(stuff->selection) && ValidAtom(stuff->target));
    if (stuff->property != None)
	paramsOkay &= ValidAtom(stuff->property);
    if (paramsOkay)
    {
	int i;

	i = 0;
	while ((i < NumCurrentSelections) && 
	       CurrentSelections[i].selection != stuff->selection) i++;
	if ((i < NumCurrentSelections) && 
	    (CurrentSelections[i].window != None)
#ifdef XACE
	    && XaceHook(XACE_RESOURCE_ACCESS, client,
			CurrentSelections[i].window, RT_WINDOW,
			SecurityReadAccess, CurrentSelections[i].pWin)
#endif
	    )
	{        
	    event.u.u.type = SelectionRequest;
	    event.u.selectionRequest.time = stuff->time;
	    event.u.selectionRequest.owner = 
			CurrentSelections[i].window;
	    event.u.selectionRequest.requestor = stuff->requestor;
	    event.u.selectionRequest.selection = stuff->selection;
	    event.u.selectionRequest.target = stuff->target;
	    event.u.selectionRequest.property = stuff->property;
	    if (TryClientEvents(
		CurrentSelections[i].client, &event, 1, NoEventMask,
		NoEventMask /* CantBeFiltered */, NullGrab))
		return (client->noClientException);
	}
	event.u.u.type = SelectionNotify;
	event.u.selectionNotify.time = stuff->time;
	event.u.selectionNotify.requestor = stuff->requestor;
	event.u.selectionNotify.selection = stuff->selection;
	event.u.selectionNotify.target = stuff->target;
	event.u.selectionNotify.property = None;
	(void) TryClientEvents(client, &event, 1, NoEventMask,
			       NoEventMask /* CantBeFiltered */, NullGrab);
	return (client->noClientException);
    }
    else 
    {
	client->errorValue = stuff->property;
        return (BadAtom);
    }
}

int
ProcGrabServer(register ClientPtr client)
d958 1
d968 3
a970 1
    OnlyListenToOneClient(client);
d1013 1
a1013 1
ProcUngrabServer(register ClientPtr client)
d1021 1
a1021 1
ProcTranslateCoords(register ClientPtr client)
d1025 1
a1025 1
    register WindowPtr pWin, pDst;
d1027 1
d1030 6
a1035 8
    pWin = (WindowPtr)SecurityLookupWindow(stuff->srcWid, client,
					   SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
    pDst = (WindowPtr)SecurityLookupWindow(stuff->dstWid, client,
					   SecurityReadAccess);
    if (!pDst)
        return(BadWindow);
d1098 1
a1098 1
ProcOpenFont(register ClientPtr client)
d1117 1
a1117 1
ProcCloseFont(register ClientPtr client)
d1124 1
a1124 1
					    SecurityDestroyAccess);
d1138 1
a1138 1
ProcQueryFont(register ClientPtr client)
d1142 2
a1143 1
    register GC *pGC;
d1145 1
a1146 1
    REQUEST_SIZE_MATCH(xResourceReq);
d1148 7
a1154 13
    pFont = (FontPtr)SecurityLookupIDByType(client, stuff->id, RT_FONT,
					    SecurityReadAccess);
    if (!pFont)
    {
	  /* can't use VERIFY_GC because it might return BadGC */
	pGC = (GC *) SecurityLookupIDByType(client, stuff->id, RT_GC,
					    SecurityReadAccess);
        if (!pGC)
	{
	    client->errorValue = stuff->id;
            return(BadFont);     /* procotol spec says only error is BadFont */
	}
	pFont = pGC->font;
d1156 2
d1176 1
a1176 1
	reply = (xQueryFontReply *)ALLOCATE_LOCAL(rlength);
d1188 1
a1188 1
	DEALLOCATE_LOCAL(reply);
d1194 1
a1194 1
ProcQueryTextExtents(register ClientPtr client)
a1195 1
    REQUEST(xQueryTextExtentsReq);
d1201 2
a1202 1

d1205 8
a1212 12
    pFont = (FontPtr)SecurityLookupIDByType(client, stuff->fid, RT_FONT,
					    SecurityReadAccess);
    if (!pFont)
    {
        pGC = (GC *)SecurityLookupIDByType(client, stuff->fid, RT_GC,
					   SecurityReadAccess);
        if (!pGC)
	{
	    client->errorValue = stuff->fid;
            return(BadFont);
	}
	pFont = pGC->font;
d1214 3
d1243 1
a1243 1
ProcListFonts(register ClientPtr client)
d1254 1
a1254 1
ProcListFontsWithInfo(register ClientPtr client)
d1276 1
a1276 1
ProcCreatePixmap(register ClientPtr client)
d1279 1
a1279 1
    register DrawablePtr pDraw;
d1282 1
a1282 1
    register int i;
d1287 6
a1292 2
    SECURITY_VERIFY_GEOMETRABLE (pDraw, stuff->drawable, client,
				 SecurityReadAccess);
d1327 1
a1327 1
		 stuff->height, stuff->depth);
d1332 7
d1341 1
d1347 1
a1347 1
ProcFreePixmap(register ClientPtr client)
d1350 1
a1350 1

d1352 1
d1354 3
a1356 4
    REQUEST_SIZE_MATCH(xResourceReq);
    pMap = (PixmapPtr)SecurityLookupIDByType(client, stuff->id, RT_PIXMAP,
					     SecurityDestroyAccess);
    if (pMap) 
d1364 1
a1364 1
	return (BadPixmap);
d1369 1
a1369 1
ProcCreateGC(register ClientPtr client)
d1371 1
a1371 1
    int error;
d1373 1
a1373 1
    register DrawablePtr pDraw;
d1380 5
a1384 2
    SECURITY_VERIFY_DRAWABLE (pDraw, stuff->drawable, client,
			      SecurityReadAccess);
d1388 2
a1389 2
    pGC = (GC *)CreateGC(pDraw, stuff->mask, 
			 (XID *) &stuff[1], &error);
d1398 1
a1398 1
ProcChangeGC(register ClientPtr client)
a1400 1
    REQUEST(xChangeGCReq);
d1403 1
a1403 1
		
d1405 5
a1409 1
    SECURITY_VERIFY_GC(pGC, stuff->gc, client, SecurityWriteAccess);
d1425 1
a1425 1
ProcCopyGC(register ClientPtr client)
d1427 2
a1428 2
    register GC *dstGC;
    register GC *pGC;
d1431 1
d1433 6
a1438 3
    REQUEST_SIZE_MATCH(xCopyGCReq);
    SECURITY_VERIFY_GC( pGC, stuff->srcGC, client, SecurityReadAccess);
    SECURITY_VERIFY_GC( dstGC, stuff->dstGC, client, SecurityWriteAccess);
d1452 1
a1452 1
ProcSetDashes(register ClientPtr client)
d1454 1
a1454 1
    register GC *pGC;
d1465 3
a1467 1
    SECURITY_VERIFY_GC(pGC,stuff->gc, client, SecurityWriteAccess);
d1481 1
a1481 1
ProcSetClipRectangles(register ClientPtr client)
d1483 2
a1484 3
    int	nr;
    int result;
    register GC *pGC;
d1494 3
a1496 1
    SECURITY_VERIFY_GC(pGC,stuff->gc, client, SecurityWriteAccess);
d1511 1
a1511 1
ProcFreeGC(register ClientPtr client)
d1513 2
a1514 1
    register GC *pGC;
d1516 5
a1521 2
    REQUEST_SIZE_MATCH(xResourceReq);
    SECURITY_VERIFY_GC(pGC, stuff->id, client, SecurityDestroyAccess);
d1527 1
a1527 1
ProcClearToBackground(register ClientPtr client)
d1530 2
a1531 1
    register WindowPtr pWin;
d1534 3
a1536 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityWriteAccess);
    if (!pWin)
        return(BadWindow);
d1554 1
a1554 1
ProcCopyArea(register ClientPtr client)
d1556 3
a1558 3
    register DrawablePtr pDst;
    register DrawablePtr pSrc;
    register GC *pGC;
d1561 1
d1565 1
a1565 1
    VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pDst, pGC, client); 
d1568 4
a1571 2
	SECURITY_VERIFY_DRAWABLE(pSrc, stuff->srcDrawable, client,
				 SecurityReadAccess);
a1580 2
    SET_DBE_SRCBUF(pSrc, stuff->srcDrawable);

d1596 1
a1596 1
ProcCopyPlane(register ClientPtr client)
d1598 2
a1599 2
    register DrawablePtr psrcDraw, pdstDraw;
    register GC *pGC;
d1602 1
d1606 1
a1606 1
    VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pdstDraw, pGC, client);
d1609 5
a1613 2
	SECURITY_VERIFY_DRAWABLE(psrcDraw, stuff->srcDrawable, client,
				 SecurityReadAccess);
a1622 2
    SET_DBE_SRCBUF(psrcDraw, stuff->srcDrawable);

d1645 1
a1645 1
ProcPolyPoint(register ClientPtr client)
d1648 2
a1649 2
    register GC *pGC;
    register DrawablePtr pDraw;
d1659 1
a1659 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client); 
d1668 1
a1668 1
ProcPolyLine(register ClientPtr client)
d1671 2
a1672 2
    register GC *pGC;
    register DrawablePtr pDraw;
d1682 1
a1682 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d1691 1
a1691 1
ProcPolySegment(register ClientPtr client)
d1694 2
a1695 2
    register GC *pGC;
    register DrawablePtr pDraw;
d1699 1
a1699 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d1710 1
a1710 1
ProcPolyRectangle (register ClientPtr client)
d1713 2
a1714 2
    register GC *pGC;
    register DrawablePtr pDraw;
d1718 1
a1718 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d1730 1
a1730 1
ProcPolyArc(register ClientPtr client)
d1733 2
a1734 2
    register GC *pGC;
    register DrawablePtr pDraw;
d1738 1
a1738 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d1749 1
a1749 1
ProcFillPoly(register ClientPtr client)
d1752 2
a1753 2
    register GC *pGC;
    register DrawablePtr pDraw;
d1770 1
a1770 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d1780 1
a1780 1
ProcPolyFillRectangle(register ClientPtr client)
d1783 2
a1784 2
    register GC *pGC;
    register DrawablePtr pDraw;
d1788 1
a1788 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d1801 1
a1801 1
ProcPolyFillArc(register ClientPtr client)
d1804 2
a1805 2
    register GC *pGC;
    register DrawablePtr pDraw;
d1809 1
a1809 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d1874 1
a1874 1
ProcPutImage(register ClientPtr client)
d1876 2
a1877 2
    register	GC *pGC;
    register	DrawablePtr pDraw;
d1884 1
a1884 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d1930 2
a1931 3

int
DoGetImage(register ClientPtr client, int format, Drawable drawable, 
d1935 3
a1937 3
    register DrawablePtr pDraw;
    int			nlines, linesPerBuf;
    register int	linesDone;
a1941 1
#ifdef XACE
a1942 1
#endif
d1949 4
a1952 1
    SECURITY_VERIFY_DRAWABLE(pDraw, drawable, client, SecurityReadAccess);
a1981 2
    SET_DBE_SRCBUF(pDraw, drawable);

d2042 1
a2042 1
	if(!(pBuf = (char *) ALLOCATE_LOCAL(length)))
d2047 1
a2047 3
#ifdef XACE
    if (pDraw->type == DRAWABLE_WINDOW &&
	!XaceHook(XACE_DRAWABLE_ACCESS, client, pDraw))
d2052 2
a2053 1
	    REGION_TRANSLATE(pDraw->pScreen, pVisibleRegion, -pDraw->x, -pDraw->y);
a2055 1
#endif
a2074 1
#ifdef XACE
a2078 1
#endif
a2113 1
#ifdef XACE
a2118 1
#endif
a2139 1
#ifdef XACE
a2141 1
#endif
d2143 1
a2143 1
	DEALLOCATE_LOCAL(pBuf);
d2148 1
a2148 1
ProcGetImage(register ClientPtr client)
d2161 1
a2161 1
ProcPolyText(register ClientPtr client)
d2169 1
a2169 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d2190 1
a2190 1
ProcImageText8(register ClientPtr client)
d2193 2
a2194 2
    register DrawablePtr pDraw;
    register GC *pGC;
d2199 1
a2199 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d2220 1
a2220 1
ProcImageText16(register ClientPtr client)
d2223 2
a2224 2
    register DrawablePtr pDraw;
    register GC *pGC;
d2229 1
a2229 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d2251 1
a2251 1
ProcCreateColormap(register ClientPtr client)
d2256 1
a2256 1
    register WindowPtr   pWin;
d2270 3
a2272 4
    pWin = (WindowPtr)SecurityLookupWindow(stuff->window, client,
					   SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
d2293 1
a2293 1
ProcFreeColormap(register ClientPtr client)
d2296 1
d2300 3
a2302 3
    pmap = (ColormapPtr )SecurityLookupIDByType(client, stuff->id, RT_COLORMAP,
						SecurityDestroyAccess);
    if (pmap) 
d2312 1
a2312 1
	return (BadColor);
d2318 1
a2318 1
ProcCopyColormapAndFree(register ClientPtr client)
d2323 1
a2323 1
    int result;
d2328 3
a2330 2
    if( (pSrcMap = (ColormapPtr )SecurityLookupIDByType(client,	stuff->srcCmap,
		RT_COLORMAP, SecurityReadAccess|SecurityWriteAccess)) )
d2332 1
a2332 1
	result = CopyColormapAndFree(mid, pSrcMap, client->index);
d2336 1
a2336 1
            return(result);
d2341 1
a2341 1
	return(BadColor);
d2346 1
a2346 1
ProcInstallColormap(register ClientPtr client)
d2349 1
d2351 1
d2353 15
a2367 13
    REQUEST_SIZE_MATCH(xResourceReq);
    pcmp = (ColormapPtr)SecurityLookupIDByType(client, stuff->id,
					    RT_COLORMAP, SecurityReadAccess);
    if (pcmp)
    {
        (*(pcmp->pScreen->InstallColormap)) (pcmp);
        return (client->noClientException);        
    }
    else
    {
        client->errorValue = stuff->id;
        return (BadColor);
    }
d2371 1
a2371 1
ProcUninstallColormap(register ClientPtr client)
d2374 1
d2376 1
d2378 16
a2393 14
    REQUEST_SIZE_MATCH(xResourceReq);
    pcmp = (ColormapPtr)SecurityLookupIDByType(client, stuff->id,
					RT_COLORMAP, SecurityReadAccess);
    if (pcmp)
    {
	if(pcmp->mid != pcmp->pScreen->defColormap)
            (*(pcmp->pScreen->UninstallColormap)) (pcmp);
        return (client->noClientException);        
    }
    else
    {
        client->errorValue = stuff->id;
        return (BadColor);
    }
d2397 1
a2397 1
ProcListInstalledColormaps(register ClientPtr client)
d2400 1
a2400 1
    int nummaps;
a2402 1

a2403 2
    pWin = (WindowPtr)SecurityLookupWindow(stuff->id, client,
					   SecurityReadAccess);
d2405 8
a2412 2
    if (!pWin)
        return(BadWindow);
d2415 1
a2415 1
		ALLOCATE_LOCAL(sizeof(xListInstalledColormapsReply) +
d2430 4
a2433 2
    DEALLOCATE_LOCAL(preply);
    return(client->noClientException);
d2437 1
a2437 1
ProcAllocColor (register ClientPtr client)
d2440 1
a2440 1
    int	retval;
d2445 3
a2447 3
    pmap = (ColormapPtr)SecurityLookupIDByType(client, stuff->cmap,
					RT_COLORMAP, SecurityWriteAccess);
    if (pmap)
d2456 1
a2456 1
	if( (retval = AllocColor(pmap, &acr.red, &acr.green, &acr.blue,
d2462 1
a2462 1
	        return (retval);
d2474 1
a2474 1
        return (BadColor);
d2479 1
a2479 1
ProcAllocNamedColor (register ClientPtr client)
d2482 1
d2486 3
a2488 3
    pcmp = (ColormapPtr)SecurityLookupIDByType(client, stuff->cmap,
					    RT_COLORMAP, SecurityWriteAccess);
    if (pcmp)
a2489 2
	int		retval;

d2503 1
a2503 1
	    if( (retval = AllocColor(pcmp,
d2510 1
a2510 1
    	            return(retval);
d2525 1
a2525 1
        return (BadColor);
d2530 1
a2530 1
ProcAllocColorCells (register ClientPtr client)
d2533 1
d2537 3
a2539 3
    pcmp = (ColormapPtr)SecurityLookupIDByType(client, stuff->cmap,
					RT_COLORMAP, SecurityWriteAccess);
    if (pcmp)
d2542 1
a2542 1
	int			npixels, nmasks, retval;
d2559 1
a2559 1
	ppixels = (Pixel *)ALLOCATE_LOCAL(length);
d2564 1
a2564 1
	if( (retval = AllocColorCells(client->index, pcmp, npixels, nmasks, 
d2567 1
a2567 1
	    DEALLOCATE_LOCAL(ppixels);
d2571 1
a2571 1
	        return(retval);
d2586 1
a2586 1
	DEALLOCATE_LOCAL(ppixels);
d2592 1
a2592 1
        return (BadColor);
d2597 1
a2597 1
ProcAllocColorPlanes(register ClientPtr client)
d2600 1
d2604 3
a2606 3
    pcmp = (ColormapPtr)SecurityLookupIDByType(client, stuff->cmap,
					RT_COLORMAP, SecurityWriteAccess);
    if (pcmp)
d2609 1
a2609 1
	int			npixels, retval;
d2628 1
a2628 1
	ppixels = (Pixel *)ALLOCATE_LOCAL(length);
d2631 1
a2631 1
	if( (retval = AllocColorPlanes(client->index, pcmp, npixels,
d2636 1
a2636 1
            DEALLOCATE_LOCAL(ppixels);
d2640 1
a2640 1
	        return(retval);
d2651 1
a2651 1
	DEALLOCATE_LOCAL(ppixels);
d2657 1
a2657 1
        return (BadColor);
d2662 1
a2662 1
ProcFreeColors(register ClientPtr client)
d2665 1
d2669 3
a2671 3
    pcmp = (ColormapPtr)SecurityLookupIDByType(client, stuff->cmap,
					RT_COLORMAP, SecurityWriteAccess);
    if (pcmp)
a2673 1
        int     retval;
d2678 1
a2678 1
	retval =  FreeColors(pcmp, client->index, count,
d2685 1
a2685 1
            return(retval);
d2692 1
a2692 1
        return (BadColor);
d2700 1
d2704 3
a2706 3
    pcmp = (ColormapPtr)SecurityLookupIDByType(client, stuff->cmap,
					RT_COLORMAP, SecurityWriteAccess);
    if (pcmp)
a2708 1
        int     retval;
d2714 1
a2714 1
	retval = StoreColors(pcmp, count, (xColorItem *)&stuff[1]);
d2720 1
a2720 1
            return(retval);
d2726 1
a2726 1
        return (BadColor);
d2731 1
a2731 1
ProcStoreNamedColor (register ClientPtr client)
d2734 1
d2738 3
a2740 3
    pcmp = (ColormapPtr)SecurityLookupIDByType(client, stuff->cmap,
					RT_COLORMAP, SecurityWriteAccess);
    if (pcmp)
a2742 1
        int             retval;
d2749 1
a2749 1
	    retval = StoreColors(pcmp, 1, &def);
d2753 1
a2753 1
		return(retval);
d2760 1
a2760 1
        return (BadColor);
d2765 1
a2765 1
ProcQueryColors(register ClientPtr client)
d2768 1
d2772 3
a2774 3
    pcmp = (ColormapPtr)SecurityLookupIDByType(client, stuff->cmap,
					RT_COLORMAP, SecurityReadAccess);
    if (pcmp)
d2776 1
a2776 1
	int			count, retval;
d2781 1
a2781 1
	prgbs = (xrgb *)ALLOCATE_LOCAL(count * sizeof(xrgb));
d2784 1
a2784 1
	if( (retval = QueryColors(pcmp, count, (Pixel *)&stuff[1], prgbs)) )
d2786 1
a2786 1
   	    if (prgbs) DEALLOCATE_LOCAL(prgbs);
d2792 1
a2792 1
	        return (retval);
d2805 1
a2805 1
	if (prgbs) DEALLOCATE_LOCAL(prgbs);
d2812 1
a2812 1
        return (BadColor);
d2817 1
a2817 1
ProcLookupColor(register ClientPtr client)
d2820 1
d2824 3
a2826 3
    pcmp = (ColormapPtr)SecurityLookupIDByType(client, stuff->cmap,
					RT_COLORMAP, SecurityReadAccess);
    if (pcmp)
d2851 1
a2851 1
        return (BadColor);
d2856 1
a2856 1
ProcCreateCursor (register ClientPtr client)
d2858 3
a2860 4
    CursorPtr	pCursor;

    register PixmapPtr 	src;
    register PixmapPtr 	msk;
d2865 2
a2866 2
    CursorMetricRec cm;

d2873 3
a2875 6
    src = (PixmapPtr)SecurityLookupIDByType(client, stuff->source,
					      RT_PIXMAP, SecurityReadAccess);
    msk = (PixmapPtr)SecurityLookupIDByType(client, stuff->mask,
					      RT_PIXMAP, SecurityReadAccess);
    if (   src == (PixmapPtr)NULL)
    {
d2877 1
a2877 1
	return (BadPixmap);
d2879 4
a2882 1
    if ( msk == (PixmapPtr)NULL)
d2887 1
a2887 1
	    return (BadPixmap);
d2920 1
a2920 1
	register unsigned char *bits = mskbits;
d2935 9
a2943 3
    pCursor = AllocCursor( srcbits, mskbits, &cm,
	    stuff->foreRed, stuff->foreGreen, stuff->foreBlue,
	    stuff->backRed, stuff->backGreen, stuff->backBlue);
d2945 1
a2945 3
    if (pCursor && AddResource(stuff->cid, RT_CURSOR, (pointer)pCursor))
	    return (client->noClientException);
    return BadAlloc;
d2949 1
a2949 1
ProcCreateGlyphCursor (register ClientPtr client)
d2963 1
a2963 1
			   &pCursor, client);
d2973 1
a2973 1
ProcFreeCursor (register ClientPtr client)
d2976 1
d2980 3
a2982 3
    pCursor = (CursorPtr)SecurityLookupIDByType(client, stuff->id,
					RT_CURSOR, SecurityDestroyAccess);
    if (pCursor) 
d2990 1
a2990 1
	return (BadCursor);
d2995 1
a2995 1
ProcQueryBestSize (register ClientPtr client)
d2998 1
a2998 1
    register DrawablePtr pDraw;
d3000 1
d3002 1
a3003 1
    REQUEST_SIZE_MATCH(xQueryBestSizeReq);
d3011 5
a3015 2
    SECURITY_VERIFY_GEOMETRABLE (pDraw, stuff->drawable, client,
				 SecurityReadAccess);
d3019 3
d3035 1
a3035 1
ProcSetScreenSaver (register ClientPtr client)
d3037 1
a3037 1
    int blankingOption, exposureOption;
d3039 8
a3047 1
    REQUEST_SIZE_MATCH(xSetScreenSaverReq);
d3098 1
a3098 1
ProcGetScreenSaver(register ClientPtr client)
d3101 9
a3110 1
    REQUEST_SIZE_MATCH(xReq);
d3123 1
a3123 1
ProcChangeHosts(register ClientPtr client)
d3147 1
a3147 1
ProcListHosts(register ClientPtr client)
d3155 1
a3155 1
#ifdef XACE
d3157 4
a3160 5
    if (!XaceHook(XACE_HOSTLIST_ACCESS, client, SecurityReadAccess))
    {
	return BadAccess;
    }
#endif
d3179 1
a3179 1
ProcChangeAccessControl(register ClientPtr client)
d3196 22
d3219 1
a3219 1
ProcKillClient(register ClientPtr client)
d3222 2
a3223 1
    ClientPtr	killclient;
d3232 2
a3233 2
    if ((killclient = LookupClient(stuff->id, client)))
    {
d3247 1
a3247 4
    {
	client->errorValue = stuff->id;
	return (BadValue);
    }
d3251 1
a3251 1
ProcSetFontPath(register ClientPtr client)
d3286 1
a3286 1
ProcGetFontPath(register ClientPtr client)
d3289 1
a3289 1
    int stringLens, numpaths;
d3294 3
a3296 1
    bufferStart = GetFontPath(&numpaths, &stringLens);
d3310 1
a3310 1
ProcChangeCloseDownMode(register ClientPtr client)
d3312 1
d3314 5
a3319 1
    REQUEST_SIZE_MATCH(xSetCloseDownModeReq);
d3334 1
a3334 1
int ProcForceScreenSaver(register ClientPtr client)
d3336 1
d3347 3
a3349 1
    SaveScreens(SCREEN_SAVER_FORCER, (int)stuff->mode);
d3353 1
a3353 1
int ProcNoOperation(register ClientPtr client)
a3371 6
#ifdef K5AUTH
	if (!k5_Vector[i])
	{
	    k5_Vector[i] = k5_bad;
	}
#endif
d3390 1
a3390 1
CloseDownClient(register ClientPtr client)
d3462 3
d3471 1
d3480 1
a3480 1
KillAllClients()
a3490 26
/*********************
 * CloseDownRetainedResources
 *
 *    Find all clients that are gone and have terminated in RetainTemporary 
 *    and  destroy their resources.
 *********************/

void
CloseDownRetainedResources()
{
    register int i;
    register ClientPtr client;

    for (i=1; i<currentMaxClients; i++)
    {
        client = clients[i];
        if (client && (client->closeDownMode == RetainTemporary)
	    && (client->clientGone))
	    CloseDownClient(client);
    }
}

extern int clientPrivateLen;
extern unsigned *clientPrivateSizes;
extern unsigned totalClientSize;

d3497 1
a3497 14
    if (i)
    {
	client->closeDownMode = DestroyAll;
	client->lastDrawable = (DrawablePtr)WindowTable[0];
	client->lastDrawableID = WindowTable[0]->drawable.id;
    }
    else
    {
	client->closeDownMode = RetainPermanent;
	client->lastDrawable = (DrawablePtr)NULL;
	client->lastDrawableID = INVALID;
    }
    client->lastGC = (GCPtr) NULL;
    client->lastGCID = INVALID;
d3510 1
a3530 46
int
InitClientPrivates(ClientPtr client)
{
    register char *ptr;
    DevUnion *ppriv;
    register unsigned *sizes;
    register unsigned size;
    register int i;

    if (totalClientSize == sizeof(ClientRec))
	ppriv = (DevUnion *)NULL;
    else if (client->index)
	ppriv = (DevUnion *)(client + 1);
    else
    {
	ppriv = (DevUnion *)xalloc(totalClientSize - sizeof(ClientRec));
	if (!ppriv)
	    return 0;
    }
    client->devPrivates = ppriv;
    sizes = clientPrivateSizes;
    ptr = (char *)(ppriv + clientPrivateLen);
    for (i = clientPrivateLen; --i >= 0; ppriv++, sizes++)
    {
	if ( (size = *sizes) )
	{
	    ppriv->ptr = (pointer)ptr;
	    ptr += size;
	}
	else
	    ppriv->ptr = (pointer)NULL;
    }

    /* Allow registrants to initialize the serverClient devPrivates */
    if (!client->index && ClientStateCallback)
    {
	NewClientInfoRec clientinfo;

	clientinfo.client = client; 
	clientinfo.prefix = (xConnSetupPrefix *)NULL;  
	clientinfo.setup = (xConnSetup *) NULL;
	CallCallbacks((&ClientStateCallback), (pointer)&clientinfo);
    } 
    return 1;
}

d3540 2
a3541 2
    register int i;
    register ClientPtr client;
d3547 1
a3547 1
    clients[i] = client = (ClientPtr)xalloc(totalClientSize);
a3550 1
    InitClientPrivates(client);
d3581 1
a3581 1
ProcInitialConnection(register ClientPtr client)
d3584 1
a3584 1
    register xConnClientPrefix *prefix;
d3607 2
a3608 2
int
SendConnSetup(register ClientPtr client, char *reason)
d3610 2
a3611 2
    register xWindowRoot *root;
    register int i;
d3666 2
a3667 2
	register unsigned int j;
	register xDepth *pDepth;
d3708 1
a3708 1
ProcEstablishConnection(register ClientPtr client)
d3711 1
a3711 1
    register xConnClientPrefix *prefix;
a3754 44
}

void
DeleteWindowFromAnySelections(WindowPtr pWin)
{
    register int i;

    for (i = 0; i< NumCurrentSelections; i++)
        if (CurrentSelections[i].pWin == pWin)
        {
	    if (SelectionCallback)
	    {
	        SelectionInfoRec    info;

		info.selection = &CurrentSelections[i];
		info.kind = SelectionWindowDestroy;
		CallCallbacks(&SelectionCallback, &info);
	    }
            CurrentSelections[i].pWin = (WindowPtr)NULL;
            CurrentSelections[i].window = None;
	    CurrentSelections[i].client = NullClient;
	}
}

static void
DeleteClientFromAnySelections(ClientPtr client)
{
    register int i;

    for (i = 0; i< NumCurrentSelections; i++)
        if (CurrentSelections[i].client == client)
        {
	    if (SelectionCallback)
	    {
	        SelectionInfoRec    info;

		info.selection = &CurrentSelections[i];
		info.kind = SelectionWindowDestroy;
		CallCallbacks(&SelectionCallback, &info);
	    }
            CurrentSelections[i].pWin = (WindowPtr)NULL;
            CurrentSelections[i].window = None;
	    CurrentSelections[i].client = NullClient;
	}
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a76 30
/* XSERVER_DTRACE additions:
 * Copyright 2005-2006 Sun Microsystems, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
 */


d107 1
d109 1
d118 1
a118 12
#include <xkbsrv.h>
#endif

#ifdef XSERVER_DTRACE
#include <sys/types.h>
typedef const char *string;
#include "Xserver-dtrace.h"

char *RequestNames[256];
static void LoadRequestNames(void);
static void FreeRequestNames(void);
#define GetRequestName(i) (RequestNames[i])
d182 1
a182 1
UpdateCurrentTime(void)
d201 1
a201 1
UpdateCurrentTimeIf(void)
d214 1
a214 1
InitSelections(void)
d226 1
a226 1
    ClientPtr client;
d261 3
a263 2
static ClientPtr   SmartLastClient;
static int	   SmartLastIndex[SMART_MAX_PRIORITY-SMART_MIN_PRIORITY+1];
d272 1
a272 1
static int
d358 5
a362 5
    int        *clientReady;     /* array of request ready clients */
    int	result;
    ClientPtr	client;
    int	nready;
    HWEventQueuePtr* icheck = checkForInput;
a374 4
#ifdef XSERVER_DTRACE
    LoadRequestNames();
#endif

a450 5
#ifdef XSERVER_DTRACE
		XSERVER_REQUEST_START(GetRequestName(MAJOROP), MAJOROP,
			      ((xReq *)client->requestBuffer)->length,
			      client->index, client->requestBuffer);
#endif
d453 3
a455 1
		else {
d460 4
a463 5
#ifdef XSERVER_DTRACE
		XSERVER_REQUEST_DONE(GetRequestName(MAJOROP), MAJOROP,
			      client->sequence, client->index, result);
#endif

a493 3
#ifdef XSERVER_DTRACE
    FreeRequestNames();
#endif
d507 1
a507 1
    WindowPtr pParent, pWin;
d509 2
a510 1
    int result, len, rc;
d515 3
a517 3
    rc = dixLookupWindow(&pParent, stuff->parent, client, DixWriteAccess);
    if (rc != Success)
        return rc;
d548 1
a548 1
ProcChangeWindowAttributes(ClientPtr client)
d550 1
a550 1
    WindowPtr pWin;
d552 2
a553 2
    int result;
    int len, rc;
d556 4
a559 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (rc != Success)
        return rc;
d574 1
a574 1
ProcGetWindowAttributes(ClientPtr client)
d576 1
a576 1
    WindowPtr pWin;
a578 1
    int rc;
d581 4
a584 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixReadAccess);
    if (rc != Success)
	return rc;
d591 1
a591 1
ProcDestroyWindow(ClientPtr client)
d593 1
a593 1
    WindowPtr pWin;
a594 1
    int rc;
d597 4
a600 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixDestroyAccess);
    if (rc != Success)
	return rc;
d607 1
a607 1
ProcDestroySubwindows(ClientPtr client)
d609 1
a609 1
    WindowPtr pWin;
a610 1
    int rc;
d613 4
a616 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixDestroyAccess);
    if (rc != Success)
	return rc;
d622 1
a622 1
ProcChangeSaveSet(ClientPtr client)
d624 1
a624 1
    WindowPtr pWin;
d626 1
a626 1
    int result, rc;
d629 4
a632 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
    if (rc != Success)
        return rc;
d651 1
a651 1
ProcReparentWindow(ClientPtr client)
d653 1
a653 1
    WindowPtr pWin, pParent;
d655 1
a655 1
    int result, rc;
d658 8
a665 6
    rc = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (rc != Success)
        return rc;
    rc = dixLookupWindow(&pParent, stuff->parent, client, DixWriteAccess);
    if (rc != Success)
        return rc;
d686 1
a686 1
ProcMapWindow(ClientPtr client)
d688 1
a688 1
    WindowPtr pWin;
a689 1
    int rc;
d692 4
a695 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixReadAccess);
    if (rc != Success)
        return rc;
d702 1
a702 1
ProcMapSubwindows(ClientPtr client)
d704 1
a704 1
    WindowPtr pWin;
a705 1
    int rc;
d708 4
a711 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixReadAccess);
    if (rc != Success)
        return rc;
d718 1
a718 1
ProcUnmapWindow(ClientPtr client)
d720 1
a720 1
    WindowPtr pWin;
a721 1
    int rc;
d724 4
a727 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixReadAccess);
    if (rc != Success)
        return rc;
d734 1
a734 1
ProcUnmapSubwindows(ClientPtr client)
d736 1
a736 1
    WindowPtr pWin;
a737 1
    int rc;
d740 4
a743 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixReadAccess);
    if (rc != Success)
        return rc;
d749 1
a749 1
ProcConfigureWindow(ClientPtr client)
d751 1
a751 1
    WindowPtr pWin;
d753 2
a754 2
    int result;
    int len, rc;
d757 4
a760 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (rc != Success)
        return rc;
d773 1
a773 1
ProcCirculateWindow(ClientPtr client)
d775 1
a775 1
    WindowPtr pWin;
a776 1
    int rc;
d785 4
a788 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (rc != Success)
        return rc;
d793 2
a794 2
static int
GetGeometry(ClientPtr client, xGetGeometryReply *rep)
d796 1
a796 2
    DrawablePtr pDraw;
    int rc;
d798 1
d800 1
a800 5

    rc = dixLookupDrawable(&pDraw, stuff->id, client, M_ANY, DixReadAccess);
    if (rc != Success)
	return rc;

d820 1
a820 1
        WindowPtr pWin = (WindowPtr)pDraw;
d835 1
a835 1
ProcGetGeometry(ClientPtr client)
d849 1
a849 1
ProcQueryTree(ClientPtr client)
d852 2
a853 2
    int rc, numChildren = 0;
    WindowPtr pChild, pWin, pHead;
d858 4
a861 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixReadAccess);
    if (rc != Success)
        return rc;
d898 1
a898 1
ProcInternAtom(ClientPtr client)
d927 1
a927 1
ProcGetAtomName(ClientPtr client)
d953 4
d958 1
a958 1
ProcSetSelectionOwner(ClientPtr client)
d974 4
a977 3
	int rc = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
        if (rc != Success)
            return rc;
d1054 1
a1054 1
ProcGetSelectionOwner(ClientPtr client)
d1085 1
a1085 1
ProcConvertSelection(ClientPtr client)
a1090 1
    int rc;
d1093 4
a1096 3
    rc = dixLookupWindow(&pWin, stuff->requestor, client, DixReadAccess);
    if (rc != Success)
        return rc;
d1108 8
a1115 5
	if ((i < NumCurrentSelections) &&
	    (CurrentSelections[i].window != None) &&
	    XaceHook(XACE_RESOURCE_ACCESS, client,
		     CurrentSelections[i].window, RT_WINDOW,
		     DixReadAccess, CurrentSelections[i].pWin))
d1148 1
a1148 1
ProcGrabServer(ClientPtr client)
d1202 1
a1202 1
ProcUngrabServer(ClientPtr client)
d1210 1
a1210 1
ProcTranslateCoords(ClientPtr client)
d1214 1
a1214 1
    WindowPtr pWin, pDst;
a1215 1
    int rc;
d1218 8
a1225 6
    rc = dixLookupWindow(&pWin, stuff->srcWid, client, DixReadAccess);
    if (rc != Success)
        return rc;
    rc = dixLookupWindow(&pDst, stuff->dstWid, client, DixReadAccess);
    if (rc != Success)
        return rc;
d1288 1
a1288 1
ProcOpenFont(ClientPtr client)
d1307 1
a1307 1
ProcCloseFont(ClientPtr client)
d1314 1
a1314 1
					    DixDestroyAccess);
d1328 1
a1328 1
ProcQueryFont(ClientPtr client)
d1332 1
a1332 1
    GC *pGC;
d1338 1
a1338 1
					    DixReadAccess);
d1341 1
d1343 1
a1343 1
					    DixReadAccess);
d1387 1
a1387 1
ProcQueryTextExtents(ClientPtr client)
d1399 1
a1399 1
					    DixReadAccess);
d1403 1
a1403 1
					   DixReadAccess);
d1437 1
a1437 1
ProcListFonts(ClientPtr client)
d1448 1
a1448 1
ProcListFontsWithInfo(ClientPtr client)
d1470 1
a1470 1
ProcCreatePixmap(ClientPtr client)
d1473 1
a1473 1
    DrawablePtr pDraw;
d1476 1
a1476 1
    int i, rc;
d1481 2
a1482 6
    
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
			   DixReadAccess);
    if (rc != Success)
	return rc;

d1529 1
a1529 1
ProcFreePixmap(ClientPtr client)
d1537 1
a1537 1
					     DixDestroyAccess);
d1551 1
a1551 1
ProcCreateGC(ClientPtr client)
d1553 1
a1553 1
    int error, rc;
d1555 1
a1555 1
    DrawablePtr pDraw;
d1562 2
a1563 4
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixReadAccess);
    if (rc != Success)
	return rc;

d1577 1
a1577 1
ProcChangeGC(ClientPtr client)
d1580 1
d1583 1
a1583 1
    REQUEST(xChangeGCReq);
d1585 1
a1585 5

    result = dixLookupGC(&pGC, stuff->gc, client, DixWriteAccess);
    if (result != Success)
	return result;

d1601 1
a1601 1
ProcCopyGC(ClientPtr client)
d1603 2
a1604 2
    GC *dstGC;
    GC *pGC;
d1607 1
d1609 2
a1610 7

    result = dixLookupGC(&pGC, stuff->srcGC, client, DixReadAccess);
    if (result != Success)
	return result;
    result = dixLookupGC(&dstGC, stuff->dstGC, client, DixWriteAccess);
    if (result != Success)
	return result;
d1624 1
a1624 1
ProcSetDashes(ClientPtr client)
d1626 1
a1626 1
    GC *pGC;
d1637 1
a1637 3
    result = dixLookupGC(&pGC,stuff->gc, client, DixWriteAccess);
    if (result != Success)
	return result;
d1651 1
a1651 1
ProcSetClipRectangles(ClientPtr client)
d1653 3
a1655 2
    int	nr, result;
    GC *pGC;
d1665 1
a1665 3
    result = dixLookupGC(&pGC,stuff->gc, client, DixWriteAccess);
    if (result != Success)
	return result;
d1680 1
a1680 1
ProcFreeGC(ClientPtr client)
d1682 1
a1682 2
    GC *pGC;
    int rc;
d1684 1
d1686 1
a1686 5

    rc = dixLookupGC(&pGC, stuff->id, client, DixDestroyAccess);
    if (rc != Success)
	return rc;

d1692 1
a1692 1
ProcClearToBackground(ClientPtr client)
d1695 1
a1695 2
    WindowPtr pWin;
    int rc;
d1698 4
a1701 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (rc != Success)
        return rc;
d1719 1
a1719 1
ProcCopyArea(ClientPtr client)
d1721 3
a1723 3
    DrawablePtr pDst;
    DrawablePtr pSrc;
    GC *pGC;
a1725 1
    int rc;
d1732 2
a1733 4
	rc = dixLookupDrawable(&pSrc, stuff->srcDrawable, client, 0,
				 DixReadAccess);
	if (rc != Success)
	    return rc;
d1743 2
d1760 1
a1760 1
ProcCopyPlane(ClientPtr client)
d1762 2
a1763 2
    DrawablePtr psrcDraw, pdstDraw;
    GC *pGC;
a1765 1
    int rc;
d1772 2
a1773 5
	rc = dixLookupDrawable(&psrcDraw, stuff->srcDrawable, client, 0,
			       DixReadAccess);
	if (rc != Success)
	    return rc;

d1783 2
d1807 1
a1807 1
ProcPolyPoint(ClientPtr client)
d1810 2
a1811 2
    GC *pGC;
    DrawablePtr pDraw;
d1830 1
a1830 1
ProcPolyLine(ClientPtr client)
d1833 2
a1834 2
    GC *pGC;
    DrawablePtr pDraw;
d1853 1
a1853 1
ProcPolySegment(ClientPtr client)
d1856 2
a1857 2
    GC *pGC;
    DrawablePtr pDraw;
d1872 1
a1872 1
ProcPolyRectangle (ClientPtr client)
d1875 2
a1876 2
    GC *pGC;
    DrawablePtr pDraw;
d1892 1
a1892 1
ProcPolyArc(ClientPtr client)
d1895 2
a1896 2
    GC *pGC;
    DrawablePtr pDraw;
d1911 1
a1911 1
ProcFillPoly(ClientPtr client)
d1914 2
a1915 2
    GC *pGC;
    DrawablePtr pDraw;
d1942 1
a1942 1
ProcPolyFillRectangle(ClientPtr client)
d1945 2
a1946 2
    GC *pGC;
    DrawablePtr pDraw;
d1963 1
a1963 1
ProcPolyFillArc(ClientPtr client)
d1966 2
a1967 2
    GC *pGC;
    DrawablePtr pDraw;
d2036 1
a2036 1
ProcPutImage(ClientPtr client)
d2038 2
a2039 2
    GC *pGC;
    DrawablePtr pDraw;
d2092 3
a2094 2
static int
DoGetImage(ClientPtr client, int format, Drawable drawable, 
d2098 3
a2100 3
    DrawablePtr		pDraw;
    int			nlines, linesPerBuf, rc;
    int	linesDone;
d2105 1
d2107 1
d2114 1
a2114 4
    rc = dixLookupDrawable(&pDraw, drawable, client, 0, DixReadAccess);
    if (rc != Success)
	return rc;

d2144 2
d2211 1
d2218 1
a2218 2
	    REGION_TRANSLATE(pDraw->pScreen, pVisibleRegion,
			     -pDraw->x, -pDraw->y);
d2221 1
d2241 1
d2246 1
d2282 1
d2288 1
d2310 1
d2313 1
d2320 1
a2320 1
ProcGetImage(ClientPtr client)
d2333 1
a2333 1
ProcPolyText(ClientPtr client)
d2362 1
a2362 1
ProcImageText8(ClientPtr client)
d2365 2
a2366 2
    DrawablePtr pDraw;
    GC *pGC;
d2392 1
a2392 1
ProcImageText16(ClientPtr client)
d2395 2
a2396 2
    DrawablePtr pDraw;
    GC *pGC;
d2423 1
a2423 1
ProcCreateColormap(ClientPtr client)
d2428 1
a2428 1
    WindowPtr   pWin;
d2442 4
a2445 3
    result = dixLookupWindow(&pWin, stuff->window, client, DixReadAccess);
    if (result != Success)
        return result;
d2466 1
a2466 1
ProcFreeColormap(ClientPtr client)
d2473 1
a2473 1
						DixDestroyAccess);
d2490 1
a2490 1
ProcCopyColormapAndFree(ClientPtr client)
d2501 1
a2501 1
		RT_COLORMAP, DixReadAccess|DixWriteAccess)) )
d2517 1
a2517 1
ProcInstallColormap(ClientPtr client)
d2524 1
a2524 1
					    RT_COLORMAP, DixReadAccess);
d2538 1
a2538 1
ProcUninstallColormap(ClientPtr client)
d2545 1
a2545 1
					RT_COLORMAP, DixReadAccess);
d2560 1
a2560 1
ProcListInstalledColormaps(ClientPtr client)
d2563 1
a2563 1
    int nummaps, rc;
d2568 5
a2572 3
    rc = dixLookupWindow(&pWin, stuff->id, client, DixReadAccess);
    if (rc != Success)
        return rc;
d2595 1
a2595 1
ProcAllocColor (ClientPtr client)
d2604 1
a2604 1
					RT_COLORMAP, DixWriteAccess);
d2637 1
a2637 1
ProcAllocNamedColor (ClientPtr client)
d2644 1
a2644 1
					    RT_COLORMAP, DixWriteAccess);
d2689 1
a2689 1
ProcAllocColorCells (ClientPtr client)
d2696 1
a2696 1
					RT_COLORMAP, DixWriteAccess);
d2755 1
a2755 1
ProcAllocColorPlanes(ClientPtr client)
d2762 1
a2762 1
					RT_COLORMAP, DixWriteAccess);
d2819 1
a2819 1
ProcFreeColors(ClientPtr client)
d2826 1
a2826 1
					RT_COLORMAP, DixWriteAccess);
d2861 1
a2861 1
					RT_COLORMAP, DixWriteAccess);
d2888 1
a2888 1
ProcStoreNamedColor (ClientPtr client)
d2895 1
a2895 1
					RT_COLORMAP, DixWriteAccess);
d2922 1
a2922 1
ProcQueryColors(ClientPtr client)
d2929 1
a2929 1
					RT_COLORMAP, DixReadAccess);
d2973 1
a2973 1
ProcLookupColor(ClientPtr client)
d2980 1
a2980 1
					RT_COLORMAP, DixReadAccess);
d3011 1
a3011 1
ProcCreateCursor (ClientPtr client)
d3013 4
a3016 3
    CursorPtr		pCursor;
    PixmapPtr 		src;
    PixmapPtr 		msk;
d3021 1
a3021 1
    CursorMetricRec 	cm;
d3030 1
a3030 1
					      RT_PIXMAP, DixReadAccess);
d3032 1
a3032 1
					      RT_PIXMAP, DixReadAccess);
d3076 1
a3076 1
	unsigned char *bits = mskbits;
d3101 1
a3101 1
ProcCreateGlyphCursor (ClientPtr client)
d3125 1
a3125 1
ProcFreeCursor (ClientPtr client)
d3132 1
a3132 1
					RT_CURSOR, DixDestroyAccess);
d3146 1
a3146 1
ProcQueryBestSize (ClientPtr client)
d3149 1
a3149 1
    DrawablePtr pDraw;
a3150 1
    int rc;
d3152 1
a3153 1

d3161 2
a3162 5

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
			   DixReadAccess);
    if (rc != Success)
	return rc;
d3179 1
a3179 1
ProcSetScreenSaver (ClientPtr client)
d3235 1
a3235 1
ProcGetScreenSaver(ClientPtr client)
d3252 1
a3252 1
ProcChangeHosts(ClientPtr client)
d3276 1
a3276 1
ProcListHosts(ClientPtr client)
d3284 1
a3284 1

d3286 2
a3287 1
    if (!XaceHook(XACE_HOSTLIST_ACCESS, client, DixReadAccess))
d3289 2
a3290 1

d3309 1
a3309 1
ProcChangeAccessControl(ClientPtr client)
a3325 22
/*********************
 * CloseDownRetainedResources
 *
 *    Find all clients that are gone and have terminated in RetainTemporary 
 *    and destroy their resources.
 *********************/

static void
CloseDownRetainedResources(void)
{
    int i;
    ClientPtr client;

    for (i=1; i<currentMaxClients; i++)
    {
        client = clients[i];
        if (client && (client->closeDownMode == RetainTemporary)
	    && (client->clientGone))
	    CloseDownClient(client);
    }
}

d3327 1
a3327 1
ProcKillClient(ClientPtr client)
d3330 1
a3330 2
    ClientPtr killclient;
    int rc;
d3339 2
a3340 2
    rc = dixLookupClient(&killclient, stuff->id, client, DixDestroyAccess);
    if (rc == Success) {
d3354 4
a3357 1
	return rc;
d3361 1
a3361 1
ProcSetFontPath(ClientPtr client)
d3396 1
a3396 1
ProcGetFontPath(ClientPtr client)
d3418 1
a3418 1
ProcChangeCloseDownMode(ClientPtr client)
d3437 1
a3437 1
int ProcForceScreenSaver(ClientPtr client)
d3453 1
a3453 1
int ProcNoOperation(ClientPtr client)
d3472 6
d3496 1
a3496 1
CloseDownClient(ClientPtr client)
a3567 3
#ifdef XSERVER_DTRACE
	XSERVER_CLIENT_DISCONNECT(client->index);
#endif	
d3582 1
a3582 1
KillAllClients(void)
d3593 22
d3674 1
a3674 1
    char *ptr;
d3676 3
a3678 3
    unsigned *sizes;
    unsigned size;
    int i;
a3692 2
    if (ppriv)
	bzero(ppriv, totalClientSize - sizeof(ClientRec));
d3726 2
a3727 2
    int i;
    ClientPtr client;
d3768 1
a3768 1
ProcInitialConnection(ClientPtr client)
d3771 1
a3771 1
    xConnClientPrefix *prefix;
d3795 1
a3795 1
SendConnSetup(ClientPtr client, char *reason)
d3797 2
a3798 2
    xWindowRoot *root;
    int i;
d3853 2
a3854 2
	unsigned int j;
	xDepth *pDepth;
d3895 1
a3895 1
ProcEstablishConnection(ClientPtr client)
d3898 1
a3898 1
    xConnClientPrefix *prefix;
d3947 1
a3947 1
    int i;
d3969 1
a3969 1
    int i;
a3992 57

#ifdef XSERVER_DTRACE
#include <ctype.h>

/* Load table of request names for dtrace probes */
static void LoadRequestNames(void)
{
    int i;
    FILE *xedb;
    extern void LoadExtensionNames(char **RequestNames);

    bzero(RequestNames, 256 * sizeof(char *));

    xedb = fopen(XERRORDB_PATH, "r");
    if (xedb != NULL) {
	char buf[256];
	while (fgets(buf, sizeof(buf), xedb)) {
	    if ((strncmp("XRequest.", buf, 9) == 0) && (isdigit(buf[9]))) {
		char *name;
		i = strtol(buf + 9, &name, 10);
		if (RequestNames[i] == 0) {
		    char *end = strchr(name, '\n');
		    if (end) { *end = '\0'; }
		    RequestNames[i] = strdup(name + 1);
		}
	    }
	}
	fclose(xedb);
    }

    LoadExtensionNames(RequestNames);

    for (i = 0; i < 256; i++) {
	if (RequestNames[i] == 0) {
#define RN_SIZE 12 /* "Request#' + up to 3 digits + \0 */
	    RequestNames[i] = xalloc(RN_SIZE);
	    if (RequestNames[i]) {
		snprintf(RequestNames[i], RN_SIZE, "Request#%d", i);
	    }
	}
	/* fprintf(stderr, "%d: %s\n", i, RequestNames[i]); */
    }
}

static void FreeRequestNames(void)
{
    int i;

    for (i = 0; i < 256; i++) {
	if (RequestNames[i] != 0) {
	    free(RequestNames[i]);
	    RequestNames[i] = 0;
	}
    }
}

#endif
@

