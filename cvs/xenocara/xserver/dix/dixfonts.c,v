head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.2
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.2
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	s0SI41sEunLdyFfd;

1.15
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	7pAEtF6Y5EgemkuY;

1.14
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	Te1daavkBLskZ8gc;

1.13
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.09.05.37.56;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.17.15.44.49;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.19;	author matthieu;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.19;	author matthieu;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	2008.01.29.06.02.07;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/************************************************************************
Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

************************************************************************/
/* The panoramix components contained the following notice */
/*
Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.

******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xmd.h>
#include <X11/Xproto.h>
#include "scrnintstr.h"
#include "resource.h"
#include "dixstruct.h"
#include "cursorstr.h"
#include "misc.h"
#include "opaque.h"
#include "dixfontstr.h"
#include "closestr.h"
#include "dixfont.h"
#include "xace.h"

#ifdef XF86BIGFONT
#include "xf86bigfontsrv.h"
#endif

extern void *fosNaturalParams;
extern FontPtr defaultFont;

static FontPathElementPtr *font_path_elements = (FontPathElementPtr *) 0;
static int num_fpes = 0;
static FPEFunctions *fpe_functions = (FPEFunctions *) 0;
static int num_fpe_types = 0;

static unsigned char *font_path_string;

static int num_slept_fpes = 0;
static int size_slept_fpes = 0;
static FontPathElementPtr *slept_fpes = (FontPathElementPtr *) 0;
static FontPatternCachePtr patternCache;

static int
FontToXError(int err)
{
    switch (err) {
    case Successful:
        return Success;
    case AllocError:
        return BadAlloc;
    case BadFontName:
        return BadName;
    case BadFontPath:
    case BadFontFormat:        /* is there something better? */
    case BadCharRange:
        return BadValue;
    default:
        return err;
    }
}

static int
LoadGlyphs(ClientPtr client, FontPtr pfont, unsigned nchars, int item_size,
           unsigned char *data)
{
    if (fpe_functions[pfont->fpe->type].load_glyphs)
        return (*fpe_functions[pfont->fpe->type].load_glyphs)
            (client, pfont, 0, nchars, item_size, data);
    else
        return Successful;
}

void
dixGetGlyphs(FontPtr font, unsigned long count, unsigned char *chars,
             FontEncoding fontEncoding,
             unsigned long *glyphcount,    /* RETURN */
             CharInfoPtr *glyphs)          /* RETURN */
{
    (*font->get_glyphs) (font, count, chars, fontEncoding, glyphcount, glyphs);
}

/*
 * adding RT_FONT prevents conflict with default cursor font
 */
Bool
SetDefaultFont(const char *defaultfontname)
{
    int err;
    FontPtr pf;
    XID fid;

    fid = FakeClientID(0);
    err = OpenFont(serverClient, fid, FontLoadAll | FontOpenSync,
                   (unsigned) strlen(defaultfontname), defaultfontname);
    if (err != Success)
        return FALSE;
    err = dixLookupResourceByType((void **) &pf, fid, RT_FONT, serverClient,
                                  DixReadAccess);
    if (err != Success)
        return FALSE;
    defaultFont = pf;
    return TRUE;
}

/*
 * note that the font wakeup queue is not refcounted.  this is because
 * an fpe needs to be added when it's inited, and removed when it's finally
 * freed, in order to handle any data that isn't requested, like FS events.
 *
 * since the only thing that should call these routines is the renderer's
 * init_fpe() and free_fpe(), there shouldn't be any problem in using
 * freed data.
 */
static void
QueueFontWakeup(FontPathElementPtr fpe)
{
    int i;
    FontPathElementPtr *new;

    for (i = 0; i < num_slept_fpes; i++) {
        if (slept_fpes[i] == fpe) {
            return;
        }
    }
    if (num_slept_fpes == size_slept_fpes) {
        new = reallocarray(slept_fpes, size_slept_fpes + 4,
                           sizeof(FontPathElementPtr));
        if (!new)
            return;
        slept_fpes = new;
        size_slept_fpes += 4;
    }
    slept_fpes[num_slept_fpes] = fpe;
    num_slept_fpes++;
}

static void
RemoveFontWakeup(FontPathElementPtr fpe)
{
    int i, j;

    for (i = 0; i < num_slept_fpes; i++) {
        if (slept_fpes[i] == fpe) {
            for (j = i; j < num_slept_fpes; j++) {
                slept_fpes[j] = slept_fpes[j + 1];
            }
            num_slept_fpes--;
            return;
        }
    }
}

static void
FontWakeup(void *data, int count, void *LastSelectMask)
{
    int i;
    FontPathElementPtr fpe;

    if (count < 0)
        return;
    /* wake up any fpe's that may be waiting for information */
    for (i = 0; i < num_slept_fpes; i++) {
        fpe = slept_fpes[i];
        (void) (*fpe_functions[fpe->type].wakeup_fpe) (fpe, LastSelectMask);
    }
}

/* XXX -- these two funcs may want to be broken into macros */
static void
UseFPE(FontPathElementPtr fpe)
{
    fpe->refcount++;
}

static void
FreeFPE(FontPathElementPtr fpe)
{
    fpe->refcount--;
    if (fpe->refcount == 0) {
        (*fpe_functions[fpe->type].free_fpe) (fpe);
        free((void *) fpe->name);
        free(fpe);
    }
}

static Bool
doOpenFont(ClientPtr client, OFclosurePtr c)
{
    FontPtr pfont = NullFont;
    FontPathElementPtr fpe = NULL;
    ScreenPtr pScr;
    int err = Successful;
    int i;
    char *alias, *newname;
    int newlen;
    int aliascount = 20;

    /*
     * Decide at runtime what FontFormat to use.
     */
    Mask FontFormat =
        ((screenInfo.imageByteOrder == LSBFirst) ?
         BitmapFormatByteOrderLSB : BitmapFormatByteOrderMSB) |
        ((screenInfo.bitmapBitOrder == LSBFirst) ?
         BitmapFormatBitOrderLSB : BitmapFormatBitOrderMSB) |
        BitmapFormatImageRectMin |
#if GLYPHPADBYTES == 1
        BitmapFormatScanlinePad8 |
#endif
#if GLYPHPADBYTES == 2
        BitmapFormatScanlinePad16 |
#endif
#if GLYPHPADBYTES == 4
        BitmapFormatScanlinePad32 |
#endif
#if GLYPHPADBYTES == 8
        BitmapFormatScanlinePad64 |
#endif
        BitmapFormatScanlineUnit8;

    if (client->clientGone) {
        if (c->current_fpe < c->num_fpes) {
            fpe = c->fpe_list[c->current_fpe];
            (*fpe_functions[fpe->type].client_died) ((void *) client, fpe);
        }
        err = Successful;
        goto bail;
    }
    while (c->current_fpe < c->num_fpes) {
        fpe = c->fpe_list[c->current_fpe];
        err = (*fpe_functions[fpe->type].open_font)
            ((void *) client, fpe, c->flags,
             c->fontname, c->fnamelen, FontFormat,
             BitmapFormatMaskByte |
             BitmapFormatMaskBit |
             BitmapFormatMaskImageRectangle |
             BitmapFormatMaskScanLinePad |
             BitmapFormatMaskScanLineUnit,
             c->fontid, &pfont, &alias,
             c->non_cachable_font && c->non_cachable_font->fpe == fpe ?
             c->non_cachable_font : (FontPtr) 0);

        if (err == FontNameAlias && alias) {
            newlen = strlen(alias);
            newname = (char *) realloc((char *) c->fontname, newlen);
            if (!newname) {
                err = AllocError;
                break;
            }
            memmove(newname, alias, newlen);
            c->fontname = newname;
            c->fnamelen = newlen;
            c->current_fpe = 0;
            if (--aliascount <= 0) {
                /* We've tried resolving this alias 20 times, we're
                 * probably stuck in an infinite loop of aliases pointing
                 * to each other - time to take emergency exit!
                 */
                err = BadImplementation;
                break;
            }
            continue;
        }
        if (err == BadFontName) {
            c->current_fpe++;
            continue;
        }
        if (err == Suspended) {
            if (!ClientIsAsleep(client))
                ClientSleep(client, (ClientSleepProcPtr) doOpenFont, c);
            return TRUE;
        }
        break;
    }

    if (err != Successful)
        goto bail;
    if (!pfont) {
        err = BadFontName;
        goto bail;
    }
    /* check values for firstCol, lastCol, firstRow, and lastRow */
    if (pfont->info.firstCol > pfont->info.lastCol ||
        pfont->info.firstRow > pfont->info.lastRow ||
        pfont->info.lastCol - pfont->info.firstCol > 255) {
        err = AllocError;
        goto bail;
    }
    if (!pfont->fpe)
        pfont->fpe = fpe;
    pfont->refcnt++;
    if (pfont->refcnt == 1) {
        UseFPE(pfont->fpe);
        for (i = 0; i < screenInfo.numScreens; i++) {
            pScr = screenInfo.screens[i];
            if (pScr->RealizeFont) {
                if (!(*pScr->RealizeFont) (pScr, pfont)) {
                    CloseFont(pfont, (Font) 0);
                    err = AllocError;
                    goto bail;
                }
            }
        }
    }
    if (!AddResource(c->fontid, RT_FONT, (void *) pfont)) {
        err = AllocError;
        goto bail;
    }
    if (patternCache && pfont != c->non_cachable_font)
        CacheFontPattern(patternCache, c->origFontName, c->origFontNameLen,
                         pfont);
 bail:
    if (err != Successful && c->client != serverClient) {
        SendErrorToClient(c->client, X_OpenFont, 0,
                          c->fontid, FontToXError(err));
    }
    ClientWakeup(c->client);
    for (i = 0; i < c->num_fpes; i++) {
        FreeFPE(c->fpe_list[i]);
    }
    free(c->fpe_list);
    free((void *) c->fontname);
    free(c);
    return TRUE;
}

int
OpenFont(ClientPtr client, XID fid, Mask flags, unsigned lenfname,
         const char *pfontname)
{
    OFclosurePtr c;
    int i;
    FontPtr cached = (FontPtr) 0;

    if (!lenfname || lenfname > XLFDMAXFONTNAMELEN)
        return BadName;
    if (patternCache) {

        /*
         ** Check name cache.  If we find a cached version of this font that
         ** is cachable, immediately satisfy the request with it.  If we find
         ** a cached version of this font that is non-cachable, we do not
         ** satisfy the request with it.  Instead, we pass the FontPtr to the
         ** FPE's open_font code (the fontfile FPE in turn passes the
         ** information to the rasterizer; the fserve FPE ignores it).
         **
         ** Presumably, the font is marked non-cachable because the FPE has
         ** put some licensing restrictions on it.  If the FPE, using
         ** whatever logic it relies on, determines that it is willing to
         ** share this existing font with the client, then it has the option
         ** to return the FontPtr we passed it as the newly-opened font.
         ** This allows the FPE to exercise its licensing logic without
         ** having to create another instance of a font that already exists.
         */

        cached = FindCachedFontPattern(patternCache, pfontname, lenfname);
        if (cached && cached->info.cachable) {
            if (!AddResource(fid, RT_FONT, (void *) cached))
                return BadAlloc;
            cached->refcnt++;
            return Success;
        }
    }
    c = malloc(sizeof(OFclosureRec));
    if (!c)
        return BadAlloc;
    c->fontname = malloc(lenfname);
    c->origFontName = pfontname;
    c->origFontNameLen = lenfname;
    if (!c->fontname) {
        free(c);
        return BadAlloc;
    }
    /*
     * copy the current FPE list, so that if it gets changed by another client
     * while we're blocking, the request still appears atomic
     */
    c->fpe_list = xallocarray(num_fpes, sizeof(FontPathElementPtr));
    if (!c->fpe_list) {
        free((void *) c->fontname);
        free(c);
        return BadAlloc;
    }
    memmove(c->fontname, pfontname, lenfname);
    for (i = 0; i < num_fpes; i++) {
        c->fpe_list[i] = font_path_elements[i];
        UseFPE(c->fpe_list[i]);
    }
    c->client = client;
    c->fontid = fid;
    c->current_fpe = 0;
    c->num_fpes = num_fpes;
    c->fnamelen = lenfname;
    c->flags = flags;
    c->non_cachable_font = cached;

    (void) doOpenFont(client, c);
    return Success;
}

/**
 * Decrement font's ref count, and free storage if ref count equals zero
 *
 *  \param value must conform to DeleteType
 */
int
CloseFont(void *value, XID fid)
{
    int nscr;
    ScreenPtr pscr;
    FontPathElementPtr fpe;
    FontPtr pfont = (FontPtr) value;

    if (pfont == NullFont)
        return Success;
    if (--pfont->refcnt == 0) {
        if (patternCache)
            RemoveCachedFontPattern(patternCache, pfont);
        /*
         * since the last reference is gone, ask each screen to free any
         * storage it may have allocated locally for it.
         */
        for (nscr = 0; nscr < screenInfo.numScreens; nscr++) {
            pscr = screenInfo.screens[nscr];
            if (pscr->UnrealizeFont)
                (*pscr->UnrealizeFont) (pscr, pfont);
        }
        if (pfont == defaultFont)
            defaultFont = NULL;
#ifdef XF86BIGFONT
        XF86BigfontFreeFontShm(pfont);
#endif
        fpe = pfont->fpe;
        (*fpe_functions[fpe->type].close_font) (fpe, pfont);
        FreeFPE(fpe);
    }
    return Success;
}

/***====================================================================***/

/**
 * Sets up pReply as the correct QueryFontReply for pFont with the first
 * nProtoCCIStructs char infos.
 *
 *  \param pReply caller must allocate this storage
  */
void
QueryFont(FontPtr pFont, xQueryFontReply * pReply, int nProtoCCIStructs)
{
    FontPropPtr pFP;
    int r, c, i;
    xFontProp *prFP;
    xCharInfo *prCI;
    xCharInfo *charInfos[256];
    unsigned char chars[512];
    int ninfos;
    unsigned long ncols;
    unsigned long count;

    /* pr->length set in dispatch */
    pReply->minCharOrByte2 = pFont->info.firstCol;
    pReply->defaultChar = pFont->info.defaultCh;
    pReply->maxCharOrByte2 = pFont->info.lastCol;
    pReply->drawDirection = pFont->info.drawDirection;
    pReply->allCharsExist = pFont->info.allExist;
    pReply->minByte1 = pFont->info.firstRow;
    pReply->maxByte1 = pFont->info.lastRow;
    pReply->fontAscent = pFont->info.fontAscent;
    pReply->fontDescent = pFont->info.fontDescent;

    pReply->minBounds = pFont->info.ink_minbounds;
    pReply->maxBounds = pFont->info.ink_maxbounds;

    pReply->nFontProps = pFont->info.nprops;
    pReply->nCharInfos = nProtoCCIStructs;

    for (i = 0, pFP = pFont->info.props, prFP = (xFontProp *) (&pReply[1]);
         i < pFont->info.nprops; i++, pFP++, prFP++) {
        prFP->name = pFP->name;
        prFP->value = pFP->value;
    }

    ninfos = 0;
    ncols = (unsigned long) (pFont->info.lastCol - pFont->info.firstCol + 1);
    prCI = (xCharInfo *) (prFP);
    for (r = pFont->info.firstRow;
         ninfos < nProtoCCIStructs && r <= (int) pFont->info.lastRow; r++) {
        i = 0;
        for (c = pFont->info.firstCol; c <= (int) pFont->info.lastCol; c++) {
            chars[i++] = r;
            chars[i++] = c;
        }
        (*pFont->get_metrics) (pFont, ncols, chars,
                               TwoD16Bit, &count, charInfos);
        i = 0;
        for (i = 0; i < (int) count && ninfos < nProtoCCIStructs; i++) {
            *prCI = *charInfos[i];
            prCI++;
            ninfos++;
        }
    }
    return;
}

static Bool
doListFontsAndAliases(ClientPtr client, LFclosurePtr c)
{
    FontPathElementPtr fpe;
    int err = Successful;
    FontNamesPtr names = NULL;
    char *name, *resolved = NULL;
    int namelen, resolvedlen;
    int nnames;
    int stringLens;
    int i;
    xListFontsReply reply;
    char *bufptr;
    char *bufferStart;
    int aliascount = 0;

    if (client->clientGone) {
        if (c->current.current_fpe < c->num_fpes) {
            fpe = c->fpe_list[c->current.current_fpe];
            (*fpe_functions[fpe->type].client_died) ((void *) client, fpe);
        }
        err = Successful;
        goto bail;
    }

    if (!c->current.patlen)
        goto finish;

    while (c->current.current_fpe < c->num_fpes) {
        fpe = c->fpe_list[c->current.current_fpe];
        err = Successful;

        if (!fpe_functions[fpe->type].start_list_fonts_and_aliases) {
            /* This FPE doesn't support/require list_fonts_and_aliases */

            err = (*fpe_functions[fpe->type].list_fonts)
                ((void *) c->client, fpe, c->current.pattern,
                 c->current.patlen, c->current.max_names - c->names->nnames,
                 c->names);

            if (err == Suspended) {
                if (!ClientIsAsleep(client))
                    ClientSleep(client,
                                (ClientSleepProcPtr) doListFontsAndAliases, c);
                return TRUE;
            }

            err = BadFontName;
        }
        else {
            /* Start of list_fonts_and_aliases functionality.  Modeled
               after list_fonts_with_info in that it resolves aliases,
               except that the information collected from FPEs is just
               names, not font info.  Each list_next_font_or_alias()
               returns either a name into name/namelen or an alias into
               name/namelen and its target name into resolved/resolvedlen.
               The code at this level then resolves the alias by polling
               the FPEs.  */

            if (!c->current.list_started) {
                err = (*fpe_functions[fpe->type].start_list_fonts_and_aliases)
                    ((void *) c->client, fpe, c->current.pattern,
                     c->current.patlen, c->current.max_names - c->names->nnames,
                     &c->current.private);
                if (err == Suspended) {
                    if (!ClientIsAsleep(client))
                        ClientSleep(client,
                                    (ClientSleepProcPtr) doListFontsAndAliases,
                                    c);
                    return TRUE;
                }
                if (err == Successful)
                    c->current.list_started = TRUE;
            }
            if (err == Successful) {
                char *tmpname;

                name = 0;
                err = (*fpe_functions[fpe->type].list_next_font_or_alias)
                    ((void *) c->client, fpe, &name, &namelen, &tmpname,
                     &resolvedlen, c->current.private);
                if (err == Suspended) {
                    if (!ClientIsAsleep(client))
                        ClientSleep(client,
                                    (ClientSleepProcPtr) doListFontsAndAliases,
                                    c);
                    return TRUE;
                }
                if (err == FontNameAlias) {
                    free(resolved);
                    resolved = malloc(resolvedlen + 1);
                    if (resolved)
                        memmove(resolved, tmpname, resolvedlen + 1);
                }
            }

            if (err == Successful) {
                if (c->haveSaved) {
                    if (c->savedName)
                        (void) AddFontNamesName(c->names, c->savedName,
                                                c->savedNameLen);
                }
                else
                    (void) AddFontNamesName(c->names, name, namelen);
            }

            /*
             * When we get an alias back, save our state and reset back to
             * the start of the FPE looking for the specified name.  As
             * soon as a real font is found for the alias, pop back to the
             * old state
             */
            else if (err == FontNameAlias) {
                char tmp_pattern[XLFDMAXFONTNAMELEN];

                /*
                 * when an alias recurses, we need to give
                 * the last FPE a chance to clean up; so we call
                 * it again, and assume that the error returned
                 * is BadFontName, indicating the alias resolution
                 * is complete.
                 */
                memmove(tmp_pattern, resolved, resolvedlen);
                if (c->haveSaved) {
                    char *tmpname;
                    int tmpnamelen;

                    tmpname = 0;
                    (void) (*fpe_functions[fpe->type].list_next_font_or_alias)
                        ((void *) c->client, fpe, &tmpname, &tmpnamelen,
                         &tmpname, &tmpnamelen, c->current.private);
                    if (--aliascount <= 0) {
                        err = BadFontName;
                        goto ContBadFontName;
                    }
                }
                else {
                    c->saved = c->current;
                    c->haveSaved = TRUE;
                    free(c->savedName);
                    c->savedName = malloc(namelen + 1);
                    if (c->savedName)
                        memmove(c->savedName, name, namelen + 1);
                    c->savedNameLen = namelen;
                    aliascount = 20;
                }
                memmove(c->current.pattern, tmp_pattern, resolvedlen);
                c->current.patlen = resolvedlen;
                c->current.max_names = c->names->nnames + 1;
                c->current.current_fpe = -1;
                c->current.private = 0;
                err = BadFontName;
            }
        }
        /*
         * At the end of this FPE, step to the next.  If we've finished
         * processing an alias, pop state back. If we've collected enough
         * font names, quit.
         */
        if (err == BadFontName) {
 ContBadFontName:;
            c->current.list_started = FALSE;
            c->current.current_fpe++;
            err = Successful;
            if (c->haveSaved) {
                if (c->names->nnames == c->current.max_names ||
                    c->current.current_fpe == c->num_fpes) {
                    c->haveSaved = FALSE;
                    c->current = c->saved;
                    /* Give the saved namelist a chance to clean itself up */
                    continue;
                }
            }
            if (c->names->nnames == c->current.max_names)
                break;
        }
    }

    /*
     * send the reply
     */
    if (err != Successful) {
        SendErrorToClient(client, X_ListFonts, 0, 0, FontToXError(err));
        goto bail;
    }

 finish:

    names = c->names;
    nnames = names->nnames;
    client = c->client;
    stringLens = 0;
    for (i = 0; i < nnames; i++)
        stringLens += (names->length[i] <= 255) ? names->length[i] : 0;

    reply = (xListFontsReply) {
        .type = X_Reply,
        .length = bytes_to_int32(stringLens + nnames),
        .nFonts = nnames,
        .sequenceNumber = client->sequence
    };

    bufptr = bufferStart = malloc(reply.length << 2);

    if (!bufptr && reply.length) {
        SendErrorToClient(client, X_ListFonts, 0, 0, BadAlloc);
        goto bail;
    }
    /*
     * since WriteToClient long word aligns things, copy to temp buffer and
     * write all at once
     */
    for (i = 0; i < nnames; i++) {
        if (names->length[i] > 255)
            reply.nFonts--;
        else {
            *bufptr++ = names->length[i];
            memmove(bufptr, names->names[i], names->length[i]);
            bufptr += names->length[i];
        }
    }
    nnames = reply.nFonts;
    reply.length = bytes_to_int32(stringLens + nnames);
    client->pSwapReplyFunc = ReplySwapVector[X_ListFonts];
    WriteSwappedDataToClient(client, sizeof(xListFontsReply), &reply);
    WriteToClient(client, stringLens + nnames, bufferStart);
    free(bufferStart);

 bail:
    ClientWakeup(client);
    for (i = 0; i < c->num_fpes; i++)
        FreeFPE(c->fpe_list[i]);
    free(c->fpe_list);
    free(c->savedName);
    FreeFontNames(names);
    free(c);
    free(resolved);
    return TRUE;
}

int
ListFonts(ClientPtr client, unsigned char *pattern, unsigned length,
          unsigned max_names)
{
    int i;
    LFclosurePtr c;

    /*
     * The right error to return here would be BadName, however the
     * specification does not allow for a Name error on this request.
     * Perhaps a better solution would be to return a nil list, i.e.
     * a list containing zero fontnames.
     */
    if (length > XLFDMAXFONTNAMELEN)
        return BadAlloc;

    i = XaceHook(XACE_SERVER_ACCESS, client, DixGetAttrAccess);
    if (i != Success)
        return i;

    if (!(c = malloc(sizeof *c)))
        return BadAlloc;
    c->fpe_list = xallocarray(num_fpes, sizeof(FontPathElementPtr));
    if (!c->fpe_list) {
        free(c);
        return BadAlloc;
    }
    c->names = MakeFontNamesRecord(max_names < 100 ? max_names : 100);
    if (!c->names) {
        free(c->fpe_list);
        free(c);
        return BadAlloc;
    }
    memmove(c->current.pattern, pattern, length);
    for (i = 0; i < num_fpes; i++) {
        c->fpe_list[i] = font_path_elements[i];
        UseFPE(c->fpe_list[i]);
    }
    c->client = client;
    c->num_fpes = num_fpes;
    c->current.patlen = length;
    c->current.current_fpe = 0;
    c->current.max_names = max_names;
    c->current.list_started = FALSE;
    c->current.private = 0;
    c->haveSaved = FALSE;
    c->savedName = 0;
    doListFontsAndAliases(client, c);
    return Success;
}

static int
doListFontsWithInfo(ClientPtr client, LFWIclosurePtr c)
{
    FontPathElementPtr fpe;
    int err = Successful;
    char *name;
    int namelen;
    int numFonts;
    FontInfoRec fontInfo, *pFontInfo;
    xListFontsWithInfoReply *reply;
    int length;
    xFontProp *pFP;
    int i;
    int aliascount = 0;
    xListFontsWithInfoReply finalReply;

    if (client->clientGone) {
        if (c->current.current_fpe < c->num_fpes) {
            fpe = c->fpe_list[c->current.current_fpe];
            (*fpe_functions[fpe->type].client_died) ((void *) client, fpe);
        }
        err = Successful;
        goto bail;
    }
    client->pSwapReplyFunc = ReplySwapVector[X_ListFontsWithInfo];
    if (!c->current.patlen)
        goto finish;
    while (c->current.current_fpe < c->num_fpes) {
        fpe = c->fpe_list[c->current.current_fpe];
        err = Successful;
        if (!c->current.list_started) {
            err = (*fpe_functions[fpe->type].start_list_fonts_with_info)
                (client, fpe, c->current.pattern, c->current.patlen,
                 c->current.max_names, &c->current.private);
            if (err == Suspended) {
                if (!ClientIsAsleep(client))
                    ClientSleep(client,
                                (ClientSleepProcPtr) doListFontsWithInfo, c);
                return TRUE;
            }
            if (err == Successful)
                c->current.list_started = TRUE;
        }
        if (err == Successful) {
            name = 0;
            pFontInfo = &fontInfo;
            err = (*fpe_functions[fpe->type].list_next_font_with_info)
                (client, fpe, &name, &namelen, &pFontInfo,
                 &numFonts, c->current.private);
            if (err == Suspended) {
                if (!ClientIsAsleep(client))
                    ClientSleep(client,
                                (ClientSleepProcPtr) doListFontsWithInfo, c);
                return TRUE;
            }
        }
        /*
         * When we get an alias back, save our state and reset back to the
         * start of the FPE looking for the specified name.  As soon as a real
         * font is found for the alias, pop back to the old state
         */
        if (err == FontNameAlias) {
            /*
             * when an alias recurses, we need to give
             * the last FPE a chance to clean up; so we call
             * it again, and assume that the error returned
             * is BadFontName, indicating the alias resolution
             * is complete.
             */
            if (c->haveSaved) {
                char *tmpname;
                int tmpnamelen;
                FontInfoPtr tmpFontInfo;

                tmpname = 0;
                tmpFontInfo = &fontInfo;
                (void) (*fpe_functions[fpe->type].list_next_font_with_info)
                    (client, fpe, &tmpname, &tmpnamelen, &tmpFontInfo,
                     &numFonts, c->current.private);
                if (--aliascount <= 0) {
                    err = BadFontName;
                    goto ContBadFontName;
                }
            }
            else {
                c->saved = c->current;
                c->haveSaved = TRUE;
                c->savedNumFonts = numFonts;
                free(c->savedName);
                c->savedName = malloc(namelen + 1);
                if (c->savedName)
                    memmove(c->savedName, name, namelen + 1);
                aliascount = 20;
            }
            memmove(c->current.pattern, name, namelen);
            c->current.patlen = namelen;
            c->current.max_names = 1;
            c->current.current_fpe = 0;
            c->current.private = 0;
            c->current.list_started = FALSE;
        }
        /*
         * At the end of this FPE, step to the next.  If we've finished
         * processing an alias, pop state back.  If we've sent enough font
         * names, quit.  Always wait for BadFontName to let the FPE
         * have a chance to clean up.
         */
        else if (err == BadFontName) {
 ContBadFontName:;
            c->current.list_started = FALSE;
            c->current.current_fpe++;
            err = Successful;
            if (c->haveSaved) {
                if (c->current.max_names == 0 ||
                    c->current.current_fpe == c->num_fpes) {
                    c->haveSaved = FALSE;
                    c->saved.max_names -= (1 - c->current.max_names);
                    c->current = c->saved;
                }
            }
            else if (c->current.max_names == 0)
                break;
        }
        else if (err == Successful) {
            length = sizeof(*reply) + pFontInfo->nprops * sizeof(xFontProp);
            reply = c->reply;
            if (c->length < length) {
                reply = (xListFontsWithInfoReply *) realloc(c->reply, length);
                if (!reply) {
                    err = AllocError;
                    break;
                }
                memset((char *) reply + c->length, 0, length - c->length);
                c->reply = reply;
                c->length = length;
            }
            if (c->haveSaved) {
                numFonts = c->savedNumFonts;
                name = c->savedName;
                namelen = strlen(name);
            }
            reply->type = X_Reply;
            reply->length =
                bytes_to_int32(sizeof *reply - sizeof(xGenericReply) +
                               pFontInfo->nprops * sizeof(xFontProp) + namelen);
            reply->sequenceNumber = client->sequence;
            reply->nameLength = namelen;
            reply->minBounds = pFontInfo->ink_minbounds;
            reply->maxBounds = pFontInfo->ink_maxbounds;
            reply->minCharOrByte2 = pFontInfo->firstCol;
            reply->maxCharOrByte2 = pFontInfo->lastCol;
            reply->defaultChar = pFontInfo->defaultCh;
            reply->nFontProps = pFontInfo->nprops;
            reply->drawDirection = pFontInfo->drawDirection;
            reply->minByte1 = pFontInfo->firstRow;
            reply->maxByte1 = pFontInfo->lastRow;
            reply->allCharsExist = pFontInfo->allExist;
            reply->fontAscent = pFontInfo->fontAscent;
            reply->fontDescent = pFontInfo->fontDescent;
            reply->nReplies = numFonts;
            pFP = (xFontProp *) (reply + 1);
            for (i = 0; i < pFontInfo->nprops; i++) {
                pFP->name = pFontInfo->props[i].name;
                pFP->value = pFontInfo->props[i].value;
                pFP++;
            }
            WriteSwappedDataToClient(client, length, reply);
            WriteToClient(client, namelen, name);
            if (pFontInfo == &fontInfo) {
                free(fontInfo.props);
                free(fontInfo.isStringProp);
            }
            --c->current.max_names;
        }
    }
 finish:
    length = sizeof(xListFontsWithInfoReply);
    finalReply = (xListFontsWithInfoReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(sizeof(xListFontsWithInfoReply)
                                 - sizeof(xGenericReply))
    };
    WriteSwappedDataToClient(client, length, &finalReply);
 bail:
    ClientWakeup(client);
    for (i = 0; i < c->num_fpes; i++)
        FreeFPE(c->fpe_list[i]);
    free(c->reply);
    free(c->fpe_list);
    free(c->savedName);
    free(c);
    return TRUE;
}

int
StartListFontsWithInfo(ClientPtr client, int length, unsigned char *pattern,
                       int max_names)
{
    int i;
    LFWIclosurePtr c;

    /*
     * The right error to return here would be BadName, however the
     * specification does not allow for a Name error on this request.
     * Perhaps a better solution would be to return a nil list, i.e.
     * a list containing zero fontnames.
     */
    if (length > XLFDMAXFONTNAMELEN)
        return BadAlloc;

    i = XaceHook(XACE_SERVER_ACCESS, client, DixGetAttrAccess);
    if (i != Success)
        return i;

    if (!(c = malloc(sizeof *c)))
        goto badAlloc;
    c->fpe_list = xallocarray(num_fpes, sizeof(FontPathElementPtr));
    if (!c->fpe_list) {
        free(c);
        goto badAlloc;
    }
    memmove(c->current.pattern, pattern, length);
    for (i = 0; i < num_fpes; i++) {
        c->fpe_list[i] = font_path_elements[i];
        UseFPE(c->fpe_list[i]);
    }
    c->client = client;
    c->num_fpes = num_fpes;
    c->reply = 0;
    c->length = 0;
    c->current.patlen = length;
    c->current.current_fpe = 0;
    c->current.max_names = max_names;
    c->current.list_started = FALSE;
    c->current.private = 0;
    c->savedNumFonts = 0;
    c->haveSaved = FALSE;
    c->savedName = 0;
    doListFontsWithInfo(client, c);
    return Success;
 badAlloc:
    return BadAlloc;
}

#define TextEltHeader 2
#define FontShiftSize 5
static ChangeGCVal clearGC[] = { {.ptr = NullPixmap} };

#define clearGCmask (GCClipMask)

static int
doPolyText(ClientPtr client, PTclosurePtr c)
{
    FontPtr pFont = c->pGC->font, oldpFont;
    int err = Success, lgerr;   /* err is in X error, not font error, space */
    enum { NEVER_SLEPT, START_SLEEP, SLEEPING } client_state = NEVER_SLEPT;
    FontPathElementPtr fpe;
    GC *origGC = NULL;
    int itemSize = c->reqType == X_PolyText8 ? 1 : 2;

    if (client->clientGone) {
        fpe = c->pGC->font->fpe;
        (*fpe_functions[fpe->type].client_died) ((void *) client, fpe);

        if (ClientIsAsleep(client)) {
            /* Client has died, but we cannot bail out right now.  We
               need to clean up after the work we did when going to
               sleep.  Setting the drawable poiner to 0 makes this
               happen without any attempts to render or perform other
               unnecessary activities.  */
            c->pDraw = (DrawablePtr) 0;
        }
        else {
            err = Success;
            goto bail;
        }
    }

    /* Make sure our drawable hasn't disappeared while we slept. */
    if (ClientIsAsleep(client) && c->pDraw) {
        DrawablePtr pDraw;

        dixLookupDrawable(&pDraw, c->did, client, 0, DixWriteAccess);
        if (c->pDraw != pDraw) {
            /* Our drawable has disappeared.  Treat like client died... ask
               the FPE code to clean up after client and avoid further
               rendering while we clean up after ourself.  */
            fpe = c->pGC->font->fpe;
            (*fpe_functions[fpe->type].client_died) ((void *) client, fpe);
            c->pDraw = (DrawablePtr) 0;
        }
    }

    client_state = ClientIsAsleep(client) ? SLEEPING : NEVER_SLEPT;

    while (c->endReq - c->pElt > TextEltHeader) {
        if (*c->pElt == FontChange) {
            Font fid;

            if (c->endReq - c->pElt < FontShiftSize) {
                err = BadLength;
                goto bail;
            }

            oldpFont = pFont;

            fid = ((Font) *(c->pElt + 4))       /* big-endian */
                |((Font) *(c->pElt + 3)) << 8
                | ((Font) *(c->pElt + 2)) << 16 | ((Font) *(c->pElt + 1)) << 24;
            err = dixLookupResourceByType((void **) &pFont, fid, RT_FONT,
                                          client, DixUseAccess);
            if (err != Success) {
                /* restore pFont for step 4 (described below) */
                pFont = oldpFont;

                /* If we're in START_SLEEP mode, the following step
                   shortens the request...  in the unlikely event that
                   the fid somehow becomes valid before we come through
                   again to actually execute the polytext, which would
                   then mess up our refcounting scheme badly.  */
                c->err = err;
                c->endReq = c->pElt;

                goto bail;
            }

            /* Step 3 (described below) on our new font */
            if (client_state == START_SLEEP)
                pFont->refcnt++;
            else {
                if (pFont != c->pGC->font && c->pDraw) {
                    ChangeGCVal val;

                    val.ptr = pFont;
                    ChangeGC(NullClient, c->pGC, GCFont, &val);
                    ValidateGC(c->pDraw, c->pGC);
                }

                /* Undo the refcnt++ we performed when going to sleep */
                if (client_state == SLEEPING)
                    (void) CloseFont(c->pGC->font, (Font) 0);
            }
            c->pElt += FontShiftSize;
        }
        else {                  /* print a string */

            unsigned char *pNextElt;

            pNextElt = c->pElt + TextEltHeader + (*c->pElt) * itemSize;
            if (pNextElt > c->endReq) {
                err = BadLength;
                goto bail;
            }
            if (client_state == START_SLEEP) {
                c->pElt = pNextElt;
                continue;
            }
            if (c->pDraw) {
                lgerr = LoadGlyphs(client, c->pGC->font, *c->pElt, itemSize,
                                   c->pElt + TextEltHeader);
            }
            else
                lgerr = Successful;

            if (lgerr == Suspended) {
                if (!ClientIsAsleep(client)) {
                    int len;
                    GC *pGC;
                    PTclosurePtr new_closure;

                    /*  We're putting the client to sleep.  We need to do a few things
                       to ensure successful and atomic-appearing execution of the
                       remainder of the request.  First, copy the remainder of the
                       request into a safe malloc'd area.  Second, create a scratch GC
                       to use for the remainder of the request.  Third, mark all fonts
                       referenced in the remainder of the request to prevent their
                       deallocation.  Fourth, make the original GC look like the
                       request has completed...  set its font to the final font value
                       from this request.  These GC manipulations are for the unlikely
                       (but possible) event that some other client is using the GC.
                       Steps 3 and 4 are performed by running this procedure through
                       the remainder of the request in a special no-render mode
                       indicated by client_state = START_SLEEP.  */

                    /* Step 1 */
                    /* Allocate a malloc'd closure structure to replace
                       the local one we were passed */
                    new_closure = malloc(sizeof(PTclosureRec));
                    if (!new_closure) {
                        err = BadAlloc;
                        goto bail;
                    }
                    *new_closure = *c;

                    len = new_closure->endReq - new_closure->pElt;
                    new_closure->data = malloc(len);
                    if (!new_closure->data) {
                        free(new_closure);
                        err = BadAlloc;
                        goto bail;
                    }
                    memmove(new_closure->data, new_closure->pElt, len);
                    new_closure->pElt = new_closure->data;
                    new_closure->endReq = new_closure->pElt + len;

                    /* Step 2 */

                    pGC =
                        GetScratchGC(new_closure->pGC->depth,
                                     new_closure->pGC->pScreen);
                    if (!pGC) {
                        free(new_closure->data);
                        free(new_closure);
                        err = BadAlloc;
                        goto bail;
                    }
                    if ((err = CopyGC(new_closure->pGC, pGC, GCFunction |
                                      GCPlaneMask | GCForeground |
                                      GCBackground | GCFillStyle |
                                      GCTile | GCStipple |
                                      GCTileStipXOrigin |
                                      GCTileStipYOrigin | GCFont |
                                      GCSubwindowMode | GCClipXOrigin |
                                      GCClipYOrigin | GCClipMask)) != Success) {
                        FreeScratchGC(pGC);
                        free(new_closure->data);
                        free(new_closure);
                        err = BadAlloc;
                        goto bail;
                    }
                    c = new_closure;
                    origGC = c->pGC;
                    c->pGC = pGC;
                    ValidateGC(c->pDraw, c->pGC);

                    ClientSleep(client, (ClientSleepProcPtr) doPolyText, c);

                    /* Set up to perform steps 3 and 4 */
                    client_state = START_SLEEP;
                    continue;   /* on to steps 3 and 4 */
                }
                return TRUE;
            }
            else if (lgerr != Successful) {
                err = FontToXError(lgerr);
                goto bail;
            }
            if (c->pDraw) {
                c->xorg += *((INT8 *) (c->pElt + 1));   /* must be signed */
                if (c->reqType == X_PolyText8)
                    c->xorg =
                        (*c->pGC->ops->PolyText8) (c->pDraw, c->pGC, c->xorg,
                                                   c->yorg, *c->pElt,
                                                   (char *) (c->pElt +
                                                             TextEltHeader));
                else
                    c->xorg =
                        (*c->pGC->ops->PolyText16) (c->pDraw, c->pGC, c->xorg,
                                                    c->yorg, *c->pElt,
                                                    (unsigned short *) (c->
                                                                        pElt +
                                                                        TextEltHeader));
            }
            c->pElt = pNextElt;
        }
    }

 bail:

    if (client_state == START_SLEEP) {
        /* Step 4 */
        if (pFont != origGC->font) {
            ChangeGCVal val;

            val.ptr = pFont;
            ChangeGC(NullClient, origGC, GCFont, &val);
            ValidateGC(c->pDraw, origGC);
        }

        /* restore pElt pointer for execution of remainder of the request */
        c->pElt = c->data;
        return TRUE;
    }

    if (c->err != Success)
        err = c->err;
    if (err != Success && c->client != serverClient) {
#ifdef PANORAMIX
        if (noPanoramiXExtension || !c->pGC->pScreen->myNum)
#endif
            SendErrorToClient(c->client, c->reqType, 0, 0, err);
    }
    if (ClientIsAsleep(client)) {
        ClientWakeup(c->client);
        ChangeGC(NullClient, c->pGC, clearGCmask, clearGC);

        /* Unreference the font from the scratch GC */
        CloseFont(c->pGC->font, (Font) 0);
        c->pGC->font = NullFont;

        FreeScratchGC(c->pGC);
        free(c->data);
        free(c);
    }
    return TRUE;
}

int
PolyText(ClientPtr client, DrawablePtr pDraw, GC * pGC, unsigned char *pElt,
         unsigned char *endReq, int xorg, int yorg, int reqType, XID did)
{
    PTclosureRec local_closure;

    local_closure.pElt = pElt;
    local_closure.endReq = endReq;
    local_closure.client = client;
    local_closure.pDraw = pDraw;
    local_closure.xorg = xorg;
    local_closure.yorg = yorg;
    local_closure.reqType = reqType;
    local_closure.pGC = pGC;
    local_closure.did = did;
    local_closure.err = Success;

    (void) doPolyText(client, &local_closure);
    return Success;
}

#undef TextEltHeader
#undef FontShiftSize

static int
doImageText(ClientPtr client, ITclosurePtr c)
{
    int err = Success, lgerr;   /* err is in X error, not font error, space */
    FontPathElementPtr fpe;
    int itemSize = c->reqType == X_ImageText8 ? 1 : 2;

    if (client->clientGone) {
        fpe = c->pGC->font->fpe;
        (*fpe_functions[fpe->type].client_died) ((void *) client, fpe);
        err = Success;
        goto bail;
    }

    /* Make sure our drawable hasn't disappeared while we slept. */
    if (ClientIsAsleep(client) && c->pDraw) {
        DrawablePtr pDraw;

        dixLookupDrawable(&pDraw, c->did, client, 0, DixWriteAccess);
        if (c->pDraw != pDraw) {
            /* Our drawable has disappeared.  Treat like client died... ask
               the FPE code to clean up after client. */
            fpe = c->pGC->font->fpe;
            (*fpe_functions[fpe->type].client_died) ((void *) client, fpe);
            err = Success;
            goto bail;
        }
    }

    lgerr = LoadGlyphs(client, c->pGC->font, c->nChars, itemSize, c->data);
    if (lgerr == Suspended) {
        if (!ClientIsAsleep(client)) {
            GC *pGC;
            unsigned char *data;
            ITclosurePtr new_closure;
            ITclosurePtr old_closure;

            /* We're putting the client to sleep.  We need to
               save some state.  Similar problem to that handled
               in doPolyText, but much simpler because the
               request structure is much simpler. */

            new_closure = malloc(sizeof(ITclosureRec));
            if (!new_closure) {
                err = BadAlloc;
                goto bail;
            }
            old_closure = c;
            *new_closure = *c;
            c = new_closure;

            data = xallocarray(c->nChars, itemSize);
            if (!data) {
                free(c);
                c = old_closure;
                err = BadAlloc;
                goto bail;
            }
            memmove(data, c->data, c->nChars * itemSize);
            c->data = data;

            pGC = GetScratchGC(c->pGC->depth, c->pGC->pScreen);
            if (!pGC) {
                free(c->data);
                free(c);
                c = old_closure;
                err = BadAlloc;
                goto bail;
            }
            if ((err = CopyGC(c->pGC, pGC, GCFunction | GCPlaneMask |
                              GCForeground | GCBackground | GCFillStyle |
                              GCTile | GCStipple | GCTileStipXOrigin |
                              GCTileStipYOrigin | GCFont |
                              GCSubwindowMode | GCClipXOrigin |
                              GCClipYOrigin | GCClipMask)) != Success) {
                FreeScratchGC(pGC);
                free(c->data);
                free(c);
                c = old_closure;
                err = BadAlloc;
                goto bail;
            }
            c->pGC = pGC;
            ValidateGC(c->pDraw, c->pGC);

            ClientSleep(client, (ClientSleepProcPtr) doImageText, c);
        }
        return TRUE;
    }
    else if (lgerr != Successful) {
        err = FontToXError(lgerr);
        goto bail;
    }
    if (c->pDraw) {
        if (c->reqType == X_ImageText8)
            (*c->pGC->ops->ImageText8) (c->pDraw, c->pGC, c->xorg, c->yorg,
                                        c->nChars, (char *) c->data);
        else
            (*c->pGC->ops->ImageText16) (c->pDraw, c->pGC, c->xorg, c->yorg,
                                         c->nChars, (unsigned short *) c->data);
    }

 bail:

    if (err != Success && c->client != serverClient) {
        SendErrorToClient(c->client, c->reqType, 0, 0, err);
    }
    if (ClientIsAsleep(client)) {
        ClientWakeup(c->client);
        ChangeGC(NullClient, c->pGC, clearGCmask, clearGC);

        /* Unreference the font from the scratch GC */
        CloseFont(c->pGC->font, (Font) 0);
        c->pGC->font = NullFont;

        FreeScratchGC(c->pGC);
        free(c->data);
        free(c);
    }
    return TRUE;
}

int
ImageText(ClientPtr client, DrawablePtr pDraw, GC * pGC, int nChars,
          unsigned char *data, int xorg, int yorg, int reqType, XID did)
{
    ITclosureRec local_closure;

    local_closure.client = client;
    local_closure.pDraw = pDraw;
    local_closure.pGC = pGC;
    local_closure.nChars = nChars;
    local_closure.data = data;
    local_closure.xorg = xorg;
    local_closure.yorg = yorg;
    local_closure.reqType = reqType;
    local_closure.did = did;

    (void) doImageText(client, &local_closure);
    return Success;
}

/* does the necessary magic to figure out the fpe type */
static int
DetermineFPEType(const char *pathname)
{
    int i;

    for (i = 0; i < num_fpe_types; i++) {
        if ((*fpe_functions[i].name_check) (pathname))
            return i;
    }
    return -1;
}

static void
FreeFontPath(FontPathElementPtr * list, int n, Bool force)
{
    int i;

    for (i = 0; i < n; i++) {
        if (force) {
            /* Sanity check that all refcounts will be 0 by the time
               we get to the end of the list. */
            int found = 1;      /* the first reference is us */
            int j;

            for (j = i + 1; j < n; j++) {
                if (list[j] == list[i])
                    found++;
            }
            if (list[i]->refcount != found) {
                list[i]->refcount = found;      /* ensure it will get freed */
            }
        }
        FreeFPE(list[i]);
    }
    free(list);
}

static FontPathElementPtr
find_existing_fpe(FontPathElementPtr * list, int num, unsigned char *name,
                  int len)
{
    FontPathElementPtr fpe;
    int i;

    for (i = 0; i < num; i++) {
        fpe = list[i];
        if (fpe->name_length == len && memcmp(name, fpe->name, len) == 0)
            return fpe;
    }
    return (FontPathElementPtr) 0;
}

static int
SetFontPathElements(int npaths, unsigned char *paths, int *bad, Bool persist)
{
    int i, err = 0;
    int valid_paths = 0;
    unsigned int len;
    unsigned char *cp = paths;
    FontPathElementPtr fpe = NULL, *fplist;

    fplist = xallocarray(npaths, sizeof(FontPathElementPtr));
    if (!fplist) {
        *bad = 0;
        return BadAlloc;
    }
    for (i = 0; i < num_fpe_types; i++) {
        if (fpe_functions[i].set_path_hook)
            (*fpe_functions[i].set_path_hook) ();
    }
    for (i = 0; i < npaths; i++) {
        len = (unsigned int) (*cp++);

        if (len == 0) {
            if (persist)
                ErrorF
                    ("[dix] Removing empty element from the valid list of fontpaths\n");
            err = BadValue;
        }
        else {
            /* if it's already in our active list, just reset it */
            /*
             * note that this can miss FPE's in limbo -- may be worth catching
             * them, though it'd muck up refcounting
             */
            fpe = find_existing_fpe(font_path_elements, num_fpes, cp, len);
            if (fpe) {
                err = (*fpe_functions[fpe->type].reset_fpe) (fpe);
                if (err == Successful) {
                    UseFPE(fpe);        /* since it'll be decref'd later when freed
                                         * from the old list */
                }
                else
                    fpe = 0;
            }
            /* if error or can't do it, act like it's a new one */
            if (!fpe) {
                char *name;
                fpe = malloc(sizeof(FontPathElementRec));
                if (!fpe) {
                    err = BadAlloc;
                    goto bail;
                }
                name = malloc(len + 1);
                if (!name) {
                    free(fpe);
                    err = BadAlloc;
                    goto bail;
                }
                fpe->refcount = 1;

                strncpy(name, (char *) cp, (int) len);
                name[len] = '\0';
                fpe->name = name;
                fpe->name_length = len;
                fpe->type = DetermineFPEType(fpe->name);
                if (fpe->type == -1)
                    err = BadValue;
                else
                    err = (*fpe_functions[fpe->type].init_fpe) (fpe);
                if (err != Successful) {
                    if (persist) {
                        DebugF
                            ("[dix] Could not init font path element %s, removing from list!\n",
                             fpe->name);
                    }
                    free((void *) fpe->name);
                    free(fpe);
                }
            }
        }
        if (err != Successful) {
            if (!persist)
                goto bail;
        }
        else {
            fplist[valid_paths++] = fpe;
        }
        cp += len;
    }

    FreeFontPath(font_path_elements, num_fpes, FALSE);
    font_path_elements = fplist;
    if (patternCache)
        EmptyFontPatternCache(patternCache);
    num_fpes = valid_paths;

    return Success;
 bail:
    *bad = i;
    while (--valid_paths >= 0)
        FreeFPE(fplist[valid_paths]);
    free(fplist);
    return FontToXError(err);
}

int
SetFontPath(ClientPtr client, int npaths, unsigned char *paths)
{
    int err = XaceHook(XACE_SERVER_ACCESS, client, DixManageAccess);

    if (err != Success)
        return err;

    if (npaths == 0) {
        if (SetDefaultFontPath(defaultFontPath) != Success)
            return BadValue;
    }
    else {
        int bad;

        err = SetFontPathElements(npaths, paths, &bad, FALSE);
        client->errorValue = bad;
    }
    return err;
}

int
SetDefaultFontPath(const char *path)
{
    const char *start, *end;
    char *temp_path;
    unsigned char *cp, *pp, *nump, *newpath;
    int num = 1, len, err, size = 0, bad;

    /* ensure temp_path contains "built-ins" */
    start = path;
    while (1) {
        start = strstr(start, "built-ins");
        if (start == NULL)
            break;
        end = start + strlen("built-ins");
        if ((start == path || start[-1] == ',') && (!*end || *end == ','))
            break;
        start = end;
    }
    if (!start) {
        if (asprintf(&temp_path, "%s%sbuilt-ins", path, *path ? "," : "")
            == -1)
            temp_path = NULL;
    }
    else {
        temp_path = strdup(path);
    }
    if (!temp_path)
        return BadAlloc;

    /* get enough for string, plus values -- use up commas */
    len = strlen(temp_path) + 1;
    nump = cp = newpath = malloc(len);
    if (!newpath) {
        free(temp_path);
        return BadAlloc;
    }
    pp = (unsigned char *) temp_path;
    cp++;
    while (*pp) {
        if (*pp == ',') {
            *nump = (unsigned char) size;
            nump = cp++;
            pp++;
            num++;
            size = 0;
        }
        else {
            *cp++ = *pp++;
            size++;
        }
    }
    *nump = (unsigned char) size;

    err = SetFontPathElements(num, newpath, &bad, TRUE);

    free(newpath);
    free(temp_path);

    return err;
}

int
GetFontPath(ClientPtr client, int *count, int *length, unsigned char **result)
{
    int i;
    unsigned char *c;
    int len;
    FontPathElementPtr fpe;

    i = XaceHook(XACE_SERVER_ACCESS, client, DixGetAttrAccess);
    if (i != Success)
        return i;

    len = 0;
    for (i = 0; i < num_fpes; i++) {
        fpe = font_path_elements[i];
        len += fpe->name_length + 1;
    }
    c = realloc(font_path_string, len);
    if (c == NULL) {
        free(font_path_string);
        font_path_string = NULL;
        return BadAlloc;
    }

    font_path_string = c;
    *length = 0;
    for (i = 0; i < num_fpes; i++) {
        fpe = font_path_elements[i];
        *c = fpe->name_length;
        *length += *c++;
        memmove(c, fpe->name, fpe->name_length);
        c += fpe->name_length;
    }
    *count = num_fpes;
    *result = font_path_string;
    return Success;
}

void
DeleteClientFontStuff(ClientPtr client)
{
    int i;
    FontPathElementPtr fpe;

    for (i = 0; i < num_fpes; i++) {
        fpe = font_path_elements[i];
        if (fpe_functions[fpe->type].client_died)
            (*fpe_functions[fpe->type].client_died) ((void *) client, fpe);
    }
}

void
InitFonts(void)
{
    patternCache = MakeFontPatternCache();

    register_fpe_functions();
}

_X_EXPORT
int
GetDefaultPointSize(void)
{
    return 120;
}

_X_EXPORT
FontResolutionPtr
GetClientResolutions(int *num)
{
    static struct _FontResolution res;
    ScreenPtr pScreen;

    pScreen = screenInfo.screens[0];
    res.x_resolution = (pScreen->width * 25.4) / pScreen->mmWidth;
    /*
     * XXX - we'll want this as long as bitmap instances are prevalent
     so that we can match them from scalable fonts
     */
    if (res.x_resolution < 88)
        res.x_resolution = 75;
    else
        res.x_resolution = 100;
    res.y_resolution = (pScreen->height * 25.4) / pScreen->mmHeight;
    if (res.y_resolution < 88)
        res.y_resolution = 75;
    else
        res.y_resolution = 100;
    res.point_size = 120;
    *num = 1;
    return &res;
}

/*
 * returns the type index of the new fpe
 *
 * should be called (only once!) by each type of fpe when initialized
 */

_X_EXPORT
int
RegisterFPEFunctions(NameCheckFunc name_func,
                     InitFpeFunc init_func,
                     FreeFpeFunc free_func,
                     ResetFpeFunc reset_func,
                     OpenFontFunc open_func,
                     CloseFontFunc close_func,
                     ListFontsFunc list_func,
                     StartLfwiFunc start_lfwi_func,
                     NextLfwiFunc next_lfwi_func,
                     WakeupFpeFunc wakeup_func,
                     ClientDiedFunc client_died,
                     LoadGlyphsFunc load_glyphs,
                     StartLaFunc start_list_alias_func,
                     NextLaFunc next_list_alias_func, SetPathFunc set_path_func)
{
    FPEFunctions *new;

    /* grow the list */
    new = reallocarray(fpe_functions, num_fpe_types + 1, sizeof(FPEFunctions));
    if (!new)
        return -1;
    fpe_functions = new;

    fpe_functions[num_fpe_types].name_check = name_func;
    fpe_functions[num_fpe_types].open_font = open_func;
    fpe_functions[num_fpe_types].close_font = close_func;
    fpe_functions[num_fpe_types].wakeup_fpe = wakeup_func;
    fpe_functions[num_fpe_types].list_fonts = list_func;
    fpe_functions[num_fpe_types].start_list_fonts_with_info = start_lfwi_func;
    fpe_functions[num_fpe_types].list_next_font_with_info = next_lfwi_func;
    fpe_functions[num_fpe_types].init_fpe = init_func;
    fpe_functions[num_fpe_types].free_fpe = free_func;
    fpe_functions[num_fpe_types].reset_fpe = reset_func;
    fpe_functions[num_fpe_types].client_died = client_died;
    fpe_functions[num_fpe_types].load_glyphs = load_glyphs;
    fpe_functions[num_fpe_types].start_list_fonts_and_aliases =
        start_list_alias_func;
    fpe_functions[num_fpe_types].list_next_font_or_alias = next_list_alias_func;
    fpe_functions[num_fpe_types].set_path_hook = set_path_func;

    return num_fpe_types++;
}

void
FreeFonts(void)
{
    if (patternCache) {
        FreeFontPatternCache(patternCache);
        patternCache = 0;
    }
    FreeFontPath(font_path_elements, num_fpes, TRUE);
    font_path_elements = 0;
    num_fpes = 0;
    free(fpe_functions);
    num_fpe_types = 0;
    fpe_functions = (FPEFunctions *) 0;
}

/* convenience functions for FS interface */

FontPtr
find_old_font(XID id)
{
    void *pFont;

    dixLookupResourceByType(&pFont, id, RT_NONE, serverClient, DixReadAccess);
    return (FontPtr) pFont;
}

_X_EXPORT
Font
GetNewFontClientID(void)
{
    return FakeClientID(0);
}

_X_EXPORT
int
StoreFontClientFont(FontPtr pfont, Font id)
{
    return AddResource(id, RT_NONE, (void *) pfont);
}

_X_EXPORT
void
DeleteFontClientID(Font id)
{
    FreeResource(id, RT_NONE);
}

_X_EXPORT
int
client_auth_generation(ClientPtr client)
{
    return 0;
}

static int fs_handlers_installed = 0;
static unsigned int last_server_gen;

_X_EXPORT
int
init_fs_handlers(FontPathElementPtr fpe, BlockHandlerProcPtr block_handler)
{
    /* if server has reset, make sure the b&w handlers are reinstalled */
    if (last_server_gen < serverGeneration) {
        last_server_gen = serverGeneration;
        fs_handlers_installed = 0;
    }
    if (fs_handlers_installed == 0) {
        if (!RegisterBlockAndWakeupHandlers(block_handler,
                                            FontWakeup, (void *) 0))
            return AllocError;
        fs_handlers_installed++;
    }
    QueueFontWakeup(fpe);
    return Successful;
}

_X_EXPORT
void
remove_fs_handlers(FontPathElementPtr fpe, BlockHandlerProcPtr block_handler,
                   Bool all)
{
    if (all) {
        /* remove the handlers if no one else is using them */
        if (--fs_handlers_installed == 0) {
            RemoveBlockAndWakeupHandlers(block_handler, FontWakeup,
                                         (void *) 0);
        }
    }
    RemoveFontWakeup(fpe);
}
@


1.15
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d159 1
a159 1
void
d171 2
a172 3
        new = (FontPathElementPtr *)
            realloc(slept_fpes,
                    sizeof(FontPathElementPtr) * (size_slept_fpes + 4));
d182 1
a182 1
void
d198 1
a198 1
void
d423 1
a423 1
    c->fpe_list = malloc(sizeof(FontPathElementPtr) * num_fpes);
d813 1
a813 1
    c->fpe_list = malloc(sizeof(FontPathElementPtr) * num_fpes);
d842 1
a842 1
int
d1059 1
a1059 1
    c->fpe_list = malloc(sizeof(FontPathElementPtr) * num_fpes);
d1093 1
a1093 1
int
d1374 1
a1374 1
int
d1425 1
a1425 1
            data = malloc(c->nChars * itemSize);
d1578 1
a1578 1
    fplist = malloc(sizeof(FontPathElementPtr) * npaths);
d1875 1
a1875 2
    new = (FPEFunctions *) realloc(fpe_functions,
                                   (num_fpe_types + 1) * sizeof(FPEFunctions));
@


1.14
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a316 2
            else
                goto xinerama_sleep;
a363 1
 xinerama_sleep:
a595 2
                else
                    goto xinerama_sleep;
a620 2
                    else
                        goto xinerama_sleep;
a637 2
                    else
                        goto xinerama_sleep;
a781 1
 xinerama_sleep:
a880 2
                else
                    goto xinerama_sleep;
a895 2
                else
                    goto xinerama_sleep;
a1028 1
 xinerama_sleep:
a1284 2
                else
                    goto xinerama_sleep;
a1337 1
 xinerama_sleep:
a1461 2
        else
            goto xinerama_sleep;
a1483 1
 xinerama_sleep:
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d809 1
a809 1
    /* 
d1060 1
a1060 1
    /* 
d1854 1
a1854 1
     * XXX - we'll want this as long as bitmap instances are prevalent 
@


1.12
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d73 1
a73 1
extern pointer fosNaturalParams;
d131 1
a131 1
SetDefaultFont(char *defaultfontname)
d142 1
a142 1
    err = dixLookupResourceByType((pointer *) &pf, fid, RT_FONT, serverClient,
d200 1
a200 1
FontWakeup(pointer data, int count, pointer LastSelectMask)
d227 1
a227 1
        free(fpe->name);
d270 1
a270 1
            (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
d278 1
a278 1
            ((pointer) client, fpe, c->flags,
d291 1
a291 1
            newname = (char *) realloc(c->fontname, newlen);
d353 1
a353 1
    if (!AddResource(c->fontid, RT_FONT, (pointer) pfont)) {
d371 1
a371 1
    free(c->fontname);
d378 1
a378 1
         char *pfontname)
d407 1
a407 1
            if (!AddResource(fid, RT_FONT, (pointer) cached))
d429 1
a429 1
        free(c->fontname);
d456 1
a456 1
CloseFont(pointer value, XID fid)
d574 1
a574 1
            (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
d591 1
a591 1
                ((pointer) c->client, fpe, c->current.pattern,
d618 1
a618 1
                    ((pointer) c->client, fpe, c->current.pattern,
d638 1
a638 1
                    ((pointer) c->client, fpe, &name, &namelen, &tmpname,
d690 1
a690 1
                        ((pointer) c->client, fpe, &tmpname, &tmpnamelen,
d872 1
a872 1
            (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
d1121 1
a1121 1
        (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
d1126 1
a1126 1
               sleep.  Setting the drawable pointer to 0 makes this
d1147 1
a1147 1
            (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
d1168 1
a1168 1
            err = dixLookupResourceByType((pointer *) &pFont, fid, RT_FONT,
d1402 1
a1402 1
        (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
d1416 1
a1416 1
            (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
d1540 1
a1540 1
DetermineFPEType(char *pathname)
d1636 1
d1642 2
a1643 2
                fpe->name = malloc(len + 1);
                if (!fpe->name) {
d1650 3
a1652 2
                strncpy(fpe->name, (char *) cp, (int) len);
                fpe->name[len] = '\0';
d1661 1
a1661 1
                        ErrorF
d1665 1
a1665 1
                    free(fpe->name);
d1717 1
a1717 1
SetDefaultFontPath(char *path)
d1719 2
a1720 1
    char *temp_path, *start, *end;
d1825 1
a1825 1
            (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
d1943 1
a1943 1
    pointer pFont;
d1960 1
a1960 1
    return AddResource(id, RT_NONE, (pointer) pfont);
d1991 1
a1991 1
                                            FontWakeup, (pointer) 0))
d2008 1
a2008 1
                                         (pointer) 0);
@


1.11
log
@Fix from upstreams for CVE-2013-4396
Use after free in Xserver handling of ImageText requests
@
text
@d1792 4
a1795 2
    font_path_string = (unsigned char *) realloc(font_path_string, len);
    if (!font_path_string)
d1797 1
d1799 1
a1799 1
    c = font_path_string;
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d1428 1
d1440 1
d1447 1
d1458 1
d1471 1
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d118 9
d756 6
a761 5
    memset(&reply, 0, sizeof(xListFontsReply));
    reply.type = X_Reply;
    reply.length = bytes_to_int32(stringLens + nnames);
    reply.nFonts = nnames;
    reply.sequenceNumber = client->sequence;
d786 1
a786 1
    (void) WriteToClient(client, stringLens + nnames, bufferStart);
d1024 1
a1024 1
            (void) WriteToClient(client, namelen, name);
d1034 6
a1039 5
    memset((char *) &finalReply, 0, sizeof(xListFontsWithInfoReply));
    finalReply.type = X_Reply;
    finalReply.sequenceNumber = client->sequence;
    finalReply.length = bytes_to_int32(sizeof(xListFontsWithInfoReply)
                                       - sizeof(xGenericReply));
d1826 1
d1833 1
d1866 1
d1938 1
d1945 1
d1952 1
d1959 1
d1969 1
d1988 1
@


1.8
log
@Update to xserver 1.11.2
@
text
@d77 1
a77 1
static int  num_fpes = 0;
d79 1
a79 1
static int  num_fpe_types = 0;
d83 2
a84 2
static int  num_slept_fpes = 0;
static int  size_slept_fpes = 0;
d93 1
a93 1
	return Success;
d95 1
a95 1
	return BadAlloc;
d97 1
a97 1
	return BadName;
d99 1
a99 1
    case BadFontFormat:	/* is there something better? */
d101 1
a101 1
	return BadValue;
d103 1
a103 1
	return err;
d109 1
a109 1
	   unsigned char *data)
d112 2
a113 2
	return (*fpe_functions[pfont->fpe->type].load_glyphs)
	    (client, pfont, 0, nchars, item_size, data);
d115 1
a115 1
	return Successful;
d124 3
a126 3
    int         err;
    FontPtr     pf;
    XID         fid;
d130 1
a130 1
		   (unsigned) strlen(defaultfontname), defaultfontname);
d132 3
a134 3
	return FALSE;
    err = dixLookupResourceByType((pointer *)&pf, fid, RT_FONT, serverClient,
				  DixReadAccess);
d136 1
a136 1
	return FALSE;
d153 1
a153 1
    int         i;
d157 3
a159 3
	if (slept_fpes[i] == fpe) {
	    return;
	}
d162 7
a168 7
	new = (FontPathElementPtr *)
	    realloc(slept_fpes,
		     sizeof(FontPathElementPtr) * (size_slept_fpes + 4));
	if (!new)
	    return;
	slept_fpes = new;
	size_slept_fpes += 4;
d177 1
a177 2
    int         i,
                j;
d180 7
a186 7
	if (slept_fpes[i] == fpe) {
	    for (j = i; j < num_slept_fpes; j++) {
		slept_fpes[j] = slept_fpes[j + 1];
	    }
	    num_slept_fpes--;
	    return;
	}
d193 1
a193 1
    int         i;
d197 1
a197 1
	return;
d200 2
a201 2
	fpe = slept_fpes[i];
	(void) (*fpe_functions[fpe->type].wakeup_fpe) (fpe, LastSelectMask);
d213 1
a213 1
FreeFPE (FontPathElementPtr fpe)
d217 3
a219 3
	(*fpe_functions[fpe->type].free_fpe) (fpe);
	free(fpe->name);
	free(fpe);
d226 1
a226 1
    FontPtr     pfont = NullFont;
d228 7
a234 7
    ScreenPtr   pScr;
    int         err = Successful;
    int         i;
    char       *alias,
               *newname;
    int         newlen;
    int		aliascount = 20;
d238 6
a243 10
    Mask FontFormat = 

	((screenInfo.imageByteOrder == LSBFirst) ?
	    BitmapFormatByteOrderLSB : BitmapFormatByteOrderMSB) |

	((screenInfo.bitmapBitOrder == LSBFirst) ?
	    BitmapFormatBitOrderLSB : BitmapFormatBitOrderMSB) |

	BitmapFormatImageRectMin |

d245 1
a245 1
	BitmapFormatScanlinePad8 |
a246 1

d248 1
a248 1
	BitmapFormatScanlinePad16 |
a249 1

d251 1
a251 1
	BitmapFormatScanlinePad32 |
a252 1

d254 1
a254 1
	BitmapFormatScanlinePad64 |
d256 1
d258 7
a264 11
	BitmapFormatScanlineUnit8;

    if (client->clientGone)
    {
	if (c->current_fpe < c->num_fpes)
	{
	    fpe = c->fpe_list[c->current_fpe];
	    (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
	}
	err = Successful;
	goto bail;
d267 46
a312 47
	fpe = c->fpe_list[c->current_fpe];
	err = (*fpe_functions[fpe->type].open_font)
	    ((pointer) client, fpe, c->flags,
	     c->fontname, c->fnamelen, FontFormat,
	     BitmapFormatMaskByte |
	     BitmapFormatMaskBit |
	     BitmapFormatMaskImageRectangle |
	     BitmapFormatMaskScanLinePad |
	     BitmapFormatMaskScanLineUnit,
	     c->fontid, &pfont, &alias,
	     c->non_cachable_font && c->non_cachable_font->fpe == fpe ?
		 c->non_cachable_font :
		 (FontPtr)0);

	if (err == FontNameAlias && alias) {
	    newlen = strlen(alias);
	    newname = (char *) realloc(c->fontname, newlen);
	    if (!newname) {
		err = AllocError;
		break;
	    }
	    memmove(newname, alias, newlen);
	    c->fontname = newname;
	    c->fnamelen = newlen;
	    c->current_fpe = 0;
	    if (--aliascount <= 0) {
		/* We've tried resolving this alias 20 times, we're
 		 * probably stuck in an infinite loop of aliases pointing
 		 * to each other - time to take emergency exit!
 		 */
 		err = BadImplementation;
		break;
	    }
	    continue;
	}
	if (err == BadFontName) {
	    c->current_fpe++;
	    continue;
	}
	if (err == Suspended) {
	    if (!ClientIsAsleep(client))
		ClientSleep(client, (ClientSleepProcPtr)doOpenFont, c);
	    else
		goto xinerama_sleep;
	    return TRUE;
	}
	break;
d316 1
a316 1
	goto bail;
d318 2
a319 2
	err = BadFontName;
	goto bail;
d323 4
a326 4
       pfont->info.firstRow > pfont->info.lastRow ||
       pfont->info.lastCol - pfont->info.firstCol > 255) {
       err = AllocError;
       goto bail;
d329 1
a329 1
	pfont->fpe = fpe;
d332 11
a342 13
	UseFPE(pfont->fpe);
	for (i = 0; i < screenInfo.numScreens; i++) {
	    pScr = screenInfo.screens[i];
	    if (pScr->RealizeFont)
	    {
		if (!(*pScr->RealizeFont) (pScr, pfont))
		{
		    CloseFont (pfont, (Font) 0);
		    err = AllocError;
		    goto bail;
		}
	    }
	}
d345 2
a346 2
	err = AllocError;
	goto bail;
d349 3
a351 3
	CacheFontPattern(patternCache, c->origFontName, c->origFontNameLen,
			 pfont);
bail:
d353 2
a354 2
	SendErrorToClient(c->client, X_OpenFont, 0,
			  c->fontid, FontToXError(err));
d357 1
a357 1
xinerama_sleep:
d359 1
a359 1
	FreeFPE(c->fpe_list[i]);
d368 2
a369 1
OpenFont(ClientPtr client, XID fid, Mask flags, unsigned lenfname, char *pfontname)
d372 2
a373 2
    int         i;
    FontPtr     cached = (FontPtr)0;
d376 2
a377 3
	return BadName;
    if (patternCache)
    {
d379 24
a402 25
    /*
    ** Check name cache.  If we find a cached version of this font that
    ** is cachable, immediately satisfy the request with it.  If we find
    ** a cached version of this font that is non-cachable, we do not
    ** satisfy the request with it.  Instead, we pass the FontPtr to the
    ** FPE's open_font code (the fontfile FPE in turn passes the
    ** information to the rasterizer; the fserve FPE ignores it).
    **
    ** Presumably, the font is marked non-cachable because the FPE has
    ** put some licensing restrictions on it.  If the FPE, using
    ** whatever logic it relies on, determines that it is willing to
    ** share this existing font with the client, then it has the option
    ** to return the FontPtr we passed it as the newly-opened font.
    ** This allows the FPE to exercise its licensing logic without
    ** having to create another instance of a font that already exists.
    */

	cached = FindCachedFontPattern(patternCache, pfontname, lenfname);
	if (cached && cached->info.cachable)
	{
	    if (!AddResource(fid, RT_FONT, (pointer) cached))
		return BadAlloc;
	    cached->refcnt++;
	    return Success;
	}
d406 1
a406 1
	return BadAlloc;
d411 2
a412 2
	free(c);
	return BadAlloc;
d420 3
a422 3
	free(c->fontname);
	free(c);
	return BadAlloc;
d426 2
a427 2
	c->fpe_list[i] = font_path_elements[i];
	UseFPE(c->fpe_list[i]);
d449 2
a450 2
    int         nscr;
    ScreenPtr   pscr;
d452 1
a452 1
    FontPtr     pfont = (FontPtr)value;
d455 1
a455 1
	return Success;
d457 13
a469 13
	if (patternCache)
	    RemoveCachedFontPattern (patternCache, pfont);
	/*
	 * since the last reference is gone, ask each screen to free any
	 * storage it may have allocated locally for it.
	 */
	for (nscr = 0; nscr < screenInfo.numScreens; nscr++) {
	    pscr = screenInfo.screens[nscr];
	    if (pscr->UnrealizeFont)
		(*pscr->UnrealizeFont) (pscr, pfont);
	}
	if (pfont == defaultFont)
	    defaultFont = NULL;
d471 1
a471 1
	XF86BigfontFreeFontShm(pfont);
d473 3
a475 3
	fpe = pfont->fpe;
	(*fpe_functions[fpe->type].close_font) (fpe, pfont);
	FreeFPE(fpe);
a479 1

d489 1
a489 1
QueryFont(FontPtr pFont, xQueryFontReply *pReply, int nProtoCCIStructs)
d491 9
a499 11
    FontPropPtr      pFP;
    int              r,
                     c,
                     i;
    xFontProp       *prFP;
    xCharInfo       *prCI;
    xCharInfo       *charInfos[256];
    unsigned char    chars[512];
    int              ninfos;
    unsigned long    ncols;
    unsigned long    count;
d519 3
a521 4
	    i < pFont->info.nprops;
	    i++, pFP++, prFP++) {
	prFP->name = pFP->name;
	prFP->value = pFP->value;
d528 14
a541 15
	    ninfos < nProtoCCIStructs && r <= (int)pFont->info.lastRow;
	    r++) {
	i = 0;
	for (c = pFont->info.firstCol; c <= (int)pFont->info.lastCol; c++) {
	    chars[i++] = r;
	    chars[i++] = c;
	}
	(*pFont->get_metrics) (pFont, ncols, chars, 
				TwoD16Bit, &count, charInfos);
	i = 0;
	for (i = 0; i < (int) count && ninfos < nProtoCCIStructs; i++) {
	    *prCI = *charInfos[i];
	    prCI++;
	    ninfos++;
	}
d550 1
a550 1
    int         err = Successful;
d552 5
a556 5
    char       *name, *resolved=NULL;
    int         namelen, resolvedlen;
    int		nnames;
    int         stringLens;
    int         i;
d558 11
a568 13
    char	*bufptr;
    char	*bufferStart;
    int		aliascount = 0;

    if (client->clientGone)
    {
	if (c->current.current_fpe < c->num_fpes)
	{
	    fpe = c->fpe_list[c->current.current_fpe];
	    (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
	}
	err = Successful;
	goto bail;
d572 1
a572 1
	goto finish;
d575 5
a579 2
	fpe = c->fpe_list[c->current.current_fpe];
	err = Successful;
d581 147
a727 157
	if (!fpe_functions[fpe->type].start_list_fonts_and_aliases)
	{
	    /* This FPE doesn't support/require list_fonts_and_aliases */

	    err = (*fpe_functions[fpe->type].list_fonts)
		((pointer) c->client, fpe, c->current.pattern,
		 c->current.patlen, c->current.max_names - c->names->nnames,
		 c->names);

	    if (err == Suspended) {
		if (!ClientIsAsleep(client))
		    ClientSleep(client,
				(ClientSleepProcPtr)doListFontsAndAliases,
				c);
		else
		    goto xinerama_sleep;
		return TRUE;
	    }

	    err = BadFontName;
	}
	else
	{
	    /* Start of list_fonts_and_aliases functionality.  Modeled
	       after list_fonts_with_info in that it resolves aliases,
	       except that the information collected from FPEs is just
	       names, not font info.  Each list_next_font_or_alias()
	       returns either a name into name/namelen or an alias into
	       name/namelen and its target name into resolved/resolvedlen.
	       The code at this level then resolves the alias by polling
	       the FPEs.  */

	    if (!c->current.list_started) {
		err = (*fpe_functions[fpe->type].start_list_fonts_and_aliases)
		    ((pointer) c->client, fpe, c->current.pattern,
		     c->current.patlen, c->current.max_names - c->names->nnames,
		     &c->current.private);
		if (err == Suspended) {
		    if (!ClientIsAsleep(client))
			ClientSleep(client,
				    (ClientSleepProcPtr)doListFontsAndAliases,
				    c);
		    else
			goto xinerama_sleep;
		    return TRUE;
		}
		if (err == Successful)
		    c->current.list_started = TRUE;
	    }
	    if (err == Successful) {
		char    *tmpname;
		name = 0;
		err = (*fpe_functions[fpe->type].list_next_font_or_alias)
		    ((pointer) c->client, fpe, &name, &namelen, &tmpname,
		     &resolvedlen, c->current.private);
		if (err == Suspended) {
		    if (!ClientIsAsleep(client))
			ClientSleep(client,
				    (ClientSleepProcPtr)doListFontsAndAliases,
				    c);
		    else
			goto xinerama_sleep;
		    return TRUE;
		}
		if (err == FontNameAlias) {
		    free(resolved);
		    resolved = malloc(resolvedlen + 1);
		    if (resolved)
			memmove(resolved, tmpname, resolvedlen + 1);
		}
	    }

	    if (err == Successful)
	    {
		if (c->haveSaved)
		{
		    if (c->savedName)
			(void)AddFontNamesName(c->names, c->savedName,
					       c->savedNameLen);
		}
		else
		    (void)AddFontNamesName(c->names, name, namelen);
	    }

	    /*
	     * When we get an alias back, save our state and reset back to
	     * the start of the FPE looking for the specified name.  As
	     * soon as a real font is found for the alias, pop back to the
	     * old state
	     */
	    else if (err == FontNameAlias) {
		char	tmp_pattern[XLFDMAXFONTNAMELEN];
		/*
		 * when an alias recurses, we need to give
		 * the last FPE a chance to clean up; so we call
		 * it again, and assume that the error returned
		 * is BadFontName, indicating the alias resolution
		 * is complete.
		 */
		memmove(tmp_pattern, resolved, resolvedlen);
		if (c->haveSaved)
		{
		    char    *tmpname;
		    int     tmpnamelen;

		    tmpname = 0;
		    (void) (*fpe_functions[fpe->type].list_next_font_or_alias)
			((pointer) c->client, fpe, &tmpname, &tmpnamelen,
			 &tmpname, &tmpnamelen, c->current.private);
		    if (--aliascount <= 0)
		    {
			err = BadFontName;
			goto ContBadFontName;
		    }
		}
		else
		{
		    c->saved = c->current;
		    c->haveSaved = TRUE;
		    free(c->savedName);
		    c->savedName = malloc(namelen + 1);
		    if (c->savedName)
			memmove(c->savedName, name, namelen + 1);
		    c->savedNameLen = namelen;
		    aliascount = 20;
		}
		memmove(c->current.pattern, tmp_pattern, resolvedlen);
		c->current.patlen = resolvedlen;
		c->current.max_names = c->names->nnames + 1;
		c->current.current_fpe = -1;
		c->current.private = 0;
		err = BadFontName;
	    }
	}
	/*
	 * At the end of this FPE, step to the next.  If we've finished
	 * processing an alias, pop state back. If we've collected enough
	 * font names, quit.
	 */
	if (err == BadFontName) {
	  ContBadFontName: ;
	    c->current.list_started = FALSE;
	    c->current.current_fpe++;
	    err = Successful;
	    if (c->haveSaved)
	    {
		if (c->names->nnames == c->current.max_names ||
			c->current.current_fpe == c->num_fpes) {
		    c->haveSaved = FALSE;
		    c->current = c->saved;
		    /* Give the saved namelist a chance to clean itself up */
		    continue;
		}
	    }
	    if (c->names->nnames == c->current.max_names)
		break;
	}
d734 2
a735 2
	SendErrorToClient(client, X_ListFonts, 0, 0, FontToXError(err));
	goto bail;
d738 1
a738 1
finish:
d745 1
a745 1
	stringLens += (names->length[i] <= 255) ? names->length[i] : 0;
d756 2
a757 2
	SendErrorToClient(client, X_ListFonts, 0, 0, BadAlloc);
	goto bail;
d764 7
a770 8
	if (names->length[i] > 255)
	    reply.nFonts--;
	else
	{
	    *bufptr++ = names->length[i];
	    memmove( bufptr, names->names[i], names->length[i]);
	    bufptr += names->length[i];
	}
d779 1
a779 1
bail:
d781 1
a781 1
xinerama_sleep:
d783 1
a783 1
	FreeFPE(c->fpe_list[i]);
d793 1
a793 1
ListFonts(ClientPtr client, unsigned char *pattern, unsigned length, 
d796 1
a796 1
    int         i;
d806 1
a806 1
	return BadAlloc;
d810 1
a810 1
	return i;
d813 1
a813 1
	return BadAlloc;
d816 2
a817 2
	free(c);
	return BadAlloc;
d820 4
a823 5
    if (!c->names)
    {
	free(c->fpe_list);
	free(c);
	return BadAlloc;
d825 1
a825 1
    memmove( c->current.pattern, pattern, length);
d827 2
a828 2
	c->fpe_list[i] = font_path_elements[i];
	UseFPE(c->fpe_list[i]);
d847 5
a851 6
    int         err = Successful;
    char       *name;
    int         namelen;
    int         numFonts;
    FontInfoRec fontInfo,
               *pFontInfo;
d853 4
a856 4
    int         length;
    xFontProp  *pFP;
    int         i;
    int		aliascount = 0;
d859 7
a865 9
    if (client->clientGone)
    {
	if (c->current.current_fpe < c->num_fpes)
 	{
	    fpe = c->fpe_list[c->current.current_fpe];
	    (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
	}
	err = Successful;
	goto bail;
d869 152
a1020 170
	goto finish;
    while (c->current.current_fpe < c->num_fpes)
    {
	fpe = c->fpe_list[c->current.current_fpe];
	err = Successful;
	if (!c->current.list_started)
 	{
	    err = (*fpe_functions[fpe->type].start_list_fonts_with_info)
		(client, fpe, c->current.pattern, c->current.patlen,
		 c->current.max_names, &c->current.private);
	    if (err == Suspended)
 	    {
		if (!ClientIsAsleep(client))
		    ClientSleep(client,
				(ClientSleepProcPtr)doListFontsWithInfo, c);
		else
		    goto xinerama_sleep;
		return TRUE;
	    }
	    if (err == Successful)
		c->current.list_started = TRUE;
	}
	if (err == Successful)
 	{
	    name = 0;
	    pFontInfo = &fontInfo;
	    err = (*fpe_functions[fpe->type].list_next_font_with_info)
		(client, fpe, &name, &namelen, &pFontInfo,
		 &numFonts, c->current.private);
	    if (err == Suspended)
 	    {
		if (!ClientIsAsleep(client))
		    ClientSleep(client,
				(ClientSleepProcPtr)doListFontsWithInfo, c);
		else
		    goto xinerama_sleep;
		return TRUE;
	    }
	}
	/*
	 * When we get an alias back, save our state and reset back to the
	 * start of the FPE looking for the specified name.  As soon as a real
	 * font is found for the alias, pop back to the old state
	 */
	if (err == FontNameAlias)
 	{
	    /*
	     * when an alias recurses, we need to give
	     * the last FPE a chance to clean up; so we call
	     * it again, and assume that the error returned
	     * is BadFontName, indicating the alias resolution
	     * is complete.
	     */
	    if (c->haveSaved)
	    {
		char	*tmpname;
		int	tmpnamelen;
		FontInfoPtr tmpFontInfo;

	    	tmpname = 0;
	    	tmpFontInfo = &fontInfo;
	    	(void) (*fpe_functions[fpe->type].list_next_font_with_info)
		    (client, fpe, &tmpname, &tmpnamelen, &tmpFontInfo,
		     &numFonts, c->current.private);
		if (--aliascount <= 0)
		{
		    err = BadFontName;
		    goto ContBadFontName;
		}
	    }
	    else
	    {
		c->saved = c->current;
		c->haveSaved = TRUE;
		c->savedNumFonts = numFonts;
		free(c->savedName);
		c->savedName = malloc(namelen + 1);
		if (c->savedName)
		  memmove(c->savedName, name, namelen + 1);
		aliascount = 20;
	    }
	    memmove(c->current.pattern, name, namelen);
	    c->current.patlen = namelen;
	    c->current.max_names = 1;
	    c->current.current_fpe = 0;
	    c->current.private = 0;
	    c->current.list_started = FALSE;
	}
	/*
	 * At the end of this FPE, step to the next.  If we've finished
	 * processing an alias, pop state back.  If we've sent enough font
	 * names, quit.  Always wait for BadFontName to let the FPE
	 * have a chance to clean up.
	 */
	else if (err == BadFontName)
 	{
	  ContBadFontName: ;
	    c->current.list_started = FALSE;
	    c->current.current_fpe++;
	    err = Successful;
	    if (c->haveSaved)
 	    {
		if (c->current.max_names == 0 ||
			c->current.current_fpe == c->num_fpes)
 		{
		    c->haveSaved = FALSE;
		    c->saved.max_names -= (1 - c->current.max_names);
		    c->current = c->saved;
		}
	    }
	    else if (c->current.max_names == 0)
		break;
	}
 	else if (err == Successful)
 	{
	    length = sizeof(*reply) + pFontInfo->nprops * sizeof(xFontProp);
	    reply = c->reply;
	    if (c->length < length)
 	    {
		reply = (xListFontsWithInfoReply *) realloc(c->reply, length);
		if (!reply)
 		{
		    err = AllocError;
		    break;
		}
		memset((char*)reply + c->length, 0, length - c->length);
		c->reply = reply;
		c->length = length;
	    }
	    if (c->haveSaved)
 	    {
		numFonts = c->savedNumFonts;
		name = c->savedName;
		namelen = strlen(name);
	    }
	    reply->type = X_Reply;
	    reply->length = bytes_to_int32(sizeof *reply - sizeof(xGenericReply) +
			     pFontInfo->nprops * sizeof(xFontProp) +
			     namelen);
	    reply->sequenceNumber = client->sequence;
	    reply->nameLength = namelen;
	    reply->minBounds = pFontInfo->ink_minbounds;
	    reply->maxBounds = pFontInfo->ink_maxbounds;
	    reply->minCharOrByte2 = pFontInfo->firstCol;
	    reply->maxCharOrByte2 = pFontInfo->lastCol;
	    reply->defaultChar = pFontInfo->defaultCh;
	    reply->nFontProps = pFontInfo->nprops;
	    reply->drawDirection = pFontInfo->drawDirection;
	    reply->minByte1 = pFontInfo->firstRow;
	    reply->maxByte1 = pFontInfo->lastRow;
	    reply->allCharsExist = pFontInfo->allExist;
	    reply->fontAscent = pFontInfo->fontAscent;
	    reply->fontDescent = pFontInfo->fontDescent;
	    reply->nReplies = numFonts;
	    pFP = (xFontProp *) (reply + 1);
	    for (i = 0; i < pFontInfo->nprops; i++)
 	    {
		pFP->name = pFontInfo->props[i].name;
		pFP->value = pFontInfo->props[i].value;
		pFP++;
	    }
	    WriteSwappedDataToClient(client, length, reply);
	    (void) WriteToClient(client, namelen, name);
	    if (pFontInfo == &fontInfo)
 	    {
		free(fontInfo.props);
		free(fontInfo.isStringProp);
	    }
	    --c->current.max_names;
	}
d1022 1
a1022 1
finish:
d1028 1
a1028 1
		     - sizeof(xGenericReply));
d1030 1
a1030 1
bail:
d1032 1
a1032 1
xinerama_sleep:
d1034 1
a1034 1
	FreeFPE(c->fpe_list[i]);
d1043 1
a1043 1
StartListFontsWithInfo(ClientPtr client, int length, unsigned char *pattern, 
d1046 2
a1047 2
    int		    i;
    LFWIclosurePtr  c;
d1056 1
a1056 1
	return BadAlloc;
d1060 1
a1060 1
	return i;
d1063 1
a1063 1
	goto badAlloc;
d1065 3
a1067 4
    if (!c->fpe_list)
    {
	free(c);
	goto badAlloc;
d1070 3
a1072 4
    for (i = 0; i < num_fpes; i++)
    {
	c->fpe_list[i] = font_path_elements[i];
	UseFPE(c->fpe_list[i]);
d1088 1
a1088 1
badAlloc:
d1094 2
a1095 1
static ChangeGCVal clearGC[] = { { .ptr = NullPixmap } };
d1102 1
a1102 1
    int err = Success, lgerr;	/* err is in X error, not font error, space */
d1108 16
a1123 19
    if (client->clientGone)
    {
	fpe = c->pGC->font->fpe;
	(*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);

	if (ClientIsAsleep(client))
	{
	    /* Client has died, but we cannot bail out right now.  We
	       need to clean up after the work we did when going to
	       sleep.  Setting the drawable pointer to 0 makes this
	       happen without any attempts to render or perform other
	       unnecessary activities.  */
	    c->pDraw = (DrawablePtr)0;
	}
	else
	{
	    err = Success;
	    goto bail;
	}
d1127 12
a1138 12
    if (ClientIsAsleep(client) && c->pDraw)
    {
	DrawablePtr pDraw;
	dixLookupDrawable(&pDraw, c->did, client, 0, DixWriteAccess);
	if (c->pDraw != pDraw) {
	    /* Our drawable has disappeared.  Treat like client died... ask
	       the FPE code to clean up after client and avoid further
	       rendering while we clean up after ourself.  */
	    fpe = c->pGC->font->fpe;
	    (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
	    c->pDraw = (DrawablePtr)0;
	}
d1143 172
a1314 195
    while (c->endReq - c->pElt > TextEltHeader)
    {
	if (*c->pElt == FontChange)
        {
	    Font fid;
	    if (c->endReq - c->pElt < FontShiftSize)
	    {
		 err = BadLength;
		 goto bail;
	    }

	    oldpFont = pFont;

	    fid =  ((Font)*(c->pElt+4))		/* big-endian */
		 | ((Font)*(c->pElt+3)) << 8
		 | ((Font)*(c->pElt+2)) << 16
		 | ((Font)*(c->pElt+1)) << 24;
	    err = dixLookupResourceByType((pointer *)&pFont, fid, RT_FONT,
					  client, DixUseAccess);
	    if (err != Success)
	    {
		/* restore pFont for step 4 (described below) */
		pFont = oldpFont;

		/* If we're in START_SLEEP mode, the following step
		   shortens the request...  in the unlikely event that
		   the fid somehow becomes valid before we come through
		   again to actually execute the polytext, which would
		   then mess up our refcounting scheme badly.  */
		c->err = err;
		c->endReq = c->pElt;

		goto bail;
	    }

	    /* Step 3 (described below) on our new font */
	    if (client_state == START_SLEEP)
		pFont->refcnt++;
	    else
	    {
		if (pFont != c->pGC->font && c->pDraw)
		{
		    ChangeGCVal val;
		    val.ptr = pFont;
		    ChangeGC(NullClient, c->pGC, GCFont, &val);
		    ValidateGC(c->pDraw, c->pGC);
		}

		/* Undo the refcnt++ we performed when going to sleep */
		if (client_state == SLEEPING)
		    (void)CloseFont(c->pGC->font, (Font)0);
	    }
	    c->pElt += FontShiftSize;
	}
	else	/* print a string */
	{
	    unsigned char *pNextElt;
	    pNextElt = c->pElt + TextEltHeader + (*c->pElt) * itemSize;
	    if ( pNextElt > c->endReq)
	    {
		err = BadLength;
		goto bail;
	    }
	    if (client_state == START_SLEEP)
	    {
		c->pElt = pNextElt;
		continue;
	    }
	    if (c->pDraw)
	    {
		lgerr = LoadGlyphs(client, c->pGC->font, *c->pElt, itemSize,
				   c->pElt + TextEltHeader);
	    }
	    else lgerr = Successful;

	    if (lgerr == Suspended)
	    {
		if (!ClientIsAsleep(client)) {
		    int len;
		    GC *pGC;
		    PTclosurePtr new_closure;

    /*  We're putting the client to sleep.  We need to do a few things
	to ensure successful and atomic-appearing execution of the
	remainder of the request.  First, copy the remainder of the
	request into a safe malloc'd area.  Second, create a scratch GC
	to use for the remainder of the request.  Third, mark all fonts
	referenced in the remainder of the request to prevent their
	deallocation.  Fourth, make the original GC look like the
	request has completed...  set its font to the final font value
	from this request.  These GC manipulations are for the unlikely
	(but possible) event that some other client is using the GC.
	Steps 3 and 4 are performed by running this procedure through
	the remainder of the request in a special no-render mode
	indicated by client_state = START_SLEEP.  */

		    /* Step 1 */
		    /* Allocate a malloc'd closure structure to replace
		       the local one we were passed */
		    new_closure = malloc(sizeof(PTclosureRec));
		    if (!new_closure)
		    {
			err = BadAlloc;
			goto bail;
		    }
		    *new_closure = *c;

		    len = new_closure->endReq - new_closure->pElt;
		    new_closure->data = malloc(len);
		    if (!new_closure->data)
		    {
			free(new_closure);
			err = BadAlloc;
			goto bail;
		    }
		    memmove(new_closure->data, new_closure->pElt, len);
		    new_closure->pElt = new_closure->data;
		    new_closure->endReq = new_closure->pElt + len;

		    /* Step 2 */

		    pGC = GetScratchGC(new_closure->pGC->depth, new_closure->pGC->pScreen);
		    if (!pGC)
		    {
			free(new_closure->data);
			free(new_closure);
			err = BadAlloc;
			goto bail;
		    }
		    if ((err = CopyGC(new_closure->pGC, pGC, GCFunction |
				      GCPlaneMask | GCForeground |
				      GCBackground | GCFillStyle |
				      GCTile | GCStipple |
				      GCTileStipXOrigin |
				      GCTileStipYOrigin | GCFont |
				      GCSubwindowMode | GCClipXOrigin |
				      GCClipYOrigin | GCClipMask)) !=
				      Success)
		    {
			FreeScratchGC(pGC);
			free(new_closure->data);
			free(new_closure);
			err = BadAlloc;
			goto bail;
		    }
		    c = new_closure;
		    origGC = c->pGC;
		    c->pGC = pGC;
		    ValidateGC(c->pDraw, c->pGC);

		    ClientSleep(client, (ClientSleepProcPtr)doPolyText, c);

		    /* Set up to perform steps 3 and 4 */
		    client_state = START_SLEEP;
		    continue;	/* on to steps 3 and 4 */
		}
		else
		    goto xinerama_sleep;
		return TRUE;
	    }
	    else if (lgerr != Successful)
	    {
		err = FontToXError(lgerr);
		goto bail;
	    }
	    if (c->pDraw)
	    {
		c->xorg += *((INT8 *)(c->pElt + 1));	/* must be signed */
		if (c->reqType == X_PolyText8)
		    c->xorg = (* c->pGC->ops->PolyText8)(c->pDraw, c->pGC, c->xorg, c->yorg,
			*c->pElt, (char *) (c->pElt + TextEltHeader));
		else
		    c->xorg = (* c->pGC->ops->PolyText16)(c->pDraw, c->pGC, c->xorg, c->yorg,
			*c->pElt, (unsigned short *) (c->pElt + TextEltHeader));
	    }
	    c->pElt = pNextElt;
	}
    }

bail:

    if (client_state == START_SLEEP)
    {
	/* Step 4 */
	if (pFont != origGC->font)
	{
	    ChangeGCVal val;
	    val.ptr = pFont;
	    ChangeGC(NullClient, origGC, GCFont, &val);
	    ValidateGC(c->pDraw, origGC);
	}

	/* restore pElt pointer for execution of remainder of the request */
	c->pElt = c->data;
	return TRUE;
d1317 19
a1335 1
    if (c->err != Success) err = c->err;
d1340 1
a1340 1
	    SendErrorToClient(c->client, c->reqType, 0, 0, err);
d1342 12
a1353 13
    if (ClientIsAsleep(client))
    {
	ClientWakeup(c->client);
xinerama_sleep:
	ChangeGC(NullClient, c->pGC, clearGCmask, clearGC);

	/* Unreference the font from the scratch GC */
	CloseFont(c->pGC->font, (Font)0);
	c->pGC->font = NullFont;

	FreeScratchGC(c->pGC);
	free(c->data);
	free(c);
d1359 1
a1359 1
PolyText(ClientPtr client, DrawablePtr pDraw, GC *pGC, unsigned char *pElt, 
a1378 1

d1385 1
a1385 1
    int err = Success, lgerr;	/* err is in X error, not font error, space */
d1389 5
a1393 6
    if (client->clientGone)
    {
	fpe = c->pGC->font->fpe;
	(*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
	err = Success;
	goto bail;
d1397 12
a1408 12
    if (ClientIsAsleep(client) && c->pDraw)
    {
	DrawablePtr pDraw;
	dixLookupDrawable(&pDraw, c->did, client, 0, DixWriteAccess);
	if (c->pDraw != pDraw) {
	    /* Our drawable has disappeared.  Treat like client died... ask
	       the FPE code to clean up after client. */
	    fpe = c->pGC->font->fpe;
	    (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
	    err = Success;
	    goto bail;
	}
d1412 1
a1412 2
    if (lgerr == Suspended)
    {
d1414 47
a1460 51
	    GC *pGC;
	    unsigned char *data;
	    ITclosurePtr new_closure;

	    /* We're putting the client to sleep.  We need to
	       save some state.  Similar problem to that handled
	       in doPolyText, but much simpler because the
	       request structure is much simpler. */

	    new_closure = malloc(sizeof(ITclosureRec));
	    if (!new_closure)
	    {
		err = BadAlloc;
		goto bail;
	    }
	    *new_closure = *c;
	    c = new_closure;

	    data = malloc(c->nChars * itemSize);
	    if (!data)
	    {
		free(c);
		err = BadAlloc;
		goto bail;
	    }
	    memmove(data, c->data, c->nChars * itemSize);
	    c->data = data;

	    pGC = GetScratchGC(c->pGC->depth, c->pGC->pScreen);
	    if (!pGC)
	    {
		free(c->data);
		free(c);
		err = BadAlloc;
		goto bail;
	    }
	    if ((err = CopyGC(c->pGC, pGC, GCFunction | GCPlaneMask |
			      GCForeground | GCBackground | GCFillStyle |
			      GCTile | GCStipple | GCTileStipXOrigin |
			      GCTileStipYOrigin | GCFont |
			      GCSubwindowMode | GCClipXOrigin |
			      GCClipYOrigin | GCClipMask)) != Success)
	    {
		FreeScratchGC(pGC);
		free(c->data);
		free(c);
		err = BadAlloc;
		goto bail;
	    }
	    c->pGC = pGC;
	    ValidateGC(c->pDraw, c->pGC);
d1462 1
a1462 1
            ClientSleep(client, (ClientSleepProcPtr)doImageText, c);
d1464 2
a1465 2
	else
	    goto xinerama_sleep;
d1468 1
a1468 2
    else if (lgerr != Successful)
    {
d1472 7
a1478 8
    if (c->pDraw)
    {
	if (c->reqType == X_ImageText8)
	    (* c->pGC->ops->ImageText8)(c->pDraw, c->pGC, c->xorg, c->yorg,
		c->nChars, (char *) c->data);
	else
	    (* c->pGC->ops->ImageText16)(c->pDraw, c->pGC, c->xorg, c->yorg,
		c->nChars, (unsigned short *) c->data);
d1481 1
a1481 1
bail:
d1484 1
a1484 1
	SendErrorToClient(c->client, c->reqType, 0, 0, err);
d1486 12
a1497 13
    if (ClientIsAsleep(client))
    {
	ClientWakeup(c->client);
xinerama_sleep:
	ChangeGC(NullClient, c->pGC, clearGCmask, clearGC);

	/* Unreference the font from the scratch GC */
	CloseFont(c->pGC->font, (Font)0);
	c->pGC->font = NullFont;

	FreeScratchGC(c->pGC);
	free(c->data);
	free(c);
d1503 1
a1503 1
ImageText(ClientPtr client, DrawablePtr pDraw, GC *pGC, int nChars, 
a1521 1

d1526 1
a1526 1
    int         i;
d1529 2
a1530 2
	if ((*fpe_functions[i].name_check) (pathname))
	    return i;
a1534 1

d1536 1
a1536 1
FreeFontPath(FontPathElementPtr *list, int n, Bool force)
d1538 1
a1538 1
    int         i;
d1541 15
a1555 14
	if (force) {
	    /* Sanity check that all refcounts will be 0 by the time
	       we get to the end of the list. */
	    int found = 1;	/* the first reference is us */
	    int j;
	    for (j = i+1; j < n; j++) {
		if (list[j] == list[i])
		    found++;
	    }
	    if (list[i]->refcount != found) {
		list[i]->refcount = found; /* ensure it will get freed */
	    }
	}
	FreeFPE(list[i]);
d1561 2
a1562 1
find_existing_fpe(FontPathElementPtr *list, int num, unsigned char *name, int len)
d1565 1
a1565 1
    int         i;
d1568 3
a1570 3
	fpe = list[i];
	if (fpe->name_length == len && memcmp(name, fpe->name, len) == 0)
	    return fpe;
a1574 1

d1578 2
a1579 2
    int         i, err = 0;
    int         valid_paths = 0;
d1586 2
a1587 2
	*bad = 0;
	return BadAlloc;
d1590 2
a1591 2
	if (fpe_functions[i].set_path_hook)
	    (*fpe_functions[i].set_path_hook) ();
d1593 67
a1659 77
    for (i = 0; i < npaths; i++) 
    {
	len = (unsigned int) (*cp++);

	if (len == 0) 
	{
	    if (persist)
		ErrorF("[dix] Removing empty element from the valid list of fontpaths\n");
	    err = BadValue;
	}
	else
	{
	    /* if it's already in our active list, just reset it */
	    /*
	     * note that this can miss FPE's in limbo -- may be worth catching
	     * them, though it'd muck up refcounting
	     */
	    fpe = find_existing_fpe(font_path_elements, num_fpes, cp, len);
	    if (fpe) 
	    {
		err = (*fpe_functions[fpe->type].reset_fpe) (fpe);
		if (err == Successful) 
		{
		    UseFPE(fpe);/* since it'll be decref'd later when freed
				 * from the old list */
		}
		else
		    fpe = 0;
	    }
	    /* if error or can't do it, act like it's a new one */
	    if (!fpe)
	    {
		fpe = malloc(sizeof(FontPathElementRec));
		if (!fpe) 
		{
		    err = BadAlloc;
		    goto bail;
		}
		fpe->name = malloc(len + 1);
		if (!fpe->name) 
		{
		    free(fpe);
		    err = BadAlloc;
		    goto bail;
		}
		fpe->refcount = 1;
    
		strncpy(fpe->name, (char *) cp, (int) len);
		fpe->name[len] = '\0';
		fpe->name_length = len;
		fpe->type = DetermineFPEType(fpe->name);
		if (fpe->type == -1)
		    err = BadValue;
		else
		    err = (*fpe_functions[fpe->type].init_fpe) (fpe);
		if (err != Successful)
		{
		    if (persist)
		    {
			ErrorF("[dix] Could not init font path element %s, removing from list!\n",
			       fpe->name);
		    }
		    free(fpe->name);
		    free(fpe);
		}
	    }
	}
	if (err != Successful)
	{
	    if (!persist)
		goto bail;
	}
	else
	{
	    fplist[valid_paths++] = fpe;
	}
	cp += len;
d1665 1
a1665 1
	EmptyFontPatternCache(patternCache);
d1669 1
a1669 1
bail:
d1672 1
a1672 1
	FreeFPE(fplist[valid_paths]);
d1681 1
d1683 1
a1683 1
	return err;
d1686 8
a1693 6
	if (SetDefaultFontPath(defaultFontPath) != Success)
	    return BadValue;
    } else {
	int bad;
	err = SetFontPathElements(npaths, paths, &bad, FALSE);
	client->errorValue = bad;
d1701 3
a1703 12
    char       *temp_path,
               *start,
               *end;
    unsigned char *cp,
               *pp,
               *nump,
               *newpath;
    int         num = 1,
                len,
                err,
                size = 0,
                bad;
d1708 7
a1714 7
	start = strstr(start, "built-ins");
	if (start == NULL)
	    break;
	end = start + strlen("built-ins");
	if ((start == path || start[-1] == ',') && (!*end || *end == ','))
	    break;
	start = end;
d1717 6
a1722 5
	if (asprintf(&temp_path, "%s%sbuilt-ins", path, *path ? "," : "")
	    == -1)
	    temp_path = NULL;
    } else {
	temp_path = strdup(path);
d1731 2
a1732 2
	free(temp_path);
	return BadAlloc;
d1737 11
a1747 10
	if (*pp == ',') {
	    *nump = (unsigned char) size;
	    nump = cp++;
	    pp++;
	    num++;
	    size = 0;
	} else {
	    *cp++ = *pp++;
	    size++;
	}
d1762 4
a1765 4
    int			i;
    unsigned char       *c;
    int			len;
    FontPathElementPtr	fpe;
d1769 1
a1769 1
	return i;
d1773 2
a1774 2
	fpe = font_path_elements[i];
	len += fpe->name_length + 1;
d1778 1
a1778 1
	return BadAlloc;
d1783 5
a1787 5
	fpe = font_path_elements[i];
	*c = fpe->name_length;
	*length += *c++;
	memmove(c, fpe->name, fpe->name_length);
	c += fpe->name_length;
d1797 2
a1798 2
    int			i;
    FontPathElementPtr	fpe;
d1800 4
a1803 5
    for (i = 0; i < num_fpes; i++)
    {
	fpe = font_path_elements[i];
	if (fpe_functions[fpe->type].client_died)
	    (*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
d1808 1
a1808 1
InitFonts (void)
d1816 1
a1816 1
GetDefaultPointSize (void)
a1820 1

d1822 1
a1822 1
GetClientResolutions (int *num)
d1825 1
a1825 1
    ScreenPtr   pScreen;
d1834 1
a1834 1
	res.x_resolution = 75;
d1836 1
a1836 1
	res.x_resolution = 100;
d1839 1
a1839 1
	res.y_resolution = 75;
d1841 1
a1841 1
	res.y_resolution = 100;
d1854 14
a1867 15
RegisterFPEFunctions(NameCheckFunc name_func, 
		     InitFpeFunc init_func, 
		     FreeFpeFunc free_func, 
		     ResetFpeFunc reset_func, 
		     OpenFontFunc open_func, 
		     CloseFontFunc close_func, 
		     ListFontsFunc list_func, 
		     StartLfwiFunc start_lfwi_func, 
		     NextLfwiFunc next_lfwi_func, 
		     WakeupFpeFunc wakeup_func, 
		     ClientDiedFunc client_died, 
		     LoadGlyphsFunc load_glyphs, 
		     StartLaFunc start_list_alias_func, 
		     NextLaFunc next_list_alias_func, 
		     SetPathFunc set_path_func)
d1873 1
a1873 1
				 (num_fpe_types + 1) * sizeof(FPEFunctions));
d1875 1
a1875 1
	return -1;
d1883 2
a1884 4
    fpe_functions[num_fpe_types].start_list_fonts_with_info =
	start_lfwi_func;
    fpe_functions[num_fpe_types].list_next_font_with_info =
	next_lfwi_func;
d1891 2
a1892 3
	start_list_alias_func;
    fpe_functions[num_fpe_types].list_next_font_or_alias =
	next_list_alias_func;
d1902 2
a1903 2
	FreeFontPatternCache(patternCache);
	patternCache = 0;
d1919 1
d1921 1
a1921 1
    return (FontPtr)pFont;
d1948 1
a1948 1
static int  fs_handlers_installed = 0;
d1956 2
a1957 2
	last_server_gen = serverGeneration;
	fs_handlers_installed = 0;
d1960 4
a1963 4
	if (!RegisterBlockAndWakeupHandlers(block_handler,
					    FontWakeup, (pointer) 0))
	    return AllocError;
	fs_handlers_installed++;
d1970 2
a1971 1
remove_fs_handlers(FontPathElementPtr fpe, BlockHandlerProcPtr block_handler, Bool all)
d1974 5
a1978 5
	/* remove the handlers if no one else is using them */
	if (--fs_handlers_installed == 0) {
	    RemoveBlockAndWakeupHandlers(block_handler, FontWakeup,
					 (pointer) 0);
	}
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a68 4
#ifdef DEBUG
#include	<stdio.h>
#endif

a72 2
#define QUERYCHARINFO(pci, pr)  *(pr) = (pci)->metrics

a387 8
#ifdef FONTDEBUG
    char *f;
    f = malloc(lenfname + 1);
    memmove(f, pfontname, lenfname);
    f[lenfname] = '\0';
    ErrorF("[dix] OpenFont: fontname is \"%s\"\n", f);
    free(f);
#endif
d656 1
a656 1
		    if (ClientIsAsleep(client))
d1159 1
a1244 4
		    if (c->reqType == X_PolyText8)
			c->polyText = (PolyTextPtr) c->pGC->ops->PolyText8;
		    else
			c->polyText = (PolyTextPtr) c->pGC->ops->PolyText16;
d1256 1
a1256 1
	    pNextElt = c->pElt + TextEltHeader + (*c->pElt)*c->itemSize;
d1269 1
a1269 1
		lgerr = LoadGlyphs(client, c->pGC->font, *c->pElt, c->itemSize,
a1304 1
		    c = new_closure;
d1306 3
a1308 3
		    len = c->endReq - c->pElt;
		    c->data = malloc(len);
		    if (!c->data)
d1310 1
a1310 1
			free(c);
d1314 3
a1316 3
		    memmove(c->data, c->pElt, len);
		    c->pElt = c->data;
		    c->endReq = c->pElt + len;
d1320 1
a1320 1
		    pGC = GetScratchGC(c->pGC->depth, c->pGC->pScreen);
d1323 2
a1324 2
			free(c->data);
			free(c);
d1328 1
a1328 1
		    if ((err = CopyGC(c->pGC, pGC, GCFunction |
d1339 2
a1340 2
			free(c->data);
			free(c);
d1344 1
d1348 1
a1348 1
		    
d1367 6
a1372 2
		c->xorg = (* c->polyText)(c->pDraw, c->pGC, c->xorg, c->yorg,
		    *c->pElt, c->pElt + TextEltHeader);
d1432 1
a1432 10
    if ((local_closure.reqType = reqType) == X_PolyText8)
    {
	local_closure.polyText = (PolyTextPtr) pGC->ops->PolyText8;
	local_closure.itemSize = 1;
    }
    else
    {
	local_closure.polyText =  (PolyTextPtr) pGC->ops->PolyText16;
	local_closure.itemSize = 2;
    }
d1450 1
d1475 1
a1475 1
    lgerr = LoadGlyphs(client, c->pGC->font, c->nChars, c->itemSize, c->data);
d1497 1
a1497 1
	    data = malloc(c->nChars * c->itemSize);
d1504 1
a1504 1
	    memmove(data, c->data, c->nChars * c->itemSize);
d1544 6
a1549 2
	(* c->imageText)(c->pDraw, c->pGC, c->xorg, c->yorg,
	    c->nChars, c->data);
d1587 1
a1587 10
    if ((local_closure.reqType = reqType) == X_ImageText8)
    {
	local_closure.imageText = (ImageTextPtr) pGC->ops->ImageText8;
	local_closure.itemSize = 1;
    }
    else
    {
	local_closure.imageText = (ImageTextPtr) pGC->ops->ImageText16;
	local_closure.itemSize = 2;
    }
d1806 3
a1808 1
	temp_path = Xprintf("%s%sbuilt-ins", path, *path ? "," : "");
d1818 2
a1819 1
    if (!newpath)
d1821 1
@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d169 1
a169 1
	    xrealloc(slept_fpes,
d225 2
a226 2
	xfree(fpe->name);
	xfree(fpe);
d300 1
a300 1
	    newname = (char *) xrealloc(c->fontname, newlen);
d324 4
a327 4
	    if (!c->slept) {
		c->slept = TRUE;
		ClientSleep(client, (ClientSleepProcPtr)doOpenFont, (pointer) c);
	    }
d376 2
a377 2
    if (c->slept)
	ClientWakeup(c->client);
d381 3
a383 3
    xfree(c->fpe_list);
    xfree(c->fontname);
    xfree(c);
d396 1
a396 1
    f = xalloc(lenfname + 1);
d400 1
a400 1
    xfree(f);
d433 1
a433 1
    c = xalloc(sizeof(OFclosureRec));
d436 1
a436 1
    c->fontname = xalloc(lenfname);
d440 1
a440 1
	xfree(c);
d447 1
a447 1
    c->fpe_list = xalloc(sizeof(FontPathElementPtr) * num_fpes);
d449 2
a450 2
	xfree(c->fontname);
	xfree(c);
a462 1
    c->slept = FALSE;
d484 1
a484 1
	return (Success);
d506 1
a506 1
    return (Success);
d624 1
a624 2
		if (!c->slept) {
		    c->slept = TRUE;
d626 4
a629 3
			(ClientSleepProcPtr)doListFontsAndAliases,
			(pointer) c);
		}
d652 1
a652 1
		    if (!c->slept) {
d655 3
a657 3
				    (pointer) c);
			c->slept = TRUE;
		    }
d670 1
a670 1
		    if (!c->slept) {
d673 3
a675 3
				    (pointer) c);
			c->slept = TRUE;
		    }
d679 2
a680 2
		    if (resolved) xfree(resolved);
		    resolved = xalloc(resolvedlen + 1);
d733 2
a734 3
		    if (c->savedName)
			xfree(c->savedName);
		    c->savedName = xalloc(namelen + 1);
d796 1
a796 1
    bufptr = bufferStart = xalloc(reply.length << 2);
d821 1
a821 1
    xfree(bufferStart);
d824 2
a825 2
    if (c->slept)
	ClientWakeup(client);
d828 2
a829 2
    xfree(c->fpe_list);
    if (c->savedName) xfree(c->savedName);
d831 2
a832 2
    xfree(c);
    if (resolved) xfree(resolved);
d856 1
a856 1
    if (!(c = xalloc(sizeof *c)))
d858 1
a858 1
    c->fpe_list = xalloc(sizeof(FontPathElementPtr) * num_fpes);
d860 1
a860 1
	xfree(c);
d866 2
a867 2
	xfree(c->fpe_list);
	xfree(c);
a882 1
    c->slept = FALSE;
d929 5
a933 5
		if (!c->slept)
 		{
		    ClientSleep(client, (ClientSleepProcPtr)doListFontsWithInfo, c);
		    c->slept = TRUE;
		}
d948 1
a948 2
		if (!c->slept)
 		{
d950 3
a952 4
		    	     (ClientSleepProcPtr)doListFontsWithInfo,
			     c);
		    c->slept = TRUE;
		}
d992 2
a993 3
		if (c->savedName)
		  xfree(c->savedName);
		c->savedName = xalloc(namelen + 1);
d1036 1
a1036 1
		reply = (xListFontsWithInfoReply *) xrealloc(c->reply, length);
d1082 2
a1083 2
		xfree(fontInfo.props);
		xfree(fontInfo.isStringProp);
d1090 1
a1090 1
    bzero((char *) &finalReply, sizeof(xListFontsWithInfoReply));
d1097 2
a1098 2
    if (c->slept)
	ClientWakeup(client);
d1101 4
a1104 4
    xfree(c->reply);
    xfree(c->fpe_list);
    if (c->savedName) xfree(c->savedName);
    xfree(c);
d1128 1
a1128 1
    if (!(c = xalloc(sizeof *c)))
d1130 1
a1130 1
    c->fpe_list = xalloc(sizeof(FontPathElementPtr) * num_fpes);
d1133 1
a1133 1
	xfree(c);
a1152 1
    c->slept = FALSE;
d1162 1
a1162 1
static XID clearGC[] = { CT_NONE };
a1168 1
    Font	fid, oldfid;
d1179 1
a1179 1
	if (c->slept)
d1196 1
a1196 1
    if (c->slept && c->pDraw)
d1210 1
a1210 1
    client_state = c->slept ? SLEEPING : NEVER_SLEPT;
d1216 1
a1223 1
	    oldfid = fid;
d1230 1
a1230 1
					  client, DixReadAccess);
d1233 1
a1233 2
		err = (err == BadValue) ? BadFont : err;
		/* restore pFont and fid for step 4 (described below) */
a1234 1
		fid = oldfid;
d1254 3
a1256 1
		    ChangeGC( c->pGC, GCFont, &fid);
d1293 1
a1293 1
		if (!c->slept) {
d1315 1
a1315 1
		    new_closure = xalloc(sizeof(PTclosureRec));
d1325 1
a1325 1
		    c->data = xalloc(len);
d1328 1
a1328 1
			xfree(c);
d1341 2
a1342 2
			xfree(c->data);
			xfree(c);
d1357 2
a1358 2
			xfree(c->data);
			xfree(c);
d1366 1
a1366 4
		    c->slept = TRUE;
		    ClientSleep(client,
		    	     (ClientSleepProcPtr)doPolyText,
			     (pointer) c);
d1372 2
d1398 3
a1400 1
	    ChangeGC(origGC, GCFont, &fid);
d1416 1
a1416 1
    if (c->slept)
d1419 2
a1420 1
	ChangeGC(c->pGC, clearGCmask, clearGC);
d1427 2
a1428 2
	xfree(c->data);
	xfree(c);
a1457 1
    local_closure.slept = FALSE;
d1482 1
a1482 1
    if (c->slept && c->pDraw)
d1499 1
a1499 1
        if (!c->slept) {
d1509 1
a1509 1
	    new_closure = xalloc(sizeof(ITclosureRec));
d1518 1
a1518 1
	    data = xalloc(c->nChars * c->itemSize);
d1521 1
a1521 1
		xfree(c);
d1531 2
a1532 2
		xfree(c->data);
		xfree(c);
d1544 2
a1545 2
		xfree(c->data);
		xfree(c);
d1552 1
a1552 2
	    c->slept = TRUE;
            ClientSleep(client, (ClientSleepProcPtr)doImageText, (pointer) c);
d1554 2
d1574 1
a1574 1
    if (c->slept)
d1577 2
a1578 1
	ChangeGC(c->pGC, clearGCmask, clearGC);
d1585 2
a1586 2
	xfree(c->data);
	xfree(c);
a1614 1
    local_closure.slept = FALSE;
d1656 1
a1656 1
    xfree(list);
d1683 1
a1683 1
    fplist = xalloc(sizeof(FontPathElementPtr) * npaths);
d1724 1
a1724 1
		fpe = xalloc(sizeof(FontPathElementRec));
d1730 1
a1730 1
		fpe->name = xalloc(len + 1);
d1733 1
a1733 1
		    xfree(fpe);
d1754 2
a1755 2
		    xfree (fpe->name);
		    xfree (fpe);
d1782 1
a1782 1
    xfree(fplist);
a1785 1
/* XXX -- do we need to pass error down to each renderer? */
d1787 1
a1787 1
SetFontPath(ClientPtr client, int npaths, unsigned char *paths, int *error)
d1797 3
a1799 1
	err = SetFontPathElements(npaths, paths, error, FALSE);
d1834 1
a1834 1
	temp_path = Xstrdup(path);
d1841 1
a1841 1
    nump = cp = newpath = xalloc(len);
d1862 2
a1863 2
    xfree(newpath);
    xfree(temp_path);
d1885 1
a1885 1
    font_path_string = (unsigned char *) xrealloc(font_path_string, len);
d1922 1
a1922 3
    BuiltinRegisterFpeFunctions();
    FontFileRegisterFpeFunctions();
    fs_register_fpe_functions();
d1984 1
a1984 1
    new = (FPEFunctions *) xrealloc(fpe_functions,
d2023 1
a2023 1
    xfree(fpe_functions);
@


1.5
log
@Update to server 1.6.5.
@
text
@a50 1
#define NEED_REPLIES
a72 4
#ifdef PANORAMIX
#include "panoramiX.h"
#endif

d74 1
a74 2
#define _XF86BIGFONT_SERVER_
#include <X11/extensions/xf86bigfont.h>
d139 3
a141 2
    pf = (FontPtr) LookupIDByType(fid, RT_FONT);
    if (pf == (FontPtr) NULL)
d396 1
a396 1
    f = (char *)xalloc(lenfname + 1);
d433 1
a433 1
    c = (OFclosurePtr) xalloc(sizeof(OFclosureRec));
d436 1
a436 1
    c->fontname = (char *) xalloc(lenfname);
d447 1
a447 2
    c->fpe_list = (FontPathElementPtr *)
	xalloc(sizeof(FontPathElementPtr) * num_fpes);
d681 1
a681 1
		    resolved = (char *) xalloc(resolvedlen + 1);
d736 1
a736 1
		    c->savedName = (char *)xalloc(namelen + 1);
d792 1
d794 1
a794 1
    reply.length = (stringLens + nnames + 3) >> 2;
d798 1
a798 1
    bufptr = bufferStart = (char *) xalloc(reply.length << 2);
d819 1
a819 1
    reply.length = (stringLens + nnames + 3) >> 2;
d858 1
a858 1
    if (!(c = (LFclosurePtr) xalloc(sizeof *c)))
d860 1
a860 2
    c->fpe_list = (FontPathElementPtr *)
	xalloc(sizeof(FontPathElementPtr) * num_fpes);
d999 1
a999 1
		c->savedName = (char *)xalloc(namelen + 1);
d1048 1
d1059 1
a1059 1
	    reply->length = (sizeof *reply - sizeof(xGenericReply) +
d1061 1
a1061 1
			     namelen + 3) >> 2;
d1099 2
a1100 2
    finalReply.length = (sizeof(xListFontsWithInfoReply)
		     - sizeof(xGenericReply)) >> 2;
d1134 1
a1134 1
    if (!(c = (LFWIclosurePtr) xalloc(sizeof *c)))
d1136 1
a1136 2
    c->fpe_list = (FontPathElementPtr *)
	xalloc(sizeof(FontPathElementPtr) * num_fpes);
d1204 12
a1215 11
    if (c->slept &&
	c->pDraw &&
	c->pDraw != (DrawablePtr)SecurityLookupIDByClass(client, c->did,
					RC_DRAWABLE, DixWriteAccess))
    {
	/* Our drawable has disappeared.  Treat like client died... ask
	   the FPE code to clean up after client and avoid further
	   rendering while we clean up after ourself.  */
	fpe = c->pGC->font->fpe;
	(*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
	c->pDraw = (DrawablePtr)0;
d1237 3
a1239 3
	    pFont = (FontPtr)SecurityLookupIDByType(client, fid, RT_FONT,
						    DixReadAccess);
	    if (!pFont)
d1241 1
a1241 2
		client->errorValue = fid;
		err = BadFont;
d1323 1
a1323 1
		    new_closure = (PTclosurePtr) xalloc(sizeof(PTclosureRec));
d1333 1
a1333 1
		    c->data = (unsigned char *)xalloc(len);
d1489 1
a1489 4
    if (c->slept &&
	c->pDraw &&
	c->pDraw != (DrawablePtr)SecurityLookupIDByClass(client, c->did,
					RC_DRAWABLE, DixWriteAccess))
d1491 10
a1500 6
	/* Our drawable has disappeared.  Treat like client died... ask
	   the FPE code to clean up after client. */
	fpe = c->pGC->font->fpe;
	(*fpe_functions[fpe->type].client_died) ((pointer) client, fpe);
	err = Success;
	goto bail;
d1516 1
a1516 1
	    new_closure = (ITclosurePtr) xalloc(sizeof(ITclosureRec));
d1525 1
a1525 1
	    data = (unsigned char *)xalloc(c->nChars * c->itemSize);
d1662 1
a1662 1
    xfree((char *) list);
d1689 1
a1689 2
    fplist = (FontPathElementPtr *)
	xalloc(sizeof(FontPathElementPtr) * npaths);
d1730 1
a1730 1
		fpe = (FontPathElementPtr) xalloc(sizeof(FontPathElementRec));
d1736 1
a1736 1
		fpe->name = (char *) xalloc(len + 1);
d1933 1
a1933 1
GetDefaultPointSize ()
d2040 3
a2042 2
    return (FontPtr) SecurityLookupIDByType(NullClient, id, RT_NONE,
					    DixUnknownAccess);
d2046 1
a2046 1
GetNewFontClientID()
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d1818 3
d1831 19
d1851 2
a1852 2
    len = strlen(path) + 1;
    nump = cp = newpath = (unsigned char *) xalloc(len);
d1855 1
a1855 1
    pp = (unsigned char *) path;
d1874 1
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d90 1
a90 1
_X_EXPORT FPEFunctions *fpe_functions = (FPEFunctions *) 0;
d100 2
a101 3
_X_EXPORT int
FontToXError(err)
    int         err;
d119 10
d314 6
a319 1
	    if (--aliascount <= 0)
d321 1
d404 1
a404 1
    ErrorF("OpenFont: fontname is \"%s\"\n", f);
d482 1
a482 1
_X_EXPORT int
d1711 1
a1711 1
		ErrorF ("Removing empty element from the valid list of fontpaths\n");
d1763 1
a1763 1
			ErrorF("Could not init font path element %s, removing from list!\n",
a1890 10
_X_EXPORT int
LoadGlyphs(ClientPtr client, FontPtr pfont, unsigned nchars, int item_size, unsigned char *data)
{
    if (fpe_functions[pfont->fpe->type].load_glyphs)
	return (*fpe_functions[pfont->fpe->type].load_glyphs)
	    (client, pfont, 0, nchars, item_size, data);
    else
	return Successful;
}

d1910 3
a1912 17
#ifndef BUILTIN_FONTS
    if (screenInfo.numScreens > screenInfo.numVideoScreens) {
	PrinterFontRegisterFpeFunctions();
	FontFileCheckRegisterFpeFunctions();
	check_fs_register_fpe_functions();
    } else 
#endif
    {
#ifdef BUILTIN_FONTS
        BuiltinRegisterFpeFunctions();
#else
	FontFileRegisterFpeFunctions();
#endif
#ifndef NOFONTSERVERACCESS
	fs_register_fpe_functions();
#endif
    }
d1925 16
a1940 6
#ifdef XPRINT
    if (requestingClient && requestingClient->fontResFunc != NULL &&
	!requestingClient->clientGone)
    {
	return (*requestingClient->fontResFunc)(requestingClient, num);
    }
d1942 4
a1945 24
#endif
    {
	static struct _FontResolution res;
	ScreenPtr   pScreen;

	pScreen = screenInfo.screens[0];
	res.x_resolution = (pScreen->width * 25.4) / pScreen->mmWidth;
	/*
	 * XXX - we'll want this as long as bitmap instances are prevalent 
	 so that we can match them from scalable fonts
	 */
	if (res.x_resolution < 88)
	    res.x_resolution = 75;
	else
	    res.x_resolution = 100;
	res.y_resolution = (pScreen->height * 25.4) / pScreen->mmHeight;
	if (res.y_resolution < 88)
	    res.y_resolution = 75;
	else
	    res.y_resolution = 100;
	res.point_size = 120;
	*num = 1;
	return &res;
    }
@


1.2
log
@Fix from X.Org for  CVE-2008-0006 - PCF Font parser buffer overflow.
@
text
@d68 1
d788 1
a788 1
    bufptr = bufferStart = (char *) ALLOCATE_LOCAL(reply.length << 2);
d813 1
a813 1
    DEALLOCATE_LOCAL(bufferStart);
d844 4
d1120 4
a1646 3
		ErrorF("FreeFontPath: FPE \"%.*s\" refcount is %d, should be %d; fixing.\n",
		       list[i]->name_length, list[i]->name,
		       list[i]->refcount, found);
d1787 3
a1789 1
    int   err = Success;
d1815 1
a1815 1
    nump = cp = newpath = (unsigned char *) ALLOCATE_LOCAL(len);
d1836 1
a1836 1
    DEALLOCATE_LOCAL(newpath);
d1841 2
a1842 2
unsigned char *
GetFontPath(int *count, int *length)
d1849 4
d1860 1
a1860 1
	return NULL;
d1872 2
a1873 1
    return font_path_string;
d1934 1
d1940 3
a1942 1
    else {
@


1.1
log
@Initial revision
@
text
@d67 1
a158 5

#ifdef DEBUG
	    fprintf(stderr, "re-queueing fpe wakeup\n");
#endif

d328 7
d1155 1
a1155 1
doPolyText(ClientPtr client, register PTclosurePtr c)
d1157 1
a1157 1
    register FontPtr pFont = c->pGC->font, oldpFont;
d1189 1
a1189 1
					RC_DRAWABLE, SecurityWriteAccess))
d1219 1
a1219 1
						    SecurityReadAccess);
d1457 1
a1457 1
doImageText(ClientPtr client, register ITclosurePtr c)
d1474 1
a1474 1
					RC_DRAWABLE, SecurityWriteAccess))
d1888 1
a1888 1
InitFonts ()
d1892 1
a1892 1
#ifndef KDRIVESERVER
d1900 4
a1903 2
#ifdef KDRIVESERVER
	BuiltinRegisterFpeFunctions();
a1904 1
	FontFileRegisterFpeFunctions();
d2007 1
a2007 1
FreeFonts()
d2027 1
a2027 1
					    SecurityUnknownAccess);
a2065 5

#ifdef DEBUG
	fprintf(stderr, "adding FS b & w handlers\n");
#endif

a2080 5

#ifdef DEBUG
	    fprintf(stderr, "removing FS b & w handlers\n");
#endif

a2086 41

#ifdef DEBUG
#define GLWIDTHBYTESPADDED(bits,nbytes) \
	((nbytes) == 1 ? (((bits)+7)>>3)        /* pad to 1 byte */ \
	:(nbytes) == 2 ? ((((bits)+15)>>3)&~1)  /* pad to 2 bytes */ \
	:(nbytes) == 4 ? ((((bits)+31)>>3)&~3)  /* pad to 4 bytes */ \
	:(nbytes) == 8 ? ((((bits)+63)>>3)&~7)  /* pad to 8 bytes */ \
	: 0)

#define GLYPH_SIZE(ch, nbytes)          \
	GLWIDTHBYTESPADDED((ch)->metrics.rightSideBearing - \
			(ch)->metrics.leftSideBearing, (nbytes))
void
dump_char_ascii(CharInfoPtr cip)
{
    int         r,
                l;
    int         bpr;
    int         byte;
    static unsigned maskTab[] = {
	(1 << 7), (1 << 6), (1 << 5), (1 << 4),
	(1 << 3), (1 << 2), (1 << 1), (1 << 0),
    };

    bpr = GLYPH_SIZE(cip, 4);
    for (r = 0; r < (cip->metrics.ascent + cip->metrics.descent); r++) {
	pointer     row = (pointer) cip->bits + r * bpr;

	byte = 0;
	for (l = 0; l <= (cip->metrics.rightSideBearing -
			  cip->metrics.leftSideBearing); l++) {
	    if (maskTab[l & 7] & row[l >> 3])
		putchar('X');
	    else
		putchar('.');
	}
	putchar('\n');
    }
}

#endif
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.1.2.1
log
@Merging a bunch of security fixes from X.org

CVE-2007-5760 - XFree86 Misc extension out of bounds array index.
CVE-2007-5958 - File existence disclosure.
CVE-2007-6427 - Xinput extension memory corruption.
CVE-2007-6428 - TOG-cup extension memory corruption.
CVE-2007-6429 - MIT-SHM and EVI extensions integer overflows.
CVE-2008-0006 - PCF Font parser buffer overflow.
@
text
@a331 7
    /* check values for firstCol, lastCol, firstRow, and lastRow */
    if (pfont->info.firstCol > pfont->info.lastCol ||
       pfont->info.firstRow > pfont->info.lastRow ||
       pfont->info.lastCol - pfont->info.firstCol > 255) {
       err = AllocError;
       goto bail;
    }
@


1.1.1.2
log
@xserver 1.4
@
text
@a66 1
#include "dixfont.h"
d158 5
d1152 1
a1152 1
doPolyText(ClientPtr client, PTclosurePtr c)
d1154 1
a1154 1
    FontPtr pFont = c->pGC->font, oldpFont;
d1186 1
a1186 1
					RC_DRAWABLE, DixWriteAccess))
d1216 1
a1216 1
						    DixReadAccess);
d1454 1
a1454 1
doImageText(ClientPtr client, ITclosurePtr c)
d1471 1
a1471 1
					RC_DRAWABLE, DixWriteAccess))
d1885 1
a1885 1
InitFonts (void)
d1889 1
a1889 1
#ifndef BUILTIN_FONTS
d1897 3
a1899 3
#ifdef BUILTIN_FONTS
        BuiltinRegisterFpeFunctions();
#else
a1900 1
#endif
d2003 1
a2003 1
FreeFonts(void)
d2023 1
a2023 1
					    DixUnknownAccess);
d2062 5
d2082 5
d2093 41
@

