head	1.8;
access;
symbols
	OPENBSD_6_0:1.7.0.10
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.8
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.2
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.8
date	2016.08.09.18.59.51;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	6HLO5qdN5N4nPDjW;

1.7
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 *
 * Copyright Â© 2006-2009 Simon Thum             simon dot thum at gmx dot de
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <math.h>
#include <ptrveloc.h>
#include <exevents.h>
#include <X11/Xatom.h>
#include <os.h>

#include <xserver-properties.h>

/*****************************************************************************
 * Predictable pointer acceleration
 *
 * 2006-2009 by Simon Thum (simon [dot] thum [at] gmx de)
 *
 * Serves 3 complementary functions:
 * 1) provide a sophisticated ballistic velocity estimate to improve
 *    the relation between velocity (of the device) and acceleration
 * 2) make arbitrary acceleration profiles possible
 * 3) decelerate by two means (constant and adaptive) if enabled
 *
 * Important concepts are the
 *
 * - Scheme
 *      which selects the basic algorithm
 *      (see devices.c/InitPointerAccelerationScheme)
 * - Profile
 *      which returns an acceleration
 *      for a given velocity
 *
 *  The profile can be selected by the user at runtime.
 *  The classic profile is intended to cleanly perform old-style
 *  function selection (threshold =/!= 0)
 *
 ****************************************************************************/

/* fwds */
static double
SimpleSmoothProfile(DeviceIntPtr dev, DeviceVelocityPtr vel, double velocity,
                    double threshold, double acc);
static PointerAccelerationProfileFunc
GetAccelerationProfile(DeviceVelocityPtr vel, int profile_num);
static BOOL
InitializePredictableAccelerationProperties(DeviceIntPtr,
                                            DeviceVelocityPtr,
                                            PredictableAccelSchemePtr);
static BOOL
DeletePredictableAccelerationProperties(DeviceIntPtr,
                                        PredictableAccelSchemePtr);

/*#define PTRACCEL_DEBUGGING*/

#ifdef PTRACCEL_DEBUGGING
#define DebugAccelF(...) ErrorFSigSafe("dix/ptraccel: " __VA_ARGS__)
#else
#define DebugAccelF(...)        /* */
#endif

/********************************
 *  Init/Uninit
 *******************************/

/* some int which is not a profile number */
#define PROFILE_UNINITIALIZE (-100)

/**
 * Init DeviceVelocity struct so it should match the average case
 */
void
InitVelocityData(DeviceVelocityPtr vel)
{
    memset(vel, 0, sizeof(DeviceVelocityRec));

    vel->corr_mul = 10.0;       /* dots per 10 milisecond should be usable */
    vel->const_acceleration = 1.0;      /* no acceleration/deceleration  */
    vel->reset_time = 300;
    vel->use_softening = 1;
    vel->min_acceleration = 1.0;        /* don't decelerate */
    vel->max_rel_diff = 0.2;
    vel->max_diff = 1.0;
    vel->initial_range = 2;
    vel->average_accel = TRUE;
    SetAccelerationProfile(vel, AccelProfileClassic);
    InitTrackers(vel, 16);
}

/**
 * Clean up DeviceVelocityRec
 */
void
FreeVelocityData(DeviceVelocityPtr vel)
{
    free(vel->tracker);
    SetAccelerationProfile(vel, PROFILE_UNINITIALIZE);
}

/**
 * Init predictable scheme
 */
Bool
InitPredictableAccelerationScheme(DeviceIntPtr dev,
                                  ValuatorAccelerationPtr protoScheme)
{
    DeviceVelocityPtr vel;
    ValuatorAccelerationRec scheme;
    PredictableAccelSchemePtr schemeData;

    scheme = *protoScheme;
    vel = calloc(1, sizeof(DeviceVelocityRec));
    schemeData = calloc(1, sizeof(PredictableAccelSchemeRec));
    if (!vel || !schemeData) {
        free(vel);
        free(schemeData);
        return FALSE;
    }
    InitVelocityData(vel);
    schemeData->vel = vel;
    scheme.accelData = schemeData;
    if (!InitializePredictableAccelerationProperties(dev, vel, schemeData)) {
        free(vel);
        free(schemeData);
        return FALSE;
    }
    /* all fine, assign scheme to device */
    dev->valuator->accelScheme = scheme;
    return TRUE;
}

/**
 *  Uninit scheme
 */
void
AccelerationDefaultCleanup(DeviceIntPtr dev)
{
    DeviceVelocityPtr vel = GetDevicePredictableAccelData(dev);

    if (vel) {
        /* the proper guarantee would be that we're not inside of
         * AccelSchemeProc(), but that seems impossible. Schemes don't get
         * switched often anyway.
         */
        OsBlockSignals();
        dev->valuator->accelScheme.AccelSchemeProc = NULL;
        FreeVelocityData(vel);
        free(vel);
        DeletePredictableAccelerationProperties(dev,
                                                (PredictableAccelSchemePtr)
                                                dev->valuator->accelScheme.
                                                accelData);
        free(dev->valuator->accelScheme.accelData);
        dev->valuator->accelScheme.accelData = NULL;
        OsReleaseSignals();
    }
}

/*************************
 * Input property support
 ************************/

/**
 * choose profile
 */
static int
AccelSetProfileProperty(DeviceIntPtr dev, Atom atom,
                        XIPropertyValuePtr val, BOOL checkOnly)
{
    DeviceVelocityPtr vel;
    int profile, *ptr = &profile;
    int rc;
    int nelem = 1;

    if (atom != XIGetKnownProperty(ACCEL_PROP_PROFILE_NUMBER))
        return Success;

    vel = GetDevicePredictableAccelData(dev);
    if (!vel)
        return BadValue;
    rc = XIPropToInt(val, &nelem, &ptr);

    if (checkOnly) {
        if (rc)
            return rc;

        if (GetAccelerationProfile(vel, profile) == NULL)
            return BadValue;
    }
    else
        SetAccelerationProfile(vel, profile);

    return Success;
}

static long
AccelInitProfileProperty(DeviceIntPtr dev, DeviceVelocityPtr vel)
{
    int profile = vel->statistics.profile_number;
    Atom prop_profile_number = XIGetKnownProperty(ACCEL_PROP_PROFILE_NUMBER);

    XIChangeDeviceProperty(dev, prop_profile_number, XA_INTEGER, 32,
                           PropModeReplace, 1, &profile, FALSE);
    XISetDevicePropertyDeletable(dev, prop_profile_number, FALSE);
    return XIRegisterPropertyHandler(dev, AccelSetProfileProperty, NULL, NULL);
}

/**
 * constant deceleration
 */
static int
AccelSetDecelProperty(DeviceIntPtr dev, Atom atom,
                      XIPropertyValuePtr val, BOOL checkOnly)
{
    DeviceVelocityPtr vel;
    float v, *ptr = &v;
    int rc;
    int nelem = 1;

    if (atom != XIGetKnownProperty(ACCEL_PROP_CONSTANT_DECELERATION))
        return Success;

    vel = GetDevicePredictableAccelData(dev);
    if (!vel)
        return BadValue;
    rc = XIPropToFloat(val, &nelem, &ptr);

    if (checkOnly) {
        if (rc)
            return rc;
        return (v > 0) ? Success : BadValue;
    }

    vel->const_acceleration = 1 / v;

    return Success;
}

static long
AccelInitDecelProperty(DeviceIntPtr dev, DeviceVelocityPtr vel)
{
    float fval = 1.0 / vel->const_acceleration;
    Atom prop_const_decel =
        XIGetKnownProperty(ACCEL_PROP_CONSTANT_DECELERATION);
    XIChangeDeviceProperty(dev, prop_const_decel,
                           XIGetKnownProperty(XATOM_FLOAT), 32, PropModeReplace,
                           1, &fval, FALSE);
    XISetDevicePropertyDeletable(dev, prop_const_decel, FALSE);
    return XIRegisterPropertyHandler(dev, AccelSetDecelProperty, NULL, NULL);
}

/**
 * adaptive deceleration
 */
static int
AccelSetAdaptDecelProperty(DeviceIntPtr dev, Atom atom,
                           XIPropertyValuePtr val, BOOL checkOnly)
{
    DeviceVelocityPtr veloc;
    float v, *ptr = &v;
    int rc;
    int nelem = 1;

    if (atom != XIGetKnownProperty(ACCEL_PROP_ADAPTIVE_DECELERATION))
        return Success;

    veloc = GetDevicePredictableAccelData(dev);
    if (!veloc)
        return BadValue;
    rc = XIPropToFloat(val, &nelem, &ptr);

    if (checkOnly) {
        if (rc)
            return rc;
        return (v >= 1.0f) ? Success : BadValue;
    }

    if (v >= 1.0f)
        veloc->min_acceleration = 1 / v;

    return Success;
}

static long
AccelInitAdaptDecelProperty(DeviceIntPtr dev, DeviceVelocityPtr vel)
{
    float fval = 1.0 / vel->min_acceleration;
    Atom prop_adapt_decel =
        XIGetKnownProperty(ACCEL_PROP_ADAPTIVE_DECELERATION);

    XIChangeDeviceProperty(dev, prop_adapt_decel,
                           XIGetKnownProperty(XATOM_FLOAT), 32, PropModeReplace,
                           1, &fval, FALSE);
    XISetDevicePropertyDeletable(dev, prop_adapt_decel, FALSE);
    return XIRegisterPropertyHandler(dev, AccelSetAdaptDecelProperty, NULL,
                                     NULL);
}

/**
 * velocity scaling
 */
static int
AccelSetScaleProperty(DeviceIntPtr dev, Atom atom,
                      XIPropertyValuePtr val, BOOL checkOnly)
{
    DeviceVelocityPtr vel;
    float v, *ptr = &v;
    int rc;
    int nelem = 1;

    if (atom != XIGetKnownProperty(ACCEL_PROP_VELOCITY_SCALING))
        return Success;

    vel = GetDevicePredictableAccelData(dev);
    if (!vel)
        return BadValue;
    rc = XIPropToFloat(val, &nelem, &ptr);

    if (checkOnly) {
        if (rc)
            return rc;

        return (v > 0) ? Success : BadValue;
    }

    if (v > 0)
        vel->corr_mul = v;

    return Success;
}

static long
AccelInitScaleProperty(DeviceIntPtr dev, DeviceVelocityPtr vel)
{
    float fval = vel->corr_mul;
    Atom prop_velo_scale = XIGetKnownProperty(ACCEL_PROP_VELOCITY_SCALING);

    XIChangeDeviceProperty(dev, prop_velo_scale,
                           XIGetKnownProperty(XATOM_FLOAT), 32, PropModeReplace,
                           1, &fval, FALSE);
    XISetDevicePropertyDeletable(dev, prop_velo_scale, FALSE);
    return XIRegisterPropertyHandler(dev, AccelSetScaleProperty, NULL, NULL);
}

static BOOL
InitializePredictableAccelerationProperties(DeviceIntPtr dev,
                                            DeviceVelocityPtr vel,
                                            PredictableAccelSchemePtr
                                            schemeData)
{
    int num_handlers = 4;

    if (!vel)
        return FALSE;

    schemeData->prop_handlers = calloc(num_handlers, sizeof(long));
    if (!schemeData->prop_handlers)
        return FALSE;
    schemeData->num_prop_handlers = num_handlers;
    schemeData->prop_handlers[0] = AccelInitProfileProperty(dev, vel);
    schemeData->prop_handlers[1] = AccelInitDecelProperty(dev, vel);
    schemeData->prop_handlers[2] = AccelInitAdaptDecelProperty(dev, vel);
    schemeData->prop_handlers[3] = AccelInitScaleProperty(dev, vel);

    return TRUE;
}

BOOL
DeletePredictableAccelerationProperties(DeviceIntPtr dev,
                                        PredictableAccelSchemePtr scheme)
{
    DeviceVelocityPtr vel;
    Atom prop;
    int i;

    prop = XIGetKnownProperty(ACCEL_PROP_VELOCITY_SCALING);
    XIDeleteDeviceProperty(dev, prop, FALSE);
    prop = XIGetKnownProperty(ACCEL_PROP_ADAPTIVE_DECELERATION);
    XIDeleteDeviceProperty(dev, prop, FALSE);
    prop = XIGetKnownProperty(ACCEL_PROP_CONSTANT_DECELERATION);
    XIDeleteDeviceProperty(dev, prop, FALSE);
    prop = XIGetKnownProperty(ACCEL_PROP_PROFILE_NUMBER);
    XIDeleteDeviceProperty(dev, prop, FALSE);

    vel = GetDevicePredictableAccelData(dev);
    if (vel) {
        for (i = 0; i < scheme->num_prop_handlers; i++)
            if (scheme->prop_handlers[i])
                XIUnregisterPropertyHandler(dev, scheme->prop_handlers[i]);
    }

    free(scheme->prop_handlers);
    scheme->prop_handlers = NULL;
    scheme->num_prop_handlers = 0;
    return TRUE;
}

/*********************
 * Tracking logic
 ********************/

void
InitTrackers(DeviceVelocityPtr vel, int ntracker)
{
    if (ntracker < 1) {
        ErrorF("invalid number of trackers\n");
        return;
    }
    free(vel->tracker);
    vel->tracker = (MotionTrackerPtr) calloc(ntracker, sizeof(MotionTracker));
    vel->num_tracker = ntracker;
}

enum directions {
    N = (1 << 0),
    NE = (1 << 1),
    E = (1 << 2),
    SE = (1 << 3),
    S = (1 << 4),
    SW = (1 << 5),
    W = (1 << 6),
    NW = (1 << 7),
    UNDEFINED = 0xFF
};

/**
 * return a bit field of possible directions.
 * There's no reason against widening to more precise directions (<45 degrees),
 * should it not perform well. All this is needed for is sort out non-linear
 * motion, so precision isn't paramount. However, one should not flag direction
 * too narrow, since it would then cut the linear segment to zero size way too
 * often.
 *
 * @@return A bitmask for N, NE, S, SE, etc. indicating the directions for
 * this movement.
 */
static int
DoGetDirection(int dx, int dy)
{
    int dir = 0;

    /* on insignificant mickeys, flag 135 degrees */
    if (abs(dx) < 2 && abs(dy) < 2) {
        /* first check diagonal cases */
        if (dx > 0 && dy > 0)
            dir = E | SE | S;
        else if (dx > 0 && dy < 0)
            dir = N | NE | E;
        else if (dx < 0 && dy < 0)
            dir = W | NW | N;
        else if (dx < 0 && dy > 0)
            dir = W | SW | S;
        /* check axis-aligned directions */
        else if (dx > 0)
            dir = NE | E | SE;
        else if (dx < 0)
            dir = NW | W | SW;
        else if (dy > 0)
            dir = SE | S | SW;
        else if (dy < 0)
            dir = NE | N | NW;
        else
            dir = UNDEFINED;    /* shouldn't happen */
    }
    else {                      /* compute angle and set appropriate flags */
        double r;
        int i1, i2;

        r = atan2(dy, dx);
        /* find direction.
         *
         * Add 360Â° to avoid r become negative since C has no well-defined
         * modulo for such cases. Then divide by 45Â° to get the octant
         * number,  e.g.
         *          0 <= r <= 1 is [0-45]Â°
         *          1 <= r <= 2 is [45-90]Â°
         *          etc.
         * But we add extra 90Â° to match up with our N, S, etc. defines up
         * there, rest stays the same.
         */
        r = (r + (M_PI * 2.5)) / (M_PI / 4);
        /* this intends to flag 2 directions (45 degrees),
         * except on very well-aligned mickeys. */
        i1 = (int) (r + 0.1) % 8;
        i2 = (int) (r + 0.9) % 8;
        if (i1 < 0 || i1 > 7 || i2 < 0 || i2 > 7)
            dir = UNDEFINED;    /* shouldn't happen */
        else
            dir = (1 << i1 | 1 << i2);
    }
    return dir;
}

#define DIRECTION_CACHE_RANGE 5
#define DIRECTION_CACHE_SIZE (DIRECTION_CACHE_RANGE*2+1)

/* cache DoGetDirection().
 * To avoid excessive use of direction calculation, cache the values for
 * [-5..5] for both x/y. Anything outside of that is calcualted on the fly.
 *
 * @@return A bitmask for N, NE, S, SE, etc. indicating the directions for
 * this movement.
 */
static int
GetDirection(int dx, int dy)
{
    static int cache[DIRECTION_CACHE_SIZE][DIRECTION_CACHE_SIZE];
    int dir;

    if (abs(dx) <= DIRECTION_CACHE_RANGE && abs(dy) <= DIRECTION_CACHE_RANGE) {
        /* cacheable */
        dir = cache[DIRECTION_CACHE_RANGE + dx][DIRECTION_CACHE_RANGE + dy];
        if (dir == 0) {
            dir = DoGetDirection(dx, dy);
            cache[DIRECTION_CACHE_RANGE + dx][DIRECTION_CACHE_RANGE + dy] = dir;
        }
    }
    else {
        /* non-cacheable */
        dir = DoGetDirection(dx, dy);
    }

    return dir;
}

#undef DIRECTION_CACHE_RANGE
#undef DIRECTION_CACHE_SIZE

/* convert offset (age) to array index */
#define TRACKER_INDEX(s, d) (((s)->num_tracker + (s)->cur_tracker - (d)) % (s)->num_tracker)
#define TRACKER(s, d) &(s)->tracker[TRACKER_INDEX(s,d)]

/**
 * Add the delta motion to each tracker, then reset the latest tracker to
 * 0/0 and set it as the current one.
 */
static inline void
FeedTrackers(DeviceVelocityPtr vel, double dx, double dy, int cur_t)
{
    int n;

    for (n = 0; n < vel->num_tracker; n++) {
        vel->tracker[n].dx += dx;
        vel->tracker[n].dy += dy;
    }
    n = (vel->cur_tracker + 1) % vel->num_tracker;
    vel->tracker[n].dx = 0.0;
    vel->tracker[n].dy = 0.0;
    vel->tracker[n].time = cur_t;
    vel->tracker[n].dir = GetDirection(dx, dy);
    DebugAccelF("motion [dx: %f dy: %f dir:%d diff: %d]\n",
                dx, dy, vel->tracker[n].dir,
                cur_t - vel->tracker[vel->cur_tracker].time);
    vel->cur_tracker = n;
}

/**
 * calc velocity for given tracker, with
 * velocity scaling.
 * This assumes linear motion.
 */
static double
CalcTracker(const MotionTracker * tracker, int cur_t)
{
    double dist = sqrt(tracker->dx * tracker->dx + tracker->dy * tracker->dy);
    int dtime = cur_t - tracker->time;

    if (dtime > 0)
        return dist / dtime;
    else
        return 0;               /* synonymous for NaN, since we're not C99 */
}

/* find the most plausible velocity. That is, the most distant
 * (in time) tracker which isn't too old, the movement vector was
 * in the same octant, and where the velocity is within an
 * acceptable range to the inital velocity.
 *
 * @@return The tracker's velocity or 0 if the above conditions are unmet
 */
static double
QueryTrackers(DeviceVelocityPtr vel, int cur_t)
{
    int offset, dir = UNDEFINED, used_offset = -1, age_ms;

    /* initial velocity: a low-offset, valid velocity */
    double initial_velocity = 0, result = 0, velocity_diff;
    double velocity_factor = vel->corr_mul * vel->const_acceleration;   /* premultiply */

    /* loop from current to older data */
    for (offset = 1; offset < vel->num_tracker; offset++) {
        MotionTracker *tracker = TRACKER(vel, offset);
        double tracker_velocity;

        age_ms = cur_t - tracker->time;

        /* bail out if data is too old and protect from overrun */
        if (age_ms >= vel->reset_time || age_ms < 0) {
            DebugAccelF("query: tracker too old (reset after %d, age is %d)\n",
                        vel->reset_time, age_ms);
            break;
        }

        /*
         * this heuristic avoids using the linear-motion velocity formula
         * in CalcTracker() on motion that isn't exactly linear. So to get
         * even more precision we could subdivide as a final step, so possible
         * non-linearities are accounted for.
         */
        dir &= tracker->dir;
        if (dir == 0) {         /* we've changed octant of movement (e.g. NE â NW) */
            DebugAccelF("query: no longer linear\n");
            /* instead of breaking it we might also inspect the partition after,
             * but actual improvement with this is probably rare. */
            break;
        }

        tracker_velocity = CalcTracker(tracker, cur_t) * velocity_factor;

        if ((initial_velocity == 0 || offset <= vel->initial_range) &&
            tracker_velocity != 0) {
            /* set initial velocity and result */
            result = initial_velocity = tracker_velocity;
            used_offset = offset;
        }
        else if (initial_velocity != 0 && tracker_velocity != 0) {
            velocity_diff = fabs(initial_velocity - tracker_velocity);

            if (velocity_diff > vel->max_diff &&
                velocity_diff / (initial_velocity + tracker_velocity) >=
                vel->max_rel_diff) {
                /* we're not in range, quit - it won't get better. */
                DebugAccelF("query: tracker too different:"
                            " old %2.2f initial %2.2f diff: %2.2f\n",
                            tracker_velocity, initial_velocity, velocity_diff);
                break;
            }
            /* we're in range with the initial velocity,
             * so this result is likely better
             * (it contains more information). */
            result = tracker_velocity;
            used_offset = offset;
        }
    }
    if (offset == vel->num_tracker) {
        DebugAccelF("query: last tracker in effect\n");
        used_offset = vel->num_tracker - 1;
    }
    if (used_offset >= 0) {
#ifdef PTRACCEL_DEBUGGING
        MotionTracker *tracker = TRACKER(vel, used_offset);

        DebugAccelF("result: offset %i [dx: %f dy: %f diff: %i]\n",
                    used_offset, tracker->dx, tracker->dy,
                    cur_t - tracker->time);
#endif
    }
    return result;
}

#undef TRACKER_INDEX
#undef TRACKER

/**
 * Perform velocity approximation based on 2D 'mickeys' (mouse motion delta).
 * return true if non-visible state reset is suggested
 */
BOOL
ProcessVelocityData2D(DeviceVelocityPtr vel, double dx, double dy, int time)
{
    double velocity;

    vel->last_velocity = vel->velocity;

    FeedTrackers(vel, dx, dy, time);

    velocity = QueryTrackers(vel, time);

    DebugAccelF("velocity is %f\n", velocity);

    vel->velocity = velocity;
    return velocity == 0;
}

/**
 * this flattens significant ( > 1) mickeys a little bit for more steady
 * constant-velocity response
 */
static inline double
ApplySimpleSoftening(double prev_delta, double delta)
{
    double result = delta;

    if (delta < -1.0 || delta > 1.0) {
        if (delta > prev_delta)
            result -= 0.5;
        else if (delta < prev_delta)
            result += 0.5;
    }
    return result;
}

/**
 * Soften the delta based on previous deltas stored in vel.
 *
 * @@param[in,out] fdx Delta X, modified in-place.
 * @@param[in,out] fdx Delta Y, modified in-place.
 */
static void
ApplySoftening(DeviceVelocityPtr vel, double *fdx, double *fdy)
{
    if (vel->use_softening) {
        *fdx = ApplySimpleSoftening(vel->last_dx, *fdx);
        *fdy = ApplySimpleSoftening(vel->last_dy, *fdy);
    }
}

static void
ApplyConstantDeceleration(DeviceVelocityPtr vel, double *fdx, double *fdy)
{
    *fdx *= vel->const_acceleration;
    *fdy *= vel->const_acceleration;
}

/*
 * compute the acceleration for given velocity and enforce min_acceleration
 */
double
BasicComputeAcceleration(DeviceIntPtr dev,
                         DeviceVelocityPtr vel,
                         double velocity, double threshold, double acc)
{

    double result;

    result = vel->Profile(dev, vel, velocity, threshold, acc);

    /* enforce min_acceleration */
    if (result < vel->min_acceleration)
        result = vel->min_acceleration;
    return result;
}

/**
 * Compute acceleration. Takes into account averaging, nv-reset, etc.
 * If the velocity has changed, an average is taken of 6 velocity factors:
 * current velocity, last velocity and 4 times the average between the two.
 */
static double
ComputeAcceleration(DeviceIntPtr dev,
                    DeviceVelocityPtr vel, double threshold, double acc)
{
    double result;

    if (vel->velocity <= 0) {
        DebugAccelF("profile skipped\n");
        /*
         * If we have no idea about device velocity, don't pretend it.
         */
        return 1;
    }

    if (vel->average_accel && vel->velocity != vel->last_velocity) {
        /* use simpson's rule to average acceleration between
         * current and previous velocity.
         * Though being the more natural choice, it causes a minor delay
         * in comparison, so it can be disabled. */
        result =
            BasicComputeAcceleration(dev, vel, vel->velocity, threshold, acc);
        result +=
            BasicComputeAcceleration(dev, vel, vel->last_velocity, threshold,
                                     acc);
        result +=
            4.0f * BasicComputeAcceleration(dev, vel,
                                            (vel->last_velocity +
                                             vel->velocity) / 2,
                                            threshold,
                                            acc);
        result /= 6.0f;
        DebugAccelF("profile average [%.2f ... %.2f] is %.3f\n",
                    vel->velocity, vel->last_velocity, result);
    }
    else {
        result = BasicComputeAcceleration(dev, vel,
                                          vel->velocity, threshold, acc);
        DebugAccelF("profile sample [%.2f] is %.3f\n",
                    vel->velocity, result);
    }

    return result;
}

/*****************************************
 *  Acceleration functions and profiles
 ****************************************/

/**
 * Polynomial function similar previous one, but with f(1) = 1
 */
static double
PolynomialAccelerationProfile(DeviceIntPtr dev,
                              DeviceVelocityPtr vel,
                              double velocity, double ignored, double acc)
{
    return pow(velocity, (acc - 1.0) * 0.5);
}

/**
 * returns acceleration for velocity.
 * This profile selects the two functions like the old scheme did
 */
static double
ClassicProfile(DeviceIntPtr dev,
               DeviceVelocityPtr vel,
               double velocity, double threshold, double acc)
{
    if (threshold > 0) {
        return SimpleSmoothProfile(dev, vel, velocity, threshold, acc);
    }
    else {
        return PolynomialAccelerationProfile(dev, vel, velocity, 0, acc);
    }
}

/**
 * Power profile
 * This has a completely smooth transition curve, i.e. no jumps in the
 * derivatives.
 *
 * This has the expense of overall response dependency on min-acceleration.
 * In effect, min_acceleration mimics const_acceleration in this profile.
 */
static double
PowerProfile(DeviceIntPtr dev,
             DeviceVelocityPtr vel,
             double velocity, double threshold, double acc)
{
    double vel_dist;

    acc = (acc - 1.0) * 0.1f + 1.0;     /* without this, acc of 2 is unuseable */

    if (velocity <= threshold)
        return vel->min_acceleration;
    vel_dist = velocity - threshold;
    return (pow(acc, vel_dist)) * vel->min_acceleration;
}

/**
 * just a smooth function in [0..1] -> [0..1]
 *  - point symmetry at 0.5
 *  - f'(0) = f'(1) = 0
 *  - starts faster than a sinoid
 *  - smoothness C1 (Cinf if you dare to ignore endpoints)
 */
static inline double
CalcPenumbralGradient(double x)
{
    x *= 2.0f;
    x -= 1.0f;
    return 0.5f + (x * sqrt(1.0 - x * x) + asin(x)) / M_PI;
}

/**
 * acceleration function similar to classic accelerated/unaccelerated,
 * but with smooth transition in between (and towards zero for adaptive dec.).
 */
static double
SimpleSmoothProfile(DeviceIntPtr dev,
                    DeviceVelocityPtr vel,
                    double velocity, double threshold, double acc)
{
    if (velocity < 1.0f)
        return CalcPenumbralGradient(0.5 + velocity * 0.5) * 2.0f - 1.0f;
    if (threshold < 1.0f)
        threshold = 1.0f;
    if (velocity <= threshold)
        return 1;
    velocity /= threshold;
    if (velocity >= acc)
        return acc;
    else
        return 1.0f + (CalcPenumbralGradient(velocity / acc) * (acc - 1.0f));
}

/**
 * This profile uses the first half of the penumbral gradient as a start
 * and then scales linearly.
 */
static double
SmoothLinearProfile(DeviceIntPtr dev,
                    DeviceVelocityPtr vel,
                    double velocity, double threshold, double acc)
{
    double res, nv;

    if (acc > 1.0f)
        acc -= 1.0f;            /*this is so acc = 1 is no acceleration */
    else
        return 1.0f;

    nv = (velocity - threshold) * acc * 0.5f;

    if (nv < 0) {
        res = 0;
    }
    else if (nv < 2) {
        res = CalcPenumbralGradient(nv * 0.25f) * 2.0f;
    }
    else {
        nv -= 2.0f;
        res = nv * 2.0f / M_PI  /* steepness of gradient at 0.5 */
            + 1.0f;             /* gradient crosses 2|1 */
    }
    res += vel->min_acceleration;
    return res;
}

/**
 * From 0 to threshold, the response graduates smoothly from min_accel to
 * acceleration. Beyond threshold it is exactly the specified acceleration.
 */
static double
SmoothLimitedProfile(DeviceIntPtr dev,
                     DeviceVelocityPtr vel,
                     double velocity, double threshold, double acc)
{
    double res;

    if (velocity >= threshold || threshold == 0.0f)
        return acc;

    velocity /= threshold;      /* should be [0..1[ now */

    res = CalcPenumbralGradient(velocity) * (acc - vel->min_acceleration);

    return vel->min_acceleration + res;
}

static double
LinearProfile(DeviceIntPtr dev,
              DeviceVelocityPtr vel,
              double velocity, double threshold, double acc)
{
    return acc * velocity;
}

static double
NoProfile(DeviceIntPtr dev,
          DeviceVelocityPtr vel, double velocity, double threshold, double acc)
{
    return 1.0f;
}

static PointerAccelerationProfileFunc
GetAccelerationProfile(DeviceVelocityPtr vel, int profile_num)
{
    switch (profile_num) {
    case AccelProfileClassic:
        return ClassicProfile;
    case AccelProfileDeviceSpecific:
        return vel->deviceSpecificProfile;
    case AccelProfilePolynomial:
        return PolynomialAccelerationProfile;
    case AccelProfileSmoothLinear:
        return SmoothLinearProfile;
    case AccelProfileSimple:
        return SimpleSmoothProfile;
    case AccelProfilePower:
        return PowerProfile;
    case AccelProfileLinear:
        return LinearProfile;
    case AccelProfileSmoothLimited:
        return SmoothLimitedProfile;
    case AccelProfileNone:
        return NoProfile;
    default:
        return NULL;
    }
}

/**
 * Set the profile by number.
 * Intended to make profiles exchangeable at runtime.
 * If you created a profile, give it a number here and in the header to
 * make it selectable. In case some profile-specific init is needed, here
 * would be a good place, since FreeVelocityData() also calls this with
 * PROFILE_UNINITIALIZE.
 *
 * returns FALSE if profile number is unavailable, TRUE otherwise.
 */
int
SetAccelerationProfile(DeviceVelocityPtr vel, int profile_num)
{
    PointerAccelerationProfileFunc profile;

    profile = GetAccelerationProfile(vel, profile_num);

    if (profile == NULL && profile_num != PROFILE_UNINITIALIZE)
        return FALSE;

    /* Here one could free old profile-private data */
    free(vel->profile_private);
    vel->profile_private = NULL;
    /* Here one could init profile-private data */
    vel->Profile = profile;
    vel->statistics.profile_number = profile_num;
    return TRUE;
}

/**********************************************
 * driver interaction
 **********************************************/

/**
 * device-specific profile
 *
 * The device-specific profile is intended as a hook for a driver
 * which may want to provide an own acceleration profile.
 * It should not rely on profile-private data, instead
 * it should do init/uninit in the driver (ie. with DEVICE_INIT and friends).
 * Users may override or choose it.
 */
void
SetDeviceSpecificAccelerationProfile(DeviceVelocityPtr vel,
                                     PointerAccelerationProfileFunc profile)
{
    if (vel)
        vel->deviceSpecificProfile = profile;
}

/**
 * Use this function to obtain a DeviceVelocityPtr for a device. Will return NULL if
 * the predictable acceleration scheme is not in effect.
 */
DeviceVelocityPtr
GetDevicePredictableAccelData(DeviceIntPtr dev)
{
    BUG_RETURN_VAL(!dev, NULL);

    if (dev->valuator &&
        dev->valuator->accelScheme.AccelSchemeProc ==
        acceleratePointerPredictable &&
        dev->valuator->accelScheme.accelData != NULL) {

        return ((PredictableAccelSchemePtr)
                dev->valuator->accelScheme.accelData)->vel;
    }
    return NULL;
}

/********************************
 *  acceleration schemes
 *******************************/

/**
 * Modifies valuators in-place.
 * This version employs a velocity approximation algorithm to
 * enable fine-grained predictable acceleration profiles.
 */
void
acceleratePointerPredictable(DeviceIntPtr dev, ValuatorMask *val, CARD32 evtime)
{
    double dx = 0, dy = 0;
    DeviceVelocityPtr velocitydata = GetDevicePredictableAccelData(dev);
    Bool soften = TRUE;

    if (valuator_mask_num_valuators(val) == 0 || !velocitydata)
        return;

    if (velocitydata->statistics.profile_number == AccelProfileNone &&
        velocitydata->const_acceleration == 1.0f) {
        return;                 /*we're inactive anyway, so skip the whole thing. */
    }

    if (valuator_mask_isset(val, 0)) {
        dx = valuator_mask_get_double(val, 0);
    }

    if (valuator_mask_isset(val, 1)) {
        dy = valuator_mask_get_double(val, 1);
    }

    if (dx != 0.0 || dy != 0.0) {
        /* reset non-visible state? */
        if (ProcessVelocityData2D(velocitydata, dx, dy, evtime)) {
            soften = FALSE;
        }

        if (dev->ptrfeed && dev->ptrfeed->ctrl.num) {
            double mult;

            /* invoke acceleration profile to determine acceleration */
            mult = ComputeAcceleration(dev, velocitydata,
                                       dev->ptrfeed->ctrl.threshold,
                                       (double) dev->ptrfeed->ctrl.num /
                                       (double) dev->ptrfeed->ctrl.den);

            DebugAccelF("mult is %f\n", mult);
            if (mult != 1.0f || velocitydata->const_acceleration != 1.0f) {
                if (mult > 1.0f && soften)
                    ApplySoftening(velocitydata, &dx, &dy);
                ApplyConstantDeceleration(velocitydata, &dx, &dy);

                if (dx != 0.0)
                    valuator_mask_set_double(val, 0, mult * dx);
                if (dy != 0.0)
                    valuator_mask_set_double(val, 1, mult * dy);
                DebugAccelF("delta x:%.3f y:%.3f\n", mult * dx, mult * dy);
            }
        }
    }
    /* remember last motion delta (for softening/slow movement treatment) */
    velocitydata->last_dx = dx;
    velocitydata->last_dy = dy;
}

/**
 * Originally a part of xf86PostMotionEvent; modifies valuators
 * in-place. Retained mostly for embedded scenarios.
 */
void
acceleratePointerLightweight(DeviceIntPtr dev,
                             ValuatorMask *val, CARD32 ignored)
{
    double mult = 0.0, tmpf;
    double dx = 0.0, dy = 0.0;

    if (valuator_mask_isset(val, 0)) {
        dx = valuator_mask_get(val, 0);
    }

    if (valuator_mask_isset(val, 1)) {
        dy = valuator_mask_get(val, 1);
    }

    if (valuator_mask_num_valuators(val) == 0)
        return;

    if (dev->ptrfeed && dev->ptrfeed->ctrl.num) {
        /* modeled from xf86Events.c */
        if (dev->ptrfeed->ctrl.threshold) {
            if ((fabs(dx) + fabs(dy)) >= dev->ptrfeed->ctrl.threshold) {
                if (dx != 0.0) {
                    tmpf = (dx * (double) (dev->ptrfeed->ctrl.num)) /
                        (double) (dev->ptrfeed->ctrl.den);
                    valuator_mask_set_double(val, 0, tmpf);
                }

                if (dy != 0.0) {
                    tmpf = (dy * (double) (dev->ptrfeed->ctrl.num)) /
                        (double) (dev->ptrfeed->ctrl.den);
                    valuator_mask_set_double(val, 1, tmpf);
                }
            }
        }
        else {
            mult = pow(dx * dx + dy * dy,
                       ((double) (dev->ptrfeed->ctrl.num) /
                        (double) (dev->ptrfeed->ctrl.den) - 1.0) / 2.0) / 2.0;
            if (dx != 0.0)
                valuator_mask_set_double(val, 0, mult * dx);
            if (dy != 0.0)
                valuator_mask_set_double(val, 1, mult * dy);
        }
    }
}
@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d137 3
a139 1
    if (!vel || !schemeData)
d141 1
d145 3
a147 1
    if (!InitializePredictableAccelerationProperties(dev, vel, schemeData))
d149 1
@


1.6
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d248 1
a248 1
        return (v >= 1.0f) ? Success : BadValue;
d251 1
a251 2
    if (v >= 1.0f)
        vel->const_acceleration = 1 / v;
@


1.5
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a63 2
int
 SetAccelerationProfile(DeviceVelocityPtr vel, int profile_num);
a64 1

d80 1
a80 1
#define DebugAccelF ErrorF
d424 1
a424 1
        ErrorF("(dix ptracc) invalid number of trackers\n");
d569 1
a569 1
    DebugAccelF("(dix prtacc) motion [dx: %i dy: %i dir:%i diff: %i]\n",
d617 2
a618 1
            DebugAccelF("(dix prtacc) query: tracker too old\n");
d630 1
a630 1
            DebugAccelF("(dix prtacc) query: no longer linear\n");
d651 1
a651 1
                DebugAccelF("(dix prtacc) query: tracker too different:"
d664 1
a664 1
        DebugAccelF("(dix prtacc) query: last tracker in effect\n");
d671 1
a671 1
        DebugAccelF("(dix prtacc) result: offset %i [dx: %i dy: %i diff: %i]\n",
d697 2
d744 1
a744 1
 * compute the acceleration for given velocity and enforce min_acceleartion
d774 1
a774 1
        DebugAccelF("(dix ptracc) profile skipped\n");
d794 2
a795 1
                                             vel->velocity) / 2, threshold,
d798 1
a798 1
        DebugAccelF("(dix ptracc) profile average [%.2f ... %.2f] is %.3f\n",
d804 2
a805 2
        DebugAccelF("(dix ptracc) profile sample [%.2f] is %.3f\n",
                    vel->velocity, res);
d1056 2
a1057 5
    /*sanity check */
    if (!dev) {
        ErrorF("[dix] accel: DeviceIntPtr was NULL");
        return NULL;
    }
d1116 1
d1126 1
a1126 2
                DebugAccelF("pos (%i | %i) delta x:%.3f y:%.3f\n", mult * dx,
                            mult * dy);
@


1.4
log
@Update to xserver 1.11.2
@
text
@d65 5
a69 4
SetAccelerationProfile(DeviceVelocityPtr vel, int profile_num);
static float
SimpleSmoothProfile(DeviceIntPtr dev, DeviceVelocityPtr vel, float velocity,
                    float threshold, float acc);
d85 1
a85 1
#define DebugAccelF(...) /* */
d103 2
a104 2
    vel->corr_mul = 10.0;      /* dots per 10 milisecond should be usable */
    vel->const_acceleration = 1.0;   /* no acceleration/deceleration  */
d107 1
a107 1
    vel->min_acceleration = 1.0; /* don't decelerate */
a115 1

d120 2
a121 1
FreeVelocityData(DeviceVelocityPtr vel){
a125 1

d131 2
a132 1
                                  ValuatorAccelerationPtr protoScheme) {
d136 1
a151 1

d159 1
d170 3
a172 1
            (PredictableAccelSchemePtr) dev->valuator->accelScheme.accelData);
a178 1

d203 1
a203 2
    if(checkOnly)
    {
d209 3
a211 2
    } else
	SetAccelerationProfile(vel, profile);
d248 1
a248 2
    if(checkOnly)
    {
d251 1
a251 1
	return (v >= 1.0f) ? Success : BadValue;
d254 2
a255 2
    if(v >= 1.0f)
	vel->const_acceleration = 1/v;
d263 3
a265 2
    float fval = 1.0/vel->const_acceleration;
    Atom prop_const_decel = XIGetKnownProperty(ACCEL_PROP_CONSTANT_DECELERATION);
d267 2
a268 2
                           XIGetKnownProperty(XATOM_FLOAT), 32,
                           PropModeReplace, 1, &fval, FALSE);
a272 1

d293 1
a293 2
    if(checkOnly)
    {
d296 1
a296 1
	return (v >= 1.0f) ? Success : BadValue;
d299 2
a300 2
    if(v >= 1.0f)
	veloc->min_acceleration = 1/v;
d308 7
a314 5
    float fval = 1.0/vel->min_acceleration;
    Atom prop_adapt_decel = XIGetKnownProperty(ACCEL_PROP_ADAPTIVE_DECELERATION);

    XIChangeDeviceProperty(dev, prop_adapt_decel, XIGetKnownProperty(XATOM_FLOAT), 32,
                           PropModeReplace, 1, &fval, FALSE);
d316 2
a317 1
    return XIRegisterPropertyHandler(dev, AccelSetAdaptDecelProperty, NULL, NULL);
a319 1

d340 1
a340 2
    if (checkOnly)
    {
d347 2
a348 2
    if(v > 0)
	vel->corr_mul = v;
d359 3
a361 2
    XIChangeDeviceProperty(dev, prop_velo_scale, XIGetKnownProperty(XATOM_FLOAT), 32,
                           PropModeReplace, 1, &fval, FALSE);
d367 4
a370 4
InitializePredictableAccelerationProperties(
    DeviceIntPtr dev,
    DeviceVelocityPtr  vel,
    PredictableAccelSchemePtr schemeData)
d373 2
a374 1
    if(!vel)
d390 2
a391 3
DeletePredictableAccelerationProperties(
    DeviceIntPtr dev,
    PredictableAccelSchemePtr scheme)
d426 3
a428 3
    if(ntracker < 1){
	ErrorF("(dix ptracc) invalid number of trackers\n");
	return;
d431 1
a431 1
    vel->tracker = (MotionTrackerPtr)calloc(ntracker, sizeof(MotionTracker));
d436 8
a443 8
    N   = (1 << 0),
    NE  = (1 << 1),
    E   = (1 << 2),
    SE  = (1 << 3),
    S   = (1 << 4),
    SW  = (1 << 5),
    W   = (1 << 6),
    NW  = (1 << 7),
d446 1
d459 2
a460 1
DoGetDirection(int dx, int dy){
d464 1
a464 1
    if(abs(dx) < 2 && abs(dy) < 2){
d466 1
a466 1
        if(dx > 0 && dy > 0)
d468 6
a473 6
        else if(dx > 0 && dy < 0)
            dir =  N | NE | E;
        else if(dx < 0 && dy < 0)
            dir =  W | NW | N;
        else if(dx < 0 && dy > 0)
            dir =  W | SW | S;
d475 8
a482 8
        else if(dx > 0)
            dir =  NE | E | SE;
        else if(dx < 0)
            dir =  NW | W | SW;
        else if(dy > 0)
            dir =  SE | S | SW;
        else if(dy < 0)
            dir =  NE | N | NW;
d484 4
a487 3
            dir = UNDEFINED; /* shouldn't happen */
    } else { /* compute angle and set appropriate flags */
        float r;
a489 3
#ifdef _ISOC99_SOURCE
        r = atan2f(dy, dx);
#else
a490 1
#endif
d502 1
a502 1
        r = (r+(M_PI*2.5))/(M_PI/4);
d505 4
a508 4
        i1 = (int)(r+0.1) % 8;
        i2 = (int)(r+0.9) % 8;
        if(i1 < 0 || i1 > 7 || i2 < 0 || i2 > 7)
            dir = UNDEFINED; /* shouldn't happen */
d526 2
a527 1
GetDirection(int dx, int dy){
d530 12
a541 11
    if (abs(dx) <= DIRECTION_CACHE_RANGE &&
	abs(dy) <= DIRECTION_CACHE_RANGE) {
	/* cacheable */
	dir = cache[DIRECTION_CACHE_RANGE+dx][DIRECTION_CACHE_RANGE+dy];
	if(dir == 0) {
	    dir = DoGetDirection(dx, dy);
	    cache[DIRECTION_CACHE_RANGE+dx][DIRECTION_CACHE_RANGE+dy] = dir;
	}
    }else{
	/* non-cacheable */
	dir = DoGetDirection(dx, dy);
a549 1

d559 1
a559 1
FeedTrackers(DeviceVelocityPtr vel, int dx, int dy, int cur_t)
d562 4
a565 3
    for(n = 0; n < vel->num_tracker; n++){
	vel->tracker[n].dx += dx;
	vel->tracker[n].dy += dy;
d568 2
a569 2
    vel->tracker[n].dx = 0;
    vel->tracker[n].dy = 0;
d583 4
a586 3
static float
CalcTracker(const MotionTracker *tracker, int cur_t){
    float dist = sqrt(tracker->dx * tracker->dx + tracker->dy * tracker->dy);
d588 3
a590 2
    if(dtime > 0)
	return dist / dtime;
d592 1
a592 1
	return 0;/* synonymous for NaN, since we're not C99 */
d602 3
a604 2
static float
QueryTrackers(DeviceVelocityPtr vel, int cur_t){
d606 1
d608 3
a610 2
    float initial_velocity = 0, result = 0, velocity_diff;
    float velocity_factor =  vel->corr_mul * vel->const_acceleration; /* premultiply */
d612 52
a663 53
    for(offset = 1; offset < vel->num_tracker; offset++){
	MotionTracker *tracker = TRACKER(vel, offset);
	float tracker_velocity;

	age_ms = cur_t - tracker->time;

	/* bail out if data is too old and protect from overrun */
	if (age_ms >= vel->reset_time || age_ms < 0) {
	    DebugAccelF("(dix prtacc) query: tracker too old\n");
	    break;
	}

	/*
	 * this heuristic avoids using the linear-motion velocity formula
	 * in CalcTracker() on motion that isn't exactly linear. So to get
	 * even more precision we could subdivide as a final step, so possible
	 * non-linearities are accounted for.
	 */
	dir &= tracker->dir;
	if(dir == 0){ /* we've changed octant of movement (e.g. NE â NW) */
	    DebugAccelF("(dix prtacc) query: no longer linear\n");
	    /* instead of breaking it we might also inspect the partition after,
	     * but actual improvement with this is probably rare. */
	    break;
	}

	tracker_velocity = CalcTracker(tracker, cur_t) * velocity_factor;

	if ((initial_velocity == 0 || offset <= vel->initial_range) && tracker_velocity != 0) {
	    /* set initial velocity and result */
	    result = initial_velocity = tracker_velocity;
	    used_offset = offset;
	} else if (initial_velocity != 0 && tracker_velocity != 0) {
	    velocity_diff = fabs(initial_velocity - tracker_velocity);

	    if (velocity_diff > vel->max_diff &&
		velocity_diff/(initial_velocity + tracker_velocity) >= vel->max_rel_diff) {
		/* we're not in range, quit - it won't get better. */
		DebugAccelF("(dix prtacc) query: tracker too different:"
		            " old %2.2f initial %2.2f diff: %2.2f\n",
		            tracker_velocity, initial_velocity, velocity_diff);
		break;
	    }
	    /* we're in range with the initial velocity,
	     * so this result is likely better
	     * (it contains more information). */
	    result = tracker_velocity;
	    used_offset = offset;
	}
    }
    if(offset == vel->num_tracker){
	DebugAccelF("(dix prtacc) query: last tracker in effect\n");
	used_offset = vel->num_tracker-1;
d665 5
d671 6
a676 4
    if(used_offset >= 0){
	MotionTracker *tracker = TRACKER(vel, used_offset);
	DebugAccelF("(dix prtacc) result: offset %i [dx: %i dy: %i diff: %i]\n",
	            used_offset, tracker->dx, tracker->dy, cur_t - tracker->time);
a677 1
#endif
d689 1
a689 5
ProcessVelocityData2D(
    DeviceVelocityPtr vel,
    int dx,
    int dy,
    int time)
d691 1
a691 1
    float velocity;
d707 2
a708 2
static inline float
ApplySimpleSoftening(int prev_delta, int delta)
d710 1
a710 1
    float result = delta;
d712 5
a716 5
    if (delta < -1 || delta > 1) {
	if (delta > prev_delta)
	    result -= 0.5;
	else if (delta < prev_delta)
	    result += 0.5;
a720 1

d728 1
a728 4
ApplySoftening(
        DeviceVelocityPtr vel,
        float* fdx,
        float* fdy)
d737 1
a737 1
ApplyConstantDeceleration(DeviceVelocityPtr vel, float *fdx, float *fdy)
d746 7
a752 7
float
BasicComputeAcceleration(
    DeviceIntPtr dev,
    DeviceVelocityPtr vel,
    float velocity,
    float threshold,
    float acc){
a753 1
    float result;
d758 1
a758 1
	result = vel->min_acceleration;
d767 5
a771 7
static float
ComputeAcceleration(
    DeviceIntPtr dev,
    DeviceVelocityPtr vel,
    float threshold,
    float acc){
    float result;
d773 2
a774 2
    if(vel->velocity <= 0){
	DebugAccelF("(dix ptracc) profile skipped\n");
d778 1
a778 1
	return 1;
d781 24
a804 20
    if(vel->average_accel && vel->velocity != vel->last_velocity){
	/* use simpson's rule to average acceleration between
	 * current and previous velocity.
	 * Though being the more natural choice, it causes a minor delay
	 * in comparison, so it can be disabled. */
	result = BasicComputeAcceleration(
	          dev, vel, vel->velocity, threshold, acc);
	result += BasicComputeAcceleration(
	          dev, vel, vel->last_velocity, threshold, acc);
	result += 4.0f * BasicComputeAcceleration(dev, vel,
	                   (vel->last_velocity + vel->velocity) / 2,
	                   threshold, acc);
	result /= 6.0f;
	DebugAccelF("(dix ptracc) profile average [%.2f ... %.2f] is %.3f\n",
	            vel->velocity, vel->last_velocity, result);
    }else{
	result = BasicComputeAcceleration(dev, vel,
	                                  vel->velocity, threshold, acc);
	DebugAccelF("(dix ptracc) profile sample [%.2f] is %.3f\n",
               vel->velocity, res);
a809 1

d817 4
a820 7
static float
PolynomialAccelerationProfile(
    DeviceIntPtr dev,
    DeviceVelocityPtr vel,
    float velocity,
    float ignored,
    float acc)
d822 1
a822 1
   return pow(velocity, (acc - 1.0) * 0.5);
a824 1

d829 4
a832 7
static float
ClassicProfile(
    DeviceIntPtr dev,
    DeviceVelocityPtr vel,
    float velocity,
    float threshold,
    float acc)
d835 4
a838 11
	return SimpleSmoothProfile (dev,
	                            vel,
	                            velocity,
                                    threshold,
                                    acc);
    } else {
	return PolynomialAccelerationProfile (dev,
	                                      vel,
	                                      velocity,
                                              0,
                                              acc);
a841 1

d850 4
a853 7
static float
PowerProfile(
    DeviceIntPtr dev,
    DeviceVelocityPtr vel,
    float velocity,
    float threshold,
    float acc)
d855 1
a855 1
    float vel_dist;
d857 1
a857 1
    acc = (acc-1.0) * 0.1f + 1.0; /* without this, acc of 2 is unuseable */
a864 1

d872 3
a874 2
static inline float
CalcPenumbralGradient(float x){
d877 1
a877 1
    return 0.5f + (x * sqrt(1.0f - x*x) + asin(x))/M_PI;
a879 1

d884 8
a891 11
static float
SimpleSmoothProfile(
    DeviceIntPtr dev,
    DeviceVelocityPtr vel,
    float velocity,
    float threshold,
    float acc)
{
    if(velocity < 1.0f)
        return CalcPenumbralGradient(0.5 + velocity*0.5) * 2.0f - 1.0f;
    if(threshold < 1.0f)
d899 1
a899 1
        return 1.0f + (CalcPenumbralGradient(velocity/acc) * (acc - 1.0f));
a901 1

d906 4
a909 7
static float
SmoothLinearProfile(
    DeviceIntPtr dev,
    DeviceVelocityPtr vel,
    float velocity,
    float threshold,
    float acc)
d911 1
a911 1
    float res, nv;
d913 2
a914 2
    if(acc > 1.0f)
        acc -= 1.0f; /*this is so acc = 1 is no acceleration */
d920 1
a920 1
    if(nv < 0){
d922 5
a926 3
    }else if(nv < 2){
        res = CalcPenumbralGradient(nv*0.25f)*2.0f;
    }else{
d929 1
a929 1
              + 1.0f; /* gradient crosses 2|1 */
a934 1

d939 4
a942 7
static float
SmoothLimitedProfile(
    DeviceIntPtr dev,
    DeviceVelocityPtr vel,
    float velocity,
    float threshold,
    float acc)
d944 1
a944 1
    float res;
d946 2
a947 2
    if(velocity >= threshold || threshold == 0.0f)
	return acc;
d949 1
a949 1
    velocity /= threshold; /* should be [0..1[ now */
d956 4
a959 8

static float
LinearProfile(
    DeviceIntPtr dev,
    DeviceVelocityPtr vel,
    float velocity,
    float threshold,
    float acc)
d964 3
a966 7
static float
NoProfile(
    DeviceIntPtr dev,
    DeviceVelocityPtr vel,
    float velocity,
    float threshold,
    float acc)
d972 23
a994 25
GetAccelerationProfile(
    DeviceVelocityPtr vel,
    int profile_num)
{
    switch(profile_num){
        case AccelProfileClassic:
            return ClassicProfile;
        case AccelProfileDeviceSpecific:
            return vel->deviceSpecificProfile;
        case AccelProfilePolynomial:
            return PolynomialAccelerationProfile;
        case AccelProfileSmoothLinear:
            return SmoothLinearProfile;
        case AccelProfileSimple:
            return SimpleSmoothProfile;
        case AccelProfilePower:
            return PowerProfile;
        case AccelProfileLinear:
            return LinearProfile;
        case AccelProfileSmoothLimited:
            return SmoothLimitedProfile;
        case AccelProfileNone:
            return NoProfile;
        default:
            return NULL;
d1009 1
a1009 3
SetAccelerationProfile(
    DeviceVelocityPtr vel,
    int profile_num)
d1012 1
d1015 2
a1016 2
    if(profile == NULL && profile_num != PROFILE_UNINITIALIZE)
	return FALSE;
a1030 1

d1041 2
a1042 3
SetDeviceSpecificAccelerationProfile(
        DeviceVelocityPtr vel,
        PointerAccelerationProfileFunc profile)
d1044 2
a1045 2
    if(vel)
	vel->deviceSpecificProfile = profile;
d1053 1
a1053 2
GetDevicePredictableAccelData(
	DeviceIntPtr dev)
d1055 9
a1063 9
    /*sanity check*/
    if(!dev){
	ErrorF("[dix] accel: DeviceIntPtr was NULL");
	return NULL;
    }
    if( dev->valuator &&
	dev->valuator->accelScheme.AccelSchemeProc ==
	    acceleratePointerPredictable &&
	dev->valuator->accelScheme.accelData != NULL){
d1065 2
a1066 2
	return ((PredictableAccelSchemePtr)
		dev->valuator->accelScheme.accelData)->vel;
d1081 1
a1081 4
acceleratePointerPredictable(
    DeviceIntPtr dev,
    ValuatorMask* val,
    CARD32 evtime)
d1083 1
a1083 1
    int dx = 0, dy = 0, tmpi;
d1087 1
a1087 1
    if (!velocitydata)
d1092 1
a1092 1
        return; /*we're inactive anyway, so skip the whole thing.*/
d1096 1
a1096 1
        dx = valuator_mask_get(val, 0);
d1100 1
a1100 1
        dy = valuator_mask_get(val, 1);
d1103 1
a1103 1
    if (dx || dy){
d1105 1
a1105 1
        if (ProcessVelocityData2D(velocitydata, dx , dy, evtime)) {
d1110 1
a1110 1
            float mult;
d1113 4
a1116 8
            mult = ComputeAcceleration (dev, velocitydata,
                                        dev->ptrfeed->ctrl.threshold,
                                        (float)dev->ptrfeed->ctrl.num /
                                            (float)dev->ptrfeed->ctrl.den);

            if(mult != 1.0f || velocitydata->const_acceleration != 1.0f) {
                float fdx = dx,
                      fdy = dy;
d1118 1
d1120 2
a1121 2
                    ApplySoftening(velocitydata, &fdx, &fdy);
                ApplyConstantDeceleration(velocitydata, &fdx, &fdy);
d1123 6
a1128 23
                /* Calculate the new delta (with accel) and drop it back
                 * into the valuator masks */
                if (dx) {
                    float tmp;
                    tmp = mult * fdx + dev->last.remainder[0];
                    /* Since it may not be apparent: lrintf() does not offer
                     * strong statements about rounding; however because we
                     * process each axis conditionally, there's no danger
                     * of a toggling remainder. Its lack of guarantees likely
                     * makes it faster on the average target. */
                    tmpi = lrintf(tmp);
                    valuator_mask_set(val, 0, tmpi);
                    dev->last.remainder[0] = tmp - (float)tmpi;
                }
                if (dy) {
                    float tmp;
                    tmp = mult * fdy + dev->last.remainder[1];
                    tmpi = lrintf(tmp);
                    valuator_mask_set(val, 1, tmpi);
                    dev->last.remainder[1] = tmp - (float)tmpi;
                }
                DebugAccelF("pos (%i | %i) remainders x: %.3f y: %.3f delta x:%.3f y:%.3f\n",
                            *px, *py, dev->last.remainder[0], dev->last.remainder[1], fdx, fdy);
a1136 2


d1142 2
a1143 4
acceleratePointerLightweight(
    DeviceIntPtr dev,
    ValuatorMask* val,
    CARD32 ignored)
d1145 2
a1146 2
    float mult = 0.0, tmpf;
    int dx = 0, dy = 0, tmpi;
d1156 1
a1156 1
    if (!dx && !dy)
d1162 5
a1166 9
            if ((abs(dx) + abs(dy)) >= dev->ptrfeed->ctrl.threshold) {
                tmpf = ((float)dx *
                        (float)(dev->ptrfeed->ctrl.num)) /
                       (float)(dev->ptrfeed->ctrl.den) +
                       dev->last.remainder[0];
                if (dx) {
                    tmpi = (int) tmpf;
                    valuator_mask_set(val, 0, tmpi);
                    dev->last.remainder[0] = tmpf - (float)tmpi;
d1169 4
a1172 8
                tmpf = ((float)dy *
                        (float)(dev->ptrfeed->ctrl.num)) /
                       (float)(dev->ptrfeed->ctrl.den) +
                       dev->last.remainder[1];
                if (dy) {
                    tmpi = (int) tmpf;
                    valuator_mask_set(val, 1, tmpi);
                    dev->last.remainder[1] = tmpf - (float)tmpi;
d1177 7
a1183 18
            mult = pow((float)dx * (float)dx + (float)dy * (float)dy,
                       ((float)(dev->ptrfeed->ctrl.num) /
                        (float)(dev->ptrfeed->ctrl.den) - 1.0) /
                       2.0) / 2.0;
            if (dx) {
                tmpf = mult * (float)dx +
                       dev->last.remainder[0];
                tmpi = (int) tmpf;
                valuator_mask_set(val, 0, tmpi);
                dev->last.remainder[0] = tmpf - (float)tmpi;
            }
            if (dy) {
                tmpf = mult * (float)dy +
                       dev->last.remainder[1];
                tmpi = (int)tmpf;
                valuator_mask_set(val, 1, tmpi);
                dev->last.remainder[1] = tmpf - (float)tmpi;
            }
@


1.3
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d33 1
d71 7
a93 1

d95 1
a95 1
 * Init struct so it should match the average case
d117 1
a117 1
 * Clean up
d126 27
a152 2
/*
 *  dix uninit helper, called through scheme
d157 7
a163 3
    /*sanity check*/
    if( dev->valuator->accelScheme.AccelSchemeProc == acceleratePointerPredictable
            && dev->valuator->accelScheme.accelData != NULL){
d165 4
a168 1
        FreeVelocityData(dev->valuator->accelScheme.accelData);
d171 1
a171 1
        DeletePredictableAccelerationProperties(dev);
d363 5
a367 2
BOOL
InitializePredictableAccelerationProperties(DeviceIntPtr dev)
d369 1
a369 2
    DeviceVelocityPtr  vel = GetDevicePredictableAccelData(dev);

d371 1
a371 1
	return FALSE;
d373 8
a380 4
    vel->prop_handlers[0] = AccelInitProfileProperty(dev, vel);
    vel->prop_handlers[1] = AccelInitDecelProperty(dev, vel);
    vel->prop_handlers[2] = AccelInitAdaptDecelProperty(dev, vel);
    vel->prop_handlers[3] = AccelInitScaleProperty(dev, vel);
d386 3
a388 1
DeletePredictableAccelerationProperties(DeviceIntPtr dev)
d390 1
a390 1
    DeviceVelocityPtr  vel;
d404 5
a408 3
    for (i = 0; vel && i < NPROPS_PREDICTABLE_ACCEL; i++)
	if (vel->prop_handlers[i])
	    XIUnregisterPropertyHandler(dev, vel->prop_handlers[i]);
d410 3
d428 1
a428 2
    vel->tracker = (MotionTrackerPtr)malloc(ntracker * sizeof(MotionTracker));
    memset(vel->tracker, 0, ntracker * sizeof(MotionTracker));
d432 11
a444 1
 * 0 = N, 2 = E, 4 = S, 6 = W, in-between is as you guess.
d450 3
d456 2
a457 2
    float r;
    int i1, i2;
d459 10
a468 10
    if(abs(dx) < 2 && abs(dy < 2)){
	/* first check diagonal cases */
	if(dx > 0 && dy > 0)
	    return 4+8+16;
	if(dx > 0 && dy < 0)
	    return 1+2+4;
	if(dx < 0 && dy < 0)
	    return 1+128+64;
	if(dx < 0 && dy > 0)
	    return 16+32+64;
d470 14
a483 11
	if(dx > 0)
            return 2+4+8; /*E*/
        if(dx < 0)
            return 128+64+32; /*W*/
        if(dy > 0)
            return 32+16+8; /*S*/
        if(dy < 0)
            return 128+1+2; /*N*/
        return 255; /* shouldn't happen */
    }
    /* else, compute angle and set appropriate flags */
d485 1
a485 1
    r = atan2f(dy, dx);
d487 1
a487 1
    r = atan2(dy, dx);
d489 22
a510 10
    /* find direction. We avoid r to become negative,
     * since C has no well-defined modulo for such cases. */
    r = (r+(M_PI*2.5))/(M_PI/4);
    /* this intends to flag 2 directions (90 degrees),
     * except on very well-aligned mickeys. */
    i1 = (int)(r+0.1) % 8;
    i2 = (int)(r+0.9) % 8;
    if(i1 < 0 || i1 > 7 || i2 < 0 || i2 > 7)
	return 255; /* shouldn't happen */
    return 1 << i1 | 1 << i2;
d516 7
a522 1
/* cache DoGetDirection(). */
d526 1
a526 1
    int i;
d530 4
a533 7
	i = cache[DIRECTION_CACHE_RANGE+dx][DIRECTION_CACHE_RANGE+dy];
	if(i != 0){
	    return i;
	}else{
	    i = DoGetDirection(dx, dy);
	    cache[DIRECTION_CACHE_RANGE+dx][DIRECTION_CACHE_RANGE+dy] = i;
	    return i;
d537 1
a537 1
	return DoGetDirection(dx, dy);
d539 2
d549 1
d551 4
d580 3
a582 5
CalcTracker(DeviceVelocityPtr vel, int offset, int cur_t){
    int index = TRACKER_INDEX(vel, offset);
    float dist = sqrt(  vel->tracker[index].dx * vel->tracker[index].dx
                      + vel->tracker[index].dy * vel->tracker[index].dy);
    int dtime = cur_t - vel->tracker[index].time;
d590 3
a592 2
 * (in time) tracker which isn't too old, beyond a linear partition,
 * or simply too much off initial velocity.
d594 1
a594 1
 * May return 0.
d598 1
a598 1
    int n, offset, dir = 255, i = -1, age_ms;
d600 2
a601 2
    float iveloc = 0, res = 0, tmp, vdiff;
    float vfac =  vel->corr_mul * vel->const_acceleration; /* premultiply */
d604 2
a605 1
	n = TRACKER_INDEX(vel, offset);
d607 1
a607 1
	age_ms = cur_t - vel->tracker[n].time;
d621 2
a622 2
	dir &= vel->tracker[n].dir;
	if(dir == 0){
d629 1
a629 1
	tmp = CalcTracker(vel, offset, cur_t) * vfac;
d631 1
a631 1
	if ((iveloc == 0 || offset <= vel->initial_range) && tmp != 0) {
d633 7
a639 12
	    res = iveloc = tmp;
	    i = offset;
	} else if (iveloc != 0 && tmp != 0) {
	    vdiff = fabs(iveloc - tmp);
	    if (vdiff <= vel->max_diff ||
		vdiff/(iveloc + tmp) < vel->max_rel_diff) {
		/* we're in range with the initial velocity,
		 * so this result is likely better
		 * (it contains more information). */
		res = tmp;
		i = offset;
	    }else{
d643 1
a643 1
		            tmp, iveloc, vdiff);
d646 5
d655 1
a655 1
	i = vel->num_tracker-1;
d657 3
a659 2
    if(i>=0){
        n = TRACKER_INDEX(vel, i);
d661 1
a661 4
	            i,
	            vel->tracker[n].dx,
	            vel->tracker[n].dy,
	            cur_t - vel->tracker[n].time);
d663 2
a664 1
    return res;
d668 1
d674 1
a674 1
short
d698 1
a698 1
ApplySimpleSoftening(int od, int d)
d700 9
a708 8
    float res = d;
    if (d <= 1 && d >= -1)
        return res;
    if (d > od)
        res -= 0.5;
    else if (d < od)
        res += 0.5;
    return res;
d712 6
d719 1
a719 1
ApplySofteningAndConstantDeceleration(
a720 2
        int dx,
        int dy,
d722 1
a722 2
        float* fdy,
        short do_soften)
d724 3
a726 6
    if (do_soften && vel->use_softening) {
        *fdx = ApplySimpleSoftening(vel->last_dx, dx);
        *fdy = ApplySimpleSoftening(vel->last_dy, dy);
    } else {
        *fdx = dx;
        *fdy = dy;
d728 1
d730 3
d759 2
d768 1
a768 1
    float res;
d783 1
a783 1
	res = BasicComputeAcceleration(
d785 1
a785 1
	res += BasicComputeAcceleration(
d787 1
a787 1
	res += 4.0f * BasicComputeAcceleration(dev, vel,
d790 1
a790 1
	res /= 6.0f;
d792 1
a792 2
	            vel->velocity, vel->last_velocity, res);
        return res;
d794 2
a795 2
	res = BasicComputeAcceleration(dev, vel,
	                               vel->velocity, threshold, acc);
a797 1
	return res;
d799 2
d1051 3
a1053 5
    if(vel->profile_private != NULL){
        /* Here one could free old profile-private data */
        free(vel->profile_private);
        vel->profile_private = NULL;
    }
d1101 2
a1102 1
	return (DeviceVelocityPtr)dev->valuator->accelScheme.accelData;
d1119 5
a1123 11
    int first_valuator,
    int num_valuators,
    int *valuators,
    int evtime)
{
    float mult = 0.0;
    int dx = 0, dy = 0;
    int *px = NULL, *py = NULL;
    DeviceVelocityPtr velocitydata =
	(DeviceVelocityPtr) dev->valuator->accelScheme.accelData;
    float fdx, fdy, tmp; /* no need to init */
d1126 1
a1126 1
    if (!num_valuators || !valuators || !velocitydata)
d1130 2
a1131 2
	velocitydata->const_acceleration == 1.0f) {
	return; /*we're inactive anyway, so skip the whole thing.*/
d1134 2
a1135 3
    if (first_valuator == 0) {
        dx = valuators[0];
        px = &valuators[0];
d1137 3
a1139 3
    if (first_valuator <= 1 && num_valuators >= (2 - first_valuator)) {
        dy = valuators[1 - first_valuator];
        py = &valuators[1 - first_valuator];
d1149 2
d1153 11
a1163 9
					dev->ptrfeed->ctrl.threshold,
					(float)dev->ptrfeed->ctrl.num /
					(float)dev->ptrfeed->ctrl.den);

            if(mult != 1.0 || velocitydata->const_acceleration != 1.0) {
                ApplySofteningAndConstantDeceleration( velocitydata,
						       dx, dy,
						       &fdx, &fdy,
						       (mult > 1.0) && soften);
d1165 2
d1168 1
d1175 3
a1177 2
                    *px = lrintf(tmp);
                    dev->last.remainder[0] = tmp - (float)*px;
d1180 1
d1182 3
a1184 2
                    *py = lrintf(tmp);
                    dev->last.remainder[1] = tmp - (float)*py;
d1205 5
a1209 8
    int first_valuator,
    int num_valuators,
    int *valuators,
    int ignored)
{
    float mult = 0.0;
    int dx = 0, dy = 0;
    int *px = NULL, *py = NULL;
d1211 3
a1213 2
    if (!num_valuators || !valuators)
        return;
d1215 2
a1216 7
    if (first_valuator == 0) {
        dx = valuators[0];
        px = &valuators[0];
    }
    if (first_valuator <= 1 && num_valuators >= (2 - first_valuator)) {
        dy = valuators[1 - first_valuator];
        py = &valuators[1 - first_valuator];
d1226 8
a1233 8
                dev->last.remainder[0] = ((float)dx *
                                             (float)(dev->ptrfeed->ctrl.num)) /
                                             (float)(dev->ptrfeed->ctrl.den) +
                                            dev->last.remainder[0];
                if (px) {
                    *px = (int)dev->last.remainder[0];
                    dev->last.remainder[0] = dev->last.remainder[0] -
                                                (float)(*px);
d1236 8
a1243 8
                dev->last.remainder[1] = ((float)dy *
                                             (float)(dev->ptrfeed->ctrl.num)) /
                                             (float)(dev->ptrfeed->ctrl.den) +
                                            dev->last.remainder[1];
                if (py) {
                    *py = (int)dev->last.remainder[1];
                    dev->last.remainder[1] = dev->last.remainder[1] -
                                                (float)(*py);
d1248 1
a1248 1
	    mult = pow((float)dx * (float)dx + (float)dy * (float)dy,
d1253 5
a1257 5
                dev->last.remainder[0] = mult * (float)dx +
                                            dev->last.remainder[0];
                *px = (int)dev->last.remainder[0];
                dev->last.remainder[0] = dev->last.remainder[0] -
                                            (float)(*px);
d1260 5
a1264 5
                dev->last.remainder[1] = mult * (float)dy +
                                            dev->last.remainder[1];
                *py = (int)dev->last.remainder[1];
                dev->last.remainder[1] = dev->last.remainder[1] -
                                            (float)(*py);
@


1.2
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a85 2
/* number of properties for predictable acceleration */
#define NPROPS_PREDICTABLE_ACCEL 4
d114 1
a114 1
    xfree(vel->tracker);
d130 1
a130 1
        xfree(dev->valuator->accelScheme.accelData);
a323 3
static int AccelPropHandlerPrivateKeyIndex;
DevPrivateKey AccelPropHandlerPrivateKey = &AccelPropHandlerPrivateKeyIndex;

a327 1
    long *prop_handlers;
a330 6
    prop_handlers = xalloc(NPROPS_PREDICTABLE_ACCEL * sizeof(long));

    prop_handlers[0] = AccelInitProfileProperty(dev, vel);
    prop_handlers[1] = AccelInitDecelProperty(dev, vel);
    prop_handlers[2] = AccelInitAdaptDecelProperty(dev, vel);
    prop_handlers[3] = AccelInitScaleProperty(dev, vel);
d332 4
a335 2
    dixSetPrivate(&dev->devPrivates, AccelPropHandlerPrivateKey,
                  prop_handlers);
d343 1
a344 1
    long *prop_handlers;
d356 4
a359 7
    prop_handlers = dixLookupPrivate(&dev->devPrivates,
                                     AccelPropHandlerPrivateKey);
    dixSetPrivate(&dev->devPrivates, AccelPropHandlerPrivateKey, NULL);

    for (i = 0; prop_handlers && i < NPROPS_PREDICTABLE_ACCEL; i++)
        XIUnregisterPropertyHandler(dev, prop_handlers[i]);
    xfree(prop_handlers);
d375 2
a376 2
    xfree(vel->tracker);
    vel->tracker = (MotionTrackerPtr)xalloc(ntracker * sizeof(MotionTracker));
d497 1
a497 1
	return (dist / dtime);
d957 1
a957 1
        xfree(vel->profile_private);
@


1.1
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d3 1
a3 1
 * Copyright Â© 2006-2008 Simon Thum             simon dot thum at gmx dot de
d31 4
a34 3
#include <inputstr.h>
#include <assert.h>
#include <os.h>
d39 1
a39 1
 * 2006-2008 by Simon Thum (simon [dot] thum [at] gmx de)
d56 2
a57 2
 *  The profile can be selected by the user (potentially at runtime).
 *  the classic profile is intended to cleanly perform old-style
a62 6
static inline void
FeedFilterStage(FilterStagePtr s, float value, int tdiff);
extern void
InitFilterStage(FilterStagePtr s, float rdecay, int lutsize);
void
CleanupFilterChain(DeviceVelocityPtr s);
d64 1
a64 6
SetAccelerationProfile(DeviceVelocityPtr s, int profile_num);
void
InitFilterChain(DeviceVelocityPtr s, float rdecay, float degression,
                int stages, int lutsize);
void
CleanupFilterChain(DeviceVelocityPtr s);
d66 1
a66 1
SimpleSmoothProfile(DeviceVelocityPtr pVel, float velocity,
d68 2
a69 2


d80 1
a80 1
 *  Init/Uninit etc
d83 6
d93 1
a93 1
InitVelocityData(DeviceVelocityPtr s)
d95 1
a95 1
    memset(s, 0, sizeof(DeviceVelocityRec));
d97 11
a107 9
    s->corr_mul = 10.0;      /* dots per 10 milisecond should be usable */
    s->const_acceleration = 1.0;   /* no acceleration/deceleration  */
    s->reset_time = 300;
    s->use_softening = 1;
    s->min_acceleration = 1.0; /* don't decelerate */
    s->coupling = 0.25;
    s->average_accel = TRUE;
    SetAccelerationProfile(s, AccelProfileClassic);
    InitFilterChain(s, (float)1.0/20.0, 1, 1, 40);
d114 4
a117 4
static void
FreeVelocityData(DeviceVelocityPtr s){
    CleanupFilterChain(s);
    SetAccelerationProfile(s, -1);
d125 1
a125 1
AccelerationDefaultCleanup(DeviceIntPtr pDev)
d128 7
a134 6
    if( pDev->valuator->accelScheme.AccelSchemeProc == acceleratePointerPredictable
            && pDev->valuator->accelScheme.accelData != NULL){
        pDev->valuator->accelScheme.AccelSchemeProc = NULL;
        FreeVelocityData(pDev->valuator->accelScheme.accelData);
        xfree(pDev->valuator->accelScheme.accelData);
        pDev->valuator->accelScheme.accelData = NULL;
d138 4
a141 3
/*********************
 * Filtering logic
 ********************/
d144 23
a166 2
Initialize a filter chain.
Expected result is a series of filters, each progressively more integrating.
d168 6
a173 27
This allows for two strategies: Either you have one filter which is reasonable
and is being coupled to account for fast-changing input, or you have 'one for
every situation'. You might want to have tighter coupling then, e.g. 0.1.
In the filter stats, you can see if a reasonable filter useage emerges.
*/
void
InitFilterChain(DeviceVelocityPtr s, float rdecay, float progression, int stages, int lutsize)
{
    int fn;
    if((stages > 1 && progression < 1.0f) || 0 == progression){
	ErrorF("(dix ptracc) invalid filter chain progression specified\n");
	return;
    }
    /* Block here to support runtime filter adjustment */
    OsBlockSignals();
    for(fn = 0; fn < MAX_VELOCITY_FILTERS; fn++){
	if(fn < stages){
	    InitFilterStage(&s->filters[fn], rdecay, lutsize);
	}else{
	    InitFilterStage(&s->filters[fn], 0, 0);
	}
	rdecay /= progression;
    }
    /* release again. Should the input loop be threaded, we also need
     * memory release here (in principle).
     */
    OsReleaseSignals();
d176 2
a177 3

void
CleanupFilterChain(DeviceVelocityPtr s)
d179 2
a180 1
    int fn;
d182 4
a185 2
    for(fn = 0; fn < MAX_VELOCITY_FILTERS; fn++)
	InitFilterStage(&s->filters[fn], 0, 0);
d188 6
a193 2
static inline void
StuffFilterChain(DeviceVelocityPtr s, float value)
d195 4
a198 1
    int fn;
d200 13
a212 4
    for(fn = 0; fn < MAX_VELOCITY_FILTERS; fn++){
	if(s->filters[fn].rdecay != 0)
	    s->filters[fn].current = value;
	else break;
d214 17
d235 1
a235 5
 * Adjust weighting decay and lut for a stage
 * The weight fn is designed so its integral 0->inf is unity, so we end
 * up with a stable (basically IIR) filter. It always draws
 * towards its more current input values, which have more weight the older
 * the last input value is.
d237 3
a239 2
void
InitFilterStage(FilterStagePtr s, float rdecay, int lutsize)
d241 18
a258 14
    int x;
    float *newlut;
    float *oldlut;

    s->fading_lut_size  = 0; /* prevent access */

    if(lutsize > 0){
        newlut = xalloc (sizeof(float)* lutsize);
        if(!newlut)
            return;
        for(x = 0; x < lutsize; x++)
            newlut[x] = pow(0.5, ((float)x) * rdecay);
    }else{
        newlut = NULL;
d260 17
a276 7
    oldlut = s->fading_lut;
    s->fading_lut = newlut;
    s->rdecay = rdecay;
    s->fading_lut_size = lutsize;
    s->current = 0;
    if(oldlut != NULL)
        xfree(oldlut);
d280 6
a285 2
static inline void
FeedFilterChain(DeviceVelocityPtr s, float value, int tdiff)
d287 7
a293 1
    int fn;
d295 11
a305 4
    for(fn = 0; fn < MAX_VELOCITY_FILTERS; fn++){
	if(s->filters[fn].rdecay != 0)
	    FeedFilterStage(&s->filters[fn], value, tdiff);
	else break;
d307 5
d314 5
d320 4
a323 9
static inline void
FeedFilterStage(FilterStagePtr s, float value, int tdiff){
    float fade;
    if(tdiff < s->fading_lut_size)
        fade = s->fading_lut[tdiff];
    else
        fade = pow(0.5, ((float)tdiff) * s->rdecay);
    s->current *= fade;    /* fade out old velocity */
    s->current += value * (1.0f - fade);    /* and add up current */
d326 12
a337 18
/**
 * Select the most filtered matching result. Also, the first
 * mismatching filter may be set to value (coupling).
 */
static inline float
QueryFilterChain(
    DeviceVelocityPtr s,
    float value)
{
    int fn, rfn = 0, cfn = -1;
    float cur, result = value;

    /* try to retrieve most integrated result 'within range'
     * Assumption: filter are in order least to most integrating */
    for(fn = 0; fn < MAX_VELOCITY_FILTERS; fn++){
	if(0.0f == s->filters[fn].rdecay)
	    break;
	cur = s->filters[fn].current;
d339 4
a342 7
	if (fabs(value - cur) <= (s->coupling * (value + cur))){
	    result = cur;
	    rfn = fn + 1; /*remember result determining filter */
	} else if(cfn == -1){
	    cfn = fn; /* remember first mismatching filter */
	}
    }
d344 2
a345 8
    s->statistics.filter_usecount[rfn]++;
    DebugAccelF("(dix ptracc) result from stage %i,  input %.2f, output %.2f\n",
           rfn, value, result);

    /* override first mismatching current (coupling) so the filter
     * catches up quickly. */
    if(cfn != -1)
        s->filters[cfn].current = result;
d347 1
a347 1
    return result;
d350 23
a372 3
/********************************
 *  velocity computation
 *******************************/
d374 1
a374 17
/**
 * return the axis if mickey is insignificant and axis-aligned,
 * -1 otherwise
 * 1 for x-axis
 * 2 for y-axis
 */
static inline short
GetAxis(int dx, int dy){
    if(dx == 0 || dy == 0){
        if(dx == 1 || dx == -1)
            return 1;
        if(dy == 1 || dy == -1)
            return 2;
        return -1;
    }else{
        return -1;
    }
d377 3
d381 2
a382 10
/**
 * Perform velocity approximation
 * return true if non-visible state reset is suggested
 */
static short
ProcessVelocityData(
    DeviceVelocityPtr s,
    int dx,
    int dy,
    int time)
d384 9
a392 1
    float cvelocity;
d394 72
a465 17
    int diff = time - s->lrm_time;
    int cur_ax, last_ax;
    short reset = (diff >= s->reset_time);

    /* remember last round's result */
    s->last_velocity = s->velocity;
    cur_ax = GetAxis(dx, dy);
    last_ax = GetAxis(s->last_dx, s->last_dy);

    if(cur_ax != last_ax && cur_ax != -1 && last_ax != -1 && !reset){
        /* correct for the error induced when diagonal movements are
           reported as alternating axis mickeys */
        dx += s->last_dx;
        dy += s->last_dy;
        diff += s->last_diff;
        s->last_diff = time - s->lrm_time; /* prevent repeating add-up */
        DebugAccelF("(dix ptracc) axial correction\n");
d467 2
a468 1
        s->last_diff = diff;
d470 4
a474 8
    /*
     * cvelocity is not a real velocity yet, more a motion delta. constant
     * acceleration is multiplied here to make the velocity an on-screen
     * velocity (pix/t as opposed to [insert unit]/t). This is intended to
     * make multiple devices with widely varying ConstantDecelerations respond
     * similar to acceleration controls.
     */
    cvelocity = (float)sqrt(dx*dx + dy*dy) * s->const_acceleration;
d476 2
a477 1
    s->lrm_time = time;
d479 18
a496 5
    if (s->reset_time < 0 || diff < 0) { /* reset disabled or timer overrun? */
        /* simply set velocity from current movement, no reset. */
        s->velocity = cvelocity;
        return FALSE;
    }
d498 16
a513 2
    if (diff == 0)
        diff = 1; /* prevent div-by-zero, though it shouldn't happen anyway*/
d515 23
a537 3
    /* translate velocity to dots/ms (somewhat intractable in integers,
       so we multiply by some per-device adjustable factor) */
    cvelocity = cvelocity * s->corr_mul / (float)diff;
a538 2
    /* short-circuit: when nv-reset the rest can be skipped */
    if(reset == TRUE){
d540 4
a543 2
	 * we don't really have a velocity here, since diff includes inactive
	 * time. This is dealt with in ComputeAcceleration.
d545 31
a575 5
	StuffFilterChain(s, cvelocity);
	s->velocity = s->last_velocity = cvelocity;
	s->last_reset = TRUE;
	DebugAccelF("(dix ptracc) non-visible state reset\n");
	return TRUE;
d577 29
d607 1
a607 13
    if(s->last_reset == TRUE){
	/*
	 * when here, we're probably processing the second mickey of a starting
	 * stroke. This happens to be the first time we can reasonably pretend
	 * that cvelocity is an actual velocity. Thus, to opt precision, we
	 * stuff that into the filter chain.
	 */
	s->last_reset = FALSE;
	DebugAccelF("(dix ptracc) after-reset vel:%.3f\n", cvelocity);
	StuffFilterChain(s, cvelocity);
	s->velocity = cvelocity;
	return FALSE;
    }
d609 1
a609 2
    /* feed into filter chain */
    FeedFilterChain(s, cvelocity, diff);
d611 1
a611 2
    /* perform coupling and decide final value */
    s->velocity = QueryFilterChain(s, cvelocity);
d613 2
a614 8
    DebugAccelF("(dix ptracc) guess: vel=%.3f diff=%d   %i|%i|%i|%i|%i|%i|%i|%i|%i\n",
           s->velocity, diff,
           s->statistics.filter_usecount[0], s->statistics.filter_usecount[1],
           s->statistics.filter_usecount[2], s->statistics.filter_usecount[3],
           s->statistics.filter_usecount[4], s->statistics.filter_usecount[5],
           s->statistics.filter_usecount[6], s->statistics.filter_usecount[7],
           s->statistics.filter_usecount[8]);
    return FALSE;
a616 1

d637 1
a637 1
        DeviceVelocityPtr s,
d644 3
a646 3
    if (do_soften && s->use_softening) {
        *fdx = ApplySimpleSoftening(s->last_dx, dx);
        *fdy = ApplySimpleSoftening(s->last_dy, dy);
d652 2
a653 2
    *fdx *= s->const_acceleration;
    *fdy *= s->const_acceleration;
d659 1
a659 1
static float
d661 2
a662 1
    DeviceVelocityPtr pVel,
d668 1
a668 1
    result = pVel->Profile(pVel, velocity, threshold, acc);
d671 2
a672 2
    if (result < pVel->min_acceleration)
	result = pVel->min_acceleration;
d681 1
d687 1
a687 1
    if(vel->last_reset){
d690 1
a690 3
         * This is intended to override the first estimate of a stroke,
         * which is too low (see ProcessVelocityData). 1 should make sure
         * the mickey is seen on screen.
d700 5
a704 3
	res = BasicComputeAcceleration(vel, vel->velocity, threshold, acc);
	res += BasicComputeAcceleration(vel, vel->last_velocity, threshold, acc);
	res += 4.0f * BasicComputeAcceleration(vel,
d712 2
a713 1
	res = BasicComputeAcceleration(vel, vel->velocity, threshold, acc);
d730 2
a731 1
    DeviceVelocityPtr pVel,
d746 2
a747 1
    DeviceVelocityPtr pVel,
d752 3
a754 2
    if (threshold) {
	return SimpleSmoothProfile (pVel,
d759 2
a760 1
	return PolynomialAccelerationProfile (pVel,
d778 2
a779 1
    DeviceVelocityPtr pVel,
d789 1
a789 1
        return pVel->min_acceleration;
d791 1
a791 1
    return (pow(acc, vel_dist)) * pVel->min_acceleration;
d816 2
a817 1
    DeviceVelocityPtr pVel,
d842 2
a843 1
    DeviceVelocityPtr pVel,
d866 1
a866 1
    res += pVel->min_acceleration;
d871 25
d898 2
a899 1
    DeviceVelocityPtr pVel,
d907 10
d918 3
a920 11
/**
 * Set the profile by number.
 * Intended to make profiles exchangeable at runtime.
 * If you created a profile, give it a number here and in the header to
 * make it selectable. In case some profile-specific init is needed, here
 * would be a good place, since FreeVelocityData() also calls this with -1.
 * returns FALSE (0) if profile number is unavailable.
 */
_X_EXPORT int
SetAccelerationProfile(
    DeviceVelocityPtr s,
a922 1
    PointerAccelerationProfileFunc profile;
a923 3
        case -1:
            profile = NULL;  /* Special case to uninit properly */
            break;
d925 1
a925 2
            profile = ClassicProfile;
            break;
d927 1
a927 4
            if(NULL == s->deviceSpecificProfile)
        	return FALSE;
            profile = s->deviceSpecificProfile;
            break;
d929 1
a929 2
            profile = PolynomialAccelerationProfile;
            break;
d931 1
a931 2
            profile = SmoothLinearProfile;
            break;
d933 1
a933 2
            profile = SimpleSmoothProfile;
            break;
d935 1
a935 2
            profile = PowerProfile;
            break;
d937 5
a941 4
            profile = LinearProfile;
            break;
        case AccelProfileReserved:
            /* reserved for future use, e.g. a user-defined profile */
d943 1
a943 1
            return FALSE;
d945 24
a968 1
    if(s->profile_private != NULL){
d970 2
a971 2
        xfree(s->profile_private);
        s->profile_private = NULL;
d974 2
a975 2
    s->Profile = profile;
    s->statistics.profile_number = profile_num;
d993 1
a993 1
_X_EXPORT void
d995 1
a995 1
        DeviceVelocityPtr s,
d998 2
a999 2
    if(s)
	s->deviceSpecificProfile = profile;
d1006 1
a1006 1
_X_EXPORT DeviceVelocityPtr
d1008 1
a1008 1
	DeviceIntPtr pDev)
d1011 1
a1011 1
    if(!pDev){
d1015 2
a1016 2
    if( pDev->valuator &&
	pDev->valuator->accelScheme.AccelSchemeProc ==
d1018 1
a1018 1
	pDev->valuator->accelScheme.accelData != NULL){
d1020 1
a1020 1
	return (DeviceVelocityPtr)pDev->valuator->accelScheme.accelData;
d1036 1
a1036 1
    DeviceIntPtr pDev,
d1046 3
a1048 2
	(DeviceVelocityPtr) pDev->valuator->accelScheme.accelData;
    float fdx, fdy; /* no need to init */
d1053 5
d1068 3
a1070 10
        /* reset nonvisible state? */
        if (ProcessVelocityData(velocitydata, dx , dy, evtime)) {
            /* set to center of pixel. makes sense as long as there are no
             * means of passing on sub-pixel values.
             */
            pDev->last.remainder[0] = pDev->last.remainder[1] = 0.5f;
            /* prevent softening (somewhat quirky solution,
            as it depends on the algorithm) */
            velocitydata->last_dx = dx;
            velocitydata->last_dy = dy;
d1073 1
a1073 1
        if (pDev->ptrfeed && pDev->ptrfeed->ctrl.num) {
d1075 4
a1078 4
            mult = ComputeAcceleration (velocitydata,
					pDev->ptrfeed->ctrl.threshold,
					(float)pDev->ptrfeed->ctrl.num /
					(float)pDev->ptrfeed->ctrl.den);
d1082 4
a1085 3
                                                       dx, dy,
                                                       &fdx, &fdy,
                                                       mult > 1.0);
d1087 8
a1094 3
                    pDev->last.remainder[0] = mult * fdx + pDev->last.remainder[0];
                    *px = (int)pDev->last.remainder[0];
                    pDev->last.remainder[0] = pDev->last.remainder[0] - (float)*px;
d1097 3
a1099 3
                    pDev->last.remainder[1] = mult * fdy + pDev->last.remainder[1];
                    *py = (int)pDev->last.remainder[1];
                    pDev->last.remainder[1] = pDev->last.remainder[1] - (float)*py;
d1101 2
d1119 1
a1119 1
    DeviceIntPtr pDev,
d1144 1
a1144 1
    if (pDev->ptrfeed && pDev->ptrfeed->ctrl.num) {
d1146 6
a1151 6
        if (pDev->ptrfeed->ctrl.threshold) {
            if ((abs(dx) + abs(dy)) >= pDev->ptrfeed->ctrl.threshold) {
                pDev->last.remainder[0] = ((float)dx *
                                             (float)(pDev->ptrfeed->ctrl.num)) /
                                             (float)(pDev->ptrfeed->ctrl.den) +
                                            pDev->last.remainder[0];
d1153 2
a1154 2
                    *px = (int)pDev->last.remainder[0];
                    pDev->last.remainder[0] = pDev->last.remainder[0] -
d1158 4
a1161 4
                pDev->last.remainder[1] = ((float)dy *
                                             (float)(pDev->ptrfeed->ctrl.num)) /
                                             (float)(pDev->ptrfeed->ctrl.den) +
                                            pDev->last.remainder[1];
d1163 2
a1164 2
                    *py = (int)pDev->last.remainder[1];
                    pDev->last.remainder[1] = pDev->last.remainder[1] -
d1171 2
a1172 2
                       ((float)(pDev->ptrfeed->ctrl.num) /
                        (float)(pDev->ptrfeed->ctrl.den) - 1.0) /
d1175 4
a1178 4
                pDev->last.remainder[0] = mult * (float)dx +
                                            pDev->last.remainder[0];
                *px = (int)pDev->last.remainder[0];
                pDev->last.remainder[0] = pDev->last.remainder[0] -
d1182 4
a1185 4
                pDev->last.remainder[1] = mult * (float)dy +
                                            pDev->last.remainder[1];
                *py = (int)pDev->last.remainder[1];
                pDev->last.remainder[1] = pDev->last.remainder[1] -
@

