head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.6
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.2
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.2
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.2
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.2
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	s0SI41sEunLdyFfd;

1.21
date	2015.11.07.16.48.52;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	7pAEtF6Y5EgemkuY;

1.20
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.19;
commitid	Te1daavkBLskZ8gc;

1.19
date	2014.09.27.17.53.00;	author matthieu;	state Exp;
branches;
next	1.18;
commitid	cVXoV5PxI8YrEaVA;

1.18
date	2014.05.02.19.27.47;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2013.09.28.15.36.33;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2013.08.24.19.44.31;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2013.06.07.17.28.47;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2012.08.05.18.11.37;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2012.06.10.13.21.21;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2011.12.18.16.08.59;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.05.13.32.49;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.07.04.20.40.19;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.02.16.08.39;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.21.20.10.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.05.15.36.04;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.27.19.02.26;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.21;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.13;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.56.23;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.56.23;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.12.13.21.17.09;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright © 2006 Nokia Corporation
 * Copyright © 2006-2007 Daniel Stone
 * Copyright © 2008 Red Hat, Inc.
 * Copyright © 2011 The Chromium Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors: Daniel Stone <daniel@@fooishbar.org>
 *          Peter Hutterer <peter.hutterer@@who-t.net>
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/keysym.h>
#include <X11/Xproto.h>
#include <math.h>
#include <limits.h>

#include "misc.h"
#include "resource.h"
#include "inputstr.h"
#include "scrnintstr.h"
#include "cursorstr.h"
#include "dixstruct.h"
#include "globals.h"
#include "dixevents.h"
#include "mipointer.h"
#include "eventstr.h"
#include "eventconvert.h"
#include "inpututils.h"
#include "mi.h"
#include "windowstr.h"

#include <X11/extensions/XKBproto.h>
#include "xkbsrv.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

#include <X11/extensions/XI.h>
#include <X11/extensions/XI2.h>
#include <X11/extensions/XIproto.h>
#include <pixman.h>
#include "exglobals.h"
#include "exevents.h"
#include "extnsionst.h"
#include "listdev.h"            /* for sizing up DeviceClassesChangedEvent */
#include "probes.h"

/* Number of motion history events to store. */
#define MOTION_HISTORY_SIZE 256

/**
 * InputEventList is the storage for input events generated by
 * QueuePointerEvents, QueueKeyboardEvents, and QueueProximityEvents.
 * This list is allocated on startup by the DIX.
 */
InternalEvent *InputEventList = NULL;

/**
 * Pick some arbitrary size for Xi motion history.
 */
int
GetMotionHistorySize(void)
{
    return MOTION_HISTORY_SIZE;
}

void
set_button_down(DeviceIntPtr pDev, int button, int type)
{
    if (type == BUTTON_PROCESSED)
        SetBit(pDev->button->down, button);
    else
        SetBit(pDev->button->postdown, button);
}

void
set_button_up(DeviceIntPtr pDev, int button, int type)
{
    if (type == BUTTON_PROCESSED)
        ClearBit(pDev->button->down, button);
    else
        ClearBit(pDev->button->postdown, button);
}

Bool
button_is_down(DeviceIntPtr pDev, int button, int type)
{
    Bool ret = FALSE;

    if (type & BUTTON_PROCESSED)
        ret = ret || BitIsOn(pDev->button->down, button);
    if (type & BUTTON_POSTED)
        ret = ret || BitIsOn(pDev->button->postdown, button);

    return ret;
}

void
set_key_down(DeviceIntPtr pDev, int key_code, int type)
{
    if (type == KEY_PROCESSED)
        SetBit(pDev->key->down, key_code);
    else
        SetBit(pDev->key->postdown, key_code);
}

void
set_key_up(DeviceIntPtr pDev, int key_code, int type)
{
    if (type == KEY_PROCESSED)
        ClearBit(pDev->key->down, key_code);
    else
        ClearBit(pDev->key->postdown, key_code);
}

Bool
key_is_down(DeviceIntPtr pDev, int key_code, int type)
{
    Bool ret = FALSE;

    if (type & KEY_PROCESSED)
        ret = ret || BitIsOn(pDev->key->down, key_code);
    if (type & KEY_POSTED)
        ret = ret || BitIsOn(pDev->key->postdown, key_code);

    return ret;
}

static Bool
key_autorepeats(DeviceIntPtr pDev, int key_code)
{
    return ! !(pDev->kbdfeed->ctrl.autoRepeats[key_code >> 3] &
               (1 << (key_code & 7)));
}

static void
init_touch_ownership(DeviceIntPtr dev, TouchOwnershipEvent *event, Time ms)
{
    memset(event, 0, sizeof(TouchOwnershipEvent));
    event->header = ET_Internal;
    event->type = ET_TouchOwnership;
    event->length = sizeof(TouchOwnershipEvent);
    event->time = ms;
    event->deviceid = dev->id;
}

static void
init_raw(DeviceIntPtr dev, RawDeviceEvent *event, Time ms, int type, int detail)
{
    memset(event, 0, sizeof(RawDeviceEvent));
    event->header = ET_Internal;
    event->length = sizeof(RawDeviceEvent);
    switch (type) {
    case MotionNotify:
        event->type = ET_RawMotion;
        break;
    case ButtonPress:
        event->type = ET_RawButtonPress;
        break;
    case ButtonRelease:
        event->type = ET_RawButtonRelease;
        break;
    case KeyPress:
        event->type = ET_RawKeyPress;
        break;
    case KeyRelease:
        event->type = ET_RawKeyRelease;
        break;
    case XI_TouchBegin:
        event->type = ET_RawTouchBegin;
        break;
    case XI_TouchUpdate:
        event->type = ET_RawTouchUpdate;
        break;
    case XI_TouchEnd:
        event->type = ET_RawTouchEnd;
        break;
    }
    event->time = ms;
    event->deviceid = dev->id;
    event->sourceid = dev->id;
    event->detail.button = detail;
}

static void
set_raw_valuators(RawDeviceEvent *event, ValuatorMask *mask,
                  BOOL use_unaccel, double *data)
{
    int i;

    use_unaccel = use_unaccel && valuator_mask_has_unaccelerated(mask);

    for (i = 0; i < valuator_mask_size(mask); i++) {
        if (valuator_mask_isset(mask, i)) {
            double v;

            SetBit(event->valuators.mask, i);

            if (use_unaccel)
                v = valuator_mask_get_unaccelerated(mask, i);
            else
                v = valuator_mask_get_double(mask, i);

            data[i] = v;
        }
    }
}

static void
set_valuators(DeviceIntPtr dev, DeviceEvent *event, ValuatorMask *mask)
{
    int i;

    /* Set the data to the previous value for unset absolute axes. The values
     * may be used when sent as part of an XI 1.x valuator event. */
    for (i = 0; i < valuator_mask_size(mask); i++) {
        if (valuator_mask_isset(mask, i)) {
            SetBit(event->valuators.mask, i);
            if (valuator_get_mode(dev, i) == Absolute)
                SetBit(event->valuators.mode, i);
            event->valuators.data[i] = valuator_mask_get_double(mask, i);
        }
        else
            event->valuators.data[i] = dev->valuator->axisVal[i];
    }
}

void
CreateClassesChangedEvent(InternalEvent *event,
                          DeviceIntPtr master, DeviceIntPtr slave, int flags)
{
    int i;
    DeviceChangedEvent *dce;
    CARD32 ms = GetTimeInMillis();

    dce = &event->changed_event;
    memset(dce, 0, sizeof(DeviceChangedEvent));
    dce->deviceid = slave->id;
    dce->masterid = master ? master->id : 0;
    dce->header = ET_Internal;
    dce->length = sizeof(DeviceChangedEvent);
    dce->type = ET_DeviceChanged;
    dce->time = ms;
    dce->flags = flags;
    dce->sourceid = slave->id;

    if (slave->button) {
        dce->buttons.num_buttons = slave->button->numButtons;
        for (i = 0; i < dce->buttons.num_buttons; i++)
            dce->buttons.names[i] = slave->button->labels[i];
    }
    if (slave->valuator) {
        dce->num_valuators = slave->valuator->numAxes;
        for (i = 0; i < dce->num_valuators; i++) {
            dce->valuators[i].min = slave->valuator->axes[i].min_value;
            dce->valuators[i].max = slave->valuator->axes[i].max_value;
            dce->valuators[i].resolution = slave->valuator->axes[i].resolution;
            dce->valuators[i].mode = slave->valuator->axes[i].mode;
            dce->valuators[i].name = slave->valuator->axes[i].label;
            dce->valuators[i].scroll = slave->valuator->axes[i].scroll;
            dce->valuators[i].value = slave->valuator->axisVal[i];
        }
    }
    if (slave->key) {
        dce->keys.min_keycode = slave->key->xkbInfo->desc->min_key_code;
        dce->keys.max_keycode = slave->key->xkbInfo->desc->max_key_code;
    }
}

/**
 * Rescale the coord between the two axis ranges.
 */
static double
rescaleValuatorAxis(double coord, AxisInfoPtr from, AxisInfoPtr to,
                    double defmin, double defmax)
{
    double fmin = defmin, fmax = defmax;
    double tmin = defmin, tmax = defmax;

    if (from && from->min_value < from->max_value) {
        fmin = from->min_value;
        fmax = from->max_value + 1;
    }
    if (to && to->min_value < to->max_value) {
        tmin = to->min_value;
        tmax = to->max_value + 1;
    }

    if (fmin == tmin && fmax == tmax)
        return coord;

    if (fmax == fmin)           /* avoid division by 0 */
        return 0.0;

    return (coord - fmin) * (tmax - tmin) / (fmax - fmin) + tmin;
}

/**
 * Update all coordinates when changing to a different SD
 * to ensure that relative reporting will work as expected
 * without loss of precision.
 *
 * pDev->last.valuators will be in absolute device coordinates after this
 * function.
 */
static void
updateSlaveDeviceCoords(DeviceIntPtr master, DeviceIntPtr pDev)
{
    int i;
    DeviceIntPtr lastSlave;

    /* master->last.valuators[0]/[1] is in desktop-wide coords and the actual
     * position of the pointer */
    pDev->last.valuators[0] = master->last.valuators[0];
    pDev->last.valuators[1] = master->last.valuators[1];

    if (!pDev->valuator)
        return;

    /* scale back to device coordinates */
    if (pDev->valuator->numAxes > 0) {
        pDev->last.valuators[0] = rescaleValuatorAxis(pDev->last.valuators[0],
                                                      NULL,
                                                      pDev->valuator->axes + 0,
                                                      screenInfo.x,
                                                      screenInfo.width);
    }
    if (pDev->valuator->numAxes > 1) {
        pDev->last.valuators[1] = rescaleValuatorAxis(pDev->last.valuators[1],
                                                      NULL,
                                                      pDev->valuator->axes + 1,
                                                      screenInfo.y,
                                                      screenInfo.height);
    }

    /* calculate the other axis as well based on info from the old
     * slave-device. If the old slave had less axes than this one,
     * last.valuators is reset to 0.
     */
    if ((lastSlave = master->last.slave) && lastSlave->valuator) {
        for (i = 2; i < pDev->valuator->numAxes; i++) {
            if (i >= lastSlave->valuator->numAxes) {
                pDev->last.valuators[i] = 0;
                valuator_mask_set_double(pDev->last.scroll, i, 0);
            }
            else {
                double val = pDev->last.valuators[i];

                val = rescaleValuatorAxis(val, lastSlave->valuator->axes + i,
                                          pDev->valuator->axes + i, 0, 0);
                pDev->last.valuators[i] = val;
                valuator_mask_set_double(pDev->last.scroll, i, val);
            }
        }
    }

}

/**
 * Allocate the motion history buffer.
 */
void
AllocateMotionHistory(DeviceIntPtr pDev)
{
    int size;

    free(pDev->valuator->motion);

    if (pDev->valuator->numMotionEvents < 1)
        return;

    /* An MD must have a motion history size large enough to keep all
     * potential valuators, plus the respective range of the valuators.
     * 3 * INT32 for (min_val, max_val, curr_val))
     */
    if (IsMaster(pDev))
        size = sizeof(INT32) * 3 * MAX_VALUATORS;
    else {
        ValuatorClassPtr v = pDev->valuator;
        int numAxes;

        /* XI1 doesn't understand mixed mode devices */
        for (numAxes = 0; numAxes < v->numAxes; numAxes++)
            if (valuator_get_mode(pDev, numAxes) != valuator_get_mode(pDev, 0))
                break;
        size = sizeof(INT32) * numAxes;
    }

    size += sizeof(Time);

    pDev->valuator->motion = calloc(pDev->valuator->numMotionEvents, size);
    pDev->valuator->first_motion = 0;
    pDev->valuator->last_motion = 0;
    if (!pDev->valuator->motion)
        ErrorF("[dix] %s: Failed to alloc motion history (%d bytes).\n",
               pDev->name, size * pDev->valuator->numMotionEvents);
}

/**
 * Dump the motion history between start and stop into the supplied buffer.
 * Only records the event for a given screen in theory, but in practice, we
 * sort of ignore this.
 *
 * If core is set, we only generate x/y, in INT16, scaled to screen coords.
 */
int
GetMotionHistory(DeviceIntPtr pDev, xTimecoord ** buff, unsigned long start,
                 unsigned long stop, ScreenPtr pScreen, BOOL core)
{
    char *ibuff = NULL, *obuff;
    int i = 0, ret = 0;
    int j, coord;
    Time current;

    /* The size of a single motion event. */
    int size;
    AxisInfo from, *to;         /* for scaling */
    INT32 *ocbuf, *icbuf;       /* pointer to coordinates for copying */
    INT16 *corebuf;
    AxisInfo core_axis = { 0 };

    if (!pDev->valuator || !pDev->valuator->numMotionEvents)
        return 0;

    if (core && !pScreen)
        return 0;

    if (IsMaster(pDev))
        size = (sizeof(INT32) * 3 * MAX_VALUATORS) + sizeof(Time);
    else
        size = (sizeof(INT32) * pDev->valuator->numAxes) + sizeof(Time);

    *buff = malloc(size * pDev->valuator->numMotionEvents);
    if (!(*buff))
        return 0;
    obuff = (char *) *buff;

    for (i = pDev->valuator->first_motion;
         i != pDev->valuator->last_motion;
         i = (i + 1) % pDev->valuator->numMotionEvents) {
        /* We index the input buffer by which element we're accessing, which
         * is not monotonic, and the output buffer by how many events we've
         * written so far. */
        ibuff = (char *) pDev->valuator->motion + (i * size);
        memcpy(&current, ibuff, sizeof(Time));

        if (current > stop) {
            return ret;
        }
        else if (current >= start) {
            if (core) {
                memcpy(obuff, ibuff, sizeof(Time));     /* copy timestamp */

                icbuf = (INT32 *) (ibuff + sizeof(Time));
                corebuf = (INT16 *) (obuff + sizeof(Time));

                /* fetch x coordinate + range */
                memcpy(&from.min_value, icbuf++, sizeof(INT32));
                memcpy(&from.max_value, icbuf++, sizeof(INT32));
                memcpy(&coord, icbuf++, sizeof(INT32));

                /* scale to screen coords */
                to = &core_axis;
                to->max_value = pScreen->width;
                coord =
                    rescaleValuatorAxis(coord, &from, to, 0, pScreen->width);

                memcpy(corebuf, &coord, sizeof(INT16));
                corebuf++;

                /* fetch y coordinate + range */
                memcpy(&from.min_value, icbuf++, sizeof(INT32));
                memcpy(&from.max_value, icbuf++, sizeof(INT32));
                memcpy(&coord, icbuf++, sizeof(INT32));

                to->max_value = pScreen->height;
                coord =
                    rescaleValuatorAxis(coord, &from, to, 0, pScreen->height);
                memcpy(corebuf, &coord, sizeof(INT16));

            }
            else if (IsMaster(pDev)) {
                memcpy(obuff, ibuff, sizeof(Time));     /* copy timestamp */

                ocbuf = (INT32 *) (obuff + sizeof(Time));
                icbuf = (INT32 *) (ibuff + sizeof(Time));
                for (j = 0; j < MAX_VALUATORS; j++) {
                    if (j >= pDev->valuator->numAxes)
                        break;

                    /* fetch min/max/coordinate */
                    memcpy(&from.min_value, icbuf++, sizeof(INT32));
                    memcpy(&from.max_value, icbuf++, sizeof(INT32));
                    memcpy(&coord, icbuf++, sizeof(INT32));

                    to = (j <
                          pDev->valuator->numAxes) ? &pDev->valuator->
                        axes[j] : NULL;

                    /* x/y scaled to screen if no range is present */
                    if (j == 0 && (from.max_value < from.min_value))
                        from.max_value = pScreen->width;
                    else if (j == 1 && (from.max_value < from.min_value))
                        from.max_value = pScreen->height;

                    /* scale from stored range into current range */
                    coord = rescaleValuatorAxis(coord, &from, to, 0, 0);
                    memcpy(ocbuf, &coord, sizeof(INT32));
                    ocbuf++;
                }
            }
            else
                memcpy(obuff, ibuff, size);

            /* don't advance by size here. size may be different to the
             * actually written size if the MD has less valuators than MAX */
            if (core)
                obuff += sizeof(INT32) + sizeof(Time);
            else
                obuff +=
                    (sizeof(INT32) * pDev->valuator->numAxes) + sizeof(Time);
            ret++;
        }
    }

    return ret;
}

/**
 * Update the motion history for a specific device, with the list of
 * valuators.
 *
 * Layout of the history buffer:
 *   for SDs: [time] [val0] [val1] ... [valn]
 *   for MDs: [time] [min_val0] [max_val0] [val0] [min_val1] ... [valn]
 *
 * For events that have some valuators unset:
 *      min_val == max_val == val == 0.
 */
static void
updateMotionHistory(DeviceIntPtr pDev, CARD32 ms, ValuatorMask *mask,
                    double *valuators)
{
    char *buff = (char *) pDev->valuator->motion;
    ValuatorClassPtr v;
    int i;

    if (!pDev->valuator->numMotionEvents)
        return;

    v = pDev->valuator;
    if (IsMaster(pDev)) {
        buff += ((sizeof(INT32) * 3 * MAX_VALUATORS) + sizeof(CARD32)) *
            v->last_motion;

        memcpy(buff, &ms, sizeof(Time));
        buff += sizeof(Time);

        memset(buff, 0, sizeof(INT32) * 3 * MAX_VALUATORS);

        for (i = 0; i < v->numAxes; i++) {
            int val;

            /* XI1 doesn't support mixed mode devices */
            if (valuator_get_mode(pDev, i) != valuator_get_mode(pDev, 0))
                break;
            if (valuator_mask_size(mask) <= i || !valuator_mask_isset(mask, i)) {
                buff += 3 * sizeof(INT32);
                continue;
            }
            memcpy(buff, &v->axes[i].min_value, sizeof(INT32));
            buff += sizeof(INT32);
            memcpy(buff, &v->axes[i].max_value, sizeof(INT32));
            buff += sizeof(INT32);
            val = valuators[i];
            memcpy(buff, &val, sizeof(INT32));
            buff += sizeof(INT32);
        }
    }
    else {

        buff += ((sizeof(INT32) * pDev->valuator->numAxes) + sizeof(CARD32)) *
            pDev->valuator->last_motion;

        memcpy(buff, &ms, sizeof(Time));
        buff += sizeof(Time);

        memset(buff, 0, sizeof(INT32) * pDev->valuator->numAxes);

        for (i = 0; i < MAX_VALUATORS; i++) {
            int val;

            if (valuator_mask_size(mask) <= i || !valuator_mask_isset(mask, i)) {
                buff += sizeof(INT32);
                continue;
            }
            val = valuators[i];
            memcpy(buff, &val, sizeof(INT32));
            buff += sizeof(INT32);
        }
    }

    pDev->valuator->last_motion = (pDev->valuator->last_motion + 1) %
        pDev->valuator->numMotionEvents;
    /* If we're wrapping around, just keep the circular buffer going. */
    if (pDev->valuator->first_motion == pDev->valuator->last_motion)
        pDev->valuator->first_motion = (pDev->valuator->first_motion + 1) %
            pDev->valuator->numMotionEvents;

    return;
}

/**
 * Returns the maximum number of events GetKeyboardEvents
 * and GetPointerEvents will ever return.
 *
 * This MUST be absolutely constant, from init until exit.
 */
int
GetMaximumEventsNum(void)
{
    /* One raw event
     * One device event
     * One possible device changed event
     * Lots of possible separate button scroll events (horiz + vert)
     * Lots of possible separate raw button scroll events (horiz + vert)
     */
    return 100;
}

/**
 * Clip an axis to its bounds, which are declared in the call to
 * InitValuatorAxisClassStruct.
 */
static void
clipAxis(DeviceIntPtr pDev, int axisNum, double *val)
{
    AxisInfoPtr axis;

    if (axisNum >= pDev->valuator->numAxes)
        return;

    axis = pDev->valuator->axes + axisNum;

    /* If a value range is defined, clip. If not, do nothing */
    if (axis->max_value <= axis->min_value)
        return;

    if (*val < axis->min_value)
        *val = axis->min_value;
    if (*val > axis->max_value)
        *val = axis->max_value;
}

/**
 * Clip every axis in the list of valuators to its bounds.
 */
static void
clipValuators(DeviceIntPtr pDev, ValuatorMask *mask)
{
    int i;

    for (i = 0; i < valuator_mask_size(mask); i++)
        if (valuator_mask_isset(mask, i)) {
            double val = valuator_mask_get_double(mask, i);

            clipAxis(pDev, i, &val);
            valuator_mask_set_double(mask, i, val);
        }
}

/**
 * Create the DCCE event (does not update the master's device state yet, this
 * is done in the event processing).
 * Pull in the coordinates from the MD if necessary.
 *
 * @@param events Pointer to a pre-allocated event array.
 * @@param dev The slave device that generated an event.
 * @@param type Either DEVCHANGE_POINTER_EVENT and/or DEVCHANGE_KEYBOARD_EVENT
 * @@param num_events The current number of events, returns the number of
 *        events if a DCCE was generated.
 * @@return The updated @@events pointer.
 */
InternalEvent *
UpdateFromMaster(InternalEvent *events, DeviceIntPtr dev, int type,
                 int *num_events)
{
    DeviceIntPtr master;

    master =
        GetMaster(dev,
                  (type & DEVCHANGE_POINTER_EVENT) ? MASTER_POINTER :
                  MASTER_KEYBOARD);

    if (master && master->last.slave != dev) {
        CreateClassesChangedEvent(events, master, dev,
                                  type | DEVCHANGE_SLAVE_SWITCH);
        if (IsPointerDevice(master)) {
            updateSlaveDeviceCoords(master, dev);
            master->last.numValuators = dev->last.numValuators;
        }
        master->last.slave = dev;
        (*num_events)++;
        events++;
    }
    return events;
}

/**
 * Move the device's pointer to the position given in the valuators.
 *
 * @@param dev The device whose pointer is to be moved.
 * @@param mask Valuator data for this event.
 */
static void
clipAbsolute(DeviceIntPtr dev, ValuatorMask *mask)
{
    int i;

    for (i = 0; i < valuator_mask_size(mask); i++) {
        double val;

        if (!valuator_mask_isset(mask, i))
            continue;
        val = valuator_mask_get_double(mask, i);
        clipAxis(dev, i, &val);
        valuator_mask_set_double(mask, i, val);
    }
}

static void
add_to_scroll_valuator(DeviceIntPtr dev, ValuatorMask *mask, int valuator, double value)
{
    double v;

    if (!valuator_mask_fetch_double(mask, valuator, &v))
        return;

    /* protect against scrolling overflow. INT_MAX for double, because
     * we'll eventually write this as 32.32 fixed point */
    if ((value > 0 && v > INT_MAX - value) || (value < 0 && v < INT_MIN - value)) {
        v = 0;

        /* reset last.scroll to avoid a button storm */
        valuator_mask_set_double(dev->last.scroll, valuator, 0);
    }
    else
        v += value;

    valuator_mask_set_double(mask, valuator, v);
}


static void
scale_for_device_resolution(DeviceIntPtr dev, ValuatorMask *mask)
{
    double y;
    ValuatorClassPtr v = dev->valuator;
    int xrange = v->axes[0].max_value - v->axes[0].min_value + 1;
    int yrange = v->axes[1].max_value - v->axes[1].min_value + 1;

    double screen_ratio = 1.0 * screenInfo.width/screenInfo.height;
    double device_ratio = 1.0 * xrange/yrange;
    double resolution_ratio = 1.0;
    double ratio;

    if (!valuator_mask_fetch_double(mask, 1, &y))
        return;

    if (v->axes[0].resolution != 0 && v->axes[1].resolution != 0)
        resolution_ratio = 1.0 * v->axes[0].resolution/v->axes[1].resolution;

    ratio = device_ratio/resolution_ratio/screen_ratio;
    valuator_mask_set_double(mask, 1, y / ratio);
}

/**
 * Move the device's pointer by the values given in @@valuators.
 *
 * @@param dev The device whose pointer is to be moved.
 * @@param[in,out] mask Valuator data for this event, modified in-place.
 */
static void
moveRelative(DeviceIntPtr dev, int flags, ValuatorMask *mask)
{
    int i;
    Bool clip_xy = IsMaster(dev) || !IsFloating(dev);
    ValuatorClassPtr v = dev->valuator;

    /* for abs devices in relative mode, we've just scaled wrong, since we
       mapped the device's shape into the screen shape. Undo this. */
    if ((flags & POINTER_ABSOLUTE) == 0 && v && v->numAxes > 1 &&
        v->axes[0].min_value < v->axes[0].max_value &&
        v->axes[1].min_value < v->axes[1].max_value) {
        scale_for_device_resolution(dev, mask);
    }

    /* calc other axes, clip, drop back into valuators */
    for (i = 0; i < valuator_mask_size(mask); i++) {
        double val = dev->last.valuators[i];

        if (!valuator_mask_isset(mask, i))
            continue;

        add_to_scroll_valuator(dev, mask, i, val);

        /* x & y need to go over the limits to cross screens if the SD
         * isn't currently attached; otherwise, clip to screen bounds. */
        if (valuator_get_mode(dev, i) == Absolute &&
            ((i != 0 && i != 1) || clip_xy)) {
            val = valuator_mask_get_double(mask, i);
            clipAxis(dev, i, &val);
            valuator_mask_set_double(mask, i, val);
        }
    }
}

/**
 * Accelerate the data in valuators based on the device's acceleration scheme.
 *
 * @@param dev The device which's pointer is to be moved.
 * @@param valuators Valuator mask
 * @@param ms Current time.
 */
static void
accelPointer(DeviceIntPtr dev, ValuatorMask *valuators, CARD32 ms)
{
    if (dev->valuator->accelScheme.AccelSchemeProc)
        dev->valuator->accelScheme.AccelSchemeProc(dev, valuators, ms);
}

/**
 * Scale from absolute screen coordinates to absolute coordinates in the
 * device's coordinate range.
 *
 * @@param dev The device to scale for.
 * @@param[in, out] mask The mask in desktop/screen coordinates, modified in place
 * to contain device coordinate range.
 * @@param flags If POINTER_SCREEN is set, mask is in per-screen coordinates.
 *              Otherwise, mask is in desktop coords.
 */
static void
scale_from_screen(DeviceIntPtr dev, ValuatorMask *mask, int flags)
{
    double scaled;
    ScreenPtr scr = miPointerGetScreen(dev);

    if (valuator_mask_isset(mask, 0)) {
        scaled = valuator_mask_get_double(mask, 0);
        if (flags & POINTER_SCREEN)
            scaled += scr->x;
        scaled = rescaleValuatorAxis(scaled,
                                     NULL, dev->valuator->axes + 0,
                                     screenInfo.x, screenInfo.width);
        valuator_mask_set_double(mask, 0, scaled);
    }
    if (valuator_mask_isset(mask, 1)) {
        scaled = valuator_mask_get_double(mask, 1);
        if (flags & POINTER_SCREEN)
            scaled += scr->y;
        scaled = rescaleValuatorAxis(scaled,
                                     NULL, dev->valuator->axes + 1,
                                     screenInfo.y, screenInfo.height);
        valuator_mask_set_double(mask, 1, scaled);
    }
}

/**
 * Scale from (absolute) device to screen coordinates here,
 *
 * The coordinates provided are always absolute. see fill_pointer_events for
 * information on coordinate systems.
 *
 * @@param dev The device to be moved.
 * @@param mask Mask of axis values for this event
 * @@param[out] devx x desktop-wide coordinate in device coordinate system
 * @@param[out] devy y desktop-wide coordinate in device coordinate system
 * @@param[out] screenx x coordinate in desktop coordinate system
 * @@param[out] screeny y coordinate in desktop coordinate system
 */
static ScreenPtr
scale_to_desktop(DeviceIntPtr dev, ValuatorMask *mask,
                 double *devx, double *devy, double *screenx, double *screeny)
{
    ScreenPtr scr = miPointerGetScreen(dev);
    double x, y;

    BUG_WARN(dev->valuator && dev->valuator->numAxes < 2);
    if (!dev->valuator || dev->valuator->numAxes < 2) {
        /* if we have no axes, last.valuators must be in screen coords
         * anyway */
        *devx = *screenx = dev->last.valuators[0];
        *devy = *screeny = dev->last.valuators[1];
        return scr;
    }

    if (valuator_mask_isset(mask, 0))
        x = valuator_mask_get_double(mask, 0);
    else
        x = dev->last.valuators[0];
    if (valuator_mask_isset(mask, 1))
        y = valuator_mask_get_double(mask, 1);
    else
        y = dev->last.valuators[1];

    /* scale x&y to desktop coordinates */
    *screenx = rescaleValuatorAxis(x, dev->valuator->axes + 0, NULL,
                                   screenInfo.x, screenInfo.width);
    *screeny = rescaleValuatorAxis(y, dev->valuator->axes + 1, NULL,
                                   screenInfo.y, screenInfo.height);

    *devx = x;
    *devy = y;

    return scr;
}

/**
 * If we have HW cursors, this actually moves the visible sprite. If not, we
 * just do all the screen crossing, etc.
 *
 * We use the screen coordinates here, call miPointerSetPosition() and then
 * scale back into device coordinates (if needed). miPSP will change x/y if
 * the screen was crossed.
 *
 * The coordinates provided are always absolute. The parameter mode
 * specifies whether it was relative or absolute movement that landed us at
 * those coordinates. see fill_pointer_events for information on coordinate
 * systems.
 *
 * @@param dev The device to be moved.
 * @@param mode Movement mode (Absolute or Relative)
 * @@param[out] mask Mask of axis values for this event, returns the
 * per-screen device coordinates after confinement
 * @@param[in,out] devx x desktop-wide coordinate in device coordinate system
 * @@param[in,out] devy y desktop-wide coordinate in device coordinate system
 * @@param[in,out] screenx x coordinate in desktop coordinate system
 * @@param[in,out] screeny y coordinate in desktop coordinate system
 * @@param[out] nevents Number of barrier events added to events
 * @@param[in,out] events List of events barrier events are added to
 */
static ScreenPtr
positionSprite(DeviceIntPtr dev, int mode, ValuatorMask *mask,
               double *devx, double *devy, double *screenx, double *screeny,
               int *nevents, InternalEvent* events)
{
    ScreenPtr scr = miPointerGetScreen(dev);
    double tmpx, tmpy;

    if (!dev->valuator || dev->valuator->numAxes < 2)
        return scr;

    tmpx = *screenx;
    tmpy = *screeny;

    /* miPointerSetPosition takes care of crossing screens for us, as well as
     * clipping to the current screen. Coordinates returned are in desktop
     * coord system */
    scr = miPointerSetPosition(dev, mode, screenx, screeny, nevents, events);

    /* If we were constrained, rescale x/y from the screen coordinates so
     * the device valuators reflect the correct position. For screen
     * crossing this doesn't matter much, the coords would be 0 or max.
     */
    if (tmpx != *screenx)
        *devx = rescaleValuatorAxis(*screenx, NULL, dev->valuator->axes + 0,
                                    screenInfo.x, screenInfo.width);

    if (tmpy != *screeny)
        *devy = rescaleValuatorAxis(*screeny, NULL, dev->valuator->axes + 1,
                                    screenInfo.y, screenInfo.height);

    /* Recalculate the per-screen device coordinates */
    if (valuator_mask_isset(mask, 0)) {
        double x;

        x = rescaleValuatorAxis(*screenx - scr->x, NULL,
                                dev->valuator->axes + 0, 0, scr->width);
        valuator_mask_set_double(mask, 0, x);
    }
    if (valuator_mask_isset(mask, 1)) {
        double y;

        y = rescaleValuatorAxis(*screeny - scr->y, NULL,
                                dev->valuator->axes + 1, 0, scr->height);
        valuator_mask_set_double(mask, 1, y);
    }

    return scr;
}

/**
 * Update the motion history for the device and (if appropriate) for its
 * master device.
 * @@param dev Slave device to update.
 * @@param mask Bit mask of valid valuators to append to history.
 * @@param num Total number of valuators to append to history.
 * @@param ms Current time
 */
static void
updateHistory(DeviceIntPtr dev, ValuatorMask *mask, CARD32 ms)
{
    if (!dev->valuator)
        return;

    updateMotionHistory(dev, ms, mask, dev->last.valuators);
    if (!IsMaster(dev) && !IsFloating(dev)) {
        DeviceIntPtr master = GetMaster(dev, MASTER_POINTER);

        updateMotionHistory(master, ms, mask, dev->last.valuators);
    }
}

static void
queueEventList(DeviceIntPtr device, InternalEvent *events, int nevents)
{
    int i;

    for (i = 0; i < nevents; i++)
        mieqEnqueue(device, &events[i]);
}

static void
event_set_root_coordinates(DeviceEvent *event, double x, double y)
{
    event->root_x = trunc(x);
    event->root_y = trunc(y);
    event->root_x_frac = x - trunc(x);
    event->root_y_frac = y - trunc(y);
}

/**
 * Generate internal events representing this keyboard event and enqueue
 * them on the event queue.
 *
 * This function is not reentrant. Disable signals before calling.
 *
 * @@param device The device to generate the event for
 * @@param type Event type, one of KeyPress or KeyRelease
 * @@param keycode Key code of the pressed/released key
 *
 */
void
QueueKeyboardEvents(DeviceIntPtr device, int type,
                    int keycode)
{
    int nevents;

    nevents = GetKeyboardEvents(InputEventList, device, type, keycode);
    queueEventList(device, InputEventList, nevents);
}

/**
 * Returns a set of InternalEvents for KeyPress/KeyRelease, optionally
 * also with valuator events.
 *
 * The DDX is responsible for allocating the event list in the first
 * place via InitEventList(), and for freeing it.
 *
 * @@return the number of events written into events.
 */
int
GetKeyboardEvents(InternalEvent *events, DeviceIntPtr pDev, int type,
                  int key_code)
{
    int num_events = 0;
    CARD32 ms = 0;
    DeviceEvent *event;
    RawDeviceEvent *raw;

#if XSERVER_DTRACE
    if (XSERVER_INPUT_EVENT_ENABLED()) {
        XSERVER_INPUT_EVENT(pDev->id, type, key_code, 0, 0,
                            NULL, NULL);
    }
#endif

    /* refuse events from disabled devices */
    if (!pDev->enabled)
        return 0;

    if (!events || !pDev->key || !pDev->focus || !pDev->kbdfeed ||
        (type != KeyPress && type != KeyRelease) ||
        (key_code < 8 || key_code > 255))
        return 0;

    num_events = 1;

    events =
        UpdateFromMaster(events, pDev, DEVCHANGE_KEYBOARD_EVENT, &num_events);

    /* Handle core repeating, via press/release/press/release. */
    if (type == KeyPress && key_is_down(pDev, key_code, KEY_POSTED)) {
        /* If autorepeating is disabled either globally or just for that key,
         * or we have a modifier, don't generate a repeat event. */
        if (!pDev->kbdfeed->ctrl.autoRepeat ||
            !key_autorepeats(pDev, key_code) ||
            pDev->key->xkbInfo->desc->map->modmap[key_code])
            return 0;
    }

    ms = GetTimeInMillis();

    raw = &events->raw_event;
    events++;
    num_events++;

    init_raw(pDev, raw, ms, type, key_code);

    event = &events->device_event;
    init_device_event(event, pDev, ms);
    event->detail.key = key_code;

    if (type == KeyPress) {
        event->type = ET_KeyPress;
        set_key_down(pDev, key_code, KEY_POSTED);
    }
    else if (type == KeyRelease) {
        event->type = ET_KeyRelease;
        set_key_up(pDev, key_code, KEY_POSTED);
    }

    return num_events;
}

/**
 * Initialize an event array large enough for num_events arrays.
 * This event list is to be passed into GetPointerEvents() and
 * GetKeyboardEvents().
 *
 * @@param num_events Number of elements in list.
 */
InternalEvent *
InitEventList(int num_events)
{
    InternalEvent *events = calloc(num_events, sizeof(InternalEvent));

    return events;
}

/**
 * Free an event list.
 *
 * @@param list The list to be freed.
 * @@param num_events Number of elements in list.
 */
void
FreeEventList(InternalEvent *list, int num_events)
{
    free(list);
}

/**
 * Transform vector x/y according to matrix m and drop the rounded coords
 * back into x/y.
 */
static void
transform(struct pixman_f_transform *m, double *x, double *y)
{
    struct pixman_f_vector p = {.v = {*x, *y, 1} };
    pixman_f_transform_point(m, &p);

    *x = p.v[0];
    *y = p.v[1];
}

static void
transformRelative(DeviceIntPtr dev, ValuatorMask *mask)
{
    double x = 0, y = 0;

    valuator_mask_fetch_double(mask, 0, &x);
    valuator_mask_fetch_double(mask, 1, &y);

    transform(&dev->relative_transform, &x, &y);

    if (x)
        valuator_mask_set_double(mask, 0, x);
    else
        valuator_mask_unset(mask, 0);

    if (y)
        valuator_mask_set_double(mask, 1, y);
    else
        valuator_mask_unset(mask, 1);
}

/**
 * Apply the device's transformation matrix to the valuator mask and replace
 * the scaled values in mask. This transformation only applies to valuators
 * 0 and 1, others will be untouched.
 *
 * @@param dev The device the valuators came from
 * @@param[in,out] mask The valuator mask.
 */
static void
transformAbsolute(DeviceIntPtr dev, ValuatorMask *mask)
{
    double x, y, ox, oy;
    int has_x, has_y;

    has_x = valuator_mask_isset(mask, 0);
    has_y = valuator_mask_isset(mask, 1);

    if (!has_x && !has_y)
        return;

    if (!has_x || !has_y) {
        struct pixman_f_transform invert;

        /* undo transformation from last event */
        ox = dev->last.valuators[0];
        oy = dev->last.valuators[1];

        pixman_f_transform_invert(&invert, &dev->scale_and_transform);
        transform(&invert, &ox, &oy);
    }

    if (has_x)
        ox = valuator_mask_get_double(mask, 0);

    if (has_y)
        oy = valuator_mask_get_double(mask, 1);

    x = ox;
    y = oy;

    transform(&dev->scale_and_transform, &x, &y);

    if (has_x || ox != x)
        valuator_mask_set_double(mask, 0, x);

    if (has_y || oy != y)
        valuator_mask_set_double(mask, 1, y);
}

static void
storeLastValuators(DeviceIntPtr dev, ValuatorMask *mask,
                   int xaxis, int yaxis, double devx, double devy)
{
    int i;

    /* store desktop-wide in last.valuators */
    if (valuator_mask_isset(mask, xaxis))
        dev->last.valuators[0] = devx;
    if (valuator_mask_isset(mask, yaxis))
        dev->last.valuators[1] = devy;

    for (i = 0; i < valuator_mask_size(mask); i++) {
        if (i == xaxis || i == yaxis)
            continue;

        if (valuator_mask_isset(mask, i))
            dev->last.valuators[i] = valuator_mask_get_double(mask, i);
    }

}

/**
 * Generate internal events representing this pointer event and enqueue them
 * on the event queue.
 *
 * This function is not reentrant. Disable signals before calling.
 *
 * @@param device The device to generate the event for
 * @@param type Event type, one of ButtonPress, ButtonRelease, MotionNotify
 * @@param buttons Button number of the buttons modified. Must be 0 for
 * MotionNotify
 * @@param flags Event modification flags
 * @@param mask Valuator mask for valuators present for this event.
 */
void
QueuePointerEvents(DeviceIntPtr device, int type,
                   int buttons, int flags, const ValuatorMask *mask)
{
    int nevents;

    nevents =
        GetPointerEvents(InputEventList, device, type, buttons, flags, mask);
    queueEventList(device, InputEventList, nevents);
}

/**
 * Helper function for GetPointerEvents, which only generates motion and
 * raw motion events for the slave device: does not update the master device.
 *
 * Should not be called by anyone other than GetPointerEvents.
 *
 * We use several different coordinate systems and need to switch between
 * the three in fill_pointer_events, positionSprite and
 * miPointerSetPosition. "desktop" refers to the width/height of all
 * screenInfo.screens[n]->width/height added up. "screen" is ScreenRec, not
 * output.
 *
 * Coordinate systems:
 * - relative events have a mask_in in relative coordinates, mapped to
 *   pixels. These events are mapped to the current position±delta.
 * - absolute events have a mask_in in absolute device coordinates in
 *   device-specific range. This range is mapped to the desktop.
 * - POINTER_SCREEN absolute events (x86WarpCursor) are in screen-relative
 *   screen coordinate range.
 * - rootx/rooty in events must be be relative to the current screen's
 *   origin (screen coordinate system)
 * - XI2 valuators must be relative to the current screen's origin. On
 *   the protocol the device min/max range maps to the current screen.
 *
 * For screen switching we need to get the desktop coordinates for each
 * event, then map that to the respective position on each screen and
 * position the cursor there.
 * The device's last.valuator[] stores the last position in desktop-wide
 * coordinates (in device range for slave devices, desktop range for master
 * devices).
 *
 * screen-relative device coordinates requires scaling: A device coordinate
 * x/y of range [n..m] that maps to positions Sx/Sy on Screen S must be
 * rescaled to match Sx/Sy for [n..m]. In the simplest example, x of (m/2-1)
 * is the last coordinate on the first screen and must be rescaled for the
 * event to be m. XI2 clients that do their own coordinate mapping would
 * otherwise interpret the position of the device elsewere to the cursor.
 * However, this scaling leads to losses:
 * if we have two ScreenRecs we scale from e.g. [0..44704]  (Wacom I4) to
 * [0..2048[. that gives us 2047.954 as desktop coord, or the per-screen
 * coordinate 1023.954. Scaling that back into the device coordinate range
 * gives us 44703. So off by one device unit. It's a bug, but we'll have to
 * live with it because with all this scaling, we just cannot win.
 *
 * @@return the number of events written into events.
 */
static int
fill_pointer_events(InternalEvent *events, DeviceIntPtr pDev, int type,
                    int buttons, CARD32 ms, int flags,
                    const ValuatorMask *mask_in)
{
    int num_events = 1;
    DeviceEvent *event;
    RawDeviceEvent *raw = NULL;
    double screenx = 0.0, screeny = 0.0;        /* desktop coordinate system */
    double devx = 0.0, devy = 0.0;      /* desktop-wide in device coords */
    int sx = 0, sy = 0;                 /* for POINTER_SCREEN */
    ValuatorMask mask;
    ScreenPtr scr;
    int num_barrier_events = 0;

    switch (type) {
    case MotionNotify:
        if (!pDev->valuator) {
            ErrorF("[dix] motion events from device %d without valuators\n",
                   pDev->id);
            return 0;
        }
        if (!mask_in || valuator_mask_num_valuators(mask_in) <= 0)
            return 0;
        break;
    case ButtonPress:
    case ButtonRelease:
        if (!pDev->button || !buttons)
            return 0;
        if (mask_in && valuator_mask_size(mask_in) > 0 && !pDev->valuator) {
            ErrorF
                ("[dix] button event with valuator from device %d without valuators\n",
                 pDev->id);
            return 0;
        }
        break;
    default:
        return 0;
    }

    valuator_mask_copy(&mask, mask_in);

    if ((flags & POINTER_NORAW) == 0) {
        raw = &events->raw_event;
        events++;
        num_events++;

        init_raw(pDev, raw, ms, type, buttons);
        set_raw_valuators(raw, &mask, TRUE, raw->valuators.data_raw);
    }

    valuator_mask_drop_unaccelerated(&mask);

    /* valuators are in driver-native format (rel or abs) */

    if (flags & POINTER_ABSOLUTE) {
        if (flags & (POINTER_SCREEN | POINTER_DESKTOP)) {    /* valuators are in screen/desktop coords */
            sx = valuator_mask_get(&mask, 0);
            sy = valuator_mask_get(&mask, 1);
            scale_from_screen(pDev, &mask, flags);
        }

        transformAbsolute(pDev, &mask);
        clipAbsolute(pDev, &mask);
        if ((flags & POINTER_NORAW) == 0 && raw)
            set_raw_valuators(raw, &mask, FALSE, raw->valuators.data);
    }
    else {
        transformRelative(pDev, &mask);

        if (flags & POINTER_ACCELERATE)
            accelPointer(pDev, &mask, ms);
        if ((flags & POINTER_NORAW) == 0 && raw)
            set_raw_valuators(raw, &mask, FALSE, raw->valuators.data);

        moveRelative(pDev, flags, &mask);
    }

    /* valuators are in device coordinate system in absolute coordinates */
    scale_to_desktop(pDev, &mask, &devx, &devy, &screenx, &screeny);

    /* #53037 XWarpPointer's scaling back and forth between screen and
       device may leave us with rounding errors. End result is that the
       pointer doesn't end up on the pixel it should.
       Avoid this by forcing screenx/screeny back to what the input
       coordinates were.
     */
    if (flags & POINTER_SCREEN) {
        scr = miPointerGetScreen(pDev);
        screenx = sx + scr->x;
        screeny = sy + scr->y;
    }

    scr = positionSprite(pDev, (flags & POINTER_ABSOLUTE) ? Absolute : Relative,
                         &mask, &devx, &devy, &screenx, &screeny,
                         &num_barrier_events, events);
    num_events += num_barrier_events;
    events += num_barrier_events;

    /* screenx, screeny are in desktop coordinates,
       mask is in device coordinates per-screen (the event data)
       devx/devy is in device coordinate desktop-wide */
    updateHistory(pDev, &mask, ms);

    clipValuators(pDev, &mask);

    storeLastValuators(pDev, &mask, 0, 1, devx, devy);

    /* Update the MD's co-ordinates, which are always in desktop space. */
    if (!IsMaster(pDev) && !IsFloating(pDev)) {
        DeviceIntPtr master = GetMaster(pDev, MASTER_POINTER);

        master->last.valuators[0] = screenx;
        master->last.valuators[1] = screeny;
    }

    event = &events->device_event;
    init_device_event(event, pDev, ms);

    if (type == MotionNotify) {
        event->type = ET_Motion;
        event->detail.button = 0;
    }
    else {
        if (type == ButtonPress) {
            event->type = ET_ButtonPress;
            set_button_down(pDev, buttons, BUTTON_POSTED);
        }
        else if (type == ButtonRelease) {
            event->type = ET_ButtonRelease;
            set_button_up(pDev, buttons, BUTTON_POSTED);
        }
        event->detail.button = buttons;
    }

    /* root_x and root_y must be in per-screen co-ordinates */
    event_set_root_coordinates(event, screenx - scr->x, screeny - scr->y);

    if (flags & POINTER_EMULATED) {
        if (raw)
            raw->flags = XIPointerEmulated;
        event->flags = XIPointerEmulated;
    }

    set_valuators(pDev, event, &mask);

    return num_events;
}

/**
 * Generate events for each scroll axis that changed between before/after
 * for the device.
 *
 * @@param events The pointer to the event list to fill the events
 * @@param dev The device to generate the events for
 * @@param type The real type of the event
 * @@param axis The axis number to generate events for
 * @@param mask State before this event in absolute coords
 * @@param[in,out] last Last scroll state posted in absolute coords (modified
 * in-place)
 * @@param ms Current time in ms
 * @@param max_events Max number of events to be generated
 * @@return The number of events generated
 */
static int
emulate_scroll_button_events(InternalEvent *events,
                             DeviceIntPtr dev,
                             int type,
                             int axis,
                             const ValuatorMask *mask,
                             ValuatorMask *last, CARD32 ms, int max_events)
{
    AxisInfoPtr ax;
    double delta;
    double incr;
    int num_events = 0;
    double total;
    int b;
    int flags = 0;

    if (dev->valuator->axes[axis].scroll.type == SCROLL_TYPE_NONE)
        return 0;

    if (!valuator_mask_isset(mask, axis))
        return 0;

    ax = &dev->valuator->axes[axis];
    incr = ax->scroll.increment;

    BUG_WARN_MSG(incr == 0, "for device %s\n", dev->name);
    if (incr == 0)
        return 0;

    if (type != ButtonPress && type != ButtonRelease)
        flags |= POINTER_EMULATED;

    if (!valuator_mask_isset(last, axis))
        valuator_mask_set_double(last, axis, 0);

    delta =
        valuator_mask_get_double(mask, axis) - valuator_mask_get_double(last,
                                                                        axis);
    total = delta;
    b = (ax->scroll.type == SCROLL_TYPE_VERTICAL) ? 5 : 7;

    if ((incr > 0 && delta < 0) || (incr < 0 && delta > 0))
        b--;                    /* we're scrolling up or left → button 4 or 6 */

    while (fabs(delta) >= fabs(incr)) {
        int nev_tmp;

        if (delta > 0)
            delta -= fabs(incr);
        else if (delta < 0)
            delta += fabs(incr);

        /* fill_pointer_events() generates four events: one normal and one raw
         * event for button press and button release.
         * We may get a bigger scroll delta than we can generate events
         * for. In that case, we keep decreasing delta, but skip events.
         */
        if (num_events + 4 < max_events) {
            if (type != ButtonRelease) {
                nev_tmp = fill_pointer_events(events, dev, ButtonPress, b, ms,
                                              flags, NULL);
                events += nev_tmp;
                num_events += nev_tmp;
            }
            if (type != ButtonPress) {
                nev_tmp = fill_pointer_events(events, dev, ButtonRelease, b, ms,
                                              flags, NULL);
                events += nev_tmp;
                num_events += nev_tmp;
            }
        }
    }

    /* We emulated, update last.scroll */
    if (total != delta) {
        total -= delta;
        valuator_mask_set_double(last, axis,
                                 valuator_mask_get_double(last, axis) + total);
    }

    return num_events;
}


/**
 * Generate a complete series of InternalEvents (filled into the EventList)
 * representing pointer motion, or button presses.  If the device is a slave
 * device, also potentially generate a DeviceClassesChangedEvent to update
 * the master device.
 *
 * events is not NULL-terminated; the return value is the number of events.
 * The DDX is responsible for allocating the event structure in the first
 * place via InitEventList() and GetMaximumEventsNum(), and for freeing it.
 *
 * In the generated events rootX/Y will be in absolute screen coords and
 * the valuator information in the absolute or relative device coords.
 *
 * last.valuators[x] of the device is always in absolute device coords.
 * last.valuators[x] of the master device is in absolute screen coords.
 *
 * master->last.valuators[x] for x > 2 is undefined.
 */
int
GetPointerEvents(InternalEvent *events, DeviceIntPtr pDev, int type,
                 int buttons, int flags, const ValuatorMask *mask_in)
{
    CARD32 ms = GetTimeInMillis();
    int num_events = 0, nev_tmp;
    ValuatorMask mask;
    ValuatorMask scroll;
    int i;
    int realtype = type;

#if XSERVER_DTRACE
    if (XSERVER_INPUT_EVENT_ENABLED()) {
        XSERVER_INPUT_EVENT(pDev->id, type, buttons, flags,
                            mask_in ? mask_in->last_bit + 1 : 0,
                            mask_in ? mask_in->mask : NULL,
                            mask_in ? mask_in->valuators : NULL);
    }
#endif

    BUG_RETURN_VAL(buttons >= MAX_BUTTONS, 0);

    /* refuse events from disabled devices */
    if (!pDev->enabled)
        return 0;

    if (!miPointerGetScreen(pDev))
        return 0;

    events = UpdateFromMaster(events, pDev, DEVCHANGE_POINTER_EVENT,
                              &num_events);

    valuator_mask_copy(&mask, mask_in);

    /* Turn a scroll button press into a smooth-scrolling event if
     * necessary. This only needs to cater for the XIScrollFlagPreferred
     * axis (if more than one scrolling axis is present) */
    if (type == ButtonPress) {
        double adj;
        int axis;
        int h_scroll_axis = -1;
        int v_scroll_axis = -1;

        if (pDev->valuator) {
            h_scroll_axis = pDev->valuator->h_scroll_axis;
            v_scroll_axis = pDev->valuator->v_scroll_axis;
        }

        /* Up is negative on valuators, down positive */
        switch (buttons) {
        case 4:
            adj = -1.0;
            axis = v_scroll_axis;
            break;
        case 5:
            adj = 1.0;
            axis = v_scroll_axis;
            break;
        case 6:
            adj = -1.0;
            axis = h_scroll_axis;
            break;
        case 7:
            adj = 1.0;
            axis = h_scroll_axis;
            break;
        default:
            adj = 0.0;
            axis = -1;
            break;
        }

        if (adj != 0.0 && axis != -1) {
            adj *= pDev->valuator->axes[axis].scroll.increment;
            if (!valuator_mask_isset(&mask, axis))
                valuator_mask_set(&mask, axis, 0);
            add_to_scroll_valuator(pDev, &mask, axis, adj);
            type = MotionNotify;
            buttons = 0;
            flags |= POINTER_EMULATED;
        }
    }

    /* First fill out the original event set, with smooth-scrolling axes. */
    nev_tmp = fill_pointer_events(events, pDev, type, buttons, ms, flags,
                                  &mask);
    events += nev_tmp;
    num_events += nev_tmp;

    valuator_mask_zero(&scroll);

    /* Now turn the smooth-scrolling axes back into emulated button presses
     * for legacy clients, based on the integer delta between before and now */
    for (i = 0; i < valuator_mask_size(&mask); i++) {
        if ( !pDev->valuator || (i >= pDev->valuator->numAxes))
            break;

        if (!valuator_mask_isset(&mask, i))
            continue;

        valuator_mask_set_double(&scroll, i, pDev->last.valuators[i]);

        nev_tmp =
            emulate_scroll_button_events(events, pDev, realtype, i, &scroll,
                                         pDev->last.scroll, ms,
                                         GetMaximumEventsNum() - num_events);
        events += nev_tmp;
        num_events += nev_tmp;
    }

    return num_events;
}

/**
 * Generate internal events representing this proximity event and enqueue
 * them on the event queue.
 *
 * This function is not reentrant. Disable signals before calling.
 *
 * @@param device The device to generate the event for
 * @@param type Event type, one of ProximityIn or ProximityOut
 * @@param keycode Key code of the pressed/released key
 * @@param mask Valuator mask for valuators present for this event.
 *
 */
void
QueueProximityEvents(DeviceIntPtr device, int type, const ValuatorMask *mask)
{
    int nevents;

    nevents = GetProximityEvents(InputEventList, device, type, mask);
    queueEventList(device, InputEventList, nevents);
}

/**
 * Generate ProximityIn/ProximityOut InternalEvents, accompanied by
 * valuators.
 *
 * The DDX is responsible for allocating the events in the first place via
 * InitEventList(), and for freeing it.
 *
 * @@return the number of events written into events.
 */
int
GetProximityEvents(InternalEvent *events, DeviceIntPtr pDev, int type,
                   const ValuatorMask *mask_in)
{
    int num_events = 1, i;
    DeviceEvent *event;
    ValuatorMask mask;

#if XSERVER_DTRACE
    if (XSERVER_INPUT_EVENT_ENABLED()) {
        XSERVER_INPUT_EVENT(pDev->id, type, 0, 0,
                            mask_in ? mask_in->last_bit + 1 : 0,
                            mask_in ? mask_in->mask : NULL,
                            mask_in ? mask_in->valuators : NULL);
    }
#endif

    /* refuse events from disabled devices */
    if (!pDev->enabled)
        return 0;

    /* Sanity checks. */
    if ((type != ProximityIn && type != ProximityOut) || !mask_in)
        return 0;
    if (!pDev->valuator || !pDev->proximity)
        return 0;

    valuator_mask_copy(&mask, mask_in);

    /* ignore relative axes for proximity. */
    for (i = 0; i < valuator_mask_size(&mask); i++) {
        if (valuator_mask_isset(&mask, i) &&
            valuator_get_mode(pDev, i) == Relative)
            valuator_mask_unset(&mask, i);
    }

    /* FIXME: posting proximity events with relative valuators only results
     * in an empty event, EventToXI() will fail to convert → no event sent
     * to client. */

    events =
        UpdateFromMaster(events, pDev, DEVCHANGE_POINTER_EVENT, &num_events);

    event = &events->device_event;
    init_device_event(event, pDev, GetTimeInMillis());
    event->type = (type == ProximityIn) ? ET_ProximityIn : ET_ProximityOut;

    clipValuators(pDev, &mask);

    set_valuators(pDev, event, &mask);

    return num_events;
}

int
GetTouchOwnershipEvents(InternalEvent *events, DeviceIntPtr pDev,
                        TouchPointInfoPtr ti, uint8_t reason, XID resource,
                        uint32_t flags)
{
    TouchClassPtr t = pDev->touch;
    TouchOwnershipEvent *event;
    CARD32 ms = GetTimeInMillis();

    if (!pDev->enabled || !t || !ti)
        return 0;

    event = &events->touch_ownership_event;
    init_touch_ownership(pDev, event, ms);

    event->touchid = ti->client_id;
    event->sourceid = ti->sourceid;
    event->resource = resource;
    event->flags = flags;
    event->reason = reason;

    return 1;
}

/**
 * Generate internal events representing this touch event and enqueue them
 * on the event queue.
 *
 * This function is not reentrant. Disable signals before calling.
 *
 * @@param device The device to generate the event for
 * @@param type Event type, one of XI_TouchBegin, XI_TouchUpdate, XI_TouchEnd
 * @@param touchid Touch point ID
 * @@param flags Event modification flags
 * @@param mask Valuator mask for valuators present for this event.
 */
void
QueueTouchEvents(DeviceIntPtr device, int type,
                 uint32_t ddx_touchid, int flags, const ValuatorMask *mask)
{
    int nevents;

    nevents =
        GetTouchEvents(InputEventList, device, ddx_touchid, type, flags, mask);
    queueEventList(device, InputEventList, nevents);
}

/**
 * Get events for a touch. Generates a TouchBegin event if end is not set and
 * the touch id is not active. Generates a TouchUpdate event if end is not set
 * and the touch id is active. Generates a TouchEnd event if end is set and the
 * touch id is active.
 *
 * events is not NULL-terminated; the return value is the number of events.
 * The DDX is responsible for allocating the event structure in the first
 * place via GetMaximumEventsNum(), and for freeing it.
 *
 * @@param[out] events The list of events generated
 * @@param dev The device to generate the events for
 * @@param ddx_touchid The touch ID as assigned by the DDX
 * @@param type XI_TouchBegin, XI_TouchUpdate or XI_TouchEnd
 * @@param flags Event flags
 * @@param mask_in Valuator information for this event
 */
int
GetTouchEvents(InternalEvent *events, DeviceIntPtr dev, uint32_t ddx_touchid,
               uint16_t type, uint32_t flags, const ValuatorMask *mask_in)
{
    ScreenPtr scr = dev->spriteInfo->sprite->hotPhys.pScreen;
    TouchClassPtr t = dev->touch;
    ValuatorClassPtr v = dev->valuator;
    DeviceEvent *event;
    CARD32 ms = GetTimeInMillis();
    ValuatorMask mask;
    double screenx = 0.0, screeny = 0.0;        /* desktop coordinate system */
    double devx = 0.0, devy = 0.0;      /* desktop-wide in device coords */
    int i;
    int num_events = 0;
    RawDeviceEvent *raw;
    DDXTouchPointInfoPtr ti;
    int need_rawevent = TRUE;
    Bool emulate_pointer = FALSE;
    int client_id = 0;

#if XSERVER_DTRACE
    if (XSERVER_INPUT_EVENT_ENABLED()) {
        XSERVER_INPUT_EVENT(dev->id, type, ddx_touchid, flags,
                            mask_in ? mask_in->last_bit + 1 : 0,
                            mask_in ? mask_in->mask : NULL,
                            mask_in ? mask_in->valuators : NULL);
    }
#endif

    if (!dev->enabled || !t || !v)
        return 0;

    /* Find and/or create the DDX touch info */

    ti = TouchFindByDDXID(dev, ddx_touchid, (type == XI_TouchBegin));
    if (!ti) {
        ErrorFSigSafe("[dix] %s: unable to %s touch point %u\n", dev->name,
                      type == XI_TouchBegin ? "begin" : "find", ddx_touchid);
        return 0;
    }
    client_id = ti->client_id;

    emulate_pointer = ti->emulate_pointer;

    if (!IsMaster(dev))
        events =
            UpdateFromMaster(events, dev, DEVCHANGE_POINTER_EVENT, &num_events);

    valuator_mask_copy(&mask, mask_in);

    if (need_rawevent) {
        raw = &events->raw_event;
        events++;
        num_events++;
        init_raw(dev, raw, ms, type, client_id);
        set_raw_valuators(raw, &mask, TRUE, raw->valuators.data_raw);
    }

    event = &events->device_event;
    num_events++;

    init_device_event(event, dev, ms);

    switch (type) {
    case XI_TouchBegin:
        event->type = ET_TouchBegin;
        /* If we're starting a touch, we must have x & y co-ordinates. */
        if (!mask_in ||
            !valuator_mask_isset(mask_in, 0) ||
            !valuator_mask_isset(mask_in, 1)) {
            ErrorFSigSafe("%s: Attempted to start touch without x/y "
                          "(driver bug)\n", dev->name);
            return 0;
        }
        break;
    case XI_TouchUpdate:
        event->type = ET_TouchUpdate;
        if (!mask_in || valuator_mask_num_valuators(mask_in) <= 0) {
            ErrorFSigSafe("%s: TouchUpdate with no valuators? Driver bug\n",
                          dev->name);
        }
        break;
    case XI_TouchEnd:
        event->type = ET_TouchEnd;
        /* We can end the DDX touch here, since we don't use the active
         * field below */
        TouchEndDDXTouch(dev, ti);
        break;
    default:
        return 0;
    }

    /* Get our screen event co-ordinates (root_x/root_y/event_x/event_y):
     * these come from the touchpoint in Absolute mode, or the sprite in
     * Relative. */
    if (t->mode == XIDirectTouch) {
        for (i = 0; i < max(valuator_mask_size(&mask), 2); i++) {
            double val;

            if (valuator_mask_fetch_double(&mask, i, &val))
                valuator_mask_set_double(ti->valuators, i, val);
            /* If the device doesn't post new X and Y axis values,
             * use the last values posted.
             */
            else if (i < 2 &&
                valuator_mask_fetch_double(ti->valuators, i, &val))
                valuator_mask_set_double(&mask, i, val);
        }

        transformAbsolute(dev, &mask);
        clipAbsolute(dev, &mask);
    }
    else {
        screenx = dev->spriteInfo->sprite->hotPhys.x;
        screeny = dev->spriteInfo->sprite->hotPhys.y;
    }
    if (need_rawevent)
        set_raw_valuators(raw, &mask, FALSE, raw->valuators.data);

    /* Indirect device touch coordinates are not used for cursor positioning.
     * They are merely informational, and are provided in device coordinates.
     * The device sprite is used for positioning instead, and it is already
     * scaled. */
    if (t->mode == XIDirectTouch)
        scr = scale_to_desktop(dev, &mask, &devx, &devy, &screenx, &screeny);
    if (emulate_pointer)
        scr = positionSprite(dev, Absolute, &mask,
                             &devx, &devy, &screenx, &screeny, NULL, NULL);

    /* see fill_pointer_events for coordinate systems */
    if (emulate_pointer)
        updateHistory(dev, &mask, ms);

    clipValuators(dev, &mask);

    if (emulate_pointer)
        storeLastValuators(dev, &mask, 0, 1, devx, devy);

    /* Update the MD's co-ordinates, which are always in desktop space. */
    if (emulate_pointer && !IsMaster(dev) && !IsFloating(dev)) {
	    DeviceIntPtr master = GetMaster(dev, MASTER_POINTER);

	    master->last.valuators[0] = screenx;
	    master->last.valuators[1] = screeny;
    }

    event->root = scr->root->drawable.id;

    event_set_root_coordinates(event, screenx - scr->x, screeny - scr->y);
    event->touchid = client_id;
    event->flags = flags;

    if (emulate_pointer) {
        event->flags |= TOUCH_POINTER_EMULATED;
        event->detail.button = 1;
    }

    set_valuators(dev, event, &mask);
    for (i = 0; i < v->numAxes; i++) {
        if (valuator_mask_isset(&mask, i))
            v->axisVal[i] = valuator_mask_get(&mask, i);
    }

    return num_events;
}

void
GetDixTouchEnd(InternalEvent *ievent, DeviceIntPtr dev, TouchPointInfoPtr ti,
               uint32_t flags)
{
    ScreenPtr scr = dev->spriteInfo->sprite->hotPhys.pScreen;
    DeviceEvent *event = &ievent->device_event;
    CARD32 ms = GetTimeInMillis();

    BUG_WARN(!dev->enabled);

    init_device_event(event, dev, ms);

    event->sourceid = ti->sourceid;
    event->type = ET_TouchEnd;

    event->root = scr->root->drawable.id;

    /* Get screen event coordinates from the sprite.  Is this really the best
     * we can do? */
    event_set_root_coordinates(event,
                               dev->last.valuators[0] - scr->x,
                               dev->last.valuators[1] - scr->y);
    event->touchid = ti->client_id;
    event->flags = flags;

    if (flags & TOUCH_POINTER_EMULATED) {
        event->flags |= TOUCH_POINTER_EMULATED;
        event->detail.button = 1;
    }
}

/**
 * Synthesize a single motion event for the core pointer.
 *
 * Used in cursor functions, e.g. when cursor confinement changes, and we need
 * to shift the pointer to get it inside the new bounds.
 */
void
PostSyntheticMotion(DeviceIntPtr pDev,
                    int x, int y, int screen, unsigned long time)
{
    DeviceEvent ev;

#ifdef PANORAMIX
    /* Translate back to the sprite screen since processInputProc
       will translate from sprite screen to screen 0 upon reentry
       to the DIX layer. */
    if (!noPanoramiXExtension) {
        x += screenInfo.screens[0]->x - screenInfo.screens[screen]->x;
        y += screenInfo.screens[0]->y - screenInfo.screens[screen]->y;
    }
#endif

    memset(&ev, 0, sizeof(DeviceEvent));
    init_device_event(&ev, pDev, time);
    ev.root_x = x;
    ev.root_y = y;
    ev.type = ET_Motion;
    ev.time = time;

    /* FIXME: MD/SD considerations? */
    (*pDev->public.processInputProc) ((InternalEvent *) &ev, pDev);
}
@


1.21
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d211 2
a212 1
set_raw_valuators(RawDeviceEvent *event, ValuatorMask *mask, double *data)
d216 2
d220 2
d223 7
a229 1
            data[i] = valuator_mask_get_double(mask, i);
a1062 2
 * FIXME: flags for relative/abs motion?
 *
a1065 1
 * @@param mask Valuator mask for valuators present for this event.
d1070 1
a1070 1
                    int keycode, const ValuatorMask *mask)
d1074 1
a1074 1
    nevents = GetKeyboardEvents(InputEventList, device, type, keycode, mask);
d1089 1
a1089 1
                  int key_code, const ValuatorMask *mask_in)
a1094 1
    ValuatorMask mask;
d1098 2
a1099 4
        XSERVER_INPUT_EVENT(pDev->id, type, key_code, 0,
                            mask_in ? mask_in->last_bit + 1 : 0,
                            mask_in ? mask_in->mask : NULL,
                            mask_in ? mask_in->valuators : NULL);
a1111 5
    if (mask_in && valuator_mask_size(mask_in) > 1) {
        ErrorF("[dix] the server does not handle valuator masks with "
               "keyboard events. This is a bug. You may fix it.\n");
    }

a1132 2
    valuator_mask_copy(&mask, mask_in);

a1133 5
    set_raw_valuators(raw, &mask, raw->valuators.data_raw);

    clipValuators(pDev, &mask);

    set_raw_valuators(raw, &mask, raw->valuators.data);
a1147 12
    clipValuators(pDev, &mask);

    set_valuators(pDev, event, &mask);

    if (!IsFloating(pDev)) {
        DeviceIntPtr master = GetMaster(pDev, MASTER_POINTER);

        event_set_root_coordinates(event,
                                   master->last.valuators[0],
                                   master->last.valuators[1]);
    }

d1402 1
a1402 1
        set_raw_valuators(raw, &mask, raw->valuators.data_raw);
d1405 2
d1419 1
a1419 1
            set_raw_valuators(raw, &mask, raw->valuators.data);
d1427 1
a1427 1
            set_raw_valuators(raw, &mask, raw->valuators.data);
d1543 4
d1936 1
a1936 1
        set_raw_valuators(raw, &mask, raw->valuators.data_raw);
d1998 1
a1998 1
        set_raw_valuators(raw, &mask, raw->valuators.data);
@


1.20
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d71 1
a71 6

#if XSERVER_DTRACE
#include <sys/types.h>
typedef const char *string;
#include <Xserver-dtrace.h>
#endif
@


1.19
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1251 2
a1252 2
    has_x = valuator_mask_fetch_double(mask, 0, &ox);
    has_y = valuator_mask_fetch_double(mask, 1, &oy);
d1266 1
d1268 2
a1269 3
        x = ox;
        y = oy;
    }
d1271 2
a1272 2
    if (valuator_mask_isset(mask, 0))
        ox = x = valuator_mask_get_double(mask, 0);
d1274 2
a1275 2
    if (valuator_mask_isset(mask, 1))
        oy = y = valuator_mask_get_double(mask, 1);
d1279 1
a1279 1
    if (valuator_mask_isset(mask, 0) || ox != x)
d1282 1
a1282 1
    if (valuator_mask_isset(mask, 1) || oy != y)
d2047 1
a2047 1
    event_set_root_coordinates(event, screenx, screeny);
d2085 2
a2086 2
                               dev->last.valuators[0],
                               dev->last.valuators[1]);
@


1.18
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d1385 1
a1385 1
    RawDeviceEvent *raw;
d1388 1
a1388 1
    int sx, sy;                         /* for POINTER_SCREEN */
d1440 1
a1440 1
        if ((flags & POINTER_NORAW) == 0)
d1448 1
a1448 1
        if ((flags & POINTER_NORAW) == 0)
d1515 2
a1516 1
        raw->flags = XIPointerEmulated;
@


1.17
log
@Update to xserver 1.14.3
@
text
@d773 23
d807 1
d811 4
a814 18
    if ((flags & POINTER_ABSOLUTE) == 0 && dev->valuator &&
        dev->valuator->axes[0].min_value < dev->valuator->axes[0].max_value) {

        double ratio = 1.0 * screenInfo.width/screenInfo.height;

        if (ratio > 1.0) {
            double y;
            if (valuator_mask_fetch_double(mask, 1, &y)) {
                y *= ratio;
                valuator_mask_set_double(mask, 1, y);
            }
        } else {
            double x;
            if (valuator_mask_fetch_double(mask, 0, &x)) {
                x *= ratio;
                valuator_mask_set_double(mask, 0, x);
            }
        }
d1656 2
@


1.16
log
@Uodate to xserver 1.14.2. Tested by krw@@, shadchin@@, todd@@
@
text
@d242 1
a242 1
        else if (valuator_get_mode(dev, i) == Absolute)
@


1.15
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d280 1
d301 1
a301 1
        fmax = from->max_value;
d305 1
a305 1
        tmax = to->max_value;
d917 1
a917 1
                                   screenInfo.x, screenInfo.width - 1);
d919 1
a919 1
                                   screenInfo.y, screenInfo.height - 1);
d1359 6
@


1.14
log
@Update to xserver 1.12.3.
@
text
@d72 6
a166 11
init_event(DeviceIntPtr dev, DeviceEvent *event, Time ms)
{
    memset(event, 0, sizeof(DeviceEvent));
    event->header = ET_Internal;
    event->length = sizeof(DeviceEvent);
    event->time = ms;
    event->deviceid = dev->id;
    event->sourceid = dev->id;
}

static void
d779 1
a779 1
moveRelative(DeviceIntPtr dev, ValuatorMask *mask)
d784 22
d845 1
a845 1
 * @@param[in, out] mask The mask in desktop coordinates, modified in place
d847 2
d851 1
a851 1
scale_from_screen(DeviceIntPtr dev, ValuatorMask *mask)
d857 3
a859 1
        scaled = valuator_mask_get_double(mask, 0) + scr->x;
d862 1
a862 1
                                     0, scr->width);
d866 3
a868 1
        scaled = valuator_mask_get_double(mask, 1) + scr->y;
d871 1
a871 1
                                     0, scr->height);
d916 1
a916 1
                                   screenInfo.x, screenInfo.width);
d918 1
a918 1
                                   screenInfo.y, screenInfo.height);
d947 2
d952 2
a953 1
               double *devx, double *devy, double *screenx, double *screeny)
d967 1
a967 1
    scr = miPointerSetPosition(dev, mode, screenx, screeny);
d1083 9
d1205 21
d1253 1
a1253 1
        pixman_f_transform_invert(&invert, &dev->transform);
d1266 1
a1266 1
    transform(&dev->transform, &x, &y);
d1371 1
d1374 1
d1415 5
a1419 2
        if (flags & POINTER_SCREEN)     /* valuators are in screen coords */
            scale_from_screen(pDev, &mask);
d1427 2
d1434 1
a1434 1
        moveRelative(pDev, &mask);
d1439 13
d1453 4
a1456 1
                         &mask, &devx, &devy, &screenx, &screeny);
d1631 9
d1692 2
d1769 9
d1894 1
a1894 4
    union touch {
        TouchPointInfoPtr dix_ti;
        DDXTouchPointInfoPtr ti;
    } touchpoint;
d1899 9
d1913 5
a1917 17
    if (flags & TOUCH_CLIENT_ID) {      /* A DIX-submitted TouchEnd */
        touchpoint.dix_ti = TouchFindByClientID(dev, ddx_touchid);
        BUG_WARN(!touchpoint.dix_ti);

        if (!touchpoint.dix_ti)
            return 0;

        if (!mask_in ||
            !valuator_mask_isset(mask_in, 0) ||
            !valuator_mask_isset(mask_in, 1)) {
            ErrorF
                ("[dix] dix-submitted events must have x/y valuator information.\n");
            return 0;
        }

        need_rawevent = FALSE;
        client_id = touchpoint.dix_ti->client_id;
d1919 1
a1919 1
    else {                      /* a DDX-submitted touch */
d1921 1
a1921 14
        touchpoint.ti =
            TouchFindByDDXID(dev, ddx_touchid, (type == XI_TouchBegin));
        if (!touchpoint.ti) {
            ErrorF("[dix] %s: unable to %s touch point %x\n", dev->name,
                   type == XI_TouchBegin ? "begin" : "find", ddx_touchid);
            return 0;
        }
        client_id = touchpoint.ti->client_id;
    }

    if (!(flags & TOUCH_CLIENT_ID))
        emulate_pointer = touchpoint.ti->emulate_pointer;
    else
        emulate_pointer = ! !(flags & TOUCH_POINTER_EMULATED);
d1940 1
a1940 6
    init_event(dev, event, ms);
    /* if submitted for master device, get the sourceid from there */
    if (flags & TOUCH_CLIENT_ID) {
        event->sourceid = touchpoint.dix_ti->sourceid;
        /* TOUCH_CLIENT_ID implies norawevent */
    }
d1949 2
a1950 2
            ErrorF("%s: Attempted to start touch without x/y (driver bug)\n",
                   dev->name);
d1957 2
a1958 2
            ErrorF("%s: TouchUpdate with no valuators? Driver bug\n",
                   dev->name);
d1965 1
a1965 2
        if (!(flags & TOUCH_CLIENT_ID))
            TouchEndDDXTouch(dev, touchpoint.ti);
a1969 10
    if (t->mode == XIDirectTouch && !(flags & TOUCH_CLIENT_ID)) {
        if (!valuator_mask_isset(&mask, 0))
            valuator_mask_set_double(&mask, 0,
                                     valuator_mask_get_double(touchpoint.ti->
                                                              valuators, 0));
        if (!valuator_mask_isset(&mask, 1))
            valuator_mask_set_double(&mask, 1,
                                     valuator_mask_get_double(touchpoint.ti->
                                                              valuators, 1));
    }
d1975 2
a1976 1
        transformAbsolute(dev, &mask);
d1978 8
a1985 7
        if (!(flags & TOUCH_CLIENT_ID)) {
            for (i = 0; i < valuator_mask_size(&mask); i++) {
                double val;

                if (valuator_mask_fetch_double(&mask, i, &val))
                    valuator_mask_set_double(touchpoint.ti->valuators, i, val);
            }
d1988 1
d2006 1
a2006 1
                             &devx, &devy, &screenx, &screeny);
d2017 8
d2043 31
@


1.13
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d38 1
d754 23
d795 3
a797 1
        val += valuator_mask_get_double(mask, i);
d801 2
a802 1
            ((i != 0 && i != 1) || clip_xy))
d804 2
a805 1
        valuator_mask_set_double(mask, i, val);
d1182 21
a1205 2
    else
        ox = x = dev->last.valuators[0];
a1208 2
    else
        oy = y = dev->last.valuators[1];
d1522 1
d1568 1
a1568 1
        double val, adj;
d1604 1
a1604 2
            val = valuator_mask_get_double(&mask, axis) + adj;
            valuator_mask_set_double(&mask, axis, val);
d1622 1
a1622 1
        if (i >= pDev->valuator->numAxes)
@


1.12
log
@Bugfix Update to xserver 1.11.3
@
text
@d5 1
d52 1
d63 1
d69 1
a69 1
#include "listdev.h" /* for sizing up DeviceClassesChangedEvent */
d79 1
a79 1
InternalEvent* InputEventList = NULL;
d155 2
a156 2
    return !!(pDev->kbdfeed->ctrl.autoRepeats[key_code >> 3] &
              (1 << (key_code & 7)));
d160 1
a160 1
init_event(DeviceIntPtr dev, DeviceEvent* event, Time ms)
d171 11
d187 26
a212 1
    event->type = ET_RawKeyPress - ET_KeyPress + type;
d220 1
a220 1
set_raw_valuators(RawDeviceEvent *event, ValuatorMask *mask, int32_t* data)
d224 2
a225 4
    for (i = 0; i < valuator_mask_size(mask); i++)
    {
        if (valuator_mask_isset(mask, i))
        {
d227 1
a227 1
            data[i] = valuator_mask_get(mask, i);
a231 1

d233 1
a233 1
set_valuators(DeviceIntPtr dev, DeviceEvent* event, ValuatorMask *mask)
d239 2
a240 4
    for (i = 0; i < valuator_mask_size(mask); i++)
    {
        if (valuator_mask_isset(mask, i))
        {
d244 1
a244 3
            event->valuators.data[i] = valuator_mask_get(mask, i);
            event->valuators.data_frac[i] =
                dev->last.remainder[i] * (1 << 16) * (1 << 16);
d252 2
a253 4
CreateClassesChangedEvent(InternalEvent* event,
                          DeviceIntPtr master,
                          DeviceIntPtr slave,
                          int type)
d262 1
a262 1
    dce->masterid = master->id;
d267 1
a267 2
    dce->flags = type;
    dce->flags |= DEVCHANGE_SLAVE_SWITCH;
d270 1
a270 2
    if (slave->button)
    {
d275 1
a275 2
    if (slave->valuator)
    {
d277 1
a277 2
        for (i = 0; i < dce->num_valuators; i++)
        {
d283 1
d286 1
a286 2
    if (slave->key)
    {
d295 3
a297 3
static int
rescaleValuatorAxis(int coord, float remainder, float *remainder_return, AxisInfoPtr from, AxisInfoPtr to,
                    int defmax)
d299 2
a300 2
    int fmin = 0, tmin = 0, fmax = defmax, tmax = defmax, coord_return;
    float value;
d302 1
a302 1
    if(from && from->min_value < from->max_value) {
d306 1
a306 1
    if(to && to->min_value < to->max_value) {
d311 1
a311 3
    if(fmin == tmin && fmax == tmax) {
        if (remainder_return)
            *remainder_return = remainder;
a312 1
    }
d314 2
a315 5
    if(fmax == fmin) { /* avoid division by 0 */
        if (remainder_return)
            *remainder_return = 0.0;
        return 0;
    }
d317 1
a317 5
    value = (coord + remainder - fmin) * (tmax - tmin) / (fmax - fmin) + tmin;
    coord_return = lroundf(value);
    if (remainder_return)
        *remainder_return = value - coord_return;
    return coord_return;
a330 1
    ScreenPtr scr = miPointerGetScreen(pDev);
d334 1
a334 1
    /* master->last.valuators[0]/[1] is in screen coords and the actual
a337 2
    pDev->last.remainder[0] = master->last.remainder[0];
    pDev->last.remainder[1] = master->last.remainder[1];
d343 14
a356 6
    if(pDev->valuator->numAxes > 0)
        pDev->last.valuators[0] = rescaleValuatorAxis(pDev->last.valuators[0], pDev->last.remainder[0],
                        &pDev->last.remainder[0], NULL, pDev->valuator->axes + 0, scr->width);
    if(pDev->valuator->numAxes > 1)
        pDev->last.valuators[1] = rescaleValuatorAxis(pDev->last.valuators[1], pDev->last.remainder[1],
                        &pDev->last.remainder[1], NULL, pDev->valuator->axes + 1, scr->height);
d364 1
a364 2
            if (i >= lastSlave->valuator->numAxes)
            {
d366 1
a366 1
                pDev->last.remainder[i] = 0;
d368 7
a374 8
            else
            {
                pDev->last.valuators[i] =
                    rescaleValuatorAxis(pDev->last.valuators[i],
                            pDev->last.remainder[i],
                            &pDev->last.remainder[i],
                            lastSlave->valuator->axes + i,
                            pDev->valuator->axes + i, 0);
d388 1
d403 1
d418 1
a418 1
                pDev->name, size * pDev->valuator->numMotionEvents);
d429 1
a429 1
GetMotionHistory(DeviceIntPtr pDev, xTimecoord **buff, unsigned long start,
d436 1
d439 2
a440 3
    int dflt;
    AxisInfo from, *to; /* for scaling */
    INT32 *ocbuf, *icbuf; /* pointer to coordinates for copying */
d442 1
a442 1
    AxisInfo core_axis = {0};
d458 1
a458 1
    obuff = (char *)*buff;
d473 2
a474 3
            if (core)
            {
                memcpy(obuff, ibuff, sizeof(Time)); /* copy timestamp */
d476 2
a477 2
                icbuf = (INT32*)(ibuff + sizeof(Time));
                corebuf = (INT16*)(obuff + sizeof(Time));
d487 2
a488 1
                coord = rescaleValuatorAxis(coord, 0.0, NULL, &from, to, pScreen->width);
d499 2
a500 1
                coord = rescaleValuatorAxis(coord, 0.0, NULL, &from, to, pScreen->height);
d503 7
a509 8
            } else if (IsMaster(pDev))
            {
                memcpy(obuff, ibuff, sizeof(Time)); /* copy timestamp */

                ocbuf = (INT32*)(obuff + sizeof(Time));
                icbuf = (INT32*)(ibuff + sizeof(Time));
                for (j = 0; j < MAX_VALUATORS; j++)
                {
d518 3
a520 1
                    to = (j < pDev->valuator->numAxes) ? &pDev->valuator->axes[j] : NULL;
a527 7
                    if (j == 0 && (to->max_value < to->min_value))
                        dflt = pScreen->width;
                    else if (j == 1 && (to->max_value < to->min_value))
                        dflt = pScreen->height;
                    else
                        dflt = 0;

d529 1
a529 1
                    coord = rescaleValuatorAxis(coord, 0.0, NULL, &from, to, 0);
d533 2
a534 1
            } else
d542 2
a543 1
                obuff += (sizeof(INT32) * pDev->valuator->numAxes) + sizeof(Time);
a550 1

d564 1
a564 1
                    int *valuators)
d574 1
a574 2
    if (IsMaster(pDev))
    {
d576 1
a576 1
                v->last_motion;
d583 3
a585 2
        for (i = 0; i < v->numAxes; i++)
        {
d589 1
a589 2
            if (valuator_mask_size(mask) <= i || !valuator_mask_isset(mask, i))
            {
d597 2
a598 1
            memcpy(buff, &valuators[i], sizeof(INT32));
d601 2
a602 2
    } else
    {
d612 4
a615 4
        for (i = 0; i < MAX_VALUATORS; i++)
        {
            if (valuator_mask_size(mask) <= i || !valuator_mask_isset(mask, i))
            {
d619 2
a620 1
            memcpy(buff, &valuators[i], sizeof(INT32));
d630 1
a630 1
                                       pDev->valuator->numMotionEvents;
a634 1

d642 2
a643 1
GetMaximumEventsNum(void) {
d647 2
d650 1
a650 1
    return 3;
a652 1

d658 1
a658 1
clipAxis(DeviceIntPtr pDev, int axisNum, int *val)
d686 3
a688 3
        if (valuator_mask_isset(mask, i))
        {
            int val = valuator_mask_get(mask, i);
d690 1
a690 1
            valuator_mask_set(mask, i, val);
d706 3
a708 2
InternalEvent*
UpdateFromMaster(InternalEvent* events, DeviceIntPtr dev, int type, int *num_events)
d712 9
a720 7
    master = GetMaster(dev, (type & DEVCHANGE_POINTER_EVENT) ?  MASTER_POINTER : MASTER_KEYBOARD);

    if (master && master->last.slave != dev)
    {
        CreateClassesChangedEvent(events, master, dev, type);
        if (IsPointerDevice(master))
        {
d734 2
a735 6
 * @@param dev The device which's pointer is to be moved.
 * @@param x Returns the x position of the pointer after the move.
 * @@param y Returns the y position of the pointer after the move.
 * @@param mask Bit mask of valid valuators.
 * @@param valuators Valuator data for each axis between @@first and
 *        @@first+@@num.
d738 1
a738 1
moveAbsolute(DeviceIntPtr dev, int *x, int *y, ValuatorMask *mask)
d742 2
a743 9
    if (valuator_mask_isset(mask, 0))
        *x = valuator_mask_get(mask, 0);
    else
        *x = dev->last.valuators[0];

    if (valuator_mask_isset(mask, 1))
        *y = valuator_mask_get(mask, 1);
    else
        *y = dev->last.valuators[1];
d745 5
a749 10
    clipAxis(dev, 0, x);
    clipAxis(dev, 1, y);

    for (i = 2; i < valuator_mask_size(mask); i++)
    {
        if (valuator_mask_isset(mask, i))
        {
            dev->last.valuators[i] = valuator_mask_get(mask, i);
            clipAxis(dev, i, &dev->last.valuators[i]);
        }
d756 2
a757 6
 * @@param dev The device which's pointer is to be moved.
 * @@param x Returns the x position of the pointer after the move.
 * @@param y Returns the y position of the pointer after the move.
 * @@param mask Bit mask of valid valuators.
 * @@param valuators Valuator data for each axis between @@first and
 *        @@first+@@num.
d760 1
a760 1
moveRelative(DeviceIntPtr dev, int *x, int *y, ValuatorMask *mask)
d763 1
d765 3
a767 2
    *x = dev->last.valuators[0];
    *y = dev->last.valuators[1];
d769 9
a777 26
    if (valuator_mask_isset(mask, 0))
        *x += valuator_mask_get(mask, 0);

    if (valuator_mask_isset(mask, 1))
        *y += valuator_mask_get(mask, 1);

    /* if attached, clip both x and y to the defined limits (usually
     * co-ord space limit). If it is attached, we need x/y to go over the
     * limits to be able to change screens. */
    if (dev->valuator && (IsMaster(dev) || !IsFloating(dev))) {
        if (valuator_get_mode(dev, 0) == Absolute)
            clipAxis(dev, 0, x);
        if (valuator_get_mode(dev, 1) == Absolute)
            clipAxis(dev, 1, y);
    }

    /* calc other axes, clip, drop back into valuators */
    for (i = 2; i < valuator_mask_size(mask); i++)
    {
        if (valuator_mask_isset(mask, i))
        {
            dev->last.valuators[i] += valuator_mask_get(mask, i);
            if (valuator_get_mode(dev, i) == Absolute)
                clipAxis(dev, i, &dev->last.valuators[i]);
            valuator_mask_set(mask, i, dev->last.valuators[i]);
        }
d789 1
a789 1
accelPointer(DeviceIntPtr dev, ValuatorMask* valuators, CARD32 ms)
d796 2
a797 6
 * If we have HW cursors, this actually moves the visible sprite. If not, we
 * just do all the screen crossing, etc.
 *
 * We scale from device to screen coordinates here, call
 * miPointerSetPosition() and then scale back into device coordinates (if
 * needed). miPSP will change x/y if the screen was crossed.
d799 3
a801 14
 * The coordinates provided are always absolute. The parameter mode whether
 * it was relative or absolute movement that landed us at those coordinates.
 *
 * @@param dev The device to be moved.
 * @@param mode Movement mode (Absolute or Relative)
 * @@param x Pointer to current x-axis value, may be modified.
 * @@param y Pointer to current y-axis value, may be modified.
 * @@param x_frac Fractional part of current x-axis value, may be modified.
 * @@param y_frac Fractional part of current y-axis value, may be modified.
 * @@param scr Screen the device's sprite is currently on.
 * @@param screenx Screen x coordinate the sprite is on after the update.
 * @@param screeny Screen y coordinate the sprite is on after the update.
 * @@param screenx_frac Fractional part of screen x coordinate, as above.
 * @@param screeny_frac Fractional part of screen y coordinate, as above.
d804 1
a804 3
positionSprite(DeviceIntPtr dev, int mode,
               int *x, int *y, float x_frac, float y_frac,
               ScreenPtr scr, int *screenx, int *screeny, float *screenx_frac, float *screeny_frac)
d806 2
a807 1
    int old_screenx, old_screeny;
d809 13
a821 7
    /* scale x&y to screen */
    if (dev->valuator && dev->valuator->numAxes > 0) {
        *screenx = rescaleValuatorAxis(*x, x_frac, screenx_frac,
                dev->valuator->axes + 0, NULL, scr->width);
    } else {
        *screenx = dev->last.valuators[0];
        *screenx_frac = dev->last.remainder[0];
d823 1
d825 27
a851 6
    if (dev->valuator && dev->valuator->numAxes > 1) {
        *screeny = rescaleValuatorAxis(*y, y_frac, screeny_frac,
                dev->valuator->axes + 1, NULL, scr->height);
    } else {
        *screeny = dev->last.valuators[1];
        *screeny_frac = dev->last.remainder[1];
d854 72
a925 11
    /* Hit the left screen edge? */
    if (*screenx <= 0 && *screenx_frac < 0.0f)
    {
        *screenx_frac = 0.0f;
        x_frac = 0.0f;
    }
    if (*screeny <= 0 && *screeny_frac < 0.0f)
    {
        *screeny_frac = 0.0f;
        y_frac = 0.0f;
    }
d927 3
d931 6
a936 5
    old_screenx = *screenx;
    old_screeny = *screeny;
    /* This takes care of crossing screens for us, as well as clipping
     * to the current screen. */
    miPointerSetPosition(dev, mode, screenx, screeny);
d938 3
a940 23
    if(!IsMaster(dev) && !IsFloating(dev)) {
        DeviceIntPtr master = GetMaster(dev, MASTER_POINTER);
        master->last.valuators[0] = *screenx;
        master->last.valuators[1] = *screeny;
        master->last.remainder[0] = *screenx_frac;
        master->last.remainder[1] = *screeny_frac;
    }

    if (dev->valuator)
    {
        /* Crossed screen? Scale back to device coordiantes */
        if(*screenx != old_screenx)
        {
            scr = miPointerGetScreen(dev);
            *x = rescaleValuatorAxis(*screenx, *screenx_frac, &x_frac, NULL,
                                    dev->valuator->axes + 0, scr->width);
        }
        if(*screeny != old_screeny)
        {
            scr = miPointerGetScreen(dev);
            *y = rescaleValuatorAxis(*screeny, *screeny_frac, &y_frac, NULL,
                                     dev->valuator->axes + 1, scr->height);
        }
d943 1
a943 5
    /* dropy x/y (device coordinates) back into valuators for next event */
    dev->last.valuators[0] = *x;
    dev->last.valuators[1] = *y;
    dev->last.remainder[0] = x_frac;
    dev->last.remainder[1] = y_frac;
d961 1
a961 2
    if(!IsMaster(dev) && !IsFloating(dev))
    {
d963 1
d972 1
d977 9
d1021 2
a1022 1
                  int key_code, const ValuatorMask *mask_in) {
d1033 3
a1035 3
    if (!events ||!pDev->key || !pDev->focus || !pDev->kbdfeed ||
       (type != KeyPress && type != KeyRelease) ||
       (key_code < 8 || key_code > 255))
d1038 5
d1045 2
a1046 1
    events = UpdateFromMaster(events, pDev, DEVCHANGE_KEYBOARD_EVENT, &num_events);
d1074 1
a1074 1
    init_event(pDev, event, ms);
d1079 1
a1079 1
	set_key_down(pDev, key_code, KEY_POSTED);
d1083 1
a1083 1
	set_key_up(pDev, key_code, KEY_POSTED);
d1090 8
d1108 1
a1108 1
InternalEvent*
d1112 1
d1133 1
a1133 1
transform(struct pixman_f_transform *m, int *x, int *y)
d1135 1
a1135 1
    struct pixman_f_vector p = {.v = {*x, *y, 1}};
d1138 2
a1139 2
    *x = lround(p.v[0]);
    *y = lround(p.v[1]);
d1142 8
d1153 1
a1153 1
    int x, y, ox, oy;
d1155 9
a1163 4
    ox = x = valuator_mask_isset(mask, 0) ? valuator_mask_get(mask, 0) :
                                            dev->last.valuators[0];
    oy = y = valuator_mask_isset(mask, 1) ? valuator_mask_get(mask, 1) :
                                            dev->last.valuators[1];
d1168 1
a1168 1
        valuator_mask_set(mask, 0, x);
d1171 23
a1193 1
        valuator_mask_set(mask, 1, y);
d1215 2
a1216 1
    nevents = GetPointerEvents(InputEventList, device, type, buttons, flags, mask);
d1221 2
a1222 2
 * Generate a series of InternalEvents representing pointer motion, or
 * button presses.
d1224 1
a1224 2
 * The DDX is responsible for allocating the events in the first
 * place via InitEventList() and GetMaximumEventsNum(), and for freeing it.
d1226 31
a1256 7
 * In the generated events rootX/Y will be in absolute screen coords and
 * the valuator information in the absolute or relative device coords.
 *
 * last.valuators[x] of the device is always in absolute device coords.
 * last.valuators[x] of the master device is in absolute screen coords.
 *
 * master->last.valuators[x] for x > 2 is undefined.
d1260 5
a1264 3
int
GetPointerEvents(InternalEvent *events, DeviceIntPtr pDev, int type, int buttons,
                 int flags, const ValuatorMask *mask_in) {
a1265 1
    CARD32 ms;
d1267 3
a1269 5
    RawDeviceEvent    *raw;
    int x = 0, y = 0, /* device coords */
        cx, cy; /* only screen coordinates */
    float x_frac = 0.0, y_frac = 0.0, cx_frac, cy_frac;
    ScreenPtr scr = miPointerGetScreen(pDev);
d1271 1
d1273 22
a1294 2
    /* refuse events from disabled devices */
    if (!pDev->enabled)
d1296 1
d1298 6
a1303 2
    if (!scr)
        return 0;
d1305 2
a1306 13
    switch (type)
    {
        case MotionNotify:
            if (!mask_in || valuator_mask_num_valuators(mask_in) <= 0)
                return 0;
            break;
        case ButtonPress:
        case ButtonRelease:
            if (!pDev->button || !buttons)
                return 0;
            break;
        default:
            return 0;
d1309 1
a1309 5
    ms = GetTimeInMillis(); /* before pointer update to help precision */

    events = UpdateFromMaster(events, pDev, DEVCHANGE_POINTER_EVENT, &num_events);

    valuator_mask_copy(&mask, mask_in);
d1311 3
a1313 33
    if ((flags & POINTER_NORAW) == 0)
    {
	raw = &events->raw_event;
	events++;
	num_events++;

	init_raw(pDev, raw, ms, type, buttons);
	set_raw_valuators(raw, &mask, raw->valuators.data_raw);
    }

    if (flags & POINTER_ABSOLUTE)
    {
        if (flags & POINTER_SCREEN) /* valuators are in screen coords */
        {
            int scaled;

            if (valuator_mask_isset(&mask, 0))
            {
                scaled = rescaleValuatorAxis(valuator_mask_get(&mask, 0),
                                             0.0, &x_frac, NULL,
                                             pDev->valuator->axes + 0,
                                             scr->width);
                valuator_mask_set(&mask, 0, scaled);
            }
            if (valuator_mask_isset(&mask, 1))
            {
                scaled = rescaleValuatorAxis(valuator_mask_get(&mask, 1),
                                             0.0, &y_frac, NULL,
                                             pDev->valuator->axes + 1,
                                             scr->height);
                valuator_mask_set(&mask, 1, scaled);
            }
        }
d1316 6
a1321 3
        moveAbsolute(pDev, &x, &y, &mask);
    } else {
        if (flags & POINTER_ACCELERATE) {
d1323 4
a1326 6
            /* The pointer acceleration code modifies the fractional part
             * in-place, so we need to extract this information first */
            x_frac = pDev->last.remainder[0];
            y_frac = pDev->last.remainder[1];
        }
        moveRelative(pDev, &x, &y, &mask);
d1329 4
a1332 2
    if ((flags & POINTER_NORAW) == 0)
	set_raw_valuators(raw, &mask, raw->valuators.data);
d1334 3
a1336 2
    positionSprite(pDev, (flags & POINTER_ABSOLUTE) ? Absolute : Relative,
                   &x, &y, x_frac, y_frac, scr, &cx, &cy, &cx_frac, &cy_frac);
d1339 7
a1345 5
    /* Update the valuators with the true value sent to the client*/
    if (valuator_mask_isset(&mask, 0))
        valuator_mask_set(&mask, 0, x);
    if (valuator_mask_isset(&mask, 1))
        valuator_mask_set(&mask, 1, y);
d1347 3
a1349 1
    clipValuators(pDev, &mask);
d1352 1
a1352 1
    init_event(pDev, event, ms);
d1370 7
a1376 4
    event->root_x = cx; /* root_x/y always in screen coords */
    event->root_y = cy;
    event->root_x_frac = cx_frac;
    event->root_y_frac = cy_frac;
d1384 213
d1609 1
a1609 2
QueueProximityEvents(DeviceIntPtr device, int type,
                     const ValuatorMask *mask)
d1627 2
a1628 1
GetProximityEvents(InternalEvent *events, DeviceIntPtr pDev, int type, const ValuatorMask *mask_in)
d1647 1
a1647 2
    for (i = 0; i < valuator_mask_size(&mask); i++)
    {
d1657 2
a1658 1
    events = UpdateFromMaster(events, pDev, DEVCHANGE_POINTER_EVENT, &num_events);
d1661 1
a1661 1
    init_event(pDev, event, GetTimeInMillis());
d1671 254
d1933 1
a1933 4
                    int x,
                    int y,
                    int screen,
                    unsigned long time)
d1948 1
a1948 1
    init_event(pDev, &ev, time);
d1955 1
a1955 1
    (*pDev->public.processInputProc)((InternalEvent*)&ev, pDev);
@


1.11
log
@Update to xserver 1.11.2
@
text
@d1312 1
a1312 1
    if (!pDev->valuator)
@


1.10
log
@Fix transformation of events supplying only a valuator for the y-coordinate.

ok matthieu@@
@
text
@d49 2
a64 1
#include "exglobals.h"
d71 4
a74 3
/* InputEventList is the container list for all input events generated by the
 * DDX. The DDX is expected to call GetEventList() and then pass the list into
 * Get{Pointer|Keyboard}Events.
d76 1
a76 9
EventListPtr InputEventList = NULL;
int InputEventListLen = 0;

int
GetEventList(EventListPtr* list)
{
    *list = InputEventList;
    return InputEventListLen;
}
d181 1
a181 1
set_raw_valuators(RawDeviceEvent *event, int first, int num, int *valuators, int32_t* data)
a183 2
    for (i = first; i < first + num; i++)
        SetBit(event->valuators.mask, i);
d185 8
a192 1
    memcpy(&data[first], valuators, num * sizeof(uint32_t));
d197 1
a197 2
set_valuators(DeviceIntPtr dev, DeviceEvent* event, int first_valuator,
              int num_valuators, int *valuators)
d201 3
a203 1
    for (i = first_valuator; i < first_valuator + num_valuators; i++)
d205 11
a215 5
        SetBit(event->valuators.mask, i);
        if (dev->valuator->mode == Absolute)
            SetBit(event->valuators.mode, i);
        event->valuators.data_frac[i] =
            dev->last.remainder[i] * (1 << 16) * (1 << 16);
a216 4

    memcpy(&event->valuators.data[first_valuator],
           valuators, num_valuators * sizeof(int32_t));

d220 1
a220 1
CreateClassesChangedEvent(EventList* event,
d229 1
a229 1
    dce = (DeviceChangedEvent*)event->event;
d255 1
a255 2
            /* This should, eventually, be a per-axis mode */
            dce->valuators[i].mode = slave->valuator->mode;
d323 2
d344 1
d346 2
d349 1
d356 1
d380 9
a388 2
    else
        size = sizeof(INT32) * pDev->valuator->numAxes;
d542 1
a542 1
 * For events that have some valuators unset (first_valuator > 0):
d546 2
a547 2
updateMotionHistory(DeviceIntPtr pDev, CARD32 ms, int first_valuator,
                    int num_valuators, int *valuators)
a565 1
        buff += 3 * sizeof(INT32) * first_valuator;
d567 1
a567 1
        for (i = first_valuator; i < first_valuator + num_valuators; i++)
d569 2
a570 1
            if (i >= v->numAxes)
d572 5
d581 1
a581 1
            memcpy(buff, &valuators[i - first_valuator], sizeof(INT32));
a593 1
        buff += sizeof(INT32) * first_valuator;
d595 10
a604 1
        memcpy(buff, valuators, sizeof(INT32) * num_valuators);
d619 2
a620 2
 * Returns the maximum number of events GetKeyboardEvents,
 * GetKeyboardValuatorEvents, and GetPointerEvents will ever return.
d662 1
a662 2
clipValuators(DeviceIntPtr pDev, int first_valuator, int num_valuators,
              int *valuators)
d666 7
a672 2
    for (i = 0; i < num_valuators; i++)
        clipAxis(pDev, i + first_valuator, &(valuators[i]));
d680 1
a680 1
 * @@param events Pointer to a pre-allocated event list.
d687 2
a688 2
EventListPtr
UpdateFromMaster(EventListPtr events, DeviceIntPtr dev, int type, int *num_events)
d715 1
a715 2
 * @@param first The first valuator in @@valuators
 * @@param num Total number of valuators in @@valuators.
d720 1
a720 2
moveAbsolute(DeviceIntPtr dev, int *x, int *y,
             int first, int num, int *valuators)
d724 2
a725 3

    if (num >= 1 && first == 0)
        *x = *(valuators + 0);
d729 2
a730 2
    if (first <= 1 && num >= (2 - first))
        *y = *(valuators + 1 - first);
d737 1
a737 2
    i = (first > 2) ? 0 : 2;
    for (; i < num; i++)
d739 5
a743 2
        dev->last.valuators[i + first] = valuators[i];
        clipAxis(dev, i, &dev->last.valuators[i + first]);
d753 1
a753 2
 * @@param first The first valuator in @@valuators
 * @@param num Total number of valuators in @@valuators.
d758 1
a758 2
moveRelative(DeviceIntPtr dev, int *x, int *y,
             int first, int num, int *valuators)
d765 2
a766 2
    if (num >= 1 && first == 0)
        *x += *(valuators +0);
d768 2
a769 2
    if (first <= 1 && num >= (2 - first))
        *y += *(valuators + 1 - first);
d774 5
a778 3
    if(dev->u.master && dev->valuator->mode == Absolute) {
        clipAxis(dev, 0, x);
        clipAxis(dev, 1, y);
d782 1
a782 2
    i = (first > 2) ? 0 : 2;
    for (; i < num; i++)
d784 7
a790 4
        dev->last.valuators[i + first] += valuators[i];
        if (dev->valuator->mode == Absolute)
            clipAxis(dev, i, &dev->last.valuators[i + first]);
        valuators[i] = dev->last.valuators[i + first];
d798 1
a798 4
 * @@param first The first valuator in @@valuators
 * @@param num Total number of valuators in @@valuators.
 * @@param valuators Valuator data for each axis between @@first and
 *        @@first+@@num.
d802 1
a802 1
accelPointer(DeviceIntPtr dev, int first, int num, int *valuators, CARD32 ms)
d805 1
a805 1
        dev->valuator->accelScheme.AccelSchemeProc(dev, first, num, valuators, ms);
d816 3
d820 1
d832 2
a833 1
positionSprite(DeviceIntPtr dev, int *x, int *y, float x_frac, float y_frac,
d839 1
a839 1
    if (dev->valuator->numAxes > 0) {
d847 1
a847 1
    if (dev->valuator->numAxes > 1) {
d872 1
a872 1
    miPointerSetPosition(dev, screenx, screeny);
d874 6
a879 5
    if (dev->u.master) {
        dev->u.master->last.valuators[0] = *screenx;
        dev->u.master->last.valuators[1] = *screeny;
        dev->u.master->last.remainder[0] = *screenx_frac;
        dev->u.master->last.remainder[1] = *screeny_frac;
d882 1
a882 2
    /* Crossed screen? Scale back to device coordiantes */
    if(*screenx != old_screenx)
d884 13
a896 9
        scr = miPointerGetScreen(dev);
        *x = rescaleValuatorAxis(*screenx, *screenx_frac, &x_frac, NULL,
                                dev->valuator->axes + 0, scr->width);
    }
    if(*screeny != old_screeny)
    {
        scr = miPointerGetScreen(dev);
        *y = rescaleValuatorAxis(*screeny, *screeny_frac, &y_frac, NULL,
                                 dev->valuator->axes + 1, scr->height);
d910 1
a910 1
 * @@param first First valuator to append to history.
d915 1
a915 1
updateHistory(DeviceIntPtr dev, int first, int num, CARD32 ms)
d917 5
a921 2
    updateMotionHistory(dev, ms, first, num, &dev->last.valuators[first]);
    if (dev->u.master)
d924 1
a924 1
        updateMotionHistory(master, ms, first, num, &dev->last.valuators[first]);
d928 8
d937 12
a948 2
 * Convenience wrapper around GetKeyboardValuatorEvents, that takes no
 * valuators.
d950 8
a957 3
int
GetKeyboardEvents(EventList *events, DeviceIntPtr pDev, int type, int key_code) {
    return GetKeyboardValuatorEvents(events, pDev, type, key_code, 0, 0, NULL);
a959 1

d961 2
a962 5
 * Returns a set of keyboard events for KeyPress/KeyRelease, optionally
 * also with valuator events.  Handles Xi and XKB.
 *
 * DOES NOT GENERATE CORE EVENTS! Core events are created when processing the
 * event (ProcessOtherEvent).
d964 2
a965 3
 * events is not NULL-terminated; the return value is the number of events.
 * The DDX is responsible for allocating the event structure in the first
 * place via GetMaximumEventsNum(), and for freeing it.
d967 1
a967 4
 * This function does not change the core keymap to that of the device;
 * that is done by SwitchCoreKeyboard, which is called from
 * mieqProcessInputEvents.  If replacing that function, take care to call
 * SetCoreKeyboard before processInputProc, so keymaps are altered to suit.
d970 2
a971 3
GetKeyboardValuatorEvents(EventList *events, DeviceIntPtr pDev, int type,
                          int key_code, int first_valuator,
                          int num_valuators, int *valuators_in) {
d976 1
a976 1
    int valuators[MAX_VALUATORS];
a982 1
        num_valuators > MAX_VALUATORS ||
d1003 1
a1003 1
    raw = (RawDeviceEvent*)events->event;
d1007 1
a1007 1
    memcpy(valuators, valuators_in, num_valuators * sizeof(int));
d1010 1
a1010 2
    set_raw_valuators(raw, first_valuator, num_valuators, valuators,
                      raw->valuators.data_raw);
d1012 1
a1012 2
    if (num_valuators)
        clipValuators(pDev, first_valuator, num_valuators, valuators);
d1014 1
a1014 2
    set_raw_valuators(raw, first_valuator, num_valuators, valuators,
                      raw->valuators.data);
d1016 1
a1016 1
    event = (DeviceEvent*) events->event;
d1029 1
a1029 2
    if (num_valuators)
        clipValuators(pDev, first_valuator, num_valuators, valuators);
d1031 1
a1031 1
    set_valuators(pDev, event, first_valuator, num_valuators, valuators);
d1037 1
a1037 1
 * Initialize an event list and fill with 32 byte sized events.
d1043 1
a1043 1
EventListPtr
d1046 1
a1046 22
    EventListPtr events;
    int i;

    events = (EventListPtr)calloc(num_events, sizeof(EventList));
    if (!events)
        return NULL;

    for (i = 0; i < num_events; i++)
    {
        events[i].evlen = sizeof(InternalEvent);
        events[i].event = calloc(1, sizeof(InternalEvent));
        if (!events[i].event)
        {
            /* rollback */
            while(i--)
                free(events[i].event);
            free(events);
            events = NULL;
            break;
        }
    }

d1057 1
a1057 1
FreeEventList(EventListPtr list, int num_events)
a1058 4
    if (!list)
        return;
    while(num_events--)
        free(list[num_events].event);
d1062 4
d1067 1
a1067 1
transformAbsolute(DeviceIntPtr dev, int first, int num, int *valuators)
d1069 2
a1070 1
    struct pixman_f_vector p = { .v = {0.0, 0.0, 1.0} };
d1072 8
a1079 3
    /* p' = M * p in homogeneous coordinates */
    if (num >= 1 && first == 0)
        p.v[0] = *(valuators + 0);
d1081 4
a1084 2
    if (first <= 1 && num >= (2 - first))
        p.v[1] = *(valuators + 1 - first);
d1086 1
a1086 1
    pixman_f_transform_point(&dev->transform, &p);
d1088 2
a1089 2
    if (num >= 1 && first == 0)
	    *(valuators + 0) = lround(p.v[0]);
d1091 2
a1092 2
    if (first <= 1 && num >= (2 - first))
        *(valuators + 1 - first) = lround(p.v[1]);
d1096 2
a1097 2
 * Generate a series of xEvents (filled into the EventList) representing
 * pointer motion, or button presses.  Xi and XKB-aware.
d1099 1
a1099 2
 * DOES NOT GENERATE CORE EVENTS! Core events are created when processing the
 * event (ProcessOtherEvent).
d1101 22
a1122 2
 * events is not NULL-terminated; the return value is the number of events.
 * The DDX is responsible for allocating the event structure in the first
d1132 2
d1136 2
a1137 3
GetPointerEvents(EventList *events, DeviceIntPtr pDev, int type, int buttons,
                 int flags, int first_valuator, int num_valuators,
                 int *valuators_in) {
d1146 1
a1146 1
    int valuators[MAX_VALUATORS];
d1152 18
a1171 9
    if (!scr || !pDev->valuator || first_valuator < 0 ||
        num_valuators > MAX_VALUATORS ||
        ((num_valuators + first_valuator) > pDev->valuator->numAxes) ||
        (type != MotionNotify && type != ButtonPress && type != ButtonRelease) ||
        (type != MotionNotify && !pDev->button) ||
        ((type == ButtonPress || type == ButtonRelease) && !buttons) ||
        (type == MotionNotify && num_valuators <= 0))
        return 0;

d1174 1
a1174 3
    raw = (RawDeviceEvent*)events->event;
    events++;
    num_events++;
d1176 5
a1180 1
    memcpy(valuators, valuators_in, num_valuators * sizeof(int));
d1182 3
a1184 3
    init_raw(pDev, raw, ms, type, buttons);
    set_raw_valuators(raw, first_valuator, num_valuators, valuators,
                      raw->valuators.data_raw);
d1190 1
d1192 16
a1207 8
            if (num_valuators >= 1 && first_valuator == 0)
                valuators[0] = rescaleValuatorAxis(valuators[0], 0.0, &x_frac, NULL,
                        pDev->valuator->axes + 0,
                        scr->width);
            if (first_valuator <= 1 && num_valuators >= (2 - first_valuator))
                valuators[1 - first_valuator] = rescaleValuatorAxis(valuators[1 - first_valuator], 0.0, &y_frac, NULL,
                        pDev->valuator->axes + 1,
                        scr->height);
d1210 2
a1211 2
        transformAbsolute(pDev, first_valuator, num_valuators, valuators);
        moveAbsolute(pDev, &x, &y, first_valuator, num_valuators, valuators);
d1214 1
a1214 1
            accelPointer(pDev, first_valuator, num_valuators, valuators, ms);
d1220 1
a1220 1
        moveRelative(pDev, &x, &y, first_valuator, num_valuators, valuators);
d1223 2
a1224 2
    set_raw_valuators(raw, first_valuator, num_valuators, valuators,
            raw->valuators.data);
d1226 3
a1228 2
    positionSprite(pDev, &x, &y, x_frac, y_frac, scr, &cx, &cy, &cx_frac, &cy_frac);
    updateHistory(pDev, first_valuator, num_valuators, ms);
d1231 4
a1234 4
    if (num_valuators >= 1 && first_valuator == 0)
        valuators[0] = x;
    if (first_valuator <= 1 && num_valuators >= (2 - first_valuator))
        valuators[1 - first_valuator] = y;
d1236 1
a1236 2
    if (num_valuators)
        clipValuators(pDev, first_valuator, num_valuators, valuators);
d1238 1
a1238 1
    event = (DeviceEvent*) events->event;
d1262 1
a1262 1
    set_valuators(pDev, event, first_valuator, num_valuators, valuators);
d1267 21
d1290 2
a1291 1
 * Post ProximityIn/ProximityOut events, accompanied by valuators.
d1293 4
a1296 3
 * events is not NULL-terminated; the return value is the number of events.
 * The DDX is responsible for allocating the event structure in the first
 * place via GetMaximumEventsNum(), and for freeing it.
d1299 1
a1299 2
GetProximityEvents(EventList *events, DeviceIntPtr pDev, int type,
                   int first_valuator, int num_valuators, int *valuators_in)
d1301 1
a1301 1
    int num_events = 1;
d1303 1
a1303 1
    int valuators[MAX_VALUATORS];
d1310 1
a1310 1
    if (type != ProximityIn && type != ProximityOut)
d1314 14
a1327 8
    /* Do we need to send a DeviceValuator event? */
    if ((pDev->valuator->mode & 1) == Relative)
        num_valuators = 0;

    /* You fail. */
    if (first_valuator < 0 || num_valuators > MAX_VALUATORS ||
        (num_valuators + first_valuator) > pDev->valuator->numAxes)
        return 0;
d1331 1
a1331 1
    event = (DeviceEvent *) events->event;
d1335 1
a1335 4
    if (num_valuators) {
        memcpy(valuators, valuators_in, num_valuators * sizeof(int));
        clipValuators(pDev, first_valuator, num_valuators, valuators);
    }
d1337 1
a1337 1
    set_valuators(pDev, event, first_valuator, num_valuators, valuators);
@


1.9
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d1050 5
a1054 2
    valuators[0] = lround(p.v[0]);
    valuators[1] = lround(p.v[1]);
@


1.8
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d1037 1
a1037 1
transformAbsolute(DeviceIntPtr dev, int v[MAX_VALUATORS])
d1039 1
a1039 1
    struct pixman_f_vector p;
d1042 5
a1046 3
    p.v[0] = v[0];
    p.v[1] = v[1];
    p.v[2] = 1.0;
d1050 2
a1051 2
    v[0] = lround(p.v[0]);
    v[1] = lround(p.v[1]);
d1129 1
a1129 1
        transformAbsolute(pDev, valuators);
@


1.7
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d114 1
a114 1
    int ret = 0;
d117 1
a117 1
        ret |= !!BitIsOn(pDev->button->down, button);
d119 1
a119 1
        ret |= !!BitIsOn(pDev->button->postdown, button);
d145 1
a145 1
    int ret = 0;
d148 1
a148 1
        ret |= !!BitIsOn(pDev->key->down, key_code);
d150 1
a150 1
        ret |= !!BitIsOn(pDev->key->postdown, key_code);
d213 1
a213 1
           valuators, num_valuators * sizeof(uint32_t));
@


1.6
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d36 1
d60 1
d94 31
d128 1
a128 1
        pDev->key->down[key_code >> 3] |= (1 << (key_code & 7));
d130 1
a130 1
        pDev->key->postdown[key_code >> 3] |= (1 << (key_code & 7));
d137 1
a137 1
        pDev->key->down[key_code >> 3] &= ~(1 << (key_code & 7));
d139 1
a139 1
        pDev->key->postdown[key_code >> 3] &= ~(1 << (key_code & 7));
d148 3
a150 3
        ret |= !!(pDev->key->down[key_code >> 3] & (1 << (key_code & 7)));
    else if (type & KEY_POSTED)
        ret |= !!(pDev->key->postdown[key_code >> 3] & (1 << (key_code & 7)));
d361 1
a361 2
    if (pDev->valuator->motion)
        xfree(pDev->valuator->motion);
d377 1
a377 1
    pDev->valuator->motion = xcalloc(pDev->valuator->numMotionEvents, size);
d419 1
a419 1
    *buff = xalloc(size * pDev->valuator->numMotionEvents);
d655 2
a656 2
static EventListPtr
updateFromMaster(EventListPtr events, DeviceIntPtr dev, int type, int *num_events)
d915 1
a915 1
                          int num_valuators, int *valuators) {
d920 1
d927 1
d934 1
a934 1
    events = updateFromMaster(events, pDev, DEVCHANGE_KEYBOARD_EVENT, &num_events);
d952 2
d998 1
a998 1
    events = (EventListPtr)xcalloc(num_events, sizeof(EventList));
d1005 1
a1005 1
        events[i].event = xcalloc(1, sizeof(InternalEvent));
d1010 2
a1011 2
                xfree(events[i].event);
            xfree(events);
d1032 18
a1049 2
        xfree(list[num_events].event);
    xfree(list);
d1074 1
a1074 1
                 int *valuators) {
d1083 1
d1092 1
d1100 1
a1100 1
    events = updateFromMaster(events, pDev, DEVCHANGE_POINTER_EVENT, &num_events);
d1106 2
d1127 1
d1165 1
a1165 1
            pDev->button->postdown[buttons >> 3] |= (1 << (buttons & 7));
d1169 1
a1169 1
            pDev->button->postdown[buttons >> 3] &= ~(1 << (buttons & 7));
d1194 1
a1194 1
                   int first_valuator, int num_valuators, int *valuators)
d1198 1
d1214 1
a1214 1
    if (first_valuator < 0 ||
d1218 1
a1218 1
    events = updateFromMaster(events, pDev, DEVCHANGE_POINTER_EVENT, &num_events);
d1224 2
a1225 1
    if (num_valuators)
d1227 1
d1254 2
a1255 2
        x += panoramiXdataPtr[0].x - panoramiXdataPtr[screen].x;
        y += panoramiXdataPtr[0].y - panoramiXdataPtr[screen].y;
@


1.5
log
@Update to server 1.6.5.
@
text
@d4 1
d25 2
a26 1
 * Author: Daniel Stone <daniel@@fooishbar.org>
a34 2
#define NEED_EVENTS
#define NEED_REPLIES
d46 2
a48 1
#ifdef XKB
d50 1
a50 2
#include <xkbsrv.h>
#endif
d63 1
d75 1
a75 1
_X_EXPORT int
d85 1
a85 1
_X_EXPORT int
d91 2
a92 2
static void
set_key_down(DeviceIntPtr pDev, int key_code)
d94 4
a97 1
    pDev->key->postdown[key_code >> 3] |= (1 << (key_code & 7));
d100 2
a101 2
static void
set_key_up(DeviceIntPtr pDev, int key_code)
d103 4
a106 1
    pDev->key->postdown[key_code >> 3] &= ~(1 << (key_code & 7));
d109 2
a110 2
static Bool
key_is_down(DeviceIntPtr pDev, int key_code)
d112 8
a119 1
    return !!(pDev->key->postdown[key_code >> 3] & (1 << (key_code & 7)));
d129 103
d236 1
a236 1
rescaleValuatorAxis(int coord, AxisInfoPtr from, AxisInfoPtr to,
d239 2
a240 1
    int fmin = 0, tmin = 0, fmax = defmax, tmax = defmax;
d251 3
a253 1
    if(fmin == tmin && fmax == tmax)
d255 1
d257 3
a259 1
    if(fmax == fmin) /* avoid division by 0 */
d261 1
d263 5
a267 2
    return roundf(((float)(coord - fmin)) * (tmax - tmin) /
                 (fmax - fmin)) + tmin;
d295 2
a296 1
        pDev->last.valuators[0] = rescaleValuatorAxis(pDev->last.valuators[0], NULL, pDev->valuator->axes + 0, scr->width);
d298 2
a299 1
        pDev->last.valuators[1] = rescaleValuatorAxis(pDev->last.valuators[1], NULL, pDev->valuator->axes + 1, scr->height);
d305 1
a305 1
    if ((lastSlave = master->u.lastSlave) && lastSlave->valuator) {
d312 2
d324 1
a324 1
_X_EXPORT void
d338 1
a338 1
    if (pDev->isMaster)
d360 1
a360 1
_X_EXPORT int
d382 1
a382 1
    if (pDev->isMaster)
d420 1
a420 1
                coord = rescaleValuatorAxis(coord, &from, to, pScreen->width);
d431 1
a431 1
                coord = rescaleValuatorAxis(coord, &from, to, pScreen->height);
d434 1
a434 1
            } else if (pDev->isMaster)
d466 1
a466 1
                    coord = rescaleValuatorAxis(coord, &from, to, 0);
d510 1
a510 1
    if (pDev->isMaster)
a561 3
 * Should be used in DIX as:
 * xEvent *events = xcalloc(sizeof(xEvent), GetMaximumEventsNum());
 *
d564 1
a564 1
_X_EXPORT int
d566 5
a570 10
    /* One base event -- device, plus valuator events.
     *  Multiply by two if we're doing non-XKB key repeats. */
    int ret = 1 + MAX_VALUATOR_EVENTS;

#ifdef XKB
    if (noXkbExtension)
#endif
        ret *= 2;

    return ret;
d581 6
a586 2
    AxisInfoPtr axis = pDev->valuator->axes + axisNum;
    /* InitValuatoraAxisStruct ensures that (min < max). */
a604 1
    AxisInfoPtr axes = pDev->valuator->axes + first_valuator;
d607 1
a607 1
    for (i = 0; i < num_valuators; i++, axes++)
a610 39

/**
 * Fills events with valuator events for pDev, as given by the other
 * parameters.
 */
static EventList *
getValuatorEvents(EventList *events, DeviceIntPtr pDev,
        int first_valuator, int num_valuators, int *valuators) {
    deviceValuator *xv;
    int i;

    for (i = 0; i < num_valuators; i += 6, events++) {
        xv = (deviceValuator*)events->event;
        xv->type = DeviceValuator;
        xv->first_valuator = first_valuator + i;
        xv->num_valuators = ((num_valuators - i) > 6) ? 6 : (num_valuators - i);
        xv->deviceid = pDev->id;
        switch (num_valuators - i) {
        case 6:
            xv->valuator5 = valuators[i + 5];
        case 5:
            xv->valuator4 = valuators[i + 4];
        case 4:
            xv->valuator3 = valuators[i + 3];
        case 3:
            xv->valuator2 = valuators[i + 2];
        case 2:
            xv->valuator1 = valuators[i + 1];
        case 1:
            xv->valuator0 = valuators[i + 0];
        }

        if (i + 6 < num_valuators)
            xv->deviceid |= MORE_EVENTS;
    }

    return events;
}

d618 1
d624 1
a624 1
updateFromMaster(EventListPtr events, DeviceIntPtr dev, int *num_events)
d626 5
a630 2
    DeviceIntPtr master = dev->u.master;
    if (master && master->u.lastSlave != dev && dev->coreEvents)
d632 9
a640 3
        updateSlaveDeviceCoords(master, dev);
        master->u.lastSlave = dev;
        master->last.numValuators = dev->last.numValuators;
d713 1
a713 1
    if(dev->u.master) {
d723 2
a724 1
        clipAxis(dev, i, &dev->last.valuators[i + first]);
d757 2
d762 2
d766 2
a767 2
positionSprite(DeviceIntPtr dev, int *x, int *y,
               ScreenPtr scr, int *screenx, int *screeny)
d769 2
d772 7
a778 4
    *screenx = rescaleValuatorAxis(*x, dev->valuator->axes + 0, NULL, scr->width);
    *screeny = rescaleValuatorAxis(*y, dev->valuator->axes + 1, NULL, scr->height);
    dev->last.valuators[0] = *screenx;
    dev->last.valuators[1] = *screeny;
d780 23
d805 1
a805 1
    miPointerSetPosition(dev, &dev->last.valuators[0], &dev->last.valuators[1]);
d807 5
a811 3
    if (dev->u.master && dev->coreEvents) {
        dev->u.master->last.valuators[0] = dev->last.valuators[0];
        dev->u.master->last.valuators[1] = dev->last.valuators[1];
d815 1
a815 1
    if(*screenx != dev->last.valuators[0])
d818 1
a818 1
        *x = rescaleValuatorAxis(dev->last.valuators[0], NULL,
a819 1
        *screenx = dev->last.valuators[0];
d821 1
a821 1
    if(*screeny != dev->last.valuators[1])
d824 1
a824 2
        *screeny = dev->last.valuators[1];
        *y = rescaleValuatorAxis(dev->last.valuators[1], NULL,
d831 2
d848 4
a851 19
        updateMotionHistory(dev->u.master, ms, first, num,
                            &dev->last.valuators[first]);
}

/**
 * Calculate how many DeviceValuator events are needed given a number of
 * valuators.
 * @@param num_valuators Number of valuators to attach to event.
 * @@return the number of DeviceValuator events needed.
 */
static int
countValuatorEvents(int num_valuators)
{
    if (num_valuators) {
        if (((num_valuators - 1) / 6) + 1 > MAX_VALUATOR_EVENTS)
            num_valuators = MAX_VALUATOR_EVENTS * 6;
        return ((num_valuators - 1)/ 6) + 1;
    } else
        return 0;
d858 1
a858 1
_X_EXPORT int
a878 4
 *
 * Note that this function recurses!  If called for non-XKB, a repeating
 * key press will trigger a matching KeyRelease, as well as the
 * KeyPresses.
d880 1
a880 1
_X_EXPORT int
d884 1
a884 1
    int numEvents = 0;
d886 6
a891 3
    KeySym *map;
    KeySym sym;
    deviceKeyButtonPointer *kbp = NULL;
d898 1
a898 1
    numEvents = 1;
d900 1
a900 3
    map = pDev->key->curKeySyms.map;
    sym = map[(key_code - pDev->key->curKeySyms.minKeyCode)
              * pDev->key->curKeySyms.mapWidth];
d902 2
a903 24
    events = updateFromMaster(events, pDev, &numEvents);

    numEvents += countValuatorEvents(num_valuators);

#ifdef XKB
    if (noXkbExtension)
#endif
    {
        switch (sym) {
            case XK_Num_Lock:
            case XK_Caps_Lock:
            case XK_Scroll_Lock:
            case XK_Shift_Lock:
                if (type == KeyRelease)
                    return 0;
                else if (type == KeyPress && key_is_down(pDev, key_code))
                    type = KeyRelease;
        }
    }

    /* Handle core repeating, via press/release/press/release.
     * FIXME: In theory, if you're repeating with two keyboards in non-XKB,
     *        you could get unbalanced events here. */
    if (type == KeyPress && key_is_down(pDev, key_code)) {
d908 1
a908 1
            pDev->key->modifierMap[key_code])
d910 1
d912 12
a923 5
#ifdef XKB
        if (noXkbExtension)
#endif
        {
            int numReleaseEvents;
d925 2
a926 9
            numReleaseEvents = GetKeyboardValuatorEvents(events, pDev,
                                                         KeyRelease, key_code,
                                                         first_valuator,
                                                         num_valuators,
                                                         valuators);
            numEvents += numReleaseEvents;
            events += numReleaseEvents;
        }
    }
d928 3
a930 1
    ms = GetTimeInMillis();
a931 4
    kbp = (deviceKeyButtonPointer *) events->event;
    kbp->time = ms;
    kbp->deviceid = pDev->id;
    kbp->detail = key_code;
d933 2
a934 2
        kbp->type = DeviceKeyPress;
	set_key_down(pDev, key_code);
d937 2
a938 2
        kbp->type = DeviceKeyRelease;
	set_key_up(pDev, key_code);
d941 1
a941 3
    events++;
    if (num_valuators) {
        kbp->deviceid |= MORE_EVENTS;
a942 3
        events = getValuatorEvents(events, pDev, first_valuator,
                                   num_valuators, valuators);
    }
d944 3
a946 1
    return numEvents;
d968 2
a969 2
        events[i].evlen = sizeof(xEvent);
        events[i].event = xcalloc(1, sizeof(xEvent));
a984 24
 * Allocs min_size memory for each event in the list.
 */
_X_EXPORT void
SetMinimumEventSize(EventListPtr list, int num_events, int min_size)
{
    if (!list)
        return;

    while(num_events--)
    {
        if (list[num_events].evlen < min_size)
        {
            list[num_events].evlen = min_size;
            list[num_events].event = realloc(list[num_events].event, min_size);
            if (!list[num_events].event)
            {
                FatalError("[dix] Failed to set event list's "
                        "min_size to %d.\n", min_size);
            }
        }
    }
}

/**
d990 1
a990 1
_X_EXPORT void
d1019 1
a1019 1
_X_EXPORT int
d1025 3
a1027 2
    deviceKeyButtonPointer *kbp = NULL;
    int x, y, /* switches between device and screen coords */
d1029 1
d1032 4
d1042 1
d1046 1
a1046 1
    num_events += countValuatorEvents(num_valuators);
d1048 7
a1054 1
    events = updateFromMaster(events, pDev, &num_events);
d1061 8
a1068 6
            valuators[0] = rescaleValuatorAxis(valuators[0], NULL,
                                               pDev->valuator->axes + 0,
                                               scr->width);
            valuators[1] = rescaleValuatorAxis(valuators[1], NULL,
                                               pDev->valuator->axes + 1,
                                               scr->height);
d1073 1
a1073 1
        if (flags & POINTER_ACCELERATE)
d1075 5
d1083 4
a1086 1
    positionSprite(pDev, &x, &y, scr, &cx, &cy);
a1088 1

d1095 5
a1099 3
    kbp = (deviceKeyButtonPointer *) events->event;
    kbp->time = ms;
    kbp->deviceid = pDev->id;
d1102 2
a1103 1
        kbp->type = DeviceMotionNotify;
d1106 9
a1114 5
        if (type == ButtonPress)
            kbp->type = DeviceButtonPress;
        else if (type == ButtonRelease)
            kbp->type = DeviceButtonRelease;
        kbp->detail = buttons;
d1117 4
a1120 2
    kbp->root_x = cx; /* root_x/y always in screen coords */
    kbp->root_y = cy;
d1122 1
a1122 8
    events++;
    if (num_valuators) {
        kbp->deviceid |= MORE_EVENTS;
        if (flags & POINTER_ABSOLUTE)
            clipValuators(pDev, first_valuator, num_valuators, valuators);
        events = getValuatorEvents(events, pDev, first_valuator,
                                   num_valuators, valuators);
    }
d1135 1
a1135 1
_X_EXPORT int
d1140 5
a1144 2
    deviceKeyButtonPointer *kbp;
    DeviceIntPtr master;
a1154 6
    if (num_valuators) {
        if ((((num_valuators - 1) / 6) + 1) > MAX_VALUATOR_EVENTS)
            num_valuators = MAX_VALUATOR_EVENTS * 6;
        num_events += ((num_valuators - 1) / 6) + 1;
    }

d1160 1
a1160 7
    master = pDev->u.master;
    if (master && master->u.lastSlave != pDev)
    {
        updateSlaveDeviceCoords(master, pDev);
        master->u.lastSlave = pDev;
        master->last.numValuators = pDev->last.numValuators;
    }
d1162 3
a1164 5
    kbp = (deviceKeyButtonPointer *) events->event;
    kbp->type = type;
    kbp->deviceid = pDev->id;
    kbp->detail = 0;
    kbp->time = GetTimeInMillis();
d1166 1
a1166 3
    if (num_valuators) {
        kbp->deviceid |= MORE_EVENTS;
        events++;
d1168 2
a1169 3
        events = getValuatorEvents(events, pDev, first_valuator,
                                   num_valuators, valuators);
    }
d1187 1
a1187 1
    xEvent xE;
d1199 6
a1204 5
    memset(&xE, 0, sizeof(xEvent));
    xE.u.u.type = MotionNotify;
    xE.u.keyButtonPointer.rootX = x;
    xE.u.keyButtonPointer.rootY = y;
    xE.u.keyButtonPointer.time = time;
d1206 2
a1207 1
    (*pDev->public.processInputProc)(&xE, pDev, 1);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d539 1
a539 1
    if (master && master->u.lastSlave != dev)
d677 1
a677 1
    if (dev->u.master) {
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a49 1
extern Bool XkbCopyKeymap(XkbDescPtr src, XkbDescPtr dst, Bool sendNotifies);
a63 5

/* Maximum number of valuators, divided by six, rounded up, to get number
 * of events. */
#define MAX_VALUATOR_EVENTS 6

d67 13
d116 75
d196 1
d203 12
a214 3
    pDev->valuator->motion = xalloc(((sizeof(INT32) * pDev->valuator->numAxes) +
                                     sizeof(Time)) *
                                    pDev->valuator->numMotionEvents);
d217 3
a221 1

d226 2
d230 2
a231 2
GetMotionHistory(DeviceIntPtr pDev, xTimecoord *buff, unsigned long start,
                 unsigned long stop, ScreenPtr pScreen)
d233 1
a233 1
    char *ibuff = NULL, *obuff = (char *) buff;
d235 1
d238 6
a243 1
    int size = (sizeof(INT32) * pDev->valuator->numAxes) + sizeof(Time);
d248 13
d274 74
a347 2
            memcpy(obuff, ibuff, size);
            obuff += size;
d359 7
d372 2
d378 27
a404 1
    buff += ((sizeof(INT32) * pDev->valuator->numAxes) + sizeof(CARD32)) *
a405 1
    memcpy(buff, &ms, sizeof(Time));
d407 5
a411 2
    buff += sizeof(Time);
    bzero(buff, sizeof(INT32) * pDev->valuator->numAxes);
d413 2
a414 2
    buff += sizeof(INT32) * first_valuator;
    memcpy(buff, valuators, sizeof(INT32) * num_valuators);
d417 1
a417 2
                                  pDev->valuator->numMotionEvents;

d438 3
a440 3
    /* Two base events -- core and device, plus valuator events.  Multiply
     * by two if we're doing non-XKB key repeats. */
    int ret = 2 + MAX_VALUATOR_EVENTS;
a450 74
/* Originally a part of xf86PostMotionEvent; modifies valuators
 * in-place. */
static void
acceleratePointer(DeviceIntPtr pDev, int first_valuator, int num_valuators,
                  int *valuators)
{
    float mult = 0.0;
    int dx = 0, dy = 0;
    int *px = NULL, *py = NULL;

    if (!num_valuators || !valuators)
        return;

    if (first_valuator == 0) {
        dx = valuators[0];
        px = &valuators[0];
    }
    if (first_valuator <= 1 && num_valuators >= (2 - first_valuator)) {
        dy = valuators[1 - first_valuator];
        py = &valuators[1 - first_valuator];
    }

    if (!dx && !dy)
        return;

    if (pDev->ptrfeed && pDev->ptrfeed->ctrl.num) {
        /* modeled from xf86Events.c */
        if (pDev->ptrfeed->ctrl.threshold) {
            if ((abs(dx) + abs(dy)) >= pDev->ptrfeed->ctrl.threshold) {
                pDev->valuator->dxremaind = ((float)dx *
                                             (float)(pDev->ptrfeed->ctrl.num)) /
                                             (float)(pDev->ptrfeed->ctrl.den) +
                                            pDev->valuator->dxremaind;
                if (px) {
                    *px = (int)pDev->valuator->dxremaind;
                    pDev->valuator->dxremaind = pDev->valuator->dxremaind -
                                                (float)(*px);
                }

                pDev->valuator->dyremaind = ((float)dy *
                                             (float)(pDev->ptrfeed->ctrl.num)) /
                                             (float)(pDev->ptrfeed->ctrl.den) +
                                            pDev->valuator->dyremaind;
                if (py) {
                    *py = (int)pDev->valuator->dyremaind;
                    pDev->valuator->dyremaind = pDev->valuator->dyremaind -
                                                (float)(*py);
                }
            }
        }
        else {
	    mult = pow((float)dx * (float)dx + (float)dy * (float)dy,
                       ((float)(pDev->ptrfeed->ctrl.num) /
                        (float)(pDev->ptrfeed->ctrl.den) - 1.0) /
                       2.0) / 2.0;
            if (dx) {
                pDev->valuator->dxremaind = mult * (float)dx +
                                            pDev->valuator->dxremaind;
                *px = (int)pDev->valuator->dxremaind;
                pDev->valuator->dxremaind = pDev->valuator->dxremaind -
                                            (float)(*px);
            }
            if (dy) {
                pDev->valuator->dyremaind = mult * (float)dy +
                                            pDev->valuator->dyremaind;
                *py = (int)pDev->valuator->dyremaind;
                pDev->valuator->dyremaind = pDev->valuator->dyremaind -
                                            (float)(*py);
            }
        }
    }
}


d458 2
a459 1
    AxisInfoPtr axes = pDev->valuator->axes + axisNum;
d461 8
a468 7
    /* No clipping if the value-range <= 0 */
    if(axes->min_value < axes->min_value) {
        if (*val < axes->min_value)
            *val = axes->min_value;
        if (*val > axes->max_value)
            *val = axes->max_value;
    }
d489 6
a494 10
 *
 * FIXME: Need to fix ValuatorClassRec to store all the valuators as
 *        last posted, not just x and y; otherwise relative non-x/y
 *        valuators, though a very narrow use case, will be broken.
 */
static xEvent *
getValuatorEvents(xEvent *events, DeviceIntPtr pDev, int first_valuator,
                  int num_valuators, int *valuators) {
    deviceValuator *xv = (deviceValuator *) events;
    int i = 0, final_valuator = first_valuator + num_valuators;
d496 2
a497 1
    for (i = first_valuator; i < final_valuator; i += 6, xv++, events++) {
d499 2
a500 2
        xv->first_valuator = i;
        xv->num_valuators = ((final_valuator - i) > 6) ? 6 : (final_valuator - i);
d502 1
a502 1
        switch (final_valuator - i) {
d514 1
a514 1
            xv->valuator0 = valuators[i];
d517 1
a517 1
        if (i + 6 < final_valuator)
d524 212
d742 1
a742 1
GetKeyboardEvents(xEvent *events, DeviceIntPtr pDev, int type, int key_code) {
d751 3
d768 1
a768 1
GetKeyboardValuatorEvents(xEvent *events, DeviceIntPtr pDev, int type,
d773 1
a773 1
    KeySym *map = pDev->key->curKeySyms.map;
d777 3
a779 9
    if (!events)
        return 0;

    /* DO NOT WANT */
    if (type != KeyPress && type != KeyRelease)
        return 0;

    if (!pDev->key || !pDev->focus || !pDev->kbdfeed ||
        (pDev->coreEvents && !inputInfo.keyboard->key))
d782 1
a782 2
    if (key_code < 8 || key_code > 255)
        return 0;
d784 1
d788 1
a788 4
    if (pDev->coreEvents)
        numEvents = 2;
    else
        numEvents = 1;
d790 1
a790 5
    if (num_valuators) {
        if ((num_valuators / 6) + 1 > MAX_VALUATOR_EVENTS)
            num_valuators = MAX_VALUATOR_EVENTS;
        numEvents += (num_valuators / 6) + 1;
    }
d823 9
a831 5
            numEvents += GetKeyboardValuatorEvents(events, pDev,
                                                   KeyRelease, key_code,
                                                   first_valuator, num_valuators,
                                                   valuators);
            events += numEvents;
d837 1
a837 12
    if (pDev->coreEvents) {
        events->u.keyButtonPointer.time = ms;
        events->u.u.type = type;
        events->u.u.detail = key_code;
        if (type == KeyPress)
	    set_key_down(inputInfo.keyboard, key_code);
        else if (type == KeyRelease)
	    set_key_up(inputInfo.keyboard, key_code);
        events++;
    }

    kbp = (deviceKeyButtonPointer *) events;
d861 34
d897 45
a941 2
 * Generate a series of xEvents (returned in xE) representing pointer
 * motion, or button presses.  Xi and XKB-aware.
d945 9
a953 1
 * place via GetMaximumEventsNum(), and for freeing it.
d956 1
a956 1
GetPointerEvents(xEvent *events, DeviceIntPtr pDev, int type, int buttons,
d959 2
a960 2
    int num_events = 0, final_valuator = 0;
    CARD32 ms = 0;
d962 2
a963 3
    DeviceIntPtr cp = inputInfo.pointer;
    int x = 0, y = 0;
    Bool coreOnly = (pDev == inputInfo.pointer);
d966 1
a966 6
    /* Sanity checks. */
    if (type != MotionNotify && type != ButtonPress && type != ButtonRelease)
        return 0;

    if ((type == ButtonPress || type == ButtonRelease) && !pDev->button)
        return 0;
d968 5
a972 3
    /* FIXME: I guess it should, in theory, be possible to post button events
     *        from devices without valuators. */
    if (!pDev->valuator)
d975 1
a975 4
    if (!coreOnly && pDev->coreEvents)
        num_events = 2;
    else
        num_events = 1;
d977 1
a977 2
    if (type == MotionNotify && num_valuators <= 0)
        return 0;
d979 4
a982 6
    /* Do we need to send a DeviceValuator event? */
    if (!coreOnly && num_valuators) {
        if ((((num_valuators - 1) / 6) + 1) > MAX_VALUATOR_EVENTS)
            num_valuators = MAX_VALUATOR_EVENTS * 6;
        num_events += ((num_valuators - 1) / 6) + 1;
    }
d984 6
a989 48
    final_valuator = num_valuators + first_valuator;

    /* You fail. */
    if (first_valuator < 0 || final_valuator > pDev->valuator->numAxes)
        return 0;

    ms = GetTimeInMillis();

    /* Set x and y based on whether this is absolute or relative, and
     * accelerate if we need to. */
    if (flags & POINTER_ABSOLUTE) {
        if (num_valuators >= 1 && first_valuator == 0) {
            x = valuators[0];
        }
        else {
            /* If we're sending core events but didn't provide a value,
             * translate the core value (but use the device coord if
             * it translates to the same coord to preserve sub-pixel
             * coord information). If we're not sending core events use
             * whatever value we have */
            x = pDev->valuator->lastx;
            if(pDev->coreEvents) {
                int min = pDev->valuator->axes[0].min_value;
                int max = pDev->valuator->axes[0].max_value;
                if(min < max) {
                    if((int)((float)(x-min)*scr->width/(max-min+1)) != cp->valuator->lastx)
                        x = (int)((float)(cp->valuator->lastx)*(max-min+1)/scr->width)+min;
                }
                else
                    x = cp->valuator->lastx;
            }
        }

        if (first_valuator <= 1 && num_valuators >= (2 - first_valuator)) {
            y = valuators[1 - first_valuator];
        }
        else {
            y = pDev->valuator->lasty;
            if(pDev->coreEvents) {
                int min = pDev->valuator->axes[1].min_value;
                int max = pDev->valuator->axes[1].max_value;
                if(min < max) {
                    if((int)((float)(y-min)*scr->height/(max-min+1)) != cp->valuator->lasty)
                        y = (int)((float)(cp->valuator->lasty)*(max-min+1)/scr->height)+min;
                }
                else
                    y = cp->valuator->lasty;
            }
d992 2
a993 5
        /* Clip both x and y to the defined limits (usually co-ord space limit). */
        clipAxis(pDev, 0, &x);
        clipAxis(pDev, 1, &y);
    }
    else {
d995 2
a996 49
            acceleratePointer(pDev, first_valuator, num_valuators,
                              valuators);

        if (pDev->coreEvents) {
            /* Get and convert the core pointer coordinate space into
             * device coordinates. Use the device coords if it translates
             * into the same position as the core to preserve relative sub-
             * pixel movements from the device. */
            int min = pDev->valuator->axes[0].min_value;
            int max = pDev->valuator->axes[0].max_value;
            if(min < max) {
                x = pDev->valuator->lastx;
                if((int)((float)(x-min)*scr->width/(max-min+1)) != cp->valuator->lastx)
                    x = (int)((float)(cp->valuator->lastx)*(max-min+1)/scr->width)+min;
            }
            else
                x = cp->valuator->lastx;

            min = pDev->valuator->axes[1].min_value;
            max = pDev->valuator->axes[1].max_value;
            if(min < max) {
                y = pDev->valuator->lasty;
                if((int)((float)(y-min)*scr->height/(max-min+1)) != cp->valuator->lasty)
                    y = (int)((float)(cp->valuator->lasty)*(max-min+1)/scr->height)+min;
            }
            else
                y = cp->valuator->lasty;

            /* Add relative movement */
            if (first_valuator == 0 && num_valuators >= 1)
                x += valuators[0];
            if (first_valuator <= 1 && num_valuators >= (2 - first_valuator))
                y += valuators[1 - first_valuator];
        }
        else {
            x = pDev->valuator->lastx;
            y = pDev->valuator->lasty;
            if (first_valuator == 0 && num_valuators >= 1)
                x += valuators[0];
            if (first_valuator <= 1 && num_valuators >= (2 - first_valuator))
                y += valuators[1 - first_valuator];

            if(!coreOnly) {
                /* Since we're not sending core-events we must clip both x and y
                 * to the defined limits so we don't run outside the box. */
                clipAxis(pDev, 0, &x);
                clipAxis(pDev, 1, &y);
            }
        }
d999 2
a1000 16
    pDev->valuator->lastx = x;
    pDev->valuator->lasty = y;
    /* Convert the dev coord back to screen coord if we're
     * sending core events */
    if (pDev->coreEvents) {
        int min = pDev->valuator->axes[0].min_value;
        int max = pDev->valuator->axes[0].max_value;
        if(min < max)
            x = (int)((float)(x-min)*scr->width/(max-min+1));
        cp->valuator->lastx = x;
        min = pDev->valuator->axes[1].min_value;
        max = pDev->valuator->axes[1].max_value;
        if(min < max)
            y = (int)((float)(y-min)*scr->height/(max-min+1));
        cp->valuator->lasty = y;
    }
a1001 27
    /* This takes care of crossing screens for us, as well as clipping
     * to the current screen.  Right now, we only have one history buffer,
     * so we don't set this for both the device and core.*/
    miPointerSetPosition(pDev, &x, &y, ms);

    if (pDev->coreEvents) {
        /* miPointerSetPosition may have changed screen */
        scr = miPointerGetScreen(pDev);
        if(x != cp->valuator->lastx) {
            int min = pDev->valuator->axes[0].min_value;
            int max = pDev->valuator->axes[0].max_value;
            cp->valuator->lastx = pDev->valuator->lastx = x;
            if(min < max)
                pDev->valuator->lastx = (int)((float)(x)*(max-min+1)/scr->width)+min;
        }
        if(y != cp->valuator->lasty) {
            int min = pDev->valuator->axes[1].min_value;
            int max = pDev->valuator->axes[1].max_value;
            cp->valuator->lasty = pDev->valuator->lasty = y;
            if(min < max)
                pDev->valuator->lasty = (int)((float)(y)*(max-min+1)/scr->height)+min;
        }
    }
    else if (coreOnly) {
        cp->valuator->lastx = x;
        cp->valuator->lasty = y;
    }
d1003 3
a1005 4
    /* Drop x and y back into the valuators list, if they were originally
     * present. */
    if (first_valuator == 0 && num_valuators >= 1)
        valuators[0] = pDev->valuator->lastx;
d1007 1
a1007 1
        valuators[1 - first_valuator] = pDev->valuator->lasty;
d1009 3
a1011 1
    updateMotionHistory(pDev, ms, first_valuator, num_valuators, valuators);
d1013 9
a1021 18
    /* for some reason inputInfo.pointer does not have coreEvents set */
    if (coreOnly || pDev->coreEvents) {
        events->u.u.type = type;
        events->u.keyButtonPointer.time = ms;
        events->u.keyButtonPointer.rootX = x;
        events->u.keyButtonPointer.rootY = y;

        if (type == ButtonPress || type == ButtonRelease) {
            /* We hijack SetPointerMapping to work on all core-sending
             * devices, so we use the device-specific map here instead of
             * the core one. */
            events->u.u.detail = pDev->button->map[buttons];
        }
        else {
            events->u.u.detail = 0;
        }

        events++;
d1024 2
a1025 4
    if (!coreOnly) {
        kbp = (deviceKeyButtonPointer *) events;
        kbp->time = ms;
        kbp->deviceid = pDev->id;
d1027 4
a1030 17
        if (type == MotionNotify) {
            kbp->type = DeviceMotionNotify;
        }
        else {
            if (type == ButtonPress)
                kbp->type = DeviceButtonPress;
            else if (type == ButtonRelease)
                kbp->type = DeviceButtonRelease;
            kbp->detail = pDev->button->map[buttons];
        }

        kbp->root_x = pDev->valuator->lastx;
        kbp->root_y = pDev->valuator->lasty;

        events++;
        if (num_valuators) {
            kbp->deviceid |= MORE_EVENTS;
d1032 2
a1033 3
            events = getValuatorEvents(events, pDev, first_valuator,
                                       num_valuators, valuators);
        }
d1048 1
a1048 1
GetProximityEvents(xEvent *events, DeviceIntPtr pDev, int type,
d1052 2
a1053 1
    deviceKeyButtonPointer *kbp = (deviceKeyButtonPointer *) events;
a1057 1

a1059 1

d1075 9
a1099 81

/**
 * Note that pDev was the last device to send a core event.  This function
 * copies the complete keymap from the originating device to the core
 * device, and makes sure the appropriate notifications are generated.
 *
 * Call this just before processInputProc.
 */
_X_EXPORT void
SwitchCoreKeyboard(DeviceIntPtr pDev)
{
    KeyClassPtr ckeyc = inputInfo.keyboard->key;
    int i = 0;

    if (pDev != dixLookupPrivate(&inputInfo.keyboard->devPrivates,
				 CoreDevicePrivateKey)) {
        memcpy(ckeyc->modifierMap, pDev->key->modifierMap, MAP_LENGTH);
        if (ckeyc->modifierKeyMap)
            xfree(ckeyc->modifierKeyMap);
        ckeyc->modifierKeyMap = xalloc(8 * pDev->key->maxKeysPerModifier);
        memcpy(ckeyc->modifierKeyMap, pDev->key->modifierKeyMap,
                (8 * pDev->key->maxKeysPerModifier));

        ckeyc->maxKeysPerModifier = pDev->key->maxKeysPerModifier;
        ckeyc->curKeySyms.minKeyCode = pDev->key->curKeySyms.minKeyCode;
        ckeyc->curKeySyms.maxKeyCode = pDev->key->curKeySyms.maxKeyCode;
        SetKeySymsMap(&ckeyc->curKeySyms, &pDev->key->curKeySyms);

        /*
         * Copy state from the extended keyboard to core.  If you omit this,
         * holding Ctrl on keyboard one, and pressing Q on keyboard two, will
         * cause your app to quit.  This feels wrong to me, hence the below
         * code.
         *
         * XXX: If you synthesise core modifier events, the state will get
         *      clobbered here.  You'll have to work out something sensible
         *      to fix that.  Good luck.
         */

#define KEYBOARD_MASK (ShiftMask | LockMask | ControlMask | Mod1Mask | \
                       Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask)
        ckeyc->state &= ~(KEYBOARD_MASK);
        ckeyc->state |= (pDev->key->state & KEYBOARD_MASK);
#undef KEYBOARD_MASK
        for (i = 0; i < 8; i++)
            ckeyc->modifierKeyCount[i] = pDev->key->modifierKeyCount[i];

#ifdef XKB
        if (!noXkbExtension && pDev->key->xkbInfo && pDev->key->xkbInfo->desc) {
            if (!XkbCopyKeymap(pDev->key->xkbInfo->desc, ckeyc->xkbInfo->desc,
                               True))
                FatalError("Couldn't pivot keymap from device to core!\n");
        }
#endif

        SendMappingNotify(MappingKeyboard, ckeyc->curKeySyms.minKeyCode,
                          (ckeyc->curKeySyms.maxKeyCode -
                           ckeyc->curKeySyms.minKeyCode),
                          serverClient);
	dixSetPrivate(&inputInfo.keyboard->devPrivates, CoreDevicePrivateKey,
		      pDev);
    }
}


/**
 * Note that pDev was the last function to send a core pointer event.
 * Currently a no-op.
 *
 * Call this just before processInputProc.
 */
_X_EXPORT void
SwitchCorePointer(DeviceIntPtr pDev)
{
    if (pDev != dixLookupPrivate(&inputInfo.pointer->devPrivates,
				 CoreDevicePrivateKey))
	dixSetPrivate(&inputInfo.pointer->devPrivates,
		      CoreDevicePrivateKey, pDev);
}


d1107 5
a1111 1
PostSyntheticMotion(int x, int y, int screen, unsigned long time)
d1131 1
a1131 1
    (*inputInfo.pointer->public.processInputProc)(&xE, inputInfo.pointer, 1);
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d210 2
d216 1
a216 1
     * by two if we're doing key repeats. */
d279 1
a279 1
		mult = pow((float)dx * (float)dx + (float)dy * (float)dy,
d411 1
a411 1
    KeySym sym = map[key_code * pDev->key->curKeySyms.mapWidth];
d428 3
d845 2
a846 1
    if (inputInfo.keyboard->devPrivates[CoreDevicePrivatesIndex].ptr != pDev) {
d890 2
a891 1
        inputInfo.keyboard->devPrivates[CoreDevicePrivatesIndex].ptr = pDev;
d905 4
a908 2
    if (inputInfo.pointer->devPrivates[CoreDevicePrivatesIndex].ptr != pDev)
        inputInfo.pointer->devPrivates[CoreDevicePrivatesIndex].ptr = pDev;
@


1.1
log
@Initial revision
@
text
@d98 8
a105 1
    return pDev->key->postdown[key_code >> 3] >> (key_code & 7);
d309 7
a315 4
    if (*val < axes->min_value)
        *val = axes->min_value;
    if (axes->max_value >= 0 && *val > axes->max_value)
        *val = axes->max_value;
d350 1
a350 1
        xv->num_valuators = num_valuators;
d415 1
d423 3
d457 2
d460 2
a461 3
            pDev->key->modifierMap[key_code] ||
            !(pDev->kbdfeed->ctrl.autoRepeats[key_code >> 3]
                & (1 << (key_code & 7))))
a528 3
    /* Thanks to a broken lib, we _always_ have to chase DeviceMotionNotifies
     * with DeviceValuators. */
    Bool sendValuators = (type == MotionNotify || flags & POINTER_ABSOLUTE);
d532 1
d555 1
a555 1
    if (!coreOnly && sendValuators) {
d576 16
a591 4
            if (pDev->coreEvents)
                x = cp->valuator->lastx;
            else
                x = pDev->valuator->lastx;
d598 11
a608 4
            if (pDev->coreEvents)
                y = cp->valuator->lasty;
            else
                y = pDev->valuator->lasty;
d610 4
d621 11
a631 2
            if (first_valuator == 0 && num_valuators >= 1)
                x = cp->valuator->lastx + valuators[0];
d635 7
a641 2
            if (first_valuator <= 1 && num_valuators >= (2 - first_valuator))
                y = cp->valuator->lasty + valuators[1 - first_valuator];
d644 6
d652 2
d655 3
a657 3
                x = pDev->valuator->lastx + valuators[0];
            else
                x = pDev->valuator->lastx;
d659 6
a664 4
            if (first_valuator <= 1 && num_valuators >= (2 - first_valuator))
                y = pDev->valuator->lasty + valuators[1 - first_valuator];
            else
                y = pDev->valuator->lasty;
d668 16
a683 3
    /* Clip both x and y to the defined limits (usually co-ord space limit). */
    clipAxis(pDev, 0, &x);
    clipAxis(pDev, 1, &y);
d690 23
d716 1
a716 1
        valuators[0] = x;
d718 1
a718 1
        valuators[1 - first_valuator] = y;
a721 7
    if (pDev->coreEvents) {
        cp->valuator->lastx = x;
        cp->valuator->lasty = y;
    }
    pDev->valuator->lastx = x;
    pDev->valuator->lasty = y;

d758 2
a759 2
        kbp->root_x = x;
        kbp->root_y = y;
d762 1
a762 1
        if (sendValuators) {
d785 1
a785 1
    int num_events = 0;
@


1.1.1.1
log
@xserver 1.4
@
text
@@


1.1.1.2
log
@xserver 1.4.0.90
@
text
@d98 1
a98 8
    return !!(pDev->key->postdown[key_code >> 3] & (1 << (key_code & 7)));
}

static Bool
key_autorepeats(DeviceIntPtr pDev, int key_code)
{
    return !!(pDev->kbdfeed->ctrl.autoRepeats[key_code >> 3] &
              (1 << (key_code & 7)));
a404 1
    /* DO NOT WANT */
a411 3
    if (key_code < 8 || key_code > 255)
        return 0;

a442 2
        /* If autorepeating is disabled either globally or just for that key,
         * or we have a modifier, don't generate a repeat event. */
d444 3
a446 2
            !key_autorepeats(pDev, key_code) ||
            pDev->key->modifierMap[key_code])
d696 1
a696 1
    int num_events = 1;
@

