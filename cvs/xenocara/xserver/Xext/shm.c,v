head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.2
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.19.0.2
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.4
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.2
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.08.09.18.59.50;	author matthieu;	state Exp;
branches;
next	1.23;
commitid	6HLO5qdN5N4nPDjW;

1.23
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.22;
commitid	Te1daavkBLskZ8gc;

1.22
date	2015.02.09.09.45.32;	author kettenis;	state Exp;
branches;
next	1.21;
commitid	2nAtjr0Ll5YwPvQy;

1.21
date	2014.11.22.08.33.46;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	qWPhfcRCIbHxIFHp;

1.20
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.19;
commitid	cVXoV5PxI8YrEaVA;

1.19
date	2014.05.02.19.27.46;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2012.01.31.07.52.35;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.17.21.53.45;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.21.21.38.22;	author matthieu;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2008.01.18.20.53.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.17.15.43.43;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.24.19.04.01;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.31.03.37.55;	author matthieu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2007.05.25.16.20.46;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.59;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.59;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.50;	author matthieu;	state Exp;
branches;
next	;

1.3.2.1
date	2008.01.29.06.02.07;	author ckuethe;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2008.01.30.06.17.10;	author ckuethe;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2008.02.10.19.55.10;	author ckuethe;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2008.07.13.03.11.28;	author brad;	state Exp;
branches;
next	;

1.7.2.1
date	2008.07.13.03.08.30;	author brad;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

********************************************************/

/* THIS IS NOT AN X CONSORTIUM STANDARD OR AN X PROJECT TEAM SPECIFICATION */

#define SHM

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "gcstruct.h"
#include "extnsionst.h"
#include "servermd.h"
#include "shmint.h"
#include "xace.h"
#include <X11/extensions/shmproto.h>
#include <X11/Xfuncproto.h>
#include <sys/mman.h>
#include "protocol-versions.h"
#include "busfault.h"

/* Needed for Solaris cross-zone shared memory extension */
#ifdef HAVE_SHMCTL64
#include <sys/ipc_impl.h>
#define SHMSTAT(id, buf)	shmctl64(id, IPC_STAT64, buf)
#define SHMSTAT_TYPE 		struct shmid_ds64
#define SHMPERM_TYPE 		struct ipc_perm64
#define SHM_PERM(buf) 		buf.shmx_perm
#define SHM_SEGSZ(buf)		buf.shmx_segsz
#define SHMPERM_UID(p)		p->ipcx_uid
#define SHMPERM_CUID(p)		p->ipcx_cuid
#define SHMPERM_GID(p)		p->ipcx_gid
#define SHMPERM_CGID(p)		p->ipcx_cgid
#define SHMPERM_MODE(p)		p->ipcx_mode
#define SHMPERM_ZONEID(p)	p->ipcx_zoneid
#else
#define SHMSTAT(id, buf) 	shmctl(id, IPC_STAT, buf)
#define SHMSTAT_TYPE 		struct shmid_ds
#define SHMPERM_TYPE 		struct ipc_perm
#define SHM_PERM(buf) 		buf.shm_perm
#define SHM_SEGSZ(buf)		buf.shm_segsz
#define SHMPERM_UID(p)		p->uid
#define SHMPERM_CUID(p)		p->cuid
#define SHMPERM_GID(p)		p->gid
#define SHMPERM_CGID(p)		p->cgid
#define SHMPERM_MODE(p)		p->mode
#endif

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

#include "extinit.h"

typedef struct _ShmScrPrivateRec {
    CloseScreenProcPtr CloseScreen;
    ShmFuncsPtr shmFuncs;
    DestroyPixmapProcPtr destroyPixmap;
} ShmScrPrivateRec;

static PixmapPtr fbShmCreatePixmap(XSHM_CREATE_PIXMAP_ARGS);
static int ShmDetachSegment(void *value, XID shmseg);
static void ShmResetProc(ExtensionEntry *extEntry);
static void SShmCompletionEvent(xShmCompletionEvent *from,
                                xShmCompletionEvent *to);

static Bool ShmDestroyPixmap(PixmapPtr pPixmap);

static unsigned char ShmReqCode;
int ShmCompletionCode;
int BadShmSegCode;
RESTYPE ShmSegType;
static ShmDescPtr Shmsegs;
static Bool sharedPixmaps;
static DevPrivateKeyRec shmScrPrivateKeyRec;

#define shmScrPrivateKey (&shmScrPrivateKeyRec)
static DevPrivateKeyRec shmPixmapPrivateKeyRec;

#define shmPixmapPrivateKey (&shmPixmapPrivateKeyRec)
static ShmFuncs miFuncs = { NULL, NULL };
static ShmFuncs fbFuncs = { fbShmCreatePixmap, NULL };

#define ShmGetScreenPriv(s) ((ShmScrPrivateRec *)dixLookupPrivate(&(s)->devPrivates, shmScrPrivateKey))

#define VERIFY_SHMSEG(shmseg,shmdesc,client) \
{ \
    int tmprc; \
    tmprc = dixLookupResourceByType((void **)&(shmdesc), shmseg, ShmSegType, \
                                    client, DixReadAccess); \
    if (tmprc != Success) \
	return tmprc; \
}

#define VERIFY_SHMPTR(shmseg,offset,needwrite,shmdesc,client) \
{ \
    VERIFY_SHMSEG(shmseg, shmdesc, client); \
    if ((offset & 3) || (offset > shmdesc->size)) \
    { \
	client->errorValue = offset; \
	return BadValue; \
    } \
    if (needwrite && !shmdesc->writable) \
	return BadAccess; \
}

#define VERIFY_SHMSIZE(shmdesc,offset,len,client) \
{ \
    if ((offset + len) > shmdesc->size) \
    { \
	return BadAccess; \
    } \
}

#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__CYGWIN__) || defined(__DragonFly__)
#include <sys/signal.h>

static Bool badSysCall = FALSE;

static void
SigSysHandler(int signo)
{
    badSysCall = TRUE;
}

static Bool
CheckForShmSyscall(void)
{
    void (*oldHandler) (int);
    int shmid = -1;

    /* If no SHM support in the kernel, the bad syscall will generate SIGSYS */
    oldHandler = signal(SIGSYS, SigSysHandler);

    badSysCall = FALSE;
    shmid = shmget(IPC_PRIVATE, 4096, IPC_CREAT);

    if (shmid != -1) {
        /* Successful allocation - clean up */
        shmctl(shmid, IPC_RMID, NULL);
    }
    else {
        /* Allocation failed */
        badSysCall = TRUE;
    }
    signal(SIGSYS, oldHandler);
    return !badSysCall;
}

#define MUST_CHECK_FOR_SHM_SYSCALL

#endif

static Bool
ShmCloseScreen(ScreenPtr pScreen)
{
    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(pScreen);

    pScreen->CloseScreen = screen_priv->CloseScreen;
    dixSetPrivate(&pScreen->devPrivates, shmScrPrivateKey, NULL);
    free(screen_priv);
    return (*pScreen->CloseScreen) (pScreen);
}

static ShmScrPrivateRec *
ShmInitScreenPriv(ScreenPtr pScreen)
{
    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(pScreen);

    if (!screen_priv) {
        screen_priv = calloc(1, sizeof(ShmScrPrivateRec));
        screen_priv->CloseScreen = pScreen->CloseScreen;
        dixSetPrivate(&pScreen->devPrivates, shmScrPrivateKey, screen_priv);
        pScreen->CloseScreen = ShmCloseScreen;
    }
    return screen_priv;
}

static Bool
ShmRegisterPrivates(void)
{
    if (!dixRegisterPrivateKey(&shmScrPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&shmPixmapPrivateKeyRec, PRIVATE_PIXMAP, 0))
        return FALSE;
    return TRUE;
}

 /*ARGSUSED*/ static void
ShmResetProc(ExtensionEntry * extEntry)
{
    int i;

    for (i = 0; i < screenInfo.numScreens; i++)
        ShmRegisterFuncs(screenInfo.screens[i], NULL);
}

void
ShmRegisterFuncs(ScreenPtr pScreen, ShmFuncsPtr funcs)
{
    if (!ShmRegisterPrivates())
        return;
    ShmInitScreenPriv(pScreen)->shmFuncs = funcs;
}

static Bool
ShmDestroyPixmap(PixmapPtr pPixmap)
{
    ScreenPtr pScreen = pPixmap->drawable.pScreen;
    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(pScreen);
    void *shmdesc = NULL;
    Bool ret;

    if (pPixmap->refcnt == 1)
        shmdesc = dixLookupPrivate(&pPixmap->devPrivates, shmPixmapPrivateKey);

    pScreen->DestroyPixmap = screen_priv->destroyPixmap;
    ret = (*pScreen->DestroyPixmap) (pPixmap);
    screen_priv->destroyPixmap = pScreen->DestroyPixmap;
    pScreen->DestroyPixmap = ShmDestroyPixmap;

    if (shmdesc)
	ShmDetachSegment(shmdesc, 0);

    return ret;
}

void
ShmRegisterFbFuncs(ScreenPtr pScreen)
{
    ShmRegisterFuncs(pScreen, &fbFuncs);
}

static int
ProcShmQueryVersion(ClientPtr client)
{
    xShmQueryVersionReply rep = {
        .type = X_Reply,
        .sharedPixmaps = sharedPixmaps,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = SERVER_SHM_MAJOR_VERSION,
        .minorVersion = SERVER_SHM_MINOR_VERSION,
        .uid = geteuid(),
        .gid = getegid(),
        .pixmapFormat = sharedPixmaps ? ZPixmap : 0
    };

    REQUEST_SIZE_MATCH(xShmQueryVersionReq);

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.majorVersion);
        swaps(&rep.minorVersion);
        swaps(&rep.uid);
        swaps(&rep.gid);
    }
    WriteToClient(client, sizeof(xShmQueryVersionReply), &rep);
    return Success;
}

/*
 * Simulate the access() system call for a shared memory segement,
 * using the credentials from the client if available
 */
static int
shm_access(ClientPtr client, SHMPERM_TYPE * perm, int readonly)
{
    int uid, gid;
    mode_t mask;
    int uidset = 0, gidset = 0;
    LocalClientCredRec *lcc;

    if (GetLocalClientCreds(client, &lcc) != -1) {

        if (lcc->fieldsSet & LCC_UID_SET) {
            uid = lcc->euid;
            uidset = 1;
        }
        if (lcc->fieldsSet & LCC_GID_SET) {
            gid = lcc->egid;
            gidset = 1;
        }

#if defined(HAVE_GETZONEID) && defined(SHMPERM_ZONEID)
        if (((lcc->fieldsSet & LCC_ZID_SET) == 0) || (lcc->zoneid == -1)
            || (lcc->zoneid != SHMPERM_ZONEID(perm))) {
            uidset = 0;
            gidset = 0;
        }
#endif
        FreeLocalClientCreds(lcc);

        if (uidset) {
            /* User id 0 always gets access */
            if (uid == 0) {
                return 0;
            }
            /* Check the owner */
            if (SHMPERM_UID(perm) == uid || SHMPERM_CUID(perm) == uid) {
                mask = S_IRUSR;
                if (!readonly) {
                    mask |= S_IWUSR;
                }
                return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
            }
        }

        if (gidset) {
            /* Check the group */
            if (SHMPERM_GID(perm) == gid || SHMPERM_CGID(perm) == gid) {
                mask = S_IRGRP;
                if (!readonly) {
                    mask |= S_IWGRP;
                }
                return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
            }
        }
    }
    /* Otherwise, check everyone else */
    mask = S_IROTH;
    if (!readonly) {
        mask |= S_IWOTH;
    }
    return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
}

static int
ProcShmAttach(ClientPtr client)
{
    SHMSTAT_TYPE buf;
    ShmDescPtr shmdesc;

    REQUEST(xShmAttachReq);

    REQUEST_SIZE_MATCH(xShmAttachReq);
    LEGAL_NEW_RESOURCE(stuff->shmseg, client);
    if ((stuff->readOnly != xTrue) && (stuff->readOnly != xFalse)) {
        client->errorValue = stuff->readOnly;
        return BadValue;
    }
    for (shmdesc = Shmsegs; shmdesc; shmdesc = shmdesc->next) {
        if (!SHMDESC_IS_FD(shmdesc) && shmdesc->shmid == stuff->shmid)
            break;
    }
    if (shmdesc) {
        if (!stuff->readOnly && !shmdesc->writable)
            return BadAccess;
        shmdesc->refcnt++;
    }
    else {
        shmdesc = malloc(sizeof(ShmDescRec));
        if (!shmdesc)
            return BadAlloc;
#ifdef SHM_FD_PASSING
        shmdesc->is_fd = FALSE;
#endif
        shmdesc->addr = shmat(stuff->shmid, 0,
                              stuff->readOnly ? SHM_RDONLY : 0);
        if ((shmdesc->addr == ((char *) -1)) || SHMSTAT(stuff->shmid, &buf)) {
            free(shmdesc);
            return BadAccess;
        }

        /* The attach was performed with root privs. We must
         * do manual checking of access rights for the credentials
         * of the client */

        if (shm_access(client, &(SHM_PERM(buf)), stuff->readOnly) == -1) {
            shmdt(shmdesc->addr);
            free(shmdesc);
            return BadAccess;
        }

        shmdesc->shmid = stuff->shmid;
        shmdesc->refcnt = 1;
        shmdesc->writable = !stuff->readOnly;
        shmdesc->size = SHM_SEGSZ(buf);
        shmdesc->next = Shmsegs;
        Shmsegs = shmdesc;
    }
    if (!AddResource(stuff->shmseg, ShmSegType, (void *) shmdesc))
        return BadAlloc;
    return Success;
}

 /*ARGSUSED*/ static int
ShmDetachSegment(void *value, /* must conform to DeleteType */
                 XID unused)
{
    ShmDescPtr shmdesc = (ShmDescPtr) value;
    ShmDescPtr *prev;

    if (--shmdesc->refcnt)
        return TRUE;
#if SHM_FD_PASSING
    if (shmdesc->is_fd) {
        if (shmdesc->busfault)
            busfault_unregister(shmdesc->busfault);
        munmap(shmdesc->addr, shmdesc->size);
    } else
#endif
        shmdt(shmdesc->addr);
    for (prev = &Shmsegs; *prev != shmdesc; prev = &(*prev)->next);
    *prev = shmdesc->next;
    free(shmdesc);
    return Success;
}

static int
ProcShmDetach(ClientPtr client)
{
    ShmDescPtr shmdesc;

    REQUEST(xShmDetachReq);

    REQUEST_SIZE_MATCH(xShmDetachReq);
    VERIFY_SHMSEG(stuff->shmseg, shmdesc, client);
    FreeResource(stuff->shmseg, RT_NONE);
    return Success;
}

/*
 * If the given request doesn't exactly match PutImage's constraints,
 * wrap the image in a scratch pixmap header and let CopyArea sort it out.
 */
static void
doShmPutImage(DrawablePtr dst, GCPtr pGC,
              int depth, unsigned int format,
              int w, int h, int sx, int sy, int sw, int sh, int dx, int dy,
              char *data)
{
    PixmapPtr pPixmap;

    if (format == ZPixmap || (format == XYPixmap && depth == 1)) {
        pPixmap = GetScratchPixmapHeader(dst->pScreen, w, h, depth,
                                         BitsPerPixel(depth),
                                         PixmapBytePad(w, depth), data);
        if (!pPixmap)
            return;
        pGC->ops->CopyArea((DrawablePtr) pPixmap, dst, pGC, sx, sy, sw, sh, dx,
                           dy);
        FreeScratchPixmapHeader(pPixmap);
    }
    else {
        GCPtr putGC = GetScratchGC(depth, dst->pScreen);

        if (!putGC)
            return;

        pPixmap = (*dst->pScreen->CreatePixmap) (dst->pScreen, sw, sh, depth,
                                                 CREATE_PIXMAP_USAGE_SCRATCH);
        if (!pPixmap) {
            FreeScratchGC(putGC);
            return;
        }
        ValidateGC(&pPixmap->drawable, putGC);
        (*putGC->ops->PutImage) (&pPixmap->drawable, putGC, depth, -sx, -sy, w,
                                 h, 0,
                                 (format == XYPixmap) ? XYPixmap : ZPixmap,
                                 data);
        FreeScratchGC(putGC);
        if (format == XYBitmap)
            (void) (*pGC->ops->CopyPlane) (&pPixmap->drawable, dst, pGC, 0, 0,
                                           sw, sh, dx, dy, 1L);
        else
            (void) (*pGC->ops->CopyArea) (&pPixmap->drawable, dst, pGC, 0, 0,
                                          sw, sh, dx, dy);
        (*pPixmap->drawable.pScreen->DestroyPixmap) (pPixmap);
    }
}

static int
ProcShmPutImage(ClientPtr client)
{
    GCPtr pGC;
    DrawablePtr pDraw;
    long length;
    ShmDescPtr shmdesc;

    REQUEST(xShmPutImageReq);

    REQUEST_SIZE_MATCH(xShmPutImageReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, FALSE, shmdesc, client);
    if ((stuff->sendEvent != xTrue) && (stuff->sendEvent != xFalse))
        return BadValue;
    if (stuff->format == XYBitmap) {
        if (stuff->depth != 1)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, 1);
    }
    else if (stuff->format == XYPixmap) {
        if (pDraw->depth != stuff->depth)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, 1);
        length *= stuff->depth;
    }
    else if (stuff->format == ZPixmap) {
        if (pDraw->depth != stuff->depth)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, stuff->depth);
    }
    else {
        client->errorValue = stuff->format;
        return BadValue;
    }

    /*
     * There's a potential integer overflow in this check:
     * VERIFY_SHMSIZE(shmdesc, stuff->offset, length * stuff->totalHeight,
     *                client);
     * the version below ought to avoid it
     */
    if (stuff->totalHeight != 0 &&
        length > (shmdesc->size - stuff->offset) / stuff->totalHeight) {
        client->errorValue = stuff->totalWidth;
        return BadValue;
    }
    if (stuff->srcX > stuff->totalWidth) {
        client->errorValue = stuff->srcX;
        return BadValue;
    }
    if (stuff->srcY > stuff->totalHeight) {
        client->errorValue = stuff->srcY;
        return BadValue;
    }
    if ((stuff->srcX + stuff->srcWidth) > stuff->totalWidth) {
        client->errorValue = stuff->srcWidth;
        return BadValue;
    }
    if ((stuff->srcY + stuff->srcHeight) > stuff->totalHeight) {
        client->errorValue = stuff->srcHeight;
        return BadValue;
    }

    if ((((stuff->format == ZPixmap) && (stuff->srcX == 0)) ||
         ((stuff->format != ZPixmap) &&
          (stuff->srcX < screenInfo.bitmapScanlinePad) &&
          ((stuff->format == XYBitmap) ||
           ((stuff->srcY == 0) &&
            (stuff->srcHeight == stuff->totalHeight))))) &&
        ((stuff->srcX + stuff->srcWidth) == stuff->totalWidth))
        (*pGC->ops->PutImage) (pDraw, pGC, stuff->depth,
                               stuff->dstX, stuff->dstY,
                               stuff->totalWidth, stuff->srcHeight,
                               stuff->srcX, stuff->format,
                               shmdesc->addr + stuff->offset +
                               (stuff->srcY * length));
    else
        doShmPutImage(pDraw, pGC, stuff->depth, stuff->format,
                      stuff->totalWidth, stuff->totalHeight,
                      stuff->srcX, stuff->srcY,
                      stuff->srcWidth, stuff->srcHeight,
                      stuff->dstX, stuff->dstY, shmdesc->addr + stuff->offset);

    if (stuff->sendEvent) {
        xShmCompletionEvent ev = {
            .type = ShmCompletionCode,
            .drawable = stuff->drawable,
            .minorEvent = X_ShmPutImage,
            .majorEvent = ShmReqCode,
            .shmseg = stuff->shmseg,
            .offset = stuff->offset
        };
        WriteEventsToClient(client, 1, (xEvent *) &ev);
    }

    return Success;
}

static int
ProcShmGetImage(ClientPtr client)
{
    DrawablePtr pDraw;
    long lenPer = 0, length;
    Mask plane = 0;
    xShmGetImageReply xgi;
    ShmDescPtr shmdesc;
    VisualID visual = None;
    RegionPtr pVisibleRegion = NULL;
    int rc;

    REQUEST(xShmGetImageReq);

    REQUEST_SIZE_MATCH(xShmGetImageReq);
    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap)) {
        client->errorValue = stuff->format;
        return BadValue;
    }
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixReadAccess);
    if (rc != Success)
        return rc;
    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);
    if (pDraw->type == DRAWABLE_WINDOW) {
        if (   /* check for being viewable */
               !((WindowPtr) pDraw)->realized ||
               /* check for being on screen */
               pDraw->x + stuff->x < 0 ||
               pDraw->x + stuff->x + (int) stuff->width > pDraw->pScreen->width
               || pDraw->y + stuff->y < 0 ||
               pDraw->y + stuff->y + (int) stuff->height >
               pDraw->pScreen->height ||
               /* check for being inside of border */
               stuff->x < -wBorderWidth((WindowPtr) pDraw) ||
               stuff->x + (int) stuff->width >
               wBorderWidth((WindowPtr) pDraw) + (int) pDraw->width ||
               stuff->y < -wBorderWidth((WindowPtr) pDraw) ||
               stuff->y + (int) stuff->height >
               wBorderWidth((WindowPtr) pDraw) + (int) pDraw->height)
            return BadMatch;
        visual = wVisual(((WindowPtr) pDraw));
        pVisibleRegion = NotClippedByChildren((WindowPtr) pDraw);
        if (pVisibleRegion)
            RegionTranslate(pVisibleRegion, -pDraw->x, -pDraw->y);
    }
    else {
        if (stuff->x < 0 ||
            stuff->x + (int) stuff->width > pDraw->width ||
            stuff->y < 0 || stuff->y + (int) stuff->height > pDraw->height)
            return BadMatch;
        visual = None;
    }
    xgi = (xShmGetImageReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .visual = visual,
        .depth = pDraw->depth
    };
    if (stuff->format == ZPixmap) {
        length = PixmapBytePad(stuff->width, pDraw->depth) * stuff->height;
    }
    else {
        lenPer = PixmapBytePad(stuff->width, 1) * stuff->height;
        plane = ((Mask) 1) << (pDraw->depth - 1);
        /* only planes asked for */
        length = lenPer * Ones(stuff->planeMask & (plane | (plane - 1)));
    }

    VERIFY_SHMSIZE(shmdesc, stuff->offset, length, client);
    xgi.size = length;

    if (length == 0) {
        /* nothing to do */
    }
    else if (stuff->format == ZPixmap) {
        (*pDraw->pScreen->GetImage) (pDraw, stuff->x, stuff->y,
                                     stuff->width, stuff->height,
                                     stuff->format, stuff->planeMask,
                                     shmdesc->addr + stuff->offset);
        if (pVisibleRegion)
            XaceCensorImage(client, pVisibleRegion,
                    PixmapBytePad(stuff->width, pDraw->depth), pDraw,
                    stuff->x, stuff->y, stuff->width, stuff->height,
                    stuff->format, shmdesc->addr + stuff->offset);
    }
    else {

        length = stuff->offset;
        for (; plane; plane >>= 1) {
            if (stuff->planeMask & plane) {
                (*pDraw->pScreen->GetImage) (pDraw,
                                             stuff->x, stuff->y,
                                             stuff->width, stuff->height,
                                             stuff->format, plane,
                                             shmdesc->addr + length);
                if (pVisibleRegion)
                    XaceCensorImage(client, pVisibleRegion,
                            BitmapBytePad(stuff->width), pDraw,
                            stuff->x, stuff->y, stuff->width, stuff->height,
                            stuff->format, shmdesc->addr + length);
                length += lenPer;
            }
        }
    }

    if (pVisibleRegion)
        RegionDestroy(pVisibleRegion);

    if (client->swapped) {
        swaps(&xgi.sequenceNumber);
        swapl(&xgi.length);
        swapl(&xgi.visual);
        swapl(&xgi.size);
    }
    WriteToClient(client, sizeof(xShmGetImageReply), &xgi);

    return Success;
}

#ifdef PANORAMIX
static int
ProcPanoramiXShmPutImage(ClientPtr client)
{
    int j, result, orig_x, orig_y;
    PanoramiXRes *draw, *gc;
    Bool sendEvent, isRoot;

    REQUEST(xShmPutImageReq);
    REQUEST_SIZE_MATCH(xShmPutImageReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((void **) &gc, stuff->gc,
                                     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    orig_x = stuff->dstX;
    orig_y = stuff->dstY;
    sendEvent = stuff->sendEvent;
    stuff->sendEvent = 0;
    FOR_NSCREENS(j) {
        if (!j)
            stuff->sendEvent = sendEvent;
        stuff->drawable = draw->info[j].id;
        stuff->gc = gc->info[j].id;
        if (isRoot) {
            stuff->dstX = orig_x - screenInfo.screens[j]->x;
            stuff->dstY = orig_y - screenInfo.screens[j]->y;
        }
        result = ProcShmPutImage(client);
        if (result != Success)
            break;
    }
    return result;
}

static int
ProcPanoramiXShmGetImage(ClientPtr client)
{
    PanoramiXRes *draw;
    DrawablePtr *drawables;
    DrawablePtr pDraw;
    xShmGetImageReply xgi;
    ShmDescPtr shmdesc;
    int i, x, y, w, h, format, rc;
    Mask plane = 0, planemask;
    long lenPer = 0, length, widthBytesLine;
    Bool isRoot;

    REQUEST(xShmGetImageReq);

    REQUEST_SIZE_MATCH(xShmGetImageReq);

    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap)) {
        client->errorValue = stuff->format;
        return BadValue;
    }

    rc = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                  XRC_DRAWABLE, client, DixWriteAccess);
    if (rc != Success)
        return (rc == BadValue) ? BadDrawable : rc;

    if (draw->type == XRT_PIXMAP)
        return ProcShmGetImage(client);

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixReadAccess);
    if (rc != Success)
        return rc;

    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);

    x = stuff->x;
    y = stuff->y;
    w = stuff->width;
    h = stuff->height;
    format = stuff->format;
    planemask = stuff->planeMask;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    if (isRoot) {
        if (                    /* check for being onscreen */
               x < 0 || x + w > PanoramiXPixWidth ||
               y < 0 || y + h > PanoramiXPixHeight)
            return BadMatch;
    }
    else {
        if (                    /* check for being onscreen */
               screenInfo.screens[0]->x + pDraw->x + x < 0 ||
               screenInfo.screens[0]->x + pDraw->x + x + w > PanoramiXPixWidth
               || screenInfo.screens[0]->y + pDraw->y + y < 0 ||
               screenInfo.screens[0]->y + pDraw->y + y + h > PanoramiXPixHeight
               ||
               /* check for being inside of border */
               x < -wBorderWidth((WindowPtr) pDraw) ||
               x + w > wBorderWidth((WindowPtr) pDraw) + (int) pDraw->width ||
               y < -wBorderWidth((WindowPtr) pDraw) ||
               y + h > wBorderWidth((WindowPtr) pDraw) + (int) pDraw->height)
            return BadMatch;
    }

    drawables = calloc(PanoramiXNumScreens, sizeof(DrawablePtr));
    if (!drawables)
        return BadAlloc;

    drawables[0] = pDraw;
    FOR_NSCREENS_FORWARD_SKIP(i) {
        rc = dixLookupDrawable(drawables + i, draw->info[i].id, client, 0,
                               DixReadAccess);
        if (rc != Success) {
            free(drawables);
            return rc;
        }
    }

    xgi = (xShmGetImageReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .visual = wVisual(((WindowPtr) pDraw)),
        .depth = pDraw->depth
    };

    if (format == ZPixmap) {
        widthBytesLine = PixmapBytePad(w, pDraw->depth);
        length = widthBytesLine * h;
    }
    else {
        widthBytesLine = PixmapBytePad(w, 1);
        lenPer = widthBytesLine * h;
        plane = ((Mask) 1) << (pDraw->depth - 1);
        length = lenPer * Ones(planemask & (plane | (plane - 1)));
    }

    VERIFY_SHMSIZE(shmdesc, stuff->offset, length, client);
    xgi.size = length;

    if (length == 0) {          /* nothing to do */
    }
    else if (format == ZPixmap) {
        XineramaGetImageData(drawables, x, y, w, h, format, planemask,
                             shmdesc->addr + stuff->offset,
                             widthBytesLine, isRoot);
    }
    else {

        length = stuff->offset;
        for (; plane; plane >>= 1) {
            if (planemask & plane) {
                XineramaGetImageData(drawables, x, y, w, h,
                                     format, plane, shmdesc->addr + length,
                                     widthBytesLine, isRoot);
                length += lenPer;
            }
        }
    }
    free(drawables);

    if (client->swapped) {
        swaps(&xgi.sequenceNumber);
        swapl(&xgi.length);
        swapl(&xgi.visual);
        swapl(&xgi.size);
    }
    WriteToClient(client, sizeof(xShmGetImageReply), &xgi);

    return Success;
}

static int
ProcPanoramiXShmCreatePixmap(ClientPtr client)
{
    ScreenPtr pScreen = NULL;
    PixmapPtr pMap = NULL;
    DrawablePtr pDraw;
    DepthPtr pDepth;
    int i, j, result, rc;
    ShmDescPtr shmdesc;

    REQUEST(xShmCreatePixmapReq);
    unsigned int width, height, depth;
    unsigned long size;
    PanoramiXRes *newPix;

    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);
    client->errorValue = stuff->pid;
    if (!sharedPixmaps)
        return BadImplementation;
    LEGAL_NEW_RESOURCE(stuff->pid, client);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
                           DixGetAttrAccess);
    if (rc != Success)
        return rc;

    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);

    width = stuff->width;
    height = stuff->height;
    depth = stuff->depth;
    if (!width || !height || !depth) {
        client->errorValue = 0;
        return BadValue;
    }
    if (width > 32767 || height > 32767)
        return BadAlloc;

    if (stuff->depth != 1) {
        pDepth = pDraw->pScreen->allowedDepths;
        for (i = 0; i < pDraw->pScreen->numDepths; i++, pDepth++)
            if (pDepth->depth == stuff->depth)
                goto CreatePmap;
        client->errorValue = stuff->depth;
        return BadValue;
    }

 CreatePmap:
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {
        if (size < width * height)
            return BadAlloc;
    }
    /* thankfully, offset is unsigned */
    if (stuff->offset + size < size)
        return BadAlloc;

    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);

    if (!(newPix = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newPix->type = XRT_PIXMAP;
    newPix->u.pix.shared = TRUE;
    panoramix_setup_ids(newPix, client, stuff->pid);

    result = Success;

    FOR_NSCREENS(j) {
        ShmScrPrivateRec *screen_priv;

        pScreen = screenInfo.screens[j];

        screen_priv = ShmGetScreenPriv(pScreen);
        pMap = (*screen_priv->shmFuncs->CreatePixmap) (pScreen,
                                                       stuff->width,
                                                       stuff->height,
                                                       stuff->depth,
                                                       shmdesc->addr +
                                                       stuff->offset);

        if (pMap) {
            result = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid,
                              RT_PIXMAP, pMap, RT_NONE, NULL, DixCreateAccess);
            if (result != Success) {
                pDraw->pScreen->DestroyPixmap(pMap);
                return result;
            }
            dixSetPrivate(&pMap->devPrivates, shmPixmapPrivateKey, shmdesc);
            shmdesc->refcnt++;
            pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
            pMap->drawable.id = newPix->info[j].id;
            if (!AddResource(newPix->info[j].id, RT_PIXMAP, (void *) pMap)) {
                result = BadAlloc;
                break;
            }
        }
        else {
            result = BadAlloc;
            break;
        }
    }

    if (result == BadAlloc) {
        while (j--)
            FreeResource(newPix->info[j].id, RT_NONE);
        free(newPix);
    }
    else
        AddResource(stuff->pid, XRT_PIXMAP, newPix);

    return result;
}
#endif

static PixmapPtr
fbShmCreatePixmap(ScreenPtr pScreen,
                  int width, int height, int depth, char *addr)
{
    PixmapPtr pPixmap;

    pPixmap = (*pScreen->CreatePixmap) (pScreen, 0, 0, pScreen->rootDepth, 0);
    if (!pPixmap)
        return NullPixmap;

    if (!(*pScreen->ModifyPixmapHeader) (pPixmap, width, height, depth,
                                         BitsPerPixel(depth),
                                         PixmapBytePad(width, depth),
                                         (void *) addr)) {
        (*pScreen->DestroyPixmap) (pPixmap);
        return NullPixmap;
    }
    return pPixmap;
}

static int
ProcShmCreatePixmap(ClientPtr client)
{
    PixmapPtr pMap;
    DrawablePtr pDraw;
    DepthPtr pDepth;
    int i, rc;
    ShmDescPtr shmdesc;
    ShmScrPrivateRec *screen_priv;

    REQUEST(xShmCreatePixmapReq);
    unsigned int width, height, depth;
    unsigned long size;

    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);
    client->errorValue = stuff->pid;
    if (!sharedPixmaps)
        return BadImplementation;
    LEGAL_NEW_RESOURCE(stuff->pid, client);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
                           DixGetAttrAccess);
    if (rc != Success)
        return rc;

    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);

    width = stuff->width;
    height = stuff->height;
    depth = stuff->depth;
    if (!width || !height || !depth) {
        client->errorValue = 0;
        return BadValue;
    }
    if (width > 32767 || height > 32767)
        return BadAlloc;

    if (stuff->depth != 1) {
        pDepth = pDraw->pScreen->allowedDepths;
        for (i = 0; i < pDraw->pScreen->numDepths; i++, pDepth++)
            if (pDepth->depth == stuff->depth)
                goto CreatePmap;
        client->errorValue = stuff->depth;
        return BadValue;
    }

 CreatePmap:
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {
        if (size < width * height)
            return BadAlloc;
    }
    /* thankfully, offset is unsigned */
    if (stuff->offset + size < size)
        return BadAlloc;

    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);
    screen_priv = ShmGetScreenPriv(pDraw->pScreen);
    pMap = (*screen_priv->shmFuncs->CreatePixmap) (pDraw->pScreen, stuff->width,
                                                   stuff->height, stuff->depth,
                                                   shmdesc->addr +
                                                   stuff->offset);
    if (pMap) {
        rc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, RT_PIXMAP,
                      pMap, RT_NONE, NULL, DixCreateAccess);
        if (rc != Success) {
            pDraw->pScreen->DestroyPixmap(pMap);
            return rc;
        }
        dixSetPrivate(&pMap->devPrivates, shmPixmapPrivateKey, shmdesc);
        shmdesc->refcnt++;
        pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
        pMap->drawable.id = stuff->pid;
        if (AddResource(stuff->pid, RT_PIXMAP, (void *) pMap)) {
            return Success;
        }
    }
    return BadAlloc;
}

#ifdef SHM_FD_PASSING

static void
ShmBusfaultNotify(void *context)
{
    ShmDescPtr shmdesc = context;

    ErrorF("shared memory 0x%x truncated by client\n",
           (unsigned int) shmdesc->resource);
    busfault_unregister(shmdesc->busfault);
    shmdesc->busfault = NULL;
    FreeResource (shmdesc->resource, RT_NONE);
}

static int
ProcShmAttachFd(ClientPtr client)
{
    int fd;
    ShmDescPtr shmdesc;
    REQUEST(xShmAttachFdReq);
    struct stat statb;

    SetReqFds(client, 1);
    REQUEST_SIZE_MATCH(xShmAttachFdReq);
    LEGAL_NEW_RESOURCE(stuff->shmseg, client);
    if ((stuff->readOnly != xTrue) && (stuff->readOnly != xFalse)) {
        client->errorValue = stuff->readOnly;
        return BadValue;
    }
    fd = ReadFdFromClient(client);
    if (fd < 0)
        return BadMatch;

    if (fstat(fd, &statb) < 0 || statb.st_size == 0) {
        close(fd);
        return BadMatch;
    }

    shmdesc = malloc(sizeof(ShmDescRec));
    if (!shmdesc) {
        close(fd);
        return BadAlloc;
    }
    shmdesc->is_fd = TRUE;
    shmdesc->addr = mmap(NULL, statb.st_size,
                         stuff->readOnly ? PROT_READ : PROT_READ|PROT_WRITE,
                         MAP_SHARED|__MAP_NOFAULT,
                         fd, 0);

    close(fd);
    if (shmdesc->addr == ((char *) -1)) {
        free(shmdesc);
        return BadAccess;
    }

    shmdesc->refcnt = 1;
    shmdesc->writable = !stuff->readOnly;
    shmdesc->size = statb.st_size;
    shmdesc->resource = stuff->shmseg;

    shmdesc->busfault = busfault_register_mmap(shmdesc->addr, shmdesc->size, ShmBusfaultNotify, shmdesc);
    if (!shmdesc->busfault) {
        munmap(shmdesc->addr, shmdesc->size);
        free(shmdesc);
        return BadAlloc;
    }

    shmdesc->next = Shmsegs;
    Shmsegs = shmdesc;

    if (!AddResource(stuff->shmseg, ShmSegType, (void *) shmdesc))
        return BadAlloc;
    return Success;
}

static int
shm_tmpfile(void)
{
#ifdef SHMDIR
	int	fd;
	int	flags;
	char	template[] = SHMDIR "/shmfd-XXXXXX";
#ifdef O_TMPFILE
	fd = open(SHMDIR, O_TMPFILE|O_RDWR|O_CLOEXEC|O_EXCL, 0666);
	if (fd >= 0) {
		ErrorF ("Using O_TMPFILE\n");
		return fd;
	}
	ErrorF ("Not using O_TMPFILE\n");
#endif
	fd = mkstemp(template);
	if (fd < 0)
		return -1;
	unlink(template);
	if (fcntl(fd, F_GETFD, &flags) >= 0) {
		flags |= FD_CLOEXEC;
		(void) fcntl(fd, F_SETFD, &flags);
	}
	return fd;
#else
        return -1;
#endif
}

static int
ProcShmCreateSegment(ClientPtr client)
{
    int fd;
    ShmDescPtr shmdesc;
    REQUEST(xShmCreateSegmentReq);
    xShmCreateSegmentReply rep = {
        .type = X_Reply,
        .nfd = 1,
        .sequenceNumber = client->sequence,
        .length = 0,
    };

    REQUEST_SIZE_MATCH(xShmCreateSegmentReq);
    if ((stuff->readOnly != xTrue) && (stuff->readOnly != xFalse)) {
        client->errorValue = stuff->readOnly;
        return BadValue;
    }
    fd = shm_tmpfile();
    if (fd < 0)
        return BadAlloc;
    if (ftruncate(fd, stuff->size) < 0) {
        close(fd);
        return BadAlloc;
    }
    shmdesc = malloc(sizeof(ShmDescRec));
    if (!shmdesc) {
        close(fd);
        return BadAlloc;
    }
    shmdesc->is_fd = TRUE;
    shmdesc->addr = mmap(NULL, stuff->size,
                         stuff->readOnly ? PROT_READ : PROT_READ|PROT_WRITE,
                         MAP_SHARED|__MAP_NOFAULT,
                         fd, 0);

    if (shmdesc->addr == ((char *) -1)) {
        close(fd);
        free(shmdesc);
        return BadAccess;
    }

    shmdesc->refcnt = 1;
    shmdesc->writable = !stuff->readOnly;
    shmdesc->size = stuff->size;

    shmdesc->busfault = busfault_register_mmap(shmdesc->addr, shmdesc->size, ShmBusfaultNotify, shmdesc);
    if (!shmdesc->busfault) {
        close(fd);
        munmap(shmdesc->addr, shmdesc->size);
        free(shmdesc);
        return BadAlloc;
    }

    shmdesc->next = Shmsegs;
    Shmsegs = shmdesc;

    if (!AddResource(stuff->shmseg, ShmSegType, (void *) shmdesc)) {
        close(fd);
        return BadAlloc;
    }

    if (WriteFdToClient(client, fd, TRUE) < 0) {
        FreeResource(stuff->shmseg, RT_NONE);
        close(fd);
        return BadAlloc;
    }
    WriteToClient(client, sizeof (xShmCreateSegmentReply), &rep);
    return Success;
}
#endif /* SHM_FD_PASSING */

static int
ProcShmDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_ShmQueryVersion:
        return ProcShmQueryVersion(client);
    case X_ShmAttach:
        return ProcShmAttach(client);
    case X_ShmDetach:
        return ProcShmDetach(client);
    case X_ShmPutImage:
#ifdef PANORAMIX
        if (!noPanoramiXExtension)
            return ProcPanoramiXShmPutImage(client);
#endif
        return ProcShmPutImage(client);
    case X_ShmGetImage:
#ifdef PANORAMIX
        if (!noPanoramiXExtension)
            return ProcPanoramiXShmGetImage(client);
#endif
        return ProcShmGetImage(client);
    case X_ShmCreatePixmap:
#ifdef PANORAMIX
        if (!noPanoramiXExtension)
            return ProcPanoramiXShmCreatePixmap(client);
#endif
        return ProcShmCreatePixmap(client);
#ifdef SHM_FD_PASSING
    case X_ShmAttachFd:
        return ProcShmAttachFd(client);
    case X_ShmCreateSegment:
        return ProcShmCreateSegment(client);
#endif
    default:
        return BadRequest;
    }
}

static void
SShmCompletionEvent(xShmCompletionEvent * from, xShmCompletionEvent * to)
{
    to->type = from->type;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->drawable, to->drawable);
    cpswaps(from->minorEvent, to->minorEvent);
    to->majorEvent = from->majorEvent;
    cpswapl(from->shmseg, to->shmseg);
    cpswapl(from->offset, to->offset);
}

static int
SProcShmQueryVersion(ClientPtr client)
{
    REQUEST(xShmQueryVersionReq);

    swaps(&stuff->length);
    return ProcShmQueryVersion(client);
}

static int
SProcShmAttach(ClientPtr client)
{
    REQUEST(xShmAttachReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShmAttachReq);
    swapl(&stuff->shmseg);
    swapl(&stuff->shmid);
    return ProcShmAttach(client);
}

static int
SProcShmDetach(ClientPtr client)
{
    REQUEST(xShmDetachReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShmDetachReq);
    swapl(&stuff->shmseg);
    return ProcShmDetach(client);
}

static int
SProcShmPutImage(ClientPtr client)
{
    REQUEST(xShmPutImageReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShmPutImageReq);
    swapl(&stuff->drawable);
    swapl(&stuff->gc);
    swaps(&stuff->totalWidth);
    swaps(&stuff->totalHeight);
    swaps(&stuff->srcX);
    swaps(&stuff->srcY);
    swaps(&stuff->srcWidth);
    swaps(&stuff->srcHeight);
    swaps(&stuff->dstX);
    swaps(&stuff->dstY);
    swapl(&stuff->shmseg);
    swapl(&stuff->offset);
    return ProcShmPutImage(client);
}

static int
SProcShmGetImage(ClientPtr client)
{
    REQUEST(xShmGetImageReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShmGetImageReq);
    swapl(&stuff->drawable);
    swaps(&stuff->x);
    swaps(&stuff->y);
    swaps(&stuff->width);
    swaps(&stuff->height);
    swapl(&stuff->planeMask);
    swapl(&stuff->shmseg);
    swapl(&stuff->offset);
    return ProcShmGetImage(client);
}

static int
SProcShmCreatePixmap(ClientPtr client)
{
    REQUEST(xShmCreatePixmapReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShmCreatePixmapReq);
    swapl(&stuff->pid);
    swapl(&stuff->drawable);
    swaps(&stuff->width);
    swaps(&stuff->height);
    swapl(&stuff->shmseg);
    swapl(&stuff->offset);
    return ProcShmCreatePixmap(client);
}

#ifdef SHM_FD_PASSING
static int
SProcShmAttachFd(ClientPtr client)
{
    REQUEST(xShmAttachFdReq);
    SetReqFds(client, 1);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShmAttachFdReq);
    swapl(&stuff->shmseg);
    return ProcShmAttachFd(client);
}

static int
SProcShmCreateSegment(ClientPtr client)
{
    REQUEST(xShmCreateSegmentReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShmCreateSegmentReq);
    swapl(&stuff->shmseg);
    swapl(&stuff->size);
    return ProcShmCreateSegment(client);
}
#endif  /* SHM_FD_PASSING */

static int
SProcShmDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_ShmQueryVersion:
        return SProcShmQueryVersion(client);
    case X_ShmAttach:
        return SProcShmAttach(client);
    case X_ShmDetach:
        return SProcShmDetach(client);
    case X_ShmPutImage:
        return SProcShmPutImage(client);
    case X_ShmGetImage:
        return SProcShmGetImage(client);
    case X_ShmCreatePixmap:
        return SProcShmCreatePixmap(client);
#ifdef SHM_FD_PASSING
    case X_ShmAttachFd:
        return SProcShmAttachFd(client);
    case X_ShmCreateSegment:
        return SProcShmCreateSegment(client);
#endif
    default:
        return BadRequest;
    }
}

void
ShmExtensionInit(void)
{
    ExtensionEntry *extEntry;
    int i;

#ifdef MUST_CHECK_FOR_SHM_SYSCALL
    if (!CheckForShmSyscall()) {
        ErrorF("MIT-SHM extension disabled due to lack of kernel support\n");
        return;
    }
#endif

    if (!ShmRegisterPrivates())
        return;

    sharedPixmaps = xFalse;
    {
        sharedPixmaps = xTrue;
        for (i = 0; i < screenInfo.numScreens; i++) {
            ShmScrPrivateRec *screen_priv =
                ShmInitScreenPriv(screenInfo.screens[i]);
            if (!screen_priv->shmFuncs)
                screen_priv->shmFuncs = &miFuncs;
            if (!screen_priv->shmFuncs->CreatePixmap)
                sharedPixmaps = xFalse;
        }
        if (sharedPixmaps)
            for (i = 0; i < screenInfo.numScreens; i++) {
                ShmScrPrivateRec *screen_priv =
                    ShmGetScreenPriv(screenInfo.screens[i]);
                screen_priv->destroyPixmap =
                    screenInfo.screens[i]->DestroyPixmap;
                screenInfo.screens[i]->DestroyPixmap = ShmDestroyPixmap;
            }
    }
    ShmSegType = CreateNewResourceType(ShmDetachSegment, "ShmSeg");
    if (ShmSegType &&
        (extEntry = AddExtension(SHMNAME, ShmNumberEvents, ShmNumberErrors,
                                 ProcShmDispatch, SProcShmDispatch,
                                 ShmResetProc, StandardMinorOpcode))) {
        ShmReqCode = (unsigned char) extEntry->base;
        ShmCompletionCode = extEntry->eventBase;
        BadShmSegCode = extEntry->errorBase;
        SetResourceTypeErrorValue(ShmSegType, BadShmSegCode);
        EventSwapVector[ShmCompletionCode] = (EventSwapPtr) SShmCompletionEvent;
    }
}
@


1.23
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d622 1
d654 3
d693 5
d709 5
d718 3
@


1.22
log
@Use __MAP_NOFAULT to map shared memory passed through file descriptors.  This
completely avoids the risk of getting killed by a signal because the backing
storage isn't there.

Use the __-prefixed name for now, as we might still change the name.

ok deraadt@@, matthieu@@
@
text
@d263 1
a263 1
	ShmDetachSegment(shmdesc, pPixmap->drawable.id);
d407 1
a407 1
         * do manual checking of access rights for the credentials 
d430 1
a430 1
                 XID shmseg)
d974 6
d1156 1
a1156 1
    if ((shmdesc->addr == ((char *) -1))) {
d1246 1
a1246 1
    if ((shmdesc->addr == ((char *) -1))) {
@


1.21
log
@Update to xserver 1.16.2
@
text
@d1146 1
a1146 1
                         MAP_SHARED,
d1237 1
a1237 1
                         MAP_SHARED,
@


1.20
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d251 1
d254 2
a255 8
    if (pPixmap->refcnt == 1) {
        ShmDescPtr shmdesc;

        shmdesc = (ShmDescPtr) dixLookupPrivate(&pPixmap->devPrivates,
                                                shmPixmapPrivateKey);
        if (shmdesc)
            ShmDetachSegment((void *) shmdesc, pPixmap->drawable.id);
    }
d261 4
@


1.19
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d102 4
a105 8
static int ShmDetachSegment(pointer /* value */ ,
                            XID /* shmseg */
    );
static void ShmResetProc(ExtensionEntry *       /* extEntry */
    );
static void SShmCompletionEvent(xShmCompletionEvent * /* from */ ,
                                xShmCompletionEvent *   /* to */
    );
d129 1
a129 1
    tmprc = dixLookupResourceByType((pointer *)&(shmdesc), shmseg, ShmSegType, \
d259 1
a259 1
            ShmDetachSegment((pointer) shmdesc, pPixmap->drawable.id);
d424 1
a424 1
    if (!AddResource(stuff->shmseg, ShmSegType, (pointer) shmdesc))
d430 1
a430 1
ShmDetachSegment(pointer value, /* must conform to DeleteType */
d728 1
a728 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d733 1
a733 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc,
d782 1
a782 1
    rc = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d979 1
a979 1
            if (!AddResource(newPix->info[j].id, RT_PIXMAP, (pointer) pMap)) {
d1015 1
a1015 1
                                         (pointer) addr)) {
d1094 1
a1094 1
        if (AddResource(stuff->pid, RT_PIXMAP, (pointer) pMap)) {
d1171 1
a1171 1
    if (!AddResource(stuff->shmseg, ShmSegType, (pointer) shmdesc))
d1262 1
a1262 1
    if (!AddResource(stuff->shmseg, ShmSegType, (pointer) shmdesc)) {
@


1.18
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d40 1
d57 1
d59 1
a94 9
typedef struct _ShmDesc {
    struct _ShmDesc *next;
    int shmid;
    int refcnt;
    char *addr;
    Bool writable;
    unsigned long size;
} ShmDescRec, *ShmDescPtr;

d388 4
a391 2
    for (shmdesc = Shmsegs;
         shmdesc && (shmdesc->shmid != stuff->shmid); shmdesc = shmdesc->next);
d401 3
d442 8
a449 1
    shmdt(shmdesc->addr);
d1105 176
d1310 6
d1416 24
d1457 6
@


1.17
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d90 1
a90 1
#include "modinit.h"
d138 5
a142 5
    int rc; \
    rc = dixLookupResourceByType((pointer *)&(shmdesc), shmseg, ShmSegType, \
                                 client, DixReadAccess); \
    if (rc != Success) \
	return rc; \
d205 1
a205 1
ShmCloseScreen(int i, ScreenPtr pScreen)
d212 1
a212 1
    return (*pScreen->CloseScreen) (i, pScreen);
d288 11
a298 1
    xShmQueryVersionReply rep;
d301 1
a301 10
    memset(&rep, 0, sizeof(xShmQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.sharedPixmaps = sharedPixmaps;
    rep.pixmapFormat = sharedPixmaps ? ZPixmap : 0;
    rep.majorVersion = SERVER_SHM_MAJOR_VERSION;
    rep.minorVersion = SERVER_SHM_MINOR_VERSION;
    rep.uid = geteuid();
    rep.gid = getegid();
d310 1
a310 1
    WriteToClient(client, sizeof(xShmQueryVersionReply), (char *) &rep);
d598 8
a605 8
        xShmCompletionEvent ev;

        ev.type = ShmCompletionCode;
        ev.drawable = stuff->drawable;
        ev.minorEvent = X_ShmPutImage;
        ev.majorEvent = ShmReqCode;
        ev.shmseg = stuff->shmseg;
        ev.offset = stuff->offset;
d620 1
d635 1
a635 1
        if (                    /* check for being viewable */
d651 1
a651 1
        xgi.visual = wVisual(((WindowPtr) pDraw));
d658 1
a658 1
        xgi.visual = None;
d660 7
a666 4
    xgi.type = X_Reply;
    xgi.length = 0;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;
d710 1
a710 1
    WriteToClient(client, sizeof(xShmGetImageReply), (char *) &xgi);
d838 7
a844 5
    xgi.visual = wVisual(((WindowPtr) pDraw));
    xgi.type = X_Reply;
    xgi.length = 0;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;
d887 1
a887 1
    WriteToClient(client, sizeof(xShmGetImageReply), (char *) &xgi);
d1251 1
a1251 1
ShmExtensionInit(INITARGS)
@


1.16
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@a28 1

d108 2
a109 3
static int ShmDetachSegment(
    pointer		/* value */,
    XID			/* shmseg */
d111 1
a111 2
static void ShmResetProc(
    ExtensionEntry *	/* extEntry */
d113 2
a114 3
static void SShmCompletionEvent(
    xShmCompletionEvent * /* from */,
    xShmCompletionEvent * /* to */
d117 1
a117 2
static Bool ShmDestroyPixmap (PixmapPtr pPixmap);

d126 1
d129 1
d131 2
a132 2
static ShmFuncs miFuncs = {NULL, NULL};
static ShmFuncs fbFuncs = {fbShmCreatePixmap, NULL};
a164 1

d176 2
a177 1
static Bool CheckForShmSyscall(void)
d179 1
a179 1
    void (*oldHandler)();
d188 1
a188 2
    if (shmid != -1)
    {
d190 1
a190 1
	shmctl(shmid, IPC_RMID, NULL);
d192 1
a192 2
    else
    {
d208 1
d219 6
a224 6
    if (!screen_priv)
    {
	screen_priv = calloc(1, sizeof (ShmScrPrivateRec));
	screen_priv->CloseScreen = pScreen->CloseScreen;
	dixSetPrivate(&pScreen->devPrivates, shmScrPrivateKey, screen_priv);
	pScreen->CloseScreen = ShmCloseScreen;
d233 1
a233 1
	return FALSE;
d235 1
a235 1
	return FALSE;
d239 2
a240 3
/*ARGSUSED*/
static void
ShmResetProc(ExtensionEntry *extEntry)
d243 1
d245 1
a245 1
	ShmRegisterFuncs(screenInfo.screens[i], NULL);
d252 1
a252 1
	return;
d257 1
a257 1
ShmDestroyPixmap (PixmapPtr pPixmap)
d259 1
a259 1
    ScreenPtr	    pScreen = pPixmap->drawable.pScreen;
d261 9
a269 8
    Bool	    ret;
    if (pPixmap->refcnt == 1)
    {
	ShmDescPtr  shmdesc;
	shmdesc = (ShmDescPtr)dixLookupPrivate(&pPixmap->devPrivates,
					       shmPixmapPrivateKey);
	if (shmdesc)
	    ShmDetachSegment ((pointer) shmdesc, pPixmap->drawable.id);
d271 1
a271 1
    
a288 1
    int n;
d302 6
a307 6
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
	swaps(&rep.uid, n);
	swaps(&rep.gid, n);
d309 1
a309 1
    WriteToClient(client, sizeof(xShmQueryVersionReply), (char *)&rep);
d318 1
a318 1
shm_access(ClientPtr client, SHMPERM_TYPE *perm, int readonly)
d324 1
a324 1
    
d327 8
a334 8
	if (lcc->fieldsSet & LCC_UID_SET) {
	    uid = lcc->euid;
	    uidset = 1;
	}
	if (lcc->fieldsSet & LCC_GID_SET) {
	    gid = lcc->egid;
	    gidset = 1;
	}
d337 5
a341 5
	if ( ((lcc->fieldsSet & LCC_ZID_SET) == 0) || (lcc->zoneid == -1)
	     || (lcc->zoneid != SHMPERM_ZONEID(perm))) {
		uidset = 0;
		gidset = 0;
	}
d343 27
a369 27
	FreeLocalClientCreds(lcc);
	
	if (uidset) {
	    /* User id 0 always gets access */
	    if (uid == 0) {
		return 0;
	    }
	    /* Check the owner */
	    if (SHMPERM_UID(perm) == uid || SHMPERM_CUID(perm) == uid) {
		mask = S_IRUSR;
		if (!readonly) {
		    mask |= S_IWUSR;
		}
		return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
	    }
	}

	if (gidset) {
	    /* Check the group */
	    if (SHMPERM_GID(perm) == gid || SHMPERM_CGID(perm) == gid) {
		mask = S_IRGRP;
		if (!readonly) {
		    mask |= S_IWGRP;
		}
		return (SHMPERM_MODE(perm) & mask) == mask ? 0 : -1;
	    }
	}
d374 1
a374 1
	mask |= S_IWOTH;
d384 1
d389 2
a390 3
    if ((stuff->readOnly != xTrue) && (stuff->readOnly != xFalse))
    {
	client->errorValue = stuff->readOnly;
d394 33
a426 8
	 shmdesc && (shmdesc->shmid != stuff->shmid);
	 shmdesc = shmdesc->next)
	;
    if (shmdesc)
    {
	if (!stuff->readOnly && !shmdesc->writable)
	    return BadAccess;
	shmdesc->refcnt++;
d428 2
a429 33
    else
    {
	shmdesc = malloc(sizeof(ShmDescRec));
	if (!shmdesc)
	    return BadAlloc;
	shmdesc->addr = shmat(stuff->shmid, 0,
			      stuff->readOnly ? SHM_RDONLY : 0);
	if ((shmdesc->addr == ((char *)-1)) ||
	    SHMSTAT(stuff->shmid, &buf))
	{
	    free(shmdesc);
	    return BadAccess;
	}

	/* The attach was performed with root privs. We must
	 * do manual checking of access rights for the credentials 
	 * of the client */

	if (shm_access(client, &(SHM_PERM(buf)), stuff->readOnly) == -1) {
	    shmdt(shmdesc->addr);
	    free(shmdesc);
	    return BadAccess;
	}

	shmdesc->shmid = stuff->shmid;
	shmdesc->refcnt = 1;
	shmdesc->writable = !stuff->readOnly;
	shmdesc->size = SHM_SEGSZ(buf);
	shmdesc->next = Shmsegs;
	Shmsegs = shmdesc;
    }
    if (!AddResource(stuff->shmseg, ShmSegType, (pointer)shmdesc))
	return BadAlloc;
d433 1
a433 2
/*ARGSUSED*/
static int
d435 1
a435 1
		 XID shmseg)
d437 1
a437 1
    ShmDescPtr shmdesc = (ShmDescPtr)value;
d441 1
a441 1
	return TRUE;
d443 1
a443 2
    for (prev = &Shmsegs; *prev != shmdesc; prev = &(*prev)->next)
	;
d453 1
d468 3
a470 3
	      int depth, unsigned int format,
	      int w, int h, int sx, int sy, int sw, int sh, int dx, int dy,
	      char *data)
d475 34
a508 31
	pPixmap = GetScratchPixmapHeader(dst->pScreen, w, h, depth,
					 BitsPerPixel(depth),
					 PixmapBytePad(w, depth),
					 data);
	if (!pPixmap)
	    return;
	pGC->ops->CopyArea((DrawablePtr)pPixmap, dst, pGC, sx, sy, sw, sh, dx, dy);
	FreeScratchPixmapHeader(pPixmap);
    } else {
	GCPtr putGC = GetScratchGC(depth, dst->pScreen);

	if (!putGC)
	    return;

	pPixmap = (*dst->pScreen->CreatePixmap)(dst->pScreen, sw, sh, depth,
						CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pPixmap) {
	    FreeScratchGC(putGC);
	    return;
	}
	ValidateGC(&pPixmap->drawable, putGC);
	(*putGC->ops->PutImage)(&pPixmap->drawable, putGC, depth, -sx, -sy, w, h, 0,
				(format == XYPixmap) ? XYPixmap : ZPixmap, data);
	FreeScratchGC(putGC);
	if (format == XYBitmap)
	    (void)(*pGC->ops->CopyPlane)(&pPixmap->drawable, dst, pGC, 0, 0, sw, sh,
					 dx, dy, 1L);
	else
	    (void)(*pGC->ops->CopyArea)(&pPixmap->drawable, dst, pGC, 0, 0, sw, sh,
					dx, dy);
	(*pPixmap->drawable.pScreen->DestroyPixmap)(pPixmap);
d519 1
d526 2
a527 3
	return BadValue;
    if (stuff->format == XYBitmap)
    {
d532 1
a532 2
    else if (stuff->format == XYPixmap)
    {
d536 1
a536 1
	length *= stuff->depth;
d538 1
a538 2
    else if (stuff->format == ZPixmap)
    {
d543 2
a544 3
    else
    {
	client->errorValue = stuff->format;
d555 3
a557 3
	length > (shmdesc->size - stuff->offset)/stuff->totalHeight) {
	client->errorValue = stuff->totalWidth;
	return BadValue;
d559 3
a561 4
    if (stuff->srcX > stuff->totalWidth)
    {
	client->errorValue = stuff->srcX;
	return BadValue;
d563 3
a565 4
    if (stuff->srcY > stuff->totalHeight)
    {
	client->errorValue = stuff->srcY;
	return BadValue;
d567 3
a569 4
    if ((stuff->srcX + stuff->srcWidth) > stuff->totalWidth)
    {
	client->errorValue = stuff->srcWidth;
	return BadValue;
d571 3
a573 4
    if ((stuff->srcY + stuff->srcHeight) > stuff->totalHeight)
    {
	client->errorValue = stuff->srcHeight;
	return BadValue;
d577 12
a588 12
	 ((stuff->format != ZPixmap) &&
	  (stuff->srcX < screenInfo.bitmapScanlinePad) &&
	  ((stuff->format == XYBitmap) ||
	   ((stuff->srcY == 0) &&
	    (stuff->srcHeight == stuff->totalHeight))))) &&
	((stuff->srcX + stuff->srcWidth) == stuff->totalWidth))
	(*pGC->ops->PutImage) (pDraw, pGC, stuff->depth,
			       stuff->dstX, stuff->dstY,
			       stuff->totalWidth, stuff->srcHeight,
			       stuff->srcX, stuff->format,
			       shmdesc->addr + stuff->offset +
			       (stuff->srcY * length));
d590 16
a605 18
	doShmPutImage(pDraw, pGC, stuff->depth, stuff->format,
		      stuff->totalWidth, stuff->totalHeight,
		      stuff->srcX, stuff->srcY,
		      stuff->srcWidth, stuff->srcHeight,
		      stuff->dstX, stuff->dstY,
                      shmdesc->addr + stuff->offset);

    if (stuff->sendEvent)
    {
	xShmCompletionEvent ev;

	ev.type = ShmCompletionCode;
	ev.drawable = stuff->drawable;
	ev.minorEvent = X_ShmPutImage;
	ev.majorEvent = ShmReqCode;
	ev.shmseg = stuff->shmseg;
	ev.offset = stuff->offset;
	WriteEventsToClient(client, 1, (xEvent *) &ev);
d614 6
a619 6
    DrawablePtr		pDraw;
    long		lenPer = 0, length;
    Mask		plane = 0;
    xShmGetImageReply	xgi;
    ShmDescPtr		shmdesc;
    int			n, rc;
d624 2
a625 3
    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap))
    {
	client->errorValue = stuff->format;
d628 1
a628 2
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixReadAccess);
d630 1
a630 1
	return rc;
d632 18
a649 19
    if (pDraw->type == DRAWABLE_WINDOW)
    {
      if( /* check for being viewable */
	 !((WindowPtr) pDraw)->realized ||
	  /* check for being on screen */
         pDraw->x + stuff->x < 0 ||
         pDraw->x + stuff->x + (int)stuff->width > pDraw->pScreen->width ||
         pDraw->y + stuff->y < 0 ||
         pDraw->y + stuff->y + (int)stuff->height > pDraw->pScreen->height ||
          /* check for being inside of border */
         stuff->x < - wBorderWidth((WindowPtr)pDraw) ||
         stuff->x + (int)stuff->width >
		wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
         stuff->y < -wBorderWidth((WindowPtr)pDraw) ||
         stuff->y + (int)stuff->height >
		wBorderWidth((WindowPtr)pDraw) + (int)pDraw->height
        )
	    return BadMatch;
	xgi.visual = wVisual(((WindowPtr)pDraw));
d651 6
a656 9
    else
    {
	if (stuff->x < 0 ||
	    stuff->x+(int)stuff->width > pDraw->width ||
	    stuff->y < 0 ||
	    stuff->y+(int)stuff->height > pDraw->height
	    )
	    return BadMatch;
	xgi.visual = None;
d662 2
a663 3
    if(stuff->format == ZPixmap)
    {
	length = PixmapBytePad(stuff->width, pDraw->depth) * stuff->height;
d665 5
a669 6
    else
    {
	lenPer = PixmapBytePad(stuff->width, 1) * stuff->height;
	plane = ((Mask)1) << (pDraw->depth - 1);
	/* only planes asked for */
	length = lenPer * Ones(stuff->planeMask & (plane | (plane - 1)));
d675 2
a676 3
    if (length == 0)
    {
	/* nothing to do */
d678 5
a682 6
    else if (stuff->format == ZPixmap)
    {
	(*pDraw->pScreen->GetImage)(pDraw, stuff->x, stuff->y,
				    stuff->width, stuff->height,
				    stuff->format, stuff->planeMask,
				    shmdesc->addr + stuff->offset);
d684 1
a684 2
    else
    {
d686 11
a696 13
	length = stuff->offset;
        for (; plane; plane >>= 1)
	{
	    if (stuff->planeMask & plane)
	    {
		(*pDraw->pScreen->GetImage)(pDraw,
					    stuff->x, stuff->y,
					    stuff->width, stuff->height,
					    stuff->format, plane,
					    shmdesc->addr + length);
		length += lenPer;
	    }
	}
d700 4
a703 4
	swaps(&xgi.sequenceNumber, n);
	swapl(&xgi.length, n);
	swapl(&xgi.visual, n);
	swapl(&xgi.size, n);
d705 1
a705 1
    WriteToClient(client, sizeof(xShmGetImageReply), (char *)&xgi);
d711 1
a711 1
static int 
d714 3
a716 3
    int			 j, result, orig_x, orig_y;
    PanoramiXRes	*draw, *gc;
    Bool		 sendEvent, isRoot;
d721 2
a722 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d726 2
a727 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
d738 11
a748 9
	if(!j) stuff->sendEvent = sendEvent;
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->dstX = orig_x - screenInfo.screens[j]->x;
	    stuff->dstY = orig_y - screenInfo.screens[j]->y;
	}
	result = ProcShmPutImage(client);
	if(result != Success) break;
d753 1
a753 1
static int 
d756 9
a764 9
    PanoramiXRes	*draw;
    DrawablePtr 	*drawables;
    DrawablePtr 	pDraw;
    xShmGetImageReply	xgi;
    ShmDescPtr		shmdesc;
    int         	i, x, y, w, h, format, rc;
    Mask		plane = 0, planemask;
    long		lenPer = 0, length, widthBytesLine;
    Bool		isRoot;
d771 1
a771 1
	client->errorValue = stuff->format;
d775 2
a776 2
    rc = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				  XRC_DRAWABLE, client, DixWriteAccess);
d778 1
a778 1
	return (rc == BadValue) ? BadDrawable : rc;
d781 1
a781 1
	return ProcShmGetImage(client);
d783 1
a783 2
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixReadAccess);
d785 1
a785 1
	return rc;
d798 19
a816 17
    if(isRoot) {
      if( /* check for being onscreen */
	x < 0 || x + w > PanoramiXPixWidth ||
	y < 0 || y + h > PanoramiXPixHeight )
	    return BadMatch;
    } else {
      if( /* check for being onscreen */
	screenInfo.screens[0]->x + pDraw->x + x < 0 ||
	screenInfo.screens[0]->x + pDraw->x + x + w > PanoramiXPixWidth ||
	screenInfo.screens[0]->y + pDraw->y + y < 0 ||
	screenInfo.screens[0]->y + pDraw->y + y + h > PanoramiXPixHeight ||
	 /* check for being inside of border */
       	x < - wBorderWidth((WindowPtr)pDraw) ||
	x + w > wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
	y < -wBorderWidth((WindowPtr)pDraw) ||
	y + h > wBorderWidth ((WindowPtr)pDraw) + (int)pDraw->height)
	    return BadMatch;
d820 2
a821 2
    if(!drawables)
	return BadAlloc;
d825 6
a830 7
	rc = dixLookupDrawable(drawables+i, draw->info[i].id, client, 0, 
			       DixReadAccess);
	if (rc != Success)
	{
	    free(drawables);
	    return rc;
	}
d833 1
a833 1
    xgi.visual = wVisual(((WindowPtr)pDraw));
d839 9
a847 8
    if(format == ZPixmap) {
	widthBytesLine = PixmapBytePad(w, pDraw->depth);
	length = widthBytesLine * h;
    } else {
	widthBytesLine = PixmapBytePad(w, 1);
	lenPer = widthBytesLine * h;
	plane = ((Mask)1) << (pDraw->depth - 1);
	length = lenPer * Ones(planemask & (plane | (plane - 1)));
d853 2
a854 1
    if (length == 0) {/* nothing to do */ }
d856 5
a860 4
	    XineramaGetImageData(drawables, x, y, w, h, format, planemask,
					shmdesc->addr + stuff->offset,
					widthBytesLine, isRoot);
    } else {
d862 1
a862 1
	length = stuff->offset;
d864 7
a870 7
	    if (planemask & plane) {
		XineramaGetImageData(drawables, x, y, w, h, 
				     format, plane, shmdesc->addr + length,
				     widthBytesLine, isRoot);
		length += lenPer;
	    }
	}
d873 1
a873 1
    
d875 4
a878 5
	int n;
    	swaps(&xgi.sequenceNumber, n);
    	swapl(&xgi.length, n);
	swapl(&xgi.visual, n);
	swapl(&xgi.size, n);
d880 1
a880 1
    WriteToClient(client, sizeof(xShmGetImageReply), (char *)&xgi);
d894 1
d903 1
a903 1
	return BadImplementation;
d906 1
a906 1
			   DixGetAttrAccess);
d908 1
a908 1
	return rc;
d915 2
a916 3
    if (!width || !height || !depth)
    {
	client->errorValue = 0;
d922 1
a922 2
    if (stuff->depth != 1)
    {
d924 4
a927 4
        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)
	   if (pDepth->depth == stuff->depth)
               goto CreatePmap;
	client->errorValue = stuff->depth;
d931 1
a931 1
CreatePmap:
d939 1
a939 1
	return BadAlloc;
d943 2
a944 2
    if(!(newPix = malloc(sizeof(PanoramiXRes))))
	return BadAlloc;
d953 3
a955 2
	ShmScrPrivateRec *screen_priv;
	pScreen = screenInfo.screens[j];
d957 7
a963 4
	screen_priv = ShmGetScreenPriv(pScreen);
	pMap = (*screen_priv->shmFuncs->CreatePixmap)(pScreen,
				stuff->width, stuff->height, stuff->depth,
				shmdesc->addr + stuff->offset);
d965 2
a966 2
	if (pMap) {
	    dixSetPrivate(&pMap->devPrivates, shmPixmapPrivateKey, shmdesc);
d968 20
a987 18
	    pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	    pMap->drawable.id = newPix->info[j].id;
	    if (!AddResource(newPix->info[j].id, RT_PIXMAP, (pointer)pMap)) {
		result = BadAlloc;
		break;
	    }
	} else {
	   result = BadAlloc;
	   break;
	}
    }

    if(result == BadAlloc) {
	while(j--)
	    FreeResource(newPix->info[j].id, RT_NONE);
	free(newPix);
    } else 
	AddResource(stuff->pid, XRT_PIXMAP, newPix);
d994 2
a995 2
fbShmCreatePixmap (ScreenPtr pScreen,
		   int width, int height, int depth, char *addr)
d999 1
a999 1
    pPixmap = (*pScreen->CreatePixmap)(pScreen, 0, 0, pScreen->rootDepth, 0);
d1001 1
a1001 1
	return NullPixmap;
d1003 6
a1008 4
    if (!(*pScreen->ModifyPixmapHeader)(pPixmap, width, height, depth,
	    BitsPerPixel(depth), PixmapBytePad(width, depth), (pointer)addr)) {
	(*pScreen->DestroyPixmap)(pPixmap);
	return NullPixmap;
d1022 1
d1030 1
a1030 1
	return BadImplementation;
d1033 1
a1033 1
			   DixGetAttrAccess);
d1035 1
a1035 1
	return rc;
d1038 1
a1038 1
    
d1042 2
a1043 3
    if (!width || !height || !depth)
    {
	client->errorValue = 0;
d1047 1
a1047 1
	return BadAlloc;
d1049 1
a1049 2
    if (stuff->depth != 1)
    {
d1051 4
a1054 4
        for (i=0; i<pDraw->pScreen->numDepths; i++, pDepth++)
	   if (pDepth->depth == stuff->depth)
               goto CreatePmap;
	client->errorValue = stuff->depth;
d1058 1
a1058 1
CreatePmap:
d1061 2
a1062 2
	if (size < width * height)
	    return BadAlloc;
d1066 1
a1066 1
	return BadAlloc;
d1070 18
a1087 20
    pMap = (*screen_priv->shmFuncs->CreatePixmap)(
			    pDraw->pScreen, stuff->width,
			    stuff->height, stuff->depth,
			    shmdesc->addr + stuff->offset);
    if (pMap)
    {
	rc = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, RT_PIXMAP,
		      pMap, RT_NONE, NULL, DixCreateAccess);
	if (rc != Success) {
	    pDraw->pScreen->DestroyPixmap(pMap);
	    return rc;
	}
	dixSetPrivate(&pMap->devPrivates, shmPixmapPrivateKey, shmdesc);
	shmdesc->refcnt++;
	pMap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	pMap->drawable.id = stuff->pid;
	if (AddResource(stuff->pid, RT_PIXMAP, (pointer)pMap))
	{
	    return Success;
	}
d1093 1
a1093 1
ProcShmDispatch (ClientPtr client)
d1096 1
a1096 2
    switch (stuff->data)
    {
d1098 1
a1098 1
	return ProcShmQueryVersion(client);
d1100 1
a1100 1
	return ProcShmAttach(client);
d1102 1
a1102 1
	return ProcShmDetach(client);
d1105 2
a1106 2
        if ( !noPanoramiXExtension )
	   return ProcPanoramiXShmPutImage(client);
d1108 1
a1108 1
	return ProcShmPutImage(client);
d1111 2
a1112 2
        if ( !noPanoramiXExtension )
	   return ProcPanoramiXShmGetImage(client);
d1114 1
a1114 1
	return ProcShmGetImage(client);
d1117 2
a1118 2
        if ( !noPanoramiXExtension )
	   return ProcPanoramiXShmCreatePixmap(client);
d1120 1
a1120 1
	   return ProcShmCreatePixmap(client);
d1122 1
a1122 1
	return BadRequest;
d1127 1
a1127 1
SShmCompletionEvent(xShmCompletionEvent *from, xShmCompletionEvent *to)
a1140 1
    int n;
d1143 1
a1143 1
    swaps(&stuff->length, n);
a1149 1
    int n;
d1151 1
a1151 1
    swaps(&stuff->length, n);
d1153 2
a1154 2
    swapl(&stuff->shmseg, n);
    swapl(&stuff->shmid, n);
a1160 1
    int n;
d1162 1
a1162 1
    swaps(&stuff->length, n);
d1164 1
a1164 1
    swapl(&stuff->shmseg, n);
a1170 1
    int n;
d1172 1
a1172 1
    swaps(&stuff->length, n);
d1174 12
a1185 12
    swapl(&stuff->drawable, n);
    swapl(&stuff->gc, n);
    swaps(&stuff->totalWidth, n);
    swaps(&stuff->totalHeight, n);
    swaps(&stuff->srcX, n);
    swaps(&stuff->srcY, n);
    swaps(&stuff->srcWidth, n);
    swaps(&stuff->srcHeight, n);
    swaps(&stuff->dstX, n);
    swaps(&stuff->dstY, n);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->offset, n);
a1191 1
    int n;
d1193 1
a1193 1
    swaps(&stuff->length, n);
d1195 8
a1202 8
    swapl(&stuff->drawable, n);
    swaps(&stuff->x, n);
    swaps(&stuff->y, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    swapl(&stuff->planeMask, n);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->offset, n);
a1208 1
    int n;
d1210 1
a1210 1
    swaps(&stuff->length, n);
d1212 6
a1217 6
    swapl(&stuff->pid, n);
    swapl(&stuff->drawable, n);
    swaps(&stuff->width, n);
    swaps(&stuff->height, n);
    swapl(&stuff->shmseg, n);
    swapl(&stuff->offset, n);
d1222 1
a1222 1
SProcShmDispatch (ClientPtr client)
d1225 1
a1225 2
    switch (stuff->data)
    {
d1227 1
a1227 1
	return SProcShmQueryVersion(client);
d1229 1
a1229 1
	return SProcShmAttach(client);
d1231 1
a1231 1
	return SProcShmDetach(client);
d1233 1
a1233 1
	return SProcShmPutImage(client);
d1235 1
a1235 1
	return SProcShmGetImage(client);
d1237 1
a1237 1
	return SProcShmCreatePixmap(client);
d1239 1
a1239 1
	return BadRequest;
d1250 3
a1252 4
    if (!CheckForShmSyscall())
    {
	ErrorF("MIT-SHM extension disabled due to lack of kernel support\n");
	return;
d1257 1
a1257 1
	return;
d1261 17
a1277 16
      sharedPixmaps = xTrue;
      for (i = 0; i < screenInfo.numScreens; i++)
      {
	ShmScrPrivateRec *screen_priv = ShmInitScreenPriv(screenInfo.screens[i]);
	if (!screen_priv->shmFuncs)
	    screen_priv->shmFuncs = &miFuncs;
	if (!screen_priv->shmFuncs->CreatePixmap)
	    sharedPixmaps = xFalse;
      }
      if (sharedPixmaps)
	for (i = 0; i < screenInfo.numScreens; i++)
	{
	    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(screenInfo.screens[i]);
	    screen_priv->destroyPixmap = screenInfo.screens[i]->DestroyPixmap;
	    screenInfo.screens[i]->DestroyPixmap = ShmDestroyPixmap;
	}
d1281 8
a1288 9
	(extEntry = AddExtension(SHMNAME, ShmNumberEvents, ShmNumberErrors,
				 ProcShmDispatch, SProcShmDispatch,
				 ShmResetProc, StandardMinorOpcode)))
    {
	ShmReqCode = (unsigned char)extEntry->base;
	ShmCompletionCode = extEntry->eventBase;
	BadShmSegCode = extEntry->errorBase;
	SetResourceTypeErrorValue(ShmSegType, BadShmSegCode);
	EventSwapVector[ShmCompletionCode] = (EventSwapPtr) SShmCompletionEvent;
@


1.15
log
@Update to xserver 1.11.2
@
text
@d485 1
a485 1
    if (format == ZPixmap || depth == 1) {
@


1.14
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a122 14
static DISPATCH_PROC(ProcShmAttach);
static DISPATCH_PROC(ProcShmCreatePixmap);
static DISPATCH_PROC(ProcShmDetach);
static DISPATCH_PROC(ProcShmDispatch);
static DISPATCH_PROC(ProcShmGetImage);
static DISPATCH_PROC(ProcShmPutImage);
static DISPATCH_PROC(ProcShmQueryVersion);
static DISPATCH_PROC(SProcShmAttach);
static DISPATCH_PROC(SProcShmCreatePixmap);
static DISPATCH_PROC(SProcShmDetach);
static DISPATCH_PROC(SProcShmDispatch);
static DISPATCH_PROC(SProcShmGetImage);
static DISPATCH_PROC(SProcShmPutImage);
static DISPATCH_PROC(SProcShmQueryVersion);
a242 50
void
ShmExtensionInit(INITARGS)
{
    ExtensionEntry *extEntry;
    int i;

#ifdef MUST_CHECK_FOR_SHM_SYSCALL
    if (!CheckForShmSyscall())
    {
	ErrorF("MIT-SHM extension disabled due to lack of kernel support\n");
	return;
    }
#endif

    if (!ShmRegisterPrivates())
	return;

    sharedPixmaps = xFalse;
    {
      sharedPixmaps = xTrue;
      for (i = 0; i < screenInfo.numScreens; i++)
      {
	ShmScrPrivateRec *screen_priv = ShmInitScreenPriv(screenInfo.screens[i]);
	if (!screen_priv->shmFuncs)
	    screen_priv->shmFuncs = &miFuncs;
	if (!screen_priv->shmFuncs->CreatePixmap)
	    sharedPixmaps = xFalse;
      }
      if (sharedPixmaps)
	for (i = 0; i < screenInfo.numScreens; i++)
	{
	    ShmScrPrivateRec *screen_priv = ShmGetScreenPriv(screenInfo.screens[i]);
	    screen_priv->destroyPixmap = screenInfo.screens[i]->DestroyPixmap;
	    screenInfo.screens[i]->DestroyPixmap = ShmDestroyPixmap;
	}
    }
    ShmSegType = CreateNewResourceType(ShmDetachSegment, "ShmSeg");
    if (ShmSegType &&
	(extEntry = AddExtension(SHMNAME, ShmNumberEvents, ShmNumberErrors,
				 ProcShmDispatch, SProcShmDispatch,
				 ShmResetProc, StandardMinorOpcode)))
    {
	ShmReqCode = (unsigned char)extEntry->base;
	ShmCompletionCode = extEntry->eventBase;
	BadShmSegCode = extEntry->errorBase;
	SetResourceTypeErrorValue(ShmSegType, BadShmSegCode);
	EventSwapVector[ShmCompletionCode] = (EventSwapPtr) SShmCompletionEvent;
    }
}

d520 2
a521 3
#ifdef PANORAMIX
static int 
ProcPanoramiXShmPutImage(ClientPtr client)
d523 5
a527 3
    int			 j, result, orig_x, orig_y;
    PanoramiXRes	*draw, *gc;
    Bool		 sendEvent, isRoot;
a528 1
    REQUEST(xShmPutImageReq);
d530 28
d559 31
a589 4
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;
d591 20
a610 4
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;
d612 3
a614 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d616 7
a622 14
    orig_x = stuff->dstX;
    orig_y = stuff->dstY;
    sendEvent = stuff->sendEvent;
    stuff->sendEvent = 0;
    FOR_NSCREENS(j) {
	if(!j) stuff->sendEvent = sendEvent;
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->dstX = orig_x - screenInfo.screens[j]->x;
	    stuff->dstY = orig_y - screenInfo.screens[j]->y;
	}
	result = ProcShmPutImage(client);
	if(result != Success) break;
d624 2
a625 1
    return result;
d628 2
a629 2
static int 
ProcPanoramiXShmGetImage(ClientPtr client)
d631 3
a633 3
    PanoramiXRes	*draw;
    DrawablePtr 	*drawables;
    DrawablePtr 	pDraw;
d636 1
a636 4
    int         	i, x, y, w, h, format, rc;
    Mask		plane = 0, planemask;
    long		lenPer = 0, length, widthBytesLine;
    Bool		isRoot;
d641 2
a642 2

    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap)) {
a645 9

    rc = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				  XRC_DRAWABLE, client, DixWriteAccess);
    if (rc != Success)
	return (rc == BadValue) ? BadDrawable : rc;

    if (draw->type == XRT_PIXMAP)
	return ProcShmGetImage(client);

a649 1

d651 17
a667 14

    x = stuff->x;
    y = stuff->y;
    w = stuff->width;
    h = stuff->height;
    format = stuff->format;
    planemask = stuff->planeMask;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    if(isRoot) {
      if( /* check for being onscreen */
	x < 0 || x + w > PanoramiXPixWidth ||
	y < 0 || y + h > PanoramiXPixHeight )
d669 174
a842 11
    } else {
      if( /* check for being onscreen */
	screenInfo.screens[0]->x + pDraw->x + x < 0 ||
	screenInfo.screens[0]->x + pDraw->x + x + w > PanoramiXPixWidth ||
	screenInfo.screens[0]->y + pDraw->y + y < 0 ||
	screenInfo.screens[0]->y + pDraw->y + y + h > PanoramiXPixHeight ||
	 /* check for being inside of border */
       	x < - wBorderWidth((WindowPtr)pDraw) ||
	x + w > wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
	y < -wBorderWidth((WindowPtr)pDraw) ||
	y + h > wBorderWidth ((WindowPtr)pDraw) + (int)pDraw->height)
d851 1
a851 1
    for(i = 1; i < PanoramiXNumScreens; i++) {
d975 1
a975 3
    newPix->info[0].id = stuff->pid;
    for(j = 1; j < PanoramiXNumScreens; j++)
	newPix->info[j].id = FakeClientID(client->index);
a993 1
		(*pScreen->DestroyPixmap)(pMap);
d1004 1
a1004 2
	while(j--) {
	    (*pScreen->DestroyPixmap)(pMap);
a1005 1
	}
a1011 1

a1013 222
static int
ProcShmPutImage(ClientPtr client)
{
    GCPtr pGC;
    DrawablePtr pDraw;
    long length;
    ShmDescPtr shmdesc;
    REQUEST(xShmPutImageReq);

    REQUEST_SIZE_MATCH(xShmPutImageReq);
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, FALSE, shmdesc, client);
    if ((stuff->sendEvent != xTrue) && (stuff->sendEvent != xFalse))
	return BadValue;
    if (stuff->format == XYBitmap)
    {
        if (stuff->depth != 1)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, 1);
    }
    else if (stuff->format == XYPixmap)
    {
        if (pDraw->depth != stuff->depth)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, 1);
	length *= stuff->depth;
    }
    else if (stuff->format == ZPixmap)
    {
        if (pDraw->depth != stuff->depth)
            return BadMatch;
        length = PixmapBytePad(stuff->totalWidth, stuff->depth);
    }
    else
    {
	client->errorValue = stuff->format;
        return BadValue;
    }

    /* 
     * There's a potential integer overflow in this check:
     * VERIFY_SHMSIZE(shmdesc, stuff->offset, length * stuff->totalHeight,
     *                client);
     * the version below ought to avoid it
     */
    if (stuff->totalHeight != 0 && 
	length > (shmdesc->size - stuff->offset)/stuff->totalHeight) {
	client->errorValue = stuff->totalWidth;
	return BadValue;
    }
    if (stuff->srcX > stuff->totalWidth)
    {
	client->errorValue = stuff->srcX;
	return BadValue;
    }
    if (stuff->srcY > stuff->totalHeight)
    {
	client->errorValue = stuff->srcY;
	return BadValue;
    }
    if ((stuff->srcX + stuff->srcWidth) > stuff->totalWidth)
    {
	client->errorValue = stuff->srcWidth;
	return BadValue;
    }
    if ((stuff->srcY + stuff->srcHeight) > stuff->totalHeight)
    {
	client->errorValue = stuff->srcHeight;
	return BadValue;
    }

    if ((((stuff->format == ZPixmap) && (stuff->srcX == 0)) ||
	 ((stuff->format != ZPixmap) &&
	  (stuff->srcX < screenInfo.bitmapScanlinePad) &&
	  ((stuff->format == XYBitmap) ||
	   ((stuff->srcY == 0) &&
	    (stuff->srcHeight == stuff->totalHeight))))) &&
	((stuff->srcX + stuff->srcWidth) == stuff->totalWidth))
	(*pGC->ops->PutImage) (pDraw, pGC, stuff->depth,
			       stuff->dstX, stuff->dstY,
			       stuff->totalWidth, stuff->srcHeight, 
			       stuff->srcX, stuff->format, 
			       shmdesc->addr + stuff->offset +
			       (stuff->srcY * length));
    else
	doShmPutImage(pDraw, pGC, stuff->depth, stuff->format,
		      stuff->totalWidth, stuff->totalHeight,
		      stuff->srcX, stuff->srcY,
		      stuff->srcWidth, stuff->srcHeight,
		      stuff->dstX, stuff->dstY,
                      shmdesc->addr + stuff->offset);

    if (stuff->sendEvent)
    {
	xShmCompletionEvent ev;

	ev.type = ShmCompletionCode;
	ev.drawable = stuff->drawable;
	ev.minorEvent = X_ShmPutImage;
	ev.majorEvent = ShmReqCode;
	ev.shmseg = stuff->shmseg;
	ev.offset = stuff->offset;
	WriteEventsToClient(client, 1, (xEvent *) &ev);
    }

    return Success;
}



static int
ProcShmGetImage(ClientPtr client)
{
    DrawablePtr		pDraw;
    long		lenPer = 0, length;
    Mask		plane = 0;
    xShmGetImageReply	xgi;
    ShmDescPtr		shmdesc;
    int			n, rc;

    REQUEST(xShmGetImageReq);

    REQUEST_SIZE_MATCH(xShmGetImageReq);
    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap))
    {
	client->errorValue = stuff->format;
        return BadValue;
    }
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixReadAccess);
    if (rc != Success)
	return rc;
    VERIFY_SHMPTR(stuff->shmseg, stuff->offset, TRUE, shmdesc, client);
    if (pDraw->type == DRAWABLE_WINDOW)
    {
      if( /* check for being viewable */
	 !((WindowPtr) pDraw)->realized ||
	  /* check for being on screen */
         pDraw->x + stuff->x < 0 ||
 	 pDraw->x + stuff->x + (int)stuff->width > pDraw->pScreen->width ||
         pDraw->y + stuff->y < 0 ||
         pDraw->y + stuff->y + (int)stuff->height > pDraw->pScreen->height ||
          /* check for being inside of border */
         stuff->x < - wBorderWidth((WindowPtr)pDraw) ||
         stuff->x + (int)stuff->width >
		wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
         stuff->y < -wBorderWidth((WindowPtr)pDraw) ||
         stuff->y + (int)stuff->height >
		wBorderWidth((WindowPtr)pDraw) + (int)pDraw->height
        )
	    return BadMatch;
	xgi.visual = wVisual(((WindowPtr)pDraw));
    }
    else
    {
	if (stuff->x < 0 ||
	    stuff->x+(int)stuff->width > pDraw->width ||
	    stuff->y < 0 ||
	    stuff->y+(int)stuff->height > pDraw->height
	    )
	    return BadMatch;
	xgi.visual = None;
    }
    xgi.type = X_Reply;
    xgi.length = 0;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;
    if(stuff->format == ZPixmap)
    {
	length = PixmapBytePad(stuff->width, pDraw->depth) * stuff->height;
    }
    else 
    {
	lenPer = PixmapBytePad(stuff->width, 1) * stuff->height;
	plane = ((Mask)1) << (pDraw->depth - 1);
	/* only planes asked for */
	length = lenPer * Ones(stuff->planeMask & (plane | (plane - 1)));
    }

    VERIFY_SHMSIZE(shmdesc, stuff->offset, length, client);
    xgi.size = length;

    if (length == 0)
    {
	/* nothing to do */
    }
    else if (stuff->format == ZPixmap)
    {
	(*pDraw->pScreen->GetImage)(pDraw, stuff->x, stuff->y,
				    stuff->width, stuff->height,
				    stuff->format, stuff->planeMask,
				    shmdesc->addr + stuff->offset);
    }
    else
    {

	length = stuff->offset;
        for (; plane; plane >>= 1)
	{
	    if (stuff->planeMask & plane)
	    {
		(*pDraw->pScreen->GetImage)(pDraw,
					    stuff->x, stuff->y,
					    stuff->width, stuff->height,
					    stuff->format, plane,
					    shmdesc->addr + length);
		length += lenPer;
	    }
	}
    }
    
    if (client->swapped) {
    	swaps(&xgi.sequenceNumber, n);
    	swapl(&xgi.length, n);
	swapl(&xgi.visual, n);
	swapl(&xgi.size, n);
    }
    WriteToClient(client, sizeof(xShmGetImageReply), (char *)&xgi);

    return Success;
}

a1109 1
	pDraw->pScreen->DestroyPixmap(pMap);
d1270 50
@


1.13
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d144 4
a147 4
static int shmScrPrivateKeyIndex;
static DevPrivateKey shmScrPrivateKey = &shmScrPrivateKeyIndex;
static int shmPixmapPrivateIndex;
static DevPrivateKey shmPixmapPrivate = &shmPixmapPrivateIndex;
d159 1
a159 1
	return (rc == BadValue) ? BadShmSegCode : rc; \
d216 1
a216 1
    return(!badSysCall);
d229 1
a229 1
    xfree (screen_priv);
d239 1
a239 1
	screen_priv = xcalloc (1, sizeof (ShmScrPrivateRec));
d247 10
d271 3
d302 1
d319 2
d334 1
a334 1
					       shmPixmapPrivate);
d378 1
a378 1
    return (client->noClientException);
d459 1
a459 1
        return(BadValue);
d473 1
a473 1
	shmdesc = xalloc(sizeof(ShmDescRec));
d481 1
a481 1
	    xfree(shmdesc);
d491 1
a491 1
	    xfree(shmdesc);
d504 1
a504 1
    return(client->noClientException);
d521 1
a521 1
    xfree(shmdesc);
d534 1
a534 1
    return(client->noClientException);
d603 1
a603 1
        return (result == BadValue) ? BadGC : result;
d616 2
a617 2
	    stuff->dstX = orig_x - panoramiXdataPtr[j].x;
	    stuff->dstY = orig_y - panoramiXdataPtr[j].y;
d620 1
a620 1
	if(result != client->noClientException) break;
d622 1
a622 1
    return(result);
d644 1
a644 1
        return(BadValue);
d675 1
a675 1
	    return(BadMatch);
d678 4
a681 4
	panoramiXdataPtr[0].x + pDraw->x + x < 0 ||
	panoramiXdataPtr[0].x + pDraw->x + x + w > PanoramiXPixWidth ||
        panoramiXdataPtr[0].y + pDraw->y + y < 0 ||
	panoramiXdataPtr[0].y + pDraw->y + y + h > PanoramiXPixHeight ||
d687 1
a687 1
	    return(BadMatch);
d690 1
a690 1
    drawables = xcalloc(PanoramiXNumScreens, sizeof(DrawablePtr));
d692 1
a692 1
	return(BadAlloc);
d700 1
a700 1
	    xfree(drawables);
d741 1
a741 1
    xfree(drawables);
d752 1
a752 1
    return(client->noClientException);
d814 1
a814 1
    if(!(newPix = xalloc(sizeof(PanoramiXRes))))
d823 1
a823 1
    result = (client->noClientException);
d835 1
a835 1
	    dixSetPrivate(&pMap->devPrivates, shmPixmapPrivate, shmdesc);
d855 1
a855 1
	xfree(newPix);
a961 1
	ev.sequenceNumber = client->sequence;
d969 1
a969 1
    return (client->noClientException);
d990 1
a990 1
        return(BadValue);
d1014 1
a1014 1
	    return(BadMatch);
d1024 1
a1024 1
	    return(BadMatch);
d1083 1
a1083 1
    return(client->noClientException);
d1174 1
a1174 1
	dixSetPrivate(&pMap->devPrivates, shmPixmapPrivate, shmdesc);
d1180 1
a1180 1
	    return(client->noClientException);
d1184 1
a1184 1
    return (BadAlloc);
@


1.12
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@a40 2
#define NEED_REPLIES
#define NEED_EVENTS
a54 1
#ifdef HAVE_X11_EXTENSIONS_SHMPROTO_H
a55 4
#else
#define _XSHM_SERVER_
#include <X11/extensions/shmstr.h>
#endif
d57 1
d102 6
d139 3
a141 3
_X_EXPORT int ShmCompletionCode;
_X_EXPORT int BadShmSegCode;
_X_EXPORT RESTYPE ShmSegType;
d144 2
a145 2
static ShmFuncsPtr shmFuncs[MAXSCREENS];
static DestroyPixmapProcPtr destroyPixmap[MAXSCREENS];
d151 2
d155 5
a159 6
    shmdesc = (ShmDescPtr)LookupIDByType(shmseg, ShmSegType); \
    if (!shmdesc) \
    { \
	client->errorValue = shmseg; \
	return BadShmSegCode; \
    } \
d208 1
a208 1
	shmctl(shmid, IPC_RMID, (struct shmid_ds *)NULL);
d223 24
d266 4
a269 3
	if (!shmFuncs[i])
	    shmFuncs[i] = &miFuncs;
	if (!shmFuncs[i]->CreatePixmap)
d275 2
a276 1
	    destroyPixmap[i] = screenInfo.screens[i]->DestroyPixmap;
d280 1
a280 1
    ShmSegType = CreateNewResourceType(ShmDetachSegment);
d298 2
a299 5

    for (i = 0; i < MAXSCREENS; i++)
    {
	shmFuncs[i] = (ShmFuncsPtr)NULL;
    }
d302 1
a302 1
_X_EXPORT void
d305 1
a305 1
    shmFuncs[pScreen->myNum] = funcs;
d312 1
d323 1
a323 1
    pScreen->DestroyPixmap = destroyPixmap[pScreen->myNum];
d325 1
a325 1
    destroyPixmap[pScreen->myNum] = pScreen->DestroyPixmap;
d330 1
a330 1
_X_EXPORT void
d333 1
a333 1
    shmFuncs[pScreen->myNum] = &fbFuncs;
d343 1
d349 2
a350 2
    rep.majorVersion = SHM_MAJOR_VERSION;
    rep.minorVersion = SHM_MINOR_VERSION;
d457 1
a457 1
	shmdesc = (ShmDescPtr) xalloc(sizeof(ShmDescRec));
d532 34
a565 9
  
    pPixmap = GetScratchPixmapHeader(dst->pScreen, w, h, depth,
				     BitsPerPixel(depth),
				     PixmapBytePad(w, depth),
				     data);
    if (!pPixmap)
	return;
    pGC->ops->CopyArea((DrawablePtr)pPixmap, dst, pGC, sx, sy, sw, sh, dx, dy);
    FreeScratchPixmapHeader(pPixmap);
d572 1
a572 1
    int			 j, result = 0, orig_x, orig_y;
d579 9
a587 7
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
        return BadDrawable;

    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->gc, XRT_GC, DixReadAccess)))
        return BadGC;
d613 1
a613 1
    DrawablePtr 	drawables[MAXSCREENS];
d631 4
a634 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;
d674 4
d683 2
d686 1
d725 1
d798 1
a798 1
    if(!(newPix = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d810 1
d813 2
a814 1
	pMap = (*shmFuncs[j]->CreatePixmap)(pScreen, 
d1097 1
d1146 2
a1147 1
    pMap = (*shmFuncs[pDraw->pScreen->myNum]->CreatePixmap)(
@


1.11
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d57 3
d62 1
@


1.10
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a36 1
#ifndef Lynx
a38 4
#else
#include <ipc.h>
#include <shm.h>
#endif
a139 2
static int pixmapFormat;
static int shmPixFormat[MAXSCREENS];
d142 2
a143 1
static DevPrivateKey shmPixmapPrivate = &shmPixmapPrivate;
d184 1
a184 2
SigSysHandler(signo)
int signo;
d189 1
a189 1
static Bool CheckForShmSyscall()
a232 1
    pixmapFormat = 0;
a234 1
      pixmapFormat = shmPixFormat[0];
a240 5
	if (shmPixFormat[i] && (shmPixFormat[i] != pixmapFormat))
	{
	    sharedPixmaps = xFalse;
	    pixmapFormat = 0;
	}
a241 2
      if (!pixmapFormat)
	pixmapFormat = ZPixmap;
d264 1
a264 2
ShmResetProc (extEntry)
ExtensionEntry	*extEntry;
a270 1
	shmPixFormat[i] = 0;
d274 2
a275 4
void
ShmRegisterFuncs(
    ScreenPtr pScreen,
    ShmFuncsPtr funcs)
a279 8
void
ShmSetPixmapFormat(
    ScreenPtr pScreen,
    int format)
{
    shmPixFormat[pScreen->myNum] = format;
}

d301 2
a302 3
void
ShmRegisterFbFuncs(pScreen)
    ScreenPtr pScreen;
d308 1
a308 2
ProcShmQueryVersion(client)
    register ClientPtr client;
d311 1
a311 1
    register int n;
d318 1
a318 1
    rep.pixmapFormat = pixmapFormat;
d402 1
a402 2
ProcShmAttach(client)
    register ClientPtr client;
d463 2
a464 3
ShmDetachSegment(value, shmseg)
    pointer value; /* must conform to DeleteType */
    XID shmseg;
d480 1
a480 2
ProcShmDetach(client)
    register ClientPtr client;
d515 1
a515 1
ProcPanoramiXShmPutImage(register ClientPtr client)
d662 1
a662 1
	register int n;
d674 1
a674 2
ProcPanoramiXShmCreatePixmap(
    register ClientPtr client)
d781 1
a781 2
ProcShmPutImage(client)
    register ClientPtr client;
d892 1
a892 2
ProcShmGetImage(client)
    register ClientPtr client;
d1004 2
a1005 6
fbShmCreatePixmap (pScreen, width, height, depth, addr)
    ScreenPtr	pScreen;
    int		width;
    int		height;
    int		depth;
    char	*addr;
d1007 1
a1007 1
    register PixmapPtr pPixmap;
d1022 1
a1022 2
ProcShmCreatePixmap(client)
    register ClientPtr client;
d1027 1
a1027 1
    register int i, rc;
d1103 1
a1103 2
ProcShmDispatch (client)
    register ClientPtr	client;
d1138 1
a1138 2
SShmCompletionEvent(from, to)
    xShmCompletionEvent *from, *to;
d1150 1
a1150 2
SProcShmQueryVersion(client)
    register ClientPtr	client;
d1152 1
a1152 1
    register int n;
d1160 1
a1160 2
SProcShmAttach(client)
    ClientPtr client;
d1162 1
a1162 1
    register int n;
d1172 1
a1172 2
SProcShmDetach(client)
    ClientPtr client;
d1174 1
a1174 1
    register int n;
d1183 1
a1183 2
SProcShmPutImage(client)
    ClientPtr client;
d1185 1
a1185 1
    register int n;
d1205 1
a1205 2
SProcShmGetImage(client)
    ClientPtr client;
d1207 1
a1207 1
    register int n;
d1223 1
a1223 2
SProcShmCreatePixmap(client)
    ClientPtr client;
d1225 1
a1225 1
    register int n;
d1239 1
a1239 2
SProcShmDispatch (client)
    register ClientPtr	client;
@


1.9
log
@CVE-2008-1379 - MIT-SHM arbitrary memory read.
(This patch was missing form the bunch of security patches committed
on june 11. noticed by brad@@).
@
text
@d60 2
d66 27
a108 2
static void miShmPutImage(XSHM_PUT_IMAGE_ARGS);
static void fbShmPutImage(XSHM_PUT_IMAGE_ARGS);
d149 3
a151 3
static int  shmPixmapPrivate;
static ShmFuncs miFuncs = {NULL, miShmPutImage};
static ShmFuncs fbFuncs = {fbShmCreatePixmap, fbShmPutImage};
a258 1
      {
a263 8
	shmPixmapPrivate = AllocatePixmapPrivateIndex();
	for (i = 0; i < screenInfo.numScreens; i++)
	{
	    if (!AllocatePixmapPrivate(screenInfo.screens[i],
				       shmPixmapPrivate, 0))
		return;
	}
      }
d316 2
a317 1
	shmdesc = (ShmDescPtr) pPixmap->devPrivates[shmPixmapPrivate].ptr;
d370 1
a370 1
shm_access(ClientPtr client, struct ipc_perm *perm, int readonly)
d374 4
d379 17
a395 1
    if (LocalClientCred(client, &uid, &gid) != -1) {
d397 12
a408 9
	/* User id 0 always gets access */
	if (uid == 0) {
	    return 0;
	}
	/* Check the owner */
	if (perm->uid == uid || perm->cuid == uid) {
	    mask = S_IRUSR;
	    if (!readonly) {
		mask |= S_IWUSR;
a409 1
	    return (perm->mode & mask) == mask ? 0 : -1;
d411 9
a419 5
	/* Check the group */
	if (perm->gid == gid || perm->cgid == gid) {
	    mask = S_IRGRP;
	    if (!readonly) {
		mask |= S_IWGRP;
a420 1
	    return (perm->mode & mask) == mask ? 0 : -1;
d428 1
a428 1
    return (perm->mode & mask) == mask ? 0 : -1;
d435 1
a435 1
    struct shmid_ds buf;
d464 1
a464 1
	    shmctl(stuff->shmid, IPC_STAT, &buf))
d474 1
a474 1
	if (shm_access(client, &(buf.shm_perm), stuff->readOnly) == -1) {
d483 1
a483 1
	shmdesc->size = buf.shm_segsz;
d524 4
d529 12
a540 12
miShmPutImage(dst, pGC, depth, format, w, h, sx, sy, sw, sh, dx, dy, data)
    DrawablePtr dst;
    GCPtr	pGC;
    int		depth, w, h, sx, sy, sw, sh, dx, dy;
    unsigned int format;
    char 	*data;
{
    PixmapPtr pmap;
    GCPtr putGC;

    putGC = GetScratchGC(depth, dst->pScreen);
    if (!putGC)
d542 2
a543 17
    pmap = (*dst->pScreen->CreatePixmap)(dst->pScreen, sw, sh, depth);
    if (!pmap)
    {
	FreeScratchGC(putGC);
	return;
    }
    ValidateGC((DrawablePtr)pmap, putGC);
    (*putGC->ops->PutImage)((DrawablePtr)pmap, putGC, depth, -sx, -sy, w, h, 0,
			    (format == XYPixmap) ? XYPixmap : ZPixmap, data);
    FreeScratchGC(putGC);
    if (format == XYBitmap)
	(void)(*pGC->ops->CopyPlane)((DrawablePtr)pmap, dst, pGC, 0, 0, sw, sh,
				     dx, dy, 1L);
    else
	(void)(*pGC->ops->CopyArea)((DrawablePtr)pmap, dst, pGC, 0, 0, sw, sh,
				    dx, dy);
    (*pmap->drawable.pScreen->DestroyPixmap)(pmap);
a545 30
static void
fbShmPutImage(dst, pGC, depth, format, w, h, sx, sy, sw, sh, dx, dy, data)
    DrawablePtr dst;
    GCPtr	pGC;
    int		depth, w, h, sx, sy, sw, sh, dx, dy;
    unsigned int format;
    char 	*data;
{
    if ((format == ZPixmap) || (depth == 1))
    {
	PixmapPtr pPixmap;

	pPixmap = GetScratchPixmapHeader(dst->pScreen, w, h, depth,
		BitsPerPixel(depth), PixmapBytePad(w, depth), (pointer)data);
	if (!pPixmap)
	    return;
	if (format == XYBitmap)
	    (void)(*pGC->ops->CopyPlane)((DrawablePtr)pPixmap, dst, pGC,
					 sx, sy, sw, sh, dx, dy, 1L);
	else
	    (void)(*pGC->ops->CopyArea)((DrawablePtr)pPixmap, dst, pGC,
					sx, sy, sw, sh, dx, dy);
	FreeScratchPixmapHeader(pPixmap);
    }
    else
	miShmPutImage(dst, pGC, depth, format, w, h, sx, sy, sw, sh, dx, dy,
		      data);
}


d615 1
a615 1
			   DixUnknownAccess);
d652 1
a652 1
			       DixUnknownAccess);
d727 1
a727 1
			   DixUnknownAccess);
d785 1
a785 1
            pMap->devPrivates[shmPixmapPrivate].ptr = (pointer) shmdesc;
d825 1
a825 1
    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d900 6
a905 7
	(*shmFuncs[pDraw->pScreen->myNum]->PutImage)(
			       pDraw, pGC, stuff->depth, stuff->format,
			       stuff->totalWidth, stuff->totalHeight,
			       stuff->srcX, stuff->srcY,
			       stuff->srcWidth, stuff->srcHeight,
			       stuff->dstX, stuff->dstY,
                               shmdesc->addr + stuff->offset);
d946 1
a946 1
			   DixUnknownAccess);
d1049 1
a1049 1
    pPixmap = (*pScreen->CreatePixmap)(pScreen, 0, 0, pScreen->rootDepth);
d1080 1
a1080 1
			   DixUnknownAccess);
d1124 7
a1130 1
	pMap->devPrivates[shmPixmapPrivate].ptr = (pointer) shmdesc;
d1138 1
@


1.8
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@d851 11
a861 2
    VERIFY_SHMSIZE(shmdesc, stuff->offset, length * stuff->totalHeight,
		   client);
@


1.7
log
@3rd try... CVE-2007-6429: Always test for size+offset wrapping. From X.Org.
@
text
@d157 1
a157 1
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__CYGWIN__)
@


1.7.2.1
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@d851 2
a852 11
    /* 
     * There's a potential integer overflow in this check:
     * VERIFY_SHMSIZE(shmdesc, stuff->offset, length * stuff->totalHeight,
     *                client);
     * the version below ought to avoid it
     */
    if (stuff->totalHeight != 0 && 
	length > (shmdesc->size - stuff->offset)/stuff->totalHeight) {
	client->errorValue = stuff->totalWidth;
	return BadValue;
    }
@


1.6
log
@Previous shm fix for CVE-2007-6429 was incorrect.
Don't spuriously reject <8bpp shm pixmaps. From X.Org repository.
@
text
@a755 3
        /* thankfully, offset is unsigned */
        if (stuff->offset + size < size)
            return BadAlloc;
d757 3
a1100 3
	/* thankfully, offset is unsigned */
	if (stuff->offset + size < size)
	    return BadAlloc;
d1102 3
@


1.5
log
@Fix from X.Org for CVE-2007-6429 - MIT-SHM and EVI extensions integer overflows.
@
text
@a739 8
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4) {
        if (size < width * height)
            return BadAlloc;
        /* thankfully, offset is unsigned */
        if (stuff->offset + size < size)
            return BadAlloc;
    }
d750 1
d752 9
a1084 8
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4) {
	if (size < width * height)
	    return BadAlloc;
	/* thankfully, offset is unsigned */
	if (stuff->offset + size < size)
	    return BadAlloc;
    }
d1095 1
d1097 9
@


1.4
log
@merge xserver 1.4, 1st pass
@
text
@d714 2
d729 5
a733 1
    if (!stuff->width || !stuff->height)
d738 11
d759 1
a759 3
    VERIFY_SHMSIZE(shmdesc, stuff->offset,
		   PixmapBytePad(stuff->width, stuff->depth) * stuff->height,
		   client);
d1058 2
d1072 5
a1076 1
    if (!stuff->width || !stuff->height)
d1081 11
d1102 1
a1102 3
    VERIFY_SHMSIZE(shmdesc, stuff->offset,
		   PixmapBytePad(stuff->width, stuff->depth) * stuff->height,
		   client);
@


1.3
log
@Remove debugging code that was not supposed to leak in.
@
text
@a121 1
#ifdef PIXPRIV
a122 1
#endif
a237 1
#ifdef PIXPRIV
a244 1
#endif
a297 1
#ifdef PIXPRIV
a298 14
#else
	char	*base = (char *) pPixmap->devPrivate.ptr;
	
	if (base != (pointer) (pPixmap + 1))
	{
	    for (shmdesc = Shmsegs; shmdesc; shmdesc = shmdesc->next)
	    {
		if (shmdesc->addr <= base && base <= shmdesc->addr + shmdesc->size)
		    break;
	    }
	}
	else
	    shmdesc = 0;
#endif
d555 1
a555 1
                client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d559 1
a559 1
                client, stuff->gc, XRT_GC, SecurityReadAccess)))
d590 1
a590 1
    int         	i, x, y, w, h, format;
d605 1
a605 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d611 4
a614 1
    VERIFY_DRAWABLE(pDraw, stuff->drawable, client);
d647 6
a652 2
    for(i = 1; i < PanoramiXNumScreens; i++)
	VERIFY_DRAWABLE(drawables[i], draw->info[i].id, client);
d711 1
a711 1
    int i, j, result;
d721 5
a725 1
    VERIFY_GEOMETRABLE(pDraw, stuff->drawable, client);
a764 1
#ifdef PIXPRIV
a765 1
#endif
d798 2
a799 2
    register GCPtr pGC;
    register DrawablePtr pDraw;
d902 1
a902 1
    register DrawablePtr pDraw;
d907 1
a907 1
    int			n;
d917 4
a920 1
    VERIFY_DRAWABLE(pDraw, stuff->drawable, client);
d1038 1
a1038 1
    register DrawablePtr pDraw;
d1040 1
a1040 1
    register int i;
d1049 5
a1053 1
    VERIFY_GEOMETRABLE(pDraw, stuff->drawable, client);
a1078 1
#ifdef PIXPRIV
a1079 1
#endif
@


1.3.2.1
log
@Merging a bunch of security fixes from X.org

CVE-2007-5760 - XFree86 Misc extension out of bounds array index.
CVE-2007-5958 - File existence disclosure.
CVE-2007-6427 - Xinput extension memory corruption.
CVE-2007-6428 - TOG-cup extension memory corruption.
CVE-2007-6429 - MIT-SHM and EVI extensions integer overflows.
CVE-2008-0006 - PCF Font parser buffer overflow.
@
text
@a725 2
    unsigned int width, height, depth;
    unsigned long size;
d735 1
a735 5

    width = stuff->width;
    height = stuff->height;
    depth = stuff->depth;
    if (!width || !height || !depth)
a739 11
    if (width > 32767 || height > 32767)
        return BadAlloc;
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4) {
        if (size < width * height)
            return BadAlloc;
        /* thankfully, offset is unsigned */
        if (stuff->offset + size < size)
            return BadAlloc;
    }

d750 3
a752 1
    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);
a1049 2
    unsigned int width, height, depth;
    unsigned long size;
d1058 1
a1058 5
    
    width = stuff->width;
    height = stuff->height;
    depth = stuff->depth;
    if (!width || !height || !depth)
a1062 11
    if (width > 32767 || height > 32767)
	return BadAlloc;
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4) {
	if (size < width * height)
	    return BadAlloc;
	/* thankfully, offset is unsigned */
	if (stuff->offset + size < size)
	    return BadAlloc;
    }

d1073 3
a1075 1
    VERIFY_SHMSIZE(shmdesc, stuff->offset, size, client);
@


1.3.2.2
log
@merge the right fix
@
text
@d752 3
a755 3
    /* thankfully, offset is unsigned */
    if (stuff->offset + size < size)
	return BadAlloc;
d1090 3
a1093 3
    /* thankfully, offset is unsigned */
    if (stuff->offset + size < size)
	return BadAlloc;
@


1.3.2.3
log
@I goofed merging the patch. Thanks to Brad and Matthieu for finding/fixing this.
@
text
@d748 8
a765 1

a766 9
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {
        if (size < width * height)
            return BadAlloc;
    }
    /* thankfully, offset is unsigned */
    if (stuff->offset + size < size)
	return BadAlloc;

d1075 1
a1075 1

d1086 8
a1103 1

a1104 9
    size = PixmapBytePad(width, depth) * height;
    if (sizeof(size) == 4 && BitsPerPixel(depth) > 8) {
	if (size < width * height)
	    return BadAlloc;
    }
    /* thankfully, offset is unsigned */
    if (stuff->offset + size < size)
	return BadAlloc;

@


1.3.2.4
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@d861 2
a862 11
    /* 
     * There's a potential integer overflow in this check:
     * VERIFY_SHMSIZE(shmdesc, stuff->offset, length * stuff->totalHeight,
     *                client);
     * the version below ought to avoid it
     */
    if (stuff->totalHeight != 0 && 
	length > (shmdesc->size - stuff->offset)/stuff->totalHeight) {
	client->errorValue = stuff->totalWidth;
	return BadValue;
    }
@


1.2
log
@regen
@
text
@a435 1
	ErrorF("shmat %u\n", stuff->shmid);
a440 1
	    ErrorF("shmat fails shmid: %u\n", stuff->shmid);
@


1.1
log
@Initial revision
@
text
@d436 1
d442 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d122 1
d124 1
d240 1
d248 1
d302 1
d304 14
d574 1
a574 1
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d578 1
a578 1
                client, stuff->gc, XRT_GC, DixReadAccess)))
d609 1
a609 1
    int         	i, x, y, w, h, format, rc;
d624 1
a624 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d630 1
a630 4
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixUnknownAccess);
    if (rc != Success)
	return rc;
d663 2
a664 6
    for(i = 1; i < PanoramiXNumScreens; i++) {
	rc = dixLookupDrawable(drawables+i, draw->info[i].id, client, 0, 
			       DixUnknownAccess);
	if (rc != Success)
	    return rc;
    }
d723 1
a723 1
    int i, j, result, rc;
d733 1
a733 5
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
			   DixUnknownAccess);
    if (rc != Success)
	return rc;

d773 1
d775 1
d808 2
a809 2
    GCPtr pGC;
    DrawablePtr pDraw;
d912 1
a912 1
    DrawablePtr		pDraw;
d917 1
a917 1
    int			n, rc;
d927 1
a927 4
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixUnknownAccess);
    if (rc != Success)
	return rc;
d1045 1
a1045 1
    DrawablePtr pDraw;
d1047 1
a1047 1
    register int i, rc;
d1056 1
a1056 5
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, M_ANY,
			   DixUnknownAccess);
    if (rc != Success)
	return rc;

d1082 1
d1084 1
@

