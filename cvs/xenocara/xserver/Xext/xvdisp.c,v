head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.2.0.6
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	Te1daavkBLskZ8gc;

1.12
date	2014.12.09.17.58.52;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	vcnjRBuLQw44cPHf;

1.11
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.46;	author matthieu;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.12.18.16.08.59;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.51;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.51;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.58;	author matthieu;	state Exp;
branches;
next	;

1.9.4.1
date	2014.12.09.18.00.12;	author matthieu;	state Exp;
branches;
next	;
commitid	xg6qoZmMsIovdaEA;

1.10.2.1
date	2014.12.09.17.59.32;	author matthieu;	state Exp;
branches;
next	;
commitid	TlkXlepp8erAnwcR;


desc
@@


1.13
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/***********************************************************
Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "gcstruct.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"

#include <X11/extensions/Xv.h>
#include <X11/extensions/Xvproto.h>
#include "xvdix.h"
#ifdef MITSHM
#include <X11/extensions/shmproto.h>
#include "shmint.h"
#endif

#include "xvdisp.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"

unsigned long XvXRTPort;
#endif

static int
SWriteQueryExtensionReply(ClientPtr client, xvQueryExtensionReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swaps(&rep->version);
    swaps(&rep->revision);

    WriteToClient(client, sz_xvQueryExtensionReply, rep);

    return Success;
}

static int
SWriteQueryAdaptorsReply(ClientPtr client, xvQueryAdaptorsReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swaps(&rep->num_adaptors);

    WriteToClient(client, sz_xvQueryAdaptorsReply, rep);

    return Success;
}

static int
SWriteQueryEncodingsReply(ClientPtr client, xvQueryEncodingsReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swaps(&rep->num_encodings);

    WriteToClient(client, sz_xvQueryEncodingsReply, rep);

    return Success;
}

static int
SWriteAdaptorInfo(ClientPtr client, xvAdaptorInfo * pAdaptor)
{
    swapl(&pAdaptor->base_id);
    swaps(&pAdaptor->name_size);
    swaps(&pAdaptor->num_ports);
    swaps(&pAdaptor->num_formats);

    WriteToClient(client, sz_xvAdaptorInfo, pAdaptor);

    return Success;
}

static int
SWriteEncodingInfo(ClientPtr client, xvEncodingInfo * pEncoding)
{

    swapl(&pEncoding->encoding);
    swaps(&pEncoding->name_size);
    swaps(&pEncoding->width);
    swaps(&pEncoding->height);
    swapl(&pEncoding->rate.numerator);
    swapl(&pEncoding->rate.denominator);
    WriteToClient(client, sz_xvEncodingInfo, pEncoding);

    return Success;
}

static int
SWriteFormat(ClientPtr client, xvFormat * pFormat)
{
    swapl(&pFormat->visual);
    WriteToClient(client, sz_xvFormat, pFormat);

    return Success;
}

static int
SWriteAttributeInfo(ClientPtr client, xvAttributeInfo * pAtt)
{
    swapl(&pAtt->flags);
    swapl(&pAtt->size);
    swapl(&pAtt->min);
    swapl(&pAtt->max);
    WriteToClient(client, sz_xvAttributeInfo, pAtt);

    return Success;
}

static int
SWriteImageFormatInfo(ClientPtr client, xvImageFormatInfo * pImage)
{
    swapl(&pImage->id);
    swapl(&pImage->red_mask);
    swapl(&pImage->green_mask);
    swapl(&pImage->blue_mask);
    swapl(&pImage->y_sample_bits);
    swapl(&pImage->u_sample_bits);
    swapl(&pImage->v_sample_bits);
    swapl(&pImage->horz_y_period);
    swapl(&pImage->horz_u_period);
    swapl(&pImage->horz_v_period);
    swapl(&pImage->vert_y_period);
    swapl(&pImage->vert_u_period);
    swapl(&pImage->vert_v_period);

    WriteToClient(client, sz_xvImageFormatInfo, pImage);

    return Success;
}

static int
SWriteGrabPortReply(ClientPtr client, xvGrabPortReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);

    WriteToClient(client, sz_xvGrabPortReply, rep);

    return Success;
}

static int
SWriteGetPortAttributeReply(ClientPtr client, xvGetPortAttributeReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swapl(&rep->value);

    WriteToClient(client, sz_xvGetPortAttributeReply, rep);

    return Success;
}

static int
SWriteQueryBestSizeReply(ClientPtr client, xvQueryBestSizeReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swaps(&rep->actual_width);
    swaps(&rep->actual_height);

    WriteToClient(client, sz_xvQueryBestSizeReply, rep);

    return Success;
}

static int
SWriteQueryPortAttributesReply(ClientPtr client,
                               xvQueryPortAttributesReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swapl(&rep->num_attributes);
    swapl(&rep->text_size);

    WriteToClient(client, sz_xvQueryPortAttributesReply, rep);

    return Success;
}

static int
SWriteQueryImageAttributesReply(ClientPtr client,
                                xvQueryImageAttributesReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swapl(&rep->num_planes);
    swapl(&rep->data_size);
    swaps(&rep->width);
    swaps(&rep->height);

    WriteToClient(client, sz_xvQueryImageAttributesReply, rep);

    return Success;
}

static int
SWriteListImageFormatsReply(ClientPtr client, xvListImageFormatsReply * rep)
{
    swaps(&rep->sequenceNumber);
    swapl(&rep->length);
    swapl(&rep->num_formats);

    WriteToClient(client, sz_xvListImageFormatsReply, rep);

    return Success;
}

#define _WriteQueryAdaptorsReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryAdaptorsReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryAdaptorsReply, _d)

#define _WriteQueryExtensionReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryExtensionReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryExtensionReply, _d)

#define _WriteQueryEncodingsReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryEncodingsReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryEncodingsReply, _d)

#define _WriteAdaptorInfo(_c,_d) \
  if ((_c)->swapped) SWriteAdaptorInfo(_c, _d); \
  else WriteToClient(_c, sz_xvAdaptorInfo, _d)

#define _WriteAttributeInfo(_c,_d) \
  if ((_c)->swapped) SWriteAttributeInfo(_c, _d); \
  else WriteToClient(_c, sz_xvAttributeInfo, _d)

#define _WriteEncodingInfo(_c,_d) \
  if ((_c)->swapped) SWriteEncodingInfo(_c, _d); \
  else WriteToClient(_c, sz_xvEncodingInfo, _d)

#define _WriteFormat(_c,_d) \
  if ((_c)->swapped) SWriteFormat(_c, _d); \
  else WriteToClient(_c, sz_xvFormat, _d)

#define _WriteGrabPortReply(_c,_d) \
  if ((_c)->swapped) SWriteGrabPortReply(_c, _d); \
  else WriteToClient(_c, sz_xvGrabPortReply, _d)

#define _WriteGetPortAttributeReply(_c,_d) \
  if ((_c)->swapped) SWriteGetPortAttributeReply(_c, _d); \
  else WriteToClient(_c, sz_xvGetPortAttributeReply, _d)

#define _WriteQueryBestSizeReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryBestSizeReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryBestSizeReply, _d)

#define _WriteQueryPortAttributesReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryPortAttributesReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryPortAttributesReply, _d)

#define _WriteQueryImageAttributesReply(_c,_d) \
  if ((_c)->swapped) SWriteQueryImageAttributesReply(_c, _d); \
  else WriteToClient(_c, sz_xvQueryImageAttributesReply, _d)

#define _WriteListImageFormatsReply(_c,_d) \
  if ((_c)->swapped) SWriteListImageFormatsReply(_c, _d); \
  else WriteToClient(_c, sz_xvListImageFormatsReply, _d)

#define _WriteImageFormatInfo(_c,_d) \
  if ((_c)->swapped) SWriteImageFormatInfo(_c, _d); \
  else WriteToClient(_c, sz_xvImageFormatInfo, _d)

static int
ProcXvQueryExtension(ClientPtr client)
{
    xvQueryExtensionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .version = XvVersion,
        .revision = XvRevision
    };

    /* REQUEST(xvQueryExtensionReq); */
    REQUEST_SIZE_MATCH(xvQueryExtensionReq);

    _WriteQueryExtensionReply(client, &rep);

    return Success;
}

static int
ProcXvQueryAdaptors(ClientPtr client)
{
    xvFormat format;
    xvAdaptorInfo ainfo;
    xvQueryAdaptorsReply rep;
    int totalSize, na, nf, rc;
    int nameSize;
    XvAdaptorPtr pa;
    XvFormatPtr pf;
    WindowPtr pWin;
    ScreenPtr pScreen;
    XvScreenPtr pxvs;

    REQUEST(xvQueryAdaptorsReq);
    REQUEST_SIZE_MATCH(xvQueryAdaptorsReq);

    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    pScreen = pWin->drawable.pScreen;
    pxvs = (XvScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                          XvGetScreenKey());
    if (!pxvs) {
        rep = (xvQueryAdaptorsReply) {
            .type = X_Reply,
            .sequenceNumber = client->sequence,
            .length = 0,
            .num_adaptors = 0
        };

        _WriteQueryAdaptorsReply(client, &rep);

        return Success;
    }

    rep = (xvQueryAdaptorsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .num_adaptors = pxvs->nAdaptors
    };

    /* CALCULATE THE TOTAL SIZE OF THE REPLY IN BYTES */

    totalSize = pxvs->nAdaptors * sz_xvAdaptorInfo;

    /* FOR EACH ADPATOR ADD UP THE BYTES FOR ENCODINGS AND FORMATS */

    na = pxvs->nAdaptors;
    pa = pxvs->pAdaptors;
    while (na--) {
        totalSize += pad_to_int32(strlen(pa->name));
        totalSize += pa->nFormats * sz_xvFormat;
        pa++;
    }

    rep.length = bytes_to_int32(totalSize);

    _WriteQueryAdaptorsReply(client, &rep);

    na = pxvs->nAdaptors;
    pa = pxvs->pAdaptors;
    while (na--) {

        ainfo.base_id = pa->base_id;
        ainfo.num_ports = pa->nPorts;
        ainfo.type = pa->type;
        ainfo.name_size = nameSize = strlen(pa->name);
        ainfo.num_formats = pa->nFormats;

        _WriteAdaptorInfo(client, &ainfo);

        WriteToClient(client, nameSize, pa->name);

        nf = pa->nFormats;
        pf = pa->pFormats;
        while (nf--) {
            format.depth = pf->depth;
            format.visual = pf->visual;
            _WriteFormat(client, &format);
            pf++;
        }

        pa++;

    }

    return Success;
}

static int
ProcXvQueryEncodings(ClientPtr client)
{
    xvEncodingInfo einfo;
    xvQueryEncodingsReply rep;
    int totalSize;
    int nameSize;
    XvPortPtr pPort;
    int ne;
    XvEncodingPtr pe;

    REQUEST(xvQueryEncodingsReq);
    REQUEST_SIZE_MATCH(xvQueryEncodingsReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    rep = (xvQueryEncodingsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .num_encodings = pPort->pAdaptor->nEncodings
    };

    /* FOR EACH ENCODING ADD UP THE BYTES FOR ENCODING NAMES */

    ne = pPort->pAdaptor->nEncodings;
    pe = pPort->pAdaptor->pEncodings;
    totalSize = ne * sz_xvEncodingInfo;
    while (ne--) {
        totalSize += pad_to_int32(strlen(pe->name));
        pe++;
    }

    rep.length = bytes_to_int32(totalSize);

    _WriteQueryEncodingsReply(client, &rep);

    ne = pPort->pAdaptor->nEncodings;
    pe = pPort->pAdaptor->pEncodings;
    while (ne--) {
        einfo.encoding = pe->id;
        einfo.name_size = nameSize = strlen(pe->name);
        einfo.width = pe->width;
        einfo.height = pe->height;
        einfo.rate.numerator = pe->rate.numerator;
        einfo.rate.denominator = pe->rate.denominator;
        _WriteEncodingInfo(client, &einfo);
        WriteToClient(client, nameSize, pe->name);
        pe++;
    }

    return Success;
}

static int
ProcXvPutVideo(ClientPtr client)
{
    DrawablePtr pDraw;
    XvPortPtr pPort;
    GCPtr pGC;
    int status;

    REQUEST(xvPutVideoReq);
    REQUEST_SIZE_MATCH(xvPutVideoReq);

    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    if (!(pPort->pAdaptor->type & XvInputMask) ||
        !(pPort->pAdaptor->type & XvVideoMask)) {
        client->errorValue = stuff->port;
        return BadMatch;
    }

    status = XvdiMatchPort(pPort, pDraw);
    if (status != Success) {
        return status;
    }

    return XvdiPutVideo(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
                        stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
                        stuff->drw_w, stuff->drw_h);
}

static int
ProcXvPutStill(ClientPtr client)
{
    DrawablePtr pDraw;
    XvPortPtr pPort;
    GCPtr pGC;
    int status;

    REQUEST(xvPutStillReq);
    REQUEST_SIZE_MATCH(xvPutStillReq);

    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    if (!(pPort->pAdaptor->type & XvInputMask) ||
        !(pPort->pAdaptor->type & XvStillMask)) {
        client->errorValue = stuff->port;
        return BadMatch;
    }

    status = XvdiMatchPort(pPort, pDraw);
    if (status != Success) {
        return status;
    }

    return XvdiPutStill(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
                        stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
                        stuff->drw_w, stuff->drw_h);
}

static int
ProcXvGetVideo(ClientPtr client)
{
    DrawablePtr pDraw;
    XvPortPtr pPort;
    GCPtr pGC;
    int status;

    REQUEST(xvGetVideoReq);
    REQUEST_SIZE_MATCH(xvGetVideoReq);

    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixReadAccess);
    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    if (!(pPort->pAdaptor->type & XvOutputMask) ||
        !(pPort->pAdaptor->type & XvVideoMask)) {
        client->errorValue = stuff->port;
        return BadMatch;
    }

    status = XvdiMatchPort(pPort, pDraw);
    if (status != Success) {
        return status;
    }

    return XvdiGetVideo(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
                        stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
                        stuff->drw_w, stuff->drw_h);
}

static int
ProcXvGetStill(ClientPtr client)
{
    DrawablePtr pDraw;
    XvPortPtr pPort;
    GCPtr pGC;
    int status;

    REQUEST(xvGetStillReq);
    REQUEST_SIZE_MATCH(xvGetStillReq);

    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixReadAccess);
    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    if (!(pPort->pAdaptor->type & XvOutputMask) ||
        !(pPort->pAdaptor->type & XvStillMask)) {
        client->errorValue = stuff->port;
        return BadMatch;
    }

    status = XvdiMatchPort(pPort, pDraw);
    if (status != Success) {
        return status;
    }

    return XvdiGetStill(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
                        stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
                        stuff->drw_w, stuff->drw_h);
}

static int
ProcXvSelectVideoNotify(ClientPtr client)
{
    DrawablePtr pDraw;
    int rc;

    REQUEST(xvSelectVideoNotifyReq);
    REQUEST_SIZE_MATCH(xvSelectVideoNotifyReq);

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
                           DixReceiveAccess);
    if (rc != Success)
        return rc;

    return XvdiSelectVideoNotify(client, pDraw, stuff->onoff);
}

static int
ProcXvSelectPortNotify(ClientPtr client)
{
    XvPortPtr pPort;

    REQUEST(xvSelectPortNotifyReq);
    REQUEST_SIZE_MATCH(xvSelectPortNotifyReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    return XvdiSelectPortNotify(client, pPort, stuff->onoff);
}

static int
ProcXvGrabPort(ClientPtr client)
{
    int result, status;
    XvPortPtr pPort;
    xvGrabPortReply rep;

    REQUEST(xvGrabPortReq);
    REQUEST_SIZE_MATCH(xvGrabPortReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    status = XvdiGrabPort(client, pPort, stuff->time, &result);

    if (status != Success) {
        return status;
    }
    rep = (xvGrabPortReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .result = result
    };

    _WriteGrabPortReply(client, &rep);

    return Success;
}

static int
ProcXvUngrabPort(ClientPtr client)
{
    XvPortPtr pPort;

    REQUEST(xvGrabPortReq);
    REQUEST_SIZE_MATCH(xvGrabPortReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    return XvdiUngrabPort(client, pPort, stuff->time);
}

static int
ProcXvStopVideo(ClientPtr client)
{
    int ret;
    DrawablePtr pDraw;
    XvPortPtr pPort;

    REQUEST(xvStopVideoReq);
    REQUEST_SIZE_MATCH(xvStopVideoReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    ret = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixWriteAccess);
    if (ret != Success)
        return ret;

    return XvdiStopVideo(client, pPort, pDraw);
}

static int
ProcXvSetPortAttribute(ClientPtr client)
{
    int status;
    XvPortPtr pPort;

    REQUEST(xvSetPortAttributeReq);
    REQUEST_SIZE_MATCH(xvSetPortAttributeReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixSetAttrAccess);

    if (!ValidAtom(stuff->attribute)) {
        client->errorValue = stuff->attribute;
        return BadAtom;
    }

    status =
        XvdiSetPortAttribute(client, pPort, stuff->attribute, stuff->value);

    if (status == BadMatch)
        client->errorValue = stuff->attribute;
    else
        client->errorValue = stuff->value;

    return status;
}

static int
ProcXvGetPortAttribute(ClientPtr client)
{
    INT32 value;
    int status;
    XvPortPtr pPort;
    xvGetPortAttributeReply rep;

    REQUEST(xvGetPortAttributeReq);
    REQUEST_SIZE_MATCH(xvGetPortAttributeReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixGetAttrAccess);

    if (!ValidAtom(stuff->attribute)) {
        client->errorValue = stuff->attribute;
        return BadAtom;
    }

    status = XvdiGetPortAttribute(client, pPort, stuff->attribute, &value);
    if (status != Success) {
        client->errorValue = stuff->attribute;
        return status;
    }

    rep = (xvGetPortAttributeReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .value = value
    };

    _WriteGetPortAttributeReply(client, &rep);

    return Success;
}

static int
ProcXvQueryBestSize(ClientPtr client)
{
    unsigned int actual_width, actual_height;
    XvPortPtr pPort;
    xvQueryBestSizeReply rep;

    REQUEST(xvQueryBestSizeReq);
    REQUEST_SIZE_MATCH(xvQueryBestSizeReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    (*pPort->pAdaptor->ddQueryBestSize) (pPort, stuff->motion,
                                         stuff->vid_w, stuff->vid_h,
                                         stuff->drw_w, stuff->drw_h,
                                         &actual_width, &actual_height);

    rep = (xvQueryBestSizeReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .actual_width = actual_width,
        .actual_height = actual_height
    };

    _WriteQueryBestSizeReply(client, &rep);

    return Success;
}

static int
ProcXvQueryPortAttributes(ClientPtr client)
{
    int size, i;
    XvPortPtr pPort;
    XvAttributePtr pAtt;
    xvQueryPortAttributesReply rep;
    xvAttributeInfo Info;

    REQUEST(xvQueryPortAttributesReq);
    REQUEST_SIZE_MATCH(xvQueryPortAttributesReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixGetAttrAccess);

    rep = (xvQueryPortAttributesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .num_attributes = pPort->pAdaptor->nAttributes,
        .text_size = 0
    };

    for (i = 0, pAtt = pPort->pAdaptor->pAttributes;
         i < pPort->pAdaptor->nAttributes; i++, pAtt++) {
        rep.text_size += pad_to_int32(strlen(pAtt->name) + 1);
    }

    rep.length = (pPort->pAdaptor->nAttributes * sz_xvAttributeInfo)
        + rep.text_size;
    rep.length >>= 2;

    _WriteQueryPortAttributesReply(client, &rep);

    for (i = 0, pAtt = pPort->pAdaptor->pAttributes;
         i < pPort->pAdaptor->nAttributes; i++, pAtt++) {
        size = strlen(pAtt->name) + 1;  /* pass the NULL */
        Info.flags = pAtt->flags;
        Info.min = pAtt->min_value;
        Info.max = pAtt->max_value;
        Info.size = pad_to_int32(size);

        _WriteAttributeInfo(client, &Info);

        WriteToClient(client, size, pAtt->name);
    }

    return Success;
}

static int
ProcXvPutImage(ClientPtr client)
{
    DrawablePtr pDraw;
    XvPortPtr pPort;
    XvImagePtr pImage = NULL;
    GCPtr pGC;
    int status, i, size;
    CARD16 width, height;

    REQUEST(xvPutImageReq);
    REQUEST_AT_LEAST_SIZE(xvPutImageReq);

    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    if (!(pPort->pAdaptor->type & XvImageMask) ||
        !(pPort->pAdaptor->type & XvInputMask)) {
        client->errorValue = stuff->port;
        return BadMatch;
    }

    status = XvdiMatchPort(pPort, pDraw);
    if (status != Success) {
        return status;
    }

    for (i = 0; i < pPort->pAdaptor->nImages; i++) {
        if (pPort->pAdaptor->pImages[i].id == stuff->id) {
            pImage = &(pPort->pAdaptor->pImages[i]);
            break;
        }
    }

    if (!pImage)
        return BadMatch;

    width = stuff->width;
    height = stuff->height;
    size = (*pPort->pAdaptor->ddQueryImageAttributes) (pPort, pImage, &width,
                                                       &height, NULL, NULL);
    size += sizeof(xvPutImageReq);
    size = bytes_to_int32(size);

    if ((width < stuff->width) || (height < stuff->height))
        return BadValue;

    if (client->req_len < size)
        return BadLength;

    return XvdiPutImage(client, pDraw, pPort, pGC, stuff->src_x, stuff->src_y,
                        stuff->src_w, stuff->src_h, stuff->drw_x, stuff->drw_y,
                        stuff->drw_w, stuff->drw_h, pImage,
                        (unsigned char *) (&stuff[1]), FALSE,
                        stuff->width, stuff->height);
}

#ifdef MITSHM

static int
ProcXvShmPutImage(ClientPtr client)
{
    ShmDescPtr shmdesc;
    DrawablePtr pDraw;
    XvPortPtr pPort;
    XvImagePtr pImage = NULL;
    GCPtr pGC;
    int status, size_needed, i;
    CARD16 width, height;

    REQUEST(xvShmPutImageReq);
    REQUEST_SIZE_MATCH(xvShmPutImageReq);

    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    if (!(pPort->pAdaptor->type & XvImageMask) ||
        !(pPort->pAdaptor->type & XvInputMask)) {
        client->errorValue = stuff->port;
        return BadMatch;
    }

    status = XvdiMatchPort(pPort, pDraw);
    if (status != Success) {
        return status;
    }

    for (i = 0; i < pPort->pAdaptor->nImages; i++) {
        if (pPort->pAdaptor->pImages[i].id == stuff->id) {
            pImage = &(pPort->pAdaptor->pImages[i]);
            break;
        }
    }

    if (!pImage)
        return BadMatch;

    status = dixLookupResourceByType((void **) &shmdesc, stuff->shmseg,
                                     ShmSegType, serverClient, DixReadAccess);
    if (status != Success)
        return status;

    width = stuff->width;
    height = stuff->height;
    size_needed = (*pPort->pAdaptor->ddQueryImageAttributes) (pPort, pImage,
                                                              &width, &height,
                                                              NULL, NULL);
    if ((size_needed + stuff->offset) > shmdesc->size)
        return BadAccess;

    if ((width < stuff->width) || (height < stuff->height))
        return BadValue;

    status = XvdiPutImage(client, pDraw, pPort, pGC, stuff->src_x, stuff->src_y,
                          stuff->src_w, stuff->src_h, stuff->drw_x,
                          stuff->drw_y, stuff->drw_w, stuff->drw_h, pImage,
                          (unsigned char *) shmdesc->addr + stuff->offset,
                          stuff->send_event, stuff->width, stuff->height);

    if ((status == Success) && stuff->send_event) {
        xShmCompletionEvent ev = {
            .type = ShmCompletionCode,
            .drawable = stuff->drawable,
            .minorEvent = xv_ShmPutImage,
            .majorEvent = XvReqCode,
            .shmseg = stuff->shmseg,
            .offset = stuff->offset
        };
        WriteEventsToClient(client, 1, (xEvent *) &ev);
    }

    return status;
}
#else                           /* !MITSHM */
static int
ProcXvShmPutImage(ClientPtr client)
{
    SendErrorToClient(client, XvReqCode, xv_ShmPutImage, 0, BadImplementation);
    return BadImplementation;
}
#endif

#ifdef XvMCExtension
#include "xvmcext.h"
#endif

static int
ProcXvQueryImageAttributes(ClientPtr client)
{
    xvQueryImageAttributesReply rep;
    int size, num_planes, i;
    CARD16 width, height;
    XvImagePtr pImage = NULL;
    XvPortPtr pPort;
    int *offsets;
    int *pitches;
    int planeLength;

    REQUEST(xvQueryImageAttributesReq);

    REQUEST_SIZE_MATCH(xvQueryImageAttributesReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    for (i = 0; i < pPort->pAdaptor->nImages; i++) {
        if (pPort->pAdaptor->pImages[i].id == stuff->id) {
            pImage = &(pPort->pAdaptor->pImages[i]);
            break;
        }
    }

#ifdef XvMCExtension
    if (!pImage)
        pImage = XvMCFindXvImage(pPort, stuff->id);
#endif

    if (!pImage)
        return BadMatch;

    num_planes = pImage->num_planes;

    if (!(offsets = malloc(num_planes << 3)))
        return BadAlloc;
    pitches = offsets + num_planes;

    width = stuff->width;
    height = stuff->height;

    size = (*pPort->pAdaptor->ddQueryImageAttributes) (pPort, pImage,
                                                       &width, &height, offsets,
                                                       pitches);

    rep = (xvQueryImageAttributesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = planeLength = num_planes << 1,
        .num_planes = num_planes,
        .width = width,
        .height = height,
        .data_size = size
    };

    _WriteQueryImageAttributesReply(client, &rep);
    if (client->swapped)
        SwapLongs((CARD32 *) offsets, planeLength);
    WriteToClient(client, planeLength << 2, offsets);

    free(offsets);

    return Success;
}

static int
ProcXvListImageFormats(ClientPtr client)
{
    XvPortPtr pPort;
    XvImagePtr pImage;
    int i;
    xvListImageFormatsReply rep;
    xvImageFormatInfo info;

    REQUEST(xvListImageFormatsReq);

    REQUEST_SIZE_MATCH(xvListImageFormatsReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    rep = (xvListImageFormatsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .num_formats = pPort->pAdaptor->nImages,
        .length =
            bytes_to_int32(pPort->pAdaptor->nImages * sz_xvImageFormatInfo)
    };

    _WriteListImageFormatsReply(client, &rep);

    pImage = pPort->pAdaptor->pImages;

    for (i = 0; i < pPort->pAdaptor->nImages; i++, pImage++) {
        info.id = pImage->id;
        info.type = pImage->type;
        info.byte_order = pImage->byte_order;
        memcpy(&info.guid, pImage->guid, 16);
        info.bpp = pImage->bits_per_pixel;
        info.num_planes = pImage->num_planes;
        info.depth = pImage->depth;
        info.red_mask = pImage->red_mask;
        info.green_mask = pImage->green_mask;
        info.blue_mask = pImage->blue_mask;
        info.format = pImage->format;
        info.y_sample_bits = pImage->y_sample_bits;
        info.u_sample_bits = pImage->u_sample_bits;
        info.v_sample_bits = pImage->v_sample_bits;
        info.horz_y_period = pImage->horz_y_period;
        info.horz_u_period = pImage->horz_u_period;
        info.horz_v_period = pImage->horz_v_period;
        info.vert_y_period = pImage->vert_y_period;
        info.vert_u_period = pImage->vert_u_period;
        info.vert_v_period = pImage->vert_v_period;
        memcpy(&info.comp_order, pImage->component_order, 32);
        info.scanline_order = pImage->scanline_order;
        _WriteImageFormatInfo(client, &info);
    }

    return Success;
}

static int (*XvProcVector[xvNumRequests]) (ClientPtr) = {
ProcXvQueryExtension,
        ProcXvQueryAdaptors,
        ProcXvQueryEncodings,
        ProcXvGrabPort,
        ProcXvUngrabPort,
        ProcXvPutVideo,
        ProcXvPutStill,
        ProcXvGetVideo,
        ProcXvGetStill,
        ProcXvStopVideo,
        ProcXvSelectVideoNotify,
        ProcXvSelectPortNotify,
        ProcXvQueryBestSize,
        ProcXvSetPortAttribute,
        ProcXvGetPortAttribute,
        ProcXvQueryPortAttributes,
        ProcXvListImageFormats,
        ProcXvQueryImageAttributes, ProcXvPutImage, ProcXvShmPutImage,};

int
ProcXvDispatch(ClientPtr client)
{
    REQUEST(xReq);

    UpdateCurrentTime();

    if (stuff->data >= xvNumRequests) {
        SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
        return BadRequest;
    }

    return XvProcVector[stuff->data] (client);
}

/* Swapped Procs */

static int
SProcXvQueryExtension(ClientPtr client)
{
    REQUEST(xvQueryExtensionReq);
    REQUEST_SIZE_MATCH(xvQueryExtensionReq);
    swaps(&stuff->length);
    return XvProcVector[xv_QueryExtension] (client);
}

static int
SProcXvQueryAdaptors(ClientPtr client)
{
    REQUEST(xvQueryAdaptorsReq);
    REQUEST_SIZE_MATCH(xvQueryAdaptorsReq);
    swaps(&stuff->length);
    swapl(&stuff->window);
    return XvProcVector[xv_QueryAdaptors] (client);
}

static int
SProcXvQueryEncodings(ClientPtr client)
{
    REQUEST(xvQueryEncodingsReq);
    REQUEST_SIZE_MATCH(xvQueryEncodingsReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    return XvProcVector[xv_QueryEncodings] (client);
}

static int
SProcXvGrabPort(ClientPtr client)
{
    REQUEST(xvGrabPortReq);
    REQUEST_SIZE_MATCH(xvGrabPortReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->time);
    return XvProcVector[xv_GrabPort] (client);
}

static int
SProcXvUngrabPort(ClientPtr client)
{
    REQUEST(xvUngrabPortReq);
    REQUEST_SIZE_MATCH(xvUngrabPortReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->time);
    return XvProcVector[xv_UngrabPort] (client);
}

static int
SProcXvPutVideo(ClientPtr client)
{
    REQUEST(xvPutVideoReq);
    REQUEST_SIZE_MATCH(xvPutVideoReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->drawable);
    swapl(&stuff->gc);
    swaps(&stuff->vid_x);
    swaps(&stuff->vid_y);
    swaps(&stuff->vid_w);
    swaps(&stuff->vid_h);
    swaps(&stuff->drw_x);
    swaps(&stuff->drw_y);
    swaps(&stuff->drw_w);
    swaps(&stuff->drw_h);
    return XvProcVector[xv_PutVideo] (client);
}

static int
SProcXvPutStill(ClientPtr client)
{
    REQUEST(xvPutStillReq);
    REQUEST_SIZE_MATCH(xvPutStillReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->drawable);
    swapl(&stuff->gc);
    swaps(&stuff->vid_x);
    swaps(&stuff->vid_y);
    swaps(&stuff->vid_w);
    swaps(&stuff->vid_h);
    swaps(&stuff->drw_x);
    swaps(&stuff->drw_y);
    swaps(&stuff->drw_w);
    swaps(&stuff->drw_h);
    return XvProcVector[xv_PutStill] (client);
}

static int
SProcXvGetVideo(ClientPtr client)
{
    REQUEST(xvGetVideoReq);
    REQUEST_SIZE_MATCH(xvGetVideoReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->drawable);
    swapl(&stuff->gc);
    swaps(&stuff->vid_x);
    swaps(&stuff->vid_y);
    swaps(&stuff->vid_w);
    swaps(&stuff->vid_h);
    swaps(&stuff->drw_x);
    swaps(&stuff->drw_y);
    swaps(&stuff->drw_w);
    swaps(&stuff->drw_h);
    return XvProcVector[xv_GetVideo] (client);
}

static int
SProcXvGetStill(ClientPtr client)
{
    REQUEST(xvGetStillReq);
    REQUEST_SIZE_MATCH(xvGetStillReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->drawable);
    swapl(&stuff->gc);
    swaps(&stuff->vid_x);
    swaps(&stuff->vid_y);
    swaps(&stuff->vid_w);
    swaps(&stuff->vid_h);
    swaps(&stuff->drw_x);
    swaps(&stuff->drw_y);
    swaps(&stuff->drw_w);
    swaps(&stuff->drw_h);
    return XvProcVector[xv_GetStill] (client);
}

static int
SProcXvPutImage(ClientPtr client)
{
    REQUEST(xvPutImageReq);
    REQUEST_AT_LEAST_SIZE(xvPutImageReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->drawable);
    swapl(&stuff->gc);
    swapl(&stuff->id);
    swaps(&stuff->src_x);
    swaps(&stuff->src_y);
    swaps(&stuff->src_w);
    swaps(&stuff->src_h);
    swaps(&stuff->drw_x);
    swaps(&stuff->drw_y);
    swaps(&stuff->drw_w);
    swaps(&stuff->drw_h);
    swaps(&stuff->width);
    swaps(&stuff->height);
    return XvProcVector[xv_PutImage] (client);
}

#ifdef MITSHM
static int
SProcXvShmPutImage(ClientPtr client)
{
    REQUEST(xvShmPutImageReq);
    REQUEST_SIZE_MATCH(xvShmPutImageReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->drawable);
    swapl(&stuff->gc);
    swapl(&stuff->shmseg);
    swapl(&stuff->id);
    swapl(&stuff->offset);
    swaps(&stuff->src_x);
    swaps(&stuff->src_y);
    swaps(&stuff->src_w);
    swaps(&stuff->src_h);
    swaps(&stuff->drw_x);
    swaps(&stuff->drw_y);
    swaps(&stuff->drw_w);
    swaps(&stuff->drw_h);
    swaps(&stuff->width);
    swaps(&stuff->height);
    return XvProcVector[xv_ShmPutImage] (client);
}
#else                           /* MITSHM */
#define SProcXvShmPutImage ProcXvShmPutImage
#endif

static int
SProcXvSelectVideoNotify(ClientPtr client)
{
    REQUEST(xvSelectVideoNotifyReq);
    REQUEST_SIZE_MATCH(xvSelectVideoNotifyReq);
    swaps(&stuff->length);
    swapl(&stuff->drawable);
    return XvProcVector[xv_SelectVideoNotify] (client);
}

static int
SProcXvSelectPortNotify(ClientPtr client)
{
    REQUEST(xvSelectPortNotifyReq);
    REQUEST_SIZE_MATCH(xvSelectPortNotifyReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    return XvProcVector[xv_SelectPortNotify] (client);
}

static int
SProcXvStopVideo(ClientPtr client)
{
    REQUEST(xvStopVideoReq);
    REQUEST_SIZE_MATCH(xvStopVideoReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->drawable);
    return XvProcVector[xv_StopVideo] (client);
}

static int
SProcXvSetPortAttribute(ClientPtr client)
{
    REQUEST(xvSetPortAttributeReq);
    REQUEST_SIZE_MATCH(xvSetPortAttributeReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->attribute);
    swapl(&stuff->value);
    return XvProcVector[xv_SetPortAttribute] (client);
}

static int
SProcXvGetPortAttribute(ClientPtr client)
{
    REQUEST(xvGetPortAttributeReq);
    REQUEST_SIZE_MATCH(xvGetPortAttributeReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->attribute);
    return XvProcVector[xv_GetPortAttribute] (client);
}

static int
SProcXvQueryBestSize(ClientPtr client)
{
    REQUEST(xvQueryBestSizeReq);
    REQUEST_SIZE_MATCH(xvQueryBestSizeReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swaps(&stuff->vid_w);
    swaps(&stuff->vid_h);
    swaps(&stuff->drw_w);
    swaps(&stuff->drw_h);
    return XvProcVector[xv_QueryBestSize] (client);
}

static int
SProcXvQueryPortAttributes(ClientPtr client)
{
    REQUEST(xvQueryPortAttributesReq);
    REQUEST_SIZE_MATCH(xvQueryPortAttributesReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    return XvProcVector[xv_QueryPortAttributes] (client);
}

static int
SProcXvQueryImageAttributes(ClientPtr client)
{
    REQUEST(xvQueryImageAttributesReq);
    REQUEST_SIZE_MATCH(xvQueryImageAttributesReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    swapl(&stuff->id);
    swaps(&stuff->width);
    swaps(&stuff->height);
    return XvProcVector[xv_QueryImageAttributes] (client);
}

static int
SProcXvListImageFormats(ClientPtr client)
{
    REQUEST(xvListImageFormatsReq);
    REQUEST_SIZE_MATCH(xvListImageFormatsReq);
    swaps(&stuff->length);
    swapl(&stuff->port);
    return XvProcVector[xv_ListImageFormats] (client);
}

static int (*SXvProcVector[xvNumRequests]) (ClientPtr) = {
SProcXvQueryExtension,
        SProcXvQueryAdaptors,
        SProcXvQueryEncodings,
        SProcXvGrabPort,
        SProcXvUngrabPort,
        SProcXvPutVideo,
        SProcXvPutStill,
        SProcXvGetVideo,
        SProcXvGetStill,
        SProcXvStopVideo,
        SProcXvSelectVideoNotify,
        SProcXvSelectPortNotify,
        SProcXvQueryBestSize,
        SProcXvSetPortAttribute,
        SProcXvGetPortAttribute,
        SProcXvQueryPortAttributes,
        SProcXvListImageFormats,
        SProcXvQueryImageAttributes, SProcXvPutImage, SProcXvShmPutImage,};

int
SProcXvDispatch(ClientPtr client)
{
    REQUEST(xReq);

    UpdateCurrentTime();

    if (stuff->data >= xvNumRequests) {
        SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
        return BadRequest;
    }

    return SXvProcVector[stuff->data] (client);
}

#ifdef PANORAMIX
static int
XineramaXvStopVideo(ClientPtr client)
{
    int result, i;
    PanoramiXRes *draw, *port;

    REQUEST(xvStopVideoReq);
    REQUEST_SIZE_MATCH(xvStopVideoReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((void **) &port, stuff->port,
                                     XvXRTPort, client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(i) {
        if (port->info[i].id) {
            stuff->drawable = draw->info[i].id;
            stuff->port = port->info[i].id;
            result = ProcXvStopVideo(client);
        }
    }

    return result;
}

static int
XineramaXvSetPortAttribute(ClientPtr client)
{
    REQUEST(xvSetPortAttributeReq);
    PanoramiXRes *port;
    int result, i;

    REQUEST_SIZE_MATCH(xvSetPortAttributeReq);

    result = dixLookupResourceByType((void **) &port, stuff->port,
                                     XvXRTPort, client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(i) {
        if (port->info[i].id) {
            stuff->port = port->info[i].id;
            result = ProcXvSetPortAttribute(client);
        }
    }
    return result;
}

#ifdef MITSHM
static int
XineramaXvShmPutImage(ClientPtr client)
{
    REQUEST(xvShmPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool send_event = stuff->send_event;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_SIZE_MATCH(xvShmPutImageReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((void **) &gc, stuff->gc,
                                     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((void **) &port, stuff->port,
                                     XvXRTPort, client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
        if (port->info[i].id) {
            stuff->drawable = draw->info[i].id;
            stuff->port = port->info[i].id;
            stuff->gc = gc->info[i].id;
            stuff->drw_x = x;
            stuff->drw_y = y;
            if (isRoot) {
                stuff->drw_x -= screenInfo.screens[i]->x;
                stuff->drw_y -= screenInfo.screens[i]->y;
            }
            stuff->send_event = (send_event && !i) ? 1 : 0;

            result = ProcXvShmPutImage(client);
        }
    }
    return result;
}
#else
#define XineramaXvShmPutImage ProcXvShmPutImage
#endif

static int
XineramaXvPutImage(ClientPtr client)
{
    REQUEST(xvPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_AT_LEAST_SIZE(xvPutImageReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((void **) &gc, stuff->gc,
                                     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((void **) &port, stuff->port,
                                     XvXRTPort, client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
        if (port->info[i].id) {
            stuff->drawable = draw->info[i].id;
            stuff->port = port->info[i].id;
            stuff->gc = gc->info[i].id;
            stuff->drw_x = x;
            stuff->drw_y = y;
            if (isRoot) {
                stuff->drw_x -= screenInfo.screens[i]->x;
                stuff->drw_y -= screenInfo.screens[i]->y;
            }

            result = ProcXvPutImage(client);
        }
    }
    return result;
}

static int
XineramaXvPutVideo(ClientPtr client)
{
    REQUEST(xvPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_AT_LEAST_SIZE(xvPutVideoReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((void **) &gc, stuff->gc,
                                     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((void **) &port, stuff->port,
                                     XvXRTPort, client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
        if (port->info[i].id) {
            stuff->drawable = draw->info[i].id;
            stuff->port = port->info[i].id;
            stuff->gc = gc->info[i].id;
            stuff->drw_x = x;
            stuff->drw_y = y;
            if (isRoot) {
                stuff->drw_x -= screenInfo.screens[i]->x;
                stuff->drw_y -= screenInfo.screens[i]->y;
            }

            result = ProcXvPutVideo(client);
        }
    }
    return result;
}

static int
XineramaXvPutStill(ClientPtr client)
{
    REQUEST(xvPutImageReq);
    PanoramiXRes *draw, *gc, *port;
    Bool isRoot;
    int result, i, x, y;

    REQUEST_AT_LEAST_SIZE(xvPutImageReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    result = dixLookupResourceByType((void **) &gc, stuff->gc,
                                     XRT_GC, client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((void **) &port, stuff->port,
                                     XvXRTPort, client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

    x = stuff->drw_x;
    y = stuff->drw_y;

    FOR_NSCREENS_BACKWARD(i) {
        if (port->info[i].id) {
            stuff->drawable = draw->info[i].id;
            stuff->port = port->info[i].id;
            stuff->gc = gc->info[i].id;
            stuff->drw_x = x;
            stuff->drw_y = y;
            if (isRoot) {
                stuff->drw_x -= screenInfo.screens[i]->x;
                stuff->drw_y -= screenInfo.screens[i]->y;
            }

            result = ProcXvPutStill(client);
        }
    }
    return result;
}

static Bool
isImageAdaptor(XvAdaptorPtr pAdapt)
{
    return (pAdapt->type & XvImageMask) && (pAdapt->nImages > 0);
}

static Bool
hasOverlay(XvAdaptorPtr pAdapt)
{
    int i;

    for (i = 0; i < pAdapt->nAttributes; i++)
        if (!strcmp(pAdapt->pAttributes[i].name, "XV_COLORKEY"))
            return TRUE;
    return FALSE;
}

static XvAdaptorPtr
matchAdaptor(ScreenPtr pScreen, XvAdaptorPtr refAdapt, Bool isOverlay)
{
    int i;
    XvScreenPtr xvsp =
        dixLookupPrivate(&pScreen->devPrivates, XvGetScreenKey());
    /* Do not try to go on if xv is not supported on this screen */
    if (xvsp == NULL)
        return NULL;

    /* if the adaptor has the same name it's a perfect match */
    for (i = 0; i < xvsp->nAdaptors; i++) {
        XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;

        if (!strcmp(refAdapt->name, pAdapt->name))
            return pAdapt;
    }

    /* otherwise we only look for XvImage adaptors */
    if (!isImageAdaptor(refAdapt))
        return NULL;

    /* prefer overlay/overlay non-overlay/non-overlay pairing */
    for (i = 0; i < xvsp->nAdaptors; i++) {
        XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;

        if (isImageAdaptor(pAdapt) && isOverlay == hasOverlay(pAdapt))
            return pAdapt;
    }

    /* but we'll take any XvImage pairing if we can get it */
    for (i = 0; i < xvsp->nAdaptors; i++) {
        XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;

        if (isImageAdaptor(pAdapt))
            return pAdapt;
    }
    return NULL;
}

void
XineramifyXv(void)
{
    XvScreenPtr xvsp0 =
        dixLookupPrivate(&screenInfo.screens[0]->devPrivates, XvGetScreenKey());
    XvAdaptorPtr MatchingAdaptors[MAXSCREENS];
    int i, j, k;

    XvXRTPort = CreateNewResourceType(XineramaDeleteResource, "XvXRTPort");

    if (!xvsp0 || !XvXRTPort)
        return;
    SetResourceTypeErrorValue(XvXRTPort, _XvBadPort);

    for (i = 0; i < xvsp0->nAdaptors; i++) {
        Bool isOverlay;
        XvAdaptorPtr refAdapt = xvsp0->pAdaptors + i;

        if (!(refAdapt->type & XvInputMask))
            continue;

        MatchingAdaptors[0] = refAdapt;
        isOverlay = hasOverlay(refAdapt);
        FOR_NSCREENS_FORWARD_SKIP(j)
            MatchingAdaptors[j] =
            matchAdaptor(screenInfo.screens[j], refAdapt, isOverlay);

        /* now create a resource for each port */
        for (j = 0; j < refAdapt->nPorts; j++) {
            PanoramiXRes *port = malloc(sizeof(PanoramiXRes));

            if (!port)
                break;

            FOR_NSCREENS(k) {
                if (MatchingAdaptors[k] && (MatchingAdaptors[k]->nPorts > j))
                    port->info[k].id = MatchingAdaptors[k]->base_id + j;
                else
                    port->info[k].id = 0;
            }
            AddResource(port->info[0].id, XvXRTPort, port);
        }
    }

    /* munge the dispatch vector */
    XvProcVector[xv_PutVideo] = XineramaXvPutVideo;
    XvProcVector[xv_PutStill] = XineramaXvPutStill;
    XvProcVector[xv_StopVideo] = XineramaXvStopVideo;
    XvProcVector[xv_SetPortAttribute] = XineramaXvSetPortAttribute;
    XvProcVector[xv_PutImage] = XineramaXvPutImage;
    XvProcVector[xv_ShmPutImage] = XineramaXvShmPutImage;
}
#endif                          /* PANORAMIX */

void
XvResetProcVector(void)
{
#ifdef PANORAMIX
    XvProcVector[xv_PutVideo] = ProcXvPutVideo;
    XvProcVector[xv_PutStill] = ProcXvPutStill;
    XvProcVector[xv_StopVideo] = ProcXvStopVideo;
    XvProcVector[xv_SetPortAttribute] = ProcXvSetPortAttribute;
    XvProcVector[xv_PutImage] = ProcXvPutImage;
    XvProcVector[xv_ShmPutImage] = ProcXvShmPutImage;
#endif
}
@


1.12
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@d7 2
a8 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d10 1
a10 1
both that copyright notice and this permission notice appear in 
d13 1
a13 1
software without specific, written prior permission.  
a299 3
#define _AllocatePort(_i,_p) \
  ((_p)->id != _i) ? (* (_p)->pAdaptor->ddAllocatePort)(_i,_p,&_p) : Success

a355 2
    (*pxvs->ddQueryAdaptors) (pScreen, &pxvs->pAdaptors, &pxvs->nAdaptors);

a419 1
    int status;
a425 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a476 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a506 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a536 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a566 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a602 1
    int status;
a609 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a624 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a644 1
    int status;
a651 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

d658 1
a658 1
    int status, ret;
a666 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a684 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a713 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a739 1
    int status;
d749 1
a749 6
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

    (*pPort->pAdaptor->ddQueryBestSize) (client, pPort, stuff->motion,
d770 1
a770 1
    int status, size, i;
a780 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

a830 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

d854 1
a854 2
    size = (*pPort->pAdaptor->ddQueryImageAttributes) (client,
                                                       pPort, pImage, &width,
a890 5
    if ((status = _AllocatePort(stuff->port, pPort)) != Success) {
        client->errorValue = stuff->port;
        return status;
    }

d919 1
a919 2
    size_needed = (*pPort->pAdaptor->ddQueryImageAttributes) (client,
                                                              pPort, pImage,
d1003 1
a1003 1
    size = (*pPort->pAdaptor->ddQueryImageAttributes) (client, pPort, pImage,
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1210 1
d1219 1
d1229 1
d1239 1
d1250 1
d1261 1
d1281 1
d1301 1
d1321 1
d1341 1
d1365 1
d1393 1
d1403 1
d1413 1
d1424 1
d1436 1
d1447 1
d1461 1
d1471 1
d1484 1
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d997 1
a997 1
    status = dixLookupResourceByType((pointer *) &shmdesc, stuff->shmseg,
d1515 1
a1515 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1520 1
a1520 1
    result = dixLookupResourceByType((pointer *) &port, stuff->port,
d1545 1
a1545 1
    result = dixLookupResourceByType((pointer *) &port, stuff->port,
d1571 1
a1571 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1576 1
a1576 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc,
d1581 1
a1581 1
    result = dixLookupResourceByType((pointer *) &port, stuff->port,
d1623 1
a1623 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1628 1
a1628 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc,
d1633 1
a1633 1
    result = dixLookupResourceByType((pointer *) &port, stuff->port,
d1671 1
a1671 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1676 1
a1676 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc,
d1681 1
a1681 1
    result = dixLookupResourceByType((pointer *) &port, stuff->port,
d1719 1
a1719 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1724 1
a1724 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc,
d1729 1
a1729 1
    result = dixLookupResourceByType((pointer *) &port, stuff->port,
@


1.10.2.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a1209 1
    REQUEST_SIZE_MATCH(xvQueryExtensionReq);
a1217 1
    REQUEST_SIZE_MATCH(xvQueryAdaptorsReq);
a1226 1
    REQUEST_SIZE_MATCH(xvQueryEncodingsReq);
a1235 1
    REQUEST_SIZE_MATCH(xvGrabPortReq);
a1245 1
    REQUEST_SIZE_MATCH(xvUngrabPortReq);
a1255 1
    REQUEST_SIZE_MATCH(xvPutVideoReq);
a1274 1
    REQUEST_SIZE_MATCH(xvPutStillReq);
a1293 1
    REQUEST_SIZE_MATCH(xvGetVideoReq);
a1312 1
    REQUEST_SIZE_MATCH(xvGetStillReq);
a1331 1
    REQUEST_AT_LEAST_SIZE(xvPutImageReq);
a1354 1
    REQUEST_SIZE_MATCH(xvShmPutImageReq);
a1381 1
    REQUEST_SIZE_MATCH(xvSelectVideoNotifyReq);
a1390 1
    REQUEST_SIZE_MATCH(xvSelectPortNotifyReq);
a1399 1
    REQUEST_SIZE_MATCH(xvStopVideoReq);
a1409 1
    REQUEST_SIZE_MATCH(xvSetPortAttributeReq);
a1420 1
    REQUEST_SIZE_MATCH(xvGetPortAttributeReq);
a1430 1
    REQUEST_SIZE_MATCH(xvQueryBestSizeReq);
a1443 1
    REQUEST_SIZE_MATCH(xvQueryPortAttributesReq);
a1452 1
    REQUEST_SIZE_MATCH(xvQueryImageAttributesReq);
a1464 1
    REQUEST_SIZE_MATCH(xvListImageFormatsReq);
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d46 1
d706 1
a706 1
    int status, rc;
d720 3
a722 3
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixWriteAccess);
    if (rc != Success)
        return rc;
a952 12
/* redefined here since it's not in any header file */
typedef struct _ShmDesc {
    struct _ShmDesc *next;
    int shmid;
    int refcnt;
    char *addr;
    Bool writable;
    unsigned long size;
} ShmDescRec, *ShmDescPtr;

extern RESTYPE ShmSegType;
extern int ShmCompletionCode;
@


1.9.4.1
log
@Protocol handling issues in X Window System servers
One year after Ilja van Sprundel, discovered and reported a large number
of issues in the way the X server code base handles requests from X clients,
they have been fixed.
@
text
@a1220 1
    REQUEST_SIZE_MATCH(xvQueryExtensionReq);
a1228 1
    REQUEST_SIZE_MATCH(xvQueryAdaptorsReq);
a1237 1
    REQUEST_SIZE_MATCH(xvQueryEncodingsReq);
a1246 1
    REQUEST_SIZE_MATCH(xvGrabPortReq);
a1256 1
    REQUEST_SIZE_MATCH(xvUngrabPortReq);
a1266 1
    REQUEST_SIZE_MATCH(xvPutVideoReq);
a1285 1
    REQUEST_SIZE_MATCH(xvPutStillReq);
a1304 1
    REQUEST_SIZE_MATCH(xvGetVideoReq);
a1323 1
    REQUEST_SIZE_MATCH(xvGetStillReq);
a1342 1
    REQUEST_AT_LEAST_SIZE(xvPutImageReq);
a1365 1
    REQUEST_SIZE_MATCH(xvShmPutImageReq);
a1392 1
    REQUEST_SIZE_MATCH(xvSelectVideoNotifyReq);
a1401 1
    REQUEST_SIZE_MATCH(xvSelectPortNotifyReq);
a1410 1
    REQUEST_SIZE_MATCH(xvStopVideoReq);
a1420 1
    REQUEST_SIZE_MATCH(xvSetPortAttributeReq);
a1431 1
    REQUEST_SIZE_MATCH(xvGetPortAttributeReq);
a1441 1
    REQUEST_SIZE_MATCH(xvQueryBestSizeReq);
a1454 1
    REQUEST_SIZE_MATCH(xvQueryPortAttributesReq);
a1463 1
    REQUEST_SIZE_MATCH(xvQueryImageAttributesReq);
a1475 1
    REQUEST_SIZE_MATCH(xvListImageFormatsReq);
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d65 1
a65 1
    (void) WriteToClient(client, sz_xvQueryExtensionReply, (char *) rep);
d77 1
a77 1
    (void) WriteToClient(client, sz_xvQueryAdaptorsReply, (char *) rep);
d89 1
a89 1
    (void) WriteToClient(client, sz_xvQueryEncodingsReply, (char *) rep);
d102 1
a102 1
    (void) WriteToClient(client, sz_xvAdaptorInfo, (char *) pAdaptor);
d117 1
a117 1
    (void) WriteToClient(client, sz_xvEncodingInfo, (char *) pEncoding);
d126 1
a126 1
    (void) WriteToClient(client, sz_xvFormat, (char *) pFormat);
d138 1
a138 1
    (void) WriteToClient(client, sz_xvAttributeInfo, (char *) pAtt);
d160 1
a160 1
    (void) WriteToClient(client, sz_xvImageFormatInfo, (char *) pImage);
d171 1
a171 1
    (void) WriteToClient(client, sz_xvGrabPortReply, (char *) rep);
d183 1
a183 1
    (void) WriteToClient(client, sz_xvGetPortAttributeReply, (char *) rep);
d196 1
a196 1
    (void) WriteToClient(client, sz_xvQueryBestSizeReply, (char *) rep);
d210 1
a210 1
    (void) WriteToClient(client, sz_xvQueryPortAttributesReply, (char *) rep);
d226 1
a226 1
    (void) WriteToClient(client, sz_xvQueryImageAttributesReply, (char *) rep);
d238 1
a238 1
    (void) WriteToClient(client, sz_xvListImageFormatsReply, (char *) rep);
d245 1
a245 1
  else WriteToClient(_c, sz_xvQueryAdaptorsReply, (char*)_d)
d249 1
a249 1
  else WriteToClient(_c, sz_xvQueryExtensionReply, (char*)_d)
d253 1
a253 1
  else WriteToClient(_c, sz_xvQueryEncodingsReply, (char*)_d)
d257 1
a257 1
  else WriteToClient(_c, sz_xvAdaptorInfo, (char*)_d)
d261 1
a261 1
  else WriteToClient(_c, sz_xvAttributeInfo, (char*)_d)
d265 1
a265 1
  else WriteToClient(_c, sz_xvEncodingInfo, (char*)_d)
d269 1
a269 1
  else WriteToClient(_c, sz_xvFormat, (char*)_d)
d273 1
a273 1
  else WriteToClient(_c, sz_xvGrabPortReply, (char*)_d)
d277 1
a277 1
  else WriteToClient(_c, sz_xvGetPortAttributeReply, (char*)_d)
d281 1
a281 1
  else WriteToClient(_c, sz_xvQueryBestSizeReply,(char*) _d)
d285 1
a285 1
  else WriteToClient(_c, sz_xvQueryPortAttributesReply,(char*) _d)
d289 1
a289 1
  else WriteToClient(_c, sz_xvQueryImageAttributesReply,(char*) _d)
d293 1
a293 1
  else WriteToClient(_c, sz_xvListImageFormatsReply,(char*) _d)
d297 1
a297 1
  else WriteToClient(_c, sz_xvImageFormatInfo, (char*)_d)
d305 7
a311 1
    xvQueryExtensionReply rep;
a315 6
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.version = XvVersion;
    rep.revision = XvRevision;

d346 6
a351 4
        rep.type = X_Reply;
        rep.sequenceNumber = client->sequence;
        rep.num_adaptors = 0;
        rep.length = 0;
d360 5
a364 3
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num_adaptors = pxvs->nAdaptors;
d436 5
a440 3
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num_encodings = pPort->pAdaptor->nEncodings;
d671 6
a676 5

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.result = result;
d787 6
a792 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.value = value;
a816 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;

d822 7
a828 2
    rep.actual_width = actual_width;
    rep.actual_height = actual_height;
d854 6
a859 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num_attributes = pPort->pAdaptor->nAttributes;
    rep.text_size = 0;
d1032 8
a1039 8
        xShmCompletionEvent ev;

        ev.type = ShmCompletionCode;
        ev.drawable = stuff->drawable;
        ev.minorEvent = xv_ShmPutImage;
        ev.majorEvent = XvReqCode;
        ev.shmseg = stuff->shmseg;
        ev.offset = stuff->offset;
d1104 9
a1112 7
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = planeLength = num_planes << 1;
    rep.num_planes = num_planes;
    rep.width = width;
    rep.height = height;
    rep.data_size = size;
d1117 1
a1117 1
    WriteToClient(client, planeLength << 2, (char *) offsets);
d1139 7
a1145 5
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num_formats = pPort->pAdaptor->nImages;
    rep.length =
        bytes_to_int32(pPort->pAdaptor->nImages * sz_xvImageFormatInfo);
@


1.7
log
@Bugfix Update to xserver 1.11.3
@
text
@d58 6
a63 5
SWriteQueryExtensionReply(
   ClientPtr client,
   xvQueryExtensionReply *rep
){
  char n;
d65 1
a65 6
  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->version, n);
  swaps(&rep->revision, n);
  
  (void)WriteToClient(client, sz_xvQueryExtensionReply, (char *)rep);
d67 1
a67 1
  return Success;
d71 5
a75 5
SWriteQueryAdaptorsReply(
   ClientPtr client,
   xvQueryAdaptorsReply *rep
){
  char n;
d77 1
a77 5
  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->num_adaptors, n);
  
  (void)WriteToClient(client, sz_xvQueryAdaptorsReply, (char *)rep);
d79 1
a79 1
  return Success;
d83 5
a87 5
SWriteQueryEncodingsReply(
   ClientPtr client,
   xvQueryEncodingsReply *rep
){
  char n;
d89 1
a89 5
  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->num_encodings, n);
  
  (void)WriteToClient(client, sz_xvQueryEncodingsReply, (char *)rep);
d91 1
a91 1
  return Success;
d95 6
a100 10
SWriteAdaptorInfo(
   ClientPtr client,
   xvAdaptorInfo *pAdaptor
){
  char n;

  swapl(&pAdaptor->base_id, n);
  swaps(&pAdaptor->name_size, n);
  swaps(&pAdaptor->num_ports, n);
  swaps(&pAdaptor->num_formats, n);
d102 1
a102 1
  (void)WriteToClient(client, sz_xvAdaptorInfo, (char *)pAdaptor);
d104 1
a104 1
  return Success;
d108 10
a117 13
SWriteEncodingInfo(
   ClientPtr client,
   xvEncodingInfo *pEncoding
){
  char n;
  
  swapl(&pEncoding->encoding, n);
  swaps(&pEncoding->name_size, n);
  swaps(&pEncoding->width, n);
  swaps(&pEncoding->height, n);
  swapl(&pEncoding->rate.numerator, n);
  swapl(&pEncoding->rate.denominator, n);
  (void)WriteToClient(client, sz_xvEncodingInfo, (char *)pEncoding);
d119 1
a119 1
  return Success;
d123 4
a126 5
SWriteFormat(
   ClientPtr client,
   xvFormat *pFormat
){
  char n;
d128 1
a128 4
  swapl(&pFormat->visual, n);
  (void)WriteToClient(client, sz_xvFormat, (char *)pFormat);

  return Success;
d132 7
a138 5
SWriteAttributeInfo(
   ClientPtr client,
   xvAttributeInfo *pAtt
){
  char n;
d140 1
a140 7
  swapl(&pAtt->flags, n);
  swapl(&pAtt->size, n);
  swapl(&pAtt->min, n);
  swapl(&pAtt->max, n);
  (void)WriteToClient(client, sz_xvAttributeInfo, (char *)pAtt);

  return Success;
d144 15
a158 19
SWriteImageFormatInfo(
   ClientPtr client,
   xvImageFormatInfo *pImage
){
  char n;

  swapl(&pImage->id, n);
  swapl(&pImage->red_mask, n);
  swapl(&pImage->green_mask, n);
  swapl(&pImage->blue_mask, n);
  swapl(&pImage->y_sample_bits, n);
  swapl(&pImage->u_sample_bits, n);
  swapl(&pImage->v_sample_bits, n);
  swapl(&pImage->horz_y_period, n);
  swapl(&pImage->horz_u_period, n);
  swapl(&pImage->horz_v_period, n);
  swapl(&pImage->vert_y_period, n);
  swapl(&pImage->vert_u_period, n);
  swapl(&pImage->vert_v_period, n);
d160 1
a160 1
  (void)WriteToClient(client, sz_xvImageFormatInfo, (char *)pImage);
d162 1
a162 1
  return Success;
d166 4
a169 8
SWriteGrabPortReply(
   ClientPtr client,
   xvGrabPortReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
d171 1
a171 1
  (void)WriteToClient(client, sz_xvGrabPortReply, (char *)rep);
d173 1
a173 1
  return Success;
d177 5
a181 9
SWriteGetPortAttributeReply(
   ClientPtr client,
   xvGetPortAttributeReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->value, n);
d183 1
a183 1
  (void)WriteToClient(client, sz_xvGetPortAttributeReply, (char *)rep);
d185 1
a185 1
  return Success;
d189 6
a194 10
SWriteQueryBestSizeReply(
   ClientPtr client,
   xvQueryBestSizeReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->actual_width, n);
  swaps(&rep->actual_height, n);
d196 1
a196 1
  (void)WriteToClient(client, sz_xvQueryBestSizeReply, (char *)rep);
d198 1
a198 1
  return Success;
d202 7
a208 10
SWriteQueryPortAttributesReply(
   ClientPtr client,
   xvQueryPortAttributesReply *rep
){
  char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_attributes, n);
  swapl(&rep->text_size, n);
d210 1
a210 1
  (void)WriteToClient(client, sz_xvQueryPortAttributesReply, (char *)rep);
d212 1
a212 1
  return Success;
d216 9
a224 5
SWriteQueryImageAttributesReply(
   ClientPtr client,
   xvQueryImageAttributesReply *rep
){
  char n;
d226 1
a226 6
  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_planes, n);
  swapl(&rep->data_size, n);
  swaps(&rep->width, n);
  swaps(&rep->height, n);
d228 1
a228 3
  (void)WriteToClient(client, sz_xvQueryImageAttributesReply, (char *)rep);

  return Success;
d232 5
a236 5
SWriteListImageFormatsReply(
   ClientPtr client,
   xvListImageFormatsReply *rep
){
  char n;
d238 1
a238 3
  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_formats, n);
d240 1
a240 3
  (void)WriteToClient(client, sz_xvListImageFormatsReply, (char *)rep);

  return Success;
d305 4
a308 9
  xvQueryExtensionReply rep;
  /* REQUEST(xvQueryExtensionReq); */
  REQUEST_SIZE_MATCH(xvQueryExtensionReq);

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;
  rep.version = XvVersion;
  rep.revision = XvRevision;
d310 5
a314 1
  _WriteQueryExtensionReply(client, &rep);
d316 3
a318 1
  return Success;
d324 10
a333 10
  xvFormat format;
  xvAdaptorInfo ainfo;
  xvQueryAdaptorsReply rep;
  int totalSize, na, nf, rc;
  int nameSize;
  XvAdaptorPtr pa;
  XvFormatPtr pf;
  WindowPtr pWin;
  ScreenPtr pScreen;
  XvScreenPtr pxvs;
d335 2
a336 2
  REQUEST(xvQueryAdaptorsReq);
  REQUEST_SIZE_MATCH(xvQueryAdaptorsReq);
d338 3
a340 3
  rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
  if (rc != Success)
      return rc;
d342 8
a349 9
  pScreen = pWin->drawable.pScreen;
  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
				       XvGetScreenKey());
  if (!pxvs)
    {
      rep.type = X_Reply;
      rep.sequenceNumber = client->sequence;
      rep.num_adaptors = 0;
      rep.length = 0;
d351 1
a351 1
      _WriteQueryAdaptorsReply(client, &rep);
d353 1
a353 1
      return Success;
d356 1
a356 1
  (* pxvs->ddQueryAdaptors)(pScreen, &pxvs->pAdaptors, &pxvs->nAdaptors);
d358 3
a360 3
  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_adaptors = pxvs->nAdaptors;
d362 1
a362 1
  /* CALCULATE THE TOTAL SIZE OF THE REPLY IN BYTES */
d364 1
a364 1
  totalSize = pxvs->nAdaptors * sz_xvAdaptorInfo;
d366 1
a366 1
  /* FOR EACH ADPATOR ADD UP THE BYTES FOR ENCODINGS AND FORMATS */
d368 6
a373 7
  na = pxvs->nAdaptors;
  pa = pxvs->pAdaptors;
  while (na--)
    {
      totalSize += pad_to_int32(strlen(pa->name));
      totalSize += pa->nFormats * sz_xvFormat;
      pa++;
d376 1
a376 1
  rep.length = bytes_to_int32(totalSize);
d378 1
a378 1
  _WriteQueryAdaptorsReply(client, &rep);
d380 3
a382 4
  na = pxvs->nAdaptors;
  pa = pxvs->pAdaptors;
  while (na--)
    {
d384 5
a388 5
      ainfo.base_id = pa->base_id;
      ainfo.num_ports = pa->nPorts;
      ainfo.type = pa->type;
      ainfo.name_size = nameSize = strlen(pa->name);
      ainfo.num_formats = pa->nFormats;
d390 1
a390 1
      _WriteAdaptorInfo(client, &ainfo);
d392 1
a392 1
      WriteToClient(client, nameSize, pa->name);
d394 8
a401 9
      nf = pa->nFormats;
      pf = pa->pFormats;
      while (nf--)
	{
	  format.depth = pf->depth;
	  format.visual = pf->visual;
	  _WriteFormat(client, &format);
	  pf++;
	}
d403 1
a403 1
      pa++;
d407 1
a407 1
  return Success;
d413 49
a461 52
  xvEncodingInfo einfo;
  xvQueryEncodingsReply rep;
  int totalSize;
  int nameSize;
  XvPortPtr pPort;
  int ne;
  XvEncodingPtr pe;
  int status;

  REQUEST(xvQueryEncodingsReq);
  REQUEST_SIZE_MATCH(xvQueryEncodingsReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_encodings = pPort->pAdaptor->nEncodings;

  /* FOR EACH ENCODING ADD UP THE BYTES FOR ENCODING NAMES */

  ne = pPort->pAdaptor->nEncodings;
  pe = pPort->pAdaptor->pEncodings;
  totalSize = ne * sz_xvEncodingInfo;
  while (ne--)
    {
      totalSize += pad_to_int32(strlen(pe->name));
      pe++;
    }

  rep.length = bytes_to_int32(totalSize);

  _WriteQueryEncodingsReply(client, &rep);

  ne = pPort->pAdaptor->nEncodings;
  pe = pPort->pAdaptor->pEncodings;
  while (ne--) 
    {
      einfo.encoding = pe->id;
      einfo.name_size = nameSize = strlen(pe->name);
      einfo.width = pe->width;
      einfo.height = pe->height;
      einfo.rate.numerator = pe->rate.numerator;
      einfo.rate.denominator = pe->rate.denominator;
      _WriteEncodingInfo(client, &einfo);
      WriteToClient(client, nameSize, pe->name);
      pe++;
d464 1
a464 1
  return Success;
d470 4
a473 4
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;
d475 2
a476 2
  REQUEST(xvPutVideoReq);
  REQUEST_SIZE_MATCH(xvPutVideoReq);
d478 2
a479 2
  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
d481 3
a483 4
  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
d486 4
a489 5
  if (!(pPort->pAdaptor->type & XvInputMask) ||
	!(pPort->pAdaptor->type & XvVideoMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
d492 3
a494 4
  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
d497 3
a499 3
  return XvdiPutVideo(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
d505 4
a508 4
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;
d510 2
a511 2
  REQUEST(xvPutStillReq);
  REQUEST_SIZE_MATCH(xvPutStillReq);
d513 2
a514 2
  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
d516 3
a518 4
  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
d521 4
a524 5
  if (!(pPort->pAdaptor->type & XvInputMask) ||
	!(pPort->pAdaptor->type & XvStillMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
d527 3
a529 4
  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
d532 3
a534 3
  return XvdiPutStill(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
d540 4
a543 4
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;
d545 2
a546 2
  REQUEST(xvGetVideoReq);
  REQUEST_SIZE_MATCH(xvGetVideoReq);
d548 2
a549 2
  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixReadAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
d551 3
a553 4
  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
d556 4
a559 5
  if (!(pPort->pAdaptor->type & XvOutputMask) ||
	!(pPort->pAdaptor->type & XvVideoMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
d562 3
a564 4
  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
d567 3
a569 3
  return XvdiGetVideo(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
d575 4
a578 4
  DrawablePtr pDraw;
  XvPortPtr pPort;
  GCPtr pGC;
  int status;
d580 2
a581 2
  REQUEST(xvGetStillReq);
  REQUEST_SIZE_MATCH(xvGetStillReq);
d583 2
a584 2
  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixReadAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
d586 3
a588 4
  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
d591 4
a594 5
  if (!(pPort->pAdaptor->type & XvOutputMask) ||
	!(pPort->pAdaptor->type & XvStillMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
d597 3
a599 4
  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
d602 3
a604 3
  return XvdiGetStill(client, pDraw, pPort, pGC, stuff->vid_x, stuff->vid_y,
		      stuff->vid_w, stuff->vid_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h);
d610 2
a611 8
  DrawablePtr pDraw;
  int rc;
  REQUEST(xvSelectVideoNotifyReq);
  REQUEST_SIZE_MATCH(xvSelectVideoNotifyReq);

  rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixReceiveAccess);
  if (rc != Success)
    return rc;
d613 9
a621 1
  return XvdiSelectVideoNotify(client, pDraw, stuff->onoff);
d627 5
a631 4
  int status;
  XvPortPtr pPort;
  REQUEST(xvSelectPortNotifyReq);
  REQUEST_SIZE_MATCH(xvSelectPortNotifyReq);
d633 1
a633 1
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
d635 3
a637 4
  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
d640 1
a640 1
  return XvdiSelectPortNotify(client, pPort, stuff->onoff);
d646 3
a648 5
  int result, status;
  XvPortPtr pPort;
  xvGrabPortReply rep;
  REQUEST(xvGrabPortReq);
  REQUEST_SIZE_MATCH(xvGrabPortReq);
d650 2
a651 1
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
d653 5
a657 4
  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
d660 1
a660 1
  status = XvdiGrabPort(client, pPort, stuff->time, &result);
d662 2
a663 3
  if (status != Success)
    {
      return status;
d666 4
a669 4
  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;
  rep.result = result;
d671 1
a671 1
  _WriteGrabPortReply(client, &rep);
d673 1
a673 1
  return Success;
d679 5
a683 4
  int status;
  XvPortPtr pPort;
  REQUEST(xvGrabPortReq);
  REQUEST_SIZE_MATCH(xvGrabPortReq);
d685 1
a685 1
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
d687 3
a689 4
  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
d692 1
a692 1
  return XvdiUngrabPort(client, pPort, stuff->time);
d698 3
a700 5
  int status, rc;
  DrawablePtr pDraw;
  XvPortPtr pPort;
  REQUEST(xvStopVideoReq);
  REQUEST_SIZE_MATCH(xvStopVideoReq);
d702 2
a703 1
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
d705 5
a709 4
  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
d712 3
a714 3
  rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixWriteAccess);
  if (rc != Success)
    return rc;
d716 1
a716 1
  return XvdiStopVideo(client, pPort, pDraw);
d722 5
a726 4
  int status;
  XvPortPtr pPort;
  REQUEST(xvSetPortAttributeReq);
  REQUEST_SIZE_MATCH(xvSetPortAttributeReq);
d728 1
a728 1
  VALIDATE_XV_PORT(stuff->port, pPort, DixSetAttrAccess);
d730 3
a732 4
  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
d735 3
a737 4
  if (!ValidAtom(stuff->attribute))
    {
      client->errorValue = stuff->attribute;
      return BadAtom;
d740 2
a741 1
  status = XvdiSetPortAttribute(client, pPort, stuff->attribute, stuff->value);
d743 4
a746 4
  if (status == BadMatch) 
      client->errorValue = stuff->attribute;
  else
      client->errorValue = stuff->value;
d748 1
a748 1
  return status;
d754 4
a757 34
  INT32 value;
  int status;
  XvPortPtr pPort;
  xvGetPortAttributeReply rep;
  REQUEST(xvGetPortAttributeReq);
  REQUEST_SIZE_MATCH(xvGetPortAttributeReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixGetAttrAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!ValidAtom(stuff->attribute))
    {
      client->errorValue = stuff->attribute;
      return BadAtom;
    }

  status = XvdiGetPortAttribute(client, pPort, stuff->attribute, &value);
  if (status != Success)
    {
      client->errorValue = stuff->attribute;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;
  rep.value = value;
 
  _WriteGetPortAttributeReply(client, &rep);
d759 29
a787 1
  return Success;
d793 28
a820 28
  int status;
  unsigned int actual_width, actual_height;
  XvPortPtr pPort;
  xvQueryBestSizeReply rep;
  REQUEST(xvQueryBestSizeReq);
  REQUEST_SIZE_MATCH(xvQueryBestSizeReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = 0;

  (* pPort->pAdaptor->ddQueryBestSize)(client, pPort, stuff->motion,
				       stuff->vid_w, stuff->vid_h, 
				       stuff->drw_w, stuff->drw_h, 
				       &actual_width, &actual_height);

  rep.actual_width = actual_width;
  rep.actual_height = actual_height;
 
  _WriteQueryBestSizeReply(client, &rep);
d822 1
a822 1
  return Success;
a824 1

d828 8
a835 7
  int status, size, i;
  XvPortPtr pPort;
  XvAttributePtr pAtt;
  xvQueryPortAttributesReply rep;
  xvAttributeInfo Info;
  REQUEST(xvQueryPortAttributesReq);
  REQUEST_SIZE_MATCH(xvQueryPortAttributesReq);
d837 1
a837 1
  VALIDATE_XV_PORT(stuff->port, pPort, DixGetAttrAccess);
d839 3
a841 4
  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
d844 4
a847 4
  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_attributes = pPort->pAdaptor->nAttributes;
  rep.text_size = 0;
d849 4
a852 5
  for(i = 0, pAtt = pPort->pAdaptor->pAttributes; 
      i < pPort->pAdaptor->nAttributes; i++, pAtt++) 
  {    
      rep.text_size += pad_to_int32(strlen(pAtt->name) + 1);
  }
d854 3
a856 3
  rep.length = (pPort->pAdaptor->nAttributes * sz_xvAttributeInfo)
      + rep.text_size;
  rep.length >>= 2;
d858 1
a858 1
  _WriteQueryPortAttributesReply(client, &rep);
d860 7
a866 8
  for(i = 0, pAtt = pPort->pAdaptor->pAttributes; 
      i < pPort->pAdaptor->nAttributes; i++, pAtt++) 
  {
      size = strlen(pAtt->name) + 1;  /* pass the NULL */
      Info.flags = pAtt->flags;
      Info.min = pAtt->min_value;
      Info.max = pAtt->max_value;
      Info.size = pad_to_int32(size);
d868 1
a868 1
      _WriteAttributeInfo(client, &Info);
d870 2
a871 2
      WriteToClient(client, size, pAtt->name);
  }
d873 1
a873 1
  return Success;
d876 1
a876 1
static int 
d879 58
a936 60
  DrawablePtr pDraw;
  XvPortPtr pPort;
  XvImagePtr pImage = NULL;
  GCPtr pGC;
  int status, i, size;
  CARD16 width, height;

  REQUEST(xvPutImageReq);
  REQUEST_AT_LEAST_SIZE(xvPutImageReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvImageMask) ||
	!(pPort->pAdaptor->type & XvInputMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  for(i = 0; i < pPort->pAdaptor->nImages; i++) {
      if(pPort->pAdaptor->pImages[i].id == stuff->id) {
	  pImage = &(pPort->pAdaptor->pImages[i]);
	  break;
      }
  }

  if(!pImage)
     return BadMatch;

  width = stuff->width;
  height = stuff->height;
  size = (*pPort->pAdaptor->ddQueryImageAttributes)(client, 
			pPort, pImage, &width, &height, NULL, NULL);
  size += sizeof(xvPutImageReq);
  size = bytes_to_int32(size);
  
  if((width < stuff->width) || (height < stuff->height))
     return BadValue;

  if(client->req_len < size)
     return BadLength;

  return XvdiPutImage(client, pDraw, pPort, pGC, stuff->src_x, stuff->src_y,
		      stuff->src_w, stuff->src_h, stuff->drw_x, stuff->drw_y,
		      stuff->drw_w, stuff->drw_h, pImage,
		      (unsigned char*)(&stuff[1]), FALSE,
		      stuff->width, stuff->height);
d953 1
a953 1
static int 
d956 62
a1017 63
  ShmDescPtr shmdesc;
  DrawablePtr pDraw;
  XvPortPtr pPort;
  XvImagePtr pImage = NULL;
  GCPtr pGC;
  int status, size_needed, i;
  CARD16 width, height;

  REQUEST(xvShmPutImageReq);
  REQUEST_SIZE_MATCH(xvShmPutImageReq);

  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);
  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
    {
      client->errorValue = stuff->port;
      return status;
    }

  if (!(pPort->pAdaptor->type & XvImageMask) ||
	!(pPort->pAdaptor->type & XvInputMask))
    {
      client->errorValue = stuff->port;
      return BadMatch;
    }

  status = XvdiMatchPort(pPort, pDraw);
  if (status != Success)
    {
      return status;
    }

  for(i = 0; i < pPort->pAdaptor->nImages; i++) {
      if(pPort->pAdaptor->pImages[i].id == stuff->id) {
	  pImage = &(pPort->pAdaptor->pImages[i]);
	  break;
      }
  }

  if(!pImage)
     return BadMatch;

  status = dixLookupResourceByType((pointer *)&shmdesc, stuff->shmseg,
				   ShmSegType, serverClient, DixReadAccess);
  if (status != Success)
      return status;
 
  width = stuff->width;
  height = stuff->height;
  size_needed = (*pPort->pAdaptor->ddQueryImageAttributes)(client, 
			pPort, pImage, &width, &height, NULL, NULL);
  if((size_needed + stuff->offset) > shmdesc->size)
      return BadAccess;

  if((width < stuff->width) || (height < stuff->height))
     return BadValue;
     
  status = XvdiPutImage(client, pDraw, pPort, pGC, stuff->src_x, stuff->src_y,
			stuff->src_w, stuff->src_h, stuff->drw_x, stuff->drw_y,
			stuff->drw_w, stuff->drw_h, pImage,
			(unsigned char *)shmdesc->addr + stuff->offset, 
			stuff->send_event, stuff->width, stuff->height);
d1019 1
a1019 1
  if((status == Success) && stuff->send_event) {
d1029 1
a1029 1
  }
d1031 1
a1031 1
  return status;
d1033 1
a1033 1
#else /* !MITSHM */
d1046 1
a1046 1
static int 
d1049 21
a1069 20
  xvQueryImageAttributesReply rep;
  int size, num_planes, i;
  CARD16 width, height;
  XvImagePtr pImage = NULL;
  XvPortPtr pPort;
  int *offsets;
  int *pitches;
  int planeLength;
  REQUEST(xvQueryImageAttributesReq);

  REQUEST_SIZE_MATCH(xvQueryImageAttributesReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);
  
  for(i = 0; i < pPort->pAdaptor->nImages; i++) {
      if(pPort->pAdaptor->pImages[i].id == stuff->id) {
	  pImage = &(pPort->pAdaptor->pImages[i]);
	  break;
      }
  }
d1072 2
a1073 2
  if(!pImage)
     pImage = XvMCFindXvImage(pPort, stuff->id);
d1076 2
a1077 2
  if(!pImage)
     return BadMatch;
d1079 1
a1079 1
  num_planes = pImage->num_planes;
d1081 23
a1103 3
  if(!(offsets = malloc(num_planes << 3)))
	return BadAlloc;
  pitches = offsets + num_planes;
d1105 1
a1105 2
  width = stuff->width;
  height = stuff->height;
d1107 11
a1117 2
  size = (*pPort->pAdaptor->ddQueryImageAttributes)(client, pPort, pImage,
					&width, &height, offsets, pitches);
d1119 1
a1119 12
  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.length = planeLength = num_planes << 1;
  rep.num_planes = num_planes;
  rep.width = width;
  rep.height = height;
  rep.data_size = size;
 
  _WriteQueryImageAttributesReply(client, &rep);
  if(client->swapped)
    SwapLongs((CARD32*)offsets, planeLength);
  WriteToClient(client, planeLength << 2, (char*)offsets);
d1121 1
a1121 1
  free(offsets);
d1123 1
a1123 2
  return Success;
}
d1125 58
a1182 74
static int 
ProcXvListImageFormats(ClientPtr client)
{
  XvPortPtr pPort;
  XvImagePtr pImage;
  int i;
  xvListImageFormatsReply rep;
  xvImageFormatInfo info;
  REQUEST(xvListImageFormatsReq);

  REQUEST_SIZE_MATCH(xvListImageFormatsReq);

  VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

  rep.type = X_Reply;
  rep.sequenceNumber = client->sequence;
  rep.num_formats = pPort->pAdaptor->nImages;
  rep.length = bytes_to_int32(pPort->pAdaptor->nImages * sz_xvImageFormatInfo);

  _WriteListImageFormatsReply(client, &rep);

  pImage = pPort->pAdaptor->pImages;
  
  for(i = 0; i < pPort->pAdaptor->nImages; i++, pImage++) {
     info.id = pImage->id; 	
     info.type = pImage->type; 	
     info.byte_order = pImage->byte_order; 
     memcpy(&info.guid, pImage->guid, 16);	
     info.bpp = pImage->bits_per_pixel; 	
     info.num_planes = pImage->num_planes; 	
     info.depth = pImage->depth; 	
     info.red_mask = pImage->red_mask; 	
     info.green_mask = pImage->green_mask; 	
     info.blue_mask = pImage->blue_mask; 	
     info.format = pImage->format; 	
     info.y_sample_bits = pImage->y_sample_bits; 	
     info.u_sample_bits = pImage->u_sample_bits; 	
     info.v_sample_bits = pImage->v_sample_bits; 	
     info.horz_y_period = pImage->horz_y_period; 	
     info.horz_u_period = pImage->horz_u_period; 	
     info.horz_v_period = pImage->horz_v_period; 	
     info.vert_y_period = pImage->vert_y_period; 	
     info.vert_u_period = pImage->vert_u_period; 	
     info.vert_v_period = pImage->vert_v_period; 	
     memcpy(&info.comp_order, pImage->component_order, 32);	
     info.scanline_order = pImage->scanline_order;
     _WriteImageFormatInfo(client, &info);
  }  

  return Success;
}

static int (*XvProcVector[xvNumRequests])(ClientPtr) = {
    ProcXvQueryExtension,
    ProcXvQueryAdaptors,
    ProcXvQueryEncodings,
    ProcXvGrabPort,
    ProcXvUngrabPort,
    ProcXvPutVideo,
    ProcXvPutStill,
    ProcXvGetVideo,
    ProcXvGetStill,
    ProcXvStopVideo,
    ProcXvSelectVideoNotify,
    ProcXvSelectPortNotify,
    ProcXvQueryBestSize,
    ProcXvSetPortAttribute,
    ProcXvGetPortAttribute,
    ProcXvQueryPortAttributes,
    ProcXvListImageFormats,
    ProcXvQueryImageAttributes,
    ProcXvPutImage,
    ProcXvShmPutImage,
};
d1187 1
a1187 1
  REQUEST(xReq);
d1189 1
a1189 1
  UpdateCurrentTime();
d1191 4
a1194 4
  if (stuff->data >= xvNumRequests) {
    SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
    return BadRequest;
  }
d1196 1
a1196 1
  return XvProcVector[stuff->data](client);
d1204 3
a1206 4
  char n;
  REQUEST(xvQueryExtensionReq);
  swaps(&stuff->length, n);
  return XvProcVector[xv_QueryExtension](client);
d1212 4
a1215 5
  char n;
  REQUEST(xvQueryAdaptorsReq);
  swaps(&stuff->length, n);
  swapl(&stuff->window, n);
  return XvProcVector[xv_QueryAdaptors](client);
d1221 4
a1224 5
  char n;
  REQUEST(xvQueryEncodingsReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_QueryEncodings](client);
d1230 5
a1234 6
  char n;
  REQUEST(xvGrabPortReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->time, n);
  return XvProcVector[xv_GrabPort](client);
d1240 5
a1244 6
  char n;
  REQUEST(xvUngrabPortReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->time, n);
  return XvProcVector[xv_UngrabPort](client);
d1250 14
a1263 15
  char n;
  REQUEST(xvPutVideoReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_PutVideo](client);
d1269 14
a1282 15
  char n;
  REQUEST(xvPutStillReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_PutStill](client);
d1288 14
a1301 15
  char n;
  REQUEST(xvGetVideoReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_GetVideo](client);
d1307 14
a1320 15
  char n;
  REQUEST(xvGetStillReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swaps(&stuff->vid_x, n);
  swaps(&stuff->vid_y, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_GetStill](client);
d1326 17
a1342 18
  char n;
  REQUEST(xvPutImageReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swapl(&stuff->id, n);
  swaps(&stuff->src_x, n);
  swaps(&stuff->src_y, n);
  swaps(&stuff->src_w, n);
  swaps(&stuff->src_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  swaps(&stuff->width, n);
  swaps(&stuff->height, n);
  return XvProcVector[xv_PutImage](client);
d1349 19
a1367 20
  char n;
  REQUEST(xvShmPutImageReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  swapl(&stuff->gc, n);
  swapl(&stuff->shmseg, n);
  swapl(&stuff->id, n);
  swapl(&stuff->offset, n);
  swaps(&stuff->src_x, n);
  swaps(&stuff->src_y, n);
  swaps(&stuff->src_w, n);
  swaps(&stuff->src_h, n);
  swaps(&stuff->drw_x, n);
  swaps(&stuff->drw_y, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  swaps(&stuff->width, n);
  swaps(&stuff->height, n);
  return XvProcVector[xv_ShmPutImage](client);
d1369 1
a1369 1
#else /* MITSHM */
d1376 4
a1379 5
  char n;
  REQUEST(xvSelectVideoNotifyReq);
  swaps(&stuff->length, n);
  swapl(&stuff->drawable, n);
  return XvProcVector[xv_SelectVideoNotify](client);
d1385 4
a1388 5
  char n;
  REQUEST(xvSelectPortNotifyReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_SelectPortNotify](client);
d1394 5
a1398 6
  char n;
  REQUEST(xvStopVideoReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->drawable, n);
  return XvProcVector[xv_StopVideo](client);
d1404 6
a1409 7
  char n;
  REQUEST(xvSetPortAttributeReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->attribute, n);
  swapl(&stuff->value, n);
  return XvProcVector[xv_SetPortAttribute](client);
d1415 5
a1419 6
  char n;
  REQUEST(xvGetPortAttributeReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->attribute, n);
  return XvProcVector[xv_GetPortAttribute](client);
d1425 8
a1432 9
  char n;
  REQUEST(xvQueryBestSizeReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swaps(&stuff->vid_w, n);
  swaps(&stuff->vid_h, n);
  swaps(&stuff->drw_w, n);
  swaps(&stuff->drw_h, n);
  return XvProcVector[xv_QueryBestSize](client);
d1438 4
a1441 5
  char n;
  REQUEST(xvQueryPortAttributesReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_QueryPortAttributes](client);
d1447 7
a1453 8
  char n;
  REQUEST(xvQueryImageAttributesReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  swapl(&stuff->id, n);
  swaps(&stuff->width, n);
  swaps(&stuff->height, n);
  return XvProcVector[xv_QueryImageAttributes](client);
d1459 25
a1483 29
  char n;
  REQUEST(xvListImageFormatsReq);
  swaps(&stuff->length, n);
  swapl(&stuff->port, n);
  return XvProcVector[xv_ListImageFormats](client);
}

static int (*SXvProcVector[xvNumRequests])(ClientPtr) = {
    SProcXvQueryExtension,
    SProcXvQueryAdaptors,
    SProcXvQueryEncodings,
    SProcXvGrabPort,
    SProcXvUngrabPort,
    SProcXvPutVideo,
    SProcXvPutStill,
    SProcXvGetVideo,
    SProcXvGetStill,
    SProcXvStopVideo,
    SProcXvSelectVideoNotify,
    SProcXvSelectPortNotify,
    SProcXvQueryBestSize,
    SProcXvSetPortAttribute,
    SProcXvGetPortAttribute,
    SProcXvQueryPortAttributes,
    SProcXvListImageFormats,
    SProcXvQueryImageAttributes,
    SProcXvPutImage,
    SProcXvShmPutImage,
};
d1488 1
a1488 1
  REQUEST(xReq);
d1490 1
a1490 1
  UpdateCurrentTime();
d1492 4
a1495 4
  if (stuff->data >= xvNumRequests) {
    SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
    return BadRequest;
  }
d1497 1
a1497 1
  return SXvProcVector[stuff->data](client);
d1504 23
a1526 22
   int result, i;
   PanoramiXRes *draw, *port;
   REQUEST(xvStopVideoReq);
   REQUEST_SIZE_MATCH(xvStopVideoReq);

   result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				     XRC_DRAWABLE, client, DixWriteAccess);
   if (result != Success)
       return (result == BadValue) ? BadDrawable : result;

   result = dixLookupResourceByType((pointer *)&port, stuff->port,
				    XvXRTPort, client, DixReadAccess);
   if (result != Success)
       return result;

   FOR_NSCREENS_BACKWARD(i) {
	if(port->info[i].id) {
	   stuff->drawable = draw->info[i].id;
	   stuff->port = port->info[i].id;
	   result = ProcXvStopVideo(client);
     	}
   }
d1528 1
a1528 1
   return result;
d1540 2
a1541 2
    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
d1543 1
a1543 1
	return result;
d1546 4
a1549 4
	if(port->info[i].id) {
	   stuff->port = port->info[i].id;
	   result = ProcXvSetPortAttribute(client);
	}
d1555 1
a1555 1
static int 
d1566 2
a1567 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1569 1
a1569 1
	return (result == BadValue) ? BadDrawable : result;
d1571 2
a1572 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
d1576 2
a1577 2
    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
d1579 2
a1580 2
	return result;
 
d1587 11
a1597 11
	if(port->info[i].id) {
	   stuff->drawable = draw->info[i].id;
	   stuff->port = port->info[i].id;
	   stuff->gc = gc->info[i].id;
	   stuff->drw_x = x;
	   stuff->drw_y = y;
	   if(isRoot) {
		stuff->drw_x -= screenInfo.screens[i]->x;
		stuff->drw_y -= screenInfo.screens[i]->y;
	   }
	   stuff->send_event = (send_event && !i) ? 1 : 0;
d1599 2
a1600 2
	   result = ProcXvShmPutImage(client);
	}
d1608 1
a1608 1
static int 
d1618 2
a1619 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1621 1
a1621 1
	return (result == BadValue) ? BadDrawable : result;
d1623 2
a1624 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
d1628 2
a1629 2
    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
d1631 2
a1632 2
	return result;
 
d1639 10
a1648 10
	if(port->info[i].id) {
	   stuff->drawable = draw->info[i].id;
	   stuff->port = port->info[i].id;
	   stuff->gc = gc->info[i].id;
	   stuff->drw_x = x;
	   stuff->drw_y = y;
	   if(isRoot) {
		stuff->drw_x -= screenInfo.screens[i]->x;
		stuff->drw_y -= screenInfo.screens[i]->y;
	   }
d1650 2
a1651 2
	   result = ProcXvPutImage(client);
	}
d1666 2
a1667 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1669 1
a1669 1
	return (result == BadValue) ? BadDrawable : result;
d1671 2
a1672 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
d1676 2
a1677 2
    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
d1679 1
a1679 1
	return result;
d1687 7
a1693 7
        if(port->info[i].id) {
           stuff->drawable = draw->info[i].id;
           stuff->port = port->info[i].id;
           stuff->gc = gc->info[i].id;
           stuff->drw_x = x;
           stuff->drw_y = y;
           if(isRoot) {
d1696 1
a1696 1
           }
d1698 1
a1698 1
           result = ProcXvPutVideo(client);
d1714 2
a1715 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1717 1
a1717 1
	return (result == BadValue) ? BadDrawable : result;
d1719 2
a1720 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc,
				     XRT_GC, client, DixReadAccess);
d1724 2
a1725 2
    result = dixLookupResourceByType((pointer *)&port, stuff->port,
				     XvXRTPort, client, DixReadAccess);
d1727 1
a1727 1
	return result;
d1735 7
a1741 7
        if(port->info[i].id) {
           stuff->drawable = draw->info[i].id;
           stuff->port = port->info[i].id;
           stuff->gc = gc->info[i].id;
           stuff->drw_x = x;
           stuff->drw_y = y;
           if(isRoot) {
d1744 1
a1744 1
           }
d1746 1
a1746 1
           result = ProcXvPutStill(client);
d1762 4
a1765 3
    for(i = 0; i < pAdapt->nAttributes; i++)
	if(!strcmp(pAdapt->pAttributes[i].name, "XV_COLORKEY"))
	    return TRUE;
d1773 2
a1774 1
    XvScreenPtr xvsp = dixLookupPrivate(&pScreen->devPrivates, XvGetScreenKey());
d1776 2
a1777 2
    if(xvsp == NULL)
	return NULL;
d1780 5
a1784 4
    for(i = 0; i < xvsp->nAdaptors; i++) {
	XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;
	if(!strcmp(refAdapt->name, pAdapt->name))
	    return pAdapt;
d1788 2
a1789 2
    if(!isImageAdaptor(refAdapt))
	return NULL;
d1792 5
a1796 4
    for(i = 0; i < xvsp->nAdaptors; i++) {
	XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;
	if(isImageAdaptor(pAdapt) && isOverlay == hasOverlay(pAdapt))
	    return pAdapt;
d1800 5
a1804 4
    for(i = 0; i < xvsp->nAdaptors; i++) {
	XvAdaptorPtr pAdapt = xvsp->pAdaptors + i;
	if(isImageAdaptor(pAdapt))
	    return pAdapt;
d1809 2
a1810 1
void XineramifyXv(void)
d1812 48
a1859 42
   XvScreenPtr xvsp0 = dixLookupPrivate(&screenInfo.screens[0]->devPrivates, XvGetScreenKey());
   XvAdaptorPtr MatchingAdaptors[MAXSCREENS];
   int i, j, k;

   XvXRTPort = CreateNewResourceType(XineramaDeleteResource, "XvXRTPort");

   if (!xvsp0 || !XvXRTPort) return;
   SetResourceTypeErrorValue(XvXRTPort, _XvBadPort);

   for(i = 0; i < xvsp0->nAdaptors; i++) {
      Bool isOverlay;
      XvAdaptorPtr refAdapt = xvsp0->pAdaptors + i;
      if(!(refAdapt->type & XvInputMask)) continue;

      MatchingAdaptors[0] = refAdapt;
      isOverlay = hasOverlay(refAdapt);
      FOR_NSCREENS_FORWARD_SKIP(j)
	 MatchingAdaptors[j] = matchAdaptor(screenInfo.screens[j], refAdapt, isOverlay);

      /* now create a resource for each port */
      for(j = 0; j < refAdapt->nPorts; j++) {
	 PanoramiXRes *port = malloc(sizeof(PanoramiXRes));
	 if(!port)
	    break;

	 FOR_NSCREENS(k) {
	    if(MatchingAdaptors[k] && (MatchingAdaptors[k]->nPorts > j)) 
		port->info[k].id = MatchingAdaptors[k]->base_id + j;
	    else
		port->info[k].id = 0;
	 } 
	 AddResource(port->info[0].id, XvXRTPort, port);
      }
   }

   /* munge the dispatch vector */
   XvProcVector[xv_PutVideo]		= XineramaXvPutVideo;
   XvProcVector[xv_PutStill]		= XineramaXvPutStill;
   XvProcVector[xv_StopVideo]		= XineramaXvStopVideo;
   XvProcVector[xv_SetPortAttribute]	= XineramaXvSetPortAttribute;
   XvProcVector[xv_PutImage]		= XineramaXvPutImage;
   XvProcVector[xv_ShmPutImage]		= XineramaXvShmPutImage;
d1861 1
a1861 1
#endif /* PANORAMIX */
d1867 6
a1872 6
   XvProcVector[xv_PutVideo]		= ProcXvPutVideo;
   XvProcVector[xv_PutStill]		= ProcXvPutStill;
   XvProcVector[xv_StopVideo]		= ProcXvStopVideo;
   XvProcVector[xv_SetPortAttribute]	= ProcXvSetPortAttribute;
   XvProcVector[xv_PutImage]		= ProcXvPutImage;
   XvProcVector[xv_ShmPutImage]		= ProcXvShmPutImage;
@


1.6
log
@Update to xserver 1.11.2
@
text
@d1268 1
a1268 1
  if (stuff->data > xvNumRequests) {
d1592 1
a1592 1
  if (stuff->data > xvNumRequests) {
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d1921 1
a1921 1
      for(j = 1; j < PanoramiXNumScreens; j++)
d1930 1
a1930 1
	 for(k = 0; k < PanoramiXNumScreens; k++) {
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d463 1
a463 1
  return (client->noClientException);
d486 1
a486 1
      return (status);
d523 1
a523 1
  return (client->noClientException);
d543 1
a543 1
      return (status);
d550 1
a550 1
      return (BadMatch);
d581 1
a581 1
      return (status);
d588 1
a588 1
      return (BadMatch);
d619 1
a619 1
      return (status);
d626 1
a626 1
      return (BadMatch);
d657 1
a657 1
      return (status);
d664 1
a664 1
      return (BadMatch);
d706 1
a706 1
      return (status);
d726 1
a726 1
      return (status);
d759 1
a759 1
      return (status);
d779 1
a779 1
      return (status);
d802 1
a802 1
      return (status);
d808 1
a808 1
      return(BadAtom);
d836 1
a836 1
      return (status);
d842 1
a842 1
      return(BadAtom);
d877 1
a877 1
      return (status);
d914 1
a914 1
      return (status);
d970 1
a970 1
      return (status);
d977 1
a977 1
      return (BadMatch);
a1027 1
extern int BadShmSegCode;
d1050 1
a1050 1
      return (status);
d1057 1
a1057 1
      return (BadMatch);
d1079 1
a1079 1
      return (status == BadValue) ? BadShmSegCode : status;
a1101 1
        ev.sequenceNumber = client->sequence;
d1116 1
a1116 1
    return(BadImplementation);
d1158 1
a1158 1
  if(!(offsets = xalloc(num_planes << 3)))
d1181 1
a1181 1
  xfree(offsets);
d1270 1
a1270 1
    return(BadRequest);
d1594 1
a1594 1
    return(BadRequest);
d1617 1
a1617 1
       return (result == BadValue) ? _XvBadPort : result;
d1642 1
a1642 1
	return (result == BadValue) ? _XvBadPort : result;
d1673 1
a1673 1
        return (result == BadValue) ? BadGC : result;
d1678 1
a1678 1
	return (result == BadValue) ? _XvBadPort : result;
d1693 2
a1694 2
		stuff->drw_x -= panoramiXdataPtr[i].x;
		stuff->drw_y -= panoramiXdataPtr[i].y;
d1725 1
a1725 1
        return (result == BadValue) ? BadGC : result;
d1730 1
a1730 1
	return (result == BadValue) ? _XvBadPort : result;
d1745 2
a1746 2
		stuff->drw_x -= panoramiXdataPtr[i].x;
		stuff->drw_y -= panoramiXdataPtr[i].y;
d1773 1
a1773 1
        return (result == BadValue) ? BadGC : result;
d1778 1
a1778 1
	return (result == BadValue) ? _XvBadPort : result;
d1793 2
a1794 2
                stuff->drw_x -= panoramiXdataPtr[i].x;
                stuff->drw_y -= panoramiXdataPtr[i].y;
d1821 1
a1821 1
        return (result == BadValue) ? BadGC : result;
d1826 1
a1826 1
	return (result == BadValue) ? _XvBadPort : result;
d1841 2
a1842 2
                stuff->drw_x -= panoramiXdataPtr[i].x;
                stuff->drw_y -= panoramiXdataPtr[i].y;
d1851 52
d1905 1
a1905 8
   ScreenPtr pScreen, screen0 = screenInfo.screens[0];
   XvScreenPtr xvsp0 = (XvScreenPtr)dixLookupPrivate(&screen0->devPrivates,
						     XvGetScreenKey());
   XvAdaptorPtr refAdapt, pAdapt;
   XvAttributePtr pAttr;
   XvScreenPtr xvsp;
   Bool isOverlay, hasOverlay;
   PanoramiXRes *port;
d1907 1
a1907 1
   int i, j, k, l;
d1912 1
d1915 3
a1917 1
      refAdapt = xvsp0->pAdaptors + i;
a1918 2
      bzero(MatchingAdaptors, sizeof(XvAdaptorPtr) * MAXSCREENS);
      
d1920 3
a1922 67
   
      if(!(refAdapt->type & XvInputMask)) continue;
      
      isOverlay = FALSE;
      for(j = 0; j < refAdapt->nAttributes; j++) {
         pAttr = refAdapt->pAttributes + j;
         if(!strcmp(pAttr->name, "XV_COLORKEY")) {
	    isOverlay = TRUE;
	    break;
	 }
      }
   
      for(j = 1; j < PanoramiXNumScreens; j++) {
         pScreen = screenInfo.screens[j];
	 xvsp = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
					      XvGetScreenKey());
         /* Do not try to go on if xv is not supported on this screen */
         if (xvsp==NULL) continue ;
	 
         /* if the adaptor has the same name it's a perfect match */
	 for(k = 0; k < xvsp->nAdaptors; k++) {
	   pAdapt = xvsp->pAdaptors + k;
           if(!strcmp(refAdapt->name, pAdapt->name)) {
	       MatchingAdaptors[j] = pAdapt;
	       break;
	   }
         }
	 if(MatchingAdaptors[j]) continue; /* found it */
	 
	 /* otherwise we only look for XvImage adaptors */
	 if(!(refAdapt->type & XvImageMask)) continue;
	 if(refAdapt->nImages <= 0) continue;
	 
	 /* prefer overlay/overlay non-overlay/non-overlay pairing */
	 for(k = 0; k < xvsp->nAdaptors; k++) {
	    pAdapt = xvsp->pAdaptors + k;
	    if((pAdapt->type & XvImageMask) && (pAdapt->nImages > 0)) {
	      hasOverlay = FALSE;
              for(l = 0; l < pAdapt->nAttributes; l++) {
	         if(!strcmp(pAdapt->pAttributes[l].name, "XV_COLORKEY")) {
		   hasOverlay = TRUE;
		   break;
		 }
	      }
	      if(isOverlay && hasOverlay) {
	      	 MatchingAdaptors[j] = pAdapt;
		 break;
	      }
              else if(!isOverlay && !hasOverlay) {
	      	 MatchingAdaptors[j] = pAdapt;
		 break;
	      }
	    }
         }
	 
	 if(MatchingAdaptors[j]) continue; /* found it */
	 
	 /* but we'll take any XvImage pairing if we can get it */
	 	 
	 for(k = 0; k < xvsp->nAdaptors; k++) {
	    pAdapt = xvsp->pAdaptors + k;
	    if((pAdapt->type & XvImageMask) && (pAdapt->nImages > 0)) {
	      	 MatchingAdaptors[j] = pAdapt;
		 break;
	    }
         }
      }
d1926 2
a1927 1
         if(!(port = xalloc(sizeof(PanoramiXRes))))
a1928 2
	 port->info[0].id = MatchingAdaptors[0]->base_id + j;
	 AddResource(port->info[0].id, XvXRTPort, port);
d1930 1
a1930 1
	 for(k = 1; k < PanoramiXNumScreens; k++) {
d1936 1
@


1.3
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@a44 1
#ifdef HAVE_X11_EXTENSIONS_SHMPROTO_H
a45 4
#else
#define _XSHM_SERVER_
#include <X11/extensions/shmstr.h>
#endif
d425 1
a425 1
      totalSize += (strlen(pa->name) + 3) & ~3;
d430 1
a430 1
  rep.length = totalSize >> 2;
d481 1
a481 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d500 1
a500 1
      totalSize += (strlen(pe->name) + 3) & ~3;
d504 1
a504 1
  rep.length = totalSize >> 2;
d538 1
a538 6

  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d553 1
a553 1
  status = XVCALL(diMatchPort)(pPort, pDraw);
d559 3
a561 5
  return XVCALL(diPutVideo)(client, pDraw, pPort, pGC,
			    stuff->vid_x, stuff->vid_y,
			    stuff->vid_w, stuff->vid_h,
			    stuff->drw_x, stuff->drw_y,
			    stuff->drw_w, stuff->drw_h);
d576 1
a576 6

  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d591 1
a591 1
  status = XVCALL(diMatchPort)(pPort, pDraw);
d597 3
a599 5
  return XVCALL(diPutStill)(client, pDraw, pPort, pGC,
			    stuff->vid_x, stuff->vid_y,
			    stuff->vid_w, stuff->vid_h,
			    stuff->drw_x, stuff->drw_y,
			    stuff->drw_w, stuff->drw_h);
d614 1
a614 6

  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d629 1
a629 1
  status = XVCALL(diMatchPort)(pPort, pDraw);
d635 3
a637 5
  return XVCALL(diGetVideo)(client, pDraw, pPort, pGC,
			    stuff->vid_x, stuff->vid_y,
			    stuff->vid_w, stuff->vid_h,
			    stuff->drw_x, stuff->drw_y,
			    stuff->drw_w, stuff->drw_h);
d652 1
a652 6

  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d667 1
a667 1
  status = XVCALL(diMatchPort)(pPort, pDraw);
d673 3
a675 5
  return XVCALL(diGetStill)(client, pDraw, pPort, pGC,
			    stuff->vid_x, stuff->vid_y,
			    stuff->vid_w, stuff->vid_h,
			    stuff->drw_x, stuff->drw_y,
			    stuff->drw_w, stuff->drw_h);
d690 1
a690 1
  return XVCALL(diSelectVideoNotify)(client, pDraw, stuff->onoff);
d701 1
a701 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d709 1
a709 1
  return XVCALL(diSelectPortNotify)(client, pPort, stuff->onoff);
d721 1
a721 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d729 1
a729 1
  status = XVCALL(diGrabPort)(client, pPort, stuff->time, &result);
d754 1
a754 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d762 1
a762 1
  return XVCALL(diUngrabPort)(client, pPort, stuff->time);
d774 1
a774 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d786 1
a786 1
  return XVCALL(diStopVideo)(client, pPort, pDraw);
d797 1
a797 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d811 1
a811 2
  status = XVCALL(diSetPortAttribute)(client, pPort, 
				    stuff->attribute, stuff->value);
d831 1
a831 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d845 1
a845 1
  status = XVCALL(diGetPortAttribute)(client, pPort, stuff->attribute, &value);
d872 1
a872 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d909 1
a909 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d925 1
a925 1
      rep.text_size += (strlen(pAtt->name) + 1 + 3) & ~3L;
d941 1
a941 1
      Info.size = (size + 3) & ~3L;
d965 1
a965 6

  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d980 1
a980 1
  status = XVCALL(diMatchPort)(pPort, pDraw);
d1001 1
a1001 1
  size = (size + 3) >> 2;
d1009 5
a1013 7
  return XVCALL(diPutImage)(client, pDraw, pPort, pGC, 
			    stuff->src_x, stuff->src_y,
			    stuff->src_w, stuff->src_h,
			    stuff->drw_x, stuff->drw_y,
			    stuff->drw_w, stuff->drw_h,
			    pImage, (unsigned char*)(&stuff[1]), FALSE,
			    stuff->width, stuff->height);
d1046 1
a1046 6

  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d1061 1
a1061 1
  status = XVCALL(diMatchPort)(pPort, pDraw);
d1077 4
a1080 5
  if(!(shmdesc = (ShmDescPtr)LookupIDByType(stuff->shmseg, ShmSegType))) 
    {
      client->errorValue = stuff->shmseg;
      return BadShmSegCode;  
    }	
d1092 5
a1096 7
  status = XVCALL(diPutImage)(client, pDraw, pPort, pGC, 
			    stuff->src_x, stuff->src_y,
			    stuff->src_w, stuff->src_h,
			    stuff->drw_x, stuff->drw_y,
			    stuff->drw_w, stuff->drw_h, pImage,
			    (unsigned char *)shmdesc->addr + stuff->offset, 
			    stuff->send_event, stuff->width, stuff->height);
d1141 1
a1141 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d1200 1
a1200 5
  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
    {
      client->errorValue = stuff->port;
      return (_XvBadPort);
    }
d1205 1
a1205 1
  rep.length = pPort->pAdaptor->nImages * sz_xvImageFormatInfo >> 2;
d1606 1
a1606 1
   int result = Success, i;
d1611 9
a1619 7
   if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
        return BadDrawable;

   if(!(port = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->port, XvXRTPort, DixReadAccess)))
        return _XvBadPort;
d1637 1
a1637 1
    int result = Success, i;
d1641 4
a1644 3
    if(!(port = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->port, XvXRTPort, DixReadAccess)))
        return _XvBadPort;
d1663 1
a1663 1
    int result = Success, i, x, y;
d1667 14
a1680 11
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
        return BadDrawable;

    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->gc, XRT_GC, DixReadAccess)))
        return BadGC;    

    if(!(port = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->port, XvXRTPort, DixReadAccess)))
        return _XvBadPort;
d1715 1
a1715 1
    int result = Success, i, x, y;
d1719 14
a1732 11
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
        return BadDrawable;

    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->gc, XRT_GC, DixReadAccess)))
        return BadGC;    

    if(!(port = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->port, XvXRTPort, DixReadAccess)))
	return _XvBadPort;
d1763 1
a1763 1
    int result = Success, i, x, y;
d1767 14
a1780 11
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
        return BadDrawable;

    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->gc, XRT_GC, DixReadAccess)))
        return BadGC;

    if(!(port = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->port, XvXRTPort, DixReadAccess)))
        return _XvBadPort;
d1811 1
a1811 1
    int result = Success, i, x, y;
d1815 14
a1828 11
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
        return BadDrawable;

    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->gc, XRT_GC, DixReadAccess)))
        return BadGC;

    if(!(port = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->port, XvXRTPort, DixReadAccess)))
        return _XvBadPort;
d1866 3
a1868 1
   XvXRTPort = CreateNewResourceType(XineramaDeleteResource);
a1869 2
   if(!xvsp0) return;
   
d1915 1
a1915 1
	         if(!strcmp(pAdapt->name, "XV_COLORKEY")) {
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d45 3
d50 1
@


1.1
log
@Initial revision
@
text
@a21 1

a23 24
/*
** File: 
**
**   xvdisp.c --- Xv server extension dispatch module.
**
** Author: 
**
**   David Carver (Digital Workstation Engineering/Project Athena)
**
** Revisions:
**
**   11.06.91 Carver
**     - changed SetPortControl to SetPortAttribute
**     - changed GetPortControl to GetPortAttribute
**     - changed QueryBestSize
**
**   15.05.91 Carver
**     - version 2.0 upgrade
**
**   24.01.91 Carver
**     - version 1.4 upgrade
**
*/

d56 188
d245 35
a279 9
#ifdef MITSHM
static int XineramaXvShmPutImage(ClientPtr);
#endif
static int XineramaXvPutImage(ClientPtr);
static int XineramaXvPutVideo(ClientPtr);
static int XineramaXvPutStill(ClientPtr);
static int XineramaXvSetPortAttribute(ClientPtr);
static int XineramaXvStopVideo(ClientPtr);
#endif
d281 6
a286 1
/* INTERNAL */
d288 3
a290 22
static int ProcXvQueryExtension(ClientPtr);
static int ProcXvQueryAdaptors(ClientPtr);
static int ProcXvQueryEncodings(ClientPtr);
static int ProcXvPutVideo(ClientPtr);
static int ProcXvPutStill(ClientPtr);
static int ProcXvGetVideo(ClientPtr);
static int ProcXvGetStill(ClientPtr);
static int ProcXvGrabPort(ClientPtr);
static int ProcXvUngrabPort(ClientPtr);
static int ProcXvSelectVideoNotify(ClientPtr);
static int ProcXvSelectPortNotify(ClientPtr);
static int ProcXvStopVideo(ClientPtr);
static int ProcXvSetPortAttribute(ClientPtr);
static int ProcXvGetPortAttribute(ClientPtr);
static int ProcXvQueryBestSize(ClientPtr);
static int ProcXvQueryPortAttributes(ClientPtr);
static int ProcXvPutImage(ClientPtr);
#ifdef MITSHM
static int ProcXvShmPutImage(ClientPtr);
#endif
static int ProcXvQueryImageAttributes(ClientPtr);
static int ProcXvListImageFormats(ClientPtr);
d292 1
a292 22
static int SProcXvQueryExtension(ClientPtr);
static int SProcXvQueryAdaptors(ClientPtr);
static int SProcXvQueryEncodings(ClientPtr);
static int SProcXvPutVideo(ClientPtr);
static int SProcXvPutStill(ClientPtr);
static int SProcXvGetVideo(ClientPtr);
static int SProcXvGetStill(ClientPtr);
static int SProcXvGrabPort(ClientPtr);
static int SProcXvUngrabPort(ClientPtr);
static int SProcXvSelectVideoNotify(ClientPtr);
static int SProcXvSelectPortNotify(ClientPtr);
static int SProcXvStopVideo(ClientPtr);
static int SProcXvSetPortAttribute(ClientPtr);
static int SProcXvGetPortAttribute(ClientPtr);
static int SProcXvQueryBestSize(ClientPtr);
static int SProcXvQueryPortAttributes(ClientPtr);
static int SProcXvPutImage(ClientPtr);
#ifdef MITSHM
static int SProcXvShmPutImage(ClientPtr);
#endif
static int SProcXvQueryImageAttributes(ClientPtr);
static int SProcXvListImageFormats(ClientPtr);
d294 2
a295 16
static int SWriteQueryAdaptorsReply(ClientPtr, xvQueryAdaptorsReply *);
static int SWriteQueryExtensionReply(ClientPtr, xvQueryExtensionReply *);
static int SWriteQueryEncodingsReply(ClientPtr, xvQueryEncodingsReply *);
static int SWriteAdaptorInfo(ClientPtr, xvAdaptorInfo *);
static int SWriteEncodingInfo(ClientPtr, xvEncodingInfo *);
static int SWriteFormat(ClientPtr, xvFormat *);
static int SWriteAttributeInfo(ClientPtr, xvAttributeInfo *);
static int SWriteGrabPortReply(ClientPtr, xvGrabPortReply *);
static int SWriteGetPortAttributeReply(ClientPtr, xvGetPortAttributeReply *);
static int SWriteQueryBestSizeReply(ClientPtr, xvQueryBestSizeReply *);
static int SWriteQueryPortAttributesReply(
		ClientPtr, xvQueryPortAttributesReply *);
static int SWriteQueryImageAttributesReply(
		ClientPtr, xvQueryImageAttributesReply*);
static int SWriteListImageFormatsReply(ClientPtr, xvListImageFormatsReply*);
static int SWriteImageFormatInfo(ClientPtr, xvImageFormatInfo*);
a355 135
/*
** ProcXvDispatch
**
**
**
*/

int
ProcXvDispatch(ClientPtr client)
{
  REQUEST(xReq);

  UpdateCurrentTime();

  switch (stuff->data) 
    {
    case xv_QueryExtension: return(ProcXvQueryExtension(client));
    case xv_QueryAdaptors: return(ProcXvQueryAdaptors(client));
    case xv_QueryEncodings: return(ProcXvQueryEncodings(client));
    case xv_PutVideo:
#ifdef PANORAMIX
        if(!noPanoramiXExtension)
            return(XineramaXvPutVideo(client));
        else
#endif
            return(ProcXvPutVideo(client));
    case xv_PutStill:
#ifdef PANORAMIX
        if(!noPanoramiXExtension)
            return(XineramaXvPutStill(client));
        else
#endif
    	    return(ProcXvPutStill(client));
    case xv_GetVideo: return(ProcXvGetVideo(client));
    case xv_GetStill: return(ProcXvGetStill(client));
    case xv_GrabPort: return(ProcXvGrabPort(client));
    case xv_UngrabPort: return(ProcXvUngrabPort(client));
    case xv_SelectVideoNotify: return(ProcXvSelectVideoNotify(client));
    case xv_SelectPortNotify: return(ProcXvSelectPortNotify(client));
    case xv_StopVideo: 
#ifdef PANORAMIX
        if(!noPanoramiXExtension)
	    return(XineramaXvStopVideo(client));
	else
#endif
	    return(ProcXvStopVideo(client));
    case xv_SetPortAttribute: 
#ifdef PANORAMIX
        if(!noPanoramiXExtension)
	    return(XineramaXvSetPortAttribute(client));
	else
#endif
	    return(ProcXvSetPortAttribute(client));
    case xv_GetPortAttribute: return(ProcXvGetPortAttribute(client));
    case xv_QueryBestSize: return(ProcXvQueryBestSize(client));
    case xv_QueryPortAttributes: return(ProcXvQueryPortAttributes(client));
    case xv_PutImage:
#ifdef PANORAMIX
        if(!noPanoramiXExtension)
	    return(XineramaXvPutImage(client));
	else
#endif
	    return(ProcXvPutImage(client));
#ifdef MITSHM
    case xv_ShmPutImage: 
#ifdef PANORAMIX
        if(!noPanoramiXExtension)
	    return(XineramaXvShmPutImage(client));
	else
#endif
	    return(ProcXvShmPutImage(client));
#endif
    case xv_QueryImageAttributes: return(ProcXvQueryImageAttributes(client));
    case xv_ListImageFormats: return(ProcXvListImageFormats(client));
    default:
      if (stuff->data < xvNumRequests)
	{
	  SendErrorToClient(client, XvReqCode, stuff->data, 0, 
			    BadImplementation);
	  return(BadImplementation);
	}
      else
	{
	  SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
	  return(BadRequest);
	}
    }
}

int
SProcXvDispatch(ClientPtr client)
{
  REQUEST(xReq);

  UpdateCurrentTime();

  switch (stuff->data) 
    {
    case xv_QueryExtension: return(SProcXvQueryExtension(client));
    case xv_QueryAdaptors: return(SProcXvQueryAdaptors(client));
    case xv_QueryEncodings: return(SProcXvQueryEncodings(client));
    case xv_PutVideo: return(SProcXvPutVideo(client));
    case xv_PutStill: return(SProcXvPutStill(client));
    case xv_GetVideo: return(SProcXvGetVideo(client));
    case xv_GetStill: return(SProcXvGetStill(client));
    case xv_GrabPort: return(SProcXvGrabPort(client));
    case xv_UngrabPort: return(SProcXvUngrabPort(client));
    case xv_SelectVideoNotify: return(SProcXvSelectVideoNotify(client));
    case xv_SelectPortNotify: return(SProcXvSelectPortNotify(client));
    case xv_StopVideo: return(SProcXvStopVideo(client));
    case xv_SetPortAttribute: return(SProcXvSetPortAttribute(client));
    case xv_GetPortAttribute: return(SProcXvGetPortAttribute(client));
    case xv_QueryBestSize: return(SProcXvQueryBestSize(client));
    case xv_QueryPortAttributes: return(SProcXvQueryPortAttributes(client));
    case xv_PutImage: return(SProcXvPutImage(client));
#ifdef MITSHM
    case xv_ShmPutImage: return(SProcXvShmPutImage(client));
#endif
    case xv_QueryImageAttributes: return(SProcXvQueryImageAttributes(client));
    case xv_ListImageFormats: return(SProcXvListImageFormats(client));
    default:
      if (stuff->data < xvNumRequests)
	{
	  SendErrorToClient(client, XvReqCode, stuff->data, 0, 
			    BadImplementation);
	  return(BadImplementation);
	}
      else
	{
	  SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
	  return(BadRequest);
	}
    }
}

a371 1

d380 2
a381 2
  int totalSize;
  int na;
a382 1
  int nf;
d391 3
a393 5
  if(!(pWin = (WindowPtr)LookupWindow(stuff->window, client) ))
    {
      client->errorValue = stuff->window;
      return (BadWindow);
    }
d396 2
a397 2
  pxvs = (XvScreenPtr)pScreen->devPrivates[XvScreenIndex].ptr;

d443 1
a443 1
      ainfo.name_size = strlen(pa->name);
d448 1
a448 1
      WriteToClient(client, ainfo.name_size, pa->name);
a464 1

d473 1
d518 1
a518 1
      einfo.name_size = strlen(pe->name);
d524 1
a524 1
      WriteToClient(client, einfo.name_size, pe->name);
a528 1

d534 1
a534 1
  register DrawablePtr pDraw;
d536 1
a536 1
  register GCPtr pGC;
d542 1
a542 1
  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
a573 1

d579 1
a579 1
  register DrawablePtr pDraw;
d581 1
a581 1
  register GCPtr pGC;
d587 1
a587 1
  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
a618 1

a620 1

d624 1
a624 1
  register DrawablePtr pDraw;
d626 1
a626 1
  register GCPtr pGC;
d632 1
a632 1
  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
a663 1

a665 1

d669 1
a669 1
  register DrawablePtr pDraw;
d671 1
a671 1
  register GCPtr pGC;
d677 1
a677 1
  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
a708 1

d714 2
a715 1
  register DrawablePtr pDraw;
d719 3
a721 5
  if(!(pDraw = (DrawablePtr)LOOKUP_DRAWABLE(stuff->drawable, client) ))
    {
      client->errorValue = stuff->drawable;
      return (BadWindow);
    }
a723 1

a746 1

a784 1

a807 1

a809 1

d813 2
a814 2
  int status;
  register DrawablePtr pDraw;
d831 3
a833 5
  if(!(pDraw = LOOKUP_DRAWABLE(stuff->drawable, client) ))
    {
      client->errorValue = stuff->drawable;
      return (BadDrawable);
    }
a835 1

d989 1
a989 1
      i < rep.num_attributes; i++, pAtt++) 
d994 2
a995 1
  rep.length = (rep.num_attributes * sz_xvAttributeInfo) + rep.text_size;
d1001 1
a1001 1
      i < rep.num_attributes; i++, pAtt++) 
a1016 2


d1030 1
a1030 1
  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d1118 1
a1118 1
  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
d1194 7
d1217 1
d1257 1
a1257 1
  rep.length = num_planes << 1;
d1265 2
a1266 2
    SwapLongs((CARD32*)offsets, rep.length);
  WriteToClient(client, rep.length << 2, (char*)offsets);
d1294 1
a1294 1
  rep.length = rep.num_formats * sz_xvImageFormatInfo >> 2;
d1300 1
a1300 1
  for(i = 0; i < rep.num_formats; i++, pImage++) {
d1329 34
d1364 2
d1372 1
a1372 1
  register char n;
d1375 1
a1375 1
  return ProcXvQueryExtension(client);
d1381 1
a1381 1
  register char n;
d1385 1
a1385 1
  return ProcXvQueryAdaptors(client);
d1391 1
a1391 1
  register char n;
d1395 1
a1395 1
  return ProcXvQueryEncodings(client);
d1401 1
a1401 1
  register char n;
d1406 1
a1406 1
  return ProcXvGrabPort(client);
d1412 1
a1412 1
  register char n;
d1417 1
a1417 1
  return ProcXvUngrabPort(client);
d1423 1
a1423 1
  register char n;
d1437 1
a1437 1
  return ProcXvPutVideo(client);
d1443 1
a1443 1
  register char n;
d1457 1
a1457 1
  return ProcXvPutStill(client);
d1463 1
a1463 1
  register char n;
d1477 1
a1477 1
  return ProcXvGetVideo(client);
d1483 1
a1483 1
  register char n;
d1497 1
a1497 1
  return ProcXvGetStill(client);
d1503 1
a1503 1
  register char n;
d1520 1
a1520 1
  return ProcXvPutImage(client);
d1527 1
a1527 1
  register char n;
d1535 1
a1543 1
  swaps(&stuff->offset, n);
d1546 1
a1546 1
  return ProcXvShmPutImage(client);
d1548 2
a1551 1

d1555 1
a1555 1
  register char n;
d1559 1
a1559 1
  return ProcXvSelectVideoNotify(client);
d1565 1
a1565 1
  register char n;
d1569 1
a1569 1
  return ProcXvSelectPortNotify(client);
d1575 1
a1575 1
  register char n;
d1580 1
a1580 1
  return ProcXvStopVideo(client);
d1586 1
a1586 1
  register char n;
d1591 2
a1592 1
  return ProcXvSetPortAttribute(client);
d1598 1
a1598 1
  register char n;
d1603 1
a1603 1
  return ProcXvGetPortAttribute(client);
d1609 1
a1609 1
  register char n;
d1617 1
a1617 1
  return ProcXvQueryBestSize(client);
d1623 1
a1623 1
  register char n;
d1627 1
a1627 1
  return ProcXvQueryPortAttributes(client);
d1633 1
a1633 1
  register char n;
d1636 1
d1639 2
a1640 2
  swaps(&stuff->width, n);
  return ProcXvQueryImageAttributes(client);
d1646 1
a1646 1
  register char n;
d1650 1
a1650 1
  return ProcXvListImageFormats(client);
d1653 22
d1676 4
a1679 6
static int
SWriteQueryExtensionReply(
   ClientPtr client,
   xvQueryExtensionReply *rep
){
  register char n;
d1681 1
a1681 6
  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->version, n);
  swaps(&rep->revision, n);
  
  (void)WriteToClient(client, sz_xvQueryExtensionReply, (char *)&rep);
d1683 4
a1686 222
  return Success;
}

static int
SWriteQueryAdaptorsReply(
   ClientPtr client,
   xvQueryAdaptorsReply *rep
){
  register char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->num_adaptors, n);
  
  (void)WriteToClient(client, sz_xvQueryAdaptorsReply, (char *)&rep);

  return Success;
}

static int
SWriteQueryEncodingsReply(
   ClientPtr client,
   xvQueryEncodingsReply *rep
){
  register char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->num_encodings, n);
  
  (void)WriteToClient(client, sz_xvQueryEncodingsReply, (char *)&rep);

  return Success;
}

static int
SWriteAdaptorInfo(
   ClientPtr client,
   xvAdaptorInfo *pAdaptor
){
  register char n;

  swapl(&pAdaptor->base_id, n);
  swaps(&pAdaptor->name_size, n);
  swaps(&pAdaptor->num_ports, n);
  swaps(&pAdaptor->num_formats, n);

  (void)WriteToClient(client, sz_xvAdaptorInfo, (char *)pAdaptor);

  return Success;
}

static int
SWriteEncodingInfo(
   ClientPtr client,
   xvEncodingInfo *pEncoding
){
  register char n;
  
  swapl(&pEncoding->encoding, n);
  swaps(&pEncoding->name_size, n);
  swaps(&pEncoding->width, n);
  swaps(&pEncoding->height, n);
  swapl(&pEncoding->rate.numerator, n);
  swapl(&pEncoding->rate.denominator, n);
  (void)WriteToClient(client, sz_xvEncodingInfo, (char *)pEncoding);

  return Success;
}

static int
SWriteFormat(
   ClientPtr client,
   xvFormat *pFormat
){
  register char n;

  swapl(&pFormat->visual, n);
  (void)WriteToClient(client, sz_xvFormat, (char *)pFormat);

  return Success;
}

static int
SWriteAttributeInfo(
   ClientPtr client,
   xvAttributeInfo *pAtt
){
  register char n;

  swapl(&pAtt->flags, n);
  swapl(&pAtt->size, n);
  swapl(&pAtt->min, n);
  swapl(&pAtt->max, n);
  (void)WriteToClient(client, sz_xvAttributeInfo, (char *)pAtt);

  return Success;
}

static int
SWriteImageFormatInfo(
   ClientPtr client,
   xvImageFormatInfo *pImage
){
  register char n;

  swapl(&pImage->id, n);
  swapl(&pImage->red_mask, n);
  swapl(&pImage->green_mask, n);
  swapl(&pImage->blue_mask, n);
  swapl(&pImage->y_sample_bits, n);
  swapl(&pImage->u_sample_bits, n);
  swapl(&pImage->v_sample_bits, n);
  swapl(&pImage->horz_y_period, n);
  swapl(&pImage->horz_u_period, n);
  swapl(&pImage->horz_v_period, n);
  swapl(&pImage->vert_y_period, n);
  swapl(&pImage->vert_u_period, n);
  swapl(&pImage->vert_v_period, n);

  (void)WriteToClient(client, sz_xvImageFormatInfo, (char *)pImage);

  return Success;
}



static int
SWriteGrabPortReply(
   ClientPtr client,
   xvGrabPortReply *rep
){
  register char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);

  (void)WriteToClient(client, sz_xvGrabPortReply, (char *)&rep);

  return Success;
}

static int
SWriteGetPortAttributeReply(
   ClientPtr client,
   xvGetPortAttributeReply *rep
){
  register char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->value, n);

  (void)WriteToClient(client, sz_xvGetPortAttributeReply, (char *)&rep);

  return Success;
}

static int
SWriteQueryBestSizeReply(
   ClientPtr client,
   xvQueryBestSizeReply *rep
){
  register char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swaps(&rep->actual_width, n);
  swaps(&rep->actual_height, n);

  (void)WriteToClient(client, sz_xvQueryBestSizeReply, (char *)&rep);

  return Success;
}

static int
SWriteQueryPortAttributesReply(
   ClientPtr client,
   xvQueryPortAttributesReply *rep
){
  register char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_attributes, n);
  swapl(&rep->text_size, n);

  (void)WriteToClient(client, sz_xvQueryPortAttributesReply, (char *)&rep);

  return Success;
}

static int
SWriteQueryImageAttributesReply(
   ClientPtr client,
   xvQueryImageAttributesReply *rep
){
  register char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_planes, n);
  swapl(&rep->data_size, n);
  swaps(&rep->width, n);
  swaps(&rep->height, n);

  (void)WriteToClient(client, sz_xvQueryImageAttributesReply, (char *)&rep);

  return Success;
}


static int
SWriteListImageFormatsReply(
   ClientPtr client,
   xvListImageFormatsReply *rep
){
  register char n;

  swaps(&rep->sequenceNumber, n);
  swapl(&rep->length, n);
  swapl(&rep->num_formats, n);
d1688 1
a1688 3
  (void)WriteToClient(client, sz_xvListImageFormatsReply, (char *)&rep);

  return Success;
a1690 1

a1691 4




d1701 1
a1701 1
                client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1705 1
a1705 1
                client, stuff->port, XvXRTPort, SecurityReadAccess)))
d1729 1
a1729 1
                client, stuff->port, XvXRTPort, SecurityReadAccess)))
a1740 1

d1754 1
a1754 1
                client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1758 1
a1758 1
                client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1762 1
a1762 1
                client, stuff->port, XvXRTPort, SecurityReadAccess)))
d1788 2
d1803 1
a1803 1
                client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1807 1
a1807 1
                client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1811 1
a1811 1
		client, stuff->port, XvXRTPort, SecurityReadAccess)))
d1848 1
a1848 1
                client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1852 1
a1852 1
                client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1856 1
a1856 1
                client, stuff->port, XvXRTPort, SecurityReadAccess)))
d1893 1
a1893 1
                client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1897 1
a1897 1
                client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1901 1
a1901 1
                client, stuff->port, XvXRTPort, SecurityReadAccess)))
a1926 1

d1930 2
a1931 1
   XvScreenPtr xvsp0 = (XvScreenPtr)screen0->devPrivates[XvScreenIndex].ptr;
d1964 2
a1965 2
	 xvsp = (XvScreenPtr)pScreen->devPrivates[XvScreenIndex].ptr;

d2033 8
d2042 1
d2044 10
d2055 1
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d376 2
a377 1
  int totalSize, na, nf, rc;
d379 1
d388 5
a392 3
  rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
  if (rc != Success)
      return rc;
d534 1
a534 1
  DrawablePtr pDraw;
d536 1
a536 1
  GCPtr pGC;
d580 1
a580 1
  DrawablePtr pDraw;
d582 1
a582 1
  GCPtr pGC;
d627 1
a627 1
  DrawablePtr pDraw;
d629 1
a629 1
  GCPtr pGC;
d674 1
a674 1
  DrawablePtr pDraw;
d676 1
a676 1
  GCPtr pGC;
d720 1
a720 2
  DrawablePtr pDraw;
  int rc;
d724 5
a728 3
  rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixUnknownAccess);
  if (rc != Success)
    return rc;
d825 2
a826 2
  int status, rc;
  DrawablePtr pDraw;
d843 5
a847 3
  rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixUnknownAccess);
  if (rc != Success)
    return rc;
d1880 1
a1880 1
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1884 1
a1884 1
                client, stuff->port, XvXRTPort, DixReadAccess)))
d1908 1
a1908 1
                client, stuff->port, XvXRTPort, DixReadAccess)))
d1934 1
a1934 1
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1938 1
a1938 1
                client, stuff->gc, XRT_GC, DixReadAccess)))
d1942 1
a1942 1
                client, stuff->port, XvXRTPort, DixReadAccess)))
d1981 1
a1981 1
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1985 1
a1985 1
                client, stuff->gc, XRT_GC, DixReadAccess)))
d1989 1
a1989 1
		client, stuff->port, XvXRTPort, DixReadAccess)))
d2026 1
a2026 1
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d2030 1
a2030 1
                client, stuff->gc, XRT_GC, DixReadAccess)))
d2034 1
a2034 1
                client, stuff->port, XvXRTPort, DixReadAccess)))
d2071 1
a2071 1
                client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d2075 1
a2075 1
                client, stuff->gc, XRT_GC, DixReadAccess)))
d2079 1
a2079 1
                client, stuff->port, XvXRTPort, DixReadAccess)))
@

