head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.5.0.4
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	s0SI41sEunLdyFfd;

1.15
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	Te1daavkBLskZ8gc;

1.14
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	cVXoV5PxI8YrEaVA;

1.13
date	2014.05.02.19.27.46;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2012.01.31.07.52.35;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.05.13.32.46;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.11.15.39.26;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.20.21.29.42;	author matthieu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2008.01.17.15.41.53;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.54;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.54;	author matthieu;	state Exp;
branches
	1.1.1.1.2.1;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.53;	author matthieu;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	2008.01.29.06.02.07;	author ckuethe;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	2008.07.13.03.11.28;	author brad;	state Exp;
branches;
next	;

1.3.2.1
date	2008.07.13.03.08.30;	author brad;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*

Copyright 1996, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "inputstr.h"
#include "windowstr.h"
#include "propertyst.h"
#include "colormapst.h"
#include "privates.h"
#include "registry.h"
#include "xacestr.h"
#include "securitysrv.h"
#include <X11/extensions/securproto.h>
#include "extinit.h"
#include "protocol-versions.h"

/* Extension stuff */
static int SecurityErrorBase;   /* first Security error number */
static int SecurityEventBase;   /* first Security event number */

RESTYPE SecurityAuthorizationResType;   /* resource type for authorizations */
static RESTYPE RTEventClient;

static CallbackListPtr SecurityValidateGroupCallback = NULL;

/* Private state record */
static DevPrivateKeyRec stateKeyRec;

#define stateKey (&stateKeyRec)

/* This is what we store as client security state */
typedef struct {
    unsigned int haveState  :1;
    unsigned int live       :1;
    unsigned int trustLevel :2;
    XID authId;
} SecurityStateRec;

/* Extensions that untrusted clients shouldn't have access to */
static const char *SecurityTrustedExtensions[] = {
    "XC-MISC",
    "BIG-REQUESTS",
    NULL
};

/*
 * Access modes that untrusted clients are allowed on trusted objects.
 */
static const Mask SecurityResourceMask =
    DixGetAttrAccess | DixReceiveAccess | DixListPropAccess |
    DixGetPropAccess | DixListAccess;
static const Mask SecurityWindowExtraMask = DixRemoveAccess;
static const Mask SecurityRootWindowExtraMask =
    DixReceiveAccess | DixSendAccess | DixAddAccess | DixRemoveAccess;
static const Mask SecurityDeviceMask =
    DixGetAttrAccess | DixReceiveAccess | DixGetFocusAccess |
    DixGrabAccess | DixSetAttrAccess | DixUseAccess;
static const Mask SecurityServerMask = DixGetAttrAccess | DixGrabAccess;
static const Mask SecurityClientMask = DixGetAttrAccess;

/* SecurityAudit
 *
 * Arguments:
 *	format is the formatting string to be used to interpret the
 *	  remaining arguments.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Writes the message to the log file if security logging is on.
 */

static void
_X_ATTRIBUTE_PRINTF(1, 2)
SecurityAudit(const char *format, ...)
{
    va_list args;

    if (auditTrailLevel < SECURITY_AUDIT_LEVEL)
        return;
    va_start(args, format);
    VAuditF(format, args);
    va_end(args);
}                               /* SecurityAudit */

/*
 * Performs a Security permission check.
 */
static int
SecurityDoCheck(SecurityStateRec * subj, SecurityStateRec * obj,
                Mask requested, Mask allowed)
{
    if (!subj->haveState || !obj->haveState)
        return Success;
    if (subj->trustLevel == XSecurityClientTrusted)
        return Success;
    if (obj->trustLevel != XSecurityClientTrusted)
        return Success;
    if ((requested | allowed) == allowed)
        return Success;

    return BadAccess;
}

/*
 * Labels initial server objects.
 */
static void
SecurityLabelInitial(void)
{
    SecurityStateRec *state;

    /* Do the serverClient */
    state = dixLookupPrivate(&serverClient->devPrivates, stateKey);
    state->trustLevel = XSecurityClientTrusted;
    state->haveState = TRUE;
    state->live = FALSE;
}

/*
 * Looks up a request name
 */
static _X_INLINE const char *
SecurityLookupRequestName(ClientPtr client)
{
    return LookupRequestName(client->majorOp, client->minorOp);
}

/* SecurityDeleteAuthorization
 *
 * Arguments:
 *	value is the authorization to delete.
 *	id is its resource ID.
 *
 * Returns: Success.
 *
 * Side Effects:
 *	Frees everything associated with the authorization.
 */

static int
SecurityDeleteAuthorization(void *value, XID id)
{
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr) value;
    unsigned short name_len, data_len;
    const char *name;
    char *data;
    int status;
    int i;
    OtherClientsPtr pEventClient;

    /* Remove the auth using the os layer auth manager */

    status = AuthorizationFromID(pAuth->id, &name_len, &name, &data_len, &data);
    assert(status);
    status = RemoveAuthorization(name_len, name, data_len, data);
    assert(status);
    (void) status;

    /* free the auth timer if there is one */

    if (pAuth->timer)
        TimerFree(pAuth->timer);

    /* send revoke events */

    while ((pEventClient = pAuth->eventClients)) {
        /* send revocation event event */
        xSecurityAuthorizationRevokedEvent are = {
            .type = SecurityEventBase + XSecurityAuthorizationRevoked,
            .authId = pAuth->id
        };
        WriteEventsToClient(rClient(pEventClient), 1, (xEvent *) &are);
        FreeResource(pEventClient->resource, RT_NONE);
    }

    /* kill all clients using this auth */

    for (i = 1; i < currentMaxClients; i++)
        if (clients[i]) {
            SecurityStateRec *state;

            state = dixLookupPrivate(&clients[i]->devPrivates, stateKey);
            if (state->haveState && state->authId == pAuth->id)
                CloseDownClient(clients[i]);
        }

    SecurityAudit("revoked authorization ID %lu\n", (unsigned long)pAuth->id);
    free(pAuth);
    return Success;

}                               /* SecurityDeleteAuthorization */

/* resource delete function for RTEventClient */
static int
SecurityDeleteAuthorizationEventClient(void *value, XID id)
{
    OtherClientsPtr pEventClient, prev = NULL;
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr) value;

    for (pEventClient = pAuth->eventClients;
         pEventClient; pEventClient = pEventClient->next) {
        if (pEventClient->resource == id) {
            if (prev)
                prev->next = pEventClient->next;
            else
                pAuth->eventClients = pEventClient->next;
            free(pEventClient);
            return Success;
        }
        prev = pEventClient;
    }
     /*NOTREACHED*/ return -1;  /* make compiler happy */
}                               /* SecurityDeleteAuthorizationEventClient */

/* SecurityComputeAuthorizationTimeout
 *
 * Arguments:
 *	pAuth is the authorization for which we are computing the timeout
 *	seconds is the number of seconds we want to wait
 *
 * Returns:
 *	the number of milliseconds that the auth timer should be set to
 *
 * Side Effects:
 *	Sets pAuth->secondsRemaining to any "overflow" amount of time
 *	that didn't fit in 32 bits worth of milliseconds
 */

static CARD32
SecurityComputeAuthorizationTimeout(SecurityAuthorizationPtr pAuth,
                                    unsigned int seconds)
{
    /* maxSecs is the number of full seconds that can be expressed in
     * 32 bits worth of milliseconds
     */
    CARD32 maxSecs = (CARD32) (~0) / (CARD32) MILLI_PER_SECOND;

    if (seconds > maxSecs) {    /* only come here if we want to wait more than 49 days */
        pAuth->secondsRemaining = seconds - maxSecs;
        return maxSecs * MILLI_PER_SECOND;
    }
    else {                      /* by far the common case */
        pAuth->secondsRemaining = 0;
        return seconds * MILLI_PER_SECOND;
    }
}                               /* SecurityStartAuthorizationTimer */

/* SecurityAuthorizationExpired
 *
 * This function is passed as an argument to TimerSet and gets called from
 * the timer manager in the os layer when its time is up.
 *
 * Arguments:
 *	timer is the timer for this authorization.
 *	time is the current time.
 *	pval is the authorization whose time is up.
 *
 * Returns:
 *	A new time delay in milliseconds if the timer should wait some
 *	more, else zero.
 *
 * Side Effects:
 *	Frees the authorization resource if the timeout period is really
 *	over, otherwise recomputes pAuth->secondsRemaining.
 */

static CARD32
SecurityAuthorizationExpired(OsTimerPtr timer, CARD32 time, void *pval)
{
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr) pval;

    assert(pAuth->timer == timer);

    if (pAuth->secondsRemaining) {
        return SecurityComputeAuthorizationTimeout(pAuth,
                                                   pAuth->secondsRemaining);
    }
    else {
        FreeResource(pAuth->id, RT_NONE);
        return 0;
    }
}                               /* SecurityAuthorizationExpired */

/* SecurityStartAuthorizationTimer
 *
 * Arguments:
 *	pAuth is the authorization whose timer should be started.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	A timer is started, set to expire after the timeout period for
 *	this authorization.  When it expires, the function
 *	SecurityAuthorizationExpired will be called.
 */

static void
SecurityStartAuthorizationTimer(SecurityAuthorizationPtr pAuth)
{
    pAuth->timer = TimerSet(pAuth->timer, 0,
                            SecurityComputeAuthorizationTimeout(pAuth,
                                                                pAuth->timeout),
                            SecurityAuthorizationExpired, pAuth);
}                               /* SecurityStartAuthorizationTimer */

/* Proc functions all take a client argument, execute the request in
 * client->requestBuffer, and return a protocol error status.
 */

static int
ProcSecurityQueryVersion(ClientPtr client)
{
    /* REQUEST(xSecurityQueryVersionReq); */
    xSecurityQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = SERVER_SECURITY_MAJOR_VERSION,
        .minorVersion = SERVER_SECURITY_MINOR_VERSION
    };

    REQUEST_SIZE_MATCH(xSecurityQueryVersionReq);

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swaps(&rep.majorVersion);
        swaps(&rep.minorVersion);
    }
    WriteToClient(client, SIZEOF(xSecurityQueryVersionReply), &rep);
    return Success;
}                               /* ProcSecurityQueryVersion */

static int
SecurityEventSelectForAuthorization(SecurityAuthorizationPtr pAuth,
                                    ClientPtr client, Mask mask)
{
    OtherClients *pEventClient;

    for (pEventClient = pAuth->eventClients;
         pEventClient; pEventClient = pEventClient->next) {
        if (SameClient(pEventClient, client)) {
            if (mask == 0)
                FreeResource(pEventClient->resource, RT_NONE);
            else
                pEventClient->mask = mask;
            return Success;
        }
    }

    pEventClient = malloc(sizeof(OtherClients));
    if (!pEventClient)
        return BadAlloc;
    pEventClient->mask = mask;
    pEventClient->resource = FakeClientID(client->index);
    pEventClient->next = pAuth->eventClients;
    if (!AddResource(pEventClient->resource, RTEventClient, (void *) pAuth)) {
        free(pEventClient);
        return BadAlloc;
    }
    pAuth->eventClients = pEventClient;

    return Success;
}                               /* SecurityEventSelectForAuthorization */

static int
ProcSecurityGenerateAuthorization(ClientPtr client)
{
    REQUEST(xSecurityGenerateAuthorizationReq);
    int len;                    /* request length in CARD32s */
    Bool removeAuth = FALSE;    /* if bailout, call RemoveAuthorization? */
    SecurityAuthorizationPtr pAuth = NULL;      /* auth we are creating */
    int err;                    /* error to return from this function */
    XID authId;                 /* authorization ID assigned by os layer */
    xSecurityGenerateAuthorizationReply rep;    /* reply struct */
    unsigned int trustLevel;    /* trust level of new auth */
    XID group;                  /* group of new auth */
    CARD32 timeout;             /* timeout of new auth */
    CARD32 *values;             /* list of supplied attributes */
    char *protoname;            /* auth proto name sent in request */
    char *protodata;            /* auth proto data sent in request */
    unsigned int authdata_len;  /* # bytes of generated auth data */
    char *pAuthdata;            /* generated auth data */
    Mask eventMask;             /* what events on this auth does client want */

    /* check request length */

    REQUEST_AT_LEAST_SIZE(xSecurityGenerateAuthorizationReq);
    len = bytes_to_int32(SIZEOF(xSecurityGenerateAuthorizationReq));
    len += bytes_to_int32(stuff->nbytesAuthProto);
    len += bytes_to_int32(stuff->nbytesAuthData);
    values = ((CARD32 *) stuff) + len;
    len += Ones(stuff->valueMask);
    if (client->req_len != len)
        return BadLength;

    /* check valuemask */
    if (stuff->valueMask & ~XSecurityAllAuthorizationAttributes) {
        client->errorValue = stuff->valueMask;
        return BadValue;
    }

    /* check timeout */
    timeout = 60;
    if (stuff->valueMask & XSecurityTimeout) {
        timeout = *values++;
    }

    /* check trustLevel */
    trustLevel = XSecurityClientUntrusted;
    if (stuff->valueMask & XSecurityTrustLevel) {
        trustLevel = *values++;
        if (trustLevel != XSecurityClientTrusted &&
            trustLevel != XSecurityClientUntrusted) {
            client->errorValue = trustLevel;
            return BadValue;
        }
    }

    /* check group */
    group = None;
    if (stuff->valueMask & XSecurityGroup) {
        group = *values++;
        if (SecurityValidateGroupCallback) {
            SecurityValidateGroupInfoRec vgi;

            vgi.group = group;
            vgi.valid = FALSE;
            CallCallbacks(&SecurityValidateGroupCallback, (void *) &vgi);

            /* if nobody said they recognized it, it's an error */

            if (!vgi.valid) {
                client->errorValue = group;
                return BadValue;
            }
        }
    }

    /* check event mask */
    eventMask = 0;
    if (stuff->valueMask & XSecurityEventMask) {
        eventMask = *values++;
        if (eventMask & ~XSecurityAllEventMasks) {
            client->errorValue = eventMask;
            return BadValue;
        }
    }

    protoname = (char *) &stuff[1];
    protodata = protoname + bytes_to_int32(stuff->nbytesAuthProto);

    /* call os layer to generate the authorization */

    authId = GenerateAuthorization(stuff->nbytesAuthProto, protoname,
                                   stuff->nbytesAuthData, protodata,
                                   &authdata_len, &pAuthdata);
    if ((XID) ~0L == authId) {
        err = SecurityErrorBase + XSecurityBadAuthorizationProtocol;
        goto bailout;
    }

    /* now that we've added the auth, remember to remove it if we have to
     * abort the request for some reason (like allocation failure)
     */
    removeAuth = TRUE;

    /* associate additional information with this auth ID */

    pAuth = malloc(sizeof(SecurityAuthorizationRec));
    if (!pAuth) {
        err = BadAlloc;
        goto bailout;
    }

    /* fill in the auth fields */

    pAuth->id = authId;
    pAuth->timeout = timeout;
    pAuth->group = group;
    pAuth->trustLevel = trustLevel;
    pAuth->refcnt = 0;          /* the auth was just created; nobody's using it yet */
    pAuth->secondsRemaining = 0;
    pAuth->timer = NULL;
    pAuth->eventClients = NULL;

    /* handle event selection */
    if (eventMask) {
        err = SecurityEventSelectForAuthorization(pAuth, client, eventMask);
        if (err != Success)
            goto bailout;
    }

    if (!AddResource(authId, SecurityAuthorizationResType, pAuth)) {
        err = BadAlloc;
        goto bailout;
    }

    /* start the timer ticking */

    if (pAuth->timeout != 0)
        SecurityStartAuthorizationTimer(pAuth);

    /* tell client the auth id and data */

    rep = (xSecurityGenerateAuthorizationReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(authdata_len),
        .authId = authId,
        .dataLength = authdata_len
    };

    if (client->swapped) {
        swapl(&rep.length);
        swaps(&rep.sequenceNumber);
        swapl(&rep.authId);
        swaps(&rep.dataLength);
    }

    WriteToClient(client, SIZEOF(xSecurityGenerateAuthorizationReply), &rep);
    WriteToClient(client, authdata_len, pAuthdata);

    SecurityAudit
        ("client %d generated authorization %lu trust %d timeout %lu group %lu events %lu\n",
         client->index, (unsigned long)pAuth->id, pAuth->trustLevel, (unsigned long)pAuth->timeout,
         (unsigned long)pAuth->group, (unsigned long)eventMask);

    /* the request succeeded; don't call RemoveAuthorization or free pAuth */
    return Success;

 bailout:
    if (removeAuth)
        RemoveAuthorization(stuff->nbytesAuthProto, protoname,
                            authdata_len, pAuthdata);
    free(pAuth);
    return err;

}                               /* ProcSecurityGenerateAuthorization */

static int
ProcSecurityRevokeAuthorization(ClientPtr client)
{
    REQUEST(xSecurityRevokeAuthorizationReq);
    SecurityAuthorizationPtr pAuth;
    int rc;

    REQUEST_SIZE_MATCH(xSecurityRevokeAuthorizationReq);

    rc = dixLookupResourceByType((void **) &pAuth, stuff->authId,
                                 SecurityAuthorizationResType, client,
                                 DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->authId, RT_NONE);
    return Success;
}                               /* ProcSecurityRevokeAuthorization */

static int
ProcSecurityDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_SecurityQueryVersion:
        return ProcSecurityQueryVersion(client);
    case X_SecurityGenerateAuthorization:
        return ProcSecurityGenerateAuthorization(client);
    case X_SecurityRevokeAuthorization:
        return ProcSecurityRevokeAuthorization(client);
    default:
        return BadRequest;
    }
}                               /* ProcSecurityDispatch */

static int
SProcSecurityQueryVersion(ClientPtr client)
{
    REQUEST(xSecurityQueryVersionReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSecurityQueryVersionReq);
    swaps(&stuff->majorVersion);
    swaps(&stuff->minorVersion);
    return ProcSecurityQueryVersion(client);
}                               /* SProcSecurityQueryVersion */

static int
SProcSecurityGenerateAuthorization(ClientPtr client)
{
    REQUEST(xSecurityGenerateAuthorizationReq);
    CARD32 *values;
    unsigned long nvalues;
    int values_offset;

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xSecurityGenerateAuthorizationReq);
    swaps(&stuff->nbytesAuthProto);
    swaps(&stuff->nbytesAuthData);
    swapl(&stuff->valueMask);
    values_offset = bytes_to_int32(stuff->nbytesAuthProto) +
        bytes_to_int32(stuff->nbytesAuthData);
    if (values_offset >
        stuff->length - bytes_to_int32(sz_xSecurityGenerateAuthorizationReq))
        return BadLength;
    values = (CARD32 *) (&stuff[1]) + values_offset;
    nvalues = (((CARD32 *) stuff) + stuff->length) - values;
    SwapLongs(values, nvalues);
    return ProcSecurityGenerateAuthorization(client);
}                               /* SProcSecurityGenerateAuthorization */

static int
SProcSecurityRevokeAuthorization(ClientPtr client)
{
    REQUEST(xSecurityRevokeAuthorizationReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSecurityRevokeAuthorizationReq);
    swapl(&stuff->authId);
    return ProcSecurityRevokeAuthorization(client);
}                               /* SProcSecurityRevokeAuthorization */

static int
SProcSecurityDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_SecurityQueryVersion:
        return SProcSecurityQueryVersion(client);
    case X_SecurityGenerateAuthorization:
        return SProcSecurityGenerateAuthorization(client);
    case X_SecurityRevokeAuthorization:
        return SProcSecurityRevokeAuthorization(client);
    default:
        return BadRequest;
    }
}                               /* SProcSecurityDispatch */

static void
SwapSecurityAuthorizationRevokedEvent(xSecurityAuthorizationRevokedEvent * from,
                                      xSecurityAuthorizationRevokedEvent * to)
{
    to->type = from->type;
    to->detail = from->detail;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->authId, to->authId);
}

/* SecurityCheckDeviceAccess
 *
 * Arguments:
 *	client is the client attempting to access a device.
 *	dev is the device being accessed.
 *	fromRequest is TRUE if the device access is a direct result of
 *	  the client executing some request and FALSE if it is a
 *	  result of the server trying to send an event (e.g. KeymapNotify)
 *	  to the client.
 * Returns:
 *	TRUE if the device access should be allowed, else FALSE.
 *
 * Side Effects:
 *	An audit message is generated if access is denied.
 */

static void
SecurityDevice(CallbackListPtr *pcbl, void *unused, void *calldata)
{
    XaceDeviceAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityDeviceMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&serverClient->devPrivates, stateKey);

    if (rec->dev != inputInfo.keyboard)
        /* this extension only supports the core keyboard */
        allowed = requested;

    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
        SecurityAudit("Security denied client %d keyboard access on request "
                      "%s\n", rec->client->index,
                      SecurityLookupRequestName(rec->client));
        rec->status = BadAccess;
    }
}

/* SecurityResource
 *
 * This function gets plugged into client->CheckAccess and is called from
 * SecurityLookupIDByType/Class to determine if the client can access the
 * resource.
 *
 * Arguments:
 *	client is the client doing the resource access.
 *	id is the resource id.
 *	rtype is its type or class.
 *	access_mode represents the intended use of the resource; see
 *	  resource.h.
 *	res is a pointer to the resource structure for this resource.
 *
 * Returns:
 *	If access is granted, the value of rval that was passed in, else FALSE.
 *
 * Side Effects:
 *	Disallowed resource accesses are audited.
 */

static void
SecurityResource(CallbackListPtr *pcbl, void *unused, void *calldata)
{
    XaceResourceAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    int cid = CLIENT_ID(rec->id);
    Mask requested = rec->access_mode;
    Mask allowed = SecurityResourceMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);

    /* disable background None for untrusted windows */
    if ((requested & DixCreateAccess) && (rec->rtype == RT_WINDOW))
        if (subj->haveState && subj->trustLevel != XSecurityClientTrusted)
            ((WindowPtr) rec->res)->forcedBG = TRUE;

    /* additional permissions for specific resource types */
    if (rec->rtype == RT_WINDOW)
        allowed |= SecurityWindowExtraMask;

    /* special checks for server-owned resources */
    if (cid == 0) {
        if (rec->rtype & RC_DRAWABLE)
            /* additional operations allowed on root windows */
            allowed |= SecurityRootWindowExtraMask;

        else if (rec->rtype == RT_COLORMAP)
            /* allow access to default colormaps */
            allowed = requested;

        else
            /* allow read access to other server-owned resources */
            allowed |= DixReadAccess;
    }

    if (clients[cid] != NULL) {
        obj = dixLookupPrivate(&clients[cid]->devPrivates, stateKey);
        if (SecurityDoCheck(subj, obj, requested, allowed) == Success)
            return;
    }

    SecurityAudit("Security: denied client %d access %lx to resource 0x%lx "
                  "of client %d on request %s\n", rec->client->index,
                  (unsigned long)requested, (unsigned long)rec->id, cid,
                  SecurityLookupRequestName(rec->client));
    rec->status = BadAccess;    /* deny access */
}

static void
SecurityExtension(CallbackListPtr *pcbl, void *unused, void *calldata)
{
    XaceExtAccessRec *rec = calldata;
    SecurityStateRec *subj;
    int i = 0;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);

    if (subj->haveState && subj->trustLevel == XSecurityClientTrusted)
        return;

    while (SecurityTrustedExtensions[i])
        if (!strcmp(SecurityTrustedExtensions[i++], rec->ext->name))
            return;

    SecurityAudit("Security: denied client %d access to extension "
                  "%s on request %s\n",
                  rec->client->index, rec->ext->name,
                  SecurityLookupRequestName(rec->client));
    rec->status = BadAccess;
}

static void
SecurityServer(CallbackListPtr *pcbl, void *unused, void *calldata)
{
    XaceServerAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityServerMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&serverClient->devPrivates, stateKey);

    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
        SecurityAudit("Security: denied client %d access to server "
                      "configuration request %s\n", rec->client->index,
                      SecurityLookupRequestName(rec->client));
        rec->status = BadAccess;
    }
}

static void
SecurityClient(CallbackListPtr *pcbl, void *unused, void *calldata)
{
    XaceClientAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityClientMask;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&rec->target->devPrivates, stateKey);

    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
        SecurityAudit("Security: denied client %d access to client %d on "
                      "request %s\n", rec->client->index, rec->target->index,
                      SecurityLookupRequestName(rec->client));
        rec->status = BadAccess;
    }
}

static void
SecurityProperty(CallbackListPtr *pcbl, void *unused, void *calldata)
{
    XacePropertyAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;
    ATOM name = (*rec->ppProp)->propertyName;
    Mask requested = rec->access_mode;
    Mask allowed = SecurityResourceMask | DixReadAccess;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&wClient(rec->pWin)->devPrivates, stateKey);

    if (SecurityDoCheck(subj, obj, requested, allowed) != Success) {
        SecurityAudit("Security: denied client %d access to property %s "
                      "(atom 0x%x) window 0x%lx of client %d on request %s\n",
                      rec->client->index, NameForAtom(name), name,
                      (unsigned long)rec->pWin->drawable.id, wClient(rec->pWin)->index,
                      SecurityLookupRequestName(rec->client));
        rec->status = BadAccess;
    }
}

static void
SecuritySend(CallbackListPtr *pcbl, void *unused, void *calldata)
{
    XaceSendAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;

    if (rec->client) {
        int i;

        subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
        obj = dixLookupPrivate(&wClient(rec->pWin)->devPrivates, stateKey);

        if (SecurityDoCheck(subj, obj, DixSendAccess, 0) == Success)
            return;

        for (i = 0; i < rec->count; i++)
            if (rec->events[i].u.u.type != UnmapNotify &&
                rec->events[i].u.u.type != ConfigureRequest &&
                rec->events[i].u.u.type != ClientMessage) {

                SecurityAudit("Security: denied client %d from sending event "
                              "of type %s to window 0x%lx of client %d\n",
                              rec->client->index,
                              LookupEventName(rec->events[i].u.u.type),
                              (unsigned long)rec->pWin->drawable.id,
                              wClient(rec->pWin)->index);
                rec->status = BadAccess;
                return;
            }
    }
}

static void
SecurityReceive(CallbackListPtr *pcbl, void *unused, void *calldata)
{
    XaceReceiveAccessRec *rec = calldata;
    SecurityStateRec *subj, *obj;

    subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
    obj = dixLookupPrivate(&wClient(rec->pWin)->devPrivates, stateKey);

    if (SecurityDoCheck(subj, obj, DixReceiveAccess, 0) == Success)
        return;

    SecurityAudit("Security: denied client %d from receiving an event "
                  "sent to window 0x%lx of client %d\n",
                  rec->client->index, (unsigned long)rec->pWin->drawable.id,
                  wClient(rec->pWin)->index);
    rec->status = BadAccess;
}

/* SecurityClientStateCallback
 *
 * Arguments:
 *	pcbl is &ClientStateCallback.
 *	nullata is NULL.
 *	calldata is a pointer to a NewClientInfoRec (include/dixstruct.h)
 *	which contains information about client state changes.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *
 * If a new client is connecting, its authorization ID is copied to
 * client->authID.  If this is a generated authorization, its reference
 * count is bumped, its timer is cancelled if it was running, and its
 * trustlevel is copied to TRUSTLEVEL(client).
 *
 * If a client is disconnecting and the client was using a generated
 * authorization, the authorization's reference count is decremented, and
 * if it is now zero, the timer for this authorization is started.
 */

static void
SecurityClientState(CallbackListPtr *pcbl, void *unused, void *calldata)
{
    NewClientInfoRec *pci = calldata;
    SecurityStateRec *state;
    SecurityAuthorizationPtr pAuth;
    int rc;

    state = dixLookupPrivate(&pci->client->devPrivates, stateKey);

    switch (pci->client->clientState) {
    case ClientStateInitial:
        state->trustLevel = XSecurityClientTrusted;
        state->authId = None;
        state->haveState = TRUE;
        state->live = FALSE;
        break;

    case ClientStateRunning:
        state->authId = AuthorizationIDOfClient(pci->client);
        rc = dixLookupResourceByType((void **) &pAuth, state->authId,
                                     SecurityAuthorizationResType, serverClient,
                                     DixGetAttrAccess);
        if (rc == Success) {
            /* it is a generated authorization */
            pAuth->refcnt++;
            state->live = TRUE;
            if (pAuth->refcnt == 1 && pAuth->timer)
                TimerCancel(pAuth->timer);

            state->trustLevel = pAuth->trustLevel;
        }
        break;

    case ClientStateGone:
    case ClientStateRetained:
        rc = dixLookupResourceByType((void **) &pAuth, state->authId,
                                     SecurityAuthorizationResType, serverClient,
                                     DixGetAttrAccess);
        if (rc == Success && state->live) {
            /* it is a generated authorization */
            pAuth->refcnt--;
            state->live = FALSE;
            if (pAuth->refcnt == 0)
                SecurityStartAuthorizationTimer(pAuth);
        }
        break;

    default:
        break;
    }
}

/* SecurityResetProc
 *
 * Arguments:
 *	extEntry is the extension information for the security extension.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Performs any cleanup needed by Security at server shutdown time.
 */

static void
SecurityResetProc(ExtensionEntry * extEntry)
{
    /* Unregister callbacks */
    DeleteCallback(&ClientStateCallback, SecurityClientState, NULL);

    XaceDeleteCallback(XACE_EXT_DISPATCH, SecurityExtension, NULL);
    XaceDeleteCallback(XACE_RESOURCE_ACCESS, SecurityResource, NULL);
    XaceDeleteCallback(XACE_DEVICE_ACCESS, SecurityDevice, NULL);
    XaceDeleteCallback(XACE_PROPERTY_ACCESS, SecurityProperty, NULL);
    XaceDeleteCallback(XACE_SEND_ACCESS, SecuritySend, NULL);
    XaceDeleteCallback(XACE_RECEIVE_ACCESS, SecurityReceive, NULL);
    XaceDeleteCallback(XACE_CLIENT_ACCESS, SecurityClient, NULL);
    XaceDeleteCallback(XACE_EXT_ACCESS, SecurityExtension, NULL);
    XaceDeleteCallback(XACE_SERVER_ACCESS, SecurityServer, NULL);
}

/* SecurityExtensionInit
 *
 * Arguments: none.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Enables the Security extension if possible.
 */

void
SecurityExtensionInit(void)
{
    ExtensionEntry *extEntry;
    int ret = TRUE;

    SecurityAuthorizationResType =
        CreateNewResourceType(SecurityDeleteAuthorization,
                              "SecurityAuthorization");

    RTEventClient =
        CreateNewResourceType(SecurityDeleteAuthorizationEventClient,
                              "SecurityEventClient");

    if (!SecurityAuthorizationResType || !RTEventClient)
        return;

    RTEventClient |= RC_NEVERRETAIN;

    /* Allocate the private storage */
    if (!dixRegisterPrivateKey
        (stateKey, PRIVATE_CLIENT, sizeof(SecurityStateRec)))
        FatalError("SecurityExtensionSetup: Can't allocate client private.\n");

    /* Register callbacks */
    ret &= AddCallback(&ClientStateCallback, SecurityClientState, NULL);

    ret &= XaceRegisterCallback(XACE_EXT_DISPATCH, SecurityExtension, NULL);
    ret &= XaceRegisterCallback(XACE_RESOURCE_ACCESS, SecurityResource, NULL);
    ret &= XaceRegisterCallback(XACE_DEVICE_ACCESS, SecurityDevice, NULL);
    ret &= XaceRegisterCallback(XACE_PROPERTY_ACCESS, SecurityProperty, NULL);
    ret &= XaceRegisterCallback(XACE_SEND_ACCESS, SecuritySend, NULL);
    ret &= XaceRegisterCallback(XACE_RECEIVE_ACCESS, SecurityReceive, NULL);
    ret &= XaceRegisterCallback(XACE_CLIENT_ACCESS, SecurityClient, NULL);
    ret &= XaceRegisterCallback(XACE_EXT_ACCESS, SecurityExtension, NULL);
    ret &= XaceRegisterCallback(XACE_SERVER_ACCESS, SecurityServer, NULL);

    if (!ret)
        FatalError("SecurityExtensionSetup: Failed to register callbacks\n");

    /* Add extension to server */
    extEntry = AddExtension(SECURITY_EXTENSION_NAME,
                            XSecurityNumberEvents, XSecurityNumberErrors,
                            ProcSecurityDispatch, SProcSecurityDispatch,
                            SecurityResetProc, StandardMinorOpcode);

    SecurityErrorBase = extEntry->errorBase;
    SecurityEventBase = extEntry->eventBase;

    EventSwapVector[SecurityEventBase + XSecurityAuthorizationRevoked] =
        (EventSwapPtr) SwapSecurityAuthorizationRevokedEvent;

    SetResourceTypeErrorValue(SecurityAuthorizationResType,
                              SecurityErrorBase + XSecurityBadAuthorization);

    /* Label objects that were created before we could register ourself */
    SecurityLabelInitial();
}
@


1.15
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d215 1
a215 1
    SecurityAudit("revoked authorization ID %d\n", pAuth->id);
d552 3
a554 3
        ("client %d generated authorization %d trust %d timeout %d group %d events %d\n",
         client->index, pAuth->id, pAuth->trustLevel, pAuth->timeout,
         pAuth->group, eventMask);
d779 1
a779 1
    SecurityAudit("Security: denied client %d access %x to resource 0x%x "
d781 1
a781 1
                  requested, rec->id, cid,
d861 1
a861 1
                      "(atom 0x%x) window 0x%x of client %d on request %s\n",
d863 1
a863 1
                      rec->pWin->drawable.id, wClient(rec->pWin)->index,
d890 1
a890 1
                              "of type %s to window 0x%x of client %d\n",
d893 1
a893 1
                              rec->pWin->drawable.id,
d914 2
a915 2
                  "sent to window 0x%x of client %d\n",
                  rec->client->index, rec->pWin->drawable.id,
@


1.14
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a69 1
    "XpExtension",
d931 1
a931 1
 * 
d936 1
a936 1
 * 
@


1.13
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d170 1
a170 1
SecurityDeleteAuthorization(pointer value, XID id)
d224 1
a224 1
SecurityDeleteAuthorizationEventClient(pointer value, XID id)
d297 1
a297 1
SecurityAuthorizationExpired(OsTimerPtr timer, CARD32 time, pointer pval)
d385 1
a385 1
    if (!AddResource(pEventClient->resource, RTEventClient, (pointer) pAuth)) {
d457 1
a457 1
            CallCallbacks(&SecurityValidateGroupCallback, (pointer) &vgi);
d578 1
a578 1
    rc = dixLookupResourceByType((pointer *) &pAuth, stuff->authId,
d696 1
a696 1
SecurityDevice(CallbackListPtr *pcbl, pointer unused, pointer calldata)
d740 1
a740 1
SecurityResource(CallbackListPtr *pcbl, pointer unused, pointer calldata)
d788 1
a788 1
SecurityExtension(CallbackListPtr *pcbl, pointer unused, pointer calldata)
d811 1
a811 1
SecurityServer(CallbackListPtr *pcbl, pointer unused, pointer calldata)
d830 1
a830 1
SecurityClient(CallbackListPtr *pcbl, pointer unused, pointer calldata)
d849 1
a849 1
SecurityProperty(CallbackListPtr *pcbl, pointer unused, pointer calldata)
d871 1
a871 1
SecuritySend(CallbackListPtr *pcbl, pointer unused, pointer calldata)
d903 1
a903 1
SecurityReceive(CallbackListPtr *pcbl, pointer unused, pointer calldata)
d944 1
a944 1
SecurityClientState(CallbackListPtr *pcbl, pointer unused, pointer calldata)
d963 1
a963 1
        rc = dixLookupResourceByType((pointer *) &pAuth, state->authId,
d979 1
a979 1
        rc = dixLookupResourceByType((pointer *) &pAuth, state->authId,
@


1.12
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d60 3
a62 2
    int haveState;
    unsigned int trustLevel;
d145 1
d958 1
d969 1
d982 1
a982 1
        if (rc == Success) {
d985 1
@


1.11
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d41 1
a41 1
#include "modinit.h"
d195 4
a198 4
        xSecurityAuthorizationRevokedEvent are;

        are.type = SecurityEventBase + XSecurityAuthorizationRevoked;
        are.authId = pAuth->id;
d341 7
a347 1
    xSecurityQueryVersionReply rep;
d350 1
a350 5
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.majorVersion = SERVER_SECURITY_MAJOR_VERSION;
    rep.minorVersion = SERVER_SECURITY_MINOR_VERSION;
d356 1
a356 2
    (void) WriteToClient(client, SIZEOF(xSecurityQueryVersionReply),
                         (char *) &rep);
d532 7
a538 5
    rep.type = X_Reply;
    rep.length = bytes_to_int32(authdata_len);
    rep.sequenceNumber = client->sequence;
    rep.authId = authId;
    rep.dataLength = authdata_len;
d547 1
a547 2
    WriteToClient(client, SIZEOF(xSecurityGenerateAuthorizationReply),
                  (char *) &rep);
d1030 1
a1030 1
SecurityExtensionInit(INITARGS)
@


1.10
log
@Update to xserver 1.11.4. tested by krw@@, shadchin@@.
@
text
@d45 2
a46 2
static int SecurityErrorBase;  /* first Security error number */
static int SecurityEventBase;  /* first Security event number */
d48 1
a48 1
RESTYPE SecurityAuthorizationResType; /* resource type for authorizations */
d55 1
d66 1
a66 1
static char *SecurityTrustedExtensions[] = {
a87 1

d101 2
a102 1
SecurityAudit(char *format, ...)
d107 1
a107 1
	return;
d111 1
a111 1
} /* SecurityAudit */
d117 2
a118 2
SecurityDoCheck(SecurityStateRec *subj, SecurityStateRec *obj,
		Mask requested, Mask allowed)
d121 1
a121 1
	return Success;
d123 1
a123 1
	return Success;
d125 1
a125 1
	return Success;
d127 1
a127 1
	return Success;
a154 1

d168 1
a168 3
SecurityDeleteAuthorization(
    pointer value,
    XID id)
d170 1
a170 1
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr)value;
d172 2
a173 1
    char *name, *data;
d180 1
a180 2
    status = AuthorizationFromID(pAuth->id, &name_len, &name,
				 &data_len, &data);
d184 1
a184 1
    (void)status;
d188 2
a189 1
    if (pAuth->timer) TimerFree(pAuth->timer);
d193 8
a200 8
    while ((pEventClient = pAuth->eventClients))
    {
	/* send revocation event event */
	xSecurityAuthorizationRevokedEvent are;
	are.type = SecurityEventBase + XSecurityAuthorizationRevoked;
	are.authId = pAuth->id;
	WriteEventsToClient(rClient(pEventClient), 1, (xEvent *)&are);
	FreeResource(pEventClient->resource, RT_NONE);
d205 8
a212 7
    for (i = 1; i<currentMaxClients; i++)
	if (clients[i]) {
	    SecurityStateRec *state;
	    state = dixLookupPrivate(&clients[i]->devPrivates, stateKey);
	    if (state->haveState && state->authId == pAuth->id)
		CloseDownClient(clients[i]);
	}
d218 1
a218 2
} /* SecurityDeleteAuthorization */

d222 1
a222 3
SecurityDeleteAuthorizationEventClient(
    pointer value,
    XID id)
d225 1
a225 1
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr)value;
d228 13
a240 18
	 pEventClient;
	 pEventClient = pEventClient->next)
    {
	if (pEventClient->resource == id)
	{
	    if (prev)
		prev->next = pEventClient->next;
	    else
		pAuth->eventClients = pEventClient->next;
	    free(pEventClient);
	    return Success;
	}
	prev = pEventClient;
    }
    /*NOTREACHED*/
    return -1; /* make compiler happy */
} /* SecurityDeleteAuthorizationEventClient */

d257 2
a258 3
SecurityComputeAuthorizationTimeout(
    SecurityAuthorizationPtr pAuth,
    unsigned int seconds)
d263 1
a263 1
    CARD32 maxSecs = (CARD32)(~0) / (CARD32)MILLI_PER_SECOND;
d265 7
a271 9
    if (seconds > maxSecs)
    { /* only come here if we want to wait more than 49 days */
	pAuth->secondsRemaining = seconds - maxSecs;
	return maxSecs * MILLI_PER_SECOND;
    }
    else
    { /* by far the common case */
	pAuth->secondsRemaining = 0;
	return seconds * MILLI_PER_SECOND;
d273 1
a273 1
} /* SecurityStartAuthorizationTimer */
d295 1
a295 4
SecurityAuthorizationExpired(
    OsTimerPtr timer,
    CARD32 time,
    pointer pval)
d297 1
a297 1
    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr)pval;
d301 7
a307 9
    if (pAuth->secondsRemaining)
    {
	return SecurityComputeAuthorizationTimeout(pAuth,
						   pAuth->secondsRemaining);
    }
    else
    {
	FreeResource(pAuth->id, RT_NONE);
	return 0;
d309 1
a309 1
} /* SecurityAuthorizationExpired */
d325 1
a325 2
SecurityStartAuthorizationTimer(
    SecurityAuthorizationPtr pAuth)
d328 4
a331 4
	SecurityComputeAuthorizationTimeout(pAuth, pAuth->timeout),
			    SecurityAuthorizationExpired, pAuth);
} /* SecurityStartAuthorizationTimer */

d338 1
a338 2
ProcSecurityQueryVersion(
    ClientPtr client)
d341 1
a341 1
    xSecurityQueryVersionReply 	rep;
d344 9
a352 11
    rep.type        	= X_Reply;
    rep.sequenceNumber 	= client->sequence;
    rep.length         	= 0;
    rep.majorVersion  	= SERVER_SECURITY_MAJOR_VERSION;
    rep.minorVersion  	= SERVER_SECURITY_MINOR_VERSION;
    if(client->swapped)
    {
	char n;
    	swaps(&rep.sequenceNumber, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
d354 2
a355 2
    (void)WriteToClient(client, SIZEOF(xSecurityQueryVersionReply),
			(char *)&rep);
d357 1
a357 2
} /* ProcSecurityQueryVersion */

d360 2
a361 4
SecurityEventSelectForAuthorization(
    SecurityAuthorizationPtr pAuth,
    ClientPtr client,
    Mask mask)
d366 8
a373 11
	 pEventClient;
	 pEventClient = pEventClient->next)
    {
	if (SameClient(pEventClient, client))
	{
	    if (mask == 0)
		FreeResource(pEventClient->resource, RT_NONE);
	    else
		pEventClient->mask = mask;
	    return Success;
	}
d375 1
a375 1
    
d378 1
a378 1
	return BadAlloc;
d382 3
a384 5
    if (!AddResource(pEventClient->resource, RTEventClient,
		     (pointer)pAuth))
    {
	free(pEventClient);
	return BadAlloc;
d389 1
a389 2
} /* SecurityEventSelectForAuthorization */

d392 1
a392 2
ProcSecurityGenerateAuthorization(
    ClientPtr client)
d395 6
a400 6
    int len;			/* request length in CARD32s*/
    Bool removeAuth = FALSE;	/* if bailout, call RemoveAuthorization? */
    SecurityAuthorizationPtr pAuth = NULL;  /* auth we are creating */
    int err;			/* error to return from this function */
    XID authId;			/* authorization ID assigned by os layer */
    xSecurityGenerateAuthorizationReply rep; /* reply struct */
d402 5
a406 5
    XID group;			/* group of new auth */
    CARD32 timeout;		/* timeout of new auth */
    CARD32 *values;		/* list of supplied attributes */
    char *protoname;		/* auth proto name sent in request */
    char *protodata;		/* auth proto data sent in request */
d408 2
a409 2
    char *pAuthdata;		/* generated auth data */
    Mask eventMask;		/* what events on this auth does client want */
d417 1
a417 1
    values = ((CARD32 *)stuff) + len;
d420 1
a420 1
	return BadLength;
d423 3
a425 4
    if (stuff->valueMask & ~XSecurityAllAuthorizationAttributes)
    {
	client->errorValue = stuff->valueMask;
	return BadValue;
d430 2
a431 3
    if (stuff->valueMask & XSecurityTimeout)
    {
	timeout = *values++;
d436 7
a442 9
    if (stuff->valueMask & XSecurityTrustLevel)
    {
	trustLevel = *values++;
	if (trustLevel != XSecurityClientTrusted &&
	    trustLevel != XSecurityClientUntrusted)
	{
	    client->errorValue = trustLevel;
	    return BadValue;
	}
d447 16
a462 18
    if (stuff->valueMask & XSecurityGroup)
    {
	group = *values++;
	if (SecurityValidateGroupCallback)
	{
	    SecurityValidateGroupInfoRec vgi;
	    vgi.group = group;
	    vgi.valid = FALSE;
	    CallCallbacks(&SecurityValidateGroupCallback, (pointer)&vgi);

	    /* if nobody said they recognized it, it's an error */

	    if (!vgi.valid)
	    {
		client->errorValue = group;
		return BadValue;
	    }
	}
d467 6
a472 8
    if (stuff->valueMask & XSecurityEventMask)
    {
	eventMask = *values++;
	if (eventMask & ~XSecurityAllEventMasks)
	{
	    client->errorValue = eventMask;
	    return BadValue;
	}
d475 1
a475 1
    protoname = (char *)&stuff[1];
d481 5
a485 6
				   stuff->nbytesAuthData,  protodata,
				   &authdata_len, &pAuthdata);
    if ((XID) ~0L == authId)
    {
	err = SecurityErrorBase + XSecurityBadAuthorizationProtocol;
	goto bailout;
d496 3
a498 4
    if (!pAuth)
    {
	err = BadAlloc;
	goto bailout;
d507 1
a507 1
    pAuth->refcnt = 0;	/* the auth was just created; nobody's using it yet */
d513 4
a516 5
    if (eventMask)
    {
	err = SecurityEventSelectForAuthorization(pAuth, client, eventMask);
	if (err != Success)
	    goto bailout;
d519 3
a521 4
    if (!AddResource(authId, SecurityAuthorizationResType, pAuth))
    {
	err = BadAlloc;
	goto bailout;
d527 1
a527 1
	SecurityStartAuthorizationTimer(pAuth);
d537 5
a541 7
    if (client->swapped)
    {
	char n;
    	swapl(&rep.length, n);
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.authId, n);
    	swaps(&rep.dataLength, n);
d545 1
a545 1
		  (char *)&rep);
d548 4
a551 3
    SecurityAudit("client %d generated authorization %d trust %d timeout %d group %d events %d\n",
		  client->index, pAuth->id, pAuth->trustLevel, pAuth->timeout,
		  pAuth->group, eventMask);
d556 1
a556 1
bailout:
d558 2
a559 2
	RemoveAuthorization(stuff->nbytesAuthProto, protoname,
			    authdata_len, pAuthdata);
d563 1
a563 1
} /* ProcSecurityGenerateAuthorization */
d566 1
a566 2
ProcSecurityRevokeAuthorization(
    ClientPtr client)
d574 3
a576 3
    rc = dixLookupResourceByType((pointer *)&pAuth, stuff->authId,
				 SecurityAuthorizationResType, client,
				 DixDestroyAccess);
d578 1
a578 1
	return rc;
d582 1
a582 2
} /* ProcSecurityRevokeAuthorization */

d585 1
a585 2
ProcSecurityDispatch(
    ClientPtr client)
d589 9
a597 10
    switch (stuff->data)
    {
	case X_SecurityQueryVersion:
	    return ProcSecurityQueryVersion(client);
	case X_SecurityGenerateAuthorization:
	    return ProcSecurityGenerateAuthorization(client);
	case X_SecurityRevokeAuthorization:
	    return ProcSecurityRevokeAuthorization(client);
	default:
	    return BadRequest;
d599 1
a599 1
} /* ProcSecurityDispatch */
d602 1
a602 2
SProcSecurityQueryVersion(
    ClientPtr client)
a604 1
    char	n;
d606 1
a606 1
    swaps(&stuff->length, n);
d608 2
a609 2
    swaps(&stuff->majorVersion, n);
    swaps(&stuff->minorVersion,n);
d611 1
a611 2
} /* SProcSecurityQueryVersion */

d614 1
a614 2
SProcSecurityGenerateAuthorization(
    ClientPtr client)
a616 1
    char	n;
d621 1
a621 1
    swaps(&stuff->length, n);
d623 3
a625 3
    swaps(&stuff->nbytesAuthProto, n);
    swaps(&stuff->nbytesAuthData, n);
    swapl(&stuff->valueMask, n);
d627 6
a632 6
		    bytes_to_int32(stuff->nbytesAuthData);
    if (values_offset > 
	stuff->length - bytes_to_int32(sz_xSecurityGenerateAuthorizationReq))
	return BadLength;
    values = (CARD32 *)(&stuff[1]) + values_offset;
    nvalues = (((CARD32 *)stuff) + stuff->length) - values;
d635 1
a635 2
} /* SProcSecurityGenerateAuthorization */

d638 1
a638 2
SProcSecurityRevokeAuthorization(
    ClientPtr client)
a640 1
    char	n;
d642 1
a642 1
    swaps(&stuff->length, n);
d644 1
a644 1
    swapl(&stuff->authId, n);
d646 1
a646 2
} /* SProcSecurityRevokeAuthorization */

d649 1
a649 2
SProcSecurityDispatch(
    ClientPtr client)
d653 15
a667 17
    switch (stuff->data)
    {
	case X_SecurityQueryVersion:
	    return SProcSecurityQueryVersion(client);
	case X_SecurityGenerateAuthorization:
	    return SProcSecurityGenerateAuthorization(client);
	case X_SecurityRevokeAuthorization:
	    return SProcSecurityRevokeAuthorization(client);
	default:
	    return BadRequest;
    }
} /* SProcSecurityDispatch */

static void 
SwapSecurityAuthorizationRevokedEvent(
    xSecurityAuthorizationRevokedEvent *from,
    xSecurityAuthorizationRevokedEvent *to)
d703 2
a704 2
	/* this extension only supports the core keyboard */
	allowed = requested;
d707 4
a710 4
	SecurityAudit("Security denied client %d keyboard access on request "
		      "%s\n", rec->client->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
d748 2
a749 2
	if (subj->haveState && subj->trustLevel != XSecurityClientTrusted)
	    ((WindowPtr)rec->res)->forcedBG = TRUE;
d753 1
a753 1
	allowed |= SecurityWindowExtraMask;
d757 11
a767 11
	if (rec->rtype & RC_DRAWABLE)
	    /* additional operations allowed on root windows */
	    allowed |= SecurityRootWindowExtraMask;

	else if (rec->rtype == RT_COLORMAP)
	    /* allow access to default colormaps */
	    allowed = requested;

	else
	    /* allow read access to other server-owned resources */
	    allowed |= DixReadAccess;
d771 3
a773 3
	obj = dixLookupPrivate(&clients[cid]->devPrivates, stateKey);
	if (SecurityDoCheck(subj, obj, requested, allowed) == Success)
	    return;
d777 4
a780 4
		  "of client %d on request %s\n", rec->client->index,
		  requested, rec->id, cid,
		  SecurityLookupRequestName(rec->client));
    rec->status = BadAccess; /* deny access */
a782 1

d793 1
a793 1
	return;
d796 2
a797 2
	if (!strcmp(SecurityTrustedExtensions[i++], rec->ext->name))
	    return;
d800 3
a802 3
		  "%s on request %s\n",
		  rec->client->index, rec->ext->name,
		  SecurityLookupRequestName(rec->client));
d816 1
a816 1
 
d818 4
a821 4
	SecurityAudit("Security: denied client %d access to server "
		      "configuration request %s\n", rec->client->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
d837 4
a840 4
	SecurityAudit("Security: denied client %d access to client %d on "
		      "request %s\n", rec->client->index, rec->target->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
d846 1
a846 1
{    
d857 6
a862 6
	SecurityAudit("Security: denied client %d access to property %s "
		      "(atom 0x%x) window 0x%x of client %d on request %s\n",
		      rec->client->index, NameForAtom(name), name,
		      rec->pWin->drawable.id, wClient(rec->pWin)->index,
		      SecurityLookupRequestName(rec->client));
	rec->status = BadAccess;
d873 1
a873 1
	int i;
d875 2
a876 2
	subj = dixLookupPrivate(&rec->client->devPrivates, stateKey);
	obj = dixLookupPrivate(&wClient(rec->pWin)->devPrivates, stateKey);
d878 2
a879 2
	if (SecurityDoCheck(subj, obj, DixSendAccess, 0) == Success)
	    return;
d881 14
a894 14
	for (i = 0; i < rec->count; i++)
	    if (rec->events[i].u.u.type != UnmapNotify &&
		rec->events[i].u.u.type != ConfigureRequest &&
		rec->events[i].u.u.type != ClientMessage) {

		SecurityAudit("Security: denied client %d from sending event "
			      "of type %s to window 0x%x of client %d\n",
			      rec->client->index,
			      LookupEventName(rec->events[i].u.u.type),
			      rec->pWin->drawable.id,
			      wClient(rec->pWin)->index);
		rec->status = BadAccess;
		return;
	    }
d908 1
a908 1
	return;
d911 3
a913 3
		  "sent to window 0x%x of client %d\n",
		  rec->client->index, rec->pWin->drawable.id,
		  wClient(rec->pWin)->index);
d951 4
a954 4
	state->trustLevel = XSecurityClientTrusted;
	state->authId = None;
	state->haveState = TRUE;
	break;
d957 13
a969 13
	state->authId = AuthorizationIDOfClient(pci->client);
	rc = dixLookupResourceByType((pointer *)&pAuth, state->authId,
			       SecurityAuthorizationResType, serverClient,
			       DixGetAttrAccess);
	if (rc == Success) {
	    /* it is a generated authorization */
	    pAuth->refcnt++;
	    if (pAuth->refcnt == 1 && pAuth->timer)
		TimerCancel(pAuth->timer);

	    state->trustLevel = pAuth->trustLevel;
	}
	break;
d973 10
a982 10
	rc = dixLookupResourceByType((pointer *)&pAuth, state->authId,
			       SecurityAuthorizationResType, serverClient,
			       DixGetAttrAccess);
	if (rc == Success) {
	    /* it is a generated authorization */
	    pAuth->refcnt--;
	    if (pAuth->refcnt == 0)
		SecurityStartAuthorizationTimer(pAuth);
	}
	break;
d985 1
a985 1
	break;
d1001 1
a1001 2
SecurityResetProc(
    ExtensionEntry *extEntry)
a1016 1

d1030 1
a1030 1
    ExtensionEntry	*extEntry;
d1034 2
a1035 2
	CreateNewResourceType(SecurityDeleteAuthorization,
			      "SecurityAuthorization");
d1038 2
a1039 2
	CreateNewResourceType(SecurityDeleteAuthorizationEventClient,
			      "SecurityEventClient");
d1042 1
a1042 1
	return;
d1047 3
a1049 2
    if (!dixRegisterPrivateKey(stateKey, PRIVATE_CLIENT, sizeof(SecurityStateRec)))
	FatalError("SecurityExtensionSetup: Can't allocate client private.\n");
d1065 1
a1065 1
	FatalError("SecurityExtensionSetup: Failed to register callbacks\n");
d1069 2
a1070 2
			    XSecurityNumberEvents, XSecurityNumberErrors,
			    ProcSecurityDispatch, SProcSecurityDispatch,
d1077 1
a1077 1
	(EventSwapPtr)SwapSecurityAuthorizationRevokedEvent;
d1079 2
a1080 1
    SetResourceTypeErrorValue(SecurityAuthorizationResType, SecurityErrorBase + XSecurityBadAuthorization);
@


1.9
log
@Update to xserver 1.11.2
@
text
@d151 1
a151 3
    int major = ((xReq *)client->requestBuffer)->reqType;
    int minor = MinorOpcodeOfRequest(client);
    return LookupRequestName(major, minor);
@


1.8
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a156 2
#define rClient(obj) (clients[CLIENT_ID((obj)->resource)])

@


1.7
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d54 2
a55 2
static int stateKeyIndex;
static DevPrivateKey stateKey = &stateKeyIndex;
d201 4
a204 10
	ClientPtr client = rClient(pEventClient);

	if (!client->clientGone)
	{
	    xSecurityAuthorizationRevokedEvent are;
	    are.type = SecurityEventBase + XSecurityAuthorizationRevoked;
	    are.sequenceNumber = client->sequence;
	    are.authId = pAuth->id;
	    WriteEventsToClient(client, 1, (xEvent *)&are);
	}
d219 1
a219 1
    xfree(pAuth);
d244 2
a245 2
	    xfree(pEventClient);
	    return(Success);
d380 1
a380 1
    return (client->noClientException);
d406 1
a406 1
    pEventClient = xalloc(sizeof(OtherClients));
d415 1
a415 1
	xfree(pEventClient);
d538 1
a538 1
    pAuth = xalloc(sizeof(SecurityAuthorizationRec));
d601 1
a601 4

    removeAuth = FALSE;
    pAuth = NULL;
    err = client->noClientException;
d607 1
a607 1
    if (pAuth) xfree(pAuth);
d626 1
a626 2
	return (rc == BadValue) ?
	    SecurityErrorBase + XSecurityBadAuthorization : rc;
a807 1
    obj = dixLookupPrivate(&clients[cid]->devPrivates, stateKey);
d833 5
a837 2
    if (SecurityDoCheck(subj, obj, requested, allowed) == Success)
	return;
d1113 1
a1113 1
    if (!dixRequestPrivate(stateKey, sizeof(SecurityStateRec)))
d1143 2
@


1.6
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d40 1
a40 1
#include <X11/extensions/securstr.h>
d42 1
d375 2
a376 2
    rep.majorVersion  	= SECURITY_MAJOR_VERSION;
    rep.minorVersion  	= SECURITY_MINOR_VERSION;
d412 1
a412 1
    pEventClient = (OtherClients *) xalloc(sizeof(OtherClients));
d454 3
a456 3
    len = SIZEOF(xSecurityGenerateAuthorizationReq) >> 2;
    len += (stuff->nbytesAuthProto + (unsigned)3) >> 2;
    len += (stuff->nbytesAuthData  + (unsigned)3) >> 2;
d524 1
a524 1
    protodata = protoname + ((stuff->nbytesAuthProto + (unsigned)3) >> 2);
d544 1
a544 1
    pAuth = (SecurityAuthorizationPtr)xalloc(sizeof(SecurityAuthorizationRec));
d584 1
a584 1
    rep.length = (authdata_len + 3) >> 2;
d627 1
d631 6
a636 4
    pAuth = (SecurityAuthorizationPtr)SecurityLookupIDByType(client,
	stuff->authId, SecurityAuthorizationResType, DixDestroyAccess);
    if (!pAuth)
	return SecurityErrorBase + XSecurityBadAuthorization;
d692 2
a693 2
    values_offset = ((stuff->nbytesAuthProto + (unsigned)3) >> 2) +
		    ((stuff->nbytesAuthData + (unsigned)3) >> 2);
d695 1
a695 1
	stuff->length - (sz_xSecurityGenerateAuthorizationReq >> 2))
d1108 2
a1109 1
	CreateNewResourceType(SecurityDeleteAuthorization);
d1111 3
a1113 2
    RTEventClient = CreateNewResourceType(
				SecurityDeleteAuthorizationEventClient);
a1118 2
    RegisterResourceName(SecurityAuthorizationResType, "SecurityAuthorization");
    RegisterResourceName(RTEventClient, "SecurityEventClient");
@


1.5
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a40 3
#ifdef XAPPGROUP
#include "appgroup.h"
#endif
d53 2
a54 1
static DevPrivateKey stateKey = &stateKey;
d64 4
a67 4
static char *SecurityUntrustedExtensions[] = {
    "RandR",
    "SECURITY",
    "XFree86-DGA",
d77 1
d378 1
a378 1
	register char n;
d590 1
a590 1
	register char n;
d663 1
a663 1
    register char 	n;
d678 1
a678 1
    register char 	n;
d705 1
a705 1
    register char 	n;
d821 4
a842 5
#ifdef XAPPGROUP
    if (rec->id == XagDefaultColormap(rec->client))
	return;
#endif

d860 12
a871 10
    if (subj->haveState && subj->trustLevel != XSecurityClientTrusted)
	while (SecurityUntrustedExtensions[i])
	    if (!strcmp(SecurityUntrustedExtensions[i++], rec->ext->name)) {
		SecurityAudit("Security: denied client %d access to extension "
			      "%s on request %s\n",
			      rec->client->index, rec->ext->name,
			      SecurityLookupRequestName(rec->client));
		rec->status = BadAccess;
		return;
	    }
d956 4
a959 3
			      rec->client->index, rec->pWin->drawable.id,
			      wClient(rec->pWin)->index,
			      LookupEventName(rec->events[i].u.u.type));
d1026 1
a1026 1
	rc = dixLookupResource((pointer *)&pAuth, state->authId,
d1041 1
a1041 1
	rc = dixLookupResource((pointer *)&pAuth, state->authId,
d1053 1
a1053 1
	break; 
@


1.4
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@d31 2
a32 2
#include "dixstruct.h"
#include "extnsionst.h"
d34 1
a34 3
#include "inputstr.h"
#include "scrnintstr.h"
#include "gcstruct.h"
d36 2
a37 1
#include "propertyst.h"
a40 2
#include <assert.h>
#include <stdarg.h>
a43 11
#include <stdio.h>  /* for file reading operations */
#include <X11/Xatom.h>  /* for XA_STRING */

#ifndef DEFAULTPOLICYFILE
# define DEFAULTPOLICYFILE NULL
#endif
#if defined(WIN32) || defined(__CYGWIN__)
#include <X11/Xos.h>
#undef index
#endif

d46 1
a48 2
static int securityClientPrivateIndex;
static int securityExtnsnPrivateIndex;
d50 9
a58 1
/* this is what we store as client security state */
d60 1
d63 1
a63 1
} SecurityClientStateRec;
d65 7
a71 8
#define STATEVAL(extnsn) \
    ((extnsn)->devPrivates[securityExtnsnPrivateIndex].val)
#define STATEPTR(client) \
    ((client)->devPrivates[securityClientPrivateIndex].ptr)
#define TRUSTLEVEL(client) \
    (((SecurityClientStateRec*)STATEPTR(client))->trustLevel)
#define AUTHID(client) \
    (((SecurityClientStateRec*)STATEPTR(client))->authId)
d73 13
a85 1
static CallbackListPtr SecurityValidateGroupCallback = NULL;
a86 6
RESTYPE SecurityAuthorizationResType; /* resource type for authorizations */

static RESTYPE RTEventClient;

#define CALLBACK(name) static void \
name(CallbackListPtr *pcbl, pointer nulldata, pointer calldata)
d112 45
d217 6
a222 4
    {
	if (clients[i] && (AUTHID(clients[i]) == pAuth->id))
	    CloseDownClient(clients[i]);
    }
a370 6
    /* paranoia: this "can't happen" because this extension is hidden
     * from untrusted clients, but just in case...
     */
    if (TRUSTLEVEL(client) != XSecurityClientTrusted)
	return BadRequest;

a450 6
    /* paranoia: this "can't happen" because this extension is hidden
     * from untrusted clients, but just in case...
     */
    if (TRUSTLEVEL(client) != XSecurityClientTrusted)
	return BadRequest;

a627 6
    /* paranoia: this "can't happen" because this extension is hidden
     * from untrusted clients, but just in case...
     */
    if (TRUSTLEVEL(client) != XSecurityClientTrusted)
	return BadRequest;

a744 53
/* SecurityDetermineEventPropogationLimits
 *
 * This is a helper function for SecurityCheckDeviceAccess.
 *
 * Arguments:
 *	dev is the device for which the starting and stopping windows for
 *	event propogation should be determined.
 *	The values pointed to by ppWin and ppStopWin are not used.
 *
 * Returns:
 *	ppWin is filled in with a pointer to the window at which event
 *	propogation for the given device should start given the current
 *	state of the server (pointer position, window layout, etc.)
 *	ppStopWin is filled in with the window at which event propogation
 *	should stop; events should not go to ppStopWin.
 *
 * Side Effects: none.
 */

static void
SecurityDetermineEventPropogationLimits(
    DeviceIntPtr dev,
    WindowPtr *ppWin,
    WindowPtr *ppStopWin)
{
    WindowPtr pFocusWin = dev->focus ? dev->focus->win : NoneWin;

    if (pFocusWin == NoneWin)
    { /* no focus -- events don't go anywhere */
	*ppWin = *ppStopWin = NULL;
	return;
    }

    if (pFocusWin == PointerRootWin)
    { /* focus follows the pointer */
	*ppWin = GetSpriteWindow();
	*ppStopWin = NULL; /* propogate all the way to the root */
    }
    else
    { /* a real window is set for the focus */
	WindowPtr pSpriteWin = GetSpriteWindow();
	*ppStopWin = pFocusWin->parent; /* don't go past the focus window */

	/* if the pointer is in a subwindow of the focus window, start
	 * at that subwindow, else start at the focus window itself
	 */
	if (IsParent(pFocusWin, pSpriteWin))
	     *ppWin = pSpriteWin;
	else *ppWin = pFocusWin;
    }
} /* SecurityDetermineEventPropogationLimits */


d761 2
a762 1
CALLBACK(SecurityCheckDeviceAccess)
d764 17
a780 36
    XaceDeviceAccessRec *rec = (XaceDeviceAccessRec*)calldata;
    ClientPtr client = rec->client;
    DeviceIntPtr dev = rec->dev;
    Bool fromRequest = rec->fromRequest;
    WindowPtr pWin, pStopWin;
    Bool untrusted_got_event;
    Bool found_event_window;
    Mask eventmask;
    int reqtype = 0;

    /* trusted clients always allowed to do anything */
    if (TRUSTLEVEL(client) == XSecurityClientTrusted)
	return;

    /* device security other than keyboard is not implemented yet */
    if (dev != inputInfo.keyboard)
	return;

    /* some untrusted client wants access */

    if (fromRequest)
    {
	reqtype = ((xReq *)client->requestBuffer)->reqType;
	switch (reqtype)
	{
	    /* never allow these */
	    case X_ChangeKeyboardMapping:
	    case X_ChangeKeyboardControl:
	    case X_SetModifierMapping:
		SecurityAudit("client %d attempted request %d\n",
			      client->index, reqtype);
		rec->rval = FALSE;
		return;
	    default:
		break;
	}
d782 1
d784 1
a784 116
    untrusted_got_event = FALSE;
    found_event_window = FALSE;

    if (dev->grab)
    {
	untrusted_got_event =
	    (TRUSTLEVEL(rClient(dev->grab)) != XSecurityClientTrusted);
    }
    else
    {
	SecurityDetermineEventPropogationLimits(dev, &pWin, &pStopWin);

	eventmask = KeyPressMask | KeyReleaseMask;
	while ( (pWin != pStopWin) && !found_event_window)
	{
	    OtherClients *other;

	    if (pWin->eventMask & eventmask)
	    {
		found_event_window = TRUE;
		client = wClient(pWin);
		if (TRUSTLEVEL(client) != XSecurityClientTrusted)
		{
		    untrusted_got_event = TRUE;
		}
	    }
	    if (wOtherEventMasks(pWin) & eventmask)
	    {
		found_event_window = TRUE;
		for (other = wOtherClients(pWin); other; other = other->next)
		{
		    if (other->mask & eventmask)
		    {
			client = rClient(other);
			if (TRUSTLEVEL(client) != XSecurityClientTrusted)
			{
			    untrusted_got_event = TRUE;
			    break;
			}
		    }
		}
	    }
	    if (wDontPropagateMask(pWin) & eventmask)
		break;
	    pWin = pWin->parent;
	} /* while propogating the event */
    }

    /* allow access by untrusted clients only if an event would have gone 
     * to an untrusted client
     */
    
    if (!untrusted_got_event)
    {
	char *devname = dev->name;
	if (!devname) devname = "unnamed";
	if (fromRequest)
	    SecurityAudit("client %d attempted request %d device %d (%s)\n",
			  client->index, reqtype, dev->id, devname);
	else
	    SecurityAudit("client %d attempted to access device %d (%s)\n",
			  client->index, dev->id, devname);
	rec->rval = FALSE;
    }
    return;
} /* SecurityCheckDeviceAccess */



/* SecurityAuditResourceIDAccess
 *
 * Arguments:
 *	client is the client doing the resource access.
 *	id is the resource id.
 *
 * Returns: NULL
 *
 * Side Effects:
 *	An audit message is generated with details of the denied
 *	resource access.
 */

static pointer
SecurityAuditResourceIDAccess(
    ClientPtr client,
    XID id)
{
    int cid = CLIENT_ID(id);
    int reqtype = ((xReq *)client->requestBuffer)->reqType;
    switch (reqtype)
    {
	case X_ChangeProperty:
	case X_DeleteProperty:
	case X_GetProperty:
	{
	    xChangePropertyReq *req =
		(xChangePropertyReq *)client->requestBuffer;
	    int propertyatom = req->property;
	    char *propertyname = NameForAtom(propertyatom);

	    SecurityAudit("client %d attempted request %d with window 0x%x property %s of client %d\n",
		   client->index, reqtype, id, propertyname, cid);
	    break;
	}
	default:
	{
	    SecurityAudit("client %d attempted request %d with resource 0x%x of client %d\n",
		   client->index, reqtype, id, cid);
	    break;
	}   
    }
    return NULL;
} /* SecurityAuditResourceIDAccess */


/* SecurityCheckResourceIDAccess
d805 2
a806 1
CALLBACK(SecurityCheckResourceIDAccess)
d808 23
a830 29
    XaceResourceAccessRec *rec = (XaceResourceAccessRec*)calldata;
    ClientPtr client = rec->client;
    XID id = rec->id;
    RESTYPE rtype = rec->rtype;
    Mask access_mode = rec->access_mode;
    pointer rval = rec->res;
    int cid, reqtype;

    if (TRUSTLEVEL(client) == XSecurityClientTrusted ||
	DixUnknownAccess == access_mode)
	return;       /* for compatibility, we have to allow access */

    cid = CLIENT_ID(id);
    reqtype = ((xReq *)client->requestBuffer)->reqType;
    switch (reqtype)
    { /* these are always allowed */
	case X_QueryTree:
        case X_TranslateCoords:
        case X_GetGeometry:
	/* property access is controlled in SecurityCheckPropertyAccess */
	case X_GetProperty:
	case X_ChangeProperty:
	case X_DeleteProperty:
	case X_RotateProperties:
        case X_ListProperties:
	    return;
	default:
	    break;
    }
a831 22
    if (cid != 0)
    { /* not a server-owned resource */
     /*
      * The following 'if' restricts clients to only access resources at
      * the same trustLevel.  Since there are currently only two trust levels,
      * and trusted clients never call this function, this degenerates into
      * saying that untrusted clients can only access resources of other
      * untrusted clients.  One way to add the notion of groups would be to
      * allow values other than Trusted (0) and Untrusted (1) for this field.
      * Clients at the same trust level would be able to use each other's
      * resources, but not those of clients at other trust levels.  I haven't
      * tried it, but this probably mostly works already.  The obvious
      * competing alternative for grouping clients for security purposes is to
      * use app groups.  dpw
      */
	if (TRUSTLEVEL(client) == TRUSTLEVEL(clients[cid])
#ifdef XAPPGROUP
	    || (RT_COLORMAP == rtype && 
		XagDefaultColormap (client) == (Colormap) id)
#endif
	)
	    return;
d833 2
a834 74
	    goto deny;
    }
    else /* server-owned resource - probably a default colormap or root window */
    {
	if (RC_DRAWABLE & rtype)
	{
	    switch (reqtype)
	    {   /* the following operations are allowed on root windows */
	        case X_CreatePixmap:
	        case X_CreateGC:
	        case X_CreateWindow:
	        case X_CreateColormap:
		case X_ListProperties:
		case X_GrabPointer:
	        case X_UngrabButton:
		case X_QueryBestSize:
		case X_GetWindowAttributes:
		    break;
		case X_SendEvent:
		{ /* see if it is an event specified by the ICCCM */
		    xSendEventReq *req = (xSendEventReq *)
						(client->requestBuffer);
		    if (req->propagate == xTrue
			||
			  (req->eventMask != ColormapChangeMask &&
			   req->eventMask != StructureNotifyMask &&
			   req->eventMask !=
			      (SubstructureRedirectMask|SubstructureNotifyMask)
			  )
			||
			  (req->event.u.u.type != UnmapNotify &&
			   req->event.u.u.type != ConfigureRequest &&
			   req->event.u.u.type != ClientMessage
			  )
		       )
		    { /* not an ICCCM event */
			goto deny;
		    }
		    break;
		} /* case X_SendEvent on root */

		case X_ChangeWindowAttributes:
		{ /* Allow selection of PropertyNotify and StructureNotify
		   * events on the root.
		   */
		    xChangeWindowAttributesReq *req =
			(xChangeWindowAttributesReq *)(client->requestBuffer);
		    if (req->valueMask == CWEventMask)
		    {
			CARD32 value = *((CARD32 *)(req + 1));
			if ( (value &
			      ~(PropertyChangeMask|StructureNotifyMask)) == 0)
			    break;
		    }
		    goto deny;
		} /* case X_ChangeWindowAttributes on root */

		default:
		{
		    /* others not allowed */
		    goto deny;
		}
	    }
	} /* end server-owned window or drawable */
	else if (SecurityAuthorizationResType == rtype)
	{
	    SecurityAuthorizationPtr pAuth = (SecurityAuthorizationPtr)rval;
	    if (pAuth->trustLevel != TRUSTLEVEL(client))
		goto deny;
	}
	else if (RT_COLORMAP != rtype)
	{ /* don't allow anything else besides colormaps */
	    goto deny;
	}
a835 5
    return;
  deny:
    SecurityAuditResourceIDAccess(client, id);
    rec->rval = FALSE;	/* deny access */
} /* SecurityCheckResourceIDAccess */
d837 2
d840 4
a843 58
/* SecurityClientStateCallback
 *
 * Arguments:
 *	pcbl is &ClientStateCallback.
 *	nullata is NULL.
 *	calldata is a pointer to a NewClientInfoRec (include/dixstruct.h)
 *	which contains information about client state changes.
 *
 * Returns: nothing.
 *
 * Side Effects:
 * 
 * If a new client is connecting, its authorization ID is copied to
 * client->authID.  If this is a generated authorization, its reference
 * count is bumped, its timer is cancelled if it was running, and its
 * trustlevel is copied to TRUSTLEVEL(client).
 * 
 * If a client is disconnecting and the client was using a generated
 * authorization, the authorization's reference count is decremented, and
 * if it is now zero, the timer for this authorization is started.
 */

CALLBACK(SecurityClientStateCallback)
{
    NewClientInfoRec *pci = (NewClientInfoRec *)calldata;
    ClientPtr client = pci->client;

    switch (client->clientState)
    {
    case ClientStateInitial:
	TRUSTLEVEL(client) = XSecurityClientTrusted;
	AUTHID(client) = None;
	break;

    case ClientStateRunning:
	{ 
	    XID authId = AuthorizationIDOfClient(client);
	    SecurityAuthorizationPtr pAuth;

	    TRUSTLEVEL(client) = XSecurityClientTrusted;
	    AUTHID(client) = authId;
	    pAuth = (SecurityAuthorizationPtr)LookupIDByType(authId,
						SecurityAuthorizationResType);
	    if (pAuth)
	    { /* it is a generated authorization */
		pAuth->refcnt++;
		if (pAuth->refcnt == 1)
		{
		    if (pAuth->timer) TimerCancel(pAuth->timer);
		}
		TRUSTLEVEL(client) = pAuth->trustLevel;
	    }
	    break;
	}
    case ClientStateGone:
    case ClientStateRetained: /* client disconnected */
	{
	    SecurityAuthorizationPtr pAuth;
d845 5
a849 26
	    /* client may not have any state (bad authorization) */
	    if (!STATEPTR(client))
		break;

	    pAuth = (SecurityAuthorizationPtr)LookupIDByType(AUTHID(client),
						SecurityAuthorizationResType);
	    if (pAuth)
	    { /* it is a generated authorization */
		pAuth->refcnt--;
		if (pAuth->refcnt == 0)
		{
		    SecurityStartAuthorizationTimer(pAuth);
		}
	    }	    
	    break;
	}
    default: break; 
    }
} /* SecurityClientStateCallback */

CALLBACK(SecurityCheckDrawableAccess)
{
    XaceDrawableAccessRec *rec = (XaceDrawableAccessRec*)calldata;

    if (TRUSTLEVEL(rec->client) != XSecurityClientTrusted)
	rec->rval = FALSE;
a851 10
CALLBACK(SecurityCheckMapAccess)
{
    XaceMapAccessRec *rec = (XaceMapAccessRec*)calldata;
    WindowPtr pWin = rec->pWin;

    if (STATEPTR(rec->client) &&
	(TRUSTLEVEL(rec->client) != XSecurityClientTrusted) &&
	(pWin->drawable.class == InputOnly) &&
	pWin->parent && pWin->parent->parent &&
	(TRUSTLEVEL(wClient(pWin->parent)) == XSecurityClientTrusted))
d853 2
a854 4
	rec->rval = FALSE;
}

CALLBACK(SecurityCheckBackgrndAccess)
d856 16
a871 4
    XaceMapAccessRec *rec = (XaceMapAccessRec*)calldata;

    if (TRUSTLEVEL(rec->client) != XSecurityClientTrusted)
	rec->rval = FALSE;
d874 2
a875 1
CALLBACK(SecurityCheckExtAccess)
d877 4
a880 4
    XaceExtAccessRec *rec = (XaceExtAccessRec*)calldata;

    if ((TRUSTLEVEL(rec->client) != XSecurityClientTrusted) &&
	!STATEVAL(rec->ext))
d882 2
a883 6
	rec->rval = FALSE;
}

CALLBACK(SecurityCheckHostlistAccess)
{
    XaceHostlistAccessRec *rec = (XaceHostlistAccessRec*)calldata;
d885 5
a889 9
    if (TRUSTLEVEL(rec->client) != XSecurityClientTrusted)
    {
	rec->rval = FALSE;
	if (rec->access_mode == DixWriteAccess)
	    SecurityAudit("client %d attempted to change host access\n",
			  rec->client->index);
	else
	    SecurityAudit("client %d attempted to list hosts\n",
			  rec->client->index);
d893 2
a894 1
CALLBACK(SecurityDeclareExtSecure)
d896 14
a909 4
    XaceDeclareExtSecureRec *rec = (XaceDeclareExtSecureRec*)calldata;

    /* security state for extensions is simply a boolean trust value */
    STATEVAL(rec->ext) = rec->secure;
a911 39
/**********************************************************************/

typedef struct _PropertyAccessRec {
    ATOM name;
    ATOM mustHaveProperty;
    char *mustHaveValue;
    char windowRestriction;
#define SecurityAnyWindow          0
#define SecurityRootWindow         1
#define SecurityWindowWithProperty 2
    char readAction;
    char writeAction;
    char destroyAction;
    struct _PropertyAccessRec *next;
} PropertyAccessRec, *PropertyAccessPtr;

static PropertyAccessPtr PropertyAccessList = NULL;
static char SecurityDefaultAction = XaceErrorOperation;
static char *SecurityPolicyFile = DEFAULTPOLICYFILE;
static ATOM SecurityMaxPropertyName = 0;

static char *SecurityKeywords[] = {
#define SecurityKeywordComment 0
    "#",
#define SecurityKeywordProperty 1
    "property",
#define SecurityKeywordSitePolicy 2
    "sitepolicy",
#define SecurityKeywordRoot 3
    "root",
#define SecurityKeywordAny 4
    "any"
};

#define NUMKEYWORDS (sizeof(SecurityKeywords) / sizeof(char *))

#undef PROPDEBUG
/*#define PROPDEBUG  1*/

d913 18
a930 7
SecurityFreePropertyAccessList(void)
{
    while (PropertyAccessList)
    {
	PropertyAccessPtr freeit = PropertyAccessList;
	PropertyAccessList = PropertyAccessList->next;
	xfree(freeit);
d932 1
a932 1
} /* SecurityFreePropertyAccessList */
d934 2
a935 5
#define SecurityIsWhitespace(c) ( (c == ' ') || (c == '\t') || (c == '\n') )

static char *
SecuritySkipWhitespace(
    char *p)
d937 2
a938 4
    while (SecurityIsWhitespace(*p))
	p++;
    return p;
} /* SecuritySkipWhitespace */
d940 2
d943 2
a944 7
static char *
SecurityParseString(
    char **rest)
{
    char *startOfString;
    char *s = *rest;
    char endChar = 0;
d946 2
a947 1
    s = SecuritySkipWhitespace(s);
d949 13
a961 6
    if (*s == '"' || *s == '\'')
    {
	endChar = *s++;
	startOfString = s;
	while (*s && (*s != endChar))
	    s++;
d963 1
a963 18
    else
    {
	startOfString = s;
	while (*s && !SecurityIsWhitespace(*s))
	    s++;
    }
    if (*s)
    {
	*s = '\0';
	*rest = s + 1;
	return startOfString;
    }
    else
    {
	*rest = s;
	return (endChar) ? NULL : startOfString;
    }
} /* SecurityParseString */
d965 2
a966 4

static int
SecurityParseKeyword(
    char **p)
d968 2
a969 60
    int i;
    char *s = *p;
    s = SecuritySkipWhitespace(s);
    for (i = 0; i < NUMKEYWORDS; i++)
    {
	int len = strlen(SecurityKeywords[i]);
	if (strncmp(s, SecurityKeywords[i], len) == 0)
	{
	    *p = s + len;
	    return (i);
	}
    }
    *p = s;
    return -1;
} /* SecurityParseKeyword */


static Bool
SecurityParsePropertyAccessRule(
    char *p)
{
    char *propname;
    char c;
    char action = SecurityDefaultAction;
    char readAction, writeAction, destroyAction;
    PropertyAccessPtr pacl, prev, cur;
    char *mustHaveProperty = NULL;
    char *mustHaveValue = NULL;
    Bool invalid;
    char windowRestriction;
    int size;
    int keyword;

    /* get property name */
    propname = SecurityParseString(&p);
    if (!propname || (strlen(propname) == 0))
	return FALSE;

    /* get window on which property must reside for rule to apply */

    keyword = SecurityParseKeyword(&p);
    if (keyword == SecurityKeywordRoot)
	windowRestriction = SecurityRootWindow;
    else if (keyword == SecurityKeywordAny) 
	windowRestriction = SecurityAnyWindow;
    else /* not root or any, must be a property name */
    {
	mustHaveProperty = SecurityParseString(&p);
	if (!mustHaveProperty || (strlen(mustHaveProperty) == 0))
	    return FALSE;
	windowRestriction = SecurityWindowWithProperty;
	p = SecuritySkipWhitespace(p);
	if (*p == '=')
	{ /* property value is specified too */
	    p++; /* skip over '=' */
	    mustHaveValue = SecurityParseString(&p);
	    if (!mustHaveValue)
		return FALSE;
	}
    }
d971 2
a972 1
    /* get operations and actions */
d974 2
a975 22
    invalid = FALSE;
    readAction = writeAction = destroyAction = SecurityDefaultAction;
    while ( (c = *p++) && !invalid)
    {
	switch (c)
	{
	    case 'i': action = XaceIgnoreOperation; break;
	    case 'a': action = XaceAllowOperation;  break;
	    case 'e': action = XaceErrorOperation;  break;

	    case 'r': readAction    = action; break;
	    case 'w': writeAction   = action; break;
	    case 'd': destroyAction = action; break;

	    default :
		if (!SecurityIsWhitespace(c))
		    invalid = TRUE;
	    break;
	}
    }
    if (invalid)
	return FALSE;
d977 6
a982 4
    /* We've successfully collected all the information needed for this
     * property access rule.  Now record it in a PropertyAccessRec.
     */
    size = sizeof(PropertyAccessRec);
d984 21
a1004 105
    /* If there is a property value string, allocate space for it 
     * right after the PropertyAccessRec.
     */
    if (mustHaveValue)
	size += strlen(mustHaveValue) + 1;
    pacl = (PropertyAccessPtr)Xalloc(size);
    if (!pacl)
	return FALSE;

    pacl->name = MakeAtom(propname, strlen(propname), TRUE);
    if (pacl->name == BAD_RESOURCE)
    {
	Xfree(pacl);
	return FALSE;
    }
    if (mustHaveProperty)
    {
	pacl->mustHaveProperty = MakeAtom(mustHaveProperty,
					  strlen(mustHaveProperty), TRUE);
	if (pacl->mustHaveProperty == BAD_RESOURCE)
	{
	    Xfree(pacl);
	    return FALSE;
	}
    }
    else
	pacl->mustHaveProperty = 0;

    if (mustHaveValue)
    {
	pacl->mustHaveValue = (char *)(pacl + 1);
	strcpy(pacl->mustHaveValue, mustHaveValue);
    }
    else
	pacl->mustHaveValue = NULL;

    SecurityMaxPropertyName = max(SecurityMaxPropertyName, pacl->name);

    pacl->windowRestriction = windowRestriction;
    pacl->readAction  = readAction;
    pacl->writeAction = writeAction;
    pacl->destroyAction = destroyAction;

    /* link the new rule into the list of rules in order of increasing
     * property name (atom) value to make searching easier
     */

    for (prev = NULL,  cur = PropertyAccessList;
	 cur && cur->name <= pacl->name;
	 prev = cur, cur = cur->next)
	;
    if (!prev)
    {
	pacl->next = cur;
	PropertyAccessList = pacl;
    }
    else
    {
	prev->next = pacl;
	pacl->next = cur;
    }
    return TRUE;
} /* SecurityParsePropertyAccessRule */

static char **SecurityPolicyStrings = NULL;
static int nSecurityPolicyStrings = 0;

static Bool
SecurityParseSitePolicy(
    char *p)
{
    char *policyStr = SecurityParseString(&p);
    char *copyPolicyStr;
    char **newStrings;

    if (!policyStr)
	return FALSE;

    copyPolicyStr = (char *)Xalloc(strlen(policyStr) + 1);
    if (!copyPolicyStr)
	return TRUE;
    strcpy(copyPolicyStr, policyStr);
    newStrings = (char **)Xrealloc(SecurityPolicyStrings,
			  sizeof (char *) * (nSecurityPolicyStrings + 1));
    if (!newStrings)
    {
	Xfree(copyPolicyStr);
	return TRUE;
    }

    SecurityPolicyStrings = newStrings;
    SecurityPolicyStrings[nSecurityPolicyStrings++] = copyPolicyStr;

    return TRUE;

} /* SecurityParseSitePolicy */


char **
SecurityGetSitePolicyStrings(n)
    int *n;
{
    *n = nSecurityPolicyStrings;
    return SecurityPolicyStrings;
} /* SecurityGetSitePolicyStrings */
d1007 1
a1007 1
SecurityFreeSitePolicyStrings(void)
d1009 4
a1012 12
    if (SecurityPolicyStrings)
    {
	assert(nSecurityPolicyStrings);
	while (nSecurityPolicyStrings--)
	{
	    Xfree(SecurityPolicyStrings[nSecurityPolicyStrings]);
	}
	Xfree(SecurityPolicyStrings);
	SecurityPolicyStrings = NULL;
	nSecurityPolicyStrings = 0;
    }
} /* SecurityFreeSitePolicyStrings */
d1014 1
d1016 6
a1021 5
static void
SecurityLoadPropertyAccessList(void)
{
    FILE *f;
    int lineNumber = 0;
d1023 10
a1032 4
    SecurityMaxPropertyName = 0;

    if (!SecurityPolicyFile)
	return;
d1034 1
a1034 50
    f = Fopen(SecurityPolicyFile, "r");
    if (!f)
    {
	ErrorF("error opening security policy file %s\n",
	       SecurityPolicyFile);
	return;
    }

    while (!feof(f))
    {
	char buf[200];
	Bool validLine;
	char *p;

	if (!(p = fgets(buf, sizeof(buf), f)))
	    break;
	lineNumber++;

	/* if first line, check version number */
	if (lineNumber == 1)
	{
	    char *v = SecurityParseString(&p);
	    if (strcmp(v, SECURITY_POLICY_FILE_VERSION) != 0)
	    {
		ErrorF("%s: invalid security policy file version, ignoring file\n",
		       SecurityPolicyFile);
		break;
	    }
	    validLine = TRUE;
	}
	else
	{
	    switch (SecurityParseKeyword(&p))
	    {
		case SecurityKeywordComment:
		    validLine = TRUE;
		break;

		case SecurityKeywordProperty:
		    validLine = SecurityParsePropertyAccessRule(p);
		break;

		case SecurityKeywordSitePolicy:
		    validLine = SecurityParseSitePolicy(p);
		break;

		default:
		    validLine = (*p == '\0'); /* blank lines OK, others not */
		break;
	    }
d1036 1
d1038 10
a1047 27
	if (!validLine)
	    ErrorF("Line %d of %s invalid, ignoring\n",
		   lineNumber, SecurityPolicyFile);
    } /* end while more input */

#ifdef PROPDEBUG
    {
	PropertyAccessPtr pacl;
	char *op = "aie";
	for (pacl = PropertyAccessList; pacl; pacl = pacl->next)
	{
	    ErrorF("property %s ", NameForAtom(pacl->name));
	    switch (pacl->windowRestriction)
	    {
		case SecurityAnyWindow: ErrorF("any "); break;
		case SecurityRootWindow: ErrorF("root "); break;
		case SecurityWindowWithProperty:
		{
		    ErrorF("%s ", NameForAtom(pacl->mustHaveProperty));
		    if (pacl->mustHaveValue)
			ErrorF(" = \"%s\" ", pacl->mustHaveValue);

		}
		break;
	    }
	    ErrorF("%cr %cw %cd\n", op[pacl->readAction],
		   op[pacl->writeAction], op[pacl->destroyAction]);
d1049 1
a1049 6
    }
#endif /* PROPDEBUG */

    Fclose(f);
} /* SecurityLoadPropertyAccessList */

d1051 2
a1052 23
static Bool
SecurityMatchString(
    char *ws,
    char *cs)
{
    while (*ws && *cs)
    {
	if (*ws == '*')
	{
	    Bool match = FALSE;
	    ws++;
	    while (!(match = SecurityMatchString(ws, cs)) && *cs)
	    {
		cs++;
	    }
	    return match;
	}
	else if (*ws == *cs)
	{
	    ws++;
	    cs++;
	}
	else break;
d1054 1
a1054 142
    return ( ( (*ws == '\0') || ((*ws == '*') && *(ws+1) == '\0') )
	     && (*cs == '\0') );
} /* SecurityMatchString */

#ifdef PROPDEBUG
#include <sys/types.h>
#include <sys/stat.h>
#endif


CALLBACK(SecurityCheckPropertyAccess)
{    
    XacePropertyAccessRec *rec = (XacePropertyAccessRec*)calldata;
    ClientPtr client = rec->client;
    WindowPtr pWin = rec->pWin;
    ATOM propertyName = rec->propertyName;
    Mask access_mode = rec->access_mode;
    PropertyAccessPtr pacl;
    char action = SecurityDefaultAction;

    /* if client trusted or window untrusted, allow operation */

    if ( (TRUSTLEVEL(client) == XSecurityClientTrusted) ||
	 (TRUSTLEVEL(wClient(pWin)) != XSecurityClientTrusted) )
	return;

#ifdef PROPDEBUG
    /* For testing, it's more convenient if the property rules file gets
     * reloaded whenever it changes, so we can rapidly try things without
     * having to reset the server.
     */
    {
	struct stat buf;
	static time_t lastmod = 0;
	int ret = stat(SecurityPolicyFile , &buf);
	if ( (ret == 0) && (buf.st_mtime > lastmod) )
	{
	    ErrorF("reloading property rules\n");
	    SecurityFreePropertyAccessList();
	    SecurityLoadPropertyAccessList();
	    lastmod = buf.st_mtime;
	}
    }
#endif

    /* If the property atom is bigger than any atoms on the list, 
     * we know we won't find it, so don't even bother looking.
     */
    if (propertyName <= SecurityMaxPropertyName)
    {
	/* untrusted client operating on trusted window; see if it's allowed */

	for (pacl = PropertyAccessList; pacl; pacl = pacl->next)
	{
	    if (pacl->name < propertyName)
		continue;
	    if (pacl->name > propertyName)
		break;

	    /* pacl->name == propertyName, so see if it applies to this window */

	    switch (pacl->windowRestriction)
	    {
		case SecurityAnyWindow: /* always applies */
		    break;

		case SecurityRootWindow:
		{
		    /* if not a root window, this rule doesn't apply */
		    if (pWin->parent)
			continue;
		}
		break;

		case SecurityWindowWithProperty:
		{
		    PropertyPtr pProp = wUserProps (pWin);
		    Bool match = FALSE;
		    char *p;
		    char *pEndData;

		    while (pProp)
		    {
			if (pProp->propertyName == pacl->mustHaveProperty)
			    break;
			pProp = pProp->next;
		    }
		    if (!pProp)
			continue;
		    if (!pacl->mustHaveValue)
			break;
		    if (pProp->type != XA_STRING || pProp->format != 8)
			continue;

		    p = pProp->data;
		    pEndData = ((char *)pProp->data) + pProp->size;
		    while (!match && p < pEndData)
		    {
			 if (SecurityMatchString(pacl->mustHaveValue, p))
			     match = TRUE;
			 else
			 { /* skip to the next string */
			     while (*p++ && p < pEndData)
				 ;
			 }
		    }
		    if (!match)
			continue;
		}
		break; /* end case SecurityWindowWithProperty */
	    } /* end switch on windowRestriction */

	    /* If we get here, the property access rule pacl applies.
	     * If pacl doesn't apply, something above should have
	     * executed a continue, which will skip the follwing code.
	     */
	    action = XaceAllowOperation;
	    if (access_mode & DixReadAccess)
		action = max(action, pacl->readAction);
	    if (access_mode & DixWriteAccess)
		action = max(action, pacl->writeAction);
	    if (access_mode & DixDestroyAccess)
		action = max(action, pacl->destroyAction);
	    break;
	} /* end for each pacl */
    } /* end if propertyName <= SecurityMaxPropertyName */

    if (XaceAllowOperation != action)
    { /* audit the access violation */
	int cid = CLIENT_ID(pWin->drawable.id);
	int reqtype = ((xReq *)client->requestBuffer)->reqType;
	char *actionstr = (XaceIgnoreOperation == action) ?
							"ignored" : "error";
	SecurityAudit("client %d attempted request %d with window 0x%x property %s (atom 0x%x) of client %d, %s\n",
		client->index, reqtype, pWin->drawable.id,
		      NameForAtom(propertyName), propertyName, cid, actionstr);
    }
    /* return codes increase with strictness */
    if (action > rec->rval)
        rec->rval = action;
} /* SecurityCheckPropertyAccess */

d1071 2
a1072 3
    SecurityFreePropertyAccessList();
    SecurityFreeSitePolicyStrings();
} /* SecurityResetProc */
d1074 10
a1083 56

int
XSecurityOptions(argc, argv, i)
    int argc;
    char **argv;
    int i;
{
    if (strcmp(argv[i], "-sp") == 0)
    {
	if (i < argc)
	    SecurityPolicyFile = argv[++i];
	return (i + 1);
    }
    return (i);
} /* XSecurityOptions */


/* SecurityExtensionSetup
 *
 * Arguments: none.
 *
 * Returns: nothing.
 *
 * Side Effects:
 *	Sets up the Security extension if possible.
 *      This function contains things that need to be done
 *      before any other extension init functions get called.
 */

void
SecurityExtensionSetup(INITARGS)
{
    /* Allocate the client private index */
    securityClientPrivateIndex = AllocateClientPrivateIndex();
    if (!AllocateClientPrivate(securityClientPrivateIndex,
			       sizeof (SecurityClientStateRec)))
	FatalError("SecurityExtensionSetup: Can't allocate client private.\n");

    /* Allocate the extension private index */
    securityExtnsnPrivateIndex = AllocateExtensionPrivateIndex();
    if (!AllocateExtensionPrivate(securityExtnsnPrivateIndex, 0))
	FatalError("SecurityExtensionSetup: Can't allocate extnsn private.\n");

    /* register callbacks */
#define XaceRC XaceRegisterCallback
    XaceRC(XACE_RESOURCE_ACCESS, SecurityCheckResourceIDAccess, NULL);
    XaceRC(XACE_DEVICE_ACCESS, SecurityCheckDeviceAccess, NULL);
    XaceRC(XACE_PROPERTY_ACCESS, SecurityCheckPropertyAccess, NULL);
    XaceRC(XACE_DRAWABLE_ACCESS, SecurityCheckDrawableAccess, NULL);
    XaceRC(XACE_MAP_ACCESS, SecurityCheckMapAccess, NULL);
    XaceRC(XACE_BACKGRND_ACCESS, SecurityCheckBackgrndAccess, NULL);
    XaceRC(XACE_EXT_DISPATCH, SecurityCheckExtAccess, NULL);
    XaceRC(XACE_EXT_ACCESS, SecurityCheckExtAccess, NULL);
    XaceRC(XACE_HOSTLIST_ACCESS, SecurityCheckHostlistAccess, NULL);
    XaceRC(XACE_DECLARE_EXT_SECURE, SecurityDeclareExtSecure, NULL);
} /* SecurityExtensionSetup */
d1100 1
d1112 19
d1132 2
a1133 2
    if (!AddCallback(&ClientStateCallback, SecurityClientStateCallback, NULL))
	return;
d1135 1
d1147 3
a1149 3
    SecurityLoadPropertyAccessList();

} /* SecurityExtensionInit */
@


1.3
log
@Fix from X.Org repository: untrusted access broken in 7.3.
@
text
@d654 1
d661 6
a666 3
    values = (CARD32 *)(&stuff[1]) +
	((stuff->nbytesAuthProto + (unsigned)3) >> 2) +
	((stuff->nbytesAuthData + (unsigned)3) >> 2);
@


1.3.2.1
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@a653 1
    int values_offset;
d660 3
a662 6
    values_offset = ((stuff->nbytesAuthProto + (unsigned)3) >> 2) +
		    ((stuff->nbytesAuthData + (unsigned)3) >> 2);
    if (values_offset > 
	stuff->length - (sz_xSecurityGenerateAuthorizationReq >> 2))
	return BadLength;
    values = (CARD32 *)(&stuff[1]) + values_offset;
@


1.2
log
@Fix from X.Org for CVE-2007-5958 - File existence disclosure.
@
text
@d1017 1
a1017 1
	if (RT_WINDOW == rtype || RC_DRAWABLE == rtype)
@


1.1
log
@Initial revision
@
text
@d80 1
a80 1
CallbackListPtr SecurityValidateGroupCallback = NULL;  /* see security.h */
d603 1
a603 1
	stuff->authId, SecurityAuthorizationResType, SecurityDestroyAccess);
d949 1
a949 1
 *	rval is a pointer to the resource structure for this resource.
d952 1
a952 1
 *	If access is granted, the value of rval that was passed in, else NULL.
d969 1
a969 1
	SecurityUnknownAccess == access_mode)
d1190 1
d1221 1
a1221 1
	if (rec->access_mode == SecurityWriteAccess)
d1255 1
a1255 1
static char SecurityDefaultAction = SecurityErrorOperation;
a1287 1
#ifndef __UNIXOS2__
a1288 3
#else
#define SecurityIsWhitespace(c) ( (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r') )
#endif
d1410 3
a1412 3
	    case 'i': action = SecurityIgnoreOperation; break;
	    case 'a': action = SecurityAllowOperation;  break;
	    case 'e': action = SecurityErrorOperation;  break;
d1566 1
a1566 5
#ifndef __UNIXOS2__
    f = fopen(SecurityPolicyFile, "r");
#else
    f = fopen((char*)__XOS2RedirRoot(SecurityPolicyFile), "r");
#endif    
d1649 1
a1649 1
    fclose(f);
d1793 2
a1794 2
	    action = SecurityAllowOperation;
	    if (access_mode & SecurityReadAccess)
d1796 1
a1796 1
	    if (access_mode & SecurityWriteAccess)
d1798 1
a1798 1
	    if (access_mode & SecurityDestroyAccess)
d1804 1
a1804 1
    if (SecurityAllowOperation != action)
d1808 1
a1808 1
	char *actionstr = (SecurityIgnoreOperation == action) ?
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.1.2.1
log
@Merging a bunch of security fixes from X.org

CVE-2007-5760 - XFree86 Misc extension out of bounds array index.
CVE-2007-5958 - File existence disclosure.
CVE-2007-6427 - Xinput extension memory corruption.
CVE-2007-6428 - TOG-cup extension memory corruption.
CVE-2007-6429 - MIT-SHM and EVI extensions integer overflows.
CVE-2008-0006 - PCF Font parser buffer overflow.
@
text
@d1570 1
a1570 1
    f = Fopen(SecurityPolicyFile, "r");
d1656 1
a1656 1
    Fclose(f);
@


1.1.1.1.2.2
log
@Fixes for various integer overflow problems from X.Org:
CVE-2008-2360 - RENDER Extension heap buffer overflow
CVE-2008-2361 - RENDER Extension crash
CVE-2008-2362 - RENDER Extension memory corruption
CVE-2008-1379 - MIT-SHM arbitrary memory read
CVE-2008-1377 - RECORD and Security extensions memory corruption
@
text
@a653 1
    int values_offset;
d660 3
a662 6
    values_offset = ((stuff->nbytesAuthProto + (unsigned)3) >> 2) +
		    ((stuff->nbytesAuthData + (unsigned)3) >> 2);
    if (values_offset > 
	stuff->length - (sz_xSecurityGenerateAuthorizationReq >> 2))
	return BadLength;
    values = (CARD32 *)(&stuff[1]) + values_offset;
@


1.1.1.2
log
@xserver 1.4
@
text
@d80 1
a80 1
static CallbackListPtr SecurityValidateGroupCallback = NULL;
d603 1
a603 1
	stuff->authId, SecurityAuthorizationResType, DixDestroyAccess);
d949 1
a949 1
 *	res is a pointer to the resource structure for this resource.
d952 1
a952 1
 *	If access is granted, the value of rval that was passed in, else FALSE.
d969 1
a969 1
	DixUnknownAccess == access_mode)
a1189 1
	pWin->parent && pWin->parent->parent &&
d1220 1
a1220 1
	if (rec->access_mode == DixWriteAccess)
d1254 1
a1254 1
static char SecurityDefaultAction = XaceErrorOperation;
d1287 1
d1289 3
d1413 3
a1415 3
	    case 'i': action = XaceIgnoreOperation; break;
	    case 'a': action = XaceAllowOperation;  break;
	    case 'e': action = XaceErrorOperation;  break;
d1569 1
d1571 3
d1800 2
a1801 2
	    action = XaceAllowOperation;
	    if (access_mode & DixReadAccess)
d1803 1
a1803 1
	    if (access_mode & DixWriteAccess)
d1805 1
a1805 1
	    if (access_mode & DixDestroyAccess)
d1811 1
a1811 1
    if (XaceAllowOperation != action)
d1815 1
a1815 1
	char *actionstr = (XaceIgnoreOperation == action) ?
@

