head	1.13;
access;
symbols
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.08.09.18.59.50;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	6HLO5qdN5N4nPDjW;

1.12
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.19;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.46;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.44;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.00;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.00;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.52;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*****************************************************************
Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.
******************************************************************/

/* Massively rewritten by Mark Vojkovich <markv@@valinux.com> */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include "windowstr.h"
#include "dixfontstr.h"
#include "gcstruct.h"
#include "colormapst.h"
#include "scrnintstr.h"
#include "opaque.h"
#include "inputstr.h"
#include "migc.h"
#include "misc.h"
#include "dixstruct.h"
#include "panoramiX.h"
#include "panoramiXsrv.h"
#include "resource.h"
#include "panoramiXh.h"

#define XINERAMA_IMAGE_BUFSIZE (256*1024)
#define INPUTONLY_LEGAL_MASK (CWWinGravity | CWEventMask | \
                              CWDontPropagate | CWOverrideRedirect | CWCursor )

int
PanoramiXCreateWindow(ClientPtr client)
{
    PanoramiXRes *parent, *newWin;
    PanoramiXRes *backPix = NULL;
    PanoramiXRes *bordPix = NULL;
    PanoramiXRes *cmap = NULL;

    REQUEST(xCreateWindowReq);
    int pback_offset = 0, pbord_offset = 0, cmap_offset = 0;
    int result, len, j;
    int orig_x, orig_y;
    XID orig_visual, tmp;
    Bool parentIsRoot;

    REQUEST_AT_LEAST_SIZE(xCreateWindowReq);

    len = client->req_len - bytes_to_int32(sizeof(xCreateWindowReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    result = dixLookupResourceByType((void **) &parent, stuff->parent,
                                     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    if (stuff->class == CopyFromParent)
        stuff->class = parent->u.win.class;

    if ((stuff->class == InputOnly) && (stuff->mask & (~INPUTONLY_LEGAL_MASK)))
        return BadMatch;

    if ((Mask) stuff->mask & CWBackPixmap) {
        pback_offset = Ones((Mask) stuff->mask & (CWBackPixmap - 1));
        tmp = *((CARD32 *) &stuff[1] + pback_offset);
        if ((tmp != None) && (tmp != ParentRelative)) {
            result = dixLookupResourceByType((void **) &backPix, tmp,
                                             XRT_PIXMAP, client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }
    if ((Mask) stuff->mask & CWBorderPixmap) {
        pbord_offset = Ones((Mask) stuff->mask & (CWBorderPixmap - 1));
        tmp = *((CARD32 *) &stuff[1] + pbord_offset);
        if (tmp != CopyFromParent) {
            result = dixLookupResourceByType((void **) &bordPix, tmp,
                                             XRT_PIXMAP, client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }
    if ((Mask) stuff->mask & CWColormap) {
        cmap_offset = Ones((Mask) stuff->mask & (CWColormap - 1));
        tmp = *((CARD32 *) &stuff[1] + cmap_offset);
        if (tmp != CopyFromParent) {
            result = dixLookupResourceByType((void **) &cmap, tmp,
                                             XRT_COLORMAP, client,
                                             DixReadAccess);
            if (result != Success)
                return result;
        }
    }

    if (!(newWin = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newWin->type = XRT_WINDOW;
    newWin->u.win.visibility = VisibilityNotViewable;
    newWin->u.win.class = stuff->class;
    newWin->u.win.root = FALSE;
    panoramix_setup_ids(newWin, client, stuff->wid);

    if (stuff->class == InputOnly)
        stuff->visual = CopyFromParent;
    orig_visual = stuff->visual;
    orig_x = stuff->x;
    orig_y = stuff->y;
    parentIsRoot = (stuff->parent == screenInfo.screens[0]->root->drawable.id)
        || (stuff->parent == screenInfo.screens[0]->screensaver.wid);
    FOR_NSCREENS_BACKWARD(j) {
        stuff->wid = newWin->info[j].id;
        stuff->parent = parent->info[j].id;
        if (parentIsRoot) {
            stuff->x = orig_x - screenInfo.screens[j]->x;
            stuff->y = orig_y - screenInfo.screens[j]->y;
        }
        if (backPix)
            *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[j].id;
        if (bordPix)
            *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[j].id;
        if (cmap)
            *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[j].id;
        if (orig_visual != CopyFromParent)
            stuff->visual = PanoramiXTranslateVisualID(j, orig_visual);
        result = (*SavedProcVector[X_CreateWindow]) (client);
        if (result != Success)
            break;
    }

    if (result == Success)
        AddResource(newWin->info[0].id, XRT_WINDOW, newWin);
    else
        free(newWin);

    return result;
}

int
PanoramiXChangeWindowAttributes(ClientPtr client)
{
    PanoramiXRes *win;
    PanoramiXRes *backPix = NULL;
    PanoramiXRes *bordPix = NULL;
    PanoramiXRes *cmap = NULL;

    REQUEST(xChangeWindowAttributesReq);
    int pback_offset = 0, pbord_offset = 0, cmap_offset = 0;
    int result, len, j;
    XID tmp;

    REQUEST_AT_LEAST_SIZE(xChangeWindowAttributesReq);

    len = client->req_len - bytes_to_int32(sizeof(xChangeWindowAttributesReq));
    if (Ones(stuff->valueMask) != len)
        return BadLength;

    result = dixLookupResourceByType((void **) &win, stuff->window,
                                     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    if ((win->u.win.class == InputOnly) &&
        (stuff->valueMask & (~INPUTONLY_LEGAL_MASK)))
        return BadMatch;

    if ((Mask) stuff->valueMask & CWBackPixmap) {
        pback_offset = Ones((Mask) stuff->valueMask & (CWBackPixmap - 1));
        tmp = *((CARD32 *) &stuff[1] + pback_offset);
        if ((tmp != None) && (tmp != ParentRelative)) {
            result = dixLookupResourceByType((void **) &backPix, tmp,
                                             XRT_PIXMAP, client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }
    if ((Mask) stuff->valueMask & CWBorderPixmap) {
        pbord_offset = Ones((Mask) stuff->valueMask & (CWBorderPixmap - 1));
        tmp = *((CARD32 *) &stuff[1] + pbord_offset);
        if (tmp != CopyFromParent) {
            result = dixLookupResourceByType((void **) &bordPix, tmp,
                                             XRT_PIXMAP, client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }
    if ((Mask) stuff->valueMask & CWColormap) {
        cmap_offset = Ones((Mask) stuff->valueMask & (CWColormap - 1));
        tmp = *((CARD32 *) &stuff[1] + cmap_offset);
        if (tmp != CopyFromParent) {
            result = dixLookupResourceByType((void **) &cmap, tmp,
                                             XRT_COLORMAP, client,
                                             DixReadAccess);
            if (result != Success)
                return result;
        }
    }

    FOR_NSCREENS_BACKWARD(j) {
        stuff->window = win->info[j].id;
        if (backPix)
            *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[j].id;
        if (bordPix)
            *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[j].id;
        if (cmap)
            *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[j].id;
        result = (*SavedProcVector[X_ChangeWindowAttributes]) (client);
    }

    return result;
}

int
PanoramiXDestroyWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int result, j;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((void **) &win, stuff->id, XRT_WINDOW,
                                     client, DixDestroyAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->id = win->info[j].id;
        result = (*SavedProcVector[X_DestroyWindow]) (client);
        if (result != Success)
            break;
    }

    /* Since ProcDestroyWindow is using FreeResource, it will free
       our resource for us on the last pass through the loop above */

    return result;
}

int
PanoramiXDestroySubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int result, j;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((void **) &win, stuff->id, XRT_WINDOW,
                                     client, DixDestroyAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->id = win->info[j].id;
        result = (*SavedProcVector[X_DestroySubwindows]) (client);
        if (result != Success)
            break;
    }

    /* DestroySubwindows is using FreeResource which will free
       our resources for us on the last pass through the loop above */

    return result;
}

int
PanoramiXChangeSaveSet(ClientPtr client)
{
    PanoramiXRes *win;
    int result, j;

    REQUEST(xChangeSaveSetReq);

    REQUEST_SIZE_MATCH(xChangeSaveSetReq);

    result = dixLookupResourceByType((void **) &win, stuff->window,
                                     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->window = win->info[j].id;
        result = (*SavedProcVector[X_ChangeSaveSet]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXReparentWindow(ClientPtr client)
{
    PanoramiXRes *win, *parent;
    int result, j;
    int x, y;
    Bool parentIsRoot;

    REQUEST(xReparentWindowReq);

    REQUEST_SIZE_MATCH(xReparentWindowReq);

    result = dixLookupResourceByType((void **) &win, stuff->window,
                                     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((void **) &parent, stuff->parent,
                                     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    x = stuff->x;
    y = stuff->y;
    parentIsRoot = (stuff->parent == screenInfo.screens[0]->root->drawable.id)
        || (stuff->parent == screenInfo.screens[0]->screensaver.wid);
    FOR_NSCREENS_BACKWARD(j) {
        stuff->window = win->info[j].id;
        stuff->parent = parent->info[j].id;
        if (parentIsRoot) {
            stuff->x = x - screenInfo.screens[j]->x;
            stuff->y = y - screenInfo.screens[j]->y;
        }
        result = (*SavedProcVector[X_ReparentWindow]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXMapWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int result, j;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((void **) &win, stuff->id,
                                     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_FORWARD(j) {
        stuff->id = win->info[j].id;
        result = (*SavedProcVector[X_MapWindow]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXMapSubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int result, j;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((void **) &win, stuff->id,
                                     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_FORWARD(j) {
        stuff->id = win->info[j].id;
        result = (*SavedProcVector[X_MapSubwindows]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXUnmapWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int result, j;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((void **) &win, stuff->id,
                                     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_FORWARD(j) {
        stuff->id = win->info[j].id;
        result = (*SavedProcVector[X_UnmapWindow]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXUnmapSubwindows(ClientPtr client)
{
    PanoramiXRes *win;
    int result, j;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((void **) &win, stuff->id,
                                     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_FORWARD(j) {
        stuff->id = win->info[j].id;
        result = (*SavedProcVector[X_UnmapSubwindows]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXConfigureWindow(ClientPtr client)
{
    PanoramiXRes *win;
    PanoramiXRes *sib = NULL;
    WindowPtr pWin;
    int result, j, len, sib_offset = 0, x = 0, y = 0;
    int x_offset = -1;
    int y_offset = -1;

    REQUEST(xConfigureWindowReq);

    REQUEST_AT_LEAST_SIZE(xConfigureWindowReq);

    len = client->req_len - bytes_to_int32(sizeof(xConfigureWindowReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    /* because we need the parent */
    result = dixLookupResourceByType((void **) &pWin, stuff->window,
                                     RT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((void **) &win, stuff->window,
                                     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    if ((Mask) stuff->mask & CWSibling) {
        XID tmp;

        sib_offset = Ones((Mask) stuff->mask & (CWSibling - 1));
        if ((tmp = *((CARD32 *) &stuff[1] + sib_offset))) {
            result = dixLookupResourceByType((void **) &sib, tmp, XRT_WINDOW,
                                             client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }

    if (pWin->parent && ((pWin->parent == screenInfo.screens[0]->root) ||
                         (pWin->parent->drawable.id ==
                          screenInfo.screens[0]->screensaver.wid))) {
        if ((Mask) stuff->mask & CWX) {
            x_offset = 0;
            x = *((CARD32 *) &stuff[1]);
        }
        if ((Mask) stuff->mask & CWY) {
            y_offset = (x_offset == -1) ? 0 : 1;
            y = *((CARD32 *) &stuff[1] + y_offset);
        }
    }

    /* have to go forward or you get expose events before
       ConfigureNotify events */
    FOR_NSCREENS_FORWARD(j) {
        stuff->window = win->info[j].id;
        if (sib)
            *((CARD32 *) &stuff[1] + sib_offset) = sib->info[j].id;
        if (x_offset >= 0)
            *((CARD32 *) &stuff[1] + x_offset) = x - screenInfo.screens[j]->x;
        if (y_offset >= 0)
            *((CARD32 *) &stuff[1] + y_offset) = y - screenInfo.screens[j]->y;
        result = (*SavedProcVector[X_ConfigureWindow]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXCirculateWindow(ClientPtr client)
{
    PanoramiXRes *win;
    int result, j;

    REQUEST(xCirculateWindowReq);

    REQUEST_SIZE_MATCH(xCirculateWindowReq);

    result = dixLookupResourceByType((void **) &win, stuff->window,
                                     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_FORWARD(j) {
        stuff->window = win->info[j].id;
        result = (*SavedProcVector[X_CirculateWindow]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXGetGeometry(ClientPtr client)
{
    xGetGeometryReply rep;
    DrawablePtr pDraw;
    int rc;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);
    rc = dixLookupDrawable(&pDraw, stuff->id, client, M_ANY, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep = (xGetGeometryReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .root = screenInfo.screens[0]->root->drawable.id,
        .depth = pDraw->depth,
        .width = pDraw->width,
        .height = pDraw->height,
        .x = 0,
        .y = 0,
        .borderWidth = 0
    };

    if (stuff->id == rep.root) {
        xWindowRoot *root = (xWindowRoot *)
            (ConnectionInfo + connBlockScreenStart);

        rep.width = root->pixWidth;
        rep.height = root->pixHeight;
    }
    else if (WindowDrawable(pDraw->type)) {
        WindowPtr pWin = (WindowPtr) pDraw;

        rep.x = pWin->origin.x - wBorderWidth(pWin);
        rep.y = pWin->origin.y - wBorderWidth(pWin);
        if ((pWin->parent == screenInfo.screens[0]->root) ||
            (pWin->parent->drawable.id ==
             screenInfo.screens[0]->screensaver.wid)) {
            rep.x += screenInfo.screens[0]->x;
            rep.y += screenInfo.screens[0]->y;
        }
        rep.borderWidth = pWin->borderWidth;
    }

    WriteReplyToClient(client, sizeof(xGetGeometryReply), &rep);
    return Success;
}

int
PanoramiXTranslateCoords(ClientPtr client)
{
    INT16 x, y;

    REQUEST(xTranslateCoordsReq);
    int rc;
    WindowPtr pWin, pDst;
    xTranslateCoordsReply rep;

    REQUEST_SIZE_MATCH(xTranslateCoordsReq);
    rc = dixLookupWindow(&pWin, stuff->srcWid, client, DixReadAccess);
    if (rc != Success)
        return rc;
    rc = dixLookupWindow(&pDst, stuff->dstWid, client, DixReadAccess);
    if (rc != Success)
        return rc;
    rep = (xTranslateCoordsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .sameScreen = xTrue,
        .child = None
    };

    if ((pWin == screenInfo.screens[0]->root) ||
        (pWin->drawable.id == screenInfo.screens[0]->screensaver.wid)) {
        x = stuff->srcX - screenInfo.screens[0]->x;
        y = stuff->srcY - screenInfo.screens[0]->y;
    }
    else {
        x = pWin->drawable.x + stuff->srcX;
        y = pWin->drawable.y + stuff->srcY;
    }
    pWin = pDst->firstChild;
    while (pWin) {
        BoxRec box;

        if ((pWin->mapped) &&
            (x >= pWin->drawable.x - wBorderWidth(pWin)) &&
            (x < pWin->drawable.x + (int) pWin->drawable.width +
             wBorderWidth(pWin)) &&
            (y >= pWin->drawable.y - wBorderWidth(pWin)) &&
            (y < pWin->drawable.y + (int) pWin->drawable.height +
             wBorderWidth(pWin))
            /* When a window is shaped, a further check
             * is made to see if the point is inside
             * borderSize
             */
            && (!wBoundingShape(pWin) ||
                RegionContainsPoint(wBoundingShape(pWin),
                                    x - pWin->drawable.x,
                                    y - pWin->drawable.y, &box))
            ) {
            rep.child = pWin->drawable.id;
            pWin = (WindowPtr) NULL;
        }
        else
            pWin = pWin->nextSib;
    }
    rep.dstX = x - pDst->drawable.x;
    rep.dstY = y - pDst->drawable.y;
    if ((pDst == screenInfo.screens[0]->root) ||
        (pDst->drawable.id == screenInfo.screens[0]->screensaver.wid)) {
        rep.dstX += screenInfo.screens[0]->x;
        rep.dstY += screenInfo.screens[0]->y;
    }

    WriteReplyToClient(client, sizeof(xTranslateCoordsReply), &rep);
    return Success;
}

int
PanoramiXCreatePixmap(ClientPtr client)
{
    PanoramiXRes *refDraw, *newPix;
    int result, j;

    REQUEST(xCreatePixmapReq);

    REQUEST_SIZE_MATCH(xCreatePixmapReq);
    client->errorValue = stuff->pid;

    result = dixLookupResourceByClass((void **) &refDraw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixReadAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (!(newPix = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newPix->type = XRT_PIXMAP;
    newPix->u.pix.shared = FALSE;
    panoramix_setup_ids(newPix, client, stuff->pid);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->pid = newPix->info[j].id;
        stuff->drawable = refDraw->info[j].id;
        result = (*SavedProcVector[X_CreatePixmap]) (client);
        if (result != Success)
            break;
    }

    if (result == Success)
        AddResource(newPix->info[0].id, XRT_PIXMAP, newPix);
    else
        free(newPix);

    return result;
}

int
PanoramiXFreePixmap(ClientPtr client)
{
    PanoramiXRes *pix;
    int result, j;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    client->errorValue = stuff->id;

    result = dixLookupResourceByType((void **) &pix, stuff->id, XRT_PIXMAP,
                                     client, DixDestroyAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->id = pix->info[j].id;
        result = (*SavedProcVector[X_FreePixmap]) (client);
        if (result != Success)
            break;
    }

    /* Since ProcFreePixmap is using FreeResource, it will free
       our resource for us on the last pass through the loop above */

    return result;
}

int
PanoramiXCreateGC(ClientPtr client)
{
    PanoramiXRes *refDraw;
    PanoramiXRes *newGC;
    PanoramiXRes *stip = NULL;
    PanoramiXRes *tile = NULL;
    PanoramiXRes *clip = NULL;

    REQUEST(xCreateGCReq);
    int tile_offset = 0, stip_offset = 0, clip_offset = 0;
    int result, len, j;
    XID tmp;

    REQUEST_AT_LEAST_SIZE(xCreateGCReq);

    client->errorValue = stuff->gc;
    len = client->req_len - bytes_to_int32(sizeof(xCreateGCReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    result = dixLookupResourceByClass((void **) &refDraw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixReadAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if ((Mask) stuff->mask & GCTile) {
        tile_offset = Ones((Mask) stuff->mask & (GCTile - 1));
        if ((tmp = *((CARD32 *) &stuff[1] + tile_offset))) {
            result = dixLookupResourceByType((void **) &tile, tmp, XRT_PIXMAP,
                                             client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }
    if ((Mask) stuff->mask & GCStipple) {
        stip_offset = Ones((Mask) stuff->mask & (GCStipple - 1));
        if ((tmp = *((CARD32 *) &stuff[1] + stip_offset))) {
            result = dixLookupResourceByType((void **) &stip, tmp, XRT_PIXMAP,
                                             client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }
    if ((Mask) stuff->mask & GCClipMask) {
        clip_offset = Ones((Mask) stuff->mask & (GCClipMask - 1));
        if ((tmp = *((CARD32 *) &stuff[1] + clip_offset))) {
            result = dixLookupResourceByType((void **) &clip, tmp, XRT_PIXMAP,
                                             client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }

    if (!(newGC = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newGC->type = XRT_GC;
    panoramix_setup_ids(newGC, client, stuff->gc);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = newGC->info[j].id;
        stuff->drawable = refDraw->info[j].id;
        if (tile)
            *((CARD32 *) &stuff[1] + tile_offset) = tile->info[j].id;
        if (stip)
            *((CARD32 *) &stuff[1] + stip_offset) = stip->info[j].id;
        if (clip)
            *((CARD32 *) &stuff[1] + clip_offset) = clip->info[j].id;
        result = (*SavedProcVector[X_CreateGC]) (client);
        if (result != Success)
            break;
    }

    if (result == Success)
        AddResource(newGC->info[0].id, XRT_GC, newGC);
    else
        free(newGC);

    return result;
}

int
PanoramiXChangeGC(ClientPtr client)
{
    PanoramiXRes *gc;
    PanoramiXRes *stip = NULL;
    PanoramiXRes *tile = NULL;
    PanoramiXRes *clip = NULL;

    REQUEST(xChangeGCReq);
    int tile_offset = 0, stip_offset = 0, clip_offset = 0;
    int result, len, j;
    XID tmp;

    REQUEST_AT_LEAST_SIZE(xChangeGCReq);

    len = client->req_len - bytes_to_int32(sizeof(xChangeGCReq));
    if (Ones(stuff->mask) != len)
        return BadLength;

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    if ((Mask) stuff->mask & GCTile) {
        tile_offset = Ones((Mask) stuff->mask & (GCTile - 1));
        if ((tmp = *((CARD32 *) &stuff[1] + tile_offset))) {
            result = dixLookupResourceByType((void **) &tile, tmp, XRT_PIXMAP,
                                             client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }
    if ((Mask) stuff->mask & GCStipple) {
        stip_offset = Ones((Mask) stuff->mask & (GCStipple - 1));
        if ((tmp = *((CARD32 *) &stuff[1] + stip_offset))) {
            result = dixLookupResourceByType((void **) &stip, tmp, XRT_PIXMAP,
                                             client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }
    if ((Mask) stuff->mask & GCClipMask) {
        clip_offset = Ones((Mask) stuff->mask & (GCClipMask - 1));
        if ((tmp = *((CARD32 *) &stuff[1] + clip_offset))) {
            result = dixLookupResourceByType((void **) &clip, tmp, XRT_PIXMAP,
                                             client, DixReadAccess);
            if (result != Success)
                return result;
        }
    }

    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = gc->info[j].id;
        if (tile)
            *((CARD32 *) &stuff[1] + tile_offset) = tile->info[j].id;
        if (stip)
            *((CARD32 *) &stuff[1] + stip_offset) = stip->info[j].id;
        if (clip)
            *((CARD32 *) &stuff[1] + clip_offset) = clip->info[j].id;
        result = (*SavedProcVector[X_ChangeGC]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXCopyGC(ClientPtr client)
{
    PanoramiXRes *srcGC, *dstGC;
    int result, j;

    REQUEST(xCopyGCReq);

    REQUEST_SIZE_MATCH(xCopyGCReq);

    result = dixLookupResourceByType((void **) &srcGC, stuff->srcGC, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((void **) &dstGC, stuff->dstGC, XRT_GC,
                                     client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS(j) {
        stuff->srcGC = srcGC->info[j].id;
        stuff->dstGC = dstGC->info[j].id;
        result = (*SavedProcVector[X_CopyGC]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXSetDashes(ClientPtr client)
{
    PanoramiXRes *gc;
    int result, j;

    REQUEST(xSetDashesReq);

    REQUEST_FIXED_SIZE(xSetDashesReq, stuff->nDashes);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = gc->info[j].id;
        result = (*SavedProcVector[X_SetDashes]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXSetClipRectangles(ClientPtr client)
{
    PanoramiXRes *gc;
    int result, j;

    REQUEST(xSetClipRectanglesReq);

    REQUEST_AT_LEAST_SIZE(xSetClipRectanglesReq);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->gc = gc->info[j].id;
        result = (*SavedProcVector[X_SetClipRectangles]) (client);
        if (result != Success)
            break;
    }

    return result;
}

int
PanoramiXFreeGC(ClientPtr client)
{
    PanoramiXRes *gc;
    int result, j;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    result = dixLookupResourceByType((void **) &gc, stuff->id, XRT_GC,
                                     client, DixDestroyAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->id = gc->info[j].id;
        result = (*SavedProcVector[X_FreeGC]) (client);
        if (result != Success)
            break;
    }

    /* Since ProcFreeGC is using FreeResource, it will free
       our resource for us on the last pass through the loop above */

    return result;
}

int
PanoramiXClearToBackground(ClientPtr client)
{
    PanoramiXRes *win;
    int result, j, x, y;
    Bool isRoot;

    REQUEST(xClearAreaReq);

    REQUEST_SIZE_MATCH(xClearAreaReq);

    result = dixLookupResourceByType((void **) &win, stuff->window,
                                     XRT_WINDOW, client, DixWriteAccess);
    if (result != Success)
        return result;

    x = stuff->x;
    y = stuff->y;
    isRoot = win->u.win.root;
    FOR_NSCREENS_BACKWARD(j) {
        stuff->window = win->info[j].id;
        if (isRoot) {
            stuff->x = x - screenInfo.screens[j]->x;
            stuff->y = y - screenInfo.screens[j]->y;
        }
        result = (*SavedProcVector[X_ClearArea]) (client);
        if (result != Success)
            break;
    }

    return result;
}

/*
    For Window to Pixmap copies you're screwed since each screen's
    pixmap will look like what it sees on its screen.  Unless the
    screens overlap and the window lies on each, the two copies
    will be out of sync.  To remedy this we do a GetImage and PutImage
    in place of the copy.  Doing this as a single Image isn't quite
    correct since it will include the obscured areas but we will
    have to fix this later. (MArk).
*/

int
PanoramiXCopyArea(ClientPtr client)
{
    int j, result, srcx, srcy, dstx, dsty;
    PanoramiXRes *gc, *src, *dst;
    Bool srcIsRoot = FALSE;
    Bool dstIsRoot = FALSE;
    Bool srcShared, dstShared;

    REQUEST(xCopyAreaReq);

    REQUEST_SIZE_MATCH(xCopyAreaReq);

    result = dixLookupResourceByClass((void **) &src, stuff->srcDrawable,
                                      XRC_DRAWABLE, client, DixReadAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    srcShared = IS_SHARED_PIXMAP(src);

    result = dixLookupResourceByClass((void **) &dst, stuff->dstDrawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    dstShared = IS_SHARED_PIXMAP(dst);

    if (dstShared && srcShared)
        return (*SavedProcVector[X_CopyArea]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    if ((dst->type == XRT_WINDOW) && dst->u.win.root)
        dstIsRoot = TRUE;
    if ((src->type == XRT_WINDOW) && src->u.win.root)
        srcIsRoot = TRUE;

    srcx = stuff->srcX;
    srcy = stuff->srcY;
    dstx = stuff->dstX;
    dsty = stuff->dstY;
    if ((dst->type == XRT_PIXMAP) && (src->type == XRT_WINDOW)) {
        DrawablePtr drawables[MAXSCREENS];
        DrawablePtr pDst;
        GCPtr pGC;
        char *data;
        int pitch, rc;

        FOR_NSCREENS(j) {
            rc = dixLookupDrawable(drawables + j, src->info[j].id, client, 0,
                                   DixGetAttrAccess);
            if (rc != Success)
                return rc;
        }

        pitch = PixmapBytePad(stuff->width, drawables[0]->depth);
        if (!(data = calloc(stuff->height, pitch)))
            return BadAlloc;

        XineramaGetImageData(drawables, srcx, srcy,
                             stuff->width, stuff->height, ZPixmap, ~0, data,
                             pitch, srcIsRoot);

        FOR_NSCREENS_BACKWARD(j) {
            stuff->gc = gc->info[j].id;
            VALIDATE_DRAWABLE_AND_GC(dst->info[j].id, pDst, DixWriteAccess);
            if (drawables[0]->depth != pDst->depth) {
                client->errorValue = stuff->dstDrawable;
                free(data);
                return BadMatch;
            }

            (*pGC->ops->PutImage) (pDst, pGC, pDst->depth, dstx, dsty,
                                   stuff->width, stuff->height,
                                   0, ZPixmap, data);

            if (dstShared)
                break;
        }

        free(data);
    }
    else {
        DrawablePtr pDst = NULL, pSrc = NULL;
        GCPtr pGC = NULL;
        RegionRec totalReg;
        int rc;

        RegionNull(&totalReg);
        FOR_NSCREENS_BACKWARD(j) {
            RegionPtr pRgn;

            stuff->dstDrawable = dst->info[j].id;
            stuff->srcDrawable = src->info[j].id;
            stuff->gc = gc->info[j].id;
            if (srcIsRoot) {
                stuff->srcX = srcx - screenInfo.screens[j]->x;
                stuff->srcY = srcy - screenInfo.screens[j]->y;
            }
            if (dstIsRoot) {
                stuff->dstX = dstx - screenInfo.screens[j]->x;
                stuff->dstY = dsty - screenInfo.screens[j]->y;
            }

            VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pDst, DixWriteAccess);

            if (stuff->dstDrawable != stuff->srcDrawable) {
                rc = dixLookupDrawable(&pSrc, stuff->srcDrawable, client, 0,
                                       DixReadAccess);
                if (rc != Success)
                    return rc;

                if ((pDst->pScreen != pSrc->pScreen) ||
                    (pDst->depth != pSrc->depth)) {
                    client->errorValue = stuff->dstDrawable;
                    return BadMatch;
                }
            }
            else
                pSrc = pDst;

            pRgn = (*pGC->ops->CopyArea) (pSrc, pDst, pGC,
                                          stuff->srcX, stuff->srcY,
                                          stuff->width, stuff->height,
                                          stuff->dstX, stuff->dstY);
            if (pGC->graphicsExposures && pRgn) {
                if (srcIsRoot) {
                    RegionTranslate(pRgn,
                                    screenInfo.screens[j]->x,
                                    screenInfo.screens[j]->y);
                }
                RegionAppend(&totalReg, pRgn);
                RegionDestroy(pRgn);
            }

            if (dstShared)
                break;
        }

        if (pGC->graphicsExposures) {
            Bool overlap;

            RegionValidate(&totalReg, &overlap);
            SendGraphicsExpose(client, &totalReg, stuff->dstDrawable,
                               X_CopyArea, 0);
            RegionUninit(&totalReg);
        }
    }

    return Success;
}

int
PanoramiXCopyPlane(ClientPtr client)
{
    int j, srcx, srcy, dstx, dsty, rc;
    PanoramiXRes *gc, *src, *dst;
    Bool srcIsRoot = FALSE;
    Bool dstIsRoot = FALSE;
    Bool srcShared, dstShared;
    DrawablePtr psrcDraw, pdstDraw = NULL;
    GCPtr pGC = NULL;
    RegionRec totalReg;

    REQUEST(xCopyPlaneReq);

    REQUEST_SIZE_MATCH(xCopyPlaneReq);

    rc = dixLookupResourceByClass((void **) &src, stuff->srcDrawable,
                                  XRC_DRAWABLE, client, DixReadAccess);
    if (rc != Success)
        return (rc == BadValue) ? BadDrawable : rc;

    srcShared = IS_SHARED_PIXMAP(src);

    rc = dixLookupResourceByClass((void **) &dst, stuff->dstDrawable,
                                  XRC_DRAWABLE, client, DixWriteAccess);
    if (rc != Success)
        return (rc == BadValue) ? BadDrawable : rc;

    dstShared = IS_SHARED_PIXMAP(dst);

    if (dstShared && srcShared)
        return (*SavedProcVector[X_CopyPlane]) (client);

    rc = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                 client, DixReadAccess);
    if (rc != Success)
        return rc;

    if ((dst->type == XRT_WINDOW) && dst->u.win.root)
        dstIsRoot = TRUE;
    if ((src->type == XRT_WINDOW) && src->u.win.root)
        srcIsRoot = TRUE;

    srcx = stuff->srcX;
    srcy = stuff->srcY;
    dstx = stuff->dstX;
    dsty = stuff->dstY;

    RegionNull(&totalReg);
    FOR_NSCREENS_BACKWARD(j) {
        RegionPtr pRgn;

        stuff->dstDrawable = dst->info[j].id;
        stuff->srcDrawable = src->info[j].id;
        stuff->gc = gc->info[j].id;
        if (srcIsRoot) {
            stuff->srcX = srcx - screenInfo.screens[j]->x;
            stuff->srcY = srcy - screenInfo.screens[j]->y;
        }
        if (dstIsRoot) {
            stuff->dstX = dstx - screenInfo.screens[j]->x;
            stuff->dstY = dsty - screenInfo.screens[j]->y;
        }

        VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pdstDraw, DixWriteAccess);
        if (stuff->dstDrawable != stuff->srcDrawable) {
            rc = dixLookupDrawable(&psrcDraw, stuff->srcDrawable, client, 0,
                                   DixReadAccess);
            if (rc != Success)
                return rc;

            if (pdstDraw->pScreen != psrcDraw->pScreen) {
                client->errorValue = stuff->dstDrawable;
                return BadMatch;
            }
        }
        else
            psrcDraw = pdstDraw;

        if (stuff->bitPlane == 0 || (stuff->bitPlane & (stuff->bitPlane - 1)) ||
            (stuff->bitPlane > (1L << (psrcDraw->depth - 1)))) {
            client->errorValue = stuff->bitPlane;
            return BadValue;
        }

        pRgn = (*pGC->ops->CopyPlane) (psrcDraw, pdstDraw, pGC,
                                       stuff->srcX, stuff->srcY,
                                       stuff->width, stuff->height,
                                       stuff->dstX, stuff->dstY,
                                       stuff->bitPlane);
        if (pGC->graphicsExposures && pRgn) {
            RegionAppend(&totalReg, pRgn);
            RegionDestroy(pRgn);
        }

        if (dstShared)
            break;
    }

    if (pGC->graphicsExposures) {
        Bool overlap;

        RegionValidate(&totalReg, &overlap);
        SendGraphicsExpose(client, &totalReg, stuff->dstDrawable,
                           X_CopyPlane, 0);
        RegionUninit(&totalReg);
    }

    return Success;
}

int
PanoramiXPolyPoint(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    int result, npoint, j;
    xPoint *origPts;
    Bool isRoot;

    REQUEST(xPolyPointReq);

    REQUEST_AT_LEAST_SIZE(xPolyPointReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_PolyPoint]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
    npoint = bytes_to_int32((client->req_len << 2) - sizeof(xPolyPointReq));
    if (npoint > 0) {
        origPts = xallocarray(npoint, sizeof(xPoint));
        memcpy((char *) origPts, (char *) &stuff[1], npoint * sizeof(xPoint));
        FOR_NSCREENS_FORWARD(j) {

            if (j)
                memcpy(&stuff[1], origPts, npoint * sizeof(xPoint));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xPoint *pnts = (xPoint *) &stuff[1];
                    int i =
                        (stuff->coordMode == CoordModePrevious) ? 1 : npoint;

                    while (i--) {
                        pnts->x -= x_off;
                        pnts->y -= y_off;
                        pnts++;
                    }
                }
            }

            stuff->drawable = draw->info[j].id;
            stuff->gc = gc->info[j].id;
            result = (*SavedProcVector[X_PolyPoint]) (client);
            if (result != Success)
                break;
        }
        free(origPts);
        return result;
    }
    else
        return Success;
}

int
PanoramiXPolyLine(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    int result, npoint, j;
    xPoint *origPts;
    Bool isRoot;

    REQUEST(xPolyLineReq);

    REQUEST_AT_LEAST_SIZE(xPolyLineReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_PolyLine]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);
    npoint = bytes_to_int32((client->req_len << 2) - sizeof(xPolyLineReq));
    if (npoint > 0) {
        origPts = xallocarray(npoint, sizeof(xPoint));
        memcpy((char *) origPts, (char *) &stuff[1], npoint * sizeof(xPoint));
        FOR_NSCREENS_FORWARD(j) {

            if (j)
                memcpy(&stuff[1], origPts, npoint * sizeof(xPoint));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xPoint *pnts = (xPoint *) &stuff[1];
                    int i =
                        (stuff->coordMode == CoordModePrevious) ? 1 : npoint;

                    while (i--) {
                        pnts->x -= x_off;
                        pnts->y -= y_off;
                        pnts++;
                    }
                }
            }

            stuff->drawable = draw->info[j].id;
            stuff->gc = gc->info[j].id;
            result = (*SavedProcVector[X_PolyLine]) (client);
            if (result != Success)
                break;
        }
        free(origPts);
        return result;
    }
    else
        return Success;
}

int
PanoramiXPolySegment(ClientPtr client)
{
    int result, nsegs, i, j;
    PanoramiXRes *gc, *draw;
    xSegment *origSegs;
    Bool isRoot;

    REQUEST(xPolySegmentReq);

    REQUEST_AT_LEAST_SIZE(xPolySegmentReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_PolySegment]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    nsegs = (client->req_len << 2) - sizeof(xPolySegmentReq);
    if (nsegs & 4)
        return BadLength;
    nsegs >>= 3;
    if (nsegs > 0) {
        origSegs = xallocarray(nsegs, sizeof(xSegment));
        memcpy((char *) origSegs, (char *) &stuff[1], nsegs * sizeof(xSegment));
        FOR_NSCREENS_FORWARD(j) {

            if (j)
                memcpy(&stuff[1], origSegs, nsegs * sizeof(xSegment));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xSegment *segs = (xSegment *) &stuff[1];

                    for (i = nsegs; i--; segs++) {
                        segs->x1 -= x_off;
                        segs->x2 -= x_off;
                        segs->y1 -= y_off;
                        segs->y2 -= y_off;
                    }
                }
            }

            stuff->drawable = draw->info[j].id;
            stuff->gc = gc->info[j].id;
            result = (*SavedProcVector[X_PolySegment]) (client);
            if (result != Success)
                break;
        }
        free(origSegs);
        return result;
    }
    else
        return Success;
}

int
PanoramiXPolyRectangle(ClientPtr client)
{
    int result, nrects, i, j;
    PanoramiXRes *gc, *draw;
    Bool isRoot;
    xRectangle *origRecs;

    REQUEST(xPolyRectangleReq);

    REQUEST_AT_LEAST_SIZE(xPolyRectangleReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_PolyRectangle]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    nrects = (client->req_len << 2) - sizeof(xPolyRectangleReq);
    if (nrects & 4)
        return BadLength;
    nrects >>= 3;
    if (nrects > 0) {
        origRecs = xallocarray(nrects, sizeof(xRectangle));
        memcpy((char *) origRecs, (char *) &stuff[1],
               nrects * sizeof(xRectangle));
        FOR_NSCREENS_FORWARD(j) {

            if (j)
                memcpy(&stuff[1], origRecs, nrects * sizeof(xRectangle));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xRectangle *rects = (xRectangle *) &stuff[1];

                    for (i = nrects; i--; rects++) {
                        rects->x -= x_off;
                        rects->y -= y_off;
                    }
                }
            }

            stuff->drawable = draw->info[j].id;
            stuff->gc = gc->info[j].id;
            result = (*SavedProcVector[X_PolyRectangle]) (client);
            if (result != Success)
                break;
        }
        free(origRecs);
        return result;
    }
    else
        return Success;
}

int
PanoramiXPolyArc(ClientPtr client)
{
    int result, narcs, i, j;
    PanoramiXRes *gc, *draw;
    Bool isRoot;
    xArc *origArcs;

    REQUEST(xPolyArcReq);

    REQUEST_AT_LEAST_SIZE(xPolyArcReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_PolyArc]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    narcs = (client->req_len << 2) - sizeof(xPolyArcReq);
    if (narcs % sizeof(xArc))
        return BadLength;
    narcs /= sizeof(xArc);
    if (narcs > 0) {
        origArcs = xallocarray(narcs, sizeof(xArc));
        memcpy((char *) origArcs, (char *) &stuff[1], narcs * sizeof(xArc));
        FOR_NSCREENS_FORWARD(j) {

            if (j)
                memcpy(&stuff[1], origArcs, narcs * sizeof(xArc));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xArc *arcs = (xArc *) &stuff[1];

                    for (i = narcs; i--; arcs++) {
                        arcs->x -= x_off;
                        arcs->y -= y_off;
                    }
                }
            }
            stuff->drawable = draw->info[j].id;
            stuff->gc = gc->info[j].id;
            result = (*SavedProcVector[X_PolyArc]) (client);
            if (result != Success)
                break;
        }
        free(origArcs);
        return result;
    }
    else
        return Success;
}

int
PanoramiXFillPoly(ClientPtr client)
{
    int result, count, j;
    PanoramiXRes *gc, *draw;
    Bool isRoot;
    DDXPointPtr locPts;

    REQUEST(xFillPolyReq);

    REQUEST_AT_LEAST_SIZE(xFillPolyReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_FillPoly]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    count = bytes_to_int32((client->req_len << 2) - sizeof(xFillPolyReq));
    if (count > 0) {
        locPts = xallocarray(count, sizeof(DDXPointRec));
        memcpy((char *) locPts, (char *) &stuff[1],
               count * sizeof(DDXPointRec));
        FOR_NSCREENS_FORWARD(j) {

            if (j)
                memcpy(&stuff[1], locPts, count * sizeof(DDXPointRec));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    DDXPointPtr pnts = (DDXPointPtr) &stuff[1];
                    int i = (stuff->coordMode == CoordModePrevious) ? 1 : count;

                    while (i--) {
                        pnts->x -= x_off;
                        pnts->y -= y_off;
                        pnts++;
                    }
                }
            }

            stuff->drawable = draw->info[j].id;
            stuff->gc = gc->info[j].id;
            result = (*SavedProcVector[X_FillPoly]) (client);
            if (result != Success)
                break;
        }
        free(locPts);
        return result;
    }
    else
        return Success;
}

int
PanoramiXPolyFillRectangle(ClientPtr client)
{
    int result, things, i, j;
    PanoramiXRes *gc, *draw;
    Bool isRoot;
    xRectangle *origRects;

    REQUEST(xPolyFillRectangleReq);

    REQUEST_AT_LEAST_SIZE(xPolyFillRectangleReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_PolyFillRectangle]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    things = (client->req_len << 2) - sizeof(xPolyFillRectangleReq);
    if (things & 4)
        return BadLength;
    things >>= 3;
    if (things > 0) {
        origRects = xallocarray(things, sizeof(xRectangle));
        memcpy((char *) origRects, (char *) &stuff[1],
               things * sizeof(xRectangle));
        FOR_NSCREENS_FORWARD(j) {

            if (j)
                memcpy(&stuff[1], origRects, things * sizeof(xRectangle));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xRectangle *rects = (xRectangle *) &stuff[1];

                    for (i = things; i--; rects++) {
                        rects->x -= x_off;
                        rects->y -= y_off;
                    }
                }
            }

            stuff->drawable = draw->info[j].id;
            stuff->gc = gc->info[j].id;
            result = (*SavedProcVector[X_PolyFillRectangle]) (client);
            if (result != Success)
                break;
        }
        free(origRects);
        return result;
    }
    else
        return Success;
}

int
PanoramiXPolyFillArc(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool isRoot;
    int result, narcs, i, j;
    xArc *origArcs;

    REQUEST(xPolyFillArcReq);

    REQUEST_AT_LEAST_SIZE(xPolyFillArcReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_PolyFillArc]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    narcs = (client->req_len << 2) - sizeof(xPolyFillArcReq);
    if (narcs % sizeof(xArc))
        return BadLength;
    narcs /= sizeof(xArc);
    if (narcs > 0) {
        origArcs = xallocarray(narcs, sizeof(xArc));
        memcpy((char *) origArcs, (char *) &stuff[1], narcs * sizeof(xArc));
        FOR_NSCREENS_FORWARD(j) {

            if (j)
                memcpy(&stuff[1], origArcs, narcs * sizeof(xArc));

            if (isRoot) {
                int x_off = screenInfo.screens[j]->x;
                int y_off = screenInfo.screens[j]->y;

                if (x_off || y_off) {
                    xArc *arcs = (xArc *) &stuff[1];

                    for (i = narcs; i--; arcs++) {
                        arcs->x -= x_off;
                        arcs->y -= y_off;
                    }
                }
            }

            stuff->drawable = draw->info[j].id;
            stuff->gc = gc->info[j].id;
            result = (*SavedProcVector[X_PolyFillArc]) (client);
            if (result != Success)
                break;
        }
        free(origArcs);
        return result;
    }
    else
        return Success;
}

int
PanoramiXPutImage(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool isRoot;
    int j, result, orig_x, orig_y;

    REQUEST(xPutImageReq);

    REQUEST_AT_LEAST_SIZE(xPutImageReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_PutImage]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->dstX;
    orig_y = stuff->dstY;
    FOR_NSCREENS_BACKWARD(j) {
        if (isRoot) {
            stuff->dstX = orig_x - screenInfo.screens[j]->x;
            stuff->dstY = orig_y - screenInfo.screens[j]->y;
        }
        stuff->drawable = draw->info[j].id;
        stuff->gc = gc->info[j].id;
        result = (*SavedProcVector[X_PutImage]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXGetImage(ClientPtr client)
{
    DrawablePtr drawables[MAXSCREENS];
    DrawablePtr pDraw;
    PanoramiXRes *draw;
    xGetImageReply xgi;
    Bool isRoot;
    char *pBuf;
    int i, x, y, w, h, format, rc;
    Mask plane = 0, planemask;
    int linesDone, nlines, linesPerBuf;
    long widthBytesLine, length;

    REQUEST(xGetImageReq);

    REQUEST_SIZE_MATCH(xGetImageReq);

    if ((stuff->format != XYPixmap) && (stuff->format != ZPixmap)) {
        client->errorValue = stuff->format;
        return BadValue;
    }

    rc = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                  XRC_DRAWABLE, client, DixReadAccess);
    if (rc != Success)
        return (rc == BadValue) ? BadDrawable : rc;

    if (draw->type == XRT_PIXMAP)
        return (*SavedProcVector[X_GetImage]) (client);

    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0, DixReadAccess);
    if (rc != Success)
        return rc;

    if (!((WindowPtr) pDraw)->realized)
        return BadMatch;

    x = stuff->x;
    y = stuff->y;
    w = stuff->width;
    h = stuff->height;
    format = stuff->format;
    planemask = stuff->planeMask;

    isRoot = IS_ROOT_DRAWABLE(draw);

    if (isRoot) {
        /* check for being onscreen */
        if (x < 0 || x + w > PanoramiXPixWidth ||
            y < 0 || y + h > PanoramiXPixHeight)
            return BadMatch;
    }
    else {
        /* check for being onscreen and inside of border */
        if (screenInfo.screens[0]->x + pDraw->x + x < 0 ||
            screenInfo.screens[0]->x + pDraw->x + x + w > PanoramiXPixWidth ||
            screenInfo.screens[0]->y + pDraw->y + y < 0 ||
            screenInfo.screens[0]->y + pDraw->y + y + h > PanoramiXPixHeight ||
            x < -wBorderWidth((WindowPtr) pDraw) ||
            x + w > wBorderWidth((WindowPtr) pDraw) + (int) pDraw->width ||
            y < -wBorderWidth((WindowPtr) pDraw) ||
            y + h > wBorderWidth((WindowPtr) pDraw) + (int) pDraw->height)
            return BadMatch;
    }

    drawables[0] = pDraw;
    FOR_NSCREENS_FORWARD_SKIP(i) {
        rc = dixLookupDrawable(drawables + i, draw->info[i].id, client, 0,
                               DixGetAttrAccess);
        if (rc != Success)
            return rc;
    }

    xgi = (xGetImageReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .visual = wVisual(((WindowPtr) pDraw)),
        .depth = pDraw->depth
    };
    if (format == ZPixmap) {
        widthBytesLine = PixmapBytePad(w, pDraw->depth);
        length = widthBytesLine * h;

    }
    else {
        widthBytesLine = BitmapBytePad(w);
        plane = ((Mask) 1) << (pDraw->depth - 1);
        /* only planes asked for */
        length = widthBytesLine * h * Ones(planemask & (plane | (plane - 1)));

    }

    xgi.length = bytes_to_int32(length);

    if (widthBytesLine == 0 || h == 0)
        linesPerBuf = 0;
    else if (widthBytesLine >= XINERAMA_IMAGE_BUFSIZE)
        linesPerBuf = 1;
    else {
        linesPerBuf = XINERAMA_IMAGE_BUFSIZE / widthBytesLine;
        if (linesPerBuf > h)
            linesPerBuf = h;
    }
    if (!(pBuf = xallocarray(linesPerBuf, widthBytesLine)))
        return BadAlloc;

    WriteReplyToClient(client, sizeof(xGetImageReply), &xgi);

    if (linesPerBuf == 0) {
        /* nothing to do */
    }
    else if (format == ZPixmap) {
        linesDone = 0;
        while (h - linesDone > 0) {
            nlines = min(linesPerBuf, h - linesDone);

            if (pDraw->depth == 1)
                memset(pBuf, 0, nlines * widthBytesLine);

            XineramaGetImageData(drawables, x, y + linesDone, w, nlines,
                                 format, planemask, pBuf, widthBytesLine,
                                 isRoot);

            WriteToClient(client, (int) (nlines * widthBytesLine), pBuf);
            linesDone += nlines;
        }
    }
    else {                      /* XYPixmap */
        for (; plane; plane >>= 1) {
            if (planemask & plane) {
                linesDone = 0;
                while (h - linesDone > 0) {
                    nlines = min(linesPerBuf, h - linesDone);

                    memset(pBuf, 0, nlines * widthBytesLine);

                    XineramaGetImageData(drawables, x, y + linesDone, w,
                                         nlines, format, plane, pBuf,
                                         widthBytesLine, isRoot);

                    WriteToClient(client, (int)(nlines * widthBytesLine), pBuf);

                    linesDone += nlines;
                }
            }
        }
    }
    free(pBuf);
    return Success;
}

/* The text stuff should be rewritten so that duplication happens
   at the GlyphBlt level.  That is, loading the font and getting
   the glyphs should only happen once */

int
PanoramiXPolyText8(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool isRoot;
    int result, j;
    int orig_x, orig_y;

    REQUEST(xPolyTextReq);

    REQUEST_AT_LEAST_SIZE(xPolyTextReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_PolyText8]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j) {
        stuff->drawable = draw->info[j].id;
        stuff->gc = gc->info[j].id;
        if (isRoot) {
            stuff->x = orig_x - screenInfo.screens[j]->x;
            stuff->y = orig_y - screenInfo.screens[j]->y;
        }
        result = (*SavedProcVector[X_PolyText8]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXPolyText16(ClientPtr client)
{
    PanoramiXRes *gc, *draw;
    Bool isRoot;
    int result, j;
    int orig_x, orig_y;

    REQUEST(xPolyTextReq);

    REQUEST_AT_LEAST_SIZE(xPolyTextReq);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_PolyText16]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j) {
        stuff->drawable = draw->info[j].id;
        stuff->gc = gc->info[j].id;
        if (isRoot) {
            stuff->x = orig_x - screenInfo.screens[j]->x;
            stuff->y = orig_y - screenInfo.screens[j]->y;
        }
        result = (*SavedProcVector[X_PolyText16]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXImageText8(ClientPtr client)
{
    int result, j;
    PanoramiXRes *gc, *draw;
    Bool isRoot;
    int orig_x, orig_y;

    REQUEST(xImageTextReq);

    REQUEST_FIXED_SIZE(xImageTextReq, stuff->nChars);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_ImageText8]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j) {
        stuff->drawable = draw->info[j].id;
        stuff->gc = gc->info[j].id;
        if (isRoot) {
            stuff->x = orig_x - screenInfo.screens[j]->x;
            stuff->y = orig_y - screenInfo.screens[j]->y;
        }
        result = (*SavedProcVector[X_ImageText8]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXImageText16(ClientPtr client)
{
    int result, j;
    PanoramiXRes *gc, *draw;
    Bool isRoot;
    int orig_x, orig_y;

    REQUEST(xImageTextReq);

    REQUEST_FIXED_SIZE(xImageTextReq, stuff->nChars << 1);

    result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
    if (result != Success)
        return (result == BadValue) ? BadDrawable : result;

    if (IS_SHARED_PIXMAP(draw))
        return (*SavedProcVector[X_ImageText16]) (client);

    result = dixLookupResourceByType((void **) &gc, stuff->gc, XRT_GC,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    isRoot = IS_ROOT_DRAWABLE(draw);

    orig_x = stuff->x;
    orig_y = stuff->y;
    FOR_NSCREENS_BACKWARD(j) {
        stuff->drawable = draw->info[j].id;
        stuff->gc = gc->info[j].id;
        if (isRoot) {
            stuff->x = orig_x - screenInfo.screens[j]->x;
            stuff->y = orig_y - screenInfo.screens[j]->y;
        }
        result = (*SavedProcVector[X_ImageText16]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXCreateColormap(ClientPtr client)
{
    PanoramiXRes *win, *newCmap;
    int result, j, orig_visual;

    REQUEST(xCreateColormapReq);

    REQUEST_SIZE_MATCH(xCreateColormapReq);

    result = dixLookupResourceByType((void **) &win, stuff->window,
                                     XRT_WINDOW, client, DixReadAccess);
    if (result != Success)
        return result;

    if (!(newCmap = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newCmap->type = XRT_COLORMAP;
    panoramix_setup_ids(newCmap, client, stuff->mid);

    orig_visual = stuff->visual;
    FOR_NSCREENS_BACKWARD(j) {
        stuff->mid = newCmap->info[j].id;
        stuff->window = win->info[j].id;
        stuff->visual = PanoramiXTranslateVisualID(j, orig_visual);
        result = (*SavedProcVector[X_CreateColormap]) (client);
        if (result != Success)
            break;
    }

    if (result == Success)
        AddResource(newCmap->info[0].id, XRT_COLORMAP, newCmap);
    else
        free(newCmap);

    return result;
}

int
PanoramiXFreeColormap(ClientPtr client)
{
    PanoramiXRes *cmap;
    int result, j;

    REQUEST(xResourceReq);

    REQUEST_SIZE_MATCH(xResourceReq);

    client->errorValue = stuff->id;

    result = dixLookupResourceByType((void **) &cmap, stuff->id, XRT_COLORMAP,
                                     client, DixDestroyAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->id = cmap->info[j].id;
        result = (*SavedProcVector[X_FreeColormap]) (client);
        if (result != Success)
            break;
    }

    /* Since ProcFreeColormap is using FreeResource, it will free
       our resource for us on the last pass through the loop above */

    return result;
}

int
PanoramiXCopyColormapAndFree(ClientPtr client)
{
    PanoramiXRes *cmap, *newCmap;
    int result, j;

    REQUEST(xCopyColormapAndFreeReq);

    REQUEST_SIZE_MATCH(xCopyColormapAndFreeReq);

    client->errorValue = stuff->srcCmap;

    result = dixLookupResourceByType((void **) &cmap, stuff->srcCmap,
                                     XRT_COLORMAP, client,
                                     DixReadAccess | DixWriteAccess);
    if (result != Success)
        return result;

    if (!(newCmap = malloc(sizeof(PanoramiXRes))))
        return BadAlloc;

    newCmap->type = XRT_COLORMAP;
    panoramix_setup_ids(newCmap, client, stuff->mid);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->srcCmap = cmap->info[j].id;
        stuff->mid = newCmap->info[j].id;
        result = (*SavedProcVector[X_CopyColormapAndFree]) (client);
        if (result != Success)
            break;
    }

    if (result == Success)
        AddResource(newCmap->info[0].id, XRT_COLORMAP, newCmap);
    else
        free(newCmap);

    return result;
}

int
PanoramiXInstallColormap(ClientPtr client)
{
    REQUEST(xResourceReq);
    int result, j;
    PanoramiXRes *cmap;

    REQUEST_SIZE_MATCH(xResourceReq);

    client->errorValue = stuff->id;

    result = dixLookupResourceByType((void **) &cmap, stuff->id, XRT_COLORMAP,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->id = cmap->info[j].id;
        result = (*SavedProcVector[X_InstallColormap]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXUninstallColormap(ClientPtr client)
{
    REQUEST(xResourceReq);
    int result, j;
    PanoramiXRes *cmap;

    REQUEST_SIZE_MATCH(xResourceReq);

    client->errorValue = stuff->id;

    result = dixLookupResourceByType((void **) &cmap, stuff->id, XRT_COLORMAP,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->id = cmap->info[j].id;
        result = (*SavedProcVector[X_UninstallColormap]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXAllocColor(ClientPtr client)
{
    int result, j;
    PanoramiXRes *cmap;

    REQUEST(xAllocColorReq);

    REQUEST_SIZE_MATCH(xAllocColorReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((void **) &cmap, stuff->cmap,
                                     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->cmap = cmap->info[j].id;
        result = (*SavedProcVector[X_AllocColor]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXAllocNamedColor(ClientPtr client)
{
    int result, j;
    PanoramiXRes *cmap;

    REQUEST(xAllocNamedColorReq);

    REQUEST_FIXED_SIZE(xAllocNamedColorReq, stuff->nbytes);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((void **) &cmap, stuff->cmap,
                                     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->cmap = cmap->info[j].id;
        result = (*SavedProcVector[X_AllocNamedColor]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXAllocColorCells(ClientPtr client)
{
    int result, j;
    PanoramiXRes *cmap;

    REQUEST(xAllocColorCellsReq);

    REQUEST_SIZE_MATCH(xAllocColorCellsReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((void **) &cmap, stuff->cmap,
                                     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->cmap = cmap->info[j].id;
        result = (*SavedProcVector[X_AllocColorCells]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXAllocColorPlanes(ClientPtr client)
{
    int result, j;
    PanoramiXRes *cmap;

    REQUEST(xAllocColorPlanesReq);

    REQUEST_SIZE_MATCH(xAllocColorPlanesReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((void **) &cmap, stuff->cmap,
                                     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->cmap = cmap->info[j].id;
        result = (*SavedProcVector[X_AllocColorPlanes]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXFreeColors(ClientPtr client)
{
    int result, j;
    PanoramiXRes *cmap;

    REQUEST(xFreeColorsReq);

    REQUEST_AT_LEAST_SIZE(xFreeColorsReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((void **) &cmap, stuff->cmap,
                                     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->cmap = cmap->info[j].id;
        result = (*SavedProcVector[X_FreeColors]) (client);
    }
    return result;
}

int
PanoramiXStoreColors(ClientPtr client)
{
    int result, j;
    PanoramiXRes *cmap;

    REQUEST(xStoreColorsReq);

    REQUEST_AT_LEAST_SIZE(xStoreColorsReq);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((void **) &cmap, stuff->cmap,
                                     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->cmap = cmap->info[j].id;
        result = (*SavedProcVector[X_StoreColors]) (client);
        if (result != Success)
            break;
    }
    return result;
}

int
PanoramiXStoreNamedColor(ClientPtr client)
{
    int result, j;
    PanoramiXRes *cmap;

    REQUEST(xStoreNamedColorReq);

    REQUEST_FIXED_SIZE(xStoreNamedColorReq, stuff->nbytes);

    client->errorValue = stuff->cmap;

    result = dixLookupResourceByType((void **) &cmap, stuff->cmap,
                                     XRT_COLORMAP, client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS_BACKWARD(j) {
        stuff->cmap = cmap->info[j].id;
        result = (*SavedProcVector[X_StoreNamedColor]) (client);
        if (result != Success)
            break;
    }
    return result;
}
@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d109 1
a109 1
        if ((tmp != CopyFromParent) && (tmp != None)) {
d213 1
a213 1
        if ((tmp != CopyFromParent) && (tmp != None)) {
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d1109 1
a1109 1
        if (!(data = calloc(1, stuff->height * pitch)))
d1344 1
a1344 1
        origPts = malloc(npoint * sizeof(xPoint));
d1409 1
a1409 1
        origPts = malloc(npoint * sizeof(xPoint));
d1478 1
a1478 1
        origSegs = malloc(nsegs * sizeof(xSegment));
d1546 1
a1546 1
        origRecs = malloc(nrects * sizeof(xRectangle));
d1613 1
a1613 1
        origArcs = malloc(narcs * sizeof(xArc));
d1675 1
a1675 1
        locPts = malloc(count * sizeof(DDXPointRec));
d1744 1
a1744 1
        origRects = malloc(things * sizeof(xRectangle));
d1811 1
a1811 1
        origArcs = malloc(narcs * sizeof(xArc));
d1991 1
a1991 2
    length = linesPerBuf * widthBytesLine;
    if (!(pBuf = malloc(length)))
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d512 1
a512 1
    /* have to go forward or you get expose events before 
d1040 1
a1040 1
/* 
d1196 2
a1197 3
            (*pDst->pScreen->SendGraphicsExpose) (client, &totalReg,
                                                  stuff->dstDrawable,
                                                  X_CopyArea, 0);
d1308 2
a1309 3
        (*pdstDraw->pScreen->SendGraphicsExpose) (client, &totalReg,
                                                  stuff->dstDrawable,
                                                  X_CopyPlane, 0);
d1911 1
a1911 1
                                  XRC_DRAWABLE, client, DixWriteAccess);
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d75 1
a75 1
    result = dixLookupResourceByType((pointer *) &parent, stuff->parent,
d90 1
a90 1
            result = dixLookupResourceByType((pointer *) &backPix, tmp,
d100 1
a100 1
            result = dixLookupResourceByType((pointer *) &bordPix, tmp,
d110 1
a110 1
            result = dixLookupResourceByType((pointer *) &cmap, tmp,
d181 1
a181 1
    result = dixLookupResourceByType((pointer *) &win, stuff->window,
d194 1
a194 1
            result = dixLookupResourceByType((pointer *) &backPix, tmp,
d204 1
a204 1
            result = dixLookupResourceByType((pointer *) &bordPix, tmp,
d214 1
a214 1
            result = dixLookupResourceByType((pointer *) &cmap, tmp,
d246 1
a246 1
    result = dixLookupResourceByType((pointer *) &win, stuff->id, XRT_WINDOW,
d274 1
a274 1
    result = dixLookupResourceByType((pointer *) &win, stuff->id, XRT_WINDOW,
d302 1
a302 1
    result = dixLookupResourceByType((pointer *) &win, stuff->window,
d329 1
a329 1
    result = dixLookupResourceByType((pointer *) &win, stuff->window,
d334 1
a334 1
    result = dixLookupResourceByType((pointer *) &parent, stuff->parent,
d368 1
a368 1
    result = dixLookupResourceByType((pointer *) &win, stuff->id,
d393 1
a393 1
    result = dixLookupResourceByType((pointer *) &win, stuff->id,
d418 1
a418 1
    result = dixLookupResourceByType((pointer *) &win, stuff->id,
d443 1
a443 1
    result = dixLookupResourceByType((pointer *) &win, stuff->id,
d477 1
a477 1
    result = dixLookupResourceByType((pointer *) &pWin, stuff->window,
d482 1
a482 1
    result = dixLookupResourceByType((pointer *) &win, stuff->window,
d492 1
a492 1
            result = dixLookupResourceByType((pointer *) &sib, tmp, XRT_WINDOW,
d540 1
a540 1
    result = dixLookupResourceByType((pointer *) &win, stuff->window,
d690 1
a690 1
    result = dixLookupResourceByClass((pointer *) &refDraw, stuff->drawable,
d730 1
a730 1
    result = dixLookupResourceByType((pointer *) &pix, stuff->id, XRT_PIXMAP,
d769 1
a769 1
    result = dixLookupResourceByClass((pointer *) &refDraw, stuff->drawable,
d777 1
a777 1
            result = dixLookupResourceByType((pointer *) &tile, tmp, XRT_PIXMAP,
d786 1
a786 1
            result = dixLookupResourceByType((pointer *) &stip, tmp, XRT_PIXMAP,
d795 1
a795 1
            result = dixLookupResourceByType((pointer *) &clip, tmp, XRT_PIXMAP,
d849 1
a849 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d857 1
a857 1
            result = dixLookupResourceByType((pointer *) &tile, tmp, XRT_PIXMAP,
d866 1
a866 1
            result = dixLookupResourceByType((pointer *) &stip, tmp, XRT_PIXMAP,
d875 1
a875 1
            result = dixLookupResourceByType((pointer *) &clip, tmp, XRT_PIXMAP,
d908 1
a908 1
    result = dixLookupResourceByType((pointer *) &srcGC, stuff->srcGC, XRT_GC,
d913 1
a913 1
    result = dixLookupResourceByType((pointer *) &dstGC, stuff->dstGC, XRT_GC,
d939 1
a939 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d964 1
a964 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d989 1
a989 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->id, XRT_GC,
d1018 1
a1018 1
    result = dixLookupResourceByType((pointer *) &win, stuff->window,
d1063 1
a1063 1
    result = dixLookupResourceByClass((pointer *) &src, stuff->srcDrawable,
d1070 1
a1070 1
    result = dixLookupResourceByClass((pointer *) &dst, stuff->dstDrawable,
d1080 1
a1080 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1222 1
a1222 1
    rc = dixLookupResourceByClass((pointer *) &src, stuff->srcDrawable,
d1229 1
a1229 1
    rc = dixLookupResourceByClass((pointer *) &dst, stuff->dstDrawable,
d1239 1
a1239 1
    rc = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1330 1
a1330 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1338 1
a1338 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1395 1
a1395 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1403 1
a1403 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1460 1
a1460 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1468 1
a1468 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1528 1
a1528 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1536 1
a1536 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1595 1
a1595 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1603 1
a1603 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1660 1
a1660 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1668 1
a1668 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1726 1
a1726 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1734 1
a1734 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1793 1
a1793 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1801 1
a1801 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1858 1
a1858 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1866 1
a1866 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d1912 1
a1912 1
    rc = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d2058 1
a2058 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d2066 1
a2066 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d2101 1
a2101 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d2109 1
a2109 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d2144 1
a2144 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d2152 1
a2152 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d2187 1
a2187 1
    result = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d2195 1
a2195 1
    result = dixLookupResourceByType((pointer *) &gc, stuff->gc, XRT_GC,
d2228 1
a2228 1
    result = dixLookupResourceByType((pointer *) &win, stuff->window,
d2269 1
a2269 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->id, XRT_COLORMAP,
d2299 1
a2299 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->srcCmap,
d2338 1
a2338 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->id, XRT_COLORMAP,
d2363 1
a2363 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->id, XRT_COLORMAP,
d2389 1
a2389 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->cmap,
d2415 1
a2415 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->cmap,
d2441 1
a2441 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->cmap,
d2467 1
a2467 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->cmap,
d2493 1
a2493 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->cmap,
d2517 1
a2517 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->cmap,
d2543 1
a2543 1
    result = dixLookupResourceByType((pointer *) &cmap, stuff->cmap,
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d569 12
a580 8
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.root = screenInfo.screens[0]->root->drawable.id;
    rep.depth = pDraw->depth;
    rep.width = pDraw->width;
    rep.height = pDraw->height;
    rep.x = rep.y = rep.borderWidth = 0;
d624 7
a630 5
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.sameScreen = xTrue;
    rep.child = None;
d1963 6
a1968 4
    xgi.visual = wVisual(((WindowPtr) pDraw));
    xgi.type = X_Reply;
    xgi.sequenceNumber = client->sequence;
    xgi.depth = pDraw->depth;
d2014 1
a2014 1
            (void) WriteToClient(client, (int) (nlines * widthBytesLine), pBuf);
d2031 1
a2031 2
                    (void) WriteToClient(client,
                                         (int) (nlines * widthBytesLine), pBuf);
@


1.7
log
@Update to xserver 1.11.2
@
text
@a27 1

d54 2
a55 1
int PanoramiXCreateWindow(ClientPtr client)
d60 2
a61 1
    PanoramiXRes *cmap    = NULL;
d70 1
a70 1
    
d75 2
a76 2
    result = dixLookupResourceByType((pointer *)&parent, stuff->parent,
				     XRT_WINDOW, client, DixWriteAccess);
d80 2
a81 2
    if(stuff->class == CopyFromParent)
	stuff->class = parent->u.win.class;
d83 1
a83 1
    if((stuff->class == InputOnly) && (stuff->mask & (~INPUTONLY_LEGAL_MASK)))
d86 30
a115 29
    if ((Mask)stuff->mask & CWBackPixmap) {
	pback_offset = Ones((Mask)stuff->mask & (CWBackPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pback_offset);
	if ((tmp != None) && (tmp != ParentRelative)) {
	    result = dixLookupResourceByType((pointer *)&backPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & CWBorderPixmap) {
	pbord_offset = Ones((Mask)stuff->mask & (CWBorderPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pbord_offset);
	if (tmp != CopyFromParent) {
	    result = dixLookupResourceByType((pointer *)&bordPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & CWColormap) {
	cmap_offset = Ones((Mask)stuff->mask & (CWColormap - 1));
	tmp = *((CARD32 *) &stuff[1] + cmap_offset);
	if ((tmp != CopyFromParent) && (tmp != None)) {
	    result = dixLookupResourceByType((pointer *)&cmap, tmp,
					     XRT_COLORMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
d118 1
a118 1
    if(!(newWin = malloc(sizeof(PanoramiXRes))))
d128 1
a128 1
	stuff->visual = CopyFromParent;
d132 2
a133 2
    parentIsRoot = (stuff->parent == screenInfo.screens[0]->root->drawable.id) ||
                   (stuff->parent == screenInfo.screens[0]->screensaver.wid);
d137 15
a151 14
	if (parentIsRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	if (backPix)
	    *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[j].id;
	if (bordPix)
	    *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[j].id;
	if (cmap)
	    *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[j].id;
	if ( orig_visual != CopyFromParent ) 
	    stuff->visual = PanoramiXTranslateVisualID(j, orig_visual);
        result = (*SavedProcVector[X_CreateWindow])(client);
        if(result != Success) break;
d156 1
a156 1
    else 
d162 2
a163 2

int PanoramiXChangeWindowAttributes(ClientPtr client)
d168 2
a169 1
    PanoramiXRes *cmap    = NULL;
d176 1
a176 1
    
d181 2
a182 2
    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
d186 2
a187 2
    if((win->u.win.class == InputOnly) && 
       (stuff->valueMask & (~INPUTONLY_LEGAL_MASK)))
d190 30
a219 29
    if ((Mask)stuff->valueMask & CWBackPixmap) {
	pback_offset = Ones((Mask)stuff->valueMask & (CWBackPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pback_offset);
	if ((tmp != None) && (tmp != ParentRelative)) {
	    result = dixLookupResourceByType((pointer *)&backPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->valueMask & CWBorderPixmap) {
	pbord_offset = Ones((Mask)stuff->valueMask & (CWBorderPixmap - 1));
	tmp = *((CARD32 *) &stuff[1] + pbord_offset);
	if (tmp != CopyFromParent) {
	    result = dixLookupResourceByType((pointer *)&bordPix, tmp,
					     XRT_PIXMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->valueMask & CWColormap) {
	cmap_offset = Ones((Mask)stuff->valueMask & (CWColormap - 1));
	tmp = *((CARD32 *) &stuff[1] + cmap_offset);
	if ((tmp != CopyFromParent) && (tmp != None)) {
	    result = dixLookupResourceByType((pointer *)&cmap, tmp,
					     XRT_COLORMAP, client, DixReadAccess);
	    if (result != Success)
		return result;
	}
d224 7
a230 7
	if (backPix)
	    *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[j].id;
	if (bordPix)
	    *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[j].id;
	if (cmap)
	    *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[j].id;
        result = (*SavedProcVector[X_ChangeWindowAttributes])(client);
d236 2
a237 2

int PanoramiXDestroyWindow(ClientPtr client)
d240 2
a241 1
    int         result, j;
d246 2
a247 2
    result = dixLookupResourceByType((pointer *)&win, stuff->id, XRT_WINDOW,
				     client, DixDestroyAccess);
d249 1
a249 1
	return result;
d252 4
a255 3
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_DestroyWindow])(client);
        if(result != Success) break;
d259 2
a260 2
	our resource for us on the last pass through the loop above */
 
d264 2
a265 2

int PanoramiXDestroySubwindows(ClientPtr client)
d268 2
a269 1
    int         result, j;
d274 2
a275 2
    result = dixLookupResourceByType((pointer *)&win, stuff->id, XRT_WINDOW,
				     client, DixDestroyAccess);
d277 1
a277 1
	return result;
d280 4
a283 3
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_DestroySubwindows])(client);
        if(result != Success) break;
d287 1
a287 1
	our resources for us on the last pass through the loop above */
d292 2
a293 2

int PanoramiXChangeSaveSet(ClientPtr client)
d296 2
a297 1
    int         result, j;
d302 2
a303 2
    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixReadAccess);
d305 1
a305 1
	return result;
d308 4
a311 3
	stuff->window = win->info[j].id;
	result = (*SavedProcVector[X_ChangeSaveSet])(client);
        if(result != Success) break;
d317 2
a318 2

int PanoramiXReparentWindow(ClientPtr client)
d321 4
a324 3
    int         result, j;
    int		x, y;
    Bool	parentIsRoot;
d329 2
a330 2
    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
d332 1
a332 1
	return result;
d334 2
a335 2
    result = dixLookupResourceByType((pointer *)&parent, stuff->parent,
				     XRT_WINDOW, client, DixWriteAccess);
d337 1
a337 1
	return result;
d341 2
a342 2
    parentIsRoot = (stuff->parent == screenInfo.screens[0]->root->drawable.id) ||
                   (stuff->parent == screenInfo.screens[0]->screensaver.wid);
d344 9
a352 8
	stuff->window = win->info[j].id;
	stuff->parent = parent->info[j].id;
	if(parentIsRoot) {
	    stuff->x = x - screenInfo.screens[j]->x;
	    stuff->y = y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ReparentWindow])(client);
        if(result != Success) break;
d358 2
a359 2

int PanoramiXMapWindow(ClientPtr client)
d362 2
a363 1
    int         result, j;
d368 2
a369 2
    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
d371 1
a371 1
	return result;
d374 4
a377 3
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_MapWindow])(client);
        if(result != Success) break;
d383 2
a384 2

int PanoramiXMapSubwindows(ClientPtr client)
d387 2
a388 1
    int         result, j;
d393 2
a394 2
    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
d396 1
a396 1
	return result;
d399 4
a402 3
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_MapSubwindows])(client);
        if(result != Success) break;
d408 2
a409 2

int PanoramiXUnmapWindow(ClientPtr client)
d412 2
a413 1
    int         result, j;
d418 2
a419 2
    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
d421 1
a421 1
	return result;
d424 4
a427 3
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_UnmapWindow])(client);
        if(result != Success) break;
d433 2
a434 2

int PanoramiXUnmapSubwindows(ClientPtr client)
d437 2
a438 1
    int         result, j;
d443 2
a444 2
    result = dixLookupResourceByType((pointer *)&win, stuff->id,
				     XRT_WINDOW, client, DixReadAccess);
d446 1
a446 1
	return result;
d449 4
a452 3
	stuff->id = win->info[j].id;
	result = (*SavedProcVector[X_UnmapSubwindows])(client);
        if(result != Success) break;
d458 2
a459 2

int PanoramiXConfigureWindow(ClientPtr client)
d463 5
a467 4
    WindowPtr   pWin;
    int         result, j, len, sib_offset = 0, x = 0, y = 0;
    int		x_offset = -1;
    int		y_offset = -1;
d477 2
a478 2
    result = dixLookupResourceByType((pointer *)&pWin, stuff->window,
				     RT_WINDOW, client, DixWriteAccess);
d480 1
a480 1
	return result;
d482 2
a483 2
    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
d485 25
a509 24
	return result;

    if ((Mask)stuff->mask & CWSibling) {
	XID tmp;
	sib_offset = Ones((Mask)stuff->mask & (CWSibling - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + sib_offset))) {
	    result = dixLookupResourceByType((pointer *)&sib, tmp, XRT_WINDOW,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }

    if(pWin->parent && ((pWin->parent == screenInfo.screens[0]->root) ||
                        (pWin->parent->drawable.id == screenInfo.screens[0]->screensaver.wid)))
    {
	if ((Mask)stuff->mask & CWX) {
	    x_offset = 0;
	    x = *((CARD32 *)&stuff[1]);
	}
	if ((Mask)stuff->mask & CWY) {
	    y_offset = (x_offset == -1) ? 0 : 1;
	    y = *((CARD32 *) &stuff[1] + y_offset);
	}
d513 1
a513 1
	ConfigureNotify events */
d515 10
a524 9
	stuff->window = win->info[j].id;
	if(sib)
	    *((CARD32 *) &stuff[1] + sib_offset) = sib->info[j].id;
	if(x_offset >= 0)
	    *((CARD32 *) &stuff[1] + x_offset) = x - screenInfo.screens[j]->x;
	if(y_offset >= 0)
	    *((CARD32 *) &stuff[1] + y_offset) = y - screenInfo.screens[j]->y;
	result = (*SavedProcVector[X_ConfigureWindow])(client);
        if(result != Success) break;
d530 2
a531 2

int PanoramiXCirculateWindow(ClientPtr client)
d534 2
a535 1
    int         result, j;
d540 2
a541 2
    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
d543 1
a543 1
	return result;
d546 4
a549 3
	stuff->window = win->info[j].id;
	result = (*SavedProcVector[X_CirculateWindow])(client);
        if(result != Success) break;
d555 2
a556 2

int PanoramiXGetGeometry(ClientPtr client)
d558 1
a558 1
    xGetGeometryReply 	 rep;
d561 1
d567 1
a567 1
	return rc;
d579 8
a586 2
	xWindowRoot *root  = (xWindowRoot *)
				    (ConnectionInfo + connBlockScreenStart);
d588 9
a596 15
	rep.width = root->pixWidth;
	rep.height = root->pixHeight;
    } else 
    if (WindowDrawable(pDraw->type))
    {
        WindowPtr pWin = (WindowPtr)pDraw;
	rep.x = pWin->origin.x - wBorderWidth (pWin);
	rep.y = pWin->origin.y - wBorderWidth (pWin);
	if((pWin->parent == screenInfo.screens[0]->root) ||
           (pWin->parent->drawable.id == screenInfo.screens[0]->screensaver.wid))
        {
	   rep.x += screenInfo.screens[0]->x;
	   rep.y += screenInfo.screens[0]->y;
	}
	rep.borderWidth = pWin->borderWidth;
d603 2
a604 1
int PanoramiXTranslateCoords(ClientPtr client)
d607 1
d626 8
a633 8
    if((pWin == screenInfo.screens[0]->root) ||
       (pWin->drawable.id == screenInfo.screens[0]->screensaver.wid))
    { 
	x = stuff->srcX - screenInfo.screens[0]->x;
	y = stuff->srcY - screenInfo.screens[0]->y;
    } else {
	x = pWin->drawable.x + stuff->srcX;
	y = pWin->drawable.y + stuff->srcY;
d637 23
a659 23
	    BoxRec  box;
	    if ((pWin->mapped) &&
		(x >= pWin->drawable.x - wBorderWidth (pWin)) &&
		(x < pWin->drawable.x + (int)pWin->drawable.width +
		 wBorderWidth (pWin)) &&
		(y >= pWin->drawable.y - wBorderWidth (pWin)) &&
		(y < pWin->drawable.y + (int)pWin->drawable.height +
		 wBorderWidth (pWin))
		/* When a window is shaped, a further check
		 * is made to see if the point is inside
		 * borderSize
		 */
		&& (!wBoundingShape(pWin) ||
		    RegionContainsPoint(wBoundingShape(pWin),
					x - pWin->drawable.x, 
					y - pWin->drawable.y, &box))
		)
            {
		rep.child = pWin->drawable.id;
		pWin = (WindowPtr) NULL;
	    }
	    else
		pWin = pWin->nextSib;
d663 4
a666 5
    if((pDst == screenInfo.screens[0]->root) ||
       (pDst->drawable.id == screenInfo.screens[0]->screensaver.wid))
    {
	rep.dstX += screenInfo.screens[0]->x;
	rep.dstY += screenInfo.screens[0]->y;
d673 2
a674 1
int PanoramiXCreatePixmap(ClientPtr client)
d678 1
d684 2
a685 2
    result = dixLookupResourceByClass((pointer *)&refDraw, stuff->drawable,
				      XRC_DRAWABLE, client, DixReadAccess);
d687 1
a687 1
	return (result == BadValue) ? BadDrawable : result;
d689 2
a690 2
    if(!(newPix = malloc(sizeof(PanoramiXRes))))
	return BadAlloc;
d695 1
a695 1
   
d697 5
a701 4
	stuff->pid = newPix->info[j].id;
	stuff->drawable = refDraw->info[j].id;
	result = (*SavedProcVector[X_CreatePixmap])(client);
	if(result != Success) break;
d705 3
a707 3
	AddResource(newPix->info[0].id, XRT_PIXMAP, newPix);
    else 
	free(newPix);
d712 2
a713 2

int PanoramiXFreePixmap(ClientPtr client)
d716 2
a717 1
    int         result, j;
d724 2
a725 2
    result = dixLookupResourceByType((pointer *)&pix, stuff->id, XRT_PIXMAP,
				     client, DixDestroyAccess);
d727 1
a727 1
	return result;
d730 4
a733 3
	stuff->id = pix->info[j].id;
	result = (*SavedProcVector[X_FreePixmap])(client);
	if(result != Success) break;
d737 2
a738 2
	our resource for us on the last pass through the loop above */
 
d742 2
a743 2

int PanoramiXCreateGC(ClientPtr client)
d750 1
d757 1
a757 1
    
d763 2
a764 2
    result = dixLookupResourceByClass((pointer *)&refDraw, stuff->drawable,
				      XRC_DRAWABLE, client, DixReadAccess);
d766 1
a766 1
	return (result == BadValue) ? BadDrawable : result;
d768 26
a793 26
    if ((Mask)stuff->mask & GCTile) {
	tile_offset = Ones((Mask)stuff->mask & (GCTile - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + tile_offset))) {
	    result = dixLookupResourceByType((pointer *)&tile, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCStipple) {
	stip_offset = Ones((Mask)stuff->mask & (GCStipple - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + stip_offset))) {
	    result = dixLookupResourceByType((pointer *)&stip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCClipMask) {
	clip_offset = Ones((Mask)stuff->mask & (GCClipMask - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + clip_offset))) {
	    result = dixLookupResourceByType((pointer *)&clip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
d796 1
a796 1
    if(!(newGC = malloc(sizeof(PanoramiXRes))))
d805 9
a813 8
	if (tile)
	    *((CARD32 *) &stuff[1] + tile_offset) = tile->info[j].id;
	if (stip)
	    *((CARD32 *) &stuff[1] + stip_offset) = stip->info[j].id;
	if (clip)
	    *((CARD32 *) &stuff[1] + clip_offset) = clip->info[j].id;
        result = (*SavedProcVector[X_CreateGC])(client);
        if(result != Success) break;
d818 1
a818 1
    else 
d824 2
a825 1
int PanoramiXChangeGC(ClientPtr client)
d831 1
d838 1
a838 1
    
d843 2
a844 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d846 1
a846 1
	return result;
d848 26
a873 26
    if ((Mask)stuff->mask & GCTile) {
	tile_offset = Ones((Mask)stuff->mask & (GCTile - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + tile_offset))) {
	    result = dixLookupResourceByType((pointer *)&tile, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCStipple) {
	stip_offset = Ones((Mask)stuff->mask & (GCStipple - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + stip_offset))) {
	    result = dixLookupResourceByType((pointer *)&stip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
    }
    if ((Mask)stuff->mask & GCClipMask) {
	clip_offset = Ones((Mask)stuff->mask & (GCClipMask - 1));
	if ((tmp = *((CARD32 *) &stuff[1] + clip_offset))) {
	    result = dixLookupResourceByType((pointer *)&clip, tmp, XRT_PIXMAP,
					     client, DixReadAccess);
	    if (result != Success)
		return result;
	}
a875 1

d878 9
a886 8
	if (tile)
	    *((CARD32 *) &stuff[1] + tile_offset) = tile->info[j].id;
	if (stip)
	    *((CARD32 *) &stuff[1] + stip_offset) = stip->info[j].id;
	if (clip)
	    *((CARD32 *) &stuff[1] + clip_offset) = clip->info[j].id;
        result = (*SavedProcVector[X_ChangeGC])(client);
        if(result != Success) break;
d892 2
a893 2

int PanoramiXCopyGC(ClientPtr client)
d896 2
a897 1
    int         result, j;
d902 2
a903 2
    result = dixLookupResourceByType((pointer *)&srcGC, stuff->srcGC, XRT_GC,
				     client, DixReadAccess);
d905 1
a905 1
	return result;
d907 2
a908 2
    result = dixLookupResourceByType((pointer *)&dstGC, stuff->dstGC, XRT_GC,
				     client, DixWriteAccess);
d910 1
a910 1
	return result;
d913 5
a917 4
	stuff->srcGC = srcGC->info[j].id;
	stuff->dstGC = dstGC->info[j].id;
	result = (*SavedProcVector[X_CopyGC])(client);
        if(result != Success) break;
d923 2
a924 2

int PanoramiXSetDashes(ClientPtr client)
d927 2
a928 1
    int         result, j;
d933 2
a934 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixWriteAccess);
d936 1
a936 1
	return result;
d939 4
a942 3
	stuff->gc = gc->info[j].id;
	result = (*SavedProcVector[X_SetDashes])(client);
        if(result != Success) break;
d948 2
a949 2

int PanoramiXSetClipRectangles(ClientPtr client)
d952 2
a953 1
    int         result, j;
d958 2
a959 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixWriteAccess);
d961 1
a961 1
	return result;
d964 4
a967 3
	stuff->gc = gc->info[j].id;
	result = (*SavedProcVector[X_SetClipRectangles])(client);
        if(result != Success) break;
d973 2
a974 2

int PanoramiXFreeGC(ClientPtr client)
d977 2
a978 1
    int         result, j;
d983 2
a984 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->id, XRT_GC,
				     client, DixDestroyAccess);
d986 1
a986 1
	return result;
d989 4
a992 3
	stuff->id = gc->info[j].id;
	result = (*SavedProcVector[X_FreeGC])(client);
	if(result != Success) break;
d996 2
a997 2
	our resource for us on the last pass through the loop above */
 
d1001 2
a1002 2

int PanoramiXClearToBackground(ClientPtr client)
d1005 3
a1007 2
    int         result, j, x, y;
    Bool	isRoot;
d1012 2
a1013 2
    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixWriteAccess);
d1015 1
a1015 1
	return result;
d1021 8
a1028 7
	stuff->window = win->info[j].id;
	if(isRoot) {
	    stuff->x = x - screenInfo.screens[j]->x;
	    stuff->y = y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ClearArea])(client);
	if(result != Success) break;
d1030 1
a1030 1
 
a1033 1

d1044 2
a1045 1
int PanoramiXCopyArea(ClientPtr client)
d1047 6
a1052 5
    int			j, result, srcx, srcy, dstx, dsty;
    PanoramiXRes	*gc, *src, *dst;
    Bool		srcIsRoot = FALSE;
    Bool		dstIsRoot = FALSE;
    Bool		srcShared, dstShared;
d1057 2
a1058 2
    result = dixLookupResourceByClass((pointer *)&src, stuff->srcDrawable,
				      XRC_DRAWABLE, client, DixReadAccess);
d1060 1
a1060 1
	return (result == BadValue) ? BadDrawable : result;
d1064 2
a1065 2
    result = dixLookupResourceByClass((pointer *)&dst, stuff->dstDrawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1067 1
a1067 1
	return (result == BadValue) ? BadDrawable : result;
d1071 2
a1072 2
    if(dstShared && srcShared)
	return (* SavedProcVector[X_CopyArea])(client);
d1074 2
a1075 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d1077 1
a1077 1
	return result;
d1079 13
a1091 11
    if((dst->type == XRT_WINDOW) && dst->u.win.root)
	dstIsRoot = TRUE;
    if((src->type == XRT_WINDOW) && src->u.win.root)
	srcIsRoot = TRUE;

    srcx = stuff->srcX; srcy = stuff->srcY;
    dstx = stuff->dstX; dsty = stuff->dstY;
    if((dst->type == XRT_PIXMAP) && (src->type == XRT_WINDOW)) {
	DrawablePtr drawables[MAXSCREENS];
	DrawablePtr pDst;
	GCPtr pGC;
d1093 8
a1100 1
	int pitch, rc;
d1102 93
a1194 93
	FOR_NSCREENS(j) {
	    rc = dixLookupDrawable(drawables+j, src->info[j].id, client, 0,
				   DixGetAttrAccess);
	    if (rc != Success)
		return rc;
	}

	pitch = PixmapBytePad(stuff->width, drawables[0]->depth); 
	if(!(data = calloc(1, stuff->height * pitch)))
	    return BadAlloc;

	XineramaGetImageData(drawables, srcx, srcy, 
		stuff->width, stuff->height, ZPixmap, ~0, data, pitch, 
		srcIsRoot);

	FOR_NSCREENS_BACKWARD(j) {
	    stuff->gc = gc->info[j].id;
	    VALIDATE_DRAWABLE_AND_GC(dst->info[j].id, pDst, DixWriteAccess);
	    if(drawables[0]->depth != pDst->depth) {
		client->errorValue = stuff->dstDrawable;
		free(data);
		return BadMatch;
	    }

	    (*pGC->ops->PutImage) (pDst, pGC, pDst->depth, dstx, dsty, 
				   stuff->width, stuff->height, 
				   0, ZPixmap, data);

	    if(dstShared) break;
	}

	free(data);
    } else {
	DrawablePtr pDst = NULL, pSrc = NULL;
	GCPtr pGC = NULL;
	RegionRec totalReg;
	int rc;

	RegionNull(&totalReg);
	FOR_NSCREENS_BACKWARD(j) {
	    RegionPtr pRgn;
	    stuff->dstDrawable = dst->info[j].id;
	    stuff->srcDrawable = src->info[j].id;
	    stuff->gc          = gc->info[j].id;
 	    if (srcIsRoot) {	
		stuff->srcX = srcx - screenInfo.screens[j]->x;
		stuff->srcY = srcy - screenInfo.screens[j]->y;
	    }
 	    if (dstIsRoot) {	
		stuff->dstX = dstx - screenInfo.screens[j]->x;
		stuff->dstY = dsty - screenInfo.screens[j]->y;
	    }

	    VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pDst, DixWriteAccess);

	    if (stuff->dstDrawable != stuff->srcDrawable) {
		rc = dixLookupDrawable(&pSrc, stuff->srcDrawable, client, 0,
				       DixReadAccess);
		if (rc != Success)
		    return rc;

		if ((pDst->pScreen != pSrc->pScreen) || 
		    (pDst->depth != pSrc->depth)) {
			client->errorValue = stuff->dstDrawable;
			return BadMatch;
   		}
 	    } else
		pSrc = pDst;

	    pRgn = (*pGC->ops->CopyArea)(pSrc, pDst, pGC,
				stuff->srcX, stuff->srcY,
				stuff->width, stuff->height, 
				stuff->dstX, stuff->dstY);
	    if(pGC->graphicsExposures && pRgn) {
	       if(srcIsRoot) {
		   RegionTranslate(pRgn,
			    screenInfo.screens[j]->x, screenInfo.screens[j]->y);
	       }
	       RegionAppend(&totalReg, pRgn);
	       RegionDestroy(pRgn);
	    }

	    if(dstShared)
		break;
	}

	if(pGC->graphicsExposures) {
	    Bool overlap;
	    RegionValidate(&totalReg, &overlap);
	    (*pDst->pScreen->SendGraphicsExpose)(
		client, &totalReg, stuff->dstDrawable, X_CopyArea, 0);
	    RegionUninit(&totalReg);
	}
d1200 11
a1211 10
int PanoramiXCopyPlane(ClientPtr client)
{
    int			j, srcx, srcy, dstx, dsty, rc;
    PanoramiXRes	*gc, *src, *dst;
    Bool		srcIsRoot = FALSE;
    Bool		dstIsRoot = FALSE;
    Bool		srcShared, dstShared;
    DrawablePtr 	psrcDraw, pdstDraw = NULL;
    GCPtr 		pGC = NULL;
    RegionRec		totalReg;
d1216 2
a1217 2
    rc = dixLookupResourceByClass((pointer *)&src, stuff->srcDrawable,
				  XRC_DRAWABLE, client, DixReadAccess);
d1219 1
a1219 1
	return (rc == BadValue) ? BadDrawable : rc;
d1223 2
a1224 2
    rc = dixLookupResourceByClass((pointer *)&dst, stuff->dstDrawable,
				  XRC_DRAWABLE, client, DixWriteAccess);
d1226 1
a1226 1
	return (rc == BadValue) ? BadDrawable : rc;
d1230 2
a1231 2
    if(dstShared && srcShared)
	return (* SavedProcVector[X_CopyPlane])(client);
d1233 2
a1234 2
    rc = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				 client, DixReadAccess);
d1236 11
a1246 1
	return rc;
a1247 8
    if((dst->type == XRT_WINDOW) && dst->u.win.root)
	dstIsRoot = TRUE;
    if((src->type == XRT_WINDOW) && src->u.win.root)
	srcIsRoot = TRUE;

    srcx = stuff->srcX; srcy = stuff->srcY;
    dstx = stuff->dstX; dsty = stuff->dstY;
 
d1250 20
a1269 19
	RegionPtr pRgn;
	stuff->dstDrawable = dst->info[j].id;
	stuff->srcDrawable = src->info[j].id;
	stuff->gc          = gc->info[j].id;
	if (srcIsRoot) {	
	    stuff->srcX = srcx - screenInfo.screens[j]->x;
	    stuff->srcY = srcy - screenInfo.screens[j]->y;
	}
	if (dstIsRoot) {	
	    stuff->dstX = dstx - screenInfo.screens[j]->x;
	    stuff->dstY = dsty - screenInfo.screens[j]->y;
	}

	VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pdstDraw, DixWriteAccess);
	if (stuff->dstDrawable != stuff->srcDrawable) {
	    rc = dixLookupDrawable(&psrcDraw, stuff->srcDrawable, client, 0,
				   DixReadAccess);
	    if (rc != Success)
		return rc;
d1272 35
a1306 31
		client->errorValue = stuff->dstDrawable;
		return BadMatch;
	    }
	} else
	    psrcDraw = pdstDraw;

	if(stuff->bitPlane == 0 || (stuff->bitPlane & (stuff->bitPlane - 1)) ||
		(stuff->bitPlane > (1L << (psrcDraw->depth - 1)))) {
	    client->errorValue = stuff->bitPlane;
	    return BadValue;
	}

	pRgn = (*pGC->ops->CopyPlane)(psrcDraw, pdstDraw, pGC,
				stuff->srcX, stuff->srcY,
				stuff->width, stuff->height, 
				stuff->dstX, stuff->dstY, stuff->bitPlane);
	if(pGC->graphicsExposures && pRgn) {
	    RegionAppend(&totalReg, pRgn);
	    RegionDestroy(pRgn);
	}

	if(dstShared)
	    break;
    }

    if(pGC->graphicsExposures) {
	Bool overlap;
	RegionValidate(&totalReg, &overlap);
	(*pdstDraw->pScreen->SendGraphicsExpose)(
		client, &totalReg, stuff->dstDrawable, X_CopyPlane, 0);
	RegionUninit(&totalReg);
d1312 2
a1313 2

int PanoramiXPolyPoint(ClientPtr client)
d1316 4
a1319 3
    int 	  result, npoint, j;
    xPoint 	  *origPts;
    Bool	  isRoot;
d1324 2
a1325 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1327 1
a1327 1
	return (result == BadValue) ? BadDrawable : result;
d1329 2
a1330 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyPoint])(client);
d1332 2
a1333 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d1335 1
a1335 1
	return result;
d1342 1
a1342 1
        FOR_NSCREENS_FORWARD(j){
d1344 2
a1345 1
            if(j) memcpy(&stuff[1], origPts, npoint * sizeof(xPoint));
d1351 9
a1359 8
		if(x_off || y_off) {
                    xPoint *pnts = (xPoint*)&stuff[1];
		    int i = (stuff->coordMode==CoordModePrevious) ? 1 : npoint;

		    while(i--) {
			pnts->x -= x_off;
			pnts->y -= y_off;
			pnts++;
d1361 1
a1361 1
		}
d1364 5
a1368 4
	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyPoint])(client);
	    if(result != Success) break;
d1372 3
a1374 2
    } else
	return Success;
d1377 2
a1378 2

int PanoramiXPolyLine(ClientPtr client)
d1381 4
a1384 3
    int 	  result, npoint, j;
    xPoint 	  *origPts;
    Bool	  isRoot;
d1389 2
a1390 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1392 1
a1392 1
	return (result == BadValue) ? BadDrawable : result;
d1394 2
a1395 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyLine])(client);
d1397 2
a1398 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d1400 1
a1400 1
	return result;
d1404 1
a1404 1
    if (npoint > 0){
d1407 1
a1407 1
        FOR_NSCREENS_FORWARD(j){
d1409 2
a1410 1
            if(j) memcpy(&stuff[1], origPts, npoint * sizeof(xPoint));
d1416 11
a1426 10
		if(x_off || y_off) {
		    xPoint *pnts = (xPoint*)&stuff[1];
		    int i = (stuff->coordMode==CoordModePrevious) ? 1 : npoint;

		    while(i--) {
			pnts->x -= x_off;
			pnts->y -= y_off;
			pnts++;
		    }
		}
d1429 5
a1433 4
	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyLine])(client);
	    if(result != Success) break;
d1437 3
a1439 2
   } else
	return Success;
d1442 2
a1443 2

int PanoramiXPolySegment(ClientPtr client)
d1445 1
a1445 1
    int		  result, nsegs, i, j;
d1447 3
a1449 2
    xSegment 	  *origSegs;
    Bool	  isRoot;
d1454 2
a1455 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1457 1
a1457 1
	return (result == BadValue) ? BadDrawable : result;
d1459 2
a1460 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolySegment])(client);
d1462 2
a1463 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d1465 1
a1465 1
	return result;
d1470 2
a1471 1
    if(nsegs & 4) return BadLength;
d1474 1
a1474 1
	origSegs = malloc(nsegs * sizeof(xSegment));
d1476 1
a1476 1
        FOR_NSCREENS_FORWARD(j){
d1478 2
a1479 1
            if(j) memcpy(&stuff[1], origSegs, nsegs * sizeof(xSegment));
d1485 2
a1486 2
		if(x_off || y_off) {
		    xSegment *segs = (xSegment*)&stuff[1];
d1488 7
a1494 7
		    for (i = nsegs; i--; segs++) {
			segs->x1 -= x_off;
			segs->x2 -= x_off;
			segs->y1 -= y_off;
			segs->y2 -= y_off;
		    }
		}
d1497 11
a1507 9
	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolySegment])(client);
	    if(result != Success) break;
    	}
	free(origSegs);
	return result;
    } else
	  return Success;
d1510 2
a1511 2

int PanoramiXPolyRectangle(ClientPtr client)
d1513 1
a1513 1
    int 	  result, nrects, i, j;
d1515 3
a1517 2
    Bool	  isRoot;
    xRectangle 	  *origRecs;
d1522 2
a1523 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1525 1
a1525 1
	return (result == BadValue) ? BadDrawable : result;
d1527 2
a1528 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyRectangle])(client);
d1530 2
a1531 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d1533 1
a1533 1
	return result;
d1538 2
a1539 1
    if(nrects & 4) return BadLength;
d1541 5
a1545 4
    if (nrects > 0){
	origRecs = malloc(nrects * sizeof(xRectangle));
	memcpy((char *)origRecs,(char *)&stuff[1],nrects * sizeof(xRectangle));
        FOR_NSCREENS_FORWARD(j){
d1547 2
a1548 1
            if(j) memcpy(&stuff[1], origRecs, nrects * sizeof(xRectangle));
d1550 3
a1552 3
	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;
d1554 2
d1557 6
a1562 2
		if(x_off || y_off) {
	    	    xRectangle *rects = (xRectangle *) &stuff[1];
d1564 11
a1574 16
		    for (i = nrects; i--; rects++) {
			rects->x -= x_off;
			rects->y -= y_off;
		    }
		}
	    } 

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyRectangle])(client);
	    if(result != Success) break;
	}
	free(origRecs);
	return result;
    } else
       return Success;
d1577 2
a1578 2

int PanoramiXPolyArc(ClientPtr client)
d1580 1
a1580 1
    int 	  result, narcs, i, j;
d1582 3
a1584 2
    Bool	  isRoot;
    xArc	  *origArcs;
d1589 2
a1590 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1592 1
a1592 1
	return (result == BadValue) ? BadDrawable : result;
d1594 2
a1595 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyArc])(client);
d1597 2
a1598 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d1600 1
a1600 1
	return result;
d1605 2
a1606 1
    if(narcs % sizeof(xArc)) return BadLength;
d1608 20
a1627 19
    if (narcs > 0){
	origArcs = malloc(narcs * sizeof(xArc));
	memcpy((char *) origArcs, (char *) &stuff[1], narcs * sizeof(xArc));
        FOR_NSCREENS_FORWARD(j){

            if(j) memcpy(&stuff[1], origArcs, narcs * sizeof(xArc));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;
	
		if(x_off || y_off) {
		    xArc *arcs = (xArc *) &stuff[1];

		    for (i = narcs; i--; arcs++) {
			arcs->x -= x_off;
			arcs->y -= y_off;
		    }
		}
d1629 5
a1633 4
	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyArc])(client);
	    if(result != Success) break;
d1635 5
a1639 4
	free(origArcs);
	return result;
    } else
       return Success;
d1642 2
a1643 2

int PanoramiXFillPoly(ClientPtr client)
d1645 1
a1645 1
    int 	  result, count, j;
d1647 3
a1649 2
    Bool	  isRoot;
    DDXPointPtr	  locPts;
d1654 2
a1655 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1657 1
a1657 1
	return (result == BadValue) ? BadDrawable : result;
d1659 2
a1660 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_FillPoly])(client);
d1662 2
a1663 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d1665 1
a1665 1
	return result;
d1670 36
a1705 32
    if (count > 0){
	locPts = malloc(count * sizeof(DDXPointRec));
	memcpy((char *)locPts, (char *)&stuff[1], count * sizeof(DDXPointRec));
        FOR_NSCREENS_FORWARD(j){

	    if(j) memcpy(&stuff[1], locPts, count * sizeof(DDXPointRec));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    DDXPointPtr pnts = (DDXPointPtr)&stuff[1];
		    int i = (stuff->coordMode==CoordModePrevious) ? 1 : count;

		    while(i--) {
			pnts->x -= x_off;
			pnts->y -= y_off;
			pnts++;
		    }
		}
	    }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_FillPoly])(client);
	    if(result != Success) break;
	}
	free(locPts);
	return result;
    } else
       return Success;
d1708 2
a1709 2

int PanoramiXPolyFillRectangle(ClientPtr client)
d1711 1
a1711 1
    int 	  result, things, i, j;
d1713 3
a1715 2
    Bool	  isRoot;
    xRectangle	  *origRects;
d1720 2
a1721 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1723 1
a1723 1
	return (result == BadValue) ? BadDrawable : result;
d1725 2
a1726 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyFillRectangle])(client);
d1728 2
a1729 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d1731 1
a1731 1
	return result;
d1736 2
a1737 1
    if(things & 4) return BadLength;
d1739 34
a1772 30
    if (things > 0){
	origRects = malloc(things * sizeof(xRectangle));
	memcpy((char*)origRects,(char*)&stuff[1], things * sizeof(xRectangle));
        FOR_NSCREENS_FORWARD(j){

	    if(j) memcpy(&stuff[1], origRects, things * sizeof(xRectangle));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xRectangle *rects = (xRectangle *) &stuff[1];

		    for (i = things; i--; rects++) {
			rects->x -= x_off;
			rects->y -= y_off;
		    }
		}
	    }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyFillRectangle])(client);
	    if(result != Success) break;
	}
	free(origRects);
	return result;
    } else
       return Success;
d1775 2
a1776 2

int PanoramiXPolyFillArc(ClientPtr client)
d1779 4
a1782 3
    Bool	  isRoot;
    int 	  result, narcs, i, j;
    xArc	  *origArcs;
d1787 2
a1788 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1790 1
a1790 1
	return (result == BadValue) ? BadDrawable : result;
d1792 2
a1793 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyFillArc])(client);
d1795 2
a1796 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d1798 1
a1798 1
	return result;
d1803 2
a1804 1
    if (narcs % sizeof(xArc)) return BadLength;
d1807 32
a1838 29
	origArcs = malloc(narcs * sizeof(xArc));
	memcpy((char *) origArcs, (char *)&stuff[1], narcs * sizeof(xArc));
        FOR_NSCREENS_FORWARD(j){

	    if(j) memcpy(&stuff[1], origArcs, narcs * sizeof(xArc));

	    if (isRoot) {
		int x_off = screenInfo.screens[j]->x;
		int y_off = screenInfo.screens[j]->y;

		if(x_off || y_off) {
		    xArc *arcs = (xArc *) &stuff[1];

		    for (i = narcs; i--; arcs++) {
			arcs->x -= x_off;
			arcs->y -= y_off;
		    }
		}
	    }

	    stuff->drawable = draw->info[j].id;
	    stuff->gc = gc->info[j].id;
	    result = (* SavedProcVector[X_PolyFillArc])(client);
	    if(result != Success) break;
	}
	free(origArcs);
	return result;
    } else
       return Success;
d1841 2
a1842 2

int PanoramiXPutImage(ClientPtr client)
d1845 3
a1847 2
    Bool	  isRoot;
    int		  j, result, orig_x, orig_y;
d1852 2
a1853 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d1855 1
a1855 1
	return (result == BadValue) ? BadDrawable : result;
d1857 2
a1858 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PutImage])(client);
d1860 2
a1861 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d1863 1
a1863 1
	return result;
d1869 10
a1878 9
    FOR_NSCREENS_BACKWARD(j){
	if (isRoot) {
	  stuff->dstX = orig_x - screenInfo.screens[j]->x;
	  stuff->dstY = orig_y - screenInfo.screens[j]->y;
	}
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	result = (* SavedProcVector[X_PutImage])(client);
	if(result != Success) break;
d1883 13
a1895 13

int PanoramiXGetImage(ClientPtr client)
{
    DrawablePtr 	drawables[MAXSCREENS];
    DrawablePtr 	pDraw;
    PanoramiXRes	*draw;
    xGetImageReply	xgi;
    Bool		isRoot;
    char		*pBuf;
    int         	i, x, y, w, h, format, rc;
    Mask		plane = 0, planemask;
    int			linesDone, nlines, linesPerBuf;
    long		widthBytesLine, length;
d1902 1
a1902 1
	client->errorValue = stuff->format;
d1906 2
a1907 2
    rc = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				  XRC_DRAWABLE, client, DixWriteAccess);
d1909 1
a1909 1
	return (rc == BadValue) ? BadDrawable : rc;
d1911 2
a1912 2
    if(draw->type == XRT_PIXMAP)
	return (*SavedProcVector[X_GetImage])(client);
d1914 1
a1914 2
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixReadAccess);
d1916 1
a1916 1
	return rc;
d1918 2
a1919 2
    if(!((WindowPtr)pDraw)->realized)
	return BadMatch;
d1930 17
a1946 17
    if(isRoot) {
      if( /* check for being onscreen */
	x < 0 || x + w > PanoramiXPixWidth ||
	y < 0 || y + h > PanoramiXPixHeight )
	    return BadMatch;
    } else {
      if( /* check for being onscreen */
	screenInfo.screens[0]->x + pDraw->x + x < 0 ||
	screenInfo.screens[0]->x + pDraw->x + x + w > PanoramiXPixWidth ||
	screenInfo.screens[0]->y + pDraw->y + y < 0 ||
	screenInfo.screens[0]->y + pDraw->y + y + h > PanoramiXPixHeight ||
	 /* check for being inside of border */
       	x < - wBorderWidth((WindowPtr)pDraw) ||
	x + w > wBorderWidth((WindowPtr)pDraw) + (int)pDraw->width ||
	y < -wBorderWidth((WindowPtr)pDraw) ||
	y + h > wBorderWidth ((WindowPtr)pDraw) + (int)pDraw->height)
	    return BadMatch;
d1951 4
a1954 4
	rc = dixLookupDrawable(drawables+i, draw->info[i].id, client, 0,
			       DixGetAttrAccess);
	if (rc != Success)
	    return rc;
d1957 1
a1957 1
    xgi.visual = wVisual (((WindowPtr) pDraw));
d1961 3
a1963 3
    if(format == ZPixmap) {
	widthBytesLine = PixmapBytePad(w, pDraw->depth);
	length = widthBytesLine * h;
d1965 6
a1970 7

    } else {
	widthBytesLine = BitmapBytePad(w);
	plane = ((Mask)1) << (pDraw->depth - 1);
	/* only planes asked for */
	length = widthBytesLine * h *
		 Ones(planemask & (plane | (plane - 1)));
d1977 1
a1977 1
	linesPerBuf = 0;
d1979 1
a1979 1
	linesPerBuf = 1;
d1981 3
a1983 3
	linesPerBuf = XINERAMA_IMAGE_BUFSIZE / widthBytesLine;
	if (linesPerBuf > h)
	    linesPerBuf = h;
d1986 2
a1987 2
    if(!(pBuf = malloc(length)))
	return BadAlloc;
d1989 1
a1989 1
    WriteReplyToClient(client, sizeof (xGetImageReply), &xgi);
d1992 1
a1992 1
	/* nothing to do */
d1997 1
a1997 1
	    nlines = min(linesPerBuf, h - linesDone);
d1999 2
a2000 2
	    if(pDraw->depth == 1)
		memset(pBuf, 0, nlines * widthBytesLine);
d2002 3
a2004 2
	    XineramaGetImageData(drawables, x, y + linesDone, w, nlines,
			format, planemask, pBuf, widthBytesLine, isRoot);
d2006 2
a2007 4
		(void)WriteToClient(client,
				    (int)(nlines * widthBytesLine),
				    pBuf);
	    linesDone += nlines;
d2009 2
a2010 1
    } else { /* XYPixmap */
d2012 13
a2024 14
	    if (planemask & plane) {
	        linesDone = 0;
	        while (h - linesDone > 0) {
		    nlines = min(linesPerBuf, h - linesDone);

		    memset(pBuf, 0, nlines * widthBytesLine);

		    XineramaGetImageData(drawables, x, y + linesDone, w, 
					nlines, format, plane, pBuf,
					widthBytesLine, isRoot);

		    (void)WriteToClient(client,
				    (int)(nlines * widthBytesLine),
				    pBuf);
d2026 2
a2027 2
		    linesDone += nlines;
		}
d2029 1
a2029 1
	}
a2034 1

d2039 1
a2039 1
int 
d2043 4
a2046 3
    Bool	  isRoot;
    int 	  result, j;
    int	 	  orig_x, orig_y;
d2051 2
a2052 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d2054 1
a2054 1
	return (result == BadValue) ? BadDrawable : result;
d2056 2
a2057 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyText8])(client);
d2059 2
a2060 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d2062 1
a2062 1
	return result;
d2068 10
a2077 9
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_PolyText8])(client);
	if(result != Success) break;
d2082 1
a2082 1
int 
d2086 4
a2089 3
    Bool	  isRoot;
    int 	  result, j;
    int	 	  orig_x, orig_y;
d2094 2
a2095 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d2097 1
a2097 1
	return (result == BadValue) ? BadDrawable : result;
d2099 2
a2100 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_PolyText16])(client);
d2102 2
a2103 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d2105 1
a2105 1
	return result;
d2111 10
a2120 9
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_PolyText16])(client);
	if(result != Success) break;
d2125 2
a2126 2

int PanoramiXImageText8(ClientPtr client)
d2128 1
a2128 1
    int 	  result, j;
d2130 3
a2132 2
    Bool	  isRoot;
    int		  orig_x, orig_y;
d2137 2
a2138 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d2140 1
a2140 1
	return (result == BadValue) ? BadDrawable : result;
d2142 2
a2143 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_ImageText8])(client);
d2145 2
a2146 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d2148 1
a2148 1
	return result;
d2154 10
a2163 9
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ImageText8])(client);
	if(result != Success) break;
d2168 2
a2169 2

int PanoramiXImageText16(ClientPtr client)
d2171 1
a2171 1
    int 	  result, j;
d2173 3
a2175 2
    Bool	  isRoot;
    int		  orig_x, orig_y;
d2180 2
a2181 2
    result = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				      XRC_DRAWABLE, client, DixWriteAccess);
d2183 1
a2183 1
	return (result == BadValue) ? BadDrawable : result;
d2185 2
a2186 2
    if(IS_SHARED_PIXMAP(draw))
	return (*SavedProcVector[X_ImageText16])(client);
d2188 2
a2189 2
    result = dixLookupResourceByType((pointer *)&gc, stuff->gc, XRT_GC,
				     client, DixReadAccess);
d2191 1
a2191 1
	return result;
d2197 10
a2206 9
    FOR_NSCREENS_BACKWARD(j){
	stuff->drawable = draw->info[j].id;
	stuff->gc = gc->info[j].id;
	if (isRoot) {
	    stuff->x = orig_x - screenInfo.screens[j]->x;
	    stuff->y = orig_y - screenInfo.screens[j]->y;
	}
	result = (*SavedProcVector[X_ImageText16])(client);
	if(result != Success) break;
d2211 5
a2216 5

int PanoramiXCreateColormap(ClientPtr client)
{
    PanoramiXRes	*win, *newCmap;
    int 		result, j, orig_visual;
d2221 2
a2222 2
    result = dixLookupResourceByType((pointer *)&win, stuff->window,
				     XRT_WINDOW, client, DixReadAccess);
d2224 1
a2224 1
	return result;
d2226 1
a2226 1
    if(!(newCmap = malloc(sizeof(PanoramiXRes))))
d2233 7
a2239 6
    FOR_NSCREENS_BACKWARD(j){
	stuff->mid = newCmap->info[j].id;
	stuff->window = win->info[j].id;
	stuff->visual = PanoramiXTranslateVisualID(j, orig_visual);
	result = (* SavedProcVector[X_CreateColormap])(client);
	if(result != Success) break;
d2241 1
a2241 1
 
d2244 1
a2244 1
    else 
d2250 2
a2251 2

int PanoramiXFreeColormap(ClientPtr client)
d2254 2
a2255 1
    int          result, j;
d2262 2
a2263 2
    result = dixLookupResourceByType((pointer *)&cmap, stuff->id, XRT_COLORMAP,
				     client, DixDestroyAccess);
d2269 3
a2271 2
        result = (* SavedProcVector[X_FreeColormap])(client);
	if(result != Success) break;
d2275 1
a2275 1
	our resource for us on the last pass through the loop above */
a2279 1

d2284 2
a2285 1
    int          result, j;
d2292 3
a2294 3
    result = dixLookupResourceByType((pointer *)&cmap, stuff->srcCmap,
				     XRT_COLORMAP, client,
				     DixReadAccess | DixWriteAccess);
d2298 1
a2298 1
    if(!(newCmap = malloc(sizeof(PanoramiXRes))))
d2306 4
a2309 3
	stuff->mid = newCmap->info[j].id;
        result = (* SavedProcVector[X_CopyColormapAndFree])(client);
	if(result != Success) break;
d2314 1
a2314 1
    else 
d2320 2
a2321 2

int PanoramiXInstallColormap(ClientPtr client)
d2324 1
a2324 1
    int 	result, j;
d2331 2
a2332 2
    result = dixLookupResourceByType((pointer *)&cmap, stuff->id, XRT_COLORMAP,
				     client, DixReadAccess);
d2336 5
a2340 4
    FOR_NSCREENS_BACKWARD(j){
	stuff->id = cmap->info[j].id;
	result = (* SavedProcVector[X_InstallColormap])(client);
	if(result != Success) break;
d2345 2
a2346 2

int PanoramiXUninstallColormap(ClientPtr client)
d2349 1
a2349 1
    int 	result, j;
d2353 1
a2353 1
 
d2356 2
a2357 2
    result = dixLookupResourceByType((pointer *)&cmap, stuff->id, XRT_COLORMAP,
				     client, DixReadAccess);
d2362 4
a2365 3
	stuff->id = cmap->info[j].id;
	result = (* SavedProcVector[X_UninstallColormap])(client);
	if(result != Success) break;
d2370 2
a2371 2

int PanoramiXAllocColor(ClientPtr client)
d2373 1
a2373 1
    int           result, j;
d2375 1
d2382 2
a2383 2
    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
d2387 5
a2391 4
    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_AllocColor])(client);
	if(result != Success) break;
d2396 5
a2401 4
int PanoramiXAllocNamedColor(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
d2408 2
a2409 2
    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
d2413 1
a2413 1
    FOR_NSCREENS_BACKWARD(j){
d2415 3
a2417 2
        result = (* SavedProcVector[X_AllocNamedColor])(client);
	if(result != Success) break;
d2422 5
a2427 4
int PanoramiXAllocColorCells(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
d2434 2
a2435 2
    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
d2438 6
a2443 5
	
    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_AllocColorCells])(client);
	if(result != Success) break;
d2448 5
a2453 4
int PanoramiXAllocColorPlanes(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
d2460 2
a2461 2
    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
d2464 6
a2469 5
	
    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_AllocColorPlanes])(client);
	if(result != Success) break;
d2474 5
a2479 5

int PanoramiXFreeColors(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
d2486 2
a2487 2
    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
d2493 1
a2493 1
        result = (* SavedProcVector[X_FreeColors])(client);
d2498 5
a2503 4
int PanoramiXStoreColors(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
d2510 2
a2511 2
    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
d2515 5
a2519 4
    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_StoreColors])(client);
	if(result != Success) break;
d2524 5
a2529 4
int PanoramiXStoreNamedColor(ClientPtr client)
{
    int           result, j;
    PanoramiXRes  *cmap;
d2536 2
a2537 2
    result = dixLookupResourceByType((pointer *)&cmap, stuff->cmap,
				     XRT_COLORMAP, client, DixWriteAccess);
d2541 5
a2545 4
    FOR_NSCREENS_BACKWARD(j){
	stuff->cmap = cmap->info[j].id;
	result = (* SavedProcVector[X_StoreNamedColor])(client);
	if(result != Success) break;
@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d123 1
a123 3
    newWin->info[0].id = stuff->wid;
    for(j = 1; j < PanoramiXNumScreens; j++)
        newWin->info[j].id = FakeClientID(client->index);
d664 1
a664 3
    newPix->info[0].id = stuff->pid;
    for(j = 1; j < PanoramiXNumScreens; j++)
	newPix->info[j].id = FakeClientID(client->index);
d766 1
a766 3
    newGC->info[0].id = stuff->gc;
    for(j = 1; j < PanoramiXNumScreens; j++)
        newGC->info[j].id = FakeClientID(client->index);
d1331 1
a1331 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d1391 1
a1391 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d1454 1
a1454 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d1516 1
a1516 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d1576 1
a1576 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d1637 1
a1637 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d1698 1
a1698 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d1758 1
a1758 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d1821 1
a1821 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d1843 1
a1843 1
    for(i = 1; i < PanoramiXNumScreens; i++) {
d1959 1
a1959 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d2000 1
a2000 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d2041 1
a2041 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d2082 1
a2082 1
    isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
d2118 1
a2118 3
    newCmap->info[0].id = stuff->mid;
    for(j = 1; j < PanoramiXNumScreens; j++)
        newCmap->info[j].id = FakeClientID(client->index);
d2187 1
a2187 3
    newCmap->info[0].id = stuff->mid;
    for(j = 1; j < PanoramiXNumScreens; j++)
        newCmap->info[j].id = FakeClientID(client->index);
d2189 1
a2189 1
    FOR_NSCREENS_BACKWARD(j){
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d637 1
a637 1
       (pWin->drawable.id == screenInfo.screens[0]->screensaver.wid))
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a54 7
/* Various of the DIX function interfaces were not designed to allow
 * the client->errorValue to be set on BadValue and other errors.
 * Rather than changing interfaces and breaking untold code we introduce
 * a new global that dispatch can use.
 */
extern XID clientErrorValue;   /* XXX this is a kludge */

d77 1
a77 1
        return (result == BadValue) ? BadWindow : result;
d92 1
a92 1
		return (result == BadValue) ? BadPixmap : result;
d102 1
a102 1
		return (result == BadValue) ? BadPixmap : result;
d112 1
a112 1
		return (result == BadValue) ? BadColor : result;
d116 1
a116 1
    if(!(newWin = xalloc(sizeof(PanoramiXRes))))
d132 2
a133 2
    parentIsRoot = (stuff->parent == WindowTable[0]->drawable.id) ||
                   (stuff->parent == savedScreenInfo[0].wid);
d138 2
a139 2
	    stuff->x = orig_x - panoramiXdataPtr[j].x;
	    stuff->y = orig_y - panoramiXdataPtr[j].y;
d156 1
a156 1
        xfree(newWin);
d158 1
a158 1
    return (result);
d182 1
a182 1
        return (result == BadValue) ? BadWindow : result;
d195 1
a195 1
		return (result == BadValue) ? BadPixmap : result;
d205 1
a205 1
		return (result == BadValue) ? BadPixmap : result;
d215 1
a215 1
		return (result == BadValue) ? BadColor : result;
d230 1
a230 1
    return (result);
d245 1
a245 1
	return (result == BadValue) ? BadWindow : result;
d256 1
a256 1
    return (result);
d271 1
a271 1
	return (result == BadValue) ? BadWindow : result;
d282 1
a282 1
    return (result);
d297 1
a297 1
	return (result == BadValue) ? BadWindow : result;
d305 1
a305 1
    return (result);
d322 1
a322 1
	return (result == BadValue) ? BadWindow : result;
d327 1
a327 1
	return (result == BadValue) ? BadWindow : result;
d331 2
a332 2
    parentIsRoot = (stuff->parent == WindowTable[0]->drawable.id) ||
                   (stuff->parent == savedScreenInfo[0].wid);
d337 2
a338 2
	    stuff->x = x - panoramiXdataPtr[j].x;
	    stuff->y = y - panoramiXdataPtr[j].y;
d344 1
a344 1
    return (result);
d359 1
a359 1
	return (result == BadValue) ? BadWindow : result;
d367 1
a367 1
    return (result);
d382 1
a382 1
	return (result == BadValue) ? BadWindow : result;
d390 1
a390 1
    return (result);
d405 1
a405 1
	return (result == BadValue) ? BadWindow : result;
d413 1
a413 1
    return (result);
d428 1
a428 1
	return (result == BadValue) ? BadWindow : result;
d436 1
a436 1
    return (result);
d460 1
a460 1
	return (result == BadValue) ? BadWindow : result;
d465 1
a465 1
	return (result == BadValue) ? BadWindow : result;
d474 1
a474 1
		return (result == BadValue) ? BadWindow : result;
d478 2
a479 2
    if(pWin->parent && ((pWin->parent == WindowTable[0]) ||
                        (pWin->parent->drawable.id == savedScreenInfo[0].wid)))
d498 1
a498 1
	    *((CARD32 *) &stuff[1] + x_offset) = x - panoramiXdataPtr[j].x;
d500 1
a500 1
	    *((CARD32 *) &stuff[1] + y_offset) = y - panoramiXdataPtr[j].y;
d505 1
a505 1
    return (result);
d520 1
a520 1
	return (result == BadValue) ? BadWindow : result;
d528 1
a528 1
    return (result);
d547 1
a547 1
    rep.root = WindowTable[0]->drawable.id;
d560 1
a560 1
    if ((pDraw->type == UNDRAWABLE_WINDOW) || (pDraw->type == DRAWABLE_WINDOW))
d565 2
a566 2
	if((pWin->parent == WindowTable[0]) || 
           (pWin->parent->drawable.id == savedScreenInfo[0].wid))
d568 2
a569 2
	   rep.x += panoramiXdataPtr[0].x;
	   rep.y += panoramiXdataPtr[0].y;
d575 1
a575 1
    return (client->noClientException);
d599 2
a600 2
    if((pWin == WindowTable[0]) || 
       (pWin->drawable.id == savedScreenInfo[0].wid))
d602 2
a603 2
	x = stuff->srcX - panoramiXdataPtr[0].x;
	y = stuff->srcY - panoramiXdataPtr[0].y;
d623 1
a623 2
		    POINT_IN_REGION(pWin->drawable.pScreen, 
					wBoundingShape(pWin), 
d636 2
a637 2
    if((pDst == WindowTable[0]) || 
       (pDst->drawable.id == savedScreenInfo[0].wid))
d639 2
a640 2
	rep.dstX += panoramiXdataPtr[0].x;
	rep.dstY += panoramiXdataPtr[0].y;
d644 1
a644 1
    return(client->noClientException);
d661 1
a661 1
    if(!(newPix = xalloc(sizeof(PanoramiXRes))))
d680 1
a680 1
	xfree(newPix);
d682 1
a682 1
    return (result);
d699 1
a699 1
	return (result == BadValue) ? BadPixmap : result;
d710 1
a710 1
    return (result);
d744 1
a744 1
		return (result == BadValue) ? BadPixmap : result;
d753 1
a753 1
		return (result == BadValue) ? BadPixmap : result;
d762 1
a762 1
		return (result == BadValue) ? BadPixmap : result;
d766 1
a766 1
    if(!(newGC = xalloc(sizeof(PanoramiXRes))))
d790 1
a790 1
        xfree(newGC);
d792 1
a792 1
    return (result);
d815 1
a815 1
	return (result == BadValue) ? BadGC : result;
d823 1
a823 1
		return (result == BadValue) ? BadPixmap : result;
d832 1
a832 1
		return (result == BadValue) ? BadPixmap : result;
d841 1
a841 1
		return (result == BadValue) ? BadPixmap : result;
d858 1
a858 1
    return (result);
d873 1
a873 1
	return (result == BadValue) ? BadGC : result;
d878 1
a878 1
	return (result == BadValue) ? BadGC : result;
d887 1
a887 1
    return (result);
d902 1
a902 1
	return (result == BadValue) ? BadGC : result;
d910 1
a910 1
    return (result);
d925 1
a925 1
	return (result == BadValue) ? BadGC : result;
d933 1
a933 1
    return (result);
d948 1
a948 1
	return (result == BadValue) ? BadGC : result;
d959 1
a959 1
    return (result);
d975 1
a975 1
	return (result == BadValue) ? BadWindow : result;
d983 2
a984 2
	    stuff->x = x - panoramiXdataPtr[j].x;
	    stuff->y = y - panoramiXdataPtr[j].y;
d990 1
a990 1
    return (result);
d1035 1
a1035 1
	return (result == BadValue) ? BadGC : result;
d1059 1
a1059 1
	if(!(data = xcalloc(1, stuff->height * pitch)))
d1071 2
a1072 2
		xfree(data);
		return (BadMatch);
d1082 1
a1082 3
	xfree(data);

	result = Success;
d1086 1
a1086 1
	RegionPtr pRgn[MAXSCREENS];
d1089 1
d1091 1
d1096 2
a1097 2
		stuff->srcX = srcx - panoramiXdataPtr[j].x;
		stuff->srcY = srcy - panoramiXdataPtr[j].y;
d1100 2
a1101 2
		stuff->dstX = dstx - panoramiXdataPtr[j].x;
		stuff->dstY = dsty - panoramiXdataPtr[j].y;
d1115 1
a1115 1
			return (BadMatch);
d1120 1
a1120 1
	    pRgn[j] = (*pGC->ops->CopyArea)(pSrc, pDst, pGC, 
d1124 8
d1133 1
a1133 2
	    if(dstShared) {
		while(j--) pRgn[j] = NULL;
a1134 1
	    }
a1137 2
	    ScreenPtr pScreen = pDst->pScreen;
	    RegionRec totalReg;
d1139 2
a1140 14

	    REGION_NULL(pScreen, &totalReg);
	    FOR_NSCREENS_BACKWARD(j) {
		if(pRgn[j]) {
		   if(srcIsRoot) {
		       REGION_TRANSLATE(pScreen, pRgn[j], 
				panoramiXdataPtr[j].x, panoramiXdataPtr[j].y);
		   }
		   REGION_APPEND(pScreen, &totalReg, pRgn[j]);
		   REGION_DESTROY(pScreen, pRgn[j]);
		}
	    }
	    REGION_VALIDATE(pScreen, &totalReg, &overlap);
	    (*pScreen->SendGraphicsExpose)(
d1142 1
a1142 1
	    REGION_UNINIT(pScreen, &totalReg);
a1143 2
	
	result = client->noClientException;
d1146 1
a1146 1
    return (result);
d1159 1
a1159 1
    RegionPtr 		pRgn[MAXSCREENS];
d1184 1
a1184 1
	return (rc == BadValue) ? BadGC : rc;
d1194 1
d1196 1
d1201 2
a1202 2
	    stuff->srcX = srcx - panoramiXdataPtr[j].x;
	    stuff->srcY = srcy - panoramiXdataPtr[j].y;
d1205 2
a1206 2
	    stuff->dstX = dstx - panoramiXdataPtr[j].x;
	    stuff->dstY = dsty - panoramiXdataPtr[j].y;
d1218 1
a1218 1
		return (BadMatch);
d1226 1
a1226 1
	    return(BadValue);
d1229 1
a1229 1
	pRgn[j] = (*pGC->ops->CopyPlane)(psrcDraw, pdstDraw, pGC, 
d1233 4
d1238 1
a1238 2
	if(dstShared) {
	    while(j--) pRgn[j] = NULL;
a1239 1
	}
a1242 2
	ScreenPtr pScreen = pdstDraw->pScreen;
	RegionRec totalReg;
d1244 2
a1245 10

	REGION_NULL(pScreen, &totalReg);
	FOR_NSCREENS_BACKWARD(j) {
	    if(pRgn[j]) {
		REGION_APPEND(pScreen, &totalReg, pRgn[j]);
		REGION_DESTROY(pScreen, pRgn[j]);
	    }
	}
	REGION_VALIDATE(pScreen, &totalReg, &overlap);
	(*pScreen->SendGraphicsExpose)(
d1247 1
a1247 1
	REGION_UNINIT(pScreen, &totalReg);
d1250 1
a1250 1
    return (client->noClientException);
d1275 1
a1275 1
	return (result == BadValue) ? BadGC : result;
d1280 1
a1280 1
        origPts = xalloc(npoint * sizeof(xPoint));
d1287 2
a1288 2
                int x_off = panoramiXdataPtr[j].x;
                int y_off = panoramiXdataPtr[j].y;
d1307 2
a1308 2
        xfree(origPts);
        return (result);
d1310 1
a1310 1
	return (client->noClientException);
d1335 1
a1335 1
	return (result == BadValue) ? BadGC : result;
d1340 1
a1340 1
        origPts = xalloc(npoint * sizeof(xPoint));
d1347 2
a1348 2
                int x_off = panoramiXdataPtr[j].x;
                int y_off = panoramiXdataPtr[j].y;
d1367 2
a1368 2
        xfree(origPts);
        return (result);
d1370 1
a1370 1
	return (client->noClientException);
d1395 1
a1395 1
	return (result == BadValue) ? BadGC : result;
d1403 1
a1403 1
	origSegs = xalloc(nsegs * sizeof(xSegment));
d1410 2
a1411 2
                int x_off = panoramiXdataPtr[j].x;
                int y_off = panoramiXdataPtr[j].y;
d1430 2
a1431 2
	xfree(origSegs);
	return (result);
d1433 1
a1433 1
	  return (client->noClientException);
d1458 1
a1458 1
	return (result == BadValue) ? BadGC : result;
d1466 1
a1466 1
	origRecs = xalloc(nrects * sizeof(xRectangle));
d1473 2
a1474 2
		int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;
d1492 2
a1493 2
	xfree(origRecs);
	return (result);
d1495 1
a1495 1
       return (client->noClientException);
d1520 1
a1520 1
	return (result == BadValue) ? BadGC : result;
d1528 1
a1528 1
	origArcs = xalloc(narcs * sizeof(xArc));
d1535 2
a1536 2
		int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;
d1552 2
a1553 2
	xfree(origArcs);
	return (result);
d1555 1
a1555 1
       return (client->noClientException);
d1580 1
a1580 1
	return (result == BadValue) ? BadGC : result;
d1586 1
a1586 1
	locPts = xalloc(count * sizeof(DDXPointRec));
d1593 2
a1594 2
		int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;
d1613 2
a1614 2
	xfree(locPts);
	return (result);
d1616 1
a1616 1
       return (client->noClientException);
d1641 1
a1641 1
	return (result == BadValue) ? BadGC : result;
d1649 1
a1649 1
	origRects = xalloc(things * sizeof(xRectangle));
d1656 2
a1657 2
		int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;
d1674 2
a1675 2
	xfree(origRects);
	return (result);
d1677 1
a1677 1
       return (client->noClientException);
d1702 1
a1702 1
	return (result == BadValue) ? BadGC : result;
d1707 1
a1707 1
    IF_RETURN((narcs % sizeof(xArc)), BadLength);
d1710 1
a1710 1
	origArcs = xalloc(narcs * sizeof(xArc));
d1717 2
a1718 2
		int x_off = panoramiXdataPtr[j].x;
		int y_off = panoramiXdataPtr[j].y;
d1735 2
a1736 2
	xfree(origArcs);
	return (result);
d1738 1
a1738 1
       return (client->noClientException);
d1762 1
a1762 1
	return (result == BadValue) ? BadGC : result;
d1770 2
a1771 2
    	  stuff->dstX = orig_x - panoramiXdataPtr[j].x;
	  stuff->dstY = orig_y - panoramiXdataPtr[j].y;
d1778 1
a1778 1
    return (result);
d1801 1
a1801 1
        return(BadValue);
d1818 1
a1818 1
	return(BadMatch);
d1833 1
a1833 1
	    return(BadMatch);
d1836 4
a1839 4
	panoramiXdataPtr[0].x + pDraw->x + x < 0 ||
	panoramiXdataPtr[0].x + pDraw->x + x + w > PanoramiXPixWidth ||
        panoramiXdataPtr[0].y + pDraw->y + y < 0 ||
	panoramiXdataPtr[0].y + pDraw->y + y + h > PanoramiXPixHeight ||
d1845 1
a1845 1
	    return(BadMatch);
d1886 2
a1887 2
    if(!(pBuf = xalloc(length)))
	return (BadAlloc);
d1900 1
a1900 1
		bzero(pBuf, nlines * widthBytesLine);
d1917 1
a1917 1
		    bzero(pBuf, nlines * widthBytesLine);
d1932 2
a1933 2
    xfree(pBuf);
    return (client->noClientException);
d1963 1
a1963 1
	return (result == BadValue) ? BadGC : result;
d1973 2
a1974 2
	    stuff->x = orig_x - panoramiXdataPtr[j].x;
	    stuff->y = orig_y - panoramiXdataPtr[j].y;
d1979 1
a1979 1
    return (result);
d2004 1
a2004 1
	return (result == BadValue) ? BadGC : result;
d2014 2
a2015 2
	    stuff->x = orig_x - panoramiXdataPtr[j].x;
	    stuff->y = orig_y - panoramiXdataPtr[j].y;
d2020 1
a2020 1
    return (result);
d2045 1
a2045 1
	return (result == BadValue) ? BadGC : result;
d2055 2
a2056 2
	    stuff->x = orig_x - panoramiXdataPtr[j].x;
	    stuff->y = orig_y - panoramiXdataPtr[j].y;
d2061 1
a2061 1
    return (result);
d2086 1
a2086 1
	return (result == BadValue) ? BadGC : result;
d2096 2
a2097 2
	    stuff->x = orig_x - panoramiXdataPtr[j].x;
	    stuff->y = orig_y - panoramiXdataPtr[j].y;
d2102 1
a2102 1
    return (result);
d2118 1
a2118 1
	return (result == BadValue) ? BadWindow : result;
d2120 1
a2120 1
    if(!(newCmap = xalloc(sizeof(PanoramiXRes))))
d2140 1
a2140 1
        xfree(newCmap);
d2142 1
a2142 1
    return (result);
d2159 1
a2159 1
        return (result == BadValue) ? BadColor : result;
d2170 1
a2170 1
    return (result);
d2189 1
a2189 1
        return (result == BadValue) ? BadColor : result;
d2191 1
a2191 1
    if(!(newCmap = xalloc(sizeof(PanoramiXRes))))
d2209 1
a2209 1
        xfree(newCmap);
d2211 1
a2211 1
    return (result);
d2228 1
a2228 1
        return (result == BadValue) ? BadColor : result;
d2235 1
a2235 1
    return (result);
d2252 1
a2252 1
        return (result == BadValue) ? BadColor : result;
d2259 1
a2259 1
    return (result);
d2276 1
a2276 1
        return (result == BadValue) ? BadColor : result;
d2283 1
a2283 1
    return (result);
d2300 1
a2300 1
        return (result == BadValue) ? BadColor : result;
d2307 1
a2307 1
    return (result);
d2324 1
a2324 1
        return (result == BadValue) ? BadColor : result;
d2331 1
a2331 1
    return (result);
d2348 1
a2348 1
        return (result == BadValue) ? BadColor : result;
d2355 1
a2355 1
    return (result);
d2373 1
a2373 1
        return (result == BadValue) ? BadColor : result;
d2379 1
a2379 1
    return (result);
d2396 1
a2396 1
        return (result == BadValue) ? BadColor : result;
d2403 1
a2403 1
    return (result);
d2420 1
a2420 1
        return (result == BadValue) ? BadColor : result;
d2427 1
a2427 1
    return (result);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a34 2
#define NEED_REPLIES
#define NEED_EVENTS
d70 1
a70 1
    int result = 0, len, j;
d77 1
a77 1
    len = client->req_len - (sizeof(xCreateWindowReq) >> 2);
d81 4
a84 3
    if (!(parent = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->parent, XRT_WINDOW, DixWriteAccess)))
        return BadWindow;
d96 4
a99 3
	   if(!(backPix = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_PIXMAP, DixReadAccess)))
	      return BadPixmap;
d106 4
a109 3
	   if(!(bordPix = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_PIXMAP, DixReadAccess)))
	      return BadPixmap;
d116 4
a119 3
	   if(!(cmap = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_COLORMAP, DixReadAccess)))
	      return BadColor;
d123 1
a123 1
    if(!(newWin = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d177 1
a177 1
    int result = 0, len, j;
d182 1
a182 1
    len = client->req_len - (sizeof(xChangeWindowAttributesReq) >> 2);
d186 4
a189 3
    if (!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->window, XRT_WINDOW, DixWriteAccess)))
        return BadWindow;
d199 4
a202 3
	   if(!(backPix = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_PIXMAP, DixReadAccess)))
	      return BadPixmap;
d209 4
a212 3
	   if(!(bordPix = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_PIXMAP, DixReadAccess)))
	      return BadPixmap;
d219 4
a222 3
	   if(!(cmap = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_COLORMAP, DixReadAccess)))
	      return BadColor;
d244 1
a244 1
    int         result = 0, j;
d249 4
a252 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->id, XRT_WINDOW, DixDestroyAccess)))
	return BadWindow;
d270 1
a270 1
    int         result = 0, j;
d275 4
a278 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->id, XRT_WINDOW, DixDestroyAccess)))
	return BadWindow;
d296 1
a296 1
    int         result = 0, j;
d301 4
a304 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->window, XRT_WINDOW, DixReadAccess)))
	return BadWindow;
d319 1
a319 1
    int         result = 0, j;
d326 9
a334 7
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->window, XRT_WINDOW, DixWriteAccess)))
	return BadWindow;

    if(!(parent = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->parent, XRT_WINDOW, DixWriteAccess)))
	return BadWindow;
d358 1
a358 1
    int         result = 0, j;
d363 4
a366 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->id, XRT_WINDOW, DixReadAccess)))
	return BadWindow;
d381 1
a381 1
    int         result = 0, j;
d386 4
a389 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->id, XRT_WINDOW, DixReadAccess)))
	return BadWindow;
d404 1
a404 1
    int         result = 0, j;
d409 4
a412 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->id, XRT_WINDOW, DixReadAccess)))
	return BadWindow;
d427 1
a427 1
    int         result = 0, j;
d432 4
a435 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->id, XRT_WINDOW, DixReadAccess)))
	return BadWindow;
d452 1
a452 1
    int         result = 0, j, len, sib_offset = 0, x = 0, y = 0;
d459 1
a459 1
    len = client->req_len - (sizeof(xConfigureWindowReq) >> 2);
d464 9
a472 7
    if (!(pWin = (WindowPtr)SecurityLookupIDByType(
		client, stuff->window, RT_WINDOW, DixWriteAccess)))
        return BadWindow;

    if (!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->window, XRT_WINDOW, DixWriteAccess)))
        return BadWindow;
d478 4
a481 3
	   if(!(sib = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_WINDOW, DixReadAccess)))
	      return BadWindow;
d519 1
a519 1
    int         result = 0, j;
d524 4
a527 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->window, XRT_WINDOW, DixWriteAccess)))
	return BadWindow;
d658 1
a658 1
    int result = 0, j;
d664 4
a667 3
    if(!(refDraw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixReadAccess)))
	return BadDrawable;
d669 1
a669 1
    if(!(newPix = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d697 1
a697 1
    int         result = 0, j;
d704 4
a707 3
    if(!(pix = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->id, XRT_PIXMAP, DixDestroyAccess)))
	return BadPixmap;
d731 1
a731 1
    int result = 0, len, j;
d737 1
a737 1
    len = client->req_len - (sizeof(xCreateGCReq) >> 2);
d741 4
a744 3
    if (!(refDraw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixReadAccess)))
        return BadDrawable;
d749 4
a752 3
	   if(!(tile = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_PIXMAP, DixReadAccess)))
	      return BadPixmap;
d758 4
a761 3
	   if(!(stip = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_PIXMAP, DixReadAccess)))
	      return BadPixmap;
d767 4
a770 3
	   if(!(clip = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_PIXMAP, DixReadAccess)))
	      return BadPixmap;
d774 1
a774 1
    if(!(newGC = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d811 1
a811 1
    int result = 0, len, j;
d816 1
a816 1
    len = client->req_len - (sizeof(xChangeGCReq) >> 2);
d820 4
a823 3
    if (!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
        return BadGC;
d828 4
a831 3
	   if(!(tile = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_PIXMAP, DixReadAccess)))
	      return BadPixmap;
d837 4
a840 3
	   if(!(stip = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_PIXMAP, DixReadAccess)))
	      return BadPixmap;
d846 4
a849 3
	   if(!(clip = (PanoramiXRes*) SecurityLookupIDByType(
		client, tmp, XRT_PIXMAP, DixReadAccess)))
	      return BadPixmap;
d873 1
a873 1
    int         result = 0, j;
d878 9
a886 7
    if(!(srcGC = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->srcGC, XRT_GC, DixReadAccess)))
	return BadGC;

    if(!(dstGC = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->dstGC, XRT_GC, DixWriteAccess)))
	return BadGC;
d902 1
a902 1
    int         result = 0, j;
d907 4
a910 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixWriteAccess)))
	return BadGC;
d925 1
a925 1
    int         result = 0, j;
d930 4
a933 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixWriteAccess)))
	return BadGC;
d948 1
a948 1
    int         result = 0, j;
d953 4
a956 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->id, XRT_GC, DixDestroyAccess)))
	return BadGC;
d974 1
a974 1
    int         result = 0, j, x, y;
d980 4
a983 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->window, XRT_WINDOW, DixWriteAccess)))
	return BadWindow;
d1014 1
a1014 1
    int			j, result = 0, srcx, srcy, dstx, dsty;
d1023 4
a1026 3
    if(!(src = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->srcDrawable, XRC_DRAWABLE, DixReadAccess)))
	return BadDrawable;
d1030 4
a1033 3
    if(!(dst = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->dstDrawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;
d1040 4
a1043 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;
d1182 4
a1185 3
    if(!(src = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->srcDrawable, XRC_DRAWABLE, DixReadAccess)))
	return BadDrawable;    
d1189 4
a1192 3
    if(!(dst = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->dstDrawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;
d1199 4
a1202 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;
d1281 1
a1281 1
    int 	  result = 0, npoint, j;
d1288 4
a1291 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;
d1296 4
a1299 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d1302 1
a1302 1
    npoint = ((client->req_len << 2) - sizeof(xPolyPointReq)) >> 2;
d1304 1
a1304 1
        origPts = (xPoint *) xalloc(npoint * sizeof(xPoint));
d1341 1
a1341 1
    int 	  result = 0, npoint, j;
d1348 4
a1351 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d1356 4
a1359 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d1362 1
a1362 1
    npoint = ((client->req_len << 2) - sizeof(xPolyLineReq)) >> 2;
d1364 1
a1364 1
        origPts = (xPoint *) xalloc(npoint * sizeof(xPoint));
d1400 1
a1400 1
    int		  result = 0, nsegs, i, j;
d1408 4
a1411 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d1416 4
a1419 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d1427 1
a1427 1
	origSegs = (xSegment *) xalloc(nsegs * sizeof(xSegment));
d1463 1
a1463 1
    int 	  result = 0, nrects, i, j;
d1471 4
a1474 4

    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;
d1479 4
a1482 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d1490 1
a1490 1
	origRecs = (xRectangle *) xalloc(nrects * sizeof(xRectangle));
d1525 1
a1525 1
    int 	  result = 0, narcs, i, j;
d1533 4
a1536 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d1541 4
a1544 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d1552 1
a1552 1
	origArcs = (xArc *) xalloc(narcs * sizeof(xArc));
d1585 1
a1585 1
    int 	  result = 0, count, j;
d1593 4
a1596 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d1601 4
a1604 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d1608 1
a1608 1
    count = ((client->req_len << 2) - sizeof(xFillPolyReq)) >> 2;
d1610 1
a1610 1
	locPts = (DDXPointPtr) xalloc(count * sizeof(DDXPointRec));
d1646 1
a1646 1
    int 	  result = 0, things, i, j;
d1654 4
a1657 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d1662 4
a1665 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d1673 1
a1673 1
	origRects = (xRectangle *) xalloc(things * sizeof(xRectangle));
d1709 1
a1709 1
    int 	  result = 0, narcs, i, j;
d1715 4
a1718 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d1723 4
a1726 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d1734 1
a1734 1
	origArcs = (xArc *) xalloc(narcs * sizeof(xArc));
d1770 1
a1770 1
    int		  j, result = 0, orig_x, orig_y;
d1775 4
a1778 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d1783 4
a1786 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d1828 4
a1831 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;
d1898 1
a1898 1
    xgi.length = (length + 3) >> 2;
d1970 1
a1970 1
    int 	  result = 0, j;
d1976 4
a1979 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d1984 4
a1987 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d2011 1
a2011 1
    int 	  result = 0, j;
d2017 4
a2020 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d2025 4
a2028 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d2050 1
a2050 1
    int 	  result = 0, j;
d2058 4
a2061 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d2066 4
a2069 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d2091 1
a2091 1
    int 	  result = 0, j;
d2099 4
a2102 3
    if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
	return BadDrawable;    
d2107 4
a2110 3
    if(!(gc = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->gc, XRT_GC, DixReadAccess)))
	return BadGC;    
d2134 1
a2134 1
    int 		result = 0, j, orig_visual;
d2139 4
a2142 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->window, XRT_WINDOW, DixReadAccess)))
	return BadWindow;    
d2144 1
a2144 1
    if(!(newCmap = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d2173 1
a2173 1
    int          result = 0, j;
d2180 4
a2183 3
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->id, XRT_COLORMAP, DixDestroyAccess)))
        return BadColor;
d2202 1
a2202 1
    int          result = 0, j;
d2209 5
a2213 4
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->srcCmap, XRT_COLORMAP, 
		DixReadAccess | DixWriteAccess)))
        return BadColor;
d2215 1
a2215 1
    if(!(newCmap = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes))))
d2242 1
a2242 1
    int 	result = 0, j;
d2249 4
a2252 3
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->id, XRT_COLORMAP, DixReadAccess)))
        return BadColor;
d2266 1
a2266 1
    int 	result = 0, j;
d2273 4
a2276 3
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->id, XRT_COLORMAP, DixReadAccess)))
        return BadColor;
d2289 1
a2289 1
    int           result = 0, j;
d2297 4
a2300 3
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
	return BadColor;
d2313 1
a2313 1
    int           result = 0, j;
d2321 4
a2324 3
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
        return BadColor;
d2337 1
a2337 1
    int           result = 0, j;
d2345 4
a2348 3
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
	return BadColor;
d2361 1
a2361 1
    int           result = 0, j;
d2369 4
a2372 3
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
	return BadColor;
d2386 1
a2386 1
    int           result = 0, j;
d2394 4
a2397 3
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
        return BadColor;
d2409 1
a2409 1
    int           result = 0, j;
d2417 4
a2420 3
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
        return BadColor;
d2433 1
a2433 1
    int           result = 0, j;
d2441 4
a2444 3
    if(!(cmap = (PanoramiXRes *)SecurityLookupIDByType(
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
        return BadColor;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a597 1
#ifdef SHAPE
a598 1
#endif
a605 1
#ifdef SHAPE
a614 1
#endif
@


1.1
log
@Initial revision
@
text
@a56 10
#if 0
extern void (* EventSwapVector[128]) (fsError *, fsError *);

extern void Swap32Write();
extern void SLHostsExtend();
extern void SQColorsExtend();
WriteSConnectionInfo();
extern void WriteSConnSetupPrefix();
#endif

d84 1
a84 1
		client, stuff->parent, XRT_WINDOW, SecurityWriteAccess)))
d98 1
a98 1
		client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d107 1
a107 1
		client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d116 1
a116 1
		client, tmp, XRT_COLORMAP, SecurityReadAccess)))
d153 1
a153 1
	    stuff->visual = PanoramiXVisualTable[(orig_visual*MAXSCREENS) + j];
d185 1
a185 1
		client, stuff->window, XRT_WINDOW, SecurityWriteAccess)))
d197 1
a197 1
		client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d206 1
a206 1
		client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d215 1
a215 1
		client, tmp, XRT_COLORMAP, SecurityReadAccess)))
d244 1
a244 1
		client, stuff->id, XRT_WINDOW, SecurityDestroyAccess)))
d269 1
a269 1
		client, stuff->id, XRT_WINDOW, SecurityDestroyAccess)))
d294 1
a294 1
		client, stuff->window, XRT_WINDOW, SecurityReadAccess)))
d318 1
a318 1
		client, stuff->window, XRT_WINDOW, SecurityWriteAccess)))
d322 1
a322 1
		client, stuff->parent, XRT_WINDOW, SecurityWriteAccess)))
d353 1
a353 1
		client, stuff->id, XRT_WINDOW, SecurityReadAccess)))
d375 1
a375 1
		client, stuff->id, XRT_WINDOW, SecurityReadAccess)))
d397 1
a397 1
		client, stuff->id, XRT_WINDOW, SecurityReadAccess)))
d419 1
a419 1
		client, stuff->id, XRT_WINDOW, SecurityReadAccess)))
d450 1
a450 1
		client, stuff->window, RT_WINDOW, SecurityWriteAccess)))
d454 1
a454 1
		client, stuff->window, XRT_WINDOW, SecurityWriteAccess)))
d462 1
a462 1
		client, tmp, XRT_WINDOW, SecurityReadAccess)))
d507 1
a507 1
		client, stuff->window, XRT_WINDOW, SecurityWriteAccess)))
d524 1
d528 4
a531 1
    VERIFY_GEOMETRABLE (pDraw, stuff->id, client);
d570 2
a571 2

    register WindowPtr pWin, pDst;
d575 6
a580 8
    pWin = (WindowPtr)SecurityLookupWindow(stuff->srcWid, client,
					   SecurityReadAccess);
    if (!pWin)
        return(BadWindow);
    pDst = (WindowPtr)SecurityLookupWindow(stuff->dstWid, client,
					   SecurityReadAccess);
    if (!pDst)
        return(BadWindow);
d650 1
a650 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityReadAccess)))
d689 1
a689 1
		client, stuff->id, XRT_PIXMAP, SecurityDestroyAccess)))
d725 1
a725 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityReadAccess)))
d732 1
a732 1
		client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d740 1
a740 1
		client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d748 1
a748 1
		client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d800 1
a800 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d807 1
a807 1
		client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d815 1
a815 1
		client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d823 1
a823 1
		client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d854 1
a854 1
		client, stuff->srcGC, XRT_GC, SecurityReadAccess)))
d858 1
a858 1
		client, stuff->dstGC, XRT_GC, SecurityWriteAccess)))
d881 1
a881 1
		client, stuff->gc, XRT_GC, SecurityWriteAccess)))
d903 1
a903 1
		client, stuff->gc, XRT_GC, SecurityWriteAccess)))
d925 1
a925 1
		client, stuff->id, XRT_GC, SecurityDestroyAccess)))
d951 1
a951 1
		client, stuff->window, XRT_WINDOW, SecurityWriteAccess)))
d993 1
a993 1
		client, stuff->srcDrawable, XRC_DRAWABLE, SecurityReadAccess)))
d999 1
a999 1
		client, stuff->dstDrawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1008 1
a1008 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1023 1
a1023 1
	int pitch;
d1025 6
a1030 2
	FOR_NSCREENS(j)
	    VERIFY_DRAWABLE(drawables[j], src->info[j].id, client);
d1042 1
a1042 2
	    VALIDATE_DRAWABLE_AND_GC(dst->info[j].id, pDst, pGC, client);

d1063 1
d1078 2
a1079 1
	    VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pDst, pGC, client); 
d1081 5
a1085 2
		SECURITY_VERIFY_DRAWABLE(pSrc, stuff->srcDrawable, client,
                                 SecurityReadAccess);
d1136 1
a1136 1
    int			j, srcx, srcy, dstx, dsty;
d1149 1
a1149 1
		client, stuff->srcDrawable, XRC_DRAWABLE, SecurityReadAccess)))
d1155 1
a1155 1
		client, stuff->dstDrawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1164 1
a1164 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1188 1
a1188 1
	VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pdstDraw, pGC, client);
d1190 5
a1194 2
	    SECURITY_VERIFY_DRAWABLE(psrcDraw, stuff->srcDrawable, client,
                                 SecurityReadAccess);
d1252 1
a1252 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1259 1
a1259 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1265 1
a1265 1
        origPts = (xPoint *) ALLOCATE_LOCAL(npoint * sizeof(xPoint));
d1292 1
a1292 1
        DEALLOCATE_LOCAL(origPts);
d1310 1
a1310 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1317 1
a1317 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1323 1
a1323 1
        origPts = (xPoint *) ALLOCATE_LOCAL(npoint * sizeof(xPoint));
d1350 1
a1350 1
        DEALLOCATE_LOCAL(origPts);
d1368 1
a1368 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1375 1
a1375 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1384 1
a1384 1
	origSegs = (xSegment *) ALLOCATE_LOCAL(nsegs * sizeof(xSegment));
d1411 1
a1411 1
	DEALLOCATE_LOCAL(origSegs);
d1430 1
a1430 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1437 1
a1437 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1446 1
a1446 1
	origRecs = (xRectangle *) ALLOCATE_LOCAL(nrects * sizeof(xRectangle));
d1472 1
a1472 1
	DEALLOCATE_LOCAL(origRecs);
d1490 1
a1490 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1497 1
a1497 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1506 1
a1506 1
	origArcs = (xArc *) ALLOCATE_LOCAL(narcs * sizeof(xArc));
d1530 1
a1530 1
	DEALLOCATE_LOCAL(origArcs);
d1548 1
a1548 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1555 1
a1555 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1562 1
a1562 1
	locPts = (DDXPointPtr) ALLOCATE_LOCAL(count * sizeof(DDXPointRec));
d1589 1
a1589 1
	DEALLOCATE_LOCAL(locPts);
d1607 1
a1607 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1614 1
a1614 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1623 1
a1623 1
	origRects = (xRectangle *) ALLOCATE_LOCAL(things * sizeof(xRectangle));
d1648 1
a1648 1
	DEALLOCATE_LOCAL(origRects);
d1666 1
a1666 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1673 1
a1673 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1682 1
a1682 1
	origArcs = (xArc *) ALLOCATE_LOCAL(narcs * sizeof(xArc));
d1707 1
a1707 1
	DEALLOCATE_LOCAL(origArcs);
d1724 1
a1724 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1731 1
a1731 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1760 1
a1760 1
    int         	i, x, y, w, h, format;
d1775 1
a1775 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1781 4
a1784 1
    VERIFY_DRAWABLE(pDraw, stuff->drawable, client);
d1818 6
a1823 2
    for(i = 1; i < PanoramiXNumScreens; i++)
	VERIFY_DRAWABLE(drawables[i], draw->info[i].id, client);
d1922 1
a1922 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1929 1
a1929 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d1961 1
a1961 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1968 1
a1968 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d2000 1
a2000 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d2007 1
a2007 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d2039 1
a2039 1
		client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d2046 1
a2046 1
		client, stuff->gc, XRT_GC, SecurityReadAccess)))
d2077 1
a2077 1
		client, stuff->window, XRT_WINDOW, SecurityReadAccess)))
a2079 3
    if(!stuff->visual || (stuff->visual > 255)) 
	return BadValue;

d2092 1
a2092 1
	stuff->visual = PanoramiXVisualTable[(orig_visual * MAXSCREENS) + j];
d2117 1
a2117 1
                client, stuff->id, XRT_COLORMAP, SecurityDestroyAccess)))
d2146 1
a2146 1
		SecurityReadAccess | SecurityWriteAccess)))
d2184 1
a2184 1
                client, stuff->id, XRT_COLORMAP, SecurityReadAccess)))
d2207 1
a2207 1
                client, stuff->id, XRT_COLORMAP, SecurityReadAccess)))
d2230 1
a2230 1
                client, stuff->cmap, XRT_COLORMAP, SecurityWriteAccess)))
d2253 1
a2253 1
                client, stuff->cmap, XRT_COLORMAP, SecurityWriteAccess)))
d2276 1
a2276 1
                client, stuff->cmap, XRT_COLORMAP, SecurityWriteAccess)))
d2299 1
a2299 1
                client, stuff->cmap, XRT_COLORMAP, SecurityWriteAccess)))
d2323 1
a2323 1
                client, stuff->cmap, XRT_COLORMAP, SecurityWriteAccess)))
d2345 1
a2345 1
                client, stuff->cmap, XRT_COLORMAP, SecurityWriteAccess)))
d2368 1
a2368 1
                client, stuff->cmap, XRT_COLORMAP, SecurityWriteAccess)))
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d94 1
a94 1
		client, stuff->parent, XRT_WINDOW, DixWriteAccess)))
d108 1
a108 1
		client, tmp, XRT_PIXMAP, DixReadAccess)))
d117 1
a117 1
		client, tmp, XRT_PIXMAP, DixReadAccess)))
d126 1
a126 1
		client, tmp, XRT_COLORMAP, DixReadAccess)))
d195 1
a195 1
		client, stuff->window, XRT_WINDOW, DixWriteAccess)))
d207 1
a207 1
		client, tmp, XRT_PIXMAP, DixReadAccess)))
d216 1
a216 1
		client, tmp, XRT_PIXMAP, DixReadAccess)))
d225 1
a225 1
		client, tmp, XRT_COLORMAP, DixReadAccess)))
d254 1
a254 1
		client, stuff->id, XRT_WINDOW, DixDestroyAccess)))
d279 1
a279 1
		client, stuff->id, XRT_WINDOW, DixDestroyAccess)))
d304 1
a304 1
		client, stuff->window, XRT_WINDOW, DixReadAccess)))
d328 1
a328 1
		client, stuff->window, XRT_WINDOW, DixWriteAccess)))
d332 1
a332 1
		client, stuff->parent, XRT_WINDOW, DixWriteAccess)))
d363 1
a363 1
		client, stuff->id, XRT_WINDOW, DixReadAccess)))
d385 1
a385 1
		client, stuff->id, XRT_WINDOW, DixReadAccess)))
d407 1
a407 1
		client, stuff->id, XRT_WINDOW, DixReadAccess)))
d429 1
a429 1
		client, stuff->id, XRT_WINDOW, DixReadAccess)))
d460 1
a460 1
		client, stuff->window, RT_WINDOW, DixWriteAccess)))
d464 1
a464 1
		client, stuff->window, XRT_WINDOW, DixWriteAccess)))
d472 1
a472 1
		client, tmp, XRT_WINDOW, DixReadAccess)))
d517 1
a517 1
		client, stuff->window, XRT_WINDOW, DixWriteAccess)))
a533 1
    int rc;
d537 1
a537 4
    rc = dixLookupDrawable(&pDraw, stuff->id, client, M_ANY, DixUnknownAccess);
    if (rc != Success)
	return rc;

d576 2
a577 2
    int rc;
    WindowPtr pWin, pDst;
d581 8
a588 6
    rc = dixLookupWindow(&pWin, stuff->srcWid, client, DixReadAccess);
    if (rc != Success)
        return rc;
    rc = dixLookupWindow(&pDst, stuff->dstWid, client, DixReadAccess);
    if (rc != Success)
        return rc;
d658 1
a658 1
		client, stuff->drawable, XRC_DRAWABLE, DixReadAccess)))
d697 1
a697 1
		client, stuff->id, XRT_PIXMAP, DixDestroyAccess)))
d733 1
a733 1
		client, stuff->drawable, XRC_DRAWABLE, DixReadAccess)))
d740 1
a740 1
		client, tmp, XRT_PIXMAP, DixReadAccess)))
d748 1
a748 1
		client, tmp, XRT_PIXMAP, DixReadAccess)))
d756 1
a756 1
		client, tmp, XRT_PIXMAP, DixReadAccess)))
d808 1
a808 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d815 1
a815 1
		client, tmp, XRT_PIXMAP, DixReadAccess)))
d823 1
a823 1
		client, tmp, XRT_PIXMAP, DixReadAccess)))
d831 1
a831 1
		client, tmp, XRT_PIXMAP, DixReadAccess)))
d862 1
a862 1
		client, stuff->srcGC, XRT_GC, DixReadAccess)))
d866 1
a866 1
		client, stuff->dstGC, XRT_GC, DixWriteAccess)))
d889 1
a889 1
		client, stuff->gc, XRT_GC, DixWriteAccess)))
d911 1
a911 1
		client, stuff->gc, XRT_GC, DixWriteAccess)))
d933 1
a933 1
		client, stuff->id, XRT_GC, DixDestroyAccess)))
d959 1
a959 1
		client, stuff->window, XRT_WINDOW, DixWriteAccess)))
d1001 1
a1001 1
		client, stuff->srcDrawable, XRC_DRAWABLE, DixReadAccess)))
d1007 1
a1007 1
		client, stuff->dstDrawable, XRC_DRAWABLE, DixWriteAccess)))
d1016 1
a1016 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1031 1
a1031 1
	int pitch, rc;
d1033 2
a1034 6
	FOR_NSCREENS(j) {
	    rc = dixLookupDrawable(drawables+j, src->info[j].id, client, 0,
				   DixUnknownAccess);
	    if (rc != Success)
		return rc;
	}
a1067 1
	int rc;
d1084 2
a1085 5
		rc = dixLookupDrawable(&pSrc, stuff->srcDrawable, client, 0,
				       DixReadAccess);
		if (rc != Success)
		    return rc;

d1136 1
a1136 1
    int			j, srcx, srcy, dstx, dsty, rc;
d1149 1
a1149 1
		client, stuff->srcDrawable, XRC_DRAWABLE, DixReadAccess)))
d1155 1
a1155 1
		client, stuff->dstDrawable, XRC_DRAWABLE, DixWriteAccess)))
d1164 1
a1164 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1190 2
a1191 5
	    rc = dixLookupDrawable(&psrcDraw, stuff->srcDrawable, client, 0,
				   DixReadAccess);
	    if (rc != Success)
		return rc;

d1249 1
a1249 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1256 1
a1256 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1307 1
a1307 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1314 1
a1314 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1365 1
a1365 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1372 1
a1372 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1427 1
a1427 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1434 1
a1434 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1487 1
a1487 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1494 1
a1494 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1545 1
a1545 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1552 1
a1552 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1604 1
a1604 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1611 1
a1611 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1663 1
a1663 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1670 1
a1670 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1721 1
a1721 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1728 1
a1728 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1757 1
a1757 1
    int         	i, x, y, w, h, format, rc;
d1772 1
a1772 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1778 1
a1778 4
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixUnknownAccess);
    if (rc != Success)
	return rc;
d1812 2
a1813 6
    for(i = 1; i < PanoramiXNumScreens; i++) {
	rc = dixLookupDrawable(drawables+i, draw->info[i].id, client, 0,
			       DixUnknownAccess);
	if (rc != Success)
	    return rc;
    }
d1912 1
a1912 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1919 1
a1919 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1951 1
a1951 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1958 1
a1958 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d1990 1
a1990 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1997 1
a1997 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d2029 1
a2029 1
		client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d2036 1
a2036 1
		client, stuff->gc, XRT_GC, DixReadAccess)))
d2067 1
a2067 1
		client, stuff->window, XRT_WINDOW, DixReadAccess)))
d2110 1
a2110 1
                client, stuff->id, XRT_COLORMAP, DixDestroyAccess)))
d2139 1
a2139 1
		DixReadAccess | DixWriteAccess)))
d2177 1
a2177 1
                client, stuff->id, XRT_COLORMAP, DixReadAccess)))
d2200 1
a2200 1
                client, stuff->id, XRT_COLORMAP, DixReadAccess)))
d2223 1
a2223 1
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
d2246 1
a2246 1
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
d2269 1
a2269 1
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
d2292 1
a2292 1
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
d2316 1
a2316 1
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
d2338 1
a2338 1
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
d2361 1
a2361 1
                client, stuff->cmap, XRT_COLORMAP, DixWriteAccess)))
@

