head	1.10;
access;
symbols
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.6
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.55;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.55;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.58;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "resource.h"
#include "scrnintstr.h"
#include "extnsionst.h"
#include "extinit.h"
#include "servermd.h"
#include <X11/Xfuncproto.h>
#include "xvdix.h"
#include <X11/extensions/XvMC.h>
#include <X11/extensions/Xvproto.h>
#include <X11/extensions/XvMCproto.h>
#include "xvmcext.h"
#include "protocol-versions.h"

#ifdef HAS_XVMCSHM
#include <sys/ipc.h>
#include <sys/types.h>
#include <sys/shm.h>
#endif                          /* HAS_XVMCSHM */

#define DR_CLIENT_DRIVER_NAME_SIZE 48
#define DR_BUSID_SIZE 48

static DevPrivateKeyRec XvMCScreenKeyRec;

#define XvMCScreenKey (&XvMCScreenKeyRec)
static Bool XvMCInUse;

int XvMCReqCode;
int XvMCEventBase;

static RESTYPE XvMCRTContext;
static RESTYPE XvMCRTSurface;
static RESTYPE XvMCRTSubpicture;

int (*XvMCScreenInitProc)(ScreenPtr, int, XvMCAdaptorPtr) = NULL;

typedef struct {
    int num_adaptors;
    XvMCAdaptorPtr adaptors;
    CloseScreenProcPtr CloseScreen;
    char clientDriverName[DR_CLIENT_DRIVER_NAME_SIZE];
    char busID[DR_BUSID_SIZE];
    int major;
    int minor;
    int patchLevel;
} XvMCScreenRec, *XvMCScreenPtr;

#define XVMC_GET_PRIVATE(pScreen) \
    (XvMCScreenPtr)(dixLookupPrivate(&(pScreen)->devPrivates, XvMCScreenKey))

static int
XvMCDestroyContextRes(void *data, XID id)
{
    XvMCContextPtr pContext = (XvMCContextPtr) data;

    pContext->refcnt--;

    if (!pContext->refcnt) {
        XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

        (*pScreenPriv->adaptors[pContext->adapt_num].DestroyContext) (pContext);
        free(pContext);
    }

    return Success;
}

static int
XvMCDestroySurfaceRes(void *data, XID id)
{
    XvMCSurfacePtr pSurface = (XvMCSurfacePtr) data;
    XvMCContextPtr pContext = pSurface->context;
    XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

    (*pScreenPriv->adaptors[pContext->adapt_num].DestroySurface) (pSurface);
    free(pSurface);

    XvMCDestroyContextRes((void *) pContext, pContext->context_id);

    return Success;
}

static int
XvMCDestroySubpictureRes(void *data, XID id)
{
    XvMCSubpicturePtr pSubpict = (XvMCSubpicturePtr) data;
    XvMCContextPtr pContext = pSubpict->context;
    XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

    (*pScreenPriv->adaptors[pContext->adapt_num].DestroySubpicture) (pSubpict);
    free(pSubpict);

    XvMCDestroyContextRes((void *) pContext, pContext->context_id);

    return Success;
}

static int
ProcXvMCQueryVersion(ClientPtr client)
{
    xvmcQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .major = SERVER_XVMC_MAJOR_VERSION,
        .minor = SERVER_XVMC_MINOR_VERSION
    };

    /* REQUEST(xvmcQueryVersionReq); */
    REQUEST_SIZE_MATCH(xvmcQueryVersionReq);

    WriteToClient(client, sizeof(xvmcQueryVersionReply), &rep);
    return Success;
}

static int
ProcXvMCListSurfaceTypes(ClientPtr client)
{
    XvPortPtr pPort;
    int i;
    XvMCScreenPtr pScreenPriv;
    xvmcListSurfaceTypesReply rep;
    xvmcSurfaceInfo info;
    XvMCAdaptorPtr adaptor = NULL;
    XvMCSurfaceInfoPtr surface;
    int num_surfaces;

    REQUEST(xvmcListSurfaceTypesReq);
    REQUEST_SIZE_MATCH(xvmcListSurfaceTypesReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    if (XvMCInUse) {            /* any adaptors at all */
        ScreenPtr pScreen = pPort->pAdaptor->pScreen;

        if ((pScreenPriv = XVMC_GET_PRIVATE(pScreen))) {        /* any this screen */
            for (i = 0; i < pScreenPriv->num_adaptors; i++) {
                if (pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
                    adaptor = &(pScreenPriv->adaptors[i]);
                    break;
                }
            }
        }
    }

    num_surfaces = (adaptor) ? adaptor->num_surfaces : 0;
    rep = (xvmcListSurfaceTypesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .num = num_surfaces,
        .length = bytes_to_int32(num_surfaces * sizeof(xvmcSurfaceInfo)),
    };

    WriteToClient(client, sizeof(xvmcListSurfaceTypesReply), &rep);

    for (i = 0; i < num_surfaces; i++) {
        surface = adaptor->surfaces[i];
        info.surface_type_id = surface->surface_type_id;
        info.chroma_format = surface->chroma_format;
        info.max_width = surface->max_width;
        info.max_height = surface->max_height;
        info.subpicture_max_width = surface->subpicture_max_width;
        info.subpicture_max_height = surface->subpicture_max_height;
        info.mc_type = surface->mc_type;
        info.flags = surface->flags;
        WriteToClient(client, sizeof(xvmcSurfaceInfo), &info);
    }

    return Success;
}

static int
ProcXvMCCreateContext(ClientPtr client)
{
    XvPortPtr pPort;
    CARD32 *data = NULL;
    int dwords = 0;
    int i, result, adapt_num = -1;
    ScreenPtr pScreen;
    XvMCContextPtr pContext;
    XvMCScreenPtr pScreenPriv;
    XvMCAdaptorPtr adaptor = NULL;
    XvMCSurfaceInfoPtr surface = NULL;
    xvmcCreateContextReply rep;

    REQUEST(xvmcCreateContextReq);
    REQUEST_SIZE_MATCH(xvmcCreateContextReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    pScreen = pPort->pAdaptor->pScreen;

    if (!XvMCInUse)             /* no XvMC adaptors */
        return BadMatch;

    if (!(pScreenPriv = XVMC_GET_PRIVATE(pScreen)))     /* none this screen */
        return BadMatch;

    for (i = 0; i < pScreenPriv->num_adaptors; i++) {
        if (pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
            adaptor = &(pScreenPriv->adaptors[i]);
            adapt_num = i;
            break;
        }
    }

    if (adapt_num < 0)          /* none this port */
        return BadMatch;

    for (i = 0; i < adaptor->num_surfaces; i++) {
        if (adaptor->surfaces[i]->surface_type_id == stuff->surface_type_id) {
            surface = adaptor->surfaces[i];
            break;
        }
    }

    /* adaptor doesn't support this suface_type_id */
    if (!surface)
        return BadMatch;

    if ((stuff->width > surface->max_width) ||
        (stuff->height > surface->max_height))
        return BadValue;

    if (!(pContext = malloc(sizeof(XvMCContextRec)))) {
        return BadAlloc;
    }

    pContext->pScreen = pScreen;
    pContext->adapt_num = adapt_num;
    pContext->context_id = stuff->context_id;
    pContext->surface_type_id = stuff->surface_type_id;
    pContext->width = stuff->width;
    pContext->height = stuff->height;
    pContext->flags = stuff->flags;
    pContext->refcnt = 1;

    result = (*adaptor->CreateContext) (pPort, pContext, &dwords, &data);

    if (result != Success) {
        free(pContext);
        return result;
    }
    if (!AddResource(pContext->context_id, XvMCRTContext, pContext)) {
        free(data);
        return BadAlloc;
    }

    rep = (xvmcCreateContextReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = dwords,
        .width_actual = pContext->width,
        .height_actual = pContext->height,
        .flags_return = pContext->flags
    };

    WriteToClient(client, sizeof(xvmcCreateContextReply), &rep);
    if (dwords)
        WriteToClient(client, dwords << 2, data);

    free(data);

    return Success;
}

static int
ProcXvMCDestroyContext(ClientPtr client)
{
    void *val;
    int rc;

    REQUEST(xvmcDestroyContextReq);
    REQUEST_SIZE_MATCH(xvmcDestroyContextReq);

    rc = dixLookupResourceByType(&val, stuff->context_id, XvMCRTContext,
                                 client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->context_id, RT_NONE);

    return Success;
}

static int
ProcXvMCCreateSurface(ClientPtr client)
{
    CARD32 *data = NULL;
    int dwords = 0;
    int result;
    XvMCContextPtr pContext;
    XvMCSurfacePtr pSurface;
    XvMCScreenPtr pScreenPriv;
    xvmcCreateSurfaceReply rep;

    REQUEST(xvmcCreateSurfaceReq);
    REQUEST_SIZE_MATCH(xvmcCreateSurfaceReq);

    result = dixLookupResourceByType((void **) &pContext, stuff->context_id,
                                     XvMCRTContext, client, DixUseAccess);
    if (result != Success)
        return result;

    pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

    if (!(pSurface = malloc(sizeof(XvMCSurfaceRec))))
        return BadAlloc;

    pSurface->surface_id = stuff->surface_id;
    pSurface->surface_type_id = pContext->surface_type_id;
    pSurface->context = pContext;

    result =
        (*pScreenPriv->adaptors[pContext->adapt_num].CreateSurface) (pSurface,
                                                                     &dwords,
                                                                     &data);

    if (result != Success) {
        free(pSurface);
        return result;
    }
    if (!AddResource(pSurface->surface_id, XvMCRTSurface, pSurface)) {
        free(data);
        return BadAlloc;
    }

    rep = (xvmcCreateSurfaceReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = dwords
    };

    WriteToClient(client, sizeof(xvmcCreateSurfaceReply), &rep);
    if (dwords)
        WriteToClient(client, dwords << 2, data);

    free(data);

    pContext->refcnt++;

    return Success;
}

static int
ProcXvMCDestroySurface(ClientPtr client)
{
    void *val;
    int rc;

    REQUEST(xvmcDestroySurfaceReq);
    REQUEST_SIZE_MATCH(xvmcDestroySurfaceReq);

    rc = dixLookupResourceByType(&val, stuff->surface_id, XvMCRTSurface,
                                 client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->surface_id, RT_NONE);

    return Success;
}

static int
ProcXvMCCreateSubpicture(ClientPtr client)
{
    Bool image_supported = FALSE;
    CARD32 *data = NULL;
    int i, result, dwords = 0;
    XvMCContextPtr pContext;
    XvMCSubpicturePtr pSubpicture;
    XvMCScreenPtr pScreenPriv;
    xvmcCreateSubpictureReply rep;
    XvMCAdaptorPtr adaptor;
    XvMCSurfaceInfoPtr surface = NULL;

    REQUEST(xvmcCreateSubpictureReq);
    REQUEST_SIZE_MATCH(xvmcCreateSubpictureReq);

    result = dixLookupResourceByType((void **) &pContext, stuff->context_id,
                                     XvMCRTContext, client, DixUseAccess);
    if (result != Success)
        return result;

    pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);

    adaptor = &(pScreenPriv->adaptors[pContext->adapt_num]);

    /* find which surface this context supports */
    for (i = 0; i < adaptor->num_surfaces; i++) {
        if (adaptor->surfaces[i]->surface_type_id == pContext->surface_type_id) {
            surface = adaptor->surfaces[i];
            break;
        }
    }

    if (!surface)
        return BadMatch;

    /* make sure this surface supports that xvimage format */
    if (!surface->compatible_subpictures)
        return BadMatch;

    for (i = 0; i < surface->compatible_subpictures->num_xvimages; i++) {
        if (surface->compatible_subpictures->xvimage_ids[i] ==
            stuff->xvimage_id) {
            image_supported = TRUE;
            break;
        }
    }

    if (!image_supported)
        return BadMatch;

    /* make sure the size is OK */
    if ((stuff->width > surface->subpicture_max_width) ||
        (stuff->height > surface->subpicture_max_height))
        return BadValue;

    if (!(pSubpicture = malloc(sizeof(XvMCSubpictureRec))))
        return BadAlloc;

    pSubpicture->subpicture_id = stuff->subpicture_id;
    pSubpicture->xvimage_id = stuff->xvimage_id;
    pSubpicture->width = stuff->width;
    pSubpicture->height = stuff->height;
    pSubpicture->num_palette_entries = 0;       /* overwritten by DDX */
    pSubpicture->entry_bytes = 0;       /* overwritten by DDX */
    pSubpicture->component_order[0] = 0;        /* overwritten by DDX */
    pSubpicture->component_order[1] = 0;
    pSubpicture->component_order[2] = 0;
    pSubpicture->component_order[3] = 0;
    pSubpicture->context = pContext;

    result =
        (*pScreenPriv->adaptors[pContext->adapt_num].
         CreateSubpicture) (pSubpicture, &dwords, &data);

    if (result != Success) {
        free(pSubpicture);
        return result;
    }
    if (!AddResource(pSubpicture->subpicture_id, XvMCRTSubpicture, pSubpicture)) {
        free(data);
        return BadAlloc;
    }

    rep = (xvmcCreateSubpictureReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = dwords,
        .width_actual = pSubpicture->width,
        .height_actual = pSubpicture->height,
        .num_palette_entries = pSubpicture->num_palette_entries,
        .entry_bytes = pSubpicture->entry_bytes,
        .component_order[0] = pSubpicture->component_order[0],
        .component_order[1] = pSubpicture->component_order[1],
        .component_order[2] = pSubpicture->component_order[2],
        .component_order[3] = pSubpicture->component_order[3]
    };

    WriteToClient(client, sizeof(xvmcCreateSubpictureReply), &rep);
    if (dwords)
        WriteToClient(client, dwords << 2, data);

    free(data);

    pContext->refcnt++;

    return Success;
}

static int
ProcXvMCDestroySubpicture(ClientPtr client)
{
    void *val;
    int rc;

    REQUEST(xvmcDestroySubpictureReq);
    REQUEST_SIZE_MATCH(xvmcDestroySubpictureReq);

    rc = dixLookupResourceByType(&val, stuff->subpicture_id, XvMCRTSubpicture,
                                 client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->subpicture_id, RT_NONE);

    return Success;
}

static int
ProcXvMCListSubpictureTypes(ClientPtr client)
{
    XvPortPtr pPort;
    xvmcListSubpictureTypesReply rep;
    XvMCScreenPtr pScreenPriv;
    ScreenPtr pScreen;
    XvMCAdaptorPtr adaptor = NULL;
    XvMCSurfaceInfoPtr surface = NULL;
    xvImageFormatInfo info;
    XvImagePtr pImage;
    int i, j;

    REQUEST(xvmcListSubpictureTypesReq);
    REQUEST_SIZE_MATCH(xvmcListSubpictureTypesReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    pScreen = pPort->pAdaptor->pScreen;

    if (!dixPrivateKeyRegistered(XvMCScreenKey))
        return BadMatch;        /* No XvMC adaptors */

    if (!(pScreenPriv = XVMC_GET_PRIVATE(pScreen)))
        return BadMatch;        /* None this screen */

    for (i = 0; i < pScreenPriv->num_adaptors; i++) {
        if (pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
            adaptor = &(pScreenPriv->adaptors[i]);
            break;
        }
    }

    if (!adaptor)
        return BadMatch;

    for (i = 0; i < adaptor->num_surfaces; i++) {
        if (adaptor->surfaces[i]->surface_type_id == stuff->surface_type_id) {
            surface = adaptor->surfaces[i];
            break;
        }
    }

    if (!surface)
        return BadMatch;

    rep = (xvmcListSubpictureTypesReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .num = 0
    };
    if (surface->compatible_subpictures)
        rep.num = surface->compatible_subpictures->num_xvimages;

    rep.length = bytes_to_int32(rep.num * sizeof(xvImageFormatInfo));

    WriteToClient(client, sizeof(xvmcListSubpictureTypesReply), &rep);

    for (i = 0; i < rep.num; i++) {
        pImage = NULL;
        for (j = 0; j < adaptor->num_subpictures; j++) {
            if (surface->compatible_subpictures->xvimage_ids[i] ==
                adaptor->subpictures[j]->id) {
                pImage = adaptor->subpictures[j];
                break;
            }
        }
        if (!pImage)
            return BadImplementation;

        info.id = pImage->id;
        info.type = pImage->type;
        info.byte_order = pImage->byte_order;
        memcpy(&info.guid, pImage->guid, 16);
        info.bpp = pImage->bits_per_pixel;
        info.num_planes = pImage->num_planes;
        info.depth = pImage->depth;
        info.red_mask = pImage->red_mask;
        info.green_mask = pImage->green_mask;
        info.blue_mask = pImage->blue_mask;
        info.format = pImage->format;
        info.y_sample_bits = pImage->y_sample_bits;
        info.u_sample_bits = pImage->u_sample_bits;
        info.v_sample_bits = pImage->v_sample_bits;
        info.horz_y_period = pImage->horz_y_period;
        info.horz_u_period = pImage->horz_u_period;
        info.horz_v_period = pImage->horz_v_period;
        info.vert_y_period = pImage->vert_y_period;
        info.vert_u_period = pImage->vert_u_period;
        info.vert_v_period = pImage->vert_v_period;
        memcpy(&info.comp_order, pImage->component_order, 32);
        info.scanline_order = pImage->scanline_order;
        WriteToClient(client, sizeof(xvImageFormatInfo), &info);
    }

    return Success;
}

static int
ProcXvMCGetDRInfo(ClientPtr client)
{
    xvmcGetDRInfoReply rep;
    XvPortPtr pPort;
    ScreenPtr pScreen;
    XvMCScreenPtr pScreenPriv;

#ifdef HAS_XVMCSHM
    volatile CARD32 *patternP;
#endif

    REQUEST(xvmcGetDRInfoReq);
    REQUEST_SIZE_MATCH(xvmcGetDRInfoReq);

    VALIDATE_XV_PORT(stuff->port, pPort, DixReadAccess);

    pScreen = pPort->pAdaptor->pScreen;
    pScreenPriv = XVMC_GET_PRIVATE(pScreen);

    rep = (xvmcGetDRInfoReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .major = pScreenPriv->major,
        .minor = pScreenPriv->minor,
        .patchLevel = pScreenPriv->patchLevel,
        .nameLen = bytes_to_int32(strlen(pScreenPriv->clientDriverName) + 1),
        .busIDLen = bytes_to_int32(strlen(pScreenPriv->busID) + 1),
        .isLocal = 1
    };

    rep.length = rep.nameLen + rep.busIDLen;
    rep.nameLen <<= 2;
    rep.busIDLen <<= 2;

    /*
     * Read back to the client what she has put in the shared memory
     * segment she prepared for us.
     */

#ifdef HAS_XVMCSHM
    patternP = (CARD32 *) shmat(stuff->shmKey, NULL, SHM_RDONLY);
    if (-1 != (long) patternP) {
        volatile CARD32 *patternC = patternP;
        int i;
        CARD32 magic = stuff->magic;

        rep.isLocal = 1;
        i = 1024 / sizeof(CARD32);

        while (i--) {
            if (*patternC++ != magic) {
                rep.isLocal = 0;
                break;
            }
            magic = ~magic;
        }
        shmdt((char *) patternP);
    }
#endif                          /* HAS_XVMCSHM */

    WriteToClient(client, sizeof(xvmcGetDRInfoReply), &rep);
    if (rep.length) {
        WriteToClient(client, rep.nameLen, pScreenPriv->clientDriverName);
        WriteToClient(client, rep.busIDLen, pScreenPriv->busID);
    }
    return Success;
}

int (*ProcXvMCVector[xvmcNumRequest]) (ClientPtr) = {
ProcXvMCQueryVersion,
        ProcXvMCListSurfaceTypes,
        ProcXvMCCreateContext,
        ProcXvMCDestroyContext,
        ProcXvMCCreateSurface,
        ProcXvMCDestroySurface,
        ProcXvMCCreateSubpicture,
        ProcXvMCDestroySubpicture,
        ProcXvMCListSubpictureTypes, ProcXvMCGetDRInfo};

static int
ProcXvMCDispatch(ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < xvmcNumRequest)
        return (*ProcXvMCVector[stuff->data]) (client);
    else
        return BadRequest;
}

static int
SProcXvMCDispatch(ClientPtr client)
{
    /* We only support local */
    return BadImplementation;
}

void
XvMCExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if (!dixPrivateKeyRegistered(XvMCScreenKey))
        return;

    if (!(XvMCRTContext = CreateNewResourceType(XvMCDestroyContextRes,
                                                "XvMCRTContext")))
        return;

    if (!(XvMCRTSurface = CreateNewResourceType(XvMCDestroySurfaceRes,
                                                "XvMCRTSurface")))
        return;

    if (!(XvMCRTSubpicture = CreateNewResourceType(XvMCDestroySubpictureRes,
                                                   "XvMCRTSubpicture")))
        return;

    extEntry = AddExtension(XvMCName, XvMCNumEvents, XvMCNumErrors,
                            ProcXvMCDispatch, SProcXvMCDispatch,
                            NULL, StandardMinorOpcode);

    if (!extEntry)
        return;

    XvMCReqCode = extEntry->base;
    XvMCEventBase = extEntry->eventBase;
    SetResourceTypeErrorValue(XvMCRTContext,
                              extEntry->errorBase + XvMCBadContext);
    SetResourceTypeErrorValue(XvMCRTSurface,
                              extEntry->errorBase + XvMCBadSurface);
    SetResourceTypeErrorValue(XvMCRTSubpicture,
                              extEntry->errorBase + XvMCBadSubpicture);
}

static Bool
XvMCCloseScreen(ScreenPtr pScreen)
{
    XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pScreen);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;

    free(pScreenPriv);

    return (*pScreen->CloseScreen) (pScreen);
}

int
XvMCScreenInit(ScreenPtr pScreen, int num, XvMCAdaptorPtr pAdapt)
{
    XvMCScreenPtr pScreenPriv;

    if (!dixRegisterPrivateKey(&XvMCScreenKeyRec, PRIVATE_SCREEN, 0))
        return BadAlloc;

    if (!(pScreenPriv = malloc(sizeof(XvMCScreenRec))))
        return BadAlloc;

    dixSetPrivate(&pScreen->devPrivates, XvMCScreenKey, pScreenPriv);

    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = XvMCCloseScreen;

    pScreenPriv->num_adaptors = num;
    pScreenPriv->adaptors = pAdapt;
    pScreenPriv->clientDriverName[0] = 0;
    pScreenPriv->busID[0] = 0;
    pScreenPriv->major = 0;
    pScreenPriv->minor = 0;
    pScreenPriv->patchLevel = 0;

    XvMCInUse = TRUE;

    return Success;
}

XvImagePtr
XvMCFindXvImage(XvPortPtr pPort, CARD32 id)
{
    XvImagePtr pImage = NULL;
    ScreenPtr pScreen = pPort->pAdaptor->pScreen;
    XvMCScreenPtr pScreenPriv;
    XvMCAdaptorPtr adaptor = NULL;
    int i;

    if (!dixPrivateKeyRegistered(XvMCScreenKey))
        return NULL;

    if (!(pScreenPriv = XVMC_GET_PRIVATE(pScreen)))
        return NULL;

    for (i = 0; i < pScreenPriv->num_adaptors; i++) {
        if (pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
            adaptor = &(pScreenPriv->adaptors[i]);
            break;
        }
    }

    if (!adaptor)
        return NULL;

    for (i = 0; i < adaptor->num_subpictures; i++) {
        if (adaptor->subpictures[i]->id == id) {
            pImage = adaptor->subpictures[i];
            break;
        }
    }

    return pImage;
}

int
xf86XvMCRegisterDRInfo(ScreenPtr pScreen, const char *name,
                       const char *busID, int major, int minor, int patchLevel)
{
    XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pScreen);

    strlcpy(pScreenPriv->clientDriverName, name, DR_CLIENT_DRIVER_NAME_SIZE);
    strlcpy(pScreenPriv->busID, busID, DR_BUSID_SIZE);
    pScreenPriv->major = major;
    pScreenPriv->minor = minor;
    pScreenPriv->patchLevel = patchLevel;
    return Success;
}
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d256 4
a272 1
    AddResource(pContext->context_id, XvMCRTContext, pContext);
d335 5
a348 1
    AddResource(pSurface->surface_id, XvMCRTSurface, pSurface);
d455 5
a476 1
    AddResource(pSubpicture->subpicture_id, XvMCRTSubpicture, pSubpicture);
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d64 1
a64 1
XvMCDestroyContextRes(pointer data, XID id)
d81 1
a81 1
XvMCDestroySurfaceRes(pointer data, XID id)
d90 1
a90 1
    XvMCDestroyContextRes((pointer) pContext, pContext->context_id);
d96 1
a96 1
XvMCDestroySubpictureRes(pointer data, XID id)
d105 1
a105 1
    XvMCDestroyContextRes((pointer) pContext, pContext->context_id);
d279 1
a279 1
    pointer val;
d309 1
a309 1
    result = dixLookupResourceByType((pointer *) &pContext, stuff->context_id,
d353 1
a353 1
    pointer val;
d385 1
a385 1
    result = dixLookupResourceByType((pointer *) &pContext, stuff->context_id,
d477 1
a477 1
    pointer val;
d803 2
a804 2
xf86XvMCRegisterDRInfo(ScreenPtr pScreen, char *name,
                       char *busID, int major, int minor, int patchLevel)
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d16 1
a39 2
unsigned long XvMCGeneration = 0;

d47 2
d113 7
a119 1
    xvmcQueryVersionReply rep;
d123 2
a124 6
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.major = SERVER_XVMC_MAJOR_VERSION;
    rep.minor = SERVER_XVMC_MINOR_VERSION;
    WriteToClient(client, sizeof(xvmcQueryVersionReply), (char *) &rep);
d138 1
d158 7
a164 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num = (adaptor) ? adaptor->num_surfaces : 0;
    rep.length = bytes_to_int32(rep.num * sizeof(xvmcSurfaceInfo));
d166 1
a166 1
    WriteToClient(client, sizeof(xvmcListSurfaceTypesReply), (char *) &rep);
d168 1
a168 1
    for (i = 0; i < rep.num; i++) {
d178 1
a178 1
        WriteToClient(client, sizeof(xvmcSurfaceInfo), (char *) &info);
d257 8
a264 6
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.width_actual = pContext->width;
    rep.height_actual = pContext->height;
    rep.flags_return = pContext->flags;
    rep.length = dwords;
d266 1
a266 1
    WriteToClient(client, sizeof(xvmcCreateContextReply), (char *) &rep);
d268 1
a268 1
        WriteToClient(client, dwords << 2, (char *) data);
d332 5
d338 1
a338 5
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = dwords;

    WriteToClient(client, sizeof(xvmcCreateSurfaceReply), (char *) &rep);
d340 1
a340 1
        WriteToClient(client, dwords << 2, (char *) data);
d448 13
d462 1
a462 13
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.width_actual = pSubpicture->width;
    rep.height_actual = pSubpicture->height;
    rep.num_palette_entries = pSubpicture->num_palette_entries;
    rep.entry_bytes = pSubpicture->entry_bytes;
    rep.component_order[0] = pSubpicture->component_order[0];
    rep.component_order[1] = pSubpicture->component_order[1];
    rep.component_order[2] = pSubpicture->component_order[2];
    rep.component_order[3] = pSubpicture->component_order[3];
    rep.length = dwords;

    WriteToClient(client, sizeof(xvmcCreateSubpictureReply), (char *) &rep);
d464 1
a464 1
        WriteToClient(client, dwords << 2, (char *) data);
d539 5
a543 3
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.num = 0;
d549 1
a549 1
    WriteToClient(client, sizeof(xvmcListSubpictureTypesReply), (char *) &rep);
d585 1
a585 1
        WriteToClient(client, sizeof(xvImageFormatInfo), (char *) &info);
d611 10
a620 7
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.major = pScreenPriv->major;
    rep.minor = pScreenPriv->minor;
    rep.patchLevel = pScreenPriv->patchLevel;
    rep.nameLen = bytes_to_int32(strlen(pScreenPriv->clientDriverName) + 1);
    rep.busIDLen = bytes_to_int32(strlen(pScreenPriv->busID) + 1);
a630 1
    rep.isLocal = 1;
d652 1
a652 1
    WriteToClient(client, sizeof(xvmcGetDRInfoReply), (char *) &rep);
d727 1
a727 1
XvMCCloseScreen(int i, ScreenPtr pScreen)
d735 1
a735 1
    return (*pScreen->CloseScreen) (i, pScreen);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d29 1
a29 3
#endif /* HAS_XVMCSHM */
   

d35 1
d49 9
a57 9
   int num_adaptors;
   XvMCAdaptorPtr adaptors;
   CloseScreenProcPtr	CloseScreen;
   char clientDriverName[DR_CLIENT_DRIVER_NAME_SIZE];
   char busID[DR_BUSID_SIZE];
   int major;
   int minor;
   int patchLevel;
} XvMCScreenRec, *XvMCScreenPtr; 
a61 1

d65 6
a70 9
   XvMCContextPtr pContext = (XvMCContextPtr)data;
   
   pContext->refcnt--;

   if(!pContext->refcnt) {
  	 XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);
	(*pScreenPriv->adaptors[pContext->adapt_num].DestroyContext)(pContext);
	free(pContext);
   }	   
d72 5
a76 1
   return Success;
d82 3
a84 3
   XvMCSurfacePtr pSurface = (XvMCSurfacePtr)data;
   XvMCContextPtr pContext = pSurface->context;
   XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);
d86 2
a87 2
   (*pScreenPriv->adaptors[pContext->adapt_num].DestroySurface)(pSurface); 
   free(pSurface);
d89 1
a89 1
   XvMCDestroyContextRes((pointer)pContext, pContext->context_id);
d91 1
a91 1
   return Success;
a93 1

d97 3
a99 3
   XvMCSubpicturePtr pSubpict = (XvMCSubpicturePtr)data;
   XvMCContextPtr pContext = pSubpict->context;
   XvMCScreenPtr pScreenPriv = XVMC_GET_PRIVATE(pContext->pScreen);
d101 2
a102 2
   (*pScreenPriv->adaptors[pContext->adapt_num].DestroySubpicture)(pSubpict); 
   free(pSubpict);
d104 1
a104 1
   XvMCDestroyContextRes((pointer)pContext, pContext->context_id);
d106 1
a106 1
   return Success;
d109 1
a109 1
static int 
d113 1
d121 1
a121 1
    WriteToClient(client, sizeof(xvmcQueryVersionReply), (char*)&rep);
d125 1
a125 2

static int 
d135 1
d141 11
a151 10
    if(XvMCInUse) { /* any adaptors at all */
       ScreenPtr pScreen = pPort->pAdaptor->pScreen;
       if((pScreenPriv = XVMC_GET_PRIVATE(pScreen))) {  /* any this screen */
          for(i = 0; i < pScreenPriv->num_adaptors; i++) {
             if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
               adaptor = &(pScreenPriv->adaptors[i]);
               break;
             }
          }
       }
a157 2
 
    WriteToClient(client, sizeof(xvmcListSurfaceTypesReply), (char*)&rep);
d159 13
a171 11
    for(i = 0; i < rep.num; i++) {
	surface = adaptor->surfaces[i];
	info.surface_type_id = surface->surface_type_id;
	info.chroma_format = surface->chroma_format;
	info.max_width = surface->max_width;
	info.max_height = surface->max_height;
	info.subpicture_max_width = surface->subpicture_max_width;
	info.subpicture_max_height = surface->subpicture_max_height;
	info.mc_type = surface->mc_type;
	info.flags = surface->flags;
	WriteToClient(client, sizeof(xvmcSurfaceInfo), (char*)&info);
d177 1
a177 1
static int 
d182 1
a182 1
    int dwords = 0; 
d190 1
d198 12
a209 12
    if(!XvMCInUse) /* no XvMC adaptors */
       return BadMatch;
 
    if(!(pScreenPriv = XVMC_GET_PRIVATE(pScreen))) /* none this screen */
       return BadMatch;

    for(i = 0; i < pScreenPriv->num_adaptors; i++) {
	if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
	    adaptor = &(pScreenPriv->adaptors[i]);
	    adapt_num = i; 
	    break;
	}
d212 2
a213 2
    if(adapt_num < 0) /* none this port */
	return BadMatch;	
d215 2
a216 2
    for(i = 0; i < adaptor->num_surfaces; i++) {
        if(adaptor->surfaces[i]->surface_type_id == stuff->surface_type_id) {
d223 2
a224 1
    if(!surface) return BadMatch;
d226 2
a227 3

    if((stuff->width > surface->max_width) ||
       (stuff->height > surface->max_height))
d230 2
a231 2
    if(!(pContext = malloc(sizeof(XvMCContextRec)))) {
	return BadAlloc;
a233 1

d243 1
a243 1
    result = (*adaptor->CreateContext)(pPort, pContext, &dwords, &data);
d245 3
a247 3
    if(result != Success) {
	free(pContext);
	return result;
d252 3
a254 3
    rep.width_actual = pContext->width; 
    rep.height_actual = pContext->height; 
    rep.flags_return = pContext->flags; 
d257 3
a259 3
    WriteToClient(client, sizeof(xvmcCreateContextReply), (char*)&rep);
    if(dwords)
      WriteToClient(client, dwords << 2, (char*)data); 
d267 1
a267 1
static int 
d272 1
d277 1
a277 1
				 client, DixDestroyAccess);
d279 1
a279 1
	return rc;
d281 1
a281 1
    FreeResource(stuff->context_id, RT_NONE); 
d286 1
a286 1
static int 
d296 1
d300 2
a301 2
    result = dixLookupResourceByType((pointer *)&pContext, stuff->context_id,
				     XvMCRTContext, client, DixUseAccess);
d307 1
a307 1
    if(!(pSurface = malloc(sizeof(XvMCSurfaceRec)))) 
d314 4
a317 2
    result = (*pScreenPriv->adaptors[pContext->adapt_num].CreateSurface)(
                pSurface, &dwords, &data);
d319 1
a319 1
    if(result != Success) {
d328 3
a330 3
    WriteToClient(client, sizeof(xvmcCreateSurfaceReply), (char*)&rep);
    if(dwords)
      WriteToClient(client, dwords << 2, (char*)data);
d340 1
a340 1
static int 
d345 1
d350 1
a350 1
				 client, DixDestroyAccess);
d359 1
a359 1
static int 
d371 1
d375 2
a376 2
    result = dixLookupResourceByType((pointer *)&pContext, stuff->context_id,
				     XvMCRTContext, client, DixUseAccess);
d382 1
a382 1
    adaptor = &(pScreenPriv->adaptors[pContext->adapt_num]); 
d385 6
a390 6
    for(i = 0; i < adaptor->num_surfaces; i++) {
	if(adaptor->surfaces[i]->surface_type_id == pContext->surface_type_id){
	   surface = adaptor->surfaces[i];
	   break;
	}
    } 
d392 2
a393 1
    if(!surface) return BadMatch;
d396 2
a397 1
    if(!surface->compatible_subpictures) return BadMatch;
d399 6
a404 5
    for(i = 0; i < surface->compatible_subpictures->num_xvimages; i++) {
      if(surface->compatible_subpictures->xvimage_ids[i] == stuff->xvimage_id) {
	   image_supported = TRUE;
	   break;
      }
d407 2
a408 1
    if(!image_supported) return BadMatch;
d411 3
a413 3
    if((stuff->width > surface->subpicture_max_width) ||
       (stuff->height > surface->subpicture_max_height))
	return BadValue;
d415 1
a415 1
    if(!(pSubpicture = malloc(sizeof(XvMCSubpictureRec))))
d422 3
a424 3
    pSubpicture->num_palette_entries = 0; /* overwritten by DDX */
    pSubpicture->entry_bytes = 0;         /* overwritten by DDX */
    pSubpicture->component_order[0] = 0;  /* overwritten by DDX */
a428 3
   
    result = (*pScreenPriv->adaptors[pContext->adapt_num].CreateSubpicture)(
                pSubpicture, &dwords, &data);
d430 5
a434 1
    if(result != Success) {
d451 3
a453 3
    WriteToClient(client, sizeof(xvmcCreateSubpictureReply), (char*)&rep);
    if(dwords)
      WriteToClient(client, dwords << 2, (char*)data);
d463 1
a463 1
static int 
d468 1
d473 1
a473 1
				 client, DixDestroyAccess);
a481 1

d494 1
d503 1
a503 1
        return BadMatch;   /* No XvMC adaptors */
d505 2
a506 2
    if(!(pScreenPriv = XVMC_GET_PRIVATE(pScreen)))
        return BadMatch;   /* None this screen */
d508 2
a509 2
    for(i = 0; i < pScreenPriv->num_adaptors; i++) {
        if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
d515 2
a516 1
    if(!adaptor) return BadMatch;
d518 2
a519 2
    for(i = 0; i < adaptor->num_surfaces; i++) {
        if(adaptor->surfaces[i]->surface_type_id == stuff->surface_type_id) {
d525 2
a526 1
    if(!surface) return BadMatch;
d531 2
a532 2
    if(surface->compatible_subpictures) 
	rep.num = surface->compatible_subpictures->num_xvimages;
d536 1
a536 1
    WriteToClient(client, sizeof(xvmcListSubpictureTypesReply), (char*)&rep);
d538 33
a570 33
    for(i = 0; i < rep.num; i++) {
	pImage = NULL;
	for(j = 0; j < adaptor->num_subpictures; j++) {
	    if(surface->compatible_subpictures->xvimage_ids[i] ==
	       adaptor->subpictures[j]->id)
	    {
		pImage = adaptor->subpictures[j];
	        break;
	    }
	}
	if(!pImage) return BadImplementation;

        info.id = pImage->id;      
	info.type = pImage->type;  
        info.byte_order = pImage->byte_order; 
        memcpy(&info.guid, pImage->guid, 16);      
        info.bpp = pImage->bits_per_pixel;         
        info.num_planes = pImage->num_planes;      
        info.depth = pImage->depth;        
        info.red_mask = pImage->red_mask;  
        info.green_mask = pImage->green_mask;      
        info.blue_mask = pImage->blue_mask;        
        info.format = pImage->format;      
        info.y_sample_bits = pImage->y_sample_bits;        
        info.u_sample_bits = pImage->u_sample_bits;        
        info.v_sample_bits = pImage->v_sample_bits;        
        info.horz_y_period = pImage->horz_y_period;        
        info.horz_u_period = pImage->horz_u_period;        
        info.horz_v_period = pImage->horz_v_period;        
        info.vert_y_period = pImage->vert_y_period;        
        info.vert_u_period = pImage->vert_u_period;        
        info.vert_v_period = pImage->vert_v_period;        
        memcpy(&info.comp_order, pImage->component_order, 32);     
d572 1
a572 1
	WriteToClient(client, sizeof(xvImageFormatInfo), (char*)&info);
d597 1
a597 1
    
d607 2
a608 2
    rep.nameLen <<=2;
    rep.busIDLen <<=2;
d617 2
a618 2
    patternP = (CARD32 *)shmat( stuff->shmKey, NULL, SHM_RDONLY );
    if ( -1 != (long) patternP) {
d620 22
a641 25
	int i;
	CARD32 magic = stuff->magic;
	
	rep.isLocal = 1;
	i = 1024 / sizeof(CARD32);
	
	while ( i-- ) {
	    if (*patternC++ != magic) {
		rep.isLocal = 0;
		break;
	    }
	    magic = ~magic;
	}
	shmdt( (char *)patternP ); 
    }
#endif /* HAS_XVMCSHM */
    
    WriteToClient(client, sizeof(xvmcGetDRInfoReply), 
		  (char*)&rep);
    if (rep.length) {      
	WriteToClient(client, rep.nameLen, 
		      pScreenPriv->clientDriverName);
	WriteToClient(client, rep.busIDLen, 
		      pScreenPriv->busID);
    }	
d645 10
a654 13

int (*ProcXvMCVector[xvmcNumRequest])(ClientPtr) = {
  ProcXvMCQueryVersion,
  ProcXvMCListSurfaceTypes,
  ProcXvMCCreateContext,
  ProcXvMCDestroyContext,
  ProcXvMCCreateSurface,
  ProcXvMCDestroySurface,
  ProcXvMCCreateSubpicture,
  ProcXvMCDestroySubpicture,
  ProcXvMCListSubpictureTypes,
  ProcXvMCGetDRInfo
};
d657 1
a657 1
ProcXvMCDispatch (ClientPtr client)
d660 3
a662 3
    
    if(stuff->data < xvmcNumRequest)
	return (*ProcXvMCVector[stuff->data])(client);
d664 1
a664 1
	return BadRequest;
d668 1
a668 1
SProcXvMCDispatch (ClientPtr client)
d677 1
a677 1
   ExtensionEntry *extEntry;
d679 2
a680 2
   if (!dixPrivateKeyRegistered(XvMCScreenKey))
	return;
d682 27
a708 23
   if(!(XvMCRTContext = CreateNewResourceType(XvMCDestroyContextRes,
					      "XvMCRTContext")))
	return;

   if(!(XvMCRTSurface = CreateNewResourceType(XvMCDestroySurfaceRes,
					      "XvMCRTSurface")))
	return;

   if(!(XvMCRTSubpicture = CreateNewResourceType(XvMCDestroySubpictureRes,
						 "XvMCRTSubpicture")))
	return;

   extEntry = AddExtension(XvMCName, XvMCNumEvents, XvMCNumErrors, 
                              ProcXvMCDispatch, SProcXvMCDispatch,
                              NULL, StandardMinorOpcode);

   if(!extEntry) return;
  
   XvMCReqCode = extEntry->base;
   XvMCEventBase = extEntry->eventBase;
   SetResourceTypeErrorValue(XvMCRTContext, extEntry->errorBase + XvMCBadContext);
   SetResourceTypeErrorValue(XvMCRTSurface, extEntry->errorBase + XvMCBadSurface);
   SetResourceTypeErrorValue(XvMCRTSubpicture, extEntry->errorBase + XvMCBadSubpicture);
d712 1
a712 1
XvMCCloseScreen (int i, ScreenPtr pScreen)
d720 1
a720 1
    return (*pScreen->CloseScreen)(i, pScreen);
a722 1

d726 1
a726 1
   XvMCScreenPtr pScreenPriv;
d728 2
a729 2
   if (!dixRegisterPrivateKey(&XvMCScreenKeyRec, PRIVATE_SCREEN, 0))
       return BadAlloc;
d731 2
a732 2
   if(!(pScreenPriv = malloc(sizeof(XvMCScreenRec))))
	return BadAlloc;
d734 1
a734 1
   dixSetPrivate(&pScreen->devPrivates, XvMCScreenKey, pScreenPriv);
d736 2
a737 2
   pScreenPriv->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = XvMCCloseScreen;
d739 7
a745 7
   pScreenPriv->num_adaptors = num;
   pScreenPriv->adaptors = pAdapt;
   pScreenPriv->clientDriverName[0] = 0;
   pScreenPriv->busID[0] = 0;
   pScreenPriv->major = 0;
   pScreenPriv->minor = 0;
   pScreenPriv->patchLevel = 0;
d747 1
a747 1
   XvMCInUse = TRUE;
d749 1
a749 1
   return Success;
d752 2
a753 1
XvImagePtr XvMCFindXvImage(XvPortPtr pPort, CARD32 id)
d764 1
a764 1
    if(!(pScreenPriv = XVMC_GET_PRIVATE(pScreen))) 
d767 5
a771 5
    for(i = 0; i < pScreenPriv->num_adaptors; i++) {
       if(pPort->pAdaptor == pScreenPriv->adaptors[i].xv_adaptor) {
          adaptor = &(pScreenPriv->adaptors[i]);
          break;
       }
d774 2
a775 1
    if(!adaptor) return NULL;
d777 2
a778 2
    for(i = 0; i < adaptor->num_subpictures; i++) {
        if(adaptor->subpictures[i]->id == id) {
d789 1
a789 2
		       char *busID, int major, int minor,
		       int patchLevel)
d792 3
a794 3
    strncpy(pScreenPriv->clientDriverName, name,
	    DR_CLIENT_DRIVER_NAME_SIZE);
    strncpy(pScreenPriv->busID, busID, DR_BUSID_SIZE);
a797 2
    pScreenPriv->clientDriverName[DR_CLIENT_DRIVER_NAME_SIZE-1] = 0;
    pScreenPriv->busID[DR_BUSID_SIZE-1] = 0;
a799 1

@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d45 3
a47 3
unsigned long XvMCRTContext;
unsigned long XvMCRTSurface;
unsigned long XvMCRTSubpicture;
d490 2
a491 2
    if(XvMCScreenKey == NULL) /* No XvMC adaptors */
        return BadMatch;
d671 2
a672 2
   if(XvMCScreenKey == NULL) /* nobody supports it */
	return; 
d749 2
a750 1
    if(XvMCScreenKey == NULL) return NULL;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d36 3
a38 2
static int XvMCScreenKeyIndex;
static DevPrivateKey XvMCScreenKey;
a43 1
int XvMCErrorBase;
d74 1
a74 1
	xfree(pContext);
d88 1
a88 1
   xfree(pSurface);
d104 1
a104 1
   xfree(pSubpict);
d142 1
a142 1
    if(XvMCScreenKey) { /* any adaptors at all */
d197 1
a197 1
    if(XvMCScreenKey == NULL) /* no XvMC adaptors */
d229 1
a229 1
    if(!(pContext = xalloc(sizeof(XvMCContextRec)))) {
d246 1
a246 1
	xfree(pContext);
d262 1
a262 2
    if(data)
	xfree(data);
d278 1
a278 1
	return (rc == BadValue) ? XvMCBadContext + XvMCErrorBase : rc;
d301 1
a301 1
        return (result == BadValue) ? XvMCBadContext + XvMCErrorBase : result;
d305 1
a305 1
    if(!(pSurface = xalloc(sizeof(XvMCSurfaceRec)))) 
d316 1
a316 1
        xfree(pSurface);
d329 1
a329 2
    if(data)
        xfree(data);
d347 1
a347 1
        return (rc == BadValue) ? XvMCBadSurface + XvMCErrorBase : rc;
d372 1
a372 1
        return (result == BadValue) ? XvMCBadContext + XvMCErrorBase : result;
d405 1
a405 1
    if(!(pSubpicture = xalloc(sizeof(XvMCSubpictureRec))))
d424 1
a424 1
        xfree(pSubpicture);
d445 1
a445 2
    if(data)
        xfree(data);
d463 1
a463 1
        return (rc == BadValue) ? XvMCBadSubpicture + XvMCErrorBase : rc;
d694 3
a696 1
   XvMCErrorBase = extEntry->errorBase;
d706 1
a706 1
    xfree(pScreenPriv);
d717 2
a718 1
   XvMCScreenKey = &XvMCScreenKeyIndex;
d720 1
a720 1
   if(!(pScreenPriv = xalloc(sizeof(XvMCScreenRec))))
d735 2
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a1 2
#define NEED_REPLIES
#define NEED_EVENTS
d23 1
d120 2
a121 2
    rep.major = XvMCVersion;
    rep.minor = XvMCRevision;
d140 1
a140 4
    if(!(pPort = LOOKUP_PORT(stuff->port, client))) {
        client->errorValue = stuff->port;
        return _XvBadPort;
    }
d157 1
a157 1
    rep.length = rep.num * sizeof(xvmcSurfaceInfo) >> 2;
d193 1
a193 4
    if(!(pPort = LOOKUP_PORT(stuff->port, client))) {
	client->errorValue = stuff->port;
	return _XvBadPort;
    }
d271 2
d276 4
a279 2
    if(!LookupIDByType(stuff->context_id, XvMCRTContext))
	return (XvMCBadContext + XvMCErrorBase);
d299 4
a302 2
    if(!(pContext = LookupIDByType(stuff->context_id, XvMCRTContext)))
        return (XvMCBadContext + XvMCErrorBase);
d341 2
d346 4
a349 2
    if(!LookupIDByType(stuff->surface_id, XvMCRTSurface))
        return (XvMCBadSurface + XvMCErrorBase);
d371 4
a374 2
    if(!(pContext = LookupIDByType(stuff->context_id, XvMCRTContext)))
        return (XvMCBadContext + XvMCErrorBase);
d458 2
d463 4
a466 2
    if(!LookupIDByType(stuff->subpicture_id, XvMCRTSubpicture))
        return (XvMCBadSubpicture + XvMCErrorBase);
d489 1
a489 4
    if(!(pPort = LOOKUP_PORT(stuff->port, client))) {
        client->errorValue = stuff->port;
        return _XvBadPort;
    }
d523 1
a523 1
    rep.length = rep.num * sizeof(xvImageFormatInfo) >> 2;
d582 1
a582 5

    if(!(pPort = LOOKUP_PORT(stuff->port, client))) {
	client->errorValue = stuff->port;
	return _XvBadPort;
    }
d592 2
a593 2
    rep.nameLen = (strlen(pScreenPriv->clientDriverName) + 4) >> 2;
    rep.busIDLen = (strlen(pScreenPriv->busID) + 4) >> 2;
d669 1
a669 1
void 
d677 2
a678 1
   if(!(XvMCRTContext = CreateNewResourceType(XvMCDestroyContextRes)))
d681 2
a682 1
   if(!(XvMCRTSurface = CreateNewResourceType(XvMCDestroySurfaceRes)))
d685 2
a686 1
   if(!(XvMCRTSubpicture = CreateNewResourceType(XvMCDestroySubpictureRes)))
d720 1
a720 1
   if(!(pScreenPriv = (XvMCScreenPtr)xalloc(sizeof(XvMCScreenRec))))
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a26 1
#ifndef Lynx
a29 4
#else
#include <ipc.h>
#include <shm.h>
#endif /* Lynx */
d37 2
a38 1
static DevPrivateKey XvMCScreenKey = NULL;
a111 6
static void
XvMCResetProc (ExtensionEntry *extEntry)
{
}


d606 2
a607 2
        register volatile CARD32 *patternC = patternP;
	register int i;
d686 1
a686 1
                              XvMCResetProc, StandardMinorOpcode);
d713 1
a713 1
   XvMCScreenKey = &XvMCScreenKey;
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
int XvMCScreenIndex = -1;
d66 1
a66 1
   (XvMCScreenPtr)((pScreen)->devPrivates[XvMCScreenIndex].ptr)
d156 1
a156 1
    if(XvMCScreenIndex >= 0) { /* any adaptors at all */
d214 1
a214 1
    if(XvMCScreenIndex < 0) /* no XvMC adaptors */
d497 1
a497 1
    if(XvMCScreenIndex < 0) /* No XvMC adaptors */
d678 1
a678 1
XvMCExtensionInit()
d682 1
a682 1
   if(XvMCScreenIndex < 0) /* nobody supports it */
d723 1
a723 6
   if(XvMCGeneration != serverGeneration) {
	if((XvMCScreenIndex = AllocateScreenPrivateIndex()) < 0)
	   return BadAlloc;

	XvMCGeneration = serverGeneration;
   }
d728 1
a728 1
   pScreen->devPrivates[XvMCScreenIndex].ptr = (pointer)pScreenPriv;
d752 1
a752 1
    if(XvMCScreenIndex < 0) return NULL;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d678 1
a678 1
XvMCExtensionInit(void)
@

