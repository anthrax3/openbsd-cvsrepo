head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.46;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.55;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.55;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.57;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/***********************************************************
Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
** File:
**
**   xvmain.c --- Xv server extension main device independent module.
**
** Author:
**
**   David Carver (Digital Workstation Engineering/Project Athena)
**
** Revisions:
**
**   04.09.91 Carver
**     - change: stop video always generates an event even when video
**       wasn't active
**
**   29.08.91 Carver
**     - change: unrealizing windows no longer preempts video
**
**   11.06.91 Carver
**     - changed SetPortControl to SetPortAttribute
**     - changed GetPortControl to GetPortAttribute
**     - changed QueryBestSize
**
**   28.05.91 Carver
**     - fixed Put and Get requests to not preempt operations to same drawable
**
**   15.05.91 Carver
**     - version 2.0 upgrade
**
**   19.03.91 Carver
**     - fixed Put and Get requests to honor grabbed ports.
**     - fixed Video requests to update di structure with new drawable, and
**       client after calling ddx.
**
**   24.01.91 Carver
**     - version 1.4 upgrade
**
** Notes:
**
**   Port structures reference client structures in a two different
**   ways: when grabs, or video is active.  Each reference is encoded
**   as fake client resources and thus when the client is goes away so
**   does the reference (it is zeroed).  No other action is taken, so
**   video doesn't necessarily stop.  It probably will as a result of
**   other resources going away, but if a client starts video using
**   none of its own resources, then the video will continue to play
**   after the client disappears.
**
**
*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "gcstruct.h"
#include "extnsionst.h"
#include "extinit.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include "input.h"

#define GLOBAL

#include <X11/extensions/Xv.h>
#include <X11/extensions/Xvproto.h>
#include "xvdix.h"

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif
#include "xvdisp.h"

static DevPrivateKeyRec XvScreenKeyRec;

#define XvScreenKey (&XvScreenKeyRec)
unsigned long XvExtensionGeneration = 0;
unsigned long XvScreenGeneration = 0;
unsigned long XvResourceGeneration = 0;

int XvReqCode;
int XvEventBase;
int XvErrorBase;

RESTYPE XvRTPort;
RESTYPE XvRTEncoding;
RESTYPE XvRTGrab;
RESTYPE XvRTVideoNotify;
RESTYPE XvRTVideoNotifyList;
RESTYPE XvRTPortNotify;

/* EXTERNAL */

static void WriteSwappedVideoNotifyEvent(xvEvent *, xvEvent *);
static void WriteSwappedPortNotifyEvent(xvEvent *, xvEvent *);
static Bool CreateResourceTypes(void);

static Bool XvCloseScreen(ScreenPtr);
static Bool XvDestroyPixmap(PixmapPtr);
static Bool XvDestroyWindow(WindowPtr);
static void XvResetProc(ExtensionEntry *);
static int XvdiDestroyGrab(void *, XID);
static int XvdiDestroyEncoding(void *, XID);
static int XvdiDestroyVideoNotify(void *, XID);
static int XvdiDestroyPortNotify(void *, XID);
static int XvdiDestroyVideoNotifyList(void *, XID);
static int XvdiDestroyPort(void *, XID);
static int XvdiSendVideoNotify(XvPortPtr, DrawablePtr, int);

/*
** XvExtensionInit
**
**
*/

void
XvExtensionInit(void)
{
    ExtensionEntry *extEntry;

    if (!dixRegisterPrivateKey(&XvScreenKeyRec, PRIVATE_SCREEN, 0))
        return;

    /* Look to see if any screens were initialized; if not then
       init global variables so the extension can function */
    if (XvScreenGeneration != serverGeneration) {
        if (!CreateResourceTypes()) {
            ErrorF("XvExtensionInit: Unable to allocate resource types\n");
            return;
        }
#ifdef PANORAMIX
        XineramaRegisterConnectionBlockCallback(XineramifyXv);
#endif
        XvScreenGeneration = serverGeneration;
    }

    if (XvExtensionGeneration != serverGeneration) {
        XvExtensionGeneration = serverGeneration;

        extEntry = AddExtension(XvName, XvNumEvents, XvNumErrors,
                                ProcXvDispatch, SProcXvDispatch,
                                XvResetProc, StandardMinorOpcode);
        if (!extEntry) {
            FatalError("XvExtensionInit: AddExtensions failed\n");
        }

        XvReqCode = extEntry->base;
        XvEventBase = extEntry->eventBase;
        XvErrorBase = extEntry->errorBase;

        EventSwapVector[XvEventBase + XvVideoNotify] =
            (EventSwapPtr) WriteSwappedVideoNotifyEvent;
        EventSwapVector[XvEventBase + XvPortNotify] =
            (EventSwapPtr) WriteSwappedPortNotifyEvent;

        SetResourceTypeErrorValue(XvRTPort, _XvBadPort);
        (void) MakeAtom(XvName, strlen(XvName), xTrue);

    }
}

static Bool
CreateResourceTypes(void)
{

    if (XvResourceGeneration == serverGeneration)
        return TRUE;

    XvResourceGeneration = serverGeneration;

    if (!(XvRTPort = CreateNewResourceType(XvdiDestroyPort, "XvRTPort"))) {
        ErrorF("CreateResourceTypes: failed to allocate port resource.\n");
        return FALSE;
    }

    if (!(XvRTGrab = CreateNewResourceType(XvdiDestroyGrab, "XvRTGrab"))) {
        ErrorF("CreateResourceTypes: failed to allocate grab resource.\n");
        return FALSE;
    }

    if (!(XvRTEncoding = CreateNewResourceType(XvdiDestroyEncoding,
                                               "XvRTEncoding"))) {
        ErrorF("CreateResourceTypes: failed to allocate encoding resource.\n");
        return FALSE;
    }

    if (!(XvRTVideoNotify = CreateNewResourceType(XvdiDestroyVideoNotify,
                                                  "XvRTVideoNotify"))) {
        ErrorF
            ("CreateResourceTypes: failed to allocate video notify resource.\n");
        return FALSE;
    }

    if (!
        (XvRTVideoNotifyList =
         CreateNewResourceType(XvdiDestroyVideoNotifyList,
                               "XvRTVideoNotifyList"))) {
        ErrorF
            ("CreateResourceTypes: failed to allocate video notify list resource.\n");
        return FALSE;
    }

    if (!(XvRTPortNotify = CreateNewResourceType(XvdiDestroyPortNotify,
                                                 "XvRTPortNotify"))) {
        ErrorF
            ("CreateResourceTypes: failed to allocate port notify resource.\n");
        return FALSE;
    }

    return TRUE;

}

int
XvScreenInit(ScreenPtr pScreen)
{
    XvScreenPtr pxvs;

    if (XvScreenGeneration != serverGeneration) {
        if (!CreateResourceTypes()) {
            ErrorF("XvScreenInit: Unable to allocate resource types\n");
            return BadAlloc;
        }
#ifdef PANORAMIX
        XineramaRegisterConnectionBlockCallback(XineramifyXv);
#endif
        XvScreenGeneration = serverGeneration;
    }

    if (!dixRegisterPrivateKey(&XvScreenKeyRec, PRIVATE_SCREEN, 0))
        return BadAlloc;

    if (dixLookupPrivate(&pScreen->devPrivates, XvScreenKey)) {
        ErrorF("XvScreenInit: screen devPrivates ptr non-NULL before init\n");
    }

    /* ALLOCATE SCREEN PRIVATE RECORD */

    pxvs = malloc(sizeof(XvScreenRec));
    if (!pxvs) {
        ErrorF("XvScreenInit: Unable to allocate screen private structure\n");
        return BadAlloc;
    }

    dixSetPrivate(&pScreen->devPrivates, XvScreenKey, pxvs);

    pxvs->DestroyPixmap = pScreen->DestroyPixmap;
    pxvs->DestroyWindow = pScreen->DestroyWindow;
    pxvs->CloseScreen = pScreen->CloseScreen;

    pScreen->DestroyPixmap = XvDestroyPixmap;
    pScreen->DestroyWindow = XvDestroyWindow;
    pScreen->CloseScreen = XvCloseScreen;

    return Success;
}

static Bool
XvCloseScreen(ScreenPtr pScreen)
{

    XvScreenPtr pxvs;

    pxvs = (XvScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);

    pScreen->DestroyPixmap = pxvs->DestroyPixmap;
    pScreen->DestroyWindow = pxvs->DestroyWindow;
    pScreen->CloseScreen = pxvs->CloseScreen;

    free(pxvs);

    dixSetPrivate(&pScreen->devPrivates, XvScreenKey, NULL);

    return (*pScreen->CloseScreen) (pScreen);
}

static void
XvResetProc(ExtensionEntry * extEntry)
{
    XvResetProcVector();
}

DevPrivateKey
XvGetScreenKey(void)
{
    return XvScreenKey;
}

unsigned long
XvGetRTPort(void)
{
    return XvRTPort;
}

static void
XvStopAdaptors(DrawablePtr pDrawable)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    XvScreenPtr pxvs = dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);
    XvAdaptorPtr pa = pxvs->pAdaptors;
    int na = pxvs->nAdaptors;

    /* CHECK TO SEE IF THIS PORT IS IN USE */
    while (na--) {
        XvPortPtr pp = pa->pPorts;
        int np = pa->nPorts;

        while (np--) {
            if (pp->pDraw == pDrawable) {
                XvdiSendVideoNotify(pp, pDrawable, XvPreempted);

                (void) (*pp->pAdaptor->ddStopVideo) (pp, pDrawable);

                pp->pDraw = NULL;
                pp->client = NULL;
                pp->time = currentTime;
            }
            pp++;
        }
        pa++;
    }
}

static Bool
XvDestroyPixmap(PixmapPtr pPix)
{
    ScreenPtr pScreen = pPix->drawable.pScreen;
    Bool status;

    if (pPix->refcnt == 1)
        XvStopAdaptors(&pPix->drawable);

    SCREEN_PROLOGUE(pScreen, DestroyPixmap);
    status = (*pScreen->DestroyPixmap) (pPix);
    SCREEN_EPILOGUE(pScreen, DestroyPixmap, XvDestroyPixmap);

    return status;

}

static Bool
XvDestroyWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    Bool status;

    XvStopAdaptors(&pWin->drawable);

    SCREEN_PROLOGUE(pScreen, DestroyWindow);
    status = (*pScreen->DestroyWindow) (pWin);
    SCREEN_EPILOGUE(pScreen, DestroyWindow, XvDestroyWindow);

    return status;

}

static int
XvdiDestroyPort(void *pPort, XID id)
{
    return Success;
}

static int
XvdiDestroyGrab(void *pGrab, XID id)
{
    ((XvGrabPtr) pGrab)->client = NULL;
    return Success;
}

static int
XvdiDestroyVideoNotify(void *pn, XID id)
{
    /* JUST CLEAR OUT THE client POINTER FIELD */

    ((XvVideoNotifyPtr) pn)->client = NULL;
    return Success;
}

static int
XvdiDestroyPortNotify(void *pn, XID id)
{
    /* JUST CLEAR OUT THE client POINTER FIELD */

    ((XvPortNotifyPtr) pn)->client = NULL;
    return Success;
}

static int
XvdiDestroyVideoNotifyList(void *pn, XID id)
{
    XvVideoNotifyPtr npn, cpn;

    /* ACTUALLY DESTROY THE NOTITY LIST */

    cpn = (XvVideoNotifyPtr) pn;

    while (cpn) {
        npn = cpn->next;
        if (cpn->client)
            FreeResource(cpn->id, XvRTVideoNotify);
        free(cpn);
        cpn = npn;
    }
    return Success;
}

static int
XvdiDestroyEncoding(void *value, XID id)
{
    return Success;
}

static int
XvdiSendVideoNotify(XvPortPtr pPort, DrawablePtr pDraw, int reason)
{
    XvVideoNotifyPtr pn;

    dixLookupResourceByType((void **) &pn, pDraw->id, XvRTVideoNotifyList,
                            serverClient, DixReadAccess);

    while (pn) {
        xvEvent event = {
            .u.videoNotify.reason = reason,
            .u.videoNotify.time = currentTime.milliseconds,
            .u.videoNotify.drawable = pDraw->id,
            .u.videoNotify.port = pPort->id
        };
        event.u.u.type = XvEventBase + XvVideoNotify;
        WriteEventsToClient(pn->client, 1, (xEventPtr) &event);
        pn = pn->next;
    }

    return Success;

}

int
XvdiSendPortNotify(XvPortPtr pPort, Atom attribute, INT32 value)
{
    XvPortNotifyPtr pn;

    pn = pPort->pNotify;

    while (pn) {
        xvEvent event = {
            .u.portNotify.time = currentTime.milliseconds,
            .u.portNotify.port = pPort->id,
            .u.portNotify.attribute = attribute,
            .u.portNotify.value = value
        };
        event.u.u.type = XvEventBase + XvPortNotify;
        WriteEventsToClient(pn->client, 1, (xEventPtr) &event);
        pn = pn->next;
    }

    return Success;

}

#define CHECK_SIZE(dw, dh, sw, sh) {                                  \
  if(!dw || !dh || !sw || !sh)  return Success;                       \
  /* The region code will break these if they are too large */        \
  if((dw > 32767) || (dh > 32767) || (sw > 32767) || (sh > 32767))    \
        return BadValue;                                              \
}

int
XvdiPutVideo(ClientPtr client,
             DrawablePtr pDraw,
             XvPortPtr pPort,
             GCPtr pGC,
             INT16 vid_x, INT16 vid_y,
             CARD16 vid_w, CARD16 vid_h,
             INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    DrawablePtr pOldDraw;

    CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

    /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

    UpdateCurrentTime();

    /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
       INFORM CLIENT OF ITS FAILURE */

    if (pPort->grab.client && (pPort->grab.client != client)) {
        XvdiSendVideoNotify(pPort, pDraw, XvBusy);
        return Success;
    }

    /* CHECK TO SEE IF PORT IS IN USE; IF SO THEN WE MUST DELIVER INTERRUPTED
       EVENTS TO ANY CLIENTS WHO WANT THEM */

    pOldDraw = pPort->pDraw;
    if ((pOldDraw) && (pOldDraw != pDraw)) {
        XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);
    }

    (void) (*pPort->pAdaptor->ddPutVideo) (pDraw, pPort, pGC,
                                           vid_x, vid_y, vid_w, vid_h,
                                           drw_x, drw_y, drw_w, drw_h);

    if ((pPort->pDraw) && (pOldDraw != pDraw)) {
        pPort->client = client;
        XvdiSendVideoNotify(pPort, pPort->pDraw, XvStarted);
    }

    pPort->time = currentTime;

    return Success;

}

int
XvdiPutStill(ClientPtr client,
             DrawablePtr pDraw,
             XvPortPtr pPort,
             GCPtr pGC,
             INT16 vid_x, INT16 vid_y,
             CARD16 vid_w, CARD16 vid_h,
             INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    int status;

    CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

    /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

    UpdateCurrentTime();

    /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
       INFORM CLIENT OF ITS FAILURE */

    if (pPort->grab.client && (pPort->grab.client != client)) {
        XvdiSendVideoNotify(pPort, pDraw, XvBusy);
        return Success;
    }

    pPort->time = currentTime;

    status = (*pPort->pAdaptor->ddPutStill) (pDraw, pPort, pGC,
                                             vid_x, vid_y, vid_w, vid_h,
                                             drw_x, drw_y, drw_w, drw_h);

    return status;

}

int
XvdiPutImage(ClientPtr client,
             DrawablePtr pDraw,
             XvPortPtr pPort,
             GCPtr pGC,
             INT16 src_x, INT16 src_y,
             CARD16 src_w, CARD16 src_h,
             INT16 drw_x, INT16 drw_y,
             CARD16 drw_w, CARD16 drw_h,
             XvImagePtr image,
             unsigned char *data, Bool sync, CARD16 width, CARD16 height)
{
    CHECK_SIZE(drw_w, drw_h, src_w, src_h);

    /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

    UpdateCurrentTime();

    /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
       INFORM CLIENT OF ITS FAILURE */

    if (pPort->grab.client && (pPort->grab.client != client)) {
        XvdiSendVideoNotify(pPort, pDraw, XvBusy);
        return Success;
    }

    pPort->time = currentTime;

    return (*pPort->pAdaptor->ddPutImage) (pDraw, pPort, pGC,
                                           src_x, src_y, src_w, src_h,
                                           drw_x, drw_y, drw_w, drw_h,
                                           image, data, sync, width, height);
}

int
XvdiGetVideo(ClientPtr client,
             DrawablePtr pDraw,
             XvPortPtr pPort,
             GCPtr pGC,
             INT16 vid_x, INT16 vid_y,
             CARD16 vid_w, CARD16 vid_h,
             INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    DrawablePtr pOldDraw;

    CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

    /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

    UpdateCurrentTime();

    /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
       INFORM CLIENT OF ITS FAILURE */

    if (pPort->grab.client && (pPort->grab.client != client)) {
        XvdiSendVideoNotify(pPort, pDraw, XvBusy);
        return Success;
    }

    /* CHECK TO SEE IF PORT IS IN USE; IF SO THEN WE MUST DELIVER INTERRUPTED
       EVENTS TO ANY CLIENTS WHO WANT THEM */

    pOldDraw = pPort->pDraw;
    if ((pOldDraw) && (pOldDraw != pDraw)) {
        XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);
    }

    (void) (*pPort->pAdaptor->ddGetVideo) (pDraw, pPort, pGC,
                                           vid_x, vid_y, vid_w, vid_h,
                                           drw_x, drw_y, drw_w, drw_h);

    if ((pPort->pDraw) && (pOldDraw != pDraw)) {
        pPort->client = client;
        XvdiSendVideoNotify(pPort, pPort->pDraw, XvStarted);
    }

    pPort->time = currentTime;

    return Success;

}

int
XvdiGetStill(ClientPtr client,
             DrawablePtr pDraw,
             XvPortPtr pPort,
             GCPtr pGC,
             INT16 vid_x, INT16 vid_y,
             CARD16 vid_w, CARD16 vid_h,
             INT16 drw_x, INT16 drw_y, CARD16 drw_w, CARD16 drw_h)
{
    int status;

    CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);

    /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

    UpdateCurrentTime();

    /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
       INFORM CLIENT OF ITS FAILURE */

    if (pPort->grab.client && (pPort->grab.client != client)) {
        XvdiSendVideoNotify(pPort, pDraw, XvBusy);
        return Success;
    }

    status = (*pPort->pAdaptor->ddGetStill) (pDraw, pPort, pGC,
                                             vid_x, vid_y, vid_w, vid_h,
                                             drw_x, drw_y, drw_w, drw_h);

    pPort->time = currentTime;

    return status;

}

int
XvdiGrabPort(ClientPtr client, XvPortPtr pPort, Time ctime, int *p_result)
{
    unsigned long id;
    TimeStamp time;

    UpdateCurrentTime();
    time = ClientTimeToServerTime(ctime);

    if (pPort->grab.client && (client != pPort->grab.client)) {
        *p_result = XvAlreadyGrabbed;
        return Success;
    }

    if ((CompareTimeStamps(time, currentTime) == LATER) ||
        (CompareTimeStamps(time, pPort->time) == EARLIER)) {
        *p_result = XvInvalidTime;
        return Success;
    }

    if (client == pPort->grab.client) {
        *p_result = Success;
        return Success;
    }

    id = FakeClientID(client->index);

    if (!AddResource(id, XvRTGrab, &pPort->grab)) {
        return BadAlloc;
    }

    /* IF THERE IS ACTIVE VIDEO THEN STOP IT */

    if ((pPort->pDraw) && (client != pPort->client)) {
        XvdiStopVideo(NULL, pPort, pPort->pDraw);
    }

    pPort->grab.client = client;
    pPort->grab.id = id;

    pPort->time = currentTime;

    *p_result = Success;

    return Success;

}

int
XvdiUngrabPort(ClientPtr client, XvPortPtr pPort, Time ctime)
{
    TimeStamp time;

    UpdateCurrentTime();
    time = ClientTimeToServerTime(ctime);

    if ((!pPort->grab.client) || (client != pPort->grab.client)) {
        return Success;
    }

    if ((CompareTimeStamps(time, currentTime) == LATER) ||
        (CompareTimeStamps(time, pPort->time) == EARLIER)) {
        return Success;
    }

    /* FREE THE GRAB RESOURCE; AND SET THE GRAB CLIENT TO NULL */

    FreeResource(pPort->grab.id, XvRTGrab);
    pPort->grab.client = NULL;

    pPort->time = currentTime;

    return Success;

}

int
XvdiSelectVideoNotify(ClientPtr client, DrawablePtr pDraw, BOOL onoff)
{
    XvVideoNotifyPtr pn, tpn, fpn;
    int rc;

    /* FIND VideoNotify LIST */

    rc = dixLookupResourceByType((void **) &pn, pDraw->id,
                                 XvRTVideoNotifyList, client, DixWriteAccess);
    if (rc != Success && rc != BadValue)
        return rc;

    /* IF ONE DONES'T EXIST AND NO MASK, THEN JUST RETURN */

    if (!onoff && !pn)
        return Success;

    /* IF ONE DOESN'T EXIST CREATE IT AND ADD A RESOURCE SO THAT THE LIST
       WILL BE DELETED WHEN THE DRAWABLE IS DESTROYED */

    if (!pn) {
        if (!(tpn = malloc(sizeof(XvVideoNotifyRec))))
            return BadAlloc;
        tpn->next = NULL;
        tpn->client = NULL;
        if (!AddResource(pDraw->id, XvRTVideoNotifyList, tpn))
            return BadAlloc;
    }
    else {
        /* LOOK TO SEE IF ENTRY ALREADY EXISTS */

        fpn = NULL;
        tpn = pn;
        while (tpn) {
            if (tpn->client == client) {
                if (!onoff)
                    tpn->client = NULL;
                return Success;
            }
            if (!tpn->client)
                fpn = tpn;      /* TAKE NOTE OF FREE ENTRY */
            tpn = tpn->next;
        }

        /* IF TUNNING OFF, THEN JUST RETURN */

        if (!onoff)
            return Success;

        /* IF ONE ISN'T FOUND THEN ALLOCATE ONE AND LINK IT INTO THE LIST */

        if (fpn) {
            tpn = fpn;
        }
        else {
            if (!(tpn = malloc(sizeof(XvVideoNotifyRec))))
                return BadAlloc;
            tpn->next = pn->next;
            pn->next = tpn;
        }
    }

    /* INIT CLIENT PTR IN CASE WE CAN'T ADD RESOURCE */
    /* ADD RESOURCE SO THAT IF CLIENT EXITS THE CLIENT PTR WILL BE CLEARED */

    tpn->client = NULL;
    tpn->id = FakeClientID(client->index);
    if (!AddResource(tpn->id, XvRTVideoNotify, tpn))
        return BadAlloc;

    tpn->client = client;
    return Success;

}

int
XvdiSelectPortNotify(ClientPtr client, XvPortPtr pPort, BOOL onoff)
{
    XvPortNotifyPtr pn, tpn;

    /* SEE IF CLIENT IS ALREADY IN LIST */

    tpn = NULL;
    pn = pPort->pNotify;
    while (pn) {
        if (!pn->client)
            tpn = pn;           /* TAKE NOTE OF FREE ENTRY */
        if (pn->client == client)
            break;
        pn = pn->next;
    }

    /* IS THE CLIENT ALREADY ON THE LIST? */

    if (pn) {
        /* REMOVE IT? */

        if (!onoff) {
            pn->client = NULL;
            FreeResource(pn->id, XvRTPortNotify);
        }

        return Success;
    }

    /* DIDN'T FIND IT; SO REUSE LIST ELEMENT IF ONE IS FREE OTHERWISE
       CREATE A NEW ONE AND ADD IT TO THE BEGINNING OF THE LIST */

    if (!tpn) {
        if (!(tpn = malloc(sizeof(XvPortNotifyRec))))
            return BadAlloc;
        tpn->next = pPort->pNotify;
        pPort->pNotify = tpn;
    }

    tpn->client = client;
    tpn->id = FakeClientID(client->index);
    if (!AddResource(tpn->id, XvRTPortNotify, tpn))
        return BadAlloc;

    return Success;

}

int
XvdiStopVideo(ClientPtr client, XvPortPtr pPort, DrawablePtr pDraw)
{
    int status;

    /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */

    if (!pPort->pDraw || (pPort->pDraw != pDraw)) {
        XvdiSendVideoNotify(pPort, pDraw, XvStopped);
        return Success;
    }

    /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
       INFORM CLIENT OF ITS FAILURE */

    if ((client) && (pPort->grab.client) && (pPort->grab.client != client)) {
        XvdiSendVideoNotify(pPort, pDraw, XvBusy);
        return Success;
    }

    XvdiSendVideoNotify(pPort, pDraw, XvStopped);

    status = (*pPort->pAdaptor->ddStopVideo) (pPort, pDraw);

    pPort->pDraw = NULL;
    pPort->client = (ClientPtr) client;
    pPort->time = currentTime;

    return status;

}

int
XvdiMatchPort(XvPortPtr pPort, DrawablePtr pDraw)
{

    XvAdaptorPtr pa;
    XvFormatPtr pf;
    int nf;

    pa = pPort->pAdaptor;

    if (pa->pScreen != pDraw->pScreen)
        return BadMatch;

    nf = pa->nFormats;
    pf = pa->pFormats;

    while (nf--) {
        if (pf->depth == pDraw->depth)
            return Success;
        pf++;
    }

    return BadMatch;

}

int
XvdiSetPortAttribute(ClientPtr client,
                     XvPortPtr pPort, Atom attribute, INT32 value)
{
    int status;

    status =
        (*pPort->pAdaptor->ddSetPortAttribute) (pPort, attribute,
                                                value);
    if (status == Success)
        XvdiSendPortNotify(pPort, attribute, value);

    return status;
}

int
XvdiGetPortAttribute(ClientPtr client,
                     XvPortPtr pPort, Atom attribute, INT32 *p_value)
{

    return
        (*pPort->pAdaptor->ddGetPortAttribute) (pPort, attribute,
                                                p_value);

}

static void
WriteSwappedVideoNotifyEvent(xvEvent * from, xvEvent * to)
{

    to->u.u.type = from->u.u.type;
    to->u.u.detail = from->u.u.detail;
    cpswaps(from->u.videoNotify.sequenceNumber,
            to->u.videoNotify.sequenceNumber);
    cpswapl(from->u.videoNotify.time, to->u.videoNotify.time);
    cpswapl(from->u.videoNotify.drawable, to->u.videoNotify.drawable);
    cpswapl(from->u.videoNotify.port, to->u.videoNotify.port);

}

static void
WriteSwappedPortNotifyEvent(xvEvent * from, xvEvent * to)
{

    to->u.u.type = from->u.u.type;
    to->u.u.detail = from->u.u.detail;
    cpswaps(from->u.portNotify.sequenceNumber, to->u.portNotify.sequenceNumber);
    cpswapl(from->u.portNotify.time, to->u.portNotify.time);
    cpswapl(from->u.portNotify.port, to->u.portNotify.port);
    cpswapl(from->u.portNotify.value, to->u.portNotify.value);

}

void
XvFreeAdaptor(XvAdaptorPtr pAdaptor)
{
    int i;

    free(pAdaptor->name);
    pAdaptor->name = NULL;

    if (pAdaptor->pEncodings) {
        XvEncodingPtr pEncode = pAdaptor->pEncodings;

        for (i = 0; i < pAdaptor->nEncodings; i++, pEncode++)
            free(pEncode->name);
        free(pAdaptor->pEncodings);
        pAdaptor->pEncodings = NULL;
    }

    free(pAdaptor->pFormats);
    pAdaptor->pFormats = NULL;

    free(pAdaptor->pPorts);
    pAdaptor->pPorts = NULL;

    if (pAdaptor->pAttributes) {
        XvAttributePtr pAttribute = pAdaptor->pAttributes;

        for (i = 0; i < pAdaptor->nAttributes; i++, pAttribute++)
            free(pAttribute->name);
        free(pAdaptor->pAttributes);
        pAdaptor->pAttributes = NULL;
    }

    free(pAdaptor->pImages);
    pAdaptor->pImages = NULL;

    free(pAdaptor->devPriv.ptr);
    pAdaptor->devPriv.ptr = NULL;
}

void
XvFillColorKey(DrawablePtr pDraw, CARD32 key, RegionPtr region)
{
    ScreenPtr pScreen = pDraw->pScreen;
    ChangeGCVal pval[2];
    BoxPtr pbox = RegionRects(region);
    int i, nbox = RegionNumRects(region);
    xRectangle *rects;
    GCPtr gc;

    gc = GetScratchGC(pDraw->depth, pScreen);
    if (!gc)
        return;

    pval[0].val = key;
    pval[1].val = IncludeInferiors;
    (void) ChangeGC(NullClient, gc, GCForeground | GCSubwindowMode, pval);
    ValidateGC(pDraw, gc);

    rects = xallocarray(nbox, sizeof(xRectangle));
    if (rects) {
        for (i = 0; i < nbox; i++, pbox++) {
            rects[i].x = pbox->x1 - pDraw->x;
            rects[i].y = pbox->y1 - pDraw->y;
            rects[i].width = pbox->x2 - pbox->x1;
            rects[i].height = pbox->y2 - pbox->y1;
        }

        (*gc->ops->PolyFillRect) (pDraw, gc, nbox, rects);

        free(rects);
    }
    FreeScratchGC(gc);
}
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d330 2
a331 2
static Bool
XvDestroyPixmap(PixmapPtr pPix)
d333 4
a336 13
    Bool status;
    ScreenPtr pScreen;
    XvScreenPtr pxvs;
    XvAdaptorPtr pa;
    int na;
    XvPortPtr pp;
    int np;

    pScreen = pPix->drawable.pScreen;

    SCREEN_PROLOGUE(pScreen, DestroyPixmap);

    pxvs = (XvScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);
a338 3

    pa = pxvs->pAdaptors;
    na = pxvs->nAdaptors;
d340 2
a341 2
        np = pa->nPorts;
        pp = pa->pPorts;
d344 2
a345 2
            if (pp->pDraw == (DrawablePtr) pPix) {
                XvdiSendVideoNotify(pp, pp->pDraw, XvPreempted);
d347 1
a347 1
                (void) (*pp->pAdaptor->ddStopVideo) (pp, pp->pDraw);
d357 1
d359 10
a369 1

d379 1
a380 6
    ScreenPtr pScreen;
    XvScreenPtr pxvs;
    XvAdaptorPtr pa;
    int na;
    XvPortPtr pp;
    int np;
d382 1
a382 1
    pScreen = pWin->drawable.pScreen;
a384 26

    pxvs = (XvScreenPtr) dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);

    /* CHECK TO SEE IF THIS PORT IS IN USE */

    pa = pxvs->pAdaptors;
    na = pxvs->nAdaptors;
    while (na--) {
        np = pa->nPorts;
        pp = pa->pPorts;

        while (np--) {
            if (pp->pDraw == (DrawablePtr) pWin) {
                XvdiSendVideoNotify(pp, pp->pDraw, XvPreempted);

                (void) (*pp->pAdaptor->ddStopVideo) (pp, pp->pDraw);

                pp->pDraw = NULL;
                pp->client = NULL;
                pp->time = currentTime;
            }
            pp++;
        }
        pa++;
    }

a385 1

d803 2
a804 2
        if (!AddResource(pDraw->id, XvRTVideoNotifyList, tpn)) {
            free(tpn);
a805 1
        }
d846 2
a847 1
    AddResource(tpn->id, XvRTVideoNotify, tpn);
d896 2
a897 1
    AddResource(tpn->id, XvRTPortNotify, tpn);
d1072 1
a1072 1
    rects = malloc(nbox * sizeof(xRectangle));
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d7 2
a8 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d10 1
a10 1
both that copyright notice and this permission notice appear in 
d13 1
a13 1
software without specific, written prior permission.  
d26 1
a26 1
** File: 
d29 2
a30 2
**   
** Author: 
d61 1
a61 1
**       
d89 1
a89 1
#include "gc.h"
a304 2
    (*pxvs->ddCloseScreen) (pScreen);

d359 1
a359 1
                (void) (*pp->pAdaptor->ddStopVideo) (NULL, pp, pp->pDraw);
d407 1
a407 1
                (void) (*pp->pAdaptor->ddStopVideo) (NULL, pp, pp->pDraw);
a425 24
/* The XvdiVideoStopped procedure is a hook for the device dependent layer.
   It provides a way for the dd layer to inform the di layer that video has
   stopped in a port for reasons that the di layer had no control over; note
   that it doesn't call back into the dd layer */

int
XvdiVideoStopped(XvPortPtr pPort, int reason)
{

    /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */

    if (!pPort->pDraw)
        return Success;

    XvdiSendVideoNotify(pPort, pPort->pDraw, reason);

    pPort->pDraw = NULL;
    pPort->client = NULL;
    pPort->time = currentTime;

    return Success;

}

d429 1
a429 1
    return (*((XvPortPtr) pPort)->pAdaptor->ddFreePort) (pPort);
d569 1
a569 1
    (void) (*pPort->pAdaptor->ddPutVideo) (client, pDraw, pPort, pGC,
d611 1
a611 1
    status = (*pPort->pAdaptor->ddPutStill) (client, pDraw, pPort, pGC,
d647 1
a647 1
    return (*pPort->pAdaptor->ddPutImage) (client, pDraw, pPort, pGC,
d686 1
a686 1
    (void) (*pPort->pAdaptor->ddGetVideo) (client, pDraw, pPort, pGC,
d726 1
a726 1
    status = (*pPort->pAdaptor->ddGetStill) (client, pDraw, pPort, pGC,
d918 1
a918 1
    /* DIDN'T FIND IT; SO REUSE LIST ELEMENT IF ONE IS FREE OTHERWISE 
d958 1
a958 23
    status = (*pPort->pAdaptor->ddStopVideo) (client, pPort, pDraw);

    pPort->pDraw = NULL;
    pPort->client = (ClientPtr) client;
    pPort->time = currentTime;

    return status;

}

int
XvdiPreemptVideo(ClientPtr client, XvPortPtr pPort, DrawablePtr pDraw)
{
    int status;

    /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */

    if (!pPort->pDraw || (pPort->pDraw != pDraw))
        return Success;

    XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);

    status = (*pPort->pAdaptor->ddStopVideo) (client, pPort, pPort->pDraw);
d1001 1
a1001 1
        (*pPort->pAdaptor->ddSetPortAttribute) (client, pPort, attribute,
d1015 1
a1015 1
        (*pPort->pAdaptor->ddGetPortAttribute) (client, pPort, attribute,
d1045 74
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d137 6
a142 6
static int XvdiDestroyGrab(pointer, XID);
static int XvdiDestroyEncoding(pointer, XID);
static int XvdiDestroyVideoNotify(pointer, XID);
static int XvdiDestroyPortNotify(pointer, XID);
static int XvdiDestroyVideoNotifyList(pointer, XID);
static int XvdiDestroyPort(pointer, XID);
d453 1
a453 1
XvdiDestroyPort(pointer pPort, XID id)
d459 1
a459 1
XvdiDestroyGrab(pointer pGrab, XID id)
d466 1
a466 1
XvdiDestroyVideoNotify(pointer pn, XID id)
d475 1
a475 1
XvdiDestroyPortNotify(pointer pn, XID id)
d484 1
a484 1
XvdiDestroyVideoNotifyList(pointer pn, XID id)
d503 1
a503 1
XvdiDestroyEncoding(pointer value, XID id)
d513 1
a513 1
    dixLookupResourceByType((pointer *) &pn, pDraw->id, XvRTVideoNotifyList,
d846 1
a846 1
    rc = dixLookupResourceByType((pointer *) &pn, pDraw->id,
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d159 2
a160 2
    /* LOOK TO SEE IF ANY SCREENS WERE INITIALIZED; IF NOT THEN
       INIT GLOBAL VARIABLES SO THE EXTENSION CAN FUNCTION */
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d91 1
d133 1
a133 1
static Bool XvCloseScreen(int, ScreenPtr);
d294 1
a294 1
XvCloseScreen(int ii, ScreenPtr pScreen)
d305 1
a305 1
    (*pxvs->ddCloseScreen) (ii, pScreen);
d311 1
a311 1
    return (*pScreen->CloseScreen) (ii, pScreen);
a510 1
    xvEvent event;
d517 6
d524 1
a524 5
        event.u.videoNotify.time = currentTime.milliseconds;
        event.u.videoNotify.drawable = pDraw->id;
        event.u.videoNotify.port = pPort->id;
        event.u.videoNotify.reason = reason;
        WriteEventsToClient(pn->client, 1, (xEventPtr) & event);
a534 1
    xvEvent event;
d540 6
d547 1
a547 5
        event.u.portNotify.time = currentTime.milliseconds;
        event.u.portNotify.port = pPort->id;
        event.u.portNotify.attribute = attribute;
        event.u.portNotify.value = value;
        WriteEventsToClient(pn->client, 1, (xEventPtr) & event);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d109 1
d135 1
a135 1
static void XvResetProc(ExtensionEntry*);
a143 3



d153 1
a153 1
  ExtensionEntry *extEntry;
d155 2
a156 2
  if (!dixRegisterPrivateKey(&XvScreenKeyRec, PRIVATE_SCREEN, 0))
      return;
d158 7
a164 9
  /* LOOK TO SEE IF ANY SCREENS WERE INITIALIZED; IF NOT THEN
     INIT GLOBAL VARIABLES SO THE EXTENSION CAN FUNCTION */
  if (XvScreenGeneration != serverGeneration)
    {
      if (!CreateResourceTypes())
	{
	  ErrorF("XvExtensionInit: Unable to allocate resource types\n");
	  return;
	}
d168 1
a168 1
      XvScreenGeneration = serverGeneration;
d171 18
a188 20
  if (XvExtensionGeneration != serverGeneration)
    {
      XvExtensionGeneration = serverGeneration;

      extEntry = AddExtension(XvName, XvNumEvents, XvNumErrors, 
			      ProcXvDispatch, SProcXvDispatch,
			      XvResetProc, StandardMinorOpcode);
      if (!extEntry) 
	{
	  FatalError("XvExtensionInit: AddExtensions failed\n");
	}

      XvReqCode = extEntry->base;
      XvEventBase = extEntry->eventBase;
      XvErrorBase = extEntry->errorBase;

      EventSwapVector[XvEventBase+XvVideoNotify] = 
	(EventSwapPtr)WriteSwappedVideoNotifyEvent;
      EventSwapVector[XvEventBase+XvPortNotify] = 
	(EventSwapPtr)WriteSwappedPortNotifyEvent;
d190 2
a191 2
      SetResourceTypeErrorValue(XvRTPort, _XvBadPort);
      (void)MakeAtom(XvName, strlen(XvName), xTrue);
d198 1
d200 2
a201 3
{
  
  if (XvResourceGeneration == serverGeneration) return TRUE;
d203 1
a203 1
  XvResourceGeneration = serverGeneration;
d205 3
a207 4
  if (!(XvRTPort = CreateNewResourceType(XvdiDestroyPort, "XvRTPort")))
    {
      ErrorF("CreateResourceTypes: failed to allocate port resource.\n");
      return FALSE;
d210 3
a212 4
  if (!(XvRTGrab = CreateNewResourceType(XvdiDestroyGrab, "XvRTGrab")))
    {
      ErrorF("CreateResourceTypes: failed to allocate grab resource.\n");
      return FALSE;
d215 4
a218 5
  if (!(XvRTEncoding = CreateNewResourceType(XvdiDestroyEncoding,
					     "XvRTEncoding")))
    {
      ErrorF("CreateResourceTypes: failed to allocate encoding resource.\n");
      return FALSE;
d221 5
a225 5
  if (!(XvRTVideoNotify = CreateNewResourceType(XvdiDestroyVideoNotify,
						"XvRTVideoNotify")))
    {
      ErrorF("CreateResourceTypes: failed to allocate video notify resource.\n");
      return FALSE;
d228 7
a234 5
  if (!(XvRTVideoNotifyList = CreateNewResourceType(XvdiDestroyVideoNotifyList,
						    "XvRTVideoNotifyList")))
    {
      ErrorF("CreateResourceTypes: failed to allocate video notify list resource.\n");
      return FALSE;
d237 5
a241 5
  if (!(XvRTPortNotify = CreateNewResourceType(XvdiDestroyPortNotify,
					       "XvRTPortNotify")))
    {
      ErrorF("CreateResourceTypes: failed to allocate port notify resource.\n");
      return FALSE;
d244 1
a244 1
  return TRUE;
d251 1
a251 1
  XvScreenPtr pxvs;
d253 5
a257 7
  if (XvScreenGeneration != serverGeneration)
    {
      if (!CreateResourceTypes())
	{
	  ErrorF("XvScreenInit: Unable to allocate resource types\n");
	  return BadAlloc;
	}
d261 1
a261 1
      XvScreenGeneration = serverGeneration; 
d264 2
a265 2
  if (!dixRegisterPrivateKey(&XvScreenKeyRec, PRIVATE_SCREEN, 0))
      return BadAlloc;
d267 2
a268 3
  if (dixLookupPrivate(&pScreen->devPrivates, XvScreenKey))
    {
      ErrorF("XvScreenInit: screen devPrivates ptr non-NULL before init\n");
d271 6
a276 7
  /* ALLOCATE SCREEN PRIVATE RECORD */
  
  pxvs = malloc(sizeof (XvScreenRec));
  if (!pxvs)
    {
      ErrorF("XvScreenInit: Unable to allocate screen private structure\n");
      return BadAlloc;
d279 5
a283 9
  dixSetPrivate(&pScreen->devPrivates, XvScreenKey, pxvs);
  
  pxvs->DestroyPixmap = pScreen->DestroyPixmap;
  pxvs->DestroyWindow = pScreen->DestroyWindow;
  pxvs->CloseScreen = pScreen->CloseScreen;
  
  pScreen->DestroyPixmap = XvDestroyPixmap;
  pScreen->DestroyWindow = XvDestroyWindow;
  pScreen->CloseScreen = XvCloseScreen;
d285 5
a289 1
  return Success;
d293 2
a294 4
XvCloseScreen(
  int ii,
  ScreenPtr pScreen
){
d296 1
a296 1
  XvScreenPtr pxvs;
d298 1
a298 1
  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);
d300 3
a302 3
  pScreen->DestroyPixmap = pxvs->DestroyPixmap;
  pScreen->DestroyWindow = pxvs->DestroyWindow;
  pScreen->CloseScreen = pxvs->CloseScreen;
d304 1
a304 1
  (* pxvs->ddCloseScreen)(ii, pScreen); 
d306 1
a306 1
  free(pxvs);
d308 1
a308 1
  dixSetPrivate(&pScreen->devPrivates, XvScreenKey, NULL);
d310 1
a310 1
  return (*pScreen->CloseScreen)(ii, pScreen);
d314 1
a314 1
XvResetProc(ExtensionEntry* extEntry)
d328 1
a328 1
  return XvRTPort;
d334 35
a368 38
  Bool status;
  ScreenPtr pScreen;
  XvScreenPtr pxvs;
  XvAdaptorPtr pa;
  int na;
  XvPortPtr pp;
  int np;

  pScreen = pPix->drawable.pScreen;

  SCREEN_PROLOGUE(pScreen, DestroyPixmap);

  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);

  /* CHECK TO SEE IF THIS PORT IS IN USE */

  pa = pxvs->pAdaptors;
  na = pxvs->nAdaptors;
  while (na--)
    {
      np = pa->nPorts;
      pp = pa->pPorts;

      while (np--)
	{
	  if (pp->pDraw == (DrawablePtr)pPix)
	    {
	      XvdiSendVideoNotify(pp, pp->pDraw, XvPreempted);

	      (void)(* pp->pAdaptor->ddStopVideo)(NULL, pp, pp->pDraw);

	      pp->pDraw = NULL;
	      pp->client = NULL;
	      pp->time = currentTime;
	    }
	  pp++;
	}
      pa++;
a369 2
  
  status = (* pScreen->DestroyPixmap)(pPix);
d371 3
a373 1
  SCREEN_EPILOGUE(pScreen, DestroyPixmap, XvDestroyPixmap);
d375 1
a375 1
  return status;
d382 7
a388 7
  Bool status;
  ScreenPtr pScreen;
  XvScreenPtr pxvs;
  XvAdaptorPtr pa;
  int na;
  XvPortPtr pp;
  int np;
d390 1
a390 1
  pScreen = pWin->drawable.pScreen;
d392 1
a392 1
  SCREEN_PROLOGUE(pScreen, DestroyWindow);
d394 1
a394 1
  pxvs = (XvScreenPtr)dixLookupPrivate(&pScreen->devPrivates, XvScreenKey);
d396 1
a396 1
  /* CHECK TO SEE IF THIS PORT IS IN USE */
d398 5
a402 6
  pa = pxvs->pAdaptors;
  na = pxvs->nAdaptors;
  while (na--)
    {
      np = pa->nPorts;
      pp = pa->pPorts;
d404 3
a406 5
      while (np--)
	{
	  if (pp->pDraw == (DrawablePtr)pWin)
	    {
	      XvdiSendVideoNotify(pp, pp->pDraw, XvPreempted);
d408 1
a408 1
	      (void)(* pp->pAdaptor->ddStopVideo)(NULL, pp, pp->pDraw);
d410 7
a416 7
	      pp->pDraw = NULL;
	      pp->client = NULL;
	      pp->time = currentTime;
	    }
	  pp++;
	}
      pa++;
d419 1
a419 2
  
  status = (* pScreen->DestroyWindow)(pWin);
d421 1
a421 1
  SCREEN_EPILOGUE(pScreen, DestroyWindow, XvDestroyWindow);
d423 1
a423 1
  return status;
a434 2
  
  /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */
d436 4
a439 1
  if (!pPort->pDraw) return Success;
d441 1
a441 1
  XvdiSendVideoNotify(pPort, pPort->pDraw, reason);
d443 3
a445 3
  pPort->pDraw = NULL;
  pPort->client = NULL;
  pPort->time = currentTime;
d447 1
a447 1
  return Success;
d451 1
a451 1
static int 
d454 1
a454 1
  return (* ((XvPortPtr)pPort)->pAdaptor->ddFreePort)(pPort);
d460 2
a461 2
  ((XvGrabPtr)pGrab)->client = NULL;
  return Success;
d467 1
a467 1
  /* JUST CLEAR OUT THE client POINTER FIELD */
d469 2
a470 2
  ((XvVideoNotifyPtr)pn)->client = NULL;
  return Success;
d476 1
a476 1
  /* JUST CLEAR OUT THE client POINTER FIELD */
d478 2
a479 2
  ((XvPortNotifyPtr)pn)->client = NULL;
  return Success;
d485 1
a485 1
  XvVideoNotifyPtr npn,cpn;
d487 1
a487 1
  /* ACTUALLY DESTROY THE NOTITY LIST */
d489 1
a489 1
  cpn = (XvVideoNotifyPtr)pn;
d491 6
a496 6
  while (cpn)
    {
      npn = cpn->next;
      if (cpn->client) FreeResource(cpn->id, XvRTVideoNotify);
      free(cpn);
      cpn = npn;
d498 1
a498 1
  return Success;
d504 1
a504 1
  return Success;
d510 2
a511 2
  xvEvent event;
  XvVideoNotifyPtr pn;
d513 2
a514 2
  dixLookupResourceByType((pointer *)&pn, pDraw->id, XvRTVideoNotifyList,
			  serverClient, DixReadAccess);
d516 8
a523 9
  while (pn) 
    {
      event.u.u.type = XvEventBase + XvVideoNotify;
      event.u.videoNotify.time = currentTime.milliseconds;
      event.u.videoNotify.drawable = pDraw->id;
      event.u.videoNotify.port = pPort->id;
      event.u.videoNotify.reason = reason;
      WriteEventsToClient(pn->client, 1, (xEventPtr)&event);
      pn = pn->next;
d526 1
a526 1
  return Success;
d530 7
d538 8
a545 20
int
XvdiSendPortNotify(
  XvPortPtr pPort,
  Atom attribute,
  INT32 value
){
  xvEvent event;
  XvPortNotifyPtr pn;

  pn = pPort->pNotify;

  while (pn) 
    {
      event.u.u.type = XvEventBase + XvPortNotify;
      event.u.portNotify.time = currentTime.milliseconds;
      event.u.portNotify.port = pPort->id;
      event.u.portNotify.attribute = attribute;
      event.u.portNotify.value = value;
      WriteEventsToClient(pn->client, 1, (xEventPtr)&event);
      pn = pn->next;
d548 1
a548 1
  return Success;
a551 1

a558 1

d560 9
a568 11
XvdiPutVideo(   
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  DrawablePtr pOldDraw;
d570 1
a570 1
  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);
d572 1
a572 1
  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */
d574 1
a574 1
  UpdateCurrentTime();
d576 2
a577 2
  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */
d579 3
a581 4
  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
d584 2
a585 2
  /* CHECK TO SEE IF PORT IS IN USE; IF SO THEN WE MUST DELIVER INTERRUPTED
     EVENTS TO ANY CLIENTS WHO WANT THEM */
d587 3
a589 4
  pOldDraw = pPort->pDraw;
  if ((pOldDraw) && (pOldDraw != pDraw))
    {
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);
d592 3
a594 3
  (void) (* pPort->pAdaptor->ddPutVideo)(client, pDraw, pPort, pGC,
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);
d596 3
a598 4
  if ((pPort->pDraw) && (pOldDraw != pDraw))
    {
      pPort->client = client;
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvStarted);
d601 1
a601 1
  pPort->time = currentTime;
d603 1
a603 1
  return Success;
d608 9
a616 11
XvdiPutStill(   
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  int status;
d618 1
a618 1
  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);
d620 1
a620 1
  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */
d622 1
a622 1
  UpdateCurrentTime();
d624 2
a625 2
  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */
d627 3
a629 4
  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
d632 1
a632 1
  pPort->time = currentTime;
d634 3
a636 3
  status = (* pPort->pAdaptor->ddPutStill)(client, pDraw, pPort, pGC, 
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);
d638 1
a638 1
  return status;
d643 31
a673 35
XvdiPutImage(   
   ClientPtr client, 
   DrawablePtr pDraw, 
   XvPortPtr pPort, 
   GCPtr pGC,
   INT16 src_x, INT16 src_y, 
   CARD16 src_w, CARD16 src_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h,
   XvImagePtr image,
   unsigned char* data,
   Bool sync,
   CARD16 width, CARD16 height
){
  CHECK_SIZE(drw_w, drw_h, src_w, src_h);

  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */

  UpdateCurrentTime();

  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */

  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
    }

  pPort->time = currentTime;

  return (* pPort->pAdaptor->ddPutImage)(client, pDraw, pPort, pGC, 
					   src_x, src_y, src_w, src_h, 
					   drw_x, drw_y, drw_w, drw_h,
					   image, data, sync, width, height);
a675 1

d677 9
a685 11
XvdiGetVideo(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  DrawablePtr pOldDraw;
d687 1
a687 1
  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);
d689 1
a689 1
  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */
d691 1
a691 1
  UpdateCurrentTime();
d693 2
a694 2
  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */
d696 3
a698 4
  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
d701 2
a702 2
  /* CHECK TO SEE IF PORT IS IN USE; IF SO THEN WE MUST DELIVER INTERRUPTED
     EVENTS TO ANY CLIENTS WHO WANT THEM */
d704 3
a706 4
  pOldDraw = pPort->pDraw;
  if ((pOldDraw) && (pOldDraw != pDraw))
    {
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);
d709 3
a711 3
  (void) (* pPort->pAdaptor->ddGetVideo)(client, pDraw, pPort, pGC,
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);
d713 3
a715 4
  if ((pPort->pDraw) && (pOldDraw != pDraw))
    {
      pPort->client = client;
      XvdiSendVideoNotify(pPort, pPort->pDraw, XvStarted);
d718 1
a718 1
  pPort->time = currentTime;
d720 1
a720 1
  return Success;
d725 9
a733 11
XvdiGetStill(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  int status;
d735 1
a735 1
  CHECK_SIZE(drw_w, drw_h, vid_w, vid_h);
d737 1
a737 1
  /* UPDATE TIME VARIABLES FOR USE IN EVENTS */
d739 1
a739 1
  UpdateCurrentTime();
d741 2
a742 2
  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */
d744 3
a746 4
  if (pPort->grab.client && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
d749 3
a751 3
  status = (* pPort->pAdaptor->ddGetStill)(client, pDraw, pPort, pGC, 
					   vid_x, vid_y, vid_w, vid_h, 
					   drw_x, drw_y, drw_w, drw_h);
d753 1
a753 1
  pPort->time = currentTime;
d755 1
a755 1
  return status;
d760 4
a763 8
XvdiGrabPort(
   ClientPtr client,
   XvPortPtr pPort,
   Time ctime,
   int *p_result
){
  unsigned long id;
  TimeStamp time;
d765 2
a766 2
  UpdateCurrentTime();
  time = ClientTimeToServerTime(ctime);
d768 3
a770 4
  if (pPort->grab.client && (client != pPort->grab.client))
    {
      *p_result = XvAlreadyGrabbed;
      return Success;
d773 4
a776 5
  if ((CompareTimeStamps(time, currentTime) == LATER) ||
      (CompareTimeStamps(time, pPort->time) == EARLIER))
    {
      *p_result = XvInvalidTime;
      return Success;
d779 3
a781 4
  if (client == pPort->grab.client)
    {
      *p_result = Success;
      return Success;
d784 1
a784 1
  id = FakeClientID(client->index);
d786 2
a787 3
  if (!AddResource(id, XvRTGrab, &pPort->grab))
    {
      return BadAlloc;
d790 1
a790 1
  /* IF THERE IS ACTIVE VIDEO THEN STOP IT */
d792 2
a793 3
  if ((pPort->pDraw) && (client != pPort->client))
    {
      XvdiStopVideo(NULL, pPort, pPort->pDraw);
d796 2
a797 2
  pPort->grab.client = client;
  pPort->grab.id = id;
d799 1
a799 1
  pPort->time = currentTime;
d801 1
a801 1
  *p_result = Success;
d803 1
a803 1
  return Success;
d808 3
a810 6
XvdiUngrabPort(
  ClientPtr client,
  XvPortPtr pPort,
  Time ctime
){
  TimeStamp time;
d812 2
a813 2
  UpdateCurrentTime();
  time = ClientTimeToServerTime(ctime);
d815 2
a816 3
  if ((!pPort->grab.client) || (client != pPort->grab.client))
    {
      return Success;
d819 3
a821 4
  if ((CompareTimeStamps(time, currentTime) == LATER) ||
      (CompareTimeStamps(time, pPort->time) == EARLIER))
    {
      return Success;
d824 1
a824 1
  /* FREE THE GRAB RESOURCE; AND SET THE GRAB CLIENT TO NULL */
d826 2
a827 2
  FreeResource(pPort->grab.id, XvRTGrab);
  pPort->grab.client = NULL;
d829 1
a829 1
  pPort->time = currentTime;
d831 1
a831 1
  return Success;
d835 50
d886 19
a904 76
int
XvdiSelectVideoNotify(
  ClientPtr client,
  DrawablePtr pDraw,
  BOOL onoff
){
  XvVideoNotifyPtr pn,tpn,fpn;
  int rc;

  /* FIND VideoNotify LIST */

  rc = dixLookupResourceByType((pointer *)&pn, pDraw->id, XvRTVideoNotifyList,
			       client, DixWriteAccess);
  if (rc != Success && rc != BadValue)
      return rc;

  /* IF ONE DONES'T EXIST AND NO MASK, THEN JUST RETURN */

  if (!onoff && !pn) return Success;

  /* IF ONE DOESN'T EXIST CREATE IT AND ADD A RESOURCE SO THAT THE LIST
     WILL BE DELETED WHEN THE DRAWABLE IS DESTROYED */

  if (!pn) 
    {
      if (!(tpn = malloc(sizeof(XvVideoNotifyRec))))
	return BadAlloc;
      tpn->next = NULL;
      if (!AddResource(pDraw->id, XvRTVideoNotifyList, tpn))
	{
	  free(tpn);
	  return BadAlloc;
	}
    }
  else
    {
      /* LOOK TO SEE IF ENTRY ALREADY EXISTS */

      fpn = NULL;
      tpn = pn;
      while (tpn)
	{
	  if (tpn->client == client) 
	    {
	      if (!onoff) tpn->client = NULL;
	      return Success;
	    }
	  if (!tpn->client) fpn = tpn; /* TAKE NOTE OF FREE ENTRY */
	  tpn = tpn->next;
	}

      /* IF TUNNING OFF, THEN JUST RETURN */

      if (!onoff) return Success;

      /* IF ONE ISN'T FOUND THEN ALLOCATE ONE AND LINK IT INTO THE LIST */

      if (fpn)
	{
	  tpn = fpn;
	}
      else
	{
	  if (!(tpn = malloc(sizeof(XvVideoNotifyRec))))
	    return BadAlloc;
	  tpn->next = pn->next;
	  pn->next = tpn;
	}
    }

  /* INIT CLIENT PTR IN CASE WE CAN'T ADD RESOURCE */
  /* ADD RESOURCE SO THAT IF CLIENT EXITS THE CLIENT PTR WILL BE CLEARED */

  tpn->client = NULL;
  tpn->id = FakeClientID(client->index);
  AddResource(tpn->id, XvRTVideoNotify, tpn);
d906 2
a907 2
  tpn->client = client;
  return Success;
d912 3
a914 6
XvdiSelectPortNotify(
   ClientPtr client,
   XvPortPtr pPort,
   BOOL onoff
){
  XvPortNotifyPtr pn,tpn;
d916 1
a916 1
  /* SEE IF CLIENT IS ALREADY IN LIST */
d918 8
a925 7
  tpn = NULL;
  pn = pPort->pNotify;
  while (pn)
    {
      if (!pn->client) tpn = pn; /* TAKE NOTE OF FREE ENTRY */
      if (pn->client == client) break;
      pn = pn->next;
d928 1
a928 1
  /* IS THE CLIENT ALREADY ON THE LIST? */
d930 2
a931 3
  if (pn)
    {
      /* REMOVE IT? */
d933 4
a936 5
      if (!onoff)
	{
	  pn->client = NULL;
	  FreeResource(pn->id, XvRTPortNotify);
	}
d938 1
a938 1
      return Success;
d941 2
a942 2
  /* DIDN'T FIND IT; SO REUSE LIST ELEMENT IF ONE IS FREE OTHERWISE 
     CREATE A NEW ONE AND ADD IT TO THE BEGINNING OF THE LIST */
d944 5
a948 6
  if (!tpn)
    {
      if (!(tpn = malloc(sizeof(XvPortNotifyRec))))
	return BadAlloc;
      tpn->next = pPort->pNotify;
      pPort->pNotify = tpn;
d951 3
a953 3
  tpn->client = client;
  tpn->id = FakeClientID(client->index);
  AddResource(tpn->id, XvRTPortNotify, tpn);
d955 1
a955 1
  return Success;
d960 3
a962 6
XvdiStopVideo(
  ClientPtr client,
  XvPortPtr pPort,
  DrawablePtr pDraw
){
  int status;
d964 1
a964 1
  /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */
d966 3
a968 4
  if (!pPort->pDraw || (pPort->pDraw != pDraw)) 
    {
      XvdiSendVideoNotify(pPort, pDraw, XvStopped);
      return Success;
d971 2
a972 2
  /* CHECK FOR GRAB; IF THIS CLIENT DOESN'T HAVE THE PORT GRABBED THEN
     INFORM CLIENT OF ITS FAILURE */
d974 3
a976 4
  if ((client) && (pPort->grab.client) && (pPort->grab.client != client))
    {
      XvdiSendVideoNotify(pPort, pDraw, XvBusy);
      return Success;
d979 1
a979 1
  XvdiSendVideoNotify(pPort, pDraw, XvStopped);
d981 1
a981 1
  status = (* pPort->pAdaptor->ddStopVideo)(client, pPort, pDraw);
d983 3
a985 3
  pPort->pDraw = NULL;
  pPort->client = (ClientPtr)client;
  pPort->time = currentTime;
d987 1
a987 1
  return status;
d992 3
a994 6
XvdiPreemptVideo(
  ClientPtr client,
  XvPortPtr pPort,
  DrawablePtr pDraw
){
  int status;
d996 1
a996 1
  /* IF PORT ISN'T ACTIVE THEN WE'RE DONE */
d998 2
a999 1
  if (!pPort->pDraw || (pPort->pDraw != pDraw)) return Success;
d1001 1
a1001 1
  XvdiSendVideoNotify(pPort, pPort->pDraw, XvPreempted);
d1003 1
a1003 1
  status = (* pPort->pAdaptor->ddStopVideo)(client, pPort, pPort->pDraw);
d1005 3
a1007 3
  pPort->pDraw = NULL;
  pPort->client = (ClientPtr)client;
  pPort->time = currentTime;
d1009 1
a1009 1
  return status;
d1014 2
a1015 4
XvdiMatchPort(
  XvPortPtr pPort,
  DrawablePtr pDraw
){
d1017 3
a1019 3
  XvAdaptorPtr pa;
  XvFormatPtr pf;
  int nf;
d1021 1
a1021 1
  pa = pPort->pAdaptor;
d1023 2
a1024 1
  if (pa->pScreen != pDraw->pScreen) return BadMatch;
d1026 2
a1027 2
  nf = pa->nFormats;
  pf = pa->pFormats;
d1029 4
a1032 5
  while (nf--)
    {
      if (pf->depth == pDraw->depth)
	return Success;
      pf++;
d1035 1
a1035 1
  return BadMatch;
d1040 4
a1043 11
XvdiSetPortAttribute(
  ClientPtr client,
  XvPortPtr pPort,
  Atom attribute,
  INT32 value
){
  int status;

  status = (* pPort->pAdaptor->ddSetPortAttribute)(client, pPort, attribute, value);
  if (status == Success)
    XvdiSendPortNotify(pPort, attribute, value);
d1045 7
a1051 1
  return status;
d1055 3
a1057 6
XvdiGetPortAttribute(
  ClientPtr client,
  XvPortPtr pPort,
  Atom attribute,
  INT32 *p_value
){
d1059 3
a1061 2
  return 
    (* pPort->pAdaptor->ddGetPortAttribute)(client, pPort, attribute, p_value);
d1066 1
a1066 2
WriteSwappedVideoNotifyEvent(xvEvent *from, xvEvent *to)

d1069 7
a1075 7
  to->u.u.type = from->u.u.type;
  to->u.u.detail = from->u.u.detail;
  cpswaps(from->u.videoNotify.sequenceNumber, 
	  to->u.videoNotify.sequenceNumber);
  cpswapl(from->u.videoNotify.time, to->u.videoNotify.time);
  cpswapl(from->u.videoNotify.drawable, to->u.videoNotify.drawable);
  cpswapl(from->u.videoNotify.port, to->u.videoNotify.port);
d1080 1
a1080 2
WriteSwappedPortNotifyEvent(xvEvent *from, xvEvent *to)

d1083 6
a1088 6
  to->u.u.type = from->u.u.type;
  to->u.u.detail = from->u.u.detail;
  cpswaps(from->u.portNotify.sequenceNumber, to->u.portNotify.sequenceNumber);
  cpswapl(from->u.portNotify.time, to->u.portNotify.time);
  cpswapl(from->u.portNotify.port, to->u.portNotify.port);
  cpswapl(from->u.portNotify.value, to->u.portNotify.value);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d118 6
a123 8
unsigned long XvRTPort;
unsigned long XvRTEncoding;
unsigned long XvRTGrab;
unsigned long XvRTVideoNotify;
unsigned long XvRTVideoNotifyList;
unsigned long XvRTPortNotify;


d1113 1
a1113 6
      if ((pf->depth == pDraw->depth) 
#if 0
         && ((pDraw->type == DRAWABLE_PIXMAP) || 
	   (wVisual(((WindowPtr)pDraw)) == pf->visual))
#endif
	)
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d108 2
a109 2
static int XvScreenKeyIndex;
static DevPrivateKey XvScreenKey = &XvScreenKeyIndex;
a128 2
extern XID clientErrorValue;

d159 3
d198 1
d275 3
d285 1
a285 1
  pxvs = xalloc (sizeof (XvScreenRec));
a292 1

d321 1
a321 1
  xfree(pxvs);
d516 1
a516 1
      xfree(cpn);
d539 6
a544 11
      if (pn->client)
	{
	  event.u.u.type = XvEventBase + XvVideoNotify;
	  event.u.u.sequenceNumber = pn->client->sequence;
	  event.u.videoNotify.time = currentTime.milliseconds;
	  event.u.videoNotify.drawable = pDraw->id;
	  event.u.videoNotify.port = pPort->id;
	  event.u.videoNotify.reason = reason;
	  TryClientEvents(pn->client, NULL, (xEventPtr)&event, 1,
                          NoEventMask, NoEventMask, NullGrab);
	}
d566 6
a571 11
      if (pn->client)
	{
	  event.u.u.type = XvEventBase + XvPortNotify;
	  event.u.u.sequenceNumber = pn->client->sequence;
	  event.u.portNotify.time = currentTime.milliseconds;
	  event.u.portNotify.port = pPort->id;
	  event.u.portNotify.attribute = attribute;
	  event.u.portNotify.value = value;
	  TryClientEvents(pn->client, NULL, (xEventPtr)&event, 1,
                          NoEventMask, NoEventMask, NullGrab);
	}
d637 1
a637 1
  return (Success);
d767 1
a767 1
  return (Success);
d925 1
a925 1
      if (!(tpn = xalloc(sizeof(XvVideoNotifyRec))))
d930 1
a930 1
	  xfree(tpn);
d963 1
a963 1
	  if (!(tpn = xalloc(sizeof(XvVideoNotifyRec))))
d1021 1
a1021 1
      if (!(tpn = xalloc(sizeof(XvPortNotifyRec))))
d1136 1
d1138 2
d1142 1
a1142 3
  return 
    (* pPort->pAdaptor->ddSetPortAttribute)(client, pPort, attribute, value);

@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d156 1
a156 1
void 
d211 1
a211 1
  if (!(XvRTPort = CreateNewResourceType(XvdiDestroyPort)))
d216 2
a217 2
  
  if (!(XvRTGrab = CreateNewResourceType(XvdiDestroyGrab)))
d222 3
a224 2
  
  if (!(XvRTEncoding = CreateNewResourceType(XvdiDestroyEncoding)))
d229 3
a231 2
  
  if (!(XvRTVideoNotify = CreateNewResourceType(XvdiDestroyVideoNotify)))
d236 3
a238 2
  
  if (!(XvRTVideoNotifyList = CreateNewResourceType(XvdiDestroyVideoNotifyList)))
d244 2
a245 1
  if (!(XvRTPortNotify = CreateNewResourceType(XvdiDestroyPortNotify)))
d255 1
a255 1
_X_EXPORT int
d280 1
a280 1
  pxvs = (XvScreenPtr) xalloc (sizeof (XvScreenRec));
d330 1
a330 1
_X_EXPORT DevPrivateKey
d336 1
a336 1
_X_EXPORT unsigned long
d374 1
a374 2
	      (void)(* pp->pAdaptor->ddStopVideo)((ClientPtr)NULL, pp, 
						  pp->pDraw);
d376 2
a377 2
	      pp->pDraw = (DrawablePtr)NULL;
	      pp->client = (ClientPtr)NULL;
d425 1
a425 2
	      (void)(* pp->pAdaptor->ddStopVideo)((ClientPtr)NULL, pp, 
						  pp->pDraw);
d427 2
a428 2
	      pp->pDraw = (DrawablePtr)NULL;
	      pp->client = (ClientPtr)NULL;
d460 2
a461 2
  pPort->pDraw = (DrawablePtr)NULL;
  pPort->client = (ClientPtr)NULL;
d477 1
a477 1
  ((XvGrabPtr)pGrab)->client = (ClientPtr)NULL;
d486 1
a486 1
  ((XvVideoNotifyPtr)pn)->client = (ClientPtr)NULL;
d495 1
a495 1
  ((XvPortNotifyPtr)pn)->client = (ClientPtr)NULL;
d525 1
a525 6
XvdiSendVideoNotify(pPort, pDraw, reason)

XvPortPtr pPort;
DrawablePtr pDraw;
int reason;

d530 2
a531 1
  pn = (XvVideoNotifyPtr)LookupIDByType(pDraw->id, XvRTVideoNotifyList);
d858 1
a858 1
      XVCALL(diStopVideo)((ClientPtr)NULL, pPort, pPort->pDraw);
d897 1
a897 1
  pPort->grab.client = (ClientPtr)NULL;
d913 1
d917 4
a920 1
  pn = (XvVideoNotifyPtr)LookupIDByType(pDraw->id, XvRTVideoNotifyList);
d931 1
a931 1
      if (!(tpn = (XvVideoNotifyPtr)xalloc(sizeof(XvVideoNotifyRec))))
d933 1
a933 1
      tpn->next = (XvVideoNotifyPtr)NULL;
d944 1
a944 1
      fpn = (XvVideoNotifyPtr)NULL;
d950 1
a950 1
	      if (!onoff) tpn->client = (ClientPtr)NULL;
d969 1
a969 1
	  if (!(tpn = (XvVideoNotifyPtr)xalloc(sizeof(XvVideoNotifyRec))))
d979 1
a979 1
  tpn->client = (ClientPtr)NULL;
d998 1
a998 1
  tpn = (XvPortNotifyPtr)NULL;
d1015 1
a1015 1
	  pn->client = (ClientPtr)NULL;
d1027 1
a1027 1
      if (!(tpn = (XvPortNotifyPtr)xalloc(sizeof(XvPortNotifyRec))))
d1070 1
a1070 1
  pPort->pDraw = (DrawablePtr)NULL;
d1094 1
a1094 1
  pPort->pDraw = (DrawablePtr)NULL;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d108 2
a109 1
static DevPrivateKey XvScreenKey = &XvScreenKey;
d545 2
a546 2
	  (void) TryClientEvents(pn->client, (xEventPtr)&event, 1, NoEventMask,
				 NoEventMask, NullGrab);
d577 2
a578 2
	  (void) TryClientEvents(pn->client, (xEventPtr)&event, 1, NoEventMask,
				 NoEventMask, NullGrab);
@


1.1
log
@Initial revision
@
text
@d105 1
a106 1
#endif
d108 1
a108 1
int  XvScreenIndex = -1;
d156 1
a156 1
XvExtensionInit()
a168 6
      XvScreenIndex = AllocateScreenPrivateIndex ();
      if (XvScreenIndex < 0)
	{
	  ErrorF("XvExtensionInit: Unable to allocate screen private index\n");
	  return;
	}
d202 1
a202 1
CreateResourceTypes()
a261 6
      XvScreenIndex = AllocateScreenPrivateIndex ();
      if (XvScreenIndex < 0)
	{
	  ErrorF("XvScreenInit: Unable to allocate screen private index\n");
	  return BadAlloc;
	}
d268 1
a268 1
  if (pScreen->devPrivates[XvScreenIndex].ptr)
d282 1
a282 1
  pScreen->devPrivates[XvScreenIndex].ptr = (pointer)pxvs;
d304 1
a304 1
  pxvs = (XvScreenPtr) pScreen->devPrivates[XvScreenIndex].ptr;
d314 1
a314 1
  pScreen->devPrivates[XvScreenIndex].ptr = (pointer)NULL;
a316 1

d322 1
d325 2
a326 2
_X_EXPORT int
XvGetScreenIndex()
d328 1
a328 1
  return XvScreenIndex;
d332 1
a332 1
XvGetRTPort()
d352 1
a352 1
  pxvs = (XvScreenPtr)pScreen->devPrivates[XvScreenIndex].ptr;
d404 1
a404 1
  pxvs = (XvScreenPtr)pScreen->devPrivates[XvScreenIndex].ptr;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d156 1
a156 1
XvExtensionInit(void)
d208 1
a208 1
CreateResourceTypes(void)
d338 1
a338 1
XvGetScreenIndex(void)
d344 1
a344 1
XvGetRTPort(void)
@

