head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.2
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	s0SI41sEunLdyFfd;

1.11
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	Te1daavkBLskZ8gc;

1.10
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2014.05.02.19.27.46;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.19;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.54;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.54;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.51;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*****************************************************************
Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.
******************************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifdef HAVE_DMX_CONFIG_H
#include <dmx-config.h>
#endif

#include <stdio.h>
#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xarch.h>
#include "misc.h"
#include "cursor.h"
#include "cursorstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "gc.h"
#include "gcstruct.h"
#include "scrnintstr.h"
#include "window.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "panoramiX.h"
#include <X11/extensions/panoramiXproto.h>
#include "panoramiXsrv.h"
#include "globals.h"
#include "servermd.h"
#include "resource.h"
#include "picturestr.h"
#include "xfixesint.h"
#include "damageextint.h"
#ifdef COMPOSITE
#include "compint.h"
#endif
#include "extinit.h"
#include "protocol-versions.h"

#ifdef GLXPROXY
extern VisualPtr glxMatchVisual(ScreenPtr pScreen,
                                VisualPtr pVisual, ScreenPtr pMatchScreen);
#endif

/*
 *	PanoramiX data declarations
 */

int PanoramiXPixWidth = 0;
int PanoramiXPixHeight = 0;
int PanoramiXNumScreens = 0;

_X_EXPORT RegionRec PanoramiXScreenRegion = { {0, 0, 0, 0}, NULL };

static int PanoramiXNumDepths;
static DepthPtr PanoramiXDepths;
static int PanoramiXNumVisuals;
static VisualPtr PanoramiXVisuals;

RESTYPE XRC_DRAWABLE;
RESTYPE XRT_WINDOW;
RESTYPE XRT_PIXMAP;
RESTYPE XRT_GC;
RESTYPE XRT_COLORMAP;

static Bool VisualsEqual(VisualPtr, ScreenPtr, VisualPtr);
XineramaVisualsEqualProcPtr XineramaVisualsEqualPtr = &VisualsEqual;

/*
 *	Function prototypes
 */

static int panoramiXGeneration;
static int ProcPanoramiXDispatch(ClientPtr client);

static void PanoramiXResetProc(ExtensionEntry *);

/*
 *	External references for functions and data variables
 */

#include "panoramiXh.h"

int (*SavedProcVector[256]) (ClientPtr client) = {
NULL,};

static DevPrivateKeyRec PanoramiXGCKeyRec;

#define PanoramiXGCKey (&PanoramiXGCKeyRec)
static DevPrivateKeyRec PanoramiXScreenKeyRec;

#define PanoramiXScreenKey (&PanoramiXScreenKeyRec)

typedef struct {
    DDXPointRec clipOrg;
    DDXPointRec patOrg;
    const GCFuncs *wrapFuncs;
} PanoramiXGCRec, *PanoramiXGCPtr;

typedef struct {
    CreateGCProcPtr CreateGC;
    CloseScreenProcPtr CloseScreen;
} PanoramiXScreenRec, *PanoramiXScreenPtr;

static void XineramaValidateGC(GCPtr, unsigned long, DrawablePtr);
static void XineramaChangeGC(GCPtr, unsigned long);
static void XineramaCopyGC(GCPtr, unsigned long, GCPtr);
static void XineramaDestroyGC(GCPtr);
static void XineramaChangeClip(GCPtr, int, void *, int);
static void XineramaDestroyClip(GCPtr);
static void XineramaCopyClip(GCPtr, GCPtr);

static const GCFuncs XineramaGCFuncs = {
    XineramaValidateGC, XineramaChangeGC, XineramaCopyGC, XineramaDestroyGC,
    XineramaChangeClip, XineramaDestroyClip, XineramaCopyClip
};

#define Xinerama_GC_FUNC_PROLOGUE(pGC)\
    PanoramiXGCPtr  pGCPriv = (PanoramiXGCPtr) \
	dixLookupPrivate(&(pGC)->devPrivates, PanoramiXGCKey); \
    (pGC)->funcs = pGCPriv->wrapFuncs;

#define Xinerama_GC_FUNC_EPILOGUE(pGC)\
    pGCPriv->wrapFuncs = (pGC)->funcs;\
    (pGC)->funcs = &XineramaGCFuncs;

static Bool
XineramaCloseScreen(ScreenPtr pScreen)
{
    PanoramiXScreenPtr pScreenPriv = (PanoramiXScreenPtr)
        dixLookupPrivate(&pScreen->devPrivates, PanoramiXScreenKey);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;
    pScreen->CreateGC = pScreenPriv->CreateGC;

    if (pScreen->myNum == 0)
        RegionUninit(&PanoramiXScreenRegion);

    free(pScreenPriv);

    return (*pScreen->CloseScreen) (pScreen);
}

static Bool
XineramaCreateGC(GCPtr pGC)
{
    ScreenPtr pScreen = pGC->pScreen;
    PanoramiXScreenPtr pScreenPriv = (PanoramiXScreenPtr)
        dixLookupPrivate(&pScreen->devPrivates, PanoramiXScreenKey);
    Bool ret;

    pScreen->CreateGC = pScreenPriv->CreateGC;
    if ((ret = (*pScreen->CreateGC) (pGC))) {
        PanoramiXGCPtr pGCPriv = (PanoramiXGCPtr)
            dixLookupPrivate(&pGC->devPrivates, PanoramiXGCKey);

        pGCPriv->wrapFuncs = pGC->funcs;
        pGC->funcs = &XineramaGCFuncs;

        pGCPriv->clipOrg.x = pGC->clipOrg.x;
        pGCPriv->clipOrg.y = pGC->clipOrg.y;
        pGCPriv->patOrg.x = pGC->patOrg.x;
        pGCPriv->patOrg.y = pGC->patOrg.y;
    }
    pScreen->CreateGC = XineramaCreateGC;

    return ret;
}

static void
XineramaValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDraw)
{
    Xinerama_GC_FUNC_PROLOGUE(pGC);

    if ((pDraw->type == DRAWABLE_WINDOW) && !(((WindowPtr) pDraw)->parent)) {
        /* the root window */
        int x_off = pGC->pScreen->x;
        int y_off = pGC->pScreen->y;
        int new_val;

        new_val = pGCPriv->clipOrg.x - x_off;
        if (pGC->clipOrg.x != new_val) {
            pGC->clipOrg.x = new_val;
            changes |= GCClipXOrigin;
        }
        new_val = pGCPriv->clipOrg.y - y_off;
        if (pGC->clipOrg.y != new_val) {
            pGC->clipOrg.y = new_val;
            changes |= GCClipYOrigin;
        }
        new_val = pGCPriv->patOrg.x - x_off;
        if (pGC->patOrg.x != new_val) {
            pGC->patOrg.x = new_val;
            changes |= GCTileStipXOrigin;
        }
        new_val = pGCPriv->patOrg.y - y_off;
        if (pGC->patOrg.y != new_val) {
            pGC->patOrg.y = new_val;
            changes |= GCTileStipYOrigin;
        }
    }
    else {
        if (pGC->clipOrg.x != pGCPriv->clipOrg.x) {
            pGC->clipOrg.x = pGCPriv->clipOrg.x;
            changes |= GCClipXOrigin;
        }
        if (pGC->clipOrg.y != pGCPriv->clipOrg.y) {
            pGC->clipOrg.y = pGCPriv->clipOrg.y;
            changes |= GCClipYOrigin;
        }
        if (pGC->patOrg.x != pGCPriv->patOrg.x) {
            pGC->patOrg.x = pGCPriv->patOrg.x;
            changes |= GCTileStipXOrigin;
        }
        if (pGC->patOrg.y != pGCPriv->patOrg.y) {
            pGC->patOrg.y = pGCPriv->patOrg.y;
            changes |= GCTileStipYOrigin;
        }
    }

    (*pGC->funcs->ValidateGC) (pGC, changes, pDraw);
    Xinerama_GC_FUNC_EPILOGUE(pGC);
}

static void
XineramaDestroyGC(GCPtr pGC)
{
    Xinerama_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->DestroyGC) (pGC);
    Xinerama_GC_FUNC_EPILOGUE(pGC);
}

static void
XineramaChangeGC(GCPtr pGC, unsigned long mask)
{
    Xinerama_GC_FUNC_PROLOGUE(pGC);

    if (mask & GCTileStipXOrigin)
        pGCPriv->patOrg.x = pGC->patOrg.x;
    if (mask & GCTileStipYOrigin)
        pGCPriv->patOrg.y = pGC->patOrg.y;
    if (mask & GCClipXOrigin)
        pGCPriv->clipOrg.x = pGC->clipOrg.x;
    if (mask & GCClipYOrigin)
        pGCPriv->clipOrg.y = pGC->clipOrg.y;

    (*pGC->funcs->ChangeGC) (pGC, mask);
    Xinerama_GC_FUNC_EPILOGUE(pGC);
}

static void
XineramaCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
{
    PanoramiXGCPtr pSrcPriv = (PanoramiXGCPtr)
        dixLookupPrivate(&pGCSrc->devPrivates, PanoramiXGCKey);

    Xinerama_GC_FUNC_PROLOGUE(pGCDst);

    if (mask & GCTileStipXOrigin)
        pGCPriv->patOrg.x = pSrcPriv->patOrg.x;
    if (mask & GCTileStipYOrigin)
        pGCPriv->patOrg.y = pSrcPriv->patOrg.y;
    if (mask & GCClipXOrigin)
        pGCPriv->clipOrg.x = pSrcPriv->clipOrg.x;
    if (mask & GCClipYOrigin)
        pGCPriv->clipOrg.y = pSrcPriv->clipOrg.y;

    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
    Xinerama_GC_FUNC_EPILOGUE(pGCDst);
}

static void
XineramaChangeClip(GCPtr pGC, int type, void *pvalue, int nrects)
{
    Xinerama_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
    Xinerama_GC_FUNC_EPILOGUE(pGC);
}

static void
XineramaCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    Xinerama_GC_FUNC_PROLOGUE(pgcDst);
    (*pgcDst->funcs->CopyClip) (pgcDst, pgcSrc);
    Xinerama_GC_FUNC_EPILOGUE(pgcDst);
}

static void
XineramaDestroyClip(GCPtr pGC)
{
    Xinerama_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->DestroyClip) (pGC);
    Xinerama_GC_FUNC_EPILOGUE(pGC);
}

int
XineramaDeleteResource(void *data, XID id)
{
    free(data);
    return 1;
}

typedef struct {
    int screen;
    int id;
} PanoramiXSearchData;

static Bool
XineramaFindIDByScrnum(void *resource, XID id, void *privdata)
{
    PanoramiXRes *res = (PanoramiXRes *) resource;
    PanoramiXSearchData *data = (PanoramiXSearchData *) privdata;

    return res->info[data->screen].id == data->id;
}

PanoramiXRes *
PanoramiXFindIDByScrnum(RESTYPE type, XID id, int screen)
{
    PanoramiXSearchData data;
    void *val;

    if (!screen) {
        dixLookupResourceByType(&val, id, type, serverClient, DixReadAccess);
        return val;
    }

    data.screen = screen;
    data.id = id;

    return LookupClientResourceComplex(clients[CLIENT_ID(id)], type,
                                       XineramaFindIDByScrnum, &data);
}

typedef struct _connect_callback_list {
    void (*func) (void);
    struct _connect_callback_list *next;
} XineramaConnectionCallbackList;

static XineramaConnectionCallbackList *ConnectionCallbackList = NULL;

Bool
XineramaRegisterConnectionBlockCallback(void (*func) (void))
{
    XineramaConnectionCallbackList *newlist;

    if (!(newlist = malloc(sizeof(XineramaConnectionCallbackList))))
        return FALSE;

    newlist->next = ConnectionCallbackList;
    newlist->func = func;
    ConnectionCallbackList = newlist;

    return TRUE;
}

static void
XineramaInitData(void)
{
    int i, w, h;

    RegionNull(&PanoramiXScreenRegion);
    FOR_NSCREENS(i) {
        BoxRec TheBox;
        RegionRec ScreenRegion;

        ScreenPtr pScreen = screenInfo.screens[i];

        TheBox.x1 = pScreen->x;
        TheBox.x2 = TheBox.x1 + pScreen->width;
        TheBox.y1 = pScreen->y;
        TheBox.y2 = TheBox.y1 + pScreen->height;

        RegionInit(&ScreenRegion, &TheBox, 1);
        RegionUnion(&PanoramiXScreenRegion, &PanoramiXScreenRegion,
                    &ScreenRegion);
        RegionUninit(&ScreenRegion);
    }

    PanoramiXPixWidth = screenInfo.screens[0]->x + screenInfo.screens[0]->width;
    PanoramiXPixHeight =
        screenInfo.screens[0]->y + screenInfo.screens[0]->height;

    FOR_NSCREENS_FORWARD_SKIP(i) {
        ScreenPtr pScreen = screenInfo.screens[i];

        w = pScreen->x + pScreen->width;
        h = pScreen->y + pScreen->height;

        if (PanoramiXPixWidth < w)
            PanoramiXPixWidth = w;
        if (PanoramiXPixHeight < h)
            PanoramiXPixHeight = h;
    }
}

void
XineramaReinitData(void)
{
    RegionUninit(&PanoramiXScreenRegion);
    XineramaInitData();
}

/*
 *	PanoramiXExtensionInit():
 *		Called from InitExtensions in main().
 *		Register PanoramiXeen Extension
 *		Initialize global variables.
 */

void
PanoramiXExtensionInit(void)
{
    int i;
    Bool success = FALSE;
    ExtensionEntry *extEntry;
    ScreenPtr pScreen = screenInfo.screens[0];
    PanoramiXScreenPtr pScreenPriv;

    if (noPanoramiXExtension)
        return;

    if (!dixRegisterPrivateKey(&PanoramiXScreenKeyRec, PRIVATE_SCREEN, 0)) {
        noPanoramiXExtension = TRUE;
        return;
    }

    if (!dixRegisterPrivateKey
        (&PanoramiXGCKeyRec, PRIVATE_GC, sizeof(PanoramiXGCRec))) {
        noPanoramiXExtension = TRUE;
        return;
    }

    PanoramiXNumScreens = screenInfo.numScreens;
    if (PanoramiXNumScreens == 1) {     /* Only 1 screen        */
        noPanoramiXExtension = TRUE;
        return;
    }

    while (panoramiXGeneration != serverGeneration) {
        extEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 0, 0,
                                ProcPanoramiXDispatch,
                                SProcPanoramiXDispatch, PanoramiXResetProc,
                                StandardMinorOpcode);
        if (!extEntry)
            break;

        /*
         *      First make sure all the basic allocations succeed.  If not,
         *      run in non-PanoramiXeen mode.
         */

        FOR_NSCREENS(i) {
            pScreen = screenInfo.screens[i];
            pScreenPriv = malloc(sizeof(PanoramiXScreenRec));
            dixSetPrivate(&pScreen->devPrivates, PanoramiXScreenKey,
                          pScreenPriv);
            if (!pScreenPriv) {
                noPanoramiXExtension = TRUE;
                return;
            }

            pScreenPriv->CreateGC = pScreen->CreateGC;
            pScreenPriv->CloseScreen = pScreen->CloseScreen;

            pScreen->CreateGC = XineramaCreateGC;
            pScreen->CloseScreen = XineramaCloseScreen;
        }

        XRC_DRAWABLE = CreateNewResourceClass();
        XRT_WINDOW = CreateNewResourceType(XineramaDeleteResource,
                                           "XineramaWindow");
        if (XRT_WINDOW)
            XRT_WINDOW |= XRC_DRAWABLE;
        XRT_PIXMAP = CreateNewResourceType(XineramaDeleteResource,
                                           "XineramaPixmap");
        if (XRT_PIXMAP)
            XRT_PIXMAP |= XRC_DRAWABLE;
        XRT_GC = CreateNewResourceType(XineramaDeleteResource, "XineramaGC");
        XRT_COLORMAP = CreateNewResourceType(XineramaDeleteResource,
                                             "XineramaColormap");

        if (XRT_WINDOW && XRT_PIXMAP && XRT_GC && XRT_COLORMAP) {
            panoramiXGeneration = serverGeneration;
            success = TRUE;
        }
        SetResourceTypeErrorValue(XRT_WINDOW, BadWindow);
        SetResourceTypeErrorValue(XRT_PIXMAP, BadPixmap);
        SetResourceTypeErrorValue(XRT_GC, BadGC);
        SetResourceTypeErrorValue(XRT_COLORMAP, BadColor);
    }

    if (!success) {
        noPanoramiXExtension = TRUE;
        ErrorF(PANORAMIX_PROTOCOL_NAME " extension failed to initialize\n");
        return;
    }

    XineramaInitData();

    /*
     *  Put our processes into the ProcVector
     */

    for (i = 256; i--;)
        SavedProcVector[i] = ProcVector[i];

    ProcVector[X_CreateWindow] = PanoramiXCreateWindow;
    ProcVector[X_ChangeWindowAttributes] = PanoramiXChangeWindowAttributes;
    ProcVector[X_DestroyWindow] = PanoramiXDestroyWindow;
    ProcVector[X_DestroySubwindows] = PanoramiXDestroySubwindows;
    ProcVector[X_ChangeSaveSet] = PanoramiXChangeSaveSet;
    ProcVector[X_ReparentWindow] = PanoramiXReparentWindow;
    ProcVector[X_MapWindow] = PanoramiXMapWindow;
    ProcVector[X_MapSubwindows] = PanoramiXMapSubwindows;
    ProcVector[X_UnmapWindow] = PanoramiXUnmapWindow;
    ProcVector[X_UnmapSubwindows] = PanoramiXUnmapSubwindows;
    ProcVector[X_ConfigureWindow] = PanoramiXConfigureWindow;
    ProcVector[X_CirculateWindow] = PanoramiXCirculateWindow;
    ProcVector[X_GetGeometry] = PanoramiXGetGeometry;
    ProcVector[X_TranslateCoords] = PanoramiXTranslateCoords;
    ProcVector[X_CreatePixmap] = PanoramiXCreatePixmap;
    ProcVector[X_FreePixmap] = PanoramiXFreePixmap;
    ProcVector[X_CreateGC] = PanoramiXCreateGC;
    ProcVector[X_ChangeGC] = PanoramiXChangeGC;
    ProcVector[X_CopyGC] = PanoramiXCopyGC;
    ProcVector[X_SetDashes] = PanoramiXSetDashes;
    ProcVector[X_SetClipRectangles] = PanoramiXSetClipRectangles;
    ProcVector[X_FreeGC] = PanoramiXFreeGC;
    ProcVector[X_ClearArea] = PanoramiXClearToBackground;
    ProcVector[X_CopyArea] = PanoramiXCopyArea;
    ProcVector[X_CopyPlane] = PanoramiXCopyPlane;
    ProcVector[X_PolyPoint] = PanoramiXPolyPoint;
    ProcVector[X_PolyLine] = PanoramiXPolyLine;
    ProcVector[X_PolySegment] = PanoramiXPolySegment;
    ProcVector[X_PolyRectangle] = PanoramiXPolyRectangle;
    ProcVector[X_PolyArc] = PanoramiXPolyArc;
    ProcVector[X_FillPoly] = PanoramiXFillPoly;
    ProcVector[X_PolyFillRectangle] = PanoramiXPolyFillRectangle;
    ProcVector[X_PolyFillArc] = PanoramiXPolyFillArc;
    ProcVector[X_PutImage] = PanoramiXPutImage;
    ProcVector[X_GetImage] = PanoramiXGetImage;
    ProcVector[X_PolyText8] = PanoramiXPolyText8;
    ProcVector[X_PolyText16] = PanoramiXPolyText16;
    ProcVector[X_ImageText8] = PanoramiXImageText8;
    ProcVector[X_ImageText16] = PanoramiXImageText16;
    ProcVector[X_CreateColormap] = PanoramiXCreateColormap;
    ProcVector[X_FreeColormap] = PanoramiXFreeColormap;
    ProcVector[X_CopyColormapAndFree] = PanoramiXCopyColormapAndFree;
    ProcVector[X_InstallColormap] = PanoramiXInstallColormap;
    ProcVector[X_UninstallColormap] = PanoramiXUninstallColormap;
    ProcVector[X_AllocColor] = PanoramiXAllocColor;
    ProcVector[X_AllocNamedColor] = PanoramiXAllocNamedColor;
    ProcVector[X_AllocColorCells] = PanoramiXAllocColorCells;
    ProcVector[X_AllocColorPlanes] = PanoramiXAllocColorPlanes;
    ProcVector[X_FreeColors] = PanoramiXFreeColors;
    ProcVector[X_StoreColors] = PanoramiXStoreColors;
    ProcVector[X_StoreNamedColor] = PanoramiXStoreNamedColor;

    PanoramiXRenderInit();
    PanoramiXFixesInit();
    PanoramiXDamageInit();
#ifdef COMPOSITE
    PanoramiXCompositeInit();
#endif

}

Bool
PanoramiXCreateConnectionBlock(void)
{
    int i, j, length;
    Bool disable_backing_store = FALSE;
    int old_width, old_height;
    float width_mult, height_mult;
    xWindowRoot *root;
    xVisualType *visual;
    xDepth *depth;
    VisualPtr pVisual;
    ScreenPtr pScreen;

    /*
     *  Do normal CreateConnectionBlock but faking it for only one screen
     */

    if (!PanoramiXNumDepths) {
        ErrorF("Xinerama error: No common visuals\n");
        return FALSE;
    }

    for (i = 1; i < screenInfo.numScreens; i++) {
        pScreen = screenInfo.screens[i];
        if (pScreen->rootDepth != screenInfo.screens[0]->rootDepth) {
            ErrorF("Xinerama error: Root window depths differ\n");
            return FALSE;
        }
        if (pScreen->backingStoreSupport !=
            screenInfo.screens[0]->backingStoreSupport)
            disable_backing_store = TRUE;
    }

    if (disable_backing_store) {
        for (i = 0; i < screenInfo.numScreens; i++) {
            pScreen = screenInfo.screens[i];
            pScreen->backingStoreSupport = NotUseful;
        }
    }

    i = screenInfo.numScreens;
    screenInfo.numScreens = 1;
    if (!CreateConnectionBlock()) {
        screenInfo.numScreens = i;
        return FALSE;
    }

    screenInfo.numScreens = i;

    root = (xWindowRoot *) (ConnectionInfo + connBlockScreenStart);
    length = connBlockScreenStart + sizeof(xWindowRoot);

    /* overwrite the connection block */
    root->nDepths = PanoramiXNumDepths;

    for (i = 0; i < PanoramiXNumDepths; i++) {
        depth = (xDepth *) (ConnectionInfo + length);
        depth->depth = PanoramiXDepths[i].depth;
        depth->nVisuals = PanoramiXDepths[i].numVids;
        length += sizeof(xDepth);
        visual = (xVisualType *) (ConnectionInfo + length);

        for (j = 0; j < depth->nVisuals; j++, visual++) {
            visual->visualID = PanoramiXDepths[i].vids[j];

            for (pVisual = PanoramiXVisuals;
                 pVisual->vid != visual->visualID; pVisual++);

            visual->class = pVisual->class;
            visual->bitsPerRGB = pVisual->bitsPerRGBValue;
            visual->colormapEntries = pVisual->ColormapEntries;
            visual->redMask = pVisual->redMask;
            visual->greenMask = pVisual->greenMask;
            visual->blueMask = pVisual->blueMask;
        }

        length += (depth->nVisuals * sizeof(xVisualType));
    }

    connSetupPrefix.length = bytes_to_int32(length);

    for (i = 0; i < PanoramiXNumDepths; i++)
        free(PanoramiXDepths[i].vids);
    free(PanoramiXDepths);
    PanoramiXDepths = NULL;

    /*
     *  OK, change some dimensions so it looks as if it were one big screen
     */

    old_width = root->pixWidth;
    old_height = root->pixHeight;

    root->pixWidth = PanoramiXPixWidth;
    root->pixHeight = PanoramiXPixHeight;
    width_mult = (1.0 * root->pixWidth) / old_width;
    height_mult = (1.0 * root->pixHeight) / old_height;
    root->mmWidth *= width_mult;
    root->mmHeight *= height_mult;

    while (ConnectionCallbackList) {
        void *tmp;

        tmp = (void *) ConnectionCallbackList;
        (*ConnectionCallbackList->func) ();
        ConnectionCallbackList = ConnectionCallbackList->next;
        free(tmp);
    }

    return TRUE;
}

/*
 * This isn't just memcmp(), bitsPerRGBValue is skipped.  markv made that
 * change way back before xf86 4.0, but the comment for _why_ is a bit
 * opaque, so I'm not going to question it for now.
 *
 * This is probably better done as a screen hook so DBE/EVI/GLX can add
 * their own tests, and adding privates to VisualRec so they don't have to
 * do their own back-mapping.
 */
static Bool
VisualsEqual(VisualPtr a, ScreenPtr pScreenB, VisualPtr b)
{
    return ((a->class == b->class) &&
            (a->ColormapEntries == b->ColormapEntries) &&
            (a->nplanes == b->nplanes) &&
            (a->redMask == b->redMask) &&
            (a->greenMask == b->greenMask) &&
            (a->blueMask == b->blueMask) &&
            (a->offsetRed == b->offsetRed) &&
            (a->offsetGreen == b->offsetGreen) &&
            (a->offsetBlue == b->offsetBlue));
}

static void
PanoramiXMaybeAddDepth(DepthPtr pDepth)
{
    ScreenPtr pScreen;
    int j, k;
    Bool found = FALSE;

    FOR_NSCREENS_FORWARD_SKIP(j) {
        pScreen = screenInfo.screens[j];
        for (k = 0; k < pScreen->numDepths; k++) {
            if (pScreen->allowedDepths[k].depth == pDepth->depth) {
                found = TRUE;
                break;
            }
        }
    }

    if (!found)
        return;

    j = PanoramiXNumDepths;
    PanoramiXNumDepths++;
    PanoramiXDepths = reallocarray(PanoramiXDepths,
                                   PanoramiXNumDepths, sizeof(DepthRec));
    PanoramiXDepths[j].depth = pDepth->depth;
    PanoramiXDepths[j].numVids = 0;
    /* XXX suboptimal, should grow these dynamically */
    if (pDepth->numVids)
        PanoramiXDepths[j].vids = xallocarray(pDepth->numVids, sizeof(VisualID));
    else
        PanoramiXDepths[j].vids = NULL;
}

static void
PanoramiXMaybeAddVisual(VisualPtr pVisual)
{
    ScreenPtr pScreen;
    int j, k;
    Bool found = FALSE;

    FOR_NSCREENS_FORWARD_SKIP(j) {
        pScreen = screenInfo.screens[j];
        found = FALSE;

        for (k = 0; k < pScreen->numVisuals; k++) {
            VisualPtr candidate = &pScreen->visuals[k];

            if ((*XineramaVisualsEqualPtr) (pVisual, pScreen, candidate)
#ifdef GLXPROXY
                && glxMatchVisual(screenInfo.screens[0], pVisual, pScreen)
#endif
                ) {
                found = TRUE;
                break;
            }
        }

        if (!found)
            return;
    }

    /* found a matching visual on all screens, add it to the subset list */
    j = PanoramiXNumVisuals;
    PanoramiXNumVisuals++;
    PanoramiXVisuals = reallocarray(PanoramiXVisuals,
                                    PanoramiXNumVisuals, sizeof(VisualRec));

    memcpy(&PanoramiXVisuals[j], pVisual, sizeof(VisualRec));

    for (k = 0; k < PanoramiXNumDepths; k++) {
        if (PanoramiXDepths[k].depth == pVisual->nplanes) {
            PanoramiXDepths[k].vids[PanoramiXDepths[k].numVids] = pVisual->vid;
            PanoramiXDepths[k].numVids++;
            break;
        }
    }
}

extern void
PanoramiXConsolidate(void)
{
    int i;
    PanoramiXRes *root, *defmap, *saver;
    ScreenPtr pScreen = screenInfo.screens[0];
    DepthPtr pDepth = pScreen->allowedDepths;
    VisualPtr pVisual = pScreen->visuals;

    PanoramiXNumDepths = 0;
    PanoramiXNumVisuals = 0;

    for (i = 0; i < pScreen->numDepths; i++)
        PanoramiXMaybeAddDepth(pDepth++);

    for (i = 0; i < pScreen->numVisuals; i++)
        PanoramiXMaybeAddVisual(pVisual++);

    root = malloc(sizeof(PanoramiXRes));
    root->type = XRT_WINDOW;
    defmap = malloc(sizeof(PanoramiXRes));
    defmap->type = XRT_COLORMAP;
    saver = malloc(sizeof(PanoramiXRes));
    saver->type = XRT_WINDOW;

    FOR_NSCREENS(i) {
        ScreenPtr scr = screenInfo.screens[i];

        root->info[i].id = scr->root->drawable.id;
        root->u.win.class = InputOutput;
        root->u.win.root = TRUE;
        saver->info[i].id = scr->screensaver.wid;
        saver->u.win.class = InputOutput;
        saver->u.win.root = TRUE;
        defmap->info[i].id = scr->defColormap;
    }

    AddResource(root->info[0].id, XRT_WINDOW, root);
    AddResource(saver->info[0].id, XRT_WINDOW, saver);
    AddResource(defmap->info[0].id, XRT_COLORMAP, defmap);
}

VisualID
PanoramiXTranslateVisualID(int screen, VisualID orig)
{
    ScreenPtr pOtherScreen = screenInfo.screens[screen];
    VisualPtr pVisual = NULL;
    int i;

    for (i = 0; i < PanoramiXNumVisuals; i++) {
        if (orig == PanoramiXVisuals[i].vid) {
            pVisual = &PanoramiXVisuals[i];
            break;
        }
    }

    if (!pVisual)
        return 0;

    /* if screen is 0, orig is already the correct visual ID */
    if (screen == 0)
        return orig;

    /* found the original, now translate it relative to the backend screen */
    for (i = 0; i < pOtherScreen->numVisuals; i++) {
        VisualPtr pOtherVisual = &pOtherScreen->visuals[i];

        if ((*XineramaVisualsEqualPtr) (pVisual, pOtherScreen, pOtherVisual))
            return pOtherVisual->vid;
    }

    return 0;
}

/*
 *	PanoramiXResetProc()
 *		Exit, deallocating as needed.
 */

static void
PanoramiXResetProc(ExtensionEntry * extEntry)
{
    int i;

    PanoramiXRenderReset();
    PanoramiXFixesReset();
    PanoramiXDamageReset();
#ifdef COMPOSITE
    PanoramiXCompositeReset ();
#endif
    screenInfo.numScreens = PanoramiXNumScreens;
    for (i = 256; i--;)
        ProcVector[i] = SavedProcVector[i];
}

int
ProcPanoramiXQueryVersion(ClientPtr client)
{
    /* REQUEST(xPanoramiXQueryVersionReq); */
    xPanoramiXQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = SERVER_PANORAMIX_MAJOR_VERSION,
        .minorVersion = SERVER_PANORAMIX_MINOR_VERSION
    };

    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.majorVersion);
        swaps(&rep.minorVersion);
    }
    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), &rep);
    return Success;
}

int
ProcPanoramiXGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    WindowPtr pWin;
    xPanoramiXGetStateReply rep;
    int rc;

    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep = (xPanoramiXGetStateReply) {
        .type = X_Reply,
        .state = !noPanoramiXExtension,
        .sequenceNumber = client->sequence,
        .length = 0,
        .window = stuff->window
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.window);
    }
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), &rep);
    return Success;

}

int
ProcPanoramiXGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    WindowPtr pWin;
    xPanoramiXGetScreenCountReply rep;
    int rc;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep = (xPanoramiXGetScreenCountReply) {
        .type = X_Reply,
        .ScreenCount = PanoramiXNumScreens,
        .sequenceNumber = client->sequence,
        .length = 0,
        .window = stuff->window
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.window);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), &rep);
    return Success;
}

int
ProcPanoramiXGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    WindowPtr pWin;
    xPanoramiXGetScreenSizeReply rep;
    int rc;

    if (stuff->screen >= PanoramiXNumScreens)
        return BadMatch;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rep = (xPanoramiXGetScreenSizeReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
    /* screen dimensions */
        .width = screenInfo.screens[stuff->screen]->width,
        .height = screenInfo.screens[stuff->screen]->height,
        .window = stuff->window,
        .screen = stuff->screen
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.width);
        swapl(&rep.height);
        swapl(&rep.window);
        swapl(&rep.screen);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), &rep);
    return Success;
}

int
ProcXineramaIsActive(ClientPtr client)
{
    /* REQUEST(xXineramaIsActiveReq); */
    xXineramaIsActiveReply rep;

    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);

    rep = (xXineramaIsActiveReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
#if 1
        /* The following hack fools clients into thinking that Xinerama
         * is disabled even though it is not. */
        .state = !noPanoramiXExtension && !PanoramiXExtensionDisabledHack
#else
        .state = !noPanoramiXExtension;
#endif
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.state);
    }
    WriteToClient(client, sizeof(xXineramaIsActiveReply), &rep);
    return Success;
}

int
ProcXineramaQueryScreens(ClientPtr client)
{
    /* REQUEST(xXineramaQueryScreensReq); */
    CARD32 number = (noPanoramiXExtension) ? 0 : PanoramiXNumScreens;
    xXineramaQueryScreensReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(number * sz_XineramaScreenInfo),
        .number = number
    };

    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.number);
    }
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), &rep);

    if (!noPanoramiXExtension) {
        xXineramaScreenInfo scratch;
        int i;

        FOR_NSCREENS(i) {
            scratch.x_org = screenInfo.screens[i]->x;
            scratch.y_org = screenInfo.screens[i]->y;
            scratch.width = screenInfo.screens[i]->width;
            scratch.height = screenInfo.screens[i]->height;

            if (client->swapped) {
                swaps(&scratch.x_org);
                swaps(&scratch.y_org);
                swaps(&scratch.width);
                swaps(&scratch.height);
            }
            WriteToClient(client, sz_XineramaScreenInfo, &scratch);
        }
    }

    return Success;
}

static int
ProcPanoramiXDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_PanoramiXQueryVersion:
        return ProcPanoramiXQueryVersion(client);
    case X_PanoramiXGetState:
        return ProcPanoramiXGetState(client);
    case X_PanoramiXGetScreenCount:
        return ProcPanoramiXGetScreenCount(client);
    case X_PanoramiXGetScreenSize:
        return ProcPanoramiXGetScreenSize(client);
    case X_XineramaIsActive:
        return ProcXineramaIsActive(client);
    case X_XineramaQueryScreens:
        return ProcXineramaQueryScreens(client);
    }
    return BadRequest;
}

#if X_BYTE_ORDER == X_LITTLE_ENDIAN
#define SHIFT_L(v,s) (v) << (s)
#define SHIFT_R(v,s) (v) >> (s)
#else
#define SHIFT_L(v,s) (v) >> (s)
#define SHIFT_R(v,s) (v) << (s)
#endif

static void
CopyBits(char *dst, int shiftL, char *src, int bytes)
{
    /* Just get it to work.  Worry about speed later */
    int shiftR = 8 - shiftL;

    while (bytes--) {
        *dst |= SHIFT_L(*src, shiftL);
        *(dst + 1) |= SHIFT_R(*src, shiftR);
        dst++;
        src++;
    }
}

/* Caution.  This doesn't support 2 and 4 bpp formats.  We expect
   1 bpp and planar data to be already cleared when presented
   to this function */

void
XineramaGetImageData(DrawablePtr *pDrawables,
                     int left,
                     int top,
                     int width,
                     int height,
                     unsigned int format,
                     unsigned long planemask,
                     char *data, int pitch, Bool isRoot)
{
    RegionRec SrcRegion, ScreenRegion, GrabRegion;
    BoxRec SrcBox, *pbox;
    int x, y, w, h, i, j, nbox, size, sizeNeeded, ScratchPitch, inOut, depth;
    DrawablePtr pDraw = pDrawables[0];
    char *ScratchMem = NULL;

    size = 0;

    /* find box in logical screen space */
    SrcBox.x1 = left;
    SrcBox.y1 = top;
    if (!isRoot) {
        SrcBox.x1 += pDraw->x + screenInfo.screens[0]->x;
        SrcBox.y1 += pDraw->y + screenInfo.screens[0]->y;
    }
    SrcBox.x2 = SrcBox.x1 + width;
    SrcBox.y2 = SrcBox.y1 + height;

    RegionInit(&SrcRegion, &SrcBox, 1);
    RegionNull(&GrabRegion);

    depth = (format == XYPixmap) ? 1 : pDraw->depth;

    FOR_NSCREENS(i) {
        BoxRec TheBox;
        ScreenPtr pScreen;

        pDraw = pDrawables[i];
        pScreen = pDraw->pScreen;

        TheBox.x1 = pScreen->x;
        TheBox.x2 = TheBox.x1 + pScreen->width;
        TheBox.y1 = pScreen->y;
        TheBox.y2 = TheBox.y1 + pScreen->height;

        RegionInit(&ScreenRegion, &TheBox, 1);
        inOut = RegionContainsRect(&ScreenRegion, &SrcBox);
        if (inOut == rgnPART)
            RegionIntersect(&GrabRegion, &SrcRegion, &ScreenRegion);
        RegionUninit(&ScreenRegion);

        if (inOut == rgnIN) {
            (*pScreen->GetImage) (pDraw,
                                  SrcBox.x1 - pDraw->x -
                                  screenInfo.screens[i]->x,
                                  SrcBox.y1 - pDraw->y -
                                  screenInfo.screens[i]->y, width, height,
                                  format, planemask, data);
            break;
        }
        else if (inOut == rgnOUT)
            continue;

        nbox = RegionNumRects(&GrabRegion);

        if (nbox) {
            pbox = RegionRects(&GrabRegion);

            while (nbox--) {
                w = pbox->x2 - pbox->x1;
                h = pbox->y2 - pbox->y1;
                ScratchPitch = PixmapBytePad(w, depth);
                sizeNeeded = ScratchPitch * h;

                if (sizeNeeded > size) {
                    char *tmpdata = ScratchMem;

                    ScratchMem = realloc(ScratchMem, sizeNeeded);
                    if (ScratchMem)
                        size = sizeNeeded;
                    else {
                        ScratchMem = tmpdata;
                        break;
                    }
                }

                x = pbox->x1 - pDraw->x - screenInfo.screens[i]->x;
                y = pbox->y1 - pDraw->y - screenInfo.screens[i]->y;

                (*pScreen->GetImage) (pDraw, x, y, w, h,
                                      format, planemask, ScratchMem);

                /* copy the memory over */

                if (depth == 1) {
                    int k, shift, leftover, index, index2;

                    x = pbox->x1 - SrcBox.x1;
                    y = pbox->y1 - SrcBox.y1;
                    shift = x & 7;
                    x >>= 3;
                    leftover = w & 7;
                    w >>= 3;

                    /* clean up the edge */
                    if (leftover) {
                        int mask = (1 << leftover) - 1;

                        for (j = h, k = w; j--; k += ScratchPitch)
                            ScratchMem[k] &= mask;
                    }

                    for (j = 0, index = (pitch * y) + x, index2 = 0; j < h;
                         j++, index += pitch, index2 += ScratchPitch) {
                        if (w) {
                            if (!shift)
                                memcpy(data + index, ScratchMem + index2, w);
                            else
                                CopyBits(data + index, shift,
                                         ScratchMem + index2, w);
                        }

                        if (leftover) {
                            data[index + w] |=
                                SHIFT_L(ScratchMem[index2 + w], shift);
                            if ((shift + leftover) > 8)
                                data[index + w + 1] |=
                                    SHIFT_R(ScratchMem[index2 + w],
                                            (8 - shift));
                        }
                    }
                }
                else {
                    j = BitsPerPixel(depth) >> 3;
                    x = (pbox->x1 - SrcBox.x1) * j;
                    y = pbox->y1 - SrcBox.y1;
                    w *= j;

                    for (j = 0; j < h; j++) {
                        memcpy(data + (pitch * (y + j)) + x,
                               ScratchMem + (ScratchPitch * j), w);
                    }
                }
                pbox++;
            }

            RegionSubtract(&SrcRegion, &SrcRegion, &GrabRegion);
            if (!RegionNotEmpty(&SrcRegion))
                break;
        }

    }

    free(ScratchMem);

    RegionUninit(&SrcRegion);
    RegionUninit(&GrabRegion);
}
@


1.11
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d750 2
a751 2
    PanoramiXDepths = realloc(PanoramiXDepths,
                              PanoramiXNumDepths * sizeof(DepthRec));
d756 1
a756 1
        PanoramiXDepths[j].vids = malloc(sizeof(VisualID) * pDepth->numVids);
d792 2
a793 2
    PanoramiXVisuals = realloc(PanoramiXVisuals,
                               PanoramiXNumVisuals * sizeof(VisualRec));
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d430 1
a430 1
 *		Called from InitExtensions in main().  
@


1.9
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d121 1
a121 1
    GCFuncs *wrapFuncs;
d133 1
a133 1
static void XineramaChangeClip(GCPtr, int, pointer, int);
d137 1
a137 1
static GCFuncs XineramaGCFuncs = {
d163 1
a163 1
    free((pointer) pScreenPriv);
d297 1
a297 1
XineramaChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects)
d321 1
a321 1
XineramaDeleteResource(pointer data, XID id)
d333 1
a333 1
XineramaFindIDByScrnum(pointer resource, XID id, pointer privdata)
d345 1
a345 1
    pointer val;
d694 1
a694 1
        pointer tmp;
d696 1
a696 1
        tmp = (pointer) ConnectionCallbackList;
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a55 1
#ifdef XFIXES
d57 1
a57 1
#endif
d77 1
a77 1
static RegionRec PanoramiXScreenRegion = { {0, 0, 0, 0}, NULL };
a584 1
#ifdef XFIXES
d586 1
a586 1
#endif
d597 1
a597 1
    Bool disableBackingStore = FALSE;
d623 1
a623 1
            disableBackingStore = TRUE;
d626 1
a626 1
    if (disableBackingStore) {
d832 1
a832 1
        ScreenPtr pScreen = screenInfo.screens[i];
d834 1
a834 1
        root->info[i].id = pScreen->root->drawable.id;
d837 1
a837 1
        saver->info[i].id = pScreen->screensaver.wid;
d840 1
a840 1
        defmap->info[i].id = pScreen->defColormap;
a890 1
#ifdef XFIXES
d892 1
a892 1
#endif
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d62 1
a62 1
#include "modinit.h"
d153 1
a153 1
XineramaCloseScreen(int i, ScreenPtr pScreen)
d166 1
a166 1
    return (*pScreen->CloseScreen) (i, pScreen);
d437 1
a437 1
PanoramiXExtensionInit(int argc, char *argv[])
a594 2
extern Bool CreateConnectionBlock(void);

d896 3
d908 7
a914 1
    xPanoramiXQueryVersionReply rep;
a916 5
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_PANORAMIX_MAJOR_VERSION;
    rep.minorVersion = SERVER_PANORAMIX_MINOR_VERSION;
d923 1
a923 1
    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *) &rep);
d940 7
a946 5
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !noPanoramiXExtension;
    rep.window = stuff->window;
d952 1
a952 1
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *) &rep);
d970 7
a976 5
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.ScreenCount = PanoramiXNumScreens;
    rep.window = stuff->window;
d982 1
a982 1
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *) &rep);
d1002 4
a1005 3
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d1007 5
a1011 4
    rep.width = screenInfo.screens[stuff->screen]->width;
    rep.height = screenInfo.screens[stuff->screen]->height;
    rep.window = stuff->window;
    rep.screen = stuff->screen;
d1020 1
a1020 1
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *) &rep);
d1032 4
a1035 3
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
a1036 1
    {
d1039 1
a1039 2
        rep.state = !noPanoramiXExtension && !PanoramiXExtensionDisabledHack;
    }
d1041 1
a1041 1
    rep.state = !noPanoramiXExtension;
d1043 1
d1049 1
a1049 1
    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &rep);
d1057 7
a1063 1
    xXineramaQueryScreensReply rep;
a1066 4
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.number = (noPanoramiXExtension) ? 0 : PanoramiXNumScreens;
    rep.length = bytes_to_int32(rep.number * sz_XineramaScreenInfo);
d1072 1
a1072 1
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *) &rep);
d1090 1
a1090 1
            WriteToClient(client, sz_XineramaScreenInfo, (char *) &scratch);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d67 1
a67 2
				VisualPtr pVisual,
				ScreenPtr pMatchScreen);
d74 10
a83 10
int 		PanoramiXPixWidth = 0;
int 		PanoramiXPixHeight = 0;
int 		PanoramiXNumScreens = 0;

static RegionRec   	PanoramiXScreenRegion = {{0, 0, 0, 0}, NULL};

static int		PanoramiXNumDepths;
static DepthPtr		PanoramiXDepths;
static int		PanoramiXNumVisuals;
static VisualPtr	PanoramiXVisuals;
d99 1
a99 1
static int ProcPanoramiXDispatch(ClientPtr client); 
d101 1
a101 1
static void PanoramiXResetProc(ExtensionEntry*);
d109 2
a110 1
int (* SavedProcVector[256]) (ClientPtr client) = { NULL, };
d113 1
d116 1
d120 3
a122 3
  DDXPointRec clipOrg;
  DDXPointRec patOrg;
  GCFuncs *wrapFuncs;
d126 2
a127 2
  CreateGCProcPtr	CreateGC;
  CloseScreenProcPtr	CloseScreen;
a151 1

d153 1
a153 1
XineramaCloseScreen (int i, ScreenPtr pScreen)
d156 1
a156 1
	dixLookupPrivate(&pScreen->devPrivates, PanoramiXScreenKey);
d162 1
a162 1
	RegionUninit(&PanoramiXScreenRegion);
d174 1
a174 1
	dixLookupPrivate(&pScreen->devPrivates, PanoramiXScreenKey);
d178 3
a180 3
    if((ret = (*pScreen->CreateGC)(pGC))) {
	PanoramiXGCPtr pGCPriv = (PanoramiXGCPtr)
	    dixLookupPrivate(&pGC->devPrivates, PanoramiXGCKey);
d182 1
a182 1
	pGCPriv->wrapFuncs = pGC->funcs;
d185 4
a188 4
	pGCPriv->clipOrg.x = pGC->clipOrg.x; 
	pGCPriv->clipOrg.y = pGC->clipOrg.y;
	pGCPriv->patOrg.x = pGC->patOrg.x;
	pGCPriv->patOrg.y = pGC->patOrg.y;
d196 52
a247 54
XineramaValidateGC(
   GCPtr         pGC,
   unsigned long changes,
   DrawablePtr   pDraw 
){
    Xinerama_GC_FUNC_PROLOGUE (pGC);

    if((pDraw->type == DRAWABLE_WINDOW) && !(((WindowPtr)pDraw)->parent)) {
	/* the root window */
	int x_off = pGC->pScreen->x;
	int y_off = pGC->pScreen->y;
	int new_val;

	new_val = pGCPriv->clipOrg.x - x_off;
	if(pGC->clipOrg.x != new_val) {
	    pGC->clipOrg.x = new_val;
	    changes |= GCClipXOrigin;
	}
	new_val = pGCPriv->clipOrg.y - y_off;
	if(pGC->clipOrg.y != new_val) {
	    pGC->clipOrg.y = new_val;
	    changes |= GCClipYOrigin;
	}
	new_val = pGCPriv->patOrg.x - x_off;
	if(pGC->patOrg.x != new_val) {
	    pGC->patOrg.x = new_val;
	    changes |= GCTileStipXOrigin;
	}
	new_val = pGCPriv->patOrg.y - y_off;
	if(pGC->patOrg.y != new_val) {
	    pGC->patOrg.y = new_val;
	    changes |= GCTileStipYOrigin;
	}
    } else {
	if(pGC->clipOrg.x != pGCPriv->clipOrg.x) {
	    pGC->clipOrg.x = pGCPriv->clipOrg.x;
	    changes |= GCClipXOrigin;
	}
	if(pGC->clipOrg.y != pGCPriv->clipOrg.y) {
	    pGC->clipOrg.y = pGCPriv->clipOrg.y;
	    changes |= GCClipYOrigin;
	}
	if(pGC->patOrg.x != pGCPriv->patOrg.x) {
	    pGC->patOrg.x = pGCPriv->patOrg.x;
	    changes |= GCTileStipXOrigin;
	}
	if(pGC->patOrg.y != pGCPriv->patOrg.y) {
	    pGC->patOrg.y = pGCPriv->patOrg.y;
	    changes |= GCTileStipYOrigin;
	}
    }
  
    (*pGC->funcs->ValidateGC)(pGC, changes, pDraw);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
d253 3
a255 3
    Xinerama_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->DestroyGC)(pGC);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
d259 12
a270 14
XineramaChangeGC (
    GCPtr	    pGC,
    unsigned long   mask
){
    Xinerama_GC_FUNC_PROLOGUE (pGC);

    if(mask & GCTileStipXOrigin)
	pGCPriv->patOrg.x = pGC->patOrg.x;
    if(mask & GCTileStipYOrigin)
	pGCPriv->patOrg.y = pGC->patOrg.y;
    if(mask & GCClipXOrigin)
	pGCPriv->clipOrg.x = pGC->clipOrg.x; 
    if(mask & GCClipYOrigin)
	pGCPriv->clipOrg.y = pGC->clipOrg.y;
d273 1
a273 1
    Xinerama_GC_FUNC_EPILOGUE (pGC);
d277 2
a278 5
XineramaCopyGC (
    GCPtr	    pGCSrc, 
    unsigned long   mask,
    GCPtr	    pGCDst
){
d280 3
a282 2
	dixLookupPrivate(&pGCSrc->devPrivates, PanoramiXGCKey);
    Xinerama_GC_FUNC_PROLOGUE (pGCDst);
d284 1
a284 1
    if(mask & GCTileStipXOrigin)
d286 1
a286 1
    if(mask & GCTileStipYOrigin)
d288 1
a288 1
    if(mask & GCClipXOrigin)
d290 1
a290 1
    if(mask & GCClipYOrigin)
d294 1
a294 1
    Xinerama_GC_FUNC_EPILOGUE (pGCDst);
d298 3
a300 7
XineramaChangeClip (
    GCPtr   pGC,
    int		type,
    pointer	pvalue,
    int		nrects 
){
    Xinerama_GC_FUNC_PROLOGUE (pGC);
d302 1
a302 1
    Xinerama_GC_FUNC_EPILOGUE (pGC);
d308 3
a310 3
    Xinerama_GC_FUNC_PROLOGUE (pgcDst);
    (* pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
    Xinerama_GC_FUNC_EPILOGUE (pgcDst);
d316 3
a318 3
    Xinerama_GC_FUNC_PROLOGUE (pGC);
    (* pGC->funcs->DestroyClip)(pGC);
    Xinerama_GC_FUNC_EPILOGUE (pGC);
d329 3
a331 3
   int screen;
   int id;
} PanoramiXSearchData; 
d333 1
a333 1
static Bool 
d336 3
a338 3
    PanoramiXRes *res = (PanoramiXRes*)resource;
    PanoramiXSearchData *data = (PanoramiXSearchData*)privdata;
    
d348 3
a350 3
    if(!screen) {
	dixLookupResourceByType(&val, id, type, serverClient, DixReadAccess);
	return val;
d357 1
a357 1
		XineramaFindIDByScrnum, &data);
d361 1
a361 1
    void (*func)(void);
d368 1
a368 1
XineramaRegisterConnectionBlockCallback(void (*func)(void))
d372 2
a373 2
    if(!(newlist = malloc(sizeof(XineramaConnectionCallbackList))))
	return FALSE;
d382 2
a383 1
static void XineramaInitData(ScreenPtr pScreen)
d389 2
a390 2
	BoxRec TheBox;
	RegionRec ScreenRegion;
d392 1
a392 1
        pScreen = screenInfo.screens[i];
d394 9
a402 9
	TheBox.x1 = pScreen->x;
	TheBox.x2 = TheBox.x1 + pScreen->width;
	TheBox.y1 = pScreen->y;
	TheBox.y2 = TheBox.y1 + pScreen->height;

	RegionInit(&ScreenRegion, &TheBox, 1);
	RegionUnion(&PanoramiXScreenRegion, &PanoramiXScreenRegion,
		     &ScreenRegion);
	RegionUninit(&ScreenRegion);
d406 2
a407 1
    PanoramiXPixHeight = screenInfo.screens[0]->y + screenInfo.screens[0]->height;
d410 1
a410 3
	pScreen = screenInfo.screens[i];
	w = pScreen->x + pScreen->width;
	h = pScreen->y + pScreen->height;
d412 7
a418 4
	if (PanoramiXPixWidth < w)
	    PanoramiXPixWidth = w;
	if (PanoramiXPixHeight < h)
	    PanoramiXPixHeight = h;
d422 2
a423 1
void XineramaReinitData(ScreenPtr pScreen)
d426 1
a426 1
    XineramaInitData(pScreen);
d434 1
a434 1
 */ 
d436 2
a437 1
void PanoramiXExtensionInit(int argc, char *argv[])
d439 5
a443 5
    int 	     	i;
    Bool	     	success = FALSE;
    ExtensionEntry 	*extEntry;
    ScreenPtr		pScreen = screenInfo.screens[0];
    PanoramiXScreenPtr	pScreenPriv;
d445 2
a446 2
    if (noPanoramiXExtension) 
	return;
d449 2
a450 2
	noPanoramiXExtension = TRUE;
	return;
d453 4
a456 3
    if (!dixRegisterPrivateKey(&PanoramiXGCKeyRec, PRIVATE_GC, sizeof(PanoramiXGCRec))) {
	noPanoramiXExtension = TRUE;
	return;
d460 3
a462 3
    if (PanoramiXNumScreens == 1) {		/* Only 1 screen 	*/
	noPanoramiXExtension = TRUE;
	return;
d466 50
a515 51
	extEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0, 
				ProcPanoramiXDispatch,
				SProcPanoramiXDispatch, PanoramiXResetProc, 
				StandardMinorOpcode);
	if (!extEntry)
	    break;

	/*
	 *	First make sure all the basic allocations succeed.  If not,
	 *	run in non-PanoramiXeen mode.
	 */

	FOR_NSCREENS(i) {
	   pScreen = screenInfo.screens[i];
	   pScreenPriv = malloc(sizeof(PanoramiXScreenRec));
	   dixSetPrivate(&pScreen->devPrivates, PanoramiXScreenKey,
			 pScreenPriv);
	   if(!pScreenPriv) {
		noPanoramiXExtension = TRUE;
		return;
	   }
	
	   pScreenPriv->CreateGC = pScreen->CreateGC;
	   pScreenPriv->CloseScreen = pScreen->CloseScreen;
	
	   pScreen->CreateGC = XineramaCreateGC;
	   pScreen->CloseScreen = XineramaCloseScreen;
	}

	XRC_DRAWABLE = CreateNewResourceClass();
	XRT_WINDOW = CreateNewResourceType(XineramaDeleteResource,
					   "XineramaWindow");
	if (XRT_WINDOW)
	    XRT_WINDOW |= XRC_DRAWABLE;
	XRT_PIXMAP = CreateNewResourceType(XineramaDeleteResource,
					   "XineramaPixmap");
	if (XRT_PIXMAP)
	    XRT_PIXMAP |= XRC_DRAWABLE;
	XRT_GC = CreateNewResourceType(XineramaDeleteResource,
				       "XineramaGC");
	XRT_COLORMAP = CreateNewResourceType(XineramaDeleteResource,
					     "XineramaColormap");

	if (XRT_WINDOW && XRT_PIXMAP && XRT_GC && XRT_COLORMAP) {
	    panoramiXGeneration = serverGeneration;
	    success = TRUE;
	}
	SetResourceTypeErrorValue(XRT_WINDOW, BadWindow);
	SetResourceTypeErrorValue(XRT_PIXMAP, BadPixmap);
	SetResourceTypeErrorValue(XRT_GC, BadGC);
	SetResourceTypeErrorValue(XRT_COLORMAP, BadColor);
d519 3
a521 3
	noPanoramiXExtension = TRUE;
	ErrorF(PANORAMIX_PROTOCOL_NAME " extension failed to initialize\n");
	return;
d523 2
a524 2
  
    XineramaInitData(pScreen);
d527 1
a527 1
     *	Put our processes into the ProcVector
d530 2
a531 2
    for (i = 256; i--; )
	SavedProcVector[i] = ProcVector[i];
d585 1
a585 1
    PanoramiXRenderInit ();
d587 1
a587 1
    PanoramiXFixesInit ();
d590 1
a590 1
    PanoramiXCompositeInit ();
d597 2
a598 1
Bool PanoramiXCreateConnectionBlock(void)
d611 1
a611 1
     *	Do normal CreateConnectionBlock but faking it for only one screen
d614 3
a616 3
    if(!PanoramiXNumDepths) {
	ErrorF("Xinerama error: No common visuals\n");
	return FALSE;
d619 9
a627 8
    for(i = 1; i < screenInfo.numScreens; i++) {
	pScreen = screenInfo.screens[i];
	if(pScreen->rootDepth != screenInfo.screens[0]->rootDepth) {
	    ErrorF("Xinerama error: Root window depths differ\n");
	    return FALSE;
	}
	if(pScreen->backingStoreSupport != screenInfo.screens[0]->backingStoreSupport)
	     disableBackingStore = TRUE;
d631 4
a634 4
    	for (i = 0; i < screenInfo.numScreens; i++) {
	    pScreen = screenInfo.screens[i];
	    pScreen->backingStoreSupport = NotUseful;
	}
d640 2
a641 2
	screenInfo.numScreens = i;
	return FALSE;
d645 1
a645 1
    
d653 19
a671 21
	depth = (xDepth *) (ConnectionInfo + length);
	depth->depth = PanoramiXDepths[i].depth;
	depth->nVisuals = PanoramiXDepths[i].numVids;
	length += sizeof(xDepth);
	visual = (xVisualType *)(ConnectionInfo + length);
	
	for (j = 0; j < depth->nVisuals; j++, visual++) {
	    visual->visualID = PanoramiXDepths[i].vids[j];

	    for (pVisual = PanoramiXVisuals;
		 pVisual->vid != visual->visualID;
		 pVisual++)
	         ;

	    visual->class = pVisual->class;
	    visual->bitsPerRGB = pVisual->bitsPerRGBValue;
	    visual->colormapEntries = pVisual->ColormapEntries;
	    visual->redMask = pVisual->redMask;
	    visual->greenMask = pVisual->greenMask;
	    visual->blueMask = pVisual->blueMask;
	}
d673 1
a673 1
	length += (depth->nVisuals * sizeof(xVisualType));
d679 1
a679 1
	free(PanoramiXDepths[i].vids);
d686 1
a686 1
    
d697 2
a698 2
    while(ConnectionCallbackList) {
	pointer tmp;
d700 4
a703 4
	tmp = (pointer)ConnectionCallbackList;
	(*ConnectionCallbackList->func)();
	ConnectionCallbackList = ConnectionCallbackList->next;
	free(tmp);
d722 8
a729 8
	(a->ColormapEntries == b->ColormapEntries) &&
	(a->nplanes == b->nplanes) &&
	(a->redMask == b->redMask) &&
	(a->greenMask == b->greenMask) &&
	(a->blueMask == b->blueMask) &&
	(a->offsetRed == b->offsetRed) &&
	(a->offsetGreen == b->offsetGreen) &&
	(a->offsetBlue == b->offsetBlue));
d740 7
a746 7
	pScreen = screenInfo.screens[j];
	for (k = 0; k < pScreen->numDepths; k++) {
	    if (pScreen->allowedDepths[k].depth == pDepth->depth) {
		found = TRUE;
		break;
	    }
	}
d750 1
a750 1
	return;
d755 1
a755 1
	    PanoramiXNumDepths * sizeof(DepthRec));
d759 2
a760 2
    if(pDepth->numVids)
	PanoramiXDepths[j].vids = malloc(sizeof(VisualID) * pDepth->numVids);
d762 1
a762 1
	PanoramiXDepths[j].vids = NULL;
d773 2
a774 2
	pScreen = screenInfo.screens[j];
	found = FALSE;
d776 2
a777 2
	for (k = 0; k < pScreen->numVisuals; k++) {
	    VisualPtr candidate = &pScreen->visuals[k];
d779 1
a779 1
	    if ((*XineramaVisualsEqualPtr)(pVisual, pScreen, candidate)
d781 1
a781 1
		&& glxMatchVisual(screenInfo.screens[0], pVisual, pScreen)
d783 5
a787 5
		    ) {
		found = TRUE;
		break;
	    }
	}
d789 2
a790 2
	if (!found)
	    return;
d797 1
a797 1
	    PanoramiXNumVisuals * sizeof(VisualRec));
d802 6
a807 6
	if (PanoramiXDepths[k].depth == pVisual->nplanes) {
	    PanoramiXDepths[k].vids[PanoramiXDepths[k].numVids] = pVisual->vid;
	    PanoramiXDepths[k].numVids++;
	    break;
	}	
    }   
d813 1
a813 1
    int 	i;
d815 3
a817 3
    ScreenPtr   pScreen = screenInfo.screens[0];
    DepthPtr    pDepth = pScreen->allowedDepths;
    VisualPtr   pVisual = pScreen->visuals;
d823 1
a823 1
	PanoramiXMaybeAddDepth(pDepth++);
d826 1
a826 1
	PanoramiXMaybeAddVisual(pVisual++);
d836 4
a839 3
	ScreenPtr pScreen = screenInfo.screens[i];
	root->info[i].id = pScreen->root->drawable.id;
	root->u.win.class = InputOutput;
d844 1
a844 1
	defmap->info[i].id = pScreen->defColormap;
d860 4
a863 4
	if (orig == PanoramiXVisuals[i].vid) {
	    pVisual = &PanoramiXVisuals[i];
	    break;
	}
d867 1
a867 1
	return 0;
d871 1
a871 1
	return orig;
d875 1
a875 1
	VisualPtr pOtherVisual = &pOtherScreen->visuals[i];
d877 2
a878 2
	if ((*XineramaVisualsEqualPtr)(pVisual, pOtherScreen, pOtherVisual))
	    return pOtherVisual->vid;
a883 1

d889 2
a890 1
static void PanoramiXResetProc(ExtensionEntry* extEntry)
d892 1
a892 1
    int		i;
d894 1
a894 1
    PanoramiXRenderReset ();
d896 1
a896 1
    PanoramiXFixesReset ();
d899 2
a900 2
    for (i = 256; i--; )
	ProcVector[i] = SavedProcVector[i];
a902 1

d904 1
a904 1
ProcPanoramiXQueryVersion (ClientPtr client)
d907 1
a907 2
    xPanoramiXQueryVersionReply		rep;
    register 	int			n;
d909 1
a909 1
    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
d915 5
a919 5
    if (client->swapped) { 
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);     
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
d921 1
a921 1
    WriteToClient(client, sizeof (xPanoramiXQueryVersionReply), (char *)&rep);
d928 22
a949 22
	REQUEST(xPanoramiXGetStateReq);
    	WindowPtr			pWin;
	xPanoramiXGetStateReply		rep;
	int			n, rc;
	
	REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;

	rep.type = X_Reply;
	rep.length = 0;
	rep.sequenceNumber = client->sequence;
	rep.state = !noPanoramiXExtension;
	rep.window = stuff->window;
    	if (client->swapped) {
	    swaps (&rep.sequenceNumber, n);
	    swapl (&rep.length, n);
	    swapl (&rep.window, n);
	}	
	WriteToClient (client, sizeof (xPanoramiXGetStateReply), (char *) &rep);
	return Success;
d953 1
a953 1
int 
d956 22
a977 22
	REQUEST(xPanoramiXGetScreenCountReq);
    	WindowPtr			pWin;
	xPanoramiXGetScreenCountReply	rep;
	int			n, rc;

	REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;

	rep.type = X_Reply;
	rep.length = 0;
	rep.sequenceNumber = client->sequence;
	rep.ScreenCount = PanoramiXNumScreens;
	rep.window = stuff->window;
    	if (client->swapped) {
	    swaps (&rep.sequenceNumber, n);
	    swapl (&rep.length, n);
	    swapl (&rep.window, n);
	}	
	WriteToClient (client, sizeof (xPanoramiXGetScreenCountReply), (char *) &rep);
	return Success;
d980 1
a980 1
int 
d983 31
a1013 31
	REQUEST(xPanoramiXGetScreenSizeReq);
    	WindowPtr			pWin;
	xPanoramiXGetScreenSizeReply	rep;
	int			n, rc;
	
	if (stuff->screen >= PanoramiXNumScreens)
	    return BadMatch;

	REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
	rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
	if (rc != Success)
	    return rc;

	rep.type = X_Reply;
	rep.length = 0;
	rep.sequenceNumber = client->sequence;
		/* screen dimensions */
	rep.width  = screenInfo.screens[stuff->screen]->width;
	rep.height = screenInfo.screens[stuff->screen]->height;
	rep.window = stuff->window;
	rep.screen = stuff->screen;
    	if (client->swapped) {
	    swaps (&rep.sequenceNumber, n);
	    swapl (&rep.length, n);
	    swapl (&rep.width, n);
	    swapl (&rep.height, n);
	    swapl (&rep.window, n);
	    swapl (&rep.screen, n);
	}	
	WriteToClient (client, sizeof (xPanoramiXGetScreenSizeReply), (char *) &rep);
	return Success;
a1015 1

d1020 1
a1020 1
    xXineramaIsActiveReply	rep;
d1029 3
a1031 3
	/* The following hack fools clients into thinking that Xinerama
	 * is disabled even though it is not. */
	rep.state = !noPanoramiXExtension && !PanoramiXExtensionDisabledHack;
d1037 5
a1041 6
	int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.state, n);
    }	
    WriteToClient (client, sizeof (xXineramaIsActiveReply), (char *) &rep);
a1044 1

d1049 1
a1049 1
    xXineramaQueryScreensReply	rep;
d1058 24
a1081 26
	int n;
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.number, n);
    }	
    WriteToClient (client, sizeof (xXineramaQueryScreensReply), (char *) &rep);

    if(!noPanoramiXExtension) {
	xXineramaScreenInfo scratch;
	int i;

	FOR_NSCREENS(i) {
	    scratch.x_org  = screenInfo.screens[i]->x;
	    scratch.y_org  = screenInfo.screens[i]->y;
	    scratch.width  = screenInfo.screens[i]->width;
	    scratch.height = screenInfo.screens[i]->height;
	
	    if(client->swapped) {
		int n;
		swaps (&scratch.x_org, n);
		swaps (&scratch.y_org, n);
		swaps (&scratch.width, n);
		swaps (&scratch.height, n);
	    }
	    WriteToClient (client, sz_XineramaScreenInfo, (char *) &scratch);
	}
a1086 1

d1088 16
a1103 16
ProcPanoramiXDispatch (ClientPtr client)
{   REQUEST(xReq);
    switch (stuff->data)
    {
	case X_PanoramiXQueryVersion:
	     return ProcPanoramiXQueryVersion(client);
	case X_PanoramiXGetState:
	     return ProcPanoramiXGetState(client);
	case X_PanoramiXGetScreenCount:
	     return ProcPanoramiXGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return ProcPanoramiXGetScreenSize(client);
	case X_XineramaIsActive:
	     return ProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return ProcXineramaQueryScreens(client);
a1107 1

d1119 1
a1119 1
   /* Just get it to work.  Worry about speed later */
d1122 6
a1127 5
    while(bytes--) {
	*dst |= SHIFT_L(*src, shiftL);
	*(dst + 1) |= SHIFT_R(*src, shiftR);
	dst++; src++;
    }     
a1129 1

d1135 9
a1143 12
XineramaGetImageData(
    DrawablePtr *pDrawables,
    int left,
    int top,
    int width, 
    int height,
    unsigned int format,
    unsigned long planemask,
    char *data,
    int pitch,
    Bool isRoot
){
d1155 3
a1157 3
    if(!isRoot) {
	SrcBox.x1 += pDraw->x + screenInfo.screens[0]->x;
	SrcBox.y1 += pDraw->y + screenInfo.screens[0]->y;
d1161 1
a1161 1
    
d1168 117
a1284 110
	BoxRec TheBox;
	ScreenPtr pScreen;
	pDraw = pDrawables[i];
	pScreen = pDraw->pScreen;

	TheBox.x1 = pScreen->x;
	TheBox.x2 = TheBox.x1 + pScreen->width;
	TheBox.y1 = pScreen->y;
	TheBox.y2 = TheBox.y1 + pScreen->height;

	RegionInit(&ScreenRegion, &TheBox, 1);
	inOut = RegionContainsRect(&ScreenRegion, &SrcBox);
	if(inOut == rgnPART)
	    RegionIntersect(&GrabRegion, &SrcRegion, &ScreenRegion);
	RegionUninit(&ScreenRegion);

	if(inOut == rgnIN) {	   
	    (*pScreen->GetImage)(pDraw,
			SrcBox.x1 - pDraw->x - screenInfo.screens[i]->x,
			SrcBox.y1 - pDraw->y - screenInfo.screens[i]->y,
			width, height, format, planemask, data);
	    break;
	} else if (inOut == rgnOUT)
	    continue;

	nbox = RegionNumRects(&GrabRegion);

	if(nbox) {
	    pbox = RegionRects(&GrabRegion);

	    while(nbox--) {
		w = pbox->x2 - pbox->x1;
		h = pbox->y2 - pbox->y1;
		ScratchPitch = PixmapBytePad(w, depth);
		sizeNeeded = ScratchPitch * h;

		if(sizeNeeded > size) {
		    char *tmpdata = ScratchMem;
		    ScratchMem = realloc(ScratchMem, sizeNeeded);
		    if(ScratchMem)
			size = sizeNeeded;
		    else {
			ScratchMem = tmpdata;
			break;
		    }	
		}

		x = pbox->x1 - pDraw->x - screenInfo.screens[i]->x;
		y = pbox->y1 - pDraw->y - screenInfo.screens[i]->y;

		(*pScreen->GetImage)(pDraw, x, y, w, h,
					format, planemask, ScratchMem);
		
		/* copy the memory over */

		if(depth == 1) {
		   int k, shift, leftover, index, index2;
		
		   x = pbox->x1 - SrcBox.x1;
		   y = pbox->y1 - SrcBox.y1;
		   shift = x & 7;
		   x >>= 3;
		   leftover = w & 7;
		   w >>= 3;

		   /* clean up the edge */
		   if(leftover) {
			int mask = (1 << leftover) - 1;
			for(j = h, k = w; j--; k += ScratchPitch)
			    ScratchMem[k] &= mask;
		   }

		   for(j = 0, index = (pitch * y) + x, index2 = 0; j < h;
		       j++, index += pitch, index2 += ScratchPitch) 
		   {
			if(w) {
			    if(!shift)
				memcpy(data + index, ScratchMem + index2, w);
			    else
				CopyBits(data + index, shift, 
						ScratchMem + index2, w);
			}
	
			if(leftover) {
			    data[index + w] |= 
				SHIFT_L(ScratchMem[index2 + w], shift);
			    if((shift + leftover) > 8)
				data[index + w + 1] |= 
				  SHIFT_R(ScratchMem[index2 + w],(8 - shift));
			}
		    }
		} else {
		    j = BitsPerPixel(depth) >> 3;
		    x = (pbox->x1 - SrcBox.x1) * j;
		    y = pbox->y1 - SrcBox.y1;
		    w *= j;

		    for(j = 0; j < h; j++) {
			memcpy(data + (pitch * (y + j)) + x, 
				ScratchMem + (ScratchPitch * j), w);
		    }
		}
		pbox++;
	    }

	    RegionSubtract(&SrcRegion, &SrcRegion, &GrabRegion);
	    if(!RegionNotEmpty(&SrcRegion))
		break;
	}
	
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d56 6
d86 5
a90 5
unsigned long XRC_DRAWABLE;
unsigned long XRT_WINDOW;
unsigned long XRT_PIXMAP;
unsigned long XRT_GC;
unsigned long XRT_COLORMAP;
d396 1
a396 1
    for (i = 0; i < PanoramiXNumScreens; i++) {
d416 1
a416 1
    for (i = 1; i < PanoramiXNumScreens; i++) {
d481 1
a481 1
	for (i = 0; i < PanoramiXNumScreens; i++) {
d590 7
d743 1
a743 1
    for (j = 1; j < PanoramiXNumScreens; j++) {
d776 1
a776 1
    for (j = 1; j < PanoramiXNumScreens; j++) {
d839 1
a839 1
    for (i =  0; i < PanoramiXNumScreens; i++) {
d898 3
d1077 1
a1077 1
	for(i = 0; i < PanoramiXNumScreens; i++) {
d1182 1
a1182 1
    for(i = 0; i < PanoramiXNumScreens; i++) {
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a54 1
#ifdef RENDER
a55 1
#endif
a72 1
PanoramiXData *panoramiXdataPtr = NULL;
d106 4
a109 4
static int PanoramiXGCKeyIndex;
static DevPrivateKey PanoramiXGCKey = &PanoramiXGCKeyIndex;
static int PanoramiXScreenKeyIndex;
static DevPrivateKey PanoramiXScreenKey = &PanoramiXScreenKeyIndex;
a121 2
RegionRec XineramaScreenRegions[MAXSCREENS];

a153 1
    REGION_UNINIT(pScreen, &XineramaScreenRegions[pScreen->myNum]);
d155 1
a155 1
	REGION_UNINIT(pScreen, &PanoramiXScreenRegion);
d157 1
a157 1
    xfree ((pointer) pScreenPriv);
d198 2
a199 2
	int x_off = panoramiXdataPtr[pGC->pScreen->myNum].x;
	int y_off = panoramiXdataPtr[pGC->pScreen->myNum].y;
d327 1
a327 1
    xfree(data);
d342 1
a342 1
    return (res->info[data->screen].id == data->id);
d375 1
a375 1
    if(!(newlist = xalloc(sizeof(XineramaConnectionCallbackList))))
d389 1
a389 1
    REGION_NULL(pScreen, &PanoramiXScreenRegion)
d392 1
d396 9
a404 13
	panoramiXdataPtr[i].x = dixScreenOrigins[i].x;
	panoramiXdataPtr[i].y = dixScreenOrigins[i].y;
	panoramiXdataPtr[i].width = pScreen->width;
	panoramiXdataPtr[i].height = pScreen->height;

	TheBox.x1 = panoramiXdataPtr[i].x;
	TheBox.x2 = TheBox.x1 + panoramiXdataPtr[i].width;
	TheBox.y1 = panoramiXdataPtr[i].y;
	TheBox.y2 = TheBox.y1 + panoramiXdataPtr[i].height;

	REGION_INIT(pScreen, &XineramaScreenRegions[i], &TheBox, 1);
	REGION_UNION(pScreen, &PanoramiXScreenRegion, &PanoramiXScreenRegion,
		     &XineramaScreenRegions[i]);
d407 2
a408 2
    PanoramiXPixWidth = panoramiXdataPtr[0].x + panoramiXdataPtr[0].width;
    PanoramiXPixHeight = panoramiXdataPtr[0].y + panoramiXdataPtr[0].height;
d411 3
a413 2
	w = panoramiXdataPtr[i].x + panoramiXdataPtr[i].width;
	h = panoramiXdataPtr[i].y + panoramiXdataPtr[i].height;
d424 1
a424 6
    int i;

    REGION_UNINIT(pScreen, &PanoramiXScreenRegion);
    for (i = 0; i < PanoramiXNumScreens; i++)
	REGION_UNINIT(pScreen, &XineramaScreenRegions[i]);

d446 10
a474 10
	panoramiXdataPtr = (PanoramiXData *) 
		xcalloc(PanoramiXNumScreens, sizeof(PanoramiXData));

        BREAK_IF(!panoramiXdataPtr);

	if (!dixRequestPrivate(PanoramiXGCKey, sizeof(PanoramiXGCRec))) {
		noPanoramiXExtension = TRUE;
		return;
	}
	
d477 1
a477 1
	   pScreenPriv = xalloc(sizeof(PanoramiXScreenRec));
d510 4
a582 1
#ifdef RENDER
a583 1
#endif
d670 2
a671 2
	xfree(PanoramiXDepths[i].vids);
    xfree(PanoramiXDepths);
d694 1
a694 1
	xfree(tmp);
d745 1
a745 1
    PanoramiXDepths = xrealloc(PanoramiXDepths,
d751 1
a751 1
	PanoramiXDepths[j].vids = xalloc(sizeof(VisualID) * pDepth->numVids);
d787 1
a787 1
    PanoramiXVisuals = xrealloc(PanoramiXVisuals,
d819 1
a819 1
    root = xalloc(sizeof(PanoramiXRes));
d821 1
a821 1
    defmap = xalloc(sizeof(PanoramiXRes));
d823 1
a823 1
    saver = xalloc(sizeof(PanoramiXRes));
d827 2
a828 1
	root->info[i].id = WindowTable[i]->drawable.id;
d831 1
a831 1
        saver->info[i].id = savedScreenInfo[i].wid;
d834 1
a834 1
	defmap->info[i].id = (screenInfo.screens[i])->defColormap;
a883 1
#ifdef RENDER
a884 1
#endif
a887 2

    Xfree(panoramiXdataPtr);    
d911 1
a911 1
    return (client->noClientException);
d938 1
a938 1
	return client->noClientException;
d966 1
a966 1
	return client->noClientException;
d989 2
a990 2
	rep.width  = panoramiXdataPtr[stuff->screen].width; 
	rep.height = panoramiXdataPtr[stuff->screen].height; 
d1002 1
a1002 1
	return client->noClientException;
d1033 1
a1033 1
    return client->noClientException;
d1062 4
a1065 4
	    scratch.x_org  = panoramiXdataPtr[i].x;
	    scratch.y_org  = panoramiXdataPtr[i].y;
	    scratch.width  = panoramiXdataPtr[i].width;
	    scratch.height = panoramiXdataPtr[i].height;
d1078 1
a1078 1
    return client->noClientException;
d1143 1
a1143 1
    RegionRec SrcRegion, GrabRegion;
d1155 2
a1156 2
	SrcBox.x1 += pDraw->x + panoramiXdataPtr[0].x;
	SrcBox.y1 += pDraw->y + panoramiXdataPtr[0].y;
d1161 2
a1162 2
    REGION_INIT(pScreen, &SrcRegion, &SrcBox, 1);
    REGION_NULL(pScreen, &GrabRegion);
d1167 2
d1170 1
d1172 10
a1181 1
	inOut = RECT_IN_REGION(pScreen,&XineramaScreenRegions[i],&SrcBox);
d1184 3
a1186 3
	    (*pDraw->pScreen->GetImage)(pDraw, 
			SrcBox.x1 - pDraw->x - panoramiXdataPtr[i].x,
			SrcBox.y1 - pDraw->y - panoramiXdataPtr[i].y, 
d1192 1
a1192 4
	REGION_INTERSECT(pScreen, &GrabRegion, &SrcRegion, 
					&XineramaScreenRegions[i]);

	nbox = REGION_NUM_RECTS(&GrabRegion);
d1195 1
a1195 1
	    pbox = REGION_RECTS(&GrabRegion);
d1205 1
a1205 1
		    ScratchMem = xrealloc(ScratchMem, sizeNeeded);
d1214 2
a1215 2
		x = pbox->x1 - pDraw->x - panoramiXdataPtr[i].x;
		y = pbox->y1 - pDraw->y - panoramiXdataPtr[i].y;
d1217 1
a1217 1
		(*pDraw->pScreen->GetImage)(pDraw, x, y, w, h, 
d1272 2
a1273 2
	    REGION_SUBTRACT(pScreen, &SrcRegion, &SrcRegion, &GrabRegion);
	    if(!REGION_NOTEMPTY(pScreen, &SrcRegion))
d1279 1
a1279 2
    if(ScratchMem)
	xfree(ScratchMem);
d1281 2
a1282 2
    REGION_UNINIT(pScreen, &SrcRegion);
    REGION_UNINIT(pScreen, &GrabRegion);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a33 1
#define NEED_REPLIES
d59 1
a59 3

#define SERVER_PANORAMIX_MAJOR_VERSION	1
#define SERVER_PANORAMIX_MINOR_VERSION	1
d73 1
a73 1
_X_EXPORT int 	PanoramiXNumScreens = 0;
d75 1
a75 1
_X_EXPORT PanoramiXData *panoramiXdataPtr = NULL;
d83 5
a87 5
_X_EXPORT unsigned long XRC_DRAWABLE;
_X_EXPORT unsigned long XRT_WINDOW;
_X_EXPORT unsigned long XRT_PIXMAP;
_X_EXPORT unsigned long XRT_GC;
_X_EXPORT unsigned long XRT_COLORMAP;
d90 1
a90 1
_X_EXPORT XineramaVisualsEqualProcPtr XineramaVisualsEqualPtr = &VisualsEqual;
d330 1
a330 1
_X_EXPORT int
d355 1
d357 4
a360 2
    if(!screen) 
	return LookupIDByType(id, type);
d376 1
a376 1
_X_EXPORT Bool
d506 17
a522 9
	XRT_WINDOW = CreateNewResourceType(XineramaDeleteResource) | 
						XRC_DRAWABLE;
	XRT_PIXMAP = CreateNewResourceType(XineramaDeleteResource) | 
						XRC_DRAWABLE;
	XRT_GC = CreateNewResourceType(XineramaDeleteResource);
	XRT_COLORMAP = CreateNewResourceType(XineramaDeleteResource);

	panoramiXGeneration = serverGeneration;
	success = TRUE;
d678 1
a678 1
    connSetupPrefix.length = length >> 2;
d852 1
a852 1
_X_EXPORT VisualID
d1062 1
a1062 1
    rep.length = rep.number * sz_XineramaScreenInfo >> 2;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d61 2
d112 4
a115 2
static DevPrivateKey PanoramiXGCKey = &PanoramiXGCKey;
static DevPrivateKey PanoramiXScreenKey = &PanoramiXScreenKey;
d555 2
a556 2
    ProcVector[X_CopyArea] = PanoramiXCopyArea;;
    ProcVector[X_CopyPlane] = PanoramiXCopyPlane;;
d579 1
a579 1
    ProcVector[X_AllocColorPlanes] = PanoramiXAllocColorPlanes;    
d581 2
a582 2
    ProcVector[X_StoreColors] = PanoramiXStoreColors;    
    ProcVector[X_StoreNamedColor] = PanoramiXStoreNamedColor;    
a594 1
    Bool disableSaveUnders = FALSE;
a619 2
	if(pScreen->saveUnderSupport != screenInfo.screens[0]->saveUnderSupport)
	     disableSaveUnders = TRUE;
d622 2
a623 2
    if(disableBackingStore || disableSaveUnders) {
    	for(i = 0; i < screenInfo.numScreens; i++) {
d625 1
a625 4
	    if(disableBackingStore)
		pScreen->backingStoreSupport = NotUseful;
	    if(disableSaveUnders)
		pScreen->saveUnderSupport = NotUseful;
d908 2
a909 2
    rep.majorVersion = PANORAMIX_MAJOR_VERSION;
    rep.minorVersion = PANORAMIX_MINOR_VERSION;   
d926 1
a926 1
	register int			n, rc;
d954 1
a954 1
	register int			n, rc;
d981 1
a981 1
	register int			n, rc;
d1033 1
a1033 1
	register int n;
d1056 1
a1056 1
	register int n;
d1074 1
a1074 1
		register int n;
@


1.1
log
@Initial revision
@
text
@a67 3
#if 0
static unsigned char PanoramiXReqCode = 0;
#endif
d77 1
a77 1
RegionRec   		PanoramiXScreenRegion = {{0, 0, 0, 0}, NULL};
a83 3
/* We support at most 256 visuals */
_X_EXPORT XID		*PanoramiXVisualTable = NULL;

d90 3
a108 1
ScreenInfo *GlobalScrInfo = NULL;
d110 2
a111 2
static int PanoramiXGCIndex = -1;
static int PanoramiXScreenIndex = -1;
d134 1
a134 1
GCFuncs XineramaGCFuncs = {
d140 2
a141 2
    PanoramiXGCPtr  pGCPriv = \
		(PanoramiXGCPtr) (pGC)->devPrivates[PanoramiXGCIndex].ptr;\
d152 2
a153 2
    PanoramiXScreenPtr pScreenPriv = 
        (PanoramiXScreenPtr) pScreen->devPrivates[PanoramiXScreenIndex].ptr;
d167 1
a167 1
Bool
d171 2
a172 2
    PanoramiXScreenPtr pScreenPriv = 
        (PanoramiXScreenPtr) pScreen->devPrivates[PanoramiXScreenIndex].ptr;
d177 2
a178 2
	PanoramiXGCPtr pGCPriv = 
		(PanoramiXGCPtr) pGC->devPrivates[PanoramiXGCIndex].ptr;
d284 2
a285 2
    PanoramiXGCPtr pSrcPriv =
                (PanoramiXGCPtr) pGCSrc->devPrivates[PanoramiXGCIndex].ptr;
a328 2


a335 20

static Bool 
XineramaFindIDOnAnyScreen(pointer resource, XID id, pointer privdata)
{
    PanoramiXRes *res = (PanoramiXRes*)resource;
    int j;

    FOR_NSCREENS(j) 
	if(res->info[j].id == *((XID*)privdata)) return TRUE;
    
    return FALSE;
}

PanoramiXRes *
PanoramiXFindIDOnAnyScreen(RESTYPE type, XID id)
{
    return LookupClientResourceComplex(clients[CLIENT_ID(id)], type,
		XineramaFindIDOnAnyScreen, &id);
}

a340 1

a364 17
WindowPtr
PanoramiXChangeWindow(int ScrnNum, WindowPtr pWin)
{
    int num = pWin->drawable.pScreen->myNum;

    if(num != ScrnNum) {
	PanoramiXRes	*win;

	win = PanoramiXFindIDByScrnum(XRT_WINDOW, pWin->drawable.id, num);

        if (win) 
           pWin = (WindowPtr) LookupIDByType(win->info[ScrnNum].id, RT_WINDOW);
    }
  
    return pWin;
}

a454 1
    GlobalScrInfo = &screenInfo;		/* For debug visibility */
d466 1
a466 2
	if (!extEntry) {
	    ErrorF("PanoramiXExtensionInit(): failed to AddExtension\n");
a467 5
 	}

#if 0
	PanoramiXReqCode = (unsigned char)extEntry->base;
#endif
d478 5
a482 2
	BREAK_IF((PanoramiXGCIndex = AllocateGCPrivateIndex()) < 0);
	BREAK_IF((PanoramiXScreenIndex = AllocateScreenPrivateIndex()) < 0);
a485 6
	   if(!AllocateGCPrivate(pScreen, PanoramiXGCIndex, 
						sizeof(PanoramiXGCRec))) {
		noPanoramiXExtension = TRUE;
		return;
	   }

d487 2
a488 2
	   pScreen->devPrivates[PanoramiXScreenIndex].ptr = 
						(pointer)pScreenPriv;
d515 1
a515 1
	ErrorF("%s Extension failed to initialize\n", PANORAMIX_PROTOCOL_NAME);
d605 1
a605 1
	ErrorF("PanoramiX error: Incompatible screens. No common visuals\n");
d612 1
a612 1
	    ErrorF("PanoramiX error: Incompatible screens. Root window depths differ\n");
a673 1
    xfree(PanoramiXVisuals);
d677 1
d705 25
a729 2
extern
void PanoramiXConsolidate(void)
d731 13
a743 6
    int 	i, j, k;
    VisualPtr   pVisual, pVisual2;
    ScreenPtr   pScreen, pScreen2;
    DepthPtr    pDepth, pDepth2;
    PanoramiXRes *root, *defmap, *saver;
    Bool        foundDepth, missingDepth;
d745 2
a746 2
    if(!PanoramiXVisualTable)
	PanoramiXVisualTable = xcalloc(256 * MAXSCREENS, sizeof(XID));
d748 12
a759 3
    pScreen = screenInfo.screens[0];
    pVisual = pScreen->visuals; 
    pDepth  = pScreen->allowedDepths;
d761 10
a770 4
    PanoramiXNumDepths = 0;
    PanoramiXDepths = xcalloc(pScreen->numDepths,sizeof(DepthRec));
    PanoramiXNumVisuals = 0;
    PanoramiXVisuals = xcalloc(pScreen->numVisuals,sizeof(VisualRec));
d772 2
a773 38
    for (i = 0; i < pScreen->numDepths; i++, pDepth++) {
        missingDepth = FALSE;
        for (j = 1; j < PanoramiXNumScreens; j++) {
             pScreen2 = screenInfo.screens[j];
             pDepth2 = pScreen2->allowedDepths;

             foundDepth = FALSE;
             for (k = 0; k < pScreen2->numDepths; k++, pDepth2++) {
                 if(pDepth2->depth == pDepth->depth) {
                     foundDepth = TRUE;
                     break;
                 }
             }

             if(!foundDepth) {
                missingDepth = TRUE;
                break;
             }
        }
          
        if(!missingDepth) {
            PanoramiXDepths[PanoramiXNumDepths].depth = pDepth->depth;
            PanoramiXDepths[PanoramiXNumDepths].numVids = 0;
            if(pDepth->numVids)
                PanoramiXDepths[PanoramiXNumDepths].vids = 
                      xalloc(sizeof(VisualID) * pDepth->numVids);      
            else
                PanoramiXDepths[PanoramiXNumDepths].vids = NULL;
            PanoramiXNumDepths++;
        }
    }

    for (i = 0; i < pScreen->numVisuals; i++, pVisual++) {
	PanoramiXVisualTable[pVisual->vid * MAXSCREENS] = pVisual->vid;

	/* check if the visual exists on all screens */
	for (j = 1; j < PanoramiXNumScreens; j++) {
	    pScreen2 = screenInfo.screens[j];
d775 1
d777 1
a777 9
	    pVisual2 = glxMatchVisual(pScreen, pVisual, pScreen2);
	    if (pVisual2) {
		PanoramiXVisualTable[(pVisual->vid * MAXSCREENS) + j] =
		    pVisual2->vid;
		continue;
	    } else if (glxMatchVisual(pScreen, pVisual, pScreen)) {
		PanoramiXVisualTable[(pVisual->vid * MAXSCREENS) + j] = 0;
		break;
	    }
d779 2
a780 27
	    pVisual2 = pScreen2->visuals;

	    for (k = 0; k < pScreen2->numVisuals; k++, pVisual2++) {
		if ((pVisual->class == pVisual2->class) &&
		    (pVisual->ColormapEntries == pVisual2->ColormapEntries) &&
		    (pVisual->nplanes == pVisual2->nplanes) &&
		    (pVisual->redMask == pVisual2->redMask) &&
		    (pVisual->greenMask == pVisual2->greenMask) &&
		    (pVisual->blueMask == pVisual2->blueMask) &&
		    (pVisual->offsetRed == pVisual2->offsetRed) &&
		    (pVisual->offsetGreen == pVisual2->offsetGreen) &&
		    (pVisual->offsetBlue == pVisual2->offsetBlue))
		{
                /* We merely assign the first visual that matches.  OpenGL
                   will need to get involved at some point if you want
                   match GLX visuals */
			PanoramiXVisualTable[(pVisual->vid * MAXSCREENS) + j] =
					 pVisual2->vid;
			break;
		}
	    }
	}
	
	/* if it doesn't exist on all screens we can't use it */
	for (j = 0; j < PanoramiXNumScreens; j++) {
	    if (!PanoramiXVisualTable[(pVisual->vid * MAXSCREENS) + j]) {
		PanoramiXVisualTable[pVisual->vid * MAXSCREENS] = 0;
d785 35
a819 24
	/* if it does, make sure it's in the list of supported depths and visuals */
	if(PanoramiXVisualTable[pVisual->vid * MAXSCREENS]) {
	    PanoramiXVisuals[PanoramiXNumVisuals].vid = pVisual->vid;
	    PanoramiXVisuals[PanoramiXNumVisuals].class = pVisual->class;
	    PanoramiXVisuals[PanoramiXNumVisuals].bitsPerRGBValue = pVisual->bitsPerRGBValue;
	    PanoramiXVisuals[PanoramiXNumVisuals].ColormapEntries = pVisual->ColormapEntries;
	    PanoramiXVisuals[PanoramiXNumVisuals].nplanes = pVisual->nplanes;
	    PanoramiXVisuals[PanoramiXNumVisuals].redMask = pVisual->redMask;
	    PanoramiXVisuals[PanoramiXNumVisuals].greenMask = pVisual->greenMask;
	    PanoramiXVisuals[PanoramiXNumVisuals].blueMask = pVisual->blueMask;
	    PanoramiXVisuals[PanoramiXNumVisuals].offsetRed = pVisual->offsetRed;
	    PanoramiXVisuals[PanoramiXNumVisuals].offsetGreen = pVisual->offsetGreen;
	    PanoramiXVisuals[PanoramiXNumVisuals].offsetBlue = pVisual->offsetBlue;
	    PanoramiXNumVisuals++;	

	    for (j = 0; j < PanoramiXNumDepths; j++) {
	        if (PanoramiXDepths[j].depth == pVisual->nplanes) {
		    PanoramiXDepths[j].vids[PanoramiXDepths[j].numVids] = pVisual->vid;
		    PanoramiXDepths[j].numVids++;
		    break;
		}	
	    }   
	}
    } 
d821 2
d824 1
a824 1
    root = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes));
d826 1
a826 1
    defmap = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes));
d828 1
a828 1
    saver = (PanoramiXRes *) xalloc(sizeof(PanoramiXRes));
a830 1

d846 32
d928 1
a928 1
	register int			n;
d931 4
a934 3
	pWin = LookupWindow (stuff->window, client);
	if (!pWin)
	     return BadWindow;
d939 1
d943 1
a943 1
	    swaps (&rep.state, n);
d956 1
a956 1
	register int			n;
d959 4
a962 3
	pWin = LookupWindow (stuff->window, client);
	if (!pWin)
	     return BadWindow;
d967 1
d971 1
a971 1
	    swaps (&rep.ScreenCount, n);
d983 1
a983 1
	register int			n;
d985 3
d989 4
a992 3
	pWin = LookupWindow (stuff->window, client);
	if (!pWin)
	     return BadWindow;
d999 2
d1004 4
a1007 2
	    swaps (&rep.width, n);
	    swaps (&rep.height, n);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d80 1
a80 1
static RegionRec   	PanoramiXScreenRegion = {{0, 0, 0, 0}, NULL};
d112 1
d138 1
a138 1
static GCFuncs XineramaGCFuncs = {
d171 1
a171 1
static Bool
d333 2
d342 20
d367 1
d392 17
d499 1
d961 1
a961 1
	register int			n, rc;
d964 3
a966 4
	rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
	if (rc != Success)
	    return rc;

d987 1
a987 1
	register int			n, rc;
d990 3
a992 4
	rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
	if (rc != Success)
	    return rc;

d1012 1
a1012 1
	register int			n, rc;
d1015 3
a1017 4
	rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
	if (rc != Success)
	    return rc;

@

