head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.56;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.56;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.50;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include <X11/extensions/shapeproto.h>
#include "regionstr.h"
#include "gcstruct.h"
#include "extinit.h"
#include "protocol-versions.h"

typedef RegionPtr (*CreateDftPtr) (WindowPtr    /* pWin */
    );

static int ShapeFreeClient(void * /* data */ ,
                           XID    /* id */
    );
static int ShapeFreeEvents(void * /* data */ ,
                           XID    /* id */
    );
static void SShapeNotifyEvent(xShapeNotifyEvent * /* from */ ,
                              xShapeNotifyEvent *       /* to */
    );

/* SendShapeNotify, CreateBoundingShape and CreateClipShape are used
 * externally by the Xfixes extension and are now defined in window.h
 */

#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif

static int ShapeEventBase = 0;
static RESTYPE ClientType, ShapeEventType;      /* resource types for event masks */

/*
 * each window has a list of clients requesting
 * ShapeNotify events.  Each client has a resource
 * for each window it selects ShapeNotify input for,
 * this resource is used to delete the ShapeNotifyRec
 * entry from the per-window queue.
 */

typedef struct _ShapeEvent *ShapeEventPtr;

typedef struct _ShapeEvent {
    ShapeEventPtr next;
    ClientPtr client;
    WindowPtr window;
    XID clientResource;
} ShapeEventRec;

/****************
 * ShapeExtensionInit
 *
 * Called from InitExtensions in main() or from QueryExtension() if the
 * extension is dynamically loaded.
 *
 ****************/

static int
RegionOperate(ClientPtr client,
              WindowPtr pWin,
              int kind,
              RegionPtr *destRgnp,
              RegionPtr srcRgn, int op, int xoff, int yoff, CreateDftPtr create)
{
    if (srcRgn && (xoff || yoff))
        RegionTranslate(srcRgn, xoff, yoff);
    if (!pWin->parent) {
        if (srcRgn)
            RegionDestroy(srcRgn);
        return Success;
    }

    /* May/30/2001:
     * The shape.PS specs say if src is None, existing shape is to be
     * removed (and so the op-code has no meaning in such removal);
     * see shape.PS, page 3, ShapeMask.
     */
    if (srcRgn == NULL) {
        if (*destRgnp != NULL) {
            RegionDestroy(*destRgnp);
            *destRgnp = 0;
            /* go on to remove shape and generate ShapeNotify */
        }
        else {
            /* May/30/2001:
             * The target currently has no shape in effect, so nothing to
             * do here.  The specs say that ShapeNotify is generated whenever
             * the client region is "modified"; since no modification is done
             * here, we do not generate that event.  The specs does not say
             * "it is an error to request removal when there is no shape in
             * effect", so we return good status.
             */
            return Success;
        }
    }
    else
        switch (op) {
        case ShapeSet:
            if (*destRgnp)
                RegionDestroy(*destRgnp);
            *destRgnp = srcRgn;
            srcRgn = 0;
            break;
        case ShapeUnion:
            if (*destRgnp)
                RegionUnion(*destRgnp, *destRgnp, srcRgn);
            break;
        case ShapeIntersect:
            if (*destRgnp)
                RegionIntersect(*destRgnp, *destRgnp, srcRgn);
            else {
                *destRgnp = srcRgn;
                srcRgn = 0;
            }
            break;
        case ShapeSubtract:
            if (!*destRgnp)
                *destRgnp = (*create) (pWin);
            RegionSubtract(*destRgnp, *destRgnp, srcRgn);
            break;
        case ShapeInvert:
            if (!*destRgnp)
                *destRgnp = RegionCreate((BoxPtr) 0, 0);
            else
                RegionSubtract(*destRgnp, srcRgn, *destRgnp);
            break;
        default:
            client->errorValue = op;
            return BadValue;
        }
    if (srcRgn)
        RegionDestroy(srcRgn);
    (*pWin->drawable.pScreen->SetShape) (pWin, kind);
    SendShapeNotify(pWin, kind);
    return Success;
}

RegionPtr
CreateBoundingShape(WindowPtr pWin)
{
    BoxRec extents;

    extents.x1 = -wBorderWidth(pWin);
    extents.y1 = -wBorderWidth(pWin);
    extents.x2 = pWin->drawable.width + wBorderWidth(pWin);
    extents.y2 = pWin->drawable.height + wBorderWidth(pWin);
    return RegionCreate(&extents, 1);
}

RegionPtr
CreateClipShape(WindowPtr pWin)
{
    BoxRec extents;

    extents.x1 = 0;
    extents.y1 = 0;
    extents.x2 = pWin->drawable.width;
    extents.y2 = pWin->drawable.height;
    return RegionCreate(&extents, 1);
}

static int
ProcShapeQueryVersion(ClientPtr client)
{
    xShapeQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = SERVER_SHAPE_MAJOR_VERSION,
        .minorVersion = SERVER_SHAPE_MINOR_VERSION
    };

    REQUEST_SIZE_MATCH(xShapeQueryVersionReq);

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.majorVersion);
        swaps(&rep.minorVersion);
    }
    WriteToClient(client, sizeof(xShapeQueryVersionReply), &rep);
    return Success;
}

/*****************
 * ProcShapeRectangles
 *
 *****************/

static int
ProcShapeRectangles(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xShapeRectanglesReq);
    xRectangle *prects;
    int nrects, ctype, rc;
    RegionPtr srcRgn;
    RegionPtr *destRgn;
    CreateDftPtr createDefault;

    REQUEST_AT_LEAST_SIZE(xShapeRectanglesReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;
    switch (stuff->destKind) {
    case ShapeBounding:
        createDefault = CreateBoundingShape;
        break;
    case ShapeClip:
        createDefault = CreateClipShape;
        break;
    case ShapeInput:
        createDefault = CreateBoundingShape;
        break;
    default:
        client->errorValue = stuff->destKind;
        return BadValue;
    }
    if ((stuff->ordering != Unsorted) && (stuff->ordering != YSorted) &&
        (stuff->ordering != YXSorted) && (stuff->ordering != YXBanded)) {
        client->errorValue = stuff->ordering;
        return BadValue;
    }
    nrects = ((stuff->length << 2) - sizeof(xShapeRectanglesReq));
    if (nrects & 4)
        return BadLength;
    nrects >>= 3;
    prects = (xRectangle *) &stuff[1];
    ctype = VerifyRectOrder(nrects, prects, (int) stuff->ordering);
    if (ctype < 0)
        return BadMatch;
    srcRgn = RegionFromRects(nrects, prects, ctype);

    if (!pWin->optional)
        MakeWindowOptional(pWin);
    switch (stuff->destKind) {
    case ShapeBounding:
        destRgn = &pWin->optional->boundingShape;
        break;
    case ShapeClip:
        destRgn = &pWin->optional->clipShape;
        break;
    case ShapeInput:
        destRgn = &pWin->optional->inputShape;
        break;
    default:
        return BadValue;
    }

    return RegionOperate(client, pWin, (int) stuff->destKind,
                         destRgn, srcRgn, (int) stuff->op,
                         stuff->xOff, stuff->yOff, createDefault);
}

#ifdef PANORAMIX
static int
ProcPanoramiXShapeRectangles(ClientPtr client)
{
    REQUEST(xShapeRectanglesReq);
    PanoramiXRes *win;
    int j, result;

    REQUEST_AT_LEAST_SIZE(xShapeRectanglesReq);

    result = dixLookupResourceByType((void **) &win, stuff->dest, XRT_WINDOW,
                                     client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS(j) {
        stuff->dest = win->info[j].id;
        result = ProcShapeRectangles(client);
        if (result != Success)
            break;
    }
    return result;
}
#endif

/**************
 * ProcShapeMask
 **************/

static int
ProcShapeMask(ClientPtr client)
{
    WindowPtr pWin;
    ScreenPtr pScreen;

    REQUEST(xShapeMaskReq);
    RegionPtr srcRgn;
    RegionPtr *destRgn;
    PixmapPtr pPixmap;
    CreateDftPtr createDefault;
    int rc;

    REQUEST_SIZE_MATCH(xShapeMaskReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;
    switch (stuff->destKind) {
    case ShapeBounding:
        createDefault = CreateBoundingShape;
        break;
    case ShapeClip:
        createDefault = CreateClipShape;
        break;
    case ShapeInput:
        createDefault = CreateBoundingShape;
        break;
    default:
        client->errorValue = stuff->destKind;
        return BadValue;
    }
    pScreen = pWin->drawable.pScreen;
    if (stuff->src == None)
        srcRgn = 0;
    else {
        rc = dixLookupResourceByType((void **) &pPixmap, stuff->src,
                                     RT_PIXMAP, client, DixReadAccess);
        if (rc != Success)
            return rc;
        if (pPixmap->drawable.pScreen != pScreen ||
            pPixmap->drawable.depth != 1)
            return BadMatch;
        srcRgn = BitmapToRegion(pScreen, pPixmap);
        if (!srcRgn)
            return BadAlloc;
    }

    if (!pWin->optional)
        MakeWindowOptional(pWin);
    switch (stuff->destKind) {
    case ShapeBounding:
        destRgn = &pWin->optional->boundingShape;
        break;
    case ShapeClip:
        destRgn = &pWin->optional->clipShape;
        break;
    case ShapeInput:
        destRgn = &pWin->optional->inputShape;
        break;
    default:
        return BadValue;
    }

    return RegionOperate(client, pWin, (int) stuff->destKind,
                         destRgn, srcRgn, (int) stuff->op,
                         stuff->xOff, stuff->yOff, createDefault);
}

#ifdef PANORAMIX
static int
ProcPanoramiXShapeMask(ClientPtr client)
{
    REQUEST(xShapeMaskReq);
    PanoramiXRes *win, *pmap;
    int j, result;

    REQUEST_SIZE_MATCH(xShapeMaskReq);

    result = dixLookupResourceByType((void **) &win, stuff->dest, XRT_WINDOW,
                                     client, DixWriteAccess);
    if (result != Success)
        return result;

    if (stuff->src != None) {
        result = dixLookupResourceByType((void **) &pmap, stuff->src,
                                         XRT_PIXMAP, client, DixReadAccess);
        if (result != Success)
            return result;
    }
    else
        pmap = NULL;

    FOR_NSCREENS(j) {
        stuff->dest = win->info[j].id;
        if (pmap)
            stuff->src = pmap->info[j].id;
        result = ProcShapeMask(client);
        if (result != Success)
            break;
    }
    return result;
}
#endif

/************
 * ProcShapeCombine
 ************/

static int
ProcShapeCombine(ClientPtr client)
{
    WindowPtr pSrcWin, pDestWin;

    REQUEST(xShapeCombineReq);
    RegionPtr srcRgn;
    RegionPtr *destRgn;
    CreateDftPtr createDefault;
    CreateDftPtr createSrc;
    RegionPtr tmp;
    int rc;

    REQUEST_SIZE_MATCH(xShapeCombineReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pDestWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;
    if (!pDestWin->optional)
        MakeWindowOptional(pDestWin);
    switch (stuff->destKind) {
    case ShapeBounding:
        createDefault = CreateBoundingShape;
        break;
    case ShapeClip:
        createDefault = CreateClipShape;
        break;
    case ShapeInput:
        createDefault = CreateBoundingShape;
        break;
    default:
        client->errorValue = stuff->destKind;
        return BadValue;
    }

    rc = dixLookupWindow(&pSrcWin, stuff->src, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    switch (stuff->srcKind) {
    case ShapeBounding:
        srcRgn = wBoundingShape(pSrcWin);
        createSrc = CreateBoundingShape;
        break;
    case ShapeClip:
        srcRgn = wClipShape(pSrcWin);
        createSrc = CreateClipShape;
        break;
    case ShapeInput:
        srcRgn = wInputShape(pSrcWin);
        createSrc = CreateBoundingShape;
        break;
    default:
        client->errorValue = stuff->srcKind;
        return BadValue;
    }
    if (pSrcWin->drawable.pScreen != pDestWin->drawable.pScreen) {
        return BadMatch;
    }

    if (srcRgn) {
        tmp = RegionCreate((BoxPtr) 0, 0);
        RegionCopy(tmp, srcRgn);
        srcRgn = tmp;
    }
    else
        srcRgn = (*createSrc) (pSrcWin);

    if (!pDestWin->optional)
        MakeWindowOptional(pDestWin);
    switch (stuff->destKind) {
    case ShapeBounding:
        destRgn = &pDestWin->optional->boundingShape;
        break;
    case ShapeClip:
        destRgn = &pDestWin->optional->clipShape;
        break;
    case ShapeInput:
        destRgn = &pDestWin->optional->inputShape;
        break;
    default:
        return BadValue;
    }

    return RegionOperate(client, pDestWin, (int) stuff->destKind,
                         destRgn, srcRgn, (int) stuff->op,
                         stuff->xOff, stuff->yOff, createDefault);
}

#ifdef PANORAMIX
static int
ProcPanoramiXShapeCombine(ClientPtr client)
{
    REQUEST(xShapeCombineReq);
    PanoramiXRes *win, *win2;
    int j, result;

    REQUEST_AT_LEAST_SIZE(xShapeCombineReq);

    result = dixLookupResourceByType((void **) &win, stuff->dest, XRT_WINDOW,
                                     client, DixWriteAccess);
    if (result != Success)
        return result;

    result = dixLookupResourceByType((void **) &win2, stuff->src, XRT_WINDOW,
                                     client, DixReadAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS(j) {
        stuff->dest = win->info[j].id;
        stuff->src = win2->info[j].id;
        result = ProcShapeCombine(client);
        if (result != Success)
            break;
    }
    return result;
}
#endif

/*************
 * ProcShapeOffset
 *************/

static int
ProcShapeOffset(ClientPtr client)
{
    WindowPtr pWin;

    REQUEST(xShapeOffsetReq);
    RegionPtr srcRgn;
    int rc;

    REQUEST_SIZE_MATCH(xShapeOffsetReq);
    UpdateCurrentTime();
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixSetAttrAccess);
    if (rc != Success)
        return rc;
    switch (stuff->destKind) {
    case ShapeBounding:
        srcRgn = wBoundingShape(pWin);
        break;
    case ShapeClip:
        srcRgn = wClipShape(pWin);
        break;
    case ShapeInput:
        srcRgn = wInputShape(pWin);
        break;
    default:
        client->errorValue = stuff->destKind;
        return BadValue;
    }
    if (srcRgn) {
        RegionTranslate(srcRgn, stuff->xOff, stuff->yOff);
        (*pWin->drawable.pScreen->SetShape) (pWin, stuff->destKind);
    }
    SendShapeNotify(pWin, (int) stuff->destKind);
    return Success;
}

#ifdef PANORAMIX
static int
ProcPanoramiXShapeOffset(ClientPtr client)
{
    REQUEST(xShapeOffsetReq);
    PanoramiXRes *win;
    int j, result;

    REQUEST_AT_LEAST_SIZE(xShapeOffsetReq);

    result = dixLookupResourceByType((void **) &win, stuff->dest, XRT_WINDOW,
                                     client, DixWriteAccess);
    if (result != Success)
        return result;

    FOR_NSCREENS(j) {
        stuff->dest = win->info[j].id;
        result = ProcShapeOffset(client);
        if (result != Success)
            break;
    }
    return result;
}
#endif

static int
ProcShapeQueryExtents(ClientPtr client)
{
    REQUEST(xShapeQueryExtentsReq);
    WindowPtr pWin;
    xShapeQueryExtentsReply rep;
    BoxRec extents, *pExtents;
    int rc;
    RegionPtr region;

    REQUEST_SIZE_MATCH(xShapeQueryExtentsReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    rep = (xShapeQueryExtentsReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .boundingShaped = (wBoundingShape(pWin) != 0),
        .clipShaped = (wClipShape(pWin) != 0)
    };
    if ((region = wBoundingShape(pWin))) {
        /* this is done in two steps because of a compiler bug on SunOS 4.1.3 */
        pExtents = RegionExtents(region);
        extents = *pExtents;
    }
    else {
        extents.x1 = -wBorderWidth(pWin);
        extents.y1 = -wBorderWidth(pWin);
        extents.x2 = pWin->drawable.width + wBorderWidth(pWin);
        extents.y2 = pWin->drawable.height + wBorderWidth(pWin);
    }
    rep.xBoundingShape = extents.x1;
    rep.yBoundingShape = extents.y1;
    rep.widthBoundingShape = extents.x2 - extents.x1;
    rep.heightBoundingShape = extents.y2 - extents.y1;
    if ((region = wClipShape(pWin))) {
        /* this is done in two steps because of a compiler bug on SunOS 4.1.3 */
        pExtents = RegionExtents(region);
        extents = *pExtents;
    }
    else {
        extents.x1 = 0;
        extents.y1 = 0;
        extents.x2 = pWin->drawable.width;
        extents.y2 = pWin->drawable.height;
    }
    rep.xClipShape = extents.x1;
    rep.yClipShape = extents.y1;
    rep.widthClipShape = extents.x2 - extents.x1;
    rep.heightClipShape = extents.y2 - extents.y1;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swaps(&rep.xBoundingShape);
        swaps(&rep.yBoundingShape);
        swaps(&rep.widthBoundingShape);
        swaps(&rep.heightBoundingShape);
        swaps(&rep.xClipShape);
        swaps(&rep.yClipShape);
        swaps(&rep.widthClipShape);
        swaps(&rep.heightClipShape);
    }
    WriteToClient(client, sizeof(xShapeQueryExtentsReply), &rep);
    return Success;
}

 /*ARGSUSED*/ static int
ShapeFreeClient(void *data, XID id)
{
    ShapeEventPtr pShapeEvent;
    WindowPtr pWin;
    ShapeEventPtr *pHead, pCur, pPrev;
    int rc;

    pShapeEvent = (ShapeEventPtr) data;
    pWin = pShapeEvent->window;
    rc = dixLookupResourceByType((void **) &pHead, pWin->drawable.id,
                                 ShapeEventType, serverClient, DixReadAccess);
    if (rc == Success) {
        pPrev = 0;
        for (pCur = *pHead; pCur && pCur != pShapeEvent; pCur = pCur->next)
            pPrev = pCur;
        if (pCur) {
            if (pPrev)
                pPrev->next = pShapeEvent->next;
            else
                *pHead = pShapeEvent->next;
        }
    }
    free((void *) pShapeEvent);
    return 1;
}

 /*ARGSUSED*/ static int
ShapeFreeEvents(void *data, XID id)
{
    ShapeEventPtr *pHead, pCur, pNext;

    pHead = (ShapeEventPtr *) data;
    for (pCur = *pHead; pCur; pCur = pNext) {
        pNext = pCur->next;
        FreeResource(pCur->clientResource, ClientType);
        free((void *) pCur);
    }
    free((void *) pHead);
    return 1;
}

static int
ProcShapeSelectInput(ClientPtr client)
{
    REQUEST(xShapeSelectInputReq);
    WindowPtr pWin;
    ShapeEventPtr pShapeEvent, pNewShapeEvent, *pHead;
    XID clientResource;
    int rc;

    REQUEST_SIZE_MATCH(xShapeSelectInputReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixReceiveAccess);
    if (rc != Success)
        return rc;
    rc = dixLookupResourceByType((void **) &pHead, pWin->drawable.id,
                                 ShapeEventType, client, DixWriteAccess);
    if (rc != Success && rc != BadValue)
        return rc;

    switch (stuff->enable) {
    case xTrue:
        if (pHead) {

            /* check for existing entry. */
            for (pShapeEvent = *pHead;
                 pShapeEvent; pShapeEvent = pShapeEvent->next) {
                if (pShapeEvent->client == client)
                    return Success;
            }
        }

        /* build the entry */
        pNewShapeEvent = malloc(sizeof(ShapeEventRec));
        if (!pNewShapeEvent)
            return BadAlloc;
        pNewShapeEvent->next = 0;
        pNewShapeEvent->client = client;
        pNewShapeEvent->window = pWin;
        /*
         * add a resource that will be deleted when
         * the client goes away
         */
        clientResource = FakeClientID(client->index);
        pNewShapeEvent->clientResource = clientResource;
        if (!AddResource(clientResource, ClientType, (void *) pNewShapeEvent))
            return BadAlloc;
        /*
         * create a resource to contain a void *to the list
         * of clients selecting input.  This must be indirect as
         * the list may be arbitrarily rearranged which cannot be
         * done through the resource database.
         */
        if (!pHead) {
            pHead = malloc(sizeof(ShapeEventPtr));
            if (!pHead ||
                !AddResource(pWin->drawable.id, ShapeEventType,
                             (void *) pHead)) {
                FreeResource(clientResource, RT_NONE);
                return BadAlloc;
            }
            *pHead = 0;
        }
        pNewShapeEvent->next = *pHead;
        *pHead = pNewShapeEvent;
        break;
    case xFalse:
        /* delete the interest */
        if (pHead) {
            pNewShapeEvent = 0;
            for (pShapeEvent = *pHead; pShapeEvent;
                 pShapeEvent = pShapeEvent->next) {
                if (pShapeEvent->client == client)
                    break;
                pNewShapeEvent = pShapeEvent;
            }
            if (pShapeEvent) {
                FreeResource(pShapeEvent->clientResource, ClientType);
                if (pNewShapeEvent)
                    pNewShapeEvent->next = pShapeEvent->next;
                else
                    *pHead = pShapeEvent->next;
                free(pShapeEvent);
            }
        }
        break;
    default:
        client->errorValue = stuff->enable;
        return BadValue;
    }
    return Success;
}

/*
 * deliver the event
 */

void
SendShapeNotify(WindowPtr pWin, int which)
{
    ShapeEventPtr *pHead, pShapeEvent;
    BoxRec extents;
    RegionPtr region;
    BYTE shaped;
    int rc;

    rc = dixLookupResourceByType((void **) &pHead, pWin->drawable.id,
                                 ShapeEventType, serverClient, DixReadAccess);
    if (rc != Success)
        return;
    switch (which) {
    case ShapeBounding:
        region = wBoundingShape(pWin);
        if (region) {
            extents = *RegionExtents(region);
            shaped = xTrue;
        }
        else {
            extents.x1 = -wBorderWidth(pWin);
            extents.y1 = -wBorderWidth(pWin);
            extents.x2 = pWin->drawable.width + wBorderWidth(pWin);
            extents.y2 = pWin->drawable.height + wBorderWidth(pWin);
            shaped = xFalse;
        }
        break;
    case ShapeClip:
        region = wClipShape(pWin);
        if (region) {
            extents = *RegionExtents(region);
            shaped = xTrue;
        }
        else {
            extents.x1 = 0;
            extents.y1 = 0;
            extents.x2 = pWin->drawable.width;
            extents.y2 = pWin->drawable.height;
            shaped = xFalse;
        }
        break;
    case ShapeInput:
        region = wInputShape(pWin);
        if (region) {
            extents = *RegionExtents(region);
            shaped = xTrue;
        }
        else {
            extents.x1 = -wBorderWidth(pWin);
            extents.y1 = -wBorderWidth(pWin);
            extents.x2 = pWin->drawable.width + wBorderWidth(pWin);
            extents.y2 = pWin->drawable.height + wBorderWidth(pWin);
            shaped = xFalse;
        }
        break;
    default:
        return;
    }
    for (pShapeEvent = *pHead; pShapeEvent; pShapeEvent = pShapeEvent->next) {
        xShapeNotifyEvent se = {
            .type = ShapeNotify + ShapeEventBase,
            .kind = which,
            .window = pWin->drawable.id,
            .x = extents.x1,
            .y = extents.y1,
            .width = extents.x2 - extents.x1,
            .height = extents.y2 - extents.y1,
            .time = currentTime.milliseconds,
            .shaped = shaped
        };
        WriteEventsToClient(pShapeEvent->client, 1, (xEvent *) &se);
    }
}

static int
ProcShapeInputSelected(ClientPtr client)
{
    REQUEST(xShapeInputSelectedReq);
    WindowPtr pWin;
    ShapeEventPtr pShapeEvent, *pHead;
    int enabled, rc;
    xShapeInputSelectedReply rep;

    REQUEST_SIZE_MATCH(xShapeInputSelectedReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    rc = dixLookupResourceByType((void **) &pHead, pWin->drawable.id,
                                 ShapeEventType, client, DixReadAccess);
    if (rc != Success && rc != BadValue)
        return rc;
    enabled = xFalse;
    if (pHead) {
        for (pShapeEvent = *pHead; pShapeEvent; pShapeEvent = pShapeEvent->next) {
            if (pShapeEvent->client == client) {
                enabled = xTrue;
                break;
            }
        }
    }
    rep = (xShapeInputSelectedReply) {
        .type = X_Reply,
        .enabled = enabled,
        .sequenceNumber = client->sequence,
        .length = 0
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
    }
    WriteToClient(client, sizeof(xShapeInputSelectedReply), &rep);
    return Success;
}

static int
ProcShapeGetRectangles(ClientPtr client)
{
    REQUEST(xShapeGetRectanglesReq);
    WindowPtr pWin;
    xShapeGetRectanglesReply rep;
    xRectangle *rects;
    int nrects, i, rc;
    RegionPtr region;

    REQUEST_SIZE_MATCH(xShapeGetRectanglesReq);
    rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);
    if (rc != Success)
        return rc;
    switch (stuff->kind) {
    case ShapeBounding:
        region = wBoundingShape(pWin);
        break;
    case ShapeClip:
        region = wClipShape(pWin);
        break;
    case ShapeInput:
        region = wInputShape(pWin);
        break;
    default:
        client->errorValue = stuff->kind;
        return BadValue;
    }
    if (!region) {
        nrects = 1;
        rects = malloc(sizeof(xRectangle));
        if (!rects)
            return BadAlloc;
        switch (stuff->kind) {
        case ShapeBounding:
            rects->x = -(int) wBorderWidth(pWin);
            rects->y = -(int) wBorderWidth(pWin);
            rects->width = pWin->drawable.width + wBorderWidth(pWin);
            rects->height = pWin->drawable.height + wBorderWidth(pWin);
            break;
        case ShapeClip:
            rects->x = 0;
            rects->y = 0;
            rects->width = pWin->drawable.width;
            rects->height = pWin->drawable.height;
            break;
        case ShapeInput:
            rects->x = -(int) wBorderWidth(pWin);
            rects->y = -(int) wBorderWidth(pWin);
            rects->width = pWin->drawable.width + wBorderWidth(pWin);
            rects->height = pWin->drawable.height + wBorderWidth(pWin);
            break;
        }
    }
    else {
        BoxPtr box;

        nrects = RegionNumRects(region);
        box = RegionRects(region);
        rects = xallocarray(nrects, sizeof(xRectangle));
        if (!rects && nrects)
            return BadAlloc;
        for (i = 0; i < nrects; i++, box++) {
            rects[i].x = box->x1;
            rects[i].y = box->y1;
            rects[i].width = box->x2 - box->x1;
            rects[i].height = box->y2 - box->y1;
        }
    }
    rep = (xShapeGetRectanglesReply) {
        .type = X_Reply,
        .ordering = YXBanded,
        .sequenceNumber = client->sequence,
        .length = bytes_to_int32(nrects * sizeof(xRectangle)),
        .nrects = nrects
    };
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.nrects);
        SwapShorts((short *) rects, (unsigned long) nrects * 4);
    }
    WriteToClient(client, sizeof(rep), &rep);
    WriteToClient(client, nrects * sizeof(xRectangle), rects);
    free(rects);
    return Success;
}

static int
ProcShapeDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_ShapeQueryVersion:
        return ProcShapeQueryVersion(client);
    case X_ShapeRectangles:
#ifdef PANORAMIX
        if (!noPanoramiXExtension)
            return ProcPanoramiXShapeRectangles(client);
        else
#endif
            return ProcShapeRectangles(client);
    case X_ShapeMask:
#ifdef PANORAMIX
        if (!noPanoramiXExtension)
            return ProcPanoramiXShapeMask(client);
        else
#endif
            return ProcShapeMask(client);
    case X_ShapeCombine:
#ifdef PANORAMIX
        if (!noPanoramiXExtension)
            return ProcPanoramiXShapeCombine(client);
        else
#endif
            return ProcShapeCombine(client);
    case X_ShapeOffset:
#ifdef PANORAMIX
        if (!noPanoramiXExtension)
            return ProcPanoramiXShapeOffset(client);
        else
#endif
            return ProcShapeOffset(client);
    case X_ShapeQueryExtents:
        return ProcShapeQueryExtents(client);
    case X_ShapeSelectInput:
        return ProcShapeSelectInput(client);
    case X_ShapeInputSelected:
        return ProcShapeInputSelected(client);
    case X_ShapeGetRectangles:
        return ProcShapeGetRectangles(client);
    default:
        return BadRequest;
    }
}

static void
SShapeNotifyEvent(xShapeNotifyEvent * from, xShapeNotifyEvent * to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswapl(from->window, to->window);
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswaps(from->x, to->x);
    cpswaps(from->y, to->y);
    cpswaps(from->width, to->width);
    cpswaps(from->height, to->height);
    cpswapl(from->time, to->time);
    to->shaped = from->shaped;
}

static int
SProcShapeQueryVersion(ClientPtr client)
{
    REQUEST(xShapeQueryVersionReq);

    swaps(&stuff->length);
    return ProcShapeQueryVersion(client);
}

static int
SProcShapeRectangles(ClientPtr client)
{
    REQUEST(xShapeRectanglesReq);

    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xShapeRectanglesReq);
    swapl(&stuff->dest);
    swaps(&stuff->xOff);
    swaps(&stuff->yOff);
    SwapRestS(stuff);
    return ProcShapeRectangles(client);
}

static int
SProcShapeMask(ClientPtr client)
{
    REQUEST(xShapeMaskReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShapeMaskReq);
    swapl(&stuff->dest);
    swaps(&stuff->xOff);
    swaps(&stuff->yOff);
    swapl(&stuff->src);
    return ProcShapeMask(client);
}

static int
SProcShapeCombine(ClientPtr client)
{
    REQUEST(xShapeCombineReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShapeCombineReq);
    swapl(&stuff->dest);
    swaps(&stuff->xOff);
    swaps(&stuff->yOff);
    swapl(&stuff->src);
    return ProcShapeCombine(client);
}

static int
SProcShapeOffset(ClientPtr client)
{
    REQUEST(xShapeOffsetReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShapeOffsetReq);
    swapl(&stuff->dest);
    swaps(&stuff->xOff);
    swaps(&stuff->yOff);
    return ProcShapeOffset(client);
}

static int
SProcShapeQueryExtents(ClientPtr client)
{
    REQUEST(xShapeQueryExtentsReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShapeQueryExtentsReq);
    swapl(&stuff->window);
    return ProcShapeQueryExtents(client);
}

static int
SProcShapeSelectInput(ClientPtr client)
{
    REQUEST(xShapeSelectInputReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShapeSelectInputReq);
    swapl(&stuff->window);
    return ProcShapeSelectInput(client);
}

static int
SProcShapeInputSelected(ClientPtr client)
{
    REQUEST(xShapeInputSelectedReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShapeInputSelectedReq);
    swapl(&stuff->window);
    return ProcShapeInputSelected(client);
}

static int
SProcShapeGetRectangles(ClientPtr client)
{
    REQUEST(xShapeGetRectanglesReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xShapeGetRectanglesReq);
    swapl(&stuff->window);
    return ProcShapeGetRectangles(client);
}

static int
SProcShapeDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_ShapeQueryVersion:
        return SProcShapeQueryVersion(client);
    case X_ShapeRectangles:
        return SProcShapeRectangles(client);
    case X_ShapeMask:
        return SProcShapeMask(client);
    case X_ShapeCombine:
        return SProcShapeCombine(client);
    case X_ShapeOffset:
        return SProcShapeOffset(client);
    case X_ShapeQueryExtents:
        return SProcShapeQueryExtents(client);
    case X_ShapeSelectInput:
        return SProcShapeSelectInput(client);
    case X_ShapeInputSelected:
        return SProcShapeInputSelected(client);
    case X_ShapeGetRectangles:
        return SProcShapeGetRectangles(client);
    default:
        return BadRequest;
    }
}

void
ShapeExtensionInit(void)
{
    ExtensionEntry *extEntry;

    ClientType = CreateNewResourceType(ShapeFreeClient, "ShapeClient");
    ShapeEventType = CreateNewResourceType(ShapeFreeEvents, "ShapeEvent");
    if (ClientType && ShapeEventType &&
        (extEntry = AddExtension(SHAPENAME, ShapeNumberEvents, 0,
                                 ProcShapeDispatch, SProcShapeDispatch,
                                 NULL, StandardMinorOpcode))) {
        ShapeEventBase = extEntry->eventBase;
        EventSwapVector[ShapeEventBase] = (EventSwapPtr) SShapeNotifyEvent;
    }
}
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d999 1
a999 1
        rects = malloc(nrects * sizeof(xRectangle));
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d53 2
a54 2
static int ShapeFreeClient(pointer /* data */ ,
                           XID  /* id */
d56 2
a57 2
static int ShapeFreeEvents(pointer /* data */ ,
                           XID  /* id */
d309 1
a309 1
    result = dixLookupResourceByType((pointer *) &win, stuff->dest, XRT_WINDOW,
d364 1
a364 1
        rc = dixLookupResourceByType((pointer *) &pPixmap, stuff->src,
d407 1
a407 1
    result = dixLookupResourceByType((pointer *) &win, stuff->dest, XRT_WINDOW,
d413 1
a413 1
        result = dixLookupResourceByType((pointer *) &pmap, stuff->src,
d535 1
a535 1
    result = dixLookupResourceByType((pointer *) &win, stuff->dest, XRT_WINDOW,
d540 1
a540 1
    result = dixLookupResourceByType((pointer *) &win2, stuff->src, XRT_WINDOW,
d606 1
a606 1
    result = dixLookupResourceByType((pointer *) &win, stuff->dest, XRT_WINDOW,
d689 1
a689 1
ShapeFreeClient(pointer data, XID id)
d698 1
a698 1
    rc = dixLookupResourceByType((pointer *) &pHead, pWin->drawable.id,
d711 1
a711 1
    free((pointer) pShapeEvent);
d716 1
a716 1
ShapeFreeEvents(pointer data, XID id)
d724 1
a724 1
        free((pointer) pCur);
d726 1
a726 1
    free((pointer) pHead);
d743 1
a743 1
    rc = dixLookupResourceByType((pointer *) &pHead, pWin->drawable.id,
d773 1
a773 1
        if (!AddResource(clientResource, ClientType, (pointer) pNewShapeEvent))
d776 1
a776 1
         * create a resource to contain a pointer to the list
d785 1
a785 1
                             (pointer) pHead)) {
d834 1
a834 1
    rc = dixLookupResourceByType((pointer *) &pHead, pWin->drawable.id,
d913 1
a913 1
    rc = dixLookupResourceByType((pointer *) &pHead, pWin->drawable.id,
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d47 1
a47 1
#include "modinit.h"
d207 7
a213 1
    xShapeQueryVersionReply rep;
d216 1
a216 6
    memset(&rep, 0, sizeof(xShapeQueryVersionReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_SHAPE_MAJOR_VERSION;
    rep.minorVersion = SERVER_SHAPE_MINOR_VERSION;
d223 1
a223 1
    WriteToClient(client, sizeof(xShapeQueryVersionReply), (char *) &rep);
d635 7
a641 6
    memset(&rep, 0, sizeof(xShapeQueryExtentsReply));
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.boundingShaped = (wBoundingShape(pWin) != 0);
    rep.clipShaped = (wClipShape(pWin) != 0);
d684 1
a684 1
    WriteToClient(client, sizeof(xShapeQueryExtentsReply), (char *) &rep);
a828 1
    xShapeNotifyEvent se;
d885 11
a895 9
        se.type = ShapeNotify + ShapeEventBase;
        se.kind = which;
        se.window = pWin->drawable.id;
        se.x = extents.x1;
        se.y = extents.y1;
        se.width = extents.x2 - extents.x1;
        se.height = extents.y2 - extents.y1;
        se.time = currentTime.milliseconds;
        se.shaped = shaped;
d926 6
a931 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.enabled = enabled;
d936 1
a936 1
    WriteToClient(client, sizeof(xShapeInputSelectedReply), (char *) &rep);
d1009 7
a1015 5
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = bytes_to_int32(nrects * sizeof(xRectangle));
    rep.ordering = YXBanded;
    rep.nrects = nrects;
d1022 2
a1023 2
    WriteToClient(client, sizeof(rep), (char *) &rep);
    WriteToClient(client, nrects * sizeof(xRectangle), (char *) rects);
@


1.7
log
@Update to xserver 1.11.2
@
text
@d50 12
a61 16
typedef	RegionPtr (*CreateDftPtr)(
	WindowPtr /* pWin */
	);

static int ShapeFreeClient(
	pointer /* data */,
	XID /* id */
	);
static int ShapeFreeEvents(
	pointer /* data */,
	XID /* id */
	);
static void SShapeNotifyEvent(
	xShapeNotifyEvent * /* from */,
	xShapeNotifyEvent * /* to */
	);
a66 1

d73 1
a73 1
static RESTYPE ClientType, ShapeEventType; /* resource types for event masks */
d86 4
a89 4
    ShapeEventPtr   next;
    ClientPtr	    client;
    WindowPtr	    window;
    XID		    clientResource;
d101 5
a105 9
RegionOperate (
	ClientPtr client,
	WindowPtr pWin,
	int kind,
	RegionPtr *destRgnp,
	RegionPtr srcRgn,
	int op,
	int xoff, int yoff,
	CreateDftPtr create)
d108 5
a112 6
	RegionTranslate(srcRgn, xoff, yoff);
    if (!pWin->parent)
    {
	if (srcRgn)
	    RegionDestroy(srcRgn);
	return Success;
d121 52
a172 51
      if (*destRgnp != NULL) {
	RegionDestroy(*destRgnp);
	*destRgnp = 0;
	/* go on to remove shape and generate ShapeNotify */
      }
      else {
	/* May/30/2001:
	 * The target currently has no shape in effect, so nothing to
	 * do here.  The specs say that ShapeNotify is generated whenever
	 * the client region is "modified"; since no modification is done
	 * here, we do not generate that event.  The specs does not say
	 * "it is an error to request removal when there is no shape in
	 * effect", so we return good status.
	 */
	return Success;
      }
    }
    else switch (op) {
    case ShapeSet:
	if (*destRgnp)
	    RegionDestroy(*destRgnp);
	*destRgnp = srcRgn;
	srcRgn = 0;
	break;
    case ShapeUnion:
	if (*destRgnp)
	    RegionUnion(*destRgnp, *destRgnp, srcRgn);
	break;
    case ShapeIntersect:
	if (*destRgnp)
	    RegionIntersect(*destRgnp, *destRgnp, srcRgn);
	else {
	    *destRgnp = srcRgn;
	    srcRgn = 0;
	}
	break;
    case ShapeSubtract:
	if (!*destRgnp)
	    *destRgnp = (*create)(pWin);
	RegionSubtract(*destRgnp, *destRgnp, srcRgn);
	break;
    case ShapeInvert:
	if (!*destRgnp)
	    *destRgnp = RegionCreate((BoxPtr) 0, 0);
	else
	    RegionSubtract(*destRgnp, srcRgn, *destRgnp);
	break;
    default:
	client->errorValue = op;
	return BadValue;
    }
d174 1
a174 1
	RegionDestroy(srcRgn);
d176 1
a176 1
    SendShapeNotify (pWin, kind);
d181 1
a181 1
CreateBoundingShape (WindowPtr pWin)
d183 1
a183 1
    BoxRec	extents;
d185 4
a188 4
    extents.x1 = -wBorderWidth (pWin);
    extents.y1 = -wBorderWidth (pWin);
    extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
    extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
d193 1
a193 1
CreateClipShape (WindowPtr pWin)
d195 1
a195 1
    BoxRec	extents;
d205 1
a205 1
ProcShapeQueryVersion (ClientPtr client)
d207 1
a207 2
    xShapeQueryVersionReply	rep;
    int		n;
d209 1
a209 1
    REQUEST_SIZE_MATCH (xShapeQueryVersionReq);
d217 4
a220 4
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.majorVersion, n);
	swaps(&rep.minorVersion, n);
d222 1
a222 1
    WriteToClient(client, sizeof (xShapeQueryVersionReply), (char *)&rep);
d232 1
a232 1
ProcShapeRectangles (ClientPtr client)
d234 2
a235 1
    WindowPtr		pWin;
d237 5
a241 5
    xRectangle		*prects;
    int		        nrects, ctype, rc;
    RegionPtr		srcRgn;
    RegionPtr		*destRgn;
    CreateDftPtr	createDefault;
d243 1
a243 1
    REQUEST_AT_LEAST_SIZE (xShapeRectanglesReq);
d247 1
a247 1
	return rc;
d250 2
a251 2
	createDefault = CreateBoundingShape;
	break;
d253 2
a254 2
	createDefault = CreateClipShape;
	break;
d256 2
a257 2
	createDefault = CreateBoundingShape;
	break;
d259 2
a260 2
	client->errorValue = stuff->destKind;
	return BadValue;
d263 2
a264 3
	(stuff->ordering != YXSorted) && (stuff->ordering != YXBanded))
    {
	client->errorValue = stuff->ordering;
d267 1
a267 1
    nrects = ((stuff->length  << 2) - sizeof(xShapeRectanglesReq));
d269 1
a269 1
	return BadLength;
d272 1
a272 1
    ctype = VerifyRectOrder(nrects, prects, (int)stuff->ordering);
d274 1
a274 1
	return BadMatch;
d278 1
a278 1
	MakeWindowOptional (pWin);
d281 2
a282 2
	destRgn = &pWin->optional->boundingShape;
	break;
d284 2
a285 2
	destRgn = &pWin->optional->clipShape;
	break;
d287 2
a288 2
	destRgn = &pWin->optional->inputShape;
	break;
d290 1
a290 1
	return BadValue;
d293 3
a295 3
    return RegionOperate (client, pWin, (int)stuff->destKind,
			  destRgn, srcRgn, (int)stuff->op,
			  stuff->xOff, stuff->yOff, createDefault);
d300 1
a300 2
ProcPanoramiXShapeRectangles(
    ClientPtr client)
d303 2
a304 2
    PanoramiXRes	*win;
    int        		j, result;
d306 1
a306 1
    REQUEST_AT_LEAST_SIZE (xShapeRectanglesReq);
d308 2
a309 2
    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
d311 1
a311 1
	return result;
d314 4
a317 3
	stuff->dest = win->info[j].id;
	result = ProcShapeRectangles (client);
	if (result != Success) break;
a322 1

a326 1

d328 1
a328 1
ProcShapeMask (ClientPtr client)
d330 3
a332 2
    WindowPtr		pWin;
    ScreenPtr		pScreen;
d334 5
a338 5
    RegionPtr		srcRgn;
    RegionPtr		*destRgn;
    PixmapPtr		pPixmap;
    CreateDftPtr	createDefault;
    int			rc;
d340 1
a340 1
    REQUEST_SIZE_MATCH (xShapeMaskReq);
d344 1
a344 1
	return rc;
d347 2
a348 2
	createDefault = CreateBoundingShape;
	break;
d350 2
a351 2
	createDefault = CreateClipShape;
	break;
d353 2
a354 2
	createDefault = CreateBoundingShape;
	break;
d356 2
a357 2
	client->errorValue = stuff->destKind;
	return BadValue;
d361 1
a361 1
	srcRgn = 0;
d363 2
a364 2
	rc = dixLookupResourceByType((pointer *)&pPixmap, stuff->src, RT_PIXMAP,
			       client, DixReadAccess);
d366 7
a372 7
	    return rc;
	if (pPixmap->drawable.pScreen != pScreen ||
	    pPixmap->drawable.depth != 1)
	    return BadMatch;
	srcRgn = BitmapToRegion(pScreen, pPixmap);
	if (!srcRgn)
	    return BadAlloc;
d376 1
a376 1
	MakeWindowOptional (pWin);
d379 2
a380 2
	destRgn = &pWin->optional->boundingShape;
	break;
d382 2
a383 2
	destRgn = &pWin->optional->clipShape;
	break;
d385 2
a386 2
	destRgn = &pWin->optional->inputShape;
	break;
d388 1
a388 1
	return BadValue;
d391 3
a393 3
    return RegionOperate (client, pWin, (int)stuff->destKind,
			  destRgn, srcRgn, (int)stuff->op,
			  stuff->xOff, stuff->yOff, createDefault);
d398 1
a398 2
ProcPanoramiXShapeMask(
    ClientPtr client)
d401 2
a402 2
    PanoramiXRes	*win, *pmap;
    int 		j, result;
d404 1
a404 1
    REQUEST_SIZE_MATCH (xShapeMaskReq);
d406 2
a407 2
    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
d409 1
a409 1
	return result;
d411 8
a418 7
    if(stuff->src != None) {
	result = dixLookupResourceByType((pointer *)&pmap, stuff->src,
					 XRT_PIXMAP, client, DixReadAccess);
	if (result != Success)
	    return result;
    } else
	pmap = NULL;
d421 6
a426 5
	stuff->dest = win->info[j].id;
	if(pmap)
	    stuff->src  = pmap->info[j].id;
	result = ProcShapeMask (client);
	if (result != Success) break;
a431 1

d437 1
a437 1
ProcShapeCombine (ClientPtr client)
d439 2
a440 1
    WindowPtr		pSrcWin, pDestWin;
d442 6
a447 6
    RegionPtr		srcRgn;
    RegionPtr		*destRgn;
    CreateDftPtr	createDefault;
    CreateDftPtr	createSrc;
    RegionPtr		tmp;
    int			rc;
d449 1
a449 1
    REQUEST_SIZE_MATCH (xShapeCombineReq);
d453 1
a453 1
	return rc;
d455 1
a455 1
	MakeWindowOptional (pDestWin);
d458 2
a459 2
	createDefault = CreateBoundingShape;
	break;
d461 2
a462 2
	createDefault = CreateClipShape;
	break;
d464 2
a465 2
	createDefault = CreateBoundingShape;
	break;
d467 2
a468 2
	client->errorValue = stuff->destKind;
	return BadValue;
d473 1
a473 1
	return rc;
d476 3
a478 3
	srcRgn = wBoundingShape (pSrcWin);
	createSrc = CreateBoundingShape;
	break;
d480 3
a482 3
	srcRgn = wClipShape (pSrcWin);
	createSrc = CreateClipShape;
	break;
d484 3
a486 3
	srcRgn = wInputShape (pSrcWin);
	createSrc = CreateBoundingShape;
	break;
d488 2
a489 2
	client->errorValue = stuff->srcKind;
	return BadValue;
d491 2
a492 3
    if (pSrcWin->drawable.pScreen != pDestWin->drawable.pScreen)
    {
	return BadMatch;
d499 3
a501 2
    } else
	srcRgn = (*createSrc) (pSrcWin);
d504 1
a504 1
	MakeWindowOptional (pDestWin);
d507 2
a508 2
	destRgn = &pDestWin->optional->boundingShape;
	break;
d510 2
a511 2
	destRgn = &pDestWin->optional->clipShape;
	break;
d513 2
a514 2
	destRgn = &pDestWin->optional->inputShape;
	break;
d516 1
a516 1
	return BadValue;
d519 3
a521 3
    return RegionOperate (client, pDestWin, (int)stuff->destKind,
			  destRgn, srcRgn, (int)stuff->op,
			  stuff->xOff, stuff->yOff, createDefault);
a523 1

d526 1
a526 2
ProcPanoramiXShapeCombine(
    ClientPtr client)
d529 2
a530 2
    PanoramiXRes	*win, *win2;
    int 		j, result;
d532 1
a532 1
    REQUEST_AT_LEAST_SIZE (xShapeCombineReq);
d534 2
a535 2
    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
d537 1
a537 1
	return result;
d539 2
a540 2
    result = dixLookupResourceByType((pointer *)&win2, stuff->src, XRT_WINDOW,
				     client, DixReadAccess);
d542 1
a542 1
	return result;
d545 5
a549 4
	stuff->dest = win->info[j].id;
	stuff->src =  win2->info[j].id;
	result = ProcShapeCombine (client);
	if (result != Success) break;
d560 1
a560 1
ProcShapeOffset (ClientPtr client)
d562 2
a563 1
    WindowPtr		pWin;
d565 2
a566 2
    RegionPtr		srcRgn;
    int			rc;
d568 1
a568 1
    REQUEST_SIZE_MATCH (xShapeOffsetReq);
d572 1
a572 1
	return rc;
d575 2
a576 2
	srcRgn = wBoundingShape (pWin);
	break;
d578 2
a579 2
	srcRgn = wClipShape(pWin);
	break;
d581 2
a582 2
	srcRgn = wInputShape (pWin);
	break;
d584 2
a585 2
	client->errorValue = stuff->destKind;
	return BadValue;
d587 1
a587 2
    if (srcRgn)
    {
d591 1
a591 1
    SendShapeNotify (pWin, (int)stuff->destKind);
a594 1

d597 1
a597 2
ProcPanoramiXShapeOffset(
    ClientPtr client)
d603 4
a606 4
    REQUEST_AT_LEAST_SIZE (xShapeOffsetReq);
   
    result = dixLookupResourceByType((pointer *)&win, stuff->dest, XRT_WINDOW,
				     client, DixWriteAccess);
d608 1
a608 1
	return result;
d611 4
a614 3
	stuff->dest = win->info[j].id;
	result = ProcShapeOffset (client);
	if(result != Success) break;
a619 1

d621 1
a621 1
ProcShapeQueryExtents (ClientPtr client)
d624 5
a628 5
    WindowPtr		pWin;
    xShapeQueryExtentsReply	rep;
    BoxRec		extents, *pExtents;
    int	n, rc;
    RegionPtr		region;
d630 1
a630 1
    REQUEST_SIZE_MATCH (xShapeQueryExtentsReq);
d633 1
a633 1
	return rc;
d641 9
a649 8
     /* this is done in two steps because of a compiler bug on SunOS 4.1.3 */
	pExtents = RegionExtents(region);
	extents = *pExtents;
    } else {
	extents.x1 = -wBorderWidth (pWin);
	extents.y1 = -wBorderWidth (pWin);
	extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
	extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
d656 9
a664 8
     /* this is done in two steps because of a compiler bug on SunOS 4.1.3 */
	pExtents = RegionExtents(region);
	extents = *pExtents;
    } else {
	extents.x1 = 0;
	extents.y1 = 0;
	extents.x2 = pWin->drawable.width;
	extents.y2 = pWin->drawable.height;
d671 10
a680 10
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
	swaps(&rep.xBoundingShape, n);
	swaps(&rep.yBoundingShape, n);
	swaps(&rep.widthBoundingShape, n);
	swaps(&rep.heightBoundingShape, n);
	swaps(&rep.xClipShape, n);
	swaps(&rep.yClipShape, n);
	swaps(&rep.widthClipShape, n);
	swaps(&rep.heightClipShape, n);
d682 1
a682 1
    WriteToClient(client, sizeof (xShapeQueryExtentsReply), (char *)&rep);
d686 2
a687 3
/*ARGSUSED*/
static int
ShapeFreeClient (pointer data, XID id)
d689 3
a691 3
    ShapeEventPtr   pShapeEvent;
    WindowPtr	    pWin;
    ShapeEventPtr   *pHead, pCur, pPrev;
d696 2
a697 2
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, serverClient, DixReadAccess);
d699 9
a707 10
	pPrev = 0;
	for (pCur = *pHead; pCur && pCur != pShapeEvent; pCur=pCur->next)
	    pPrev = pCur;
	if (pCur)
	{
	    if (pPrev)
	    	pPrev->next = pShapeEvent->next;
	    else
	    	*pHead = pShapeEvent->next;
	}
d713 2
a714 3
/*ARGSUSED*/
static int
ShapeFreeEvents (pointer data, XID id)
d716 1
a716 1
    ShapeEventPtr   *pHead, pCur, pNext;
d720 3
a722 3
	pNext = pCur->next;
	FreeResource (pCur->clientResource, ClientType);
	free((pointer) pCur);
d729 1
a729 1
ProcShapeSelectInput (ClientPtr client)
d732 4
a735 4
    WindowPtr		pWin;
    ShapeEventPtr	pShapeEvent, pNewShapeEvent, *pHead;
    XID			clientResource;
    int			rc;
d737 1
a737 1
    REQUEST_SIZE_MATCH (xShapeSelectInputReq);
d740 3
a742 3
	return rc;
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, client, DixWriteAccess);
d744 1
a744 1
	return rc;
d748 1
a748 1
	if (pHead) {
d750 42
a791 45
	    /* check for existing entry. */
	    for (pShapeEvent = *pHead;
		 pShapeEvent;
 		 pShapeEvent = pShapeEvent->next)
	    {
		if (pShapeEvent->client == client)
		    return Success;
	    }
	}

	/* build the entry */
	pNewShapeEvent = malloc(sizeof (ShapeEventRec));
    	if (!pNewShapeEvent)
	    return BadAlloc;
    	pNewShapeEvent->next = 0;
    	pNewShapeEvent->client = client;
    	pNewShapeEvent->window = pWin;
    	/*
 	 * add a resource that will be deleted when
     	 * the client goes away
     	 */
   	clientResource = FakeClientID (client->index);
    	pNewShapeEvent->clientResource = clientResource;
    	if (!AddResource (clientResource, ClientType, (pointer)pNewShapeEvent))
	    return BadAlloc;
    	/*
     	 * create a resource to contain a pointer to the list
     	 * of clients selecting input.  This must be indirect as
     	 * the list may be arbitrarily rearranged which cannot be
     	 * done through the resource database.
     	 */
    	if (!pHead)
    	{
	    pHead = malloc(sizeof (ShapeEventPtr));
	    if (!pHead ||
		!AddResource (pWin->drawable.id, ShapeEventType, (pointer)pHead))
	    {
	    	FreeResource (clientResource, RT_NONE);
	    	return BadAlloc;
	    }
	    *pHead = 0;
    	}
    	pNewShapeEvent->next = *pHead;
    	*pHead = pNewShapeEvent;
	break;
d793 19
a811 18
	/* delete the interest */
	if (pHead) {
	    pNewShapeEvent = 0;
	    for (pShapeEvent = *pHead; pShapeEvent; pShapeEvent = pShapeEvent->next) {
		if (pShapeEvent->client == client)
		    break;
		pNewShapeEvent = pShapeEvent;
	    }
	    if (pShapeEvent) {
		FreeResource (pShapeEvent->clientResource, ClientType);
		if (pNewShapeEvent)
		    pNewShapeEvent->next = pShapeEvent->next;
		else
		    *pHead = pShapeEvent->next;
		free(pShapeEvent);
	    }
	}
	break;
d813 2
a814 2
	client->errorValue = stuff->enable;
	return BadValue;
d824 1
a824 1
SendShapeNotify (WindowPtr pWin, int which)
d826 5
a830 5
    ShapeEventPtr	*pHead, pShapeEvent;
    xShapeNotifyEvent	se;
    BoxRec		extents;
    RegionPtr		region;
    BYTE		shaped;
d833 2
a834 2
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, serverClient, DixReadAccess);
d836 1
a836 1
	return;
d839 13
a851 12
	region = wBoundingShape(pWin);
	if (region) {
	    extents = *RegionExtents(region);
	    shaped = xTrue;
	} else {
	    extents.x1 = -wBorderWidth (pWin);
	    extents.y1 = -wBorderWidth (pWin);
	    extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
	    extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
	    shaped = xFalse;
	}
	break;
d853 13
a865 12
	region = wClipShape(pWin);
	if (region) {
	    extents = *RegionExtents(region);
	    shaped = xTrue;
	} else {
	    extents.x1 = 0;
	    extents.y1 = 0;
	    extents.x2 = pWin->drawable.width;
	    extents.y2 = pWin->drawable.height;
	    shaped = xFalse;
	}
	break;
d867 13
a879 12
	region = wInputShape(pWin);
	if (region) {
	    extents = *RegionExtents(region);
	    shaped = xTrue;
	} else {
	    extents.x1 = -wBorderWidth (pWin);
	    extents.y1 = -wBorderWidth (pWin);
	    extents.x2 = pWin->drawable.width + wBorderWidth (pWin);
	    extents.y2 = pWin->drawable.height + wBorderWidth (pWin);
	    shaped = xFalse;
	}
	break;
d881 1
a881 1
	return;
d884 10
a893 10
	se.type = ShapeNotify + ShapeEventBase;
	se.kind = which;
	se.window = pWin->drawable.id;
	se.x = extents.x1;
	se.y = extents.y1;
	se.width = extents.x2 - extents.x1;
	se.height = extents.y2 - extents.y1;
	se.time = currentTime.milliseconds;
	se.shaped = shaped;
	WriteEventsToClient (pShapeEvent->client, 1, (xEvent *) &se);
d898 1
a898 1
ProcShapeInputSelected (ClientPtr client)
d901 4
a904 5
    WindowPtr		pWin;
    ShapeEventPtr	pShapeEvent, *pHead;
    int			enabled, rc;
    xShapeInputSelectedReply	rep;
    int		n;
d906 1
a906 1
    REQUEST_SIZE_MATCH (xShapeInputSelectedReq);
d909 3
a911 3
	return rc;
    rc = dixLookupResourceByType((pointer *)&pHead, pWin->drawable.id,
				 ShapeEventType, client, DixReadAccess);
d913 1
a913 1
	return rc;
d916 6
a921 9
    	for (pShapeEvent = *pHead;
	     pShapeEvent;
	     pShapeEvent = pShapeEvent->next)
    	{
	    if (pShapeEvent->client == client) {
	    	enabled = xTrue;
		break;
	    }
    	}
d928 2
a929 2
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
d931 1
a931 1
    WriteToClient (client, sizeof (xShapeInputSelectedReply), (char *) &rep);
d936 1
a936 1
ProcShapeGetRectangles (ClientPtr client)
d939 5
a943 6
    WindowPtr			pWin;
    xShapeGetRectanglesReply	rep;
    xRectangle			*rects;
    int				nrects, i, rc;
    RegionPtr			region;
    int		n;
d948 1
a948 1
	return rc;
d951 2
a952 2
	region = wBoundingShape(pWin);
	break;
d954 2
a955 2
	region = wClipShape(pWin);
	break;
d957 2
a958 2
	region = wInputShape (pWin);
	break;
d960 2
a961 2
	client->errorValue = stuff->kind;
	return BadValue;
d964 39
a1002 37
	nrects = 1;
	rects = malloc(sizeof (xRectangle));
	if (!rects)
	    return BadAlloc;
	switch (stuff->kind) {
	case ShapeBounding:
	    rects->x = - (int) wBorderWidth (pWin);
	    rects->y = - (int) wBorderWidth (pWin);
	    rects->width = pWin->drawable.width + wBorderWidth (pWin);
	    rects->height = pWin->drawable.height + wBorderWidth (pWin);
	    break;
	case ShapeClip:
	    rects->x = 0;
	    rects->y = 0;
	    rects->width = pWin->drawable.width;
	    rects->height = pWin->drawable.height;
	    break;
	case ShapeInput:
	    rects->x = - (int) wBorderWidth (pWin);
	    rects->y = - (int) wBorderWidth (pWin);
	    rects->width = pWin->drawable.width + wBorderWidth (pWin);
	    rects->height = pWin->drawable.height + wBorderWidth (pWin);
	    break;
	}
    } else {
	BoxPtr box;
	nrects = RegionNumRects(region);
	box = RegionRects(region);
	rects = malloc(nrects * sizeof (xRectangle));
	if (!rects && nrects)
	    return BadAlloc;
	for (i = 0; i < nrects; i++, box++) {
	    rects[i].x = box->x1;
	    rects[i].y = box->y1;
	    rects[i].width = box->x2 - box->x1;
	    rects[i].height = box->y2 - box->y1;
	}
d1006 1
a1006 1
    rep.length = bytes_to_int32(nrects * sizeof (xRectangle));
d1010 4
a1013 4
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.nrects, n);
	SwapShorts ((short *)rects, (unsigned long)nrects * 4);
d1015 2
a1016 2
    WriteToClient (client, sizeof (rep), (char *) &rep);
    WriteToClient (client, nrects * sizeof (xRectangle), (char *) rects);
d1022 1
a1022 1
ProcShapeDispatch (ClientPtr client)
d1027 1
a1027 1
	return ProcShapeQueryVersion (client);
d1030 3
a1032 3
        if ( !noPanoramiXExtension )
	    return ProcPanoramiXShapeRectangles (client);
        else 
d1034 1
a1034 1
	return ProcShapeRectangles (client);
d1037 3
a1039 3
        if ( !noPanoramiXExtension )
           return ProcPanoramiXShapeMask (client);
	else
d1041 1
a1041 1
	return ProcShapeMask (client);
d1044 3
a1046 3
        if ( !noPanoramiXExtension )
           return ProcPanoramiXShapeCombine (client);
	else
d1048 1
a1048 1
	return ProcShapeCombine (client);
d1051 3
a1053 3
        if ( !noPanoramiXExtension )
           return ProcPanoramiXShapeOffset (client);
	else
d1055 1
a1055 1
	return ProcShapeOffset (client);
d1057 1
a1057 1
	return ProcShapeQueryExtents (client);
d1059 1
a1059 1
	return ProcShapeSelectInput (client);
d1061 1
a1061 1
	return ProcShapeInputSelected (client);
d1063 1
a1063 1
	return ProcShapeGetRectangles (client);
d1065 1
a1065 1
	return BadRequest;
d1070 1
a1070 1
SShapeNotifyEvent(xShapeNotifyEvent *from, xShapeNotifyEvent *to)
d1074 7
a1080 7
    cpswapl (from->window, to->window);
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswaps (from->x, to->x);
    cpswaps (from->y, to->y);
    cpswaps (from->width, to->width);
    cpswaps (from->height, to->height);
    cpswapl (from->time, to->time);
d1085 1
a1085 1
SProcShapeQueryVersion (ClientPtr client)
d1087 1
a1087 2
    int    n;
    REQUEST (xShapeQueryVersionReq);
d1089 2
a1090 2
    swaps (&stuff->length, n);
    return ProcShapeQueryVersion (client);
d1094 1
a1094 1
SProcShapeRectangles (ClientPtr client)
d1096 1
a1096 2
    char   n;
    REQUEST (xShapeRectanglesReq);
d1098 5
a1102 5
    swaps (&stuff->length, n);
    REQUEST_AT_LEAST_SIZE (xShapeRectanglesReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
d1104 1
a1104 1
    return ProcShapeRectangles (client);
d1108 1
a1108 1
SProcShapeMask (ClientPtr client)
d1110 1
a1110 2
    char   n;
    REQUEST (xShapeMaskReq);
d1112 7
a1118 7
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeMaskReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    swapl (&stuff->src, n);
    return ProcShapeMask (client);
d1122 1
a1122 1
SProcShapeCombine (ClientPtr client)
d1124 1
a1124 2
    char   n;
    REQUEST (xShapeCombineReq);
d1126 7
a1132 7
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeCombineReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    swapl (&stuff->src, n);
    return ProcShapeCombine (client);
d1136 1
a1136 1
SProcShapeOffset (ClientPtr client)
d1138 1
a1138 2
    char   n;
    REQUEST (xShapeOffsetReq);
d1140 6
a1145 6
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeOffsetReq);
    swapl (&stuff->dest, n);
    swaps (&stuff->xOff, n);
    swaps (&stuff->yOff, n);
    return ProcShapeOffset (client);
d1149 1
a1149 1
SProcShapeQueryExtents (ClientPtr client)
d1151 1
a1151 2
    char   n;
    REQUEST (xShapeQueryExtentsReq);
d1153 4
a1156 4
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeQueryExtentsReq);
    swapl (&stuff->window, n);
    return ProcShapeQueryExtents (client);
d1160 1
a1160 1
SProcShapeSelectInput (ClientPtr client)
d1162 1
a1162 2
    char   n;
    REQUEST (xShapeSelectInputReq);
d1164 4
a1167 4
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeSelectInputReq);
    swapl (&stuff->window, n);
    return ProcShapeSelectInput (client);
d1171 1
a1171 1
SProcShapeInputSelected (ClientPtr client)
d1173 1
a1173 2
    int    n;
    REQUEST (xShapeInputSelectedReq);
d1175 4
a1178 4
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH (xShapeInputSelectedReq);
    swapl (&stuff->window, n);
    return ProcShapeInputSelected (client);
d1182 1
a1182 1
SProcShapeGetRectangles (ClientPtr client)
d1185 1
a1185 3
    char   n;

    swaps (&stuff->length, n);
d1187 2
a1188 2
    swapl (&stuff->window, n);
    return ProcShapeGetRectangles (client);
d1192 1
a1192 1
SProcShapeDispatch (ClientPtr client)
d1197 1
a1197 1
	return SProcShapeQueryVersion (client);
d1199 1
a1199 1
	return SProcShapeRectangles (client);
d1201 1
a1201 1
	return SProcShapeMask (client);
d1203 1
a1203 1
	return SProcShapeCombine (client);
d1205 1
a1205 1
	return SProcShapeOffset (client);
d1207 1
a1207 1
	return SProcShapeQueryExtents (client);
d1209 1
a1209 1
	return SProcShapeSelectInput (client);
d1211 1
a1211 1
	return SProcShapeInputSelected (client);
d1213 1
a1213 1
	return SProcShapeGetRectangles (client);
d1215 1
a1215 1
	return BadRequest;
d1227 5
a1231 6
	(extEntry = AddExtension(SHAPENAME, ShapeNumberEvents, 0,
				 ProcShapeDispatch, SProcShapeDispatch,
				 NULL, StandardMinorOpcode)))
    {
	ShapeEventBase = extEntry->eventBase;
	EventSwapVector[ShapeEventBase] = (EventSwapPtr) SShapeNotifyEvent;
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a70 20
static DISPATCH_PROC(ProcShapeCombine);
static DISPATCH_PROC(ProcShapeDispatch);
static DISPATCH_PROC(ProcShapeGetRectangles);
static DISPATCH_PROC(ProcShapeInputSelected);
static DISPATCH_PROC(ProcShapeMask);
static DISPATCH_PROC(ProcShapeOffset);
static DISPATCH_PROC(ProcShapeQueryExtents);
static DISPATCH_PROC(ProcShapeQueryVersion);
static DISPATCH_PROC(ProcShapeRectangles);
static DISPATCH_PROC(ProcShapeSelectInput);
static DISPATCH_PROC(SProcShapeCombine);
static DISPATCH_PROC(SProcShapeDispatch);
static DISPATCH_PROC(SProcShapeGetRectangles);
static DISPATCH_PROC(SProcShapeInputSelected);
static DISPATCH_PROC(SProcShapeMask);
static DISPATCH_PROC(SProcShapeOffset);
static DISPATCH_PROC(SProcShapeQueryExtents);
static DISPATCH_PROC(SProcShapeQueryVersion);
static DISPATCH_PROC(SProcShapeRectangles);
static DISPATCH_PROC(SProcShapeSelectInput);
a104 17
void
ShapeExtensionInit(void)
{
    ExtensionEntry *extEntry;

    ClientType = CreateNewResourceType(ShapeFreeClient, "ShapeClient");
    ShapeEventType = CreateNewResourceType(ShapeFreeEvents, "ShapeEvent");
    if (ClientType && ShapeEventType &&
	(extEntry = AddExtension(SHAPENAME, ShapeNumberEvents, 0,
				 ProcShapeDispatch, SProcShapeDispatch,
				 NULL, StandardMinorOpcode)))
    {
	ShapeEventBase = extEntry->eventBase;
	EventSwapVector[ShapeEventBase] = (EventSwapPtr) SShapeNotifyEvent;
    }
}

d1242 17
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a152 2
    ScreenPtr	pScreen = pWin->drawable.pScreen;

d154 1
a154 1
	REGION_TRANSLATE(pScreen, srcRgn, xoff, yoff);
d158 1
a158 1
	    REGION_DESTROY(pScreen, srcRgn);
d169 1
a169 1
	REGION_DESTROY (pScreen, *destRgnp);
d188 1
a188 1
	    REGION_DESTROY(pScreen, *destRgnp);
d194 1
a194 1
	    REGION_UNION(pScreen, *destRgnp, *destRgnp, srcRgn);
d198 1
a198 1
	    REGION_INTERSECT(pScreen, *destRgnp, *destRgnp, srcRgn);
d207 1
a207 1
	REGION_SUBTRACT(pScreen, *destRgnp, *destRgnp, srcRgn);
d211 1
a211 1
	    *destRgnp = REGION_CREATE(pScreen, (BoxPtr) 0, 0);
d213 1
a213 1
	    REGION_SUBTRACT(pScreen, *destRgnp, srcRgn, *destRgnp);
d220 2
a221 2
	REGION_DESTROY(pScreen, srcRgn);
    (*pScreen->SetShape) (pWin);
d235 1
a235 1
    return REGION_CREATE(pWin->drawable.pScreen, &extents, 1);
d247 1
a247 1
    return REGION_CREATE(pWin->drawable.pScreen, &extents, 1);
d270 1
a270 1
    return (client->noClientException);
a281 1
    ScreenPtr		pScreen;
a313 1
    pScreen = pWin->drawable.pScreen;
d322 1
a322 1
    srcRgn = RECTS_TO_REGION(pScreen, nrects, prects, ctype);
d359 1
a359 1
	return (result == BadValue) ? BadWindow : result;
d364 1
a364 1
	BREAK_IF(result != Success);
d366 1
a366 1
    return (result);
d414 1
a414 1
	    return (rc == BadValue) ? BadPixmap : rc;
d418 1
a418 1
	srcRgn = BITMAP_TO_REGION(pScreen, pPixmap);
d458 1
a458 1
	return (result == BadValue) ? BadWindow : result;
d464 1
a464 1
	    return (result == BadValue) ? BadPixmap : result;
d473 1
a473 1
	BREAK_IF(result != Success);
d475 1
a475 1
    return (result);
a487 1
    ScreenPtr		pScreen;
a516 1
    pScreen = pDestWin->drawable.pScreen;
d538 1
a538 1
    if (pSrcWin->drawable.pScreen != pScreen)
d544 2
a545 2
        tmp = REGION_CREATE(pScreen, (BoxPtr) 0, 0);
        REGION_COPY(pScreen, tmp, srcRgn);
d586 1
a586 1
	return (result == BadValue) ? BadWindow : result;
d591 1
a591 1
	return (result == BadValue) ? BadWindow : result;
d597 1
a597 1
	BREAK_IF(result != Success);
d599 1
a599 1
    return (result);
a610 1
    ScreenPtr		pScreen;
a633 1
    pScreen = pWin->drawable.pScreen;
d636 2
a637 2
        REGION_TRANSLATE(pScreen, srcRgn, stuff->xOff, stuff->yOff);
        (*pScreen->SetShape) (pWin);
d658 1
a658 1
	return (result == BadValue) ? BadWindow : result;
d665 1
a665 1
    return (result);
d692 1
a692 1
	pExtents = REGION_EXTENTS(pWin->drawable.pScreen, region);
d706 1
a706 1
	pExtents = REGION_EXTENTS(pWin->drawable.pScreen, region);
d731 1
a731 1
    return (client->noClientException);
d759 1
a759 1
    xfree ((pointer) pShapeEvent);
d773 1
a773 1
	xfree ((pointer) pCur);
d775 1
a775 1
    xfree ((pointer) pHead);
d812 1
a812 1
    	pNewShapeEvent = xalloc (sizeof (ShapeEventRec));
d834 1
a834 1
	    pHead = xalloc (sizeof (ShapeEventPtr));
d861 1
a861 1
		xfree (pShapeEvent);
a879 1
    ClientPtr		client;
d894 1
a894 1
	    extents = *REGION_EXTENTS(pWin->drawable.pScreen, region);
d907 1
a907 1
	    extents = *REGION_EXTENTS(pWin->drawable.pScreen, region);
d920 1
a920 1
	    extents = *REGION_EXTENTS(pWin->drawable.pScreen, region);
a933 3
	client = pShapeEvent->client;
	if (client == serverClient || client->clientGone)
	    continue;
a936 1
	se.sequenceNumber = client->sequence;
d943 1
a943 1
	WriteEventsToClient (client, 1, (xEvent *) &se);
d986 1
a986 1
    return (client->noClientException);
d1020 1
a1020 1
	rects = xalloc (sizeof (xRectangle));
d1045 3
a1047 3
	nrects = REGION_NUM_RECTS(region);
	box = REGION_RECTS(region);
	rects = xalloc (nrects * sizeof (xRectangle));
d1070 2
a1071 2
    xfree (rects);
    return client->noClientException;
@


1.4
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@a26 2
#define NEED_REPLIES
#define NEED_EVENTS
a43 1
#ifdef HAVE_X11_EXTENSIONS_SHAPEPROTO_H
a44 4
#else
#define _SHAPE_SERVER_	/* don't want Xlib structures */
#include <X11/extensions/shapestr.h>
#endif
d48 1
a65 12
static int
RegionOperate (
	ClientPtr /* client */,
	WindowPtr /* pWin */,
	int /* kind */,
	RegionPtr * /* destRgnp */,
	RegionPtr /* srcRgn */,
	int /* op */,
	int /* xoff */,
	int /* yoff */,
	CreateDftPtr /* create */
	);
d98 1
a98 1
static RESTYPE ClientType, EventType; /* resource types for event masks */
d130 3
a132 3
    ClientType = CreateNewResourceType(ShapeFreeClient);
    EventType = CreateNewResourceType(ShapeFreeEvents);
    if (ClientType && EventType &&
d143 9
a151 8
RegionOperate (client, pWin, kind, destRgnp, srcRgn, op, xoff, yoff, create)
    ClientPtr	client;
    WindowPtr	pWin;
    int		kind;
    RegionPtr	*destRgnp, srcRgn;
    int		op;
    int		xoff, yoff;
    CreateDftPtr create;	/* creates a reasonable *destRgnp */
d229 1
a229 2
CreateBoundingShape (pWin)
    WindowPtr	pWin;
d241 1
a241 2
CreateClipShape (pWin)
    WindowPtr	pWin;
d253 1
a253 2
ProcShapeQueryVersion (client)
    ClientPtr	client;
d259 1
d263 2
a264 2
    rep.majorVersion = SHAPE_MAJOR_VERSION;
    rep.minorVersion = SHAPE_MINOR_VERSION;
d281 1
a281 2
ProcShapeRectangles (client)
    ClientPtr client;
d356 1
a356 1
    int        		j, result = 0;
d360 4
a363 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->dest, XRT_WINDOW, DixWriteAccess)))
	return BadWindow;
d381 1
a381 2
ProcShapeMask (client)
    ClientPtr client;
d455 1
a455 1
    int 		j, result = 0;
d459 4
a462 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->dest, XRT_WINDOW, DixWriteAccess)))
	return BadWindow;
d465 4
a468 3
	if(!(pmap = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->src, XRT_PIXMAP, DixReadAccess)))
	    return BadPixmap;
d489 1
a489 2
ProcShapeCombine (client)
    ClientPtr client;
d585 1
a585 1
    int 		j, result = 0;
d589 9
a597 7
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->dest, XRT_WINDOW, DixWriteAccess)))
	return BadWindow;

    if(!(win2 = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->src, XRT_WINDOW, DixReadAccess)))
	return BadWindow;
d614 1
a614 2
ProcShapeOffset (client)
    ClientPtr client;
d659 1
a659 1
    int j, result = 0;
d663 4
a666 3
    if(!(win = (PanoramiXRes *)SecurityLookupIDByType(
		client, stuff->dest, XRT_WINDOW, DixWriteAccess)))
	return BadWindow;
d679 1
a679 2
ProcShapeQueryExtents (client)
    ClientPtr	client;
d692 1
d744 1
a744 3
ShapeFreeClient (data, id)
    pointer	    data;
    XID		    id;
d749 1
d753 3
a755 2
    pHead = (ShapeEventPtr *) LookupIDByType(pWin->drawable.id, EventType);
    if (pHead) {
d773 1
a773 3
ShapeFreeEvents (data, id)
    pointer	    data;
    XID		    id;
d788 1
a788 2
ProcShapeSelectInput (client)
    ClientPtr	client;
d800 5
a804 2
    pHead = (ShapeEventPtr *)SecurityLookupIDByType(client,
			pWin->drawable.id, EventType, DixWriteAccess);
d820 1
a820 2
    	pNewShapeEvent = (ShapeEventPtr)
			    xalloc (sizeof (ShapeEventRec));
d842 1
a842 1
	    pHead = (ShapeEventPtr *) xalloc (sizeof (ShapeEventPtr));
d844 1
a844 1
	    	!AddResource (pWin->drawable.id, EventType, (pointer)pHead))
d885 1
a885 3
SendShapeNotify (pWin, which)
    WindowPtr	pWin;
    int		which;
d893 1
d895 3
a897 2
    pHead = (ShapeEventPtr *) LookupIDByType(pWin->drawable.id, EventType);
    if (!pHead)
d961 1
a961 2
ProcShapeInputSelected (client)
    ClientPtr	client;
d974 4
a977 2
    pHead = (ShapeEventPtr *) SecurityLookupIDByType(client,
			pWin->drawable.id, EventType, DixReadAccess);
d1003 1
a1003 2
ProcShapeGetRectangles (client)
    ClientPtr	client;
d1033 1
a1033 1
	rects = (xRectangle *) xalloc (sizeof (xRectangle));
d1060 1
a1060 1
	rects = (xRectangle *) xalloc (nrects * sizeof (xRectangle));
d1072 1
a1072 1
    rep.length = (nrects * sizeof (xRectangle)) >> 2;
d1088 1
a1088 2
ProcShapeDispatch (client)
    ClientPtr	client;
d1136 1
a1136 2
SShapeNotifyEvent(from, to)
    xShapeNotifyEvent *from, *to;
d1151 1
a1151 2
SProcShapeQueryVersion (client)
    ClientPtr	client;
d1161 1
a1161 2
SProcShapeRectangles (client)
    ClientPtr	client;
d1176 1
a1176 2
SProcShapeMask (client)
    ClientPtr	client;
d1191 1
a1191 2
SProcShapeCombine (client)
    ClientPtr	client;
d1206 1
a1206 2
SProcShapeOffset (client)
    ClientPtr	client;
d1220 1
a1220 2
SProcShapeQueryExtents (client)
    ClientPtr	client;
d1232 1
a1232 2
SProcShapeSelectInput (client)
    ClientPtr	client;
d1244 1
a1244 2
SProcShapeInputSelected (client)
    ClientPtr	client;
d1256 1
a1256 2
SProcShapeGetRectangles (client)
    ClientPtr	client;
d1268 1
a1268 2
SProcShapeDispatch (client)
    ClientPtr	client;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d46 3
d51 1
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a63 3
static void ShapeResetProc(
	ExtensionEntry * /* extEntry */
	);
d149 1
a149 1
				 ShapeResetProc, StandardMinorOpcode)))
a155 7
/*ARGSUSED*/
static void
ShapeResetProc (extEntry)
ExtensionEntry	*extEntry;
{
}

d269 1
a269 1
    register ClientPtr	client;
d272 1
a272 1
    register int		n;
d297 1
a297 1
    register ClientPtr client;
d368 1
a368 1
    register ClientPtr client)
d397 1
a397 1
    register ClientPtr client;
d431 1
a431 1
	rc = dixLookupResource((pointer *)&pPixmap, stuff->src, RT_PIXMAP,
d467 1
a467 1
    register ClientPtr client)
d504 1
a504 1
    register ClientPtr client;
d596 1
a596 1
    register ClientPtr client)
d628 1
a628 1
    register ClientPtr client;
d669 1
a669 1
    register ClientPtr client)
d693 1
a693 1
    register ClientPtr	client;
d699 1
a699 1
    register int	n, rc;
d804 1
a804 1
    register ClientPtr	client;
d976 1
a976 1
    register ClientPtr	client;
d983 1
a983 1
    register int		n;
d1017 1
a1017 1
    register ClientPtr	client;
d1025 1
a1025 1
    register int		n;
d1103 1
a1103 1
    register ClientPtr	client;
d1168 1
a1168 1
    register ClientPtr	client;
d1170 1
a1170 1
    register int    n;
d1179 1
a1179 1
    register ClientPtr	client;
d1181 1
a1181 1
    register char   n;
d1195 1
a1195 1
    register ClientPtr	client;
d1197 1
a1197 1
    register char   n;
d1211 1
a1211 1
    register ClientPtr	client;
d1213 1
a1213 1
    register char   n;
d1227 1
a1227 1
    register ClientPtr	client;
d1229 1
a1229 1
    register char   n;
d1242 1
a1242 1
    register ClientPtr	client;
d1244 1
a1244 1
    register char   n;
d1255 1
a1255 1
    register ClientPtr	client;
d1257 1
a1257 1
    register char   n;
d1268 1
a1268 1
    register ClientPtr	client;
d1270 1
a1270 1
    register int    n;
d1281 1
a1281 1
    register ClientPtr	client;
d1284 1
a1284 1
    register char   n;
d1294 1
a1294 1
    register ClientPtr	client;
@


1.1
log
@Initial revision
@
text
@a113 3
#if 0
static unsigned char ShapeReqCode = 0;
#endif
a153 3
#if 0
	ShapeReqCode = (unsigned char)extEntry->base;
#endif
d313 1
a313 1
    int		        nrects, ctype;
d320 3
a322 3
    pWin = LookupWindow (stuff->dest, client);
    if (!pWin)
	return BadWindow;
d387 1
a387 1
		client, stuff->dest, XRT_WINDOW, SecurityWriteAccess)))
d416 1
d420 3
a422 3
    pWin = SecurityLookupWindow (stuff->dest, client, SecurityWriteAccess);
    if (!pWin)
	return BadWindow;
d441 4
a444 4
        pPixmap = (PixmapPtr) SecurityLookupIDByType(client, stuff->src,
						RT_PIXMAP, SecurityReadAccess);
        if (!pPixmap)
	    return BadPixmap;
d486 1
a486 1
		client, stuff->dest, XRT_WINDOW, SecurityWriteAccess)))
d491 1
a491 1
		client, stuff->src, XRT_PIXMAP, SecurityReadAccess)))
d524 1
d528 3
a530 3
    pDestWin = LookupWindow (stuff->dest, client);
    if (!pDestWin)
	return BadWindow;
d549 3
a551 3
    pSrcWin = LookupWindow (stuff->src, client);
    if (!pSrcWin)
	return BadWindow;
d615 1
a615 1
		client, stuff->dest, XRT_WINDOW, SecurityWriteAccess)))
d619 1
a619 1
		client, stuff->src, XRT_WINDOW, SecurityReadAccess)))
d644 1
d648 3
a650 3
    pWin = LookupWindow (stuff->dest, client);
    if (!pWin)
	return BadWindow;
d688 1
a688 1
		client, stuff->dest, XRT_WINDOW, SecurityWriteAccess)))
d709 1
a709 1
    register int	n;
d713 3
a715 3
    pWin = LookupWindow (stuff->window, client);
    if (!pWin)
	return BadWindow;
d820 1
d823 3
a825 3
    pWin = SecurityLookupWindow (stuff->window, client, SecurityWriteAccess);
    if (!pWin)
	return BadWindow;
d827 1
a827 1
			pWin->drawable.id, EventType, SecurityWriteAccess);
d991 1
a991 1
    int			enabled;
d996 3
a998 3
    pWin = LookupWindow (stuff->window, client);
    if (!pWin)
	return BadWindow;
d1000 1
a1000 1
			pWin->drawable.id, EventType, SecurityReadAccess);
d1033 1
a1033 1
    int				nrects, i;
d1038 3
a1040 3
    pWin = LookupWindow (stuff->window, client);
    if (!pWin)
	return BadWindow;
d1057 1
a1057 1
	rects = (xRectangle *) ALLOCATE_LOCAL (sizeof (xRectangle));
d1084 1
a1084 1
	rects = (xRectangle *) ALLOCATE_LOCAL (nrects * sizeof (xRectangle));
d1107 1
a1107 1
    DEALLOCATE_LOCAL (rects);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d319 1
a319 1
    int		        nrects, ctype, rc;
d326 3
a328 3
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixUnknownAccess);
    if (rc != Success)
	return rc;
d393 1
a393 1
		client, stuff->dest, XRT_WINDOW, DixWriteAccess)))
a421 1
    int			rc;
d425 3
a427 3
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixWriteAccess);
    if (rc != Success)
	return rc;
d447 1
a447 1
						RT_PIXMAP, DixReadAccess);
d491 1
a491 1
		client, stuff->dest, XRT_WINDOW, DixWriteAccess)))
d496 1
a496 1
		client, stuff->src, XRT_PIXMAP, DixReadAccess)))
a528 1
    int			rc;
d532 3
a534 3
    rc = dixLookupWindow(&pDestWin, stuff->dest, client, DixUnknownAccess);
    if (rc != Success)
	return rc;
d553 3
a555 3
    rc = dixLookupWindow(&pSrcWin, stuff->src, client, DixUnknownAccess);
    if (rc != Success)
	return rc;
d619 1
a619 1
		client, stuff->dest, XRT_WINDOW, DixWriteAccess)))
d623 1
a623 1
		client, stuff->src, XRT_WINDOW, DixReadAccess)))
a647 1
    int			rc;
d651 3
a653 3
    rc = dixLookupWindow(&pWin, stuff->dest, client, DixUnknownAccess);
    if (rc != Success)
	return rc;
d691 1
a691 1
		client, stuff->dest, XRT_WINDOW, DixWriteAccess)))
d712 1
a712 1
    register int	n, rc;
d716 3
a718 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
    if (rc != Success)
	return rc;
a822 1
    int			rc;
d825 3
a827 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixWriteAccess);
    if (rc != Success)
	return rc;
d829 1
a829 1
			pWin->drawable.id, EventType, DixWriteAccess);
d993 1
a993 1
    int			enabled, rc;
d998 3
a1000 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
    if (rc != Success)
	return rc;
d1002 1
a1002 1
			pWin->drawable.id, EventType, DixReadAccess);
d1035 1
a1035 1
    int				nrects, i, rc;
d1040 3
a1042 3
    rc = dixLookupWindow(&pWin, stuff->window, client, DixUnknownAccess);
    if (rc != Success)
	return rc;
@

