head	1.17;
access;
symbols
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.15.0.4
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.2
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.2
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.16;
commitid	s0SI41sEunLdyFfd;

1.16
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	Te1daavkBLskZ8gc;

1.15
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	cVXoV5PxI8YrEaVA;

1.14
date	2014.05.02.19.27.46;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.12.15.11.31.09;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2013.12.08.10.53.01;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.02.16.08.38;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.50;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.50;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.57;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*

Copyright 1991, 1993, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

Copyright 1991, 1993 by Digital Equipment Corporation, Maynard, Massachusetts,
and Olivetti Research Limited, Cambridge, England.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the names of Digital or Olivetti
not be used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  Digital and Olivetti
make no representations about the suitability of this software
for any purpose.  It is provided "as is" without express or implied warranty.

DIGITAL AND OLIVETTI DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL THEY BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.

*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include <X11/X.h>
#include <X11/Xproto.h>
#include <X11/Xmd.h>
#include "scrnintstr.h"
#include "os.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "pixmapstr.h"
#include "resource.h"
#include "opaque.h"
#include <X11/extensions/syncproto.h>
#include "syncsrv.h"
#include "syncsdk.h"
#include "protocol-versions.h"
#include "inputstr.h"

#include <stdio.h>
#if !defined(WIN32)
#include <sys/time.h>
#endif

#include "extinit.h"

/*
 * Local Global Variables
 */
static int SyncEventBase;
static int SyncErrorBase;
static RESTYPE RTCounter = 0;
static RESTYPE RTAwait;
static RESTYPE RTAlarm;
static RESTYPE RTAlarmClient;
static RESTYPE RTFence;
static struct xorg_list SysCounterList;
static int SyncNumInvalidCounterWarnings = 0;

#define MAX_INVALID_COUNTER_WARNINGS	   5

static const char *WARN_INVALID_COUNTER_COMPARE =
    "Warning: Non-counter XSync object using Counter-only\n"
    "         comparison.  Result will never be true.\n";

static const char *WARN_INVALID_COUNTER_ALARM =
    "Warning: Non-counter XSync object used in alarm.  This is\n"
    "         the result of a programming error in the X server.\n";

#define IsSystemCounter(pCounter) \
    (pCounter && (pCounter->sync.client == NULL))

/* these are all the alarm attributes that pertain to the alarm's trigger */
#define XSyncCAAllTrigger \
    (XSyncCACounter | XSyncCAValueType | XSyncCAValue | XSyncCATestType)

static void SyncComputeBracketValues(SyncCounter *);

static void SyncInitServerTime(void);

static void SyncInitIdleTime(void);

static inline void*
SysCounterGetPrivate(SyncCounter *counter)
{
    BUG_WARN(!IsSystemCounter(counter));

    return counter->pSysCounterInfo ? counter->pSysCounterInfo->private : NULL;
}

static Bool
SyncCheckWarnIsCounter(const SyncObject * pSync, const char *warning)
{
    if (pSync && (SYNC_COUNTER != pSync->type)) {
        if (SyncNumInvalidCounterWarnings++ < MAX_INVALID_COUNTER_WARNINGS) {
            ErrorF("%s", warning);
            ErrorF("         Counter type: %d\n", pSync->type);
        }

        return FALSE;
    }

    return TRUE;
}

/*  Each counter maintains a simple linked list of triggers that are
 *  interested in the counter.  The two functions below are used to
 *  delete and add triggers on this list.
 */
void
SyncDeleteTriggerFromSyncObject(SyncTrigger * pTrigger)
{
    SyncTriggerList *pCur;
    SyncTriggerList *pPrev;
    SyncCounter *pCounter;

    /* pSync needs to be stored in pTrigger before calling here. */

    if (!pTrigger->pSync)
        return;

    pPrev = NULL;
    pCur = pTrigger->pSync->pTriglist;

    while (pCur) {
        if (pCur->pTrigger == pTrigger) {
            if (pPrev)
                pPrev->next = pCur->next;
            else
                pTrigger->pSync->pTriglist = pCur->next;

            free(pCur);
            break;
        }

        pPrev = pCur;
        pCur = pCur->next;
    }

    if (SYNC_COUNTER == pTrigger->pSync->type) {
        pCounter = (SyncCounter *) pTrigger->pSync;

        if (IsSystemCounter(pCounter))
            SyncComputeBracketValues(pCounter);
    }
    else if (SYNC_FENCE == pTrigger->pSync->type) {
        SyncFence *pFence = (SyncFence *) pTrigger->pSync;

        pFence->funcs.DeleteTrigger(pTrigger);
    }
}

int
SyncAddTriggerToSyncObject(SyncTrigger * pTrigger)
{
    SyncTriggerList *pCur;
    SyncCounter *pCounter;

    if (!pTrigger->pSync)
        return Success;

    /* don't do anything if it's already there */
    for (pCur = pTrigger->pSync->pTriglist; pCur; pCur = pCur->next) {
        if (pCur->pTrigger == pTrigger)
            return Success;
    }

    if (!(pCur = malloc(sizeof(SyncTriggerList))))
        return BadAlloc;

    pCur->pTrigger = pTrigger;
    pCur->next = pTrigger->pSync->pTriglist;
    pTrigger->pSync->pTriglist = pCur;

    if (SYNC_COUNTER == pTrigger->pSync->type) {
        pCounter = (SyncCounter *) pTrigger->pSync;

        if (IsSystemCounter(pCounter))
            SyncComputeBracketValues(pCounter);
    }
    else if (SYNC_FENCE == pTrigger->pSync->type) {
        SyncFence *pFence = (SyncFence *) pTrigger->pSync;

        pFence->funcs.AddTrigger(pTrigger);
    }

    return Success;
}

/*  Below are five possible functions that can be plugged into
 *  pTrigger->CheckTrigger for counter sync objects, corresponding to
 *  the four possible test-types, and the one possible function that
 *  can be plugged into pTrigger->CheckTrigger for fence sync objects.
 *  These functions are called after the sync object's state changes
 *  but are also passed the old state so they can inspect both the old
 *  and new values.  (PositiveTransition and NegativeTransition need to
 *  see both pieces of information.)  These functions return the truth
 *  value of the trigger.
 *
 *  All of them include the condition pTrigger->pSync == NULL.
 *  This is because the spec says that a trigger with a sync value
 *  of None is always TRUE.
 */

static Bool
SyncCheckTriggerPositiveComparison(SyncTrigger * pTrigger, CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
        return FALSE;

    pCounter = (SyncCounter *) pTrigger->pSync;

    return (pCounter == NULL ||
            XSyncValueGreaterOrEqual(pCounter->value, pTrigger->test_value));
}

static Bool
SyncCheckTriggerNegativeComparison(SyncTrigger * pTrigger, CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
        return FALSE;

    pCounter = (SyncCounter *) pTrigger->pSync;

    return (pCounter == NULL ||
            XSyncValueLessOrEqual(pCounter->value, pTrigger->test_value));
}

static Bool
SyncCheckTriggerPositiveTransition(SyncTrigger * pTrigger, CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
        return FALSE;

    pCounter = (SyncCounter *) pTrigger->pSync;

    return (pCounter == NULL ||
            (XSyncValueLessThan(oldval, pTrigger->test_value) &&
             XSyncValueGreaterOrEqual(pCounter->value, pTrigger->test_value)));
}

static Bool
SyncCheckTriggerNegativeTransition(SyncTrigger * pTrigger, CARD64 oldval)
{
    SyncCounter *pCounter;

    /* Non-counter sync objects should never get here because they
     * never trigger this comparison. */
    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_COMPARE))
        return FALSE;

    pCounter = (SyncCounter *) pTrigger->pSync;

    return (pCounter == NULL ||
            (XSyncValueGreaterThan(oldval, pTrigger->test_value) &&
             XSyncValueLessOrEqual(pCounter->value, pTrigger->test_value)));
}

static Bool
SyncCheckTriggerFence(SyncTrigger * pTrigger, CARD64 unused)
{
    SyncFence *pFence = (SyncFence *) pTrigger->pSync;

    (void) unused;

    return (pFence == NULL || pFence->funcs.CheckTriggered(pFence));
}

static int
SyncInitTrigger(ClientPtr client, SyncTrigger * pTrigger, XID syncObject,
                RESTYPE resType, Mask changes)
{
    SyncObject *pSync = pTrigger->pSync;
    SyncCounter *pCounter = NULL;
    int rc;
    Bool newSyncObject = FALSE;

    if (changes & XSyncCACounter) {
        if (syncObject == None)
            pSync = NULL;
        else if (Success != (rc = dixLookupResourceByType((void **) &pSync,
                                                          syncObject, resType,
                                                          client,
                                                          DixReadAccess))) {
            client->errorValue = syncObject;
            return rc;
        }
        if (pSync != pTrigger->pSync) { /* new counter for trigger */
            SyncDeleteTriggerFromSyncObject(pTrigger);
            pTrigger->pSync = pSync;
            newSyncObject = TRUE;
        }
    }

    /* if system counter, ask it what the current value is */

    if (pSync && SYNC_COUNTER == pSync->type) {
        pCounter = (SyncCounter *) pSync;

        if (IsSystemCounter(pCounter)) {
            (*pCounter->pSysCounterInfo->QueryValue) ((void *) pCounter,
                                                      &pCounter->value);
        }
    }

    if (changes & XSyncCAValueType) {
        if (pTrigger->value_type != XSyncRelative &&
            pTrigger->value_type != XSyncAbsolute) {
            client->errorValue = pTrigger->value_type;
            return BadValue;
        }
    }

    if (changes & XSyncCATestType) {

        if (pSync && SYNC_FENCE == pSync->type) {
            pTrigger->CheckTrigger = SyncCheckTriggerFence;
        }
        else {
            /* select appropriate CheckTrigger function */

            switch (pTrigger->test_type) {
            case XSyncPositiveTransition:
                pTrigger->CheckTrigger = SyncCheckTriggerPositiveTransition;
                break;
            case XSyncNegativeTransition:
                pTrigger->CheckTrigger = SyncCheckTriggerNegativeTransition;
                break;
            case XSyncPositiveComparison:
                pTrigger->CheckTrigger = SyncCheckTriggerPositiveComparison;
                break;
            case XSyncNegativeComparison:
                pTrigger->CheckTrigger = SyncCheckTriggerNegativeComparison;
                break;
            default:
                client->errorValue = pTrigger->test_type;
                return BadValue;
            }
        }
    }

    if (changes & (XSyncCAValueType | XSyncCAValue)) {
        if (pTrigger->value_type == XSyncAbsolute)
            pTrigger->test_value = pTrigger->wait_value;
        else {                  /* relative */

            Bool overflow;

            if (pCounter == NULL)
                return BadMatch;

            XSyncValueAdd(&pTrigger->test_value, pCounter->value,
                          pTrigger->wait_value, &overflow);
            if (overflow) {
                client->errorValue = XSyncValueHigh32(pTrigger->wait_value);
                return BadValue;
            }
        }
    }

    /*  we wait until we're sure there are no errors before registering
     *  a new counter on a trigger
     */
    if (newSyncObject) {
        if ((rc = SyncAddTriggerToSyncObject(pTrigger)) != Success)
            return rc;
    }
    else if (pCounter && IsSystemCounter(pCounter)) {
        SyncComputeBracketValues(pCounter);
    }

    return Success;
}

/*  AlarmNotify events happen in response to actions taken on an Alarm or
 *  the counter used by the alarm.  AlarmNotify may be sent to multiple
 *  clients.  The alarm maintains a list of clients interested in events.
 */
static void
SyncSendAlarmNotifyEvents(SyncAlarm * pAlarm)
{
    SyncAlarmClientList *pcl;
    xSyncAlarmNotifyEvent ane;
    SyncTrigger *pTrigger = &pAlarm->trigger;
    SyncCounter *pCounter;

    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_ALARM))
        return;

    pCounter = (SyncCounter *) pTrigger->pSync;

    UpdateCurrentTime();

    ane = (xSyncAlarmNotifyEvent) {
        .type = SyncEventBase + XSyncAlarmNotify,
        .kind = XSyncAlarmNotify,
        .alarm = pAlarm->alarm_id,
        .alarm_value_hi = XSyncValueHigh32(pTrigger->test_value),
        .alarm_value_lo = XSyncValueLow32(pTrigger->test_value),
        .time = currentTime.milliseconds,
        .state = pAlarm->state
    };

    if (pTrigger->pSync && SYNC_COUNTER == pTrigger->pSync->type) {
        ane.counter_value_hi = XSyncValueHigh32(pCounter->value);
        ane.counter_value_lo = XSyncValueLow32(pCounter->value);
    }
    else {
        /* XXX what else can we do if there's no counter? */
        ane.counter_value_hi = ane.counter_value_lo = 0;
    }

    /* send to owner */
    if (pAlarm->events)
        WriteEventsToClient(pAlarm->client, 1, (xEvent *) &ane);

    /* send to other interested clients */
    for (pcl = pAlarm->pEventClients; pcl; pcl = pcl->next)
        WriteEventsToClient(pcl->client, 1, (xEvent *) &ane);
}

/*  CounterNotify events only occur in response to an Await.  The events
 *  go only to the Awaiting client.
 */
static void
SyncSendCounterNotifyEvents(ClientPtr client, SyncAwait ** ppAwait,
                            int num_events)
{
    xSyncCounterNotifyEvent *pEvents, *pev;
    int i;

    if (client->clientGone)
        return;
    pev = pEvents = calloc(num_events, sizeof(xSyncCounterNotifyEvent));
    if (!pEvents)
        return;
    UpdateCurrentTime();
    for (i = 0; i < num_events; i++, ppAwait++, pev++) {
        SyncTrigger *pTrigger = &(*ppAwait)->trigger;

        pev->type = SyncEventBase + XSyncCounterNotify;
        pev->kind = XSyncCounterNotify;
        pev->counter = pTrigger->pSync->id;
        pev->wait_value_lo = XSyncValueLow32(pTrigger->test_value);
        pev->wait_value_hi = XSyncValueHigh32(pTrigger->test_value);
        if (SYNC_COUNTER == pTrigger->pSync->type) {
            SyncCounter *pCounter = (SyncCounter *) pTrigger->pSync;

            pev->counter_value_lo = XSyncValueLow32(pCounter->value);
            pev->counter_value_hi = XSyncValueHigh32(pCounter->value);
        }
        else {
            pev->counter_value_lo = 0;
            pev->counter_value_hi = 0;
        }

        pev->time = currentTime.milliseconds;
        pev->count = num_events - i - 1;        /* events remaining */
        pev->destroyed = pTrigger->pSync->beingDestroyed;
    }
    /* swapping will be taken care of by this */
    WriteEventsToClient(client, num_events, (xEvent *) pEvents);
    free(pEvents);
}

/* This function is called when an alarm's counter is destroyed.
 * It is plugged into pTrigger->CounterDestroyed (for alarm triggers).
 */
static void
SyncAlarmCounterDestroyed(SyncTrigger * pTrigger)
{
    SyncAlarm *pAlarm = (SyncAlarm *) pTrigger;

    pAlarm->state = XSyncAlarmInactive;
    SyncSendAlarmNotifyEvents(pAlarm);
    pTrigger->pSync = NULL;
}

/*  This function is called when an alarm "goes off."
 *  It is plugged into pTrigger->TriggerFired (for alarm triggers).
 */
static void
SyncAlarmTriggerFired(SyncTrigger * pTrigger)
{
    SyncAlarm *pAlarm = (SyncAlarm *) pTrigger;
    SyncCounter *pCounter;
    CARD64 new_test_value;

    if (!SyncCheckWarnIsCounter(pTrigger->pSync, WARN_INVALID_COUNTER_ALARM))
        return;

    pCounter = (SyncCounter *) pTrigger->pSync;

    /* no need to check alarm unless it's active */
    if (pAlarm->state != XSyncAlarmActive)
        return;

    /*  " if the counter value is None, or if the delta is 0 and
     *    the test-type is PositiveComparison or NegativeComparison,
     *    no change is made to value (test-value) and the alarm
     *    state is changed to Inactive before the event is generated."
     */
    if (pCounter == NULL || (XSyncValueIsZero(pAlarm->delta)
                             && (pAlarm->trigger.test_type ==
                                 XSyncPositiveComparison ||
                                 pAlarm->trigger.test_type ==
                                 XSyncNegativeComparison)))
        pAlarm->state = XSyncAlarmInactive;

    new_test_value = pAlarm->trigger.test_value;

    if (pAlarm->state == XSyncAlarmActive) {
        Bool overflow;
        CARD64 oldvalue;
        SyncTrigger *paTrigger = &pAlarm->trigger;
        SyncCounter *paCounter;

        if (!SyncCheckWarnIsCounter(paTrigger->pSync,
                                    WARN_INVALID_COUNTER_ALARM))
            return;

        paCounter = (SyncCounter *) pTrigger->pSync;

        /* "The alarm is updated by repeatedly adding delta to the
         *  value of the trigger and re-initializing it until it
         *  becomes FALSE."
         */
        oldvalue = paTrigger->test_value;

        /* XXX really should do something smarter here */

        do {
            XSyncValueAdd(&paTrigger->test_value, paTrigger->test_value,
                          pAlarm->delta, &overflow);
        } while (!overflow &&
                 (*paTrigger->CheckTrigger) (paTrigger, paCounter->value));

        new_test_value = paTrigger->test_value;
        paTrigger->test_value = oldvalue;

        /* "If this update would cause value to fall outside the range
         *  for an INT64...no change is made to value (test-value) and
         *  the alarm state is changed to Inactive before the event is
         *  generated."
         */
        if (overflow) {
            new_test_value = oldvalue;
            pAlarm->state = XSyncAlarmInactive;
        }
    }
    /*  The AlarmNotify event has to have the "new state of the alarm"
     *  which we can't be sure of until this point.  However, it has
     *  to have the "old" trigger test value.  That's the reason for
     *  all the newvalue/oldvalue shuffling above.  After we send the
     *  events, give the trigger its new test value.
     */
    SyncSendAlarmNotifyEvents(pAlarm);
    pTrigger->test_value = new_test_value;
}

/*  This function is called when an Await unblocks, either as a result
 *  of the trigger firing OR the counter being destroyed.
 *  It goes into pTrigger->TriggerFired AND pTrigger->CounterDestroyed
 *  (for Await triggers).
 */
static void
SyncAwaitTriggerFired(SyncTrigger * pTrigger)
{
    SyncAwait *pAwait = (SyncAwait *) pTrigger;
    int numwaits;
    SyncAwaitUnion *pAwaitUnion;
    SyncAwait **ppAwait;
    int num_events = 0;

    pAwaitUnion = (SyncAwaitUnion *) pAwait->pHeader;
    numwaits = pAwaitUnion->header.num_waitconditions;
    ppAwait = xallocarray(numwaits, sizeof(SyncAwait *));
    if (!ppAwait)
        goto bail;

    pAwait = &(pAwaitUnion + 1)->await;

    /* "When a client is unblocked, all the CounterNotify events for
     *  the Await request are generated contiguously. If count is 0
     *  there are no more events to follow for this request. If
     *  count is n, there are at least n more events to follow."
     *
     *  Thus, it is best to find all the counters for which events
     *  need to be sent first, so that an accurate count field can
     *  be stored in the events.
     */
    for (; numwaits; numwaits--, pAwait++) {
        CARD64 diff;
        Bool overflow, diffgreater, diffequal;

        /* "A CounterNotify event with the destroyed flag set to TRUE is
         *  always generated if the counter for one of the triggers is
         *  destroyed."
         */
        if (pAwait->trigger.pSync->beingDestroyed) {
            ppAwait[num_events++] = pAwait;
            continue;
        }

        if (SYNC_COUNTER == pAwait->trigger.pSync->type) {
            SyncCounter *pCounter = (SyncCounter *) pAwait->trigger.pSync;

            /* "The difference between the counter and the test value is
             *  calculated by subtracting the test value from the value of
             *  the counter."
             */
            XSyncValueSubtract(&diff, pCounter->value,
                               pAwait->trigger.test_value, &overflow);

            /* "If the difference lies outside the range for an INT64, an
             *  event is not generated."
             */
            if (overflow)
                continue;
            diffgreater = XSyncValueGreaterThan(diff, pAwait->event_threshold);
            diffequal = XSyncValueEqual(diff, pAwait->event_threshold);

            /* "If the test-type is PositiveTransition or
             *  PositiveComparison, a CounterNotify event is generated if
             *  the difference is at least event-threshold. If the test-type
             *  is NegativeTransition or NegativeComparison, a CounterNotify
             *  event is generated if the difference is at most
             *  event-threshold."
             */

            if (((pAwait->trigger.test_type == XSyncPositiveComparison ||
                  pAwait->trigger.test_type == XSyncPositiveTransition)
                 && (diffgreater || diffequal))
                ||
                ((pAwait->trigger.test_type == XSyncNegativeComparison ||
                  pAwait->trigger.test_type == XSyncNegativeTransition)
                 && (!diffgreater)      /* less or equal */
                )
                ) {
                ppAwait[num_events++] = pAwait;
            }
        }
    }
    if (num_events)
        SyncSendCounterNotifyEvents(pAwaitUnion->header.client, ppAwait,
                                    num_events);
    free(ppAwait);

 bail:
    /* unblock the client */
    AttendClient(pAwaitUnion->header.client);
    /* delete the await */
    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
}

static CARD64
SyncUpdateCounter(SyncCounter *pCounter, CARD64 newval)
{
    CARD64 oldval = pCounter->value;
    pCounter->value = newval;
    return oldval;
}

/*  This function should always be used to change a counter's value so that
 *  any triggers depending on the counter will be checked.
 */
void
SyncChangeCounter(SyncCounter * pCounter, CARD64 newval)
{
    SyncTriggerList *ptl, *pnext;
    CARD64 oldval;

    oldval = SyncUpdateCounter(pCounter, newval);

    /* run through triggers to see if any become true */
    for (ptl = pCounter->sync.pTriglist; ptl; ptl = pnext) {
        pnext = ptl->next;
        if ((*ptl->pTrigger->CheckTrigger) (ptl->pTrigger, oldval))
            (*ptl->pTrigger->TriggerFired) (ptl->pTrigger);
    }

    if (IsSystemCounter(pCounter)) {
        SyncComputeBracketValues(pCounter);
    }
}

/* loosely based on dix/events.c/EventSelectForWindow */
static Bool
SyncEventSelectForAlarm(SyncAlarm * pAlarm, ClientPtr client, Bool wantevents)
{
    SyncAlarmClientList *pClients;

    if (client == pAlarm->client) {     /* alarm owner */
        pAlarm->events = wantevents;
        return Success;
    }

    /* see if the client is already on the list (has events selected) */

    for (pClients = pAlarm->pEventClients; pClients; pClients = pClients->next) {
        if (pClients->client == client) {
            /* client's presence on the list indicates desire for
             * events.  If the client doesn't want events, remove it
             * from the list.  If the client does want events, do
             * nothing, since it's already got them.
             */
            if (!wantevents) {
                FreeResource(pClients->delete_id, RT_NONE);
            }
            return Success;
        }
    }

    /*  if we get here, this client does not currently have
     *  events selected on the alarm
     */

    if (!wantevents)
        /* client doesn't want events, and we just discovered that it
         * doesn't have them, so there's nothing to do.
         */
        return Success;

    /* add new client to pAlarm->pEventClients */

    pClients = malloc(sizeof(SyncAlarmClientList));
    if (!pClients)
        return BadAlloc;

    /*  register it as a resource so it will be cleaned up
     *  if the client dies
     */

    pClients->delete_id = FakeClientID(client->index);

    /* link it into list after we know all the allocations succeed */
    pClients->next = pAlarm->pEventClients;
    pAlarm->pEventClients = pClients;
    pClients->client = client;

    if (!AddResource(pClients->delete_id, RTAlarmClient, pAlarm))
        return BadAlloc;

    return Success;
}

/*
 * ** SyncChangeAlarmAttributes ** This is used by CreateAlarm and ChangeAlarm
 */
static int
SyncChangeAlarmAttributes(ClientPtr client, SyncAlarm * pAlarm, Mask mask,
                          CARD32 *values)
{
    int status;
    XSyncCounter counter;
    Mask origmask = mask;

    counter = pAlarm->trigger.pSync ? pAlarm->trigger.pSync->id : None;

    while (mask) {
        int index2 = lowbit(mask);

        mask &= ~index2;
        switch (index2) {
        case XSyncCACounter:
            mask &= ~XSyncCACounter;
            /* sanity check in SyncInitTrigger */
            counter = *values++;
            break;

        case XSyncCAValueType:
            mask &= ~XSyncCAValueType;
            /* sanity check in SyncInitTrigger */
            pAlarm->trigger.value_type = *values++;
            break;

        case XSyncCAValue:
            mask &= ~XSyncCAValue;
            XSyncIntsToValue(&pAlarm->trigger.wait_value, values[1], values[0]);
            values += 2;
            break;

        case XSyncCATestType:
            mask &= ~XSyncCATestType;
            /* sanity check in SyncInitTrigger */
            pAlarm->trigger.test_type = *values++;
            break;

        case XSyncCADelta:
            mask &= ~XSyncCADelta;
            XSyncIntsToValue(&pAlarm->delta, values[1], values[0]);
            values += 2;
            break;

        case XSyncCAEvents:
            mask &= ~XSyncCAEvents;
            if ((*values != xTrue) && (*values != xFalse)) {
                client->errorValue = *values;
                return BadValue;
            }
            status = SyncEventSelectForAlarm(pAlarm, client,
                                             (Bool) (*values++));
            if (status != Success)
                return status;
            break;

        default:
            client->errorValue = mask;
            return BadValue;
        }
    }

    /* "If the test-type is PositiveComparison or PositiveTransition
     *  and delta is less than zero, or if the test-type is
     *  NegativeComparison or NegativeTransition and delta is
     *  greater than zero, a Match error is generated."
     */
    if (origmask & (XSyncCADelta | XSyncCATestType)) {
        CARD64 zero;

        XSyncIntToValue(&zero, 0);
        if ((((pAlarm->trigger.test_type == XSyncPositiveComparison) ||
              (pAlarm->trigger.test_type == XSyncPositiveTransition))
             && XSyncValueLessThan(pAlarm->delta, zero))
            ||
            (((pAlarm->trigger.test_type == XSyncNegativeComparison) ||
              (pAlarm->trigger.test_type == XSyncNegativeTransition))
             && XSyncValueGreaterThan(pAlarm->delta, zero))
            ) {
            return BadMatch;
        }
    }

    /* postpone this until now, when we're sure nothing else can go wrong */
    if ((status = SyncInitTrigger(client, &pAlarm->trigger, counter, RTCounter,
                                  origmask & XSyncCAAllTrigger)) != Success)
        return status;

    /* XXX spec does not really say to do this - needs clarification */
    pAlarm->state = XSyncAlarmActive;
    return Success;
}

static SyncObject *
SyncCreate(ClientPtr client, XID id, unsigned char type)
{
    SyncObject *pSync;

    switch (type) {
    case SYNC_COUNTER:
        pSync = malloc(sizeof(SyncCounter));
        break;
    case SYNC_FENCE:
        pSync = (SyncObject *) dixAllocateObjectWithPrivates(SyncFence,
                                                             PRIVATE_SYNC_FENCE);
        break;
    default:
        return NULL;
    }

    if (!pSync)
        return NULL;

    pSync->client = client;
    pSync->id = id;
    pSync->pTriglist = NULL;
    pSync->beingDestroyed = FALSE;
    pSync->type = type;

    return pSync;
}

int
SyncCreateFenceFromFD(ClientPtr client, DrawablePtr pDraw, XID id, int fd, BOOL initially_triggered)
{
#if HAVE_XSHMFENCE
    SyncFence  *pFence;
    int         status;

    pFence = (SyncFence *) SyncCreate(client, id, SYNC_FENCE);
    if (!pFence)
        return BadAlloc;

    status = miSyncInitFenceFromFD(pDraw, pFence, fd, initially_triggered);
    if (status != Success) {
        dixFreeObjectWithPrivates(pFence, PRIVATE_SYNC_FENCE);
        return status;
    }

    if (!AddResource(id, RTFence, (void *) pFence))
        return BadAlloc;

    return Success;
#else
    return BadImplementation;
#endif
}

int
SyncFDFromFence(ClientPtr client, DrawablePtr pDraw, SyncFence *pFence)
{
#if HAVE_XSHMFENCE
    return miSyncFDFromFence(pDraw, pFence);
#else
    return BadImplementation;
#endif
}

static SyncCounter *
SyncCreateCounter(ClientPtr client, XSyncCounter id, CARD64 initialvalue)
{
    SyncCounter *pCounter;

    if (!(pCounter = (SyncCounter *) SyncCreate(client, id, SYNC_COUNTER)))
        return NULL;

    pCounter->value = initialvalue;
    pCounter->pSysCounterInfo = NULL;

    if (!AddResource(id, RTCounter, (void *) pCounter))
        return NULL;

    return pCounter;
}

static int FreeCounter(void *, XID);

/*
 * ***** System Counter utilities
 */

SyncCounter*
SyncCreateSystemCounter(const char *name,
                        CARD64 initial,
                        CARD64 resolution,
                        SyncCounterType counterType,
                        SyncSystemCounterQueryValue QueryValue,
                        SyncSystemCounterBracketValues BracketValues
    )
{
    SyncCounter *pCounter;

    /* this function may be called before SYNC has been initialized, so we
     * have to make sure RTCounter is created.
     */
    if (RTCounter == 0) {
        RTCounter = CreateNewResourceType(FreeCounter, "SyncCounter");
        if (RTCounter == 0) {
            return NULL;
        }
        xorg_list_init(&SysCounterList);
    }

    pCounter = SyncCreateCounter(NULL, FakeClientID(0), initial);

    if (pCounter) {
        SysCounterInfo *psci;

        psci = malloc(sizeof(SysCounterInfo));
        if (!psci) {
            FreeResource(pCounter->sync.id, RT_NONE);
            return pCounter;
        }
        pCounter->pSysCounterInfo = psci;
        psci->pCounter = pCounter;
        psci->name = strdup(name);
        psci->resolution = resolution;
        psci->counterType = counterType;
        psci->QueryValue = QueryValue;
        psci->BracketValues = BracketValues;
        psci->private = NULL;
        XSyncMaxValue(&psci->bracket_greater);
        XSyncMinValue(&psci->bracket_less);
        xorg_list_add(&psci->entry, &SysCounterList);
    }
    return pCounter;
}

void
SyncDestroySystemCounter(void *pSysCounter)
{
    SyncCounter *pCounter = (SyncCounter *) pSysCounter;

    FreeResource(pCounter->sync.id, RT_NONE);
}

static void
SyncComputeBracketValues(SyncCounter * pCounter)
{
    SyncTriggerList *pCur;
    SyncTrigger *pTrigger;
    SysCounterInfo *psci;
    CARD64 *pnewgtval = NULL;
    CARD64 *pnewltval = NULL;
    SyncCounterType ct;

    if (!pCounter)
        return;

    psci = pCounter->pSysCounterInfo;
    ct = pCounter->pSysCounterInfo->counterType;
    if (ct == XSyncCounterNeverChanges)
        return;

    XSyncMaxValue(&psci->bracket_greater);
    XSyncMinValue(&psci->bracket_less);

    for (pCur = pCounter->sync.pTriglist; pCur; pCur = pCur->next) {
        pTrigger = pCur->pTrigger;

        if (pTrigger->test_type == XSyncPositiveComparison &&
            ct != XSyncCounterNeverIncreases) {
            if (XSyncValueLessThan(pCounter->value, pTrigger->test_value) &&
                XSyncValueLessThan(pTrigger->test_value,
                                   psci->bracket_greater)) {
                psci->bracket_greater = pTrigger->test_value;
                pnewgtval = &psci->bracket_greater;
            }
            else if (XSyncValueGreaterThan(pCounter->value, pTrigger->test_value) &&
                     XSyncValueGreaterThan(pTrigger->test_value, psci->bracket_less)) {
                    psci->bracket_less = pTrigger->test_value;
                    pnewltval = &psci->bracket_less;
            }
        }
        else if (pTrigger->test_type == XSyncNegativeComparison &&
                 ct != XSyncCounterNeverDecreases) {
            if (XSyncValueGreaterThan(pCounter->value, pTrigger->test_value) &&
                XSyncValueGreaterThan(pTrigger->test_value,
                                      psci->bracket_less)) {
                psci->bracket_less = pTrigger->test_value;
                pnewltval = &psci->bracket_less;
            }
            else if (XSyncValueLessThan(pCounter->value, pTrigger->test_value) &&
                     XSyncValueLessThan(pTrigger->test_value, psci->bracket_greater)) {
                    psci->bracket_greater = pTrigger->test_value;
                    pnewgtval = &psci->bracket_greater;
            }
        }
        else if (pTrigger->test_type == XSyncNegativeTransition &&
                 ct != XSyncCounterNeverIncreases) {
            if (XSyncValueGreaterOrEqual(pCounter->value, pTrigger->test_value) &&
                XSyncValueGreaterThan(pTrigger->test_value, psci->bracket_less)) {
                    /*
                     * If the value is exactly equal to our threshold, we want one
                     * more event in the negative direction to ensure we pick up
                     * when the value is less than this threshold.
                     */
                    psci->bracket_less = pTrigger->test_value;
                    pnewltval = &psci->bracket_less;
            }
            else if (XSyncValueLessThan(pCounter->value, pTrigger->test_value) &&
                     XSyncValueLessThan(pTrigger->test_value, psci->bracket_greater)) {
                    psci->bracket_greater = pTrigger->test_value;
                    pnewgtval = &psci->bracket_greater;
            }
        }
        else if (pTrigger->test_type == XSyncPositiveTransition &&
                 ct != XSyncCounterNeverDecreases) {
            if (XSyncValueLessOrEqual(pCounter->value, pTrigger->test_value) &&
                XSyncValueLessThan(pTrigger->test_value, psci->bracket_greater)) {
                    /*
                     * If the value is exactly equal to our threshold, we
                     * want one more event in the positive direction to
                     * ensure we pick up when the value *exceeds* this
                     * threshold.
                     */
                    psci->bracket_greater = pTrigger->test_value;
                    pnewgtval = &psci->bracket_greater;
            }
            else if (XSyncValueGreaterThan(pCounter->value, pTrigger->test_value) &&
                     XSyncValueGreaterThan(pTrigger->test_value, psci->bracket_less)) {
                    psci->bracket_less = pTrigger->test_value;
                    pnewltval = &psci->bracket_less;
            }
        }
    }                           /* end for each trigger */

    (*psci->BracketValues) ((void *) pCounter, pnewltval, pnewgtval);

}

/*
 * *****  Resource delete functions
 */

/* ARGSUSED */
static int
FreeAlarm(void *addr, XID id)
{
    SyncAlarm *pAlarm = (SyncAlarm *) addr;

    pAlarm->state = XSyncAlarmDestroyed;

    SyncSendAlarmNotifyEvents(pAlarm);

    /* delete event selections */

    while (pAlarm->pEventClients)
        FreeResource(pAlarm->pEventClients->delete_id, RT_NONE);

    SyncDeleteTriggerFromSyncObject(&pAlarm->trigger);

    free(pAlarm);
    return Success;
}

/*
 * ** Cleanup after the destruction of a Counter
 */
/* ARGSUSED */
static int
FreeCounter(void *env, XID id)
{
    SyncCounter *pCounter = (SyncCounter *) env;
    SyncTriggerList *ptl, *pnext;

    pCounter->sync.beingDestroyed = TRUE;
    /* tell all the counter's triggers that the counter has been destroyed */
    for (ptl = pCounter->sync.pTriglist; ptl; ptl = pnext) {
        (*ptl->pTrigger->CounterDestroyed) (ptl->pTrigger);
        pnext = ptl->next;
        free(ptl);              /* destroy the trigger list as we go */
    }
    if (IsSystemCounter(pCounter)) {
        xorg_list_del(&pCounter->pSysCounterInfo->entry);
        free(pCounter->pSysCounterInfo->name);
        free(pCounter->pSysCounterInfo->private);
        free(pCounter->pSysCounterInfo);
    }
    free(pCounter);
    return Success;
}

/*
 * ** Cleanup after Await
 */
/* ARGSUSED */
static int
FreeAwait(void *addr, XID id)
{
    SyncAwaitUnion *pAwaitUnion = (SyncAwaitUnion *) addr;
    SyncAwait *pAwait;
    int numwaits;

    pAwait = &(pAwaitUnion + 1)->await; /* first await on list */

    /* remove triggers from counters */

    for (numwaits = pAwaitUnion->header.num_waitconditions; numwaits;
         numwaits--, pAwait++) {
        /* If the counter is being destroyed, FreeCounter will delete
         * the trigger list itself, so don't do it here.
         */
        SyncObject *pSync = pAwait->trigger.pSync;

        if (pSync && !pSync->beingDestroyed)
            SyncDeleteTriggerFromSyncObject(&pAwait->trigger);
    }
    free(pAwaitUnion);
    return Success;
}

/* loosely based on dix/events.c/OtherClientGone */
static int
FreeAlarmClient(void *value, XID id)
{
    SyncAlarm *pAlarm = (SyncAlarm *) value;
    SyncAlarmClientList *pCur, *pPrev;

    for (pPrev = NULL, pCur = pAlarm->pEventClients;
         pCur; pPrev = pCur, pCur = pCur->next) {
        if (pCur->delete_id == id) {
            if (pPrev)
                pPrev->next = pCur->next;
            else
                pAlarm->pEventClients = pCur->next;
            free(pCur);
            return Success;
        }
    }
    FatalError("alarm client not on event list");
 /*NOTREACHED*/}

/*
 * *****  Proc functions
 */

/*
 * ** Initialize the extension
 */
static int
ProcSyncInitialize(ClientPtr client)
{
    xSyncInitializeReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = SERVER_SYNC_MAJOR_VERSION,
        .minorVersion = SERVER_SYNC_MINOR_VERSION,
    };

    REQUEST_SIZE_MATCH(xSyncInitializeReq);

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
    }
    WriteToClient(client, sizeof(rep), &rep);
    return Success;
}

/*
 * ** Get list of system counters available through the extension
 */
static int
ProcSyncListSystemCounters(ClientPtr client)
{
    xSyncListSystemCountersReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .nCounters = 0,
    };
    SysCounterInfo *psci;
    int len = 0;
    xSyncSystemCounter *list = NULL, *walklist = NULL;

    REQUEST_SIZE_MATCH(xSyncListSystemCountersReq);

    xorg_list_for_each_entry(psci, &SysCounterList, entry) {
        /* pad to 4 byte boundary */
        len += pad_to_int32(sz_xSyncSystemCounter + strlen(psci->name));
        ++rep.nCounters;
    }

    if (len) {
        walklist = list = malloc(len);
        if (!list)
            return BadAlloc;
    }

    rep.length = bytes_to_int32(len);

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.nCounters);
    }

    xorg_list_for_each_entry(psci, &SysCounterList, entry) {
        int namelen;
        char *pname_in_reply;

        walklist->counter = psci->pCounter->sync.id;
        walklist->resolution_hi = XSyncValueHigh32(psci->resolution);
        walklist->resolution_lo = XSyncValueLow32(psci->resolution);
        namelen = strlen(psci->name);
        walklist->name_length = namelen;

        if (client->swapped) {
            swapl(&walklist->counter);
            swapl(&walklist->resolution_hi);
            swapl(&walklist->resolution_lo);
            swaps(&walklist->name_length);
        }

        pname_in_reply = ((char *) walklist) + sz_xSyncSystemCounter;
        strncpy(pname_in_reply, psci->name, namelen);
        walklist = (xSyncSystemCounter *) (((char *) walklist) +
                                           pad_to_int32(sz_xSyncSystemCounter +
                                                        namelen));
    }

    WriteToClient(client, sizeof(rep), &rep);
    if (len) {
        WriteToClient(client, len, list);
        free(list);
    }

    return Success;
}

/*
 * ** Set client Priority
 */
static int
ProcSyncSetPriority(ClientPtr client)
{
    REQUEST(xSyncSetPriorityReq);
    ClientPtr priorityclient;
    int rc;

    REQUEST_SIZE_MATCH(xSyncSetPriorityReq);

    if (stuff->id == None)
        priorityclient = client;
    else {
        rc = dixLookupClient(&priorityclient, stuff->id, client,
                             DixSetAttrAccess);
        if (rc != Success)
            return rc;
    }

    if (priorityclient->priority != stuff->priority) {
        priorityclient->priority = stuff->priority;

        /*  The following will force the server back into WaitForSomething
         *  so that the change in this client's priority is immediately
         *  reflected.
         */
        isItTimeToYield = TRUE;
        dispatchException |= DE_PRIORITYCHANGE;
    }
    return Success;
}

/*
 * ** Get client Priority
 */
static int
ProcSyncGetPriority(ClientPtr client)
{
    REQUEST(xSyncGetPriorityReq);
    xSyncGetPriorityReply rep;
    ClientPtr priorityclient;
    int rc;

    REQUEST_SIZE_MATCH(xSyncGetPriorityReq);

    if (stuff->id == None)
        priorityclient = client;
    else {
        rc = dixLookupClient(&priorityclient, stuff->id, client,
                             DixGetAttrAccess);
        if (rc != Success)
            return rc;
    }

    rep = (xSyncGetPriorityReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .priority = priorityclient->priority
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.priority);
    }

    WriteToClient(client, sizeof(xSyncGetPriorityReply), &rep);

    return Success;
}

/*
 * ** Create a new counter
 */
static int
ProcSyncCreateCounter(ClientPtr client)
{
    REQUEST(xSyncCreateCounterReq);
    CARD64 initial;

    REQUEST_SIZE_MATCH(xSyncCreateCounterReq);

    LEGAL_NEW_RESOURCE(stuff->cid, client);

    XSyncIntsToValue(&initial, stuff->initial_value_lo,
                     stuff->initial_value_hi);
    if (!SyncCreateCounter(client, stuff->cid, initial))
        return BadAlloc;

    return Success;
}

/*
 * ** Set Counter value
 */
static int
ProcSyncSetCounter(ClientPtr client)
{
    REQUEST(xSyncSetCounterReq);
    SyncCounter *pCounter;
    CARD64 newvalue;
    int rc;

    REQUEST_SIZE_MATCH(xSyncSetCounterReq);

    rc = dixLookupResourceByType((void **) &pCounter, stuff->cid, RTCounter,
                                 client, DixWriteAccess);
    if (rc != Success)
        return rc;

    if (IsSystemCounter(pCounter)) {
        client->errorValue = stuff->cid;
        return BadAccess;
    }

    XSyncIntsToValue(&newvalue, stuff->value_lo, stuff->value_hi);
    SyncChangeCounter(pCounter, newvalue);
    return Success;
}

/*
 * ** Change Counter value
 */
static int
ProcSyncChangeCounter(ClientPtr client)
{
    REQUEST(xSyncChangeCounterReq);
    SyncCounter *pCounter;
    CARD64 newvalue;
    Bool overflow;
    int rc;

    REQUEST_SIZE_MATCH(xSyncChangeCounterReq);

    rc = dixLookupResourceByType((void **) &pCounter, stuff->cid, RTCounter,
                                 client, DixWriteAccess);
    if (rc != Success)
        return rc;

    if (IsSystemCounter(pCounter)) {
        client->errorValue = stuff->cid;
        return BadAccess;
    }

    XSyncIntsToValue(&newvalue, stuff->value_lo, stuff->value_hi);
    XSyncValueAdd(&newvalue, pCounter->value, newvalue, &overflow);
    if (overflow) {
        /* XXX 64 bit value can't fit in 32 bits; do the best we can */
        client->errorValue = stuff->value_hi;
        return BadValue;
    }
    SyncChangeCounter(pCounter, newvalue);
    return Success;
}

/*
 * ** Destroy a counter
 */
static int
ProcSyncDestroyCounter(ClientPtr client)
{
    REQUEST(xSyncDestroyCounterReq);
    SyncCounter *pCounter;
    int rc;

    REQUEST_SIZE_MATCH(xSyncDestroyCounterReq);

    rc = dixLookupResourceByType((void **) &pCounter, stuff->counter,
                                 RTCounter, client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    if (IsSystemCounter(pCounter)) {
        client->errorValue = stuff->counter;
        return BadAccess;
    }
    FreeResource(pCounter->sync.id, RT_NONE);
    return Success;
}

static SyncAwaitUnion *
SyncAwaitPrologue(ClientPtr client, int items)
{
    SyncAwaitUnion *pAwaitUnion;

    /*  all the memory for the entire await list is allocated
     *  here in one chunk
     */
    pAwaitUnion = xallocarray(items + 1, sizeof(SyncAwaitUnion));
    if (!pAwaitUnion)
        return NULL;

    /* first item is the header, remainder are real wait conditions */

    pAwaitUnion->header.delete_id = FakeClientID(client->index);
    pAwaitUnion->header.client = client;
    pAwaitUnion->header.num_waitconditions = 0;

    if (!AddResource(pAwaitUnion->header.delete_id, RTAwait, pAwaitUnion))
        return NULL;

    return pAwaitUnion;
}

static void
SyncAwaitEpilogue(ClientPtr client, int items, SyncAwaitUnion * pAwaitUnion)
{
    SyncAwait *pAwait;
    int i;

    IgnoreClient(client);

    /* see if any of the triggers are already true */

    pAwait = &(pAwaitUnion + 1)->await; /* skip over header */
    for (i = 0; i < items; i++, pAwait++) {
        CARD64 value;

        /*  don't have to worry about NULL counters because the request
         *  errors before we get here out if they occur
         */
        switch (pAwait->trigger.pSync->type) {
        case SYNC_COUNTER:
            value = ((SyncCounter *) pAwait->trigger.pSync)->value;
            break;
        default:
            XSyncIntToValue(&value, 0);
        }

        if ((*pAwait->trigger.CheckTrigger) (&pAwait->trigger, value)) {
            (*pAwait->trigger.TriggerFired) (&pAwait->trigger);
            break;              /* once is enough */
        }
    }
}

/*
 * ** Await
 */
static int
ProcSyncAwait(ClientPtr client)
{
    REQUEST(xSyncAwaitReq);
    int len, items;
    int i;
    xSyncWaitCondition *pProtocolWaitConds;
    SyncAwaitUnion *pAwaitUnion;
    SyncAwait *pAwait;
    int status;

    REQUEST_AT_LEAST_SIZE(xSyncAwaitReq);

    len = client->req_len << 2;
    len -= sz_xSyncAwaitReq;
    items = len / sz_xSyncWaitCondition;

    if (items * sz_xSyncWaitCondition != len) {
        return BadLength;
    }
    if (items == 0) {
        client->errorValue = items;     /* XXX protocol change */
        return BadValue;
    }

    if (!(pAwaitUnion = SyncAwaitPrologue(client, items)))
        return BadAlloc;

    /* don't need to do any more memory allocation for this request! */

    pProtocolWaitConds = (xSyncWaitCondition *) &stuff[1];

    pAwait = &(pAwaitUnion + 1)->await; /* skip over header */
    for (i = 0; i < items; i++, pProtocolWaitConds++, pAwait++) {
        if (pProtocolWaitConds->counter == None) {      /* XXX protocol change */
            /*  this should take care of removing any triggers created by
             *  this request that have already been registered on sync objects
             */
            FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
            client->errorValue = pProtocolWaitConds->counter;
            return SyncErrorBase + XSyncBadCounter;
        }

        /* sanity checks are in SyncInitTrigger */
        pAwait->trigger.pSync = NULL;
        pAwait->trigger.value_type = pProtocolWaitConds->value_type;
        XSyncIntsToValue(&pAwait->trigger.wait_value,
                         pProtocolWaitConds->wait_value_lo,
                         pProtocolWaitConds->wait_value_hi);
        pAwait->trigger.test_type = pProtocolWaitConds->test_type;

        status = SyncInitTrigger(client, &pAwait->trigger,
                                 pProtocolWaitConds->counter, RTCounter,
                                 XSyncCAAllTrigger);
        if (status != Success) {
            /*  this should take care of removing any triggers created by
             *  this request that have already been registered on sync objects
             */
            FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
            return status;
        }
        /* this is not a mistake -- same function works for both cases */
        pAwait->trigger.TriggerFired = SyncAwaitTriggerFired;
        pAwait->trigger.CounterDestroyed = SyncAwaitTriggerFired;
        XSyncIntsToValue(&pAwait->event_threshold,
                         pProtocolWaitConds->event_threshold_lo,
                         pProtocolWaitConds->event_threshold_hi);
        pAwait->pHeader = &pAwaitUnion->header;
        pAwaitUnion->header.num_waitconditions++;
    }

    SyncAwaitEpilogue(client, items, pAwaitUnion);

    return Success;
}

/*
 * ** Query a counter
 */
static int
ProcSyncQueryCounter(ClientPtr client)
{
    REQUEST(xSyncQueryCounterReq);
    xSyncQueryCounterReply rep;
    SyncCounter *pCounter;
    int rc;

    REQUEST_SIZE_MATCH(xSyncQueryCounterReq);

    rc = dixLookupResourceByType((void **) &pCounter, stuff->counter,
                                 RTCounter, client, DixReadAccess);
    if (rc != Success)
        return rc;

    /* if system counter, ask it what the current value is */
    if (IsSystemCounter(pCounter)) {
        (*pCounter->pSysCounterInfo->QueryValue) ((void *) pCounter,
                                                  &pCounter->value);
    }

    rep = (xSyncQueryCounterReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .value_hi = XSyncValueHigh32(pCounter->value),
        .value_lo = XSyncValueLow32(pCounter->value)
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.value_hi);
        swapl(&rep.value_lo);
    }
    WriteToClient(client, sizeof(xSyncQueryCounterReply), &rep);
    return Success;
}

/*
 * ** Create Alarm
 */
static int
ProcSyncCreateAlarm(ClientPtr client)
{
    REQUEST(xSyncCreateAlarmReq);
    SyncAlarm *pAlarm;
    int status;
    unsigned long len, vmask;
    SyncTrigger *pTrigger;

    REQUEST_AT_LEAST_SIZE(xSyncCreateAlarmReq);

    LEGAL_NEW_RESOURCE(stuff->id, client);

    vmask = stuff->valueMask;
    len = client->req_len - bytes_to_int32(sizeof(xSyncCreateAlarmReq));
    /* the "extra" call to Ones accounts for the presence of 64 bit values */
    if (len != (Ones(vmask) + Ones(vmask & (XSyncCAValue | XSyncCADelta))))
        return BadLength;

    if (!(pAlarm = malloc(sizeof(SyncAlarm)))) {
        return BadAlloc;
    }

    /* set up defaults */

    pTrigger = &pAlarm->trigger;
    pTrigger->pSync = NULL;
    pTrigger->value_type = XSyncAbsolute;
    XSyncIntToValue(&pTrigger->wait_value, 0L);
    pTrigger->test_type = XSyncPositiveComparison;
    pTrigger->TriggerFired = SyncAlarmTriggerFired;
    pTrigger->CounterDestroyed = SyncAlarmCounterDestroyed;
    status = SyncInitTrigger(client, pTrigger, None, RTCounter,
                             XSyncCAAllTrigger);
    if (status != Success) {
        free(pAlarm);
        return status;
    }

    pAlarm->client = client;
    pAlarm->alarm_id = stuff->id;
    XSyncIntToValue(&pAlarm->delta, 1L);
    pAlarm->events = TRUE;
    pAlarm->state = XSyncAlarmInactive;
    pAlarm->pEventClients = NULL;
    status = SyncChangeAlarmAttributes(client, pAlarm, vmask,
                                       (CARD32 *) &stuff[1]);
    if (status != Success) {
        free(pAlarm);
        return status;
    }

    if (!AddResource(stuff->id, RTAlarm, pAlarm))
        return BadAlloc;

    /*  see if alarm already triggered.  NULL counter will not trigger
     *  in CreateAlarm and sets alarm state to Inactive.
     */

    if (!pTrigger->pSync) {
        pAlarm->state = XSyncAlarmInactive;     /* XXX protocol change */
    }
    else {
        SyncCounter *pCounter;

        if (!SyncCheckWarnIsCounter(pTrigger->pSync,
                                    WARN_INVALID_COUNTER_ALARM)) {
            FreeResource(stuff->id, RT_NONE);
            return BadAlloc;
        }

        pCounter = (SyncCounter *) pTrigger->pSync;

        if ((*pTrigger->CheckTrigger) (pTrigger, pCounter->value))
            (*pTrigger->TriggerFired) (pTrigger);
    }

    return Success;
}

/*
 * ** Change Alarm
 */
static int
ProcSyncChangeAlarm(ClientPtr client)
{
    REQUEST(xSyncChangeAlarmReq);
    SyncAlarm *pAlarm;
    SyncCounter *pCounter = NULL;
    long vmask;
    int len, status;

    REQUEST_AT_LEAST_SIZE(xSyncChangeAlarmReq);

    status = dixLookupResourceByType((void **) &pAlarm, stuff->alarm, RTAlarm,
                                     client, DixWriteAccess);
    if (status != Success)
        return status;

    vmask = stuff->valueMask;
    len = client->req_len - bytes_to_int32(sizeof(xSyncChangeAlarmReq));
    /* the "extra" call to Ones accounts for the presence of 64 bit values */
    if (len != (Ones(vmask) + Ones(vmask & (XSyncCAValue | XSyncCADelta))))
        return BadLength;

    if ((status = SyncChangeAlarmAttributes(client, pAlarm, vmask,
                                            (CARD32 *) &stuff[1])) != Success)
        return status;

    if (SyncCheckWarnIsCounter(pAlarm->trigger.pSync,
                               WARN_INVALID_COUNTER_ALARM))
        pCounter = (SyncCounter *) pAlarm->trigger.pSync;

    /*  see if alarm already triggered.  NULL counter WILL trigger
     *  in ChangeAlarm.
     */

    if (!pCounter ||
        (*pAlarm->trigger.CheckTrigger) (&pAlarm->trigger, pCounter->value)) {
        (*pAlarm->trigger.TriggerFired) (&pAlarm->trigger);
    }
    return Success;
}

static int
ProcSyncQueryAlarm(ClientPtr client)
{
    REQUEST(xSyncQueryAlarmReq);
    SyncAlarm *pAlarm;
    xSyncQueryAlarmReply rep;
    SyncTrigger *pTrigger;
    int rc;

    REQUEST_SIZE_MATCH(xSyncQueryAlarmReq);

    rc = dixLookupResourceByType((void **) &pAlarm, stuff->alarm, RTAlarm,
                                 client, DixReadAccess);
    if (rc != Success)
        return rc;

    pTrigger = &pAlarm->trigger;
    rep = (xSyncQueryAlarmReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length =
          bytes_to_int32(sizeof(xSyncQueryAlarmReply) - sizeof(xGenericReply)),
        .counter = (pTrigger->pSync) ? pTrigger->pSync->id : None,

#if 0  /* XXX unclear what to do, depends on whether relative value-types
        * are "consumed" immediately and are considered absolute from then
        * on.
        */
        .value_type = pTrigger->value_type,
        .wait_value_hi = XSyncValueHigh32(pTrigger->wait_value),
        .wait_value_lo = XSyncValueLow32(pTrigger->wait_value),
#else
        .value_type = XSyncAbsolute,
        .wait_value_hi = XSyncValueHigh32(pTrigger->test_value),
        .wait_value_lo = XSyncValueLow32(pTrigger->test_value),
#endif

        .test_type = pTrigger->test_type,
        .delta_hi = XSyncValueHigh32(pAlarm->delta),
        .delta_lo = XSyncValueLow32(pAlarm->delta),
        .events = pAlarm->events,
        .state = pAlarm->state
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.counter);
        swapl(&rep.wait_value_hi);
        swapl(&rep.wait_value_lo);
        swapl(&rep.test_type);
        swapl(&rep.delta_hi);
        swapl(&rep.delta_lo);
    }

    WriteToClient(client, sizeof(xSyncQueryAlarmReply), &rep);
    return Success;
}

static int
ProcSyncDestroyAlarm(ClientPtr client)
{
    SyncAlarm *pAlarm;
    int rc;

    REQUEST(xSyncDestroyAlarmReq);

    REQUEST_SIZE_MATCH(xSyncDestroyAlarmReq);

    rc = dixLookupResourceByType((void **) &pAlarm, stuff->alarm, RTAlarm,
                                 client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->alarm, RT_NONE);
    return Success;
}

static int
ProcSyncCreateFence(ClientPtr client)
{
    REQUEST(xSyncCreateFenceReq);
    DrawablePtr pDraw;
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncCreateFenceReq);

    rc = dixLookupDrawable(&pDraw, stuff->d, client, M_ANY, DixGetAttrAccess);
    if (rc != Success)
        return rc;

    LEGAL_NEW_RESOURCE(stuff->fid, client);

    if (!(pFence = (SyncFence *) SyncCreate(client, stuff->fid, SYNC_FENCE)))
        return BadAlloc;

    miSyncInitFence(pDraw->pScreen, pFence, stuff->initially_triggered);

    if (!AddResource(stuff->fid, RTFence, (void *) pFence))
        return BadAlloc;

    return client->noClientException;
}

static int
FreeFence(void *obj, XID id)
{
    SyncFence *pFence = (SyncFence *) obj;

    miSyncDestroyFence(pFence);

    return Success;
}

int
SyncVerifyFence(SyncFence ** ppSyncFence, XID fid, ClientPtr client, Mask mode)
{
    int rc = dixLookupResourceByType((void **) ppSyncFence, fid, RTFence,
                                     client, mode);

    if (rc != Success)
        client->errorValue = fid;

    return rc;
}

static int
ProcSyncTriggerFence(ClientPtr client)
{
    REQUEST(xSyncTriggerFenceReq);
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncTriggerFenceReq);

    rc = dixLookupResourceByType((void **) &pFence, stuff->fid, RTFence,
                                 client, DixWriteAccess);
    if (rc != Success)
        return rc;

    miSyncTriggerFence(pFence);

    return client->noClientException;
}

static int
ProcSyncResetFence(ClientPtr client)
{
    REQUEST(xSyncResetFenceReq);
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncResetFenceReq);

    rc = dixLookupResourceByType((void **) &pFence, stuff->fid, RTFence,
                                 client, DixWriteAccess);
    if (rc != Success)
        return rc;

    if (pFence->funcs.CheckTriggered(pFence) != TRUE)
        return BadMatch;

    pFence->funcs.Reset(pFence);

    return client->noClientException;
}

static int
ProcSyncDestroyFence(ClientPtr client)
{
    REQUEST(xSyncDestroyFenceReq);
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncDestroyFenceReq);

    rc = dixLookupResourceByType((void **) &pFence, stuff->fid, RTFence,
                                 client, DixDestroyAccess);
    if (rc != Success)
        return rc;

    FreeResource(stuff->fid, RT_NONE);
    return client->noClientException;
}

static int
ProcSyncQueryFence(ClientPtr client)
{
    REQUEST(xSyncQueryFenceReq);
    xSyncQueryFenceReply rep;
    SyncFence *pFence;
    int rc;

    REQUEST_SIZE_MATCH(xSyncQueryFenceReq);

    rc = dixLookupResourceByType((void **) &pFence, stuff->fid,
                                 RTFence, client, DixReadAccess);
    if (rc != Success)
        return rc;

    rep = (xSyncQueryFenceReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,

        .triggered = pFence->funcs.CheckTriggered(pFence)
    };

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
    }

    WriteToClient(client, sizeof(xSyncQueryFenceReply), &rep);
    return client->noClientException;
}

static int
ProcSyncAwaitFence(ClientPtr client)
{
    REQUEST(xSyncAwaitFenceReq);
    SyncAwaitUnion *pAwaitUnion;
    SyncAwait *pAwait;

    /* Use CARD32 rather than XSyncFence because XIDs are hard-coded to
     * CARD32 in protocol definitions */
    CARD32 *pProtocolFences;
    int status;
    int len;
    int items;
    int i;

    REQUEST_AT_LEAST_SIZE(xSyncAwaitFenceReq);

    len = client->req_len << 2;
    len -= sz_xSyncAwaitFenceReq;
    items = len / sizeof(CARD32);

    if (items * sizeof(CARD32) != len) {
        return BadLength;
    }
    if (items == 0) {
        client->errorValue = items;
        return BadValue;
    }

    if (!(pAwaitUnion = SyncAwaitPrologue(client, items)))
        return BadAlloc;

    /* don't need to do any more memory allocation for this request! */

    pProtocolFences = (CARD32 *) &stuff[1];

    pAwait = &(pAwaitUnion + 1)->await; /* skip over header */
    for (i = 0; i < items; i++, pProtocolFences++, pAwait++) {
        if (*pProtocolFences == None) {
            /*  this should take care of removing any triggers created by
             *  this request that have already been registered on sync objects
             */
            FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
            client->errorValue = *pProtocolFences;
            return SyncErrorBase + XSyncBadFence;
        }

        pAwait->trigger.pSync = NULL;
        /* Provide acceptable values for these unused fields to
         * satisfy SyncInitTrigger's validation logic
         */
        pAwait->trigger.value_type = XSyncAbsolute;
        XSyncIntToValue(&pAwait->trigger.wait_value, 0);
        pAwait->trigger.test_type = 0;

        status = SyncInitTrigger(client, &pAwait->trigger,
                                 *pProtocolFences, RTFence, XSyncCAAllTrigger);
        if (status != Success) {
            /*  this should take care of removing any triggers created by
             *  this request that have already been registered on sync objects
             */
            FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
            return status;
        }
        /* this is not a mistake -- same function works for both cases */
        pAwait->trigger.TriggerFired = SyncAwaitTriggerFired;
        pAwait->trigger.CounterDestroyed = SyncAwaitTriggerFired;
        /* event_threshold is unused for fence syncs */
        XSyncIntToValue(&pAwait->event_threshold, 0);
        pAwait->pHeader = &pAwaitUnion->header;
        pAwaitUnion->header.num_waitconditions++;
    }

    SyncAwaitEpilogue(client, items, pAwaitUnion);

    return client->noClientException;
}

/*
 * ** Given an extension request, call the appropriate request procedure
 */
static int
ProcSyncDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_SyncInitialize:
        return ProcSyncInitialize(client);
    case X_SyncListSystemCounters:
        return ProcSyncListSystemCounters(client);
    case X_SyncCreateCounter:
        return ProcSyncCreateCounter(client);
    case X_SyncSetCounter:
        return ProcSyncSetCounter(client);
    case X_SyncChangeCounter:
        return ProcSyncChangeCounter(client);
    case X_SyncQueryCounter:
        return ProcSyncQueryCounter(client);
    case X_SyncDestroyCounter:
        return ProcSyncDestroyCounter(client);
    case X_SyncAwait:
        return ProcSyncAwait(client);
    case X_SyncCreateAlarm:
        return ProcSyncCreateAlarm(client);
    case X_SyncChangeAlarm:
        return ProcSyncChangeAlarm(client);
    case X_SyncQueryAlarm:
        return ProcSyncQueryAlarm(client);
    case X_SyncDestroyAlarm:
        return ProcSyncDestroyAlarm(client);
    case X_SyncSetPriority:
        return ProcSyncSetPriority(client);
    case X_SyncGetPriority:
        return ProcSyncGetPriority(client);
    case X_SyncCreateFence:
        return ProcSyncCreateFence(client);
    case X_SyncTriggerFence:
        return ProcSyncTriggerFence(client);
    case X_SyncResetFence:
        return ProcSyncResetFence(client);
    case X_SyncDestroyFence:
        return ProcSyncDestroyFence(client);
    case X_SyncQueryFence:
        return ProcSyncQueryFence(client);
    case X_SyncAwaitFence:
        return ProcSyncAwaitFence(client);
    default:
        return BadRequest;
    }
}

/*
 * Boring Swapping stuff ...
 */

static int
SProcSyncInitialize(ClientPtr client)
{
    REQUEST(xSyncInitializeReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncInitializeReq);

    return ProcSyncInitialize(client);
}

static int
SProcSyncListSystemCounters(ClientPtr client)
{
    REQUEST(xSyncListSystemCountersReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncListSystemCountersReq);

    return ProcSyncListSystemCounters(client);
}

static int
SProcSyncCreateCounter(ClientPtr client)
{
    REQUEST(xSyncCreateCounterReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncCreateCounterReq);
    swapl(&stuff->cid);
    swapl(&stuff->initial_value_lo);
    swapl(&stuff->initial_value_hi);

    return ProcSyncCreateCounter(client);
}

static int
SProcSyncSetCounter(ClientPtr client)
{
    REQUEST(xSyncSetCounterReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncSetCounterReq);
    swapl(&stuff->cid);
    swapl(&stuff->value_lo);
    swapl(&stuff->value_hi);

    return ProcSyncSetCounter(client);
}

static int
SProcSyncChangeCounter(ClientPtr client)
{
    REQUEST(xSyncChangeCounterReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncChangeCounterReq);
    swapl(&stuff->cid);
    swapl(&stuff->value_lo);
    swapl(&stuff->value_hi);

    return ProcSyncChangeCounter(client);
}

static int
SProcSyncQueryCounter(ClientPtr client)
{
    REQUEST(xSyncQueryCounterReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncQueryCounterReq);
    swapl(&stuff->counter);

    return ProcSyncQueryCounter(client);
}

static int
SProcSyncDestroyCounter(ClientPtr client)
{
    REQUEST(xSyncDestroyCounterReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncDestroyCounterReq);
    swapl(&stuff->counter);

    return ProcSyncDestroyCounter(client);
}

static int
SProcSyncAwait(ClientPtr client)
{
    REQUEST(xSyncAwaitReq);
    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xSyncAwaitReq);
    SwapRestL(stuff);

    return ProcSyncAwait(client);
}

static int
SProcSyncCreateAlarm(ClientPtr client)
{
    REQUEST(xSyncCreateAlarmReq);
    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xSyncCreateAlarmReq);
    swapl(&stuff->id);
    swapl(&stuff->valueMask);
    SwapRestL(stuff);

    return ProcSyncCreateAlarm(client);
}

static int
SProcSyncChangeAlarm(ClientPtr client)
{
    REQUEST(xSyncChangeAlarmReq);
    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xSyncChangeAlarmReq);
    swapl(&stuff->alarm);
    swapl(&stuff->valueMask);
    SwapRestL(stuff);
    return ProcSyncChangeAlarm(client);
}

static int
SProcSyncQueryAlarm(ClientPtr client)
{
    REQUEST(xSyncQueryAlarmReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncQueryAlarmReq);
    swapl(&stuff->alarm);

    return ProcSyncQueryAlarm(client);
}

static int
SProcSyncDestroyAlarm(ClientPtr client)
{
    REQUEST(xSyncDestroyAlarmReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncDestroyAlarmReq);
    swapl(&stuff->alarm);

    return ProcSyncDestroyAlarm(client);
}

static int
SProcSyncSetPriority(ClientPtr client)
{
    REQUEST(xSyncSetPriorityReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncSetPriorityReq);
    swapl(&stuff->id);
    swapl(&stuff->priority);

    return ProcSyncSetPriority(client);
}

static int
SProcSyncGetPriority(ClientPtr client)
{
    REQUEST(xSyncGetPriorityReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncGetPriorityReq);
    swapl(&stuff->id);

    return ProcSyncGetPriority(client);
}

static int
SProcSyncCreateFence(ClientPtr client)
{
    REQUEST(xSyncCreateFenceReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncCreateFenceReq);
    swapl(&stuff->fid);

    return ProcSyncCreateFence(client);
}

static int
SProcSyncTriggerFence(ClientPtr client)
{
    REQUEST(xSyncTriggerFenceReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncTriggerFenceReq);
    swapl(&stuff->fid);

    return ProcSyncTriggerFence(client);
}

static int
SProcSyncResetFence(ClientPtr client)
{
    REQUEST(xSyncResetFenceReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncResetFenceReq);
    swapl(&stuff->fid);

    return ProcSyncResetFence(client);
}

static int
SProcSyncDestroyFence(ClientPtr client)
{
    REQUEST(xSyncDestroyFenceReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncDestroyFenceReq);
    swapl(&stuff->fid);

    return ProcSyncDestroyFence(client);
}

static int
SProcSyncQueryFence(ClientPtr client)
{
    REQUEST(xSyncQueryFenceReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xSyncQueryFenceReq);
    swapl(&stuff->fid);

    return ProcSyncQueryFence(client);
}

static int
SProcSyncAwaitFence(ClientPtr client)
{
    REQUEST(xSyncAwaitFenceReq);
    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xSyncAwaitFenceReq);
    SwapRestL(stuff);

    return ProcSyncAwaitFence(client);
}

static int
SProcSyncDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_SyncInitialize:
        return SProcSyncInitialize(client);
    case X_SyncListSystemCounters:
        return SProcSyncListSystemCounters(client);
    case X_SyncCreateCounter:
        return SProcSyncCreateCounter(client);
    case X_SyncSetCounter:
        return SProcSyncSetCounter(client);
    case X_SyncChangeCounter:
        return SProcSyncChangeCounter(client);
    case X_SyncQueryCounter:
        return SProcSyncQueryCounter(client);
    case X_SyncDestroyCounter:
        return SProcSyncDestroyCounter(client);
    case X_SyncAwait:
        return SProcSyncAwait(client);
    case X_SyncCreateAlarm:
        return SProcSyncCreateAlarm(client);
    case X_SyncChangeAlarm:
        return SProcSyncChangeAlarm(client);
    case X_SyncQueryAlarm:
        return SProcSyncQueryAlarm(client);
    case X_SyncDestroyAlarm:
        return SProcSyncDestroyAlarm(client);
    case X_SyncSetPriority:
        return SProcSyncSetPriority(client);
    case X_SyncGetPriority:
        return SProcSyncGetPriority(client);
    case X_SyncCreateFence:
        return SProcSyncCreateFence(client);
    case X_SyncTriggerFence:
        return SProcSyncTriggerFence(client);
    case X_SyncResetFence:
        return SProcSyncResetFence(client);
    case X_SyncDestroyFence:
        return SProcSyncDestroyFence(client);
    case X_SyncQueryFence:
        return SProcSyncQueryFence(client);
    case X_SyncAwaitFence:
        return SProcSyncAwaitFence(client);
    default:
        return BadRequest;
    }
}

/*
 * Event Swapping
 */

static void
SCounterNotifyEvent(xSyncCounterNotifyEvent * from,
                    xSyncCounterNotifyEvent * to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->counter, to->counter);
    cpswapl(from->wait_value_lo, to->wait_value_lo);
    cpswapl(from->wait_value_hi, to->wait_value_hi);
    cpswapl(from->counter_value_lo, to->counter_value_lo);
    cpswapl(from->counter_value_hi, to->counter_value_hi);
    cpswapl(from->time, to->time);
    cpswaps(from->count, to->count);
    to->destroyed = from->destroyed;
}

static void
SAlarmNotifyEvent(xSyncAlarmNotifyEvent * from, xSyncAlarmNotifyEvent * to)
{
    to->type = from->type;
    to->kind = from->kind;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->alarm, to->alarm);
    cpswapl(from->counter_value_lo, to->counter_value_lo);
    cpswapl(from->counter_value_hi, to->counter_value_hi);
    cpswapl(from->alarm_value_lo, to->alarm_value_lo);
    cpswapl(from->alarm_value_hi, to->alarm_value_hi);
    cpswapl(from->time, to->time);
    to->state = from->state;
}

/*
 * ** Close everything down. ** This is fairly simple for now.
 */
/* ARGSUSED */
static void
SyncResetProc(ExtensionEntry * extEntry)
{
    RTCounter = 0;
}

/*
 * ** Initialise the extension.
 */
void
SyncExtensionInit(void)
{
    ExtensionEntry *extEntry;
    int s;

    for (s = 0; s < screenInfo.numScreens; s++)
        miSyncSetup(screenInfo.screens[s]);

    if (RTCounter == 0) {
        RTCounter = CreateNewResourceType(FreeCounter, "SyncCounter");
        xorg_list_init(&SysCounterList);
    }
    RTAlarm = CreateNewResourceType(FreeAlarm, "SyncAlarm");
    RTAwait = CreateNewResourceType(FreeAwait, "SyncAwait");
    RTFence = CreateNewResourceType(FreeFence, "SyncFence");
    if (RTAwait)
        RTAwait |= RC_NEVERRETAIN;
    RTAlarmClient = CreateNewResourceType(FreeAlarmClient, "SyncAlarmClient");
    if (RTAlarmClient)
        RTAlarmClient |= RC_NEVERRETAIN;

    if (RTCounter == 0 || RTAwait == 0 || RTAlarm == 0 ||
        RTAlarmClient == 0 ||
        (extEntry = AddExtension(SYNC_NAME,
                                 XSyncNumberEvents, XSyncNumberErrors,
                                 ProcSyncDispatch, SProcSyncDispatch,
                                 SyncResetProc, StandardMinorOpcode)) == NULL) {
        ErrorF("Sync Extension %d.%d failed to Initialise\n",
               SYNC_MAJOR_VERSION, SYNC_MINOR_VERSION);
        return;
    }

    SyncEventBase = extEntry->eventBase;
    SyncErrorBase = extEntry->errorBase;
    EventSwapVector[SyncEventBase + XSyncCounterNotify] =
        (EventSwapPtr) SCounterNotifyEvent;
    EventSwapVector[SyncEventBase + XSyncAlarmNotify] =
        (EventSwapPtr) SAlarmNotifyEvent;

    SetResourceTypeErrorValue(RTCounter, SyncErrorBase + XSyncBadCounter);
    SetResourceTypeErrorValue(RTAlarm, SyncErrorBase + XSyncBadAlarm);
    SetResourceTypeErrorValue(RTFence, SyncErrorBase + XSyncBadFence);

    /*
     * Although SERVERTIME is implemented by the OS layer, we initialise it
     * here because doing it in OsInit() is too early. The resource database
     * is not initialised when OsInit() is called. This is just about OK
     * because there is always a servertime counter.
     */
    SyncInitServerTime();
    SyncInitIdleTime();

#ifdef DEBUG
    fprintf(stderr, "Sync Extension %d.%d\n",
            SYNC_MAJOR_VERSION, SYNC_MINOR_VERSION);
#endif
}

/*
 * ***** SERVERTIME implementation - should go in its own file in OS directory?
 */

static void *ServertimeCounter;
static XSyncValue Now;
static XSyncValue *pnext_time;

#define GetTime()\
{\
    unsigned long millis = GetTimeInMillis();\
    unsigned long maxis = XSyncValueHigh32(Now);\
    if (millis < XSyncValueLow32(Now)) maxis++;\
    XSyncIntsToValue(&Now, millis, maxis);\
}

/*
*** Server Block Handler
*** code inspired by multibuffer extension (now deprecated)
 */
 /*ARGSUSED*/ static void
ServertimeBlockHandler(void *env, struct timeval **wt, void *LastSelectMask)
{
    XSyncValue delay;
    unsigned long timeout;

    if (pnext_time) {
        GetTime();

        if (XSyncValueGreaterOrEqual(Now, *pnext_time)) {
            timeout = 0;
        }
        else {
            Bool overflow;

            XSyncValueSubtract(&delay, *pnext_time, Now, &overflow);
            (void) overflow;
            timeout = XSyncValueLow32(delay);
        }
        AdjustWaitForDelay(wt, timeout);        /* os/utils.c */
    }
}

/*
*** Wakeup Handler
 */
 /*ARGSUSED*/ static void
ServertimeWakeupHandler(void *env, int rc, void *LastSelectMask)
{
    if (pnext_time) {
        GetTime();

        if (XSyncValueGreaterOrEqual(Now, *pnext_time)) {
            SyncChangeCounter(ServertimeCounter, Now);
        }
    }
}

static void
ServertimeQueryValue(void *pCounter, CARD64 * pValue_return)
{
    GetTime();
    *pValue_return = Now;
}

static void
ServertimeBracketValues(void *pCounter, CARD64 * pbracket_less,
                        CARD64 * pbracket_greater)
{
    if (!pnext_time && pbracket_greater) {
        RegisterBlockAndWakeupHandlers(ServertimeBlockHandler,
                                       ServertimeWakeupHandler, NULL);
    }
    else if (pnext_time && !pbracket_greater) {
        RemoveBlockAndWakeupHandlers(ServertimeBlockHandler,
                                     ServertimeWakeupHandler, NULL);
    }
    pnext_time = pbracket_greater;
}

static void
SyncInitServerTime(void)
{
    CARD64 resolution;

    XSyncIntsToValue(&Now, GetTimeInMillis(), 0);
    XSyncIntToValue(&resolution, 4);
    ServertimeCounter = SyncCreateSystemCounter("SERVERTIME", Now, resolution,
                                                XSyncCounterNeverDecreases,
                                                ServertimeQueryValue,
                                                ServertimeBracketValues);
    pnext_time = NULL;
}

/*
 * IDLETIME implementation
 */

typedef struct {
    XSyncValue *value_less;
    XSyncValue *value_greater;
    int deviceid;
} IdleCounterPriv;

static void
IdleTimeQueryValue(void *pCounter, CARD64 * pValue_return)
{
    int deviceid;
    CARD32 idle;

    if (pCounter) {
        SyncCounter *counter = pCounter;
        IdleCounterPriv *priv = SysCounterGetPrivate(counter);
        deviceid = priv->deviceid;
    }
    else
        deviceid = XIAllDevices;
    idle = GetTimeInMillis() - LastEventTime(deviceid).milliseconds;
    XSyncIntsToValue(pValue_return, idle, 0);
}

static void
IdleTimeBlockHandler(void *pCounter, struct timeval **wt, void *LastSelectMask)
{
    SyncCounter *counter = pCounter;
    IdleCounterPriv *priv = SysCounterGetPrivate(counter);
    XSyncValue *less = priv->value_less,
               *greater = priv->value_greater;
    XSyncValue idle, old_idle;
    SyncTriggerList *list = counter->sync.pTriglist;
    SyncTrigger *trig;

    if (!less && !greater)
        return;

    old_idle = counter->value;
    IdleTimeQueryValue(counter, &idle);
    counter->value = idle;      /* push, so CheckTrigger works */

    /**
     * There's an indefinite amount of time between ProcessInputEvents()
     * where the idle time is reset and the time we actually get here. idle
     * may be past the lower bracket if we dawdled with the events, so
     * check for whether we did reset and bomb out of select immediately.
     */
    if (less && XSyncValueGreaterThan(idle, *less) &&
        LastEventTimeWasReset(priv->deviceid)) {
        AdjustWaitForDelay(wt, 0);
    } else if (less && XSyncValueLessOrEqual(idle, *less)) {
        /*
         * We've been idle for less than the threshold value, and someone
         * wants to know about that, but now we need to know whether they
         * want level or edge trigger.  Check the trigger list against the
         * current idle time, and if any succeed, bomb out of select()
         * immediately so we can reschedule.
         */

        for (list = counter->sync.pTriglist; list; list = list->next) {
            trig = list->pTrigger;
            if (trig->CheckTrigger(trig, old_idle)) {
                AdjustWaitForDelay(wt, 0);
                break;
            }
        }
        /*
         * We've been called exactly on the idle time, but we have a
         * NegativeTransition trigger which requires a transition from an
         * idle time greater than this.  Schedule a wakeup for the next
         * millisecond so we won't miss a transition.
         */
        if (XSyncValueEqual(idle, *less))
            AdjustWaitForDelay(wt, 1);
    }
    else if (greater) {
        /*
         * There's a threshold in the positive direction.  If we've been
         * idle less than it, schedule a wakeup for sometime in the future.
         * If we've been idle more than it, and someone wants to know about
         * that level-triggered, schedule an immediate wakeup.
         */

        if (XSyncValueLessThan(idle, *greater)) {
            XSyncValue value;
            Bool overflow;

            XSyncValueSubtract(&value, *greater, idle, &overflow);
            AdjustWaitForDelay(wt, XSyncValueLow32(value));
        }
        else {
            for (list = counter->sync.pTriglist; list;
                 list = list->next) {
                trig = list->pTrigger;
                if (trig->CheckTrigger(trig, old_idle)) {
                    AdjustWaitForDelay(wt, 0);
                    break;
                }
            }
        }
    }

    counter->value = old_idle;  /* pop */
}

static void
IdleTimeCheckBrackets(SyncCounter *counter, XSyncValue idle, XSyncValue *less, XSyncValue *greater)
{
    if ((greater && XSyncValueGreaterOrEqual(idle, *greater)) ||
        (less && XSyncValueLessOrEqual(idle, *less))) {
        SyncChangeCounter(counter, idle);
    }
    else
        SyncUpdateCounter(counter, idle);
}

static void
IdleTimeWakeupHandler(void *pCounter, int rc, void *LastSelectMask)
{
    SyncCounter *counter = pCounter;
    IdleCounterPriv *priv = SysCounterGetPrivate(counter);
    XSyncValue *less = priv->value_less,
               *greater = priv->value_greater;
    XSyncValue idle;

    if (!less && !greater)
        return;

    IdleTimeQueryValue(pCounter, &idle);

    /*
      There is no guarantee for the WakeupHandler to be called within a specific
      timeframe. Idletime may go to 0, but by the time we get here, it may be
      non-zero and alarms for a pos. transition on 0 won't get triggered.
      https://bugs.freedesktop.org/show_bug.cgi?id=70476
      */
    if (LastEventTimeWasReset(priv->deviceid)) {
        LastEventTimeToggleResetFlag(priv->deviceid, FALSE);
        if (!XSyncValueIsZero(idle)) {
            XSyncValue zero;
            XSyncIntsToValue(&zero, 0, 0);
            IdleTimeCheckBrackets(counter, zero, less, greater);
            less = priv->value_less;
            greater = priv->value_greater;
        }
    }

    IdleTimeCheckBrackets(counter, idle, less, greater);
}

static void
IdleTimeBracketValues(void *pCounter, CARD64 * pbracket_less,
                      CARD64 * pbracket_greater)
{
    SyncCounter *counter = pCounter;
    IdleCounterPriv *priv = SysCounterGetPrivate(counter);
    XSyncValue *less = priv->value_less,
               *greater = priv->value_greater;
    Bool registered = (less || greater);

    if (registered && !pbracket_less && !pbracket_greater) {
        RemoveBlockAndWakeupHandlers(IdleTimeBlockHandler,
                                     IdleTimeWakeupHandler, pCounter);
    }
    else if (!registered && (pbracket_less || pbracket_greater)) {
        /* Reset flag must be zero so we don't force a idle timer reset on
           the first wakeup */
        LastEventTimeToggleResetAll(FALSE);
        RegisterBlockAndWakeupHandlers(IdleTimeBlockHandler,
                                       IdleTimeWakeupHandler, pCounter);
    }

    priv->value_greater = pbracket_greater;
    priv->value_less = pbracket_less;
}

static SyncCounter*
init_system_idle_counter(const char *name, int deviceid)
{
    CARD64 resolution;
    XSyncValue idle;
    SyncCounter *idle_time_counter;

    IdleTimeQueryValue(NULL, &idle);
    XSyncIntToValue(&resolution, 4);

    idle_time_counter = SyncCreateSystemCounter(name, idle, resolution,
                                                XSyncCounterUnrestricted,
                                                IdleTimeQueryValue,
                                                IdleTimeBracketValues);

    if (idle_time_counter != NULL) {
        IdleCounterPriv *priv = malloc(sizeof(IdleCounterPriv));

        priv->value_less = priv->value_greater = NULL;
        priv->deviceid = deviceid;

        idle_time_counter->pSysCounterInfo->private = priv;
    }

    return idle_time_counter;
}

static void
SyncInitIdleTime(void)
{
    init_system_idle_counter("IDLETIME", XIAllDevices);
}

SyncCounter*
SyncInitDeviceIdleTime(DeviceIntPtr dev)
{
    char timer_name[64];
    sprintf(timer_name, "DEVICEIDLETIME %d", dev->id);

    return init_system_idle_counter(timer_name, dev->id);
}

void SyncRemoveDeviceIdleTime(SyncCounter *counter)
{
    /* FreeAllResources() frees all system counters before the devices are
       shut down, check if there are any left before freeing the device's
       counter */
    if (counter && !xorg_list_is_empty(&SysCounterList))
        xorg_list_del(&counter->pSysCounterInfo->entry);
}
@


1.16
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d623 1
a623 1
    ppAwait = malloc(numwaits * sizeof(SyncAwait *));
d1517 1
a1517 1
    pAwaitUnion = malloc((items + 1) * sizeof(SyncAwaitUnion));
@


1.15
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d2718 1
a2718 1
        /* 
@


1.14
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d327 1
a327 1
        else if (Success != (rc = dixLookupResourceByType((pointer *) &pSync,
d347 1
a347 1
            (*pCounter->pSysCounterInfo->QueryValue) ((pointer) pCounter,
d936 1
a936 1
    if (!AddResource(id, RTFence, (pointer) pFence))
d966 1
a966 1
    if (!AddResource(id, RTCounter, (pointer) pCounter))
d1026 1
a1026 1
SyncDestroySystemCounter(pointer pSysCounter)
d1124 1
a1124 1
    (*psci->BracketValues) ((pointer) pCounter, pnewltval, pnewgtval);
d1434 1
a1434 1
    rc = dixLookupResourceByType((pointer *) &pCounter, stuff->cid, RTCounter,
d1463 1
a1463 1
    rc = dixLookupResourceByType((pointer *) &pCounter, stuff->cid, RTCounter,
d1496 1
a1496 1
    rc = dixLookupResourceByType((pointer *) &pCounter, stuff->counter,
d1657 1
a1657 1
    rc = dixLookupResourceByType((pointer *) &pCounter, stuff->counter,
d1664 1
a1664 1
        (*pCounter->pSysCounterInfo->QueryValue) ((pointer) pCounter,
d1783 1
a1783 1
    status = dixLookupResourceByType((pointer *) &pAlarm, stuff->alarm, RTAlarm,
d1824 1
a1824 1
    rc = dixLookupResourceByType((pointer *) &pAlarm, stuff->alarm, RTAlarm,
d1882 1
a1882 1
    rc = dixLookupResourceByType((pointer *) &pAlarm, stuff->alarm, RTAlarm,
d1912 1
a1912 1
    if (!AddResource(stuff->fid, RTFence, (pointer) pFence))
d1931 1
a1931 1
    int rc = dixLookupResourceByType((pointer *) ppSyncFence, fid, RTFence,
d1949 1
a1949 1
    rc = dixLookupResourceByType((pointer *) &pFence, stuff->fid, RTFence,
d1968 1
a1968 1
    rc = dixLookupResourceByType((pointer *) &pFence, stuff->fid, RTFence,
d1990 1
a1990 1
    rc = dixLookupResourceByType((pointer *) &pFence, stuff->fid, RTFence,
d2009 1
a2009 1
    rc = dixLookupResourceByType((pointer *) &pFence, stuff->fid,
d2558 1
a2558 1
static pointer ServertimeCounter;
d2659 1
a2659 1
IdleTimeQueryValue(pointer pCounter, CARD64 * pValue_return)
d2676 1
a2676 1
IdleTimeBlockHandler(pointer pCounter, struct timeval **wt, pointer LastSelectMask)
d2769 1
a2769 1
IdleTimeWakeupHandler(pointer pCounter, int rc, pointer LastSelectMask)
d2803 1
a2803 1
IdleTimeBracketValues(pointer pCounter, CARD64 * pbracket_less,
@


1.13
log
@Update to xserver 1.14.5
@
text
@d144 1
a144 1
static void
d187 1
a187 1
static int
d919 36
a2832 1
    IdleCounterPriv *priv = malloc(sizeof(IdleCounterPriv));
d2843 5
a2847 2
    priv->deviceid = deviceid;
    priv->value_less = priv->value_greater = NULL;
d2849 2
a2850 1
    idle_time_counter->pSysCounterInfo->private = priv;
d2875 1
a2875 1
    if (!xorg_list_is_empty(&SysCounterList))
@


1.12
log
@Avoid timeouts of ULONG_MAX milliseconds.  Stops the X server from crashing
with "select returned EINVAL" messages.

ok matthieu@@
@
text
@d2657 10
a2666 1
    if (less && XSyncValueLessOrEqual(idle, *less)) {
@


1.11
log
@Update to xserver 1.14.4
@
text
@a2688 1
        unsigned long timeout = -1;
d2695 1
a2695 1
            timeout = min(timeout, XSyncValueLow32(value));
d2702 1
a2702 1
                    timeout = min(timeout, 0);
a2706 2

        AdjustWaitForDelay(wt, timeout);
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d702 8
d719 1
a719 2
    oldval = pCounter->value;
    pCounter->value = newval;
d1029 5
d1043 5
d1051 9
a1059 5
            if (XSyncValueGreaterThan(pCounter->value, pTrigger->test_value) &&
                XSyncValueGreaterThan(pTrigger->test_value, psci->bracket_less))
            {
                psci->bracket_less = pTrigger->test_value;
                pnewltval = &psci->bracket_less;
d1061 4
a1064 10
            else if (XSyncValueEqual(pCounter->value, pTrigger->test_value) &&
                     XSyncValueGreaterThan(pTrigger->test_value,
                                           psci->bracket_less)) {
                /*
                 * The value is exactly equal to our threshold.  We want one
                 * more event in the negative direction to ensure we pick up
                 * when the value is less than this threshold.
                 */
                psci->bracket_less = pTrigger->test_value;
                pnewltval = &psci->bracket_less;
d1069 10
a1078 5
            if (XSyncValueLessThan(pCounter->value, pTrigger->test_value) &&
                XSyncValueLessThan(pTrigger->test_value, psci->bracket_greater))
            {
                psci->bracket_greater = pTrigger->test_value;
                pnewgtval = &psci->bracket_greater;
d1080 4
a1083 10
            else if (XSyncValueEqual(pCounter->value, pTrigger->test_value) &&
                     XSyncValueLessThan(pTrigger->test_value,
                                        psci->bracket_greater)) {
                /*
                 * The value is exactly equal to our threshold.  We want one
                 * more event in the positive direction to ensure we pick up
                 * when the value *exceeds* this threshold.
                 */
                psci->bracket_greater = pTrigger->test_value;
                pnewgtval = &psci->bracket_greater;
d1088 2
a1089 3
    if (pnewgtval || pnewltval) {
        (*psci->BracketValues) ((pointer) pCounter, pnewltval, pnewgtval);
    }
d2635 1
a2635 1
    idle = GetTimeInMillis() - lastDeviceEventTime[deviceid].milliseconds;
d2654 1
a2654 1
    IdleTimeQueryValue(NULL, &idle);
d2716 11
d2740 15
a2754 3
    if ((greater && XSyncValueGreaterOrEqual(idle, *greater)) ||
        (less && XSyncValueLessOrEqual(idle, *less))) {
        SyncChangeCounter(counter, idle);
d2756 2
d2775 3
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d72 1
d79 1
a79 1
#include "modinit.h"
d91 1
a91 2
static int SyncNumSystemCounters = 0;
static SyncCounter **SysCounterList = NULL;
d117 8
d440 10
a449 3
    ane.type = SyncEventBase + XSyncAlarmNotify;
    ane.kind = XSyncAlarmNotify;
    ane.alarm = pAlarm->alarm_id;
d454 2
a455 1
    else {                      /* XXX what else can we do if there's no counter? */
a458 5
    ane.alarm_value_hi = XSyncValueHigh32(pTrigger->test_value);
    ane.alarm_value_lo = XSyncValueLow32(pTrigger->test_value);
    ane.time = currentTime.milliseconds;
    ane.state = pAlarm->state;

d480 1
a480 1
    pev = pEvents = malloc(num_events * sizeof(xSyncCounterNotifyEvent));
d935 1
a935 1
pointer
d940 2
a941 5
                        void (*QueryValue) (pointer /* pCounter */ ,
                                            CARD64 * /* pValue_return */ ),
                        void (*BracketValues) (pointer /* pCounter */ ,
                                               CARD64 * /* pbracket_less */ ,
                                               CARD64 * /* pbracket_greater */ )
a945 6
    SysCounterList = realloc(SysCounterList,
                             (SyncNumSystemCounters +
                              1) * sizeof(SyncCounter *));
    if (!SysCounterList)
        return NULL;

d954 1
d968 2
a969 1
        psci->name = name;
d974 1
d977 1
a977 1
        SysCounterList[SyncNumSystemCounters++] = pCounter;
d1041 2
a1042 2
                     XSyncValueLessThan(pTrigger->test_value,
                                        psci->bracket_greater)) {
d1045 2
a1046 2
                 * more event in the positive direction to ensure we pick up
                 * when the value *exceeds* this threshold.
d1048 2
a1049 2
                psci->bracket_greater = pTrigger->test_value;
                pnewgtval = &psci->bracket_greater;
d1061 2
a1062 2
                     XSyncValueGreaterThan(pTrigger->test_value,
                                           psci->bracket_less)) {
d1065 2
a1066 2
                 * more event in the negative direction to ensure we pick up
                 * when the value is less than this threshold.
d1068 2
a1069 2
                psci->bracket_less = pTrigger->test_value;
                pnewltval = &psci->bracket_less;
d1122 3
a1124 2
        int i, found = 0;

a1125 17

        /* find the counter in the list of system counters and remove it */

        if (SysCounterList) {
            for (i = 0; i < SyncNumSystemCounters; i++) {
                if (SysCounterList[i] == pCounter) {
                    found = i;
                    break;
                }
            }
            if (found < (SyncNumSystemCounters - 1)) {
                for (i = found; i < SyncNumSystemCounters - 1; i++) {
                    SysCounterList[i] = SysCounterList[i + 1];
                }
            }
        }
        SyncNumSystemCounters--;
d1191 7
a1197 1
    xSyncInitializeReply rep;
a1200 7
    memset(&rep, 0, sizeof(xSyncInitializeReply));
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_SYNC_MAJOR_VERSION;
    rep.minorVersion = SERVER_SYNC_MINOR_VERSION;
    rep.length = 0;

d1204 1
a1204 1
    WriteToClient(client, sizeof(rep), (char *) &rep);
d1214 7
a1220 2
    xSyncListSystemCountersReply rep;
    int i, len;
d1225 1
a1225 7
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.nCounters = SyncNumSystemCounters;

    for (i = len = 0; i < SyncNumSystemCounters; i++) {
        const char *name = SysCounterList[i]->pSysCounterInfo->name;

d1227 2
a1228 1
        len += pad_to_int32(sz_xSyncSystemCounter + strlen(name));
d1245 1
a1245 1
    for (i = 0; i < SyncNumSystemCounters; i++) {
a1247 1
        SysCounterInfo *psci = SysCounterList[i]->pSysCounterInfo;
d1249 1
a1249 1
        walklist->counter = SysCounterList[i]->sync.id;
d1269 1
a1269 1
    WriteToClient(client, sizeof(rep), (char *) &rep);
d1271 1
a1271 1
        WriteToClient(client, len, (char *) list);
d1334 6
a1339 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.priority = priorityclient->priority;
d1346 1
a1346 1
    WriteToClient(client, sizeof(xSyncGetPriorityReply), (char *) &rep);
a1612 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;

a1613 1

d1619 8
a1626 2
    rep.value_hi = XSyncValueHigh32(pCounter->value);
    rep.value_lo = XSyncValueLow32(pCounter->value);
d1633 1
a1633 1
    WriteToClient(client, sizeof(xSyncQueryCounterReply), (char *) &rep);
a1779 5
    rep.type = X_Reply;
    rep.length =
        bytes_to_int32(sizeof(xSyncQueryAlarmReply) - sizeof(xGenericReply));
    rep.sequenceNumber = client->sequence;

d1781 14
a1794 9
    rep.counter = (pTrigger->pSync) ? pTrigger->pSync->id : None;

#if 0                           /* XXX unclear what to do, depends on whether relative value-types
                                 * are "consumed" immediately and are considered absolute from then
                                 * on.
                                 */
    rep.value_type = pTrigger->value_type;
    rep.wait_value_hi = XSyncValueHigh32(pTrigger->wait_value);
    rep.wait_value_lo = XSyncValueLow32(pTrigger->wait_value);
d1796 3
a1798 3
    rep.value_type = XSyncAbsolute;
    rep.wait_value_hi = XSyncValueHigh32(pTrigger->test_value);
    rep.wait_value_lo = XSyncValueLow32(pTrigger->test_value);
d1801 6
a1806 5
    rep.test_type = pTrigger->test_type;
    rep.delta_hi = XSyncValueHigh32(pAlarm->delta);
    rep.delta_lo = XSyncValueLow32(pAlarm->delta);
    rep.events = pAlarm->events;
    rep.state = pAlarm->state;
d1819 1
a1819 1
    WriteToClient(client, sizeof(xSyncQueryAlarmReply), (char *) &rep);
d1965 4
a1968 3
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
d1970 2
a1971 1
    rep.triggered = pFence->funcs.CheckTriggered(pFence);
d1978 1
a1978 1
    WriteToClient(client, sizeof(xSyncQueryFenceReply), (char *) &rep);
a2439 2
    free(SysCounterList);
    SysCounterList = NULL;
d2457 1
d2603 5
a2607 3
static SyncCounter *IdleTimeCounter;
static XSyncValue *pIdleTimeValueLess;
static XSyncValue *pIdleTimeValueGreater;
d2612 2
a2613 1
    CARD32 idle = GetTimeInMillis() - lastDeviceEventTime.milliseconds;
d2615 8
d2627 1
a2627 1
IdleTimeBlockHandler(pointer env, struct timeval **wt, pointer LastSelectMask)
d2629 4
d2634 1
a2634 1
    SyncTriggerList *list = IdleTimeCounter->sync.pTriglist;
d2637 1
a2637 1
    if (!pIdleTimeValueLess && !pIdleTimeValueGreater)
d2640 1
a2640 1
    old_idle = IdleTimeCounter->value;
d2642 1
a2642 1
    IdleTimeCounter->value = idle;      /* push, so CheckTrigger works */
d2644 1
a2644 1
    if (pIdleTimeValueLess && XSyncValueLessOrEqual(idle, *pIdleTimeValueLess)) {
d2653 1
a2653 1
        for (list = IdleTimeCounter->sync.pTriglist; list; list = list->next) {
d2666 1
a2666 1
        if (XSyncValueEqual(idle, *pIdleTimeValueLess))
d2669 1
a2669 1
    else if (pIdleTimeValueGreater) {
d2678 1
a2678 1
        if (XSyncValueLessThan(idle, *pIdleTimeValueGreater)) {
d2682 1
a2682 1
            XSyncValueSubtract(&value, *pIdleTimeValueGreater, idle, &overflow);
d2686 1
a2686 1
            for (list = IdleTimeCounter->sync.pTriglist; list;
d2699 1
a2699 1
    IdleTimeCounter->value = old_idle;  /* pop */
d2703 1
a2703 1
IdleTimeWakeupHandler(pointer env, int rc, pointer LastSelectMask)
d2705 4
d2711 1
a2711 1
    if (!pIdleTimeValueLess && !pIdleTimeValueGreater)
d2714 1
a2714 1
    IdleTimeQueryValue(NULL, &idle);
d2716 3
a2718 5
    if ((pIdleTimeValueGreater &&
         XSyncValueGreaterOrEqual(idle, *pIdleTimeValueGreater)) ||
        (pIdleTimeValueLess &&
         XSyncValueLessOrEqual(idle, *pIdleTimeValueLess))) {
        SyncChangeCounter(IdleTimeCounter, idle);
d2726 5
a2730 1
    Bool registered = (pIdleTimeValueLess || pIdleTimeValueGreater);
d2734 1
a2734 1
                                     IdleTimeWakeupHandler, NULL);
d2738 1
a2738 1
                                       IdleTimeWakeupHandler, NULL);
d2741 2
a2742 2
    pIdleTimeValueGreater = pbracket_greater;
    pIdleTimeValueLess = pbracket_less;
d2745 2
a2746 2
static void
SyncInitIdleTime(void)
d2750 2
d2756 9
a2764 4
    IdleTimeCounter = SyncCreateSystemCounter("IDLETIME", idle, resolution,
                                              XSyncCounterUnrestricted,
                                              IdleTimeQueryValue,
                                              IdleTimeBracketValues);
d2766 25
a2790 1
    pIdleTimeValueLess = pIdleTimeValueGreater = NULL;
@


1.8
log
@Update to xserver 1.11.2
@
text
@a26 1

d83 7
a89 7
static int      SyncEventBase;
static int      SyncErrorBase;
static RESTYPE  RTCounter = 0;
static RESTYPE  RTAwait;
static RESTYPE  RTAlarm;
static RESTYPE  RTAlarmClient;
static RESTYPE  RTFence;
d93 1
d97 2
a98 2
"Warning: Non-counter XSync object using Counter-only\n"
"         comparison.  Result will never be true.\n";
d101 2
a102 2
"Warning: Non-counter XSync object used in alarm.  This is\n"
"         the result of a programming error in the X server.\n";
d118 1
a118 1
SyncCheckWarnIsCounter(const SyncObject* pSync, const char *warning)
d120 5
a124 7
    if (pSync && (SYNC_COUNTER != pSync->type))
    {
	if (SyncNumInvalidCounterWarnings++ < MAX_INVALID_COUNTER_WARNINGS)
	{
	    ErrorF("%s", warning);
	    ErrorF("         Counter type: %d\n", pSync->type);
	}
d126 1
a126 1
	return FALSE;
d137 1
a137 1
SyncDeleteTriggerFromSyncObject(SyncTrigger *pTrigger)
d146 1
a146 1
	return;
d151 6
a156 8
    while (pCur)
    {
	if (pCur->pTrigger == pTrigger)
	{
	    if (pPrev)
		pPrev->next = pCur->next;
	    else
		pTrigger->pSync->pTriglist = pCur->next;
d158 6
a163 6
	    free(pCur);
	    break;
	}
	
	pPrev = pCur;
	pCur = pCur->next;
d166 2
a167 3
    if (SYNC_COUNTER == pTrigger->pSync->type)
    {
	pCounter = (SyncCounter *)pTrigger->pSync;
d169 7
a175 5
	if (IsSystemCounter(pCounter))
	    SyncComputeBracketValues(pCounter);
    } else if (SYNC_FENCE == pTrigger->pSync->type) {
	SyncFence* pFence = (SyncFence*) pTrigger->pSync;
	pFence->funcs.DeleteTrigger(pTrigger);
a178 1

d180 1
a180 1
SyncAddTriggerToSyncObject(SyncTrigger *pTrigger)
d186 1
a186 1
	return Success;
d189 3
a191 4
    for (pCur = pTrigger->pSync->pTriglist; pCur; pCur = pCur->next)
    {
	if (pCur->pTrigger == pTrigger)
	    return Success;
d195 1
a195 1
	return BadAlloc;
d201 10
a210 9
    if (SYNC_COUNTER == pTrigger->pSync->type)
    {
	pCounter = (SyncCounter *)pTrigger->pSync;

	if (IsSystemCounter(pCounter))
	    SyncComputeBracketValues(pCounter);
    } else if (SYNC_FENCE == pTrigger->pSync->type) {
	SyncFence* pFence = (SyncFence*) pTrigger->pSync;
	pFence->funcs.AddTrigger(pTrigger);
a215 1

d232 1
a232 1
SyncCheckTriggerPositiveComparison(SyncTrigger *pTrigger, CARD64 oldval)
d239 1
a239 1
	return FALSE;
d241 1
a241 1
    pCounter = (SyncCounter *)pTrigger->pSync;
d244 1
a244 1
	    XSyncValueGreaterOrEqual(pCounter->value, pTrigger->test_value));
d248 1
a248 1
SyncCheckTriggerNegativeComparison(SyncTrigger *pTrigger,  CARD64 oldval)
d255 1
a255 1
	return FALSE;
d257 1
a257 1
    pCounter = (SyncCounter *)pTrigger->pSync;
d260 1
a260 1
	    XSyncValueLessOrEqual(pCounter->value, pTrigger->test_value));
d264 1
a264 1
SyncCheckTriggerPositiveTransition(SyncTrigger *pTrigger, CARD64 oldval)
d271 1
a271 1
	return FALSE;
d273 1
a273 1
    pCounter = (SyncCounter *)pTrigger->pSync;
d276 2
a277 2
	    (XSyncValueLessThan(oldval, pTrigger->test_value) &&
	     XSyncValueGreaterOrEqual(pCounter->value, pTrigger->test_value)));
d281 1
a281 1
SyncCheckTriggerNegativeTransition(SyncTrigger *pTrigger, CARD64 oldval)
d288 1
a288 1
	return FALSE;
d290 1
a290 1
    pCounter = (SyncCounter *)pTrigger->pSync;
d293 2
a294 2
	    (XSyncValueGreaterThan(oldval, pTrigger->test_value) &&
	     XSyncValueLessOrEqual(pCounter->value, pTrigger->test_value)));
d298 1
a298 1
SyncCheckTriggerFence(SyncTrigger *pTrigger, CARD64 unused)
d300 3
a302 2
    SyncFence* pFence = (SyncFence*) pTrigger->pSync;
    (void)unused;
d304 1
a304 2
    return (pFence == NULL ||
	    pFence->funcs.CheckTriggered(pFence));
d308 2
a309 2
SyncInitTrigger(ClientPtr client, SyncTrigger *pTrigger, XID syncObject,
		RESTYPE resType, Mask changes)
d313 2
a314 2
    int		rc;
    Bool	newSyncObject = FALSE;
d316 15
a330 16
    if (changes & XSyncCACounter)
    {
	if (syncObject == None)
	    pSync = NULL;
	else if (Success != (rc = dixLookupResourceByType ((pointer *)&pSync,
				syncObject, resType, client, DixReadAccess)))
	{
	    client->errorValue = syncObject;
	    return rc;
	}
	if (pSync != pTrigger->pSync)
	{ /* new counter for trigger */
	    SyncDeleteTriggerFromSyncObject(pTrigger);
	    pTrigger->pSync = pSync;
	    newSyncObject = TRUE;
	}
d335 62
a396 71
    if (pSync && SYNC_COUNTER == pSync->type)
    {
	pCounter = (SyncCounter *)pSync;

	if (IsSystemCounter(pCounter))
	{
	    (*pCounter->pSysCounterInfo->QueryValue) ((pointer) pCounter,
						      &pCounter->value);
	}
    }

    if (changes & XSyncCAValueType)
    {
	if (pTrigger->value_type != XSyncRelative &&
	    pTrigger->value_type != XSyncAbsolute)
	{
	    client->errorValue = pTrigger->value_type;
	    return BadValue;
	}
    }

    if (changes & XSyncCATestType)
    {

	if (pSync && SYNC_FENCE == pSync->type)
	{
	    pTrigger->CheckTrigger = SyncCheckTriggerFence;
	}
	else
	{
	    /* select appropriate CheckTrigger function */

	    switch (pTrigger->test_type)
	    {
	    case XSyncPositiveTransition:
		pTrigger->CheckTrigger = SyncCheckTriggerPositiveTransition;
		break;
	    case XSyncNegativeTransition:
		pTrigger->CheckTrigger = SyncCheckTriggerNegativeTransition;
		break;
	    case XSyncPositiveComparison:
		pTrigger->CheckTrigger = SyncCheckTriggerPositiveComparison;
		break;
	    case XSyncNegativeComparison:
		pTrigger->CheckTrigger = SyncCheckTriggerNegativeComparison;
		break;
	    default:
		client->errorValue = pTrigger->test_type;
		return BadValue;
	    }
	}
    }

    if (changes & (XSyncCAValueType | XSyncCAValue))
    {
	if (pTrigger->value_type == XSyncAbsolute)
	    pTrigger->test_value = pTrigger->wait_value;
	else /* relative */
	{
	    Bool overflow;
	    if (pCounter == NULL)
		return BadMatch;

	    XSyncValueAdd(&pTrigger->test_value, pCounter->value,
			  pTrigger->wait_value, &overflow);
	    if (overflow)
	    {
		client->errorValue = XSyncValueHigh32(pTrigger->wait_value);
		return BadValue;
	    }
	}
d402 6
a407 8
    if (newSyncObject)
    {
	if ((rc = SyncAddTriggerToSyncObject(pTrigger)) != Success)
	    return rc;
    }
    else if (pCounter && IsSystemCounter(pCounter))
    {
	SyncComputeBracketValues(pCounter);
d418 1
a418 1
SyncSendAlarmNotifyEvents(SyncAlarm *pAlarm)
d426 1
a426 1
	return;
d428 1
a428 1
    pCounter = (SyncCounter *)pTrigger->pSync;
d435 6
a440 8
    if (pTrigger->pSync && SYNC_COUNTER == pTrigger->pSync->type)
    {
	ane.counter_value_hi = XSyncValueHigh32(pCounter->value);
	ane.counter_value_lo = XSyncValueLow32(pCounter->value);
    }
    else
    { /* XXX what else can we do if there's no counter? */
	ane.counter_value_hi = ane.counter_value_lo = 0;
d450 1
a450 1
	WriteEventsToClient(pAlarm->client, 1, (xEvent *) &ane);
d454 1
a454 1
	WriteEventsToClient(pcl->client, 1, (xEvent *) &ane);
a456 1

d461 2
a462 2
SyncSendCounterNotifyEvents(ClientPtr client, SyncAwait **ppAwait,
			    int num_events)
d468 1
a468 1
	return;
d471 1
a471 1
	return;
d473 22
a494 24
    for (i = 0; i < num_events; i++, ppAwait++, pev++)
    {
	SyncTrigger *pTrigger = &(*ppAwait)->trigger;
	pev->type = SyncEventBase + XSyncCounterNotify;
	pev->kind = XSyncCounterNotify;
	pev->counter = pTrigger->pSync->id;
	pev->wait_value_lo = XSyncValueLow32(pTrigger->test_value);
	pev->wait_value_hi = XSyncValueHigh32(pTrigger->test_value);
	if (SYNC_COUNTER == pTrigger->pSync->type)
	{
	    SyncCounter *pCounter = (SyncCounter *)pTrigger->pSync;

	    pev->counter_value_lo = XSyncValueLow32(pCounter->value);
	    pev->counter_value_hi = XSyncValueHigh32(pCounter->value);
	}
	else
	{
	    pev->counter_value_lo = 0;
	    pev->counter_value_hi = 0;
	}

	pev->time = currentTime.milliseconds;
	pev->count = num_events - i - 1; /* events remaining */
	pev->destroyed = pTrigger->pSync->beingDestroyed;
d497 1
a497 1
    WriteEventsToClient(client, num_events, (xEvent *)pEvents);
a500 1

d505 1
a505 1
SyncAlarmCounterDestroyed(SyncTrigger *pTrigger)
d507 1
a507 1
    SyncAlarm *pAlarm = (SyncAlarm *)pTrigger;
a513 1

d518 1
a518 1
SyncAlarmTriggerFired(SyncTrigger *pTrigger)
d520 1
a520 1
    SyncAlarm *pAlarm = (SyncAlarm *)pTrigger;
d525 1
a525 1
	return;
d527 1
a527 1
    pCounter = (SyncCounter *)pTrigger->pSync;
d531 1
a531 1
	return;
d538 6
a543 5
    if (pCounter == NULL
	|| (XSyncValueIsZero(pAlarm->delta)
	    && (pAlarm->trigger.test_type == XSyncPositiveComparison
		|| pAlarm->trigger.test_type == XSyncNegativeComparison)))
	pAlarm->state = XSyncAlarmInactive;
d547 38
a584 42
    if (pAlarm->state == XSyncAlarmActive)
    {
	Bool overflow;
	CARD64 oldvalue;
	SyncTrigger *paTrigger = &pAlarm->trigger;
	SyncCounter *paCounter;

	if (!SyncCheckWarnIsCounter(paTrigger->pSync,
				    WARN_INVALID_COUNTER_ALARM))
	    return;

	paCounter = (SyncCounter *)pTrigger->pSync;

	/* "The alarm is updated by repeatedly adding delta to the
	 *  value of the trigger and re-initializing it until it
	 *  becomes FALSE."
	 */
	oldvalue = paTrigger->test_value;

	/* XXX really should do something smarter here */

	do
	{
	    XSyncValueAdd(&paTrigger->test_value, paTrigger->test_value,
			  pAlarm->delta, &overflow);
	} while (!overflow &&
	      (*paTrigger->CheckTrigger)(paTrigger,
					paCounter->value));

	new_test_value = paTrigger->test_value;
	paTrigger->test_value = oldvalue;

	/* "If this update would cause value to fall outside the range
	 *  for an INT64...no change is made to value (test-value) and
	 *  the alarm state is changed to Inactive before the event is
	 *  generated."
	 */
	if (overflow)
	{
	    new_test_value = oldvalue;
	    pAlarm->state = XSyncAlarmInactive;
	}
a595 1

d602 1
a602 1
SyncAwaitTriggerFired(SyncTrigger *pTrigger)
d604 1
a604 1
    SyncAwait *pAwait = (SyncAwait *)pTrigger;
d610 1
a610 1
    pAwaitUnion = (SyncAwaitUnion *)pAwait->pHeader;
d614 1
a614 1
	goto bail;
d616 1
a616 1
    pAwait = &(pAwaitUnion+1)->await;
d627 51
a677 55
    for ( ; numwaits; numwaits--, pAwait++)
    {
	CARD64 diff;
	Bool overflow, diffgreater, diffequal;

	/* "A CounterNotify event with the destroyed flag set to TRUE is
	 *  always generated if the counter for one of the triggers is
	 *  destroyed."
	 */
	if (pAwait->trigger.pSync->beingDestroyed)
	{
	    ppAwait[num_events++] = pAwait;
	    continue;
	}
	
	if (SYNC_COUNTER == pAwait->trigger.pSync->type)
	{
	    SyncCounter *pCounter = (SyncCounter *) pAwait->trigger.pSync;

	    /* "The difference between the counter and the test value is
	     *  calculated by subtracting the test value from the value of
	     *  the counter."
	     */
	    XSyncValueSubtract(&diff, pCounter->value,
			       pAwait->trigger.test_value, &overflow);

	    /* "If the difference lies outside the range for an INT64, an
	     *  event is not generated."
	     */
	    if (overflow)
		continue;
	    diffgreater = XSyncValueGreaterThan(diff, pAwait->event_threshold);
	    diffequal   = XSyncValueEqual(diff, pAwait->event_threshold);

	    /* "If the test-type is PositiveTransition or
	     *  PositiveComparison, a CounterNotify event is generated if
	     *  the difference is at least event-threshold. If the test-type
	     *  is NegativeTransition or NegativeComparison, a CounterNotify
	     *  event is generated if the difference is at most
	     *  event-threshold."
	     */

	    if ( ((pAwait->trigger.test_type == XSyncPositiveComparison ||
		   pAwait->trigger.test_type == XSyncPositiveTransition)
		  && (diffgreater || diffequal))
		 ||
		 ((pAwait->trigger.test_type == XSyncNegativeComparison ||
		   pAwait->trigger.test_type == XSyncNegativeTransition)
		  && (!diffgreater) /* less or equal */
		 )
	       )
	    {
		ppAwait[num_events++] = pAwait;
	    }
	}
d680 2
a681 2
	SyncSendCounterNotifyEvents(pAwaitUnion->header.client, ppAwait,
				    num_events);
d684 1
a684 1
bail:
a690 1

d695 1
a695 1
SyncChangeCounter(SyncCounter *pCounter, CARD64 newval)
d697 1
a697 1
    SyncTriggerList       *ptl, *pnext;
d704 4
a707 5
    for (ptl = pCounter->sync.pTriglist; ptl; ptl = pnext)
    {
	pnext = ptl->next;
	if ((*ptl->pTrigger->CheckTrigger)(ptl->pTrigger, oldval))
	    (*ptl->pTrigger->TriggerFired)(ptl->pTrigger);
d710 2
a711 3
    if (IsSystemCounter(pCounter))
    {
	SyncComputeBracketValues(pCounter);
a714 1

d717 1
a717 1
SyncEventSelectForAlarm(SyncAlarm *pAlarm, ClientPtr client, Bool wantevents)
d721 3
a723 4
    if (client == pAlarm->client) /* alarm owner */
    {
	pAlarm->events = wantevents;
	return Success;
d728 12
a739 16
    for (pClients = pAlarm->pEventClients; pClients;
	 pClients = pClients->next)
    {
	if (pClients->client == client)
	{
	    /* client's presence on the list indicates desire for
	     * events.  If the client doesn't want events, remove it
	     * from the list.  If the client does want events, do
	     * nothing, since it's already got them.
	     */
	    if (!wantevents)
	    {
		FreeResource(pClients->delete_id, RT_NONE);
	    }
	    return Success;
	}
d747 4
a750 4
	/* client doesn't want events, and we just discovered that it
	 * doesn't have them, so there's nothing to do.
	 */
	return Success;
d756 1
a756 1
	return BadAlloc;
d770 1
a770 1
	return BadAlloc;
d779 2
a780 2
SyncChangeAlarmAttributes(ClientPtr client, SyncAlarm *pAlarm, Mask mask,
			  CARD32 *values)
d782 57
a838 60
    int		   status;
    XSyncCounter   counter;
    Mask	   origmask = mask;

    counter =
	pAlarm->trigger.pSync ? pAlarm->trigger.pSync->id : None;

    while (mask)
    {
	int    index2 = lowbit(mask);
	mask &= ~index2;
	switch (index2)
	{
	  case XSyncCACounter:
	    mask &= ~XSyncCACounter;
	    /* sanity check in SyncInitTrigger */
	    counter = *values++;
	    break;

	  case XSyncCAValueType:
	    mask &= ~XSyncCAValueType;
	    /* sanity check in SyncInitTrigger */
	    pAlarm->trigger.value_type = *values++;
	    break;

	  case XSyncCAValue:
	    mask &= ~XSyncCAValue;
	    XSyncIntsToValue(&pAlarm->trigger.wait_value, values[1], values[0]);
	    values += 2;
	    break;

	  case XSyncCATestType:
	    mask &= ~XSyncCATestType;
	    /* sanity check in SyncInitTrigger */
	    pAlarm->trigger.test_type = *values++;
	    break;

	  case XSyncCADelta:
	    mask &= ~XSyncCADelta;
	    XSyncIntsToValue(&pAlarm->delta, values[1], values[0]);
	    values += 2;
	    break;

	  case XSyncCAEvents:
	    mask &= ~XSyncCAEvents;
	    if ((*values != xTrue) && (*values != xFalse))
	    {
		client->errorValue = *values;
		return BadValue;
	    }
	    status = SyncEventSelectForAlarm(pAlarm, client,
					     (Bool)(*values++));
	    if (status != Success)
		return status;
	    break;

	  default:
	    client->errorValue = mask;
	    return BadValue;
	}
d846 14
a859 15
    if (origmask & (XSyncCADelta|XSyncCATestType))
    {
	CARD64 zero;
	XSyncIntToValue(&zero, 0);
	if ((((pAlarm->trigger.test_type == XSyncPositiveComparison) ||
	      (pAlarm->trigger.test_type == XSyncPositiveTransition))
	     && XSyncValueLessThan(pAlarm->delta, zero))
	    ||
	    (((pAlarm->trigger.test_type == XSyncNegativeComparison) ||
	      (pAlarm->trigger.test_type == XSyncNegativeTransition))
	     && XSyncValueGreaterThan(pAlarm->delta, zero))
	   )
	{
	    return BadMatch;
	}
d864 2
a865 2
			     origmask & XSyncCAAllTrigger)) != Success)
	return status;
d879 2
a880 2
	pSync = malloc(sizeof(SyncCounter));
	break;
d882 3
a884 3
	pSync = (SyncObject*)dixAllocateObjectWithPrivates(SyncFence,
							   PRIVATE_SYNC_FENCE);
	break;
d886 1
a886 1
	return NULL;
d890 1
a890 1
	return NULL;
a900 1

d906 2
a907 4
    if (!(pCounter = (SyncCounter *)SyncCreate(client,
					       id,
					       SYNC_COUNTER)))
	return NULL;
d913 1
a913 1
	return NULL;
d925 10
a934 11
SyncCreateSystemCounter(
	char *name,
	CARD64 initial,
	CARD64 resolution,
	SyncCounterType counterType,
	void (*QueryValue)(pointer /* pCounter */,
	      	           CARD64 * /* pValue_return */),
	void (*BracketValues)(pointer /* pCounter */,
	       	              CARD64 * /* pbracket_less */,
	                      CARD64 * /* pbracket_greater */)
	)
d936 1
a936 1
    SyncCounter    *pCounter;
d939 2
a940 1
			    (SyncNumSystemCounters+1)*sizeof(SyncCounter *));
d942 1
a942 1
	return NULL;
d947 5
a951 7
    if (RTCounter == 0)
    {
	RTCounter = CreateNewResourceType(FreeCounter, "SyncCounter");
	if (RTCounter == 0)
	{
	    return NULL;
	}
d956 17
a972 19
    if (pCounter)
    {
	SysCounterInfo *psci;

	psci = malloc(sizeof(SysCounterInfo));
	if (!psci)
	{
	    FreeResource(pCounter->sync.id, RT_NONE);
	    return pCounter;
	}
	pCounter->pSysCounterInfo = psci;
	psci->name = name;
	psci->resolution = resolution;
	psci->counterType = counterType;
	psci->QueryValue = QueryValue;
	psci->BracketValues = BracketValues;
	XSyncMaxValue(&psci->bracket_greater);
	XSyncMinValue(&psci->bracket_less);
	SysCounterList[SyncNumSystemCounters++] = pCounter;
d980 2
a981 1
    SyncCounter *pCounter = (SyncCounter *)pSysCounter;
d986 1
a986 1
SyncComputeBracketValues(SyncCounter *pCounter)
d996 1
a996 1
	return;
d1001 1
a1001 1
	return;
d1006 3
a1008 4
    for (pCur = pCounter->sync.pTriglist; pCur; pCur = pCur->next)
    {
	pTrigger = pCur->pTrigger;
	
d1010 37
a1046 42
	    ct != XSyncCounterNeverIncreases)
	{
	    if (XSyncValueLessThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueLessThan(pTrigger->test_value,
				   psci->bracket_greater))
	    {
		psci->bracket_greater = pTrigger->test_value;
		pnewgtval = &psci->bracket_greater;
	    }
	}
	else if (pTrigger->test_type == XSyncNegativeComparison &&
		 ct != XSyncCounterNeverDecreases)
	{
	    if (XSyncValueGreaterThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueGreaterThan(pTrigger->test_value,
				      psci->bracket_less))
	    {
		psci->bracket_less = pTrigger->test_value;
		pnewltval = &psci->bracket_less;
	    }
	}
	else if (pTrigger->test_type == XSyncNegativeTransition &&
		   ct != XSyncCounterNeverIncreases)
	{
	    if (XSyncValueGreaterThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueGreaterThan(pTrigger->test_value, psci->bracket_less))
	    {
		psci->bracket_less = pTrigger->test_value;
		pnewltval = &psci->bracket_less;
	    } else if (XSyncValueEqual(pCounter->value, pTrigger->test_value) &&
		       XSyncValueLessThan(pTrigger->test_value,
					  psci->bracket_greater))
	    {
	        /*
		 * The value is exactly equal to our threshold.  We want one
		 * more event in the positive direction to ensure we pick up
		 * when the value *exceeds* this threshold.
		 */
	        psci->bracket_greater = pTrigger->test_value;
		pnewgtval = &psci->bracket_greater;
	    }
	}
d1048 23
a1070 25
		  ct != XSyncCounterNeverDecreases)
	{
	    if (XSyncValueLessThan(pCounter->value, pTrigger->test_value) &&
		XSyncValueLessThan(pTrigger->test_value, psci->bracket_greater))
	    {
		psci->bracket_greater = pTrigger->test_value;
		pnewgtval = &psci->bracket_greater;
	    } else if (XSyncValueEqual(pCounter->value, pTrigger->test_value) &&
		       XSyncValueGreaterThan(pTrigger->test_value,
					     psci->bracket_less))
	    {
	        /*
		 * The value is exactly equal to our threshold.  We want one
		 * more event in the negative direction to ensure we pick up
		 * when the value is less than this threshold.
		 */
	        psci->bracket_less = pTrigger->test_value;
		pnewltval = &psci->bracket_less;
	    }
	}
    } /* end for each trigger */

    if (pnewgtval || pnewltval)
    {
	(*psci->BracketValues)((pointer)pCounter, pnewltval, pnewgtval);
d1082 1
a1082 1
    SyncAlarm      *pAlarm = (SyncAlarm *) addr;
d1091 1
a1091 1
	FreeResource(pAlarm->pEventClients->delete_id, RT_NONE);
a1098 1

d1106 1
a1106 1
    SyncCounter     *pCounter = (SyncCounter *) env;
d1111 26
a1136 33
    for (ptl = pCounter->sync.pTriglist; ptl; ptl = pnext)
    {
	(*ptl->pTrigger->CounterDestroyed)(ptl->pTrigger);
	pnext = ptl->next;
	free(ptl); /* destroy the trigger list as we go */
    }
    if (IsSystemCounter(pCounter))
    {
	int i, found = 0;

	free(pCounter->pSysCounterInfo);

	/* find the counter in the list of system counters and remove it */

	if (SysCounterList)
	{
	    for (i = 0; i < SyncNumSystemCounters; i++)
	    {
		if (SysCounterList[i] == pCounter)
		{
		    found = i;
		    break;
		}
	    }
	    if (found < (SyncNumSystemCounters-1))
	    {
		for (i = found; i < SyncNumSystemCounters-1; i++)
		{
		    SysCounterList[i] = SysCounterList[i+1];
		}
	    }
	}
	SyncNumSystemCounters--;
d1153 1
a1153 1
    pAwait = &(pAwaitUnion+1)->await; /* first await on list */
d1158 8
a1165 8
	 numwaits--, pAwait++)
    {
	/* If the counter is being destroyed, FreeCounter will delete
	 * the trigger list itself, so don't do it here.
	 */
	SyncObject *pSync = pAwait->trigger.pSync;
	if (pSync && !pSync->beingDestroyed)
	    SyncDeleteTriggerFromSyncObject(&pAwait->trigger);
d1175 1
a1175 1
    SyncAlarm *pAlarm = (SyncAlarm *)value;
d1179 9
a1187 12
	 pCur;
	 pPrev = pCur, pCur = pCur->next)
    {
	if (pCur->delete_id == id)
	{
	    if (pPrev)
		pPrev->next = pCur->next;
	    else
		pAlarm->pEventClients = pCur->next;
	    free(pCur);
	    return Success;
	}
d1190 1
a1190 3
    /*NOTREACHED*/
}

a1195 1

d1202 1
a1202 2
    xSyncInitializeReply  rep;
    int   n;
d1213 2
a1214 3
    if (client->swapped)
    {
	swaps(&rep.sequenceNumber, n);
d1226 1
a1226 1
    xSyncListSystemCountersReply  rep;
d1236 5
a1240 5
    for (i = len = 0; i < SyncNumSystemCounters; i++)
    {
	char *name = SysCounterList[i]->pSysCounterInfo->name;
	/* pad to 4 byte boundary */
	len += pad_to_int32(sz_xSyncSystemCounter + strlen(name));
d1243 4
a1246 5
    if (len)
    {
	walklist = list = malloc(len);
	if (!list)
	    return BadAlloc;
d1251 29
a1279 33
    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.nCounters, n);
    }

    for (i = 0; i < SyncNumSystemCounters; i++)
    {
	int namelen;
	char *pname_in_reply;
	SysCounterInfo *psci = SysCounterList[i]->pSysCounterInfo;

	walklist->counter = SysCounterList[i]->sync.id;
	walklist->resolution_hi = XSyncValueHigh32(psci->resolution);
	walklist->resolution_lo = XSyncValueLow32(psci->resolution);
	namelen = strlen(psci->name);
	walklist->name_length = namelen;

	if (client->swapped)
	{
	    char n;
	    swapl(&walklist->counter, n);
	    swapl(&walklist->resolution_hi, n);
	    swapl(&walklist->resolution_lo, n);
	    swaps(&walklist->name_length, n);
	}

	pname_in_reply = ((char *)walklist) + sz_xSyncSystemCounter;
	strncpy(pname_in_reply, psci->name, namelen);
	walklist = (xSyncSystemCounter *) (((char *)walklist) +
				pad_to_int32(sz_xSyncSystemCounter + namelen));
d1283 3
a1285 4
    if (len)
    {
	WriteToClient(client, len, (char *) list);
	free(list);
d1304 1
a1304 1
	priorityclient = client;
d1306 15
a1320 16
	rc = dixLookupClient(&priorityclient, stuff->id, client,
			     DixSetAttrAccess);
	if (rc != Success)
	    return rc;
    }

    if (priorityclient->priority != stuff->priority)
    {
	priorityclient->priority = stuff->priority;

	/*  The following will force the server back into WaitForSomething
	 *  so that the change in this client's priority is immediately
	 *  reflected.
	 */
	isItTimeToYield = TRUE;
	dispatchException |= DE_PRIORITYCHANGE;
d1339 1
a1339 1
	priorityclient = client;
d1341 4
a1344 4
	rc = dixLookupClient(&priorityclient, stuff->id, client,
			     DixGetAttrAccess);
	if (rc != Success)
	    return rc;
d1352 3
a1354 5
    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.priority, n);
d1369 1
a1369 1
    CARD64          initial;
d1375 2
a1376 1
    XSyncIntsToValue(&initial, stuff->initial_value_lo, stuff->initial_value_hi);
d1378 1
a1378 1
	return BadAlloc;
d1390 3
a1392 3
    SyncCounter    *pCounter;
    CARD64	   newvalue;
    int	rc;
d1396 2
a1397 2
    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->cid, RTCounter,
				 client, DixWriteAccess);
d1399 1
a1399 1
	return rc;
d1401 3
a1403 4
    if (IsSystemCounter(pCounter))
    {
	client->errorValue = stuff->cid;
	return BadAccess;
d1418 4
a1421 4
    SyncCounter    *pCounter;
    CARD64          newvalue;
    Bool	    overflow;
    int	rc;
d1425 2
a1426 2
    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->cid, RTCounter,
				 client, DixWriteAccess);
d1428 1
a1428 1
	return rc;
d1430 3
a1432 4
    if (IsSystemCounter(pCounter))
    {
	client->errorValue = stuff->cid;
	return BadAccess;
d1437 4
a1440 5
    if (overflow)
    {
	/* XXX 64 bit value can't fit in 32 bits; do the best we can */
	client->errorValue = stuff->value_hi;
	return BadValue;
d1453 1
a1453 1
    SyncCounter    *pCounter;
d1458 2
a1459 2
    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->counter, RTCounter,
				 client, DixDestroyAccess);
d1461 1
a1461 1
	return rc;
d1463 3
a1465 4
    if (IsSystemCounter(pCounter))
    {
	client->errorValue = stuff->counter;
	return BadAccess;
d1471 1
a1471 1
static SyncAwaitUnion*
d1479 1
a1479 1
    pAwaitUnion = malloc((items+1) * sizeof(SyncAwaitUnion));
d1481 1
a1481 1
	return NULL;
d1490 1
a1490 1
	return NULL;
d1496 1
a1496 1
SyncAwaitEpilogue(ClientPtr client, int items, SyncAwaitUnion *pAwaitUnion)
d1505 19
a1523 21
    pAwait = &(pAwaitUnion+1)->await; /* skip over header */
    for (i = 0; i < items; i++, pAwait++)
    {
	CARD64 value;

	/*  don't have to worry about NULL counters because the request
	 *  errors before we get here out if they occur
	 */
	switch (pAwait->trigger.pSync->type) {
	case SYNC_COUNTER:
	    value = ((SyncCounter *)pAwait->trigger.pSync)->value;
	    break;
	default:
	    XSyncIntToValue(&value, 0);
	}

	if ((*pAwait->trigger.CheckTrigger)(&pAwait->trigger, value))
	{
	    (*pAwait->trigger.TriggerFired)(&pAwait->trigger);
	    break; /* once is enough */
	}
d1534 2
a1535 2
    int             len, items;
    int             i;
d1538 2
a1539 2
    SyncAwait	   *pAwait;
    int		   status;
d1547 6
a1552 8
    if (items * sz_xSyncWaitCondition != len)
    {
	return BadLength;
    }
    if (items == 0)
    {
	client->errorValue = items; /* XXX protocol change */
	return BadValue;
d1556 1
a1556 1
	return BadAlloc;
d1560 1
a1560 1
    pProtocolWaitConds = (xSyncWaitCondition *) & stuff[1];
d1562 37
a1598 40
    pAwait = &(pAwaitUnion+1)->await; /* skip over header */
    for (i = 0; i < items; i++, pProtocolWaitConds++, pAwait++)
    {
	if (pProtocolWaitConds->counter == None) /* XXX protocol change */
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    client->errorValue = pProtocolWaitConds->counter;
	    return SyncErrorBase + XSyncBadCounter;
	}

	/* sanity checks are in SyncInitTrigger */
	pAwait->trigger.pSync = NULL;
	pAwait->trigger.value_type = pProtocolWaitConds->value_type;
	XSyncIntsToValue(&pAwait->trigger.wait_value,
			 pProtocolWaitConds->wait_value_lo,
			 pProtocolWaitConds->wait_value_hi);
	pAwait->trigger.test_type = pProtocolWaitConds->test_type;

	status = SyncInitTrigger(client, &pAwait->trigger,
				 pProtocolWaitConds->counter, RTCounter,
				 XSyncCAAllTrigger);
	if (status != Success)
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    return status;
	}
	/* this is not a mistake -- same function works for both cases */
	pAwait->trigger.TriggerFired = SyncAwaitTriggerFired;
	pAwait->trigger.CounterDestroyed = SyncAwaitTriggerFired;
	XSyncIntsToValue(&pAwait->event_threshold,
			 pProtocolWaitConds->event_threshold_lo,
			 pProtocolWaitConds->event_threshold_hi);
	pAwait->pHeader = &pAwaitUnion->header;
	pAwaitUnion->header.num_waitconditions++;
a1605 1

d1614 1
a1614 1
    SyncCounter    *pCounter;
d1619 2
a1620 2
    rc = dixLookupResourceByType((pointer *)&pCounter, stuff->counter,
				 RTCounter, client, DixReadAccess);
d1622 1
a1622 1
	return rc;
d1630 3
a1632 4
    if (IsSystemCounter(pCounter))
    {
	(*pCounter->pSysCounterInfo->QueryValue) ((pointer) pCounter,
						  &pCounter->value);
d1637 5
a1641 7
    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.value_hi, n);
	swapl(&rep.value_lo, n);
a1646 1

d1654 4
a1657 4
    SyncAlarm      *pAlarm;
    int             status;
    unsigned long   len, vmask;
    SyncTrigger	    *pTrigger;
d1666 2
a1667 2
    if (len != (Ones(vmask) + Ones(vmask & (XSyncCAValue|XSyncCADelta))))
	return BadLength;
d1669 2
a1670 3
    if (!(pAlarm = malloc(sizeof(SyncAlarm))))
    {
	return BadAlloc;
d1683 4
a1686 5
			     XSyncCAAllTrigger);
    if (status != Success)
    {
	free(pAlarm);
	return status;
d1696 4
a1699 5
				       (CARD32 *)&stuff[1]);
    if (status != Success)
    {
	free(pAlarm);
	return status;
d1703 1
a1703 1
	return BadAlloc;
d1709 2
a1710 3
    if (!pTrigger->pSync)
    {
	pAlarm->state = XSyncAlarmInactive; /* XXX protocol change */
d1712 2
a1713 10
    else
    {
	SyncCounter *pCounter;

	if (!SyncCheckWarnIsCounter(pTrigger->pSync,
				    WARN_INVALID_COUNTER_ALARM))
	{
	    FreeResource(stuff->id, RT_NONE);
	    return BadAlloc;
	}
d1715 5
a1719 1
	pCounter = (SyncCounter *)pTrigger->pSync;
d1721 4
a1724 2
	if ((*pTrigger->CheckTrigger)(pTrigger, pCounter->value))
	    (*pTrigger->TriggerFired)(pTrigger);
d1737 1
a1737 1
    SyncAlarm   *pAlarm;
d1739 2
a1740 2
    long        vmask;
    int         len, status;
d1744 2
a1745 2
    status = dixLookupResourceByType((pointer *)&pAlarm, stuff->alarm, RTAlarm,
				     client, DixWriteAccess);
d1747 1
a1747 1
	return status;
d1752 2
a1753 2
    if (len != (Ones(vmask) + Ones(vmask & (XSyncCAValue|XSyncCADelta))))
	return BadLength;
d1756 2
a1757 2
					    (CARD32 *)&stuff[1])) != Success)
	return status;
d1760 2
a1761 2
			       WARN_INVALID_COUNTER_ALARM))
	pCounter = (SyncCounter *)pAlarm->trigger.pSync;
d1768 2
a1769 3
	(*pAlarm->trigger.CheckTrigger)(&pAlarm->trigger, pCounter->value))
    {
	(*pAlarm->trigger.TriggerFired)(&pAlarm->trigger);
d1778 1
a1778 1
    SyncAlarm      *pAlarm;
d1780 1
a1780 1
    SyncTrigger    *pTrigger;
d1785 2
a1786 2
    rc = dixLookupResourceByType((pointer *)&pAlarm, stuff->alarm, RTAlarm,
				 client, DixReadAccess);
d1788 1
a1788 1
	return rc;
d1791 2
a1792 1
    rep.length = bytes_to_int32(sizeof(xSyncQueryAlarmReply) - sizeof(xGenericReply));
d1798 4
a1801 4
#if 0 /* XXX unclear what to do, depends on whether relative value-types
       * are "consumed" immediately and are considered absolute from then
       * on.
       */
d1817 9
a1825 11
    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.counter, n);
	swapl(&rep.wait_value_hi, n);
	swapl(&rep.wait_value_lo, n);
	swapl(&rep.test_type, n);
	swapl(&rep.delta_hi, n);
	swapl(&rep.delta_lo, n);
d1837 1
d1842 2
a1843 2
    rc = dixLookupResourceByType((pointer *)&pAlarm, stuff->alarm, RTAlarm,
				 client, DixDestroyAccess);
d1845 1
a1845 1
	return rc;
d1863 1
a1863 1
	return rc;
d1867 2
a1868 4
    if (!(pFence = (SyncFence *)SyncCreate(client,
					   stuff->fid,
					   SYNC_FENCE)))
	return BadAlloc;
d1873 1
a1873 1
	return BadAlloc;
d1888 2
a1889 2
int SyncVerifyFence(SyncFence **ppSyncFence, XID fid,
		    ClientPtr client, Mask mode)
d1891 2
a1892 2
    int rc = dixLookupResourceByType((pointer *)ppSyncFence, fid, RTFence,
				     client, mode);
d1895 1
a1895 1
	client->errorValue = fid;
d1909 2
a1910 2
    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid, RTFence,
				 client, DixWriteAccess);
d1912 1
a1912 1
	return rc;
d1928 2
a1929 2
    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid, RTFence,
				 client, DixWriteAccess);
d1931 1
a1931 1
	return rc;
d1934 1
a1934 1
	return BadMatch;
d1950 2
a1951 2
    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid, RTFence,
				 client, DixDestroyAccess);
d1953 1
a1953 1
	return rc;
d1969 2
a1970 2
    rc = dixLookupResourceByType((pointer *)&pFence, stuff->fid,
				 RTFence, client, DixReadAccess);
d1972 1
a1972 1
	return rc;
d1980 3
a1982 5
    if (client->swapped)
    {
	char n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
d1995 1
d2010 6
a2015 8
    if (items * sizeof(CARD32) != len)
    {
	return BadLength;
    }
    if (items == 0)
    {
	client->errorValue = items;
	return BadValue;
d2019 1
a2019 1
	return BadAlloc;
d2023 12
a2034 1
    pProtocolFences = (CARD32 *) & stuff[1];
d2036 24
a2059 39
    pAwait = &(pAwaitUnion+1)->await; /* skip over header */
    for (i = 0; i < items; i++, pProtocolFences++, pAwait++)
    {
	if (*pProtocolFences == None)
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    client->errorValue = *pProtocolFences;
	    return SyncErrorBase + XSyncBadFence;
	}

	pAwait->trigger.pSync = NULL;
	/* Provide acceptable values for these unused fields to
	 * satisfy SyncInitTrigger's validation logic
	 */
	pAwait->trigger.value_type = XSyncAbsolute;
	XSyncIntToValue(&pAwait->trigger.wait_value, 0);
	pAwait->trigger.test_type = 0;

	status = SyncInitTrigger(client, &pAwait->trigger,
				 *pProtocolFences, RTFence,
				 XSyncCAAllTrigger);
	if (status != Success)
	{
	    /*  this should take care of removing any triggers created by
	     *  this request that have already been registered on sync objects
	     */
	    FreeResource(pAwaitUnion->header.delete_id, RT_NONE);
	    return status;
	}
	/* this is not a mistake -- same function works for both cases */
	pAwait->trigger.TriggerFired = SyncAwaitTriggerFired;
	pAwait->trigger.CounterDestroyed = SyncAwaitTriggerFired;
	/* event_threshold is unused for fence syncs */
	XSyncIntToValue(&pAwait->event_threshold, 0);
	pAwait->pHeader = &pAwaitUnion->header;
	pAwaitUnion->header.num_waitconditions++;
d2075 43
a2117 44
    switch (stuff->data)
    {
      case X_SyncInitialize:
	return ProcSyncInitialize(client);
      case X_SyncListSystemCounters:
	return ProcSyncListSystemCounters(client);
      case X_SyncCreateCounter:
	return ProcSyncCreateCounter(client);
      case X_SyncSetCounter:
	return ProcSyncSetCounter(client);
      case X_SyncChangeCounter:
	return ProcSyncChangeCounter(client);
      case X_SyncQueryCounter:
	return ProcSyncQueryCounter(client);
      case X_SyncDestroyCounter:
	return ProcSyncDestroyCounter(client);
      case X_SyncAwait:
	return ProcSyncAwait(client);
      case X_SyncCreateAlarm:
	return ProcSyncCreateAlarm(client);
      case X_SyncChangeAlarm:
	return ProcSyncChangeAlarm(client);
      case X_SyncQueryAlarm:
	return ProcSyncQueryAlarm(client);
      case X_SyncDestroyAlarm:
	return ProcSyncDestroyAlarm(client);
      case X_SyncSetPriority:
	return ProcSyncSetPriority(client);
      case X_SyncGetPriority:
	return ProcSyncGetPriority(client);
      case X_SyncCreateFence:
	return ProcSyncCreateFence(client);
      case X_SyncTriggerFence:
	return ProcSyncTriggerFence(client);
      case X_SyncResetFence:
	return ProcSyncResetFence(client);
      case X_SyncDestroyFence:
	return ProcSyncDestroyFence(client);
      case X_SyncQueryFence:
	return ProcSyncQueryFence(client);
      case X_SyncAwaitFence:
	return ProcSyncAwaitFence(client);
      default:
	return BadRequest;
d2129 2
a2130 4
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncInitializeReq);
d2139 2
a2140 4
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncListSystemCountersReq);
d2149 5
a2153 7
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncCreateCounterReq);
    swapl(&stuff->cid, n);
    swapl(&stuff->initial_value_lo, n);
    swapl(&stuff->initial_value_hi, n);
d2162 5
a2166 7
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncSetCounterReq);
    swapl(&stuff->cid, n);
    swapl(&stuff->value_lo, n);
    swapl(&stuff->value_hi, n);
d2175 5
a2179 7
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncChangeCounterReq);
    swapl(&stuff->cid, n);
    swapl(&stuff->value_lo, n);
    swapl(&stuff->value_hi, n);
d2188 3
a2190 5
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncQueryCounterReq);
    swapl(&stuff->counter, n);
d2199 3
a2201 5
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncDestroyCounterReq);
    swapl(&stuff->counter, n);
d2210 1
a2210 3
    char   n;

    swaps(&stuff->length, n);
d2221 1
a2221 3
    char   n;

    swaps(&stuff->length, n);
d2223 2
a2224 2
    swapl(&stuff->id, n);
    swapl(&stuff->valueMask, n);
d2234 1
a2234 3
    char   n;

    swaps(&stuff->length, n);
d2236 2
a2237 2
    swapl(&stuff->alarm, n);
    swapl(&stuff->valueMask, n);
d2246 3
a2248 5
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncQueryAlarmReq);
    swapl(&stuff->alarm, n);
d2257 3
a2259 5
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncDestroyAlarmReq);
    swapl(&stuff->alarm, n);
d2268 4
a2271 6
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncSetPriorityReq);
    swapl(&stuff->id, n);
    swapl(&stuff->priority, n);
d2280 3
a2282 5
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncGetPriorityReq);
    swapl(&stuff->id, n);
d2291 3
a2293 5
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncCreateFenceReq);
    swapl(&stuff->fid, n);
d2302 3
a2304 5
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncTriggerFenceReq);
    swapl(&stuff->fid, n);
d2313 3
a2315 5
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncResetFenceReq);
    swapl(&stuff->fid, n);
d2324 3
a2326 5
    char n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncDestroyFenceReq);
    swapl(&stuff->fid, n);
d2335 3
a2337 5
    char   n;

    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH (xSyncQueryFenceReq);
    swapl(&stuff->fid, n);
d2346 1
a2346 3
    char   n;

    swaps(&stuff->length, n);
d2358 43
a2400 44
    switch (stuff->data)
    {
      case X_SyncInitialize:
	return SProcSyncInitialize(client);
      case X_SyncListSystemCounters:
	return SProcSyncListSystemCounters(client);
      case X_SyncCreateCounter:
	return SProcSyncCreateCounter(client);
      case X_SyncSetCounter:
	return SProcSyncSetCounter(client);
      case X_SyncChangeCounter:
	return SProcSyncChangeCounter(client);
      case X_SyncQueryCounter:
	return SProcSyncQueryCounter(client);
      case X_SyncDestroyCounter:
	return SProcSyncDestroyCounter(client);
      case X_SyncAwait:
	return SProcSyncAwait(client);
      case X_SyncCreateAlarm:
	return SProcSyncCreateAlarm(client);
      case X_SyncChangeAlarm:
	return SProcSyncChangeAlarm(client);
      case X_SyncQueryAlarm:
	return SProcSyncQueryAlarm(client);
      case X_SyncDestroyAlarm:
	return SProcSyncDestroyAlarm(client);
      case X_SyncSetPriority:
	return SProcSyncSetPriority(client);
      case X_SyncGetPriority:
	return SProcSyncGetPriority(client);
      case X_SyncCreateFence:
	return SProcSyncCreateFence(client);
      case X_SyncTriggerFence:
	return SProcSyncTriggerFence(client);
      case X_SyncResetFence:
	return SProcSyncResetFence(client);
      case X_SyncDestroyFence:
	return SProcSyncDestroyFence(client);
      case X_SyncQueryFence:
	return SProcSyncQueryFence(client);
      case X_SyncAwaitFence:
	return SProcSyncAwaitFence(client);
      default:
	return BadRequest;
d2409 2
a2410 1
SCounterNotifyEvent(xSyncCounterNotifyEvent *from, xSyncCounterNotifyEvent *to)
a2424 1

d2426 1
a2426 1
SAlarmNotifyEvent(xSyncAlarmNotifyEvent *from, xSyncAlarmNotifyEvent *to)
d2445 1
a2445 1
SyncResetProc(ExtensionEntry *extEntry)
d2459 1
a2459 1
    int 	    s;
d2462 1
a2462 1
	miSyncSetup(screenInfo.screens[s]);
d2464 2
a2465 3
    if (RTCounter == 0)
    {
	RTCounter = CreateNewResourceType(FreeCounter, "SyncCounter");
d2471 1
a2471 1
	RTAwait |= RC_NEVERRETAIN;
d2474 1
a2474 1
	RTAlarmClient |= RC_NEVERRETAIN;
d2477 8
a2484 10
	RTAlarmClient == 0 ||
	(extEntry = AddExtension(SYNC_NAME,
				 XSyncNumberEvents, XSyncNumberErrors,
				 ProcSyncDispatch, SProcSyncDispatch,
				 SyncResetProc,
				 StandardMinorOpcode)) == NULL)
    {
	ErrorF("Sync Extension %d.%d failed to Initialise\n",
		SYNC_MAJOR_VERSION, SYNC_MINOR_VERSION);
	return;
d2489 4
a2492 2
    EventSwapVector[SyncEventBase + XSyncCounterNotify] = (EventSwapPtr) SCounterNotifyEvent;
    EventSwapVector[SyncEventBase + XSyncAlarmNotify] = (EventSwapPtr) SAlarmNotifyEvent;
d2509 1
a2509 1
	    SYNC_MAJOR_VERSION, SYNC_MINOR_VERSION);
a2512 1

a2516 2


d2533 1
a2533 2
/*ARGSUSED*/
static void
d2539 1
a2539 2
    if (pnext_time)
    {
d2542 1
a2542 2
        if (XSyncValueGreaterOrEqual(Now, *pnext_time))
	{
d2545 3
a2547 3
	else
	{
	    Bool overflow;
d2549 1
a2549 1
	    (void)overflow;
d2552 1
a2552 1
        AdjustWaitForDelay(wt, timeout); /* os/utils.c */
d2559 1
a2559 2
/*ARGSUSED*/
static void
d2562 1
a2562 2
    if (pnext_time)
    {
d2565 1
a2565 2
        if (XSyncValueGreaterOrEqual(Now, *pnext_time))
	{
d2572 1
a2572 1
ServertimeQueryValue(void *pCounter, CARD64 *pValue_return)
d2579 2
a2580 2
ServertimeBracketValues(void *pCounter, CARD64 *pbracket_less,
			CARD64 *pbracket_greater)
d2582 7
a2588 11
    if (!pnext_time && pbracket_greater)
    {
	RegisterBlockAndWakeupHandlers(ServertimeBlockHandler,
				       ServertimeWakeupHandler,
				       NULL);
    }
    else if (pnext_time && !pbracket_greater)
    {
	RemoveBlockAndWakeupHandlers(ServertimeBlockHandler,
				     ServertimeWakeupHandler,
				     NULL);
d2601 3
a2603 2
			    XSyncCounterNeverDecreases,
			    ServertimeQueryValue, ServertimeBracketValues);
a2606 2


d2616 1
a2616 1
IdleTimeQueryValue (pointer pCounter, CARD64 *pValue_return)
d2619 2
a2620 1
    XSyncIntsToValue (pValue_return, idle, 0);
d2631 1
a2631 1
	return;
d2634 2
a2635 2
    IdleTimeQueryValue (NULL, &idle);
    IdleTimeCounter->value = idle; /* push, so CheckTrigger works */
d2637 37
a2673 53
    if (pIdleTimeValueLess &&
        XSyncValueLessOrEqual (idle, *pIdleTimeValueLess))
    {
	/*
	 * We've been idle for less than the threshold value, and someone
	 * wants to know about that, but now we need to know whether they
	 * want level or edge trigger.  Check the trigger list against the
	 * current idle time, and if any succeed, bomb out of select()
	 * immediately so we can reschedule.
	 */

	for (list = IdleTimeCounter->sync.pTriglist; list; list = list->next) {
	    trig = list->pTrigger;
	    if (trig->CheckTrigger(trig, old_idle)) {
		AdjustWaitForDelay(wt, 0);
		break;
	    }
	}
	/* 
	 * We've been called exactly on the idle time, but we have a
	 * NegativeTransition trigger which requires a transition from an
	 * idle time greater than this.  Schedule a wakeup for the next
	 * millisecond so we won't miss a transition.
	 */
	if (XSyncValueEqual (idle, *pIdleTimeValueLess))
	    AdjustWaitForDelay(wt, 1);
    }
    else if (pIdleTimeValueGreater)
    {
	/*
	 * There's a threshold in the positive direction.  If we've been
	 * idle less than it, schedule a wakeup for sometime in the future.
	 * If we've been idle more than it, and someone wants to know about
	 * that level-triggered, schedule an immediate wakeup.
	 */
	unsigned long timeout = -1;

	if (XSyncValueLessThan (idle, *pIdleTimeValueGreater)) {
	    XSyncValue value;
	    Bool overflow;

	    XSyncValueSubtract (&value, *pIdleTimeValueGreater,
	                        idle, &overflow);
	    timeout = min(timeout, XSyncValueLow32 (value));
	} else {
	    for (list = IdleTimeCounter->sync.pTriglist; list; list = list->next) {
		trig = list->pTrigger;
		if (trig->CheckTrigger(trig, old_idle)) {
		    timeout = min(timeout, 0);
		    break;
		}
	    }
	}
d2675 15
a2689 1
	AdjustWaitForDelay (wt, timeout);
d2692 1
a2692 1
    IdleTimeCounter->value = old_idle; /* pop */
d2696 1
a2696 1
IdleTimeWakeupHandler (pointer env, int rc, pointer LastSelectMask)
d2701 1
a2701 1
	return;
d2703 1
a2703 1
    IdleTimeQueryValue (NULL, &idle);
d2706 1
a2706 1
         XSyncValueGreaterOrEqual (idle, *pIdleTimeValueGreater)) ||
d2708 2
a2709 3
	 XSyncValueLessOrEqual (idle, *pIdleTimeValueLess)))
    {
	SyncChangeCounter (IdleTimeCounter, idle);
d2714 2
a2715 2
IdleTimeBracketValues (pointer pCounter, CARD64 *pbracket_less,
                       CARD64 *pbracket_greater)
d2719 7
a2725 11
    if (registered && !pbracket_less && !pbracket_greater)
    {
	RemoveBlockAndWakeupHandlers(IdleTimeBlockHandler,
	                             IdleTimeWakeupHandler,
	                             NULL);
    }
    else if (!registered && (pbracket_less || pbracket_greater))
    {
	RegisterBlockAndWakeupHandlers(IdleTimeBlockHandler,
	                               IdleTimeWakeupHandler,
	                               NULL);
d2729 1
a2729 1
    pIdleTimeValueLess    = pbracket_less;
d2733 1
a2733 1
SyncInitIdleTime (void)
d2738 2
a2739 2
    IdleTimeQueryValue (NULL, &idle);
    XSyncIntToValue (&resolution, 4);
d2741 4
a2744 4
    IdleTimeCounter = SyncCreateSystemCounter ("IDLETIME", idle, resolution,
                                               XSyncCounterUnrestricted,
                                               IdleTimeQueryValue,
                                               IdleTimeBracketValues);
@


1.7
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d62 1
a62 1
#include "misc.h"
d66 1
d71 1
d90 1
d93 10
d105 1
a105 1
    (pCounter && (pCounter->client == NULL))
d117 16
a132 30
static DISPATCH_PROC(ProcSyncAwait);
static DISPATCH_PROC(ProcSyncChangeAlarm);
static DISPATCH_PROC(ProcSyncChangeCounter);
static DISPATCH_PROC(ProcSyncCreateAlarm);
static DISPATCH_PROC(ProcSyncCreateCounter);
static DISPATCH_PROC(ProcSyncDestroyAlarm);
static DISPATCH_PROC(ProcSyncDestroyCounter);
static DISPATCH_PROC(ProcSyncDispatch);
static DISPATCH_PROC(ProcSyncGetPriority);
static DISPATCH_PROC(ProcSyncInitialize);
static DISPATCH_PROC(ProcSyncListSystemCounters);
static DISPATCH_PROC(ProcSyncQueryAlarm);
static DISPATCH_PROC(ProcSyncQueryCounter);
static DISPATCH_PROC(ProcSyncSetCounter);
static DISPATCH_PROC(ProcSyncSetPriority);
static DISPATCH_PROC(SProcSyncAwait);
static DISPATCH_PROC(SProcSyncChangeAlarm);
static DISPATCH_PROC(SProcSyncChangeCounter);
static DISPATCH_PROC(SProcSyncCreateAlarm);
static DISPATCH_PROC(SProcSyncCreateCounter);
static DISPATCH_PROC(SProcSyncDestroyAlarm);
static DISPATCH_PROC(SProcSyncDestroyCounter);
static DISPATCH_PROC(SProcSyncDispatch);
static DISPATCH_PROC(SProcSyncGetPriority);
static DISPATCH_PROC(SProcSyncInitialize);
static DISPATCH_PROC(SProcSyncListSystemCounters);
static DISPATCH_PROC(SProcSyncQueryAlarm);
static DISPATCH_PROC(SProcSyncQueryCounter);
static DISPATCH_PROC(SProcSyncSetCounter);
static DISPATCH_PROC(SProcSyncSetPriority);
d139 1
a139 1
SyncDeleteTriggerFromCounter(SyncTrigger *pTrigger)
d143 1
d145 1
a145 1
    /* pCounter needs to be stored in pTrigger before calling here. */
d147 1
a147 1
    if (!pTrigger->pCounter)
d151 1
a151 1
    pCur = pTrigger->pCounter->pTriglist;
d160 1
a160 1
		pTrigger->pCounter->pTriglist = pCur->next;
d170 10
a179 2
    if (IsSystemCounter(pTrigger->pCounter))
	SyncComputeBracketValues(pTrigger->pCounter);
d184 1
a184 1
SyncAddTriggerToCounter(SyncTrigger *pTrigger)
d187 1
d189 1
a189 1
    if (!pTrigger->pCounter)
d193 1
a193 1
    for (pCur = pTrigger->pCounter->pTriglist; pCur; pCur = pCur->next)
d203 6
a208 2
    pCur->next = pTrigger->pCounter->pTriglist;
    pTrigger->pCounter->pTriglist = pCur;
d210 6
a215 2
    if (IsSystemCounter(pTrigger->pCounter))
	SyncComputeBracketValues(pTrigger->pCounter);
d221 9
a229 8
/*  Below are four possible functions that can be plugged into
 *  pTrigger->CheckTrigger, corresponding to the four possible
 *  test-types.  These functions are called after the counter's
 *  value changes but are also passed the old counter value
 *  so they can inspect both the old and new values.
 *  (PositiveTransition and NegativeTransition need to see both
 *  pieces of information.)  These functions return the truth value
 *  of the trigger.
d231 2
a232 2
 *  All of them include the condition pTrigger->pCounter == NULL.
 *  This is because the spec says that a trigger with a counter value
d239 11
a249 3
    return (pTrigger->pCounter == NULL ||
	    XSyncValueGreaterOrEqual(pTrigger->pCounter->value,
				     pTrigger->test_value));
d255 11
a265 3
    return (pTrigger->pCounter == NULL ||
	    XSyncValueLessOrEqual(pTrigger->pCounter->value,
				  pTrigger->test_value));
d271 10
a280 1
    return (pTrigger->pCounter == NULL ||
d282 1
a282 2
	     XSyncValueGreaterOrEqual(pTrigger->pCounter->value,
				      pTrigger->test_value)));
d288 10
a297 1
    return (pTrigger->pCounter == NULL ||
d299 11
a309 2
	     XSyncValueLessOrEqual(pTrigger->pCounter->value,
				   pTrigger->test_value)));
d313 2
a314 2
SyncInitTrigger(ClientPtr client, SyncTrigger *pTrigger, XSyncCounter counter,
		Mask changes)
d316 2
a317 1
    SyncCounter *pCounter = pTrigger->pCounter;
d319 1
a319 1
    Bool	newcounter = FALSE;
d323 4
a326 4
	if (counter == None)
	    pCounter = NULL;
	else if (Success != (rc = dixLookupResourceByType ((pointer *)&pCounter,
				counter, RTCounter, client, DixReadAccess)))
d328 1
a328 1
	    client->errorValue = counter;
d331 1
a331 1
	if (pCounter != pTrigger->pCounter)
d333 3
a335 3
	    SyncDeleteTriggerFromCounter(pTrigger);
	    pTrigger->pCounter = pCounter;
	    newcounter = TRUE;
d341 1
a341 1
    if (IsSystemCounter(pCounter))
d343 7
a349 2
	(*pCounter->pSysCounterInfo->QueryValue) ((pointer) pCounter,
						  &pCounter->value);
d364 2
a365 4
	if (pTrigger->test_type != XSyncPositiveTransition &&
	    pTrigger->test_type != XSyncNegativeTransition &&
	    pTrigger->test_type != XSyncPositiveComparison &&
	    pTrigger->test_type != XSyncNegativeComparison)
d367 1
a367 2
	    client->errorValue = pTrigger->test_type;
	    return BadValue;
d369 3
a371 1
	/* select appropriate CheckTrigger function */
d373 18
a390 14
	switch (pTrigger->test_type)
	{
        case XSyncPositiveTransition:
	    pTrigger->CheckTrigger = SyncCheckTriggerPositiveTransition;
	    break;
        case XSyncNegativeTransition:
	    pTrigger->CheckTrigger = SyncCheckTriggerNegativeTransition;
	    break;
        case XSyncPositiveComparison:
	    pTrigger->CheckTrigger = SyncCheckTriggerPositiveComparison;
	    break;
        case XSyncNegativeComparison:
	    pTrigger->CheckTrigger = SyncCheckTriggerNegativeComparison;
	    break;
d417 1
a417 1
    if (newcounter)
d419 1
a419 1
	if ((rc = SyncAddTriggerToCounter(pTrigger)) != Success)
d422 1
a422 1
    else if (IsSystemCounter(pCounter))
d440 6
d452 1
a452 1
    if (pTrigger->pCounter)
d454 2
a455 2
	ane.counter_value_hi = XSyncValueHigh32(pTrigger->pCounter->value);
	ane.counter_value_lo = XSyncValueLow32(pTrigger->pCounter->value);
d498 1
a498 1
	pev->counter = pTrigger->pCounter->id;
d501 13
a513 2
	pev->counter_value_lo = XSyncValueLow32(pTrigger->pCounter->value);
	pev->counter_value_hi = XSyncValueHigh32(pTrigger->pCounter->value);
d516 1
a516 1
	pev->destroyed = pTrigger->pCounter->beingDestroyed;
d534 1
a534 1
    pTrigger->pCounter = NULL;
d545 1
d548 5
d562 1
a562 1
    if (pAlarm->trigger.pCounter == NULL
d575 7
d597 1
a597 1
					paTrigger->pCounter->value));
d664 1
a664 1
	if (pAwait->trigger.pCounter->beingDestroyed)
d669 4
d674 6
a679 6
	/* "The difference between the counter and the test value is
	 *  calculated by subtracting the test value from the value of
	 *  the counter."
	 */
	XSyncValueSubtract(&diff, pAwait->trigger.pCounter->value,
			   pAwait->trigger.test_value, &overflow);
d681 15
a695 7
	/* "If the difference lies outside the range for an INT64, an
	 *  event is not generated."
	 */
	if (overflow)
	    continue;
	diffgreater = XSyncValueGreaterThan(diff, pAwait->event_threshold);
	diffequal   = XSyncValueEqual(diff, pAwait->event_threshold);
d697 12
a708 19
	/* "If the test-type is PositiveTransition or
	 *  PositiveComparison, a CounterNotify event is generated if
	 *  the difference is at least event-threshold. If the test-type
	 *  is NegativeTransition or NegativeComparison, a CounterNotify
	 *  event is generated if the difference is at most
	 *  event-threshold."
	 */

	if ( ((pAwait->trigger.test_type == XSyncPositiveComparison ||
	       pAwait->trigger.test_type == XSyncPositiveTransition)
	       && (diffgreater || diffequal))
	     ||
	     ((pAwait->trigger.test_type == XSyncNegativeComparison ||
	       pAwait->trigger.test_type == XSyncNegativeTransition)
	      && (!diffgreater) /* less or equal */
	      )
	   )
	{
	    ppAwait[num_events++] = pAwait;
d737 1
a737 1
    for (ptl = pCounter->pTriglist; ptl; ptl = pnext)
a803 5
    if (!AddResource(pClients->delete_id, RTAlarmClient, pAlarm))
    {
	free(pClients);
	return BadAlloc;
    }
a805 1

d809 4
d827 2
a828 1
    counter = pAlarm->trigger.pCounter ? pAlarm->trigger.pCounter->id : None;
d908 1
a908 1
    if ((status = SyncInitTrigger(client, &pAlarm->trigger, counter,
d917 29
d952 3
a954 1
    if (!(pCounter = malloc(sizeof(SyncCounter))))
d957 3
a960 2
    {
	free(pCounter);
a961 1
    }
a962 6
    pCounter->client = client;
    pCounter->id = id;
    pCounter->value = initialvalue;
    pCounter->pTriglist = NULL;
    pCounter->beingDestroyed = FALSE;
    pCounter->pSysCounterInfo = NULL;
d1013 1
a1013 1
	    FreeResource(pCounter->id, RT_NONE);
d1033 1
a1033 1
    FreeResource(pCounter->id, RT_NONE);
d1057 1
a1057 1
    for (pCur = pCounter->pTriglist; pCur; pCur = pCur->next)
d1152 1
a1152 1
    SyncDeleteTriggerFromCounter(&pAlarm->trigger);
d1169 1
a1169 1
    pCounter->beingDestroyed = TRUE;
d1171 1
a1171 1
    for (ptl = pCounter->pTriglist; ptl; ptl = pnext)
d1230 3
a1232 3
	SyncCounter *pCounter = pAwait->trigger.pCounter;
	if (pCounter && !pCounter->beingDestroyed)
	    SyncDeleteTriggerFromCounter(&pAwait->trigger);
d1341 1
a1341 1
	walklist->counter = SysCounterList[i]->id;
d1554 1
a1554 1
    FreeResource(pCounter->id, RT_NONE);
d1558 57
d1646 1
a1646 15
    pProtocolWaitConds = (xSyncWaitCondition *) & stuff[1];

    /*  all the memory for the entire await list is allocated
     *  here in one chunk
     */
    pAwaitUnion = malloc((items+1) * sizeof(SyncAwaitUnion));
    if (!pAwaitUnion)
	return BadAlloc;

    /* first item is the header, remainder are real wait conditions */

    pAwaitUnion->header.delete_id = FakeClientID(client->index);
    if (!AddResource(pAwaitUnion->header.delete_id, RTAwait, pAwaitUnion))
    {
	free(pAwaitUnion);
a1647 1
    }
d1651 1
a1651 2
    pAwaitUnion->header.client = client;
    pAwaitUnion->header.num_waitconditions = 0;
d1659 1
a1659 1
	     *  this request that have already been registered on counters
d1667 1
a1667 1
	pAwait->trigger.pCounter = NULL;
d1675 2
a1676 1
			 pProtocolWaitConds->counter, XSyncCAAllTrigger);
d1680 1
a1680 1
	     *  this request that have already been registered on counters
d1695 1
a1695 3
    IgnoreClient(client);

    /* see if any of the triggers are already true */
a1696 13
    pAwait = &(pAwaitUnion+1)->await; /* skip over header */
    for (i = 0; i < items; i++, pAwait++)
    {
	/*  don't have to worry about NULL counters because the request
	 *  errors before we get here out if they occur
	 */
	if ((*pAwait->trigger.CheckTrigger)(&pAwait->trigger,
					    pAwait->trigger.pCounter->value))
	{
	    (*pAwait->trigger.TriggerFired)(&pAwait->trigger);
	    break; /* once is enough */
	}
    }
d1776 1
a1776 1
    pTrigger->pCounter = NULL;
d1782 2
a1783 1
    status = SyncInitTrigger(client, pTrigger, None, XSyncCAAllTrigger);
a1804 2
    {
	free(pAlarm);
a1805 1
    }
d1811 1
a1811 1
    if (!pTrigger->pCounter)
d1815 1
a1815 1
    else if ((*pTrigger->CheckTrigger)(pTrigger, pTrigger->pCounter->value))
d1817 13
a1829 1
	(*pTrigger->TriggerFired)(pTrigger);
d1843 1
d1864 4
d1872 2
a1873 3
    if (!pAlarm->trigger.pCounter ||
	(*pAlarm->trigger.CheckTrigger)(&pAlarm->trigger,
					pAlarm->trigger.pCounter->value))
d1901 1
a1901 1
    rep.counter = (pTrigger->pCounter) ? pTrigger->pCounter->id : None;
d1957 225
d2220 12
d2431 77
d2544 12
a2608 1

d2616 4
d2627 1
d2654 1
d2798 1
a2798 1
    SyncTriggerList *list = IdleTimeCounter->pTriglist;
d2819 1
a2819 1
	for (list = IdleTimeCounter->pTriglist; list; list = list->next) {
d2853 1
a2853 1
	    for (list = IdleTimeCounter->pTriglist; list; list = list->next) {
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d70 1
d963 11
d984 11
d1155 2
a1156 2
    rep.majorVersion = SYNC_MAJOR_VERSION;
    rep.minorVersion = SYNC_MINOR_VERSION;
d2326 8
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d161 1
a161 1
	    xfree(pCur);
d189 1
a189 1
    if (!(pCur = xalloc(sizeof(SyncTriggerList))))
d267 1
a267 1
	    return (rc == BadValue) ? SyncErrorBase + XSyncBadCounter : rc;
a374 1
    ane.sequenceNumber = pAlarm->client->sequence;
d392 1
a392 1
    if (pAlarm->events && !pAlarm->client->clientGone)
d397 1
a397 7
    {
	if (!pAlarm->client->clientGone)
	{
	    ane.sequenceNumber = pcl->client->sequence;
	    WriteEventsToClient(pcl->client, 1, (xEvent *) &ane);
	}
    }
d413 1
a413 1
    pev = pEvents = xalloc(num_events * sizeof(xSyncCounterNotifyEvent));
a421 1
	pev->sequenceNumber = client->sequence;
d433 1
a433 1
    xfree(pEvents);
d540 1
a540 1
    ppAwait = xalloc(numwaits * sizeof(SyncAwait *));
d609 1
a609 1
    xfree(ppAwait);
d690 1
a690 1
    pClients = xalloc(sizeof(SyncAlarmClientList));
d701 1
a701 1
	xfree(pClients);
d819 1
a819 1
    if (!(pCounter = xalloc(sizeof(SyncCounter))))
d824 1
a824 1
	xfree(pCounter);
d858 1
a858 1
    SysCounterList = xrealloc(SysCounterList,
d881 1
a881 1
	psci = xalloc(sizeof(SysCounterInfo));
d1003 1
a1003 1
    xfree(pAlarm);
d1024 1
a1024 1
	xfree(ptl); /* destroy the trigger list as we go */
d1030 1
a1030 1
	xfree(pCounter->pSysCounterInfo);
d1054 1
a1054 1
    xfree(pCounter);
d1083 1
a1083 1
    xfree(pAwaitUnion);
d1104 1
a1104 1
	    xfree(pCur);
d1141 1
a1141 1
    return client->noClientException;
d1169 1
a1169 1
	walklist = list = xalloc(len);
d1215 1
a1215 1
	xfree(list);
d1218 1
a1218 1
    return client->noClientException;
d1292 1
a1292 1
    return client->noClientException;
d1312 1
a1312 1
    return client->noClientException;
d1331 1
a1331 1
	return (rc == BadValue) ? SyncErrorBase + XSyncBadCounter : rc;
d1361 1
a1361 1
	return (rc == BadValue) ? SyncErrorBase + XSyncBadCounter : rc;
d1396 1
a1396 1
	return (rc == BadValue) ? SyncErrorBase + XSyncBadCounter : rc;
d1443 1
a1443 1
    pAwaitUnion = xalloc((items+1) * sizeof(SyncAwaitUnion));
d1452 1
a1452 1
	xfree(pAwaitUnion);
d1539 1
a1539 1
	return (rc == BadValue) ? SyncErrorBase + XSyncBadCounter : rc;
d1564 1
a1564 1
    return client->noClientException;
d1590 1
a1590 1
    if (!(pAlarm = xalloc(sizeof(SyncAlarm))))
d1607 1
a1607 1
	xfree(pAlarm);
d1621 1
a1621 1
	xfree(pAlarm);
d1627 1
a1627 1
	xfree(pAlarm);
d1663 1
a1663 1
	return (status == BadValue) ? SyncErrorBase + XSyncBadAlarm : status;
d1702 1
a1702 1
	return (rc == BadValue) ? SyncErrorBase + XSyncBadAlarm : rc;
d1744 1
a1744 1
    return client->noClientException;
d1759 1
a1759 1
	return (rc == BadValue) ? SyncErrorBase + XSyncBadAlarm : rc;
d1762 1
a1762 1
    return client->noClientException;
d2086 1
a2086 1
    xfree(SysCounterList);
d2130 3
d2169 1
a2169 1
*** code inspired by multibuffer extension
@


1.4
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@d37 1
a37 1
supporting documentation, and that the names of Digital or Olivetti 
a52 2
#define NEED_REPLIES
#define NEED_EVENTS
a67 1
#ifdef HAVE_X11_EXTENSIONS_SYNCPROTO_H
a69 5
#else
#define _SYNC_SERVER
#include <X11/extensions/sync.h>
#include <X11/extensions/syncstr.h>
#endif
d97 1
a97 104
static int
FreeAlarm(
    pointer /* addr */,
    XID /* id */
);

static int
FreeAlarmClient(
    pointer /* value */,
    XID /* id */
);

static int
FreeAwait(
    pointer /* addr */,
    XID /* id */
);

static void
ServertimeBracketValues(
    pointer /* pCounter */,
    CARD64 * /* pbracket_less */,
    CARD64 * /* pbracket_greater */
);

static void
ServertimeQueryValue(
    pointer /* pCounter */,
    CARD64 * /* pValue_return */
);

static void
ServertimeWakeupHandler(
    pointer /* env */,
    int /* rc */,
    pointer /* LastSelectMask */
);

static int 
SyncInitTrigger(
    ClientPtr /* client */,
    SyncTrigger * /* pTrigger */,
    XSyncCounter /* counter */,
    Mask /* changes */
);

static void
SAlarmNotifyEvent(
    xSyncAlarmNotifyEvent * /* from */,
    xSyncAlarmNotifyEvent * /* to */
);

static void
SCounterNotifyEvent(
    xSyncCounterNotifyEvent * /* from */,
    xSyncCounterNotifyEvent * /* to */
);

static void
ServertimeBlockHandler(
    pointer  /* env */,
    struct timeval ** /* wt */,
    pointer  /* LastSelectMask */
);

static int
SyncAddTriggerToCounter(
    SyncTrigger * /* pTrigger */
);

extern void
SyncAlarmCounterDestroyed(
    SyncTrigger * /* pTrigger */
);

static void
SyncAlarmTriggerFired(
    SyncTrigger * /* pTrigger */
);

static void
SyncAwaitTriggerFired(
    SyncTrigger * /* pTrigger */
);

static int
SyncChangeAlarmAttributes(
    ClientPtr /* client */,
    SyncAlarm * /* pAlarm */,
    Mask /* mask */,
    CARD32 * /* values */
);

static Bool
SyncCheckTriggerNegativeComparison(
    SyncTrigger * /* pTrigger */,
    CARD64 /* oldval */
);

static Bool
SyncCheckTriggerNegativeTransition(
    SyncTrigger * /* pTrigger */,
    CARD64 /* oldval */
);
d99 1
a99 5
static Bool
SyncCheckTriggerPositiveComparison(
    SyncTrigger * /* pTrigger */,
    CARD64 /* oldval */
);
d101 1
a101 56
static Bool
SyncCheckTriggerPositiveTransition(
    SyncTrigger * /* pTrigger */,
    CARD64 /* oldval */
);

static SyncCounter *
SyncCreateCounter(
    ClientPtr /* client */,
    XSyncCounter /* id */,
    CARD64 /* initialvalue */
);

static void SyncComputeBracketValues(
    SyncCounter * /* pCounter */,
    Bool /* startOver */
);

static void
SyncDeleteTriggerFromCounter(
    SyncTrigger * /* pTrigger */
);

static Bool
SyncEventSelectForAlarm(
    SyncAlarm * /* pAlarm */,
    ClientPtr /* client */,
    Bool /* wantevents */
);

static void
SyncInitServerTime(
    void
);

static void
SyncInitIdleTime(
    void
);

static void 
SyncResetProc(
    ExtensionEntry * /* extEntry */
);

static void
SyncSendAlarmNotifyEvents(
    SyncAlarm * /* pAlarm */
);

static void
SyncSendCounterNotifyEvents(
    ClientPtr /* client */,
    SyncAwait ** /* ppAwait */,
    int /* num_events */
);
d139 1
a139 2
SyncDeleteTriggerFromCounter(pTrigger)
    SyncTrigger *pTrigger;
d160 1
a160 1
	    
d168 1
a168 1
    
d170 1
a170 1
	SyncComputeBracketValues(pTrigger->pCounter, /*startOver*/ TRUE);
d175 1
a175 2
SyncAddTriggerToCounter(pTrigger)
    SyncTrigger *pTrigger;
d189 1
a189 1
    if (!(pCur = (SyncTriggerList *)xalloc(sizeof(SyncTriggerList))))
d197 1
a197 1
	SyncComputeBracketValues(pTrigger->pCounter, /*startOver*/ TRUE);
d203 1
a203 1
/*  Below are four possible functions that can be plugged into 
d213 1
a213 1
 *  This is because the spec says that a trigger with a counter value 
d218 1
a218 3
SyncCheckTriggerPositiveComparison(pTrigger, oldval)
    SyncTrigger *pTrigger;
    CARD64	oldval;
d226 1
a226 3
SyncCheckTriggerNegativeComparison(pTrigger, oldval)
    SyncTrigger *pTrigger;
    CARD64	oldval;
d234 1
a234 3
SyncCheckTriggerPositiveTransition(pTrigger, oldval)
    SyncTrigger *pTrigger;
    CARD64	oldval;
d243 1
a243 3
SyncCheckTriggerNegativeTransition(pTrigger, oldval)
    SyncTrigger *pTrigger;
    CARD64	oldval;
d251 3
a253 8


static int 
SyncInitTrigger(client, pTrigger, counter, changes) 
    ClientPtr	     client;    /* so we can set errorValue */
    SyncTrigger      *pTrigger;
    XSyncCounter     counter; 
    Mask	     changes;
d309 1
a309 1
        case XSyncPositiveTransition: 
d312 1
a312 1
        case XSyncNegativeTransition: 
d315 1
a315 1
        case XSyncPositiveComparison: 
d318 1
a318 1
        case XSyncNegativeComparison: 
d334 1
a334 1
	    XSyncValueAdd(&pTrigger->test_value, pCounter->value, 
d354 1
a354 1
	SyncComputeBracketValues(pCounter, /*startOver*/ TRUE);
d356 1
a356 1
    
d361 1
a361 1
 *  the counter used by the alarm.  AlarmNotify may be sent to multiple 
d365 1
a365 2
SyncSendAlarmNotifyEvents(pAlarm)
    SyncAlarm *pAlarm;
d393 1
a393 1
    if (pAlarm->events && !pAlarm->client->clientGone) 
d408 1
a408 1
/*  CounterNotify events only occur in response to an Await.  The events 
d412 2
a413 4
SyncSendCounterNotifyEvents(client, ppAwait, num_events)
    ClientPtr client;
    SyncAwait **ppAwait;
    int num_events;
d420 2
a421 3
    pev = pEvents = (xSyncCounterNotifyEvent *)
		 xalloc(num_events * sizeof(xSyncCounterNotifyEvent));
    if (!pEvents) 
d448 2
a449 3
void
SyncAlarmCounterDestroyed(pTrigger)
    SyncTrigger *pTrigger;
d459 1
a459 1
/*  This function is called when an alarm "goes off."  
d463 1
a463 2
SyncAlarmTriggerFired(pTrigger)
    SyncTrigger *pTrigger;
d503 1
a503 1
	} while (!overflow && 
d538 1
a538 2
SyncAwaitTriggerFired(pTrigger)
    SyncTrigger *pTrigger;
d548 1
a548 1
    ppAwait = (SyncAwait **)xalloc(numwaits * sizeof(SyncAwait *));
d631 1
a631 3
SyncChangeCounter(pCounter, newval)
    SyncCounter    *pCounter;
    CARD64         newval;
d649 1
a649 1
	SyncComputeBracketValues(pCounter, /* startOver */ FALSE);
d656 1
a656 4
SyncEventSelectForAlarm(pAlarm, client, wantevents)
    SyncAlarm *pAlarm;
    ClientPtr client;
    Bool      wantevents;
d673 2
a674 2
	    /* client's presence on the list indicates desire for 
	     * events.  If the client doesn't want events, remove it 
d691 1
a691 1
	/* client doesn't want events, and we just discovered that it 
d698 1
a698 1
    pClients = (SyncAlarmClientList *) xalloc(sizeof(SyncAlarmClientList));
d702 1
a702 1
    /*  register it as a resource so it will be cleaned up 
d724 3
a726 6
static int 
SyncChangeAlarmAttributes(client, pAlarm, mask, values)
    ClientPtr       client;
    SyncAlarm      *pAlarm;
    Mask	    mask;
    CARD32	    *values;
d823 1
a823 4
SyncCreateCounter(client, id, initialvalue)
    ClientPtr	client;
    XSyncCounter id;
    CARD64      initialvalue;
d827 2
a828 2
    if (!(pCounter = (SyncCounter *) xalloc(sizeof(SyncCounter))))
	return (SyncCounter *)NULL;
d832 2
a833 2
	xfree((pointer) pCounter);
	return (SyncCounter *)NULL;
d845 1
a845 4
static int FreeCounter(
    pointer /*env*/,
    XID     /*id*/
);
d851 12
a862 14
pointer 
SyncCreateSystemCounter(name, initial, resolution, counterType,
			QueryValue, BracketValues)
    char           *name;
    CARD64          initial;
    CARD64          resolution;
    SyncCounterType counterType;
    void            (*QueryValue) (
        pointer /* pCounter */, 
        CARD64 * /* pValue_return */);
    void            (*BracketValues) (
        pointer /* pCounter */,
        CARD64 * /* pbracket_less */,
        CARD64 * /* pbracket_greater */);
d866 1
a866 1
    SysCounterList = (SyncCounter **)xrealloc(SysCounterList,
d869 1
a869 1
	return (pointer)NULL;
d876 1
a876 1
	RTCounter = CreateNewResourceType(FreeCounter);
d879 1
a879 1
	    return (pointer)NULL;
d883 1
a883 1
    pCounter = SyncCreateCounter((ClientPtr)NULL, FakeClientID(0), initial);
d889 1
a889 1
	psci = (SysCounterInfo *)xalloc(sizeof(SysCounterInfo));
d893 1
a893 1
	    return (pointer) pCounter;
d905 1
a905 1
    return (pointer) pCounter;
d909 1
a909 2
SyncDestroySystemCounter(pSysCounter)
    pointer pSysCounter;
d916 1
a916 3
SyncComputeBracketValues(pCounter, startOver)
    SyncCounter *pCounter;
    Bool startOver;
d933 2
a934 5
    if (startOver)
    {
	XSyncMaxValue(&psci->bracket_greater);
	XSyncMinValue(&psci->bracket_less);
    }
d996 1
a996 3
FreeAlarm(addr, id)
    pointer         addr;
    XID             id;
d1021 1
a1021 3
FreeCounter(env, id)
    pointer         env;
    XID             id;
d1071 1
a1071 3
FreeAwait(addr, id)
    pointer         addr;
    XID             id;
d1084 1
a1084 1
	/* If the counter is being destroyed, FreeCounter will delete 
d1097 1
a1097 3
FreeAlarmClient(value, id)
    pointer value; /* must conform to DeleteType */
    XID   id;
d1113 1
a1113 1
	    return(Success);
d1129 2
a1130 3
static int 
ProcSyncInitialize(client)
    ClientPtr       client;
d1137 1
d1149 1
a1149 1
    return (client->noClientException);
d1155 2
a1156 3
static int 
ProcSyncListSystemCounters(client)
    ClientPtr       client;
d1161 1
a1161 1
    
d1172 1
a1172 1
	len += (sz_xSyncSystemCounter + strlen(name) + 3) & ~3;
d1177 1
a1177 1
	walklist = list = (xSyncSystemCounter *) xalloc(len);
d1182 1
a1182 1
    rep.length = len >> 2;
d1215 2
a1216 2
	walklist = (xSyncSystemCounter *) (((char *)walklist) + 
				((sz_xSyncSystemCounter + namelen + 3) & ~3));
d1220 1
a1220 1
    if (len) 
d1226 1
a1226 1
    return (client->noClientException);
d1232 2
a1233 3
static int 
ProcSyncSetPriority(client)
    ClientPtr       client;
d1267 2
a1268 3
static int 
ProcSyncGetPriority(client)
    ClientPtr       client;
d1300 1
a1300 1
    return (client->noClientException);
d1306 2
a1307 3
static int 
ProcSyncCreateCounter(client)
    ClientPtr       client;
d1320 1
a1320 1
    return (client->noClientException);
d1326 2
a1327 3
static int 
ProcSyncSetCounter(client)
    ClientPtr       client;
d1332 1
d1336 4
a1339 7
    pCounter = (SyncCounter *)SecurityLookupIDByType(client, stuff->cid,
					   RTCounter, DixWriteAccess);
    if (pCounter == NULL)
    {
	client->errorValue = stuff->cid;
	return SyncErrorBase + XSyncBadCounter;
    }
d1355 2
a1356 3
static int 
ProcSyncChangeCounter(client)
    ClientPtr       client;
d1362 1
d1366 4
a1369 7
    pCounter = (SyncCounter *) SecurityLookupIDByType(client, stuff->cid,
					    RTCounter, DixWriteAccess);
    if (pCounter == NULL)
    {
	client->errorValue = stuff->cid;
	return SyncErrorBase + XSyncBadCounter;
    }
d1382 1
a1382 1
	client->errorValue = stuff->value_hi; 
d1392 2
a1393 3
static int 
ProcSyncDestroyCounter(client)
    ClientPtr       client;
d1397 1
d1401 5
a1405 7
    pCounter = (SyncCounter *)SecurityLookupIDByType(client, stuff->counter,
					   RTCounter, DixDestroyAccess);
    if (pCounter == NULL)
    {
	client->errorValue = stuff->counter;
	return SyncErrorBase + XSyncBadCounter;
    }
d1419 2
a1420 3
static int 
ProcSyncAwait(client)
    ClientPtr       client;
d1448 1
a1448 1
    /*  all the memory for the entire await list is allocated 
d1451 1
a1451 1
    pAwaitUnion = (SyncAwaitUnion *)xalloc((items+1) * sizeof(SyncAwaitUnion));
d1534 2
a1535 3
static int 
ProcSyncQueryCounter(client)
    ClientPtr       client;
d1540 1
d1544 4
a1547 7
    pCounter = (SyncCounter *)SecurityLookupIDByType(client, stuff->counter,
					    RTCounter, DixReadAccess);
    if (pCounter == NULL)
    {
	client->errorValue = stuff->counter;
	return SyncErrorBase + XSyncBadCounter;
    }
d1572 1
a1572 1
    return (client->noClientException);
d1579 2
a1580 3
static int 
ProcSyncCreateAlarm(client)
    ClientPtr       client;
d1593 1
a1593 1
    len = client->req_len - (sizeof(xSyncCreateAlarmReq) >> 2);
d1598 1
a1598 1
    if (!(pAlarm = (SyncAlarm *) xalloc(sizeof(SyncAlarm))))
d1658 2
a1659 3
static int 
ProcSyncChangeAlarm(client)
    ClientPtr       client;
d1668 4
a1671 6
    if (!(pAlarm = (SyncAlarm *)SecurityLookupIDByType(client, stuff->alarm,
					      RTAlarm, DixWriteAccess)))
    {
	client->errorValue = stuff->alarm;
	return SyncErrorBase + XSyncBadAlarm;
    }
d1674 1
a1674 1
    len = client->req_len - (sizeof(xSyncChangeAlarmReq) >> 2);
d1679 1
a1679 1
    if ((status = SyncChangeAlarmAttributes(client, pAlarm, vmask, 
d1696 2
a1697 3
static int 
ProcSyncQueryAlarm(client)
    ClientPtr       client;
d1703 1
d1707 4
a1710 7
    pAlarm = (SyncAlarm *)SecurityLookupIDByType(client, stuff->alarm,
						RTAlarm, DixReadAccess);
    if (!pAlarm)
    {
	client->errorValue = stuff->alarm;
	return (SyncErrorBase + XSyncBadAlarm);
    }
d1713 1
a1713 1
    rep.length = (sizeof(xSyncQueryAlarmReply) - sizeof(xGenericReply)) >> 2;
d1752 1
a1752 1
    return (client->noClientException);
d1755 2
a1756 4

static int 
ProcSyncDestroyAlarm(client)
    ClientPtr       client;
d1758 2
d1764 4
a1767 6
    if (!((SyncAlarm *)SecurityLookupIDByType(client, stuff->alarm,
					      RTAlarm, DixDestroyAccess)))
    {
	client->errorValue = stuff->alarm;
	return SyncErrorBase + XSyncBadAlarm;
    }
d1770 1
a1770 1
    return (client->noClientException);
d1776 2
a1777 3
static int 
ProcSyncDispatch(client)
    ClientPtr       client;
a1782 1

d1820 2
a1821 3
static int 
SProcSyncInitialize(client)
    ClientPtr       client;
d1832 2
a1833 3
static int 
SProcSyncListSystemCounters(client)
    ClientPtr       client;
d1844 2
a1845 3
static int 
SProcSyncCreateCounter(client)
    ClientPtr       client;
d1859 2
a1860 3
static int 
SProcSyncSetCounter(client)
    ClientPtr       client;
d1874 2
a1875 3
static int 
SProcSyncChangeCounter(client)
    ClientPtr       client;
d1889 2
a1890 3
static int 
SProcSyncQueryCounter(client)
    ClientPtr       client;
d1902 2
a1903 3
static int 
SProcSyncDestroyCounter(client)
    ClientPtr       client;
d1915 2
a1916 3
static int 
SProcSyncAwait(client)
    ClientPtr       client;
d1928 2
a1929 4

static int 
SProcSyncCreateAlarm(client)
    ClientPtr       client;
d1943 2
a1944 3
static int 
SProcSyncChangeAlarm(client)
    ClientPtr       client;
d1957 2
a1958 3
static int 
SProcSyncQueryAlarm(client)
    ClientPtr       client;
d1970 2
a1971 3
static int 
SProcSyncDestroyAlarm(client)
    ClientPtr       client;
d1983 2
a1984 3
static int 
SProcSyncSetPriority(client)
    ClientPtr       client;
d1997 2
a1998 3
static int 
SProcSyncGetPriority(client)
    ClientPtr       client;
d2011 2
a2012 3
static int 
SProcSyncDispatch(client)
    ClientPtr       client;
d2055 2
a2056 3
static void 
SCounterNotifyEvent(from, to)
    xSyncCounterNotifyEvent *from, *to;
d2072 2
a2073 3
static void 
SAlarmNotifyEvent(from, to)
    xSyncAlarmNotifyEvent *from, *to;
d2091 2
a2092 3
static void 
SyncResetProc(extEntry)
    ExtensionEntry *extEntry;
d2103 2
a2104 2
void 
SyncExtensionInit(INITARGS)
d2110 1
a2110 1
	RTCounter = CreateNewResourceType(FreeCounter);
d2112 7
a2118 3
    RTAlarm = CreateNewResourceType(FreeAlarm);
    RTAwait = CreateNewResourceType(FreeAwait)|RC_NEVERRETAIN;
    RTAlarmClient = CreateNewResourceType(FreeAlarmClient)|RC_NEVERRETAIN;
d2177 2
a2178 4
static void ServertimeBlockHandler(env, wt, LastSelectMask)
pointer env;
struct timeval **wt;
pointer LastSelectMask;
d2190 1
a2190 1
        } 
d2206 2
a2207 4
static void ServertimeWakeupHandler(env, rc, LastSelectMask)
pointer env;
int rc;
pointer LastSelectMask;
d2221 1
a2221 3
ServertimeQueryValue(pCounter, pValue_return)
    pointer pCounter;
    CARD64 *pValue_return;
d2228 2
a2229 4
ServertimeBracketValues(pCounter, pbracket_less, pbracket_greater)
    pointer pCounter;
    CARD64 *pbracket_less;
    CARD64 *pbracket_greater;
d2343 1
a2343 3
IdleTimeWakeupHandler (pointer env,
                       int rc,
                       pointer LastSelectMask)
d2362 1
a2362 2
IdleTimeBracketValues (pointer pCounter,
                       CARD64 *pbracket_less,
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d70 4
d77 1
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d75 1
a75 1
#if !defined(WIN32) && !defined(Lynx)
d443 1
a443 1
	else if (Success != (rc = dixLookupResource((pointer *)&pCounter,
d1171 1
a1171 1
	else if ( (pTrigger->test_type == XSyncPositiveTransition &&
d1173 9
a1181 2
		 ||
		 (pTrigger->test_type == XSyncNegativeTransition &&
a1182 1
		 )
d1184 2
a1185 1
	    if (XSyncValueLessThan(pCounter->value, pTrigger->test_value))
d1187 2
a1188 13
		if (XSyncValueLessThan(pTrigger->test_value,
				       psci->bracket_greater))
		{
		    psci->bracket_greater = pTrigger->test_value;
		    pnewgtval = &psci->bracket_greater;
		}
		else
		if (XSyncValueGreaterThan(pTrigger->test_value,
					  psci->bracket_less))
		{
		    psci->bracket_less = pTrigger->test_value;
		    pnewltval = &psci->bracket_less;
		}
d1404 1
a1404 1
	register char n;
d1424 1
a1424 1
	    register char n;
d1513 1
a1513 1
	register char n;
d1798 1
a1798 1
	register char n;
d1980 1
a1980 1
	register char n;
d2069 1
a2069 1
    register char   n;
d2082 1
a2082 1
    register char   n;
d2095 1
a2095 1
    register char   n;
d2111 1
a2111 1
    register char   n;
d2127 1
a2127 1
    register char   n;
d2143 1
a2143 1
    register char   n;
d2157 1
a2157 1
    register char   n;
d2171 1
a2171 1
    register char   n;
d2186 1
a2186 1
    register char   n;
d2202 1
a2202 1
    register char   n;
d2217 1
a2217 1
    register char   n;
d2231 1
a2231 1
    register char   n;
d2245 1
a2245 1
    register char   n;
d2260 1
a2260 1
    register char   n;
d2532 1
a2532 1
static pointer IdleTimeCounter;
d2544 1
a2544 3
IdleTimeBlockHandler (pointer env,
                      struct timeval **wt,
                      pointer LastSelectMask)
d2546 3
a2548 1
    XSyncValue idle;
d2553 1
d2555 1
d2560 15
a2574 1
	AdjustWaitForDelay (wt, 0);
d2578 7
a2584 1
	unsigned long timeout = 0;
d2586 1
a2586 2
	if (XSyncValueLessThan (idle, *pIdleTimeValueGreater))
	{
d2592 9
a2600 1
	    timeout = XSyncValueLow32 (value);
d2605 2
@


1.1
log
@Initial revision
@
text
@d246 5
d436 1
a436 1
    int		status;
d443 2
a444 2
	else if (!(pCounter = (SyncCounter *)SecurityLookupIDByType(
			client, counter, RTCounter, SecurityReadAccess)))
d447 1
a447 1
	    return SyncErrorBase + XSyncBadCounter;
d529 2
a530 2
	if ((status = SyncAddTriggerToCounter(pTrigger)) != Success)
	    return status;
d604 1
a604 1
		 ALLOCATE_LOCAL(num_events * sizeof(xSyncCounterNotifyEvent));
d625 1
a625 1
    DEALLOCATE_LOCAL(pEvents);
d735 1
a735 1
    ppAwait = (SyncAwait **)ALLOCATE_LOCAL(numwaits * sizeof(SyncAwait *));
d804 1
a804 1
    DEALLOCATE_LOCAL(ppAwait);
d1399 1
a1399 1
	walklist = list = (xSyncSystemCounter *) ALLOCATE_LOCAL(len);
d1445 1
a1445 1
	DEALLOCATE_LOCAL(list);
d1460 1
d1466 5
a1470 4
    else if (!(priorityclient = LookupClient(stuff->id, client)))
    {
	client->errorValue = stuff->id;
	return BadMatch;
d1497 1
d1503 5
a1507 4
    else if (!(priorityclient = LookupClient(stuff->id, client)))
    {
	client->errorValue = stuff->id;
	return BadMatch;
d1562 1
a1562 1
					   RTCounter, SecurityWriteAccess);
d1595 1
a1595 1
					    RTCounter, SecurityWriteAccess);
d1633 1
a1633 1
					   RTCounter, SecurityDestroyAccess);
d1779 1
a1779 1
					    RTCounter, SecurityReadAccess);
d1908 1
a1908 1
					      RTAlarm, SecurityWriteAccess)))
d1949 1
a1949 1
						RTAlarm, SecurityReadAccess);
d2009 1
a2009 1
					      RTAlarm, SecurityDestroyAccess)))
d2408 1
d2518 1
a2518 1
SyncInitServerTime()
d2528 114
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a245 5
static void
SyncInitIdleTime(
    void
);

d439 1
a439 1
			client, counter, RTCounter, DixReadAccess)))
a1454 1
    int rc;
d1460 4
a1463 5
    else {
	rc = dixLookupClient(&priorityclient, stuff->id, client,
			     DixUnknownAccess);
	if (rc != Success)
	    return rc;
a1489 1
    int rc;
d1495 4
a1498 5
    else {
	rc = dixLookupClient(&priorityclient, stuff->id, client,
			     DixUnknownAccess);
	if (rc != Success)
	    return rc;
d1553 1
a1553 1
					   RTCounter, DixWriteAccess);
d1586 1
a1586 1
					    RTCounter, DixWriteAccess);
d1624 1
a1624 1
					   RTCounter, DixDestroyAccess);
d1770 1
a1770 1
					    RTCounter, DixReadAccess);
d1899 1
a1899 1
					      RTAlarm, DixWriteAccess)))
d1940 1
a1940 1
						RTAlarm, DixReadAccess);
d2000 1
a2000 1
					      RTAlarm, DixDestroyAccess)))
a2398 1
    SyncInitIdleTime();
d2508 1
a2508 1
SyncInitServerTime(void)
a2517 114
}



/*
 * IDLETIME implementation
 */

static pointer IdleTimeCounter;
static XSyncValue *pIdleTimeValueLess;
static XSyncValue *pIdleTimeValueGreater;

static void
IdleTimeQueryValue (pointer pCounter, CARD64 *pValue_return)
{
    CARD32 idle = GetTimeInMillis() - lastDeviceEventTime.milliseconds;
    XSyncIntsToValue (pValue_return, idle, 0);
}

static void
IdleTimeBlockHandler (pointer env,
                      struct timeval **wt,
                      pointer LastSelectMask)
{
    XSyncValue idle;

    if (!pIdleTimeValueLess && !pIdleTimeValueGreater)
	return;

    IdleTimeQueryValue (NULL, &idle);

    if (pIdleTimeValueLess &&
        XSyncValueLessOrEqual (idle, *pIdleTimeValueLess))
    {
	AdjustWaitForDelay (wt, 0);
    }
    else if (pIdleTimeValueGreater)
    {
	unsigned long timeout = 0;

	if (XSyncValueLessThan (idle, *pIdleTimeValueGreater))
	{
	    XSyncValue value;
	    Bool overflow;

	    XSyncValueSubtract (&value, *pIdleTimeValueGreater,
	                        idle, &overflow);
	    timeout = XSyncValueLow32 (value);
	}

	AdjustWaitForDelay (wt, timeout);
    }
}

static void
IdleTimeWakeupHandler (pointer env,
                       int rc,
                       pointer LastSelectMask)
{
    XSyncValue idle;

    if (!pIdleTimeValueLess && !pIdleTimeValueGreater)
	return;

    IdleTimeQueryValue (NULL, &idle);

    if ((pIdleTimeValueGreater &&
         XSyncValueGreaterOrEqual (idle, *pIdleTimeValueGreater)) ||
        (pIdleTimeValueLess &&
	 XSyncValueLessOrEqual (idle, *pIdleTimeValueLess)))
    {
	SyncChangeCounter (IdleTimeCounter, idle);
    }
}

static void
IdleTimeBracketValues (pointer pCounter,
                       CARD64 *pbracket_less,
                       CARD64 *pbracket_greater)
{
    Bool registered = (pIdleTimeValueLess || pIdleTimeValueGreater);

    if (registered && !pbracket_less && !pbracket_greater)
    {
	RemoveBlockAndWakeupHandlers(IdleTimeBlockHandler,
	                             IdleTimeWakeupHandler,
	                             NULL);
    }
    else if (!registered && (pbracket_less || pbracket_greater))
    {
	RegisterBlockAndWakeupHandlers(IdleTimeBlockHandler,
	                               IdleTimeWakeupHandler,
	                               NULL);
    }

    pIdleTimeValueGreater = pbracket_greater;
    pIdleTimeValueLess    = pbracket_less;
}

static void
SyncInitIdleTime (void)
{
    CARD64 resolution;
    XSyncValue idle;

    IdleTimeQueryValue (NULL, &idle);
    XSyncIntToValue (&resolution, 4);

    IdleTimeCounter = SyncCreateSystemCounter ("IDLETIME", idle, resolution,
                                               XSyncCounterUnrestricted,
                                               IdleTimeQueryValue,
                                               IdleTimeBracketValues);

    pIdleTimeValueLess = pIdleTimeValueGreater = NULL;
@

