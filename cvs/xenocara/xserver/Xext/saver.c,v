head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.4
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.2
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.2
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.08.09.18.59.50;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	6HLO5qdN5N4nPDjW;

1.15
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	s0SI41sEunLdyFfd;

1.14
date	2015.09.16.19.10.20;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	Te1daavkBLskZ8gc;

1.13
date	2014.09.27.17.52.59;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	cVXoV5PxI8YrEaVA;

1.12
date	2013.12.08.10.53.01;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2013.09.28.15.36.32;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2011.12.18.16.08.59;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.46;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.48;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.48;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.59;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to xserver 1.18.4

tested by krw@@ and dcoppa@@ ok dcoppa@@
@
text
@/*
 *
Copyright (c) 1992  X Consortium

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the X Consortium shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from the X Consortium.
 *
 * Author:  Keith Packard, MIT X Consortium
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "extnsionst.h"
#include "dixstruct.h"
#include "resource.h"
#include "opaque.h"
#include <X11/extensions/saverproto.h>
#include "gcstruct.h"
#include "cursorstr.h"
#include "colormapst.h"
#include "xace.h"
#include "inputstr.h"
#ifdef PANORAMIX
#include "panoramiX.h"
#include "panoramiXsrv.h"
#endif
#ifdef DPMSExtension
#include <X11/extensions/dpmsconst.h>
#endif
#include "protocol-versions.h"

#include <stdio.h>

#include "extinit.h"

static int ScreenSaverEventBase = 0;

static Bool ScreenSaverHandle(ScreenPtr /* pScreen */ ,
                              int /* xstate */ ,
                              Bool      /* force */
    );

static Bool
 CreateSaverWindow(ScreenPtr    /* pScreen */
    );

static Bool
 DestroySaverWindow(ScreenPtr   /* pScreen */
    );

static void
 UninstallSaverColormap(ScreenPtr       /* pScreen */
    );

static void
 CheckScreenPrivate(ScreenPtr   /* pScreen */
    );

static void SScreenSaverNotifyEvent(xScreenSaverNotifyEvent * /* from */ ,
                                    xScreenSaverNotifyEvent *   /* to */
    );

static RESTYPE SuspendType;     /* resource type for suspension records */

typedef struct _ScreenSaverSuspension *ScreenSaverSuspensionPtr;

/* List of clients that are suspending the screensaver. */
static ScreenSaverSuspensionPtr suspendingClients = NULL;

/*
 * clientResource is a resource ID that's added when the record is
 * allocated, so the record is freed and the screensaver resumed when
 * the client disconnects. count is the number of times the client has
 * requested the screensaver be suspended.
 */
typedef struct _ScreenSaverSuspension {
    ScreenSaverSuspensionPtr next;
    ClientPtr pClient;
    XID clientResource;
    int count;
} ScreenSaverSuspensionRec;

static int ScreenSaverFreeSuspend(void *value, XID id);

/*
 * each screen has a list of clients requesting
 * ScreenSaverNotify events.  Each client has a resource
 * for each screen it selects ScreenSaverNotify input for,
 * this resource is used to delete the ScreenSaverNotifyRec
 * entry from the per-screen queue.
 */

static RESTYPE SaverEventType;  /* resource type for event masks */

typedef struct _ScreenSaverEvent *ScreenSaverEventPtr;

typedef struct _ScreenSaverEvent {
    ScreenSaverEventPtr next;
    ClientPtr client;
    ScreenPtr screen;
    XID resource;
    CARD32 mask;
} ScreenSaverEventRec;

static int ScreenSaverFreeEvents(void * value, XID id);

static Bool setEventMask(ScreenPtr      pScreen,
                         ClientPtr      client,
                         unsigned long  mask);

static unsigned long getEventMask(ScreenPtr     pScreen,
                                  ClientPtr     client);

/*
 * when a client sets the screen saver attributes, a resource is
 * kept to be freed when the client exits
 */

static RESTYPE AttrType;        /* resource type for attributes */

typedef struct _ScreenSaverAttr {
    ScreenPtr screen;
    ClientPtr client;
    XID resource;
    short x, y;
    unsigned short width, height, borderWidth;
    unsigned char class;
    unsigned char depth;
    VisualID visual;
    CursorPtr pCursor;
    PixmapPtr pBackgroundPixmap;
    PixmapPtr pBorderPixmap;
    Colormap colormap;
    unsigned long mask;         /* no pixmaps or cursors */
    unsigned long *values;
} ScreenSaverAttrRec, *ScreenSaverAttrPtr;

static int ScreenSaverFreeAttr(void *value, XID id);

static void FreeAttrs(ScreenSaverAttrPtr pAttr);

static void FreeScreenAttr(ScreenSaverAttrPtr pAttr);

static void
SendScreenSaverNotify(ScreenPtr pScreen,
                      int       state,
                      Bool      forced);

typedef struct _ScreenSaverScreenPrivate {
    ScreenSaverEventPtr events;
    ScreenSaverAttrPtr attr;
    Bool hasWindow;
    Colormap installedMap;
} ScreenSaverScreenPrivateRec, *ScreenSaverScreenPrivatePtr;

static ScreenSaverScreenPrivatePtr MakeScreenPrivate(ScreenPtr pScreen);

static DevPrivateKeyRec ScreenPrivateKeyRec;

#define ScreenPrivateKey (&ScreenPrivateKeyRec)

#define GetScreenPrivate(s) ((ScreenSaverScreenPrivatePtr) \
    dixLookupPrivate(&(s)->devPrivates, ScreenPrivateKey))
#define SetScreenPrivate(s,v) \
    dixSetPrivate(&(s)->devPrivates, ScreenPrivateKey, v);
#define SetupScreen(s)	ScreenSaverScreenPrivatePtr pPriv = (s ? GetScreenPrivate(s) : NULL)

#define New(t)	(malloc(sizeof (t)))

static void
CheckScreenPrivate(ScreenPtr pScreen)
{
    SetupScreen(pScreen);

    if (!pPriv)
        return;
    if (!pPriv->attr && !pPriv->events &&
        !pPriv->hasWindow && pPriv->installedMap == None) {
        free(pPriv);
        SetScreenPrivate(pScreen, NULL);
        pScreen->screensaver.ExternalScreenSaver = NULL;
    }
}

static ScreenSaverScreenPrivatePtr
MakeScreenPrivate(ScreenPtr pScreen)
{
    SetupScreen(pScreen);

    if (pPriv)
        return pPriv;
    pPriv = New(ScreenSaverScreenPrivateRec);
    if (!pPriv)
        return 0;
    pPriv->events = 0;
    pPriv->attr = 0;
    pPriv->hasWindow = FALSE;
    pPriv->installedMap = None;
    SetScreenPrivate(pScreen, pPriv);
    pScreen->screensaver.ExternalScreenSaver = ScreenSaverHandle;
    return pPriv;
}

static unsigned long
getEventMask(ScreenPtr pScreen, ClientPtr client)
{
    SetupScreen(pScreen);
    ScreenSaverEventPtr pEv;

    if (!pPriv)
        return 0;
    for (pEv = pPriv->events; pEv; pEv = pEv->next)
        if (pEv->client == client)
            return pEv->mask;
    return 0;
}

static Bool
setEventMask(ScreenPtr pScreen, ClientPtr client, unsigned long mask)
{
    SetupScreen(pScreen);
    ScreenSaverEventPtr pEv, *pPrev;

    if (getEventMask(pScreen, client) == mask)
        return TRUE;
    if (!pPriv) {
        pPriv = MakeScreenPrivate(pScreen);
        if (!pPriv)
            return FALSE;
    }
    for (pPrev = &pPriv->events; (pEv = *pPrev) != 0; pPrev = &pEv->next)
        if (pEv->client == client)
            break;
    if (mask == 0) {
        FreeResource(pEv->resource, SaverEventType);
        *pPrev = pEv->next;
        free(pEv);
        CheckScreenPrivate(pScreen);
    }
    else {
        if (!pEv) {
            pEv = New(ScreenSaverEventRec);
            if (!pEv) {
                CheckScreenPrivate(pScreen);
                return FALSE;
            }
            *pPrev = pEv;
            pEv->next = NULL;
            pEv->client = client;
            pEv->screen = pScreen;
            pEv->resource = FakeClientID(client->index);
            if (!AddResource(pEv->resource, SaverEventType, (void *) pEv))
                return FALSE;
        }
        pEv->mask = mask;
    }
    return TRUE;
}

static void
FreeAttrs(ScreenSaverAttrPtr pAttr)
{
    PixmapPtr pPixmap;
    CursorPtr pCursor;

    if ((pPixmap = pAttr->pBackgroundPixmap) != 0)
        (*pPixmap->drawable.pScreen->DestroyPixmap) (pPixmap);
    if ((pPixmap = pAttr->pBorderPixmap) != 0)
        (*pPixmap->drawable.pScreen->DestroyPixmap) (pPixmap);
    if ((pCursor = pAttr->pCursor) != 0)
        FreeCursor(pCursor, (Cursor) 0);
}

static void
FreeScreenAttr(ScreenSaverAttrPtr pAttr)
{
    FreeAttrs(pAttr);
    free(pAttr->values);
    free(pAttr);
}

static int
ScreenSaverFreeEvents(void *value, XID id)
{
    ScreenSaverEventPtr pOld = (ScreenSaverEventPtr) value;
    ScreenPtr pScreen = pOld->screen;

    SetupScreen(pScreen);
    ScreenSaverEventPtr pEv, *pPrev;

    if (!pPriv)
        return TRUE;
    for (pPrev = &pPriv->events; (pEv = *pPrev) != 0; pPrev = &pEv->next)
        if (pEv == pOld)
            break;
    if (!pEv)
        return TRUE;
    *pPrev = pEv->next;
    free(pEv);
    CheckScreenPrivate(pScreen);
    return TRUE;
}

static int
ScreenSaverFreeAttr(void *value, XID id)
{
    ScreenSaverAttrPtr pOldAttr = (ScreenSaverAttrPtr) value;
    ScreenPtr pScreen = pOldAttr->screen;

    SetupScreen(pScreen);

    if (!pPriv)
        return TRUE;
    if (pPriv->attr != pOldAttr)
        return TRUE;
    FreeScreenAttr(pOldAttr);
    pPriv->attr = NULL;
    if (pPriv->hasWindow) {
        dixSaveScreens(serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);
        dixSaveScreens(serverClient, SCREEN_SAVER_FORCER, ScreenSaverActive);
    }
    CheckScreenPrivate(pScreen);
    return TRUE;
}

static int
ScreenSaverFreeSuspend(void *value, XID id)
{
    ScreenSaverSuspensionPtr data = (ScreenSaverSuspensionPtr) value;
    ScreenSaverSuspensionPtr *prev, this;

    /* Unlink and free the suspension record for the client */
    for (prev = &suspendingClients; (this = *prev); prev = &this->next) {
        if (this == data) {
            *prev = this->next;
            free(this);
            break;
        }
    }

    /* Reenable the screensaver if this was the last client suspending it. */
    if (screenSaverSuspended && suspendingClients == NULL) {
        screenSaverSuspended = FALSE;

        /* The screensaver could be active, since suspending it (by design)
           doesn't prevent it from being forceably activated */
#ifdef DPMSExtension
        if (screenIsSaved != SCREEN_SAVER_ON && DPMSPowerLevel == DPMSModeOn)
#else
        if (screenIsSaved != SCREEN_SAVER_ON)
#endif
        {
            DeviceIntPtr dev;
            UpdateCurrentTimeIf();
            nt_list_for_each_entry(dev, inputInfo.devices, next)
                NoticeTime(dev, currentTime);
            SetScreenSaverTimer();
        }
    }

    return Success;
}

static void
SendScreenSaverNotify(ScreenPtr pScreen, int state, Bool forced)
{
    ScreenSaverScreenPrivatePtr pPriv;
    ScreenSaverEventPtr pEv;
    unsigned long mask;
    int kind;

    UpdateCurrentTimeIf();
    mask = ScreenSaverNotifyMask;
    if (state == ScreenSaverCycle)
        mask = ScreenSaverCycleMask;
    pScreen = screenInfo.screens[pScreen->myNum];
    pPriv = GetScreenPrivate(pScreen);
    if (!pPriv)
        return;
    if (pPriv->attr)
        kind = ScreenSaverExternal;
    else if (ScreenSaverBlanking != DontPreferBlanking)
        kind = ScreenSaverBlanked;
    else
        kind = ScreenSaverInternal;
    for (pEv = pPriv->events; pEv; pEv = pEv->next) {
        if (pEv->mask & mask) {
            xScreenSaverNotifyEvent ev = {
                .type = ScreenSaverNotify + ScreenSaverEventBase,
                .state = state,
                .timestamp = currentTime.milliseconds,
                .root = pScreen->root->drawable.id,
                .window = pScreen->screensaver.wid,
                .kind = kind,
                .forced = forced
            };
            WriteEventsToClient(pEv->client, 1, (xEvent *) &ev);
        }
    }
}

static void
SScreenSaverNotifyEvent(xScreenSaverNotifyEvent * from,
                        xScreenSaverNotifyEvent * to)
{
    to->type = from->type;
    to->state = from->state;
    cpswaps(from->sequenceNumber, to->sequenceNumber);
    cpswapl(from->timestamp, to->timestamp);
    cpswapl(from->root, to->root);
    cpswapl(from->window, to->window);
    to->kind = from->kind;
    to->forced = from->forced;
}

static void
UninstallSaverColormap(ScreenPtr pScreen)
{
    SetupScreen(pScreen);
    ColormapPtr pCmap;
    int rc;

    if (pPriv && pPriv->installedMap != None) {
        rc = dixLookupResourceByType((void **) &pCmap, pPriv->installedMap,
                                     RT_COLORMAP, serverClient,
                                     DixUninstallAccess);
        if (rc == Success)
            (*pCmap->pScreen->UninstallColormap) (pCmap);
        pPriv->installedMap = None;
        CheckScreenPrivate(pScreen);
    }
}

static Bool
CreateSaverWindow(ScreenPtr pScreen)
{
    SetupScreen(pScreen);
    ScreenSaverStuffPtr pSaver;
    ScreenSaverAttrPtr pAttr;
    WindowPtr pWin;
    int result;
    unsigned long mask;
    Colormap wantMap;
    ColormapPtr pCmap;

    pSaver = &pScreen->screensaver;
    if (pSaver->pWindow) {
        pSaver->pWindow = NullWindow;
        FreeResource(pSaver->wid, RT_NONE);
        if (pPriv) {
            UninstallSaverColormap(pScreen);
            pPriv->hasWindow = FALSE;
            CheckScreenPrivate(pScreen);
        }
    }

    if (!pPriv || !(pAttr = pPriv->attr))
        return FALSE;

    pPriv->installedMap = None;

    if (GrabInProgress && GrabInProgress != pAttr->client->index)
        return FALSE;

    pWin = CreateWindow(pSaver->wid, pScreen->root,
                        pAttr->x, pAttr->y, pAttr->width, pAttr->height,
                        pAttr->borderWidth, pAttr->class,
                        pAttr->mask, (XID *) pAttr->values,
                        pAttr->depth, serverClient, pAttr->visual, &result);
    if (!pWin)
        return FALSE;

    if (!AddResource(pWin->drawable.id, RT_WINDOW, pWin))
        return FALSE;

    mask = 0;
    if (pAttr->pBackgroundPixmap) {
        pWin->backgroundState = BackgroundPixmap;
        pWin->background.pixmap = pAttr->pBackgroundPixmap;
        pAttr->pBackgroundPixmap->refcnt++;
        mask |= CWBackPixmap;
    }
    if (pAttr->pBorderPixmap) {
        pWin->borderIsPixel = FALSE;
        pWin->border.pixmap = pAttr->pBorderPixmap;
        pAttr->pBorderPixmap->refcnt++;
        mask |= CWBorderPixmap;
    }
    if (pAttr->pCursor) {
        CursorPtr cursor;
        if (!pWin->optional)
            if (!MakeWindowOptional(pWin)) {
                FreeResource(pWin->drawable.id, RT_NONE);
                return FALSE;
            }
        cursor = RefCursor(pAttr->pCursor);
        if (pWin->optional->cursor)
            FreeCursor(pWin->optional->cursor, (Cursor) 0);
        pWin->optional->cursor = cursor;
        pWin->cursorIsNone = FALSE;
        CheckWindowOptionalNeed(pWin);
        mask |= CWCursor;
    }
    if (mask)
        (*pScreen->ChangeWindowAttributes) (pWin, mask);

    if (pAttr->colormap != None)
        (void) ChangeWindowAttributes(pWin, CWColormap, &pAttr->colormap,
                                      serverClient);

    MapWindow(pWin, serverClient);

    pPriv->hasWindow = TRUE;
    pSaver->pWindow = pWin;

    /* check and install our own colormap if it isn't installed now */
    wantMap = wColormap(pWin);
    if (wantMap == None || IsMapInstalled(wantMap, pWin))
        return TRUE;

    result = dixLookupResourceByType((void **) &pCmap, wantMap, RT_COLORMAP,
                                     serverClient, DixInstallAccess);
    if (result != Success)
        return TRUE;

    pPriv->installedMap = wantMap;

    (*pCmap->pScreen->InstallColormap) (pCmap);

    return TRUE;
}

static Bool
DestroySaverWindow(ScreenPtr pScreen)
{
    SetupScreen(pScreen);
    ScreenSaverStuffPtr pSaver;

    if (!pPriv || !pPriv->hasWindow)
        return FALSE;

    pSaver = &pScreen->screensaver;
    if (pSaver->pWindow) {
        pSaver->pWindow = NullWindow;
        FreeResource(pSaver->wid, RT_NONE);
    }
    pPriv->hasWindow = FALSE;
    CheckScreenPrivate(pScreen);
    UninstallSaverColormap(pScreen);
    return TRUE;
}

static Bool
ScreenSaverHandle(ScreenPtr pScreen, int xstate, Bool force)
{
    int state = 0;
    Bool ret = FALSE;
    ScreenSaverScreenPrivatePtr pPriv;

    switch (xstate) {
    case SCREEN_SAVER_ON:
        state = ScreenSaverOn;
        ret = CreateSaverWindow(pScreen);
        break;
    case SCREEN_SAVER_OFF:
        state = ScreenSaverOff;
        ret = DestroySaverWindow(pScreen);
        break;
    case SCREEN_SAVER_CYCLE:
        state = ScreenSaverCycle;
        pPriv = GetScreenPrivate(pScreen);
        if (pPriv && pPriv->hasWindow)
            ret = TRUE;

    }
#ifdef PANORAMIX
    if (noPanoramiXExtension || !pScreen->myNum)
#endif
        SendScreenSaverNotify(pScreen, state, force);
    return ret;
}

static int
ProcScreenSaverQueryVersion(ClientPtr client)
{
    xScreenSaverQueryVersionReply rep = {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = SERVER_SAVER_MAJOR_VERSION,
        .minorVersion = SERVER_SAVER_MINOR_VERSION
    };

    REQUEST_SIZE_MATCH(xScreenSaverQueryVersionReq);

    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
    }
    WriteToClient(client, sizeof(xScreenSaverQueryVersionReply), &rep);
    return Success;
}

static int
ProcScreenSaverQueryInfo(ClientPtr client)
{
    REQUEST(xScreenSaverQueryInfoReq);
    xScreenSaverQueryInfoReply rep;
    int rc;
    ScreenSaverStuffPtr pSaver;
    DrawablePtr pDraw;
    CARD32 lastInput;
    ScreenSaverScreenPrivatePtr pPriv;

    REQUEST_SIZE_MATCH(xScreenSaverQueryInfoReq);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
                           DixGetAttrAccess);
    if (rc != Success)
        return rc;
    rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, pDraw->pScreen,
                  DixGetAttrAccess);
    if (rc != Success)
        return rc;

    pSaver = &pDraw->pScreen->screensaver;
    pPriv = GetScreenPrivate(pDraw->pScreen);

    UpdateCurrentTime();
    lastInput = GetTimeInMillis() - LastEventTime(XIAllDevices).milliseconds;

    rep = (xScreenSaverQueryInfoReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .window = pSaver->wid
    };
    if (screenIsSaved != SCREEN_SAVER_OFF) {
        rep.state = ScreenSaverOn;
        if (ScreenSaverTime)
            rep.tilOrSince = lastInput - ScreenSaverTime;
        else
            rep.tilOrSince = 0;
    }
    else {
        if (ScreenSaverTime) {
            rep.state = ScreenSaverOff;
            if (ScreenSaverTime < lastInput)
                rep.tilOrSince = 0;
            else
                rep.tilOrSince = ScreenSaverTime - lastInput;
        }
        else {
            rep.state = ScreenSaverDisabled;
            rep.tilOrSince = 0;
        }
    }
    rep.idle = lastInput;
    rep.eventMask = getEventMask(pDraw->pScreen, client);
    if (pPriv && pPriv->attr)
        rep.kind = ScreenSaverExternal;
    else if (ScreenSaverBlanking != DontPreferBlanking)
        rep.kind = ScreenSaverBlanked;
    else
        rep.kind = ScreenSaverInternal;
    if (client->swapped) {
        swaps(&rep.sequenceNumber);
        swapl(&rep.length);
        swapl(&rep.window);
        swapl(&rep.tilOrSince);
        swapl(&rep.idle);
        swapl(&rep.eventMask);
    }
    WriteToClient(client, sizeof(xScreenSaverQueryInfoReply), &rep);
    return Success;
}

static int
ProcScreenSaverSelectInput(ClientPtr client)
{
    REQUEST(xScreenSaverSelectInputReq);
    DrawablePtr pDraw;
    int rc;

    REQUEST_SIZE_MATCH(xScreenSaverSelectInputReq);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
                           DixGetAttrAccess);
    if (rc != Success)
        return rc;

    rc = XaceHook(XACE_SCREENSAVER_ACCESS, client, pDraw->pScreen,
                  DixSetAttrAccess);
    if (rc != Success)
        return rc;

    if (!setEventMask(pDraw->pScreen, client, stuff->eventMask))
        return BadAlloc;
    return Success;
}

static int
ScreenSaverSetAttributes(ClientPtr client)
{
    REQUEST(xScreenSaverSetAttributesReq);
    DrawablePtr pDraw;
    WindowPtr pParent;
    ScreenPtr pScreen;
    ScreenSaverScreenPrivatePtr pPriv = 0;
    ScreenSaverAttrPtr pAttr = 0;
    int ret, len, class, bw, depth;
    unsigned long visual;
    int idepth, ivisual;
    Bool fOK;
    DepthPtr pDepth;
    WindowOptPtr ancwopt;
    unsigned int *pVlist;
    unsigned long *values = 0;
    unsigned long tmask, imask;
    unsigned long val;
    Pixmap pixID;
    PixmapPtr pPixmap;
    Cursor cursorID;
    CursorPtr pCursor;
    Colormap cmap;
    ColormapPtr pCmap;

    REQUEST_AT_LEAST_SIZE(xScreenSaverSetAttributesReq);
    ret = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
                            DixGetAttrAccess);
    if (ret != Success)
        return ret;
    pScreen = pDraw->pScreen;
    pParent = pScreen->root;

    ret = XaceHook(XACE_SCREENSAVER_ACCESS, client, pScreen, DixSetAttrAccess);
    if (ret != Success)
        return ret;

    len = stuff->length - bytes_to_int32(sizeof(xScreenSaverSetAttributesReq));
    if (Ones(stuff->mask) != len)
        return BadLength;
    if (!stuff->width || !stuff->height) {
        client->errorValue = 0;
        return BadValue;
    }
    switch (class = stuff->c_class) {
    case CopyFromParent:
    case InputOnly:
    case InputOutput:
        break;
    default:
        client->errorValue = class;
        return BadValue;
    }
    bw = stuff->borderWidth;
    depth = stuff->depth;
    visual = stuff->visualID;

    /* copied directly from CreateWindow */

    if (class == CopyFromParent)
        class = pParent->drawable.class;

    if ((class != InputOutput) && (class != InputOnly)) {
        client->errorValue = class;
        return BadValue;
    }

    if ((class != InputOnly) && (pParent->drawable.class == InputOnly))
        return BadMatch;

    if ((class == InputOnly) && ((bw != 0) || (depth != 0)))
        return BadMatch;

    if ((class == InputOutput) && (depth == 0))
        depth = pParent->drawable.depth;
    ancwopt = pParent->optional;
    if (!ancwopt)
        ancwopt = FindWindowWithOptional(pParent)->optional;
    if (visual == CopyFromParent)
        visual = ancwopt->visual;

    /* Find out if the depth and visual are acceptable for this Screen */
    if ((visual != ancwopt->visual) || (depth != pParent->drawable.depth)) {
        fOK = FALSE;
        for (idepth = 0; idepth < pScreen->numDepths; idepth++) {
            pDepth = (DepthPtr) &pScreen->allowedDepths[idepth];
            if ((depth == pDepth->depth) || (depth == 0)) {
                for (ivisual = 0; ivisual < pDepth->numVids; ivisual++) {
                    if (visual == pDepth->vids[ivisual]) {
                        fOK = TRUE;
                        break;
                    }
                }
            }
        }
        if (fOK == FALSE)
            return BadMatch;
    }

    if (((stuff->mask & (CWBorderPixmap | CWBorderPixel)) == 0) &&
        (class != InputOnly) && (depth != pParent->drawable.depth)) {
        return BadMatch;
    }

    if (((stuff->mask & CWColormap) == 0) &&
        (class != InputOnly) &&
        ((visual != ancwopt->visual) || (ancwopt->colormap == None))) {
        return BadMatch;
    }

    /* end of errors from CreateWindow */

    pPriv = GetScreenPrivate(pScreen);
    if (pPriv && pPriv->attr) {
        if (pPriv->attr->client != client)
            return BadAccess;
    }
    if (!pPriv) {
        pPriv = MakeScreenPrivate(pScreen);
        if (!pPriv)
            return FALSE;
    }
    pAttr = New(ScreenSaverAttrRec);
    if (!pAttr) {
        ret = BadAlloc;
        goto bail;
    }
    /* over allocate for override redirect */
    pAttr->values = values = xallocarray(len + 1, sizeof(unsigned long));
    if (!values) {
        ret = BadAlloc;
        goto bail;
    }
    pAttr->screen = pScreen;
    pAttr->client = client;
    pAttr->x = stuff->x;
    pAttr->y = stuff->y;
    pAttr->width = stuff->width;
    pAttr->height = stuff->height;
    pAttr->borderWidth = stuff->borderWidth;
    pAttr->class = stuff->c_class;
    pAttr->depth = depth;
    pAttr->visual = visual;
    pAttr->colormap = None;
    pAttr->pCursor = NullCursor;
    pAttr->pBackgroundPixmap = NullPixmap;
    pAttr->pBorderPixmap = NullPixmap;
    /*
     * go through the mask, checking the values,
     * looking up pixmaps and cursors and hold a reference
     * to them.
     */
    pAttr->mask = tmask = stuff->mask | CWOverrideRedirect;
    pVlist = (unsigned int *) (stuff + 1);
    while (tmask) {
        imask = lowbit(tmask);
        tmask &= ~imask;
        switch (imask) {
        case CWBackPixmap:
            pixID = (Pixmap) * pVlist;
            if (pixID == None) {
                *values++ = None;
            }
            else if (pixID == ParentRelative) {
                if (depth != pParent->drawable.depth) {
                    ret = BadMatch;
                    goto PatchUp;
                }
                *values++ = ParentRelative;
            }
            else {
                ret =
                    dixLookupResourceByType((void **) &pPixmap, pixID,
                                            RT_PIXMAP, client, DixReadAccess);
                if (ret == Success) {
                    if ((pPixmap->drawable.depth != depth) ||
                        (pPixmap->drawable.pScreen != pScreen)) {
                        ret = BadMatch;
                        goto PatchUp;
                    }
                    pAttr->pBackgroundPixmap = pPixmap;
                    pPixmap->refcnt++;
                    pAttr->mask &= ~CWBackPixmap;
                }
                else {
                    client->errorValue = pixID;
                    goto PatchUp;
                }
            }
            break;
        case CWBackPixel:
            *values++ = (CARD32) *pVlist;
            break;
        case CWBorderPixmap:
            pixID = (Pixmap) * pVlist;
            if (pixID == CopyFromParent) {
                if (depth != pParent->drawable.depth) {
                    ret = BadMatch;
                    goto PatchUp;
                }
                *values++ = CopyFromParent;
            }
            else {
                ret =
                    dixLookupResourceByType((void **) &pPixmap, pixID,
                                            RT_PIXMAP, client, DixReadAccess);
                if (ret == Success) {
                    if ((pPixmap->drawable.depth != depth) ||
                        (pPixmap->drawable.pScreen != pScreen)) {
                        ret = BadMatch;
                        goto PatchUp;
                    }
                    pAttr->pBorderPixmap = pPixmap;
                    pPixmap->refcnt++;
                    pAttr->mask &= ~CWBorderPixmap;
                }
                else {
                    client->errorValue = pixID;
                    goto PatchUp;
                }
            }
            break;
        case CWBorderPixel:
            *values++ = (CARD32) *pVlist;
            break;
        case CWBitGravity:
            val = (CARD8) *pVlist;
            if (val > StaticGravity) {
                ret = BadValue;
                client->errorValue = val;
                goto PatchUp;
            }
            *values++ = val;
            break;
        case CWWinGravity:
            val = (CARD8) *pVlist;
            if (val > StaticGravity) {
                ret = BadValue;
                client->errorValue = val;
                goto PatchUp;
            }
            *values++ = val;
            break;
        case CWBackingStore:
            val = (CARD8) *pVlist;
            if ((val != NotUseful) && (val != WhenMapped) && (val != Always)) {
                ret = BadValue;
                client->errorValue = val;
                goto PatchUp;
            }
            *values++ = val;
            break;
        case CWBackingPlanes:
            *values++ = (CARD32) *pVlist;
            break;
        case CWBackingPixel:
            *values++ = (CARD32) *pVlist;
            break;
        case CWSaveUnder:
            val = (BOOL) * pVlist;
            if ((val != xTrue) && (val != xFalse)) {
                ret = BadValue;
                client->errorValue = val;
                goto PatchUp;
            }
            *values++ = val;
            break;
        case CWEventMask:
            *values++ = (CARD32) *pVlist;
            break;
        case CWDontPropagate:
            *values++ = (CARD32) *pVlist;
            break;
        case CWOverrideRedirect:
            if (!(stuff->mask & CWOverrideRedirect))
                pVlist--;
            else {
                val = (BOOL) * pVlist;
                if ((val != xTrue) && (val != xFalse)) {
                    ret = BadValue;
                    client->errorValue = val;
                    goto PatchUp;
                }
            }
            *values++ = xTrue;
            break;
        case CWColormap:
            cmap = (Colormap) * pVlist;
            ret = dixLookupResourceByType((void **) &pCmap, cmap, RT_COLORMAP,
                                          client, DixUseAccess);
            if (ret != Success) {
                client->errorValue = cmap;
                goto PatchUp;
            }
            if (pCmap->pVisual->vid != visual || pCmap->pScreen != pScreen) {
                ret = BadMatch;
                goto PatchUp;
            }
            pAttr->colormap = cmap;
            pAttr->mask &= ~CWColormap;
            break;
        case CWCursor:
            cursorID = (Cursor) * pVlist;
            if (cursorID == None) {
                *values++ = None;
            }
            else {
                ret = dixLookupResourceByType((void **) &pCursor, cursorID,
                                              RT_CURSOR, client, DixUseAccess);
                if (ret != Success) {
                    client->errorValue = cursorID;
                    goto PatchUp;
                }
                pAttr->pCursor = RefCursor(pCursor);
                pAttr->mask &= ~CWCursor;
            }
            break;
        default:
            ret = BadValue;
            client->errorValue = stuff->mask;
            goto PatchUp;
        }
        pVlist++;
    }
    if (pPriv->attr)
        FreeScreenAttr(pPriv->attr);
    pPriv->attr = pAttr;
    pAttr->resource = FakeClientID(client->index);
    if (!AddResource(pAttr->resource, AttrType, (void *) pAttr))
        return BadAlloc;
    return Success;
 PatchUp:
    FreeAttrs(pAttr);
 bail:
    CheckScreenPrivate(pScreen);
    if (pAttr)
        free(pAttr->values);
    free(pAttr);
    return ret;
}

static int
ScreenSaverUnsetAttributes(ClientPtr client)
{
    REQUEST(xScreenSaverSetAttributesReq);
    DrawablePtr pDraw;
    ScreenSaverScreenPrivatePtr pPriv;
    int rc;

    REQUEST_SIZE_MATCH(xScreenSaverUnsetAttributesReq);
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
                           DixGetAttrAccess);
    if (rc != Success)
        return rc;
    pPriv = GetScreenPrivate(pDraw->pScreen);
    if (pPriv && pPriv->attr && pPriv->attr->client == client) {
        FreeResource(pPriv->attr->resource, AttrType);
        FreeScreenAttr(pPriv->attr);
        pPriv->attr = NULL;
        CheckScreenPrivate(pDraw->pScreen);
    }
    return Success;
}

static int
ProcScreenSaverSetAttributes(ClientPtr client)
{
#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        REQUEST(xScreenSaverSetAttributesReq);
        PanoramiXRes *draw;
        PanoramiXRes *backPix = NULL;
        PanoramiXRes *bordPix = NULL;
        PanoramiXRes *cmap = NULL;
        int i, status, len;
        int pback_offset = 0, pbord_offset = 0, cmap_offset = 0;
        XID orig_visual, tmp;

        REQUEST_AT_LEAST_SIZE(xScreenSaverSetAttributesReq);

        status = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                          XRC_DRAWABLE, client, DixWriteAccess);
        if (status != Success)
            return (status == BadValue) ? BadDrawable : status;

        len =
            stuff->length -
            bytes_to_int32(sizeof(xScreenSaverSetAttributesReq));
        if (Ones(stuff->mask) != len)
            return BadLength;

        if ((Mask) stuff->mask & CWBackPixmap) {
            pback_offset = Ones((Mask) stuff->mask & (CWBackPixmap - 1));
            tmp = *((CARD32 *) &stuff[1] + pback_offset);
            if ((tmp != None) && (tmp != ParentRelative)) {
                status = dixLookupResourceByType((void **) &backPix, tmp,
                                                 XRT_PIXMAP, client,
                                                 DixReadAccess);
                if (status != Success)
                    return status;
            }
        }

        if ((Mask) stuff->mask & CWBorderPixmap) {
            pbord_offset = Ones((Mask) stuff->mask & (CWBorderPixmap - 1));
            tmp = *((CARD32 *) &stuff[1] + pbord_offset);
            if (tmp != CopyFromParent) {
                status = dixLookupResourceByType((void **) &bordPix, tmp,
                                                 XRT_PIXMAP, client,
                                                 DixReadAccess);
                if (status != Success)
                    return status;
            }
        }

        if ((Mask) stuff->mask & CWColormap) {
            cmap_offset = Ones((Mask) stuff->mask & (CWColormap - 1));
            tmp = *((CARD32 *) &stuff[1] + cmap_offset);
            if (tmp != CopyFromParent) {
                status = dixLookupResourceByType((void **) &cmap, tmp,
                                                 XRT_COLORMAP, client,
                                                 DixReadAccess);
                if (status != Success)
                    return status;
            }
        }

        orig_visual = stuff->visualID;

        FOR_NSCREENS_BACKWARD(i) {
            stuff->drawable = draw->info[i].id;
            if (backPix)
                *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[i].id;
            if (bordPix)
                *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[i].id;
            if (cmap)
                *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[i].id;

            if (orig_visual != CopyFromParent)
                stuff->visualID = PanoramiXTranslateVisualID(i, orig_visual);

            status = ScreenSaverSetAttributes(client);
        }

        return status;
    }
#endif

    return ScreenSaverSetAttributes(client);
}

static int
ProcScreenSaverUnsetAttributes(ClientPtr client)
{
#ifdef PANORAMIX
    if (!noPanoramiXExtension) {
        REQUEST(xScreenSaverUnsetAttributesReq);
        PanoramiXRes *draw;
        int rc, i;

        rc = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                      XRC_DRAWABLE, client, DixWriteAccess);
        if (rc != Success)
            return (rc == BadValue) ? BadDrawable : rc;

        for (i = PanoramiXNumScreens - 1; i > 0; i--) {
            stuff->drawable = draw->info[i].id;
            ScreenSaverUnsetAttributes(client);
        }

        stuff->drawable = draw->info[0].id;
    }
#endif

    return ScreenSaverUnsetAttributes(client);
}

static int
ProcScreenSaverSuspend(ClientPtr client)
{
    ScreenSaverSuspensionPtr *prev, this;

    REQUEST(xScreenSaverSuspendReq);
    REQUEST_SIZE_MATCH(xScreenSaverSuspendReq);

    /* Check if this client is suspending the screensaver */
    for (prev = &suspendingClients; (this = *prev); prev = &this->next)
        if (this->pClient == client)
            break;

    if (this) {
        if (stuff->suspend == TRUE)
            this->count++;
        else if (--this->count == 0)
            FreeResource(this->clientResource, RT_NONE);

        return Success;
    }

    /* If we get to this point, this client isn't suspending the screensaver */
    if (stuff->suspend == FALSE)
        return Success;

    /*
     * Allocate a suspension record for the client, and stop the screensaver
     * if it isn't already suspended by another client. We attach a resource ID
     * to the record, so the screensaver will be reenabled and the record freed
     * if the client disconnects without reenabling it first.
     */
    this = malloc(sizeof(ScreenSaverSuspensionRec));

    if (!this)
        return BadAlloc;

    this->next = NULL;
    this->pClient = client;
    this->count = 1;
    this->clientResource = FakeClientID(client->index);

    if (!AddResource(this->clientResource, SuspendType, (void *) this)) {
        free(this);
        return BadAlloc;
    }

    *prev = this;
    if (!screenSaverSuspended) {
        screenSaverSuspended = TRUE;
        FreeScreenSaverTimer();
    }

    return Success;
}

static int (*NormalVector[]) (ClientPtr /* client */ ) = {
ProcScreenSaverQueryVersion,
        ProcScreenSaverQueryInfo,
        ProcScreenSaverSelectInput,
        ProcScreenSaverSetAttributes,
        ProcScreenSaverUnsetAttributes, ProcScreenSaverSuspend,};

#define NUM_REQUESTS	((sizeof NormalVector) / (sizeof NormalVector[0]))

static int
ProcScreenSaverDispatch(ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < NUM_REQUESTS)
        return (*NormalVector[stuff->data]) (client);
    return BadRequest;
}

static int
SProcScreenSaverQueryVersion(ClientPtr client)
{
    REQUEST(xScreenSaverQueryVersionReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xScreenSaverQueryVersionReq);
    return ProcScreenSaverQueryVersion(client);
}

static int
SProcScreenSaverQueryInfo(ClientPtr client)
{
    REQUEST(xScreenSaverQueryInfoReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xScreenSaverQueryInfoReq);
    swapl(&stuff->drawable);
    return ProcScreenSaverQueryInfo(client);
}

static int
SProcScreenSaverSelectInput(ClientPtr client)
{
    REQUEST(xScreenSaverSelectInputReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xScreenSaverSelectInputReq);
    swapl(&stuff->drawable);
    swapl(&stuff->eventMask);
    return ProcScreenSaverSelectInput(client);
}

static int
SProcScreenSaverSetAttributes(ClientPtr client)
{
    REQUEST(xScreenSaverSetAttributesReq);
    swaps(&stuff->length);
    REQUEST_AT_LEAST_SIZE(xScreenSaverSetAttributesReq);
    swapl(&stuff->drawable);
    swaps(&stuff->x);
    swaps(&stuff->y);
    swaps(&stuff->width);
    swaps(&stuff->height);
    swaps(&stuff->borderWidth);
    swapl(&stuff->visualID);
    swapl(&stuff->mask);
    SwapRestL(stuff);
    return ProcScreenSaverSetAttributes(client);
}

static int
SProcScreenSaverUnsetAttributes(ClientPtr client)
{
    REQUEST(xScreenSaverUnsetAttributesReq);
    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xScreenSaverUnsetAttributesReq);
    swapl(&stuff->drawable);
    return ProcScreenSaverUnsetAttributes(client);
}

static int
SProcScreenSaverSuspend(ClientPtr client)
{
    REQUEST(xScreenSaverSuspendReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xScreenSaverSuspendReq);
    return ProcScreenSaverSuspend(client);
}

static int (*SwappedVector[]) (ClientPtr /* client */ ) = {
SProcScreenSaverQueryVersion,
        SProcScreenSaverQueryInfo,
        SProcScreenSaverSelectInput,
        SProcScreenSaverSetAttributes,
        SProcScreenSaverUnsetAttributes, SProcScreenSaverSuspend,};

static int
SProcScreenSaverDispatch(ClientPtr client)
{
    REQUEST(xReq);

    if (stuff->data < NUM_REQUESTS)
        return (*SwappedVector[stuff->data]) (client);
    return BadRequest;
}

void
ScreenSaverExtensionInit(void)
{
    ExtensionEntry *extEntry;
    int i;
    ScreenPtr pScreen;

    if (!dixRegisterPrivateKey(&ScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return;

    AttrType = CreateNewResourceType(ScreenSaverFreeAttr, "SaverAttr");
    SaverEventType = CreateNewResourceType(ScreenSaverFreeEvents, "SaverEvent");
    SuspendType = CreateNewResourceType(ScreenSaverFreeSuspend, "SaverSuspend");

    for (i = 0; i < screenInfo.numScreens; i++) {
        pScreen = screenInfo.screens[i];
        SetScreenPrivate(pScreen, NULL);
    }
    if (AttrType && SaverEventType && SuspendType &&
        (extEntry = AddExtension(ScreenSaverName, ScreenSaverNumberEvents, 0,
                                 ProcScreenSaverDispatch,
                                 SProcScreenSaverDispatch, NULL,
                                 StandardMinorOpcode))) {
        ScreenSaverEventBase = extEntry->eventBase;
        EventSwapVector[ScreenSaverEventBase] =
            (EventSwapPtr) SScreenSaverNotifyEvent;
    }
}
@


1.15
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@d1146 1
a1146 1
            if ((tmp != CopyFromParent) && (tmp != None)) {
@


1.14
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d856 1
a856 1
    pAttr->values = values = malloc((len + 1) * sizeof(unsigned long));
@


1.13
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@a469 3
    Colormap *installedMaps;
    int numInstalled;
    int i;
d545 1
a545 12
    if (wantMap == None)
        return TRUE;
    installedMaps = malloc(pScreen->maxInstalledCmaps * sizeof(Colormap));
    numInstalled = (*pWin->drawable.pScreen->ListInstalledColormaps)
        (pScreen, installedMaps);
    for (i = 0; i < numInstalled; i++)
        if (installedMaps[i] == wantMap)
            break;

    free((char *) installedMaps);

    if (i < numInstalled)
@


1.12
log
@Update to xserver 1.14.4
@
text
@d110 1
a110 3
static int ScreenSaverFreeSuspend(pointer /*value */ ,
                                  XID   /* id */
    );
d132 8
a139 12
static int ScreenSaverFreeEvents(pointer /* value */ ,
                                 XID    /* id */
    );

static Bool setEventMask(ScreenPtr /* pScreen */ ,
                         ClientPtr /* client */ ,
                         unsigned long  /* mask */
    );

static unsigned long getEventMask(ScreenPtr /* pScreen */ ,
                                  ClientPtr     /* client */
    );
d165 1
a165 3
static int ScreenSaverFreeAttr(pointer /* value */ ,
                               XID      /* id */
    );
d167 1
a167 2
static void FreeAttrs(ScreenSaverAttrPtr        /* pAttr */
    );
d169 1
a169 2
static void FreeScreenAttr(ScreenSaverAttrPtr   /* pAttr */
    );
d172 3
a174 4
 SendScreenSaverNotify(ScreenPtr /* pScreen */ ,
                       int /* state */ ,
                       Bool     /* forced */
    );
d183 1
a183 2
static ScreenSaverScreenPrivatePtr MakeScreenPrivate(ScreenPtr  /* pScreen */
    );
d279 1
a279 1
            if (!AddResource(pEv->resource, SaverEventType, (pointer) pEv))
d310 1
a310 1
ScreenSaverFreeEvents(pointer value, XID id)
d332 1
a332 1
ScreenSaverFreeAttr(pointer value, XID id)
d354 1
a354 1
ScreenSaverFreeSuspend(pointer value, XID id)
d451 1
a451 1
        rc = dixLookupResourceByType((pointer *) &pCmap, pPriv->installedMap,
d562 1
a562 1
    result = dixLookupResourceByType((pointer *) &pCmap, wantMap, RT_COLORMAP,
d914 1
a914 1
                    dixLookupResourceByType((pointer *) &pPixmap, pixID,
d946 1
a946 1
                    dixLookupResourceByType((pointer *) &pPixmap, pixID,
d1030 1
a1030 1
            ret = dixLookupResourceByType((pointer *) &pCmap, cmap, RT_COLORMAP,
d1049 1
a1049 1
                ret = dixLookupResourceByType((pointer *) &pCursor, cursorID,
d1070 1
a1070 1
    if (!AddResource(pAttr->resource, AttrType, (pointer) pAttr))
d1122 1
a1122 1
        status = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1137 1
a1137 1
                status = dixLookupResourceByType((pointer *) &backPix, tmp,
d1149 1
a1149 1
                status = dixLookupResourceByType((pointer *) &bordPix, tmp,
d1161 1
a1161 1
                status = dixLookupResourceByType((pointer *) &cmap, tmp,
d1202 1
a1202 1
        rc = dixLookupResourceByClass((pointer *) &draw, stuff->drawable,
d1261 1
a1261 1
    if (!AddResource(this->clientResource, SuspendType, (pointer) this)) {
@


1.11
log
@Update to xserver 1.14.3
@
text
@d395 1
a395 3
                lastDeviceEventTime[dev->id] = currentTime;
            lastDeviceEventTime[XIAllDevices] = currentTime;
            lastDeviceEventTime[XIAllMasterDevices] = currentTime;
d682 1
a682 1
    lastInput = GetTimeInMillis() - lastDeviceEventTime[XIAllDevices].milliseconds;
@


1.10
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d534 1
d540 1
a540 1
        pAttr->pCursor->refcnt++;
d543 1
a543 1
        pWin->optional->cursor = pAttr->pCursor;
d1069 1
a1069 2
                pCursor->refcnt++;
                pAttr->pCursor = pCursor;
@


1.9
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d49 1
d61 1
a61 1
#include "modinit.h"
d392 1
d394 4
a397 1
            lastDeviceEventTime = currentTime;
a410 1
    xScreenSaverNotifyEvent ev;
d428 12
a439 10
        if (!(pEv->mask & mask))
            continue;
        ev.type = ScreenSaverNotify + ScreenSaverEventBase;
        ev.state = state;
        ev.timestamp = currentTime.milliseconds;
        ev.root = pScreen->root->drawable.id;
        ev.window = pScreen->screensaver.wid;
        ev.kind = kind;
        ev.forced = forced;
        WriteEventsToClient(pEv->client, 1, (xEvent *) &ev);
d640 7
a646 1
    xScreenSaverQueryVersionReply rep;
d649 1
a649 5
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SERVER_SAVER_MAJOR_VERSION;
    rep.minorVersion = SERVER_SAVER_MINOR_VERSION;
d654 1
a654 1
    WriteToClient(client, sizeof(xScreenSaverQueryVersionReply), (char *) &rep);
d683 1
a683 1
    lastInput = GetTimeInMillis() - lastDeviceEventTime.milliseconds;
d685 6
a690 4
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.window = pSaver->wid;
d727 1
a727 1
    WriteToClient(client, sizeof(xScreenSaverQueryInfoReply), (char *) &rep);
d840 1
a840 1
            pDepth = (DepthPtr) & pScreen->allowedDepths[idepth];
d1394 1
a1394 1
ScreenSaverExtensionInit(INITARGS)
@


1.8
log
@Bugfix Update to xserver 1.11.3
@
text
@a28 1

d64 4
a67 6

static Bool ScreenSaverHandle (
	ScreenPtr /* pScreen */,
	int /* xstate */,
	Bool /* force */
	);
d70 2
a71 3
CreateSaverWindow (
	ScreenPtr /* pScreen */
	);
d74 2
a75 3
DestroySaverWindow (
	ScreenPtr /* pScreen */
	);
d78 2
a79 3
UninstallSaverColormap (
	ScreenPtr /* pScreen */
	);
d82 6
a87 8
CheckScreenPrivate (
	ScreenPtr /* pScreen */
	);

static void SScreenSaverNotifyEvent (
	xScreenSaverNotifyEvent * /* from */,
	xScreenSaverNotifyEvent * /* to */
	);
d89 1
a89 1
static RESTYPE SuspendType;  /* resource type for suspension records */
d102 5
a106 6
typedef struct _ScreenSaverSuspension
{
    ScreenSaverSuspensionPtr  next;
    ClientPtr                 pClient;
    XID                       clientResource;
    int                       count;
d109 3
a111 4
static int ScreenSaverFreeSuspend(
    pointer /*value */,
    XID /* id */
);
d121 1
a121 1
static RESTYPE SaverEventType;   /* resource type for event masks */
d126 5
a130 5
    ScreenSaverEventPtr	next;
    ClientPtr		client;
    ScreenPtr		screen;
    XID			resource;
    CARD32		mask;
d133 12
a144 15
static int ScreenSaverFreeEvents(
    pointer /* value */,
    XID /* id */
);

static Bool setEventMask (
    ScreenPtr /* pScreen */,
    ClientPtr /* client */,
    unsigned long /* mask */
);

static unsigned long getEventMask (
    ScreenPtr /* pScreen */,
    ClientPtr /* client */
);
d151 1
a151 1
static RESTYPE AttrType;    /* resource type for attributes */
d154 14
a167 14
    ScreenPtr	    screen;
    ClientPtr	    client;
    XID		    resource;
    short	    x, y;
    unsigned short  width, height, borderWidth;
    unsigned char   class;
    unsigned char   depth;
    VisualID	    visual;
    CursorPtr	    pCursor;
    PixmapPtr	    pBackgroundPixmap;
    PixmapPtr	    pBorderPixmap;
    Colormap	    colormap;
    unsigned long   mask;		/* no pixmaps or cursors */
    unsigned long   *values;
d170 9
a178 12
static int ScreenSaverFreeAttr (
    pointer /* value */,
    XID /* id */
);

static void FreeAttrs (
    ScreenSaverAttrPtr	/* pAttr */
);

static void FreeScreenAttr (
    ScreenSaverAttrPtr	/* pAttr */
);
d181 4
a184 5
SendScreenSaverNotify (
    ScreenPtr /* pScreen */,
    int /* state */,
    Bool /* forced */
);
d187 4
a190 4
    ScreenSaverEventPtr	    events;
    ScreenSaverAttrPtr	    attr;
    Bool		    hasWindow;
    Colormap		    installedMap;
d193 2
a194 4
static ScreenSaverScreenPrivatePtr
MakeScreenPrivate (
	ScreenPtr /* pScreen */
	);
d197 1
d209 1
a209 1
CheckScreenPrivate (ScreenPtr pScreen)
d211 1
a211 1
    SetupScreen (pScreen);
d214 1
a214 1
	return;
d216 4
a219 5
	!pPriv->hasWindow && pPriv->installedMap == None)
    {
	free(pPriv);
	SetScreenPrivate (pScreen, NULL);
	pScreen->screensaver.ExternalScreenSaver = NULL;
d224 1
a224 1
MakeScreenPrivate (ScreenPtr pScreen)
d226 1
a226 1
    SetupScreen (pScreen);
d229 2
a230 2
	return pPriv;
    pPriv = New (ScreenSaverScreenPrivateRec);
d232 1
a232 1
	return 0;
d237 1
a237 1
    SetScreenPrivate (pScreen, pPriv);
d243 1
a243 1
getEventMask (ScreenPtr pScreen, ClientPtr client)
d246 1
a246 1
    ScreenSaverEventPtr	pEv;
d249 1
a249 1
	return 0;
d251 2
a252 2
	if (pEv->client == client)
	    return pEv->mask;
d257 1
a257 1
setEventMask (ScreenPtr pScreen, ClientPtr client, unsigned long mask)
d260 1
a260 1
    ScreenSaverEventPtr	pEv, *pPrev;
d262 6
a267 7
    if (getEventMask (pScreen, client) == mask)
	return TRUE;
    if (!pPriv)
    {
	pPriv = MakeScreenPrivate (pScreen);
	if (!pPriv)
	    return FALSE;
d270 24
a293 28
	if (pEv->client == client)
	    break;
    if (mask == 0)
    {
	FreeResource (pEv->resource, SaverEventType);
	*pPrev = pEv->next;
	free(pEv);
	CheckScreenPrivate (pScreen);
    }
    else
    {
    	if (!pEv) 
    	{
	    pEv = New (ScreenSaverEventRec);
	    if (!pEv) 
	    {
		CheckScreenPrivate (pScreen);
	    	return FALSE;
	    }
    	    *pPrev = pEv;
    	    pEv->next = NULL;
    	    pEv->client = client;
    	    pEv->screen = pScreen;
    	    pEv->resource = FakeClientID (client->index);
	    if (!AddResource (pEv->resource, SaverEventType, (pointer) pEv))
		return FALSE;
    	}
	pEv->mask = mask;
d299 1
a299 1
FreeAttrs (ScreenSaverAttrPtr pAttr)
d301 2
a302 2
    PixmapPtr	    pPixmap;
    CursorPtr	    pCursor;
d305 1
a305 1
	(*pPixmap->drawable.pScreen->DestroyPixmap)(pPixmap);
d307 1
a307 1
	(*pPixmap->drawable.pScreen->DestroyPixmap)(pPixmap);
d309 1
a309 1
	FreeCursor (pCursor, (Cursor) 0);
d313 1
a313 1
FreeScreenAttr (ScreenSaverAttrPtr pAttr)
d315 1
a315 1
    FreeAttrs (pAttr);
d321 1
a321 1
ScreenSaverFreeEvents (pointer value, XID id)
d323 1
a323 1
    ScreenSaverEventPtr	pOld = (ScreenSaverEventPtr)value;
d325 3
a327 2
    SetupScreen (pScreen);
    ScreenSaverEventPtr	pEv, *pPrev;
d330 1
a330 1
	return TRUE;
d332 2
a333 2
	if (pEv == pOld)
	    break;
d335 1
a335 1
	return TRUE;
d338 1
a338 1
    CheckScreenPrivate (pScreen);
d343 1
a343 1
ScreenSaverFreeAttr (pointer value, XID id)
d345 4
a348 3
    ScreenSaverAttrPtr	pOldAttr = (ScreenSaverAttrPtr)value;
    ScreenPtr	pScreen = pOldAttr->screen;
    SetupScreen (pScreen);
d351 1
a351 1
	return TRUE;
d353 2
a354 2
	return TRUE;
    FreeScreenAttr (pOldAttr);
d356 3
a358 4
    if (pPriv->hasWindow)
    {
	dixSaveScreens (serverClient, SCREEN_SAVER_FORCER, ScreenSaverReset);
	dixSaveScreens (serverClient, SCREEN_SAVER_FORCER, ScreenSaverActive);
d360 1
a360 1
    CheckScreenPrivate (pScreen);
d365 1
a365 1
ScreenSaverFreeSuspend (pointer value, XID id)
d371 6
a376 8
    for (prev = &suspendingClients; (this = *prev); prev = &this->next)
    {
	if (this == data)
	{
	    *prev = this->next;
	    free(this);
	    break;
	}
d380 2
a381 3
    if (screenSaverSuspended && suspendingClients == NULL)
    {
	screenSaverSuspended = FALSE;
d383 2
a384 2
	/* The screensaver could be active, since suspending it (by design)
	   doesn't prevent it from being forceably activated */
d386 1
a386 1
	if (screenIsSaved != SCREEN_SAVER_ON && DPMSPowerLevel == DPMSModeOn)
d388 1
a388 1
	if (screenIsSaved != SCREEN_SAVER_ON)
d390 5
a394 5
	{
	    UpdateCurrentTimeIf();
	    lastDeviceEventTime = currentTime;
	    SetScreenSaverTimer();
	}
d401 1
a401 1
SendScreenSaverNotify (ScreenPtr pScreen, int state, Bool forced)
d403 5
a407 5
    ScreenSaverScreenPrivatePtr	pPriv;
    ScreenSaverEventPtr		pEv;
    unsigned long		mask;
    xScreenSaverNotifyEvent	ev;
    int				kind;
d409 1
a409 1
    UpdateCurrentTimeIf ();
d412 1
a412 1
	mask = ScreenSaverCycleMask;
d416 1
a416 1
	return;
d418 1
a418 1
	kind = ScreenSaverExternal;
d420 1
a420 1
	kind = ScreenSaverBlanked;
d422 12
a433 13
	kind = ScreenSaverInternal;
    for (pEv = pPriv->events; pEv; pEv = pEv->next)
    {
	if (!(pEv->mask & mask))
	    continue;
	ev.type = ScreenSaverNotify + ScreenSaverEventBase;
	ev.state = state;
	ev.timestamp = currentTime.milliseconds;
	ev.root = pScreen->root->drawable.id;
	ev.window = pScreen->screensaver.wid;
	ev.kind = kind;
	ev.forced = forced;
	WriteEventsToClient (pEv->client, 1, (xEvent *) &ev);
d438 2
a439 2
SScreenSaverNotifyEvent (xScreenSaverNotifyEvent *from,
                         xScreenSaverNotifyEvent *to)
d443 4
a446 4
    cpswaps (from->sequenceNumber, to->sequenceNumber);
    cpswapl (from->timestamp, to->timestamp);    
    cpswapl (from->root, to->root);    
    cpswapl (from->window, to->window);    
d452 1
a452 1
UninstallSaverColormap (ScreenPtr pScreen)
d455 1
a455 1
    ColormapPtr			pCmap;
d458 8
a465 9
    if (pPriv && pPriv->installedMap != None)
    {
	rc = dixLookupResourceByType((pointer *)&pCmap, pPriv->installedMap,
				     RT_COLORMAP, serverClient,
				     DixUninstallAccess);
	if (rc == Success)
	    (*pCmap->pScreen->UninstallColormap) (pCmap);
	pPriv->installedMap = None;
	CheckScreenPrivate (pScreen);
d470 1
a470 1
CreateSaverWindow (ScreenPtr pScreen)
d472 11
a482 11
    SetupScreen (pScreen);
    ScreenSaverStuffPtr		pSaver;
    ScreenSaverAttrPtr		pAttr;
    WindowPtr			pWin;
    int				result;
    unsigned long		mask;
    Colormap			*installedMaps;
    int				numInstalled;
    int				i;
    Colormap			wantMap;
    ColormapPtr			pCmap;
d485 8
a492 10
    if (pSaver->pWindow)
    {
	pSaver->pWindow = NullWindow;
	FreeResource (pSaver->wid, RT_NONE);
	if (pPriv)
	{
	    UninstallSaverColormap (pScreen);
	    pPriv->hasWindow = FALSE;
	    CheckScreenPrivate (pScreen);
	}
d496 1
a496 1
	return FALSE;
d501 1
a501 1
	return FALSE;
d503 5
a507 6
    pWin = CreateWindow (pSaver->wid, pScreen->root,
			 pAttr->x, pAttr->y, pAttr->width, pAttr->height,
			 pAttr->borderWidth, pAttr->class, 
			 pAttr->mask, (XID *)pAttr->values, 
			 pAttr->depth, serverClient, pAttr->visual, 
			 &result);
d509 1
a509 1
	return FALSE;
d512 1
a512 1
	return FALSE;
d515 25
a539 29
    if (pAttr->pBackgroundPixmap)
    {
	pWin->backgroundState = BackgroundPixmap;
	pWin->background.pixmap = pAttr->pBackgroundPixmap;
	pAttr->pBackgroundPixmap->refcnt++;
	mask |= CWBackPixmap;
    }
    if (pAttr->pBorderPixmap)
    {
	pWin->borderIsPixel = FALSE;
	pWin->border.pixmap = pAttr->pBorderPixmap;
	pAttr->pBorderPixmap->refcnt++;
	mask |= CWBorderPixmap;
    }
    if (pAttr->pCursor)
    {
	if (!pWin->optional)
	    if (!MakeWindowOptional (pWin))
	    {
    	    	FreeResource (pWin->drawable.id, RT_NONE);
    	    	return FALSE;
	    }
	pAttr->pCursor->refcnt++;
	if (pWin->optional->cursor)
	    FreeCursor (pWin->optional->cursor, (Cursor)0);
	pWin->optional->cursor = pAttr->pCursor;
	pWin->cursorIsNone = FALSE;
	CheckWindowOptionalNeed (pWin);
	mask |= CWCursor;
d542 1
a542 1
	(*pScreen->ChangeWindowAttributes) (pWin, mask);
d545 2
a546 2
	(void) ChangeWindowAttributes (pWin, CWColormap, &pAttr->colormap,
				       serverClient);
d548 1
a548 1
    MapWindow (pWin, serverClient);
d554 1
a554 1
    wantMap = wColormap (pWin);
d556 2
a557 2
	return TRUE;
    installedMaps = malloc(pScreen->maxInstalledCmaps * sizeof (Colormap));
d559 4
a562 4
						    (pScreen, installedMaps);
    for (i = 0; i < numInstalled; i++) 
	if (installedMaps[i] == wantMap)
	    break;
d567 1
a567 1
	return TRUE;
d569 2
a570 2
    result = dixLookupResourceByType((pointer *)&pCmap, wantMap, RT_COLORMAP,
				     serverClient, DixInstallAccess);
d572 1
a572 1
	return TRUE;
d582 1
a582 1
DestroySaverWindow (ScreenPtr pScreen)
d585 1
a585 1
    ScreenSaverStuffPtr		pSaver;
d588 1
a588 1
	return FALSE;
d591 3
a593 4
    if (pSaver->pWindow)
    {
	pSaver->pWindow = NullWindow;
	FreeResource (pSaver->wid, RT_NONE);
d596 2
a597 2
    CheckScreenPrivate (pScreen);
    UninstallSaverColormap (pScreen);
d602 1
a602 1
ScreenSaverHandle (ScreenPtr pScreen, int xstate, Bool force)
d604 19
a622 20
    int				state = 0;
    Bool			ret = FALSE;
    ScreenSaverScreenPrivatePtr	pPriv;

    switch (xstate)
    {
    case SCREEN_SAVER_ON:	
	state = ScreenSaverOn;
	ret = CreateSaverWindow (pScreen);
	break;
    case SCREEN_SAVER_OFF:	
	state = ScreenSaverOff;
	ret = DestroySaverWindow (pScreen);
	break;
    case SCREEN_SAVER_CYCLE:	
	state = ScreenSaverCycle;
	pPriv = GetScreenPrivate (pScreen);
	if (pPriv && pPriv->hasWindow)
	    ret = TRUE;
	
d625 1
a625 1
    if(noPanoramiXExtension || !pScreen->myNum)
d627 1
a627 1
       SendScreenSaverNotify (pScreen, state, force);
d632 1
a632 1
ProcScreenSaverQueryVersion (ClientPtr client)
d634 1
a634 2
    xScreenSaverQueryVersionReply	rep;
    int		n;
d636 1
a636 1
    REQUEST_SIZE_MATCH (xScreenSaverQueryVersionReq);
d643 2
a644 2
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
d646 1
a646 1
    WriteToClient(client, sizeof (xScreenSaverQueryVersionReply), (char *)&rep);
d651 1
a651 1
ProcScreenSaverQueryInfo (ClientPtr client)
d654 6
a659 6
    xScreenSaverQueryInfoReply	rep;
    int		n, rc;
    ScreenSaverStuffPtr		pSaver;
    DrawablePtr			pDraw;
    CARD32			lastInput;
    ScreenSaverScreenPrivatePtr	pPriv;
d661 1
a661 1
    REQUEST_SIZE_MATCH (xScreenSaverQueryInfoReq);
d663 1
a663 1
			   DixGetAttrAccess);
d665 1
a665 1
	return rc;
d667 1
a667 1
		  DixGetAttrAccess);
d669 1
a669 1
	return rc;
d672 1
a672 1
    pPriv = GetScreenPrivate (pDraw->pScreen);
d674 1
a674 1
    UpdateCurrentTime ();
d681 19
a699 23
    if (screenIsSaved != SCREEN_SAVER_OFF)
    {
	rep.state = ScreenSaverOn;
	if (ScreenSaverTime)
	    rep.tilOrSince = lastInput - ScreenSaverTime;
	else
	    rep.tilOrSince = 0;
    }
    else
    {
	if (ScreenSaverTime)
	{
	    rep.state = ScreenSaverOff;
	    if (ScreenSaverTime < lastInput)
		rep.tilOrSince = 0;
	    else
		rep.tilOrSince = ScreenSaverTime - lastInput;
	}
	else
	{
	    rep.state = ScreenSaverDisabled;
	    rep.tilOrSince = 0;
	}
d702 1
a702 1
    rep.eventMask = getEventMask (pDraw->pScreen, client);
d704 1
a704 1
	rep.kind = ScreenSaverExternal;
d706 1
a706 1
	rep.kind = ScreenSaverBlanked;
d708 8
a715 9
	rep.kind = ScreenSaverInternal;
    if (client->swapped)
    {
	swaps (&rep.sequenceNumber, n);
	swapl (&rep.length, n);
	swapl (&rep.window, n);
	swapl (&rep.tilOrSince, n);
	swapl (&rep.idle, n);
	swapl (&rep.eventMask, n);
d717 1
a717 1
    WriteToClient(client, sizeof (xScreenSaverQueryInfoReply), (char *)&rep);
d722 1
a722 1
ProcScreenSaverSelectInput (ClientPtr client)
d725 2
a726 2
    DrawablePtr			pDraw;
    int				rc;
d728 3
a730 3
    REQUEST_SIZE_MATCH (xScreenSaverSelectInputReq);
    rc = dixLookupDrawable (&pDraw, stuff->drawable, client, 0,
			    DixGetAttrAccess);
d732 1
a732 1
	return rc;
d735 1
a735 1
		  DixSetAttrAccess);
d737 1
a737 1
	return rc;
d739 2
a740 2
    if (!setEventMask (pDraw->pScreen, client, stuff->eventMask))
	return BadAlloc;
d745 1
a745 1
ScreenSaverSetAttributes (ClientPtr client)
d748 3
a750 3
    DrawablePtr			pDraw;
    WindowPtr			pParent;
    ScreenPtr			pScreen;
d752 17
a768 17
    ScreenSaverAttrPtr		pAttr = 0;
    int				ret, len, class, bw, depth;
    unsigned long		visual;
    int				idepth, ivisual;
    Bool			fOK;
    DepthPtr			pDepth;
    WindowOptPtr		ancwopt;
    unsigned int		*pVlist;
    unsigned long		*values = 0;
    unsigned long		tmask, imask;
    unsigned long		val;
    Pixmap			pixID;
    PixmapPtr			pPixmap;
    Cursor			cursorID;
    CursorPtr			pCursor;
    Colormap			cmap;
    ColormapPtr			pCmap;
d770 1
a770 1
    REQUEST_AT_LEAST_SIZE (xScreenSaverSetAttributesReq);
d772 1
a772 1
			    DixGetAttrAccess);
d774 1
a774 1
	return ret;
d780 1
a780 1
	return ret;
d782 1
a782 1
    len = stuff->length -  bytes_to_int32(sizeof(xScreenSaverSetAttributesReq));
d785 2
a786 3
    if (!stuff->width || !stuff->height)
    {
	client->errorValue = 0;
d789 1
a789 2
    switch (class = stuff->c_class) 
    {
d793 1
a793 1
	break;
d795 2
a796 2
	client->errorValue = class;
	return BadValue;
d805 1
a805 1
	class = pParent->drawable.class;
d807 3
a809 4
    if ((class != InputOutput) && (class != InputOnly))
    {
	client->errorValue = class;
	return BadValue;
d822 1
a822 1
	ancwopt = FindWindowWithOptional(pParent)->optional;
d824 1
a824 1
	visual = ancwopt->visual;
d827 15
a841 20
    if ((visual != ancwopt->visual) || (depth != pParent->drawable.depth))
    {
	fOK = FALSE;
	for(idepth = 0; idepth < pScreen->numDepths; idepth++)
	{
	    pDepth = (DepthPtr) &pScreen->allowedDepths[idepth];
	    if ((depth == pDepth->depth) || (depth == 0))
	    {
		for (ivisual = 0; ivisual < pDepth->numVids; ivisual++)
		{
		    if (visual == pDepth->vids[ivisual])
		    {
			fOK = TRUE;
			break;
		    }
		}
	    }
	}
	if (fOK == FALSE)
	    return BadMatch;
d845 1
a845 3
	(class != InputOnly) &&
	(depth != pParent->drawable.depth))
    {
d850 3
a852 4
	(class != InputOnly) &&
	((visual != ancwopt->visual) || (ancwopt->colormap == None)))
    {
	return BadMatch;
d857 14
a870 17
    pPriv = GetScreenPrivate (pScreen);
    if (pPriv && pPriv->attr)
    {
	if (pPriv->attr->client != client)
	    return BadAccess;
    }
    if (!pPriv)
    {
	pPriv = MakeScreenPrivate (pScreen);
	if (!pPriv)
	    return FALSE;
    }
    pAttr = New (ScreenSaverAttrRec);
    if (!pAttr)
    {
	ret = BadAlloc;
	goto bail;
d873 4
a876 5
    pAttr->values = values = malloc((len + 1) * sizeof (unsigned long));
    if (!values)
    {
	ret = BadAlloc;
	goto bail;
d900 54
a953 28
	imask = lowbit (tmask);
	tmask &= ~imask;
	switch (imask)
        {
	case CWBackPixmap:
	    pixID = (Pixmap )*pVlist;
	    if (pixID == None)
	    {
		*values++ = None;
	    }
	    else if (pixID == ParentRelative)
	    {
		if (depth != pParent->drawable.depth)
		{
		    ret = BadMatch;
		    goto PatchUp;
		}
		*values++ = ParentRelative;
	    }
            else
	    {	
		ret = dixLookupResourceByType((pointer *)&pPixmap, pixID, RT_PIXMAP,
					client, DixReadAccess);
		if (ret == Success)
		{
                    if  ((pPixmap->drawable.depth != depth) ||
			 (pPixmap->drawable.pScreen != pScreen))
		    {
d955 43
a997 51
			goto PatchUp;
		    }
		    pAttr->pBackgroundPixmap = pPixmap;
		    pPixmap->refcnt++;
		    pAttr->mask &= ~CWBackPixmap;
		}
	        else
		{
		    client->errorValue = pixID;
		    goto PatchUp;
		}
	    }
	    break;
	case CWBackPixel:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWBorderPixmap:
	    pixID = (Pixmap ) *pVlist;
	    if (pixID == CopyFromParent)
	    {
		if (depth != pParent->drawable.depth)
		{
		    ret = BadMatch;
		    goto PatchUp;
		}
		*values++ = CopyFromParent;
	    }
	    else
	    {	
		ret = dixLookupResourceByType((pointer *)&pPixmap, pixID, RT_PIXMAP,
					client, DixReadAccess);
		if (ret == Success)
		{
                    if  ((pPixmap->drawable.depth != depth) ||
			 (pPixmap->drawable.pScreen != pScreen))
		    {
			ret = BadMatch;
			goto PatchUp;
		    }
		    pAttr->pBorderPixmap = pPixmap;
		    pPixmap->refcnt++;
		    pAttr->mask &= ~CWBorderPixmap;
		}
    	        else
		{
		    client->errorValue = pixID;
		    goto PatchUp;
		}
	    }
	    break;
	case CWBorderPixel:
d1000 69
a1068 110
	case CWBitGravity:
	    val = (CARD8 )*pVlist;
	    if (val > StaticGravity)
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWWinGravity:
	    val = (CARD8 )*pVlist;
	    if (val > StaticGravity)
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWBackingStore:
	    val = (CARD8 )*pVlist;
	    if ((val != NotUseful) && (val != WhenMapped) && (val != Always))
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWBackingPlanes:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWBackingPixel:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWSaveUnder:
	    val = (BOOL) *pVlist;
	    if ((val != xTrue) && (val != xFalse))
	    {
		ret = BadValue;
		client->errorValue = val;
		goto PatchUp;
	    }
	    *values++ = val;
	    break;
	case CWEventMask:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWDontPropagate:
	    *values++ = (CARD32) *pVlist;
	    break;
	case CWOverrideRedirect:
	    if (!(stuff->mask & CWOverrideRedirect))
		pVlist--;
	    else
	    {
	    	val = (BOOL ) *pVlist;
	    	if ((val != xTrue) && (val != xFalse))
	    	{
		    ret = BadValue;
		    client->errorValue = val;
		    goto PatchUp;
	    	}
	    }
	    *values++ = xTrue;
	    break;
	case CWColormap:
	    cmap = (Colormap) *pVlist;
	    ret = dixLookupResourceByType((pointer *)&pCmap, cmap, RT_COLORMAP,
				    client, DixUseAccess);
	    if (ret != Success)
	    {
		client->errorValue = cmap;
		goto PatchUp;
	    }
	    if (pCmap->pVisual->vid != visual || pCmap->pScreen != pScreen)
	    {
		ret = BadMatch;
		goto PatchUp;
	    }
	    pAttr->colormap = cmap;
	    pAttr->mask &= ~CWColormap;
	    break;
	case CWCursor:
	    cursorID = (Cursor ) *pVlist;
	    if ( cursorID == None)
	    {
		*values++ = None;
	    }
	    else
	    {
		ret = dixLookupResourceByType((pointer *)&pCursor, cursorID,
					RT_CURSOR, client, DixUseAccess);
	    	if (ret != Success)
	    	{
		    client->errorValue = cursorID;
		    goto PatchUp;
	    	}
		pCursor->refcnt++;
		pAttr->pCursor = pCursor;
		pAttr->mask &= ~CWCursor;
	    }
	    break;
     	 default:
	    ret = BadValue;
	    client->errorValue = stuff->mask;
	    goto PatchUp;
	}
	pVlist++;
d1071 1
a1071 1
	FreeScreenAttr (pPriv->attr);
d1073 3
a1075 3
    pAttr->resource = FakeClientID (client->index);
    if (!AddResource (pAttr->resource, AttrType, (pointer) pAttr))
	return BadAlloc;
d1077 6
a1082 5
PatchUp:
    FreeAttrs (pAttr);
bail:
    CheckScreenPrivate (pScreen);
    if (pAttr) free(pAttr->values);
d1088 1
a1088 1
ScreenSaverUnsetAttributes (ClientPtr client)
d1091 3
a1093 3
    DrawablePtr			pDraw;
    ScreenSaverScreenPrivatePtr	pPriv;
    int				rc;
d1095 1
a1095 1
    REQUEST_SIZE_MATCH (xScreenSaverUnsetAttributesReq);
d1097 1
a1097 1
			   DixGetAttrAccess);
d1099 7
a1105 8
	return rc;
    pPriv = GetScreenPrivate (pDraw->pScreen);
    if (pPriv && pPriv->attr && pPriv->attr->client == client)
    {
	FreeResource (pPriv->attr->resource, AttrType);
    	FreeScreenAttr (pPriv->attr);
	pPriv->attr = NULL;
	CheckScreenPrivate (pDraw->pScreen);
d1111 1
a1111 1
ProcScreenSaverSetAttributes (ClientPtr client)
d1114 58
a1171 67
    if(!noPanoramiXExtension) {
       REQUEST(xScreenSaverSetAttributesReq);
       PanoramiXRes *draw;
       PanoramiXRes *backPix = NULL;
       PanoramiXRes *bordPix = NULL;
       PanoramiXRes *cmap    = NULL;
       int i, status, len;
       int  pback_offset = 0, pbord_offset = 0, cmap_offset = 0;
       XID orig_visual, tmp;

       REQUEST_AT_LEAST_SIZE (xScreenSaverSetAttributesReq);

       status = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
					 XRC_DRAWABLE, client, DixWriteAccess);
       if (status != Success)
           return (status == BadValue) ? BadDrawable : status;

       len = stuff->length -  bytes_to_int32(sizeof(xScreenSaverSetAttributesReq));
       if (Ones(stuff->mask) != len)
           return BadLength;

       if((Mask)stuff->mask & CWBackPixmap) {
          pback_offset = Ones((Mask)stuff->mask & (CWBackPixmap - 1));
          tmp = *((CARD32 *) &stuff[1] + pback_offset);
          if ((tmp != None) && (tmp != ParentRelative)) {
	      status = dixLookupResourceByType((pointer *)&backPix, tmp,
					       XRT_PIXMAP, client,
					       DixReadAccess);
	      if (status != Success)
		  return status;
          }
       }

       if ((Mask)stuff->mask & CWBorderPixmap) {
          pbord_offset = Ones((Mask)stuff->mask & (CWBorderPixmap - 1));
          tmp = *((CARD32 *) &stuff[1] + pbord_offset);
          if (tmp != CopyFromParent) {
	      status = dixLookupResourceByType((pointer *)&bordPix, tmp,
					       XRT_PIXMAP, client,
					       DixReadAccess);
	      if (status != Success)
		  return status;
          }
       }

       if ((Mask)stuff->mask & CWColormap) {
           cmap_offset = Ones((Mask)stuff->mask & (CWColormap - 1));
           tmp = *((CARD32 *) &stuff[1] + cmap_offset);
           if ((tmp != CopyFromParent) && (tmp != None)) {
	       status = dixLookupResourceByType((pointer *)&cmap, tmp,
						XRT_COLORMAP, client,
						DixReadAccess);
	       if (status != Success)
		   return status;
           }
       }

       orig_visual = stuff->visualID;

       FOR_NSCREENS_BACKWARD(i) {
          stuff->drawable = draw->info[i].id;  
          if (backPix)
             *((CARD32 *) &stuff[1] + pback_offset) = backPix->info[i].id;
          if (bordPix)
             *((CARD32 *) &stuff[1] + pbord_offset) = bordPix->info[i].id;
          if (cmap)
             *((CARD32 *) &stuff[1] + cmap_offset) = cmap->info[i].id;
d1173 1
a1173 2
          if (orig_visual != CopyFromParent) 
            stuff->visualID = PanoramiXTranslateVisualID(i, orig_visual);
d1175 8
a1182 2
          status = ScreenSaverSetAttributes(client);
       }
d1184 7
a1190 1
       return status;
d1198 1
a1198 1
ProcScreenSaverUnsetAttributes (ClientPtr client)
d1201 9
a1209 9
    if(!noPanoramiXExtension) {
       REQUEST(xScreenSaverUnsetAttributesReq);
       PanoramiXRes *draw;
       int rc, i;

       rc = dixLookupResourceByClass((pointer *)&draw, stuff->drawable,
				     XRC_DRAWABLE, client, DixWriteAccess);
       if (rc != Success)
           return (rc == BadValue) ? BadDrawable : rc;
d1211 1
a1211 1
       for(i = PanoramiXNumScreens - 1; i > 0; i--) {
d1214 1
a1214 1
       }
d1216 1
a1216 1
       stuff->drawable = draw->info[0].id;
d1224 1
a1224 1
ProcScreenSaverSuspend (ClientPtr client)
d1233 2
a1234 2
	if (this->pClient == client)
	    break;
d1236 5
a1240 6
    if (this)
    {
	if (stuff->suspend == TRUE)
	   this->count++;
	else if (--this->count == 0)
	   FreeResource (this->clientResource, RT_NONE);
d1242 1
a1242 1
	return Success;
d1247 1
a1247 1
	return Success;
d1255 1
a1255 1
    this = malloc(sizeof (ScreenSaverSuspensionRec));
d1258 1
a1258 1
	return BadAlloc;
d1260 8
a1267 9
    this->next           = NULL;
    this->pClient        = client;
    this->count          = 1;
    this->clientResource = FakeClientID (client->index);

    if (!AddResource (this->clientResource, SuspendType, (pointer) this))
    {
	free(this);
	return BadAlloc;
d1271 3
a1273 4
    if (!screenSaverSuspended)
    {
	screenSaverSuspended = TRUE;
	FreeScreenSaverTimer();
d1279 6
a1284 8
static int (*NormalVector[]) (ClientPtr /* client */) = {
    ProcScreenSaverQueryVersion,
    ProcScreenSaverQueryInfo,
    ProcScreenSaverSelectInput,
    ProcScreenSaverSetAttributes,
    ProcScreenSaverUnsetAttributes,
    ProcScreenSaverSuspend,
};
d1289 1
a1289 1
ProcScreenSaverDispatch (ClientPtr client)
d1294 1
a1294 1
	return (*NormalVector[stuff->data])(client);
d1299 1
a1299 1
SProcScreenSaverQueryVersion (ClientPtr client)
d1302 1
a1302 3
    int	    n;

    swaps (&stuff->length, n);
d1304 1
a1304 1
    return ProcScreenSaverQueryVersion (client);
d1308 1
a1308 1
SProcScreenSaverQueryInfo (ClientPtr client)
d1311 1
a1311 3
    int	    n;

    swaps (&stuff->length, n);
d1313 2
a1314 2
    swapl (&stuff->drawable, n);
    return ProcScreenSaverQueryInfo (client);
d1318 1
a1318 1
SProcScreenSaverSelectInput (ClientPtr client)
d1321 1
a1321 3
    int	    n;

    swaps (&stuff->length, n);
d1323 3
a1325 3
    swapl (&stuff->drawable, n);
    swapl (&stuff->eventMask, n);
    return ProcScreenSaverSelectInput (client);
d1329 1
a1329 1
SProcScreenSaverSetAttributes (ClientPtr client)
d1332 1
a1332 3
    int	    n;

    swaps (&stuff->length, n);
d1334 8
a1341 8
    swapl (&stuff->drawable, n);
    swaps (&stuff->x, n);
    swaps (&stuff->y, n);
    swaps (&stuff->width, n);
    swaps (&stuff->height, n);
    swaps (&stuff->borderWidth, n);
    swapl (&stuff->visualID, n);
    swapl (&stuff->mask, n);
d1343 1
a1343 1
    return ProcScreenSaverSetAttributes (client);
d1347 1
a1347 1
SProcScreenSaverUnsetAttributes (ClientPtr client)
d1350 1
a1350 3
    int	    n;

    swaps (&stuff->length, n);
d1352 2
a1353 2
    swapl (&stuff->drawable, n);
    return ProcScreenSaverUnsetAttributes (client);
d1357 1
a1357 1
SProcScreenSaverSuspend (ClientPtr client)
a1358 1
    int n;
d1361 1
a1361 1
    swaps(&stuff->length, n);
d1363 1
a1363 2
    swapl(&stuff->suspend, n);
    return ProcScreenSaverSuspend (client);
d1366 6
a1371 8
static int (*SwappedVector[]) (ClientPtr /* client */) = {
    SProcScreenSaverQueryVersion,
    SProcScreenSaverQueryInfo,
    SProcScreenSaverSelectInput,
    SProcScreenSaverSetAttributes,
    SProcScreenSaverUnsetAttributes,
    SProcScreenSaverSuspend,
};
d1374 1
a1374 1
SProcScreenSaverDispatch (ClientPtr client)
d1379 1
a1379 1
	return (*SwappedVector[stuff->data])(client);
d1387 2
a1388 2
    int		    i;
    ScreenPtr	    pScreen;
d1391 1
a1391 1
	return;
d1394 6
a1399 9
    SaverEventType = CreateNewResourceType(ScreenSaverFreeEvents,
					   "SaverEvent");
    SuspendType = CreateNewResourceType(ScreenSaverFreeSuspend,
					"SaverSuspend");

    for (i = 0; i < screenInfo.numScreens; i++)
    {
	pScreen = screenInfo.screens[i];
	SetScreenPrivate (pScreen, NULL);
d1402 7
a1408 6
	(extEntry = AddExtension(ScreenSaverName, ScreenSaverNumberEvents, 0,
				 ProcScreenSaverDispatch, SProcScreenSaverDispatch,
				 NULL, StandardMinorOpcode)))
    {
	ScreenSaverEventBase = extEntry->eventBase;
	EventSwapVector[ScreenSaverEventBase] = (EventSwapPtr) SScreenSaverNotifyEvent;
@


1.7
log
@Update to xserver 1.11.2
@
text
@d930 1
a930 1
    values = malloc((len + 1) * sizeof (unsigned long));
a949 1
    pAttr->values = values;
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a64 14
static DISPATCH_PROC(ProcScreenSaverQueryInfo);
static DISPATCH_PROC(ProcScreenSaverDispatch);
static DISPATCH_PROC(ProcScreenSaverQueryVersion);
static DISPATCH_PROC(ProcScreenSaverSelectInput);
static DISPATCH_PROC(ProcScreenSaverSetAttributes);
static DISPATCH_PROC(ProcScreenSaverUnsetAttributes);
static DISPATCH_PROC(ProcScreenSaverSuspend);
static DISPATCH_PROC(SProcScreenSaverDispatch);
static DISPATCH_PROC(SProcScreenSaverQueryInfo);
static DISPATCH_PROC(SProcScreenSaverQueryVersion);
static DISPATCH_PROC(SProcScreenSaverSelectInput);
static DISPATCH_PROC(SProcScreenSaverSetAttributes);
static DISPATCH_PROC(SProcScreenSaverUnsetAttributes);
static DISPATCH_PROC(SProcScreenSaverSuspend);
a225 39
/****************
 * ScreenSaverExtensionInit
 *
 * Called from InitExtensions in main() or from QueryExtension() if the
 * extension is dynamically loaded.
 *
 ****************/

void
ScreenSaverExtensionInit(INITARGS)
{
    ExtensionEntry *extEntry;
    int		    i;
    ScreenPtr	    pScreen;

    if (!dixRegisterPrivateKey(&ScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
	return;

    AttrType = CreateNewResourceType(ScreenSaverFreeAttr, "SaverAttr");
    SaverEventType = CreateNewResourceType(ScreenSaverFreeEvents,
					   "SaverEvent");
    SuspendType = CreateNewResourceType(ScreenSaverFreeSuspend,
					"SaverSuspend");

    for (i = 0; i < screenInfo.numScreens; i++)
    {
	pScreen = screenInfo.screens[i];
	SetScreenPrivate (pScreen, NULL);
    }
    if (AttrType && SaverEventType && SuspendType &&
	(extEntry = AddExtension(ScreenSaverName, ScreenSaverNumberEvents, 0,
				 ProcScreenSaverDispatch, SProcScreenSaverDispatch,
				 NULL, StandardMinorOpcode)))
    {
	ScreenSaverEventBase = extEntry->eventBase;
	EventSwapVector[ScreenSaverEventBase] = (EventSwapPtr) SScreenSaverNotifyEvent;
    }
}

d1362 1
a1362 1
static DISPATCH_PROC((*NormalVector[])) = {
d1463 1
a1463 1
static DISPATCH_PROC((*SwappedVector[])) = {
d1480 31
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d229 2
a230 2
static int ScreenPrivateKeyIndex;
static DevPrivateKey ScreenPrivateKey = &ScreenPrivateKeyIndex;
d238 1
a238 1
#define New(t)	(xalloc (sizeof (t)))
d255 3
d289 1
a289 1
	xfree (pPriv);
d291 1
a291 1
	savedScreenInfo[pScreen->myNum].ExternalScreenSaver = NULL;
d310 1
a310 1
    savedScreenInfo[pScreen->myNum].ExternalScreenSaver = ScreenSaverHandle;
d349 1
a349 1
	xfree (pEv);
d393 2
a394 2
    xfree (pAttr->values);
    xfree (pAttr);
d413 1
a413 1
    xfree (pEv);
d452 1
a452 1
	    xfree (this);
a485 1
    ClientPtr			client;
a503 3
	client = pEv->client;
	if (client->clientGone)
	    continue;
a507 1
	ev.sequenceNumber = client->sequence;
d509 2
a510 2
	ev.root = WindowTable[pScreen->myNum]->drawable.id;
	ev.window = savedScreenInfo[pScreen->myNum].wid;
d513 1
a513 1
	WriteEventsToClient (client, 1, (xEvent *) &ev);
d565 1
a565 1
    pSaver = &savedScreenInfo[pScreen->myNum];
d586 1
a586 1
    pWin = CreateWindow (pSaver->wid, WindowTable[pScreen->myNum],
d645 1
a645 1
    installedMaps = xalloc (pScreen->maxInstalledCmaps * sizeof (Colormap));
d652 1
a652 1
    xfree ((char *) installedMaps);
d678 1
a678 1
    pSaver = &savedScreenInfo[pScreen->myNum];
d738 1
a738 1
    return (client->noClientException);
d762 1
a762 1
    pSaver = &savedScreenInfo[pDraw->pScreen->myNum];
d814 1
a814 1
    return (client->noClientException);
d872 1
a872 1
    pParent = WindowTable[pScreen->myNum];
d983 1
a983 1
    values = xalloc ((len + 1) * sizeof (unsigned long));
a1048 1
		    ret = (ret == BadValue) ? BadPixmap : ret;
a1085 1
		    ret = (ret == BadValue) ? BadPixmap : ret;
a1166 1
		ret = (ret == BadValue) ? BadColor : ret;
a1189 1
		    ret = (ret == BadValue) ? BadCursor : ret;
d1216 2
a1217 2
    if (pAttr) xfree (pAttr->values);
    xfree (pAttr);
d1278 1
a1278 1
		  return (status == BadValue) ? BadPixmap : status;
d1290 1
a1290 1
		  return (status == BadValue) ? BadPixmap : status;
d1302 1
a1302 1
		   return (status == BadValue) ? BadColor : status;
d1389 1
a1389 1
    this = xalloc (sizeof (ScreenSaverSuspensionRec));
d1401 1
a1401 1
	xfree (this);
d1412 1
a1412 1
    return (client->noClientException);
@


1.4
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@a29 2
#define NEED_REPLIES
#define NEED_EVENTS
a54 1
#ifdef HAVE_X11_EXTENSIONS_DPMSCONST_H
a55 4
#else
#define DPMS_SERVER
#include <X11/extensions/dpms.h>
#endif
d57 1
d145 1
a145 1
static RESTYPE EventType;   /* resource type for event masks */
d238 1
a238 1
#define New(t)	((t *) xalloc (sizeof (t)))
d255 5
a259 3
    AttrType = CreateNewResourceType(ScreenSaverFreeAttr);
    EventType = CreateNewResourceType(ScreenSaverFreeEvents);
    SuspendType = CreateNewResourceType(ScreenSaverFreeSuspend);
d266 1
a266 1
    if (AttrType && EventType && SuspendType &&
d277 1
a277 2
CheckScreenPrivate (pScreen)
    ScreenPtr	pScreen;
d293 1
a293 2
MakeScreenPrivate (pScreen)
    ScreenPtr	pScreen;
d312 1
a312 3
getEventMask (pScreen, client)
    ScreenPtr	pScreen;
    ClientPtr	client;
d326 1
a326 4
setEventMask (pScreen, client, mask)
    ScreenPtr	pScreen;
    ClientPtr	client;
    unsigned long   mask;
d344 1
a344 1
	FreeResource (pEv->resource, EventType);
d364 1
a364 1
	    if (!AddResource (pEv->resource, EventType, (pointer) pEv))
d373 1
a373 2
FreeAttrs (pAttr)
    ScreenSaverAttrPtr	pAttr;
d387 1
a387 2
FreeScreenAttr (pAttr)
    ScreenSaverAttrPtr	pAttr;
d395 1
a395 3
ScreenSaverFreeEvents (value, id)
    pointer value;
    XID id;
d416 1
a416 3
ScreenSaverFreeAttr (value, id)
    pointer value;
    XID id;
d477 1
a477 4
SendScreenSaverNotify (pScreen, state, forced)
    ScreenPtr			pScreen;
    int	    state;
    Bool    forced;
d520 2
a521 2
SScreenSaverNotifyEvent (from, to)
    xScreenSaverNotifyEvent *from, *to;
d534 1
a534 2
UninstallSaverColormap (pScreen)
    ScreenPtr	pScreen;
d538 1
d542 4
a545 2
	pCmap = (ColormapPtr) LookupIDByType (pPriv->installedMap, RT_COLORMAP);
	if (pCmap)
d553 1
a553 2
CreateSaverWindow (pScreen)
    ScreenPtr	pScreen;
d623 1
a626 1
	pAttr->pCursor->refcnt++;
d647 1
a647 2
    installedMaps = (Colormap *) xalloc (pScreen->maxInstalledCmaps *
						 sizeof (Colormap));
d659 3
a661 2
    pCmap = (ColormapPtr) LookupIDByType (wantMap, RT_COLORMAP);
    if (!pCmap)
d672 1
a672 2
DestroySaverWindow (pScreen)
    ScreenPtr	pScreen;
d693 1
a693 4
ScreenSaverHandle (pScreen, xstate, force)
    ScreenPtr	pScreen;
    int		xstate;
    Bool	force;
d724 1
a724 2
ProcScreenSaverQueryVersion (client)
    ClientPtr	client;
d733 2
a734 2
    rep.majorVersion = ScreenSaverMajorVersion;
    rep.minorVersion = ScreenSaverMinorVersion;
d744 1
a744 2
ProcScreenSaverQueryInfo (client)
    ClientPtr	client;
d820 1
a820 2
ProcScreenSaverSelectInput (client)
    ClientPtr	client;
d880 1
a880 1
    len = stuff->length -  (sizeof(xScreenSaverSetAttributesReq) >> 2);
d985 1
a985 1
    values = (unsigned long *) xalloc ((len + 1) * sizeof (unsigned long));
d1261 1
a1261 1
       int i, status = 0, len;
d1267 4
a1270 3
       if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
                   client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
           return BadDrawable;
d1272 1
a1272 1
       len = stuff->length -  (sizeof(xScreenSaverSetAttributesReq) >> 2);
d1280 5
a1284 3
             if(!(backPix = (PanoramiXRes*) SecurityLookupIDByType(
                  client, tmp, XRT_PIXMAP, DixReadAccess)))
                return BadPixmap;
d1292 5
a1296 3
             if(!(bordPix = (PanoramiXRes*) SecurityLookupIDByType(
                  client, tmp, XRT_PIXMAP, DixReadAccess)))
                return BadPixmap;
d1304 5
a1308 3
             if(!(cmap = (PanoramiXRes*) SecurityLookupIDByType(
                  client, tmp, XRT_COLORMAP, DixReadAccess)))
                 return BadColor;
d1343 1
a1343 1
       int i;
d1345 4
a1348 3
       if(!(draw = (PanoramiXRes *)SecurityLookupIDByClass(
                   client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
           return BadDrawable;
d1395 1
a1395 1
    this = (ScreenSaverSuspensionPtr) xalloc (sizeof (ScreenSaverSuspensionRec));
d1433 1
a1433 2
ProcScreenSaverDispatch (client)
    ClientPtr	client;
d1443 1
a1443 2
SProcScreenSaverQueryVersion (client)
    ClientPtr	client;
d1454 1
a1454 2
SProcScreenSaverQueryInfo (client)
    ClientPtr	client;
d1466 1
a1466 2
SProcScreenSaverSelectInput (client)
    ClientPtr	client;
d1479 1
a1479 2
SProcScreenSaverSetAttributes (client)
    ClientPtr	client;
d1499 1
a1499 2
SProcScreenSaverUnsetAttributes (client)
    ClientPtr	client;
d1532 1
a1532 2
SProcScreenSaverDispatch (client)
    ClientPtr	client;
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d57 3
d62 1
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a112 4
static void ScreenSaverResetProc (
	ExtensionEntry * /* extEntry */
	);

d231 2
a232 1
static DevPrivateKey ScreenPrivateKey = &ScreenPrivateKey;
d269 1
a269 1
				 ScreenSaverResetProc, StandardMinorOpcode)))
a275 7
/*ARGSUSED*/
static void
ScreenSaverResetProc (extEntry)
ExtensionEntry	*extEntry;
{
}

d744 1
a744 1
    register ClientPtr	client;
d747 1
a747 1
    register int		n;
d765 1
a765 1
    register ClientPtr	client;
d769 1
a769 1
    register int		n, rc;
d842 1
a842 1
    register ClientPtr	client;
d1057 1
a1057 1
		ret = dixLookupResource((pointer *)&pPixmap, pixID, RT_PIXMAP,
d1095 1
a1095 1
		ret = dixLookupResource((pointer *)&pPixmap, pixID, RT_PIXMAP,
d1189 1
a1189 1
	    ret = dixLookupResource((pointer *)&pCmap, cmap, RT_COLORMAP,
d1213 1
a1213 1
		ret = dixLookupResource((pointer *)&pCursor, cursorID,
@


1.1
log
@Initial revision
@
text
@d51 1
a64 3
#if 0
static unsigned char ScreenSaverReqCode = 0;
#endif
d67 1
a67 1
extern DISPATCH_PROC(ProcScreenSaverQueryInfo);
d235 1
a235 1
static int ScreenPrivateIndex;
d237 4
a240 2
#define GetScreenPrivate(s) ((ScreenSaverScreenPrivatePtr)(s)->devPrivates[ScreenPrivateIndex].ptr)
#define SetScreenPrivate(s,v) ((s)->devPrivates[ScreenPrivateIndex].ptr = (pointer) v);
a262 1
    ScreenPrivateIndex = AllocateScreenPrivateIndex ();
d269 1
a269 1
    if (AttrType && EventType && SuspendType && ScreenPrivateIndex != -1 &&
a273 3
#if 0
	ScreenSaverReqCode = (unsigned char)extEntry->base;
#endif
d453 2
a454 2
	SaveScreens (SCREEN_SAVER_FORCER, ScreenSaverReset);
	SaveScreens (SCREEN_SAVER_FORCER, ScreenSaverActive);
d672 1
a672 1
    installedMaps = (Colormap *) ALLOCATE_LOCAL (pScreen->maxInstalledCmaps *
d680 1
a680 1
    DEALLOCATE_LOCAL ((char *) installedMaps);
d773 1
a773 1
int
d779 1
a779 1
    register int		n;
d786 8
a793 3
    pDraw = (DrawablePtr) LookupDrawable (stuff->drawable, client);
    if (!pDraw)
	return BadDrawable;
d856 1
d859 10
a868 3
    pDraw = (DrawablePtr) LookupDrawable (stuff->drawable, client);
    if (!pDraw)
	return BadDrawable;
d883 1
a883 3
    int				ret;
    int				len;
    int				class, bw, depth;
d901 4
a904 3
    pDraw = (DrawablePtr) LookupDrawable (stuff->drawable, client);
    if (!pDraw)
	return BadDrawable;
d908 4
d1067 3
a1069 2
                pPixmap = (PixmapPtr)LookupIDByType(pixID, RT_PIXMAP);
                if (pPixmap != (PixmapPtr) NULL)
d1083 1
a1083 1
		    ret = BadPixmap;
d1105 3
a1107 2
		pPixmap = (PixmapPtr)LookupIDByType(pixID, RT_PIXMAP);
		if (pPixmap)
d1121 1
a1121 1
		    ret = BadPixmap;
d1199 3
a1201 2
	    pCmap = (ColormapPtr)LookupIDByType(cmap, RT_COLORMAP);
	    if (!pCmap)
d1203 1
a1203 1
		ret = BadColor;
d1223 3
a1225 2
	    	pCursor = (CursorPtr)LookupIDByType(cursorID, RT_CURSOR);
	    	if (!pCursor)
d1227 1
a1227 1
		    ret = BadCursor;
d1265 1
d1268 4
a1271 3
    pDraw = (DrawablePtr) LookupDrawable (stuff->drawable, client);
    if (!pDraw)
	return BadDrawable;
d1300 1
a1300 1
                   client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
d1312 1
a1312 1
                  client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d1322 1
a1322 1
                  client, tmp, XRT_PIXMAP, SecurityReadAccess)))
d1332 1
a1332 1
                  client, tmp, XRT_COLORMAP, SecurityReadAccess)))
d1349 1
a1349 2
            stuff->visualID = 
                     PanoramiXVisualTable[(orig_visual*MAXSCREENS) + i];
d1371 1
a1371 1
                   client, stuff->drawable, XRC_DRAWABLE, SecurityWriteAccess)))
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d69 1
a69 1
static DISPATCH_PROC(ProcScreenSaverQueryInfo);
d777 1
a777 1
static int
d783 1
a783 1
    register int		n, rc;
d790 3
a792 4
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixUnknownAccess);
    if (rc != Success)
	return rc;
a854 1
    int				rc;
d857 3
a859 4
    rc = dixLookupDrawable (&pDraw, stuff->drawable, client, 0,
			    DixUnknownAccess);
    if (rc != Success)
	return rc;
d874 3
a876 1
    int				ret, len, class, bw, depth;
d894 3
a896 4
    ret = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			    DixUnknownAccess);
    if (ret != Success)
	return ret;
a1248 1
    int				rc;
d1251 3
a1253 4
    rc = dixLookupDrawable(&pDraw, stuff->drawable, client, 0,
			   DixUnknownAccess);
    if (rc != Success)
	return rc;
d1282 1
a1282 1
                   client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
d1294 1
a1294 1
                  client, tmp, XRT_PIXMAP, DixReadAccess)))
d1304 1
a1304 1
                  client, tmp, XRT_PIXMAP, DixReadAccess)))
d1314 1
a1314 1
                  client, tmp, XRT_COLORMAP, DixReadAccess)))
d1354 1
a1354 1
                   client, stuff->drawable, XRC_DRAWABLE, DixWriteAccess)))
@

