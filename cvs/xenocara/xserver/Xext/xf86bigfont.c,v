head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.12
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.10
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.8
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.35;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2013.06.07.17.28.46;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.20;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.47;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.05.15.36.03;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.27.19.02.25;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.15.26.11;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.15.00.17.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.54;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.54;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.55;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * BIGFONT extension for sharing font metrics between clients (if possible)
 * and for transmitting font metrics to clients in a compressed form.
 *
 * Copyright (c) 1999-2000  Bruno Haible
 * Copyright (c) 1999-2000  The XFree86 Project, Inc.
 */

/* THIS IS NOT AN X CONSORTIUM STANDARD */

/*
 * Big fonts suffer from the following: All clients that have opened a
 * font can access the complete glyph metrics array (the XFontStruct member
 * `per_char') directly, without going through a macro. Moreover these
 * glyph metrics are ink metrics, i.e. are not redundant even for a
 * fixed-width font. For a Unicode font, the size of this array is 768 KB.
 *
 * Problems: 1. It eats a lot of memory in each client. 2. All this glyph
 * metrics data is piped through the socket when the font is opened.
 *
 * This extension addresses these two problems for local clients, by using
 * shared memory. It also addresses the second problem for non-local clients,
 * by compressing the data before transmit by a factor of nearly 6.
 *
 * If you use this extension, your OS ought to nicely support shared memory.
 * This means: Shared memory should be swappable to the swap, and the limits
 * should be high enough (SHMMNI at least 64, SHMMAX at least 768 KB,
 * SHMALL at least 48 MB). It is a plus if your OS allows shmat() calls
 * on segments that have already been marked "removed", because it permits
 * these segments to be cleaned up by the OS if the X server is killed with
 * signal SIGKILL.
 *
 * This extension is transparently exploited by Xlib (functions XQueryFont,
 * XLoadQueryFont).
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <sys/types.h>
#ifdef HAS_SHM
#if defined(linux) && (!defined(__GNU_LIBRARY__) || __GNU_LIBRARY__ < 2)
/* libc4 does not define __GNU_LIBRARY__, libc5 defines __GNU_LIBRARY__ as 1 */
/* Linux libc4 and libc5 only (because glibc doesn't include kernel headers):
   Linux 2.0.x and 2.2.x define SHMLBA as PAGE_SIZE, but forget to define
   PAGE_SIZE. It is defined in <asm/page.h>. */
#include <asm/page.h>
#endif
#ifdef SVR4
#include <sys/sysmacros.h>
#endif
#if defined(__CYGWIN__)
#include <sys/param.h>
#include <sys/sysmacros.h>
#endif
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <errno.h>
#endif

#include <X11/X.h>
#include <X11/Xproto.h>
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "gcstruct.h"
#include "dixfontstr.h"
#include "extnsionst.h"
#include "extinit.h"
#include "protocol-versions.h"

#include <X11/extensions/xf86bigfproto.h>
#include "xf86bigfontsrv.h"

static void XF86BigfontResetProc(ExtensionEntry *       /* extEntry */
    );

#ifdef HAS_SHM

/* A random signature, transmitted to the clients so they can verify that the
   shared memory segment they are attaching to was really established by the
   X server they are talking to. */
static CARD32 signature;

/* Index for additional information stored in a FontRec's devPrivates array. */
static int FontShmdescIndex;

static unsigned int pagesize;

static Bool badSysCall = FALSE;

#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__CYGWIN__) || defined(__DragonFly__)

#include <sys/signal.h>

static void
SigSysHandler(int signo)
{
    badSysCall = TRUE;
}

static Bool
CheckForShmSyscall(void)
{
    void (*oldHandler) (int);
    int shmid = -1;

    /* If no SHM support in the kernel, the bad syscall will generate SIGSYS */
    oldHandler = signal(SIGSYS, SigSysHandler);

    badSysCall = FALSE;
    shmid = shmget(IPC_PRIVATE, 4096, IPC_CREAT);
    if (shmid != -1) {
        /* Successful allocation - clean up */
        shmctl(shmid, IPC_RMID, NULL);
    }
    else {
        /* Allocation failed */
        badSysCall = TRUE;
    }
    signal(SIGSYS, oldHandler);
    return !badSysCall;
}

#define MUST_CHECK_FOR_SHM_SYSCALL

#endif

#endif

/* ========== Management of shared memory segments ========== */

#ifdef HAS_SHM

#ifdef __linux__
/* On Linux, shared memory marked as "removed" can still be attached.
   Nice feature, because the kernel will automatically free the associated
   storage when the server and all clients are gone. */
#define EARLY_REMOVE
#endif

typedef struct _ShmDesc {
    struct _ShmDesc *next;
    struct _ShmDesc **prev;
    int shmid;
    char *attach_addr;
} ShmDescRec, *ShmDescPtr;

static ShmDescPtr ShmList = (ShmDescPtr) NULL;

static ShmDescPtr
shmalloc(unsigned int size)
{
    ShmDescPtr pDesc;
    int shmid;
    char *addr;

#ifdef MUST_CHECK_FOR_SHM_SYSCALL
    if (pagesize == 0)
        return (ShmDescPtr) NULL;
#endif

    /* On some older Linux systems, the number of shared memory segments
       system-wide is 127. In Linux 2.4, it is 4095.
       Therefore there is a tradeoff to be made between allocating a
       shared memory segment on one hand, and allocating memory and piping
       the glyph metrics on the other hand. If the glyph metrics size is
       small, we prefer the traditional way. */
    if (size < 3500)
        return (ShmDescPtr) NULL;

    pDesc = malloc(sizeof(ShmDescRec));
    if (!pDesc)
        return (ShmDescPtr) NULL;

    size = (size + pagesize - 1) & -pagesize;
    shmid = shmget(IPC_PRIVATE, size, S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH);
    if (shmid == -1) {
        ErrorF(XF86BIGFONTNAME " extension: shmget() failed, size = %u, %s\n",
               size, strerror(errno));
        free(pDesc);
        return (ShmDescPtr) NULL;
    }

    if ((addr = shmat(shmid, 0, 0)) == (char *) -1) {
        ErrorF(XF86BIGFONTNAME " extension: shmat() failed, size = %u, %s\n",
               size, strerror(errno));
        shmctl(shmid, IPC_RMID, (void *) 0);
        free(pDesc);
        return (ShmDescPtr) NULL;
    }

#ifdef EARLY_REMOVE
    shmctl(shmid, IPC_RMID, (void *) 0);
#endif

    pDesc->shmid = shmid;
    pDesc->attach_addr = addr;
    if (ShmList)
        ShmList->prev = &pDesc->next;
    pDesc->next = ShmList;
    pDesc->prev = &ShmList;
    ShmList = pDesc;

    return pDesc;
}

static void
shmdealloc(ShmDescPtr pDesc)
{
#ifndef EARLY_REMOVE
    shmctl(pDesc->shmid, IPC_RMID, (void *) 0);
#endif
    shmdt(pDesc->attach_addr);

    if (pDesc->next)
        pDesc->next->prev = pDesc->prev;
    *pDesc->prev = pDesc->next;
    free(pDesc);
}

#endif

/* Called when a font is closed. */
void
XF86BigfontFreeFontShm(FontPtr pFont)
{
#ifdef HAS_SHM
    ShmDescPtr pDesc;

    /* If during shutdown of the server, XF86BigfontCleanup() has already
     * called shmdealloc() for all segments, we don't need to do it here.
     */
    if (!ShmList)
        return;

    pDesc = (ShmDescPtr) FontGetPrivate(pFont, FontShmdescIndex);
    if (pDesc)
        shmdealloc(pDesc);
#endif
}

/* Called upon fatal signal. */
void
XF86BigfontCleanup(void)
{
#ifdef HAS_SHM
    while (ShmList)
        shmdealloc(ShmList);
#endif
}

/* Called when a server generation dies. */
static void
XF86BigfontResetProc(ExtensionEntry * extEntry)
{
    /* This function is normally called from CloseDownExtensions(), called
     * from main(). It will be followed by a call to FreeAllResources(),
     * which will call XF86BigfontFreeFontShm() for each font. Thus it
     * appears that we do not need to do anything in this function. --
     * But I prefer to write robust code, and not keep shared memory lying
     * around when it's not needed any more. (Someone might close down the
     * extension without calling FreeAllResources()...)
     */
    XF86BigfontCleanup();
}

/* ========== Handling of extension specific requests ========== */

static int
ProcXF86BigfontQueryVersion(ClientPtr client)
{
    xXF86BigfontQueryVersionReply reply;

    REQUEST_SIZE_MATCH(xXF86BigfontQueryVersionReq);
    reply = (xXF86BigfontQueryVersionReply) {
        .type = X_Reply,
        .sequenceNumber = client->sequence,
        .length = 0,
        .majorVersion = SERVER_XF86BIGFONT_MAJOR_VERSION,
        .minorVersion = SERVER_XF86BIGFONT_MINOR_VERSION,
        .uid = geteuid(),
        .gid = getegid(),
#ifdef HAS_SHM
        .signature = signature,
        .capabilities = (client->local && !client->swapped)
                         ? XF86Bigfont_CAP_LocalShm : 0
#else
        .signature = 0,
        .capabilities = 0
#endif
    };
    if (client->swapped) {
        swaps(&reply.sequenceNumber);
        swapl(&reply.length);
        swaps(&reply.majorVersion);
        swaps(&reply.minorVersion);
        swapl(&reply.uid);
        swapl(&reply.gid);
        swapl(&reply.signature);
    }
    WriteToClient(client, sizeof(xXF86BigfontQueryVersionReply), &reply);
    return Success;
}

static void
swapCharInfo(xCharInfo * pCI)
{
    swaps(&pCI->leftSideBearing);
    swaps(&pCI->rightSideBearing);
    swaps(&pCI->characterWidth);
    swaps(&pCI->ascent);
    swaps(&pCI->descent);
    swaps(&pCI->attributes);
}

/* static CARD32 hashCI (xCharInfo *p); */
#define hashCI(p) \
	(CARD32)(((p->leftSideBearing << 27) + (p->leftSideBearing >> 5) + \
	          (p->rightSideBearing << 23) + (p->rightSideBearing >> 9) + \
	          (p->characterWidth << 16) + \
	          (p->ascent << 11) + (p->descent << 6)) ^ p->attributes)

static int
ProcXF86BigfontQueryFont(ClientPtr client)
{
    FontPtr pFont;

    REQUEST(xXF86BigfontQueryFontReq);
    CARD32 stuff_flags;
    xCharInfo *pmax;
    xCharInfo *pmin;
    int nCharInfos;
    int shmid;

#ifdef HAS_SHM
    ShmDescPtr pDesc = NULL;
#else
#define pDesc 0
#endif
    xCharInfo *pCI;
    CARD16 *pIndex2UniqIndex;
    CARD16 *pUniqIndex2Index;
    CARD32 nUniqCharInfos;

#if 0
    REQUEST_SIZE_MATCH(xXF86BigfontQueryFontReq);
#else
    switch (client->req_len) {
    case 2:                    /* client with version 1.0 libX11 */
        stuff_flags = (client->local &&
                       !client->swapped ? XF86Bigfont_FLAGS_Shm : 0);
        break;
    case 3:                    /* client with version 1.1 libX11 */
        stuff_flags = stuff->flags;
        break;
    default:
        return BadLength;
    }
#endif
    if (dixLookupFontable(&pFont, stuff->id, client, DixGetAttrAccess) !=
        Success)
        return BadFont;         /* procotol spec says only error is BadFont */

    pmax = FONTINKMAX(pFont);
    pmin = FONTINKMIN(pFont);
    nCharInfos =
        (pmax->rightSideBearing == pmin->rightSideBearing
         && pmax->leftSideBearing == pmin->leftSideBearing
         && pmax->descent == pmin->descent
         && pmax->ascent == pmin->ascent
         && pmax->characterWidth == pmin->characterWidth)
        ? 0 : N2dChars(pFont);
    shmid = -1;
    pCI = NULL;
    pIndex2UniqIndex = NULL;
    pUniqIndex2Index = NULL;
    nUniqCharInfos = 0;

    if (nCharInfos > 0) {
#ifdef HAS_SHM
        if (!badSysCall)
            pDesc = (ShmDescPtr) FontGetPrivate(pFont, FontShmdescIndex);
        if (pDesc) {
            pCI = (xCharInfo *) pDesc->attach_addr;
            if (stuff_flags & XF86Bigfont_FLAGS_Shm)
                shmid = pDesc->shmid;
        }
        else {
            if (stuff_flags & XF86Bigfont_FLAGS_Shm && !badSysCall)
                pDesc = shmalloc(nCharInfos * sizeof(xCharInfo)
                                 + sizeof(CARD32));
            if (pDesc) {
                pCI = (xCharInfo *) pDesc->attach_addr;
                shmid = pDesc->shmid;
            }
            else {
#endif
                pCI = xallocarray(nCharInfos, sizeof(xCharInfo));
                if (!pCI)
                    return BadAlloc;
#ifdef HAS_SHM
            }
#endif
            /* Fill nCharInfos starting at pCI. */
            {
                xCharInfo *prCI = pCI;
                int ninfos = 0;
                int ncols = pFont->info.lastCol - pFont->info.firstCol + 1;
                int row;

                for (row = pFont->info.firstRow;
                     row <= pFont->info.lastRow && ninfos < nCharInfos; row++) {
                    unsigned char chars[512];
                    xCharInfo *tmpCharInfos[256];
                    unsigned long count;
                    int col;
                    unsigned long i;

                    i = 0;
                    for (col = pFont->info.firstCol;
                         col <= pFont->info.lastCol; col++) {
                        chars[i++] = row;
                        chars[i++] = col;
                    }
                    (*pFont->get_metrics) (pFont, ncols, chars, TwoD16Bit,
                                           &count, tmpCharInfos);
                    for (i = 0; i < count && ninfos < nCharInfos; i++) {
                        *prCI++ = *tmpCharInfos[i];
                        ninfos++;
                    }
                }
            }
#ifdef HAS_SHM
            if (pDesc && !badSysCall) {
                *(CARD32 *) (pCI + nCharInfos) = signature;
                if (!FontSetPrivate(pFont, FontShmdescIndex, pDesc)) {
                    shmdealloc(pDesc);
                    return BadAlloc;
                }
            }
        }
#endif
        if (shmid == -1) {
            /* Cannot use shared memory, so remove-duplicates the xCharInfos
               using a temporary hash table. */
            /* Note that CARD16 is suitable as index type, because
               nCharInfos <= 0x10000. */
            CARD32 hashModulus;
            CARD16 *pHash2UniqIndex;
            CARD16 *pUniqIndex2NextUniqIndex;
            CARD32 NextIndex;
            CARD32 NextUniqIndex;
            CARD16 *tmp;
            CARD32 i, j;

            hashModulus = 67;
            if (hashModulus > nCharInfos + 1)
                hashModulus = nCharInfos + 1;

            tmp = xallocarray(4 * nCharInfos + 1, sizeof(CARD16));
            if (!tmp) {
                if (!pDesc)
                    free(pCI);
                return BadAlloc;
            }
            pIndex2UniqIndex = tmp;
            /* nCharInfos elements */
            pUniqIndex2Index = tmp + nCharInfos;
            /* max. nCharInfos elements */
            pUniqIndex2NextUniqIndex = tmp + 2 * nCharInfos;
            /* max. nCharInfos elements */
            pHash2UniqIndex = tmp + 3 * nCharInfos;
            /* hashModulus (<= nCharInfos+1) elements */

            /* Note that we can use 0xffff as end-of-list indicator, because
               even if nCharInfos = 0x10000, 0xffff can not occur as valid
               entry before the last element has been inserted. And once the
               last element has been inserted, we don't need the hash table
               any more. */
            for (j = 0; j < hashModulus; j++)
                pHash2UniqIndex[j] = (CARD16) (-1);

            NextUniqIndex = 0;
            for (NextIndex = 0; NextIndex < nCharInfos; NextIndex++) {
                xCharInfo *p = &pCI[NextIndex];
                CARD32 hashCode = hashCI(p) % hashModulus;

                for (i = pHash2UniqIndex[hashCode];
                     i != (CARD16) (-1); i = pUniqIndex2NextUniqIndex[i]) {
                    j = pUniqIndex2Index[i];
                    if (pCI[j].leftSideBearing == p->leftSideBearing
                        && pCI[j].rightSideBearing == p->rightSideBearing
                        && pCI[j].characterWidth == p->characterWidth
                        && pCI[j].ascent == p->ascent
                        && pCI[j].descent == p->descent
                        && pCI[j].attributes == p->attributes)
                        break;
                }
                if (i != (CARD16) (-1)) {
                    /* Found *p at Index j, UniqIndex i */
                    pIndex2UniqIndex[NextIndex] = i;
                }
                else {
                    /* Allocate a new entry in the Uniq table */
                    if (hashModulus <= 2 * NextUniqIndex
                        && hashModulus < nCharInfos + 1) {
                        /* Time to increate hash table size */
                        hashModulus = 2 * hashModulus + 1;
                        if (hashModulus > nCharInfos + 1)
                            hashModulus = nCharInfos + 1;
                        for (j = 0; j < hashModulus; j++)
                            pHash2UniqIndex[j] = (CARD16) (-1);
                        for (i = 0; i < NextUniqIndex; i++)
                            pUniqIndex2NextUniqIndex[i] = (CARD16) (-1);
                        for (i = 0; i < NextUniqIndex; i++) {
                            j = pUniqIndex2Index[i];
                            p = &pCI[j];
                            hashCode = hashCI(p) % hashModulus;
                            pUniqIndex2NextUniqIndex[i] =
                                pHash2UniqIndex[hashCode];
                            pHash2UniqIndex[hashCode] = i;
                        }
                        p = &pCI[NextIndex];
                        hashCode = hashCI(p) % hashModulus;
                    }
                    i = NextUniqIndex++;
                    pUniqIndex2NextUniqIndex[i] = pHash2UniqIndex[hashCode];
                    pHash2UniqIndex[hashCode] = i;
                    pUniqIndex2Index[i] = NextIndex;
                    pIndex2UniqIndex[NextIndex] = i;
                }
            }
            nUniqCharInfos = NextUniqIndex;
            /* fprintf(stderr, "font metrics: nCharInfos = %d, nUniqCharInfos = %d, hashModulus = %d\n", nCharInfos, nUniqCharInfos, hashModulus); */
        }
    }

    {
        int nfontprops = pFont->info.nprops;
        int rlength = sizeof(xXF86BigfontQueryFontReply)
            + nfontprops * sizeof(xFontProp)
            + (nCharInfos > 0 && shmid == -1
               ? nUniqCharInfos * sizeof(xCharInfo)
               + (nCharInfos + 1) / 2 * 2 * sizeof(CARD16)
               : 0);
        xXF86BigfontQueryFontReply *reply = calloc(1, rlength);
        char *p;

        if (!reply) {
            if (nCharInfos > 0) {
                if (shmid == -1)
                    free(pIndex2UniqIndex);
                if (!pDesc)
                    free(pCI);
            }
            return BadAlloc;
        }
        reply->type = X_Reply;
        reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
        reply->sequenceNumber = client->sequence;
        reply->minBounds = pFont->info.ink_minbounds;
        reply->maxBounds = pFont->info.ink_maxbounds;
        reply->minCharOrByte2 = pFont->info.firstCol;
        reply->maxCharOrByte2 = pFont->info.lastCol;
        reply->defaultChar = pFont->info.defaultCh;
        reply->nFontProps = pFont->info.nprops;
        reply->drawDirection = pFont->info.drawDirection;
        reply->minByte1 = pFont->info.firstRow;
        reply->maxByte1 = pFont->info.lastRow;
        reply->allCharsExist = pFont->info.allExist;
        reply->fontAscent = pFont->info.fontAscent;
        reply->fontDescent = pFont->info.fontDescent;
        reply->nCharInfos = nCharInfos;
        reply->nUniqCharInfos = nUniqCharInfos;
        reply->shmid = shmid;
        reply->shmsegoffset = 0;
        if (client->swapped) {
            swaps(&reply->sequenceNumber);
            swapl(&reply->length);
            swapCharInfo(&reply->minBounds);
            swapCharInfo(&reply->maxBounds);
            swaps(&reply->minCharOrByte2);
            swaps(&reply->maxCharOrByte2);
            swaps(&reply->defaultChar);
            swaps(&reply->nFontProps);
            swaps(&reply->fontAscent);
            swaps(&reply->fontDescent);
            swapl(&reply->nCharInfos);
            swapl(&reply->nUniqCharInfos);
            swapl(&reply->shmid);
            swapl(&reply->shmsegoffset);
        }
        p = (char *) &reply[1];
        {
            FontPropPtr pFP;
            xFontProp *prFP;
            int i;

            for (i = 0, pFP = pFont->info.props, prFP = (xFontProp *) p;
                 i < nfontprops; i++, pFP++, prFP++) {
                prFP->name = pFP->name;
                prFP->value = pFP->value;
                if (client->swapped) {
                    swapl(&prFP->name);
                    swapl(&prFP->value);
                }
            }
            p = (char *) prFP;
        }
        if (nCharInfos > 0 && shmid == -1) {
            xCharInfo *pci;
            CARD16 *ps;
            int i, j;

            pci = (xCharInfo *) p;
            for (i = 0; i < nUniqCharInfos; i++, pci++) {
                *pci = pCI[pUniqIndex2Index[i]];
                if (client->swapped)
                    swapCharInfo(pci);
            }
            ps = (CARD16 *) pci;
            for (j = 0; j < nCharInfos; j++, ps++) {
                *ps = pIndex2UniqIndex[j];
                if (client->swapped) {
                    swaps(ps);
                }
            }
        }
        WriteToClient(client, rlength, reply);
        free(reply);
        if (nCharInfos > 0) {
            if (shmid == -1)
                free(pIndex2UniqIndex);
            if (!pDesc)
                free(pCI);
        }
        return Success;
    }
}

static int
ProcXF86BigfontDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_XF86BigfontQueryVersion:
        return ProcXF86BigfontQueryVersion(client);
    case X_XF86BigfontQueryFont:
        return ProcXF86BigfontQueryFont(client);
    default:
        return BadRequest;
    }
}

static int
SProcXF86BigfontQueryVersion(ClientPtr client)
{
    REQUEST(xXF86BigfontQueryVersionReq);

    swaps(&stuff->length);
    return ProcXF86BigfontQueryVersion(client);
}

static int
SProcXF86BigfontQueryFont(ClientPtr client)
{
    REQUEST(xXF86BigfontQueryFontReq);

    swaps(&stuff->length);
    REQUEST_SIZE_MATCH(xXF86BigfontQueryFontReq);
    swapl(&stuff->id);
    return ProcXF86BigfontQueryFont(client);
}

static int
SProcXF86BigfontDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_XF86BigfontQueryVersion:
        return SProcXF86BigfontQueryVersion(client);
    case X_XF86BigfontQueryFont:
        return SProcXF86BigfontQueryFont(client);
    default:
        return BadRequest;
    }
}

void
XFree86BigfontExtensionInit(void)
{
    if (AddExtension(XF86BIGFONTNAME,
                     XF86BigfontNumberEvents,
                     XF86BigfontNumberErrors,
                     ProcXF86BigfontDispatch,
                     SProcXF86BigfontDispatch,
                     XF86BigfontResetProc, StandardMinorOpcode)) {
#ifdef HAS_SHM
#ifdef MUST_CHECK_FOR_SHM_SYSCALL
        /*
         * Note: Local-clients will not be optimized without shared memory
         * support. Remote-client optimization does not depend on shared
         * memory support.  Thus, the extension is still registered even
         * when shared memory support is not functional.
         */
        if (!CheckForShmSyscall()) {
            ErrorF(XF86BIGFONTNAME
                   " extension local-client optimization disabled due to lack of shared memory support in the kernel\n");
            return;
        }
#endif

        srand((unsigned int) time(NULL));
        signature = ((unsigned int) (65536.0 / (RAND_MAX + 1.0) * rand()) << 16)
            + (unsigned int) (65536.0 / (RAND_MAX + 1.0) * rand());
        /* fprintf(stderr, "signature = 0x%08X\n", signature); */

        FontShmdescIndex = AllocateFontPrivateIndex();

#if !defined(CSRG_BASED) && !defined(__CYGWIN__)
        pagesize = SHMLBA;
#else
#ifdef _SC_PAGESIZE
        pagesize = sysconf(_SC_PAGESIZE);
#else
        pagesize = getpagesize();
#endif
#endif
#endif
    }
}
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d404 1
a404 1
                pCI = malloc(nCharInfos * sizeof(xCharInfo));
d466 1
a466 1
            tmp = malloc((4 * nCharInfos + 1) * sizeof(CARD16));
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d74 1
d281 8
a288 7
    reply.type = X_Reply;
    reply.length = 0;
    reply.sequenceNumber = client->sequence;
    reply.majorVersion = SERVER_XF86BIGFONT_MAJOR_VERSION;
    reply.minorVersion = SERVER_XF86BIGFONT_MINOR_VERSION;
    reply.uid = geteuid();
    reply.gid = getegid();
d290 3
a292 1
    reply.signature = signature;
d294 2
a295 1
    reply.signature = 0;        /* This is redundant. Avoids uninitialized memory. */
d297 1
a297 7
    reply.capabilities =
#ifdef HAS_SHM
        (LocalClient(client) && !client->swapped ? XF86Bigfont_CAP_LocalShm : 0)
#else
        0
#endif
        ;                       /* may add more bits here in future versions */
a298 2
        char tmp;

d307 1
a307 2
    WriteToClient(client,
                  sizeof(xXF86BigfontQueryVersionReply), (char *) &reply);
a313 2
    char tmp;

d356 1
a356 1
        stuff_flags = (LocalClient(client) &&
d552 1
a552 1
        xXF86BigfontQueryFontReply *reply = malloc(rlength);
a583 2
            char tmp;

a609 2
                    char tmp;

a630 2
                    char tmp;

d635 1
a635 1
        WriteToClient(client, rlength, (char *) reply);
a665 1
    char tmp;
a674 1
    char tmp;
@


1.7
log
@Update to xserver 1.11.2
@
text
@d53 1
a53 1
#if defined(__CYGWIN__) 
d79 1
a79 2
static void XF86BigfontResetProc(
    ExtensionEntry *	/* extEntry */
a81 1

d101 1
a101 2
SigSysHandler(
     int signo)
d109 1
a109 1
    void (*oldHandler)(int);
d117 1
a117 2
    if (shmid != -1)
    {
d119 1
a119 1
	shmctl(shmid, IPC_RMID, NULL);
d121 1
a121 2
    else
    {
d156 1
a156 2
shmalloc(
    unsigned int size)
d164 1
a164 1
	return (ShmDescPtr) NULL;
d174 1
a174 1
	return (ShmDescPtr) NULL;
d178 1
a178 1
	return (ShmDescPtr) NULL;
d180 1
a180 1
    size = (size + pagesize-1) & -pagesize;
d183 4
a186 4
	ErrorF(XF86BIGFONTNAME " extension: shmget() failed, size = %u, %s\n",
	       size, strerror(errno));
	free(pDesc);
	return (ShmDescPtr) NULL;
d189 6
a194 6
    if ((addr = shmat(shmid, 0, 0)) == (char *)-1) {
	ErrorF(XF86BIGFONTNAME " extension: shmat() failed, size = %u, %s\n",
	       size, strerror(errno));
	shmctl(shmid, IPC_RMID, (void *) 0);
	free(pDesc);
	return (ShmDescPtr) NULL;
d203 2
a204 1
    if (ShmList) ShmList->prev = &pDesc->next;
d213 1
a213 2
shmdealloc(
    ShmDescPtr pDesc)
d220 2
a221 1
    if (pDesc->next) pDesc->next->prev = pDesc->prev;
d230 1
a230 2
XF86BigfontFreeFontShm(
    FontPtr pFont)
d239 1
a239 1
	return;
d243 1
a243 1
	shmdealloc(pDesc);
d253 1
a253 1
	shmdealloc(ShmList);
d259 1
a259 2
XF86BigfontResetProc(
    ExtensionEntry* extEntry)
a271 1

d275 1
a275 2
ProcXF86BigfontQueryVersion(
    ClientPtr client)
d290 1
a290 1
    reply.signature = 0; /* This is redundant. Avoids uninitialized memory. */
d294 1
a294 1
	(LocalClient(client) && !client->swapped ? XF86Bigfont_CAP_LocalShm : 0)
d296 1
a296 1
	0
d298 1
a298 1
	; /* may add more bits here in future versions */
d300 9
a308 8
	char tmp;
	swaps(&reply.sequenceNumber, tmp);
	swapl(&reply.length, tmp);
	swaps(&reply.majorVersion, tmp);
	swaps(&reply.minorVersion, tmp);
	swapl(&reply.uid, tmp);
	swapl(&reply.gid, tmp);
	swapl(&reply.signature, tmp);
d311 1
a311 1
		  sizeof(xXF86BigfontQueryVersionReply), (char *)&reply);
d316 1
a316 2
swapCharInfo(
    xCharInfo *pCI)
d320 6
a325 6
    swaps(&pCI->leftSideBearing, tmp);
    swaps(&pCI->rightSideBearing, tmp);
    swaps(&pCI->characterWidth, tmp);
    swaps(&pCI->ascent, tmp);
    swaps(&pCI->descent, tmp);
    swaps(&pCI->attributes, tmp);
d336 1
a336 2
ProcXF86BigfontQueryFont(
    ClientPtr client)
d339 1
d342 2
a343 2
    xCharInfo* pmax;
    xCharInfo* pmin;
d346 1
d352 3
a354 3
    xCharInfo* pCI;
    CARD16* pIndex2UniqIndex;
    CARD16* pUniqIndex2Index;
d361 9
a369 8
	case 2: /* client with version 1.0 libX11 */
	    stuff_flags = (LocalClient(client) && !client->swapped ? XF86Bigfont_FLAGS_Shm : 0);
	    break;
	case 3: /* client with version 1.1 libX11 */
	    stuff_flags = stuff->flags;
	    break;
	default:
	    return BadLength;
d372 3
a374 2
    if (dixLookupFontable(&pFont, stuff->id, client, DixGetAttrAccess) != Success)
	return BadFont;    /* procotol spec says only error is BadFont */
d379 6
a384 6
       (pmax->rightSideBearing == pmin->rightSideBearing
        && pmax->leftSideBearing == pmin->leftSideBearing
        && pmax->descent == pmin->descent
        && pmax->ascent == pmin->ascent
        && pmax->characterWidth == pmin->characterWidth)
       ? 0 : N2dChars(pFont);
d393 155
a547 150
	if (!badSysCall)
	    pDesc = (ShmDescPtr) FontGetPrivate(pFont, FontShmdescIndex);
	if (pDesc) {
	    pCI = (xCharInfo *) pDesc->attach_addr;
	    if (stuff_flags & XF86Bigfont_FLAGS_Shm)
		shmid = pDesc->shmid;
	} else {
	    if (stuff_flags & XF86Bigfont_FLAGS_Shm && !badSysCall)
		pDesc = shmalloc(nCharInfos * sizeof(xCharInfo)
				 + sizeof(CARD32));
	    if (pDesc) {
		pCI = (xCharInfo *) pDesc->attach_addr;
		shmid = pDesc->shmid;
	    } else {
#endif
		pCI = malloc(nCharInfos * sizeof(xCharInfo));
		if (!pCI)
		    return BadAlloc;
#ifdef HAS_SHM
	    }
#endif
	    /* Fill nCharInfos starting at pCI. */
	    {
		xCharInfo* prCI = pCI;
		int ninfos = 0;
		int ncols = pFont->info.lastCol - pFont->info.firstCol + 1;
		int row;
		for (row = pFont->info.firstRow;
		     row <= pFont->info.lastRow && ninfos < nCharInfos;
		     row++) {
		    unsigned char chars[512];
		    xCharInfo* tmpCharInfos[256];
		    unsigned long count;
		    int col;
		    unsigned long i;
		    i = 0;
		    for (col = pFont->info.firstCol;
			 col <= pFont->info.lastCol;
			 col++) {
			chars[i++] = row;
			chars[i++] = col;
		    }
		    (*pFont->get_metrics) (pFont, ncols, chars, TwoD16Bit,
					   &count, tmpCharInfos);
		    for (i = 0; i < count && ninfos < nCharInfos; i++) {
			*prCI++ = *tmpCharInfos[i];
			ninfos++;
		    }
		}
	    }
#ifdef HAS_SHM
	    if (pDesc && !badSysCall) {
		*(CARD32 *)(pCI + nCharInfos) = signature;
		if (!FontSetPrivate(pFont, FontShmdescIndex, pDesc)) {
		    shmdealloc(pDesc);
		    return BadAlloc;
		}
	    }
	}
#endif
	if (shmid == -1) {
	    /* Cannot use shared memory, so remove-duplicates the xCharInfos
	       using a temporary hash table. */
	    /* Note that CARD16 is suitable as index type, because
	       nCharInfos <= 0x10000. */
	    CARD32 hashModulus;
	    CARD16* pHash2UniqIndex;
	    CARD16* pUniqIndex2NextUniqIndex;
	    CARD32 NextIndex;
	    CARD32 NextUniqIndex;
	    CARD16* tmp;
	    CARD32 i, j;

	    hashModulus = 67;
	    if (hashModulus > nCharInfos+1)
		hashModulus = nCharInfos+1;

	    tmp = malloc((4*nCharInfos+1) * sizeof(CARD16));
	    if (!tmp) {
		if (!pDesc) free(pCI);
		return BadAlloc;
	    }
	    pIndex2UniqIndex = tmp;
		/* nCharInfos elements */
	    pUniqIndex2Index = tmp + nCharInfos;
		/* max. nCharInfos elements */
	    pUniqIndex2NextUniqIndex = tmp + 2*nCharInfos;
		/* max. nCharInfos elements */
	    pHash2UniqIndex = tmp + 3*nCharInfos;
		/* hashModulus (<= nCharInfos+1) elements */

	    /* Note that we can use 0xffff as end-of-list indicator, because
	       even if nCharInfos = 0x10000, 0xffff can not occur as valid
	       entry before the last element has been inserted. And once the
	       last element has been inserted, we don't need the hash table
	       any more. */
	    for (j = 0; j < hashModulus; j++)
		pHash2UniqIndex[j] = (CARD16)(-1);

	    NextUniqIndex = 0;
	    for (NextIndex = 0; NextIndex < nCharInfos; NextIndex++) {
		xCharInfo* p = &pCI[NextIndex];
		CARD32 hashCode = hashCI(p) % hashModulus;
		for (i = pHash2UniqIndex[hashCode];
		     i != (CARD16)(-1);
		     i = pUniqIndex2NextUniqIndex[i]) {
		    j = pUniqIndex2Index[i];
		    if (pCI[j].leftSideBearing == p->leftSideBearing
			&& pCI[j].rightSideBearing == p->rightSideBearing
			&& pCI[j].characterWidth == p->characterWidth
			&& pCI[j].ascent == p->ascent
			&& pCI[j].descent == p->descent
			&& pCI[j].attributes == p->attributes)
			break;
		}
		if (i != (CARD16)(-1)) {
		    /* Found *p at Index j, UniqIndex i */
		    pIndex2UniqIndex[NextIndex] = i;
		} else {
		    /* Allocate a new entry in the Uniq table */
		    if (hashModulus <= 2*NextUniqIndex
			&& hashModulus < nCharInfos+1) {
			/* Time to increate hash table size */
			hashModulus = 2*hashModulus+1;
			if (hashModulus > nCharInfos+1)
			    hashModulus = nCharInfos+1;
			for (j = 0; j < hashModulus; j++)
			    pHash2UniqIndex[j] = (CARD16)(-1);
			for (i = 0; i < NextUniqIndex; i++)
			    pUniqIndex2NextUniqIndex[i] = (CARD16)(-1);
			for (i = 0; i < NextUniqIndex; i++) {
			    j = pUniqIndex2Index[i];
			    p = &pCI[j];
			    hashCode = hashCI(p) % hashModulus;
			    pUniqIndex2NextUniqIndex[i] = pHash2UniqIndex[hashCode];
			    pHash2UniqIndex[hashCode] = i;
			}
			p = &pCI[NextIndex];
			hashCode = hashCI(p) % hashModulus;
		    }
		    i = NextUniqIndex++;
		    pUniqIndex2NextUniqIndex[i] = pHash2UniqIndex[hashCode];
		    pHash2UniqIndex[hashCode] = i;
		    pUniqIndex2Index[i] = NextIndex;
		    pIndex2UniqIndex[NextIndex] = i;
		}
	    }
	    nUniqCharInfos = NextUniqIndex;
	    /* fprintf(stderr, "font metrics: nCharInfos = %d, nUniqCharInfos = %d, hashModulus = %d\n", nCharInfos, nUniqCharInfos, hashModulus); */
	}
d551 35
a585 33
	int nfontprops = pFont->info.nprops;
	int rlength =
	   sizeof(xXF86BigfontQueryFontReply)
	   + nfontprops * sizeof(xFontProp)
	   + (nCharInfos > 0 && shmid == -1
	      ? nUniqCharInfos * sizeof(xCharInfo)
	        + (nCharInfos+1)/2 * 2 * sizeof(CARD16)
	      : 0);
	xXF86BigfontQueryFontReply* reply = malloc(rlength);
	char* p;
	if (!reply) {
	    if (nCharInfos > 0) {
		if (shmid == -1) free(pIndex2UniqIndex);
		if (!pDesc) free(pCI);
	    }
	    return BadAlloc;
	}
	reply->type = X_Reply;
	reply->length = bytes_to_int32(rlength - sizeof(xGenericReply));
	reply->sequenceNumber = client->sequence;
	reply->minBounds = pFont->info.ink_minbounds;
	reply->maxBounds = pFont->info.ink_maxbounds;
	reply->minCharOrByte2 = pFont->info.firstCol;
	reply->maxCharOrByte2 = pFont->info.lastCol;
	reply->defaultChar = pFont->info.defaultCh;
	reply->nFontProps = pFont->info.nprops;
	reply->drawDirection = pFont->info.drawDirection;
	reply->minByte1 = pFont->info.firstRow;
	reply->maxByte1 = pFont->info.lastRow;
	reply->allCharsExist = pFont->info.allExist;
	reply->fontAscent = pFont->info.fontAscent;
	reply->fontDescent = pFont->info.fontDescent;
	reply->nCharInfos = nCharInfos;
d587 69
a655 63
	reply->shmid = shmid;
	reply->shmsegoffset = 0;
	if (client->swapped) {
	    char tmp;
	    swaps(&reply->sequenceNumber, tmp);
	    swapl(&reply->length, tmp);
	    swapCharInfo(&reply->minBounds);
	    swapCharInfo(&reply->maxBounds);
	    swaps(&reply->minCharOrByte2, tmp);
	    swaps(&reply->maxCharOrByte2, tmp);
	    swaps(&reply->defaultChar, tmp);
	    swaps(&reply->nFontProps, tmp);
	    swaps(&reply->fontAscent, tmp);
	    swaps(&reply->fontDescent, tmp);
	    swapl(&reply->nCharInfos, tmp);
	    swapl(&reply->nUniqCharInfos, tmp);
	    swapl(&reply->shmid, tmp);
	    swapl(&reply->shmsegoffset, tmp);
	}
	p = (char*) &reply[1];
	{
	    FontPropPtr pFP;
	    xFontProp* prFP;
	    int i;
	    for (i = 0, pFP = pFont->info.props, prFP = (xFontProp *) p;
		 i < nfontprops;
		 i++, pFP++, prFP++) {
		prFP->name = pFP->name;
		prFP->value = pFP->value;
		if (client->swapped) {
		    char tmp;
		    swapl(&prFP->name, tmp);
		    swapl(&prFP->value, tmp);
		}
	    }
	    p = (char*) prFP;
	}
	if (nCharInfos > 0 && shmid == -1) {
	    xCharInfo* pci;
	    CARD16* ps;
	    int i, j;
	    pci = (xCharInfo*) p;
	    for (i = 0; i < nUniqCharInfos; i++, pci++) {
		*pci = pCI[pUniqIndex2Index[i]];
		if (client->swapped)
		    swapCharInfo(pci);
	    }
	    ps = (CARD16*) pci;
	    for (j = 0; j < nCharInfos; j++, ps++) {
		*ps = pIndex2UniqIndex[j];
		if (client->swapped) {
		    char tmp;
		    swaps(ps, tmp);
		}
	    }
	}
	WriteToClient(client, rlength, (char *)reply);
	free(reply);
	if (nCharInfos > 0) {
	    if (shmid == -1) free(pIndex2UniqIndex);
	    if (!pDesc) free(pCI);
	}
	return Success;
d660 1
a660 2
ProcXF86BigfontDispatch(
    ClientPtr client)
d665 6
a670 6
	case X_XF86BigfontQueryVersion:
	    return ProcXF86BigfontQueryVersion(client);
	case X_XF86BigfontQueryFont:
	    return ProcXF86BigfontQueryFont(client);
	default:
	    return BadRequest;
d675 1
a675 2
SProcXF86BigfontQueryVersion(
    ClientPtr client)
d680 1
a680 1
    swaps(&stuff->length, tmp);
d685 1
a685 2
SProcXF86BigfontQueryFont(
    ClientPtr client)
d690 1
a690 1
    swaps(&stuff->length, tmp);
d692 1
a692 1
    swapl(&stuff->id, tmp);
d697 1
a697 2
SProcXF86BigfontDispatch(
    ClientPtr client)
d702 6
a707 6
	case X_XF86BigfontQueryVersion:
	    return SProcXF86BigfontQueryVersion(client);
	case X_XF86BigfontQueryFont:
	    return SProcXF86BigfontQueryFont(client);
	default:
	    return BadRequest;
d715 5
a719 6
		     XF86BigfontNumberEvents,
		     XF86BigfontNumberErrors,
		     ProcXF86BigfontDispatch,
		     SProcXF86BigfontDispatch,
		     XF86BigfontResetProc,
		     StandardMinorOpcode)) {
d722 17
a738 16
	/*
	 * Note: Local-clients will not be optimized without shared memory
	 * support. Remote-client optimization does not depend on shared
	 * memory support.  Thus, the extension is still registered even
	 * when shared memory support is not functional.
	 */
	if (!CheckForShmSyscall()) {
	    ErrorF(XF86BIGFONTNAME " extension local-client optimization disabled due to lack of shared memory support in the kernel\n");
	    return;
	}
#endif

	srand((unsigned int) time(NULL));
	signature = ((unsigned int) (65536.0/(RAND_MAX+1.0) * rand()) << 16)
	           + (unsigned int) (65536.0/(RAND_MAX+1.0) * rand());
	/* fprintf(stderr, "signature = 0x%08X\n", signature); */
d740 1
a740 1
	FontShmdescIndex = AllocateFontPrivateIndex();
d743 1
a743 1
	pagesize = SHMLBA;
d745 5
a749 5
# ifdef _SC_PAGESIZE
	pagesize = sysconf(_SC_PAGESIZE);
# else
	pagesize = getpagesize();
# endif
@


1.6
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d53 1
a53 1
#if defined(__CYGWIN__) || defined(__SCO__)
a82 6
static DISPATCH_PROC(ProcXF86BigfontDispatch);
static DISPATCH_PROC(ProcXF86BigfontQueryVersion);
static DISPATCH_PROC(ProcXF86BigfontQueryFont);
static DISPATCH_PROC(SProcXF86BigfontDispatch);
static DISPATCH_PROC(SProcXF86BigfontQueryVersion);
static DISPATCH_PROC(SProcXF86BigfontQueryFont);
a139 45
void
XFree86BigfontExtensionInit(void)
{
    if (AddExtension(XF86BIGFONTNAME,
		     XF86BigfontNumberEvents,
		     XF86BigfontNumberErrors,
		     ProcXF86BigfontDispatch,
		     SProcXF86BigfontDispatch,
		     XF86BigfontResetProc,
		     StandardMinorOpcode)) {
#ifdef HAS_SHM
#ifdef MUST_CHECK_FOR_SHM_SYSCALL
	/*
	 * Note: Local-clients will not be optimized without shared memory
	 * support. Remote-client optimization does not depend on shared
	 * memory support.  Thus, the extension is still registered even
	 * when shared memory support is not functional.  
	 */
	if (!CheckForShmSyscall()) {
	    ErrorF(XF86BIGFONTNAME " extension local-client optimization disabled due to lack of shared memory support in the kernel\n");
	    return;
	}
#endif

	srand((unsigned int) time(NULL));
	signature = ((unsigned int) (65536.0/(RAND_MAX+1.0) * rand()) << 16)
	           + (unsigned int) (65536.0/(RAND_MAX+1.0) * rand());
	/* fprintf(stderr, "signature = 0x%08X\n", signature); */

	FontShmdescIndex = AllocateFontPrivateIndex();

#if !defined(CSRG_BASED) && !defined(__CYGWIN__)
	pagesize = SHMLBA;
#else
# ifdef _SC_PAGESIZE
	pagesize = sysconf(_SC_PAGESIZE);
# else
	pagesize = getpagesize();
# endif
#endif
#endif
    }
}


d705 44
@


1.5
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d137 1
a137 1
    return (!badSysCall);
d233 1
a233 1
    pDesc = xalloc(sizeof(ShmDescRec));
d242 1
a242 1
	xfree(pDesc);
d250 1
a250 1
	xfree(pDesc);
d279 1
a279 1
    xfree(pDesc);
d371 1
a371 1
    return client->noClientException;
d407 1
a407 1
    ShmDescPtr pDesc;
d430 2
a431 12
    client->errorValue = stuff->id;		/* EITHER font or gc */
    dixLookupResourceByType((pointer *)&pFont, stuff->id, RT_FONT,
			    client, DixGetAttrAccess);
    if (!pFont) {
	GC *pGC;
	dixLookupResourceByType((pointer *)&pGC, stuff->id, RT_GC,
				client, DixGetAttrAccess);
        if (!pGC)
            return BadFont;    /* procotol spec says only error is BadFont */

	pFont = pGC->font;
    }
a451 2
	else
	    pDesc = NULL;
d465 1
a465 1
		pCI = xalloc(nCharInfos * sizeof(xCharInfo));
d527 1
a527 1
	    tmp = xalloc((4*nCharInfos+1) * sizeof(CARD16));
d529 1
a529 1
		if (!pDesc) xfree(pCI);
d611 1
a611 1
	xXF86BigfontQueryFontReply* reply = xalloc(rlength);
d615 2
a616 2
		if (shmid == -1) xfree(pIndex2UniqIndex);
		if (!pDesc) xfree(pCI);
d694 1
a694 1
	xfree(reply);
d696 2
a697 2
	    if (shmid == -1) xfree(pIndex2UniqIndex);
	    if (!pDesc) xfree(pCI);
d699 1
a699 1
	return (client->noClientException);
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d74 1
d76 2
a77 2
#define _XF86BIGFONT_SERVER_
#include <X11/extensions/xf86bigfstr.h>
d129 1
a129 1
	shmctl(shmid, IPC_RMID, (struct shmid_ds *)NULL);
d147 1
a147 1
XFree86BigfontExtensionInit()
d233 1
a233 1
    pDesc = (ShmDescRec *) xalloc(sizeof(ShmDescRec));
d306 1
a306 1
XF86BigfontCleanup()
d343 2
a344 2
    reply.majorVersion = XF86BIGFONT_MAJOR_VERSION;
    reply.minorVersion = XF86BIGFONT_MINOR_VERSION;
d431 2
a432 2
    pFont = (FontPtr)SecurityLookupIDByType(client, stuff->id, RT_FONT,
					    DixGetAttrAccess);
d434 4
a437 4
	GC *pGC = (GC *) SecurityLookupIDByType(client, stuff->id, RT_GC,
						DixGetAttrAccess);
        if (!pGC) {
	    client->errorValue = stuff->id;
d439 1
a439 1
	}
d477 1
a477 2
		pCI = (xCharInfo *)
		      xalloc(nCharInfos * sizeof(xCharInfo));
d539 1
a539 2
	    tmp = (CARD16*)
		  xalloc((4*nCharInfos+1) * sizeof(CARD16));
d623 1
a623 2
	xXF86BigfontQueryFontReply* reply =
	   (xXF86BigfontQueryFontReply *) xalloc(rlength);
d633 1
a633 1
	reply->length = (rlength - sizeof(xGenericReply)) >> 2;
@


1.3
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d53 1
a53 1
#if defined(ISC) || defined(__CYGWIN__) || defined(__SCO__)
@


1.2
log
@Update to xserver 1.4.2. Tested by landry@@, ckuethe@@, jsing@@ mbalmer@@.
@
text
@a88 4
#if 0
static unsigned char XF86BigfontReqCode;
#endif

a147 12
#if 0
    ExtensionEntry* extEntry;

    if ((extEntry = AddExtension(XF86BIGFONTNAME,
				 XF86BigfontNumberEvents,
				 XF86BigfontNumberErrors,
				 ProcXF86BigfontDispatch,
				 SProcXF86BigfontDispatch,
				 XF86BigfontResetProc,
				 StandardMinorOpcode))) {
	XF86BigfontReqCode = (unsigned char) extEntry->base;
#else
a154 1
#endif
d239 2
a240 2
	ErrorF(XF86BIGFONTNAME " extension: shmget() failed, size = %u, errno = %d\n",
	       size, errno);
d246 2
a247 2
	ErrorF(XF86BIGFONTNAME " extension: shmat() failed, size = %u, errno = %d\n",
	       size, errno);
d431 1
a431 1
					    DixReadAccess);
d434 1
a434 1
						DixReadAccess);
d477 1
a477 1
		      ALLOCATE_LOCAL(nCharInfos * sizeof(xCharInfo));
d540 1
a540 1
		  ALLOCATE_LOCAL((4*nCharInfos+1) * sizeof(CARD16));
d542 1
a542 1
		if (!pDesc) DEALLOCATE_LOCAL(pCI);
d625 1
a625 1
	   (xXF86BigfontQueryFontReply *) ALLOCATE_LOCAL(rlength);
d629 2
a630 2
		if (shmid == -1) DEALLOCATE_LOCAL(pIndex2UniqIndex);
		if (!pDesc) DEALLOCATE_LOCAL(pCI);
d708 1
a708 1
	DEALLOCATE_LOCAL(reply);
d710 2
a711 2
	    if (shmid == -1) DEALLOCATE_LOCAL(pIndex2UniqIndex);
	    if (!pDesc) DEALLOCATE_LOCAL(pCI);
@


1.1
log
@Initial revision
@
text
@d107 1
a107 1
#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__CYGWIN__)
d448 1
a448 1
					    SecurityReadAccess);
a449 1
	/* can't use VERIFY_GC because it might return BadGC */
d451 1
a451 1
						SecurityReadAccess);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d448 1
a448 1
					    DixReadAccess);
d450 1
d452 1
a452 1
						DixReadAccess);
@

