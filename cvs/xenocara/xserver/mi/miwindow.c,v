head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.10
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.18;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.48;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@
/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include <X11/extensions/shapeconst.h>
#include "regionstr.h"
#include "region.h"
#include "mi.h"
#include "windowstr.h"
#include "scrnintstr.h"
#include "pixmapstr.h"
#include "mivalidate.h"
#include "inputstr.h"

void
miClearToBackground(WindowPtr pWin,
                    int x, int y, int w, int h, Bool generateExposures)
{
    BoxRec box;
    RegionRec reg;
    BoxPtr extents;
    int x1, y1, x2, y2;

    /* compute everything using ints to avoid overflow */

    x1 = pWin->drawable.x + x;
    y1 = pWin->drawable.y + y;
    if (w)
        x2 = x1 + (int) w;
    else
        x2 = x1 + (int) pWin->drawable.width - (int) x;
    if (h)
        y2 = y1 + h;
    else
        y2 = y1 + (int) pWin->drawable.height - (int) y;

    extents = &pWin->clipList.extents;

    /* clip the resulting rectangle to the window clipList extents.  This
     * makes sure that the result will fit in a box, given that the
     * screen is < 32768 on a side.
     */

    if (x1 < extents->x1)
        x1 = extents->x1;
    if (x2 > extents->x2)
        x2 = extents->x2;
    if (y1 < extents->y1)
        y1 = extents->y1;
    if (y2 > extents->y2)
        y2 = extents->y2;

    if (x2 <= x1 || y2 <= y1) {
        x2 = x1 = 0;
        y2 = y1 = 0;
    }

    box.x1 = x1;
    box.x2 = x2;
    box.y1 = y1;
    box.y2 = y2;

    RegionInit(&reg, &box, 1);

    RegionIntersect(&reg, &reg, &pWin->clipList);
    if (generateExposures)
        (*pWin->drawable.pScreen->WindowExposures) (pWin, &reg);
    else if (pWin->backgroundState != None)
        pWin->drawable.pScreen->PaintWindow(pWin, &reg, PW_BACKGROUND);
    RegionUninit(&reg);
}

void
miMarkWindow(WindowPtr pWin)
{
    ValidatePtr val;

    if (pWin->valdata)
        return;
    val = (ValidatePtr) xnfalloc(sizeof(ValidateRec));
    val->before.oldAbsCorner.x = pWin->drawable.x;
    val->before.oldAbsCorner.y = pWin->drawable.y;
    val->before.borderVisible = NullRegion;
    val->before.resized = FALSE;
    pWin->valdata = val;
}

Bool
miMarkOverlappedWindows(WindowPtr pWin, WindowPtr pFirst, WindowPtr *ppLayerWin)
{
    BoxPtr box;
    WindowPtr pChild, pLast;
    Bool anyMarked = FALSE;
    MarkWindowProcPtr MarkWindow = pWin->drawable.pScreen->MarkWindow;

    /* single layered systems are easy */
    if (ppLayerWin)
        *ppLayerWin = pWin;

    if (pWin == pFirst) {
        /* Blindly mark pWin and all of its inferiors.   This is a slight
         * overkill if there are mapped windows that outside pWin's border,
         * but it's better than wasting time on RectIn checks.
         */
        pChild = pWin;
        while (1) {
            if (pChild->viewable) {
                if (RegionBroken(&pChild->winSize))
                    SetWinSize(pChild);
                if (RegionBroken(&pChild->borderSize))
                    SetBorderSize(pChild);
                (*MarkWindow) (pChild);
                if (pChild->firstChild) {
                    pChild = pChild->firstChild;
                    continue;
                }
            }
            while (!pChild->nextSib && (pChild != pWin))
                pChild = pChild->parent;
            if (pChild == pWin)
                break;
            pChild = pChild->nextSib;
        }
        anyMarked = TRUE;
        pFirst = pFirst->nextSib;
    }
    if ((pChild = pFirst)) {
        box = RegionExtents(&pWin->borderSize);
        pLast = pChild->parent->lastChild;
        while (1) {
            if (pChild->viewable) {
                if (RegionBroken(&pChild->winSize))
                    SetWinSize(pChild);
                if (RegionBroken(&pChild->borderSize))
                    SetBorderSize(pChild);
                if (RegionContainsRect(&pChild->borderSize, box)) {
                    (*MarkWindow) (pChild);
                    anyMarked = TRUE;
                    if (pChild->firstChild) {
                        pChild = pChild->firstChild;
                        continue;
                    }
                }
            }
            while (!pChild->nextSib && (pChild != pLast))
                pChild = pChild->parent;
            if (pChild == pLast)
                break;
            pChild = pChild->nextSib;
        }
    }
    if (anyMarked)
        (*MarkWindow) (pWin->parent);
    return anyMarked;
}

/*****
 *  miHandleValidateExposures(pWin)
 *    starting at pWin, draw background in any windows that have exposure
 *    regions, translate the regions, restore any backing store,
 *    and then send any regions still exposed to the client
 *****/
void
miHandleValidateExposures(WindowPtr pWin)
{
    WindowPtr pChild;
    ValidatePtr val;
    WindowExposuresProcPtr WindowExposures;

    pChild = pWin;
    WindowExposures = pChild->drawable.pScreen->WindowExposures;
    while (1) {
        if ((val = pChild->valdata)) {
            if (RegionNotEmpty(&val->after.borderExposed))
                pWin->drawable.pScreen->PaintWindow(pChild,
                                                    &val->after.borderExposed,
                                                    PW_BORDER);
            RegionUninit(&val->after.borderExposed);
            (*WindowExposures) (pChild, &val->after.exposed);
            RegionUninit(&val->after.exposed);
            free(val);
            pChild->valdata = NULL;
            if (pChild->firstChild) {
                pChild = pChild->firstChild;
                continue;
            }
        }
        while (!pChild->nextSib && (pChild != pWin))
            pChild = pChild->parent;
        if (pChild == pWin)
            break;
        pChild = pChild->nextSib;
    }
}

void
miMoveWindow(WindowPtr pWin, int x, int y, WindowPtr pNextSib, VTKind kind)
{
    WindowPtr pParent;
    Bool WasViewable = (Bool) (pWin->viewable);
    short bw;
    RegionPtr oldRegion = NULL;
    DDXPointRec oldpt;
    Bool anyMarked = FALSE;
    ScreenPtr pScreen;
    WindowPtr windowToValidate;
    WindowPtr pLayerWin;

    /* if this is a root window, can't be moved */
    if (!(pParent = pWin->parent))
        return;
    pScreen = pWin->drawable.pScreen;
    bw = wBorderWidth(pWin);

    oldpt.x = pWin->drawable.x;
    oldpt.y = pWin->drawable.y;
    if (WasViewable) {
        oldRegion = RegionCreate(NullBox, 1);
        RegionCopy(oldRegion, &pWin->borderClip);
        anyMarked = (*pScreen->MarkOverlappedWindows) (pWin, pWin, &pLayerWin);
    }
    pWin->origin.x = x + (int) bw;
    pWin->origin.y = y + (int) bw;
    x = pWin->drawable.x = pParent->drawable.x + x + (int) bw;
    y = pWin->drawable.y = pParent->drawable.y + y + (int) bw;

    SetWinSize(pWin);
    SetBorderSize(pWin);

    (*pScreen->PositionWindow) (pWin, x, y);

    windowToValidate = MoveWindowInStack(pWin, pNextSib);

    ResizeChildrenWinSize(pWin, x - oldpt.x, y - oldpt.y, 0, 0);

    if (WasViewable) {
        if (pLayerWin == pWin)
            anyMarked |= (*pScreen->MarkOverlappedWindows)
                (pWin, windowToValidate, NULL);
        else
            anyMarked |= (*pScreen->MarkOverlappedWindows)
                (pWin, pLayerWin, NULL);

        if (anyMarked) {
            (*pScreen->ValidateTree) (pLayerWin->parent, NullWindow, kind);
            (*pWin->drawable.pScreen->CopyWindow) (pWin, oldpt, oldRegion);
            RegionDestroy(oldRegion);
            /* XXX need to retile border if ParentRelative origin */
            (*pScreen->HandleExposures) (pLayerWin->parent);
            if (pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pLayerWin->parent, NULL, kind);
        }
    }
    if (pWin->realized)
        WindowsRestructured();
}

/*
 * pValid is a region of the screen which has been
 * successfully copied -- recomputed exposed regions for affected windows
 */

static int
miRecomputeExposures(WindowPtr pWin, void *value)
{                               /* must conform to VisitWindowProcPtr */
    RegionPtr pValid = (RegionPtr) value;

    if (pWin->valdata) {
#ifdef COMPOSITE
        /*
         * Redirected windows are not affected by parent window
         * gravity manipulations, so don't recompute their
         * exposed areas here.
         */
        if (pWin->redirectDraw != RedirectDrawNone)
            return WT_DONTWALKCHILDREN;
#endif
        /*
         * compute exposed regions of this window
         */
        RegionSubtract(&pWin->valdata->after.exposed, &pWin->clipList, pValid);
        /*
         * compute exposed regions of the border
         */
        RegionSubtract(&pWin->valdata->after.borderExposed,
                       &pWin->borderClip, &pWin->winSize);
        RegionSubtract(&pWin->valdata->after.borderExposed,
                       &pWin->valdata->after.borderExposed, pValid);
        return WT_WALKCHILDREN;
    }
    return WT_NOMATCH;
}

void
miResizeWindow(WindowPtr pWin, int x, int y, unsigned int w, unsigned int h,
               WindowPtr pSib)
{
    WindowPtr pParent;
    Bool WasViewable = (Bool) (pWin->viewable);
    unsigned short width = pWin->drawable.width, height = pWin->drawable.height;
    short oldx = pWin->drawable.x, oldy = pWin->drawable.y;
    int bw = wBorderWidth(pWin);
    short dw, dh;
    DDXPointRec oldpt;
    RegionPtr oldRegion = NULL;
    Bool anyMarked = FALSE;
    ScreenPtr pScreen;
    WindowPtr pFirstChange;
    WindowPtr pChild;
    RegionPtr gravitate[StaticGravity + 1];
    unsigned g;
    int nx, ny;                 /* destination x,y */
    int newx, newy;             /* new inner window position */
    RegionPtr pRegion = NULL;
    RegionPtr destClip;         /* portions of destination already written */
    RegionPtr oldWinClip = NULL;        /* old clip list for window */
    RegionPtr borderVisible = NullRegion;       /* visible area of the border */
    Bool shrunk = FALSE;        /* shrunk in an inner dimension */
    Bool moved = FALSE;         /* window position changed */
    WindowPtr pLayerWin;

    /* if this is a root window, can't be resized */
    if (!(pParent = pWin->parent))
        return;

    pScreen = pWin->drawable.pScreen;
    newx = pParent->drawable.x + x + bw;
    newy = pParent->drawable.y + y + bw;
    if (WasViewable) {
        anyMarked = FALSE;
        /*
         * save the visible region of the window
         */
        oldRegion = RegionCreate(NullBox, 1);
        RegionCopy(oldRegion, &pWin->winSize);

        /*
         * categorize child windows into regions to be moved
         */
        for (g = 0; g <= StaticGravity; g++)
            gravitate[g] = (RegionPtr) NULL;
        for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
            g = pChild->winGravity;
            if (g != UnmapGravity) {
                if (!gravitate[g])
                    gravitate[g] = RegionCreate(NullBox, 1);
                RegionUnion(gravitate[g], gravitate[g], &pChild->borderClip);
            }
            else {
                UnmapWindow(pChild, TRUE);
                anyMarked = TRUE;
            }
        }
        anyMarked |= (*pScreen->MarkOverlappedWindows) (pWin, pWin, &pLayerWin);

        oldWinClip = NULL;
        if (pWin->bitGravity != ForgetGravity) {
            oldWinClip = RegionCreate(NullBox, 1);
            RegionCopy(oldWinClip, &pWin->clipList);
        }
        /*
         * if the window is changing size, borderExposed
         * can't be computed correctly without some help.
         */
        if (pWin->drawable.height > h || pWin->drawable.width > w)
            shrunk = TRUE;

        if (newx != oldx || newy != oldy)
            moved = TRUE;

        if ((pWin->drawable.height != h || pWin->drawable.width != w) &&
            HasBorder(pWin)) {
            borderVisible = RegionCreate(NullBox, 1);
            /* for tiled borders, we punt and draw the whole thing */
            if (pWin->borderIsPixel || !moved) {
                if (shrunk || moved)
                    RegionSubtract(borderVisible,
                                   &pWin->borderClip, &pWin->winSize);
                else
                    RegionCopy(borderVisible, &pWin->borderClip);
            }
        }
    }
    pWin->origin.x = x + bw;
    pWin->origin.y = y + bw;
    pWin->drawable.height = h;
    pWin->drawable.width = w;

    x = pWin->drawable.x = newx;
    y = pWin->drawable.y = newy;

    SetWinSize(pWin);
    SetBorderSize(pWin);

    dw = (int) w - (int) width;
    dh = (int) h - (int) height;
    ResizeChildrenWinSize(pWin, x - oldx, y - oldy, dw, dh);

    /* let the hardware adjust background and border pixmaps, if any */
    (*pScreen->PositionWindow) (pWin, x, y);

    pFirstChange = MoveWindowInStack(pWin, pSib);

    if (WasViewable) {
        pRegion = RegionCreate(NullBox, 1);

        if (pLayerWin == pWin)
            anyMarked |= (*pScreen->MarkOverlappedWindows) (pWin, pFirstChange,
                                                            NULL);
        else
            anyMarked |= (*pScreen->MarkOverlappedWindows) (pWin, pLayerWin,
                                                            NULL);

        if (pWin->valdata) {
            pWin->valdata->before.resized = TRUE;
            pWin->valdata->before.borderVisible = borderVisible;
        }

        if (anyMarked)
            (*pScreen->ValidateTree) (pLayerWin->parent, pFirstChange, VTOther);
        /*
         * the entire window is trashed unless bitGravity
         * recovers portions of it
         */
        RegionCopy(&pWin->valdata->after.exposed, &pWin->clipList);
    }

    GravityTranslate(x, y, oldx, oldy, dw, dh, pWin->bitGravity, &nx, &ny);

    if (WasViewable) {
        /* avoid the border */
        if (HasBorder(pWin)) {
            int offx, offy, dx, dy;

            /* kruft to avoid double translates for each gravity */
            offx = 0;
            offy = 0;
            for (g = 0; g <= StaticGravity; g++) {
                if (!gravitate[g])
                    continue;

                /* align winSize to gravitate[g].
                 * winSize is in new coordinates,
                 * gravitate[g] is still in old coordinates */
                GravityTranslate(x, y, oldx, oldy, dw, dh, g, &nx, &ny);

                dx = (oldx - nx) - offx;
                dy = (oldy - ny) - offy;
                if (dx || dy) {
                    RegionTranslate(&pWin->winSize, dx, dy);
                    offx += dx;
                    offy += dy;
                }
                RegionIntersect(gravitate[g], gravitate[g], &pWin->winSize);
            }
            /* get winSize back where it belongs */
            if (offx || offy)
                RegionTranslate(&pWin->winSize, -offx, -offy);
        }
        /*
         * add screen bits to the appropriate bucket
         */

        if (oldWinClip) {
            /*
             * clip to new clipList
             */
            RegionCopy(pRegion, oldWinClip);
            RegionTranslate(pRegion, nx - oldx, ny - oldy);
            RegionIntersect(oldWinClip, pRegion, &pWin->clipList);
            /*
             * don't step on any gravity bits which will be copied after this
             * region.  Note -- this assumes that the regions will be copied
             * in gravity order.
             */
            for (g = pWin->bitGravity + 1; g <= StaticGravity; g++) {
                if (gravitate[g])
                    RegionSubtract(oldWinClip, oldWinClip, gravitate[g]);
            }
            RegionTranslate(oldWinClip, oldx - nx, oldy - ny);
            g = pWin->bitGravity;
            if (!gravitate[g])
                gravitate[g] = oldWinClip;
            else {
                RegionUnion(gravitate[g], gravitate[g], oldWinClip);
                RegionDestroy(oldWinClip);
            }
        }

        /*
         * move the bits on the screen
         */

        destClip = NULL;

        for (g = 0; g <= StaticGravity; g++) {
            if (!gravitate[g])
                continue;

            GravityTranslate(x, y, oldx, oldy, dw, dh, g, &nx, &ny);

            oldpt.x = oldx + (x - nx);
            oldpt.y = oldy + (y - ny);

            /* Note that gravitate[g] is *translated* by CopyWindow */

            /* only copy the remaining useful bits */

            RegionIntersect(gravitate[g], gravitate[g], oldRegion);

            /* clip to not overwrite already copied areas */

            if (destClip) {
                RegionTranslate(destClip, oldpt.x - x, oldpt.y - y);
                RegionSubtract(gravitate[g], gravitate[g], destClip);
                RegionTranslate(destClip, x - oldpt.x, y - oldpt.y);
            }

            /* and move those bits */

            if (oldpt.x != x || oldpt.y != y
#ifdef COMPOSITE
                || pWin->redirectDraw
#endif
                ) {
                (*pWin->drawable.pScreen->CopyWindow) (pWin, oldpt,
                                                       gravitate[g]);
            }

            /* remove any overwritten bits from the remaining useful bits */

            RegionSubtract(oldRegion, oldRegion, gravitate[g]);

            /*
             * recompute exposed regions of child windows
             */

            for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
                if (pChild->winGravity != g)
                    continue;
                RegionIntersect(pRegion, &pChild->borderClip, gravitate[g]);
                TraverseTree(pChild, miRecomputeExposures, (void *) pRegion);
            }

            /*
             * remove the successfully copied regions of the
             * window from its exposed region
             */

            if (g == pWin->bitGravity)
                RegionSubtract(&pWin->valdata->after.exposed,
                               &pWin->valdata->after.exposed, gravitate[g]);
            if (!destClip)
                destClip = gravitate[g];
            else {
                RegionUnion(destClip, destClip, gravitate[g]);
                RegionDestroy(gravitate[g]);
            }
        }

        RegionDestroy(oldRegion);
        RegionDestroy(pRegion);
        if (destClip)
            RegionDestroy(destClip);
        if (anyMarked) {
            (*pScreen->HandleExposures) (pLayerWin->parent);
            if (pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pLayerWin->parent, pFirstChange,
                                              VTOther);
        }
    }
    if (pWin->realized)
        WindowsRestructured();
}

WindowPtr
miGetLayerWindow(WindowPtr pWin)
{
    return pWin->firstChild;
}

/******
 *
 * miSetShape
 *    The border/window shape has changed.  Recompute winSize/borderSize
 *    and send appropriate exposure events
 */

void
miSetShape(WindowPtr pWin, int kind)
{
    Bool WasViewable = (Bool) (pWin->viewable);
    ScreenPtr pScreen = pWin->drawable.pScreen;
    Bool anyMarked = FALSE;
    WindowPtr pLayerWin;

    if (kind != ShapeInput) {
        if (WasViewable) {
            anyMarked = (*pScreen->MarkOverlappedWindows) (pWin, pWin,
                                                           &pLayerWin);
            if (pWin->valdata) {
                if (HasBorder(pWin)) {
                    RegionPtr borderVisible;

                    borderVisible = RegionCreate(NullBox, 1);
                    RegionSubtract(borderVisible,
                                   &pWin->borderClip, &pWin->winSize);
                    pWin->valdata->before.borderVisible = borderVisible;
                }
                pWin->valdata->before.resized = TRUE;
            }
        }

        SetWinSize(pWin);
        SetBorderSize(pWin);

        ResizeChildrenWinSize(pWin, 0, 0, 0, 0);

        if (WasViewable) {
            anyMarked |= (*pScreen->MarkOverlappedWindows) (pWin, pWin, NULL);

            if (anyMarked) {
                (*pScreen->ValidateTree) (pLayerWin->parent, NullWindow,
                                          VTOther);
                (*pScreen->HandleExposures) (pLayerWin->parent);
                if (pScreen->PostValidateTree)
                    (*pScreen->PostValidateTree) (pLayerWin->parent, NULL,
                                                  VTOther);
            }
        }
    }
    if (pWin->realized)
        WindowsRestructured();
    CheckCursorConfinement(pWin);
}

/* Keeps the same inside(!) origin */

void
miChangeBorderWidth(WindowPtr pWin, unsigned int width)
{
    int oldwidth;
    Bool anyMarked = FALSE;
    ScreenPtr pScreen;
    Bool WasViewable = (Bool) (pWin->viewable);
    Bool HadBorder;
    WindowPtr pLayerWin;

    oldwidth = wBorderWidth(pWin);
    if (oldwidth == width)
        return;
    HadBorder = HasBorder(pWin);
    pScreen = pWin->drawable.pScreen;
    if (WasViewable && width < oldwidth)
        anyMarked = (*pScreen->MarkOverlappedWindows) (pWin, pWin, &pLayerWin);

    pWin->borderWidth = width;
    SetBorderSize(pWin);

    if (WasViewable) {
        if (width > oldwidth) {
            anyMarked = (*pScreen->MarkOverlappedWindows) (pWin, pWin,
                                                           &pLayerWin);
            /*
             * save the old border visible region to correctly compute
             * borderExposed.
             */
            if (pWin->valdata && HadBorder) {
                RegionPtr borderVisible;

                borderVisible = RegionCreate(NULL, 1);
                RegionSubtract(borderVisible,
                               &pWin->borderClip, &pWin->winSize);
                pWin->valdata->before.borderVisible = borderVisible;
            }
        }

        if (anyMarked) {
            (*pScreen->ValidateTree) (pLayerWin->parent, pLayerWin, VTOther);
            (*pScreen->HandleExposures) (pLayerWin->parent);
            if (pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pLayerWin->parent, pLayerWin,
                                              VTOther);
        }
    }
    if (pWin->realized)
        WindowsRestructured();
}

void
miMarkUnrealizedWindow(WindowPtr pChild, WindowPtr pWin, Bool fromConfigure)
{
    if ((pChild != pWin) || fromConfigure) {
        RegionEmpty(&pChild->clipList);
        if (pChild->drawable.pScreen->ClipNotify)
            (*pChild->drawable.pScreen->ClipNotify) (pChild, 0, 0);
        RegionEmpty(&pChild->borderClip);
    }
}

WindowPtr
miSpriteTrace(SpritePtr pSprite, int x, int y)
{
    WindowPtr pWin;
    BoxRec box;

    pWin = DeepestSpriteWin(pSprite)->firstChild;
    while (pWin) {
        if ((pWin->mapped) &&
            (x >= pWin->drawable.x - wBorderWidth(pWin)) &&
            (x < pWin->drawable.x + (int) pWin->drawable.width +
             wBorderWidth(pWin)) &&
            (y >= pWin->drawable.y - wBorderWidth(pWin)) &&
            (y < pWin->drawable.y + (int) pWin->drawable.height +
             wBorderWidth(pWin))
            /* When a window is shaped, a further check
             * is made to see if the point is inside
             * borderSize
             */
            && (!wBoundingShape(pWin) || PointInBorderSize(pWin, x, y))
            && (!wInputShape(pWin) ||
                RegionContainsPoint(wInputShape(pWin),
                                    x - pWin->drawable.x,
                                    y - pWin->drawable.y, &box))
            /* In rootless mode windows may be offscreen, even when
             * they're in X's stack. (E.g. if the native window system
             * implements some form of virtual desktop system).
             */
            && !pWin->unhittable) {
            if (pSprite->spriteTraceGood >= pSprite->spriteTraceSize) {
                pSprite->spriteTraceSize += 10;
                pSprite->spriteTrace = reallocarray(pSprite->spriteTrace,
                                                    pSprite->spriteTraceSize,
                                                    sizeof(WindowPtr));
            }
            pSprite->spriteTrace[pSprite->spriteTraceGood++] = pWin;
            pWin = pWin->firstChild;
        }
        else
            pWin = pWin->nextSib;
    }
    return DeepestSpriteWin(pSprite);
}

/**
 * Traversed from the root window to the window at the position x/y. While
 * traversing, it sets up the traversal history in the spriteTrace array.
 * After completing, the spriteTrace history is set in the following way:
 *   spriteTrace[0] ... root window
 *   spriteTrace[1] ... top level window that encloses x/y
 *       ...
 *   spriteTrace[spriteTraceGood - 1] ... window at x/y
 *
 * @@returns the window at the given coordinates.
 */
WindowPtr
miXYToWindow(ScreenPtr pScreen, SpritePtr pSprite, int x, int y)
{
    pSprite->spriteTraceGood = 1;       /* root window still there */
    return miSpriteTrace(pSprite, x, y);
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d116 1
a116 1
        miPaintWindow(pWin, &reg, PW_BACKGROUND);
d222 3
a224 1
                miPaintWindow(pChild, &val->after.borderExposed, PW_BORDER);
a771 1
#ifdef ROOTLESS
d776 1
a776 3
            && !pWin->rootlessUnhittable
#endif
            ) {
d779 3
a781 3
                pSprite->spriteTrace = realloc(pSprite->spriteTrace,
                                               pSprite->spriteTraceSize *
                                               sizeof(WindowPtr));
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d30 2
a31 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d33 1
a33 1
both that copyright notice and this permission notice appear in 
d36 1
a36 1
software without specific, written prior permission.  
d114 1
a114 1
        (*pWin->drawable.pScreen->WindowExposures) (pWin, &reg, NULL);
d224 1
a224 1
            (*WindowExposures) (pChild, &val->after.exposed, NullRegion);
d295 2
a297 2
        if (anyMarked && pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pLayerWin->parent, NullWindow, kind);
d340 2
a341 3
miSlideAndSizeWindow(WindowPtr pWin,
                     int x, int y,
                     unsigned int w, unsigned int h, WindowPtr pSib)
d610 1
a610 1
        if (anyMarked)
d612 4
a615 3
        if (anyMarked && pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pLayerWin->parent, pFirstChange,
                                          VTOther);
d667 1
a667 1
            if (anyMarked)
a669 4
        }

        if (WasViewable) {
            if (anyMarked)
d671 4
a674 3
            if (anyMarked && pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pLayerWin->parent, NullWindow,
                                              VTOther);
d726 3
a729 3
        if (anyMarked && pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pLayerWin->parent, pLayerWin,
                                          VTOther);
a742 14
    }
}

void
miSegregateChildren(WindowPtr pWin, RegionPtr pReg, int depth)
{
    WindowPtr pChild;

    for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
        if (pChild->drawable.depth == depth)
            RegionUnion(pReg, pReg, &pChild->borderClip);

        if (pChild->firstChild)
            miSegregateChildren(pChild, pReg, depth);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d60 1
d309 1
a309 1
miRecomputeExposures(WindowPtr pWin, pointer value)
d588 1
a588 1
                TraverseTree(pChild, miRecomputeExposures, (pointer) pRegion);
d761 65
@


1.6
log
@Update to xserver 1.11.2
@
text
@a25 1

d63 1
a63 2
                    int x, int y, int w, int h,
                    Bool generateExposures)
d66 3
a68 3
    RegionRec	reg;
    BoxPtr  extents;
    int	    x1, y1, x2, y2;
d79 1
a79 1
        y2 = y1 + h;	
d84 1
a84 1
    
d91 1
a91 1
	x1 = extents->x1;
d93 1
a93 1
	x2 = extents->x2;
d95 1
a95 1
	y1 = extents->y1;
d97 1
a97 1
	y2 = extents->y2;
d99 3
a101 4
    if (x2 <= x1 || y2 <= y1)
    {
	x2 = x1 = 0;
	y2 = y1 = 0;
d113 1
a113 1
	(*pWin->drawable.pScreen->WindowExposures)(pWin, &reg, NULL);
d115 1
a115 1
	miPaintWindow(pWin, &reg, PW_BACKGROUND);
d125 2
a126 2
	return;
    val = (ValidatePtr)xnfalloc(sizeof(ValidateRec));
d143 2
a144 1
    if (ppLayerWin) *ppLayerWin = pWin;
d146 51
a196 60
    if (pWin == pFirst)
    {
	/* Blindly mark pWin and all of its inferiors.	 This is a slight
	 * overkill if there are mapped windows that outside pWin's border,
	 * but it's better than wasting time on RectIn checks.
	 */
	pChild = pWin;
	while (1)
	{
	    if (pChild->viewable)
	    {
		if (RegionBroken(&pChild->winSize))
		    SetWinSize (pChild);
		if (RegionBroken(&pChild->borderSize))
		    SetBorderSize (pChild);
		(* MarkWindow)(pChild);
		if (pChild->firstChild)
		{
		    pChild = pChild->firstChild;
		    continue;
		}
	    }
	    while (!pChild->nextSib && (pChild != pWin))
		pChild = pChild->parent;
	    if (pChild == pWin)
		break;
	    pChild = pChild->nextSib;
	}
	anyMarked = TRUE;
	pFirst = pFirst->nextSib;
    }
    if ( (pChild = pFirst) )
    {
	box = RegionExtents(&pWin->borderSize);
	pLast = pChild->parent->lastChild;
	while (1)
	{
	    if (pChild->viewable)
	    {
		if (RegionBroken(&pChild->winSize))
		    SetWinSize (pChild);
		if (RegionBroken(&pChild->borderSize))
		    SetBorderSize (pChild);
		if (RegionContainsRect(&pChild->borderSize, box))
		{
		    (* MarkWindow)(pChild);
		    anyMarked = TRUE;
		    if (pChild->firstChild)
		    {
			pChild = pChild->firstChild;
			continue;
		    }
		}
	    }
	    while (!pChild->nextSib && (pChild != pLast))
		pChild = pChild->parent;
	    if (pChild == pLast)
		break;
	    pChild = pChild->nextSib;
	}
d199 1
a199 1
	(* MarkWindow)(pWin->parent);
d218 19
a236 22
    while (1)
    {
	if ( (val = pChild->valdata) )
	{
	    if (RegionNotEmpty(&val->after.borderExposed))
		miPaintWindow(pChild, &val->after.borderExposed, PW_BORDER);
	    RegionUninit(&val->after.borderExposed);
	    (*WindowExposures)(pChild, &val->after.exposed, NullRegion);
	    RegionUninit(&val->after.exposed);
	    free(val);
	    pChild->valdata = NULL;
	    if (pChild->firstChild)
	    {
		pChild = pChild->firstChild;
		continue;
	    }
	}
	while (!pChild->nextSib && (pChild != pWin))
	    pChild = pChild->parent;
	if (pChild == pWin)
	    break;
	pChild = pChild->nextSib;
d244 1
a244 1
    Bool WasViewable = (Bool)(pWin->viewable);
d255 1
a255 1
       return ;
d257 1
a257 1
    bw = wBorderWidth (pWin);
d261 9
a269 10
    if (WasViewable)
    {
	oldRegion = RegionCreate(NullBox, 1);
	RegionCopy(oldRegion, &pWin->borderClip);
	anyMarked = (*pScreen->MarkOverlappedWindows)(pWin, pWin, &pLayerWin);
    }
    pWin->origin.x = x + (int)bw;
    pWin->origin.y = y + (int)bw;
    x = pWin->drawable.x = pParent->drawable.x + x + (int)bw;
    y = pWin->drawable.y = pParent->drawable.y + y + (int)bw;
d271 2
a272 2
    SetWinSize (pWin);
    SetBorderSize (pWin);
d274 1
a274 1
    (*pScreen->PositionWindow)(pWin, x, y);
d280 17
a296 20
    if (WasViewable)
    {
	if (pLayerWin == pWin)
	    anyMarked |= (*pScreen->MarkOverlappedWindows)
				(pWin, windowToValidate, NULL);
	else
	    anyMarked |= (*pScreen->MarkOverlappedWindows)
				(pWin, pLayerWin, NULL);


	if (anyMarked)
	{
	    (*pScreen->ValidateTree)(pLayerWin->parent, NullWindow, kind);
	    (* pWin->drawable.pScreen->CopyWindow)(pWin, oldpt, oldRegion);
	    RegionDestroy(oldRegion);
	    /* XXX need to retile border if ParentRelative origin */
	    (*pScreen->HandleExposures)(pLayerWin->parent);
	}
	if (anyMarked && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pLayerWin->parent, NullWindow, kind);
d299 1
a299 1
	WindowsRestructured ();
a301 1

d308 3
a310 5
miRecomputeExposures (
    WindowPtr	pWin,
    pointer		value) /* must conform to VisitWindowProcPtr */
{
    RegionPtr	pValid = (RegionPtr)value;
d312 1
a312 2
    if (pWin->valdata)
    {
d314 7
a320 7
	/*
	 * Redirected windows are not affected by parent window
	 * gravity manipulations, so don't recompute their
	 * exposed areas here.
	 */
	if (pWin->redirectDraw != RedirectDrawNone)
	    return WT_DONTWALKCHILDREN;
d322 12
a333 13
	/*
	 * compute exposed regions of this window
	 */
	RegionSubtract(&pWin->valdata->after.exposed,
			&pWin->clipList, pValid);
	/*
	 * compute exposed regions of the border
	 */
	RegionSubtract(&pWin->valdata->after.borderExposed,
			     &pWin->borderClip, &pWin->winSize);
	RegionSubtract(&pWin->valdata->after.borderExposed,
			     &pWin->valdata->after.borderExposed, pValid);
	return WT_WALKCHILDREN;
d341 1
a341 2
                     unsigned int w, unsigned int h,
                     WindowPtr pSib)
d344 4
a347 6
    Bool WasViewable = (Bool)(pWin->viewable);
    unsigned short width = pWin->drawable.width,
		   height = pWin->drawable.height;
    short oldx = pWin->drawable.x,
	  oldy = pWin->drawable.y;
    int bw = wBorderWidth (pWin);
d355 1
a355 1
    RegionPtr	gravitate[StaticGravity + 1];
d357 9
a365 9
    int		nx, ny;		/* destination x,y */
    int		newx, newy;	/* new inner window position */
    RegionPtr	pRegion = NULL;
    RegionPtr	destClip;	/* portions of destination already written */
    RegionPtr	oldWinClip = NULL;	/* old clip list for window */
    RegionPtr	borderVisible = NullRegion; /* visible area of the border */
    Bool	shrunk = FALSE; /* shrunk in an inner dimension */
    Bool	moved = FALSE;	/* window position changed */
    WindowPtr  pLayerWin;
d369 1
a369 1
	return ;
d374 54
a427 65
    if (WasViewable)
    {
	anyMarked = FALSE;
	/*
	 * save the visible region of the window
	 */
	oldRegion = RegionCreate(NullBox, 1);
	RegionCopy(oldRegion, &pWin->winSize);

	/*
	 * categorize child windows into regions to be moved
	 */
	for (g = 0; g <= StaticGravity; g++)
	    gravitate[g] = (RegionPtr) NULL;
	for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib)
	{
	    g = pChild->winGravity;
	    if (g != UnmapGravity)
	    {
		if (!gravitate[g])
		    gravitate[g] = RegionCreate(NullBox, 1);
		RegionUnion(gravitate[g],
				   gravitate[g], &pChild->borderClip);
	    }
	    else
	    {
		UnmapWindow(pChild, TRUE);
		anyMarked = TRUE;
	    }
	}
	anyMarked |= (*pScreen->MarkOverlappedWindows)(pWin, pWin, 
						       &pLayerWin);

	oldWinClip = NULL;
	if (pWin->bitGravity != ForgetGravity)
	{
	    oldWinClip = RegionCreate(NullBox, 1);
	    RegionCopy(oldWinClip, &pWin->clipList);
	}
	/*
	 * if the window is changing size, borderExposed
	 * can't be computed correctly without some help.
	 */
	if (pWin->drawable.height > h || pWin->drawable.width > w)
	    shrunk = TRUE;

	if (newx != oldx || newy != oldy)
	    moved = TRUE;

	if ((pWin->drawable.height != h || pWin->drawable.width != w) &&
	    HasBorder (pWin))
	{
	    borderVisible = RegionCreate(NullBox, 1);
	    /* for tiled borders, we punt and draw the whole thing */
	    if (pWin->borderIsPixel || !moved)
	    {
		if (shrunk || moved)
		    RegionSubtract(borderVisible,
					  &pWin->borderClip,
					  &pWin->winSize);
		else
		    RegionCopy(borderVisible,
					    &pWin->borderClip);
	    }
	}
d437 2
a438 2
    SetWinSize (pWin);
    SetBorderSize (pWin);
d440 2
a441 2
    dw = (int)w - (int)width;
    dh = (int)h - (int)height;
d445 1
a445 1
    (*pScreen->PositionWindow)(pWin, x, y);
d449 100
a548 127
    if (WasViewable)
    {
	pRegion = RegionCreate(NullBox, 1);

	if (pLayerWin == pWin)
	    anyMarked |= (*pScreen->MarkOverlappedWindows)(pWin, pFirstChange,
						NULL);
	else
	    anyMarked |= (*pScreen->MarkOverlappedWindows)(pWin, pLayerWin,
						NULL);

	if (pWin->valdata)
	{
	    pWin->valdata->before.resized = TRUE;
	    pWin->valdata->before.borderVisible = borderVisible;
	}


	if (anyMarked)
	    (*pScreen->ValidateTree)(pLayerWin->parent, pFirstChange, VTOther);
	/*
	 * the entire window is trashed unless bitGravity
	 * recovers portions of it
	 */
	RegionCopy(&pWin->valdata->after.exposed, &pWin->clipList);
    }

    GravityTranslate (x, y, oldx, oldy, dw, dh, pWin->bitGravity, &nx, &ny);

    if (WasViewable)
    {
	/* avoid the border */
	if (HasBorder (pWin))
	{
	    int	offx, offy, dx, dy;

	    /* kruft to avoid double translates for each gravity */
	    offx = 0;
	    offy = 0;
	    for (g = 0; g <= StaticGravity; g++)
	    {
		if (!gravitate[g])
		    continue;

		/* align winSize to gravitate[g].
		 * winSize is in new coordinates,
		 * gravitate[g] is still in old coordinates */
		GravityTranslate (x, y, oldx, oldy, dw, dh, g, &nx, &ny);
		
		dx = (oldx - nx) - offx;
		dy = (oldy - ny) - offy;
		if (dx || dy)
		{
		    RegionTranslate(&pWin->winSize, dx, dy);
		    offx += dx;
		    offy += dy;
		}
		RegionIntersect(gravitate[g], gravitate[g],
				 &pWin->winSize);
	    }
	    /* get winSize back where it belongs */
	    if (offx || offy)
		RegionTranslate(&pWin->winSize, -offx, -offy);
	}
	/*
	 * add screen bits to the appropriate bucket
	 */

	if (oldWinClip)
	{
	    /*
	     * clip to new clipList
	     */
	    RegionCopy(pRegion, oldWinClip);
	    RegionTranslate(pRegion, nx - oldx, ny - oldy);
	    RegionIntersect(oldWinClip, pRegion, &pWin->clipList);
	    /*
	     * don't step on any gravity bits which will be copied after this
	     * region.	Note -- this assumes that the regions will be copied
	     * in gravity order.
	     */
	    for (g = pWin->bitGravity + 1; g <= StaticGravity; g++)
	    {
		if (gravitate[g])
		    RegionSubtract(oldWinClip, oldWinClip,
					gravitate[g]);
	    }
	    RegionTranslate(oldWinClip, oldx - nx, oldy - ny);
	    g = pWin->bitGravity;
	    if (!gravitate[g])
		gravitate[g] = oldWinClip;
	    else
	    {
		RegionUnion(gravitate[g], gravitate[g], oldWinClip);
		RegionDestroy(oldWinClip);
	    }
	}

	/*
	 * move the bits on the screen
	 */

	destClip = NULL;

	for (g = 0; g <= StaticGravity; g++)
	{
	    if (!gravitate[g])
		continue;

	    GravityTranslate (x, y, oldx, oldy, dw, dh, g, &nx, &ny);

	    oldpt.x = oldx + (x - nx);
	    oldpt.y = oldy + (y - ny);

	    /* Note that gravitate[g] is *translated* by CopyWindow */

	    /* only copy the remaining useful bits */

	    RegionIntersect(gravitate[g], gravitate[g], oldRegion);

	    /* clip to not overwrite already copied areas */

	    if (destClip) {
		RegionTranslate(destClip, oldpt.x - x, oldpt.y - y);
		RegionSubtract(gravitate[g], gravitate[g], destClip);
		RegionTranslate(destClip, x - oldpt.x, y - oldpt.y);
	    }
d550 1
a550 1
	    /* and move those bits */
d552 15
a566 1
	    if (oldpt.x != x || oldpt.y != y
d568 1
a568 1
		|| pWin->redirectDraw
d570 45
a614 48
		)
	    {
		(*pWin->drawable.pScreen->CopyWindow)(pWin, oldpt, gravitate[g]);
	    }

	    /* remove any overwritten bits from the remaining useful bits */

	    RegionSubtract(oldRegion, oldRegion, gravitate[g]);

	    /*
	     * recompute exposed regions of child windows
	     */
	
	    for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib)
	    {
		if (pChild->winGravity != g)
		    continue;
		RegionIntersect(pRegion,
				       &pChild->borderClip, gravitate[g]);
		TraverseTree (pChild, miRecomputeExposures, (pointer)pRegion);
	    }

	    /*
	     * remove the successfully copied regions of the
	     * window from its exposed region
	     */

	    if (g == pWin->bitGravity)
		RegionSubtract(&pWin->valdata->after.exposed,
				     &pWin->valdata->after.exposed, gravitate[g]);
	    if (!destClip)
		destClip = gravitate[g];
	    else
	    {
		RegionUnion(destClip, destClip, gravitate[g]);
		RegionDestroy(gravitate[g]);
	    }
	}

	RegionDestroy(oldRegion);
	RegionDestroy(pRegion);
	if (destClip)
	    RegionDestroy(destClip);
	if (anyMarked)
	    (*pScreen->HandleExposures)(pLayerWin->parent);
	if (anyMarked && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pLayerWin->parent, pFirstChange,
					  VTOther);
d617 1
a617 1
	WindowsRestructured ();
d636 4
a639 4
    Bool        WasViewable = (Bool)(pWin->viewable);
    ScreenPtr   pScreen = pWin->drawable.pScreen;
    Bool        anyMarked = FALSE;
    WindowPtr   pLayerWin;
d642 5
a646 8
        if (WasViewable)
        {
            anyMarked = (*pScreen->MarkOverlappedWindows)(pWin, pWin,
                                                          &pLayerWin);
            if (pWin->valdata)
            {
                if (HasBorder (pWin))
                {
d651 1
a651 1
                                    &pWin->borderClip, &pWin->winSize);
d658 2
a659 2
        SetWinSize (pWin);
        SetBorderSize (pWin);
d663 2
a664 4
        if (WasViewable)
        {
            anyMarked |= (*pScreen->MarkOverlappedWindows)(pWin, pWin,
                                                           NULL);
d667 2
a668 2
                (*pScreen->ValidateTree)(pLayerWin->parent, NullWindow,
                                         VTOther);
d671 1
a671 2
        if (WasViewable)
        {
d673 1
a673 1
                (*pScreen->HandleExposures)(pLayerWin->parent);
d675 2
a676 2
                (*pScreen->PostValidateTree)(pLayerWin->parent, NullWindow,
                                             VTOther);
d680 1
a680 1
        WindowsRestructured ();
d692 1
a692 1
    Bool WasViewable = (Bool)(pWin->viewable);
d694 1
a694 1
    WindowPtr  pLayerWin;
d696 1
a696 1
    oldwidth = wBorderWidth (pWin);
d698 1
a698 1
	return;
d702 1
a702 1
	anyMarked = (*pScreen->MarkOverlappedWindows)(pWin, pWin, &pLayerWin);
d705 1
a705 1
    SetBorderSize (pWin);
d707 25
a731 28
    if (WasViewable)
    {
	if (width > oldwidth)
	{
	    anyMarked = (*pScreen->MarkOverlappedWindows)(pWin, pWin,
							  &pLayerWin);
	    /*
	     * save the old border visible region to correctly compute
	     * borderExposed.
	     */
	    if (pWin->valdata && HadBorder)
	    {
		RegionPtr   borderVisible;
		borderVisible = RegionCreate(NULL, 1);
		RegionSubtract(borderVisible,
				      &pWin->borderClip, &pWin->winSize);
		pWin->valdata->before.borderVisible = borderVisible;
	    }
	}

	if (anyMarked)
	{
	    (*pScreen->ValidateTree)(pLayerWin->parent, pLayerWin, VTOther);
	    (*pScreen->HandleExposures)(pLayerWin->parent);
	}
	if (anyMarked && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pLayerWin->parent, pLayerWin,
					  VTOther);
d734 1
a734 1
	WindowsRestructured ();
d740 5
a744 6
    if ((pChild != pWin) || fromConfigure)
    {
	RegionEmpty(&pChild->clipList);
	if (pChild->drawable.pScreen->ClipNotify)
	    (* pChild->drawable.pScreen->ClipNotify)(pChild, 0, 0);
	RegionEmpty(&pChild->borderClip);
d753 3
a755 4
    for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib)
    {
	if (pChild->drawable.depth == depth)
	    RegionUnion(pReg, pReg, &pChild->borderClip);
d757 2
a758 2
	if (pChild->firstChild)
	    miSegregateChildren(pChild, pReg, depth);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a68 1
    RegionPtr pBSReg = NullRegion;
d116 1
a116 1
	(*pWin->drawable.pScreen->WindowExposures)(pWin, &reg, pBSReg);
a119 2
    if (pBSReg)
	RegionDestroy(pBSReg);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d53 1
a69 1
    ScreenPtr	pScreen;
d113 1
a113 2
    pScreen = pWin->drawable.pScreen;
    REGION_INIT(pScreen, &reg, &box, 1);
d115 1
a115 1
    REGION_INTERSECT(pScreen, &reg, &reg, &pWin->clipList);
d117 1
a117 1
	(*pScreen->WindowExposures)(pWin, &reg, pBSReg);
d120 1
a120 1
    REGION_UNINIT(pScreen, &reg);
d122 1
a122 1
	REGION_DESTROY(pScreen, pBSReg);
a146 3
    ScreenPtr pScreen;

    pScreen = pWin->drawable.pScreen;
d162 1
a162 1
		if (REGION_BROKEN (pScreen, &pChild->winSize))
d164 1
a164 1
		if (REGION_BROKEN (pScreen, &pChild->borderSize))
d184 1
a184 1
	box = REGION_EXTENTS(pChild->drawable.pScreen, &pWin->borderSize);
d190 1
a190 1
		if (REGION_BROKEN (pScreen, &pChild->winSize))
d192 1
a192 1
		if (REGION_BROKEN (pScreen, &pChild->borderSize))
d194 1
a194 1
		if (RECT_IN_REGION(pScreen, &pChild->borderSize, box))
a227 1
    ScreenPtr pScreen;
a229 2
    pScreen = pWin->drawable.pScreen;

d236 1
a236 1
	    if (REGION_NOTEMPTY(pScreen, &val->after.borderExposed))
d238 1
a238 1
	    REGION_UNINIT(pScreen, &val->after.borderExposed);
d240 2
a241 2
	    REGION_UNINIT(pScreen, &val->after.exposed);
	    xfree(val);
d280 2
a281 2
	oldRegion = REGION_CREATE(pScreen, NullBox, 1);
	REGION_COPY(pScreen, oldRegion, &pWin->borderClip);
d312 1
a312 1
	    REGION_DESTROY(pScreen, oldRegion);
a333 1
    ScreenPtr	pScreen;
a346 1
	pScreen = pWin->drawable.pScreen;
d350 1
a350 1
	REGION_SUBTRACT(pScreen, &pWin->valdata->after.exposed,
d355 1
a355 1
	REGION_SUBTRACT(pScreen, &pWin->valdata->after.borderExposed,
d357 1
a357 1
	REGION_SUBTRACT(pScreen, &pWin->valdata->after.borderExposed,
d409 2
a410 2
	oldRegion = REGION_CREATE(pScreen, NullBox, 1);
	REGION_COPY(pScreen, oldRegion, &pWin->winSize);
d423 2
a424 2
		    gravitate[g] = REGION_CREATE(pScreen, NullBox, 1);
		REGION_UNION(pScreen, gravitate[g],
d439 2
a440 2
	    oldWinClip = REGION_CREATE(pScreen, NullBox, 1);
	    REGION_COPY(pScreen, oldWinClip, &pWin->clipList);
d455 1
a455 1
	    borderVisible = REGION_CREATE(pScreen, NullBox, 1);
d460 1
a460 1
		    REGION_SUBTRACT(pScreen, borderVisible,
d464 1
a464 1
		    REGION_COPY(pScreen, borderVisible,
d491 1
a491 1
	pRegion = REGION_CREATE(pScreen, NullBox, 1);
d513 1
a513 1
	REGION_COPY(pScreen, &pWin->valdata->after.exposed, &pWin->clipList);
d542 1
a542 1
		    REGION_TRANSLATE(pScreen, &pWin->winSize, dx, dy);
d546 1
a546 1
		REGION_INTERSECT(pScreen, gravitate[g], gravitate[g],
d551 1
a551 1
		REGION_TRANSLATE(pScreen, &pWin->winSize, -offx, -offy);
d562 3
a564 3
	    REGION_COPY(pScreen, pRegion, oldWinClip);
	    REGION_TRANSLATE(pScreen, pRegion, nx - oldx, ny - oldy);
	    REGION_INTERSECT(pScreen, oldWinClip, pRegion, &pWin->clipList);
d573 1
a573 1
		    REGION_SUBTRACT(pScreen, oldWinClip, oldWinClip,
d576 1
a576 1
	    REGION_TRANSLATE(pScreen, oldWinClip, oldx - nx, oldy - ny);
d582 2
a583 2
		REGION_UNION(pScreen, gravitate[g], gravitate[g], oldWinClip);
		REGION_DESTROY(pScreen, oldWinClip);
d607 1
a607 1
	    REGION_INTERSECT(pScreen, gravitate[g], gravitate[g], oldRegion);
d612 3
a614 3
		REGION_TRANSLATE(pScreen, destClip, oldpt.x - x, oldpt.y - y);
		REGION_SUBTRACT(pScreen, gravitate[g], gravitate[g], destClip);
		REGION_TRANSLATE(pScreen, destClip, x - oldpt.x, y - oldpt.y);
d630 1
a630 1
	    REGION_SUBTRACT(pScreen, oldRegion, oldRegion, gravitate[g]);
d640 1
a640 1
		REGION_INTERSECT(pScreen, pRegion,
d651 1
a651 1
		REGION_SUBTRACT(pScreen, &pWin->valdata->after.exposed,
d657 2
a658 2
		REGION_UNION(pScreen, destClip, destClip, gravitate[g]);
		REGION_DESTROY(pScreen, gravitate[g]);
d662 2
a663 2
	REGION_DESTROY(pScreen, oldRegion);
	REGION_DESTROY(pScreen, pRegion);
d665 1
a665 1
	    REGION_DESTROY(pScreen, destClip);
d690 1
a690 1
miSetShape(WindowPtr pWin)
d692 3
a694 3
    Bool	WasViewable = (Bool)(pWin->viewable);
    ScreenPtr 	pScreen = pWin->drawable.pScreen;
    Bool	anyMarked = FALSE;
d697 43
a739 40
    if (WasViewable)
    {
	anyMarked = (*pScreen->MarkOverlappedWindows)(pWin, pWin,
						      &pLayerWin);
	if (pWin->valdata)
	{
	    if (HasBorder (pWin))
	    {
		RegionPtr	borderVisible;

		borderVisible = REGION_CREATE(pScreen, NullBox, 1);
		REGION_SUBTRACT(pScreen, borderVisible,
				      &pWin->borderClip, &pWin->winSize);
		pWin->valdata->before.borderVisible = borderVisible;
	    }
	    pWin->valdata->before.resized = TRUE;
	}
    }

    SetWinSize (pWin);
    SetBorderSize (pWin);

    ResizeChildrenWinSize(pWin, 0, 0, 0, 0);

    if (WasViewable)
    {
	anyMarked |= (*pScreen->MarkOverlappedWindows)(pWin, pWin,
						NULL);


	if (anyMarked)
	    (*pScreen->ValidateTree)(pLayerWin->parent, NullWindow, VTOther);
    }

    if (WasViewable)
    {
	if (anyMarked)
	    (*pScreen->HandleExposures)(pLayerWin->parent);
	if (anyMarked && pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pLayerWin->parent, NullWindow, VTOther);
d742 1
a742 1
	WindowsRestructured ();
d782 2
a783 2
		borderVisible = REGION_CREATE(pScreen, NULL, 1);
		REGION_SUBTRACT(pScreen, borderVisible,
d807 1
a807 1
	REGION_EMPTY(pChild->drawable.pScreen, &pChild->clipList);
d810 1
a810 1
	REGION_EMPTY(pChild->drawable.pScreen, &pChild->borderClip);
a816 1
    ScreenPtr pScreen;
a818 2
    pScreen = pWin->drawable.pScreen;

d822 1
a822 1
	    REGION_UNION(pScreen, pReg, pReg, &pChild->borderClip);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d1 1
d61 1
a61 1
_X_EXPORT void
d249 1
a249 1
	    pChild->valdata = (ValidatePtr)NULL;
d309 1
a309 1
				(pWin, windowToValidate, (WindowPtr *)NULL);
d312 1
a312 1
				(pWin, pLayerWin, (WindowPtr *)NULL);
d504 1
a504 1
						(WindowPtr *)NULL);
d507 1
a507 1
						(WindowPtr *)NULL);
d733 1
a733 1
						(WindowPtr *)NULL);
d820 1
a820 1
_X_EXPORT void
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d60 4
a63 6
_X_EXPORT void 
miClearToBackground(pWin, x, y, w, h, generateExposures)
    WindowPtr pWin;
    int x,y;
    int w,h;
    Bool generateExposures;
a124 204
/*
 * For SaveUnders using backing-store. The idea is that when a window is mapped
 * with saveUnder set TRUE, any windows it obscures will have its backing
 * store turned on setting the DIXsaveUnder bit,
 * The backing-store code must be written to allow for this
 */

/*-
 *-----------------------------------------------------------------------
 * miCheckSubSaveUnder --
 *	Check all the inferiors of a window for coverage by saveUnder
 *	windows. Called from ChangeSaveUnder and CheckSaveUnder.
 *	This code is very inefficient.
 *
 * Results:
 *	TRUE if any windows need to have backing-store removed.
 *
 * Side Effects:
 *	Windows may have backing-store turned on or off.
 *
 *-----------------------------------------------------------------------
 */
static Bool
miCheckSubSaveUnder(
    WindowPtr		pParent,	/* Parent to check */
    WindowPtr		pFirst,		/* first reconfigured window */
    RegionPtr		pRegion)	/* Initial area obscured by saveUnder */
{
    WindowPtr		pChild;		/* Current child */
    ScreenPtr		pScreen;	/* Screen to use */
    RegionRec		SubRegion;	/* Area of children obscured */
    Bool		res = FALSE;	/* result */
    Bool		subInited=FALSE;/* SubRegion initialized */

    pScreen = pParent->drawable.pScreen;
    if ( (pChild = pParent->firstChild) )
    {
	/*
	 * build region above first changed window
	 */

	for (; pChild != pFirst; pChild = pChild->nextSib)
	    if (pChild->viewable && pChild->saveUnder)
		REGION_UNION(pScreen, pRegion, pRegion, &pChild->borderSize);
	
	/*
	 * check region below and including first changed window
	 */

	for (; pChild; pChild = pChild->nextSib)
	{
	    if (pChild->viewable)
	    {
		/*
		 * don't save under nephew/niece windows;
		 * use a separate region
		 */

		if (pChild->firstChild)
		{
		    if (!subInited)
		    {
			REGION_NULL(pScreen, &SubRegion);
			subInited = TRUE;
		    }
		    REGION_COPY(pScreen, &SubRegion, pRegion);
		    res |= miCheckSubSaveUnder(pChild, pChild->firstChild,
					     &SubRegion);
		}
		else
		{
		    res |= miCheckSubSaveUnder(pChild, pChild->firstChild,
					     pRegion);
		}

		if (pChild->saveUnder)
		    REGION_UNION(pScreen, pRegion, pRegion, &pChild->borderSize);
	    }
	}

	if (subInited)
	    REGION_UNINIT(pScreen, &SubRegion);
    }

    /*
     * Check the state of this window.	DIX save unders are
     * enabled for viewable windows with some client expressing
     * exposure interest and which intersect the save under region
     */

    if (pParent->viewable && 
	((pParent->eventMask | wOtherEventMasks(pParent)) & ExposureMask) &&
	REGION_NOTEMPTY(pScreen, &pParent->borderSize) &&
	RECT_IN_REGION(pScreen, pRegion, REGION_EXTENTS(pScreen, 
					&pParent->borderSize)) != rgnOUT)
    {
	if (!pParent->DIXsaveUnder)
	{
	    pParent->DIXsaveUnder = TRUE;
	    (*pScreen->ChangeWindowAttributes) (pParent, CWBackingStore);
	}
    }
    else
    {
	if (pParent->DIXsaveUnder)
	{
	    res = TRUE;
	    pParent->DIXsaveUnder = FALSE;
	}
    }
    return res;
}


/*-
 *-----------------------------------------------------------------------
 * miChangeSaveUnder --
 *	Change the save-under state of a tree of windows. Called when
 *	a window with saveUnder TRUE is mapped/unmapped/reconfigured.
 *	
 * Results:
 *	TRUE if any windows need to have backing-store removed (which
 *	means that PostChangeSaveUnder needs to be called later to 
 *	finish the job).
 *
 * Side Effects:
 *	Windows may have backing-store turned on or off.
 *
 *-----------------------------------------------------------------------
 */
Bool
miChangeSaveUnder(pWin, first)
    WindowPtr		pWin;
    WindowPtr		first;		/* First window to check.
					 * Used when pWin was restacked */
{
    RegionRec	rgn;	/* Area obscured by saveUnder windows */
    ScreenPtr 	pScreen;
    Bool	res;

    if (!deltaSaveUndersViewable && !numSaveUndersViewable)
	return FALSE;
    numSaveUndersViewable += deltaSaveUndersViewable;
    deltaSaveUndersViewable = 0;
    pScreen = pWin->drawable.pScreen;
    REGION_NULL(pScreen, &rgn);
    res = miCheckSubSaveUnder (pWin->parent,
			       pWin->saveUnder ? first : pWin->nextSib,
			       &rgn);
    REGION_UNINIT(pScreen, &rgn);
    return res;
}

/*-
 *-----------------------------------------------------------------------
 * miPostChangeSaveUnder --
 *	Actually turn backing-store off for those windows that no longer
 *	need to have it on.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	Backing-store and SAVE_UNDER_CHANGE_BIT are turned off for those
 *	windows affected.
 *
 *-----------------------------------------------------------------------
 */
void
miPostChangeSaveUnder(pWin, pFirst)
    WindowPtr		pWin;
    WindowPtr		pFirst;
{
    WindowPtr pParent, pChild;
    ChangeWindowAttributesProcPtr ChangeWindowAttributes;

    if (!(pParent = pWin->parent))
	return;
    ChangeWindowAttributes = pParent->drawable.pScreen->ChangeWindowAttributes;
    if (!pParent->DIXsaveUnder &&
	(pParent->backingStore == NotUseful) && pParent->backStorage)
	(*ChangeWindowAttributes)(pParent, CWBackingStore);
    if (!(pChild = pFirst))
	return;
    while (1)
    {
	if (!pChild->DIXsaveUnder &&
	    (pChild->backingStore == NotUseful) && pChild->backStorage)
	    (*ChangeWindowAttributes)(pChild, CWBackingStore);
	if (pChild->firstChild)
	{
	    pChild = pChild->firstChild;
	    continue;
	}
	while (!pChild->nextSib)
	{
	    pChild = pChild->parent;
	    if (pChild == pParent)
		return;
	}
	pChild = pChild->nextSib;
    }
}

d126 1
a126 2
miMarkWindow(pWin)
    WindowPtr pWin;
d141 1
a141 4
miMarkOverlappedWindows(pWin, pFirst, ppLayerWin)
    WindowPtr pWin;
    WindowPtr pFirst;
    WindowPtr *ppLayerWin;
d226 2
a227 3
_X_EXPORT void
miHandleValidateExposures(pWin)
    WindowPtr pWin;
d264 1
a264 5
miMoveWindow(pWin, x, y, pNextSib, kind)
    WindowPtr pWin;
    int x,y;
    WindowPtr pNextSib;
    VTKind kind;
a273 3
#ifdef DO_SAVE_UNDERS
    Bool dosave = FALSE;
#endif
a312 6
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	{
	    dosave = (*pScreen->ChangeSaveUnder)(pLayerWin, windowToValidate);
	}
#endif /* DO_SAVE_UNDERS */
a321 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pLayerWin, windowToValidate);
#endif /* DO_SAVE_UNDERS */
d345 9
d373 4
a376 5
miSlideAndSizeWindow(pWin, x, y, w, h, pSib)
    WindowPtr pWin;
    int x,y;
    unsigned int w, h;
    WindowPtr pSib;
a401 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a513 6
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	{
	    dosave = (*pScreen->ChangeSaveUnder)(pLayerWin, pFirstChange);
	}
#endif /* DO_SAVE_UNDERS */
a675 6
#ifdef DO_SAVE_UNDERS
	if (dosave)
	{
	    (*pScreen->PostChangeSaveUnder)(pLayerWin, pFirstChange);
	}
#endif /* DO_SAVE_UNDERS */
d685 1
a685 2
miGetLayerWindow(pWin)
    WindowPtr pWin;
a689 1
#ifdef SHAPE
d697 2
a698 3
_X_EXPORT void
miSetShape(pWin)
    WindowPtr	pWin;
a702 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a733 6
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	{
	    dosave = (*pScreen->ChangeSaveUnder)(pLayerWin, pLayerWin);
	}
#endif /* DO_SAVE_UNDERS */
a742 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pLayerWin, pLayerWin);
#endif /* DO_SAVE_UNDERS */
a749 1
#endif
d753 2
a754 4
_X_EXPORT void
miChangeBorderWidth(pWin, width)
    WindowPtr pWin;
    unsigned int width;
a760 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a792 6
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	{
	    dosave = (*pScreen->ChangeSaveUnder)(pLayerWin, pWin->nextSib);
	}
#endif /* DO_SAVE_UNDERS */
a798 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pLayerWin, pWin->nextSib);
#endif /* DO_SAVE_UNDERS */
d808 1
a808 4
miMarkUnrealizedWindow(pChild, pWin, fromConfigure)
    WindowPtr pChild;
    WindowPtr pWin;
    Bool fromConfigure;
@


1.1
log
@Initial revision
@
text
@a115 12
    if (pWin->backStorage)
    {
	/*
	 * If the window has backing-store on, call through the
	 * ClearToBackground vector to handle the special semantics
	 * (i.e. things backing store is to be cleared out and
	 * an Expose event is to be generated for those areas in backing
	 * store if generateExposures is TRUE).
	 */
	pBSReg = (* pScreen->ClearBackingStore)(pWin, x, y, w, h,
						 generateExposures);
    }
d121 1
a121 1
        (*pScreen->PaintWindowBackground)(pWin, &reg, PW_BACKGROUND);
d151 1
a151 1
    register WindowPtr	pParent,	/* Parent to check */
d155 2
a156 2
    register WindowPtr	pChild;		/* Current child */
    register ScreenPtr	pScreen;	/* Screen to use */
d259 1
a259 1
    register WindowPtr	pWin;
d264 1
a264 1
    register ScreenPtr pScreen;
d300 1
a300 1
    register WindowPtr pParent, pChild;
d333 1
a333 1
    register WindowPtr pWin;
d335 1
a335 1
    register ValidatePtr val;
d353 2
a354 2
    register BoxPtr box;
    register WindowPtr pChild, pLast;
d440 2
a441 2
    register WindowPtr pChild;
    register ValidatePtr val;
d454 1
a454 3
		(*pChild->drawable.pScreen->PaintWindowBorder)(pChild,
						    &val->after.borderExposed,
						    PW_BORDER);
d476 1
a476 1
    register WindowPtr pWin;
d487 1
a487 1
    register ScreenPtr pScreen;
d565 1
a565 1
    register WindowPtr	pWin,
d568 1
a568 1
    register ScreenPtr	pScreen;
d593 1
a593 1
    register WindowPtr pWin;
d609 1
a609 1
    register ScreenPtr pScreen;
d611 1
a611 1
    register WindowPtr pChild;
d613 1
a613 1
    register unsigned g;
a619 1
    RegionPtr	bsExposed = NullRegion;	    /* backing store exposures */
a722 2
	if (pWin->backStorage)
	    REGION_COPY(pScreen, pRegion, &pWin->clipList);
a754 15
    if (pWin->backStorage &&
	((pWin->backingStore == Always) || WasViewable))
    {
	if (!WasViewable)
	    pRegion = &pWin->clipList; /* a convenient empty region */
	if (pWin->bitGravity == ForgetGravity)
	    bsExposed = (*pScreen->TranslateBackingStore)
				(pWin, 0, 0, NullRegion, oldx, oldy);
	else
	{
	    bsExposed = (*pScreen->TranslateBackingStore)
			     (pWin, nx - x, ny - y, pRegion, oldx, oldy);
	}
    }

a902 11
	if (bsExposed)
	{
	    RegionPtr	valExposed = NullRegion;

	    if (pWin->valdata)
		valExposed = &pWin->valdata->after.exposed;
	    (*pScreen->WindowExposures) (pWin, valExposed, bsExposed);
	    if (valExposed)
		REGION_EMPTY(pScreen, valExposed);
	    REGION_DESTROY(pScreen, bsExposed);
	}
a914 5
    else if (bsExposed)
    {
	(*pScreen->WindowExposures) (pWin, NullRegion, bsExposed);
	REGION_DESTROY(pScreen, bsExposed);
    }
d936 1
a936 1
    register WindowPtr	pWin;
d939 1
a939 1
    register ScreenPtr pScreen = pWin->drawable.pScreen;
a940 1
    RegionPtr	pOldClip = NULL, bsExposed;
a971 6
	if (pWin->backStorage)
	{
	    pOldClip = REGION_CREATE(pScreen, NullBox, 1);
	    REGION_COPY(pScreen, pOldClip, &pWin->clipList);
	}

a985 22
    if (pWin->backStorage &&
	((pWin->backingStore == Always) || WasViewable))
    {
	if (!WasViewable)
	    pOldClip = &pWin->clipList; /* a convenient empty region */
	bsExposed = (*pScreen->TranslateBackingStore)
			     (pWin, 0, 0, pOldClip,
			      pWin->drawable.x, pWin->drawable.y);
	if (WasViewable)
	    REGION_DESTROY(pScreen, pOldClip);
	if (bsExposed)
	{
	    RegionPtr	valExposed = NullRegion;
    
	    if (pWin->valdata)
		valExposed = &pWin->valdata->after.exposed;
	    (*pScreen->WindowExposures) (pWin, valExposed, bsExposed);
	    if (valExposed)
		REGION_EMPTY(pScreen, valExposed);
	    REGION_DESTROY(pScreen, bsExposed);
	}
    }
d1007 1
a1007 1
    register WindowPtr pWin;
d1012 1
a1012 1
    register ScreenPtr pScreen;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d163 1
a163 1
    WindowPtr		pParent,	/* Parent to check */
d167 2
a168 2
    WindowPtr		pChild;		/* Current child */
    ScreenPtr		pScreen;	/* Screen to use */
d271 1
a271 1
    WindowPtr		pWin;
d276 1
a276 1
    ScreenPtr 	pScreen;
d312 1
a312 1
    WindowPtr pParent, pChild;
d345 1
a345 1
    WindowPtr pWin;
d347 1
a347 1
    ValidatePtr val;
d365 2
a366 2
    BoxPtr box;
    WindowPtr pChild, pLast;
d452 2
a453 2
    WindowPtr pChild;
    ValidatePtr val;
d490 1
a490 1
    WindowPtr pWin;
d501 1
a501 1
    ScreenPtr pScreen;
d579 1
a579 1
    WindowPtr	pWin,
d582 1
a582 1
    ScreenPtr	pScreen;
d607 1
a607 1
    WindowPtr pWin;
d623 1
a623 1
    ScreenPtr pScreen;
d625 1
a625 1
    WindowPtr pChild;
d627 1
a627 1
    unsigned g;
d984 1
a984 1
    WindowPtr	pWin;
d987 1
a987 1
    ScreenPtr 	pScreen = pWin->drawable.pScreen;
d1084 1
a1084 1
    WindowPtr pWin;
d1089 1
a1089 1
    ScreenPtr pScreen;
@

