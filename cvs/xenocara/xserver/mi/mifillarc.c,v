head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.14
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.12
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.16;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.42;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/************************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

Author:  Bob Scheifler, MIT X Consortium

********************************************************/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <math.h>
#include <X11/X.h>
#include <X11/Xprotostr.h>
#include "regionstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "mi.h"
#include "mifillarc.h"

#define QUADRANT (90 * 64)
#define HALFCIRCLE (180 * 64)
#define QUADRANT3 (270 * 64)

#ifndef M_PI
#define M_PI	3.14159265358979323846
#endif

#define Dsin(d)	sin((double)d*(M_PI/11520.0))
#define Dcos(d)	cos((double)d*(M_PI/11520.0))

static void
miFillArcSetup(xArc * arc, miFillArcRec * info)
{
    info->y = arc->height >> 1;
    info->dy = arc->height & 1;
    info->yorg = arc->y + info->y;
    info->dx = arc->width & 1;
    info->xorg = arc->x + (arc->width >> 1) + info->dx;
    info->dx = 1 - info->dx;
    if (arc->width == arc->height) {
        /* (2x - 2xorg)^2 = d^2 - (2y - 2yorg)^2 */
        /* even: xorg = yorg = 0   odd:  xorg = .5, yorg = -.5 */
        info->ym = 8;
        info->xm = 8;
        info->yk = info->y << 3;
        if (!info->dx) {
            info->xk = 0;
            info->e = -1;
        }
        else {
            info->y++;
            info->yk += 4;
            info->xk = -4;
            info->e = -(info->y << 3);
        }
    }
    else {
        /* h^2 * (2x - 2xorg)^2 = w^2 * h^2 - w^2 * (2y - 2yorg)^2 */
        /* even: xorg = yorg = 0   odd:  xorg = .5, yorg = -.5 */
        info->ym = (arc->width * arc->width) << 3;
        info->xm = (arc->height * arc->height) << 3;
        info->yk = info->y * info->ym;
        if (!info->dy)
            info->yk -= info->ym >> 1;
        if (!info->dx) {
            info->xk = 0;
            info->e = -(info->xm >> 3);
        }
        else {
            info->y++;
            info->yk += info->ym;
            info->xk = -(info->xm >> 1);
            info->e = info->xk - info->yk;
        }
    }
}

static void
miFillArcDSetup(xArc * arc, miFillArcDRec * info)
{
    /* h^2 * (2x - 2xorg)^2 = w^2 * h^2 - w^2 * (2y - 2yorg)^2 */
    /* even: xorg = yorg = 0   odd:  xorg = .5, yorg = -.5 */
    info->y = arc->height >> 1;
    info->dy = arc->height & 1;
    info->yorg = arc->y + info->y;
    info->dx = arc->width & 1;
    info->xorg = arc->x + (arc->width >> 1) + info->dx;
    info->dx = 1 - info->dx;
    info->ym = ((double) arc->width) * (arc->width * 8);
    info->xm = ((double) arc->height) * (arc->height * 8);
    info->yk = info->y * info->ym;
    if (!info->dy)
        info->yk -= info->ym / 2.0;
    if (!info->dx) {
        info->xk = 0;
        info->e = -(info->xm / 8.0);
    }
    else {
        info->y++;
        info->yk += info->ym;
        info->xk = -info->xm / 2.0;
        info->e = info->xk - info->yk;
    }
}

static void
miGetArcEdge(xArc * arc, miSliceEdgePtr edge, int k, Bool top, Bool left)
{
    int xady, y;

    y = arc->height >> 1;
    if (!(arc->width & 1))
        y++;
    if (!top) {
        y = -y;
        if (arc->height & 1)
            y--;
    }
    xady = k + y * edge->dx;
    if (xady <= 0)
        edge->x = -((-xady) / edge->dy + 1);
    else
        edge->x = (xady - 1) / edge->dy;
    edge->e = xady - edge->x * edge->dy;
    if ((top && (edge->dx < 0)) || (!top && (edge->dx > 0)))
        edge->e = edge->dy - edge->e + 1;
    if (left)
        edge->x++;
    edge->x += arc->x + (arc->width >> 1);
    if (edge->dx > 0) {
        edge->deltax = 1;
        edge->stepx = edge->dx / edge->dy;
        edge->dx = edge->dx % edge->dy;
    }
    else {
        edge->deltax = -1;
        edge->stepx = -((-edge->dx) / edge->dy);
        edge->dx = (-edge->dx) % edge->dy;
    }
    if (!top) {
        edge->deltax = -edge->deltax;
        edge->stepx = -edge->stepx;
    }
}

static void
miEllipseAngleToSlope(int angle, int width, int height, int *dxp, int *dyp,
                      double *d_dxp, double *d_dyp)
{
    int dx, dy;
    double d_dx, d_dy, scale;
    Bool negative_dx, negative_dy;

    switch (angle) {
    case 0:
        *dxp = -1;
        *dyp = 0;
        if (d_dxp) {
            *d_dxp = width / 2.0;
            *d_dyp = 0;
        }
        break;
    case QUADRANT:
        *dxp = 0;
        *dyp = 1;
        if (d_dxp) {
            *d_dxp = 0;
            *d_dyp = -height / 2.0;
        }
        break;
    case HALFCIRCLE:
        *dxp = 1;
        *dyp = 0;
        if (d_dxp) {
            *d_dxp = -width / 2.0;
            *d_dyp = 0;
        }
        break;
    case QUADRANT3:
        *dxp = 0;
        *dyp = -1;
        if (d_dxp) {
            *d_dxp = 0;
            *d_dyp = height / 2.0;
        }
        break;
    default:
        d_dx = Dcos(angle) * width;
        d_dy = Dsin(angle) * height;
        if (d_dxp) {
            *d_dxp = d_dx / 2.0;
            *d_dyp = -d_dy / 2.0;
        }
        negative_dx = FALSE;
        if (d_dx < 0.0) {
            d_dx = -d_dx;
            negative_dx = TRUE;
        }
        negative_dy = FALSE;
        if (d_dy < 0.0) {
            d_dy = -d_dy;
            negative_dy = TRUE;
        }
        scale = d_dx;
        if (d_dy > d_dx)
            scale = d_dy;
        dx = floor((d_dx * 32768) / scale + 0.5);
        if (negative_dx)
            dx = -dx;
        *dxp = dx;
        dy = floor((d_dy * 32768) / scale + 0.5);
        if (negative_dy)
            dy = -dy;
        *dyp = dy;
        break;
    }
}

static void
miGetPieEdge(xArc * arc, int angle, miSliceEdgePtr edge, Bool top, Bool left)
{
    int k;
    int dx, dy;

    miEllipseAngleToSlope(angle, arc->width, arc->height, &dx, &dy, 0, 0);

    if (dy == 0) {
        edge->x = left ? -65536 : 65536;
        edge->stepx = 0;
        edge->e = 0;
        edge->dx = -1;
        return;
    }
    if (dx == 0) {
        edge->x = arc->x + (arc->width >> 1);
        if (left && (arc->width & 1))
            edge->x++;
        else if (!left && !(arc->width & 1))
            edge->x--;
        edge->stepx = 0;
        edge->e = 0;
        edge->dx = -1;
        return;
    }
    if (dy < 0) {
        dx = -dx;
        dy = -dy;
    }
    k = (arc->height & 1) ? dx : 0;
    if (arc->width & 1)
        k += dy;
    edge->dx = dx << 1;
    edge->dy = dy << 1;
    miGetArcEdge(arc, edge, k, top, left);
}

static void
miFillArcSliceSetup(xArc * arc, miArcSliceRec * slice, GCPtr pGC)
{
    int angle1, angle2;

    angle1 = arc->angle1;
    if (arc->angle2 < 0) {
        angle2 = angle1;
        angle1 += arc->angle2;
    }
    else
        angle2 = angle1 + arc->angle2;
    while (angle1 < 0)
        angle1 += FULLCIRCLE;
    while (angle1 >= FULLCIRCLE)
        angle1 -= FULLCIRCLE;
    while (angle2 < 0)
        angle2 += FULLCIRCLE;
    while (angle2 >= FULLCIRCLE)
        angle2 -= FULLCIRCLE;
    slice->min_top_y = 0;
    slice->max_top_y = arc->height >> 1;
    slice->min_bot_y = 1 - (arc->height & 1);
    slice->max_bot_y = slice->max_top_y - 1;
    slice->flip_top = FALSE;
    slice->flip_bot = FALSE;
    if (pGC->arcMode == ArcPieSlice) {
        slice->edge1_top = (angle1 < HALFCIRCLE);
        slice->edge2_top = (angle2 <= HALFCIRCLE);
        if ((angle2 == 0) || (angle1 == HALFCIRCLE)) {
            if (angle2 ? slice->edge2_top : slice->edge1_top)
                slice->min_top_y = slice->min_bot_y;
            else
                slice->min_top_y = arc->height;
            slice->min_bot_y = 0;
        }
        else if ((angle1 == 0) || (angle2 == HALFCIRCLE)) {
            slice->min_top_y = slice->min_bot_y;
            if (angle1 ? slice->edge1_top : slice->edge2_top)
                slice->min_bot_y = arc->height;
            else
                slice->min_bot_y = 0;
        }
        else if (slice->edge1_top == slice->edge2_top) {
            if (angle2 < angle1) {
                slice->flip_top = slice->edge1_top;
                slice->flip_bot = !slice->edge1_top;
            }
            else if (slice->edge1_top) {
                slice->min_top_y = 1;
                slice->min_bot_y = arc->height;
            }
            else {
                slice->min_bot_y = 0;
                slice->min_top_y = arc->height;
            }
        }
        miGetPieEdge(arc, angle1, &slice->edge1,
                     slice->edge1_top, !slice->edge1_top);
        miGetPieEdge(arc, angle2, &slice->edge2,
                     slice->edge2_top, slice->edge2_top);
    }
    else {
        double w2, h2, x1, y1, x2, y2, dx, dy, scale;
        int signdx, signdy, y, k;
        Bool isInt1 = TRUE, isInt2 = TRUE;

        w2 = (double) arc->width / 2.0;
        h2 = (double) arc->height / 2.0;
        if ((angle1 == 0) || (angle1 == HALFCIRCLE)) {
            x1 = angle1 ? -w2 : w2;
            y1 = 0.0;
        }
        else if ((angle1 == QUADRANT) || (angle1 == QUADRANT3)) {
            x1 = 0.0;
            y1 = (angle1 == QUADRANT) ? h2 : -h2;
        }
        else {
            isInt1 = FALSE;
            x1 = Dcos(angle1) * w2;
            y1 = Dsin(angle1) * h2;
        }
        if ((angle2 == 0) || (angle2 == HALFCIRCLE)) {
            x2 = angle2 ? -w2 : w2;
            y2 = 0.0;
        }
        else if ((angle2 == QUADRANT) || (angle2 == QUADRANT3)) {
            x2 = 0.0;
            y2 = (angle2 == QUADRANT) ? h2 : -h2;
        }
        else {
            isInt2 = FALSE;
            x2 = Dcos(angle2) * w2;
            y2 = Dsin(angle2) * h2;
        }
        dx = x2 - x1;
        dy = y2 - y1;
        if (arc->height & 1) {
            y1 -= 0.5;
            y2 -= 0.5;
        }
        if (arc->width & 1) {
            x1 += 0.5;
            x2 += 0.5;
        }
        if (dy < 0.0) {
            dy = -dy;
            signdy = -1;
        }
        else
            signdy = 1;
        if (dx < 0.0) {
            dx = -dx;
            signdx = -1;
        }
        else
            signdx = 1;
        if (isInt1 && isInt2) {
            slice->edge1.dx = dx * 2;
            slice->edge1.dy = dy * 2;
        }
        else {
            scale = (dx > dy) ? dx : dy;
            slice->edge1.dx = floor((dx * 32768) / scale + .5);
            slice->edge1.dy = floor((dy * 32768) / scale + .5);
        }
        if (!slice->edge1.dy) {
            if (signdx < 0) {
                y = floor(y1 + 1.0);
                if (y >= 0) {
                    slice->min_top_y = y;
                    slice->min_bot_y = arc->height;
                }
                else {
                    slice->max_bot_y = -y - (arc->height & 1);
                }
            }
            else {
                y = floor(y1);
                if (y >= 0)
                    slice->max_top_y = y;
                else {
                    slice->min_top_y = arc->height;
                    slice->min_bot_y = -y - (arc->height & 1);
                }
            }
            slice->edge1_top = TRUE;
            slice->edge1.x = 65536;
            slice->edge1.stepx = 0;
            slice->edge1.e = 0;
            slice->edge1.dx = -1;
            slice->edge2 = slice->edge1;
            slice->edge2_top = FALSE;
        }
        else if (!slice->edge1.dx) {
            if (signdy < 0)
                x1 -= 1.0;
            slice->edge1.x = ceil(x1);
            slice->edge1_top = signdy < 0;
            slice->edge1.x += arc->x + (arc->width >> 1);
            slice->edge1.stepx = 0;
            slice->edge1.e = 0;
            slice->edge1.dx = -1;
            slice->edge2_top = !slice->edge1_top;
            slice->edge2 = slice->edge1;
        }
        else {
            if (signdx < 0)
                slice->edge1.dx = -slice->edge1.dx;
            if (signdy < 0)
                slice->edge1.dx = -slice->edge1.dx;
            k = ceil(((x1 + x2) * slice->edge1.dy -
                      (y1 + y2) * slice->edge1.dx) / 2.0);
            slice->edge2.dx = slice->edge1.dx;
            slice->edge2.dy = slice->edge1.dy;
            slice->edge1_top = signdy < 0;
            slice->edge2_top = !slice->edge1_top;
            miGetArcEdge(arc, &slice->edge1, k,
                         slice->edge1_top, !slice->edge1_top);
            miGetArcEdge(arc, &slice->edge2, k,
                         slice->edge2_top, slice->edge2_top);
        }
    }
}

#define ADDSPANS() \
    pts->x = xorg - x; \
    pts->y = yorg - y; \
    *wids = slw; \
    pts++; \
    wids++; \
    if (miFillArcLower(slw)) \
    { \
	pts->x = xorg - x; \
	pts->y = yorg + y + dy; \
	pts++; \
	*wids++ = slw; \
    }

static int
miFillEllipseI(DrawablePtr pDraw, GCPtr pGC, xArc * arc, DDXPointPtr points, int *widths)
{
    int x, y, e;
    int yk, xk, ym, xm, dx, dy, xorg, yorg;
    int slw;
    miFillArcRec info;
    DDXPointPtr pts;
    int *wids;

    miFillArcSetup(arc, &info);
    MIFILLARCSETUP();
    if (pGC->miTranslate) {
        xorg += pDraw->x;
        yorg += pDraw->y;
    }
    pts = points;
    wids = widths;
    while (y > 0) {
        MIFILLARCSTEP(slw);
        ADDSPANS();
    }
    return pts - points;
}

static int
miFillEllipseD(DrawablePtr pDraw, GCPtr pGC, xArc * arc, DDXPointPtr points, int *widths)
{
    int x, y;
    int xorg, yorg, dx, dy, slw;
    double e, yk, xk, ym, xm;
    miFillArcDRec info;
    DDXPointPtr pts;
    int *wids;

    miFillArcDSetup(arc, &info);
    MIFILLARCSETUP();
    if (pGC->miTranslate) {
        xorg += pDraw->x;
        yorg += pDraw->y;
    }
    pts = points;
    wids = widths;
    while (y > 0) {
        MIFILLARCSTEP(slw);
        ADDSPANS();
    }
    return pts - points;
}

#define ADDSPAN(l,r) \
    if (r >= l) \
    { \
	pts->x = l; \
	pts->y = ya; \
	pts++; \
	*wids++ = r - l + 1; \
    }

#define ADDSLICESPANS(flip) \
    if (!flip) \
    { \
	ADDSPAN(xl, xr); \
    } \
    else \
    { \
	xc = xorg - x; \
	ADDSPAN(xc, xr); \
	xc += slw - 1; \
	ADDSPAN(xl, xc); \
    }

static int
miFillArcSliceI(DrawablePtr pDraw, GCPtr pGC, xArc * arc, DDXPointPtr points, int *widths)
{
    int yk, xk, ym, xm, dx, dy, xorg, yorg, slw;
    int x, y, e;
    miFillArcRec info;
    miArcSliceRec slice;
    int ya, xl, xr, xc;
    DDXPointPtr pts;
    int *wids;

    miFillArcSetup(arc, &info);
    miFillArcSliceSetup(arc, &slice, pGC);
    MIFILLARCSETUP();
    slw = arc->height;
    if (slice.flip_top || slice.flip_bot)
        slw += (arc->height >> 1) + 1;
    if (pGC->miTranslate) {
        xorg += pDraw->x;
        yorg += pDraw->y;
        slice.edge1.x += pDraw->x;
        slice.edge2.x += pDraw->x;
    }
    pts = points;
    wids = widths;
    while (y > 0) {
        MIFILLARCSTEP(slw);
        MIARCSLICESTEP(slice.edge1);
        MIARCSLICESTEP(slice.edge2);
        if (miFillSliceUpper(slice)) {
            ya = yorg - y;
            MIARCSLICEUPPER(xl, xr, slice, slw);
            ADDSLICESPANS(slice.flip_top);
        }
        if (miFillSliceLower(slice)) {
            ya = yorg + y + dy;
            MIARCSLICELOWER(xl, xr, slice, slw);
            ADDSLICESPANS(slice.flip_bot);
        }
    }
    return pts - points;
}

static int
miFillArcSliceD(DrawablePtr pDraw, GCPtr pGC, xArc * arc, DDXPointPtr points, int *widths)
{
    int x, y;
    int dx, dy, xorg, yorg, slw;
    double e, yk, xk, ym, xm;
    miFillArcDRec info;
    miArcSliceRec slice;
    int ya, xl, xr, xc;
    DDXPointPtr pts;
    int *wids;

    miFillArcDSetup(arc, &info);
    miFillArcSliceSetup(arc, &slice, pGC);
    MIFILLARCSETUP();
    slw = arc->height;
    if (slice.flip_top || slice.flip_bot)
        slw += (arc->height >> 1) + 1;
    if (pGC->miTranslate) {
        xorg += pDraw->x;
        yorg += pDraw->y;
        slice.edge1.x += pDraw->x;
        slice.edge2.x += pDraw->x;
    }
    pts = points;
    wids = widths;
    while (y > 0) {
        MIFILLARCSTEP(slw);
        MIARCSLICESTEP(slice.edge1);
        MIARCSLICESTEP(slice.edge2);
        if (miFillSliceUpper(slice)) {
            ya = yorg - y;
            MIARCSLICEUPPER(xl, xr, slice, slw);
            ADDSLICESPANS(slice.flip_top);
        }
        if (miFillSliceLower(slice)) {
            ya = yorg + y + dy;
            MIARCSLICELOWER(xl, xr, slice, slw);
            ADDSLICESPANS(slice.flip_bot);
        }
    }
    return pts - points;
}

/* MIPOLYFILLARC -- The public entry for the PolyFillArc request.
 * Since we don't have to worry about overlapping segments, we can just
 * fill each arc as it comes.
 */

/* Limit the number of spans in a single draw request to avoid integer
 * overflow in the computation of the span buffer size.
 */
#define MAX_SPANS_PER_LOOP      (4 * 1024 * 1024)

void
miPolyFillArc(DrawablePtr pDraw, GCPtr pGC, int narcs_all, xArc * parcs)
{
    while (narcs_all > 0) {
        int narcs;
        int i;
        xArc *arc;
        int nspans = 0;
        DDXPointPtr pts, points;
        int *wids, *widths;
        int n;

        for (narcs = 0, arc = parcs; narcs < narcs_all; narcs++, arc++) {
            if (narcs && nspans + arc->height > MAX_SPANS_PER_LOOP)
                break;
            nspans += arc->height;

            /* A pie-slice arc may add another pile of spans */
            if (pGC->arcMode == ArcPieSlice &&
                (-FULLCIRCLE < arc->angle2 && arc->angle2 < FULLCIRCLE))
                nspans += (arc->height + 1) >> 1;
        }

        pts = points = malloc (sizeof (DDXPointRec) * nspans +
                               sizeof(int) * nspans);
        if (points) {
            wids = widths = (int *) (points + nspans);

            for (i = 0, arc = parcs; i < narcs; arc++, i++) {
                if (miFillArcEmpty(arc))
                    continue;
                if ((arc->angle2 >= FULLCIRCLE) || (arc->angle2 <= -FULLCIRCLE))
                {
                    if (miCanFillArc(arc))
                        n = miFillEllipseI(pDraw, pGC, arc, pts, wids);
                    else
                        n = miFillEllipseD(pDraw, pGC, arc, pts, wids);
                }
                else
                {
                    if (miCanFillArc(arc))
                        n = miFillArcSliceI(pDraw, pGC, arc, pts, wids);
                    else
                        n = miFillArcSliceD(pDraw, pGC, arc, pts, wids);
                }
                pts += n;
                wids += n;
            }
            nspans = pts - points;
            if (nspans)
                (*pGC->ops->FillSpans) (pDraw, pGC, nspans, points,
                                        widths, FALSE);
            free (points);
        }
        parcs += narcs;
        narcs_all -= narcs;
    }
}
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a38 1
#include "mifpoly.h"
d53 1
a53 1
void
d279 1
a279 1
void
d478 2
a479 2
static void
miFillEllipseI(DrawablePtr pDraw, GCPtr pGC, xArc * arc)
a484 1
    DDXPointPtr points;
a485 1
    int *widths;
a487 8
    points = malloc(sizeof(DDXPointRec) * arc->height);
    if (!points)
        return;
    widths = malloc(sizeof(int) * arc->height);
    if (!widths) {
        free(points);
        return;
    }
d500 1
a500 3
    (*pGC->ops->FillSpans) (pDraw, pGC, pts - points, points, widths, FALSE);
    free(widths);
    free(points);
d503 2
a504 2
static void
miFillEllipseD(DrawablePtr pDraw, GCPtr pGC, xArc * arc)
a509 1
    DDXPointPtr points;
a510 1
    int *widths;
a512 8
    points = malloc(sizeof(DDXPointRec) * arc->height);
    if (!points)
        return;
    widths = malloc(sizeof(int) * arc->height);
    if (!widths) {
        free(points);
        return;
    }
d525 1
a525 3
    (*pGC->ops->FillSpans) (pDraw, pGC, pts - points, points, widths, FALSE);
    free(widths);
    free(points);
d550 2
a551 2
static void
miFillArcSliceI(DrawablePtr pDraw, GCPtr pGC, xArc * arc)
a557 1
    DDXPointPtr points;
a558 1
    int *widths;
a566 8
    points = malloc(sizeof(DDXPointRec) * slw);
    if (!points)
        return;
    widths = malloc(sizeof(int) * slw);
    if (!widths) {
        free(points);
        return;
    }
d590 1
a590 3
    (*pGC->ops->FillSpans) (pDraw, pGC, pts - points, points, widths, FALSE);
    free(widths);
    free(points);
d593 2
a594 2
static void
miFillArcSliceD(DrawablePtr pDraw, GCPtr pGC, xArc * arc)
a601 1
    DDXPointPtr points;
a602 1
    int *widths;
a610 8
    points = malloc(sizeof(DDXPointRec) * slw);
    if (!points)
        return;
    widths = malloc(sizeof(int) * slw);
    if (!widths) {
        free(points);
        return;
    }
d634 1
a634 3
    (*pGC->ops->FillSpans) (pDraw, pGC, pts - points, points, widths, FALSE);
    free(widths);
    free(points);
d641 6
d648 1
a648 1
miPolyFillArc(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc * parcs)
d650 50
a699 17
    int i;
    xArc *arc;

    for (i = narcs, arc = parcs; --i >= 0; arc++) {
        if (miFillArcEmpty(arc))
            continue;
        if ((arc->angle2 >= FULLCIRCLE) || (arc->angle2 <= -FULLCIRCLE)) {
            if (miCanFillArc(arc))
                miFillEllipseI(pDraw, pGC, arc);
            else
                miFillEllipseD(pDraw, pGC, arc);
        }
        else {
            if (miCanFillArc(arc))
                miFillArcSliceI(pDraw, pGC, arc);
            else
                miFillArcSliceD(pDraw, pGC, arc);
d701 2
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a28 1

d55 1
a55 1
miFillArcSetup(xArc *arc, miFillArcRec *info)
d63 35
a97 41
    if (arc->width == arc->height)
    {
	/* (2x - 2xorg)^2 = d^2 - (2y - 2yorg)^2 */
	/* even: xorg = yorg = 0   odd:  xorg = .5, yorg = -.5 */
	info->ym = 8;
	info->xm = 8;
	info->yk = info->y << 3;
	if (!info->dx)
	{
	    info->xk = 0;
	    info->e = -1;
	}
	else
	{
	    info->y++;
	    info->yk += 4;
	    info->xk = -4;
	    info->e = - (info->y << 3);
	}
    }
    else
    {
	/* h^2 * (2x - 2xorg)^2 = w^2 * h^2 - w^2 * (2y - 2yorg)^2 */
	/* even: xorg = yorg = 0   odd:  xorg = .5, yorg = -.5 */
	info->ym = (arc->width * arc->width) << 3;
	info->xm = (arc->height * arc->height) << 3;
	info->yk = info->y * info->ym;
	if (!info->dy)
	    info->yk -= info->ym >> 1;
	if (!info->dx)
	{
	    info->xk = 0;
	    info->e = - (info->xm >> 3);
	}
	else
	{
	    info->y++;
	    info->yk += info->ym;
	    info->xk = -(info->xm >> 1);
	    info->e = info->xk - info->yk;
	}
d102 1
a102 1
miFillArcDSetup(xArc *arc, miFillArcDRec *info)
d112 2
a113 2
    info->ym = ((double)arc->width) * (arc->width * 8);
    info->xm = ((double)arc->height) * (arc->height * 8);
d116 10
a125 12
	info->yk -= info->ym / 2.0;
    if (!info->dx)
    {
	info->xk = 0;
	info->e = - (info->xm / 8.0);
    }
    else
    {
	info->y++;
	info->yk += info->ym;
	info->xk = -info->xm / 2.0;
	info->e = info->xk - info->yk;
d130 1
a130 6
miGetArcEdge(
	     xArc *arc,
	     miSliceEdgePtr edge,
	     int k,
	     Bool top, 
	     Bool left )
d136 5
a140 6
	y++;
    if (!top)
    {
	y = -y;
	if (arc->height & 1)
	    y--;
d144 1
a144 1
	edge->x = - ((-xady) / edge->dy + 1);
d146 1
a146 1
	edge->x = (xady - 1) / edge->dy;
d149 1
a149 1
	edge->e = edge->dy - edge->e + 1;
d151 1
a151 1
	edge->x++;
d153 13
a165 16
    if (edge->dx > 0)
    {
	edge->deltax = 1;
	edge->stepx = edge->dx / edge->dy;
	edge->dx = edge->dx % edge->dy;
    }
    else
    {
	edge->deltax = -1;
	edge->stepx = - ((-edge->dx) / edge->dy);
	edge->dx = (-edge->dx) % edge->dy;
    }
    if (!top)
    {
	edge->deltax = -edge->deltax;
	edge->stepx = -edge->stepx;
d170 2
a171 2
miEllipseAngleToSlope (int angle, int width, int height, int *dxp, int *dyp,
		       double *d_dxp, double *d_dyp)
d173 3
a175 3
    int	    dx, dy;
    double  d_dx, d_dy, scale;
    Bool    negative_dx, negative_dy;
d179 7
a185 7
	*dxp = -1;
	*dyp = 0;
	if (d_dxp) {
	    *d_dxp = width / 2.0;
	    *d_dyp = 0;
	}
	break;
d187 7
a193 7
	*dxp = 0;
	*dyp = 1;
	if (d_dxp) {
	    *d_dxp = 0;
	    *d_dyp = - height / 2.0;
	}
	break;
d195 7
a201 7
	*dxp = 1;
	*dyp = 0;
	if (d_dxp) {
	    *d_dxp = - width / 2.0;
	    *d_dyp = 0;
	}
	break;
d203 7
a209 7
	*dxp = 0;
	*dyp = -1;
	if (d_dxp) {
	    *d_dxp = 0;
	    *d_dyp = height / 2.0;
	}
	break;
d211 28
a238 30
	d_dx = Dcos(angle) * width;
	d_dy = Dsin(angle) * height;
	if (d_dxp) {
	    *d_dxp = d_dx / 2.0;
	    *d_dyp = - d_dy / 2.0;
	}
	negative_dx = FALSE;
	if (d_dx < 0.0)
	{
	    d_dx = -d_dx;
	    negative_dx = TRUE;
	}
	negative_dy = FALSE;
	if (d_dy < 0.0)
	{
	    d_dy = -d_dy;
	    negative_dy = TRUE;
	}
	scale = d_dx;
	if (d_dy > d_dx)
	    scale = d_dy;
	dx = floor ((d_dx * 32768) / scale + 0.5);
	if (negative_dx)
	    dx = -dx;
	*dxp = dx;
	dy = floor ((d_dy * 32768) / scale + 0.5);
	if (negative_dy)
	    dy = -dy;
	*dyp = dy;
	break;
d243 1
a243 6
miGetPieEdge(
	     xArc *arc,
	     int angle,
	     miSliceEdgePtr edge,
	     Bool top, 
	     Bool left )
d246 1
a246 1
    int	dx, dy;
d248 1
a248 1
    miEllipseAngleToSlope (angle, arc->width, arc->height, &dx, &dy, 0, 0);
d250 17
a266 19
    if (dy == 0)
    {
	edge->x = left ? -65536 : 65536;
	edge->stepx = 0;
	edge->e = 0;
	edge->dx = -1;
	return;
    }
    if (dx == 0)
    {
	edge->x = arc->x + (arc->width >> 1);
	if (left && (arc->width & 1))
	    edge->x++;
	else if (!left && !(arc->width & 1))
	    edge->x--;
	edge->stepx = 0;
	edge->e = 0;
	edge->dx = -1;
	return;
d269 2
a270 2
	dx = -dx;
	dy = -dy;
d274 1
a274 1
	k += dy;
d281 1
a281 1
miFillArcSliceSetup(xArc *arc, miArcSliceRec *slice, GCPtr pGC)
d286 3
a288 4
    if (arc->angle2 < 0)
    {
	angle2 = angle1;
	angle1 += arc->angle2;
d291 1
a291 1
	angle2 = angle1 + arc->angle2;
d293 1
a293 1
	angle1 += FULLCIRCLE;
d295 1
a295 1
	angle1 -= FULLCIRCLE;
d297 1
a297 1
	angle2 += FULLCIRCLE;
d299 1
a299 1
	angle2 -= FULLCIRCLE;
d306 156
a461 183
    if (pGC->arcMode == ArcPieSlice)
    {
	slice->edge1_top = (angle1 < HALFCIRCLE);
	slice->edge2_top = (angle2 <= HALFCIRCLE);
	if ((angle2 == 0) || (angle1 == HALFCIRCLE))
	{
	    if (angle2 ? slice->edge2_top : slice->edge1_top)
		slice->min_top_y = slice->min_bot_y;
	    else
		slice->min_top_y = arc->height;
	    slice->min_bot_y = 0;
	}
	else if ((angle1 == 0) || (angle2 == HALFCIRCLE))
	{
	    slice->min_top_y = slice->min_bot_y;
	    if (angle1 ? slice->edge1_top : slice->edge2_top)
		slice->min_bot_y = arc->height;
	    else
		slice->min_bot_y = 0;
	}
	else if (slice->edge1_top == slice->edge2_top)
	{
	    if (angle2 < angle1)
	    {
		slice->flip_top = slice->edge1_top;
		slice->flip_bot = !slice->edge1_top;
	    }
	    else if (slice->edge1_top)
	    {
		slice->min_top_y = 1;
		slice->min_bot_y = arc->height;
	    }
	    else
	    {
		slice->min_bot_y = 0;
		slice->min_top_y = arc->height;
	    }
	}
	miGetPieEdge(arc, angle1, &slice->edge1,
		     slice->edge1_top, !slice->edge1_top);
	miGetPieEdge(arc, angle2, &slice->edge2,
		     slice->edge2_top, slice->edge2_top);
    }
    else
    {
	double w2, h2, x1, y1, x2, y2, dx, dy, scale;
	int signdx, signdy, y, k;
	Bool isInt1 = TRUE, isInt2 = TRUE;

	w2 = (double)arc->width / 2.0;
	h2 = (double)arc->height / 2.0;
	if ((angle1 == 0) || (angle1 == HALFCIRCLE))
	{
	    x1 = angle1 ? -w2 : w2;
	    y1 = 0.0;
	}
	else if ((angle1 == QUADRANT) || (angle1 == QUADRANT3))
	{
	    x1 = 0.0;
	    y1 = (angle1 == QUADRANT) ? h2 : -h2;
	}
	else
	{
	    isInt1 = FALSE;
	    x1 = Dcos(angle1) * w2;
	    y1 = Dsin(angle1) * h2;
	}
	if ((angle2 == 0) || (angle2 == HALFCIRCLE))
	{
	    x2 = angle2 ? -w2 : w2;
	    y2 = 0.0;
	}
	else if ((angle2 == QUADRANT) || (angle2 == QUADRANT3))
	{
	    x2 = 0.0;
	    y2 = (angle2 == QUADRANT) ? h2 : -h2;
	}
	else
	{
	    isInt2 = FALSE;
	    x2 = Dcos(angle2) * w2;
	    y2 = Dsin(angle2) * h2;
	}
	dx = x2 - x1;
	dy = y2 - y1;
	if (arc->height & 1)
	{
	    y1 -= 0.5;
	    y2 -= 0.5;
	}
	if (arc->width & 1)
	{
	    x1 += 0.5;
	    x2 += 0.5;
	}
	if (dy < 0.0)
	{
	    dy = -dy;
	    signdy = -1;
	}
	else
	    signdy = 1;
	if (dx < 0.0)
	{
	    dx = -dx;
	    signdx = -1;
	}
	else
	    signdx = 1;
	if (isInt1 && isInt2)
	{
	    slice->edge1.dx = dx * 2;
	    slice->edge1.dy = dy * 2;
	}
	else
	{
	    scale = (dx > dy) ? dx : dy;
	    slice->edge1.dx = floor((dx * 32768) / scale + .5);
	    slice->edge1.dy = floor((dy * 32768) / scale + .5);
	}
	if (!slice->edge1.dy)
	{
	    if (signdx < 0)
	    {
		y = floor(y1 + 1.0);
		if (y >= 0)
		{
		    slice->min_top_y = y;
		    slice->min_bot_y = arc->height;
		}
		else
		{
		    slice->max_bot_y = -y - (arc->height & 1);
		}
	    }
	    else
	    {
		y = floor(y1);
		if (y >= 0)
		    slice->max_top_y = y;
		else
		{
		    slice->min_top_y = arc->height;
		    slice->min_bot_y = -y - (arc->height & 1);
		}
	    }
	    slice->edge1_top = TRUE;
	    slice->edge1.x = 65536;
	    slice->edge1.stepx = 0;
	    slice->edge1.e = 0;
	    slice->edge1.dx = -1;
	    slice->edge2 = slice->edge1;
	    slice->edge2_top = FALSE;
	}
	else if (!slice->edge1.dx)
	{
	    if (signdy < 0)
		x1 -= 1.0;
	    slice->edge1.x = ceil(x1);
	    slice->edge1_top = signdy < 0;
	    slice->edge1.x += arc->x + (arc->width >> 1);
	    slice->edge1.stepx = 0;
	    slice->edge1.e = 0;
	    slice->edge1.dx = -1;
	    slice->edge2_top = !slice->edge1_top;
	    slice->edge2 = slice->edge1;
	}
	else
	{
	    if (signdx < 0)
		slice->edge1.dx = -slice->edge1.dx;
	    if (signdy < 0)
		slice->edge1.dx = -slice->edge1.dx;
	    k = ceil(((x1 + x2) * slice->edge1.dy - (y1 + y2) * slice->edge1.dx) / 2.0);
	    slice->edge2.dx = slice->edge1.dx;
	    slice->edge2.dy = slice->edge1.dy;
	    slice->edge1_top = signdy < 0;
	    slice->edge2_top = !slice->edge1_top;
	    miGetArcEdge(arc, &slice->edge1, k,
			 slice->edge1_top, !slice->edge1_top);
	    miGetArcEdge(arc, &slice->edge2, k,
			 slice->edge2_top, slice->edge2_top);
	}
d480 1
a480 4
miFillEllipseI(
	       DrawablePtr pDraw,
	       GCPtr pGC,
	       xArc *arc )
d493 1
a493 1
	return;
d495 3
a497 4
    if (!widths)
    {
	free(points);
	return;
d501 3
a503 4
    if (pGC->miTranslate)
    {
	xorg += pDraw->x;
	yorg += pDraw->y;
d507 3
a509 4
    while (y > 0)
    {
	MIFILLARCSTEP(slw);
	ADDSPANS();
d511 1
a511 1
    (*pGC->ops->FillSpans)(pDraw, pGC, pts - points, points, widths, FALSE);
d517 1
a517 4
miFillEllipseD(
	       DrawablePtr pDraw,
	       GCPtr pGC,
	       xArc *arc )
d530 1
a530 1
	return;
d532 3
a534 4
    if (!widths)
    {
	free(points);
	return;
d538 3
a540 4
    if (pGC->miTranslate)
    {
	xorg += pDraw->x;
	yorg += pDraw->y;
d544 3
a546 4
    while (y > 0)
    {
	MIFILLARCSTEP(slw);
	ADDSPANS();
d548 1
a548 1
    (*pGC->ops->FillSpans)(pDraw, pGC, pts - points, points, widths, FALSE);
d576 1
a576 4
miFillArcSliceI(
		DrawablePtr pDraw,
		GCPtr pGC,
		xArc *arc )
d593 1
a593 1
	slw += (arc->height >> 1) + 1;
d596 1
a596 1
	return;
d598 9
a606 11
    if (!widths)
    {
	free(points);
	return;
    }
    if (pGC->miTranslate)
    {
	xorg += pDraw->x;
	yorg += pDraw->y;
	slice.edge1.x += pDraw->x;
	slice.edge2.x += pDraw->x;
d610 14
a623 17
    while (y > 0)
    {
	MIFILLARCSTEP(slw);
	MIARCSLICESTEP(slice.edge1);
	MIARCSLICESTEP(slice.edge2);
	if (miFillSliceUpper(slice))
	{
	    ya = yorg - y;
	    MIARCSLICEUPPER(xl, xr, slice, slw);
	    ADDSLICESPANS(slice.flip_top);
	}
	if (miFillSliceLower(slice))
	{
	    ya = yorg + y + dy;
	    MIARCSLICELOWER(xl, xr, slice, slw);
	    ADDSLICESPANS(slice.flip_bot);
	}
d625 1
a625 1
    (*pGC->ops->FillSpans)(pDraw, pGC, pts - points, points, widths, FALSE);
d631 1
a631 4
miFillArcSliceD(
		DrawablePtr pDraw,
		GCPtr pGC,
		xArc *arc )
d649 1
a649 1
	slw += (arc->height >> 1) + 1;
d652 1
a652 1
	return;
d654 9
a662 11
    if (!widths)
    {
	free(points);
	return;
    }
    if (pGC->miTranslate)
    {
	xorg += pDraw->x;
	yorg += pDraw->y;
	slice.edge1.x += pDraw->x;
	slice.edge2.x += pDraw->x;
d666 14
a679 17
    while (y > 0)
    {
	MIFILLARCSTEP(slw);
	MIARCSLICESTEP(slice.edge1);
	MIARCSLICESTEP(slice.edge2);
	if (miFillSliceUpper(slice))
	{
	    ya = yorg - y;
	    MIARCSLICEUPPER(xl, xr, slice, slw);
	    ADDSLICESPANS(slice.flip_top);
	}
	if (miFillSliceLower(slice))
	{
	    ya = yorg + y + dy;
	    MIARCSLICELOWER(xl, xr, slice, slw);
	    ADDSLICESPANS(slice.flip_bot);
	}
d681 1
a681 1
    (*pGC->ops->FillSpans)(pDraw, pGC, pts - points, points, widths, FALSE);
d691 1
a691 1
miPolyFillArc(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc *parcs)
d696 15
a710 18
    for(i = narcs, arc = parcs; --i >= 0; arc++)
    {
	if (miFillArcEmpty(arc))
	    continue;
	if ((arc->angle2 >= FULLCIRCLE) || (arc->angle2 <= -FULLCIRCLE))
	{
	    if (miCanFillArc(arc))
		miFillEllipseI(pDraw, pGC, arc);
	    else
		miFillEllipseD(pDraw, pGC, arc);
	}
	else
	{
	    if (miCanFillArc(arc))
		miFillArcSliceI(pDraw, pGC, arc);
	    else
		miFillArcSliceD(pDraw, pGC, arc);
	}
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d549 1
a549 1
    points = xalloc(sizeof(DDXPointRec) * arc->height);
d552 1
a552 1
    widths = xalloc(sizeof(int) * arc->height);
d555 1
a555 1
	xfree(points);
d573 2
a574 2
    xfree(widths);
    xfree(points);
d592 1
a592 1
    points = xalloc(sizeof(DDXPointRec) * arc->height);
d595 1
a595 1
    widths = xalloc(sizeof(int) * arc->height);
d598 1
a598 1
	xfree(points);
d616 2
a617 2
    xfree(widths);
    xfree(points);
d664 1
a664 1
    points = xalloc(sizeof(DDXPointRec) * slw);
d667 1
a667 1
    widths = xalloc(sizeof(int) * slw);
d670 1
a670 1
	xfree(points);
d701 2
a702 2
    xfree(widths);
    xfree(points);
d728 1
a728 1
    points = xalloc(sizeof(DDXPointRec) * slw);
d731 1
a731 1
    widths = xalloc(sizeof(int) * slw);
d734 1
a734 1
	xfree(points);
d765 2
a766 2
    xfree(widths);
    xfree(points);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d55 1
a55 1
_X_EXPORT void
d307 1
a307 1
_X_EXPORT void
d549 1
a549 1
    points = (DDXPointPtr)xalloc(sizeof(DDXPointRec) * arc->height);
d552 1
a552 1
    widths = (int *)xalloc(sizeof(int) * arc->height);
d592 1
a592 1
    points = (DDXPointPtr)xalloc(sizeof(DDXPointRec) * arc->height);
d595 1
a595 1
    widths = (int *)xalloc(sizeof(int) * arc->height);
d664 1
a664 1
    points = (DDXPointPtr)xalloc(sizeof(DDXPointRec) * slw);
d667 1
a667 1
    widths = (int *)xalloc(sizeof(int) * slw);
d728 1
a728 1
    points = (DDXPointPtr)xalloc(sizeof(DDXPointRec) * slw);
d731 1
a731 1
    widths = (int *)xalloc(sizeof(int) * slw);
d773 1
a773 1
_X_EXPORT void
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d56 1
a56 3
miFillArcSetup(arc, info)
    xArc *arc;
    miFillArcRec *info;
d308 1
a308 4
miFillArcSliceSetup(arc, slice, pGC)
    xArc *arc;
    miArcSliceRec *slice;
    GCPtr pGC;
d774 1
a774 5
miPolyFillArc(pDraw, pGC, narcs, parcs)
    DrawablePtr	pDraw;
    GCPtr	pGC;
    int		narcs;
    xArc	*parcs;
d782 1
a782 1
	    continue;;
@


1.1
log
@Initial revision
@
text
@d57 2
a58 2
    register xArc *arc;
    register miFillArcRec *info;
d110 2
a111 4
void
miFillArcDSetup(arc, info)
    register xArc *arc;
    register miFillArcDRec *info;
d142 2
a143 2
	     register xArc *arc,
	     register miSliceEdgePtr edge,
d148 1
a148 1
    register int xady, y;
d189 3
a191 9
void
miEllipseAngleToSlope (angle, width, height, dxp, dyp, d_dxp, d_dyp)
    int	    angle;
    int	    width;
    int	    height;
    int	    *dxp;
    int	    *dyp;
    double  *d_dxp;
    double  *d_dyp;
d266 3
a268 3
	     register xArc *arc,
	     register int angle,
	     register miSliceEdgePtr edge,
d272 1
a272 1
    register int k;
d311 2
a312 2
    register xArc *arc;
    register miArcSliceRec *slice;
d315 1
a315 1
    register int angle1, angle2;
d545 1
a545 1
    register int x, y, e;
d550 1
a550 1
    register DDXPointPtr pts;
d552 1
a552 1
    register int *wids;
d554 1
a554 1
    points = (DDXPointPtr)ALLOCATE_LOCAL(sizeof(DDXPointRec) * arc->height);
d557 1
a557 1
    widths = (int *)ALLOCATE_LOCAL(sizeof(int) * arc->height);
d560 1
a560 1
	DEALLOCATE_LOCAL(points);
d578 2
a579 2
    DEALLOCATE_LOCAL(widths);
    DEALLOCATE_LOCAL(points);
d588 1
a588 1
    register int x, y;
d593 1
a593 1
    register DDXPointPtr pts;
d595 1
a595 1
    register int *wids;
d597 1
a597 1
    points = (DDXPointPtr)ALLOCATE_LOCAL(sizeof(DDXPointRec) * arc->height);
d600 1
a600 1
    widths = (int *)ALLOCATE_LOCAL(sizeof(int) * arc->height);
d603 1
a603 1
	DEALLOCATE_LOCAL(points);
d621 2
a622 2
    DEALLOCATE_LOCAL(widths);
    DEALLOCATE_LOCAL(points);
d654 1
a654 1
    register int x, y, e;
d659 1
a659 1
    register DDXPointPtr pts;
d661 1
a661 1
    register int *wids;
d669 1
a669 1
    points = (DDXPointPtr)ALLOCATE_LOCAL(sizeof(DDXPointRec) * slw);
d672 1
a672 1
    widths = (int *)ALLOCATE_LOCAL(sizeof(int) * slw);
d675 1
a675 1
	DEALLOCATE_LOCAL(points);
d706 2
a707 2
    DEALLOCATE_LOCAL(widths);
    DEALLOCATE_LOCAL(points);
d716 1
a716 1
    register int x, y;
d723 1
a723 1
    register DDXPointPtr pts;
d725 1
a725 1
    register int *wids;
d733 1
a733 1
    points = (DDXPointPtr)ALLOCATE_LOCAL(sizeof(DDXPointRec) * slw);
d736 1
a736 1
    widths = (int *)ALLOCATE_LOCAL(sizeof(int) * slw);
d739 1
a739 1
	DEALLOCATE_LOCAL(points);
d770 2
a771 2
    DEALLOCATE_LOCAL(widths);
    DEALLOCATE_LOCAL(points);
d785 2
a786 2
    register int i;
    register xArc *arc;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d57 2
a58 2
    xArc *arc;
    miFillArcRec *info;
d110 4
a113 2
static void
miFillArcDSetup(xArc *arc, miFillArcDRec *info)
d144 2
a145 2
	     xArc *arc,
	     miSliceEdgePtr edge,
d150 1
a150 1
    int xady, y;
d191 9
a199 3
static void
miEllipseAngleToSlope (int angle, int width, int height, int *dxp, int *dyp,
		       double *d_dxp, double *d_dyp)
d274 3
a276 3
	     xArc *arc,
	     int angle,
	     miSliceEdgePtr edge,
d280 1
a280 1
    int k;
d319 2
a320 2
    xArc *arc;
    miArcSliceRec *slice;
d323 1
a323 1
    int angle1, angle2;
d553 1
a553 1
    int x, y, e;
d558 1
a558 1
    DDXPointPtr pts;
d560 1
a560 1
    int *wids;
d596 1
a596 1
    int x, y;
d601 1
a601 1
    DDXPointPtr pts;
d603 1
a603 1
    int *wids;
d662 1
a662 1
    int x, y, e;
d667 1
a667 1
    DDXPointPtr pts;
d669 1
a669 1
    int *wids;
d724 1
a724 1
    int x, y;
d731 1
a731 1
    DDXPointPtr pts;
d733 1
a733 1
    int *wids;
d793 2
a794 2
    int i;
    xArc *arc;
@

