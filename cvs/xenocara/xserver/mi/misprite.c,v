head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.4
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.02.16.08.40;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.17;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.46;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * misprite.c
 *
 * machine independent software sprite routines
 */

/*

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.
*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include   <X11/X.h>
#include   <X11/Xproto.h>
#include   "misc.h"
#include   "pixmapstr.h"
#include   "input.h"
#include   "mi.h"
#include   "cursorstr.h"
#include   <X11/fonts/font.h>
#include   "scrnintstr.h"
#include   "colormapst.h"
#include   "windowstr.h"
#include   "gcstruct.h"
#include   "mipointer.h"
#include   "misprite.h"
#include   "dixfontstr.h"
#include   <X11/fonts/fontstruct.h>
#include   "inputstr.h"
#include   "damage.h"

typedef struct {
    CursorPtr pCursor;
    int x;                      /* cursor hotspot */
    int y;
    BoxRec saved;               /* saved area from the screen */
    Bool isUp;                  /* cursor in frame buffer */
    Bool shouldBeUp;            /* cursor should be displayed */
    WindowPtr pCacheWin;        /* window the cursor last seen in */
    Bool isInCacheWin;
    Bool checkPixels;           /* check colormap collision */
    ScreenPtr pScreen;
} miCursorInfoRec, *miCursorInfoPtr;

/*
 * per screen information
 */

typedef struct {
    /* screen procedures */
    CloseScreenProcPtr CloseScreen;
    GetImageProcPtr GetImage;
    GetSpansProcPtr GetSpans;
    SourceValidateProcPtr SourceValidate;

    /* window procedures */
    CopyWindowProcPtr CopyWindow;

    /* colormap procedures */
    InstallColormapProcPtr InstallColormap;
    StoreColorsProcPtr StoreColors;

    /* os layer procedures */
    ScreenBlockHandlerProcPtr BlockHandler;

    xColorItem colors[2];
    ColormapPtr pInstalledMap;
    ColormapPtr pColormap;
    VisualPtr pVisual;
    DamagePtr pDamage;          /* damage tracking structure */
    Bool damageRegistered;
    int numberOfCursors;
} miSpriteScreenRec, *miSpriteScreenPtr;

#define SOURCE_COLOR	0
#define MASK_COLOR	1

/*
 * Overlap BoxPtr and Box elements
 */
#define BOX_OVERLAP(pCbox,X1,Y1,X2,Y2) \
 	(((pCbox)->x1 <= (X2)) && ((X1) <= (pCbox)->x2) && \
	 ((pCbox)->y1 <= (Y2)) && ((Y1) <= (pCbox)->y2))

/*
 * Overlap BoxPtr, origins, and rectangle
 */
#define ORG_OVERLAP(pCbox,xorg,yorg,x,y,w,h) \
    BOX_OVERLAP((pCbox),(x)+(xorg),(y)+(yorg),(x)+(xorg)+(w),(y)+(yorg)+(h))

/*
 * Overlap BoxPtr, origins and RectPtr
 */
#define ORGRECT_OVERLAP(pCbox,xorg,yorg,pRect) \
    ORG_OVERLAP((pCbox),(xorg),(yorg),(pRect)->x,(pRect)->y, \
		(int)((pRect)->width), (int)((pRect)->height))
/*
 * Overlap BoxPtr and horizontal span
 */
#define SPN_OVERLAP(pCbox,y,x,w) BOX_OVERLAP((pCbox),(x),(y),(x)+(w),(y))

#define LINE_SORT(x1,y1,x2,y2) \
{ int _t; \
  if (x1 > x2) { _t = x1; x1 = x2; x2 = _t; } \
  if (y1 > y2) { _t = y1; y1 = y2; y2 = _t; } }

#define LINE_OVERLAP(pCbox,x1,y1,x2,y2,lw2) \
    BOX_OVERLAP((pCbox), (x1)-(lw2), (y1)-(lw2), (x2)+(lw2), (y2)+(lw2))

#define SPRITE_DEBUG_ENABLE 0
#if SPRITE_DEBUG_ENABLE
#define SPRITE_DEBUG(x)	ErrorF x
#else
#define SPRITE_DEBUG(x)
#endif

#define MISPRITE(dev) \
    (IsFloating(dev) ? \
       (miCursorInfoPtr)dixLookupPrivate(&dev->devPrivates, miSpriteDevPrivatesKey) : \
       (miCursorInfoPtr)dixLookupPrivate(&(GetMaster(dev, MASTER_POINTER))->devPrivates, miSpriteDevPrivatesKey))

static void
miSpriteDisableDamage(ScreenPtr pScreen, miSpriteScreenPtr pScreenPriv)
{
    if (pScreenPriv->damageRegistered) {
        DamageUnregister(pScreenPriv->pDamage);
        pScreenPriv->damageRegistered = 0;
    }
}

static void
miSpriteEnableDamage(ScreenPtr pScreen, miSpriteScreenPtr pScreenPriv)
{
    if (!pScreenPriv->damageRegistered) {
        pScreenPriv->damageRegistered = 1;
        DamageRegister(&(pScreen->GetScreenPixmap(pScreen)->drawable),
                       pScreenPriv->pDamage);
    }
}

static void
miSpriteIsUp(miCursorInfoPtr pDevCursor)
{
    pDevCursor->isUp = TRUE;
}

static void
miSpriteIsDown(miCursorInfoPtr pDevCursor)
{
    pDevCursor->isUp = FALSE;
}

/*
 * screen wrappers
 */

static DevPrivateKeyRec miSpriteScreenKeyRec;

#define miSpriteScreenKey (&miSpriteScreenKeyRec)
#define GetSpriteScreen(pScreen) \
	(dixLookupPrivate(&(pScreen)->devPrivates, miSpriteScreenKey))
static DevPrivateKeyRec miSpriteDevPrivatesKeyRec;

#define miSpriteDevPrivatesKey (&miSpriteDevPrivatesKeyRec)

static Bool miSpriteCloseScreen(ScreenPtr pScreen);
static void miSpriteGetImage(DrawablePtr pDrawable, int sx, int sy,
                             int w, int h, unsigned int format,
                             unsigned long planemask, char *pdstLine);
static void miSpriteGetSpans(DrawablePtr pDrawable, int wMax,
                             DDXPointPtr ppt, int *pwidth, int nspans,
                             char *pdstStart);
static void miSpriteSourceValidate(DrawablePtr pDrawable, int x, int y,
                                   int width, int height,
                                   unsigned int subWindowMode);
static void miSpriteCopyWindow(WindowPtr pWindow,
                               DDXPointRec ptOldOrg, RegionPtr prgnSrc);
static void miSpriteBlockHandler(ScreenPtr pScreen,
                                 void *pTimeout, void *pReadMask);
static void miSpriteInstallColormap(ColormapPtr pMap);
static void miSpriteStoreColors(ColormapPtr pMap, int ndef, xColorItem * pdef);

static void miSpriteComputeSaved(DeviceIntPtr pDev, ScreenPtr pScreen);

static Bool miSpriteDeviceCursorInitialize(DeviceIntPtr pDev,
                                           ScreenPtr pScreen);
static void miSpriteDeviceCursorCleanup(DeviceIntPtr pDev, ScreenPtr pScreen);

#define SCREEN_PROLOGUE(pPriv, pScreen, field) ((pScreen)->field = \
   (pPriv)->field)
#define SCREEN_EPILOGUE(pPriv, pScreen, field)\
    ((pPriv)->field = (pScreen)->field, (pScreen)->field = miSprite##field)

/*
 * pointer-sprite method table
 */

static Bool miSpriteRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
                                  CursorPtr pCursor);
static Bool miSpriteUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
                                    CursorPtr pCursor);
static void miSpriteSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
                              CursorPtr pCursor, int x, int y);
static void miSpriteMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
                               int x, int y);

miPointerSpriteFuncRec miSpritePointerFuncs = {
    miSpriteRealizeCursor,
    miSpriteUnrealizeCursor,
    miSpriteSetCursor,
    miSpriteMoveCursor,
    miSpriteDeviceCursorInitialize,
    miSpriteDeviceCursorCleanup,
};

/*
 * other misc functions
 */

static void miSpriteRemoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen);
static void miSpriteSaveUnderCursor(DeviceIntPtr pDev, ScreenPtr pScreen);
static void miSpriteRestoreCursor(DeviceIntPtr pDev, ScreenPtr pScreen);

static void
miSpriteRegisterBlockHandler(ScreenPtr pScreen, miSpriteScreenPtr pScreenPriv)
{
    if (!pScreenPriv->BlockHandler) {
        pScreenPriv->BlockHandler = pScreen->BlockHandler;
        pScreen->BlockHandler = miSpriteBlockHandler;
    }
}

static void
miSpriteReportDamage(DamagePtr pDamage, RegionPtr pRegion, void *closure)
{
    ScreenPtr pScreen = closure;
    miCursorInfoPtr pCursorInfo;
    DeviceIntPtr pDev;

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if (DevHasCursor(pDev)) {
            pCursorInfo = MISPRITE(pDev);

            if (pCursorInfo->isUp &&
                pCursorInfo->pScreen == pScreen &&
                RegionContainsRect(pRegion, &pCursorInfo->saved) != rgnOUT) {
                SPRITE_DEBUG(("Damage remove\n"));
                miSpriteRemoveCursor(pDev, pScreen);
            }
        }
    }
}

/*
 * miSpriteInitialize -- called from device-dependent screen
 * initialization proc after all of the function pointers have
 * been stored in the screen structure.
 */

Bool
miSpriteInitialize(ScreenPtr pScreen, miPointerScreenFuncPtr screenFuncs)
{
    miSpriteScreenPtr pScreenPriv;
    VisualPtr pVisual;

    if (!DamageSetup(pScreen))
        return FALSE;

    if (!dixRegisterPrivateKey(&miSpriteScreenKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    if (!dixRegisterPrivateKey
        (&miSpriteDevPrivatesKeyRec, PRIVATE_DEVICE, sizeof(miCursorInfoRec)))
        return FALSE;

    pScreenPriv = malloc(sizeof(miSpriteScreenRec));
    if (!pScreenPriv)
        return FALSE;

    pScreenPriv->pDamage = DamageCreate(miSpriteReportDamage,
                                        NULL,
                                        DamageReportRawRegion,
                                        TRUE, pScreen, pScreen);

    if (!miPointerInitialize(pScreen, &miSpritePointerFuncs, screenFuncs, TRUE)) {
        free(pScreenPriv);
        return FALSE;
    }
    for (pVisual = pScreen->visuals;
         pVisual->vid != pScreen->rootVisual; pVisual++);
    pScreenPriv->pVisual = pVisual;
    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreenPriv->GetImage = pScreen->GetImage;
    pScreenPriv->GetSpans = pScreen->GetSpans;
    pScreenPriv->SourceValidate = pScreen->SourceValidate;

    pScreenPriv->CopyWindow = pScreen->CopyWindow;

    pScreenPriv->InstallColormap = pScreen->InstallColormap;
    pScreenPriv->StoreColors = pScreen->StoreColors;

    pScreenPriv->BlockHandler = NULL;

    pScreenPriv->pInstalledMap = NULL;
    pScreenPriv->pColormap = NULL;
    pScreenPriv->colors[SOURCE_COLOR].red = 0;
    pScreenPriv->colors[SOURCE_COLOR].green = 0;
    pScreenPriv->colors[SOURCE_COLOR].blue = 0;
    pScreenPriv->colors[MASK_COLOR].red = 0;
    pScreenPriv->colors[MASK_COLOR].green = 0;
    pScreenPriv->colors[MASK_COLOR].blue = 0;
    pScreenPriv->damageRegistered = 0;
    pScreenPriv->numberOfCursors = 0;

    dixSetPrivate(&pScreen->devPrivates, miSpriteScreenKey, pScreenPriv);

    pScreen->CloseScreen = miSpriteCloseScreen;
    pScreen->GetImage = miSpriteGetImage;
    pScreen->GetSpans = miSpriteGetSpans;
    pScreen->SourceValidate = miSpriteSourceValidate;

    pScreen->CopyWindow = miSpriteCopyWindow;
    pScreen->InstallColormap = miSpriteInstallColormap;
    pScreen->StoreColors = miSpriteStoreColors;

    return TRUE;
}

/*
 * Screen wrappers
 */

/*
 * CloseScreen wrapper -- unwrap everything, free the private data
 * and call the wrapped function
 */

static Bool
miSpriteCloseScreen(ScreenPtr pScreen)
{
    miSpriteScreenPtr pScreenPriv = GetSpriteScreen(pScreen);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;
    pScreen->GetImage = pScreenPriv->GetImage;
    pScreen->GetSpans = pScreenPriv->GetSpans;
    pScreen->SourceValidate = pScreenPriv->SourceValidate;
    pScreen->InstallColormap = pScreenPriv->InstallColormap;
    pScreen->StoreColors = pScreenPriv->StoreColors;

    DamageDestroy(pScreenPriv->pDamage);

    free(pScreenPriv);

    return (*pScreen->CloseScreen) (pScreen);
}

static void
miSpriteGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
                 unsigned int format, unsigned long planemask, char *pdstLine)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    DeviceIntPtr pDev;
    miCursorInfoPtr pCursorInfo;
    miSpriteScreenPtr pPriv = GetSpriteScreen(pScreen);

    SCREEN_PROLOGUE(pPriv, pScreen, GetImage);

    if (pDrawable->type == DRAWABLE_WINDOW) {
        for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
            if (DevHasCursor(pDev)) {
                pCursorInfo = MISPRITE(pDev);
                if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen &&
                    ORG_OVERLAP(&pCursorInfo->saved, pDrawable->x, pDrawable->y,
                                sx, sy, w, h)) {
                    SPRITE_DEBUG(("GetImage remove\n"));
                    miSpriteRemoveCursor(pDev, pScreen);
                }
            }
        }
    }

    (*pScreen->GetImage) (pDrawable, sx, sy, w, h, format, planemask, pdstLine);

    SCREEN_EPILOGUE(pPriv, pScreen, GetImage);
}

static void
miSpriteGetSpans(DrawablePtr pDrawable, int wMax, DDXPointPtr ppt,
                 int *pwidth, int nspans, char *pdstStart)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    DeviceIntPtr pDev;
    miCursorInfoPtr pCursorInfo;
    miSpriteScreenPtr pPriv = GetSpriteScreen(pScreen);

    SCREEN_PROLOGUE(pPriv, pScreen, GetSpans);

    if (pDrawable->type == DRAWABLE_WINDOW) {
        for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
            if (DevHasCursor(pDev)) {
                pCursorInfo = MISPRITE(pDev);

                if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen) {
                    DDXPointPtr pts;
                    int *widths;
                    int nPts;
                    int xorg, yorg;

                    xorg = pDrawable->x;
                    yorg = pDrawable->y;

                    for (pts = ppt, widths = pwidth, nPts = nspans;
                         nPts--; pts++, widths++) {
                        if (SPN_OVERLAP(&pCursorInfo->saved, pts->y + yorg,
                                        pts->x + xorg, *widths)) {
                            SPRITE_DEBUG(("GetSpans remove\n"));
                            miSpriteRemoveCursor(pDev, pScreen);
                            break;
                        }
                    }
                }
            }
        }
    }

    (*pScreen->GetSpans) (pDrawable, wMax, ppt, pwidth, nspans, pdstStart);

    SCREEN_EPILOGUE(pPriv, pScreen, GetSpans);
}

static void
miSpriteSourceValidate(DrawablePtr pDrawable, int x, int y, int width,
                       int height, unsigned int subWindowMode)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    DeviceIntPtr pDev;
    miCursorInfoPtr pCursorInfo;
    miSpriteScreenPtr pPriv = GetSpriteScreen(pScreen);

    SCREEN_PROLOGUE(pPriv, pScreen, SourceValidate);

    if (pDrawable->type == DRAWABLE_WINDOW) {
        for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
            if (DevHasCursor(pDev)) {
                pCursorInfo = MISPRITE(pDev);
                if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen &&
                    ORG_OVERLAP(&pCursorInfo->saved, pDrawable->x, pDrawable->y,
                                x, y, width, height)) {
                    SPRITE_DEBUG(("SourceValidate remove\n"));
                    miSpriteRemoveCursor(pDev, pScreen);
                }
            }
        }
    }

    if (pScreen->SourceValidate)
        (*pScreen->SourceValidate) (pDrawable, x, y, width, height,
                                    subWindowMode);

    SCREEN_EPILOGUE(pPriv, pScreen, SourceValidate);
}

static void
miSpriteCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    DeviceIntPtr pDev;
    miCursorInfoPtr pCursorInfo;
    miSpriteScreenPtr pPriv = GetSpriteScreen(pScreen);

    SCREEN_PROLOGUE(pPriv, pScreen, CopyWindow);

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if (DevHasCursor(pDev)) {
            pCursorInfo = MISPRITE(pDev);
            /*
             * Damage will take care of destination check
             */
            if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen &&
                RegionContainsRect(prgnSrc, &pCursorInfo->saved) != rgnOUT) {
                SPRITE_DEBUG(("CopyWindow remove\n"));
                miSpriteRemoveCursor(pDev, pScreen);
            }
        }
    }

    (*pScreen->CopyWindow) (pWindow, ptOldOrg, prgnSrc);
    SCREEN_EPILOGUE(pPriv, pScreen, CopyWindow);
}

static void
miSpriteBlockHandler(ScreenPtr pScreen, void *pTimeout,
                     void *pReadmask)
{
    miSpriteScreenPtr pPriv = GetSpriteScreen(pScreen);
    DeviceIntPtr pDev;
    miCursorInfoPtr pCursorInfo;
    Bool WorkToDo = FALSE;

    SCREEN_PROLOGUE(pPriv, pScreen, BlockHandler);

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if (DevHasCursor(pDev)) {
            pCursorInfo = MISPRITE(pDev);
            if (pCursorInfo && !pCursorInfo->isUp
                && pCursorInfo->pScreen == pScreen && pCursorInfo->shouldBeUp) {
                SPRITE_DEBUG(("BlockHandler save"));
                miSpriteSaveUnderCursor(pDev, pScreen);
            }
        }
    }
    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
        if (DevHasCursor(pDev)) {
            pCursorInfo = MISPRITE(pDev);
            if (pCursorInfo && !pCursorInfo->isUp &&
                pCursorInfo->pScreen == pScreen && pCursorInfo->shouldBeUp) {
                SPRITE_DEBUG(("BlockHandler restore\n"));
                miSpriteRestoreCursor(pDev, pScreen);
                if (!pCursorInfo->isUp)
                    WorkToDo = TRUE;
            }
        }
    }

    (*pScreen->BlockHandler) (pScreen, pTimeout, pReadmask);

    if (WorkToDo)
        SCREEN_EPILOGUE(pPriv, pScreen, BlockHandler);
    else
        pPriv->BlockHandler = NULL;
}

static void
miSpriteInstallColormap(ColormapPtr pMap)
{
    ScreenPtr pScreen = pMap->pScreen;
    miSpriteScreenPtr pPriv = GetSpriteScreen(pScreen);

    SCREEN_PROLOGUE(pPriv, pScreen, InstallColormap);

    (*pScreen->InstallColormap) (pMap);

    SCREEN_EPILOGUE(pPriv, pScreen, InstallColormap);

    /* InstallColormap can be called before devices are initialized. */
    pPriv->pInstalledMap = pMap;
    if (pPriv->pColormap != pMap) {
        DeviceIntPtr pDev;
        miCursorInfoPtr pCursorInfo;

        for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
            if (DevHasCursor(pDev)) {
                pCursorInfo = MISPRITE(pDev);
                pCursorInfo->checkPixels = TRUE;
                if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen)
                    miSpriteRemoveCursor(pDev, pScreen);
            }
        }

    }
}

static void
miSpriteStoreColors(ColormapPtr pMap, int ndef, xColorItem * pdef)
{
    ScreenPtr pScreen = pMap->pScreen;
    miSpriteScreenPtr pPriv = GetSpriteScreen(pScreen);
    int i;
    int updated;
    VisualPtr pVisual;
    DeviceIntPtr pDev;
    miCursorInfoPtr pCursorInfo;

    SCREEN_PROLOGUE(pPriv, pScreen, StoreColors);

    (*pScreen->StoreColors) (pMap, ndef, pdef);

    SCREEN_EPILOGUE(pPriv, pScreen, StoreColors);

    if (pPriv->pColormap == pMap) {
        updated = 0;
        pVisual = pMap->pVisual;
        if (pVisual->class == DirectColor) {
            /* Direct color - match on any of the subfields */

#define MaskMatch(a,b,mask) (((a) & (pVisual->mask)) == ((b) & (pVisual->mask)))

#define UpdateDAC(dev, plane,dac,mask) {\
    if (MaskMatch (dev->colors[plane].pixel,pdef[i].pixel,mask)) {\
	dev->colors[plane].dac = pdef[i].dac; \
	updated = 1; \
    } \
}

#define CheckDirect(dev, plane) \
	    UpdateDAC(dev, plane,red,redMask) \
	    UpdateDAC(dev, plane,green,greenMask) \
	    UpdateDAC(dev, plane,blue,blueMask)

            for (i = 0; i < ndef; i++) {
                CheckDirect(pPriv, SOURCE_COLOR)
                    CheckDirect(pPriv, MASK_COLOR)
            }
        }
        else {
            /* PseudoColor/GrayScale - match on exact pixel */
            for (i = 0; i < ndef; i++) {
                if (pdef[i].pixel == pPriv->colors[SOURCE_COLOR].pixel) {
                    pPriv->colors[SOURCE_COLOR] = pdef[i];
                    if (++updated == 2)
                        break;
                }
                if (pdef[i].pixel == pPriv->colors[MASK_COLOR].pixel) {
                    pPriv->colors[MASK_COLOR] = pdef[i];
                    if (++updated == 2)
                        break;
                }
            }
        }
        if (updated) {
            for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
                if (DevHasCursor(pDev)) {
                    pCursorInfo = MISPRITE(pDev);
                    pCursorInfo->checkPixels = TRUE;
                    if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen)
                        miSpriteRemoveCursor(pDev, pScreen);
                }
            }
        }
    }
}

static void
miSpriteFindColors(miCursorInfoPtr pDevCursor, ScreenPtr pScreen)
{
    miSpriteScreenPtr pScreenPriv = GetSpriteScreen(pScreen);
    CursorPtr pCursor;
    xColorItem *sourceColor, *maskColor;

    pCursor = pDevCursor->pCursor;
    sourceColor = &pScreenPriv->colors[SOURCE_COLOR];
    maskColor = &pScreenPriv->colors[MASK_COLOR];
    if (pScreenPriv->pColormap != pScreenPriv->pInstalledMap ||
        !(pCursor->foreRed == sourceColor->red &&
          pCursor->foreGreen == sourceColor->green &&
          pCursor->foreBlue == sourceColor->blue &&
          pCursor->backRed == maskColor->red &&
          pCursor->backGreen == maskColor->green &&
          pCursor->backBlue == maskColor->blue)) {
        pScreenPriv->pColormap = pScreenPriv->pInstalledMap;
        sourceColor->red = pCursor->foreRed;
        sourceColor->green = pCursor->foreGreen;
        sourceColor->blue = pCursor->foreBlue;
        FakeAllocColor(pScreenPriv->pColormap, sourceColor);
        maskColor->red = pCursor->backRed;
        maskColor->green = pCursor->backGreen;
        maskColor->blue = pCursor->backBlue;
        FakeAllocColor(pScreenPriv->pColormap, maskColor);
        /* "free" the pixels right away, don't let this confuse you */
        FakeFreeColor(pScreenPriv->pColormap, sourceColor->pixel);
        FakeFreeColor(pScreenPriv->pColormap, maskColor->pixel);
    }

    pDevCursor->checkPixels = FALSE;

}

/*
 * miPointer interface routines
 */

#define SPRITE_PAD  8

static Bool
miSpriteRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    miCursorInfoPtr pCursorInfo;

    if (IsFloating(pDev))
        return FALSE;

    pCursorInfo = MISPRITE(pDev);

    if (pCursor == pCursorInfo->pCursor)
        pCursorInfo->checkPixels = TRUE;

    return miDCRealizeCursor(pScreen, pCursor);
}

static Bool
miSpriteUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
{
    return miDCUnrealizeCursor(pScreen, pCursor);
}

static void
miSpriteSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
                  CursorPtr pCursor, int x, int y)
{
    miCursorInfoPtr pPointer;
    miSpriteScreenPtr pScreenPriv;

    if (IsFloating(pDev))
        return;

    pPointer = MISPRITE(pDev);
    pScreenPriv = GetSpriteScreen(pScreen);

    if (!pCursor) {
        if (pPointer->shouldBeUp)
            --pScreenPriv->numberOfCursors;
        pPointer->shouldBeUp = FALSE;
        if (pPointer->isUp)
            miSpriteRemoveCursor(pDev, pScreen);
        if (pScreenPriv->numberOfCursors == 0)
            miSpriteDisableDamage(pScreen, pScreenPriv);
        pPointer->pCursor = 0;
        return;
    }
    if (!pPointer->shouldBeUp)
        pScreenPriv->numberOfCursors++;
    pPointer->shouldBeUp = TRUE;
    if (!pPointer->isUp)
        miSpriteRegisterBlockHandler(pScreen, pScreenPriv);
    if (pPointer->x == x &&
        pPointer->y == y &&
        pPointer->pCursor == pCursor && !pPointer->checkPixels) {
        return;
    }
    pPointer->x = x;
    pPointer->y = y;
    pPointer->pCacheWin = NullWindow;
    if (pPointer->checkPixels || pPointer->pCursor != pCursor) {
        pPointer->pCursor = pCursor;
        miSpriteFindColors(pPointer, pScreen);
    }
    if (pPointer->isUp) {
        /* TODO: reimplement flicker-free MoveCursor */
        SPRITE_DEBUG(("SetCursor remove %d\n", pDev->id));
        miSpriteRemoveCursor(pDev, pScreen);
    }

    if (!pPointer->isUp && pPointer->pCursor) {
        SPRITE_DEBUG(("SetCursor restore %d\n", pDev->id));
        miSpriteSaveUnderCursor(pDev, pScreen);
        miSpriteRestoreCursor(pDev, pScreen);
    }

}

static void
miSpriteMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
{
    CursorPtr pCursor;

    if (IsFloating(pDev))
        return;

    pCursor = MISPRITE(pDev)->pCursor;

    miSpriteSetCursor(pDev, pScreen, pCursor, x, y);
}

static Bool
miSpriteDeviceCursorInitialize(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    int ret = miDCDeviceInitialize(pDev, pScreen);

    if (ret) {
        miCursorInfoPtr pCursorInfo;

        pCursorInfo =
            dixLookupPrivate(&pDev->devPrivates, miSpriteDevPrivatesKey);
        pCursorInfo->pCursor = NULL;
        pCursorInfo->x = 0;
        pCursorInfo->y = 0;
        pCursorInfo->isUp = FALSE;
        pCursorInfo->shouldBeUp = FALSE;
        pCursorInfo->pCacheWin = NullWindow;
        pCursorInfo->isInCacheWin = FALSE;
        pCursorInfo->checkPixels = TRUE;
        pCursorInfo->pScreen = FALSE;
    }

    return ret;
}

static void
miSpriteDeviceCursorCleanup(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    miCursorInfoPtr pCursorInfo =
        dixLookupPrivate(&pDev->devPrivates, miSpriteDevPrivatesKey);

    if (DevHasCursor(pDev))
        miDCDeviceCleanup(pDev, pScreen);

    memset(pCursorInfo, 0, sizeof(miCursorInfoRec));
}

/*
 * undraw/draw cursor
 */

static void
miSpriteRemoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    miSpriteScreenPtr pScreenPriv;
    miCursorInfoPtr pCursorInfo;

    if (IsFloating(pDev))
        return;

    DamageDrawInternal(pScreen, TRUE);
    pScreenPriv = GetSpriteScreen(pScreen);
    pCursorInfo = MISPRITE(pDev);

    miSpriteIsDown(pCursorInfo);
    miSpriteRegisterBlockHandler(pScreen, pScreenPriv);
    pCursorInfo->pCacheWin = NullWindow;
    miSpriteDisableDamage(pScreen, pScreenPriv);
    if (!miDCRestoreUnderCursor(pDev,
                                pScreen,
                                pCursorInfo->saved.x1,
                                pCursorInfo->saved.y1,
                                pCursorInfo->saved.x2 -
                                pCursorInfo->saved.x1,
                                pCursorInfo->saved.y2 -
                                pCursorInfo->saved.y1)) {
        miSpriteIsUp(pCursorInfo);
    }
    miSpriteEnableDamage(pScreen, pScreenPriv);
    DamageDrawInternal(pScreen, FALSE);
}

/*
 * Called from the block handler, saves area under cursor
 * before waiting for something to do.
 */

static void
miSpriteSaveUnderCursor(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    miSpriteScreenPtr pScreenPriv;
    miCursorInfoPtr pCursorInfo;

    if (IsFloating(pDev))
        return;

    DamageDrawInternal(pScreen, TRUE);
    pScreenPriv = GetSpriteScreen(pScreen);
    pCursorInfo = MISPRITE(pDev);

    miSpriteComputeSaved(pDev, pScreen);

    miSpriteDisableDamage(pScreen, pScreenPriv);

    miDCSaveUnderCursor(pDev,
                        pScreen,
                        pCursorInfo->saved.x1,
                        pCursorInfo->saved.y1,
                        pCursorInfo->saved.x2 -
                        pCursorInfo->saved.x1,
                        pCursorInfo->saved.y2 - pCursorInfo->saved.y1);
    SPRITE_DEBUG(("SaveUnderCursor %d\n", pDev->id));
    miSpriteEnableDamage(pScreen, pScreenPriv);
    DamageDrawInternal(pScreen, FALSE);
}

/*
 * Called from the block handler, restores the cursor
 * before waiting for something to do.
 */

static void
miSpriteRestoreCursor(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    miSpriteScreenPtr pScreenPriv;
    int x, y;
    CursorPtr pCursor;
    miCursorInfoPtr pCursorInfo;

    if (IsFloating(pDev))
        return;

    DamageDrawInternal(pScreen, TRUE);
    pScreenPriv = GetSpriteScreen(pScreen);
    pCursorInfo = MISPRITE(pDev);

    miSpriteComputeSaved(pDev, pScreen);
    pCursor = pCursorInfo->pCursor;

    x = pCursorInfo->x - (int) pCursor->bits->xhot;
    y = pCursorInfo->y - (int) pCursor->bits->yhot;
    miSpriteDisableDamage(pScreen, pScreenPriv);
    SPRITE_DEBUG(("RestoreCursor %d\n", pDev->id));
    if (pCursorInfo->checkPixels)
        miSpriteFindColors(pCursorInfo, pScreen);
    if (miDCPutUpCursor(pDev, pScreen,
                        pCursor, x, y,
                        pScreenPriv->colors[SOURCE_COLOR].pixel,
                        pScreenPriv->colors[MASK_COLOR].pixel)) {
        miSpriteIsUp(pCursorInfo);
        pCursorInfo->pScreen = pScreen;
    }
    miSpriteEnableDamage(pScreen, pScreenPriv);
    DamageDrawInternal(pScreen, FALSE);
}

/*
 * compute the desired area of the screen to save
 */

static void
miSpriteComputeSaved(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    int x, y, w, h;
    int wpad, hpad;
    CursorPtr pCursor;
    miCursorInfoPtr pCursorInfo;

    if (IsFloating(pDev))
        return;

    pCursorInfo = MISPRITE(pDev);

    pCursor = pCursorInfo->pCursor;
    x = pCursorInfo->x - (int) pCursor->bits->xhot;
    y = pCursorInfo->y - (int) pCursor->bits->yhot;
    w = pCursor->bits->width;
    h = pCursor->bits->height;
    wpad = SPRITE_PAD;
    hpad = SPRITE_PAD;
    pCursorInfo->saved.x1 = x - wpad;
    pCursorInfo->saved.y1 = y - hpad;
    pCursorInfo->saved.x2 = pCursorInfo->saved.x1 + w + wpad * 2;
    pCursorInfo->saved.y2 = pCursorInfo->saved.y1 + h + hpad * 2;
}
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d523 2
a546 2

    SCREEN_PROLOGUE(pPriv, pScreen, BlockHandler);
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d202 1
a202 1
                                 pointer pTimeout, pointer pReadMask);
d515 2
a516 2
miSpriteBlockHandler(ScreenPtr pScreen, pointer pTimeout,
                     pointer pReadmask)
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@a88 4
    /* device cursor procedures */
    DeviceCursorInitializeProcPtr DeviceCursorInitialize;
    DeviceCursorCleanupProcPtr DeviceCursorCleanup;

d149 1
a149 2
        DamageUnregister(&(pScreen->GetScreenPixmap(pScreen)->drawable),
                         pScreenPriv->pDamage);
a325 3

    pScreenPriv->DeviceCursorInitialize = pScreen->DeviceCursorInitialize;
    pScreenPriv->DeviceCursorCleanup = pScreen->DeviceCursorCleanup;
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d194 1
a194 1
static Bool miSpriteCloseScreen(int i, ScreenPtr pScreen);
d206 1
a206 1
static void miSpriteBlockHandler(int i, pointer blockData,
d370 1
a370 1
miSpriteCloseScreen(int i, ScreenPtr pScreen)
d385 1
a385 1
    return (*pScreen->CloseScreen) (i, pScreen);
d523 1
a523 1
miSpriteBlockHandler(int i, pointer blockData, pointer pTimeout,
a525 1
    ScreenPtr pScreen = screenInfo.screens[i];
d556 1
a556 1
    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
@


1.7
log
@Update to xserver 1.11.2
@
text
@d56 10
a65 10
    CursorPtr	    pCursor;
    int		    x;			/* cursor hotspot */
    int		    y;
    BoxRec	    saved;		/* saved area from the screen */
    Bool	    isUp;		/* cursor in frame buffer */
    Bool	    shouldBeUp;		/* cursor should be displayed */
    WindowPtr	    pCacheWin;		/* window the cursor last seen in */
    Bool	    isInCacheWin;
    Bool	    checkPixels;	/* check colormap collision */
    ScreenPtr       pScreen;
d74 5
a78 5
    CloseScreenProcPtr			CloseScreen;
    GetImageProcPtr			GetImage;
    GetSpansProcPtr			GetSpans;
    SourceValidateProcPtr		SourceValidate;
    
d80 2
a81 2
    CopyWindowProcPtr			CopyWindow;
    
d83 3
a85 3
    InstallColormapProcPtr		InstallColormap;
    StoreColorsProcPtr			StoreColors;
    
d87 2
a88 2
    ScreenBlockHandlerProcPtr		BlockHandler;
    
d90 2
a91 2
    DeviceCursorInitializeProcPtr       DeviceCursorInitialize;
    DeviceCursorCleanupProcPtr          DeviceCursorCleanup;
d93 7
a99 7
    xColorItem	    colors[2];
    ColormapPtr     pInstalledMap;
    ColormapPtr     pColormap;
    VisualPtr	    pVisual;
    DamagePtr	    pDamage;		/* damage tracking structure */
    Bool            damageRegistered;
    int             numberOfCursors;
a136 1

d153 3
a155 3
	DamageUnregister (&(pScreen->GetScreenPixmap(pScreen)->drawable),
			  pScreenPriv->pDamage);
	pScreenPriv->damageRegistered = 0;
d163 3
a165 3
	pScreenPriv->damageRegistered = 1;
	DamageRegister (&(pScreen->GetScreenPixmap(pScreen)->drawable),
			pScreenPriv->pDamage);
d186 1
d191 1
d194 22
a215 27
static Bool	    miSpriteCloseScreen(int i, ScreenPtr pScreen);
static void	    miSpriteGetImage(DrawablePtr pDrawable, int sx, int sy,
				     int w, int h, unsigned int format,
				     unsigned long planemask, char *pdstLine);
static void	    miSpriteGetSpans(DrawablePtr pDrawable, int wMax,
				     DDXPointPtr ppt, int *pwidth, int nspans,
				     char *pdstStart);
static void	    miSpriteSourceValidate(DrawablePtr pDrawable, int x, int y,
					   int width, int height,
					   unsigned int subWindowMode);
static void	    miSpriteCopyWindow (WindowPtr pWindow,
					DDXPointRec ptOldOrg,
					RegionPtr prgnSrc);
static void	    miSpriteBlockHandler(int i, pointer blockData,
					 pointer pTimeout,
					 pointer pReadMask);
static void	    miSpriteInstallColormap(ColormapPtr pMap);
static void	    miSpriteStoreColors(ColormapPtr pMap, int ndef,
					xColorItem *pdef);

static void	    miSpriteComputeSaved(DeviceIntPtr pDev,
                                         ScreenPtr pScreen);

static Bool         miSpriteDeviceCursorInitialize(DeviceIntPtr pDev,
                                                   ScreenPtr pScreen);
static void         miSpriteDeviceCursorCleanup(DeviceIntPtr pDev,
                                                ScreenPtr pScreen);
d248 3
a250 6
static void miSpriteRemoveCursor(DeviceIntPtr pDev,
                                 ScreenPtr pScreen);
static void miSpriteSaveUnderCursor(DeviceIntPtr pDev,
                                 ScreenPtr pScreen);
static void miSpriteRestoreCursor(DeviceIntPtr pDev,
                                 ScreenPtr pScreen);
d262 1
a262 1
miSpriteReportDamage (DamagePtr pDamage, RegionPtr pRegion, void *closure)
d264 6
a269 8
    ScreenPtr		    pScreen = closure;
    miCursorInfoPtr         pCursorInfo;
    DeviceIntPtr            pDev;

    for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
    {
        if (DevHasCursor(pDev))
        {
d274 1
a274 2
                RegionContainsRect(pRegion, &pCursorInfo->saved) != rgnOUT)
            {
d276 1
a276 1
                miSpriteRemoveCursor (pDev, pScreen);
d289 1
a289 2
miSpriteInitialize (ScreenPtr               pScreen,
                    miPointerScreenFuncPtr  screenFuncs)
d291 2
a292 2
    miSpriteScreenPtr	pScreenPriv;
    VisualPtr		pVisual;
d294 2
a295 2
    if (!DamageSetup (pScreen))
	return FALSE;
d298 1
a298 1
	return FALSE;
d300 3
a302 2
    if (!dixRegisterPrivateKey(&miSpriteDevPrivatesKeyRec, PRIVATE_DEVICE, sizeof(miCursorInfoRec)))
	return FALSE;
d304 1
a304 1
    pScreenPriv = malloc(sizeof (miSpriteScreenRec));
d306 6
a311 1
	return FALSE;
d313 3
a315 11
    pScreenPriv->pDamage = DamageCreate (miSpriteReportDamage,
					 NULL,
					 DamageReportRawRegion,
					 TRUE,
					 pScreen,
					 pScreen);

    if (!miPointerInitialize (pScreen, &miSpritePointerFuncs, screenFuncs,TRUE))
    {
	free(pScreenPriv);
	return FALSE;
d318 1
a318 3
	 pVisual->vid != pScreen->rootVisual;
	 pVisual++)
	;
d370 1
a370 1
miSpriteCloseScreen (int i, ScreenPtr pScreen)
d372 1
a372 1
    miSpriteScreenPtr   pScreenPriv = GetSpriteScreen(pScreen);
d381 1
a381 1
    DamageDestroy (pScreenPriv->pDamage);
d389 2
a390 3
miSpriteGetImage (DrawablePtr pDrawable, int sx, int sy, int w, int h,
                  unsigned int format, unsigned long planemask,
                  char *pdstLine)
d392 4
a395 4
    ScreenPtr           pScreen = pDrawable->pScreen;
    DeviceIntPtr        pDev;
    miCursorInfoPtr     pCursorInfo;
    miSpriteScreenPtr   pPriv = GetSpriteScreen(pScreen);
d397 1
a397 1
    SCREEN_PROLOGUE (pPriv, pScreen, GetImage);
d399 10
a408 14
    if (pDrawable->type == DRAWABLE_WINDOW)
    {
        for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
        {
            if (DevHasCursor(pDev))
            {
                 pCursorInfo = MISPRITE(pDev);
                 if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen &&
                      ORG_OVERLAP(&pCursorInfo->saved,pDrawable->x,pDrawable->y,
                                  sx, sy, w, h))
                 {
                     SPRITE_DEBUG (("GetImage remove\n"));
                     miSpriteRemoveCursor (pDev, pScreen);
                 }
d413 1
a413 2
    (*pScreen->GetImage) (pDrawable, sx, sy, w, h,
			  format, planemask, pdstLine);
d415 1
a415 1
    SCREEN_EPILOGUE (pPriv, pScreen, GetImage);
d419 2
a420 2
miSpriteGetSpans (DrawablePtr pDrawable, int wMax, DDXPointPtr ppt,
                  int *pwidth, int nspans, char *pdstStart)
d422 4
a425 4
    ScreenPtr		    pScreen = pDrawable->pScreen;
    DeviceIntPtr            pDev;
    miCursorInfoPtr         pCursorInfo;
    miSpriteScreenPtr       pPriv = GetSpriteScreen(pScreen);
d427 1
a427 1
    SCREEN_PROLOGUE (pPriv, pScreen, GetSpans);
d429 3
a431 6
    if (pDrawable->type == DRAWABLE_WINDOW)
    {
        for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
        {
            if (DevHasCursor(pDev))
            {
d434 5
a438 7
                if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen)
                {
                    DDXPointPtr    pts;
                    int    	       *widths;
                    int    	       nPts;
                    int    	       xorg,
                                   yorg;
d444 5
a448 8
                            nPts--;
                            pts++, widths++)
                    {
                        if (SPN_OVERLAP(&pCursorInfo->saved,pts->y+yorg,
                                    pts->x+xorg,*widths))
                        {
                            SPRITE_DEBUG (("GetSpans remove\n"));
                            miSpriteRemoveCursor (pDev, pScreen);
d459 1
a459 1
    SCREEN_EPILOGUE (pPriv, pScreen, GetSpans);
d463 2
a464 2
miSpriteSourceValidate (DrawablePtr pDrawable, int x, int y, int width,
                        int height, unsigned int subWindowMode)
d466 19
a484 23
    ScreenPtr		    pScreen = pDrawable->pScreen;
    DeviceIntPtr            pDev;
    miCursorInfoPtr         pCursorInfo;
    miSpriteScreenPtr       pPriv = GetSpriteScreen(pScreen);

    SCREEN_PROLOGUE (pPriv, pScreen, SourceValidate);

    if (pDrawable->type == DRAWABLE_WINDOW)
    {
	for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
	{
	    if (DevHasCursor(pDev))
	    {
		pCursorInfo = MISPRITE(pDev);
		if (pCursorInfo->isUp && pCursorInfo->pScreen == pScreen &&
		    ORG_OVERLAP(&pCursorInfo->saved, pDrawable->x, pDrawable->y,
				x, y, width, height))
		{
		    SPRITE_DEBUG (("SourceValidate remove\n"));
		    miSpriteRemoveCursor (pDev, pScreen);
		}
	    }
	}
d488 2
a489 1
	(*pScreen->SourceValidate) (pDrawable, x, y, width, height, subWindowMode);
d491 1
a491 1
    SCREEN_EPILOGUE (pPriv, pScreen, SourceValidate);
d495 1
a495 1
miSpriteCopyWindow (WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
d497 4
a500 4
    ScreenPtr	pScreen = pWindow->drawable.pScreen;
    DeviceIntPtr            pDev;
    miCursorInfoPtr         pCursorInfo;
    miSpriteScreenPtr       pPriv = GetSpriteScreen(pScreen);
d502 1
a502 1
    SCREEN_PROLOGUE (pPriv, pScreen, CopyWindow);
d504 2
a505 4
    for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
    {
        if (DevHasCursor(pDev))
        {
d511 3
a513 4
                    RegionContainsRect(prgnSrc, &pCursorInfo->saved) != rgnOUT)
            {
                SPRITE_DEBUG (("CopyWindow remove\n"));
                miSpriteRemoveCursor (pDev, pScreen);
d519 1
a519 1
    SCREEN_EPILOGUE (pPriv, pScreen, CopyWindow);
d523 2
a524 2
miSpriteBlockHandler (int i, pointer blockData, pointer pTimeout,
                      pointer pReadmask)
d526 5
a530 5
    ScreenPtr		pScreen = screenInfo.screens[i];
    miSpriteScreenPtr	pPriv = GetSpriteScreen(pScreen);
    DeviceIntPtr            pDev;
    miCursorInfoPtr         pCursorInfo;
    Bool                WorkToDo = FALSE;
d532 2
a533 4
    for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
    {
        if (DevHasCursor(pDev))
        {
d536 3
a538 5
                    && pCursorInfo->pScreen == pScreen
                    && pCursorInfo->shouldBeUp)
            {
                SPRITE_DEBUG (("BlockHandler save"));
                miSpriteSaveUnderCursor (pDev, pScreen);
d542 2
a543 4
    for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
    {
        if (DevHasCursor(pDev))
        {
d546 3
a548 5
                    pCursorInfo->pScreen == pScreen &&
                    pCursorInfo->shouldBeUp)
            {
                SPRITE_DEBUG (("BlockHandler restore\n"));
                miSpriteRestoreCursor (pDev, pScreen);
d566 1
a566 1
miSpriteInstallColormap (ColormapPtr pMap)
d568 2
a569 2
    ScreenPtr		pScreen = pMap->pScreen;
    miSpriteScreenPtr	pPriv = GetSpriteScreen(pScreen);
d579 1
a579 2
    if (pPriv->pColormap != pMap)
    {
d581 4
a584 5
        miCursorInfoPtr     pCursorInfo;
        for (pDev = inputInfo.devices; pDev; pDev = pDev->next)
        {
            if (DevHasCursor(pDev))
            {
d596 1
a596 1
miSpriteStoreColors (ColormapPtr pMap, int ndef, xColorItem *pdef)
d598 7
a604 7
    ScreenPtr		pScreen = pMap->pScreen;
    miSpriteScreenPtr	pPriv = GetSpriteScreen(pScreen);
    int			i;
    int			updated;
    VisualPtr		pVisual;
    DeviceIntPtr        pDev;
    miCursorInfoPtr     pCursorInfo;
d612 1
a612 2
    if (pPriv->pColormap == pMap)
    {
d615 1
a615 2
        if (pVisual->class == DirectColor)
        {
d632 3
a634 4
            for (i = 0; i < ndef; i++)
            {
                CheckDirect (pPriv, SOURCE_COLOR)
                CheckDirect (pPriv, MASK_COLOR)
d637 1
a637 2
        else
        {
d639 2
a640 5
            for (i = 0; i < ndef; i++)
            {
                if (pdef[i].pixel ==
                        pPriv->colors[SOURCE_COLOR].pixel)
                {
d645 1
a645 3
                if (pdef[i].pixel ==
                        pPriv->colors[MASK_COLOR].pixel)
                {
d652 3
a654 6
        if (updated)
        {
            for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
            {
                if (DevHasCursor(pDev))
                {
d658 1
a658 1
                        miSpriteRemoveCursor (pDev, pScreen);
d666 1
a666 1
miSpriteFindColors (miCursorInfoPtr pDevCursor, ScreenPtr pScreen)
d668 3
a670 3
    miSpriteScreenPtr	pScreenPriv = GetSpriteScreen(pScreen);
    CursorPtr		pCursor;
    xColorItem		*sourceColor, *maskColor;
d676 2
a677 2
	!(pCursor->foreRed == sourceColor->red &&
	  pCursor->foreGreen == sourceColor->green &&
d679 15
a693 16
	  pCursor->backRed == maskColor->red &&
	  pCursor->backGreen == maskColor->green &&
	  pCursor->backBlue == maskColor->blue))
    {
	pScreenPriv->pColormap = pScreenPriv->pInstalledMap;
	sourceColor->red = pCursor->foreRed;
	sourceColor->green = pCursor->foreGreen;
	sourceColor->blue = pCursor->foreBlue;
	FakeAllocColor (pScreenPriv->pColormap, sourceColor);
	maskColor->red = pCursor->backRed;
	maskColor->green = pCursor->backGreen;
	maskColor->blue = pCursor->backBlue;
	FakeAllocColor (pScreenPriv->pColormap, maskColor);
	/* "free" the pixels right away, don't let this confuse you */
	FakeFreeColor(pScreenPriv->pColormap, sourceColor->pixel);
	FakeFreeColor(pScreenPriv->pColormap, maskColor->pixel);
d707 1
a707 1
miSpriteRealizeCursor (DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor)
d717 1
a717 1
	pCursorInfo->checkPixels = TRUE;
d729 2
a730 2
miSpriteSetCursor (DeviceIntPtr pDev, ScreenPtr pScreen,
                   CursorPtr pCursor, int x, int y)
d732 2
a733 2
    miCursorInfoPtr     pPointer;
    miSpriteScreenPtr   pScreenPriv;
d741 10
a750 11
    if (!pCursor)
    {
	if (pPointer->shouldBeUp)
	    --pScreenPriv->numberOfCursors;
    	pPointer->shouldBeUp = FALSE;
    	if (pPointer->isUp)
	    miSpriteRemoveCursor (pDev, pScreen);
	if (pScreenPriv->numberOfCursors == 0)
	    miSpriteDisableDamage(pScreen, pScreenPriv);
	pPointer->pCursor = 0;
	return;
d753 1
a753 1
	pScreenPriv->numberOfCursors++;
d756 1
a756 1
	miSpriteRegisterBlockHandler(pScreen, pScreenPriv);
d758 3
a760 5
	pPointer->y == y &&
	pPointer->pCursor == pCursor &&
	!pPointer->checkPixels)
    {
	return;
d765 3
a767 4
    if (pPointer->checkPixels || pPointer->pCursor != pCursor)
    {
	pPointer->pCursor = pCursor;
	miSpriteFindColors (pPointer, pScreen);
d770 3
a772 3
	/* TODO: reimplement flicker-free MoveCursor */
	SPRITE_DEBUG (("SetCursor remove %d\n", pDev->id));
	miSpriteRemoveCursor (pDev, pScreen);
d775 2
a776 3
    if (!pPointer->isUp && pPointer->pCursor)
    {
	SPRITE_DEBUG (("SetCursor restore %d\n", pDev->id));
d778 1
a778 1
	miSpriteRestoreCursor (pDev, pScreen);
d784 1
a784 1
miSpriteMoveCursor (DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
d793 1
a793 1
    miSpriteSetCursor (pDev, pScreen, pCursor, x, y);
a795 1

d801 1
a801 2
    if (ret)
    {
d803 3
a805 1
        pCursorInfo = dixLookupPrivate(&pDev->devPrivates, miSpriteDevPrivatesKey);
d823 2
a824 1
    miCursorInfoPtr pCursorInfo = dixLookupPrivate(&pDev->devPrivates, miSpriteDevPrivatesKey);
d837 1
a837 1
miSpriteRemoveCursor (DeviceIntPtr pDev, ScreenPtr pScreen)
d839 2
a840 3
    miSpriteScreenPtr   pScreenPriv;
    miCursorInfoPtr     pCursorInfo;

d845 1
a845 1
    DamageDrawInternal (pScreen, TRUE);
d860 1
a860 2
                                pCursorInfo->saved.y1))
    {
d864 1
a864 1
    DamageDrawInternal (pScreen, FALSE);
d875 2
a876 4
    miSpriteScreenPtr   pScreenPriv;
    int			x, y;
    CursorPtr		pCursor;
    miCursorInfoPtr     pCursorInfo;
d881 1
a881 1
    DamageDrawInternal (pScreen, TRUE);
d885 1
a885 2
    miSpriteComputeSaved (pDev, pScreen);
    pCursor = pCursorInfo->pCursor;
a886 2
    x = pCursorInfo->x - (int)pCursor->bits->xhot;
    y = pCursorInfo->y - (int)pCursor->bits->yhot;
d895 1
a895 2
                        pCursorInfo->saved.y2 -
                        pCursorInfo->saved.y1);
d898 1
a898 1
    DamageDrawInternal (pScreen, FALSE);
a900 1

d907 1
a907 1
miSpriteRestoreCursor (DeviceIntPtr pDev, ScreenPtr pScreen)
d909 4
a912 4
    miSpriteScreenPtr   pScreenPriv;
    int			x, y;
    CursorPtr		pCursor;
    miCursorInfoPtr     pCursorInfo;
d917 1
a917 1
    DamageDrawInternal (pScreen, TRUE);
d921 1
a921 1
    miSpriteComputeSaved (pDev, pScreen);
d924 2
a925 2
    x = pCursorInfo->x - (int)pCursor->bits->xhot;
    y = pCursorInfo->y - (int)pCursor->bits->yhot;
d929 1
a929 1
        miSpriteFindColors (pCursorInfo, pScreen);
d931 3
a933 4
                pCursor, x, y,
                pScreenPriv->colors[SOURCE_COLOR].pixel,
                pScreenPriv->colors[MASK_COLOR].pixel))
    {
d938 1
a938 1
    DamageDrawInternal (pScreen, FALSE);
d946 1
a946 1
miSpriteComputeSaved (DeviceIntPtr pDev, ScreenPtr pScreen)
d948 3
a950 3
    int		    x, y, w, h;
    int		    wpad, hpad;
    CursorPtr	    pCursor;
d959 2
a960 2
    x = pCursorInfo->x - (int)pCursor->bits->xhot;
    y = pCursorInfo->y - (int)pCursor->bits->yhot;
a969 1

@


1.6
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d99 1
d146 1
a146 1
    ((!IsMaster(dev) && !dev->u.master) ? \
d188 2
d201 2
a202 1
					   int width, int height);
d221 4
a224 5
#define SCREEN_PROLOGUE(pScreen, field) ((pScreen)->field = \
   ((miSpriteScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, \
					miSpriteScreenKey))->field)
#define SCREEN_EPILOGUE(pScreen, field)\
    ((pScreen)->field = miSprite##field)
d260 9
d311 1
a311 1
    if (!dixRegisterPrivateKey(&miSpriteDevPrivatesKeyRec, PRIVATE_DEVICE, 0))
d345 1
a345 1
    pScreenPriv->BlockHandler = pScreen->BlockHandler;
d359 1
a371 2
    pScreen->BlockHandler = miSpriteBlockHandler;

d387 1
a387 1
    miSpriteScreenPtr   pScreenPriv;
a388 1
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
a392 1
    pScreen->BlockHandler = pScreenPriv->BlockHandler;
d408 4
a411 3
    ScreenPtr	    pScreen = pDrawable->pScreen;
    DeviceIntPtr    pDev;
    miCursorInfoPtr pCursorInfo;
d413 1
a413 1
    SCREEN_PROLOGUE (pScreen, GetImage);
d436 1
a436 1
    SCREEN_EPILOGUE (pScreen, GetImage);
d446 1
d448 1
a448 1
    SCREEN_PROLOGUE (pScreen, GetSpans);
d488 1
a488 1
    SCREEN_EPILOGUE (pScreen, GetSpans);
d493 1
a493 1
                        int height)
d498 1
d500 1
a500 1
    SCREEN_PROLOGUE (pScreen, SourceValidate);
d521 1
a521 1
	(*pScreen->SourceValidate) (pDrawable, x, y, width, height);
d523 1
a523 1
    SCREEN_EPILOGUE (pScreen, SourceValidate);
d532 1
d534 1
a534 1
    SCREEN_PROLOGUE (pScreen, CopyWindow);
d554 1
a554 1
    SCREEN_EPILOGUE (pScreen, CopyWindow);
d562 1
a562 1
    miSpriteScreenPtr	pPriv;
d565 1
a565 7

    pPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
    SCREEN_PROLOGUE(pScreen, BlockHandler);

    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);

    SCREEN_EPILOGUE(pScreen, BlockHandler);
d592 2
d597 9
d612 1
a612 1
    miSpriteScreenPtr	pPriv;
d614 1
a614 2
    pPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
    SCREEN_PROLOGUE(pScreen, InstallColormap);
d618 1
a618 1
    SCREEN_EPILOGUE(pScreen, InstallColormap);
d644 1
a644 1
    miSpriteScreenPtr	pPriv;
d651 1
a651 2
    pPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
    SCREEN_PROLOGUE(pScreen, StoreColors);
d655 1
a655 1
    SCREEN_EPILOGUE(pScreen, StoreColors);
d725 1
a725 2
    miSpriteScreenPtr   pScreenPriv =
	dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
d769 1
a769 1
    if (!IsMaster(pDev) && !pDev->u.master)
d790 2
a791 1
    miCursorInfoPtr pPointer;
d793 1
a793 1
    if (!IsMaster(pDev) && !pDev->u.master)
d797 1
d801 2
d806 2
d811 2
d814 2
d851 1
a851 1
    if (!IsMaster(pDev) && !pDev->u.master)
d863 1
a863 2
    miCursorInfoPtr pCursorInfo;
    int ret = FALSE;
d865 1
a865 16
    pCursorInfo = malloc(sizeof(miCursorInfoRec));
    if (!pCursorInfo)
        return FALSE;

    pCursorInfo->pCursor = NULL;
    pCursorInfo->x = 0;
    pCursorInfo->y = 0;
    pCursorInfo->isUp = FALSE;
    pCursorInfo->shouldBeUp = FALSE;
    pCursorInfo->pCacheWin = NullWindow;
    pCursorInfo->isInCacheWin = FALSE;
    pCursorInfo->checkPixels = TRUE;
    pCursorInfo->pScreen = FALSE;

    ret = miDCDeviceInitialize(pDev, pScreen);
    if (!ret)
d867 11
a877 2
        free(pCursorInfo);
        pCursorInfo = NULL;
d879 1
a879 1
    dixSetPrivate(&pDev->devPrivates, miSpriteDevPrivatesKey, pCursorInfo);
d886 2
d890 2
d905 1
a905 1
    if (!IsMaster(pDev) && !pDev->u.master)
d909 1
a909 1
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
d913 1
d944 1
a944 1
    if (!IsMaster(pDev) && !pDev->u.master)
d948 1
a948 1
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
d985 1
a985 1
    if (!IsMaster(pDev) && !pDev->u.master)
d989 1
a989 1
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
d1025 1
a1025 1
    if (!IsMaster(pDev) && !pDev->u.master)
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d569 1
a569 1
                SPRITE_DEBUG (("BlockHandler restore\n"));
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a96 1
    miSpriteCursorFuncPtr    funcs;
d185 4
a188 4
static int miSpriteScreenKeyIndex;
static DevPrivateKey miSpriteScreenKey = &miSpriteScreenKeyIndex;
static int miSpriteDevPrivatesKeyIndex;
static DevPrivateKey miSpriteDevPrivatesKey = &miSpriteDevPrivatesKeyIndex;
a259 1
    miSpriteScreenPtr	    pScreenPriv;
a262 2
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);

d271 1
a271 1
                miRectIn(pRegion, &pCursorInfo->saved) != rgnOUT)
a287 1
                    miSpriteCursorFuncPtr   cursorFuncs,
d296 7
a302 1
    pScreenPriv = xalloc (sizeof (miSpriteScreenRec));
d315 1
a315 1
	xfree (pScreenPriv);
a339 1
    pScreenPriv->funcs = cursorFuncs;
d389 1
a389 1
    xfree (pScreenPriv);
a399 1
    miSpriteScreenPtr    pScreenPriv;
a406 1
        pScreenPriv = dixLookupPrivate(&pScreen->devPrivates,miSpriteScreenKey);
a433 1
    miSpriteScreenPtr	    pScreenPriv;
a440 2
        pScreenPriv = dixLookupPrivate(&pScreen->devPrivates,miSpriteScreenKey);

a484 1
    miSpriteScreenPtr	    pScreenPriv;
a491 2
	pScreenPriv = dixLookupPrivate(&pScreen->devPrivates,miSpriteScreenKey);

a517 1
    miSpriteScreenPtr	    pScreenPriv;
a522 2
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);

d532 1
a532 1
                    miRectIn(prgnSrc, &pCursorInfo->saved) != rgnOUT)
a751 1
    miSpriteScreenPtr	pScreenPriv;
a753 1
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
d762 1
a762 1
    return (*pScreenPriv->funcs->RealizeCursor) (pScreen, pCursor);
d768 1
a768 4
    miSpriteScreenPtr	pScreenPriv;

    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
    return (*pScreenPriv->funcs->UnrealizeCursor) (pScreen, pCursor);
a774 1
    miSpriteScreenPtr	pScreenPriv;
a776 2
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);

d807 3
a809 67
#if 0
        /* FIXME: Disabled for MPX, should be rewritten */
	int	sx, sy;
	/*
	 * check to see if the old saved region
	 * encloses the new sprite, in which case we use
	 * the flicker-free MoveCursor primitive.
	 */
	sx = pointer->x - (int)pCursor->bits->xhot;
	sy = pointer->y - (int)pCursor->bits->yhot;
	if (sx + (int) pCursor->bits->width >= pointer->saved.x1 &&
	    sx < pointer->saved.x2 &&
	    sy + (int) pCursor->bits->height >= pointer->saved.y1 &&
	    sy < pointer->saved.y2 &&
	    (int) pCursor->bits->width + (2 * SPRITE_PAD) ==
		pointer->saved.x2 - pointer->saved.x1 &&
	    (int) pCursor->bits->height + (2 * SPRITE_PAD) ==
		pointer->saved.y2 - pointer->saved.y1
	    )
	{
	    DamageDrawInternal (pScreen, TRUE);
	    miSpriteIsDown(pCursorInfo);
	    if (!(sx >= pointer->saved.x1 &&
                  sx + (int)pCursor->bits->width < pointer->saved.x2
                  && sy >= pointer->saved.y1 &&
                  sy + (int)pCursor->bits->height <
                                pointer->saved.y2))
            {
		int oldx1, oldy1, dx, dy;

		oldx1 = pointer->saved.x1;
		oldy1 = pointer->saved.y1;
		dx = oldx1 - (sx - SPRITE_PAD);
		dy = oldy1 - (sy - SPRITE_PAD);
		pointer->saved.x1 -= dx;
		pointer->saved.y1 -= dy;
		pointer->saved.x2 -= dx;
		pointer->saved.y2 -= dy;
		(void) (*pScreenPriv->funcs->ChangeSave) (pScreen,
				pointer->saved.x1,
 				pointer->saved.y1,
                                pointer->saved.x2 -
                                pointer->saved.x1,
                                pointer->saved.y2 -
                                pointer->saved.y1,
				dx, dy);
	    }
	    (void) (*pScreenPriv->funcs->MoveCursor) (pScreen, pCursor,
				  pointer->saved.x1,
 				  pointer->saved.y1,
                                  pointer->saved.x2 -
                                  pointer->saved.x1,
                                  pointer->saved.y2 -
                                  pointer->saved.y1,
				  sx - pointer->saved.x1,
				  sy - pointer->saved.y1,
				  pointer->colors[SOURCE_COLOR].pixel,
				  pointer->colors[MASK_COLOR].pixel);
	    miSpriteIsUp(pCursorInfo);
	    DamageDrawInternal (pScreen, FALSE);
	}
	else
#endif
	{
	    SPRITE_DEBUG (("SetCursor remove %d\n", pDev->id));
	    miSpriteRemoveCursor (pDev, pScreen);
	}
a823 1
    miSpriteScreenPtr	pScreenPriv;
a825 1
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
a837 1
    miSpriteScreenPtr pScreenPriv;
d841 1
a841 3
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);

    pCursorInfo = xalloc(sizeof(miCursorInfoRec));
d855 1
a855 1
    ret = (*pScreenPriv->funcs->DeviceCursorInitialize)(pDev, pScreen);
d858 1
a858 1
        xfree(pCursorInfo);
d869 1
a869 7
    {
        miSpriteScreenPtr pScreenPriv;
        pScreenPriv = dixLookupPrivate(&pScreen->devPrivates,
                                       miSpriteScreenKey);

        (*pScreenPriv->funcs->DeviceCursorCleanup)(pDev, pScreen);
    }
d893 8
a900 8
    if (!(*pScreenPriv->funcs->RestoreUnderCursor) (pDev,
                                         pScreen,
					 pCursorInfo->saved.x1,
                                         pCursorInfo->saved.y1,
                                         pCursorInfo->saved.x2 -
                                         pCursorInfo->saved.x1,
                                         pCursorInfo->saved.y2 -
                                         pCursorInfo->saved.y1))
d902 1
a902 1
	miSpriteIsUp(pCursorInfo);
d935 8
a942 8
    (*pScreenPriv->funcs->SaveUnderCursor) (pDev,
                                      pScreen,
				      pCursorInfo->saved.x1,
				      pCursorInfo->saved.y1,
                                      pCursorInfo->saved.x2 -
                                      pCursorInfo->saved.x1,
                                      pCursorInfo->saved.y2 -
                                      pCursorInfo->saved.y1);
d978 1
a978 1
    if ((*pScreenPriv->funcs->PutUpCursor) (pDev, pScreen,
a996 1
    miSpriteScreenPtr   pScreenPriv;
a1004 1
    pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d36 18
a53 17
# include   <X11/X.h>
# include   <X11/Xproto.h>
# include   "misc.h"
# include   "pixmapstr.h"
# include   "input.h"
# include   "mi.h"
# include   "cursorstr.h"
# include   <X11/fonts/font.h>
# include   "scrnintstr.h"
# include   "colormapst.h"
# include   "windowstr.h"
# include   "gcstruct.h"
# include   "mipointer.h"
# include   "mispritest.h"
# include   "dixfontstr.h"
# include   <X11/fonts/fontstruct.h>
# include   "inputstr.h"
d55 78
a132 4
#ifdef RENDER
# include   "mipict.h"
#endif
# include   "damage.h"
d134 2
a144 1

d146 1
a146 1
    ((DevHasCursor(dev)) ? \
d148 1
a148 3
       (miCursorInfoPtr)dixLookupPrivate(&dev->u.master->devPrivates, miSpriteDevPrivatesKey))

static int damageRegister = 0;
d153 1
a153 1
    if (damageRegister) {
d156 1
a156 1
	damageRegister = 0;
d163 2
a164 2
    if (!damageRegister) {
	damageRegister = 1;
d188 2
a189 2
static int mmiSpriteDevPrivatesKeyIndex;
static DevPrivateKey miSpriteDevPrivatesKey = &mmiSpriteDevPrivatesKeyIndex;
d237 1
a237 1
_X_EXPORT miPointerSpriteFuncRec miSpritePointerFuncs = {
d265 1
a265 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d275 1
a275 2
                RECT_IN_REGION (pScreen, pRegion, &pCursorInfo->saved)
                         != rgnOUT)
d301 1
a301 1
    pScreenPriv = (miSpriteScreenPtr) xalloc (sizeof (miSpriteScreenRec));
d306 1
a306 1
					 (DamageDestroyFunc) 0,
d310 1
a310 1
					 (void *) pScreen);
d314 1
a314 1
	xfree ((pointer) pScreenPriv);
d346 2
a360 2
    damageRegister = 0;

d378 1
a378 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d389 1
a389 1
    xfree ((pointer) pScreenPriv);
d401 1
a401 1
    DeviceIntPtr    pDev = inputInfo.pointer;
d406 1
a406 3
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
    for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
d408 2
a409 1
        if (DevHasCursor(pDev))
d411 11
a421 10
             pCursorInfo = MISPRITE(pDev);
             if (pDrawable->type == DRAWABLE_WINDOW &&
                     pCursorInfo->isUp &&
                     pCursorInfo->pScreen == pScreen &&
                     ORG_OVERLAP(&pCursorInfo->saved,pDrawable->x,pDrawable->y,
                         sx, sy, w, h))
             {
                 SPRITE_DEBUG (("GetImage remove\n"));
                 miSpriteRemoveCursor (pDev, pScreen);
             }
d437 1
a437 1
    DeviceIntPtr            pDev = inputInfo.pointer;
d442 3
a444 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d446 1
a446 3
    for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
    {
        if (DevHasCursor(pDev))
d448 3
a450 1
            pCursorInfo = MISPRITE(pDev);
d452 1
a452 16
            if (pDrawable->type == DRAWABLE_WINDOW &&
                    pCursorInfo->isUp &&
                    pCursorInfo->pScreen == pScreen)
            {
                DDXPointPtr    pts;
                int    	       *widths;
                int    	       nPts;
                int    	       xorg,
                               yorg;

                xorg = pDrawable->x;
                yorg = pDrawable->y;

                for (pts = ppt, widths = pwidth, nPts = nspans;
                        nPts--;
                        pts++, widths++)
d454 12
a465 2
                    if (SPN_OVERLAP(&pCursorInfo->saved,pts->y+yorg,
                                pts->x+xorg,*widths))
d467 7
a473 3
                        SPRITE_DEBUG (("GetSpans remove\n"));
                        miSpriteRemoveCursor (pDev, pScreen);
                        break;
d491 1
a491 1
    DeviceIntPtr            pDev = inputInfo.pointer;
d496 3
a498 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d500 14
a513 14
    for(pDev = inputInfo.devices; pDev; pDev = pDev->next)
    {
        if (DevHasCursor(pDev))
        {
            pCursorInfo = MISPRITE(pDev);
            if (pDrawable->type == DRAWABLE_WINDOW && pCursorInfo->isUp &&
                    pCursorInfo->pScreen == pScreen &&
                    ORG_OVERLAP(&pCursorInfo->saved, pDrawable->x, pDrawable->y,
                        x, y, width, height))
            {
                SPRITE_DEBUG (("SourceValidate remove\n"));
                miSpriteRemoveCursor (pDev, pScreen);
            }
        }
d527 1
a527 1
    DeviceIntPtr            pDev = inputInfo.pointer;
d532 1
a532 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d543 1
a543 1
                    RECT_IN_REGION (pScreen, prgnSrc, &pCursorInfo->saved) != rgnOUT)
d561 1
a561 1
    DeviceIntPtr            pDev = inputInfo.pointer;
d564 1
a564 2
    pPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						miSpriteScreenKey);
d607 1
a607 2
    pPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						miSpriteScreenKey);
d642 1
a642 1
    DeviceIntPtr        pDev = inputInfo.pointer;
d645 1
a645 2
    pPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						miSpriteScreenKey);
d720 1
a720 1
    miSpriteScreenPtr   pScreenPriv = (miSpriteScreenPtr)
d766 2
a767 5
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
    if (!pDev->isMaster && !pDev->u.master)
    {
        ErrorF("[mi] miSpriteRealizeCursor called for floating device.\n");
d769 1
a769 1
    }
d783 1
a783 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d794 1
a794 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d796 1
a796 3
    if (!pDev->isMaster && !pDev->u.master)
    {
        ErrorF("[mi] miSpriteSetCursor called for floating device.\n");
d798 1
a798 1
    }
d910 2
a911 5
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
    if (!pDev->isMaster && !pDev->u.master)
    {
        ErrorF("[mi] miSpriteMoveCursor called for floating device.\n");
d913 1
a913 1
    }
d927 1
a927 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d959 2
a960 2
        pScreenPriv = (miSpriteScreenPtr)
                dixLookupPrivate(&pScreen->devPrivates, miSpriteScreenKey);
d977 1
a977 3
    if (!pDev->isMaster && !pDev->u.master)
    {
        ErrorF("[mi] miSpriteRemoveCursor called for floating device.\n");
d979 1
a979 1
    }
d981 1
a981 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d1015 1
a1015 3
    if (!pDev->isMaster && !pDev->u.master)
    {
        ErrorF("[mi] miSpriteSaveUnderCursor called for floating device.\n");
d1017 1
a1017 1
    }
d1019 1
a1019 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d1056 1
a1056 3
    if (!pDev->isMaster && !pDev->u.master)
    {
        ErrorF("[mi] miSpriteRestoreCursor called for floating device.\n");
a1057 1
    }
d1060 1
a1060 2
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
d1097 1
a1097 3
    if (!pDev->isMaster && !pDev->u.master)
    {
        ErrorF("[mi] miSpriteComputeSaved called for floating device.\n");
d1099 2
a1100 3
    }
    pScreenPriv = (miSpriteScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						      miSpriteScreenKey);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a6 1

d52 1
d59 2
d68 40
d112 4
a115 1
static DevPrivateKey miSpriteScreenKey = &miSpriteScreenKey;
d136 7
a142 1
static void	    miSpriteComputeSaved(ScreenPtr pScreen);
d154 8
a161 5
static Bool miSpriteRealizeCursor(ScreenPtr pScreen, CursorPtr pCursor);
static Bool miSpriteUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor);
static void miSpriteSetCursor(ScreenPtr pScreen, CursorPtr pCursor,
			      int x, int y);
static void miSpriteMoveCursor(ScreenPtr pScreen, int x, int y);
d168 2
d176 6
a181 2
static void miSpriteRemoveCursor(ScreenPtr pScreen);
static void miSpriteRestoreCursor(ScreenPtr pScreen);
d188 3
a190 1
    
d193 2
a194 2
    if (pScreenPriv->isUp &&
	RECT_IN_REGION (pScreen, pRegion, &pScreenPriv->saved) != rgnOUT)
d196 13
a208 2
	SPRITE_DEBUG(("Damage remove\n"));
	miSpriteRemoveCursor (pScreen);
d219 3
a221 4
miSpriteInitialize (pScreen, cursorFuncs, screenFuncs)
    ScreenPtr		    pScreen;
    miSpriteCursorFuncPtr   cursorFuncs;
    miPointerScreenFuncPtr  screenFuncs;
d225 1
a225 1
    
d232 1
a232 1
    
d256 1
a256 1
    
d259 1
a259 1
    
d261 4
a264 9
    
    pScreenPriv->pCursor = NULL;
    pScreenPriv->x = 0;
    pScreenPriv->y = 0;
    pScreenPriv->isUp = FALSE;
    pScreenPriv->shouldBeUp = FALSE;
    pScreenPriv->pCacheWin = NullWindow;
    pScreenPriv->isInCacheWin = FALSE;
    pScreenPriv->checkPixels = TRUE;
d275 1
a275 1
    
d280 1
a280 1
    
a281 1
    
d286 3
a288 1
    
d302 1
a302 3
miSpriteCloseScreen (i, pScreen)
    int i;
    ScreenPtr	pScreen;
a315 1
    miSpriteIsUpFALSE (pScreen, pScreenPriv);
d317 1
a317 1
    
d324 3
a326 6
miSpriteGetImage (pDrawable, sx, sy, w, h, format, planemask, pdstLine)
    DrawablePtr	    pDrawable;
    int		    sx, sy, w, h;
    unsigned int    format;
    unsigned long   planemask;
    char	    *pdstLine;
d330 3
a332 1
    
d337 1
a337 3
    if (pDrawable->type == DRAWABLE_WINDOW &&
        pScreenPriv->isUp &&
	ORG_OVERLAP(&pScreenPriv->saved,pDrawable->x,pDrawable->y, sx, sy, w, h))
d339 13
a351 2
	SPRITE_DEBUG (("GetImage remove\n"));
	miSpriteRemoveCursor (pScreen);
d361 2
a362 7
miSpriteGetSpans (pDrawable, wMax, ppt, pwidth, nspans, pdstStart)
    DrawablePtr	pDrawable;
    int		wMax;
    DDXPointPtr	ppt;
    int		*pwidth;
    int		nspans;
    char	*pdstStart;
d366 3
a368 1
    
d373 2
a374 1
    if (pDrawable->type == DRAWABLE_WINDOW && pScreenPriv->isUp)
d376 31
a406 21
	DDXPointPtr    	pts;
	int    		*widths;
	int    		nPts;
	int    		xorg,
			yorg;

	xorg = pDrawable->x;
	yorg = pDrawable->y;

	for (pts = ppt, widths = pwidth, nPts = nspans;
	     nPts--;
	     pts++, widths++)
 	{
	    if (SPN_OVERLAP(&pScreenPriv->saved,pts->y+yorg,
			     pts->x+xorg,*widths))
	    {
		SPRITE_DEBUG (("GetSpans remove\n"));
		miSpriteRemoveCursor (pScreen);
		break;
	    }
	}
d415 2
a416 3
miSpriteSourceValidate (pDrawable, x, y, width, height)
    DrawablePtr	pDrawable;
    int		x, y, width, height;
d420 3
a422 1
    
d427 2
a428 3
    if (pDrawable->type == DRAWABLE_WINDOW && pScreenPriv->isUp &&
	ORG_OVERLAP(&pScreenPriv->saved, pDrawable->x, pDrawable->y,
		    x, y, width, height))
d430 12
a441 2
	SPRITE_DEBUG (("SourceValidate remove\n"));
	miSpriteRemoveCursor (pScreen);
d455 3
a457 1
    
d462 2
a463 5
    /*
     * Damage will take care of destination check
     */
    if (pScreenPriv->isUp &&
	RECT_IN_REGION (pScreen, prgnSrc, &pScreenPriv->saved) != rgnOUT)
d465 13
a477 2
	SPRITE_DEBUG (("CopyWindow remove\n"));
	miSpriteRemoveCursor (pScreen);
d485 2
a486 5
miSpriteBlockHandler (i, blockData, pTimeout, pReadmask)
    int	i;
    pointer	blockData;
    pointer	pTimeout;
    pointer	pReadmask;
d490 2
d496 1
a496 1
    
d501 15
a515 1
    if (!pPriv->isUp && pPriv->shouldBeUp)
d517 11
a527 2
	SPRITE_DEBUG (("BlockHandler restore\n"));
	miSpriteRestoreCursor (pScreen);
d532 1
a532 2
miSpriteInstallColormap (pMap)
    ColormapPtr	pMap;
d540 1
a540 1
    
d545 1
d549 13
a561 3
    	pPriv->checkPixels = TRUE;
	if (pPriv->isUp)
	    miSpriteRemoveCursor (pScreen);
d566 1
a566 4
miSpriteStoreColors (pMap, ndef, pdef)
    ColormapPtr	pMap;
    int		ndef;
    xColorItem	*pdef;
d573 2
d579 1
a579 1
    
d586 5
a590 5
	updated = 0;
	pVisual = pMap->pVisual;
	if (pVisual->class == DirectColor)
	{
	    /* Direct color - match on any of the subfields */
d594 3
a596 3
#define UpdateDAC(plane,dac,mask) {\
    if (MaskMatch (pPriv->colors[plane].pixel,pdef[i].pixel,mask)) {\
	pPriv->colors[plane].dac = pdef[i].dac; \
d601 45
a645 36
#define CheckDirect(plane) \
	    UpdateDAC(plane,red,redMask) \
	    UpdateDAC(plane,green,greenMask) \
	    UpdateDAC(plane,blue,blueMask)

	    for (i = 0; i < ndef; i++)
	    {
		CheckDirect (SOURCE_COLOR)
		CheckDirect (MASK_COLOR)
	    }
	}
	else
	{
	    /* PseudoColor/GrayScale - match on exact pixel */
	    for (i = 0; i < ndef; i++)
	    {
	    	if (pdef[i].pixel == pPriv->colors[SOURCE_COLOR].pixel)
	    	{
		    pPriv->colors[SOURCE_COLOR] = pdef[i];
		    if (++updated == 2)
		    	break;
	    	}
	    	if (pdef[i].pixel == pPriv->colors[MASK_COLOR].pixel)
	    	{
		    pPriv->colors[MASK_COLOR] = pdef[i];
		    if (++updated == 2)
		    	break;
	    	}
	    }
	}
    	if (updated)
    	{
	    pPriv->checkPixels = TRUE;
	    if (pPriv->isUp)
	    	miSpriteRemoveCursor (pScreen);
    	}
d650 1
a650 1
miSpriteFindColors (ScreenPtr pScreen)
d652 1
a652 1
    miSpriteScreenPtr	pScreenPriv = (miSpriteScreenPtr)
d657 1
a657 1
    pCursor = pScreenPriv->pCursor;
d681 3
a683 1
    pScreenPriv->checkPixels = FALSE;
d693 1
a693 3
miSpriteRealizeCursor (pScreen, pCursor)
    ScreenPtr	pScreen;
    CursorPtr	pCursor;
d696 1
d700 10
a709 2
    if (pCursor == pScreenPriv->pCursor)
	pScreenPriv->checkPixels = TRUE;
d714 1
a714 3
miSpriteUnrealizeCursor (pScreen, pCursor)
    ScreenPtr	pScreen;
    CursorPtr	pCursor;
d724 2
a725 5
miSpriteSetCursor (pScreen, pCursor, x, y)
    ScreenPtr	pScreen;
    CursorPtr	pCursor;
    int		x;
    int		y;
d728 1
d732 8
d742 4
a745 4
    	pScreenPriv->shouldBeUp = FALSE;
    	if (pScreenPriv->isUp)
	    miSpriteRemoveCursor (pScreen);
	pScreenPriv->pCursor = 0;
d748 5
a752 5
    pScreenPriv->shouldBeUp = TRUE;
    if (pScreenPriv->x == x &&
	pScreenPriv->y == y &&
	pScreenPriv->pCursor == pCursor &&
	!pScreenPriv->checkPixels)
d756 4
a759 4
    pScreenPriv->x = x;
    pScreenPriv->y = y;
    pScreenPriv->pCacheWin = NullWindow;
    if (pScreenPriv->checkPixels || pScreenPriv->pCursor != pCursor)
d761 2
a762 2
	pScreenPriv->pCursor = pCursor;
	miSpriteFindColors (pScreen);
d764 3
a766 1
    if (pScreenPriv->isUp) {
d773 6
a778 6
	sx = pScreenPriv->x - (int)pCursor->bits->xhot;
	sy = pScreenPriv->y - (int)pCursor->bits->yhot;
	if (sx + (int) pCursor->bits->width >= pScreenPriv->saved.x1 &&
	    sx < pScreenPriv->saved.x2 &&
	    sy + (int) pCursor->bits->height >= pScreenPriv->saved.y1 &&
	    sy < pScreenPriv->saved.y2 &&
d780 1
a780 1
		pScreenPriv->saved.x2 - pScreenPriv->saved.x1 &&
d782 1
a782 1
		pScreenPriv->saved.y2 - pScreenPriv->saved.y1
d786 7
a792 6
	    miSpriteIsUpFALSE (pScreen, pScreenPriv);
	    if (!(sx >= pScreenPriv->saved.x1 &&
	      	  sx + (int)pCursor->bits->width < pScreenPriv->saved.x2 &&
	      	  sy >= pScreenPriv->saved.y1 &&
	      	  sy + (int)pCursor->bits->height < pScreenPriv->saved.y2))
	    {
d795 2
a796 2
		oldx1 = pScreenPriv->saved.x1;
		oldy1 = pScreenPriv->saved.y1;
d799 4
a802 4
		pScreenPriv->saved.x1 -= dx;
		pScreenPriv->saved.y1 -= dy;
		pScreenPriv->saved.x2 -= dx;
		pScreenPriv->saved.y2 -= dy;
d804 6
a809 4
				pScreenPriv->saved.x1,
 				pScreenPriv->saved.y1,
				pScreenPriv->saved.x2 - pScreenPriv->saved.x1,
				pScreenPriv->saved.y2 - pScreenPriv->saved.y1,
d813 11
a823 9
				  pScreenPriv->saved.x1,
 				  pScreenPriv->saved.y1,
				  pScreenPriv->saved.x2 - pScreenPriv->saved.x1,
				  pScreenPriv->saved.y2 - pScreenPriv->saved.y1,
				  sx - pScreenPriv->saved.x1,
				  sy - pScreenPriv->saved.y1,
				  pScreenPriv->colors[SOURCE_COLOR].pixel,
				  pScreenPriv->colors[MASK_COLOR].pixel);
	    miSpriteIsUpTRUE (pScreen, pScreenPriv);
d827 1
d829 2
a830 2
	    SPRITE_DEBUG (("SetCursor remove\n"));
	    miSpriteRemoveCursor (pScreen);
d833 2
a834 1
    if (!pScreenPriv->isUp && pScreenPriv->pCursor)
d836 3
a838 2
	SPRITE_DEBUG (("SetCursor restore\n"));
	miSpriteRestoreCursor (pScreen);
d840 1
d844 1
a844 3
miSpriteMoveCursor (pScreen, x, y)
    ScreenPtr	pScreen;
    int		x, y;
d847 1
d851 56
a906 1
    miSpriteSetCursor (pScreen, pScreenPriv->pCursor, x, y);
d914 1
a914 2
miSpriteRemoveCursor (pScreen)
    ScreenPtr	pScreen;
d917 1
d919 6
d928 13
a940 7
    miSpriteIsUpFALSE (pScreen, pScreenPriv);
    pScreenPriv->pCacheWin = NullWindow;
    if (!(*pScreenPriv->funcs->RestoreUnderCursor) (pScreen,
					 pScreenPriv->saved.x1,
					 pScreenPriv->saved.y1,
					 pScreenPriv->saved.x2 - pScreenPriv->saved.x1,
					 pScreenPriv->saved.y2 - pScreenPriv->saved.y1))
d942 1
a942 1
	miSpriteIsUpTRUE (pScreen, pScreenPriv);
d944 1
d949 44
d998 1
a998 2
miSpriteRestoreCursor (pScreen)
    ScreenPtr	pScreen;
d1003 7
a1011 1
    miSpriteComputeSaved (pScreen);
d1014 18
a1031 17
    pCursor = pScreenPriv->pCursor;
    x = pScreenPriv->x - (int)pCursor->bits->xhot;
    y = pScreenPriv->y - (int)pCursor->bits->yhot;
    if ((*pScreenPriv->funcs->SaveUnderCursor) (pScreen,
				      pScreenPriv->saved.x1,
				      pScreenPriv->saved.y1,
				      pScreenPriv->saved.x2 - pScreenPriv->saved.x1,
				      pScreenPriv->saved.y2 - pScreenPriv->saved.y1))
    {
	if (pScreenPriv->checkPixels)
	    miSpriteFindColors (pScreen);
	if ((*pScreenPriv->funcs->PutUpCursor) (pScreen, pCursor, x, y,
				  pScreenPriv->colors[SOURCE_COLOR].pixel,
				  pScreenPriv->colors[MASK_COLOR].pixel))
	{
	    miSpriteIsUpTRUE (pScreen, pScreenPriv);
	}
d1033 1
d1042 1
a1042 2
miSpriteComputeSaved (pScreen)
    ScreenPtr	pScreen;
d1048 1
d1050 5
d1057 5
a1061 3
    pCursor = pScreenPriv->pCursor;
    x = pScreenPriv->x - (int)pCursor->bits->xhot;
    y = pScreenPriv->y - (int)pCursor->bits->yhot;
d1066 4
a1069 4
    pScreenPriv->saved.x1 = x - wpad;
    pScreenPriv->saved.y1 = y - hpad;
    pScreenPriv->saved.x2 = pScreenPriv->saved.x1 + w + wpad * 2;
    pScreenPriv->saved.y2 = pScreenPriv->saved.y1 + h + hpad * 2;
d1071 1
@


1.1
log
@Initial revision
@
text
@d70 1
a70 2
static int  miSpriteScreenIndex;
static unsigned long miSpriteGeneration = 0;
a90 3
static void	    miSpriteSaveDoomedAreas(WindowPtr pWin,
					    RegionPtr pObscured, int dx,
					    int dy);
d93 3
a95 4
#define SCREEN_PROLOGUE(pScreen, field)\
  ((pScreen)->field = \
   ((miSpriteScreenPtr) (pScreen)->devPrivates[miSpriteScreenIndex].ptr)->field)

d129 2
a130 2
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;
    
a156 8
    if (miSpriteGeneration != serverGeneration)
    {
	miSpriteScreenIndex = AllocateScreenPrivateIndex ();
	if (miSpriteScreenIndex < 0)
	    return FALSE;
	miSpriteGeneration = serverGeneration;
    }
    
a184 2
    pScreenPriv->SaveDoomedAreas = pScreen->SaveDoomedAreas;
    
d207 1
a207 1
    pScreen->devPrivates[miSpriteScreenIndex].ptr = (pointer) pScreenPriv;
a215 2
    pScreen->SaveDoomedAreas = miSpriteSaveDoomedAreas;
    
d240 2
a241 2
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;

a249 1
    pScreen->SaveDoomedAreas = pScreenPriv->SaveDoomedAreas;
d271 2
a272 2
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;

d301 2
a302 2
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;

d305 5
a309 5
	register DDXPointPtr    pts;
	register int    	*widths;
	register int    	nPts;
	register int    	xorg,
				yorg;
d343 2
a344 2
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;

d367 2
a368 1
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;
d393 2
a394 2
    pPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;

d415 2
a416 2
    pPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;

d444 2
a445 2
    pPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;

d512 1
a512 1
			    pScreen->devPrivates[miSpriteScreenIndex].ptr;
a543 39
 * BackingStore wrappers
 */

static void
miSpriteSaveDoomedAreas (pWin, pObscured, dx, dy)
    WindowPtr	pWin;
    RegionPtr	pObscured;
    int		dx, dy;
{
    ScreenPtr		pScreen;
    miSpriteScreenPtr   pScreenPriv;
    BoxRec		cursorBox;

    pScreen = pWin->drawable.pScreen;
    
    SCREEN_PROLOGUE (pScreen, SaveDoomedAreas);

    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;
    if (pScreenPriv->isUp)
    {
	cursorBox = pScreenPriv->saved;

	if (dx || dy)
 	{
	    cursorBox.x1 += dx;
	    cursorBox.y1 += dy;
	    cursorBox.x2 += dx;
	    cursorBox.y2 += dy;
	}
	if (RECT_IN_REGION( pScreen, pObscured, &cursorBox) != rgnOUT)
	    miSpriteRemoveCursor (pScreen);
    }

    (*pScreen->SaveDoomedAreas) (pWin, pObscured, dx, dy);

    SCREEN_EPILOGUE (pScreen, SaveDoomedAreas);
}

/*
d556 2
a557 1
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;
d570 2
a571 1
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;
d584 2
a585 1
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;
d685 2
a686 1
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;
d701 2
a702 1
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;
d731 2
a732 1
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;
d767 2
a768 1
    pScreenPriv = (miSpriteScreenPtr) pScreen->devPrivates[miSpriteScreenIndex].ptr;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d323 5
a327 5
	DDXPointPtr    	pts;
	int    		*widths;
	int    		nPts;
	int    		xorg,
			yorg;
@

