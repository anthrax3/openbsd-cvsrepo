head	1.11;
access;
symbols
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	Te1daavkBLskZ8gc;

1.9
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	cVXoV5PxI8YrEaVA;

1.8
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.18;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.18;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * midispcur.c
 *
 * machine independent cursor display routines
 */

/*

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.
*/

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include   <X11/X.h>
#include   "misc.h"
#include   "input.h"
#include   "cursorstr.h"
#include   "windowstr.h"
#include   "regionstr.h"
#include   "dixstruct.h"
#include   "scrnintstr.h"
#include   "servermd.h"
#include   "mipointer.h"
#include   "misprite.h"
#include   "gcstruct.h"

#include   "picturestr.h"

#include "inputstr.h"

/* per-screen private data */
static DevPrivateKeyRec miDCScreenKeyRec;

#define miDCScreenKey (&miDCScreenKeyRec)

static DevScreenPrivateKeyRec miDCDeviceKeyRec;

#define miDCDeviceKey (&miDCDeviceKeyRec)

static Bool miDCCloseScreen(ScreenPtr pScreen);

/* per device private data */
typedef struct {
    GCPtr pSourceGC, pMaskGC;
    GCPtr pSaveGC, pRestoreGC;
    PixmapPtr pSave;
    PicturePtr pRootPicture;
} miDCBufferRec, *miDCBufferPtr;

#define miGetDCDevice(dev, screen) \
 ((DevHasCursor(dev)) ? \
  (miDCBufferPtr)dixLookupScreenPrivate(&dev->devPrivates, miDCDeviceKey, screen) : \
  (miDCBufferPtr)dixLookupScreenPrivate(&GetMaster(dev, MASTER_POINTER)->devPrivates, miDCDeviceKey, screen))

/*
 * The core pointer buffer will point to the index of the virtual pointer
 * in the pCursorBuffers array.
 */
typedef struct {
    CloseScreenProcPtr CloseScreen;
    PixmapPtr sourceBits;       /* source bits */
    PixmapPtr maskBits;         /* mask bits */
    PicturePtr pPicture;
    CursorPtr pCursor;
} miDCScreenRec, *miDCScreenPtr;

#define miGetDCScreen(s)	((miDCScreenPtr)(dixLookupPrivate(&(s)->devPrivates, miDCScreenKey)))

Bool
miDCInitialize(ScreenPtr pScreen, miPointerScreenFuncPtr screenFuncs)
{
    miDCScreenPtr pScreenPriv;

    if (!dixRegisterPrivateKey(&miDCScreenKeyRec, PRIVATE_SCREEN, 0) ||
        !dixRegisterScreenPrivateKey(&miDCDeviceKeyRec, pScreen, PRIVATE_DEVICE,
                                     0))
        return FALSE;

    pScreenPriv = calloc(1, sizeof(miDCScreenRec));
    if (!pScreenPriv)
        return FALSE;

    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = miDCCloseScreen;

    dixSetPrivate(&pScreen->devPrivates, miDCScreenKey, pScreenPriv);

    if (!miSpriteInitialize(pScreen, screenFuncs)) {
        free((void *) pScreenPriv);
        return FALSE;
    }
    return TRUE;
}

static void
miDCSwitchScreenCursor(ScreenPtr pScreen, CursorPtr pCursor, PixmapPtr sourceBits, PixmapPtr maskBits, PicturePtr pPicture)
{
    miDCScreenPtr pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miDCScreenKey);

    if (pScreenPriv->sourceBits)
        (*pScreen->DestroyPixmap)(pScreenPriv->sourceBits);
    pScreenPriv->sourceBits = sourceBits;

    if (pScreenPriv->maskBits)
        (*pScreen->DestroyPixmap)(pScreenPriv->maskBits);
    pScreenPriv->maskBits = maskBits;

    if (pScreenPriv->pPicture)
        FreePicture(pScreenPriv->pPicture, 0);
    pScreenPriv->pPicture = pPicture;

    pScreenPriv->pCursor = pCursor;
}

static Bool
miDCCloseScreen(ScreenPtr pScreen)
{
    miDCScreenPtr pScreenPriv;

    pScreenPriv = (miDCScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                   miDCScreenKey);
    pScreen->CloseScreen = pScreenPriv->CloseScreen;

    miDCSwitchScreenCursor(pScreen, NULL, NULL, NULL, NULL);
    free((void *) pScreenPriv);
    return (*pScreen->CloseScreen) (pScreen);
}

Bool
miDCRealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
{
    return TRUE;
}

#define EnsurePicture(picture,draw,win) (picture || miDCMakePicture(&picture,draw,win))

static PicturePtr
miDCMakePicture(PicturePtr * ppPicture, DrawablePtr pDraw, WindowPtr pWin)
{
    PictFormatPtr pFormat;
    XID subwindow_mode = IncludeInferiors;
    PicturePtr pPicture;
    int error;

    pFormat = PictureWindowFormat(pWin);
    if (!pFormat)
        return 0;
    pPicture = CreatePicture(0, pDraw, pFormat,
                             CPSubwindowMode, &subwindow_mode,
                             serverClient, &error);
    *ppPicture = pPicture;
    return pPicture;
}

static Bool
miDCRealize(ScreenPtr pScreen, CursorPtr pCursor)
{
    miDCScreenPtr pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miDCScreenKey);
    GCPtr pGC;
    ChangeGCVal gcvals;
    PixmapPtr   sourceBits, maskBits;

    if (pScreenPriv->pCursor == pCursor)
        return TRUE;

    if (pCursor->bits->argb) {
        PixmapPtr pPixmap;
        PictFormatPtr pFormat;
        int error;
        PicturePtr  pPicture;

        pFormat = PictureMatchFormat(pScreen, 32, PICT_a8r8g8b8);
        if (!pFormat)
            return FALSE;

        pPixmap = (*pScreen->CreatePixmap) (pScreen, pCursor->bits->width,
                                            pCursor->bits->height, 32,
                                            CREATE_PIXMAP_USAGE_SCRATCH);
        if (!pPixmap)
            return FALSE;

        pGC = GetScratchGC(32, pScreen);
        if (!pGC) {
            (*pScreen->DestroyPixmap) (pPixmap);
            return FALSE;
        }
        ValidateGC(&pPixmap->drawable, pGC);
        (*pGC->ops->PutImage) (&pPixmap->drawable, pGC, 32,
                               0, 0, pCursor->bits->width,
                               pCursor->bits->height,
                               0, ZPixmap, (char *) pCursor->bits->argb);
        FreeScratchGC(pGC);
        pPicture = CreatePicture(0, &pPixmap->drawable,
                                 pFormat, 0, 0, serverClient, &error);
        (*pScreen->DestroyPixmap) (pPixmap);
        if (!pPicture)
            return FALSE;

        miDCSwitchScreenCursor(pScreen, pCursor, NULL, NULL, pPicture);
        return TRUE;
    }

    sourceBits = (*pScreen->CreatePixmap) (pScreen, pCursor->bits->width,
                                           pCursor->bits->height, 1, 0);
    if (!sourceBits)
        return FALSE;

    maskBits = (*pScreen->CreatePixmap) (pScreen, pCursor->bits->width,
                                         pCursor->bits->height, 1, 0);
    if (!maskBits) {
        (*pScreen->DestroyPixmap) (sourceBits);
        return FALSE;
    }

    /* create the two sets of bits, clipping as appropriate */

    pGC = GetScratchGC(1, pScreen);
    if (!pGC) {
        (*pScreen->DestroyPixmap) (sourceBits);
        (*pScreen->DestroyPixmap) (maskBits);
        return FALSE;
    }

    ValidateGC((DrawablePtr) sourceBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr) sourceBits, pGC, 1,
                           0, 0, pCursor->bits->width, pCursor->bits->height,
                           0, XYPixmap, (char *) pCursor->bits->source);
    gcvals.val = GXand;
    ChangeGC(NullClient, pGC, GCFunction, &gcvals);
    ValidateGC((DrawablePtr) sourceBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr) sourceBits, pGC, 1,
                           0, 0, pCursor->bits->width, pCursor->bits->height,
                           0, XYPixmap, (char *) pCursor->bits->mask);

    /* mask bits -- pCursor->mask & ~pCursor->source */
    gcvals.val = GXcopy;
    ChangeGC(NullClient, pGC, GCFunction, &gcvals);
    ValidateGC((DrawablePtr) maskBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr) maskBits, pGC, 1,
                           0, 0, pCursor->bits->width, pCursor->bits->height,
                           0, XYPixmap, (char *) pCursor->bits->mask);
    gcvals.val = GXandInverted;
    ChangeGC(NullClient, pGC, GCFunction, &gcvals);
    ValidateGC((DrawablePtr) maskBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr) maskBits, pGC, 1,
                           0, 0, pCursor->bits->width, pCursor->bits->height,
                           0, XYPixmap, (char *) pCursor->bits->source);
    FreeScratchGC(pGC);

    miDCSwitchScreenCursor(pScreen, pCursor, sourceBits, maskBits, NULL);
    return TRUE;
}

Bool
miDCUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor)
{
    miDCScreenPtr pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miDCScreenKey);

    if (pCursor == pScreenPriv->pCursor)
        miDCSwitchScreenCursor(pScreen, NULL, NULL, NULL, NULL);
    return TRUE;
}

static void
miDCPutBits(DrawablePtr pDrawable,
            GCPtr sourceGC,
            GCPtr maskGC,
            int x_org,
            int y_org,
            unsigned w, unsigned h, unsigned long source, unsigned long mask)
{
    miDCScreenPtr pScreenPriv = dixLookupPrivate(&pDrawable->pScreen->devPrivates, miDCScreenKey);
    ChangeGCVal gcval;
    int x, y;

    if (sourceGC->fgPixel != source) {
        gcval.val = source;
        ChangeGC(NullClient, sourceGC, GCForeground, &gcval);
    }
    if (sourceGC->serialNumber != pDrawable->serialNumber)
        ValidateGC(pDrawable, sourceGC);

    if (sourceGC->miTranslate) {
        x = pDrawable->x + x_org;
        y = pDrawable->y + y_org;
    }
    else {
        x = x_org;
        y = y_org;
    }

    (*sourceGC->ops->PushPixels) (sourceGC, pScreenPriv->sourceBits, pDrawable, w, h,
                                  x, y);
    if (maskGC->fgPixel != mask) {
        gcval.val = mask;
        ChangeGC(NullClient, maskGC, GCForeground, &gcval);
    }
    if (maskGC->serialNumber != pDrawable->serialNumber)
        ValidateGC(pDrawable, maskGC);

    if (maskGC->miTranslate) {
        x = pDrawable->x + x_org;
        y = pDrawable->y + y_org;
    }
    else {
        x = x_org;
        y = y_org;
    }

    (*maskGC->ops->PushPixels) (maskGC, pScreenPriv->maskBits, pDrawable, w, h, x, y);
}

static GCPtr
miDCMakeGC(WindowPtr pWin)
{
    GCPtr pGC;
    int status;
    XID gcvals[2];

    gcvals[0] = IncludeInferiors;
    gcvals[1] = FALSE;
    pGC = CreateGC((DrawablePtr) pWin,
                   GCSubwindowMode | GCGraphicsExposures, gcvals, &status,
                   (XID) 0, serverClient);
    return pGC;
}

Bool
miDCPutUpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor,
                int x, int y, unsigned long source, unsigned long mask)
{
    miDCScreenPtr pScreenPriv = dixLookupPrivate(&pScreen->devPrivates, miDCScreenKey);
    miDCBufferPtr pBuffer;
    WindowPtr pWin;

    if (!miDCRealize(pScreen, pCursor))
        return FALSE;

    pWin = pScreen->root;
    pBuffer = miGetDCDevice(pDev, pScreen);

    if (pScreenPriv->pPicture) {
        if (!EnsurePicture(pBuffer->pRootPicture, &pWin->drawable, pWin))
            return FALSE;
        CompositePicture(PictOpOver,
                         pScreenPriv->pPicture,
                         NULL,
                         pBuffer->pRootPicture,
                         0, 0, 0, 0,
                         x, y, pCursor->bits->width, pCursor->bits->height);
    }
    else
    {
        miDCPutBits((DrawablePtr) pWin,
                    pBuffer->pSourceGC, pBuffer->pMaskGC,
                    x, y, pCursor->bits->width, pCursor->bits->height,
                    source, mask);
    }
    return TRUE;
}

Bool
miDCSaveUnderCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
                    int x, int y, int w, int h)
{
    miDCBufferPtr pBuffer;
    PixmapPtr pSave;
    WindowPtr pWin;
    GCPtr pGC;

    pBuffer = miGetDCDevice(pDev, pScreen);

    pSave = pBuffer->pSave;
    pWin = pScreen->root;
    if (!pSave || pSave->drawable.width < w || pSave->drawable.height < h) {
        if (pSave)
            (*pScreen->DestroyPixmap) (pSave);
        pBuffer->pSave = pSave =
            (*pScreen->CreatePixmap) (pScreen, w, h, pScreen->rootDepth, 0);
        if (!pSave)
            return FALSE;
    }

    pGC = pBuffer->pSaveGC;
    if (pSave->drawable.serialNumber != pGC->serialNumber)
        ValidateGC((DrawablePtr) pSave, pGC);
    (*pGC->ops->CopyArea) ((DrawablePtr) pWin, (DrawablePtr) pSave, pGC,
                           x, y, w, h, 0, 0);
    return TRUE;
}

Bool
miDCRestoreUnderCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
                       int x, int y, int w, int h)
{
    miDCBufferPtr pBuffer;
    PixmapPtr pSave;
    WindowPtr pWin;
    GCPtr pGC;

    pBuffer = miGetDCDevice(pDev, pScreen);
    pSave = pBuffer->pSave;

    pWin = pScreen->root;
    if (!pSave)
        return FALSE;

    pGC = pBuffer->pRestoreGC;
    if (pWin->drawable.serialNumber != pGC->serialNumber)
        ValidateGC((DrawablePtr) pWin, pGC);
    (*pGC->ops->CopyArea) ((DrawablePtr) pSave, (DrawablePtr) pWin, pGC,
                           0, 0, w, h, x, y);
    return TRUE;
}

Bool
miDCDeviceInitialize(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    miDCBufferPtr pBuffer;
    WindowPtr pWin;
    int i;

    if (!DevHasCursor(pDev))
        return TRUE;

    for (i = 0; i < screenInfo.numScreens; i++) {
        pScreen = screenInfo.screens[i];

        pBuffer = calloc(1, sizeof(miDCBufferRec));
        if (!pBuffer)
            goto failure;

        dixSetScreenPrivate(&pDev->devPrivates, miDCDeviceKey, pScreen,
                            pBuffer);
        pWin = pScreen->root;

        pBuffer->pSourceGC = miDCMakeGC(pWin);
        if (!pBuffer->pSourceGC)
            goto failure;

        pBuffer->pMaskGC = miDCMakeGC(pWin);
        if (!pBuffer->pMaskGC)
            goto failure;

        pBuffer->pSaveGC = miDCMakeGC(pWin);
        if (!pBuffer->pSaveGC)
            goto failure;

        pBuffer->pRestoreGC = miDCMakeGC(pWin);
        if (!pBuffer->pRestoreGC)
            goto failure;

        pBuffer->pRootPicture = NULL;

        /* (re)allocated lazily depending on the cursor size */
        pBuffer->pSave = NULL;
    }

    return TRUE;

 failure:

    miDCDeviceCleanup(pDev, pScreen);

    return FALSE;
}

void
miDCDeviceCleanup(DeviceIntPtr pDev, ScreenPtr pScreen)
{
    miDCBufferPtr pBuffer;
    int i;

    if (DevHasCursor(pDev)) {
        for (i = 0; i < screenInfo.numScreens; i++) {
            pScreen = screenInfo.screens[i];

            pBuffer = miGetDCDevice(pDev, pScreen);

            if (pBuffer) {
                if (pBuffer->pSourceGC)
                    FreeGC(pBuffer->pSourceGC, (GContext) 0);
                if (pBuffer->pMaskGC)
                    FreeGC(pBuffer->pMaskGC, (GContext) 0);
                if (pBuffer->pSaveGC)
                    FreeGC(pBuffer->pSaveGC, (GContext) 0);
                if (pBuffer->pRestoreGC)
                    FreeGC(pBuffer->pRestoreGC, (GContext) 0);

                /* If a pRootPicture was allocated for a root window, it
                 * is freed when that root window is destroyed, so don't
                 * free it again here. */

                if (pBuffer->pSave)
                    (*pScreen->DestroyPixmap) (pBuffer->pSave);

                free(pBuffer);
                dixSetScreenPrivate(&pDev->devPrivates, miDCDeviceKey, pScreen,
                                    NULL);
            }
        }
    }
}
@


1.10
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@a48 1
#ifdef ARGB_CURSOR
a49 1
#endif
a68 1
#ifdef ARGB_CURSOR
a69 1
#endif
a84 1
#ifdef ARGB_CURSOR
a85 1
#endif
a129 1
#ifdef ARGB_CURSOR
a132 1
#endif
a156 1
#ifdef ARGB_CURSOR
a175 1
#endif
a187 2
#ifdef ARGB_CURSOR

d224 1
a224 1
#endif
a363 1
#ifdef ARGB_CURSOR
a374 1
#endif
a474 1
#ifdef ARGB_CURSOR
a475 1
#endif
a511 1
#ifdef ARGB_CURSOR
a514 1
#endif
@


1.9
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d81 1
a81 1
/* 
d83 1
a83 1
 * in the pCursorBuffers array. 
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d82 1
a82 1
 * The core pointer buffer will point to the index of the virtual core pointer
d117 1
a117 1
        free((pointer) pScreenPriv);
d155 1
a155 1
    free((pointer) pScreenPriv);
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a58 1
static DevScreenPrivateKeyRec miDCCursorBitsKeyRec;
a59 1
#define miDCCursorBitsKey (&miDCCursorBitsKeyRec)
d64 1
a64 1
static Bool miDCCloseScreen(int index, ScreenPtr pScreen);
a86 6
} miDCScreenRec, *miDCScreenPtr;

#define miGetDCScreen(s)	((miDCScreenPtr)(dixLookupPrivate(&(s)->devPrivates, miDCScreenKey)))

/* per-cursor per-screen private data */
typedef struct {
d92 4
a95 1
} miDCCursorRec, *miDCCursorPtr;
a102 2
        !dixRegisterScreenPrivateKey(&miDCCursorBitsKeyRec, pScreen,
                                     PRIVATE_CURSOR_BITS, 0) ||
d107 1
a107 1
    pScreenPriv = malloc(sizeof(miDCScreenRec));
d123 22
d146 1
a146 1
miDCCloseScreen(int index, ScreenPtr pScreen)
d153 2
d156 1
a156 1
    return (*pScreen->CloseScreen) (index, pScreen);
a161 3
    if (pCursor->bits->refcnt <= 1)
        dixSetScreenPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey,
                            pScreen, NULL);
a167 13
static VisualPtr
miDCGetWindowVisual(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    VisualID vid = wVisual(pWin);
    int i;

    for (i = 0; i < pScreen->numVisuals; i++)
        if (pScreen->visuals[i].vid == vid)
            return &pScreen->visuals[i];
    return 0;
}

a170 2
    ScreenPtr pScreen = pDraw->pScreen;
    VisualPtr pVisual;
d176 1
a176 4
    pVisual = miDCGetWindowVisual(pWin);
    if (!pVisual)
        return 0;
    pFormat = PictureMatchVisual(pScreen, pDraw->depth, pVisual);
d187 1
a187 1
static miDCCursorPtr
d190 1
a190 1
    miDCCursorPtr pPriv;
d193 4
a197 3
    pPriv = malloc(sizeof(miDCCursorRec));
    if (!pPriv)
        return NULL;
d199 1
d204 1
d207 2
a208 4
        if (!pFormat) {
            free((pointer) pPriv);
            return NULL;
        }
a209 2
        pPriv->sourceBits = 0;
        pPriv->maskBits = 0;
d213 3
a215 4
        if (!pPixmap) {
            free((pointer) pPriv);
            return NULL;
        }
d219 1
a219 2
            free((pointer) pPriv);
            return NULL;
d227 2
a228 2
        pPriv->pPicture = CreatePicture(0, &pPixmap->drawable,
                                        pFormat, 0, 0, serverClient, &error);
d230 5
a234 7
        if (!pPriv->pPicture) {
            free((pointer) pPriv);
            return NULL;
        }
        dixSetScreenPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey,
                            pScreen, pPriv);
        return pPriv;
a235 1
    pPriv->pPicture = 0;
d237 10
a246 14
    pPriv->sourceBits =
        (*pScreen->CreatePixmap) (pScreen, pCursor->bits->width,
                                  pCursor->bits->height, 1, 0);
    if (!pPriv->sourceBits) {
        free((pointer) pPriv);
        return NULL;
    }
    pPriv->maskBits =
        (*pScreen->CreatePixmap) (pScreen, pCursor->bits->width,
                                  pCursor->bits->height, 1, 0);
    if (!pPriv->maskBits) {
        (*pScreen->DestroyPixmap) (pPriv->sourceBits);
        free((pointer) pPriv);
        return NULL;
a247 2
    dixSetScreenPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey, pScreen,
                        pPriv);
d253 3
a255 2
        (void) miDCUnrealizeCursor(pScreen, pCursor);
        return NULL;
d258 2
a259 2
    ValidateGC((DrawablePtr) pPriv->sourceBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr) pPriv->sourceBits, pGC, 1,
d264 2
a265 2
    ValidateGC((DrawablePtr) pPriv->sourceBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr) pPriv->sourceBits, pGC, 1,
d272 2
a273 2
    ValidateGC((DrawablePtr) pPriv->maskBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr) pPriv->maskBits, pGC, 1,
d278 2
a279 2
    ValidateGC((DrawablePtr) pPriv->maskBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr) pPriv->maskBits, pGC, 1,
d283 3
a285 1
    return pPriv;
d291 1
a291 1
    miDCCursorPtr pPriv;
d293 2
a294 15
    pPriv = (miDCCursorPtr) dixLookupScreenPrivate(&pCursor->bits->devPrivates,
                                                   miDCCursorBitsKey, pScreen);
    if (pPriv && (pCursor->bits->refcnt <= 1)) {
        if (pPriv->sourceBits)
            (*pScreen->DestroyPixmap) (pPriv->sourceBits);
        if (pPriv->maskBits)
            (*pScreen->DestroyPixmap) (pPriv->maskBits);
#ifdef ARGB_CURSOR
        if (pPriv->pPicture)
            FreePicture(pPriv->pPicture, 0);
#endif
        free((pointer) pPriv);
        dixSetScreenPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey,
                            pScreen, NULL);
    }
a299 1
            miDCCursorPtr pPriv,
d306 1
d326 1
a326 1
    (*sourceGC->ops->PushPixels) (sourceGC, pPriv->sourceBits, pDrawable, w, h,
d344 1
a344 1
    (*maskGC->ops->PushPixels) (maskGC, pPriv->maskBits, pDrawable, w, h, x, y);
d366 1
a366 1
    miDCCursorPtr pPriv;
d370 2
a371 7
    pPriv = (miDCCursorPtr) dixLookupScreenPrivate(&pCursor->bits->devPrivates,
                                                   miDCCursorBitsKey, pScreen);
    if (!pPriv) {
        pPriv = miDCRealize(pScreen, pCursor);
        if (!pPriv)
            return FALSE;
    }
d377 1
a377 1
    if (pPriv->pPicture) {
d381 1
a381 1
                         pPriv->pPicture,
d390 1
a390 1
        miDCPutBits((DrawablePtr) pWin, pPriv,
@


1.6
log
@Update to xserver 1.11.2
@
text
@a6 1

d36 12
a47 12
# include   <X11/X.h>
# include   "misc.h"
# include   "input.h"
# include   "cursorstr.h"
# include   "windowstr.h"
# include   "regionstr.h"
# include   "dixstruct.h"
# include   "scrnintstr.h"
# include   "servermd.h"
# include   "mipointer.h"
# include   "misprite.h"
# include   "gcstruct.h"
d50 1
a50 1
# include   "picturestr.h"
d53 1
a53 1
# include "inputstr.h"
d57 1
d60 1
d63 1
d66 1
a66 1
static Bool	miDCCloseScreen(int index, ScreenPtr pScreen);
d70 3
a72 3
    GCPtr	    pSourceGC, pMaskGC;
    GCPtr	    pSaveGC, pRestoreGC;
    PixmapPtr	    pSave;
d74 1
a74 1
    PicturePtr	    pRootPicture;
d88 1
a88 1
    CloseScreenProcPtr	CloseScreen;
d95 2
a96 2
    PixmapPtr		sourceBits;	    /* source bits */
    PixmapPtr		maskBits;	    /* mask bits */
d98 1
a98 1
    PicturePtr		pPicture;
d103 1
a103 1
miDCInitialize (ScreenPtr pScreen, miPointerScreenFuncPtr screenFuncs)
d105 1
a105 1
    miDCScreenPtr   pScreenPriv;
d108 5
a112 3
        !dixRegisterScreenPrivateKey(&miDCCursorBitsKeyRec, pScreen, PRIVATE_CURSOR_BITS, 0) ||
        !dixRegisterScreenPrivateKey(&miDCDeviceKeyRec, pScreen, PRIVATE_DEVICE, 0))
	return FALSE;
d114 1
a114 1
    pScreenPriv = malloc(sizeof (miDCScreenRec));
d116 1
a116 1
	return FALSE;
d123 3
a125 4
    if (!miSpriteInitialize (pScreen, screenFuncs))
    {
	free((pointer) pScreenPriv);
	return FALSE;
d131 1
a131 1
miDCCloseScreen (int index, ScreenPtr pScreen)
d133 1
a133 1
    miDCScreenPtr   pScreenPriv;
d135 2
a136 2
    pScreenPriv = (miDCScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						  miDCScreenKey);
d143 1
a143 1
miDCRealizeCursor (ScreenPtr pScreen, CursorPtr pCursor)
d146 2
a147 1
	dixSetScreenPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey, pScreen, NULL);
d155 1
a155 1
miDCGetWindowVisual (WindowPtr pWin)
d157 3
a159 3
    ScreenPtr	    pScreen = pWin->drawable.pScreen;
    VisualID	    vid = wVisual (pWin);
    int		    i;
d162 2
a163 2
	if (pScreen->visuals[i].vid == vid)
	    return &pScreen->visuals[i];
d168 1
a168 1
miDCMakePicture (PicturePtr *ppPicture, DrawablePtr pDraw, WindowPtr pWin)
d170 8
a177 8
    ScreenPtr	    pScreen = pDraw->pScreen;
    VisualPtr	    pVisual;
    PictFormatPtr   pFormat;
    XID		    subwindow_mode = IncludeInferiors;
    PicturePtr	    pPicture;
    int		    error;
    
    pVisual = miDCGetWindowVisual (pWin);
d179 2
a180 2
	return 0;
    pFormat = PictureMatchVisual (pScreen, pDraw->depth, pVisual);
d182 4
a185 4
	return 0;
    pPicture = CreatePicture (0, pDraw, pFormat,
			      CPSubwindowMode, &subwindow_mode,
			      serverClient, &error);
d192 1
a192 1
miDCRealize (ScreenPtr pScreen, CursorPtr pCursor)
d194 3
a196 3
    miDCCursorPtr   pPriv;
    GCPtr	    pGC;
    ChangeGCVal	    gcvals;
d198 1
a198 1
    pPriv = malloc(sizeof (miDCCursorRec));
d200 1
a200 1
	return NULL;
d202 34
a235 38
    if (pCursor->bits->argb)
    {
	PixmapPtr	pPixmap;
	PictFormatPtr	pFormat;
	int		error;
	
	pFormat = PictureMatchFormat (pScreen, 32, PICT_a8r8g8b8);
	if (!pFormat)
	{
	    free((pointer) pPriv);
	    return NULL;
	}
	
	pPriv->sourceBits = 0;
	pPriv->maskBits = 0;
	pPixmap = (*pScreen->CreatePixmap) (pScreen, pCursor->bits->width,
					    pCursor->bits->height, 32,
					    CREATE_PIXMAP_USAGE_SCRATCH);
	if (!pPixmap)
	{
	    free((pointer) pPriv);
	    return NULL;
	}
	pGC = GetScratchGC (32, pScreen);
	if (!pGC)
	{
	    (*pScreen->DestroyPixmap) (pPixmap);
	    free((pointer) pPriv);
	    return NULL;
	}
	ValidateGC (&pPixmap->drawable, pGC);
	(*pGC->ops->PutImage) (&pPixmap->drawable, pGC, 32,
			       0, 0, pCursor->bits->width,
			       pCursor->bits->height,
			       0, ZPixmap, (char *) pCursor->bits->argb);
	FreeScratchGC (pGC);
	pPriv->pPicture = CreatePicture (0, &pPixmap->drawable,
					pFormat, 0, 0, serverClient, &error);
d237 7
a243 7
	if (!pPriv->pPicture)
	{
	    free((pointer) pPriv);
	    return NULL;
	}
	dixSetScreenPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey, pScreen, pPriv);
	return pPriv;
d247 14
a260 5
    pPriv->sourceBits = (*pScreen->CreatePixmap) (pScreen, pCursor->bits->width, pCursor->bits->height, 1, 0);
    if (!pPriv->sourceBits)
    {
	free((pointer) pPriv);
	return NULL;
d262 2
a263 8
    pPriv->maskBits =  (*pScreen->CreatePixmap) (pScreen, pCursor->bits->width, pCursor->bits->height, 1, 0);
    if (!pPriv->maskBits)
    {
	(*pScreen->DestroyPixmap) (pPriv->sourceBits);
	free((pointer) pPriv);
	return NULL;
    }
    dixSetScreenPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey, pScreen, pPriv);
d267 4
a270 5
    pGC = GetScratchGC (1, pScreen);
    if (!pGC)
    {
	(void) miDCUnrealizeCursor (pScreen, pCursor);
	return NULL;
d273 4
a276 4
    ValidateGC ((DrawablePtr)pPriv->sourceBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr)pPriv->sourceBits, pGC, 1,
			   0, 0, pCursor->bits->width, pCursor->bits->height,
 			   0, XYPixmap, (char *)pCursor->bits->source);
d278 5
a282 5
    ChangeGC (NullClient, pGC, GCFunction, &gcvals);
    ValidateGC ((DrawablePtr)pPriv->sourceBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr)pPriv->sourceBits, pGC, 1,
			   0, 0, pCursor->bits->width, pCursor->bits->height,
 			   0, XYPixmap, (char *)pCursor->bits->mask);
d286 5
a290 5
    ChangeGC (NullClient, pGC, GCFunction, &gcvals);
    ValidateGC ((DrawablePtr)pPriv->maskBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr)pPriv->maskBits, pGC, 1,
			   0, 0, pCursor->bits->width, pCursor->bits->height,
 			   0, XYPixmap, (char *)pCursor->bits->mask);
d292 6
a297 6
    ChangeGC (NullClient, pGC, GCFunction, &gcvals);
    ValidateGC ((DrawablePtr)pPriv->maskBits, pGC);
    (*pGC->ops->PutImage) ((DrawablePtr)pPriv->maskBits, pGC, 1,
			   0, 0, pCursor->bits->width, pCursor->bits->height,
 			   0, XYPixmap, (char *)pCursor->bits->source);
    FreeScratchGC (pGC);
d302 1
a302 1
miDCUnrealizeCursor (ScreenPtr pScreen, CursorPtr pCursor)
d304 1
a304 1
    miDCCursorPtr   pPriv;
d306 7
a312 8
    pPriv = (miDCCursorPtr)dixLookupScreenPrivate(&pCursor->bits->devPrivates,
						  miDCCursorBitsKey, pScreen);
    if (pPriv && (pCursor->bits->refcnt <= 1))
    {
	if (pPriv->sourceBits)
	    (*pScreen->DestroyPixmap) (pPriv->sourceBits);
	if (pPriv->maskBits)
	    (*pScreen->DestroyPixmap) (pPriv->maskBits);
d314 2
a315 2
	if (pPriv->pPicture)
	    FreePicture (pPriv->pPicture, 0);
d317 3
a319 2
	free((pointer) pPriv);
	dixSetScreenPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey, pScreen, NULL);
d325 7
a331 11
miDCPutBits (
    DrawablePtr	    pDrawable,
    miDCCursorPtr   pPriv,
    GCPtr	    sourceGC,
    GCPtr	    maskGC,
    int             x_org,
    int             y_org,
    unsigned        w,
    unsigned        h,
    unsigned long   source,
    unsigned long   mask)
d334 1
a334 1
    int     x, y;
d336 3
a338 4
    if (sourceGC->fgPixel != source)
    {
	gcval.val = source;
	ChangeGC (NullClient, sourceGC, GCForeground, &gcval);
d341 1
a341 1
	ValidateGC (pDrawable, sourceGC);
d343 1
a343 2
    if(sourceGC->miTranslate) 
    {
d346 2
a347 3
    } 
    else
    {
d352 5
a356 5
    (*sourceGC->ops->PushPixels) (sourceGC, pPriv->sourceBits, pDrawable, w, h, x, y);
    if (maskGC->fgPixel != mask)
    {
	gcval.val = mask;
	ChangeGC (NullClient, maskGC, GCForeground, &gcval);
d359 1
a359 1
	ValidateGC (pDrawable, maskGC);
d361 1
a361 2
    if(maskGC->miTranslate) 
    {
d364 2
a365 3
    } 
    else
    {
d377 2
a378 2
    int   status;
    XID   gcvals[2];
d382 3
a384 3
    pGC = CreateGC((DrawablePtr)pWin,
		   GCSubwindowMode|GCGraphicsExposures, gcvals, &status,
		   (XID)0, serverClient);
a387 1

d389 2
a390 2
miDCPutUpCursor (DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor,
                 int x, int y, unsigned long source, unsigned long mask)
d392 10
a401 11
    miDCCursorPtr   pPriv;
    miDCBufferPtr   pBuffer;
    WindowPtr	    pWin;

    pPriv = (miDCCursorPtr)dixLookupScreenPrivate(&pCursor->bits->devPrivates,
						  miDCCursorBitsKey, pScreen);
    if (!pPriv)
    {
	pPriv = miDCRealize(pScreen, pCursor);
	if (!pPriv)
	    return FALSE;
d408 9
a416 12
    if (pPriv->pPicture)
    {
	if (!EnsurePicture(pBuffer->pRootPicture, &pWin->drawable, pWin))
	    return FALSE;
	CompositePicture (PictOpOver,
			  pPriv->pPicture,
			  NULL,
			  pBuffer->pRootPicture,
			  0, 0, 0, 0, 
			  x, y, 
			  pCursor->bits->width,
			  pCursor->bits->height);
d421 4
a424 4
	miDCPutBits ((DrawablePtr)pWin, pPriv,
		     pBuffer->pSourceGC, pBuffer->pMaskGC,
		     x, y, pCursor->bits->width, pCursor->bits->height,
		     source, mask);
d430 2
a431 2
miDCSaveUnderCursor (DeviceIntPtr pDev, ScreenPtr pScreen,
                     int x, int y, int w, int h)
d433 4
a436 4
    miDCBufferPtr   pBuffer;
    PixmapPtr	    pSave;
    WindowPtr	    pWin;
    GCPtr	    pGC;
d442 7
a448 8
    if (!pSave || pSave->drawable.width < w || pSave->drawable.height < h)
    {
	if (pSave)
	    (*pScreen->DestroyPixmap) (pSave);
	pBuffer->pSave = pSave =
		(*pScreen->CreatePixmap) (pScreen, w, h, pScreen->rootDepth, 0);
	if (!pSave)
	    return FALSE;
d453 1
a453 1
	ValidateGC ((DrawablePtr) pSave, pGC);
d455 1
a455 1
			    x, y, w, h, 0, 0);
d460 2
a461 2
miDCRestoreUnderCursor (DeviceIntPtr pDev, ScreenPtr pScreen,
                        int x, int y, int w, int h)
d463 4
a466 4
    miDCBufferPtr   pBuffer;
    PixmapPtr	    pSave;
    WindowPtr	    pWin;
    GCPtr	    pGC;
d473 1
a473 1
	return FALSE;
d477 1
a477 1
	ValidateGC ((DrawablePtr) pWin, pGC);
d479 1
a479 1
			    0, 0, w, h, x, y);
d486 3
a488 3
    miDCBufferPtr   pBuffer;
    WindowPtr       pWin;
    int             i;
d493 1
a493 2
    for (i = 0; i < screenInfo.numScreens; i++)
    {
d500 2
a501 1
        dixSetScreenPrivate(&pDev->devPrivates, miDCDeviceKey, pScreen, pBuffer);
d530 1
a530 1
failure:
d540 2
a541 2
    miDCBufferPtr   pBuffer;
    int             i;
d543 2
a544 4
    if (DevHasCursor(pDev))
    {
        for (i = 0; i < screenInfo.numScreens; i++)
        {
d549 9
a557 6
            if (pBuffer)
            {
                if (pBuffer->pSourceGC) FreeGC(pBuffer->pSourceGC, (GContext) 0);
                if (pBuffer->pMaskGC) FreeGC(pBuffer->pMaskGC, (GContext) 0);
                if (pBuffer->pSaveGC) FreeGC(pBuffer->pSaveGC, (GContext) 0);
                if (pBuffer->pRestoreGC) FreeGC(pBuffer->pRestoreGC, (GContext) 0);
d565 2
a566 1
                if (pBuffer->pSave) (*pScreen->DestroyPixmap)(pBuffer->pSave);
d569 2
a570 1
                dixSetScreenPrivate(&pDev->devPrivates, miDCDeviceKey, pScreen, NULL);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d59 4
d78 2
a79 2
  (miDCBufferPtr)dixLookupPrivate(&dev->devPrivates, miDCDeviceKey(screen)) : \
  (miDCBufferPtr)dixLookupPrivate(&dev->u.master->devPrivates, miDCDeviceKey(screen)))
a86 2
    DevPrivateKey	device_key;
    DevPrivateKey	cursor_bits_key;
a89 2
#define miDCDeviceKey(s) 	(miGetDCScreen(s)->device_key)
#define miDCCursorBitsKey(s)	(miGetDCScreen(s)->cursor_bits_key)
d105 3
a107 1
    if (!dixRegisterPrivateKey(&miDCScreenKeyRec, PRIVATE_SCREEN, 0))
a113 6
    pScreenPriv->cursor_bits_key = dixCreatePrivateKey(PRIVATE_CURSOR_BITS, 0);
    pScreenPriv->device_key = dixCreatePrivateKey(PRIVATE_DEVICE, 0);
    if (!pScreenPriv->cursor_bits_key || !pScreenPriv->device_key) {
	free(pScreenPriv);
	return FALSE;
    }
d143 1
a143 1
	dixSetPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey(pScreen), NULL);
d242 1
a242 1
	dixSetPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey(pScreen), pPriv);
d260 1
a260 1
    dixSetPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey(pScreen), pPriv);
d304 2
a305 2
    pPriv = (miDCCursorPtr)dixLookupPrivate(&pCursor->bits->devPrivates,
					    miDCCursorBitsKey(pScreen));
d317 1
a317 1
	dixSetPrivate(&pCursor->bits->devPrivates, miDCCursorBitsKey(pScreen), NULL);
a399 1
    miDCScreenPtr   pScreenPriv;
d404 2
a405 2
    pPriv = (miDCCursorPtr)dixLookupPrivate(&pCursor->bits->devPrivates,
					    miDCCursorBitsKey(pScreen));
d412 1
a412 2
    pScreenPriv = (miDCScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						  miDCScreenKey);
a444 1
    miDCScreenPtr   pScreenPriv;
a449 2
    pScreenPriv = (miDCScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						  miDCScreenKey);
a475 1
    miDCScreenPtr   pScreenPriv;
a480 2
    pScreenPriv = (miDCScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						  miDCScreenKey);
d514 1
a514 1
        dixSetPrivate(&pDev->devPrivates, miDCDeviceKey(pScreen), pBuffer);
d580 1
a580 1
                dixSetPrivate(&pDev->devPrivates, miDCDeviceKey(pScreen), NULL);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d57 2
a58 2
static int miDCScreenKeyIndex;
static DevPrivateKey miDCScreenKey = &miDCScreenKeyIndex;
d62 1
a62 4
/* per device per-screen private data */
static int miDCSpriteKeyIndex[MAXSCREENS];
static DevPrivateKey miDCSpriteKey = miDCSpriteKeyIndex;

d66 1
a66 3
    GCPtr	    pMoveGC;
    GCPtr	    pPixSourceGC, pPixMaskGC;
    PixmapPtr	    pSave, pTemp;
a68 1
    PicturePtr	    pTempPicture;
d72 1
a72 1
#define MIDCBUFFER(dev, screen) \
d74 2
a75 2
  (miDCBufferPtr)dixLookupPrivate(&dev->devPrivates, miDCSpriteKey + (screen)->myNum) : \
  (miDCBufferPtr)dixLookupPrivate(&dev->u.master->devPrivates, miDCSpriteKey + (screen)->myNum))
d82 3
a84 1
    CloseScreenProcPtr CloseScreen;
d87 4
a99 38
/*
 * sprite/cursor method table
 */

static Bool	miDCRealizeCursor(ScreenPtr pScreen, CursorPtr pCursor);
static Bool	miDCUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor);
static Bool	miDCPutUpCursor(DeviceIntPtr pDev, ScreenPtr pScreen, 
                                CursorPtr pCursor, int x, int y, 
                                unsigned long source, unsigned long mask);
static Bool	miDCSaveUnderCursor(DeviceIntPtr pDev, ScreenPtr pScreen, 
                                    int x, int y,
				    int w, int h);
static Bool	miDCRestoreUnderCursor(DeviceIntPtr pDev, ScreenPtr pScreen, 
                                       int x, int y,
				       int w, int h);
static Bool	miDCMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen, 
                               CursorPtr pCursor, int x, int y, 
                               int w, int h, int dx, int dy,
			       unsigned long source, unsigned long mask);
static Bool	miDCChangeSave(DeviceIntPtr pDev, ScreenPtr pScreen, 
                               int x, int y, int w, int h,	
                               int dx, int dy);

static Bool     miDCDeviceInitialize(DeviceIntPtr pDev, ScreenPtr pScreen);
static void     miDCDeviceCleanup(DeviceIntPtr pDev, ScreenPtr pScreen);

static miSpriteCursorFuncRec miDCFuncs = {
    miDCRealizeCursor,
    miDCUnrealizeCursor,
    miDCPutUpCursor,
    miDCSaveUnderCursor,
    miDCRestoreUnderCursor,
    miDCMoveCursor,
    miDCChangeSave,
    miDCDeviceInitialize,
    miDCDeviceCleanup
};

d105 4
a108 1
    pScreenPriv = xalloc (sizeof (miDCScreenRec));
d112 6
a117 1

d123 1
a123 1
    if (!miSpriteInitialize (pScreen, &miDCFuncs, screenFuncs))
d125 1
a125 1
	xfree ((pointer) pScreenPriv);
d139 1
a139 1
    xfree ((pointer) pScreenPriv);
d143 1
a143 1
static Bool
d147 1
a147 1
	dixSetPrivate(&pCursor->bits->devPrivates, CursorScreenKey(pScreen), NULL);
d196 1
a196 1
    XID		    gcvals[3];
d198 1
a198 1
    pPriv = xalloc (sizeof (miDCCursorRec));
d211 1
a211 1
	    xfree ((pointer) pPriv);
d222 1
a222 1
	    xfree ((pointer) pPriv);
d229 1
a229 1
	    xfree ((pointer) pPriv);
d243 1
a243 1
	    xfree ((pointer) pPriv);
d246 1
a246 1
	dixSetPrivate(&pCursor->bits->devPrivates, CursorScreenKey(pScreen), pPriv);
d254 1
a254 1
	xfree ((pointer) pPriv);
d261 1
a261 1
	xfree ((pointer) pPriv);
d264 1
a264 1
    dixSetPrivate(&pCursor->bits->devPrivates, CursorScreenKey(pScreen), pPriv);
d279 2
a280 2
    gcvals[0] = GXand;
    ChangeGC (pGC, GCFunction, gcvals);
d287 2
a288 2
    gcvals[0] = GXcopy;
    ChangeGC (pGC, GCFunction, gcvals);
d293 2
a294 2
    gcvals[0] = GXandInverted;
    ChangeGC (pGC, GCFunction, gcvals);
d303 1
a303 1
static Bool
d309 1
a309 1
					    CursorScreenKey(pScreen));
d320 2
a321 2
	xfree ((pointer) pPriv);
	dixSetPrivate(&pCursor->bits->devPrivates, CursorScreenKey(pScreen), NULL);
d339 1
a339 1
    XID	    gcvals[1];
d344 2
a345 2
	gcvals[0] = source;
	DoChangeGC (sourceGC, GCForeground, gcvals, 0);
d364 2
a365 2
	gcvals[0] = mask;
	DoChangeGC (maskGC, GCForeground, gcvals, 0);
d400 1
a400 1
static Bool
d410 1
a410 1
					    CursorScreenKey(pScreen));
d419 2
a420 2
    pWin = WindowTable[pScreen->myNum];
    pBuffer = MIDCBUFFER(pDev, pScreen);
d447 1
a447 1
static Bool
d459 1
a459 1
    pBuffer = MIDCBUFFER(pDev, pScreen);
d462 1
a462 1
    pWin = WindowTable[pScreen->myNum];
d481 1
a481 1
static Bool
d493 1
a493 1
    pBuffer = MIDCBUFFER(pDev, pScreen);
d496 1
a496 1
    pWin = WindowTable[pScreen->myNum];
d508 1
a508 232
static Bool
miDCChangeSave (DeviceIntPtr pDev, ScreenPtr pScreen,
                int x, int y, int w, int h, int dx, int dy)
{
    miDCScreenPtr   pScreenPriv;
    miDCBufferPtr   pBuffer;
    PixmapPtr	    pSave;
    WindowPtr	    pWin;
    GCPtr	    pGC;
    int		    sourcex, sourcey, destx, desty, copyw, copyh;

    pScreenPriv = (miDCScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						  miDCScreenKey);
    pBuffer = MIDCBUFFER(pDev, pScreen);

    pSave = pBuffer->pSave;
    pWin = WindowTable[pScreen->myNum];
    /*
     * restore the bits which are about to get trashed
     */
    if (!pSave)
	return FALSE;

    pGC = pBuffer->pRestoreGC;
    if (pWin->drawable.serialNumber != pGC->serialNumber)
	ValidateGC ((DrawablePtr) pWin, pGC);
    /*
     * copy the old bits to the screen.
     */
    if (dy > 0)
    {
	(*pGC->ops->CopyArea) ((DrawablePtr) pSave, (DrawablePtr) pWin, pGC,
			       0, h - dy, w, dy, x + dx, y + h);
    }
    else if (dy < 0)
    {
	(*pGC->ops->CopyArea) ((DrawablePtr) pSave, (DrawablePtr) pWin, pGC,
			       0, 0, w, -dy, x + dx, y + dy);
    }
    if (dy >= 0)
    {
	desty = y + dy;
	sourcey = 0;
	copyh = h - dy;
    }
    else
    {
	desty = y;
	sourcey = - dy;
	copyh = h + dy;
    }
    if (dx > 0)
    {
	(*pGC->ops->CopyArea) ((DrawablePtr) pSave, (DrawablePtr) pWin, pGC,
			       w - dx, sourcey, dx, copyh, x + w, desty);
    }
    else if (dx < 0)
    {
	(*pGC->ops->CopyArea) ((DrawablePtr) pSave, (DrawablePtr) pWin, pGC,
			       0, sourcey, -dx, copyh, x + dx, desty);
    }

    pGC = pBuffer->pSaveGC;
    if (pSave->drawable.serialNumber != pGC->serialNumber)
	ValidateGC ((DrawablePtr) pSave, pGC);
    /*
     * move the bits that are still valid within the pixmap
     */
    if (dx >= 0)
    {
	sourcex = 0;
	destx = dx;
	copyw = w - dx;
    }
    else
    {
	destx = 0;
	sourcex = - dx;
	copyw = w + dx;
    }
    if (dy >= 0)
    {
	sourcey = 0;
	desty = dy;
	copyh = h - dy;
    }
    else
    {
	desty = 0;
	sourcey = -dy;
	copyh = h + dy;
    }
    (*pGC->ops->CopyArea) ((DrawablePtr) pSave, (DrawablePtr) pSave, pGC,
			   sourcex, sourcey, copyw, copyh, destx, desty);
    /*
     * copy the new bits from the screen into the remaining areas of the
     * pixmap
     */
    if (dy > 0)
    {
	(*pGC->ops->CopyArea) ((DrawablePtr) pWin, (DrawablePtr) pSave, pGC,
			       x, y, w, dy, 0, 0);
    }
    else if (dy < 0)
    {
	(*pGC->ops->CopyArea) ((DrawablePtr) pWin, (DrawablePtr) pSave, pGC,
			       x, y + h + dy, w, -dy, 0, h + dy);
    }
    if (dy >= 0)
    {
	desty = dy;
	sourcey = y + dy;
	copyh = h - dy;
    }
    else
    {
	desty = 0;
	sourcey = y;
	copyh = h + dy;
    }
    if (dx > 0)
    {
	(*pGC->ops->CopyArea) ((DrawablePtr) pWin, (DrawablePtr) pSave, pGC,
			       x, sourcey, dx, copyh, 0, desty);
    }
    else if (dx < 0)
    {
	(*pGC->ops->CopyArea) ((DrawablePtr) pWin, (DrawablePtr) pSave, pGC,
			       x + w + dx, sourcey, -dx, copyh, w + dx, desty);
    }
    return TRUE;
}

static Bool
miDCMoveCursor (DeviceIntPtr pDev, ScreenPtr pScreen, CursorPtr pCursor,
                int x, int y, int w, int h, int dx, int dy,
                unsigned long source, unsigned long mask)
{
    miDCCursorPtr   pPriv;
    miDCScreenPtr   pScreenPriv;
    miDCBufferPtr   pBuffer;
    int		    status;
    WindowPtr	    pWin;
    GCPtr	    pGC;
    XID		    gcval = FALSE;
    PixmapPtr	    pTemp;

    pPriv = (miDCCursorPtr)dixLookupPrivate(&pCursor->bits->devPrivates,
					    CursorScreenKey(pScreen));
    if (!pPriv)
    {
	pPriv = miDCRealize(pScreen, pCursor);
	if (!pPriv)
	    return FALSE;
    }
    pScreenPriv = (miDCScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						  miDCScreenKey);
    pWin = WindowTable[pScreen->myNum];
    pBuffer = MIDCBUFFER(pDev, pScreen);

    pTemp = pBuffer->pTemp;
    if (!pTemp ||
	pTemp->drawable.width != pBuffer->pSave->drawable.width ||
	pTemp->drawable.height != pBuffer->pSave->drawable.height)
    {
	if (pTemp)
	    (*pScreen->DestroyPixmap) (pTemp);
#ifdef ARGB_CURSOR
	if (pBuffer->pTempPicture)
	{
	    FreePicture (pBuffer->pTempPicture, 0);
	    pBuffer->pTempPicture = 0;
	}
#endif
	pBuffer->pTemp = pTemp = (*pScreen->CreatePixmap)
	    (pScreen, w, h, pBuffer->pSave->drawable.depth, 0);
	if (!pTemp)
	    return FALSE;
    }
    if (!pBuffer->pMoveGC)
    {
	pBuffer->pMoveGC = CreateGC ((DrawablePtr)pTemp,
	    GCGraphicsExposures, &gcval, &status, (XID)0, serverClient);
	if (!pBuffer->pMoveGC)
	    return FALSE;
    }
    /*
     * copy the saved area to a temporary pixmap
     */
    pGC = pBuffer->pMoveGC;
    if (pGC->serialNumber != pTemp->drawable.serialNumber)
	ValidateGC ((DrawablePtr) pTemp, pGC);
    (*pGC->ops->CopyArea)((DrawablePtr)pBuffer->pSave,
			  (DrawablePtr)pTemp, pGC, 0, 0, w, h, 0, 0);
    
    /*
     * draw the cursor in the temporary pixmap
     */
#ifdef ARGB_CURSOR
    if (pPriv->pPicture)
    {
	if (!EnsurePicture(pBuffer->pTempPicture, &pTemp->drawable, pWin))
	    return FALSE;
	CompositePicture (PictOpOver,
			  pPriv->pPicture,
			  NULL,
			  pBuffer->pTempPicture,
			  0, 0, 0, 0, 
			  dx, dy, 
			  pCursor->bits->width,
			  pCursor->bits->height);
    }
    else
#endif
    {
	miDCPutBits ((DrawablePtr)pTemp, pPriv,
		     pBuffer->pPixSourceGC, pBuffer->pPixMaskGC,
		     dx, dy, pCursor->bits->width, pCursor->bits->height,
		     source, mask);
    }

    pGC = pBuffer->pRestoreGC;
    if (pWin->drawable.serialNumber != pGC->serialNumber)
	ValidateGC ((DrawablePtr) pWin, pGC);

    (*pGC->ops->CopyArea) ((DrawablePtr) pTemp, (DrawablePtr) pWin,
			    pGC,
			    0, 0, w, h, x, y);
    return TRUE;
}

static Bool
a512 2
    XID             gcval = FALSE;
    int             status;
d522 1
a522 1
        pBuffer = xcalloc(1, sizeof(miDCBufferRec));
d526 2
a527 2
        dixSetPrivate(&pDev->devPrivates, miDCSpriteKey + pScreen->myNum, pBuffer);
        pWin = WindowTable[pScreen->myNum];
a544 15
        pBuffer->pMoveGC = CreateGC ((DrawablePtr)pWin,
            GCGraphicsExposures, &gcval, &status, (XID)0, serverClient);
        if (!pBuffer->pMoveGC)
            goto failure;

        pBuffer->pPixSourceGC = CreateGC ((DrawablePtr)pWin,
            GCGraphicsExposures, &gcval, &status, (XID)0, serverClient);
        if (!pBuffer->pPixSourceGC)
            goto failure;

        pBuffer->pPixMaskGC = CreateGC ((DrawablePtr)pWin,
            GCGraphicsExposures, &gcval, &status, (XID)0, serverClient);
        if (!pBuffer->pPixMaskGC)
            goto failure;

a546 1
        pBuffer->pTempPicture = NULL;
d549 2
a550 2
        // these get (re)allocated lazily depending on the cursor size
        pBuffer->pSave = pBuffer->pTemp = NULL;
d562 1
a562 1
static void
d574 1
a574 1
            pBuffer = MIDCBUFFER(pDev, pScreen);
d582 6
a587 3
                if (pBuffer->pMoveGC) FreeGC(pBuffer->pMoveGC, (GContext) 0);
                if (pBuffer->pPixSourceGC) FreeGC(pBuffer->pPixSourceGC, (GContext) 0);
                if (pBuffer->pPixMaskGC) FreeGC(pBuffer->pPixMaskGC, (GContext) 0);
a589 1
                if (pBuffer->pTemp) (*pScreen->DestroyPixmap)(pBuffer->pTemp);
d591 2
a592 2
                xfree(pBuffer);
                dixSetPrivate(&pDev->devPrivates, miDCSpriteKey + pScreen->myNum, NULL);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a36 1
#define NEED_EVENTS
d54 1
a54 1
# include "inputstr.h" /* for MAX_DEVICES */
d62 3
a64 3
/* per device private data */
static int miDCSpriteKeyIndex;
static DevPrivateKey miDCSpriteKey = &miDCSpriteKeyIndex;
d78 1
a78 1
#define MIDCBUFFER(dev) \
d80 2
a81 2
  (miDCBufferPtr)dixLookupPrivate(&dev->devPrivates, miDCSpriteKey) : \
  (miDCBufferPtr)dixLookupPrivate(&dev->u.master->devPrivates, miDCSpriteKey))
d138 1
a138 1
_X_EXPORT Bool
d143 1
a143 1
    pScreenPriv = (miDCScreenPtr) xalloc (sizeof (miDCScreenRec));
a160 4
#define tossGC(gc)  (gc ? FreeGC (gc, (GContext) 0) : 0)
#define tossPix(pix)	(pix ? (*pScreen->DestroyPixmap) (pix) : TRUE)
#define tossPict(pict)	(pict ? FreePicture (pict, 0) : 0)

d228 1
a228 1
    pPriv = (miDCCursorPtr) xalloc (sizeof (miDCCursorRec));
d230 1
a230 1
	return (miDCCursorPtr)NULL;
d242 1
a242 1
	    return (miDCCursorPtr)NULL;
d253 1
a253 1
	    return (miDCCursorPtr)NULL;
d260 1
a260 1
	    return (miDCCursorPtr)NULL;
d274 1
a274 1
	    return (miDCCursorPtr)NULL;
d285 1
a285 1
	return (miDCCursorPtr)NULL;
d292 1
a292 1
	return (miDCCursorPtr)NULL;
d302 1
a302 1
	return (miDCCursorPtr)NULL;
a413 2
#define EnsureGC(gc,win) (gc || miDCMakeGC(&gc, win))

d415 1
a415 3
miDCMakeGC(
    GCPtr	*ppGC,
    WindowPtr	pWin)
a425 1
    *ppGC = pGC;
d450 1
a450 1
    pBuffer = MIDCBUFFER(pDev);
a454 9
        /* see comment in miDCPutUpCursor */
        if (pBuffer->pRootPicture && 
                pBuffer->pRootPicture->pDrawable &&
                pBuffer->pRootPicture->pDrawable->pScreen != pScreen)
        {
            tossPict(pBuffer->pRootPicture);
            pBuffer->pRootPicture = NULL;
        }

a468 27
        /**
         * XXX: Before MPX, the sourceGC and maskGC were attached to the
         * screen, and would switch as the screen switches.  With mpx we have
         * the GC's attached to the device now, so each time we switch screen
         * we need to make sure the GC's are allocated on the new screen.
         * This is ... not optimal. (whot)
         */
        if (pBuffer->pSourceGC && pScreen != pBuffer->pSourceGC->pScreen)
        {
            tossGC(pBuffer->pSourceGC);
            pBuffer->pSourceGC = NULL;
        }

        if (pBuffer->pMaskGC && pScreen != pBuffer->pMaskGC->pScreen)
        {
            tossGC(pBuffer->pMaskGC);
            pBuffer->pMaskGC = NULL;
        }

	if (!EnsureGC(pBuffer->pSourceGC, pWin))
	    return FALSE;
	if (!EnsureGC(pBuffer->pMaskGC, pWin))
	{
	    FreeGC (pBuffer->pSourceGC, (GContext) 0);
	    pBuffer->pSourceGC = 0;
	    return FALSE;
	}
d489 1
a489 1
    pBuffer = MIDCBUFFER(pDev);
d502 1
a502 8
    /* see comment in miDCPutUpCursor */
    if (pBuffer->pSaveGC && pBuffer->pSaveGC->pScreen != pScreen)
    {
        tossGC(pBuffer->pSaveGC);
        pBuffer->pSaveGC = NULL;
    }
    if (!EnsureGC(pBuffer->pSaveGC, pWin))
	return FALSE;
d523 1
a523 1
    pBuffer = MIDCBUFFER(pDev);
d529 1
a529 8
    /* see comment in miDCPutUpCursor */
    if (pBuffer->pRestoreGC && pBuffer->pRestoreGC->pScreen != pScreen)
    {
        tossGC(pBuffer->pRestoreGC);
        pBuffer->pRestoreGC = NULL;
    }
    if (!EnsureGC(pBuffer->pRestoreGC, pWin))
	return FALSE;
d551 1
a551 1
    pBuffer = MIDCBUFFER(pDev);
d560 1
a560 8
    /* see comment in miDCPutUpCursor */
    if (pBuffer->pRestoreGC && pBuffer->pRestoreGC->pScreen != pScreen)
    {
        tossGC(pBuffer->pRestoreGC);
        pBuffer->pRestoreGC = NULL;
    }
    if (!EnsureGC(pBuffer->pRestoreGC, pWin))
	return FALSE;
d599 1
a599 8
    /* see comment in miDCPutUpCursor */
    if (pBuffer->pSaveGC && pBuffer->pSaveGC->pScreen != pScreen)
    {
        tossGC(pBuffer->pSaveGC);
        pBuffer->pSaveGC = NULL;
    }
    if (!EnsureGC(pBuffer->pSaveGC, pWin))
	return FALSE;
d696 1
a696 1
    pBuffer = MIDCBUFFER(pDev);
a738 9
        /* see comment in miDCPutUpCursor */
        if (pBuffer->pTempPicture && 
                pBuffer->pTempPicture->pDrawable &&
                pBuffer->pTempPicture->pDrawable->pScreen != pScreen)
        {
            tossPict(pBuffer->pTempPicture);
            pBuffer->pTempPicture = NULL;
        }

a752 14
	if (!pBuffer->pPixSourceGC)
	{
	    pBuffer->pPixSourceGC = CreateGC ((DrawablePtr)pTemp,
		GCGraphicsExposures, &gcval, &status, (XID)0, serverClient);
	    if (!pBuffer->pPixSourceGC)
		return FALSE;
	}
	if (!pBuffer->pPixMaskGC)
	{
	    pBuffer->pPixMaskGC = CreateGC ((DrawablePtr)pTemp,
		GCGraphicsExposures, &gcval, &status, (XID)0, serverClient);
	    if (!pBuffer->pPixMaskGC)
		return FALSE;
	}
a758 12
    /* see comment in miDCPutUpCursor */
    if (pBuffer->pRestoreGC && pBuffer->pRestoreGC->pScreen != pScreen)
    {
        tossGC(pBuffer->pRestoreGC);
        pBuffer->pRestoreGC = NULL;
    }
    /*
     * copy the temporary pixmap onto the screen
     */

    if (!EnsureGC(pBuffer->pRestoreGC, pWin))
	return FALSE;
d772 23
a794 1
    miDCBufferPtr pBuffer;
d796 26
a821 2
    pBuffer = xalloc(sizeof(miDCBufferRec));
    dixSetPrivate(&pDev->devPrivates, miDCSpriteKey, pBuffer);
a822 7
    pBuffer->pSourceGC =
        pBuffer->pMaskGC =
        pBuffer->pSaveGC =
        pBuffer->pRestoreGC =
        pBuffer->pMoveGC =
        pBuffer->pPixSourceGC =
        pBuffer->pPixMaskGC = NULL;
d824 2
a825 2
    pBuffer->pRootPicture = NULL;
    pBuffer->pTempPicture = NULL;
d827 4
a830 1
    pBuffer->pSave = pBuffer->pTemp = NULL;
d833 6
d845 1
d849 23
a871 18
        pBuffer = MIDCBUFFER(pDev);
        tossGC (pBuffer->pSourceGC);
        tossGC (pBuffer->pMaskGC);
        tossGC (pBuffer->pSaveGC);
        tossGC (pBuffer->pRestoreGC);
        tossGC (pBuffer->pMoveGC);
        tossGC (pBuffer->pPixSourceGC);
        tossGC (pBuffer->pPixMaskGC);
        tossPix (pBuffer->pSave);
        tossPix (pBuffer->pTemp);
#ifdef ARGB_CURSOR
#if 0				/* This has been free()d before */
        tossPict (pScreenPriv->pRootPicture);
#endif 
        tossPict (pBuffer->pTempPicture);
#endif
        xfree(pBuffer);
        dixSetPrivate(&pDev->devPrivates, miDCSpriteKey, NULL);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d55 2
d58 2
d61 1
a61 1
static DevPrivateKey miDCScreenKey = &miDCScreenKey;
d63 3
a65 1
static Bool	miDCCloseScreen(int index, ScreenPtr pScreen);
a71 1
    CloseScreenProcPtr CloseScreen;
d77 13
d107 5
a111 4
static Bool	miDCPutUpCursor(ScreenPtr pScreen, CursorPtr pCursor,
				int x, int y, unsigned long source,
				unsigned long mask);
static Bool	miDCSaveUnderCursor(ScreenPtr pScreen, int x, int y,
d113 2
a114 1
static Bool	miDCRestoreUnderCursor(ScreenPtr pScreen, int x, int y,
d116 3
a118 2
static Bool	miDCMoveCursor(ScreenPtr pScreen, CursorPtr pCursor,
			       int x, int y, int w, int h, int dx, int dy,
d120 6
a125 2
static Bool	miDCChangeSave(ScreenPtr pScreen, int x, int y, int w, int h,	
			       int dx, int dy);
d135 2
d140 1
a140 3
miDCInitialize (pScreen, screenFuncs)
    ScreenPtr		    pScreen;
    miPointerScreenFuncPtr  screenFuncs;
a147 17
    /*
     * initialize the entire private structure to zeros
     */

    pScreenPriv->pSourceGC =
	pScreenPriv->pMaskGC =
	pScreenPriv->pSaveGC =
 	pScreenPriv->pRestoreGC =
 	pScreenPriv->pMoveGC =
 	pScreenPriv->pPixSourceGC =
	pScreenPriv->pPixMaskGC = NULL;
#ifdef ARGB_CURSOR
    pScreenPriv->pRootPicture = NULL;
    pScreenPriv->pTempPicture = NULL;
#endif
    
    pScreenPriv->pSave = pScreenPriv->pTemp = NULL;
d151 1
a151 1
    
d167 1
a167 3
miDCCloseScreen (index, pScreen)
    int		index;
    ScreenPtr	pScreen;
a173 12
    tossGC (pScreenPriv->pSourceGC);
    tossGC (pScreenPriv->pMaskGC);
    tossGC (pScreenPriv->pSaveGC);
    tossGC (pScreenPriv->pRestoreGC);
    tossGC (pScreenPriv->pMoveGC);
    tossGC (pScreenPriv->pPixSourceGC);
    tossGC (pScreenPriv->pPixMaskGC);
    tossPix (pScreenPriv->pSave);
    tossPix (pScreenPriv->pTemp);
#ifdef ARGB_CURSOR
    tossPict (pScreenPriv->pTempPicture);
#endif
d179 1
a179 3
miDCRealizeCursor (pScreen, pCursor)
    ScreenPtr	pScreen;
    CursorPtr	pCursor;
d182 1
a182 1
	dixSetPrivate(&pCursor->bits->devPrivates, pScreen, NULL);
d227 1
a227 3
miDCRealize (
    ScreenPtr	pScreen,
    CursorPtr	pCursor)
d281 1
a281 1
	dixSetPrivate(&pCursor->bits->devPrivates, pScreen, pPriv);
d299 1
a299 1
    dixSetPrivate(&pCursor->bits->devPrivates, pScreen, pPriv);
d339 1
a339 3
miDCUnrealizeCursor (pScreen, pCursor)
    ScreenPtr	pScreen;
    CursorPtr	pCursor;
d344 1
a344 1
					    pScreen);
d356 1
a356 1
	dixSetPrivate(&pCursor->bits->devPrivates, pScreen, NULL);
d441 2
a442 5
miDCPutUpCursor (pScreen, pCursor, x, y, source, mask)
    ScreenPtr	    pScreen;
    CursorPtr	    pCursor;
    int		    x, y;
    unsigned long   source, mask;
d446 1
d450 1
a450 1
					    pScreen);
d460 2
d465 10
a474 1
	if (!EnsurePicture(pScreenPriv->pRootPicture, &pWin->drawable, pWin))
d479 1
a479 1
			  pScreenPriv->pRootPicture,
d488 20
a507 1
	if (!EnsureGC(pScreenPriv->pSourceGC, pWin))
d509 1
a509 1
	if (!EnsureGC(pScreenPriv->pMaskGC, pWin))
d511 2
a512 2
	    FreeGC (pScreenPriv->pSourceGC, (GContext) 0);
	    pScreenPriv->pSourceGC = 0;
d516 1
a516 1
		     pScreenPriv->pSourceGC, pScreenPriv->pMaskGC,
d524 2
a525 3
miDCSaveUnderCursor (pScreen, x, y, w, h)
    ScreenPtr	pScreen;
    int		x, y, w, h;
d528 1
d535 3
a537 1
    pSave = pScreenPriv->pSave;
d543 1
a543 1
	pScreenPriv->pSave = pSave =
d548 7
a554 1
    if (!EnsureGC(pScreenPriv->pSaveGC, pWin))
d556 1
a556 1
    pGC = pScreenPriv->pSaveGC;
d565 2
a566 3
miDCRestoreUnderCursor (pScreen, x, y, w, h)
    ScreenPtr	pScreen;
    int		x, y, w, h;
d569 1
d576 3
a578 1
    pSave = pScreenPriv->pSave;
d582 7
a588 1
    if (!EnsureGC(pScreenPriv->pRestoreGC, pWin))
d590 1
a590 1
    pGC = pScreenPriv->pRestoreGC;
d599 2
a600 3
miDCChangeSave (pScreen, x, y, w, h, dx, dy)
    ScreenPtr	    pScreen;
    int		    x, y, w, h, dx, dy;
d603 1
d611 3
a613 1
    pSave = pScreenPriv->pSave;
d620 7
a626 1
    if (!EnsureGC(pScreenPriv->pRestoreGC, pWin))
d628 1
a628 1
    pGC = pScreenPriv->pRestoreGC;
d666 7
a672 1
    if (!EnsureGC(pScreenPriv->pSaveGC, pWin))
d674 1
a674 1
    pGC = pScreenPriv->pSaveGC;
d746 3
a748 5
miDCMoveCursor (pScreen, pCursor, x, y, w, h, dx, dy, source, mask)
    ScreenPtr	    pScreen;
    CursorPtr	    pCursor;
    int		    x, y, w, h, dx, dy;
    unsigned long   source, mask;
d752 1
d760 1
a760 1
					    pScreen);
d770 3
a772 1
    pTemp = pScreenPriv->pTemp;
d774 2
a775 2
	pTemp->drawable.width != pScreenPriv->pSave->drawable.width ||
	pTemp->drawable.height != pScreenPriv->pSave->drawable.height)
d780 1
a780 1
	if (pScreenPriv->pTempPicture)
d782 2
a783 2
	    FreePicture (pScreenPriv->pTempPicture, 0);
	    pScreenPriv->pTempPicture = 0;
d786 2
a787 2
	pScreenPriv->pTemp = pTemp = (*pScreen->CreatePixmap)
	    (pScreen, w, h, pScreenPriv->pSave->drawable.depth, 0);
d791 1
a791 1
    if (!pScreenPriv->pMoveGC)
d793 1
a793 1
	pScreenPriv->pMoveGC = CreateGC ((DrawablePtr)pTemp,
d795 1
a795 1
	if (!pScreenPriv->pMoveGC)
d801 1
a801 1
    pGC = pScreenPriv->pMoveGC;
d804 1
a804 1
    (*pGC->ops->CopyArea)((DrawablePtr)pScreenPriv->pSave,
d813 10
a822 1
	if (!EnsurePicture(pScreenPriv->pTempPicture, &pTemp->drawable, pWin))
d827 1
a827 1
			  pScreenPriv->pTempPicture,
d836 1
a836 1
	if (!pScreenPriv->pPixSourceGC)
d838 1
a838 1
	    pScreenPriv->pPixSourceGC = CreateGC ((DrawablePtr)pTemp,
d840 1
a840 1
	    if (!pScreenPriv->pPixSourceGC)
d843 1
a843 1
	if (!pScreenPriv->pPixMaskGC)
d845 1
a845 1
	    pScreenPriv->pPixMaskGC = CreateGC ((DrawablePtr)pTemp,
d847 1
a847 1
	    if (!pScreenPriv->pPixMaskGC)
d851 1
a851 1
		     pScreenPriv->pPixSourceGC, pScreenPriv->pPixMaskGC,
d856 6
d866 1
a866 1
    if (!EnsureGC(pScreenPriv->pRestoreGC, pWin))
d868 1
a868 1
    pGC = pScreenPriv->pRestoreGC;
d876 52
@


1.1
log
@Initial revision
@
text
@d57 1
a57 2
static int	miDCScreenIndex;
static unsigned long miDCGeneration = 0;
a118 7
    if (miDCGeneration != serverGeneration)
    {
	miDCScreenIndex = AllocateScreenPrivateIndex ();
	if (miDCScreenIndex < 0)
	    return FALSE;
	miDCGeneration = serverGeneration;
    }
d144 1
a144 1
    pScreen->devPrivates[miDCScreenIndex].ptr = (pointer) pScreenPriv;
d165 2
a166 1
    pScreenPriv = (miDCScreenPtr) pScreen->devPrivates[miDCScreenIndex].ptr;
a177 3
#if 0				/* This has been free()d before */
    tossPict (pScreenPriv->pRootPicture);
#endif 
d190 1
a190 1
	pCursor->bits->devPriv[pScreen->myNum] = (pointer)NULL;
d263 2
a264 1
					    pCursor->bits->height, 32);
d291 1
a291 1
	pCursor->bits->devPriv[pScreen->myNum] = (pointer) pPriv;
d296 1
a296 1
    pPriv->sourceBits = (*pScreen->CreatePixmap) (pScreen, pCursor->bits->width, pCursor->bits->height, 1);
d302 1
a302 1
    pPriv->maskBits =  (*pScreen->CreatePixmap) (pScreen, pCursor->bits->width, pCursor->bits->height, 1);
d309 1
a309 1
    pCursor->bits->devPriv[pScreen->myNum] = (pointer) pPriv;
d355 2
a356 1
    pPriv = (miDCCursorPtr) pCursor->bits->devPriv[pScreen->myNum];
d368 1
a368 1
	pCursor->bits->devPriv[pScreen->myNum] = (pointer)NULL;
d445 2
a446 3
		   GCSubwindowMode|GCGraphicsExposures, gcvals, &status);
    if (pGC && pWin->drawable.pScreen->DrawGuarantee)
	(*pWin->drawable.pScreen->DrawGuarantee) (pWin, pGC, GuaranteeVisBack);
d463 2
a464 1
    pPriv = (miDCCursorPtr) pCursor->bits->devPriv[pScreen->myNum];
d471 2
a472 1
    pScreenPriv = (miDCScreenPtr) pScreen->devPrivates[miDCScreenIndex].ptr;
d517 2
a518 1
    pScreenPriv = (miDCScreenPtr) pScreen->devPrivates[miDCScreenIndex].ptr;
d526 1
a526 1
		(*pScreen->CreatePixmap) (pScreen, w, h, pScreen->rootDepth);
d550 2
a551 1
    pScreenPriv = (miDCScreenPtr) pScreen->devPrivates[miDCScreenIndex].ptr;
d577 2
a578 1
    pScreenPriv = (miDCScreenPtr) pScreen->devPrivates[miDCScreenIndex].ptr;
d714 2
a715 1
    pPriv = (miDCCursorPtr) pCursor->bits->devPriv[pScreen->myNum];
d722 2
a723 1
    pScreenPriv = (miDCScreenPtr) pScreen->devPrivates[miDCScreenIndex].ptr;
d740 1
a740 1
	    (pScreen, w, h, pScreenPriv->pSave->drawable.depth);
d747 1
a747 1
	    GCGraphicsExposures, &gcval, &status);
d783 1
a783 1
		GCGraphicsExposures, &gcval, &status);
d790 1
a790 1
		GCGraphicsExposures, &gcval, &status);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
