head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.2
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.6
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	s0SI41sEunLdyFfd;

1.9
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.16;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.16;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <X11/X.h>
#include "scrnintstr.h"
#include <X11/extensions/shapeproto.h>
#include "validate.h"
#include "windowstr.h"
#include "mi.h"
#include "gcstruct.h"
#include "regionstr.h"
#include "privates.h"
#include "mivalidate.h"
#include "mioverlay.h"
#include "migc.h"

#include "globals.h"

typedef struct {
    RegionRec exposed;
    RegionRec borderExposed;
    RegionPtr borderVisible;
    DDXPointRec oldAbsCorner;
} miOverlayValDataRec, *miOverlayValDataPtr;

typedef struct _TreeRec {
    WindowPtr pWin;
    struct _TreeRec *parent;
    struct _TreeRec *firstChild;
    struct _TreeRec *lastChild;
    struct _TreeRec *prevSib;
    struct _TreeRec *nextSib;
    RegionRec borderClip;
    RegionRec clipList;
    unsigned visibility;
    miOverlayValDataPtr valdata;
} miOverlayTreeRec, *miOverlayTreePtr;

typedef struct {
    miOverlayTreePtr tree;
} miOverlayWindowRec, *miOverlayWindowPtr;

typedef struct {
    CloseScreenProcPtr CloseScreen;
    CreateWindowProcPtr CreateWindow;
    DestroyWindowProcPtr DestroyWindow;
    UnrealizeWindowProcPtr UnrealizeWindow;
    RealizeWindowProcPtr RealizeWindow;
    miOverlayTransFunc MakeTransparent;
    miOverlayInOverlayFunc InOverlay;
    Bool underlayMarked;
    Bool copyUnderlay;
} miOverlayScreenRec, *miOverlayScreenPtr;

static DevPrivateKeyRec miOverlayWindowKeyRec;

#define miOverlayWindowKey (&miOverlayWindowKeyRec)
static DevPrivateKeyRec miOverlayScreenKeyRec;

#define miOverlayScreenKey (&miOverlayScreenKeyRec)

static void RebuildTree(WindowPtr);
static Bool HasUnderlayChildren(WindowPtr);
static void MarkUnderlayWindow(WindowPtr);
static Bool CollectUnderlayChildrenRegions(WindowPtr, RegionPtr);

static Bool miOverlayCloseScreen(ScreenPtr);
static Bool miOverlayCreateWindow(WindowPtr);
static Bool miOverlayDestroyWindow(WindowPtr);
static Bool miOverlayUnrealizeWindow(WindowPtr);
static Bool miOverlayRealizeWindow(WindowPtr);
static void miOverlayMarkWindow(WindowPtr);
static void miOverlayReparentWindow(WindowPtr, WindowPtr);
static void miOverlayRestackWindow(WindowPtr, WindowPtr);
static Bool miOverlayMarkOverlappedWindows(WindowPtr, WindowPtr, WindowPtr *);
static void miOverlayMarkUnrealizedWindow(WindowPtr, WindowPtr, Bool);
static int miOverlayValidateTree(WindowPtr, WindowPtr, VTKind);
static void miOverlayHandleExposures(WindowPtr);
static void miOverlayMoveWindow(WindowPtr, int, int, WindowPtr, VTKind);
static void miOverlayWindowExposures(WindowPtr, RegionPtr);
static void miOverlayResizeWindow(WindowPtr, int, int, unsigned int,
                                  unsigned int, WindowPtr);
static void miOverlayClearToBackground(WindowPtr, int, int, int, int, Bool);

static void miOverlaySetShape(WindowPtr, int);
static void miOverlayChangeBorderWidth(WindowPtr, unsigned int);

#define MIOVERLAY_GET_SCREEN_PRIVATE(pScreen) ((miOverlayScreenPtr) \
	dixLookupPrivate(&(pScreen)->devPrivates, miOverlayScreenKey))
#define MIOVERLAY_GET_WINDOW_PRIVATE(pWin) ((miOverlayWindowPtr) \
	dixLookupPrivate(&(pWin)->devPrivates, miOverlayWindowKey))
#define MIOVERLAY_GET_WINDOW_TREE(pWin) \
	(MIOVERLAY_GET_WINDOW_PRIVATE(pWin)->tree)

#define IN_UNDERLAY(w) MIOVERLAY_GET_WINDOW_TREE(w)
#define IN_OVERLAY(w) !MIOVERLAY_GET_WINDOW_TREE(w)

#define MARK_OVERLAY(w) miMarkWindow(w)
#define MARK_UNDERLAY(w) MarkUnderlayWindow(w)

#define HasParentRelativeBorder(w) (!(w)->borderIsPixel && \
                                    HasBorder(w) && \
                                    (w)->backgroundState == ParentRelative)

Bool
miInitOverlay(ScreenPtr pScreen,
              miOverlayInOverlayFunc inOverlayFunc,
              miOverlayTransFunc transFunc)
{
    miOverlayScreenPtr pScreenPriv;

    if (!inOverlayFunc || !transFunc)
        return FALSE;

    if (!dixRegisterPrivateKey
        (&miOverlayWindowKeyRec, PRIVATE_WINDOW, sizeof(miOverlayWindowRec)))
        return FALSE;

    if (!dixRegisterPrivateKey(&miOverlayScreenKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    if (!(pScreenPriv = malloc(sizeof(miOverlayScreenRec))))
        return FALSE;

    dixSetPrivate(&pScreen->devPrivates, miOverlayScreenKey, pScreenPriv);

    pScreenPriv->InOverlay = inOverlayFunc;
    pScreenPriv->MakeTransparent = transFunc;
    pScreenPriv->underlayMarked = FALSE;

    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreenPriv->CreateWindow = pScreen->CreateWindow;
    pScreenPriv->DestroyWindow = pScreen->DestroyWindow;
    pScreenPriv->UnrealizeWindow = pScreen->UnrealizeWindow;
    pScreenPriv->RealizeWindow = pScreen->RealizeWindow;

    pScreen->CloseScreen = miOverlayCloseScreen;
    pScreen->CreateWindow = miOverlayCreateWindow;
    pScreen->DestroyWindow = miOverlayDestroyWindow;
    pScreen->UnrealizeWindow = miOverlayUnrealizeWindow;
    pScreen->RealizeWindow = miOverlayRealizeWindow;

    pScreen->ReparentWindow = miOverlayReparentWindow;
    pScreen->RestackWindow = miOverlayRestackWindow;
    pScreen->MarkOverlappedWindows = miOverlayMarkOverlappedWindows;
    pScreen->MarkUnrealizedWindow = miOverlayMarkUnrealizedWindow;
    pScreen->ValidateTree = miOverlayValidateTree;
    pScreen->HandleExposures = miOverlayHandleExposures;
    pScreen->MoveWindow = miOverlayMoveWindow;
    pScreen->WindowExposures = miOverlayWindowExposures;
    pScreen->ResizeWindow = miOverlayResizeWindow;
    pScreen->MarkWindow = miOverlayMarkWindow;
    pScreen->ClearToBackground = miOverlayClearToBackground;
    pScreen->SetShape = miOverlaySetShape;
    pScreen->ChangeBorderWidth = miOverlayChangeBorderWidth;

    return TRUE;
}

static Bool
miOverlayCloseScreen(ScreenPtr pScreen)
{
    miOverlayScreenPtr pScreenPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;
    pScreen->CreateWindow = pScreenPriv->CreateWindow;
    pScreen->DestroyWindow = pScreenPriv->DestroyWindow;
    pScreen->UnrealizeWindow = pScreenPriv->UnrealizeWindow;
    pScreen->RealizeWindow = pScreenPriv->RealizeWindow;

    free(pScreenPriv);

    return (*pScreen->CloseScreen) (pScreen);
}

static Bool
miOverlayCreateWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    miOverlayScreenPtr pScreenPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
    miOverlayWindowPtr pWinPriv = MIOVERLAY_GET_WINDOW_PRIVATE(pWin);
    miOverlayTreePtr pTree = NULL;
    Bool result = TRUE;

    pWinPriv->tree = NULL;

    if (!pWin->parent || !((*pScreenPriv->InOverlay) (pWin))) {
        if (!(pTree = (miOverlayTreePtr) calloc(1, sizeof(miOverlayTreeRec))))
            return FALSE;
    }

    if (pScreenPriv->CreateWindow) {
        pScreen->CreateWindow = pScreenPriv->CreateWindow;
        result = (*pScreen->CreateWindow) (pWin);
        pScreen->CreateWindow = miOverlayCreateWindow;
    }

    if (pTree) {
        if (result) {
            pTree->pWin = pWin;
            pTree->visibility = VisibilityNotViewable;
            pWinPriv->tree = pTree;
            if (pWin->parent) {
                RegionNull(&(pTree->borderClip));
                RegionNull(&(pTree->clipList));
                RebuildTree(pWin);
            }
            else {
                BoxRec fullBox;

                fullBox.x1 = 0;
                fullBox.y1 = 0;
                fullBox.x2 = pScreen->width;
                fullBox.y2 = pScreen->height;
                RegionInit(&(pTree->borderClip), &fullBox, 1);
                RegionInit(&(pTree->clipList), &fullBox, 1);
            }
        }
        else
            free(pTree);
    }

    return TRUE;
}

static Bool
miOverlayDestroyWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    miOverlayScreenPtr pScreenPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
    Bool result = TRUE;

    if (pTree) {
        if (pTree->prevSib)
            pTree->prevSib->nextSib = pTree->nextSib;
        else if (pTree->parent)
            pTree->parent->firstChild = pTree->nextSib;

        if (pTree->nextSib)
            pTree->nextSib->prevSib = pTree->prevSib;
        else if (pTree->parent)
            pTree->parent->lastChild = pTree->prevSib;

        RegionUninit(&(pTree->borderClip));
        RegionUninit(&(pTree->clipList));
        free(pTree);
    }

    if (pScreenPriv->DestroyWindow) {
        pScreen->DestroyWindow = pScreenPriv->DestroyWindow;
        result = (*pScreen->DestroyWindow) (pWin);
        pScreen->DestroyWindow = miOverlayDestroyWindow;
    }

    return result;
}

static Bool
miOverlayUnrealizeWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    miOverlayScreenPtr pScreenPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
    Bool result = TRUE;

    if (pTree)
        pTree->visibility = VisibilityNotViewable;

    if (pScreenPriv->UnrealizeWindow) {
        pScreen->UnrealizeWindow = pScreenPriv->UnrealizeWindow;
        result = (*pScreen->UnrealizeWindow) (pWin);
        pScreen->UnrealizeWindow = miOverlayUnrealizeWindow;
    }

    return result;
}

static Bool
miOverlayRealizeWindow(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    miOverlayScreenPtr pScreenPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
    Bool result = TRUE;

    if (pScreenPriv->RealizeWindow) {
        pScreen->RealizeWindow = pScreenPriv->RealizeWindow;
        result = (*pScreen->RealizeWindow) (pWin);
        pScreen->RealizeWindow = miOverlayRealizeWindow;
    }

    /* we only need to catch the root window realization */

    if (result && !pWin->parent && !((*pScreenPriv->InOverlay) (pWin))) {
        BoxRec box;

        box.x1 = box.y1 = 0;
        box.x2 = pWin->drawable.width;
        box.y2 = pWin->drawable.height;
        (*pScreenPriv->MakeTransparent) (pScreen, 1, &box);
    }

    return result;
}

static void
miOverlayReparentWindow(WindowPtr pWin, WindowPtr pPriorParent)
{
    if (IN_UNDERLAY(pWin) || HasUnderlayChildren(pWin)) {
        /* This could probably be more optimal */
        RebuildTree(pWin->drawable.pScreen->root->firstChild);
    }
}

static void
miOverlayRestackWindow(WindowPtr pWin, WindowPtr oldNextSib)
{
    if (IN_UNDERLAY(pWin) || HasUnderlayChildren(pWin)) {
        /* This could probably be more optimal */
        RebuildTree(pWin);
    }
}

static Bool
miOverlayMarkOverlappedWindows(WindowPtr pWin,
                               WindowPtr pFirst, WindowPtr *pLayerWin)
{
    WindowPtr pChild, pLast;
    Bool overMarked, underMarked, doUnderlay, markAll;
    miOverlayTreePtr pTree = NULL, tLast, tChild;
    BoxPtr box;

    overMarked = underMarked = markAll = FALSE;

    if (pLayerWin)
        *pLayerWin = pWin;      /* hah! */

    doUnderlay = (IN_UNDERLAY(pWin) || HasUnderlayChildren(pWin));

    box = RegionExtents(&pWin->borderSize);

    if ((pChild = pFirst)) {
        pLast = pChild->parent->lastChild;
        while (1) {
            if (pChild == pWin)
                markAll = TRUE;

            if (doUnderlay && IN_UNDERLAY(pChild))
                pTree = MIOVERLAY_GET_WINDOW_TREE(pChild);

            if (pChild->viewable) {
                if (RegionBroken(&pChild->winSize))
                    SetWinSize(pChild);
                if (RegionBroken(&pChild->borderSize))
                    SetBorderSize(pChild);

                if (markAll || RegionContainsRect(&pChild->borderSize, box)) {
                    MARK_OVERLAY(pChild);
                    overMarked = TRUE;
                    if (doUnderlay && IN_UNDERLAY(pChild)) {
                        MARK_UNDERLAY(pChild);
                        underMarked = TRUE;
                    }
                    if (pChild->firstChild) {
                        pChild = pChild->firstChild;
                        continue;
                    }
                }
            }
            while (!pChild->nextSib && (pChild != pLast)) {
                pChild = pChild->parent;
                if (doUnderlay && IN_UNDERLAY(pChild))
                    pTree = MIOVERLAY_GET_WINDOW_TREE(pChild);
            }

            if (pChild == pWin)
                markAll = FALSE;

            if (pChild == pLast)
                break;

            pChild = pChild->nextSib;
        }
        if (overMarked)
            MARK_OVERLAY(pWin->parent);
    }

    if (doUnderlay && !pTree) {
        if (!(pTree = MIOVERLAY_GET_WINDOW_TREE(pWin))) {
            pChild = pWin->lastChild;
            while (1) {
                if ((pTree = MIOVERLAY_GET_WINDOW_TREE(pChild)))
                    break;

                if (pChild->lastChild) {
                    pChild = pChild->lastChild;
                    continue;
                }

                while (!pChild->prevSib)
                    pChild = pChild->parent;

                pChild = pChild->prevSib;
            }
        }
    }

    if (pTree && pTree->nextSib) {
        tChild = pTree->parent->lastChild;
        tLast = pTree->nextSib;

        while (1) {
            if (tChild->pWin->viewable) {
                if (RegionBroken(&tChild->pWin->winSize))
                    SetWinSize(tChild->pWin);
                if (RegionBroken(&tChild->pWin->borderSize))
                    SetBorderSize(tChild->pWin);

                if (RegionContainsRect(&(tChild->pWin->borderSize), box)) {
                    MARK_UNDERLAY(tChild->pWin);
                    underMarked = TRUE;
                }
            }

            if (tChild->lastChild) {
                tChild = tChild->lastChild;
                continue;
            }

            while (!tChild->prevSib && (tChild != tLast))
                tChild = tChild->parent;

            if (tChild == tLast)
                break;

            tChild = tChild->prevSib;
        }
    }

    if (underMarked) {
        ScreenPtr pScreen = pWin->drawable.pScreen;

        MARK_UNDERLAY(pTree->parent->pWin);
        MIOVERLAY_GET_SCREEN_PRIVATE(pScreen)->underlayMarked = TRUE;
    }

    return underMarked || overMarked;
}

static void
miOverlayComputeClips(WindowPtr pParent,
                      RegionPtr universe, VTKind kind, RegionPtr exposed)
{
    ScreenPtr pScreen = pParent->drawable.pScreen;
    int oldVis, newVis, dx, dy;
    BoxRec borderSize;
    RegionPtr borderVisible;
    RegionRec childUniverse, childUnion;
    miOverlayTreePtr tParent = MIOVERLAY_GET_WINDOW_TREE(pParent);
    miOverlayTreePtr tChild;
    Bool overlap;

    borderSize.x1 = pParent->drawable.x - wBorderWidth(pParent);
    borderSize.y1 = pParent->drawable.y - wBorderWidth(pParent);
    dx = (int) pParent->drawable.x + (int) pParent->drawable.width +
        wBorderWidth(pParent);
    if (dx > 32767)
        dx = 32767;
    borderSize.x2 = dx;
    dy = (int) pParent->drawable.y + (int) pParent->drawable.height +
        wBorderWidth(pParent);
    if (dy > 32767)
        dy = 32767;
    borderSize.y2 = dy;

    oldVis = tParent->visibility;
    switch (RegionContainsRect(universe, &borderSize)) {
    case rgnIN:
        newVis = VisibilityUnobscured;
        break;
    case rgnPART:
        newVis = VisibilityPartiallyObscured;
        {
            RegionPtr pBounding;

            if ((pBounding = wBoundingShape(pParent))) {
                switch (miShapedWindowIn(universe, pBounding,
                                         &borderSize,
                                         pParent->drawable.x,
                                         pParent->drawable.y)) {
                case rgnIN:
                    newVis = VisibilityUnobscured;
                    break;
                case rgnOUT:
                    newVis = VisibilityFullyObscured;
                    break;
                }
            }
        }
        break;
    default:
        newVis = VisibilityFullyObscured;
        break;
    }
    tParent->visibility = newVis;

    dx = pParent->drawable.x - tParent->valdata->oldAbsCorner.x;
    dy = pParent->drawable.y - tParent->valdata->oldAbsCorner.y;

    switch (kind) {
    case VTMap:
    case VTStack:
    case VTUnmap:
        break;
    case VTMove:
        if ((oldVis == newVis) &&
            ((oldVis == VisibilityFullyObscured) ||
             (oldVis == VisibilityUnobscured))) {
            tChild = tParent;
            while (1) {
                if (tChild->pWin->viewable) {
                    if (tChild->visibility != VisibilityFullyObscured) {
                        RegionTranslate(&tChild->borderClip, dx, dy);
                        RegionTranslate(&tChild->clipList, dx, dy);

                        tChild->pWin->drawable.serialNumber =
                            NEXT_SERIAL_NUMBER;
                        if (pScreen->ClipNotify)
                            (*pScreen->ClipNotify) (tChild->pWin, dx, dy);
                    }
                    if (tChild->valdata) {
                        RegionNull(&tChild->valdata->borderExposed);
                        if (HasParentRelativeBorder(tChild->pWin)) {
                            RegionSubtract(&tChild->valdata->borderExposed,
                                           &tChild->borderClip,
                                           &tChild->pWin->winSize);
                        }
                        RegionNull(&tChild->valdata->exposed);
                    }
                    if (tChild->firstChild) {
                        tChild = tChild->firstChild;
                        continue;
                    }
                }
                while (!tChild->nextSib && (tChild != tParent))
                    tChild = tChild->parent;
                if (tChild == tParent)
                    break;
                tChild = tChild->nextSib;
            }
            return;
        }
        /* fall through */
    default:
        if (dx || dy) {
            RegionTranslate(&tParent->borderClip, dx, dy);
            RegionTranslate(&tParent->clipList, dx, dy);
        }
        break;
    case VTBroken:
        RegionEmpty(&tParent->borderClip);
        RegionEmpty(&tParent->clipList);
        break;
    }

    borderVisible = tParent->valdata->borderVisible;
    RegionNull(&tParent->valdata->borderExposed);
    RegionNull(&tParent->valdata->exposed);

    if (HasBorder(pParent)) {
        if (borderVisible) {
            RegionSubtract(exposed, universe, borderVisible);
            RegionDestroy(borderVisible);
        }
        else
            RegionSubtract(exposed, universe, &tParent->borderClip);

        if (HasParentRelativeBorder(pParent) && (dx || dy))
            RegionSubtract(&tParent->valdata->borderExposed,
                           universe, &pParent->winSize);
        else
            RegionSubtract(&tParent->valdata->borderExposed,
                           exposed, &pParent->winSize);

        RegionCopy(&tParent->borderClip, universe);
        RegionIntersect(universe, universe, &pParent->winSize);
    }
    else
        RegionCopy(&tParent->borderClip, universe);

    if ((tChild = tParent->firstChild) && pParent->mapped) {
        RegionNull(&childUniverse);
        RegionNull(&childUnion);

        for (; tChild; tChild = tChild->nextSib) {
            if (tChild->pWin->viewable)
                RegionAppend(&childUnion, &tChild->pWin->borderSize);
        }

        RegionValidate(&childUnion, &overlap);

        for (tChild = tParent->firstChild; tChild; tChild = tChild->nextSib) {
            if (tChild->pWin->viewable) {
                if (tChild->valdata) {
                    RegionIntersect(&childUniverse, universe,
                                    &tChild->pWin->borderSize);
                    miOverlayComputeClips(tChild->pWin, &childUniverse,
                                          kind, exposed);
                }
                if (overlap)
                    RegionSubtract(universe, universe,
                                   &tChild->pWin->borderSize);
            }
        }
        if (!overlap)
            RegionSubtract(universe, universe, &childUnion);
        RegionUninit(&childUnion);
        RegionUninit(&childUniverse);
    }

    if (oldVis == VisibilityFullyObscured || oldVis == VisibilityNotViewable) {
        RegionCopy(&tParent->valdata->exposed, universe);
    }
    else if (newVis != VisibilityFullyObscured &&
             newVis != VisibilityNotViewable) {
        RegionSubtract(&tParent->valdata->exposed,
                       universe, &tParent->clipList);
    }

    /* HACK ALERT - copying contents of regions, instead of regions */
    {
        RegionRec tmp;

        tmp = tParent->clipList;
        tParent->clipList = *universe;
        *universe = tmp;
    }

    pParent->drawable.serialNumber = NEXT_SERIAL_NUMBER;

    if (pScreen->ClipNotify)
        (*pScreen->ClipNotify) (pParent, dx, dy);
}

static void
miOverlayMarkWindow(WindowPtr pWin)
{
    miOverlayTreePtr pTree = NULL;
    WindowPtr pChild, pGrandChild;

    miMarkWindow(pWin);

    /* look for UnmapValdata among immediate children */

    if (!(pChild = pWin->firstChild))
        return;

    for (; pChild; pChild = pChild->nextSib) {
        if (pChild->valdata == UnmapValData) {
            if (IN_UNDERLAY(pChild)) {
                pTree = MIOVERLAY_GET_WINDOW_TREE(pChild);
                pTree->valdata = (miOverlayValDataPtr) UnmapValData;
                continue;
            }
            else {
                if (!(pGrandChild = pChild->firstChild))
                    continue;

                while (1) {
                    if (IN_UNDERLAY(pGrandChild)) {
                        pTree = MIOVERLAY_GET_WINDOW_TREE(pGrandChild);
                        pTree->valdata = (miOverlayValDataPtr) UnmapValData;
                    }
                    else if (pGrandChild->firstChild) {
                        pGrandChild = pGrandChild->firstChild;
                        continue;
                    }

                    while (!pGrandChild->nextSib && (pGrandChild != pChild))
                        pGrandChild = pGrandChild->parent;

                    if (pChild == pGrandChild)
                        break;

                    pGrandChild = pGrandChild->nextSib;
                }
            }
        }
    }

    if (pTree) {
        MARK_UNDERLAY(pTree->parent->pWin);
        MIOVERLAY_GET_SCREEN_PRIVATE(pWin->drawable.pScreen)->underlayMarked =
            TRUE;
    }
}

static void
miOverlayMarkUnrealizedWindow(WindowPtr pChild,
                              WindowPtr pWin, Bool fromConfigure)
{
    if ((pChild != pWin) || fromConfigure) {
        miOverlayTreePtr pTree;

        RegionEmpty(&pChild->clipList);
        if (pChild->drawable.pScreen->ClipNotify)
            (*pChild->drawable.pScreen->ClipNotify) (pChild, 0, 0);
        RegionEmpty(&pChild->borderClip);
        if ((pTree = MIOVERLAY_GET_WINDOW_TREE(pChild))) {
            if (pTree->valdata != (miOverlayValDataPtr) UnmapValData) {
                RegionEmpty(&pTree->clipList);
                RegionEmpty(&pTree->borderClip);
            }
        }
    }
}

static int
miOverlayValidateTree(WindowPtr pParent, WindowPtr pChild,      /* first child effected */
                      VTKind kind)
{
    ScreenPtr pScreen = pParent->drawable.pScreen;
    miOverlayScreenPtr pPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
    RegionRec totalClip, childClip, exposed;
    miOverlayTreePtr tParent, tChild, tWin;
    Bool overlap;
    WindowPtr newParent;

    if (!pPriv->underlayMarked)
        goto SKIP_UNDERLAY;

    if (!pChild)
        pChild = pParent->firstChild;

    RegionNull(&totalClip);
    RegionNull(&childClip);
    RegionNull(&exposed);

    newParent = pParent;

    while (IN_OVERLAY(newParent))
        newParent = newParent->parent;

    tParent = MIOVERLAY_GET_WINDOW_TREE(newParent);

    if (IN_UNDERLAY(pChild))
        tChild = MIOVERLAY_GET_WINDOW_TREE(pChild);
    else
        tChild = tParent->firstChild;

    if (RegionBroken(&tParent->clipList) && !RegionBroken(&tParent->borderClip)) {
        kind = VTBroken;
        RegionCopy(&totalClip, &tParent->borderClip);
        RegionIntersect(&totalClip, &totalClip, &tParent->pWin->winSize);

        for (tWin = tParent->firstChild; tWin != tChild; tWin = tWin->nextSib) {
            if (tWin->pWin->viewable)
                RegionSubtract(&totalClip, &totalClip, &tWin->pWin->borderSize);
        }
        RegionEmpty(&tParent->clipList);
    }
    else {
        for (tWin = tChild; tWin; tWin = tWin->nextSib) {
            if (tWin->valdata)
                RegionAppend(&totalClip, &tWin->borderClip);
        }
        RegionValidate(&totalClip, &overlap);
    }

    if (kind != VTStack)
        RegionUnion(&totalClip, &totalClip, &tParent->clipList);

    for (tWin = tChild; tWin; tWin = tWin->nextSib) {
        if (tWin->valdata) {
            if (tWin->pWin->viewable) {
                RegionIntersect(&childClip, &totalClip,
                                &tWin->pWin->borderSize);
                miOverlayComputeClips(tWin->pWin, &childClip, kind, &exposed);
                RegionSubtract(&totalClip, &totalClip, &tWin->pWin->borderSize);
            }
            else {              /* Means we are unmapping */
                RegionEmpty(&tWin->clipList);
                RegionEmpty(&tWin->borderClip);
                tWin->valdata = NULL;
            }
        }
    }

    RegionUninit(&childClip);

    if (!((*pPriv->InOverlay) (newParent))) {
        RegionNull(&tParent->valdata->exposed);
        RegionNull(&tParent->valdata->borderExposed);
    }

    switch (kind) {
    case VTStack:
        break;
    default:
        if (!((*pPriv->InOverlay) (newParent)))
            RegionSubtract(&tParent->valdata->exposed, &totalClip,
                           &tParent->clipList);
        /* fall through */
    case VTMap:
        RegionCopy(&tParent->clipList, &totalClip);
        if (!((*pPriv->InOverlay) (newParent)))
            newParent->drawable.serialNumber = NEXT_SERIAL_NUMBER;
        break;
    }

    RegionUninit(&totalClip);
    RegionUninit(&exposed);

 SKIP_UNDERLAY:

    miValidateTree(pParent, pChild, kind);

    return 1;
}

static void
miOverlayHandleExposures(WindowPtr pWin)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    miOverlayScreenPtr pPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
    WindowPtr pChild;
    ValidatePtr val;
    WindowExposuresProcPtr WindowExposures;

    WindowExposures = pWin->drawable.pScreen->WindowExposures;
    if (pPriv->underlayMarked) {
        miOverlayTreePtr pTree;
        miOverlayValDataPtr mival;

        pChild = pWin;
        while (IN_OVERLAY(pChild))
            pChild = pChild->parent;

        pTree = MIOVERLAY_GET_WINDOW_TREE(pChild);

        while (1) {
            if ((mival = pTree->valdata)) {
                if (!((*pPriv->InOverlay) (pTree->pWin))) {
                    if (RegionNotEmpty(&mival->borderExposed)) {
                        pScreen->PaintWindow(pTree->pWin, &mival->borderExposed,
                                             PW_BORDER);
                    }
                    RegionUninit(&mival->borderExposed);

                    (*WindowExposures) (pTree->pWin, &mival->exposed);
                    RegionUninit(&mival->exposed);
                }
                free(mival);
                pTree->valdata = NULL;
                if (pTree->firstChild) {
                    pTree = pTree->firstChild;
                    continue;
                }
            }
            while (!pTree->nextSib && (pTree->pWin != pChild))
                pTree = pTree->parent;
            if (pTree->pWin == pChild)
                break;
            pTree = pTree->nextSib;
        }
        pPriv->underlayMarked = FALSE;
    }

    pChild = pWin;
    while (1) {
        if ((val = pChild->valdata)) {
            if (!((*pPriv->InOverlay) (pChild))) {
                RegionUnion(&val->after.exposed, &val->after.exposed,
                            &val->after.borderExposed);

                if (RegionNotEmpty(&val->after.exposed)) {
                    (*(MIOVERLAY_GET_SCREEN_PRIVATE(pScreen)->MakeTransparent))
                        (pScreen, RegionNumRects(&val->after.exposed),
                         RegionRects(&val->after.exposed));
                }
            }
            else {
                if (RegionNotEmpty(&val->after.borderExposed)) {
                    pScreen->PaintWindow(pChild, &val->after.borderExposed,
                                         PW_BORDER);
                }
                (*WindowExposures) (pChild, &val->after.exposed);
            }
            RegionUninit(&val->after.borderExposed);
            RegionUninit(&val->after.exposed);
            free(val);
            pChild->valdata = NULL;
            if (pChild->firstChild) {
                pChild = pChild->firstChild;
                continue;
            }
        }
        while (!pChild->nextSib && (pChild != pWin))
            pChild = pChild->parent;
        if (pChild == pWin)
            break;
        pChild = pChild->nextSib;
    }
}

static void
miOverlayMoveWindow(WindowPtr pWin,
                    int x, int y, WindowPtr pNextSib, VTKind kind)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
    WindowPtr pParent, windowToValidate;
    Bool WasViewable = (Bool) (pWin->viewable);
    short bw;
    RegionRec overReg, underReg;
    DDXPointRec oldpt;

    if (!(pParent = pWin->parent))
        return;
    bw = wBorderWidth(pWin);

    oldpt.x = pWin->drawable.x;
    oldpt.y = pWin->drawable.y;
    if (WasViewable) {
        RegionNull(&overReg);
        RegionNull(&underReg);
        if (pTree) {
            RegionCopy(&overReg, &pWin->borderClip);
            RegionCopy(&underReg, &pTree->borderClip);
        }
        else {
            RegionCopy(&overReg, &pWin->borderClip);
            CollectUnderlayChildrenRegions(pWin, &underReg);
        }
        (*pScreen->MarkOverlappedWindows) (pWin, pWin, NULL);
    }
    pWin->origin.x = x + (int) bw;
    pWin->origin.y = y + (int) bw;
    x = pWin->drawable.x = pParent->drawable.x + x + (int) bw;
    y = pWin->drawable.y = pParent->drawable.y + y + (int) bw;

    SetWinSize(pWin);
    SetBorderSize(pWin);

    (*pScreen->PositionWindow) (pWin, x, y);

    windowToValidate = MoveWindowInStack(pWin, pNextSib);

    ResizeChildrenWinSize(pWin, x - oldpt.x, y - oldpt.y, 0, 0);

    if (WasViewable) {
        miOverlayScreenPtr pPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);

        (*pScreen->MarkOverlappedWindows) (pWin, windowToValidate, NULL);

        (*pScreen->ValidateTree) (pWin->parent, NullWindow, kind);
        if (RegionNotEmpty(&underReg)) {
            pPriv->copyUnderlay = TRUE;
            (*pWin->drawable.pScreen->CopyWindow) (pWin, oldpt, &underReg);
        }
        RegionUninit(&underReg);
        if (RegionNotEmpty(&overReg)) {
            pPriv->copyUnderlay = FALSE;
            (*pWin->drawable.pScreen->CopyWindow) (pWin, oldpt, &overReg);
        }
        RegionUninit(&overReg);
        (*pScreen->HandleExposures) (pWin->parent);

        if (pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pWin->parent, NullWindow, kind);
    }
    if (pWin->realized)
        WindowsRestructured();
}

#ifndef RECTLIMIT
#define RECTLIMIT 25
#endif

static void
miOverlayWindowExposures(WindowPtr pWin, RegionPtr prgn)
{
    RegionPtr exposures = prgn;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    if (prgn && !RegionNil(prgn)) {
        RegionRec expRec;
        int clientInterested =
            (pWin->eventMask | wOtherEventMasks(pWin)) & ExposureMask;
        if (clientInterested && (RegionNumRects(prgn) > RECTLIMIT)) {
            miOverlayScreenPtr pPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
            BoxRec box;

            box = *RegionExtents(prgn);
            exposures = &expRec;
            RegionInit(exposures, &box, 1);
            RegionReset(prgn, &box);
            /* This is the only reason why we are replacing mi's version
               of this file */

            if (!((*pPriv->InOverlay) (pWin))) {
                miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);

                RegionIntersect(prgn, prgn, &pTree->clipList);
            }
            else
                RegionIntersect(prgn, prgn, &pWin->clipList);
        }
        pScreen->PaintWindow(pWin, prgn, PW_BACKGROUND);
        if (clientInterested)
            miSendExposures(pWin, exposures,
                            pWin->drawable.x, pWin->drawable.y);
        if (exposures == &expRec)
            RegionUninit(exposures);
        RegionEmpty(prgn);
    }
}

typedef struct {
    RegionPtr over;
    RegionPtr under;
} miOverlayTwoRegions;

static int
miOverlayRecomputeExposures(WindowPtr pWin, void *value)
{
    miOverlayTwoRegions *pValid = (miOverlayTwoRegions *) value;
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);

    if (pWin->valdata) {
        /*
         * compute exposed regions of this window
         */
        RegionSubtract(&pWin->valdata->after.exposed,
                       &pWin->clipList, pValid->over);
        /*
         * compute exposed regions of the border
         */
        RegionSubtract(&pWin->valdata->after.borderExposed,
                       &pWin->borderClip, &pWin->winSize);
        RegionSubtract(&pWin->valdata->after.borderExposed,
                       &pWin->valdata->after.borderExposed, pValid->over);
    }

    if (pTree && pTree->valdata) {
        RegionSubtract(&pTree->valdata->exposed,
                       &pTree->clipList, pValid->under);
        RegionSubtract(&pTree->valdata->borderExposed,
                       &pTree->borderClip, &pWin->winSize);
        RegionSubtract(&pTree->valdata->borderExposed,
                       &pTree->valdata->borderExposed, pValid->under);
    }
    else if (!pWin->valdata)
        return WT_NOMATCH;

    return WT_WALKCHILDREN;
}

static void
miOverlayResizeWindow(WindowPtr pWin,
                      int x, int y,
                      unsigned int w, unsigned int h, WindowPtr pSib)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;
    WindowPtr pParent;
    miOverlayTreePtr tChild, pTree;
    Bool WasViewable = (Bool) (pWin->viewable);
    unsigned short width = pWin->drawable.width;
    unsigned short height = pWin->drawable.height;
    short oldx = pWin->drawable.x;
    short oldy = pWin->drawable.y;
    int bw = wBorderWidth(pWin);
    short dw, dh;
    DDXPointRec oldpt;
    RegionPtr oldRegion = NULL, oldRegion2 = NULL;
    WindowPtr pFirstChange;
    WindowPtr pChild;
    RegionPtr gravitate[StaticGravity + 1];
    RegionPtr gravitate2[StaticGravity + 1];
    unsigned g;
    int nx, ny;                 /* destination x,y */
    int newx, newy;             /* new inner window position */
    RegionPtr pRegion = NULL;
    RegionPtr destClip, destClip2;
    RegionPtr oldWinClip = NULL, oldWinClip2 = NULL;
    RegionPtr borderVisible = NullRegion;
    RegionPtr borderVisible2 = NullRegion;
    Bool shrunk = FALSE;        /* shrunk in an inner dimension */
    Bool moved = FALSE;         /* window position changed */
    Bool doUnderlay;

    /* if this is a root window, can't be resized */
    if (!(pParent = pWin->parent))
        return;

    pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
    doUnderlay = ((pTree) || HasUnderlayChildren(pWin));
    newx = pParent->drawable.x + x + bw;
    newy = pParent->drawable.y + y + bw;
    if (WasViewable) {
        /*
         * save the visible region of the window
         */
        oldRegion = RegionCreate(NullBox, 1);
        RegionCopy(oldRegion, &pWin->winSize);
        if (doUnderlay) {
            oldRegion2 = RegionCreate(NullBox, 1);
            RegionCopy(oldRegion2, &pWin->winSize);
        }

        /*
         * categorize child windows into regions to be moved
         */
        for (g = 0; g <= StaticGravity; g++)
            gravitate[g] = gravitate2[g] = NULL;
        for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
            g = pChild->winGravity;
            if (g != UnmapGravity) {
                if (!gravitate[g])
                    gravitate[g] = RegionCreate(NullBox, 1);
                RegionUnion(gravitate[g], gravitate[g], &pChild->borderClip);

                if (doUnderlay) {
                    if (!gravitate2[g])
                        gravitate2[g] = RegionCreate(NullBox, 0);

                    if ((tChild = MIOVERLAY_GET_WINDOW_TREE(pChild))) {
                        RegionUnion(gravitate2[g],
                                    gravitate2[g], &tChild->borderClip);
                    }
                    else
                        CollectUnderlayChildrenRegions(pChild, gravitate2[g]);
                }
            }
            else {
                UnmapWindow(pChild, TRUE);
            }
        }
        (*pScreen->MarkOverlappedWindows) (pWin, pWin, NULL);

        oldWinClip = oldWinClip2 = NULL;
        if (pWin->bitGravity != ForgetGravity) {
            oldWinClip = RegionCreate(NullBox, 1);
            RegionCopy(oldWinClip, &pWin->clipList);
            if (pTree) {
                oldWinClip2 = RegionCreate(NullBox, 1);
                RegionCopy(oldWinClip2, &pTree->clipList);
            }
        }
        /*
         * if the window is changing size, borderExposed
         * can't be computed correctly without some help.
         */
        if (pWin->drawable.height > h || pWin->drawable.width > w)
            shrunk = TRUE;

        if (newx != oldx || newy != oldy)
            moved = TRUE;

        if ((pWin->drawable.height != h || pWin->drawable.width != w) &&
            HasBorder(pWin)) {
            borderVisible = RegionCreate(NullBox, 1);
            if (pTree)
                borderVisible2 = RegionCreate(NullBox, 1);
            /* for tiled borders, we punt and draw the whole thing */
            if (pWin->borderIsPixel || !moved) {
                if (shrunk || moved)
                    RegionSubtract(borderVisible,
                                   &pWin->borderClip, &pWin->winSize);
                else
                    RegionCopy(borderVisible, &pWin->borderClip);
                if (pTree) {
                    if (shrunk || moved)
                        RegionSubtract(borderVisible,
                                       &pTree->borderClip, &pWin->winSize);
                    else
                        RegionCopy(borderVisible, &pTree->borderClip);
                }
            }
        }
    }
    pWin->origin.x = x + bw;
    pWin->origin.y = y + bw;
    pWin->drawable.height = h;
    pWin->drawable.width = w;

    x = pWin->drawable.x = newx;
    y = pWin->drawable.y = newy;

    SetWinSize(pWin);
    SetBorderSize(pWin);

    dw = (int) w - (int) width;
    dh = (int) h - (int) height;
    ResizeChildrenWinSize(pWin, x - oldx, y - oldy, dw, dh);

    /* let the hardware adjust background and border pixmaps, if any */
    (*pScreen->PositionWindow) (pWin, x, y);

    pFirstChange = MoveWindowInStack(pWin, pSib);

    if (WasViewable) {
        pRegion = RegionCreate(NullBox, 1);

        (*pScreen->MarkOverlappedWindows) (pWin, pFirstChange, NULL);

        pWin->valdata->before.resized = TRUE;
        pWin->valdata->before.borderVisible = borderVisible;
        if (pTree)
            pTree->valdata->borderVisible = borderVisible2;

        (*pScreen->ValidateTree) (pWin->parent, pFirstChange, VTOther);
        /*
         * the entire window is trashed unless bitGravity
         * recovers portions of it
         */
        RegionCopy(&pWin->valdata->after.exposed, &pWin->clipList);
        if (pTree)
            RegionCopy(&pTree->valdata->exposed, &pTree->clipList);
    }

    GravityTranslate(x, y, oldx, oldy, dw, dh, pWin->bitGravity, &nx, &ny);

    if (WasViewable) {
        miOverlayScreenPtr pPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
        miOverlayTwoRegions TwoRegions;

        /* avoid the border */
        if (HasBorder(pWin)) {
            int offx, offy, dx, dy;

            /* kruft to avoid double translates for each gravity */
            offx = 0;
            offy = 0;
            for (g = 0; g <= StaticGravity; g++) {
                if (!gravitate[g] && !gravitate2[g])
                    continue;

                /* align winSize to gravitate[g].
                 * winSize is in new coordinates,
                 * gravitate[g] is still in old coordinates */
                GravityTranslate(x, y, oldx, oldy, dw, dh, g, &nx, &ny);

                dx = (oldx - nx) - offx;
                dy = (oldy - ny) - offy;
                if (dx || dy) {
                    RegionTranslate(&pWin->winSize, dx, dy);
                    offx += dx;
                    offy += dy;
                }
                if (gravitate[g])
                    RegionIntersect(gravitate[g], gravitate[g], &pWin->winSize);
                if (gravitate2[g])
                    RegionIntersect(gravitate2[g], gravitate2[g],
                                    &pWin->winSize);
            }
            /* get winSize back where it belongs */
            if (offx || offy)
                RegionTranslate(&pWin->winSize, -offx, -offy);
        }
        /*
         * add screen bits to the appropriate bucket
         */

        if (oldWinClip2) {
            RegionCopy(pRegion, oldWinClip2);
            RegionTranslate(pRegion, nx - oldx, ny - oldy);
            RegionIntersect(oldWinClip2, pRegion, &pTree->clipList);

            for (g = pWin->bitGravity + 1; g <= StaticGravity; g++) {
                if (gravitate2[g])
                    RegionSubtract(oldWinClip2, oldWinClip2, gravitate2[g]);
            }
            RegionTranslate(oldWinClip2, oldx - nx, oldy - ny);
            g = pWin->bitGravity;
            if (!gravitate2[g])
                gravitate2[g] = oldWinClip2;
            else {
                RegionUnion(gravitate2[g], gravitate2[g], oldWinClip2);
                RegionDestroy(oldWinClip2);
            }
        }

        if (oldWinClip) {
            /*
             * clip to new clipList
             */
            RegionCopy(pRegion, oldWinClip);
            RegionTranslate(pRegion, nx - oldx, ny - oldy);
            RegionIntersect(oldWinClip, pRegion, &pWin->clipList);
            /*
             * don't step on any gravity bits which will be copied after this
             * region.  Note -- this assumes that the regions will be copied
             * in gravity order.
             */
            for (g = pWin->bitGravity + 1; g <= StaticGravity; g++) {
                if (gravitate[g])
                    RegionSubtract(oldWinClip, oldWinClip, gravitate[g]);
            }
            RegionTranslate(oldWinClip, oldx - nx, oldy - ny);
            g = pWin->bitGravity;
            if (!gravitate[g])
                gravitate[g] = oldWinClip;
            else {
                RegionUnion(gravitate[g], gravitate[g], oldWinClip);
                RegionDestroy(oldWinClip);
            }
        }

        /*
         * move the bits on the screen
         */

        destClip = destClip2 = NULL;

        for (g = 0; g <= StaticGravity; g++) {
            if (!gravitate[g] && !gravitate2[g])
                continue;

            GravityTranslate(x, y, oldx, oldy, dw, dh, g, &nx, &ny);

            oldpt.x = oldx + (x - nx);
            oldpt.y = oldy + (y - ny);

            /* Note that gravitate[g] is *translated* by CopyWindow */

            /* only copy the remaining useful bits */

            if (gravitate[g])
                RegionIntersect(gravitate[g], gravitate[g], oldRegion);
            if (gravitate2[g])
                RegionIntersect(gravitate2[g], gravitate2[g], oldRegion2);

            /* clip to not overwrite already copied areas */

            if (destClip && gravitate[g]) {
                RegionTranslate(destClip, oldpt.x - x, oldpt.y - y);
                RegionSubtract(gravitate[g], gravitate[g], destClip);
                RegionTranslate(destClip, x - oldpt.x, y - oldpt.y);
            }
            if (destClip2 && gravitate2[g]) {
                RegionTranslate(destClip2, oldpt.x - x, oldpt.y - y);
                RegionSubtract(gravitate2[g], gravitate2[g], destClip2);
                RegionTranslate(destClip2, x - oldpt.x, y - oldpt.y);
            }

            /* and move those bits */

            if (oldpt.x != x || oldpt.y != y) {
                if (gravitate2[g]) {
                    pPriv->copyUnderlay = TRUE;
                    (*pScreen->CopyWindow) (pWin, oldpt, gravitate2[g]);
                }
                if (gravitate[g]) {
                    pPriv->copyUnderlay = FALSE;
                    (*pScreen->CopyWindow) (pWin, oldpt, gravitate[g]);
                }
            }

            /* remove any overwritten bits from the remaining useful bits */

            if (gravitate[g])
                RegionSubtract(oldRegion, oldRegion, gravitate[g]);
            if (gravitate2[g])
                RegionSubtract(oldRegion2, oldRegion2, gravitate2[g]);

            /*
             * recompute exposed regions of child windows
             */

            for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
                if (pChild->winGravity != g)
                    continue;

                TwoRegions.over = gravitate[g];
                TwoRegions.under = gravitate2[g];

                TraverseTree(pChild, miOverlayRecomputeExposures,
                             (void *) (&TwoRegions));
            }

            /*
             * remove the successfully copied regions of the
             * window from its exposed region
             */

            if (g == pWin->bitGravity) {
                if (gravitate[g])
                    RegionSubtract(&pWin->valdata->after.exposed,
                                   &pWin->valdata->after.exposed, gravitate[g]);
                if (gravitate2[g] && pTree)
                    RegionSubtract(&pTree->valdata->exposed,
                                   &pTree->valdata->exposed, gravitate2[g]);
            }
            if (gravitate[g]) {
                if (!destClip)
                    destClip = gravitate[g];
                else {
                    RegionUnion(destClip, destClip, gravitate[g]);
                    RegionDestroy(gravitate[g]);
                }
            }
            if (gravitate2[g]) {
                if (!destClip2)
                    destClip2 = gravitate2[g];
                else {
                    RegionUnion(destClip2, destClip2, gravitate2[g]);
                    RegionDestroy(gravitate2[g]);
                }
            }
        }

        RegionDestroy(pRegion);
        RegionDestroy(oldRegion);
        if (doUnderlay)
            RegionDestroy(oldRegion2);
        if (destClip)
            RegionDestroy(destClip);
        if (destClip2)
            RegionDestroy(destClip2);
        (*pScreen->HandleExposures) (pWin->parent);
        if (pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pWin->parent, pFirstChange, VTOther);
    }
    if (pWin->realized)
        WindowsRestructured();
}

static void
miOverlaySetShape(WindowPtr pWin, int kind)
{
    Bool WasViewable = (Bool) (pWin->viewable);
    ScreenPtr pScreen = pWin->drawable.pScreen;

    if (kind != ShapeInput) {
        if (WasViewable) {
            (*pScreen->MarkOverlappedWindows) (pWin, pWin, NULL);

            if (HasBorder(pWin)) {
                RegionPtr borderVisible;

                borderVisible = RegionCreate(NullBox, 1);
                RegionSubtract(borderVisible,
                               &pWin->borderClip, &pWin->winSize);
                pWin->valdata->before.borderVisible = borderVisible;
                pWin->valdata->before.resized = TRUE;
                if (IN_UNDERLAY(pWin)) {
                    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
                    RegionPtr borderVisible2;

                    borderVisible2 = RegionCreate(NULL, 1);
                    RegionSubtract(borderVisible2,
                                   &pTree->borderClip, &pWin->winSize);
                    pTree->valdata->borderVisible = borderVisible2;
                }
            }
        }

        SetWinSize(pWin);
        SetBorderSize(pWin);

        ResizeChildrenWinSize(pWin, 0, 0, 0, 0);

        if (WasViewable) {
            (*pScreen->MarkOverlappedWindows) (pWin, pWin, NULL);
            (*pScreen->ValidateTree) (pWin->parent, NullWindow, VTOther);
            (*pScreen->HandleExposures) (pWin->parent);
            if (pScreen->PostValidateTree)
                (*pScreen->PostValidateTree) (pWin->parent, NullWindow,
                                              VTOther);
        }
    }
    if (pWin->realized)
        WindowsRestructured();
    CheckCursorConfinement(pWin);
}

static void
miOverlayChangeBorderWidth(WindowPtr pWin, unsigned int width)
{
    int oldwidth;
    ScreenPtr pScreen;
    Bool WasViewable = (Bool) (pWin->viewable);
    Bool HadBorder;

    oldwidth = wBorderWidth(pWin);
    if (oldwidth == width)
        return;
    HadBorder = HasBorder(pWin);
    pScreen = pWin->drawable.pScreen;
    if (WasViewable && (width < oldwidth))
        (*pScreen->MarkOverlappedWindows) (pWin, pWin, NULL);

    pWin->borderWidth = width;
    SetBorderSize(pWin);

    if (WasViewable) {
        if (width > oldwidth) {
            (*pScreen->MarkOverlappedWindows) (pWin, pWin, NULL);

            if (HadBorder) {
                RegionPtr borderVisible;

                borderVisible = RegionCreate(NULL, 1);
                RegionSubtract(borderVisible,
                               &pWin->borderClip, &pWin->winSize);
                pWin->valdata->before.borderVisible = borderVisible;
                if (IN_UNDERLAY(pWin)) {
                    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
                    RegionPtr borderVisible2;

                    borderVisible2 = RegionCreate(NULL, 1);
                    RegionSubtract(borderVisible2,
                                   &pTree->borderClip, &pWin->winSize);
                    pTree->valdata->borderVisible = borderVisible2;
                }
            }
        }
        (*pScreen->ValidateTree) (pWin->parent, pWin, VTOther);
        (*pScreen->HandleExposures) (pWin->parent);

        if (pScreen->PostValidateTree)
            (*pScreen->PostValidateTree) (pWin->parent, pWin, VTOther);
    }
    if (pWin->realized)
        WindowsRestructured();
}

/*  We need this as an addition since the xf86 common code doesn't
    know about the second tree which is static to this file.  */

void
miOverlaySetRootClip(ScreenPtr pScreen, Bool enable)
{
    WindowPtr pRoot = pScreen->root;
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pRoot);

    MARK_UNDERLAY(pRoot);

    if (enable) {
        BoxRec box;

        box.x1 = 0;
        box.y1 = 0;
        box.x2 = pScreen->width;
        box.y2 = pScreen->height;

        RegionReset(&pTree->borderClip, &box);
    }
    else
        RegionEmpty(&pTree->borderClip);

    RegionBreak(&pTree->clipList);
}

static void
miOverlayClearToBackground(WindowPtr pWin,
                           int x, int y, int w, int h, Bool generateExposures)
{
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
    BoxRec box;
    RegionRec reg;
    ScreenPtr pScreen = pWin->drawable.pScreen;
    miOverlayScreenPtr pScreenPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
    RegionPtr clipList;
    BoxPtr extents;
    int x1, y1, x2, y2;

    x1 = pWin->drawable.x + x;
    y1 = pWin->drawable.y + y;
    if (w)
        x2 = x1 + (int) w;
    else
        x2 = x1 + (int) pWin->drawable.width - (int) x;
    if (h)
        y2 = y1 + h;
    else
        y2 = y1 + (int) pWin->drawable.height - (int) y;

    clipList = ((*pScreenPriv->InOverlay) (pWin)) ? &pWin->clipList :
        &pTree->clipList;

    extents = RegionExtents(clipList);

    if (x1 < extents->x1)
        x1 = extents->x1;
    if (x2 > extents->x2)
        x2 = extents->x2;
    if (y1 < extents->y1)
        y1 = extents->y1;
    if (y2 > extents->y2)
        y2 = extents->y2;

    if (x2 <= x1 || y2 <= y1)
        x2 = x1 = y2 = y1 = 0;

    box.x1 = x1;
    box.x2 = x2;
    box.y1 = y1;
    box.y2 = y2;

    RegionInit(&reg, &box, 1);

    RegionIntersect(&reg, &reg, clipList);
    if (generateExposures)
        (*pScreen->WindowExposures) (pWin, &reg);
    else if (pWin->backgroundState != None)
        pScreen->PaintWindow(pWin, &reg, PW_BACKGROUND);
    RegionUninit(&reg);
}

/****************************************************************/

/* not used */
Bool
miOverlayGetPrivateClips(WindowPtr pWin,
                         RegionPtr *borderClip, RegionPtr *clipList)
{
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);

    if (pTree) {
        *borderClip = &(pTree->borderClip);
        *clipList = &(pTree->clipList);
        return TRUE;
    }

    *borderClip = *clipList = NULL;

    return FALSE;
}

void
miOverlaySetTransFunction(ScreenPtr pScreen, miOverlayTransFunc transFunc)
{
    MIOVERLAY_GET_SCREEN_PRIVATE(pScreen)->MakeTransparent = transFunc;
}

Bool
miOverlayCopyUnderlay(ScreenPtr pScreen)
{
    return MIOVERLAY_GET_SCREEN_PRIVATE(pScreen)->copyUnderlay;
}

void
miOverlayComputeCompositeClip(GCPtr pGC, WindowPtr pWin)
{
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
    RegionPtr pregWin;
    Bool freeTmpClip, freeCompClip;

    if (!pTree) {
        miComputeCompositeClip(pGC, &pWin->drawable);
        return;
    }

    if (pGC->subWindowMode == IncludeInferiors) {
        pregWin = RegionCreate(NullBox, 1);
        freeTmpClip = TRUE;
        if (pWin->parent || (screenIsSaved != SCREEN_SAVER_ON) ||
            !HasSaverWindow(pGC->pScreen)) {
            RegionIntersect(pregWin, &pTree->borderClip, &pWin->winSize);
        }
    }
    else {
        pregWin = &pTree->clipList;
        freeTmpClip = FALSE;
    }
    freeCompClip = pGC->freeCompClip;
    if (!pGC->clientClip) {
        if (freeCompClip)
            RegionDestroy(pGC->pCompositeClip);
        pGC->pCompositeClip = pregWin;
        pGC->freeCompClip = freeTmpClip;
    }
    else {
        RegionTranslate(pGC->clientClip,
                        pWin->drawable.x + pGC->clipOrg.x,
                        pWin->drawable.y + pGC->clipOrg.y);

        if (freeCompClip) {
            RegionIntersect(pGC->pCompositeClip, pregWin, pGC->clientClip);
            if (freeTmpClip)
                RegionDestroy(pregWin);
        }
        else if (freeTmpClip) {
            RegionIntersect(pregWin, pregWin, pGC->clientClip);
            pGC->pCompositeClip = pregWin;
        }
        else {
            pGC->pCompositeClip = RegionCreate(NullBox, 0);
            RegionIntersect(pGC->pCompositeClip, pregWin, pGC->clientClip);
        }
        pGC->freeCompClip = TRUE;
        RegionTranslate(pGC->clientClip,
                        -(pWin->drawable.x + pGC->clipOrg.x),
                        -(pWin->drawable.y + pGC->clipOrg.y));
    }
}

Bool
miOverlayCollectUnderlayRegions(WindowPtr pWin, RegionPtr *region)
{
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);

    if (pTree) {
        *region = &pTree->borderClip;
        return FALSE;
    }

    *region = RegionCreate(NullBox, 0);

    CollectUnderlayChildrenRegions(pWin, *region);

    return TRUE;
}

static miOverlayTreePtr
DoLeaf(WindowPtr pWin, miOverlayTreePtr parent, miOverlayTreePtr prevSib)
{
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);

    pTree->parent = parent;
    pTree->firstChild = NULL;
    pTree->lastChild = NULL;
    pTree->prevSib = prevSib;
    pTree->nextSib = NULL;

    if (prevSib)
        prevSib->nextSib = pTree;

    if (!parent->firstChild)
        parent->firstChild = parent->lastChild = pTree;
    else if (parent->lastChild == prevSib)
        parent->lastChild = pTree;

    return pTree;
}

static void
RebuildTree(WindowPtr pWin)
{
    miOverlayTreePtr parent, prevSib, tChild;
    WindowPtr pChild;

    prevSib = tChild = NULL;

    pWin = pWin->parent;

    while (IN_OVERLAY(pWin))
        pWin = pWin->parent;

    parent = MIOVERLAY_GET_WINDOW_TREE(pWin);

    pChild = pWin->firstChild;
    parent->firstChild = parent->lastChild = NULL;

    while (1) {
        if (IN_UNDERLAY(pChild))
            prevSib = tChild = DoLeaf(pChild, parent, prevSib);

        if (pChild->firstChild) {
            if (IN_UNDERLAY(pChild)) {
                parent = tChild;
                prevSib = NULL;
            }
            pChild = pChild->firstChild;
            continue;
        }

        while (!pChild->nextSib) {
            pChild = pChild->parent;
            if (pChild == pWin)
                return;
            if (IN_UNDERLAY(pChild)) {
                prevSib = tChild = MIOVERLAY_GET_WINDOW_TREE(pChild);
                parent = tChild->parent;
            }
        }

        pChild = pChild->nextSib;
    }
}

static Bool
HasUnderlayChildren(WindowPtr pWin)
{
    WindowPtr pChild;

    if (!(pChild = pWin->firstChild))
        return FALSE;

    while (1) {
        if (IN_UNDERLAY(pChild))
            return TRUE;

        if (pChild->firstChild) {
            pChild = pChild->firstChild;
            continue;
        }

        while (!pChild->nextSib && (pWin != pChild))
            pChild = pChild->parent;

        if (pChild == pWin)
            break;

        pChild = pChild->nextSib;
    }

    return FALSE;
}

static Bool
CollectUnderlayChildrenRegions(WindowPtr pWin, RegionPtr pReg)
{
    WindowPtr pChild;
    miOverlayTreePtr pTree;
    Bool hasUnderlay;

    if (!(pChild = pWin->firstChild))
        return FALSE;

    hasUnderlay = FALSE;

    while (1) {
        if ((pTree = MIOVERLAY_GET_WINDOW_TREE(pChild))) {
            RegionAppend(pReg, &pTree->borderClip);
            hasUnderlay = TRUE;
        }
        else if (pChild->firstChild) {
            pChild = pChild->firstChild;
            continue;
        }

        while (!pChild->nextSib && (pWin != pChild))
            pChild = pChild->parent;

        if (pChild == pWin)
            break;

        pChild = pChild->nextSib;
    }

    if (hasUnderlay) {
        Bool overlap;

        RegionValidate(pReg, &overlap);
    }

    return hasUnderlay;
}

static void
MarkUnderlayWindow(WindowPtr pWin)
{
    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);

    if (pTree->valdata)
        return;
    pTree->valdata =
        (miOverlayValDataPtr) xnfalloc(sizeof(miOverlayValDataRec));
    pTree->valdata->oldAbsCorner.x = pWin->drawable.x;
    pTree->valdata->oldAbsCorner.y = pWin->drawable.y;
    pTree->valdata->borderVisible = NullRegion;
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d847 2
a848 2
                        miPaintWindow(pTree->pWin, &mival->borderExposed,
                                      PW_BORDER);
d886 2
a887 1
                    miPaintWindow(pChild, &val->after.borderExposed, PW_BORDER);
d986 1
a992 1
            ScreenPtr pScreen = pWin->drawable.pScreen;
d1011 1
a1011 1
        miPaintWindow(pWin, prgn, PW_BACKGROUND);
d1610 1
a1610 1
        miPaintWindow(pWin, &reg, PW_BACKGROUND);
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d82 1
a82 1
static void miOverlayWindowExposures(WindowPtr, RegionPtr, RegionPtr);
d830 1
a830 1
    void (*WindowExposures) (WindowPtr, RegionPtr, RegionPtr);
d852 1
a852 2
                    (*WindowExposures) (pTree->pWin, &mival->exposed,
                                        NullRegion);
d888 1
a888 1
                (*WindowExposures) (pChild, &val->after.exposed, NullRegion);
d982 1
a982 2
miOverlayWindowExposures(WindowPtr pWin,
                         RegionPtr prgn, RegionPtr other_exposed)
d986 1
a986 2
    if ((prgn && !RegionNil(prgn)) ||
        (exposures && !RegionNil(exposures)) || other_exposed) {
d988 3
a990 14
        int clientInterested;

        clientInterested = (pWin->eventMask | wOtherEventMasks(pWin)) &
            ExposureMask;
        if (other_exposed) {
            if (exposures) {
                RegionUnion(other_exposed, exposures, other_exposed);
                if (exposures != prgn)
                    RegionDestroy(exposures);
            }
            exposures = other_exposed;
        }
        if (clientInterested && exposures &&
            (RegionNumRects(exposures) > RECTLIMIT)) {
d995 4
a998 10
            box = *RegionExtents(exposures);
            if (exposures == prgn) {
                exposures = &expRec;
                RegionInit(exposures, &box, 1);
                RegionReset(prgn, &box);
            }
            else {
                RegionReset(exposures, &box);
                RegionUnion(prgn, prgn, exposures);
            }
d1010 2
a1011 3
        if (prgn && !RegionNil(prgn))
            miPaintWindow(pWin, prgn, PW_BACKGROUND);
        if (clientInterested && exposures && !RegionNil(exposures))
d1014 1
a1014 1
        if (exposures == &expRec) {
d1016 1
a1016 5
        }
        else if (exposures && exposures != prgn && exposures != other_exposed)
            RegionDestroy(exposures);
        if (prgn)
            RegionEmpty(prgn);
a1017 2
    else if (exposures && exposures != prgn)
        RegionDestroy(exposures);
a1466 1

a1467 3
        }

        if (WasViewable) {
a1563 1
    RegionPtr pBSReg = NullRegion;
d1607 1
a1607 1
        (*pScreen->WindowExposures) (pWin, &reg, pBSReg);
a1610 2
    if (pBSReg)
        RegionDestroy(pBSReg);
d1670 1
a1670 1
    if (pGC->clientClipType == CT_NONE) {
@


1.7
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d1053 1
a1053 1
miOverlayRecomputeExposures(WindowPtr pWin, pointer value)
d1407 1
a1407 1
                             (pointer) (&TwoRegions));
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d69 1
a69 1
static Bool miOverlayCloseScreen(int, ScreenPtr);
d163 1
a163 1
miOverlayCloseScreen(int i, ScreenPtr pScreen)
d175 1
a175 1
    return (*pScreen->CloseScreen) (i, pScreen);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a20 1

d22 4
a25 4
   RegionRec 	exposed;
   RegionRec	borderExposed;
   RegionPtr	borderVisible;
   DDXPointRec	oldAbsCorner;
d29 10
a38 10
   WindowPtr		pWin;
   struct _TreeRec 	*parent;
   struct _TreeRec 	*firstChild; 
   struct _TreeRec 	*lastChild; 
   struct _TreeRec 	*prevSib; 
   struct _TreeRec 	*nextSib;
   RegionRec 		borderClip;
   RegionRec 		clipList;
   unsigned		visibility;
   miOverlayValDataPtr  valdata;
d42 1
a42 1
   miOverlayTreePtr	tree;
d46 9
a54 9
   CloseScreenProcPtr   	CloseScreen;
   CreateWindowProcPtr  	CreateWindow;
   DestroyWindowProcPtr 	DestroyWindow;
   UnrealizeWindowProcPtr	UnrealizeWindow;
   RealizeWindowProcPtr		RealizeWindow;
   miOverlayTransFunc		MakeTransparent;
   miOverlayInOverlayFunc	InOverlay;
   Bool				underlayMarked;
   Bool				copyUnderlay;
d58 1
d61 1
d77 1
a77 1
static Bool miOverlayMarkOverlappedWindows(WindowPtr, WindowPtr, WindowPtr*);
d84 1
a84 1
					unsigned int, WindowPtr);
d108 5
a112 8
miInitOverlay(
    ScreenPtr pScreen, 
    miOverlayInOverlayFunc inOverlayFunc,
    miOverlayTransFunc transFunc
){
    miOverlayScreenPtr	pScreenPriv;

    if(!inOverlayFunc || !transFunc) return FALSE;
d114 2
a115 2
    if(!dixRegisterPrivateKey(&miOverlayWindowKeyRec, PRIVATE_WINDOW, sizeof(miOverlayWindowRec)))
	return FALSE;
d117 3
a119 2
    if(!dixRegisterPrivateKey(&miOverlayScreenKeyRec, PRIVATE_SCREEN, 0))
	return FALSE;
d121 5
a125 2
    if(!(pScreenPriv = malloc(sizeof(miOverlayScreenRec))))
	return FALSE;
a132 1

d162 1
a162 2

static Bool 
d165 1
a165 1
   miOverlayScreenPtr pScreenPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
d167 5
a171 5
   pScreen->CloseScreen = pScreenPriv->CloseScreen; 
   pScreen->CreateWindow = pScreenPriv->CreateWindow;
   pScreen->DestroyWindow = pScreenPriv->DestroyWindow;
   pScreen->UnrealizeWindow = pScreenPriv->UnrealizeWindow;
   pScreen->RealizeWindow = pScreenPriv->RealizeWindow;
d173 1
a173 1
   free(pScreenPriv);
d175 1
a175 1
   return (*pScreen->CloseScreen)(i, pScreen);
d178 1
a178 2

static Bool 
d189 3
a191 3
    if(!pWin->parent || !((*pScreenPriv->InOverlay)(pWin))) {
	if(!(pTree = (miOverlayTreePtr)calloc(1, sizeof(miOverlayTreeRec))))
	   return FALSE;
d194 4
a197 4
    if(pScreenPriv->CreateWindow) {
	pScreen->CreateWindow = pScreenPriv->CreateWindow;
	result = (*pScreen->CreateWindow)(pWin);
	pScreen->CreateWindow = miOverlayCreateWindow;
d199 1
a199 1
	
d201 22
a222 18
	if(result) {
	    pTree->pWin = pWin;
	    pTree->visibility = VisibilityNotViewable;
	    pWinPriv->tree = pTree;
	    if(pWin->parent) {
		RegionNull(&(pTree->borderClip));
		RegionNull(&(pTree->clipList));
		RebuildTree(pWin);
	    } else {
		BoxRec fullBox;
		fullBox.x1 = 0;
		fullBox.y1 = 0;
		fullBox.x2 = pScreen->width;
		fullBox.y2 = pScreen->height;
		RegionInit(&(pTree->borderClip), &fullBox, 1);
		RegionInit(&(pTree->clipList), &fullBox, 1);
	    }
	} else free(pTree);
d228 1
a228 2

static Bool 
d237 19
a255 19
	if(pTree->prevSib)
	   pTree->prevSib->nextSib = pTree->nextSib;
	else if(pTree->parent)
	   pTree->parent->firstChild = pTree->nextSib;

	if(pTree->nextSib)
	   pTree->nextSib->prevSib = pTree->prevSib;
	else if(pTree->parent)
	   pTree->parent->lastChild = pTree->prevSib;

	RegionUninit(&(pTree->borderClip));
	RegionUninit(&(pTree->clipList));
	free(pTree);
    }

    if(pScreenPriv->DestroyWindow) {
	pScreen->DestroyWindow = pScreenPriv->DestroyWindow;
	result = (*pScreen->DestroyWindow)(pWin);
	pScreen->DestroyWindow = miOverlayDestroyWindow;
d261 1
a261 1
static Bool 
d269 2
a270 1
    if(pTree) pTree->visibility = VisibilityNotViewable;
d272 4
a275 4
    if(pScreenPriv->UnrealizeWindow) {
	pScreen->UnrealizeWindow = pScreenPriv->UnrealizeWindow;
	result = (*pScreen->UnrealizeWindow)(pWin);
	pScreen->UnrealizeWindow = miOverlayUnrealizeWindow;
d281 1
a281 2

static Bool 
d288 4
a291 4
    if(pScreenPriv->RealizeWindow) {
	pScreen->RealizeWindow = pScreenPriv->RealizeWindow;
	result = (*pScreen->RealizeWindow)(pWin);
	pScreen->RealizeWindow = miOverlayRealizeWindow;
d296 7
a302 7
    if(result && !pWin->parent && !((*pScreenPriv->InOverlay)(pWin)))
    {
	BoxRec box;
	box.x1 = box.y1 = 0;
	box.x2 = pWin->drawable.width;
	box.y2 = pWin->drawable.height;
	(*pScreenPriv->MakeTransparent)(pScreen, 1, &box);
d308 1
a308 2

static void 
d311 4
a314 4
    if(IN_UNDERLAY(pWin) || HasUnderlayChildren(pWin)) {
	/* This could probably be more optimal */
	RebuildTree(pWin->drawable.pScreen->root->firstChild);
    }	
d317 1
a317 1
static void 
d320 4
a323 4
    if(IN_UNDERLAY(pWin) || HasUnderlayChildren(pWin)) {
	/* This could probably be more optimal */
	RebuildTree(pWin);
    }	
a325 1

d327 3
a329 5
miOverlayMarkOverlappedWindows(
    WindowPtr pWin,
    WindowPtr pFirst,
    WindowPtr *pLayerWin
){
d334 1
a334 1
    
d337 2
a338 1
    if(pLayerWin) *pLayerWin = pWin; /* hah! */
d344 5
a348 4
    if((pChild = pFirst)) {
	pLast = pChild->parent->lastChild;
	while (1) {
	    if (pChild == pWin) markAll = TRUE;
d350 2
a351 2
	    if(doUnderlay && IN_UNDERLAY(pChild))
		pTree = MIOVERLAY_GET_WINDOW_TREE(pChild);
d353 1
a353 1
	    if(pChild->viewable) {
d355 1
a355 1
                    SetWinSize (pChild);
d357 26
a382 1
		    SetBorderSize (pChild);
d384 17
a400 53
	    	if (markAll || 
		    RegionContainsRect(&pChild->borderSize, box))
		{
		    MARK_OVERLAY(pChild);
		    overMarked = TRUE;
		    if(doUnderlay && IN_UNDERLAY(pChild)) {
			MARK_UNDERLAY(pChild);
			underMarked = TRUE;
		    }
		    if (pChild->firstChild) {
			pChild = pChild->firstChild;
			continue;
		    }
		}
	    }
	    while (!pChild->nextSib && (pChild != pLast)) {
		pChild = pChild->parent;
		if(doUnderlay && IN_UNDERLAY(pChild))
		    pTree = MIOVERLAY_GET_WINDOW_TREE(pChild);
	    }

	    if(pChild == pWin) markAll = FALSE;

	    if (pChild == pLast) break;

	    pChild = pChild->nextSib;
	}
	if(overMarked)
	    MARK_OVERLAY(pWin->parent);
    } 

    if(doUnderlay && !pTree) {
	if(!(pTree = MIOVERLAY_GET_WINDOW_TREE(pWin))) {
 	    pChild = pWin->lastChild;
	    while(1) {
		if((pTree = MIOVERLAY_GET_WINDOW_TREE(pChild)))
		    break;

		if(pChild->lastChild) {
		    pChild = pChild->lastChild;
		    continue;
		}

		while(!pChild->prevSib) pChild = pChild->parent;

		pChild = pChild->prevSib;
	    }
	}
    }
   
    if(pTree && pTree->nextSib) {
	tChild = pTree->parent->lastChild;
	tLast = pTree->nextSib;	
d402 14
a415 2
	while(1) {
	    if(tChild->pWin->viewable) { 
d417 1
a417 1
                    SetWinSize (tChild->pWin);
d419 1
a419 1
		    SetBorderSize (tChild->pWin);
d421 5
a425 6
		if(RegionContainsRect(&(tChild->pWin->borderSize), box))
	        {
		    MARK_UNDERLAY(tChild->pWin);
		    underMarked = TRUE;
	        }
	    }
d427 4
a430 4
	    if(tChild->lastChild) {
		tChild = tChild->lastChild;
		continue;
	    }
d432 2
a433 2
	    while(!tChild->prevSib && (tChild != tLast))
		tChild = tChild->parent;
d435 2
a436 1
	    if(tChild == tLast) break;
d438 2
a439 2
	    tChild = tChild->prevSib;
	}
d442 5
a446 4
    if(underMarked) {
	ScreenPtr pScreen = pWin->drawable.pScreen;
	MARK_UNDERLAY(pTree->parent->pWin);
	MIOVERLAY_GET_SCREEN_PRIVATE(pScreen)->underlayMarked = TRUE;	
a451 1

d453 3
a455 6
miOverlayComputeClips(
    WindowPtr pParent, 
    RegionPtr universe,
    VTKind kind,
    RegionPtr exposed
){
d467 4
a470 3
    dx = (int) pParent->drawable.x + (int) pParent->drawable.width + 
						wBorderWidth(pParent);
    if (dx > 32767) dx = 32767;
d472 4
a475 3
    dy = (int) pParent->drawable.y + (int) pParent->drawable.height + 
						wBorderWidth(pParent);
    if (dy > 32767) dy = 32767;
d477 1
a477 1
  
d480 26
a505 27
	case rgnIN:
	    newVis = VisibilityUnobscured;
	    break;
	case rgnPART:
	    newVis = VisibilityPartiallyObscured;
	    {
		RegionPtr   pBounding;

		if ((pBounding = wBoundingShape (pParent))) {
		    switch (miShapedWindowIn (universe, pBounding,
					      &borderSize,
					      pParent->drawable.x,
 					      pParent->drawable.y))
		    {
		    case rgnIN:
			newVis = VisibilityUnobscured;
			break;
		    case rgnOUT:
			newVis = VisibilityFullyObscured;
			break;
		    }
		}
	    }
	    break;
	default:
	    newVis = VisibilityFullyObscured;
	    break;
d516 1
a516 1
	break;
d518 12
a529 13
	if ((oldVis == newVis) &&
	    ((oldVis == VisibilityFullyObscured) ||
	     (oldVis == VisibilityUnobscured)))
	{
	    tChild = tParent;
	    while (1) {
		if (tChild->pWin->viewable) {
		    if (tChild->visibility != VisibilityFullyObscured) {
			RegionTranslate(&tChild->borderClip, dx, dy);
			RegionTranslate(&tChild->clipList, dx, dy);
		
			tChild->pWin->drawable.serialNumber = 
							 NEXT_SERIAL_NUMBER;
d531 25
a555 25
                            (* pScreen->ClipNotify) (tChild->pWin, dx, dy);
		    }
		    if (tChild->valdata) {
			RegionNull(&tChild->valdata->borderExposed);
			if (HasParentRelativeBorder(tChild->pWin)){
			    RegionSubtract(&tChild->valdata->borderExposed,
					   &tChild->borderClip,
					   &tChild->pWin->winSize);
			}
			RegionNull(&tChild->valdata->exposed);
		    }
		    if (tChild->firstChild) {
			tChild = tChild->firstChild;
			continue;
		    }
		}
		while (!tChild->nextSib && (tChild != tParent))
		    tChild = tChild->parent;
		if (tChild == tParent)
		    break;
		tChild = tChild->nextSib;
	    }
	    return;
	}
	/* fall through */
d557 5
a561 5
    	if (dx || dy)  {
	    RegionTranslate(&tParent->borderClip, dx, dy);
	    RegionTranslate(&tParent->clipList, dx, dy);
    	} 
	break;
d563 3
a565 3
	RegionEmpty(&tParent->borderClip);
	RegionEmpty(&tParent->clipList);
	break;
d572 14
a585 13
    if (HasBorder (pParent)) {
    	if (borderVisible) {
	    RegionSubtract(exposed, universe, borderVisible);
	    RegionDestroy(borderVisible);
    	} else
	    RegionSubtract(exposed, universe, &tParent->borderClip);

	if (HasParentRelativeBorder(pParent) && (dx || dy))
	    RegionSubtract(&tParent->valdata->borderExposed,
				  universe, &pParent->winSize);
	else
	    RegionSubtract(&tParent->valdata->borderExposed,
			       exposed, &pParent->winSize);
d587 2
a588 2
	RegionCopy(&tParent->borderClip, universe);
	RegionIntersect(universe, universe, &pParent->winSize);
d591 1
a591 1
	RegionCopy(&tParent->borderClip, universe);
d594 9
a602 2
	RegionNull(&childUniverse);
	RegionNull(&childUnion);
d604 18
a621 28
	for (; tChild; tChild = tChild->nextSib) {
	    if (tChild->pWin->viewable)
		RegionAppend(&childUnion, &tChild->pWin->borderSize);
	}

	RegionValidate(&childUnion, &overlap);

	for (tChild = tParent->firstChild;
	     tChild;
	     tChild = tChild->nextSib)
 	{
	    if (tChild->pWin->viewable) {
		if (tChild->valdata) {
		    RegionIntersect(&childUniverse, universe,
					    &tChild->pWin->borderSize);
		    miOverlayComputeClips (tChild->pWin, &childUniverse, 
						kind, exposed);
		}
		if (overlap)
		    RegionSubtract(universe, universe,
					  &tChild->pWin->borderSize);
	    }
	}
	if (!overlap)
	    RegionSubtract(universe, universe, &childUnion);
	RegionUninit(&childUnion);
	RegionUninit(&childUniverse);
    } 
d623 2
a624 4
    if (oldVis == VisibilityFullyObscured ||
	oldVis == VisibilityNotViewable)
    {
	RegionCopy(&tParent->valdata->exposed, universe);
d627 3
a629 4
	     newVis != VisibilityNotViewable)
    {
	RegionSubtract(&tParent->valdata->exposed,
			       universe, &tParent->clipList);
d631 1
a631 1
    
d634 1
a634 1
	RegionRec   tmp;
d636 3
a638 3
	tmp = tParent->clipList;
	tParent->clipList = *universe;
	*universe = tmp;
d644 1
a644 1
        (* pScreen->ClipNotify) (pParent, dx, dy);
d647 1
a647 2

static void 
d652 1
a652 1
   
d657 23
a679 1
    if(!(pChild = pWin->firstChild)) return;
d681 9
a689 27
    for( ; pChild; pChild = pChild->nextSib) {
	if(pChild->valdata == UnmapValData) {
	    if(IN_UNDERLAY(pChild)) {
		pTree = MIOVERLAY_GET_WINDOW_TREE(pChild);
		pTree->valdata = (miOverlayValDataPtr)UnmapValData; 
		continue;
	    } else {	
	        if(!(pGrandChild = pChild->firstChild))
		   continue;

		while(1) {
		    if(IN_UNDERLAY(pGrandChild)) {
			pTree = MIOVERLAY_GET_WINDOW_TREE(pGrandChild);
			pTree->valdata = (miOverlayValDataPtr)UnmapValData; 
		    } else if(pGrandChild->firstChild) {	
			pGrandChild = pGrandChild->firstChild;
			continue;
		    }

		    while(!pGrandChild->nextSib && (pGrandChild != pChild))
			pGrandChild = pGrandChild->parent;

		    if(pChild == pGrandChild) break;
		
		    pGrandChild = pGrandChild->nextSib;
		}
	    }
d693 4
a696 4
    if(pTree) {
	MARK_UNDERLAY(pTree->parent->pWin);
	MIOVERLAY_GET_SCREEN_PRIVATE(
		pWin->drawable.pScreen)->underlayMarked = TRUE;
d701 3
a703 5
miOverlayMarkUnrealizedWindow(
    WindowPtr pChild,
    WindowPtr pWin,
    Bool fromConfigure
){
d705 1
a705 1
	miOverlayTreePtr pTree;
d709 1
a709 1
            (* pChild->drawable.pScreen->ClipNotify)(pChild, 0, 0);
d711 6
a716 6
	if((pTree = MIOVERLAY_GET_WINDOW_TREE(pChild))) {
	    if(pTree->valdata != (miOverlayValDataPtr)UnmapValData) {
		RegionEmpty(&pTree->clipList);
		RegionEmpty(&pTree->borderClip);
	    }
	}
d720 4
a723 7

static int 
miOverlayValidateTree(
    WindowPtr pParent,
    WindowPtr pChild,   /* first child effected */
    VTKind    kind
){
d731 2
a732 2
    if(!pPriv->underlayMarked)
	goto SKIP_UNDERLAY;
d734 2
a735 1
    if (!pChild) pChild = pParent->firstChild;
d743 2
a744 2
    while(IN_OVERLAY(newParent))
    	newParent = newParent->parent;
d748 2
a749 2
    if(IN_UNDERLAY(pChild))
	tChild = MIOVERLAY_GET_WINDOW_TREE(pChild);
d751 6
a756 1
	tChild = tParent->firstChild;
a757 8
    if (RegionBroken(&tParent->clipList) &&
        !RegionBroken(&tParent->borderClip))
    {
	kind = VTBroken;
	RegionCopy(&totalClip, &tParent->borderClip);
	RegionIntersect(&totalClip, &totalClip,
						 &tParent->pWin->winSize);
        
d760 2
a761 3
                RegionSubtract(&totalClip, &totalClip,
					&tWin->pWin->borderSize);
        }        
d763 21
a783 20
    } else {
	for(tWin = tChild; tWin; tWin = tWin->nextSib) {
	    if(tWin->valdata)
		RegionAppend(&totalClip, &tWin->borderClip);
	}
	RegionValidate(&totalClip, &overlap);
    }

    if(kind != VTStack)
	RegionUnion(&totalClip, &totalClip, &tParent->clipList);
	
    for(tWin = tChild; tWin; tWin = tWin->nextSib) {
	if(tWin->valdata) {
	    if(tWin->pWin->viewable) {
		RegionIntersect(&childClip, &totalClip,
					&tWin->pWin->borderSize);
		miOverlayComputeClips(tWin->pWin, &childClip, kind, &exposed);
		RegionSubtract(&totalClip, &totalClip,
					&tWin->pWin->borderSize);
	    } else {  /* Means we are unmapping */
d786 3
a788 3
		tWin->valdata = NULL;
	    }
	}
d793 3
a795 3
    if(!((*pPriv->InOverlay)(newParent))) {
	RegionNull(&tParent->valdata->exposed);
	RegionNull(&tParent->valdata->borderExposed);
d800 1
a800 1
	break;
d802 4
a805 4
    	if(!((*pPriv->InOverlay)(newParent))) 
	    RegionSubtract(&tParent->valdata->exposed, &totalClip,
						&tParent->clipList);
	/* fall through */
d807 4
a810 4
	RegionCopy(&tParent->clipList, &totalClip);
    	if(!((*pPriv->InOverlay)(newParent))) 
	    newParent->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	break;
d816 1
a816 1
SKIP_UNDERLAY:
a822 1

d830 1
a830 1
    void (* WindowExposures)(WindowPtr, RegionPtr, RegionPtr);
d833 35
a867 34
    if(pPriv->underlayMarked) {
	miOverlayTreePtr pTree;
	miOverlayValDataPtr mival;

	pChild = pWin;
	while(IN_OVERLAY(pChild))
	    pChild = pChild->parent;

	pTree = MIOVERLAY_GET_WINDOW_TREE(pChild);

	while (1) {
	    if((mival = pTree->valdata)) {
		if(!((*pPriv->InOverlay)(pTree->pWin))) {
		    if (RegionNotEmpty(&mival->borderExposed)) {
			miPaintWindow(pTree->pWin, &mival->borderExposed,
				      PW_BORDER);
		    }
		    RegionUninit(&mival->borderExposed);

		    (*WindowExposures)(pTree->pWin,&mival->exposed,NullRegion);
		    RegionUninit(&mival->exposed);
		}
		free(mival);
		pTree->valdata = NULL;
		if (pTree->firstChild) {
		    pTree = pTree->firstChild;
		    continue;
		}
	    }
	    while (!pTree->nextSib && (pTree->pWin != pChild))
	    	pTree = pTree->parent;
	    if (pTree->pWin == pChild)
		break;
	    pTree = pTree->nextSib;
d869 1
a869 1
	pPriv->underlayMarked = FALSE;
d874 31
a904 33
	if ( (val = pChild->valdata) ) {
	    if(!((*pPriv->InOverlay)(pChild))) {
		RegionUnion(&val->after.exposed, &val->after.exposed,
			&val->after.borderExposed);

		if (RegionNotEmpty(&val->after.exposed)) {
		   (*(MIOVERLAY_GET_SCREEN_PRIVATE(pScreen)->MakeTransparent))(
				pScreen, 
				RegionNumRects(&val->after.exposed),
				RegionRects(&val->after.exposed));
		}
	    } else {
		if (RegionNotEmpty(&val->after.borderExposed)) {
			miPaintWindow(pChild, &val->after.borderExposed,
				      PW_BORDER);
		}
		(*WindowExposures)(pChild, &val->after.exposed, NullRegion);
	    }
	    RegionUninit(&val->after.borderExposed);
	    RegionUninit(&val->after.exposed);
	    free(val);
	    pChild->valdata = NULL;
	    if (pChild->firstChild)
	    {
		pChild = pChild->firstChild;
		continue;
	    }
	}
	while (!pChild->nextSib && (pChild != pWin))
	    pChild = pChild->parent;
	if (pChild == pWin)
	    break;
	pChild = pChild->nextSib;
a907 1

d909 3
a911 7
miOverlayMoveWindow(
    WindowPtr pWin,
    int x,
    int y,
    WindowPtr pNextSib,
    VTKind kind
){
d915 1
a915 1
    Bool WasViewable = (Bool)(pWin->viewable);
d921 2
a922 2
       return ;
    bw = wBorderWidth (pWin);
d927 16
a942 15
	RegionNull(&overReg);
	RegionNull(&underReg);
	if(pTree) {
	    RegionCopy(&overReg, &pWin->borderClip);
	    RegionCopy(&underReg, &pTree->borderClip);
        } else {
	    RegionCopy(&overReg, &pWin->borderClip);
	    CollectUnderlayChildrenRegions(pWin, &underReg);
	}
	(*pScreen->MarkOverlappedWindows)(pWin, pWin, NULL);
    }
    pWin->origin.x = x + (int)bw;
    pWin->origin.y = y + (int)bw;
    x = pWin->drawable.x = pParent->drawable.x + x + (int)bw;
    y = pWin->drawable.y = pParent->drawable.y + y + (int)bw;
d944 2
a945 2
    SetWinSize (pWin);
    SetBorderSize (pWin);
d947 1
a947 1
    (*pScreen->PositionWindow)(pWin, x, y);
d954 1
a954 2
	miOverlayScreenPtr pPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
	(*pScreen->MarkOverlappedWindows) (pWin, windowToValidate, NULL);
d956 1
d958 12
a969 12
	(*pScreen->ValidateTree)(pWin->parent, NullWindow, kind);
	if(RegionNotEmpty(&underReg)) {
	    pPriv->copyUnderlay = TRUE;
	    (* pWin->drawable.pScreen->CopyWindow)(pWin, oldpt, &underReg);
	}
	RegionUninit(&underReg);
	if(RegionNotEmpty(&overReg)) {
	    pPriv->copyUnderlay = FALSE;
	    (* pWin->drawable.pScreen->CopyWindow)(pWin, oldpt, &overReg);
	}
	RegionUninit(&overReg);
	(*pScreen->HandleExposures)(pWin->parent);
d971 2
a972 2
	if (pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pWin->parent, NullWindow, kind);
d975 1
a975 1
	WindowsRestructured ();
d982 5
a986 7
static void 
miOverlayWindowExposures(
    WindowPtr pWin,
    RegionPtr prgn,
    RegionPtr other_exposed
){
    RegionPtr   exposures = prgn;
d989 17
a1005 19
	(exposures && !RegionNil(exposures)) || other_exposed)
    {
	RegionRec   expRec;
	int	    clientInterested;

	clientInterested = (pWin->eventMask|wOtherEventMasks(pWin)) &
		 	    ExposureMask;
	if (other_exposed) {
	    if (exposures) {
		RegionUnion(other_exposed, exposures, other_exposed);
		if (exposures != prgn)
		    RegionDestroy(exposures);
	    }
	    exposures = other_exposed;
	}
	if (clientInterested && exposures && 
	   (RegionNumRects(exposures) > RECTLIMIT))
	{
	    ScreenPtr pScreen = pWin->drawable.pScreen;
d1007 1
a1007 1
	    BoxRec box;
d1009 11
a1019 10
	    box = *RegionExtents(exposures);
	    if (exposures == prgn) {
		exposures = &expRec;
		RegionInit(exposures, &box, 1);
		RegionReset(prgn, &box);
	    } else {
		RegionReset(exposures, &box);
		RegionUnion(prgn, prgn, exposures);
	    }
	    /* This is the only reason why we are replacing mi's version
d1021 21
a1041 19
	    
	    if(!((*pPriv->InOverlay)(pWin))) {
		miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
		RegionIntersect(prgn, prgn, &pTree->clipList);
	    } else
		RegionIntersect(prgn, prgn, &pWin->clipList);
	}
	if (prgn && !RegionNil(prgn))
	    miPaintWindow(pWin, prgn, PW_BACKGROUND);
	if (clientInterested && exposures && !RegionNil(exposures))
	    miSendExposures(pWin, exposures,
			    pWin->drawable.x, pWin->drawable.y);
	if (exposures == &expRec) {
	    RegionUninit(exposures);
	} 
	else if (exposures && exposures != prgn && exposures != other_exposed)
	    RegionDestroy(exposures);
	if (prgn)
	    RegionEmpty(prgn);
d1044 1
a1044 1
	RegionDestroy(exposures);
a1046 1

d1048 3
a1050 3
   RegionPtr over;
   RegionPtr under;
} miOverlayTwoRegions; 
d1053 3
a1055 5
miOverlayRecomputeExposures (
    WindowPtr	pWin,
    pointer	value 
){
    miOverlayTwoRegions	*pValid = (miOverlayTwoRegions*)value;
d1059 24
a1082 23
	/*
	 * compute exposed regions of this window
	 */
	RegionSubtract(&pWin->valdata->after.exposed,
			&pWin->clipList, pValid->over);
	/*
	 * compute exposed regions of the border
	 */
	RegionSubtract(&pWin->valdata->after.borderExposed,
			     &pWin->borderClip, &pWin->winSize);
	RegionSubtract(&pWin->valdata->after.borderExposed,
			     &pWin->valdata->after.borderExposed, pValid->over);
    } 

    if(pTree && pTree->valdata) {
	RegionSubtract(&pTree->valdata->exposed,
			&pTree->clipList, pValid->under);
	RegionSubtract(&pTree->valdata->borderExposed,
			     &pTree->borderClip, &pWin->winSize);
	RegionSubtract(&pTree->valdata->borderExposed,
			     &pTree->valdata->borderExposed, pValid->under);    
    } else if (!pWin->valdata)
	return WT_NOMATCH;
d1088 4
a1091 6
miOverlayResizeWindow(
    WindowPtr pWin,
    int x, int y,
    unsigned int w, unsigned int h,
    WindowPtr pSib
){
d1095 1
a1095 1
    Bool WasViewable = (Bool)(pWin->viewable);
d1100 1
a1100 1
    int bw = wBorderWidth (pWin);
d1106 13
a1118 13
    RegionPtr	gravitate[StaticGravity + 1];
    RegionPtr	gravitate2[StaticGravity + 1];
    unsigned 	g;
    int		nx, ny;		/* destination x,y */
    int		newx, newy;	/* new inner window position */
    RegionPtr	pRegion = NULL;
    RegionPtr	destClip, destClip2;
    RegionPtr	oldWinClip = NULL, oldWinClip2 = NULL;	
    RegionPtr	borderVisible = NullRegion; 
    RegionPtr	borderVisible2 = NullRegion; 
    Bool	shrunk = FALSE; /* shrunk in an inner dimension */
    Bool	moved = FALSE;	/* window position changed */
    Bool	doUnderlay;
d1122 1
a1122 1
	return ;
d1128 81
a1208 88
    if (WasViewable)
    {
	/*
	 * save the visible region of the window
	 */
	oldRegion = RegionCreate(NullBox, 1);
	RegionCopy(oldRegion, &pWin->winSize);
	if(doUnderlay) {
	    oldRegion2 = RegionCreate(NullBox, 1);
	    RegionCopy(oldRegion2, &pWin->winSize);
	}

	/*
	 * categorize child windows into regions to be moved
	 */
	for (g = 0; g <= StaticGravity; g++)
	    gravitate[g] = gravitate2[g] = NULL;
	for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
	    g = pChild->winGravity;
	    if (g != UnmapGravity) {
		if (!gravitate[g])
		    gravitate[g] = RegionCreate(NullBox, 1);
		RegionUnion(gravitate[g],
				   gravitate[g], &pChild->borderClip);
		
		if(doUnderlay) {
		    if (!gravitate2[g])
			gravitate2[g] = RegionCreate(NullBox, 0);
		
		    if((tChild = MIOVERLAY_GET_WINDOW_TREE(pChild))) {
		        RegionUnion(gravitate2[g],
				   gravitate2[g], &tChild->borderClip);
		    } else 
			CollectUnderlayChildrenRegions(pChild, gravitate2[g]);
		}
	    } else {
		UnmapWindow(pChild, TRUE);
	    }
	}
	(*pScreen->MarkOverlappedWindows)(pWin, pWin, NULL);


	oldWinClip = oldWinClip2 = NULL;
	if (pWin->bitGravity != ForgetGravity) {
	    oldWinClip = RegionCreate(NullBox, 1);
	    RegionCopy(oldWinClip, &pWin->clipList);
	    if(pTree) {
		oldWinClip2 = RegionCreate(NullBox, 1);
		RegionCopy(oldWinClip2, &pTree->clipList);
	    }
	}
	/*
	 * if the window is changing size, borderExposed
	 * can't be computed correctly without some help.
	 */
	if (pWin->drawable.height > h || pWin->drawable.width > w)
	    shrunk = TRUE;

	if (newx != oldx || newy != oldy)
	    moved = TRUE;

	if ((pWin->drawable.height != h || pWin->drawable.width != w) &&
	    HasBorder (pWin))
	{
	    borderVisible = RegionCreate(NullBox, 1);
	    if(pTree)
		borderVisible2 = RegionCreate(NullBox, 1);
	    /* for tiled borders, we punt and draw the whole thing */
	    if (pWin->borderIsPixel || !moved)
	    {
		if (shrunk || moved)
		    RegionSubtract(borderVisible,
					  &pWin->borderClip,
					  &pWin->winSize);
		else
		    RegionCopy(borderVisible,
					    &pWin->borderClip);
		if(pTree) {
		    if (shrunk || moved)
			RegionSubtract(borderVisible,
					  &pTree->borderClip,
					  &pWin->winSize);
		    else
			RegionCopy(borderVisible,
					    &pTree->borderClip);
		}
	    }
	}
d1218 2
a1219 2
    SetWinSize (pWin);
    SetBorderSize (pWin);
d1221 2
a1222 2
    dw = (int)w - (int)width;
    dh = (int)h - (int)height;
d1226 1
a1226 1
    (*pScreen->PositionWindow)(pWin, x, y);
d1231 18
a1248 1
	pRegion = RegionCreate(NullBox, 1);
d1250 1
a1250 1
	(*pScreen->MarkOverlappedWindows)(pWin, pFirstChange, NULL);
d1252 3
a1254 4
	pWin->valdata->before.resized = TRUE;
	pWin->valdata->before.borderVisible = borderVisible;
	if(pTree)
	    pTree->valdata->borderVisible = borderVisible2;
d1256 55
d1312 93
a1404 9
	(*pScreen->ValidateTree)(pWin->parent, pFirstChange, VTOther);
	/*
	 * the entire window is trashed unless bitGravity
	 * recovers portions of it
	 */
	RegionCopy(&pWin->valdata->after.exposed, &pWin->clipList);
	if(pTree)
	    RegionCopy(&pTree->valdata->exposed, &pTree->clipList);
    }
d1406 3
a1408 1
    GravityTranslate (x, y, oldx, oldy, dw, dh, pWin->bitGravity, &nx, &ny);
d1410 30
a1439 3
    if (WasViewable) {
	miOverlayScreenPtr pPriv = MIOVERLAY_GET_SCREEN_PRIVATE(pScreen);
	miOverlayTwoRegions TwoRegions;
d1441 11
a1451 204
	/* avoid the border */
	if (HasBorder (pWin)) {
	    int	offx, offy, dx, dy;

	    /* kruft to avoid double translates for each gravity */
	    offx = 0;
	    offy = 0;
	    for (g = 0; g <= StaticGravity; g++) {
		if (!gravitate[g] && !gravitate2[g])
		    continue;

		/* align winSize to gravitate[g].
		 * winSize is in new coordinates,
		 * gravitate[g] is still in old coordinates */
		GravityTranslate (x, y, oldx, oldy, dw, dh, g, &nx, &ny);
		
		dx = (oldx - nx) - offx;
		dy = (oldy - ny) - offy;
		if (dx || dy) {
		    RegionTranslate(&pWin->winSize, dx, dy);
		    offx += dx;
		    offy += dy;
		}
		if(gravitate[g])
		    RegionIntersect(gravitate[g], gravitate[g],
				 &pWin->winSize);
		if(gravitate2[g])
		    RegionIntersect(gravitate2[g], gravitate2[g],
				 &pWin->winSize);
	    }
	    /* get winSize back where it belongs */
	    if (offx || offy)
		RegionTranslate(&pWin->winSize, -offx, -offy);
	}
	/*
	 * add screen bits to the appropriate bucket
	 */

	if (oldWinClip2)
	{
	    RegionCopy(pRegion, oldWinClip2);
	    RegionTranslate(pRegion, nx - oldx, ny - oldy);
	    RegionIntersect(oldWinClip2, pRegion, &pTree->clipList);

	    for (g = pWin->bitGravity + 1; g <= StaticGravity; g++) {
		if (gravitate2[g])
		    RegionSubtract(oldWinClip2, oldWinClip2,
					gravitate2[g]);
	    }
	    RegionTranslate(oldWinClip2, oldx - nx, oldy - ny);
	    g = pWin->bitGravity;
	    if (!gravitate2[g])
		gravitate2[g] = oldWinClip2;
	    else {
		RegionUnion(gravitate2[g],gravitate2[g],oldWinClip2);
		RegionDestroy(oldWinClip2);
	    }
	}

	if (oldWinClip)
	{
	    /*
	     * clip to new clipList
	     */
	    RegionCopy(pRegion, oldWinClip);
	    RegionTranslate(pRegion, nx - oldx, ny - oldy);
	    RegionIntersect(oldWinClip, pRegion, &pWin->clipList);
	    /*
	     * don't step on any gravity bits which will be copied after this
	     * region.	Note -- this assumes that the regions will be copied
	     * in gravity order.
	     */
	    for (g = pWin->bitGravity + 1; g <= StaticGravity; g++) {
		if (gravitate[g])
		    RegionSubtract(oldWinClip, oldWinClip,
					gravitate[g]);
	    }
	    RegionTranslate(oldWinClip, oldx - nx, oldy - ny);
	    g = pWin->bitGravity;
	    if (!gravitate[g])
		gravitate[g] = oldWinClip;
	    else {
		RegionUnion(gravitate[g], gravitate[g], oldWinClip);
		RegionDestroy(oldWinClip);
	    }
	}

	/*
	 * move the bits on the screen
	 */

	destClip = destClip2 = NULL;

	for (g = 0; g <= StaticGravity; g++) {
	    if (!gravitate[g] && !gravitate2[g])
		continue;

	    GravityTranslate (x, y, oldx, oldy, dw, dh, g, &nx, &ny);

	    oldpt.x = oldx + (x - nx);
	    oldpt.y = oldy + (y - ny);

	    /* Note that gravitate[g] is *translated* by CopyWindow */

	    /* only copy the remaining useful bits */

	    if(gravitate[g])
		RegionIntersect(gravitate[g],
				 gravitate[g], oldRegion);
	    if(gravitate2[g])
		RegionIntersect(gravitate2[g],
				 gravitate2[g], oldRegion2);

	    /* clip to not overwrite already copied areas */

	    if (destClip && gravitate[g]) {
		RegionTranslate(destClip, oldpt.x - x, oldpt.y - y);
		RegionSubtract(gravitate[g], gravitate[g], destClip);
		RegionTranslate(destClip, x - oldpt.x, y - oldpt.y);
	    }
	    if (destClip2 && gravitate2[g]) {
		RegionTranslate(destClip2, oldpt.x - x, oldpt.y - y);
		RegionSubtract(gravitate2[g],gravitate2[g],destClip2);
		RegionTranslate(destClip2, x - oldpt.x, y - oldpt.y);
	    }

	    /* and move those bits */

	    if (oldpt.x != x || oldpt.y != y) {
		if(gravitate2[g]) {
		    pPriv->copyUnderlay = TRUE;
		    (*pScreen->CopyWindow)(pWin, oldpt, gravitate2[g]);
		}
		if(gravitate[g]) {
		    pPriv->copyUnderlay = FALSE;
		    (*pScreen->CopyWindow)(pWin, oldpt, gravitate[g]);
		}
	    }

	    /* remove any overwritten bits from the remaining useful bits */

	    if(gravitate[g])
		RegionSubtract(oldRegion, oldRegion, gravitate[g]);
	    if(gravitate2[g])
		RegionSubtract(oldRegion2, oldRegion2, gravitate2[g]);

	    /*
	     * recompute exposed regions of child windows
	     */
	

	    for (pChild = pWin->firstChild; pChild; pChild = pChild->nextSib) {
		if (pChild->winGravity != g)
		    continue;

		TwoRegions.over = gravitate[g];
		TwoRegions.under = gravitate2[g];

		TraverseTree (pChild, miOverlayRecomputeExposures, 
					(pointer)(&TwoRegions));
	    }

	    /*
	     * remove the successfully copied regions of the
	     * window from its exposed region
	     */

	    if (g == pWin->bitGravity) {
		if(gravitate[g])
		    RegionSubtract(&pWin->valdata->after.exposed,
				&pWin->valdata->after.exposed, gravitate[g]);
		if(gravitate2[g] && pTree) 
		    RegionSubtract(&pTree->valdata->exposed,
				&pTree->valdata->exposed, gravitate2[g]);
	    }
	    if(gravitate[g]) {
		if (!destClip)
		    destClip = gravitate[g];
		else {
		    RegionUnion(destClip, destClip, gravitate[g]);
		    RegionDestroy(gravitate[g]);
		}
	    }
	    if(gravitate2[g]) {
		if (!destClip2)
		    destClip2 = gravitate2[g];
		else {
		    RegionUnion(destClip2, destClip2, gravitate2[g]);
		    RegionDestroy(gravitate2[g]);
		}
	    }
	}

	RegionDestroy(pRegion);
	RegionDestroy(oldRegion);
	if(doUnderlay)
	    RegionDestroy(oldRegion2);
	if (destClip)
	    RegionDestroy(destClip);
	if (destClip2)
	    RegionDestroy(destClip2);
	(*pScreen->HandleExposures)(pWin->parent);
	if (pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pWin->parent, pFirstChange, VTOther);
d1454 1
a1454 1
	WindowsRestructured ();
a1456 1

d1460 2
a1461 2
    Bool        WasViewable = (Bool)(pWin->viewable);
    ScreenPtr   pScreen = pWin->drawable.pScreen;
d1465 1
a1465 1
            (*pScreen->MarkOverlappedWindows)(pWin, pWin, NULL);
d1467 1
a1467 1
            if (HasBorder (pWin)) {
d1472 1
a1472 1
                                        &pWin->borderClip, &pWin->winSize);
d1475 1
a1475 1
                if(IN_UNDERLAY(pWin)) {
d1481 1
a1481 1
                                        &pTree->borderClip, &pWin->winSize);
d1487 2
a1488 2
        SetWinSize (pWin);
        SetBorderSize (pWin);
d1493 1
a1493 2
            (*pScreen->MarkOverlappedWindows)(pWin, pWin, NULL);

d1495 1
a1495 1
            (*pScreen->ValidateTree)(pWin->parent, NullWindow, VTOther);
d1499 1
a1499 1
            (*pScreen->HandleExposures)(pWin->parent);
d1501 2
a1502 1
                (*pScreen->PostValidateTree)(pWin->parent, NullWindow, VTOther);
d1506 1
a1506 1
        WindowsRestructured ();
a1509 2


d1511 2
a1512 4
miOverlayChangeBorderWidth(
    WindowPtr pWin,
    unsigned int width
){
d1515 1
a1515 1
    Bool WasViewable = (Bool)(pWin->viewable);
d1518 1
a1518 1
    oldwidth = wBorderWidth (pWin);
d1520 1
a1520 1
	return;
d1524 1
a1524 1
	(*pScreen->MarkOverlappedWindows)(pWin, pWin, NULL);
d1527 1
a1527 1
    SetBorderSize (pWin);
d1530 2
a1531 2
	if (width > oldwidth) {
	    (*pScreen->MarkOverlappedWindows)(pWin, pWin, NULL);
d1533 2
a1534 19
	    if (HadBorder) {
		RegionPtr   borderVisible;
		borderVisible = RegionCreate(NULL, 1);
		RegionSubtract(borderVisible,
				      &pWin->borderClip, &pWin->winSize);
		pWin->valdata->before.borderVisible = borderVisible;
		if(IN_UNDERLAY(pWin)) {
		    miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
		    RegionPtr borderVisible2;

		    borderVisible2 = RegionCreate(NULL, 1);
		    RegionSubtract(borderVisible2,
				      &pTree->borderClip, &pWin->winSize);
		    pTree->valdata->borderVisible = borderVisible2;
		}
	    }
	}
	(*pScreen->ValidateTree)(pWin->parent, pWin, VTOther);
	(*pScreen->HandleExposures)(pWin->parent);
d1536 20
a1555 2
	if (pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pWin->parent, pWin, VTOther);
d1558 1
a1558 1
	WindowsRestructured ();
d1572 12
a1583 11
    if(enable) {
	BoxRec box;
	
	box.x1 = 0;
	box.y1 = 0;
	box.x2 = pScreen->width;
	box.y2 = pScreen->height;

	RegionReset(&pTree->borderClip, &box);
    } else 
	RegionEmpty(&pTree->borderClip);
d1588 3
a1590 7
static void 
miOverlayClearToBackground(
    WindowPtr pWin,
    int x, int y,
    int w, int h,
    Bool generateExposures
)
d1599 2
a1600 2
    BoxPtr  extents;
    int     x1, y1, x2, y2;
d1609 1
a1609 1
        y2 = y1 + h;    
d1613 2
a1614 2
    clipList = ((*pScreenPriv->InOverlay)(pWin)) ? &pWin->clipList :
                                                 &pTree->clipList;
a1616 5
    
    if (x1 < extents->x1) x1 = extents->x1;
    if (x2 > extents->x2) x2 = extents->x2;
    if (y1 < extents->y1) y1 = extents->y1;
    if (y2 > extents->y2) y2 = extents->y2;
d1618 10
a1627 1
    if (x2 <= x1 || y2 <= y1) 
d1630 4
a1633 2
    box.x1 = x1; box.x2 = x2;
    box.y1 = y1; box.y2 = y2;
d1639 1
a1639 1
        (*pScreen->WindowExposures)(pWin, &reg, pBSReg);
d1641 1
a1641 1
	miPaintWindow(pWin, &reg, PW_BACKGROUND);
a1646 1

d1651 3
a1653 5
miOverlayGetPrivateClips(
    WindowPtr pWin,
    RegionPtr *borderClip,
    RegionPtr *clipList
){
d1655 5
a1659 5
	
    if(pTree) {
 	*borderClip = &(pTree->borderClip);
	*clipList = &(pTree->clipList);
	return TRUE;
d1668 2
a1669 4
miOverlaySetTransFunction (
   ScreenPtr pScreen, 
   miOverlayTransFunc transFunc
){
d1683 2
a1684 2
    RegionPtr       pregWin;
    Bool            freeTmpClip, freeCompClip;
d1686 3
a1688 3
    if(!pTree) {
	miComputeCompositeClip(pGC, &pWin->drawable);
	return;
d1692 10
a1701 10
	pregWin = RegionCreate(NullBox, 1);
	freeTmpClip = TRUE;
	if (pWin->parent || (screenIsSaved != SCREEN_SAVER_ON) ||
		!HasSaverWindow (pGC->pScreen))
	{
            RegionIntersect(pregWin,&pTree->borderClip,&pWin->winSize);
	}
    } else {
	pregWin = &pTree->clipList;
	freeTmpClip = FALSE;
d1705 27
a1731 26
	if (freeCompClip) 
	    RegionDestroy(pGC->pCompositeClip);
	pGC->pCompositeClip = pregWin;
	pGC->freeCompClip = freeTmpClip;
    } else {
	RegionTranslate(pGC->clientClip,
				pWin->drawable.x + pGC->clipOrg.x,
				pWin->drawable.y + pGC->clipOrg.y);

	if (freeCompClip) {
	    RegionIntersect(pGC->pCompositeClip,
					    pregWin, pGC->clientClip);
	    if (freeTmpClip)
		RegionDestroy(pregWin);
	} else if (freeTmpClip) {
	    RegionIntersect(pregWin, pregWin, pGC->clientClip);
	    pGC->pCompositeClip = pregWin;
	} else {
	    pGC->pCompositeClip = RegionCreate(NullBox, 0);
	    RegionIntersect(pGC->pCompositeClip,
				       pregWin, pGC->clientClip);
	}
	pGC->freeCompClip = TRUE;
	RegionTranslate(pGC->clientClip,
				-(pWin->drawable.x + pGC->clipOrg.x),
				-(pWin->drawable.y + pGC->clipOrg.y));
d1736 2
a1737 4
miOverlayCollectUnderlayRegions(
    WindowPtr pWin,
    RegionPtr *region
){
d1740 3
a1742 3
    if(pTree) {
	*region = &pTree->borderClip;
	return FALSE;
d1746 1
a1746 1
    
a1751 1

d1753 2
a1754 5
DoLeaf(
    WindowPtr pWin, 
    miOverlayTreePtr parent, 
    miOverlayTreePtr prevSib
){
d1756 1
a1756 1
    
d1763 7
a1769 2
    if(prevSib)
	prevSib->nextSib = pTree;
a1770 5
    if(!parent->firstChild)
	parent->firstChild = parent->lastChild = pTree;
    else if(parent->lastChild == prevSib)
	parent->lastChild = pTree;
   
d1774 1
a1774 1
static void 
d1784 2
a1785 2
    while(IN_OVERLAY(pWin))
	pWin = pWin->parent;
d1792 22
a1813 21
    while(1) {
	if(IN_UNDERLAY(pChild))
	   prevSib = tChild = DoLeaf(pChild, parent, prevSib);

	if(pChild->firstChild) {
	    if(IN_UNDERLAY(pChild)) {
		parent = tChild;
		prevSib = NULL;
	    }
	    pChild = pChild->firstChild;
	    continue;
	}

	while(!pChild->nextSib) {
	    pChild = pChild->parent;
	    if(pChild == pWin) return;
	    if(IN_UNDERLAY(pChild)) {
		prevSib = tChild = MIOVERLAY_GET_WINDOW_TREE(pChild);
		parent = tChild->parent;
	    }
	}
d1815 1
a1815 1
	pChild = pChild->nextSib;
a1818 1

d1824 2
a1825 2
    if(!(pChild = pWin->firstChild)) 
	return FALSE;
d1827 3
a1829 3
    while(1) {
	if(IN_UNDERLAY(pChild))
	   return TRUE;
d1831 4
a1834 4
	if(pChild->firstChild) {
	    pChild = pChild->firstChild;
	    continue;
	}
d1836 2
a1837 2
	while(!pChild->nextSib && (pWin != pChild))
	    pChild = pChild->parent;
d1839 2
a1840 1
	if(pChild == pWin) break;
d1842 1
a1842 1
	pChild = pChild->nextSib;
a1847 1

d1855 2
a1856 2
    if(!(pChild = pWin->firstChild)) 
	return FALSE;
d1860 24
a1883 22
    while(1) {
	if((pTree = MIOVERLAY_GET_WINDOW_TREE(pChild))) {
	    RegionAppend(pReg, &pTree->borderClip);
	    hasUnderlay = TRUE;
	} else
	if(pChild->firstChild) {
	    pChild = pChild->firstChild;
	    continue;
	}

	while(!pChild->nextSib && (pWin != pChild))
	    pChild = pChild->parent;

	if(pChild == pWin) break;

	pChild = pChild->nextSib;
    }

    if(hasUnderlay) {
	Bool overlap;
	RegionValidate(pReg, &overlap);
    } 
d1888 1
a1888 2

static void 
d1893 4
a1896 2
    if(pTree->valdata) return;
    pTree->valdata = (miOverlayValDataPtr)xnfalloc(sizeof(miOverlayValDataRec));
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d8 1
d58 4
a61 4
static int miOverlayWindowKeyKeyIndex;
static DevPrivateKey miOverlayWindowKey = &miOverlayWindowKeyKeyIndex;
static int miOverlayScreenKeyIndex;
static DevPrivateKey miOverlayScreenKey = &miOverlayScreenKeyIndex;
d86 1
a86 1
static void miOverlaySetShape(WindowPtr);
d116 1
a116 1
    if(!dixRequestPrivate(miOverlayWindowKey, sizeof(miOverlayWindowRec)))
d119 4
a122 1
    if(!(pScreenPriv = xalloc(sizeof(miOverlayScreenRec))))
d173 1
a173 1
   xfree(pScreenPriv);
d191 1
a191 1
	if(!(pTree = (miOverlayTreePtr)xcalloc(1, sizeof(miOverlayTreeRec))))
d207 2
a208 2
		REGION_NULL(pScreen, &(pTree->borderClip));
		REGION_NULL(pScreen, &(pTree->clipList));
d216 2
a217 2
		REGION_INIT(pScreen, &(pTree->borderClip), &fullBox, 1);
		REGION_INIT(pScreen, &(pTree->clipList), &fullBox, 1);
d219 1
a219 1
	} else xfree(pTree);
d245 3
a247 3
	REGION_UNINIT(pScreen, &(pTree->borderClip));
	REGION_UNINIT(pScreen, &(pTree->clipList));
	xfree(pTree);
d312 1
a312 1
	RebuildTree(WindowTable[pWin->drawable.pScreen->myNum]->firstChild);
a331 1
    ScreenPtr pScreen = pWin->drawable.pScreen;
d343 1
a343 1
    box = REGION_EXTENTS(pScreen, &pWin->borderSize);
d354 1
a354 1
                if (REGION_BROKEN (pScreen, &pChild->winSize))
d356 1
a356 1
                if (REGION_BROKEN (pScreen, &pChild->borderSize))
d360 1
a360 1
		    RECT_IN_REGION(pScreen, &pChild->borderSize, box))
d415 1
a415 1
                if (REGION_BROKEN (pScreen, &tChild->pWin->winSize))
d417 1
a417 1
                if (REGION_BROKEN (pScreen, &tChild->pWin->borderSize))
d420 1
a420 1
		if(RECT_IN_REGION(pScreen, &(tChild->pWin->borderSize), box)) 
d442 1
d447 1
a447 1
    return (underMarked || overMarked);
d479 1
a479 1
    switch (RECT_IN_REGION( pScreen, universe, &borderSize)) {
d489 1
a489 1
		    switch (miShapedWindowIn (pScreen, universe, pBounding,
d527 2
a528 2
			REGION_TRANSLATE( pScreen, &tChild->borderClip, dx, dy);
			REGION_TRANSLATE( pScreen, &tChild->clipList, dx, dy);
d536 1
a536 1
			REGION_NULL(pScreen, &tChild->valdata->borderExposed);
d538 3
a540 4
			    REGION_SUBTRACT(pScreen,
					 &tChild->valdata->borderExposed,
					 &tChild->borderClip,
					 &tChild->pWin->winSize);
d542 1
a542 1
			REGION_NULL(pScreen, &tChild->valdata->exposed);
d560 2
a561 2
	    REGION_TRANSLATE( pScreen, &tParent->borderClip, dx, dy);
	    REGION_TRANSLATE( pScreen, &tParent->clipList, dx, dy);
d565 2
a566 2
	REGION_EMPTY (pScreen, &tParent->borderClip);
	REGION_EMPTY (pScreen, &tParent->clipList);
d571 2
a572 2
    REGION_NULL(pScreen, &tParent->valdata->borderExposed);
    REGION_NULL(pScreen, &tParent->valdata->exposed);
d576 2
a577 2
	    REGION_SUBTRACT( pScreen, exposed, universe, borderVisible);
	    REGION_DESTROY( pScreen, borderVisible);
d579 1
a579 1
	    REGION_SUBTRACT( pScreen, exposed, universe, &tParent->borderClip);
d582 1
a582 1
	    REGION_SUBTRACT( pScreen, &tParent->valdata->borderExposed,
d585 1
a585 1
	    REGION_SUBTRACT( pScreen, &tParent->valdata->borderExposed,
d588 2
a589 2
    	REGION_COPY( pScreen, &tParent->borderClip, universe);    
    	REGION_INTERSECT( pScreen, universe, universe, &pParent->winSize);
d592 1
a592 1
    	REGION_COPY( pScreen, &tParent->borderClip, universe);
d595 2
a596 2
	REGION_NULL(pScreen, &childUniverse);
	REGION_NULL(pScreen, &childUnion);
d600 1
a600 1
		REGION_APPEND( pScreen, &childUnion, &tChild->pWin->borderSize);
d603 1
a603 1
	REGION_VALIDATE( pScreen, &childUnion, &overlap);
d611 1
a611 1
		    REGION_INTERSECT( pScreen, &childUniverse, universe,
d617 1
a617 1
		    REGION_SUBTRACT( pScreen, universe, universe,
d622 3
a624 3
	    REGION_SUBTRACT( pScreen, universe, universe, &childUnion);
	REGION_UNINIT( pScreen, &childUnion);
	REGION_UNINIT( pScreen, &childUniverse);
d630 1
a630 1
	REGION_COPY( pScreen, &tParent->valdata->exposed, universe);
d635 1
a635 1
    	REGION_SUBTRACT( pScreen, &tParent->valdata->exposed,
d713 1
a713 1
        REGION_EMPTY(pChild->drawable.pScreen, &pChild->clipList);
d716 1
a716 1
        REGION_EMPTY(pChild->drawable.pScreen, &pChild->borderClip);
d719 2
a720 2
		REGION_EMPTY(pChild->drawable.pScreen, &pTree->clipList);
		REGION_EMPTY(pChild->drawable.pScreen, &pTree->borderClip);
d745 3
a747 3
    REGION_NULL(pScreen, &totalClip);
    REGION_NULL(pScreen, &childClip);
    REGION_NULL(pScreen, &exposed);
d761 2
a762 2
    if (REGION_BROKEN (pScreen, &tParent->clipList) &&
        !REGION_BROKEN (pScreen, &tParent->borderClip))
d765 2
a766 2
	REGION_COPY (pScreen, &totalClip, &tParent->borderClip);
	REGION_INTERSECT (pScreen, &totalClip, &totalClip,
d771 1
a771 1
                REGION_SUBTRACT (pScreen, &totalClip, &totalClip, 
d774 1
a774 1
        REGION_EMPTY (pScreen, &tParent->clipList);
d778 1
a778 1
		REGION_APPEND(pScreen, &totalClip, &tWin->borderClip);
d780 1
a780 1
	REGION_VALIDATE(pScreen, &totalClip, &overlap);
d784 1
a784 1
	REGION_UNION(pScreen, &totalClip, &totalClip, &tParent->clipList);
d789 1
a789 1
		REGION_INTERSECT(pScreen, &childClip, &totalClip,
d792 1
a792 1
		REGION_SUBTRACT(pScreen, &totalClip, &totalClip,
d795 2
a796 2
                REGION_EMPTY(pScreen, &tWin->clipList);
                REGION_EMPTY( pScreen, &tWin->borderClip);
d802 1
a802 1
    REGION_UNINIT(pScreen, &childClip);
d805 2
a806 2
	REGION_NULL(pScreen, &tParent->valdata->exposed);
	REGION_NULL(pScreen, &tParent->valdata->borderExposed);
d814 1
a814 1
	    REGION_SUBTRACT(pScreen, &tParent->valdata->exposed, &totalClip, 
d818 1
a818 1
	REGION_COPY( pScreen, &tParent->clipList, &totalClip);
d824 2
a825 2
    REGION_UNINIT( pScreen, &totalClip);
    REGION_UNINIT( pScreen, &exposed);
d858 1
a858 1
		    if (REGION_NOTEMPTY(pScreen, &mival->borderExposed)) {
d862 1
a862 1
		    REGION_UNINIT(pScreen, &mival->borderExposed);
d865 1
a865 1
		    REGION_UNINIT(pScreen, &mival->exposed);
d867 1
a867 1
		xfree(mival);
d887 1
a887 1
		REGION_UNION(pScreen, &val->after.exposed, &val->after.exposed,
d890 1
a890 1
		if (REGION_NOTEMPTY(pScreen, &val->after.exposed)) {
d893 2
a894 2
				REGION_NUM_RECTS(&val->after.exposed),
				REGION_RECTS(&val->after.exposed));
d897 1
a897 1
		if (REGION_NOTEMPTY(pScreen, &val->after.borderExposed)) {
d903 3
a905 3
	    REGION_UNINIT(pScreen, &val->after.borderExposed);
	    REGION_UNINIT(pScreen, &val->after.exposed);
	    xfree(val);
d945 2
a946 2
	REGION_NULL(pScreen, &overReg);
	REGION_NULL(pScreen, &underReg);
d948 2
a949 2
	    REGION_COPY(pScreen, &overReg, &pWin->borderClip);
	    REGION_COPY(pScreen, &underReg, &pTree->borderClip);
d951 1
a951 1
	    REGION_COPY(pScreen, &overReg, &pWin->borderClip);
d976 1
a976 1
	if(REGION_NOTEMPTY(pScreen, &underReg)) {
d980 2
a981 2
	REGION_UNINIT(pScreen, &underReg);
	if(REGION_NOTEMPTY(pScreen, &overReg)) {
d985 1
a985 1
	REGION_UNINIT(pScreen, &overReg);
a1005 1
    ScreenPtr pScreen = pWin->drawable.pScreen;
d1007 2
a1008 2
    if ((prgn && !REGION_NIL(prgn)) || 
	(exposures && !REGION_NIL(exposures)) || other_exposed)
d1017 1
a1017 1
		REGION_UNION(pScreen, other_exposed, exposures, other_exposed);
d1019 1
a1019 1
		    REGION_DESTROY(pScreen, exposures);
d1024 1
a1024 1
	   (REGION_NUM_RECTS(exposures) > RECTLIMIT))
d1026 1
d1030 1
a1030 1
	    box = *REGION_EXTENTS(pScreen, exposures);
d1033 2
a1034 2
		REGION_INIT(pScreen, exposures, &box, 1);
		REGION_RESET(pScreen, prgn, &box);
d1036 2
a1037 2
		REGION_RESET(pScreen, exposures, &box);
		REGION_UNION(pScreen, prgn, prgn, exposures);
d1044 1
a1044 1
		REGION_INTERSECT(pScreen, prgn, prgn, &pTree->clipList);
d1046 1
a1046 1
		REGION_INTERSECT(pScreen, prgn, prgn, &pWin->clipList);
d1048 1
a1048 1
	if (prgn && !REGION_NIL(prgn))
d1050 1
a1050 1
	if (clientInterested && exposures && !REGION_NIL(exposures))
d1054 1
a1054 1
	    REGION_UNINIT(pScreen, exposures);
d1057 1
a1057 1
	    REGION_DESTROY(pScreen, exposures);
d1059 1
a1059 1
	    REGION_EMPTY(pScreen, prgn);
d1062 1
a1062 1
	REGION_DESTROY(pScreen, exposures);
a1075 1
    ScreenPtr pScreen;
a1078 3
    /* This prevents warning about pScreen not being used. */
    pWin->drawable.pScreen = pScreen = pWin->drawable.pScreen;

d1083 1
a1083 1
	REGION_SUBTRACT(pScreen, &pWin->valdata->after.exposed,
d1088 1
a1088 1
	REGION_SUBTRACT(pScreen, &pWin->valdata->after.borderExposed,
d1090 1
a1090 1
	REGION_SUBTRACT(pScreen, &pWin->valdata->after.borderExposed,
d1095 1
a1095 1
	REGION_SUBTRACT(pScreen, &pTree->valdata->exposed,
d1097 1
a1097 1
	REGION_SUBTRACT(pScreen, &pTree->valdata->borderExposed,
d1099 1
a1099 1
	REGION_SUBTRACT(pScreen, &pTree->valdata->borderExposed,
d1155 2
a1156 2
	oldRegion = REGION_CREATE(pScreen, NullBox, 1);
	REGION_COPY(pScreen, oldRegion, &pWin->winSize);
d1158 2
a1159 2
	    oldRegion2 = REGION_CREATE(pScreen, NullBox, 1);
	    REGION_COPY(pScreen, oldRegion2, &pWin->winSize);
d1171 2
a1172 2
		    gravitate[g] = REGION_CREATE(pScreen, NullBox, 1);
		REGION_UNION(pScreen, gravitate[g],
d1177 1
a1177 1
			gravitate2[g] = REGION_CREATE(pScreen, NullBox, 0);
d1180 1
a1180 1
		        REGION_UNION(pScreen, gravitate2[g],
d1194 2
a1195 2
	    oldWinClip = REGION_CREATE(pScreen, NullBox, 1);
	    REGION_COPY(pScreen, oldWinClip, &pWin->clipList);
d1197 2
a1198 2
		oldWinClip2 = REGION_CREATE(pScreen, NullBox, 1);
		REGION_COPY(pScreen, oldWinClip2, &pTree->clipList);
d1214 1
a1214 1
	    borderVisible = REGION_CREATE(pScreen, NullBox, 1);
d1216 1
a1216 1
		borderVisible2 = REGION_CREATE(pScreen, NullBox, 1);
d1221 1
a1221 1
		    REGION_SUBTRACT(pScreen, borderVisible,
d1225 1
a1225 1
		    REGION_COPY(pScreen, borderVisible,
d1229 1
a1229 1
			REGION_SUBTRACT(pScreen, borderVisible,
d1233 1
a1233 1
			REGION_COPY(pScreen, borderVisible,
d1260 1
a1260 1
	pRegion = REGION_CREATE(pScreen, NullBox, 1);
d1275 1
a1275 1
	REGION_COPY(pScreen, &pWin->valdata->after.exposed, &pWin->clipList);
d1277 1
a1277 1
	    REGION_COPY(pScreen, &pTree->valdata->exposed, &pTree->clipList);
d1305 1
a1305 1
		    REGION_TRANSLATE(pScreen, &pWin->winSize, dx, dy);
d1310 1
a1310 1
		    REGION_INTERSECT(pScreen, gravitate[g], gravitate[g],
d1313 1
a1313 1
		    REGION_INTERSECT(pScreen, gravitate2[g], gravitate2[g],
d1318 1
a1318 1
		REGION_TRANSLATE(pScreen, &pWin->winSize, -offx, -offy);
d1326 3
a1328 3
	    REGION_COPY(pScreen, pRegion, oldWinClip2);
	    REGION_TRANSLATE(pScreen, pRegion, nx - oldx, ny - oldy);
	    REGION_INTERSECT(pScreen, oldWinClip2, pRegion, &pTree->clipList);
d1332 1
a1332 1
		    REGION_SUBTRACT(pScreen, oldWinClip2, oldWinClip2,
d1335 1
a1335 1
	    REGION_TRANSLATE(pScreen, oldWinClip2, oldx - nx, oldy - ny);
d1340 2
a1341 2
		REGION_UNION(pScreen,gravitate2[g],gravitate2[g],oldWinClip2);
		REGION_DESTROY(pScreen, oldWinClip2);
d1350 3
a1352 3
	    REGION_COPY(pScreen, pRegion, oldWinClip);
	    REGION_TRANSLATE(pScreen, pRegion, nx - oldx, ny - oldy);
	    REGION_INTERSECT(pScreen, oldWinClip, pRegion, &pWin->clipList);
d1360 1
a1360 1
		    REGION_SUBTRACT(pScreen, oldWinClip, oldWinClip,
d1363 1
a1363 1
	    REGION_TRANSLATE(pScreen, oldWinClip, oldx - nx, oldy - ny);
d1368 2
a1369 2
		REGION_UNION(pScreen, gravitate[g], gravitate[g], oldWinClip);
		REGION_DESTROY(pScreen, oldWinClip);
d1393 1
a1393 1
		REGION_INTERSECT(pScreen, gravitate[g], 
d1396 1
a1396 1
		REGION_INTERSECT(pScreen, gravitate2[g], 
d1402 3
a1404 3
		REGION_TRANSLATE(pScreen, destClip, oldpt.x - x, oldpt.y - y);
		REGION_SUBTRACT(pScreen, gravitate[g], gravitate[g], destClip);
		REGION_TRANSLATE(pScreen, destClip, x - oldpt.x, y - oldpt.y);
d1407 3
a1409 3
		REGION_TRANSLATE(pScreen, destClip2, oldpt.x - x, oldpt.y - y);
		REGION_SUBTRACT(pScreen,gravitate2[g],gravitate2[g],destClip2);
		REGION_TRANSLATE(pScreen, destClip2, x - oldpt.x, y - oldpt.y);
d1417 1
a1417 2
		    (*pWin->drawable.pScreen->CopyWindow)(
						pWin, oldpt, gravitate2[g]);
d1421 1
a1421 2
		    (*pWin->drawable.pScreen->CopyWindow)(
						pWin, oldpt, gravitate[g]);
d1428 1
a1428 1
		REGION_SUBTRACT(pScreen, oldRegion, oldRegion, gravitate[g]);
d1430 1
a1430 1
		REGION_SUBTRACT(pScreen, oldRegion2, oldRegion2, gravitate2[g]);
d1455 1
a1455 1
		    REGION_SUBTRACT(pScreen, &pWin->valdata->after.exposed,
d1458 1
a1458 1
		    REGION_SUBTRACT(pScreen, &pTree->valdata->exposed,
d1465 2
a1466 2
		    REGION_UNION(pScreen, destClip, destClip, gravitate[g]);
		    REGION_DESTROY(pScreen, gravitate[g]);
d1473 2
a1474 2
		    REGION_UNION(pScreen, destClip2, destClip2, gravitate2[g]);
		    REGION_DESTROY(pScreen, gravitate2[g]);
d1479 2
a1480 2
	REGION_DESTROY(pScreen, pRegion);
	REGION_DESTROY(pScreen, oldRegion);
d1482 1
a1482 1
	    REGION_DESTROY(pScreen, oldRegion2);
d1484 1
a1484 1
	    REGION_DESTROY(pScreen, destClip);
d1486 1
a1486 1
	    REGION_DESTROY(pScreen, destClip2);
d1497 1
a1497 1
miOverlaySetShape(WindowPtr pWin)
d1499 2
a1500 2
    Bool	WasViewable = (Bool)(pWin->viewable);
    ScreenPtr 	pScreen = pWin->drawable.pScreen;
d1502 23
a1524 22
    if (WasViewable) {
	(*pScreen->MarkOverlappedWindows)(pWin, pWin, NULL);

	if (HasBorder (pWin)) {
	    RegionPtr borderVisible;

	    borderVisible = REGION_CREATE(pScreen, NullBox, 1);
	    REGION_SUBTRACT(pScreen, borderVisible,
				      &pWin->borderClip, &pWin->winSize);
	    pWin->valdata->before.borderVisible = borderVisible;
	    pWin->valdata->before.resized = TRUE;
	    if(IN_UNDERLAY(pWin)) {
		miOverlayTreePtr pTree = MIOVERLAY_GET_WINDOW_TREE(pWin);
		RegionPtr borderVisible2;

		borderVisible2 = REGION_CREATE(pScreen, NULL, 1);
		REGION_SUBTRACT(pScreen, borderVisible2,
				      &pTree->borderClip, &pWin->winSize);
		pTree->valdata->borderVisible = borderVisible2;
	    }
	}
    }
d1526 2
a1527 2
    SetWinSize (pWin);
    SetBorderSize (pWin);
d1529 1
a1529 1
    ResizeChildrenWinSize(pWin, 0, 0, 0, 0);
d1531 2
a1532 2
    if (WasViewable) {
	(*pScreen->MarkOverlappedWindows)(pWin, pWin, NULL);
d1535 2
a1536 2
	(*pScreen->ValidateTree)(pWin->parent, NullWindow, VTOther);
    }
d1538 5
a1542 4
    if (WasViewable) {
	(*pScreen->HandleExposures)(pWin->parent);
	if (pScreen->PostValidateTree)
	    (*pScreen->PostValidateTree)(pWin->parent, NullWindow, VTOther);
d1545 1
a1545 1
	WindowsRestructured ();
d1578 2
a1579 2
		borderVisible = REGION_CREATE(pScreen, NULL, 1);
		REGION_SUBTRACT(pScreen, borderVisible,
d1586 2
a1587 2
		    borderVisible2 = REGION_CREATE(pScreen, NULL, 1);
		    REGION_SUBTRACT(pScreen, borderVisible2,
d1609 1
a1609 1
    WindowPtr pRoot = WindowTable[pScreen->myNum];
d1622 1
a1622 1
	REGION_RESET(pScreen, &pTree->borderClip, &box);
d1624 1
a1624 1
	REGION_EMPTY(pScreen, &pTree->borderClip);
d1626 1
a1626 1
    REGION_BREAK(pScreen, &pTree->clipList);
d1661 1
a1661 1
    extents = REGION_EXTENTS(pScreen, clipList);
d1674 1
a1674 1
    REGION_INIT(pScreen, &reg, &box, 1);
d1676 1
a1676 1
    REGION_INTERSECT(pScreen, &reg, &reg, clipList);
d1681 1
a1681 1
    REGION_UNINIT(pScreen, &reg);
d1683 1
a1683 1
        REGION_DESTROY(pScreen, pBSReg);
a1725 1
    ScreenPtr       pScreen = pGC->pScreen;
d1736 1
a1736 1
	pregWin = REGION_CREATE(pScreen, NullBox, 1);
d1739 1
a1739 1
		!HasSaverWindow (pScreen->myNum))
d1741 1
a1741 1
            REGION_INTERSECT(pScreen,pregWin,&pTree->borderClip,&pWin->winSize);
d1750 1
a1750 1
	    REGION_DESTROY(pScreen, pGC->pCompositeClip);
d1754 1
a1754 1
	REGION_TRANSLATE(pScreen, pGC->clientClip,
d1759 1
a1759 1
	    REGION_INTERSECT(pGC->pScreen, pGC->pCompositeClip,
d1762 1
a1762 1
		REGION_DESTROY(pScreen, pregWin);
d1764 1
a1764 1
	    REGION_INTERSECT(pScreen, pregWin, pregWin, pGC->clientClip);
d1767 2
a1768 2
	    pGC->pCompositeClip = REGION_CREATE(pScreen, NullBox, 0);
	    REGION_INTERSECT(pScreen, pGC->pCompositeClip,
d1772 1
a1772 1
	REGION_TRANSLATE(pScreen, pGC->clientClip,
d1790 1
a1790 1
    *region = REGION_CREATE(pWin->drawable.pScreen, NullBox, 0);
d1911 1
a1911 1
	    REGION_APPEND(pScreen, pReg, &pTree->borderClip);
d1929 1
a1929 1
	REGION_VALIDATE(pScreen, pReg, &overlap);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d105 1
a105 1
_X_EXPORT Bool
d903 1
a903 1
	    pChild->valdata = (ValidatePtr)NULL;
d1607 1
a1607 1
_X_EXPORT void
d1691 1
a1691 1
_X_EXPORT Bool
d1710 1
a1710 1
_X_EXPORT void 
d1718 1
a1718 1
_X_EXPORT Bool 
d1724 1
a1724 1
_X_EXPORT void
d1780 1
a1780 1
_X_EXPORT Bool
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d57 4
a60 2
static DevPrivateKey miOverlayWindowKey = &miOverlayWindowKey;
static DevPrivateKey miOverlayScreenKey = &miOverlayScreenKey;
a84 1
#ifdef SHAPE
a85 1
#endif
a150 1
#ifdef SHAPE
a151 1
#endif
a480 1
#ifdef SHAPE
a498 1
#endif
a933 3
#ifdef DO_SAVE_UNDERS
    Bool dosave = FALSE;
#endif
a970 4
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	    dosave = (*pScreen->ChangeSaveUnder)(pWin, windowToValidate);
#endif /* DO_SAVE_UNDERS */
a984 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pWin, windowToValidate);
#endif /* DO_SAVE_UNDERS */
a1140 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a1269 4
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	    dosave = (*pScreen->ChangeSaveUnder)(pWin, pFirstChange);
#endif /* DO_SAVE_UNDERS */
a1490 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pWin, pFirstChange);
#endif /* DO_SAVE_UNDERS */
a1498 1
#ifdef SHAPE
a1503 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a1535 4
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	    dosave = (*pScreen->ChangeSaveUnder)(pWin, pWin);
#endif /* DO_SAVE_UNDERS */
a1541 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pWin, pWin);
#endif /* DO_SAVE_UNDERS */
a1548 1
#endif
a1560 3
#ifdef DO_SAVE_UNDERS
    Bool	dosave = FALSE;
#endif
a1593 4
#ifdef DO_SAVE_UNDERS
	if (DO_SAVE_UNDERS(pWin))
	    dosave = (*pScreen->ChangeSaveUnder)(pWin, pWin->nextSib);
#endif /* DO_SAVE_UNDERS */
a1596 4
#ifdef DO_SAVE_UNDERS
	if (dosave)
	    (*pScreen->PostChangeSaveUnder)(pWin, pWin->nextSib);
#endif /* DO_SAVE_UNDERS */
@


1.1
log
@Initial revision
@
text
@d13 1
d57 2
a58 3
static unsigned long miOverlayGeneration = 0;
int miOverlayWindowIndex = -1;
int miOverlayScreenIndex = -1;
d88 4
a91 4
#define MIOVERLAY_GET_SCREEN_PRIVATE(pScreen) \
	((miOverlayScreenPtr)((pScreen)->devPrivates[miOverlayScreenIndex].ptr))
#define MIOVERLAY_GET_WINDOW_PRIVATE(pWin) \
	((miOverlayWindowPtr)((pWin)->devPrivates[miOverlayWindowIndex].ptr))
d115 1
a115 10
    if(miOverlayGeneration != serverGeneration) {
	if(((miOverlayScreenIndex = AllocateScreenPrivateIndex()) < 0) ||
	   ((miOverlayWindowIndex = AllocateWindowPrivateIndex()) < 0))
	    return FALSE;
	
	miOverlayGeneration = serverGeneration;
    }

    if(!AllocateWindowPrivate(pScreen, miOverlayWindowIndex,
				sizeof(miOverlayWindowRec)))
d121 1
a121 1
    pScreen->devPrivates[miOverlayScreenIndex].ptr = (pointer)pScreenPriv;
d859 4
a862 3
		    if (REGION_NOTEMPTY(pScreen, &mival->borderExposed))
			(*pWin->drawable.pScreen->PaintWindowBorder)(
				pTree->pWin, &mival->borderExposed, PW_BORDER);
d898 4
a901 4
		if (REGION_NOTEMPTY(pScreen, &val->after.borderExposed))
		    (*pChild->drawable.pScreen->PaintWindowBorder)(pChild,
						    &val->after.borderExposed,
						    PW_BORDER);
d1014 1
a1014 1
    register RegionPtr prgn,
a1019 2
    if (pWin->backStorage && prgn)
	exposures = (*pScreen->RestoreAreas)(pWin, prgn);
a1058 10

	    /* need to clear out new areas of backing store, too */
	    if (pWin->backStorage)
		(void) (*pScreen->ClearBackingStore)(
					     pWin,
					     box.x1 - pWin->drawable.x,
					     box.y1 - pWin->drawable.y,
					     box.x2 - box.x1,
					     box.y2 - box.y1,
					     FALSE);
d1061 1
a1061 2
	    (*pScreen->PaintWindowBackground)(
			pWin, prgn, PW_BACKGROUND);
d1088 1
a1088 1
    register ScreenPtr pScreen;
d1143 1
a1143 1
    register WindowPtr pChild;
d1146 1
a1146 1
    register unsigned g;
a1153 1
    RegionPtr	bsExposed = NullRegion;	    /* backing store exposures */
a1279 2
	if (pWin->backStorage)
	    REGION_COPY(pScreen, pRegion, &pWin->clipList);
a1304 11
    if (pWin->backStorage && ((pWin->backingStore == Always) || WasViewable)) {
	if (!WasViewable)
	    pRegion = &pWin->clipList; /* a convenient empty region */
	if (pWin->bitGravity == ForgetGravity)
	    bsExposed = (*pScreen->TranslateBackingStore)
				(pWin, 0, 0, NullRegion, oldx, oldy);
	else
	    bsExposed = (*pScreen->TranslateBackingStore)
			     (pWin, nx - x, ny - y, pRegion, oldx, oldy);
    }

a1511 10
	if (bsExposed) {
	    RegionPtr	valExposed = NullRegion;

	    if (pWin->valdata)
		valExposed = &pWin->valdata->after.exposed;
	    (*pScreen->WindowExposures) (pWin, valExposed, bsExposed);
	    if (valExposed)
		REGION_EMPTY(pScreen, valExposed);
	    REGION_DESTROY(pScreen, bsExposed);
	}
a1519 4
    else if (bsExposed) {
	(*pScreen->WindowExposures) (pWin, NullRegion, bsExposed);
	REGION_DESTROY(pScreen, bsExposed);
    }
a1530 1
    RegionPtr	pOldClip = NULL, bsExposed;
a1563 5
	if (pWin->backStorage) {
	    pOldClip = REGION_CREATE(pScreen, NullBox, 1);
	    REGION_COPY(pScreen, pOldClip, &pWin->clipList);
	}

a1573 20
    if (pWin->backStorage && ((pWin->backingStore == Always) || WasViewable)) {
	if (!WasViewable)
	    pOldClip = &pWin->clipList; /* a convenient empty region */
	bsExposed = (*pScreen->TranslateBackingStore)
			     (pWin, 0, 0, pOldClip,
			      pWin->drawable.x, pWin->drawable.y);
	if (WasViewable)
	    REGION_DESTROY(pScreen, pOldClip);
	if (bsExposed)
	{
	    RegionPtr	valExposed = NullRegion;
    
	    if (pWin->valdata)
		valExposed = &pWin->valdata->after.exposed;
	    (*pScreen->WindowExposures) (pWin, valExposed, bsExposed);
	    if (valExposed)
		REGION_EMPTY(pScreen, valExposed);
	    REGION_DESTROY(pScreen, bsExposed);
	}
    }
d1597 1
a1597 1
    register ScreenPtr pScreen;
a1725 4
    if (pWin->backStorage) {
        pBSReg = (* pScreen->ClearBackingStore)(pWin, x, y, w, h,
                                                 generateExposures);
    }
d1731 1
a1731 1
        (*pScreen->PaintWindowBackground)(pWin, &reg, PW_BACKGROUND);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d57 2
a58 2
static int miOverlayWindowIndex = -1;
static int miOverlayScreenIndex = -1;
d1022 1
a1022 1
    RegionPtr prgn,
d1109 1
a1109 1
    ScreenPtr pScreen;
d1164 1
a1164 1
    WindowPtr pChild;
d1167 1
a1167 1
    unsigned 	g;
d1672 1
a1672 1
    ScreenPtr pScreen;
@

