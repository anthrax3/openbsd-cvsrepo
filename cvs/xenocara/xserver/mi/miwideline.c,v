head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.2
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.21.20.10.49;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.13;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*

Copyright 1988, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

Copyright 1989 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
*/

/* Author:  Keith Packard, MIT X Consortium */

/*
 * Mostly integer wideline code.  Uses a technique similar to
 * bresenham zero-width lines, except walks an X edge
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdio.h>
#ifdef _XOPEN_SOURCE
#include <math.h>
#else
#define _XOPEN_SOURCE           /* to get prototype for hypot on some systems */
#include <math.h>
#undef _XOPEN_SOURCE
#endif
#include <X11/X.h>
#include "windowstr.h"
#include "gcstruct.h"
#include "regionstr.h"
#include "miwideline.h"
#include "mi.h"

#if 0
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "misc.h"
#include "pixmapstr.h"
#include "gcstruct.h"
#endif

typedef struct {
    int count;                  /* number of spans                  */
    DDXPointPtr points;         /* pointer to list of start points  */
    int *widths;                /* pointer to list of widths        */
} Spans;

typedef struct {
    int size;                   /* Total number of *Spans allocated     */
    int count;                  /* Number of *Spans actually in group   */
    Spans *group;               /* List of Spans                        */
    int ymin, ymax;             /* Min, max y values encountered        */
} SpanGroup;

/* Rops which must use span groups */
#define miSpansCarefulRop(rop)	(((rop) & 0xc) == 0x8 || ((rop) & 0x3) == 0x2)
#define miSpansEasyRop(rop)	(!miSpansCarefulRop(rop))

/*

These routines maintain lists of Spans, in order to implement the
``touch-each-pixel-once'' rules of wide lines and arcs.

Written by Joel McCormack, Summer 1989.

*/

static void
miInitSpanGroup(SpanGroup * spanGroup)
{
    spanGroup->size = 0;
    spanGroup->count = 0;
    spanGroup->group = NULL;
    spanGroup->ymin = MAXSHORT;
    spanGroup->ymax = MINSHORT;
}                               /* InitSpanGroup */

#define YMIN(spans) (spans->points[0].y)
#define YMAX(spans)  (spans->points[spans->count-1].y)

static void
miSubtractSpans(SpanGroup * spanGroup, Spans * sub)
{
    int i, subCount, spansCount;
    int ymin, ymax, xmin, xmax;
    Spans *spans;
    DDXPointPtr subPt, spansPt;
    int *subWid, *spansWid;
    int extra;

    ymin = YMIN(sub);
    ymax = YMAX(sub);
    spans = spanGroup->group;
    for (i = spanGroup->count; i; i--, spans++) {
        if (YMIN(spans) <= ymax && ymin <= YMAX(spans)) {
            subCount = sub->count;
            subPt = sub->points;
            subWid = sub->widths;
            spansCount = spans->count;
            spansPt = spans->points;
            spansWid = spans->widths;
            extra = 0;
            for (;;) {
                while (spansCount && spansPt->y < subPt->y) {
                    spansPt++;
                    spansWid++;
                    spansCount--;
                }
                if (!spansCount)
                    break;
                while (subCount && subPt->y < spansPt->y) {
                    subPt++;
                    subWid++;
                    subCount--;
                }
                if (!subCount)
                    break;
                if (subPt->y == spansPt->y) {
                    xmin = subPt->x;
                    xmax = xmin + *subWid;
                    if (xmin >= spansPt->x + *spansWid || spansPt->x >= xmax) {
                        ;
                    }
                    else if (xmin <= spansPt->x) {
                        if (xmax >= spansPt->x + *spansWid) {
                            memmove(spansPt, spansPt + 1,
                                    sizeof *spansPt * (spansCount - 1));
                            memmove(spansWid, spansWid + 1,
                                    sizeof *spansWid * (spansCount - 1));
                            spansPt--;
                            spansWid--;
                            spans->count--;
                            extra++;
                        }
                        else {
                            *spansWid = *spansWid - (xmax - spansPt->x);
                            spansPt->x = xmax;
                        }
                    }
                    else {
                        if (xmax >= spansPt->x + *spansWid) {
                            *spansWid = xmin - spansPt->x;
                        }
                        else {
                            if (!extra) {
                                DDXPointPtr newPt;
                                int *newwid;

#define EXTRA 8
                                newPt = reallocarray(spans->points,
                                                     spans->count + EXTRA,
                                                     sizeof(DDXPointRec));
                                if (!newPt)
                                    break;
                                spansPt = newPt + (spansPt - spans->points);
                                spans->points = newPt;
                                newwid = reallocarray(spans->widths,
                                                      spans->count + EXTRA,
                                                      sizeof(int));
                                if (!newwid)
                                    break;
                                spansWid = newwid + (spansWid - spans->widths);
                                spans->widths = newwid;
                                extra = EXTRA;
                            }
                            memmove(spansPt + 1, spansPt,
                                    sizeof *spansPt * (spansCount));
                            memmove(spansWid + 1, spansWid,
                                    sizeof *spansWid * (spansCount));
                            spans->count++;
                            extra--;
                            *spansWid = xmin - spansPt->x;
                            spansWid++;
                            spansPt++;
                            *spansWid = *spansWid - (xmax - spansPt->x);
                            spansPt->x = xmax;
                        }
                    }
                }
                spansPt++;
                spansWid++;
                spansCount--;
            }
        }
    }
}

static void
miAppendSpans(SpanGroup * spanGroup, SpanGroup * otherGroup, Spans * spans)
{
    int ymin, ymax;
    int spansCount;

    spansCount = spans->count;
    if (spansCount > 0) {
        if (spanGroup->size == spanGroup->count) {
            spanGroup->size = (spanGroup->size + 8) * 2;
            spanGroup->group =
                reallocarray(spanGroup->group, sizeof(Spans), spanGroup->size);
        }

        spanGroup->group[spanGroup->count] = *spans;
        (spanGroup->count)++;
        ymin = spans->points[0].y;
        if (ymin < spanGroup->ymin)
            spanGroup->ymin = ymin;
        ymax = spans->points[spansCount - 1].y;
        if (ymax > spanGroup->ymax)
            spanGroup->ymax = ymax;
        if (otherGroup && otherGroup->ymin < ymax && ymin < otherGroup->ymax) {
            miSubtractSpans(otherGroup, spans);
        }
    }
    else {
        free(spans->points);
        free(spans->widths);
    }
}                               /* AppendSpans */

static void
miFreeSpanGroup(SpanGroup * spanGroup)
{
    free(spanGroup->group);
}

static void
QuickSortSpansX(DDXPointRec points[], int widths[], int numSpans)
{
    int x;
    int i, j, m;
    DDXPointPtr r;

/* Always called with numSpans > 1 */
/* Sorts only by x, as all y should be the same */

#define ExchangeSpans(a, b)				    \
{							    \
    DDXPointRec 	tpt;				    \
    int    		tw;				    \
							    \
    tpt = points[a]; points[a] = points[b]; points[b] = tpt;    \
    tw = widths[a]; widths[a] = widths[b]; widths[b] = tw;  \
}

    do {
        if (numSpans < 9) {
            /* Do insertion sort */
            int xprev;

            xprev = points[0].x;
            i = 1;
            do {                /* while i != numSpans */
                x = points[i].x;
                if (xprev > x) {
                    /* points[i] is out of order.  Move into proper location. */
                    DDXPointRec tpt;
                    int tw, k;

                    for (j = 0; x >= points[j].x; j++) {
                    }
                    tpt = points[i];
                    tw = widths[i];
                    for (k = i; k != j; k--) {
                        points[k] = points[k - 1];
                        widths[k] = widths[k - 1];
                    }
                    points[j] = tpt;
                    widths[j] = tw;
                    x = points[i].x;
                }               /* if out of order */
                xprev = x;
                i++;
            } while (i != numSpans);
            return;
        }

        /* Choose partition element, stick in location 0 */
        m = numSpans / 2;
        if (points[m].x > points[0].x)
            ExchangeSpans(m, 0);
        if (points[m].x > points[numSpans - 1].x)
            ExchangeSpans(m, numSpans - 1);
        if (points[m].x > points[0].x)
            ExchangeSpans(m, 0);
        x = points[0].x;

        /* Partition array */
        i = 0;
        j = numSpans;
        do {
            r = &(points[i]);
            do {
                r++;
                i++;
            } while (i != numSpans && r->x < x);
            r = &(points[j]);
            do {
                r--;
                j--;
            } while (x < r->x);
            if (i < j)
                ExchangeSpans(i, j);
        } while (i < j);

        /* Move partition element back to middle */
        ExchangeSpans(0, j);

        /* Recurse */
        if (numSpans - j - 1 > 1)
            QuickSortSpansX(&points[j + 1], &widths[j + 1], numSpans - j - 1);
        numSpans = j;
    } while (numSpans > 1);
}                               /* QuickSortSpans */

static int
UniquifySpansX(Spans * spans, DDXPointRec * newPoints, int *newWidths)
{
    int newx1, newx2, oldpt, i, y;
    DDXPointRec *oldPoints;
    int *oldWidths;
    int *startNewWidths;

/* Always called with numSpans > 1 */
/* Uniquify the spans, and stash them into newPoints and newWidths.  Return the
   number of unique spans. */

    startNewWidths = newWidths;

    oldPoints = spans->points;
    oldWidths = spans->widths;

    y = oldPoints->y;
    newx1 = oldPoints->x;
    newx2 = newx1 + *oldWidths;

    for (i = spans->count - 1; i != 0; i--) {
        oldPoints++;
        oldWidths++;
        oldpt = oldPoints->x;
        if (oldpt > newx2) {
            /* Write current span, start a new one */
            newPoints->x = newx1;
            newPoints->y = y;
            *newWidths = newx2 - newx1;
            newPoints++;
            newWidths++;
            newx1 = oldpt;
            newx2 = oldpt + *oldWidths;
        }
        else {
            /* extend current span, if old extends beyond new */
            oldpt = oldpt + *oldWidths;
            if (oldpt > newx2)
                newx2 = oldpt;
        }
    }                           /* for */

    /* Write final span */
    newPoints->x = newx1;
    *newWidths = newx2 - newx1;
    newPoints->y = y;

    return (newWidths - startNewWidths) + 1;
}                               /* UniquifySpansX */

static void
miDisposeSpanGroup(SpanGroup * spanGroup)
{
    int i;
    Spans *spans;

    for (i = 0; i < spanGroup->count; i++) {
        spans = spanGroup->group + i;
        free(spans->points);
        free(spans->widths);
    }
}

static void
miFillUniqueSpanGroup(DrawablePtr pDraw, GCPtr pGC, SpanGroup * spanGroup)
{
    int i;
    Spans *spans;
    Spans *yspans;
    int *ysizes;
    int ymin, ylength;

    /* Outgoing spans for one big call to FillSpans */
    DDXPointPtr points;
    int *widths;
    int count;

    if (spanGroup->count == 0)
        return;

    if (spanGroup->count == 1) {
        /* Already should be sorted, unique */
        spans = spanGroup->group;
        (*pGC->ops->FillSpans)
            (pDraw, pGC, spans->count, spans->points, spans->widths, TRUE);
        free(spans->points);
        free(spans->widths);
    }
    else {
        /* Yuck.  Gross.  Radix sort into y buckets, then sort x and uniquify */
        /* This seems to be the fastest thing to do.  I've tried sorting on
           both x and y at the same time rather than creating into all those
           y buckets, but it was somewhat slower. */

        ymin = spanGroup->ymin;
        ylength = spanGroup->ymax - ymin + 1;

        /* Allocate Spans for y buckets */
        yspans = xallocarray(ylength, sizeof(Spans));
        ysizes = xallocarray(ylength, sizeof(int));

        if (!yspans || !ysizes) {
            free(yspans);
            free(ysizes);
            miDisposeSpanGroup(spanGroup);
            return;
        }

        for (i = 0; i != ylength; i++) {
            ysizes[i] = 0;
            yspans[i].count = 0;
            yspans[i].points = NULL;
            yspans[i].widths = NULL;
        }

        /* Go through every single span and put it into the correct bucket */
        count = 0;
        for (i = 0, spans = spanGroup->group;
             i != spanGroup->count; i++, spans++) {
            int index;
            int j;

            for (j = 0, points = spans->points, widths = spans->widths;
                 j != spans->count; j++, points++, widths++) {
                index = points->y - ymin;
                if (index >= 0 && index < ylength) {
                    Spans *newspans = &(yspans[index]);

                    if (newspans->count == ysizes[index]) {
                        DDXPointPtr newpoints;
                        int *newwidths;

                        ysizes[index] = (ysizes[index] + 8) * 2;
                        newpoints = reallocarray(newspans->points,
                                                 ysizes[index],
                                                 sizeof(DDXPointRec));
                        newwidths = reallocarray(newspans->widths,
                                                 ysizes[index], sizeof(int));
                        if (!newpoints || !newwidths) {
                            for (i = 0; i < ylength; i++) {
                                free(yspans[i].points);
                                free(yspans[i].widths);
                            }
                            free(yspans);
                            free(ysizes);
                            free(newpoints);
                            free(newwidths);
                            miDisposeSpanGroup(spanGroup);
                            return;
                        }
                        newspans->points = newpoints;
                        newspans->widths = newwidths;
                    }
                    newspans->points[newspans->count] = *points;
                    newspans->widths[newspans->count] = *widths;
                    (newspans->count)++;
                }               /* if y value of span in range */
            }                   /* for j through spans */
            count += spans->count;
            free(spans->points);
            spans->points = NULL;
            free(spans->widths);
            spans->widths = NULL;
        }                       /* for i thorough Spans */

        /* Now sort by x and uniquify each bucket into the final array */
        points = xallocarray(count, sizeof(DDXPointRec));
        widths = xallocarray(count, sizeof(int));
        if (!points || !widths) {
            for (i = 0; i < ylength; i++) {
                free(yspans[i].points);
                free(yspans[i].widths);
            }
            free(yspans);
            free(ysizes);
            free(points);
            free(widths);
            return;
        }
        count = 0;
        for (i = 0; i != ylength; i++) {
            int ycount = yspans[i].count;

            if (ycount > 0) {
                if (ycount > 1) {
                    QuickSortSpansX(yspans[i].points, yspans[i].widths, ycount);
                    count += UniquifySpansX
                        (&(yspans[i]), &(points[count]), &(widths[count]));
                }
                else {
                    points[count] = yspans[i].points[0];
                    widths[count] = yspans[i].widths[0];
                    count++;
                }
                free(yspans[i].points);
                free(yspans[i].widths);
            }
        }

        (*pGC->ops->FillSpans) (pDraw, pGC, count, points, widths, TRUE);
        free(points);
        free(widths);
        free(yspans);
        free(ysizes);           /* use (DE)xalloc for these? */
    }

    spanGroup->count = 0;
    spanGroup->ymin = MAXSHORT;
    spanGroup->ymax = MINSHORT;
}

static Bool
InitSpans(Spans * spans, size_t nspans)
{
    spans->points = xallocarray(nspans, sizeof(*spans->points));
    if (!spans->points)
        return FALSE;
    spans->widths = xallocarray(nspans, sizeof(*spans->widths));
    if (!spans->widths) {
        free(spans->points);
        return FALSE;
    }
    return TRUE;
}

/*
 * interface data to span-merging polygon filler
 */

typedef struct _SpanData {
    SpanGroup fgGroup, bgGroup;
} SpanDataRec, *SpanDataPtr;

static void
AppendSpanGroup(GCPtr pGC, unsigned long pixel, Spans * spanPtr,
                SpanDataPtr spanData)
{
    SpanGroup *group, *othergroup = NULL;

    if (pixel == pGC->fgPixel) {
        group = &spanData->fgGroup;
        if (pGC->lineStyle == LineDoubleDash)
            othergroup = &spanData->bgGroup;
    }
    else {
        group = &spanData->bgGroup;
        othergroup = &spanData->fgGroup;
    }
    miAppendSpans(group, othergroup, spanPtr);
}

static void miLineArc(DrawablePtr pDraw, GCPtr pGC,
                      unsigned long pixel, SpanDataPtr spanData,
                      LineFacePtr leftFace,
                      LineFacePtr rightFace,
                      double xorg, double yorg, Bool isInt);

/*
 * spans-based polygon filler
 */

static void
fillSpans(DrawablePtr pDrawable, GCPtr pGC, unsigned long pixel, Spans * spans,
          SpanDataPtr spanData)
{
    if (!spanData) {
        ChangeGCVal oldPixel, tmpPixel;

        oldPixel.val = pGC->fgPixel;
        if (pixel != oldPixel.val) {
            tmpPixel.val = (XID) pixel;
            ChangeGC(NullClient, pGC, GCForeground, &tmpPixel);
            ValidateGC(pDrawable, pGC);
        }
        (*pGC->ops->FillSpans) (pDrawable, pGC, spans->count, spans->points,
                                spans->widths, TRUE);
        free(spans->widths);
        free(spans->points);
        if (pixel != oldPixel.val) {
            ChangeGC(NullClient, pGC, GCForeground, &oldPixel);
            ValidateGC(pDrawable, pGC);
        }
    }
    else
        AppendSpanGroup(pGC, pixel, spans, spanData);
}

static void
miFillPolyHelper(DrawablePtr pDrawable, GCPtr pGC, unsigned long pixel,
                 SpanDataPtr spanData, int y, int overall_height,
                 PolyEdgePtr left, PolyEdgePtr right,
                 int left_count, int right_count)
{
    int left_x = 0, left_e = 0;
    int left_stepx = 0;
    int left_signdx = 0;
    int left_dy = 0, left_dx = 0;

    int right_x = 0, right_e = 0;
    int right_stepx = 0;
    int right_signdx = 0;
    int right_dy = 0, right_dx = 0;

    int height = 0;
    int left_height = 0, right_height = 0;

    DDXPointPtr ppt;
    int *pwidth;
    int xorg;
    Spans spanRec;

    if (!InitSpans(&spanRec, overall_height))
        return;
    ppt = spanRec.points;
    pwidth = spanRec.widths;

    xorg = 0;
    if (pGC->miTranslate) {
        y += pDrawable->y;
        xorg = pDrawable->x;
    }
    while ((left_count || left_height) && (right_count || right_height)) {
        if (!left_height && left_count) {
            left_height = left->height;
            left_x = left->x;
            left_stepx = left->stepx;
            left_signdx = left->signdx;
            left_e = left->e;
            left_dy = left->dy;
            left_dx = left->dx;
            --left_count;
            ++left;
        }

        if (!right_height && right_count) {
            right_height = right->height;
            right_x = right->x;
            right_stepx = right->stepx;
            right_signdx = right->signdx;
            right_e = right->e;
            right_dy = right->dy;
            right_dx = right->dx;
            --right_count;
            ++right;
        }

        height = left_height;
        if (height > right_height)
            height = right_height;

        left_height -= height;
        right_height -= height;

        while (--height >= 0) {
            if (right_x >= left_x) {
                ppt->y = y;
                ppt->x = left_x + xorg;
                ppt++;
                *pwidth++ = right_x - left_x + 1;
            }
            y++;

            left_x += left_stepx;
            left_e += left_dx;
            if (left_e > 0) {
                left_x += left_signdx;
                left_e -= left_dy;
            }

            right_x += right_stepx;
            right_e += right_dx;
            if (right_e > 0) {
                right_x += right_signdx;
                right_e -= right_dy;
            }
        }
    }
    spanRec.count = ppt - spanRec.points;
    fillSpans(pDrawable, pGC, pixel, &spanRec, spanData);
}

static void
miFillRectPolyHelper(DrawablePtr pDrawable,
                     GCPtr pGC,
                     unsigned long pixel,
                     SpanDataPtr spanData, int x, int y, int w, int h)
{
    DDXPointPtr ppt;
    int *pwidth;
    ChangeGCVal oldPixel, tmpPixel;
    Spans spanRec;
    xRectangle rect;

    if (!spanData) {
        rect.x = x;
        rect.y = y;
        rect.width = w;
        rect.height = h;
        oldPixel.val = pGC->fgPixel;
        if (pixel != oldPixel.val) {
            tmpPixel.val = (XID) pixel;
            ChangeGC(NullClient, pGC, GCForeground, &tmpPixel);
            ValidateGC(pDrawable, pGC);
        }
        (*pGC->ops->PolyFillRect) (pDrawable, pGC, 1, &rect);
        if (pixel != oldPixel.val) {
            ChangeGC(NullClient, pGC, GCForeground, &oldPixel);
            ValidateGC(pDrawable, pGC);
        }
    }
    else {
        if (!InitSpans(&spanRec, h))
            return;
        ppt = spanRec.points;
        pwidth = spanRec.widths;

        if (pGC->miTranslate) {
            y += pDrawable->y;
            x += pDrawable->x;
        }
        while (h--) {
            ppt->x = x;
            ppt->y = y;
            ppt++;
            *pwidth++ = w;
            y++;
        }
        spanRec.count = ppt - spanRec.points;
        AppendSpanGroup(pGC, pixel, &spanRec, spanData);
    }
}

static int
miPolyBuildEdge(double x0, double y0, double k, /* x0 * dy - y0 * dx */
                int dx, int dy, int xi, int yi, int left, PolyEdgePtr edge)
{
    int x, y, e;
    int xady;

    if (dy < 0) {
        dy = -dy;
        dx = -dx;
        k = -k;
    }

#ifdef NOTDEF
    {
        double realk, kerror;

        realk = x0 * dy - y0 * dx;
        kerror = fabs(realk - k);
        if (kerror > .1)
            printf("realk: %g k: %g\n", realk, k);
    }
#endif
    y = ICEIL(y0);
    xady = ICEIL(k) + y * dx;

    if (xady <= 0)
        x = -(-xady / dy) - 1;
    else
        x = (xady - 1) / dy;

    e = xady - x * dy;

    if (dx >= 0) {
        edge->signdx = 1;
        edge->stepx = dx / dy;
        edge->dx = dx % dy;
    }
    else {
        edge->signdx = -1;
        edge->stepx = -(-dx / dy);
        edge->dx = -dx % dy;
        e = dy - e + 1;
    }
    edge->dy = dy;
    edge->x = x + left + xi;
    edge->e = e - dy;           /* bias to compare against 0 instead of dy */
    return y + yi;
}

#define StepAround(v, incr, max) (((v) + (incr) < 0) ? (max - 1) : ((v) + (incr) == max) ? 0 : ((v) + (incr)))

static int
miPolyBuildPoly(PolyVertexPtr vertices,
                PolySlopePtr slopes,
                int count,
                int xi,
                int yi,
                PolyEdgePtr left,
                PolyEdgePtr right, int *pnleft, int *pnright, int *h)
{
    int top, bottom;
    double miny, maxy;
    int i;
    int j;
    int clockwise;
    int slopeoff;
    int s;
    int nright, nleft;
    int y, lasty = 0, bottomy, topy = 0;

    /* find the top of the polygon */
    maxy = miny = vertices[0].y;
    bottom = top = 0;
    for (i = 1; i < count; i++) {
        if (vertices[i].y < miny) {
            top = i;
            miny = vertices[i].y;
        }
        if (vertices[i].y >= maxy) {
            bottom = i;
            maxy = vertices[i].y;
        }
    }
    clockwise = 1;
    slopeoff = 0;

    i = top;
    j = StepAround(top, -1, count);

    if ((int64_t) slopes[j].dy * slopes[i].dx >
        (int64_t) slopes[i].dy * slopes[j].dx) {
        clockwise = -1;
        slopeoff = -1;
    }

    bottomy = ICEIL(maxy) + yi;

    nright = 0;

    s = StepAround(top, slopeoff, count);
    i = top;
    while (i != bottom) {
        if (slopes[s].dy != 0) {
            y = miPolyBuildEdge(vertices[i].x, vertices[i].y,
                                slopes[s].k,
                                slopes[s].dx, slopes[s].dy,
                                xi, yi, 0, &right[nright]);
            if (nright != 0)
                right[nright - 1].height = y - lasty;
            else
                topy = y;
            nright++;
            lasty = y;
        }

        i = StepAround(i, clockwise, count);
        s = StepAround(s, clockwise, count);
    }
    if (nright != 0)
        right[nright - 1].height = bottomy - lasty;

    if (slopeoff == 0)
        slopeoff = -1;
    else
        slopeoff = 0;

    nleft = 0;
    s = StepAround(top, slopeoff, count);
    i = top;
    while (i != bottom) {
        if (slopes[s].dy != 0) {
            y = miPolyBuildEdge(vertices[i].x, vertices[i].y,
                                slopes[s].k,
                                slopes[s].dx, slopes[s].dy, xi, yi, 1,
                                &left[nleft]);

            if (nleft != 0)
                left[nleft - 1].height = y - lasty;
            nleft++;
            lasty = y;
        }
        i = StepAround(i, -clockwise, count);
        s = StepAround(s, -clockwise, count);
    }
    if (nleft != 0)
        left[nleft - 1].height = bottomy - lasty;
    *pnleft = nleft;
    *pnright = nright;
    *h = bottomy - topy;
    return topy;
}

static void
miLineOnePoint(DrawablePtr pDrawable,
               GCPtr pGC,
               unsigned long pixel, SpanDataPtr spanData, int x, int y)
{
    DDXPointRec pt;
    int wid;
    unsigned long oldPixel;

    MILINESETPIXEL(pDrawable, pGC, pixel, oldPixel);
    if (pGC->fillStyle == FillSolid) {
        pt.x = x;
        pt.y = y;
        (*pGC->ops->PolyPoint) (pDrawable, pGC, CoordModeOrigin, 1, &pt);
    }
    else {
        wid = 1;
        if (pGC->miTranslate) {
            x += pDrawable->x;
            y += pDrawable->y;
        }
        pt.x = x;
        pt.y = y;
        (*pGC->ops->FillSpans) (pDrawable, pGC, 1, &pt, &wid, TRUE);
    }
    MILINERESETPIXEL(pDrawable, pGC, pixel, oldPixel);
}

static void
miLineJoin(DrawablePtr pDrawable,
           GCPtr pGC,
           unsigned long pixel,
           SpanDataPtr spanData, LineFacePtr pLeft, LineFacePtr pRight)
{
    double mx = 0, my = 0;
    double denom = 0.0;
    PolyVertexRec vertices[4];
    PolySlopeRec slopes[4];
    int edgecount;
    PolyEdgeRec left[4], right[4];
    int nleft, nright;
    int y, height;
    int swapslopes;
    int joinStyle = pGC->joinStyle;
    int lw = pGC->lineWidth;

    if (lw == 1 && !spanData) {
        /* See if one of the lines will draw the joining pixel */
        if (pLeft->dx > 0 || (pLeft->dx == 0 && pLeft->dy > 0))
            return;
        if (pRight->dx > 0 || (pRight->dx == 0 && pRight->dy > 0))
            return;
        if (joinStyle != JoinRound) {
            denom =
                -pLeft->dx * (double) pRight->dy +
                pRight->dx * (double) pLeft->dy;
            if (denom == 0)
                return;         /* no join to draw */
        }
        if (joinStyle != JoinMiter) {
            miLineOnePoint(pDrawable, pGC, pixel, spanData, pLeft->x, pLeft->y);
            return;
        }
    }
    else {
        if (joinStyle == JoinRound) {
            miLineArc(pDrawable, pGC, pixel, spanData,
                      pLeft, pRight, (double) 0.0, (double) 0.0, TRUE);
            return;
        }
        denom =
            -pLeft->dx * (double) pRight->dy + pRight->dx * (double) pLeft->dy;
        if (denom == 0.0)
            return;             /* no join to draw */
    }

    swapslopes = 0;
    if (denom > 0) {
        pLeft->xa = -pLeft->xa;
        pLeft->ya = -pLeft->ya;
        pLeft->dx = -pLeft->dx;
        pLeft->dy = -pLeft->dy;
    }
    else {
        swapslopes = 1;
        pRight->xa = -pRight->xa;
        pRight->ya = -pRight->ya;
        pRight->dx = -pRight->dx;
        pRight->dy = -pRight->dy;
    }

    vertices[0].x = pRight->xa;
    vertices[0].y = pRight->ya;
    slopes[0].dx = -pRight->dy;
    slopes[0].dy = pRight->dx;
    slopes[0].k = 0;

    vertices[1].x = 0;
    vertices[1].y = 0;
    slopes[1].dx = pLeft->dy;
    slopes[1].dy = -pLeft->dx;
    slopes[1].k = 0;

    vertices[2].x = pLeft->xa;
    vertices[2].y = pLeft->ya;

    if (joinStyle == JoinMiter) {
        my = (pLeft->dy * (pRight->xa * pRight->dy - pRight->ya * pRight->dx) -
              pRight->dy * (pLeft->xa * pLeft->dy - pLeft->ya * pLeft->dx)) /
            denom;
        if (pLeft->dy != 0) {
            mx = pLeft->xa + (my - pLeft->ya) *
                (double) pLeft->dx / (double) pLeft->dy;
        }
        else {
            mx = pRight->xa + (my - pRight->ya) *
                (double) pRight->dx / (double) pRight->dy;
        }
        /* check miter limit */
        if ((mx * mx + my * my) * 4 > SQSECANT * lw * lw)
            joinStyle = JoinBevel;
    }

    if (joinStyle == JoinMiter) {
        slopes[2].dx = pLeft->dx;
        slopes[2].dy = pLeft->dy;
        slopes[2].k = pLeft->k;
        if (swapslopes) {
            slopes[2].dx = -slopes[2].dx;
            slopes[2].dy = -slopes[2].dy;
            slopes[2].k = -slopes[2].k;
        }
        vertices[3].x = mx;
        vertices[3].y = my;
        slopes[3].dx = pRight->dx;
        slopes[3].dy = pRight->dy;
        slopes[3].k = pRight->k;
        if (swapslopes) {
            slopes[3].dx = -slopes[3].dx;
            slopes[3].dy = -slopes[3].dy;
            slopes[3].k = -slopes[3].k;
        }
        edgecount = 4;
    }
    else {
        double scale, dx, dy, adx, ady;

        adx = dx = pRight->xa - pLeft->xa;
        ady = dy = pRight->ya - pLeft->ya;
        if (adx < 0)
            adx = -adx;
        if (ady < 0)
            ady = -ady;
        scale = ady;
        if (adx > ady)
            scale = adx;
        slopes[2].dx = (dx * 65536) / scale;
        slopes[2].dy = (dy * 65536) / scale;
        slopes[2].k = ((pLeft->xa + pRight->xa) * slopes[2].dy -
                       (pLeft->ya + pRight->ya) * slopes[2].dx) / 2.0;
        edgecount = 3;
    }

    y = miPolyBuildPoly(vertices, slopes, edgecount, pLeft->x, pLeft->y,
                        left, right, &nleft, &nright, &height);
    miFillPolyHelper(pDrawable, pGC, pixel, spanData, y, height, left, right,
                     nleft, nright);
}

static int
miLineArcI(DrawablePtr pDraw,
           GCPtr pGC, int xorg, int yorg, DDXPointPtr points, int *widths)
{
    DDXPointPtr tpts, bpts;
    int *twids, *bwids;
    int x, y, e, ex, slw;

    tpts = points;
    twids = widths;
    if (pGC->miTranslate) {
        xorg += pDraw->x;
        yorg += pDraw->y;
    }
    slw = pGC->lineWidth;
    if (slw == 1) {
        tpts->x = xorg;
        tpts->y = yorg;
        *twids = 1;
        return 1;
    }
    bpts = tpts + slw;
    bwids = twids + slw;
    y = (slw >> 1) + 1;
    if (slw & 1)
        e = -((y << 2) + 3);
    else
        e = -(y << 3);
    ex = -4;
    x = 0;
    while (y) {
        e += (y << 3) - 4;
        while (e >= 0) {
            x++;
            e += (ex = -((x << 3) + 4));
        }
        y--;
        slw = (x << 1) + 1;
        if ((e == ex) && (slw > 1))
            slw--;
        tpts->x = xorg - x;
        tpts->y = yorg - y;
        tpts++;
        *twids++ = slw;
        if ((y != 0) && ((slw > 1) || (e != ex))) {
            bpts--;
            bpts->x = xorg - x;
            bpts->y = yorg + y;
            *--bwids = slw;
        }
    }
    return pGC->lineWidth;
}

#define CLIPSTEPEDGE(edgey,edge,edgeleft) \
    if (ybase == edgey) \
    { \
	if (edgeleft) \
	{ \
	    if (edge->x > xcl) \
		xcl = edge->x; \
	} \
	else \
	{ \
	    if (edge->x < xcr) \
		xcr = edge->x; \
	} \
	edgey++; \
	edge->x += edge->stepx; \
	edge->e += edge->dx; \
	if (edge->e > 0) \
	{ \
	    edge->x += edge->signdx; \
	    edge->e -= edge->dy; \
	} \
    }

static int
miLineArcD(DrawablePtr pDraw,
           GCPtr pGC,
           double xorg,
           double yorg,
           DDXPointPtr points,
           int *widths,
           PolyEdgePtr edge1,
           int edgey1,
           Bool edgeleft1, PolyEdgePtr edge2, int edgey2, Bool edgeleft2)
{
    DDXPointPtr pts;
    int *wids;
    double radius, x0, y0, el, er, yk, xlk, xrk, k;
    int xbase, ybase, y, boty, xl, xr, xcl, xcr;
    int ymin, ymax;
    Bool edge1IsMin, edge2IsMin;
    int ymin1, ymin2;

    pts = points;
    wids = widths;
    xbase = floor(xorg);
    x0 = xorg - xbase;
    ybase = ICEIL(yorg);
    y0 = yorg - ybase;
    if (pGC->miTranslate) {
        xbase += pDraw->x;
        ybase += pDraw->y;
        edge1->x += pDraw->x;
        edge2->x += pDraw->x;
        edgey1 += pDraw->y;
        edgey2 += pDraw->y;
    }
    xlk = x0 + x0 + 1.0;
    xrk = x0 + x0 - 1.0;
    yk = y0 + y0 - 1.0;
    radius = ((double) pGC->lineWidth) / 2.0;
    y = floor(radius - y0 + 1.0);
    ybase -= y;
    ymin = ybase;
    ymax = 65536;
    edge1IsMin = FALSE;
    ymin1 = edgey1;
    if (edge1->dy >= 0) {
        if (!edge1->dy) {
            if (edgeleft1)
                edge1IsMin = TRUE;
            else
                ymax = edgey1;
            edgey1 = 65536;
        }
        else {
            if ((edge1->signdx < 0) == edgeleft1)
                edge1IsMin = TRUE;
        }
    }
    edge2IsMin = FALSE;
    ymin2 = edgey2;
    if (edge2->dy >= 0) {
        if (!edge2->dy) {
            if (edgeleft2)
                edge2IsMin = TRUE;
            else
                ymax = edgey2;
            edgey2 = 65536;
        }
        else {
            if ((edge2->signdx < 0) == edgeleft2)
                edge2IsMin = TRUE;
        }
    }
    if (edge1IsMin) {
        ymin = ymin1;
        if (edge2IsMin && ymin1 > ymin2)
            ymin = ymin2;
    }
    else if (edge2IsMin)
        ymin = ymin2;
    el = radius * radius - ((y + y0) * (y + y0)) - (x0 * x0);
    er = el + xrk;
    xl = 1;
    xr = 0;
    if (x0 < 0.5) {
        xl = 0;
        el -= xlk;
    }
    boty = (y0 < -0.5) ? 1 : 0;
    if (ybase + y - boty > ymax)
        boty = ymax - ybase - y;
    while (y > boty) {
        k = (y << 1) + yk;
        er += k;
        while (er > 0.0) {
            xr++;
            er += xrk - (xr << 1);
        }
        el += k;
        while (el >= 0.0) {
            xl--;
            el += (xl << 1) - xlk;
        }
        y--;
        ybase++;
        if (ybase < ymin)
            continue;
        xcl = xl + xbase;
        xcr = xr + xbase;
        CLIPSTEPEDGE(edgey1, edge1, edgeleft1);
        CLIPSTEPEDGE(edgey2, edge2, edgeleft2);
        if (xcr >= xcl) {
            pts->x = xcl;
            pts->y = ybase;
            pts++;
            *wids++ = xcr - xcl + 1;
        }
    }
    er = xrk - (xr << 1) - er;
    el = (xl << 1) - xlk - el;
    boty = floor(-y0 - radius + 1.0);
    if (ybase + y - boty > ymax)
        boty = ymax - ybase - y;
    while (y > boty) {
        k = (y << 1) + yk;
        er -= k;
        while ((er >= 0.0) && (xr >= 0)) {
            xr--;
            er += xrk - (xr << 1);
        }
        el -= k;
        while ((el > 0.0) && (xl <= 0)) {
            xl++;
            el += (xl << 1) - xlk;
        }
        y--;
        ybase++;
        if (ybase < ymin)
            continue;
        xcl = xl + xbase;
        xcr = xr + xbase;
        CLIPSTEPEDGE(edgey1, edge1, edgeleft1);
        CLIPSTEPEDGE(edgey2, edge2, edgeleft2);
        if (xcr >= xcl) {
            pts->x = xcl;
            pts->y = ybase;
            pts++;
            *wids++ = xcr - xcl + 1;
        }
    }
    return pts - points;
}

static int
miRoundJoinFace(LineFacePtr face, PolyEdgePtr edge, Bool *leftEdge)
{
    int y;
    int dx, dy;
    double xa, ya;
    Bool left;

    dx = -face->dy;
    dy = face->dx;
    xa = face->xa;
    ya = face->ya;
    left = 1;
    if (ya > 0) {
        ya = 0.0;
        xa = 0.0;
    }
    if (dy < 0 || (dy == 0 && dx > 0)) {
        dx = -dx;
        dy = -dy;
        left = !left;
    }
    if (dx == 0 && dy == 0)
        dy = 1;
    if (dy == 0) {
        y = ICEIL(face->ya) + face->y;
        edge->x = -32767;
        edge->stepx = 0;
        edge->signdx = 0;
        edge->e = -1;
        edge->dy = 0;
        edge->dx = 0;
        edge->height = 0;
    }
    else {
        y = miPolyBuildEdge(xa, ya, 0.0, dx, dy, face->x, face->y, !left, edge);
        edge->height = 32767;
    }
    *leftEdge = !left;
    return y;
}

static void
miRoundJoinClip(LineFacePtr pLeft, LineFacePtr pRight,
                PolyEdgePtr edge1, PolyEdgePtr edge2,
                int *y1, int *y2, Bool *left1, Bool *left2)
{
    double denom;

    denom = -pLeft->dx * (double) pRight->dy + pRight->dx * (double) pLeft->dy;

    if (denom >= 0) {
        pLeft->xa = -pLeft->xa;
        pLeft->ya = -pLeft->ya;
    }
    else {
        pRight->xa = -pRight->xa;
        pRight->ya = -pRight->ya;
    }
    *y1 = miRoundJoinFace(pLeft, edge1, left1);
    *y2 = miRoundJoinFace(pRight, edge2, left2);
}

static int
miRoundCapClip(LineFacePtr face, Bool isInt, PolyEdgePtr edge, Bool *leftEdge)
{
    int y;
    int dx, dy;
    double xa, ya, k;
    Bool left;

    dx = -face->dy;
    dy = face->dx;
    xa = face->xa;
    ya = face->ya;
    k = 0.0;
    if (!isInt)
        k = face->k;
    left = 1;
    if (dy < 0 || (dy == 0 && dx > 0)) {
        dx = -dx;
        dy = -dy;
        xa = -xa;
        ya = -ya;
        left = !left;
    }
    if (dx == 0 && dy == 0)
        dy = 1;
    if (dy == 0) {
        y = ICEIL(face->ya) + face->y;
        edge->x = -32767;
        edge->stepx = 0;
        edge->signdx = 0;
        edge->e = -1;
        edge->dy = 0;
        edge->dx = 0;
        edge->height = 0;
    }
    else {
        y = miPolyBuildEdge(xa, ya, k, dx, dy, face->x, face->y, !left, edge);
        edge->height = 32767;
    }
    *leftEdge = !left;
    return y;
}

static void
miLineArc(DrawablePtr pDraw,
          GCPtr pGC,
          unsigned long pixel,
          SpanDataPtr spanData,
          LineFacePtr leftFace,
          LineFacePtr rightFace, double xorg, double yorg, Bool isInt)
{
    int xorgi = 0, yorgi = 0;
    Spans spanRec;
    int n;
    PolyEdgeRec edge1 = { 0 }, edge2 = { 0 };
    int edgey1, edgey2;
    Bool edgeleft1, edgeleft2;

    if (isInt) {
        xorgi = leftFace ? leftFace->x : rightFace->x;
        yorgi = leftFace ? leftFace->y : rightFace->y;
    }
    edgey1 = 65536;
    edgey2 = 65536;
    edge1.x = 0;                /* not used, keep memory checkers happy */
    edge1.dy = -1;
    edge2.x = 0;                /* not used, keep memory checkers happy */
    edge2.dy = -1;
    edgeleft1 = FALSE;
    edgeleft2 = FALSE;
    if ((pGC->lineStyle != LineSolid || pGC->lineWidth > 2) &&
        ((pGC->capStyle == CapRound && pGC->joinStyle != JoinRound) ||
         (pGC->joinStyle == JoinRound && pGC->capStyle == CapButt))) {
        if (isInt) {
            xorg = (double) xorgi;
            yorg = (double) yorgi;
        }
        if (leftFace && rightFace) {
            miRoundJoinClip(leftFace, rightFace, &edge1, &edge2,
                            &edgey1, &edgey2, &edgeleft1, &edgeleft2);
        }
        else if (leftFace) {
            edgey1 = miRoundCapClip(leftFace, isInt, &edge1, &edgeleft1);
        }
        else if (rightFace) {
            edgey2 = miRoundCapClip(rightFace, isInt, &edge2, &edgeleft2);
        }
        isInt = FALSE;
    }
    if (!InitSpans(&spanRec, pGC->lineWidth))
        return;
    if (isInt)
        n = miLineArcI(pDraw, pGC, xorgi, yorgi, spanRec.points,
                       spanRec.widths);
    else
        n = miLineArcD(pDraw, pGC, xorg, yorg, spanRec.points, spanRec.widths,
                       &edge1, edgey1, edgeleft1, &edge2, edgey2, edgeleft2);
    spanRec.count = n;
    fillSpans(pDraw, pGC, pixel, &spanRec, spanData);
}

static void
miLineProjectingCap(DrawablePtr pDrawable, GCPtr pGC, unsigned long pixel,
                    SpanDataPtr spanData, LineFacePtr face, Bool isLeft,
                    double xorg, double yorg, Bool isInt)
{
    int xorgi = 0, yorgi = 0;
    int lw;
    PolyEdgeRec lefts[4], rights[4];
    int lefty, righty, topy, bottomy;
    PolyEdgePtr left, right;
    PolyEdgePtr top, bottom;
    double xa, ya;
    double k;
    double xap, yap;
    int dx, dy;
    double projectXoff, projectYoff;
    double maxy;
    int finaly;

    if (isInt) {
        xorgi = face->x;
        yorgi = face->y;
    }
    lw = pGC->lineWidth;
    dx = face->dx;
    dy = face->dy;
    k = face->k;
    if (dy == 0) {
        lefts[0].height = lw;
        lefts[0].x = xorgi;
        if (isLeft)
            lefts[0].x -= (lw >> 1);
        lefts[0].stepx = 0;
        lefts[0].signdx = 1;
        lefts[0].e = -lw;
        lefts[0].dx = 0;
        lefts[0].dy = lw;
        rights[0].height = lw;
        rights[0].x = xorgi;
        if (!isLeft)
            rights[0].x += ((lw + 1) >> 1);
        rights[0].stepx = 0;
        rights[0].signdx = 1;
        rights[0].e = -lw;
        rights[0].dx = 0;
        rights[0].dy = lw;
        miFillPolyHelper(pDrawable, pGC, pixel, spanData, yorgi - (lw >> 1), lw,
                         lefts, rights, 1, 1);
    }
    else if (dx == 0) {
        if (dy < 0) {
            dy = -dy;
            isLeft = !isLeft;
        }
        topy = yorgi;
        bottomy = yorgi + dy;
        if (isLeft)
            topy -= (lw >> 1);
        else
            bottomy += (lw >> 1);
        lefts[0].height = bottomy - topy;
        lefts[0].x = xorgi - (lw >> 1);
        lefts[0].stepx = 0;
        lefts[0].signdx = 1;
        lefts[0].e = -dy;
        lefts[0].dx = dx;
        lefts[0].dy = dy;

        rights[0].height = bottomy - topy;
        rights[0].x = lefts[0].x + (lw - 1);
        rights[0].stepx = 0;
        rights[0].signdx = 1;
        rights[0].e = -dy;
        rights[0].dx = dx;
        rights[0].dy = dy;
        miFillPolyHelper(pDrawable, pGC, pixel, spanData, topy, bottomy - topy,
                         lefts, rights, 1, 1);
    }
    else {
        xa = face->xa;
        ya = face->ya;
        projectXoff = -ya;
        projectYoff = xa;
        if (dx < 0) {
            right = &rights[1];
            left = &lefts[0];
            top = &rights[0];
            bottom = &lefts[1];
        }
        else {
            right = &rights[0];
            left = &lefts[1];
            top = &lefts[0];
            bottom = &rights[1];
        }
        if (isLeft) {
            righty = miPolyBuildEdge(xa, ya, k, dx, dy, xorgi, yorgi, 0, right);

            xa = -xa;
            ya = -ya;
            k = -k;
            lefty = miPolyBuildEdge(xa - projectXoff, ya - projectYoff,
                                    k, dx, dy, xorgi, yorgi, 1, left);
            if (dx > 0) {
                ya = -ya;
                xa = -xa;
            }
            xap = xa - projectXoff;
            yap = ya - projectYoff;
            topy = miPolyBuildEdge(xap, yap, xap * dx + yap * dy,
                                   -dy, dx, xorgi, yorgi, dx > 0, top);
            bottomy = miPolyBuildEdge(xa, ya,
                                      0.0, -dy, dx, xorgi, yorgi, dx < 0,
                                      bottom);
            maxy = -ya;
        }
        else {
            righty = miPolyBuildEdge(xa - projectXoff, ya - projectYoff,
                                     k, dx, dy, xorgi, yorgi, 0, right);

            xa = -xa;
            ya = -ya;
            k = -k;
            lefty = miPolyBuildEdge(xa, ya, k, dx, dy, xorgi, yorgi, 1, left);
            if (dx > 0) {
                ya = -ya;
                xa = -xa;
            }
            xap = xa - projectXoff;
            yap = ya - projectYoff;
            topy =
                miPolyBuildEdge(xa, ya, 0.0, -dy, dx, xorgi, xorgi, dx > 0,
                                top);
            bottomy =
                miPolyBuildEdge(xap, yap, xap * dx + yap * dy, -dy, dx, xorgi,
                                xorgi, dx < 0, bottom);
            maxy = -ya + projectYoff;
        }
        finaly = ICEIL(maxy) + yorgi;
        if (dx < 0) {
            left->height = bottomy - lefty;
            right->height = finaly - righty;
            top->height = righty - topy;
        }
        else {
            right->height = bottomy - righty;
            left->height = finaly - lefty;
            top->height = lefty - topy;
        }
        bottom->height = finaly - bottomy;
        miFillPolyHelper(pDrawable, pGC, pixel, spanData, topy,
                         bottom->height + bottomy - topy, lefts, rights, 2, 2);
    }
}

static void
miWideSegment(DrawablePtr pDrawable,
              GCPtr pGC,
              unsigned long pixel,
              SpanDataPtr spanData,
              int x1,
              int y1,
              int x2,
              int y2,
              Bool projectLeft,
              Bool projectRight, LineFacePtr leftFace, LineFacePtr rightFace)
{
    double l, L, r;
    double xa, ya;
    double projectXoff = 0.0, projectYoff = 0.0;
    double k;
    double maxy;
    int x, y;
    int dx, dy;
    int finaly;
    PolyEdgePtr left, right;
    PolyEdgePtr top, bottom;
    int lefty, righty, topy, bottomy;
    int signdx;
    PolyEdgeRec lefts[4], rights[4];
    LineFacePtr tface;
    int lw = pGC->lineWidth;

    /* draw top-to-bottom always */
    if (y2 < y1 || (y2 == y1 && x2 < x1)) {
        x = x1;
        x1 = x2;
        x2 = x;

        y = y1;
        y1 = y2;
        y2 = y;

        x = projectLeft;
        projectLeft = projectRight;
        projectRight = x;

        tface = leftFace;
        leftFace = rightFace;
        rightFace = tface;
    }

    dy = y2 - y1;
    signdx = 1;
    dx = x2 - x1;
    if (dx < 0)
        signdx = -1;

    leftFace->x = x1;
    leftFace->y = y1;
    leftFace->dx = dx;
    leftFace->dy = dy;

    rightFace->x = x2;
    rightFace->y = y2;
    rightFace->dx = -dx;
    rightFace->dy = -dy;

    if (dy == 0) {
        rightFace->xa = 0;
        rightFace->ya = (double) lw / 2.0;
        rightFace->k = -(double) (lw * dx) / 2.0;
        leftFace->xa = 0;
        leftFace->ya = -rightFace->ya;
        leftFace->k = rightFace->k;
        x = x1;
        if (projectLeft)
            x -= (lw >> 1);
        y = y1 - (lw >> 1);
        dx = x2 - x;
        if (projectRight)
            dx += ((lw + 1) >> 1);
        dy = lw;
        miFillRectPolyHelper(pDrawable, pGC, pixel, spanData, x, y, dx, dy);
    }
    else if (dx == 0) {
        leftFace->xa = (double) lw / 2.0;
        leftFace->ya = 0;
        leftFace->k = (double) (lw * dy) / 2.0;
        rightFace->xa = -leftFace->xa;
        rightFace->ya = 0;
        rightFace->k = leftFace->k;
        y = y1;
        if (projectLeft)
            y -= lw >> 1;
        x = x1 - (lw >> 1);
        dy = y2 - y;
        if (projectRight)
            dy += ((lw + 1) >> 1);
        dx = lw;
        miFillRectPolyHelper(pDrawable, pGC, pixel, spanData, x, y, dx, dy);
    }
    else {
        l = ((double) lw) / 2.0;
        L = hypot((double) dx, (double) dy);

        if (dx < 0) {
            right = &rights[1];
            left = &lefts[0];
            top = &rights[0];
            bottom = &lefts[1];
        }
        else {
            right = &rights[0];
            left = &lefts[1];
            top = &lefts[0];
            bottom = &rights[1];
        }
        r = l / L;

        /* coord of upper bound at integral y */
        ya = -r * dx;
        xa = r * dy;

        if (projectLeft | projectRight) {
            projectXoff = -ya;
            projectYoff = xa;
        }

        /* xa * dy - ya * dx */
        k = l * L;

        leftFace->xa = xa;
        leftFace->ya = ya;
        leftFace->k = k;
        rightFace->xa = -xa;
        rightFace->ya = -ya;
        rightFace->k = k;

        if (projectLeft)
            righty = miPolyBuildEdge(xa - projectXoff, ya - projectYoff,
                                     k, dx, dy, x1, y1, 0, right);
        else
            righty = miPolyBuildEdge(xa, ya, k, dx, dy, x1, y1, 0, right);

        /* coord of lower bound at integral y */
        ya = -ya;
        xa = -xa;

        /* xa * dy - ya * dx */
        k = -k;

        if (projectLeft)
            lefty = miPolyBuildEdge(xa - projectXoff, ya - projectYoff,
                                    k, dx, dy, x1, y1, 1, left);
        else
            lefty = miPolyBuildEdge(xa, ya, k, dx, dy, x1, y1, 1, left);

        /* coord of top face at integral y */

        if (signdx > 0) {
            ya = -ya;
            xa = -xa;
        }

        if (projectLeft) {
            double xap = xa - projectXoff;
            double yap = ya - projectYoff;

            topy = miPolyBuildEdge(xap, yap, xap * dx + yap * dy,
                                   -dy, dx, x1, y1, dx > 0, top);
        }
        else
            topy = miPolyBuildEdge(xa, ya, 0.0, -dy, dx, x1, y1, dx > 0, top);

        /* coord of bottom face at integral y */

        if (projectRight) {
            double xap = xa + projectXoff;
            double yap = ya + projectYoff;

            bottomy = miPolyBuildEdge(xap, yap, xap * dx + yap * dy,
                                      -dy, dx, x2, y2, dx < 0, bottom);
            maxy = -ya + projectYoff;
        }
        else {
            bottomy = miPolyBuildEdge(xa, ya,
                                      0.0, -dy, dx, x2, y2, dx < 0, bottom);
            maxy = -ya;
        }

        finaly = ICEIL(maxy) + y2;

        if (dx < 0) {
            left->height = bottomy - lefty;
            right->height = finaly - righty;
            top->height = righty - topy;
        }
        else {
            right->height = bottomy - righty;
            left->height = finaly - lefty;
            top->height = lefty - topy;
        }
        bottom->height = finaly - bottomy;
        miFillPolyHelper(pDrawable, pGC, pixel, spanData, topy,
                         bottom->height + bottomy - topy, lefts, rights, 2, 2);
    }
}

static SpanDataPtr
miSetupSpanData(GCPtr pGC, SpanDataPtr spanData, int npt)
{
    if ((npt < 3 && pGC->capStyle != CapRound) || miSpansEasyRop(pGC->alu))
        return (SpanDataPtr) NULL;
    if (pGC->lineStyle == LineDoubleDash)
        miInitSpanGroup(&spanData->bgGroup);
    miInitSpanGroup(&spanData->fgGroup);
    return spanData;
}

static void
miCleanupSpanData(DrawablePtr pDrawable, GCPtr pGC, SpanDataPtr spanData)
{
    if (pGC->lineStyle == LineDoubleDash) {
        ChangeGCVal oldPixel, pixel;

        pixel.val = pGC->bgPixel;
        oldPixel.val = pGC->fgPixel;
        if (pixel.val != oldPixel.val) {
            ChangeGC(NullClient, pGC, GCForeground, &pixel);
            ValidateGC(pDrawable, pGC);
        }
        miFillUniqueSpanGroup(pDrawable, pGC, &spanData->bgGroup);
        miFreeSpanGroup(&spanData->bgGroup);
        if (pixel.val != oldPixel.val) {
            ChangeGC(NullClient, pGC, GCForeground, &oldPixel);
            ValidateGC(pDrawable, pGC);
        }
    }
    miFillUniqueSpanGroup(pDrawable, pGC, &spanData->fgGroup);
    miFreeSpanGroup(&spanData->fgGroup);
}

void
miWideLine(DrawablePtr pDrawable, GCPtr pGC,
           int mode, int npt, DDXPointPtr pPts)
{
    int x1, y1, x2, y2;
    SpanDataRec spanDataRec;
    SpanDataPtr spanData;
    long pixel;
    Bool projectLeft, projectRight;
    LineFaceRec leftFace, rightFace, prevRightFace;
    LineFaceRec firstFace;
    int first;
    Bool somethingDrawn = FALSE;
    Bool selfJoin;

    spanData = miSetupSpanData(pGC, &spanDataRec, npt);
    pixel = pGC->fgPixel;
    x2 = pPts->x;
    y2 = pPts->y;
    first = TRUE;
    selfJoin = FALSE;
    if (npt > 1) {
        if (mode == CoordModePrevious) {
            int nptTmp;
            DDXPointPtr pPtsTmp;

            x1 = x2;
            y1 = y2;
            nptTmp = npt;
            pPtsTmp = pPts + 1;
            while (--nptTmp) {
                x1 += pPtsTmp->x;
                y1 += pPtsTmp->y;
                ++pPtsTmp;
            }
            if (x2 == x1 && y2 == y1)
                selfJoin = TRUE;
        }
        else if (x2 == pPts[npt - 1].x && y2 == pPts[npt - 1].y) {
            selfJoin = TRUE;
        }
    }
    projectLeft = pGC->capStyle == CapProjecting && !selfJoin;
    projectRight = FALSE;
    while (--npt) {
        x1 = x2;
        y1 = y2;
        ++pPts;
        x2 = pPts->x;
        y2 = pPts->y;
        if (mode == CoordModePrevious) {
            x2 += x1;
            y2 += y1;
        }
        if (x1 != x2 || y1 != y2) {
            somethingDrawn = TRUE;
            if (npt == 1 && pGC->capStyle == CapProjecting && !selfJoin)
                projectRight = TRUE;
            miWideSegment(pDrawable, pGC, pixel, spanData, x1, y1, x2, y2,
                          projectLeft, projectRight, &leftFace, &rightFace);
            if (first) {
                if (selfJoin)
                    firstFace = leftFace;
                else if (pGC->capStyle == CapRound) {
                    if (pGC->lineWidth == 1 && !spanData)
                        miLineOnePoint(pDrawable, pGC, pixel, spanData, x1, y1);
                    else
                        miLineArc(pDrawable, pGC, pixel, spanData,
                                  &leftFace, (LineFacePtr) NULL,
                                  (double) 0.0, (double) 0.0, TRUE);
                }
            }
            else {
                miLineJoin(pDrawable, pGC, pixel, spanData, &leftFace,
                           &prevRightFace);
            }
            prevRightFace = rightFace;
            first = FALSE;
            projectLeft = FALSE;
        }
        if (npt == 1 && somethingDrawn) {
            if (selfJoin)
                miLineJoin(pDrawable, pGC, pixel, spanData, &firstFace,
                           &rightFace);
            else if (pGC->capStyle == CapRound) {
                if (pGC->lineWidth == 1 && !spanData)
                    miLineOnePoint(pDrawable, pGC, pixel, spanData, x2, y2);
                else
                    miLineArc(pDrawable, pGC, pixel, spanData,
                              (LineFacePtr) NULL, &rightFace,
                              (double) 0.0, (double) 0.0, TRUE);
            }
        }
    }
    /* handle crock where all points are coincedent */
    if (!somethingDrawn) {
        projectLeft = pGC->capStyle == CapProjecting;
        miWideSegment(pDrawable, pGC, pixel, spanData,
                      x2, y2, x2, y2, projectLeft, projectLeft,
                      &leftFace, &rightFace);
        if (pGC->capStyle == CapRound) {
            miLineArc(pDrawable, pGC, pixel, spanData,
                      &leftFace, (LineFacePtr) NULL,
                      (double) 0.0, (double) 0.0, TRUE);
            rightFace.dx = -1;  /* sleezy hack to make it work */
            miLineArc(pDrawable, pGC, pixel, spanData,
                      (LineFacePtr) NULL, &rightFace,
                      (double) 0.0, (double) 0.0, TRUE);
        }
    }
    if (spanData)
        miCleanupSpanData(pDrawable, pGC, spanData);
}

#define V_TOP	    0
#define V_RIGHT	    1
#define V_BOTTOM    2
#define V_LEFT	    3

static void
miWideDashSegment(DrawablePtr pDrawable,
                  GCPtr pGC,
                  SpanDataPtr spanData,
                  int *pDashOffset,
                  int *pDashIndex,
                  int x1,
                  int y1,
                  int x2,
                  int y2,
                  Bool projectLeft,
                  Bool projectRight,
                  LineFacePtr leftFace, LineFacePtr rightFace)
{
    int dashIndex, dashRemain;
    unsigned char *pDash;
    double L, l;
    double k;
    PolyVertexRec vertices[4];
    PolyVertexRec saveRight, saveBottom;
    PolySlopeRec slopes[4];
    PolyEdgeRec left[4], right[4];
    LineFaceRec lcapFace, rcapFace;
    int nleft, nright;
    int h;
    int y;
    int dy, dx;
    unsigned long pixel;
    double LRemain;
    double r;
    double rdx, rdy;
    double dashDx, dashDy;
    double saveK = 0.0;
    Bool first = TRUE;
    double lcenterx, lcentery, rcenterx = 0.0, rcentery = 0.0;
    unsigned long fgPixel, bgPixel;

    dx = x2 - x1;
    dy = y2 - y1;
    dashIndex = *pDashIndex;
    pDash = pGC->dash;
    dashRemain = pDash[dashIndex] - *pDashOffset;
    fgPixel = pGC->fgPixel;
    bgPixel = pGC->bgPixel;
    if (pGC->fillStyle == FillOpaqueStippled || pGC->fillStyle == FillTiled) {
        bgPixel = fgPixel;
    }

    l = ((double) pGC->lineWidth) / 2.0;
    if (dx == 0) {
        L = dy;
        rdx = 0;
        rdy = l;
        if (dy < 0) {
            L = -dy;
            rdy = -l;
        }
    }
    else if (dy == 0) {
        L = dx;
        rdx = l;
        rdy = 0;
        if (dx < 0) {
            L = -dx;
            rdx = -l;
        }
    }
    else {
        L = hypot((double) dx, (double) dy);
        r = l / L;

        rdx = r * dx;
        rdy = r * dy;
    }
    k = l * L;
    LRemain = L;
    /* All position comments are relative to a line with dx and dy > 0,
     * but the code does not depend on this */
    /* top */
    slopes[V_TOP].dx = dx;
    slopes[V_TOP].dy = dy;
    slopes[V_TOP].k = k;
    /* right */
    slopes[V_RIGHT].dx = -dy;
    slopes[V_RIGHT].dy = dx;
    slopes[V_RIGHT].k = 0;
    /* bottom */
    slopes[V_BOTTOM].dx = -dx;
    slopes[V_BOTTOM].dy = -dy;
    slopes[V_BOTTOM].k = k;
    /* left */
    slopes[V_LEFT].dx = dy;
    slopes[V_LEFT].dy = -dx;
    slopes[V_LEFT].k = 0;

    /* preload the start coordinates */
    vertices[V_RIGHT].x = vertices[V_TOP].x = rdy;
    vertices[V_RIGHT].y = vertices[V_TOP].y = -rdx;

    vertices[V_BOTTOM].x = vertices[V_LEFT].x = -rdy;
    vertices[V_BOTTOM].y = vertices[V_LEFT].y = rdx;

    if (projectLeft) {
        vertices[V_TOP].x -= rdx;
        vertices[V_TOP].y -= rdy;

        vertices[V_LEFT].x -= rdx;
        vertices[V_LEFT].y -= rdy;

        slopes[V_LEFT].k = rdx * dx + rdy * dy;
    }

    lcenterx = x1;
    lcentery = y1;

    if (pGC->capStyle == CapRound) {
        lcapFace.dx = dx;
        lcapFace.dy = dy;
        lcapFace.x = x1;
        lcapFace.y = y1;

        rcapFace.dx = -dx;
        rcapFace.dy = -dy;
        rcapFace.x = x1;
        rcapFace.y = y1;
    }
    while (LRemain > dashRemain) {
        dashDx = (dashRemain * dx) / L;
        dashDy = (dashRemain * dy) / L;

        rcenterx = lcenterx + dashDx;
        rcentery = lcentery + dashDy;

        vertices[V_RIGHT].x += dashDx;
        vertices[V_RIGHT].y += dashDy;

        vertices[V_BOTTOM].x += dashDx;
        vertices[V_BOTTOM].y += dashDy;

        slopes[V_RIGHT].k = vertices[V_RIGHT].x * dx + vertices[V_RIGHT].y * dy;

        if (pGC->lineStyle == LineDoubleDash || !(dashIndex & 1)) {
            if (pGC->lineStyle == LineOnOffDash &&
                pGC->capStyle == CapProjecting) {
                saveRight = vertices[V_RIGHT];
                saveBottom = vertices[V_BOTTOM];
                saveK = slopes[V_RIGHT].k;

                if (!first) {
                    vertices[V_TOP].x -= rdx;
                    vertices[V_TOP].y -= rdy;

                    vertices[V_LEFT].x -= rdx;
                    vertices[V_LEFT].y -= rdy;

                    slopes[V_LEFT].k = vertices[V_LEFT].x *
                        slopes[V_LEFT].dy -
                        vertices[V_LEFT].y * slopes[V_LEFT].dx;
                }

                vertices[V_RIGHT].x += rdx;
                vertices[V_RIGHT].y += rdy;

                vertices[V_BOTTOM].x += rdx;
                vertices[V_BOTTOM].y += rdy;

                slopes[V_RIGHT].k = vertices[V_RIGHT].x *
                    slopes[V_RIGHT].dy -
                    vertices[V_RIGHT].y * slopes[V_RIGHT].dx;
            }
            y = miPolyBuildPoly(vertices, slopes, 4, x1, y1,
                                left, right, &nleft, &nright, &h);
            pixel = (dashIndex & 1) ? bgPixel : fgPixel;
            miFillPolyHelper(pDrawable, pGC, pixel, spanData, y, h, left, right,
                             nleft, nright);

            if (pGC->lineStyle == LineOnOffDash) {
                switch (pGC->capStyle) {
                case CapProjecting:
                    vertices[V_BOTTOM] = saveBottom;
                    vertices[V_RIGHT] = saveRight;
                    slopes[V_RIGHT].k = saveK;
                    break;
                case CapRound:
                    if (!first) {
                        if (dx < 0) {
                            lcapFace.xa = -vertices[V_LEFT].x;
                            lcapFace.ya = -vertices[V_LEFT].y;
                            lcapFace.k = slopes[V_LEFT].k;
                        }
                        else {
                            lcapFace.xa = vertices[V_TOP].x;
                            lcapFace.ya = vertices[V_TOP].y;
                            lcapFace.k = -slopes[V_LEFT].k;
                        }
                        miLineArc(pDrawable, pGC, pixel, spanData,
                                  &lcapFace, (LineFacePtr) NULL,
                                  lcenterx, lcentery, FALSE);
                    }
                    if (dx < 0) {
                        rcapFace.xa = vertices[V_BOTTOM].x;
                        rcapFace.ya = vertices[V_BOTTOM].y;
                        rcapFace.k = slopes[V_RIGHT].k;
                    }
                    else {
                        rcapFace.xa = -vertices[V_RIGHT].x;
                        rcapFace.ya = -vertices[V_RIGHT].y;
                        rcapFace.k = -slopes[V_RIGHT].k;
                    }
                    miLineArc(pDrawable, pGC, pixel, spanData,
                              (LineFacePtr) NULL, &rcapFace,
                              rcenterx, rcentery, FALSE);
                    break;
                }
            }
        }
        LRemain -= dashRemain;
        ++dashIndex;
        if (dashIndex == pGC->numInDashList)
            dashIndex = 0;
        dashRemain = pDash[dashIndex];

        lcenterx = rcenterx;
        lcentery = rcentery;

        vertices[V_TOP] = vertices[V_RIGHT];
        vertices[V_LEFT] = vertices[V_BOTTOM];
        slopes[V_LEFT].k = -slopes[V_RIGHT].k;
        first = FALSE;
    }

    if (pGC->lineStyle == LineDoubleDash || !(dashIndex & 1)) {
        vertices[V_TOP].x -= dx;
        vertices[V_TOP].y -= dy;

        vertices[V_LEFT].x -= dx;
        vertices[V_LEFT].y -= dy;

        vertices[V_RIGHT].x = rdy;
        vertices[V_RIGHT].y = -rdx;

        vertices[V_BOTTOM].x = -rdy;
        vertices[V_BOTTOM].y = rdx;

        if (projectRight) {
            vertices[V_RIGHT].x += rdx;
            vertices[V_RIGHT].y += rdy;

            vertices[V_BOTTOM].x += rdx;
            vertices[V_BOTTOM].y += rdy;
            slopes[V_RIGHT].k = vertices[V_RIGHT].x *
                slopes[V_RIGHT].dy - vertices[V_RIGHT].y * slopes[V_RIGHT].dx;
        }
        else
            slopes[V_RIGHT].k = 0;

        if (!first && pGC->lineStyle == LineOnOffDash &&
            pGC->capStyle == CapProjecting) {
            vertices[V_TOP].x -= rdx;
            vertices[V_TOP].y -= rdy;

            vertices[V_LEFT].x -= rdx;
            vertices[V_LEFT].y -= rdy;
            slopes[V_LEFT].k = vertices[V_LEFT].x *
                slopes[V_LEFT].dy - vertices[V_LEFT].y * slopes[V_LEFT].dx;
        }
        else
            slopes[V_LEFT].k += dx * dx + dy * dy;

        y = miPolyBuildPoly(vertices, slopes, 4, x2, y2,
                            left, right, &nleft, &nright, &h);

        pixel = (dashIndex & 1) ? pGC->bgPixel : pGC->fgPixel;
        miFillPolyHelper(pDrawable, pGC, pixel, spanData, y, h, left, right,
                         nleft, nright);
        if (!first && pGC->lineStyle == LineOnOffDash &&
            pGC->capStyle == CapRound) {
            lcapFace.x = x2;
            lcapFace.y = y2;
            if (dx < 0) {
                lcapFace.xa = -vertices[V_LEFT].x;
                lcapFace.ya = -vertices[V_LEFT].y;
                lcapFace.k = slopes[V_LEFT].k;
            }
            else {
                lcapFace.xa = vertices[V_TOP].x;
                lcapFace.ya = vertices[V_TOP].y;
                lcapFace.k = -slopes[V_LEFT].k;
            }
            miLineArc(pDrawable, pGC, pixel, spanData,
                      &lcapFace, (LineFacePtr) NULL, rcenterx, rcentery, FALSE);
        }
    }
    dashRemain = ((double) dashRemain) - LRemain;
    if (dashRemain == 0) {
        dashIndex++;
        if (dashIndex == pGC->numInDashList)
            dashIndex = 0;
        dashRemain = pDash[dashIndex];
    }

    leftFace->x = x1;
    leftFace->y = y1;
    leftFace->dx = dx;
    leftFace->dy = dy;
    leftFace->xa = rdy;
    leftFace->ya = -rdx;
    leftFace->k = k;

    rightFace->x = x2;
    rightFace->y = y2;
    rightFace->dx = -dx;
    rightFace->dy = -dy;
    rightFace->xa = -rdy;
    rightFace->ya = rdx;
    rightFace->k = k;

    *pDashIndex = dashIndex;
    *pDashOffset = pDash[dashIndex] - dashRemain;
}

void
miWideDash(DrawablePtr pDrawable, GCPtr pGC,
           int mode, int npt, DDXPointPtr pPts)
{
    int x1, y1, x2, y2;
    unsigned long pixel;
    Bool projectLeft, projectRight;
    LineFaceRec leftFace, rightFace, prevRightFace;
    LineFaceRec firstFace;
    int first;
    int dashIndex, dashOffset;
    int prevDashIndex;
    SpanDataRec spanDataRec;
    SpanDataPtr spanData;
    Bool somethingDrawn = FALSE;
    Bool selfJoin;
    Bool endIsFg = FALSE, startIsFg = FALSE;
    Bool firstIsFg = FALSE, prevIsFg = FALSE;

#if 0
    /* XXX backward compatibility */
    if (pGC->lineWidth == 0) {
        miZeroDashLine(pDrawable, pGC, mode, npt, pPts);
        return;
    }
#endif
    if (pGC->lineStyle == LineDoubleDash &&
        (pGC->fillStyle == FillOpaqueStippled || pGC->fillStyle == FillTiled)) {
        miWideLine(pDrawable, pGC, mode, npt, pPts);
        return;
    }
    if (npt == 0)
        return;
    spanData = miSetupSpanData(pGC, &spanDataRec, npt);
    x2 = pPts->x;
    y2 = pPts->y;
    first = TRUE;
    selfJoin = FALSE;
    if (mode == CoordModePrevious) {
        int nptTmp;
        DDXPointPtr pPtsTmp;

        x1 = x2;
        y1 = y2;
        nptTmp = npt;
        pPtsTmp = pPts + 1;
        while (--nptTmp) {
            x1 += pPtsTmp->x;
            y1 += pPtsTmp->y;
            ++pPtsTmp;
        }
        if (x2 == x1 && y2 == y1)
            selfJoin = TRUE;
    }
    else if (x2 == pPts[npt - 1].x && y2 == pPts[npt - 1].y) {
        selfJoin = TRUE;
    }
    projectLeft = pGC->capStyle == CapProjecting && !selfJoin;
    projectRight = FALSE;
    dashIndex = 0;
    dashOffset = 0;
    miStepDash((int) pGC->dashOffset, &dashIndex,
               pGC->dash, (int) pGC->numInDashList, &dashOffset);
    while (--npt) {
        x1 = x2;
        y1 = y2;
        ++pPts;
        x2 = pPts->x;
        y2 = pPts->y;
        if (mode == CoordModePrevious) {
            x2 += x1;
            y2 += y1;
        }
        if (x1 != x2 || y1 != y2) {
            somethingDrawn = TRUE;
            if (npt == 1 && pGC->capStyle == CapProjecting &&
                (!selfJoin || !firstIsFg))
                projectRight = TRUE;
            prevDashIndex = dashIndex;
            miWideDashSegment(pDrawable, pGC, spanData, &dashOffset, &dashIndex,
                              x1, y1, x2, y2,
                              projectLeft, projectRight, &leftFace, &rightFace);
            startIsFg = !(prevDashIndex & 1);
            endIsFg = (dashIndex & 1) ^ (dashOffset != 0);
            if (pGC->lineStyle == LineDoubleDash || startIsFg) {
                pixel = startIsFg ? pGC->fgPixel : pGC->bgPixel;
                if (first || (pGC->lineStyle == LineOnOffDash && !prevIsFg)) {
                    if (first && selfJoin) {
                        firstFace = leftFace;
                        firstIsFg = startIsFg;
                    }
                    else if (pGC->capStyle == CapRound)
                        miLineArc(pDrawable, pGC, pixel, spanData,
                                  &leftFace, (LineFacePtr) NULL,
                                  (double) 0.0, (double) 0.0, TRUE);
                }
                else {
                    miLineJoin(pDrawable, pGC, pixel, spanData, &leftFace,
                               &prevRightFace);
                }
            }
            prevRightFace = rightFace;
            prevIsFg = endIsFg;
            first = FALSE;
            projectLeft = FALSE;
        }
        if (npt == 1 && somethingDrawn) {
            if (pGC->lineStyle == LineDoubleDash || endIsFg) {
                pixel = endIsFg ? pGC->fgPixel : pGC->bgPixel;
                if (selfJoin && (pGC->lineStyle == LineDoubleDash || firstIsFg)) {
                    miLineJoin(pDrawable, pGC, pixel, spanData, &firstFace,
                               &rightFace);
                }
                else {
                    if (pGC->capStyle == CapRound)
                        miLineArc(pDrawable, pGC, pixel, spanData,
                                  (LineFacePtr) NULL, &rightFace,
                                  (double) 0.0, (double) 0.0, TRUE);
                }
            }
            else {
                /* glue a cap to the start of the line if
                 * we're OnOffDash and ended on odd dash
                 */
                if (selfJoin && firstIsFg) {
                    pixel = pGC->fgPixel;
                    if (pGC->capStyle == CapProjecting)
                        miLineProjectingCap(pDrawable, pGC, pixel, spanData,
                                            &firstFace, TRUE,
                                            (double) 0.0, (double) 0.0, TRUE);
                    else if (pGC->capStyle == CapRound)
                        miLineArc(pDrawable, pGC, pixel, spanData,
                                  &firstFace, (LineFacePtr) NULL,
                                  (double) 0.0, (double) 0.0, TRUE);
                }
            }
        }
    }
    /* handle crock where all points are coincident */
    if (!somethingDrawn &&
        (pGC->lineStyle == LineDoubleDash || !(dashIndex & 1))) {
        /* not the same as endIsFg computation above */
        pixel = (dashIndex & 1) ? pGC->bgPixel : pGC->fgPixel;
        switch (pGC->capStyle) {
        case CapRound:
            miLineArc(pDrawable, pGC, pixel, spanData,
                      (LineFacePtr) NULL, (LineFacePtr) NULL,
                      (double) x2, (double) y2, FALSE);
            break;
        case CapProjecting:
            x1 = pGC->lineWidth;
            miFillRectPolyHelper(pDrawable, pGC, pixel, spanData,
                                 x2 - (x1 >> 1), y2 - (x1 >> 1), x1, x1);
            break;
        }
    }
    if (spanData)
        miCleanupSpanData(pDrawable, pGC, spanData);
}

void
miPolylines(DrawablePtr drawable,
            GCPtr gc,
            int mode,
            int n,
            DDXPointPtr points)
{
    if (gc->lineWidth == 0) {
        if (gc->lineStyle == LineSolid)
            miZeroLine(drawable, gc, mode, n, points);
        else
            miZeroDashLine(drawable, gc, mode, n, points);
    } else {
        if (gc->lineStyle == LineSolid)
            miWideLine(drawable, gc, mode, n, points);
        else
            miWideDash(drawable, gc, mode, n, points);
    }
}
@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d192 3
a194 5
                                newPt =
                                    (DDXPointPtr) realloc(spans->points,
                                                          (spans->count +
                                                           EXTRA) *
                                                          sizeof(DDXPointRec));
d199 3
a201 4
                                newwid =
                                    (int *) realloc(spans->widths,
                                                    (spans->count +
                                                     EXTRA) * sizeof(int));
d240 2
a241 2
            spanGroup->group = (Spans *)
                realloc(spanGroup->group, sizeof(Spans) * spanGroup->size);
d456 2
a457 2
        yspans = malloc(ylength * sizeof(Spans));
        ysizes = malloc(ylength * sizeof(int));
d491 5
a495 6
                        newpoints = (DDXPointPtr) realloc(newspans->points,
                                                          ysizes[index] *
                                                          sizeof(DDXPointRec));
                        newwidths =
                            (int *) realloc(newspans->widths,
                                            ysizes[index] * sizeof(int));
d524 2
a525 2
        points = malloc(count * sizeof(DDXPointRec));
        widths = malloc(count * sizeof(int));
d572 1
a572 1
    spans->points = malloc(nspans * sizeof(*spans->points));
d575 1
a575 1
    spans->widths = malloc(nspans * sizeof(*spans->widths));
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d1461 1
a1461 1
    PolyEdgeRec edge1, edge2;
@


1.8
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d27 19
d74 499
d794 1
a794 1
/* static */ int
d846 1
a846 1
/* static */ int
d1386 1
a1386 1
void
d1407 1
a1407 1
int
d2499 20
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d997 1
a997 1
    PolyEdgeRec lefts[2], rights[2];
d1169 1
a1169 1
    PolyEdgeRec lefts[2], rights[2];
d1523 1
a1523 1
    PolyEdgeRec left[2], right[2];
@


1.6
log
@Update to xorg-server 1.9.3. Tested by japser@@, landry@@ and ajacoutot@@
in various configurations.
@
text
@d44 1
a44 1
#define _XOPEN_SOURCE	/* to get prototype for hypot on some systems */
d56 1
a56 1
InitSpans(Spans *spans, size_t nspans)
d58 1
a58 1
    spans->points = malloc(nspans * sizeof (*spans->points));
d60 5
a64 6
	return FALSE;
    spans->widths = malloc(nspans * sizeof (*spans->widths));
    if (!spans->widths)
    {
	free(spans->points);
	return FALSE;
d74 1
a74 1
    SpanGroup	fgGroup, bgGroup;
d78 2
a79 1
AppendSpanGroup(GCPtr pGC, unsigned long pixel, Spans *spanPtr, SpanDataPtr spanData)
d82 9
a90 10
    if (pixel == pGC->fgPixel)
    {
	group = &spanData->fgGroup;
	if (pGC->lineStyle == LineDoubleDash)
	    othergroup = &spanData->bgGroup;
    }
    else
    {
	group = &spanData->bgGroup;
	othergroup = &spanData->fgGroup;
d92 1
a92 1
    miAppendSpans (group, othergroup, spanPtr);
a94 1

d96 4
a99 5
		      unsigned long pixel, SpanDataPtr spanData,
		      LineFacePtr leftFace,
		      LineFacePtr rightFace,
		      double xorg, double yorg, Bool isInt);

d106 2
a107 1
fillSpans(DrawablePtr pDrawable, GCPtr pGC, unsigned long pixel, Spans *spans, SpanDataPtr spanData)
d109 17
a125 18
    if (!spanData)
    {
	ChangeGCVal oldPixel, tmpPixel;
	oldPixel.val = pGC->fgPixel;
	if (pixel != oldPixel.val)
	{
	    tmpPixel.val = (XID)pixel;
	    ChangeGC (NullClient, pGC, GCForeground, &tmpPixel);
	    ValidateGC (pDrawable, pGC);
	}
	(*pGC->ops->FillSpans) (pDrawable, pGC, spans->count, spans->points, spans->widths, TRUE);
	free(spans->widths);
	free(spans->points);
	if (pixel != oldPixel.val)
	{
	    ChangeGC (NullClient, pGC, GCForeground, &oldPixel);
	    ValidateGC (pDrawable, pGC);
	}
d128 1
a128 1
	AppendSpanGroup (pGC, pixel, spans, spanData);
d132 4
a135 4
miFillPolyHelper (DrawablePtr pDrawable, GCPtr pGC, unsigned long pixel,
		  SpanDataPtr spanData, int y, int overall_height,
		  PolyEdgePtr left, PolyEdgePtr right,
		  int left_count, int right_count)
d138 3
a140 3
    int	left_stepx = 0;
    int	left_signdx = 0;
    int	left_dy = 0, left_dx = 0;
d143 3
a145 3
    int	right_stepx = 0;
    int	right_signdx = 0;
    int	right_dy = 0, right_dx = 0;
d147 2
a148 2
    int	height = 0;
    int	left_height = 0, right_height = 0;
d151 3
a153 3
    int 	*pwidth;
    int		xorg;
    Spans	spanRec;
d156 1
a156 1
	return;
d161 59
a219 68
    if (pGC->miTranslate)
    {
	y += pDrawable->y;
	xorg = pDrawable->x;
    }
    while ((left_count || left_height) &&
	   (right_count || right_height))
    {
	if (!left_height && left_count)
	{
	    left_height = left->height;
	    left_x = left->x;
	    left_stepx = left->stepx;
	    left_signdx = left->signdx;
	    left_e = left->e;
	    left_dy = left->dy;
	    left_dx = left->dx;
	    --left_count;
	    ++left;
	}

	if (!right_height && right_count)
	{
	    right_height = right->height;
	    right_x = right->x;
	    right_stepx = right->stepx;
	    right_signdx = right->signdx;
	    right_e = right->e;
	    right_dy = right->dy;
	    right_dx = right->dx;
	    --right_count;
	    ++right;
	}

	height = left_height;
	if (height > right_height)
	    height = right_height;

	left_height -= height;
	right_height -= height;

	while (--height >= 0)
	{
	    if (right_x >= left_x)
	    {
		ppt->y = y;
		ppt->x = left_x + xorg;
		ppt++;
		*pwidth++ = right_x - left_x + 1;
	    }
	    y++;

	    left_x += left_stepx;
	    left_e += left_dx;
	    if (left_e > 0)
	    {
		left_x += left_signdx;
		left_e -= left_dy;
	    }

	    right_x += right_stepx;
	    right_e += right_dx;
	    if (right_e > 0)
	    {
		right_x += right_signdx;
		right_e -= right_dy;
	    }
	}
d222 1
a222 1
    fillSpans (pDrawable, pGC, pixel, &spanRec, spanData);
d226 4
a229 9
miFillRectPolyHelper (
    DrawablePtr	pDrawable,
    GCPtr	pGC,
    unsigned long   pixel,
    SpanDataPtr	spanData,
    int		x,
    int		y,
    int		w,
    int		h)
d232 4
a235 4
    int 	*pwidth;
    ChangeGCVal	oldPixel, tmpPixel;
    Spans	spanRec;
    xRectangle  rect;
d237 36
a272 42
    if (!spanData)
    {
	rect.x = x;
	rect.y = y;
	rect.width = w;
	rect.height = h;
	oldPixel.val = pGC->fgPixel;
	if (pixel != oldPixel.val)
    	{
	    tmpPixel.val = (XID)pixel;
	    ChangeGC (NullClient, pGC, GCForeground, &tmpPixel);
    	    ValidateGC (pDrawable, pGC);
    	}
	(*pGC->ops->PolyFillRect) (pDrawable, pGC, 1, &rect);
	if (pixel != oldPixel.val)
    	{
	    ChangeGC (NullClient, pGC, GCForeground, &oldPixel);
	    ValidateGC (pDrawable, pGC);
    	}
    }
    else
    {
	if (!InitSpans(&spanRec, h))
	    return;
	ppt = spanRec.points;
	pwidth = spanRec.widths;

    	if (pGC->miTranslate)
    	{
	    y += pDrawable->y;
	    x += pDrawable->x;
    	}
	while (h--)
	{
	    ppt->x = x;
	    ppt->y = y;
	    ppt++;
	    *pwidth++ = w;
	    y++;
	}
	spanRec.count = ppt - spanRec.points;
	AppendSpanGroup (pGC, pixel, &spanRec, spanData);
d277 2
a278 10
miPolyBuildEdge (
    double	x0,
    double	y0,
    double	k,  /* x0 * dy - y0 * dx */
    int		dx,
    int		dy,
    int		xi,
    int		yi,
    int		left,
    PolyEdgePtr edge)
d280 2
a281 2
    int	    x, y, e;
    int	    xady;
d283 4
a286 5
    if (dy < 0)
    {
	dy = -dy;
	dx = -dx;
	k = -k;
d291 6
a296 5
	double	realk, kerror;
    	realk = x0 * dy - y0 * dx;
    	kerror = Fabs (realk - k);
    	if (kerror > .1)
	    printf ("realk: %g k: %g\n", realk, k);
d299 2
a300 2
    y = ICEIL (y0);
    xady = ICEIL (k) + y * dx;
d303 1
a303 1
	x = - (-xady / dy) - 1;
d305 1
a305 1
	x = (xady - 1) / dy;
d309 10
a318 12
    if (dx >= 0)
    {
	edge->signdx = 1;
	edge->stepx = dx / dy;
	edge->dx = dx % dy;
    }
    else
    {
	edge->signdx = -1;
	edge->stepx = - (-dx / dy);
	edge->dx = -dx % dy;
	e = dy - e + 1;
d322 1
a322 1
    edge->e = e - dy;	/* bias to compare against 0 instead of dy */
d329 17
a345 21
miPolyBuildPoly (
    PolyVertexPtr	vertices,
    PolySlopePtr	slopes,
    int			count,
    int			xi,
    int			yi,
    PolyEdgePtr		left,
    PolyEdgePtr		right,
    int			*pnleft,
    int			*pnright,
    int			*h)
{
    int 	top, bottom;
    double 	miny, maxy;
    int 	i;
    int		j;
    int		clockwise;
    int		slopeoff;
    int 	s;
    int 	nright, nleft;
    int	   	y, lasty = 0, bottomy, topy = 0;
d350 9
a358 12
    for (i = 1; i < count; i++)
    {
	if (vertices[i].y < miny)
	{
	    top = i;
	    miny = vertices[i].y;
	}
	if (vertices[i].y >= maxy)
	{
	    bottom = i;
	    maxy = vertices[i].y;
	}
d364 1
a364 1
    j = StepAround (top, -1, count);
d366 4
a369 4
    if ((int64_t)slopes[j].dy * slopes[i].dx > (int64_t)slopes[i].dy * slopes[j].dx)
    {
	clockwise = -1;
	slopeoff = -1;
d372 1
a372 1
    bottomy = ICEIL (maxy) + yi;
d376 1
a376 1
    s = StepAround (top, slopeoff, count);
d378 13
a390 16
    while (i != bottom)
    {
	if (slopes[s].dy != 0)
	{
	    y = miPolyBuildEdge (vertices[i].x, vertices[i].y,
			slopes[s].k,
			slopes[s].dx, slopes[s].dy,
			xi, yi, 0,
			&right[nright]);
	    if (nright != 0)
	    	right[nright-1].height = y - lasty;
	    else
	    	topy = y;
	    nright++;
	    lasty = y;
	}
d392 2
a393 2
	i = StepAround (i, clockwise, count);
	s = StepAround (s, clockwise, count);
d396 1
a396 1
	right[nright-1].height = bottomy - lasty;
d399 1
a399 1
	slopeoff = -1;
d401 1
a401 1
	slopeoff = 0;
d404 1
a404 1
    s = StepAround (top, slopeoff, count);
d406 14
a419 16
    while (i != bottom)
    {
	if (slopes[s].dy != 0)
	{
	    y = miPolyBuildEdge (vertices[i].x, vertices[i].y,
			   slopes[s].k,
		       	   slopes[s].dx,  slopes[s].dy, xi, yi, 1,
		       	   &left[nleft]);
    
	    if (nleft != 0)
	    	left[nleft-1].height = y - lasty;
	    nleft++;
	    lasty = y;
	}
	i = StepAround (i, -clockwise, count);
	s = StepAround (s, -clockwise, count);
d422 1
a422 1
	left[nleft-1].height = bottomy - lasty;
d430 3
a432 7
miLineOnePoint (
    DrawablePtr	    pDrawable,
    GCPtr	    pGC,
    unsigned long   pixel,
    SpanDataPtr	    spanData,
    int		    x,
    int		    y)
d435 2
a436 2
    int	    wid;
    unsigned long	oldPixel;
d438 15
a452 18
    MILINESETPIXEL (pDrawable, pGC, pixel, oldPixel);
    if (pGC->fillStyle == FillSolid)
    {
	pt.x = x;
	pt.y = y;
	(*pGC->ops->PolyPoint) (pDrawable, pGC, CoordModeOrigin, 1, &pt);
    }
    else
    {
	wid = 1;
	if (pGC->miTranslate) 
	{
	    x += pDrawable->x;
	    y += pDrawable->y;
	}
	pt.x = x;
	pt.y = y;
	(*pGC->ops->FillSpans) (pDrawable, pGC, 1, &pt, &wid, TRUE);
d454 1
a454 1
    MILINERESETPIXEL (pDrawable, pGC, pixel, oldPixel);
d458 16
a473 19
miLineJoin (
    DrawablePtr 	pDrawable,
    GCPtr		pGC,
    unsigned long	pixel,
    SpanDataPtr		spanData,
    LineFacePtr		pLeft,
    LineFacePtr 	pRight)
{
    double	    mx = 0, my = 0;
    double	    denom = 0.0;
    PolyVertexRec   vertices[4];
    PolySlopeRec    slopes[4];
    int		    edgecount;
    PolyEdgeRec	    left[4], right[4];
    int		    nleft, nright;
    int		    y, height;
    int		    swapslopes;
    int		    joinStyle = pGC->joinStyle;
    int		    lw = pGC->lineWidth;
d476 27
a502 25
	/* See if one of the lines will draw the joining pixel */
	if (pLeft->dx > 0 || (pLeft->dx == 0 && pLeft->dy > 0))
	    return;
	if (pRight->dx > 0 || (pRight->dx == 0 && pRight->dy > 0))
	    return;
	if (joinStyle != JoinRound) {
    	    denom = - pLeft->dx * (double)pRight->dy + pRight->dx * (double)pLeft->dy;
    	    if (denom == 0)
	    	return;	/* no join to draw */
	}
	if (joinStyle != JoinMiter) {
	    miLineOnePoint (pDrawable, pGC, pixel, spanData, pLeft->x, pLeft->y);
	    return;
	}
    } else {
    	if (joinStyle == JoinRound)
    	{
	    miLineArc(pDrawable, pGC, pixel, spanData,
		      pLeft, pRight,
		      (double)0.0, (double)0.0, TRUE);
	    return;
    	}
    	denom = - pLeft->dx * (double)pRight->dy + pRight->dx * (double)pLeft->dy;
    	if (denom == 0.0)
	    return;	/* no join to draw */
d506 12
a517 14
    if (denom > 0)
    {
	pLeft->xa = -pLeft->xa;
	pLeft->ya = -pLeft->ya;
	pLeft->dx = -pLeft->dx;
	pLeft->dy = -pLeft->dy;
    }
    else
    {
	swapslopes = 1;
	pRight->xa = -pRight->xa;
	pRight->ya = -pRight->ya;
	pRight->dx = -pRight->dx;
	pRight->dy = -pRight->dy;
d523 1
a523 1
    slopes[0].dy =  pRight->dx;
d528 1
a528 1
    slopes[1].dx =  pLeft->dy;
d535 61
a595 67
    if (joinStyle == JoinMiter)
    {
    	my = (pLeft->dy  * (pRight->xa * pRight->dy - pRight->ya * pRight->dx) -
              pRight->dy * (pLeft->xa  * pLeft->dy  - pLeft->ya  * pLeft->dx )) /
	      denom;
    	if (pLeft->dy != 0)
    	{
	    mx = pLeft->xa + (my - pLeft->ya) *
			    (double) pLeft->dx / (double) pLeft->dy;
    	}
    	else
    	{
	    mx = pRight->xa + (my - pRight->ya) *
			    (double) pRight->dx / (double) pRight->dy;
    	}
	/* check miter limit */
	if ((mx * mx + my * my) * 4 > SQSECANT * lw * lw)
	    joinStyle = JoinBevel;
    }

    if (joinStyle == JoinMiter)
    {
	slopes[2].dx = pLeft->dx;
	slopes[2].dy = pLeft->dy;
	slopes[2].k =  pLeft->k;
	if (swapslopes)
	{
	    slopes[2].dx = -slopes[2].dx;
	    slopes[2].dy = -slopes[2].dy;
	    slopes[2].k  = -slopes[2].k;
	}
	vertices[3].x = mx;
	vertices[3].y = my;
	slopes[3].dx = pRight->dx;
	slopes[3].dy = pRight->dy;
	slopes[3].k  = pRight->k;
	if (swapslopes)
	{
	    slopes[3].dx = -slopes[3].dx;
	    slopes[3].dy = -slopes[3].dy;
	    slopes[3].k  = -slopes[3].k;
	}
	edgecount = 4;
    }
    else
    {
	double	scale, dx, dy, adx, ady;

	adx = dx = pRight->xa - pLeft->xa;
	ady = dy = pRight->ya - pLeft->ya;
	if (adx < 0)
	    adx = -adx;
	if (ady < 0)
	    ady = -ady;
	scale = ady;
	if (adx > ady)
	    scale = adx;
	slopes[2].dx = (dx * 65536) / scale;
	slopes[2].dy = (dy * 65536) / scale;
	slopes[2].k = ((pLeft->xa + pRight->xa) * slopes[2].dy -
		       (pLeft->ya + pRight->ya) * slopes[2].dx) / 2.0;
	edgecount = 3;
    }

    y = miPolyBuildPoly (vertices, slopes, edgecount, pLeft->x, pLeft->y,
		   left, right, &nleft, &nright, &height);
    miFillPolyHelper (pDrawable, pGC, pixel, spanData, y, height, left, right, nleft, nright);
d599 2
a600 7
miLineArcI (
    DrawablePtr	    pDraw,
    GCPtr	    pGC,
    int		    xorg,
    int		    yorg,
    DDXPointPtr	    points,
    int		    *widths)
d608 3
a610 4
    if (pGC->miTranslate)
    {
	xorg += pDraw->x;
	yorg += pDraw->y;
d613 5
a617 6
    if (slw == 1)
    {
	tpts->x = xorg;
	tpts->y = yorg;
	*twids = 1;
	return 1;
d623 1
a623 1
	e = - ((y << 2) + 3);
d625 1
a625 1
	e = - (y << 3);
d628 20
a647 23
    while (y)
    {
	e += (y << 3) - 4;
	while (e >= 0)
	{
	    x++;
	    e += (ex = -((x << 3) + 4));
	}
	y--;
	slw = (x << 1) + 1;
	if ((e == ex) && (slw > 1))
	    slw--;
	tpts->x = xorg - x;
	tpts->y = yorg - y;
	tpts++;
	*twids++ = slw;
	if ((y != 0) && ((slw > 1) || (e != ex)))
	{
	    bpts--;
	    bpts->x = xorg - x;
	    bpts->y = yorg + y;
	    *--bwids = slw;
	}
d676 9
a684 13
miLineArcD (
    DrawablePtr	    pDraw,
    GCPtr	    pGC,
    double	    xorg,
    double	    yorg,
    DDXPointPtr	    points,
    int		    *widths,
    PolyEdgePtr	    edge1,
    int		    edgey1,
    Bool	    edgeleft1,
    PolyEdgePtr	    edge2,
    int		    edgey2,
    Bool	    edgeleft2)
d698 1
a698 1
    ybase = ICEIL (yorg);
d700 7
a706 8
    if (pGC->miTranslate)
    {
	xbase += pDraw->x;
	ybase += pDraw->y;
	edge1->x += pDraw->x;
	edge2->x += pDraw->x;
	edgey1 += pDraw->y;
	edgey2 += pDraw->y;
d711 1
a711 1
    radius = ((double)pGC->lineWidth) / 2.0;
d718 12
a729 15
    if (edge1->dy >= 0)
    {
    	if (!edge1->dy)
    	{
	    if (edgeleft1)
	    	edge1IsMin = TRUE;
	    else
	    	ymax = edgey1;
	    edgey1 = 65536;
    	}
    	else
    	{
	    if ((edge1->signdx < 0) == edgeleft1)
	    	edge1IsMin = TRUE;
    	}
d733 17
a749 15
    if (edge2->dy >= 0)
    {
    	if (!edge2->dy)
    	{
	    if (edgeleft2)
	    	edge2IsMin = TRUE;
	    else
	    	ymax = edgey2;
	    edgey2 = 65536;
    	}
    	else
    	{
	    if ((edge2->signdx < 0) == edgeleft2)
	    	edge2IsMin = TRUE;
    	}
d751 2
a752 7
    if (edge1IsMin)
    {
	ymin = ymin1;
	if (edge2IsMin && ymin1 > ymin2)
	    ymin = ymin2;
    } else if (edge2IsMin)
	ymin = ymin2;
d757 3
a759 4
    if (x0 < 0.5)
    {
	xl = 0;
	el -= xlk;
d763 27
a789 31
	boty = ymax - ybase - y;
    while (y > boty)
    {
	k = (y << 1) + yk;
	er += k;
	while (er > 0.0)
	{
	    xr++;
	    er += xrk - (xr << 1);
	}
	el += k;
	while (el >= 0.0)
	{
	    xl--;
	    el += (xl << 1) - xlk;
	}
	y--;
	ybase++;
	if (ybase < ymin)
	    continue;
	xcl = xl + xbase;
	xcr = xr + xbase;
	CLIPSTEPEDGE(edgey1, edge1, edgeleft1);
	CLIPSTEPEDGE(edgey2, edge2, edgeleft2);
	if (xcr >= xcl)
	{
	    pts->x = xcl;
	    pts->y = ybase;
	    pts++;
	    *wids++ = xcr - xcl + 1;
	}
d795 27
a821 31
	boty = ymax - ybase - y;
    while (y > boty)
    {
	k = (y << 1) + yk;
	er -= k;
	while ((er >= 0.0) && (xr >= 0))
	{
	    xr--;
	    er += xrk - (xr << 1);
	}
	el -= k;
	while ((el > 0.0) && (xl <= 0))
	{
	    xl++;
	    el += (xl << 1) - xlk;
	}
	y--;
	ybase++;
	if (ybase < ymin)
	    continue;
	xcl = xl + xbase;
	xcr = xr + xbase;
	CLIPSTEPEDGE(edgey1, edge1, edgeleft1);
	CLIPSTEPEDGE(edgey2, edge2, edgeleft2);
	if (xcr >= xcl)
	{
	    pts->x = xcl;
	    pts->y = ybase;
	    pts++;
	    *wids++ = xcr - xcl + 1;
	}
d827 1
a827 1
miRoundJoinFace (LineFacePtr face, PolyEdgePtr edge, Bool *leftEdge)
d829 4
a832 4
    int	    y;
    int	    dx, dy;
    double  xa, ya;
    Bool	left;
d839 8
a846 10
    if (ya > 0)
    {
	ya = 0.0;
	xa = 0.0;
    }
    if (dy < 0 || (dy == 0 && dx > 0))
    {
	dx = -dx;
	dy = -dy;
	left = !left;
d849 14
a862 16
	dy = 1;
    if (dy == 0)
    {
	y = ICEIL (face->ya) + face->y;
	edge->x = -32767;
	edge->stepx = 0;
	edge->signdx = 0;
	edge->e = -1;
	edge->dy = 0;
	edge->dx = 0;
	edge->height = 0;
    }
    else
    {
	y = miPolyBuildEdge (xa, ya, 0.0, dx, dy, face->x, face->y, !left, edge);
	edge->height = 32767;
d869 3
a871 3
miRoundJoinClip (LineFacePtr pLeft, LineFacePtr pRight,
		 PolyEdgePtr edge1, PolyEdgePtr edge2,
		 int *y1, int *y2, Bool *left1, Bool *left2)
d873 1
a873 1
    double	denom;
d875 1
a875 1
    denom = - pLeft->dx * (double)pRight->dy + pRight->dx * (double)pLeft->dy;
d877 3
a879 4
    if (denom >= 0)
    {
	pLeft->xa = -pLeft->xa;
	pLeft->ya = -pLeft->ya;
d881 3
a883 4
    else
    {
	pRight->xa = -pRight->xa;
	pRight->ya = -pRight->ya;
d885 2
a886 2
    *y1 = miRoundJoinFace (pLeft, edge1, left1);
    *y2 = miRoundJoinFace (pRight, edge2, left2);
d890 1
a890 1
miRoundCapClip (LineFacePtr face, Bool isInt, PolyEdgePtr edge, Bool *leftEdge)
d892 4
a895 4
    int		y;
    int 	dx, dy;
    double	xa, ya, k;
    Bool	left;
d903 1
a903 1
	k = face->k;
d905 6
a910 7
    if (dy < 0 || (dy == 0 && dx > 0))
    {
	dx = -dx;
	dy = -dy;
	xa = -xa;
	ya = -ya;
	left = !left;
d913 14
a926 16
	dy = 1;
    if (dy == 0)
    {
	y = ICEIL (face->ya) + face->y;
	edge->x = -32767;
	edge->stepx = 0;
	edge->signdx = 0;
	edge->e = -1;
	edge->dy = 0;
	edge->dx = 0;
	edge->height = 0;
    }
    else
    {
	y = miPolyBuildEdge (xa, ya, k, dx, dy, face->x, face->y, !left, edge);
	edge->height = 32767;
d933 6
a938 10
miLineArc (
    DrawablePtr		pDraw,
    GCPtr  		pGC,
    unsigned long	pixel,
    SpanDataPtr		spanData,
    LineFacePtr		leftFace,
    LineFacePtr 	rightFace,
    double	    	xorg,
    double          	yorg,
    Bool	    	isInt)
d943 7
a949 8
    PolyEdgeRec	edge1, edge2;
    int		edgey1, edgey2;
    Bool	edgeleft1, edgeleft2;

    if (isInt)
    {
	xorgi = leftFace ? leftFace->x : rightFace->x;
	yorgi = leftFace ? leftFace->y : rightFace->y;
d953 1
a953 1
    edge1.x = 0; /* not used, keep memory checkers happy */
d955 1
a955 1
    edge2.x = 0; /* not used, keep memory checkers happy */
d960 17
a976 22
	((pGC->capStyle == CapRound && pGC->joinStyle != JoinRound) ||
	 (pGC->joinStyle == JoinRound && pGC->capStyle == CapButt)))
    {
	if (isInt)
	{
	    xorg = (double) xorgi;
	    yorg = (double) yorgi;
	}
	if (leftFace && rightFace)
	{
	    miRoundJoinClip (leftFace, rightFace, &edge1, &edge2,
			     &edgey1, &edgey2, &edgeleft1, &edgeleft2);
	}
	else if (leftFace)
	{
	    edgey1 = miRoundCapClip (leftFace, isInt, &edge1, &edgeleft1);
	}
	else if (rightFace)
	{
	    edgey2 = miRoundCapClip (rightFace, isInt, &edge2, &edgeleft2);
	}
	isInt = FALSE;
d979 1
a979 1
	return;
d981 2
a982 1
	n = miLineArcI(pDraw, pGC, xorgi, yorgi, spanRec.points, spanRec.widths);
d984 2
a985 3
	n = miLineArcD(pDraw, pGC, xorg, yorg, spanRec.points, spanRec.widths,
		       &edge1, edgey1, edgeleft1,
		       &edge2, edgey2, edgeleft2);
d987 1
a987 1
    fillSpans (pDraw, pGC, pixel, &spanRec, spanData);
d991 8
a998 8
miLineProjectingCap (DrawablePtr pDrawable, GCPtr pGC, unsigned long pixel,
		     SpanDataPtr spanData, LineFacePtr face, Bool isLeft,
		     double xorg, double yorg, Bool isInt)
{
    int	xorgi = 0, yorgi = 0;
    int	lw;
    PolyEdgeRec	lefts[2], rights[2];
    int		lefty, righty, topy, bottomy;
d1000 12
a1011 13
    PolyEdgePtr	top, bottom;
    double	xa,ya;
    double	k;
    double	xap, yap;
    int		dx, dy;
    double	projectXoff, projectYoff;
    double	maxy;
    int		finaly;
    
    if (isInt)
    {
	xorgi = face->x;
	yorgi = face->y;
d1017 125
a1141 133
    if (dy == 0)
    {
	lefts[0].height = lw;
	lefts[0].x = xorgi;
	if (isLeft)
	    lefts[0].x -= (lw >> 1);
	lefts[0].stepx = 0;
	lefts[0].signdx = 1;
	lefts[0].e = -lw;
	lefts[0].dx = 0;
	lefts[0].dy = lw;
	rights[0].height = lw;
	rights[0].x = xorgi;
	if (!isLeft)
	    rights[0].x += ((lw + 1) >> 1);
	rights[0].stepx = 0;
	rights[0].signdx = 1;
	rights[0].e = -lw;
	rights[0].dx = 0;
	rights[0].dy = lw;
	miFillPolyHelper (pDrawable, pGC, pixel, spanData, yorgi - (lw >> 1), lw,
		     lefts, rights, 1, 1);
    }
    else if (dx == 0)
    {
	if (dy < 0) {
	    dy = -dy;
	    isLeft = !isLeft;
	}
	topy = yorgi;
	bottomy = yorgi + dy;
	if (isLeft)
	    topy -= (lw >> 1);
	else
	    bottomy += (lw >> 1);
	lefts[0].height = bottomy - topy;
	lefts[0].x = xorgi - (lw >> 1);
	lefts[0].stepx = 0;
	lefts[0].signdx = 1;
	lefts[0].e = -dy;
	lefts[0].dx = dx;
	lefts[0].dy = dy;

	rights[0].height = bottomy - topy;
	rights[0].x = lefts[0].x + (lw-1);
	rights[0].stepx = 0;
	rights[0].signdx = 1;
	rights[0].e = -dy;
	rights[0].dx = dx;
	rights[0].dy = dy;
	miFillPolyHelper (pDrawable, pGC, pixel, spanData, topy, bottomy - topy, lefts, rights, 1, 1);
    }
    else
    {
	xa = face->xa;
	ya = face->ya;
	projectXoff = -ya;
	projectYoff = xa;
	if (dx < 0)
	{
	    right = &rights[1];
	    left = &lefts[0];
	    top = &rights[0];
	    bottom = &lefts[1];
	}
	else
	{
	    right = &rights[0];
	    left = &lefts[1];
	    top = &lefts[0];
	    bottom = &rights[1];
	}
	if (isLeft)
	{
	    righty = miPolyBuildEdge (xa, ya,
		     k, dx, dy, xorgi, yorgi, 0, right);
	    
	    xa = -xa;
	    ya = -ya;
	    k = -k;
	    lefty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,
				     k, dx, dy, xorgi, yorgi, 1, left);
	    if (dx > 0)
	    {
		ya = -ya;
		xa = -xa;
	    }
	    xap = xa - projectXoff;
	    yap = ya - projectYoff;
	    topy = miPolyBuildEdge (xap, yap, xap * dx + yap * dy,
				    -dy, dx, xorgi, yorgi, dx > 0, top);
	    bottomy = miPolyBuildEdge (xa, ya,
				       0.0, -dy, dx, xorgi, yorgi, dx < 0, bottom);
	    maxy = -ya;
	}
	else
	{
	    righty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,
		     k, dx, dy, xorgi, yorgi, 0, right);
	    
	    xa = -xa;
	    ya = -ya;
	    k = -k;
	    lefty = miPolyBuildEdge (xa, ya,
		    k, dx, dy, xorgi, yorgi, 1, left);
	    if (dx > 0)
	    {
		ya = -ya;
		xa = -xa;
	    }
	    xap = xa - projectXoff;
	    yap = ya - projectYoff;
	    topy = miPolyBuildEdge (xa, ya, 0.0, -dy, dx, xorgi, xorgi, dx > 0, top);
	    bottomy = miPolyBuildEdge (xap, yap, xap * dx + yap * dy,
				       -dy, dx, xorgi, xorgi, dx < 0, bottom);
	    maxy = -ya + projectYoff;
	}
	finaly = ICEIL(maxy) + yorgi;
	if (dx < 0)
	{
	    left->height = bottomy - lefty;
	    right->height = finaly - righty;
	    top->height = righty - topy;
	}
	else
	{
	    right->height =  bottomy - righty;
	    left->height = finaly - lefty;
	    top->height = lefty - topy;
	}
	bottom->height = finaly - bottomy;
	miFillPolyHelper (pDrawable, pGC, pixel, spanData, topy,
		     bottom->height + bottomy - topy, lefts, rights, 2, 2);
d1146 19
a1164 22
miWideSegment (
    DrawablePtr		pDrawable,
    GCPtr		pGC,
    unsigned long	pixel,
    SpanDataPtr		spanData,
    int    		x1,
    int    		y1,
    int    		x2,
    int    		y2,
    Bool		projectLeft,
    Bool		projectRight,
    LineFacePtr 	leftFace,
    LineFacePtr 	rightFace)
{
    double	l, L, r;
    double	xa, ya;
    double	projectXoff = 0.0, projectYoff = 0.0;
    double	k;
    double	maxy;
    int		x, y;
    int		dx, dy;
    int		finaly;
d1166 6
a1171 6
    PolyEdgePtr	top, bottom;
    int		lefty, righty, topy, bottomy;
    int		signdx;
    PolyEdgeRec	lefts[2], rights[2];
    LineFacePtr	tface;
    int		lw = pGC->lineWidth;
d1174 16
a1189 17
    if (y2 < y1 || (y2 == y1 && x2 < x1))
    {
	x = x1;
	x1 = x2;
	x2 = x;

	y = y1;
	y1 = y2;
	y2 = y;

	x = projectLeft;
	projectLeft = projectRight;
	projectRight = x;

	tface = leftFace;
	leftFace = rightFace;
	rightFace = tface;
d1196 1
a1196 1
	signdx = -1;
d1208 138
a1345 152
    if (dy == 0)
    {
	rightFace->xa = 0;
	rightFace->ya = (double) lw / 2.0;
	rightFace->k = -(double) (lw * dx) / 2.0;
	leftFace->xa = 0;
	leftFace->ya = -rightFace->ya;
	leftFace->k = rightFace->k;
	x = x1;
	if (projectLeft)
	    x -= (lw >> 1);
	y = y1 - (lw >> 1);
	dx = x2 - x;
	if (projectRight)
	    dx += ((lw + 1) >> 1);
	dy = lw;
	miFillRectPolyHelper (pDrawable, pGC, pixel, spanData,
			      x, y, dx, dy);
    }
    else if (dx == 0)
    {
	leftFace->xa =  (double) lw / 2.0;
	leftFace->ya = 0;
	leftFace->k = (double) (lw * dy) / 2.0;
	rightFace->xa = -leftFace->xa;
	rightFace->ya = 0;
	rightFace->k = leftFace->k;
	y = y1;
	if (projectLeft)
	    y -= lw >> 1;
	x = x1 - (lw >> 1);
	dy = y2 - y;
	if (projectRight)
	    dy += ((lw + 1) >> 1);
	dx = lw;
	miFillRectPolyHelper (pDrawable, pGC, pixel, spanData,
			      x, y, dx, dy);
    }
    else
    {
    	l = ((double) lw) / 2.0;
    	L = hypot ((double) dx, (double) dy);

	if (dx < 0)
	{
	    right = &rights[1];
	    left = &lefts[0];
	    top = &rights[0];
	    bottom = &lefts[1];
	}
	else
	{
	    right = &rights[0];
	    left = &lefts[1];
	    top = &lefts[0];
	    bottom = &rights[1];
	}
	r = l / L;

	/* coord of upper bound at integral y */
	ya = -r * dx;
	xa = r * dy;

	if (projectLeft | projectRight)
	{
	    projectXoff = -ya;
	    projectYoff = xa;
	}

    	/* xa * dy - ya * dx */
	k = l * L;

	leftFace->xa = xa;
	leftFace->ya = ya;
	leftFace->k = k;
	rightFace->xa = -xa;
	rightFace->ya = -ya;
	rightFace->k = k;

	if (projectLeft)
	    righty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,
				      k, dx, dy, x1, y1, 0, right);
	else
	    righty = miPolyBuildEdge (xa, ya,
				      k, dx, dy, x1, y1, 0, right);

	/* coord of lower bound at integral y */
	ya = -ya;
	xa = -xa;

	/* xa * dy - ya * dx */
	k = - k;

	if (projectLeft)
	    lefty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,
				     k, dx, dy, x1, y1, 1, left);
	else
	    lefty = miPolyBuildEdge (xa, ya,
				     k, dx, dy, x1, y1, 1, left);

	/* coord of top face at integral y */

	if (signdx > 0)
	{
	    ya = -ya;
	    xa = -xa;
	}

	if (projectLeft)
	{
	    double xap = xa - projectXoff;
	    double yap = ya - projectYoff;
	    topy = miPolyBuildEdge (xap, yap, xap * dx + yap * dy,
				    -dy, dx, x1, y1, dx > 0, top);
	}
	else
	    topy = miPolyBuildEdge (xa, ya, 0.0, -dy, dx, x1, y1, dx > 0, top);

	/* coord of bottom face at integral y */

	if (projectRight)
	{
	    double xap = xa + projectXoff;
	    double yap = ya + projectYoff;
	    bottomy = miPolyBuildEdge (xap, yap, xap * dx + yap * dy,
				       -dy, dx, x2, y2, dx < 0, bottom);
	    maxy = -ya + projectYoff;
	}
	else
	{
	    bottomy = miPolyBuildEdge (xa, ya,
				       0.0, -dy, dx, x2, y2, dx < 0, bottom);
	    maxy = -ya;
	}

	finaly = ICEIL (maxy) + y2;

	if (dx < 0)
	{
	    left->height = bottomy - lefty;
	    right->height = finaly - righty;
	    top->height = righty - topy;
	}
	else
	{
	    right->height =  bottomy - righty;
	    left->height = finaly - lefty;
	    top->height = lefty - topy;
	}
	bottom->height = finaly - bottomy;
	miFillPolyHelper (pDrawable, pGC, pixel, spanData, topy,
		     bottom->height + bottomy - topy, lefts, rights, 2, 2);
d1350 1
a1350 1
miSetupSpanData (GCPtr pGC, SpanDataPtr spanData, int npt)
d1353 1
a1353 1
	return (SpanDataPtr) NULL;
d1355 2
a1356 2
	miInitSpanGroup (&spanData->bgGroup);
    miInitSpanGroup (&spanData->fgGroup);
d1361 1
a1361 1
miCleanupSpanData (DrawablePtr pDrawable, GCPtr pGC, SpanDataPtr spanData)
d1363 15
a1377 17
    if (pGC->lineStyle == LineDoubleDash)
    {
	ChangeGCVal oldPixel, pixel;
	pixel.val = pGC->bgPixel;
	oldPixel.val = pGC->fgPixel;
	if (pixel.val != oldPixel.val)
    	{
	    ChangeGC (NullClient, pGC, GCForeground, &pixel);
    	    ValidateGC (pDrawable, pGC);
    	}
	miFillUniqueSpanGroup (pDrawable, pGC, &spanData->bgGroup);
	miFreeSpanGroup (&spanData->bgGroup);
	if (pixel.val != oldPixel.val)
    	{
	    ChangeGC (NullClient, pGC, GCForeground, &oldPixel);
	    ValidateGC (pDrawable, pGC);
    	}
d1379 2
a1380 2
    miFillUniqueSpanGroup (pDrawable, pGC, &spanData->fgGroup);
    miFreeSpanGroup (&spanData->fgGroup);
d1384 2
a1385 2
miWideLine (DrawablePtr pDrawable, GCPtr pGC,
	    int mode, int npt, DDXPointPtr pPts)
d1387 10
a1396 10
 int x1, y1, x2, y2;
    SpanDataRec	spanDataRec;
    SpanDataPtr	spanData;
    long   	pixel;
    Bool	projectLeft, projectRight;
    LineFaceRec	leftFace, rightFace, prevRightFace;
    LineFaceRec	firstFace;
    int		first;
    Bool	somethingDrawn = FALSE;
    Bool	selfJoin;
d1398 1
a1398 1
    spanData = miSetupSpanData (pGC, &spanDataRec, npt);
d1404 20
a1423 24
    if (npt > 1)
    {
    	if (mode == CoordModePrevious)
    	{
	    int nptTmp;
	    DDXPointPtr pPtsTmp;
    
	    x1 = x2;
	    y1 = y2;
	    nptTmp = npt;
	    pPtsTmp = pPts + 1;
	    while (--nptTmp)
	    {
	    	x1 += pPtsTmp->x;
	    	y1 += pPtsTmp->y;
	    	++pPtsTmp;
	    }
	    if (x2 == x1 && y2 == y1)
	    	selfJoin = TRUE;
    	}
    	else if (x2 == pPts[npt-1].x && y2 == pPts[npt-1].y)
    	{
	    selfJoin = TRUE;
    	}
d1427 49
a1475 59
    while (--npt)
    {
	x1 = x2;
	y1 = y2;
	++pPts;
	x2 = pPts->x;
	y2 = pPts->y;
	if (mode == CoordModePrevious)
	{
	    x2 += x1;
	    y2 += y1;
	}
	if (x1 != x2 || y1 != y2)
	{
	    somethingDrawn = TRUE;
	    if (npt == 1 && pGC->capStyle == CapProjecting && !selfJoin)
	    	projectRight = TRUE;
	    miWideSegment (pDrawable, pGC, pixel, spanData, x1, y1, x2, y2,
		       	   projectLeft, projectRight, &leftFace, &rightFace);
	    if (first)
	    {
	    	if (selfJoin)
		    firstFace = leftFace;
	    	else if (pGC->capStyle == CapRound)
		{
		    if (pGC->lineWidth == 1 && !spanData)
			miLineOnePoint (pDrawable, pGC, pixel, spanData, x1, y1);
		    else
		    	miLineArc (pDrawable, pGC, pixel, spanData,
			       	   &leftFace, (LineFacePtr) NULL,
 			       	   (double)0.0, (double)0.0,
			       	   TRUE);
		}
	    }
	    else
	    {
	    	miLineJoin (pDrawable, pGC, pixel, spanData, &leftFace,
		            &prevRightFace);
	    }
	    prevRightFace = rightFace;
	    first = FALSE;
	    projectLeft = FALSE;
	}
	if (npt == 1 && somethingDrawn)
 	{
	    if (selfJoin)
		miLineJoin (pDrawable, pGC, pixel, spanData, &firstFace,
			    &rightFace);
	    else if (pGC->capStyle == CapRound)
	    {
		if (pGC->lineWidth == 1 && !spanData)
		    miLineOnePoint (pDrawable, pGC, pixel, spanData, x2, y2);
		else
		    miLineArc (pDrawable, pGC, pixel, spanData,
			       (LineFacePtr) NULL, &rightFace,
			       (double)0.0, (double)0.0,
			       TRUE);
	    }
	}
d1478 14
a1491 18
    if (!somethingDrawn)
    {
	projectLeft = pGC->capStyle == CapProjecting;
	miWideSegment (pDrawable, pGC, pixel, spanData,
		       x2, y2, x2, y2, projectLeft, projectLeft,
		       &leftFace, &rightFace);
	if (pGC->capStyle == CapRound)
	{
	    miLineArc (pDrawable, pGC, pixel, spanData,
		       &leftFace, (LineFacePtr) NULL,
		       (double)0.0, (double)0.0,
		       TRUE);
	    rightFace.dx = -1;	/* sleezy hack to make it work */
	    miLineArc (pDrawable, pGC, pixel, spanData,
		       (LineFacePtr) NULL, &rightFace,
 		       (double)0.0, (double)0.0,
		       TRUE);
	}
d1494 1
a1494 1
	miCleanupSpanData (pDrawable, pGC, spanData);
d1503 36
a1538 38
miWideDashSegment (
    DrawablePtr	    pDrawable,
    GCPtr  	    pGC,
    SpanDataPtr	    spanData,
    int		    *pDashOffset,
    int		    *pDashIndex,
    int		    x1,
    int		    y1,
    int		    x2,
    int		    y2,
    Bool	    projectLeft,
    Bool	    projectRight,
    LineFacePtr	    leftFace,
    LineFacePtr	    rightFace)
{
    int		    dashIndex, dashRemain;
    unsigned char   *pDash;
    double	    L, l;
    double	    k;
    PolyVertexRec   vertices[4];
    PolyVertexRec   saveRight, saveBottom;
    PolySlopeRec    slopes[4];
    PolyEdgeRec	    left[2], right[2];
    LineFaceRec	    lcapFace, rcapFace;
    int		    nleft, nright;
    int		    h;
    int		    y;
    int		    dy, dx;
    unsigned long   pixel;
    double	    LRemain;
    double	    r;
    double	    rdx, rdy;
    double	    dashDx, dashDy;
    double	    saveK = 0.0;
    Bool	    first = TRUE;
    double	    lcenterx, lcentery, rcenterx = 0.0, rcentery = 0.0;
    unsigned long   fgPixel, bgPixel;
    
d1546 2
a1547 4
    if (pGC->fillStyle == FillOpaqueStippled ||
	pGC->fillStyle == FillTiled)
    {
	bgPixel = fgPixel;
d1551 21
a1571 26
    if (dx == 0)
    {
	L = dy;
	rdx = 0;
	rdy = l;
	if (dy < 0)
	{
	    L = -dy;
	    rdy = -l;
	}
    }
    else if (dy == 0)
    {
	L = dx;
	rdx = l;
	rdy = 0;
	if (dx < 0)
	{
	    L = -dx;
	    rdx = -l;
	}
    }
    else
    {
	L = hypot ((double) dx, (double) dy);
	r = l / L;
d1573 2
a1574 2
	rdx = r * dx;
	rdy = r * dy;
d1604 3
a1606 4
    if (projectLeft)
    {
	vertices[V_TOP].x -= rdx;
	vertices[V_TOP].y -= rdy;
d1608 2
a1609 2
	vertices[V_LEFT].x -= rdx;
	vertices[V_LEFT].y -= rdy;
d1611 1
a1611 1
	slopes[V_LEFT].k = rdx * dx + rdy * dy;
d1617 177
a1793 202
    if (pGC->capStyle == CapRound)
    {
	lcapFace.dx = dx;
	lcapFace.dy = dy;
	lcapFace.x = x1;
	lcapFace.y = y1;

	rcapFace.dx = -dx;
	rcapFace.dy = -dy;
	rcapFace.x = x1;
	rcapFace.y = y1;
    }
    while (LRemain > dashRemain)
    {
	dashDx = (dashRemain * dx) / L;
	dashDy = (dashRemain * dy) / L;

	rcenterx = lcenterx + dashDx;
	rcentery = lcentery + dashDy;

	vertices[V_RIGHT].x += dashDx;
	vertices[V_RIGHT].y += dashDy;

	vertices[V_BOTTOM].x += dashDx;
	vertices[V_BOTTOM].y += dashDy;

	slopes[V_RIGHT].k = vertices[V_RIGHT].x * dx + vertices[V_RIGHT].y * dy;

	if (pGC->lineStyle == LineDoubleDash || !(dashIndex & 1))
	{
	    if (pGC->lineStyle == LineOnOffDash &&
 	        pGC->capStyle == CapProjecting)
	    {
		saveRight = vertices[V_RIGHT];
		saveBottom = vertices[V_BOTTOM];
		saveK = slopes[V_RIGHT].k;
		
		if (!first)
		{
		    vertices[V_TOP].x -= rdx;
		    vertices[V_TOP].y -= rdy;
    
		    vertices[V_LEFT].x -= rdx;
		    vertices[V_LEFT].y -= rdy;

		    slopes[V_LEFT].k = vertices[V_LEFT].x *
				       slopes[V_LEFT].dy -
				       vertices[V_LEFT].y *
				       slopes[V_LEFT].dx;
		}
		
		vertices[V_RIGHT].x += rdx;
		vertices[V_RIGHT].y += rdy;

		vertices[V_BOTTOM].x += rdx;
		vertices[V_BOTTOM].y += rdy;

		slopes[V_RIGHT].k = vertices[V_RIGHT].x *
				   slopes[V_RIGHT].dy -
				   vertices[V_RIGHT].y *
				   slopes[V_RIGHT].dx;
	    }
	    y = miPolyBuildPoly (vertices, slopes, 4, x1, y1,
			     	 left, right, &nleft, &nright, &h);
	    pixel = (dashIndex & 1) ? bgPixel : fgPixel;
	    miFillPolyHelper (pDrawable, pGC, pixel, spanData, y, h, left, right, nleft, nright);

	    if (pGC->lineStyle == LineOnOffDash)
	    {
		switch (pGC->capStyle)
		{
		case CapProjecting:
		    vertices[V_BOTTOM] = saveBottom;
		    vertices[V_RIGHT] = saveRight;
		    slopes[V_RIGHT].k = saveK;
		    break;
		case CapRound:
		    if (!first)
		    {
		    	if (dx < 0)
		    	{
		    	    lcapFace.xa = -vertices[V_LEFT].x;
		    	    lcapFace.ya = -vertices[V_LEFT].y;
			    lcapFace.k = slopes[V_LEFT].k;
		    	}
		    	else
		    	{
		    	    lcapFace.xa = vertices[V_TOP].x;
		    	    lcapFace.ya = vertices[V_TOP].y;
			    lcapFace.k = -slopes[V_LEFT].k;
		    	}
		    	miLineArc (pDrawable, pGC, pixel, spanData,
			       	   &lcapFace, (LineFacePtr) NULL,
			       	   lcenterx, lcentery, FALSE);
		    }
		    if (dx < 0)
		    {
		    	rcapFace.xa = vertices[V_BOTTOM].x;
		    	rcapFace.ya = vertices[V_BOTTOM].y;
			rcapFace.k = slopes[V_RIGHT].k;
		    }
		    else
		    {
		    	rcapFace.xa = -vertices[V_RIGHT].x;
		    	rcapFace.ya = -vertices[V_RIGHT].y;
			rcapFace.k = -slopes[V_RIGHT].k;
		    }
		    miLineArc (pDrawable, pGC, pixel, spanData,
			       (LineFacePtr) NULL, &rcapFace,
			       rcenterx, rcentery, FALSE);
		    break;
	    	}
	    }
	}
	LRemain -= dashRemain;
	++dashIndex;
	if (dashIndex == pGC->numInDashList)
	    dashIndex = 0;
	dashRemain = pDash[dashIndex];

	lcenterx = rcenterx;
	lcentery = rcentery;

	vertices[V_TOP] = vertices[V_RIGHT];
	vertices[V_LEFT] = vertices[V_BOTTOM];
	slopes[V_LEFT].k = -slopes[V_RIGHT].k;
	first = FALSE;
    }

    if (pGC->lineStyle == LineDoubleDash || !(dashIndex & 1))
    {
    	vertices[V_TOP].x -= dx;
    	vertices[V_TOP].y -= dy;

	vertices[V_LEFT].x -= dx;
	vertices[V_LEFT].y -= dy;

	vertices[V_RIGHT].x = rdy;
	vertices[V_RIGHT].y = -rdx;

	vertices[V_BOTTOM].x = -rdy;
	vertices[V_BOTTOM].y = rdx;

	
	if (projectRight)
	{
	    vertices[V_RIGHT].x += rdx;
	    vertices[V_RIGHT].y += rdy;
    
	    vertices[V_BOTTOM].x += rdx;
	    vertices[V_BOTTOM].y += rdy;
	    slopes[V_RIGHT].k = vertices[V_RIGHT].x *
				slopes[V_RIGHT].dy -
				vertices[V_RIGHT].y *
				slopes[V_RIGHT].dx;
	}
	else
	    slopes[V_RIGHT].k = 0;

	if (!first && pGC->lineStyle == LineOnOffDash &&
	    pGC->capStyle == CapProjecting)
	{
	    vertices[V_TOP].x -= rdx;
	    vertices[V_TOP].y -= rdy;

	    vertices[V_LEFT].x -= rdx;
	    vertices[V_LEFT].y -= rdy;
	    slopes[V_LEFT].k = vertices[V_LEFT].x *
			       slopes[V_LEFT].dy -
			       vertices[V_LEFT].y *
			       slopes[V_LEFT].dx;
	}
	else
	    slopes[V_LEFT].k += dx * dx + dy * dy;


	y = miPolyBuildPoly (vertices, slopes, 4, x2, y2,
			     left, right, &nleft, &nright, &h);

	pixel = (dashIndex & 1) ? pGC->bgPixel : pGC->fgPixel;
	miFillPolyHelper (pDrawable, pGC, pixel, spanData, y, h, left, right, nleft, nright);
	if (!first && pGC->lineStyle == LineOnOffDash &&
	    pGC->capStyle == CapRound)
	{
	    lcapFace.x = x2;
	    lcapFace.y = y2;
	    if (dx < 0)
	    {
		lcapFace.xa = -vertices[V_LEFT].x;
		lcapFace.ya = -vertices[V_LEFT].y;
		lcapFace.k = slopes[V_LEFT].k;
	    }
	    else
	    {
		lcapFace.xa = vertices[V_TOP].x;
		lcapFace.ya = vertices[V_TOP].y;
		lcapFace.k = -slopes[V_LEFT].k;
	    }
	    miLineArc (pDrawable, pGC, pixel, spanData,
		       &lcapFace, (LineFacePtr) NULL,
		       rcenterx, rcentery, FALSE);
	}
d1796 5
a1800 6
    if (dashRemain == 0)
    {
	dashIndex++;
	if (dashIndex == pGC->numInDashList)
	    dashIndex = 0;
	dashRemain = pDash[dashIndex];
d1824 2
a1825 2
miWideDash (DrawablePtr pDrawable, GCPtr pGC,
	    int mode, int npt, DDXPointPtr pPts)
d1827 14
a1840 14
    int			x1, y1, x2, y2;
    unsigned long	pixel;
    Bool		projectLeft, projectRight;
    LineFaceRec		leftFace, rightFace, prevRightFace;
    LineFaceRec		firstFace;
    int			first;
    int			dashIndex, dashOffset;
    int			prevDashIndex;
    SpanDataRec		spanDataRec;
    SpanDataPtr		spanData;
    Bool		somethingDrawn = FALSE;
    Bool		selfJoin;
    Bool		endIsFg = FALSE, startIsFg = FALSE;
    Bool		firstIsFg = FALSE, prevIsFg = FALSE;
d1844 3
a1846 4
    if (pGC->lineWidth == 0)
    {
	miZeroDashLine (pDrawable, pGC, mode, npt, pPts);
	return;
d1849 4
a1852 5
    if (pGC->lineStyle == LineDoubleDash && 
	(pGC->fillStyle == FillOpaqueStippled || pGC->fillStyle == FillTiled))
    {
	miWideLine (pDrawable, pGC, mode, npt, pPts);
	return;
d1855 2
a1856 2
	return;
    spanData = miSetupSpanData (pGC, &spanDataRec, npt);
d1861 15
a1875 17
    if (mode == CoordModePrevious)
    {
	int nptTmp;
	DDXPointPtr pPtsTmp;

	x1 = x2;
	y1 = y2;
	nptTmp = npt;
	pPtsTmp = pPts + 1;
	while (--nptTmp)
	{
	    x1 += pPtsTmp->x;
	    y1 += pPtsTmp->y;
	    ++pPtsTmp;
	}
	if (x2 == x1 && y2 == y1)
	    selfJoin = TRUE;
d1877 2
a1878 3
    else if (x2 == pPts[npt-1].x && y2 == pPts[npt-1].y)
    {
	selfJoin = TRUE;
d1884 76
a1959 89
    miStepDash ((int)pGC->dashOffset, &dashIndex,
	        pGC->dash, (int)pGC->numInDashList, &dashOffset);
    while (--npt)
    {
	x1 = x2;
	y1 = y2;
	++pPts;
	x2 = pPts->x;
	y2 = pPts->y;
	if (mode == CoordModePrevious)
	{
	    x2 += x1;
	    y2 += y1;
	}
	if (x1 != x2 || y1 != y2)
	{
	    somethingDrawn = TRUE;
	    if (npt == 1 && pGC->capStyle == CapProjecting && 
		(!selfJoin || !firstIsFg))
		projectRight = TRUE;
	    prevDashIndex = dashIndex;
	    miWideDashSegment (pDrawable, pGC, spanData, &dashOffset, &dashIndex,
				x1, y1, x2, y2,
				projectLeft, projectRight, &leftFace, &rightFace);
	    startIsFg = !(prevDashIndex & 1);
	    endIsFg = (dashIndex & 1) ^ (dashOffset != 0);
	    if (pGC->lineStyle == LineDoubleDash || startIsFg)
	    {
	    	pixel = startIsFg ? pGC->fgPixel : pGC->bgPixel;
	    	if (first || (pGC->lineStyle == LineOnOffDash && !prevIsFg))
	    	{
	    	    if (first && selfJoin)
		    {
		    	firstFace = leftFace;
			firstIsFg = startIsFg;
		    }
	    	    else if (pGC->capStyle == CapRound)
		    	miLineArc (pDrawable, pGC, pixel, spanData,
			       	   &leftFace, (LineFacePtr) NULL,
			       	   (double)0.0, (double)0.0, TRUE);
	    	}
	    	else
	    	{
	    	    miLineJoin (pDrawable, pGC, pixel, spanData, &leftFace,
		            	&prevRightFace);
	    	}
	    }
	    prevRightFace = rightFace;
	    prevIsFg = endIsFg;
	    first = FALSE;
	    projectLeft = FALSE;
	}
	if (npt == 1 && somethingDrawn)
	{
	    if (pGC->lineStyle == LineDoubleDash || endIsFg)
	    {
		pixel = endIsFg ? pGC->fgPixel : pGC->bgPixel;
		if (selfJoin && (pGC->lineStyle == LineDoubleDash || firstIsFg))
		{
		    miLineJoin (pDrawable, pGC, pixel, spanData, &firstFace,
				&rightFace);
		}
		else 
		{
		    if (pGC->capStyle == CapRound)
			miLineArc (pDrawable, pGC, pixel, spanData,
				    (LineFacePtr) NULL, &rightFace,
				    (double)0.0, (double)0.0, TRUE);
		}
	    }
	    else
	    {
		/* glue a cap to the start of the line if
		 * we're OnOffDash and ended on odd dash
		 */
		if (selfJoin && firstIsFg)
		{
		    pixel = pGC->fgPixel;
		    if (pGC->capStyle == CapProjecting)
			miLineProjectingCap (pDrawable, pGC, pixel, spanData,
				    &firstFace, TRUE,
				    (double)0.0, (double)0.0, TRUE);
		    else if (pGC->capStyle == CapRound)
			miLineArc (pDrawable, pGC, pixel, spanData,
				    &firstFace, (LineFacePtr) NULL,
				    (double)0.0, (double)0.0, TRUE);
		}
	    }
	}
d1962 16
a1977 17
    if (!somethingDrawn && (pGC->lineStyle == LineDoubleDash || !(dashIndex & 1)))
    {
	/* not the same as endIsFg computation above */
	pixel = (dashIndex & 1) ? pGC->bgPixel : pGC->fgPixel;
	switch (pGC->capStyle) {
	case CapRound:
	    miLineArc (pDrawable, pGC, pixel, spanData,
		       (LineFacePtr) NULL, (LineFacePtr) NULL,
		       (double)x2, (double)y2,
		       FALSE);
	    break;
	case CapProjecting:
	    x1 = pGC->lineWidth;
	    miFillRectPolyHelper (pDrawable, pGC, pixel, spanData,
				  x2 - (x1 >> 1), y2 - (x1 >> 1), x1, x1);
	    break;
	}
d1980 1
a1980 1
	miCleanupSpanData (pDrawable, pGC, spanData);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d406 1
a406 1
    if (slopes[j].dy * slopes[i].dx > slopes[i].dy * slopes[j].dx)
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d55 42
d109 26
a153 1
    DDXPointPtr pptInit = NULL;
a154 2
    int 	*pwidthInit = NULL;
    XID		oldPixel;
d158 4
a161 38
    left_height = 0;
    right_height = 0;
    
    if (!spanData)
    {
    	pptInit = xalloc (overall_height * sizeof(*ppt));
    	if (!pptInit)
	    return;
    	pwidthInit = xalloc (overall_height * sizeof(*pwidth));
    	if (!pwidthInit)
    	{
	    xfree (pptInit);
	    return;
    	}
	ppt = pptInit;
	pwidth = pwidthInit;
    	oldPixel = pGC->fgPixel;
    	if (pixel != oldPixel)
    	{
	    XID tmpPixel = (XID)pixel;
    	    DoChangeGC (pGC, GCForeground, &tmpPixel, FALSE);
    	    ValidateGC (pDrawable, pGC);
    	}
    }
    else
    {
	spanRec.points = xalloc (overall_height * sizeof (*ppt));
	if (!spanRec.points)
	    return;
	spanRec.widths = xalloc (overall_height * sizeof (int));
	if (!spanRec.widths)
	{
	    xfree (spanRec.points);
	    return;
	}
	ppt = spanRec.points;
	pwidth = spanRec.widths;
    }
d172 25
a196 2
	MIPOLYRELOADLEFT
	MIPOLYRELOADRIGHT
d214 1
a214 3
    	    y++;
    	
	    MIPOLYSTEPLEFT
d216 15
a230 1
	    MIPOLYSTEPRIGHT
d233 2
a234 16
    if (!spanData)
    {
    	(*pGC->ops->FillSpans) (pDrawable, pGC, ppt - pptInit, pptInit, pwidthInit, TRUE);
    	xfree (pwidthInit);
    	xfree (pptInit);
    	if (pixel != oldPixel)
    	{
	    DoChangeGC (pGC, GCForeground, &oldPixel, FALSE);
	    ValidateGC (pDrawable, pGC);
    	}
    }
    else
    {
	spanRec.count = ppt - spanRec.points;
	AppendSpanGroup (pGC, pixel, &spanRec, spanData)
    }
d250 1
a250 1
    XID		oldPixel;
d260 2
a261 2
    	oldPixel = pGC->fgPixel;
    	if (pixel != oldPixel)
d263 2
a264 2
	    XID tmpPixel = (XID)pixel;
    	    DoChangeGC (pGC, GCForeground, &tmpPixel, FALSE);
d268 1
a268 1
    	if (pixel != oldPixel)
d270 1
a270 1
	    DoChangeGC (pGC, GCForeground, &oldPixel, FALSE);
d276 1
a276 7
	spanRec.points = xalloc (h * sizeof (*ppt));
	if (!spanRec.points)
	    return;
	spanRec.widths = xalloc (h * sizeof (int));
	if (!spanRec.widths)
	{
	    xfree (spanRec.points);
a277 1
	}
d295 1
a295 1
	AppendSpanGroup (pGC, pixel, &spanRec, spanData)
d720 1
a720 1
    return (pGC->lineWidth);
d914 1
a914 1
    return (pts - points);
a1043 2
    DDXPointPtr points;
    int *widths;
a1044 1
    XID		oldPixel;
d1088 2
a1089 33
    if (!spanData)
    {
    	points = xalloc(sizeof(DDXPointRec) * pGC->lineWidth);
    	if (!points)
	    return;
    	widths = xalloc(sizeof(int) * pGC->lineWidth);
    	if (!widths)
    	{
	    xfree(points);
	    return;
    	}
    	oldPixel = pGC->fgPixel;
    	if (pixel != oldPixel)
    	{
	    XID tmpPixel = (XID)pixel;
	    DoChangeGC(pGC, GCForeground, &tmpPixel, FALSE);
	    ValidateGC (pDraw, pGC);
    	}
    }
    else
    {
	points = xalloc (pGC->lineWidth * sizeof (DDXPointRec));
	if (!points)
	    return;
	widths = xalloc (pGC->lineWidth * sizeof (int));
	if (!widths)
	{
	    xfree (points);
	    return;
	}
	spanRec.points = points;
	spanRec.widths = widths;
    }
d1091 1
a1091 1
	n = miLineArcI(pDraw, pGC, xorgi, yorgi, points, widths);
d1093 1
a1093 1
	n = miLineArcD(pDraw, pGC, xorg, yorg, points, widths,
d1096 2
a1097 17

    if (!spanData)
    {
    	(*pGC->ops->FillSpans)(pDraw, pGC, n, points, widths, TRUE);
    	xfree(widths);
    	xfree(points);
    	if (pixel != oldPixel)
    	{
	    DoChangeGC(pGC, GCForeground, &oldPixel, FALSE);
	    ValidateGC (pDraw, pGC);
    	}
    }
    else
    {
	spanRec.count = n;
	AppendSpanGroup (pGC, pixel, &spanRec, spanData)
    }
d1502 4
a1505 5
	XID oldPixel, pixel;
	
	pixel = pGC->bgPixel;
	oldPixel = pGC->fgPixel;
    	if (pixel != oldPixel)
d1507 1
a1507 1
    	    DoChangeGC (pGC, GCForeground, &pixel, FALSE);
d1512 1
a1512 1
    	if (pixel != oldPixel)
d1514 1
a1514 1
	    DoChangeGC (pGC, GCForeground, &oldPixel, FALSE);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d98 1
a98 1
    	pptInit = (DDXPointPtr) xalloc (overall_height * sizeof(*ppt));
d101 1
a101 1
    	pwidthInit = (int *) xalloc (overall_height * sizeof(*pwidth));
d119 1
a119 1
	spanRec.points = (DDXPointPtr) xalloc (overall_height * sizeof (*ppt));
d122 1
a122 1
	spanRec.widths = (int *) xalloc (overall_height * sizeof (int));
d224 1
a224 1
	spanRec.points = (DDXPointPtr) xalloc (h * sizeof (*ppt));
d227 1
a227 1
	spanRec.widths = (int *) xalloc (h * sizeof (int));
d254 1
a254 1
_X_EXPORT /* static */ int
d316 1
a316 1
_X_EXPORT /* static */ int
d918 1
a918 1
_X_EXPORT void
d941 1
a941 1
_X_EXPORT int
d1048 1
a1048 1
    	points = (DDXPointPtr)xalloc(sizeof(DDXPointRec) * pGC->lineWidth);
d1051 1
a1051 1
    	widths = (int *)xalloc(sizeof(int) * pGC->lineWidth);
d1067 1
a1067 1
	points = (DDXPointPtr) xalloc (pGC->lineWidth * sizeof (DDXPointRec));
d1070 1
a1070 1
	widths = (int *) xalloc (pGC->lineWidth * sizeof (int));
d1527 1
a1527 1
_X_EXPORT void
d2021 1
a2021 1
_X_EXPORT void
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d255 10
a264 7
miPolyBuildEdge (x0, y0, k, dx, dy, xi, yi, left, edge)
    double	x0, y0;
    double	k;  /* x0 * dy - y0 * dx */
    int 	dx, dy;
    int		xi, yi;
    int		left;
    PolyEdgePtr edge;
d317 11
a327 8
miPolyBuildPoly (vertices, slopes, count, xi, yi, left, right, pnleft, pnright, h)
    PolyVertexPtr 	vertices;
    PolySlopePtr	slopes;
    int			count;
    int		   	xi, yi;
    PolyEdgePtr	    	left, right;
    int		    	*pnleft, *pnright;
    int		    	*h;
d919 3
a921 5
miRoundJoinClip (pLeft, pRight, edge1, edge2, y1, y2, left1, left2)
    LineFacePtr pLeft, pRight;
    PolyEdgePtr	edge1, edge2;
    int		*y1, *y2;
    Bool	*left1, *left2;
d942 1
a942 5
miRoundCapClip (face, isInt, edge, leftEdge)
    LineFacePtr face;
    Bool	isInt;
    PolyEdgePtr edge;
    Bool	*leftEdge;
d1528 2
a1529 6
miWideLine (pDrawable, pGC, mode, npt, pPts)
    DrawablePtr	pDrawable;
    GCPtr 	pGC;
    int		mode;
    int 	npt;
    DDXPointPtr pPts;
d1531 1
a1531 1
    int		x1, y1, x2, y2;
d2022 2
a2023 6
miWideDash (pDrawable, pGC, mode, npt, pPts)
    DrawablePtr	pDrawable;
    GCPtr 	pGC;
    int		mode;
    int 	npt;
    DDXPointPtr pPts;
@


1.1
log
@Initial revision
@
text
@d55 1
a55 5
#ifdef ICEILTEMPDECL
ICEILTEMPDECL
#endif

static void miLineArc(DrawablePtr pDraw, register GCPtr pGC,
d57 2
a58 2
		      register LineFacePtr leftFace,
		      register LineFacePtr rightFace,
d66 5
a70 11
void
miFillPolyHelper (pDrawable, pGC, pixel, spanData, y, overall_height,
		  left, right, left_count, right_count)
    DrawablePtr	pDrawable;
    GCPtr	pGC;
    unsigned long   pixel;
    SpanDataPtr	spanData;
    int		y;			/* start y coordinate */
    int		overall_height;		/* height of entire segment */
    PolyEdgePtr	left, right;
    int		left_count, right_count;
d72 1
a72 1
    register int left_x = 0, left_e = 0;
d77 1
a77 1
    register int right_x = 0, right_e = 0;
d85 1
a85 1
    register DDXPointPtr ppt;
d87 2
a88 2
    register int *pwidth;
    int *pwidthInit = NULL;
d98 1
a98 1
    	pptInit = (DDXPointPtr) ALLOCATE_LOCAL (overall_height * sizeof(*ppt));
d101 1
a101 1
    	pwidthInit = (int *) ALLOCATE_LOCAL (overall_height * sizeof(*pwidth));
d104 1
a104 1
	    DEALLOCATE_LOCAL (pptInit);
d170 2
a171 2
    	DEALLOCATE_LOCAL (pwidthInit);
    	DEALLOCATE_LOCAL (pptInit);
d196 2
a197 2
    register DDXPointPtr ppt;
    register int *pwidth;
d258 1
a258 1
    register int dx, dy;
d261 1
a261 1
    register PolyEdgePtr edge;
d315 7
a321 7
    register PolyVertexPtr vertices;
    register PolySlopePtr  slopes;
    int		    count;
    int		    xi, yi;
    PolyEdgePtr	    left, right;
    int		    *pnleft, *pnright;
    int		    *h;
d323 9
a331 9
    int	    top, bottom;
    double  miny, maxy;
    register int i;
    int	    j;
    int	    clockwise;
    int	    slopeoff;
    register int s;
    register int nright, nleft;
    int	    y, lasty = 0, bottomy, topy = 0;
d460 6
a465 6
    DrawablePtr	    pDrawable,
    GCPtr	    pGC,
    unsigned long   pixel,
    SpanDataPtr	    spanData,
    register LineFacePtr pLeft,
    register LineFacePtr pRight)
d617 3
a619 3
    register DDXPointPtr tpts, bpts;
    register int *twids, *bwids;
    register int x, y, e, ex, slw;
d710 2
a711 2
    register DDXPointPtr pts;
    register int *wids;
d866 2
a867 5
int
miRoundJoinFace (face, edge, leftEdge)
    register LineFacePtr face;
    register PolyEdgePtr edge;
    Bool	*leftEdge;
d914 1
a914 1
    register LineFacePtr pLeft, pRight;
d939 1
a939 1
    register LineFacePtr face;
d941 1
a941 1
    register PolyEdgePtr edge;
d944 3
a946 3
    int	    y;
    register int dx, dy;
    double  xa, ya, k;
d989 9
a997 9
    DrawablePtr	    pDraw,
    register GCPtr  pGC,
    unsigned long   pixel,
    SpanDataPtr	    spanData,
    register LineFacePtr leftFace,
    register LineFacePtr rightFace,
    double	    xorg,
    double          yorg,
    Bool	    isInt)
d1048 1
a1048 1
    	points = (DDXPointPtr)ALLOCATE_LOCAL(sizeof(DDXPointRec) * pGC->lineWidth);
d1051 1
a1051 1
    	widths = (int *)ALLOCATE_LOCAL(sizeof(int) * pGC->lineWidth);
d1054 1
a1054 1
	    DEALLOCATE_LOCAL(points);
d1089 2
a1090 2
    	DEALLOCATE_LOCAL(widths);
    	DEALLOCATE_LOCAL(points);
d1104 4
a1107 10
void
miLineProjectingCap (pDrawable, pGC, pixel, spanData, face, isLeft, xorg, yorg, isInt)
    DrawablePtr	    pDrawable;
    register GCPtr  pGC;
    unsigned long   pixel;
    SpanDataPtr	    spanData;
    register LineFacePtr face;
    Bool	    isLeft;
    double	    xorg, yorg;
    Bool	    isInt;
d1270 12
a1281 12
    DrawablePtr	    pDrawable,
    GCPtr	    pGC,
    unsigned long   pixel,
    SpanDataPtr	    spanData,
    register int    x1,
    register int    y1,
    register int    x2,
    register int    y2,
    Bool	    projectLeft,
    Bool	    projectRight,
    register LineFacePtr leftFace,
    register LineFacePtr rightFace)
d1490 2
a1491 5
SpanDataPtr
miSetupSpanData (pGC, spanData, npt)
    register GCPtr pGC;
    SpanDataPtr	spanData;
    int		npt;
d1501 2
a1502 5
void
miCleanupSpanData (pDrawable, pGC, spanData)
    DrawablePtr	pDrawable;
    GCPtr	pGC;
    SpanDataPtr	spanData;
d1530 1
a1530 1
    register GCPtr pGC;
d1532 2
a1533 2
    register int npt;
    register DDXPointPtr pPts;
d1535 10
a1544 10
    int		    x1, y1, x2, y2;
    SpanDataRec	    spanDataRec;
    SpanDataPtr	    spanData;
    unsigned long   pixel;
    Bool	    projectLeft, projectRight;
    LineFaceRec	    leftFace, rightFace, prevRightFace;
    LineFaceRec	    firstFace;
    register int    first;
    Bool	    somethingDrawn = FALSE;
    Bool	    selfJoin;
d1671 1
a1671 1
    register GCPtr  pGC,
d2028 1
a2028 1
    register GCPtr pGC;
d2030 2
a2031 2
    register int npt;
    register DDXPointPtr pPts;
d2033 14
a2046 14
    int		    x1, y1, x2, y2;
    unsigned long   pixel;
    Bool	    projectLeft, projectRight;
    LineFaceRec	    leftFace, rightFace, prevRightFace;
    LineFaceRec	    firstFace;
    int		    first;
    int		    dashIndex, dashOffset;
    register int    prevDashIndex;
    SpanDataRec	    spanDataRec;
    SpanDataPtr	    spanData;
    Bool	    somethingDrawn = FALSE;
    Bool	    selfJoin;
    Bool	    endIsFg = FALSE, startIsFg = FALSE;
    Bool            firstIsFg = FALSE, prevIsFg = FALSE;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d55 5
a59 1
static void miLineArc(DrawablePtr pDraw, GCPtr pGC,
d61 2
a62 2
		      LineFacePtr leftFace,
		      LineFacePtr rightFace,
d70 11
a80 5
static void
miFillPolyHelper (DrawablePtr pDrawable, GCPtr pGC, unsigned long pixel,
		  SpanDataPtr spanData, int y, int overall_height,
		  PolyEdgePtr left, PolyEdgePtr right,
		  int left_count, int right_count)
d82 1
a82 1
    int left_x = 0, left_e = 0;
d87 1
a87 1
    int right_x = 0, right_e = 0;
d95 1
a95 1
    DDXPointPtr ppt;
d97 2
a98 2
    int 	*pwidth;
    int 	*pwidthInit = NULL;
d206 2
a207 2
    DDXPointPtr ppt;
    int 	*pwidth;
d268 1
a268 1
    int 	dx, dy;
d271 1
a271 1
    PolyEdgePtr edge;
d325 7
a331 7
    PolyVertexPtr 	vertices;
    PolySlopePtr	slopes;
    int			count;
    int		   	xi, yi;
    PolyEdgePtr	    	left, right;
    int		    	*pnleft, *pnright;
    int		    	*h;
d333 9
a341 9
    int 	top, bottom;
    double 	miny, maxy;
    int 	i;
    int		j;
    int		clockwise;
    int		slopeoff;
    int 	s;
    int 	nright, nleft;
    int	   	y, lasty = 0, bottomy, topy = 0;
d470 6
a475 6
    DrawablePtr 	pDrawable,
    GCPtr		pGC,
    unsigned long	pixel,
    SpanDataPtr		spanData,
    LineFacePtr		pLeft,
    LineFacePtr 	pRight)
d627 3
a629 3
    DDXPointPtr tpts, bpts;
    int *twids, *bwids;
    int x, y, e, ex, slw;
d720 2
a721 2
    DDXPointPtr pts;
    int *wids;
d876 5
a880 2
static int
miRoundJoinFace (LineFacePtr face, PolyEdgePtr edge, Bool *leftEdge)
d927 1
a927 1
    LineFacePtr pLeft, pRight;
d952 1
a952 1
    LineFacePtr face;
d954 1
a954 1
    PolyEdgePtr edge;
d957 3
a959 3
    int		y;
    int 	dx, dy;
    double	xa, ya, k;
d1002 9
a1010 9
    DrawablePtr		pDraw,
    GCPtr  		pGC,
    unsigned long	pixel,
    SpanDataPtr		spanData,
    LineFacePtr		leftFace,
    LineFacePtr 	rightFace,
    double	    	xorg,
    double          	yorg,
    Bool	    	isInt)
d1117 10
a1126 4
static void
miLineProjectingCap (DrawablePtr pDrawable, GCPtr pGC, unsigned long pixel,
		     SpanDataPtr spanData, LineFacePtr face, Bool isLeft,
		     double xorg, double yorg, Bool isInt)
d1289 12
a1300 12
    DrawablePtr		pDrawable,
    GCPtr		pGC,
    unsigned long	pixel,
    SpanDataPtr		spanData,
    int    		x1,
    int    		y1,
    int    		x2,
    int    		y2,
    Bool		projectLeft,
    Bool		projectRight,
    LineFacePtr 	leftFace,
    LineFacePtr 	rightFace)
d1509 5
a1513 2
static SpanDataPtr
miSetupSpanData (GCPtr pGC, SpanDataPtr spanData, int npt)
d1523 5
a1527 2
static void
miCleanupSpanData (DrawablePtr pDrawable, GCPtr pGC, SpanDataPtr spanData)
d1555 1
a1555 1
    GCPtr 	pGC;
d1557 2
a1558 2
    int 	npt;
    DDXPointPtr pPts;
d1560 10
a1569 10
    int		x1, y1, x2, y2;
    SpanDataRec	spanDataRec;
    SpanDataPtr	spanData;
    long   	pixel;
    Bool	projectLeft, projectRight;
    LineFaceRec	leftFace, rightFace, prevRightFace;
    LineFaceRec	firstFace;
    int		first;
    Bool	somethingDrawn = FALSE;
    Bool	selfJoin;
d1696 1
a1696 1
    GCPtr  	    pGC,
d2053 1
a2053 1
    GCPtr 	pGC;
d2055 2
a2056 2
    int 	npt;
    DDXPointPtr pPts;
d2058 14
a2071 14
    int			x1, y1, x2, y2;
    unsigned long	pixel;
    Bool		projectLeft, projectRight;
    LineFaceRec		leftFace, rightFace, prevRightFace;
    LineFaceRec		firstFace;
    int			first;
    int			dashIndex, dashOffset;
    int			prevDashIndex;
    SpanDataRec		spanDataRec;
    SpanDataPtr		spanData;
    Bool		somethingDrawn = FALSE;
    Bool		selfJoin;
    Bool		endIsFg = FALSE, startIsFg = FALSE;
    Bool		firstIsFg = FALSE, prevIsFg = FALSE;
@

