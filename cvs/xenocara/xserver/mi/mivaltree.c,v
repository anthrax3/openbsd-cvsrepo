head	1.7;
access;
symbols
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.14
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.12
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.17;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.17;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 * mivaltree.c --
 *	Functions for recalculating window clip lists. Main function
 *	is miValidateTree.
 *

Copyright 1987, 1988, 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

 *
 * Copyright 1987, 1988, 1989 by
 * Digital Equipment Corporation, Maynard, Massachusetts,
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital not be
 * used in advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 ******************************************************************/

/* The panoramix components contained the following notice */
/*****************************************************************

Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.

******************************************************************/

 /*
  * Aug '86: Susan Angebranndt -- original code
  * July '87: Adam de Boor -- substantially modified and commented
  * Summer '89: Joel McCormack -- so fast you wouldn't believe it possible.
  *             In particular, much improved code for window mapping and
  *             circulating.
  *             Bob Scheifler -- avoid miComputeClips for unmapped windows,
  *                              valdata changes
  */
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "validate.h"
#include    "windowstr.h"
#include    "mi.h"
#include    "regionstr.h"
#include    "mivalidate.h"
#include    "globals.h"
#ifdef COMPOSITE
#include    "compint.h"
#endif

/*
 * Compute the visibility of a shaped window
 */
int
miShapedWindowIn(RegionPtr universe, RegionPtr bounding,
                 BoxPtr rect, int x, int y)
{
    BoxRec box;
    BoxPtr boundBox;
    int nbox;
    Bool someIn, someOut;
    int t, x1, y1, x2, y2;

    nbox = RegionNumRects(bounding);
    boundBox = RegionRects(bounding);
    someIn = someOut = FALSE;
    x1 = rect->x1;
    y1 = rect->y1;
    x2 = rect->x2;
    y2 = rect->y2;
    while (nbox--) {
        if ((t = boundBox->x1 + x) < x1)
            t = x1;
        box.x1 = t;
        if ((t = boundBox->y1 + y) < y1)
            t = y1;
        box.y1 = t;
        if ((t = boundBox->x2 + x) > x2)
            t = x2;
        box.x2 = t;
        if ((t = boundBox->y2 + y) > y2)
            t = y2;
        box.y2 = t;
        if (box.x1 > box.x2)
            box.x2 = box.x1;
        if (box.y1 > box.y2)
            box.y2 = box.y1;
        switch (RegionContainsRect(universe, &box)) {
        case rgnIN:
            if (someOut)
                return rgnPART;
            someIn = TRUE;
            break;
        case rgnOUT:
            if (someIn)
                return rgnPART;
            someOut = TRUE;
            break;
        default:
            return rgnPART;
        }
        boundBox++;
    }
    if (someIn)
        return rgnIN;
    return rgnOUT;
}

/*
 * Manual redirected windows are treated as transparent; they do not obscure
 * siblings or parent windows
 */

#ifdef COMPOSITE
#define TreatAsTransparent(w)	((w)->redirectDraw == RedirectDrawManual)
#else
#define TreatAsTransparent(w)	FALSE
#endif

#define HasParentRelativeBorder(w) (!(w)->borderIsPixel && \
				    HasBorder(w) && \
				    (w)->backgroundState == ParentRelative)

/*
 *-----------------------------------------------------------------------
 * miComputeClips --
 *	Recompute the clipList, borderClip, exposed and borderExposed
 *	regions for pParent and its children. Only viewable windows are
 *	taken into account.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	clipList, borderClip, exposed and borderExposed are altered.
 *	A VisibilityNotify event may be generated on the parent window.
 *
 *-----------------------------------------------------------------------
 */
static void
miComputeClips(WindowPtr pParent,
               ScreenPtr pScreen,
               RegionPtr universe, VTKind kind, RegionPtr exposed)
{                               /* for intermediate calculations */
    int dx, dy;
    RegionRec childUniverse;
    WindowPtr pChild;
    int oldVis, newVis;
    BoxRec borderSize;
    RegionRec childUnion;
    Bool overlap;
    RegionPtr borderVisible;

    /*
     * Figure out the new visibility of this window.
     * The extent of the universe should be the same as the extent of
     * the borderSize region. If the window is unobscured, this rectangle
     * will be completely inside the universe (the universe will cover it
     * completely). If the window is completely obscured, none of the
     * universe will cover the rectangle.
     */
    borderSize.x1 = pParent->drawable.x - wBorderWidth(pParent);
    borderSize.y1 = pParent->drawable.y - wBorderWidth(pParent);
    dx = (int) pParent->drawable.x + (int) pParent->drawable.width +
        wBorderWidth(pParent);
    if (dx > 32767)
        dx = 32767;
    borderSize.x2 = dx;
    dy = (int) pParent->drawable.y + (int) pParent->drawable.height +
        wBorderWidth(pParent);
    if (dy > 32767)
        dy = 32767;
    borderSize.y2 = dy;

#ifdef COMPOSITE
    /*
     * In redirected drawing case, reset universe to borderSize
     */
    if (pParent->redirectDraw != RedirectDrawNone) {
        if (TreatAsTransparent(pParent))
            RegionEmpty(universe);
        compSetRedirectBorderClip (pParent, universe);
        RegionCopy(universe, &pParent->borderSize);
    }
#endif

    oldVis = pParent->visibility;
    switch (RegionContainsRect(universe, &borderSize)) {
    case rgnIN:
        newVis = VisibilityUnobscured;
        break;
    case rgnPART:
        newVis = VisibilityPartiallyObscured;
        {
            RegionPtr pBounding;

            if ((pBounding = wBoundingShape(pParent))) {
                switch (miShapedWindowIn(universe, pBounding,
                                         &borderSize,
                                         pParent->drawable.x,
                                         pParent->drawable.y)) {
                case rgnIN:
                    newVis = VisibilityUnobscured;
                    break;
                case rgnOUT:
                    newVis = VisibilityFullyObscured;
                    break;
                }
            }
        }
        break;
    default:
        newVis = VisibilityFullyObscured;
        break;
    }
    pParent->visibility = newVis;
    if (oldVis != newVis &&
        ((pParent->
          eventMask | wOtherEventMasks(pParent)) & VisibilityChangeMask))
        SendVisibilityNotify(pParent);

    dx = pParent->drawable.x - pParent->valdata->before.oldAbsCorner.x;
    dy = pParent->drawable.y - pParent->valdata->before.oldAbsCorner.y;

    /*
     * avoid computations when dealing with simple operations
     */

    switch (kind) {
    case VTMap:
    case VTStack:
    case VTUnmap:
        break;
    case VTMove:
        if ((oldVis == newVis) &&
            ((oldVis == VisibilityFullyObscured) ||
             (oldVis == VisibilityUnobscured))) {
            pChild = pParent;
            while (1) {
                if (pChild->viewable) {
                    if (pChild->visibility != VisibilityFullyObscured) {
                        RegionTranslate(&pChild->borderClip, dx, dy);
                        RegionTranslate(&pChild->clipList, dx, dy);
                        pChild->drawable.serialNumber = NEXT_SERIAL_NUMBER;
                        if (pScreen->ClipNotify)
                            (*pScreen->ClipNotify) (pChild, dx, dy);

                    }
                    if (pChild->valdata) {
                        RegionNull(&pChild->valdata->after.borderExposed);
                        if (HasParentRelativeBorder(pChild)) {
                            RegionSubtract(&pChild->valdata->after.
                                           borderExposed, &pChild->borderClip,
                                           &pChild->winSize);
                        }
                        RegionNull(&pChild->valdata->after.exposed);
                    }
                    if (pChild->firstChild) {
                        pChild = pChild->firstChild;
                        continue;
                    }
                }
                while (!pChild->nextSib && (pChild != pParent))
                    pChild = pChild->parent;
                if (pChild == pParent)
                    break;
                pChild = pChild->nextSib;
            }
            return;
        }
        /* fall through */
    default:
        /*
         * To calculate exposures correctly, we have to translate the old
         * borderClip and clipList regions to the window's new location so there
         * is a correspondence between pieces of the new and old clipping regions.
         */
        if (dx || dy) {
            /*
             * We translate the old clipList because that will be exposed or copied
             * if gravity is right.
             */
            RegionTranslate(&pParent->borderClip, dx, dy);
            RegionTranslate(&pParent->clipList, dx, dy);
        }
        break;
    case VTBroken:
        RegionEmpty(&pParent->borderClip);
        RegionEmpty(&pParent->clipList);
        break;
    }

    borderVisible = pParent->valdata->before.borderVisible;
    RegionNull(&pParent->valdata->after.borderExposed);
    RegionNull(&pParent->valdata->after.exposed);

    /*
     * Since the borderClip must not be clipped by the children, we do
     * the border exposure first...
     *
     * 'universe' is the window's borderClip. To figure the exposures, remove
     * the area that used to be exposed from the new.
     * This leaves a region of pieces that weren't exposed before.
     */

    if (HasBorder(pParent)) {
        if (borderVisible) {
            /*
             * when the border changes shape, the old visible portions
             * of the border will be saved by DIX in borderVisible --
             * use that region and destroy it
             */
            RegionSubtract(exposed, universe, borderVisible);
            RegionDestroy(borderVisible);
        }
        else {
            RegionSubtract(exposed, universe, &pParent->borderClip);
        }
        if (HasParentRelativeBorder(pParent) && (dx || dy))
            RegionSubtract(&pParent->valdata->after.borderExposed,
                           universe, &pParent->winSize);
        else
            RegionSubtract(&pParent->valdata->after.borderExposed,
                           exposed, &pParent->winSize);

        RegionCopy(&pParent->borderClip, universe);

        /*
         * To get the right clipList for the parent, and to make doubly sure
         * that no child overlaps the parent's border, we remove the parent's
         * border from the universe before proceeding.
         */

        RegionIntersect(universe, universe, &pParent->winSize);
    }
    else
        RegionCopy(&pParent->borderClip, universe);

    if ((pChild = pParent->firstChild) && pParent->mapped) {
        RegionNull(&childUniverse);
        RegionNull(&childUnion);
        if ((pChild->drawable.y < pParent->lastChild->drawable.y) ||
            ((pChild->drawable.y == pParent->lastChild->drawable.y) &&
             (pChild->drawable.x < pParent->lastChild->drawable.x))) {
            for (; pChild; pChild = pChild->nextSib) {
                if (pChild->viewable && !TreatAsTransparent(pChild))
                    RegionAppend(&childUnion, &pChild->borderSize);
            }
        }
        else {
            for (pChild = pParent->lastChild; pChild; pChild = pChild->prevSib) {
                if (pChild->viewable && !TreatAsTransparent(pChild))
                    RegionAppend(&childUnion, &pChild->borderSize);
            }
        }
        RegionValidate(&childUnion, &overlap);

        for (pChild = pParent->firstChild; pChild; pChild = pChild->nextSib) {
            if (pChild->viewable) {
                /*
                 * If the child is viewable, we want to remove its extents
                 * from the current universe, but we only re-clip it if
                 * it's been marked.
                 */
                if (pChild->valdata) {
                    /*
                     * Figure out the new universe from the child's
                     * perspective and recurse.
                     */
                    RegionIntersect(&childUniverse,
                                    universe, &pChild->borderSize);
                    miComputeClips(pChild, pScreen, &childUniverse, kind,
                                   exposed);
                }
                /*
                 * Once the child has been processed, we remove its extents
                 * from the current universe, thus denying its space to any
                 * other sibling.
                 */
                if (overlap && !TreatAsTransparent(pChild))
                    RegionSubtract(universe, universe, &pChild->borderSize);
            }
        }
        if (!overlap)
            RegionSubtract(universe, universe, &childUnion);
        RegionUninit(&childUnion);
        RegionUninit(&childUniverse);
    }                           /* if any children */

    /*
     * 'universe' now contains the new clipList for the parent window.
     *
     * To figure the exposure of the window we subtract the old clip from the
     * new, just as for the border.
     */

    if (oldVis == VisibilityFullyObscured || oldVis == VisibilityNotViewable) {
        RegionCopy(&pParent->valdata->after.exposed, universe);
    }
    else if (newVis != VisibilityFullyObscured &&
             newVis != VisibilityNotViewable) {
        RegionSubtract(&pParent->valdata->after.exposed,
                       universe, &pParent->clipList);
    }

    /* HACK ALERT - copying contents of regions, instead of regions */
    {
        RegionRec tmp;

        tmp = pParent->clipList;
        pParent->clipList = *universe;
        *universe = tmp;
    }

#ifdef NOTDEF
    RegionCopy(&pParent->clipList, universe);
#endif

    pParent->drawable.serialNumber = NEXT_SERIAL_NUMBER;

    if (pScreen->ClipNotify)
        (*pScreen->ClipNotify) (pParent, dx, dy);
}

static void
miTreeObscured(WindowPtr pParent)
{
    WindowPtr pChild;
    int oldVis;

    pChild = pParent;
    while (1) {
        if (pChild->viewable) {
            oldVis = pChild->visibility;
            if (oldVis != (pChild->visibility = VisibilityFullyObscured) &&
                ((pChild->
                  eventMask | wOtherEventMasks(pChild)) & VisibilityChangeMask))
                SendVisibilityNotify(pChild);
            if (pChild->firstChild) {
                pChild = pChild->firstChild;
                continue;
            }
        }
        while (!pChild->nextSib && (pChild != pParent))
            pChild = pChild->parent;
        if (pChild == pParent)
            break;
        pChild = pChild->nextSib;
    }
}

static RegionPtr
getBorderClip(WindowPtr pWin)
{
#ifdef COMPOSITE
    if (pWin->redirectDraw != RedirectDrawNone)
        return compGetRedirectBorderClip(pWin);
    else
#endif
        return &pWin->borderClip;
}

/*
 *-----------------------------------------------------------------------
 * miValidateTree --
 *	Recomputes the clip list for pParent and all its inferiors.
 *
 * Results:
 *	Always returns 1.
 *
 * Side Effects:
 *	The clipList, borderClip, exposed, and borderExposed regions for
 *	each marked window are altered.
 *
 * Notes:
 *	This routine assumes that all affected windows have been marked
 *	(valdata created) and their winSize and borderSize regions
 *	adjusted to correspond to their new positions. The borderClip and
 *	clipList regions should not have been touched.
 *
 *	The top-most level is treated differently from all lower levels
 *	because pParent is unchanged. For the top level, we merge the
 *	regions taken up by the marked children back into the clipList
 *	for pParent, thus forming a region from which the marked children
 *	can claim their areas. For lower levels, where the old clipList
 *	and borderClip are invalid, we can't do this and have to do the
 *	extra operations done in miComputeClips, but this is much faster
 *	e.g. when only one child has moved...
 *
 *-----------------------------------------------------------------------
 */
 /*ARGSUSED*/ int
miValidateTree(WindowPtr pParent,       /* Parent to validate */
               WindowPtr pChild,        /* First child of pParent that was
                                         * affected */
               VTKind kind      /* What kind of configuration caused call */
    )
{
    RegionRec totalClip;        /* Total clipping region available to
                                 * the marked children. pParent's clipList
                                 * merged with the borderClips of all
                                 * the marked children. */
    RegionRec childClip;        /* The new borderClip for the current
                                 * child */
    RegionRec childUnion;       /* the space covered by borderSize for
                                 * all marked children */
    RegionRec exposed;          /* For intermediate calculations */
    ScreenPtr pScreen;
    WindowPtr pWin;
    Bool overlap;
    int viewvals;
    Bool forward;

    pScreen = pParent->drawable.pScreen;
    if (pChild == NullWindow)
        pChild = pParent->firstChild;

    RegionNull(&childClip);
    RegionNull(&exposed);

    /*
     * compute the area of the parent window occupied
     * by the marked children + the parent itself.  This
     * is the area which can be divied up among the marked
     * children in their new configuration.
     */
    RegionNull(&totalClip);
    viewvals = 0;
    if (RegionBroken(&pParent->clipList) && !RegionBroken(&pParent->borderClip)) {
        kind = VTBroken;
        /*
         * When rebuilding clip lists after out of memory,
         * assume everything is busted.
         */
        forward = TRUE;
        RegionCopy(&totalClip, &pParent->borderClip);
        RegionIntersect(&totalClip, &totalClip, &pParent->winSize);

        for (pWin = pParent->firstChild; pWin != pChild; pWin = pWin->nextSib) {
            if (pWin->viewable && !TreatAsTransparent(pWin))
                RegionSubtract(&totalClip, &totalClip, &pWin->borderSize);
        }
        for (pWin = pChild; pWin; pWin = pWin->nextSib)
            if (pWin->valdata && pWin->viewable)
                viewvals++;

        RegionEmpty(&pParent->clipList);
    }
    else {
        if ((pChild->drawable.y < pParent->lastChild->drawable.y) ||
            ((pChild->drawable.y == pParent->lastChild->drawable.y) &&
             (pChild->drawable.x < pParent->lastChild->drawable.x))) {
            forward = TRUE;
            for (pWin = pChild; pWin; pWin = pWin->nextSib) {
                if (pWin->valdata) {
                    RegionAppend(&totalClip, getBorderClip(pWin));
                    if (pWin->viewable)
                        viewvals++;
                }
            }
        }
        else {
            forward = FALSE;
            pWin = pParent->lastChild;
            while (1) {
                if (pWin->valdata) {
                    RegionAppend(&totalClip, getBorderClip(pWin));
                    if (pWin->viewable)
                        viewvals++;
                }
                if (pWin == pChild)
                    break;
                pWin = pWin->prevSib;
            }
        }
        RegionValidate(&totalClip, &overlap);
    }

    /*
     * Now go through the children of the root and figure their new
     * borderClips from the totalClip, passing that off to miComputeClips
     * to handle recursively. Once that's done, we remove the child
     * from the totalClip to clip any siblings below it.
     */

    overlap = TRUE;
    if (kind != VTStack) {
        RegionUnion(&totalClip, &totalClip, &pParent->clipList);
        if (viewvals > 1) {
            /*
             * precompute childUnion to discover whether any of them
             * overlap.  This seems redundant, but performance studies
             * have demonstrated that the cost of this loop is
             * lower than the cost of multiple Subtracts in the
             * loop below.
             */
            RegionNull(&childUnion);
            if (forward) {
                for (pWin = pChild; pWin; pWin = pWin->nextSib)
                    if (pWin->valdata && pWin->viewable &&
                        !TreatAsTransparent(pWin))
                        RegionAppend(&childUnion, &pWin->borderSize);
            }
            else {
                pWin = pParent->lastChild;
                while (1) {
                    if (pWin->valdata && pWin->viewable &&
                        !TreatAsTransparent(pWin))
                        RegionAppend(&childUnion, &pWin->borderSize);
                    if (pWin == pChild)
                        break;
                    pWin = pWin->prevSib;
                }
            }
            RegionValidate(&childUnion, &overlap);
            if (overlap)
                RegionUninit(&childUnion);
        }
    }

    for (pWin = pChild; pWin != NullWindow; pWin = pWin->nextSib) {
        if (pWin->viewable) {
            if (pWin->valdata) {
                RegionIntersect(&childClip, &totalClip, &pWin->borderSize);
                miComputeClips(pWin, pScreen, &childClip, kind, &exposed);
                if (overlap && !TreatAsTransparent(pWin)) {
                    RegionSubtract(&totalClip, &totalClip, &pWin->borderSize);
                }
            }
            else if (pWin->visibility == VisibilityNotViewable) {
                miTreeObscured(pWin);
            }
        }
        else {
            if (pWin->valdata) {
                RegionEmpty(&pWin->clipList);
                if (pScreen->ClipNotify)
                    (*pScreen->ClipNotify) (pWin, 0, 0);
                RegionEmpty(&pWin->borderClip);
                pWin->valdata = NULL;
            }
        }
    }

    RegionUninit(&childClip);
    if (!overlap) {
        RegionSubtract(&totalClip, &totalClip, &childUnion);
        RegionUninit(&childUnion);
    }

    RegionNull(&pParent->valdata->after.exposed);
    RegionNull(&pParent->valdata->after.borderExposed);

    /*
     * each case below is responsible for updating the
     * clipList and serial number for the parent window
     */

    switch (kind) {
    case VTStack:
        break;
    default:
        /*
         * totalClip contains the new clipList for the parent. Figure out
         * exposures and obscures as per miComputeClips and reset the parent's
         * clipList.
         */
        RegionSubtract(&pParent->valdata->after.exposed,
                       &totalClip, &pParent->clipList);
        /* fall through */
    case VTMap:
        RegionCopy(&pParent->clipList, &totalClip);
        pParent->drawable.serialNumber = NEXT_SERIAL_NUMBER;
        break;
    }

    RegionUninit(&totalClip);
    RegionUninit(&exposed);
    if (pScreen->ClipNotify)
        (*pScreen->ClipNotify) (pParent, 0, 0);
    return 1;
}
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d30 1
a30 1
 * Copyright 1987, 1988, 1989 by 
d32 1
a32 1
 * 
d34 3
a36 3
 * 
 * Permission to use, copy, modify, and distribute this software and its 
 * documentation for any purpose and without fee is hereby granted, 
d38 1
a38 1
 * both that copyright notice and this permission notice appear in 
d41 2
a42 2
 * software without specific, written prior permission.  
 * 
d50 1
a50 1
 * 
d82 1
a82 1
 /* 
a101 1

d103 3
a164 11
static GetRedirectBorderClipProcPtr miGetRedirectBorderClipProc;
static SetRedirectBorderClipProcPtr miSetRedirectBorderClipProc;

void
miRegisterRedirectBorderClipProc(SetRedirectBorderClipProcPtr setBorderClip,
                                 GetRedirectBorderClipProcPtr getBorderClip)
{
    miSetRedirectBorderClipProc = setBorderClip;
    miGetRedirectBorderClipProc = getBorderClip;
}

d236 3
a238 5
        if (miSetRedirectBorderClipProc) {
            if (TreatAsTransparent(pParent))
                RegionEmpty(universe);
            (*miSetRedirectBorderClipProc) (pParent, universe);
        }
d508 11
d612 1
a612 8
                    RegionPtr pBorderClip = &pWin->borderClip;

#ifdef COMPOSITE
                    if (pWin->redirectDraw != RedirectDrawNone &&
                        miGetRedirectBorderClipProc)
                        pBorderClip = (*miGetRedirectBorderClipProc) (pWin);
#endif
                    RegionAppend(&totalClip, pBorderClip);
d623 1
a623 8
                    RegionPtr pBorderClip = &pWin->borderClip;

#ifdef COMPOSITE
                    if (pWin->redirectDraw != RedirectDrawNone &&
                        miGetRedirectBorderClipProc)
                        pBorderClip = (*miGetRedirectBorderClipProc) (pWin);
#endif
                    RegionAppend(&totalClip, pBorderClip);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a81 1

d88 2
a89 2
  *		Bob Scheifler -- avoid miComputeClips for unmapped windows,
  *				 valdata changes
d109 2
a110 2
miShapedWindowIn (RegionPtr universe, RegionPtr bounding,
                  BoxPtr rect, int x, int y)
d112 5
a116 5
    BoxRec  	box;
    BoxPtr	boundBox;
    int		nbox;
    Bool	someIn, someOut;
    int 	t, x1, y1, x2, y2;
d118 2
a119 2
    nbox = RegionNumRects (bounding);
    boundBox = RegionRects (bounding);
d125 32
a156 34
    while (nbox--)
    {
	if ((t = boundBox->x1 + x) < x1)
	    t = x1;
	box.x1 = t;
	if ((t = boundBox->y1 + y) < y1)
	    t = y1;
	box.y1 = t;
	if ((t = boundBox->x2 + x) > x2)
	    t = x2;
	box.x2 = t;
	if ((t = boundBox->y2 + y) > y2)
	    t = y2;
	box.y2 = t;
	if (box.x1 > box.x2)
	    box.x2 = box.x1;
	if (box.y1 > box.y2)
	    box.y2 = box.y1;
	switch (RegionContainsRect(universe, &box))
	{
	case rgnIN:
	    if (someOut)
		return rgnPART;
	    someIn = TRUE;
	    break;
	case rgnOUT:
	    if (someIn)
		return rgnPART;
	    someOut = TRUE;
	    break;
	default:
	    return rgnPART;
	}
	boundBox++;
d159 1
a159 1
	return rgnIN;
d163 2
a164 2
static GetRedirectBorderClipProcPtr	miGetRedirectBorderClipProc;
static SetRedirectBorderClipProcPtr	miSetRedirectBorderClipProc;
d167 2
a168 2
miRegisterRedirectBorderClipProc (SetRedirectBorderClipProcPtr setBorderClip,
				  GetRedirectBorderClipProcPtr getBorderClip)
a188 1

d206 13
a218 17
miComputeClips (
    WindowPtr	pParent,
    ScreenPtr	pScreen,
    RegionPtr	universe,
    VTKind		kind,
    RegionPtr		exposed ) /* for intermediate calculations */
{
    int			dx,
			dy;
    RegionRec		childUniverse;
    WindowPtr		pChild;
    int     	  	oldVis, newVis;
    BoxRec		borderSize;
    RegionRec		childUnion;
    Bool		overlap;
    RegionPtr		borderVisible;
    Bool		resized;
d229 2
a230 1
    dx = (int) pParent->drawable.x + (int) pParent->drawable.width + wBorderWidth(pParent);
d232 1
a232 1
	dx = 32767;
d234 2
a235 1
    dy = (int) pParent->drawable.y + (int) pParent->drawable.height + wBorderWidth(pParent);
d237 1
a237 1
	dy = 32767;
d244 7
a250 9
    if (pParent->redirectDraw != RedirectDrawNone)
    {
	if (miSetRedirectBorderClipProc)
	{
	    if (TreatAsTransparent (pParent))
		RegionEmpty(universe);
	    (*miSetRedirectBorderClipProc) (pParent, universe);
	}
	RegionCopy(universe, &pParent->borderSize);
d255 27
a281 30
    switch (RegionContainsRect(universe, &borderSize))
    {
	case rgnIN:
	    newVis = VisibilityUnobscured;
	    break;
	case rgnPART:
	    newVis = VisibilityPartiallyObscured;
	    {
		RegionPtr   pBounding;

		if ((pBounding = wBoundingShape (pParent)))
		{
		    switch (miShapedWindowIn (universe, pBounding,
					      &borderSize,
					      pParent->drawable.x,
 					      pParent->drawable.y))
		    {
		    case rgnIN:
			newVis = VisibilityUnobscured;
			break;
		    case rgnOUT:
			newVis = VisibilityFullyObscured;
			break;
		    }
		}
	    }
	    break;
	default:
	    newVis = VisibilityFullyObscured;
	    break;
d285 3
a287 2
	((pParent->eventMask | wOtherEventMasks(pParent)) & VisibilityChangeMask))
	SendVisibilityNotify(pParent);
d300 1
a300 1
	break;
d302 37
a338 46
	if ((oldVis == newVis) &&
	    ((oldVis == VisibilityFullyObscured) ||
	     (oldVis == VisibilityUnobscured)))
	{
	    pChild = pParent;
	    while (1)
	    {
		if (pChild->viewable)
		{
		    if (pChild->visibility != VisibilityFullyObscured)
		    {
			RegionTranslate(&pChild->borderClip,
						      dx, dy);
			RegionTranslate(&pChild->clipList,
						      dx, dy);
			pChild->drawable.serialNumber = NEXT_SERIAL_NUMBER;
			if (pScreen->ClipNotify)
			    (* pScreen->ClipNotify) (pChild, dx, dy);

		    }
		    if (pChild->valdata)
		    {
			RegionNull(&pChild->valdata->after.borderExposed);
			if (HasParentRelativeBorder(pChild))
			{
			    RegionSubtract(&pChild->valdata->after.borderExposed,
					   &pChild->borderClip,
					   &pChild->winSize);
			}
			RegionNull(&pChild->valdata->after.exposed);
		    }
		    if (pChild->firstChild)
		    {
			pChild = pChild->firstChild;
			continue;
		    }
		}
		while (!pChild->nextSib && (pChild != pParent))
		    pChild = pChild->parent;
		if (pChild == pParent)
		    break;
		pChild = pChild->nextSib;
	    }
	    return;
	}
	/* fall through */
d340 14
a353 15
    	/*
     	 * To calculate exposures correctly, we have to translate the old
     	 * borderClip and clipList regions to the window's new location so there
     	 * is a correspondence between pieces of the new and old clipping regions.
     	 */
    	if (dx || dy) 
    	{
	    /*
	     * We translate the old clipList because that will be exposed or copied
	     * if gravity is right.
	     */
	    RegionTranslate(&pParent->borderClip, dx, dy);
	    RegionTranslate(&pParent->clipList, dx, dy);
    	} 
	break;
d355 3
a357 3
	RegionEmpty(&pParent->borderClip);
	RegionEmpty(&pParent->clipList);
	break;
a360 1
    resized = pParent->valdata->before.resized;
d373 29
a401 33
    if (HasBorder (pParent))
    {
    	if (borderVisible)
    	{
	    /*
	     * when the border changes shape, the old visible portions
	     * of the border will be saved by DIX in borderVisible --
	     * use that region and destroy it
	     */
	    RegionSubtract(exposed, universe, borderVisible);
	    RegionDestroy(borderVisible);
    	}
    	else
    	{
	    RegionSubtract(exposed, universe, &pParent->borderClip);
    	}
	if (HasParentRelativeBorder(pParent) && (dx || dy))
	    RegionSubtract(&pParent->valdata->after.borderExposed,
				  universe,
				  &pParent->winSize);
	else
	    RegionSubtract(&pParent->valdata->after.borderExposed,
			       exposed, &pParent->winSize);

	RegionCopy(&pParent->borderClip, universe);
    
    	/*
     	 * To get the right clipList for the parent, and to make doubly sure
     	 * that no child overlaps the parent's border, we remove the parent's
     	 * border from the universe before proceeding.
     	 */
    
	RegionIntersect(universe, universe, &pParent->winSize);
d404 52
a455 62
	RegionCopy(&pParent->borderClip, universe);
    
    if ((pChild = pParent->firstChild) && pParent->mapped)
    {
	RegionNull(&childUniverse);
	RegionNull(&childUnion);
	if ((pChild->drawable.y < pParent->lastChild->drawable.y) ||
	    ((pChild->drawable.y == pParent->lastChild->drawable.y) &&
	     (pChild->drawable.x < pParent->lastChild->drawable.x)))
	{
	    for (; pChild; pChild = pChild->nextSib)
	    {
		if (pChild->viewable && !TreatAsTransparent(pChild))
		    RegionAppend(&childUnion, &pChild->borderSize);
	    }
	}
	else
	{
	    for (pChild = pParent->lastChild; pChild; pChild = pChild->prevSib)
	    {
		if (pChild->viewable && !TreatAsTransparent(pChild))
		    RegionAppend(&childUnion, &pChild->borderSize);
	    }
	}
	RegionValidate(&childUnion, &overlap);

	for (pChild = pParent->firstChild;
	     pChild;
	     pChild = pChild->nextSib)
 	{
	    if (pChild->viewable) {
		/*
		 * If the child is viewable, we want to remove its extents
		 * from the current universe, but we only re-clip it if
		 * it's been marked.
		 */
		if (pChild->valdata) {
		    /*
		     * Figure out the new universe from the child's
		     * perspective and recurse.
		     */
		    RegionIntersect(&childUniverse,
					    universe,
					    &pChild->borderSize);
		    miComputeClips (pChild, pScreen, &childUniverse, kind,
				    exposed);
		}
		/*
		 * Once the child has been processed, we remove its extents
		 * from the current universe, thus denying its space to any
		 * other sibling.
		 */
		if (overlap && !TreatAsTransparent (pChild))
		    RegionSubtract(universe, universe,
					  &pChild->borderSize);
	    }
	}
	if (!overlap)
	    RegionSubtract(universe, universe, &childUnion);
	RegionUninit(&childUnion);
	RegionUninit(&childUniverse);
    } /* if any children */
d464 2
a465 4
    if (oldVis == VisibilityFullyObscured ||
	oldVis == VisibilityNotViewable)
    {
	RegionCopy(&pParent->valdata->after.exposed, universe);
d468 3
a470 4
	     newVis != VisibilityNotViewable)
    {
	RegionSubtract(&pParent->valdata->after.exposed,
			       universe, &pParent->clipList);
d475 1
a475 1
	RegionRec   tmp;
d477 3
a479 3
	tmp = pParent->clipList;
	pParent->clipList = *universe;
	*universe = tmp;
d489 1
a489 1
	(* pScreen->ClipNotify) (pParent, dx, dy);
d493 1
a493 2
miTreeObscured(
    WindowPtr pParent )
d495 2
a496 2
    WindowPtr 	pChild;
    int    	oldVis;
d499 17
a515 19
    while (1)
    {
	if (pChild->viewable)
	{
	    oldVis = pChild->visibility;
	    if (oldVis != (pChild->visibility = VisibilityFullyObscured) &&
		((pChild->eventMask | wOtherEventMasks(pChild)) & VisibilityChangeMask))
		SendVisibilityNotify(pChild);
	    if (pChild->firstChild)
	    {
		pChild = pChild->firstChild;
		continue;
	    }
	}
	while (!pChild->nextSib && (pChild != pParent))
	    pChild = pChild->parent;
	if (pChild == pParent)
	    break;
	pChild = pChild->nextSib;
d548 5
a552 7
/*ARGSUSED*/
int
miValidateTree (
    WindowPtr		pParent,    /* Parent to validate */
    WindowPtr		pChild,     /* First child of pParent that was
				     * affected */
    VTKind		kind        /* What kind of configuration caused call */
d555 14
a568 14
    RegionRec	  	totalClip;  /* Total clipping region available to
				     * the marked children. pParent's clipList
				     * merged with the borderClips of all
				     * the marked children. */
    RegionRec	  	childClip;  /* The new borderClip for the current
				     * child */
    RegionRec		childUnion; /* the space covered by borderSize for
				     * all marked children */
    RegionRec		exposed;    /* For intermediate calculations */
    ScreenPtr		pScreen;
    WindowPtr		pWin;
    Bool		overlap;
    int			viewvals;
    Bool		forward;
d572 1
a572 1
	pChild = pParent->firstChild;
d585 29
a613 35
    if (RegionBroken(&pParent->clipList) &&
	!RegionBroken(&pParent->borderClip))
    {
	kind = VTBroken;
	/*
	 * When rebuilding clip lists after out of memory,
	 * assume everything is busted.
	 */
	forward = TRUE;
	RegionCopy(&totalClip, &pParent->borderClip);
	RegionIntersect(&totalClip, &totalClip, &pParent->winSize);
	
	for (pWin = pParent->firstChild; pWin != pChild; pWin = pWin->nextSib)
	{
	    if (pWin->viewable && !TreatAsTransparent (pWin))
		RegionSubtract(&totalClip, &totalClip, &pWin->borderSize);
	}
	for (pWin = pChild; pWin; pWin = pWin->nextSib)
	    if (pWin->valdata && pWin->viewable)
		viewvals++;
	
	RegionEmpty(&pParent->clipList);
    }
    else 
    {
	if ((pChild->drawable.y < pParent->lastChild->drawable.y) ||
	    ((pChild->drawable.y == pParent->lastChild->drawable.y) &&
	     (pChild->drawable.x < pParent->lastChild->drawable.x)))
	{
	    forward = TRUE;
	    for (pWin = pChild; pWin; pWin = pWin->nextSib)
	    {
		if (pWin->valdata)
		{
		    RegionPtr	pBorderClip = &pWin->borderClip;
d615 3
a617 2
		    if (pWin->redirectDraw != RedirectDrawNone && miGetRedirectBorderClipProc)
			pBorderClip = (*miGetRedirectBorderClipProc)(pWin);
d619 13
a631 15
		    RegionAppend(&totalClip, pBorderClip );
		    if (pWin->viewable)
			viewvals++;
		}
	    }
	}
	else
	{
	    forward = FALSE;
	    pWin = pParent->lastChild;
	    while (1)
	    {
		if (pWin->valdata)
		{
		    RegionPtr	pBorderClip = &pWin->borderClip;
d633 3
a635 2
		    if (pWin->redirectDraw != RedirectDrawNone && miGetRedirectBorderClipProc)
			pBorderClip = (*miGetRedirectBorderClipProc)(pWin);
d637 10
a646 10
		    RegionAppend(&totalClip, pBorderClip );
		    if (pWin->viewable)
			viewvals++;
		}
		if (pWin == pChild)
		    break;
		pWin = pWin->prevSib;
	    }
	}
	RegionValidate(&totalClip, &overlap);
d657 56
a712 67
    if (kind != VTStack)
    {
	RegionUnion(&totalClip, &totalClip, &pParent->clipList);
	if (viewvals > 1)
	{
	    /*
	     * precompute childUnion to discover whether any of them
	     * overlap.  This seems redundant, but performance studies
	     * have demonstrated that the cost of this loop is
	     * lower than the cost of multiple Subtracts in the
	     * loop below.
	     */
	    RegionNull(&childUnion);
	    if (forward)
	    {
		for (pWin = pChild; pWin; pWin = pWin->nextSib)
		    if (pWin->valdata && pWin->viewable && !TreatAsTransparent (pWin))
			RegionAppend(&childUnion,
						   &pWin->borderSize);
	    }
	    else
	    {
		pWin = pParent->lastChild;
		while (1)
		{
		    if (pWin->valdata && pWin->viewable && !TreatAsTransparent (pWin))
			RegionAppend(&childUnion,
						   &pWin->borderSize);
		    if (pWin == pChild)
			break;
		    pWin = pWin->prevSib;
		}
	    }
	    RegionValidate(&childUnion, &overlap);
	    if (overlap)
		RegionUninit(&childUnion);
	}
    }

    for (pWin = pChild;
	 pWin != NullWindow;
	 pWin = pWin->nextSib)
    {
	if (pWin->viewable) {
	    if (pWin->valdata) {
		RegionIntersect(&childClip,
					&totalClip,
 					&pWin->borderSize);
		miComputeClips (pWin, pScreen, &childClip, kind, &exposed);
		if (overlap && !TreatAsTransparent (pWin))
		{
		    RegionSubtract(&totalClip,
				       	   &totalClip,
				       	   &pWin->borderSize);
		}
	    } else if (pWin->visibility == VisibilityNotViewable) {
		miTreeObscured(pWin);
	    }
	} else {
	    if (pWin->valdata) {
		RegionEmpty(&pWin->clipList);
		if (pScreen->ClipNotify)
		    (* pScreen->ClipNotify) (pWin, 0, 0);
		RegionEmpty(&pWin->borderClip);
		pWin->valdata = NULL;
	    }
	}
d716 3
a718 4
    if (!overlap)
    {
	RegionSubtract(&totalClip, &totalClip, &childUnion);
	RegionUninit(&childUnion);
d731 1
a731 1
	break;
d733 8
a740 8
	/*
	 * totalClip contains the new clipList for the parent. Figure out
	 * exposures and obscures as per miComputeClips and reset the parent's
	 * clipList.
	 */
	RegionSubtract(&pParent->valdata->after.exposed,
			       &totalClip, &pParent->clipList);
	/* fall through */
d742 3
a744 3
	RegionCopy(&pParent->clipList, &totalClip);
	pParent->drawable.serialNumber = NEXT_SERIAL_NUMBER;
	break;
d750 1
a750 1
	(*pScreen->ClipNotify) (pParent, 0, 0);
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d110 1
a110 1
miShapedWindowIn (ScreenPtr pScreen, RegionPtr universe, RegionPtr bounding,
d119 2
a120 2
    nbox = REGION_NUM_RECTS (bounding);
    boundBox = REGION_RECTS (bounding);
d144 1
a144 1
	switch (RECT_IN_REGION(pScreen, universe, &box))
d255 1
a255 1
		REGION_EMPTY (pScreen, universe);
d258 1
a258 1
	REGION_COPY(pScreen, universe, &pParent->borderSize);
d263 1
a263 1
    switch (RECT_IN_REGION( pScreen, universe, &borderSize)) 
d275 1
a275 1
		    switch (miShapedWindowIn (pScreen, universe, pBounding,
d323 1
a323 1
			REGION_TRANSLATE( pScreen, &pChild->borderClip,
d325 1
a325 1
			REGION_TRANSLATE( pScreen, &pChild->clipList,
d334 1
a334 2
			REGION_NULL(pScreen,
				    &pChild->valdata->after.borderExposed);
d337 3
a339 4
			    REGION_SUBTRACT(pScreen,
					 &pChild->valdata->after.borderExposed,
					 &pChild->borderClip,
					 &pChild->winSize);
d341 1
a341 1
			REGION_NULL(pScreen, &pChild->valdata->after.exposed);
d370 2
a371 2
	    REGION_TRANSLATE( pScreen, &pParent->borderClip, dx, dy);
	    REGION_TRANSLATE( pScreen, &pParent->clipList, dx, dy);
d375 2
a376 2
	REGION_EMPTY (pScreen, &pParent->borderClip);
	REGION_EMPTY (pScreen, &pParent->clipList);
d382 2
a383 2
    REGION_NULL(pScreen, &pParent->valdata->after.borderExposed);
    REGION_NULL(pScreen, &pParent->valdata->after.exposed);
d403 2
a404 2
	    REGION_SUBTRACT( pScreen, exposed, universe, borderVisible);
	    REGION_DESTROY( pScreen, borderVisible);
d408 1
a408 1
	    REGION_SUBTRACT( pScreen, exposed, universe, &pParent->borderClip);
d411 1
a411 1
	    REGION_SUBTRACT( pScreen, &pParent->valdata->after.borderExposed,
d415 1
a415 1
	    REGION_SUBTRACT( pScreen, &pParent->valdata->after.borderExposed,
d418 1
a418 1
    	REGION_COPY( pScreen, &pParent->borderClip, universe);
d426 1
a426 1
    	REGION_INTERSECT( pScreen, universe, universe, &pParent->winSize);
d429 1
a429 1
    	REGION_COPY( pScreen, &pParent->borderClip, universe);
d433 2
a434 2
	REGION_NULL(pScreen, &childUniverse);
	REGION_NULL(pScreen, &childUnion);
d442 1
a442 1
		    REGION_APPEND( pScreen, &childUnion, &pChild->borderSize);
d450 1
a450 1
		    REGION_APPEND( pScreen, &childUnion, &pChild->borderSize);
d453 1
a453 1
	REGION_VALIDATE( pScreen, &childUnion, &overlap);
d470 1
a470 1
		    REGION_INTERSECT( pScreen, &childUniverse,
d482 1
a482 1
		    REGION_SUBTRACT( pScreen, universe, universe,
d487 3
a489 3
	    REGION_SUBTRACT( pScreen, universe, universe, &childUnion);
	REGION_UNINIT( pScreen, &childUnion);
	REGION_UNINIT( pScreen, &childUniverse);
d502 1
a502 1
	REGION_COPY( pScreen, &pParent->valdata->after.exposed, universe);
d507 1
a507 1
    	REGION_SUBTRACT( pScreen, &pParent->valdata->after.exposed,
d521 1
a521 1
    REGION_COPY( pScreen, &pParent->clipList, universe);
d617 2
a618 2
    REGION_NULL(pScreen, &childClip);
    REGION_NULL(pScreen, &exposed);
d626 1
a626 1
    REGION_NULL(pScreen, &totalClip);
d628 2
a629 2
    if (REGION_BROKEN (pScreen, &pParent->clipList) &&
	!REGION_BROKEN (pScreen, &pParent->borderClip))
d637 2
a638 2
	REGION_COPY (pScreen, &totalClip, &pParent->borderClip);
	REGION_INTERSECT (pScreen, &totalClip, &totalClip, &pParent->winSize);
d643 1
a643 1
		REGION_SUBTRACT (pScreen, &totalClip, &totalClip, &pWin->borderSize);
d649 1
a649 1
	REGION_EMPTY (pScreen, &pParent->clipList);
d667 1
a667 1
		    REGION_APPEND( pScreen, &totalClip, pBorderClip );
d686 1
a686 1
		    REGION_APPEND( pScreen, &totalClip, pBorderClip );
d695 1
a695 1
	REGION_VALIDATE( pScreen, &totalClip, &overlap);
d708 1
a708 1
	REGION_UNION( pScreen, &totalClip, &totalClip, &pParent->clipList);
d718 1
a718 1
	    REGION_NULL(pScreen, &childUnion);
d723 1
a723 1
			REGION_APPEND( pScreen, &childUnion,
d732 1
a732 1
			REGION_APPEND( pScreen, &childUnion,
d739 1
a739 1
	    REGION_VALIDATE(pScreen, &childUnion, &overlap);
d741 1
a741 1
		REGION_UNINIT(pScreen, &childUnion);
d751 1
a751 1
		REGION_INTERSECT( pScreen, &childClip,
d757 1
a757 1
		    REGION_SUBTRACT( pScreen, &totalClip,
d766 1
a766 1
		REGION_EMPTY( pScreen, &pWin->clipList);
d769 1
a769 1
		REGION_EMPTY( pScreen, &pWin->borderClip);
d775 1
a775 1
    REGION_UNINIT( pScreen, &childClip);
d778 2
a779 2
	REGION_SUBTRACT(pScreen, &totalClip, &totalClip, &childUnion);
	REGION_UNINIT(pScreen, &childUnion);
d782 2
a783 2
    REGION_NULL(pScreen, &pParent->valdata->after.exposed);
    REGION_NULL(pScreen, &pParent->valdata->after.borderExposed);
d799 1
a799 1
	REGION_SUBTRACT( pScreen, &pParent->valdata->after.exposed,
d803 1
a803 1
	REGION_COPY( pScreen, &pParent->clipList, &totalClip);
d808 2
a809 2
    REGION_UNINIT( pScreen, &totalClip);
    REGION_UNINIT( pScreen, &exposed);
d812 1
a812 1
    return (1);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d772 1
a772 1
		pWin->valdata = (ValidatePtr)NULL;
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@a105 1
#ifdef SHAPE
d109 3
a111 6
_X_EXPORT int
miShapedWindowIn (pScreen, universe, bounding, rect, x, y)
    ScreenPtr	pScreen;
    RegionPtr	universe, bounding;
    BoxPtr	rect;
    int 	x, y;
a164 1
#endif
a269 1
#ifdef SHAPE
a288 1
#endif
d593 3
a595 3
miValidateTree (pParent, pChild, kind)
    WindowPtr	  	pParent;    /* Parent to validate */
    WindowPtr	  	pChild;     /* First child of pParent that was
d597 2
a598 1
    VTKind    	  	kind;       /* What kind of configuration caused call */
@


1.1
log
@Initial revision
@
text
@d115 1
a115 1
    register int x, y;
d117 5
a121 5
    BoxRec  box;
    register BoxPtr  boundBox;
    int	    nbox;
    Bool    someIn, someOut;
    register int t, x1, y1, x2, y2;
d182 11
d216 3
a218 3
    register WindowPtr	pParent,
    register ScreenPtr	pScreen,
    register RegionPtr	universe,
d225 1
a225 1
    register WindowPtr	pChild;
d255 1
a255 1
    if (pParent->redirectDraw)
d258 3
d262 1
d450 1
a450 1
		if (pChild->viewable)
d458 1
a458 1
		if (pChild->viewable)
d490 1
a490 1
		if (overlap)
a519 12
    /*
     * One last thing: backing storage. We have to try to save what parts of
     * the window are about to be obscured. We can just subtract the universe
     * from the old clipList and get the areas that were in the old but aren't
     * in the new and, hence, are about to be obscured.
     */
    if (pParent->backStorage && !resized)
    {
	REGION_SUBTRACT( pScreen, exposed, &pParent->clipList, universe);
	(* pScreen->SaveDoomedAreas)(pParent, exposed, dx, dy);
    }
    
d541 1
a541 1
    register WindowPtr pParent )
d543 2
a544 2
    register WindowPtr pChild;
    register int    oldVis;
d615 2
a616 2
    register ScreenPtr	pScreen;
    register WindowPtr	pWin;
d650 1
a650 1
	    if (pWin->viewable)
d672 1
a672 1
		    if (pWin->redirectDraw && miGetRedirectBorderClipProc)
d691 1
a691 1
		    if (pWin->redirectDraw && miGetRedirectBorderClipProc)
d730 1
a730 1
		    if (pWin->valdata && pWin->viewable)
d739 1
a739 1
		    if (pWin->valdata && pWin->viewable)
d763 1
a763 1
		if (overlap)
a810 5
	if (pParent->backStorage) {
	    REGION_SUBTRACT( pScreen, &exposed, &pParent->clipList, &totalClip);
	    (* pScreen->SaveDoomedAreas)(pParent, &exposed, 0, 0);
	}
	
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d115 1
a115 1
    int 	x, y;
d117 5
a121 5
    BoxRec  	box;
    BoxPtr	boundBox;
    int		nbox;
    Bool	someIn, someOut;
    int 	t, x1, y1, x2, y2;
a181 11
/*
 * Manual redirected windows are treated as transparent; they do not obscure
 * siblings or parent windows
 */

#ifdef COMPOSITE
#define TreatAsTransparent(w)	((w)->redirectDraw == RedirectDrawManual)
#else
#define TreatAsTransparent(w)	FALSE
#endif

d205 3
a207 3
    WindowPtr	pParent,
    ScreenPtr	pScreen,
    RegionPtr	universe,
d214 1
a214 1
    WindowPtr		pChild;
d244 1
a244 1
    if (pParent->redirectDraw != RedirectDrawNone)
d435 1
a435 1
		if (pChild->viewable && !TreatAsTransparent(pChild))
d443 1
a443 1
		if (pChild->viewable && !TreatAsTransparent(pChild))
d475 1
a475 1
		if (overlap && !TreatAsTransparent (pChild))
d538 1
a538 1
    WindowPtr pParent )
d540 2
a541 2
    WindowPtr 	pChild;
    int    	oldVis;
d612 2
a613 2
    ScreenPtr		pScreen;
    WindowPtr		pWin;
d647 1
a647 1
	    if (pWin->viewable && !TreatAsTransparent (pWin))
d669 1
a669 1
		    if (pWin->redirectDraw != RedirectDrawNone && miGetRedirectBorderClipProc)
d688 1
a688 1
		    if (pWin->redirectDraw != RedirectDrawNone && miGetRedirectBorderClipProc)
d727 1
a727 1
		    if (pWin->valdata && pWin->viewable && !TreatAsTransparent (pWin))
d736 1
a736 1
		    if (pWin->valdata && pWin->viewable && !TreatAsTransparent (pWin))
d760 1
a760 1
		if (overlap && !TreatAsTransparent (pWin))
@

