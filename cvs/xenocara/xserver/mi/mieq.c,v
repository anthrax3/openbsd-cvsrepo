head	1.16;
access;
symbols
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.2
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.4
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.2
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.2
	OPENBSD_5_0:1.9.0.2
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.3.0.4
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.2
	v1_4_0_90:1.1.1.3
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2016.05.29.12.02.39;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	s0SI41sEunLdyFfd;

1.15
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.14;
commitid	7pAEtF6Y5EgemkuY;

1.14
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	cVXoV5PxI8YrEaVA;

1.13
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.02.16.08.40;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.13.19.54.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.31.14.09.44;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.12.20.17.47;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.14.13;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.14.13;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.56.41;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.12.13.21.07.22;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 *
Copyright 1990, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.
 *
 * Author:  Keith Packard, MIT X Consortium
 */

/*
 * mieq.c
 *
 * Machine independent event queue
 *
 */

#if HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include   <X11/X.h>
#include   <X11/Xmd.h>
#include   <X11/Xproto.h>
#include   "misc.h"
#include   "windowstr.h"
#include   "pixmapstr.h"
#include   "inputstr.h"
#include   "inpututils.h"
#include   "mi.h"
#include   "mipointer.h"
#include   "scrnintstr.h"
#include   <X11/extensions/XI.h>
#include   <X11/extensions/XIproto.h>
#include   <X11/extensions/geproto.h>
#include   "extinit.h"
#include   "exglobals.h"
#include   "eventstr.h"

#ifdef DPMSExtension
#include "dpmsproc.h"
#include <X11/extensions/dpmsconst.h>
#endif

/* Maximum size should be initial size multiplied by a power of 2 */
#define QUEUE_INITIAL_SIZE                 512
#define QUEUE_RESERVED_SIZE                 64
#define QUEUE_MAXIMUM_SIZE                4096
#define QUEUE_DROP_BACKTRACE_FREQUENCY     100
#define QUEUE_DROP_BACKTRACE_MAX            10

#define EnqueueScreen(dev) dev->spriteInfo->sprite->pEnqueueScreen
#define DequeueScreen(dev) dev->spriteInfo->sprite->pDequeueScreen

typedef struct _Event {
    InternalEvent *events;
    ScreenPtr pScreen;
    DeviceIntPtr pDev;          /* device this event _originated_ from */
} EventRec, *EventPtr;

typedef struct _EventQueue {
    HWEventQueueType head, tail;        /* long for SetInputCheck */
    CARD32 lastEventTime;       /* to avoid time running backwards */
    int lastMotion;             /* device ID if last event motion? */
    EventRec *events;           /* our queue as an array */
    size_t nevents;             /* the number of buckets in our queue */
    size_t dropped;             /* counter for number of consecutive dropped events */
    mieqHandler handlers[128];  /* custom event handler */
} EventQueueRec, *EventQueuePtr;

static EventQueueRec miEventQueue;

#ifdef XQUARTZ
#include  <pthread.h>
static pthread_mutex_t miEventQueueMutex = PTHREAD_MUTEX_INITIALIZER;

extern BOOL serverRunning;
extern pthread_mutex_t serverRunningMutex;
extern pthread_cond_t serverRunningCond;

static inline void
wait_for_server_init(void)
{
    /* If the server hasn't finished initializing, wait for it... */
    if (!serverRunning) {
        pthread_mutex_lock(&serverRunningMutex);
        while (!serverRunning)
            pthread_cond_wait(&serverRunningCond, &serverRunningMutex);
        pthread_mutex_unlock(&serverRunningMutex);
    }
}
#endif

static size_t
mieqNumEnqueued(EventQueuePtr eventQueue)
{
    size_t n_enqueued = 0;

    if (eventQueue->nevents) {
        /* % is not well-defined with negative numbers... sigh */
        n_enqueued = eventQueue->tail - eventQueue->head + eventQueue->nevents;
        if (n_enqueued >= eventQueue->nevents)
            n_enqueued -= eventQueue->nevents;
    }
    return n_enqueued;
}

/* Pre-condition: Called with miEventQueueMutex held */
static Bool
mieqGrowQueue(EventQueuePtr eventQueue, size_t new_nevents)
{
    size_t i, n_enqueued, first_hunk;
    EventRec *new_events;

    if (!eventQueue) {
        ErrorF("[mi] mieqGrowQueue called with a NULL eventQueue\n");
        return FALSE;
    }

    if (new_nevents <= eventQueue->nevents)
        return FALSE;

    new_events = calloc(new_nevents, sizeof(EventRec));
    if (new_events == NULL) {
        ErrorF("[mi] mieqGrowQueue memory allocation error.\n");
        return FALSE;
    }

    n_enqueued = mieqNumEnqueued(eventQueue);

    /* We block signals, so an mieqEnqueue triggered by SIGIO does not
     * write to our queue as we are modifying it.
     */
    OsBlockSignals();

    /* First copy the existing events */
    first_hunk = eventQueue->nevents - eventQueue->head;
    memcpy(new_events,
           &eventQueue->events[eventQueue->head],
           first_hunk * sizeof(EventRec));
    memcpy(&new_events[first_hunk],
           eventQueue->events, eventQueue->head * sizeof(EventRec));

    /* Initialize the new portion */
    for (i = eventQueue->nevents; i < new_nevents; i++) {
        InternalEvent *evlist = InitEventList(1);

        if (!evlist) {
            size_t j;

            for (j = 0; j < i; j++)
                FreeEventList(new_events[j].events, 1);
            free(new_events);
            OsReleaseSignals();
            return FALSE;
        }
        new_events[i].events = evlist;
    }

    /* And update our record */
    eventQueue->tail = n_enqueued;
    eventQueue->head = 0;
    eventQueue->nevents = new_nevents;
    free(eventQueue->events);
    eventQueue->events = new_events;

    OsReleaseSignals();
    return TRUE;
}

Bool
mieqInit(void)
{
    memset(&miEventQueue, 0, sizeof(miEventQueue));
    miEventQueue.lastEventTime = GetTimeInMillis();

    if (!mieqGrowQueue(&miEventQueue, QUEUE_INITIAL_SIZE))
        FatalError("Could not allocate event queue.\n");

    SetInputCheck(&miEventQueue.head, &miEventQueue.tail);
    return TRUE;
}

void
mieqFini(void)
{
    int i;

    for (i = 0; i < miEventQueue.nevents; i++) {
        if (miEventQueue.events[i].events != NULL) {
            FreeEventList(miEventQueue.events[i].events, 1);
            miEventQueue.events[i].events = NULL;
        }
    }
    free(miEventQueue.events);
}

/* This function will determine if the given event is allowed to used the reserved
 * queue space.
 */
static Bool
mieqReservedCandidate(InternalEvent *e)
{
    switch (e->any.type) {
    case ET_KeyRelease:
    case ET_ButtonRelease:
#if XFreeXDGA
    case ET_DGAEvent:
#endif
    case ET_RawKeyRelease:
    case ET_RawButtonRelease:
    case ET_XQuartz:
        return TRUE;
    default:
        return FALSE;
    }
}

/*
 * Must be reentrant with ProcessInputEvents.  Assumption: mieqEnqueue
 * will never be interrupted.  If this is called from both signal
 * handlers and regular code, make sure the signal is suspended when
 * called from regular code.
 */

void
mieqEnqueue(DeviceIntPtr pDev, InternalEvent *e)
{
    unsigned int oldtail = miEventQueue.tail;
    InternalEvent *evt;
    int isMotion = 0;
    int evlen;
    Time time;
    size_t n_enqueued;

#ifdef XQUARTZ
    wait_for_server_init();
    pthread_mutex_lock(&miEventQueueMutex);
#endif

    verify_internal_event(e);

    n_enqueued = mieqNumEnqueued(&miEventQueue);

    /* avoid merging events from different devices */
    if (e->any.type == ET_Motion)
        isMotion = pDev->id;

    if (isMotion && isMotion == miEventQueue.lastMotion &&
        oldtail != miEventQueue.head) {
        oldtail = (oldtail - 1) % miEventQueue.nevents;
    }
    else if ((n_enqueued + 1 == miEventQueue.nevents) ||
             ((n_enqueued + 1 >= miEventQueue.nevents - QUEUE_RESERVED_SIZE) &&
              !mieqReservedCandidate(e))) {
        /* Toss events which come in late.  Usually this means your server's
         * stuck in an infinite loop somewhere, but SIGIO is still getting
         * handled.
         */
        miEventQueue.dropped++;
        if (miEventQueue.dropped == 1) {
            ErrorFSigSafe("[mi] EQ overflowing.  Additional events will be "
                         "discarded until existing events are processed.\n");
            xorg_backtrace();
            ErrorFSigSafe("[mi] These backtraces from mieqEnqueue may point to "
                         "a culprit higher up the stack.\n");
            ErrorFSigSafe("[mi] mieq is *NOT* the cause.  It is a victim.\n");
        }
        else if (miEventQueue.dropped % QUEUE_DROP_BACKTRACE_FREQUENCY == 0 &&
                 miEventQueue.dropped / QUEUE_DROP_BACKTRACE_FREQUENCY <=
                 QUEUE_DROP_BACKTRACE_MAX) {
            ErrorFSigSafe("[mi] EQ overflow continuing.  %zu events have been "
                         "dropped.\n", miEventQueue.dropped);
            if (miEventQueue.dropped / QUEUE_DROP_BACKTRACE_FREQUENCY ==
                QUEUE_DROP_BACKTRACE_MAX) {
                ErrorFSigSafe("[mi] No further overflow reports will be "
                             "reported until the clog is cleared.\n");
            }
            xorg_backtrace();
        }

#ifdef XQUARTZ
        pthread_mutex_unlock(&miEventQueueMutex);
#endif
        return;
    }

    evlen = e->any.length;
    evt = miEventQueue.events[oldtail].events;
    memcpy(evt, e, evlen);

    time = e->any.time;
    /* Make sure that event times don't go backwards - this
     * is "unnecessary", but very useful. */
    if (time < miEventQueue.lastEventTime &&
        miEventQueue.lastEventTime - time < 10000)
        e->any.time = miEventQueue.lastEventTime;

    miEventQueue.lastEventTime = evt->any.time;
    miEventQueue.events[oldtail].pScreen = pDev ? EnqueueScreen(pDev) : NULL;
    miEventQueue.events[oldtail].pDev = pDev;

    miEventQueue.lastMotion = isMotion;
    miEventQueue.tail = (oldtail + 1) % miEventQueue.nevents;
#ifdef XQUARTZ
    pthread_mutex_unlock(&miEventQueueMutex);
#endif
}

/**
 * Changes the screen reference events are being enqueued from.
 * Input events are enqueued with a screen reference and dequeued and
 * processed with a (potentially different) screen reference.
 * This function is called whenever a new event has changed screen but is
 * still logically on the previous screen as seen by the client.
 * This usually happens whenever the visible cursor moves across screen
 * boundaries during event generation, before the same event is processed
 * and sent down the wire.
 *
 * @@param pDev The device that triggered a screen change.
 * @@param pScreen The new screen events are being enqueued for.
 * @@param set_dequeue_screen If TRUE, pScreen is set as both enqueue screen
 * and dequeue screen.
 */
void
mieqSwitchScreen(DeviceIntPtr pDev, ScreenPtr pScreen, Bool set_dequeue_screen)
{
#ifdef XQUARTZ
    pthread_mutex_lock(&miEventQueueMutex);
#endif
    EnqueueScreen(pDev) = pScreen;
    if (set_dequeue_screen)
        DequeueScreen(pDev) = pScreen;
#ifdef XQUARTZ
    pthread_mutex_unlock(&miEventQueueMutex);
#endif
}

void
mieqSetHandler(int event, mieqHandler handler)
{
#ifdef XQUARTZ
    pthread_mutex_lock(&miEventQueueMutex);
#endif
    if (handler && miEventQueue.handlers[event])
        ErrorF("[mi] mieq: warning: overriding existing handler %p with %p for "
               "event %d\n", miEventQueue.handlers[event], handler, event);

    miEventQueue.handlers[event] = handler;
#ifdef XQUARTZ
    pthread_mutex_unlock(&miEventQueueMutex);
#endif
}

/**
 * Change the device id of the given event to the given device's id.
 */
static void
ChangeDeviceID(DeviceIntPtr dev, InternalEvent *event)
{
    switch (event->any.type) {
    case ET_Motion:
    case ET_KeyPress:
    case ET_KeyRelease:
    case ET_ButtonPress:
    case ET_ButtonRelease:
    case ET_ProximityIn:
    case ET_ProximityOut:
    case ET_Hierarchy:
    case ET_DeviceChanged:
    case ET_TouchBegin:
    case ET_TouchUpdate:
    case ET_TouchEnd:
        event->device_event.deviceid = dev->id;
        break;
    case ET_TouchOwnership:
        event->touch_ownership_event.deviceid = dev->id;
        break;
#if XFreeXDGA
    case ET_DGAEvent:
        break;
#endif
    case ET_RawKeyPress:
    case ET_RawKeyRelease:
    case ET_RawButtonPress:
    case ET_RawButtonRelease:
    case ET_RawMotion:
    case ET_RawTouchBegin:
    case ET_RawTouchEnd:
    case ET_RawTouchUpdate:
        event->raw_event.deviceid = dev->id;
        break;
    case ET_BarrierHit:
    case ET_BarrierLeave:
        event->barrier_event.deviceid = dev->id;
        break;
    default:
        ErrorF("[mi] Unknown event type (%d), cannot change id.\n",
               event->any.type);
    }
}

static void
FixUpEventForMaster(DeviceIntPtr mdev, DeviceIntPtr sdev,
                    InternalEvent *original, InternalEvent *master)
{
    verify_internal_event(original);
    verify_internal_event(master);
    /* Ensure chained button mappings, i.e. that the detail field is the
     * value of the mapped button on the SD, not the physical button */
    if (original->any.type == ET_ButtonPress ||
        original->any.type == ET_ButtonRelease) {
        int btn = original->device_event.detail.button;

        if (!sdev->button)
            return;             /* Should never happen */

        master->device_event.detail.button = sdev->button->map[btn];
    }
}

/**
 * Copy the given event into master.
 * @@param sdev The slave device the original event comes from
 * @@param original The event as it came from the EQ
 * @@param copy The event after being copied
 * @@return The master device or NULL if the device is a floating slave.
 */
DeviceIntPtr
CopyGetMasterEvent(DeviceIntPtr sdev,
                   InternalEvent *original, InternalEvent *copy)
{
    DeviceIntPtr mdev;
    int len = original->any.length;
    int type = original->any.type;
    int mtype;                  /* which master type? */

    verify_internal_event(original);

    /* ET_XQuartz has sdev == NULL */
    if (!sdev || IsMaster(sdev) || IsFloating(sdev))
        return NULL;

#if XFreeXDGA
    if (type == ET_DGAEvent)
        type = original->dga_event.subtype;
#endif

    switch (type) {
    case ET_KeyPress:
    case ET_KeyRelease:
        mtype = MASTER_KEYBOARD;
        break;
    case ET_ButtonPress:
    case ET_ButtonRelease:
    case ET_Motion:
    case ET_ProximityIn:
    case ET_ProximityOut:
        mtype = MASTER_POINTER;
        break;
    default:
        mtype = MASTER_ATTACHED;
        break;
    }

    mdev = GetMaster(sdev, mtype);
    memcpy(copy, original, len);
    ChangeDeviceID(mdev, copy);
    FixUpEventForMaster(mdev, sdev, original, copy);

    return mdev;
}

static void
mieqMoveToNewScreen(DeviceIntPtr dev, ScreenPtr screen, DeviceEvent *event)
{
    if (dev && screen && screen != DequeueScreen(dev)) {
        int x = 0, y = 0;

        DequeueScreen(dev) = screen;
        x = event->root_x;
        y = event->root_y;
        NewCurrentScreen(dev, DequeueScreen(dev), x, y);
    }
}

/**
 * Post the given @@event through the device hierarchy, as appropriate.
 * Use this function if an event must be posted for a given device during the
 * usual event processing cycle.
 */
void
mieqProcessDeviceEvent(DeviceIntPtr dev, InternalEvent *event, ScreenPtr screen)
{
    mieqHandler handler;
    DeviceIntPtr master;
    InternalEvent mevent;       /* master event */

    verify_internal_event(event);

    /* refuse events from disabled devices */
    if (dev && !dev->enabled)
        return;

    /* Custom event handler */
    handler = miEventQueue.handlers[event->any.type];

    switch (event->any.type) {
        /* Catch events that include valuator information and check if they
         * are changing the screen */
    case ET_Motion:
    case ET_KeyPress:
    case ET_KeyRelease:
    case ET_ButtonPress:
    case ET_ButtonRelease:
        if (!handler)
            mieqMoveToNewScreen(dev, screen, &event->device_event);
        break;
    case ET_TouchBegin:
    case ET_TouchUpdate:
    case ET_TouchEnd:
        if (!handler && (event->device_event.flags & TOUCH_POINTER_EMULATED))
            mieqMoveToNewScreen(dev, screen, &event->device_event);
        break;
    default:
        break;
    }
    master = CopyGetMasterEvent(dev, event, &mevent);

    if (master)
        master->lastSlave = dev;

    /* If someone's registered a custom event handler, let them
     * steal it. */
    if (handler) {
        int screenNum = dev &&
            DequeueScreen(dev) ? DequeueScreen(dev)->myNum : (screen ? screen->
                                                              myNum : 0);
        handler(screenNum, event, dev);
        /* Check for the SD's master in case the device got detached
         * during event processing */
        if (master && !IsFloating(dev))
            handler(screenNum, &mevent, master);
    }
    else {
        /* process slave first, then master */
        dev->public.processInputProc(event, dev);

        /* Check for the SD's master in case the device got detached
         * during event processing */
        if (master && !IsFloating(dev))
            master->public.processInputProc(&mevent, master);
    }
}

/* Call this from ProcessInputEvents(). */
void
mieqProcessInputEvents(void)
{
    EventRec *e = NULL;
    ScreenPtr screen;
    InternalEvent event;
    DeviceIntPtr dev = NULL, master = NULL;
    size_t n_enqueued;
    static Bool inProcessInputEvents = FALSE;

#ifdef XQUARTZ
    pthread_mutex_lock(&miEventQueueMutex);
#endif

    /*
     * report an error if mieqProcessInputEvents() is called recursively;
     * this can happen, e.g., if something in the mieqProcessDeviceEvent()
     * call chain calls UpdateCurrentTime() instead of UpdateCurrentTimeIf()
     */
    BUG_WARN_MSG(inProcessInputEvents, "[mi] mieqProcessInputEvents() called recursively.\n");
    inProcessInputEvents = TRUE;

    /* Grow our queue if we are reaching capacity: < 2 * QUEUE_RESERVED_SIZE remaining */
    n_enqueued = mieqNumEnqueued(&miEventQueue);
    if (n_enqueued >= (miEventQueue.nevents - (2 * QUEUE_RESERVED_SIZE)) &&
        miEventQueue.nevents < QUEUE_MAXIMUM_SIZE) {
        ErrorF("[mi] Increasing EQ size to %lu to prevent dropped events.\n",
               (unsigned long) (miEventQueue.nevents << 1));
        if (!mieqGrowQueue(&miEventQueue, miEventQueue.nevents << 1)) {
            ErrorF("[mi] Increasing the size of EQ failed.\n");
        }
    }

    if (miEventQueue.dropped) {
        ErrorF("[mi] EQ processing has resumed after %lu dropped events.\n",
               (unsigned long) miEventQueue.dropped);
        ErrorF
            ("[mi] This may be caused by a misbehaving driver monopolizing the server's resources.\n");
        miEventQueue.dropped = 0;
    }

    while (miEventQueue.head != miEventQueue.tail) {
        e = &miEventQueue.events[miEventQueue.head];

        event = *e->events;
        dev = e->pDev;
        screen = e->pScreen;

        miEventQueue.head = (miEventQueue.head + 1) % miEventQueue.nevents;

#ifdef XQUARTZ
        pthread_mutex_unlock(&miEventQueueMutex);
#endif

        master = (dev) ? GetMaster(dev, MASTER_ATTACHED) : NULL;

        if (screenIsSaved == SCREEN_SAVER_ON)
            dixSaveScreens(serverClient, SCREEN_SAVER_OFF, ScreenSaverReset);
#ifdef DPMSExtension
        else if (DPMSPowerLevel != DPMSModeOn)
            SetScreenSaverTimer();

        if (DPMSPowerLevel != DPMSModeOn)
            DPMSSet(serverClient, DPMSModeOn);
#endif

        mieqProcessDeviceEvent(dev, &event, screen);

        /* Update the sprite now. Next event may be from different device. */
        if (master &&
            (event.any.type == ET_Motion ||
             ((event.any.type == ET_TouchBegin ||
               event.any.type == ET_TouchUpdate) &&
              event.device_event.flags & TOUCH_POINTER_EMULATED)))
            miPointerUpdateSprite(dev);

#ifdef XQUARTZ
        pthread_mutex_lock(&miEventQueueMutex);
#endif
    }

    inProcessInputEvents = FALSE;

#ifdef XQUARTZ
    pthread_mutex_unlock(&miEventQueueMutex);
#endif
}
@


1.15
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@d579 1
a579 1
    static InternalEvent event;
d582 1
d588 8
d654 3
@


1.14
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d602 1
a602 1
            ("[mi] This may be caused my a misbehaving driver monopolizing the server's resources.\n");
@


1.13
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d289 1
a289 1
            ErrorFSigSafe("[mi] EQ overflow continuing.  %u events have been "
d518 4
d592 1
a592 1
               miEventQueue.nevents << 1);
d600 1
a600 1
               miEventQueue.dropped);
@


1.12
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d63 1
a63 1
#define QUEUE_INITIAL_SIZE                 256
@


1.11
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d279 2
a280 2
            ErrorF
                ("[mi] EQ overflowing.  Additional events will be discarded until existing events are processed.\n");
d282 3
a284 3
            ErrorF
                ("[mi] These backtraces from mieqEnqueue may point to a culprit higher up the stack.\n");
            ErrorF("[mi] mieq is *NOT* the cause.  It is a victim.\n");
d289 2
a290 3
            ErrorF
                ("[mi] EQ overflow continuing.  %lu events have been dropped.\n",
                 miEventQueue.dropped);
d293 2
a294 2
                ErrorF
                    ("[mi] No further overflow reports will be reported until the clog is cleared.\n");
d410 4
d630 5
a634 1
        if (event.any.type == ET_Motion && master)
@


1.10
log
@Update to xserver 1.11.2
@
text
@d39 17
a55 17
# include   <X11/X.h>
# include   <X11/Xmd.h>
# include   <X11/Xproto.h>
# include   "misc.h"
# include   "windowstr.h"
# include   "pixmapstr.h"
# include   "inputstr.h"
# include   "inpututils.h"
# include   "mi.h"
# include   "mipointer.h"
# include   "scrnintstr.h"
# include   <X11/extensions/XI.h>
# include   <X11/extensions/XIproto.h>
# include   <X11/extensions/geproto.h>
# include   "extinit.h"
# include   "exglobals.h"
# include   "eventstr.h"
d58 2
a59 2
# include "dpmsproc.h"
# include <X11/extensions/dpmsconst.h>
d62 6
a67 1
#define QUEUE_SIZE  512
d73 3
a75 3
    InternalEvent*  events;
    ScreenPtr	    pScreen;
    DeviceIntPtr    pDev; /* device this event _originated_ from */
d79 7
a85 5
    HWEventQueueType head, tail;         /* long for SetInputCheck */
    CARD32           lastEventTime;      /* to avoid time running backwards */
    int              lastMotion;         /* device ID if last event motion? */
    EventRec         events[QUEUE_SIZE]; /* static allocation for signals */
    mieqHandler      handlers[128];      /* custom event handler */
d98 3
a100 1
static inline void wait_for_server_init(void) {
d102 1
a102 1
    if(!serverRunning) {
d104 1
a104 1
        while(!serverRunning)
d111 77
d191 2
a192 1
    int i;
d194 2
a195 14
    miEventQueue.head = miEventQueue.tail = 0;
    miEventQueue.lastEventTime = GetTimeInMillis ();
    miEventQueue.lastMotion = FALSE;
    for (i = 0; i < 128; i++)
        miEventQueue.handlers[i] = NULL;
    for (i = 0; i < QUEUE_SIZE; i++)
    {
	if (miEventQueue.events[i].events == NULL) {
	    InternalEvent* evlist = InitEventList(1);
	    if (!evlist)
		FatalError("Could not allocate event queue.\n");
	    miEventQueue.events[i].events = evlist;
	}
    }
d205 28
a232 6
    for (i = 0; i < QUEUE_SIZE; i++)
    {
	if (miEventQueue.events[i].events != NULL) {
	    FreeEventList(miEventQueue.events[i].events, 1);
	    miEventQueue.events[i].events = NULL;
	}
d246 6
a251 5
    unsigned int           oldtail = miEventQueue.tail;
    InternalEvent*         evt;
    int                    isMotion = 0;
    int                    evlen;
    Time                   time;
d260 2
d268 1
a268 1
        oldtail = (oldtail - 1) % QUEUE_SIZE;
d270 3
a272 2
    else {
        static int stuck = 0;
d275 21
a295 7
         * handled. */
        if (((oldtail + 1) % QUEUE_SIZE) == miEventQueue.head) {
            if (!stuck) {
                ErrorF("[mi] EQ overflowing. The server is probably stuck "
                        "in an infinite loop.\n");
                xorg_backtrace();
                stuck = 1;
d297 3
d301 1
a301 1
            pthread_mutex_unlock(&miEventQueueMutex);
d303 1
a303 3
	        return;
        }
        stuck = 0;
d322 1
a322 1
    miEventQueue.tail = (oldtail + 1) % QUEUE_SIZE;
d328 15
d344 1
a344 1
mieqSwitchScreen(DeviceIntPtr pDev, ScreenPtr pScreen, Bool fromDIX)
d350 1
a350 1
    if (fromDIX)
d377 1
a377 1
ChangeDeviceID(DeviceIntPtr dev, InternalEvent* event)
d379 18
a396 13
    switch(event->any.type)
    {
        case ET_Motion:
        case ET_KeyPress:
        case ET_KeyRelease:
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_ProximityIn:
        case ET_ProximityOut:
        case ET_Hierarchy:
        case ET_DeviceChanged:
            event->device_event.deviceid = dev->id;
            break;
d398 2
a399 2
        case ET_DGAEvent:
            break;
d401 13
a413 10
        case ET_RawKeyPress:
        case ET_RawKeyRelease:
        case ET_RawButtonPress:
        case ET_RawButtonRelease:
        case ET_RawMotion:
            event->raw_event.deviceid = dev->id;
            break;
        default:
            ErrorF("[mi] Unknown event type (%d), cannot change id.\n",
                   event->any.type);
d419 1
a419 1
                    InternalEvent* original, InternalEvent *master)
d426 1
a426 2
        original->any.type == ET_ButtonRelease)
    {
d428 1
d430 1
a430 1
            return; /* Should never happen */
d445 1
a445 1
                   InternalEvent* original, InternalEvent *copy)
d450 1
a450 1
    int mtype; /* which master type? */
d463 15
a477 16
    switch(type)
    {
        case ET_KeyPress:
        case ET_KeyRelease:
            mtype = MASTER_KEYBOARD;
            break;
        case ET_ButtonPress:
        case ET_ButtonRelease:
        case ET_Motion:
        case ET_ProximityIn:
        case ET_ProximityOut:
            mtype = MASTER_POINTER;
            break;
        default:
            mtype = MASTER_ATTACHED;
            break;
d488 12
d507 1
a507 3
mieqProcessDeviceEvent(DeviceIntPtr dev,
                       InternalEvent *event,
                       ScreenPtr screen)
a509 1
    int x = 0, y = 0;
d511 1
a511 1
    InternalEvent mevent; /* master event */
d521 16
a536 14
        case ET_Motion:
        case ET_KeyPress:
        case ET_KeyRelease:
        case ET_ButtonPress:
        case ET_ButtonRelease:
            if (dev && screen && screen != DequeueScreen(dev) && !handler) {
                DequeueScreen(dev) = screen;
                x = event->device_event.root_x;
                y = event->device_event.root_y;
                NewCurrentScreen (dev, DequeueScreen(dev), x, y);
            }
            break;
        default:
            break;
d545 4
a548 3
    if (handler)
    {
        int screenNum = dev && DequeueScreen(dev) ? DequeueScreen(dev)->myNum : (screen ? screen->myNum : 0);
d554 2
a555 2
    } else
    {
d573 2
a574 2
    DeviceIntPtr dev = NULL,
                 master = NULL;
d579 20
a598 1
    
d603 2
a604 2
        dev     = e->pDev;
        screen  = e->pScreen;
d606 1
a606 1
        miEventQueue.head = (miEventQueue.head + 1) % QUEUE_SIZE;
d615 1
a615 1
            dixSaveScreens (serverClient, SCREEN_SAVER_OFF, ScreenSaverReset);
a637 1

@


1.9
log
@Update to xserver 1.9.5. Tested by jasper@@, ajacoutot@@ and krw@@
@
text
@d46 1
d68 1
a68 1
    EventListPtr    events;
d87 3
a89 3
extern BOOL serverInitComplete;
extern pthread_mutex_t serverInitCompleteMutex;
extern pthread_cond_t serverInitCompleteCond;
d93 5
a97 5
    if(!serverInitComplete) {
        pthread_mutex_lock(&serverInitCompleteMutex);
        while(!serverInitComplete)
            pthread_cond_wait(&serverInitCompleteCond, &serverInitCompleteMutex);
        pthread_mutex_unlock(&serverInitCompleteMutex);
d115 1
a115 1
	    EventListPtr evlist = InitEventList(1);
d150 1
a150 1
    EventListPtr           evt;
d160 1
a160 1
    CHECKEVENT(e);
d192 1
a192 15
    if (evt->evlen < evlen)
    {
        evt->evlen = evlen;
        evt->event = realloc(evt->event, evt->evlen);
        if (!evt->event)
        {
            ErrorF("[mi] Running out of memory. Tossing event.\n");
#ifdef XQUARTZ
            pthread_mutex_unlock(&miEventQueueMutex);
#endif
            return;
        }
    }

    memcpy(evt->event, e, evlen);
d201 1
a201 1
    miEventQueue.lastEventTime = ((InternalEvent*)evt->event)->any.time;
d282 2
a283 2
    CHECKEVENT(original);
    CHECKEVENT(master);
d311 1
d313 1
a313 1
    CHECKEVENT(original);
d316 1
a316 1
    if (!sdev || !sdev->u.master)
d328 1
a328 1
            mdev = GetMaster(sdev, MASTER_KEYBOARD);
d335 1
a335 1
            mdev = GetMaster(sdev, MASTER_POINTER);
d338 1
a338 1
            mdev = sdev->u.master;
d342 1
d366 1
a366 1
    CHECKEVENT(event);
d392 1
a392 1
        master->u.lastSlave = dev;
d402 1
a402 1
        if (master && dev->u.master)
d411 1
a411 1
        if (master && dev->u.master)
a420 1
    int evlen;
d422 1
a422 2
    static InternalEvent *event = NULL;
    static size_t event_size = 0;
d433 1
a433 14
        evlen   = e->events->evlen;
        if(evlen > event_size)
          {
            event = realloc(event, evlen);
            event_size = evlen;
          }


        if (!event)
            FatalError("[mi] No memory left for event processing.\n");

        memcpy(event, e->events->event, evlen);


d443 1
a443 1
        master  = (dev && !IsMaster(dev) && dev->u.master) ? dev->u.master : NULL;
d455 1
a455 1
        mieqProcessDeviceEvent(dev, event, screen);
d458 1
a458 1
        if (event->any.type == ET_Motion && master)
@


1.8
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d323 1
d331 6
a336 1
    switch(original->any.type)
@


1.7
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d194 1
a194 1
        evt->event = xrealloc(evt->event, evt->evlen);
d442 5
a446 1
            event = xrealloc(event, evlen);
@


1.6
log
@Add a configure test for newer proto headers and use it to enable
building xserver 1.6 with those headers. ok oga@@.
@
text
@a38 1
# define NEED_EVENTS
d54 1
d58 1
a58 6
# define DPMS_SERVER
#ifndef HAVE_X11_EXTENSIONS_DPMSCONST_H
#include <X11/extensions/dpms.h>
#else  
#include <X11/extensions/dpmsconst.h>
#endif
a67 1
    int             nevents;
a80 1
static EventListPtr masterEvents; /* for use in mieqProcessInputEvents */
d113 6
a118 4
        EventListPtr evlist = InitEventList(1 + MAX_VALUATOR_EVENTS);
        if (!evlist)
            FatalError("Could not allocate event queue.\n");
        miEventQueue.events[i].events = evlist;
a120 10
    /* XXX: mE is just 1 event long, if we have Motion + Valuator they are
     * squashed into the first event to make passing it into the event
     * processing handlers easier. This should be fixed when the processing
     * handlers switch to EventListPtr instead of xEvent */
    masterEvents = InitEventList(1);
    if (!masterEvents)
        FatalError("Could not allocated MD event queue.\n");
    SetMinimumEventSize(masterEvents, 1,
                        (1 + MAX_VALUATOR_EVENTS) * sizeof(xEvent));

a124 1
/* Ensure all events in the EQ are at least size bytes. */
d126 1
a126 1
mieqResizeEvents(int min_size)
a128 1

d130 6
a135 1
        SetMinimumEventSize(miEventQueue.events[i].events, 7, min_size);
d146 1
a146 1
mieqEnqueue(DeviceIntPtr pDev, xEvent *e)
d152 1
d159 2
d162 1
a162 1
    if (e->u.u.type == MotionNotify)
a163 42
    else if (e->u.u.type == DeviceMotionNotify)
        isMotion = pDev->id | (1 << 8); /* flag to indicate DeviceMotion */

    /* We silently steal valuator events: just tack them on to the last
     * motion event they need to be attached to.  Sigh. */
    if (e->u.u.type == DeviceValuator) {
        deviceValuator         *v = (deviceValuator *) e;
        EventPtr               laste;
        deviceKeyButtonPointer *lastkbp;

        laste = &miEventQueue.events[(oldtail - 1) % QUEUE_SIZE];
        lastkbp = (deviceKeyButtonPointer *) laste->events->event;

        if (laste->nevents > 6) {
#ifdef XQUARTZ
            pthread_mutex_unlock(&miEventQueueMutex);
#endif
            
            ErrorF("[mi] mieqEnqueue: more than six valuator events; dropping.\n");
            return;
        }
        if (oldtail == miEventQueue.head ||
            !(lastkbp->type == DeviceMotionNotify ||
              lastkbp->type == DeviceButtonPress ||
              lastkbp->type == DeviceButtonRelease ||
              lastkbp->type == ProximityIn ||
              lastkbp->type == ProximityOut) ||
            ((lastkbp->deviceid & DEVICE_BITS) !=
             (v->deviceid & DEVICE_BITS))) {
#ifdef XQUARTZ
            pthread_mutex_unlock(&miEventQueueMutex);
#endif
            ErrorF("[mi] mieqEnequeue: out-of-order valuator event; dropping.\n");
            return;
        }

        memcpy((laste->events[laste->nevents++].event), e, sizeof(xEvent));
#ifdef XQUARTZ
        pthread_mutex_unlock(&miEventQueueMutex);
#endif
        return;
    }
d167 1
a167 1
	oldtail = (oldtail - 1) % QUEUE_SIZE;
d170 2
a171 2
	static int stuck = 0;
	/* Toss events which come in late.  Usually this means your server's
d174 7
a180 7
	if (((oldtail + 1) % QUEUE_SIZE) == miEventQueue.head) {
            ErrorF("[mi] EQ overflowing. The server is probably stuck "
                   "in an infinite loop.\n");
	    if (!stuck) {
		xorg_backtrace();
		stuck = 1;
	    }
d182 1
a182 1
	    pthread_mutex_unlock(&miEventQueueMutex);
d184 1
a184 1
	    return;
d186 1
a186 1
	stuck = 0;
d189 1
a189 4
    evlen = sizeof(xEvent);
    if (e->u.u.type == GenericEvent)
        evlen += ((xGenericEvent*)e)->length * 4;

a205 1
    miEventQueue.events[oldtail].nevents = 1;
d207 1
d210 3
a212 4
    if (e->u.u.type != GenericEvent &&
        e->u.keyButtonPointer.time < miEventQueue.lastEventTime &&
            miEventQueue.lastEventTime - e->u.keyButtonPointer.time < 10000)
        evt->event->u.keyButtonPointer.time = miEventQueue.lastEventTime;
d214 2
a215 2
    miEventQueue.lastEventTime = evt->event->u.keyButtonPointer.time;
    miEventQueue.events[oldtail].pScreen = EnqueueScreen(pDev);
d233 1
a233 1
	DequeueScreen(pDev) = pScreen;
d259 1
a259 1
ChangeDeviceID(DeviceIntPtr dev, xEvent* event)
d261 1
a261 10
    int type = event->u.u.type;

    if (type == DeviceKeyPress || type == DeviceKeyRelease ||
            type == DeviceButtonPress || type == DeviceButtonRelease ||
            type == DeviceMotionNotify || type == ProximityIn ||
            type == ProximityOut)
        ((deviceKeyButtonPointer*)event)->deviceid = dev->id;
    else if (type == DeviceValuator)
        ((deviceValuator*)event)->deviceid = dev->id;
    else if (type == GenericEvent)
d263 26
a288 5
        DebugF("[mi] Unknown generic event (%d/%d), cannot change id.\n",
                ((xGenericEvent*)event)->extension,
                ((xGenericEvent*)event)->evtype);
    } else
        DebugF("[mi] Unknown event type (%d), cannot change id.\n", type);
d292 2
a293 2
FixUpEventForMaster(DeviceIntPtr mdev, DeviceIntPtr sdev, xEvent* original,
                    EventListPtr master, int count)
d295 2
d299 2
a300 1
    if (original->u.u.type == DeviceButtonPress || original->u.u.type == DeviceButtonRelease)
d302 1
a302 1
        int btn = original->u.u.detail;
d306 1
a306 1
        master->event->u.u.detail = sdev->button->map[btn];
a311 1
 * @@param mdev The master device
d314 46
a359 2
 * @@param master The event after being copied
 * @@param count Number of events in original.
d362 3
a364 2
CopyGetMasterEvent(DeviceIntPtr mdev, DeviceIntPtr sdev, xEvent* original,
                   EventListPtr master, int count)
d366 6
a371 1
    int len = count * sizeof(xEvent);
d373 2
a374 1
    /* Assumption: GenericEvents always have count 1 */
d376 19
a394 2
    if (GEV(original)->type == GenericEvent)
        len += GEV(original)->length * 4;
d396 2
a397 2
    if (master->evlen < len)
        SetMinimumEventSize(master, 1, len);
d399 3
a401 2
    memcpy(master->event, original, len);
    while (count--)
d403 15
a417 2
        ChangeDeviceID(mdev, &master->event[count]);
        FixUpEventForMaster(mdev, sdev, original, master, count);
a419 4
extern void
CopyKeyClass(DeviceIntPtr device, DeviceIntPtr master);


a424 1
    mieqHandler handler;
d426 1
a426 2
    int x = 0, y = 0;
    int type, nevents, evlen, i;
d428 1
a428 1
    static xEvent *event = NULL;
d440 3
a442 7
        /* GenericEvents always have nevents == 1 */
        nevents = e->nevents;
        evlen   = (nevents > 1) ? sizeof(xEvent) : e->events->evlen;
        if((nevents * evlen) > event_size) {
            event_size = nevents * evlen;
            event = (xEvent *)xrealloc(event, event_size);
        }
d447 1
a447 2
        for (i = 0; i < nevents; i++)
            memcpy(&event[i], e->events[i].event, evlen);
d458 2
a459 3
        
        type    = event->u.u.type;
        master  = (!dev->isMaster && dev->u.master) ? dev->u.master : NULL;
d471 1
a471 43
        /* Custom event handler */
        handler = miEventQueue.handlers[type];

        if (screen != DequeueScreen(dev) && !handler) {
            /* Assumption - screen switching can only occur on motion events. */
            DequeueScreen(dev) = screen;
            x = event->u.keyButtonPointer.rootX;
            y = event->u.keyButtonPointer.rootY;
            NewCurrentScreen (dev, DequeueScreen(dev), x, y);
        }
        else {
            if (master && dev->coreEvents) {
                /* Force a copy of the key class into the VCK so that the layout
                   is transferred. */
                if (event->u.u.type == DeviceKeyPress ||
                    event->u.u.type == DeviceKeyRelease)
                {
                    if (!master->key)
                        master = GetPairedDevice(master);
		    CopyKeyClass(dev, master);
                }

                CopyGetMasterEvent(master, dev, event, masterEvents, nevents);
            }

            /* If someone's registered a custom event handler, let them
             * steal it. */
            if (handler)
            {
                handler(DequeueScreen(dev)->myNum, event, dev, nevents);
                if (master)
                    handler(DequeueScreen(master)->myNum,
                            masterEvents->event, master, nevents);
            } else
            {
                /* process slave first, then master */
                dev->public.processInputProc(event, dev, nevents);

                if (master && dev->coreEvents)
                    master->public.processInputProc(masterEvents->event, master,
                                                    nevents);
            }
        }
d474 1
a474 1
        if (type == DeviceMotionNotify && dev->coreEvents)
@


1.5
log
@Update to server 1.6.5.
@
text
@d59 5
a63 1
# include <X11/extensions/dpms.h>
@


1.4
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d449 1
a449 1
            if (master) {
d476 1
a476 1
                if (master)
@


1.3
log
@Update to xserver 1.5.3 + latests commits on server-1.5-branch.
tested by stsp@@, david@@, form@@, ckuethe@@, oga@@. thanks.
@
text
@d52 1
d64 3
d68 1
a68 1
    xEvent          event[7];
a78 2
    ScreenPtr        pEnqueueScreen;     /* screen events are being delivered to */
    ScreenPtr        pDequeueScreen;     /* screen events are being dispatched to */
d83 20
a111 2
    miEventQueue.pEnqueueScreen = screenInfo.screens[0];
    miEventQueue.pDequeueScreen = miEventQueue.pEnqueueScreen;
d114 18
d136 10
d156 2
a157 1
    unsigned int           oldtail = miEventQueue.tail, newtail;
d159 6
a164 5
    deviceValuator         *v = (deviceValuator *) e;
    EventPtr               laste = &miEventQueue.events[(oldtail - 1) %
							QUEUE_SIZE];
    deviceKeyButtonPointer *lastkbp = (deviceKeyButtonPointer *)
                                      &laste->event[0];
d166 1
d168 1
a168 1
        isMotion = inputInfo.pointer->id;
d170 1
a170 1
        isMotion = pDev->id;
d175 7
d183 4
d198 3
d204 5
a208 1
        memcpy(&(laste->event[laste->nevents++]), e, sizeof(xEvent));
a217 1
	newtail = (oldtail + 1) % QUEUE_SIZE;
d221 1
a221 1
	if (newtail == miEventQueue.head) {
d228 3
a233 1
	miEventQueue.tail = newtail;
d236 20
a255 1
    memcpy(&(miEventQueue.events[oldtail].event[0]), e, sizeof(xEvent));
d260 7
a266 8
    if (e->u.keyButtonPointer.time < miEventQueue.lastEventTime &&
	miEventQueue.lastEventTime - e->u.keyButtonPointer.time < 10000)
	miEventQueue.events[oldtail].event[0].u.keyButtonPointer.time =
	    miEventQueue.lastEventTime;

    miEventQueue.lastEventTime =
	miEventQueue.events[oldtail].event[0].u.keyButtonPointer.time;
    miEventQueue.events[oldtail].pScreen = miEventQueue.pEnqueueScreen;
d270 4
d277 1
a277 1
mieqSwitchScreen(ScreenPtr pScreen, Bool fromDIX)
d279 4
a282 1
    miEventQueue.pEnqueueScreen = pScreen;
d284 4
a287 1
	miEventQueue.pDequeueScreen = pScreen;
d293 3
d297 1
a297 1
        ErrorF("mieq: warning: overriding existing handler %p with %p for "
d301 43
d346 34
d384 1
d387 6
a392 1
    DeviceIntPtr dev = NULL;
d394 4
d399 29
d438 2
a439 3
        e = &miEventQueue.events[miEventQueue.head];
        /* Assumption - screen switching can only occur on motion events. */
        miEventQueue.head = (miEventQueue.head + 1) % QUEUE_SIZE;
d441 6
a446 5
        if (e->pScreen != miEventQueue.pDequeueScreen) {
            miEventQueue.pDequeueScreen = e->pScreen;
            x = e->event[0].u.keyButtonPointer.rootX;
            y = e->event[0].u.keyButtonPointer.rootY;
            NewCurrentScreen (miEventQueue.pDequeueScreen, x, y);
d449 14
d465 14
a478 5
            if (miEventQueue.handlers[e->event->u.u.type]) {
                miEventQueue.handlers[e->event->u.u.type](miEventQueue.pDequeueScreen->myNum,
                                                          e->event, dev,
                                                          e->nevents);
                return;
d480 1
d482 3
a484 16
            /* If this is a core event, make sure our keymap, et al, is
             * changed to suit. */
            if (e->event[0].u.u.type == KeyPress ||
                e->event[0].u.u.type == KeyRelease) {
                SwitchCoreKeyboard(e->pDev);
                dev = inputInfo.keyboard;
            }
            else if (e->event[0].u.u.type == MotionNotify ||
                     e->event[0].u.u.type == ButtonPress ||
                     e->event[0].u.u.type == ButtonRelease) {
                SwitchCorePointer(e->pDev);
                dev = inputInfo.pointer;
            }
            else {
                dev = e->pDev;
            }
d486 3
a488 2
            dev->public.processInputProc(e->event, dev, e->nevents);
        }
d490 3
d494 1
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d148 1
d156 4
d162 1
@


1.1
log
@Initial revision
@
text
@d48 1
d50 10
d61 1
a61 1
#define QUEUE_SIZE  256
d64 4
a67 2
    xEvent	event;
    ScreenPtr	pScreen;
d71 7
a77 7
    HWEventQueueType	head, tail;	    /* long for SetInputCheck */
    CARD32	lastEventTime;	    /* to avoid time running backwards */
    Bool	lastMotion;
    EventRec	events[QUEUE_SIZE]; /* static allocation for signals */
    DevicePtr	pKbd, pPtr;	    /* device pointer, to get funcs */
    ScreenPtr	pEnqueueScreen;	    /* screen events are being delivered to */
    ScreenPtr	pDequeueScreen;	    /* screen events are being dispatched to */
d83 1
a83 2
mieqInit (pKbd, pPtr)
    DevicePtr	pKbd, pPtr;
d85 2
a88 2
    miEventQueue.pKbd = pKbd;
    miEventQueue.pPtr = pPtr;
d92 3
a94 1
    SetInputCheck (&miEventQueue.head, &miEventQueue.tail);
d106 1
a106 2
mieqEnqueue (e)
    xEvent	*e;
d108 34
a141 2
    HWEventQueueType	oldtail, newtail;
    Bool    isMotion;
d143 3
a145 7
    oldtail = miEventQueue.tail;
    isMotion = e->u.u.type == MotionNotify;
    if (isMotion && miEventQueue.lastMotion && oldtail != miEventQueue.head)
    {
	if (oldtail == 0)
	    oldtail = QUEUE_SIZE;
	oldtail = oldtail - 1;
d147 8
a154 7
    else
    {
    	newtail = oldtail + 1;
    	if (newtail == QUEUE_SIZE)
	    newtail = 0;
    	/* Toss events which come in late */
    	if (newtail == miEventQueue.head)
d156 1
d159 6
a164 6
    miEventQueue.lastMotion = isMotion;
    miEventQueue.events[oldtail].event = *e;
    /*
     * Make sure that event times don't go backwards - this
     * is "unnecessary", but very useful
     */
d167 1
a167 2
    {
	miEventQueue.events[oldtail].event.u.keyButtonPointer.time =
d169 1
a169 1
    }
d171 1
a171 1
	miEventQueue.events[oldtail].event.u.keyButtonPointer.time;
d173 3
d179 1
a179 3
mieqSwitchScreen (pScreen, fromDIX)
    ScreenPtr	pScreen;
    Bool	fromDIX;
d186 9
a194 3
/*
 * Call this from ProcessInputEvents()
 */
d196 3
a198 1
void mieqProcessInputEvents ()
d200 54
a253 44
    EventRec	*e;
    int		x, y;
    xEvent	xe;

    while (miEventQueue.head != miEventQueue.tail)
    {
	if (screenIsSaved == SCREEN_SAVER_ON)
	    SaveScreens (SCREEN_SAVER_OFF, ScreenSaverReset);

	e = &miEventQueue.events[miEventQueue.head];
	/*
	 * Assumption - screen switching can only occur on motion events
	 */
	if (e->pScreen != miEventQueue.pDequeueScreen)
	{
	    miEventQueue.pDequeueScreen = e->pScreen;
	    x = e->event.u.keyButtonPointer.rootX;
	    y = e->event.u.keyButtonPointer.rootY;
	    if (miEventQueue.head == QUEUE_SIZE - 1)
	    	miEventQueue.head = 0;
	    else
	    	++miEventQueue.head;
	    NewCurrentScreen (miEventQueue.pDequeueScreen, x, y);
	}
	else
	{
	    xe = e->event;
	    if (miEventQueue.head == QUEUE_SIZE - 1)
	    	miEventQueue.head = 0;
	    else
	    	++miEventQueue.head;
	    switch (xe.u.u.type) 
	    {
	    case KeyPress:
	    case KeyRelease:
	    	(*miEventQueue.pKbd->processInputProc)
				(&xe, (DeviceIntPtr)miEventQueue.pKbd, 1);
	    	break;
	    default:
	    	(*miEventQueue.pPtr->processInputProc)
				(&xe, (DeviceIntPtr)miEventQueue.pPtr, 1);
	    	break;
	    }
	}
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a47 1
# include   "mipointer.h"
a48 10
# include   <X11/extensions/XI.h>
# include   <X11/extensions/XIproto.h>
# include   "extinit.h"
# include   "exglobals.h"

#ifdef DPMSExtension
# include "dpmsproc.h"
# define DPMS_SERVER
# include <X11/extensions/dpms.h>
#endif
d50 1
a50 1
#define QUEUE_SIZE  512
d53 2
a54 4
    xEvent          event[7];
    int             nevents;
    ScreenPtr	    pScreen;
    DeviceIntPtr    pDev; /* device this event _originated_ from */
d58 7
a64 7
    HWEventQueueType head, tail;         /* long for SetInputCheck */
    CARD32           lastEventTime;      /* to avoid time running backwards */
    int              lastMotion;         /* device ID if last event motion? */
    EventRec         events[QUEUE_SIZE]; /* static allocation for signals */
    ScreenPtr        pEnqueueScreen;     /* screen events are being delivered to */
    ScreenPtr        pDequeueScreen;     /* screen events are being dispatched to */
    mieqHandler      handlers[128];      /* custom event handler */
d70 2
a71 1
mieqInit(void)
a72 2
    int i;

d75 2
d80 1
a80 3
    for (i = 0; i < 128; i++)
        miEventQueue.handlers[i] = NULL;
    SetInputCheck(&miEventQueue.head, &miEventQueue.tail);
d92 2
a93 1
mieqEnqueue(DeviceIntPtr pDev, xEvent *e)
d95 2
a96 32
    unsigned int           oldtail = miEventQueue.tail, newtail;
    int                    isMotion = 0;
    deviceValuator         *v = (deviceValuator *) e;
    EventPtr               laste = &miEventQueue.events[(oldtail - 1) %
							QUEUE_SIZE];
    deviceKeyButtonPointer *lastkbp = (deviceKeyButtonPointer *)
                                      &laste->event[0];

    if (e->u.u.type == MotionNotify)
        isMotion = inputInfo.pointer->id;
    else if (e->u.u.type == DeviceMotionNotify)
        isMotion = pDev->id;

    /* We silently steal valuator events: just tack them on to the last
     * motion event they need to be attached to.  Sigh. */
    if (e->u.u.type == DeviceValuator) {
        if (laste->nevents > 6) {
            ErrorF("mieqEnqueue: more than six valuator events; dropping.\n");
            return;
        }
        if (oldtail == miEventQueue.head ||
            !(lastkbp->type == DeviceMotionNotify ||
              lastkbp->type == DeviceButtonPress ||
              lastkbp->type == DeviceButtonRelease) ||
            ((lastkbp->deviceid & DEVICE_BITS) !=
             (v->deviceid & DEVICE_BITS))) {
            ErrorF("mieqEnequeue: out-of-order valuator event; dropping.\n");
            return;
        }
        memcpy(&(laste->event[laste->nevents++]), e, sizeof(xEvent));
        return;
    }
d98 7
a104 3
    if (isMotion && isMotion == miEventQueue.lastMotion &&
        oldtail != miEventQueue.head) {
	oldtail = (oldtail - 1) % QUEUE_SIZE;
d106 7
a112 7
    else {
    	newtail = (oldtail + 1) % QUEUE_SIZE;
    	/* Toss events which come in late.  Usually this means your server's
         * stuck in an infinite loop somewhere, but SIGIO is still getting
         * handled. */
    	if (newtail == miEventQueue.head) {
            ErrorF("tossed event which came in late\n");
a113 1
        }
d116 6
a121 6

    memcpy(&(miEventQueue.events[oldtail].event[0]), e, sizeof(xEvent));
    miEventQueue.events[oldtail].nevents = 1;

    /* Make sure that event times don't go backwards - this
     * is "unnecessary", but very useful. */
d124 2
a125 1
	miEventQueue.events[oldtail].event[0].u.keyButtonPointer.time =
d127 1
a127 1

d129 1
a129 1
	miEventQueue.events[oldtail].event[0].u.keyButtonPointer.time;
a130 3
    miEventQueue.events[oldtail].pDev = pDev;

    miEventQueue.lastMotion = isMotion;
d134 3
a136 1
mieqSwitchScreen(ScreenPtr pScreen, Bool fromDIX)
d143 3
a145 6
void
mieqSetHandler(int event, mieqHandler handler)
{
    if (handler && miEventQueue.handlers[event])
        ErrorF("mieq: warning: overriding existing handler %p with %p for "
               "event %d\n", miEventQueue.handlers[event], handler, event);
d147 1
a147 6
    miEventQueue.handlers[event] = handler;
}

/* Call this from ProcessInputEvents(). */
void
mieqProcessInputEvents(void)
d149 44
a192 54
    EventRec *e = NULL;
    int x = 0, y = 0;
    DeviceIntPtr dev = NULL;

    while (miEventQueue.head != miEventQueue.tail) {
        if (screenIsSaved == SCREEN_SAVER_ON)
            SaveScreens (SCREEN_SAVER_OFF, ScreenSaverReset);
#ifdef DPMSExtension
        else if (DPMSPowerLevel != DPMSModeOn)
            SetScreenSaverTimer();

        if (DPMSPowerLevel != DPMSModeOn)
            DPMSSet(DPMSModeOn);
#endif

        e = &miEventQueue.events[miEventQueue.head];
        /* Assumption - screen switching can only occur on motion events. */
        miEventQueue.head = (miEventQueue.head + 1) % QUEUE_SIZE;

        if (e->pScreen != miEventQueue.pDequeueScreen) {
            miEventQueue.pDequeueScreen = e->pScreen;
            x = e->event[0].u.keyButtonPointer.rootX;
            y = e->event[0].u.keyButtonPointer.rootY;
            NewCurrentScreen (miEventQueue.pDequeueScreen, x, y);
        }
        else {
            /* If someone's registered a custom event handler, let them
             * steal it. */
            if (miEventQueue.handlers[e->event->u.u.type]) {
                miEventQueue.handlers[e->event->u.u.type](miEventQueue.pDequeueScreen->myNum,
                                                          e->event, dev,
                                                          e->nevents);
                return;
            }

            /* If this is a core event, make sure our keymap, et al, is
             * changed to suit. */
            if (e->event[0].u.u.type == KeyPress ||
                e->event[0].u.u.type == KeyRelease) {
                SwitchCoreKeyboard(e->pDev);
                dev = inputInfo.keyboard;
            }
            else if (e->event[0].u.u.type == MotionNotify ||
                     e->event[0].u.u.type == ButtonPress ||
                     e->event[0].u.u.type == ButtonRelease) {
                SwitchCorePointer(e->pDev);
                dev = inputInfo.pointer;
            }
            else {
                dev = e->pDev;
            }

            dev->public.processInputProc(e->event, dev, e->nevents);
        }
@


1.1.1.3
log
@xserver 1.4.0.90
@
text
@d131 1
a131 3
              lastkbp->type == DeviceButtonRelease ||
              lastkbp->type == ProximityIn ||
              lastkbp->type == ProximityOut) ||
@


