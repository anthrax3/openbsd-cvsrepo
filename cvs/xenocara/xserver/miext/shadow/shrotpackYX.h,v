head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.18
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.16
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.14
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.12
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.8
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.2
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.2.0.14
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.10
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.06;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.06;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.04;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@/*
 * Copyright Â© 2004 Philip Blundell
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Philip Blundell not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Philip Blundell makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * PHILIP BLUNDELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL PHILIP BLUNDELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    "dixfontstr.h"
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "shadow.h"
#include    "fb.h"

#if ROTATE == 270

#define WINSTEPX(stride)    (stride)
#define WINSTART(x,y)       (((pScreen->height - 1) - y) + (x * winStride))
#define WINSTEPY()	    -1

#elif ROTATE == 90

#define WINSTEPX(stride)    (-stride)
#define WINSTEPY()	    1
#define WINSTART(x,y)       (((pScreen->width - 1 - x) * winStride) + y)

#else

#error This rotation is not supported here

#endif

#ifdef __arm__
#define PREFETCH
#endif

void
FUNC(ScreenPtr pScreen, shadowBufPtr pBuf)
{
    RegionPtr damage = shadowDamage(pBuf);
    PixmapPtr pShadow = pBuf->pPixmap;
    int nbox = RegionNumRects(damage);
    BoxPtr pbox = RegionRects(damage);
    FbBits *shaBits;
    Data *shaBase, *shaLine, *sha;
    FbStride shaStride, winStride;
    int shaBpp;
    _X_UNUSED int shaXoff, shaYoff;
    int x, y, w, h;
    Data *winBase, *win, *winLine;
    CARD32 winSize;

    fbGetDrawable(&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff,
                  shaYoff);
    shaBase = (Data *) shaBits;
    shaStride = shaStride * sizeof(FbBits) / sizeof(Data);

    winBase = (Data *) (*pBuf->window) (pScreen, 0, 0,
                                        SHADOW_WINDOW_WRITE,
                                        &winSize, pBuf->closure);
    winStride = (Data *) (*pBuf->window) (pScreen, 1, 0,
                                          SHADOW_WINDOW_WRITE,
                                          &winSize, pBuf->closure) - winBase;

    while (nbox--) {
        x = pbox->x1;
        y = pbox->y1;
        w = (pbox->x2 - pbox->x1);
        h = pbox->y2 - pbox->y1;

        shaLine = shaBase + (y * shaStride) + x;
#ifdef PREFETCH
        __builtin_prefetch(shaLine);
#endif
        winLine = winBase + WINSTART(x, y);

        while (h--) {
            sha = shaLine;
            win = winLine;

            while (sha < (shaLine + w - 16)) {
#ifdef PREFETCH
                __builtin_prefetch(sha + shaStride);
#endif
                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);

                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);

                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);

                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);
                *win = *sha++;
                win += WINSTEPX(winStride);
            }

            while (sha < (shaLine + w)) {
                *win = *sha++;
                win += WINSTEPX(winStride);
            }

            y++;
            shaLine += shaStride;
            winLine += WINSTEPY();
        }
        pbox++;
    }                           /*  nbox */
}
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a56 3
 FUNC(ScreenPtr pScreen, shadowBufPtr pBuf);

void
@


1.3
log
@Update to xserver 1.11.2
@
text
@d57 1
a57 2
FUNC (ScreenPtr	    pScreen,
      shadowBufPtr  pBuf);
d60 1
a60 2
FUNC (ScreenPtr	    pScreen,
      shadowBufPtr  pBuf)
d62 12
a73 12
    RegionPtr	damage = shadowDamage(pBuf);
    PixmapPtr	pShadow = pBuf->pPixmap;
    int		nbox = RegionNumRects (damage);
    BoxPtr	pbox = RegionRects (damage);
    FbBits	*shaBits;
    Data	*shaBase, *shaLine, *sha;
    FbStride	shaStride, winStride;
    int		shaBpp;
    _X_UNUSED int	shaXoff, shaYoff;
    int		x, y, w, h;
    Data	*winBase, *win, *winLine;
    CARD32	winSize;
d75 2
a76 1
    fbGetDrawable (&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff, shaYoff);
d78 1
a78 1
    shaStride = shaStride * sizeof (FbBits) / sizeof (Data);
d81 2
a82 2
					SHADOW_WINDOW_WRITE,
					&winSize, pBuf->closure);
d84 2
a85 2
					  SHADOW_WINDOW_WRITE,
					  &winSize, pBuf->closure) - winBase;
d87 1
a87 2
    while (nbox--)
    {
d93 1
a93 1
	shaLine = shaBase + (y * shaStride) + x;
d95 1
a95 1
	__builtin_prefetch (shaLine);
d97 1
a97 1
	winLine = winBase + WINSTART(x, y);
d99 3
a101 4
        while (h--)
        {
	    sha = shaLine;
	    win = winLine;
d103 1
a103 2
            while (sha < (shaLine + w - 16))
            {
d105 1
a105 1
		__builtin_prefetch (sha + shaStride);
d107 35
a141 35
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);

		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);

		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);

		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
		*win = *sha++;
		win += WINSTEPX(winStride);
d144 3
a146 4
            while (sha < (shaLine + w))
            {
		*win = *sha++;
		win += WINSTEPX(winStride);
d149 3
a151 3
	    y++;
	    shaLine += shaStride;
	    winLine += WINSTEPY();
d154 1
a154 1
    } /*  nbox */
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d72 1
a72 1
    int		shaXoff, shaYoff;   /* XXX assumed to be zero */
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d66 2
a67 2
    int		nbox = REGION_NUM_RECTS (damage);
    BoxPtr	pbox = REGION_RECTS (damage);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
@

