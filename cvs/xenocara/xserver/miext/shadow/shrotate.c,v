head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.4
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.14
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.12
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.10
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.8
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.2
	OPENBSD_5_0:1.2.0.4
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.2
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	Te1daavkBLskZ8gc;

1.4
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.07;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.07;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@/*
 *
 * Copyright Â© 2001 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    <X11/fonts/font.h>
#include    "dixfontstr.h"
#include    <X11/fonts/fontstruct.h>
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "shadow.h"
#include    "fb.h"

/*
 * These indicate which way the source (shadow) is scanned when
 * walking the screen in a particular direction
 */

#define LEFT_TO_RIGHT	1
#define RIGHT_TO_LEFT	-1
#define TOP_TO_BOTTOM	2
#define BOTTOM_TO_TOP	-2

void
shadowUpdateRotatePacked(ScreenPtr pScreen, shadowBufPtr pBuf)
{
    RegionPtr damage = shadowDamage(pBuf);
    PixmapPtr pShadow = pBuf->pPixmap;
    int nbox = RegionNumRects(damage);
    BoxPtr pbox = RegionRects(damage);
    FbBits *shaBits;
    FbStride shaStride;
    int shaBpp;
    _X_UNUSED int shaXoff, shaYoff;
    int box_x1, box_x2, box_y1, box_y2;
    int sha_x1 = 0, sha_y1 = 0;
    int scr_x1 = 0, scr_x2 = 0, scr_y1 = 0, scr_y2 = 0, scr_w, scr_h;
    int scr_x, scr_y;
    int w;
    int pixelsPerBits;
    int pixelsMask;
    FbStride shaStepOverY = 0, shaStepDownY = 0;
    FbStride shaStepOverX = 0, shaStepDownX = 0;
    FbBits *shaLine, *sha;
    int shaHeight = pShadow->drawable.height;
    int shaWidth = pShadow->drawable.width;
    FbBits shaMask;
    int shaFirstShift, shaShift;
    int o_x_dir;
    int o_y_dir;
    int x_dir;
    int y_dir;

    fbGetDrawable(&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff,
                  shaYoff);
    pixelsPerBits = (sizeof(FbBits) * 8) / shaBpp;
    pixelsMask = ~(pixelsPerBits - 1);
    shaMask = FbBitsMask(FB_UNIT - shaBpp, shaBpp);
    /*
     * Compute rotation related constants to walk the shadow
     */
    o_x_dir = LEFT_TO_RIGHT;
    o_y_dir = TOP_TO_BOTTOM;
    if (pBuf->randr & SHADOW_REFLECT_X)
        o_x_dir = -o_x_dir;
    if (pBuf->randr & SHADOW_REFLECT_Y)
        o_y_dir = -o_y_dir;
    switch (pBuf->randr & (SHADOW_ROTATE_ALL)) {
    case SHADOW_ROTATE_0:      /* upper left shadow -> upper left screen */
    default:
        x_dir = o_x_dir;
        y_dir = o_y_dir;
        break;
    case SHADOW_ROTATE_90:     /* upper right shadow -> upper left screen */
        x_dir = o_y_dir;
        y_dir = -o_x_dir;
        break;
    case SHADOW_ROTATE_180:    /* lower right shadow -> upper left screen */
        x_dir = -o_x_dir;
        y_dir = -o_y_dir;
        break;
    case SHADOW_ROTATE_270:    /* lower left shadow -> upper left screen */
        x_dir = -o_y_dir;
        y_dir = o_x_dir;
        break;
    }
    switch (x_dir) {
    case LEFT_TO_RIGHT:
        shaStepOverX = shaBpp;
        shaStepOverY = 0;
        break;
    case TOP_TO_BOTTOM:
        shaStepOverX = 0;
        shaStepOverY = shaStride;
        break;
    case RIGHT_TO_LEFT:
        shaStepOverX = -shaBpp;
        shaStepOverY = 0;
        break;
    case BOTTOM_TO_TOP:
        shaStepOverX = 0;
        shaStepOverY = -shaStride;
        break;
    }
    switch (y_dir) {
    case TOP_TO_BOTTOM:
        shaStepDownX = 0;
        shaStepDownY = shaStride;
        break;
    case RIGHT_TO_LEFT:
        shaStepDownX = -shaBpp;
        shaStepDownY = 0;
        break;
    case BOTTOM_TO_TOP:
        shaStepDownX = 0;
        shaStepDownY = -shaStride;
        break;
    case LEFT_TO_RIGHT:
        shaStepDownX = shaBpp;
        shaStepDownY = 0;
        break;
    }

    while (nbox--) {
        box_x1 = pbox->x1;
        box_y1 = pbox->y1;
        box_x2 = pbox->x2;
        box_y2 = pbox->y2;
        pbox++;

        /*
         * Compute screen and shadow locations for this box
         */
        switch (x_dir) {
        case LEFT_TO_RIGHT:
            scr_x1 = box_x1 & pixelsMask;
            scr_x2 = (box_x2 + pixelsPerBits - 1) & pixelsMask;

            sha_x1 = scr_x1;
            break;
        case TOP_TO_BOTTOM:
            scr_x1 = box_y1 & pixelsMask;
            scr_x2 = (box_y2 + pixelsPerBits - 1) & pixelsMask;

            sha_y1 = scr_x1;
            break;
        case RIGHT_TO_LEFT:
            scr_x1 = (shaWidth - box_x2) & pixelsMask;
            scr_x2 = (shaWidth - box_x1 + pixelsPerBits - 1) & pixelsMask;

            sha_x1 = (shaWidth - scr_x1 - 1);
            break;
        case BOTTOM_TO_TOP:
            scr_x1 = (shaHeight - box_y2) & pixelsMask;
            scr_x2 = (shaHeight - box_y1 + pixelsPerBits - 1) & pixelsMask;

            sha_y1 = (shaHeight - scr_x1 - 1);
            break;
        }
        switch (y_dir) {
        case TOP_TO_BOTTOM:
            scr_y1 = box_y1;
            scr_y2 = box_y2;

            sha_y1 = scr_y1;
            break;
        case RIGHT_TO_LEFT:
            scr_y1 = (shaWidth - box_x2);
            scr_y2 = (shaWidth - box_x1);

            sha_x1 = box_x2 - 1;
            break;
        case BOTTOM_TO_TOP:
            scr_y1 = shaHeight - box_y2;
            scr_y2 = shaHeight - box_y1;

            sha_y1 = box_y2 - 1;
            break;
        case LEFT_TO_RIGHT:
            scr_y1 = box_x1;
            scr_y2 = box_x2;

            sha_x1 = box_x1;
            break;
        }
        scr_w = ((scr_x2 - scr_x1) * shaBpp) >> FB_SHIFT;
        scr_h = scr_y2 - scr_y1;
        scr_y = scr_y1;

        /* shift amount for first pixel on screen */
        shaFirstShift = FB_UNIT - ((sha_x1 * shaBpp) & FB_MASK) - shaBpp;

        /* pointer to shadow data first placed on screen */
        shaLine = (shaBits +
                   sha_y1 * shaStride + ((sha_x1 * shaBpp) >> FB_SHIFT));

        /*
         * Copy the bits, always write across the physical frame buffer
         * to take advantage of write combining.
         */
        while (scr_h--) {
            int p;
            FbBits bits;
            FbBits *win;
            int i;
            CARD32 winSize;

            sha = shaLine;
            shaShift = shaFirstShift;
            w = scr_w;
            scr_x = scr_x1 * shaBpp >> FB_SHIFT;

            while (w) {
                /*
                 * Map some of this line
                 */
                win = (FbBits *) (*pBuf->window) (pScreen,
                                                  scr_y,
                                                  scr_x << 2,
                                                  SHADOW_WINDOW_WRITE,
                                                  &winSize, pBuf->closure);
                i = (winSize >> 2);
                if (i > w)
                    i = w;
                w -= i;
                scr_x += i;
                /*
                 * Copy the portion of the line mapped
                 */
                while (i--) {
                    bits = 0;
                    p = pixelsPerBits;
                    /*
                     * Build one word of output from multiple inputs
                     *
                     * Note that for 90/270 rotations, this will walk
                     * down the shadow hitting each scanline once.
                     * This is probably not very efficient.
                     */
                    while (p--) {
                        bits = FbScrLeft(bits, shaBpp);
                        bits |= FbScrRight(*sha, shaShift) & shaMask;

                        shaShift -= shaStepOverX;
                        if (shaShift >= FB_UNIT) {
                            shaShift -= FB_UNIT;
                            sha--;
                        }
                        else if (shaShift < 0) {
                            shaShift += FB_UNIT;
                            sha++;
                        }
                        sha += shaStepOverY;
                    }
                    *win++ = bits;
                }
            }
            scr_y++;
            shaFirstShift -= shaStepDownX;
            if (shaFirstShift >= FB_UNIT) {
                shaFirstShift -= FB_UNIT;
                shaLine--;
            }
            else if (shaFirstShift < 0) {
                shaFirstShift += FB_UNIT;
                shaLine++;
            }
            shaLine += shaStepDownY;
        }
    }
}

shadowUpdateProc
shadowUpdateRotatePackedWeak(void)
{
    return shadowUpdateRotatePacked;
}
@


1.4
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d262 1
a262 1
                     * 
@


1.3
log
@Update to xserver 1.11.2
@
text
@d52 1
a52 2
shadowUpdateRotatePacked (ScreenPtr	pScreen,
			  shadowBufPtr	pBuf)
d54 30
a83 29
    RegionPtr	damage = shadowDamage (pBuf);
    PixmapPtr	pShadow = pBuf->pPixmap;
    int		nbox = RegionNumRects (damage);
    BoxPtr	pbox = RegionRects (damage);
    FbBits	*shaBits;
    FbStride	shaStride;
    int		shaBpp;
    _X_UNUSED int	shaXoff, shaYoff;
    int		box_x1, box_x2, box_y1, box_y2;
    int		sha_x1 = 0, sha_y1 = 0;
    int		scr_x1 = 0, scr_x2 = 0, scr_y1 = 0, scr_y2 = 0, scr_w, scr_h;
    int		scr_x, scr_y;
    int		w;
    int		pixelsPerBits;
    int		pixelsMask;
    FbStride	shaStepOverY = 0, shaStepDownY = 0;
    FbStride	shaStepOverX = 0, shaStepDownX = 0;
    FbBits	*shaLine, *sha;
    int		shaHeight = pShadow->drawable.height;
    int		shaWidth = pShadow->drawable.width;
    FbBits	shaMask;
    int		shaFirstShift, shaShift;
    int		o_x_dir;
    int		o_y_dir;
    int		x_dir;
    int		y_dir;

    fbGetDrawable (&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff, shaYoff);
    pixelsPerBits = (sizeof (FbBits) * 8) / shaBpp;
d85 1
a85 1
    shaMask = FbBitsMask (FB_UNIT-shaBpp, shaBpp);
d92 1
a92 1
	o_x_dir = -o_x_dir;
d94 1
a94 1
	o_y_dir = -o_y_dir;
d96 1
a96 1
    case SHADOW_ROTATE_0:	/* upper left shadow -> upper left screen */
d98 15
a112 15
	x_dir = o_x_dir;
	y_dir = o_y_dir;
	break;
    case SHADOW_ROTATE_90:    	/* upper right shadow -> upper left screen */
	x_dir = o_y_dir;
	y_dir = -o_x_dir;
	break;
    case SHADOW_ROTATE_180:	/* lower right shadow -> upper left screen */
	x_dir = -o_x_dir;
	y_dir = -o_y_dir;
	break;
    case SHADOW_ROTATE_270:	/* lower left shadow -> upper left screen */
	x_dir = -o_y_dir;
	y_dir = o_x_dir;
	break;
d116 3
a118 3
	shaStepOverX = shaBpp;
	shaStepOverY = 0;
	break;
d120 3
a122 3
	shaStepOverX = 0;
	shaStepOverY = shaStride;
	break;
d124 3
a126 3
	shaStepOverX = -shaBpp;
	shaStepOverY = 0;
	break;
d128 3
a130 3
	shaStepOverX = 0;
	shaStepOverY = -shaStride;
	break;
d134 3
a136 3
	shaStepDownX = 0;
	shaStepDownY = shaStride;
	break;
d138 3
a140 3
	shaStepDownX = -shaBpp;
	shaStepDownY = 0;
	break;
d142 3
a144 3
	shaStepDownX = 0;
	shaStepDownY = -shaStride;
	break;
d146 3
a148 3
	shaStepDownX = shaBpp;
	shaStepDownY = 0;
	break;
d150 2
a151 3
    
    while (nbox--)
    {
d158 139
a296 149
	/*
	 * Compute screen and shadow locations for this box
	 */
	switch (x_dir) {
	case LEFT_TO_RIGHT:
	    scr_x1 = box_x1 & pixelsMask;
	    scr_x2 = (box_x2 + pixelsPerBits - 1) & pixelsMask;
	    
	    sha_x1 = scr_x1;
	    break;
	case TOP_TO_BOTTOM:
	    scr_x1 = box_y1 & pixelsMask;
	    scr_x2 = (box_y2 + pixelsPerBits - 1) & pixelsMask;

	    sha_y1 = scr_x1;
	    break;
	case RIGHT_TO_LEFT:
	    scr_x1 = (shaWidth - box_x2) & pixelsMask;
	    scr_x2 = (shaWidth - box_x1 + pixelsPerBits - 1) & pixelsMask;

	    sha_x1 = (shaWidth - scr_x1 - 1);
	    break;
	case BOTTOM_TO_TOP:
	    scr_x1 = (shaHeight - box_y2) & pixelsMask;
	    scr_x2 = (shaHeight - box_y1 + pixelsPerBits - 1) & pixelsMask;
	    
	    sha_y1 = (shaHeight - scr_x1 - 1);
	    break;
	}
	switch (y_dir) {
	case TOP_TO_BOTTOM:
	    scr_y1 = box_y1;
	    scr_y2 = box_y2;

	    sha_y1 = scr_y1;
	    break;
	case RIGHT_TO_LEFT:
	    scr_y1 = (shaWidth - box_x2);
	    scr_y2 = (shaWidth - box_x1);

	    sha_x1 = box_x2 - 1;
	    break;
	case BOTTOM_TO_TOP:
	    scr_y1 = shaHeight - box_y2;
	    scr_y2 = shaHeight - box_y1;
	    
	    sha_y1 = box_y2 - 1;
	    break;
	case LEFT_TO_RIGHT:
	    scr_y1 = box_x1;
	    scr_y2 = box_x2;

	    sha_x1 = box_x1;
	    break;
	}
	scr_w = ((scr_x2 - scr_x1) * shaBpp) >> FB_SHIFT;
	scr_h = scr_y2 - scr_y1;
	scr_y = scr_y1;

	/* shift amount for first pixel on screen */ 
	shaFirstShift = FB_UNIT - ((sha_x1 * shaBpp) & FB_MASK) - shaBpp;
	
	/* pointer to shadow data first placed on screen */
	shaLine = (shaBits + 
		   sha_y1 * shaStride + 
		   ((sha_x1 * shaBpp) >> FB_SHIFT));

	/*
	 * Copy the bits, always write across the physical frame buffer
	 * to take advantage of write combining.
	 */
	while (scr_h--)
	{
	    int	    p;
	    FbBits  bits;
	    FbBits  *win;
	    int	    i;
	    CARD32  winSize;
	    
	    sha = shaLine;
	    shaShift = shaFirstShift;
	    w = scr_w;
	    scr_x = scr_x1 * shaBpp >> FB_SHIFT;

	    while (w)
	    {
		/*
		 * Map some of this line
		 */
		win = (FbBits *) (*pBuf->window) (pScreen,
						  scr_y,
						  scr_x << 2,
						  SHADOW_WINDOW_WRITE,
						  &winSize,
						  pBuf->closure);
		i = (winSize >> 2);
		if (i > w)
		    i = w;
		w -= i;
		scr_x += i;
		/*
		 * Copy the portion of the line mapped
		 */
		while (i--)
		{
		    bits = 0;
		    p = pixelsPerBits;
		    /*
		     * Build one word of output from multiple inputs
		     * 
		     * Note that for 90/270 rotations, this will walk
		     * down the shadow hitting each scanline once.
		     * This is probably not very efficient.
		     */
		    while (p--)
		    {
			bits = FbScrLeft(bits, shaBpp);
			bits |= FbScrRight (*sha, shaShift) & shaMask;

			shaShift -= shaStepOverX;
			if (shaShift >= FB_UNIT)
			{
			    shaShift -= FB_UNIT;
			    sha--;
			}
			else if (shaShift < 0)
			{
			    shaShift += FB_UNIT;
			    sha++;
			}
			sha += shaStepOverY;
		    }
		    *win++ = bits;
		}
	    }
	    scr_y++;
	    shaFirstShift -= shaStepDownX;
	    if (shaFirstShift >= FB_UNIT)
	    {
		shaFirstShift -= FB_UNIT;
		shaLine--;
	    }
	    else if (shaFirstShift < 0)
	    {
		shaFirstShift += FB_UNIT;
		shaLine++;
	    }
	    shaLine += shaStepDownY;
	}
d300 3
a302 1
shadowUpdateProc shadowUpdateRotatePackedWeak(void) {
@


1.2
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d62 1
a62 1
    int		shaXoff, shaYoff;
@


1.1
log
@Initial revision
@
text
@d57 2
a58 2
    int		nbox = REGION_NUM_RECTS (damage);
    BoxPtr	pbox = REGION_RECTS (damage);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
