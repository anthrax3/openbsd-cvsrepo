head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.10
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.8
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.6
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.4
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.2
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * Copyright Â© 2010 NVIDIA Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "scrnintstr.h"
#include "misync.h"
#include "misyncstr.h"

DevPrivateKeyRec miSyncScreenPrivateKey;

/* Default implementations of the sync screen functions */
void
miSyncScreenCreateFence(ScreenPtr pScreen, SyncFence * pFence,
                        Bool initially_triggered)
{
    (void) pScreen;

    pFence->triggered = initially_triggered;
}

void
miSyncScreenDestroyFence(ScreenPtr pScreen, SyncFence * pFence)
{
    (void) pScreen;
    (void) pFence;
}

/* Default implementations of the per-object functions */
void
miSyncFenceSetTriggered(SyncFence * pFence)
{
    pFence->triggered = TRUE;
}

void
miSyncFenceReset(SyncFence * pFence)
{
    pFence->triggered = FALSE;
}

Bool
miSyncFenceCheckTriggered(SyncFence * pFence)
{
    return pFence->triggered;
}

void
miSyncFenceAddTrigger(SyncTrigger * pTrigger)
{
    (void) pTrigger;

    return;
}

void
miSyncFenceDeleteTrigger(SyncTrigger * pTrigger)
{
    (void) pTrigger;

    return;
}

/* Machine independent portion of the fence sync object implementation */
void
miSyncInitFence(ScreenPtr pScreen, SyncFence * pFence, Bool initially_triggered)
{
    SyncScreenPrivPtr pScreenPriv = SYNC_SCREEN_PRIV(pScreen);

    static const SyncFenceFuncsRec miSyncFenceFuncs = {
        &miSyncFenceSetTriggered,
        &miSyncFenceReset,
        &miSyncFenceCheckTriggered,
        &miSyncFenceAddTrigger,
        &miSyncFenceDeleteTrigger
    };

    pFence->pScreen = pScreen;
    pFence->funcs = miSyncFenceFuncs;

    pScreenPriv->funcs.CreateFence(pScreen, pFence, initially_triggered);
}

void
miSyncDestroyFence(SyncFence * pFence)
{
    ScreenPtr pScreen = pFence->pScreen;
    SyncScreenPrivPtr pScreenPriv = SYNC_SCREEN_PRIV(pScreen);
    SyncTriggerList *ptl, *pNext;

    pFence->sync.beingDestroyed = TRUE;
    /* tell all the fence's triggers that the counter has been destroyed */
    for (ptl = pFence->sync.pTriglist; ptl; ptl = pNext) {
        (*ptl->pTrigger->CounterDestroyed) (ptl->pTrigger);
        pNext = ptl->next;
        free(ptl);              /* destroy the trigger list as we go */
    }

    pScreenPriv->funcs.DestroyFence(pScreen, pFence);

    dixFreeObjectWithPrivates(pFence, PRIVATE_SYNC_FENCE);
}

void
miSyncTriggerFence(SyncFence * pFence)
{
    SyncTriggerList *ptl, *pNext;
    CARD64 unused;

    pFence->funcs.SetTriggered(pFence);

    XSyncIntToValue(&unused, 0L);

    /* run through triggers to see if any fired */
    for (ptl = pFence->sync.pTriglist; ptl; ptl = pNext) {
        pNext = ptl->next;
        if ((*ptl->pTrigger->CheckTrigger) (ptl->pTrigger, unused))
            (*ptl->pTrigger->TriggerFired) (ptl->pTrigger);
    }
}

SyncScreenFuncsPtr
miSyncGetScreenFuncs(ScreenPtr pScreen)
{
    SyncScreenPrivPtr pScreenPriv = SYNC_SCREEN_PRIV(pScreen);

    return &pScreenPriv->funcs;
}

static Bool
SyncCloseScreen(ScreenPtr pScreen)
{
    SyncScreenPrivPtr pScreenPriv = SYNC_SCREEN_PRIV(pScreen);

    pScreen->CloseScreen = pScreenPriv->CloseScreen;

    return (*pScreen->CloseScreen) (pScreen);
}

Bool
miSyncSetup(ScreenPtr pScreen)
{
    SyncScreenPrivPtr pScreenPriv;

    static const SyncScreenFuncsRec miSyncScreenFuncs = {
        &miSyncScreenCreateFence,
        &miSyncScreenDestroyFence
    };

    if (!dixPrivateKeyRegistered(&miSyncScreenPrivateKey)) {
        if (!dixRegisterPrivateKey(&miSyncScreenPrivateKey, PRIVATE_SCREEN,
                                   sizeof(SyncScreenPrivRec)))
            return FALSE;
    }

    pScreenPriv = SYNC_SCREEN_PRIV(pScreen);

    if (!pScreenPriv->funcs.CreateFence) {
        pScreenPriv->funcs = miSyncScreenFuncs;

        /* Wrap CloseScreen to clean up */
        pScreenPriv->CloseScreen = pScreen->CloseScreen;
        pScreen->CloseScreen = SyncCloseScreen;
    }

    return TRUE;
}
@


1.3
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d32 1
a32 14
static DevPrivateKeyRec syncScreenPrivateKeyRec;
static DevPrivateKey syncScreenPrivateKey = &syncScreenPrivateKeyRec;

#define SYNC_SCREEN_PRIV(pScreen) 				\
    (SyncScreenPrivPtr) dixLookupPrivate(&pScreen->devPrivates,	\
					 syncScreenPrivateKey)

typedef struct _syncScreenPriv {
    /* Wrappable sync-specific screen functions */
    SyncScreenFuncsRec funcs;

    /* Wrapped screen functions */
    CloseScreenProcPtr CloseScreen;
} SyncScreenPrivRec, *SyncScreenPrivPtr;
d52 1
a52 1
static void
d58 1
a58 1
static void
d64 1
a64 1
static Bool
d70 1
a70 1
static void
d78 1
a78 1
static void
d172 5
a176 6
    if (dixPrivateKeyRegistered(syncScreenPrivateKey))
        return TRUE;

    if (!dixRegisterPrivateKey(syncScreenPrivateKey, PRIVATE_SCREEN,
                               sizeof(SyncScreenPrivRec)))
        return FALSE;
d180 2
a181 1
    pScreenPriv->funcs = miSyncScreenFuncs;
d183 4
a186 3
    /* Wrap CloseScreen to clean up */
    pScreenPriv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = SyncCloseScreen;
@


1.2
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d166 1
a166 1
SyncCloseScreen(int i, ScreenPtr pScreen)
d172 1
a172 1
    return (*pScreen->CloseScreen) (i, pScreen);
@


1.1
log
@Update to xserver 1.11.2
@
text
@d41 1
a41 1
    SyncScreenFuncsRec		funcs;
d44 1
a44 1
    CloseScreenProcPtr		CloseScreen;
d49 1
a49 1
miSyncScreenCreateFence(ScreenPtr pScreen, SyncFence* pFence,
d52 1
a52 1
    (void)pScreen;
d57 2
a58 1
void miSyncScreenDestroyFence(ScreenPtr pScreen, SyncFence* pFence)
d60 2
a61 2
    (void)pScreen;
    (void)pFence;
d66 1
a66 1
miSyncFenceSetTriggered(SyncFence* pFence)
d72 1
a72 1
miSyncFenceReset(SyncFence* pFence)
d78 1
a78 1
miSyncFenceCheckTriggered(SyncFence* pFence)
d84 1
a84 1
miSyncFenceAddTrigger(SyncTrigger* pTrigger)
d86 1
a86 1
    (void)pTrigger;
d92 1
a92 1
miSyncFenceDeleteTrigger(SyncTrigger* pTrigger)
d94 1
a94 1
    (void)pTrigger;
d101 1
a101 1
miSyncInitFence(ScreenPtr pScreen, SyncFence* pFence, Bool initially_triggered)
d104 1
d106 5
a110 5
	&miSyncFenceSetTriggered,
	&miSyncFenceReset,
	&miSyncFenceCheckTriggered,
	&miSyncFenceAddTrigger,
	&miSyncFenceDeleteTrigger
d120 1
a120 1
miSyncDestroyFence(SyncFence* pFence)
d128 4
a131 5
    for (ptl = pFence->sync.pTriglist; ptl; ptl = pNext)
    {
	(*ptl->pTrigger->CounterDestroyed)(ptl->pTrigger);
	pNext = ptl->next;
	free(ptl); /* destroy the trigger list as we go */
d140 1
a140 1
miSyncTriggerFence(SyncFence* pFence)
d150 4
a153 5
    for (ptl = pFence->sync.pTriglist; ptl; ptl = pNext)
    {
	pNext = ptl->next;
	if ((*ptl->pTrigger->CheckTrigger)(ptl->pTrigger, unused))
	    (*ptl->pTrigger->TriggerFired)(ptl->pTrigger);
d157 2
a158 1
SyncScreenFuncsPtr miSyncGetScreenFuncs(ScreenPtr pScreen)
d166 1
a166 1
SyncCloseScreen (int i, ScreenPtr pScreen)
d178 1
a178 1
    SyncScreenPrivPtr	pScreenPriv;
d181 2
a182 2
	&miSyncScreenCreateFence,
	&miSyncScreenDestroyFence
d186 1
a186 1
	return TRUE;
d189 2
a190 2
			       sizeof(SyncScreenPrivRec)))
	return FALSE;
@

