head	1.8;
access;
symbols
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.06.07.17.28.55;	author matthieu;	state dead;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.05;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.05;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@/*
 * Copyright Â© 2004 Eric Anholt
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Eric Anholt not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Eric Anholt makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * ERIC ANHOLT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL ERIC ANHOLT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <string.h>

#include "gcstruct.h"
#include "windowstr.h"
#include "cw.h"

#define CW_DEBUG 1

#if CW_DEBUG
#define CW_ASSERT(x) do {						\
    if (!(x)) {								\
	ErrorF("composite wrapper: assertion failed at %s:%d\n", __FUNC__, \
	    __LINE__);							\
    }									\
} while (0)
#else
#define CW_ASSERT(x) do {} while (0)
#endif

DevPrivateKeyRec cwGCKeyRec;
DevPrivateKeyRec cwScreenKeyRec;
DevPrivateKeyRec cwWindowKeyRec;
DevPrivateKeyRec cwPictureKeyRec;

extern GCOps cwGCOps;

static Bool
 cwCloseScreen(int i, ScreenPtr pScreen);

static void
 cwValidateGC(GCPtr pGC, unsigned long stateChanges, DrawablePtr pDrawable);
static void
 cwChangeGC(GCPtr pGC, unsigned long mask);
static void
 cwCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst);
static void
 cwDestroyGC(GCPtr pGC);
static void
 cwChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects);
static void
 cwCopyClip(GCPtr pgcDst, GCPtr pgcSrc);
static void
 cwDestroyClip(GCPtr pGC);

GCFuncs cwGCFuncs = {
    cwValidateGC,
    cwChangeGC,
    cwCopyGC,
    cwDestroyGC,
    cwChangeClip,
    cwDestroyClip,
    cwCopyClip,
};

/* Find the real drawable to draw to, and provide offsets that will translate
 * window coordinates to backing pixmap coordinates.
 */
DrawablePtr
cwGetBackingDrawable(DrawablePtr pDrawable, int *x_off, int *y_off)
{
    PixmapPtr pPixmap;

    if (pDrawable->type == DRAWABLE_WINDOW &&
        (pPixmap = getCwPixmap((WindowPtr) pDrawable))) {
        *x_off = pDrawable->x - pPixmap->screen_x;
        *y_off = pDrawable->y - pPixmap->screen_y;
        return &pPixmap->drawable;
    }
    else {
        *x_off = *y_off = 0;
        return pDrawable;
    }
}

#define FUNC_PROLOGUE(pGC, pPriv) do {					\
    (pGC)->funcs = (pPriv)->wrapFuncs;					\
    (pGC)->ops = (pPriv)->wrapOps;					\
} while (0)

#define FUNC_EPILOGUE(pGC, pPriv) do {					\
    (pPriv)->wrapFuncs = (pGC)->funcs;					\
    (pPriv)->wrapOps = (pGC)->ops;					\
    (pGC)->funcs = &cwGCFuncs;						\
    (pGC)->ops = &cwGCOps;						\
} while (0)

static Bool
cwCreateBackingGC(GCPtr pGC, DrawablePtr pDrawable)
{
    cwGCRec *pPriv = getCwGC(pGC);
    int status, x_off, y_off;
    XID noexpose = xFalse;
    DrawablePtr pBackingDrawable;

    pBackingDrawable = cwGetBackingDrawable(pDrawable, &x_off, &y_off);
    pPriv->pBackingGC = CreateGC(pBackingDrawable, GCGraphicsExposures,
                                 &noexpose, &status, (XID) 0, serverClient);
    if (status != Success)
        return FALSE;

    pPriv->serialNumber = 0;
    pPriv->stateChanges = GCAllBits;

    return TRUE;
}

static void
cwDestroyBackingGC(GCPtr pGC)
{
    cwGCPtr pPriv;

    pPriv = (cwGCPtr) getCwGC(pGC);

    if (pPriv->pBackingGC) {
        FreeGC(pPriv->pBackingGC, (XID) 0);
        pPriv->pBackingGC = NULL;
    }
}

static void
cwValidateGC(GCPtr pGC, unsigned long stateChanges, DrawablePtr pDrawable)
{
    GCPtr pBackingGC;
    cwGCPtr pPriv;
    DrawablePtr pBackingDrawable;
    int x_off, y_off;

    pPriv = (cwGCPtr) getCwGC(pGC);

    FUNC_PROLOGUE(pGC, pPriv);

    /*
     * Must call ValidateGC to ensure pGC->pCompositeClip is valid
     */
    (*pGC->funcs->ValidateGC) (pGC, stateChanges, pDrawable);

    if (!cwDrawableIsRedirWindow(pDrawable)) {
        cwDestroyBackingGC(pGC);
        FUNC_EPILOGUE(pGC, pPriv);
        return;
    }
    else {
        if (!pPriv->pBackingGC && !cwCreateBackingGC(pGC, pDrawable)) {
            FUNC_EPILOGUE(pGC, pPriv);
            return;
        }
    }

    pBackingGC = pPriv->pBackingGC;
    pBackingDrawable = cwGetBackingDrawable(pDrawable, &x_off, &y_off);

    pPriv->stateChanges |= stateChanges;

    /*
     * Copy the composite clip into the backing GC if either
     * the drawable clip list has changed or the client has changed
     * the client clip data
     */
    if (pDrawable->serialNumber != pPriv->serialNumber ||
        (pPriv->stateChanges & (GCClipXOrigin | GCClipYOrigin | GCClipMask))) {
        ChangeGCVal vals[2];
        RegionPtr pCompositeClip;

        pCompositeClip = RegionCreate(NULL, 0);
        RegionCopy(pCompositeClip, pGC->pCompositeClip);

        /* Either the drawable has changed, or the clip list in the drawable has
         * changed.  Copy the new clip list over and set the new translated
         * offset for it.
         */

        (*pBackingGC->funcs->ChangeClip) (pBackingGC, CT_REGION,
                                          (pointer) pCompositeClip, 0);

        vals[0].val = x_off - pDrawable->x;
        vals[1].val = y_off - pDrawable->y;
        ChangeGC(NullClient, pBackingGC, (GCClipXOrigin | GCClipYOrigin), vals);

        pPriv->serialNumber = pDrawable->serialNumber;
        /*
         * Mask off any client clip changes to make sure
         * the clip list set above remains in effect
         */
        pPriv->stateChanges &= ~(GCClipXOrigin | GCClipYOrigin | GCClipMask);
    }

    if (pPriv->stateChanges) {
        CopyGC(pGC, pBackingGC, pPriv->stateChanges);
        pPriv->stateChanges = 0;
    }

    if ((pGC->patOrg.x + x_off) != pBackingGC->patOrg.x ||
        (pGC->patOrg.y + y_off) != pBackingGC->patOrg.y) {
        ChangeGCVal vals[2];

        vals[0].val = pGC->patOrg.x + x_off;
        vals[1].val = pGC->patOrg.y + y_off;
        ChangeGC(NullClient, pBackingGC,
                 (GCTileStipXOrigin | GCTileStipYOrigin), vals);
    }

    ValidateGC(pBackingDrawable, pBackingGC);

    FUNC_EPILOGUE(pGC, pPriv);
}

static void
cwChangeGC(GCPtr pGC, unsigned long mask)
{
    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pGC->devPrivates, cwGCKey);

    FUNC_PROLOGUE(pGC, pPriv);

    (*pGC->funcs->ChangeGC) (pGC, mask);

    FUNC_EPILOGUE(pGC, pPriv);
}

static void
cwCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
{
    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pGCDst->devPrivates, cwGCKey);

    FUNC_PROLOGUE(pGCDst, pPriv);

    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);

    FUNC_EPILOGUE(pGCDst, pPriv);
}

static void
cwDestroyGC(GCPtr pGC)
{
    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pGC->devPrivates, cwGCKey);

    FUNC_PROLOGUE(pGC, pPriv);

    cwDestroyBackingGC(pGC);

    (*pGC->funcs->DestroyGC) (pGC);

    /* leave it unwrapped */
}

static void
cwChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects)
{
    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pGC->devPrivates, cwGCKey);

    FUNC_PROLOGUE(pGC, pPriv);

    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);

    FUNC_EPILOGUE(pGC, pPriv);
}

static void
cwCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pgcDst->devPrivates, cwGCKey);

    FUNC_PROLOGUE(pgcDst, pPriv);

    (*pgcDst->funcs->CopyClip) (pgcDst, pgcSrc);

    FUNC_EPILOGUE(pgcDst, pPriv);
}

static void
cwDestroyClip(GCPtr pGC)
{
    cwGCPtr pPriv = (cwGCPtr) dixLookupPrivate(&pGC->devPrivates, cwGCKey);

    FUNC_PROLOGUE(pGC, pPriv);

    (*pGC->funcs->DestroyClip) (pGC);

    FUNC_EPILOGUE(pGC, pPriv);
}

/*
 * Screen wrappers.
 */

#define SCREEN_PROLOGUE(pScreen, field)				\
  ((pScreen)->field = getCwScreen(pScreen)->field)

#define SCREEN_EPILOGUE(pScreen, field, wrapper) do {		\
    getCwScreen(pScreen)->field = (pScreen)->field;		\
    (pScreen)->field = (wrapper);				\
} while (0)

static Bool
cwCreateGC(GCPtr pGC)
{
    cwGCPtr pPriv = getCwGC(pGC);
    ScreenPtr pScreen = pGC->pScreen;
    Bool ret;

    SCREEN_PROLOGUE(pScreen, CreateGC);

    if ((ret = (*pScreen->CreateGC) (pGC)))
        FUNC_EPILOGUE(pGC, pPriv);

    SCREEN_EPILOGUE(pScreen, CreateGC, cwCreateGC);

    return ret;
}

static void
cwGetImage(DrawablePtr pSrc, int x, int y, int w, int h, unsigned int format,
           unsigned long planemask, char *pdstLine)
{
    ScreenPtr pScreen = pSrc->pScreen;
    DrawablePtr pBackingDrawable;
    int src_off_x, src_off_y;

    SCREEN_PROLOGUE(pScreen, GetImage);

    pBackingDrawable = cwGetBackingDrawable(pSrc, &src_off_x, &src_off_y);

    CW_OFFSET_XY_SRC(x, y);

    (*pScreen->GetImage) (pBackingDrawable, x, y, w, h, format, planemask,
                          pdstLine);

    SCREEN_EPILOGUE(pScreen, GetImage, cwGetImage);
}

static void
cwGetSpans(DrawablePtr pSrc, int wMax, DDXPointPtr ppt, int *pwidth,
           int nspans, char *pdstStart)
{
    ScreenPtr pScreen = pSrc->pScreen;
    DrawablePtr pBackingDrawable;
    int i;
    int src_off_x, src_off_y;

    SCREEN_PROLOGUE(pScreen, GetSpans);

    pBackingDrawable = cwGetBackingDrawable(pSrc, &src_off_x, &src_off_y);

    for (i = 0; i < nspans; i++)
        CW_OFFSET_XY_SRC(ppt[i].x, ppt[i].y);

    (*pScreen->GetSpans) (pBackingDrawable, wMax, ppt, pwidth, nspans,
                          pdstStart);

    SCREEN_EPILOGUE(pScreen, GetSpans, cwGetSpans);
}

static void
cwCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    SCREEN_PROLOGUE(pScreen, CopyWindow);

    if (!cwDrawableIsRedirWindow((DrawablePtr) pWin)) {
        (*pScreen->CopyWindow) (pWin, ptOldOrg, prgnSrc);
    }
    else {
        GCPtr pGC;
        BoxPtr pExtents;
        int x_off, y_off;
        int dx, dy;
        PixmapPtr pBackingPixmap;
        RegionPtr pClip;
        int src_x, src_y, dst_x, dst_y, w, h;

        dx = ptOldOrg.x - pWin->drawable.x;
        dy = ptOldOrg.y - pWin->drawable.y;

        pExtents = RegionExtents(prgnSrc);

        pBackingPixmap = (PixmapPtr) cwGetBackingDrawable((DrawablePtr) pWin,
                                                          &x_off, &y_off);

        src_x = pExtents->x1 - pBackingPixmap->screen_x;
        src_y = pExtents->y1 - pBackingPixmap->screen_y;
        w = pExtents->x2 - pExtents->x1;
        h = pExtents->y2 - pExtents->y1;
        dst_x = src_x - dx;
        dst_y = src_y - dy;

        /* Translate region (as required by API) */
        RegionTranslate(prgnSrc, -dx, -dy);

        pGC = GetScratchGC(pBackingPixmap->drawable.depth, pScreen);
        /*
         * Copy region to GC as clip, aligning as dest clip
         */
        pClip = RegionCreate(NULL, 0);
        RegionIntersect(pClip, &pWin->borderClip, prgnSrc);
        RegionTranslate(pClip,
                        -pBackingPixmap->screen_x, -pBackingPixmap->screen_y);

        (*pGC->funcs->ChangeClip) (pGC, CT_REGION, pClip, 0);

        ValidateGC(&pBackingPixmap->drawable, pGC);

        (*pGC->ops->CopyArea) (&pBackingPixmap->drawable,
                               &pBackingPixmap->drawable, pGC,
                               src_x, src_y, w, h, dst_x, dst_y);

        (*pGC->funcs->DestroyClip) (pGC);

        FreeScratchGC(pGC);
    }

    SCREEN_EPILOGUE(pScreen, CopyWindow, cwCopyWindow);
}

static PixmapPtr
cwGetWindowPixmap(WindowPtr pWin)
{
    PixmapPtr pPixmap = getCwPixmap(pWin);

    if (!pPixmap) {
        ScreenPtr pScreen = pWin->drawable.pScreen;

        SCREEN_PROLOGUE(pScreen, GetWindowPixmap);
        if (pScreen->GetWindowPixmap)
            pPixmap = (*pScreen->GetWindowPixmap) (pWin);
        SCREEN_EPILOGUE(pScreen, GetWindowPixmap, cwGetWindowPixmap);
    }
    return pPixmap;
}

static void
cwSetWindowPixmap(WindowPtr pWindow, PixmapPtr pPixmap)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;

    if (pPixmap == (*pScreen->GetScreenPixmap) (pScreen))
        pPixmap = NULL;
    setCwPixmap(pWindow, pPixmap);
}

/* Screen initialization/teardown */
void
miInitializeCompositeWrapper(ScreenPtr pScreen)
{
    cwScreenPtr pScreenPriv;
    Bool has_render = GetPictureScreenIfSet(pScreen) != NULL;

    if (!dixRegisterPrivateKey(&cwScreenKeyRec, PRIVATE_SCREEN, 0))
        return;

    if (!dixRegisterPrivateKey(&cwGCKeyRec, PRIVATE_GC, sizeof(cwGCRec)))
        return;

    if (!dixRegisterPrivateKey(&cwWindowKeyRec, PRIVATE_WINDOW, 0))
        return;

    if (!dixRegisterPrivateKey(&cwPictureKeyRec, PRIVATE_PICTURE, 0))
        return;

    pScreenPriv = malloc(sizeof(cwScreenRec));
    if (!pScreenPriv)
        return;

    dixSetPrivate(&pScreen->devPrivates, cwScreenKey, pScreenPriv);

    SCREEN_EPILOGUE(pScreen, CloseScreen, cwCloseScreen);
    SCREEN_EPILOGUE(pScreen, GetImage, cwGetImage);
    SCREEN_EPILOGUE(pScreen, GetSpans, cwGetSpans);
    SCREEN_EPILOGUE(pScreen, CreateGC, cwCreateGC);
    SCREEN_EPILOGUE(pScreen, CopyWindow, cwCopyWindow);

    SCREEN_EPILOGUE(pScreen, SetWindowPixmap, cwSetWindowPixmap);
    SCREEN_EPILOGUE(pScreen, GetWindowPixmap, cwGetWindowPixmap);

    if (has_render)
        cwInitializeRender(pScreen);
}

static Bool
cwCloseScreen(int i, ScreenPtr pScreen)
{
    cwScreenPtr pScreenPriv;
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    pScreenPriv = (cwScreenPtr) dixLookupPrivate(&pScreen->devPrivates,
                                                 cwScreenKey);
    pScreen->CloseScreen = pScreenPriv->CloseScreen;
    pScreen->GetImage = pScreenPriv->GetImage;
    pScreen->GetSpans = pScreenPriv->GetSpans;
    pScreen->CreateGC = pScreenPriv->CreateGC;
    pScreen->CopyWindow = pScreenPriv->CopyWindow;

    if (ps)
        cwFiniRender(pScreen);

    free((pointer) pScreenPriv);

    return (*pScreen->CloseScreen) (i, pScreen);
}
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@@


1.6
log
@Update to xserver 1.11.2
@
text
@d54 1
a54 1
cwCloseScreen (int i, ScreenPtr pScreen);
d57 1
a57 1
cwValidateGC(GCPtr pGC, unsigned long stateChanges, DrawablePtr pDrawable);
d59 1
a59 1
cwChangeGC(GCPtr pGC, unsigned long mask);
d61 1
a61 1
cwCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst);
d63 1
a63 1
cwDestroyGC(GCPtr pGC);
d65 1
a65 1
cwChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects);
d67 1
a67 1
cwCopyClip(GCPtr pgcDst, GCPtr pgcSrc);
d69 1
a69 1
cwDestroyClip(GCPtr pGC);
d87 11
a97 11
    PixmapPtr	pPixmap;
    
    if (pDrawable->type == DRAWABLE_WINDOW && 
	(pPixmap = getCwPixmap ((WindowPtr) pDrawable)))
    {
	*x_off = pDrawable->x - pPixmap->screen_x;
	*y_off = pDrawable->y - pPixmap->screen_y;
	return &pPixmap->drawable;
    } else {
	*x_off = *y_off = 0;
	return pDrawable;
a112 1

d123 1
a123 1
				 &noexpose, &status, (XID)0, serverClient);
d125 1
a125 1
	return FALSE;
d138 1
a138 1
    pPriv = (cwGCPtr) getCwGC (pGC);
d141 2
a142 2
	FreeGC(pPriv->pBackingGC, (XID)0);
	pPriv->pBackingGC = NULL;
d149 4
a152 4
    GCPtr   	  	pBackingGC;
    cwGCPtr		pPriv;
    DrawablePtr		pBackingDrawable;
    int			x_off, y_off;
d154 1
a154 1
    pPriv = (cwGCPtr) getCwGC (pGC);
d161 1
a161 1
    (*pGC->funcs->ValidateGC)(pGC, stateChanges, pDrawable);
d164 9
a172 8
	cwDestroyBackingGC(pGC);
	FUNC_EPILOGUE(pGC, pPriv);
	return;
    } else {
	if (!pPriv->pBackingGC && !cwCreateBackingGC(pGC, pDrawable)) {
	    FUNC_EPILOGUE(pGC, pPriv);
	    return;
	}
d186 25
a210 27
	(pPriv->stateChanges & (GCClipXOrigin|GCClipYOrigin|GCClipMask)))
    {
	ChangeGCVal vals[2];
	RegionPtr   pCompositeClip;

	pCompositeClip = RegionCreate(NULL, 0);
	RegionCopy(pCompositeClip, pGC->pCompositeClip);

	/* Either the drawable has changed, or the clip list in the drawable has
	 * changed.  Copy the new clip list over and set the new translated
	 * offset for it.
	 */
	
	(*pBackingGC->funcs->ChangeClip) (pBackingGC, CT_REGION,
					  (pointer) pCompositeClip, 0);
	
	vals[0].val = x_off - pDrawable->x;
	vals[1].val = y_off - pDrawable->y;
	ChangeGC(NullClient, pBackingGC,
		    (GCClipXOrigin | GCClipYOrigin), vals);

	pPriv->serialNumber = pDrawable->serialNumber;
	/*
	 * Mask off any client clip changes to make sure
	 * the clip list set above remains in effect
	 */
	pPriv->stateChanges &= ~(GCClipXOrigin|GCClipYOrigin|GCClipMask);
d214 2
a215 2
	CopyGC(pGC, pBackingGC, pPriv->stateChanges);
	pPriv->stateChanges = 0;
d219 7
a225 7
	(pGC->patOrg.y + y_off) != pBackingGC->patOrg.y)
    {
	ChangeGCVal vals[2];
	vals[0].val = pGC->patOrg.x + x_off;
	vals[1].val = pGC->patOrg.y + y_off;
	ChangeGC(NullClient, pBackingGC,
		    (GCTileStipXOrigin | GCTileStipYOrigin), vals);
d236 1
a236 1
    cwGCPtr pPriv = (cwGCPtr)dixLookupPrivate(&pGC->devPrivates, cwGCKey);
d248 1
a248 1
    cwGCPtr pPriv = (cwGCPtr)dixLookupPrivate(&pGCDst->devPrivates, cwGCKey);
d260 1
a260 1
    cwGCPtr pPriv = (cwGCPtr)dixLookupPrivate(&pGC->devPrivates, cwGCKey);
d274 1
a274 1
    cwGCPtr pPriv = (cwGCPtr)dixLookupPrivate(&pGC->devPrivates, cwGCKey);
d278 1
a278 1
    (*pGC->funcs->ChangeClip)(pGC, type, pvalue, nrects);
d286 1
a286 1
    cwGCPtr pPriv = (cwGCPtr)dixLookupPrivate(&pgcDst->devPrivates, cwGCKey);
d290 1
a290 1
    (*pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
d298 1
a298 1
    cwGCPtr pPriv = (cwGCPtr)dixLookupPrivate(&pGC->devPrivates, cwGCKey);
d302 1
a302 1
    (*pGC->funcs->DestroyClip)(pGC);
d322 3
a324 3
    cwGCPtr	pPriv = getCwGC(pGC);
    ScreenPtr	pScreen = pGC->pScreen;
    Bool	ret;
d328 2
a329 2
    if ( (ret = (*pScreen->CreateGC)(pGC)) )
	FUNC_EPILOGUE(pGC, pPriv);
d338 1
a338 1
	   unsigned long planemask, char *pdstLine)
d343 1
a343 1
    
d350 2
a351 2
    (*pScreen->GetImage)(pBackingDrawable, x, y, w, h, format, planemask,
			 pdstLine);
d358 1
a358 1
	   int nspans, char *pdstStart)
d364 1
a364 1
    
d370 1
a370 1
	CW_OFFSET_XY_SRC(ppt[i].x, ppt[i].y);
d372 2
a373 2
    (*pScreen->GetSpans)(pBackingDrawable, wMax, ppt, pwidth, nspans,
			 pdstStart);
a377 1

d385 46
a430 46
    if (!cwDrawableIsRedirWindow((DrawablePtr)pWin)) {
	(*pScreen->CopyWindow)(pWin, ptOldOrg, prgnSrc);
    } else {
	GCPtr	    pGC;
	BoxPtr	    pExtents;
	int	    x_off, y_off;
	int	    dx, dy;
	PixmapPtr   pBackingPixmap;
	RegionPtr   pClip;
	int	    src_x, src_y, dst_x, dst_y, w, h;

	dx = ptOldOrg.x - pWin->drawable.x;
	dy = ptOldOrg.y - pWin->drawable.y;

	pExtents = RegionExtents(prgnSrc);

	pBackingPixmap = (PixmapPtr) cwGetBackingDrawable((DrawablePtr)pWin,
							  &x_off, &y_off);

	src_x = pExtents->x1 - pBackingPixmap->screen_x;
	src_y = pExtents->y1 - pBackingPixmap->screen_y;
	w = pExtents->x2 - pExtents->x1;
	h = pExtents->y2 - pExtents->y1;
	dst_x = src_x - dx;
	dst_y = src_y - dy;
			       
	/* Translate region (as required by API) */
	RegionTranslate(prgnSrc, -dx, -dy);
	
	pGC = GetScratchGC(pBackingPixmap->drawable.depth, pScreen);
	/*
	 * Copy region to GC as clip, aligning as dest clip
	 */
	pClip = RegionCreate(NULL, 0);
	RegionIntersect(pClip, &pWin->borderClip, prgnSrc);
	RegionTranslate(pClip,
			 -pBackingPixmap->screen_x,
			 -pBackingPixmap->screen_y);
	
	(*pGC->funcs->ChangeClip) (pGC, CT_REGION, pClip, 0);

	ValidateGC(&pBackingPixmap->drawable, pGC);

	(*pGC->ops->CopyArea) (&pBackingPixmap->drawable,
			       &pBackingPixmap->drawable, pGC,
			       src_x, src_y, w, h, dst_x, dst_y);
d432 1
a432 1
	(*pGC->funcs->DestroyClip) (pGC);
d434 1
a434 1
	FreeScratchGC(pGC);
d436 1
a436 1
	
d441 1
a441 1
cwGetWindowPixmap (WindowPtr pWin)
d443 1
a443 1
    PixmapPtr	pPixmap = getCwPixmap (pWin);
d445 7
a451 7
    if (!pPixmap)
    {
	ScreenPtr   pScreen = pWin->drawable.pScreen;
	SCREEN_PROLOGUE(pScreen, GetWindowPixmap);
	if (pScreen->GetWindowPixmap)
	    pPixmap = (*pScreen->GetWindowPixmap) (pWin);
	SCREEN_EPILOGUE(pScreen, GetWindowPixmap, cwGetWindowPixmap);
d457 1
a457 1
cwSetWindowPixmap (WindowPtr pWindow, PixmapPtr pPixmap)
d459 2
a460 2
    ScreenPtr	pScreen = pWindow->drawable.pScreen;
    
d462 2
a463 2
	pPixmap = NULL;
    setCwPixmap (pWindow, pPixmap);
d474 1
a474 1
	return;
d477 1
a477 1
	return;
d480 1
a480 1
	return;
d483 1
a483 1
	return;
d487 1
a487 1
	return;
d490 1
a490 1
    
d501 1
a501 1
	cwInitializeRender(pScreen);
d505 1
a505 1
cwCloseScreen (int i, ScreenPtr pScreen)
d507 1
a507 1
    cwScreenPtr   pScreenPriv;
d510 2
a511 2
    pScreenPriv = (cwScreenPtr)dixLookupPrivate(&pScreen->devPrivates,
						cwScreenKey);
d519 1
a519 1
	cwFiniRender(pScreen);
d521 1
a521 1
    free((pointer)pScreenPriv);
d523 1
a523 1
    return (*pScreen->CloseScreen)(i, pScreen);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a327 1
    memset(pPriv, 0, sizeof(cwGCRec));
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d46 5
a50 10
static int cwGCKeyIndex;
DevPrivateKey cwGCKey = &cwGCKeyIndex;
static int cwScreenKeyIndex;
DevPrivateKey cwScreenKey = &cwScreenKeyIndex;
static int cwWindowKeyIndex;
DevPrivateKey cwWindowKey = &cwWindowKeyIndex;
#ifdef RENDER
static int cwPictureKeyIndex;
DevPrivateKey cwPictureKey = &cwPictureKeyIndex;
#endif
d129 1
a129 1
    pPriv->stateChanges = (1 << (GCLastBit + 1)) - 1;
d188 1
a188 1
	XID vals[2];
d191 2
a192 2
	pCompositeClip = REGION_CREATE (pScreen, NULL, 0);
	REGION_COPY (pScreen, pCompositeClip, pGC->pCompositeClip);
d202 4
a205 4
	vals[0] = x_off - pDrawable->x;
	vals[1] = y_off - pDrawable->y;
	dixChangeGC(NullClient, pBackingGC,
		    (GCClipXOrigin | GCClipYOrigin), vals, NULL);
d223 5
a227 5
	XID vals[2];
	vals[0] = pGC->patOrg.x + x_off;
	vals[1] = pGC->patOrg.y + y_off;
	dixChangeGC(NullClient, pBackingGC,
		    (GCTileStipXOrigin | GCTileStipYOrigin), vals, NULL);
d328 1
a328 1
    bzero(pPriv, sizeof(cwGCRec));
d403 1
a403 1
	pExtents = REGION_EXTENTS(pScreen, prgnSrc);
d416 1
a416 1
	REGION_TRANSLATE(pScreen, prgnSrc, -dx, -dy);
d422 3
a424 3
	pClip = REGION_CREATE (pScreen, NULL, 0);
	REGION_INTERSECT(pScreen, pClip, &pWin->borderClip, prgnSrc);
	REGION_TRANSLATE(pScreen, pClip, 
a474 1
#ifdef RENDER
a475 1
#endif
d477 10
a486 1
    if (!dixRequestPrivate(cwGCKey, sizeof(cwGCRec)))
d489 1
a489 1
    pScreenPriv = xalloc(sizeof(cwScreenRec));
a503 1
#ifdef RENDER
a505 1
#endif
a511 1
#ifdef RENDER
a512 1
#endif
a521 1
#ifdef RENDER
a523 1
#endif
d525 1
a525 1
    xfree((pointer)pScreenPriv);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d487 1
a487 1
    pScreenPriv = (cwScreenPtr)xalloc(sizeof(cwScreenRec));
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d46 6
a51 3
DevPrivateKey cwGCKey = &cwGCKey;
DevPrivateKey cwScreenKey = &cwScreenKey;
DevPrivateKey cwWindowKey = &cwWindowKey;
d53 2
a54 1
DevPrivateKey cwPictureKey = &cwPictureKey;
@


1.1
log
@Initial revision
@
text
@a21 1
/* $Header$ */
d46 3
a48 3
int cwGCIndex;
int cwScreenIndex;
int cwWindowIndex;
d50 1
a50 1
int cwPictureIndex;
a51 2
static Bool cwDisabled[MAXSCREENS];
static unsigned long cwGeneration = 0;
d125 1
a125 1
				 &noexpose, &status);
d239 1
a239 1
    cwGCPtr	pPriv = (cwGCPtr)(pGC)->devPrivates[cwGCIndex].ptr;
d251 1
a251 1
    cwGCPtr	pPriv = (cwGCPtr)(pGCDst)->devPrivates[cwGCIndex].ptr;
d263 1
a263 1
    cwGCPtr	pPriv = (cwGCPtr)(pGC)->devPrivates[cwGCIndex].ptr;
d277 1
a277 1
    cwGCPtr	pPriv = (cwGCPtr)(pGC)->devPrivates[cwGCIndex].ptr;
d289 1
a289 1
    cwGCPtr	pPriv = (cwGCPtr)(pgcDst)->devPrivates[cwGCIndex].ptr;
d301 1
a301 1
    cwGCPtr	pPriv = (cwGCPtr)(pGC)->devPrivates[cwGCIndex].ptr;
a381 143
static void
cwFillRegionSolid(DrawablePtr pDrawable, RegionPtr pRegion, unsigned long pixel)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    GCPtr     pGC;
    BoxPtr    pBox;
    int       nbox, i;
    ChangeGCVal v[3];

    pGC = GetScratchGC(pDrawable->depth, pScreen);
    v[0].val = GXcopy;
    v[1].val = pixel;
    v[2].val = FillSolid;
    dixChangeGC(NullClient, pGC, (GCFunction | GCForeground | GCFillStyle),
		NULL, v);
    ValidateGC(pDrawable, pGC);

    pBox = REGION_RECTS(pRegion);
    nbox = REGION_NUM_RECTS(pRegion);

    for (i = 0; i < nbox; i++, pBox++) {
	xRectangle rect;
	rect.x      = pBox->x1;
	rect.y      = pBox->y1;
	rect.width  = pBox->x2 - pBox->x1;
	rect.height = pBox->y2 - pBox->y1;
	(*pGC->ops->PolyFillRect)(pDrawable, pGC, 1, &rect);
    }

   FreeScratchGC(pGC);
}

static void
cwFillRegionTiled(DrawablePtr pDrawable, RegionPtr pRegion, PixmapPtr pTile,
		  int x_off, int y_off)
{
    ScreenPtr pScreen = pDrawable->pScreen;
    GCPtr     pGC;
    BoxPtr    pBox;
    int       nbox, i;
    ChangeGCVal v[5];

    pGC = GetScratchGC(pDrawable->depth, pScreen);
    v[0].val = GXcopy;
    v[1].val = FillTiled;
    v[2].ptr = (pointer) pTile;
    v[3].val = x_off;
    v[4].val = y_off;
    dixChangeGC(NullClient, pGC, (GCFunction | GCFillStyle | GCTile |
		GCTileStipXOrigin | GCTileStipYOrigin), NULL, v);

    ValidateGC(pDrawable, pGC);

    pBox = REGION_RECTS(pRegion);
    nbox = REGION_NUM_RECTS(pRegion);

    for (i = 0; i < nbox; i++, pBox++) {
	xRectangle rect;
	rect.x      = pBox->x1;
	rect.y      = pBox->y1;
	rect.width  = pBox->x2 - pBox->x1;
	rect.height = pBox->y2 - pBox->y1;
	(*pGC->ops->PolyFillRect)(pDrawable, pGC, 1, &rect);
    }

   FreeScratchGC(pGC);
}

static void
cwPaintWindowBackground(WindowPtr pWin, RegionPtr pRegion, int what)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    SCREEN_PROLOGUE(pScreen, PaintWindowBackground);

    if (!cwDrawableIsRedirWindow((DrawablePtr)pWin)) {
	(*pScreen->PaintWindowBackground)(pWin, pRegion, what);
    } else {
	DrawablePtr pBackingDrawable;
	int x_off, y_off, x_screen, y_screen;

	while (pWin->backgroundState == ParentRelative)
	    pWin = pWin->parent;

	pBackingDrawable = cwGetBackingDrawable((DrawablePtr)pWin, &x_off,
						&y_off);

	x_screen = x_off - pWin->drawable.x;
	y_screen = y_off - pWin->drawable.y;

	if (pWin && (pWin->backgroundState == BackgroundPixel ||
		pWin->backgroundState == BackgroundPixmap))
	{
	    REGION_TRANSLATE(pScreen, pRegion, x_screen, y_screen);

	    if (pWin->backgroundState == BackgroundPixel) {
		cwFillRegionSolid(pBackingDrawable, pRegion,
				  pWin->background.pixel);
	    } else {
		cwFillRegionTiled(pBackingDrawable, pRegion,
				  pWin->background.pixmap, x_off, y_off);
	    }

	    REGION_TRANSLATE(pScreen, pRegion, -x_screen, -y_screen);
	}
    }

    SCREEN_EPILOGUE(pScreen, PaintWindowBackground, cwPaintWindowBackground);
}

static void
cwPaintWindowBorder(WindowPtr pWin, RegionPtr pRegion, int what)
{
    ScreenPtr pScreen = pWin->drawable.pScreen;

    SCREEN_PROLOGUE(pScreen, PaintWindowBorder);

    if (!cwDrawableIsRedirWindow((DrawablePtr)pWin)) {
	(*pScreen->PaintWindowBorder)(pWin, pRegion,  what);
    } else {
	DrawablePtr pBackingDrawable;
	int x_off, y_off, x_screen, y_screen;

	pBackingDrawable = cwGetBackingDrawable((DrawablePtr)pWin, &x_off,
						&y_off);

	x_screen = x_off - pWin->drawable.x;
	y_screen = y_off - pWin->drawable.y;

	REGION_TRANSLATE(pScreen, pRegion, x_screen, y_screen);

	if (pWin->borderIsPixel) {
	    cwFillRegionSolid(pBackingDrawable, pRegion, pWin->border.pixel);
	} else {
	    cwFillRegionTiled(pBackingDrawable, pRegion, pWin->border.pixmap,
			      x_off, y_off);
	}

	REGION_TRANSLATE(pScreen, pRegion, -x_screen, -y_screen);
    }

    SCREEN_EPILOGUE(pScreen, PaintWindowBorder, cwPaintWindowBorder);
}
d476 3
d480 1
a480 1
    if (cwDisabled[pScreen->myNum])
a482 20
    if (cwGeneration != serverGeneration)
    {
	cwScreenIndex = AllocateScreenPrivateIndex();
	if (cwScreenIndex < 0)
	    return;
	cwGCIndex = AllocateGCPrivateIndex();
	cwWindowIndex = AllocateWindowPrivateIndex();
#ifdef RENDER
	cwPictureIndex = AllocatePicturePrivateIndex();
#endif
	cwGeneration = serverGeneration;
    }
    if (!AllocateGCPrivate(pScreen, cwGCIndex, sizeof(cwGCRec)))
	return;
    if (!AllocateWindowPrivate(pScreen, cwWindowIndex, 0))
	return;
#ifdef RENDER
    if (!AllocatePicturePrivate(pScreen, cwPictureIndex, 0))
	return;
#endif
d487 1
a487 1
    pScreen->devPrivates[cwScreenIndex].ptr = (pointer)pScreenPriv;
a492 2
    SCREEN_EPILOGUE(pScreen, PaintWindowBackground, cwPaintWindowBackground);
    SCREEN_EPILOGUE(pScreen, PaintWindowBorder, cwPaintWindowBorder);
d499 1
a499 1
    if (GetPictureScreen (pScreen))
a503 6
_X_EXPORT void
miDisableCompositeWrapper(ScreenPtr pScreen)
{
    cwDisabled[pScreen->myNum] = TRUE;
}

d512 2
a513 2
    pScreenPriv = (cwScreenPtr)pScreen->devPrivates[cwScreenIndex].ptr;

a517 2
    pScreen->PaintWindowBackground = pScreenPriv->PaintWindowBackground;
    pScreen->PaintWindowBorder = pScreenPriv->PaintWindowBorder;
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d22 1
d53 1
d622 3
a624 3
#ifdef RENDER
    Bool has_render = GetPictureScreenIfSet(pScreen) != NULL;
#endif
d634 1
a634 2
	if (has_render)
	    cwPictureIndex = AllocatePicturePrivateIndex();
d643 2
a644 4
    if (has_render) {
	if (!AllocatePicturePrivate(pScreen, cwPictureIndex, 0))
	    return;
    }
d664 1
a664 1
    if (has_render)
d667 6
@

