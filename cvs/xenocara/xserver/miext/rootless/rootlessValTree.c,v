head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.14
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.12
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.10
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.2.0.8
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.6
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	7pAEtF6Y5EgemkuY;

1.7
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	Te1daavkBLskZ8gc;

1.6
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.02;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.02;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.07;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/*
 * Calculate window clip lists for rootless mode
 *
 * This file is very closely based on mivaltree.c.
 */

/*
 * mivaltree.c --
 *	Functions for recalculating window clip lists. Main function
 *	is miValidateTree.
 *

Copyright 1987, 1988, 1989, 1998  The Open Group

All Rights Reserved.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

 *
 * Copyright 1987, 1988, 1989 by
 * Digital Equipment Corporation, Maynard, Massachusetts,
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital not be
 * used in advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 ******************************************************************/

/* The panoramix components contained the following notice */
/*****************************************************************

Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or other
dealings in this Software without prior written authorization from Digital
Equipment Corporation.

******************************************************************/
 /*
  * Aug '86: Susan Angebranndt -- original code
  * July '87: Adam de Boor -- substantially modified and commented
  * Summer '89: Joel McCormack -- so fast you wouldn't believe it possible.
  *             In particular, much improved code for window mapping and
  *             circulating.
  *             Bob Scheifler -- avoid miComputeClips for unmapped windows,
  *                              valdata changes
  */
#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stddef.h>             /* For NULL */
#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "validate.h"
#include    "windowstr.h"
#include    "mi.h"
#include    "regionstr.h"
#include    "mivalidate.h"

#include    "globals.h"

int RootlessMiValidateTree(WindowPtr pRoot, WindowPtr pChild, VTKind kind);

#define HasParentRelativeBorder(w) (!(w)->borderIsPixel && \
				    HasBorder(w) && \
				    (w)->backgroundState == ParentRelative)

/*
 *-----------------------------------------------------------------------
 * RootlessComputeClips --
 *	Recompute the clipList, borderClip, exposed and borderExposed
 *	regions for pParent and its children. Only viewable windows are
 *	taken into account.
 *
 * Results:
 *	None.
 *
 * Side Effects:
 *	clipList, borderClip, exposed and borderExposed are altered.
 *	A VisibilityNotify event may be generated on the parent window.
 *
 *-----------------------------------------------------------------------
 */
static void
RootlessComputeClips(WindowPtr pParent, ScreenPtr pScreen,
                     RegionPtr universe, VTKind kind, RegionPtr exposed)
{
    int dx, dy;
    RegionRec childUniverse;
    register WindowPtr pChild;
    int oldVis, newVis;
    BoxRec borderSize;
    RegionRec childUnion;
    Bool overlap;
    RegionPtr borderVisible;

    /*
     * Figure out the new visibility of this window.
     * The extent of the universe should be the same as the extent of
     * the borderSize region. If the window is unobscured, this rectangle
     * will be completely inside the universe (the universe will cover it
     * completely). If the window is completely obscured, none of the
     * universe will cover the rectangle.
     */
    borderSize.x1 = pParent->drawable.x - wBorderWidth(pParent);
    borderSize.y1 = pParent->drawable.y - wBorderWidth(pParent);
    dx = (int) pParent->drawable.x + (int) pParent->drawable.width +
        wBorderWidth(pParent);
    if (dx > 32767)
        dx = 32767;
    borderSize.x2 = dx;
    dy = (int) pParent->drawable.y + (int) pParent->drawable.height +
        wBorderWidth(pParent);
    if (dy > 32767)
        dy = 32767;
    borderSize.y2 = dy;

    oldVis = pParent->visibility;
    switch (RegionContainsRect(universe, &borderSize)) {
    case rgnIN:
        newVis = VisibilityUnobscured;
        break;
    case rgnPART:
        newVis = VisibilityPartiallyObscured;
        {
            RegionPtr pBounding;

            if ((pBounding = wBoundingShape(pParent))) {
                switch (miShapedWindowIn(universe, pBounding, &borderSize,
                                         pParent->drawable.x,
                                         pParent->drawable.y)) {
                case rgnIN:
                    newVis = VisibilityUnobscured;
                    break;
                case rgnOUT:
                    newVis = VisibilityFullyObscured;
                    break;
                }
            }
        }
        break;
    default:
        newVis = VisibilityFullyObscured;
        break;
    }

    pParent->visibility = newVis;
    if (oldVis != newVis &&
        ((pParent->
          eventMask | wOtherEventMasks(pParent)) & VisibilityChangeMask))
        SendVisibilityNotify(pParent);

    dx = pParent->drawable.x - pParent->valdata->before.oldAbsCorner.x;
    dy = pParent->drawable.y - pParent->valdata->before.oldAbsCorner.y;

    /*
     * avoid computations when dealing with simple operations
     */

    switch (kind) {
    case VTMap:
    case VTStack:
    case VTUnmap:
        break;
    case VTMove:
        if ((oldVis == newVis) &&
            ((oldVis == VisibilityFullyObscured) ||
             (oldVis == VisibilityUnobscured))) {
            pChild = pParent;
            while (1) {
                if (pChild->viewable) {
                    if (pChild->visibility != VisibilityFullyObscured) {
                        RegionTranslate(&pChild->borderClip, dx, dy);
                        RegionTranslate(&pChild->clipList, dx, dy);
                        pChild->drawable.serialNumber = NEXT_SERIAL_NUMBER;
                        if (pScreen->ClipNotify)
                            (*pScreen->ClipNotify) (pChild, dx, dy);

                    }
                    if (pChild->valdata) {
                        RegionNull(&pChild->valdata->after.borderExposed);
                        if (HasParentRelativeBorder(pChild)) {
                            RegionSubtract(&pChild->valdata->after.
                                           borderExposed, &pChild->borderClip,
                                           &pChild->winSize);
                        }
                        RegionNull(&pChild->valdata->after.exposed);
                    }
                    if (pChild->firstChild) {
                        pChild = pChild->firstChild;
                        continue;
                    }
                }
                while (!pChild->nextSib && (pChild != pParent))
                    pChild = pChild->parent;
                if (pChild == pParent)
                    break;
                pChild = pChild->nextSib;
            }
            return;
        }
        /* fall through */
    default:
        /*
         * To calculate exposures correctly, we have to translate the old
         * borderClip and clipList regions to the window's new location so there
         * is a correspondence between pieces of the new and old clipping regions.
         */
        if (dx || dy) {
            /*
             * We translate the old clipList because that will be exposed or copied
             * if gravity is right.
             */
            RegionTranslate(&pParent->borderClip, dx, dy);
            RegionTranslate(&pParent->clipList, dx, dy);
        }
        break;
    case VTBroken:
        RegionEmpty(&pParent->borderClip);
        RegionEmpty(&pParent->clipList);
        break;
    }

    borderVisible = pParent->valdata->before.borderVisible;
    RegionNull(&pParent->valdata->after.borderExposed);
    RegionNull(&pParent->valdata->after.exposed);

    /*
     * Since the borderClip must not be clipped by the children, we do
     * the border exposure first...
     *
     * 'universe' is the window's borderClip. To figure the exposures, remove
     * the area that used to be exposed from the new.
     * This leaves a region of pieces that weren't exposed before.
     */

    if (HasBorder(pParent)) {
        if (borderVisible) {
            /*
             * when the border changes shape, the old visible portions
             * of the border will be saved by DIX in borderVisible --
             * use that region and destroy it
             */
            RegionSubtract(exposed, universe, borderVisible);
            RegionDestroy(borderVisible);
        }
        else {
            RegionSubtract(exposed, universe, &pParent->borderClip);
        }
        if (HasParentRelativeBorder(pParent) && (dx || dy)) {
            RegionSubtract(&pParent->valdata->after.borderExposed,
                           universe, &pParent->winSize);
        }
        else {
            RegionSubtract(&pParent->valdata->after.borderExposed,
                           exposed, &pParent->winSize);
        }

        RegionCopy(&pParent->borderClip, universe);

        /*
         * To get the right clipList for the parent, and to make doubly sure
         * that no child overlaps the parent's border, we remove the parent's
         * border from the universe before proceeding.
         */

        RegionIntersect(universe, universe, &pParent->winSize);
    }
    else
        RegionCopy(&pParent->borderClip, universe);

    if ((pChild = pParent->firstChild) && pParent->mapped) {
        RegionNull(&childUniverse);
        RegionNull(&childUnion);
        if ((pChild->drawable.y < pParent->lastChild->drawable.y) ||
            ((pChild->drawable.y == pParent->lastChild->drawable.y) &&
             (pChild->drawable.x < pParent->lastChild->drawable.x))) {
            for (; pChild; pChild = pChild->nextSib) {
                if (pChild->viewable)
                    RegionAppend(&childUnion, &pChild->borderSize);
            }
        }
        else {
            for (pChild = pParent->lastChild; pChild; pChild = pChild->prevSib) {
                if (pChild->viewable)
                    RegionAppend(&childUnion, &pChild->borderSize);
            }
        }
        RegionValidate(&childUnion, &overlap);

        for (pChild = pParent->firstChild; pChild; pChild = pChild->nextSib) {
            if (pChild->viewable) {
                /*
                 * If the child is viewable, we want to remove its extents
                 * from the current universe, but we only re-clip it if
                 * it's been marked.
                 */
                if (pChild->valdata) {
                    /*
                     * Figure out the new universe from the child's
                     * perspective and recurse.
                     */
                    RegionIntersect(&childUniverse,
                                    universe, &pChild->borderSize);
                    RootlessComputeClips(pChild, pScreen, &childUniverse,
                                         kind, exposed);
                }
                /*
                 * Once the child has been processed, we remove its extents
                 * from the current universe, thus denying its space to any
                 * other sibling.
                 */
                if (overlap)
                    RegionSubtract(universe, universe, &pChild->borderSize);
            }
        }
        if (!overlap)
            RegionSubtract(universe, universe, &childUnion);
        RegionUninit(&childUnion);
        RegionUninit(&childUniverse);
    }                           /* if any children */

    /*
     * 'universe' now contains the new clipList for the parent window.
     *
     * To figure the exposure of the window we subtract the old clip from the
     * new, just as for the border.
     */

    if (oldVis == VisibilityFullyObscured || oldVis == VisibilityNotViewable) {
        RegionCopy(&pParent->valdata->after.exposed, universe);
    }
    else if (newVis != VisibilityFullyObscured &&
             newVis != VisibilityNotViewable) {
        RegionSubtract(&pParent->valdata->after.exposed,
                       universe, &pParent->clipList);
    }

    /* HACK ALERT - copying contents of regions, instead of regions */
    {
        RegionRec tmp;

        tmp = pParent->clipList;
        pParent->clipList = *universe;
        *universe = tmp;
    }

#ifdef NOTDEF
    RegionCopy(&pParent->clipList, universe);
#endif

    pParent->drawable.serialNumber = NEXT_SERIAL_NUMBER;

    if (pScreen->ClipNotify)
        (*pScreen->ClipNotify) (pParent, dx, dy);
}

static void
RootlessTreeObscured(WindowPtr pParent)
{
    register WindowPtr pChild;
    register int oldVis;

    pChild = pParent;
    while (1) {
        if (pChild->viewable) {
            oldVis = pChild->visibility;
            if (oldVis != (pChild->visibility = VisibilityFullyObscured) &&
                ((pChild->
                  eventMask | wOtherEventMasks(pChild)) & VisibilityChangeMask))
                SendVisibilityNotify(pChild);
            if (pChild->firstChild) {
                pChild = pChild->firstChild;
                continue;
            }
        }
        while (!pChild->nextSib && (pChild != pParent))
            pChild = pChild->parent;
        if (pChild == pParent)
            break;
        pChild = pChild->nextSib;
    }
}

/*
 *-----------------------------------------------------------------------
 * RootlessMiValidateTree --
 *	Recomputes the clip list for pParent and all its inferiors.
 *
 * Results:
 *	Always returns 1.
 *
 * Side Effects:
 *	The clipList, borderClip, exposed, and borderExposed regions for
 *	each marked window are altered.
 *
 * Notes:
 *	This routine assumes that all affected windows have been marked
 *	(valdata created) and their winSize and borderSize regions
 *	adjusted to correspond to their new positions. The borderClip and
 *	clipList regions should not have been touched.
 *
 *	The top-most level is treated differently from all lower levels
 *	because pParent is unchanged. For the top level, we merge the
 *	regions taken up by the marked children back into the clipList
 *	for pParent, thus forming a region from which the marked children
 *	can claim their areas. For lower levels, where the old clipList
 *	and borderClip are invalid, we can't do this and have to do the
 *	extra operations done in miComputeClips, but this is much faster
 *	e.g. when only one child has moved...
 *
 *-----------------------------------------------------------------------
 */
/*
   Quartz version: used for validate from root in rootless mode.
   We need to make sure top-level windows don't clip each other,
   and that top-level windows aren't clipped to the root window.
*/
 /*ARGSUSED*/
// fixme this is ugly
// Xprint/ValTree.c doesn't work, but maybe that method can?
    int
RootlessMiValidateTree(WindowPtr pRoot, /* Parent to validate */
                       WindowPtr pChild,        /* First child of pRoot that was
                                                 * affected */
                       VTKind kind /* What kind of configuration caused call */
                       )
{
    RegionRec childClip;        /* The new borderClip for the current
                                 * child */
    RegionRec exposed;          /* For intermediate calculations */
    register ScreenPtr pScreen;
    register WindowPtr pWin;

    pScreen = pRoot->drawable.pScreen;
    if (pChild == NullWindow)
        pChild = pRoot->firstChild;

    RegionNull(&childClip);
    RegionNull(&exposed);

    if (RegionBroken(&pRoot->clipList) && !RegionBroken(&pRoot->borderClip)) {
        // fixme this might not work, but hopefully doesn't happen anyway.
        kind = VTBroken;
        RegionNull(&pRoot->clipList);
        ErrorF("ValidateTree: BUSTED!\n");
    }

    /*
     * Recursively compute the clips for all children of the root.
     * They don't clip against each other or the root itself, so
     * childClip is always reset to that child's size.
     */

    for (pWin = pChild; pWin != NullWindow; pWin = pWin->nextSib) {
        if (pWin->viewable) {
            if (pWin->valdata) {
                RegionCopy(&childClip, &pWin->borderSize);
                RootlessComputeClips(pWin, pScreen, &childClip, kind, &exposed);
            }
            else if (pWin->visibility == VisibilityNotViewable) {
                RootlessTreeObscured(pWin);
            }
        }
        else {
            if (pWin->valdata) {
                RegionEmpty(&pWin->clipList);
                if (pScreen->ClipNotify)
                    (*pScreen->ClipNotify) (pWin, 0, 0);
                RegionEmpty(&pWin->borderClip);
                pWin->valdata = NULL;
            }
        }
    }

    RegionUninit(&childClip);

    /* The root is never clipped by its children, so nothing on the root
       is ever exposed by moving or mapping its children. */
    RegionNull(&pRoot->valdata->after.exposed);
    RegionNull(&pRoot->valdata->after.borderExposed);

    return 1;
}
@


1.7
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d490 1
a490 1
        RegionEmpty(&pRoot->clipList);
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d32 1
a32 1
 * Copyright 1987, 1988, 1989 by 
d34 1
a34 1
 * 
d36 3
a38 3
 * 
 * Permission to use, copy, modify, and distribute this software and its 
 * documentation for any purpose and without fee is hereby granted, 
d40 1
a40 1
 * both that copyright notice and this permission notice appear in 
d43 2
a44 2
 * software without specific, written prior permission.  
 * 
d52 1
a52 1
 * 
d83 1
a83 1
 /* 
a108 58
/*
 * Compute the visibility of a shaped window
 */
static int
RootlessShapedWindowIn(RegionPtr universe,
                       RegionPtr bounding, BoxPtr rect, int x, int y)
{
    BoxRec box;
    register BoxPtr boundBox;
    int nbox;
    Bool someIn, someOut;
    register int t, x1, y1, x2, y2;

    nbox = RegionNumRects(bounding);
    boundBox = RegionRects(bounding);
    someIn = someOut = FALSE;
    x1 = rect->x1;
    y1 = rect->y1;
    x2 = rect->x2;
    y2 = rect->y2;
    while (nbox--) {
        if ((t = boundBox->x1 + x) < x1)
            t = x1;
        box.x1 = t;
        if ((t = boundBox->y1 + y) < y1)
            t = y1;
        box.y1 = t;
        if ((t = boundBox->x2 + x) > x2)
            t = x2;
        box.x2 = t;
        if ((t = boundBox->y2 + y) > y2)
            t = y2;
        box.y2 = t;
        if (box.x1 > box.x2)
            box.x2 = box.x1;
        if (box.y1 > box.y2)
            box.y2 = box.y1;
        switch (RegionContainsRect(universe, &box)) {
        case rgnIN:
            if (someOut)
                return rgnPART;
            someIn = TRUE;
            break;
        case rgnOUT:
            if (someIn)
                return rgnPART;
            someOut = TRUE;
            break;
        default:
            return rgnPART;
        }
        boundBox++;
    }
    if (someIn)
        return rgnIN;
    return rgnOUT;
}

d174 3
a176 4
                switch (RootlessShapedWindowIn(universe,
                                               pBounding, &borderSize,
                                               pParent->drawable.x,
                                               pParent->drawable.y)) {
d459 1
a459 1
/* 
d461 1
a461 1
   We need to make sure top-level windows don't clip each other, 
d494 3
a496 3
    /* 
     * Recursively compute the clips for all children of the root. 
     * They don't clip against each other or the root itself, so 
d523 1
a523 1
    /* The root is never clipped by its children, so nothing on the root 
@


1.5
log
@Update to xserver 1.11.2
@
text
@d89 2
a90 2
  *		Bob Scheifler -- avoid miComputeClips for unmapped windows,
  *				 valdata changes
d96 1
a96 1
#include <stddef.h> /* For NULL */
d107 1
a107 1
int RootlessMiValidateTree (WindowPtr pRoot, WindowPtr pChild, VTKind kind);
d113 2
a114 2
RootlessShapedWindowIn (RegionPtr universe,
			RegionPtr bounding, BoxPtr rect, int x, int y)
d116 4
a119 4
    BoxRec  box;
    register BoxPtr  boundBox;
    int	    nbox;
    Bool    someIn, someOut;
d122 2
a123 2
    nbox = RegionNumRects (bounding);
    boundBox = RegionRects (bounding);
d129 32
a160 34
    while (nbox--)
    {
	if ((t = boundBox->x1 + x) < x1)
	    t = x1;
	box.x1 = t;
	if ((t = boundBox->y1 + y) < y1)
	    t = y1;
	box.y1 = t;
	if ((t = boundBox->x2 + x) > x2)
	    t = x2;
	box.x2 = t;
	if ((t = boundBox->y2 + y) > y2)
	    t = y2;
	box.y2 = t;
	if (box.x1 > box.x2)
	    box.x2 = box.x1;
	if (box.y1 > box.y2)
	    box.y2 = box.y1;
	switch (RegionContainsRect(universe, &box))
	{
	case rgnIN:
	    if (someOut)
		return rgnPART;
	    someIn = TRUE;
	    break;
	case rgnOUT:
	    if (someIn)
		return rgnPART;
	    someOut = TRUE;
	    break;
	default:
	    return rgnPART;
	}
	boundBox++;
d163 1
a163 1
	return rgnIN;
a170 1

d188 2
a189 2
RootlessComputeClips (WindowPtr pParent, ScreenPtr pScreen, 
		      RegionPtr universe, VTKind kind, RegionPtr exposed)
d191 9
a199 9
    int			dx,
			dy;
    RegionRec		childUniverse;
    register WindowPtr	pChild;
    int     	  	oldVis, newVis;
    BoxRec		borderSize;
    RegionRec		childUnion;
    Bool		overlap;
    RegionPtr		borderVisible;
d210 2
a211 1
    dx = (int) pParent->drawable.x + (int) pParent->drawable.width + wBorderWidth(pParent);
d213 1
a213 1
	dx = 32767;
d215 2
a216 1
    dy = (int) pParent->drawable.y + (int) pParent->drawable.height + wBorderWidth(pParent);
d218 1
a218 1
	dy = 32767;
d222 1
a222 2
    switch (RegionContainsRect(universe, &borderSize))
    {
d224 25
a248 27
	    newVis = VisibilityUnobscured;
	    break;
	case rgnPART:
	    newVis = VisibilityPartiallyObscured;
	    {
		RegionPtr   pBounding;

		if ((pBounding = wBoundingShape (pParent)))
		{
		    switch (RootlessShapedWindowIn (universe,
						    pBounding, &borderSize,
						    pParent->drawable.x,
						    pParent->drawable.y))
		    {
		    case rgnIN:
			newVis = VisibilityUnobscured;
			break;
		    case rgnOUT:
			newVis = VisibilityFullyObscured;
			break;
		    }
		}
	    }
	    break;
	default:
	    newVis = VisibilityFullyObscured;
	    break;
d253 3
a255 2
	((pParent->eventMask | wOtherEventMasks(pParent)) & VisibilityChangeMask))
	SendVisibilityNotify(pParent);
d268 1
a268 1
	break;
d270 37
a306 46
	if ((oldVis == newVis) &&
	    ((oldVis == VisibilityFullyObscured) ||
	     (oldVis == VisibilityUnobscured)))
	{
	    pChild = pParent;
	    while (1)
	    {
		if (pChild->viewable)
		{
		    if (pChild->visibility != VisibilityFullyObscured)
		    {
			RegionTranslate(&pChild->borderClip,
						      dx, dy);
			RegionTranslate(&pChild->clipList,
						      dx, dy);
			pChild->drawable.serialNumber = NEXT_SERIAL_NUMBER;
			if (pScreen->ClipNotify)
			    (* pScreen->ClipNotify) (pChild, dx, dy);

		    }
		    if (pChild->valdata)
		    {
			RegionNull(&pChild->valdata->after.borderExposed);
			if (HasParentRelativeBorder(pChild))
			  {
			    RegionSubtract(&pChild->valdata->after.borderExposed,
					   &pChild->borderClip,
					   &pChild->winSize);
			}
			RegionNull(&pChild->valdata->after.exposed);
		    }
		    if (pChild->firstChild)
		    {
			pChild = pChild->firstChild;
			continue;
		    }
		}
		while (!pChild->nextSib && (pChild != pParent))
		    pChild = pChild->parent;
		if (pChild == pParent)
		    break;
		pChild = pChild->nextSib;
	    }
	    return;
	}
	/* fall through */
d308 14
a321 15
    	/*
     	 * To calculate exposures correctly, we have to translate the old
     	 * borderClip and clipList regions to the window's new location so there
     	 * is a correspondence between pieces of the new and old clipping regions.
     	 */
    	if (dx || dy) 
    	{
	    /*
	     * We translate the old clipList because that will be exposed or copied
	     * if gravity is right.
	     */
	    RegionTranslate(&pParent->borderClip, dx, dy);
	    RegionTranslate(&pParent->clipList, dx, dy);
    	} 
	break;
d323 3
a325 3
	RegionEmpty(&pParent->borderClip);
	RegionEmpty(&pParent->clipList);
	break;
d341 31
a371 34
    if (HasBorder (pParent))
    {
    	if (borderVisible)
    	{
	    /*
	     * when the border changes shape, the old visible portions
	     * of the border will be saved by DIX in borderVisible --
	     * use that region and destroy it
	     */
	    RegionSubtract(exposed, universe, borderVisible);
	    RegionDestroy(borderVisible);
    	}
    	else
    	{
	    RegionSubtract(exposed, universe, &pParent->borderClip);
    	}
	if (HasParentRelativeBorder(pParent) && (dx || dy)) {
	    RegionSubtract(&pParent->valdata->after.borderExposed,
				  universe,
				  &pParent->winSize);
	} else {
	    RegionSubtract(&pParent->valdata->after.borderExposed,
			       exposed, &pParent->winSize);
	}

	RegionCopy(&pParent->borderClip, universe);
    
    	/*
     	 * To get the right clipList for the parent, and to make doubly sure
     	 * that no child overlaps the parent's border, we remove the parent's
     	 * border from the universe before proceeding.
     	 */
    
	RegionIntersect(universe, universe, &pParent->winSize);
d374 52
a425 62
	RegionCopy(&pParent->borderClip, universe);
    
    if ((pChild = pParent->firstChild) && pParent->mapped)
    {
	RegionNull(&childUniverse);
	RegionNull(&childUnion);
	if ((pChild->drawable.y < pParent->lastChild->drawable.y) ||
	    ((pChild->drawable.y == pParent->lastChild->drawable.y) &&
	     (pChild->drawable.x < pParent->lastChild->drawable.x)))
	{
	    for (; pChild; pChild = pChild->nextSib)
	    {
		if (pChild->viewable)
		    RegionAppend(&childUnion, &pChild->borderSize);
	    }
	}
	else
	{
	    for (pChild = pParent->lastChild; pChild; pChild = pChild->prevSib)
	    {
		if (pChild->viewable)
		    RegionAppend(&childUnion, &pChild->borderSize);
	    }
	}
	RegionValidate(&childUnion, &overlap);

	for (pChild = pParent->firstChild;
	     pChild;
	     pChild = pChild->nextSib)
 	{
	    if (pChild->viewable) {
		/*
		 * If the child is viewable, we want to remove its extents
		 * from the current universe, but we only re-clip it if
		 * it's been marked.
		 */
		if (pChild->valdata) {
		    /*
		     * Figure out the new universe from the child's
		     * perspective and recurse.
		     */
		    RegionIntersect(&childUniverse,
					    universe,
					    &pChild->borderSize);
		    RootlessComputeClips (pChild, pScreen, &childUniverse, 
					  kind, exposed);
		}
		/*
		 * Once the child has been processed, we remove its extents
		 * from the current universe, thus denying its space to any
		 * other sibling.
		 */
		if (overlap)
		    RegionSubtract(universe, universe,
					  &pChild->borderSize);
	    }
	}
	if (!overlap)
	    RegionSubtract(universe, universe, &childUnion);
	RegionUninit(&childUnion);
	RegionUninit(&childUniverse);
    } /* if any children */
d434 2
a435 4
    if (oldVis == VisibilityFullyObscured ||
	oldVis == VisibilityNotViewable)
    {
	RegionCopy(&pParent->valdata->after.exposed, universe);
d438 3
a440 4
	     newVis != VisibilityNotViewable)
    {
	RegionSubtract(&pParent->valdata->after.exposed,
			       universe, &pParent->clipList);
d445 1
a445 1
	RegionRec   tmp;
d447 3
a449 3
	tmp = pParent->clipList;
	pParent->clipList = *universe;
	*universe = tmp;
d459 1
a459 1
	(* pScreen->ClipNotify) (pParent, dx, dy);
d466 1
a466 1
    register int    oldVis;
d469 17
a485 19
    while (1)
    {
	if (pChild->viewable)
	{
	    oldVis = pChild->visibility;
	    if (oldVis != (pChild->visibility = VisibilityFullyObscured) &&
		((pChild->eventMask | wOtherEventMasks(pChild)) & VisibilityChangeMask))
		SendVisibilityNotify(pChild);
	    if (pChild->firstChild)
	    {
		pChild = pChild->firstChild;
		continue;
	    }
	}
	while (!pChild->nextSib && (pChild != pParent))
	    pChild = pChild->parent;
	if (pChild == pParent)
	    break;
	pChild = pChild->nextSib;
d523 1
a523 1
/*ARGSUSED*/
d526 6
a531 5
int
RootlessMiValidateTree (WindowPtr pRoot, /* Parent to validate */
			WindowPtr pChild, /* First child of pRoot that was
					   * affected */
			VTKind kind /* What kind of configuration caused call */)
d533 5
a537 5
    RegionRec	  	childClip;  /* The new borderClip for the current
				     * child */
    RegionRec		exposed;    /* For intermediate calculations */
    register ScreenPtr	pScreen;
    register WindowPtr	pWin;
d541 1
a541 1
	pChild = pRoot->firstChild;
d546 1
a546 3
    if (RegionBroken(&pRoot->clipList) &&
	!RegionBroken(&pRoot->borderClip))
    {
d559 1
a559 4
    for (pWin = pChild;
	 pWin != NullWindow;
	 pWin = pWin->nextSib)
    {
d563 3
a565 2
                RootlessComputeClips (pWin, pScreen, &childClip, kind, &exposed);
            } else if (pWin->visibility == VisibilityNotViewable) {
d568 2
a569 1
        } else {
d573 1
a573 1
                    (* pScreen->ClipNotify) (pWin, 0, 0);
@


1.4
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a202 1
    Bool		resized;
a341 1
    resized = pParent->valdata->before.resized;
a471 12
    /*
     * One last thing: backing storage. We have to try to save what parts of
     * the window are about to be obscured. We can just subtract the universe
     * from the old clipList and get the areas that were in the old but aren't
     * in the new and, hence, are about to be obscured.
     */
    if (pParent->backStorage && !resized)
    {
	RegionSubtract(exposed, &pParent->clipList, universe);
	(* pScreen->SaveDoomedAreas)(pParent, exposed, dx, dy);
    }
    
@


1.3
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@a106 3
int RootlessShapedWindowIn (ScreenPtr pScreen, RegionPtr universe,
			RegionPtr bounding, BoxPtr rect, int x, int y);

d112 2
a113 2
int
RootlessShapedWindowIn (ScreenPtr pScreen, RegionPtr universe,
d122 2
a123 2
    nbox = REGION_NUM_RECTS (bounding);
    boundBox = REGION_RECTS (bounding);
d147 1
a147 1
	switch (RECT_IN_REGION(pScreen, universe, &box))
d224 1
a224 1
    switch (RECT_IN_REGION( pScreen, universe, &borderSize)) 
d236 1
a236 1
		    switch (RootlessShapedWindowIn (pScreen, universe, 
d285 1
a285 1
			REGION_TRANSLATE( pScreen, &pChild->borderClip,
d287 1
a287 1
			REGION_TRANSLATE( pScreen, &pChild->clipList,
d296 1
a296 2
			REGION_NULL(pScreen,
				    &pChild->valdata->after.borderExposed);
d299 3
a301 4
			    REGION_SUBTRACT(pScreen,
					 &pChild->valdata->after.borderExposed,
					 &pChild->borderClip,
					 &pChild->winSize);
d303 1
a303 1
			REGION_NULL(pScreen, &pChild->valdata->after.exposed);
d332 2
a333 2
	    REGION_TRANSLATE( pScreen, &pParent->borderClip, dx, dy);
	    REGION_TRANSLATE( pScreen, &pParent->clipList, dx, dy);
d337 2
a338 2
	REGION_EMPTY (pScreen, &pParent->borderClip);
	REGION_EMPTY (pScreen, &pParent->clipList);
d344 2
a345 2
    REGION_NULL(pScreen, &pParent->valdata->after.borderExposed);
    REGION_NULL(pScreen, &pParent->valdata->after.exposed);
d365 2
a366 2
	    REGION_SUBTRACT( pScreen, exposed, universe, borderVisible);
	    REGION_DESTROY( pScreen, borderVisible);
d370 1
a370 1
	    REGION_SUBTRACT( pScreen, exposed, universe, &pParent->borderClip);
d373 1
a373 1
	    REGION_SUBTRACT( pScreen, &pParent->valdata->after.borderExposed,
d377 1
a377 1
	    REGION_SUBTRACT( pScreen, &pParent->valdata->after.borderExposed,
d381 1
a381 1
    	REGION_COPY( pScreen, &pParent->borderClip, universe);
d389 1
a389 1
    	REGION_INTERSECT( pScreen, universe, universe, &pParent->winSize);
d392 1
a392 1
    	REGION_COPY( pScreen, &pParent->borderClip, universe);
d396 2
a397 2
	REGION_NULL(pScreen, &childUniverse);
	REGION_NULL(pScreen, &childUnion);
d405 1
a405 1
		    REGION_APPEND( pScreen, &childUnion, &pChild->borderSize);
d413 1
a413 1
		    REGION_APPEND( pScreen, &childUnion, &pChild->borderSize);
d416 1
a416 1
	REGION_VALIDATE( pScreen, &childUnion, &overlap);
d433 1
a433 1
		    REGION_INTERSECT( pScreen, &childUniverse,
d445 1
a445 1
		    REGION_SUBTRACT( pScreen, universe, universe,
d450 3
a452 3
	    REGION_SUBTRACT( pScreen, universe, universe, &childUnion);
	REGION_UNINIT( pScreen, &childUnion);
	REGION_UNINIT( pScreen, &childUniverse);
d465 1
a465 1
	REGION_COPY( pScreen, &pParent->valdata->after.exposed, universe);
d470 1
a470 1
    	REGION_SUBTRACT( pScreen, &pParent->valdata->after.exposed,
d482 1
a482 1
	REGION_SUBTRACT( pScreen, exposed, &pParent->clipList, universe);
d496 1
a496 1
    REGION_COPY( pScreen, &pParent->clipList, universe);
d587 2
a588 2
    REGION_NULL(pScreen, &childClip);
    REGION_NULL(pScreen, &exposed);
d590 2
a591 2
    if (REGION_BROKEN (pScreen, &pRoot->clipList) &&
	!REGION_BROKEN (pScreen, &pRoot->borderClip))
d595 1
a595 1
        REGION_EMPTY (pScreen, &pRoot->clipList);
d611 1
a611 1
                REGION_COPY( pScreen, &childClip, &pWin->borderSize);
d618 1
a618 1
                REGION_EMPTY( pScreen, &pWin->clipList);
d621 1
a621 1
                REGION_EMPTY( pScreen, &pWin->borderClip);
d627 1
a627 1
    REGION_UNINIT(pScreen, &childClip);
d631 2
a632 2
    REGION_NULL(pScreen, &pRoot->valdata->after.exposed);
    REGION_NULL(pScreen, &pRoot->valdata->after.borderExposed);
@


1.2
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d627 1
a627 1
                pWin->valdata = (ValidatePtr)NULL;
@


1.1
log
@Initial revision
@
text
@d96 1
d107 5
a111 1
#ifdef SHAPE
d116 2
a117 5
RootlessShapedWindowIn (pScreen, universe, bounding, rect, x, y)
    ScreenPtr	pScreen;
    RegionPtr	universe, bounding;
    BoxPtr	rect;
    register int x, y;
a170 1
#endif
d194 2
a195 6
RootlessComputeClips (pParent, pScreen, universe, kind, exposed)
    register WindowPtr	pParent;
    register ScreenPtr	pScreen;
    register RegionPtr	universe;
    VTKind		kind;
    RegionPtr		exposed; /* for intermediate calculations */
a233 1
#ifdef SHAPE
a252 1
#endif
d511 1
a511 2
RootlessTreeObscured(pParent)
    register WindowPtr pParent;
d577 4
a580 5
RootlessMiValidateTree (pRoot, pChild, kind)
    WindowPtr	  	pRoot;      /* Parent to validate */
    WindowPtr	  	pChild;     /* First child of pRoot that was
				     * affected */
    VTKind    	  	kind;       /* What kind of configuration caused call */
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a95 1
#include <stddef.h> /* For NULL */
@

