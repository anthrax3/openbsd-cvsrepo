head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_4_0_90:1.1.1.1
	v1_4:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	s0SI41sEunLdyFfd;

1.10
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	cVXoV5PxI8YrEaVA;

1.9
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2011.12.18.16.09.00;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.01;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.01;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Screen routines for generic rootless X server
 */
/*
 * Copyright (c) 2001 Greg Parker. All Rights Reserved.
 * Copyright (c) 2002-2003 Torrey T. Lyons. All Rights Reserved.
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include "mi.h"
#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "propertyst.h"
#include "mivalidate.h"
#include "picturestr.h"
#include "colormapst.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#include "rootlessCommon.h"
#include "rootlessWindow.h"

/* In milliseconds */
#ifndef ROOTLESS_REDISPLAY_DELAY
#define ROOTLESS_REDISPLAY_DELAY 10
#endif

extern int RootlessMiValidateTree(WindowPtr pRoot, WindowPtr pChild,
                                  VTKind kind);
extern Bool RootlessCreateGC(GCPtr pGC);

// Initialize globals
DevPrivateKeyRec rootlessGCPrivateKeyRec;
DevPrivateKeyRec rootlessScreenPrivateKeyRec;
DevPrivateKeyRec rootlessWindowPrivateKeyRec;
DevPrivateKeyRec rootlessWindowOldPixmapPrivateKeyRec;

/*
 * RootlessUpdateScreenPixmap
 *  miCreateScreenResources does not like a null framebuffer pointer,
 *  it leaves the screen pixmap with an uninitialized data pointer.
 *  Thus, rootless implementations typically set the framebuffer width
 *  to zero so that miCreateScreenResources does not allocate a screen
 *  pixmap for us. We allocate our own screen pixmap here since we need
 *  the screen pixmap to be valid (e.g. CopyArea from the root window).
 */
void
RootlessUpdateScreenPixmap(ScreenPtr pScreen)
{
    RootlessScreenRec *s = SCREENREC(pScreen);
    PixmapPtr pPix;
    unsigned int rowbytes;

    pPix = (*pScreen->GetScreenPixmap) (pScreen);
    if (pPix == NULL) {
        pPix = (*pScreen->CreatePixmap) (pScreen, 0, 0, pScreen->rootDepth, 0);
        (*pScreen->SetScreenPixmap) (pPix);
    }

    rowbytes = PixmapBytePad(pScreen->width, pScreen->rootDepth);

    if (s->pixmap_data_size < rowbytes) {
        free(s->pixmap_data);

        s->pixmap_data_size = rowbytes;
        s->pixmap_data = malloc(s->pixmap_data_size);
        if (s->pixmap_data == NULL)
            return;

        memset(s->pixmap_data, 0xFF, s->pixmap_data_size);

        pScreen->ModifyPixmapHeader(pPix, pScreen->width, pScreen->height,
                                    pScreen->rootDepth,
                                    BitsPerPixel(pScreen->rootDepth),
                                    0, s->pixmap_data);
        /* ModifyPixmapHeader ignores zero arguments, so install rowbytes
           by hand. */
        pPix->devKind = 0;
    }
}

/*
 * RootlessCreateScreenResources
 *  Rootless implementations typically set a null framebuffer pointer, which
 *  causes problems with miCreateScreenResources. We fix things up here.
 */
static Bool
RootlessCreateScreenResources(ScreenPtr pScreen)
{
    Bool ret = TRUE;

    SCREEN_UNWRAP(pScreen, CreateScreenResources);

    if (pScreen->CreateScreenResources != NULL)
        ret = (*pScreen->CreateScreenResources) (pScreen);

    SCREEN_WRAP(pScreen, CreateScreenResources);

    if (!ret)
        return ret;

    /* Make sure we have a valid screen pixmap. */

    RootlessUpdateScreenPixmap(pScreen);

    return ret;
}

static Bool
RootlessCloseScreen(ScreenPtr pScreen)
{
    RootlessScreenRec *s;

    s = SCREENREC(pScreen);

    // fixme unwrap everything that was wrapped?
    pScreen->CloseScreen = s->CloseScreen;

    if (s->pixmap_data != NULL) {
        free(s->pixmap_data);
        s->pixmap_data = NULL;
        s->pixmap_data_size = 0;
    }

    free(s);
    return pScreen->CloseScreen(pScreen);
}

static void
RootlessGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
                 unsigned int format, unsigned long planeMask, char *pdstLine)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    SCREEN_UNWRAP(pScreen, GetImage);

    if (pDrawable->type == DRAWABLE_WINDOW) {
        int x0, y0, x1, y1;
        RootlessWindowRec *winRec;

        // Many apps use GetImage to sync with the visible frame buffer
        // FIXME: entire screen or just window or all screens?
        RootlessRedisplayScreen(pScreen);

        // RedisplayScreen stops drawing, so we need to start it again
        RootlessStartDrawing((WindowPtr) pDrawable);

        /* Check that we have some place to read from. */
        winRec = WINREC(TopLevelParent((WindowPtr) pDrawable));
        if (winRec == NULL)
            goto out;

        /* Clip to top-level window bounds. */
        /* FIXME: fbGetImage uses the width parameter to calculate the
           stride of the destination pixmap. If w is clipped, the data
           returned will be garbage, although we will not crash. */

        x0 = pDrawable->x + sx;
        y0 = pDrawable->y + sy;
        x1 = x0 + w;
        y1 = y0 + h;

        x0 = max(x0, winRec->x);
        y0 = max(y0, winRec->y);
        x1 = min(x1, winRec->x + winRec->width);
        y1 = min(y1, winRec->y + winRec->height);

        sx = x0 - pDrawable->x;
        sy = y0 - pDrawable->y;
        w = x1 - x0;
        h = y1 - y0;

        if (w <= 0 || h <= 0)
            goto out;
    }

    pScreen->GetImage(pDrawable, sx, sy, w, h, format, planeMask, pdstLine);

 out:
    SCREEN_WRAP(pScreen, GetImage);
}

/*
 * RootlessSourceValidate
 *  CopyArea and CopyPlane use a GC tied to the destination drawable.
 *  StartDrawing/StopDrawing wrappers won't be called if source is
 *  a visible window but the destination isn't. So, we call StartDrawing
 *  here and leave StopDrawing for the block handler.
 */
static void
RootlessSourceValidate(DrawablePtr pDrawable, int x, int y, int w, int h,
                       unsigned int subWindowMode)
{
    SCREEN_UNWRAP(pDrawable->pScreen, SourceValidate);
    if (pDrawable->type == DRAWABLE_WINDOW) {
        WindowPtr pWin = (WindowPtr) pDrawable;

        RootlessStartDrawing(pWin);
    }
    if (pDrawable->pScreen->SourceValidate) {
        pDrawable->pScreen->SourceValidate(pDrawable, x, y, w, h,
                                           subWindowMode);
    }
    SCREEN_WRAP(pDrawable->pScreen, SourceValidate);
}

static void
RootlessComposite(CARD8 op, PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst,
                  INT16 xSrc, INT16 ySrc, INT16 xMask, INT16 yMask,
                  INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    WindowPtr srcWin, dstWin, maskWin = NULL;

    if (pMask) {                // pMask can be NULL
        maskWin = (pMask->pDrawable &&
                   pMask->pDrawable->type ==
                   DRAWABLE_WINDOW) ? (WindowPtr) pMask->pDrawable : NULL;
    }
    srcWin = (pSrc->pDrawable && pSrc->pDrawable->type == DRAWABLE_WINDOW) ?
        (WindowPtr) pSrc->pDrawable : NULL;
    dstWin = (pDst->pDrawable->type == DRAWABLE_WINDOW) ?
        (WindowPtr) pDst->pDrawable : NULL;

    // SCREEN_UNWRAP(ps, Composite);
    ps->Composite = SCREENREC(pScreen)->Composite;

    if (srcWin && IsFramedWindow(srcWin))
        RootlessStartDrawing(srcWin);
    if (maskWin && IsFramedWindow(maskWin))
        RootlessStartDrawing(maskWin);
    if (dstWin && IsFramedWindow(dstWin))
        RootlessStartDrawing(dstWin);

    ps->Composite(op, pSrc, pMask, pDst,
                  xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);

    if (dstWin && IsFramedWindow(dstWin)) {
        RootlessDamageRect(dstWin, xDst, yDst, width, height);
    }

    ps->Composite = RootlessComposite;
    // SCREEN_WRAP(ps, Composite);
}

static void
RootlessGlyphs(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
               PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
               int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    int x, y;
    int n;
    GlyphPtr glyph;
    WindowPtr srcWin, dstWin;

    srcWin = (pSrc->pDrawable && pSrc->pDrawable->type == DRAWABLE_WINDOW) ?
        (WindowPtr) pSrc->pDrawable : NULL;
    dstWin = (pDst->pDrawable->type == DRAWABLE_WINDOW) ?
        (WindowPtr) pDst->pDrawable : NULL;

    if (srcWin && IsFramedWindow(srcWin))
        RootlessStartDrawing(srcWin);
    if (dstWin && IsFramedWindow(dstWin))
        RootlessStartDrawing(dstWin);

    //SCREEN_UNWRAP(ps, Glyphs);
    ps->Glyphs = SCREENREC(pScreen)->Glyphs;
    ps->Glyphs(op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);
    ps->Glyphs = RootlessGlyphs;
    //SCREEN_WRAP(ps, Glyphs);

    if (dstWin && IsFramedWindow(dstWin)) {
        x = xSrc;
        y = ySrc;

        while (nlist--) {
            x += list->xOff;
            y += list->yOff;
            n = list->len;

            /* Calling DamageRect for the bounding box of each glyph is
               inefficient. So compute the union of all glyphs in a list
               and damage that. */

            if (n > 0) {
                BoxRec box;

                glyph = *glyphs++;

                box.x1 = x - glyph->info.x;
                box.y1 = y - glyph->info.y;
                box.x2 = box.x1 + glyph->info.width;
                box.y2 = box.y1 + glyph->info.height;

                x += glyph->info.xOff;
                y += glyph->info.yOff;

                while (--n > 0) {
                    short x1, y1, x2, y2;

                    glyph = *glyphs++;

                    x1 = x - glyph->info.x;
                    y1 = y - glyph->info.y;
                    x2 = x1 + glyph->info.width;
                    y2 = y1 + glyph->info.height;

                    box.x1 = max(box.x1, x1);
                    box.y1 = max(box.y1, y1);
                    box.x2 = max(box.x2, x2);
                    box.y2 = max(box.y2, y2);

                    x += glyph->info.xOff;
                    y += glyph->info.yOff;
                }

                RootlessDamageBox(dstWin, &box);
            }
            list++;
        }
    }
}

/*
 * RootlessValidateTree
 *  ValidateTree is modified in two ways:
 *   - top-level windows don't clip each other
 *   - windows aren't clipped against root.
 *  These only matter when validating from the root.
 */
static int
RootlessValidateTree(WindowPtr pParent, WindowPtr pChild, VTKind kind)
{
    int result;
    RegionRec saveRoot;
    ScreenPtr pScreen = pParent->drawable.pScreen;

    SCREEN_UNWRAP(pScreen, ValidateTree);
    RL_DEBUG_MSG("VALIDATETREE start ");

    // Use our custom version to validate from root
    if (IsRoot(pParent)) {
        RL_DEBUG_MSG("custom ");
        result = RootlessMiValidateTree(pParent, pChild, kind);
    }
    else {
        HUGE_ROOT(pParent);
        result = pScreen->ValidateTree(pParent, pChild, kind);
        NORMAL_ROOT(pParent);
    }

    SCREEN_WRAP(pScreen, ValidateTree);
    RL_DEBUG_MSG("VALIDATETREE end\n");

    return result;
}

/*
 * RootlessMarkOverlappedWindows
 *  MarkOverlappedWindows is modified to ignore overlapping
 *  top-level windows.
 */
static Bool
RootlessMarkOverlappedWindows(WindowPtr pWin, WindowPtr pFirst,
                              WindowPtr *ppLayerWin)
{
    RegionRec saveRoot;
    Bool result;
    ScreenPtr pScreen = pWin->drawable.pScreen;

    SCREEN_UNWRAP(pScreen, MarkOverlappedWindows);
    RL_DEBUG_MSG("MARKOVERLAPPEDWINDOWS start ");

    HUGE_ROOT(pWin);
    if (IsRoot(pWin)) {
        // root - mark nothing
        RL_DEBUG_MSG("is root not marking ");
        result = FALSE;
    }
    else if (!IsTopLevel(pWin)) {
        // not top-level window - mark normally
        result = pScreen->MarkOverlappedWindows(pWin, pFirst, ppLayerWin);
    }
    else {
        //top-level window - mark children ONLY - NO overlaps with sibs (?)
        // This code copied from miMarkOverlappedWindows()

        register WindowPtr pChild;
        Bool anyMarked = FALSE;
        MarkWindowProcPtr MarkWindow = pScreen->MarkWindow;

        RL_DEBUG_MSG("is top level! ");
        /* single layered systems are easy */
        if (ppLayerWin)
            *ppLayerWin = pWin;

        if (pWin == pFirst) {
            /* Blindly mark pWin and all of its inferiors.   This is a slight
             * overkill if there are mapped windows that outside pWin's border,
             * but it's better than wasting time on RectIn checks.
             */
            pChild = pWin;
            while (1) {
                if (pChild->viewable) {
                    if (RegionBroken(&pChild->winSize))
                        SetWinSize(pChild);
                    if (RegionBroken(&pChild->borderSize))
                        SetBorderSize(pChild);
                    (*MarkWindow) (pChild);
                    if (pChild->firstChild) {
                        pChild = pChild->firstChild;
                        continue;
                    }
                }
                while (!pChild->nextSib && (pChild != pWin))
                    pChild = pChild->parent;
                if (pChild == pWin)
                    break;
                pChild = pChild->nextSib;
            }
            anyMarked = TRUE;
        }
        if (anyMarked)
            (*MarkWindow) (pWin->parent);
        result = anyMarked;
    }
    NORMAL_ROOT(pWin);
    SCREEN_WRAP(pScreen, MarkOverlappedWindows);
    RL_DEBUG_MSG("MARKOVERLAPPEDWINDOWS end\n");

    return result;
}

static void
expose_1(WindowPtr pWin)
{
    WindowPtr pChild;

    if (!pWin->realized)
        return;

    pWin->drawable.pScreen->PaintWindow(pWin, &pWin->borderClip, PW_BACKGROUND);

    /* FIXME: comments in windowstr.h indicate that borderClip doesn't
       include subwindow visibility. But I'm not so sure.. so we may
       be exposing too much.. */

    miSendExposures(pWin, &pWin->borderClip,
                    pWin->drawable.x, pWin->drawable.y);

    for (pChild = pWin->firstChild; pChild != NULL; pChild = pChild->nextSib)
        expose_1(pChild);
}

void
RootlessScreenExpose(ScreenPtr pScreen)
{
    expose_1(pScreen->root);
}

ColormapPtr
RootlessGetColormap(ScreenPtr pScreen)
{
    RootlessScreenRec *s = SCREENREC(pScreen);

    return s->colormap;
}

static void
RootlessInstallColormap(ColormapPtr pMap)
{
    ScreenPtr pScreen = pMap->pScreen;
    RootlessScreenRec *s = SCREENREC(pScreen);

    SCREEN_UNWRAP(pScreen, InstallColormap);

    if (s->colormap != pMap) {
        s->colormap = pMap;
        s->colormap_changed = TRUE;
        RootlessQueueRedisplay(pScreen);
    }

    pScreen->InstallColormap(pMap);

    SCREEN_WRAP(pScreen, InstallColormap);
}

static void
RootlessUninstallColormap(ColormapPtr pMap)
{
    ScreenPtr pScreen = pMap->pScreen;
    RootlessScreenRec *s = SCREENREC(pScreen);

    SCREEN_UNWRAP(pScreen, UninstallColormap);

    if (s->colormap == pMap)
        s->colormap = NULL;

    pScreen->UninstallColormap(pMap);

    SCREEN_WRAP(pScreen, UninstallColormap);
}

static void
RootlessStoreColors(ColormapPtr pMap, int ndef, xColorItem * pdef)
{
    ScreenPtr pScreen = pMap->pScreen;
    RootlessScreenRec *s = SCREENREC(pScreen);

    SCREEN_UNWRAP(pScreen, StoreColors);

    if (s->colormap == pMap && ndef > 0) {
        s->colormap_changed = TRUE;
        RootlessQueueRedisplay(pScreen);
    }

    pScreen->StoreColors(pMap, ndef, pdef);

    SCREEN_WRAP(pScreen, StoreColors);
}

static CARD32
RootlessRedisplayCallback(OsTimerPtr timer, CARD32 time, void *arg)
{
    RootlessScreenRec *screenRec = arg;

    if (!screenRec->redisplay_queued) {
        /* No update needed. Stop the timer. */

        screenRec->redisplay_timer_set = FALSE;
        return 0;
    }

    screenRec->redisplay_queued = FALSE;

    /* Mark that we should redisplay before waiting for I/O next time */
    screenRec->redisplay_expired = TRUE;

    /* Reinstall the timer immediately, so we get as close to our
       redisplay interval as possible. */

    return ROOTLESS_REDISPLAY_DELAY;
}

/*
 * RootlessQueueRedisplay
 *  Queue a redisplay after a timer delay to ensure we do not redisplay
 *  too frequently.
 */
void
RootlessQueueRedisplay(ScreenPtr pScreen)
{
    RootlessScreenRec *screenRec = SCREENREC(pScreen);

    screenRec->redisplay_queued = TRUE;

    if (screenRec->redisplay_timer_set)
        return;

    screenRec->redisplay_timer = TimerSet(screenRec->redisplay_timer,
                                          0, ROOTLESS_REDISPLAY_DELAY,
                                          RootlessRedisplayCallback, screenRec);
    screenRec->redisplay_timer_set = TRUE;
}

/*
 * RootlessBlockHandler
 *  If the redisplay timer has expired, flush drawing before blocking
 *  on select().
 */
static void
RootlessBlockHandler(void *pbdata, OSTimePtr pTimeout, void *pReadmask)
{
    ScreenPtr pScreen = pbdata;
    RootlessScreenRec *screenRec = SCREENREC(pScreen);

    if (screenRec->redisplay_expired) {
        screenRec->redisplay_expired = FALSE;

        RootlessRedisplayScreen(pScreen);
    }
}

static void
RootlessWakeupHandler(void *data, int i, void *LastSelectMask)
{
    // nothing here
}

static Bool
RootlessAllocatePrivates(ScreenPtr pScreen)
{
    RootlessScreenRec *s;

    if (!dixRegisterPrivateKey
        (&rootlessGCPrivateKeyRec, PRIVATE_GC, sizeof(RootlessGCRec)))
        return FALSE;
    if (!dixRegisterPrivateKey(&rootlessScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;
    if (!dixRegisterPrivateKey(&rootlessWindowPrivateKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;
    if (!dixRegisterPrivateKey
        (&rootlessWindowOldPixmapPrivateKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;

    s = malloc(sizeof(RootlessScreenRec));
    if (!s)
        return FALSE;
    SETSCREENREC(pScreen, s);

    s->pixmap_data = NULL;
    s->pixmap_data_size = 0;

    s->redisplay_timer = NULL;
    s->redisplay_timer_set = FALSE;

    return TRUE;
}

static void
RootlessWrap(ScreenPtr pScreen)
{
    RootlessScreenRec *s = SCREENREC(pScreen);

#define WRAP(a) \
    if (pScreen->a) { \
        s->a = pScreen->a; \
    } else { \
        RL_DEBUG_MSG("null screen fn " #a "\n"); \
        s->a = NULL; \
    } \
    pScreen->a = Rootless##a

    WRAP(CreateScreenResources);
    WRAP(CloseScreen);
    WRAP(CreateGC);
    WRAP(CopyWindow);
    WRAP(PaintWindow);
    WRAP(GetImage);
    WRAP(SourceValidate);
    WRAP(CreateWindow);
    WRAP(DestroyWindow);
    WRAP(RealizeWindow);
    WRAP(UnrealizeWindow);
    WRAP(MoveWindow);
    WRAP(PositionWindow);
    WRAP(ResizeWindow);
    WRAP(RestackWindow);
    WRAP(ReparentWindow);
    WRAP(ChangeBorderWidth);
    WRAP(MarkOverlappedWindows);
    WRAP(ValidateTree);
    WRAP(ChangeWindowAttributes);
    WRAP(InstallColormap);
    WRAP(UninstallColormap);
    WRAP(StoreColors);

    WRAP(SetShape);

    {
        // Composite and Glyphs don't use normal screen wrapping
        PictureScreenPtr ps = GetPictureScreen(pScreen);

        s->Composite = ps->Composite;
        ps->Composite = RootlessComposite;
        s->Glyphs = ps->Glyphs;
        ps->Glyphs = RootlessGlyphs;
    }

    // WRAP(ClearToBackground); fixme put this back? useful for shaped wins?

#undef WRAP
}

/*
 * RootlessInit
 *  Called by the rootless implementation to initialize the rootless layer.
 *  Rootless wraps lots of stuff and needs a bunch of devPrivates.
 */
Bool
RootlessInit(ScreenPtr pScreen, RootlessFrameProcsPtr procs)
{
    RootlessScreenRec *s;

    if (!RootlessAllocatePrivates(pScreen))
        return FALSE;

    s = SCREENREC(pScreen);

    s->imp = procs;
    s->colormap = NULL;
    s->redisplay_expired = FALSE;

    RootlessWrap(pScreen);

    if (!RegisterBlockAndWakeupHandlers(RootlessBlockHandler,
                                        RootlessWakeupHandler,
                                        (void *) pScreen)) {
        return FALSE;
    }

    return TRUE;
}

void
RootlessUpdateRooted(Bool state)
{
    int i;

    if (!state) {
        for (i = 0; i < screenInfo.numScreens; i++)
            RootlessDisableRoot(screenInfo.screens[i]);
    }
    else {
        for (i = 0; i < screenInfo.numScreens; i++)
            RootlessEnableRoot(screenInfo.screens[i]);
    }
}
@


1.10
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d476 1
a476 1
    miPaintWindow(pWin, &pWin->borderClip, PW_BACKGROUND);
d672 1
@


1.9
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d606 1
a606 1
RootlessBlockHandler(pointer pbdata, OSTimePtr pTimeout, pointer pReadmask)
d619 1
a619 1
RootlessWakeupHandler(pointer data, int i, pointer LastSelectMask)
d731 1
a731 1
                                        (pointer) pScreen)) {
@


1.8
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d141 1
a141 1
RootlessCloseScreen(int i, ScreenPtr pScreen)
d157 1
a157 1
    return pScreen->CloseScreen(i, pScreen);
@


1.7
log
@Bugfix Update to xserver 1.11.3
@
text
@a31 1

d85 1
a85 1
    pPix = (*pScreen->GetScreenPixmap)(pScreen);
d87 2
a88 2
        pPix = (*pScreen->CreatePixmap)(pScreen, 0, 0, pScreen->rootDepth, 0);
        (*pScreen->SetScreenPixmap)(pPix);
a112 1

d126 1
a126 1
        ret = (*pScreen->CreateScreenResources)(pScreen);
a139 1

a159 1

d165 1
d177 1
a177 1
        RootlessStartDrawing((WindowPtr)pDrawable);
d194 4
a197 4
        x0 = max (x0, winRec->x);
        y0 = max (y0, winRec->y);
        x1 = min (x1, winRec->x + winRec->width);
        y1 = min (y1, winRec->y + winRec->height);
d210 1
a210 1
out:
a213 1

d227 2
a228 1
        WindowPtr pWin = (WindowPtr)pDrawable;
d232 2
a233 1
        pDrawable->pScreen->SourceValidate(pDrawable, x, y, w, h, subWindowMode);
d240 1
a240 1
                  INT16 xSrc, INT16 ySrc, INT16  xMask, INT16  yMask,
d247 9
a255 8
    if (pMask) {                        // pMask can be NULL
        maskWin = (pMask->pDrawable && pMask->pDrawable->type == DRAWABLE_WINDOW) ?
                  (WindowPtr)pMask->pDrawable : NULL;
    }
    srcWin  = (pSrc->pDrawable && pSrc->pDrawable->type  == DRAWABLE_WINDOW) ?
              (WindowPtr)pSrc->pDrawable  :  NULL;
    dstWin  = (pDst->pDrawable->type == DRAWABLE_WINDOW) ?
              (WindowPtr)pDst->pDrawable  :  NULL;
d260 1
a260 1
    if (srcWin  && IsFramedWindow(srcWin))
d264 1
a264 1
    if (dstWin  && IsFramedWindow(dstWin))
d268 1
a268 2
                  xSrc, ySrc, xMask, yMask,
                  xDst, yDst, width, height);
d270 1
a270 1
    if (dstWin  && IsFramedWindow(dstWin)) {
a277 1

d281 1
a281 1
               int nlist, GlyphListPtr list, GlyphPtr *glyphs)
d291 1
a291 1
             (WindowPtr)pSrc->pDrawable  :  NULL;
d293 1
a293 1
             (WindowPtr)pDst->pDrawable  :  NULL;
d295 4
a298 2
    if (srcWin && IsFramedWindow(srcWin)) RootlessStartDrawing(srcWin);
    if (dstWin && IsFramedWindow(dstWin)) RootlessStartDrawing(dstWin);
d342 4
a345 4
                    box.x1 = max (box.x1, x1);
                    box.y1 = max (box.y1, y1);
                    box.x2 = max (box.x2, x2);
                    box.y2 = max (box.y2, y2);
a357 1

d379 2
a380 1
    } else {
a391 1

d404 1
d414 1
a414 1
    else if (! IsTopLevel(pWin)) {
d428 2
a429 1
        if (ppLayerWin) *ppLayerWin = pWin;
d440 1
a440 1
                        SetWinSize (pChild);
d442 2
a443 2
                        SetBorderSize (pChild);
                    (* MarkWindow)(pChild);
d458 1
a458 1
            (* MarkWindow)(pWin->parent);
d468 3
a470 1
static void expose_1 (WindowPtr pWin) {
d472 1
a472 1
    
d475 1
a475 1
    
d477 1
a477 1
    
d479 6
a484 6
     include subwindow visibility. But I'm not so sure.. so we may
     be exposing too much.. */
    
    miSendExposures (pWin, &pWin->borderClip,
                     pWin->drawable.x, pWin->drawable.y);
    
d486 1
a486 1
        expose_1 (pChild);
d490 1
a490 1
RootlessScreenExpose (ScreenPtr pScreen)
d492 1
a492 1
    expose_1 (pScreen->root);
a494 1

d496 1
a496 1
RootlessGetColormap (ScreenPtr pScreen)
d498 1
a498 1
  RootlessScreenRec *s = SCREENREC (pScreen);
d500 1
a500 1
  return s->colormap;
d504 1
a504 1
RootlessInstallColormap (ColormapPtr pMap)
d506 2
a507 2
  ScreenPtr pScreen = pMap->pScreen;
  RootlessScreenRec *s = SCREENREC (pScreen);
d509 1
a509 1
  SCREEN_UNWRAP(pScreen, InstallColormap);
d511 5
a515 5
  if (s->colormap != pMap) {
    s->colormap = pMap;
    s->colormap_changed = TRUE;
    RootlessQueueRedisplay (pScreen);
  }
d517 1
a517 1
  pScreen->InstallColormap (pMap);
d519 1
a519 1
  SCREEN_WRAP (pScreen, InstallColormap);
d523 1
a523 1
RootlessUninstallColormap (ColormapPtr pMap)
d525 2
a526 2
  ScreenPtr pScreen = pMap->pScreen;
  RootlessScreenRec *s = SCREENREC (pScreen);
d528 1
a528 1
  SCREEN_UNWRAP(pScreen, UninstallColormap);
d530 2
a531 2
  if (s->colormap == pMap)
    s->colormap = NULL;
d533 1
a533 1
  pScreen->UninstallColormap (pMap);
d535 1
a535 1
  SCREEN_WRAP(pScreen, UninstallColormap);
d539 1
a539 1
RootlessStoreColors (ColormapPtr pMap, int ndef, xColorItem *pdef)
d541 2
a542 2
  ScreenPtr pScreen = pMap->pScreen;
  RootlessScreenRec *s = SCREENREC (pScreen);
d544 1
a544 1
  SCREEN_UNWRAP(pScreen, StoreColors);
d546 4
a549 4
  if (s->colormap == pMap && ndef > 0) {
    s->colormap_changed = TRUE;
    RootlessQueueRedisplay (pScreen);
  }
d551 1
a551 1
  pScreen->StoreColors (pMap, ndef, pdef);
d553 1
a553 1
  SCREEN_WRAP(pScreen, StoreColors);
a555 1

a578 1

d596 1
a596 2
                                          RootlessRedisplayCallback,
                                          screenRec);
a599 1

a617 1

a623 1

d629 2
a630 1
    if (!dixRegisterPrivateKey(&rootlessGCPrivateKeyRec, PRIVATE_GC, sizeof(RootlessGCRec)))
d636 2
a637 1
    if (!dixRegisterPrivateKey(&rootlessWindowOldPixmapPrivateKeyRec, PRIVATE_WINDOW, 0))
d641 2
a642 1
    if (! s) return FALSE;
a653 1

d696 1
a707 1

d713 2
a714 1
Bool RootlessInit(ScreenPtr pScreen, RootlessFrameProcsPtr procs)
d731 1
a731 2
                                        (pointer) pScreen))
    {
d738 3
a740 1
void RootlessUpdateRooted (Bool state) {
d742 2
a743 3
    
    if (!state)
    {
d745 1
a745 1
            RootlessDisableRoot (screenInfo.screens[i]);
d747 1
a747 2
    else
    {
d749 1
a749 1
            RootlessEnableRoot (screenInfo.screens[i]);
@


1.6
log
@Update to xserver 1.11.2
@
text
@d250 2
a251 2
        maskWin = (pMask->pDrawable->type == DRAWABLE_WINDOW) ?
                  (WindowPtr)pMask->pDrawable :  NULL;
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@d95 1
a95 2
        if (s->pixmap_data != NULL)
            free(s->pixmap_data);
d226 2
a227 1
RootlessSourceValidate(DrawablePtr pDrawable, int x, int y, int w, int h)
d235 1
a235 1
        pDrawable->pScreen->SourceValidate(pDrawable, x, y, w, h);
d328 1
a328 1
                box.y2 = box.y2 + glyph->info.height;
a455 1
            pFirst = pFirst->nextSib;
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d65 4
a68 9
static int rootlessGCPrivateKeyIndex;
DevPrivateKey rootlessGCPrivateKey = &rootlessGCPrivateKeyIndex;
static int rootlessScreenPrivateKeyIndex;
DevPrivateKey rootlessScreenPrivateKey = &rootlessScreenPrivateKeyIndex;
static int rootlessWindowPrivateKeyIndex;
DevPrivateKey rootlessWindowPrivateKey = &rootlessWindowPrivateKeyIndex;
static int rootlessWindowOldPixmapPrivateKeyIndex;
DevPrivateKey rootlessWindowOldPixmapPrivateKey = &rootlessWindowOldPixmapPrivateKeyIndex;

d96 1
a96 1
            xfree(s->pixmap_data);
d99 1
a99 1
        s->pixmap_data = xalloc(s->pixmap_data_size);
d155 1
a155 1
        xfree (s->pixmap_data);
d160 1
a160 1
    xfree(s);
a239 2
#ifdef RENDER

a358 2
#endif // RENDER

d439 1
a439 1
                    if (REGION_BROKEN (pScreen, &pChild->winSize))
d441 1
a441 1
                    if (REGION_BROKEN (pScreen, &pChild->borderSize))
d491 1
a491 1
    expose_1 (WindowTable[pScreen->myNum]);
d635 7
a641 2
    // no allocation needed for screen privates
    if (!dixRequestPrivate(rootlessGCPrivateKey, sizeof(RootlessGCRec)))
d644 1
a644 1
    s = xalloc(sizeof(RootlessScreenRec));
a696 1
#ifdef RENDER
a704 1
#endif
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d203 4
a206 4
        x0 = MAX (x0, winRec->x);
        y0 = MAX (y0, winRec->y);
        x1 = MIN (x1, winRec->x + winRec->width);
        y1 = MIN (y1, winRec->y + winRec->height);
d260 1
a260 1
    srcWin  = (pSrc->pDrawable->type  == DRAWABLE_WINDOW) ?
d300 1
a300 1
    srcWin = (pSrc->pDrawable->type == DRAWABLE_WINDOW) ?
d350 4
a353 4
                    box.x1 = MAX (box.x1, x1);
                    box.y1 = MAX (box.y1, y1);
                    box.x2 = MAX (box.x2, x2);
                    box.y2 = MAX (box.y2, y2);
d434 1
a434 1
        void (* MarkWindow)() = pScreen->MarkWindow;
d478 1
a478 1
void expose_1 (WindowPtr pWin) {
d484 1
a484 2
    (*pWin->drawable.pScreen->PaintWindowBackground) (pWin, &pWin->borderClip,
                                                      PW_BACKGROUND);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d65 8
a72 4
DevPrivateKey rootlessGCPrivateKey = &rootlessGCPrivateKey;
DevPrivateKey rootlessScreenPrivateKey = &rootlessScreenPrivateKey;
DevPrivateKey rootlessWindowPrivateKey = &rootlessWindowPrivateKey;
DevPrivateKey rootlessWindowOldPixmapPrivateKey = &rootlessWindowOldPixmapPrivateKey;
d478 27
a699 1
#ifdef SHAPE
a700 1
#endif
d747 15
@


1.1
log
@Initial revision
@
text
@d45 1
d65 4
a68 3
int rootlessGCPrivateIndex = -1;
int rootlessScreenPrivateIndex = -1;
int rootlessWindowPrivateIndex = -1;
d89 1
a89 1
        pPix = (*pScreen->CreatePixmap)(pScreen, 0, 0, pScreen->rootDepth);
d474 61
a612 11
    static unsigned long rootlessGeneration = 0;

    if (rootlessGeneration != serverGeneration) {
        rootlessScreenPrivateIndex = AllocateScreenPrivateIndex();
        if (rootlessScreenPrivateIndex == -1) return FALSE;
        rootlessGCPrivateIndex = AllocateGCPrivateIndex();
        if (rootlessGCPrivateIndex == -1) return FALSE;
        rootlessWindowPrivateIndex = AllocateWindowPrivateIndex();
        if (rootlessWindowPrivateIndex == -1) return FALSE;
        rootlessGeneration = serverGeneration;
    }
d615 1
a615 4
    if (!AllocateGCPrivate(pScreen, rootlessGCPrivateIndex,
                           sizeof(RootlessGCRec)))
        return FALSE;
    if (!AllocateWindowPrivate(pScreen, rootlessWindowPrivateIndex, 0))
d620 1
a620 1
    SCREENREC(pScreen) = s;
d635 1
a635 2
    RootlessScreenRec *s = (RootlessScreenRec*)
            pScreen->devPrivates[rootlessScreenPrivateIndex].ptr;
a648 2
    WRAP(PaintWindowBackground);
    WRAP(PaintWindowBorder);
d665 3
a684 1
    // WRAP(RestoreAreas); fixme put this back?
d702 1
a702 2
    s = (RootlessScreenRec*)
        pScreen->devPrivates[rootlessScreenPrivateIndex].ptr;
d705 2
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@
