head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.10
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.8
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.11.07.16.48.53;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	7pAEtF6Y5EgemkuY;

1.9
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.8;
commitid	Te1daavkBLskZ8gc;

1.8
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	cVXoV5PxI8YrEaVA;

1.7
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.33;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.03;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.03;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.06;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update to xserver 1.17.4.
tested by naddy@@
@
text
@/*
 * Graphics Context support for generic rootless X server
 */
/*
 * Copyright (c) 2001 Greg Parker. All Rights Reserved.
 * Copyright (c) 2002-2003 Torrey T. Lyons. All Rights Reserved.
 * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the sale,
 * use or other dealings in this Software without prior written authorization.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stddef.h>             /* For NULL */
#include "mi.h"
#include "scrnintstr.h"
#include "gcstruct.h"
#include "pixmapstr.h"
#include "windowstr.h"
#include "dixfontstr.h"
#include "mivalidate.h"
#include "fb.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "rootlessCommon.h"

// GC functions
static void RootlessValidateGC(GCPtr pGC, unsigned long changes,
                               DrawablePtr pDrawable);
static void RootlessChangeGC(GCPtr pGC, unsigned long mask);
static void RootlessCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst);
static void RootlessDestroyGC(GCPtr pGC);
static void RootlessChangeClip(GCPtr pGC, int type, void *pvalue, int nrects);
static void RootlessDestroyClip(GCPtr pGC);
static void RootlessCopyClip(GCPtr pgcDst, GCPtr pgcSrc);

Bool RootlessCreateGC(GCPtr pGC);

GCFuncs rootlessGCFuncs = {
    RootlessValidateGC,
    RootlessChangeGC,
    RootlessCopyGC,
    RootlessDestroyGC,
    RootlessChangeClip,
    RootlessDestroyClip,
    RootlessCopyClip,
};

// GC operations
static void RootlessFillSpans(DrawablePtr dst, GCPtr pGC, int nInit,
                              DDXPointPtr pptInit, int *pwidthInit, int sorted);
static void RootlessSetSpans(DrawablePtr dst, GCPtr pGC, char *pSrc,
                             DDXPointPtr pptInit, int *pwidthInit,
                             int nspans, int sorted);
static void RootlessPutImage(DrawablePtr dst, GCPtr pGC,
                             int depth, int x, int y, int w, int h,
                             int leftPad, int format, char *pBits);
static RegionPtr RootlessCopyArea(DrawablePtr pSrc, DrawablePtr dst, GCPtr pGC,
                                  int srcx, int srcy, int w, int h,
                                  int dstx, int dsty);
static RegionPtr RootlessCopyPlane(DrawablePtr pSrc, DrawablePtr dst,
                                   GCPtr pGC, int srcx, int srcy,
                                   int w, int h, int dstx, int dsty,
                                   unsigned long plane);
static void RootlessPolyPoint(DrawablePtr dst, GCPtr pGC,
                              int mode, int npt, DDXPointPtr pptInit);
static void RootlessPolylines(DrawablePtr dst, GCPtr pGC,
                              int mode, int npt, DDXPointPtr pptInit);
static void RootlessPolySegment(DrawablePtr dst, GCPtr pGC,
                                int nseg, xSegment * pSeg);
static void RootlessPolyRectangle(DrawablePtr dst, GCPtr pGC,
                                  int nRects, xRectangle *pRects);
static void RootlessPolyArc(DrawablePtr dst, GCPtr pGC, int narcs,
                            xArc * parcs);
static void RootlessFillPolygon(DrawablePtr dst, GCPtr pGC, int shape, int mode,
                                int count, DDXPointPtr pptInit);
static void RootlessPolyFillRect(DrawablePtr dst, GCPtr pGC, int nRectsInit,
                                 xRectangle *pRectsInit);
static void RootlessPolyFillArc(DrawablePtr dst, GCPtr pGC, int narcsInit,
                                xArc * parcsInit);
static int RootlessPolyText8(DrawablePtr dst, GCPtr pGC, int x, int y,
                             int count, char *chars);
static int RootlessPolyText16(DrawablePtr dst, GCPtr pGC, int x, int y,
                              int count, unsigned short *chars);
static void RootlessImageText8(DrawablePtr dst, GCPtr pGC, int x, int y,
                               int count, char *chars);
static void RootlessImageText16(DrawablePtr dst, GCPtr pGC, int x, int y,
                                int count, unsigned short *chars);
static void RootlessImageGlyphBlt(DrawablePtr dst, GCPtr pGC, int x, int y,
                                  unsigned int nglyphInit,
                                  CharInfoPtr * ppciInit, void *unused);
static void RootlessPolyGlyphBlt(DrawablePtr dst, GCPtr pGC, int x, int y,
                                 unsigned int nglyph, CharInfoPtr * ppci,
                                 void *pglyphBase);
static void RootlessPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr dst,
                               int dx, int dy, int xOrg, int yOrg);

static GCOps rootlessGCOps = {
    RootlessFillSpans,
    RootlessSetSpans,
    RootlessPutImage,
    RootlessCopyArea,
    RootlessCopyPlane,
    RootlessPolyPoint,
    RootlessPolylines,
    RootlessPolySegment,
    RootlessPolyRectangle,
    RootlessPolyArc,
    RootlessFillPolygon,
    RootlessPolyFillRect,
    RootlessPolyFillArc,
    RootlessPolyText8,
    RootlessPolyText16,
    RootlessImageText8,
    RootlessImageText16,
    RootlessImageGlyphBlt,
    RootlessPolyGlyphBlt,
    RootlessPushPixels
};

/*
   If ROOTLESS_PROTECT_ALPHA is set, we have to make sure that the alpha
   channel of the on screen windows is always opaque. fb makes this harder
   than it would otherwise be by noticing that a planemask of 0x00ffffff
   includes all bits when depth==24, and so it "optimizes" the planemask to
   0xffffffff. We work around this by temporarily setting depth=bpp while
   changing the GC.

   So the normal situation (in 32 bit mode) is that the planemask is
   0x00ffffff and thus fb leaves the alpha channel alone. The rootless
   implementation is responsible for setting the alpha channel opaque
   initially.

   Unfortunately drawing with a planemask that doesn't have all bits set
   normally causes fb to fall off its fastest paths when blitting and
   filling.  So we try to recognize when we can relax the planemask back to
   0xffffffff, and do that for the duration of the drawing operation,
   setting the alpha channel in fg/bg pixels to opaque at the same time. We
   can do this when drawing op is GXcopy. We can also do this when copying
   from another window since its alpha channel must also be opaque.

   The three macros below are used to implement this. Drawing ops that can
   potentially have their planemask relaxed look like:

   OP {
       GC_SAVE(gc);
       GCOP_UNWRAP(gc);

       ...

       if (canAccelxxx(..) && otherwise-suitable)
            GC_UNSET_PM(gc, dst);

       gc->funcs->OP(gc, ...);

       GC_RESTORE(gc, dst);
       GCOP_WRAP(gc);
   }

 */

#define GC_SAVE(pGC) 				\
    unsigned long _save_fg = (pGC)->fgPixel;	\
    unsigned long _save_bg = (pGC)->bgPixel;	\
    unsigned long _save_pm = (pGC)->planemask;	\
    Bool _changed = FALSE

#define GC_RESTORE(pGC, pDraw)					\
    do {							\
        if (_changed) {						\
            unsigned int depth = (pDraw)->depth;		\
            (pGC)->fgPixel = _save_fg;				\
            (pGC)->bgPixel = _save_bg;				\
            (pGC)->planemask = _save_pm;			\
            (pDraw)->depth = (pDraw)->bitsPerPixel;		\
            VALIDATE_GC(pGC, GCForeground | GCBackground |	\
                        GCPlaneMask, pDraw);			\
            (pDraw)->depth = depth;				\
        }							\
    } while (0)

#define GC_UNSET_PM(pGC, pDraw)						\
    do {								\
        unsigned int mask = RootlessAlphaMask ((pDraw)->bitsPerPixel);	\
        if (((pGC)->planemask & mask) != mask) {			\
            unsigned int depth = (pDraw)->depth;			\
            (pGC)->fgPixel |= mask;					\
            (pGC)->bgPixel |= mask;					\
            (pGC)->planemask |= mask;					\
            (pDraw)->depth = (pDraw)->bitsPerPixel;			\
            VALIDATE_GC(pGC, GCForeground |				\
                        GCBackground | GCPlaneMask, pDraw);		\
            (pDraw)->depth = depth;					\
            _changed = TRUE;						\
        }								\
    } while (0)

#define VALIDATE_GC(pGC, changes, pDrawable)				\
    do {								\
        pGC->funcs->ValidateGC(pGC, changes, pDrawable);		\
        if (((WindowPtr) pDrawable)->viewable) {			\
            gcrec->originalOps = pGC->ops;				\
        }								\
    } while(0)

static RootlessWindowRec *
canAccelBlit(DrawablePtr pDraw, GCPtr pGC)
{
    WindowPtr pTop;
    RootlessWindowRec *winRec;
    unsigned int pm;

    if (pGC->alu != GXcopy)
        return NULL;

    if (pDraw->type != DRAWABLE_WINDOW)
        return NULL;

    pm = ~RootlessAlphaMask(pDraw->bitsPerPixel);
    if ((pGC->planemask & pm) != pm)
        return NULL;

    pTop = TopLevelParent((WindowPtr) pDraw);
    if (pTop == NULL)
        return NULL;

    winRec = WINREC(pTop);
    if (winRec == NULL)
        return NULL;

    return winRec;
}

static inline RootlessWindowRec *
canAccelFill(DrawablePtr pDraw, GCPtr pGC)
{
    if (pGC->fillStyle != FillSolid)
        return NULL;

    return canAccelBlit(pDraw, pGC);
}

/*
 * Screen function to create a graphics context
 */
Bool
RootlessCreateGC(GCPtr pGC)
{
    RootlessGCRec *gcrec;
    RootlessScreenRec *s;
    Bool result;

    SCREEN_UNWRAP(pGC->pScreen, CreateGC);
    s = SCREENREC(pGC->pScreen);
    result = s->CreateGC(pGC);

    gcrec = (RootlessGCRec *)
        dixLookupPrivate(&pGC->devPrivates, rootlessGCPrivateKey);
    gcrec->originalOps = NULL;  // don't wrap ops yet
    gcrec->originalFuncs = pGC->funcs;
    pGC->funcs = &rootlessGCFuncs;

    SCREEN_WRAP(pGC->pScreen, CreateGC);
    return result;
}

/*
 * GC funcs
 *
 * These wrap lower level GC funcs.
 * ValidateGC wraps the GC ops iff dest is viewable.
 * All the others just unwrap and call.
 */

// GCFUNC_UNRAP assumes funcs have been wrapped and
// does not assume ops have been wrapped
#define GCFUNC_UNWRAP(pGC) \
    RootlessGCRec *gcrec = (RootlessGCRec *) \
	dixLookupPrivate(&(pGC)->devPrivates, rootlessGCPrivateKey); \
    (pGC)->funcs = gcrec->originalFuncs; \
    if (gcrec->originalOps) { \
        (pGC)->ops = gcrec->originalOps; \
}

#define GCFUNC_WRAP(pGC) \
    gcrec->originalFuncs = (pGC)->funcs; \
    (pGC)->funcs = &rootlessGCFuncs; \
    if (gcrec->originalOps) { \
        gcrec->originalOps = (pGC)->ops; \
        (pGC)->ops = &rootlessGCOps; \
}

static void
RootlessValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDrawable)
{
    GCFUNC_UNWRAP(pGC);

    gcrec->originalOps = NULL;

    if (pDrawable->type == DRAWABLE_WINDOW) {
#ifdef ROOTLESS_PROTECT_ALPHA
        unsigned int depth = pDrawable->depth;

        // We force a planemask so fb doesn't overwrite the alpha channel.
        // Left to its own devices, fb will optimize away the planemask.
        pDrawable->depth = pDrawable->bitsPerPixel;
        pGC->planemask &= ~RootlessAlphaMask(pDrawable->bitsPerPixel);
        VALIDATE_GC(pGC, changes | GCPlaneMask, pDrawable);
        pDrawable->depth = depth;
#else
        VALIDATE_GC(pGC, changes, pDrawable);
#endif
    }
    else {
        pGC->funcs->ValidateGC(pGC, changes, pDrawable);
    }

    GCFUNC_WRAP(pGC);
}

static void
RootlessChangeGC(GCPtr pGC, unsigned long mask)
{
    GCFUNC_UNWRAP(pGC);
    pGC->funcs->ChangeGC(pGC, mask);
    GCFUNC_WRAP(pGC);
}

static void
RootlessCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
{
    GCFUNC_UNWRAP(pGCDst);
    pGCDst->funcs->CopyGC(pGCSrc, mask, pGCDst);
    GCFUNC_WRAP(pGCDst);
}

static void
RootlessDestroyGC(GCPtr pGC)
{
    GCFUNC_UNWRAP(pGC);
    pGC->funcs->DestroyGC(pGC);
    GCFUNC_WRAP(pGC);
}

static void
RootlessChangeClip(GCPtr pGC, int type, void *pvalue, int nrects)
{
    GCFUNC_UNWRAP(pGC);
    pGC->funcs->ChangeClip(pGC, type, pvalue, nrects);
    GCFUNC_WRAP(pGC);
}

static void
RootlessDestroyClip(GCPtr pGC)
{
    GCFUNC_UNWRAP(pGC);
    pGC->funcs->DestroyClip(pGC);
    GCFUNC_WRAP(pGC);
}

static void
RootlessCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    GCFUNC_UNWRAP(pgcDst);
    pgcDst->funcs->CopyClip(pgcDst, pgcSrc);
    GCFUNC_WRAP(pgcDst);
}

/*
 * GC ops
 *
 * We can't use shadowfb because shadowfb assumes one pixmap
 * and our root window is a special case.
 * However, much of this code is copied from shadowfb.
 */

// assumes both funcs and ops are wrapped
#define GCOP_UNWRAP(pGC) \
    RootlessGCRec *gcrec = (RootlessGCRec *) \
        dixLookupPrivate(&(pGC)->devPrivates, rootlessGCPrivateKey); \
    const GCFuncs *saveFuncs = pGC->funcs; \
    (pGC)->funcs = gcrec->originalFuncs; \
    (pGC)->ops = gcrec->originalOps;

#define GCOP_WRAP(pGC) \
    gcrec->originalOps = (pGC)->ops; \
    (pGC)->funcs = saveFuncs; \
    (pGC)->ops = &rootlessGCOps;

static void
RootlessFillSpans(DrawablePtr dst, GCPtr pGC, int nInit,
                  DDXPointPtr pptInit, int *pwidthInit, int sorted)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("fill spans start ");

    if (nInit <= 0) {
        pGC->ops->FillSpans(dst, pGC, nInit, pptInit, pwidthInit, sorted);
    }
    else {
        DDXPointPtr ppt = pptInit;
        int *pwidth = pwidthInit;
        int i = nInit;
        BoxRec box;

        box.x1 = ppt->x;
        box.x2 = box.x1 + *pwidth;
        box.y2 = box.y1 = ppt->y;

        while (--i) {
            ppt++;
            pwidth++;
            if (box.x1 > ppt->x)
                box.x1 = ppt->x;
            if (box.x2 < (ppt->x + *pwidth))
                box.x2 = ppt->x + *pwidth;
            if (box.y1 > ppt->y)
                box.y1 = ppt->y;
            else if (box.y2 < ppt->y)
                box.y2 = ppt->y;
        }

        box.y2++;

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC)) {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->FillSpans(dst, pGC, nInit, pptInit, pwidthInit, sorted);

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("fill spans end\n");
}

static void
RootlessSetSpans(DrawablePtr dst, GCPtr pGC, char *pSrc,
                 DDXPointPtr pptInit, int *pwidthInit, int nspans, int sorted)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("set spans start ");

    if (nspans <= 0) {
        pGC->ops->SetSpans(dst, pGC, pSrc, pptInit, pwidthInit, nspans, sorted);
    }
    else {
        DDXPointPtr ppt = pptInit;
        int *pwidth = pwidthInit;
        int i = nspans;
        BoxRec box;

        box.x1 = ppt->x;
        box.x2 = box.x1 + *pwidth;
        box.y2 = box.y1 = ppt->y;

        while (--i) {
            ppt++;
            pwidth++;
            if (box.x1 > ppt->x)
                box.x1 = ppt->x;
            if (box.x2 < (ppt->x + *pwidth))
                box.x2 = ppt->x + *pwidth;
            if (box.y1 > ppt->y)
                box.y1 = ppt->y;
            else if (box.y2 < ppt->y)
                box.y2 = ppt->y;
        }

        box.y2++;

        RootlessStartDrawing((WindowPtr) dst);
        pGC->ops->SetSpans(dst, pGC, pSrc, pptInit, pwidthInit, nspans, sorted);

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("set spans end\n");
}

static void
RootlessPutImage(DrawablePtr dst, GCPtr pGC,
                 int depth, int x, int y, int w, int h,
                 int leftPad, int format, char *pBits)
{
    BoxRec box;

    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("put image start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PutImage(dst, pGC, depth, x, y, w, h, leftPad, format, pBits);

    box.x1 = x + dst->x;
    box.x2 = box.x1 + w;
    box.y1 = y + dst->y;
    box.y2 = box.y1 + h;

    TRIM_BOX(box, pGC);
    if (BOX_NOT_EMPTY(box))
        RootlessDamageBox((WindowPtr) dst, &box);

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("put image end\n");
}

/* changed area is *dest* rect */
static RegionPtr
RootlessCopyArea(DrawablePtr pSrc, DrawablePtr dst, GCPtr pGC,
                 int srcx, int srcy, int w, int h, int dstx, int dsty)
{
    RegionPtr result;
    BoxRec box;

    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);

    RL_DEBUG_MSG("copy area start (src 0x%x, dst 0x%x)", pSrc, dst);

    if (pSrc->type == DRAWABLE_WINDOW && IsFramedWindow((WindowPtr) pSrc)) {
        /* If both source and dest are windows, and we're doing
           a simple copy operation, we can remove the alpha-protecting
           planemask (since source has opaque alpha as well) */

        if (canAccelBlit(pSrc, pGC)) {
            GC_UNSET_PM(pGC, dst);
        }

        RootlessStartDrawing((WindowPtr) pSrc);
    }
    RootlessStartDrawing((WindowPtr) dst);
    result = pGC->ops->CopyArea(pSrc, dst, pGC, srcx, srcy, w, h, dstx, dsty);

    box.x1 = dstx + dst->x;
    box.x2 = box.x1 + w;
    box.y1 = dsty + dst->y;
    box.y2 = box.y1 + h;

    TRIM_BOX(box, pGC);
    if (BOX_NOT_EMPTY(box))
        RootlessDamageBox((WindowPtr) dst, &box);

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("copy area end\n");
    return result;
}

/* changed area is *dest* rect */
static RegionPtr
RootlessCopyPlane(DrawablePtr pSrc, DrawablePtr dst,
                  GCPtr pGC, int srcx, int srcy,
                  int w, int h, int dstx, int dsty, unsigned long plane)
{
    RegionPtr result;
    BoxRec box;

    GCOP_UNWRAP(pGC);

    RL_DEBUG_MSG("copy plane start ");

    if (pSrc->type == DRAWABLE_WINDOW && IsFramedWindow((WindowPtr) pSrc)) {
        RootlessStartDrawing((WindowPtr) pSrc);
    }
    RootlessStartDrawing((WindowPtr) dst);
    result = pGC->ops->CopyPlane(pSrc, dst, pGC, srcx, srcy, w, h,
                                 dstx, dsty, plane);

    box.x1 = dstx + dst->x;
    box.x2 = box.x1 + w;
    box.y1 = dsty + dst->y;
    box.y2 = box.y1 + h;

    TRIM_BOX(box, pGC);
    if (BOX_NOT_EMPTY(box))
        RootlessDamageBox((WindowPtr) dst, &box);

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("copy plane end\n");
    return result;
}

// Options for size of changed area:
//  0 = box per point
//  1 = big box around all points
//  2 = accumulate point in 20 pixel radius
#define ROOTLESS_CHANGED_AREA 1
#define abs(a) ((a) > 0 ? (a) : -(a))

/* changed area is box around all points */
static void
RootlessPolyPoint(DrawablePtr dst, GCPtr pGC,
                  int mode, int npt, DDXPointPtr pptInit)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("polypoint start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PolyPoint(dst, pGC, mode, npt, pptInit);

    if (npt > 0) {
#if ROOTLESS_CHANGED_AREA==0
        // box per point
        BoxRec box;

        while (npt) {
            box.x1 = pptInit->x;
            box.y1 = pptInit->y;
            box.x2 = box.x1 + 1;
            box.y2 = box.y1 + 1;

            TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
            if (BOX_NOT_EMPTY(box))
                RootlessDamageBox((WindowPtr) dst, &box);

            npt--;
            pptInit++;
        }

#elif ROOTLESS_CHANGED_AREA==1
        // one big box
        BoxRec box;

        box.x2 = box.x1 = pptInit->x;
        box.y2 = box.y1 = pptInit->y;
        while (--npt) {
            pptInit++;
            if (box.x1 > pptInit->x)
                box.x1 = pptInit->x;
            else if (box.x2 < pptInit->x)
                box.x2 = pptInit->x;
            if (box.y1 > pptInit->y)
                box.y1 = pptInit->y;
            else if (box.y2 < pptInit->y)
                box.y2 = pptInit->y;
        }

        box.x2++;
        box.y2++;

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);

#elif ROOTLESS_CHANGED_AREA==2
        // clever(?) method: accumulate point in 20-pixel radius
        BoxRec box;
        int firstx, firsty;

        box.x2 = box.x1 = firstx = pptInit->x;
        box.y2 = box.y1 = firsty = pptInit->y;
        while (--npt) {
            pptInit++;
            if (abs(pptInit->x - firstx) > 20 || abs(pptInit->y - firsty) > 20) {
                box.x2++;
                box.y2++;
                TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
                if (BOX_NOT_EMPTY(box))
                    RootlessDamageBox((WindowPtr) dst, &box);
                box.x2 = box.x1 = firstx = pptInit->x;
                box.y2 = box.y1 = firsty = pptInit->y;
            }
            else {
                if (box.x1 > pptInit->x)
                    box.x1 = pptInit->x;
                else if (box.x2 < pptInit->x)
                    box.x2 = pptInit->x;
                if (box.y1 > pptInit->y)
                    box.y1 = pptInit->y;
                else if (box.y2 < pptInit->y)
                    box.y2 = pptInit->y;
            }
        }
        box.x2++;
        box.y2++;
        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
#endif                          /* ROOTLESS_CHANGED_AREA */
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("polypoint end\n");
}

#undef ROOTLESS_CHANGED_AREA

/* changed area is box around each line */
static void
RootlessPolylines(DrawablePtr dst, GCPtr pGC,
                  int mode, int npt, DDXPointPtr pptInit)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("poly lines start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->Polylines(dst, pGC, mode, npt, pptInit);

    if (npt > 0) {
        BoxRec box;
        int extra = pGC->lineWidth >> 1;

        box.x2 = box.x1 = pptInit->x;
        box.y2 = box.y1 = pptInit->y;

        if (npt > 1) {
            if (pGC->joinStyle == JoinMiter)
                extra = 6 * pGC->lineWidth;
            else if (pGC->capStyle == CapProjecting)
                extra = pGC->lineWidth;
        }

        if (mode == CoordModePrevious) {
            int x = box.x1;
            int y = box.y1;

            while (--npt) {
                pptInit++;
                x += pptInit->x;
                y += pptInit->y;
                if (box.x1 > x)
                    box.x1 = x;
                else if (box.x2 < x)
                    box.x2 = x;
                if (box.y1 > y)
                    box.y1 = y;
                else if (box.y2 < y)
                    box.y2 = y;
            }
        }
        else {
            while (--npt) {
                pptInit++;
                if (box.x1 > pptInit->x)
                    box.x1 = pptInit->x;
                else if (box.x2 < pptInit->x)
                    box.x2 = pptInit->x;
                if (box.y1 > pptInit->y)
                    box.y1 = pptInit->y;
                else if (box.y2 < pptInit->y)
                    box.y2 = pptInit->y;
            }
        }

        box.x2++;
        box.y2++;

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("poly lines end\n");
}

/* changed area is box around each line segment */
static void
RootlessPolySegment(DrawablePtr dst, GCPtr pGC, int nseg, xSegment * pSeg)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("poly segment start (win 0x%x)", dst);

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PolySegment(dst, pGC, nseg, pSeg);

    if (nseg > 0) {
        BoxRec box;
        int extra = pGC->lineWidth;

        if (pGC->capStyle != CapProjecting)
            extra >>= 1;

        if (pSeg->x2 > pSeg->x1) {
            box.x1 = pSeg->x1;
            box.x2 = pSeg->x2;
        }
        else {
            box.x2 = pSeg->x1;
            box.x1 = pSeg->x2;
        }

        if (pSeg->y2 > pSeg->y1) {
            box.y1 = pSeg->y1;
            box.y2 = pSeg->y2;
        }
        else {
            box.y2 = pSeg->y1;
            box.y1 = pSeg->y2;
        }

        while (--nseg) {
            pSeg++;
            if (pSeg->x2 > pSeg->x1) {
                if (pSeg->x1 < box.x1)
                    box.x1 = pSeg->x1;
                if (pSeg->x2 > box.x2)
                    box.x2 = pSeg->x2;
            }
            else {
                if (pSeg->x2 < box.x1)
                    box.x1 = pSeg->x2;
                if (pSeg->x1 > box.x2)
                    box.x2 = pSeg->x1;
            }
            if (pSeg->y2 > pSeg->y1) {
                if (pSeg->y1 < box.y1)
                    box.y1 = pSeg->y1;
                if (pSeg->y2 > box.y2)
                    box.y2 = pSeg->y2;
            }
            else {
                if (pSeg->y2 < box.y1)
                    box.y1 = pSeg->y2;
                if (pSeg->y1 > box.y2)
                    box.y2 = pSeg->y1;
            }
        }

        box.x2++;
        box.y2++;

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("poly segment end\n");
}

/* changed area is box around each line (not entire rects) */
static void
RootlessPolyRectangle(DrawablePtr dst, GCPtr pGC,
                      int nRects, xRectangle *pRects)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("poly rectangle start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PolyRectangle(dst, pGC, nRects, pRects);

    if (nRects > 0) {
        BoxRec box;
        int offset1, offset2, offset3;

        offset2 = pGC->lineWidth;
        if (!offset2)
            offset2 = 1;
        offset1 = offset2 >> 1;
        offset3 = offset2 - offset1;

        while (nRects--) {
            box.x1 = pRects->x - offset1;
            box.y1 = pRects->y - offset1;
            box.x2 = box.x1 + pRects->width + offset2;
            box.y2 = box.y1 + offset2;
            TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
            if (BOX_NOT_EMPTY(box))
                RootlessDamageBox((WindowPtr) dst, &box);

            box.x1 = pRects->x - offset1;
            box.y1 = pRects->y + offset3;
            box.x2 = box.x1 + offset2;
            box.y2 = box.y1 + pRects->height - offset2;
            TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
            if (BOX_NOT_EMPTY(box))
                RootlessDamageBox((WindowPtr) dst, &box);

            box.x1 = pRects->x + pRects->width - offset1;
            box.y1 = pRects->y + offset3;
            box.x2 = box.x1 + offset2;
            box.y2 = box.y1 + pRects->height - offset2;
            TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
            if (BOX_NOT_EMPTY(box))
                RootlessDamageBox((WindowPtr) dst, &box);

            box.x1 = pRects->x - offset1;
            box.y1 = pRects->y + pRects->height - offset1;
            box.x2 = box.x1 + pRects->width + offset2;
            box.y2 = box.y1 + offset2;
            TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
            if (BOX_NOT_EMPTY(box))
                RootlessDamageBox((WindowPtr) dst, &box);

            pRects++;
        }
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("poly rectangle end\n");
}

/* changed area is box around each arc (assumes all arcs are 360 degrees) */
static void
RootlessPolyArc(DrawablePtr dst, GCPtr pGC, int narcs, xArc * parcs)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("poly arc start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PolyArc(dst, pGC, narcs, parcs);

    if (narcs > 0) {
        int extra = pGC->lineWidth >> 1;
        BoxRec box;

        box.x1 = parcs->x;
        box.x2 = box.x1 + parcs->width;
        box.y1 = parcs->y;
        box.y2 = box.y1 + parcs->height;

        /* should I break these up instead ? */

        while (--narcs) {
            parcs++;
            if (box.x1 > parcs->x)
                box.x1 = parcs->x;
            if (box.x2 < (parcs->x + parcs->width))
                box.x2 = parcs->x + parcs->width;
            if (box.y1 > parcs->y)
                box.y1 = parcs->y;
            if (box.y2 < (parcs->y + parcs->height))
                box.y2 = parcs->y + parcs->height;
        }

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        box.x2++;
        box.y2++;

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("poly arc end\n");
}

/* changed area is box around each poly */
static void
RootlessFillPolygon(DrawablePtr dst, GCPtr pGC,
                    int shape, int mode, int count, DDXPointPtr pptInit)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("fill poly start (win 0x%x, fillStyle 0x%x)", dst,
                 pGC->fillStyle);

    if (count <= 2) {
        pGC->ops->FillPolygon(dst, pGC, shape, mode, count, pptInit);
    }
    else {
        DDXPointPtr ppt = pptInit;
        int i = count;
        BoxRec box;

        box.x2 = box.x1 = ppt->x;
        box.y2 = box.y1 = ppt->y;

        if (mode != CoordModeOrigin) {
            int x = box.x1;
            int y = box.y1;

            while (--i) {
                ppt++;
                x += ppt->x;
                y += ppt->y;
                if (box.x1 > x)
                    box.x1 = x;
                else if (box.x2 < x)
                    box.x2 = x;
                if (box.y1 > y)
                    box.y1 = y;
                else if (box.y2 < y)
                    box.y2 = y;
            }
        }
        else {
            while (--i) {
                ppt++;
                if (box.x1 > ppt->x)
                    box.x1 = ppt->x;
                else if (box.x2 < ppt->x)
                    box.x2 = ppt->x;
                if (box.y1 > ppt->y)
                    box.y1 = ppt->y;
                else if (box.y2 < ppt->y)
                    box.y2 = ppt->y;
            }
        }

        box.x2++;
        box.y2++;

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC)) {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->FillPolygon(dst, pGC, shape, mode, count, pptInit);

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("fill poly end\n");
}

/* changed area is the rects */
static void
RootlessPolyFillRect(DrawablePtr dst, GCPtr pGC,
                     int nRectsInit, xRectangle *pRectsInit)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("fill rect start (win 0x%x, fillStyle 0x%x)", dst,
                 pGC->fillStyle);

    if (nRectsInit <= 0) {
        pGC->ops->PolyFillRect(dst, pGC, nRectsInit, pRectsInit);
    }
    else {
        BoxRec box;
        xRectangle *pRects = pRectsInit;
        int nRects = nRectsInit;

        box.x1 = pRects->x;
        box.x2 = box.x1 + pRects->width;
        box.y1 = pRects->y;
        box.y2 = box.y1 + pRects->height;

        while (--nRects) {
            pRects++;
            if (box.x1 > pRects->x)
                box.x1 = pRects->x;
            if (box.x2 < (pRects->x + pRects->width))
                box.x2 = pRects->x + pRects->width;
            if (box.y1 > pRects->y)
                box.y1 = pRects->y;
            if (box.y2 < (pRects->y + pRects->height))
                box.y2 = pRects->y + pRects->height;
        }

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC)) {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->PolyFillRect(dst, pGC, nRectsInit, pRectsInit);

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("fill rect end\n");
}

/* changed area is box around each arc (assuming arcs are all 360 degrees) */
static void
RootlessPolyFillArc(DrawablePtr dst, GCPtr pGC, int narcsInit, xArc * parcsInit)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("fill arc start ");

    if (narcsInit > 0) {
        BoxRec box;
        int narcs = narcsInit;
        xArc *parcs = parcsInit;

        box.x1 = parcs->x;
        box.x2 = box.x1 + parcs->width;
        box.y1 = parcs->y;
        box.y2 = box.y1 + parcs->height;

        /* should I break these up instead ? */

        while (--narcs) {
            parcs++;
            if (box.x1 > parcs->x)
                box.x1 = parcs->x;
            if (box.x2 < (parcs->x + parcs->width))
                box.x2 = parcs->x + parcs->width;
            if (box.y1 > parcs->y)
                box.y1 = parcs->y;
            if (box.y2 < (parcs->y + parcs->height))
                box.y2 = parcs->y + parcs->height;
        }

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC)) {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->PolyFillArc(dst, pGC, narcsInit, parcsInit);

        TRIM_AND_TRANSLATE_BOX(box, dst, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }
    else {
        pGC->ops->PolyFillArc(dst, pGC, narcsInit, parcsInit);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("fill arc end\n");
}

static void
RootlessImageText8(DrawablePtr dst, GCPtr pGC,
                   int x, int y, int count, char *chars)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("imagetext8 start ");

    if (count > 0) {
        int top, bot, Min, Max;
        BoxRec box;

        top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
        bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

        Min = count * FONTMINBOUNDS(pGC->font, characterWidth);
        if (Min > 0)
            Min = 0;
        Max = count * FONTMAXBOUNDS(pGC->font, characterWidth);
        if (Max < 0)
            Max = 0;

        /* ugh */
        box.x1 = dst->x + x + Min + FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = dst->x + x + Max + FONTMAXBOUNDS(pGC->font, rightSideBearing);

        box.y1 = dst->y + y - top;
        box.y2 = dst->y + y + bot;

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC)) {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->ImageText8(dst, pGC, x, y, count, chars);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }
    else {
        pGC->ops->ImageText8(dst, pGC, x, y, count, chars);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("imagetext8 end\n");
}

static int
RootlessPolyText8(DrawablePtr dst, GCPtr pGC,
                  int x, int y, int count, char *chars)
{
    int width;                  // the result, sorta

    GCOP_UNWRAP(pGC);

    RL_DEBUG_MSG("polytext8 start ");

    RootlessStartDrawing((WindowPtr) dst);
    width = pGC->ops->PolyText8(dst, pGC, x, y, count, chars);
    width -= x;

    if (width > 0) {
        BoxRec box;

        /* ugh */
        box.x1 = dst->x + x + FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = dst->x + x + FONTMAXBOUNDS(pGC->font, rightSideBearing);

        if (count > 1) {
            if (width > 0)
                box.x2 += width;
            else
                box.x1 += width;
        }

        box.y1 = dst->y + y - FONTMAXBOUNDS(pGC->font, ascent);
        box.y2 = dst->y + y + FONTMAXBOUNDS(pGC->font, descent);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("polytext8 end\n");
    return width + x;
}

static void
RootlessImageText16(DrawablePtr dst, GCPtr pGC,
                    int x, int y, int count, unsigned short *chars)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("imagetext16 start ");

    if (count > 0) {
        int top, bot, Min, Max;
        BoxRec box;

        top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
        bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

        Min = count * FONTMINBOUNDS(pGC->font, characterWidth);
        if (Min > 0)
            Min = 0;
        Max = count * FONTMAXBOUNDS(pGC->font, characterWidth);
        if (Max < 0)
            Max = 0;

        /* ugh */
        box.x1 = dst->x + x + Min + FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = dst->x + x + Max + FONTMAXBOUNDS(pGC->font, rightSideBearing);

        box.y1 = dst->y + y - top;
        box.y2 = dst->y + y + bot;

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC)) {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->ImageText16(dst, pGC, x, y, count, chars);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }
    else {
        pGC->ops->ImageText16(dst, pGC, x, y, count, chars);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("imagetext16 end\n");
}

static int
RootlessPolyText16(DrawablePtr dst, GCPtr pGC,
                   int x, int y, int count, unsigned short *chars)
{
    int width;                  // the result, sorta

    GCOP_UNWRAP(pGC);

    RL_DEBUG_MSG("polytext16 start ");

    RootlessStartDrawing((WindowPtr) dst);
    width = pGC->ops->PolyText16(dst, pGC, x, y, count, chars);
    width -= x;

    if (width > 0) {
        BoxRec box;

        /* ugh */
        box.x1 = dst->x + x + FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = dst->x + x + FONTMAXBOUNDS(pGC->font, rightSideBearing);

        if (count > 1) {
            if (width > 0)
                box.x2 += width;
            else
                box.x1 += width;
        }

        box.y1 = dst->y + y - FONTMAXBOUNDS(pGC->font, ascent);
        box.y2 = dst->y + y + FONTMAXBOUNDS(pGC->font, descent);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("polytext16 end\n");
    return width + x;
}

static void
RootlessImageGlyphBlt(DrawablePtr dst, GCPtr pGC,
                      int x, int y, unsigned int nglyphInit,
                      CharInfoPtr * ppciInit, void *unused)
{
    GC_SAVE(pGC);
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("imageglyph start ");

    if (nglyphInit > 0) {
        int top, bot, width = 0;
        BoxRec box;
        unsigned int nglyph = nglyphInit;
        CharInfoPtr *ppci = ppciInit;

        top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
        bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

        box.x1 = ppci[0]->metrics.leftSideBearing;
        if (box.x1 > 0)
            box.x1 = 0;
        box.x2 = ppci[nglyph - 1]->metrics.rightSideBearing -
            ppci[nglyph - 1]->metrics.characterWidth;
        if (box.x2 < 0)
            box.x2 = 0;

        box.x2 += dst->x + x;
        box.x1 += dst->x + x;

        while (nglyph--) {
            width += (*ppci)->metrics.characterWidth;
            ppci++;
        }

        if (width > 0)
            box.x2 += width;
        else
            box.x1 += width;

        box.y1 = dst->y + y - top;
        box.y2 = dst->y + y + bot;

        RootlessStartDrawing((WindowPtr) dst);

        if (canAccelFill(dst, pGC)) {
            GC_UNSET_PM(pGC, dst);
        }

        pGC->ops->ImageGlyphBlt(dst, pGC, x, y, nglyphInit, ppciInit, unused);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }
    else {
        pGC->ops->ImageGlyphBlt(dst, pGC, x, y, nglyphInit, ppciInit, unused);
    }

    GC_RESTORE(pGC, dst);
    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("imageglyph end\n");
}

static void
RootlessPolyGlyphBlt(DrawablePtr dst, GCPtr pGC,
                     int x, int y, unsigned int nglyph,
                     CharInfoPtr * ppci, void *pglyphBase)
{
    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("polyglyph start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PolyGlyphBlt(dst, pGC, x, y, nglyph, ppci, pglyphBase);

    if (nglyph > 0) {
        BoxRec box;

        /* ugh */
        box.x1 = dst->x + x + ppci[0]->metrics.leftSideBearing;
        box.x2 = dst->x + x + ppci[nglyph - 1]->metrics.rightSideBearing;

        if (nglyph > 1) {
            int width = 0;

            while (--nglyph) {
                width += (*ppci)->metrics.characterWidth;
                ppci++;
            }

            if (width > 0)
                box.x2 += width;
            else
                box.x1 += width;
        }

        box.y1 = dst->y + y - FONTMAXBOUNDS(pGC->font, ascent);
        box.y2 = dst->y + y + FONTMAXBOUNDS(pGC->font, descent);

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            RootlessDamageBox((WindowPtr) dst, &box);
    }

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("polyglyph end\n");
}

/* changed area is in dest */
static void
RootlessPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr dst,
                   int dx, int dy, int xOrg, int yOrg)
{
    BoxRec box;

    GCOP_UNWRAP(pGC);
    RL_DEBUG_MSG("push pixels start ");

    RootlessStartDrawing((WindowPtr) dst);
    pGC->ops->PushPixels(pGC, pBitMap, dst, dx, dy, xOrg, yOrg);

    box.x1 = xOrg + dst->x;
    box.x2 = box.x1 + dx;
    box.y1 = yOrg + dst->y;
    box.y2 = box.y1 + dy;

    TRIM_BOX(box, pGC);
    if (BOX_NOT_EMPTY(box))
        RootlessDamageBox((WindowPtr) dst, &box);

    GCOP_WRAP(pGC);
    RL_DEBUG_MSG("push pixels end\n");
}
@


1.9
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d406 1
a406 1
    GCFuncs *saveFuncs = pGC->funcs; \
@


1.8
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d300 1
a300 1
// GCFUNC_UNRAP assumes funcs have been wrapped and 
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@d58 1
a58 1
static void RootlessChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects);
d116 1
a116 1
                                  CharInfoPtr * ppciInit, pointer unused);
d119 1
a119 1
                                 pointer pglyphBase);
d371 1
a371 1
RootlessChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects)
d1359 1
a1359 1
                      CharInfoPtr * ppciInit, pointer unused)
d1422 1
a1422 1
                     CharInfoPtr * ppci, pointer pglyphBase)
@


1.6
log
@Update to xserver 1.11.2
@
text
@d36 1
a36 1
#include <stddef.h> /* For NULL */
a51 1

d58 1
a58 2
static void RootlessChangeClip(GCPtr pGC, int type, pointer pvalue,
                               int nrects);
d76 1
a76 2
			      DDXPointPtr pptInit, int *pwidthInit, 
			      int sorted);
d78 2
a79 2
			     DDXPointPtr pptInit, int *pwidthInit,
			     int nspans, int sorted);
d81 2
a82 2
			     int depth, int x, int y, int w, int h,
			     int leftPad, int format, char *pBits);
d84 2
a85 2
				  int srcx, int srcy, int w, int h,
				  int dstx, int dsty);
d95 1
a95 1
                                int nseg, xSegment *pSeg);
d98 22
a119 22
static void RootlessPolyArc(DrawablePtr dst, GCPtr pGC, int narcs, xArc *parcs);
static void RootlessFillPolygon(DrawablePtr dst, GCPtr pGC,
                                int shape, int mode, int count,
                                DDXPointPtr pptInit);
static void RootlessPolyFillRect(DrawablePtr dst, GCPtr pGC,
                                 int nRectsInit, xRectangle *pRectsInit);
static void RootlessPolyFillArc(DrawablePtr dst, GCPtr pGC,
                                int narcsInit, xArc *parcsInit);
static int RootlessPolyText8(DrawablePtr dst, GCPtr pGC,
			     int x, int y, int count, char *chars);
static int RootlessPolyText16(DrawablePtr dst, GCPtr pGC,
			      int x, int y, int count, unsigned short *chars);
static void RootlessImageText8(DrawablePtr dst, GCPtr pGC,
                               int x, int y, int count, char *chars);
static void RootlessImageText16(DrawablePtr dst, GCPtr pGC,
                                int x, int y, int count, unsigned short *chars);
static void RootlessImageGlyphBlt(DrawablePtr dst, GCPtr pGC,
                                  int x, int y, unsigned int nglyphInit,
                                  CharInfoPtr *ppciInit, pointer unused);
static void RootlessPolyGlyphBlt(DrawablePtr dst, GCPtr pGC,
                                 int x, int y, unsigned int nglyph,
                                 CharInfoPtr *ppci, pointer pglyphBase);
d121 1
a121 2
			       int dx, int dy, int xOrg, int yOrg);

d232 1
a232 1
canAccelBlit (DrawablePtr pDraw, GCPtr pGC)
a267 1

d283 2
a284 2
	dixLookupPrivate(&pGC->devPrivates, rootlessGCPrivateKey);
    gcrec->originalOps = NULL; // don't wrap ops yet
a291 1

a317 1

d325 1
a325 2
    if (pDrawable->type == DRAWABLE_WINDOW)
    {
d338 2
a339 1
    } else {
d346 2
a347 1
static void RootlessChangeGC(GCPtr pGC, unsigned long mask)
d354 2
a355 1
static void RootlessCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
d362 2
a363 1
static void RootlessDestroyGC(GCPtr pGC)
d370 2
a371 1
static void RootlessChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects)
d378 2
a379 1
static void RootlessDestroyClip(GCPtr pGC)
d386 2
a387 1
static void RootlessCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
a393 1

d425 2
a426 1
    } else {
d453 1
a453 2
        if (canAccelFill(dst, pGC))
        {
d461 1
a461 1
            RootlessDamageBox ((WindowPtr) dst, &box);
d471 1
a471 2
                 DDXPointPtr pptInit, int *pwidthInit,
                 int nspans, int sorted)
d477 3
a479 3
        pGC->ops->SetSpans(dst, pGC, pSrc, pptInit, pwidthInit,
                           nspans, sorted);
    } else {
d505 1
a505 2
        pGC->ops->SetSpans(dst, pGC, pSrc, pptInit, pwidthInit,
                           nspans, sorted);
d509 1
a509 1
            RootlessDamageBox ((WindowPtr) dst, &box);
d526 1
a526 1
    pGC->ops->PutImage(dst, pGC, depth, x,y,w,h, leftPad, format, pBits);
d535 1
a535 1
        RootlessDamageBox ((WindowPtr) dst, &box);
d544 1
a544 2
                 int srcx, int srcy, int w, int h,
                 int dstx, int dsty)
d554 1
a554 1
    if (pSrc->type == DRAWABLE_WINDOW && IsFramedWindow((WindowPtr)pSrc)) {
d559 1
a559 2
        if (canAccelBlit(pSrc, pGC))
        {
d575 1
a575 1
        RootlessDamageBox ((WindowPtr) dst, &box);
d584 4
a587 4
static RegionPtr RootlessCopyPlane(DrawablePtr pSrc, DrawablePtr dst,
                                   GCPtr pGC, int srcx, int srcy,
                                   int w, int h, int dstx, int dsty,
                                   unsigned long plane)
d596 1
a596 1
    if (pSrc->type == DRAWABLE_WINDOW && IsFramedWindow((WindowPtr)pSrc)) {
d610 1
a610 1
        RootlessDamageBox ((WindowPtr) dst, &box);
d625 3
a627 2
static void RootlessPolyPoint(DrawablePtr dst, GCPtr pGC,
                              int mode, int npt, DDXPointPtr pptInit)
d648 1
a648 1
                RootlessDamageBox ((WindowPtr) dst, &box);
d677 1
a677 1
            RootlessDamageBox ((WindowPtr) dst, &box);
d688 1
a688 2
            if (abs(pptInit->x - firstx) > 20 ||
                abs(pptInit->y - firsty) > 20) {
d693 1
a693 1
                    RootlessDamageBox ((WindowPtr) dst, &box);
d696 10
a705 5
            } else {
                if (box.x1 > pptInit->x) box.x1 = pptInit->x;
                else if (box.x2 < pptInit->x) box.x2 = pptInit->x;
                if (box.y1 > pptInit->y) box.y1 = pptInit->y;
                else if (box.y2 < pptInit->y) box.y2 = pptInit->y;
d713 1
a713 1
#endif  /* ROOTLESS_CHANGED_AREA */
d723 3
a725 2
static void RootlessPolylines(DrawablePtr dst, GCPtr pGC,
                              int mode, int npt, DDXPointPtr pptInit)
d764 2
a765 1
        } else {
d791 1
a791 1
            RootlessDamageBox ((WindowPtr) dst, &box);
d799 2
a800 2
static void RootlessPolySegment(DrawablePtr dst, GCPtr pGC,
                                int nseg, xSegment *pSeg)
d813 1
a813 1
        extra >>= 1;
d818 2
a819 1
        } else {
d827 2
a828 1
        } else {
d836 10
a845 5
                if (pSeg->x1 < box.x1) box.x1 = pSeg->x1;
                if (pSeg->x2 > box.x2) box.x2 = pSeg->x2;
            } else {
                if (pSeg->x2 < box.x1) box.x1 = pSeg->x2;
                if (pSeg->x1 > box.x2) box.x2 = pSeg->x1;
d848 10
a857 5
                if (pSeg->y1 < box.y1) box.y1 = pSeg->y1;
                if (pSeg->y2 > box.y2) box.y2 = pSeg->y2;
            } else {
                if (pSeg->y2 < box.y1) box.y1 = pSeg->y2;
                if (pSeg->y1 > box.y2) box.y2 = pSeg->y1;
d873 1
a873 1
            RootlessDamageBox ((WindowPtr) dst, &box);
d881 3
a883 2
static void RootlessPolyRectangle(DrawablePtr dst, GCPtr pGC,
                                  int nRects, xRectangle *pRects)
d896 2
a897 1
        if (!offset2) offset2 = 1;
d908 1
a908 1
                RootlessDamageBox ((WindowPtr) dst, &box);
d916 1
a916 1
                RootlessDamageBox ((WindowPtr) dst, &box);
d924 1
a924 1
                RootlessDamageBox ((WindowPtr) dst, &box);
d932 1
a932 1
                RootlessDamageBox ((WindowPtr) dst, &box);
a941 1

d943 2
a944 1
static void RootlessPolyArc(DrawablePtr dst, GCPtr pGC, int narcs, xArc *parcs)
d987 1
a987 1
            RootlessDamageBox ((WindowPtr) dst, &box);
a993 1

d995 3
a997 3
static void RootlessFillPolygon(DrawablePtr dst, GCPtr pGC,
                                int shape, int mode, int count,
                                DDXPointPtr pptInit)
d1006 2
a1007 1
    } else {
d1032 2
a1033 1
        } else {
d1052 1
a1052 2
        if (canAccelFill(dst, pGC))
        {
d1060 1
a1060 1
            RootlessDamageBox ((WindowPtr) dst, &box);
d1069 3
a1071 2
static void RootlessPolyFillRect(DrawablePtr dst, GCPtr pGC,
                                 int nRectsInit, xRectangle *pRectsInit)
d1080 2
a1081 1
    } else {
d1104 2
a1105 3
 
        if (canAccelFill(dst, pGC))
        {
d1109 1
a1109 1
       pGC->ops->PolyFillRect(dst, pGC, nRectsInit, pRectsInit);
d1113 1
a1113 1
            RootlessDamageBox ((WindowPtr) dst, &box);
a1120 1

d1122 2
a1123 2
static void RootlessPolyFillArc(DrawablePtr dst, GCPtr pGC,
                                int narcsInit, xArc *parcsInit)
d1155 1
a1155 2
        if (canAccelFill(dst, pGC))
        {
d1163 3
a1165 2
            RootlessDamageBox ((WindowPtr) dst, &box);
    } else {
d1174 3
a1176 3

static void RootlessImageText8(DrawablePtr dst, GCPtr pGC,
                               int x, int y, int count, char *chars)
d1190 2
a1191 1
        if (Min > 0) Min = 0;
d1193 2
a1194 1
        if (Max < 0) Max = 0;
d1197 2
a1198 4
        box.x1 = dst->x + x + Min +
        FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = dst->x + x + Max +
        FONTMAXBOUNDS(pGC->font, rightSideBearing);
d1205 1
a1205 2
        if (canAccelFill(dst, pGC))
        {
d1213 3
a1215 2
            RootlessDamageBox ((WindowPtr) dst, &box);
    } else {
d1224 3
a1226 2
static int RootlessPolyText8(DrawablePtr dst, GCPtr pGC,
                             int x, int y, int count, char *chars)
d1228 1
a1228 1
    int width; // the result, sorta
d1246 4
a1249 2
            if (width > 0) box.x2 += width;
            else box.x1 += width;
d1257 1
a1257 1
            RootlessDamageBox ((WindowPtr) dst, &box);
d1265 3
a1267 2
static void RootlessImageText16(DrawablePtr dst, GCPtr pGC,
                                int x, int y, int count, unsigned short *chars)
d1281 2
a1282 1
        if (Min > 0) Min = 0;
d1284 2
a1285 1
        if (Max < 0) Max = 0;
d1288 2
a1289 4
        box.x1 = dst->x + x + Min +
            FONTMINBOUNDS(pGC->font, leftSideBearing);
        box.x2 = dst->x + x + Max +
            FONTMAXBOUNDS(pGC->font, rightSideBearing);
d1296 1
a1296 2
        if (canAccelFill(dst, pGC))
        {
d1304 3
a1306 2
            RootlessDamageBox ((WindowPtr) dst, &box);
    } else {
d1315 3
a1317 2
static int RootlessPolyText16(DrawablePtr dst, GCPtr pGC,
                            int x, int y, int count, unsigned short *chars)
d1319 1
a1319 1
    int width; // the result, sorta
d1337 4
a1340 2
            if (width > 0) box.x2 += width;
            else box.x1 += width;
d1348 1
a1348 1
            RootlessDamageBox ((WindowPtr) dst, &box);
d1356 4
a1359 3
static void RootlessImageGlyphBlt(DrawablePtr dst, GCPtr pGC,
                                  int x, int y, unsigned int nglyphInit,
                                  CharInfoPtr *ppciInit, pointer unused)
d1375 2
a1376 1
        if (box.x1 > 0) box.x1 = 0;
d1379 2
a1380 1
        if (box.x2 < 0) box.x2 = 0;
d1400 1
a1400 2
        if (canAccelFill(dst, pGC))
        {
d1408 3
a1410 2
            RootlessDamageBox ((WindowPtr) dst, &box);
    } else {
d1419 4
a1422 3
static void RootlessPolyGlyphBlt(DrawablePtr dst, GCPtr pGC,
                                 int x, int y, unsigned int nglyph,
                                 CharInfoPtr *ppci, pointer pglyphBase)
d1445 4
a1448 2
            if (width > 0) box.x2 += width;
            else box.x1 += width;
d1456 1
a1456 1
            RootlessDamageBox ((WindowPtr) dst, &box);
a1462 1

d1483 1
a1483 1
        RootlessDamageBox ((WindowPtr) dst, &box);
@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a150 3
   There are two issues we must contend with when drawing. These are
   controlled with ROOTLESS_PROTECT_ALPHA and RootlessAccelInit().

d171 2
a172 15
   The other issue to consider is that the rootless implementation may
   provide accelerated drawing functions if RootlessAccelInit() is called.For 
   some drawing primitives we swap in rootless acceleration functions, which
   use the accelerated drawing functions where possible.

   Where both alpha protection and acceleration is used, it is even a bigger
   win to relax the planemask to all ones because most accelerated drawing
   functions can only be used in this case. However, even if we can't set
   the planemask to all ones, we can still use the accelerated
   CompositePixels function for GXcopy if it is a forward copy. This is
   mainly intended for copying from pixmaps to windows. The CompositePixels
   operation used sets alpha to 0xFF during the copy.

   The three macros below are used to implement this, potentially accelerated
   drawing ops look something like this:
a271 10
static unsigned int
boxBytes(DrawablePtr pDraw, BoxRec *box)
{
    unsigned int pixels;

    pixels = (box->x2 - box->x1) * (box->y2 - box->y1);

    return pixels * (pDraw->bitsPerPixel >> 3);
}

d454 1
a454 2
        if (canAccelFill(dst, pGC) &&
            boxBytes(dst, &box) >= rootless_FillBytes_threshold)
a559 2
        unsigned int bytes;

d564 1
a564 3
        bytes = w * h * (pSrc->depth >> 3);

        if (bytes >= rootless_CopyBytes_threshold && canAccelBlit(pSrc, pGC))
d1036 1
a1036 2
        if (canAccelFill(dst, pGC) &&
            boxBytes(dst, &box) >= rootless_FillBytes_threshold)
d1088 1
a1088 2
        if (canAccelFill(dst, pGC) &&
            boxBytes(dst, &box) >= rootless_FillBytes_threshold)
d1140 1
a1140 2
        if (canAccelFill(dst, pGC) &&
            boxBytes(dst, &box) >= rootless_FillBytes_threshold)
d1190 1
a1190 2
        if (canAccelFill(dst, pGC) &&
            boxBytes(dst, &box) >= rootless_FillBytes_threshold)
d1277 1
a1277 2
        if (canAccelFill(dst, pGC) &&
            boxBytes(dst, &box) >= rootless_FillBytes_threshold)
d1375 1
a1375 2
        if (canAccelFill(dst, pGC) &&
            boxBytes(dst, &box) >= rootless_FillBytes_threshold)
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d1279 1
a1279 1
    return (width + x);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@a442 13
/* Turn drawing on the root into a no-op */
#define GC_IS_ROOT(pDst) ((pDst)->type == DRAWABLE_WINDOW \
                            && IsRoot ((WindowPtr) (pDst)))

#define GC_SKIP_ROOT(pDst, pGC)			\
    do {					\
        if (GC_IS_ROOT (pDst)) {		\
            GCOP_WRAP(pGC);			\
            return;				\
        }					\
    } while (0)


a448 1
    GC_SKIP_ROOT(dst, pGC);
a503 1
    GC_SKIP_ROOT(dst, pGC);
a553 1
    GC_SKIP_ROOT(dst, pGC);
a583 6
    if (GC_IS_ROOT(dst) || GC_IS_ROOT(pSrc))
    {
        GCOP_WRAP(pGC);
        return NULL;			/* nothing exposed */
    }

a630 6
    if (GC_IS_ROOT(dst) || GC_IS_ROOT(pSrc))
    {
        GCOP_WRAP(pGC);
        return NULL;			/* nothing exposed */
    }

a665 1
    GC_SKIP_ROOT(dst, pGC);
a758 1
    GC_SKIP_ROOT(dst, pGC);
a832 1
    GC_SKIP_ROOT(dst, pGC);
a902 1
    GC_SKIP_ROOT(dst, pGC);
a962 1
    GC_SKIP_ROOT(dst, pGC);
a1017 1
    GC_SKIP_ROOT(dst, pGC);
a1090 1
    GC_SKIP_ROOT(dst, pGC);
a1144 1
    GC_SKIP_ROOT(dst, pGC);
a1198 1
    GC_SKIP_ROOT(dst, pGC);
a1250 6
    if (GC_IS_ROOT(dst))
    {
        GCOP_WRAP(pGC);
        return 0;
    }

a1286 1
    GC_SKIP_ROOT(dst, pGC);
a1338 6
    if (GC_IS_ROOT(dst))
    {
        GCOP_WRAP(pGC);
        return 0;
    }

a1375 1
    GC_SKIP_ROOT(dst, pGC);
a1435 1
    GC_SKIP_ROOT(dst, pGC);
a1480 1
    GC_SKIP_ROOT(dst, pGC);
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d64 2
d77 49
a125 20
static void RootlessFillSpans();
static void RootlessSetSpans();
static void RootlessPutImage();
static RegionPtr RootlessCopyArea();
static RegionPtr RootlessCopyPlane();
static void RootlessPolyPoint();
static void RootlessPolylines();
static void RootlessPolySegment();
static void RootlessPolyRectangle();
static void RootlessPolyArc();
static void RootlessFillPolygon();
static void RootlessPolyFillRect();
static void RootlessPolyFillArc();
static int RootlessPolyText8();
static int RootlessPolyText16();
static void RootlessImageText8();
static void RootlessImageText16();
static void RootlessImageGlyphBlt();
static void RootlessPolyGlyphBlt();
static void RootlessPushPixels();
d152 1
a152 1
   controlled with ROOTLESS_PROTECT_ALPHA and ROOTLESS_ACCEL.
d175 3
a177 3
   provide accelerated drawing functions if ROOTLESS_ACCEL is set. For some
   drawing primitives we swap in rootless acceleration functions, which use
   the accelerated drawing functions where possible.
@


1.1
log
@Initial revision
@
text
@d36 1
d279 1
a279 2
    s = (RootlessScreenRec *) pGC->pScreen->
            devPrivates[rootlessScreenPrivateIndex].ptr;
d282 2
a283 1
    gcrec = (RootlessGCRec *) pGC->devPrivates[rootlessGCPrivateIndex].ptr;
d305 1
a305 1
        (pGC)->devPrivates[rootlessGCPrivateIndex].ptr; \
d402 1
a402 1
        (pGC)->devPrivates[rootlessGCPrivateIndex].ptr; \
d416 1
a416 1
#define GC_SKIP_ROOT(pDst)			\
d418 2
a419 1
        if (GC_IS_ROOT (pDst))			\
d421 1
d431 1
a431 1
    GC_SKIP_ROOT(dst);
d487 1
a487 1
    GC_SKIP_ROOT(dst);
d538 1
a538 1
    GC_SKIP_ROOT(dst);
d570 2
d573 1
d623 2
d626 1
d663 1
a663 1
    GC_SKIP_ROOT(dst);
d757 1
a757 1
    GC_SKIP_ROOT(dst);
d832 1
a832 1
    GC_SKIP_ROOT(dst);
d903 1
a903 1
    GC_SKIP_ROOT(dst);
d964 1
a964 1
    GC_SKIP_ROOT(dst);
d1020 1
a1020 1
    GC_SKIP_ROOT(dst);
d1094 1
a1094 1
    GC_SKIP_ROOT(dst);
d1149 1
a1149 1
    GC_SKIP_ROOT(dst);
d1204 1
a1204 1
    GC_SKIP_ROOT(dst);
d1258 2
d1261 1
d1299 1
a1299 1
    GC_SKIP_ROOT(dst);
d1353 2
d1356 1
d1395 1
a1395 1
    GC_SKIP_ROOT(dst);
d1456 1
a1456 1
    GC_SKIP_ROOT(dst);
d1502 1
a1502 1
    GC_SKIP_ROOT(dst);
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@a35 1
#include <stddef.h> /* For NULL */
@

