head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.14
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.12
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.10
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.8
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.6
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.2
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.8
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2012.06.10.13.21.31;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.05;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.05;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.02;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@/*
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#ifndef _DAMAGE_H_
#define _DAMAGE_H_

typedef struct _damage *DamagePtr;

typedef enum _damageReportLevel {
    DamageReportRawRegion,
    DamageReportDeltaRegion,
    DamageReportBoundingBox,
    DamageReportNonEmpty,
    DamageReportNone
} DamageReportLevel;

typedef void (*DamageReportFunc) (DamagePtr pDamage, RegionPtr pRegion,
                                  void *closure);
typedef void (*DamageDestroyFunc) (DamagePtr pDamage, void *closure);

typedef void (*DamageScreenCreateFunc) (DamagePtr);
typedef void (*DamageScreenRegisterFunc) (DrawablePtr, DamagePtr);
typedef void (*DamageScreenUnregisterFunc) (DrawablePtr, DamagePtr);
typedef void (*DamageScreenDestroyFunc) (DamagePtr);

typedef struct _damageScreenFuncs {
    DamageScreenCreateFunc Create;
    DamageScreenRegisterFunc Register;
    DamageScreenUnregisterFunc Unregister;
    DamageScreenDestroyFunc Destroy;
} DamageScreenFuncsRec, *DamageScreenFuncsPtr;

extern _X_EXPORT void miDamageCreate(DamagePtr);
extern _X_EXPORT void miDamageRegister(DrawablePtr, DamagePtr);
extern _X_EXPORT void miDamageUnregister(DrawablePtr, DamagePtr);
extern _X_EXPORT void miDamageDestroy(DamagePtr);

extern _X_EXPORT Bool
 DamageSetup(ScreenPtr pScreen);

extern _X_EXPORT DamagePtr
DamageCreate(DamageReportFunc damageReport,
             DamageDestroyFunc damageDestroy,
             DamageReportLevel damageLevel,
             Bool isInternal, ScreenPtr pScreen, void *closure);

extern _X_EXPORT void
 DamageDrawInternal(ScreenPtr pScreen, Bool enable);

extern _X_EXPORT void
 DamageRegister(DrawablePtr pDrawable, DamagePtr pDamage);

extern _X_EXPORT void
 DamageUnregister(DamagePtr pDamage);

extern _X_EXPORT void
 DamageDestroy(DamagePtr pDamage);

extern _X_EXPORT Bool
 DamageSubtract(DamagePtr pDamage, const RegionPtr pRegion);

extern _X_EXPORT void
 DamageEmpty(DamagePtr pDamage);

extern _X_EXPORT RegionPtr
 DamageRegion(DamagePtr pDamage);

extern _X_EXPORT RegionPtr
 DamagePendingRegion(DamagePtr pDamage);

/* In case of rendering, call this before the submitting the commands. */
extern _X_EXPORT void
 DamageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion);

/* Call this directly after the rendering operation has been submitted. */
extern _X_EXPORT void
 DamageRegionProcessPending(DrawablePtr pDrawable);

/* Call this when you create a new Damage and you wish to send an initial damage message (to it). */
extern _X_EXPORT void
 DamageReportDamage(DamagePtr pDamage, RegionPtr pDamageRegion);

/* Avoid using this call, it only exists for API compatibility. */
extern _X_EXPORT void
 DamageDamageRegion(DrawablePtr pDrawable, const RegionPtr pRegion);

extern _X_EXPORT void
 DamageSetReportAfterOp(DamagePtr pDamage, Bool reportAfter);

extern _X_EXPORT DamageScreenFuncsPtr DamageGetScreenFuncs(ScreenPtr);

#endif                          /* _DAMAGE_H_ */
@


1.6
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a43 6
/* It's the responsibility of the driver to duplicate both regions. */
/* At some point DamageRegionRendered() must be called. */
typedef void (*DamageMarkerFunc) (DrawablePtr pDrawable, DamagePtr pDamage,
                                  RegionPtr pOldDamage, RegionPtr pRegion,
                                  void *closure);

d77 1
a77 1
 DamageUnregister(DrawablePtr pDrawable, DamagePtr pDamage);
a101 6
/* Call this some time after rendering is done, only relevant when a damageMarker is provided. */
extern _X_EXPORT void

DamageRegionRendered(DrawablePtr pDrawable, DamagePtr pDamage,
                     RegionPtr pOldDamage, RegionPtr pRegion);

a111 6

extern _X_EXPORT void

DamageSetPostRenderingFunctions(DamagePtr pDamage,
                                DamageReportFunc damageReportPostRendering,
                                DamageMarkerFunc damageMarker);
@


1.5
log
@Update to xserver 1.11.2
@
text
@d30 1
a30 1
typedef struct _damage	*DamagePtr;
d40 2
a41 1
typedef void (*DamageReportFunc) (DamagePtr pDamage, RegionPtr pRegion, void *closure);
d43 1
d46 3
a48 1
typedef void (*DamageMarkerFunc) (DrawablePtr pDrawable, DamagePtr pDamage, RegionPtr pOldDamage, RegionPtr pRegion, void *closure);
d56 4
a59 4
    DamageScreenCreateFunc      Create;
    DamageScreenRegisterFunc    Register;
    DamageScreenUnregisterFunc  Unregister;
    DamageScreenDestroyFunc     Destroy;
d62 4
a65 4
extern _X_EXPORT void miDamageCreate (DamagePtr);
extern _X_EXPORT void miDamageRegister (DrawablePtr, DamagePtr);
extern _X_EXPORT void miDamageUnregister (DrawablePtr, DamagePtr);
extern _X_EXPORT void miDamageDestroy (DamagePtr);
d68 2
a69 2
DamageSetup (ScreenPtr pScreen);
    
d71 4
a74 6
DamageCreate (DamageReportFunc  damageReport,
	      DamageDestroyFunc	damageDestroy,
	      DamageReportLevel damageLevel,
	      Bool		isInternal,
	      ScreenPtr		pScreen,
	      void *		closure);
d77 1
a77 1
DamageDrawInternal (ScreenPtr pScreen, Bool enable);
d80 1
a80 2
DamageRegister (DrawablePtr	pDrawable,
		DamagePtr	pDamage);
d83 1
a83 2
DamageUnregister (DrawablePtr	pDrawable,
		  DamagePtr	pDamage);
d86 1
a86 1
DamageDestroy (DamagePtr pDamage);
d89 1
a89 2
DamageSubtract (DamagePtr	    pDamage,
		const RegionPtr	    pRegion);
d92 1
a92 1
DamageEmpty (DamagePtr pDamage);
d95 1
a95 1
DamageRegion (DamagePtr		    pDamage);
d98 1
a98 1
DamagePendingRegion (DamagePtr	    pDamage);
d102 1
a102 1
DamageRegionAppend (DrawablePtr pDrawable, RegionPtr pRegion);
d106 1
a106 1
DamageRegionProcessPending (DrawablePtr pDrawable);
d110 3
a112 1
DamageRegionRendered (DrawablePtr pDrawable, DamagePtr pDamage, RegionPtr pOldDamage, RegionPtr pRegion);
d116 1
a116 1
DamageReportDamage (DamagePtr pDamage, RegionPtr pDamageRegion);
d120 1
a120 2
DamageDamageRegion (DrawablePtr	    pDrawable,
		    const RegionPtr pRegion);
d123 1
a123 1
DamageSetReportAfterOp (DamagePtr pDamage, Bool reportAfter);
a125 2
DamageSetPostRenderingFunctions(DamagePtr pDamage, DamageReportFunc damageReportPostRendering,
				DamageMarkerFunc damageMarker);
d127 5
a131 2
extern _X_EXPORT DamageScreenFuncsPtr
DamageGetScreenFuncs (ScreenPtr);
d133 1
a133 1
#endif /* _DAMAGE_H_ */
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d113 4
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d46 18
a63 1
Bool
d66 1
a66 1
DamagePtr
d74 1
a74 1
void
d77 1
a77 1
void
d81 1
a81 1
void
d85 1
a85 1
void
d88 1
a88 1
Bool
d92 1
a92 1
void
d95 1
a95 1
RegionPtr
d98 1
a98 1
RegionPtr
d102 1
a102 1
void
d106 1
a106 1
void
d110 1
a110 1
void
d114 1
a114 1
void
d118 1
a118 1
void
d121 1
a121 1
void
d124 3
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d42 3
d84 13
d103 4
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d78 3
d84 3
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
a82 3

void
DamageSetReportAfterOp (DamagePtr pDamage, Bool reportAfter);
@

