head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.2
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.10.0.2
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v1_4_0_90:1.1.1.2
	v1_4:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_2_0:1.1.1.1
	v1_1_99_903:1.1.1.1
	v1_1_99_902:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2016.05.29.12.02.40;	author matthieu;	state Exp;
branches;
next	1.12;
commitid	s0SI41sEunLdyFfd;

1.12
date	2015.09.16.19.10.25;	author matthieu;	state Exp;
branches;
next	1.11;
commitid	Te1daavkBLskZ8gc;

1.11
date	2014.09.27.17.53.04;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	cVXoV5PxI8YrEaVA;

1.10
date	2014.05.02.19.27.50;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2013.12.28.14.40.02;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.06.07.17.28.55;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.10.13.21.30;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.05.13.32.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.12.05.15.36.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.27.19.02.37;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.06.19.44.37;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.15.26.32;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.18.15.04;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.18.15.04;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.24.17.57.03;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update to xserver 1.18.3. Tested by shadchin@@ and naddy@@.

Note that indirect GLX is now disbled by default.
@
text
@/*
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef HAVE_DIX_CONFIG_H
#include <dix-config.h>
#endif

#include <stdlib.h>

#include    <X11/X.h>
#include    "scrnintstr.h"
#include    "windowstr.h"
#include    <X11/fonts/font.h>
#include    "dixfontstr.h"
#include    <X11/fonts/fontstruct.h>
#include    <X11/fonts/fontutil.h>
#include    "mi.h"
#include    "regionstr.h"
#include    "globals.h"
#include    "gcstruct.h"
#include    "damage.h"
#include    "damagestr.h"

#define wrap(priv, real, mem, func) {\
    priv->mem = real->mem; \
    real->mem = func; \
}

#define unwrap(priv, real, mem) {\
    real->mem = priv->mem; \
}

#define BOX_SAME(a,b) \
    ((a)->x1 == (b)->x1 && \
     (a)->y1 == (b)->y1 && \
     (a)->x2 == (b)->x2 && \
     (a)->y2 == (b)->y2)

#define DAMAGE_VALIDATE_ENABLE 0
#define DAMAGE_DEBUG_ENABLE 0
#if DAMAGE_DEBUG_ENABLE
#define DAMAGE_DEBUG(x)	ErrorF x
#else
#define DAMAGE_DEBUG(x)
#endif

#define getPixmapDamageRef(pPixmap) ((DamagePtr *) \
    dixLookupPrivateAddr(&(pPixmap)->devPrivates, damagePixPrivateKey))

#define pixmapDamage(pPixmap)		damagePixPriv(pPixmap)

static DevPrivateKeyRec damageScrPrivateKeyRec;

#define damageScrPrivateKey (&damageScrPrivateKeyRec)
static DevPrivateKeyRec damagePixPrivateKeyRec;

#define damagePixPrivateKey (&damagePixPrivateKeyRec)
static DevPrivateKeyRec damageGCPrivateKeyRec;

#define damageGCPrivateKey (&damageGCPrivateKeyRec)
static DevPrivateKeyRec damageWinPrivateKeyRec;

#define damageWinPrivateKey (&damageWinPrivateKeyRec)

static DamagePtr *
getDrawableDamageRef(DrawablePtr pDrawable)
{
    PixmapPtr pPixmap;

    if (WindowDrawable(pDrawable->type)) {
        ScreenPtr pScreen = pDrawable->pScreen;

        pPixmap = 0;
        if (pScreen->GetWindowPixmap
#ifdef ROOTLESS_WORKAROUND
            && ((WindowPtr) pDrawable)->viewable
#endif
            )
            pPixmap = (*pScreen->GetWindowPixmap) ((WindowPtr) pDrawable);

        if (!pPixmap) {
            damageScrPriv(pScreen);

            return &pScrPriv->pScreenDamage;
        }
    }
    else
        pPixmap = (PixmapPtr) pDrawable;
    return getPixmapDamageRef(pPixmap);
}

#define getDrawableDamage(pDrawable)	(*getDrawableDamageRef (pDrawable))
#define getWindowDamage(pWin)		getDrawableDamage(&(pWin)->drawable)

#define drawableDamage(pDrawable)	\
    DamagePtr	pDamage = getDrawableDamage(pDrawable)

#define windowDamage(pWin)		drawableDamage(&(pWin)->drawable)

#define winDamageRef(pWindow) \
    DamagePtr	*pPrev = (DamagePtr *) \
	dixLookupPrivateAddr(&(pWindow)->devPrivates, damageWinPrivateKey)

#if DAMAGE_DEBUG_ENABLE
static void
_damageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion, Bool clip,
                    int subWindowMode, const char *where)
#define damageRegionAppend(d,r,c,m) _damageRegionAppend(d,r,c,m,__FUNCTION__)
#else
static void
damageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion, Bool clip,
                   int subWindowMode)
#endif
{
    ScreenPtr pScreen = pDrawable->pScreen;

    damageScrPriv(pScreen);
    drawableDamage(pDrawable);
    DamagePtr pNext;
    RegionRec clippedRec;
    RegionPtr pDamageRegion;
    RegionRec pixClip;
    int draw_x, draw_y;

#ifdef COMPOSITE
    int screen_x = 0, screen_y = 0;
#endif

    /* short circuit for empty regions */
    if (!RegionNotEmpty(pRegion))
        return;

#ifdef COMPOSITE
    /*
     * When drawing to a pixmap which is storing window contents,
     * the region presented is in pixmap relative coordinates which
     * need to be converted to screen relative coordinates
     */
    if (pDrawable->type != DRAWABLE_WINDOW) {
        screen_x = ((PixmapPtr) pDrawable)->screen_x - pDrawable->x;
        screen_y = ((PixmapPtr) pDrawable)->screen_y - pDrawable->y;
    }
    if (screen_x || screen_y)
        RegionTranslate(pRegion, screen_x, screen_y);
#endif

    if (pDrawable->type == DRAWABLE_WINDOW &&
        ((WindowPtr) (pDrawable))->backingStore == NotUseful) {
        if (subWindowMode == ClipByChildren) {
            RegionIntersect(pRegion, pRegion,
                            &((WindowPtr) (pDrawable))->clipList);
        }
        else if (subWindowMode == IncludeInferiors) {
            RegionPtr pTempRegion =
                NotClippedByChildren((WindowPtr) (pDrawable));
            RegionIntersect(pRegion, pRegion, pTempRegion);
            RegionDestroy(pTempRegion);
        }
        /* If subWindowMode is set to an invalid value, don't perform
         * any drawable-based clipping. */
    }

    RegionNull(&clippedRec);
    for (; pDamage; pDamage = pNext) {
        pNext = pDamage->pNext;
        /*
         * Check for internal damage and don't send events
         */
        if (pScrPriv->internalLevel > 0 && !pDamage->isInternal) {
            DAMAGE_DEBUG(("non internal damage, skipping at %d\n",
                          pScrPriv->internalLevel));
            continue;
        }
        /*
         * Check for unrealized windows
         */
        if (pDamage->pDrawable->type == DRAWABLE_WINDOW &&
            !((WindowPtr) (pDamage->pDrawable))->realized) {
            continue;
        }

        draw_x = pDamage->pDrawable->x;
        draw_y = pDamage->pDrawable->y;
#ifdef COMPOSITE
        /*
         * Need to move everyone to screen coordinates
         * XXX what about off-screen pixmaps with non-zero x/y?
         */
        if (!WindowDrawable(pDamage->pDrawable->type)) {
            draw_x += ((PixmapPtr) pDamage->pDrawable)->screen_x;
            draw_y += ((PixmapPtr) pDamage->pDrawable)->screen_y;
        }
#endif

        /*
         * Clip against border or pixmap bounds
         */

        pDamageRegion = pRegion;
        if (clip || pDamage->pDrawable != pDrawable) {
            pDamageRegion = &clippedRec;
            if (pDamage->pDrawable->type == DRAWABLE_WINDOW) {
                RegionIntersect(pDamageRegion, pRegion,
                                &((WindowPtr) (pDamage->pDrawable))->
                                borderClip);
            }
            else {
                BoxRec box;

                box.x1 = draw_x;
                box.y1 = draw_y;
                box.x2 = draw_x + pDamage->pDrawable->width;
                box.y2 = draw_y + pDamage->pDrawable->height;
                RegionInit(&pixClip, &box, 1);
                RegionIntersect(pDamageRegion, pRegion, &pixClip);
                RegionUninit(&pixClip);
            }
            /*
             * Short circuit empty results
             */
            if (!RegionNotEmpty(pDamageRegion))
                continue;
        }

        DAMAGE_DEBUG(("%s %d x %d +%d +%d (target 0x%lx monitor 0x%lx)\n",
                      where,
                      pDamageRegion->extents.x2 - pDamageRegion->extents.x1,
                      pDamageRegion->extents.y2 - pDamageRegion->extents.y1,
                      pDamageRegion->extents.x1, pDamageRegion->extents.y1,
                      pDrawable->id, pDamage->pDrawable->id));

        /*
         * Move region to target coordinate space
         */
        if (draw_x || draw_y)
            RegionTranslate(pDamageRegion, -draw_x, -draw_y);

        /* Store damage region if needed after submission. */
        if (pDamage->reportAfter)
            RegionUnion(&pDamage->pendingDamage,
                        &pDamage->pendingDamage, pDamageRegion);

        /* Report damage now, if desired. */
        if (!pDamage->reportAfter) {
            if (pDamage->damageReport)
                DamageReportDamage(pDamage, pDamageRegion);
            else
                RegionUnion(&pDamage->damage, &pDamage->damage, pDamageRegion);
        }

        /*
         * translate original region back
         */
        if (pDamageRegion == pRegion && (draw_x || draw_y))
            RegionTranslate(pDamageRegion, draw_x, draw_y);
    }
#ifdef COMPOSITE
    if (screen_x || screen_y)
        RegionTranslate(pRegion, -screen_x, -screen_y);
#endif

    RegionUninit(&clippedRec);
}

static void
damageRegionProcessPending(DrawablePtr pDrawable)
{
    drawableDamage(pDrawable);

    for (; pDamage != NULL; pDamage = pDamage->pNext) {
        if (pDamage->reportAfter) {
            /* It's possible that there is only interest in postRendering reporting. */
            if (pDamage->damageReport)
                DamageReportDamage(pDamage, &pDamage->pendingDamage);
            else
                RegionUnion(&pDamage->damage, &pDamage->damage,
                            &pDamage->pendingDamage);
        }

        if (pDamage->reportAfter)
            RegionEmpty(&pDamage->pendingDamage);
    }

}

#if DAMAGE_DEBUG_ENABLE
#define damageDamageBox(d,b,m) _damageDamageBox(d,b,m,__FUNCTION__)
static void
_damageDamageBox(DrawablePtr pDrawable, BoxPtr pBox, int subWindowMode,
                 const char *where)
#else
static void
damageDamageBox(DrawablePtr pDrawable, BoxPtr pBox, int subWindowMode)
#endif
{
    RegionRec region;

    RegionInit(&region, pBox, 1);
#if DAMAGE_DEBUG_ENABLE
    _damageRegionAppend(pDrawable, &region, TRUE, subWindowMode, where);
#else
    damageRegionAppend(pDrawable, &region, TRUE, subWindowMode);
#endif
    RegionUninit(&region);
}

static void damageValidateGC(GCPtr, unsigned long, DrawablePtr);
static void damageChangeGC(GCPtr, unsigned long);
static void damageCopyGC(GCPtr, unsigned long, GCPtr);
static void damageDestroyGC(GCPtr);
static void damageChangeClip(GCPtr, int, void *, int);
static void damageDestroyClip(GCPtr);
static void damageCopyClip(GCPtr, GCPtr);

static GCFuncs damageGCFuncs = {
    damageValidateGC, damageChangeGC, damageCopyGC, damageDestroyGC,
    damageChangeClip, damageDestroyClip, damageCopyClip
};

static GCOps damageGCOps;

static Bool
damageCreateGC(GCPtr pGC)
{
    ScreenPtr pScreen = pGC->pScreen;

    damageScrPriv(pScreen);
    damageGCPriv(pGC);
    Bool ret;

    unwrap(pScrPriv, pScreen, CreateGC);
    if ((ret = (*pScreen->CreateGC) (pGC))) {
        pGCPriv->ops = NULL;
        pGCPriv->funcs = pGC->funcs;
        pGC->funcs = &damageGCFuncs;
    }
    wrap(pScrPriv, pScreen, CreateGC, damageCreateGC);

    return ret;
}

#define DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable) \
    damageGCPriv(pGC);  \
    const GCFuncs *oldFuncs = pGC->funcs; \
    unwrap(pGCPriv, pGC, funcs);  \
    unwrap(pGCPriv, pGC, ops); \

#define DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable) \
    wrap(pGCPriv, pGC, funcs, oldFuncs); \
    wrap(pGCPriv, pGC, ops, &damageGCOps)

#define DAMAGE_GC_FUNC_PROLOGUE(pGC) \
    damageGCPriv(pGC); \
    unwrap(pGCPriv, pGC, funcs); \
    if (pGCPriv->ops) unwrap(pGCPriv, pGC, ops)

#define DAMAGE_GC_FUNC_EPILOGUE(pGC) \
    wrap(pGCPriv, pGC, funcs, &damageGCFuncs);  \
    if (pGCPriv->ops) wrap(pGCPriv, pGC, ops, &damageGCOps)

static void
damageValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDrawable)
{
    DAMAGE_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->ValidateGC) (pGC, changes, pDrawable);
    pGCPriv->ops = pGC->ops; /* just so it's not NULL */
    DAMAGE_GC_FUNC_EPILOGUE(pGC);
}

static void
damageDestroyGC(GCPtr pGC)
{
    DAMAGE_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->DestroyGC) (pGC);
    DAMAGE_GC_FUNC_EPILOGUE(pGC);
}

static void
damageChangeGC(GCPtr pGC, unsigned long mask)
{
    DAMAGE_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->ChangeGC) (pGC, mask);
    DAMAGE_GC_FUNC_EPILOGUE(pGC);
}

static void
damageCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst)
{
    DAMAGE_GC_FUNC_PROLOGUE(pGCDst);
    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
    DAMAGE_GC_FUNC_EPILOGUE(pGCDst);
}

static void
damageChangeClip(GCPtr pGC, int type, void *pvalue, int nrects)
{
    DAMAGE_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
    DAMAGE_GC_FUNC_EPILOGUE(pGC);
}

static void
damageCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    DAMAGE_GC_FUNC_PROLOGUE(pgcDst);
    (*pgcDst->funcs->CopyClip) (pgcDst, pgcSrc);
    DAMAGE_GC_FUNC_EPILOGUE(pgcDst);
}

static void
damageDestroyClip(GCPtr pGC)
{
    DAMAGE_GC_FUNC_PROLOGUE(pGC);
    (*pGC->funcs->DestroyClip) (pGC);
    DAMAGE_GC_FUNC_EPILOGUE(pGC);
}

#define TRIM_BOX(box, pGC) if (pGC->pCompositeClip) { \
    BoxPtr extents = &pGC->pCompositeClip->extents;\
    if(box.x1 < extents->x1) box.x1 = extents->x1; \
    if(box.x2 > extents->x2) box.x2 = extents->x2; \
    if(box.y1 < extents->y1) box.y1 = extents->y1; \
    if(box.y2 > extents->y2) box.y2 = extents->y2; \
    }

#define TRANSLATE_BOX(box, pDrawable) { \
    box.x1 += pDrawable->x; \
    box.x2 += pDrawable->x; \
    box.y1 += pDrawable->y; \
    box.y2 += pDrawable->y; \
    }

#define TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC) { \
    TRANSLATE_BOX(box, pDrawable); \
    TRIM_BOX(box, pGC); \
    }

#define BOX_NOT_EMPTY(box) \
    (((box.x2 - box.x1) > 0) && ((box.y2 - box.y1) > 0))

#define checkGCDamage(d,g)	(getDrawableDamage(d) && \
				 (!g->pCompositeClip ||\
				  RegionNotEmpty(g->pCompositeClip)))

#define TRIM_PICTURE_BOX(box, pDst) { \
    BoxPtr extents = &pDst->pCompositeClip->extents;\
    if(box.x1 < extents->x1) box.x1 = extents->x1; \
    if(box.x2 > extents->x2) box.x2 = extents->x2; \
    if(box.y1 < extents->y1) box.y1 = extents->y1; \
    if(box.y2 > extents->y2) box.y2 = extents->y2; \
    }

#define checkPictureDamage(p)	(getDrawableDamage(p->pDrawable) && \
				 RegionNotEmpty(p->pCompositeClip))

static void
damageComposite(CARD8 op,
                PicturePtr pSrc,
                PicturePtr pMask,
                PicturePtr pDst,
                INT16 xSrc,
                INT16 ySrc,
                INT16 xMask,
                INT16 yMask,
                INT16 xDst, INT16 yDst, CARD16 width, CARD16 height)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);

    damageScrPriv(pScreen);

    if (checkPictureDamage(pDst)) {
        BoxRec box;

        box.x1 = xDst + pDst->pDrawable->x;
        box.y1 = yDst + pDst->pDrawable->y;
        box.x2 = box.x1 + width;
        box.y2 = box.y1 + height;
        TRIM_PICTURE_BOX(box, pDst);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDst->pDrawable, &box, pDst->subWindowMode);
    }
    unwrap(pScrPriv, ps, Composite);
    (*ps->Composite) (op,
                      pSrc,
                      pMask,
                      pDst,
                      xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);
    damageRegionProcessPending(pDst->pDrawable);
    wrap(pScrPriv, ps, Composite, damageComposite);
}

static void
damageGlyphs(CARD8 op,
             PicturePtr pSrc,
             PicturePtr pDst,
             PictFormatPtr maskFormat,
             INT16 xSrc,
             INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs)
{
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);

    damageScrPriv(pScreen);

    if (checkPictureDamage(pDst)) {
        int nlistTmp = nlist;
        GlyphListPtr listTmp = list;
        GlyphPtr *glyphsTmp = glyphs;
        int x, y;
        int n;
        GlyphPtr glyph;
        BoxRec box;
        int x1, y1, x2, y2;

        box.x1 = 32767;
        box.y1 = 32767;
        box.x2 = -32767;
        box.y2 = -32767;
        x = pDst->pDrawable->x;
        y = pDst->pDrawable->y;
        while (nlistTmp--) {
            x += listTmp->xOff;
            y += listTmp->yOff;
            n = listTmp->len;
            while (n--) {
                glyph = *glyphsTmp++;
                x1 = x - glyph->info.x;
                y1 = y - glyph->info.y;
                x2 = x1 + glyph->info.width;
                y2 = y1 + glyph->info.height;
                if (x1 < box.x1)
                    box.x1 = x1;
                if (y1 < box.y1)
                    box.y1 = y1;
                if (x2 > box.x2)
                    box.x2 = x2;
                if (y2 > box.y2)
                    box.y2 = y2;
                x += glyph->info.xOff;
                y += glyph->info.yOff;
            }
            listTmp++;
        }
        TRIM_PICTURE_BOX(box, pDst);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDst->pDrawable, &box, pDst->subWindowMode);
    }
    unwrap(pScrPriv, ps, Glyphs);
    (*ps->Glyphs) (op, pSrc, pDst, maskFormat, xSrc, ySrc, nlist, list, glyphs);
    damageRegionProcessPending(pDst->pDrawable);
    wrap(pScrPriv, ps, Glyphs, damageGlyphs);
}

static void
damageAddTraps(PicturePtr pPicture,
               INT16 x_off, INT16 y_off, int ntrap, xTrap * traps)
{
    ScreenPtr pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr ps = GetPictureScreen(pScreen);

    damageScrPriv(pScreen);

    if (checkPictureDamage(pPicture)) {
        BoxRec box;
        int i;
        int x, y;
        xTrap *t = traps;

        box.x1 = 32767;
        box.y1 = 32767;
        box.x2 = -32767;
        box.y2 = -32767;
        x = pPicture->pDrawable->x + x_off;
        y = pPicture->pDrawable->y + y_off;
        for (i = 0; i < ntrap; i++) {
            pixman_fixed_t l = min(t->top.l, t->bot.l);
            pixman_fixed_t r = max(t->top.r, t->bot.r);
            int x1 = x + pixman_fixed_to_int(l);
            int x2 = x + pixman_fixed_to_int(pixman_fixed_ceil(r));
            int y1 = y + pixman_fixed_to_int(t->top.y);
            int y2 = y + pixman_fixed_to_int(pixman_fixed_ceil(t->bot.y));

            if (x1 < box.x1)
                box.x1 = x1;
            if (x2 > box.x2)
                box.x2 = x2;
            if (y1 < box.y1)
                box.y1 = y1;
            if (y2 > box.y2)
                box.y2 = y2;
        }
        TRIM_PICTURE_BOX(box, pPicture);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pPicture->pDrawable, &box, pPicture->subWindowMode);
    }
    unwrap(pScrPriv, ps, AddTraps);
    (*ps->AddTraps) (pPicture, x_off, y_off, ntrap, traps);
    damageRegionProcessPending(pPicture->pDrawable);
    wrap(pScrPriv, ps, AddTraps, damageAddTraps);
}

/**********************************************************/

static void
damageFillSpans(DrawablePtr pDrawable,
                GC * pGC, int npt, DDXPointPtr ppt, int *pwidth, int fSorted)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (npt && checkGCDamage(pDrawable, pGC)) {
        int nptTmp = npt;
        DDXPointPtr pptTmp = ppt;
        int *pwidthTmp = pwidth;
        BoxRec box;

        box.x1 = pptTmp->x;
        box.x2 = box.x1 + *pwidthTmp;
        box.y2 = box.y1 = pptTmp->y;

        while (--nptTmp) {
            pptTmp++;
            pwidthTmp++;
            if (box.x1 > pptTmp->x)
                box.x1 = pptTmp->x;
            if (box.x2 < (pptTmp->x + *pwidthTmp))
                box.x2 = pptTmp->x + *pwidthTmp;
            if (box.y1 > pptTmp->y)
                box.y1 = pptTmp->y;
            else if (box.y2 < pptTmp->y)
                box.y2 = pptTmp->y;
        }

        box.y2++;

        if (!pGC->miTranslate) {
            TRANSLATE_BOX(box, pDrawable);
        }
        TRIM_BOX(box, pGC);

        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }

    (*pGC->ops->FillSpans) (pDrawable, pGC, npt, ppt, pwidth, fSorted);

    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damageSetSpans(DrawablePtr pDrawable,
               GCPtr pGC,
               char *pcharsrc,
               DDXPointPtr ppt, int *pwidth, int npt, int fSorted)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (npt && checkGCDamage(pDrawable, pGC)) {
        DDXPointPtr pptTmp = ppt;
        int *pwidthTmp = pwidth;
        int nptTmp = npt;
        BoxRec box;

        box.x1 = pptTmp->x;
        box.x2 = box.x1 + *pwidthTmp;
        box.y2 = box.y1 = pptTmp->y;

        while (--nptTmp) {
            pptTmp++;
            pwidthTmp++;
            if (box.x1 > pptTmp->x)
                box.x1 = pptTmp->x;
            if (box.x2 < (pptTmp->x + *pwidthTmp))
                box.x2 = pptTmp->x + *pwidthTmp;
            if (box.y1 > pptTmp->y)
                box.y1 = pptTmp->y;
            else if (box.y2 < pptTmp->y)
                box.y2 = pptTmp->y;
        }

        box.y2++;

        if (!pGC->miTranslate) {
            TRANSLATE_BOX(box, pDrawable);
        }
        TRIM_BOX(box, pGC);

        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->SetSpans) (pDrawable, pGC, pcharsrc, ppt, pwidth, npt, fSorted);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePutImage(DrawablePtr pDrawable,
               GCPtr pGC,
               int depth,
               int x,
               int y, int w, int h, int leftPad, int format, char *pImage)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    if (checkGCDamage(pDrawable, pGC)) {
        BoxRec box;

        box.x1 = x + pDrawable->x;
        box.x2 = box.x1 + w;
        box.y1 = y + pDrawable->y;
        box.y2 = box.y1 + h;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PutImage) (pDrawable, pGC, depth, x, y, w, h,
                           leftPad, format, pImage);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static RegionPtr
damageCopyArea(DrawablePtr pSrc,
               DrawablePtr pDst,
               GC * pGC,
               int srcx, int srcy, int width, int height, int dstx, int dsty)
{
    RegionPtr ret;

    DAMAGE_GC_OP_PROLOGUE(pGC, pDst);

    if (checkGCDamage(pDst, pGC)) {
        BoxRec box;

        box.x1 = dstx + pDst->x;
        box.x2 = box.x1 + width;
        box.y1 = dsty + pDst->y;
        box.y2 = box.y1 + height;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDst, &box, pGC->subWindowMode);
    }

    ret = (*pGC->ops->CopyArea) (pSrc, pDst,
                                 pGC, srcx, srcy, width, height, dstx, dsty);
    damageRegionProcessPending(pDst);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDst);
    return ret;
}

static RegionPtr
damageCopyPlane(DrawablePtr pSrc,
                DrawablePtr pDst,
                GCPtr pGC,
                int srcx,
                int srcy,
                int width,
                int height, int dstx, int dsty, unsigned long bitPlane)
{
    RegionPtr ret;

    DAMAGE_GC_OP_PROLOGUE(pGC, pDst);

    if (checkGCDamage(pDst, pGC)) {
        BoxRec box;

        box.x1 = dstx + pDst->x;
        box.x2 = box.x1 + width;
        box.y1 = dsty + pDst->y;
        box.y2 = box.y1 + height;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDst, &box, pGC->subWindowMode);
    }

    ret = (*pGC->ops->CopyPlane) (pSrc, pDst,
                                  pGC, srcx, srcy, width, height, dstx, dsty,
                                  bitPlane);
    damageRegionProcessPending(pDst);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDst);
    return ret;
}

static void
damagePolyPoint(DrawablePtr pDrawable,
                GCPtr pGC, int mode, int npt, xPoint * ppt)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (npt && checkGCDamage(pDrawable, pGC)) {
        BoxRec box;
        int nptTmp = npt;
        xPoint *pptTmp = ppt;

        box.x2 = box.x1 = pptTmp->x;
        box.y2 = box.y1 = pptTmp->y;

        /* this could be slow if the points were spread out */

        while (--nptTmp) {
            pptTmp++;
            if (box.x1 > pptTmp->x)
                box.x1 = pptTmp->x;
            else if (box.x2 < pptTmp->x)
                box.x2 = pptTmp->x;
            if (box.y1 > pptTmp->y)
                box.y1 = pptTmp->y;
            else if (box.y2 < pptTmp->y)
                box.y2 = pptTmp->y;
        }

        box.x2++;
        box.y2++;

        TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PolyPoint) (pDrawable, pGC, mode, npt, ppt);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolylines(DrawablePtr pDrawable,
                GCPtr pGC, int mode, int npt, DDXPointPtr ppt)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (npt && checkGCDamage(pDrawable, pGC)) {
        int nptTmp = npt;
        DDXPointPtr pptTmp = ppt;
        BoxRec box;
        int extra = pGC->lineWidth >> 1;

        box.x2 = box.x1 = pptTmp->x;
        box.y2 = box.y1 = pptTmp->y;

        if (nptTmp > 1) {
            if (pGC->joinStyle == JoinMiter)
                extra = 6 * pGC->lineWidth;
            else if (pGC->capStyle == CapProjecting)
                extra = pGC->lineWidth;
        }

        if (mode == CoordModePrevious) {
            int x = box.x1;
            int y = box.y1;

            while (--nptTmp) {
                pptTmp++;
                x += pptTmp->x;
                y += pptTmp->y;
                if (box.x1 > x)
                    box.x1 = x;
                else if (box.x2 < x)
                    box.x2 = x;
                if (box.y1 > y)
                    box.y1 = y;
                else if (box.y2 < y)
                    box.y2 = y;
            }
        }
        else {
            while (--nptTmp) {
                pptTmp++;
                if (box.x1 > pptTmp->x)
                    box.x1 = pptTmp->x;
                else if (box.x2 < pptTmp->x)
                    box.x2 = pptTmp->x;
                if (box.y1 > pptTmp->y)
                    box.y1 = pptTmp->y;
                else if (box.y2 < pptTmp->y)
                    box.y2 = pptTmp->y;
            }
        }

        box.x2++;
        box.y2++;

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->Polylines) (pDrawable, pGC, mode, npt, ppt);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolySegment(DrawablePtr pDrawable, GCPtr pGC, int nSeg, xSegment * pSeg)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (nSeg && checkGCDamage(pDrawable, pGC)) {
        BoxRec box;
        int extra = pGC->lineWidth;
        int nsegTmp = nSeg;
        xSegment *pSegTmp = pSeg;

        if (pGC->capStyle != CapProjecting)
            extra >>= 1;

        if (pSegTmp->x2 > pSegTmp->x1) {
            box.x1 = pSegTmp->x1;
            box.x2 = pSegTmp->x2;
        }
        else {
            box.x2 = pSegTmp->x1;
            box.x1 = pSegTmp->x2;
        }

        if (pSegTmp->y2 > pSegTmp->y1) {
            box.y1 = pSegTmp->y1;
            box.y2 = pSegTmp->y2;
        }
        else {
            box.y2 = pSegTmp->y1;
            box.y1 = pSegTmp->y2;
        }

        while (--nsegTmp) {
            pSegTmp++;
            if (pSegTmp->x2 > pSegTmp->x1) {
                if (pSegTmp->x1 < box.x1)
                    box.x1 = pSegTmp->x1;
                if (pSegTmp->x2 > box.x2)
                    box.x2 = pSegTmp->x2;
            }
            else {
                if (pSegTmp->x2 < box.x1)
                    box.x1 = pSegTmp->x2;
                if (pSegTmp->x1 > box.x2)
                    box.x2 = pSegTmp->x1;
            }
            if (pSegTmp->y2 > pSegTmp->y1) {
                if (pSegTmp->y1 < box.y1)
                    box.y1 = pSegTmp->y1;
                if (pSegTmp->y2 > box.y2)
                    box.y2 = pSegTmp->y2;
            }
            else {
                if (pSegTmp->y2 < box.y1)
                    box.y1 = pSegTmp->y2;
                if (pSegTmp->y1 > box.y2)
                    box.y2 = pSegTmp->y1;
            }
        }

        box.x2++;
        box.y2++;

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PolySegment) (pDrawable, pGC, nSeg, pSeg);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolyRectangle(DrawablePtr pDrawable,
                    GCPtr pGC, int nRects, xRectangle *pRects)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (nRects && checkGCDamage(pDrawable, pGC)) {
        BoxRec box;
        int offset1, offset2, offset3;
        int nRectsTmp = nRects;
        xRectangle *pRectsTmp = pRects;

        offset2 = pGC->lineWidth;
        if (!offset2)
            offset2 = 1;
        offset1 = offset2 >> 1;
        offset3 = offset2 - offset1;

        while (nRectsTmp--) {
            box.x1 = pRectsTmp->x - offset1;
            box.y1 = pRectsTmp->y - offset1;
            box.x2 = box.x1 + pRectsTmp->width + offset2;
            box.y2 = box.y1 + offset2;
            TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
            if (BOX_NOT_EMPTY(box))
                damageDamageBox(pDrawable, &box, pGC->subWindowMode);

            box.x1 = pRectsTmp->x - offset1;
            box.y1 = pRectsTmp->y + offset3;
            box.x2 = box.x1 + offset2;
            box.y2 = box.y1 + pRectsTmp->height - offset2;
            TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
            if (BOX_NOT_EMPTY(box))
                damageDamageBox(pDrawable, &box, pGC->subWindowMode);

            box.x1 = pRectsTmp->x + pRectsTmp->width - offset1;
            box.y1 = pRectsTmp->y + offset3;
            box.x2 = box.x1 + offset2;
            box.y2 = box.y1 + pRectsTmp->height - offset2;
            TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
            if (BOX_NOT_EMPTY(box))
                damageDamageBox(pDrawable, &box, pGC->subWindowMode);

            box.x1 = pRectsTmp->x - offset1;
            box.y1 = pRectsTmp->y + pRectsTmp->height - offset1;
            box.x2 = box.x1 + pRectsTmp->width + offset2;
            box.y2 = box.y1 + offset2;
            TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
            if (BOX_NOT_EMPTY(box))
                damageDamageBox(pDrawable, &box, pGC->subWindowMode);

            pRectsTmp++;
        }
    }
    (*pGC->ops->PolyRectangle) (pDrawable, pGC, nRects, pRects);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolyArc(DrawablePtr pDrawable, GCPtr pGC, int nArcs, xArc * pArcs)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (nArcs && checkGCDamage(pDrawable, pGC)) {
        int extra = pGC->lineWidth >> 1;
        BoxRec box;
        int nArcsTmp = nArcs;
        xArc *pArcsTmp = pArcs;

        box.x1 = pArcsTmp->x;
        box.x2 = box.x1 + pArcsTmp->width;
        box.y1 = pArcsTmp->y;
        box.y2 = box.y1 + pArcsTmp->height;

        while (--nArcsTmp) {
            pArcsTmp++;
            if (box.x1 > pArcsTmp->x)
                box.x1 = pArcsTmp->x;
            if (box.x2 < (pArcsTmp->x + pArcsTmp->width))
                box.x2 = pArcsTmp->x + pArcsTmp->width;
            if (box.y1 > pArcsTmp->y)
                box.y1 = pArcsTmp->y;
            if (box.y2 < (pArcsTmp->y + pArcsTmp->height))
                box.y2 = pArcsTmp->y + pArcsTmp->height;
        }

        if (extra) {
            box.x1 -= extra;
            box.x2 += extra;
            box.y1 -= extra;
            box.y2 += extra;
        }

        box.x2++;
        box.y2++;

        TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PolyArc) (pDrawable, pGC, nArcs, pArcs);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damageFillPolygon(DrawablePtr pDrawable,
                  GCPtr pGC, int shape, int mode, int npt, DDXPointPtr ppt)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (npt > 2 && checkGCDamage(pDrawable, pGC)) {
        DDXPointPtr pptTmp = ppt;
        int nptTmp = npt;
        BoxRec box;

        box.x2 = box.x1 = pptTmp->x;
        box.y2 = box.y1 = pptTmp->y;

        if (mode != CoordModeOrigin) {
            int x = box.x1;
            int y = box.y1;

            while (--nptTmp) {
                pptTmp++;
                x += pptTmp->x;
                y += pptTmp->y;
                if (box.x1 > x)
                    box.x1 = x;
                else if (box.x2 < x)
                    box.x2 = x;
                if (box.y1 > y)
                    box.y1 = y;
                else if (box.y2 < y)
                    box.y2 = y;
            }
        }
        else {
            while (--nptTmp) {
                pptTmp++;
                if (box.x1 > pptTmp->x)
                    box.x1 = pptTmp->x;
                else if (box.x2 < pptTmp->x)
                    box.x2 = pptTmp->x;
                if (box.y1 > pptTmp->y)
                    box.y1 = pptTmp->y;
                else if (box.y2 < pptTmp->y)
                    box.y2 = pptTmp->y;
            }
        }

        box.x2++;
        box.y2++;

        TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }

    (*pGC->ops->FillPolygon) (pDrawable, pGC, shape, mode, npt, ppt);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolyFillRect(DrawablePtr pDrawable,
                   GCPtr pGC, int nRects, xRectangle *pRects)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    if (nRects && checkGCDamage(pDrawable, pGC)) {
        BoxRec box;
        xRectangle *pRectsTmp = pRects;
        int nRectsTmp = nRects;

        box.x1 = pRectsTmp->x;
        box.x2 = box.x1 + pRectsTmp->width;
        box.y1 = pRectsTmp->y;
        box.y2 = box.y1 + pRectsTmp->height;

        while (--nRectsTmp) {
            pRectsTmp++;
            if (box.x1 > pRectsTmp->x)
                box.x1 = pRectsTmp->x;
            if (box.x2 < (pRectsTmp->x + pRectsTmp->width))
                box.x2 = pRectsTmp->x + pRectsTmp->width;
            if (box.y1 > pRectsTmp->y)
                box.y1 = pRectsTmp->y;
            if (box.y2 < (pRectsTmp->y + pRectsTmp->height))
                box.y2 = pRectsTmp->y + pRectsTmp->height;
        }

        TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PolyFillRect) (pDrawable, pGC, nRects, pRects);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolyFillArc(DrawablePtr pDrawable, GCPtr pGC, int nArcs, xArc * pArcs)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);

    if (nArcs && checkGCDamage(pDrawable, pGC)) {
        BoxRec box;
        int nArcsTmp = nArcs;
        xArc *pArcsTmp = pArcs;

        box.x1 = pArcsTmp->x;
        box.x2 = box.x1 + pArcsTmp->width;
        box.y1 = pArcsTmp->y;
        box.y2 = box.y1 + pArcsTmp->height;

        while (--nArcsTmp) {
            pArcsTmp++;
            if (box.x1 > pArcsTmp->x)
                box.x1 = pArcsTmp->x;
            if (box.x2 < (pArcsTmp->x + pArcsTmp->width))
                box.x2 = pArcsTmp->x + pArcsTmp->width;
            if (box.y1 > pArcsTmp->y)
                box.y1 = pArcsTmp->y;
            if (box.y2 < (pArcsTmp->y + pArcsTmp->height))
                box.y2 = pArcsTmp->y + pArcsTmp->height;
        }

        TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PolyFillArc) (pDrawable, pGC, nArcs, pArcs);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

/*
 * general Poly/Image text function.  Extract glyph information,
 * compute bounding box and remove cursor if it is overlapped.
 */

static void
damageDamageChars(DrawablePtr pDrawable,
                  FontPtr font,
                  int x,
                  int y,
                  unsigned int n,
                  CharInfoPtr * charinfo, Bool imageblt, int subWindowMode)
{
    ExtentInfoRec extents;
    BoxRec box;

    QueryGlyphExtents(font, charinfo, n, &extents);
    if (imageblt) {
        if (extents.overallWidth > extents.overallRight)
            extents.overallRight = extents.overallWidth;
        if (extents.overallWidth < extents.overallLeft)
            extents.overallLeft = extents.overallWidth;
        if (extents.overallLeft > 0)
            extents.overallLeft = 0;
        if (extents.fontAscent > extents.overallAscent)
            extents.overallAscent = extents.fontAscent;
        if (extents.fontDescent > extents.overallDescent)
            extents.overallDescent = extents.fontDescent;
    }
    box.x1 = x + extents.overallLeft;
    box.y1 = y - extents.overallAscent;
    box.x2 = x + extents.overallRight;
    box.y2 = y + extents.overallDescent;
    damageDamageBox(pDrawable, &box, subWindowMode);
}

/*
 * values for textType:
 */
#define TT_POLY8   0
#define TT_IMAGE8  1
#define TT_POLY16  2
#define TT_IMAGE16 3

static void
damageText(DrawablePtr pDrawable,
           GCPtr pGC,
           int x,
           int y,
           unsigned long count,
           char *chars, FontEncoding fontEncoding, Bool textType)
{
    CharInfoPtr *charinfo;
    unsigned long i;
    unsigned int n;
    Bool imageblt;

    imageblt = (textType == TT_IMAGE8) || (textType == TT_IMAGE16);

    if (!checkGCDamage(pDrawable, pGC))
        return;

    charinfo = xallocarray(count, sizeof(CharInfoPtr));
    if (!charinfo)
        return;

    GetGlyphs(pGC->font, count, (unsigned char *) chars,
              fontEncoding, &i, charinfo);
    n = (unsigned int) i;

    if (n != 0) {
        damageDamageChars(pDrawable, pGC->font, x + pDrawable->x,
                          y + pDrawable->y, n, charinfo, imageblt,
                          pGC->subWindowMode);
    }
    free(charinfo);
}

static int
damagePolyText8(DrawablePtr pDrawable,
                GCPtr pGC, int x, int y, int count, char *chars)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    damageText(pDrawable, pGC, x, y, (unsigned long) count, chars, Linear8Bit,
               TT_POLY8);
    x = (*pGC->ops->PolyText8) (pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
    return x;
}

static int
damagePolyText16(DrawablePtr pDrawable,
                 GCPtr pGC, int x, int y, int count, unsigned short *chars)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    damageText(pDrawable, pGC, x, y, (unsigned long) count, (char *) chars,
               FONTLASTROW(pGC->font) == 0 ? Linear16Bit : TwoD16Bit,
               TT_POLY16);
    x = (*pGC->ops->PolyText16) (pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
    return x;
}

static void
damageImageText8(DrawablePtr pDrawable,
                 GCPtr pGC, int x, int y, int count, char *chars)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    damageText(pDrawable, pGC, x, y, (unsigned long) count, chars, Linear8Bit,
               TT_IMAGE8);
    (*pGC->ops->ImageText8) (pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damageImageText16(DrawablePtr pDrawable,
                  GCPtr pGC, int x, int y, int count, unsigned short *chars)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    damageText(pDrawable, pGC, x, y, (unsigned long) count, (char *) chars,
               FONTLASTROW(pGC->font) == 0 ? Linear16Bit : TwoD16Bit,
               TT_IMAGE16);
    (*pGC->ops->ImageText16) (pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damageImageGlyphBlt(DrawablePtr pDrawable,
                    GCPtr pGC,
                    int x,
                    int y,
                    unsigned int nglyph, CharInfoPtr * ppci, void *pglyphBase)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    damageDamageChars(pDrawable, pGC->font, x + pDrawable->x, y + pDrawable->y,
                      nglyph, ppci, TRUE, pGC->subWindowMode);
    (*pGC->ops->ImageGlyphBlt) (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePolyGlyphBlt(DrawablePtr pDrawable,
                   GCPtr pGC,
                   int x,
                   int y,
                   unsigned int nglyph, CharInfoPtr * ppci, void *pglyphBase)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    damageDamageChars(pDrawable, pGC->font, x + pDrawable->x, y + pDrawable->y,
                      nglyph, ppci, FALSE, pGC->subWindowMode);
    (*pGC->ops->PolyGlyphBlt) (pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damagePushPixels(GCPtr pGC,
                 PixmapPtr pBitMap,
                 DrawablePtr pDrawable, int dx, int dy, int xOrg, int yOrg)
{
    DAMAGE_GC_OP_PROLOGUE(pGC, pDrawable);
    if (checkGCDamage(pDrawable, pGC)) {
        BoxRec box;

        box.x1 = xOrg;
        box.y1 = yOrg;

        if (!pGC->miTranslate) {
            box.x1 += pDrawable->x;
            box.y1 += pDrawable->y;
        }

        box.x2 = box.x1 + dx;
        box.y2 = box.y1 + dy;

        TRIM_BOX(box, pGC);
        if (BOX_NOT_EMPTY(box))
            damageDamageBox(pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PushPixels) (pGC, pBitMap, pDrawable, dx, dy, xOrg, yOrg);
    damageRegionProcessPending(pDrawable);
    DAMAGE_GC_OP_EPILOGUE(pGC, pDrawable);
}

static void
damageRemoveDamage(DamagePtr * pPrev, DamagePtr pDamage)
{
    while (*pPrev) {
        if (*pPrev == pDamage) {
            *pPrev = pDamage->pNext;
            return;
        }
        pPrev = &(*pPrev)->pNext;
    }
#if DAMAGE_VALIDATE_ENABLE
    ErrorF("Damage not on list\n");
    OsAbort();
#endif
}

static void
damageInsertDamage(DamagePtr * pPrev, DamagePtr pDamage)
{
#if DAMAGE_VALIDATE_ENABLE
    DamagePtr pOld;

    for (pOld = *pPrev; pOld; pOld = pOld->pNext)
        if (pOld == pDamage) {
            ErrorF("Damage already on list\n");
            OsAbort();
        }
#endif
    pDamage->pNext = *pPrev;
    *pPrev = pDamage;
}

static Bool
damageDestroyPixmap(PixmapPtr pPixmap)
{
    ScreenPtr pScreen = pPixmap->drawable.pScreen;

    damageScrPriv(pScreen);

    if (pPixmap->refcnt == 1) {
        DamagePtr *pPrev = getPixmapDamageRef(pPixmap);
        DamagePtr pDamage;

        while ((pDamage = *pPrev)) {
            damageRemoveDamage(pPrev, pDamage);
            if (!pDamage->isWindow)
                DamageDestroy(pDamage);
        }
    }
    unwrap(pScrPriv, pScreen, DestroyPixmap);
    (*pScreen->DestroyPixmap) (pPixmap);
    wrap(pScrPriv, pScreen, DestroyPixmap, damageDestroyPixmap);
    return TRUE;
}

static void
damageCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;

    damageScrPriv(pScreen);

    if (getWindowDamage(pWindow)) {
        int dx = pWindow->drawable.x - ptOldOrg.x;
        int dy = pWindow->drawable.y - ptOldOrg.y;

        /*
         * The region comes in source relative, but the damage occurs
         * at the destination location.  Translate back and forth.
         */
        RegionTranslate(prgnSrc, dx, dy);
        damageRegionAppend(&pWindow->drawable, prgnSrc, FALSE, -1);
        RegionTranslate(prgnSrc, -dx, -dy);
    }
    unwrap(pScrPriv, pScreen, CopyWindow);
    (*pScreen->CopyWindow) (pWindow, ptOldOrg, prgnSrc);
    damageRegionProcessPending(&pWindow->drawable);
    wrap(pScrPriv, pScreen, CopyWindow, damageCopyWindow);
}

static GCOps damageGCOps = {
    damageFillSpans, damageSetSpans,
    damagePutImage, damageCopyArea,
    damageCopyPlane, damagePolyPoint,
    damagePolylines, damagePolySegment,
    damagePolyRectangle, damagePolyArc,
    damageFillPolygon, damagePolyFillRect,
    damagePolyFillArc, damagePolyText8,
    damagePolyText16, damageImageText8,
    damageImageText16, damageImageGlyphBlt,
    damagePolyGlyphBlt, damagePushPixels,
};

static void
damageSetWindowPixmap(WindowPtr pWindow, PixmapPtr pPixmap)
{
    DamagePtr pDamage;
    ScreenPtr pScreen = pWindow->drawable.pScreen;

    damageScrPriv(pScreen);

    if ((pDamage = damageGetWinPriv(pWindow))) {
        PixmapPtr pOldPixmap = (*pScreen->GetWindowPixmap) (pWindow);
        DamagePtr *pPrev = getPixmapDamageRef(pOldPixmap);

        while (pDamage) {
            damageRemoveDamage(pPrev, pDamage);
            pDamage = pDamage->pNextWin;
        }
    }
    unwrap(pScrPriv, pScreen, SetWindowPixmap);
    (*pScreen->SetWindowPixmap) (pWindow, pPixmap);
    wrap(pScrPriv, pScreen, SetWindowPixmap, damageSetWindowPixmap);
    if ((pDamage = damageGetWinPriv(pWindow))) {
        DamagePtr *pPrev = getPixmapDamageRef(pPixmap);

        while (pDamage) {
            damageInsertDamage(pPrev, pDamage);
            pDamage = pDamage->pNextWin;
        }
    }
}

static Bool
damageDestroyWindow(WindowPtr pWindow)
{
    DamagePtr pDamage;
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    Bool ret;

    damageScrPriv(pScreen);

    while ((pDamage = damageGetWinPriv(pWindow))) {
        DamageDestroy(pDamage);
    }
    unwrap(pScrPriv, pScreen, DestroyWindow);
    ret = (*pScreen->DestroyWindow) (pWindow);
    wrap(pScrPriv, pScreen, DestroyWindow, damageDestroyWindow);
    return ret;
}

static Bool
damageCloseScreen(ScreenPtr pScreen)
{
    damageScrPriv(pScreen);

    unwrap(pScrPriv, pScreen, DestroyPixmap);
    unwrap(pScrPriv, pScreen, CreateGC);
    unwrap(pScrPriv, pScreen, CopyWindow);
    unwrap(pScrPriv, pScreen, CloseScreen);
    free(pScrPriv);
    return (*pScreen->CloseScreen) (pScreen);
}

/**
 * Default implementations of the damage management functions.
 */
void
miDamageCreate(DamagePtr pDamage)
{
}

/*
 * We only wrap into the GC when there's a registered listener.  For windows,
 * damage includes damage to children.  So if there's a GC validated against
 * a subwindow and we then register a damage on the parent, we need to bump
 * the serial numbers of the children to re-trigger validation.
 *
 * Since we can't know if a GC has been validated against one of the affected
 * children, just bump them all to be safe.
 */
static int
damageRegisterVisit(WindowPtr pWin, void *data)
{
    pWin->drawable.serialNumber = NEXT_SERIAL_NUMBER;
    return WT_WALKCHILDREN;
}

void
miDamageRegister(DrawablePtr pDrawable, DamagePtr pDamage)
{
    if (pDrawable->type == DRAWABLE_WINDOW)
        TraverseTree((WindowPtr)pDrawable, damageRegisterVisit, NULL);
    else
        pDrawable->serialNumber = NEXT_SERIAL_NUMBER;
}

void
miDamageUnregister(DrawablePtr pDrawable, DamagePtr pDamage)
{
    if (pDrawable->type == DRAWABLE_WINDOW)
        TraverseTree((WindowPtr)pDrawable, damageRegisterVisit, NULL);
    else
        pDrawable->serialNumber = NEXT_SERIAL_NUMBER;
}

void
miDamageDestroy(DamagePtr pDamage)
{
}

/**
 * Public functions for consumption outside this file.
 */

Bool
DamageSetup(ScreenPtr pScreen)
{
    DamageScrPrivPtr pScrPriv;
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);

    const DamageScreenFuncsRec miFuncs = {
        miDamageCreate, miDamageRegister, miDamageUnregister, miDamageDestroy
    };

    if (!dixRegisterPrivateKey(&damageScrPrivateKeyRec, PRIVATE_SCREEN, 0))
        return FALSE;

    if (dixLookupPrivate(&pScreen->devPrivates, damageScrPrivateKey))
        return TRUE;

    if (!dixRegisterPrivateKey
        (&damageGCPrivateKeyRec, PRIVATE_GC, sizeof(DamageGCPrivRec)))
        return FALSE;

    if (!dixRegisterPrivateKey(&damagePixPrivateKeyRec, PRIVATE_PIXMAP, 0))
        return FALSE;

    if (!dixRegisterPrivateKey(&damageWinPrivateKeyRec, PRIVATE_WINDOW, 0))
        return FALSE;

    pScrPriv = malloc(sizeof(DamageScrPrivRec));
    if (!pScrPriv)
        return FALSE;

    pScrPriv->internalLevel = 0;
    pScrPriv->pScreenDamage = 0;

    wrap(pScrPriv, pScreen, DestroyPixmap, damageDestroyPixmap);
    wrap(pScrPriv, pScreen, CreateGC, damageCreateGC);
    wrap(pScrPriv, pScreen, DestroyWindow, damageDestroyWindow);
    wrap(pScrPriv, pScreen, SetWindowPixmap, damageSetWindowPixmap);
    wrap(pScrPriv, pScreen, CopyWindow, damageCopyWindow);
    wrap(pScrPriv, pScreen, CloseScreen, damageCloseScreen);
    if (ps) {
        wrap(pScrPriv, ps, Glyphs, damageGlyphs);
        wrap(pScrPriv, ps, Composite, damageComposite);
        wrap(pScrPriv, ps, AddTraps, damageAddTraps);
    }

    pScrPriv->funcs = miFuncs;

    dixSetPrivate(&pScreen->devPrivates, damageScrPrivateKey, pScrPriv);
    return TRUE;
}

DamagePtr
DamageCreate(DamageReportFunc damageReport,
             DamageDestroyFunc damageDestroy,
             DamageReportLevel damageLevel,
             Bool isInternal, ScreenPtr pScreen, void *closure)
{
    damageScrPriv(pScreen);
    DamagePtr pDamage;

    pDamage = dixAllocateObjectWithPrivates(DamageRec, PRIVATE_DAMAGE);
    if (!pDamage)
        return 0;
    pDamage->pNext = 0;
    pDamage->pNextWin = 0;
    RegionNull(&pDamage->damage);
    RegionNull(&pDamage->pendingDamage);

    pDamage->damageLevel = damageLevel;
    pDamage->isInternal = isInternal;
    pDamage->closure = closure;
    pDamage->isWindow = FALSE;
    pDamage->pDrawable = 0;
    pDamage->reportAfter = FALSE;

    pDamage->damageReport = damageReport;
    pDamage->damageDestroy = damageDestroy;
    pDamage->pScreen = pScreen;

    (*pScrPriv->funcs.Create) (pDamage);

    return pDamage;
}

void
DamageRegister(DrawablePtr pDrawable, DamagePtr pDamage)
{
    ScreenPtr pScreen = pDrawable->pScreen;

    damageScrPriv(pScreen);

#if DAMAGE_VALIDATE_ENABLE
    if (pDrawable->pScreen != pDamage->pScreen) {
        ErrorF("DamageRegister called with mismatched screens\n");
        OsAbort();
    }
#endif

    if (pDrawable->type == DRAWABLE_WINDOW) {
        WindowPtr pWindow = (WindowPtr) pDrawable;

        winDamageRef(pWindow);

#if DAMAGE_VALIDATE_ENABLE
        DamagePtr pOld;

        for (pOld = *pPrev; pOld; pOld = pOld->pNextWin)
            if (pOld == pDamage) {
                ErrorF("Damage already on window list\n");
                OsAbort();
            }
#endif
        pDamage->pNextWin = *pPrev;
        *pPrev = pDamage;
        pDamage->isWindow = TRUE;
    }
    else
        pDamage->isWindow = FALSE;
    pDamage->pDrawable = pDrawable;
    damageInsertDamage(getDrawableDamageRef(pDrawable), pDamage);
    (*pScrPriv->funcs.Register) (pDrawable, pDamage);
}

void
DamageDrawInternal(ScreenPtr pScreen, Bool enable)
{
    damageScrPriv(pScreen);

    pScrPriv->internalLevel += enable ? 1 : -1;
}

void
DamageUnregister(DamagePtr pDamage)
{
    DrawablePtr pDrawable = pDamage->pDrawable;
    ScreenPtr pScreen = pDrawable->pScreen;

    damageScrPriv(pScreen);

    (*pScrPriv->funcs.Unregister) (pDrawable, pDamage);

    if (pDrawable->type == DRAWABLE_WINDOW) {
        WindowPtr pWindow = (WindowPtr) pDrawable;

        winDamageRef(pWindow);
#if DAMAGE_VALIDATE_ENABLE
        int found = 0;
#endif

        while (*pPrev) {
            if (*pPrev == pDamage) {
                *pPrev = pDamage->pNextWin;
#if DAMAGE_VALIDATE_ENABLE
                found = 1;
#endif
                break;
            }
            pPrev = &(*pPrev)->pNextWin;
        }
#if DAMAGE_VALIDATE_ENABLE
        if (!found) {
            ErrorF("Damage not on window list\n");
            OsAbort();
        }
#endif
    }
    pDamage->pDrawable = 0;
    damageRemoveDamage(getDrawableDamageRef(pDrawable), pDamage);
}

void
DamageDestroy(DamagePtr pDamage)
{
    ScreenPtr pScreen = pDamage->pScreen;

    damageScrPriv(pScreen);

    if (pDamage->pDrawable)
        DamageUnregister(pDamage);

    if (pDamage->damageDestroy)
        (*pDamage->damageDestroy) (pDamage, pDamage->closure);
    (*pScrPriv->funcs.Destroy) (pDamage);
    RegionUninit(&pDamage->damage);
    RegionUninit(&pDamage->pendingDamage);
    dixFreeObjectWithPrivates(pDamage, PRIVATE_DAMAGE);
}

Bool
DamageSubtract(DamagePtr pDamage, const RegionPtr pRegion)
{
    RegionPtr pClip;
    RegionRec pixmapClip;
    DrawablePtr pDrawable = pDamage->pDrawable;

    RegionSubtract(&pDamage->damage, &pDamage->damage, pRegion);
    if (pDrawable) {
        if (pDrawable->type == DRAWABLE_WINDOW)
            pClip = &((WindowPtr) pDrawable)->borderClip;
        else {
            BoxRec box;

            box.x1 = pDrawable->x;
            box.y1 = pDrawable->y;
            box.x2 = pDrawable->x + pDrawable->width;
            box.y2 = pDrawable->y + pDrawable->height;
            RegionInit(&pixmapClip, &box, 1);
            pClip = &pixmapClip;
        }
        RegionTranslate(&pDamage->damage, pDrawable->x, pDrawable->y);
        RegionIntersect(&pDamage->damage, &pDamage->damage, pClip);
        RegionTranslate(&pDamage->damage, -pDrawable->x, -pDrawable->y);
        if (pDrawable->type != DRAWABLE_WINDOW)
            RegionUninit(&pixmapClip);
    }
    return RegionNotEmpty(&pDamage->damage);
}

void
DamageEmpty(DamagePtr pDamage)
{
    RegionEmpty(&pDamage->damage);
}

RegionPtr
DamageRegion(DamagePtr pDamage)
{
    return &pDamage->damage;
}

RegionPtr
DamagePendingRegion(DamagePtr pDamage)
{
    return &pDamage->pendingDamage;
}

void
DamageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion)
{
    damageRegionAppend(pDrawable, pRegion, FALSE, -1);
}

void
DamageRegionProcessPending(DrawablePtr pDrawable)
{
    damageRegionProcessPending(pDrawable);
}

/* This call is very odd, i'm leaving it intact for API sake, but please don't use it. */
void
DamageDamageRegion(DrawablePtr pDrawable, RegionPtr pRegion)
{
    damageRegionAppend(pDrawable, pRegion, FALSE, -1);

    /* Go back and report this damage for DamagePtrs with reportAfter set, since
     * this call isn't part of an in-progress drawing op in the call chain and
     * the DDX probably just wants to know about it right away.
     */
    damageRegionProcessPending(pDrawable);
}

void
DamageSetReportAfterOp(DamagePtr pDamage, Bool reportAfter)
{
    pDamage->reportAfter = reportAfter;
}

DamageScreenFuncsPtr
DamageGetScreenFuncs(ScreenPtr pScreen)
{
    damageScrPriv(pScreen);
    return &pScrPriv->funcs;
}

void
DamageReportDamage(DamagePtr pDamage, RegionPtr pDamageRegion)
{
    BoxRec tmpBox;
    RegionRec tmpRegion;
    Bool was_empty;

    switch (pDamage->damageLevel) {
    case DamageReportRawRegion:
        RegionUnion(&pDamage->damage, &pDamage->damage, pDamageRegion);
        (*pDamage->damageReport) (pDamage, pDamageRegion, pDamage->closure);
        break;
    case DamageReportDeltaRegion:
        RegionNull(&tmpRegion);
        RegionSubtract(&tmpRegion, pDamageRegion, &pDamage->damage);
        if (RegionNotEmpty(&tmpRegion)) {
            RegionUnion(&pDamage->damage, &pDamage->damage, pDamageRegion);
            (*pDamage->damageReport) (pDamage, &tmpRegion, pDamage->closure);
        }
        RegionUninit(&tmpRegion);
        break;
    case DamageReportBoundingBox:
        tmpBox = *RegionExtents(&pDamage->damage);
        RegionUnion(&pDamage->damage, &pDamage->damage, pDamageRegion);
        if (!BOX_SAME(&tmpBox, RegionExtents(&pDamage->damage))) {
            (*pDamage->damageReport) (pDamage, &pDamage->damage,
                                      pDamage->closure);
        }
        break;
    case DamageReportNonEmpty:
        was_empty = !RegionNotEmpty(&pDamage->damage);
        RegionUnion(&pDamage->damage, &pDamage->damage, pDamageRegion);
        if (was_empty && RegionNotEmpty(&pDamage->damage)) {
            (*pDamage->damageReport) (pDamage, &pDamage->damage,
                                      pDamage->closure);
        }
        break;
    case DamageReportNone:
        RegionUnion(&pDamage->damage, &pDamage->damage, pDamageRegion);
        break;
    }
}
@


1.12
log
@Update to xserver 1.17.2. tested by dcoppa@@, jsg@@, jasper@@ & naddy@@
@
text
@d35 1
d1297 1
a1297 1
    charinfo = malloc(count * sizeof(CharInfoPtr));
@


1.11
log
@Update to xserver 1.16.1.

Tested by naddy@@, jsg@@ & kettenis@@
@
text
@d1594 1
a1594 1
static int 
@


1.10
log
@Update to xserver 1.15.1.

Tested by at least ajacoutot@@, dcoppa@@ & jasper@@
@
text
@d329 1
a329 1
static void damageChangeClip(GCPtr, int, pointer, int);
d362 1
a362 1
    GCFuncs *oldFuncs = pGC->funcs; \
a381 1
    drawableDamage(pDrawable);
d413 1
a413 1
damageChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects)
d1369 1
a1369 1
                    unsigned int nglyph, CharInfoPtr * ppci, pointer pglyphBase)
d1384 1
a1384 1
                   unsigned int nglyph, CharInfoPtr * ppci, pointer pglyphBase)
@


1.9
log
@Update to xserver 1.14.5
@
text
@a121 45
static void
damageReportDamagePostRendering(DamagePtr pDamage, RegionPtr pOldDamage,
                                RegionPtr pDamageRegion)
{
    BoxRec tmpBox;
    RegionRec tmpRegion, newDamage;
    Bool was_empty;

    RegionUnion(&newDamage, pOldDamage, pDamageRegion);

    switch (pDamage->damageLevel) {
    case DamageReportRawRegion:
        (*pDamage->damageReportPostRendering) (pDamage, pDamageRegion,
                                               pDamage->closure);
        break;
    case DamageReportDeltaRegion:
        RegionNull(&tmpRegion);
        RegionSubtract(&tmpRegion, pDamageRegion, pOldDamage);
        if (RegionNotEmpty(&tmpRegion)) {
            (*pDamage->damageReportPostRendering) (pDamage, &tmpRegion,
                                                   pDamage->closure);
        }
        RegionUninit(&tmpRegion);
        break;
    case DamageReportBoundingBox:
        tmpBox = *RegionExtents(pOldDamage);
        if (!BOX_SAME(&tmpBox, RegionExtents(&newDamage))) {
            (*pDamage->damageReportPostRendering) (pDamage, &newDamage,
                                                   pDamage->closure);
        }
        break;
    case DamageReportNonEmpty:
        was_empty = !RegionNotEmpty(pOldDamage);
        if (was_empty && RegionNotEmpty(&newDamage)) {
            (*pDamage->damageReportPostRendering) (pDamage, &newDamage,
                                                   pDamage->closure);
        }
        break;
    case DamageReportNone:
        break;
    }

    RegionUninit(&newDamage);
}

d257 1
a257 1
        if (pDamage->reportAfter || pDamage->damageMarker)
a260 4
        /* Duplicate current damage if needed. */
        if (pDamage->damageMarker)
            RegionCopy(&pDamage->backupDamage, &pDamage->damage);

a288 6
        /* submit damage marker whenever possible. */
        if (pDamage->damageMarker)
            (*pDamage->damageMarker) (pDrawable, pDamage,
                                      &pDamage->backupDamage,
                                      &pDamage->pendingDamage,
                                      pDamage->closure);
d298 1
a298 1
        if (pDamage->reportAfter || pDamage->damageMarker)
a299 2
        if (pDamage->damageMarker)
            RegionEmpty(&pDamage->backupDamage);
d1279 1
a1279 1
static int
a1287 1
    CharInfoPtr *info;
a1289 1
    int w;
d1294 3
d1299 1
a1299 1
        return x;
a1303 4
    w = 0;
    if (!imageblt)
        for (info = charinfo; i--; info++)
            w += (*info)->metrics.characterWidth;
a1308 6
        if (imageblt)
            (*pGC->ops->ImageGlyphBlt) (pDrawable, pGC, x, y, n, charinfo,
                                        FONTGLYPHS(pGC->font));
        else
            (*pGC->ops->PolyGlyphBlt) (pDrawable, pGC, x, y, n, charinfo,
                                       FONTGLYPHS(pGC->font));
a1310 1
    return x + w;
d1318 3
a1320 6

    if (checkGCDamage(pDrawable, pGC))
        x = damageText(pDrawable, pGC, x, y, (unsigned long) count, chars,
                       Linear8Bit, TT_POLY8);
    else
        x = (*pGC->ops->PolyText8) (pDrawable, pGC, x, y, count, chars);
d1331 4
a1334 8

    if (checkGCDamage(pDrawable, pGC))
        x = damageText(pDrawable, pGC, x, y, (unsigned long) count,
                       (char *) chars,
                       FONTLASTROW(pGC->font) == 0 ? Linear16Bit : TwoD16Bit,
                       TT_POLY16);
    else
        x = (*pGC->ops->PolyText16) (pDrawable, pGC, x, y, count, chars);
d1345 3
a1347 6

    if (checkGCDamage(pDrawable, pGC))
        damageText(pDrawable, pGC, x, y, (unsigned long) count, chars,
                   Linear8Bit, TT_IMAGE8);
    else
        (*pGC->ops->ImageText8) (pDrawable, pGC, x, y, count, chars);
d1357 4
a1360 7

    if (checkGCDamage(pDrawable, pGC))
        damageText(pDrawable, pGC, x, y, (unsigned long) count, (char *) chars,
                   FONTLASTROW(pGC->font) == 0 ? Linear16Bit : TwoD16Bit,
                   TT_IMAGE16);
    else
        (*pGC->ops->ImageText16) (pDrawable, pGC, x, y, count, chars);
a1556 1
        DamageUnregister(&pWindow->drawable, pDamage);
a1704 1
    pDamage->damageReportPostRendering = NULL;
a1705 1
    pDamage->damageMarker = NULL;
d1761 1
a1761 1
DamageUnregister(DrawablePtr pDrawable, DamagePtr pDamage)
d1763 1
d1806 3
a1876 11
/* If a damage marker is provided, then this function must be called after rendering is done. */
/* Please do call back so any future enhancements can assume this function is called. */
/* There are no strict timing requirements for calling this function, just as soon as (is cheaply) possible. */
void
DamageRegionRendered(DrawablePtr pDrawable, DamagePtr pDamage,
                     RegionPtr pOldDamage, RegionPtr pRegion)
{
    if (pDamage->damageReportPostRendering)
        damageReportDamagePostRendering(pDamage, pOldDamage, pRegion);
}

a1893 9
}

void
DamageSetPostRenderingFunctions(DamagePtr pDamage,
                                DamageReportFunc damageReportPostRendering,
                                DamageMarkerFunc damageMarker)
{
    pDamage->damageReportPostRendering = damageReportPostRendering;
    pDamage->damageMarker = damageMarker;
@


1.8
log
@Update to X server 1.14.1. Tested by many during t2k13. Thanks.
@
text
@d442 1
a442 4
    if (pDamage)
        pGCPriv->ops = pGC->ops; /* so it's not NULL, so FUNC_EPILOGUE does work */
    else
        pGCPriv->ops = NULL;
@


1.7
log
@Update to xserver 1.12.2. tested by naddy@@, krw@@, mpi@@.
@
text
@a40 3
#ifdef COMPOSITE
#include    "cw.h"
#endif
d439 1
d442 4
a445 1
    pGCPriv->ops = pGC->ops;    /* just so it's not NULL */
d1650 1
a1650 1
damageCloseScreen(int i, ScreenPtr pScreen)
d1659 1
a1659 1
    return (*pScreen->CloseScreen) (i, pScreen);
d1670 16
d1689 4
d1698 4
@


1.6
log
@Update to xserver 1.11.2
@
text
@d74 1
d77 1
d80 1
d83 1
d87 1
a87 1
getDrawableDamageRef (DrawablePtr pDrawable)
d89 1
a89 5
    PixmapPtr   pPixmap;
    
    if (WindowDrawable(pDrawable->type))
    {
	ScreenPtr   pScreen = pDrawable->pScreen;
d91 5
a95 2
	pPixmap = 0;
	if (pScreen->GetWindowPixmap
d97 1
a97 1
	    && ((WindowPtr)pDrawable)->viewable
d99 2
a100 2
	    )
	    pPixmap = (*pScreen->GetWindowPixmap) ((WindowPtr)pDrawable);
d102 2
a103 3
	if (!pPixmap)
	{
	    damageScrPriv(pScreen);
d105 2
a106 2
	    return &pScrPriv->pScreenDamage;
	}
d109 2
a110 2
	pPixmap = (PixmapPtr) pDrawable;
    return getPixmapDamageRef (pPixmap);
d126 2
a127 1
damageReportDamagePostRendering (DamagePtr pDamage, RegionPtr pOldDamage, RegionPtr pDamageRegion)
d137 3
a139 2
	(*pDamage->damageReportPostRendering) (pDamage, pDamageRegion, pDamage->closure);
	break;
d141 8
a148 7
	RegionNull(&tmpRegion);
	RegionSubtract(&tmpRegion, pDamageRegion, pOldDamage);
	if (RegionNotEmpty(&tmpRegion)) {
	    (*pDamage->damageReportPostRendering) (pDamage, &tmpRegion, pDamage->closure);
	}
	RegionUninit(&tmpRegion);
	break;
d150 6
a155 6
	tmpBox = *RegionExtents(pOldDamage);
	if (!BOX_SAME (&tmpBox, RegionExtents(&newDamage))) {
	    (*pDamage->damageReportPostRendering) (pDamage, &newDamage,
				      pDamage->closure);
	}
	break;
d157 6
a162 6
	was_empty = !RegionNotEmpty(pOldDamage);
	if (was_empty && RegionNotEmpty(&newDamage)) {
	    (*pDamage->damageReportPostRendering) (pDamage, &newDamage,
				      pDamage->closure);
	}
	break;
d164 1
a164 1
	break;
d172 2
a173 1
_damageRegionAppend (DrawablePtr pDrawable, RegionPtr pRegion, Bool clip, int subWindowMode, const char *where)
d177 2
a178 2
damageRegionAppend (DrawablePtr pDrawable, RegionPtr pRegion, Bool clip,
			int subWindowMode)
d181 2
a182 1
    ScreenPtr	    pScreen = pDrawable->pScreen;
d185 6
a190 5
    DamagePtr	    pNext;
    RegionRec	    clippedRec;
    RegionPtr	    pDamageRegion;
    RegionRec	    pixClip;
    int		    draw_x, draw_y;
d192 1
a192 1
    int		    screen_x = 0, screen_y = 0;
d197 2
a198 2
	return;
    
d205 3
a207 4
    if (pDrawable->type != DRAWABLE_WINDOW)
    {
	screen_x = ((PixmapPtr) pDrawable)->screen_x - pDrawable->x;
	screen_y = ((PixmapPtr) pDrawable)->screen_y - pDrawable->y;
d212 1
a212 1
	
d214 13
a226 16
	((WindowPtr)(pDrawable))->backingStore == NotUseful)
    {
	if (subWindowMode == ClipByChildren)
	{
	    RegionIntersect(pRegion, pRegion,
			     &((WindowPtr)(pDrawable))->clipList);
	}
	else if (subWindowMode == IncludeInferiors)
	{
	    RegionPtr pTempRegion =
		NotClippedByChildren((WindowPtr)(pDrawable));
	    RegionIntersect(pRegion, pRegion, pTempRegion);
	    RegionDestroy(pTempRegion);
	}
	/* If subWindowMode is set to an invalid value, don't perform
	 * any drawable-based clipping. */
a227 1
        
d230 20
a249 23
    for (; pDamage; pDamage = pNext)
    {
	pNext = pDamage->pNext;
	/*
	 * Check for internal damage and don't send events
	 */
	if (pScrPriv->internalLevel > 0 && !pDamage->isInternal)
	{
	    DAMAGE_DEBUG (("non internal damage, skipping at %d\n",
			   pScrPriv->internalLevel));
	    continue;
	}
	/*
	 * Check for unrealized windows
	 */
	if (pDamage->pDrawable->type == DRAWABLE_WINDOW &&
	    !((WindowPtr) (pDamage->pDrawable))->realized)
	{
	    continue;
	}
	
	draw_x = pDamage->pDrawable->x;
	draw_y = pDamage->pDrawable->y;
d251 8
a258 9
	/*
	 * Need to move everyone to screen coordinates
	 * XXX what about off-screen pixmaps with non-zero x/y?
	 */
	if (!WindowDrawable(pDamage->pDrawable->type))
	{
	    draw_x += ((PixmapPtr) pDamage->pDrawable)->screen_x;
	    draw_y += ((PixmapPtr) pDamage->pDrawable)->screen_y;
	}
d260 66
a325 65
	
	/*
	 * Clip against border or pixmap bounds
	 */
	
	pDamageRegion = pRegion;
	if (clip || pDamage->pDrawable != pDrawable)
	{
	    pDamageRegion = &clippedRec;
	    if (pDamage->pDrawable->type == DRAWABLE_WINDOW) {
		RegionIntersect(pDamageRegion, pRegion,
		    &((WindowPtr)(pDamage->pDrawable))->borderClip);
	    } else {
		BoxRec	box;
		box.x1 = draw_x;
		box.y1 = draw_y;
		box.x2 = draw_x + pDamage->pDrawable->width;
		box.y2 = draw_y + pDamage->pDrawable->height;
		RegionInit(&pixClip, &box, 1);
		RegionIntersect(pDamageRegion, pRegion, &pixClip);
		RegionUninit(&pixClip);
	    }
	    /*
	     * Short circuit empty results
	     */
	    if (!RegionNotEmpty(pDamageRegion))
		continue;
	}
	
	DAMAGE_DEBUG (("%s %d x %d +%d +%d (target 0x%lx monitor 0x%lx)\n",
		       where,
		       pDamageRegion->extents.x2 - pDamageRegion->extents.x1,
		       pDamageRegion->extents.y2 - pDamageRegion->extents.y1,
		       pDamageRegion->extents.x1, pDamageRegion->extents.y1,
		       pDrawable->id, pDamage->pDrawable->id));
	
	/*
	 * Move region to target coordinate space
	 */
	if (draw_x || draw_y)
	    RegionTranslate(pDamageRegion, -draw_x, -draw_y);

	/* Store damage region if needed after submission. */
	if (pDamage->reportAfter || pDamage->damageMarker)
	    RegionUnion(&pDamage->pendingDamage,
			 &pDamage->pendingDamage, pDamageRegion);

	/* Duplicate current damage if needed. */
	if (pDamage->damageMarker)
	    RegionCopy(&pDamage->backupDamage, &pDamage->damage);

	/* Report damage now, if desired. */
	if (!pDamage->reportAfter) {
	    if (pDamage->damageReport)
		DamageReportDamage (pDamage, pDamageRegion);
	    else
		RegionUnion(&pDamage->damage,
			 &pDamage->damage, pDamageRegion);
	}

	/*
	 * translate original region back
	 */
	if (pDamageRegion == pRegion && (draw_x || draw_y))
	    RegionTranslate(pDamageRegion, draw_x, draw_y);
d329 1
a329 1
	RegionTranslate(pRegion, -screen_x, -screen_y);
d331 1
a331 1
    
d336 1
a336 1
damageRegionProcessPending (DrawablePtr pDrawable)
d340 20
a359 18
    for (; pDamage != NULL; pDamage = pDamage->pNext)
    {
	/* submit damage marker whenever possible. */
	if (pDamage->damageMarker)
	    (*pDamage->damageMarker) (pDrawable, pDamage, &pDamage->backupDamage, &pDamage->pendingDamage, pDamage->closure);
	if (pDamage->reportAfter) {
	    /* It's possible that there is only interest in postRendering reporting. */
	    if (pDamage->damageReport)
		DamageReportDamage (pDamage, &pDamage->pendingDamage);
	    else
		RegionUnion(&pDamage->damage, &pDamage->damage,
			&pDamage->pendingDamage);
	}

	if (pDamage->reportAfter || pDamage->damageMarker)
	    RegionEmpty(&pDamage->pendingDamage);
	if (pDamage->damageMarker)
	    RegionEmpty(&pDamage->backupDamage);
d361 1
a361 1
    
d367 2
a368 1
_damageDamageBox (DrawablePtr pDrawable, BoxPtr pBox, int subWindowMode, const char *where)
d371 1
a371 1
damageDamageBox (DrawablePtr pDrawable, BoxPtr pBox, int subWindowMode)
d374 1
a374 1
    RegionRec	region;
d378 1
a378 1
    _damageRegionAppend (pDrawable, &region, TRUE, subWindowMode, where);
d380 1
a380 1
    damageRegionAppend (pDrawable, &region, TRUE, subWindowMode);
d404 1
d409 5
a413 5
    unwrap (pScrPriv, pScreen, CreateGC);
    if((ret = (*pScreen->CreateGC) (pGC))) {
	pGCPriv->ops = NULL;
	pGCPriv->funcs = pGC->funcs;
	pGC->funcs = &damageGCFuncs;
d415 1
a415 1
    wrap (pScrPriv, pScreen, CreateGC, damageCreateGC);
d440 6
a445 8
damageValidateGC(GCPtr         pGC,
		 unsigned long changes,
		 DrawablePtr   pDrawable)
{
    DAMAGE_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->ValidateGC)(pGC, changes, pDrawable);
    pGCPriv->ops = pGC->ops;  /* just so it's not NULL */
    DAMAGE_GC_FUNC_EPILOGUE (pGC);
d451 3
a453 3
    DAMAGE_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->DestroyGC)(pGC);
    DAMAGE_GC_FUNC_EPILOGUE (pGC);
d457 1
a457 2
damageChangeGC (GCPtr		pGC,
		unsigned long   mask)
d459 1
a459 1
    DAMAGE_GC_FUNC_PROLOGUE (pGC);
d461 1
a461 1
    DAMAGE_GC_FUNC_EPILOGUE (pGC);
d465 1
a465 3
damageCopyGC (GCPtr	    pGCSrc,
	      unsigned long mask,
	      GCPtr	    pGCDst)
d467 1
a467 1
    DAMAGE_GC_FUNC_PROLOGUE (pGCDst);
d469 1
a469 1
    DAMAGE_GC_FUNC_EPILOGUE (pGCDst);
d473 1
a473 4
damageChangeClip (GCPtr	    pGC,
		  int	    type,
		  pointer   pvalue,
		  int	    nrects)
d475 1
a475 1
    DAMAGE_GC_FUNC_PROLOGUE (pGC);
d477 1
a477 1
    DAMAGE_GC_FUNC_EPILOGUE (pGC);
d483 3
a485 3
    DAMAGE_GC_FUNC_PROLOGUE (pgcDst);
    (* pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
    DAMAGE_GC_FUNC_EPILOGUE (pgcDst);
d491 3
a493 3
    DAMAGE_GC_FUNC_PROLOGUE (pGC);
    (* pGC->funcs->DestroyClip)(pGC);
    DAMAGE_GC_FUNC_EPILOGUE (pGC);
d530 1
a530 1
    
d535 9
a543 12
damageComposite (CARD8      op,
		   PicturePtr pSrc,
		   PicturePtr pMask,
		   PicturePtr pDst,
		   INT16      xSrc,
		   INT16      ySrc,
		   INT16      xMask,
		   INT16      yMask,
		   INT16      xDst,
		   INT16      yDst,
		   CARD16     width,
		   CARD16     height)
d545 3
a547 2
    ScreenPtr		pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
d550 10
a559 11
    if (checkPictureDamage (pDst))
    {
	BoxRec	box;

	box.x1 = xDst + pDst->pDrawable->x;
	box.y1 = yDst + pDst->pDrawable->y;
	box.x2 = box.x1 + width;
	box.y2 = box.y1 + height;
	TRIM_PICTURE_BOX(box, pDst);
	if (BOX_NOT_EMPTY(box))
	    damageDamageBox (pDst->pDrawable, &box, pDst->subWindowMode);
d561 1
a561 1
    unwrap (pScrPriv, ps, Composite);
d563 6
a568 13
		       pSrc,
		       pMask,
		       pDst,
		       xSrc,
		       ySrc,
		       xMask,
		       yMask,
		       xDst,
		       yDst,
		       width,
		       height);
    damageRegionProcessPending (pDst->pDrawable);
    wrap (pScrPriv, ps, Composite, damageComposite);
d572 6
a577 9
damageGlyphs (CARD8		op,
		PicturePtr	pSrc,
		PicturePtr	pDst,
		PictFormatPtr	maskFormat,
		INT16		xSrc,
		INT16		ySrc,
		int		nlist,
		GlyphListPtr	list,
		GlyphPtr	*glyphs)
d579 3
a581 2
    ScreenPtr		pScreen = pDst->pDrawable->pScreen;
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
d584 42
a625 45
    if (checkPictureDamage (pDst))
    {
	int		nlistTmp = nlist;
	GlyphListPtr	listTmp = list;
	GlyphPtr	*glyphsTmp = glyphs;
	int		x, y;
	int		n;
	GlyphPtr	glyph;
	BoxRec		box;
	int		x1, y1, x2, y2;

	box.x1 = 32767;
	box.y1 = 32767;
	box.x2 = -32767;
	box.y2 = -32767;
	x = pDst->pDrawable->x;
	y = pDst->pDrawable->y;
	while (nlistTmp--)
	{
	    x += listTmp->xOff;
	    y += listTmp->yOff;
	    n = listTmp->len;
	    while (n--)
	    {
		glyph = *glyphsTmp++;
		x1 = x - glyph->info.x;
		y1 = y - glyph->info.y;
		x2 = x1 + glyph->info.width;
		y2 = y1 + glyph->info.height;
		if (x1 < box.x1)
		    box.x1 = x1;
		if (y1 < box.y1)
		    box.y1 = y1;
		if (x2 > box.x2)
		    box.x2 = x2;
		if (y2 > box.y2)
		    box.y2 = y2;
		x += glyph->info.xOff;
		y += glyph->info.yOff;
	    }
	    listTmp++;
	}
	TRIM_PICTURE_BOX (box, pDst);
	if (BOX_NOT_EMPTY(box))
	    damageDamageBox (pDst->pDrawable, &box, pDst->subWindowMode);
d627 1
a627 1
    unwrap (pScrPriv, ps, Glyphs);
d629 2
a630 2
    damageRegionProcessPending (pDst->pDrawable);
    wrap (pScrPriv, ps, Glyphs, damageGlyphs);
d634 2
a635 5
damageAddTraps (PicturePtr  pPicture,
		INT16	    x_off,
		INT16	    y_off,
		int	    ntrap,
		xTrap	    *traps)
d637 3
a639 2
    ScreenPtr		pScreen = pPicture->pDrawable->pScreen;
    PictureScreenPtr	ps = GetPictureScreen(pScreen);
d642 32
a673 34
    if (checkPictureDamage (pPicture))
    {
	BoxRec	box;
	int	i;
	int	x, y;
	xTrap	*t = traps;

	box.x1 = 32767;
	box.y1 = 32767;
	box.x2 = -32767;
	box.y2 = -32767;
	x = pPicture->pDrawable->x + x_off;
	y = pPicture->pDrawable->y + y_off;
	for (i = 0; i < ntrap; i++)
	{
	    pixman_fixed_t   l = min (t->top.l, t->bot.l);
	    pixman_fixed_t   r = max (t->top.r, t->bot.r);
	    int	    x1 = x + pixman_fixed_to_int (l);
	    int	    x2 = x + pixman_fixed_to_int (pixman_fixed_ceil (r));
	    int	    y1 = y + pixman_fixed_to_int (t->top.y);
	    int	    y2 = y + pixman_fixed_to_int (pixman_fixed_ceil (t->bot.y));
	    
	    if (x1 < box.x1)
		box.x1 = x1;
	    if (x2 > box.x2)
		box.x2 = x2;
	    if (y1 < box.y1)
		box.y1 = y1;
	    if (y2 > box.y2)
		box.y2 = y2;
	}
	TRIM_PICTURE_BOX (box, pPicture);
	if (BOX_NOT_EMPTY(box))
	    damageDamageBox (pPicture->pDrawable, &box, pPicture->subWindowMode);
d675 1
a675 1
    unwrap (pScrPriv, ps, AddTraps);
d677 2
a678 2
    damageRegionProcessPending (pPicture->pDrawable);
    wrap (pScrPriv, ps, AddTraps, damageAddTraps);
a682 1

d685 1
a685 5
		GC	    *pGC,
		int	    npt,
		DDXPointPtr ppt,
		int	    *pwidth,
		int	    fSorted)
d689 29
a717 28
    if (npt && checkGCDamage (pDrawable, pGC))
    {
	int	    nptTmp = npt;
	DDXPointPtr pptTmp = ppt;
	int	    *pwidthTmp = pwidth;
	BoxRec	    box;

	box.x1 = pptTmp->x;
	box.x2 = box.x1 + *pwidthTmp;
	box.y2 = box.y1 = pptTmp->y;

	while(--nptTmp) 
	{
	   pptTmp++;
	   pwidthTmp++;
	   if(box.x1 > pptTmp->x) box.x1 = pptTmp->x;
	   if(box.x2 < (pptTmp->x + *pwidthTmp))
		box.x2 = pptTmp->x + *pwidthTmp;
	   if(box.y1 > pptTmp->y) box.y1 = pptTmp->y;
	   else if(box.y2 < pptTmp->y) box.y2 = pptTmp->y;
	}

	box.y2++;

        if(!pGC->miTranslate) {
           TRANSLATE_BOX(box, pDrawable);
        }
        TRIM_BOX(box, pGC); 
d719 2
a720 2
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
a721 2
    
    (*pGC->ops->FillSpans)(pDrawable, pGC, npt, ppt, pwidth, fSorted);
d723 3
a725 1
    damageRegionProcessPending (pDrawable);
d730 4
a733 7
damageSetSpans(DrawablePtr  pDrawable,
	       GCPtr	    pGC,
	       char	    *pcharsrc,
	       DDXPointPtr  ppt,
	       int	    *pwidth,
	       int	    npt,
	       int	    fSorted)
d737 21
a757 26
    if (npt && checkGCDamage (pDrawable, pGC))
    {
	DDXPointPtr pptTmp = ppt;
	int	    *pwidthTmp = pwidth;
	int	    nptTmp = npt;
	BoxRec	    box;

	box.x1 = pptTmp->x;
	box.x2 = box.x1 + *pwidthTmp;
	box.y2 = box.y1 = pptTmp->y;

	while(--nptTmp) 
	{
	   pptTmp++;
	   pwidthTmp++;
	   if(box.x1 > pptTmp->x) box.x1 = pptTmp->x;
	   if(box.x2 < (pptTmp->x + *pwidthTmp))
		box.x2 = pptTmp->x + *pwidthTmp;
	   if(box.y1 > pptTmp->y) box.y1 = pptTmp->y;
	   else if(box.y2 < pptTmp->y) box.y2 = pptTmp->y;
	}

	box.y2++;

        if(!pGC->miTranslate) {
           TRANSLATE_BOX(box, pDrawable);
a758 1
        TRIM_BOX(box, pGC); 
d760 9
a768 2
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
d770 2
a771 2
    (*pGC->ops->SetSpans)(pDrawable, pGC, pcharsrc, ppt, pwidth, npt, fSorted);
    damageRegionProcessPending (pDrawable);
d776 5
a780 10
damagePutImage(DrawablePtr  pDrawable,
	       GCPtr	    pGC,
	       int	    depth,
	       int	    x,
	       int	    y,
	       int	    w,
	       int	    h,
	       int	    leftPad,
	       int	    format,
	       char	    *pImage)
d783 15
a797 16
    if (checkGCDamage (pDrawable, pGC))
    {
	BoxRec box;

	box.x1 = x + pDrawable->x;
	box.x2 = box.x1 + w;
	box.y1 = y + pDrawable->y;
	box.y2 = box.y1 + h;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    (*pGC->ops->PutImage)(pDrawable, pGC, depth, x, y, w, h,
		leftPad, format, pImage);
    damageRegionProcessPending (pDrawable);
d802 4
a805 9
damageCopyArea(DrawablePtr   pSrc,
	       DrawablePtr  pDst,
	       GC	    *pGC,
	       int	    srcx,
	       int	    srcy,
	       int	    width,
	       int	    height,
	       int	    dstx,
	       int	    dsty)
d808 1
d810 17
a826 18
    
    if (checkGCDamage (pDst, pGC))
    {
	BoxRec box;

	box.x1 = dstx + pDst->x;
	box.x2 = box.x1 + width;
	box.y1 = dsty + pDst->y;
	box.y2 = box.y1 + height;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDst, &box, pGC->subWindowMode);
    }

    ret = (*pGC->ops->CopyArea)(pSrc, pDst,
            pGC, srcx, srcy, width, height, dstx, dsty);
    damageRegionProcessPending (pDst);
d832 7
a838 10
damageCopyPlane(DrawablePtr	pSrc,
		DrawablePtr	pDst,
		GCPtr		pGC,
		int		srcx,
		int		srcy,
		int		width,
		int		height,
		int		dstx,
		int		dsty,
		unsigned long	bitPlane)
d841 1
d844 17
a860 17
    if (checkGCDamage (pDst, pGC))
    {
	BoxRec box;

	box.x1 = dstx + pDst->x;
	box.x2 = box.x1 + width;
	box.y1 = dsty + pDst->y;
	box.y2 = box.y1 + height;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDst, &box, pGC->subWindowMode);
    }

    ret = (*pGC->ops->CopyPlane)(pSrc, pDst,
	       pGC, srcx, srcy, width, height, dstx, dsty, bitPlane);
    damageRegionProcessPending (pDst);
d867 1
a867 4
		GCPtr	    pGC,
		int	    mode,
		int	    npt,
		xPoint	    *ppt)
d871 28
a898 26
    if (npt && checkGCDamage (pDrawable, pGC))
    {
	BoxRec	box;
	int	nptTmp = npt;
	xPoint	*pptTmp = ppt;

	box.x2 = box.x1 = pptTmp->x;
	box.y2 = box.y1 = pptTmp->y;

	/* this could be slow if the points were spread out */

	while(--nptTmp) 
	{
	   pptTmp++;
	   if(box.x1 > pptTmp->x) box.x1 = pptTmp->x;
	   else if(box.x2 < pptTmp->x) box.x2 = pptTmp->x;
	   if(box.y1 > pptTmp->y) box.y1 = pptTmp->y;
	   else if(box.y2 < pptTmp->y) box.y2 = pptTmp->y;
	}

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
d900 2
a901 2
    (*pGC->ops->PolyPoint)(pDrawable, pGC, mode, npt, ppt);
    damageRegionProcessPending (pDrawable);
d907 1
a907 4
		GCPtr	    pGC,
		int	    mode,
		int	    npt,
		DDXPointPtr ppt)
d911 61
a971 59
    if (npt && checkGCDamage (pDrawable, pGC))
    {
	int	    nptTmp = npt;
	DDXPointPtr pptTmp = ppt;
	BoxRec	    box;
	int	    extra = pGC->lineWidth >> 1;

	box.x2 = box.x1 = pptTmp->x;
	box.y2 = box.y1 = pptTmp->y;

	if(nptTmp > 1) 
	{
	   if(pGC->joinStyle == JoinMiter)
		extra = 6 * pGC->lineWidth;
	   else if(pGC->capStyle == CapProjecting)
		extra = pGC->lineWidth;
        }

	if(mode == CoordModePrevious) 
	{
	   int x = box.x1;
	   int y = box.y1;
	   while(--nptTmp) 
	   {
		pptTmp++;
		x += pptTmp->x;
		y += pptTmp->y;
		if(box.x1 > x) box.x1 = x;
		else if(box.x2 < x) box.x2 = x;
		if(box.y1 > y) box.y1 = y;
		else if(box.y2 < y) box.y2 = y;
	    }
	}
	else 
	{
	   while(--nptTmp) 
	   {
		pptTmp++;
		if(box.x1 > pptTmp->x) box.x1 = pptTmp->x;
		else if(box.x2 < pptTmp->x) box.x2 = pptTmp->x;
		if(box.y1 > pptTmp->y) box.y1 = pptTmp->y;
		else if(box.y2 < pptTmp->y) box.y2 = pptTmp->y;
	    }
	}

	box.x2++;
	box.y2++;

	if(extra) 
	{
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
d973 2
a974 2
    (*pGC->ops->Polylines)(pDrawable, pGC, mode, npt, ppt);
    damageRegionProcessPending (pDrawable);
d979 1
a979 4
damagePolySegment(DrawablePtr	pDrawable,
		  GCPtr		pGC,
		  int		nSeg,
		  xSegment	*pSeg)
d983 68
a1050 65
    if (nSeg && checkGCDamage (pDrawable, pGC))
    {
	BoxRec	    box;
	int	    extra = pGC->lineWidth;
	int	    nsegTmp = nSeg;
	xSegment    *pSegTmp = pSeg;

        if(pGC->capStyle != CapProjecting)
	   extra >>= 1;

	if(pSegTmp->x2 > pSegTmp->x1) {
	    box.x1 = pSegTmp->x1;
	    box.x2 = pSegTmp->x2;
	} else {
	    box.x2 = pSegTmp->x1;
	    box.x1 = pSegTmp->x2;
	}

	if(pSegTmp->y2 > pSegTmp->y1) {
	    box.y1 = pSegTmp->y1;
	    box.y2 = pSegTmp->y2;
	} else {
	    box.y2 = pSegTmp->y1;
	    box.y1 = pSegTmp->y2;
	}

	while(--nsegTmp) 
	{
	    pSegTmp++;
	    if(pSegTmp->x2 > pSegTmp->x1) 
	    {
		if(pSegTmp->x1 < box.x1) box.x1 = pSegTmp->x1;
		if(pSegTmp->x2 > box.x2) box.x2 = pSegTmp->x2;
	    }
	    else 
	    {
		if(pSegTmp->x2 < box.x1) box.x1 = pSegTmp->x2;
		if(pSegTmp->x1 > box.x2) box.x2 = pSegTmp->x1;
	    }
	    if(pSegTmp->y2 > pSegTmp->y1) 
	    {
		if(pSegTmp->y1 < box.y1) box.y1 = pSegTmp->y1;
		if(pSegTmp->y2 > box.y2) box.y2 = pSegTmp->y2;
	    }
	    else
	    {
		if(pSegTmp->y2 < box.y1) box.y1 = pSegTmp->y2;
		if(pSegTmp->y1 > box.y2) box.y2 = pSegTmp->y1;
	    }
	}

	box.x2++;
	box.y2++;

	if(extra) 
	{
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
d1052 2
a1053 2
    (*pGC->ops->PolySegment)(pDrawable, pGC, nSeg, pSeg);
    damageRegionProcessPending (pDrawable);
d1058 2
a1059 4
damagePolyRectangle(DrawablePtr  pDrawable,
		    GCPtr        pGC,
		    int	         nRects,
		    xRectangle  *pRects)
d1063 44
a1106 45
    if (nRects && checkGCDamage (pDrawable, pGC))
    {
	BoxRec	    box;
	int	    offset1, offset2, offset3;
	int	    nRectsTmp = nRects;
	xRectangle  *pRectsTmp = pRects;

	offset2 = pGC->lineWidth;
	if(!offset2) offset2 = 1;
	offset1 = offset2 >> 1;
	offset3 = offset2 - offset1;

	while(nRectsTmp--)
	{
	    box.x1 = pRectsTmp->x - offset1;
	    box.y1 = pRectsTmp->y - offset1;
	    box.x2 = box.x1 + pRectsTmp->width + offset2;
	    box.y2 = box.y1 + offset2;
	    TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	    if(BOX_NOT_EMPTY(box))
		damageDamageBox (pDrawable, &box, pGC->subWindowMode);

	    box.x1 = pRectsTmp->x - offset1;
	    box.y1 = pRectsTmp->y + offset3;
	    box.x2 = box.x1 + offset2;
	    box.y2 = box.y1 + pRectsTmp->height - offset2;
	    TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	    if(BOX_NOT_EMPTY(box))
		damageDamageBox (pDrawable, &box, pGC->subWindowMode);

	    box.x1 = pRectsTmp->x + pRectsTmp->width - offset1;
	    box.y1 = pRectsTmp->y + offset3;
	    box.x2 = box.x1 + offset2;
	    box.y2 = box.y1 + pRectsTmp->height - offset2;
	    TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	    if(BOX_NOT_EMPTY(box))
		damageDamageBox (pDrawable, &box, pGC->subWindowMode);

	    box.x1 = pRectsTmp->x - offset1;
	    box.y1 = pRectsTmp->y + pRectsTmp->height - offset1;
	    box.x2 = box.x1 + pRectsTmp->width + offset2;
	    box.y2 = box.y1 + offset2;
	    TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	    if(BOX_NOT_EMPTY(box))
		damageDamageBox (pDrawable, &box, pGC->subWindowMode);
d1108 2
a1109 2
	    pRectsTmp++;
	}
d1111 2
a1112 2
    (*pGC->ops->PolyRectangle)(pDrawable, pGC, nRects, pRects);
    damageRegionProcessPending (pDrawable);
d1117 1
a1117 4
damagePolyArc(DrawablePtr   pDrawable,
	      GCPtr	    pGC,
	      int	    nArcs,
	      xArc	    *pArcs)
d1121 36
a1156 39
    if (nArcs && checkGCDamage (pDrawable, pGC))
    {
	int	extra = pGC->lineWidth >> 1;
	BoxRec	box;
	int	nArcsTmp = nArcs;
	xArc	*pArcsTmp = pArcs;

	box.x1 = pArcsTmp->x;
	box.x2 = box.x1 + pArcsTmp->width;
	box.y1 = pArcsTmp->y;
	box.y2 = box.y1 + pArcsTmp->height;

	while(--nArcsTmp) 
	{
	    pArcsTmp++;
	    if(box.x1 > pArcsTmp->x)
		box.x1 = pArcsTmp->x;
	    if(box.x2 < (pArcsTmp->x + pArcsTmp->width))
		box.x2 = pArcsTmp->x + pArcsTmp->width;
	    if(box.y1 > pArcsTmp->y) 
		box.y1 = pArcsTmp->y;
	    if(box.y2 < (pArcsTmp->y + pArcsTmp->height))
		box.y2 = pArcsTmp->y + pArcsTmp->height;
        }

	if(extra) 
	{
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
d1158 2
a1159 2
    (*pGC->ops->PolyArc)(pDrawable, pGC, nArcs, pArcs);
    damageRegionProcessPending (pDrawable);
d1164 2
a1165 6
damageFillPolygon(DrawablePtr	pDrawable,
		  GCPtr		pGC,
		  int		shape,
		  int		mode,
		  int		npt,
		  DDXPointPtr	ppt)
d1169 50
a1218 46
    if (npt > 2 && checkGCDamage (pDrawable, pGC))
    {
	DDXPointPtr pptTmp = ppt;
	int	    nptTmp = npt;
	BoxRec	    box;

	box.x2 = box.x1 = pptTmp->x;
	box.y2 = box.y1 = pptTmp->y;

	if(mode != CoordModeOrigin) 
	{
	   int x = box.x1;
	   int y = box.y1;
	   while(--nptTmp) 
	   {
		pptTmp++;
		x += pptTmp->x;
		y += pptTmp->y;
		if(box.x1 > x) box.x1 = x;
		else if(box.x2 < x) box.x2 = x;
		if(box.y1 > y) box.y1 = y;
		else if(box.y2 < y) box.y2 = y;
	    }
	}
	else 
	{
	   while(--nptTmp) 
	   {
		pptTmp++;
		if(box.x1 > pptTmp->x) box.x1 = pptTmp->x;
		else if(box.x2 < pptTmp->x) box.x2 = pptTmp->x;
		if(box.y1 > pptTmp->y) box.y1 = pptTmp->y;
		else if(box.y2 < pptTmp->y) box.y2 = pptTmp->y;
	    }
	}

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
    }
    
    (*pGC->ops->FillPolygon)(pDrawable, pGC, shape, mode, npt, ppt);
    damageRegionProcessPending (pDrawable);
a1221 1

d1223 2
a1224 4
damagePolyFillRect(DrawablePtr	pDrawable,
		   GCPtr	pGC,
		   int		nRects,
		   xRectangle	*pRects)
d1227 25
a1251 25
    if (nRects && checkGCDamage (pDrawable, pGC))
    {
	BoxRec	    box;
	xRectangle  *pRectsTmp = pRects;
	int	    nRectsTmp = nRects;

	box.x1 = pRectsTmp->x;
	box.x2 = box.x1 + pRectsTmp->width;
	box.y1 = pRectsTmp->y;
	box.y2 = box.y1 + pRectsTmp->height;

	while(--nRectsTmp) 
	{
	    pRectsTmp++;
	    if(box.x1 > pRectsTmp->x) box.x1 = pRectsTmp->x;
	    if(box.x2 < (pRectsTmp->x + pRectsTmp->width))
		box.x2 = pRectsTmp->x + pRectsTmp->width;
	    if(box.y1 > pRectsTmp->y) box.y1 = pRectsTmp->y;
	    if(box.y2 < (pRectsTmp->y + pRectsTmp->height))
		box.y2 = pRectsTmp->y + pRectsTmp->height;
	}

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	    damageDamageBox (pDrawable, &box, pGC->subWindowMode);
d1253 2
a1254 2
    (*pGC->ops->PolyFillRect)(pDrawable, pGC, nRects, pRects);
    damageRegionProcessPending (pDrawable);
a1257 1

d1259 1
a1259 4
damagePolyFillArc(DrawablePtr	pDrawable,
		  GCPtr		pGC,
		  int		nArcs,
		  xArc		*pArcs)
d1263 25
a1287 27
    if (nArcs && checkGCDamage (pDrawable, pGC))
    {
	BoxRec	box;
	int	nArcsTmp = nArcs;
	xArc	*pArcsTmp = pArcs;

	box.x1 = pArcsTmp->x;
	box.x2 = box.x1 + pArcsTmp->width;
	box.y1 = pArcsTmp->y;
	box.y2 = box.y1 + pArcsTmp->height;

	while(--nArcsTmp) 
	{
	    pArcsTmp++;
	    if(box.x1 > pArcsTmp->x)
		box.x1 = pArcsTmp->x;
	    if(box.x2 < (pArcsTmp->x + pArcsTmp->width))
		box.x2 = pArcsTmp->x + pArcsTmp->width;
	    if(box.y1 > pArcsTmp->y)
		box.y1 = pArcsTmp->y;
	    if(box.y2 < (pArcsTmp->y + pArcsTmp->height))
		box.y2 = pArcsTmp->y + pArcsTmp->height;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDrawable, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
d1289 2
a1290 2
    (*pGC->ops->PolyFillArc)(pDrawable, pGC, nArcs, pArcs);
    damageRegionProcessPending (pDrawable);
d1300 6
a1305 8
damageDamageChars (DrawablePtr	pDrawable,
		   FontPtr	font,
		   int		x,
		   int		y,
		   unsigned int	n,
		   CharInfoPtr	*charinfo,
		   Bool		imageblt,
		   int		subWindowMode)
d1307 2
a1308 2
    ExtentInfoRec   extents;
    BoxRec	    box;
d1311 11
a1321 12
    if (imageblt)
    {
	if (extents.overallWidth > extents.overallRight)
	    extents.overallRight = extents.overallWidth;
	if (extents.overallWidth < extents.overallLeft)
	    extents.overallLeft = extents.overallWidth;
	if (extents.overallLeft > 0)
	    extents.overallLeft = 0;
	if (extents.fontAscent > extents.overallAscent)
	    extents.overallAscent = extents.fontAscent;
	if (extents.fontDescent > extents.overallDescent)
	    extents.overallDescent = extents.fontDescent;
d1327 1
a1327 1
    damageDamageBox (pDrawable, &box, subWindowMode);
d1338 14
a1351 16
static int 
damageText (DrawablePtr	    pDrawable,
	    GCPtr	    pGC,
	    int		    x,
	    int		    y,
	    unsigned long   count,
	    char	    *chars,
	    FontEncoding    fontEncoding,
	    Bool	    textType)
{
    CharInfoPtr	    *charinfo;
    CharInfoPtr	    *info;
    unsigned long   i;
    unsigned int    n;
    int		    w;
    Bool	    imageblt;
d1357 1
a1357 1
	return x;
d1359 3
a1361 3
    GetGlyphs(pGC->font, count, (unsigned char *)chars,
	      fontEncoding, &i, charinfo);
    n = (unsigned int)i;
d1364 2
a1365 2
	for (info = charinfo; i--; info++)
	    w += (*info)->metrics.characterWidth;
d1368 9
a1376 8
	damageDamageChars (pDrawable, pGC->font, x + pDrawable->x, y + pDrawable->y, n,
			   charinfo, imageblt, pGC->subWindowMode);
	if (imageblt)
	    (*pGC->ops->ImageGlyphBlt)(pDrawable, pGC, x, y, n, charinfo,
				       FONTGLYPHS(pGC->font));
	else
	    (*pGC->ops->PolyGlyphBlt)(pDrawable, pGC, x, y, n, charinfo,
				      FONTGLYPHS(pGC->font));
d1384 1
a1384 5
		GCPtr	    pGC,
		int	    x,
		int	    y,
		int	    count,
		char	    *chars)
d1388 3
a1390 3
    if (checkGCDamage (pDrawable, pGC))
	x = damageText (pDrawable, pGC, x, y, (unsigned long) count, chars,
		    Linear8Bit, TT_POLY8);
d1392 2
a1393 2
	x = (*pGC->ops->PolyText8)(pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending (pDrawable);
d1399 2
a1400 6
damagePolyText16(DrawablePtr	pDrawable,
		 GCPtr		pGC,
		 int		x,
		 int		y,
		 int		count,
		 unsigned short	*chars)
d1404 5
a1408 4
    if (checkGCDamage (pDrawable, pGC))
	x = damageText (pDrawable, pGC, x, y, (unsigned long) count, (char *) chars,
		    FONTLASTROW(pGC->font) == 0 ? Linear16Bit : TwoD16Bit,
		    TT_POLY16);
d1410 2
a1411 2
	x = (*pGC->ops->PolyText16)(pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending (pDrawable);
d1417 2
a1418 6
damageImageText8(DrawablePtr	pDrawable,
		 GCPtr		pGC,
		 int		x,
		 int		y,
		 int		count,
		 char		*chars)
d1422 3
a1424 3
    if (checkGCDamage (pDrawable, pGC))
	damageText (pDrawable, pGC, x, y, (unsigned long) count, chars,
		    Linear8Bit, TT_IMAGE8);
d1426 2
a1427 2
	(*pGC->ops->ImageText8)(pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending (pDrawable);
d1432 2
a1433 6
damageImageText16(DrawablePtr	pDrawable,
		  GCPtr		pGC,
		  int		x,
		  int		y,
		  int		count,
		  unsigned short *chars)
d1437 4
a1440 4
    if (checkGCDamage (pDrawable, pGC))
	damageText (pDrawable, pGC, x, y, (unsigned long) count, (char *) chars,
		    FONTLASTROW(pGC->font) == 0 ? Linear16Bit : TwoD16Bit,
		    TT_IMAGE16);
d1442 2
a1443 2
	(*pGC->ops->ImageText16)(pDrawable, pGC, x, y, count, chars);
    damageRegionProcessPending (pDrawable);
a1446 1

d1448 5
a1452 7
damageImageGlyphBlt(DrawablePtr	    pDrawable,
		    GCPtr	    pGC,
		    int		    x,
		    int		    y,
		    unsigned int    nglyph,
		    CharInfoPtr	    *ppci,
		    pointer	    pglyphBase)
d1455 4
a1458 5
    damageDamageChars (pDrawable, pGC->font, x + pDrawable->x, y + pDrawable->y,
		       nglyph, ppci, TRUE, pGC->subWindowMode);
    (*pGC->ops->ImageGlyphBlt)(pDrawable, pGC, x, y, nglyph,
					ppci, pglyphBase);
    damageRegionProcessPending (pDrawable);
d1463 5
a1467 7
damagePolyGlyphBlt(DrawablePtr	pDrawable,
		   GCPtr	pGC,
		   int		x,
		   int		y,
		   unsigned int	nglyph,
		   CharInfoPtr	*ppci,
		   pointer	pglyphBase)
d1470 4
a1473 5
    damageDamageChars (pDrawable, pGC->font, x + pDrawable->x, y + pDrawable->y,
		       nglyph, ppci, FALSE, pGC->subWindowMode);
    (*pGC->ops->PolyGlyphBlt)(pDrawable, pGC, x, y, nglyph,
				ppci, pglyphBase);
    damageRegionProcessPending (pDrawable);
d1478 3
a1480 7
damagePushPixels(GCPtr		pGC,
		 PixmapPtr	pBitMap,
		 DrawablePtr	pDrawable,
		 int		dx,
		 int		dy,
		 int		xOrg,
		 int		yOrg)
d1483 2
a1484 3
    if(checkGCDamage (pDrawable, pGC))
    {
	BoxRec box;
d1489 3
a1491 3
        if(!pGC->miTranslate) {
           box.x1 += pDrawable->x;          
           box.y1 += pDrawable->y;          
d1494 2
a1495 2
	box.x2 = box.x1 + dx;
	box.y2 = box.y1 + dy;
d1497 3
a1499 3
	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   damageDamageBox (pDrawable, &box, pGC->subWindowMode);
d1501 2
a1502 2
    (*pGC->ops->PushPixels)(pGC, pBitMap, pDrawable, dx, dy, xOrg, yOrg);
    damageRegionProcessPending (pDrawable);
d1507 1
a1507 1
damageRemoveDamage (DamagePtr *pPrev, DamagePtr pDamage)
d1509 6
a1514 8
    while (*pPrev)
    {
	if (*pPrev == pDamage)
	{
	    *pPrev = pDamage->pNext;
	    return;
	}
	pPrev = &(*pPrev)->pNext;
d1517 2
a1518 2
    ErrorF ("Damage not on list\n");
    OsAbort ();
d1523 1
a1523 1
damageInsertDamage (DamagePtr *pPrev, DamagePtr pDamage)
d1526 1
a1526 1
    DamagePtr	pOld;
d1529 4
a1532 4
	if (pOld == pDamage) {
	    ErrorF ("Damage already on list\n");
	    OsAbort ();
	}
d1539 1
a1539 1
damageDestroyPixmap (PixmapPtr pPixmap)
d1541 2
a1542 1
    ScreenPtr	pScreen = pPixmap->drawable.pScreen;
d1545 9
a1553 11
    if (pPixmap->refcnt == 1)
    {
	DamagePtr	*pPrev = getPixmapDamageRef (pPixmap);
	DamagePtr	pDamage;

	while ((pDamage = *pPrev))
	{
	    damageRemoveDamage (pPrev, pDamage);
	    if (!pDamage->isWindow)
		DamageDestroy (pDamage);
	}
d1555 1
a1555 1
    unwrap (pScrPriv, pScreen, DestroyPixmap);
d1557 1
a1557 1
    wrap (pScrPriv, pScreen, DestroyPixmap, damageDestroyPixmap);
d1562 1
a1562 3
damageCopyWindow(WindowPtr	pWindow,
		 DDXPointRec	ptOldOrg,
		 RegionPtr	prgnSrc)
d1565 1
d1568 11
a1578 12
    if (getWindowDamage (pWindow))
    {
	int dx = pWindow->drawable.x - ptOldOrg.x;
	int dy = pWindow->drawable.y - ptOldOrg.y;
	
	/*
	 * The region comes in source relative, but the damage occurs
	 * at the destination location.  Translate back and forth.
	 */
	RegionTranslate(prgnSrc, dx, dy);
	damageRegionAppend (&pWindow->drawable, prgnSrc, FALSE, -1);
	RegionTranslate(prgnSrc, -dx, -dy);
d1580 1
a1580 1
    unwrap (pScrPriv, pScreen, CopyWindow);
d1582 2
a1583 2
    damageRegionProcessPending (&pWindow->drawable);
    wrap (pScrPriv, pScreen, CopyWindow, damageCopyWindow);
d1600 1
a1600 1
damageSetWindowPixmap (WindowPtr pWindow, PixmapPtr pPixmap)
d1602 3
a1604 2
    DamagePtr	pDamage;
    ScreenPtr	pScreen = pWindow->drawable.pScreen;
d1607 8
a1614 10
    if ((pDamage = damageGetWinPriv(pWindow)))
    {
	PixmapPtr   pOldPixmap = (*pScreen->GetWindowPixmap) (pWindow);
	DamagePtr   *pPrev = getPixmapDamageRef(pOldPixmap);
	
	while (pDamage)
	{
	    damageRemoveDamage (pPrev, pDamage);
	    pDamage = pDamage->pNextWin;
	}
d1616 1
a1616 1
    unwrap (pScrPriv, pScreen, SetWindowPixmap);
d1618 8
a1625 10
    wrap (pScrPriv, pScreen, SetWindowPixmap, damageSetWindowPixmap);
    if ((pDamage = damageGetWinPriv(pWindow)))
    {
	DamagePtr   *pPrev = getPixmapDamageRef(pPixmap);
	
	while (pDamage)
	{
	    damageInsertDamage (pPrev, pDamage);
	    pDamage = pDamage->pNextWin;
	}
d1630 1
a1630 1
damageDestroyWindow (WindowPtr pWindow)
d1632 4
a1635 3
    DamagePtr	pDamage;
    ScreenPtr	pScreen = pWindow->drawable.pScreen;
    Bool	ret;
d1638 3
a1640 4
    while ((pDamage = damageGetWinPriv(pWindow)))
    {
	DamageUnregister (&pWindow->drawable, pDamage);
	DamageDestroy (pDamage);
d1642 1
a1642 1
    unwrap (pScrPriv, pScreen, DestroyWindow);
d1644 1
a1644 1
    wrap (pScrPriv, pScreen, DestroyWindow, damageDestroyWindow);
d1649 1
a1649 1
damageCloseScreen (int i, ScreenPtr pScreen)
d1653 4
a1656 4
    unwrap (pScrPriv, pScreen, DestroyPixmap);
    unwrap (pScrPriv, pScreen, CreateGC);
    unwrap (pScrPriv, pScreen, CopyWindow);
    unwrap (pScrPriv, pScreen, CloseScreen);
d1664 2
a1665 1
void miDamageCreate (DamagePtr pDamage)
d1669 2
a1670 1
void miDamageRegister (DrawablePtr pDrawable, DamagePtr pDamage)
d1674 2
a1675 1
void miDamageUnregister (DrawablePtr pDrawable, DamagePtr pDamage)
d1679 2
a1680 1
void miDamageDestroy (DamagePtr pDamage)
d1689 1
a1689 1
DamageSetup (ScreenPtr pScreen)
d1691 3
a1693 2
    DamageScrPrivPtr	pScrPriv;
    PictureScreenPtr	ps = GetPictureScreenIfSet(pScreen);
d1695 1
a1695 1
	miDamageCreate, miDamageRegister, miDamageUnregister, miDamageDestroy
d1699 1
a1699 1
	return FALSE;
d1702 1
a1702 1
	return TRUE;
d1704 3
a1706 2
    if (!dixRegisterPrivateKey(&damageGCPrivateKeyRec, PRIVATE_GC, sizeof(DamageGCPrivRec)))
	return FALSE;
d1709 1
a1709 1
	return FALSE;
d1712 1
a1712 1
	return FALSE;
d1714 1
a1714 1
    pScrPriv = malloc(sizeof (DamageScrPrivRec));
d1716 1
a1716 1
	return FALSE;
d1721 6
a1726 6
    wrap (pScrPriv, pScreen, DestroyPixmap, damageDestroyPixmap);
    wrap (pScrPriv, pScreen, CreateGC, damageCreateGC);
    wrap (pScrPriv, pScreen, DestroyWindow, damageDestroyWindow);
    wrap (pScrPriv, pScreen, SetWindowPixmap, damageSetWindowPixmap);
    wrap (pScrPriv, pScreen, CopyWindow, damageCopyWindow);
    wrap (pScrPriv, pScreen, CloseScreen, damageCloseScreen);
d1728 3
a1730 3
	wrap (pScrPriv, ps, Glyphs, damageGlyphs);
	wrap (pScrPriv, ps, Composite, damageComposite);
	wrap (pScrPriv, ps, AddTraps, damageAddTraps);
d1740 4
a1743 6
DamageCreate (DamageReportFunc  damageReport,
	      DamageDestroyFunc	damageDestroy,
	      DamageReportLevel	damageLevel,
	      Bool		isInternal,
	      ScreenPtr		pScreen,
	      void		*closure)
d1746 1
a1746 1
    DamagePtr	pDamage;
d1750 1
a1750 1
	return 0;
d1755 1
a1755 1
    
d1775 1
a1775 2
DamageRegister (DrawablePtr pDrawable,
		DamagePtr   pDamage)
d1778 1
d1782 3
a1784 4
    if (pDrawable->pScreen != pDamage->pScreen)
    {
	ErrorF ("DamageRegister called with mismatched screens\n");
	OsAbort ();
d1788 4
a1791 4
    if (pDrawable->type == DRAWABLE_WINDOW)
    {
	WindowPtr   pWindow = (WindowPtr) pDrawable;
	winDamageRef(pWindow);
d1794 7
a1800 7
	DamagePtr   pOld;
	
	for (pOld = *pPrev; pOld; pOld = pOld->pNextWin)
	    if (pOld == pDamage) {
		ErrorF ("Damage already on window list\n");
		OsAbort ();
	    }
d1802 3
a1804 3
	pDamage->pNextWin = *pPrev;
	*pPrev = pDamage;
	pDamage->isWindow = TRUE;
d1807 1
a1807 1
	pDamage->isWindow = FALSE;
d1809 1
a1809 1
    damageInsertDamage (getDrawableDamageRef (pDrawable), pDamage);
d1814 1
a1814 1
DamageDrawInternal (ScreenPtr pScreen, Bool enable)
d1816 1
a1816 1
    damageScrPriv (pScreen);
d1822 1
a1822 2
DamageUnregister (DrawablePtr	    pDrawable,
		  DamagePtr	    pDamage)
d1825 1
d1830 4
a1833 4
    if (pDrawable->type == DRAWABLE_WINDOW)
    {
	WindowPtr   pWindow = (WindowPtr) pDrawable;
	winDamageRef (pWindow);
d1835 1
a1835 1
	int	found = 0;
d1838 3
a1840 5
	while (*pPrev)
	{
	    if (*pPrev == pDamage)
	    {
		*pPrev = pDamage->pNextWin;
d1842 1
a1842 1
		found = 1;
d1844 4
a1847 4
		break;
	    }
	    pPrev = &(*pPrev)->pNextWin;
	}
d1849 4
a1852 4
	if (!found) {
	    ErrorF ("Damage not on window list\n");
	    OsAbort ();
	}
d1856 1
a1856 1
    damageRemoveDamage (getDrawableDamageRef (pDrawable), pDamage);
d1860 1
a1860 1
DamageDestroy (DamagePtr    pDamage)
d1863 1
d1867 1
a1867 1
	(*pDamage->damageDestroy) (pDamage, pDamage->closure);
d1875 1
a1875 2
DamageSubtract (DamagePtr	    pDamage,
		const RegionPtr	    pRegion)
d1877 4
a1880 4
    RegionPtr	pClip;
    RegionRec	pixmapClip;
    DrawablePtr	pDrawable = pDamage->pDrawable;
    
d1882 18
a1899 20
    if (pDrawable)
    {
	if (pDrawable->type == DRAWABLE_WINDOW)
	    pClip = &((WindowPtr) pDrawable)->borderClip;
	else
	{
	    BoxRec  box;

	    box.x1 = pDrawable->x;
	    box.y1 = pDrawable->y;
	    box.x2 = pDrawable->x + pDrawable->width;
	    box.y2 = pDrawable->y + pDrawable->height;
	    RegionInit(&pixmapClip, &box, 1);
	    pClip = &pixmapClip;
	}
	RegionTranslate(&pDamage->damage, pDrawable->x, pDrawable->y);
	RegionIntersect(&pDamage->damage, &pDamage->damage, pClip);
	RegionTranslate(&pDamage->damage, -pDrawable->x, -pDrawable->y);
	if (pDrawable->type != DRAWABLE_WINDOW)
	    RegionUninit(&pixmapClip);
d1905 1
a1905 1
DamageEmpty (DamagePtr	    pDamage)
d1911 1
a1911 1
DamageRegion (DamagePtr		    pDamage)
d1917 1
a1917 1
DamagePendingRegion (DamagePtr	    pDamage)
d1923 1
a1923 1
DamageRegionAppend (DrawablePtr pDrawable, RegionPtr pRegion)
d1925 1
a1925 1
    damageRegionAppend (pDrawable, pRegion, FALSE, -1);
d1929 1
a1929 1
DamageRegionProcessPending (DrawablePtr pDrawable)
d1931 1
a1931 1
    damageRegionProcessPending (pDrawable);
d1938 2
a1939 1
DamageRegionRendered (DrawablePtr pDrawable, DamagePtr pDamage, RegionPtr pOldDamage, RegionPtr pRegion)
d1942 1
a1942 1
	damageReportDamagePostRendering (pDamage, pOldDamage, pRegion);
d1947 1
a1947 2
DamageDamageRegion (DrawablePtr	pDrawable,
		    RegionPtr	pRegion)
d1949 1
a1949 1
    damageRegionAppend (pDrawable, pRegion, FALSE, -1);
d1955 1
a1955 1
    damageRegionProcessPending (pDrawable);
d1959 1
a1959 1
DamageSetReportAfterOp (DamagePtr pDamage, Bool reportAfter)
d1965 3
a1967 2
DamageSetPostRenderingFunctions(DamagePtr pDamage, DamageReportFunc damageReportPostRendering,
				DamageMarkerFunc damageMarker)
d1974 1
a1974 1
DamageGetScreenFuncs (ScreenPtr pScreen)
d1981 1
a1981 1
DamageReportDamage (DamagePtr pDamage, RegionPtr pDamageRegion)
d1989 3
a1991 4
	RegionUnion(&pDamage->damage, &pDamage->damage,
			 pDamageRegion);
	(*pDamage->damageReport) (pDamage, pDamageRegion, pDamage->closure);
	break;
d1993 8
a2000 9
	RegionNull(&tmpRegion);
	RegionSubtract(&tmpRegion, pDamageRegion, &pDamage->damage);
	if (RegionNotEmpty(&tmpRegion)) {
	    RegionUnion(&pDamage->damage, &pDamage->damage,
			 pDamageRegion);
	    (*pDamage->damageReport) (pDamage, &tmpRegion, pDamage->closure);
	}
	RegionUninit(&tmpRegion);
	break;
d2002 7
a2008 8
	tmpBox = *RegionExtents(&pDamage->damage);
	RegionUnion(&pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	if (!BOX_SAME (&tmpBox, RegionExtents(&pDamage->damage))) {
	    (*pDamage->damageReport) (pDamage, &pDamage->damage,
				      pDamage->closure);
	}
	break;
d2010 7
a2016 8
	was_empty = !RegionNotEmpty(&pDamage->damage);
	RegionUnion(&pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	if (was_empty && RegionNotEmpty(&pDamage->damage)) {
	    (*pDamage->damageReport) (pDamage, &pDamage->damage,
				      pDamage->closure);
	}
	break;
d2018 2
a2019 3
	RegionUnion(&pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	break;
a2021 1

@


1.5
log
@Upgrade to xorg-server 1.9.2.
Tested by ajacoutot@@, krw@@, shadchin@@ and jasper@@ on various configurations
including multihead with both zaphod and xrandr.
@
text
@a123 48
damageReportDamage (DamagePtr pDamage, RegionPtr pDamageRegion)
{
    BoxRec tmpBox;
    RegionRec tmpRegion;
    Bool was_empty;

    switch (pDamage->damageLevel) {
    case DamageReportRawRegion:
	RegionUnion(&pDamage->damage, &pDamage->damage,
			 pDamageRegion);
	(*pDamage->damageReport) (pDamage, pDamageRegion, pDamage->closure);
	break;
    case DamageReportDeltaRegion:
	RegionNull(&tmpRegion);
	RegionSubtract(&tmpRegion, pDamageRegion, &pDamage->damage);
	if (RegionNotEmpty(&tmpRegion)) {
	    RegionUnion(&pDamage->damage, &pDamage->damage,
			 pDamageRegion);
	    (*pDamage->damageReport) (pDamage, &tmpRegion, pDamage->closure);
	}
	RegionUninit(&tmpRegion);
	break;
    case DamageReportBoundingBox:
	tmpBox = *RegionExtents(&pDamage->damage);
	RegionUnion(&pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	if (!BOX_SAME (&tmpBox, RegionExtents(&pDamage->damage))) {
	    (*pDamage->damageReport) (pDamage, &pDamage->damage,
				      pDamage->closure);
	}
	break;
    case DamageReportNonEmpty:
	was_empty = !RegionNotEmpty(&pDamage->damage);
	RegionUnion(&pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	if (was_empty && RegionNotEmpty(&pDamage->damage)) {
	    (*pDamage->damageReport) (pDamage, &pDamage->damage,
				      pDamage->closure);
	}
	break;
    case DamageReportNone:
	RegionUnion(&pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	break;
    }
}

static void
d315 1
a315 1
		damageReportDamage (pDamage, pDamageRegion);
d348 1
a348 1
		damageReportDamage (pDamage, &pDamage->pendingDamage);
a404 1
    pGC->pCompositeClip = 0;
a415 22
#ifdef NOTUSED
static void
damageWrapGC (GCPtr pGC)
{
    damageGCPriv(pGC);

    pGCPriv->ops = NULL;
    pGCPriv->funcs = pGC->funcs;
    pGC->funcs = &damageGCFuncs;
}

static void
damageUnwrapGC (GCPtr pGC)
{
    damageGCPriv(pGC);

    pGC->funcs = pGCPriv->funcs;
    if (pGCPriv->ops)
	pGC->ops = pGCPriv->ops;
}
#endif

a849 10
    /* The driver will only call SourceValidate() when pSrc != pDst,
     * but the software sprite (misprite.c) always need to know when a
     * drawable is copied so it can remove the sprite. See #1030. */
    if ((pSrc == pDst) && pSrc->pScreen->SourceValidate &&
	pSrc->type == DRAWABLE_WINDOW &&
	((WindowPtr)pSrc)->viewable)
    {
	(*pSrc->pScreen->SourceValidate) (pSrc, srcx, srcy, width, height);
    }
    
a885 10
    /* The driver will only call SourceValidate() when pSrc != pDst,
     * but the software sprite (misprite.c) always need to know when a
     * drawable is copied so it can remove the sprite. See #1030. */
    if ((pSrc == pDst) && pSrc->pScreen->SourceValidate &&
	pSrc->type == DRAWABLE_WINDOW &&
	((WindowPtr)pSrc)->viewable)
    {
        (*pSrc->pScreen->SourceValidate) (pSrc, srcx, srcy, width, height);
    }

a1694 1
    {NULL}		/* devPrivate */
d2080 49
@


1.4
log
@Update to xserver 1.8. Tested by many. Ok oga@@, todd@@.
@
text
@d73 8
a80 8
static int damageScrPrivateKeyIndex;
static DevPrivateKey damageScrPrivateKey = &damageScrPrivateKeyIndex;
static int damagePixPrivateKeyIndex;
static DevPrivateKey damagePixPrivateKey = &damagePixPrivateKeyIndex;
static int damageGCPrivateKeyIndex;
static DevPrivateKey damageGCPrivateKey = &damageGCPrivateKeyIndex;
static int damageWinPrivateKeyIndex;
static DevPrivateKey damageWinPrivateKey = &damageWinPrivateKeyIndex;
d87 1
a87 1
    if (pDrawable->type == DRAWABLE_WINDOW)
d132 1
a132 1
	REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
d137 4
a140 4
	REGION_NULL (pScreen, &tmpRegion);
	REGION_SUBTRACT (pScreen, &tmpRegion, pDamageRegion, &pDamage->damage);
	if (REGION_NOTEMPTY (pScreen, &tmpRegion)) {
	    REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
d144 1
a144 1
	REGION_UNINIT(pScreen, &tmpRegion);
d147 2
a148 2
	tmpBox = *REGION_EXTENTS (pScreen, &pDamage->damage);
	REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
d150 1
a150 1
	if (!BOX_SAME (&tmpBox, REGION_EXTENTS (pScreen, &pDamage->damage))) {
d156 2
a157 2
	was_empty = !REGION_NOTEMPTY(pScreen, &pDamage->damage);
	REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
d159 1
a159 1
	if (was_empty && REGION_NOTEMPTY(pScreen, &pDamage->damage)) {
d165 1
a165 1
	REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
d178 1
a178 1
    REGION_UNION(pScreem, &newDamage, pOldDamage, pDamageRegion);
d185 3
a187 3
	REGION_NULL (pScreen, &tmpRegion);
	REGION_SUBTRACT (pScreen, &tmpRegion, pDamageRegion, pOldDamage);
	if (REGION_NOTEMPTY (pScreen, &tmpRegion)) {
d190 1
a190 1
	REGION_UNINIT(pScreen, &tmpRegion);
d193 2
a194 2
	tmpBox = *REGION_EXTENTS (pScreen, pOldDamage);
	if (!BOX_SAME (&tmpBox, REGION_EXTENTS (pScreen, &newDamage))) {
d200 2
a201 2
	was_empty = !REGION_NOTEMPTY(pScreen, pOldDamage);
	if (was_empty && REGION_NOTEMPTY(pScreen, &newDamage)) {
d210 1
a210 1
    REGION_UNINIT(pScreen, &newDamage);
d236 1
a236 1
    if (!REGION_NOTEMPTY(pScreen, pRegion))
d251 1
a251 1
        REGION_TRANSLATE (pScreen, pRegion, screen_x, screen_y);
d259 1
a259 1
	    REGION_INTERSECT(pScreen, pRegion, pRegion,
d266 2
a267 2
	    REGION_INTERSECT(pScreen, pRegion, pRegion, pTempRegion);
	    REGION_DESTROY(pScreen, pTempRegion);
d274 1
a274 1
    REGION_NULL (pScreen, &clippedRec);
d303 1
a303 1
	if (pDamage->pDrawable->type != DRAWABLE_WINDOW)
d319 1
a319 1
		REGION_INTERSECT (pScreen, pDamageRegion, pRegion,
d327 3
a329 3
		REGION_INIT(pScreen, &pixClip, &box, 1);
		REGION_INTERSECT (pScreen, pDamageRegion, pRegion, &pixClip);
		REGION_UNINIT(pScreen, &pixClip);
d334 1
a334 1
	    if (!REGION_NOTEMPTY(pScreen, pDamageRegion))
d349 1
a349 1
	    REGION_TRANSLATE (pScreen, pDamageRegion, -draw_x, -draw_y);
d353 1
a353 1
	    REGION_UNION(pScreen, &pDamage->pendingDamage,
d358 1
a358 1
	    REGION_COPY(pScreen, &pDamage->backupDamage, &pDamage->damage);
d365 1
a365 1
		REGION_UNION(pScreen, &pDamage->damage,
d373 1
a373 1
	    REGION_TRANSLATE (pScreen, pDamageRegion, draw_x, draw_y);
d377 1
a377 1
	REGION_TRANSLATE (pScreen, pRegion, -screen_x, -screen_y);
d380 1
a380 1
    REGION_UNINIT (pScreen, &clippedRec);
d398 1
a398 1
		REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
d403 1
a403 1
	    REGION_EMPTY (pScreen, &pDamage->pendingDamage);
d405 1
a405 1
	    REGION_EMPTY (pScreen, &pDamage->backupDamage);
d421 1
a421 1
    REGION_INIT (pDrawable->pScreen, &region, pBox, 1);
d427 1
a427 1
    REGION_UNINIT (pDrawable->pScreen, &region);
d596 1
a596 4
				  REGION_NOTEMPTY(d->pScreen, \
						  g->pCompositeClip)))

#ifdef RENDER
d607 1
a607 1
				 REGION_NOTEMPTY(pScreen, p->pCompositeClip))
a773 1
#endif
d1513 1
a1513 1
    charinfo = xalloc(count * sizeof(CharInfoPtr));
d1535 1
a1535 1
    xfree(charinfo);
d1765 1
a1765 1
	REGION_TRANSLATE (pScreen, prgnSrc, dx, dy);
d1767 1
a1767 1
	REGION_TRANSLATE (pScreen, prgnSrc, -dx, -dy);
d1850 1
a1850 1
    xfree (pScrPriv);
a1880 1
#ifdef RENDER
a1881 1
#endif
d1886 3
d1892 1
a1892 1
    if (!dixRequestPrivate(damageGCPrivateKey, sizeof(DamageGCPrivRec)))
d1895 7
a1901 1
    pScrPriv = xalloc (sizeof (DamageScrPrivRec));
a1913 1
#ifdef RENDER
a1918 1
#endif
d1937 1
a1937 1
    pDamage = xalloc (sizeof (DamageRec));
d1942 2
a1943 2
    REGION_NULL(pScreen, &pDamage->damage);
    REGION_NULL(pScreen, &pDamage->pendingDamage);
a1956 1
    pDamage->devPrivates = NULL;
d2060 3
a2062 5
    dixFreePrivates(pDamage->devPrivates);
    pDamage->devPrivates = NULL;
    REGION_UNINIT (pScreen, &pDamage->damage);
    REGION_UNINIT (pScreen, &pDamage->pendingDamage);
    xfree (pDamage);
d2073 1
a2073 1
    REGION_SUBTRACT (pDrawable->pScreen, &pDamage->damage, &pDamage->damage, pRegion);
d2086 1
a2086 1
	    REGION_INIT (pDrawable->pScreen, &pixmapClip, &box, 1);
d2089 3
a2091 3
	REGION_TRANSLATE (pDrawable->pScreen, &pDamage->damage, pDrawable->x, pDrawable->y);
	REGION_INTERSECT (pDrawable->pScreen, &pDamage->damage, &pDamage->damage, pClip);
	REGION_TRANSLATE (pDrawable->pScreen, &pDamage->damage, -pDrawable->x, -pDrawable->y);
d2093 1
a2093 1
	    REGION_UNINIT(pDrawable->pScreen, &pixmapClip);
d2095 1
a2095 1
    return REGION_NOTEMPTY (pDrawable->pScreen, &pDamage->damage);
d2101 1
a2101 1
    REGION_EMPTY (pDamage->pDrawable->pScreen, &pDamage->damage);
@


1.3
log
@update to xserver 1.6.4rc1. Tested by many, ok oga@@.
@
text
@d1517 1
a1517 1
    charinfo = (CharInfoPtr *) xalloc(count * sizeof(CharInfoPtr));
d1708 1
a1708 1
    abort ();
d1721 1
a1721 1
	    abort ();
d1859 19
d1888 3
d1898 1
a1898 1
    pScrPriv = (DamageScrPrivPtr) xalloc (sizeof (DamageScrPrivRec));
d1919 2
d1933 1
d1955 5
d1967 11
d1989 1
a1989 1
		abort ();
d2000 1
d2015 5
d2043 1
a2043 1
	    abort ();
d2054 3
d2059 5
a2063 2
    REGION_UNINIT (pDamage->pDrawable->pScreen, &pDamage->damage);
    REGION_UNINIT (pDamage->pDrawable->pScreen, &pDamage->pendingDamage);
d2106 1
a2106 1
_X_EXPORT RegionPtr
d2112 1
a2112 1
_X_EXPORT RegionPtr
d2118 1
a2118 1
_X_EXPORT void
d2124 1
a2124 1
_X_EXPORT void
d2133 1
a2133 1
_X_EXPORT void
d2141 1
a2141 1
_X_EXPORT void
d2154 1
a2154 1
_X_EXPORT void
d2160 1
a2160 1
_X_EXPORT void
d2166 7
@


1.2
log
@xserver 1.5.2. tested by ckuethe@@, oga@@, and others.
@
text
@d73 8
a80 4
static DevPrivateKey damageScrPrivateKey = &damageScrPrivateKey;
static DevPrivateKey damagePixPrivateKey = &damagePixPrivateKey;
static DevPrivateKey damageGCPrivateKey = &damageGCPrivateKey;
static DevPrivateKey damageWinPrivateKey = &damageWinPrivateKey;
d124 1
a124 1
DamageReportDamage (DamagePtr pDamage, RegionPtr pDamageRegion)
d132 2
d171 42
d215 2
a216 2
_damageDamageRegion (DrawablePtr pDrawable, RegionPtr pRegion, Bool clip, int subWindowMode, const char *where)
#define damageDamageRegion(d,r,c,m) _damageDamageRegion(d,r,c,m,__FUNCTION__)
d219 1
a219 1
damageDamageRegion (DrawablePtr pDrawable, RegionPtr pRegion, Bool clip,
d351 2
a352 7
	/* If the damage rec has been flagged to report damage after the op has
	 * completed, then union it into the delayed damage region, which will
	 * be used for reporting after calling down, and skip the reporting 
	 */
	if (!pDamage->reportAfter) {
	    DamageReportDamage (pDamage, pDamageRegion);
	} else {
d355 12
d384 1
a384 1
damageReportPostOp (DrawablePtr pDrawable)
d390 3
d394 9
a402 1
	    DamageReportDamage (pDamage, &pDamage->pendingDamage);
d404 2
a405 1
	}
d423 1
a423 1
    _damageDamageRegion (pDrawable, &region, TRUE, subWindowMode, where);
d425 1
a425 1
    damageDamageRegion (pDrawable, &region, TRUE, subWindowMode);
d655 1
a655 1
    damageReportPostOp (pDst->pDrawable);
d722 1
a722 1
    damageReportPostOp (pDst->pDrawable);
d774 1
a774 1
    damageReportPostOp (pPicture->pDrawable);
d827 1
a827 1
    damageReportPostOp (pDrawable);
d875 1
a875 1
    damageReportPostOp (pDrawable);
d907 1
a907 1
    damageReportPostOp (pDrawable);
d951 1
a951 1
    damageReportPostOp (pDst);
d997 1
a997 1
    damageReportPostOp (pDst);
d1039 1
a1039 1
    damageReportPostOp (pDrawable);
d1113 1
a1113 1
    damageReportPostOp (pDrawable);
d1192 1
a1192 1
    damageReportPostOp (pDrawable);
d1254 1
a1254 1
    damageReportPostOp (pDrawable);
d1307 1
a1307 1
    damageReportPostOp (pDrawable);
d1366 1
a1366 1
    damageReportPostOp (pDrawable);
d1405 1
a1405 1
    damageReportPostOp (pDrawable);
d1447 1
a1447 1
    damageReportPostOp (pDrawable);
d1558 1
a1558 1
    damageReportPostOp (pDrawable);
d1579 1
a1579 1
    damageReportPostOp (pDrawable);
d1599 1
a1599 1
    damageReportPostOp (pDrawable);
d1619 1
a1619 1
    damageReportPostOp (pDrawable);
d1638 1
a1638 1
    damageReportPostOp (pDrawable);
d1656 1
a1656 1
    damageReportPostOp (pDrawable);
d1690 1
a1690 1
    damageReportPostOp (pDrawable);
d1770 1
a1770 1
	damageDamageRegion (&pWindow->drawable, prgnSrc, FALSE, -1);
d1775 1
a1775 1
    damageReportPostOp (&pWindow->drawable);
d1858 4
d1927 1
d1929 1
d2053 1
a2053 1
RegionPtr
d2066 23
d2092 1
a2092 1
    damageDamageRegion (pDrawable, pRegion, FALSE, -1);
d2098 1
a2098 1
    damageReportPostOp (pDrawable);
d2101 1
a2101 1
void
d2105 8
@


1.1
log
@Initial revision
@
text
@a1 2
 * $Id$
 *
d68 2
a69 2
#define getPixmapDamageRef(pPixmap) \
    ((DamagePtr *) &(pPixmap->devPrivates[damagePixPrivateIndex].ptr))
d73 5
d117 47
a163 1
	    &(pWindow->devPrivates[damageWinPrivateIndex].ptr)
a181 3
    Bool	    was_empty;
    RegionRec	    tmpRegion;
    BoxRec	    tmpBox;
a244 3
#if 0
	    DAMAGE_DEBUG (("damage while window unrealized\n"));
#endif
d302 10
a311 34
	
	switch (pDamage->damageLevel) {
	case DamageReportRawRegion:
	    (*pDamage->damageReport) (pDamage, pDamageRegion, pDamage->closure);
	    break;
	case DamageReportDeltaRegion:
	    REGION_NULL (pScreen, &tmpRegion);
	    REGION_SUBTRACT (pScreen, &tmpRegion, pDamageRegion, &pDamage->damage);
	    if (REGION_NOTEMPTY (pScreen, &tmpRegion))
	    {
		REGION_UNION(pScreen, &pDamage->damage,
			     &pDamage->damage, pDamageRegion);
		(*pDamage->damageReport) (pDamage, &tmpRegion, pDamage->closure);
	    }
	    REGION_UNINIT(pScreen, &tmpRegion);
	    break;
	case DamageReportBoundingBox:
	    tmpBox = *REGION_EXTENTS (pScreen, &pDamage->damage);
	    REGION_UNION(pScreen, &pDamage->damage,
			 &pDamage->damage, pDamageRegion);
	    if (!BOX_SAME (&tmpBox, REGION_EXTENTS (pScreen, &pDamage->damage)))
		(*pDamage->damageReport) (pDamage, &pDamage->damage, pDamage->closure);
	    break;
	case DamageReportNonEmpty:
	    was_empty = !REGION_NOTEMPTY(pScreen, &pDamage->damage);
	    REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
			 pDamageRegion);
	    if (was_empty && REGION_NOTEMPTY(pScreen, &pDamage->damage))
		(*pDamage->damageReport) (pDamage, &pDamage->damage, pDamage->closure);
	    break;
	case DamageReportNone:
	    REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
			 pDamageRegion);
	    break;
d313 1
d328 15
d371 1
a371 1
GCFuncs damageGCFuncs = {
d376 1
a376 1
extern GCOps damageGCOps;
d588 1
d655 1
d658 52
d760 1
d808 1
d840 1
d884 1
d930 1
d972 1
d1046 1
d1125 1
d1187 1
d1240 1
d1299 1
d1338 1
d1380 1
d1450 1
a1450 1
    charinfo = (CharInfoPtr *) ALLOCATE_LOCAL(count * sizeof(CharInfoPtr));
d1472 1
a1472 1
    DEALLOCATE_LOCAL(charinfo);
d1491 1
d1512 1
d1532 1
d1552 1
d1571 1
d1589 1
d1623 1
a1685 27
damagePaintWindow(WindowPtr pWindow,
		  RegionPtr prgn,
		  int	    what)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    damageScrPriv(pScreen);

    /*
     * Painting background none doesn't actually *do* anything, so
     * no damage is recorded
     */
    if ((what != PW_BACKGROUND || pWindow->backgroundState != None) &&
	getWindowDamage (pWindow))
	damageDamageRegion (&pWindow->drawable, prgn, FALSE, -1);
    if(what == PW_BACKGROUND) {
	unwrap (pScrPriv, pScreen, PaintWindowBackground);
	(*pScreen->PaintWindowBackground) (pWindow, prgn, what);
	wrap (pScrPriv, pScreen, PaintWindowBackground, damagePaintWindow);
    } else {
	unwrap (pScrPriv, pScreen, PaintWindowBorder);
	(*pScreen->PaintWindowBorder) (pWindow, prgn, what);
	wrap (pScrPriv, pScreen, PaintWindowBorder, damagePaintWindow);
    }
}


static void
d1708 1
d1712 1
a1712 1
GCOps damageGCOps = {
a1726 18
damageRestoreAreas (PixmapPtr	pPixmap,
		    RegionPtr	prgn,
		    int		xorg,
		    int		yorg,
		    WindowPtr	pWindow)
{
    ScreenPtr pScreen = pWindow->drawable.pScreen;
    damageScrPriv(pScreen);

    damageDamageRegion (&pWindow->drawable, prgn, FALSE, -1);
    unwrap (pScrPriv, pScreen, BackingStoreFuncs.RestoreAreas);
    (*pScreen->BackingStoreFuncs.RestoreAreas) (pPixmap, prgn,
						xorg, yorg, pWindow);
    wrap (pScrPriv, pScreen, BackingStoreFuncs.RestoreAreas,
			     damageRestoreAreas);
}

static void
a1784 2
    unwrap (pScrPriv, pScreen, PaintWindowBackground);
    unwrap (pScrPriv, pScreen, PaintWindowBorder);
a1786 1
    unwrap (pScrPriv, pScreen, BackingStoreFuncs.RestoreAreas);
a1790 6
int damageScrPrivateIndex;
int damagePixPrivateIndex;
int damageGCPrivateIndex;
int damageWinPrivateIndex;
int damageGeneration;

d1799 1
a1799 17
    if (damageGeneration != serverGeneration)
    {
	damageScrPrivateIndex = AllocateScreenPrivateIndex ();
	if (damageScrPrivateIndex == -1)
	    return FALSE;
	damageGCPrivateIndex = AllocateGCPrivateIndex ();
	if (damageGCPrivateIndex == -1)
	    return FALSE;
	damagePixPrivateIndex = AllocatePixmapPrivateIndex ();
	if (damagePixPrivateIndex == -1)
	    return FALSE;
	damageWinPrivateIndex = AllocateWindowPrivateIndex ();
	if (damageWinPrivateIndex == -1)
	    return FALSE;
	damageGeneration = serverGeneration;
    }
    if (pScreen->devPrivates[damageScrPrivateIndex].ptr)
d1802 1
a1802 5
    if (!AllocateGCPrivate (pScreen, damageGCPrivateIndex, sizeof (DamageGCPrivRec)))
	return FALSE;
    if (!AllocatePixmapPrivate (pScreen, damagePixPrivateIndex, 0))
	return FALSE;
    if (!AllocateWindowPrivate (pScreen, damageWinPrivateIndex, 0))
a1808 10
#ifdef COMPOSITE
    /* This is a kludge to ensure wrapping order with the composite wrapper.
     * If it's done from compinit.c, then DamageSetup may be called before the
     * extension init phase, so that cw will be higher in the wrapping chain and
     * rewrite drawables before damage gets to it, causing confusion.
     */
    if (!noCompositeExtension)
	miInitializeCompositeWrapper (pScreen);
#endif
	
a1813 2
    wrap (pScrPriv, pScreen, PaintWindowBackground, damagePaintWindow);
    wrap (pScrPriv, pScreen, PaintWindowBorder, damagePaintWindow);
a1817 2
    wrap (pScrPriv, pScreen, BackingStoreFuncs.RestoreAreas,
			     damageRestoreAreas);
d1822 1
d1826 1
a1826 1
    pScreen->devPrivates[damageScrPrivateIndex].ptr = (pointer) pScrPriv;
d1846 1
d1853 1
d1937 1
d1986 6
d1997 12
@


1.1.1.1
log
@Importing xserver from X.Org 7.2RC2
@
text
@@


1.1.1.2
log
@xserver 1.4
@
text
@d2 2
a74 6
static int damageScrPrivateIndex;
static int damagePixPrivateIndex;
static int damageGCPrivateIndex;
static int damageWinPrivateIndex;
static int damageGeneration;

a115 46
static void
DamageReportDamage (DamagePtr pDamage, RegionPtr pDamageRegion)
{
    BoxRec tmpBox;
    RegionRec tmpRegion;
    Bool was_empty;

    switch (pDamage->damageLevel) {
    case DamageReportRawRegion:
	(*pDamage->damageReport) (pDamage, pDamageRegion, pDamage->closure);
	break;
    case DamageReportDeltaRegion:
	REGION_NULL (pScreen, &tmpRegion);
	REGION_SUBTRACT (pScreen, &tmpRegion, pDamageRegion, &pDamage->damage);
	if (REGION_NOTEMPTY (pScreen, &tmpRegion)) {
	    REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
			 pDamageRegion);
	    (*pDamage->damageReport) (pDamage, &tmpRegion, pDamage->closure);
	}
	REGION_UNINIT(pScreen, &tmpRegion);
	break;
    case DamageReportBoundingBox:
	tmpBox = *REGION_EXTENTS (pScreen, &pDamage->damage);
	REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	if (!BOX_SAME (&tmpBox, REGION_EXTENTS (pScreen, &pDamage->damage))) {
	    (*pDamage->damageReport) (pDamage, &pDamage->damage,
				      pDamage->closure);
	}
	break;
    case DamageReportNonEmpty:
	was_empty = !REGION_NOTEMPTY(pScreen, &pDamage->damage);
	REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	if (was_empty && REGION_NOTEMPTY(pScreen, &pDamage->damage)) {
	    (*pDamage->damageReport) (pDamage, &pDamage->damage,
				      pDamage->closure);
	}
	break;
    case DamageReportNone:
	REGION_UNION(pScreen, &pDamage->damage, &pDamage->damage,
		     pDamageRegion);
	break;
    }
}

d133 3
d259 34
a292 10

	/* If the damage rec has been flagged to report damage after the op has
	 * completed, then union it into the delayed damage region, which will
	 * be used for reporting after calling down, and skip the reporting 
	 */
	if (!pDamage->reportAfter) {
	    DamageReportDamage (pDamage, pDamageRegion);
	} else {
	    REGION_UNION(pScreen, &pDamage->pendingDamage,
			 &pDamage->pendingDamage, pDamageRegion);
a293 1

a307 15
static void
damageReportPostOp (DrawablePtr pDrawable)
{
    drawableDamage(pDrawable);

    for (; pDamage != NULL; pDamage = pDamage->pNext)
    {
	if (pDamage->reportAfter) {
	    DamageReportDamage (pDamage, &pDamage->pendingDamage);
	    REGION_EMPTY (pScreen, &pDamage->pendingDamage);
	}
    }
    
}

d336 1
a336 1
static GCFuncs damageGCFuncs = {
d341 1
a341 1
static GCOps damageGCOps;
a552 1
    damageReportPostOp (pDst->pDrawable);
a618 1
    damageReportPostOp (pDst->pDrawable);
a670 1
    damageReportPostOp (pDrawable);
a717 1
    damageReportPostOp (pDrawable);
a748 1
    damageReportPostOp (pDrawable);
a791 1
    damageReportPostOp (pDst);
a836 1
    damageReportPostOp (pDst);
a877 1
    damageReportPostOp (pDrawable);
a950 1
    damageReportPostOp (pDrawable);
a1028 1
    damageReportPostOp (pDrawable);
a1089 1
    damageReportPostOp (pDrawable);
a1141 1
    damageReportPostOp (pDrawable);
a1199 1
    damageReportPostOp (pDrawable);
a1237 1
    damageReportPostOp (pDrawable);
a1278 1
    damageReportPostOp (pDrawable);
a1388 1
    damageReportPostOp (pDrawable);
a1408 1
    damageReportPostOp (pDrawable);
a1427 1
    damageReportPostOp (pDrawable);
a1446 1
    damageReportPostOp (pDrawable);
a1464 1
    damageReportPostOp (pDrawable);
a1481 1
    damageReportPostOp (pDrawable);
a1514 1
    damageReportPostOp (pDrawable);
a1593 1
	damageReportPostOp (&pWindow->drawable);
a1597 1
	damageReportPostOp (&pWindow->drawable);
a1625 1
    damageReportPostOp (&pWindow->drawable);
d1629 1
a1629 1
static GCOps damageGCOps = {
a1656 1
    damageReportPostOp (&pWindow->drawable);
d1729 6
d1773 10
a1822 1
    REGION_NULL(pScreen, &pDamage->pendingDamage);
a1828 1
    pDamage->reportAfter = FALSE;
a1911 1
    REGION_UNINIT (pDamage->pDrawable->pScreen, &pDamage->pendingDamage);
a1964 12

    /* Go back and report this damage for DamagePtrs with reportAfter set, since
     * this call isn't part of an in-progress drawing op in the call chain and
     * the DDX probably just wants to know about it right away.
     */
    damageReportPostOp (pDrawable);
}

void
DamageSetReportAfterOp (DamagePtr pDamage, Bool reportAfter)
{
    pDamage->reportAfter = reportAfter;
@

