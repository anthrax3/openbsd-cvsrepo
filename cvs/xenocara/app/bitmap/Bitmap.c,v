head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.6
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.10
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_3:1.1.1.1
	v1_0_2:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2015.01.25.11.30.36;	author matthieu;	state Exp;
branches;
next	1.4;
commitid	wUYhmqaHpMEiaMBU;

1.4
date	2013.05.31.20.00.13;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2012.03.10.11.46.07;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.26.14.06.18;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.20.08.47;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.20.08.47;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Update to bitmap 1.0.8
@
text
@/*

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall
not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization
from The Open Group.

*/

/*
 * Author:  Davor Matic, MIT X Consortium
 */

#include <X11/IntrinsicP.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/XawInit.h>
#include <X11/Xmu/CharSet.h>
#include <X11/Xmu/Drawing.h>
#include <X11/Xatom.h>
#include <X11/Xfuncs.h>
#include <X11/Xos.h>
#include "BitmapP.h"
#include "Bitmap.h"

#include <assert.h>
#include <stdio.h>
#include <math.h>

#define min(x, y)                     ((((int)(x)) < (int)(y)) ? (x) : (y))
#define max(x, y)                     ((((int)(x)) > (int)(y)) ? (x) : (y))

Boolean DEBUG;

#define DefaultGridTolerance 8
#define DefaultBitmapSize    "16x16"
#define FallbackBitmapWidth  16
#define FallbackBitmapHeight 16
#define DefaultGrid          TRUE
#define DefaultDashed        TRUE
#define DefaultStippled      TRUE
#define DefaultProportional  TRUE
#define DefaultAxes          FALSE
#define DefaultMargin        16
#define DefaultSquareWidth   16
#define DefaultSquareHeight  16
#define DefaultFilename      ""

#define Offset(field) XtOffsetOf(BitmapRec, bitmap.field)

static XtResource resources[] = {
{XtNforeground, XtCForeground, XtRPixel, sizeof(Pixel),
     Offset(foreground_pixel), XtRString, XtDefaultForeground},
{XtNhighlight, XtCHighlight, XtRPixel, sizeof(Pixel),
     Offset(highlight_pixel), XtRString, XtDefaultForeground},
{XtNframe, XtCFrame, XtRPixel, sizeof(Pixel),
     Offset(frame_pixel), XtRString, XtDefaultForeground},
{XtNgridTolerance, XtCGridTolerance, XtRDimension, sizeof(Dimension),
     Offset(grid_tolerance), XtRImmediate, (XtPointer) DefaultGridTolerance},
{XtNsize, XtCSize, XtRString, sizeof(String),
     Offset(size), XtRImmediate, (XtPointer) DefaultBitmapSize},
{XtNdashed, XtCDashed, XtRBoolean, sizeof(Boolean),
     Offset(dashed), XtRImmediate, (XtPointer) DefaultDashed},
{XtNgrid, XtCGrid, XtRBoolean, sizeof(Boolean),
     Offset(grid), XtRImmediate, (XtPointer) DefaultGrid},
{XtNstippled, XtCStippled, XtRBoolean, sizeof(Boolean),
     Offset(stippled), XtRImmediate, (XtPointer) DefaultStippled},
{XtNproportional, XtCProportional, XtRBoolean, sizeof(Boolean),
     Offset(proportional), XtRImmediate, (XtPointer) DefaultProportional},
{XtNaxes, XtCAxes, XtRBoolean, sizeof(Boolean),
     Offset(axes), XtRImmediate, (XtPointer) DefaultAxes},
{XtNsquareWidth, XtCSquareWidth, XtRDimension, sizeof(Dimension),
     Offset(squareW), XtRImmediate, (XtPointer) DefaultSquareWidth},
{XtNsquareHeight, XtCSquareHeight, XtRDimension, sizeof(Dimension),
     Offset(squareH), XtRImmediate, (XtPointer) DefaultSquareHeight},
{XtNmargin, XtCMargin, XtRDimension, sizeof(Dimension),
     Offset(margin), XtRImmediate, (XtPointer) DefaultMargin},
{XtNxHot, XtCXHot, XtRPosition, sizeof(Position),
     Offset(hot.x), XtRImmediate, (XtPointer) NotSet},
{XtNyHot, XtCYHot, XtRPosition, sizeof(Position),
     Offset(hot.y), XtRImmediate, (XtPointer) NotSet},
{XtNbutton1Function, XtCButton1Function, XtRButtonFunction, sizeof(int),
     Offset(button_function[0]), XtRImmediate, (XtPointer) Set},
{XtNbutton2Function, XtCButton2Function, XtRButtonFunction, sizeof(int),
     Offset(button_function[1]), XtRImmediate, (XtPointer) Invert},
{XtNbutton3Function, XtCButton3Function, XtRButtonFunction, sizeof(int),
     Offset(button_function[2]), XtRImmediate, (XtPointer) Clear},
{XtNbutton4Function, XtCButton4Function, XtRButtonFunction, sizeof(int),
     Offset(button_function[3]), XtRImmediate, (XtPointer) Clear},
{XtNbutton5Function, XtCButton5Function, XtRButtonFunction, sizeof(int),
     Offset(button_function[4]), XtRImmediate, (XtPointer) Clear},
{XtNfilename, XtCFilename, XtRString, sizeof(String),
     Offset(filename), XtRImmediate, (XtPointer) DefaultFilename},
{XtNbasename, XtCBasename, XtRString, sizeof(String),
     Offset(basename), XtRImmediate, (XtPointer) DefaultFilename},
{XtNdashes, XtCDashes, XtRBitmap, sizeof(Pixmap),
     Offset(dashes), XtRImmediate, (XtPointer) XtUnspecifiedPixmap},
{XtNstipple, XtCStipple, XtRBitmap, sizeof(Pixmap),
     Offset(stipple), XtRImmediate, (XtPointer) XtUnspecifiedPixmap},
};
#undef Offset


static XtActionsRec actions[] =
{
{"mark",               (XtActionProc)BWTMark},
{"mark-all",           (XtActionProc)BWTMarkAll},
{"unmark",             (XtActionProc)BWTUnmark},
{"paste",              (XtActionProc)BWTPaste},
{"bw-debug",           (XtActionProc)BWDebug},
{"abort",              (XtActionProc)BWAbort},
{"store-to-buffer",    (XtActionProc)BWStoreToBuffer},
{"change-notify",      (XtActionProc)BWChangeNotify},
{"set-changed",        (XtActionProc)BWSetChanged},
{"up",                 (XtActionProc)BWUp},
{"down",               (XtActionProc)BWDown},
{"left",               (XtActionProc)BWLeft},
{"right",              (XtActionProc)BWRight},
{"fold",               (XtActionProc)BWFold},
{"flip-horiz",         (XtActionProc)BWFlipHoriz},
{"flip-vert",          (XtActionProc)BWFlipVert},
{"rotate-right",       (XtActionProc)BWRotateRight},
{"rotate-left",        (XtActionProc)BWRotateLeft},
{"set",                (XtActionProc)BWSet},
{"clear",              (XtActionProc)BWClear},
{"invert",             (XtActionProc)BWInvert},
{"undo",               (XtActionProc)BWUndo},
{"redraw",             (XtActionProc)BWRedraw},
};

static char translations1[] =
"\
Shift<Btn1Down>: mark()\n\
Shift<Btn2Down>: mark-all()\n\
Shift<Btn3Down>: unmark()\n\
Ctrl<BtnDown>:   paste()\n\
Ctrl<Key>l: redraw()\n\
<Key>d:     bw-debug()\n\
<Key>a:     abort()\n\
<Key>Up:    store-to-buffer()\
            up()\
            change-notify()\
            set-changed()\n\
<Key>KP_Up: store-to-buffer()\
            up()\
            change-notify()\
            set-changed()\n\
<Key>Down:  store-to-buffer()\
            down()\
            change-notify()\
            set-changed()\n\
<Key>KP_Down: store-to-buffer()\
            down()\
            change-notify()\
            set-changed()\n\
<Key>Left:  store-to-buffer()\
            left()\
            change-notify()\
            set-changed()\n\
<Key>KP_Left: store-to-buffer()\
            left()\
            change-notify()\
            set-changed()\n\
<Key>Right: store-to-buffer()\
            right()\
            change-notify()\
            set-changed()\n\
<Key>KP_Right: store-to-buffer()\
            right()\
            change-notify()\
            set-changed()\n\
<Key>f:     store-to-buffer()\
            fold()\
            change-notify()\
            set-changed()\n\
<Key>h:     store-to-buffer()\
            flip-horiz()\
            change-notify()\
            set-changed()\n\
";

static char translations2[] =
"<Key>v:     store-to-buffer()\
            flip-vert()\
            change-notify()\
            set-changed()\n\
<Key>r:     store-to-buffer()\
            rotate-right()\
            change-notify()\
            set-changed()\n\
<Key>l:     store-to-buffer()\
            rotate-left()\
            change-notify()\
            set-changed()\n\
<Key>s:     store-to-buffer()\
            set()\
            change-notify()\
            set-changed()\n\
<Key>c:     store-to-buffer()\
            clear()\
            change-notify()\
            set-changed()\n\
<Key>i:     store-to-buffer()\
            invert()\
            change-notify()\
            set-changed()\n\
<Key>u:     undo()\
            change-notify()\
            set-changed()\n\
";

static Atom targets[] = {
    XA_BITMAP,
    XA_PIXMAP
};

#include "Requests.h"


static BWRequestRec requests[] =
{
{MarkRequest, sizeof(BWStatus),
     TwoPointsEngage, (XtPointer) BWDrawRectangle,
     TwoPointsTerminateTimed, (XtPointer) BWSelect,
     NULL, (XtPointer) NULL},
{RestoreRequest, sizeof(BWStatus),
     OnePointEngage, (XtPointer) BWDragStored,
     OnePointTerminate, (XtPointer) BWRestore,
     NULL, (XtPointer) NULL},
{ImmediateCopyRequest, sizeof(BWStatus),
     OnePointEngage, (XtPointer) BWDragMarked,
     OnePointTerminate, (XtPointer) BWCopy,
     NULL, (XtPointer) NULL},
{ImmediateMoveRequest, sizeof(BWStatus),
     OnePointEngage, (XtPointer) BWDragMarked,
     OnePointTerminate, (XtPointer) BWMove,
     NULL, (XtPointer) NULL},
{CopyRequest, sizeof(BWStatus),
     DragOnePointEngage, (XtPointer) Paste,
     DragOnePointTerminate, (XtPointer) ImmediateCopyRequest,
     Interface, (XtPointer) BWUnmark},
{MoveRequest, sizeof(BWStatus),
     DragOnePointEngage, (XtPointer) Paste,
     DragOnePointTerminate, (XtPointer) ImmediateMoveRequest,
     Interface, (XtPointer) BWUnmark},
{PointRequest, sizeof(BWStatus),
     DragOnePointEngage, (XtPointer) BWDrawPoint,
     DragOnePointTerminate, (XtPointer) BWDrawPoint,
     NULL, (XtPointer) NULL},
{CurveRequest, sizeof(BWStatus),
     DragTwoPointsEngage, (XtPointer) BWBlindLine,
     DragTwoPointsTerminate, (XtPointer) BWBlindLine,
     NULL, (XtPointer) NULL},
{LineRequest, sizeof(BWStatus),
     TwoPointsEngage, (XtPointer) BWDrawLine,
     TwoPointsTerminate, (XtPointer) BWDrawLine,
     NULL, (XtPointer) NULL},
{RectangleRequest, sizeof(BWStatus),
     TwoPointsEngage, (XtPointer) BWDrawRectangle,
     TwoPointsTerminate, (XtPointer) BWDrawRectangle,
     NULL, (XtPointer) NULL},
{FilledRectangleRequest, sizeof(BWStatus),
     TwoPointsEngage, (XtPointer) BWDrawRectangle,
     TwoPointsTerminate, (XtPointer) BWDrawFilledRectangle,
     NULL, (XtPointer) NULL},
{CircleRequest, sizeof(BWStatus),
     TwoPointsEngage, (XtPointer) BWDrawCircle,
     TwoPointsTerminate, (XtPointer) BWDrawCircle,
     NULL, (XtPointer) NULL},
{FilledCircleRequest, sizeof(BWStatus),
     TwoPointsEngage, (XtPointer) BWDrawCircle,
     TwoPointsTerminate, (XtPointer) BWDrawFilledCircle,
     NULL, (XtPointer) NULL},
{FloodFillRequest, sizeof(BWStatus),
     OnePointEngage, (XtPointer) NULL,
     OnePointTerminate, (XtPointer) BWFloodFill,
     NULL, (XtPointer) NULL},
{HotSpotRequest, sizeof(BWStatus),
     OnePointEngage, (XtPointer) BWDrawHotSpot,
     OnePointTerminate, (XtPointer) BWDrawHotSpot,
     NULL, (XtPointer) NULL},
{ZoomInRequest, sizeof(BWStatus),
     TwoPointsEngage, (XtPointer) BWDrawRectangle,
     TwoPointsTerminate, (XtPointer) BWZoomIn,
     NULL, (XtPointer) NULL},
};

static void ClassInitialize(void);
static void Initialize(Widget wrequest, Widget wnew,
		       ArgList argv, Cardinal *argc);
static void Redisplay(Widget w, XEvent *event, Region region);
static void Resize(Widget w);
static void Destroy(Widget w);
static void Refresh(BitmapWidget BW, Position x, Position y,
		    Dimension width, Dimension height);
static Boolean SetValues(Widget old, Widget request, Widget new,
			 ArgList args, Cardinal *num_args);

BitmapClassRec bitmapClassRec = {
{   /* core fields */
    /* superclass		*/	(WidgetClass) &simpleClassRec,
    /* class_name		*/	"Bitmap",
    /* widget_size		*/	sizeof(BitmapRec),
    /* class_initialize		*/	ClassInitialize,
    /* class_part_initialize	*/	NULL,
    /* class_inited		*/	FALSE,
    /* initialize		*/	Initialize,
    /* initialize_hook		*/	NULL,
    /* realize			*/	XtInheritRealize,
    /* actions			*/	actions,
    /* num_actions		*/	XtNumber(actions),
    /* resources		*/	resources,
    /* num_resources		*/	XtNumber(resources),
    /* xrm_class		*/	NULLQUARK,
    /* compress_motion		*/	TRUE,
    /* compress_exposure	*/	FALSE,
    /* compress_enterleave	*/	TRUE,
    /* visible_interest		*/	TRUE,
    /* destroy			*/	Destroy,
    /* resize			*/	Resize,
    /* expose			*/	Redisplay,
    /* set_values		*/	SetValues,
    /* set_values_hook		*/	NULL,
    /* set_values_almost	*/	XtInheritSetValuesAlmost,
    /* get_values_hook		*/	NULL,
    /* accept_focus		*/	NULL,
    /* version			*/	XtVersion,
    /* callback_private		*/	NULL,
    /* tm_table			*/	NULL , /* set in code */
    /* query_geometry		*/	XtInheritQueryGeometry,
    /* display_accelerator	*/	XtInheritDisplayAccelerator,
    /* extension		*/	NULL,
  },
  {
    /* empty			*/	XtInheritChangeSensitive,
  },
  {
    /* targets                  */      targets,
    /* num_trets                */      XtNumber(targets),
    /* requests                 */      requests,
    /* num_requests             */      XtNumber(requests),
  }
};

WidgetClass bitmapWidgetClass = (WidgetClass) &bitmapClassRec;

/* ARGSUSED */

void
BWDebug(Widget w, XEvent *event, String *params, Cardinal *num_params)
{
    DEBUG ^= True;
}

Pixmap
BWGetPixmap(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    return GetPixmap(BW, BW->bitmap.zoom.image);
}

Pixmap
BWGetUnzoomedPixmap(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;
    GC gc;
    Pixmap pix;

    if (BW->bitmap.zooming) {
	pix = XCreatePixmap(XtDisplay(w), XtWindow(w),
			    BW->bitmap.zoom.image->width,
			    BW->bitmap.zoom.image->height, 1);
	if (!(gc = XCreateGC(XtDisplay(w), pix,
			     (unsigned long) 0, (XGCValues *) 0))) {
	    XFreePixmap(XtDisplay(w), pix);
	    return (Pixmap) None;
	}

	XPutImage(XtDisplay(w), pix, gc,
		  BW->bitmap.zoom.image,
		  0, 0, 0, 0,
		  BW->bitmap.zoom.image->width,
		  BW->bitmap.zoom.image->height);
	XPutImage(XtDisplay(w), pix, gc,
		  BW->bitmap.image,
		  0, 0,
		  BW->bitmap.zoom.at_x,
		  BW->bitmap.zoom.at_y,
		  BW->bitmap.image->width,
		  BW->bitmap.image->height);
    }
    else {
	pix = XCreatePixmap(XtDisplay(w), XtWindow(w),
			    BW->bitmap.image->width,
			    BW->bitmap.image->height, 1);
	if (! (gc = XCreateGC(XtDisplay(w), pix,
			      (unsigned long) 0, (XGCValues *) 0))){
	    XFreePixmap(XtDisplay(w), pix);
	    return (Pixmap) None;
	}

	XPutImage(XtDisplay(w), pix, gc,
		  BW->bitmap.image,
		  0, 0, 0, 0,
		  BW->bitmap.image->width,
		  BW->bitmap.image->height);
    }
    XFreeGC(XtDisplay(w), gc);
    return(pix);
}


XImage *
GetImage(BitmapWidget BW, Pixmap pixmap)
{
    Window root;
    int x, y;
    unsigned int width, height, border_width, depth;
    XImage *source, *image;

    XGetGeometry(XtDisplay(BW), pixmap, &root, &x, &y,
		 &width, &height, &border_width, &depth);

    source = XGetImage(XtDisplay(BW), pixmap, x, y, width, height,
		     1, XYPixmap);

    image = ConvertToBitmapImage(BW, source);

    return image;
}

XImage *
CreateBitmapImage(BitmapWidget BW, char *data,
		  Dimension width, Dimension height)
{
    XImage *image = XCreateImage(XtDisplay(BW),
				 DefaultVisual(XtDisplay(BW),
					       DefaultScreen(XtDisplay(BW))),
				 1, XYBitmap, 0,
				 data, width, height,
				 8, ((int)width + 7) / 8);

    image->height = height;
    image->width = width;
    image->depth = 1;
    image->xoffset = 0;
    image->format = XYBitmap;
    image->data = (char *)data;
    image->byte_order = LSBFirst;
    image->bitmap_unit = 8;
    image->bitmap_bit_order = LSBFirst;
    image->bitmap_pad = 8;
    image->bytes_per_line = ((int)width + 7) / 8;

    return image;
}

void
DestroyBitmapImage(XImage **image)
{
    /*XDestroyImage(*image);*/
    if (image) {
	if (*image) {
	    if ((*image)->data)
		XtFree((*image)->data);
	    XtFree((char *)*image);
	}
	*image = NULL;
    }
}

#if 0
XImage *
BWGetImage(Widget w, XEvent *event, String *params, Cardinal *num_params)
{
    BitmapWidget BW = (BitmapWidget) w;

    return BW->bitmap.image;
}
#endif

void
BWChangeNotify(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    if (BW->bitmap.notify)
	(*BW->bitmap.notify)(w, NULL, NULL, NULL);
}

void
BWNotify(Widget w, XtActionProc proc)
{
    BitmapWidget BW = (BitmapWidget) w;

    BW->bitmap.notify = proc;
}

void
BWSetChanged(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    BW->bitmap.changed = True;
}

Boolean
BWQueryChanged(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    return BW->bitmap.changed;
}

void
BWClearChanged(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    BW->bitmap.changed = False;
}

Boolean
BWQueryStored(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    return (BW->bitmap.storage != NULL);
}

Boolean
BWQueryStippled(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    return BW->bitmap.stippled;
}

static void
RedrawStippled(BitmapWidget BW)
{
  XExposeEvent event;

  event.type = Expose;
  event.display = XtDisplay((Widget)BW);
  event.window = XtWindow((Widget)BW);
  event.x = 0;
  event.y = 0;
  event.width = BW->core.width;
  event.height = BW->core.height;
  event.count = 0;

  BWRedrawMark((Widget)BW);

  BW->bitmap.stipple_change_expose_event = True;

  XtDispatchEvent((XEvent *)&event);

  BW->bitmap.stipple_change_expose_event = False;
}

void
BWSwitchStippled(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    RedrawStippled(BW);

    BW->bitmap.stippled ^= True;
    XSetFillStyle(XtDisplay(BW), BW->bitmap.highlighting_gc,
		  (BW->bitmap.stippled ? FillStippled : FillSolid));

    RedrawStippled(BW);
}

void
BWSelect(Widget w, Position from_x, Position from_y,
	 Position to_x, Position to_y, Time btime)
{
    BWMark(w, from_x, from_y, to_x, to_y);

    BWGrabSelection(w, btime);
}

Boolean
BWQueryAxes(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    return BW->bitmap.axes;
}

void
BWSwitchAxes(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    BW->bitmap.axes ^= True;
    BWHighlightAxes(w);
}

void
BWAxes(Widget w, Boolean _switch)
{
    BitmapWidget BW = (BitmapWidget) w;

    if (BW->bitmap.axes != _switch)
	BWSwitchAxes(w);
}

void
BWRedrawAxes(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    if (BW->bitmap.axes)
	BWHighlightAxes(w);
}

#if 0
void
BWPutImage(BitmapWidget w, Display *display, Drawable drawable, GC gc,
	   Position x, Position y)
{
    BitmapWidget BW = (BitmapWidget) w;

  XPutImage(display, drawable, gc, BW->bitmap.image,
	    0, 0, x, y, BW->bitmap.image->width, BW->bitmap.image->height);
}
#endif

static String
StripFilename(_Xconst _XtString filename)
{
    const char *begin = strrchr(filename, '/');
    const char *end;
    char *result;
    int length;

    if (filename) {
	begin = (begin ? begin + 1 : filename);
	end = strchr(begin, '.'); /* change to strrchr to allow longer names */
	length = (end ? (end - begin) : strlen (begin));
	result = (char *) XtMalloc (length + 1);
	strncpy (result, begin, length);
	result [length] = '\0';
	return (result);
    }
    else
	return (NULL);
}

static int
XmuWriteBitmapDataToFile(_Xconst _XtString filename,
			 _Xconst _XtString basename,
			 int width, int height, char *datap,
			 int x_hot, int y_hot)
{
    FILE *file;
    int i, data_length;

    data_length = Length(width, height);

    if(!filename || !strcmp(filename, "") || !strcmp(filename, "-")) {
	file = stdout;
	filename = "dummy";
	}
    else
    	file = fopen(filename, "w+");

    if (file) {
	String new_basename;

	if (!basename || !strcmp(basename, "") || !strcmp(basename, "-"))
	    basename = new_basename = StripFilename(filename);
	else
	    new_basename = NULL;

	fprintf(file, "#define %s_width %d\n", basename, width);
	fprintf(file, "#define %s_height %d\n", basename, height);
	if (QuerySet(x_hot, y_hot)) {
	    fprintf(file, "#define %s_x_hot %d\n", basename, x_hot);
	    fprintf(file, "#define %s_y_hot %d\n", basename, y_hot);
	}
	fprintf(file, "static unsigned char %s_bits[] = {\n   0x%02x",
		basename, (unsigned char) datap[0]);
	for(i = 1; i < data_length; i++) {
	    fprintf(file, ",");
	    fprintf(file, (i % 12) ? " " : "\n   ");
	    fprintf(file, "0x%02x", (unsigned char) datap[i]);
	}
	fprintf(file, "};\n");

	if (file != stdout)
	    fclose(file);

	XtFree(new_basename);
	return BitmapSuccess;
    }

    return 1;
}

/*
 *
 */

				/* ARGSUSED */
static void
CvtStringToButtonFunction(XrmValuePtr args, /* not used */
			  Cardinal *num_args, /* not used */
			  XrmValuePtr from_val,
			  XrmValuePtr to_val)
{
  static int button_function;
  char lower_name[80];

  XmuCopyISOLatin1Lowered (lower_name, (char*)from_val->addr);

  if (!strcmp(lower_name, XtClear)) {
    button_function = Clear;
    to_val->addr = (XPointer) &button_function;
    to_val->size = sizeof(button_function);
    return;
  }

  if (!strcmp(lower_name, XtSet)) {
    button_function = Set;
    to_val->addr = (XPointer) &button_function;
    to_val->size = sizeof(button_function);
    return;
  }

  if (!strcmp(lower_name, XtInvert)) {
    button_function = Invert;
    to_val->addr = (XPointer) &button_function;
    to_val->size = sizeof(button_function);
    return;
  }

  XtStringConversionWarning(from_val->addr, XtRButtonFunction);
  button_function = Clear;
  to_val->addr = (XPointer) &button_function;
  to_val->size = sizeof(button_function);

}

static void
ClassInitialize(void)
{
  char *tm_table = XtMalloc(strlen(translations1) + strlen(translations2) + 1);
  strcpy(tm_table, translations1);
  strcat(tm_table, translations2);
  bitmapClassRec.core_class.tm_table = tm_table;

  XawInitializeWidgetSet();
  XtAddConverter(XtRString, XtRButtonFunction, CvtStringToButtonFunction,
		 NULL, 0);
  DEBUG = False;
}

static void
SetSizeFromSizeResource(BitmapWidget bw)
{
  if (BWParseSize(bw->bitmap.size,
		  &bw->bitmap.width,
		  &bw->bitmap.height)
      ==
      False) {
    bw->bitmap.width = FallbackBitmapWidth;
    bw->bitmap.height = FallbackBitmapHeight;
    XtWarning("Cannot parse the size resource.  BitmapWidget");
  }
}


/* ARGSUSED */
static void
Initialize(Widget wrequest, Widget wnew, ArgList argv, Cardinal *argc)
{
    BitmapWidget new = (BitmapWidget) wnew;

    XGCValues  values;
    XtGCMask   mask;
    char *image_data, *buffer_data;

    new->bitmap.stipple_change_expose_event = False;
    new->bitmap.notify = NULL;
    new->bitmap.cardinal = 0;
    new->bitmap.current = 0;
    new->bitmap.fold = False;
    new->bitmap.changed = False;
    new->bitmap.zooming = False;
    new->bitmap.selection.own = False;
    new->bitmap.selection.limbo = False;

    new->bitmap.request_stack = (BWRequestStack *)
	XtMalloc(sizeof(BWRequestStack));

    new->bitmap.request_stack[0].request = NULL;
    new->bitmap.request_stack[0].call_data = NULL;
    new->bitmap.request_stack[0].trap = False;

    SetSizeFromSizeResource(new);

    new->core.width = new->bitmap.width * new->bitmap.squareW +
	2 * new->bitmap.margin;
    new->core.height = new->bitmap.height * new->bitmap.squareH +
	2 * new->bitmap.margin;

    new->bitmap.hot.x = new->bitmap.hot.y = NotSet;
    new->bitmap.buffer_hot.x = new->bitmap.buffer_hot.y = NotSet;

    new->bitmap.mark.from_x = new->bitmap.mark.from_y = NotSet;
    new->bitmap.mark.to_x = new->bitmap.mark.to_y = NotSet;
    new->bitmap.buffer_mark.from_x = new->bitmap.buffer_mark.from_y = NotSet;
    new->bitmap.buffer_mark.to_x = new->bitmap.buffer_mark.to_y = NotSet;

    values.foreground = new->bitmap.foreground_pixel;
    values.background = new->core.background_pixel;
    values.foreground ^= values.background;
    values.function = GXxor;
    mask = GCForeground | GCBackground | GCFunction;
    new->bitmap.drawing_gc = XCreateGC(XtDisplay(new),
				       RootWindow(XtDisplay(new),
				       DefaultScreen(XtDisplay(new))),
				       mask, &values);

    values.foreground = new->bitmap.highlight_pixel;
    values.background = new->core.background_pixel;
    values.foreground ^= values.background;
    values.function = GXxor;
    mask = GCForeground | GCBackground | GCFunction;
    if (new->bitmap.stipple != XtUnspecifiedPixmap)
    {
	values.stipple = new->bitmap.stipple;
	mask |= GCStipple | GCFillStyle;
    }
    values.fill_style = (new->bitmap.stippled ? FillStippled : FillSolid);

    new->bitmap.highlighting_gc = XCreateGC(XtDisplay(new),
					    RootWindow(XtDisplay(new),
					       DefaultScreen(XtDisplay(new))),
					    mask, &values);


    values.foreground = new->bitmap.frame_pixel;
    values.background = new->core.background_pixel;
    values.foreground ^= values.background;
    mask = GCForeground | GCBackground | GCFunction;
    if (new->bitmap.dashes != XtUnspecifiedPixmap)
    {
	values.stipple = new->bitmap.dashes;
	mask |= GCStipple | GCFillStyle;
    }
    values.fill_style = (new->bitmap.dashed ? FillStippled : FillSolid);

    new->bitmap.frame_gc = XCreateGC(XtDisplay(new),
				     RootWindow(XtDisplay(new),
						DefaultScreen(XtDisplay(new))),
				     mask, &values);

    values.foreground = new->bitmap.highlight_pixel;
    values.background = new->core.background_pixel;
    values.foreground ^= values.background;
    mask = GCForeground | GCBackground | GCFunction;
    new->bitmap.axes_gc = XCreateGC(XtDisplay(new),
				     RootWindow(XtDisplay(new),
						DefaultScreen(XtDisplay(new))),
				     mask, &values);

    image_data = CreateCleanData(Length(new->bitmap.width,
					new->bitmap.height));
    buffer_data = CreateCleanData(Length(new->bitmap.width,
					 new->bitmap.height));

    new->bitmap.storage = NULL;

    new->bitmap.image = CreateBitmapImage(new,
					  image_data,
					  new->bitmap.width,
					  new->bitmap.height);
    new->bitmap.buffer = CreateBitmapImage(new,
					   buffer_data,
					   new->bitmap.width,
					   new->bitmap.height);

    /* Read file */
    {
	int status;
	XImage *image, *buffer;
	unsigned char *image_data2;
	char *buffer_data2;
	unsigned int width, height;
	int x_hot, y_hot;

	status = XmuReadBitmapDataFromFile(new->bitmap.filename,
					   &width, &height, &image_data2,
					   &x_hot, &y_hot);
	if (status == BitmapSuccess) {

	    buffer_data2 = CreateCleanData(Length(width, height));

	    image = CreateBitmapImage(new, (char *)image_data2, width, height);
	    buffer = CreateBitmapImage(new, buffer_data2, width, height);

	    TransferImageData(new->bitmap.image, buffer);

	    DestroyBitmapImage(&new->bitmap.image);
	    DestroyBitmapImage(&new->bitmap.buffer);

	    new->bitmap.image = image;
	    new->bitmap.buffer = buffer;
	    new->bitmap.width = width;
	    new->bitmap.height = height;

	    new->bitmap.hot.x = x_hot;
	    new->bitmap.hot.y = y_hot;

	    new->bitmap.changed = False;
	    new->bitmap.zooming = False;
	}

	new->bitmap.filename = XtNewString(new->bitmap.filename);

	if (!strcmp(new->bitmap.basename, "")) {
	    new->bitmap.basename = StripFilename(new->bitmap.filename);
	}
	else
	  new->bitmap.basename = XtNewString(new->bitmap.basename);
    }

    Resize((Widget)new);
}


/* returns False if the format is wrong */
Boolean
BWParseSize(String size, Dimension *width, Dimension *height)
{
  int x, y;
  unsigned int w, h;
  int status;

  status = XParseGeometry(size, &x, &y, &w, &h);

  if (status & (WidthValue | HeightValue)) {
    *width = (Dimension) w;
    *height = (Dimension) h;
    return True;
  }
  else return False;

}


Boolean
BWQueryMarked(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    return QuerySet(BW->bitmap.mark.from_x, BW->bitmap.mark.from_y);
}

static void
FixMark(BitmapWidget BW)
{
    if (QuerySet(BW->bitmap.mark.from_x, BW->bitmap.mark.from_y)) {
	BW->bitmap.mark.from_x = min(BW->bitmap.mark.from_x,
				     BW->bitmap.image->width);
	BW->bitmap.mark.from_y = min(BW->bitmap.mark.from_y,
				     BW->bitmap.image->height);
	BW->bitmap.mark.to_x = min(BW->bitmap.mark.to_x,
				   BW->bitmap.image->width);
	BW->bitmap.mark.to_y = min(BW->bitmap.mark.to_y,
				   BW->bitmap.image->height);

	if((BW->bitmap.mark.from_x == BW->bitmap.mark.from_y) &&
	   (BW->bitmap.mark.to_x   == BW->bitmap.mark.to_y))
	    BW->bitmap.mark.from_x =
		BW->bitmap.mark.from_y =
		    BW->bitmap.mark.to_x =
			BW->bitmap.mark.to_y = NotSet;
    }
}

/* ARGSUSED */
int
BWStoreFile(Widget w, _Xconst _XtString filename, _Xconst _XtString *basename)
{
    BitmapWidget BW = (BitmapWidget) w;
    int status;
    unsigned char *storage_data;
    unsigned int width, height;
    int x_hot, y_hot;

    status = XmuReadBitmapDataFromFile(filename, &width, &height,
				       &storage_data, &x_hot, &y_hot);
    if (status == BitmapSuccess) {

	DestroyBitmapImage(&BW->bitmap.storage);

	BW->bitmap.storage = CreateBitmapImage(BW, (char *)storage_data, width, height);

	return BitmapSuccess;
    }
    else
	XtWarning(" read file failed.  BitmapWidget");

    return status;
}

String
BWUnparseStatus(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    snprintf(BW->bitmap.status, sizeof(BW->bitmap.status),
	    "Filename: %s  Basename: %s  Size: %dx%d",
	    (strcmp(BW->bitmap.filename, "") ? BW->bitmap.filename : "<none>"),
	    (strcmp(BW->bitmap.basename, "") ? BW->bitmap.basename : "<none>"),
	    BW->bitmap.width, BW->bitmap.height);

    return BW->bitmap.status;
}

void
BWChangeFilename(Widget w, _Xconst _XtString str)
{
  BitmapWidget BW = (BitmapWidget) w;

  if (str) {
    XtFree(BW->bitmap.filename);
    BW->bitmap.filename = XtNewString( str);
  }
}

void
BWChangeBasename(Widget w, _Xconst _XtString str)
{
  BitmapWidget BW = (BitmapWidget) w;

  if (str) {
    XtFree(BW->bitmap.basename);
    BW->bitmap.basename = XtNewString(str);
  }
}


int
BWReadFile(Widget w, _Xconst _XtString filename, _Xconst _XtString basename) /* ARGSUSED */
{
    BitmapWidget BW = (BitmapWidget) w;
    int status;
    XImage *image, *buffer;
    unsigned char *image_data;
    char *buffer_data;
    unsigned int width, height;
    int x_hot, y_hot;

    if (!filename)
	filename = BW->bitmap.filename;

    status = XmuReadBitmapDataFromFile(filename, &width, &height, &image_data,
				       &x_hot, &y_hot);
    if (status == BitmapSuccess) {

	buffer_data = CreateCleanData(Length(width, height));

	image = CreateBitmapImage(BW, (char *)image_data, width, height);
	buffer = CreateBitmapImage(BW, buffer_data, width, height);

	TransferImageData(BW->bitmap.image, buffer);

	DestroyBitmapImage(&BW->bitmap.image);
	DestroyBitmapImage(&BW->bitmap.buffer);

	BW->bitmap.image = image;
	BW->bitmap.buffer = buffer;
	BW->bitmap.width = width;
	BW->bitmap.height = height;

	BW->bitmap.hot.x = x_hot;
	BW->bitmap.hot.y = y_hot;

	BW->bitmap.changed = False;
	BW->bitmap.zooming = False;

	XtFree(BW->bitmap.filename);
	BW->bitmap.filename = XtNewString(filename);
	XtFree(BW->bitmap.basename);
	BW->bitmap.basename = StripFilename(filename);

	BWUnmark(w);

	Resize((Widget)BW);

	if (BW->core.visible) {
	    XClearArea(XtDisplay(BW), XtWindow(BW),
		       0, 0,
		       BW->core.width, BW->core.height,
		       True);
	}

	return BitmapSuccess;
    }
    else
	XtWarning(" read file failed.  BitmapWidget");

    return status;
}

#if 0
void
BWSetImage(Widget w, XImage *image)
{
    BitmapWidget BW = (BitmapWidget) w;
    XImage *buffer;
    char *buffer_data;

    buffer_data = CreateCleanData(Length(image->width, image->height));
    buffer = CreateBitmapImage(BW, buffer_data,
			       (Dimension) image->width,
			       (Dimension) image->height);

    TransferImageData(BW->bitmap.image, buffer);

    DestroyBitmapImage(&BW->bitmap.image);
    DestroyBitmapImage(&BW->bitmap.buffer);

    BW->bitmap.image = image;
    BW->bitmap.buffer = buffer;
    BW->bitmap.width = image->width;
    BW->bitmap.height = image->height;

    Resize((Widget)BW);

    if (BW->core.visible) {
	XClearArea(XtDisplay(BW), XtWindow(BW),
		   0, 0,
		   BW->core.width, BW->core.height,
		   True);
    }
}
#endif

int
BWWriteFile(Widget w, _Xconst _XtString filename, _Xconst _XtString basename)
{
    BitmapWidget BW = (BitmapWidget) w;
    char *data;
    XImage *image;
    XPoint hot;
    int status;

    if (BW->bitmap.zooming) {
        data = XtMalloc(Length(BW->bitmap.zoom.image->width,
			       BW->bitmap.zoom.image->height));
	memmove( data, BW->bitmap.zoom.image->data,
	      Length(BW->bitmap.zoom.image->width,
		     BW->bitmap.zoom.image->height));
	image = CreateBitmapImage(BW, data,
				  (Dimension) BW->bitmap.zoom.image->width,
				  (Dimension) BW->bitmap.zoom.image->height);
	CopyImageData(BW->bitmap.image, image,
		      0, 0,
		      BW->bitmap.image->width - 1,
		      BW->bitmap.image->height - 1,
		      BW->bitmap.zoom.at_x, BW->bitmap.zoom.at_y);

	if (QuerySet(BW->bitmap.hot.x, BW->bitmap.hot.y)) {
	    hot.x = BW->bitmap.hot.x + BW->bitmap.zoom.at_x;
	    hot.y = BW->bitmap.hot.y + BW->bitmap.zoom.at_y;
	}
	else
	    hot = BW->bitmap.zoom.hot;
    }
    else {
	image = BW->bitmap.image;
	hot = BW->bitmap.hot;
    }

    if (!filename) filename = BW->bitmap.filename;
    else {
	XtFree(BW->bitmap.filename);
	BW->bitmap.filename = XtNewString(filename);
	XtFree(BW->bitmap.basename);
	BW->bitmap.basename = StripFilename(filename);
    }
    if (!basename) basename = BW->bitmap.basename;
    else {
	XtFree(BW->bitmap.basename);
	BW->bitmap.basename = XtNewString(basename);
    }

    if (DEBUG)
	fprintf(stderr, "Saving filename: %s %s\n", filename, basename);

    status = XmuWriteBitmapDataToFile(filename, basename,
				      image->width, image->height, image->data,
				      hot.x, hot.y);
    if (BW->bitmap.zooming)
	DestroyBitmapImage(&image);

    if (status == BitmapSuccess)
	BW->bitmap.changed = False;

    return status;
}

String
BWGetFilename(Widget w, String *str)
{
    BitmapWidget BW = (BitmapWidget) w;

    *str = XtNewString(BW->bitmap.filename);

    return *str;
}

String
BWGetFilepath(Widget w, String *str)
{
    BitmapWidget BW = (BitmapWidget) w;
    String end;

    *str = XtNewString(BW->bitmap.filename);
    assert(*str);

    end = strrchr(*str, '/');

    if (end)
	*(end + 1) = '\0';
    else
	**str = '\0';

    return *str;
}


String
BWGetBasename(Widget w, String *str)
{
    BitmapWidget BW = (BitmapWidget) w;

    *str = XtNewString(BW->bitmap.basename);

    return *str;
}

static void
FixHotSpot(BitmapWidget BW)
{
    if (!QueryInBitmap(BW, BW->bitmap.hot.x, BW->bitmap.hot.y))
	BW->bitmap.hot.x = BW->bitmap.hot.y = NotSet;
}

static void
ZoomOut(BitmapWidget BW)
{
    CopyImageData(BW->bitmap.image, BW->bitmap.zoom.image,
		  0, 0,
		  BW->bitmap.image->width - 1,
		  BW->bitmap.image->height - 1,
		  BW->bitmap.zoom.at_x, BW->bitmap.zoom.at_y);

    DestroyBitmapImage(&BW->bitmap.image);
    DestroyBitmapImage(&BW->bitmap.buffer);

    BW->bitmap.image = BW->bitmap.zoom.image;
    BW->bitmap.buffer = BW->bitmap.zoom.buffer;
    BW->bitmap.width = BW->bitmap.image->width;
    BW->bitmap.height = BW->bitmap.image->height;
    BW->bitmap.fold = BW->bitmap.zoom.fold;
    BW->bitmap.changed |= BW->bitmap.zoom.changed;
    BW->bitmap.grid = BW->bitmap.zoom.grid;

    if (QuerySet(BW->bitmap.hot.x, BW->bitmap.hot.y)) {
	BW->bitmap.hot.x += BW->bitmap.zoom.at_x;
	BW->bitmap.hot.y += BW->bitmap.zoom.at_y;
    }
    else
	BW->bitmap.hot = BW->bitmap.zoom.hot;

    BW->bitmap.mark.from_x = NotSet;
    BW->bitmap.mark.from_y = NotSet;
    BW->bitmap.mark.to_x = NotSet;
    BW->bitmap.mark.to_y = NotSet;
    BW->bitmap.zooming = False;
}

void
BWZoomOut(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    if (BW->bitmap.zooming) {
	ZoomOut(BW);

	Resize((Widget)BW);
	if (BW->core.visible)
	    XClearArea(XtDisplay(BW), XtWindow(BW),
		       0, 0,
		       BW->core.width, BW->core.height,
		       True);
    }
}


void
BWZoomMarked(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    BWZoomIn(w,
	     BW->bitmap.mark.from_x, BW->bitmap.mark.from_y,
	     BW->bitmap.mark.to_x,   BW->bitmap.mark.to_y);
}

void
BWZoomIn(Widget w,
	 Position from_x, Position from_y,
	 Position to_x, Position to_y)
{
    BitmapWidget BW = (BitmapWidget) w;
    XImage *image, *buffer;
    Dimension width, height;
    char *image_data, *buffer_data;

    if (BW->bitmap.zooming)
	ZoomOut(BW);

    QuerySwap(from_x, to_x);
    QuerySwap(from_y, to_y);
    from_x = max(0, from_x);
    from_y = max(0, from_y);
    to_x = min(BW->bitmap.width - 1, to_x);
    to_y = min(BW->bitmap.height - 1, to_y);

    width = to_x - from_x + 1;
    height = to_y - from_y + 1;

    image_data = CreateCleanData(Length(width, height));
    buffer_data = CreateCleanData(Length(width, height));

    image = CreateBitmapImage(BW, image_data, width, height);
    buffer = CreateBitmapImage(BW, buffer_data, width, height);

    CopyImageData(BW->bitmap.image, image, from_x, from_y, to_x, to_y, 0, 0);
    CopyImageData(BW->bitmap.buffer, buffer, from_x, from_y, to_x, to_y, 0, 0);

    BW->bitmap.zoom.image = BW->bitmap.image;
    BW->bitmap.zoom.buffer = BW->bitmap.buffer;
    BW->bitmap.zoom.at_x = from_x;
    BW->bitmap.zoom.at_y = from_y;
    BW->bitmap.zoom.fold = BW->bitmap.fold;
    BW->bitmap.zoom.changed = BW->bitmap.changed;
    BW->bitmap.zoom.hot = BW->bitmap.hot;
    BW->bitmap.zoom.grid = BW->bitmap.grid;

    BW->bitmap.image = image;
    BW->bitmap.buffer = buffer;
    BW->bitmap.width = width;
    BW->bitmap.height = height;
    BW->bitmap.changed = False;
    BW->bitmap.hot.x -= from_x;
    BW->bitmap.hot.y -= from_y;
    BW->bitmap.mark.from_x = NotSet;
    BW->bitmap.mark.from_y = NotSet;
    BW->bitmap.mark.to_x = NotSet;
    BW->bitmap.mark.to_y = NotSet;
    BW->bitmap.zooming = True;
    BW->bitmap.grid = True; /* potencially true, could use a resource here */

    FixHotSpot(BW);

    Resize((Widget)BW);
    if (BW->core.visible)
	XClearArea(XtDisplay(BW), XtWindow(BW),
		   0, 0,
		   BW->core.width, BW->core.height,
		   True);
}


void
BWRescale(Widget w, Dimension width, Dimension height)
{
    BitmapWidget BW = (BitmapWidget) w;
    XImage *image, *buffer;
    char *buffer_data;

    if (BW->bitmap.zooming)
	ZoomOut(BW);

    image = ScaleBitmapImage(BW, BW->bitmap.image,
		       (double) width / (double) BW->bitmap.image->width,
		       (double) height / (double) BW->bitmap.image->height);

    buffer_data = CreateCleanData(Length(image->width, image->height));
    buffer = CreateBitmapImage(BW, buffer_data,
			       (Dimension) image->width,
			       (Dimension) image->height);

    TransferImageData(BW->bitmap.buffer, buffer);

    DestroyBitmapImage(&BW->bitmap.image);
    DestroyBitmapImage(&BW->bitmap.buffer);

    BW->bitmap.image = image;
    BW->bitmap.buffer = buffer;
    BW->bitmap.width = image->width;
    BW->bitmap.height = image->height;

    FixHotSpot(BW);
    FixMark(BW);

    Resize((Widget)BW);
    if (BW->core.visible)
	XClearArea(XtDisplay(BW), XtWindow(BW),
		   0, 0,
		   BW->core.width, BW->core.height,
		   True);
}

Boolean
BWQueryZooming(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    return BW->bitmap.zooming;
}


static void
ResizeGrid(BitmapWidget BW, Dimension width, Dimension height)
{
  XImage *image, *buffer;
  char *image_data, *buffer_data;

  if (BW->bitmap.zooming)
    ZoomOut(BW);

  image_data = CreateCleanData(Length(width, height));
  buffer_data = CreateCleanData(Length(width, height));

  image = CreateBitmapImage(BW, image_data, width, height);
  buffer = CreateBitmapImage(BW, buffer_data, width, height);

  TransferImageData(BW->bitmap.image, image);
  TransferImageData(BW->bitmap.buffer, buffer);

  DestroyBitmapImage(&BW->bitmap.image);
  DestroyBitmapImage(&BW->bitmap.buffer);

  BW->bitmap.image = image;
  BW->bitmap.buffer = buffer;
  BW->bitmap.width = width;
  BW->bitmap.height = height;

  FixHotSpot(BW);
  FixMark(BW);
}

void
BWResize(Widget w, Dimension width, Dimension height)
{
    BitmapWidget BW = (BitmapWidget) w;

    ResizeGrid(BW, width, height);

    Resize((Widget)BW);
    if (BW->core.visible)
	XClearArea(XtDisplay(BW), XtWindow(BW),
		   0, 0,
		   BW->core.width, BW->core.height,
		   True);
}

static void
Destroy(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    XFreeGC(XtDisplay(w), BW->bitmap.drawing_gc);
    XFreeGC(XtDisplay(w), BW->bitmap.highlighting_gc);
    XFreeGC(XtDisplay(w), BW->bitmap.frame_gc);
    XFreeGC(XtDisplay(w), BW->bitmap.axes_gc);
    BWRemoveAllRequests(w);

    XtFree(BW->bitmap.filename);
    XtFree(BW->bitmap.basename);
}


static void
Resize(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    Dimension squareW, squareH;

    squareW = max(1, ((int)BW->core.width - 2 * (int)BW->bitmap.margin) /
		  (int)BW->bitmap.width);
    squareH = max(1, ((int)BW->core.height - 2 * (int)BW->bitmap.margin) /
		  (int)BW->bitmap.height);

    if (BW->bitmap.proportional)
	BW->bitmap.squareW = BW->bitmap.squareH = min(squareW, squareH);
    else {
	BW->bitmap.squareW = squareW;
	BW->bitmap.squareH = squareH;
    }

    BW->bitmap.horizOffset = max((Position)BW->bitmap.margin,
				 (Position)(BW->core.width -
					    BW->bitmap.width *
					    BW->bitmap.squareW) / 2);
    BW->bitmap.vertOffset = max((Position)BW->bitmap.margin,
				(Position)(BW->core.height -
					   BW->bitmap.height *
					   BW->bitmap.squareH) / 2);

    BW->bitmap.grid &= ((BW->bitmap.squareW > BW->bitmap.grid_tolerance) &&
			(BW->bitmap.squareH > BW->bitmap.grid_tolerance));
}

/* ARGSUSED */
static void
Redisplay(Widget w, XEvent *event, Region region)
{
     BitmapWidget BW = (BitmapWidget) w;

  if(event->type == Expose
     &&
     BW->core.visible)
    if (BW->bitmap.stipple_change_expose_event == False)
      Refresh(BW,
	      event->xexpose.x, event->xexpose.y,
	      event->xexpose.width, event->xexpose.height);
}

void
BWClip(Widget w, Position x, Position y, Dimension width, Dimension height)
{
    Position      from_x, from_y,
                  to_x, to_y;
    BitmapWidget BW = (BitmapWidget) w;
    XRectangle rectangle;

    from_x = InBitmapX(BW, x);
    from_y = InBitmapY(BW, y);
    to_x = InBitmapX(BW, x + width);
    to_y = InBitmapY(BW, y + height);
    QuerySwap(from_x, to_x);
    QuerySwap(from_y, to_y);
    from_x = max(0, from_x);
    from_y = max(0, from_y);
    to_x = min(BW->bitmap.width - 1, to_x);
    to_y = min(BW->bitmap.height - 1, to_y);

    rectangle.x = InWindowX(BW, from_x);
    rectangle.y = InWindowY(BW, from_y);
    rectangle.width = InWindowX(BW, to_x  + 1) - InWindowX(BW, from_x);
    rectangle.height = InWindowY(BW, to_y + 1) - InWindowY(BW, from_y);
    XSetClipRectangles(XtDisplay(BW),
		       BW->bitmap.highlighting_gc,
		       0, 0,
		       &rectangle, 1,
		       Unsorted);
    XSetClipRectangles(XtDisplay(BW),
		       BW->bitmap.drawing_gc,
		       0, 0,
		       &rectangle, 1,
		       Unsorted);
    XSetClipRectangles(XtDisplay(BW),
		       BW->bitmap.frame_gc,
		       0, 0,
		       &rectangle, 1,
		       Unsorted);
    XSetClipRectangles(XtDisplay(BW),
		       BW->bitmap.axes_gc,
		       0, 0,
		       &rectangle, 1,
		       Unsorted);
}

void
BWUnclip(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;
    XRectangle rectangle;

    rectangle.x = InWindowX(BW, 0);
    rectangle.y = InWindowY(BW, 0);
    rectangle.width = InWindowX(BW, BW->bitmap.width) - InWindowX(BW, 0);
    rectangle.height = InWindowY(BW, BW->bitmap.height) - InWindowY(BW, 0);
    XSetClipRectangles(XtDisplay(BW),
		       BW->bitmap.highlighting_gc,
		       0, 0,
		       &rectangle, 1,
		       Unsorted);
    XSetClipRectangles(XtDisplay(BW),
		       BW->bitmap.drawing_gc,
		       0, 0,
		       &rectangle, 1,
		       Unsorted);
    XSetClipRectangles(XtDisplay(BW),
		       BW->bitmap.frame_gc,
		       0, 0,
		       &rectangle, 1,
		       Unsorted);
    XSetClipRectangles(XtDisplay(BW),
		       BW->bitmap.axes_gc,
		       0, 0,
		       &rectangle, 1,
		       Unsorted);
}

static void
Refresh(BitmapWidget BW, Position x, Position y,
	Dimension width, Dimension height)
{
    XRectangle rectangle;

    rectangle.x = min(x, InWindowX(BW, InBitmapX(BW, x)));
    rectangle.y = min(y, InWindowY(BW, InBitmapY(BW, y)));
    rectangle.width = max(x + width,
		     InWindowX(BW, InBitmapX(BW, x + width)+1)) - rectangle.x;
    rectangle.height = max(y + height,
		     InWindowY(BW, InBitmapY(BW, y + height)+1)) - rectangle.y;

    XClearArea(XtDisplay(BW), XtWindow(BW),
	       rectangle.x, rectangle.y,
	       rectangle.width, rectangle.height,
	       False);

    XSetClipRectangles(XtDisplay(BW),
		       BW->bitmap.frame_gc,
		       0, 0,
		       &rectangle, 1,
		       Unsorted);

    XDrawRectangle(XtDisplay(BW), XtWindow(BW),
		   BW->bitmap.frame_gc,
		   InWindowX(BW, 0) - 1, InWindowY(BW, 0) - 1,
		   InWindowX(BW, BW->bitmap.width) - InWindowX(BW, 0) + 1,
		   InWindowY(BW, BW->bitmap.height) - InWindowY(BW, 0) + 1);

    BWClip((Widget) BW, x, y, width, height);

    BWRedrawGrid((Widget) BW, x, y, width, height);

    BWRedrawSquares((Widget) BW, x, y, width, height);

    BWRedrawMark((Widget) BW);
    BWRedrawHotSpot((Widget) BW);
    BWRedrawAxes((Widget) BW);
    BWUnclip((Widget) BW);
}

Boolean
BWQueryGrid(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    return BW->bitmap.grid;
}

void
BWSwitchGrid(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;
    BW->bitmap.grid ^= TRUE;
    BWDrawGrid(w,
	       0, 0,
	       BW->bitmap.image->width - 1, BW->bitmap.image->height - 1);
}

void
BWGrid(Widget w, Boolean _switch)
{
    BitmapWidget BW = (BitmapWidget) w;

    if (BW->bitmap.grid != _switch)
	BWSwitchGrid(w);
}

Boolean
BWQueryDashed(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    return (BW->bitmap.dashed);
}

void
BWSwitchDashed(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;
    XRectangle rectangle;

    BWRedrawGrid(w, 0, 0, BW->bitmap.width - 1, BW->bitmap.height - 1);

    rectangle.x = 0;
    rectangle.y = 0;
    rectangle.width = BW->core.width;
    rectangle.height = BW->core.height;

    XSetClipRectangles(XtDisplay(BW),
		       BW->bitmap.frame_gc,
		       0, 0,
		       &rectangle, 1,
		       Unsorted);

    XDrawRectangle(XtDisplay(BW), XtWindow(BW),
		   BW->bitmap.frame_gc,
		   InWindowX(BW, 0) - 1, InWindowY(BW, 0) - 1,
		   InWindowX(BW, BW->bitmap.width) - InWindowX(BW, 0) + 1,
		   InWindowY(BW, BW->bitmap.height) - InWindowY(BW, 0) + 1);

    BW->bitmap.dashed ^= True;
    XSetFillStyle(XtDisplay(BW), BW->bitmap.frame_gc,
		  (BW->bitmap.dashed ? FillStippled : FillSolid));

    XDrawRectangle(XtDisplay(BW), XtWindow(BW),
		   BW->bitmap.frame_gc,
		   InWindowX(BW, 0) - 1, InWindowY(BW, 0) - 1,
		   InWindowX(BW, BW->bitmap.width) - InWindowX(BW, 0) + 1,
		   InWindowY(BW, BW->bitmap.height) - InWindowY(BW, 0) + 1);

    BWUnclip(w);

    BWRedrawGrid(w, 0, 0, BW->bitmap.width - 1, BW->bitmap.height - 1);
}

void
BWDashed(Widget w, Boolean _switch)
{
    BitmapWidget BW = (BitmapWidget) w;

    if (BW->bitmap.dashed != _switch)
	BWSwitchDashed(w);
}

static Boolean
SetValues(Widget old, Widget request, Widget new,
	  ArgList args, Cardinal *num_args) /* ARGSUSED */
{
  BitmapWidget oldbw = (BitmapWidget) old;
  BitmapWidget newbw = (BitmapWidget) new;
  Boolean resize = False;
  Boolean redisplay = False;

#define NE(field) (oldbw->field != newbw->field)

  if (NE(bitmap.grid))
    BWSwitchGrid(old);

  if (NE(bitmap.dashed))
    BWSwitchDashed(old);

  if (NE(bitmap.axes))
    BWSwitchAxes(old);

  if (NE(bitmap.stippled))
    BWSwitchStippled(old);

  if (NE(bitmap.proportional))
    resize = True;

  if (NE(bitmap.filename) || NE(bitmap.basename)  || NE(bitmap.size))
    BWChangeNotify(old);

  if (NE(bitmap.filename)) {
    if (newbw->bitmap.filename) {
      XtFree(oldbw->bitmap.filename);
      newbw->bitmap.filename = XtNewString(newbw->bitmap.filename);
    }
    else
      newbw->bitmap.filename = oldbw->bitmap.filename;
  }

  if (NE(bitmap.basename)) {
    if (newbw->bitmap.basename) {
      XtFree(oldbw->bitmap.basename);
      newbw->bitmap.basename = XtNewString(newbw->bitmap.basename);
    }
    else
      newbw->bitmap.basename = oldbw->bitmap.basename;
  }

  if (NE(bitmap.size)) {
    Dimension width, height;

    if (BWParseSize(newbw->bitmap.size, &width, &height)) {
      ResizeGrid(newbw, width, height);
      resize = True;
    }
  }

  if (NE(bitmap.margin) ||
      NE(bitmap.grid_tolerance) ||
      NE(bitmap.squareW) ||
      NE(bitmap.squareH) ||
      NE(core.height) ||
      NE(core.width))
    resize = True;

  if (NE(bitmap.hot.x) || NE(bitmap.hot.y))
    BWSetHotSpot(old, newbw->bitmap.hot.x, newbw->bitmap.hot.y);

  if (NE(bitmap.foreground_pixel) || NE(core.background_pixel)) {
    XSetForeground(XtDisplay(new),
		   newbw->bitmap.drawing_gc,
		   newbw->bitmap.foreground_pixel
		   ^
		   newbw->core.background_pixel);
    redisplay = True;
  }

  if (NE(bitmap.frame_pixel) || NE(core.background_pixel)) {
    XSetForeground(XtDisplay(new),
		   newbw->bitmap.frame_gc,
		   newbw->bitmap.frame_pixel
		   ^
		   newbw->core.background_pixel);
    redisplay = True;
  }

  if (NE(bitmap.dashes)) {
    XSetStipple(XtDisplay(new),
		newbw->bitmap.frame_gc,
		newbw->bitmap.dashes);
    redisplay = True;
  }

  if (NE(bitmap.highlight_pixel) || NE(core.background_pixel)) {
    RedrawStippled(newbw);
    XSetForeground(XtDisplay(new),
		   newbw->bitmap.highlighting_gc,
		   newbw->bitmap.highlight_pixel
		   ^
		   newbw->core.background_pixel);
    RedrawStippled(newbw);
  }

  if (NE(bitmap.stipple)) {
    RedrawStippled(newbw);
    XSetStipple(XtDisplay(new),
		newbw->bitmap.highlighting_gc,
		newbw->bitmap.stipple);
    RedrawStippled(newbw);
  }

  if (resize) Resize((Widget)newbw);

    return (redisplay || resize);

#undef NE
}

Boolean
BWQueryProportional(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    return (BW->bitmap.proportional);
}

void
BWSwitchProportional(Widget w)
{
    BitmapWidget BW = (BitmapWidget) w;

    BW->bitmap.proportional ^= True;

    Resize((Widget)BW);
    if (BW->core.visible)
	XClearArea(XtDisplay(BW), XtWindow(BW),
		   0, 0,
		   BW->core.width, BW->core.height,
		   True);
}

#if 0
void
BWProportional(Widget w, Boolean _switch)
{
    BitmapWidget BW = (BitmapWidget) w;

    if (BW->bitmap.proportional != _switch)
	BWSwitchProportional(w);
}
#endif

void
BWTPaste(Widget w, XEvent *event, String *params, Cardinal *num_params)
{
    BitmapWidget BW = (BitmapWidget) w;

    BWRequestSelection(w, event->xbutton.time, TRUE);

    if (!BWQueryStored(w))
	return;

    BWEngageRequest(w, RestoreRequest, False,
		    (char *)&(event->xbutton.state), sizeof(int));

    OnePointHandler(w,
	       (BWStatus*) BW->bitmap.request_stack[BW->bitmap.current].status,
	       event, NULL);
}

void
BWTMark(Widget w, XEvent *event, String *params, Cardinal *num_params)
{
    BitmapWidget BW = (BitmapWidget) w;

    BWEngageRequest(w, MarkRequest, False,
		    (char *)&(event->xbutton.state), sizeof(int));
    TwoPointsHandler(w,
            (BWStatus*) BW->bitmap.request_stack[BW->bitmap.current].status,
	     event, NULL);

}

void
BWTMarkAll(Widget w, XEvent *event, String *params, Cardinal *num_params)
{
    BWMarkAll(w);

    BWGrabSelection(w, event->xkey.time);
}

void
BWTUnmark(Widget w, XEvent *event, String *params, Cardinal *num_params)
{
    BWUnmark(w);
}

/*****************************************************************************/
@


1.4
log
@Update to bitmap 1.0.7
@
text
@d44 1
d690 7
a696 2
    if (!basename || !strcmp(basename, "") || !strcmp(basename, "-"))
	basename = StripFilename(filename);
a697 1
    if (file) {
d716 1
d911 2
a912 2
	unsigned char *image_data;
	char *buffer_data;
d917 1
a917 1
					   &width, &height, &image_data,
d921 1
a921 1
	    buffer_data = CreateCleanData(Length(width, height));
d923 2
a924 2
	    image = CreateBitmapImage(new, (char *)image_data, width, height);
	    buffer = CreateBitmapImage(new, buffer_data, width, height);
d1111 1
a1111 1
	BW->bitmap.basename= XtNewString(StripFilename(filename));
d1207 1
a1207 1
	BW->bitmap.basename= XtNewString(StripFilename(filename));
d1247 2
@


1.3
log
@Update to bitmap 1.0.6
@
text
@d392 2
a393 1
			     (unsigned long) 0, (XGCValues *) 0)))
d395 1
d415 2
a416 1
			      (unsigned long) 0, (XGCValues *) 0)))
d418 1
@


1.2
log
@Update to bitmap 1.0.4
@
text
@a37 1
#include <X11/Xmu/SysUtil.h>
d43 1
a43 1
    
d237 1
a237 1
static BWRequestRec requests[] = 
d271 2
a272 2
{LineRequest, sizeof(BWStatus), 
     TwoPointsEngage, (XtPointer) BWDrawLine, 
d275 1
a275 1
{RectangleRequest, sizeof(BWStatus), 
d279 1
a279 1
{FilledRectangleRequest, sizeof(BWStatus), 
d283 1
a283 1
{CircleRequest, sizeof(BWStatus), 
d287 2
a288 2
{FilledCircleRequest, sizeof(BWStatus), 
     TwoPointsEngage, (XtPointer) BWDrawCircle, 
d306 1
a306 1
static void Initialize(Widget wrequest, Widget wnew, 
d311 1
a311 1
static void Refresh(BitmapWidget BW, Position x, Position y, 
d315 1
a315 1
 
d351 1
a351 1
  { 
d361 1
a361 1
 
d363 1
a363 1
    
d366 1
a366 1
void 
d372 2
a373 2
Pixmap 
BWGetPixmap(Widget w) 
d376 1
a376 1
 
d380 1
a380 1
Pixmap 
d386 4
a389 4
    
    if (BW->bitmap.zooming) {    
	pix = XCreatePixmap(XtDisplay(w), XtWindow(w), 
			    BW->bitmap.zoom.image->width, 
d391 1
a391 1
	if (!(gc = XCreateGC(XtDisplay(w), pix, 
d394 5
a398 5
	
	XPutImage(XtDisplay(w), pix, gc, 
		  BW->bitmap.zoom.image, 
		  0, 0, 0, 0, 
		  BW->bitmap.zoom.image->width, 
d400 3
a402 3
	XPutImage(XtDisplay(w), pix, gc, 
		  BW->bitmap.image, 
		  0, 0, 
d405 1
a405 1
		  BW->bitmap.image->width, 
d409 2
a410 2
	pix = XCreatePixmap(XtDisplay(w), XtWindow(w), 
			    BW->bitmap.image->width, 
d412 1
a412 1
	if (! (gc = XCreateGC(XtDisplay(w), pix, 
d415 3
a417 3
	
	XPutImage(XtDisplay(w), pix, gc, 
		  BW->bitmap.image, 
d419 1
a419 1
		  BW->bitmap.image->width, 
d447 1
a447 1
CreateBitmapImage(BitmapWidget BW, char *data, 
d451 1
a451 1
				 DefaultVisual(XtDisplay(BW), 
d453 1
a453 1
				 1, XYBitmap, 0, 
d472 1
a472 1
void 
d496 1
a496 1
void 
d505 1
a505 1
void 
d513 1
a513 1
void 
d517 1
a517 1
	
d521 1
a521 1
Boolean 
d525 1
a525 1
	
d529 1
a529 1
void 
d533 1
a533 1
    
d537 1
a537 1
Boolean 
d541 1
a541 1
    
d545 1
a545 1
Boolean 
d553 1
a553 1
static void 
d557 1
a557 1
  
d566 1
a566 1
  
d568 3
a570 3
  
  BW->bitmap.stipple_change_expose_event = True; 
  
d572 1
a572 1
  
d576 1
a576 1
void 
d587 1
a587 1
    RedrawStippled(BW);    
d590 2
a591 2
void 
BWSelect(Widget w, Position from_x, Position from_y, 
d599 1
a599 1
Boolean 
d607 1
a607 1
void 
d616 1
a616 1
void 
d620 1
a620 1
    
d625 1
a625 1
void 
d629 1
a629 1
    
d635 2
a636 2
void 
BWPutImage(BitmapWidget w, Display *display, Drawable drawable, GC gc, 
d646 2
a647 2
static String 
StripFilename(String filename)
d649 3
a651 2
    char *begin = strrchr(filename, '/');
    char *end, *result;
d653 1
a653 1
    
d667 4
a670 3
static int 
XmuWriteBitmapDataToFile(String filename, String basename, 
			 int width, int height, char *datap, 
d675 1
a675 1
    
d677 2
a678 2
    
    if(!filename || !strcmp(filename, "") || !strcmp(filename, "-")) {   
d684 1
a684 1
    
d687 1
a687 1
    
d703 1
a703 1
	
d709 1
a709 1
    
d718 1
a718 1
static void 
d721 1
a721 1
			  XrmValuePtr from_val, 
d726 1
a726 1
 
d728 1
a728 1
  
d735 1
a735 1
  
d749 1
a749 1
  
d754 1
a754 1
  
d757 1
a757 1
static void 
d771 1
a771 1
static void 
d774 1
a774 1
  if (BWParseSize(bw->bitmap.size, 
d787 1
a787 1
static void 
d815 1
a815 1
    new->core.width = new->bitmap.width * new->bitmap.squareW + 
d817 1
a817 1
    new->core.height = new->bitmap.height * new->bitmap.squareH + 
d819 1
a819 1
  
d822 1
a822 1
  
d833 2
a834 2
    new->bitmap.drawing_gc = XCreateGC(XtDisplay(new), 
				       RootWindow(XtDisplay(new), 
d850 3
a852 3
    new->bitmap.highlighting_gc = XCreateGC(XtDisplay(new), 
					    RootWindow(XtDisplay(new), 
					       DefaultScreen(XtDisplay(new))), 
d867 2
a868 2
    new->bitmap.frame_gc = XCreateGC(XtDisplay(new), 
				     RootWindow(XtDisplay(new), 
d876 2
a877 2
    new->bitmap.axes_gc = XCreateGC(XtDisplay(new), 
				     RootWindow(XtDisplay(new), 
d881 1
a881 1
    image_data = CreateCleanData(Length(new->bitmap.width, 
d883 1
a883 1
    buffer_data = CreateCleanData(Length(new->bitmap.width, 
d887 2
a888 2
    
    new->bitmap.image = CreateBitmapImage(new, 
d892 1
a892 1
    new->bitmap.buffer = CreateBitmapImage(new, 
d905 2
a906 2
	
	status = XmuReadBitmapDataFromFile(new->bitmap.filename, 
d910 1
a910 1
	    
d912 1
a912 1
	    
d915 1
a915 1
	
d917 1
a917 1
	
d920 1
a920 1
	
d925 1
a925 1
	    
d928 1
a928 1
	    
d934 1
a934 1
	
d947 1
a947 1
Boolean 
d966 1
a966 1
Boolean 
d974 1
a974 1
static void 
d978 1
a978 1
	BW->bitmap.mark.from_x = min(BW->bitmap.mark.from_x, 
d980 1
a980 1
	BW->bitmap.mark.from_y = min(BW->bitmap.mark.from_y, 
d982 1
a982 1
	BW->bitmap.mark.to_x = min(BW->bitmap.mark.to_x, 
d984 1
a984 1
	BW->bitmap.mark.to_y = min(BW->bitmap.mark.to_y, 
d986 1
a986 1
	
d989 1
a989 1
	    BW->bitmap.mark.from_x = 
d991 1
a991 1
		    BW->bitmap.mark.to_x = 
d997 2
a998 2
int 
BWStoreFile(Widget w, String filename, String *basename)
d1005 1
a1005 1
    
d1011 1
a1011 1
	
d1018 1
a1018 1
    
d1022 1
a1022 1
String 
d1026 2
a1027 2
    
    XmuSnprintf(BW->bitmap.status, sizeof(BW->bitmap.status),
d1036 2
a1037 2
void 
BWChangeFilename(Widget w, String str)
d1040 1
a1040 1
  
d1047 2
a1048 2
void 
BWChangeBasename(Widget w, String str)
d1051 1
a1051 1
  
d1059 2
a1060 2
int 
BWReadFile(Widget w, String filename, String basename) /* ARGSUSED */
d1069 1
a1069 1
    
d1076 1
a1076 1
	
d1078 1
a1078 1
	
d1081 1
a1081 1
	
d1083 1
a1083 1
	
d1086 1
a1086 1
	
d1091 1
a1091 1
	
d1094 1
a1094 1
	
d1097 1
a1097 1
	
d1104 1
a1104 1
	
d1109 1
a1109 1
		       0, 0, 
d1113 1
a1113 1
	
d1118 1
a1118 1
    
d1123 1
a1123 1
void 
d1129 1
a1129 1
    
d1131 2
a1132 2
    buffer = CreateBitmapImage(BW, buffer_data, 
			       (Dimension) image->width, 
d1134 1
a1134 1
    
d1136 1
a1136 1
    
d1139 1
a1139 1
    
d1144 1
a1144 1
    
d1146 1
a1146 1
    
d1149 1
a1149 1
		   0, 0, 
d1151 1
a1151 1
		   True);    
d1156 2
a1157 2
int 
BWWriteFile(Widget w, String filename, String basename)
d1164 1
a1164 1
    
d1166 1
a1166 1
        data = XtMalloc(Length(BW->bitmap.zoom.image->width, 
d1168 2
a1169 2
	memmove( data, BW->bitmap.zoom.image->data, 
	      Length(BW->bitmap.zoom.image->width, 
d1174 2
a1175 2
	CopyImageData(BW->bitmap.image, image, 
		      0, 0, 
d1179 1
a1179 1
	
d1191 1
a1191 1
    
d1213 1
a1213 1
    
d1216 1
a1216 1
    
d1220 1
a1220 1
String 
d1224 1
a1224 1
    
d1230 1
a1230 1
String 
d1241 1
a1241 1
    else 
d1248 1
a1248 1
String 
d1252 1
a1252 1
    
d1258 1
a1258 1
static void 
d1265 1
a1265 1
static void 
d1268 2
a1269 2
    CopyImageData(BW->bitmap.image, BW->bitmap.zoom.image, 
		  0, 0, 
d1273 1
a1273 1
    
d1276 1
a1276 1
    
d1291 1
a1291 1
    
d1297 1
a1297 1
}    
d1299 1
a1299 1
void 
d1303 1
a1303 1
    
d1306 1
a1306 1
	
d1310 1
a1310 1
		       0, 0, 
d1317 1
a1317 1
void 
d1322 1
a1322 1
    BWZoomIn(w, 
d1327 3
a1329 3
void 
BWZoomIn(Widget w, 
	 Position from_x, Position from_y, 
d1333 1
a1333 1
    XImage *image, *buffer;    
d1336 1
a1336 1
  
d1339 1
a1339 1
    
d1346 1
a1346 1
    
d1358 1
a1358 1
    
d1387 1
a1387 1
		   0, 0, 
d1393 1
a1393 1
void 
d1402 2
a1403 2
        
    image = ScaleBitmapImage(BW, BW->bitmap.image, 
d1408 2
a1409 2
    buffer = CreateBitmapImage(BW, buffer_data, 
			       (Dimension) image->width, 
d1411 1
a1411 1
    
d1416 1
a1416 1
    
d1421 1
a1421 1
    
d1428 1
a1428 1
		   0, 0, 
d1433 1
a1433 1
Boolean 
d1442 1
a1442 1
static void 
d1447 1
a1447 1
  
d1450 1
a1450 1
  
d1453 1
a1453 1
  
d1456 1
a1456 1
  
d1459 1
a1459 1
  
d1462 1
a1462 1
  
d1467 1
a1467 1
  
d1472 1
a1472 1
void 
d1482 1
a1482 1
		   0, 0, 
d1487 1
a1487 1
static void 
d1503 1
a1503 1
static void 
d1510 1
a1510 1
    squareW = max(1, ((int)BW->core.width - 2 * (int)BW->bitmap.margin) / 
d1512 1
a1512 1
    squareH = max(1, ((int)BW->core.height - 2 * (int)BW->bitmap.margin) / 
d1521 4
a1524 4
    
    BW->bitmap.horizOffset = max((Position)BW->bitmap.margin, 
				 (Position)(BW->core.width - 
					    BW->bitmap.width * 
d1526 3
a1528 3
    BW->bitmap.vertOffset = max((Position)BW->bitmap.margin, 
				(Position)(BW->core.height - 
					   BW->bitmap.height * 
d1531 1
a1531 1
    BW->bitmap.grid &= ((BW->bitmap.squareW > BW->bitmap.grid_tolerance) && 
d1536 1
a1536 1
static void 
d1545 1
a1545 1
      Refresh(BW, 
d1550 1
a1550 1
void 
d1557 1
a1557 1
  
d1595 1
a1595 1
void 
d1600 1
a1600 1
  
d1627 2
a1628 2
static void 
Refresh(BitmapWidget BW, Position x, Position y, 
d1639 1
a1639 1
    
d1654 1
a1654 1
		   InWindowX(BW, BW->bitmap.width) - InWindowX(BW, 0) + 1, 
d1669 1
a1669 1
Boolean 
d1677 1
a1677 1
void 
d1687 1
a1687 1
void 
d1691 1
a1691 1
    
d1696 1
a1696 1
Boolean 
d1704 1
a1704 1
void 
d1726 1
a1726 1
		   InWindowX(BW, BW->bitmap.width) - InWindowX(BW, 0) + 1, 
d1728 1
a1728 1
    
d1732 1
a1732 1
 
d1736 1
a1736 1
		   InWindowX(BW, BW->bitmap.width) - InWindowX(BW, 0) + 1, 
d1740 1
a1740 1
   
d1744 1
a1744 1
void 
d1748 1
a1748 1
    
d1753 2
a1754 2
static Boolean 
SetValues(Widget old, Widget request, Widget new, 
d1787 1
a1787 1
    else 
d1796 1
a1796 1
    else 
d1799 1
a1799 1
  
d1802 2
a1803 2
    
    if (BWParseSize(newbw->bitmap.size, &width, &height)) { 
d1808 2
a1809 2
  
  if (NE(bitmap.margin) || 
d1819 1
a1819 1
    
d1821 1
a1821 1
    XSetForeground(XtDisplay(new), 
d1823 2
a1824 2
		   newbw->bitmap.foreground_pixel 
		   ^ 
d1830 1
a1830 1
    XSetForeground(XtDisplay(new), 
d1833 1
a1833 1
		   ^ 
d1847 1
a1847 1
    XSetForeground(XtDisplay(new), 
d1850 1
a1850 1
		   ^ 
d1854 1
a1854 1
 
d1862 1
a1862 1
  
d1870 1
a1870 1
Boolean 
d1878 1
a1878 1
void 
d1888 1
a1888 1
		   0, 0, 
d1894 1
a1894 1
void 
d1904 1
a1904 1
void 
d1913 2
a1914 2
    
    BWEngageRequest(w, RestoreRequest, False, 
d1916 1
a1916 1
    
d1922 1
a1922 1
void 
d1935 1
a1935 1
void 
d1943 1
a1943 1
void 
@


1.1
log
@Initial revision
@
text
@a0 1
/* $Xorg: Bitmap.c,v 1.4 2001/02/09 02:05:28 xorgcvs Exp $ */
a27 1
/* $XFree86: Bitmap.c,v 1.5 2001/12/26 21:39:34 paulo Exp $ */
d230 1
a230 1
Atom targets[] = {
@


1.1.1.1
log
@Importing from X.Org 7.2RC2
@
text
@@
