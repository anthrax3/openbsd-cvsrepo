head	1.3;
access;
symbols
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.20
	OPENBSD_5_0:1.1.1.1.0.18
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.14
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_5:1.1.1.1
	fvwm:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2012.03.18.17.17.13;	author matthieu;	state dead;
branches;
next	1.2;

1.2
date	2012.03.04.12.07.01;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.10.53.12;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.10.53.12;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove the whole extras directory, not used in OpenBSD builds.
Noticed by fgsch@@ a while ago.
@
text
@#include "FvwmConsole.h"

#ifndef HAVE_READLINE
static   char cmd[MAX_COMMAND_SIZE];

/* no readline - starts here */
char *get_line() {
  if( fgets(cmd,MAX_COMMAND_SIZE,stdin) == NULL  ) {
	return(NULL);
  }
  return(cmd);
}

#else 
/* readline - starts here */
#include <readline/readline.h>
#include <readline/history.h>

extern int rl_bind_key();


static char cmd[MAX_COMMAND_SIZE];
static char *line = (char *)NULL;
static int done_init = 0;
static char *h_file;

char *get_line()
{
    char *prompt;
    int len;
	char *home;
	int  fdh; 

    /* If initialization hasn't been done, do it now:
     *  - We don't want TAB completion
     */
    if (!done_init) {
        rl_bind_key('\t', rl_insert);

		/* get history from file */
		home = getenv("HOME");
		h_file = safemalloc( strlen(home)+ 14);
		strcpy(h_file,home);
		strcat(h_file,HISTFILE);
		if( access( h_file, F_OK)  < 0) {
		  /* if it doesn't exist create it */
		  fdh = creat( h_file, S_IRUSR | S_IWUSR );
		  if( fdh != -1 ) {
			close( fdh ); 
		  }
		} else {
		  read_history_range( h_file, 0, HISTSIZE );
		}
		done_init = 1;
  }
                             
    /* Empty out the previous info */
    len = 0;
    *cmd = '\0';
    prompt = PS1;

    while (1) {
        int linelen = 0;

        /* If the buffer has already been allocated, free the memory. */
        if (line != (char *)NULL)
            free(line);

  /* Get a line from the user. */
        line  = readline(prompt);
        if (line == NULL)
            return (NULL);

        /* Make sure we have enough space for the new line */
        linelen = strlen(line);
        if (len + linelen > MAX_COMMAND_SIZE-2 ) {
		  fprintf( stderr, "line too long %d chars max %d \a\n", 
				   len+linelen, MAX_COMMAND_SIZE-2 );
		  strncat(cmd, line, MAX_COMMAND_SIZE-len-2);
		  add_history(cmd);
		  break;
        }
     
        /* Copy the new line onto the end of the current line */
        strcat(cmd, line);

        /* If the current line doesn't end with a backslash, we're done */
        len = strlen(cmd);
        if (cmd[len-1] != '\\')
            break;

        /* Otherwise, remove it and wait for more (add a space if needed) */
        prompt = PS2;
        cmd[len-1] = (cmd[len-2]==' ' || cmd[len-2]=='\t') ? '\0' : ' ';
  } 

    /* If the command has any text in it, save it on the history. */
    if (*cmd != '\0') {
	  add_history(cmd);
	  append_history( 1,h_file );
	  history_truncate_file( h_file, HISTSIZE ); 
	}

    cmd[len]   = '\n';
    cmd[len+1] = '\0';

    return (cmd);
}
/* readline - end here */
#endif


@


1.2
log
@rename getline() occurrences to get_line().
@
text
@@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
char *getline() {
d27 1
a27 1
char *getline()
@


1.1.1.1
log
@Importing from XF4, plus BSD make infrastructure
@
text
@@
