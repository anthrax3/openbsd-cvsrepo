head	1.3;
access;
symbols
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.20
	OPENBSD_5_0:1.1.1.1.0.18
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.14
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_5:1.1.1.1
	fvwm:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2012.03.18.17.17.13;	author matthieu;	state dead;
branches;
next	1.2;

1.2
date	2012.03.04.12.07.01;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.10.53.11;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.10.53.11;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove the whole extras directory, not used in OpenBSD builds.
Noticed by fgsch@@ a while ago.
@
text
@#include "FvwmConsole.h"

int  s;    /* socket handle */
FILE *sp;
char *name;  /* name of this program at executing time */
char *get_line();


/******************************************/
/*  close socket and exit */
/******************************************/
void sclose () {
  fclose(sp);
  exit(0);
}

/************************************/
/* print error message on stderr */
/************************************/
void ErrMsg( char *msg ) {
  fprintf( stderr, "%s error in %s\n", name , msg );
  fclose(sp);
  exit(1);
}


/*******************************************************/
/* setup socket.                                       */
/* send command to and receive message from the server */
/*******************************************************/
int main ( int argc, char *argv[]) {
  char *cmd;
  unsigned char data[MAX_MESSAGE_SIZE];
  int  len;  /* length of socket address */
  struct sockaddr_un sas;
  int  clen; /* command length */
  int  pid;  /* child process id */
  char *home;
  char *s_name;

  signal (SIGINT, sclose);  
  signal (SIGQUIT, sclose);  

  name=strrchr(argv[0], '/');
  if (name != NULL) {
    name++;
  }

  /* make a socket */
  home = getenv("HOME");
  s_name = safemalloc( strlen(home)+ 14);
  strcpy(s_name,home);
  strcat(s_name,S_NAME);
  if( (s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0 ) {
	ErrMsg ("socket");
  }

  /* name the socket and obtain the size of it*/
  sas.sun_family = AF_UNIX;
  strcpy( sas.sun_path, s_name );
  len = sizeof(sas) - sizeof( sas.sun_path) + strlen( sas.sun_path );

  if( connect( s, (struct sockaddr *)&sas, len )< 0 ) {
	ErrMsg( "connect" );
  }

  sp = fdopen( s, "r" );

  pid = fork();
  if( pid == -1 ) {
	ErrMsg( "fork");
  }
  if( pid == 0 ) {
	/* loop of get user's command and send it to server */
	while( 1 ) {

	  cmd = get_line();
	  if (cmd == NULL) {
		break;
	  }
	
	  clen = strlen(cmd);
	  if( clen == 1 ) {
		continue;    /* empty line */
	  }

	  /* send the command including null to the server */
	  send( s, cmd, strlen(cmd)+1, 0 );

	}
	kill( getppid(), SIGKILL );
	sclose();
  }
  while( fgets( data, MAX_MESSAGE_SIZE, sp )  ) {
	/* get the response */
	/* ignore config lines */
	if( !strcmp( data, C_BEG ) ) {
	  while( fgets( data, MAX_MESSAGE_SIZE, sp) ) {
		if( *data == '\0' || !strcmp(data,C_END) ) {
		  break;
		}  
	  }	
	  if( *data != '\0' ) {
		continue;
	  }
	}
	if( *data == '\0' ) {
	  break;
	}
	printf( "%s",data );
  }
return (0);
}

@


1.2
log
@rename getline() occurrences to get_line().
@
text
@@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
char *getline();
d77 1
a77 1
	  cmd = getline();
@


1.1.1.1
log
@Importing from XF4, plus BSD make infrastructure
@
text
@@
