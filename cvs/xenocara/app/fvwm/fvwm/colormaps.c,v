head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.42
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.40
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.38
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.36
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.34
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.32
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.30
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.28
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.26
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.24
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.22
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.20
	OPENBSD_5_0:1.1.1.1.0.18
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.14
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.16
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.12
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_5:1.1.1.1
	fvwm:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2006.11.26.10.53.26;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.10.53.26;	author matthieu;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@/****************************************************************************
 * This module is all new
 * by Rob Nation
 *
 * This code handles colormaps for fvwm.
 *
 * Copyright 1994 Robert Nation. No restrictions are placed on this code,
 * as long as the copyright notice is preserved . No guarantees or
 * warrantees of any sort whatsoever are given or implied or anything.
 ****************************************************************************/

#include "config.h"

#include <stdio.h>
#include <unistd.h>
#include "fvwm.h"
#include <X11/Xatom.h>
#include "misc.h"
#include "parse.h"
#include "screen.h"
#include "module.h"

FvwmWindow *colormap_win;
Colormap last_cmap = None;
extern FvwmWindow *Tmp_win;

/***********************************************************************
 *
 *  Procedure:
 *	HandleColormapNotify - colormap notify event handler
 *
 * This procedure handles both a client changing its own colormap, and
 * a client explicitly installing its colormap itself (only the window
 * manager should do that, so we must set it correctly).
 *
 ***********************************************************************/
void HandleColormapNotify(void)
{
  XColormapEvent *cevent = (XColormapEvent *)&Event;
  Bool ReInstall = False;


  if(!Tmp_win)
    {
      return;
    }
  if(cevent->new)
    {
      XGetWindowAttributes(dpy,Tmp_win->w,&(Tmp_win->attr));
      if((Tmp_win  == colormap_win)&&(Tmp_win->number_cmap_windows == 0))
	last_cmap = Tmp_win->attr.colormap;
      ReInstall = True;
    }
  else if((cevent->state == ColormapUninstalled)&&
	  (last_cmap == cevent->colormap))
    {
      /* Some window installed its colormap, change it back */
      ReInstall = True;
    }

  while(XCheckTypedEvent(dpy,ColormapNotify,&Event))
    {
      if (XFindContext (dpy, cevent->window,
			FvwmContext, (caddr_t *) &Tmp_win) == XCNOENT)
	Tmp_win = NULL;
      if((Tmp_win)&&(cevent->new))
	{
	  XGetWindowAttributes(dpy,Tmp_win->w,&(Tmp_win->attr));
	  if((Tmp_win  == colormap_win)&&(Tmp_win->number_cmap_windows == 0))
	    last_cmap = Tmp_win->attr.colormap;
	  ReInstall = True;
	}
      else if((Tmp_win)&&
	      (cevent->state == ColormapUninstalled)&&
	      (last_cmap == cevent->colormap))
	{
	  /* Some window installed its colormap, change it back */
	  ReInstall = True;
	}
      else if((Tmp_win)&&
	      (cevent->state == ColormapInstalled)&&
	      (last_cmap == cevent->colormap))
	{
	  /* The last color map installed was the correct one. Don't
	   * change anything */
	  ReInstall = False;
	}
    }

  /* Reinstall the colormap that we think should be installed,
   * UNLESS and unrecognized window has the focus - it might be
   * an override-redirect window that has its own colormap. */
  if((ReInstall)&&(Scr.UnknownWinFocused == None))
    {
      XInstallColormap(dpy,last_cmap);
    }
}

/************************************************************************
 *
 * Re-Install the active colormap
 *
 *************************************************************************/
void ReInstallActiveColormap(void)
{
  InstallWindowColormaps(colormap_win);
}

/***********************************************************************
 *
 *  Procedure:
 *	InstallWindowColormaps - install the colormaps for one fvwm window
 *
 *  Inputs:
 *	type	- type of event that caused the installation
 *	tmp	- for a subset of event types, the address of the
 *		  window structure, whose colormaps are to be installed.
 *
 ************************************************************************/

void InstallWindowColormaps (FvwmWindow *tmp)
{
  int i;
  XWindowAttributes attributes;
  Window w;
  Bool ThisWinInstalled = False;


  /* If no window, then install root colormap */
  if(!tmp)
    tmp = &Scr.FvwmRoot;

  colormap_win = tmp;
  /* Save the colormap to be loaded for when force loading of
   * root colormap(s) ends.
   */
  Scr.pushed_window = tmp;
  /* Don't load any new colormap if root colormap(s) has been
   * force loaded.
   */
  if (Scr.root_pushes)
    {
      return;
    }

  if(tmp->number_cmap_windows > 0)
    {
      for(i=tmp->number_cmap_windows -1; i>=0;i--)
	{
	  w = tmp->cmap_windows[i];
	  if(w == tmp->w)
	    ThisWinInstalled = True;
	  XGetWindowAttributes(dpy,w,&attributes);

          /*
           * On Sun X servers, don't install 24 bit TrueColor colourmaps.
           * Despite what the server says, these colourmaps are always
           * installed.
           */
	  if(last_cmap != attributes.colormap
#if defined(sun) && defined(TRUECOLOR_ALWAYS_INSTALLED)
             && !(attributes.depth == 24 && attributes.visual->class == TrueColor)
#endif
             )
	    {
	      last_cmap = attributes.colormap;
	      XInstallColormap(dpy,attributes.colormap);
	    }
	}
    }

  if(!ThisWinInstalled)
    {
      if(last_cmap != tmp->attr.colormap
#if defined(sun) && defined(TRUECOLOR_ALWAYS_INSTALLED)
         && !(tmp->attr.depth == 24 && tmp->attr.visual->class == TrueColor)
#endif
        )
	{
	  last_cmap = tmp->attr.colormap;
	  XInstallColormap(dpy,tmp->attr.colormap);
	}
    }
}


/***********************************************************************
 *
 *  Procedures:
 *	<Uni/I>nstallRootColormap - Force (un)loads root colormap(s)
 *
 *	   These matching routines provide a mechanism to insure that
 *	   the root colormap(s) is installed during operations like
 *	   rubber banding or menu display that require colors from
 *	   that colormap.  Calls may be nested arbitrarily deeply,
 *	   as long as there is one UninstallRootColormap call per
 *	   InstallRootColormap call.
 *
 *	   The final UninstallRootColormap will cause the colormap list
 *	   which would otherwise have be loaded to be loaded, unless
 *	   Enter or Leave Notify events are queued, indicating some
 *	   other colormap list would potentially be loaded anyway.
 ***********************************************************************/
void InstallRootColormap()
{
  FvwmWindow *tmp;
  if (Scr.root_pushes == 0)
    {
      tmp = Scr.pushed_window;
      InstallWindowColormaps(&Scr.FvwmRoot);
      Scr.pushed_window = tmp;
    }
  Scr.root_pushes++;
  return;
}

/***************************************************************************
 *
 * Unstacks one layer of root colormap pushing
 * If we peel off the last layer, re-install th e application colormap
 *
 ***************************************************************************/
void UninstallRootColormap()
{
  if (Scr.root_pushes)
    Scr.root_pushes--;

  if (!Scr.root_pushes)
    {
      InstallWindowColormaps(Scr.pushed_window);
    }

  return;
}



/*****************************************************************************
 *
 * Gets the WM_COLORMAP_WINDOWS property from the window
 *   This property typically doesn't exist, but a few applications
 *   use it. These seem to occur mostly on SGI machines.
 *
 ****************************************************************************/
void FetchWmColormapWindows (FvwmWindow *tmp)
{
  if(tmp->cmap_windows != (Window *)NULL)
    XFree((void *)tmp->cmap_windows);

  if(!XGetWMColormapWindows (dpy, tmp->w, &(tmp->cmap_windows),
			     &(tmp->number_cmap_windows)))
    {
      tmp->number_cmap_windows = 0;
      tmp->cmap_windows = NULL;
    }
}


@


1.1.1.1
log
@Importing from XF4, plus BSD make infrastructure
@
text
@@
