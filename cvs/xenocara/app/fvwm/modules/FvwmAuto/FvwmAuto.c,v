head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.32
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.30
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.28
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.26
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.24
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.22
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.20
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.18
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.16
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.14
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.12
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.10
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.10
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.8
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.6
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v2_2_5:1.1.1.1
	fvwm:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2009.10.24.13.34.54;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.10.53.43;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.10.53.43;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.2
log
@sprintf() -> snprintf()
@
text
@/* This module, and the entire FvwmAuto program, and the concept for
 * interfacing this module to the Window Manager, are all original work
 * by Robert Nation
 *
 * Copyright 1994, Robert Nation. No guarantees or warantees or anything
 * are provided or implied in any way whatsoever. Use this program at your
 * own risk. Permission to use this program for any purpose is given,
 * as long as the copyright is kept intact.
 *
 * reworked by A.Kadlec (albrecht@@auto.tuwien.ac.at) 09/96
 * to support an arbitrary enter_fn & leave_fn (command line arguments)
 * completely reworked, while I was there.
 *
 * Modified by John Aughey (jha@@cs.purdue.edu) 11/96
 * to not perform any action when entering the root window
 *
 * Minor patch by C. Hines 12/96.
 *
 */

#define TRUE 1
#define FALSE

#include "config.h"

#ifdef HAVE_SYS_BSDTYPES_H
#include <sys/bsdtypes.h> /* Saul */
#endif

#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/time.h>

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

#include <unistd.h>
#include <ctype.h>
#include <stdlib.h>
#include "../../fvwm/module.h"
#include "../../libs/fvwmlib.h"


/***********************************************************************
 *
 *  Procedure:
 *	SIGPIPE handler - SIGPIPE means fvwm is dying
 *
 ***********************************************************************/
void DeadPipe(int nonsense)
{
    exit(0);
}


/***********************************************************************
 *
 *  Procedure:
 *	main - start of module
 *
 ***********************************************************************/
int main(int argc, char **argv)
{
    char      	   *enter_fn="Raise",	/* default */
                   *leave_fn=NULL,
                   mask_mesg[80];
    unsigned long  header[HEADER_SIZE],
                   *body,
                   last_win = 0,	/* last window handled */
                   focus_win = 0;	/* current focus */
    int            fd_width,
                   fd[2],
                   timeout,sec = 0,usec = 0;
    struct timeval value,
                   *delay;
    fd_set	   in_fdset;

    if(argc < 7 || argc > 9)
    {
	fprintf(stderr,"FvwmAuto can use one to three arguments.\n");
	exit(1);
    }

    /* Dead pipes mean fvwm died */
    signal (SIGPIPE, DeadPipe);

    fd[0] = atoi(argv[1]);
    fd[1] = atoi(argv[2]);

    if ((timeout = atoi(argv[6])))
    {
	sec = timeout / 1000;
	usec = (timeout % 1000) * 1000;
	delay=&value;
    } else
	delay=NULL;

    if (argv[7])			/* if specified */
    {
	if (*argv[7] && !StrEquals(argv[7],"NOP")) /* not empty */
	    enter_fn=argv[7];		/* override default */
	else
	    enter_fn=NULL;		/* nop */

	if (argv[8] && *argv[8] && !StrEquals(argv[8],"NOP"))
					/* leave function specified */
	    leave_fn=argv[8];
    }

#ifdef DEBUG
    fprintf(stderr,"[FvwmAuto]: timeout: %d EnterFn: >%s< LeaveFn: >%s<\n",timeout,enter_fn,leave_fn);
#endif

    fd_width = GetFdWidth();
    snprintf(mask_mesg, sizeof(mask_mesg), "SET_MASK %lu\n",(unsigned long)(M_FOCUS_CHANGE));
    SendInfo(fd,mask_mesg,0);

    while(1)
    {
	FD_ZERO(&in_fdset);
	FD_SET(fd[1],&in_fdset);

	if (delay)		/* fill in struct - modified by select() */
	{
	    delay->tv_sec = sec;
	    delay->tv_usec = usec;
	}
	select(fd_width, SELECT_TYPE_ARG234 &in_fdset, 0, 0,
	       (focus_win == last_win) ? NULL : delay);
#ifdef DEBUG
	    fprintf(stderr,"[FvwmAuto]: after select:  focus_win: 0x%08lx, last_win: 0x%08lx\n",focus_win, last_win);
	    fprintf(stderr,"[FvwmAuto]: after select:  delay: 0x%08lx, delay struct: %d.%06d sec\n",delay,delay->tv_sec,delay->tv_usec);
#endif

	if (FD_ISSET(fd[1], &in_fdset) &&
	    ReadFvwmPacket(fd[1],header, &body) > 0)
	{
	    focus_win = body[0];
	    free(body);
#ifdef DEBUG
	    fprintf(stderr,"[FvwmAuto]: M_FOCUS_CHANGE to 0x%08lx\n",focus_win);
#endif
	}
	if (((FD_ISSET(fd[1], &in_fdset)==0) == (delay!=NULL)) &&
					/* new message and timeout==0  or */
					/* no message and timeout>0 */
	    focus_win!=last_win)	/* there's sth. to do */
	{
	    if (last_win && leave_fn)	/* if last_win isn't the root */
	    {
		SendInfo(fd,leave_fn,last_win);
#ifdef DEBUG
		fprintf(stderr,"[FvwmAuto]: executing %s on window 0x%08lx\n",leave_fn,focus_win);
#endif
	    }
	    if (focus_win && enter_fn)	/* if focus_win isn't the root */
	    {
		SendInfo(fd,enter_fn,focus_win);
#ifdef DEBUG
		fprintf(stderr,"[FvwmAuto]: executing %s on window 0x%08lx\n",enter_fn,focus_win);
#endif
	    }
	    last_win = focus_win;	/* switch to wait mode again */
	}
    }
    return 0;
}



@


1.1
log
@Initial revision
@
text
@d119 1
a119 1
    sprintf(mask_mesg,"SET_MASK %lu\n",(unsigned long)(M_FOCUS_CHANGE));
@


1.1.1.1
log
@Importing from XF4, plus BSD make infrastructure
@
text
@@
