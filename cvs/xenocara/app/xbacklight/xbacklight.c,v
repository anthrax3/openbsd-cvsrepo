head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.12
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.10
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.8
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.2
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.18
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.16
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.14
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.12
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.10
	OPENBSD_5_0:1.2.0.8
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.4
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.6
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.1.1.1.0.8
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.6
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.4
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.2
	v1_1:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.05.03.19.36.42;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.10.10.22.10;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.24.17.04.58;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.11.24.17.04.58;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Update to xbacklight 1.2.1
@
text
@/*
 * Copyright Â© 2007 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */
#include <stdio.h>
#include <stdlib.h>

#include <xcb/xcb.h>
#include <xcb/xcb_util.h>
#include <xcb/xproto.h>
#include <xcb/randr.h>

#include <ctype.h>
#include <string.h>
#include <unistd.h>

typedef enum { Get, Set, Inc, Dec } op_t;

static char *program_name;

static xcb_atom_t backlight, backlight_new, backlight_legacy;

static void
usage (void)
{
    fprintf(stderr, "usage: %s [options]\n%s", program_name,
            "  where options are:\n"
            "  -display <display> or -d <display>\n"
            "  -help\n"
            "  -set <percentage> or = <percentage>\n"
            "  -inc <percentage> or + <percentage>\n"
            "  -dec <percentage> or - <percentage>\n"
            "  -get\n"
            "  -time <fade time in milliseconds>\n"
            "  -steps <number of steps in fade>\n");
    exit (1);
}

static long
backlight_get (xcb_connection_t *conn, xcb_randr_output_t output)
{
    xcb_generic_error_t *error;
    xcb_randr_get_output_property_reply_t *prop_reply = NULL;
    xcb_randr_get_output_property_cookie_t prop_cookie;
    long value;
    
    backlight = backlight_new;
    if (backlight != XCB_ATOM_NONE) {
	prop_cookie = xcb_randr_get_output_property (conn, output,
						     backlight, XCB_ATOM_NONE,
						     0, 4, 0, 0);
	prop_reply = xcb_randr_get_output_property_reply (conn, prop_cookie, &error);
	if (error != NULL || prop_reply == NULL) {
	    backlight = backlight_legacy;
	    if (backlight != XCB_ATOM_NONE) {
		prop_cookie = xcb_randr_get_output_property (conn, output,
							     backlight, XCB_ATOM_NONE,
							     0, 4, 0, 0);
		prop_reply = xcb_randr_get_output_property_reply (conn, prop_cookie, &error);
		if (error != NULL || prop_reply == NULL) {
		    return -1;
		}
	    }
	}
    }

    if (prop_reply == NULL ||
	prop_reply->type != XCB_ATOM_INTEGER ||
	prop_reply->num_items != 1 ||
	prop_reply->format != 32) {
	value = -1;
    } else {
	value = *((int32_t *) xcb_randr_get_output_property_data (prop_reply));
    }

    free (prop_reply);
    return value;
}

static void
backlight_set (xcb_connection_t *conn, xcb_randr_output_t output, long value)
{
    xcb_randr_change_output_property (conn, output, backlight, XCB_ATOM_INTEGER,
				      32, XCB_PROP_MODE_REPLACE,
				      1, (unsigned char *)&value);
}

int
main (int argc, char **argv)
{
    char    *dpy_name = NULL;
    op_t    op = Get;
    int	    value = 0;
    int	    i;
    int	    total_time = 200;	/* ms */
    int	    steps = 20;

    xcb_connection_t *conn;
    xcb_generic_error_t *error;

    xcb_randr_query_version_cookie_t ver_cookie;
    xcb_randr_query_version_reply_t *ver_reply;

    xcb_intern_atom_cookie_t backlight_cookie[2];
    xcb_intern_atom_reply_t *backlight_reply;

    xcb_screen_iterator_t iter;

    program_name = argv[0];

    for (i = 1; i < argc; i++)
    {
	if (!strcmp (argv[i], "-display") || !strcmp ("-d", argv[i]))
	{
	    if (++i >= argc) usage();
	    dpy_name = argv[i];
	    continue;
	}
	if (!strcmp (argv[i], "-set") || !strcmp (argv[i], "="))
	{
	    if (++i >= argc) usage();
	    op = Set;
	    value = atoi (argv[i]);
	    continue;
	}
	if (argv[i][0] == '=' && isdigit (argv[i][1]))
	{
	    op = Set;
	    value = atoi (argv[i] + 1);
	    continue;
	}
	if (!strcmp (argv[i], "-inc") || !strcmp (argv[i], "+"))
	{
	    if (++i >= argc) usage();
	    op = Inc;
	    value = atoi (argv[i]);
	    continue;
	}
	if (argv[i][0] == '+' && isdigit (argv[i][1]))
	{
	    op = Inc;
	    value = atoi (argv[i] + 1);
	    continue;
	}
	if (!strcmp (argv[i], "-dec") || !strcmp (argv[i], "-"))
	{
	    if (++i >= argc) usage();
	    op = Dec;
	    value = atoi (argv[i]);
	    continue;
	}
	if (argv[i][0] == '-' && isdigit (argv[i][1]))
	{
	    op = Dec;
	    value = atoi (argv[i] + 1);
	    continue;
	}
	if (!strcmp (argv[i], "-get") || !strcmp (argv[i], "-g"))
	{
	    op = Get;
	    continue;
	}
	if (!strcmp (argv[i], "-time"))
	{
	    if (++i >= argc) usage();
	    total_time = atoi (argv[i]);
	    continue;
	}
	if (!strcmp (argv[i], "-steps"))
	{
	    if (++i >= argc) usage();
	    steps = atoi (argv[i]);
	    continue;
	}
	if (!strcmp (argv[i], "-help") || !strcmp (argv[i], "-?"))
	{
	    usage ();
	}
	usage ();
    }
    conn = xcb_connect (dpy_name, NULL);
    ver_cookie = xcb_randr_query_version (conn, 1, 2);
    ver_reply = xcb_randr_query_version_reply (conn, ver_cookie, &error);
    if (error != NULL || ver_reply == NULL) {
	int ec = error ? error->error_code : -1;
	fprintf (stderr, "RANDR Query Version returned error %d\n", ec);
	exit (1);
    }
    if (ver_reply->major_version != 1 ||
	ver_reply->minor_version < 2) {
	fprintf (stderr, "RandR version %d.%d too old\n",
		 ver_reply->major_version, ver_reply->minor_version);
	exit (1);
    }
    free (ver_reply);

    backlight_cookie[0] = xcb_intern_atom (conn, 1, strlen("Backlight"), "Backlight");
    backlight_cookie[1] = xcb_intern_atom (conn, 1, strlen("BACKLIGHT"), "BACKLIGHT");

    backlight_reply = xcb_intern_atom_reply (conn, backlight_cookie[0], &error);
    if (error != NULL || backlight_reply == NULL) {
	int ec = error ? error->error_code : -1;
	fprintf (stderr, "Intern Atom returned error %d\n", ec);
	exit (1);
    }

    backlight_new = backlight_reply->atom;
    free (backlight_reply);

    backlight_reply = xcb_intern_atom_reply (conn, backlight_cookie[1], &error);
    if (error != NULL || backlight_reply == NULL) {
	int ec = error ? error->error_code : -1;
	fprintf (stderr, "Intern Atom returned error %d\n", ec);
	exit (1);
    }

    backlight_legacy = backlight_reply->atom;
    free (backlight_reply);

    if (backlight_new == XCB_NONE && backlight_legacy == XCB_NONE) {
	fprintf (stderr, "No outputs have backlight property\n");
	exit (1);
    }

    iter = xcb_setup_roots_iterator (xcb_get_setup (conn));
    while (iter.rem) {
	xcb_screen_t *screen = iter.data;
	xcb_window_t root = screen->root;
	xcb_randr_output_t *outputs;

	xcb_randr_get_screen_resources_cookie_t resources_cookie;
	xcb_randr_get_screen_resources_reply_t *resources_reply;

	resources_cookie = xcb_randr_get_screen_resources (conn, root);
	resources_reply = xcb_randr_get_screen_resources_reply (conn, resources_cookie, &error);
	if (error != NULL || resources_reply == NULL) {
	    int ec = error ? error->error_code : -1;
	    fprintf (stderr, "RANDR Get Screen Resources returned error %d\n", ec);
	    continue;
	}

	outputs = xcb_randr_get_screen_resources_outputs (resources_reply);
	for (int o = 0; o < resources_reply->num_outputs; o++)
	{
	    xcb_randr_output_t output = outputs[o];
	    double    	cur, new, step;
	    double	min, max;
	    double	set;

	    cur = backlight_get (conn, output);
	    if (cur != -1)
	    {
		xcb_randr_query_output_property_cookie_t prop_cookie;
		xcb_randr_query_output_property_reply_t *prop_reply;

		prop_cookie = xcb_randr_query_output_property (conn, output, backlight);
		prop_reply = xcb_randr_query_output_property_reply (conn, prop_cookie, &error);

		if (error != NULL || prop_reply == NULL) continue;

		if (prop_reply->range &&
		    xcb_randr_query_output_property_valid_values_length (prop_reply) == 2) {
		    int32_t *values = xcb_randr_query_output_property_valid_values (prop_reply);
		    min = values[0];
		    max = values[1];

		    if (op == Get) {
			printf ("%f\n", (cur - min) * 100 / (max - min));
		    } else {
			set = value * (max - min) / 100;
			switch (op) {
			case Set:
			    new = min + set;
			    break;
			case Inc:
			    new = cur + set;
			    break;
			case Dec:
			    new = cur - set;
			    break;
			default:
			    xcb_aux_sync (conn);
			    return 1;
			}
			if (new > max) new = max;
			if (new < min) new = min;
			step = (new - cur) / steps;
			for (i = 0; i < steps && step != 0; i++)
			{
			    if (i == steps - 1)
				cur = new;
			    else
				cur += step;
			    backlight_set (conn, output, (long) cur);
			    xcb_flush (conn);
			    usleep (total_time * 1000 / steps);
			}
		    }
		}
		free (prop_reply);
	    }
	}

	free (resources_reply);
	xcb_screen_next (&iter);
    }
    xcb_aux_sync (conn);

    return 0;
}
@


1.2
log
@update to xbacklight 1.1.1
@
text
@d24 5
a28 3
#include <X11/Xatom.h>
#include <X11/Xlib.h>
#include <X11/extensions/Xrandr.h>
d38 1
a38 1
static Atom backlight, backlight_new, backlight_legacy;
d43 10
a52 11
    fprintf(stderr, "usage: %s [options]\n", program_name);
    fprintf(stderr, "  where options are:\n");
    fprintf(stderr, "  -display <display> or -d <display>\n");
    fprintf(stderr, "  -help\n");
    fprintf(stderr, "  -set <percentage> or = <percentage>\n");
    fprintf(stderr, "  -inc <percentage> or + <percentage>\n");
    fprintf(stderr, "  -dec <percentage> or - <percentage>\n");
    fprintf(stderr, "  -get\n");
    fprintf(stderr, "  -time <fade time in milliseconds>\n");
    fprintf(stderr, "  -steps <number of steps in fade>\n");
    /*NOTREACHED*/
d57 1
a57 1
backlight_get (Display *dpy, RROutput output)
d59 4
a62 6
    unsigned long   nitems;
    unsigned long   bytes_after;
    unsigned char   *prop;
    Atom	    actual_type;
    int		    actual_format;
    long	    value;
d65 17
a81 12
    if (!backlight ||
	XRRGetOutputProperty (dpy, output, backlight,
			      0, 4, False, False, None,
			      &actual_type, &actual_format,
			      &nitems, &bytes_after, &prop) != Success) {
	backlight = backlight_legacy;
	if (!backlight ||
	    XRRGetOutputProperty (dpy, output, backlight,
				  0, 4, False, False, None,
				  &actual_type, &actual_format,
				  &nitems, &bytes_after, &prop) != Success)
	    return -1;
d84 4
a87 1
    if (actual_type != XA_INTEGER || nitems != 1 || actual_format != 32)
d89 5
a93 3
    else
	value = *((long *) prop);
    XFree (prop);
d98 1
a98 1
backlight_set (Display *dpy, RROutput output, long value)
d100 3
a102 2
    XRRChangeOutputProperty (dpy, output, backlight, XA_INTEGER, 32,
			     PropModeReplace, (unsigned char *) &value, 1);
a108 3
    Display *dpy;
    int	    screen;
    int	    major, minor;
d115 11
d198 12
a209 5
    dpy = XOpenDisplay (dpy_name);
    if (!dpy)
    {
	fprintf (stderr, "Cannot open display \"%s\"\n",
		 XDisplayName (dpy_name));
d212 9
a220 3
    if (!XRRQueryVersion (dpy, &major, &minor))
    {
	fprintf (stderr, "RandR extension missing\n");
d223 8
a230 3
    if (major < 1 || (major == 1 && minor < 2))
    {
	fprintf (stderr, "RandR version %d.%d too old\n", major, minor);
d234 4
a237 4
    backlight_new    = XInternAtom (dpy, "Backlight", True);
    backlight_legacy = XInternAtom (dpy, "BACKLIGHT", True);
    if (backlight_new == None && backlight_legacy == None)
    {
d241 20
a260 8
    for (screen = 0; screen < ScreenCount (dpy); screen++)
    {
	Window		    root = RootWindow (dpy, screen);
	XRRScreenResources  *resources = XRRGetScreenResources (dpy, root);
	int		    o;
	
	if (!resources) continue;
	for (o = 0; o < resources->noutput; o++)
d262 1
a262 2
	    RROutput	output = resources->outputs[o];
	    XRRPropertyInfo *info;
d267 1
a267 1
	    cur = backlight_get (dpy, output);
d270 44
a313 38
		info = XRRQueryOutputProperty (dpy, output, backlight);
		if (info)
		{
		    if (info->range && info->num_values == 2)
		    {
			min = info->values[0];
			max = info->values[1];
			if (op == Get) {
			    printf ("%f\n", (cur - min) * 100 / (max - min));
			} else {
			    set = value * (max - min) / 100;
			    switch (op) {
			    case Set:
				new = min + set;
				break;
			    case Inc:
				new = cur + set;
				break;
			    case Dec:
				new = cur - set;
				break;
			    default:
				XSync (dpy, False);
				return 1;
			    }
			    if (new > max) new = max;
			    if (new < min) new = min;
			    step = (new - cur) / steps;
			    for (i = 0; i < steps && step != 0; i++)
			    {
				if (i == steps - 1)
				    cur = new;
				else
				    cur += step;
				backlight_set (dpy, output, (long) cur);
				XFlush (dpy);
				usleep (total_time * 1000 / steps);
			    }
a315 1
		    XFree (info);
d317 1
d320 3
a322 2
							   
	XRRFreeScreenResources (resources);
d324 1
a324 1
    XSync (dpy, False);
@


1.1
log
@Initial revision
@
text
@d28 4
d36 1
a36 1
static Atom backlight;
d65 3
a67 1
    if (XRRGetOutputProperty (dpy, output, backlight,
d70 10
a79 2
			      &nitems, &bytes_after, &prop) != Success)
	return -1;
d197 4
a200 2
    backlight = XInternAtom (dpy, "BACKLIGHT", True);
    if (backlight == None)
d244 3
d271 2
@


1.1.1.1
log
@xbacklight 1.1
@
text
@@
