head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.4
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.8.0.2
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.6
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.4
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.2
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.2
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.8
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.2.0.2
	OPENBSD_4_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2016.08.06.11.15.37;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	PZS2WhWqaDL9DHu5;

1.7
date	2015.06.20.09.54.58;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	qfQeUTeluaj7TPII;

1.6
date	2014.05.03.19.37.22;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.11.19.26.23;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.11.11.11.47;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.24.14.17.46;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.18.20.50.16;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.02.15.24.13;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to xinput 1.6.2
@
text
@/*
 * Copyright © 2007 Peter Hutterer
 * Copyright © 2009 Red Hat, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <X11/Xatom.h>
#include <X11/extensions/XIproto.h>

#include "xinput.h"

static Atom parse_atom(Display *dpy, char *name) {
    Bool is_atom = True;
    int i;

    for (i = 0; name[i] != '\0'; i++) {
        if (!isdigit(name[i])) {
            is_atom = False;
            break;
        }
    }

    if (is_atom)
        return atoi(name);
    else
        return XInternAtom(dpy, name, False);
}

static void
print_property(Display *dpy, XDevice* dev, Atom property)
{
    Atom                act_type;
    char                *name;
    int                 act_format;
    unsigned long       nitems, bytes_after;
    unsigned char       *data, *ptr;
    int                 j, done = False, size = 0;

    name = XGetAtomName(dpy, property);
    printf("\t%s (%ld):\t", name, property);
    XFree(name);

    if (XGetDeviceProperty(dpy, dev, property, 0, 1000, False,
                           AnyPropertyType, &act_type, &act_format,
                           &nitems, &bytes_after, &data) == Success)
    {
        Atom float_atom = XInternAtom(dpy, "FLOAT", True);

        ptr = data;

        if (nitems == 0)
            printf("<no items>");

        switch(act_format)
        {
            case 8: size = sizeof(char); break;
            case 16: size = sizeof(short); break;
            case 32: size = sizeof(long); break;
        }

        for (j = 0; j < nitems; j++)
        {
            switch(act_type)
            {
                case XA_INTEGER:
                    switch(act_format)
                    {
                        case 8:
                            printf("%d", *((char*)ptr));
                            break;
                        case 16:
                            printf("%d", *((short*)ptr));
                            break;
                        case 32:
                            printf("%ld", *((long*)ptr));
                            break;
                    }
                    break;
                case XA_CARDINAL:
                    switch(act_format)
                    {
                        case 8:
                            printf("%u", *((unsigned char*)ptr));
                            break;
                        case 16:
                            printf("%u", *((unsigned short*)ptr));
                            break;
                        case 32:
                            printf("%lu", *((unsigned long*)ptr));
                            break;
                    }
                    break;
                case XA_STRING:
                    if (act_format != 8)
                    {
                        printf("Unknown string format.\n");
                        done = True;
                        break;
                    }
                    printf("\"%s\"", ptr);
                    j += strlen((char*)ptr); /* The loop's j++ jumps over the
                                                terminating 0 */
                    ptr += strlen((char*)ptr); /* ptr += size below jumps over
                                                  the terminating 0 */
                    break;
                case XA_ATOM:
                    {
                        Atom a = *(Atom*)ptr;
                        name = (a) ? XGetAtomName(dpy, a) : NULL;
                        printf("\"%s\" (%d)", name ? name : "None", (int)a);
                        XFree(name);
                        break;
                    }
                default:
                    if (float_atom != None && act_type == float_atom)
                    {
                        printf("%f", *((float*)ptr));
                        break;
                    }

                    name = XGetAtomName(dpy, act_type);
                    printf("\t... of unknown type '%s'\n", name);
                    XFree(name);
                    done = True;
                    break;
            }

            ptr += size;

            if (done == True)
                break;
            if (j < nitems - 1)
                printf(", ");
        }
        printf("\n");
        XFree(data);
    } else
        printf("\tFetch failure\n");

}

static int
list_props_xi1(Display *dpy, int argc, char** argv, char* name, char *desc)
{
    XDeviceInfo *info;
    XDevice     *dev;
    int          i;
    int         nprops;
    Atom        *props;
    int         rc = EXIT_SUCCESS;

    if (argc == 0)
    {
        fprintf(stderr, "Usage: xinput %s %s\n", name, desc);
        return EXIT_FAILURE;
    }

    for (i = 0; i < argc; i++)
    {
        info = find_device_info(dpy, argv[i], False);
        if (!info)
        {
            fprintf(stderr, "unable to find device '%s'\n", argv[i]);
            rc = EXIT_FAILURE;
            continue;
        }

        dev = XOpenDevice(dpy, info->id);
        if (!dev)
        {
            fprintf(stderr, "unable to open device '%s'\n", info->name);
            rc = EXIT_FAILURE;
            continue;
        }

        props = XListDeviceProperties(dpy, dev, &nprops);
        if (!nprops)
        {
            printf("Device '%s' does not report any properties.\n", info->name);
            continue;
        }

        printf("Device '%s':\n", info->name);
        while(nprops--)
        {
            print_property(dpy, dev, props[nprops]);
        }

        XFree(props);
        XCloseDevice(dpy, dev);
    }
    return rc;
}


int watch_props(Display *dpy, int argc, char** argv, char* n, char *desc)
{
    XDevice     *dev;
    XDeviceInfo *info;
    XEvent      ev;
    XDevicePropertyNotifyEvent *dpev;
    char        *name;
    int         type_prop;
    XEventClass cls_prop;

    if (list_props(dpy, argc, argv, n, desc) != EXIT_SUCCESS)
        return EXIT_FAILURE;

    info = find_device_info(dpy, argv[0], False);
    if (!info)
    {
        fprintf(stderr, "unable to find device '%s'\n", argv[0]);
        return EXIT_FAILURE;
    }

    dev = XOpenDevice(dpy, info->id);
    if (!dev)
    {
        fprintf(stderr, "unable to open device '%s'\n", info->name);
        return EXIT_FAILURE;
    }

    DevicePropertyNotify(dev, type_prop, cls_prop);
    XSelectExtensionEvent(dpy, DefaultRootWindow(dpy), &cls_prop, 1);

    while(1)
    {
        XNextEvent(dpy, &ev);

        dpev = (XDevicePropertyNotifyEvent*)&ev;
        if (dpev->type != type_prop)
            continue;

        name = XGetAtomName(dpy, dpev->atom);
        printf("Property '%s' changed.\n", name);
        XFree(name);
        print_property(dpy, dev, dpev->atom);
    }

    XCloseDevice(dpy, dev);
}

static int
delete_prop_xi1(Display *dpy, int argc, char** argv, char* n, char *desc)
{
    XDevice     *dev;
    XDeviceInfo *info;
    char        *name;
    Atom        prop;

    info = find_device_info(dpy, argv[0], False);
    if (!info)
    {
        fprintf(stderr, "unable to find device '%s'\n", argv[0]);
        return EXIT_FAILURE;
    }

    dev = XOpenDevice(dpy, info->id);
    if (!dev)
    {
        fprintf(stderr, "unable to open device '%s'\n", info->name);
        return EXIT_FAILURE;
    }

    name = argv[1];

    prop = parse_atom(dpy, name);

    XDeleteDeviceProperty(dpy, dev, prop);

    XCloseDevice(dpy, dev);
    return EXIT_SUCCESS;
}

static int
do_set_prop_xi1(Display *dpy, Atom type, int format, int argc, char **argv, char *n, char *desc)
{
    XDeviceInfo  *info;
    XDevice      *dev;
    Atom          prop;
    Atom          old_type;
    char         *name;
    int           i;
    Atom          float_atom;
    int           old_format, nelements = 0;
    unsigned long act_nitems, bytes_after;
    char         *endptr;
    union {
        unsigned char *c;
        short *s;
        long *l;
        Atom *a;
    } data;

    if (argc < 3)
    {
        fprintf(stderr, "Usage: xinput %s %s\n", n, desc);
        return EXIT_FAILURE;
    }

    info = find_device_info(dpy, argv[0], False);
    if (!info)
    {
        fprintf(stderr, "unable to find device '%s'\n", argv[0]);
        return EXIT_FAILURE;
    }

    dev = XOpenDevice(dpy, info->id);
    if (!dev)
    {
        fprintf(stderr, "unable to open device '%s'\n", argv[0]);
        return EXIT_FAILURE;
    }

    name = argv[1];

    prop = parse_atom(dpy, name);

    if (prop == None) {
        fprintf(stderr, "invalid property '%s'\n", name);
        return EXIT_FAILURE;
    }

    float_atom = XInternAtom(dpy, "FLOAT", False);

    nelements = argc - 2;
    if (type == None || format == 0) {
        if (XGetDeviceProperty(dpy, dev, prop, 0, 0, False, AnyPropertyType,
                               &old_type, &old_format, &act_nitems,
                               &bytes_after, &data.c) != Success) {
            fprintf(stderr, "failed to get property type and format for '%s'\n",
                    name);
            return EXIT_FAILURE;
        } else {
            if (type == None)
                type = old_type;
            if (format == 0)
                format = old_format;
        }

        XFree(data.c);
    }

    if (type == None) {
        fprintf(stderr, "property '%s' doesn't exist, you need to specify "
                "its type and format\n", name);
        return EXIT_FAILURE;
    }

    data.c = calloc(nelements, sizeof(long));

    for (i = 0; i < nelements; i++)
    {
        if (type == XA_INTEGER || type == XA_CARDINAL) {
            switch (format)
            {
                case 8:
                    data.c[i] = atoi(argv[2 + i]);
                    break;
                case 16:
                    data.s[i] = atoi(argv[2 + i]);
                    break;
                case 32:
                    data.l[i] = atoi(argv[2 + i]);
                    break;
                default:
                    fprintf(stderr, "unexpected size for property '%s'", name);
                    return EXIT_FAILURE;
            }
        } else if (type == float_atom) {
            if (format != 32) {
                fprintf(stderr, "unexpected format %d for property '%s'\n",
                        format, name);
                return EXIT_FAILURE;
            }
            *(float *)(data.l + i) = strtod(argv[2 + i], &endptr);
            if (endptr == argv[2 + i]) {
                fprintf(stderr, "argument '%s' could not be parsed\n", argv[2 + i]);
                return EXIT_FAILURE;
            }
        } else if (type == XA_ATOM) {
            if (format != 32) {
                fprintf(stderr, "unexpected format %d for property '%s'\n",
                        format, name);
                return EXIT_FAILURE;
            }
            data.a[i] = parse_atom(dpy, argv[2 + i]);
        } else {
            fprintf(stderr, "unexpected type for property '%s'\n", name);
            return EXIT_FAILURE;
        }
    }

    XChangeDeviceProperty(dpy, dev, prop, type, format, PropModeReplace,
                          data.c, nelements);
    free(data.c);
    XCloseDevice(dpy, dev);
    return EXIT_SUCCESS;
}

#if HAVE_XI2
static void
print_property_xi2(Display *dpy, int deviceid, Atom property)
{
    Atom                act_type;
    char                *name;
    int                 act_format;
    unsigned long       nitems, bytes_after;
    unsigned char       *data, *ptr;
    int                 j, done = False;

    name = XGetAtomName(dpy, property);
    printf("\t%s (%ld):\t", name, property);
    XFree(name);

    if (XIGetProperty(dpy, deviceid, property, 0, 1000, False,
                           AnyPropertyType, &act_type, &act_format,
                           &nitems, &bytes_after, &data) == Success)
    {
        Atom float_atom = XInternAtom(dpy, "FLOAT", True);

        ptr = data;

        if (nitems == 0)
            printf("<no items>");

        for (j = 0; j < nitems; j++)
        {
            switch(act_type)
            {
                case XA_INTEGER:
                    switch(act_format)
                    {
                        case 8:
                            printf("%d", *((int8_t*)ptr));
                            break;
                        case 16:
                            printf("%d", *((int16_t*)ptr));
                            break;
                        case 32:
                            printf("%d", *((int32_t*)ptr));
                            break;
                    }
                    break;
                case XA_CARDINAL:
                    switch(act_format)
                    {
                        case 8:
                            printf("%u", *((uint8_t*)ptr));
                            break;
                        case 16:
                            printf("%u", *((uint16_t*)ptr));
                            break;
                        case 32:
                            printf("%u", *((uint32_t*)ptr));
                            break;
                    }
                    break;
                case XA_STRING:
                    if (act_format != 8)
                    {
                        printf("Unknown string format.\n");
                        done = True;
                        break;
                    }
                    printf("\"%s\"", ptr);
                    j += strlen((char*)ptr); /* The loop's j++ jumps over the
                                                terminating 0 */
                    ptr += strlen((char*)ptr); /* ptr += size below jumps over
                                                  the terminating 0 */
                    break;
                case XA_ATOM:
                    {
                        Atom a = *(uint32_t*)ptr;
                        name = (a) ? XGetAtomName(dpy, a) : NULL;
                        printf("\"%s\" (%ld)", name ? name : "None", a);
                        XFree(name);
                        break;
                    }
                    break;
                default:
                    if (float_atom != None && act_type == float_atom)
                    {
                        printf("%f", *((float*)ptr));
                        break;
                    }

                    name = XGetAtomName(dpy, act_type);
                    printf("\t... of unknown type %s\n", name);
                    XFree(name);
                    done = True;
                    break;
            }

            ptr += act_format/8;

            if (done == True)
                break;
            if (j < nitems - 1)
                printf(", ");
        }
        printf("\n");
        XFree(data);
    } else
        printf("\tFetch failure\n");

}

static int
list_props_xi2(Display *dpy, int argc, char** argv, char* name, char *desc)
{
    XIDeviceInfo *info;
    int         i;
    int         nprops;
    Atom        *props;
    int         rc = EXIT_SUCCESS;

    if (argc == 0)
    {
        fprintf(stderr, "Usage: xinput %s %s\n", name, desc);
        return EXIT_FAILURE;
    }

    for (i = 0; i < argc; i++)
    {
        info = xi2_find_device_info(dpy, argv[i]);
        if (!info)
        {
            fprintf(stderr, "unable to find device %s\n", argv[i]);
            rc = EXIT_FAILURE;
            continue;
        }

        props = XIListProperties(dpy, info->deviceid, &nprops);
        if (!nprops)
        {
            printf("Device '%s' does not report any properties.\n", info->name);
            continue;
        }

        printf("Device '%s':\n", info->name);
        while(nprops--)
        {
            print_property_xi2(dpy, info->deviceid, props[nprops]);
        }

        XFree(props);
    }
    return rc;
}

static int
delete_prop_xi2(Display *dpy, int argc, char** argv, char* n, char *desc)
{
    XIDeviceInfo *info;
    char        *name;
    Atom        prop;

    info = xi2_find_device_info(dpy, argv[0]);
    if (!info)
    {
        fprintf(stderr, "unable to find device %s\n", argv[0]);
        return EXIT_FAILURE;
    }

    name = argv[1];

    prop = parse_atom(dpy, name);

    XIDeleteProperty(dpy, info->deviceid, prop);

    return EXIT_SUCCESS;
}

static int
do_set_prop_xi2(Display *dpy, Atom type, int format, int argc, char **argv, char *n, char *desc)
{
    XIDeviceInfo *info;
    Atom          prop;
    Atom          old_type;
    char         *name;
    int           i;
    Atom          float_atom;
    int           old_format, nelements = 0;
    unsigned long act_nitems, bytes_after;
    char         *endptr;
    union {
        unsigned char *c;
        int16_t *s;
        int32_t *l;
    } data;

    if (argc < 3)
    {
        fprintf(stderr, "Usage: xinput %s %s\n", n, desc);
        return EXIT_FAILURE;
    }

    info = xi2_find_device_info(dpy, argv[0]);
    if (!info)
    {
        fprintf(stderr, "unable to find device %s\n", argv[0]);
        return EXIT_FAILURE;
    }

    name = argv[1];

    prop = parse_atom(dpy, name);

    if (prop == None) {
        fprintf(stderr, "invalid property '%s'\n", name);
        return EXIT_FAILURE;
    }

    float_atom = XInternAtom(dpy, "FLOAT", False);

    nelements = argc - 2;
    if (type == None || format == 0) {
        if (XIGetProperty(dpy, info->deviceid, prop, 0, 0, False,
                          AnyPropertyType, &old_type, &old_format, &act_nitems,
                          &bytes_after, &data.c) != Success) {
            fprintf(stderr, "failed to get property type and format for '%s'\n",
                    name);
            return EXIT_FAILURE;
        } else {
            if (type == None)
                type = old_type;
            if (format == 0)
                format = old_format;
        }

        XFree(data.c);
    }

    if (type == None) {
        fprintf(stderr, "property '%s' doesn't exist, you need to specify "
                "its type and format\n", name);
        return EXIT_FAILURE;
    }

    data.c = calloc(nelements, sizeof(int32_t));

    for (i = 0; i < nelements; i++)
    {
        if (type == XA_INTEGER || type == XA_CARDINAL) {
            switch (format)
            {
                case 8:
                    data.c[i] = atoi(argv[2 + i]);
                    break;
                case 16:
                    data.s[i] = atoi(argv[2 + i]);
                    break;
                case 32:
                    data.l[i] = atoi(argv[2 + i]);
                    break;
                default:
                    fprintf(stderr, "unexpected size for property %s", name);
                    return EXIT_FAILURE;
            }
        } else if (type == float_atom) {
            if (format != 32) {
                fprintf(stderr, "unexpected format %d for property '%s'\n",
                        format, name);
                return EXIT_FAILURE;
            }
            *(float *)(data.l + i) = strtod(argv[2 + i], &endptr);
            if (endptr == argv[2 + i]) {
                fprintf(stderr, "argument %s could not be parsed\n", argv[2 + i]);
                return EXIT_FAILURE;
            }
        } else if (type == XA_ATOM) {
            if (format != 32) {
                fprintf(stderr, "unexpected format %d for property '%s'\n",
                        format, name);
                return EXIT_FAILURE;
            }
            data.l[i] = parse_atom(dpy, argv[2 + i]);
        } else {
            fprintf(stderr, "unexpected type for property '%s'\n", name);
            return EXIT_FAILURE;
        }
    }

    XIChangeProperty(dpy, info->deviceid, prop, type, format, PropModeReplace,
                          data.c, nelements);
    free(data.c);
    return EXIT_SUCCESS;
}
#endif

int list_props(Display *display, int argc, char *argv[], char *name,
               char *desc)
{
#ifdef HAVE_XI2
    if (xinput_version(display) == XI_2_Major)
        return list_props_xi2(display, argc, argv, name, desc);
#endif
    return list_props_xi1(display, argc, argv, name, desc);

}

int delete_prop(Display *display, int argc, char *argv[], char *name,
                char *desc)
{
#ifdef HAVE_XI2
    if (xinput_version(display) == XI_2_Major)
        return delete_prop_xi2(display, argc, argv, name, desc);
#endif
    return delete_prop_xi1(display, argc, argv, name, desc);

}

static int
do_set_prop(Display *display, Atom type, int format, int argc, char *argv[], char *name, char *desc)
{
#ifdef HAVE_XI2
    if (xinput_version(display) == XI_2_Major)
        return do_set_prop_xi2(display, type, format, argc, argv, name, desc);
#endif
    return do_set_prop_xi1(display, type, format, argc, argv, name, desc);
}

int
set_atom_prop(Display *dpy, int argc, char** argv, char* n, char *desc)
{
    return do_set_prop(dpy, XA_ATOM, 32, argc, argv, n, desc);
}

int
set_int_prop(Display *dpy, int argc, char** argv, char* n, char *desc)
{
    int          i;
    int          format;

    if (argc < 3)
    {
        fprintf(stderr, "Usage: xinput %s %s\n", n, desc);
        return EXIT_FAILURE;
    }

    format    = atoi(argv[2]);
    if (format != 8 && format != 16 && format != 32)
    {
        fprintf(stderr, "Invalid format %d\n", format);
        return EXIT_FAILURE;
    }

    for (i = 3; i < argc; i++)
        argv[i - 1] = argv[i];

    return do_set_prop(dpy, XA_INTEGER, format, argc - 1, argv, n, desc);
}

int
set_float_prop(Display *dpy, int argc, char** argv, char* n, char *desc)
{
    Atom float_atom = XInternAtom(dpy, "FLOAT", False);

    if (sizeof(float) != 4)
    {
	fprintf(stderr, "sane FP required\n");
	return EXIT_FAILURE;
    }

    return do_set_prop(dpy, float_atom, 32, argc, argv, n, desc);
}

int set_prop(Display *display, int argc, char *argv[], char *name,
             char *desc)
{
    Atom type = None;
    int format = 0;
    int i = 0, j;

    while (i < argc) {
        char *option = strchr(argv[i], '=');
        /* skip non-option arguments */
        if (strncmp(argv[i], "--", 2) || !option) {
            i++;
            continue;
        }

        if (!strncmp(argv[i], "--type=", strlen("--type="))) {
            if (!strcmp(option + 1, "int")) {
                type = XA_INTEGER;
            } else if (!strcmp(option + 1, "float")) {
                type = XInternAtom(display, "FLOAT", False);
                format = 32;
            } else if (!strcmp(option + 1, "atom")) {
                type = XA_ATOM;
                format = 32;
            } else {
                fprintf(stderr, "unknown property type %s\n", option + 1);
                return EXIT_FAILURE;
            }
        } else if (!strncmp(argv[i], "--format=", strlen("--format="))) {
            format = atoi(option + 1);
            if (format != 8 && format != 16 && format != 32) {
                fprintf(stderr, "invalid property format '%s'\n", option + 1);
                return EXIT_FAILURE;
            }
        } else {
            fprintf(stderr, "invalid option '%s'\n", argv[i]);
            return EXIT_FAILURE;
        }

        for (j = i; j + 1 < argc; j++)
            argv[j] = argv[j + 1];
        argc--;
    }

    return do_set_prop(display, type, format, argc, argv, name, desc);
}

int disable(Display *display, int argc, char *argv[], char *name, char *desc)
{
    char *new_argv[3] = { NULL, "Device Enabled", "0" };

    if (argc != 1) {
        fprintf(stderr, "Usage: xinput %s %s\n", name, desc);
        return EXIT_FAILURE;
    }

    new_argv[0] = argv[0];

    return set_prop(display, 3, new_argv, name, desc);
}

int enable(Display *display, int argc, char *argv[], char *name, char *desc)
{
    char *new_argv[3] = { NULL, "Device Enabled", "1" };

    if (argc != 1) {
        fprintf(stderr, "Usage: xinput %s %s\n", name, desc);
        return EXIT_FAILURE;
    }

    new_argv[0] = argv[0];

    return set_prop(display, 3, new_argv, name, desc);
}
@


1.7
log
@Merge from upstreams Fix crash for enable/disable without a device argument

commit 904a32d908219d6fea833576f7c31727bd3aea2f
Author: Peter Hutterer <peter.hutterer@@who-t.net>
Date:   Mon Nov 25 14:51:50 2013 +1000

    Fix crash for enable/disable without a device argument

    Signed-off-by: Peter Hutterer <peter.hutterer@@who-t.net>
    Reviewed-by: Alan Coopersmith <alan.coopersmith@@oracle.com>
@
text
@d172 1
d186 1
d194 1
d214 1
a214 1
    return EXIT_SUCCESS;
d538 1
d552 1
d571 1
a571 1
    return EXIT_SUCCESS;
@


1.6
log
@Update to xinput 1.6.1
@
text
@d835 9
a843 1
    char *new_argv[3] = { argv[0], "Device Enabled", "0" };
d849 9
a857 1
    char *new_argv[3] = { argv[0], "Device Enabled", "1" };
@


1.5
log
@Update to xinput 1.6.0
@
text
@d63 1
d131 3
a133 3
                        printf("\"%s\" (%d)",
                                (a) ? XGetAtomName(dpy, a) : "None",
                                (int)a);
d143 3
a145 2
                    printf("\t... of unknown type '%s'\n",
                            XGetAtomName(dpy, act_type));
d255 1
d433 1
d494 3
a496 3
                        printf("\"%s\" (%ld)",
                                (a) ? XGetAtomName(dpy, a) : "None",
                                a);
d507 3
a509 2
                    printf("\t... of unknown type %s\n",
                            XGetAtomName(dpy, act_type));
@


1.4
log
@Update to xinput 1.5.3
@
text
@d2 2
a3 1
 * Copyright 2007 Peter Hutterer
d5 6
a10 5
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation.
d12 3
a14 15
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the author shall
 * not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization
 * from the author.
d16 7
d59 1
a59 1
    int                 j, done = False, size;
d100 14
d142 1
a142 1
                    printf("\t... of unknown type %s\n",
d182 1
a182 1
            fprintf(stderr, "unable to find device %s\n", argv[i]);
d229 1
a229 1
        fprintf(stderr, "unable to find device %s\n", argv[0]);
d270 1
a270 1
        fprintf(stderr, "unable to find device %s\n", argv[0]);
d320 1
a320 1
        fprintf(stderr, "unable to find device %s\n", argv[0]);
d327 1
a327 1
        fprintf(stderr, "unable to open device %s\n", argv[0]);
d336 1
a336 1
        fprintf(stderr, "invalid property %s\n", name);
d347 1
a347 1
            fprintf(stderr, "failed to get property type and format for %s\n",
d361 1
a361 1
        fprintf(stderr, "property %s doesn't exist, you need to specify "
d370 1
a370 1
        if (type == XA_INTEGER) {
d383 1
a383 1
                    fprintf(stderr, "unexpected size for property %s", name);
d388 1
a388 1
                fprintf(stderr, "unexpected format %d for property %s\n",
d394 1
a394 1
                fprintf(stderr, "argument %s could not be parsed\n", argv[2 + i]);
d399 1
a399 1
                fprintf(stderr, "unexpected format %d for property %s\n",
d405 1
a405 1
            fprintf(stderr, "unexpected type for property %s\n", name);
d460 14
d623 1
a623 1
        fprintf(stderr, "invalid property %s\n", name);
d634 1
a634 1
            fprintf(stderr, "failed to get property type and format for %s\n",
d648 1
a648 1
        fprintf(stderr, "property %s doesn't exist, you need to specify "
d657 1
a657 1
        if (type == XA_INTEGER) {
d675 1
a675 1
                fprintf(stderr, "unexpected format %d for property %s\n",
d686 1
a686 1
                fprintf(stderr, "unexpected format %d for property %s\n",
d692 1
a692 1
            fprintf(stderr, "unexpected type for property %s\n", name);
d812 1
a812 1
                fprintf(stderr, "invalid property format %s\n", option + 1);
d816 1
a816 1
            fprintf(stderr, "invalid option %s\n", argv[i]);
d826 12
@


1.3
log
@Udate to xinput version 1.5.0
@
text
@d464 2
a465 2
                        Atom a = *(Atom*)ptr;
                        printf("\"%s\" (%d)",
d467 1
a467 1
                                (int)a);
@


1.2
log
@update to xinput 1.4.2
@
text
@d37 17
d75 3
d117 7
a123 2
                    printf("\"%s\"", XGetAtomName(dpy, *(Atom*)ptr));
                    break;
d139 2
a142 2
            if (done == True)
                break;
d151 2
a152 1
int list_props(Display *dpy, int argc, char** argv, char* name, char *desc)
d201 2
a202 2
int
set_int_prop(Display *dpy, int argc, char** argv, char* n, char *desc)
d204 1
d206 2
a207 2
    XDevice     *dev;
    Atom         prop;
d209 2
a210 4
    int          i;
    Bool         is_atom = True;
    char        *data;
    int          format, nelements =  0;
d212 1
a212 3
    if (argc < 3)
    {
        fprintf(stderr, "Usage: xinput %s %s\n", n, desc);
a213 1
    }
d225 1
a225 1
        fprintf(stderr, "unable to open device %s\n", argv[0]);
d229 10
a238 1
    name = argv[1];
d240 3
a242 5
    for(i = 0; i < strlen(name); i++) {
	if (!isdigit(name[i])) {
            is_atom = False;
	    break;
	}
d245 10
a254 4
    if (!is_atom)
        prop = XInternAtom(dpy, name, False);
    else
        prop = atoi(name);
d256 2
a257 3
    nelements = argc - 3;
    format    = atoi(argv[2]);
    if (format != 8 && format != 16 && format != 32)
d259 1
a259 1
        fprintf(stderr, "Invalid format %d\n", format);
d263 2
a264 2
    data = calloc(nelements, sizeof(long));
    for (i = 0; i < nelements; i++)
d266 2
a267 12
        switch(format)
        {
            case 8:
                *(((char*)data) + i) = atoi(argv[3 + i]);
                break;
            case 16:
                *(((short*)data) + i) = atoi(argv[3 + i]);
                break;
            case 32:
                *(((long*)data) + i) = atoi(argv[3 + i]);
                break;
        }
d270 5
a274 2
    XChangeDeviceProperty(dpy, dev, prop, XA_INTEGER, format, PropModeReplace,
                          (unsigned char*)data, nelements);
a275 1
    free(data);
d280 2
a281 2
int
set_float_prop(Display *dpy, int argc, char** argv, char* n, char *desc)
d283 16
a298 9
    XDeviceInfo *info;
    XDevice     *dev;
    Atom         prop, float_atom;
    char        *name;
    int          i;
    Bool         is_atom = True;
    long        *data;
    int          nelements =  0;
    char*        endptr;
d300 1
a300 1
    if (argc < 2)
d322 5
a326 5
    for(i = 0; i < strlen(name); i++) {
	if (!isdigit(name[i])) {
            is_atom = False;
	    break;
	}
d329 1
a329 4
    if (!is_atom)
        prop = XInternAtom(dpy, name, False);
    else
        prop = atoi(name);
d332 13
d346 2
a347 1
    float_atom = XInternAtom(dpy, "FLOAT", False);
d349 4
a352 4
    if (float_atom == (Atom)0)
    {
	fprintf(stderr, "no FLOAT atom present in server\n");
	return EXIT_FAILURE;
d355 1
a355 5
    if (sizeof(float) != 4)
    {
	fprintf(stderr, "sane FP required\n");
	return EXIT_FAILURE;
    }
a356 1
    data = calloc(nelements, sizeof(long));
d359 38
a396 5
        *((float*)(data + i)) = strtod(argv[2 + i], &endptr);
	if(endptr == argv[2 + i]){
	    fprintf(stderr, "argument %s could not be parsed\n", argv[2 + i]);
	    return EXIT_FAILURE;
	}
d399 3
a401 4
    XChangeDeviceProperty(dpy, dev, prop, float_atom, 32, PropModeReplace,
                          (unsigned char*)data, nelements);

    free(data);
d406 3
a408 2

int watch_props(Display *dpy, int argc, char** argv, char* n, char *desc)
d410 6
a415 7
    XDevice     *dev;
    XDeviceInfo *info;
    XEvent      ev;
    XDevicePropertyNotifyEvent *dpev;
    char        *name;
    int         type_prop;
    XEventClass cls_prop;
d417 2
a418 2
    if (list_props(dpy, argc, argv, n, desc) != EXIT_SUCCESS)
        return EXIT_FAILURE;
d420 3
a422 2
    info = find_device_info(dpy, argv[0], False);
    if (!info)
d424 81
a504 3
        fprintf(stderr, "unable to find device %s\n", argv[0]);
        return EXIT_FAILURE;
    }
d506 1
a506 2
    dev = XOpenDevice(dpy, info->id);
    if (!dev)
d508 1
a508 1
        fprintf(stderr, "unable to open device '%s'\n", info->name);
d512 1
a512 4
    DevicePropertyNotify(dev, type_prop, cls_prop);
    XSelectExtensionEvent(dpy, DefaultRootWindow(dpy), &cls_prop, 1);

    while(1)
d514 6
a519 1
        XNextEvent(dpy, &ev);
d521 4
a524 2
        dpev = (XDevicePropertyNotifyEvent*)&ev;
        if (dpev->type != type_prop)
d526 7
d534 1
a534 3
        name = XGetAtomName(dpy, dpev->atom);
        printf("Property '%s' changed.\n", name);
        print_property(dpy, dev, dpev->atom);
d536 1
a536 2

    XCloseDevice(dpy, dev);
d539 2
a540 1
int delete_prop(Display *dpy, int argc, char** argv, char* n, char *desc)
d542 1
a542 2
    XDevice     *dev;
    XDeviceInfo *info;
a543 2
    int         i;
    Bool        is_atom = True;
d546 1
a546 1
    info = find_device_info(dpy, argv[0], False);
a552 7
    dev = XOpenDevice(dpy, info->id);
    if (!dev)
    {
        fprintf(stderr, "unable to open device '%s'\n", info->name);
        return EXIT_FAILURE;
    }

d555 1
a555 11
    for(i = 0; i < strlen(name); i++) {
	if (!isdigit(name[i])) {
            is_atom = False;
	    break;
	}
    }

    if (!is_atom)
        prop = XInternAtom(dpy, name, False);
    else
        prop = atoi(name);
d557 1
a557 1
    XDeleteDeviceProperty(dpy, dev, prop);
a558 1
    XCloseDevice(dpy, dev);
d562 2
a563 2
int
set_atom_prop(Display *dpy, int argc, char** argv, char* n, char *desc)
d565 14
a578 8
    XDeviceInfo *info;
    XDevice     *dev;
    Atom         prop;
    char        *name;
    int          i, j;
    Bool         is_atom = True;
    Atom        *data;
    int          nelements =  0;
d586 1
a586 1
    info = find_device_info(dpy, argv[0], False);
d593 6
a598 4
    dev = XOpenDevice(dpy, info->id);
    if (!dev)
    {
        fprintf(stderr, "unable to open device %s\n", argv[0]);
d602 19
a620 1
    name = argv[1];
d622 4
a625 5
    for(i = 0; i < strlen(name); i++) {
	if (!isdigit(name[i])) {
            is_atom = False;
	    break;
	}
d628 1
a628 4
    if (!is_atom)
        prop = XInternAtom(dpy, name, False);
    else
        prop = atoi(name);
a629 2
    nelements = argc - 2;
    data = calloc(nelements, sizeof(Atom));
d632 32
a663 6
        is_atom = True;
        name = argv[2 + i];
        for(j = 0; j < strlen(name); j++) {
            if (!isdigit(name[j])) {
                is_atom = False;
                break;
d665 4
d670 58
d729 5
a733 7
        if (!is_atom)
            data[i] = XInternAtom(dpy, name, False);
        else
        {
            data[i] = atoi(name);
            XFree(XGetAtomName(dpy, data[i]));
        }
d736 10
a745 2
    XChangeDeviceProperty(dpy, dev, prop, XA_ATOM, 32, PropModeReplace,
                          (unsigned char*)data, nelements);
d747 7
a753 3
    free(data);
    XCloseDevice(dpy, dev);
    return EXIT_SUCCESS;
d756 14
d771 31
@


1.1
log
@update to xinput 1.4.1
@
text
@d45 1
a45 1
    int                 j, done = False;
d54 1
a54 1
        int float_atom = XInternAtom(dpy, "FLOAT", False);
d58 7
d73 1
a73 1
                            printf("%d", *((int8_t*)ptr));
d76 1
a76 1
                            printf("%d", *((int16_t*)ptr));
d79 1
a79 1
                            printf("%d", *((int32_t*)ptr));
d84 6
d91 4
a94 1
                    done = True;
d112 1
a112 1
            ptr += act_format/8;
d229 1
a229 1
    data = calloc(nelements, format/8);
d235 1
a235 1
                *(((int8_t*)data) + i) = atoi(argv[3 + i]);
d238 1
a238 1
                *(((int16_t*)data) + i) = atoi(argv[3 + i]);
d241 1
a241 1
                *(((int32_t*)data) + i) = atoi(argv[3 + i]);
d263 1
a263 1
    float       *data;
d317 1
a317 1
    data = calloc(nelements, 4);
d320 1
a320 1
        *(data + i) = strtod(argv[2 + i], &endptr);
@

