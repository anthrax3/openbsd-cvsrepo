head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.14
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.12
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.10
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.8
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.2
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.6
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.4
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.4.0.6
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.2
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	v1_3_0:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2014.05.03.19.37.22;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2012.06.11.19.26.23;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.15.05.59.29;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.08.21.32.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.11.11.11.11.47;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.24.14.17.46;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.05.18.20.50.16;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.02.15.24.13;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2008.09.07.13.28.46;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.07.13.28.46;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update to xinput 1.6.1
@
text
@/*
 * Copyright 1996 by Frederic Lepied, France. <Frederic.Lepied@@sugix.frmug.org>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is  hereby granted without fee, provided that
 * the  above copyright   notice appear  in   all  copies and  that both  that
 * copyright  notice   and   this  permission   notice  appear  in  supporting
 * documentation, and that   the  name of  the authors  not  be  used  in
 * advertising or publicity pertaining to distribution of the software without
 * specific,  written      prior  permission.     The authors  make  no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * THE AUTHORS DISCLAIM ALL   WARRANTIES WITH REGARD  TO  THIS SOFTWARE,
 * INCLUDING ALL IMPLIED   WARRANTIES OF MERCHANTABILITY  AND   FITNESS, IN NO
 * EVENT  SHALL THE AUTHORS  BE   LIABLE   FOR ANY  SPECIAL, INDIRECT   OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA  OR PROFITS, WHETHER  IN  AN ACTION OF  CONTRACT,  NEGLIGENCE OR OTHER
 * TORTIOUS  ACTION, ARISING    OUT OF OR   IN  CONNECTION  WITH THE USE    OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */

#include "xinput.h"
#include <string.h>

enum print_format {
    FORMAT_NONE,
    FORMAT_SHORT,
    FORMAT_LONG,
    FORMAT_NAME,
    FORMAT_ID,
};


static void
print_info(Display* dpy, XDeviceInfo	*info, enum print_format format)
{
    int			i,j;
    XAnyClassPtr	any;
    XKeyInfoPtr		k;
    XButtonInfoPtr	b;
    XValuatorInfoPtr	v;
    XAxisInfoPtr	a;

    if (format == FORMAT_NAME)
    {
        printf("%s\n", info->name);
        return;
    } else if (format == FORMAT_ID)
    {
        printf("%ld\n", info->id);
        return;
    }

    printf("\"%s\"\tid=%ld\t[", info->name, info->id);

    switch (info->use) {
    case IsXPointer:
       printf("XPointer");
       break;
    case IsXKeyboard:
       printf("XKeyboard");
       break;
    case IsXExtensionDevice:
       printf("XExtensionDevice");
       break;
    case IsXExtensionKeyboard:
       printf("XExtensionKeyboard");
       break;
    case IsXExtensionPointer:
       printf("XExtensionPointer");
       break;
    default:
       printf("Unknown class");
       break;
    }
    printf("]\n");

    if (format == FORMAT_SHORT)
        return;

    if (info->type != None) {
	char *type = XGetAtomName(dpy, info->type);
	printf("\tType is %s\n", type);
	XFree(type);
    }

    if (info->num_classes > 0) {
	any = (XAnyClassPtr) (info->inputclassinfo);
	for (i=0; i<info->num_classes; i++) {
	    switch (any->class) {
	    case KeyClass:
		k = (XKeyInfoPtr) any;
		printf("\tNum_keys is %d\n", k->num_keys);
		printf("\tMin_keycode is %d\n", k->min_keycode);
		printf("\tMax_keycode is %d\n", k->max_keycode);
		break;

	    case ButtonClass:
		b = (XButtonInfoPtr) any;
		printf("\tNum_buttons is %d\n", b->num_buttons);
		break;

	    case ValuatorClass:
		v = (XValuatorInfoPtr) any;
		a = (XAxisInfoPtr) ((char *) v +
				    sizeof (XValuatorInfo));
		printf("\tNum_axes is %d\n", v->num_axes);
		printf("\tMode is %s\n", (v->mode == Absolute) ? "Absolute" : "Relative");
		printf("\tMotion_buffer is %ld\n", v->motion_buffer);
		for (j=0; j<v->num_axes; j++, a++) {
		    printf("\tAxis %d :\n", j);
		    printf("\t\tMin_value is %d\n", a->min_value);
		    printf("\t\tMax_value is %d\n", a->max_value);
		    printf ("\t\tResolution is %d\n", a->resolution);
		}
		break;
	    default:
		printf ("unknown class\n");
	    }
	    any = (XAnyClassPtr) ((char *) any + any->length);
	}
    }
}

static int list_xi1(Display     *display,
                    enum print_format format)
{
    XDeviceInfo		*info;
    int			loop;
    int                 num_devices;

    info = XListInputDevices(display, &num_devices);
    for(loop=0; loop<num_devices; loop++) {
        print_info(display, info+loop, format);
    }
    return EXIT_SUCCESS;
}

#ifdef HAVE_XI2
/* also used from test_xi2.c */
void
print_classes_xi2(Display* display, XIAnyClassInfo **classes,
                  int num_classes)
{
    int i, j;

    printf("\tReporting %d classes:\n", num_classes);
    for (i = 0; i < num_classes; i++)
    {
        printf("\t\tClass originated from: %d. Type: ", classes[i]->sourceid);
        switch(classes[i]->type)
        {
            case XIButtonClass:
                {
                    XIButtonClassInfo *b = (XIButtonClassInfo*)classes[i];
                    char *name;
                    printf("XIButtonClass\n");
                    printf("\t\tButtons supported: %d\n", b->num_buttons);
                    printf("\t\tButton labels:");
                    for (j = 0; j < b->num_buttons; j++)
                    {
                        name = (b->labels[j]) ? XGetAtomName(display, b->labels[j]) : NULL;
                        if (name)
                            printf(" \"%s\"", name);
                        else
                            printf(" None");
                        XFree(name);
                    }
                    printf("\n");
                    printf("\t\tButton state:");
                    for (j = 0; j < b->state.mask_len * 8; j++)
                        if (XIMaskIsSet(b->state.mask, j))
                            printf(" %d", j);
                    printf("\n");

                }
                break;
            case XIKeyClass:
                {
                    XIKeyClassInfo *k = (XIKeyClassInfo*)classes[i];
                    printf("XIKeyClass\n");
                    printf("\t\tKeycodes supported: %d\n", k->num_keycodes);
                }
                break;
            case XIValuatorClass:
                {
                    XIValuatorClassInfo *v = (XIValuatorClassInfo*)classes[i];
                    char *name = v->label ?  XGetAtomName(display, v->label) : NULL;

                    /* Bug in X servers 1.7..1.8.1, mode was | OutOfProximity */
                    v->mode &= DeviceMode;

                    printf("XIValuatorClass\n");
                    printf("\t\tDetail for Valuator %d:\n", v->number);
                    printf("\t\t  Label: %s\n",  (name) ? name : "None");
                    printf("\t\t  Range: %f - %f\n", v->min, v->max);
                    printf("\t\t  Resolution: %d units/m\n", v->resolution);
                    printf("\t\t  Mode: %s\n", v->mode == Absolute ? "absolute" :
                            "relative");
                    if (v->mode == Absolute)
                        printf("\t\t  Current value: %f\n", v->value);
                    XFree(name);
                }
                break;
#if HAVE_XI21
            case XIScrollClass:
                {
                    XIScrollClassInfo *s = (XIScrollClassInfo*)classes[i];

                    printf("XIScrollClass\n");
                    printf("\t\tScroll info for Valuator %d\n", s->number);
                    printf("\t\t  type: %d (%s)\n", s->scroll_type,
                           (s->scroll_type == XIScrollTypeHorizontal) ? "horizontal" :
                              (s->scroll_type == XIScrollTypeVertical) ? "vertical" : "unknown");
                    printf("\t\t  increment: %f\n", s->increment);
                    printf("\t\t  flags: 0x%x", s->flags);
                    if (s->flags) {
                        printf(" (");
                        if (s->flags & XIScrollFlagNoEmulation)
                            printf(" no-emulation ");
                        if (s->flags & XIScrollFlagPreferred)
                            printf(" preferred ");
                        printf(")");
                    }
                    printf("\n");
                }
                break;
#endif
#if HAVE_XI22
            case XITouchClass:
                {
                    XITouchClassInfo *t = (XITouchClassInfo*)classes[i];

                    printf("XITouchClass\n");
                    printf("\t\tTouch mode: %s\n",
                           (t->mode == XIDirectTouch) ? "direct" : "dependent");
                    printf("\t\tMax number of touches: %d\n", t->num_touches);
                }
#endif
        }
    }

    printf("\n");
}

static void
print_info_xi2(Display* display, XIDeviceInfo *dev, enum print_format format)
{
    if (format == FORMAT_NAME)
    {
        printf("%s\n", dev->name);
        return;
    } else if (format == FORMAT_ID)
    {
        printf("%d\n", dev->deviceid);
        return;
    }

    printf("%-40s\tid=%d\t[", dev->name, dev->deviceid);
    switch(dev->use)
    {
        case XIMasterPointer:
            printf("master pointer  (%d)]\n", dev->attachment);
            break;
        case XIMasterKeyboard:
            printf("master keyboard (%d)]\n", dev->attachment);
            break;
        case XISlavePointer:
            printf("slave  pointer  (%d)]\n", dev->attachment);
            break;
        case XISlaveKeyboard:
            printf("slave  keyboard (%d)]\n", dev->attachment);
            break;
        case XIFloatingSlave:
            printf("floating slave]\n");
            break;
    }

    if (format == FORMAT_SHORT)
        return;

    if (!dev->enabled)
        printf("\tThis device is disabled\n");

    print_classes_xi2(display, dev->classes, dev->num_classes);
}


static int
list_xi2(Display *display,
         enum print_format format)
{
    int ndevices;
    int i, j;
    XIDeviceInfo *info, *dev;

    info = XIQueryDevice(display, XIAllDevices, &ndevices);

    for(i = 0; i < ndevices; i++)
    {
        dev = &info[i];
        if (dev->use == XIMasterPointer || dev->use == XIMasterKeyboard)
        {
            if (format == FORMAT_SHORT || format == FORMAT_LONG)
            {
                if (have_utf8())
                    if (dev->use == XIMasterPointer)
                        printf("⎡ ");
                    else
                        printf("⎣ ");
                else
                    printf("+ ");
            }
   
            print_info_xi2(display, dev, format);
            for (j = 0; j < ndevices; j++)
            {
                XIDeviceInfo* sd = &info[j];

                if ((sd->use == XISlavePointer || sd->use == XISlaveKeyboard) &&
                     (sd->attachment == dev->deviceid))
                {
                    if (format == FORMAT_SHORT || format == FORMAT_LONG)
                        if (have_utf8())
                            printf("%s   ↳ ", dev->use == XIMasterPointer ? "⎜" : " ");
                        else
                            printf("%s   + ", dev->use == XIMasterPointer ? "|" : " ");
                    print_info_xi2(display, sd, format);
                }
            }
        }
    }

    for (i = 0; i < ndevices; i++)
    {
        dev = &info[i];
        if (dev->use == XIFloatingSlave)
        {
            printf("∼ ");
            print_info_xi2(display, dev, format);
        }
    }


    XIFreeDeviceInfo(info);
    return EXIT_SUCCESS;
}
#endif

int
list(Display	*display,
     int	argc,
     char	*argv[],
     char	*name,
     char	*desc)
{
    enum print_format format = FORMAT_NONE;
    int arg_dev = 1;

    if (argc >= 1)
    {
        if (strcmp(argv[0], "--short") == 0)
            format = FORMAT_SHORT;
        else if (strcmp(argv[0], "--long") == 0)
            format = FORMAT_LONG;
        else if (strcmp(argv[0], "--name-only") == 0)
            format = FORMAT_NAME;
        else if (strcmp(argv[0], "--id-only") == 0)
            format = FORMAT_ID;
        else
            arg_dev--;
    }

    if (argc > arg_dev)
    {
        if (format == FORMAT_NONE)
            format = FORMAT_LONG;
#ifdef HAVE_XI2
        if (xinput_version(display) == XI_2_Major)
        {
            XIDeviceInfo *info = xi2_find_device_info(display, argv[arg_dev]);

            if (!info) {
                fprintf(stderr, "unable to find device %s\n", argv[arg_dev]);
                return EXIT_FAILURE;
            } else {
                print_info_xi2(display, info, format);
                return EXIT_SUCCESS;
            }
        } else
#endif
        {
            XDeviceInfo *info = find_device_info(display, argv[arg_dev], False);

            if (!info) {
                fprintf(stderr, "unable to find device %s\n", argv[arg_dev]);
                return EXIT_FAILURE;
            } else {
                print_info(display, info, format);
                return EXIT_SUCCESS;
            }
        }
    } else {
        if (format == FORMAT_NONE)
            format = FORMAT_SHORT;
#ifdef HAVE_XI2
        if (xinput_version(display) == XI_2_Major)
            return list_xi2(display, format);
#endif
        return list_xi1(display, format);
    }
}

Bool
have_utf8(void){
    char *t;

    /*
     * There is no standard way to detect UTF-8 capabilities of a
     * given terminal, but this gets pretty close as a good heuristic.
     */
    if ((t = getenv("LC_ALL")) == NULL) {
	if ((t = getenv("LC_CTYPE")) == NULL) {
	    t = getenv("LANG");
	}
    }

    if (t != NULL && (strcasestr(t, "UTF-8") != NULL ||
      strcasestr(t, "UTF8") != NULL))
	return True;

    return False;
}

/* end of list.c */
@


1.8
log
@Update to xinput 1.6.0
@
text
@d83 5
a87 2
    if(info->type != None)
	printf("\tType is %s\n", XGetAtomName(dpy, info->type));
@


1.7
log
@Update to xinput 1.5.4
@
text
@d26 9
a34 1
#include <X11/extensions/XIproto.h> /* for XI_Device***ChangedNotify */
d37 1
a37 1
print_info(Display* dpy, XDeviceInfo	*info, Bool shortformat)
d46 10
d80 1
a80 1
    if (shortformat)
d125 1
a125 1
                    int	        shortformat)
d133 1
a133 1
        print_info(display, info+loop, shortformat);
d149 1
a149 1
        printf("\t\tClass originated from: %d\n", classes[i]->sourceid);
d156 1
d162 4
a165 1
                        printf(" %s", (name) ? name : "None");
d180 1
d189 1
a189 2
                    /* XXX: Bug in X servers 1.7..1.8.1, mode was |
                       OutOfProximity. Remove this once 1.9 is out. */
d192 1
d204 35
d246 1
a246 1
print_info_xi2(Display* display, XIDeviceInfo *dev, Bool shortformat)
d248 10
d278 1
a278 1
    if (shortformat)
d290 1
a290 1
         int     shortformat)
a291 2
    int major = 2,
        minor = 0;
a295 7
    if (XIQueryVersion(display, &major, &minor) != Success ||
        (major * 1000 + minor) < 2000)
    {
        fprintf(stderr, "XI2 not supported.\n");
        return EXIT_FAILURE;
    }

d303 7
a309 3
	    if (have_utf8())
                if (dev->use == XIMasterPointer)
                    printf("⎡ ");
d311 4
a314 5
                    printf("⎣ ");
	    else
		printf("+ ");

            print_info_xi2(display, dev, shortformat);
d322 6
a327 5
		    if (have_utf8())
                        printf("%s   ↳ ", dev->use == XIMasterPointer ? "⎜" : " ");
                    else
		        printf("%s   + ", dev->use == XIMasterPointer ? "|" : " ");
                    print_info_xi2(display, sd, shortformat);
d339 1
a339 1
            print_info_xi2(display, dev, shortformat);
d356 16
a371 3
    int shortformat = (argc >= 1 && strcmp(argv[0], "--short") == 0);
    int longformat = (argc >= 1 && strcmp(argv[0], "--long") == 0);
    int arg_dev = shortformat || longformat;
d375 2
d386 1
a386 1
                print_info_xi2(display, info, shortformat);
d398 1
a398 1
                print_info(display, info, shortformat);
d403 2
d407 1
a407 1
            return list_xi2(display, !longformat);
d409 1
a409 1
        return list_xi1(display, !longformat);
@


1.6
log
@Use ASCII art when the environment is not UTF-8 capable.OB
Based on an initial patch by jasper@@, ok jasper@@.
@
text
@d224 2
a225 2
    int major = XI_2_Major,
        minor = XI_2_Minor;
d231 1
a231 1
        (major * 1000 + minor) < (XI_2_Major * 1000 + XI_2_Minor))
@


1.5
log
@Update to xinput 1.5.3
@
text
@d244 7
a250 4
            if (dev->use == XIMasterPointer)
                printf("⎡ ");
            else
                printf("⎣ ");
d260 4
a263 1
                    printf("%s   ↳ ", dev->use == XIMasterPointer ? "⎜" : " ");
d331 21
@


1.4
log
@Udate to xinput version 1.5.0
@
text
@d166 4
@


1.3
log
@update to xinput 1.4.2
@
text
@a36 3
#if HAVE_XI2
    XAttachInfoPtr      att;
#endif
a97 6
#if HAVE_XI2
            case AttachClass:
                att = (XAttachInfoPtr)any;
                printf("\tAttached to %d\n", att->attached);
                break;
#endif
d106 2
a107 6
int
list(Display	*display,
     int	argc,
     char	*argv[],
     char	*name,
     char	*desc)
d111 1
a111 2
    int                 shortformat = False;
    int                 daemon = False;
d113 6
a118 2
    shortformat = (argc == 1 && strcmp(argv[0], "--short") == 0);
    daemon = (argc == 1 && strcmp(argv[0], "--loop") == 0);
d120 7
a126 3
    if (argc == 0 || shortformat || daemon) {
	int		num_devices;
        XEvent  ev;
d128 5
a132 2
#if HAVE_XI2
        if (daemon)
d134 43
a176 3
            XiSelectEvent(display, DefaultRootWindow(display), NULL,
                          XI_DeviceHierarchyChangedMask |
                          XI_DeviceClassesChangedMask);
d178 56
a233 1
#endif
d235 9
a243 5
        do {
            info = XListInputDevices(display, &num_devices);
            for(loop=0; loop<num_devices; loop++) {
                print_info(display, info+loop, shortformat);
            }
d245 2
a246 3
#if HAVE_XI2
            /* just wait for the next generic event to come along */
            while (daemon && !XNextEvent(display, &ev))
d248 4
a251 1
                if (ev.type == GenericEvent)
d253 2
a254 12
                    XGenericEvent* gev = (XGenericEvent*)&ev;
                    /* we just assume that extension is IReqCode, pretty save
                       since we don't register for other events. */
                    if (gev->evtype == XI_DeviceHierarchyChangedNotify)
                    {
                        printf("Hierarchy change.\n");
                    } else if (gev->evtype == XI_DeviceClassesChangedNotify)
                    {
                        printf("Device classes changed.\n");
                        free(((XDeviceClassesChangedEvent*)&ev)->inputclassinfo);
                    }
                    break;
d257 17
a274 3
        } while(daemon);
    } else {
	int	ret = EXIT_SUCCESS;
d276 29
a304 2
	for(loop=0; loop<argc; loop++) {
	    info = find_device_info(display, argv[loop], False);
d306 14
a319 8
	    if (!info) {
		fprintf(stderr, "unable to find device %s\n", argv[loop]);
		ret = EXIT_FAILURE;
	    } else {
		print_info(display, info, shortformat);
	    }
	}
	return ret;
a320 1
    return EXIT_SUCCESS;
@


1.2
log
@update to xinput 1.4.1
@
text
@d29 1
a29 1
print_info(XDeviceInfo	*info, Bool shortformat)
d68 3
d146 1
a146 1
                print_info(info+loop, shortformat);
d181 1
a181 1
		print_info(info, shortformat);
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
 * documentation, and that   the  name of  Frederic   Lepied not  be  used  in
d10 1
a10 1
 * specific,  written      prior  permission.     Frederic  Lepied   makes  no
d14 1
a14 1
 * FREDERIC  LEPIED DISCLAIMS ALL   WARRANTIES WITH REGARD  TO  THIS SOFTWARE,
d16 1
a16 1
 * EVENT  SHALL FREDERIC  LEPIED BE   LIABLE   FOR ANY  SPECIAL, INDIRECT   OR
d26 1
d37 3
d98 6
a103 1

d122 1
d125 1
d127 1
a127 1
    if (argc == 0 || shortformat) {
d129 1
d131 37
a167 5
	info = XListInputDevices(display, &num_devices);

	for(loop=0; loop<num_devices; loop++) {
	    print_info(info+loop, shortformat);
	}
d172 1
a172 1
	    info = find_device_info(display, argv[0], False);
d175 1
a175 1
		fprintf(stderr, "unable to find device %s\n", argv[0]);
@


1.1.1.1
log
@Import xinput 1.3.0. Replaces xsetmode(1)/xsetpointer(1).
@
text
@@
