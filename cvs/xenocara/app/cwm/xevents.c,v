head	1.126;
access;
symbols
	OPENBSD_6_1_BASE:1.126
	OPENBSD_6_0:1.120.0.4
	OPENBSD_6_0_BASE:1.120
	OPENBSD_5_9:1.120.0.2
	OPENBSD_5_9_BASE:1.120
	OPENBSD_5_8:1.118.0.2
	OPENBSD_5_8_BASE:1.118
	OPENBSD_5_7:1.116.0.2
	OPENBSD_5_7_BASE:1.116
	OPENBSD_5_6:1.111.0.4
	OPENBSD_5_6_BASE:1.111
	OPENBSD_5_5:1.111.0.2
	OPENBSD_5_5_BASE:1.111
	OPENBSD_5_4:1.90.0.2
	OPENBSD_5_4_BASE:1.90
	OPENBSD_5_3:1.70.0.2
	OPENBSD_5_3_BASE:1.70
	OPENBSD_5_2:1.65.0.2
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.2
	OPENBSD_5_0:1.54.0.2
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.49.0.6
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.41.0.2
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.126
date	2016.10.18.17.03.30;	author okan;	state Exp;
branches;
next	1.125;
commitid	dIOrHVlb55Ubzrpl;

1.125
date	2016.10.06.14.41.19;	author okan;	state Exp;
branches;
next	1.124;
commitid	dEdTnOYrabSl1oRa;

1.124
date	2016.10.04.20.15.55;	author okan;	state Exp;
branches;
next	1.123;
commitid	vRGk95BhViXMArN6;

1.123
date	2016.10.03.13.41.30;	author okan;	state Exp;
branches;
next	1.122;
commitid	orUFke6gsTLo5w4T;

1.122
date	2016.09.16.14.32.02;	author okan;	state Exp;
branches;
next	1.121;
commitid	JzYS0uWdEYDeM0Hk;

1.121
date	2016.09.14.19.45.33;	author okan;	state Exp;
branches;
next	1.120;
commitid	lAQwIuCLXRGzG7kf;

1.120
date	2015.11.10.20.05.33;	author okan;	state Exp;
branches;
next	1.119;
commitid	vKzF5zXTpUgY9uJK;

1.119
date	2015.08.27.18.42.56;	author okan;	state Exp;
branches;
next	1.118;
commitid	koe4Jefm6ZQVksWN;

1.118
date	2015.07.01.14.36.42;	author okan;	state Exp;
branches;
next	1.117;
commitid	HEkKIvh6L9ijX1lH;

1.117
date	2015.06.30.14.01.43;	author okan;	state Exp;
branches;
next	1.116;
commitid	h5qrb2HfsKgjVuzR;

1.116
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.115;
commitid	kLADTGYX3gw0Sf2m;

1.115
date	2014.09.27.19.04.32;	author okan;	state Exp;
branches;
next	1.114;
commitid	X6SwRTs6gMlrxQ8N;

1.114
date	2014.09.15.13.00.49;	author okan;	state Exp;
branches;
next	1.113;
commitid	VPtTUp6sF9rrEiW2;

1.113
date	2014.09.07.17.38.38;	author okan;	state Exp;
branches;
next	1.112;
commitid	idgYRjbgDXLP4UK7;

1.112
date	2014.09.06.16.08.58;	author okan;	state Exp;
branches;
next	1.111;
commitid	hqjCXxcyI22RFKvg;

1.111
date	2014.02.03.20.20.39;	author okan;	state Exp;
branches;
next	1.110;

1.110
date	2014.02.02.21.34.05;	author okan;	state Exp;
branches;
next	1.109;

1.109
date	2014.01.30.15.41.11;	author okan;	state Exp;
branches;
next	1.108;

1.108
date	2014.01.29.21.13.52;	author okan;	state Exp;
branches;
next	1.107;

1.107
date	2014.01.28.13.40.40;	author okan;	state Exp;
branches;
next	1.106;

1.106
date	2014.01.22.21.48.27;	author okan;	state Exp;
branches;
next	1.105;

1.105
date	2014.01.20.23.03.51;	author okan;	state Exp;
branches;
next	1.104;

1.104
date	2014.01.03.15.29.06;	author okan;	state Exp;
branches;
next	1.103;

1.103
date	2014.01.02.22.43.55;	author okan;	state Exp;
branches;
next	1.102;

1.102
date	2014.01.02.22.26.27;	author okan;	state Exp;
branches;
next	1.101;

1.101
date	2014.01.02.21.30.20;	author okan;	state Exp;
branches;
next	1.100;

1.100
date	2013.12.13.14.45.47;	author okan;	state Exp;
branches;
next	1.99;

1.99
date	2013.12.13.14.40.52;	author okan;	state Exp;
branches;
next	1.98;

1.98
date	2013.12.12.20.15.07;	author okan;	state Exp;
branches;
next	1.97;

1.97
date	2013.12.11.15.41.11;	author okan;	state Exp;
branches;
next	1.96;

1.96
date	2013.12.11.14.16.09;	author okan;	state Exp;
branches;
next	1.95;

1.95
date	2013.12.02.14.30.12;	author okan;	state Exp;
branches;
next	1.94;

1.94
date	2013.11.27.16.24.17;	author okan;	state Exp;
branches;
next	1.93;

1.93
date	2013.11.27.00.01.23;	author okan;	state Exp;
branches;
next	1.92;

1.92
date	2013.11.12.21.25.00;	author okan;	state Exp;
branches;
next	1.91;

1.91
date	2013.10.25.19.46.16;	author okan;	state Exp;
branches;
next	1.90;

1.90
date	2013.07.15.23.51.59;	author okan;	state Exp;
branches;
next	1.89;

1.89
date	2013.07.15.14.50.44;	author okan;	state Exp;
branches;
next	1.88;

1.88
date	2013.07.10.14.15.58;	author okan;	state Exp;
branches;
next	1.87;

1.87
date	2013.07.08.18.19.22;	author okan;	state Exp;
branches;
next	1.86;

1.86
date	2013.07.08.15.46.16;	author okan;	state Exp;
branches;
next	1.85;

1.85
date	2013.06.10.21.37.30;	author okan;	state Exp;
branches;
next	1.84;

1.84
date	2013.06.10.20.11.43;	author okan;	state Exp;
branches;
next	1.83;

1.83
date	2013.05.23.16.52.39;	author okan;	state Exp;
branches;
next	1.82;

1.82
date	2013.05.21.00.29.20;	author okan;	state Exp;
branches;
next	1.81;

1.81
date	2013.05.20.21.32.00;	author okan;	state Exp;
branches;
next	1.80;

1.80
date	2013.05.20.21.19.15;	author okan;	state Exp;
branches;
next	1.79;

1.79
date	2013.05.19.17.05.52;	author okan;	state Exp;
branches;
next	1.78;

1.78
date	2013.05.19.17.03.55;	author okan;	state Exp;
branches;
next	1.77;

1.77
date	2013.05.19.17.01.29;	author okan;	state Exp;
branches;
next	1.76;

1.76
date	2013.05.11.22.01.07;	author okan;	state Exp;
branches;
next	1.75;

1.75
date	2013.05.10.16.32.48;	author okan;	state Exp;
branches;
next	1.74;

1.74
date	2013.05.10.16.05.34;	author okan;	state Exp;
branches;
next	1.73;

1.73
date	2013.05.10.15.44.43;	author okan;	state Exp;
branches;
next	1.72;

1.72
date	2013.04.29.00.56.48;	author okan;	state Exp;
branches;
next	1.71;

1.71
date	2013.04.05.17.07.25;	author okan;	state Exp;
branches;
next	1.70;

1.70
date	2012.12.18.17.37.39;	author okan;	state Exp;
branches;
next	1.69;

1.69
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.68;

1.68
date	2012.11.07.14.49.46;	author okan;	state Exp;
branches;
next	1.67;

1.67
date	2012.09.12.15.09.33;	author okan;	state Exp;
branches;
next	1.66;

1.66
date	2012.09.10.13.28.04;	author okan;	state Exp;
branches;
next	1.65;

1.65
date	2012.07.13.17.01.04;	author okan;	state Exp;
branches;
next	1.64;

1.64
date	2012.07.13.15.21.35;	author okan;	state Exp;
branches;
next	1.63;

1.63
date	2012.07.06.14.18.00;	author okan;	state Exp;
branches;
next	1.62;

1.62
date	2012.07.05.17.35.13;	author okan;	state Exp;
branches;
next	1.61;

1.61
date	2012.07.03.13.49.03;	author okan;	state Exp;
branches;
next	1.60;

1.60
date	2012.05.16.21.57.21;	author okan;	state Exp;
branches;
next	1.59;

1.59
date	2012.05.16.01.09.17;	author okan;	state Exp;
branches;
next	1.58;

1.58
date	2012.05.16.01.04.36;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2012.05.13.15.17.13;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2011.09.13.08.41.57;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2011.08.22.16.34.34;	author oga;	state Exp;
branches;
next	1.54;

1.54
date	2011.06.24.05.33.41;	author okan;	state Exp;
branches;
next	1.53;

1.53
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2011.05.06.19.39.44;	author oga;	state Exp;
branches;
next	1.51;

1.51
date	2011.03.22.10.49.46;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.25.20.04.55;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.47;

1.47
date	2009.12.11.17.51.42;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2009.12.10.23.14.58;	author oga;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.10.17.16.51;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.28.17.52.12;	author tobias;	state Exp;
branches;
next	1.43;

1.43
date	2009.08.27.01.38.08;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2009.08.24.23.49.04;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2009.05.18.00.14.19;	author oga;	state Exp;
branches;
next	1.40;

1.40
date	2009.05.01.17.50.20;	author okan;	state Exp;
branches;
next	1.39;

1.39
date	2009.03.28.16.38.54;	author martynas;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.23.18.58.40;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.22.19.01.56;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.17.20.39.24;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.17.18.41.50;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.16.16.49.17;	author okan;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.16.15.24.14;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.11.18.25.49;	author okan;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.06.00.18.07;	author okan;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.04.23.55.04;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.29.23.16.46;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.22.14.28.04;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.22.14.15.03;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2008.07.22.21.01.54;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.18.19.09.12;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.17.23.40.33;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.17.20.55.48;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.17.20.21.17;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.14.22.04.11;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.14.21.48.54;	author okan;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.13.03.41.58;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.12.05.01.13;	author okan;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.21.14.11.19;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.19.12.56.58;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.18.20.06.36;	author okan;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.15.22.18.00;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.16.13.35.37;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.08.00.09.50;	author simon;	state Exp;
branches;
next	1.9;

1.9
date	2008.04.07.23.47.09;	author simon;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.23.15.09.21;	author simon;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.22.15.09.45;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.22.14.09.02;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.20.12.56.10;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.16.11.39.20;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.126
log
@Refactor callbacks to take a void * so as to not try and generalize into
client_ctx in keypress and buttonpress event handlers; pass appropriate *ctx's
based on context.

While here, limit some globals, replace defines with appropriate variables and
fix some naming.
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: xevents.c,v 1.125 2016/10/06 14:41:19 okan Exp $
 */

/*
 * NOTE:
 *   It is the responsibility of the caller to deal with memory
 *   management of the xevent's.
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

static void	 xev_handle_maprequest(XEvent *);
static void	 xev_handle_unmapnotify(XEvent *);
static void	 xev_handle_destroynotify(XEvent *);
static void	 xev_handle_configurerequest(XEvent *);
static void	 xev_handle_propertynotify(XEvent *);
static void	 xev_handle_enternotify(XEvent *);
static void	 xev_handle_buttonpress(XEvent *);
static void	 xev_handle_buttonrelease(XEvent *);
static void	 xev_handle_keypress(XEvent *);
static void	 xev_handle_keyrelease(XEvent *);
static void	 xev_handle_clientmessage(XEvent *);
static void	 xev_handle_randr(XEvent *);
static void	 xev_handle_mappingnotify(XEvent *);
static void	 xev_handle_expose(XEvent *);

void		(*xev_handlers[LASTEvent])(XEvent *) = {
			[MapRequest] = xev_handle_maprequest,
			[UnmapNotify] = xev_handle_unmapnotify,
			[DestroyNotify] = xev_handle_destroynotify,
			[ConfigureRequest] = xev_handle_configurerequest,
			[PropertyNotify] = xev_handle_propertynotify,
			[EnterNotify] = xev_handle_enternotify,
			[ButtonPress] = xev_handle_buttonpress,
			[ButtonRelease] = xev_handle_buttonrelease,
			[KeyPress] = xev_handle_keypress,
			[KeyRelease] = xev_handle_keyrelease,
			[ClientMessage] = xev_handle_clientmessage,
			[MappingNotify] = xev_handle_mappingnotify,
			[Expose] = xev_handle_expose,
};

static KeySym modkeys[] = { XK_Alt_L, XK_Alt_R, XK_Super_L, XK_Super_R,
			    XK_Control_L, XK_Control_R };

static void
xev_handle_maprequest(XEvent *ee)
{
	XMapRequestEvent	*e = &ee->xmaprequest;
	struct client_ctx	*cc = NULL, *old_cc;

	if ((old_cc = client_current()) != NULL)
		client_ptrsave(old_cc);

	if ((cc = client_find(e->window)) == NULL)
		cc = client_init(e->window, NULL, 0);

	if ((cc != NULL) && (!(cc->flags & CLIENT_IGNORE)))
		client_ptrwarp(cc);
}

static void
xev_handle_unmapnotify(XEvent *ee)
{
	XUnmapEvent		*e = &ee->xunmap;
	struct client_ctx	*cc;

	if ((cc = client_find(e->window)) != NULL) {
		if (e->send_event) {
			client_set_wm_state(cc, WithdrawnState);
		} else {
			if (!(cc->flags & CLIENT_HIDDEN))
				client_delete(cc);
		}
	}
}

static void
xev_handle_destroynotify(XEvent *ee)
{
	XDestroyWindowEvent	*e = &ee->xdestroywindow;
	struct client_ctx	*cc;

	if ((cc = client_find(e->window)) != NULL)
		client_delete(cc);
}

static void
xev_handle_configurerequest(XEvent *ee)
{
	XConfigureRequestEvent	*e = &ee->xconfigurerequest;
	struct client_ctx	*cc;
	struct screen_ctx	*sc;
	XWindowChanges		 wc;

	if ((cc = client_find(e->window)) != NULL) {
		sc = cc->sc;

		if (e->value_mask & CWWidth)
			cc->geom.w = e->width;
		if (e->value_mask & CWHeight)
			cc->geom.h = e->height;
		if (e->value_mask & CWX)
			cc->geom.x = e->x;
		if (e->value_mask & CWY)
			cc->geom.y = e->y;
		if (e->value_mask & CWBorderWidth)
			cc->bwidth = e->border_width;
		if (e->value_mask & CWSibling)
			wc.sibling = e->above;
		if (e->value_mask & CWStackMode)
			wc.stack_mode = e->detail;

		if (cc->geom.x == 0 && cc->geom.w >= sc->view.w)
			cc->geom.x -= cc->bwidth;

		if (cc->geom.y == 0 && cc->geom.h >= sc->view.h)
			cc->geom.y -= cc->bwidth;

		wc.x = cc->geom.x;
		wc.y = cc->geom.y;
		wc.width = cc->geom.w;
		wc.height = cc->geom.h;
		wc.border_width = cc->bwidth;

		XConfigureWindow(X_Dpy, cc->win, e->value_mask, &wc);
		client_config(cc);
	} else {
		/* let it do what it wants, it'll be ours when we map it. */
		wc.x = e->x;
		wc.y = e->y;
		wc.width = e->width;
		wc.height = e->height;
		wc.border_width = e->border_width;
		wc.stack_mode = Above;
		e->value_mask &= ~CWStackMode;

		XConfigureWindow(X_Dpy, e->window, e->value_mask, &wc);
	}
}

static void
xev_handle_propertynotify(XEvent *ee)
{
	XPropertyEvent		*e = &ee->xproperty;
	struct screen_ctx	*sc;
	struct client_ctx	*cc;

	if ((cc = client_find(e->window)) != NULL) {
		switch (e->atom) {
		case XA_WM_NORMAL_HINTS:
			client_getsizehints(cc);
			break;
		case XA_WM_NAME:
			client_setname(cc);
			break;
		case XA_WM_HINTS:
			client_wm_hints(cc);
			client_draw_border(cc);
			break;
		case XA_WM_TRANSIENT_FOR:
			client_transient(cc);
			break;
		default:
			/* do nothing */
			break;
		}
	} else {
		TAILQ_FOREACH(sc, &Screenq, entry) {
			if (sc->rootwin == e->window) {
				if (e->atom == ewmh[_NET_DESKTOP_NAMES])
					xu_ewmh_net_desktop_names(sc);
			}
		}
	}
}

static void
xev_handle_enternotify(XEvent *ee)
{
	XCrossingEvent		*e = &ee->xcrossing;
	struct client_ctx	*cc;

	Last_Event_Time = e->time;

	if ((cc = client_find(e->window)) != NULL)
		client_setactive(cc);
}

/* We can split this into two event handlers. */
static void
xev_handle_buttonpress(XEvent *ee)
{
	XButtonEvent		*e = &ee->xbutton;
	struct client_ctx	*cc;
	struct screen_ctx	*sc;
	struct bind_ctx		*mb;

	e->state &= ~IGNOREMODMASK;

	TAILQ_FOREACH(mb, &Conf.mousebindq, entry) {
		if (e->button == mb->press.button && e->state == mb->modmask)
			break;
	}

	if (mb == NULL)
		return;
	switch (mb->context) {
	case CWM_CONTEXT_CC:
		if (((cc = client_find(e->window)) == NULL) &&
		    (cc = client_current()) == NULL)
			return;
		(*mb->callback)(cc, &mb->argument, CWM_XEV_BTN);
		break;
	case CWM_CONTEXT_SC:
		if (e->window != e->root)
			return;
		if ((sc = screen_find(e->window)) == NULL)
			return;
		(*mb->callback)(sc, &mb->argument, CWM_XEV_BTN);
		break;
	case CWM_CONTEXT_NONE:
		(*mb->callback)(NULL, &mb->argument, CWM_XEV_BTN);
		break;
	}
}

static void
xev_handle_buttonrelease(XEvent *ee)
{
	XButtonEvent		*e = &ee->xbutton;
	struct client_ctx	*cc;

	if ((cc = client_find(e->window)) != NULL) {
		if (cc->flags & CLIENT_ACTIVE)
			group_toggle_membership_leave(cc);
	}
}

static void
xev_handle_keypress(XEvent *ee)
{
	XKeyEvent		*e = &ee->xkey;
	struct client_ctx	*cc;
	struct screen_ctx	*sc;
	struct bind_ctx		*kb;
	KeySym			 keysym, skeysym;
	unsigned int		 modshift;

	keysym = XkbKeycodeToKeysym(X_Dpy, e->keycode, 0, 0);
	skeysym = XkbKeycodeToKeysym(X_Dpy, e->keycode, 0, 1);

	e->state &= ~IGNOREMODMASK;

	TAILQ_FOREACH(kb, &Conf.keybindq, entry) {
		if (keysym != kb->press.keysym && skeysym == kb->press.keysym)
			modshift = ShiftMask;
		else
			modshift = 0;

		if ((kb->modmask | modshift) != e->state)
			continue;

		if (kb->press.keysym == ((modshift == 0) ? keysym : skeysym))
			break;
	}

	if (kb == NULL)
		return;
	switch (kb->context) {
	case CWM_CONTEXT_CC:
		if (((cc = client_find(e->window)) == NULL) &&
		    (cc = client_current()) == NULL)
			return;
		(*kb->callback)(cc, &kb->argument, CWM_XEV_KEY);
		break;
	case CWM_CONTEXT_SC:
		if ((sc = screen_find(e->window)) == NULL)
			return;
		(*kb->callback)(sc, &kb->argument, CWM_XEV_KEY);
		break;
	case CWM_CONTEXT_NONE:
		(*kb->callback)(NULL, &kb->argument, CWM_XEV_KEY);
		break;
	}
}

/*
 * This is only used for the modifier suppression detection.
 */
static void
xev_handle_keyrelease(XEvent *ee)
{
	XKeyEvent		*e = &ee->xkey;
	struct screen_ctx	*sc;
	KeySym			 keysym;
	unsigned int		 i;

	if ((sc = screen_find(e->root)) == NULL)
		return;

	keysym = XkbKeycodeToKeysym(X_Dpy, e->keycode, 0, 0);
	for (i = 0; i < nitems(modkeys); i++) {
		if (keysym == modkeys[i]) {
			client_cycle_leave(sc);
			break;
		}
	}
}

static void
xev_handle_clientmessage(XEvent *ee)
{
	XClientMessageEvent	*e = &ee->xclient;
	struct client_ctx	*cc, *old_cc;
	struct screen_ctx       *sc;

	if (e->message_type == cwmh[WM_CHANGE_STATE]) {
		if ((cc = client_find(e->window)) != NULL) {
	    		if (e->data.l[0] == IconicState)
				client_hide(cc);
		}
	} else if (e->message_type == ewmh[_NET_CLOSE_WINDOW]) {
		if ((cc = client_find(e->window)) != NULL) {
			client_send_delete(cc);
		}
	} else if (e->message_type == ewmh[_NET_ACTIVE_WINDOW]) {
		if ((cc = client_find(e->window)) != NULL) {
			if ((old_cc = client_current()) != NULL)
				client_ptrsave(old_cc);
			if (cc->flags & CLIENT_HIDDEN)
				client_unhide(cc);
			else
				client_raise(cc);
			client_ptrwarp(cc);
		}
	} else if (e->message_type == ewmh[_NET_WM_DESKTOP]) {
		if ((cc = client_find(e->window)) != NULL) {
			/*
			 * The EWMH spec states that if the cardinal returned
			 * is 0xFFFFFFFF (-1) then the window should appear
			 * on all desktops, in our case, group 0.
			 */
			if (e->data.l[0] == (unsigned long)-1)
				group_movetogroup(cc, 0);
			else
				group_movetogroup(cc, e->data.l[0]);
		}
	} else if (e->message_type == ewmh[_NET_WM_STATE]) {
		if ((cc = client_find(e->window)) != NULL) {
			xu_ewmh_handle_net_wm_state_msg(cc,
			    e->data.l[0], e->data.l[1], e->data.l[2]);
		}
	} else if (e->message_type == ewmh[_NET_CURRENT_DESKTOP]) {
		if ((sc = screen_find(e->window)) != NULL) {
			group_only(sc, e->data.l[0]);
		}
	}
}

static void
xev_handle_randr(XEvent *ee)
{
	XRRScreenChangeNotifyEvent	*rev = (XRRScreenChangeNotifyEvent *)ee;
	struct screen_ctx		*sc;
	int				 i;

	i = XRRRootToScreen(X_Dpy, rev->root);
	TAILQ_FOREACH(sc, &Screenq, entry) {
		if (sc->which == i) {
			XRRUpdateConfiguration(ee);
			screen_update_geometry(sc);
			screen_assert_clients_within(sc);
		}
	}
}

/*
 * Called when the keymap has changed.
 * Ungrab all keys, reload keymap and then regrab
 */
static void
xev_handle_mappingnotify(XEvent *ee)
{
	XMappingEvent		*e = &ee->xmapping;
	struct screen_ctx	*sc;

	XRefreshKeyboardMapping(e);
	if (e->request == MappingKeyboard) {
		TAILQ_FOREACH(sc, &Screenq, entry)
			conf_grab_kbd(sc->rootwin);
	}
}

static void
xev_handle_expose(XEvent *ee)
{
	XExposeEvent		*e = &ee->xexpose;
	struct client_ctx	*cc;

	if ((cc = client_find(e->window)) != NULL && e->count == 0)
		client_draw_border(cc);
}

void
xev_process(void)
{
	XEvent		 e;

	XNextEvent(X_Dpy, &e);
	if (e.type - Conf.xrandr_event_base == RRScreenChangeNotify)
		xev_handle_randr(&e);
	else if (e.type < LASTEvent && xev_handlers[e.type] != NULL)
		(*xev_handlers[e.type])(&e);
}
@


1.125
log
@Add an argument to the callbacks to pass the xevent context, button or
key press. This allows to remove a few hacks to duplicate functions only
for behaviour changes; now differing behaviours are pushed down to the
callback. Also will allow for previously unavailable actions to be bind-able
down the road.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.124 2016/10/04 20:15:55 okan Exp $
d223 3
a225 2
	struct client_ctx	*cc, fakecc;
	struct binding		*mb;
d229 1
a229 1
	TAILQ_FOREACH(mb, &Conf.mousebindingq, entry) {
d236 2
a237 1
	if (mb->context == CWM_CONTEXT_CLIENT) {
d241 3
a243 1
	} else {
d246 1
a246 2
		cc = &fakecc;
		if ((cc->sc = screen_find(e->window)) == NULL)
d248 5
a253 2

	(*mb->callback)(cc, &mb->argument, CWM_BTN);
d272 3
a274 2
	struct client_ctx	*cc = NULL, fakecc;
	struct binding		*kb;
d283 1
a283 1
	TAILQ_FOREACH(kb, &Conf.keybindingq, entry) {
d298 2
a299 1
	if (kb->context == CWM_CONTEXT_CLIENT) {
d303 4
a306 3
	} else {
		cc = &fakecc;
		if ((cc->sc = screen_find(e->window)) == NULL)
d308 5
a313 2

	(*kb->callback)(cc, &kb->argument, CWM_KEY);
d439 1
a439 1
	if (e.type - Randr_ev == RRScreenChangeNotify)
@


1.124
log
@When removing xrandr regions, ensure clients are within the bounds of
the screen; adapted from an ancient diff from Sviatoslav Chagaev. Things
in this area will likely change, but put this in so it works now and
serves as a reminder.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.123 2016/10/03 13:41:30 okan Exp $
d247 1
a247 1
	(*mb->callback)(cc, &mb->argument);
d301 1
a301 1
	(*kb->callback)(cc, &kb->argument);
@


1.123
log
@client_ptrwarp should not deal with unhiding or raising clients (non ptr
requests); most callers do this already - deal with the few that do not.
client_ptrwarp becomes a simple wrapper (setpos) but it will be expanded.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.122 2016/09/16 14:32:02 okan Exp $
d389 1
@


1.122
log
@During init, query screen for _NET_ACTIVE_WINDOW and set that client as
active; while we already look at what's under the pointer, use this
information first, then look under the pointer (saving that round-trip).
This restores the active state to a client after restart even if the
pointer is not above it (and of course the pointer is not above another
client).
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.121 2016/09/14 19:45:33 okan Exp $
d347 4
@


1.121
log
@Fix-up a few simple uses of client_current(): check CLIENT_ACTIVE flag
instead of relying on curcc.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.120 2015/11/10 20:05:33 okan Exp $
d84 1
a84 1
		cc = client_init(e->window, NULL);
@


1.120
log
@Start cleaning up name vs function differences; replace magic numbers.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.119 2015/08/27 18:42:56 okan Exp $
d253 2
a254 1
	struct client_ctx *cc;
d256 4
a259 2
	if ((cc = client_current()) != NULL)
		group_toggle_membership_leave(cc);
@


1.119
log
@Add consistent checks against NULL.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.118 2015/07/01 14:36:42 okan Exp $
d235 1
a235 1
	if (mb->flags & CWM_WIN) {
d288 1
a288 1
	if (kb->flags & CWM_WIN) {
@


1.118
log
@style
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.117 2015/06/30 14:01:43 okan Exp $
d80 1
a80 1
	if ((old_cc = client_current()))
d255 1
a255 1
	if ((cc = client_current()))
d342 1
a342 1
			if ((old_cc = client_current()))
@


1.117
log
@Re-implement XClientMessage handling so that we can feed screen_find and
client_find valid resources as needed, relieving the need for
screen_find to ungracefully handle invalid root windows. Removes a long
standing XXX.  Should theoretically allow XClientMessage handling on
more than one X screen.  Alter callers of screen_find to handle
failures.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.116 2015/01/19 14:54:16 okan Exp $
d282 1
a282 1
		if (kb->press.keysym == (modshift == 0 ? keysym : skeysym))
@


1.116
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.115 2014/09/27 19:04:32 okan Exp $
d243 2
a244 1
		cc->sc = screen_find(e->window);
d294 2
a295 1
		cc->sc = screen_find(e->window);
d312 2
a313 1
	sc = screen_find(e->root);
d331 36
a366 16
	sc = screen_find(e->window);

	if ((cc = client_find(e->window)) == NULL && e->window != sc->rootwin)
		return;

	if (e->message_type == cwmh[WM_CHANGE_STATE] && e->format == 32 &&
	    e->data.l[0] == IconicState)
		client_hide(cc);

	if (e->message_type == ewmh[_NET_CLOSE_WINDOW])
		client_send_delete(cc);

	if (e->message_type == ewmh[_NET_ACTIVE_WINDOW] && e->format == 32) {
		if ((old_cc = client_current()))
			client_ptrsave(old_cc);
		client_ptrwarp(cc);
a367 19

	if (e->message_type == ewmh[_NET_WM_DESKTOP] && e->format == 32) {
		/*
		 * The EWMH spec states that if the cardinal returned is
		 * 0xFFFFFFFF (-1) then the window should appear on all
		 * desktops, which in our case is assigned to group 0.
		 */
		if (e->data.l[0] == (unsigned long)-1)
			group_movetogroup(cc, 0);
		else
			group_movetogroup(cc, e->data.l[0]);
	}

	if (e->message_type == ewmh[_NET_WM_STATE] && e->format == 32)
		xu_ewmh_handle_net_wm_state_msg(cc,
		    e->data.l[0], e->data.l[1], e->data.l[2]);

	if (e->message_type == ewmh[_NET_CURRENT_DESKTOP] && e->format == 32)
		group_only(sc, e->data.l[0]);
@


1.115
log
@these have nothing to do with 'sticky', but rather group membership; rename.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.114 2014/09/15 13:00:49 okan Exp $
d27 1
a27 1
#include <sys/param.h>
d32 1
@


1.114
log
@use similiar style for client flags
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.113 2014/09/07 17:38:38 okan Exp $
d254 1
a254 1
		group_sticky_toggle_exit(cc);
@


1.113
log
@screen_fromroot -> screen_find
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.112 2014/09/06 16:08:58 okan Exp $
d85 1
a85 1
	if ((cc != NULL) && ((cc->flags & CLIENT_IGNORE) == 0))
@


1.112
log
@Rework group names: stash the group name inside the group_ctx as opposed
to having to manage an array outside in screen_ctx for group names and
shortcuts.  Simplifies (and moves bits for) reading, and constructing
data for, EWMH's _NET_DESKTOP_NAMES.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.111 2014/02/03 20:20:39 okan Exp $
d242 1
a242 1
		cc->sc = screen_fromroot(e->window);
d292 1
a292 1
		cc->sc = screen_fromroot(e->window);
d309 1
a309 1
	sc = screen_fromroot(e->root);
d327 1
a327 1
	sc = screen_fromroot(e->window);
@


1.111
log
@Move redundant bits from screen_init (while dealing with existing
clients) directly into client_init, performing the X roundtrip only
once. With the previous change in maprequest, this moves decision making
into one place for creating new clients.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.110 2014/02/02 21:34:05 okan Exp $
d199 1
a199 1
					group_update_names(sc);
@


1.110
log
@Move redundant window attr fetch from maprequest directly into
client_init and perform that X roundtrip only once.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.109 2014/01/30 15:41:11 okan Exp $
d83 1
a83 1
		cc = client_init(e->window, NULL, 1);
@


1.109
log
@Move cwm_status around to avoid header fu, and remove extraneous signal
header from xevents.c; noticed by Christian Neukirchen.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.108 2014/01/29 21:13:52 okan Exp $
a77 1
	XWindowAttributes	 xattr;
d82 2
a83 4
	if ((cc = client_find(e->window)) == NULL) {
		XGetWindowAttributes(X_Dpy, e->window, &xattr);
		cc = client_init(e->window, screen_fromroot(xattr.root), 1);
	}
d85 1
a85 1
	if ((cc->flags & CLIENT_IGNORE) == 0)
@


1.108
log
@Merge keybinding and mousebinding queues into using the same merged
struct, binding; they were essentially the same accept for what was
'pressed', keysym or button.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.107 2014/01/28 13:40:40 okan Exp $
a31 1
#include <signal.h>
@


1.107
log
@The EWMH spec states that if the cardinal returned is 0xFFFFFFFF (-1)
then the window should appear on all desktops, which in our case is
assigned to group 0.  Found to fix stalonetray due to the non-ewmh aware
range checking in group_movetogroup(); from Thomas Adam.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.106 2014/01/22 21:48:27 okan Exp $
d227 1
a227 1
	struct mousebinding	*mb;
d232 1
a232 1
		if (e->button == mb->button && e->state == mb->modmask)
d266 1
a266 1
	struct keybinding	*kb;
d276 1
a276 1
		if (keysym != kb->keysym && skeysym == kb->keysym)
d284 1
a284 1
		if (kb->keysym == (modshift == 0 ? keysym : skeysym))
@


1.106
log
@Somewhat streamline event loop/restart/quit handling; most notable
change allows a restart to trigger proper teardown first, even though
teardown is not (yet) complete.

After some discussion with oga@@nicotinebsd.org regarding a more
complicated version/idea.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.105 2014/01/20 23:03:51 okan Exp $
d349 11
a359 2
	if (e->message_type == ewmh[_NET_WM_DESKTOP] && e->format == 32)
		group_movetogroup(cc, e->data.l[0]);
@


1.105
log
@merge KBFLAG_NEEDCLIENT and MOUSEBIND_CTX_*; brings kbfunc and mousefunc
bits even closer.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.104 2014/01/03 15:29:06 okan Exp $
a402 2
volatile sig_atomic_t	xev_quit = 0;

d404 1
a404 1
xev_loop(void)
d408 5
a412 7
	while (xev_quit == 0) {
		XNextEvent(X_Dpy, &e);
		if (e.type - Randr_ev == RRScreenChangeNotify)
			xev_handle_randr(&e);
		else if (e.type < LASTEvent && xev_handlers[e.type] != NULL)
			(*xev_handlers[e.type])(&e);
	}
@


1.104
log
@use consistent types
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.103 2014/01/02 22:43:55 okan Exp $
d238 1
a238 1
	if (mb->flags == MOUSEBIND_CTX_WIN) {
d242 1
a242 1
	} else { /* (mb->flags == MOUSEBIND_CTX_ROOT) */
d290 1
a290 1
	if (kb->flags & KBFLAG_NEEDCLIENT) {
@


1.103
log
@Accept _NET_CURRENT_DESKTOP ClientMessage; from Thomas Adam, though
instead of group toggle, group only.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.102 2014/01/02 22:26:27 okan Exp $
d268 1
a268 1
	u_int			 modshift;
d311 1
a311 1
	u_int			 i;
@


1.102
log
@Accept _NET_WM_DESKTOP clientmessage; from Thomas Adam
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.101 2014/01/02 21:30:20 okan Exp $
d329 1
d331 3
a333 1
	if ((cc = client_find(e->window)) == NULL)
d355 3
@


1.101
log
@bring mousefunc closer to kbfunc
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.100 2013/12/13 14:45:47 okan Exp $
d345 4
@


1.100
log
@stray space and sort while here
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.99 2013/12/13 14:40:52 okan Exp $
d249 1
a249 1
	(*mb->callback)(cc, e);
@


1.99
log
@Add support for XUrgency and matching _NET_WM_STATE_DEMANDS_ATTENTION
ewmh hint; urgencyborder is configurable.  The urgency flag will stick,
even while on a client in a non-viewable group, until the client
receives focus (where the border is reset).  Initial diff from Thomas
Adam with some changes/enhancements from me.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.98 2013/12/12 20:15:07 okan Exp $
a49 1
static void	 xev_handle_expose(XEvent *);
d53 1
a53 1

d58 1
a65 2
			[Expose] = xev_handle_expose,
			[DestroyNotify] = xev_handle_destroynotify,
d68 1
@


1.98
log
@ICCCM explicitly states that server time (CurrentTime) should *not* be
used for focus events, but rather the timestamp of the generated event.
Track the last event timestamp and send it down for a WM_TAKE_FOCUS
ClientMessage.  I suspect we should do this for clients that don't
announce this Atom as well, though the raciness gets us into a bind.

Solves focus order issue since WM_TAKE_FOCUS; fix verified by sthen@@

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.97 2013/12/11 15:41:11 okan Exp $
d191 1
@


1.97
log
@Add client wrapper for XWMHints to support XA_WM_HINTS in PropertyNotify
events; based off a diff from Thomas Adam.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.96 2013/12/11 14:16:09 okan Exp $
d214 2
@


1.96
log
@Remove extra work and simplify client state handling.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.95 2013/12/02 14:30:12 okan Exp $
d188 3
@


1.95
log
@Since we use IconicState as our hidden state, check for the hidden flag
and unmanage the client if we're not hidden (basically if NormalState)
during an UnmapNotify event.

Resolves an issue with mplayer going fullscreen while not using NetWM
hints; behaviour regression reported by Ido Admon.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.94 2013/11/27 16:24:17 okan Exp $
d102 1
a102 2
			cc->state = WithdrawnState;
			xu_set_wm_state(cc->win, cc->state);
@


1.94
log
@Remove the option to bind a key by keycode with brackets; it never
worked (and no one complained!).  While it's fairly easy to fix, users
should be using keysym names and not keycodes.

Discussed at length months ago with todd@@, matthieu@@ and Owain.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.93 2013/11/27 00:01:23 okan Exp $
d104 4
a107 2
		} else
			client_hide(cc);
@


1.93
log
@Rewrite active/inactive client handling in client_setactive();
client_leave() served no real purpose, likewise no reason to handle
LeaveNotify events since an EnterNotify will process the next active
client (and we don't have anything important to process anyway), so
xev_handle_leavenotify() goes as well.  Allows a simplification of
client_mtf() and client_cycle_leave() for clarity.  While here, unify a
few client_current() checks.

No intended behaviour change.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.92 2013/11/12 21:25:00 okan Exp $
d278 1
a278 3
		if ((kb->keycode != 0 && kb->keysym == NoSymbol &&
		    kb->keycode == e->keycode) || kb->keysym ==
		    (modshift == 0 ? keysym : skeysym))
@


1.92
log
@Alter the r1.35 of event.c race fix.  Remove the forward looking event
queue check (removing the need for a server grab/ungrab) - if the client
is going away, let it fall all the way through to a DestroyNotify event.
There's no longer a need for us to manually destroy a client ourselves
(removing yet another server grab/ungrab).  Instead, when the
UnmapNotify event is synthetic, simply set the state to Withdrawn (as
per ICCCM), else Iconic (in our case 'hidden').

Verified with test case from the 2009 race which was the original reason
for r1.35 of event.c.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.91 2013/10/25 19:46:16 okan Exp $
a45 1
static void	 xev_handle_leavenotify(XEvent *);
a61 1
			[LeaveNotify] = xev_handle_leavenotify,
d82 1
a82 1
	if ((old_cc = client_current()) != NULL)
d212 1
a212 7
		client_setactive(cc, 1);
}

static void
xev_handle_leavenotify(XEvent *ee)
{
	client_leave(NULL);
d251 1
a251 1
	if ((cc = client_current()) != NULL)
a305 1
	struct client_ctx	*cc;
a309 1
	cc = client_current();
d314 1
a314 1
			client_cycle_leave(sc, cc);
d337 1
a337 2
		old_cc = client_current();
		if (old_cc)
@


1.91
log
@A client_delete should behave differently depending on whether the
triggering event was unmap (with pending destroy) log destroy; we only
need to grab/ungrab the server lock, set WithdrawnState and
XRemoveFromSaveSet clients coming from an unmap event - doing so for
clients coming from destroy are already gone, hence we generate errors.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.90 2013/07/15 23:51:59 okan Exp $
a99 1
	XEvent			ev;
a101 2
	/* XXX, we need a recursive locking wrapper around grab server */
	XGrabServer(X_Dpy);
d103 3
a105 11
		/*
		 * If it's going to die anyway, nuke it.
		 *
		 * Else, if it's a synthetic event delete state, since they
		 * want it to be withdrawn. ICCM recommends you withdraw on
		 * this even if we haven't alredy been told to iconify, to
		 * deal with legacy clients.
		 */
		if (XCheckTypedWindowEvent(X_Dpy, cc->win,
		    DestroyNotify, &ev) || e->send_event != 0) {
			client_delete(cc, 1);
a108 1
	XUngrabServer(X_Dpy);
d118 1
a118 1
		client_delete(cc, 0);
@


1.90
log
@collapse lines
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.89 2013/07/15 14:50:44 okan Exp $
d116 1
a116 1
			client_delete(cc);
d130 1
a130 1
		client_delete(cc);
@


1.89
log
@simplify atom handling; allows us to limit to one round-trip to server
for gathering Atoms.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.88 2013/07/10 14:15:58 okan Exp $
d351 2
a352 2
	if (e->message_type == cwmh[WM_CHANGE_STATE] &&
	    e->format == 32 && e->data.l[0] == IconicState)
d358 1
a358 2
	if (e->message_type == ewmh[_NET_ACTIVE_WINDOW] &&
	    e->format == 32) {
d364 1
a364 2
	if (e->message_type == ewmh[_NET_WM_STATE] &&
	    e->format == 32)
@


1.88
log
@bring buttonpress and keypress event handlers slightly closer together
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.87 2013/07/08 18:19:22 okan Exp $
d212 1
a212 1
				if (e->atom == ewmh[_NET_DESKTOP_NAMES].atom)
d351 1
a351 1
	if (e->message_type == cwmh[WM_CHANGE_STATE].atom &&
d355 1
a355 1
	if (e->message_type == ewmh[_NET_CLOSE_WINDOW].atom)
d358 1
a358 1
	if (e->message_type == ewmh[_NET_ACTIVE_WINDOW].atom &&
d365 1
a365 1
	if (e->message_type == ewmh[_NET_WM_STATE].atom &&
@


1.87
log
@move kbfunc and mousefunc closer together
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.86 2013/07/08 15:46:16 okan Exp $
a240 1
	struct screen_ctx	*sc;
a242 3
	sc = screen_fromroot(e->root);
	cc = client_find(e->window);

d252 6
a257 2
	if (mb->flags == MOUSEBIND_CTX_ROOT) {
		if (e->window != sc->rootwin)
d261 1
a261 2
	} else if (cc == NULL) /* (mb->flags == MOUSEBIND_CTX_WIN */
		return;
@


1.86
log
@whitespace and style fixes; from Tiago Cunha and one from me.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.85 2013/06/10 21:37:30 okan Exp $
d256 1
a256 1
	if (mb->context == MOUSEBIND_CTX_ROOT) {
d261 1
a261 1
	} else if (cc == NULL) /* (mb->context == MOUSEBIND_CTX_WIN */
@


1.85
log
@move synthetic responses and have client_msg only work with WM_PROTOCOLS,
since that's all ClientMessageEvent is for anyway.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.84 2013/06/10 20:11:43 okan Exp $
d360 1
a360 1
	    e->format == 32) {                                                
@


1.84
log
@Check for, and honour, CWStackMode and CWSibling change requests during a
ConfigureRequest event.  Additionally, honour a border width change;
detailed report and patch from Mike Small.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.83 2013/05/23 16:52:39 okan Exp $
d172 1
a172 1
		xu_configure(cc);
@


1.83
log
@alter conf_grab(_kbd) to first ungrab AnyKey/AnyModifier, then proceed
to grab keys in keybindingq.  we don't need to ungrab/grab on every
addition to the queue, just once with a complete keybindingq; simplify
grabbing keys per screen (during init) and during a MappingNotify.

while here, change conf_grab_{kbd,mouse} to require only a Window.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.82 2013/05/21 00:29:20 okan Exp $
d153 5
a157 1
			wc.border_width = e->border_width;
@


1.82
log
@handle _NET_WM_STATE ClientMessage; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.81 2013/05/20 21:32:00 okan Exp $
d392 1
a392 4
	struct keybinding	*kb;

	TAILQ_FOREACH(kb, &Conf.keybindingq, entry)
		conf_ungrab(&Conf, kb);
d395 4
a398 3

	TAILQ_FOREACH(kb, &Conf.keybindingq, entry)
		conf_grab(&Conf, kb);
@


1.81
log
@stray whitespace
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.80 2013/05/20 21:19:15 okan Exp $
d362 4
@


1.80
log
@handle _NET_ACTIVE_WINDOW ClientMessage; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.79 2013/05/19 17:05:52 okan Exp $
d361 1
a361 1
	}                              
@


1.79
log
@add support for _NET_CLOSE_WINDOW
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.78 2013/05/19 17:03:55 okan Exp $
d343 1
a343 1
	struct client_ctx	*cc;
d354 8
@


1.78
log
@treat WM_CHANGE_STATE like other atoms
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.77 2013/05/19 17:01:29 okan Exp $
d351 3
@


1.77
log
@simplify
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.76 2013/05/11 22:01:07 okan Exp $
a342 1
	Atom			 xa_wm_change_state;
a344 2
	xa_wm_change_state = XInternAtom(X_Dpy, "WM_CHANGE_STATE", False);

d348 2
a349 2
	if (e->message_type == xa_wm_change_state && e->format == 32 &&
	    e->data.l[0] == IconicState)
@


1.76
log
@new -> init
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.75 2013/05/10 16:32:48 okan Exp $
d206 6
a211 7
		TAILQ_FOREACH(sc, &Screenq, entry)
			if (sc->rootwin == e->window)
				goto test;
		return;
test:
		if (e->atom == ewmh[_NET_DESKTOP_NAMES].atom)
			group_update_names(sc);
@


1.75
log
@more type fixes for mask/button
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.74 2013/05/10 16:05:34 okan Exp $
d89 1
a89 1
		cc = client_new(e->window, screen_fromroot(xattr.root), 1);
@


1.74
log
@int type fixes
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.73 2013/05/10 15:44:43 okan Exp $
d280 1
a280 1
	int			 modshift;
@


1.73
log
@fix KeySym type
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.72 2013/04/29 00:56:48 okan Exp $
d326 1
a326 1
	int			 i;
@


1.72
log
@use an int in screen_init and avoid needing to cast for screen number (which).
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.71 2013/04/05 17:07:25 okan Exp $
d325 2
a326 1
	int			 i, keysym;
@


1.71
log
@zap stray whitespace
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.70 2012/12/18 17:37:39 okan Exp $
d365 1
a365 1
		if (sc->which == (u_int)i) {
@


1.70
log
@define LockMask|Mod2Mask; no functional change
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.69 2012/11/09 03:52:02 okan Exp $
d206 1
a206 1
		TAILQ_FOREACH(sc, &Screenq, entry) 
@


1.69
log
@sort
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.68 2012/11/07 14:49:46 okan Exp $
d244 1
a244 2
	/* Ignore caps lock and numlock */
	e->state &= ~(Mod2Mask | LockMask);
d285 1
a285 2
	/* we don't care about caps lock and numlock here */
	e->state &= ~(LockMask | Mod2Mask);
@


1.68
log
@missing headers; from Thordur Bjornsson.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.67 2012/09/12 15:09:33 okan Exp $
d33 1
a35 1
#include <stdio.h>
@


1.67
log
@revert previous for now until a way to test more than a few encodings is found
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.66 2012/09/10 13:28:04 okan Exp $
d32 1
@


1.66
log
@be explicit in which key masks we allow during keypress and buttonpress
events; from Alexander Polakov - makes non-us layout reliable.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.65 2012/07/13 17:01:04 okan Exp $
d243 2
a244 2
	/* only allow the ones we care about */
	e->state &= (ControlMask | Mod1Mask | Mod4Mask | ShiftMask);
d285 2
a286 2
	/* only allow the ones we care about */
	e->state &= (ControlMask | Mod1Mask | Mod4Mask | ShiftMask);
@


1.65
log
@re-use geom struct in client_ctx (saved)geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.64 2012/07/13 15:21:35 okan Exp $
d243 2
a244 2
	/* Ignore caps lock and numlock */
	e->state &= ~(Mod2Mask | LockMask);
d285 2
a286 2
	/* we don't care about caps lock and numlock here */
	e->state &= ~(LockMask | Mod2Mask);
@


1.64
log
@convert xmax/ymax uses to view geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.63 2012/07/06 14:18:00 okan Exp $
d144 1
a144 1
			cc->geom.width = e->width;
d146 1
a146 1
			cc->geom.height = e->height;
d154 1
a154 1
		if (cc->geom.x == 0 && cc->geom.width >= sc->view.w)
d157 1
a157 1
		if (cc->geom.y == 0 && cc->geom.height >= sc->view.h)
d162 2
a163 2
		wc.width = cc->geom.width;
		wc.height = cc->geom.height;
@


1.63
log
@querying for Xinerama should be done per display, not per screen, so
move chuck to display init; allows some shuffling to occur limiting
screen_init_xinerama()'s scope while keeping order intact.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.62 2012/07/05 17:35:13 okan Exp $
d154 1
a154 1
		if (cc->geom.x == 0 && cc->geom.width >= sc->xmax)
d157 1
a157 1
		if (cc->geom.y == 0 && cc->geom.height >= sc->ymax)
@


1.62
log
@the display's width and height are updated after an XRandR event so we
don't need to pass down the new values to screen_update_geometry(); so
just read the width/height values directly for both uses of
screen_update_geometry().  prep for further changes in this area.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.61 2012/07/03 13:49:03 okan Exp $
a368 1
			screen_init_xinerama(sc);
@


1.61
log
@re-implement atom handing; makes for a normalized and more consistent
separation between cwm and ewmh.  seen by a few.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.60 2012/05/16 21:57:21 okan Exp $
d368 1
a368 1
			screen_update_geometry(sc, rev->width, rev->height);
@


1.60
log
@get rid of more stray lines/spaces
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.59 2012/05/16 01:09:17 okan Exp $
d210 1
a210 1
		if (e->atom == _NET_DESKTOP_NAMES)
@


1.59
log
@cycle through other common cycling modifiers; based on a diff from
Alexander Polakov.

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.58 2012/05/16 01:04:36 okan Exp $
a208 1

a212 1

@


1.58
log
@convert from deprecated XKeycodeToKeysym to XkbKeycodeToKeysym

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.57 2012/05/13 15:17:13 okan Exp $
d73 3
d320 1
a320 1
 * This is only used for the alt suppression detection.
d328 1
a328 1
	int			 keysym;
d334 5
a338 14
	if (keysym != XK_Alt_L && keysym != XK_Alt_R)
		return;

	sc->cycling = 0;

	/*
	 * XXX - better interface... xevents should not know about
	 * how/when to mtf.
	 */
	client_mtf(NULL);

	if (cc != NULL) {
		group_sticky_toggle_exit(cc);
		XUngrabKeyboard(X_Dpy, CurrentTime);
@


1.57
log
@altpersist->cycling to be more clear that this is for cycling mod
persistence; based on a diff from Alexander Polakov, in preparation for
looping through other potential cycling modifiers.
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.56 2011/09/13 08:41:57 okan Exp $
d281 2
a282 2
	keysym = XKeycodeToKeysym(X_Dpy, e->keycode, 0);
	skeysym = XKeycodeToKeysym(X_Dpy, e->keycode, 1);
d330 1
a330 1
	keysym = XKeycodeToKeysym(X_Dpy, e->keycode, 0);
@


1.56
log
@add WM_TRANSIENT_FOR event support: moves dialogs, toolbars and such to
the group of the main application window; based on a diff from Alexander
Polakov with CLIENT_IGNORE flag suggestion from oga@@.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.55 2011/08/22 16:34:34 oga Exp $
d334 1
a334 1
	sc->altpersist = 0;
@


1.55
log
@A while ago I wrote some code to not warp to ignored windows on map (rev
1.52), not realising that the previous (less efficient) fix had already
been commited (rev 1.50).

Had this in my tree for ages to remove the previous code. Effectively
reverts rev 1.50.

ok okan@@
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.54 2011/06/24 05:33:41 okan Exp $
d193 3
@


1.54
log
@Correct extern declaration and while here, rename a variable to be
pedantic.

from Thomas Pfaff.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.53 2011/05/11 13:53:51 okan Exp $
a78 1
	struct winmatch		*wm;
a87 4
	TAILQ_FOREACH(wm, &Conf.ignoreq, entry) {
		if (strncasecmp(wm->title, cc->name, strlen(wm->title)) == 0)
			return;
	}
@


1.53
log
@tag and comment cleanup; ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: xevents.c,v 1.52 2011/05/06 19:39:44 oga Exp $
d413 1
a413 1
volatile sig_atomic_t	_xev_quit = 0;
d420 1
a420 1
	while (_xev_quit == 0) {
@


1.52
log
@On map, don't warp to windows that are marked as ignored.

Requested by Christian Neukirchen last august. He provided a patch but the one I
wrote was significantly simpler (1 - 2 + in the whole diff).

makes sense to okan@@.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.51 2011/03/22 10:49:46 okan Exp $
@


1.51
log
@remove XXX and move a configure event out of the event handler functions.

reminded by a similiar diff from Thomas Pfaff.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.50 2010/09/25 20:04:55 okan Exp $
d93 2
a94 2

	client_ptrwarp(cc);
@


1.50
log
@do not warp to clients marked 'ignore'; from chneukirchen at gmail - thanks.
(with the manpage bit from me).

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.49 2009/12/15 04:10:42 okan Exp $
d169 1
a169 1
		xev_reconfig(cc);
a215 19
void
xev_reconfig(struct client_ctx *cc)
{
	XConfigureEvent	 ce;

	ce.type = ConfigureNotify;
	ce.event = cc->win;
	ce.window = cc->win;
	ce.x = cc->geom.x;
	ce.y = cc->geom.y;
	ce.width = cc->geom.width;
	ce.height = cc->geom.height;
	ce.border_width = cc->bwidth;
	ce.above = None;
	ce.override_redirect = 0;

	XSendEvent(X_Dpy, cc->win, False, StructureNotifyMask, (XEvent *)&ce);
}

a411 1

@


1.49
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.48 2009/12/15 03:24:36 okan Exp $
d79 1
d87 5
@


1.48
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.47 2009/12/11 17:51:42 oga Exp $
d26 10
@


1.47
log
@Implement _NET_DESKTOP_NAMES, this one was a bit tricky since thespec
says that a pager can change the property at any time (most need a
clientmessage). So deal with property updates.

Needed to shuffle some of the other code around since we can't just use
shortcut_to_name[] everywhere now.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.46 2009/12/10 23:14:58 oga Exp $
a26 1
#include "headers.h"
@


1.46
log
@Implement _NET_CURRENT_DESKTOP, _NET_DESKTOP_VIEWPORT and
_NET_DESKTOP_GEOMETRY.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.45 2009/12/10 17:16:51 oga Exp $
d173 1
d188 9
d198 1
@


1.45
log
@finish unfucking the screen_ctx handling.

remove screen_current() it was utterly bogus when nscreens > 1.

pass a fake client_ctx in the case where there's no client and the
kbfunc or mousefunc doesn't need a real one, it just contains the
current screen, modify these functions so that they pass down the screen
context to their callees.

make groups per screen, it's the only way it makes sense in this regard.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.44 2009/11/28 17:52:12 tobias Exp $
d371 1
a371 2
			sc->xmax = rev->width;
			sc->ymax = rev->height;
@


1.44
log
@style (whitespaces)

ok oga, okan
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.43 2009/08/27 01:38:08 okan Exp $
d230 1
a230 1
	struct client_ctx	*cc;
a246 1

d250 4
a253 5
	} else if (mb->context == MOUSEBIND_CTX_WIN) {
		cc = client_find(e->window);
		if (cc == NULL)
			return;
	}
d271 1
a271 1
	struct client_ctx	*cc = NULL;
d299 3
a301 5

	if ((kb->flags & (KBFLAG_NEEDCLIENT)) &&
	    (cc = client_find(e->window)) == NULL &&
	    (cc = client_current()) == NULL)
		if (kb->flags & KBFLAG_NEEDCLIENT)
d303 4
@


1.43
log
@unroll the CCTOSC macro; from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.42 2009/08/24 23:49:04 okan Exp $
d378 1
a378 1
/* 
@


1.42
log
@bring together gathering, calculating and applying of size hints;
additionally, respect aspect ratio hints.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.41 2009/05/18 00:14:19 oga Exp $
d128 1
a128 1
		sc = CCTOSC(cc);
@


1.41
log
@Rip out the event layer and just use a static array of callbacks like
every other window manager since twm.

The event layer is very nice, very shiny, very flexible, and very much
underutilised. We don't need any of those shiny features so it's
probably better to earn ourselves 1k smaller text size instead.

ok todd@@, okan@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.40 2009/05/01 17:50:20 okan Exp $
a173 1
	long			 tmp;
d178 1
a178 1
			XGetWMNormalHints(X_Dpy, cc->win, cc->size, &tmp);
@


1.40
log
@fix the other 50% of xrandr cases; reported by sthen@@

"commit that" oga@@, ok sthen@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.39 2009/03/28 16:38:54 martynas Exp $
d30 33
a62 4
/*
 * NOTE: in reality, many of these should move to client.c now that
 * we've got this nice event layer.
 */
d64 2
a65 2
void
xev_handle_maprequest(struct xevent *xev, XEvent *ee)
a79 1
	xev_register(xev);
d82 2
a83 2
void
xev_handle_unmapnotify(struct xevent *xev, XEvent *ee)
a106 2

	xev_register(xev);
d109 2
a110 2
void
xev_handle_destroynotify(struct xevent *xev, XEvent *ee)
a116 2

	xev_register(xev);
d119 2
a120 2
void
xev_handle_configurerequest(struct xevent *xev, XEvent *ee)
a166 2

	xev_register(xev);
d169 2
a170 2
void
xev_handle_propertynotify(struct xevent *xev, XEvent *ee)
a188 2

	xev_register(xev);
d210 2
a211 2
void
xev_handle_enternotify(struct xevent *xev, XEvent *ee)
a217 2

	xev_register(xev);
d220 2
a221 2
void
xev_handle_leavenotify(struct xevent *xev, XEvent *ee)
a223 2

	xev_register(xev);
d227 2
a228 2
void
xev_handle_buttonpress(struct xevent *xev, XEvent *ee)
d247 1
a247 1
		goto out;
d251 1
a251 1
			goto out;
d255 1
a255 1
			goto out;
a258 2
out:
	xev_register(xev);
d261 2
a262 2
void
xev_handle_buttonrelease(struct xevent *xev, XEvent *ee)
a267 2

	xev_register(xev);
d270 2
a271 2
void
xev_handle_keypress(struct xevent *xev, XEvent *ee)
d301 1
a301 1
		goto out;
d307 1
a307 1
			goto out;
a309 3

out:
	xev_register(xev);
d315 2
a316 2
void
xev_handle_keyrelease(struct xevent *xev, XEvent *ee)
d328 1
a328 1
		goto out;
a341 3

out:
	xev_register(xev);
d344 2
a345 2
void
xev_handle_clientmessage(struct xevent *xev, XEvent *ee)
d354 1
a354 1
		goto out;
a358 2
out:
	xev_register(xev);
d361 2
a362 2
void
xev_handle_randr(struct xevent *xev, XEvent *ee)
d383 2
a384 2
void
xev_handle_mapping(struct xevent *xev, XEvent *ee)
a395 42

	xev_register(xev);
}

/*
 * X Event handling
 */

static struct xevent_q	_xevq, _xevq_putaway;
static short		_xev_q_lock = 0;
volatile sig_atomic_t	_xev_quit = 0;

void
xev_init(void)
{
	TAILQ_INIT(&_xevq);
	TAILQ_INIT(&_xevq_putaway);
}

struct xevent *
xev_new(Window *win, Window *root,
    int type, void (*cb)(struct xevent *, XEvent *), void *arg)
{
	struct xevent	*xev;

	XMALLOC(xev, struct xevent);
	xev->xev_win = win;
	xev->xev_root = root;
	xev->xev_type = type;
	xev->xev_cb = cb;
	xev->xev_arg = arg;

	return (xev);
}

void
xev_register(struct xevent *xev)
{
	struct xevent_q	*xq;

	xq = _xev_q_lock ? &_xevq_putaway : &_xevq;
	TAILQ_INSERT_TAIL(xq, xev, entry);
d399 1
a399 12
_xev_reincorporate(void)
{
	struct xevent	*xev;

	while ((xev = TAILQ_FIRST(&_xevq_putaway)) != NULL) {
		TAILQ_REMOVE(&_xevq_putaway, xev, entry);
		TAILQ_INSERT_TAIL(&_xevq, xev, entry);
	}
}

void
xev_handle_expose(struct xevent *xev, XEvent *ee)
a405 2

	xev_register(xev);
a407 4
#define ASSIGN(xtype) do {			\
	root = e. xtype .root;			\
	win = e. xtype .window;			\
} while (0)
d409 1
a409 3
#define ASSIGN1(xtype) do {			\
	win = e. xtype .window;			\
} while (0)
a413 1
	Window		 win, root;
a414 2
	struct xevent	*xev = NULL, *nextxev;
	int type;
a416 5
#ifdef DIAGNOSTIC
		if (TAILQ_EMPTY(&_xevq))
			errx(1, "X event queue empty");
#endif

d418 4
a421 61
		type = e.type;

		win = root = 0;

		switch (type) {
		case MapRequest:
			ASSIGN1(xmaprequest);
			break;
		case UnmapNotify:
			ASSIGN1(xunmap);
			break;
		case ConfigureRequest:
			ASSIGN1(xconfigurerequest);
			break;
		case PropertyNotify:
			ASSIGN1(xproperty);
			break;
		case EnterNotify:
		case LeaveNotify:
			ASSIGN(xcrossing);
			break;
		case ButtonPress:
			ASSIGN(xbutton);
			break;
		case ButtonRelease:
			ASSIGN(xbutton);
			break;
		case KeyPress:
		case KeyRelease:
			ASSIGN(xkey);
			break;
		case DestroyNotify:
			ASSIGN1(xdestroywindow);
			break;
		case ClientMessage:
			ASSIGN1(xclient);
			break;
		default:
			if (e.type == Randr_ev)
				xev_handle_randr(xev, &e);
			break;
		}

		/*
		 * Now, search for matches, and call each of them.
		 */
		_xev_q_lock = 1;
		for (xev = TAILQ_FIRST(&_xevq); xev != NULL; xev = nextxev) {
			nextxev = TAILQ_NEXT(xev, entry);

			if ((type != xev->xev_type && xev->xev_type != 0) ||
			    (xev->xev_win != NULL && win != *xev->xev_win) ||
			    (xev->xev_root != NULL && root != *xev->xev_root))
				continue;

			TAILQ_REMOVE(&_xevq, xev, entry);

			(*xev->xev_cb)(xev, &e);
		}
		_xev_q_lock = 0;
		_xev_reincorporate();
a423 3

#undef ASSIGN
#undef ASSIGN1
@


1.39
log
@- avoid shadowed Mask declaration in menu_filter
- make _xev_reincorporate static
evmask naming oga@@, input okan@@.  ok okan@@, oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.38 2009/01/23 18:58:40 oga Exp $
a360 1
	struct client_ctx		*cc;
d362 1
d364 8
a371 6
	if ((cc = client_find(rev->window)) != NULL) {
		XRRUpdateConfiguration(ee);
		sc = CCTOSC(cc);
		sc->xmax = rev->width;
		sc->ymax = rev->height;
		screen_init_xinerama(sc);
@


1.38
log
@Move the keybinding argument to a union to prevent warnings where
sizeof(int) != sizeof(void *). This has been annoying me for ages.

ok okan@@, todd@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.37 2009/01/22 19:01:56 okan Exp $
d434 1
a434 1
void
@


1.37
log
@now that pwin is gone gone gone, we no longer have to do the bwidth
dance; xevents now able to deal with a border being set (which fixes
those annoying movie-watching apps).

ok todd@@, oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.36 2009/01/17 20:39:24 okan Exp $
d297 1
a297 1
	(*kb->callback)(cc, kb->argument);
@


1.36
log
@remove unused

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.35 2009/01/17 18:41:50 oga Exp $
d114 2
d117 1
a117 2
		if (cc->geom.x == 0 &&
		    cc->geom.width >= DisplayWidth(X_Dpy, sc->which))
d120 1
a120 2
		if (cc->geom.y == 0 &&
		    cc->geom.height >= DisplayHeight(X_Dpy, sc->which))
d123 4
a126 4
		wc.x = cc->geom.x - cc->bwidth;
		wc.y = cc->geom.y - cc->bwidth;
		wc.width = cc->geom.width + cc->bwidth*2;
		wc.height = cc->geom.height + cc->bwidth*2;
d137 1
@


1.35
log
@Finally fix the really annoying race where if you rapidly switch groups several
times you'd end up losing clients (thinking they had gone away).

From the ICCCM (which should not be read without a stiff drink in hand,
I made this mistake so you don't have to): to request a window to be
withdrawn one should send a synthetic UnmapRequest event when iconified.
To request iconification one should just unmap the window. The ICCM
further recommends that the synthetic event should just be taken as a
cue to withdraw, to deal with legacy clients. Taking a hint from this,
rework xev_handle_unmaprequest to correctly detect these situations.  A
Withdrawn window may come back anywhere, even as a subwindow of
something else, so the correct way to handle this state is to forget it
ever existed.

While i'm here, kill a dumb attempt to notice this in client_delete, and
nuke the very unnecessary arguments.

Todd confirmed this fixes the `race'.

ok todd@@, ok ok okan@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.34 2009/01/16 16:49:17 okan Exp $
d195 1
a195 11
	if ((cc = client_find(e->window)) == NULL) {
		/*
		 * XXX - later.  messes up unclutter.  but may be
		 * needed when we introduce menu windows and such into
		 * the main event loop.
		 */
#ifdef notyet
		if (e->window != e->root)
			client_nocurrent();
#endif
	} else
@


1.34
log
@revert just the 'race fix'; more works needs to be ironed out with
events and state.

agreed by oga
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.33 2009/01/16 15:24:14 okan Exp $
d39 1
a40 5
	struct client_ctx	*cc = NULL, *old_cc;

#ifdef notyet
	int state;
#endif
a49 6
#ifdef notyet			/* XXX - possibly, we shouldn't map if
				 * the window is withdrawn. */
	if (xu_getstate(cc, &state) == 0 && state == WithdrawnState)
		warnx("WITHDRAWNSTATE for %s", cc->name);
#endif

d58 1
d61 18
a78 2
	if ((cc = client_find(e->window)) != NULL)
		client_delete(cc, e->send_event, 0);
d90 1
a90 1
		client_delete(cc, 1, 1);
@


1.33
log
@remove pwin, bringing us to one client, one window.  we no longer have
to push attributes around, so things get a lot simplier, while fixing a
few issues in the meantime; original suggestion by Edd Barrett many many
moons ago.

annoying window placement and race, found in c2k8 by todd, fix by oga!

lots of feedback from todd and oga - thanks!

"commit that bad boy" oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.32 2009/01/11 18:25:49 okan Exp $
d71 1
a71 1
		client_hide(cc);
@


1.32
log
@remove unused variables

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.31 2009/01/06 00:18:07 okan Exp $
d71 1
a71 1
		client_delete(cc, e->send_event, 0);
a98 1
		client_gravitate(cc, 0);
a115 2
		client_gravitate(cc, 1);

d120 1
a120 1
		wc.border_width = 0;
d122 1
a122 2
		/* We need to move the parent window, too. */
		XConfigureWindow(X_Dpy, cc->pwin, e->value_mask, &wc);
d124 10
a135 11
	wc.x = cc != NULL ? cc->bwidth : e->x;
	wc.y = cc != NULL ? cc->bwidth : e->y;
	wc.width = e->width;
	wc.height = e->height;
	wc.stack_mode = Above;
	wc.border_width = 0;
	e->value_mask &= ~CWStackMode;
	e->value_mask |= CWBorderWidth;

	XConfigureWindow(X_Dpy, e->window, e->value_mask, &wc);

d175 1
a175 1
	ce.border_width = 0;
a359 10
xev_handle_shape(struct xevent *xev, XEvent *ee)
{
	XShapeEvent		*sev = (XShapeEvent *) ee;
	struct client_ctx	*cc;

	if ((cc = client_find(sev->window)) != NULL)
		client_do_shape(cc);
}

void
d453 1
a453 1
	if ((cc = client_find(e->window)) != NULL && e->count == 0) {
a454 2
		client_do_shape(cc);
	}
d521 1
a521 3
			if (e.type == Shape_ev)
				xev_handle_shape(xev, &e);
			else if (e.type == Randr_ev)
@


1.31
log
@remove unused code

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.30 2008/12/04 23:55:04 oga Exp $
a224 1
	char			*wname;
@


1.30
log
@Kill obviously dead variable.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.29 2008/09/29 23:16:46 oga Exp $
a40 1
	struct screen_ctx	*sc;
a51 1
		sc = CCTOSC(cc);
@


1.29
log
@Xinerama and XRandR dual head support for cwm(1). Now we detect the xrandr
reconfiguration events and change our sizes depending on that. We also detect
the xinerama screens for maximize, vertmaximize and initial window placement.

This could be improved by automatically resizing maximized windows when
the screen resolution changes and by moving windows that would be hidden
into visible space. Said changes will come shortly.

Tested by many. matthieu@@ didn't oppose.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.28 2008/09/22 14:28:04 oga Exp $
d54 1
a54 2
	} else
		cc->beepbeep = 1;
@


1.28
log
@*sigh* Revert the diff that wasn't meant to go in yet.

note to self: When you mean to type cvs commit search.c, don't forget
the filename.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.26 2008/07/22 21:01:54 oga Exp $
d378 16
d544 2
@


1.27
log
@Display the current window title not a previous one in the case of
``show all'' in the window search dialogue. Noticed and diff from Tim
van der Molen, thanks!
@
text
@a377 16
void
xev_handle_randr(struct xevent *xev, XEvent *ee)
{
	XRRScreenChangeNotifyEvent	*rev = (XRRScreenChangeNotifyEvent *)ee;
	struct client_ctx		*cc;
	struct screen_ctx		*sc;

	if ((cc = client_find(rev->window)) != NULL) {
		XRRUpdateConfiguration(ee);
		sc = CCTOSC(cc);
		sc->xmax = rev->width;
		sc->ymax = rev->height;
		screen_init_xinerama(sc);
	}
}

a527 2
			else if (e.type == Randr_ev)
				xev_handle_randr(xev, &e);
@


1.26
log
@fix the froggy problem.

Implement a handler for the MappingEvent, meaning that the keymap has changed.
When this happens, ungrab all bindings, update the map, and regrab.

Fixes the problem where some keybindings wouldn't work under non us or
uk keymaps (especially the .fr map, it seems). Issue noticed by
ajacoutot@@, ratchov@@, and a few people on misc. Based on an initial diff
from ratchov@@.

ok okan.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.25 2008/07/11 14:21:28 okan Exp $
d378 16
d544 2
@


1.25
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.24 2008/06/18 19:09:12 oga Exp $
d376 21
@


1.24
log
@Revert previous "fix" it introduces new issues of its own.

The problem that's causing us to lose windows is that rapid hiding and
unhiding causes a backlog of X events, so we lose track of client state,
and delete cc->pwin when we should not. A proper fix will arrive when it's been
worked out.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.23 2008/06/17 23:40:33 oga Exp $
d38 5
a42 4
	XMapRequestEvent *e = &ee->xmaprequest;
	struct client_ctx *cc = NULL, *old_cc = client_current();
	XWindowAttributes xattr;
	struct screen_ctx *sc;
d47 1
a47 1
	if (old_cc != NULL)
d70 2
a71 2
	XUnmapEvent *e = &ee->xunmap;
	struct client_ctx *cc;
d82 2
a83 2
	XDestroyWindowEvent *e = &ee->xdestroywindow;
	struct client_ctx *cc;
d94 4
a97 4
	XConfigureRequestEvent *e = &ee->xconfigurerequest;
	struct client_ctx *cc;
	struct screen_ctx *sc;
	XWindowChanges wc;
d150 3
a152 3
	XPropertyEvent *e = &ee->xproperty;
	struct client_ctx *cc;
	long tmp;
d174 1
a174 1
	XConfigureEvent ce;
d193 2
a194 2
	XCrossingEvent *e = &ee->xcrossing;
	struct client_ctx *cc;
d226 1
a226 1
	struct screen_ctx	*sc = screen_fromroot(e->root);
d230 1
d261 1
a261 1
	struct client_ctx *cc = client_current();
d263 1
a263 1
	if (cc != NULL)
d272 5
a276 5
	XKeyEvent *e = &ee->xkey;
	struct client_ctx *cc = NULL; /* Make gcc happy. */
	struct keybinding *kb;
	KeySym keysym, skeysym;
	int modshift;
d320 7
a326 4
	XKeyEvent *e = &ee->xkey;
	struct screen_ctx *sc = screen_fromroot(e->root);
	struct client_ctx *cc = client_current();
	int keysym;
d352 3
a354 3
	XClientMessageEvent *e = &ee->xclient;
	struct client_ctx *cc = client_find(e->window);
	Atom xa_wm_change_state = XInternAtom(X_Dpy, "WM_CHANGE_STATE", False);
d356 3
a358 1
	if (cc == NULL)
d371 2
a372 2
	XShapeEvent *sev = (XShapeEvent *) ee;
	struct client_ctx *cc;
d397 1
a397 1
	struct xevent *xev;
d412 1
a412 1
	struct xevent_q *xq;
d421 1
a421 1
	struct xevent *xev;
d432 2
a433 2
	XExposeEvent *e = &ee->xexpose;
	struct client_ctx *cc;
d455 3
a457 1
	Window win, root;
a458 2
	XEvent e;
	struct xevent *xev, *nextxev;
@


1.23
log
@Ignore caps lock and numlock for keyboard bindings. The way Xlib makes
you do this is ugly. Also remove mod2 (numlock) and mod3 (odd) from the
list of keybinding modifiers. They don't make much sense here.

based on a heavily modified diff from Martynas.

ok okan.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.22 2008/06/17 20:55:48 oga Exp $
d73 1
a73 1
		xu_setstate(cc, WithdrawnState);
@


1.22
log
@Just rework the mouse binding calculation on event to look like the
kbfunc one.  Makes the code a lot easier to read.

Fixes a bug i introduced in the last commit here.

ok okan.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.21 2008/06/17 20:21:17 oga Exp $
d231 3
d278 3
@


1.21
log
@The mousebinding code missing a break once it had found the correct
binding, this expose another issue that's still being debugged.
Issue pointed out by Dan Harnett, thanks!

While i'm here KNF and rework the logic to not be ass-backwards.

ok okan.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.20 2008/06/14 22:04:11 okan Exp $
d231 3
a233 8
	if (e->window == sc->rootwin) {
		TAILQ_FOREACH(mb, &Conf.mousebindingq, entry) {
			if (e->button == mb->button && e->state == mb->modmask
			    && mb->context == MOUSEBIND_CTX_ROOT) {
				(*mb->callback)(cc, e);
				break;
			}
		}
d236 1
a236 1
	if (cc == NULL || e->state == 0)
d239 7
a245 6
	TAILQ_FOREACH(mb, &Conf.mousebindingq, entry) {
		if (e->button == mb->button && e->state == mb->modmask &&
		    mb->context == MOUSEBIND_CTX_ROOT) {
			(*mb->callback)(cc, NULL);
			break;
		}
d247 2
@


1.20
log
@(mostly) proper xshape event support

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.19 2008/06/14 21:48:54 okan Exp $
d223 5
a227 5
	XButtonEvent *e = &ee->xbutton;
	struct client_ctx *cc;
	struct screen_ctx *sc = screen_fromroot(e->root);
	char *wname;
	struct mousebinding *mb;
d231 1
a231 1
	if (sc->rootwin == e->window)
d233 5
a237 4
			if(e->button!=mb->button || e->state!=mb->modmask ||
			    mb->context!=MOUSEBIND_CTX_ROOT)
				continue;
			(*mb->callback)(cc, e);
d239 1
d245 5
a249 6
		if(e->button!=mb->button || e->state!=mb->modmask ||
		   mb->context!=MOUSEBIND_CTX_WIN)
			continue;

		(*mb->callback)(cc, NULL);
		break;
@


1.19
log
@confable menu and window mouse bindings from rivo nurges (thanks!) with
some minor fixups, man page bits and knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.18 2008/06/13 03:41:58 oga Exp $
a262 1

d356 10
d423 1
a423 1
	if ((cc = client_find(e->window)) != NULL && e->count == 0)
d425 2
d492 3
a494 1
		default:	/* XXX - still need shape event support. */
@


1.18
log
@Don't client_delete() on an Unmap event, only do that on a client delete event.

found by (among others) todd@@ when you have a lot of clients and do something
that maps and umaps a lot of windows fast.

Debugged with aid of gdb, todd, okan and NULL pointers in a pizza place in
edmonton while waiting an inordinately long time for food.

ok okan@@, todd@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.17 2008/06/12 05:01:13 okan Exp $
d224 1
a224 1
	struct client_ctx *cc, *old_cc = client_current();
d227 1
a227 1
	int altcontrol = e->state == (ControlMask|Mod1Mask);
d231 6
a236 68
	if (sc->rootwin == e->window && !altcontrol) {
		struct menu_q menuq;
		struct menu *mi;

		/* XXXSIGH!!!! */
		if (e->button == Button2) {
			group_menu(e);
			goto out;
		}

		TAILQ_INIT(&menuq);

		switch (e->button) {
		case Button1:
			TAILQ_FOREACH(cc, &Clientq, entry) {
				if (cc->flags & CLIENT_HIDDEN) {
					if (cc->label != NULL)
						wname = cc->label;
					else
						wname = cc->name;

					if (wname == NULL)
						continue;

					XCALLOC(mi, struct menu);
					strlcpy(mi->text,
					    wname, sizeof(mi->text));
					mi->ctx = cc;
					TAILQ_INSERT_TAIL(&menuq, mi, entry);
				}
			}
			break;
		case Button3: {
			struct cmd *cmd;
			conf_reload(&Conf);
			TAILQ_FOREACH(cmd, &Conf.cmdq, entry) {
				XCALLOC(mi, struct menu);
				strlcpy(mi->text, cmd->label, sizeof(mi->text));
				mi->ctx = cmd;
				TAILQ_INSERT_TAIL(&menuq, mi, entry);
			}
			break;
		}
		default:
			break;
		}

		if (TAILQ_EMPTY(&menuq))
			goto out;

		mi = menu_filter(&menuq, NULL, NULL, 0, NULL, NULL);
		if (mi == NULL)
			goto cleanup;

		switch (e->button) {
		case Button1:
			cc = (struct client_ctx *)mi->ctx;
			client_unhide(cc);

			if (old_cc != NULL)
				client_ptrsave(old_cc);
			client_ptrwarp(cc);
			break;
		case Button3:
			u_spawn(((struct cmd *)mi->ctx)->image);
			break;
		default:
			break;
a238 9
	cleanup:
		while ((mi = TAILQ_FIRST(&menuq)) != NULL) {
			TAILQ_REMOVE(&menuq, mi, entry);
			xfree(mi);
		}

		goto out;
	}

d242 4
a245 1
	sc = CCTOSC(cc);
d247 1
a247 16
	switch (e->button) {
	case Button1:
		if (altcontrol)
			group_sticky_toggle_enter(cc);
		else {
			grab_drag(cc);
			client_move(cc);
		}
		break;
	case Button2:
		grab_sweep(cc);
		client_resize(cc);
		break;
	case Button3:
		client_ptrsave(cc);
		client_lower(cc);
@


1.17
log
@ignore if non-zero expose events, for we could be covered by multiple
windows; merely an optimization.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.16 2008/05/21 14:11:19 oga Exp $
a70 7
	struct screen_ctx *sc;
	int wascurrent;

	if ((cc = client_find(e->window)) != NULL) {
		sc = CCTOSC(cc);
		wascurrent = cc == client_current();
		client_delete(cc, e->send_event, 0);
d72 2
a73 7
#ifdef notyet
		/* XXX disable the ptrwarp until we handle it
		 * better. */
		if (!client_delete(cc, e->send_event, 0) && wascurrent)
			;/* 			client_ptrwarp(new_cc); */
#endif
	}
@


1.16
log
@Make menu_filter handle mouse movement too. This enables the keyboard
search dialogues to be manipulated with the mouse, too. It also allows
me to shrink the codebase further by killing grab_menu().

One known issue with highlighting the first entry in a search dialogue,
that'll be fixed soonish.

ok okan@@, tested by Edd Barrett and todd@@.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.15 2008/05/19 12:56:58 okan Exp $
d509 1
a509 1
	if ((cc = client_find(e->window)) != NULL)
@


1.15
log
@finally implement keyboard binding for group toggling

idea for the
    "slightly-less-abhorrent-hack-but-a-hack-nonetheless-TM" from oga@@

grab and ungrab the keyboard to get around some silly X apps that like
stealing events

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.14 2008/05/18 20:06:36 okan Exp $
d293 1
a293 1
		mi = (struct menu *)grab_menu(e, &menuq);
@


1.14
log
@send the correct x/y coordinates to XConfigureWindow()

fixes some windows that seem as if they don't fit; noticed by Edd Barrett.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.13 2008/05/15 22:18:00 oga Exp $
d411 1
d425 5
@


1.13
log
@KNF, no binary change.

From Pierre Riteau. Thanks!
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.12 2008/04/16 13:35:37 oga Exp $
d144 2
a145 2
	wc.x = cc != NULL ? 0 : e->x;
	wc.y = cc != NULL ? 0 : e->y;
@


1.12
log
@Remove screen_infomsg(), nothing uses it.

ok okan.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.11 2008/04/15 20:24:41 oga Exp $
d345 1
a345 1
 out:
d425 1
a425 1
 out:
@


1.11
log
@hit it with the knf stick.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.10 2008/04/08 00:09:50 simon Exp $
a423 1
	client_altrelease();
@


1.10
log
@Make _xev_quit "volatile sig_atomic_t" for proper correctness.

Noticed by oga@@, thanks!
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.9 2008/04/07 23:47:09 simon Exp $
d49 1
a49 1
	if ((cc = client_find(e->window)) == NULL) { 
d53 1
a53 1
	} else {
a54 1
	}
d82 1
a82 1
		if (!client_delete(cc, e->send_event, 0) && wascurrent) 
d123 1
a123 1
                if (cc->geom.x == 0 &&
d127 1
a127 1
                if (cc->geom.y == 0 &&
d129 1
a129 1
                        cc->geom.y -= cc->bwidth;
d166 1
a166 1
		switch(e->atom) { 
d262 1
a262 1
				  		wname = cc->name;
d372 2
a373 2
	
        TAILQ_FOREACH(kb, &Conf.keybindingq, entry) {
d383 2
a384 2
			kb->keycode == e->keycode) || kb->keysym ==
			(modshift == 0 ? keysym : skeysym))
d386 1
a386 1
        }
d391 1
a391 1
	if ((kb->flags & (KBFLAG_NEEDCLIENT)) && 
d418 1
a418 1
	
d451 3
a453 3
static struct xevent_q _xevq, _xevq_putaway;
static short _xev_q_lock = 0;
volatile sig_atomic_t _xev_quit = 0;
d531 1
a531 1
#endif		
@


1.9
log
@Add quit function, bind it per default to CM-q and change exec_wm
binding to CM-w.

Inital diff from Gleydson Soares
Feedback from oga@@ and okan@@

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.8 2008/03/23 15:09:21 simon Exp $
d454 1
a454 1
int _xev_quit = 0;
@


1.8
log
@Replace the symlink configuration scheme with a simple yacc parser as
found in other places of the tree.  Remove sticky and font commandline
options and add another one for alternative config locations.
Split off cwmrc(5) from cwm(1), nuke #ifdef __OpenBSD__ while there.

tested by various kind people, feedback from oga@@ and okan@@ - thanks!
ok oga@@, jasper@@, okan@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.7 2008/03/22 15:09:45 oga Exp $
d454 1
d528 1
a528 1
	for (;;) {
@


1.7
log
@Rip out, burn, and dance around the grave of group-edit mode.
I've yet to speak to anyone who uses it, so just kill it.

You can still add/remove from groups using the mouse binding.  Groups
may get a re-work sometime soon if i have a stroke of genius.

knocks about 4k off the i386 binary for me.

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.6 2008/03/22 14:09:02 oga Exp $
d278 1
a278 4
			if (conf_cmd_changed(Conf.menu_path)) {
				conf_cmd_clear(&Conf);
				conf_cmd_populate(&Conf, Conf.menu_path);
			}
@


1.6
log
@Remove a bunch of unused variables and incorrect comments.

"ok with me" okan@@.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.5 2008/02/20 12:56:10 oga Exp $
d333 1
a333 1
		if (altcontrol && !Groupmode)
d341 2
a342 7
		/* XXXSIGH!!! */
		if (Groupmode)
			group_click(cc);
		else {
			grab_sweep(cc);
			client_resize(cc);
		}
d358 1
a358 1
	if (cc != NULL && !Groupmode)
a391 3
	if (kb == NULL && e->window == screen_current()->groupwin)
		group_display_keypress(e->keycode);

a504 1
	struct screen_ctx *sc = screen_current();
a508 3

	if (sc->groupwin == e->window)
		group_display_draw(sc);
@


1.5
log
@Typo: s/supression/suppression

from Pierre Riteau, thanks!
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.4 2008/01/16 11:39:20 oga Exp $
d403 1
a403 1
	if ((kb->flags & (KBFLAG_NEEDCLIENT|KBFLAG_FINDCLIENT)) && 
@


1.4
log
@huge amount of cleanup and dead code removal.

full description of changes:
-remove fontlist, and all associated structures/calls, it's not needed.
 this also removes any doubt about leftover 9wm code (the list was
 borrowed from it). Since cwm now uses Xft for everything, the legacy
 font handling is just not needed.
-add /* FALLTHROUGH */ comments into grab_{label,menu}. I actually
 didn't intend grab_menu to be a fallthrough, but it actually works quite
 well there, so remove the extra rectangle drawing. I love it when that
 happens.
-remove a couple of unused prototypes that were obviously missed
 before.
-remove a bunch of commented out or if 0ed out code. It doesn't look to
 be coming back anytime soon.
-several functions returned an int, but this was never checked. most of
 them only failed if they failed to grab the pointer (thus the internal
 state didn't change), so just make them void and return early if this is
 the case.
-remove several unused functions and some useless variables.

knocks something like 200bytes off the stripped binary size for me.

ok marc@@, tested by several others.
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.3 2008/01/11 16:06:44 oga Exp $
d416 1
a416 1
 * This is only used for the alt supression detection.
@


1.3
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d18 1
a18 1
 * $Id: xevents.c,v 1.2 2007/05/28 18:34:27 jasper Exp $
a28 2

void _sendxmsg(Window, Atom, long);
@


1.2
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@a4 1
 * All rights reserved.
d6 13
a18 1
 * $Id: xevents.c,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * $Id: xevents.c,v 1.42 2005/08/20 20:59:49 marius Exp $
d41 1
a41 1
		XGetWindowAttributes(G_dpy, e->window, &xattr);
d116 1
a116 1
		    cc->geom.width >= DisplayWidth(G_dpy, sc->which))
d120 1
a120 1
		    cc->geom.height >= DisplayHeight(G_dpy, sc->which))
d132 1
a132 1
		XConfigureWindow(G_dpy, cc->pwin, e->value_mask, &wc);
d145 1
a145 1
	XConfigureWindow(G_dpy, e->window, e->value_mask, &wc);
d160 1
a160 1
			XGetWMNormalHints(G_dpy, cc->win, cc->size, &tmp);
d190 1
a190 1
	XSendEvent(G_dpy, cc->win, False, StructureNotifyMask, (XEvent *)&ce);
d249 1
a249 1
			TAILQ_FOREACH(cc, &G_clientq, entry) {
d269 3
a271 3
			if (conf_cmd_changed(G_conf.menu_path)) {
				conf_cmd_clear(&G_conf);
				conf_cmd_populate(&G_conf, G_conf.menu_path);
d273 1
a273 1
			TAILQ_FOREACH(cmd, &G_conf.cmdq, entry) {
d324 1
a324 1
		if (altcontrol && !G_groupmode)
d333 1
a333 1
		if (G_groupmode)
d354 1
a354 1
	if (cc != NULL && !G_groupmode)
d370 2
a371 2
	keysym = XKeycodeToKeysym(G_dpy, e->keycode, 0);
	skeysym = XKeycodeToKeysym(G_dpy, e->keycode, 1);
d373 1
a373 1
        TAILQ_FOREACH(kb, &G_conf.keybindingq, entry) {
d416 1
a416 1
	keysym = XKeycodeToKeysym(G_dpy, e->keycode, 0);
d438 1
a438 1
	Atom xa_wm_change_state = XInternAtom(G_dpy, "WM_CHANGE_STATE", False);
d539 1
a539 1
		XNextEvent(G_dpy, &e);
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
