head	1.68;
access;
symbols
	OPENBSD_6_2:1.68.0.2
	OPENBSD_6_2_BASE:1.68
	OPENBSD_6_1:1.67.0.2
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.64.0.6
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.4
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.64.0.2
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.62.0.2
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.58.0.2
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.47.0.2
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.33.0.4
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.2
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.6
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.21.0.2
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13;
locks; strict;
comment	@ * @;


1.68
date	2017.04.26.21.10.54;	author okan;	state Exp;
branches;
next	1.67;
commitid	LDoW1p4qPKaKlLtb;

1.67
date	2016.12.01.17.17.27;	author okan;	state Exp;
branches;
next	1.66;
commitid	Qz0ivc5HOpzrYaDs;

1.66
date	2016.11.14.21.25.59;	author okan;	state Exp;
branches;
next	1.65;
commitid	vHOoPGxkcPiAilEG;

1.65
date	2016.10.03.14.42.34;	author okan;	state Exp;
branches;
next	1.64;
commitid	sciYi1tUXUIu4s4n;

1.64
date	2015.05.17.04.39.50;	author kspillner;	state Exp;
branches;
next	1.63;
commitid	yQea2sYlbViSGlgA;

1.63
date	2015.05.17.04.34.01;	author kspillner;	state Exp;
branches;
next	1.62;
commitid	vOYrUv5aGh2lx3AQ;

1.62
date	2015.02.14.18.24.12;	author okan;	state Exp;
branches;
next	1.61;
commitid	SWMTIZWsB7GCG44i;

1.61
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.60;
commitid	kLADTGYX3gw0Sf2m;

1.60
date	2015.01.17.02.05.03;	author okan;	state Exp;
branches;
next	1.59;
commitid	S7nbm0bGtG7Wdz0d;

1.59
date	2015.01.16.18.28.08;	author okan;	state Exp;
branches;
next	1.58;
commitid	j4Gu39WxCAE6Ivbz;

1.58
date	2014.01.30.22.41.16;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2014.01.30.22.17.22;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2014.01.29.18.34.22;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2014.01.28.20.22.21;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2014.01.28.00.42.20;	author okan;	state Exp;
branches;
next	1.53;

1.53
date	2014.01.27.14.49.40;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2014.01.24.22.38.02;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2014.01.20.21.34.32;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2014.01.20.19.06.04;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2013.12.13.14.40.52;	author okan;	state Exp;
branches;
next	1.48;

1.48
date	2013.11.25.18.21.55;	author benno;	state Exp;
branches;
next	1.47;

1.47
date	2013.07.16.14.04.44;	author okan;	state Exp;
branches;
next	1.46;

1.46
date	2013.07.08.16.32.51;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2013.06.03.20.33.17;	author sthen;	state Exp;
branches;
next	1.44;

1.44
date	2013.05.22.16.32.15;	author okan;	state Exp;
branches;
next	1.43;

1.43
date	2013.05.22.13.02.14;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.19.23.09.59;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2013.05.06.19.09.19;	author okan;	state Exp;
branches;
next	1.40;

1.40
date	2013.04.17.13.30.38;	author okan;	state Exp;
branches;
next	1.39;

1.39
date	2013.01.04.16.27.58;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2013.01.04.16.23.04;	author okan;	state Exp;
branches;
next	1.37;

1.37
date	2012.12.19.15.21.34;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2012.12.17.02.53.29;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2012.12.17.02.28.45;	author okan;	state Exp;
branches;
next	1.34;

1.34
date	2012.10.31.22.06.24;	author okan;	state Exp;
branches;
next	1.33;

1.33
date	2011.09.08.12.35.33;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2011.09.08.12.07.03;	author okan;	state Exp;
branches;
next	1.31;

1.31
date	2011.09.03.09.17.16;	author okan;	state Exp;
branches;
next	1.30;

1.30
date	2011.08.22.16.18.05;	author okan;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.25.15.10.24;	author okan;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.14.11.39.53;	author okan;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.24.06.06.24;	author okan;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.25.20.02.58;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.27.03.04.50;	author okan;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.11.17.51.42;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.20.00.22.39;	author okan;	state Exp;
branches;
next	1.20;

1.20
date	2009.05.17.23.40.57;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2009.02.07.21.07.00;	author martynas;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.23.19.00.59;	author okan;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.22.18.16.38;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.21.15.04.38;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.11.21.46.48;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.11.21.33.45;	author okan;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.16.19.09.48;	author mk;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.15.02.47.46;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.14.21.51.00;	author okan;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.14.21.48.54;	author okan;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.19.17.13.55;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.18.19.43.50;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.18.19.34.09;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.29.20.17.28;	author simon;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.16.13.38.09;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.15.18.46.58;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.15.18.22.08;	author okan;	state Exp;
branches;
next	1.1;

1.1
date	2008.03.23.15.09.21;	author simon;	state Exp;
branches;
next	;


desc
@@


1.68
log
@Switch bwidth type; unfortunately X11 is inconsistent.
@
text
@/*	$OpenBSD: parse.y,v 1.67 2016/12/01 17:17:27 okan Exp $ */

/*
 * Copyright (c) 2002, 2003, 2004 Henning Brauer <henning@@openbsd.org>
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

%{

#include <sys/types.h>
#include <sys/queue.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "calmwm.h"

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file, *topfile;
struct file	*pushfile(const char *);
int		 popfile(void);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...)
    __attribute__((__format__ (printf, 1, 2)))
    __attribute__((__nonnull__ (1)));
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

static struct conf	*conf;

typedef struct {
	union {
		int64_t			 number;
		char			*string;
	} v;
	int lineno;
} YYSTYPE;

%}

%token	BINDKEY UNBINDKEY BINDMOUSE UNBINDMOUSE
%token	FONTNAME STICKY GAP
%token	AUTOGROUP COMMAND IGNORE
%token	YES NO BORDERWIDTH MOVEAMOUNT
%token	COLOR SNAPDIST
%token	ACTIVEBORDER INACTIVEBORDER URGENCYBORDER
%token	GROUPBORDER UNGROUPBORDER
%token	MENUBG MENUFG
%token	FONTCOLOR FONTSELCOLOR
%token	ERROR
%token	<v.string>		STRING
%token	<v.number>		NUMBER
%type	<v.number>		yesno
%type	<v.string>		string
%%

grammar		: /* empty */
		| grammar '\n'
		| grammar main '\n'
		| grammar color '\n'
		| grammar error '\n'		{ file->errors++; }
		;

string		: string STRING			{
			if (asprintf(&$$, "%s %s", $1, $2) == -1) {
				free($1);
				free($2);
				yyerror("string: asprintf");
				YYERROR;
			}
			free($1);
			free($2);
		}
		| STRING
		;

yesno		: YES				{ $$ = 1; }
		| NO				{ $$ = 0; }
		;

main		: FONTNAME STRING		{
			free(conf->font);
			conf->font = $2;
		}
		| STICKY yesno {
			conf->stickygroups = $2;
		}
		| BORDERWIDTH NUMBER {
			if ($2 < 0 || $2 > INT_MAX) {
				yyerror("invalid borderwidth");
				YYERROR;
			}
			conf->bwidth = $2;
		}
		| MOVEAMOUNT NUMBER {
			if ($2 < 0 || $2 > INT_MAX) {
				yyerror("invalid movemount");
				YYERROR;
			}
			conf->mamount = $2;
		}
		| SNAPDIST NUMBER {
			if ($2 < 0 || $2 > INT_MAX) {
				yyerror("invalid snapdist");
				YYERROR;
			}
			conf->snapdist = $2;
		}
		| COMMAND STRING string		{
			if (!conf_cmd_add(conf, $2, $3)) {
				yyerror("command name/path too long");
				free($2);
				free($3);
				YYERROR;
			}
			free($2);
			free($3);
		}
		| AUTOGROUP NUMBER STRING	{
			if ($2 < 0 || $2 > 9) {
				yyerror("invalid autogroup");
				free($3);
				YYERROR;
			}
			conf_autogroup(conf, $2, NULL, $3);
			free($3);
		}
		| AUTOGROUP NUMBER STRING ',' STRING {
			if ($2 < 0 || $2 > 9) {
				yyerror("invalid autogroup");
				free($3);
				free($5);
				YYERROR;
			}
			conf_autogroup(conf, $2, $3, $5);
			free($3);
			free($5);
		}
		| IGNORE STRING {
			conf_ignore(conf, $2);
			free($2);
		}
		| GAP NUMBER NUMBER NUMBER NUMBER {
			if ($2 < 0 || $2 > INT_MAX ||
			    $3 < 0 || $3 > INT_MAX ||
			    $4 < 0 || $4 > INT_MAX ||
			    $5 < 0 || $5 > INT_MAX) {
				yyerror("invalid gap");
				YYERROR;
			}
			conf->gap.top = $2;
			conf->gap.bottom = $3;
			conf->gap.left = $4;
			conf->gap.right = $5;
		}
		| BINDKEY STRING string {
			if (!conf_bind_key(conf, $2, $3)) {
				yyerror("invalid bind-key: %s %s", $2, $3);
				free($2);
				free($3);
				YYERROR;
			}
			free($2);
			free($3);
		}
		| UNBINDKEY STRING {
			if (!conf_bind_key(conf, $2, NULL)) {
				yyerror("invalid unbind-key: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		| BINDMOUSE STRING string {
			if (!conf_bind_mouse(conf, $2, $3)) {
				yyerror("invalid bind-mouse: %s %s", $2, $3);
				free($2);
				free($3);
				YYERROR;
			}
			free($2);
			free($3);
		}
		| UNBINDMOUSE STRING {
			if (!conf_bind_mouse(conf, $2, NULL)) {
				yyerror("invalid unbind-mouse: %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

color		: COLOR colors
		;

colors		: ACTIVEBORDER STRING {
			free(conf->color[CWM_COLOR_BORDER_ACTIVE]);
			conf->color[CWM_COLOR_BORDER_ACTIVE] = $2;
		}
		| INACTIVEBORDER STRING {
			free(conf->color[CWM_COLOR_BORDER_INACTIVE]);
			conf->color[CWM_COLOR_BORDER_INACTIVE] = $2;
		}
		| URGENCYBORDER STRING {
			free(conf->color[CWM_COLOR_BORDER_URGENCY]);
			conf->color[CWM_COLOR_BORDER_URGENCY] = $2;
		}
		| GROUPBORDER STRING {
			free(conf->color[CWM_COLOR_BORDER_GROUP]);
			conf->color[CWM_COLOR_BORDER_GROUP] = $2;
		}
		| UNGROUPBORDER STRING {
			free(conf->color[CWM_COLOR_BORDER_UNGROUP]);
			conf->color[CWM_COLOR_BORDER_UNGROUP] = $2;
		}
		| MENUBG STRING {
			free(conf->color[CWM_COLOR_MENU_BG]);
			conf->color[CWM_COLOR_MENU_BG] = $2;
		}
		| MENUFG STRING {
			free(conf->color[CWM_COLOR_MENU_FG]);
			conf->color[CWM_COLOR_MENU_FG] = $2;
		}
		| FONTCOLOR STRING {
			free(conf->color[CWM_COLOR_MENU_FONT]);
			conf->color[CWM_COLOR_MENU_FONT] = $2;
		}
		| FONTSELCOLOR STRING {
			free(conf->color[CWM_COLOR_MENU_FONT_SEL]);
			conf->color[CWM_COLOR_MENU_FONT_SEL] = $2;
		}
		;
%%

struct keywords {
	const char	*k_name;
	int		 k_val;
};

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;

	file->errors++;
	va_start(ap, fmt);
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	return (0);
}

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "activeborder",	ACTIVEBORDER},
		{ "autogroup",		AUTOGROUP},
		{ "bind-key",		BINDKEY},
		{ "bind-mouse",		BINDMOUSE},
		{ "borderwidth",	BORDERWIDTH},
		{ "color",		COLOR},
		{ "command",		COMMAND},
		{ "font",		FONTCOLOR},
		{ "fontname",		FONTNAME},
		{ "gap",		GAP},
		{ "groupborder",	GROUPBORDER},
		{ "ignore",		IGNORE},
		{ "inactiveborder",	INACTIVEBORDER},
		{ "menubg",		MENUBG},
		{ "menufg",		MENUFG},
		{ "moveamount",		MOVEAMOUNT},
		{ "no",			NO},
		{ "selfont", 		FONTSELCOLOR},
		{ "snapdist",		SNAPDIST},
		{ "sticky",		STICKY},
		{ "unbind-key",		UNBINDKEY},
		{ "unbind-mouse",	UNBINDMOUSE},
		{ "ungroupborder",	UNGROUPBORDER},
		{ "urgencyborder",	URGENCYBORDER},
		{ "yes",		YES}
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p)
		return (p->k_val);
	else
		return (STRING);
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing "
			    "quoted string");
			if (file == topfile || popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (file == topfile || popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p;
	int	 quotec, next, c;
	int	 token;

	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = xstrdup(buf);
		return (STRING);
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

/* Similar to other parse.y copies, but also allows '/' in strings */
#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '#' && x != ','))

	if (isalnum(c) || c == ':' || c == '_' || c == '*' || c == '/') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			yylval.v.string = xstrdup(buf);
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

struct file *
pushfile(const char *name)
{
	struct file	*nfile;

	nfile = xcalloc(1, sizeof(struct file));
	nfile->name = xstrdup(name);

	if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL)
		prev->errors += file->errors;

	TAILQ_REMOVE(&files, file, entry);
	fclose(file->stream);
	free(file->name);
	free(file);
	file = prev;
	return (file ? 0 : EOF);
}

int
parse_config(const char *filename, struct conf *xconf)
{
	int		 errors = 0;

	conf = xconf;

	if ((file = pushfile(filename)) == NULL) {
		return (-1);
	}
	topfile = file;

	yyparse();
	errors = file->errors;
	popfile();

	return (errors ? -1 : 0);
}
@


1.67
log
@Normalize bind function names, based on a few categories: window, group, menu
and pointer.

Replace 'bind' and 'mousebind' options with 'bind-key' and 'bind-mouse',
respectively, replace special 'unmap' keyword with 'unbind-key' and
'unbind-mouse', and additionally allow unbinding all with 'all' keyword.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.66 2016/11/14 21:25:59 okan Exp $ */
d119 1
a119 1
			if ($2 < 0 || $2 > UINT_MAX) {
@


1.66
log
@Define callbacks, then default bindings.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.65 2016/10/03 14:42:34 okan Exp $ */
d71 3
a73 2
%token	FONTNAME STICKY GAP MOUSEBIND
%token	AUTOGROUP BIND COMMAND IGNORE
a172 10
		| BIND STRING string		{
			if (!conf_bind_key(conf, $2, $3)) {
				yyerror("invalid bind: %s %s", $2, $3);
				free($2);
				free($3);
				YYERROR;
			}
			free($2);
			free($3);
		}
d186 19
a204 1
		| MOUSEBIND STRING string	{
d206 1
a206 1
				yyerror("invalid mousebind: %s %s", $2, $3);
d214 8
d298 2
a299 1
		{ "bind",		BIND},
a310 1
		{ "mousebind",		MOUSEBIND},
d316 2
@


1.65
log
@Defaults are split between defines and conf_init(); normalize these, as
well as give 'sticky' groups its own variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.64 2015/05/17 04:39:50 kspillner Exp $ */
d173 1
a173 1
			if (!conf_bind_kbd(conf, $2, $3)) {
@


1.64
log
@Fix autogroup so name,class doesn't need to be quoted.

ok okan@@ on an older version of this diff
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.63 2015/05/17 04:34:01 kspillner Exp $ */
d115 1
a115 4
			if ($2 == 0)
				conf->flags &= ~CONF_STICKY_GROUPS;
			else
				conf->flags |= CONF_STICKY_GROUPS;
@


1.63
log
@Make window name and window class separate parameters to conf_autogroup.
No functional change, but will be used shortly.

ok okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2015/02/14 18:24:12 okan Exp $ */
d159 11
@


1.62
log
@simplify error messages; discussed with doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.61 2015/01/19 14:54:16 okan Exp $ */
d157 1
a157 1
			conf_autogroup(conf, $2, $3);
@


1.61
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2015/01/17 02:05:03 okan Exp $ */
d122 1
a122 1
				yyerror("invalid borderwidth: %lld", $2);
d129 1
a129 1
				yyerror("invalid movemount: %lld", $2);
d136 1
a136 1
				yyerror("invalid snapdist: %lld", $2);
d153 1
a154 1
				yyerror("invalid autogroup: %lld", $2);
d179 1
a179 2
				yyerror("invalid gap: %lld %lld %lld %lld",
				    $2, $3, $4, $5);
@


1.60
log
@Catch up with src parse.y changes by jsg@@:

Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2015/01/16 18:28:08 okan Exp $ */
d24 1
a24 1
#include <sys/param.h>
@


1.59
log
@Add gcc format attributes for yyerror(); fix a few yyerror() calls.

Adapted from src parse.y changes by doug@@. OK doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2014/01/30 22:41:16 okan Exp $ */
d441 3
@


1.58
log
@re-add lost free from previous
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2014/01/30 22:17:22 okan Exp $ */
d50 3
a52 1
int		 yyerror(const char *, ...);
d122 1
a122 1
				yyerror("invalid borderwidth: %d", $2);
d129 1
a129 1
				yyerror("invalid movemount: %d", $2);
d136 1
a136 1
				yyerror("invalid snapdist: %d", $2);
d154 1
a154 1
				yyerror("invalid autogroup: %d", $2);
d179 1
a179 1
				yyerror("invalid gap: %d %d %d %d",
@


1.57
log
@Switch ignoreq to winname struct since it's basically the same thing;
removes limit on name matching.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2014/01/29 18:34:22 okan Exp $ */
d160 1
@


1.56
log
@Check command name/path for truncation and provide user feedback during
config parse (and use conf_cmd_add to populate defaults); based on a
discussion with Tiago Cunha.  While this looks ugly, there are likely
some other changes here to come.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2014/01/28 20:22:21 okan Exp $ */
d159 1
a159 6
			if (!conf_ignore(conf, $2)) {
				yyerror("ignore windowname too long");
				free($2);
				YYERROR;
			}
			free($2);
@


1.55
log
@Check ignore windowname for truncation and provide user feedback during
config parse; based on a discussion with Tiago Cunha.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2014/01/28 00:42:20 okan Exp $ */
d140 6
a145 1
			conf_cmd_add(conf, $2, $3);
@


1.54
log
@Move conf_init/clear into main - no behaviour change; from Tiago Cunha.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2014/01/27 14:49:40 okan Exp $ */
d154 5
a158 1
			conf_ignore(conf, $2);
@


1.53
log
@simplify parse_config using assignment; inspired by a very old diff from
Tiago Cunha.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2014/01/24 22:38:02 okan Exp $ */
d548 1
a548 1
	int			 errors = 0;
a559 5

	if (errors) {
		conf_clear(conf);
		conf_init(conf);
	}
@


1.52
log
@more range checking
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2014/01/20 21:34:32 okan Exp $ */
d550 1
a550 1
	conf = xcalloc(1, sizeof(*conf));
a552 1
		free(conf);
a556 2
	conf_init(conf);

d563 1
a564 53
	else {
		struct autogroupwin	*ag;
		struct keybinding	*kb;
		struct winmatch		*wm;
		struct cmd		*cmd;
		struct mousebinding	*mb;
		int			 i;

		conf_clear(xconf);

		xconf->flags = conf->flags;
		xconf->bwidth = conf->bwidth;
		xconf->mamount = conf->mamount;
		xconf->snapdist = conf->snapdist;
		xconf->gap = conf->gap;

		while ((cmd = TAILQ_FIRST(&conf->cmdq)) != NULL) {
			TAILQ_REMOVE(&conf->cmdq, cmd, entry);
			TAILQ_INSERT_TAIL(&xconf->cmdq, cmd, entry);
		}

		while ((kb = TAILQ_FIRST(&conf->keybindingq)) != NULL) {
			TAILQ_REMOVE(&conf->keybindingq, kb, entry);
			TAILQ_INSERT_TAIL(&xconf->keybindingq, kb, entry);
		}

		while ((ag = TAILQ_FIRST(&conf->autogroupq)) != NULL) {
			TAILQ_REMOVE(&conf->autogroupq, ag, entry);
			TAILQ_INSERT_TAIL(&xconf->autogroupq, ag, entry);
		}

		while ((wm = TAILQ_FIRST(&conf->ignoreq)) != NULL) {
			TAILQ_REMOVE(&conf->ignoreq, wm, entry);
			TAILQ_INSERT_TAIL(&xconf->ignoreq, wm, entry);
		}

		while ((mb = TAILQ_FIRST(&conf->mousebindingq)) != NULL) {
			TAILQ_REMOVE(&conf->mousebindingq, mb, entry);
			TAILQ_INSERT_TAIL(&xconf->mousebindingq, mb, entry);
		}

		(void)strlcpy(xconf->termpath, conf->termpath,
		    sizeof(xconf->termpath));
		(void)strlcpy(xconf->lockpath, conf->lockpath,
		    sizeof(xconf->lockpath));

		for (i = 0; i < CWM_COLOR_NITEMS; i++)
			xconf->color[i] = conf->color[i];

		xconf->font = conf->font;
	}

	free(conf);
@


1.51
log
@constify and rename some confusing variables around cmdq.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2014/01/20 19:06:04 okan Exp $ */
d119 1
a119 1
			if ($2 < 0) {
d126 1
a126 1
			if ($2 < 0) {
d133 1
a133 1
			if ($2 < 0) {
d168 4
a171 1
			if ($2 < 0 || $3 < 0 || $4 < 0 || $5 < 0) {
@


1.50
log
@ - remove redundant range check for buttons in conf_bind_mouse.
 - make conf_bind_kbd return error on non-matches to match what
   conf_bind_mouse does.
 - rename some variables while here for clarity.
 - constify bind and cmd.

from Tiago Cunha.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2013/12/13 14:40:52 okan Exp $ */
d140 1
a140 1
			conf_cmd_add(conf, $3, $2);
@


1.49
log
@Add support for XUrgency and matching _NET_WM_STATE_DEMANDS_ATTENTION
ewmh hint; urgencyborder is configurable.  The urgency flag will stick,
even while on a client in a non-viewable group, until the client
receives focus (where the border is reset).  Initial diff from Thomas
Adam with some changes/enhancements from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2013/11/25 18:21:55 benno Exp $ */
d158 6
a163 1
			conf_bind_kbd(conf, $2, $3);
@


1.48
log
@Log message:
use u_char for buffers in yylex, for ctype calls, as done in all other
parse.y in the tree
found by millert@@, ok okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2013/07/16 14:04:44 okan Exp $ */
d73 1
a73 1
%token	ACTIVEBORDER INACTIVEBORDER
d196 4
d278 1
@


1.47
log
@max -> nitems
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2013/07/08 16:32:51 okan Exp $ */
d289 1
a289 1
char	*parsebuf;
d291 1
a291 1
char	 pushback_buffer[MAXPUSHBACK];
d384 2
a385 2
	char	 buf[8096];
	char	*p;
d426 1
a426 1
			*p++ = (char)c;
@


1.46
log
@clarify kbd vs mouse functions
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2013/06/03 20:33:17 sthen Exp $ */
d600 1
a600 1
		for (i = 0; i < CWM_COLOR_MAX; i++)
@


1.45
log
@Unlike other parse.y variants, cwm's allowed 'command xx /path/to/xx' without
quotes. Reinstate this support lost in recent sync diff and add a comment to
show that it's intentional. ok okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2013/05/22 16:32:15 okan Exp $ */
d158 1
a158 1
			conf_bindname(conf, $2, $3);
d174 1
a174 1
			if (!conf_mousebind(conf, $2, $3)) {
@


1.44
log
@move validation of pointer Button into conf_mousebind so we check
validity during the parse phase and not bother adding it to the queue,
instead of each time a client needs to grab (when it's too late);
furthermore, make this a config error, stop parsing and load the
default config.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2013/05/22 13:02:14 okan Exp $ */
d468 1
d472 1
a472 2
	x != '!' && x != '=' && x != '/' && x != '#' && \
	x != ','))
d474 1
a474 1
	if (isalnum(c) || c == ':' || c == '_' || c == '*') {
@


1.43
log
@sync with src changes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2013/05/19 23:09:59 okan Exp $ */
d174 6
a179 1
			conf_mousebind(conf, $2, $3);
@


1.42
log
@- switch border colors to Xft
- merge border/menu color structures/functions since they now both use Xft
- switch xu_xorcolor to operating on XftColor instead of just
  XRenderColor (basically adding pixel)
- if color name allocation fails, revert back to default (this, along
  with font validation should occur during config parse, but we don't
  have screens setup yet - likely to change at some point)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2013/05/06 19:09:19 okan Exp $ */
d45 11
a55 12
} *file;

struct file		*pushfile(const char *);
int			 popfile(void);
int			 yyparse(void);
int			 yylex(void);
int			 yyerror(const char *, ...);
int			 kw_cmp(const void *, const void *);
int			 lookup(char *);
int			 lgetc(int);
int			 lungetc(int);
int			 findeol(void);
d226 1
a226 1
	va_list ap;
d310 3
a312 2
			yyerror("reached end of file while parsing quoted string");
			if (popfile() == EOF)
d330 1
a330 1
		if (popfile() == EOF)
a358 1
	pushback_index = 0;
d362 4
a365 1
		c = lgetc(0);
d466 2
a467 1
	x != '!' && x != '=' && x != '#' && x != ','))
d469 1
a469 1
	if (isalnum(c) || c == ':' || c == '_' || c == '*' || c == '/') {
d501 1
d516 1
a516 1
	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
d518 7
a524 8
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
d538 1
a543 1
	file->errors = 0;
@


1.41
log
@negative values for borderwith, moveamount, snapdist and gap are
configuration errors, so warn and load defaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2013/04/17 13:30:38 okan Exp $ */
d201 2
a202 2
			free(conf->menucolor[CWM_COLOR_MENU_BG]);
			conf->menucolor[CWM_COLOR_MENU_BG] = $2;
d205 2
a206 2
			free(conf->menucolor[CWM_COLOR_MENU_FG]);
			conf->menucolor[CWM_COLOR_MENU_FG] = $2;
d209 2
a210 2
			free(conf->menucolor[CWM_COLOR_MENU_FONT]);
			conf->menucolor[CWM_COLOR_MENU_FONT] = $2;
d213 2
a214 2
			free(conf->menucolor[CWM_COLOR_MENU_FONT_SEL]);
			conf->menucolor[CWM_COLOR_MENU_FONT_SEL] = $2;
d592 1
a592 1
		for (i = 0; i < CWM_COLOR_BORDER_MAX; i++)
a593 3

		for (i = 0; i < CWM_COLOR_MENU_MAX; i++)
			xconf->menucolor[i] = conf->menucolor[i];
@


1.40
log
@add conf_ignore and move group_make_autogroup to conf_autogroup to match.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2013/01/04 16:27:58 okan Exp $ */
d120 4
d127 4
d134 4
d148 1
a148 1
				yyerror("autogroup number out of range: %d", $2);
a150 1

d164 5
@


1.39
log
@really these are just border colors, so adjust the define
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2013/01/04 16:23:04 okan Exp $ */
d140 1
a140 1
			group_make_autogroup(conf, $3, $2);
d144 1
a144 6
			struct winmatch	*wm;

			wm = xcalloc(1, sizeof(*wm));
			(void)strlcpy(wm->title, $2, sizeof(wm->title));
			TAILQ_INSERT_TAIL(&conf->ignoreq, wm, entry);

@


1.38
log
@get rid of struct color
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2012/12/19 15:21:34 okan Exp $ */
d581 1
a581 1
		for (i = 0; i < CWM_COLOR_MAX; i++)
@


1.37
log
@gc unused cmd 'flags' variable
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2012/12/17 02:53:29 okan Exp $ */
d174 2
a175 2
			free(conf->color[CWM_COLOR_BORDER_ACTIVE].name);
			conf->color[CWM_COLOR_BORDER_ACTIVE].name = $2;
d178 2
a179 2
			free(conf->color[CWM_COLOR_BORDER_INACTIVE].name);
			conf->color[CWM_COLOR_BORDER_INACTIVE].name = $2;
d182 2
a183 2
			free(conf->color[CWM_COLOR_BORDER_GROUP].name);
			conf->color[CWM_COLOR_BORDER_GROUP].name = $2;
d186 2
a187 2
			free(conf->color[CWM_COLOR_BORDER_UNGROUP].name);
			conf->color[CWM_COLOR_BORDER_UNGROUP].name = $2;
d582 1
a582 1
			xconf->color[i].name = conf->color[i].name;
@


1.36
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2012/12/17 02:28:45 okan Exp $ */
d129 1
a129 1
			conf_cmd_add(conf, $3, $2, 0);
@


1.35
log
@non-trivial menu drawing rewrite, moving to Xft and solving various
font/color drawing issues; from Alexander Polakov
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2012/10/31 22:06:24 okan Exp $ */
d585 1
a585 1
			xconf->menucolor[i]= conf->menucolor[i];
@


1.34
log
@no longer a reason to carry conf_path in struct conf, so dice.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2011/09/08 12:35:33 okan Exp $ */
d76 2
a77 1
%token	MENUBG MENUFG FONTCOLOR
d190 2
a191 2
			free(conf->color[CWM_COLOR_BG_MENU].name);
			conf->color[CWM_COLOR_BG_MENU].name = $2;
d194 2
a195 2
			free(conf->color[CWM_COLOR_FG_MENU].name);
			conf->color[CWM_COLOR_FG_MENU].name = $2;
d198 6
a203 2
			free(conf->color[CWM_COLOR_FONT].name);
			conf->color[CWM_COLOR_FONT].name = $2;
d255 1
d583 3
@


1.33
log
@allow configurable menu font color; from Alexander Polakov with a tweak
from me.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2011/09/08 12:07:03 okan Exp $ */
a517 2

	(void)strlcpy(conf->conf_path, filename, sizeof(conf->conf_path));
@


1.32
log
@allow menufg/menubg to be configurable; from Alexander Polakov.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2011/09/03 09:17:16 okan Exp $ */
d76 1
a76 1
%token	MENUBG MENUFG
d196 4
d239 1
@


1.31
log
@"defaultfont" is unclear (and confusing while reading code) when it also
applies to the user supplied font, so rename.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2011/08/22 16:18:05 okan Exp $ */
d76 1
d188 8
d240 2
@


1.30
log
@revert r1.11 of parse.y and create logic in conf_setup instead to deal
with the various scenarios of when to attempt a parse of the config,
load defaults, and when to warn and/or exit.  triggered by bogus warning
first noticed by sobrado@@.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2011/07/25 15:10:24 okan Exp $ */
d108 2
a109 2
			free(conf->DefaultFontName);
			conf->DefaultFontName = $2;
d564 1
a564 1
		xconf->DefaultFontName = conf->DefaultFontName;
@


1.29
log
@We are inconsistent when it comes to function returns, so just go all
the way with the cwm specific parts.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2011/07/14 11:39:53 okan Exp $ */
a464 2
		if (errno != ENOENT)
			warn("%s", nfile->name);
@


1.28
log
@correct spelling; from Alexander Polakov.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2011/06/24 06:06:24 okan Exp $ */
d145 1
a145 1
			strlcpy(wm->title, $2, sizeof(wm->title));
d505 1
a505 1
	strlcpy(conf->conf_path, filename, sizeof(conf->conf_path));
d558 1
a558 1
		strlcpy(xconf->termpath, conf->termpath,
d560 1
a560 1
		strlcpy(xconf->lockpath, conf->lockpath,
@


1.27
log
@introduce a new config option to snap to the screen edge.  'snapdist'
keyword taken from a diff from Sviatoslav Chagaev to do the same thing,
but implemented in a completely way (based on some very old code from
mk@@).  default set to 0, so no behavior change.

ok oga@@ (who would also like to take it further...)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2010/09/25 20:02:58 okan Exp $ */
d172 2
a173 2
			free(conf->color[CWM_COLOR_BORDOR_ACTIVE].name);
			conf->color[CWM_COLOR_BORDOR_ACTIVE].name = $2;
@


1.26
log
@picked a henning diff from src - original log:
fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2010/01/27 03:04:50 okan Exp $ */
d73 1
a73 1
%token	COLOR
d123 3
d234 1
d530 1
@


1.25
log
@- allow per-screen gap; not (yet) user configurable.
- teach _NET_WORKAREA about gap.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2009/12/15 04:10:42 okan Exp $ */
d369 2
a370 1
				else if (next == '\n')
d372 1
a372 1
				else
@


1.24
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2009/12/15 03:24:36 okan Exp $ */
d153 4
a156 4
			conf->gap_top = $2;
			conf->gap_bottom = $3;
			conf->gap_left = $4;
			conf->gap_right = $5;
d525 1
a560 2

		bcopy(&(conf->gap_top), &(xconf->gap_top), sizeof(int) * 4);
@


1.23
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2009/12/11 17:51:42 oga Exp $ */
d24 3
d28 1
@


1.22
log
@Implement _NET_DESKTOP_NAMES, this one was a bit tricky since thespec
says that a pager can change the property at any time (most need a
clientmessage). So deal with property updates.

Needed to shuffle some of the other code around since we can't just use
shortcut_to_name[] everywhere now.

ok okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2009/06/20 00:22:39 okan Exp $ */
a31 1
#include "headers.h"
@


1.21
log
@unroll XCALLOC/XMALLOC macros; since we use xcalloc/xmalloc all over the
place anyway, this makes things a bit more consistent; from Thomas Pfaff

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2009/05/17 23:40:57 okan Exp $ */
a125 3
			struct autogroupwin *aw;
			char *p;

d132 1
a132 14
			aw = xcalloc(1, sizeof(*aw));

			if ((p = strchr($3, ',')) == NULL) {
				aw->name = NULL;
				aw->class = xstrdup($3);
			} else {
				*(p++) = '\0';
				aw->name = xstrdup($3);
				aw->class = xstrdup(p);
			}
			aw->group = xstrdup(shortcut_to_name[$2]);

			TAILQ_INSERT_TAIL(&conf->autogroupq, aw, entry);

@


1.20
log
@a long time coming - re-work the way we deal with colors: since we're
using Xft(3), use it to select the font color as well instead of trying
to build one; properly allocate and free colors at-will, e.g. we now
have configurable colors.

feedback and ok's todd@@ and oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2009/02/07 21:07:00 martynas Exp $ */
d135 1
a135 1
			XCALLOC(aw, struct autogroupwin);
d154 1
a154 1
			XCALLOC(wm, struct winmatch);
d506 1
a506 1
	XCALLOC(conf, struct conf);
@


1.19
log
@add 'moveamount' to cwmrc;  it sets keyboard movement amount, making
it more useful on large screens
manpage tweak & ok jmc@@
ok okan@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2009/01/23 19:00:59 okan Exp $ */
d70 3
d83 1
d177 21
d230 1
d234 1
d238 1
d240 1
d245 1
d531 1
d568 3
@


1.18
log
@move conf_clear() and add proto.

ok todd@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2009/01/22 18:16:38 oga Exp $ */
d69 1
a69 1
%token	YES NO BORDERWIDTH
d113 3
d213 1
d506 1
@


1.17
log
@The default font name is strduped, so don't test for default font name
(therefore leaking it) when cleaning up a conf struct.

ok okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2009/01/21 15:04:38 todd Exp $ */
a465 43

void
conf_clear(struct conf *c)
{
	struct autogroupwin	*ag;
	struct keybinding	*kb;
	struct winmatch		*wm;
	struct cmd		*cmd;
	struct mousebinding	*mb;

	while ((cmd = TAILQ_FIRST(&c->cmdq)) != NULL) {
		TAILQ_REMOVE(&c->cmdq, cmd, entry);
		free(cmd);
	}

	while ((kb = TAILQ_FIRST(&c->keybindingq)) != NULL) {
		TAILQ_REMOVE(&c->keybindingq, kb, entry);
		free(kb);
	}

	while ((ag = TAILQ_FIRST(&c->autogroupq)) != NULL) {
		TAILQ_REMOVE(&c->autogroupq, ag, entry);
		free(ag->class);
		if (ag->name)
			free(ag->name);
		free(ag->group);
		free(ag);
	}

	while ((wm = TAILQ_FIRST(&c->ignoreq)) != NULL) {
		TAILQ_REMOVE(&c->ignoreq, wm, entry);
		free(wm);
	}

	while ((mb = TAILQ_FIRST(&c->mousebindingq)) != NULL) {
		TAILQ_REMOVE(&c->mousebindingq, mb, entry);
		free(mb);
	}

	if (c->DefaultFontName != NULL)
		free(c->DefaultFontName);
}

@


1.16
log
@borderwidth as a cwmrc(5) keyword, really helps debugging
from okan@@
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2009/01/11 21:46:48 oga Exp $ */
d505 1
a505 2
	if (c->DefaultFontName != NULL &&
	    c->DefaultFontName != DEFAULTFONTNAME)
@


1.15
log
@shortcut_to_name should not be defined as static in a header file. Put
it in group.c where it it used most, and add an extern definition for
the other users of it.

Found by gcc -Wall. ok okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2009/01/11 21:33:45 okan Exp $ */
d69 1
a69 1
%token	YES NO
d110 3
d204 1
d545 1
@


1.14
log
@better comparison idiom; found with -Wall

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2008/06/16 19:09:48 mk Exp $ */
a55 2

extern char		*shortcut_to_name[];
@


1.13
log
@Make this not crash when compiled with -g.

Found by myself, analysis by kurt@@, fix by me with input from otto.

``Just get some fix in...'' deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2008/06/15 02:47:46 oga Exp $ */
d474 1
a474 1
	while (cmd = TAILQ_FIRST(&c->cmdq)) {
d479 1
a479 1
	while (kb = TAILQ_FIRST(&c->keybindingq)) {
d484 1
a484 1
	while (ag = TAILQ_FIRST(&c->autogroupq)) {
d493 1
a493 1
	while (wm = TAILQ_FIRST(&c->ignoreq)) {
d498 1
a498 1
	while (mb = TAILQ_FIRST(&c->mousebindingq)) {
d544 1
a544 1
		while (cmd = TAILQ_FIRST(&conf->cmdq)) {
d549 1
a549 1
		while (kb = TAILQ_FIRST(&conf->keybindingq)) {
d554 1
a554 1
		while (ag = TAILQ_FIRST(&conf->autogroupq)) {
d559 1
a559 1
		while (wm = TAILQ_FIRST(&conf->ignoreq)) {
d564 1
a564 1
		while (mb = TAILQ_FIRST(&conf->mousebindingq)) {
@


1.12
log
@Rip out and burn the HASH_* stuff. We don't need a SPLAY tree for one font.
makes the code a lot simpler. While here rearrange the font handling functions
to be less shit.

ok and help okan@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2008/06/14 21:51:00 okan Exp $ */
d103 2
a104 5
			if (conf->DefaultFontName != NULL &&
			    conf->DefaultFontName != DEFAULTFONTNAME)
				free(conf->DefaultFontName);
			conf->DefaultFontName = xstrdup($2);
			free($2);
@


1.11
log
@slightly alter the semantics of config files:
 - if no config file, continue silently and apply defaults
 - if config file, parse and move on
 - if config file specified but not found, error out

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2008/06/14 21:48:54 okan Exp $ */
d106 1
a106 5
			if ((conf->DefaultFontName = xstrdup($2)) == NULL) {
				free($2);
				yyerror("string: asprintf");
				YYERROR;
			}
@


1.10
log
@confable menu and window mouse bindings from rivo nurges (thanks!) with
some minor fixups, man page bits and knf.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2008/05/19 17:13:55 oga Exp $ */
d444 2
a445 1
		warn("%s", nfile->name);
@


1.9
log
@allow an autogroup value of 0 to mean no group. This means you can set
automatically "sticky" (in the traditional sense of the word) windows in
autogroup mode.

Based on an initial diff from Andrew Fresh, thanks!

ok okan@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.8 2008/05/18 19:43:50 oga Exp $ */
d69 1
a69 1
%token	FONTNAME STICKY GAP
d170 5
d214 1
d478 1
d504 5
d544 1
d568 5
@


1.8
log
@Kill conf_get_int(), it was a silly function anyway.

Since it's only used once just put the (simplified) logic into
conf_client() instead. This  means we can kill an enum and
CONF_IGNORECASE, too.

ok okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.7 2008/05/18 19:34:09 oga Exp $ */
d128 1
a128 1
			if ($2 < 1 || $2 > 9) {
@


1.7
log
@When we're cleaning out the lists in parse_config and conf_clear it's a
lot simpler just to do while (entry = TAILQ_FIRST(head)) than to do a
for () over the whole lot. Simpler, shorter and probably faster.

ok okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.6 2008/04/29 20:17:28 simon Exp $ */
a154 1
			wm->opts |= CONF_IGNORECASE;
@


1.6
log
@Allow slashes in unquoted strings.

From Pierre Riteau
Makes sense to oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.5 2008/04/16 13:38:09 oga Exp $ */
d469 4
a472 7
	struct autogroupwin	*ag, *agnext;
	struct keybinding	*kb, *kbnext;
	struct winmatch		*wm, *wmnext;
	struct cmd		*cmd, *cmdnext;

	for (cmd = TAILQ_FIRST(&c->cmdq); cmd != NULL; cmd = cmdnext) {
		cmdnext = TAILQ_NEXT(cmd, entry);
d474 1
d479 1
a479 3
	for (kb = TAILQ_FIRST(&c->keybindingq); kb != NULL; kb = kbnext) {
		kbnext = TAILQ_NEXT(kb, entry);

d484 1
a484 3
	for (ag = TAILQ_FIRST(&c->autogroupq); ag != NULL; ag = agnext) {
		agnext = TAILQ_NEXT(ag, entry);

d493 1
a493 3
	for (wm = TAILQ_FIRST(&c->ignoreq); wm != NULL; wm = wmnext) {
		wmnext = TAILQ_NEXT(wm, entry);

d529 4
a532 4
		struct autogroupwin	*ag, *agnext;
		struct keybinding	*kb, *kbnext;
		struct winmatch		*wm, *wmnext;
		struct cmd		*cmd, *cmdnext;
d538 1
a538 4
		for (cmd = TAILQ_FIRST(&conf->cmdq); cmd != NULL;
		    cmd = cmdnext) {
			cmdnext = TAILQ_NEXT(cmd, entry);

d543 1
a543 4
		for (kb = TAILQ_FIRST(&conf->keybindingq); kb != NULL;
		    kb = kbnext) {
			kbnext = TAILQ_NEXT(kb, entry);

d548 1
a548 4
		for (ag = TAILQ_FIRST(&conf->autogroupq); ag != NULL;
		    ag = agnext) {
			agnext = TAILQ_NEXT(ag, entry);

d553 1
a553 4
		for (wm = TAILQ_FIRST(&conf->ignoreq); wm != NULL;
		    wm = wmnext) {
			wmnext = TAILQ_NEXT(wm, entry);

@


1.5
log
@Replace a few leftover calls to strdup and calloc with xstrdup and xcalloc
respectively.

ok okan.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.4 2008/04/15 20:24:41 oga Exp $ */
d405 1
a405 2
	x != '!' && x != '=' && x != '/' && x != '#' && \
	x != ','))
d407 1
a407 1
	if (isalnum(c) || c == ':' || c == '_' || c == '*') {
@


1.4
log
@hit it with the knf stick.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.3 2008/04/15 18:46:58 oga Exp $ */
d362 1
a362 3
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
d419 1
a419 2
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
d436 3
a438 5
	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
		warn("malloc");
		return (NULL);
	}
@


1.3
log
@Add "gap" support to .cwmrc. The options put in here make gaps on the edge
of the screen where an application won't be {,vert}maximized over. used for
placing a statusbar or something like xclock.

Patch from Edd Barrett, with input from myself and okan. Thanks!

ok okan@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.2 2008/04/15 18:22:08 okan Exp $ */
d43 11
a53 10
struct file	*pushfile(const char *);
int		 popfile(void);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...);
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);
d101 1
a101 1
  
d182 3
a184 3
	va_list          ap;
                         
	file->errors++;         
d552 2
a553 1
		for (cmd = TAILQ_FIRST(&conf->cmdq); cmd != NULL; cmd = cmdnext) {
d560 2
a561 1
		for (kb = TAILQ_FIRST(&conf->keybindingq); kb != NULL; kb = kbnext) {
d568 2
a569 1
		for (ag = TAILQ_FIRST(&conf->autogroupq); ag != NULL; ag = agnext) {
d576 2
a577 1
		for (wm = TAILQ_FIRST(&conf->ignoreq); wm != NULL; wm = wmnext) {
d584 4
a587 2
		strlcpy(xconf->termpath, conf->termpath, sizeof(xconf->termpath));
		strlcpy(xconf->lockpath, conf->lockpath, sizeof(xconf->lockpath));
@


1.2
log
@malloc -> calloc

suggested by and ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.1 2008/03/23 15:09:21 simon Exp $ */
d68 1
a68 1
%token	FONTNAME STICKY
d164 6
a170 1

d207 1
d583 2
@


1.1
log
@Replace the symlink configuration scheme with a simple yacc parser as
found in other places of the tree.  Remove sticky and font commandline
options and add another one for alternative config locations.
Split off cwmrc(5) from cwm(1), nuke #ifdef __OpenBSD__ while there.

tested by various kind people, feedback from oga@@ and okan@@ - thanks!
ok oga@@, jasper@@, okan@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d516 1
a516 2
	if ((conf = malloc(sizeof(struct conf))) == NULL)
		return (-1);
@

