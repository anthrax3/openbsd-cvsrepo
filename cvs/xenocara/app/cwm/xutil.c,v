head	1.108;
access;
symbols
	OPENBSD_6_1:1.108.0.2
	OPENBSD_6_1_BASE:1.108
	OPENBSD_6_0:1.103.0.4
	OPENBSD_6_0_BASE:1.103
	OPENBSD_5_9:1.103.0.2
	OPENBSD_5_9_BASE:1.103
	OPENBSD_5_8:1.99.0.2
	OPENBSD_5_8_BASE:1.99
	OPENBSD_5_7:1.97.0.2
	OPENBSD_5_7_BASE:1.97
	OPENBSD_5_6:1.85.0.4
	OPENBSD_5_6_BASE:1.85
	OPENBSD_5_5:1.85.0.2
	OPENBSD_5_5_BASE:1.85
	OPENBSD_5_4:1.74.0.2
	OPENBSD_5_4_BASE:1.74
	OPENBSD_5_3:1.52.0.2
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.45.0.2
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.17.0.2
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.108
date	2016.10.05.13.10.59;	author okan;	state Exp;
branches;
next	1.107;
commitid	LHP16HwBOYF7jUIx;

1.107
date	2016.10.04.15.18.20;	author okan;	state Exp;
branches;
next	1.106;
commitid	A3zvKURgft7ltYQX;

1.106
date	2016.09.30.18.28.06;	author okan;	state Exp;
branches;
next	1.105;
commitid	STecP6DPl2bavnIv;

1.105
date	2016.09.28.17.06.33;	author okan;	state Exp;
branches;
next	1.104;
commitid	UDBUlJ5kvU8CcYZj;

1.104
date	2016.09.16.14.32.02;	author okan;	state Exp;
branches;
next	1.103;
commitid	JzYS0uWdEYDeM0Hk;

1.103
date	2015.08.27.18.53.15;	author okan;	state Exp;
branches;
next	1.102;
commitid	zidCZkwdtbi68xMi;

1.102
date	2015.08.24.15.42.57;	author okan;	state Exp;
branches;
next	1.101;
commitid	xGzIdCzrHkoqADxN;

1.101
date	2015.08.24.14.56.10;	author okan;	state Exp;
branches;
next	1.100;
commitid	3heeYolWUzcrSGXI;

1.100
date	2015.08.21.16.30.02;	author okan;	state Exp;
branches;
next	1.99;
commitid	MiLmJumEJ6sclldP;

1.99
date	2015.03.28.23.12.47;	author okan;	state Exp;
branches;
next	1.98;
commitid	nwNT3PjeOYm65gQ8;

1.98
date	2015.03.28.21.55.48;	author okan;	state Exp;
branches;
next	1.97;
commitid	95UcA4BbavAMsxk7;

1.97
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.96;
commitid	kLADTGYX3gw0Sf2m;

1.96
date	2014.09.23.14.25.08;	author okan;	state Exp;
branches;
next	1.95;
commitid	rp7vMsjSPRy6s8TJ;

1.95
date	2014.09.17.18.41.44;	author okan;	state Exp;
branches;
next	1.94;
commitid	7QDlXoO0YzmTdgVS;

1.94
date	2014.09.17.16.00.44;	author okan;	state Exp;
branches;
next	1.93;
commitid	PwtpIdl7nXCakavw;

1.93
date	2014.09.15.13.00.49;	author okan;	state Exp;
branches;
next	1.92;
commitid	VPtTUp6sF9rrEiW2;

1.92
date	2014.09.08.20.11.22;	author okan;	state Exp;
branches;
next	1.91;
commitid	cu11ybsl8atTMRXD;

1.91
date	2014.09.07.19.27.30;	author okan;	state Exp;
branches;
next	1.90;
commitid	jXQ1fztXcP9vyPb1;

1.90
date	2014.09.06.16.08.58;	author okan;	state Exp;
branches;
next	1.89;
commitid	hqjCXxcyI22RFKvg;

1.89
date	2014.08.25.14.31.22;	author okan;	state Exp;
branches;
next	1.88;
commitid	IBKKLiHu5PwQFfcG;

1.88
date	2014.08.25.12.49.19;	author okan;	state Exp;
branches;
next	1.87;
commitid	rbGNqfikQcQWLop3;

1.87
date	2014.08.22.19.04.00;	author okan;	state Exp;
branches;
next	1.86;
commitid	INCxCbmjnfOT88xa;

1.86
date	2014.08.20.15.15.29;	author okan;	state Exp;
branches;
next	1.85;
commitid	SsDu0AngUZExtrz4;

1.85
date	2014.02.27.00.52.57;	author okan;	state Exp;
branches;
next	1.84;

1.84
date	2014.02.07.21.59.56;	author okan;	state Exp;
branches;
next	1.83;

1.83
date	2014.01.03.15.29.06;	author okan;	state Exp;
branches;
next	1.82;

1.82
date	2013.12.17.16.10.43;	author okan;	state Exp;
branches;
next	1.81;

1.81
date	2013.12.16.19.02.17;	author okan;	state Exp;
branches;
next	1.80;

1.80
date	2013.12.13.14.40.52;	author okan;	state Exp;
branches;
next	1.79;

1.79
date	2013.12.11.14.16.10;	author okan;	state Exp;
branches;
next	1.78;

1.78
date	2013.10.20.02.00.02;	author okan;	state Exp;
branches;
next	1.77;

1.77
date	2013.10.20.01.55.32;	author okan;	state Exp;
branches;
next	1.76;

1.76
date	2013.10.19.19.39.34;	author okan;	state Exp;
branches;
next	1.75;

1.75
date	2013.10.03.13.52.00;	author okan;	state Exp;
branches;
next	1.74;

1.74
date	2013.07.16.14.30.48;	author okan;	state Exp;
branches;
next	1.73;

1.73
date	2013.07.15.23.51.59;	author okan;	state Exp;
branches;
next	1.72;

1.72
date	2013.07.15.14.50.44;	author okan;	state Exp;
branches;
next	1.71;

1.71
date	2013.07.10.14.11.42;	author okan;	state Exp;
branches;
next	1.70;

1.70
date	2013.07.08.15.48.16;	author okan;	state Exp;
branches;
next	1.69;

1.69
date	2013.06.10.21.37.30;	author okan;	state Exp;
branches;
next	1.68;

1.68
date	2013.05.27.23.20.45;	author okan;	state Exp;
branches;
next	1.67;

1.67
date	2013.05.23.16.52.39;	author okan;	state Exp;
branches;
next	1.66;

1.66
date	2013.05.21.00.29.20;	author okan;	state Exp;
branches;
next	1.65;

1.65
date	2013.05.20.21.13.58;	author okan;	state Exp;
branches;
next	1.64;

1.64
date	2013.05.20.20.21.04;	author okan;	state Exp;
branches;
next	1.63;

1.63
date	2013.05.19.23.38.21;	author okan;	state Exp;
branches;
next	1.62;

1.62
date	2013.05.19.23.09.59;	author okan;	state Exp;
branches;
next	1.61;

1.61
date	2013.05.19.17.05.52;	author okan;	state Exp;
branches;
next	1.60;

1.60
date	2013.05.19.17.03.55;	author okan;	state Exp;
branches;
next	1.59;

1.59
date	2013.05.10.16.32.48;	author okan;	state Exp;
branches;
next	1.58;

1.58
date	2013.05.10.16.05.34;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2013.05.10.15.44.43;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2013.04.17.13.57.06;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2013.04.17.13.52.20;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.14.16.13.17;	author okan;	state Exp;
branches;
next	1.53;

1.53
date	2013.04.10.19.08.09;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2013.01.01.14.19.56;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2012.12.17.18.34.06;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2012.12.17.02.28.45;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.48;

1.48
date	2012.11.08.20.18.19;	author okan;	state Exp;
branches;
next	1.47;

1.47
date	2012.11.07.20.34.39;	author okan;	state Exp;
branches;
next	1.46;

1.46
date	2012.10.31.19.30.19;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2012.07.13.17.01.05;	author okan;	state Exp;
branches;
next	1.44;

1.44
date	2012.07.13.15.21.35;	author okan;	state Exp;
branches;
next	1.43;

1.43
date	2012.07.08.02.55.01;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2012.07.08.02.50.41;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2012.07.03.13.49.03;	author okan;	state Exp;
branches;
next	1.40;

1.40
date	2012.05.16.01.17.14;	author okan;	state Exp;
branches;
next	1.39;

1.39
date	2012.05.16.01.04.36;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2012.05.13.15.15.54;	author okan;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.25.15.10.24;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.23.13.09.11;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.22.10.57.31;	author okan;	state Exp;
branches;
next	1.33;

1.33
date	2011.03.22.10.49.46;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2010.05.22.22.32.08;	author okan;	state Exp;
branches;
next	1.31;

1.31
date	2010.05.22.22.10.31;	author okan;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.11.16.51.26;	author okan;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.27;

1.27
date	2009.12.14.16.39.01;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.11.18.09.16;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.11.17.55.42;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.11.17.51.42;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.10.23.21.26;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.10.23.14.58;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.07.23.19.51;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.07.22.46.15;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.07.22.21.59;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.07.21.20.52;	author okan;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.26.12.21.58;	author okan;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.17.13.08.37;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2009.05.17.23.40.57;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.27.00.42.53;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.23.20.07.20;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.23.20.04.30;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.22.18.06.16;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.22.15.26.33;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.07.22.20.26.12;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.17.23.40.33;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.15.22.18.00;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.16.11.39.20;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.108
log
@Stash wmname into conf.
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: xutil.c,v 1.107 2016/10/04 15:18:20 okan Exp $
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

void
xu_ptr_getpos(Window win, int *x, int *y)
{
	Window		 w0, w1;
	int		 tmp0, tmp1;
	unsigned int	 tmp2;

	XQueryPointer(X_Dpy, win, &w0, &w1, &tmp0, &tmp1, x, y, &tmp2);
}

void
xu_ptr_setpos(Window win, int x, int y)
{
	XWarpPointer(X_Dpy, None, win, 0, 0, 0, 0, x, y);
}

int
xu_getprop(Window win, Atom atm, Atom type, long len, unsigned char **p)
{
	Atom		 realtype;
	unsigned long	 n, extra;
	int		 format;

	if (XGetWindowProperty(X_Dpy, win, atm, 0L, len, False, type,
	    &realtype, &format, &n, &extra, p) != Success || *p == NULL)
		return(-1);

	if (n == 0)
		XFree(*p);

	return(n);
}

int
xu_getstrprop(Window win, Atom atm, char **text) {
	XTextProperty	 prop;
	char		**list;
	int		 nitems = 0;

	*text = NULL;

	XGetTextProperty(X_Dpy, win, &prop, atm);
	if (!prop.nitems)
		return(0);

	if (Xutf8TextPropertyToTextList(X_Dpy, &prop, &list,
	    &nitems) == Success && nitems > 0 && *list) {
		if (nitems > 1) {
			XTextProperty    prop2;
			if (Xutf8TextListToTextProperty(X_Dpy, list, nitems,
			    XUTF8StringStyle, &prop2) == Success) {
				*text = xstrdup((const char *)prop2.value);
				XFree(prop2.value);
			}
		} else {
			*text = xstrdup(*list);
		}
		XFreeStringList(list);
	}

	XFree(prop.value);

	return(nitems);
}

/* Root Window Properties */
void
xu_ewmh_net_supported(struct screen_ctx *sc)
{
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_SUPPORTED],
	    XA_ATOM, 32, PropModeReplace, (unsigned char *)ewmh, EWMH_NITEMS);
}

void
xu_ewmh_net_supported_wm_check(struct screen_ctx *sc)
{
	Window	 w;

	w = XCreateSimpleWindow(X_Dpy, sc->rootwin, -1, -1, 1, 1, 0, 0, 0);
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_SUPPORTING_WM_CHECK],
	    XA_WINDOW, 32, PropModeReplace, (unsigned char *)&w, 1);
	XChangeProperty(X_Dpy, w, ewmh[_NET_SUPPORTING_WM_CHECK],
	    XA_WINDOW, 32, PropModeReplace, (unsigned char *)&w, 1);
	XChangeProperty(X_Dpy, w, ewmh[_NET_WM_NAME],
	    cwmh[UTF8_STRING], 8, PropModeReplace,
	    (unsigned char *)Conf.wmname, strlen(Conf.wmname));
}

void
xu_ewmh_net_desktop_geometry(struct screen_ctx *sc)
{
	long	 geom[2] = { sc->view.w, sc->view.h };

	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_DESKTOP_GEOMETRY],
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)geom , 2);
}

void
xu_ewmh_net_workarea(struct screen_ctx *sc)
{
	unsigned long	*workarea;
	int		 i, ngroups = Conf.ngroups;

	workarea = xreallocarray(NULL, ngroups * 4, sizeof(unsigned long));
	for (i = 0; i < ngroups; i++) {
		workarea[4 * i + 0] = sc->work.x;
		workarea[4 * i + 1] = sc->work.y;
		workarea[4 * i + 2] = sc->work.w;
		workarea[4 * i + 3] = sc->work.h;
	}
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_WORKAREA],
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)workarea,
	    ngroups * 4);
	free(workarea);
}

void
xu_ewmh_net_client_list(struct screen_ctx *sc)
{
	struct client_ctx	*cc;
	Window			*winlist;
	int			 i = 0, j = 0;

	TAILQ_FOREACH(cc, &sc->clientq, entry)
		i++;
	if (i == 0)
		return;

	winlist = xreallocarray(NULL, i, sizeof(*winlist));
	TAILQ_FOREACH(cc, &sc->clientq, entry)
		winlist[j++] = cc->win;
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_CLIENT_LIST],
	    XA_WINDOW, 32, PropModeReplace, (unsigned char *)winlist, i);
	free(winlist);
}

void
xu_ewmh_net_client_list_stacking(struct screen_ctx *sc)
{
	struct client_ctx	*cc;
	Window			*winlist;
	int			 i = 0, j;

	TAILQ_FOREACH(cc, &sc->clientq, entry)
		i++;
	if (i == 0)
		return;

	j = i;
	winlist = xreallocarray(NULL, i, sizeof(*winlist));
	TAILQ_FOREACH(cc, &sc->clientq, entry)
		winlist[--j] = cc->win;
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_CLIENT_LIST_STACKING],
	    XA_WINDOW, 32, PropModeReplace, (unsigned char *)winlist, i);
	free(winlist);
}

void
xu_ewmh_net_active_window(struct screen_ctx *sc, Window w)
{
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_ACTIVE_WINDOW],
	    XA_WINDOW, 32, PropModeReplace, (unsigned char *)&w, 1);
}

Window
xu_ewmh_get_net_active_window(struct screen_ctx *sc)
{
	long		*p;
	Window		 win;

	if ((xu_getprop(sc->rootwin, ewmh[_NET_ACTIVE_WINDOW],
	    XA_WINDOW, 32, (unsigned char **)&p)) <= 0)
		return(None);

	win = (Window)*p;
	XFree(p);

	return(win);
}

void
xu_ewmh_net_wm_desktop_viewport(struct screen_ctx *sc)
{
	long	 viewports[2] = {0, 0};

	/* We don't support large desktops, so this is (0, 0). */
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_DESKTOP_VIEWPORT],
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)viewports, 2);
}

void
xu_ewmh_net_wm_number_of_desktops(struct screen_ctx *sc)
{
	long	 ndesks = Conf.ngroups;

	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_NUMBER_OF_DESKTOPS],
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&ndesks, 1);
}

void
xu_ewmh_net_showing_desktop(struct screen_ctx *sc)
{
	long	 zero = 0;

	/* We don't support `showing desktop' mode, so this is zero.
	 * Note that when we hide all groups, or when all groups are
	 * hidden we could technically set this later on.
	 */
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_SHOWING_DESKTOP],
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&zero, 1);
}

void
xu_ewmh_net_virtual_roots(struct screen_ctx *sc)
{
	/* We don't support virtual roots, so delete if set by previous wm. */
	XDeleteProperty(X_Dpy, sc->rootwin, ewmh[_NET_VIRTUAL_ROOTS]);
}

void
xu_ewmh_net_current_desktop(struct screen_ctx *sc)
{
	long	 num = sc->group_active->num;

	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_CURRENT_DESKTOP],
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&num, 1);
}

void
xu_ewmh_net_desktop_names(struct screen_ctx *sc)
{
	struct group_ctx	*gc;
	char			*p, *q;
	unsigned char		*prop_ret;
	int			 i = 0, j = 0, nstrings = 0, n = 0;
	size_t			 len = 0, tlen, slen;

	/* Let group names be overwritten if _NET_DESKTOP_NAMES is set. */

	if ((j = xu_getprop(sc->rootwin, ewmh[_NET_DESKTOP_NAMES],
	    cwmh[UTF8_STRING], 0xffffff, (unsigned char **)&prop_ret)) > 0) {
		prop_ret[j - 1] = '\0'; /* paranoia */
		while (i < j) {
			if (prop_ret[i++] == '\0')
				nstrings++;
		}
	}

	p = (char *)prop_ret;
	while (n < nstrings) {
		TAILQ_FOREACH(gc, &sc->groupq, entry) {
			if (gc->num == n) {
				free(gc->name);
				gc->name = xstrdup(p);
				p += strlen(p) + 1;
				break;
			}
		}
		n++;
	}
	if (prop_ret != NULL)
		XFree(prop_ret);

	TAILQ_FOREACH(gc, &sc->groupq, entry)
		len += strlen(gc->name) + 1;
	q = p = xreallocarray(NULL, len, sizeof(*p));

	tlen = len;
	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		slen = strlen(gc->name) + 1;
		(void)strlcpy(q, gc->name, tlen);
		tlen -= slen;
		q += slen;
	}

	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_DESKTOP_NAMES],
	    cwmh[UTF8_STRING], 8, PropModeReplace, (unsigned char *)p, len);
	free(p);
}

/* Application Window Properties */
void
xu_ewmh_net_wm_desktop(struct client_ctx *cc)
{
	long	 num = 0xffffffff;

	if (cc->gc)
		num = cc->gc->num;

	XChangeProperty(X_Dpy, cc->win, ewmh[_NET_WM_DESKTOP],
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&num, 1);
}

Atom *
xu_ewmh_get_net_wm_state(struct client_ctx *cc, int *n)
{
	Atom	*state, *p = NULL;

	if ((*n = xu_getprop(cc->win, ewmh[_NET_WM_STATE], XA_ATOM, 64L,
	    (unsigned char **)&p)) <= 0)
		return(NULL);

	state = xreallocarray(NULL, *n, sizeof(Atom));
	(void)memcpy(state, p, *n * sizeof(Atom));
	XFree((char *)p);

	return(state);
}

void
xu_ewmh_handle_net_wm_state_msg(struct client_ctx *cc, int action,
    Atom first, Atom second)
{
	unsigned int i;
	static struct handlers {
		int atom;
		int property;
		void (*toggle)(struct client_ctx *);
	} handlers[] = {
		{ _NET_WM_STATE_STICKY,
			CLIENT_STICKY,
			client_toggle_sticky },
		{ _NET_WM_STATE_MAXIMIZED_VERT,
			CLIENT_VMAXIMIZED,
			client_toggle_vmaximize },
		{ _NET_WM_STATE_MAXIMIZED_HORZ,
			CLIENT_HMAXIMIZED,
			client_toggle_hmaximize },
		{ _NET_WM_STATE_HIDDEN,
			CLIENT_HIDDEN,
			client_toggle_hidden },
		{ _NET_WM_STATE_FULLSCREEN,
			CLIENT_FULLSCREEN,
			client_toggle_fullscreen },
		{ _NET_WM_STATE_DEMANDS_ATTENTION,
			CLIENT_URGENCY,
			client_urgency },
		{ _CWM_WM_STATE_FREEZE,
			CLIENT_FREEZE,
			client_toggle_freeze },
	};

	for (i = 0; i < nitems(handlers); i++) {
		if (first != ewmh[handlers[i].atom] &&
		    second != ewmh[handlers[i].atom])
			continue;
		switch (action) {
		case _NET_WM_STATE_ADD:
			if (!(cc->flags & handlers[i].property))
				handlers[i].toggle(cc);
			break;
		case _NET_WM_STATE_REMOVE:
			if (cc->flags & handlers[i].property)
				handlers[i].toggle(cc);
			break;
		case _NET_WM_STATE_TOGGLE:
			handlers[i].toggle(cc);
		}
	}
}

void
xu_ewmh_restore_net_wm_state(struct client_ctx *cc)
{
	Atom	*atoms;
	int	 i, n;

	atoms = xu_ewmh_get_net_wm_state(cc, &n);
	for (i = 0; i < n; i++) {
		if (atoms[i] == ewmh[_NET_WM_STATE_STICKY])
			client_toggle_sticky(cc);
		if (atoms[i] == ewmh[_NET_WM_STATE_MAXIMIZED_VERT])
			client_toggle_vmaximize(cc);
		if (atoms[i] == ewmh[_NET_WM_STATE_MAXIMIZED_HORZ])
			client_toggle_hmaximize(cc);
		if (atoms[i] == ewmh[_NET_WM_STATE_HIDDEN])
			client_toggle_hidden(cc);
		if (atoms[i] == ewmh[_NET_WM_STATE_FULLSCREEN])
			client_toggle_fullscreen(cc);
		if (atoms[i] == ewmh[_NET_WM_STATE_DEMANDS_ATTENTION])
			client_urgency(cc);
		if (atoms[i] == ewmh[_CWM_WM_STATE_FREEZE])
			client_toggle_freeze(cc);
	}
	free(atoms);
}

void
xu_ewmh_set_net_wm_state(struct client_ctx *cc)
{
	Atom	*atoms, *oatoms;
	int	 n, i, j;

	oatoms = xu_ewmh_get_net_wm_state(cc, &n);
	atoms = xreallocarray(NULL, (n + _NET_WM_STATES_NITEMS), sizeof(Atom));
	for (i = j = 0; i < n; i++) {
		if (oatoms[i] != ewmh[_NET_WM_STATE_STICKY] &&
		    oatoms[i] != ewmh[_NET_WM_STATE_MAXIMIZED_VERT] &&
		    oatoms[i] != ewmh[_NET_WM_STATE_MAXIMIZED_HORZ] &&
		    oatoms[i] != ewmh[_NET_WM_STATE_HIDDEN] &&
		    oatoms[i] != ewmh[_NET_WM_STATE_FULLSCREEN] &&
		    oatoms[i] != ewmh[_NET_WM_STATE_DEMANDS_ATTENTION] &&
		    oatoms[i] != ewmh[_CWM_WM_STATE_FREEZE])
			atoms[j++] = oatoms[i];
	}
	free(oatoms);
	if (cc->flags & CLIENT_STICKY)
		atoms[j++] = ewmh[_NET_WM_STATE_STICKY];
	if (cc->flags & CLIENT_HIDDEN)
		atoms[j++] = ewmh[_NET_WM_STATE_HIDDEN];
	if (cc->flags & CLIENT_FULLSCREEN)
		atoms[j++] = ewmh[_NET_WM_STATE_FULLSCREEN];
	else {
		if (cc->flags & CLIENT_VMAXIMIZED)
			atoms[j++] = ewmh[_NET_WM_STATE_MAXIMIZED_VERT];
		if (cc->flags & CLIENT_HMAXIMIZED)
			atoms[j++] = ewmh[_NET_WM_STATE_MAXIMIZED_HORZ];
	}
	if (cc->flags & CLIENT_URGENCY)
		atoms[j++] = ewmh[_NET_WM_STATE_DEMANDS_ATTENTION];
	if (cc->flags & CLIENT_FREEZE)
		atoms[j++] = ewmh[_CWM_WM_STATE_FREEZE];
	if (j > 0)
		XChangeProperty(X_Dpy, cc->win, ewmh[_NET_WM_STATE],
		    XA_ATOM, 32, PropModeReplace, (unsigned char *)atoms, j);
	else
		XDeleteProperty(X_Dpy, cc->win, ewmh[_NET_WM_STATE]);
	free(atoms);
}

void
xu_xorcolor(XftColor a, XftColor b, XftColor *r)
{
	r->pixel = a.pixel ^ b.pixel;
	r->color.red = a.color.red ^ b.color.red;
	r->color.green = a.color.green ^ b.color.green;
	r->color.blue = a.color.blue ^ b.color.blue;
	r->color.alpha = 0xffff;
}
@


1.107
log
@Turn CALMWM_NGROUPS define into variable, ngroups.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.106 2016/09/30 18:28:06 okan Exp $
d118 2
a119 2
	    cwmh[UTF8_STRING], 8, PropModeReplace, (unsigned char *)WMNAME,
	    strlen(WMNAME));
@


1.106
log
@Use instinsic X11 functions for key/btn/ptr grab/ungrab/regrab requests;
the one line wrappers provided no value and limited altering calls where
needed; additionally, most of them had but one caller.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.105 2016/09/28 17:06:33 okan Exp $
d134 2
a135 2
	long	 workareas[CALMWM_NGROUPS][4];
	int	 i;
d137 6
a142 5
	for (i = 0; i < CALMWM_NGROUPS; i++) {
		workareas[i][0] = sc->work.x;
		workareas[i][1] = sc->work.y;
		workareas[i][2] = sc->work.w;
		workareas[i][3] = sc->work.h;
a143 1

d145 3
a147 2
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)workareas,
	    CALMWM_NGROUPS * 4);
d227 1
a227 1
	long	 ndesks = CALMWM_NGROUPS;
@


1.105
log
@Inline Xft draw and extents wrappers; too much abstraction.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.104 2016/09/16 14:32:02 okan Exp $
a32 62

static unsigned int ign_mods[] = { 0, LockMask, Mod2Mask, Mod2Mask | LockMask };

void
xu_btn_grab(Window win, int mask, unsigned int btn)
{
	unsigned int	i;

	for (i = 0; i < nitems(ign_mods); i++)
		XGrabButton(X_Dpy, btn, (mask | ign_mods[i]), win,
		    False, BUTTONMASK, GrabModeAsync,
		    GrabModeSync, None, None);
}

void
xu_btn_ungrab(Window win)
{
	XUngrabButton(X_Dpy, AnyButton, AnyModifier, win);
}

void
xu_key_grab(Window win, unsigned int mask, KeySym keysym)
{
	KeyCode		 code;
	unsigned int	 i;

	code = XKeysymToKeycode(X_Dpy, keysym);
	if ((XkbKeycodeToKeysym(X_Dpy, code, 0, 0) != keysym) &&
	    (XkbKeycodeToKeysym(X_Dpy, code, 0, 1) == keysym))
		mask |= ShiftMask;

	for (i = 0; i < nitems(ign_mods); i++)
		XGrabKey(X_Dpy, code, (mask | ign_mods[i]), win,
		    True, GrabModeAsync, GrabModeAsync);
}

void
xu_key_ungrab(Window win)
{
	XUngrabKey(X_Dpy, AnyKey, AnyModifier, win);
}

int
xu_ptr_grab(Window win, unsigned int mask, Cursor curs)
{
	return(XGrabPointer(X_Dpy, win, False, mask,
	    GrabModeAsync, GrabModeAsync,
	    None, curs, CurrentTime) == GrabSuccess ? 0 : -1);
}

int
xu_ptr_regrab(unsigned int mask, Cursor curs)
{
	return(XChangeActivePointerGrab(X_Dpy, mask,
	    curs, CurrentTime) == GrabSuccess ? 0 : -1);
}

void
xu_ptr_ungrab(void)
{
	XUngrabPointer(X_Dpy, CurrentTime);
}
@


1.104
log
@During init, query screen for _NET_ACTIVE_WINDOW and set that client as
active; while we already look at what's under the pointer, use this
information first, then look under the pointer (saving that round-trip).
This restores the active state to a client after restart even if the
pointer is not above it (and of course the pointer is not above another
client).
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.103 2015/08/27 18:53:15 okan Exp $
a532 18
}

int
xu_xft_width(XftFont *xftfont, const char *text, int len)
{
	XGlyphInfo	 extents;

	XftTextExtentsUtf8(X_Dpy, xftfont, (const FcChar8*)text,
	    len, &extents);

	return(extents.xOff);
}

void
xu_xft_draw(struct screen_ctx *sc, const char *text, int color, int x, int y)
{
	XftDrawStringUtf8(sc->xftdraw, &sc->xftcolor[color], sc->xftfont,
	    x, y, (const FcChar8*)text, strlen(text));
@


1.103
log
@Mechanical change: group->gc
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.102 2015/08/24 15:42:57 okan Exp $
d257 16
@


1.102
log
@Implement _NET_CLIENT_LIST_STACKING (from Thomas Admin), but
bottom-to-top order, as per spec (notified Thomas as well).
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.101 2015/08/24 14:56:10 okan Exp $
d365 2
a366 2
	if (cc->group)
		num = cc->group->num;
@


1.101
log
@Sort _NET_WM_STATE Atoms like the spec.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.100 2015/08/21 16:30:02 okan Exp $
d227 21
@


1.100
log
@Add client freeze extension to _NET_WM_STATE Atom, allowing flag to
persist. As usual with new Atoms, requires X restart.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.99 2015/03/28 23:12:47 okan Exp $
a376 3
		{ _CWM_WM_STATE_FREEZE,
			CLIENT_FREEZE,
			client_toggle_freeze },
d395 3
a426 2
		if (atoms[i] == ewmh[_CWM_WM_STATE_FREEZE])
			client_toggle_freeze(cc);
d429 2
a432 2
		if (atoms[i] == ewmh[_NET_WM_STATE_MAXIMIZED_VERT])
			client_toggle_vmaximize(cc);
d439 2
d454 2
a455 2
		if (oatoms[i] != ewmh[_CWM_WM_STATE_FREEZE] &&
		    oatoms[i] != ewmh[_NET_WM_STATE_STICKY] &&
a456 1
		    oatoms[i] != ewmh[_NET_WM_STATE_MAXIMIZED_VERT] &&
d459 2
a460 1
		    oatoms[i] != ewmh[_NET_WM_STATE_DEMANDS_ATTENTION])
a463 2
	if (cc->flags & CLIENT_FREEZE)
		atoms[j++] = ewmh[_CWM_WM_STATE_FREEZE];
d471 2
a474 2
		if (cc->flags & CLIENT_VMAXIMIZED)
			atoms[j++] = ewmh[_NET_WM_STATE_MAXIMIZED_VERT];
d478 2
@


1.99
log
@Introduce a xreallocarray and convert a few xcalloc instances that do
not require zero'ing.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.98 2015/03/28 21:55:48 okan Exp $
d377 3
d427 2
d454 2
a455 1
		if (oatoms[i] != ewmh[_NET_WM_STATE_STICKY] &&
d464 2
@


1.98
log
@plug a leak
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.97 2015/01/19 14:54:16 okan Exp $
d223 1
a223 1
	winlist = xcalloc(i, sizeof(*winlist));
d323 1
a323 1
	q = p = xcalloc(len, sizeof(*p));
d360 1
a360 1
	state = xcalloc(*n, sizeof(Atom));
d447 1
a447 1
	atoms = xcalloc((n + _NET_WM_STATES_NITEMS), sizeof(Atom));
@


1.97
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.96 2014/09/23 14:25:08 okan Exp $
d335 1
@


1.96
log
@Update _NET_CURRENT_DESKTOP with the screen's group_active->num.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.95 2014/09/17 18:41:44 okan Exp $
d21 1
a21 1
#include <sys/param.h>
d26 1
@


1.95
log
@these client actions are just toggles; less confusing with better names
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.94 2014/09/17 16:00:44 okan Exp $
d277 1
a277 1
xu_ewmh_net_current_desktop(struct screen_ctx *sc, long idx)
d279 2
d282 1
a282 1
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&idx, 1);
@


1.94
log
@Implement EWMH _NET_WM_STATE_HIDDEN.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.93 2014/09/15 13:00:49 okan Exp $
d375 1
a375 1
			client_sticky },
d378 1
a378 1
			client_vmaximize },
d381 1
a381 1
			client_hmaximize },
d384 1
a384 1
			client_hidden },
d387 1
a387 1
			client_fullscreen },
d421 1
a421 1
			client_sticky(cc);
d423 1
a423 1
			client_hmaximize(cc);
d425 1
a425 1
			client_vmaximize(cc);
d427 1
a427 1
			client_hidden(cc);
d429 1
a429 1
			client_fullscreen(cc);
@


1.93
log
@use similiar style for client flags
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.92 2014/09/08 20:11:22 okan Exp $
d382 3
d426 2
d445 2
a446 1
		if (oatoms[i] != ewmh[_NET_WM_STATE_MAXIMIZED_HORZ] &&
d448 1
a449 1
		    oatoms[i] != ewmh[_NET_WM_STATE_STICKY] &&
d456 2
@


1.92
log
@Remove duplicate client queue (mruq); instead, remove and take the
global Clientq and place it inside screen_ctx since every client belongs
to a screen, then use the same per screen clientq to track stacking
order (the sole reason for mruq).
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.91 2014/09/07 19:27:30 okan Exp $
d396 1
a396 1
			if ((cc->flags & handlers[i].property) == 0)
@


1.91
log
@more style nits
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.90 2014/09/06 16:08:58 okan Exp $
d217 1
a217 1
	TAILQ_FOREACH(cc, &Clientq, entry)
d223 1
a223 1
	TAILQ_FOREACH(cc, &Clientq, entry)
@


1.90
log
@Rework group names: stash the group name inside the group_ctx as opposed
to having to manage an array outside in screen_ctx for group names and
shortcuts.  Simplifies (and moves bits for) reading, and constructing
data for, EWMH's _NET_DESKTOP_NAMES.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.89 2014/08/25 14:31:22 okan Exp $
d77 1
a77 1
	return (XGrabPointer(X_Dpy, win, False, mask,
d85 1
a85 1
	return (XChangeActivePointerGrab(X_Dpy, mask,
d120 1
a120 1
		return (-1);
d125 1
a125 1
	return (n);
d138 1
a138 1
		return (0);
d157 1
a157 1
	return (nitems);
d354 1
a354 1
		return (NULL);
d360 1
a360 1
	return (state);
d486 1
a486 1
	return (extents.xOff);
@


1.89
log
@Since the flatting out of sc->group_names is only for setting
NET_DESKTOP_NAMES, merge the helper into xu_ewmh_net_desktop_names,
where we actually set the property.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.88 2014/08/25 12:49:19 okan Exp $
d286 31
a316 3
	char		*p, *q;
	size_t		 len = 0, tlen, slen;
	int		 i;
d318 2
a319 2
	for (i = 0; i < sc->group_nonames; i++)
		len += strlen(sc->group_names[i]) + 1;
d323 3
a325 3
	for (i = 0; i < sc->group_nonames; i++) {
		slen = strlen(sc->group_names[i]) + 1;
		(void)strlcpy(q, sc->group_names[i], tlen);
@


1.88
log
@Implement _NET_WM_STATE_STICKY, bound to CM-s by default; allows any
client to 'stick' to all desktops (ewmh speak) or groups - this
currently has the same affect as setting a client's group to 'nogroup',
with the exception that the client can also be in a group, so when
un-sticking, the client will go back to its original group/desktop.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.87 2014/08/22 19:04:00 okan Exp $
d284 1
a284 1
xu_ewmh_net_desktop_names(struct screen_ctx *sc, char *data, int n)
d286 16
d303 1
a303 1
	    cwmh[UTF8_STRING], 8, PropModeReplace, (unsigned char *)data, n);
@


1.87
log
@Fix nogroup regression, where nogroup became an actual group - the
symantics between cwm groups and ewmh got in the way.  Ensure a client
that wants to be in nogroup stays in nogroup (thus stays in view), even
when (re)reading NET_WM_DESKTOP.  Paritially reverts patchset 644
(2014-02-07 13:09 PST) which deals with a NULL cc->group.  All to be
revisited when NET_WM_STATE_STICKY hits cwm.

Reported by many; testing and ok phessler.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.86 2014/08/20 15:15:29 okan Exp $
d329 3
d373 2
d399 1
d404 2
@


1.86
log
@Purely mechanical; unify 'num', 'no' and 'shortcut'.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.85 2014/02/27 00:52:57 okan Exp $
d294 4
a297 1
	long	 num = cc->group->num;
@


1.85
log
@Alignment fix; found the hard way on sparc64 by landry@@ (and thanks too
for fast access to a box!)

ok deraadt@@, matthieu@@
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.84 2014/02/07 21:59:56 okan Exp $
d294 1
a294 1
	long	 no = cc->group->shortcut;
d297 1
a297 1
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&no, 1);
@


1.84
log
@all mapped clients now should have a group, so simplify some cases
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.83 2014/01/03 15:29:06 okan Exp $
d294 1
a294 1
	int	 no = cc->group->shortcut;
@


1.83
log
@use consistent types
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.82 2013/12/17 16:10:43 okan Exp $
d294 1
a294 5
	struct group_ctx	*gc = cc->group;
	long			 no = 0xffffffff;

	if (gc)
		no = gc->shortcut;
@


1.82
log
@replace with memset
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.81 2013/12/16 19:02:17 okan Exp $
d36 1
a36 1
xu_btn_grab(Window win, int mask, u_int btn)
d38 1
a38 1
	u_int	i;
d53 1
a53 1
xu_key_grab(Window win, u_int mask, KeySym keysym)
d55 2
a56 2
	KeyCode	 code;
	u_int	 i;
d75 1
a75 1
xu_ptr_grab(Window win, u_int mask, Cursor curs)
d83 1
a83 1
xu_ptr_regrab(u_int mask, Cursor curs)
d98 3
a100 3
	Window	 w0, w1;
	int	 tmp0, tmp1;
	u_int	 tmp2;
d114 3
a116 3
	Atom	 realtype;
	u_long	 n, extra;
	int	 format;
d324 1
a324 1
	u_int i;
@


1.81
log
@Implement support for EWMH's _NET_WM_STATE_FULLSCREEN hint.

Since we already have a form of 'maximize', we need to differentiate
between 'maximize' and the new 'fullscreen' mode.  The 'maximize' mode
will continue to honor gap but now *retains* the border, matching the
'vert/horz maximize' behaviour.  The new 'fullscreen' mode supports and
follows the _NET_WM_STATE_FULLSCREEN hint, allowing the client perform
additional window modifications; in this mode, cwm(1) will *ignore* gap,
remove borders and freeze(move/resize) the client.  Additionally,
'fullscreen' mode will remember various combinations of previous states.

* default keybinding changes: CM-f 'fullscreen', CM-m 'maximize' (re-map
  as desired).

Positive feedback from a few, testing and ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.80 2013/12/13 14:40:52 okan Exp $
d314 1
a314 1
	memcpy(state, p, *n * sizeof(Atom));
@


1.80
log
@Add support for XUrgency and matching _NET_WM_STATE_DEMANDS_ATTENTION
ewmh hint; urgencyborder is configurable.  The urgency flag will stick,
even while on a client in a non-viewable group, until the client
receives focus (where the border is reset).  Initial diff from Thomas
Adam with some changes/enhancements from me.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.79 2013/12/11 14:16:10 okan Exp $
d336 3
d375 2
d394 1
d399 8
a406 4
	if (cc->flags & CLIENT_HMAXIMIZED)
		atoms[j++] = ewmh[_NET_WM_STATE_MAXIMIZED_HORZ];
	if (cc->flags & CLIENT_VMAXIMIZED)
		atoms[j++] = ewmh[_NET_WM_STATE_MAXIMIZED_VERT];
@


1.79
log
@Remove extra work and simplify client state handling.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.78 2013/10/20 02:00:02 okan Exp $
d336 3
d372 2
d388 2
a389 1
		    oatoms[i] != ewmh[_NET_WM_STATE_MAXIMIZED_VERT])
d397 2
@


1.78
log
@shuffle
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.77 2013/10/20 01:55:32 okan Exp $
a157 27
}

int
xu_get_wm_state(Window win, int *state)
{
	long	*p = NULL;

	if (xu_getprop(win, cwmh[WM_STATE], cwmh[WM_STATE], 2L,
	    (unsigned char **)&p) <= 0)
		return (-1);

	*state = (int)*p;
	XFree((char *)p);

	return (0);
}

void
xu_set_wm_state(Window win, int state)
{
	long	 dat[2];

	dat[0] = state;
	dat[1] = None;

	XChangeProperty(X_Dpy, win, cwmh[WM_STATE], cwmh[WM_STATE], 32,
	    PropModeReplace, (unsigned char *)dat, 2);
@


1.77
log
@wrap key ungrab like btn ungrab, for it'll be used again
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.76 2013/10/19 19:39:34 okan Exp $
a34 21
int
xu_ptr_grab(Window win, u_int mask, Cursor curs)
{
	return (XGrabPointer(X_Dpy, win, False, mask,
	    GrabModeAsync, GrabModeAsync,
	    None, curs, CurrentTime) == GrabSuccess ? 0 : -1);
}

int
xu_ptr_regrab(u_int mask, Cursor curs)
{
	return (XChangeActivePointerGrab(X_Dpy, mask,
	    curs, CurrentTime) == GrabSuccess ? 0 : -1);
}

void
xu_ptr_ungrab(void)
{
	XUngrabPointer(X_Dpy, CurrentTime);
}

a52 16
xu_ptr_getpos(Window win, int *x, int *y)
{
	Window	 w0, w1;
	int	 tmp0, tmp1;
	u_int	 tmp2;

	XQueryPointer(X_Dpy, win, &w0, &w1, &tmp0, &tmp1, x, y, &tmp2);
}

void
xu_ptr_setpos(Window win, int x, int y)
{
	XWarpPointer(X_Dpy, None, win, 0, 0, 0, 0, x, y);
}

void
d72 37
@


1.76
log
@Using xu_btn_ungrab() buttons during client_leave doesn't work (error
BadValue) when the modifier is already AnyModifier .  Instead alter
xu_btn_ungrab() to ungrab AnyButton/AnyModifier and call it only when a
client is coming into focus in client_setactive(), instead of iterating
over ignore mods - matches how we handle key grabs.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.75 2013/10/03 13:52:00 okan Exp $
d103 6
@


1.75
log
@unify type; no change
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.74 2013/07/16 14:30:48 okan Exp $
d68 1
a68 1
xu_btn_ungrab(Window win, int mask, u_int btn)
d70 1
a70 4
	u_int	i;

	for (i = 0; i < nitems(ign_mods); i++)
		XUngrabButton(X_Dpy, btn, (mask | ign_mods[i]), win);
@


1.74
log
@we no longer need to construct an array for _NET_SUPPORTED.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.73 2013/07/15 23:51:59 okan Exp $
d109 1
a109 1
xu_getprop(Window win, Atom atm, Atom type, long len, u_char **p)
d163 1
a163 1
	    (u_char **)&p) <= 0)
d334 1
a334 1
	    (u_char **)&p)) <= 0)
@


1.73
log
@collapse lines
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.72 2013/07/15 14:50:44 okan Exp $
a187 6
	Atom	 atom[EWMH_NITEMS];
	u_int	 i;

	for (i = 0; i < nitems(ewmh); i++)
		atom[i] = ewmh[i];

d189 1
a189 1
	    XA_ATOM, 32, PropModeReplace, (unsigned char *)atom, EWMH_NITEMS);
@


1.72
log
@simplify atom handling; allows us to limit to one round-trip to server
for gathering Atoms.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.71 2013/07/10 14:11:42 okan Exp $
d180 1
a180 2
	XChangeProperty(X_Dpy, win,
	    cwmh[WM_STATE], cwmh[WM_STATE], 32,
@


1.71
log
@type fixes
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.70 2013/07/08 15:48:16 okan Exp $
d162 1
a162 1
	if (xu_getprop(win, cwmh[WM_STATE].atom, cwmh[WM_STATE].atom, 2L,
d181 1
a181 1
	    cwmh[WM_STATE].atom, cwmh[WM_STATE].atom, 32,
a184 41
struct atom_ctx cwmh[CWMH_NITEMS] = {
	{"WM_STATE",			None},
	{"WM_DELETE_WINDOW",		None},
	{"WM_TAKE_FOCUS",		None},
	{"WM_PROTOCOLS",		None},
	{"_MOTIF_WM_HINTS",		None},
	{"UTF8_STRING",			None},
	{"WM_CHANGE_STATE",		None},
};
struct atom_ctx ewmh[EWMH_NITEMS] = {
	{"_NET_SUPPORTED",		None},
	{"_NET_SUPPORTING_WM_CHECK",	None},
	{"_NET_ACTIVE_WINDOW",		None},
	{"_NET_CLIENT_LIST",		None},
	{"_NET_NUMBER_OF_DESKTOPS",	None},
	{"_NET_CURRENT_DESKTOP",	None},
	{"_NET_DESKTOP_VIEWPORT",	None},
	{"_NET_DESKTOP_GEOMETRY",	None},
	{"_NET_VIRTUAL_ROOTS",		None},
	{"_NET_SHOWING_DESKTOP",	None},
	{"_NET_DESKTOP_NAMES",		None},
	{"_NET_WORKAREA",		None},
	{"_NET_WM_NAME",		None},
	{"_NET_WM_DESKTOP",		None},
	{"_NET_CLOSE_WINDOW",		None},
	{"_NET_WM_STATE", 		None},
	{"_NET_WM_STATE_MAXIMIZED_VERT",None},
	{"_NET_WM_STATE_MAXIMIZED_HORZ",None},
};

void
xu_getatoms(void)
{
	u_int	 i;

	for (i = 0; i < nitems(cwmh); i++)
		cwmh[i].atom = XInternAtom(X_Dpy, cwmh[i].name, False);
	for (i = 0; i < nitems(ewmh); i++)
		ewmh[i].atom = XInternAtom(X_Dpy, ewmh[i].name, False);
}

d193 1
a193 1
		atom[i] = ewmh[i].atom;
d195 1
a195 1
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_SUPPORTED].atom,
d205 1
a205 1
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_SUPPORTING_WM_CHECK].atom,
d207 1
a207 1
	XChangeProperty(X_Dpy, w, ewmh[_NET_SUPPORTING_WM_CHECK].atom,
d209 2
a210 2
	XChangeProperty(X_Dpy, w, ewmh[_NET_WM_NAME].atom,
	    cwmh[UTF8_STRING].atom, 8, PropModeReplace, (unsigned char *)WMNAME,
d219 1
a219 1
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_DESKTOP_GEOMETRY].atom,
d236 1
a236 1
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_WORKAREA].atom,
d256 1
a256 1
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_CLIENT_LIST].atom,
d264 1
a264 1
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_ACTIVE_WINDOW].atom,
d274 1
a274 1
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_DESKTOP_VIEWPORT].atom,
d283 1
a283 1
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_NUMBER_OF_DESKTOPS].atom,
d296 1
a296 1
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_SHOWING_DESKTOP].atom,
d304 1
a304 1
	XDeleteProperty(X_Dpy, sc->rootwin, ewmh[_NET_VIRTUAL_ROOTS].atom);
d310 1
a310 1
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_CURRENT_DESKTOP].atom,
d317 2
a318 2
	XChangeProperty(X_Dpy, sc->rootwin, ewmh[_NET_DESKTOP_NAMES].atom,
	    cwmh[UTF8_STRING].atom, 8, PropModeReplace, (unsigned char *)data, n);
d331 1
a331 1
	XChangeProperty(X_Dpy, cc->win, ewmh[_NET_WM_DESKTOP].atom,
d340 1
a340 1
	if ((*n = xu_getprop(cc->win, ewmh[_NET_WM_STATE].atom, XA_ATOM, 64L,
d370 2
a371 2
		if (first != ewmh[handlers[i].atom].atom &&
		    second != ewmh[handlers[i].atom].atom)
d396 1
a396 1
		if (atoms[i] == ewmh[_NET_WM_STATE_MAXIMIZED_HORZ].atom)
d398 1
a398 1
		if (atoms[i] == ewmh[_NET_WM_STATE_MAXIMIZED_VERT].atom)
d413 2
a414 2
		if (oatoms[i] != ewmh[_NET_WM_STATE_MAXIMIZED_HORZ].atom &&
		    oatoms[i] != ewmh[_NET_WM_STATE_MAXIMIZED_VERT].atom)
d419 1
a419 1
		atoms[j++] = ewmh[_NET_WM_STATE_MAXIMIZED_HORZ].atom;
d421 1
a421 1
		atoms[j++] = ewmh[_NET_WM_STATE_MAXIMIZED_VERT].atom;
d423 1
a423 1
		XChangeProperty(X_Dpy, cc->win, ewmh[_NET_WM_STATE].atom,
d426 1
a426 1
		XDeleteProperty(X_Dpy, cc->win, ewmh[_NET_WM_STATE].atom);
@


1.70
log
@replace a few (x)malloc with (x)calloc to prevent potential integer
overflows; from Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.69 2013/06/10 21:37:30 okan Exp $
d396 1
a396 1
	int i;
@


1.69
log
@move synthetic responses and have client_msg only work with WM_PROTOCOLS,
since that's all ClientMessageEvent is for anyway.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.68 2013/05/27 23:20:45 okan Exp $
d294 1
a294 1
	winlist = xmalloc(i * sizeof(*winlist));
d385 1
a385 1
	state = xmalloc(*n * sizeof(Atom));
d452 1
a452 1
	atoms = xmalloc((n + _NET_WM_STATES_NITEMS) * sizeof(Atom));
@


1.68
log
@fix type in a ClientMessage (xu_sendmsg).
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.67 2013/05/23 16:52:39 okan Exp $
a105 35
}

void
xu_configure(struct client_ctx *cc)
{
	XConfigureEvent	 ce;

	ce.type = ConfigureNotify;
	ce.event = cc->win;
	ce.window = cc->win;
	ce.x = cc->geom.x;
	ce.y = cc->geom.y;
	ce.width = cc->geom.w;
	ce.height = cc->geom.h;
	ce.border_width = cc->bwidth;
	ce.above = None;
	ce.override_redirect = 0;

	XSendEvent(X_Dpy, cc->win, False, StructureNotifyMask, (XEvent *)&ce);
}

void
xu_sendmsg(Window win, Atom type, Atom atm)
{
	XClientMessageEvent	 e;

	bzero(&e, sizeof(e));
	e.type = ClientMessage;
	e.window = win;
	e.message_type = type;
	e.format = 32;
	e.data.l[0] = atm;
	e.data.l[1] = CurrentTime;

	XSendEvent(X_Dpy, win, False, 0L, (XEvent *)&e);
@


1.67
log
@alter conf_grab(_kbd) to first ungrab AnyKey/AnyModifier, then proceed
to grab keys in keybindingq.  we don't need to ungrab/grab on every
addition to the queue, just once with a complete keybindingq; simplify
grabbing keys per screen (during init) and during a MappingNotify.

while here, change conf_grab_{kbd,mouse} to require only a Window.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.66 2013/05/21 00:29:20 okan Exp $
d128 1
a128 1
xu_sendmsg(Window win, Atom atm, long val)
d130 1
a130 1
	XEvent	 e;
d132 7
a138 7
	(void)memset(&e, 0, sizeof(e));
	e.xclient.type = ClientMessage;
	e.xclient.window = win;
	e.xclient.message_type = atm;
	e.xclient.format = 32;
	e.xclient.data.l[0] = val;
	e.xclient.data.l[1] = CurrentTime;
d140 1
a140 1
	XSendEvent(X_Dpy, win, False, 0, &e);
@


1.66
log
@handle _NET_WM_STATE ClientMessage; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.65 2013/05/20 21:13:58 okan Exp $
a105 15
}

void
xu_key_ungrab(Window win, u_int mask, KeySym keysym)
{
	KeyCode	 code;
	u_int	 i;

	code = XKeysymToKeycode(X_Dpy, keysym);
	if ((XkbKeycodeToKeysym(X_Dpy, code, 0, 0) != keysym) &&
	    (XkbKeycodeToKeysym(X_Dpy, code, 0, 1) == keysym))
		mask |= ShiftMask;

	for (i = 0; i < nitems(ign_mods); i++)
		XUngrabKey(X_Dpy, code, (mask | ign_mods[i]), win);
@


1.65
log
@add support for _NET_WM_STATE_MAXIMIZED_{HORZ,VERT}; from Alexander Polakov.

while I'm unsure of the final look of _NET_WM_STATE, there's no reason
to delay this support.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.64 2013/05/20 20:21:04 okan Exp $
d440 37
@


1.64
log
@- configure menuwin with the screen, then create the xft drawable using
  the menu window since that's the only place on which we draw
- elminate the need to change the drawable on every font draw
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.63 2013/05/19 23:38:21 okan Exp $
d260 3
d424 58
@


1.63
log
@move the 2 small font helper functions to xutil.c
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.62 2013/05/19 23:09:59 okan Exp $
d445 1
a445 2
xu_xft_draw(struct screen_ctx *sc, const char *text,
    Drawable d, int color, int x, int y)
a446 1
	XftDrawChange(sc->xftdraw, d);
@


1.62
log
@- switch border colors to Xft
- merge border/menu color structures/functions since they now both use Xft
- switch xu_xorcolor to operating on XftColor instead of just
  XRenderColor (basically adding pixel)
- if color name allocation fails, revert back to default (this, along
  with font validation should occur during config parse, but we don't
  have screens setup yet - likely to change at some point)
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.61 2013/05/19 17:05:52 okan Exp $
d431 20
@


1.61
log
@add support for _NET_CLOSE_WINDOW
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.60 2013/05/19 17:03:55 okan Exp $
a422 13
unsigned long
xu_getcolor(struct screen_ctx *sc, char *name)
{
	XColor	 color, tmp;

	if (!XAllocNamedColor(X_Dpy, sc->colormap, name, &color, &tmp)) {
		warnx("XAllocNamedColor error: '%s'", name);
		return (0);
	}

	return (color.pixel);
}

d424 1
a424 1
xu_xorcolor(XRenderColor a, XRenderColor b, XRenderColor *r)
d426 5
a430 4
	r->red = a.red ^ b.red;
	r->green = a.green ^ b.green;
	r->blue = a.blue ^ b.blue;
	r->alpha = 0xffff;
@


1.60
log
@treat WM_CHANGE_STATE like other atoms
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.59 2013/05/10 16:32:48 okan Exp $
d259 1
@


1.59
log
@more type fixes for mask/button
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.58 2013/05/10 16:05:34 okan Exp $
d242 1
@


1.58
log
@int type fixes
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.57 2013/05/10 15:44:43 okan Exp $
d36 1
a36 1
xu_ptr_grab(Window win, int mask, Cursor curs)
d44 1
a44 1
xu_ptr_regrab(int mask, Cursor curs)
d93 1
a93 1
xu_key_grab(Window win, int mask, KeySym keysym)
d109 1
a109 1
xu_key_ungrab(Window win, int mask, KeySym keysym)
@


1.57
log
@fix KeySym type
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.56 2013/04/17 13:57:06 okan Exp $
d59 2
a60 1
	int	i;
d70 2
a71 1
	int	i;
d96 1
a96 1
	int	 i;
d112 1
a112 1
	int	 i;
d263 1
a263 1
	int	 i;
d276 1
a276 1
	int	 i;
@


1.56
log
@mechanical xu_{get,set}state -> xu_{get,set}_wm_state change
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.55 2013/04/17 13:52:20 okan Exp $
d91 1
a91 1
xu_key_grab(Window win, int mask, int keysym)
d107 1
a107 1
xu_key_ungrab(Window win, int mask, int keysym)
@


1.55
log
@slightly rework WM_STATE set/get to make it less ambigious; will be more clear
on what needs to change to make it right in the end.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.54 2013/04/14 16:13:17 okan Exp $
d206 1
a206 1
xu_getstate(Window win, int *state)
d221 1
a221 1
xu_setstate(Window win, int state)
@


1.54
log
@only a window is required to set WM_STATE.  also un-confuse xu_ptr_getpos
by using 'win' instead of 'rootwin' so as not to imply only the root
window is queried, rather any window.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.53 2013/04/10 19:08:09 okan Exp $
d221 1
a221 1
xu_setstate(struct client_ctx *cc, int state)
d228 1
a228 2
	cc->state = state;
	XChangeProperty(X_Dpy, cc->win,
@


1.53
log
@_NET_WM_NAME is UTF8_STRING type
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.52 2013/01/01 14:19:56 okan Exp $
d75 1
a75 1
xu_ptr_getpos(Window rootwin, int *x, int *y)
d81 1
a81 1
	XQueryPointer(X_Dpy, rootwin, &w0, &w1, &tmp0, &tmp1, x, y, &tmp2);
d206 1
a206 1
xu_getstate(struct client_ctx *cc, int *state)
d210 1
a210 1
	if (xu_getprop(cc->win, cwmh[WM_STATE].atom, cwmh[WM_STATE].atom, 2L,
@


1.52
log
@make num of groups no longer off-by-one; from Alexander Polakov

note that a re-exec of cwm will not rewrite the group number atom of
*existing* clients, so they will remain off-by-one until each client has
its atom updated, or of course a restart of X.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.51 2012/12/17 18:34:06 okan Exp $
d295 1
a295 1
	    XA_WM_NAME, 8, PropModeReplace, (unsigned char *)WMNAME,
@


1.51
log
@stash the default screen visual and colormap in screen_ctx
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.50 2012/12/17 02:28:45 okan Exp $
d414 1
a414 1
		no = gc->shortcut - 1;
@


1.50
log
@non-trivial menu drawing rewrite, moving to Xft and solving various
font/color drawing issues; from Alexander Polakov
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.49 2012/11/09 03:52:02 okan Exp $
d425 1
a425 2
	if (!XAllocNamedColor(X_Dpy, DefaultColormap(X_Dpy, sc->which),
	    name, &color, &tmp)) {
@


1.49
log
@sort
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.48 2012/11/08 20:18:19 okan Exp $
d432 9
@


1.48
log
@fix some warnings; inspired by a diff from Thordur Bjornsson.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.47 2012/11/07 20:34:39 okan Exp $
d26 1
a28 1
#include <stdio.h>
@


1.47
log
@get rid of the xfree() wrapper around free(); from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.46 2012/10/31 19:30:19 okan Exp $
d191 1
a191 1
				*text = xstrdup(prop2.value);
d295 2
a296 1
	    XA_WM_NAME, 8, PropModeReplace, WMNAME, strlen(WMNAME));
d400 1
a400 1
xu_ewmh_net_desktop_names(struct screen_ctx *sc, unsigned char *data, int n)
d403 1
a403 1
	    cwmh[UTF8_STRING].atom, 8, PropModeReplace, data, n);
@


1.46
log
@replace 'reload' with 'restart', which merely re-exec's cwm using the
existing argv; same idea with respect to argv saving as Alexander
Polakov.  reload support was half-complete and is getting in the way.

agreed to by many
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.45 2012/07/13 17:01:05 okan Exp $
d342 1
a342 1
	xfree(winlist);
@


1.45
log
@re-use geom struct in client_ctx (saved)geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.44 2012/07/13 15:21:35 okan Exp $
a430 6
}

void
xu_freecolor(struct screen_ctx *sc, unsigned long pixel)
{
	XFreeColors(X_Dpy, DefaultColormap(X_Dpy, sc->which), &pixel, 1, 0L);
@


1.44
log
@convert xmax/ymax uses to view geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.43 2012/07/08 02:55:01 okan Exp $
d131 2
a132 2
	ce.width = cc->geom.width;
	ce.height = cc->geom.height;
@


1.43
log
@fix atom for setting WM_STATE.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.42 2012/07/08 02:50:41 okan Exp $
d301 1
a301 1
	long	 geom[2] = { sc->xmax, sc->ymax };
d314 4
a317 4
		workareas[i][0] = sc->gap.left;
		workareas[i][1] = sc->gap.top;
		workareas[i][2] = sc->xmax - (sc->gap.left + sc->gap.right);
		workareas[i][3] = sc->ymax - (sc->gap.top + sc->gap.bottom);
@


1.42
log
@fix atom for retrieving WM_STATE between re-exec's.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.41 2012/07/03 13:49:03 okan Exp $
d230 1
a230 1
	    cwmh[WM_STATE].atom, WM_STATE, 32,
@


1.41
log
@re-implement atom handing; makes for a normalized and more consistent
separation between cwm and ewmh.  seen by a few.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.40 2012/05/16 01:17:14 okan Exp $
d210 1
a210 1
	if (xu_getprop(cc->win, cwmh[WM_STATE].atom, WM_STATE, 2L,
@


1.40
log
@instead of using the menu window for _NET_SUPPORTING_WM_CHECK, create a
dummy one to use instead; allows us to not have to wait for menu_init(),
so re-shuffle _NET_SUPPORTED slightly.

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.39 2012/05/16 01:04:36 okan Exp $
d210 2
a211 1
	if (xu_getprop(cc->win, WM_STATE, WM_STATE, 2L, (u_char **)&p) <= 0)
d229 2
a230 1
	XChangeProperty(X_Dpy, cc->win, WM_STATE, WM_STATE, 32,
d234 23
a256 22
Atom		cwm_atoms[CWM_NO_ATOMS];
char 		*atoms[CWM_NO_ATOMS] = {
	"WM_STATE",
	"WM_DELETE_WINDOW",
	"WM_TAKE_FOCUS",
	"WM_PROTOCOLS",
	"_MOTIF_WM_HINTS",
	"UTF8_STRING",
	"_NET_SUPPORTED",
	"_NET_SUPPORTING_WM_CHECK",
	"_NET_WM_NAME",
	"_NET_ACTIVE_WINDOW",
	"_NET_CLIENT_LIST",
	"_NET_NUMBER_OF_DESKTOPS",
	"_NET_CURRENT_DESKTOP",
	"_NET_DESKTOP_VIEWPORT",
	"_NET_DESKTOP_GEOMETRY",
	"_NET_VIRTUAL_ROOTS",
	"_NET_SHOWING_DESKTOP",
	"_NET_DESKTOP_NAMES",
	"_NET_WM_DESKTOP",
	"_NET_WORKAREA",
d262 6
a267 1
	XInternAtoms(X_Dpy, atoms, CWM_NO_ATOMS, False, cwm_atoms);
d270 1
d274 8
a281 3
	XChangeProperty(X_Dpy, sc->rootwin, _NET_SUPPORTED, XA_ATOM, 32,
	    PropModeReplace,  (unsigned char *)&_NET_SUPPORTED,
	    CWM_NO_ATOMS - CWM_NETWM_START);
a283 7
/*
 * The netwm spec says that to prove that the hint is not stale, one
 * must provide _NET_SUPPORTING_WM_CHECK containing a window created by
 * the root window.  The property must be set on the root window and the
 * window itself.  This child window also must have _NET_WM_NAME set with
 * the window manager name.
 */
d290 3
a292 1
	XChangeProperty(X_Dpy, sc->rootwin, _NET_SUPPORTING_WM_CHECK,
d294 55
a348 1
	XChangeProperty(X_Dpy, w, _NET_SUPPORTING_WM_CHECK,
d350 67
a416 2
	XChangeProperty(X_Dpy, w, _NET_WM_NAME, UTF8_STRING,
	    8, PropModeReplace, WMNAME, strlen(WMNAME));
@


1.39
log
@convert from deprecated XKeycodeToKeysym to XkbKeycodeToKeysym

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.38 2012/05/13 15:15:54 okan Exp $
d263 1
a263 1
xu_setwmname(struct screen_ctx *sc)
a264 4
	/*
	 * set up the _NET_SUPPORTED hint with all netwm atoms that we
	 * know about.
	 */
d268 15
a282 7
	/*
	 * netwm spec says that to prove that the hint is not stale you must
	 * provide _NET_SUPPORTING_WM_CHECK containing a window (we use the
	 * menu window). The property must be set on the root window and the
	 * window itself, the window also must have _NET_WM_NAME set with the
	 * window manager name.
	 */
d284 4
a287 4
	    XA_WINDOW, 32, PropModeReplace, (unsigned char *)&sc->menuwin, 1);
	XChangeProperty(X_Dpy, sc->menuwin, _NET_SUPPORTING_WM_CHECK,
	    XA_WINDOW, 32, PropModeReplace, (unsigned char *)&sc->menuwin, 1);
	XChangeProperty(X_Dpy, sc->menuwin, _NET_WM_NAME, UTF8_STRING,
@


1.38
log
@knf, some from a diff from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.37 2011/07/25 15:10:24 okan Exp $
d97 2
a98 2
	if ((XKeycodeToKeysym(X_Dpy, code, 0) != keysym) &&
	    (XKeycodeToKeysym(X_Dpy, code, 1) == keysym))
d113 2
a114 2
	if ((XKeycodeToKeysym(X_Dpy, code, 0) != keysym) &&
	    (XKeycodeToKeysym(X_Dpy, code, 1) == keysym))
@


1.37
log
@We are inconsistent when it comes to function returns, so just go all
the way with the cwm specific parts.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.36 2011/07/23 13:09:11 okan Exp $
d295 1
a295 1
		return 0;
d298 1
a298 1
	return color.pixel;
@


1.36
log
@Clarify defines and make them not look like non-local ones; started by a
small diff from Thomas Pfaff.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.35 2011/05/11 13:53:51 okan Exp $
d145 1
a145 1
	memset(&e, 0, sizeof(e));
@


1.35
log
@tag and comment cleanup; ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: xutil.c,v 1.34 2011/03/22 10:57:31 okan Exp $
d62 1
a62 1
		    False, ButtonMask, GrabModeAsync,
@


1.34
log
@introduce nitems macro, with the appropriate ifndef.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.33 2011/03/22 10:49:46 okan Exp $
@


1.33
log
@remove XXX and move a configure event out of the event handler functions.

reminded by a similiar diff from Thomas Pfaff.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.32 2010/05/22 22:32:08 okan Exp $
d60 1
a60 1
	for (i = 0; i < sizeof(ign_mods)/sizeof(*ign_mods); i++)
d70 1
a70 1
	for (i = 0; i < sizeof(ign_mods)/sizeof(*ign_mods); i++)
d101 1
a101 1
	for (i = 0; i < sizeof(ign_mods)/sizeof(*ign_mods); i++)
d117 1
a117 1
	for (i = 0; i < sizeof(ign_mods)/sizeof(*ign_mods); i++)
@


1.32
log
@initialize nitems

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.31 2010/05/22 22:10:31 okan Exp $
d119 19
@


1.31
log
@replace XFetchName() with something more intelligent which attempts to
use the appropriate netwm Atom first, as well as deal with utf8.

slightly different incarnation tested by sthen@@ and ajacoutot@@ - thanks!

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.30 2010/04/11 16:51:26 okan Exp $
d158 1
a158 1
	int		 nitems;
@


1.30
log
@clean up a few xu_* functions to just accept what they need (Window).

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.29 2009/12/15 04:10:42 okan Exp $
d152 32
@


1.29
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.28 2009/12/15 03:24:36 okan Exp $
d122 1
a122 1
xu_sendmsg(struct client_ctx *cc, Atom atm, long val)
d128 1
a128 1
	e.xclient.window = cc->win;
d134 1
a134 1
	XSendEvent(X_Dpy, cc->win, False, 0, &e);
d138 1
a138 1
xu_getprop(struct client_ctx *cc, Atom atm, Atom type, long len, u_char **p)
d144 1
a144 1
	if (XGetWindowProperty(X_Dpy, cc->win, atm, 0L, len, False, type,
d159 1
a159 1
	if (xu_getprop(cc, WM_STATE, WM_STATE, 2L, (u_char **)&p) <= 0)
@


1.28
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.27 2009/12/14 16:39:01 oga Exp $
d20 10
@


1.27
log
@kill _CWM_GRP atom setting. The netwm stuff does us well enough now that
it's superfluous.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.26 2009/12/11 18:09:16 oga Exp $
a20 1
#include "headers.h"
@


1.26
log
@add _NET_WORKAREA. for now we ignore the gap, this'll change soonish.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.25 2009/12/11 17:55:42 oga Exp $
a178 1
	"_CWM_GRP",
@


1.25
log
@implement support for _NET_WM_DESKTOP properties on windows.

it works kinda like _CWM_GRP, which we added to aid restarts a while
ago, but it's standardised and clients are specifically allowed to set
it to request a desktop.

for noe we leave _CWM_GRP support in, but its days are now numbered.

while i'm here fixup an int/long mixup with an earlier diff.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.24 2009/12/11 17:51:42 oga Exp $
d194 1
@


1.24
log
@Implement _NET_DESKTOP_NAMES, this one was a bit tricky since thespec
says that a pager can change the property at any time (most need a
clientmessage). So deal with property updates.

Needed to shuffle some of the other code around since we can't just use
shortcut_to_name[] everywhere now.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.23 2009/12/10 23:21:26 oga Exp $
d193 1
@


1.23
log
@Implement _NET_VIRTUAL_ROOTS (just clear it, we don't use that technique)
and _NET_SHOWING_DESKTOP (we're never doing so right now).

only three informational root-window hints to go.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.22 2009/12/10 23:14:58 oga Exp $
d192 1
@


1.22
log
@Implement _NET_CURRENT_DESKTOP, _NET_DESKTOP_VIEWPORT and
_NET_DESKTOP_GEOMETRY.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.21 2009/12/07 23:19:51 oga Exp $
d190 2
@


1.21
log
@Implement _NET_NUMBER_OF_DESKTOPS, currently this is statically 9 and
unchangable. the group code needs some cleaning up before this will be a
bit less hackish.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.20 2009/12/07 22:46:15 oga Exp $
d187 3
@


1.20
log
@support _NET_CLIENT_LIST.

the x property api doesn't let you remove one entry from an X property
array, so client_remove is kinda expensive, but there's no real way
around that..

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.19 2009/12/07 22:21:59 oga Exp $
d186 1
@


1.19
log
@Implement _NET_ACTIVE_WINDOW. for now just the informational hint is
supported, the client message to change this will be supported when all
informational hints are working.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.18 2009/12/07 21:20:52 okan Exp $
d185 1
@


1.18
log
@introduce the beginnings of netwm support, minimally and correctly;
allows java to be happy, but additionally stops others from whinning
about a non-netwm complaint wm.  more to come.

written a few times; this one includes a clever hack from oga@@ to
populate _NET_SUPPORTED.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.17 2009/06/26 12:21:58 okan Exp $
d184 1
@


1.17
log
@static local functions and data; almost identical diff from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.16 2009/06/17 13:08:37 okan Exp $
d180 4
d190 25
@


1.16
log
@remove unnecessary casts; from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.15 2009/05/17 23:40:57 okan Exp $
d24 1
a24 1
unsigned int ign_mods[] = { 0, LockMask, Mod2Mask, Mod2Mask | LockMask };
@


1.15
log
@a long time coming - re-work the way we deal with colors: since we're
using Xft(3), use it to select the font color as well instead of trying
to build one; properly allocate and free colors at-will, e.g. we now
have configurable colors.

feedback and ok's todd@@ and oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.14 2009/01/27 00:42:53 oga Exp $
d164 2
a165 2
	dat[0] = (long)state;
	dat[1] = (long)None;
@


1.14
log
@One of the most annoying things to do was restart cwm and lose all of
your group state. Fix this up by using an X Atom (_CWM_GRP) to store the
name of the group that we're using (the name, not the number is because
at one point we may make the group numbers dynamic). I've been talking
about this since c2k8. so CM-w means you keep all of your windows grouped
properly.

ok okan@@, todd@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.13 2009/01/23 20:07:20 oga Exp $
d186 20
@


1.13
log
@Whitespace nit.

pointed out by okan.
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.12 2009/01/23 20:04:30 oga Exp $
d178 2
a179 1
	"_MOTIF_WM_HINTS"
@


1.12
log
@Switch to using XInternAtoms for caching the atom numbers. Saves a pile
of function calls and server roundtrips.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.11 2009/01/22 18:06:16 oga Exp $
a179 1

@


1.11
log
@Oops, missed an atom.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.10 2009/01/22 15:26:33 oga Exp $
d173 8
d185 1
a185 5
	WM_STATE = XInternAtom(X_Dpy, "WM_STATE", False);	
	WM_DELETE_WINDOW = XInternAtom(X_Dpy, "WM_DELETE_WINDOW", False);	
	WM_TAKE_FOCUS = XInternAtom(X_Dpy, "WM_TAKE_FOCUS", False);
	WM_PROTOCOLS = XInternAtom(X_Dpy, "WM_PROTOCOLS", False);
	_MOTIF_WM_HINTS = XInternAtom(X_Dpy, "_MOTIF_WM_HINTS", False);
@


1.10
log
@Cache all of the X atoms we use at startup.

Do this instead of querying for them every time we use them. This
removes an XXX that has been in there since time began. This will become
more important as we move towards supporting netwm.

ok todd@@, okan@@.
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.9 2008/07/22 20:26:12 oga Exp $
d181 1
@


1.9
log
@Add xu_key_ungrab() and a mirror to xu_key_ungrab(). a couple of changes
that are coming up depend on it.

ok okan.
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.8 2008/07/11 14:21:28 okan Exp $
a147 1
	Atom	 wm_state;
d150 1
a150 3
	wm_state = XInternAtom(X_Dpy, "WM_STATE", False);

	if (xu_getprop(cc, wm_state, wm_state, 2L, (u_char **)&p) <= 0)
a161 1
	Atom	 wm_state;
a163 3
	/* XXX cache */
	wm_state = XInternAtom(X_Dpy, "WM_STATE", False);

d168 1
a168 1
	XChangeProperty(X_Dpy, cc->win, wm_state, wm_state, 32,
d170 11
@


1.8
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.7 2008/06/17 23:40:33 oga Exp $
d93 17
a109 3
		XGrabKey(X_Dpy, XKeysymToKeycode(X_Dpy, keysym),
		    (mask | ign_mods[i]), win, True, GrabModeAsync,
		    GrabModeAsync);
@


1.7
log
@Ignore caps lock and numlock for keyboard bindings. The way Xlib makes
you do this is ugly. Also remove mod2 (numlock) and mod3 (odd) from the
list of keybinding modifiers. They don't make much sense here.

based on a heavily modified diff from Martynas.

ok okan.
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.6 2008/05/15 22:18:00 oga Exp $
d68 3
a70 3
	int tmp0, tmp1;
	u_int tmp2;
	Window w0, w1;
d84 2
a85 2
	KeyCode	code;
	int	i;
d101 1
a101 1
	XEvent e;
d117 3
a119 3
	Atom realtype;
	u_long n, extra;
	int format;
d134 4
a137 2
	Atom wm_state = XInternAtom(X_Dpy, "WM_STATE", False);
	long *p = NULL;
d151 2
a152 2
	long dat[2];
	Atom wm_state;
@


1.6
log
@KNF, no binary change.

From Pierre Riteau. Thanks!
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.5 2008/04/15 20:24:41 oga Exp $
d24 2
d47 1
a47 1
int
d50 5
a54 3
	return (XGrabButton(X_Dpy, btn, mask, win,
	    False, ButtonMask, GrabModeAsync,
	    GrabModeSync, None, None) == GrabSuccess ? 0 : -1);
d60 3
a62 1
	XUngrabButton(X_Dpy, btn, mask, win);
d84 2
a85 1
	KeyCode code;
d92 4
a95 2
	XGrabKey(X_Dpy, XKeysymToKeycode(X_Dpy, keysym), mask, win, True,
	    GrabModeAsync, GrabModeAsync);
@


1.5
log
@hit it with the knf stick.
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.4 2008/01/16 11:39:20 oga Exp $
d28 2
a29 2
		    GrabModeAsync, GrabModeAsync,
		    None, curs, CurrentTime) == GrabSuccess ? 0 : -1);
d36 1
a36 1
		curs, CurrentTime) == GrabSuccess ? 0 : -1);
d49 2
a50 2
		    False, ButtonMask, GrabModeAsync,
		    GrabModeSync, None, None) == GrabSuccess ? 0 : -1);
d113 1
a113 1
		&realtype, &format, &n, &extra, p) != Success || *p == NULL)
@


1.4
log
@huge amount of cleanup and dead code removal.

full description of changes:
-remove fontlist, and all associated structures/calls, it's not needed.
 this also removes any doubt about leftover 9wm code (the list was
 borrowed from it). Since cwm now uses Xft for everything, the legacy
 font handling is just not needed.
-add /* FALLTHROUGH */ comments into grab_{label,menu}. I actually
 didn't intend grab_menu to be a fallthrough, but it actually works quite
 well there, so remove the extra rectangle drawing. I love it when that
 happens.
-remove a couple of unused prototypes that were obviously missed
 before.
-remove a bunch of commented out or if 0ed out code. It doesn't look to
 be coming back anytime soon.
-several functions returned an int, but this was never checked. most of
 them only failed if they failed to grab the pointer (thus the internal
 state didn't change), so just make them void and return early if this is
 the case.
-remove several unused functions and some useless variables.

knocks something like 200bytes off the stripped binary size for me.

ok marc@@, tested by several others.
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.3 2008/01/11 16:06:44 oga Exp $
d48 1
a48 1
        return (XGrabButton(X_Dpy, btn, mask, win,
d66 1
a66 1
        XQueryPointer(X_Dpy, rootwin, &w0, &w1, &tmp0, &tmp1, x, y, &tmp2);
d85 1
a85 1
        XGrabKey(X_Dpy, XKeysymToKeycode(X_Dpy, keysym), mask, win, True,
@


1.3
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d18 1
a18 1
 * $Id: xutil.c,v 1.2 2007/05/28 18:34:27 jasper Exp $
a86 10
#if 0
        XGrabKey(X_Dpy, XKeysymToKeycode(X_Dpy, keysym), LockMask|mask,
	    win, True, GrabModeAsync, GrabModeAsync);
#endif
}

void
xu_key_grab_keycode(Window win, int mask, int keycode)
{
        XGrabKey(X_Dpy, keycode, mask, win, True, GrabModeAsync, GrabModeAsync);
a134 11
}

char *
xu_getstrprop(struct client_ctx *cc, Atom atm)
{
	u_char *cp;

	if (xu_getprop(cc, atm, XA_STRING, 100L, &cp) <= 0)
		return (NULL);

	return ((char *)cp);
@


1.2
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@a4 1
 * All rights reserved.
d6 13
a18 1
 * $Id: xutil.c,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * $Id: xutil.c,v 1.7 2005/08/20 20:56:24 marius Exp $
d16 1
a16 1
	return (XGrabPointer(G_dpy, win, False, mask,
d24 1
a24 1
	return (XChangeActivePointerGrab(G_dpy, mask,
d31 1
a31 1
	XUngrabPointer(G_dpy, CurrentTime);
d37 1
a37 1
        return (XGrabButton(G_dpy, btn, mask, win,
d45 1
a45 1
	XUngrabButton(G_dpy, btn, mask, win);
d55 1
a55 1
        XQueryPointer(G_dpy, rootwin, &w0, &w1, &tmp0, &tmp1, x, y, &tmp2);
d61 1
a61 1
	XWarpPointer(G_dpy, None, win, 0, 0, 0, 0, x, y);
d69 3
a71 3
	code = XKeysymToKeycode(G_dpy, keysym);
	if ((XKeycodeToKeysym(G_dpy, code, 0) != keysym) &&
	    (XKeycodeToKeysym(G_dpy, code, 1) == keysym))
d74 1
a74 1
        XGrabKey(G_dpy, XKeysymToKeycode(G_dpy, keysym), mask, win, True,
d77 1
a77 1
        XGrabKey(G_dpy, XKeysymToKeycode(G_dpy, keysym), LockMask|mask,
d85 1
a85 1
        XGrabKey(G_dpy, keycode, mask, win, True, GrabModeAsync, GrabModeAsync);
d101 1
a101 1
	XSendEvent(G_dpy, cc->win, False, 0, &e);
d111 1
a111 1
	if (XGetWindowProperty(G_dpy, cc->win, atm, 0L, len, False, type,
d124 1
a124 1
	Atom wm_state = XInternAtom(G_dpy, "WM_STATE", False);
d154 1
a154 1
	wm_state = XInternAtom(G_dpy, "WM_STATE", False);
d160 1
a160 1
	XChangeProperty(G_dpy, cc->win, wm_state, wm_state, 32,
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
