head	1.126;
access;
symbols
	OPENBSD_6_2:1.126.0.4
	OPENBSD_6_2_BASE:1.126
	OPENBSD_6_1:1.126.0.2
	OPENBSD_6_1_BASE:1.126
	OPENBSD_6_0:1.121.0.4
	OPENBSD_6_0_BASE:1.121
	OPENBSD_5_9:1.121.0.2
	OPENBSD_5_9_BASE:1.121
	OPENBSD_5_8:1.112.0.2
	OPENBSD_5_8_BASE:1.112
	OPENBSD_5_7:1.110.0.2
	OPENBSD_5_7_BASE:1.110
	OPENBSD_5_6:1.87.0.4
	OPENBSD_5_6_BASE:1.87
	OPENBSD_5_5:1.87.0.2
	OPENBSD_5_5_BASE:1.87
	OPENBSD_5_4:1.79.0.2
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.70.0.2
	OPENBSD_5_3_BASE:1.70
	OPENBSD_5_2:1.59.0.2
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.2
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.49.0.2
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.46.0.4
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.32.0.2
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.126
date	2017.02.10.15.00.54;	author okan;	state Exp;
branches;
next	1.125;
commitid	CB8CH00ojquPeGWC;

1.125
date	2016.10.24.17.39.38;	author okan;	state Exp;
branches;
next	1.124;
commitid	4CtR29PGziRtkeB6;

1.124
date	2016.10.18.17.03.30;	author okan;	state Exp;
branches;
next	1.123;
commitid	dIOrHVlb55Ubzrpl;

1.123
date	2016.10.04.15.18.20;	author okan;	state Exp;
branches;
next	1.122;
commitid	A3zvKURgft7ltYQX;

1.122
date	2016.09.02.16.07.11;	author okan;	state Exp;
branches;
next	1.121;
commitid	4DOKmKsBDQHagyle;

1.121
date	2015.11.10.20.05.33;	author okan;	state Exp;
branches;
next	1.120;
commitid	vKzF5zXTpUgY9uJK;

1.120
date	2015.08.27.18.53.15;	author okan;	state Exp;
branches;
next	1.119;
commitid	zidCZkwdtbi68xMi;

1.119
date	2015.08.27.17.43.44;	author okan;	state Exp;
branches;
next	1.118;
commitid	GGEe3v1OUta2BX7S;

1.118
date	2015.08.25.20.35.49;	author okan;	state Exp;
branches;
next	1.117;
commitid	a4Bxb4Cg30yXgmlc;

1.117
date	2015.08.25.19.52.02;	author okan;	state Exp;
branches;
next	1.116;
commitid	XbPViFyzFdMRoFXv;

1.116
date	2015.08.25.19.49.19;	author okan;	state Exp;
branches;
next	1.115;
commitid	a99lqkhK6wYk0Jrc;

1.115
date	2015.08.25.18.29.10;	author okan;	state Exp;
branches;
next	1.114;
commitid	uqkKibG5fLGc4c6r;

1.114
date	2015.08.23.17.31.20;	author okan;	state Exp;
branches;
next	1.113;
commitid	m6evlaUZXnHGLcAq;

1.113
date	2015.08.21.15.52.49;	author okan;	state Exp;
branches;
next	1.112;
commitid	zAGJnc67FRmueTYK;

1.112
date	2015.06.28.19.50.46;	author okan;	state Exp;
branches;
next	1.111;
commitid	9QJos70x7Vh2VORU;

1.111
date	2015.03.28.23.12.47;	author okan;	state Exp;
branches;
next	1.110;
commitid	nwNT3PjeOYm65gQ8;

1.110
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.109;
commitid	kLADTGYX3gw0Sf2m;

1.109
date	2014.10.08.12.48.51;	author okan;	state Exp;
branches;
next	1.108;
commitid	bx3Cy9JxKYTynRL9;

1.108
date	2014.09.27.19.04.32;	author okan;	state Exp;
branches;
next	1.107;
commitid	X6SwRTs6gMlrxQ8N;

1.107
date	2014.09.27.18.57.11;	author okan;	state Exp;
branches;
next	1.106;
commitid	jUS6FG6I8ION7wm9;

1.106
date	2014.09.23.14.25.08;	author okan;	state Exp;
branches;
next	1.105;
commitid	rp7vMsjSPRy6s8TJ;

1.105
date	2014.09.23.13.45.48;	author okan;	state Exp;
branches;
next	1.104;
commitid	3MLwoEk2vcFsHNle;

1.104
date	2014.09.17.16.32.53;	author okan;	state Exp;
branches;
next	1.103;
commitid	VoKzpesV33vUCQZ7;

1.103
date	2014.09.17.14.31.37;	author okan;	state Exp;
branches;
next	1.102;
commitid	PntP0xZYNorE93in;

1.102
date	2014.09.08.21.15.14;	author okan;	state Exp;
branches;
next	1.101;
commitid	os8IEZxNKyVrOZR1;

1.101
date	2014.09.08.13.51.29;	author okan;	state Exp;
branches;
next	1.100;
commitid	OmIn9iExEjTH79st;

1.100
date	2014.09.07.20.57.26;	author okan;	state Exp;
branches;
next	1.99;
commitid	Fdk72uq6A4nstPUM;

1.99
date	2014.09.07.17.27.20;	author okan;	state Exp;
branches;
next	1.98;
commitid	gXhDmsdKh2raktuB;

1.98
date	2014.09.06.16.08.58;	author okan;	state Exp;
branches;
next	1.97;
commitid	hqjCXxcyI22RFKvg;

1.97
date	2014.09.01.18.04.58;	author okan;	state Exp;
branches;
next	1.96;
commitid	X0CjpcmJsClz2NwK;

1.96
date	2014.08.25.14.31.22;	author okan;	state Exp;
branches;
next	1.95;
commitid	IBKKLiHu5PwQFfcG;

1.95
date	2014.08.25.12.49.19;	author okan;	state Exp;
branches;
next	1.94;
commitid	rbGNqfikQcQWLop3;

1.94
date	2014.08.24.15.37.45;	author okan;	state Exp;
branches;
next	1.93;
commitid	0998haeGdCsc6F3q;

1.93
date	2014.08.22.19.04.00;	author okan;	state Exp;
branches;
next	1.92;
commitid	INCxCbmjnfOT88xa;

1.92
date	2014.08.20.15.15.29;	author okan;	state Exp;
branches;
next	1.91;
commitid	SsDu0AngUZExtrz4;

1.91
date	2014.08.20.13.42.27;	author okan;	state Exp;
branches;
next	1.90;
commitid	RFuXcmLFopZhWY5G;

1.90
date	2014.08.20.12.33.12;	author okan;	state Exp;
branches;
next	1.89;
commitid	5PNc5aS6nFWnspE6;

1.89
date	2014.08.19.12.47.51;	author okan;	state Exp;
branches;
next	1.88;
commitid	v4kkJCmpqLHUwcTv;

1.88
date	2014.08.18.13.57.57;	author okan;	state Exp;
branches;
next	1.87;
commitid	xw8U6yGIv8HLFURK;

1.87
date	2014.02.08.02.49.30;	author okan;	state Exp;
branches;
next	1.86;

1.86
date	2014.02.08.02.40.43;	author okan;	state Exp;
branches;
next	1.85;

1.85
date	2014.02.07.18.09.54;	author okan;	state Exp;
branches;
next	1.84;

1.84
date	2014.01.24.15.08.06;	author okan;	state Exp;
branches;
next	1.83;

1.83
date	2014.01.20.18.58.03;	author okan;	state Exp;
branches;
next	1.82;

1.82
date	2013.12.11.14.09.21;	author okan;	state Exp;
branches;
next	1.81;

1.81
date	2013.10.17.13.59.10;	author okan;	state Exp;
branches;
next	1.80;

1.80
date	2013.10.03.13.51.59;	author okan;	state Exp;
branches;
next	1.79;

1.79
date	2013.07.15.14.50.44;	author okan;	state Exp;
branches;
next	1.78;

1.78
date	2013.07.09.01.24.49;	author okan;	state Exp;
branches;
next	1.77;

1.77
date	2013.07.08.15.48.16;	author okan;	state Exp;
branches;
next	1.76;

1.76
date	2013.05.06.16.03.11;	author okan;	state Exp;
branches;
next	1.75;

1.75
date	2013.04.30.21.10.23;	author okan;	state Exp;
branches;
next	1.74;

1.74
date	2013.04.17.13.30.38;	author okan;	state Exp;
branches;
next	1.73;

1.73
date	2013.04.08.13.05.27;	author okan;	state Exp;
branches;
next	1.72;

1.72
date	2013.04.08.13.02.31;	author okan;	state Exp;
branches;
next	1.71;

1.71
date	2013.04.05.17.07.25;	author okan;	state Exp;
branches;
next	1.70;

1.70
date	2013.01.13.13.55.12;	author okan;	state Exp;
branches;
next	1.69;

1.69
date	2013.01.10.15.28.11;	author okan;	state Exp;
branches;
next	1.68;

1.68
date	2013.01.01.14.50.01;	author okan;	state Exp;
branches;
next	1.67;

1.67
date	2013.01.01.14.19.56;	author okan;	state Exp;
branches;
next	1.66;

1.66
date	2012.12.17.17.48.57;	author okan;	state Exp;
branches;
next	1.65;

1.65
date	2012.12.17.14.32.39;	author okan;	state Exp;
branches;
next	1.64;

1.64
date	2012.11.29.04.25.49;	author okan;	state Exp;
branches;
next	1.63;

1.63
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.62;

1.62
date	2012.11.08.20.18.19;	author okan;	state Exp;
branches;
next	1.61;

1.61
date	2012.11.07.20.34.39;	author okan;	state Exp;
branches;
next	1.60;

1.60
date	2012.09.09.20.52.57;	author okan;	state Exp;
branches;
next	1.59;

1.59
date	2012.07.08.01.00.24;	author okan;	state Exp;
branches;
next	1.58;

1.58
date	2012.07.03.13.49.03;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2012.05.16.21.57.21;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2012.05.16.01.10.11;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2011.12.29.20.48.38;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2011.10.12.15.43.50;	author okan;	state Exp;
branches;
next	1.53;

1.53
date	2011.09.19.07.23.03;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2011.09.13.08.37.49;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2011.07.25.15.10.24;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2011.02.13.17.25.20;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.25.20.01.27;	author okan;	state Exp;
branches;
next	1.47;

1.47
date	2010.09.25.19.58.08;	author okan;	state Exp;
branches;
next	1.46;

1.46
date	2010.07.30.12.28.19;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2010.06.28.12.29.04;	author okan;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.11.16.51.26;	author okan;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2009.12.15.03.38.11;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2009.12.15.03.34.34;	author okan;	state Exp;
branches;
next	1.40;

1.40
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.14.16.39.01;	author oga;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.11.17.55.42;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2009.12.11.17.51.42;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2009.12.10.23.21.26;	author oga;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.10.23.14.58;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2009.12.10.17.16.51;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2009.12.07.23.19.51;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.20.00.55.42;	author okan;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.20.00.22.39;	author okan;	state Exp;
branches;
next	1.30;

1.30
date	2009.05.19.12.49.37;	author sthen;	state Exp;
branches;
next	1.29;

1.29
date	2009.05.18.00.23.35;	author okan;	state Exp;
branches;
next	1.28;

1.28
date	2009.05.17.23.40.57;	author okan;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.17.23.37.52;	author okan;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.17.22.48.47;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2009.05.17.17.04.59;	author sthen;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.14.16.24.04;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.27.00.42.53;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.16.15.24.14;	author okan;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.15.00.32.35;	author okan;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.11.21.46.48;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.18.15.40.52;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.21.14.11.19;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.19.17.13.55;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.19.17.11.19;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.18.20.00.16;	author okan;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.18.19.38.18;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.15.22.18.00;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.16.13.38.09;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.16.13.35.37;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.23.15.09.21;	author simon;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.22.21.34.07;	author okan;	state Exp;
branches;
next	1.6;

1.6
date	2008.03.22.15.09.45;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.16.11.39.20;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.14.15.21.10;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.126
log
@Fix group hidden state when a client wants to be on all desktops on start;
reported by Vadim Vygonets with diff, but another approach was taken.
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Andy Adamson <dros@@monkey.org>
 * Copyright (c) 2004,2005 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: group.c,v 1.125 2016/10/24 17:39:38 okan Exp $
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

static struct group_ctx	*group_next(struct group_ctx *);
static struct group_ctx	*group_prev(struct group_ctx *);
static void		 group_restack(struct group_ctx *);
static void		 group_setactive(struct group_ctx *);

const char *num_to_name[] = {
	"nogroup", "one", "two", "three", "four", "five", "six",
	"seven", "eight", "nine"
};

void
group_assign(struct group_ctx *gc, struct client_ctx *cc)
{
	if (cc->gc != NULL)
		TAILQ_REMOVE(&cc->gc->clientq, cc, group_entry);

	if ((gc != NULL) && (gc->num == 0))
		gc = NULL;

	cc->gc = gc;

	if (cc->gc != NULL)
		TAILQ_INSERT_TAIL(&gc->clientq, cc, group_entry);

	xu_ewmh_net_wm_desktop(cc);
}

void
group_hide(struct group_ctx *gc)
{
	struct client_ctx	*cc;

	screen_updatestackingorder(gc->sc);

	TAILQ_FOREACH(cc, &gc->clientq, group_entry) {
		if (!(cc->flags & CLIENT_STICKY))
			client_hide(cc);
	}
}

void
group_show(struct group_ctx *gc)
{
	struct client_ctx	*cc;

	TAILQ_FOREACH(cc, &gc->clientq, group_entry) {
		if (!(cc->flags & CLIENT_STICKY))
			client_unhide(cc);
	}

	group_restack(gc);
	group_setactive(gc);
}

static void
group_restack(struct group_ctx *gc)
{
	struct client_ctx	*cc;
	Window			*winlist;
	int			 i, lastempty = -1;
	int			 nwins = 0, highstack = 0;

	TAILQ_FOREACH(cc, &gc->clientq, group_entry) {
		if (cc->stackingorder > highstack)
			highstack = cc->stackingorder;
	}
	winlist = xreallocarray(NULL, (highstack + 1), sizeof(*winlist));

	/* Invert the stacking order for XRestackWindows(). */
	TAILQ_FOREACH(cc, &gc->clientq, group_entry) {
		winlist[highstack - cc->stackingorder] = cc->win;
		nwins++;
	}

	/* Un-sparseify */
	for (i = 0; i <= highstack; i++) {
		if (!winlist[i] && lastempty == -1)
			lastempty = i;
		else if (winlist[i] && lastempty != -1) {
			winlist[lastempty] = winlist[i];
			if (++lastempty == i)
				lastempty = -1;
		}
	}

	XRestackWindows(X_Dpy, winlist, nwins);
	free(winlist);
}

void
group_init(struct screen_ctx *sc, int num)
{
	struct group_ctx	*gc;

	gc = xmalloc(sizeof(*gc));
	gc->sc = sc;
	gc->name = xstrdup(num_to_name[num]);
	gc->num = num;
	TAILQ_INIT(&gc->clientq);

	TAILQ_INSERT_TAIL(&sc->groupq, gc, entry);

	if (num == 1)
		group_setactive(gc);
}

void
group_setactive(struct group_ctx *gc)
{
	struct screen_ctx	*sc = gc->sc;

	sc->group_active = gc;

	xu_ewmh_net_current_desktop(sc);
}

void
group_movetogroup(struct client_ctx *cc, int idx)
{
	struct screen_ctx	*sc = cc->sc;
	struct group_ctx	*gc;

	if (idx < 0 || idx >= Conf.ngroups)
		errx(1, "%s: index out of range (%d)", __func__, idx);

	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		if (gc->num == idx)
			break;
	}

	if (cc->gc == gc)
		return;
	if (gc->num != 0 && group_holds_only_hidden(gc))
		client_hide(cc);
	group_assign(gc, cc);
}

void
group_toggle_membership_enter(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct group_ctx	*gc = sc->group_active;

	if (gc == cc->gc) {
		group_assign(NULL, cc);
		cc->flags |= CLIENT_UNGROUP;
	} else {
		group_assign(gc, cc);
		cc->flags |= CLIENT_GROUP;
	}

	client_draw_border(cc);
}

void
group_toggle_membership_leave(struct client_ctx *cc)
{
	cc->flags &= ~CLIENT_HIGHLIGHT;
	client_draw_border(cc);
}

int
group_holds_only_sticky(struct group_ctx *gc)
{
	struct client_ctx	*cc;

	TAILQ_FOREACH(cc, &gc->clientq, group_entry) {
		if (!(cc->flags & CLIENT_STICKY))
			return(0);
	}
	return(1);
}

int
group_holds_only_hidden(struct group_ctx *gc)
{
	struct client_ctx	*cc;

	TAILQ_FOREACH(cc, &gc->clientq, group_entry) {
		if (!(cc->flags & (CLIENT_HIDDEN | CLIENT_STICKY)))
			return(0);
	}
	return(1);
}

void
group_hidetoggle(struct screen_ctx *sc, int idx)
{
	struct group_ctx	*gc;

	if (idx < 0 || idx >= Conf.ngroups)
		errx(1, "%s: index out of range (%d)", __func__, idx);

	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		if (gc->num == idx)
			break;
	}

	if (group_holds_only_hidden(gc))
		group_show(gc);
	else {
		group_hide(gc);
		/* make clients stick to empty group */
		if (TAILQ_EMPTY(&gc->clientq))
			group_setactive(gc);
	}
}

void
group_only(struct screen_ctx *sc, int idx)
{
	struct group_ctx	*gc;

	if (idx < 0 || idx >= Conf.ngroups)
		errx(1, "%s: index out of range (%d)", __func__, idx);

	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		if (gc->num == idx)
			group_show(gc);
		else
			group_hide(gc);
	}
}

void
group_cycle(struct screen_ctx *sc, int flags)
{
	struct group_ctx	*newgc, *oldgc, *showgroup = NULL;

	oldgc = sc->group_active;

	newgc = oldgc;
	for (;;) {
		newgc = (flags & CWM_CYCLE_REVERSE) ? group_prev(newgc) :
		    group_next(newgc);

		if (newgc == oldgc)
			break;

		if (!group_holds_only_sticky(newgc) && showgroup == NULL)
			showgroup = newgc;
		else if (!group_holds_only_hidden(newgc))
			group_hide(newgc);
	}

	if (showgroup == NULL)
		return;

	group_hide(oldgc);

	if (group_holds_only_hidden(showgroup))
		group_show(showgroup);
	else
		group_setactive(showgroup);
}

static struct group_ctx *
group_next(struct group_ctx *gc)
{
	struct screen_ctx	*sc = gc->sc;
	struct group_ctx	*newgc;

	return(((newgc = TAILQ_NEXT(gc, entry)) != NULL) ?
	    newgc : TAILQ_FIRST(&sc->groupq));
}

static struct group_ctx *
group_prev(struct group_ctx *gc)
{
	struct screen_ctx	*sc = gc->sc;
	struct group_ctx	*newgc;

	return(((newgc = TAILQ_PREV(gc, group_q, entry)) != NULL) ?
	    newgc : TAILQ_LAST(&sc->groupq, group_q));
}

void
group_alltoggle(struct screen_ctx *sc)
{
	struct group_ctx	*gc;

	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		if (sc->hideall)
			group_show(gc);
		else
			group_hide(gc);
	}
	sc->hideall = !sc->hideall;
}

int
group_restore(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct group_ctx	*gc;
	int			 num;
	long			*grpnum;

	if (xu_getprop(cc->win, ewmh[_NET_WM_DESKTOP], XA_CARDINAL, 1L,
	    (unsigned char **)&grpnum) <= 0)
		return(0);

	num = (*grpnum == -1) ? 0 : *grpnum;
	num = MIN(num, (Conf.ngroups - 1));
	XFree(grpnum);

	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		if (gc->num == num) {
			group_assign(gc, cc);
			return(1);
		}
	}
	return(0);
}

int
group_autogroup(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct autogroup	*ag;
	struct group_ctx	*gc;
	int			 num = -1, both_match = 0;

	if (cc->ch.res_class == NULL || cc->ch.res_name == NULL)
		return(0);

	TAILQ_FOREACH(ag, &Conf.autogroupq, entry) {
		if (strcmp(ag->class, cc->ch.res_class) == 0) {
			if ((ag->name != NULL) &&
			    (strcmp(ag->name, cc->ch.res_name) == 0)) {
				num = ag->num;
				both_match = 1;
			} else if (ag->name == NULL && !both_match)
				num = ag->num;
		}
	}

	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		if (gc->num == num) {
			group_assign(gc, cc);
			return(1);
		}
	}
	return(0);
}
@


1.125
log
@Sprinkle __func__ in appropriate error messages.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.124 2016/10/18 17:03:30 okan Exp $
d167 1
a167 1
	if (group_holds_only_hidden(gc))
@


1.124
log
@Refactor callbacks to take a void * so as to not try and generalize into
client_ctx in keypress and buttonpress event handlers; pass appropriate *ctx's
based on context.

While here, limit some globals, replace defines with appropriate variables and
fix some naming.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.123 2016/10/04 15:18:20 okan Exp $
d158 1
a158 1
		errx(1, "group_movetogroup: index out of range (%d)", idx);
d226 1
a226 1
		errx(1, "group_hidetoggle: index out of range (%d)", idx);
d249 1
a249 1
		errx(1, "group_only: index out of range (%d)", idx);
@


1.123
log
@Turn CALMWM_NGROUPS define into variable, ngroups.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.122 2016/09/02 16:07:11 okan Exp $
d268 1
a268 1
		newgc = (flags & CWM_CLIENT_RCYCLE) ? group_prev(newgc) :
d307 2
a308 2
	return(((newgc = TAILQ_PREV(gc, group_ctx_q, entry)) != NULL) ?
	    newgc : TAILQ_LAST(&sc->groupq, group_ctx_q));
d354 1
a354 1
	struct autogroupwin	*aw;
d361 5
a365 5
	TAILQ_FOREACH(aw, &Conf.autogroupq, entry) {
		if (strcmp(aw->class, cc->ch.res_class) == 0) {
			if ((aw->name != NULL) &&
			    (strcmp(aw->name, cc->ch.res_name) == 0)) {
				num = aw->num;
d367 2
a368 2
			} else if (aw->name == NULL && !both_match)
				num = aw->num;
@


1.122
log
@Simplify group_holds_only_hidden(); from Vadim Vygonets.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.121 2015/11/10 20:05:33 okan Exp $
d157 1
a157 1
	if (idx < 0 || idx >= CALMWM_NGROUPS)
d225 1
a225 1
	if (idx < 0 || idx >= CALMWM_NGROUPS)
d248 1
a248 1
	if (idx < 0 || idx >= CALMWM_NGROUPS)
d338 1
a338 1
	num = MIN(num, (CALMWM_NGROUPS - 1));
@


1.121
log
@Start cleaning up name vs function differences; replace magic numbers.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.120 2015/08/27 18:53:15 okan Exp $
a211 1
	int			 hidden = 0, same = 0;
d214 2
a215 4
		if (cc->flags & CLIENT_STICKY)
			continue;
		if (hidden == ((cc->flags & CLIENT_HIDDEN) ? 1 : 0))
			same++;
d217 1
a217 5

	if (same == 0)
		hidden = !hidden;

	return(hidden);
@


1.120
log
@Mechanical change: group->gc
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.119 2015/08/27 17:43:44 okan Exp $
d275 1
a275 1
		newgc = (flags & CWM_RCYCLE) ? group_prev(newgc) :
@


1.119
log
@Re-add lost chunk in group_cycle from r1.113.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.118 2015/08/25 20:35:49 okan Exp $
d48 2
a49 2
	if (cc->group != NULL)
		TAILQ_REMOVE(&cc->group->clientq, cc, group_entry);
d54 1
a54 1
	cc->group = gc;
d56 1
a56 1
	if (cc->group != NULL)
d165 1
a165 1
	if (cc->group == gc)
d178 1
a178 1
	if (gc == cc->group) {
@


1.118
log
@Further simplify _NET_WM_DESKTOP handling using new group_assign().
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.117 2015/08/25 19:52:02 okan Exp $
d286 3
@


1.117
log
@oops; remove left over debug print
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.116 2015/08/25 19:49:19 okan Exp $
d334 1
a334 1
	int			 num = -1;
d341 2
a342 1
	num = MIN(*grpnum, (CALMWM_NGROUPS - 1));
a344 4
	if (num == -1) {
		group_assign(NULL, cc);
		return(1);
	}
@


1.116
log
@Allowing sending a valid 'nogroup' (0) group_ctx to group_assign()
(since we init all groups), though assigning the client's group to NULL
for 'sticky'; use this simplification in a few places (others to
follow).
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.115 2015/08/25 18:29:10 okan Exp $
a133 2

	fprintf(stderr, "%d: %s\n", gc->num, gc->name);
@


1.115
log
@Split out sticky mode checks and the restoring of a client's group and
_NET_WM_DESKTOP from the config-based auto-grouping; no (intentional)
behavior changes.  Needed for further work in cleaning up this area.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.114 2015/08/23 17:31:20 okan Exp $
d51 3
d135 2
d346 1
a346 1
	if ((num == -1) || (num == 0)) {
a380 4
	if (num == 0) {
		group_assign(NULL, cc);
		return(1);
	}
@


1.114
log
@Move CLIENT_STICKY logic from client hide/unhide to group hide/unhide;
rationale being that clients should be able to hide/unhide independently
of group switching.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.113 2015/08/21 15:52:49 okan Exp $
a36 1
static void		 group_assign(struct group_ctx *, struct client_ctx *);
d45 1
a45 1
static void
d326 29
a354 1
void
d360 1
a360 2
	int			 num = -2, both_match = 0;
	long			*grpnum;
d363 1
a363 1
		return;
d365 8
a372 16
	if (xu_getprop(cc->win, ewmh[_NET_WM_DESKTOP],
	    XA_CARDINAL, 1, (unsigned char **)&grpnum) > 0) {
		num = *grpnum;
		if (num > CALMWM_NGROUPS || num < -1)
			num = CALMWM_NGROUPS - 1;
		XFree(grpnum);
	} else {
		TAILQ_FOREACH(aw, &Conf.autogroupq, entry) {
			if (strcmp(aw->class, cc->ch.res_class) == 0) {
				if ((aw->name != NULL) &&
				    (strcmp(aw->name, cc->ch.res_name) == 0)) {
					num = aw->num;
					both_match = 1;
				} else if (aw->name == NULL && !both_match)
					num = aw->num;
			}
d376 1
a376 1
	if ((num == -1) || (num == 0)) {
d378 1
a378 1
		return;
a379 1

d383 1
a383 1
			return;
d386 1
a386 5

	if (Conf.flags & CONF_STICKY_GROUPS)
		group_assign(sc->group_active, cc);
	else
		group_assign(NULL, cc);
@


1.113
log
@Bring group and client cycle closer together.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.112 2015/06/28 19:50:46 okan Exp $
d67 4
a70 2
	TAILQ_FOREACH(cc, &gc->clientq, group_entry)
		client_hide(cc);
d78 4
a81 2
	TAILQ_FOREACH(cc, &gc->clientq, group_entry)
		client_unhide(cc);
@


1.112
log
@replace assert usage
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.111 2015/03/28 23:12:47 okan Exp $
d35 2
a259 3
/*
 * Cycle through active groups.  If none exist, then just stay put.
 */
d263 1
a263 1
	struct group_ctx	*gc, *showgroup = NULL;
d265 1
a265 2
	if (((gc = sc->group_active)) == NULL)
		errx(1, "group_cycle: no active group");
d267 1
d269 4
a272 6
		gc = (flags & CWM_RCYCLE) ? TAILQ_PREV(gc, group_ctx_q,
		    entry) : TAILQ_NEXT(gc, entry);
		if (gc == NULL)
			gc = (flags & CWM_RCYCLE) ? TAILQ_LAST(&sc->groupq,
			    group_ctx_q) : TAILQ_FIRST(&sc->groupq);
		if (gc == sc->group_active)
d275 4
a278 4
		if (!group_holds_only_sticky(gc) && showgroup == NULL)
			showgroup = gc;
		else if (!group_holds_only_hidden(gc))
			group_hide(gc);
d281 1
a281 4
	if (showgroup == NULL)
		return;

	group_hide(sc->group_active);
d287 20
@


1.111
log
@Introduce a xreallocarray and convert a few xcalloc instances that do
not require zero'ing.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.110 2015/01/19 14:54:16 okan Exp $
a24 1
#include <assert.h>
d266 2
a267 1
	assert(sc->group_active != NULL);
a268 1
	gc = sc->group_active;
@


1.110
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.109 2014/10/08 12:48:51 okan Exp $
d94 1
a94 1
	winlist = xcalloc((highstack + 1), sizeof(*winlist));
@


1.109
log
@make group_init work like other *_init's
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.108 2014/09/27 19:04:32 okan Exp $
d22 1
a22 1
#include <sys/param.h>
d28 1
@


1.108
log
@these have nothing to do with 'sticky', but rather group membership; rename.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.107 2014/09/27 18:57:11 okan Exp $
d117 1
a117 1
group_init(struct screen_ctx *sc)
a119 1
	int			 i;
d121 10
a130 10
	for (i = 0; i < CALMWM_NGROUPS; i++) {
		gc = xcalloc(1, sizeof(*gc));
		gc->sc = sc;
		TAILQ_INIT(&gc->clientq);
		gc->name = xstrdup(num_to_name[i]);
		gc->num = i;
		TAILQ_INSERT_TAIL(&sc->groupq, gc, entry);
		if (i == 1)
			group_setactive(gc);
	}
d133 1
a133 1
static void
@


1.107
log
@Pass just the group to group_setactive instead of the screen and an
index which then needed to be found in a queue.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.106 2014/09/23 14:25:08 okan Exp $
a164 3
/*
 * Colouring for groups upon add/remove.
 */
d166 1
a166 1
group_sticky_toggle_enter(struct client_ctx *cc)
d183 1
a183 1
group_sticky_toggle_exit(struct client_ctx *cc)
@


1.106
log
@Update _NET_CURRENT_DESKTOP with the screen's group_active->num.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.105 2014/09/23 13:45:48 okan Exp $
d37 1
a37 1
static void		 group_setactive(struct screen_ctx *, int);
d78 1
a78 1
	group_setactive(gc->sc, gc->num);
d129 2
a131 2

	group_setactive(sc, 1);
d135 1
a135 1
group_setactive(struct screen_ctx *sc, int idx)
d137 1
a137 1
	struct group_ctx	*gc;
a138 4
	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		if (gc->num == idx)
			break;
	}
d242 1
a242 1
			group_setactive(sc, idx);
d296 1
a296 1
		group_setactive(sc, showgroup->num);
@


1.105
log
@Move stuff that doesn't belong in group_init; while here, explicitly
initialize hideall and cycling.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.104 2014/09/17 16:32:53 okan Exp $
d37 1
a37 1
static void		 group_setactive(struct screen_ctx *, long);
d135 1
a135 1
group_setactive(struct screen_ctx *sc, long idx)
d145 1
a145 1
	xu_ewmh_net_current_desktop(sc, idx);
@


1.104
log
@Use a similarly named check as sticky for hidden check in a group.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.103 2014/09/17 14:31:37 okan Exp $
a121 3
	TAILQ_INIT(&sc->groupq);
	sc->group_hideall = 0;

a130 6
	xu_ewmh_net_desktop_names(sc);
	xu_ewmh_net_wm_desktop_viewport(sc);
	xu_ewmh_net_wm_number_of_desktops(sc);
	xu_ewmh_net_showing_desktop(sc);
	xu_ewmh_net_virtual_roots(sc);

d309 1
a309 1
		if (sc->group_hideall)
d314 1
a314 1
	sc->group_hideall = !sc->group_hideall;
@


1.103
log
@Introduce a check to see if a group holds only 'sticky' clients and use
this check to decide if a group is virtually empty.  Rationale: if a
group contains *only* 'sticky' clients, it should be skipped while
cycling through groups.  Apply similar logic to the group menu.

Based on an idea from phessler@@, who also tested another version.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.102 2014/09/08 21:15:14 okan Exp $
d173 1
a173 1
	if (group_hidden_state(gc))
a209 1
	/* Check if all clients in the group are 'sticky'. */
a216 3
/*
 * If all clients in a group are hidden, then the group state is hidden.
 */
d218 1
a218 1
group_hidden_state(struct group_ctx *gc)
d249 1
a249 1
	if (group_hidden_state(gc))
d297 1
a297 1
		else if (!group_hidden_state(gc))
d306 1
a306 1
	if (group_hidden_state(showgroup))
@


1.102
log
@name the group client queue appropriately, like other queues
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.101 2014/09/08 13:51:29 okan Exp $
d205 13
d299 1
a299 1
		if (!TAILQ_EMPTY(&gc->clientq) && showgroup == NULL)
@


1.101
log
@Now that a group knows its screen, only pass down the group_ctx.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.100 2014/09/07 20:57:26 okan Exp $
d48 1
a48 1
		TAILQ_REMOVE(&cc->group->clients, cc, group_entry);
d53 1
a53 1
		TAILQ_INSERT_TAIL(&gc->clients, cc, group_entry);
d65 1
a65 1
	TAILQ_FOREACH(cc, &gc->clients, group_entry)
d74 1
a74 1
	TAILQ_FOREACH(cc, &gc->clients, group_entry)
d89 1
a89 1
	TAILQ_FOREACH(cc, &gc->clients, group_entry) {
d96 1
a96 1
	TAILQ_FOREACH(cc, &gc->clients, group_entry) {
d128 1
a128 1
		TAILQ_INIT(&gc->clients);
d214 1
a214 1
	TAILQ_FOREACH(cc, &gc->clients, group_entry) {
d245 1
a245 1
		if (TAILQ_EMPTY(&gc->clients))
d286 1
a286 1
		if (!TAILQ_EMPTY(&gc->clients) && showgroup == NULL)
@


1.100
log
@Add screen_ctx to group_ctx, and populate on init.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.99 2014/09/07 17:27:20 okan Exp $
d36 1
a36 1
static void		 group_restack(struct screen_ctx *, struct group_ctx *);
d59 1
a59 1
group_hide(struct screen_ctx *sc, struct group_ctx *gc)
d63 1
a63 1
	screen_updatestackingorder(sc);
d70 1
a70 1
group_show(struct screen_ctx *sc, struct group_ctx *gc)
d77 2
a78 2
	group_restack(sc, gc);
	group_setactive(sc, gc->num);
d82 1
a82 1
group_restack(struct screen_ctx *sc, struct group_ctx *gc)
d241 1
a241 1
		group_show(sc, gc);
d243 1
a243 1
		group_hide(sc, gc);
d260 1
a260 1
			group_show(sc, gc);
d262 1
a262 1
			group_hide(sc, gc);
d289 1
a289 1
			group_hide(sc, gc);
d295 1
a295 1
	group_hide(sc, sc->group_active);
d298 1
a298 1
		group_show(sc, showgroup);
d310 1
a310 1
			group_show(sc, gc);
d312 1
a312 1
			group_hide(sc, gc);
@


1.99
log
@Get rid of a redundant array of groups per screen; we already have a
link to the group queue for each screen.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.98 2014/09/06 16:08:58 okan Exp $
d127 1
@


1.98
log
@Rework group names: stash the group name inside the group_ctx as opposed
to having to manage an array outside in screen_ctx for group names and
shortcuts.  Simplifies (and moves bits for) reading, and constructing
data for, EWMH's _NET_DESKTOP_NAMES.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.97 2014/09/01 18:04:58 okan Exp $
d119 2
a120 1
	int	 i;
d126 5
a130 4
		TAILQ_INIT(&sc->groups[i].clients);
		sc->groups[i].name = xstrdup(num_to_name[i]);
		sc->groups[i].num = i;
		TAILQ_INSERT_TAIL(&sc->groupq, &sc->groups[i], entry);
d145 7
a151 1
	sc->group_active = &sc->groups[idx];
d165 4
a168 1
	gc = &sc->groups[idx];
d234 4
a237 1
	gc = &sc->groups[idx];
@


1.97
log
@Merge group_menu into mousefunc_menu_group.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.96 2014/08/25 14:31:22 okan Exp $
a122 5
	/*
	 * See if any group names have already been set and update the
	 * property with ours if they'll have changed.
	 */
	group_update_names(sc);
d126 1
d131 1
a348 47
}

void
group_update_names(struct screen_ctx *sc)
{
	char		**strings, *p;
	unsigned char	*prop_ret;
	int		 i = 0, j = 0, nstrings = 0, n = 0, setnames = 0;

	if ((j = xu_getprop(sc->rootwin, ewmh[_NET_DESKTOP_NAMES],
	    cwmh[UTF8_STRING], 0xffffff, (unsigned char **)&prop_ret)) > 0) {
		prop_ret[j - 1] = '\0'; /* paranoia */
		while (i < j) {
			if (prop_ret[i++] == '\0')
				nstrings++;
		}
	}

	strings = xcalloc((nstrings < CALMWM_NGROUPS ? CALMWM_NGROUPS :
	    nstrings), sizeof(*strings));

	p = (char *)prop_ret;
	while (n < nstrings) {
		strings[n++] = xstrdup(p);
		p += strlen(p) + 1;
	}
	/*
	 * make sure we always set our defaults if nothing is there to
	 * replace them.
	 */
	if (n < CALMWM_NGROUPS) {
		setnames = 1;
		i = 0;
		while (n < CALMWM_NGROUPS)
			strings[n++] = xstrdup(num_to_name[i++]);
	}

	if (prop_ret != NULL)
		XFree(prop_ret);
	if (sc->group_nonames != 0)
		free(sc->group_names);

	sc->group_names = strings;
	sc->group_nonames = n;

	if (setnames)
		xu_ewmh_net_desktop_names(sc);
@


1.96
log
@Since the flatting out of sc->group_names is only for setting
NET_DESKTOP_NAMES, merge the helper into xu_ewmh_net_desktop_names,
where we actually set the property.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.95 2014/08/25 12:49:19 okan Exp $
a35 2
static void		 group_hide(struct screen_ctx *, struct group_ctx *);
static void		 group_show(struct screen_ctx *, struct group_ctx *);
a36 1
static int		 group_hidden_state(struct group_ctx *);
d58 1
a58 1
static void
d69 1
a69 1
static void
d199 1
a199 1
static int
a288 30
}

void
group_menu(struct screen_ctx *sc)
{
	struct group_ctx	*gc;
	struct menu		*mi;
	struct menu_q		 menuq;

	TAILQ_INIT(&menuq);

	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		if (TAILQ_EMPTY(&gc->clients))
			continue;
		menuq_add(&menuq, gc,
		    group_hidden_state(gc) ? "%d: [%s]" : "%d: %s",
		    gc->num, sc->group_names[gc->num]);
	}

	if (TAILQ_EMPTY(&menuq))
		return;

	mi = menu_filter(sc, &menuq, NULL, NULL, 0, NULL, NULL);
	if (mi != NULL && mi->ctx != NULL) {
		gc = (struct group_ctx *)mi->ctx;
		(group_hidden_state(gc)) ?
		    group_show(sc, gc) : group_hide(sc, gc);
	}

	menuq_clear(&menuq);
@


1.95
log
@Implement _NET_WM_STATE_STICKY, bound to CM-s by default; allows any
client to 'stick' to all desktops (ewmh speak) or groups - this
currently has the same affect as setting a client's group to 'nogroup',
with the exception that the client can also be in a group, so when
un-sticking, the client will go back to its original group/desktop.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.94 2014/08/24 15:37:45 okan Exp $
a40 1
static void		 group_set_names(struct screen_ctx *);
d429 1
d431 1
a431 23
		group_set_names(sc);
}

static void
group_set_names(struct screen_ctx *sc)
{
	char		*p, *q;
	size_t		 len = 0, tlen, slen;
	int		 i;

	for (i = 0; i < sc->group_nonames; i++)
		len += strlen(sc->group_names[i]) + 1;
	q = p = xcalloc(len, sizeof(*p));

	tlen = len;
	for (i = 0; i < sc->group_nonames; i++) {
		slen = strlen(sc->group_names[i]) + 1;
		(void)strlcpy(q, sc->group_names[i], tlen);
		tlen -= slen;
		q += slen;
	}

	xu_ewmh_net_desktop_names(sc, p, len);
@


1.94
log
@gc->hidden has never consistently kept track of a group's state;
group_show() and group_hide() are not the only ways a group can change
state - if all clients in a group are either hidden or unhidden, then
that group's state should change, as well as the various EWMH ways.
Instead of trying to keep track in a wide variety of places, simply
query the clients in a group before needing to take action based on the
group's state.  Solves long standing confusion of when a group is hidden
or not.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.93 2014/08/22 19:04:00 okan Exp $
d210 2
@


1.93
log
@Fix nogroup regression, where nogroup became an actual group - the
symantics between cwm groups and ewmh got in the way.  Ensure a client
that wants to be in nogroup stays in nogroup (thus stays in view), even
when (re)reading NET_WM_DESKTOP.  Paritially reverts patchset 644
(2014-02-07 13:09 PST) which deals with a NULL cc->group.  All to be
revisited when NET_WM_STATE_STICKY hits cwm.

Reported by many; testing and ok phessler.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.92 2014/08/20 15:15:29 okan Exp $
d39 1
a39 1
static void		 group_set_hidden_state(struct group_ctx *);
a70 2

	gc->hidden = 1;
a80 2
	gc->hidden = 0;

a134 1
		sc->groups[i].hidden = 0;
a146 9
void
group_set_state(struct screen_ctx *sc)
{
	struct group_ctx	*gc;

	TAILQ_FOREACH(gc, &sc->groupq, entry)
		group_set_hidden_state(gc);
}

d165 1
d168 1
a168 1
	if (gc->hidden)
d201 1
a201 1
 * If all clients in a group are hidden, then set the group state as hidden.
d203 2
a204 2
static void
group_set_hidden_state(struct group_ctx *gc)
d207 1
a207 1
	int			 same = 0;
d210 1
a210 1
		if (gc->hidden == ((cc->flags & CLIENT_HIDDEN) ? 1 : 0))
d215 3
a217 1
		gc->hidden = !gc->hidden;
a228 1
	group_set_hidden_state(gc);
d230 1
a230 1
	if (gc->hidden)
d278 1
a278 1
		else if (!gc->hidden)
d287 1
a287 1
	if (showgroup->hidden)
d305 2
a306 2

		menuq_add(&menuq, gc, gc->hidden ? "%d: [%s]" : "%d: %s",
d316 2
a317 1
		(gc->hidden) ? group_show(sc, gc) : group_hide(sc, gc);
@


1.92
log
@Purely mechanical; unify 'num', 'no' and 'shortcut'.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.91 2014/08/20 13:42:27 okan Exp $
a50 5
	if (gc == NULL)
		gc = TAILQ_FIRST(&cc->sc->groupq);
	if (cc->group == gc)
		return;

a53 1
	TAILQ_INSERT_TAIL(&gc->clients, cc, group_entry);
d56 3
d354 1
a354 1
	int			 num = -1, both_match = 0;
d362 2
a363 3
		if (*grpnum == -1)
			num = 0;
		else if (*grpnum > CALMWM_NGROUPS || *grpnum < 0)
a364 2
		else
			num = *grpnum;
d377 5
@


1.91
log
@Split off group window restacking.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.90 2014/08/20 12:33:12 okan Exp $
d43 1
a43 1
const char *shortcut_to_name[] = {
d89 1
a89 1
	group_setactive(sc, gc->shortcut);
d143 1
a143 1
		sc->groups[i].shortcut = i;
d264 1
a264 1
		if (gc->shortcut == idx)
d305 1
a305 1
		group_setactive(sc, showgroup->shortcut);
d322 1
a322 1
		    gc->shortcut, sc->group_names[gc->shortcut]);
d357 2
a358 2
	int			 no = -1, both_match = 0;
	long			*grpno;
d364 5
a368 5
	    XA_CARDINAL, 1, (unsigned char **)&grpno) > 0) {
		if (*grpno == -1)
			no = 0;
		else if (*grpno > CALMWM_NGROUPS || *grpno < 0)
			no = CALMWM_NGROUPS - 1;
d370 2
a371 2
			no = *grpno;
		XFree(grpno);
d377 1
a377 1
					no = aw->num;
d380 1
a380 1
					no = aw->num;
d386 1
a386 1
		if (gc->shortcut == no) {
d430 1
a430 1
			strings[n++] = xstrdup(shortcut_to_name[i++]);
@


1.90
log
@fix a misleading comment and function name
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.89 2014/08/19 12:47:51 okan Exp $
d38 1
d82 14
a108 1
		client_unhide(cc);
a124 3

	gc->hidden = 0;
	group_setactive(sc, gc->shortcut);
@


1.89
log
@Pull highstack from group_ctx (and useless calculations of); in the one
place that we use highstack, replace that usage with a local variable
(for now until stacking is done properly).
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.88 2014/08/18 13:57:57 okan Exp $
d38 1
a38 1
static void		 group_fix_hidden_state(struct group_ctx *);
d150 1
a150 1
		group_fix_hidden_state(gc);
d206 1
a206 1
 * if group_hidetoggle would produce no effect, toggle the group's hidden state
d209 1
a209 1
group_fix_hidden_state(struct group_ctx *gc)
d232 1
a232 1
	group_fix_hidden_state(gc);
@


1.88
log
@Get rid of nhidden in group_ctx; it actually never reported correctly
since nhidden wasn't incremented nor decremeted in all the right places,
thus confusing matters.  We don't need to carry a count around, so just
use a local variable in the one place we need one to supply
XRestackWindows().
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.87 2014/02/08 02:49:30 okan Exp $
d71 1
a71 2
	gc->highstack = 0;
	TAILQ_FOREACH(cc, &gc->clients, group_entry) {
d73 1
a73 3
		if (cc->stackingorder > gc->highstack)
			gc->highstack = cc->stackingorder;
	}
d83 1
a83 1
	int			 nwins = 0;
a84 1
	gc->highstack = 0;
d86 2
a87 2
		if (cc->stackingorder > gc->highstack)
			gc->highstack = cc->stackingorder;
d89 1
a89 1
	winlist = xcalloc((gc->highstack + 1), sizeof(*winlist));
d91 1
a91 4
	/*
	 * Invert the stacking order as XRestackWindows() expects them
	 * top-to-bottom.
	 */
d93 1
a93 1
		winlist[gc->highstack - cc->stackingorder] = cc->win;
d99 1
a99 1
	for (i = 0; i <= gc->highstack; i++) {
@


1.87
log
@Make sure we cycle through existing client's group membership and set
the hidden state on the group; important to know group hidden state
after a re-exec or restart of cwm (as easily seen in group menu).
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.86 2014/02/08 02:40:43 okan Exp $
a70 1
	gc->nhidden = 0;
a73 1
		gc->nhidden++;
d77 1
a77 1
	gc->hidden = 1;		/* XXX: equivalent to gc->nhidden > 0 */
d86 1
d102 1
d116 1
a116 1
	XRestackWindows(X_Dpy, winlist, gc->nhidden);
d180 1
a180 1
	if (gc->hidden) {
a181 2
		gc->nhidden++;
	}
@


1.86
log
@Replace a few hand rolled loops with like tailq loops.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.85 2014/02/07 18:09:54 okan Exp $
d149 9
@


1.85
log
@If _NET_WM_DESKTOP is set to -1 during client creation, place the client into
group 0 (nogroup); solves problem initially discovered by oga@@nicotinebsd with
tint2.  A clientmessage *after* client creation already handles this case.

Go further and assign every client to a group; in non-sticky mode, group 0
(nogroup) and sticky mode, the active group.  In both cases, autogroup will
override the group assignment.  Removing a group from a client always places
the client back into group 0 (nogroup).  Autogroup can also assign a client to
group 0 (nogroup) to keep a client always visible (unless of course one opts to
hide all clients).
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.84 2014/01/24 15:08:06 okan Exp $
d247 1
a247 1
	int	 i;
d252 3
a254 3
	for (i = 0; i < CALMWM_NGROUPS; i++) {
		if (i == idx)
			group_show(sc, &sc->groups[i]);
d256 1
a256 1
			group_hide(sc, &sc->groups[i]);
a302 1
	int			 i;
d306 1
a306 3
	for (i = 0; i < CALMWM_NGROUPS; i++) {
		gc = &sc->groups[i];

d311 1
a311 1
		    gc->shortcut, sc->group_names[i]);
d329 1
a329 1
	int	 i;
d331 1
a331 1
	for (i = 0; i < CALMWM_NGROUPS; i++) {
d333 1
a333 1
			group_show(sc, &sc->groups[i]);
d335 1
a335 1
			group_hide(sc, &sc->groups[i]);
d337 1
a337 2

	sc->group_hideall = (!sc->group_hideall);
@


1.84
log
@correct arguments and drop the cast.

sanity check by oga@@nicotinebsd
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.83 2014/01/20 18:58:03 okan Exp $
d35 1
a35 2
static void		 group_add(struct group_ctx *, struct client_ctx *);
static void		 group_remove(struct client_ctx *);
d48 1
a48 1
group_add(struct group_ctx *gc, struct client_ctx *cc)
d50 2
a51 3
	if (cc == NULL || gc == NULL)
		errx(1, "group_add: a ctx is NULL");

a64 12
group_remove(struct client_ctx *cc)
{
	if (cc == NULL || cc->group == NULL)
		errx(1, "group_remove: a ctx is NULL");

	TAILQ_REMOVE(&cc->group->clients, cc, group_entry);
	cc->group = NULL;

	xu_ewmh_net_wm_desktop(cc);
}

static void
d175 1
a175 1
	group_add(gc, cc);
d188 1
a188 1
		group_remove(cc);
d191 1
a191 1
		group_add(gc, cc);
d358 1
a358 1
		if (*grpno == 0xffffffff)
a377 4
	/* no group please */
	if (no == 0)
		return;

d380 1
a380 1
			group_add(gc, cc);
d386 3
a388 1
		group_add(sc->group_active, cc);
@


1.83
log
@Add a function that adds an entry to a menuq, normalizing a common code
path; from Tiago Cunha.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.82 2013/12/11 14:09:21 okan Exp $
d108 1
a108 1
	winlist = (Window *) xcalloc(sizeof(*winlist), (gc->highstack + 1));
@


1.82
log
@Stash Class and WM Hints in client_ctx
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.81 2013/10/17 13:59:10 okan Exp $
d327 2
a328 9
		mi = xcalloc(1, sizeof(*mi));
		if (gc->hidden)
			(void)snprintf(mi->text, sizeof(mi->text), "%d: [%s]",
			    gc->shortcut, sc->group_names[i]);
		else
			(void)snprintf(mi->text, sizeof(mi->text), "%d: %s",
			    gc->shortcut, sc->group_names[i]);
		mi->ctx = gc;
		TAILQ_INSERT_TAIL(&menuq, mi, entry);
@


1.81
log
@a few err->errx since we don't have error messages here; from Tiago Cunha
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.80 2013/10/03 13:51:59 okan Exp $
d374 1
a374 1
	if (cc->app_class == NULL || cc->app_name == NULL)
d388 1
a388 1
			if (strcmp(aw->class, cc->app_class) == 0) {
d390 1
a390 1
				    (strcmp(aw->name, cc->app_name) == 0)) {
@


1.80
log
@unify type; no change
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.79 2013/07/15 14:50:44 okan Exp $
d180 1
a180 1
		err(1, "group_movetogroup: index out of range (%d)", idx);
d243 1
a243 1
		err(1, "group_hidetoggle: index out of range (%d)", idx);
d264 1
a264 1
		err(1, "group_only: index out of range (%d)", idx);
@


1.79
log
@simplify atom handling; allows us to limit to one round-trip to server
for gathering Atoms.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.78 2013/07/09 01:24:49 okan Exp $
d422 1
a422 1
	    cwmh[UTF8_STRING], 0xffffff, (u_char **)&prop_ret)) > 0) {
@


1.78
log
@since the root and event window are the same in the case of a button
event on the screen's root window, there's no need to pass down the
entire XButtonEvent event, at least to group_menu(), the only callback
which takes an argument at this point; instead use the already populated
screen.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.77 2013/07/08 15:48:16 okan Exp $
d377 1
a377 1
	if (xu_getprop(cc->win, ewmh[_NET_WM_DESKTOP].atom,
d421 2
a422 2
	if ((j = xu_getprop(sc->rootwin, ewmh[_NET_DESKTOP_NAMES].atom,
	    cwmh[UTF8_STRING].atom, 0xffffff, (u_char **)&prop_ret)) > 0) {
@


1.77
log
@replace a few (x)malloc with (x)calloc to prevent potential integer
overflows; from Tiago Cunha
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.76 2013/05/06 16:03:11 okan Exp $
d312 1
a312 1
group_menu(XButtonEvent *e)
a313 1
	struct screen_ctx	*sc;
a317 2

	sc = screen_fromroot(e->root);
@


1.76
log
@remove group in client_delete directly.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.75 2013/04/30 21:10:23 okan Exp $
d433 2
a434 2
	strings = xmalloc((nstrings < CALMWM_NGROUPS ? CALMWM_NGROUPS :
	    nstrings) * sizeof(*strings));
@


1.75
log
@type fix
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.74 2013/04/17 13:30:38 okan Exp $
a308 11
}

/* called when a client is deleted */
void
group_client_delete(struct client_ctx *cc)
{
	if (cc->group == NULL)
		return;

	TAILQ_REMOVE(&cc->group->clients, cc, group_entry);
	cc->group = NULL; /* he he */
@


1.74
log
@add conf_ignore and move group_make_autogroup to conf_autogroup to match.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.73 2013/04/08 13:05:27 okan Exp $
d101 1
a101 2
	u_int			 i;
	int			 lastempty = -1;
@


1.73
log
@reverse logic to make it like the others
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.72 2013/04/08 13:02:31 okan Exp $
a163 21
}

void
group_make_autogroup(struct conf *conf, char *val, int no)
{
	struct autogroupwin	*aw;
	char			*p;

	aw = xcalloc(1, sizeof(*aw));

	if ((p = strchr(val, ',')) == NULL) {
		aw->name = NULL;
		aw->class = xstrdup(val);
	} else {
		*(p++) = '\0';
		aw->name = xstrdup(val);
		aw->class = xstrdup(p);
	}
	aw->num = no;

	TAILQ_INSERT_TAIL(&conf->autogroupq, aw, entry);
@


1.72
log
@consistency
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.71 2013/04/05 17:07:25 okan Exp $
d378 4
a382 8
	if (mi == NULL || mi->ctx == NULL)
		goto cleanup;

	gc = (struct group_ctx *)mi->ctx;

	(gc->hidden) ? group_show(sc, gc) : group_hide(sc, gc);

cleanup:
@


1.71
log
@zap stray whitespace
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.70 2013/01/13 13:55:12 okan Exp $
d354 1
@


1.70
log
@put back r1.68 which allows an empty group to be sticky; behavior
change noticed by Thomas Pfaff and diagnosis why we need to
group_setactive in this case by Alexander Polakov.  replace XXX with
a useful comment.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.69 2013/01/10 15:28:11 okan Exp $
d145 1
a145 1
	/* 
@


1.69
log
@set the initial group to '1', missed by recent off-by-one group
numbering re-work; discovered the hard way by sthen@@.

ok sthen@@
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.68 2013/01/01 14:50:01 okan Exp $
d272 1
a272 1
	else
d274 4
@


1.68
log
@after we toggle a group hidden, it makes no sense to set it as active
(in sticky or non-stick mode), regardless of existing clients assigned
to that group; oga marked this bit XXX in -r1.34 for it didn't seem make
sense then either.

pulled from a diff from from Alexander Polakov.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.67 2013/01/01 14:19:56 okan Exp $
d163 1
a163 1
	group_setactive(sc, 0);
@


1.67
log
@make num of groups no longer off-by-one; from Alexander Polakov

note that a re-exec of cwm will not rewrite the group number atom of
*existing* clients, so they will remain off-by-one until each client has
its atom updated, or of course a restart of X.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.66 2012/12/17 17:48:57 okan Exp $
d272 1
a272 1
	else {
a273 4
		/* XXX wtf? */
		if (TAILQ_EMPTY(&gc->clients))
			group_setactive(sc, idx);
	}
@


1.66
log
@replace client highlight with a client flag
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.65 2012/12/17 14:32:39 okan Exp $
d135 1
a135 1
	group_setactive(sc, gc->shortcut - 1);
d154 1
a154 1
		sc->groups[i].shortcut = i + 1;
d330 1
a330 1
		group_setactive(sc, showgroup->shortcut - 1);
d423 1
a423 1
			no = *grpno + 1;
d483 1
a483 1
		i = 1;
@


1.65
log
@create and use menuq_clear() helper; from Tiago Cunha
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.64 2012/11/29 04:25:49 okan Exp $
d221 1
a221 3
	struct group_ctx	*gc;

	gc = sc->group_active;
d225 1
a225 1
		cc->highlight = CLIENT_HIGHLIGHT_UNGROUP;
d228 1
a228 1
		cc->highlight = CLIENT_HIGHLIGHT_GROUP;
d237 1
a237 1
	cc->highlight = 0;
@


1.64
log
@specific last match for autogroup; few iterations with Kent Spillner.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.63 2012/11/09 03:52:02 okan Exp $
d388 1
a388 4
	while ((mi = TAILQ_FIRST(&menuq)) != NULL) {
		TAILQ_REMOVE(&menuq, mi, entry);
		free(mi);
	}
@


1.63
log
@sort
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.62 2012/11/08 20:18:19 okan Exp $
d415 1
a415 1
	int			 no = -1;
d432 7
a438 5
			if (strcmp(aw->class, cc->app_class) == 0 &&
			    (aw->name == NULL ||
			    strcmp(aw->name, cc->app_name) == 0)) {
				no = aw->num;
				break;
@


1.62
log
@fix some warnings; inspired by a diff from Thordur Bjornsson.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.61 2012/11/07 20:34:39 okan Exp $
d28 1
a30 1
#include <stdio.h>
@


1.61
log
@get rid of the xfree() wrapper around free(); from Tiago Cunha.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.60 2012/09/09 20:52:57 okan Exp $
d475 1
a475 1
	p = prop_ret;
d505 1
a505 1
	unsigned char	*p, *q;
@


1.60
log
@replace with xu_getprop wrapper used everywhere else.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.59 2012/07/08 01:00:24 okan Exp $
d132 1
a132 1
	xfree(winlist);
d390 1
a390 1
		xfree(mi);
d494 1
a494 1
		xfree(sc->group_names);
@


1.59
log
@remove a redundant assignment and another one up.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.58 2012/07/03 13:49:03 okan Exp $
d461 6
a466 12
	Atom		 type_ret;
	int		 format_ret, i = 0, nstrings = 0, n = 0, setnames = 0;
	unsigned long	 bytes_after, num_ret;

	if (XGetWindowProperty(X_Dpy, sc->rootwin,
	    ewmh[_NET_DESKTOP_NAMES].atom, 0, 0xffffff, False,
	    cwmh[UTF8_STRING].atom, &type_ret, &format_ret,
	    &num_ret, &bytes_after, &prop_ret) == Success &&
	    prop_ret != NULL && format_ret == 8) {
		/* failure, just set defaults */
		prop_ret[num_ret - 1] = '\0'; /* paranoia */
		while (i < num_ret) {
@


1.58
log
@re-implement atom handing; makes for a normalized and more consistent
separation between cwm and ewmh.  seen by a few.
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.57 2012/05/16 21:57:21 okan Exp $
d462 1
a462 1
	int		 format_ret, i = 0, nstrings = 0, n, setnames = 0;
a480 1
	i = n = 0;
@


1.57
log
@get rid of more stray lines/spaces
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.56 2012/05/16 01:10:11 okan Exp $
a50 1
	long	no;
a53 2
	no = gc->shortcut - 1;

a59 3
	XChangeProperty(X_Dpy, cc->win, _NET_WM_DESKTOP, XA_CARDINAL,
	    32, PropModeReplace, (unsigned char *)&no, 1);

d62 2
a68 2
	long	no = 0xffffffff;

a71 3
	XChangeProperty(X_Dpy, cc->win, _NET_WM_DESKTOP, XA_CARDINAL,
	    32, PropModeReplace, (unsigned char *)&no, 1);

d74 2
a141 2
	long	 viewports[2] = {0, 0};
	long	 ndesks = CALMWM_NGROUPS, zero = 0;
d158 5
a162 17
	/* we don't support large desktops, so this is always (0, 0) */
	XChangeProperty(X_Dpy, sc->rootwin, _NET_DESKTOP_VIEWPORT,
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)viewports, 2);
	XChangeProperty(X_Dpy, sc->rootwin, _NET_NUMBER_OF_DESKTOPS,
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&ndesks, 1);
	/*
	 * we don't use virtual roots, so make sure it's not there from a 
	 * previous wm.
	 */
	XDeleteProperty(X_Dpy, sc->rootwin, _NET_VIRTUAL_ROOTS);
	/*
	 * We don't really have a ``showing desktop'' mode, so this is zero
	 * always. XXX Note that when we hide all groups, or when all groups
	 * are hidden we could technically set this later on.
	 */
	XChangeProperty(X_Dpy, sc->rootwin, _NET_SHOWING_DESKTOP,
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&zero, 1);
d191 2
a192 2
	XChangeProperty(X_Dpy, sc->rootwin, _NET_CURRENT_DESKTOP,
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&idx, 1);
d421 2
a422 2
	if (xu_getprop(cc->win, _NET_WM_DESKTOP, XA_CARDINAL,
	    1, (unsigned char **)&grpno) > 0) {
d465 3
a467 2
	if (XGetWindowProperty(X_Dpy, sc->rootwin, _NET_DESKTOP_NAMES, 0,
	    0xffffff, False, UTF8_STRING, &type_ret, &format_ret,
d528 1
a528 2
	XChangeProperty(X_Dpy, sc->rootwin, _NET_DESKTOP_NAMES,
	    UTF8_STRING, 8, PropModeReplace, p, len);
@


1.56
log
@fix comment
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.55 2011/12/29 20:48:38 okan Exp $
d485 1
a485 1
	
d547 1
a547 1
		
@


1.55
log
@check if we're in the group already, else multiple calls to
group_movetogroup() on one client will still increment nhidden if the
group is hidden.

found the hard way by Thomas Jeunet and fix from Alexander Polakov -
thanks to both!

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.54 2011/10/12 15:43:50 okan Exp $
d154 3
a156 2
	/* see if any group names have already been set and update the property
	 * with ours if they'll have changed.
@


1.54
log
@use xfree instead of free since strings is allocated with xmalloc; from
dhill

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.53 2011/09/19 07:23:03 okan Exp $
d225 2
d231 1
a231 1
	group_add(&sc->groups[idx], cc);
@


1.53
log
@move client to group (movetogroup) and hide client only if group is
already hidden (suggested behavior from Alexander Polakov).

ok sthen oga
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.52 2011/09/13 08:37:49 okan Exp $
d518 1
a518 1
		free(sc->group_names);
@


1.52
log
@repair groupcycle (broke after cycle-in-group support added more flags);
found by and fix from Thomas Pfaff.

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.51 2011/07/25 15:10:24 okan Exp $
d219 1
d224 2
a225 1
	if(sc->group_active != &sc->groups[idx])
d227 2
@


1.51
log
@We are inconsistent when it comes to function returns, so just go all
the way with the cwm specific parts.

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.50 2011/05/11 13:53:51 okan Exp $
d316 1
a316 1
group_cycle(struct screen_ctx *sc, int reverse)
d324 2
a325 2
		gc = reverse ? TAILQ_PREV(gc, group_ctx_q, entry) :
		    TAILQ_NEXT(gc, entry);
d327 2
a328 2
			gc = reverse ? TAILQ_LAST(&sc->groupq, group_ctx_q) :
			    TAILQ_FIRST(&sc->groupq);
@


1.50
log
@tag and comment cleanup; ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: group.c,v 1.49 2011/02/13 17:25:20 tedu Exp $
d380 1
a380 1
			snprintf(mi->text, sizeof(mi->text), "%d: [%s]",
d383 1
a383 1
			snprintf(mi->text, sizeof(mi->text), "%d: %s",
d536 1
a536 1
		strlcpy(q, sc->group_names[i], tlen);
@


1.49
log
@we lose track of highstack somewhere, so recompute it before we need it.
fixes a crash reported by christian neukirchen.  ok okan
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.48 2010/09/25 20:01:27 okan Exp $
@


1.48
log
@spacing nits
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.47 2010/09/25 19:58:08 okan Exp $
d111 5
@


1.47
log
@more clear variable name so than name/class shouldn't be confused again.

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.46 2010/07/30 12:28:19 okan Exp $
d429 1
@


1.46
log
@revert -r1.45 of group.c (log was: fix window name and class to match
cwmrc(5)).  instead, fix cwmrc(5) to match the old behavior which also
happens to match the example config, of which many have based their
configs; this also nicely matches the output of xprop(1).

clean-up of variable names as a separate commit.

suggested by sthen (and something we should have done initially).

discussed with and ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.45 2010/06/28 12:29:04 okan Exp $
d182 1
a182 1
group_make_autogroup(struct conf *conf, char *class, int no)
d189 1
a189 1
	if ((p = strchr(class, ',')) == NULL) {
d191 1
a191 1
		aw->class = xstrdup(class);
d194 1
a194 1
		aw->name = xstrdup(class);
@


1.45
log
@fix window name and class to match cwmrc(5); from Holger Mikolon - thanks!

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.44 2010/04/11 16:51:26 okan Exp $
d191 1
d194 2
a195 1
		aw->name = xstrdup(p);
a196 1
	aw->class = xstrdup(class);
@


1.44
log
@clean up a few xu_* functions to just accept what they need (Window).

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.43 2009/12/15 04:10:42 okan Exp $
a190 1
		aw->class = xstrdup(class);
d193 1
a193 2
		aw->name = xstrdup(class);
		aw->class = xstrdup(p);
d195 1
@


1.43
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.42 2009/12/15 03:38:11 okan Exp $
d429 1
a429 1
	if (xu_getprop(cc, _NET_WM_DESKTOP, XA_CARDINAL,
@


1.42
log
@spacing
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.41 2009/12/15 03:34:34 okan Exp $
d22 3
d26 6
@


1.41
log
@pull these headers only into files that need them.

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.40 2009/12/15 03:24:36 okan Exp $
a190 1
	
a452 1

d516 1
a516 1
	q = p = xcalloc(len,  sizeof(*p));
@


1.40
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.39 2009/12/14 16:39:01 oga Exp $
d21 2
@


1.39
log
@kill _CWM_GRP atom setting. The netwm stuff does us well enough now that
it's superfluous.

ok okan@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.38 2009/12/11 17:55:42 oga Exp $
a21 1
#include "headers.h"
@


1.38
log
@implement support for _NET_WM_DESKTOP properties on windows.

it works kinda like _CWM_GRP, which we added to aid restarts a while
ago, but it's standardised and clients are specifically allowed to set
it to request a desktop.

for noe we leave _CWM_GRP support in, but its days are now numbered.

while i'm here fixup an int/long mixup with an earlier diff.

ok okan@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.37 2009/12/11 17:51:42 oga Exp $
a52 3
	XChangeProperty(X_Dpy, cc->win, _CWM_GRP, XA_STRING,
	    8, PropModeReplace, shortcut_to_name[gc->shortcut],
	    strlen(shortcut_to_name[gc->shortcut]));
a67 3
	XChangeProperty(X_Dpy, cc->win, _CWM_GRP, XA_STRING, 8,
	    PropModeReplace, shortcut_to_name[0],
	    strlen(shortcut_to_name[0]));
d415 1
a415 1
	int			 no = -1, i;
a416 1
	unsigned char		*grpstr = NULL;
a428 8
	} else if (xu_getprop(cc, _CWM_GRP,  XA_STRING,
	    (CALMWM_MAXNAMELEN - 1)/sizeof(long), &grpstr) > 0) {
		for (i = 0; i < sizeof(shortcut_to_name) /
		    sizeof(shortcut_to_name[0]); i++) {
			if (strcmp(shortcut_to_name[i], grpstr) == 0)
				no = i;
		}
		XFree(grpstr);
@


1.37
log
@Implement _NET_DESKTOP_NAMES, this one was a bit tricky since thespec
says that a pager can change the property at any time (most need a
clientmessage). So deal with property updates.

Needed to shuffle some of the other code around since we can't just use
shortcut_to_name[] everywhere now.

ok okan@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.36 2009/12/10 23:21:26 oga Exp $
d30 1
a30 1
static void		 group_setactive(struct screen_ctx *, int);
d41 1
d45 2
d56 2
d66 2
d74 2
d139 3
a141 3
	int	 	 i;
	u_int32_t	 viewports[2] = {0, 0};
	u_int32_t	 ndesks = CALMWM_NGROUPS, zero = 0;
d200 1
a200 1
group_setactive(struct screen_ctx *sc, int idx)
d422 1
d427 10
a436 1
	if (xu_getprop(cc, _CWM_GRP,  XA_STRING,
@


1.36
log
@Implement _NET_VIRTUAL_ROOTS (just clear it, we don't use that technique)
and _NET_SHOWING_DESKTOP (we're never doing so right now).

only three informational root-window hints to go.

ok okan@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.35 2009/12/10 23:14:58 oga Exp $
d31 1
d51 2
a52 1
	    8, PropModeReplace, gc->name, strlen(gc->name));
d136 4
a144 1
		sc->groups[i].name = shortcut_to_name[sc->groups[i].shortcut];
d168 22
d364 1
a364 1
			    gc->shortcut, shortcut_to_name[gc->shortcut]);
d367 1
a367 1
			    gc->shortcut, shortcut_to_name[gc->shortcut]);
d412 1
a413 1
	char			 group[CALMWM_MAXNAMELEN];
d419 5
a423 1
		strlcpy(group, grpstr, sizeof(group));
d430 1
a430 1
				strlcpy(group, aw->group, sizeof(group));
d436 2
a437 1
	if (strncmp("nogroup", group, 7) == 0)
d441 1
a441 1
		if (strcmp(shortcut_to_name[gc->shortcut], group) == 0) {
d450 75
@


1.35
log
@Implement _NET_CURRENT_DESKTOP, _NET_DESKTOP_VIEWPORT and
_NET_DESKTOP_GEOMETRY.

ok okan@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.34 2009/12/10 17:16:51 oga Exp $
d129 2
a130 1
	u_int32_t	 viewports[2] = {0, 0}, ndesks = CALMWM_NGROUPS;
d148 12
@


1.34
log
@finish unfucking the screen_ctx handling.

remove screen_current() it was utterly bogus when nscreens > 1.

pass a fake client_ctx in the case where there's no client and the
kbfunc or mousefunc doesn't need a real one, it just contains the
current screen, modify these functions so that they pass down the screen
context to their callees.

make groups per screen, it's the only way it makes sense in this regard.

ok okan@@.
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.33 2009/12/07 23:19:51 oga Exp $
d30 1
d122 1
a122 1
	sc->group_active = gc;
d128 2
a129 1
	int	 i;
a132 1
	sc->group_active = NULL;
d142 14
a155 1
	sc->group_active = &sc->groups[0];
a226 1

d235 1
a235 1
			sc->group_active = gc;
d289 1
a289 1
		sc->group_active = showgroup;
@


1.33
log
@Implement _NET_NUMBER_OF_DESKTOPS, currently this is statically 9 and
unchangable. the group code needs some cleaning up before this will be a
bit less hackish.

ok okan@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.32 2009/06/20 00:55:42 okan Exp $
d27 2
a28 2
static void		 group_hide(struct group_ctx *);
static void		 group_show(struct group_ctx *);
a30 5
struct group_ctx	*Group_active = NULL;
struct group_ctx	 Groups[CALMWM_NGROUPS];
int			 Grouphideall = 0;
struct group_ctx_q	 Groupq;

d70 1
a70 1
group_hide(struct group_ctx *gc)
d74 1
a74 1
	screen_updatestackingorder();
d88 1
a88 1
group_show(struct group_ctx *gc)
d121 1
a121 1
	Group_active = gc;
d125 1
a125 1
group_init(void)
d129 3
a131 1
	TAILQ_INIT(&Groupq);
d134 5
a138 5
		TAILQ_INIT(&Groups[i].clients);
		Groups[i].hidden = 0;
		Groups[i].shortcut = i + 1;
		Groups[i].name = shortcut_to_name[Groups[i].shortcut];
		TAILQ_INSERT_TAIL(&Groupq, &Groups[i], entry);
d141 1
a141 1
	Group_active = &Groups[0];
d147 2
d152 1
a152 1
	if(Group_active != &Groups[idx])
d154 1
a154 1
	group_add(&Groups[idx], cc);
d163 1
d166 1
a166 1
	gc = Group_active;
d205 1
a205 1
group_hidetoggle(int idx)
d212 1
a212 1
	gc = &Groups[idx];
d217 1
a217 1
		group_show(gc);
d219 2
a220 1
		group_hide(gc);
d222 1
a222 1
			Group_active = gc;
d227 1
a227 1
group_only(int idx)
d236 1
a236 1
			group_show(&Groups[i]);
d238 1
a238 1
			group_hide(&Groups[i]);
d246 1
a246 1
group_cycle(int reverse)
d250 1
a250 1
	assert(Group_active != NULL);
d252 1
a252 1
	gc = Group_active;
d257 3
a259 3
			gc = reverse ? TAILQ_LAST(&Groupq, group_ctx_q) :
			    TAILQ_FIRST(&Groupq);
		if (gc == Group_active)
d265 1
a265 1
			group_hide(gc);
d271 1
a271 1
	group_hide(Group_active);
d274 1
a274 1
		group_show(showgroup);
d276 1
a276 1
		Group_active = showgroup;
d293 1
d299 1
d303 1
a303 1
		gc = &Groups[i];
d322 1
a322 1
	mi = menu_filter(&menuq, NULL, NULL, 0, NULL, NULL);
d329 1
a329 1
	(gc->hidden) ? group_show(gc) : group_hide(gc);
d339 1
a339 1
group_alltoggle(void)
d344 2
a345 2
		if (Grouphideall)
			group_show(&Groups[i]);
d347 1
a347 1
			group_hide(&Groups[i]);
d350 1
a350 1
	Grouphideall = (Grouphideall) ? 0 : 1;
d356 1
d382 1
a382 1
	TAILQ_FOREACH(gc, &Groupq, entry) {
d390 1
a390 1
		group_add(Group_active, cc);
@


1.32
log
@compact a bit by condensing a few if-else's; from Thomas Pfaff

"go on then" oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.31 2009/06/20 00:22:39 okan Exp $
a23 2

#define CALMWM_NGROUPS 9
@


1.31
log
@unroll XCALLOC/XMALLOC macros; since we use xcalloc/xmalloc all over the
place anyway, this makes things a bit more consistent; from Thomas Pfaff

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.30 2009/05/19 12:49:37 sthen Exp $
d328 1
a328 4
	if (gc->hidden)
		group_show(gc);
	else
		group_hide(gc);
d349 1
a349 4
	if (Grouphideall)
		Grouphideall = 0;
	else
		Grouphideall = 1;
@


1.30
log
@In movetogroup, check the window's current group and skip client_hide()
if it's the same as the active group. Was in my original movetogroup diff,
but it got simplified a little too far.  ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.29 2009/05/18 00:23:35 okan Exp $
d307 1
a307 1
		XCALLOC(mi, struct menu);
@


1.29
log
@nuke the leading underscore notation for local static functions - there
are far better ways to know.

"go for it" oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.28 2009/05/17 23:40:57 okan Exp $
d155 2
a156 1
	client_hide(cc);
@


1.28
log
@a long time coming - re-work the way we deal with colors: since we're
using Xft(3), use it to select the font color as well instead of trying
to build one; properly allocate and free colors at-will, e.g. we now
have configurable colors.

feedback and ok's todd@@ and oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.27 2009/05/17 23:37:52 okan Exp $
d27 5
a31 5
static void		 _group_add(struct group_ctx *, struct client_ctx *);
static void		 _group_remove(struct client_ctx *);
static void		 _group_hide(struct group_ctx *);
static void		 _group_show(struct group_ctx *);
static void		 _group_fix_hidden_state(struct group_ctx *);
d44 1
a44 1
_group_add(struct group_ctx *gc, struct client_ctx *cc)
d47 1
a47 1
		errx(1, "_group_add: a ctx is NULL");
d63 1
a63 1
_group_remove(struct client_ctx *cc)
d66 1
a66 1
		errx(1, "_group_remove: a ctx is NULL");
d77 1
a77 1
_group_hide(struct group_ctx *gc)
d95 1
a95 1
_group_show(struct group_ctx *gc)
d156 1
a156 1
	_group_add(&Groups[idx], cc);
d170 1
a170 1
		_group_remove(cc);
d173 1
a173 1
		_group_add(gc, cc);
d191 1
a191 1
_group_fix_hidden_state(struct group_ctx *gc)
d215 1
a215 1
	_group_fix_hidden_state(gc);
d218 1
a218 1
		_group_show(gc);
d220 1
a220 1
		_group_hide(gc);
d236 1
a236 1
			_group_show(&Groups[i]);
d238 1
a238 1
			_group_hide(&Groups[i]);
d265 1
a265 1
			_group_hide(gc);
d271 1
a271 1
	_group_hide(Group_active);
d274 1
a274 1
		_group_show(showgroup);
d328 1
a328 1
		_group_show(gc);
d330 1
a330 1
		_group_hide(gc);
d346 1
a346 1
			_group_show(&Groups[i]);
d348 1
a348 1
			_group_hide(&Groups[i]);
d387 1
a387 1
			_group_add(gc, cc);
d393 1
a393 1
		_group_add(Group_active, cc);
@


1.27
log
@minor bit of knf, just to be consistent; oga@@ doesn't mind that much
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.26 2009/05/17 22:48:47 okan Exp $
d171 1
a171 1
		cc->highlight = CLIENT_HIGHLIGHT_RED;
d174 1
a174 1
		cc->highlight = CLIENT_HIGHLIGHT_BLUE;
@


1.26
log
@unbreak
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.25 2009/05/17 17:04:59 sthen Exp $
d235 1
a235 1
		if (i == idx) {
d237 1
a237 1
		} else {
a238 1
		}
@


1.25
log
@add a "movetogroup" function, which hides the current window from
display and moves it to another group. useful with the recently added
"grouponly" function, giving the ability to use groups as simple
virtual desktops (similar to e.g. xmonad, dwm and scrotwm).

this doesn't have default keyboard bindings; cwmrc(5) now shows how
you could use these functions (use M-1...9 for grouponly1...9 and
MS-1...9 for movetogroup1...9 to emulate the default dwm bindings).

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.24 2009/05/14 16:24:04 oga Exp $
d146 1
@


1.24
log
@Add a new command (currently no default keybindings for it), grouponly[1-9].

This works like the group select binding, but hides all other groups.

So, the people who've been complaining that they don't get "virtual
desktops" in cwm may want to try this out in cwmrc (from memory, untested):

---

#cwmrc

# add new windows to the current group
set sticky

# automatically sticky windows. xclock for now.
# to make more windows sticky use group_toggle to unset their group
autogroup 0 xclock

# make the group selection keys hide other groups, emulate virtual desktops
bind CM-1 grouponly1
bind CM-2 grouponly2
bind CM-3 grouponly3
bind CM-4 grouponly4
bind CM-5 grouponly5
bind CM-6 grouponly6
bind CM-7 grouponly7
bind CM-8 grouponly8
bind CM-9 grouponly9

---

mostly by sthen, tweaks from me.

ok todd@@, "if it works i'm ok with it" okan@@, ok sthen@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.23 2009/01/27 00:42:53 oga Exp $
d146 10
a155 1
	Group_active = &Groups[0];
@


1.23
log
@One of the most annoying things to do was restart cwm and lose all of
your group state. Fix this up by using an X Atom (_CWM_GRP) to store the
name of the group that we're using (the name, not the number is because
at one point we may make the group numbers dynamic). I've been talking
about this since c2k8. so CM-w means you keep all of your windows grouped
properly.

ok okan@@, todd@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.22 2009/01/16 15:24:14 okan Exp $
d213 17
@


1.22
log
@remove pwin, bringing us to one client, one window.  we no longer have
to push attributes around, so things get a lot simplier, while fixing a
few issues in the meantime; original suggestion by Edd Barrett many many
moons ago.

annoying window placement and race, found in c2k8 by todd, fix by oga!

lots of feedback from todd and oga - thanks!

"commit that bad boy" oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.21 2009/01/15 00:32:35 okan Exp $
d55 3
d68 4
d142 1
d336 1
d341 12
a352 6

	TAILQ_FOREACH(aw, &Conf.autogroupq, entry) {
		if (strcmp(aw->class, cc->app_class) == 0 &&
		    (aw->name == NULL || strcmp(aw->name, cc->app_name) == 0)) {
			strlcpy(group, aw->group, sizeof(group));
			break;
@


1.21
log
@- add missing prototypes.
- properly name, place and static private functions.
- move function which finds the xinerama screen for a coordinate to
a more appropriate place while altering its semantics to match others.
- tiny bit of style.

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.20 2009/01/11 21:46:48 oga Exp $
d102 1
a102 1
		winlist[gc->highstack - cc->stackingorder] = cc->pwin;
@


1.20
log
@shortcut_to_name should not be defined as static in a header file. Put
it in group.c where it it used most, and add an extern definition for
the other users of it.

Found by gcc -Wall. ok okan@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.19 2008/07/18 15:40:52 oga Exp $
d27 6
d39 2
a40 2
        "nogroup", "one", "two", "three", "four", "five", "six",
        "seven", "eight", "nine"
d170 1
a170 1
 * selection list display
d172 1
a172 4

/* if group_hidetoggle would produce no effect, toggle the group's hidden state
 */
void
@


1.19
log
@Put back the initialisation of gc in group_cycle. No cookie for okan.


Reported by Dan Harnett, thanks!
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.18 2008/07/11 14:21:28 okan Exp $
d31 5
@


1.18
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.17 2008/05/21 14:11:19 oga Exp $
d210 1
@


1.17
log
@Make menu_filter handle mouse movement too. This enables the keyboard
search dialogues to be manipulated with the mouse, too. It also allows
me to shrink the codebase further by killing grab_menu().

One known issue with highlighting the first entry in a search dialogue,
that'll be fixed soonish.

ok okan@@, tested by Edd Barrett and todd@@.
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.16 2008/05/19 17:13:55 oga Exp $
d61 1
a61 1
	struct client_ctx *cc;
d79 4
a82 4
	struct client_ctx *cc;
	Window *winlist;
	u_int i;
	int lastempty = -1;
d116 1
a116 1
	int i;
d136 3
a138 1
	struct group_ctx *gc = Group_active;
d167 2
a168 2
	struct client_ctx *cc;
	int same = 0;
d182 1
a182 1
	struct group_ctx *gc;
d206 1
a206 1
	struct group_ctx *gc, *showgroup = NULL;
a209 1
	gc = Group_active;
d250 2
a252 1
	struct menu		*mi;
a253 1
	struct group_ctx	*gc;
d299 1
a299 1
	int i;
d317 3
a319 3
	struct autogroupwin *aw;
	struct group_ctx *gc;
	char group[CALMWM_MAXNAMELEN];
@


1.16
log
@allow an autogroup value of 0 to mean no group. This means you can set
automatically "sticky" (in the traditional sense of the word) windows in
autogroup mode.

Based on an initial diff from Andrew Fresh, thanks!

ok okan@@.
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.15 2008/05/19 17:11:19 okan Exp $
d276 1
a276 1
	mi = (struct menu *)grab_menu(e, &menuq);
@


1.15
log
@as done with cycle/rcycle, make prev/next group switching one kbfuncs
and use a flag; adjusted to match and rename to {r,}cycle.

"ok, since i came up with the same thing" oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.14 2008/05/18 20:00:16 okan Exp $
d330 3
@


1.14
log
@remove extra calls to client_draw_border()

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.13 2008/05/18 19:38:18 oga Exp $
a197 3
#define GROUP_NEXT(gc, fwd) (fwd) ?					\
	TAILQ_NEXT(gc, entry) : TAILQ_PREV(gc, group_ctx_q, entry)

d199 1
a199 2
 * Jump to the next/previous active group.  If none exist, then just
 * stay put.
d202 1
a202 1
group_slide(int fwd)
d210 2
a211 1
		gc = GROUP_NEXT(gc, fwd);
d213 2
a214 2
			gc = fwd ? TAILQ_FIRST(&Groupq) :
			    TAILQ_LAST(&Groupq, group_ctx_q);
@


1.13
log
@group_ctx->name is only used in this one function, and for now it
corresponds directly to the static list of group names. Just use the
static list and stop strdup()ing a new version for the context struct.
Since that never got freed this also fixes a small memleak.

Kill some unused variables while i'm here.

ok okan@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.11 2008/04/16 13:38:09 oga Exp $
a55 2
	cc->highlight = 0;
	client_draw_border(cc);
@


1.12
log
@KNF, no binary change.

From Pierre Riteau. Thanks!
@
text
@a26 1
int			 Groupnamemode = 0;
a28 1
char			 Group_name[256];
a266 3
		if (gc->name == NULL)
			gc->name = xstrdup(shortcut_to_name[gc->shortcut]);

d270 1
a270 1
			    gc->shortcut, gc->name);
d273 1
a273 1
			    gc->shortcut, gc->name);
@


1.11
log
@Replace a few leftover calls to strdup and calloc with xstrdup and xcalloc
respectively.

ok okan.
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.10 2008/04/16 13:35:37 oga Exp $
d275 1
a275 1
			     gc->shortcut, gc->name);
d278 1
a278 1
			     gc->shortcut, gc->name);
d298 1
a298 1
 cleanup:
@


1.10
log
@Remove screen_infomsg(), nothing uses it.

ok okan.
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.9 2008/04/15 20:24:41 oga Exp $
d88 1
a88 1
	winlist = (Window *) xcalloc(sizeof(*winlist) * (gc->highstack + 1));
@


1.9
log
@hit it with the knf stick.
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.8 2008/03/23 15:09:21 simon Exp $
a184 3
#ifdef notyet
	char buf[128];
#endif
a199 5

#ifdef notyet
	snprintf(buf, sizeof(buf), "Group %d", idx + 1);
	screen_infomsg(buf);
#endif
@


1.8
log
@Replace the symlink configuration scheme with a simple yacc parser as
found in other places of the tree.  Remove sticky and font commandline
options and add another one for alternative config locations.
Split off cwmrc(5) from cwm(1), nuke #ifdef __OpenBSD__ while there.

tested by various kind people, feedback from oga@@ and okan@@ - thanks!
ok oga@@, jasper@@, okan@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.7 2008/03/22 21:34:07 okan Exp $
d27 6
a32 6
int                 Groupnamemode = 0;
struct group_ctx   *Group_active = NULL;
struct group_ctx    Groups[CALMWM_NGROUPS];
char                Group_name[256];
int                 Grouphideall = 0;
struct group_ctx_q  Groupq;
d38 1
a38 1
	  	errx(1, "_group_add: a ctx is NULL");
d54 1
a54 1
	  	errx(1, "_group_remove: a ctx is NULL");
d65 1
a65 1
  	struct client_ctx *cc;
d120 1
a120 1
  	int i;
d161 1
a161 1
 * selection list display 
d169 1
a169 1
	struct client_ctx *cc;	
d255 1
a255 1
	  	return;
d264 4
a267 4
  	struct menu_q menuq;
	struct menu  *mi;
	int i;
	struct group_ctx *gc;
d283 1
a283 1
			   gc->shortcut, gc->name); 
d286 1
a286 1
			   gc->shortcut, gc->name); 
d318 1
a318 1
	for (i=0; i < CALMWM_NGROUPS; i++) {
d322 1
a322 1
		  	_group_hide(&Groups[i]);
@


1.7
log
@allow autogrouping and sticky mode to work together

ok oga@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.6 2008/03/22 15:09:45 oga Exp $
a32 6

static char *shortcut_to_name[] = {
	"XXX", "one", "two", "three",
	"four", "five", "six", "seven",
	"eight", "nine",
};
@


1.6
log
@Rip out, burn, and dance around the grave of group-edit mode.
I've yet to speak to anyone who uses it, so just kill it.

You can still add/remove from groups using the mouse binding.  Groups
may get a re-work sometime soon if i have a stroke of genius.

knocks about 4k off the i386 binary for me.

ok okan@@, todd@@.
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.5 2008/01/16 11:39:20 oga Exp $
a343 5
	if (Conf.flags & CONF_STICKY_GROUPS) {
		_group_add(Group_active, cc);
		return;
	}

d356 1
a356 1
		if (strcmp(shortcut_to_name[gc->shortcut], group) == 0)
d358 2
d361 3
@


1.5
log
@huge amount of cleanup and dead code removal.

full description of changes:
-remove fontlist, and all associated structures/calls, it's not needed.
 this also removes any doubt about leftover 9wm code (the list was
 borrowed from it). Since cwm now uses Xft for everything, the legacy
 font handling is just not needed.
-add /* FALLTHROUGH */ comments into grab_{label,menu}. I actually
 didn't intend grab_menu to be a fallthrough, but it actually works quite
 well there, so remove the extra rectangle drawing. I love it when that
 happens.
-remove a couple of unused prototypes that were obviously missed
 before.
-remove a bunch of commented out or if 0ed out code. It doesn't look to
 be coming back anytime soon.
-several functions returned an int, but this was never checked. most of
 them only failed if they failed to grab the pointer (thus the internal
 state didn't change), so just make them void and return early if this is
 the case.
-remove several unused functions and some useless variables.

knocks something like 200bytes off the stripped binary size for me.

ok marc@@, tested by several others.
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.4 2008/01/14 15:21:10 oga Exp $
a26 1
int                 Groupmode = 0;
a28 1
struct group_ctx   *Group_current = NULL;
a30 3
int                 Groupfocusset = 0;
Window              Groupfocuswin;
int                 Groupfocusrevert;
a33 2
#define GroupMask (KeyPressMask|ExposureMask)

a53 1
	cc->groupcommit = 0;
a63 1
	cc->groupcommit = 0;
a68 26
_group_commit(struct group_ctx *gc)
{
  	struct client_ctx *cc;

	if (gc == NULL)
		errx(1, "_group_commit: ctx is null");

	TAILQ_FOREACH(cc, &gc->clients, group_entry)
		cc->groupcommit = 1;
}

static void
_group_purge(struct group_ctx *gc)
{
	struct client_ctx *cc;

	if (gc == NULL)
		errx(1, "_group_purge: ctx is null");

	TAILQ_FOREACH(cc, &gc->clients, group_entry)
		if (cc->groupcommit == 0)
			_group_remove(cc);
}


static void
a122 21


static void
_group_destroy(struct group_ctx *gc)
{
	struct client_ctx *cc;

	if (gc->name != NULL) {
		xfree(gc->name);
		gc->name = NULL;
	}

	while ((cc = TAILQ_FIRST(&gc->clients)) != NULL) {
		TAILQ_REMOVE(&gc->clients, cc, group_entry);
		cc->group = NULL;
		cc->groupcommit = 0;
		cc->highlight = 0;
		client_draw_border(cc);
	}
}

d137 1
a137 1
	Group_current = Group_active = &Groups[0];
d140 2
a141 2
/* 
 * manipulate the 'current group'
a142 98

/* change the current group */
void
group_select(int idx)
{
	struct group_ctx *gc = Group_current;
	struct client_ctx *cc;

	if (idx < 0 || idx >= CALMWM_NGROUPS)
		return;

	TAILQ_FOREACH(cc, &gc->clients, group_entry) {
		cc->highlight = 0;
		client_draw_border(cc);
	}

	_group_commit(gc);
	Group_current = &Groups[idx];

	group_display_draw(screen_current());
	return;
}

/* enter group mode */
void
group_enter(void)
{
  	if (Groupmode != 0)
		errx(1, "group_enter called twice");

	if (Group_current == NULL)
		Group_current = &Groups[0];

	/* setup input buffer */
	Group_name[0] = '\0';

  	Groupmode = 1;

	group_display_init(screen_current());
	group_display_draw(screen_current());
}

/* exit group mode */
void
group_exit(int commit)
{
	struct group_ctx *gc = Group_current;
	struct client_ctx *cc;

  	if (Groupmode != 1)
		errx(1, "group_exit called twice");

	TAILQ_FOREACH(cc, &gc->clients, group_entry) {
		cc->highlight = 0;
		client_draw_border(cc);
	}

	if (commit) {
		_group_commit(gc);
	} else {
	  	/* abort */
	  	_group_purge(gc);
		if (!TAILQ_EMPTY(&gc->clients))
	  		_group_destroy(gc);
	}

	XUnmapWindow(X_Dpy, screen_current()->groupwin);

	if (Groupnamemode) {
		XSetInputFocus(X_Dpy, Groupfocuswin, Groupfocusrevert,
		    CurrentTime);
		Groupfocusset = 0;
	}

  	Groupmode = Groupnamemode = 0;
}

void
group_click(struct client_ctx *cc)
{
	struct group_ctx *gc = Group_current;

	if (gc == cc->group)
		_group_remove(cc);
	else 
		_group_add(gc, cc);
	group_display_draw(screen_current());
}


/* Used to add a newly mapped window to the active group */

void
group_sticky(struct client_ctx *cc)
{
	_group_add(Group_active, cc);
}

a169 79
void
group_display_init(struct screen_ctx *sc)
{
	sc->groupwin = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0,
	    1, 1, 1, sc->blackpixl, sc->whitepixl);
}

void
group_display_draw(struct screen_ctx *sc)
{
	struct group_ctx *gc = Group_current;
	int x, y, dx, dy, fontheight;
	struct client_ctx *cc;
	char titlebuf[1024];
	struct fontdesc *font = DefaultFont;

	snprintf(titlebuf, sizeof(titlebuf), "Editing group %d", gc->shortcut);

	x = y = 0;

	fontheight = font_ascent(font) + font_descent(font) + 1;
	dx = font_width(font, titlebuf, strlen(titlebuf));
	dy = fontheight;

	TAILQ_FOREACH(cc, &gc->clients, group_entry) {
		cc->highlight = CLIENT_HIGHLIGHT_BLUE;
		client_draw_border(cc);
	}

	XMoveResizeWindow(X_Dpy, sc->groupwin, x, y, dx, dy);

	/* XXX */
	XSelectInput(X_Dpy, sc->groupwin, GroupMask);

	XMapRaised(X_Dpy, sc->groupwin);
	XClearWindow(X_Dpy, sc->groupwin);
	font_draw(font, titlebuf, strlen(titlebuf), sc->groupwin,
	    0, font_ascent(font) + 1);
}

void 
group_display_keypress(KeyCode k)
{
	struct group_ctx * gc = Group_current;
	char chr;
	enum ctltype ctl;
	int len;

	if (!Groupnamemode)
		return;

	if (input_keycodetrans(k, 0, &ctl, &chr, 1) < 0)
		goto out;

	switch (ctl) {
	case CTL_ERASEONE:
	  	if ((len = strlen(Group_name)) > 0)
			Group_name[len - 1] = '\0';
		break;
	case CTL_RETURN:
		if (gc->name != NULL)
			xfree(gc->name);

		gc->name = xstrdup(Group_name);

		group_exit(1);
		return;
	default:
		break;
	}

	if (chr != '\0')
		snprintf(Group_name, sizeof(Group_name), "%s%c", 
		    Group_name, chr);

out:
	group_display_draw(screen_current());
}

a264 1
	cc->groupcommit = 0;
a319 8
group_namemode(void)
{
	Groupnamemode = 1;

	group_display_draw(screen_current());
}

void
a337 22
group_deletecurrent(void)
{
	_group_destroy(Group_current);
	XUnmapWindow(X_Dpy, screen_current()->groupwin);

  	Groupmode = Groupnamemode = 0;
}

void
group_done(void)
{
	struct group_ctx *gc = Group_current;

	if (gc->name != NULL)
		xfree(gc->name);

	gc->name = xstrdup(shortcut_to_name[gc->shortcut]);

	group_exit(1);
}

void
d343 5
@


1.4
log
@Rewrite most of grab_menu in grab.c (it was partly 9wm code).
This should work functionally the same, with a few simplifications.

Changes:
- we don't care if you're holding another button when you release the
  menu key if you don't want to select anything, move off the menu.
- remove the hysteresis from the menu selection (before you had to move
  more than three pixels onto a new menu entry before it selected it)
- simplify a lot of the selection code
- kill dead code.
- do what the XXX comment said and cache the screensize (i may tweak
  this later).

As far as I can tell, the only code remaining from 9wm is the list of
fonts in calmwm.c. Others appear to concur.

ok marc@@, looked over and tested by a few others. Reminders from okan@@.
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.3 2008/01/11 16:06:44 oga Exp $
a199 21
#if 0
/* set current group to the first empty group
 * returns 0 on success, -1 if there are no empty groups
 */
int
group_new(void)
{
  	int i;

	for (i=0; i < CALMWM_NGROUPS; i++) {
		if (TAILQ_EMPTY(&Groups[i].clients)) {
			Group_current = &Groups[i];			

			return (0);
		}
	}

	return (-1);
}
#endif

d201 1
a201 1
int
d208 1
a208 1
		return (-1);
d219 1
a219 1
	return (0);
d335 1
a335 1
	int x, y, dx, dy, fontheight, titlelen;
d345 1
a345 1
	dx = titlelen = font_width(font, titlebuf, strlen(titlebuf));
@


1.3
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d19 1
a19 1
 * $Id: group.c,v 1.2 2007/05/28 18:34:27 jasper Exp $
d95 1
a95 1
		errx(1, "_group_commit: ctx is null");
@


1.2
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@a5 1
 * All rights reserved.
d7 13
a19 1
 * $Id: group.c,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
 * $Id: group.c,v 1.21 2005/08/28 09:36:45 marius Exp $
d16 11
a26 11
int                 G_groupmode = 0;
int                 G_groupnamemode = 0;
struct group_ctx   *G_group_active = NULL;
struct group_ctx   *G_group_current = NULL;
struct group_ctx    G_groups[CALMWM_NGROUPS];
char                G_group_name[256];
int                 G_groupfocusset = 0;
Window              G_groupfocuswin;
int                 G_groupfocusrevert;
int                 G_grouphideall = 0;
struct group_ctx_q  G_groupq;
d140 1
a140 1
	XRestackWindows(G_dpy, winlist, gc->nhidden);
d144 1
a144 1
	G_group_active = gc;
d173 1
a173 1
	TAILQ_INIT(&G_groupq);
d176 4
a179 4
		TAILQ_INIT(&G_groups[i].clients);
		G_groups[i].hidden = 0;
		G_groups[i].shortcut = i + 1;
		TAILQ_INSERT_TAIL(&G_groupq, &G_groups[i], entry);
d182 1
a182 1
	G_group_current = G_group_active = &G_groups[0];
d199 2
a200 2
		if (TAILQ_EMPTY(&G_groups[i].clients)) {
			G_group_current = &G_groups[i];			
d214 1
a214 1
	struct group_ctx *gc = G_group_current;
d226 1
a226 1
	G_group_current = &G_groups[idx];
d236 1
a236 1
  	if (G_groupmode != 0)
d239 2
a240 2
	if (G_group_current == NULL)
		G_group_current = &G_groups[0];
d243 1
a243 1
	G_group_name[0] = '\0';
d245 1
a245 1
  	G_groupmode = 1;
d255 1
a255 1
	struct group_ctx *gc = G_group_current;
d258 1
a258 1
  	if (G_groupmode != 1)
d275 1
a275 1
	XUnmapWindow(G_dpy, screen_current()->groupwin);
d277 2
a278 2
	if (G_groupnamemode) {
		XSetInputFocus(G_dpy, G_groupfocuswin, G_groupfocusrevert,
d280 1
a280 1
		G_groupfocusset = 0;
d283 1
a283 1
  	G_groupmode = G_groupnamemode = 0;
d289 1
a289 1
	struct group_ctx *gc = G_group_current;
d304 1
a304 1
	_group_add(G_group_active, cc);
d310 1
a310 1
	struct group_ctx *gc = G_group_active;
d337 1
a337 1
	sc->groupwin = XCreateSimpleWindow(G_dpy, sc->rootwin, 0, 0,
d344 1
a344 1
	struct group_ctx *gc = G_group_current;
d363 1
a363 1
	XMoveResizeWindow(G_dpy, sc->groupwin, x, y, dx, dy);
d366 1
a366 1
	XSelectInput(G_dpy, sc->groupwin, GroupMask);
d368 2
a369 2
	XMapRaised(G_dpy, sc->groupwin);
	XClearWindow(G_dpy, sc->groupwin);
d377 1
a377 1
	struct group_ctx * gc = G_group_current;
d382 1
a382 1
	if (!G_groupnamemode)
d390 2
a391 2
	  	if ((len = strlen(G_group_name)) > 0)
			G_group_name[len - 1] = '\0';
d397 1
a397 1
		gc->name = xstrdup(G_group_name);
d406 2
a407 2
		snprintf(G_group_name, sizeof(G_group_name), "%s%c", 
		    G_group_name, chr);
d441 1
a441 1
	gc = &G_groups[idx];
d450 1
a450 1
			G_group_active = gc;
d471 1
a471 1
	assert(G_group_active != NULL);
d473 1
a473 1
	gc = G_group_active;
d477 3
a479 3
			gc = fwd ? TAILQ_FIRST(&G_groupq) :
			    TAILQ_LAST(&G_groupq, group_ctx_q);
		if (gc == G_group_active)
d491 1
a491 1
	_group_hide(G_group_active);
d496 1
a496 1
		G_group_active = showgroup;
d522 1
a522 1
		gc = &G_groups[i];
d566 1
a566 1
	G_groupnamemode = 1;
d577 2
a578 2
		if (G_grouphideall)
			_group_show(&G_groups[i]);
d580 1
a580 1
		  	_group_hide(&G_groups[i]);
d583 2
a584 2
	if (G_grouphideall)
		G_grouphideall = 0;
d586 1
a586 1
		G_grouphideall = 1;
d592 2
a593 2
	_group_destroy(G_group_current);
	XUnmapWindow(G_dpy, screen_current()->groupwin);
d595 1
a595 1
  	G_groupmode = G_groupnamemode = 0;
d601 1
a601 1
	struct group_ctx *gc = G_group_current;
d621 1
a621 1
	TAILQ_FOREACH(aw, &G_conf.autogroupq, entry) {
d629 1
a629 1
	TAILQ_FOREACH(gc, &G_groupq, entry) {
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
