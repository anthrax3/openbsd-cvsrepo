head	1.336;
access;
symbols
	OPENBSD_6_0:1.311.0.4
	OPENBSD_6_0_BASE:1.311
	OPENBSD_5_9:1.311.0.2
	OPENBSD_5_9_BASE:1.311
	OPENBSD_5_8:1.297.0.2
	OPENBSD_5_8_BASE:1.297
	OPENBSD_5_7:1.284.0.2
	OPENBSD_5_7_BASE:1.284
	OPENBSD_5_6:1.259.0.4
	OPENBSD_5_6_BASE:1.259
	OPENBSD_5_5:1.259.0.2
	OPENBSD_5_5_BASE:1.259
	OPENBSD_5_4:1.220.0.2
	OPENBSD_5_4_BASE:1.220
	OPENBSD_5_3:1.186.0.2
	OPENBSD_5_3_BASE:1.186
	OPENBSD_5_2:1.152.0.2
	OPENBSD_5_2_BASE:1.152
	OPENBSD_5_1_BASE:1.142
	OPENBSD_5_1:1.142.0.2
	OPENBSD_5_0:1.135.0.2
	OPENBSD_5_0_BASE:1.135
	OPENBSD_4_9:1.118.0.2
	OPENBSD_4_9_BASE:1.118
	OPENBSD_4_8:1.118.0.4
	OPENBSD_4_8_BASE:1.118
	OPENBSD_4_7:1.116.0.2
	OPENBSD_4_7_BASE:1.116
	OPENBSD_4_6:1.94.0.2
	OPENBSD_4_6_BASE:1.94
	OPENBSD_4_5:1.83.0.2
	OPENBSD_4_5_BASE:1.83
	OPENBSD_4_4:1.65.0.2
	OPENBSD_4_4_BASE:1.65
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.336
date	2016.12.06.21.54.10;	author okan;	state Exp;
branches;
next	1.335;
commitid	GTK8UjM1rfae1rvk;

1.335
date	2016.12.01.20.28.19;	author okan;	state Exp;
branches;
next	1.334;
commitid	BV26iM1x8TsKqz4Z;

1.334
date	2016.12.01.18.17.52;	author okan;	state Exp;
branches;
next	1.333;
commitid	xRY1Peh5GoP8Vw8q;

1.333
date	2016.11.15.00.22.02;	author okan;	state Exp;
branches;
next	1.332;
commitid	OqYiQl9bHme9at14;

1.332
date	2016.11.15.00.07.03;	author okan;	state Exp;
branches;
next	1.331;
commitid	PYr7HT01LVQhfDh6;

1.331
date	2016.11.14.21.25.59;	author okan;	state Exp;
branches;
next	1.330;
commitid	vHOoPGxkcPiAilEG;

1.330
date	2016.10.24.17.16.23;	author okan;	state Exp;
branches;
next	1.329;
commitid	0zKwnarjAIoRvHGf;

1.329
date	2016.10.18.17.03.30;	author okan;	state Exp;
branches;
next	1.328;
commitid	dIOrHVlb55Ubzrpl;

1.328
date	2016.10.12.16.11.15;	author okan;	state Exp;
branches;
next	1.327;
commitid	95dUURHBCrn43jS3;

1.327
date	2016.10.06.14.53.52;	author okan;	state Exp;
branches;
next	1.326;
commitid	bbvW6xIykd8xNbAy;

1.326
date	2016.10.06.14.41.19;	author okan;	state Exp;
branches;
next	1.325;
commitid	dEdTnOYrabSl1oRa;

1.325
date	2016.10.05.13.10.59;	author okan;	state Exp;
branches;
next	1.324;
commitid	LHP16HwBOYF7jUIx;

1.324
date	2016.10.04.20.15.55;	author okan;	state Exp;
branches;
next	1.323;
commitid	vRGk95BhViXMArN6;

1.323
date	2016.10.04.15.52.32;	author okan;	state Exp;
branches;
next	1.322;
commitid	YwD6cS669TAwbf4b;

1.322
date	2016.10.04.15.18.20;	author okan;	state Exp;
branches;
next	1.321;
commitid	A3zvKURgft7ltYQX;

1.321
date	2016.10.03.18.43.49;	author okan;	state Exp;
branches;
next	1.320;
commitid	5hMp5cE2gxBlRBhs;

1.320
date	2016.10.03.14.42.34;	author okan;	state Exp;
branches;
next	1.319;
commitid	sciYi1tUXUIu4s4n;

1.319
date	2016.09.30.21.44.51;	author okan;	state Exp;
branches;
next	1.318;
commitid	trgph9ZcD5GXrAml;

1.318
date	2016.09.30.18.28.06;	author okan;	state Exp;
branches;
next	1.317;
commitid	STecP6DPl2bavnIv;

1.317
date	2016.09.30.15.12.19;	author okan;	state Exp;
branches;
next	1.316;
commitid	uC9f6GlGiQkjBS9C;

1.316
date	2016.09.29.00.21.55;	author okan;	state Exp;
branches;
next	1.315;
commitid	T0a7tiQalU2SO4pS;

1.315
date	2016.09.28.17.06.33;	author okan;	state Exp;
branches;
next	1.314;
commitid	UDBUlJ5kvU8CcYZj;

1.314
date	2016.09.22.14.36.03;	author okan;	state Exp;
branches;
next	1.313;
commitid	ITo2h4srkSgvGLD0;

1.313
date	2016.09.20.19.11.19;	author okan;	state Exp;
branches;
next	1.312;
commitid	rpX3LIVTde3xQU35;

1.312
date	2016.09.16.14.32.02;	author okan;	state Exp;
branches;
next	1.311;
commitid	JzYS0uWdEYDeM0Hk;

1.311
date	2015.11.12.21.28.03;	author okan;	state Exp;
branches;
next	1.310;
commitid	Hq4BZzA3Nlni69Xf;

1.310
date	2015.11.12.18.26.41;	author okan;	state Exp;
branches;
next	1.309;
commitid	6VVx4mZhWgIPlBck;

1.309
date	2015.11.11.14.22.01;	author okan;	state Exp;
branches;
next	1.308;
commitid	t4AzuTxPlqQ6EzqO;

1.308
date	2015.11.10.20.05.33;	author okan;	state Exp;
branches;
next	1.307;
commitid	vKzF5zXTpUgY9uJK;

1.307
date	2015.11.09.20.15.23;	author okan;	state Exp;
branches;
next	1.306;
commitid	XM39tffBFp4Wx9Ot;

1.306
date	2015.11.09.20.03.29;	author okan;	state Exp;
branches;
next	1.305;
commitid	9uKgpfLzKiBWmiSm;

1.305
date	2015.09.16.17.58.25;	author okan;	state Exp;
branches;
next	1.304;
commitid	5LZITTZspXcfHMXf;

1.304
date	2015.08.27.18.53.14;	author okan;	state Exp;
branches;
next	1.303;
commitid	zidCZkwdtbi68xMi;

1.303
date	2015.08.25.18.29.10;	author okan;	state Exp;
branches;
next	1.302;
commitid	uqkKibG5fLGc4c6r;

1.302
date	2015.08.24.15.42.57;	author okan;	state Exp;
branches;
next	1.301;
commitid	xGzIdCzrHkoqADxN;

1.301
date	2015.08.24.14.56.10;	author okan;	state Exp;
branches;
next	1.300;
commitid	3heeYolWUzcrSGXI;

1.300
date	2015.08.21.16.53.48;	author okan;	state Exp;
branches;
next	1.299;
commitid	q7ZM17yPocKxOPyi;

1.299
date	2015.08.21.16.52.37;	author okan;	state Exp;
branches;
next	1.298;
commitid	dg8NUwKKSZKDgRDL;

1.298
date	2015.08.21.16.30.02;	author okan;	state Exp;
branches;
next	1.297;
commitid	MiLmJumEJ6sclldP;

1.297
date	2015.07.12.14.31.47;	author okan;	state Exp;
branches;
next	1.296;
commitid	vbdA9GL2PIvC62Ws;

1.296
date	2015.06.30.18.54.12;	author okan;	state Exp;
branches;
next	1.295;
commitid	BFKdrINXu4OZsfXB;

1.295
date	2015.06.26.17.17.46;	author okan;	state Exp;
branches;
next	1.294;
commitid	lHlj3PDNu98waqIr;

1.294
date	2015.06.26.16.11.21;	author okan;	state Exp;
branches;
next	1.293;
commitid	Drua5igvHL1eg9QS;

1.293
date	2015.06.26.15.21.58;	author okan;	state Exp;
branches;
next	1.292;
commitid	TlmnEeM7r3xmmliS;

1.292
date	2015.06.09.13.02.15;	author okan;	state Exp;
branches;
next	1.291;
commitid	FKj6uNbIaKosvjPs;

1.291
date	2015.06.08.15.11.29;	author okan;	state Exp;
branches;
next	1.290;
commitid	ZvSEr0vP6GhJmETT;

1.290
date	2015.06.05.15.01.51;	author okan;	state Exp;
branches;
next	1.289;
commitid	zeddTrrTnPr6FqHq;

1.289
date	2015.05.21.00.37.04;	author okan;	state Exp;
branches;
next	1.288;
commitid	8wlAl4DgmYSCpXux;

1.288
date	2015.05.20.23.54.39;	author okan;	state Exp;
branches;
next	1.287;
commitid	OLy4wiKj7HhFaejM;

1.287
date	2015.05.17.04.34.01;	author kspillner;	state Exp;
branches;
next	1.286;
commitid	vOYrUv5aGh2lx3AQ;

1.286
date	2015.03.28.23.12.47;	author okan;	state Exp;
branches;
next	1.285;
commitid	nwNT3PjeOYm65gQ8;

1.285
date	2015.03.26.21.41.43;	author okan;	state Exp;
branches;
next	1.284;
commitid	4dplVPN42tl2nHll;

1.284
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.283;
commitid	kLADTGYX3gw0Sf2m;

1.283
date	2014.10.08.12.48.51;	author okan;	state Exp;
branches;
next	1.282;
commitid	bx3Cy9JxKYTynRL9;

1.282
date	2014.09.27.19.04.32;	author okan;	state Exp;
branches;
next	1.281;
commitid	X6SwRTs6gMlrxQ8N;

1.281
date	2014.09.23.14.25.08;	author okan;	state Exp;
branches;
next	1.280;
commitid	rp7vMsjSPRy6s8TJ;

1.280
date	2014.09.23.13.45.48;	author okan;	state Exp;
branches;
next	1.279;
commitid	3MLwoEk2vcFsHNle;

1.279
date	2014.09.17.18.41.44;	author okan;	state Exp;
branches;
next	1.278;
commitid	7QDlXoO0YzmTdgVS;

1.278
date	2014.09.17.16.32.53;	author okan;	state Exp;
branches;
next	1.277;
commitid	VoKzpesV33vUCQZ7;

1.277
date	2014.09.17.16.00.44;	author okan;	state Exp;
branches;
next	1.276;
commitid	PwtpIdl7nXCakavw;

1.276
date	2014.09.17.14.31.37;	author okan;	state Exp;
branches;
next	1.275;
commitid	PntP0xZYNorE93in;

1.275
date	2014.09.10.20.30.38;	author okan;	state Exp;
branches;
next	1.274;
commitid	HyfJQMRwfxSnHKow;

1.274
date	2014.09.08.21.15.14;	author okan;	state Exp;
branches;
next	1.273;
commitid	os8IEZxNKyVrOZR1;

1.273
date	2014.09.08.20.11.22;	author okan;	state Exp;
branches;
next	1.272;
commitid	cu11ybsl8atTMRXD;

1.272
date	2014.09.08.13.51.29;	author okan;	state Exp;
branches;
next	1.271;
commitid	OmIn9iExEjTH79st;

1.271
date	2014.09.07.20.57.26;	author okan;	state Exp;
branches;
next	1.270;
commitid	Fdk72uq6A4nstPUM;

1.270
date	2014.09.07.17.38.38;	author okan;	state Exp;
branches;
next	1.269;
commitid	idgYRjbgDXLP4UK7;

1.269
date	2014.09.07.17.27.20;	author okan;	state Exp;
branches;
next	1.268;
commitid	gXhDmsdKh2raktuB;

1.268
date	2014.09.06.16.14.35;	author okan;	state Exp;
branches;
next	1.267;
commitid	SwO1sBFRHuUKBTtD;

1.267
date	2014.09.06.16.08.58;	author okan;	state Exp;
branches;
next	1.266;
commitid	hqjCXxcyI22RFKvg;

1.266
date	2014.09.01.18.04.58;	author okan;	state Exp;
branches;
next	1.265;
commitid	X0CjpcmJsClz2NwK;

1.265
date	2014.08.25.14.31.22;	author okan;	state Exp;
branches;
next	1.264;
commitid	IBKKLiHu5PwQFfcG;

1.264
date	2014.08.25.12.49.19;	author okan;	state Exp;
branches;
next	1.263;
commitid	rbGNqfikQcQWLop3;

1.263
date	2014.08.24.15.37.45;	author okan;	state Exp;
branches;
next	1.262;
commitid	0998haeGdCsc6F3q;

1.262
date	2014.08.20.15.15.29;	author okan;	state Exp;
branches;
next	1.261;
commitid	SsDu0AngUZExtrz4;

1.261
date	2014.08.19.12.47.51;	author okan;	state Exp;
branches;
next	1.260;
commitid	v4kkJCmpqLHUwcTv;

1.260
date	2014.08.18.13.57.57;	author okan;	state Exp;
branches;
next	1.259;
commitid	xw8U6yGIv8HLFURK;

1.259
date	2014.02.08.02.49.30;	author okan;	state Exp;
branches;
next	1.258;

1.258
date	2014.02.03.21.07.47;	author okan;	state Exp;
branches;
next	1.257;

1.257
date	2014.02.03.20.20.39;	author okan;	state Exp;
branches;
next	1.256;

1.256
date	2014.02.02.16.29.04;	author okan;	state Exp;
branches;
next	1.255;

1.255
date	2014.02.02.15.46.05;	author okan;	state Exp;
branches;
next	1.254;

1.254
date	2014.01.30.22.17.22;	author okan;	state Exp;
branches;
next	1.253;

1.253
date	2014.01.30.15.41.11;	author okan;	state Exp;
branches;
next	1.252;

1.252
date	2014.01.30.14.40.21;	author okan;	state Exp;
branches;
next	1.251;

1.251
date	2014.01.29.22.30.00;	author okan;	state Exp;
branches;
next	1.250;

1.250
date	2014.01.29.21.13.52;	author okan;	state Exp;
branches;
next	1.249;

1.249
date	2014.01.29.18.34.22;	author okan;	state Exp;
branches;
next	1.248;

1.248
date	2014.01.28.20.22.21;	author okan;	state Exp;
branches;
next	1.247;

1.247
date	2014.01.22.21.48.27;	author okan;	state Exp;
branches;
next	1.246;

1.246
date	2014.01.21.15.42.44;	author okan;	state Exp;
branches;
next	1.245;

1.245
date	2014.01.20.23.03.51;	author okan;	state Exp;
branches;
next	1.244;

1.244
date	2014.01.20.22.31.53;	author okan;	state Exp;
branches;
next	1.243;

1.243
date	2014.01.20.21.34.32;	author okan;	state Exp;
branches;
next	1.242;

1.242
date	2014.01.20.19.06.04;	author okan;	state Exp;
branches;
next	1.241;

1.241
date	2014.01.20.18.58.03;	author okan;	state Exp;
branches;
next	1.240;

1.240
date	2014.01.03.15.29.06;	author okan;	state Exp;
branches;
next	1.239;

1.239
date	2014.01.02.21.30.20;	author okan;	state Exp;
branches;
next	1.238;

1.238
date	2014.01.02.21.17.23;	author okan;	state Exp;
branches;
next	1.237;

1.237
date	2013.12.16.19.02.17;	author okan;	state Exp;
branches;
next	1.236;

1.236
date	2013.12.13.22.39.13;	author okan;	state Exp;
branches;
next	1.235;

1.235
date	2013.12.13.14.40.52;	author okan;	state Exp;
branches;
next	1.234;

1.234
date	2013.12.12.20.15.07;	author okan;	state Exp;
branches;
next	1.233;

1.233
date	2013.12.11.15.41.11;	author okan;	state Exp;
branches;
next	1.232;

1.232
date	2013.12.11.14.16.09;	author okan;	state Exp;
branches;
next	1.231;

1.231
date	2013.12.11.14.09.21;	author okan;	state Exp;
branches;
next	1.230;

1.230
date	2013.11.27.18.34.34;	author okan;	state Exp;
branches;
next	1.229;

1.229
date	2013.11.27.00.01.23;	author okan;	state Exp;
branches;
next	1.228;

1.228
date	2013.11.12.21.25.00;	author okan;	state Exp;
branches;
next	1.227;

1.227
date	2013.11.08.17.35.12;	author okan;	state Exp;
branches;
next	1.226;

1.226
date	2013.11.02.19.13.56;	author okan;	state Exp;
branches;
next	1.225;

1.225
date	2013.11.01.14.07.19;	author okan;	state Exp;
branches;
next	1.224;

1.224
date	2013.10.25.19.46.16;	author okan;	state Exp;
branches;
next	1.223;

1.223
date	2013.10.20.01.55.32;	author okan;	state Exp;
branches;
next	1.222;

1.222
date	2013.10.19.19.39.34;	author okan;	state Exp;
branches;
next	1.221;

1.221
date	2013.10.03.13.51.57;	author okan;	state Exp;
branches;
next	1.220;

1.220
date	2013.07.16.14.04.44;	author okan;	state Exp;
branches;
next	1.219;

1.219
date	2013.07.15.23.53.19;	author okan;	state Exp;
branches;
next	1.218;

1.218
date	2013.07.15.14.50.44;	author okan;	state Exp;
branches;
next	1.217;

1.217
date	2013.07.09.01.24.49;	author okan;	state Exp;
branches;
next	1.216;

1.216
date	2013.07.08.18.39.20;	author okan;	state Exp;
branches;
next	1.215;

1.215
date	2013.07.08.18.19.22;	author okan;	state Exp;
branches;
next	1.214;

1.214
date	2013.07.08.16.32.51;	author okan;	state Exp;
branches;
next	1.213;

1.213
date	2013.06.17.17.11.10;	author okan;	state Exp;
branches;
next	1.212;

1.212
date	2013.06.10.21.37.30;	author okan;	state Exp;
branches;
next	1.211;

1.211
date	2013.05.27.23.20.45;	author okan;	state Exp;
branches;
next	1.210;

1.210
date	2013.05.23.16.52.39;	author okan;	state Exp;
branches;
next	1.209;

1.209
date	2013.05.22.16.32.15;	author okan;	state Exp;
branches;
next	1.208;

1.208
date	2013.05.21.00.29.20;	author okan;	state Exp;
branches;
next	1.207;

1.207
date	2013.05.20.21.13.58;	author okan;	state Exp;
branches;
next	1.206;

1.206
date	2013.05.20.20.21.04;	author okan;	state Exp;
branches;
next	1.205;

1.205
date	2013.05.19.23.38.21;	author okan;	state Exp;
branches;
next	1.204;

1.204
date	2013.05.19.23.16.29;	author okan;	state Exp;
branches;
next	1.203;

1.203
date	2013.05.19.23.09.59;	author okan;	state Exp;
branches;
next	1.202;

1.202
date	2013.05.19.17.05.52;	author okan;	state Exp;
branches;
next	1.201;

1.201
date	2013.05.19.17.03.55;	author okan;	state Exp;
branches;
next	1.200;

1.200
date	2013.05.19.17.02.04;	author okan;	state Exp;
branches;
next	1.199;

1.199
date	2013.05.14.12.35.56;	author okan;	state Exp;
branches;
next	1.198;

1.198
date	2013.05.11.22.01.07;	author okan;	state Exp;
branches;
next	1.197;

1.197
date	2013.05.11.21.46.27;	author okan;	state Exp;
branches;
next	1.196;

1.196
date	2013.05.10.16.32.47;	author okan;	state Exp;
branches;
next	1.195;

1.195
date	2013.05.10.15.44.43;	author okan;	state Exp;
branches;
next	1.194;

1.194
date	2013.05.06.16.03.11;	author okan;	state Exp;
branches;
next	1.193;

1.193
date	2013.05.02.17.25.15;	author okan;	state Exp;
branches;
next	1.192;

1.192
date	2013.04.29.00.56.47;	author okan;	state Exp;
branches;
next	1.191;

1.191
date	2013.04.17.13.57.06;	author okan;	state Exp;
branches;
next	1.190;

1.190
date	2013.04.17.13.52.20;	author okan;	state Exp;
branches;
next	1.189;

1.189
date	2013.04.17.13.30.38;	author okan;	state Exp;
branches;
next	1.188;

1.188
date	2013.04.14.16.13.17;	author okan;	state Exp;
branches;
next	1.187;

1.187
date	2013.04.12.14.46.30;	author okan;	state Exp;
branches;
next	1.186;

1.186
date	2013.01.08.15.16.04;	author okan;	state Exp;
branches;
next	1.185;

1.185
date	2013.01.04.16.30.03;	author okan;	state Exp;
branches;
next	1.184;

1.184
date	2013.01.04.16.27.58;	author okan;	state Exp;
branches;
next	1.183;

1.183
date	2013.01.04.16.23.04;	author okan;	state Exp;
branches;
next	1.182;

1.182
date	2013.01.02.16.26.34;	author okan;	state Exp;
branches;
next	1.181;

1.181
date	2013.01.01.14.33.52;	author okan;	state Exp;
branches;
next	1.180;

1.180
date	2013.01.01.14.19.56;	author okan;	state Exp;
branches;
next	1.179;

1.179
date	2012.12.19.15.21.34;	author okan;	state Exp;
branches;
next	1.178;

1.178
date	2012.12.18.18.39.55;	author okan;	state Exp;
branches;
next	1.177;

1.177
date	2012.12.18.18.35.36;	author okan;	state Exp;
branches;
next	1.176;

1.176
date	2012.12.18.17.44.18;	author okan;	state Exp;
branches;
next	1.175;

1.175
date	2012.12.18.17.37.39;	author okan;	state Exp;
branches;
next	1.174;

1.174
date	2012.12.18.00.14.41;	author okan;	state Exp;
branches;
next	1.173;

1.173
date	2012.12.17.23.54.57;	author okan;	state Exp;
branches;
next	1.172;

1.172
date	2012.12.17.23.03.41;	author okan;	state Exp;
branches;
next	1.171;

1.171
date	2012.12.17.18.35.26;	author okan;	state Exp;
branches;
next	1.170;

1.170
date	2012.12.17.18.34.06;	author okan;	state Exp;
branches;
next	1.169;

1.169
date	2012.12.17.17.48.57;	author okan;	state Exp;
branches;
next	1.168;

1.168
date	2012.12.17.14.58.46;	author okan;	state Exp;
branches;
next	1.167;

1.167
date	2012.12.17.14.32.39;	author okan;	state Exp;
branches;
next	1.166;

1.166
date	2012.12.17.14.20.52;	author okan;	state Exp;
branches;
next	1.165;

1.165
date	2012.12.17.02.53.29;	author okan;	state Exp;
branches;
next	1.164;

1.164
date	2012.12.17.02.28.45;	author okan;	state Exp;
branches;
next	1.163;

1.163
date	2012.11.29.03.54.46;	author okan;	state Exp;
branches;
next	1.162;

1.162
date	2012.11.29.03.34.19;	author okan;	state Exp;
branches;
next	1.161;

1.161
date	2012.11.28.14.32.44;	author okan;	state Exp;
branches;
next	1.160;

1.160
date	2012.11.28.14.14.44;	author okan;	state Exp;
branches;
next	1.159;

1.159
date	2012.11.08.20.18.19;	author okan;	state Exp;
branches;
next	1.158;

1.158
date	2012.11.07.20.34.39;	author okan;	state Exp;
branches;
next	1.157;

1.157
date	2012.11.07.14.40.51;	author okan;	state Exp;
branches;
next	1.156;

1.156
date	2012.11.07.14.39.44;	author okan;	state Exp;
branches;
next	1.155;

1.155
date	2012.10.31.22.06.24;	author okan;	state Exp;
branches;
next	1.154;

1.154
date	2012.10.31.19.30.19;	author okan;	state Exp;
branches;
next	1.153;

1.153
date	2012.09.09.19.47.47;	author okan;	state Exp;
branches;
next	1.152;

1.152
date	2012.07.13.17.01.04;	author okan;	state Exp;
branches;
next	1.151;

1.151
date	2012.07.13.15.21.35;	author okan;	state Exp;
branches;
next	1.150;

1.150
date	2012.07.13.14.18.04;	author okan;	state Exp;
branches;
next	1.149;

1.149
date	2012.07.06.14.18.00;	author okan;	state Exp;
branches;
next	1.148;

1.148
date	2012.07.05.17.35.13;	author okan;	state Exp;
branches;
next	1.147;

1.147
date	2012.07.03.13.49.03;	author okan;	state Exp;
branches;
next	1.146;

1.146
date	2012.05.16.01.17.14;	author okan;	state Exp;
branches;
next	1.145;

1.145
date	2012.05.16.01.09.17;	author okan;	state Exp;
branches;
next	1.144;

1.144
date	2012.05.16.01.04.36;	author okan;	state Exp;
branches;
next	1.143;

1.143
date	2012.05.13.15.17.13;	author okan;	state Exp;
branches;
next	1.142;

1.142
date	2011.09.13.08.41.57;	author okan;	state Exp;
branches;
next	1.141;

1.141
date	2011.09.08.12.35.33;	author okan;	state Exp;
branches;
next	1.140;

1.140
date	2011.09.04.16.59.31;	author oga;	state Exp;
branches;
next	1.139;

1.139
date	2011.09.03.09.42.33;	author okan;	state Exp;
branches;
next	1.138;

1.138
date	2011.09.03.09.25.39;	author okan;	state Exp;
branches;
next	1.137;

1.137
date	2011.09.03.09.20.58;	author okan;	state Exp;
branches;
next	1.136;

1.136
date	2011.09.03.09.17.16;	author okan;	state Exp;
branches;
next	1.135;

1.135
date	2011.07.23.13.09.11;	author okan;	state Exp;
branches;
next	1.134;

1.134
date	2011.07.14.11.39.53;	author okan;	state Exp;
branches;
next	1.133;

1.133
date	2011.06.24.06.52.23;	author okan;	state Exp;
branches;
next	1.132;

1.132
date	2011.06.24.06.09.26;	author okan;	state Exp;
branches;
next	1.131;

1.131
date	2011.06.24.06.06.24;	author okan;	state Exp;
branches;
next	1.130;

1.130
date	2011.06.24.06.01.47;	author okan;	state Exp;
branches;
next	1.129;

1.129
date	2011.06.24.05.45.57;	author okan;	state Exp;
branches;
next	1.128;

1.128
date	2011.06.24.05.40.09;	author okan;	state Exp;
branches;
next	1.127;

1.127
date	2011.06.24.05.30.42;	author okan;	state Exp;
branches;
next	1.126;

1.126
date	2011.05.15.17.58.47;	author okan;	state Exp;
branches;
next	1.125;

1.125
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.124;

1.124
date	2011.05.07.17.15.37;	author okan;	state Exp;
branches;
next	1.123;

1.123
date	2011.05.05.16.40.37;	author okan;	state Exp;
branches;
next	1.122;

1.122
date	2011.03.22.10.57.31;	author okan;	state Exp;
branches;
next	1.121;

1.121
date	2011.03.22.10.52.37;	author okan;	state Exp;
branches;
next	1.120;

1.120
date	2011.03.22.10.49.46;	author okan;	state Exp;
branches;
next	1.119;

1.119
date	2011.03.22.10.47.59;	author okan;	state Exp;
branches;
next	1.118;

1.118
date	2010.05.22.22.10.31;	author okan;	state Exp;
branches;
next	1.117;

1.117
date	2010.04.11.16.51.26;	author okan;	state Exp;
branches;
next	1.116;

1.116
date	2010.02.10.01.23.05;	author okan;	state Exp;
branches;
next	1.115;

1.115
date	2010.01.27.03.04.50;	author okan;	state Exp;
branches;
next	1.114;

1.114
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.113;

1.113
date	2009.12.15.03.34.34;	author okan;	state Exp;
branches;
next	1.112;

1.112
date	2009.12.15.03.26.22;	author okan;	state Exp;
branches;
next	1.111;

1.111
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.110;

1.110
date	2009.12.14.16.39.01;	author oga;	state Exp;
branches;
next	1.109;

1.109
date	2009.12.11.18.09.16;	author oga;	state Exp;
branches;
next	1.108;

1.108
date	2009.12.11.17.55.42;	author oga;	state Exp;
branches;
next	1.107;

1.107
date	2009.12.11.17.51.42;	author oga;	state Exp;
branches;
next	1.106;

1.106
date	2009.12.10.23.21.26;	author oga;	state Exp;
branches;
next	1.105;

1.105
date	2009.12.10.23.14.58;	author oga;	state Exp;
branches;
next	1.104;

1.104
date	2009.12.10.17.16.51;	author oga;	state Exp;
branches;
next	1.103;

1.103
date	2009.12.08.16.52.17;	author okan;	state Exp;
branches;
next	1.102;

1.102
date	2009.12.07.23.19.51;	author oga;	state Exp;
branches;
next	1.101;

1.101
date	2009.12.07.22.46.15;	author oga;	state Exp;
branches;
next	1.100;

1.100
date	2009.12.07.22.21.59;	author oga;	state Exp;
branches;
next	1.99;

1.99
date	2009.12.07.21.20.52;	author okan;	state Exp;
branches;
next	1.98;

1.98
date	2009.08.27.01.38.08;	author okan;	state Exp;
branches;
next	1.97;

1.97
date	2009.08.24.23.54.41;	author oga;	state Exp;
branches;
next	1.96;

1.96
date	2009.08.24.23.49.04;	author okan;	state Exp;
branches;
next	1.95;

1.95
date	2009.08.24.21.22.48;	author oga;	state Exp;
branches;
next	1.94;

1.94
date	2009.06.26.12.21.58;	author okan;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.23.21.52.38;	author okan;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.20.00.22.39;	author okan;	state Exp;
branches;
next	1.91;

1.91
date	2009.06.17.12.30.17;	author okan;	state Exp;
branches;
next	1.90;

1.90
date	2009.05.18.00.17.46;	author oga;	state Exp;
branches;
next	1.89;

1.89
date	2009.05.18.00.14.19;	author oga;	state Exp;
branches;
next	1.88;

1.88
date	2009.05.17.23.40.57;	author okan;	state Exp;
branches;
next	1.87;

1.87
date	2009.05.17.17.04.59;	author sthen;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.14.16.29.58;	author oga;	state Exp;
branches;
next	1.85;

1.85
date	2009.05.14.16.24.04;	author oga;	state Exp;
branches;
next	1.84;

1.84
date	2009.04.15.14.01.45;	author okan;	state Exp;
branches;
next	1.83;

1.83
date	2009.02.07.21.07.00;	author martynas;	state Exp;
branches;
next	1.82;

1.82
date	2009.01.27.02.16.20;	author okan;	state Exp;
branches;
next	1.81;

1.81
date	2009.01.27.00.42.53;	author oga;	state Exp;
branches;
next	1.80;

1.80
date	2009.01.23.19.00.59;	author okan;	state Exp;
branches;
next	1.79;

1.79
date	2009.01.23.18.58.40;	author oga;	state Exp;
branches;
next	1.78;

1.78
date	2009.01.22.15.26.33;	author oga;	state Exp;
branches;
next	1.77;

1.77
date	2009.01.21.15.04.38;	author todd;	state Exp;
branches;
next	1.76;

1.76
date	2009.01.17.20.39.24;	author okan;	state Exp;
branches;
next	1.75;

1.75
date	2009.01.17.18.41.50;	author oga;	state Exp;
branches;
next	1.74;

1.74
date	2009.01.16.15.24.14;	author okan;	state Exp;
branches;
next	1.73;

1.73
date	2009.01.15.00.32.35;	author okan;	state Exp;
branches;
next	1.72;

1.72
date	2009.01.11.21.46.48;	author oga;	state Exp;
branches;
next	1.71;

1.71
date	2009.01.11.21.34.22;	author okan;	state Exp;
branches;
next	1.70;

1.70
date	2009.01.11.18.34.46;	author okan;	state Exp;
branches;
next	1.69;

1.69
date	2008.12.04.23.55.04;	author oga;	state Exp;
branches;
next	1.68;

1.68
date	2008.09.29.23.16.46;	author oga;	state Exp;
branches;
next	1.67;

1.67
date	2008.09.22.14.28.04;	author oga;	state Exp;
branches;
next	1.66;

1.66
date	2008.09.22.14.15.03;	author oga;	state Exp;
branches;
next	1.65;

1.65
date	2008.07.22.21.01.54;	author oga;	state Exp;
branches;
next	1.64;

1.64
date	2008.07.22.20.51.54;	author oga;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.22.20.42.24;	author oga;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.22.20.26.12;	author oga;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.22.19.54.57;	author oga;	state Exp;
branches;
next	1.60;

1.60
date	2008.07.22.19.52.54;	author oga;	state Exp;
branches;
next	1.59;

1.59
date	2008.07.11.15.18.29;	author okan;	state Exp;
branches;
next	1.58;

1.58
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2008.06.25.22.44.42;	author oga;	state Exp;
branches;
next	1.56;

1.56
date	2008.06.25.22.37.29;	author oga;	state Exp;
branches;
next	1.55;

1.55
date	2008.06.17.23.40.33;	author oga;	state Exp;
branches;
next	1.54;

1.54
date	2008.06.15.02.47.46;	author oga;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.14.22.04.11;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2008.06.14.21.48.54;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.12.19.10.56;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2008.05.21.14.11.19;	author oga;	state Exp;
branches;
next	1.49;

1.49
date	2008.05.20.14.50.51;	author oga;	state Exp;
branches;
next	1.48;

1.48
date	2008.05.19.18.07.53;	author okan;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.19.17.32.22;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2008.05.19.17.24.19;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2008.05.19.17.13.55;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2008.05.19.17.11.19;	author okan;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.19.15.17.50;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2008.05.19.12.56.58;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2008.05.18.19.43.50;	author oga;	state Exp;
branches;
next	1.40;

1.40
date	2008.05.18.19.38.18;	author oga;	state Exp;
branches;
next	1.39;

1.39
date	2008.05.17.03.59.54;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2008.05.01.18.01.13;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2008.04.16.13.47.29;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2008.04.16.13.40.34;	author oga;	state Exp;
branches;
next	1.35;

1.35
date	2008.04.16.13.38.09;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2008.04.16.13.35.37;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2008.04.16.13.33.26;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2008.04.15.21.20.56;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.15.20.26.50;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.15.18.46.58;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.09.18.10.47;	author okan;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.07.23.47.09;	author simon;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.26.15.45.42;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.23.15.09.21;	author simon;	state Exp;
branches;
next	1.24;

1.24
date	2008.03.22.15.09.45;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2008.03.22.14.09.02;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2008.02.20.13.00.18;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.02.13.21.48.03;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.02.13.21.04.19;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.16.11.39.20;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.14.15.21.10;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.08.20.21.43;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.03.01.58.16;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.02.20.54.32;	author marc;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.28.16.35.52;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.19.22.18.16;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.13.23.26.04;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.13.23.08.49;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.07.21.58.03;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.27.13.28.22;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.26.19.34.26;	author niallo;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.05.19.03.20;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.27.09.23.12;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.10.17.23.49;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.27.18.08.14;	author bernd;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.336
log
@Add search_print_text(), a default callback for mi->print in menu_filter(). While
here, normalize the remaining search_print_* argument paramters.
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: calmwm.h,v 1.335 2016/12/01 20:28:19 okan Exp $
 */

#ifndef _CALMWM_H_
#define _CALMWM_H_

#include <X11/XKBlib.h>
#include <X11/Xatom.h>
#include <X11/Xft/Xft.h>
#include <X11/Xlib.h>
#include <X11/Xproto.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <X11/extensions/Xrandr.h>
#include <X11/keysym.h>

#undef MIN
#undef MAX
#define MIN(x, y) ((x) < (y) ? (x) : (y))
#define MAX(x, y) ((x) > (y) ? (x) : (y))

#ifndef nitems
#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
#endif

#define	CONFFILE	".cwmrc"

#define BUTTONMASK	(ButtonPressMask | ButtonReleaseMask)
#define MOUSEMASK	(BUTTONMASK | PointerMotionMask)
#define MENUMASK 	(MOUSEMASK | ButtonMotionMask | ExposureMask)
#define MENUGRABMASK	(MOUSEMASK | ButtonMotionMask | StructureNotifyMask)
#define KEYMASK		(KeyPressMask | ExposureMask)
#define IGNOREMODMASK	(LockMask | Mod2Mask | 0x2000)

/* direction/amount */
#define CWM_UP			0x0001
#define CWM_DOWN		0x0002
#define CWM_LEFT		0x0004
#define CWM_RIGHT		0x0008
#define CWM_BIGAMOUNT		0x0010
#define DIRECTIONMASK	(CWM_UP | CWM_DOWN | CWM_LEFT | CWM_RIGHT)

#define CWM_CYCLE_FORWARD	0x0001
#define CWM_CYCLE_REVERSE	0x0002
#define CWM_CYCLE_INGROUP	0x0004

enum cwm_status {
	CWM_QUIT,
	CWM_RUNNING,
	CWM_EXEC_WM
};

enum cursor_font {
	CF_NORMAL,
	CF_MOVE,
	CF_RESIZE,
	CF_QUESTION,
	CF_NITEMS
};
enum color {
	CWM_COLOR_BORDER_ACTIVE,
	CWM_COLOR_BORDER_INACTIVE,
	CWM_COLOR_BORDER_URGENCY,
	CWM_COLOR_BORDER_GROUP,
	CWM_COLOR_BORDER_UNGROUP,
	CWM_COLOR_MENU_FG,
	CWM_COLOR_MENU_BG,
	CWM_COLOR_MENU_FONT,
	CWM_COLOR_MENU_FONT_SEL,
	CWM_COLOR_NITEMS
};

struct geom {
	int		 x;
	int		 y;
	int		 w;
	int		 h;
};

enum apply_gap {
	CWM_NOGAP = 0,
	CWM_GAP
};
struct gap {
	int		 top;
	int		 bottom;
	int		 left;
	int		 right;
};

struct winname {
	TAILQ_ENTRY(winname)	 entry;
	char			*name;
};
TAILQ_HEAD(name_q, winname);
TAILQ_HEAD(ignore_q, winname);

struct client_ctx {
	TAILQ_ENTRY(client_ctx)	 entry;
	TAILQ_ENTRY(client_ctx)	 group_entry;
	struct screen_ctx	*sc;
	struct group_ctx	*gc;
	Window			 win;
	Colormap		 colormap;
	unsigned int		 bwidth; /* border width */
	struct geom		 geom, savegeom, fullgeom;
	struct {
		long		 flags;	/* defined hints */
		int		 basew;	/* desired width */
		int		 baseh;	/* desired height */
		int		 minw;	/* minimum width */
		int		 minh;	/* minimum height */
		int		 maxw;	/* maximum width */
		int		 maxh;	/* maximum height */
		int		 incw;	/* width increment progression */
		int		 inch;	/* height increment progression */
		float		 mina;	/* minimum aspect ratio */
		float		 maxa;	/* maximum aspect ratio */
	} hint;
	struct {
		int		 x;	/* x position */
		int		 y;	/* y position */
	} ptr;
	struct {
		int		 h;	/* height */
		int		 w;	/* width */
	} dim;
#define CLIENT_HIDDEN			0x0001
#define CLIENT_IGNORE			0x0002
#define CLIENT_VMAXIMIZED		0x0004
#define CLIENT_HMAXIMIZED		0x0008
#define CLIENT_FREEZE			0x0010
#define CLIENT_GROUP			0x0020
#define CLIENT_UNGROUP			0x0040
#define CLIENT_INPUT			0x0080
#define CLIENT_WM_DELETE_WINDOW		0x0100
#define CLIENT_WM_TAKE_FOCUS		0x0200
#define CLIENT_URGENCY			0x0400
#define CLIENT_FULLSCREEN		0x0800
#define CLIENT_STICKY			0x1000
#define CLIENT_ACTIVE			0x2000

#define CLIENT_HIGHLIGHT		(CLIENT_GROUP | CLIENT_UNGROUP)
#define CLIENT_MAXFLAGS			(CLIENT_VMAXIMIZED | CLIENT_HMAXIMIZED)
#define CLIENT_MAXIMIZED		(CLIENT_VMAXIMIZED | CLIENT_HMAXIMIZED)
	int			 flags;
	int			 stackingorder;
	struct name_q		 nameq;
	char			*name;
	char			*label;
	XClassHint		ch;
	XWMHints		*wmh;
};
TAILQ_HEAD(client_q, client_ctx);

struct group_ctx {
	TAILQ_ENTRY(group_ctx)	 entry;
	struct screen_ctx	*sc;
	char			*name;
	int			 num;
	struct client_q		 clientq;
};
TAILQ_HEAD(group_q, group_ctx);

struct autogroup {
	TAILQ_ENTRY(autogroup)	 entry;
	char			*class;
	char			*name;
	int 			 num;
};
TAILQ_HEAD(autogroup_q, autogroup);

struct region_ctx {
	TAILQ_ENTRY(region_ctx)	 entry;
	int			 num;
	struct geom		 area;
	struct geom		 view; /* viewable area */
	struct geom		 work; /* workable area, gap-applied */
};
TAILQ_HEAD(region_q, region_ctx);

struct screen_ctx {
	TAILQ_ENTRY(screen_ctx)	 entry;
	int			 which;
	Window			 rootwin;
	int			 cycling;
	int			 hideall;
	int			 snapdist;
	struct geom		 view; /* viewable area */
	struct geom		 work; /* workable area, gap-applied */
	struct gap		 gap;
	struct client_q		 clientq;
	struct region_q		 regionq;
	struct group_q		 groupq;
	struct group_ctx	*group_active;
	struct {
		Window		 win;
		XftDraw		*xftdraw;
	} menu;
	XftColor		 xftcolor[CWM_COLOR_NITEMS];
	XftFont			*xftfont;
};
TAILQ_HEAD(screen_q, screen_ctx);

enum xev {
	CWM_XEV_KEY,
	CWM_XEV_BTN
};
union arg {
	char	*c;
	int	 i;
};
union press {
	KeySym		 keysym;
	unsigned int	 button;
};
enum context {
	CWM_CONTEXT_NONE,
	CWM_CONTEXT_CC,
	CWM_CONTEXT_SC
};
struct bind_ctx {
	TAILQ_ENTRY(bind_ctx)	 entry;
	void			(*callback)(void *, union arg *, enum xev);
	union arg		 argument;
	unsigned int		 modmask;
	union press		 press;
	enum context		 context;
};
TAILQ_HEAD(keybind_q, bind_ctx);
TAILQ_HEAD(mousebind_q, bind_ctx);

struct cmd_ctx {
	TAILQ_ENTRY(cmd_ctx)	 entry;
	char			*name;
	char			 path[PATH_MAX];
};
TAILQ_HEAD(cmd_q, cmd_ctx);

enum menu_exec {
	CWM_MENU_EXEC_EXEC,
	CWM_MENU_EXEC_WM
};
#define CWM_MENU_DUMMY		0x0001
#define CWM_MENU_FILE		0x0002
#define CWM_MENU_LIST		0x0004
#define CWM_MENU_WINDOW_ALL	0x0008
#define CWM_MENU_WINDOW_HIDDEN	0x0010

struct menu {
	TAILQ_ENTRY(menu)	 entry;
	TAILQ_ENTRY(menu)	 resultentry;
#define MENU_MAXENTRY		 200
	char			 text[MENU_MAXENTRY + 1];
	char			 print[MENU_MAXENTRY + 1];
	void			*ctx;
	short			 dummy;
	short			 abort;
};
TAILQ_HEAD(menu_q, menu);

struct conf {
	struct keybind_q	 keybindq;
	struct mousebind_q	 mousebindq;
	struct autogroup_q	 autogroupq;
	struct ignore_q		 ignoreq;
	struct cmd_q		 cmdq;
	int			 ngroups;
	int			 stickygroups;
	int			 nameqlen;
	int			 bwidth;
	int			 mamount;
	int			 snapdist;
	struct gap		 gap;
	char			*color[CWM_COLOR_NITEMS];
	char			 known_hosts[PATH_MAX];
	char			*font;
	char			*wmname;
	Cursor			 cursor[CF_NITEMS];
	int			 xrandr;
	int			 xrandr_event_base;
	char			*wm_argv;
};

/* MWM hints */
struct mwm_hints {
#define MWM_HINTS_ELEMENTS	3L
#define MWM_FLAGS_STATUS	(1<<3)

#define MWM_FLAGS_FUNCTIONS	(1<<0)
#define MWM_FLAGS_DECORATIONS	(1<<1)
#define MWM_FLAGS_INPUT_MODE	(1<<2)
	unsigned long	flags;

#define MWM_FUNCS_ALL		(1<<0)
#define MWM_FUNCS_RESIZE	(1<<1)
#define MWM_FUNCS_MOVE		(1<<2)
#define MWM_FUNCS_MINIMIZE	(1<<3)
#define MWM_FUNCS_MAXIMIZE	(1<<4)
#define MWM_FUNCS_CLOSE		(1<<5)
	unsigned long	functions;

#define	MWM_DECOR_ALL		(1<<0)
#define	MWM_DECOR_BORDER	(1<<1)
#define MWM_DECOR_RESIZE_HANDLE	(1<<2)
#define MWM_DECOR_TITLEBAR	(1<<3)
#define MWM_DECOR_MENU		(1<<4)
#define MWM_DECOR_MINIMIZE	(1<<5)
#define MWM_DECOR_MAXIMIZE	(1<<6)
	unsigned long	decorations;
};

enum cwmh {
	WM_STATE,
	WM_DELETE_WINDOW,
	WM_TAKE_FOCUS,
	WM_PROTOCOLS,
	_MOTIF_WM_HINTS,
	UTF8_STRING,
	WM_CHANGE_STATE,
	CWMH_NITEMS
};
enum ewmh {
	_NET_SUPPORTED,
	_NET_SUPPORTING_WM_CHECK,
	_NET_ACTIVE_WINDOW,
	_NET_CLIENT_LIST,
	_NET_CLIENT_LIST_STACKING,
	_NET_NUMBER_OF_DESKTOPS,
	_NET_CURRENT_DESKTOP,
	_NET_DESKTOP_VIEWPORT,
	_NET_DESKTOP_GEOMETRY,
	_NET_VIRTUAL_ROOTS,
	_NET_SHOWING_DESKTOP,
	_NET_DESKTOP_NAMES,
	_NET_WORKAREA,
	_NET_WM_NAME,
	_NET_WM_DESKTOP,
	_NET_CLOSE_WINDOW,
	_NET_WM_STATE,
#define	_NET_WM_STATES_NITEMS	7
	_NET_WM_STATE_STICKY,
	_NET_WM_STATE_MAXIMIZED_VERT,
	_NET_WM_STATE_MAXIMIZED_HORZ,
	_NET_WM_STATE_HIDDEN,
	_NET_WM_STATE_FULLSCREEN,
	_NET_WM_STATE_DEMANDS_ATTENTION,
	_CWM_WM_STATE_FREEZE,
	EWMH_NITEMS
};
enum net_wm_state {
	_NET_WM_STATE_REMOVE,
	_NET_WM_STATE_ADD,
	_NET_WM_STATE_TOGGLE
};

extern Display				*X_Dpy;
extern Time				 Last_Event_Time;
extern Atom				 cwmh[CWMH_NITEMS];
extern Atom				 ewmh[EWMH_NITEMS];
extern struct screen_q			 Screenq;
extern struct conf			 Conf;
extern const char			*homedir;

__dead void		 usage(void);

void			 client_applysizehints(struct client_ctx *);
void			 client_config(struct client_ctx *);
struct client_ctx	*client_current(void);
void			 client_cycle(struct screen_ctx *, int);
void			 client_cycle_leave(struct screen_ctx *);
void			 client_delete(struct client_ctx *);
void			 client_draw_border(struct client_ctx *);
struct client_ctx	*client_find(Window);
long			 client_get_wm_state(struct client_ctx *);
void			 client_getsizehints(struct client_ctx *);
void			 client_hide(struct client_ctx *);
void 			 client_htile(struct client_ctx *);
void			 client_lower(struct client_ctx *);
void			 client_map(struct client_ctx *);
void			 client_msg(struct client_ctx *, Atom, Time);
void			 client_move(struct client_ctx *);
int			 client_inbound(struct client_ctx *, int, int);
struct client_ctx	*client_init(Window, struct screen_ctx *, int);
void			 client_ptrsave(struct client_ctx *);
void			 client_ptrwarp(struct client_ctx *);
void			 client_raise(struct client_ctx *);
void			 client_resize(struct client_ctx *, int);
void			 client_send_delete(struct client_ctx *);
void			 client_set_wm_state(struct client_ctx *, long);
void			 client_setactive(struct client_ctx *);
void			 client_setname(struct client_ctx *);
int			 client_snapcalc(int, int, int, int, int);
void			 client_toggle_freeze(struct client_ctx *);
void			 client_toggle_fullscreen(struct client_ctx *);
void			 client_toggle_hidden(struct client_ctx *);
void			 client_toggle_hmaximize(struct client_ctx *);
void			 client_toggle_maximize(struct client_ctx *);
void			 client_toggle_sticky(struct client_ctx *);
void			 client_toggle_vmaximize(struct client_ctx *);
void			 client_transient(struct client_ctx *);
void			 client_unhide(struct client_ctx *);
void			 client_urgency(struct client_ctx *);
void 			 client_vtile(struct client_ctx *);
void			 client_wm_hints(struct client_ctx *);

void			 group_alltoggle(struct screen_ctx *);
void			 group_assign(struct group_ctx *, struct client_ctx *);
int			 group_autogroup(struct client_ctx *);
void			 group_cycle(struct screen_ctx *, int);
void			 group_hide(struct group_ctx *);
void			 group_hidetoggle(struct screen_ctx *, int);
int			 group_holds_only_hidden(struct group_ctx *);
int			 group_holds_only_sticky(struct group_ctx *);
void			 group_init(struct screen_ctx *, int);
void			 group_movetogroup(struct client_ctx *, int);
void			 group_only(struct screen_ctx *, int);
int			 group_restore(struct client_ctx *);
void			 group_show(struct group_ctx *);
void			 group_toggle_membership_enter(struct client_ctx *);
void			 group_toggle_membership_leave(struct client_ctx *);
void			 group_update_names(struct screen_ctx *);

void			 search_match_client(struct menu_q *, struct menu_q *,
			     char *);
void			 search_match_exec(struct menu_q *, struct menu_q *,
			     char *);
void			 search_match_path(struct menu_q *, struct menu_q *,
			     char *);
void			 search_match_text(struct menu_q *, struct menu_q *,
			     char *);
void			 search_print_client(struct menu *, int);
void			 search_print_cmd(struct menu *, int);
void			 search_print_group(struct menu *, int);
void			 search_print_text(struct menu *, int);

struct region_ctx	*region_find(struct screen_ctx *, int, int);
struct geom		 screen_apply_gap(struct screen_ctx *, struct geom);
struct screen_ctx	*screen_find(Window);
struct geom		 screen_area(struct screen_ctx *, int, int,
			     enum apply_gap);
void			 screen_init(int);
void			 screen_update_geometry(struct screen_ctx *);
void			 screen_updatestackingorder(struct screen_ctx *);
void			 screen_assert_clients_within(struct screen_ctx *);

void			 kbfunc_cwm_status(void *, union arg *, enum xev);
void			 kbfunc_ptrmove(void *, union arg *, enum xev);
void			 kbfunc_client_move(void *, union arg *, enum xev);
void			 kbfunc_client_resize(void *, union arg *, enum xev);
void			 kbfunc_client_delete(void *, union arg *, enum xev);
void			 kbfunc_client_lower(void *, union arg *, enum xev);
void			 kbfunc_client_raise(void *, union arg *, enum xev);
void			 kbfunc_client_hide(void *, union arg *, enum xev);
void			 kbfunc_client_toggle_freeze(void *,
			     union arg *, enum xev);
void			 kbfunc_client_toggle_sticky(void *,
			     union arg *, enum xev);
void			 kbfunc_client_toggle_fullscreen(void *,
			     union arg *, enum xev);
void			 kbfunc_client_toggle_maximize(void *,
			     union arg *, enum xev);
void			 kbfunc_client_toggle_hmaximize(void *,
			     union arg *, enum xev);
void			 kbfunc_client_toggle_vmaximize(void *,
			     union arg *, enum xev);
void 			 kbfunc_client_htile(void *, union arg *, enum xev);
void 			 kbfunc_client_vtile(void *, union arg *, enum xev);
void			 kbfunc_client_cycle(void *, union arg *, enum xev);
void			 kbfunc_client_toggle_group(void *,
			     union arg *, enum xev);
void			 kbfunc_client_movetogroup(void *,
			     union arg *, enum xev);
void			 kbfunc_group_toggle(void *, union arg *, enum xev);
void			 kbfunc_group_only(void *, union arg *, enum xev);
void			 kbfunc_group_cycle(void *, union arg *, enum xev);
void			 kbfunc_group_alltoggle(void *, union arg *, enum xev);
void			 kbfunc_menu_client(void *, union arg *, enum xev);
void			 kbfunc_menu_cmd(void *, union arg *, enum xev);
void			 kbfunc_menu_group(void *, union arg *, enum xev);
void			 kbfunc_menu_exec(void *, union arg *, enum xev);
void			 kbfunc_menu_ssh(void *, union arg *, enum xev);
void			 kbfunc_menu_client_label(void *, union arg *, enum xev);
void			 kbfunc_exec_cmd(void *, union arg *, enum xev);
void			 kbfunc_exec_lock(void *, union arg *, enum xev);
void			 kbfunc_exec_term(void *, union arg *, enum xev);

void			 mousefunc_client_move(void *, union arg *, enum xev);
void			 mousefunc_client_resize(void *, union arg *, enum xev);

void			 menu_windraw(struct screen_ctx *, Window,
			     const char *, ...);
struct menu  		*menu_filter(struct screen_ctx *, struct menu_q *,
			     const char *, const char *, int,
			     void (*)(struct menu_q *, struct menu_q *, char *),
			     void (*)(struct menu *, int));
void			 menuq_add(struct menu_q *, void *, const char *, ...);
void			 menuq_clear(struct menu_q *);

int			 parse_config(const char *, struct conf *);

void			 conf_atoms(void);
void			 conf_autogroup(struct conf *, int, const char *,
			     const char *);
int			 conf_bind_key(struct conf *, const char *,
    			     const char *);
int			 conf_bind_mouse(struct conf *, const char *,
    			     const char *);
void			 conf_clear(struct conf *);
void			 conf_client(struct client_ctx *);
int			 conf_cmd_add(struct conf *, const char *,
			     const char *);
void			 conf_cursor(struct conf *);
void			 conf_grab_kbd(Window);
void			 conf_grab_mouse(Window);
void			 conf_init(struct conf *);
void			 conf_ignore(struct conf *, const char *);
void			 conf_screen(struct screen_ctx *);

void			 xev_process(void);

int			 xu_getprop(Window, Atom, Atom, long, unsigned char **);
int			 xu_getstrprop(Window, Atom, char **);
void			 xu_ptr_getpos(Window, int *, int *);
void			 xu_ptr_setpos(Window, int, int);
void 			 xu_xorcolor(XftColor, XftColor, XftColor *);

void			 xu_ewmh_net_supported(struct screen_ctx *);
void			 xu_ewmh_net_supported_wm_check(struct screen_ctx *);
void			 xu_ewmh_net_desktop_geometry(struct screen_ctx *);
void			 xu_ewmh_net_workarea(struct screen_ctx *);
void			 xu_ewmh_net_client_list(struct screen_ctx *);
void			 xu_ewmh_net_client_list_stacking(struct screen_ctx *);
void			 xu_ewmh_net_active_window(struct screen_ctx *, Window);
Window			 xu_ewmh_get_net_active_window(struct screen_ctx *);
void			 xu_ewmh_net_wm_desktop_viewport(struct screen_ctx *);
void			 xu_ewmh_net_wm_number_of_desktops(struct screen_ctx *);
void			 xu_ewmh_net_showing_desktop(struct screen_ctx *);
void			 xu_ewmh_net_virtual_roots(struct screen_ctx *);
void			 xu_ewmh_net_current_desktop(struct screen_ctx *);
void			 xu_ewmh_net_desktop_names(struct screen_ctx *);

void			 xu_ewmh_net_wm_desktop(struct client_ctx *);
Atom 			*xu_ewmh_get_net_wm_state(struct client_ctx *, int *);
void 			 xu_ewmh_handle_net_wm_state_msg(struct client_ctx *,
			     int, Atom , Atom);
void 			 xu_ewmh_set_net_wm_state(struct client_ctx *);
void 			 xu_ewmh_restore_net_wm_state(struct client_ctx *);

char			*u_argv(char * const *);
void			 u_exec(char *);
void			 u_spawn(char *);

void			*xcalloc(size_t, size_t);
void			*xmalloc(size_t);
void			*xreallocarray(void *, size_t, size_t);
char			*xstrdup(const char *);
int			 xasprintf(char **, const char *, ...)
			    __attribute__((__format__ (printf, 2, 3)))
			    __attribute__((__nonnull__ (2)));

#endif /* _CALMWM_H_ */
@


1.335
log
@Tame the number of 'exec' and 'path' search_match wrappers. No functional
change now, though more can likely go later, losing the (paritally complete or
incomplete/broken) argument completion bits.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.334 2016/12/01 18:17:52 okan Exp $
d452 1
@


1.334
log
@Change 'menu-window' to display all windows; then add 'menu-window-hidden' for
the previous behaviour of 'menu-window'.  'menu-window' becomes the default
binding; use 'bind-mouse "1" menu-window-hidden' to restore old behaviour for
those who prefer.

OK sthen@@ (long long time ago on a different version)
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.333 2016/11/15 00:22:02 okan Exp $
d445 1
a445 3
void			 search_match_exec_path(struct menu_q *,
			     struct menu_q *, char *);
void			 search_match_path_any(struct menu_q *, struct menu_q *,
@


1.333
log
@revert previous; upcoming changes will hopefully deal with these more
naturally.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.331 2016/11/14 21:25:59 okan Exp $
d264 2
@


1.332
log
@Add a wrapper based upon xevent handlers around client move/resize for key and
mouse bindings.
@
text
@a465 1
void			 kbfunc_client_move_key(void *, union arg *, enum xev);
a466 1
void			 kbfunc_client_resize_key(void *, union arg *, enum xev);
@


1.331
log
@Define callbacks, then default bindings.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.330 2016/10/24 17:16:23 okan Exp $
d466 1
d468 1
@


1.330
log
@Get rid of 'matchname'; it's too surprising to have the menu change during
client search as different potential str matches are cycled through. If there's
interest, the only string that doesn't exist in the listing is the window's
class - that can be added of course, but it makes the line too long imho.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.329 2016/10/18 17:03:30 okan Exp $
d521 1
a521 1
int			 conf_bind_kbd(struct conf *, const char *,
@


1.329
log
@Refactor callbacks to take a void * so as to not try and generalize into
client_ctx in keypress and buttonpress event handlers; pass appropriate *ctx's
based on context.

While here, limit some globals, replace defines with appropriate variables and
fix some naming.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.328 2016/10/12 16:11:15 okan Exp $
a167 1
	char			*matchname;
@


1.328
log
@remove another unused proto
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.327 2016/10/06 14:53:52 okan Exp $
d60 8
a67 35
#define CWM_CLIENT_CYCLE	0x0001
#define CWM_CLIENT_RCYCLE	0x0002
#define CWM_CLIENT_CYCLE_INGRP	0x0004

#define CWM_CLIENT_TILE_HORIZ	0x0001
#define CWM_CLIENT_TILE_VERT	0x0002

#define CWM_MENU_EXEC		0x0001
#define CWM_MENU_EXEC_WM	0x0002

#define CWM_MENU_DUMMY		0x0001
#define CWM_MENU_FILE		0x0002
#define CWM_MENU_LIST		0x0004

#define CWM_GAP			0x0001
#define CWM_NOGAP		0x0002

#define CWM_KEY			0x0001
#define CWM_BTN			0x0002

#define CWM_CONTEXT_NONE	0x0000
#define CWM_CONTEXT_CLIENT	0x0001
#define CWM_CONTEXT_SCREEN	0x0002

#define CWM_QUIT		0x0000
#define CWM_RUNNING		0x0001
#define CWM_EXEC_WM		0x0002

union arg {
	char	*c;
	int	 i;
};
union press {
	KeySym		 keysym;
	unsigned int	 button;
d97 4
d112 1
a112 1
TAILQ_HEAD(winname_q, winname);
d165 1
a165 1
	struct winname_q	 nameq;
d172 1
a172 1
TAILQ_HEAD(client_ctx_q, client_ctx);
d179 1
a179 1
	struct client_ctx_q	 clientq;
d181 1
a181 1
TAILQ_HEAD(group_ctx_q, group_ctx);
d183 5
a187 5
struct autogroupwin {
	TAILQ_ENTRY(autogroupwin)	 entry;
	char				*class;
	char				*name;
	int 				 num;
d189 1
a189 1
TAILQ_HEAD(autogroupwin_q, autogroupwin);
d198 1
a198 1
TAILQ_HEAD(region_ctx_q, region_ctx);
d210 3
a212 3
	struct client_ctx_q	 clientq;
	struct region_ctx_q	 regionq;
	struct group_ctx_q	 groupq;
d221 1
a221 1
TAILQ_HEAD(screen_ctx_q, screen_ctx);
d223 20
a242 3
struct binding {
	TAILQ_ENTRY(binding)	 entry;
	void			(*callback)(struct client_ctx *, union arg *, int);
d246 1
a246 1
	int			 context;
d248 2
a249 2
TAILQ_HEAD(keybinding_q, binding);
TAILQ_HEAD(mousebinding_q, binding);
d251 2
a252 2
struct cmd {
	TAILQ_ENTRY(cmd)	 entry;
d256 9
a264 1
TAILQ_HEAD(cmd_q, cmd);
d279 3
a281 3
	struct keybinding_q	 keybindingq;
	struct mousebinding_q	 mousebindingq;
	struct autogroupwin_q	 autogroupq;
d296 3
d329 1
a329 9
extern Display				*X_Dpy;
extern Time				 Last_Event_Time;
extern struct screen_ctx_q		 Screenq;
extern struct conf			 Conf;
extern char				*wm_argv;
extern const char			*homedir;
extern int				 HasRandr, Randr_ev;

enum {
d339 1
a339 1
enum {
d367 1
a367 1
enum {
d372 3
d377 3
d457 2
a458 1
struct geom		 screen_area(struct screen_ctx *, int, int, int);
d464 43
a506 45
void			 kbfunc_client_cycle(struct client_ctx *, union arg *, int);
void			 kbfunc_client_delete(struct client_ctx *, union arg *, int);
void			 kbfunc_client_hide(struct client_ctx *, union arg *, int);
void			 kbfunc_menu_client_label(struct client_ctx *, union arg *, int);
void			 kbfunc_client_lower(struct client_ctx *, union arg *, int);
void			 kbfunc_client_move(struct client_ctx *, union arg *, int);
void			 kbfunc_client_movetogroup(struct client_ctx *,
			     union arg *, int);
void			 kbfunc_client_raise(struct client_ctx *, union arg *, int);
void			 kbfunc_client_resize(struct client_ctx *, union arg *, int);
void 			 kbfunc_client_tile(struct client_ctx *, union arg *, int);
void			 kbfunc_client_toggle_group(struct client_ctx *,
			     union arg *, int);
void			 kbfunc_client_toggle_freeze(struct client_ctx *,
    			     union arg *, int);
void			 kbfunc_client_toggle_fullscreen(struct client_ctx *,
			     union arg *, int);
void			 kbfunc_client_toggle_hmaximize(struct client_ctx *,
			     union arg *, int);
void			 kbfunc_client_toggle_maximize(struct client_ctx *,
			     union arg *, int);
void			 kbfunc_client_toggle_sticky(struct client_ctx *,
    			     union arg *, int);
void			 kbfunc_client_toggle_vmaximize(struct client_ctx *,
			     union arg *, int);
void			 kbfunc_cwm_status(struct client_ctx *, union arg *, int);
void			 kbfunc_exec(struct client_ctx *, union arg *, int);
void			 kbfunc_exec_lock(struct client_ctx *, union arg *, int);
void			 kbfunc_exec_term(struct client_ctx *, union arg *, int);
void			 kbfunc_group_alltoggle(struct client_ctx *,
			     union arg *, int);
void			 kbfunc_group_cycle(struct client_ctx *, union arg *, int);
void			 kbfunc_group_only(struct client_ctx *, union arg *, int);
void			 kbfunc_group_toggle(struct client_ctx *, union arg *, int);
void			 kbfunc_menu_exec(struct client_ctx *, union arg *, int);
void			 kbfunc_menu_client(struct client_ctx *, union arg *, int);
void			 kbfunc_menu_cmd(struct client_ctx *, union arg *, int);
void			 kbfunc_menu_group(struct client_ctx *, union arg *, int);
void			 kbfunc_menu_ssh(struct client_ctx *, union arg *, int);
void			 kbfunc_ptrmove(struct client_ctx *, union arg *, int);

void			 mousefunc_client_move(struct client_ctx *,
    			    union arg *, int);
void			 mousefunc_client_resize(struct client_ctx *,
    			    union arg *, int);
@


1.327
log
@Rename 2 kbfunc to match closer to what they do
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.326 2016/10/06 14:41:19 okan Exp $
a468 1
void			 kbfunc_client_rcycle(struct client_ctx *, union arg *, int);
@


1.326
log
@Add an argument to the callbacks to pass the xevent context, button or
key press. This allows to remove a few hacks to duplicate functions only
for behaviour changes; now differing behaviours are pushed down to the
callback. Also will allow for previously unavailable actions to be bind-able
down the road.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.325 2016/10/05 13:10:59 okan Exp $
a461 2
void			 kbfunc_client_grouptoggle(struct client_ctx *,
			     union arg *, int);
d463 1
a463 1
void			 kbfunc_client_label(struct client_ctx *, union arg *, int);
d472 2
@


1.325
log
@Stash wmname into conf.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.324 2016/10/04 20:15:55 okan Exp $
d77 2
a78 2
#define CWM_KBD			0x0001
#define CWM_MOUSE		0x0002
d248 1
a248 1
	void			(*callback)(struct client_ctx *, union arg *);
d460 2
a461 2
void			 kbfunc_client_cycle(struct client_ctx *, union arg *);
void			 kbfunc_client_delete(struct client_ctx *, union arg *);
d463 5
a467 5
			     union arg *);
void			 kbfunc_client_hide(struct client_ctx *, union arg *);
void			 kbfunc_client_label(struct client_ctx *, union arg *);
void			 kbfunc_client_lower(struct client_ctx *, union arg *);
void			 kbfunc_client_move(struct client_ctx *, union arg *);
d469 5
a473 5
			     union arg *);
void			 kbfunc_client_raise(struct client_ctx *, union arg *);
void			 kbfunc_client_rcycle(struct client_ctx *, union arg *);
void			 kbfunc_client_resize(struct client_ctx *, union arg *);
void 			 kbfunc_client_tile(struct client_ctx *, union arg *);
d475 1
a475 1
    			     union arg *);
d477 1
a477 1
			     union arg *);
d479 1
a479 1
			     union arg *);
d481 1
a481 1
			     union arg *);
d483 1
a483 1
    			     union arg *);
d485 5
a489 5
			     union arg *);
void			 kbfunc_cwm_status(struct client_ctx *, union arg *);
void			 kbfunc_exec(struct client_ctx *, union arg *);
void			 kbfunc_exec_lock(struct client_ctx *, union arg *);
void			 kbfunc_exec_term(struct client_ctx *, union arg *);
d491 10
a500 10
			     union arg *);
void			 kbfunc_group_cycle(struct client_ctx *, union arg *);
void			 kbfunc_group_only(struct client_ctx *, union arg *);
void			 kbfunc_group_toggle(struct client_ctx *, union arg *);
void			 kbfunc_menu_exec(struct client_ctx *, union arg *);
void			 kbfunc_menu_client(struct client_ctx *, union arg *);
void			 kbfunc_menu_cmd(struct client_ctx *, union arg *);
void			 kbfunc_menu_group(struct client_ctx *, union arg *);
void			 kbfunc_menu_ssh(struct client_ctx *, union arg *);
void			 kbfunc_ptrmove(struct client_ctx *, union arg *);
d503 1
a503 1
    			    union arg *);
d505 1
a505 1
    			    union arg *);
@


1.324
log
@When removing xrandr regions, ensure clients are within the bounds of
the screen; adapted from an ancient diff from Sviatoslav Chagaev. Things
in this area will likely change, but put this in so it works now and
serves as a reminder.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.323 2016/10/04 15:52:32 okan Exp $
a43 1
#define	WMNAME	 	"CWM"
d292 1
@


1.323
log
@Calculate client nameqlen in client_setname(), the only place it's
needed/used.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.322 2016/10/04 15:18:20 okan Exp $
d458 1
@


1.322
log
@Turn CALMWM_NGROUPS define into variable, ngroups.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.321 2016/10/03 18:43:49 okan Exp $
a189 2
#define CLIENT_MAXNAMEQLEN		5
	int			 nameqlen;
d285 1
@


1.321
log
@Start simplifying menu code; and in turn, remove a cursor no longer
needed.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.320 2016/10/03 14:42:34 okan Exp $
a237 1
#define CALMWM_NGROUPS		 10
d285 1
@


1.320
log
@Defaults are split between defines and conf_init(); normalize these, as
well as give 'sticky' groups its own variable.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.319 2016/09/30 21:44:51 okan Exp $
d99 1
a99 1
	CF_DEFAULT,
d101 1
a101 1
	CF_NORMAL,
a102 1
	CF_RESIZE,
@


1.319
log
@remove unused proto
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.318 2016/09/30 18:28:06 okan Exp $
d287 1
a287 3
#define	CONF_STICKY_GROUPS		0x0001
	int			 flags;
#define CONF_BWIDTH			1
a288 1
#define	CONF_MAMOUNT			1
a289 1
#define	CONF_SNAPDIST			0
a293 1
#define	CONF_FONT			"sans-serif:pixelsize=14:bold"
a299 4
	unsigned long	flags;
	unsigned long	functions;
	unsigned long	decorations;
};
d301 1
d306 1
a306 1
#define MWM_FLAGS_STATUS	(1<<3)
d314 1
d323 2
@


1.318
log
@Use instinsic X11 functions for key/btn/ptr grab/ungrab/regrab requests;
the one line wrappers provided no value and limited altering calls where
needed; additionally, most of them had but one caller.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.317 2016/09/30 15:12:19 okan Exp $
a424 1
void			 client_warp(struct client_ctx *);
@


1.317
log
@Replace mousefunc_sweep_draw() with a generic menu_windraw() using va
lists; use it appropriately for both window dimension and position in
the respective mousefunc calls.

ok bryent@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.316 2016/09/29 00:21:55 okan Exp $
a544 2
void			 xu_btn_grab(Window, int, unsigned int);
void			 xu_btn_ungrab(Window);
a546 2
void			 xu_key_grab(Window, unsigned int, KeySym);
void			 xu_key_ungrab(Window);
a547 2
int			 xu_ptr_grab(Window, unsigned int, Cursor);
int			 xu_ptr_regrab(unsigned int, Cursor);
a548 1
void			 xu_ptr_ungrab(void);
@


1.316
log
@Mechanical change: move screen menu bits to their own struct.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.315 2016/09/28 17:06:33 okan Exp $
d514 2
@


1.315
log
@Inline Xft draw and extents wrappers; too much abstraction.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.314 2016/09/22 14:36:03 okan Exp $
a230 1
	Window			 menuwin;
d242 4
a246 1
	XftDraw			*xftdraw;
@


1.314
log
@Continue merging kb and mouse functions: fold
mousefunc_menu_{client,cmd,group} into the respective
kbfunc_menu_{client,cmd,group} functions; simply pass a flag down from
config denoting mouse action behaviour.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.313 2016/09/20 19:11:19 okan Exp $
a551 3
void			 xu_xft_draw(struct screen_ctx *, const char *,
			     int, int, int);
int			 xu_xft_width(XftFont *, const char *, int);
@


1.313
log
@de-static client_inbound()
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.312 2016/09/16 14:32:02 okan Exp $
a510 4
void			 mousefunc_menu_client(struct client_ctx *,
			    union arg *);
void			 mousefunc_menu_cmd(struct client_ctx *, union arg *);
void			 mousefunc_menu_group(struct client_ctx *, union arg *);
@


1.312
log
@During init, query screen for _NET_ACTIVE_WINDOW and set that client as
active; while we already look at what's under the pointer, use this
information first, then look under the pointer (saving that round-trip).
This restores the active state to a client after restart even if the
pointer is not above it (and of course the pointer is not above another
client).
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.311 2015/11/12 21:28:03 okan Exp $
d401 1
@


1.311
log
@more client vs screen context differences
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.310 2015/11/12 18:26:41 okan Exp $
d401 1
a401 1
struct client_ctx	*client_init(Window, struct screen_ctx *);
d567 1
@


1.310
log
@Move kb pointer movement out of the kbfunc_client_moveresize since it's
got nothing to do with clients, thus doing flags work causes lots of
waste and almost useless jumpy pointer movements; while here, split out
move and resize since they share almost no code, just like mouse client
move/resize; factor out amount and factor. Still wonder why this is
here, but it works now.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.309 2015/11/11 14:22:01 okan Exp $
a464 2
void			 kbfunc_client_cyclegroup(struct client_ctx *,
			     union arg *);
a465 3
void			 kbfunc_client_group(struct client_ctx *, union arg *);
void			 kbfunc_client_grouponly(struct client_ctx *,
			     union arg *);
a473 2
void			 kbfunc_client_nogroup(struct client_ctx *,
			     union arg *);
d494 5
@


1.309
log
@Partial revert of replacing screen_area() with region_find(); until a
fix for a regression is found; this bug has been around for a long time
it seems, but this change exposed it. Likely need to track clients in to
and out of regions.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.308 2015/11/10 20:05:33 okan Exp $
d53 7
a59 9
/* kb movement */
#define CWM_MOVE		0x0001
#define CWM_RESIZE		0x0002
#define CWM_PTRMOVE		0x0004
#define CWM_BIGMOVE		0x0008
#define CWM_UP			0x0010
#define CWM_DOWN		0x0020
#define CWM_LEFT		0x0040
#define CWM_RIGHT		0x0080
d476 1
a476 2
void			 kbfunc_client_moveresize(struct client_ctx *,
			     union arg *);
d483 1
d506 1
@


1.308
log
@Start cleaning up name vs function differences; replace magic numbers.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.307 2015/11/09 20:15:23 okan Exp $
d77 3
d223 1
d458 1
d461 1
a461 1
struct region_ctx	*region_find(struct screen_ctx *, int, int);
@


1.307
log
@Clean up unused defines.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.306 2015/11/09 20:03:29 okan Exp $
d63 9
a71 8
/* exec */
#define	CWM_EXEC_PROGRAM	0x0001
#define	CWM_EXEC_WM		0x0002

/* cycle */
#define CWM_CYCLE		0x0001
#define CWM_RCYCLE		0x0002
#define CWM_INGROUP		0x0004
a72 1
/* menu */
d77 2
a78 2
#define CWM_TILE_HORIZ 		0x0001
#define CWM_TILE_VERT 		0x0002
d80 3
a82 2
#define CWM_WIN			0x0001
#define CWM_CMD			0x0002
d86 1
a86 1
#define CWM_EXECWM		0x0002
a91 1

a104 1

d253 1
a253 1
	int			 flags;
d481 1
a481 1
void			 kbfunc_client_search(struct client_ctx *, union arg *);
a493 1
void			 kbfunc_cmdexec(struct client_ctx *, union arg *);
d496 4
a499 1
void			 kbfunc_lock(struct client_ctx *, union arg *);
d502 1
a502 3
void			 kbfunc_ssh(struct client_ctx *, union arg *);
void			 kbfunc_term(struct client_ctx *, union arg *);
void 			 kbfunc_tile(struct client_ctx *, union arg *);
d508 2
a511 2
void			 mousefunc_menu_unhide(struct client_ctx *,
    			    union arg *);
@


1.306
log
@Extend region to include both view and work areas; switch to
region_find() which no longer needs to recalculate gap each time
a client (or menu) is created or altered. If no RandR, fall back
to display dimensions while building regions instead of during
execution.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.305 2015/09/16 17:58:25 okan Exp $
a75 3

#define ARG_CHAR		0x0001
#define ARG_INT			0x0002
@


1.305
log
@On execwm, we should properly release resources before exec'ing into a
new window manager; so allow CWM_EXEC_WM to assign new wm to wm_argv and
pass through cwm_status (now EXECWM) so that x_teardown() gets called
before exec'ing the new window manager.  Removes the need for a separate
x_restart() now, using new wm_argv; and consolidates errno for execvp.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.304 2015/08/27 18:53:14 okan Exp $
a82 3
#define CWM_GAP			0x0001
#define CWM_NOGAP		0x0002

d224 2
a225 1
	struct geom		 area;
d460 1
a460 1
struct geom		 screen_area(struct screen_ctx *, int, int, int);
@


1.304
log
@Mechanical change: group->gc
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.303 2015/08/25 18:29:10 okan Exp $
d91 1
a91 1
#define CWM_RESTART		0x0002
d337 1
d585 1
@


1.303
log
@Split out sticky mode checks and the restoring of a client's group and
_NET_WM_DESKTOP from the config-based auto-grouping; no (intentional)
behavior changes.  Needed for further work in cleaning up this area.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.302 2015/08/24 15:42:57 okan Exp $
d150 1
a201 1
	struct group_ctx	*group;
@


1.302
log
@Implement _NET_CLIENT_LIST_STACKING (from Thomas Admin), but
bottom-to-top order, as per spec (notified Thomas as well).
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.301 2015/08/24 14:56:10 okan Exp $
d429 2
a430 1
void			 group_autogroup(struct client_ctx *);
d439 1
@


1.301
log
@Sort _NET_WM_STATE Atoms like the spec.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.300 2015/08/21 16:53:48 okan Exp $
d355 1
d566 1
@


1.300
log
@Add Xkb modifier to ignore mask; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.299 2015/08/21 16:52:37 okan Exp $
a367 1
	_CWM_WM_STATE_FREEZE,
d374 1
@


1.299
log
@Fix whitespace.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.298 2015/08/21 16:30:02 okan Exp $
d51 1
a51 1
#define IGNOREMODMASK	(LockMask | Mod2Mask)
@


1.298
log
@Add client freeze extension to _NET_WM_STATE Atom, allowing flag to
persist. As usual with new Atoms, requires X restart.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.297 2015/07/12 14:31:47 okan Exp $
d46 6
a51 6
#define BUTTONMASK	(ButtonPressMask|ButtonReleaseMask)
#define MOUSEMASK	(BUTTONMASK|PointerMotionMask)
#define MENUMASK 	(MOUSEMASK|ButtonMotionMask|ExposureMask)
#define MENUGRABMASK	(MOUSEMASK|ButtonMotionMask|StructureNotifyMask)
#define KEYMASK		(KeyPressMask|ExposureMask)
#define IGNOREMODMASK	(LockMask|Mod2Mask)
@


1.297
log
@introduce 'groupsearch' for group menu search; matches on either group
number/shortcut and/or name.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.296 2015/06/30 18:54:12 okan Exp $
d367 2
a368 1
#define	_NET_WM_STATES_NITEMS	6
@


1.296
log
@Introduce a callback for cmd menu printing, special-casing 'lock' and
'term'.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.295 2015/06/26 17:17:46 okan Exp $
d453 1
d500 1
@


1.295
log
@Mechanical change from xinerama to region backed areas.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.294 2015/06/26 16:11:21 okan Exp $
d452 1
@


1.294
log
@collect 'gap' applications
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.293 2015/06/26 15:21:58 okan Exp $
d455 1
a455 2
struct geom		 screen_find_xinerama(struct screen_ctx *,
    			     int, int, int);
@


1.293
log
@Replace screen region info gathering with XRandR equivalent of Xinerama
queries (currently act on XRandR events anyway). Fall-back mode without
XRandR is still what X provides. This removes -lXinerama.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.292 2015/06/09 13:02:15 okan Exp $
d453 1
@


1.292
log
@typo in comment; from jsteinha [at] iutbayonne.univ-pau.fr
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.291 2015/06/08 15:11:29 okan Exp $
a30 1
#include <X11/extensions/Xinerama.h>
@


1.291
log
@stash window dimensions
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.290 2015/06/05 15:01:51 okan Exp $
d173 1
a173 1
		int		 h;	/* hieght */
@


1.290
log
@add a flag to indicate a menu list instead of overloading 'prompt'
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.289 2015/05/21 00:37:04 okan Exp $
d172 4
@


1.289
log
@merge kbd and mouse grouptoggle
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.288 2015/05/20 23:54:39 okan Exp $
d76 1
@


1.288
log
@fill in mwm defines
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.287 2015/05/17 04:34:01 kspillner Exp $
a497 2
void			 mousefunc_client_grouptoggle(struct client_ctx *,
			    union arg *);
@


1.287
log
@Make window name and window class separate parameters to conf_autogroup.
No functional change, but will be used shortly.

ok okan@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.286 2015/03/28 23:12:47 okan Exp $
d307 14
a320 3
#define MWM_NUMHINTS		3
#define	PROP_MWM_HINTS_ELEMENTS	3
#define	MWM_HINTS_DECORATIONS	(1<<1)
d323 5
@


1.286
log
@Introduce a xreallocarray and convert a few xcalloc instances that do
not require zero'ing.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.285 2015/03/26 21:41:43 okan Exp $
d503 2
a504 1
void			 conf_autogroup(struct conf *, int, const char *);
@


1.285
log
@Simplify key/mb binding moving argtype into flags and dropping another
variable; removes the need to zero out struct binding, leaving a simple
malloc.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.284 2015/01/19 14:54:16 okan Exp $
d562 1
@


1.284
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.283 2014/10/08 12:48:51 okan Exp $
d87 1
a255 1
	int			 argtype;
@


1.283
log
@make group_init work like other *_init's
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.282 2014/09/27 19:04:32 okan Exp $
d263 1
a263 1
	char			 path[MAXPATHLEN];
d295 1
a295 1
	char			 known_hosts[MAXPATHLEN];
@


1.282
log
@these have nothing to do with 'sticky', but rather group membership; rename.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.281 2014/09/23 14:25:08 okan Exp $
a204 1
	struct client_ctx_q	 clientq;
d207 1
d413 1
a413 1
void			 group_init(struct screen_ctx *);
@


1.281
log
@Update _NET_CURRENT_DESKTOP with the screen's group_active->num.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.280 2014/09/23 13:45:48 okan Exp $
d417 2
a418 2
void			 group_sticky_toggle_enter(struct client_ctx *);
void			 group_sticky_toggle_exit(struct client_ctx *);
@


1.280
log
@Move stuff that doesn't belong in group_init; while here, explicitly
initialize hideall and cycling.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.279 2014/09/17 18:41:44 okan Exp $
d547 1
a547 1
void			 xu_ewmh_net_current_desktop(struct screen_ctx *, long);
@


1.279
log
@these client actions are just toggles; less confusing with better names
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.278 2014/09/17 16:32:53 okan Exp $
d232 1
d239 3
a244 4
#define CALMWM_NGROUPS		 10
	struct group_ctx_q	 groupq;
	int			 group_hideall;
	struct group_ctx	*group_active;
@


1.278
log
@Use a similarly named check as sticky for hidden check in a group.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.277 2014/09/17 16:00:44 okan Exp $
a373 2
void			 client_freeze(struct client_ctx *);
void			 client_fullscreen(struct client_ctx *);
a375 1
void			 client_hidden(struct client_ctx *);
a376 1
void			 client_hmaximize(struct client_ctx *);
a379 1
void			 client_maximize(struct client_ctx *);
d392 7
a398 1
void			 client_sticky(struct client_ctx *);
a401 1
void			 client_vmaximize(struct client_ctx *);
a443 3
void			 kbfunc_client_freeze(struct client_ctx *, union arg *);
void			 kbfunc_client_fullscreen(struct client_ctx *,
			     union arg *);
a449 2
void			 kbfunc_client_hmaximize(struct client_ctx *,
			     union arg *);
a451 2
void			 kbfunc_client_maximize(struct client_ctx *,
			     union arg *);
d461 11
a471 2
void			 kbfunc_client_sticky(struct client_ctx *, union arg *);
void			 kbfunc_client_vmaximize(struct client_ctx *,
@


1.277
log
@Implement EWMH _NET_WM_STATE_HIDDEN.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.276 2014/09/17 14:31:37 okan Exp $
a408 1
int			 group_hidden_state(struct group_ctx *);
d411 1
@


1.276
log
@Introduce a check to see if a group holds only 'sticky' clients and use
this check to decide if a group is virtually empty.  Rationale: if a
group contains *only* 'sticky' clients, it should be skipped while
cycling through groups.  Apply similar logic to the group menu.

Based on an idea from phessler@@, who also tested another version.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.275 2014/09/10 20:30:38 okan Exp $
d347 1
a347 1
#define	_NET_WM_STATES_NITEMS	5
d351 1
d378 1
@


1.275
log
@fold in 'active' into 'flags'
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.274 2014/09/08 21:15:14 okan Exp $
d410 1
a414 1
void			 group_sticky(struct client_ctx *);
@


1.274
log
@name the group client queue appropriately, like other queues
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.273 2014/09/08 20:11:22 okan Exp $
d183 1
a188 1
	int			 active;
@


1.273
log
@Remove duplicate client queue (mruq); instead, remove and take the
global Clientq and place it inside screen_ctx since every client belongs
to a screen, then use the same per screen clientq to track stacking
order (the sole reason for mruq).
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.272 2014/09/08 13:51:29 okan Exp $
d205 1
a205 1
	struct client_ctx_q	 clients;
@


1.272
log
@Now that a group knows its screen, only pass down the group_ctx.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.271 2014/09/07 20:57:26 okan Exp $
d146 2
a147 3
	TAILQ_ENTRY(client_ctx) entry;
	TAILQ_ENTRY(client_ctx) group_entry;
	TAILQ_ENTRY(client_ctx) mru_entry;
a200 1
TAILQ_HEAD(cycle_entry_q, client_ctx);
d236 1
a236 1
	struct cycle_entry_q	 mruq;
a315 1
extern struct client_ctx_q		 Clientq;
@


1.271
log
@Add screen_ctx to group_ctx, and populate on init.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.270 2014/09/07 17:38:38 okan Exp $
d411 1
a411 1
void			 group_hide(struct screen_ctx *, struct group_ctx *);
d416 1
a416 1
void			 group_show(struct screen_ctx *, struct group_ctx *);
@


1.270
log
@screen_fromroot -> screen_find
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.269 2014/09/07 17:27:20 okan Exp $
d206 1
@


1.269
log
@Get rid of a redundant array of groups per screen; we already have a
link to the group queue for each screen.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.268 2014/09/06 16:14:35 okan Exp $
d433 1
a435 1
struct screen_ctx	*screen_fromroot(Window);
@


1.268
log
@Move termpath and lockpath into cmdq; side effect is that 'lock' and
'term' now show up in the application menu.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.267 2014/09/06 16:08:58 okan Exp $
a242 1
	struct group_ctx	 groups[CALMWM_NGROUPS];
@


1.267
log
@Rework group names: stash the group name inside the group_ctx as opposed
to having to manage an array outside in screen_ctx for group names and
shortcuts.  Simplifies (and moves bits for) reading, and constructing
data for, EWMH's _NET_DESKTOP_NAMES.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.266 2014/09/01 18:04:58 okan Exp $
a296 2
	char			 termpath[MAXPATHLEN];
	char			 lockpath[MAXPATHLEN];
@


1.266
log
@Merge group_menu into mousefunc_menu_group.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.265 2014/08/25 14:31:22 okan Exp $
d207 1
a245 1
	int			 group_nonames;
a246 1
	char 			**group_names;
@


1.265
log
@Since the flatting out of sc->group_names is only for setting
NET_DESKTOP_NAMES, merge the helper into xu_ewmh_net_desktop_names,
where we actually set the property.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.264 2014/08/25 12:49:19 okan Exp $
d413 2
a416 1
void			 group_menu(struct screen_ctx *);
d419 1
@


1.264
log
@Implement _NET_WM_STATE_STICKY, bound to CM-s by default; allows any
client to 'stick' to all desktops (ewmh speak) or groups - this
currently has the same affect as setting a client's group to 'nogroup',
with the exception that the client can also be in a group, so when
un-sticking, the client will go back to its original group/desktop.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.263 2014/08/24 15:37:45 okan Exp $
d548 1
a548 2
void			 xu_ewmh_net_desktop_names(struct screen_ctx *, char *,
			     int);
@


1.263
log
@gc->hidden has never consistently kept track of a group's state;
group_show() and group_hide() are not the only ways a group can change
state - if all clients in a group are either hidden or unhidden, then
that group's state should change, as well as the various EWMH ways.
Instead of trying to keep track in a wide variety of places, simply
query the clients in a group before needing to take action based on the
group's state.  Solves long standing confusion of when a group is hidden
or not.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.262 2014/08/20 15:15:29 okan Exp $
d183 1
d353 2
a354 1
#define	_NET_WM_STATES_NITEMS	4
d401 1
d470 1
@


1.262
log
@Purely mechanical; unify 'num', 'no' and 'shortcut'.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.261 2014/08/19 12:47:51 okan Exp $
a206 1
	int			 hidden;
a414 1
void			 group_set_state(struct screen_ctx *);
@


1.261
log
@Pull highstack from group_ctx (and useless calculations of); in the one
place that we use highstack, replace that usage with a local variable
(for now until stacking is done properly).
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.260 2014/08/18 13:57:57 okan Exp $
d206 1
a206 1
	int			 shortcut;
@


1.260
log
@Get rid of nhidden in group_ctx; it actually never reported correctly
since nhidden wasn't incremented nor decremeted in all the right places,
thus confusing matters.  We don't need to carry a count around, so just
use a local variable in the one place we need one to supply
XRestackWindows().
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.259 2014/02/08 02:49:30 okan Exp $
a207 1
	int			 highstack;
@


1.259
log
@Make sure we cycle through existing client's group membership and set
the hidden state on the group; important to know group hidden state
after a re-exec or restart of cwm (as easily seen in group menu).
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.258 2014/02/03 21:07:47 okan Exp $
a207 1
	int			 nhidden;
@


1.258
log
@Introduce a region queue and replace screen's XineramaScreenInfo; we
still use Xinerama to populate the regions per screen, but will switch
at a more appropriate time.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.257 2014/02/03 20:20:39 okan Exp $
d418 1
@


1.257
log
@Move redundant bits from screen_init (while dealing with existing
clients) directly into client_init, performing the X roundtrip only
once. With the previous change in maprequest, this moves decision making
into one place for creating new clients.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.256 2014/02/02 16:29:04 okan Exp $
d221 7
d239 1
a242 2
	int			 xinerama_no;
	XineramaScreenInfo	*xinerama;
@


1.256
log
@No need to store screen colormap and visual; rather just use the X
macros in the one place they are needed.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.255 2014/02/02 15:46:05 okan Exp $
d386 1
a386 1
struct client_ctx	*client_init(Window, struct screen_ctx *, int);
@


1.255
log
@The menu already limits entries with MENU_MAXENTRY, so don't bother
holding a command name limit as well.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.254 2014/01/30 22:17:22 okan Exp $
a223 2
	Visual			*visual;
	Colormap		 colormap;
@


1.254
log
@Switch ignoreq to winname struct since it's basically the same thing;
removes limit on name matching.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.253 2014/01/30 15:41:11 okan Exp $
d262 3
a264 4
	TAILQ_ENTRY(cmd)	entry;
#define CMD_MAXNAMELEN		256
	char			name[CMD_MAXNAMELEN];
	char			path[MAXPATHLEN];
@


1.253
log
@Move cwm_status around to avoid header fu, and remove extraneous signal
header from xevents.c; noticed by Christian Neukirchen.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.252 2014/01/30 14:40:21 okan Exp $
d143 1
a202 7
struct winmatch {
	TAILQ_ENTRY(winmatch)	entry;
#define WIN_MAXTITLELEN		256
	char			title[WIN_MAXTITLELEN];
};
TAILQ_HEAD(winmatch_q, winmatch);

d285 1
a285 1
	struct winmatch_q	 ignoreq;
d512 1
a512 1
int			 conf_ignore(struct conf *, const char *);
@


1.252
log
@Remove duplicate mouse functions and instead use the kbfunc ones.  No
user visable changes at this point, but they'll merge at an appropriate
time.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.251 2014/01/29 22:30:00 okan Exp $
a329 1
extern volatile sig_atomic_t		 cwm_status;
@


1.251
log
@Minimize trivial differences between a few kb and mb functions.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.250 2014/01/29 21:13:52 okan Exp $
a484 2
void			 mousefunc_client_cyclegroup(struct client_ctx *,
			    union arg *);
a486 4
void			 mousefunc_client_hide(struct client_ctx *,
    			    union arg *);
void			 mousefunc_client_lower(struct client_ctx *,
    			    union arg *);
a487 2
    			    union arg *);
void			 mousefunc_client_raise(struct client_ctx *,
@


1.250
log
@Merge keybinding and mousebinding queues into using the same merged
struct, binding; they were essentially the same accept for what was
'pressed', keysym or button.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.249 2014/01/29 18:34:22 okan Exp $
d480 1
a480 1
void			 kbfunc_menu_search(struct client_ctx *, union arg *);
@


1.249
log
@Check command name/path for truncation and provide user feedback during
config parse (and use conf_cmd_add to populate defaults); based on a
discussion with Tiago Cunha.  While this looks ugly, there are likely
some other changes here to come.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.248 2014/01/28 20:22:21 okan Exp $
d97 5
d255 2
a256 2
struct keybinding {
	TAILQ_ENTRY(keybinding)	 entry;
d260 1
a260 1
	KeySym			 keysym;
d264 2
a265 11
TAILQ_HEAD(keybinding_q, keybinding);

struct mousebinding {
	TAILQ_ENTRY(mousebinding)	entry;
	void			 	(*callback)(struct client_ctx *, union arg *);
	union arg			argument;
	unsigned int			modmask;
	unsigned int		 	button;
	int				flags;
};
TAILQ_HEAD(mousebinding_q, mousebinding);
d289 1
a292 1
	struct mousebinding_q	 mousebindingq;
@


1.248
log
@Check ignore windowname for truncation and provide user feedback during
config parse; based on a discussion with Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.247 2014/01/22 21:48:27 okan Exp $
d525 1
a525 1
void			 conf_cmd_add(struct conf *, const char *,
@


1.247
log
@Somewhat streamline event loop/restart/quit handling; most notable
change allows a restart to trigger proper teardown first, even though
teardown is not (yet) complete.

After some discussion with oga@@nicotinebsd.org regarding a more
complicated version/idea.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.246 2014/01/21 15:42:44 okan Exp $
d531 1
a531 1
void			 conf_ignore(struct conf *, const char *);
@


1.246
log
@Sprinkle a few more const; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.245 2014/01/20 23:03:51 okan Exp $
d88 4
d334 1
d481 1
a484 2
void			 kbfunc_quit_wm(struct client_ctx *, union arg *);
void			 kbfunc_restart(struct client_ctx *, union arg *);
d534 1
a534 1
void			 xev_loop(void);
@


1.245
log
@merge KBFLAG_NEEDCLIENT and MOUSEBIND_CTX_*; brings kbfunc and mousefunc
bits even closer.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.244 2014/01/20 22:31:53 okan Exp $
d328 1
a328 1
extern char				*homedir;
d505 1
a505 1
			     char *, char *, int,
@


1.244
log
@Use argument to pass down flags for mousefunc cyclegroup; removes
rcyclegroup wrapper need - now similar to kbfunc.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.243 2014/01/20 21:34:32 okan Exp $
d86 2
a251 1
#define KBFLAG_NEEDCLIENT	 0x0001
a262 2
#define MOUSEBIND_CTX_ROOT		0x0001
#define MOUSEBIND_CTX_WIN		0x0002
@


1.243
log
@constify and rename some confusing variables around cmdq.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.242 2014/01/20 19:06:04 okan Exp $
a497 2
void			 mousefunc_client_rcyclegroup(struct client_ctx *,
    			   union arg *);
@


1.242
log
@ - remove redundant range check for buttons in conf_bind_mouse.
 - make conf_bind_kbd return error on non-matches to match what
   conf_bind_mouse does.
 - rename some variables while here for clarity.
 - constify bind and cmd.

from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.241 2014/01/20 18:58:03 okan Exp $
d270 3
a272 3
	char			image[MAXPATHLEN];
#define CMD_MAXLABELLEN		256
	char			label[CMD_MAXLABELLEN];
d517 1
a517 1
void			 conf_autogroup(struct conf *, int, char *);
d524 2
a525 1
void			 conf_cmd_add(struct conf *, char *, char *);
d530 1
a530 1
void			 conf_ignore(struct conf *, char *);
@


1.241
log
@Add a function that adds an entry to a menuq, normalizing a common code
path; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.240 2014/01/03 15:29:06 okan Exp $
d518 4
a521 2
void			 conf_bind_kbd(struct conf *, char *, char *);
int			 conf_bind_mouse(struct conf *, char *, char *);
@


1.240
log
@use consistent types
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.239 2014/01/02 21:30:20 okan Exp $
d511 1
@


1.239
log
@bring mousefunc closer to kbfunc
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.238 2014/01/02 21:17:23 okan Exp $
d140 1
a140 1
	u_int			 bwidth; /* border width */
d248 1
a248 1
	u_int			 modmask;
d260 2
a261 2
	u_int				modmask;
	u_int			 	button;
d314 3
a316 3
	u_long	flags;
	u_long	functions;
	u_long	decorations;
d531 1
a531 1
void			 xu_btn_grab(Window, int, u_int);
d535 1
a535 1
void			 xu_key_grab(Window, u_int, KeySym);
d538 2
a539 2
int			 xu_ptr_grab(Window, u_int, Cursor);
int			 xu_ptr_regrab(u_int, Cursor);
@


1.238
log
@gc keycode in keybinding since we only deal with keysym now
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.237 2013/12/16 19:02:17 okan Exp $
d258 2
a259 1
	void			 	(*callback)(struct client_ctx *, void *);
d487 1
a487 1
			    void *);
d489 9
a497 5
			    void *);
void			 mousefunc_client_hide(struct client_ctx *, void *);
void			 mousefunc_client_lower(struct client_ctx *, void *);
void			 mousefunc_client_move(struct client_ctx *, void *);
void			 mousefunc_client_raise(struct client_ctx *, void *);
d499 7
a505 5
    			   void *);
void			 mousefunc_client_resize(struct client_ctx *, void *);
void			 mousefunc_menu_cmd(struct client_ctx *, void *);
void			 mousefunc_menu_group(struct client_ctx *, void *);
void			 mousefunc_menu_unhide(struct client_ctx *, void *);
@


1.237
log
@Implement support for EWMH's _NET_WM_STATE_FULLSCREEN hint.

Since we already have a form of 'maximize', we need to differentiate
between 'maximize' and the new 'fullscreen' mode.  The 'maximize' mode
will continue to honor gap but now *retains* the border, matching the
'vert/horz maximize' behaviour.  The new 'fullscreen' mode supports and
follows the _NET_WM_STATE_FULLSCREEN hint, allowing the client perform
additional window modifications; in this mode, cwm(1) will *ignore* gap,
remove borders and freeze(move/resize) the client.  Additionally,
'fullscreen' mode will remember various combinations of previous states.

* default keybinding changes: CM-f 'fullscreen', CM-m 'maximize' (re-map
  as desired).

Positive feedback from a few, testing and ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.236 2013/12/13 22:39:13 okan Exp $
a249 1
	int			 keycode;
@


1.236
log
@Teach screen_find_xinerama() to apply gap only when told to do so;
adjust callers.  Needed for an upcoming feature.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.235 2013/12/13 14:40:52 okan Exp $
d141 1
a141 1
	struct geom		 geom, savegeom;
d170 1
d359 1
a359 1
#define	_NET_WM_STATES_NITEMS	3
d362 1
d385 1
d451 2
@


1.235
log
@Add support for XUrgency and matching _NET_WM_STATE_DEMANDS_ATTENTION
ewmh hint; urgencyborder is configurable.  The urgency flag will stick,
even while on a client in a non-viewable group, until the client
receives focus (where the border is reset).  Initial diff from Thomas
Adam with some changes/enhancements from me.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.234 2013/12/12 20:15:07 okan Exp $
d83 3
d436 2
a437 1
struct geom		 screen_find_xinerama(struct screen_ctx *, int, int);
@


1.234
log
@ICCCM explicitly states that server time (CurrentTime) should *not* be
used for focus events, but rather the timestamp of the generated event.
Track the last event timestamp and send it down for a WM_TAKE_FOCUS
ClientMessage.  I suspect we should do this for clients that don't
announce this Atom as well, though the raciness gets us into a bind.

Solves focus order issue since WM_TAKE_FOCUS; fix verified by sthen@@

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.233 2013/12/11 15:41:11 okan Exp $
d100 1
d166 1
d355 1
a355 1
#define	_NET_WM_STATES_NITEMS	2
d358 1
d402 1
@


1.233
log
@Add client wrapper for XWMHints to support XA_WM_HINTS in PropertyNotify
events; based off a diff from Thomas Adam.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.232 2013/12/11 14:16:09 okan Exp $
d319 1
d385 1
a385 1
void			 client_msg(struct client_ctx *, Atom);
@


1.232
log
@Remove extra work and simplify client state handling.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.231 2013/12/11 14:09:21 okan Exp $
d401 1
@


1.231
log
@Stash Class and WM Hints in client_ctx
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.230 2013/11/27 18:34:34 okan Exp $
a169 1
	int			 state;
d376 1
d392 1
a512 1
int			 xu_get_wm_state(Window, int *);
a520 1
void			 xu_set_wm_state(Window win, int);
@


1.230
log
@like gap, make snapdist per screen
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.229 2013/11/27 00:01:23 okan Exp $
d180 2
a181 2
	char			*app_class;
	char			*app_name;
@


1.229
log
@Rewrite active/inactive client handling in client_setactive();
client_leave() served no real purpose, likewise no reason to handle
LeaveNotify events since an EnterNotify will process the next active
client (and we don't have anything important to process anyway), so
xev_handle_leavenotify() goes as well.  Allows a simplification of
client_mtf() and client_cycle_leave() for clarity.  While here, unify a
few client_current() checks.

No intended behaviour change.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.228 2013/11/12 21:25:00 okan Exp $
d219 1
@


1.228
log
@Alter the r1.35 of event.c race fix.  Remove the forward looking event
queue check (removing the need for a server grab/ungrab) - if the client
is going away, let it fall all the way through to a DestroyNotify event.
There's no longer a need for us to manually destroy a client ourselves
(removing yet another server grab/ungrab).  Instead, when the
UnmapNotify event is synthetic, simply set the state to Withdrawn (as
per ICCCM), else Iconic (in our case 'hidden').

Verified with test case from the 2009 race which was the original reason
for r1.35 of event.c.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.227 2013/11/08 17:35:12 okan Exp $
d371 1
a371 2
void			 client_cycle_leave(struct screen_ctx *,
			     struct client_ctx *);
a379 1
void			 client_leave(struct client_ctx *);
d391 1
a391 1
void			 client_setactive(struct client_ctx *, int);
@


1.227
log
@stash WMProtocols in flags
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.226 2013/11/02 19:13:56 okan Exp $
d373 1
a373 1
void			 client_delete(struct client_ctx *, int);
@


1.226
log
@The only reason we need to keep XSizeHints in our client_ctx is for
flags, so just add one to hints; consolidates sizehints and shrinks.
Additionally don't abuse PSize for XGetWMNormalHints() failures.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.225 2013/11/01 14:07:19 okan Exp $
a128 5
enum wm_protocols {
	_WM_DELETE_WINDOW	= 0x0001,
	_WM_TAKE_FOCUS		= 0x0002,
};

a154 1
	enum wm_protocols	 xproto;
d163 2
@


1.225
log
@re-add support for WM_TAKE_FOCUS, and additionally this time only call
XSetInputFocus() for clients that have the InputHint; latter fix
discovered by Valery Masiutsin with a PoC patch - solves keyboard input
focus loss for java apps.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.224 2013/10/25 19:46:16 okan Exp $
a139 1
	XSizeHints		*size;
d144 1
@


1.224
log
@A client_delete should behave differently depending on whether the
triggering event was unmap (with pending destroy) log destroy; we only
need to grab/ungrab the server lock, set WithdrawnState and
XRemoveFromSaveSet clients coming from an unmap event - doing so for
clients coming from destroy are already gone, hence we generate errors.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.223 2013/10/20 01:55:32 okan Exp $
d168 1
@


1.223
log
@wrap key ungrab like btn ungrab, for it'll be used again
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.222 2013/10/19 19:39:34 okan Exp $
d376 1
a376 1
void			 client_delete(struct client_ctx *);
@


1.222
log
@Using xu_btn_ungrab() buttons during client_leave doesn't work (error
BadValue) when the modifier is already AnyModifier .  Instead alter
xu_btn_ungrab() to ungrab AnyButton/AnyModifier and call it only when a
client is coming into focus in client_setactive(), instead of iterating
over ignore mods - matches how we handle key grabs.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.221 2013/10/03 13:51:57 okan Exp $
d519 1
@


1.221
log
@unify type; no change
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.220 2013/07/16 14:04:44 okan Exp $
d514 1
a514 1
void			 xu_btn_ungrab(Window, int, u_int);
@


1.220
log
@max -> nitems
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.219 2013/07/15 23:53:19 okan Exp $
d515 1
a515 1
int			 xu_getprop(Window, Atom, Atom, long, u_char **);
@


1.219
log
@shuffle down protoypes
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.218 2013/07/15 14:50:44 okan Exp $
d106 1
a106 1
	CWM_COLOR_MAX
d226 1
a226 1
	XftColor		 xftcolor[CWM_COLOR_MAX];
d300 1
a300 1
	char			*color[CWM_COLOR_MAX];
@


1.218
log
@simplify atom handling; allows us to limit to one round-trip to server
for gathering Atoms.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.217 2013/07/09 01:24:49 okan Exp $
d321 47
a559 50

/* Externs */
extern Display				*X_Dpy;

extern struct screen_ctx_q		 Screenq;
extern struct client_ctx_q		 Clientq;
extern struct conf			 Conf;
extern char				*homedir;

extern int				 HasRandr, Randr_ev;

enum {
	WM_STATE,
	WM_DELETE_WINDOW,
	WM_TAKE_FOCUS,
	WM_PROTOCOLS,
	_MOTIF_WM_HINTS,
	UTF8_STRING,
	WM_CHANGE_STATE,
	CWMH_NITEMS
};
enum {
	_NET_SUPPORTED,
	_NET_SUPPORTING_WM_CHECK,
	_NET_ACTIVE_WINDOW,
	_NET_CLIENT_LIST,
	_NET_NUMBER_OF_DESKTOPS,
	_NET_CURRENT_DESKTOP,
	_NET_DESKTOP_VIEWPORT,
	_NET_DESKTOP_GEOMETRY,
	_NET_VIRTUAL_ROOTS,
	_NET_SHOWING_DESKTOP,
	_NET_DESKTOP_NAMES,
	_NET_WORKAREA,
	_NET_WM_NAME,
	_NET_WM_DESKTOP,
	_NET_CLOSE_WINDOW,
	_NET_WM_STATE,
#define	_NET_WM_STATES_NITEMS	2
	_NET_WM_STATE_MAXIMIZED_VERT,
	_NET_WM_STATE_MAXIMIZED_HORZ,
	EWMH_NITEMS
};
enum {
	_NET_WM_STATE_REMOVE,
	_NET_WM_STATE_ADD,
	_NET_WM_STATE_TOGGLE
};
extern Atom				 cwmh[CWMH_NITEMS];
extern Atom				 ewmh[EWMH_NITEMS];
@


1.217
log
@since the root and event window are the same in the case of a button
event on the screen's root window, there's no need to pass down the
entire XButtonEvent event, at least to group_menu(), the only callback
which takes an argument at this point; instead use the already populated
screen.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.216 2013/07/08 18:39:20 okan Exp $
d450 1
a467 1
void			 xu_getatoms(void);
d561 2
a562 6
struct atom_ctx {
	char	*name;
	Atom	 atom;
};
extern struct atom_ctx			 cwmh[CWMH_NITEMS];
extern struct atom_ctx			 ewmh[EWMH_NITEMS];
@


1.216
log
@add support for mouse based group {,r}cycle; from Rodrigo Mosconi.  not
bound by default.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.215 2013/07/08 18:19:22 okan Exp $
d363 1
a363 1
void			 group_menu(XButtonEvent *);
@


1.215
log
@move kbfunc and mousefunc closer together
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.214 2013/07/08 16:32:51 okan Exp $
d427 2
d435 2
@


1.214
log
@clarify kbd vs mouse functions
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.213 2013/06/17 17:11:10 okan Exp $
d261 1
a261 1
	int				context;
d406 2
a420 1
void			 kbfunc_moveresize(struct client_ctx *, union arg *);
d427 7
a436 7
void			 mousefunc_window_grouptoggle(struct client_ctx *,
			    void *);
void			 mousefunc_window_hide(struct client_ctx *, void *);
void			 mousefunc_window_lower(struct client_ctx *, void *);
void			 mousefunc_window_move(struct client_ctx *, void *);
void			 mousefunc_window_raise(struct client_ctx *, void *);
void			 mousefunc_window_resize(struct client_ctx *, void *);
@


1.213
log
@move Cursors into conf.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.212 2013/06/10 21:37:30 okan Exp $
d446 2
a447 1
void			 conf_bindname(struct conf *, char *, char *);
a455 1
int			 conf_mousebind(struct conf *, char *, char *);
@


1.212
log
@move synthetic responses and have client_msg only work with WM_PROTOCOLS,
since that's all ClientMessageEvent is for anyway.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.211 2013/05/27 23:20:45 okan Exp $
d88 9
d306 1
d450 1
a510 6

extern Cursor				 Cursor_default;
extern Cursor				 Cursor_move;
extern Cursor				 Cursor_normal;
extern Cursor				 Cursor_question;
extern Cursor				 Cursor_resize;
@


1.211
log
@fix type in a ClientMessage (xu_sendmsg).
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.210 2013/05/23 16:52:39 okan Exp $
d314 1
d331 1
a450 1
void			 xu_configure(struct client_ctx *);
a460 1
void			 xu_sendmsg(Window, Atom, Atom);
@


1.210
log
@alter conf_grab(_kbd) to first ungrab AnyKey/AnyModifier, then proceed
to grab keys in keybindingq.  we don't need to ungrab/grab on every
addition to the queue, just once with a complete keybindingq; simplify
grabbing keys per screen (during init) and during a MappingNotify.

while here, change conf_grab_{kbd,mouse} to require only a Window.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.209 2013/05/22 16:32:15 okan Exp $
d460 1
a460 1
void			 xu_sendmsg(Window, Atom, long);
@


1.209
log
@move validation of pointer Button into conf_mousebind so we check
validity during the parse phase and not bother adding it to the queue,
instead of each time a client needs to grab (when it's too late);
furthermore, make this a config error, stop parsing and load the
default config.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.208 2013/05/21 00:29:20 okan Exp $
d438 2
a439 2
void			 conf_grab(struct conf *, struct keybinding *);
void			 conf_grab_mouse(struct client_ctx *);
a443 1
void			 conf_ungrab(struct conf *, struct keybinding *);
a454 1
void			 xu_key_ungrab(Window, u_int, KeySym);
@


1.208
log
@handle _NET_WM_STATE ClientMessage; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.207 2013/05/20 21:13:58 okan Exp $
d442 1
a442 1
void			 conf_mousebind(struct conf *, char *, char *);
@


1.207
log
@add support for _NET_WM_STATE_MAXIMIZED_{HORZ,VERT}; from Alexander Polakov.

while I'm unsure of the final look of _NET_WM_STATE, there's no reason
to delay this support.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.206 2013/05/20 20:21:04 okan Exp $
d485 2
d547 5
@


1.206
log
@- configure menuwin with the screen, then create the xft drawable using
  the menu window since that's the only place on which we draw
- elminate the need to change the drawable on every font draw
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.205 2013/05/19 23:38:21 okan Exp $
d484 3
d540 4
@


1.205
log
@move the 2 small font helper functions to xutil.c
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.204 2013/05/19 23:16:29 okan Exp $
a428 1
void			 menu_init(struct screen_ctx *);
d465 1
a465 1
			     Drawable, int, int, int);
@


1.204
log
@move the rest of xft init into screen_conf, since most of it is based on
config parameters.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.203 2013/05/19 23:09:59 okan Exp $
a446 4
void			 font_draw(struct screen_ctx *, const char *,
			     Drawable, int, int, int);
int			 font_width(XftFont *, const char *, int);

d465 3
@


1.203
log
@- switch border colors to Xft
- merge border/menu color structures/functions since they now both use Xft
- switch xu_xorcolor to operating on XftColor instead of just
  XRenderColor (basically adding pixel)
- if color name allocation fails, revert back to default (this, along
  with font validation should occur during config parse, but we don't
  have screens setup yet - likely to change at some point)
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.202 2013/05/19 17:05:52 okan Exp $
a448 1
void			 font_init(struct screen_ctx *, const char *);
@


1.202
log
@add support for _NET_CLOSE_WINDOW
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.201 2013/05/19 17:03:55 okan Exp $
d88 5
a92 1
enum menucolor {
d97 1
a97 9
	CWM_COLOR_MENU_MAX
};

enum bordercolor {
	CWM_COLOR_BORDER_ACTIVE,
	CWM_COLOR_BORDER_INACTIVE,
	CWM_COLOR_BORDER_GROUP,
	CWM_COLOR_BORDER_UNGROUP,
	CWM_COLOR_BORDER_MAX
a211 1
	unsigned long		 color[CWM_COLOR_BORDER_MAX];
d217 1
a217 1
	XftColor		 xftcolor[CWM_COLOR_MENU_MAX];
d291 1
a291 2
	char			*color[CWM_COLOR_BORDER_MAX];
	char		 	*menucolor[CWM_COLOR_MENU_MAX];
d449 1
a449 2
void			 font_init(struct screen_ctx *, const char *,
			     const char **);
a457 1
unsigned long		 xu_getcolor(struct screen_ctx *, char *);
d470 1
a470 2
void 			 xu_xorcolor(XRenderColor, XRenderColor,
			     XRenderColor *);
@


1.201
log
@treat WM_CHANGE_STATE like other atoms
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.200 2013/05/19 17:02:04 okan Exp $
d548 1
@


1.200
log
@use XGetWMProtocols and simplify WM_PROTOCOL handling
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.199 2013/05/14 12:35:56 okan Exp $
d530 1
@


1.199
log
@- let callers of font_draw figure out (and pass) the color instead of an
  'active' flag.
- use strlen() inside of font_draw; the only instance where it wasn't
  used happened to be ignored on a subsequent draw.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.198 2013/05/11 22:01:07 okan Exp $
d124 5
d155 1
a155 3
#define CLIENT_PROTO_DELETE		 0x0001
#define CLIENT_PROTO_TAKEFOCUS		 0x0002
	int			 xproto;
@


1.198
log
@new -> init
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.197 2013/05/11 21:46:27 okan Exp $
d450 1
a450 1
void			 font_draw(struct screen_ctx *, const char *, int,
@


1.197
log
@replace conf_{gap,color,font} with conf_screen since really we are
configuring the screen *after* parsing, just as we do a conf_client on
client manage.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.196 2013/05/10 16:32:47 okan Exp $
d334 1
a334 1
struct client_ctx	*client_new(Window, struct screen_ctx *, int);
@


1.196
log
@more type fixes for mask/button
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.195 2013/05/10 15:44:43 okan Exp $
a441 3
void			 conf_color(struct conf *, struct screen_ctx *);
void			 conf_font(struct conf *, struct screen_ctx *);
void			 conf_gap(struct conf *, struct screen_ctx *);
d447 1
@


1.195
log
@fix KeySym type
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.194 2013/05/06 16:03:11 okan Exp $
d238 1
a238 1
	int			 modmask;
d250 2
a251 2
	int				modmask;
	int			 	button;
d468 2
a469 2
void			 xu_key_grab(Window, int, KeySym);
void			 xu_key_ungrab(Window, int, KeySym);
d471 2
a472 2
int			 xu_ptr_grab(Window, int, Cursor);
int			 xu_ptr_regrab(int, Cursor);
@


1.194
log
@remove group in client_delete directly.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.193 2013/05/02 17:25:15 okan Exp $
d239 1
a239 1
	int			 keysym;
d468 2
a469 2
void			 xu_key_grab(Window, int, int);
void			 xu_key_ungrab(Window, int, int);
@


1.193
log
@no need for font_{ascent,descent,height} wrappers; limit font_width to
just requiring xftfont.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.192 2013/04/29 00:56:47 okan Exp $
a350 1
void			 group_client_delete(struct client_ctx *);
@


1.192
log
@use an int in screen_init and avoid needing to cast for screen number (which).
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.191 2013/04/17 13:57:06 okan Exp $
a452 2
int			 font_ascent(struct screen_ctx *);
int			 font_descent(struct screen_ctx *);
a454 1
u_int			 font_height(struct screen_ctx *);
d457 1
a457 1
int			 font_width(struct screen_ctx *, const char *, int);
@


1.191
log
@mechanical xu_{get,set}state -> xu_{get,set}_wm_state change
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.190 2013/04/17 13:52:20 okan Exp $
d208 1
a208 1
	u_int			 which;
d377 1
a377 1
void			 screen_init(u_int);
@


1.190
log
@slightly rework WM_STATE set/get to make it less ambigious; will be more clear
on what needs to change to make it right in the end.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.189 2013/04/17 13:30:38 okan Exp $
d470 1
a470 1
int			 xu_getstate(Window, int *);
d480 1
a480 1
void			 xu_setstate(Window win, int);
@


1.189
log
@add conf_ignore and move group_make_autogroup to conf_autogroup to match.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.188 2013/04/14 16:13:17 okan Exp $
d480 1
a480 1
void			 xu_setstate(struct client_ctx *, int);
@


1.188
log
@only a window is required to set WM_STATE.  also un-confuse xu_ptr_getpos
by using 'win' instead of 'rootwin' so as not to imply only the root
window is queried, rather any window.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.187 2013/04/12 14:46:30 okan Exp $
a354 1
void			 group_make_autogroup(struct conf *, char *, int);
d438 1
d449 1
@


1.187
log
@push Screenq into screen_init
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.186 2013/01/08 15:16:04 okan Exp $
d469 1
a469 1
int			 xu_getstate(struct client_ctx *, int *);
@


1.186
log
@add per-group vert/horiz tiling support; introduces 2 new bind commands,
'vtile' and 'htile'; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.185 2013/01/04 16:30:03 okan Exp $
d378 1
a378 1
void			 screen_init(struct screen_ctx *, u_int);
@


1.185
log
@rename {h,v}max functions for consistency; from Jan Stary
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.184 2013/01/04 16:27:58 okan Exp $
d79 4
d328 1
d346 1
d417 1
@


1.184
log
@really these are just border colors, so adjust the define
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.183 2013/01/04 16:23:04 okan Exp $
d323 1
a323 1
void			 client_horizmaximize(struct client_ctx *);
d340 1
a340 1
void			 client_vertmaximize(struct client_ctx *);
@


1.183
log
@get rid of struct color
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.182 2013/01/02 16:26:34 okan Exp $
d92 1
a92 1
enum cwmcolor {
d97 1
a97 1
	CWM_COLOR_MAX
d209 1
a209 1
	unsigned long		 color[CWM_COLOR_MAX];
d289 1
a289 1
	char			*color[CWM_COLOR_MAX];
@


1.182
log
@have screen_find_xinerama() return struct geom *reliably* instead of
XineramaScreenInfo; simplifies goop around the callers.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.181 2013/01/01 14:33:52 okan Exp $
a99 5
struct color {
	char		*name;
	unsigned long	 pixel;
};

d209 1
a209 1
	struct color		 color[CWM_COLOR_MAX];
d289 1
a289 1
	struct color		 color[CWM_COLOR_MAX];
@


1.181
log
@least intrusive way to plug a memleak when unbinding a duplicate key for
kbfunc_cmdexec; from Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.180 2013/01/01 14:19:56 okan Exp $
d375 1
a375 1
XineramaScreenInfo	*screen_find_xinerama(struct screen_ctx *, int, int);
@


1.180
log
@make num of groups no longer off-by-one; from Alexander Polakov

note that a re-exec of cwm will not rewrite the group number atom of
*existing* clients, so they will remain off-by-one until each client has
its atom updated, or of course a restart of X.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.179 2012/12/19 15:21:34 okan Exp $
d77 2
d244 1
@


1.179
log
@gc unused cmd 'flags' variable
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.178 2012/12/18 18:39:55 okan Exp $
a76 2
#define KBTOGROUP(X) ((X) - 1)

d223 1
a223 1
#define CALMWM_NGROUPS		 9
@


1.178
log
@expand CHILDMASK
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.177 2012/12/18 18:35:36 okan Exp $
a259 1
	int			flags;
d439 1
a439 1
void			 conf_cmd_add(struct conf *, char *, char *, int);
@


1.177
log
@use MOUSEMASK since we already have it
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.176 2012/12/18 17:44:18 okan Exp $
a46 1
#define CHILDMASK	(SubstructureRedirectMask|SubstructureNotifyMask)
@


1.176
log
@remove unused SEARCHMASK
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.175 2012/12/18 17:37:39 okan Exp $
d50 2
a52 4
#define MENUMASK 	(BUTTONMASK|ButtonMotionMask|ExposureMask| \
			PointerMotionMask)
#define MENUGRABMASK	(BUTTONMASK|ButtonMotionMask|StructureNotifyMask|\
			PointerMotionMask)
@


1.175
log
@define LockMask|Mod2Mask; no functional change
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.174 2012/12/18 00:14:41 okan Exp $
a54 1
#define SEARCHMASK	(KeyPressMask|ExposureMask)
@


1.174
log
@simplify config file setup; with Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.173 2012/12/17 23:54:57 okan Exp $
d56 1
@


1.173
log
@put a default known_hosts into conf
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.172 2012/12/17 23:03:41 okan Exp $
a450 1
void			 conf_setup(struct conf *, const char *);
@


1.172
log
@pull user home directory via getenv or getpwuid and stash it so we don't
need to do this everytime; with Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.171 2012/12/17 18:35:26 okan Exp $
d301 1
@


1.171
log
@cmap -> colormap in client_ctx
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.170 2012/12/17 18:34:06 okan Exp $
d522 1
@


1.170
log
@stash the default screen visual and colormap in screen_ctx
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.169 2012/12/17 17:48:57 okan Exp $
d135 1
a135 1
	Colormap		 cmap;
@


1.169
log
@replace client highlight with a client flag
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.168 2012/12/17 14:58:46 okan Exp $
d213 2
@


1.168
log
@make client_mtf static
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.167 2012/12/17 14:32:39 okan Exp $
d162 2
d165 1
a171 3
#define CLIENT_HIGHLIGHT_GROUP		0x0001
#define CLIENT_HIGHLIGHT_UNGROUP	0x0002
	int			 highlight;
@


1.167
log
@create and use menuq_clear() helper; from Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.166 2012/12/17 14:20:52 okan Exp $
a333 1
void			 client_mtf(struct client_ctx *);
@


1.166
log
@screen font -> xftfont
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.165 2012/12/17 02:53:29 okan Exp $
d434 1
@


1.165
log
@knf
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.164 2012/12/17 02:28:45 okan Exp $
d223 1
a223 1
	XftFont			*font;
@


1.164
log
@non-trivial menu drawing rewrite, moving to Xft and solving various
font/color drawing issues; from Alexander Polakov
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.163 2012/11/29 03:54:46 okan Exp $
d320 2
a321 1
void			 client_cycle_leave(struct screen_ctx *, struct client_ctx *);
d368 2
a369 2
void			 search_match_exec_path(struct menu_q *, struct menu_q *,
			     char *);
d479 2
d493 2
a494 1
void			 xu_ewmh_net_desktop_names(struct screen_ctx *, char *, int);
a496 2

void 			 xu_xorcolor(XRenderColor, XRenderColor, XRenderColor *);
@


1.163
log
@x_setupscreen -> screen_init; no functional change.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.162 2012/11/29 03:34:19 okan Exp $
d87 8
a99 3
	CWM_COLOR_FG_MENU,
	CWM_COLOR_BG_MENU,
	CWM_COLOR_FONT,
a215 1
	GC			 gc;
d221 1
a221 1
	XftColor		 xftcolor;
d296 1
d453 1
a453 1
			     Drawable, int, int);
d456 1
a456 1
			     const char *);
d494 1
@


1.162
log
@remove dead extern
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.161 2012/11/28 14:32:44 okan Exp $
d372 1
@


1.161
log
@add xasprintf() for upcoming changes.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.160 2012/11/28 14:14:44 okan Exp $
d512 1
a512 1
extern int				 HasXinerama, HasRandr, Randr_ev;
@


1.160
log
@replace hand rolled font_make() with XftFontOpenName() and merge into
font_init().
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.159 2012/11/08 20:18:19 okan Exp $
d495 3
@


1.159
log
@fix some warnings; inspired by a diff from Thordur Bjornsson.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.158 2012/11/07 20:34:39 okan Exp $
d449 2
a450 1
void			 font_init(struct screen_ctx *, const char *);
a451 1
XftFont			*font_make(struct screen_ctx *, const char *);
@


1.158
log
@get rid of the xfree() wrapper around free(); from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.157 2012/11/07 14:40:51 okan Exp $
d484 1
a484 1
void			 xu_ewmh_net_desktop_names(struct screen_ctx *, unsigned char *, int);
@


1.157
log
@spacing
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.156 2012/11/07 14:39:44 okan Exp $
a492 1
void			 xfree(void *);
@


1.156
log
@tab completion support for menus; from Alexander Polakov.

ok sthen@@ on an older incarnation
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.155 2012/10/31 22:06:24 okan Exp $
d77 2
a78 2
#define CWM_MENU_DUMMY 	0x0001
#define CWM_MENU_FILE 		0x0002
@


1.155
log
@no longer a reason to carry conf_path in struct conf, so dice.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.154 2012/10/31 19:30:19 okan Exp $
d76 4
d267 1
a267 1
#define MENU_MAXENTRY		 50
d361 4
@


1.154
log
@replace 'reload' with 'restart', which merely re-exec's cwm using the
existing argv; same idea with respect to argv saving as Alexander
Polakov.  reload support was half-complete and is getting in the way.

agreed to by many
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.153 2012/09/09 19:47:47 okan Exp $
a275 1
	char			 conf_path[MAXPATHLEN];
@


1.153
log
@extend client_resize so that it can know when to reset max flags and
bwidth; this allows a client to be resized from a max state, which now
gets treated like a non-max'd client.  based on a diff that does part of
this in a different way from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.152 2012/07/13 17:01:04 okan Exp $
d400 1
a400 1
void			 kbfunc_reload(struct client_ctx *, union arg *);
a433 1
void			 conf_reload(struct conf *);
a450 1
void			 xu_freecolor(struct screen_ctx *, unsigned long);
@


1.152
log
@re-use geom struct in client_ctx (saved)geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.151 2012/07/13 15:21:35 okan Exp $
d330 1
a330 1
void			 client_resize(struct client_ctx *);
@


1.151
log
@convert xmax/ymax uses to view geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.150 2012/07/13 14:18:04 okan Exp $
d128 1
a128 6
	struct {
		int		 x;	/* x position */
		int		 y;	/* y position */
		int		 width;	/* width */
		int		 height;/* height */
	} geom, savegeom;
@


1.150
log
@introduce screen "view" area and "work" area (gap applied) to simplify
various blocks that require understanding the screen geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.149 2012/07/06 14:18:00 okan Exp $
a213 2
	int			 xmax;
	int			 ymax;
@


1.149
log
@querying for Xinerama should be done per display, not per screen, so
move chuck to display init; allows some shuffling to occur limiting
screen_init_xinerama()'s scope while keeping order intact.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.148 2012/07/05 17:35:13 okan Exp $
d99 7
d216 2
@


1.148
log
@the display's width and height are updated after an XRandR event so we
don't need to pass down the new values to screen_update_geometry(); so
just read the width/height values directly for both uses of
screen_update_geometry().  prep for further changes in this area.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.147 2012/07/03 13:49:03 okan Exp $
a362 1
void			 screen_init_xinerama(struct screen_ctx *);
@


1.147
log
@re-implement atom handing; makes for a normalized and more consistent
separation between cwm and ewmh.  seen by a few.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.146 2012/05/16 01:17:14 okan Exp $
d364 1
a364 1
void			 screen_update_geometry(struct screen_ctx *, int, int);
@


1.146
log
@instead of using the menu window for _NET_SUPPORTING_WM_CHECK, create a
dummy one to use instead; allows us to not have to wait for menu_init(),
so re-shuffle _NET_SUPPORTED slightly.

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.145 2012/05/16 01:09:17 okan Exp $
d469 13
d506 32
a537 29
#define	WM_STATE			 cwm_atoms[0]
#define WM_DELETE_WINDOW		 cwm_atoms[1]
#define WM_TAKE_FOCUS			 cwm_atoms[2]
#define WM_PROTOCOLS			 cwm_atoms[3]
#define _MOTIF_WM_HINTS			 cwm_atoms[4]
#define	UTF8_STRING			 cwm_atoms[5]
/*
 * please make all hints below this point netwm hints, starting with
 * _NET_SUPPORTED. If you change other hints make sure you update
 * CWM_NETWM_START
 */
#define	_NET_SUPPORTED			 cwm_atoms[6]
#define	_NET_SUPPORTING_WM_CHECK	 cwm_atoms[7]
#define	_NET_WM_NAME			 cwm_atoms[8]
#define	_NET_ACTIVE_WINDOW		 cwm_atoms[9]
#define	_NET_CLIENT_LIST		 cwm_atoms[10]
#define	_NET_NUMBER_OF_DESKTOPS		 cwm_atoms[11]
#define	_NET_CURRENT_DESKTOP		 cwm_atoms[12]
#define	_NET_DESKTOP_VIEWPORT		 cwm_atoms[13]
#define	_NET_DESKTOP_GEOMETRY		 cwm_atoms[14]
#define	_NET_VIRTUAL_ROOTS		 cwm_atoms[15]
#define	_NET_SHOWING_DESKTOP		 cwm_atoms[16]
#define	_NET_DESKTOP_NAMES		 cwm_atoms[17]
#define	_NET_WM_DESKTOP			 cwm_atoms[18]
#define	_NET_WORKAREA			 cwm_atoms[19]
#define CWM_NO_ATOMS			 20
#define CWM_NETWM_START			 6

extern Atom				 cwm_atoms[CWM_NO_ATOMS];
@


1.145
log
@cycle through other common cycling modifiers; based on a diff from
Alexander Polakov.

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.144 2012/05/16 01:04:36 okan Exp $
d466 3
a468 1
void			 xu_setwmname(struct screen_ctx *);
@


1.144
log
@convert from deprecated XKeycodeToKeysym to XkbKeycodeToKeysym

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.143 2012/05/13 15:17:13 okan Exp $
d310 1
@


1.143
log
@altpersist->cycling to be more clear that this is for cycling mod
persistence; based on a diff from Alexander Polakov, in preparation for
looping through other potential cycling modifiers.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.142 2011/09/13 08:41:57 okan Exp $
d24 1
@


1.142
log
@add WM_TRANSIENT_FOR event support: moves dialogs, toolbars and such to
the group of the main application window; based on a diff from Alexander
Polakov with CLIENT_IGNORE flag suggestion from oga@@.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.141 2011/09/08 12:35:33 okan Exp $
d205 1
a205 1
	int			 altpersist;
@


1.141
log
@allow configurable menu font color; from Alexander Polakov with a tweak
from me.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.140 2011/09/04 16:59:31 oga Exp $
d331 1
@


1.140
log
@Make flavours of maximisation additive.

i.e. horiz-max + vertmax = full maximisation.  full - horiz = vertmax.
etc.

Martynas wrote something like this once, so I did okan, this version
seems to finally deal with the corner cases.

ok okan@@.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.139 2011/09/03 09:42:33 okan Exp $
d89 1
d439 1
a439 1
void			 font_init(struct screen_ctx *);
@


1.139
log
@split off window hints from geometry so we don't need to carry them all
around when dealing with {,h,v}max.  same idea from oga.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.138 2011/09/03 09:25:39 okan Exp $
d146 6
a151 4
#define CLIENT_MAXIMIZED		0x0004
#define CLIENT_VMAXIMIZED		0x0008
#define CLIENT_HMAXIMIZED		0x0010
#define CLIENT_FREEZE			0x0020
@


1.138
log
@simplify color initialization.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.137 2011/09/03 09:20:58 okan Exp $
d124 2
d136 1
a136 1
	} geom, savegeom;
@


1.137
log
@Add {r,}cycleingroup to cycle through clients belonging to the same
group as the active client (as opposed to all unhidden clients); from
Alexander Polakov, with a tiny tweak requested by oga.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.136 2011/09/03 09:17:16 okan Exp $
d93 1
a94 1
	char		*name;
a279 6
#define CONF_COLOR_ACTIVEBORDER		"#CCCCCC"
#define CONF_COLOR_INACTIVEBORDER	"#666666"
#define CONF_COLOR_GROUPBORDER		"blue"
#define CONF_COLOR_UNGROUPBORDER	"red"
#define CONF_COLOR_MENUFG		"black"
#define CONF_COLOR_MENUBG		"white"
@


1.136
log
@"defaultfont" is unclear (and confusing while reading code) when it also
applies to the user supplied font, so rename.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.135 2011/07/23 13:09:11 okan Exp $
d71 3
a73 2
#define CWM_CYCLE		0
#define CWM_RCYCLE		1
@


1.135
log
@Clarify defines and make them not look like non-local ones; started by a
small diff from Thomas Pfaff.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.134 2011/07/14 11:39:53 okan Exp $
d288 2
a289 2
#define	DEFAULTFONTNAME			"sans-serif:pixelsize=14:bold"
	char			*DefaultFontName;
@


1.134
log
@correct spelling; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.133 2011/06/24 06:52:23 okan Exp $
d46 5
a50 5
#define ChildMask	(SubstructureRedirectMask|SubstructureNotifyMask)
#define ButtonMask	(ButtonPressMask|ButtonReleaseMask)
#define MouseMask	(ButtonMask|PointerMotionMask)
#define KeyMask		(KeyPressMask|ExposureMask)
#define MenuMask 	(ButtonMask|ButtonMotionMask|ExposureMask| \
d52 1
a52 1
#define MenuGrabMask	(ButtonMask|ButtonMotionMask|StructureNotifyMask|\
d54 1
a54 1
#define SearchMask	(KeyPressMask|ExposureMask)
@


1.133
log
@add 'normal' cursor and shuffle the others we use to make a bit more
sense and to be slightly less un-expected.  from Alexander Polakov.
re-use 'normal' cursor now instead XC_hand1 for menu selection.  i
really wish X had real docs and made sense.

ok on earlier diff with '?' removed (but it's back now) oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.132 2011/06/24 06:09:26 okan Exp $
d82 1
a82 1
	CWM_COLOR_BORDOR_ACTIVE,
@


1.132
log
@New option to raise a client via the mouse (unbound by default);
opposing action, lower, already exists and bound.  Both keyboard
mappings already exist.

'no opinion either way' oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.131 2011/06/24 06:06:24 okan Exp $
d476 1
d478 2
a480 3
extern Cursor				 Cursor_select;
extern Cursor				 Cursor_default;
extern Cursor				 Cursor_question;
@


1.131
log
@introduce a new config option to snap to the screen edge.  'snapdist'
keyword taken from a diff from Sviatoslav Chagaev to do the same thing,
but implemented in a completely way (based on some very old code from
mk@@).  default set to 0, so no behavior change.

ok oga@@ (who would also like to take it further...)
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.130 2011/06/24 06:01:47 okan Exp $
d408 1
@


1.130
log
@re-do various bits of {,h,v}max for simplicity and less flag handling.
as a bonus, flipping between various combinations of vmax+hmax provides
a more predictable behavior.

commitski oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.129 2011/06/24 05:45:57 okan Exp $
d276 2
d330 1
@


1.129
log
@struct XftFont already has height which we can use directly instead of
calculating ourselves, so do so.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.128 2011/06/24 05:40:09 okan Exp $
d143 4
a146 7
#define CLIENT_DOMAXIMIZE		0x0004
#define CLIENT_MAXIMIZED		0x0008
#define CLIENT_DOVMAXIMIZE		0x0010
#define CLIENT_VMAXIMIZED		0x0020
#define CLIENT_DOHMAXIMIZE		0x0040
#define CLIENT_HMAXIMIZED		0x0080
#define CLIENT_FREEZE			0x0100
@


1.128
log
@alter a few function returns and prototypes; found by lint.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.127 2011/06/24 05:30:42 okan Exp $
a209 1
	u_int			 fontheight;
@


1.127
log
@collapse client and group {r,}cycle defines since they are really
the same thing.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.126 2011/05/15 17:58:47 okan Exp $
d310 2
a311 2
struct client_ctx	*client_cycle(struct screen_ctx *, int);
int			 client_delete(struct client_ctx *);
d466 1
a466 1
int			 u_spawn(char *);
@


1.126
log
@fix botched client and group cycle defines; noticed by Thomas Pfaff.

"no cookie! fix it" - oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.125 2011/05/11 13:53:51 okan Exp $
d70 1
a70 1
/* client cycle */
a72 4

/* group cycle */
#define CWM_CYCLEGROUP		0
#define CWM_RCYCLEGROUP		1
@


1.125
log
@tag and comment cleanup; ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.h,v 1.124 2011/05/07 17:15:37 okan Exp $
d71 2
a72 2
#define CWM_CYCLE		0x0001
#define CWM_RCYCLE		0x0002
d75 2
a76 2
#define CWM_CYCLEGROUP		0x0001
#define CWM_RCYCLEGROUP		0x0002
@


1.124
log
@introduce a new 'freeze' flag (CMS-f by default) which may be applied to
any window, after which all move/resize requests will be ignored,
essentially freezing the window in place.

there's a possibility to merge this with the 'ignore' concept, pending
on how ignore+freeze should behave (really more ewmh stuff), but punting
for now since ponies are on the line.

requested and tested by thib at k2k11 with ponies, unicorns and rainbows.

'save the unicorns' todd@@, ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.123 2011/05/05 16:40:37 okan Exp $
@


1.123
log
@re-org. ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.122 2011/03/22 10:57:31 okan Exp $
d153 1
d318 1
d373 1
@


1.122
log
@introduce nitems macro, with the appropriate ifndef.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.121 2011/03/22 10:52:37 okan Exp $
a33 2
#define CALMWM_MAXNAMELEN 256

d39 4
d56 28
a83 3
#ifndef nitems
#define nitems(_a) (sizeof((_a)) / sizeof((_a)[0]))
#endif
d99 1
a106 68
struct client_ctx;

TAILQ_HEAD(cycle_entry_q, client_ctx);
TAILQ_HEAD(group_ctx_q, group_ctx);
TAILQ_HEAD(client_ctx_q, client_ctx);

#define CALMWM_NGROUPS 9
struct group_ctx {
	TAILQ_ENTRY(group_ctx)	 entry;
	struct client_ctx_q	 clients;
	int			 shortcut;
	int			 hidden;
	int			 nhidden;
	int			 highstack;
};

struct screen_ctx {
	TAILQ_ENTRY(screen_ctx)	 entry;

	u_int			 which;
	Window			 rootwin;
	Window			 menuwin;

	struct color		 color[CWM_COLOR_MAX];
	GC			 gc;

	int			 altpersist;

	int			 xmax;
	int			 ymax;

	struct gap		 gap;
	struct cycle_entry_q	 mruq;

	XftDraw			*xftdraw;
	XftColor		 xftcolor;
	XftFont			*font;
	u_int			 fontheight;

	int			 xinerama_no;
	XineramaScreenInfo	*xinerama;
	struct group_ctx	*group_active;
	struct group_ctx	 groups[CALMWM_NGROUPS];
	int			 group_hideall;
	struct group_ctx_q	 groupq;
	char 			**group_names;
	int			 group_nonames;
};

TAILQ_HEAD(screen_ctx_q, screen_ctx);

#define CLIENT_PROTO_DELETE	0x01
#define CLIENT_PROTO_TAKEFOCUS	0x02

#define CLIENT_MAXNAMEQLEN	5

#define CLIENT_HIDDEN		0x01
#define CLIENT_IGNORE		0x02
#define CLIENT_DOMAXIMIZE	0x04
#define CLIENT_MAXIMIZED	0x08
#define CLIENT_DOVMAXIMIZE	0x10
#define CLIENT_VMAXIMIZED	0x20
#define CLIENT_DOHMAXIMIZE	0x40
#define CLIENT_HMAXIMIZED	0x80

#define CLIENT_HIGHLIGHT_GROUP		1
#define CLIENT_HIGHLIGHT_UNGROUP	2

a110 1

a114 1
	TAILQ_ENTRY(client_ctx) searchentry;
a116 1

a119 1

d121 1
a121 2

	u_int			 bwidth;
d123 14
a136 3
		int		 x, y, width, height, basew, baseh,
				 minw, minh, maxw, maxh, incw, inch;
		float		 mina, maxa;
a137 1

d139 2
a140 1
		int		 x,y;
d142 2
a143 1

d145 8
a152 1

d155 8
a163 3
	struct winname_q	 nameq;
	size_t			 nameqlen;

a164 3
	int			 active;
	int			 highlight;

a166 3

	int			stackingorder;

d170 2
d173 16
a188 1
extern const char *shortcut_to_name[];
a189 1
/* Autogroups */
a195 1

d198 25
a222 37
#define CWM_MOVE	0x01
#define CWM_RESIZE	0x02
#define CWM_PTRMOVE	0x04
#define CWM_BIGMOVE	0x08
#define CWM_UP		0x10
#define CWM_DOWN	0x20
#define CWM_LEFT	0x40
#define CWM_RIGHT	0x80

/*
 * Match a window.
 */
#define CONF_MAX_WINTITLE	256
struct winmatch {
	TAILQ_ENTRY(winmatch)	entry;
	char			title[CONF_MAX_WINTITLE];
};

TAILQ_HEAD(winmatch_q, winmatch);

/* for cwm_exec */
#define	CWM_EXEC_PROGRAM	0x1
#define	CWM_EXEC_WM		0x2
/* for alt-tab */
#define CWM_CYCLE		0x0
#define CWM_RCYCLE		0x1
/* for group cycle */
#define CWM_CYCLEGROUP		0x0
#define CWM_RCYCLEGROUP		0x1

#define KBFLAG_NEEDCLIENT 0x01

#define KBTOGROUP(X) ((X) - 1)

union arg {
	char	*c;
	int	 i;
d224 1
d233 1
d236 12
d253 2
a254 2
	char			label[256];
	/* (argv) */
d256 1
d258 9
a266 6
struct mousebinding {
	int				modmask;
	int			 	button;
	int				context;
	void			 	(*callback)(struct client_ctx *, void *);
	TAILQ_ENTRY(mousebinding)	entry;
d268 1
a269 8
#define MOUSEBIND_CTX_ROOT	1
#define MOUSEBIND_CTX_WIN	2

TAILQ_HEAD(keybinding_q, keybinding);
TAILQ_HEAD(cmd_q, cmd);
TAILQ_HEAD(mousebinding_q, mousebinding);

/* Global configuration */
d277 1
a277 2

#define	CONF_STICKY_GROUPS	 0x0001
d279 1
a279 1
#define CONF_BWIDTH		 1
d281 1
a281 1
#define	CONF_MAMOUNT		 1
a283 1

a290 1

d293 1
a293 2

#define	DEFAULTFONTNAME		 "sans-serif:pixelsize=14:bold"
a296 17
/* Menu stuff */

#define MENU_MAXENTRY 50

struct menu {
	TAILQ_ENTRY(menu)	entry;
	TAILQ_ENTRY(menu)	resultentry;

	char			 text[MENU_MAXENTRY + 1];
	char			 print[MENU_MAXENTRY + 1];
	void			*ctx;
	short			 dummy;
	short			 abort;
};

TAILQ_HEAD(menu_q, menu);

a297 1

d303 1
a303 3

#define MWM_NUMHINTS 3

d305 3
a307 3
#define	MWM_HINTS_DECORATIONS	(1 << 1)
#define	MWM_DECOR_ALL		(1 << 0)
#define	MWM_DECOR_BORDER	(1 << 1)
d311 5
d317 9
d327 3
a329 2
int			 client_delete(struct client_ctx *);
void			 client_setactive(struct client_ctx *, int);
a330 4
void			 client_lower(struct client_ctx *);
void			 client_raise(struct client_ctx *);
void			 client_move(struct client_ctx *);
void			 client_leave(struct client_ctx *);
d332 2
a333 2
struct client_ctx	*client_current(void);
void			 client_hide(struct client_ctx *);
d335 1
a335 1
void			 client_setname(struct client_ctx *);
a336 11
void			 client_ptrwarp(struct client_ctx *);
void			 client_ptrsave(struct client_ctx *);
void			 client_draw_border(struct client_ctx *);
void			 client_maximize(struct client_ctx *);
void			 client_vertmaximize(struct client_ctx *);
void			 client_horizmaximize(struct client_ctx *);
void			 client_map(struct client_ctx *);
void			 client_mtf(struct client_ctx *);
struct client_ctx	*client_cycle(struct screen_ctx *, int);
void			 client_getsizehints(struct client_ctx *);
void			 client_applysizehints(struct client_ctx *);
d338 14
a351 5
struct menu  		*menu_filter(struct screen_ctx *, struct menu_q *,
			     char *, char *, int,
			     void (*)(struct menu_q *, struct menu_q *, char *),
			     void (*)(struct menu *, int));
void			 menu_init(struct screen_ctx *);
d353 7
a359 29
void			 xev_loop(void);

void			 xu_getatoms(void);
int			 xu_ptr_grab(Window, int, Cursor);
void			 xu_btn_grab(Window, int, u_int);
int			 xu_ptr_regrab(int, Cursor);
void			 xu_btn_ungrab(Window, int, u_int);
void			 xu_ptr_ungrab(void);
void			 xu_ptr_setpos(Window, int, int);
void			 xu_ptr_getpos(Window, int *, int *);
void			 xu_key_grab(Window, int, int);
void			 xu_key_ungrab(Window, int, int);
void			 xu_configure(struct client_ctx *);
void			 xu_sendmsg(Window, Atom, long);
int			 xu_getprop(Window, Atom, Atom, long, u_char **);
int			 xu_getstrprop(Window, Atom, char **);
void			 xu_setstate(struct client_ctx *, int);
int			 xu_getstate(struct client_ctx *, int *);
unsigned long		 xu_getcolor(struct screen_ctx *, char *);
void			 xu_freecolor(struct screen_ctx *, unsigned long);
void			 xu_setwmname(struct screen_ctx *);

int			 u_spawn(char *);
void			 u_exec(char *);

void			 xfree(void *);
void			*xmalloc(size_t);
void			*xcalloc(size_t, size_t);
char			*xstrdup(const char *);
d361 1
d363 2
a365 3
void			 screen_update_geometry(struct screen_ctx *, int, int);
void			 screen_init_xinerama(struct screen_ctx *);
XineramaScreenInfo	*screen_find_xinerama(struct screen_ctx *, int, int);
a366 21
void			 conf_setup(struct conf *, const char *);
void			 conf_client(struct client_ctx *);
void			 conf_grab(struct conf *, struct keybinding *);
void			 conf_ungrab(struct conf *, struct keybinding *);
void			 conf_bindname(struct conf *, char *, char *);
void			 conf_mousebind(struct conf *, char *, char *);
void			 conf_grab_mouse(struct client_ctx *);
void			 conf_reload(struct conf *);
void			 conf_gap(struct conf *, struct screen_ctx *);
void			 conf_font(struct conf *, struct screen_ctx *);
void			 conf_color(struct conf *, struct screen_ctx *);
void			 conf_init(struct conf *);
void			 conf_clear(struct conf *);
void			 conf_cmd_add(struct conf *, char *, char *, int);

int			 parse_config(const char *, struct conf *);

void			 kbfunc_client_lower(struct client_ctx *, union arg *);
void			 kbfunc_client_raise(struct client_ctx *, union arg *);
void			 kbfunc_client_search(struct client_ctx *, union arg *);
void			 kbfunc_client_hide(struct client_ctx *, union arg *);
d368 2
a369 3
void			 kbfunc_client_rcycle(struct client_ctx *, union arg *);
void			 kbfunc_cmdexec(struct client_ctx *, union arg *);
void			 kbfunc_client_label(struct client_ctx *, union arg *);
d374 1
a374 1
void			 kbfunc_client_cyclegroup(struct client_ctx *,
d376 2
a377 1
void			 kbfunc_client_nogroup(struct client_ctx *,
d379 3
a381 1
void			 kbfunc_client_grouptoggle(struct client_ctx *,
d385 1
a385 1
void			 kbfunc_client_maximize(struct client_ctx *,
d387 3
d392 6
a397 2
void			 kbfunc_client_hmaximize(struct client_ctx *,
			     union arg *);
a398 4
void			 kbfunc_quit_wm(struct client_ctx *, union arg *);
void			 kbfunc_moveresize(struct client_ctx *, union arg *);
void			 kbfunc_menu_search(struct client_ctx *, union arg *);
void			 kbfunc_exec(struct client_ctx *, union arg *);
a400 1
void			 kbfunc_lock(struct client_ctx *, union arg *);
d402 3
a404 2
void			 mousefunc_window_resize(struct client_ctx *, void *);
void			 mousefunc_window_move(struct client_ctx *, void *);
d407 1
d409 8
a416 4
void			 mousefunc_window_hide(struct client_ctx *, void *);
void			 mousefunc_menu_group(struct client_ctx *, void *);
void			 mousefunc_menu_unhide(struct client_ctx *, void *);
void			 mousefunc_menu_cmd(struct client_ctx *, void *);
d418 1
a418 7
void			 search_match_client(struct menu_q *, struct menu_q *,
			     char *);
void			 search_print_client(struct menu *, int);
void			 search_match_text(struct menu_q *, struct menu_q *,
			     char *);
void			 search_match_exec(struct menu_q *, struct menu_q *,
			     char *);
d420 14
a433 14
void			 group_init(struct screen_ctx *);
void			 group_make_autogroup(struct conf *, char *, int);
void			 group_update_names(struct screen_ctx *);
void			 group_hidetoggle(struct screen_ctx *, int);
void			 group_only(struct screen_ctx *, int);
void			 group_cycle(struct screen_ctx *, int);
void			 group_sticky(struct client_ctx *);
void			 group_client_delete(struct client_ctx *);
void			 group_menu(XButtonEvent *);
void			 group_alltoggle(struct screen_ctx *);
void			 group_sticky_toggle_enter(struct client_ctx *);
void			 group_sticky_toggle_exit(struct client_ctx *);
void			 group_autogroup(struct client_ctx *);
void			 group_movetogroup(struct client_ctx *, int);
d437 2
a441 2
void			 font_draw(struct screen_ctx *, const char *, int,
			     Drawable, int, int);
d444 30
a474 1

a483 2
extern struct screen_ctx		*curscreen;

d485 1
a487 1
extern struct conf			 Conf;
@


1.121
log
@while this piece deals with client argv's in a seemingly inefficient way
(noticed by Tim Peniket), since we don't ever do anything with cliarg,
remove the hunk and cliarg completely.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.120 2011/03/22 10:49:46 okan Exp $
d53 4
@


1.120
log
@remove XXX and move a configure event out of the event handler functions.

reminded by a similiar diff from Thomas Pfaff.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.119 2011/03/22 10:47:59 okan Exp $
a191 1
	char			*app_cliarg;
@


1.119
log
@move the single keycode function directly into the menu code.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.118 2010/05/22 22:10:31 okan Exp $
a377 3
/* XXX should be xu_ */
void			  xev_reconfig(struct client_ctx *);

d390 1
@


1.118
log
@replace XFetchName() with something more intelligent which attempts to
use the appropriate netwm Atom first, as well as deal with utf8.

slightly different incarnation tested by sthen@@ and ajacoutot@@ - thanks!

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.117 2010/04/11 16:51:26 okan Exp $
a327 6
enum ctltype {
	CTL_NONE = -1,
	CTL_ERASEONE = 0, CTL_WIPE, CTL_UP, CTL_DOWN, CTL_RETURN,
	CTL_ABORT, CTL_ALL
};

a341 3

int			 input_keycodetrans(KeyCode, u_int, enum ctltype *,
			     char *);
@


1.117
log
@clean up a few xu_* functions to just accept what they need (Window).

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.116 2010/02/10 01:23:05 okan Exp $
d404 1
a404 1
char			*xu_getstrprop(struct client_ctx *, Atom atm);
@


1.116
log
@preserve labels after an edit action is aborted; extending the menu
struct just for this is the least intrusive approach until the menu code
is reviewed.

inspired by Thomas Pfaff's report on tech@@

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.115 2010/01/27 03:04:50 okan Exp $
d402 2
a403 3
void			 xu_sendmsg(struct client_ctx *, Atom, long);
int			 xu_getprop(struct client_ctx *, Atom, Atom, long,
			     u_char **);
@


1.115
log
@- allow per-screen gap; not (yet) user configurable.
- teach _NET_WORKAREA about gap.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.114 2009/12/15 04:10:42 okan Exp $
d323 1
@


1.114
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.113 2009/12/15 03:34:34 okan Exp $
d68 6
d106 1
d294 1
a308 1
	int			 gap_top, gap_bottom, gap_left, gap_right;
d433 1
@


1.113
log
@pull these headers only into files that need them.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.112 2009/12/15 03:26:22 okan Exp $
a22 13

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
@


1.112
log
@rid ourselves of these functional macros; convert to real functions.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.111 2009/12/15 03:24:36 okan Exp $
a28 1
#include <assert.h>
a31 3
#include <dirent.h>
#include <getopt.h>
#include <signal.h>
@


1.111
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.110 2009/12/14 16:39:01 oga Exp $
d519 3
a526 4

#define	font_ascent(sc)		sc->font->ascent
#define	font_descent(sc)	sc->font->descent
#define	font_height(sc)		sc->fontheight
@


1.110
log
@kill _CWM_GRP atom setting. The netwm stuff does us well enough now that
it's superfluous.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.109 2009/12/11 18:09:16 oga Exp $
d23 27
@


1.109
log
@add _NET_WORKAREA. for now we ignore the gap, this'll change soonish.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.108 2009/12/11 17:55:42 oga Exp $
d525 1
a525 2
#define	_CWM_GRP			 cwm_atoms[5]
#define	UTF8_STRING			 cwm_atoms[6]
d531 16
a546 16
#define	_NET_SUPPORTED			 cwm_atoms[7]
#define	_NET_SUPPORTING_WM_CHECK	 cwm_atoms[8]
#define	_NET_WM_NAME			 cwm_atoms[9]
#define	_NET_ACTIVE_WINDOW		 cwm_atoms[10]
#define	_NET_CLIENT_LIST		 cwm_atoms[11]
#define	_NET_NUMBER_OF_DESKTOPS		 cwm_atoms[12]
#define	_NET_CURRENT_DESKTOP		 cwm_atoms[13]
#define	_NET_DESKTOP_VIEWPORT		 cwm_atoms[14]
#define	_NET_DESKTOP_GEOMETRY		 cwm_atoms[15]
#define	_NET_VIRTUAL_ROOTS		 cwm_atoms[16]
#define	_NET_SHOWING_DESKTOP		 cwm_atoms[17]
#define	_NET_DESKTOP_NAMES		 cwm_atoms[18]
#define _NET_WM_DESKTOP			 cwm_atoms[19]
#define	_NET_WORKAREA			 cwm_atoms[20]
#define CWM_NO_ATOMS			 21
#define CWM_NETWM_START			 7
@


1.108
log
@implement support for _NET_WM_DESKTOP properties on windows.

it works kinda like _CWM_GRP, which we added to aid restarts a while
ago, but it's standardised and clients are specifically allowed to set
it to request a desktop.

for noe we leave _CWM_GRP support in, but its days are now numbered.

while i'm here fixup an int/long mixup with an earlier diff.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.107 2009/12/11 17:51:42 oga Exp $
d545 2
a546 1
#define CWM_NO_ATOMS			 20
@


1.107
log
@Implement _NET_DESKTOP_NAMES, this one was a bit tricky since thespec
says that a pager can change the property at any time (most need a
clientmessage). So deal with property updates.

Needed to shuffle some of the other code around since we can't just use
shortcut_to_name[] everywhere now.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.106 2009/12/10 23:21:26 oga Exp $
d544 2
a545 1
#define CWM_NO_ATOMS			 19
@


1.106
log
@Implement _NET_VIRTUAL_ROOTS (just clear it, we don't use that technique)
and _NET_SHOWING_DESKTOP (we're never doing so right now).

only three informational root-window hints to go.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.105 2009/12/10 23:14:58 oga Exp $
a68 1
	const char		*name;
d103 2
d182 4
a185 5
	TAILQ_ENTRY(autogroupwin) entry;

	char	*class;
	char	*name;
	char	*group;
d478 2
d543 2
a544 1
#define CWM_NO_ATOMS			 18
@


1.105
log
@Implement _NET_CURRENT_DESKTOP, _NET_DESKTOP_VIEWPORT and
_NET_DESKTOP_GEOMETRY.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.104 2009/12/10 17:16:51 oga Exp $
d539 3
a541 1
#define CWM_NO_ATOMS			 16
@


1.104
log
@finish unfucking the screen_ctx handling.

remove screen_current() it was utterly bogus when nscreens > 1.

pass a fake client_ctx in the case where there's no client and the
kbfunc or mousefunc doesn't need a real one, it just contains the
current screen, modify these functions so that they pass down the screen
context to their callees.

make groups per screen, it's the only way it makes sense in this regard.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.103 2009/12/08 16:52:17 okan Exp $
d404 1
d534 1
a534 1
#define _NET_CLIENT_LIST		 cwm_atoms[11]
d536 4
a539 1
#define CWM_NO_ATOMS			 13
@


1.103
log
@start fixing screen_ctx usage, for it is utterly broken.  bring font
into screen_ctx and start passing screen_ctx around to in order get rid
of Curscreen; fixup per-screen config colors the same way.

diff mostly from oga@@, with a bit harsher reaction to the state of screen_ctx.

"please commit" oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.102 2009/12/07 23:19:51 oga Exp $
d62 13
d77 1
a77 1
	TAILQ_ENTRY(screen_ctx)	entry;
d79 3
a81 3
	u_int		 which;
	Window		 rootwin;
	Window		 menuwin;
d83 2
a84 4
	struct color	 color[CWM_COLOR_MAX];
	GC		 gc;

	int		 altpersist;
d86 1
a86 2
	int		 xmax;
	int		 ymax;
d88 2
a89 1
	struct cycle_entry_q mruq;
d91 1
a91 4
	XftDraw		*xftdraw;
	XftColor	 xftcolor;
	XftFont		*font;
	u_int		 fontheight;
d93 11
a103 2
	int		 xinerama_no;
	XineramaScreenInfo *xinerama;
a176 2
TAILQ_HEAD(client_ctx_q, client_ctx);

a178 13
#define CALMWM_NGROUPS 9
struct group_ctx {
	TAILQ_ENTRY(group_ctx)	 entry;
	struct client_ctx_q	 clients;
	const char		*name;
	int			 shortcut;
	int			 hidden;
	int			 nhidden;
	int			 highstack;
};

TAILQ_HEAD(group_ctx_q, group_ctx);

d359 1
a359 1
struct client_ctx	*client_cycle(int);
d363 2
a364 1
struct menu  		*menu_filter(struct menu_q *, char *, char *, int,
d403 1
a403 2
struct screen_ctx	*screen_current(void);
void			 screen_updatestackingorder(void);
d476 4
a479 4
void			 group_init(void);
void			 group_hidetoggle(int);
void			 group_only(int);
void			 group_cycle(int);
d483 1
a483 1
void			 group_alltoggle(void);
@


1.102
log
@Implement _NET_NUMBER_OF_DESKTOPS, currently this is statically 9 and
unchangable. the group code needs some cleaning up before this will be a
bit less hackish.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.101 2009/12/07 22:46:15 oga Exp $
d82 2
a288 2
	XftFont			*DefaultFont;
	u_int			 FontHeight;
d413 2
a414 2
void			 conf_font(struct conf *);
void			 conf_color(struct conf *);
d488 1
a488 1
int			 font_width(const char *, int);
d493 3
a495 3
#define font_ascent()	Conf.DefaultFont->ascent
#define font_descent()	Conf.DefaultFont->descent
#define	font_height()	Conf.FontHeight
@


1.101
log
@support _NET_CLIENT_LIST.

the x property api doesn't let you remove one entry from an X property
array, so client_remove is kinda expensive, but there's no real way
around that..

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.100 2009/12/07 22:21:59 oga Exp $
d162 1
d532 2
a533 1
#define CWM_NO_ATOMS			 12
@


1.100
log
@Implement _NET_ACTIVE_WINDOW. for now just the informational hint is
supported, the client message to change this will be supported when all
informational hints are working.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.99 2009/12/07 21:20:52 okan Exp $
d530 2
a531 1
#define CWM_NO_ATOMS			 11
@


1.99
log
@introduce the beginnings of netwm support, minimally and correctly;
allows java to be happy, but additionally stops others from whinning
about a non-netwm complaint wm.  more to come.

written a few times; this one includes a clever hack from oga@@ to
populate _NET_SUPPORTED.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.98 2009/08/27 01:38:08 okan Exp $
d529 2
a530 1
#define CWM_NO_ATOMS			 10
@


1.98
log
@unroll the CCTOSC macro; from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.97 2009/08/24 23:54:41 oga Exp $
d32 1
d388 1
d520 11
a530 1
#define CWM_NO_ATOMS			 6
@


1.97
log
@Add a keybinding to allow horizontal maximisation of a window (CMS-enter).

based on a diff by Thomas Pfaff; thanks!

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.96 2009/08/24 23:49:04 okan Exp $
a492 2

#define CCTOSC(cc) (cc->sc)
@


1.96
log
@bring together gathering, calculating and applying of size hints;
additionally, respect aspect ratio hints.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.95 2009/08/24 21:22:48 oga Exp $
d99 2
d352 1
d441 2
@


1.95
log
@Instead of having a function that just calls TAILQ_INIT on a global, use
TAILQ_HEAD_INITIALIZER() and drop the function.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.94 2009/06/26 12:21:58 okan Exp $
d124 3
a126 2
		int		 x, y, width, height;
		int		 min_dx, min_dy;
d353 2
@


1.94
log
@static local functions and data; almost identical diff from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.93 2009/06/23 21:52:38 okan Exp $
a329 1
void			 client_init(void);
a389 1
void			 screen_init(void);
@


1.93
log
@tidy up startup/init routines

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.92 2009/06/20 00:22:39 okan Exp $
a326 1
int			 x_errorhandler(Display *, XErrorEvent *);
a347 2
void			 client_update(struct client_ctx *);
void			 client_placecalc(struct client_ctx *);
a352 4
struct client_ctx	*client_mrunext(struct client_ctx *);
struct client_ctx	*client_mruprev(struct client_ctx *);
void			 client_gethints(struct client_ctx *);
void			 client_freehints(struct client_ctx *);
a402 1
void			 conf_unbind(struct conf *, struct keybinding *);
a403 1
void			 conf_mouseunbind(struct conf *, struct mousebinding *);
@


1.92
log
@unroll XCALLOC/XMALLOC macros; since we use xcalloc/xmalloc all over the
place anyway, this makes things a bit more consistent; from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.91 2009/06/17 12:30:17 okan Exp $
d331 1
a331 1
void			 client_setup(void);
d398 1
@


1.91
log
@move like defines to a central, logical location; no binary change.

aok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.90 2009/05/18 00:17:46 oga Exp $
a396 3

#define XMALLOC(p, t) ((p) = (t *)xmalloc(sizeof * (p)))
#define XCALLOC(p, t) ((p) = (t *)xcalloc(1, sizeof * (p)))
@


1.90
log
@oops, we appear to have grown an extra prototype for group_only(), get
the secateurs out.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.89 2009/05/18 00:14:19 oga Exp $
d36 6
@


1.89
log
@Rip out the event layer and just use a static array of callbacks like
every other window manager since twm.

The event layer is very nice, very shiny, very flexible, and very much
underutilised. We don't need any of those shiny features so it's
probably better to earn ourselves 1k smaller text size instead.

ok todd@@, okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.88 2009/05/17 23:40:57 okan Exp $
a473 1
void			 group_only(int);
@


1.88
log
@a long time coming - re-work the way we deal with colors: since we're
using Xft(3), use it to select the font color as well instead of trying
to build one; properly allocate and free colors at-will, e.g. we now
have configurable colors.

feedback and ok's todd@@ and oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.87 2009/05/17 17:04:59 sthen Exp $
a174 12
/* NULL/0 values indicate match any. */
struct xevent {
	TAILQ_ENTRY(xevent)	 entry;
	Window			*xev_win;
	Window			*xev_root;
	int			 xev_type;
	void			 (*xev_cb)(struct xevent *, XEvent *);
	void			*xev_arg;
};

TAILQ_HEAD(xevent_q, xevent);

a359 20
void			 xev_handle_maprequest(struct xevent *, XEvent *);
void			 xev_handle_unmapnotify(struct xevent *, XEvent *);
void			 xev_handle_destroynotify(struct xevent *, XEvent *);
void			 xev_handle_configurerequest(struct xevent *, XEvent *);
void			 xev_handle_propertynotify(struct xevent *, XEvent *);
void			 xev_handle_enternotify(struct xevent *, XEvent *);
void			 xev_handle_leavenotify(struct xevent *, XEvent *);
void			 xev_handle_buttonpress(struct xevent *, XEvent *);
void			 xev_handle_buttonrelease(struct xevent *, XEvent *);
void			 xev_handle_keypress(struct xevent *, XEvent *);
void			 xev_handle_keyrelease(struct xevent *, XEvent *);
void			 xev_handle_expose(struct xevent *, XEvent *);
void			 xev_handle_clientmessage(struct xevent *, XEvent *);
void			 xev_handle_randr(struct xevent *, XEvent *);
void			 xev_handle_mapping(struct xevent *, XEvent *);

#define XEV_QUICK(a, b, c, d, e) do {		\
	xev_register(xev_new(a, b, c, d, e));	\
} while (0)

a362 4
void			 xev_init(void);
struct xevent		*xev_new(Window *, Window *, int,
			     void (*)(struct xevent *, XEvent *), void *);
void			 xev_register(struct xevent *);
d472 1
@


1.87
log
@add a "movetogroup" function, which hides the current window from
display and moves it to another group. useful with the recently added
"grouponly" function, giving the ability to use groups as simple
virtual desktops (similar to e.g. xmonad, dwm and scrotwm).

this doesn't have default keyboard bindings; cwmrc(5) now shows how
you could use these functions (use M-1...9 for grouponly1...9 and
MS-1...9 for movetogroup1...9 to emulate the default dwm bindings).

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.86 2009/05/14 16:29:58 oga Exp $
d37 15
d62 2
a63 4
	Colormap	 colormap;
	XColor		 bgcolor, fgcolor, fccolor, redcolor, graycolor,
			 whitecolor, blackcolor;
	unsigned long	 blackpixl, whitepixl, redpixl, bluepixl, graypixl;
d94 2
a95 2
#define CLIENT_HIGHLIGHT_BLUE	1
#define CLIENT_HIGHLIGHT_RED	2
d275 8
d417 2
d448 1
@


1.86
log
@add missing prototype.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.85 2009/05/14 16:24:04 oga Exp $
d449 2
d493 1
@


1.85
log
@Add a new command (currently no default keybindings for it), grouponly[1-9].

This works like the group select binding, but hides all other groups.

So, the people who've been complaining that they don't get "virtual
desktops" in cwm may want to try this out in cwmrc (from memory, untested):

---

#cwmrc

# add new windows to the current group
set sticky

# automatically sticky windows. xclock for now.
# to make more windows sticky use group_toggle to unset their group
autogroup 0 xclock

# make the group selection keys hide other groups, emulate virtual desktops
bind CM-1 grouponly1
bind CM-2 grouponly2
bind CM-3 grouponly3
bind CM-4 grouponly4
bind CM-5 grouponly5
bind CM-6 grouponly6
bind CM-7 grouponly7
bind CM-8 grouponly8
bind CM-9 grouponly9

---

mostly by sthen, tweaks from me.

ok todd@@, "if it works i'm ok with it" okan@@, ok sthen@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.84 2009/04/15 14:01:45 okan Exp $
d483 1
@


1.84
log
@properly teardown X connection upon quit; static a few while here,
requested by oga@@

ok oga@@ sometime ago
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.83 2009/02/07 21:07:00 martynas Exp $
d441 2
@


1.83
log
@add 'moveamount' to cwmrc;  it sets keyboard movement amount, making
it more useful on large screens
manpage tweak & ok jmc@@
ok okan@@, oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.82 2009/01/27 02:16:20 okan Exp $
a312 2
void			 x_setup(void);
void			 x_setupscreen(struct screen_ctx *, u_int);
@


1.82
log
@remove Nscreens and x_screenname() - we really don't need them.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.81 2009/01/27 00:42:53 oga Exp $
d259 2
@


1.81
log
@One of the most annoying things to do was restart cwm and lose all of
your group state. Fix this up by using an X Atom (_CWM_GRP) to store the
name of the group that we're using (the name, not the number is because
at one point we may make the group numbers dynamic). I've been talking
about this since c2k8. so CM-w means you keep all of your windows grouped
properly.

ok okan@@, todd@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.80 2009/01/23 19:00:59 okan Exp $
a49 1
	char		*display;
a311 1
char			*x_screenname(int);
a512 1
extern u_int				 Nscreens;
@


1.80
log
@move conf_clear() and add proto.

ok todd@@ oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.79 2009/01/23 18:58:40 oga Exp $
d143 1
d527 2
a528 1
#define CWM_NO_ATOMS			 5
@


1.79
log
@Move the keybinding argument to a union to prevent warnings where
sizeof(int) != sizeof(void *). This has been annoying me for ages.

ok okan@@, todd@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.78 2009/01/22 15:26:33 oga Exp $
d427 1
@


1.78
log
@Cache all of the X atoms we use at startup.

Do this instead of querying for them every time we use them. This
removes an XXX that has been in there since time began. This will become
more important as we move towards supporting netwm.

ok todd@@, okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.77 2009/01/21 15:04:38 todd Exp $
d208 5
d214 3
a220 3
	void			 (*callback)(struct client_ctx *, void *);
	void			*argument;
	TAILQ_ENTRY(keybinding)	 entry;
d431 28
a458 23
void			 kbfunc_client_lower(struct client_ctx *, void *);
void			 kbfunc_client_raise(struct client_ctx *, void *);
void			 kbfunc_client_search(struct client_ctx *, void *);
void			 kbfunc_client_hide(struct client_ctx *, void *);
void			 kbfunc_client_cycle(struct client_ctx *, void *);
void			 kbfunc_client_rcycle(struct client_ctx *, void *);
void			 kbfunc_cmdexec(struct client_ctx *, void *);
void			 kbfunc_client_label(struct client_ctx *, void *);
void			 kbfunc_client_delete(struct client_ctx *, void *);
void			 kbfunc_client_group(struct client_ctx *, void *);
void			 kbfunc_client_cyclegroup(struct client_ctx *, void *);
void			 kbfunc_client_nogroup(struct client_ctx *, void *);
void			 kbfunc_client_grouptoggle(struct client_ctx *, void *);
void			 kbfunc_client_maximize(struct client_ctx *, void *);
void			 kbfunc_client_vmaximize(struct client_ctx *, void *);
void			 kbfunc_reload(struct client_ctx *, void *);
void			 kbfunc_quit_wm(struct client_ctx *, void *);
void			 kbfunc_moveresize(struct client_ctx *, void *);
void			 kbfunc_menu_search(struct client_ctx *, void *);
void			 kbfunc_exec(struct client_ctx *, void *);
void			 kbfunc_ssh(struct client_ctx *, void *);
void			 kbfunc_term(struct client_ctx *, void *);
void			 kbfunc_lock(struct client_ctx *, void *);
@


1.77
log
@borderwidth as a cwmrc(5) keyword, really helps debugging
from okan@@
ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.76 2009/01/17 20:39:24 okan Exp $
d376 1
d509 9
@


1.76
log
@remove unused

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.75 2009/01/17 18:41:50 oga Exp $
a81 1
#define CLIENT_BWIDTH		1
d252 2
@


1.75
log
@Finally fix the really annoying race where if you rapidly switch groups several
times you'd end up losing clients (thinking they had gone away).

From the ICCCM (which should not be read without a stiff drink in hand,
I made this mistake so you don't have to): to request a window to be
withdrawn one should send a synthetic UnmapRequest event when iconified.
To request iconification one should just unmap the window. The ICCM
further recommends that the synthetic event should just be taken as a
cue to withdraw, to deal with legacy clients. Taking a hint from this,
rework xev_handle_unmaprequest to correctly detect these situations.  A
Withdrawn window may come back anywhere, even as a subwindow of
something else, so the correct way to handle this state is to forget it
ever existed.

While i'm here, kill a dumb attempt to notice this in client_delete, and
nuke the very unnecessary arguments.

Todd confirmed this fixes the `race'.

ok todd@@, ok ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.74 2009/01/16 15:24:14 okan Exp $
a323 1
void			 client_nocurrent(void);
@


1.74
log
@remove pwin, bringing us to one client, one window.  we no longer have
to push attributes around, so things get a lot simplier, while fixing a
few issues in the meantime; original suggestion by Edd Barrett many many
moons ago.

annoying window placement and race, found in c2k8 by todd, fix by oga!

lots of feedback from todd and oga - thanks!

"commit that bad boy" oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.73 2009/01/15 00:32:35 okan Exp $
d313 1
a313 1
int			 client_delete(struct client_ctx *, int, int);
@


1.73
log
@- add missing prototypes.
- properly name, place and static private functions.
- move function which finds the xinerama screen for a coordinate to
a more appropriate place while altering its semantics to match others.
- tiny bit of style.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.72 2009/01/11 21:46:48 oga Exp $
d48 1
a48 1
	XColor		 bgcolor, fgcolor, fccolor, redcolor, cyancolor,
d51 1
a51 1
	unsigned long	 blackpixl, whitepixl, redpixl, bluepixl, cyanpixl;
a53 2
	Pixmap		 gray, blue, red;

d82 1
a85 1

a104 2
	Window			 pwin;

a314 1
void			 client_gravitate(struct client_ctx *, int);
a333 2
u_long			 client_bg_pixel(struct client_ctx *);
Pixmap			 client_bg_pixmap(struct client_ctx *);
a340 1
void			 client_do_shape(struct client_ctx *);
a359 1
void			 xev_handle_shape(struct xevent *, XEvent *);
a505 2
extern int				 Doshape, Shape_ev;
extern int				 Doshape, Shape_ev;
@


1.72
log
@shortcut_to_name should not be defined as static in a header file. Put
it in group.c where it it used most, and add an extern definition for
the other users of it.

Found by gcc -Wall. ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.71 2009/01/11 21:34:22 okan Exp $
d416 1
@


1.71
log
@add missing prototypes

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.70 2009/01/11 18:34:46 okan Exp $
d143 1
a143 5
static char *shortcut_to_name[] = {
	"nogroup", "one", "two", "three",
	"four", "five", "six", "seven",
	"eight", "nine"
};
@


1.70
log
@- merge grab_sweep() into mousefunc_window_resize().
- merge grab_drag() into mousefunc_window_move().
- properly name, proto and static private functions.
- since we already do XMoveResizeWindow() and XMoveWindow() in (now)
mousefunc_window_resize() and mousefunc_window_move() respectively,
client_resize() and client_move() calls are unnecessary.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.69 2008/12/04 23:55:04 oga Exp $
d432 4
@


1.69
log
@Kill obviously dead variable.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.68 2008/09/29 23:16:46 oga Exp $
a406 3

void			 grab_sweep(struct client_ctx *);
void			 grab_drag(struct client_ctx *);
@


1.68
log
@Xinerama and XRandR dual head support for cwm(1). Now we detect the xrandr
reconfiguration events and change our sizes depending on that. We also detect
the xinerama screens for maximize, vertmaximize and initial window placement.

This could be improved by automatically resizing maximized windows when
the screen resolution changes and by moving windows that would be hidden
into visible space. Said changes will come shortly.

Tested by many. matthieu@@ didn't oppose.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.67 2008/09/22 14:28:04 oga Exp $
a117 2

	int			 beepbeep;
@


1.67
log
@*sigh* Revert the diff that wasn't meant to go in yet.

note to self: When you mean to type cvs commit search.c, don't forget
the filename.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.65 2008/07/22 21:01:54 oga Exp $
d65 3
d375 1
d424 1
d520 2
@


1.66
log
@Display the current window title not a previous one in the case of
``show all'' in the window search dialogue. Noticed and diff from Tim
van der Molen, thanks!
@
text
@a64 3

	int		 xinerama_no;
	XineramaScreenInfo *xinerama;
a371 1
void			 xev_handle_randr(struct xevent *, XEvent *);
a419 1
void			 screen_init_xinerama(struct screen_ctx *);
a514 2
extern int				 Doshape, Shape_ev;
extern int				 HasXinerama, HasRandr, Randr_ev;
@


1.65
log
@fix the froggy problem.

Implement a handler for the MappingEvent, meaning that the keymap has changed.
When this happens, ungrab all bindings, update the map, and regrab.

Fixes the problem where some keybindings wouldn't work under non us or
uk keymaps (especially the .fr map, it seems). Issue noticed by
ajacoutot@@, ratchov@@, and a few people on misc. Based on an initial diff
from ratchov@@.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.64 2008/07/22 20:51:54 oga Exp $
d65 3
d375 1
d424 1
d520 2
@


1.64
log
@We've been handling grabbing wrong all this time (noticed at c2k8).

add conf_grab() and conf_ungrab, and use them in the keybinding manipulation
functions to {,un}grab the binding for all screens we have defined.

the lovely little ordering problem comes in here, since when we parse
the config initially Screenq is empty, so regrab after we fill the
queue, hopefully later reordering will remove this little need and there
will be much rejoicing.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.63 2008/07/22 20:42:24 oga Exp $
d372 1
@


1.63
log
@split x_setup() into two. dpy_init() for setting up the display and
checking the X config, and x_setup to set up the screens.

There's an ordering problem that means that some of this init needs to
come after the config is parsed, the rest should ideally happen before
though. This is a rough split, it will be refined later. Again, needed
for an upcoming change.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.62 2008/07/22 20:26:12 oga Exp $
d422 2
@


1.62
log
@Add xu_key_ungrab() and a mirror to xu_key_ungrab(). a couple of changes
that are coming up depend on it.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.61 2008/07/22 19:54:57 oga Exp $
d312 1
a312 1
void			 x_setup(char *display_name);
@


1.61
log
@Kill screen_init(). it's been stubbed out for a while now. I don't envision it
coming back in it's current form.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.60 2008/07/22 19:52:54 oga Exp $
d394 1
@


1.60
log
@kill another leftover prototype.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.59 2008/07/11 15:18:29 okan Exp $
a414 1
void			 screen_init(void);
@


1.59
log
@no more hidden (and mysterious) config reloads and allow binding a key
to a config reload; CMS-r by default.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.58 2008/07/11 14:21:28 okan Exp $
a399 1
void			 xu_key_grab_keycode(Window, int, int);
@


1.58
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.57 2008/06/25 22:44:42 oga Exp $
a427 1
int			 conf_changed(char *);
d446 1
@


1.57
log
@Allow a mouse binding to hide a window, and add a default keybinding for CMS-M3,
so it's hard to press by accident, but there if you need it.

requested (in a way) and tested by johan and todd.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.56 2008/06/25 22:37:29 oga Exp $
d86 2
a87 2
	TAILQ_ENTRY(winname) entry;
	char *name;
@


1.56
log
@Actually grab the correct mouse buttons for a window, instead of doing the
old hardcoded ones (which now can be wrong).

tested by todd@@ and johan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.55 2008/06/17 23:40:33 oga Exp $
d460 1
@


1.55
log
@Ignore caps lock and numlock for keyboard bindings. The way Xlib makes
you do this is ugly. Also remove mod2 (numlock) and mod3 (odd) from the
list of keybinding modifiers. They don't make much sense here.

based on a heavily modified diff from Martynas.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.54 2008/06/15 02:47:46 oga Exp $
d427 1
@


1.54
log
@Rip out and burn the HASH_* stuff. We don't need a SPLAY tree for one font.
makes the code a lot simpler. While here rearrange the font handling functions
to be less shit.

ok and help okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.53 2008/06/14 22:04:11 okan Exp $
d387 1
a387 1
int			 xu_btn_grab(Window, int, u_int);
@


1.53
log
@(mostly) proper xshape event support

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.52 2008/06/14 21:48:54 okan Exp $
a25 2
#include "hash.h"

a40 14
struct screen_ctx;

struct fontdesc {
	const char		*name;
	XftFont			*fn;
	struct screen_ctx	*sc;
	HASH_ENTRY(fontdesc)	 node;
};

int fontdesc_cmp(struct fontdesc *a, struct fontdesc *b);

HASH_HEAD(fonthash, fontdesc, 16);
HASH_PROTOTYPE(fonthash, fontdesc, node, fontdesc_cmp);

a62 2
	struct fonthash	 fonthash;
	u_int		 fontheight;
d266 2
d429 1
d483 2
a484 3
struct fontdesc		*font_get(struct screen_ctx *, const char *);
int			 font_width(struct fontdesc *, const char *, int);
void			 font_draw(struct fontdesc *, const char *, int,
d486 5
a490 3
int			 font_ascent(struct fontdesc *);
int			 font_descent(struct fontdesc *);
struct fontdesc		*font_getx(struct screen_ctx *, const char *);
a511 3

extern struct fontdesc			*DefaultFont;

@


1.52
log
@confable menu and window mouse bindings from rivo nurges (thanks!) with
some minor fixups, man page bits and knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.51 2008/06/12 19:10:56 okan Exp $
d387 1
@


1.51
log
@kill another long gone proto
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.50 2008/05/21 14:11:19 oga Exp $
d252 11
d265 1
d274 1
d440 2
d467 9
@


1.50
log
@Make menu_filter handle mouse movement too. This enables the keyboard
search dialogues to be manipulated with the mouse, too. It also allows
me to shrink the codebase further by killing grab_menu().

One known issue with highlighting the first entry in a search dialogue,
that'll be fixed soonish.

ok okan@@, tested by Edd Barrett and todd@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.49 2008/05/20 14:50:51 oga Exp $
a408 1
void			 grab_label(struct client_ctx *);
@


1.49
log
@Pull out the behaviour in grab_label and search_start into one utility
function menu_filter(). The plan is to eventually merge in grab_menu too.
Shrinks the code a fair bit.

Also, change XMaskEvent for XWindowEvent to prevent getting exposes for other
windows. This is particuarly noticable on slow machines with a LOT of xterms
(todd, you're an odd man).

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.48 2008/05/19 18:07:53 okan Exp $
d68 1
a68 1
	GC		 gc, hlgc;
d359 1
a408 2
void			 grab_menuinit(struct screen_ctx *);
void			*grab_menu(XButtonEvent *, struct menu_q *);
@


1.48
log
@stop normalizing search input; searching and matching are still
case-insensitive.  since this was the only use of normalizing input,
simplify as well.

allows one to exec with mixed case unmatched commands.

"works for me" oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.47 2008/05/19 17:32:22 oga Exp $
a62 1
	Window		 searchwin;
a73 1
	int		 maxinitialised;
d80 1
d356 4
a454 5
void			 search_init(struct screen_ctx *);
struct menu	*search_start(struct menu_q *,
		    void (*)(struct menu_q *, struct menu_q *, char *),
		    void (*)(struct menu *, int),
		    char *, int);
@


1.47
log
@Function prototypes should not have parameter names in them. These must
have been missed last time i knfed this.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.46 2008/05/19 17:24:19 okan Exp $
d313 1
a313 1
			     char *, int);
@


1.46
log
@client_cyclenext() -> client_cycle() since we now pass an arg.

removes a stray proto as well.

discussed with and ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.45 2008/05/19 17:13:55 oga Exp $
d348 7
a354 7
void			 client_map(struct client_ctx *cc);
void			 client_mtf(struct client_ctx *cc);
struct client_ctx	*client_cycle(int reverse);
struct client_ctx	*client_mrunext(struct client_ctx *cc);
struct client_ctx	*client_mruprev(struct client_ctx *cc);
void			 client_gethints(struct client_ctx *cc);
void			 client_freehints(struct client_ctx *cc);
d453 3
a455 3
struct menu	*search_start(struct menu_q *menuq,
		    void (*match)(struct menu_q *, struct menu_q *, char *),
		    void (*print)(struct menu *mi, int),
d459 1
a459 1
void			 search_print_client(struct menu *mi, int list);
@


1.45
log
@allow an autogroup value of 0 to mean no group. This means you can set
automatically "sticky" (in the traditional sense of the word) windows in
autogroup mode.

Based on an initial diff from Andrew Fresh, thanks!

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.44 2008/05/19 17:11:19 okan Exp $
a342 1
void			 client_cycle(struct client_ctx *);
d350 1
a350 1
struct client_ctx	*client_cyclenext(int reverse);
@


1.44
log
@as done with cycle/rcycle, make prev/next group switching one kbfuncs
and use a flag; adjusted to match and rename to {r,}cycle.

"ok, since i came up with the same thing" oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.43 2008/05/19 15:17:50 oga Exp $
d162 1
a162 1
	"XXX", "one", "two", "three",
@


1.43
log
@Use the XGrabKeyboard hack in for alt-tabbing as well. This stops the
mru getting the order messed up when gvim/xpdf et all steal key events.

While i'm here, change the logic in client_cyclenext() to use break instead
of goto, it's nicer that way.

Thirdly, instead of two different kbfuncs, just use the one and a flag.

"put your cycle diff in so I can pkg_delete gvim" okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.42 2008/05/19 12:56:58 okan Exp $
d224 1
a224 1
/* For alt-tab */
d227 3
d440 1
a440 2
void			 kbfunc_client_nextgroup(struct client_ctx *, void *);
void			 kbfunc_client_prevgroup(struct client_ctx *, void *);
d468 1
a468 1
void			 group_slide(int);
@


1.42
log
@finally implement keyboard binding for group toggling

idea for the
    "slightly-less-abhorrent-hack-but-a-hack-nonetheless-TM" from oga@@

grab and ungrab the keyboard to get around some silly X apps that like
stealing events

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.41 2008/05/18 19:43:50 oga Exp $
d224 3
@


1.41
log
@Kill conf_get_int(), it was a silly function anyway.

Since it's only used once just put the (simplified) logic into
conf_client() instead. This  means we can kill an enum and
CONF_IGNORECASE, too.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.40 2008/05/18 19:38:18 oga Exp $
d437 1
@


1.40
log
@group_ctx->name is only used in this one function, and for now it
corresponds directly to the static list of group names. Just use the
static list and stop strdup()ing a new version for the context struct.
Since that never got freed this also fixes a small memleak.

Kill some unused variables while i'm here.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.39 2008/05/17 03:59:54 okan Exp $
a34 4
enum conftype {
	CONF_BWIDTH, CONF_IGNORE,
};

a213 1
#define CONF_IGNORECASE		0x01
d216 1
a216 3

	char	title[CONF_MAX_WINTITLE];
	int	opts;
a417 1
int			 conf_get_int(struct client_ctx *, enum conftype);
a418 3
void			 conf_bindkey(struct conf *,
			     void (*)(struct client_ctx *, void *),
			     int, int, int, void *);
a422 1
char			*conf_get_str(struct client_ctx *, enum conftype);
@


1.39
log
@fix cwm's current XShape support from Edd Barrett -thanks.

XShape events should be handled at some point.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.38 2008/05/01 18:01:13 oga Exp $
a173 1
	char			*name;
@


1.38
log
@Rework the alt-tabbing code to be a lot simpler.

Diff mostly from Edd Barrett, with some minor changes from me.
Unfortunately the issue where apps like gvim and xpdf are stealing
keyrelease events causing the ordering to be messed up, but this is a
lot better. A fix for the aforementioned issue shall be forthcoming,
once a good one's been found.

ok okan@@, also tested by todd@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.37 2008/04/16 13:47:29 oga Exp $
d358 1
@


1.37
log
@merge kbfunc_{ptrmove,client_{move,resize}} into one function that takes a flag,
this code was almost identical...

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.36 2008/04/16 13:40:34 oga Exp $
a83 2

	struct client_ctx* cycle_client;
@


1.36
log
@remove infowin. It slipped out of the last commit, for some reason.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.35 2008/04/16 13:38:09 oga Exp $
d208 8
a215 4
#define CWM_BIGMOVE	0x1000
enum directions {
	CWM_UP = 0, CWM_DOWN, CWM_LEFT, CWM_RIGHT,
};
d454 1
a454 2
void			 kbfunc_client_move(struct client_ctx *, void *);
void			 kbfunc_client_resize(struct client_ctx *, void *);
a456 1
void			 kbfunc_ptrmove(struct client_ctx *, void *);
@


1.35
log
@Replace a few leftover calls to strdup and calloc with xstrdup and xcalloc
respectively.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.34 2008/04/16 13:35:37 oga Exp $
a67 1
	Window		 infowin;
@


1.34
log
@Remove screen_infomsg(), nothing uses it.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.33 2008/04/16 13:33:26 oga Exp $
d412 1
a412 1
void			*xcalloc(size_t);
d416 1
a416 1
#define XCALLOC(p, t) ((p) = (t *)xcalloc(sizeof * (p)))
@


1.33
log
@kill an unused struct member.

ok okan
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.32 2008/04/15 21:20:56 oga Exp $
a352 1
void			 client_altrelease();
a421 1
void			 screen_infomsg(char *);
@


1.32
log
@make the argument parser for commands accept quoted strings, while i'm
there make u_spawn use exec_wm (renamed to u_exec) for it's execution to
remove duplicated code.

This means constructs like this work in .cwmrc:

bind CM-t "ssh -Y 192.168.1.2 \"xterm -e top\""

or alternatively:

bind CM-t "ssh -Y 192.168.1.2 'xterm -e top'"

"in it goes" okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.31 2008/04/15 20:26:50 oga Exp $
a67 1
	Window		 groupwin;
@


1.31
log
@Kill dirent_isdir() and dirent_islink() nothing used them since the new
parser went in.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.30 2008/04/15 20:24:41 oga Exp $
d404 1
a404 1
void			 exec_wm(char *);
@


1.30
log
@hit it with the knf stick.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.29 2008/04/15 18:46:58 oga Exp $
a402 3
int			 dirent_exists(char *);
int			 dirent_isdir(char *);
int			 dirent_islink(char *);
@


1.29
log
@Add "gap" support to .cwmrc. The options put in here make gaps on the edge
of the screen where an application won't be {,vert}maximized over. used for
placing a statusbar or something like xclock.

Patch from Edd Barrett, with input from myself and okan. Thanks!

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.28 2008/04/09 18:10:47 okan Exp $
a46 2
/* #define CYCLE_FOREACH_MRU(cy, ctx) TAILQ_FOREACH((ctx),  */

d50 4
a53 4
	const char           *name;
	XftFont              *fn;
	struct screen_ctx    *sc;
	HASH_ENTRY(fontdesc)  node;
d89 3
a91 3
	struct fonthash  fonthash;
	XftDraw         *xftdraw;
	XftColor         xftcolor;
d109 1
a109 1
#define CLIENT_HIGHLIGHT_RED	2 
d129 1
a129 1
	Colormap		 cmap;	
d158 1
a158 1
	struct group_ctx        *group;
d160 1
a160 1
	int                      stackingorder;
d162 3
a164 3
	char                    *app_class;
	char                    *app_name;
	char                    *app_cliarg;
d176 8
a183 8
	TAILQ_ENTRY(group_ctx) entry;
	struct client_ctx_q  clients;
	char                *name;
	int                  shortcut;
	int                  hidden;
	int                  nhidden;
	int                  highstack;
};	
d200 6
a205 6
	TAILQ_ENTRY(xevent) entry;
	Window  *xev_win;
	Window  *xev_root;
	int     xev_type;
	void  (*xev_cb)(struct xevent *, XEvent *);
	void   *xev_arg;
d212 1
a212 1
	CWM_UP=0, CWM_DOWN, CWM_LEFT, CWM_RIGHT,
d218 2
a219 2
#define CONF_MAX_WINTITLE 256
#define CONF_IGNORECASE   0x01
d221 1
a221 1
	TAILQ_ENTRY(winmatch) entry;
d223 2
a224 2
	char title[CONF_MAX_WINTITLE];
	int  opts;
d238 7
a244 7
	int modmask;
	int keysym;
        int keycode;
	int flags;
        void (*callback)(struct client_ctx *, void *);
        void *argument;
	TAILQ_ENTRY(keybinding) entry;
d248 4
a251 5
	TAILQ_ENTRY(cmd) entry;
	int flags;
#define CMD_STATIC	0x01		/* static configuration in conf.c */
	char image[MAXPATHLEN];
	char label[256];
d266 1
a267 1
#define CONF_STICKY_GROUPS	0x0001
d272 1
a272 1
#define	DEFAULTFONTNAME		"sans-serif:pixelsize=14:bold"
d274 1
a274 1
	int			gap_top, gap_bottom, gap_left, gap_right;
d282 2
a283 2
	TAILQ_ENTRY(menu) entry;
	TAILQ_ENTRY(menu) resultentry;
d285 4
a288 4
	char  text[MENU_MAXENTRY + 1];
	char  print[MENU_MAXENTRY + 1];
	void *ctx;
	short dummy;
d302 3
a304 3
	u_long  flags;
	u_long  functions;
	u_long  decorations;
d309 64
a372 63
#define PROP_MWM_HINTS_ELEMENTS	3
#define MWM_HINTS_DECORATIONS	(1 << 1)
#define MWM_DECOR_ALL		(1 << 0)
#define MWM_DECOR_BORDER	(1 << 1)

int input_keycodetrans(KeyCode, u_int, enum ctltype *, char *, int);

int   x_errorhandler(Display *, XErrorEvent *);
void  x_setup(char *display_name);
char *x_screenname(int);
void  x_setupscreen(struct screen_ctx *, u_int);
__dead void  usage(void);

struct client_ctx *client_find(Window);
void               client_setup(void);
struct client_ctx *client_new(Window, struct screen_ctx *, int);
int                client_delete(struct client_ctx *, int, int);
void               client_setactive(struct client_ctx *, int);
void               client_gravitate(struct client_ctx *, int);
void               client_resize(struct client_ctx *);
void               client_lower(struct client_ctx *);
void               client_raise(struct client_ctx *);
void               client_move(struct client_ctx *);
void               client_leave(struct client_ctx *);
void               client_send_delete(struct client_ctx *);
struct client_ctx *client_current(void);
void               client_hide(struct client_ctx *);
void               client_unhide(struct client_ctx *);
void               client_nocurrent(void);
void               client_setname(struct client_ctx *);
void               client_warp(struct client_ctx *);
void               client_ptrwarp(struct client_ctx *);
void               client_ptrsave(struct client_ctx *);
void               client_draw_border(struct client_ctx *);
void               client_update(struct client_ctx *);
void               client_cycle(struct client_ctx *);
void               client_placecalc(struct client_ctx *);
void               client_maximize(struct client_ctx *);
void               client_vertmaximize(struct client_ctx *);
u_long             client_bg_pixel(struct client_ctx *);
Pixmap             client_bg_pixmap(struct client_ctx *);
void               client_map(struct client_ctx *cc);
void               client_mtf(struct client_ctx *cc);
struct client_ctx *client_cyclenext(int reverse);
void               client_altrelease();
struct client_ctx *client_mrunext(struct client_ctx *cc);
struct client_ctx *client_mruprev(struct client_ctx *cc);
void               client_gethints(struct client_ctx *cc);
void               client_freehints(struct client_ctx *cc);

void xev_handle_maprequest(struct xevent *, XEvent *);
void xev_handle_unmapnotify(struct xevent *, XEvent *);
void xev_handle_destroynotify(struct xevent *, XEvent *);
void xev_handle_configurerequest(struct xevent *, XEvent *);
void xev_handle_propertynotify(struct xevent *, XEvent *);
void xev_handle_enternotify(struct xevent *, XEvent *);
void xev_handle_leavenotify(struct xevent *, XEvent *);
void xev_handle_buttonpress(struct xevent *, XEvent *);
void xev_handle_buttonrelease(struct xevent *, XEvent *);
void xev_handle_keypress(struct xevent *, XEvent *);
void xev_handle_keyrelease(struct xevent *, XEvent *);
void xev_handle_expose(struct xevent *, XEvent *);
void xev_handle_clientmessage(struct xevent *, XEvent *);
d378 2
a379 1
void xev_reconfig(struct client_ctx *);	/* XXX should be xu_ */
d381 38
a418 36
void           xev_init(void);
struct xevent *xev_new(Window *, Window *, int, void (*)(struct xevent *, XEvent *), void *);
void           xev_register(struct xevent *);
void           xev_loop(void);

int   xu_ptr_grab(Window, int, Cursor);
int   xu_btn_grab(Window, int, u_int);
int   xu_ptr_regrab(int, Cursor);
void  xu_btn_ungrab(Window, int, u_int);
void  xu_ptr_ungrab(void);
void  xu_ptr_setpos(Window, int, int);
void  xu_ptr_getpos(Window, int *, int *);
void  xu_key_grab(Window, int, int);
void  xu_sendmsg(struct client_ctx *, Atom, long);
int   xu_getprop(struct client_ctx *, Atom, Atom, long, u_char **);
char *xu_getstrprop(struct client_ctx *, Atom atm);
void  xu_setstate(struct client_ctx *, int);
int   xu_getstate(struct client_ctx *, int *);
void  xu_key_grab_keycode(Window, int, int);

int dirent_exists(char *);
int dirent_isdir(char *);
int dirent_islink(char *);
int u_spawn(char *);
void exec_wm(char *);

void  grab_sweep(struct client_ctx *);
void  grab_drag(struct client_ctx *);
void  grab_menuinit(struct screen_ctx *);
void *grab_menu(XButtonEvent *, struct menu_q *);
void  grab_label(struct client_ctx *);

void  xfree(void *);
void *xmalloc(size_t);
void *xcalloc(size_t);
char *xstrdup(const char *);
d423 75
a497 73
void               screen_init(void);
struct screen_ctx *screen_fromroot(Window);
struct screen_ctx *screen_current(void);
void               screen_updatestackingorder(void);
void               screen_infomsg(char *);

void  conf_setup(struct conf *, const char *);
int   conf_get_int(struct client_ctx *, enum conftype);
void  conf_client(struct client_ctx *);
void  conf_bindkey(struct conf *, void (*)(struct client_ctx *, void *),
          int, int, int, void *);
void  conf_bindname(struct conf *, char *, char *);
void  conf_unbind(struct conf *, struct keybinding *);
int   conf_changed(char *);
void  conf_reload(struct conf *c);
char *conf_get_str(struct client_ctx *, enum conftype);

void kbfunc_client_lower(struct client_ctx *, void *);
void kbfunc_client_raise(struct client_ctx *, void *);
void kbfunc_client_search(struct client_ctx *, void *);
void kbfunc_client_hide(struct client_ctx *, void *);
void kbfunc_client_cycle(struct client_ctx *, void *);
void kbfunc_client_rcycle(struct client_ctx *cc, void *arg);
void kbfunc_cmdexec(struct client_ctx *, void *);
void kbfunc_client_label(struct client_ctx *, void *);
void kbfunc_client_delete(struct client_ctx *, void *);
void kbfunc_client_group(struct client_ctx *, void *);
void kbfunc_client_nextgroup(struct client_ctx *, void *);
void kbfunc_client_prevgroup(struct client_ctx *, void *);
void kbfunc_client_nogroup(struct client_ctx *, void *);
void kbfunc_client_maximize(struct client_ctx *, void *);
void kbfunc_client_vmaximize(struct client_ctx *, void *);
void kbfunc_quit_wm(struct client_ctx *, void *);
void kbfunc_client_move(struct client_ctx *, void *);
void kbfunc_client_resize(struct client_ctx *, void *);
void kbfunc_menu_search(struct client_ctx *, void *);
void kbfunc_exec(struct client_ctx *, void *);
void kbfunc_ptrmove(struct client_ctx *, void *);
void kbfunc_ssh(struct client_ctx *, void *);
void kbfunc_term(struct client_ctx *cc, void *arg);
void kbfunc_lock(struct client_ctx *cc, void *arg);

void  search_init(struct screen_ctx *);
struct menu *search_start(struct menu_q *menuq,
    void (*match)(struct menu_q *, struct menu_q *, char *),
    void (*print)(struct menu *mi, int),
    char *, int);
void  search_match_client(struct menu_q *, struct menu_q *, char *);
void  search_print_client(struct menu *mi, int list);
void  search_match_text(struct menu_q *, struct menu_q *, char *);
void  search_match_exec(struct menu_q *, struct menu_q *, char *);

void group_init(void);
void group_hidetoggle(int);
void group_slide(int);
void group_sticky(struct client_ctx *);
void group_client_delete(struct client_ctx *);
void group_menu(XButtonEvent *);
void group_alltoggle(void);
void group_sticky_toggle_enter(struct client_ctx *);
void group_sticky_toggle_exit(struct client_ctx *);
void group_autogroup(struct client_ctx *);

void notification_init(struct screen_ctx *);

void font_init(struct screen_ctx *sc);
struct fontdesc *font_get(struct screen_ctx *sc, const char *name);
int font_width(struct fontdesc *fdp, const char *text, int len);
void font_draw(struct fontdesc *fdp, const char *text, int len,
    Drawable d, int x, int y);
int font_ascent(struct fontdesc *fdp);
int font_descent(struct fontdesc *fdp);
struct fontdesc *font_getx(struct screen_ctx *sc, const char *name);
d520 1
a520 1
extern struct fontdesc                  *DefaultFont;
@


1.28
log
@remove alt-tab menu

discussed with a few

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.27 2008/04/07 23:47:09 simon Exp $
d277 1
@


1.27
log
@Add quit function, bind it per default to CM-q and change exec_wm
binding to CM-w.

Inital diff from Gleydson Soares
Feedback from oga@@ and okan@@

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.26 2008/03/26 15:45:42 oga Exp $
a354 1
void               client_cycleinfo(struct client_ctx *cc);
@


1.26
log
@Fix a couple of issues with the maximization code.

If a window is vertically maximized, then resized, before the MAXIMIZED
flag wasn't removed, now it is. so doing a resize then does the right
thing.

Also, separate flags are needed for vertical and normal maximziation,
else when you do vertical-maximize, followed by maximize, the window
returns to it's original size.

ok simon@@, okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.25 2008/03/23 15:09:21 simon Exp $
d454 1
@


1.25
log
@Replace the symlink configuration scheme with a simple yacc parser as
found in other places of the tree.  Remove sticky and font commandline
options and add another one for alternative config locations.
Split off cwmrc(5) from cwm(1), nuke #ifdef __OpenBSD__ while there.

tested by various kind people, feedback from oga@@ and okan@@ - thanks!
ok oga@@, jasper@@, okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.24 2008/03/22 15:09:45 oga Exp $
d98 2
a99 2
#define CLIENT_PROTO_DELETE     0x01
#define CLIENT_PROTO_TAKEFOCUS  0x02
d101 1
a101 1
#define CLIENT_MAXNAMEQLEN 5
d103 6
a108 4
#define CLIENT_HIDDEN  0x01
#define CLIENT_IGNORE  0x02
#define CLIENT_INQUEUE 0x04	/* tmp used by search code */
#define CLIENT_MAXIMIZED 0x08
d110 2
a111 2
#define CLIENT_HIGHLIGHT_BLUE 1
#define CLIENT_HIGHLIGHT_RED 2 
@


1.24
log
@Rip out, burn, and dance around the grave of group-edit mode.
I've yet to speak to anyone who uses it, so just kill it.

You can still add/remove from groups using the mouse binding.  Groups
may get a re-work sometime soon if i have a stroke of genius.

knocks about 4k off the i386 binary for me.

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.23 2008/03/22 14:09:02 oga Exp $
d33 2
d169 6
d215 14
d261 5
a265 4
	struct keybinding_q keybindingq;
	struct autogroupwin_q autogroupq;
	char	      menu_path[MAXPATHLEN];
	struct cmd_q  cmdq;
d267 1
a267 1
	int	      flags;
d270 5
a274 2
	char          termpath[MAXPATHLEN];
	char          lockpath[MAXPATHLEN];
d426 1
a426 1
void  conf_setup(struct conf *);
d433 2
a434 8
void  conf_parsekeys(struct conf *, char *);
void  conf_parsesettings(struct conf *, char *);
void  conf_parseignores(struct conf *, char *);
void  conf_parseautogroups(struct conf *, char *);
void  conf_cmd_clear(struct conf *);
int   conf_cmd_changed(char *);
void  conf_cmd_populate(struct conf *, char *);
void  conf_cmd_refresh(struct conf *c);
@


1.23
log
@Remove a bunch of unused variables and incorrect comments.

"ok with me" okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.22 2008/02/20 13:00:18 oga Exp $
a156 1
	int                      groupcommit;
a425 1
void kbfunc_client_groupselect(struct client_ctx *, void *);
a451 7
void group_select(int);
void group_enter(void);
void group_exit(int);
void group_click(struct client_ctx *);
void group_display_init(struct screen_ctx *);
void group_display_draw(struct screen_ctx *);
void group_display_keypress(KeyCode);
a456 1
void group_namemode(void);
a457 2
void group_deletecurrent(void);
void group_done(void);
a493 1
extern int Groupmode;
@


1.22
log
@add exec_wm to calmwm.h, it was missing (bad ian@@!)

Also, exec_wm() currenty err()s out if something failed with the exec,
killing the currently running wm. This is bad. Replace the err() with
warn() instead.


from Gleydson Soares, thanks!
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.21 2008/02/13 21:48:03 oga Exp $
d34 1
a34 1
	CONF_BWIDTH, CONF_IGNORE, CONF_NOTIFIER,
a70 1
	GC		 invcg;
d75 1
a75 1
	GC		 gc, invgc, hlgc;
a84 2
        FILE            *notifier;

a202 16
/* Keybindings */
enum kbtype {
	KB_DELETE, KB_NEWTERM0, KB_NEWTERM1, KB_HIDE,
	KB_LOWER, KB_RAISE, KB_SEARCH, KB_CYCLE, KB_LABEL,
	KB_GROUPSELECT, KB_VERTMAXIMIZE, KB_MAXIMIZE,

	/* Group numbers need to be in order. */
	KB_GROUP_1, KB_GROUP_2, KB_GROUP_3, KB_GROUP_4, KB_GROUP_5,
	KB_GROUP_6, KB_GROUP_7, KB_GROUP_8, KB_GROUP_9, KB_NOGROUP,
	KB_NEXTGROUP, KB_PREVGROUP,

	KB_MOVE_WEST, KB_MOVE_EAST, KB_MOVE_NORTH, KB_MOVE_SOUTH,

	KB__LAST
};

a212 1
#define KBFLAG_FINDCLIENT 0x02
a445 1
    void (*rank)(struct menu_q *, char *),
a451 1
void  search_rank_text(struct menu_q *, char *);
@


1.21
log
@usage never returns, and thus should be __dead.

ok jasper@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.20 2008/02/13 21:04:19 oga Exp $
d399 1
@


1.20
log
@add usage() for when an unknown option is given.

from Gleydson Soares <gsoares@@gmail.com>, thanks!

ok jasper@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.19 2008/01/16 11:39:20 oga Exp $
d315 1
a315 1
void  usage(void);
@


1.19
log
@huge amount of cleanup and dead code removal.

full description of changes:
-remove fontlist, and all associated structures/calls, it's not needed.
 this also removes any doubt about leftover 9wm code (the list was
 borrowed from it). Since cwm now uses Xft for everything, the legacy
 font handling is just not needed.
-add /* FALLTHROUGH */ comments into grab_{label,menu}. I actually
 didn't intend grab_menu to be a fallthrough, but it actually works quite
 well there, so remove the extra rectangle drawing. I love it when that
 happens.
-remove a couple of unused prototypes that were obviously missed
 before.
-remove a bunch of commented out or if 0ed out code. It doesn't look to
 be coming back anytime soon.
-several functions returned an int, but this was never checked. most of
 them only failed if they failed to grab the pointer (thus the internal
 state didn't change), so just make them void and return early if this is
 the case.
-remove several unused functions and some useless variables.

knocks something like 200bytes off the stripped binary size for me.

ok marc@@, tested by several others.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.18 2008/01/14 15:21:10 oga Exp $
d315 1
@


1.18
log
@Rewrite most of grab_menu in grab.c (it was partly 9wm code).
This should work functionally the same, with a few simplifications.

Changes:
- we don't care if you're holding another button when you release the
  menu key if you don't want to select anything, move off the menu.
- remove the hysteresis from the menu selection (before you had to move
  more than three pixels onto a new menu entry before it selected it)
- simplify a lot of the selection code
- kill dead code.
- do what the XXX comment said and cache the screensize (i may tweak
  this later).

As far as I can tell, the only code remaining from 9wm is the list of
fonts in calmwm.c. Others appear to concur.

ok marc@@, looked over and tested by a few others. Reminders from okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.17 2008/01/11 16:06:44 oga Exp $
d314 1
a314 2
void  x_loop(void);
int   x_setupscreen(struct screen_ctx *, u_int);
d399 2
a400 2
int   grab_sweep(struct client_ctx *);
int   grab_drag(struct client_ctx *);
d474 1
a474 2
int  group_new(void);
int  group_select(int);
a509 1
extern XFontStruct			*X_Font;
@


1.17
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d18 1
a18 1
 * $Id: calmwm.h,v 1.16 2008/01/08 20:21:43 oga Exp $
d82 4
a282 1
	short lasthit;
a404 1
void  grab_exec(void);
@


1.16
log
@Kill some more dead code, cursor.c goes away.

ok marc@@
@
text
@a4 1
 * All rights reserved.
d6 13
a18 1
 * $Id: calmwm.h,v 1.15 2008/01/03 01:58:16 oga Exp $
@


1.15
log
@Kill draw.c, nothing uses the code in it.

More dead code removals to come.

ok marc@@
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.14 2008/01/02 20:54:32 marc Exp $
a483 2

Cursor cursor_bigarrow();
@


1.14
log
@remove declaration of removed function
Reminded by matthieu@@  (thanks!)
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.13 2007/11/28 16:35:52 ian Exp $
a447 2

void draw_outline(struct client_ctx *);
@


1.13
log
@Add a "restart wm" function. ok oga@@
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.12 2007/11/19 22:18:16 oga Exp $
a485 2

struct client_ctx *geographic_west(struct client_ctx *);
@


1.12
log
@Make cwm default keybindings always exist. Additional keybindings now
overlap with the new ones, overriding them. Also a new "unmap" keyword
in binding definitions now unmaps a binding without adding a new one.

This seriously shrinks the ~/.calmwm/.keys directory of anyone who defines
their own bindings whilst wanting some of the defaults.

Looked over, liked and ok todd@@
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.11 2007/11/13 23:26:04 todd Exp $
d211 4
@


1.11
log
@introduce conf_bindname() to drastically simplify conf.c
really liked by oga@@
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.10 2007/11/13 23:08:49 todd Exp $
d409 1
@


1.10
log
@enable pointer movement in cwm via C-<arrowkeys>
looked over by oga@@
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.9 2007/11/07 21:58:03 oga Exp $
d408 1
@


1.9
log
@Add support to cwm for resizing the windows using Control-Meta-[hjkl].

Please note that this remaps Control-Meta-L (label) to Control-Meta-N (name).

ok jasper@@, todd@@.
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.8 2007/06/27 13:28:22 todd Exp $
d438 1
@


1.8
log
@implement keyboard initiated movement of windows
enhanced version of diff originally from niallo@@
man bits from niallo@@
ok niallo@@ japser@@
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.7 2007/06/26 19:34:26 niallo Exp $
d435 1
@


1.7
log
@modify "exec" dialog so that it auto-completes based on executables in
_PATH_DEFPATH

add an "ssh-to" dialog which auto-completes based on contents of
 ~/.ssh/known_hosts (M-.)

testing and eyeballing by Simon Kuhnle <simonkuhnle at web.de>, todd@@, pedro@@
mk@@ and David Cathcart <david at cathcart.cx>

ok todd@@
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.6 2007/06/05 19:03:20 jasper Exp $
d207 5
d434 1
@


1.6
log
@make it possible to cycle through the windows when non are selected.
(eg. when they're hidden, now you can cycle through them)

from aon@@iki.fi
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.5 2007/05/28 18:34:27 jasper Exp $
d260 1
d431 1
d442 1
a442 1
    char *);
d446 1
@


1.5
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.4 2007/05/27 09:23:12 jasper Exp $
d323 1
a323 1
struct client_ctx *client_cyclenext(struct client_ctx *cc, int reverse);
@


1.4
log
@full screen sized windows

ok matthieu@@
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.3 2007/05/10 17:23:49 jasper Exp $
d487 2
a488 2
extern Display				*G_dpy;
extern XFontStruct			*G_font;
d490 5
a494 5
extern Cursor				 G_cursor_move;
extern Cursor				 G_cursor_resize;
extern Cursor				 G_cursor_select;
extern Cursor				 G_cursor_default;
extern Cursor				 G_cursor_question;
d496 3
a498 3
extern struct screen_ctx_q		 G_screenq;
extern struct screen_ctx		*G_curscreen;
extern u_int				 G_nscreens;
d500 1
a500 1
extern struct client_ctx_q		 G_clientq;
d502 2
a503 2
extern int				 G_doshape, G_shape_ev;
extern struct conf			 G_conf;
d505 1
a505 1
extern int G_groupmode;
@


1.3
log
@- add a "-d" option, to specify the display cwm should be started on
- adjust argc/argv by optind
- add an ENVIRONMENT section to the manpage

ok matthieu@@ ray@@
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.2 2007/04/27 18:08:14 bernd Exp $
d195 1
a195 1
	KB_GROUPSELECT, KB_VERTMAXIMIZE,
@


1.2
log
@Apply cwm-3-exec.diff from http://aon.iki.fi/cwm/. Document the new
key binding.
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
d288 1
a288 1
void  x_setup(void);
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * $Id: calmwm.h,v 1.52 2005/08/28 09:36:44 marius Exp $
d381 1
d429 1
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
