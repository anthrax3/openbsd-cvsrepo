head	1.29;
access;
symbols
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.6
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.9.0.2
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2013.05.19.23.38.21;	author okan;	state dead;
branches;
next	1.28;

1.28
date	2013.05.19.23.16.29;	author okan;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.19.23.09.59;	author okan;	state Exp;
branches;
next	1.26;

1.26
date	2013.05.14.12.35.56;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.02.17.25.15;	author okan;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.17.18.34.06;	author okan;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.17.14.20.52;	author okan;	state Exp;
branches;
next	1.22;

1.22
date	2012.12.17.02.53.29;	author okan;	state Exp;
branches;
next	1.21;

1.21
date	2012.12.17.02.28.45;	author okan;	state Exp;
branches;
next	1.20;

1.20
date	2012.11.28.14.14.44;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.18;

1.18
date	2012.10.31.19.30.19;	author okan;	state Exp;
branches;
next	1.17;

1.17
date	2011.09.08.12.35.33;	author okan;	state Exp;
branches;
next	1.16;

1.16
date	2011.06.27.12.46.54;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.24.05.45.57;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.13;

1.13
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.15.03.26.22;	author okan;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.10;

1.10
date	2009.12.08.16.52.17;	author okan;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.17.23.40.57;	author okan;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.13.15.25.43;	author okan;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.11.18.32.08;	author okan;	state Exp;
branches;
next	1.6;

1.6
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.15.02.47.46;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.15.22.18.00;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.29
log
@move the 2 small font helper functions to xutil.c
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2005 Marius Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: font.c,v 1.28 2013/05/19 23:16:29 okan Exp $
 */

#include <sys/param.h>
#include <sys/queue.h>

#include <err.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

int
font_width(XftFont *xftfont, const char *text, int len)
{
	XGlyphInfo	 extents;

	XftTextExtentsUtf8(X_Dpy, xftfont, (const FcChar8*)text,
	    len, &extents);

	return (extents.xOff);
}

void
font_draw(struct screen_ctx *sc, const char *text,
    Drawable d, int color, int x, int y)
{
	XftDrawChange(sc->xftdraw, d);
	XftDrawStringUtf8(sc->xftdraw, &sc->xftcolor[color], sc->xftfont, x, y,
	    (const FcChar8*)text, strlen(text));
}
@


1.28
log
@move the rest of xft init into screen_conf, since most of it is based on
config parameters.
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.27 2013/05/19 23:09:59 okan Exp $
@


1.27
log
@- switch border colors to Xft
- merge border/menu color structures/functions since they now both use Xft
- switch xu_xorcolor to operating on XftColor instead of just
  XRenderColor (basically adding pixel)
- if color name allocation fails, revert back to default (this, along
  with font validation should occur during config parse, but we don't
  have screens setup yet - likely to change at some point)
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.26 2013/05/14 12:35:56 okan Exp $
a31 13

void
font_init(struct screen_ctx *sc, const char *name)
{
	sc->xftdraw = XftDrawCreate(X_Dpy, sc->rootwin,
	    sc->visual, sc->colormap);
	if (sc->xftdraw == NULL)
		errx(1, "XftDrawCreate");

	sc->xftfont = XftFontOpenName(X_Dpy, sc->which, name);
	if (sc->xftfont == NULL)
		errx(1, "XftFontOpenName");
}
@


1.26
log
@- let callers of font_draw figure out (and pass) the color instead of an
  'active' flag.
- use strlen() inside of font_draw; the only instance where it wasn't
  used happened to be ignored on a subsequent draw.
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.25 2013/05/02 17:25:15 okan Exp $
d34 1
a34 1
font_init(struct screen_ctx *sc, const char *name, const char **color)
a35 3
	int		 i;
	XRenderColor	 c;

a43 17

	for (i = 0; i < CWM_COLOR_MENU_MAX; i++) {
		if (*color[i] == '\0')
			break;
		if (!XftColorAllocName(X_Dpy, sc->visual, sc->colormap,
			color[i], &sc->xftcolor[i]))
			errx(1, "XftColorAllocName");
	}
	if (i == CWM_COLOR_MENU_MAX)
		return;

	xu_xorcolor(sc->xftcolor[CWM_COLOR_MENU_BG].color,
		    sc->xftcolor[CWM_COLOR_MENU_FG].color, &c);
	xu_xorcolor(sc->xftcolor[CWM_COLOR_MENU_FONT].color, c, &c);
	if (!XftColorAllocValue(X_Dpy, sc->visual, sc->colormap,
		&c, &sc->xftcolor[CWM_COLOR_MENU_FONT_SEL]))
		errx(1, "XftColorAllocValue");
@


1.25
log
@no need for font_{ascent,descent,height} wrappers; limit font_width to
just requiring xftfont.
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.24 2012/12/17 18:34:06 okan Exp $
d78 2
a79 2
font_draw(struct screen_ctx *sc, const char *text, int len,
    Drawable d, int active, int x, int y)
a80 3
	int	 color;

	color = active ? CWM_COLOR_MENU_FONT_SEL : CWM_COLOR_MENU_FONT;
d83 1
a83 1
	    (const FcChar8*)text, len);
@


1.24
log
@stash the default screen visual and colormap in screen_ctx
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.23 2012/12/17 14:20:52 okan Exp $
a32 18
int
font_ascent(struct screen_ctx *sc)
{
	return (sc->xftfont->ascent);
}

int
font_descent(struct screen_ctx *sc)
{
	return (sc->xftfont->descent);
}

u_int
font_height(struct screen_ctx *sc)
{
	return (sc->xftfont->height + 1);
}

d67 1
a67 1
font_width(struct screen_ctx *sc, const char *text, int len)
d71 1
a71 1
	XftTextExtentsUtf8(X_Dpy, sc->xftfont, (const FcChar8*)text,
@


1.23
log
@screen font -> xftfont
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.22 2012/12/17 02:53:29 okan Exp $
d58 1
a58 1
	    DefaultVisual(X_Dpy, sc->which), DefaultColormap(X_Dpy, sc->which));
d69 2
a70 3
		if (!XftColorAllocName(X_Dpy, DefaultVisual(X_Dpy, sc->which),
			DefaultColormap(X_Dpy, sc->which), color[i],
		       	&sc->xftcolor[i]))
d79 2
a80 3
	if (!XftColorAllocValue(X_Dpy, DefaultVisual(X_Dpy, sc->which),
		DefaultColormap(X_Dpy, sc->which), &c,
		&sc->xftcolor[CWM_COLOR_MENU_FONT_SEL]))
@


1.22
log
@knf
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.21 2012/12/17 02:28:45 okan Exp $
d36 1
a36 1
	return (sc->font->ascent);
d42 1
a42 1
	return (sc->font->descent);
d48 1
a48 1
	return (sc->font->height + 1);
d62 2
a63 2
	sc->font = XftFontOpenName(X_Dpy, sc->which, name);
	if (sc->font == NULL)
d91 1
a91 1
	XftTextExtentsUtf8(X_Dpy, sc->font, (const FcChar8*)text,
d105 1
a105 1
	XftDrawStringUtf8(sc->xftdraw, &sc->xftcolor[color], sc->font, x, y,
@


1.21
log
@non-trivial menu drawing rewrite, moving to Xft and solving various
font/color drawing issues; from Alexander Polakov
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.20 2012/11/28 14:14:44 okan Exp $
d54 2
a55 2
	int i;
	XRenderColor c;
d65 2
a66 1
	for(i = 0; i < CWM_COLOR_MENU_MAX; i++) {
d78 1
a78 1
			sc->xftcolor[CWM_COLOR_MENU_FG].color, &c);
d81 2
a82 2
				DefaultColormap(X_Dpy, sc->which), &c,
				&sc->xftcolor[CWM_COLOR_MENU_FONT_SEL]))
d101 1
a101 1
	int color;
@


1.20
log
@replace hand rolled font_make() with XftFontOpenName() and merge into
font_init().
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.19 2012/11/09 03:52:02 okan Exp $
d52 1
a52 1
font_init(struct screen_ctx *sc, const char *name, const char *color)
d54 3
a61 4
	if (!XftColorAllocName(X_Dpy, DefaultVisual(X_Dpy, sc->which),
	    DefaultColormap(X_Dpy, sc->which), color, &sc->xftcolor))
		errx(1, "XftColorAllocName");

d65 18
d98 1
a98 1
    Drawable d, int x, int y)
d100 3
d104 1
a104 1
	XftDrawStringUtf8(sc->xftdraw, &sc->xftcolor, sc->font, x, y,
@


1.19
log
@sort
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.18 2012/10/31 19:30:19 okan Exp $
d52 1
a52 1
font_init(struct screen_ctx *sc, const char *color)
d62 4
a85 18
}

XftFont *
font_make(struct screen_ctx *sc, const char *name)
{
	XftFont		*fn = NULL;
	FcPattern	*pat, *patx;
	XftResult	 res;

	if ((pat = FcNameParse((const FcChar8*)name)) == NULL)
		return (NULL);

	if ((patx = XftFontMatch(X_Dpy, sc->which, pat, &res)) != NULL)
		fn = XftFontOpenPattern(X_Dpy, patx);

	FcPatternDestroy(pat);

	return (fn);
@


1.18
log
@replace 'reload' with 'restart', which merely re-exec's cwm using the
existing argv; same idea with respect to argv saving as Alexander
Polakov.  reload support was half-complete and is getting in the way.

agreed to by many
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.17 2011/09/08 12:35:33 okan Exp $
d26 1
a28 1
#include <stdio.h>
@


1.17
log
@allow configurable menu font color; from Alexander Polakov with a tweak
from me.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.16 2011/06/27 12:46:54 okan Exp $
a53 2
	if (sc->xftdraw)
		XftDrawDestroy(sc->xftdraw);
a58 3
	if (sc->xftcolor.pixel)
		XftColorFree(X_Dpy, DefaultVisual(X_Dpy, sc->which),
		    DefaultColormap(X_Dpy, sc->which), &sc->xftcolor);
@


1.16
log
@UTF8-ify, from Alexander Polakov, but without setlocale(), after
feedback from stsp@@ - thanks!

'go for it' oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.15 2011/06/24 05:45:57 okan Exp $
d52 1
a52 1
font_init(struct screen_ctx *sc)
d54 2
d61 3
d65 1
a65 1
	    DefaultColormap(X_Dpy, sc->which), "black", &sc->xftcolor))
@


1.15
log
@struct XftFont already has height which we can use directly instead of
calculating ourselves, so do so.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: font.c,v 1.14 2011/05/11 13:53:51 okan Exp $
d69 1
a69 1
	XftTextExtents8(X_Dpy, sc->font, (const XftChar8*)text,
d80 1
a80 2
	/* Really needs to be UTF8'd. */
	XftDrawString8(sc->xftdraw, &sc->xftcolor, sc->font, x, y,
@


1.14
log
@tag and comment cleanup; ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD$
d48 1
a48 1
	return (sc->fontheight);
@


1.13
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d2 1
a2 1
 * font.c - cwm font abstraction
d17 2
@


1.12
log
@rid ourselves of these functional macros; convert to real functions.

ok oga@@
@
text
@d19 10
@


1.11
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d21 18
@


1.10
log
@start fixing screen_ctx usage, for it is utterly broken.  bring font
into screen_ctx and start passing screen_ctx around to in order get rid
of Curscreen; fixup per-screen config colors the same way.

diff mostly from oga@@, with a bit harsher reaction to the state of screen_ctx.

"please commit" oga@@
@
text
@a18 1
#include "headers.h"
@


1.9
log
@a long time coming - re-work the way we deal with colors: since we're
using Xft(3), use it to select the font color as well instead of trying
to build one; properly allocate and free colors at-will, e.g. we now
have configurable colors.

feedback and ok's todd@@ and oga@@
@
text
@d36 1
a36 1
font_width(const char *text, int len)
d40 1
a40 1
	XftTextExtents8(X_Dpy, Conf.DefaultFont, (const XftChar8*)text,
d52 1
a52 1
	XftDrawString8(sc->xftdraw, &sc->xftcolor, Conf.DefaultFont, x, y,
@


1.8
log
@better cast; noticed by ray@@

ok ray@@ oga@@
@
text
@a24 2
	XColor	 xcolor, tmp;

d30 3
a32 9
	if (!XAllocNamedColor(X_Dpy, DefaultColormap(X_Dpy, sc->which),
	    "black", &xcolor, &tmp))
		errx(1, "XAllocNamedColor");

	sc->xftcolor.color.red = xcolor.red;
	sc->xftcolor.color.green = xcolor.green;
	sc->xftcolor.color.blue = xcolor.blue;
	sc->xftcolor.color.alpha = 0x00ff00;
	sc->xftcolor.pixel = xcolor.pixel;
@


1.7
log
@FcNameParse() manpage lies, cast here.

found with pcc.

ok oga@@
@
text
@d71 1
a71 1
	if ((pat = FcNameParse((FcChar8*)name)) == NULL)
@


1.6
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d71 1
a71 1
	if ((pat = FcNameParse(name)) == NULL)
@


1.5
log
@Rip out and burn the HASH_* stuff. We don't need a SPLAY tree for one font.
makes the code a lot simpler. While here rearrange the font handling functions
to be less shit.

ok and help okan@@.
@
text
@d25 1
a25 1
	XColor xcolor, tmp;
d46 2
a47 1
	XGlyphInfo extents;
d67 3
a69 3
	XftFont *fn = NULL;
	FcPattern *pat, *patx;
	XftResult res;
@


1.4
log
@KNF, no binary change.

From Pierre Riteau. Thanks!
@
text
@a18 1
#include "hash.h"
a21 35
static XftFont *_make_font(struct screen_ctx *sc, struct fontdesc *fdp);

HASH_GENERATE(fonthash, fontdesc, node, fontdesc_cmp);

int
fontdesc_cmp(struct fontdesc *a, struct fontdesc *b)
{
	return (strcmp(a->name, b->name));
}

/*
 * Fowler/Noll/Vo hash
 *    http://www.isthe.com/chongo/tech/comp/fnv/
 */

#define	FNV_P_32	((unsigned int)0x01000193)	/* 16777619 */
#define	FNV_1_32	((unsigned int)0x811c9dc5)	/* 2166136261 */

unsigned int
fontdesc_hash(struct fontdesc *fdp)
{
	const unsigned char *p, *end, *start;
	unsigned int hash = FNV_1_32;

	start = fdp->name;
	end = (const unsigned char *)fdp->name + strlen(fdp->name);

	for (p = start; p < end; p++) {
		hash *= FNV_P_32;
		hash ^= (unsigned int)*p;
	}

	return (hash);
}

a26 1
	HASH_INIT(&sc->fonthash, fontdesc_hash);
a42 31
struct fontdesc *
font_getx(struct screen_ctx *sc, const char *name)
{
	struct fontdesc *fdp;

	if ((fdp = font_get(sc, name)) == NULL)
		errx(1, "font_get()");

	return (fdp);
}

struct fontdesc *
font_get(struct screen_ctx *sc, const char *name)
{
	struct fontdesc fd, *fdp;
	XftFont *fn;

	fd.name = name;

	if ((fdp = HASH_FIND(fonthash, &sc->fonthash, &fd)) == NULL
	    && (fn = _make_font(sc, &fd)) != NULL) {
		fdp = xmalloc(sizeof(*fdp));
		fdp->name = xstrdup(fd.name);
		fdp->fn = fn;
		fdp->sc = sc;
		HASH_INSERT(fonthash, &sc->fonthash, fdp);
	}

	return (fdp);
}

d44 1
a44 1
font_width(struct fontdesc *fdp, const char *text, int len)
d47 2
a48 1
	XftTextExtents8(X_Dpy, fdp->fn, (const XftChar8*)text, len, &extents);
d54 1
a54 1
font_draw(struct fontdesc *fdp, const char *text, int len,
d57 1
a57 1
	XftDrawChange(fdp->sc->xftdraw, d);
d59 1
a59 1
	XftDrawString8(fdp->sc->xftdraw, &fdp->sc->xftcolor, fdp->fn, x, y,
d63 2
a64 14
int
font_ascent(struct fontdesc *fdp)
{
	return (fdp->fn->ascent);
}

int
font_descent(struct fontdesc *fdp)
{
	return (fdp->fn->descent);
}

static XftFont *
_make_font(struct screen_ctx *sc, struct fontdesc *fdp)
d70 1
a70 1
	if ((pat = FcNameParse(fdp->name)) == NULL)
@


1.3
log
@hit it with the knf stick.
@
text
@d70 1
a70 1
		"black", &xcolor, &tmp))
@


1.2
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@d30 1
a30 1
	return strcmp(a->name, b->name);
d38 2
a39 2
#define FNV_P_32 ((unsigned int)0x01000193) /* 16777619 */
#define FNV_1_32 ((unsigned int)0x811c9dc5) /* 2166136261 */
d44 2
a45 2
        const unsigned char *p, *end, *start;
        unsigned int hash = FNV_1_32;
d50 4
a53 4
        for (p = start; p < end; p++) {
                hash *= FNV_P_32;
                hash ^= (unsigned int)*p;
        }
d55 1
a55 1
        return (hash);
d114 2
a115 2
    XGlyphInfo extents;
    XftTextExtents8(X_Dpy, fdp->fn, (const XftChar8*)text, len, &extents);
d117 1
a117 1
    return (extents.xOff);
d133 1
a133 1
	return fdp->fn->ascent;
d139 1
a139 1
	return fdp->fn->descent;
a158 1

@


1.1
log
@Initial revision
@
text
@d64 2
a65 2
	sc->xftdraw = XftDrawCreate(G_dpy, sc->rootwin,
	    DefaultVisual(G_dpy, sc->which), DefaultColormap(G_dpy, sc->which));
d69 1
a69 1
	if (!XAllocNamedColor(G_dpy, DefaultColormap(G_dpy, sc->which),
d115 1
a115 1
    XftTextExtents8(G_dpy, fdp->fn, (const XftChar8*)text, len, &extents);
d152 2
a153 2
	if ((patx = XftFontMatch(G_dpy, sc->which, pat, &res)) != NULL)
		fn = XftFontOpenPattern(G_dpy, patx);
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
