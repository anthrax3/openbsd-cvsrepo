head	1.21;
access;
symbols
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_2:1.5.0.2
	OPENBSD_4_2_BASE:1.5
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2009.01.11.18.34.46;	author okan;	state dead;
branches;
next	1.20;

1.20
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.15.02.47.46;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.14.22.04.11;	author okan;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.12.18.55.35;	author okan;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.12.18.32.06;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.12.05.10.24;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.21.14.11.19;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.20.14.50.51;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.19.18.07.53;	author okan;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.17.03.59.55;	author okan;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.15.22.18.00;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.16.11.39.20;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.14.15.21.10;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.05.18.57.03;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2007.04.27.18.10.39;	author bernd;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.27.18.08.14;	author bernd;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.21
log
@- merge grab_sweep() into mousefunc_window_resize().
- merge grab_drag() into mousefunc_window_move().
- properly name, proto and static private functions.
- since we already do XMoveResizeWindow() and XMoveWindow() in (now)
mousefunc_window_resize() and mousefunc_window_move() respectively,
client_resize() and client_move() calls are unnecessary.

ok oga@@
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $Id: grab.c,v 1.20 2008/07/11 14:21:28 okan Exp $
 */

#include "headers.h"
#include "calmwm.h"

static int	_sweepcalc(struct client_ctx *, int, int, int, int);

#define ADJUST_HEIGHT(cc, dy)	((cc->geom.height - cc->geom.min_dy)/ dy)
#define ADJUST_WIDTH(cc, dx)	((cc->geom.width - cc->geom.min_dx)/ dx)

void
grab_sweep_draw(struct client_ctx *cc, int dx, int dy)
{
	struct screen_ctx	*sc = CCTOSC(cc);
	char			 asize[10]; /* fits "nnnnxnnnn\0" */
	int			 wide, height, wide_size, wide_name;
	int			 x = cc->geom.x, y = cc->geom.y;

	snprintf(asize, sizeof(asize), "%dx%d",
	    ADJUST_WIDTH(cc, dx), ADJUST_HEIGHT(cc, dy));
	wide_size = font_width(asize, strlen(asize)) + 4;
	wide_name = font_width(cc->name, strlen(cc->name)) + 4;
	wide = MAX(wide_size, wide_name);
	height = font_ascent() + font_descent() + 1;

	XMoveResizeWindow(X_Dpy, sc->menuwin, x, y, wide, height * 2);
	XMapWindow(X_Dpy, sc->menuwin);
	XReparentWindow(X_Dpy, sc->menuwin, cc->win, 0, 0);
	XClearWindow(X_Dpy, sc->menuwin);
	font_draw(sc, cc->name, strlen(cc->name), sc->menuwin,
	    2, font_ascent() + 1);
	font_draw(sc, asize, strlen(asize), sc->menuwin,
	    wide / 2 - wide_size / 2, height + font_ascent() + 1);
}

void
grab_sweep(struct client_ctx *cc)
{
	XEvent			 ev;
	struct screen_ctx	*sc = CCTOSC(cc);
	int			 x = cc->geom.x, y = cc->geom.y, dx, dy;

	dx = MAX(1, cc->size->width_inc);
	dy = MAX(1, cc->size->height_inc);

	client_raise(cc);
	client_ptrsave(cc);

	if (xu_ptr_grab(sc->rootwin, MouseMask, Cursor_resize) < 0)
		return;

	xu_ptr_setpos(cc->win, cc->geom.width, cc->geom.height);
	grab_sweep_draw(cc, dx, dy);

	for (;;) {
		/* Look for changes in ptr position. */
		XMaskEvent(X_Dpy, MouseMask|ExposureMask, &ev);

		switch (ev.type) {
		case Expose:
			client_draw_border(cc);
			break;
		case MotionNotify:
			if (_sweepcalc(cc, x, y, ev.xmotion.x, ev.xmotion.y))
				/* Recompute window output */
				grab_sweep_draw(cc, dx, dy);

			XMoveResizeWindow(X_Dpy, cc->pwin,
			    cc->geom.x - cc->bwidth,
			    cc->geom.y - cc->bwidth,
			    cc->geom.width + cc->bwidth*2,
			    cc->geom.height + cc->bwidth*2);
			XMoveResizeWindow(X_Dpy, cc->win,
			    cc->bwidth, cc->bwidth,
			    cc->geom.width, cc->geom.height);

			client_do_shape(cc);
			break;
		case ButtonRelease:
			XUnmapWindow(X_Dpy, sc->menuwin);
			XReparentWindow(X_Dpy, sc->menuwin, sc->rootwin, 0, 0);
			xu_ptr_ungrab();

			/* Make sure the pointer stays within the window. */
			if (cc->ptr.x > cc->geom.width)
				cc->ptr.x = cc->geom.width - cc->bwidth;
			if (cc->ptr.y > cc->geom.height)
				cc->ptr.y = cc->geom.height - cc->bwidth;
			client_ptrwarp(cc);

			return;
		}
	}
	/* NOTREACHED */
}

void
grab_drag(struct client_ctx *cc)
{
	XEvent			 ev;
	struct screen_ctx	*sc = CCTOSC(cc);
	int			 x = cc->geom.x, y = cc->geom.y, xm, ym;

	client_raise(cc);

	if (xu_ptr_grab(sc->rootwin, MouseMask, Cursor_move) < 0)
		return;

	xu_ptr_getpos(sc->rootwin, &xm, &ym);

	for (;;) {
		XMaskEvent(X_Dpy, MouseMask|ExposureMask, &ev);

		switch (ev.type) {
		case Expose:
			client_draw_border(cc);
			break;
		case MotionNotify:
			cc->geom.x = x + (ev.xmotion.x - xm);
			cc->geom.y = y + (ev.xmotion.y - ym);

			XMoveWindow(X_Dpy, cc->pwin,
			    cc->geom.x - cc->bwidth, cc->geom.y - cc->bwidth);

			break;
		case ButtonRelease:
			xu_ptr_ungrab();
			return;
		}
	}
	/* NOTREACHED */
}

static int
_sweepcalc(struct client_ctx *cc, int x, int y, int motionx, int motiony)
{
	int	 width, height;

	width = cc->geom.width;
	height = cc->geom.height;

	cc->geom.width = abs(x - motionx);
	cc->geom.height = abs(y - motiony);

	if (cc->size->flags & PResizeInc) {
		cc->geom.width -=
		    (cc->geom.width - cc->geom.min_dx) % cc->size->width_inc;
		cc->geom.height -=
		    (cc->geom.height - cc->geom.min_dy) % cc->size->height_inc;
	}

	if (cc->size->flags & PMinSize) {
		cc->geom.width = MAX(cc->geom.width, cc->size->min_width);
		cc->geom.height = MAX(cc->geom.height, cc->size->min_height);
	}

	if (cc->size->flags & PMaxSize) {
		cc->geom.width = MIN(cc->geom.width, cc->size->max_width);
		cc->geom.height = MIN(cc->geom.height, cc->size->max_height);
	}

	cc->geom.x = x <= motionx ? x : x - cc->geom.width;
	cc->geom.y = y <= motiony ? y : y - cc->geom.height;

	return (width != cc->geom.width || height != cc->geom.height);
}
@


1.20
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.19 2008/06/15 02:47:46 oga Exp $
@


1.19
log
@Rip out and burn the HASH_* stuff. We don't need a SPLAY tree for one font.
makes the code a lot simpler. While here rearrange the font handling functions
to be less shit.

ok and help okan@@.
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.18 2008/06/14 22:04:11 okan Exp $
d32 4
a35 4
	struct screen_ctx *sc = CCTOSC(cc);
	int x0 = cc->geom.x, y0 = cc->geom.y;
	char asize[10];	/* fits "nnnnxnnnn\0" */
	int wide, height, wide_size, wide_name;
d44 1
a44 1
	XMoveResizeWindow(X_Dpy, sc->menuwin, x0, y0, wide, height * 2);
d51 1
a51 1
	    wide/2 - wide_size/2, height + font_ascent() + 1);
d57 3
a59 4
	XEvent ev;
	struct screen_ctx *sc = CCTOSC(cc);
	int x0 = cc->geom.x, y0 = cc->geom.y;
	int dx, dy;
d82 1
a82 1
			if (_sweepcalc(cc, x0, y0, ev.xmotion.x, ev.xmotion.y))
d118 3
a120 3
	int x0 = cc->geom.x, y0 = cc->geom.y, xm, ym;
	struct screen_ctx *sc = CCTOSC(cc);
	XEvent ev;
d137 2
a138 2
			cc->geom.x = x0 + (ev.xmotion.x - xm);
			cc->geom.y = y0 + (ev.xmotion.y - ym);
d153 1
a153 1
_sweepcalc(struct client_ctx *cc, int x0, int y0, int motionx, int motiony)
d155 1
a155 1
	int width, height;
d160 2
a161 2
	cc->geom.width = abs(x0 - motionx);
	cc->geom.height = abs(y0 - motiony);
d180 2
a181 2
	cc->geom.x = x0 <= motionx ? x0 : x0 - cc->geom.width;
	cc->geom.y = y0 <= motiony ? y0 : y0 - cc->geom.height;
@


1.18
log
@(mostly) proper xshape event support

ok oga@@
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.17 2008/06/12 18:55:35 okan Exp $
a35 1
	struct fontdesc *font = DefaultFont;
d39 2
a40 2
	wide_size = font_width(font, asize, strlen(asize)) + 4;
	wide_name = font_width(font, cc->name, strlen(cc->name)) + 4;
d42 1
a42 1
	height = font_ascent(font) + font_descent(font) + 1;
d48 4
a51 4
	font_draw(font, cc->name, strlen(cc->name), sc->menuwin,
	    2, font_ascent(font) + 1);
	font_draw(font, asize, strlen(asize), sc->menuwin,
	    wide/2 - wide_size/2, height + font_ascent(font) + 1);
@


1.17
log
@remove old (moved) code

ok oga@@
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.16 2008/06/12 18:32:06 okan Exp $
d97 1
a110 1
			client_do_shape(cc);
@


1.16
log
@instead of forcing the ptr in the middle everytime, be more 'calm'; keep
the ptr still unless it moves out-of-bounds, then just follow the edge.

brought up by todd@@

ok oga@@
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.15 2008/06/12 05:10:24 okan Exp $
a24 1
static int	menu_calc_entry(int, int, int, int, int);
a185 13
}

static int
menu_calc_entry(int x, int y, int width, int height, int noentries)
{
	int entry = y/height;

	/* in bounds? */
	if (x < 0 || x > width || y < 0 || y > height*noentries ||
	    entry < 0 || entry >= noentries)
		entry = -1;

	return (entry);
@


1.15
log
@place the pointer in the middle of the window after resizing with grab,
just like keyboard resize.

from Edd Barrett

ok oga@@
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.14 2008/05/21 14:11:19 oga Exp $
d103 6
a108 2
			cc->ptr.x = -1;
			cc->ptr.y = -1;
d110 1
@


1.14
log
@Make menu_filter handle mouse movement too. This enables the keyboard
search dialogues to be manipulated with the mouse, too. It also allows
me to shrink the codebase further by killing grab_menu().

One known issue with highlighting the first entry in a search dialogue,
that'll be fixed soonish.

ok okan@@, tested by Edd Barrett and todd@@.
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.13 2008/05/20 14:50:51 oga Exp $
d103 2
@


1.13
log
@Pull out the behaviour in grab_label and search_start into one utility
function menu_filter(). The plan is to eventually merge in grab_menu too.
Shrinks the code a fair bit.

Also, change XMaskEvent for XWindowEvent to prevent getting exposes for other
windows. This is particuarly noticable on slow machines with a LOT of xterms
(todd, you're an odd man).

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.12 2008/05/19 18:07:53 okan Exp $
a145 111
}

#define MenuMask	(ButtonMask|ButtonMotionMask|ExposureMask)
#define MenuGrabMask	(ButtonMask|ButtonMotionMask|StructureNotifyMask)
#define AllButtonMask	(Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask)

void *
grab_menu(XButtonEvent *e, struct menu_q *menuq)
{
	struct screen_ctx *sc;
	struct menu *mi;
	XEvent event;
	struct fontdesc *font = DefaultFont;
	int x, y, width, height, tothigh, i, no, entry, prev;
	int fx, fy;

	no = i = width = 0;

	if ((sc = screen_fromroot(e->root)) == NULL || e->window == sc->menuwin)
		return (NULL);

	TAILQ_FOREACH(mi, menuq, entry) {
		i = font_width(font, mi->text, strlen(mi->text)) + 4;
		if (i > width)
			width = i;
		no++;
	}

	height = font_ascent(font) + font_descent(font) + 1;
	tothigh = height * no;

	x = e->x - width/2;
	y = e->y - height/2;

	/* does it fit on the screen? */
	if (x < 0)
		x = 0;
	else if (x+width >= sc->xmax)
		x = sc->xmax - width;

	if (y < 0)
		y = 0;
	else if (y+tothigh >= sc->ymax)
		y = sc->ymax - tothigh;

	xu_ptr_setpos(e->root, x + width/2, y + height/2);

	XMoveResizeWindow(X_Dpy, sc->menuwin, x, y, width, tothigh);
	XSelectInput(X_Dpy, sc->menuwin, MenuMask);
	XMapRaised(X_Dpy, sc->menuwin);

	if (xu_ptr_grab(sc->menuwin, MenuGrabMask, Cursor_select) < 0) {
		XUnmapWindow(X_Dpy, sc->menuwin);
		return (NULL);
	}

	entry = prev = -1;

	for (;;) {
		XMaskEvent(X_Dpy, MenuMask, &event);
		switch (event.type) {
		case Expose:
			XClearWindow(X_Dpy, sc->menuwin);
			i = 0;
			TAILQ_FOREACH(mi, menuq, entry) {
				fx = (width - font_width(font, mi->text,
				    strlen(mi->text)))/2;
				fy = height*i + font_ascent(font) + 1;
				font_draw(font, mi->text, strlen(mi->text),
				    sc->menuwin, fx, fy);
				i++;
			}
			/* FALLTHROUGH */
		case MotionNotify:
			prev = entry;
			entry = menu_calc_entry(event.xbutton.x,
			    event.xbutton.y, width, height, no);
			if (prev != -1)
				XFillRectangle(X_Dpy, sc->menuwin, sc->hlgc,
				    0, height*prev, width, height);
			if (entry != -1) {
				xu_ptr_regrab(MenuGrabMask, Cursor_select);
				XFillRectangle(X_Dpy, sc->menuwin, sc->hlgc,
				    0, height*entry, width, height);
			} else
				xu_ptr_regrab(MenuGrabMask, Cursor_default);
			break;
		case ButtonRelease:
			if (event.xbutton.button != e->button)
				break;
			entry = menu_calc_entry(event.xbutton.x,
			    event.xbutton.y, width, height, no);
			xu_ptr_ungrab();
			XUnmapWindow(X_Dpy, sc->menuwin);

			i = 0;
			TAILQ_FOREACH(mi, menuq, entry)
				if (entry == i++)
					break;
			return (mi);
		default:
			break;
		}
	}
}

void
grab_menuinit(struct screen_ctx *sc)
{
	sc->menuwin = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0,
	    1, 1, 1, sc->blackpixl, sc->whitepixl);
@


1.12
log
@stop normalizing search input; searching and matching are still
case-insensitive.  since this was the only use of normalizing input,
simplify as well.

allows one to exec with mixed case unmatched commands.

"works for me" oga@@
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.11 2008/05/17 03:59:55 okan Exp $
a173 5
	if (!sc->maxinitialised) {
		sc->xmax = DisplayWidth(X_Dpy, sc->which);
		sc->ymax = DisplayHeight(X_Dpy, sc->which);
	}

a256 92
}

#define LABEL_MAXLEN 256
#define LabelMask (KeyPressMask|ExposureMask)

void
grab_label(struct client_ctx *cc)
{
	struct screen_ctx *sc = screen_current();
	int x, y, dx, dy, fontheight, focusrevert;
	XEvent e;
	char labelstr[LABEL_MAXLEN];
	char dispstr[LABEL_MAXLEN + sizeof("label>") - 1];
	Window focuswin;
	char chr;
	enum ctltype ctl;
	size_t len;
	struct fontdesc *font = DefaultFont;

	if (cc->label != NULL)
		strlcpy(labelstr, cc->label, sizeof(labelstr));
	else
		labelstr[0] = '\0';

	xu_ptr_getpos(sc->rootwin, &x, &y);

	dy = fontheight = font_ascent(font) + font_descent(font) + 1;
	dx = font_width(font, "label>", 6);

	XMoveResizeWindow(X_Dpy, sc->searchwin, x, y, dx, dy);
	XSelectInput(X_Dpy, sc->searchwin, LabelMask);
	XMapRaised(X_Dpy, sc->searchwin);

	XGetInputFocus(X_Dpy, &focuswin, &focusrevert);
	XSetInputFocus(X_Dpy, sc->searchwin, RevertToPointerRoot, CurrentTime);

	for (;;) {
		XMaskEvent(X_Dpy, LabelMask, &e);

		switch (e.type) {
		case KeyPress:
			if (input_keycodetrans(e.xkey.keycode, e.xkey.state,
			    &ctl, &chr) < 0)
				continue;

			switch (ctl) {
			case CTL_ERASEONE:
				if ((len = strlen(labelstr)) > 0)
					labelstr[len - 1] = '\0';
				break;
			case CTL_RETURN:
				/* Done */
				if (strlen(labelstr) == 0)
					goto out;

				if (cc->label != NULL)
					xfree(cc->label);

				cc->label = xstrdup(labelstr);
				/* FALLTHROUGH */
			case CTL_ABORT:
				goto out;
			default:
				break;
			}

			if (chr != '\0') {
				char str[2];

				str[0] = chr;
				str[1] = '\0';
				strlcat(labelstr, str, sizeof(labelstr));
			}

		case Expose:
			snprintf(dispstr, sizeof(dispstr), "label>%s",
			    labelstr);
			dx = font_width(font, dispstr, strlen(dispstr));
			dy = fontheight;

			XClearWindow(X_Dpy, sc->searchwin);
			XResizeWindow(X_Dpy, sc->searchwin, dx, dy);

			font_draw(font, dispstr, strlen(dispstr),
			    sc->searchwin, 0, font_ascent(font) + 1);
			break;
		}
	}

out:
	XSetInputFocus(X_Dpy, focuswin, focusrevert, CurrentTime);
	XUnmapWindow(X_Dpy, sc->searchwin);
@


1.11
log
@fix cwm's current XShape support from Edd Barrett -thanks.

XShape events should be handled at some point.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.10 2008/05/15 22:18:00 oga Exp $
d304 1
a304 1
			    &ctl, &chr, 0) < 0)
@


1.10
log
@KNF, no binary change.

From Pierre Riteau. Thanks!
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.9 2008/04/15 20:24:41 oga Exp $
d104 1
@


1.9
log
@hit it with the knf stick.
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.8 2008/01/16 11:39:20 oga Exp $
d295 1
a295 2
	XSetInputFocus(X_Dpy, sc->searchwin,
	    RevertToPointerRoot, CurrentTime);
d303 1
a303 1
				&ctl, &chr, 0) < 0)
d350 2
a351 3
 out:
	XSetInputFocus(X_Dpy, focuswin,
	    focusrevert, CurrentTime);
@


1.8
log
@huge amount of cleanup and dead code removal.

full description of changes:
-remove fontlist, and all associated structures/calls, it's not needed.
 this also removes any doubt about leftover 9wm code (the list was
 borrowed from it). Since cwm now uses Xft for everything, the legacy
 font handling is just not needed.
-add /* FALLTHROUGH */ comments into grab_{label,menu}. I actually
 didn't intend grab_menu to be a fallthrough, but it actually works quite
 well there, so remove the extra rectangle drawing. I love it when that
 happens.
-remove a couple of unused prototypes that were obviously missed
 before.
-remove a bunch of commented out or if 0ed out code. It doesn't look to
 be coming back anytime soon.
-several functions returned an int, but this was never checked. most of
 them only failed if they failed to grab the pointer (thus the internal
 state didn't change), so just make them void and return early if this is
 the case.
-remove several unused functions and some useless variables.

knocks something like 200bytes off the stripped binary size for me.

ok marc@@, tested by several others.
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.7 2008/01/14 15:21:10 oga Exp $
d86 1
a86 1
 				/* Recompute window output */
d147 3
a149 3
#define MenuMask       (ButtonMask|ButtonMotionMask|ExposureMask)
#define MenuGrabMask   (ButtonMask|ButtonMotionMask|StructureNotifyMask)
#define AllButtonMask   (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask)
d200 1
a200 1
		
d210 1
a210 1
		switch  (event.type) {
d240 1
a240 1
			entry =  menu_calc_entry(event.xbutton.x,
d250 1
a250 1
		default: 
d337 2
a338 1
			snprintf(dispstr, sizeof(dispstr), "label>%s", labelstr);
d401 1
a401 1
	return entry;
@


1.7
log
@Rewrite most of grab_menu in grab.c (it was partly 9wm code).
This should work functionally the same, with a few simplifications.

Changes:
- we don't care if you're holding another button when you release the
  menu key if you don't want to select anything, move off the menu.
- remove the hysteresis from the menu selection (before you had to move
  more than three pixels onto a new menu entry before it selected it)
- simplify a lot of the selection code
- kill dead code.
- do what the XXX comment said and cache the screensize (i may tweak
  this later).

As far as I can tell, the only code remaining from 9wm is the list of
fonts in calmwm.c. Others appear to concur.

ok marc@@, looked over and tested by a few others. Reminders from okan@@.
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.6 2008/01/11 16:06:44 oga Exp $
d56 1
a56 1
int
d71 1
a71 1
		return (-1);
d104 1
a104 1
			return (0);
d110 1
a110 1
int
d120 1
a120 1
		return (-1);
d141 1
a141 1
			return (0);
d222 1
a222 3
			if (entry != -1)
				XFillRectangle(X_Dpy, sc->menuwin, sc->hlgc,
				    0, entry*height, width, height);
d321 1
a321 1

@


1.6
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d18 1
a18 1
 * $Id: grab.c,v 1.5 2007/06/05 18:57:03 jasper Exp $
d24 2
a25 2
int _sweepcalc(struct client_ctx *, int, int, int, int);
int  _nobuttons(XButtonEvent *);
a146 6
/*
 * Adapted from 9wm.
 */

/* XXX - this REALLY needs to be cleaned up. */

a150 14
#ifdef notyet
struct client_ctx *
grab_menu_getcc(struct menu_q *menuq, int off)
{
	int where = 0;
	struct menu *mi;

	TAILQ_FOREACH(mi, menuq, entry)
	    if (off == where++)
		    return mi->ctx;
	return (NULL);
}
#endif

d156 1
a156 4
	XEvent ev;
	int i, n, cur = 0, old, wide, high, status, drawn, warp;
	int x, y, dx, dy, xmax, ymax;
	int tx, ty;
d158 4
a165 2
	dx = 0;
	i = 0;
d167 4
a170 6
		wide = font_width(font, mi->text, strlen(mi->text)) + 4;
		if (wide > dx)
			dx = wide;
		if (mi->lasthit)
			cur = i;
		i++;
d173 4
a176 1
	n = i;
d178 8
a185 11
	wide = dx;
	high = font_ascent(font) + font_descent(font) + 1;
	dy = n*high;
	x = e->x - wide/2;
	y = e->y - cur*high - high/2;
	warp = 0;
	/* XXX - cache these in sc. */
	xmax = DisplayWidth(X_Dpy, sc->which);
	ymax = DisplayHeight(X_Dpy, sc->which);
	if (x < 0) {
		e->x -= x;
d187 4
a190 9
		warp++;
	}
	if (x+wide >= xmax) {
		e->x -= x+wide-xmax;
		x = xmax-wide;
		warp++;
	}
	if (y < 0) {
		e->y -= y;
d192 4
a195 9
		warp++;
	}
	if (y+dy >= ymax) {
		e->y -= y+dy-ymax;
		y = ymax-dy;
		warp++;
	}
	if (warp)
		xu_ptr_setpos(e->root, e->x, e->y);
d197 1
a197 1
	XMoveResizeWindow(X_Dpy, sc->menuwin, x, y, dx, dy);
d200 2
a201 2
	status = xu_ptr_grab(sc->menuwin, MenuGrabMask, Cursor_select);
	if (status < 0) {
a204 1
	drawn = 0;
d206 1
a206 10
#ifdef notyet
	if (e->button == Button1) {
		struct client_ctx *cc;
		cc = grab_menu_getcc(menuq, cur);
		if (cc != NULL) {
			client_unhide(cc);
			XRaiseWindow(X_Dpy, sc->menuwin);
		}
	}
#endif
d209 29
a237 6
		XMaskEvent(X_Dpy, MenuMask, &ev);
		switch (ev.type) {
		default:
			warnx("menuhit: unknown ev.type %d\n", ev.type);
			break;
		case ButtonPress:
d240 1
a240 1
			if (ev.xbutton.button != e->button)
d242 2
a243 16
			x = ev.xbutton.x;
			y = ev.xbutton.y;
			i = y/high;
			if (cur >= 0 && y >= cur*high-3 && y < (cur+1)*high+3)
				i = cur;
			if (x < 0 || x > wide || y < -3)
				i = -1;
			else if (i < 0 || i >= n)
				i = -1;
/* 			else */
/* 				m->lasthit = i; */
			if (!_nobuttons(&ev.xbutton))
				i = -1;

			/* XXX */
			/* 			ungrab(&ev.xbutton); */
d246 2
a247 1
			n = 0;
d249 1
a249 1
				if (i == n++)
a250 1

d252 1
a252 44
		case MotionNotify:
			if (!drawn)
				break;
			x = ev.xbutton.x;
			y = ev.xbutton.y;
			old = cur;
			cur = y/high;
			if (old >= 0 && y >= old*high-3 && y < (old+1)*high+3)
				cur = old;
			if (x < 0 || x > wide || y < -3)
				cur = -1;
			else if (cur < 0 || cur >= n)
				cur = -1;
			if (cur == old)
				break;
			if (old >= 0 && old < n) {
#ifdef notyet
				if (e->button == Button1) {
					struct client_ctx *cc;
					cc = grab_menu_getcc(menuq, old);
					if (cc != NULL)
						client_hide(cc);
				}
#endif
				XFillRectangle(X_Dpy, sc->menuwin,
				    sc->hlgc, 0, old*high, wide, high);
			}
			if (cur >= 0 && cur < n) {
#ifdef notyet
				if (e->button == Button1) {
					struct client_ctx *cc;
					cc = grab_menu_getcc(menuq, cur);
					if (cc != NULL) {
						client_unhide(cc);
						XRaiseWindow(X_Dpy,
						    sc->menuwin);
					}
				}
#endif
				xu_ptr_regrab(MenuGrabMask, Cursor_select);
				XFillRectangle(X_Dpy, sc->menuwin,
				    sc->hlgc, 0, cur*high, wide, high);
			} else
				xu_ptr_regrab(MenuGrabMask, Cursor_default);
a253 15
		case Expose:
			XClearWindow(X_Dpy, sc->menuwin);
			i = 0;
			TAILQ_FOREACH(mi, menuq, entry) {
				tx = (wide - font_width(font, mi->text,
					strlen(mi->text)))/2;
				ty = i*high + font_ascent(font) + 1;
				font_draw(font, mi->text, strlen(mi->text),
				    sc->menuwin, tx, ty);
				i++;
			}
			if (cur >= 0 && cur < n)
				XFillRectangle(X_Dpy, sc->menuwin,
				    sc->hlgc, 0, cur*high, wide, high);
			drawn = 1;
d358 1
a358 80
#define ExecMask (KeyPressMask|ExposureMask)

void
grab_exec(void)
{
	int x, y, dx, dy, fontheight, focusrevert, len;
	char cmdstr[MAXPATHLEN];
	char dispstr[MAXPATHLEN + sizeof("exec>") - 1];
	char chr, str[2];
	enum ctltype ctl;
	struct fontdesc *font = DefaultFont;
	struct screen_ctx *sc = screen_current();
	XEvent e;
	Window focuswin;

	cmdstr[0] = '\0';

	xu_ptr_getpos(sc->rootwin, &x, &y);

	dy = fontheight = font_ascent(font) + font_descent(font) + 1;
	dx = font_width(font, "exec>", 5);

	XMoveResizeWindow(X_Dpy, sc->searchwin, x, y, dx, dy);
	XSelectInput(X_Dpy, sc->searchwin, ExecMask);
	XMapRaised(X_Dpy, sc->searchwin);

	XGetInputFocus(X_Dpy, &focuswin, &focusrevert);
	XSetInputFocus(X_Dpy, sc->searchwin,
	    RevertToPointerRoot, CurrentTime);

	for (;;) {
		XMaskEvent(X_Dpy, ExecMask, &e);

		switch (e.type) {
		case KeyPress:
			if (input_keycodetrans(e.xkey.keycode, e.xkey.state,
				&ctl, &chr, 0) < 0)
				continue;

			switch (ctl) {
			case CTL_ERASEONE:
				if ((len = strlen(cmdstr)) > 0)
					cmdstr[len - 1] = '\0';
				break;
			case CTL_RETURN:
				if (strlen(cmdstr) > 0)
					u_spawn(cmdstr);
				goto out;
				break;
			case CTL_ABORT:
				goto out;
			default:
				break;
			}

			if (chr != '\0') {
				str[0] = chr;
				str[1] = '\0';
				strlcat(cmdstr, str, sizeof(cmdstr));
			}
		case Expose:
			snprintf(dispstr, sizeof(dispstr), "exec>%s", cmdstr);

			dx = font_width(font, dispstr, strlen(dispstr));
			dy = fontheight;

			XClearWindow(X_Dpy, sc->searchwin);
			XResizeWindow(X_Dpy, sc->searchwin, dx, dy);

			font_draw(font, dispstr, strlen(dispstr),
			    sc->searchwin, 0, font_ascent(font) + 1);
			break;
		}
	}
 out:
	XSetInputFocus(X_Dpy, focuswin, focusrevert, CurrentTime);
	XUnmapWindow(X_Dpy, sc->searchwin);
}

int
d392 2
a393 3
/* XXX */
int
_nobuttons(XButtonEvent *e)	/* Einstuerzende */
d395 6
a400 1
	int state;
d402 1
a402 2
	state = (e->state & AllButtonMask);
	return (e->type == ButtonRelease) && (state & (state - 1)) == 0;
@


1.5
log
@draw window borders when redrawing a window

from aon@@iki.fi
@
text
@a4 1
 * All rights reserved.
d6 13
a18 1
 * $Id: grab.c,v 1.4 2007/05/28 18:34:27 jasper Exp $
@


1.4
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@d7 1
a7 1
 * $Id: grab.c,v 1.3 2007/04/27 18:10:39 bernd Exp $
d67 1
a67 1
		XMaskEvent(X_Dpy, MouseMask, &ev);
d70 3
d114 1
a114 1
		XMaskEvent(X_Dpy, MouseMask, &ev);
d117 3
@


1.3
log
@Apply cwm-3-input_shift.diff from http://aon.iki.fi/cwm/.
@
text
@d7 1
a7 1
 * $Id: grab.c,v 1.2 2007/04/27 18:08:14 bernd Exp $
d35 4
a38 4
	XMoveResizeWindow(G_dpy, sc->menuwin, x0, y0, wide, height * 2);
	XMapWindow(G_dpy, sc->menuwin);
	XReparentWindow(G_dpy, sc->menuwin, cc->win, 0, 0);
	XClearWindow(G_dpy, sc->menuwin);
d59 1
a59 1
	if (xu_ptr_grab(sc->rootwin, MouseMask, G_cursor_resize) < 0)
d67 1
a67 1
		XMaskEvent(G_dpy, MouseMask, &ev);
d75 1
a75 1
			XMoveResizeWindow(G_dpy, cc->pwin,
d80 1
a80 1
			XMoveResizeWindow(G_dpy, cc->win,
d86 2
a87 2
			XUnmapWindow(G_dpy, sc->menuwin);
			XReparentWindow(G_dpy, sc->menuwin, sc->rootwin, 0, 0);
d105 1
a105 1
	if (xu_ptr_grab(sc->rootwin, MouseMask, G_cursor_move) < 0)
d111 1
a111 1
		XMaskEvent(G_dpy, MouseMask, &ev);
d118 1
a118 1
			XMoveWindow(G_dpy, cc->pwin,
d188 2
a189 2
	xmax = DisplayWidth(G_dpy, sc->which);
	ymax = DisplayHeight(G_dpy, sc->which);
d213 4
a216 4
	XMoveResizeWindow(G_dpy, sc->menuwin, x, y, dx, dy);
	XSelectInput(G_dpy, sc->menuwin, MenuMask);
	XMapRaised(G_dpy, sc->menuwin);
	status = xu_ptr_grab(sc->menuwin, MenuGrabMask, G_cursor_select);
d218 1
a218 1
		XUnmapWindow(G_dpy, sc->menuwin);
d229 1
a229 1
			XRaiseWindow(G_dpy, sc->menuwin);
d235 1
a235 1
		XMaskEvent(G_dpy, MenuMask, &ev);
d262 1
a262 1
			XUnmapWindow(G_dpy, sc->menuwin);
d293 1
a293 1
				XFillRectangle(G_dpy, sc->menuwin,
d303 1
a303 1
						XRaiseWindow(G_dpy,
d308 2
a309 2
				xu_ptr_regrab(MenuGrabMask, G_cursor_select);
				XFillRectangle(G_dpy, sc->menuwin,
d312 1
a312 1
				xu_ptr_regrab(MenuGrabMask, G_cursor_default);
d315 1
a315 1
			XClearWindow(G_dpy, sc->menuwin);
d326 1
a326 1
				XFillRectangle(G_dpy, sc->menuwin,
d336 1
a336 1
	sc->menuwin = XCreateSimpleWindow(G_dpy, sc->rootwin, 0, 0,
d367 3
a369 3
	XMoveResizeWindow(G_dpy, sc->searchwin, x, y, dx, dy);
	XSelectInput(G_dpy, sc->searchwin, LabelMask);
	XMapRaised(G_dpy, sc->searchwin);
d371 2
a372 2
	XGetInputFocus(G_dpy, &focuswin, &focusrevert);
	XSetInputFocus(G_dpy, sc->searchwin,
d376 1
a376 1
		XMaskEvent(G_dpy, LabelMask, &e);
d418 2
a419 2
			XClearWindow(G_dpy, sc->searchwin);
			XResizeWindow(G_dpy, sc->searchwin, dx, dy);
d428 1
a428 1
	XSetInputFocus(G_dpy, focuswin,
d430 1
a430 1
	XUnmapWindow(G_dpy, sc->searchwin);
d455 3
a457 3
	XMoveResizeWindow(G_dpy, sc->searchwin, x, y, dx, dy);
	XSelectInput(G_dpy, sc->searchwin, ExecMask);
	XMapRaised(G_dpy, sc->searchwin);
d459 2
a460 2
	XGetInputFocus(G_dpy, &focuswin, &focusrevert);
	XSetInputFocus(G_dpy, sc->searchwin,
d464 1
a464 1
		XMaskEvent(G_dpy, ExecMask, &e);
d499 2
a500 2
			XClearWindow(G_dpy, sc->searchwin);
			XResizeWindow(G_dpy, sc->searchwin, dx, dy);
d508 2
a509 2
	XSetInputFocus(G_dpy, focuswin, focusrevert, CurrentTime);
	XUnmapWindow(G_dpy, sc->searchwin);
@


1.2
log
@Apply cwm-3-exec.diff from http://aon.iki.fi/cwm/. Document the new
key binding.
@
text
@d7 1
a7 1
 * $Id: grab.c,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
d381 1
a381 1
				&ctl, &chr, 1) < 0)
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * $Id: grab.c,v 1.19 2005/08/28 09:36:45 marius Exp $
d430 79
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
