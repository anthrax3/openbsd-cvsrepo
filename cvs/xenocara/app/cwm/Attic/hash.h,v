head	1.3;
access;
symbols
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2008.06.15.02.47.46;	author oga;	state dead;
branches;
next	1.2;

1.2
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Rip out and burn the HASH_* stuff. We don't need a SPLAY tree for one font.
makes the code a lot simpler. While here rearrange the font handling functions
to be less shit.

ok and help okan@@.
@
text
@/*
 * hash.h - generic hash template, akin to queue.h & tree.h
 *
 * Copyright (c) 2005 Marius Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _HASH_H_		/* Possibly this is too generic. */
#define _HASH_H_

#include <sys/tree.h>

#define HASH_ENTRY	SPLAY_ENTRY

#define HASH_HEAD(name, type, nbuckets)				\
	SPLAY_HEAD(name##_HASH_TREE, type);			\
	struct name {						\
		struct name##_HASH_TREE buckets[nbuckets];	\
		unsigned int (*hashfn)(struct type *elm);	\
	};

#define HASH_NBUCKETS(head)					\
	(sizeof((head)->buckets)/sizeof((head)->buckets[0]))

#define HASH_INIT(head, fn) do {			\
	int i;						\
	for (i = 0; i < HASH_NBUCKETS(head); i++) {	\
		SPLAY_INIT(&(head)->buckets[i]);	\
	}						\
	(head)->hashfn = fn;				\
} while (0)

#define HASH_PROTOTYPE(name, type, field, cmp)				\
SPLAY_PROTOTYPE(name##_HASH_TREE, type, field, cmp)			\
struct type *name##_HASH_TREE_FIND(struct name *head, struct type *find); \
void name##_HASH_TREE_INSERT(struct name *head, struct type *insert);

#define HASH_GENERATE(name, type, field, cmp)				\
SPLAY_GENERATE(name##_HASH_TREE, type, field, cmp)			\
struct type *name##_HASH_TREE_FIND(struct name *head, struct type *find) \
{									\
	struct name##_HASH_TREE *bucket =				\
	    &head->buckets[(*head->hashfn)(find) % HASH_NBUCKETS(head)]; \
	return (SPLAY_FIND(name##_HASH_TREE, bucket, find));		\
}									\
void name##_HASH_TREE_INSERT(struct name *head, struct type *insert)	\
{									\
	struct name##_HASH_TREE *bucket =				\
	    &head->buckets[(*head->hashfn)(insert) % HASH_NBUCKETS(head)]; \
									\
	SPLAY_INSERT(name##_HASH_TREE, bucket, insert);			\
}

#define HASH_FIND(name, head, find) name##_HASH_TREE_FIND((head), (find))
#define HASH_INSERT(name, head, insert) name##_HASH_TREE_INSERT((head), (insert))

#endif /* _HASH_H_ */
@


1.2
log
@hit it with the knf stick.
@
text
@@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
#define HASH_ENTRY SPLAY_ENTRY
d26 1
a26 1
#define HASH_HEAD(name, type, nbuckets) 			\
d55 1
a55 1
	return SPLAY_FIND(name##_HASH_TREE, bucket, find);		\
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
