head	1.99;
access;
symbols
	OPENBSD_6_1:1.99.0.2
	OPENBSD_6_1_BASE:1.99
	OPENBSD_6_0:1.96.0.4
	OPENBSD_6_0_BASE:1.96
	OPENBSD_5_9:1.96.0.2
	OPENBSD_5_9_BASE:1.96
	OPENBSD_5_8:1.93.0.4
	OPENBSD_5_8_BASE:1.93
	OPENBSD_5_7:1.93.0.2
	OPENBSD_5_7_BASE:1.93
	OPENBSD_5_6:1.89.0.4
	OPENBSD_5_6_BASE:1.89
	OPENBSD_5_5:1.89.0.2
	OPENBSD_5_5_BASE:1.89
	OPENBSD_5_4:1.80.0.2
	OPENBSD_5_4_BASE:1.80
	OPENBSD_5_3:1.72.0.2
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.64.0.2
	OPENBSD_5_2_BASE:1.64
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.2
	OPENBSD_5_0:1.58.0.2
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.53.0.2
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.53.0.4
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.42.0.2
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.99
date	2016.10.18.17.03.30;	author okan;	state Exp;
branches;
next	1.98;
commitid	dIOrHVlb55Ubzrpl;

1.98
date	2016.09.29.00.30.40;	author okan;	state Exp;
branches;
next	1.97;
commitid	0hqvlp9h18wNisQr;

1.97
date	2016.09.29.00.21.55;	author okan;	state Exp;
branches;
next	1.96;
commitid	T0a7tiQalU2SO4pS;

1.96
date	2015.11.12.17.56.54;	author okan;	state Exp;
branches;
next	1.95;
commitid	zA1dwQ1jU6l3GljA;

1.95
date	2015.11.10.20.05.33;	author okan;	state Exp;
branches;
next	1.94;
commitid	vKzF5zXTpUgY9uJK;

1.94
date	2015.09.16.17.58.25;	author okan;	state Exp;
branches;
next	1.93;
commitid	5LZITTZspXcfHMXf;

1.93
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.92;
commitid	kLADTGYX3gw0Sf2m;

1.92
date	2014.09.08.20.11.22;	author okan;	state Exp;
branches;
next	1.91;
commitid	cu11ybsl8atTMRXD;

1.91
date	2014.09.07.19.27.30;	author okan;	state Exp;
branches;
next	1.90;
commitid	jXQ1fztXcP9vyPb1;

1.90
date	2014.09.06.16.24.32;	author okan;	state Exp;
branches;
next	1.89;
commitid	gDtJgnCuwUAPspS0;

1.89
date	2014.02.02.16.29.04;	author okan;	state Exp;
branches;
next	1.88;

1.88
date	2014.02.01.00.25.04;	author okan;	state Exp;
branches;
next	1.87;

1.87
date	2014.01.28.00.42.20;	author okan;	state Exp;
branches;
next	1.86;

1.86
date	2014.01.22.22.26.05;	author okan;	state Exp;
branches;
next	1.85;

1.85
date	2014.01.22.22.14.02;	author okan;	state Exp;
branches;
next	1.84;

1.84
date	2014.01.22.21.48.27;	author okan;	state Exp;
branches;
next	1.83;

1.83
date	2014.01.21.15.42.44;	author okan;	state Exp;
branches;
next	1.82;

1.82
date	2014.01.03.15.29.06;	author okan;	state Exp;
branches;
next	1.81;

1.81
date	2013.12.12.20.15.07;	author okan;	state Exp;
branches;
next	1.80;

1.80
date	2013.07.15.14.50.44;	author okan;	state Exp;
branches;
next	1.79;

1.79
date	2013.07.08.15.46.16;	author okan;	state Exp;
branches;
next	1.78;

1.78
date	2013.06.17.17.11.10;	author okan;	state Exp;
branches;
next	1.77;

1.77
date	2013.06.17.14.08.51;	author okan;	state Exp;
branches;
next	1.76;

1.76
date	2013.05.22.16.54.09;	author okan;	state Exp;
branches;
next	1.75;

1.75
date	2013.05.14.13.39.53;	author okan;	state Exp;
branches;
next	1.74;

1.74
date	2013.04.12.14.49.16;	author okan;	state Exp;
branches;
next	1.73;

1.73
date	2013.04.12.14.46.30;	author okan;	state Exp;
branches;
next	1.72;

1.72
date	2012.12.18.00.14.41;	author okan;	state Exp;
branches;
next	1.71;

1.71
date	2012.12.17.23.03.41;	author okan;	state Exp;
branches;
next	1.70;

1.70
date	2012.12.17.02.28.45;	author okan;	state Exp;
branches;
next	1.69;

1.69
date	2012.11.29.16.50.03;	author okan;	state Exp;
branches;
next	1.68;

1.68
date	2012.11.29.03.54.46;	author okan;	state Exp;
branches;
next	1.67;

1.67
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.66;

1.66
date	2012.10.31.19.30.19;	author okan;	state Exp;
branches;
next	1.65;

1.65
date	2012.08.07.14.05.49;	author okan;	state Exp;
branches;
next	1.64;

1.64
date	2012.07.18.21.53.22;	author okan;	state Exp;
branches;
next	1.63;

1.63
date	2012.07.06.14.18.00;	author okan;	state Exp;
branches;
next	1.62;

1.62
date	2012.07.05.17.35.13;	author okan;	state Exp;
branches;
next	1.61;

1.61
date	2012.05.16.01.17.14;	author okan;	state Exp;
branches;
next	1.60;

1.60
date	2012.05.13.15.15.54;	author okan;	state Exp;
branches;
next	1.59;

1.59
date	2011.09.08.12.35.33;	author okan;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.25.15.10.24;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.23.13.09.11;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2011.06.24.06.52.23;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2011.06.24.05.58.51;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.12.16.17.46;	author oga;	state Exp;
branches;
next	1.52;

1.52
date	2010.01.27.03.04.50;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2009.12.15.03.34.34;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.10.23.14.58;	author oga;	state Exp;
branches;
next	1.47;

1.47
date	2009.12.10.17.16.51;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2009.12.08.16.52.17;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.07.23.19.51;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.07.21.20.52;	author okan;	state Exp;
branches;
next	1.43;

1.43
date	2009.08.24.21.22.48;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2009.06.26.12.21.58;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2009.06.23.21.52.38;	author okan;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.20.00.22.39;	author okan;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.18.00.23.35;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2009.05.18.00.14.19;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2009.05.17.23.40.57;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2009.04.15.14.01.45;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.27.02.16.20;	author okan;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.22.15.26.33;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.16.15.24.14;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.15.17.23.12;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.03.23.55.46;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2008.09.29.23.16.46;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.22.14.28.04;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.22.14.15.03;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2008.07.22.21.01.54;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2008.07.22.20.51.54;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.22.20.42.24;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.22.19.54.57;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.25.01.09.09;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.15.02.47.46;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.21.14.11.19;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.20.14.50.51;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.19.18.53.09;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.06.15.12.04;	author tobias;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.15.18.22.08;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.03.13.58.57;	author simon;	state Exp;
branches;
next	1.13;

1.13
date	2008.03.23.15.09.21;	author simon;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.22.15.09.45;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.22.14.09.02;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.13.21.48.03;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.13.21.04.19;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.13.12.09.47;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.16.11.39.20;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.14.15.21.10;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.21.07.53.11;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.10.17.23.49;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.99
log
@Refactor callbacks to take a void * so as to not try and generalize into
client_ctx in keypress and buttonpress event handlers; pass appropriate *ctx's
based on context.

While here, limit some globals, replace defines with appropriate variables and
fix some naming.
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: calmwm.c,v 1.98 2016/09/29 00:30:40 okan Exp $
 */

#include <sys/types.h>
#include <sys/queue.h>
#include <sys/wait.h>

#include <err.h>
#include <errno.h>
#include <getopt.h>
#include <limits.h>
#include <locale.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

Display			*X_Dpy;
Time			 Last_Event_Time = CurrentTime;
Atom			 cwmh[CWMH_NITEMS];
Atom			 ewmh[EWMH_NITEMS];
struct screen_q		 Screenq = TAILQ_HEAD_INITIALIZER(Screenq);
struct conf		 Conf;
const char		*homedir;
volatile sig_atomic_t	 cwm_status;

static void	sighdlr(int);
static int	x_errorhandler(Display *, XErrorEvent *);
static void	x_init(const char *);
static void	x_teardown(void);
static int	x_wmerrorhandler(Display *, XErrorEvent *);

int
main(int argc, char **argv)
{
	const char	*conf_file = NULL;
	char		*conf_path, *display_name = NULL;
	int		 ch;
	struct passwd	*pw;

	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
		warnx("no locale support");
	mbtowc(NULL, NULL, MB_CUR_MAX);

	Conf.wm_argv = u_argv(argv);
	while ((ch = getopt(argc, argv, "c:d:")) != -1) {
		switch (ch) {
		case 'c':
			conf_file = optarg;
			break;
		case 'd':
			display_name = optarg;
			break;
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (signal(SIGCHLD, sighdlr) == SIG_ERR)
		err(1, "signal");

	if ((homedir = getenv("HOME")) == NULL || *homedir == '\0') {
		pw = getpwuid(getuid());
		if (pw != NULL && pw->pw_dir != NULL && *pw->pw_dir != '\0')
			homedir = pw->pw_dir;
		else
			homedir = "/";
	}

	if (conf_file == NULL)
		xasprintf(&conf_path, "%s/%s", homedir, CONFFILE);
	else
		conf_path = xstrdup(conf_file);

	if (access(conf_path, R_OK) != 0) {
		if (conf_file != NULL)
			warn("%s", conf_file);
		free(conf_path);
		conf_path = NULL;
	}

	conf_init(&Conf);

	if (conf_path && (parse_config(conf_path, &Conf) == -1))
		warnx("config file %s has errors", conf_path);
	free(conf_path);

	x_init(display_name);
	cwm_status = CWM_RUNNING;

	if (pledge("stdio rpath proc exec", NULL) == -1)
		err(1, "pledge");

	while (cwm_status == CWM_RUNNING)
		xev_process();
	x_teardown();
	if (cwm_status == CWM_EXEC_WM)
		u_exec(Conf.wm_argv);

	return(0);
}

static void
x_init(const char *dpyname)
{
	int	i;

	if ((X_Dpy = XOpenDisplay(dpyname)) == NULL)
		errx(1, "unable to open display \"%s\"", XDisplayName(dpyname));

	XSetErrorHandler(x_wmerrorhandler);
	XSelectInput(X_Dpy, DefaultRootWindow(X_Dpy), SubstructureRedirectMask);
	XSync(X_Dpy, False);
	XSetErrorHandler(x_errorhandler);

	Conf.xrandr = XRRQueryExtension(X_Dpy, &Conf.xrandr_event_base, &i);

	conf_atoms();
	conf_cursor(&Conf);

	for (i = 0; i < ScreenCount(X_Dpy); i++)
		screen_init(i);
}

static void
x_teardown(void)
{
	struct screen_ctx	*sc;
	unsigned int		 i;

	conf_clear(&Conf);

	TAILQ_FOREACH(sc, &Screenq, entry) {
		for (i = 0; i < CWM_COLOR_NITEMS; i++)
			XftColorFree(X_Dpy, DefaultVisual(X_Dpy, sc->which),
			    DefaultColormap(X_Dpy, sc->which),
			    &sc->xftcolor[i]);
		XftFontClose(X_Dpy, sc->xftfont);
		XftDrawDestroy(sc->menu.xftdraw);
		XDestroyWindow(X_Dpy, sc->menu.win);
		XUngrabKey(X_Dpy, AnyKey, AnyModifier, sc->rootwin);
	}
	XUngrabPointer(X_Dpy, CurrentTime);
	XUngrabKeyboard(X_Dpy, CurrentTime);
	for (i = 0; i < CF_NITEMS; i++)
		XFreeCursor(X_Dpy, Conf.cursor[i]);
	XSync(X_Dpy, False);
	XSetInputFocus(X_Dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
	XCloseDisplay(X_Dpy);
}

static int
x_wmerrorhandler(Display *dpy, XErrorEvent *e)
{
	errx(1, "root window unavailable - perhaps another wm is running?");

	return(0);
}

static int
x_errorhandler(Display *dpy, XErrorEvent *e)
{
#ifdef DEBUG
	char msg[80], number[80], req[80];

	XGetErrorText(X_Dpy, e->error_code, msg, sizeof(msg));
	(void)snprintf(number, sizeof(number), "%d", e->request_code);
	XGetErrorDatabaseText(X_Dpy, "XRequest", number,
	    "<unknown>", req, sizeof(req));

	warnx("%s(0x%x): %s", req, (unsigned int)e->resourceid, msg);
#endif
	return(0);
}

static void
sighdlr(int sig)
{
	pid_t	 pid;
	int	 save_errno = errno, status;

	switch (sig) {
	case SIGCHLD:
		/* Collect dead children. */
		while ((pid = waitpid(WAIT_ANY, &status, WNOHANG)) > 0 ||
		    (pid < 0 && errno == EINTR))
			;
		break;
	}

	errno = save_errno;
}

__dead void
usage(void)
{
	extern char	*__progname;

	(void)fprintf(stderr, "usage: %s [-c file] [-d display]\n",
	    __progname);
	exit(1);
}
@


1.98
log
@no need to unmap menu window again
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.97 2016/09/29 00:21:55 okan Exp $
d39 8
a46 12
Display				*X_Dpy;
Time				 Last_Event_Time = CurrentTime;
Atom				 cwmh[CWMH_NITEMS];
Atom				 ewmh[EWMH_NITEMS];

struct screen_ctx_q		 Screenq = TAILQ_HEAD_INITIALIZER(Screenq);

int				 HasRandr, Randr_ev;
struct conf			 Conf;
const char			*homedir;
char				*wm_argv;
volatile sig_atomic_t		 cwm_status;
d66 1
a66 1
	wm_argv = u_argv(argv);
d106 1
d121 1
a121 1
		u_exec(wm_argv);
d139 1
a139 1
	HasRandr = XRRQueryExtension(X_Dpy, &Randr_ev, &i);
@


1.97
log
@Mechanical change: move screen menu bits to their own struct.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.96 2015/11/12 17:56:54 okan Exp $
d164 1
a165 2
		XftFontClose(X_Dpy, sc->xftfont);
		XUnmapWindow(X_Dpy, sc->menu.win);
@


1.96
log
@pledge "stdio rpath proc exec" cwm before main event loop, after
init/setup - mostly for menu building.

ok semarie@@ (another cwm user)
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.95 2015/11/10 20:05:33 okan Exp $
d164 1
a164 1
		XftDrawDestroy(sc->xftdraw);
d166 2
a167 2
		XUnmapWindow(X_Dpy, sc->menuwin);
		XDestroyWindow(X_Dpy, sc->menuwin);
@


1.95
log
@Start cleaning up name vs function differences; replace magic numbers.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.94 2015/09/16 17:58:25 okan Exp $
d116 4
@


1.94
log
@On execwm, we should properly release resources before exec'ing into a
new window manager; so allow CWM_EXEC_WM to assign new wm to wm_argv and
pass through cwm_status (now EXECWM) so that x_teardown() gets called
before exec'ing the new window manager.  Removes the need for a separate
x_restart() now, using new wm_argv; and consolidates errno for execvp.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.93 2015/01/19 14:54:16 okan Exp $
d119 1
a119 1
	if (cwm_status == CWM_EXECWM)
@


1.93
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.92 2014/09/08 20:11:22 okan Exp $
d49 1
a54 1
static void	x_restart(char **);
a62 1
	char		**cwm_argv;
d70 1
a70 1
	cwm_argv = argv;
d119 2
a120 2
	if (cwm_status == CWM_RESTART)
		x_restart(cwm_argv);
a144 7
}

static void
x_restart(char **args)
{
	(void)setsid();
	(void)execvp(args[0], args);
@


1.92
log
@Remove duplicate client queue (mruq); instead, remove and take the
global Clientq and place it inside screen_ctx since every client belongs
to a screen, then use the same per screen clientq to track stacking
order (the sole reason for mruq).
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.91 2014/09/07 19:27:30 okan Exp $
d21 1
a21 1
#include <sys/param.h>
d28 1
@


1.91
log
@more style nits
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.90 2014/09/06 16:24:32 okan Exp $
a43 1
struct client_ctx_q		 Clientq = TAILQ_HEAD_INITIALIZER(Clientq);
@


1.90
log
@generic sighandler
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.89 2014/02/02 16:29:04 okan Exp $
d123 1
a123 1
	return (0);
d188 1
a188 1
	return (0);
d204 1
a204 1
	return (0);
@


1.89
log
@No need to store screen colormap and visual; rather just use the X
macros in the one place they are needed.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.88 2014/02/01 00:25:04 okan Exp $
d51 1
a51 1
static void	sigchld_cb(int);
d87 1
a87 1
	if (signal(SIGCHLD, sigchld_cb) == SIG_ERR)
d208 1
a208 1
sigchld_cb(int which)
d211 1
a211 2
	int	 save_errno = errno;
	int	 status;
d213 8
a220 4
	/* Collect dead children. */
	while ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||
	    (pid < 0 && errno == EINTR))
		;
@


1.88
log
@Let the config parser continue parsing even after encountering an error;
original idea (with now-outdated patch) from Thomas Adam.  Since we now
report where errors exist, this now makes more sense.  Expand a bit on
config file parsing in the cwm(1).

Discussed with a few, including sthen; ok sthen.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.87 2014/01/28 00:42:20 okan Exp $
d165 2
a166 1
			XftColorFree(X_Dpy, sc->visual, sc->colormap,
@


1.87
log
@Move conf_init/clear into main - no behaviour change; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.86 2014/01/22 22:26:05 okan Exp $
d111 2
a112 5
	if (conf_path && (parse_config(conf_path, &Conf) == -1)) {
		warnx("config file %s has errors, not loading", conf_path);
		conf_clear(&Conf);
		conf_init(&Conf);
	}
a141 1

d160 2
@


1.86
log
@cwm_argv doesn't need to be global any longer
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.85 2014/01/22 22:14:02 okan Exp $
d111 1
a111 1
	if (conf_path && (parse_config(conf_path, &Conf) == -1))
d113 3
@


1.85
log
@start properly releasing X resources during teardown
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.84 2014/01/22 21:48:27 okan Exp $
a37 1
char				**cwm_argv;
d54 1
a54 1
static void	x_restart(void);
d63 1
d121 1
a121 1
		x_restart();
d150 1
a150 1
x_restart(void)
d153 1
a153 1
	(void)execvp(cwm_argv[0], cwm_argv);
@


1.84
log
@Somewhat streamline event loop/restart/quit handling; most notable
change allows a restart to trigger proper teardown first, even though
teardown is not (yet) complete.

After some discussion with oga@@nicotinebsd.org regarding a more
complicated version/idea.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.83 2014/01/21 15:42:44 okan Exp $
d159 19
@


1.83
log
@Sprinkle a few more const; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.82 2014/01/03 15:29:06 okan Exp $
d50 1
d55 1
d116 3
a118 1
	xev_loop();
d120 2
d147 7
@


1.82
log
@use consistent types
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.81 2013/12/12 20:15:07 okan Exp $
d49 1
a49 1
char				*homedir;
@


1.81
log
@ICCCM explicitly states that server time (CurrentTime) should *not* be
used for focus events, but rather the timestamp of the generated event.
Track the last event timestamp and send it down for a WM_TAKE_FOCUS
ClientMessage.  I suspect we should do this for clients that don't
announce this Atom as well, though the raciness gets us into a bind.

Solves focus order issue since WM_TAKE_FOCUS; fix verified by sthen@@

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.80 2013/07/15 14:50:44 okan Exp $
d168 1
a168 1
	warnx("%s(0x%x): %s", req, (u_int)e->resourceid, msg);
@


1.80
log
@simplify atom handling; allows us to limit to one round-trip to server
for gathering Atoms.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.79 2013/07/08 15:46:16 okan Exp $
d40 1
@


1.79
log
@whitespace and style fixes; from Tiago Cunha and one from me.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.78 2013/06/17 17:11:10 okan Exp $
d40 2
d134 1
a134 1
	xu_getatoms();
@


1.78
log
@move Cursors into conf.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.77 2013/06/17 14:08:51 okan Exp $
a104 1

d123 1
a123 2
		errx(1, "unable to open display \"%s\"",
		    XDisplayName(dpyname));
@


1.77
log
@now that we have conf_screen, which configures individual screens
*after* config parsing, we no longer need to split up display/screen
initialization, so collapse.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.76 2013/05/22 16:54:09 okan Exp $
a40 6
Cursor				 Cursor_default;
Cursor				 Cursor_move;
Cursor				 Cursor_normal;
Cursor				 Cursor_question;
Cursor				 Cursor_resize;

d136 1
a136 5
	Cursor_default = XCreateFontCursor(X_Dpy, XC_X_cursor);
	Cursor_move = XCreateFontCursor(X_Dpy, XC_fleur);
	Cursor_normal = XCreateFontCursor(X_Dpy, XC_left_ptr);
	Cursor_question = XCreateFontCursor(X_Dpy, XC_question_arrow);
	Cursor_resize = XCreateFontCursor(X_Dpy, XC_bottom_right_corner);
@


1.76
log
@get rid of long standing XXX: now that we configure screens based on
config options, add the keybinding GrabKey calls here
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.75 2013/05/14 13:39:53 okan Exp $
a54 1
static void	dpy_init(const char *);
d56 2
a58 2
static void	x_setup(void);
static void	x_teardown(void);
a110 1
	dpy_init(display_name);
d117 1
a117 2
	xu_getatoms();
	x_setup();
d125 1
a125 1
dpy_init(const char *dpyname)
a138 1
}
d140 1
a140 4
static void
x_setup(void)
{
	int			 i;
@


1.75
log
@if -> ifdef
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.74 2013/04/12 14:49:16 okan Exp $
a146 1
	struct keybinding	*kb;
a156 7

	/*
	 * XXX key grabs weren't done before, since Screenq was empty,
	 * do them here for now (this needs changing).
	 */
	TAILQ_FOREACH(kb, &Conf.keybindingq, entry)
		conf_grab(&Conf, kb);
@


1.74
log
@makes no sense to set an error handler which uses X_Dpy before XOpenDisplay.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.73 2013/04/12 14:46:30 okan Exp $
d184 1
a184 1
#if DEBUG
@


1.73
log
@push Screenq into screen_init
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.72 2012/12/18 00:14:41 okan Exp $
a130 2

	XSetErrorHandler(x_errorhandler);
@


1.72
log
@simplify config file setup; with Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.71 2012/12/17 23:03:41 okan Exp $
a148 1
	struct screen_ctx	*sc;
d158 2
a159 5
	for (i = 0; i < ScreenCount(X_Dpy); i++) {
		sc = xcalloc(1, sizeof(*sc));
		screen_init(sc, i);
		TAILQ_INSERT_TAIL(&Screenq, sc, entry);
	}
@


1.71
log
@pull user home directory via getenv or getpwuid and stash it so we don't
need to do this everytime; with Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.70 2012/12/17 02:28:45 okan Exp $
d65 1
a65 1
	char		*display_name = NULL;
d100 12
d114 5
a118 2
	bzero(&Conf, sizeof(Conf));
	conf_setup(&Conf, conf_file);
@


1.70
log
@non-trivial menu drawing rewrite, moving to Xft and solving various
font/color drawing issues; from Alexander Polakov
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.69 2012/11/29 16:50:03 okan Exp $
d29 1
d52 1
d67 1
d91 8
@


1.69
log
@zap extra lines
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.68 2012/11/29 03:54:46 okan Exp $
a149 5
	struct screen_ctx	*sc;

	TAILQ_FOREACH(sc, &Screenq, entry)
		XFreeGC(X_Dpy, sc->gc);

@


1.68
log
@x_setupscreen -> screen_init; no functional change.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.67 2012/11/09 03:52:02 okan Exp $
a94 1

a95 1

@


1.67
log
@sort
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.66 2012/10/31 19:30:19 okan Exp $
a56 1
static void	x_setupscreen(struct screen_ctx *, u_int);
d137 1
a137 1
		x_setupscreen(sc, i);
a157 55
}

static void
x_setupscreen(struct screen_ctx *sc, u_int which)
{
	Window			*wins, w0, w1;
	XWindowAttributes	 winattr;
	XSetWindowAttributes	 rootattr;
	u_int			 nwins, i;

	sc->which = which;
	sc->rootwin = RootWindow(X_Dpy, sc->which);

	xu_ewmh_net_supported(sc);
	xu_ewmh_net_supported_wm_check(sc);

	conf_gap(&Conf, sc);

	screen_update_geometry(sc);

	conf_color(&Conf, sc);

	group_init(sc);
	conf_font(&Conf, sc);

	TAILQ_INIT(&sc->mruq);

	/* Initialize menu window. */
	menu_init(sc);

	rootattr.cursor = Cursor_normal;
	rootattr.event_mask = CHILDMASK|PropertyChangeMask|EnterWindowMask|
	    LeaveWindowMask|ColormapChangeMask|BUTTONMASK;

	XChangeWindowAttributes(X_Dpy, sc->rootwin,
	    CWEventMask|CWCursor, &rootattr);

	/* Deal with existing clients. */
	XQueryTree(X_Dpy, sc->rootwin, &w0, &w1, &wins, &nwins);

	for (i = 0; i < nwins; i++) {
		XGetWindowAttributes(X_Dpy, wins[i], &winattr);
		if (winattr.override_redirect ||
		    winattr.map_state != IsViewable)
			continue;
		(void)client_new(wins[i], sc, winattr.map_state != IsUnmapped);
	}
	XFree(wins);

	screen_updatestackingorder(sc);

	if (HasRandr)
		XRRSelectInput(X_Dpy, sc->rootwin, RRScreenChangeNotifyMask);

	XSync(X_Dpy, False);
@


1.66
log
@replace 'reload' with 'restart', which merely re-exec's cwm using the
existing argv; same idea with respect to argv saving as Alexander
Polakov.  reload support was half-complete and is getting in the way.

agreed to by many
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.65 2012/08/07 14:05:49 okan Exp $
d30 1
a32 1
#include <stdio.h>
@


1.65
log
@support multibyte input to menu code; from Alexander Polakov with a tiny tweak.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.64 2012/07/18 21:53:22 okan Exp $
d37 1
d71 1
@


1.64
log
@Further simplify Xinerama init and re-init on XRR events.

While testing for Xinerama during setup was done display-wide, each time
XineramaQueryScreens() is called either in start-up or due to an XRR
event, the library re-tests for the Xinerama extension anyway before
moving on; so the initial test is redundant and allows another global to
go away with one other change: always fill in sc->xinerama (and _no),
regardless of the success of malloc in XineramaQueryScreens(), and use
it to see if Xinerama dimensions exist when asked by client and/or menu
code.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.63 2012/07/06 14:18:00 okan Exp $
d28 1
d65 4
@


1.63
log
@querying for Xinerama should be done per display, not per screen, so
move chuck to display init; allows some shuffling to occur limiting
screen_init_xinerama()'s scope while keeping order intact.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.62 2012/07/05 17:35:13 okan Exp $
d47 1
a47 1
int				 HasXinerama, HasRandr, Randr_ev;
d100 1
a100 1
	int	i, fake;
a112 3
	if (XineramaQueryExtension(X_Dpy, &fake, &fake) == 1 &&
	    ((HasXinerama = XineramaIsActive(X_Dpy)) == 1))
		HasXinerama = 1;
@


1.62
log
@the display's width and height are updated after an XRandR event so we
don't need to pass down the new values to screen_update_geometry(); so
just read the width/height values directly for both uses of
screen_update_geometry().  prep for further changes in this area.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.61 2012/05/16 01:17:14 okan Exp $
d100 1
a100 1
	int	i;
d113 3
a162 1
	int			 fake;
a205 3
	if (XineramaQueryExtension(X_Dpy, &fake, &fake) == 1 &&
	    ((HasXinerama = XineramaIsActive(X_Dpy)) == 1))
		HasXinerama = 1;
a207 6
	/*
	 * initial setup of xinerama screens, if we're using RandR then we'll
	 * redo this whenever the screen changes since a CTRC may have been
	 * added or removed
	 */
	screen_init_xinerama(sc);
@


1.61
log
@instead of using the menu window for _NET_SUPPORTING_WM_CHECK, create a
dummy one to use instead; allows us to not have to wait for menu_init(),
so re-shuffle _NET_SUPPORTED slightly.

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.60 2012/05/13 15:15:54 okan Exp $
d170 2
a171 2
	screen_update_geometry(sc, DisplayWidth(X_Dpy, sc->which),
	    DisplayHeight(X_Dpy, sc->which));
@


1.60
log
@knf, some from a diff from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.59 2011/09/08 12:35:33 okan Exp $
d166 3
a181 2

	xu_setwmname(sc);
@


1.59
log
@allow configurable menu font color; from Alexander Polakov with a tweak
from me.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.58 2011/07/25 15:10:24 okan Exp $
d162 1
d225 1
@


1.58
log
@We are inconsistent when it comes to function returns, so just go all
the way with the cwm specific parts.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.57 2011/07/23 13:09:11 okan Exp $
a171 1
	font_init(sc);
@


1.57
log
@Clarify defines and make them not look like non-local ones; started by a
small diff from Thomas Pfaff.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.56 2011/06/24 06:52:23 okan Exp $
d197 1
a197 1
		client_new(wins[i], sc, winattr.map_state != IsUnmapped);
d232 1
a232 1
	snprintf(number, sizeof(number), "%d", e->request_code);
d261 2
a262 1
	fprintf(stderr, "usage: %s [-c file] [-d display]\n", __progname);
@


1.56
log
@add 'normal' cursor and shuffle the others we use to make a bit more
sense and to be slightly less un-expected.  from Alexander Polakov.
re-use 'normal' cursor now instead XC_hand1 for menu selection.  i
really wish X had real docs and made sense.

ok on earlier diff with '?' removed (but it's back now) oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.55 2011/06/24 05:58:51 okan Exp $
d183 2
a184 2
	rootattr.event_mask = ChildMask|PropertyChangeMask|EnterWindowMask|
	    LeaveWindowMask|ColormapChangeMask|ButtonMask;
@


1.55
log
@replace the non-working check to see if another wm is running with a
method that actually works.  checking for icccm compliant wm's should
also be done first, but that's another diff (noted by oga).

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.54 2011/05/11 13:53:51 okan Exp $
d38 1
d40 2
a42 3
Cursor				 Cursor_select;
Cursor				 Cursor_default;
Cursor				 Cursor_question;
d123 6
a140 6

	Cursor_move = XCreateFontCursor(X_Dpy, XC_fleur);
	Cursor_resize = XCreateFontCursor(X_Dpy, XC_bottom_right_corner);
	Cursor_select = XCreateFontCursor(X_Dpy, XC_hand1);
	Cursor_default = XCreateFontCursor(X_Dpy, XC_X_cursor);
	Cursor_question = XCreateFontCursor(X_Dpy, XC_question_arrow);
d182 1
d187 1
a187 1
	    CWEventMask, &rootattr);
@


1.54
log
@tag and comment cleanup; ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: calmwm.c,v 1.53 2010/04/12 16:17:46 oga Exp $
a47 1
int				 Starting;
d53 1
a82 1
	Starting = 1;
a88 1
	Starting = 0;
d102 2
d108 3
d218 7
d227 7
a233 8
#ifdef DEBUG
	{
		char msg[80], number[80], req[80];

		XGetErrorText(X_Dpy, e->error_code, msg, sizeof(msg));
		snprintf(number, sizeof(number), "%d", e->request_code);
		XGetErrorDatabaseText(X_Dpy, "XRequest", number,
		    "<unknown>", req, sizeof(req));
d235 1
a235 2
		warnx("%s(0x%x): %s", req, (u_int)e->resourceid, msg);
	}
a236 7

	if (Starting &&
	    e->error_code == BadAccess &&
	    e->request_code == X_GrabKey)
		errx(1, "root window unavailable - perhaps another "
		    "wm is running?");

@


1.53
log
@grab events on the root window *before* we look for existing windows.

This closes a race we were hitting often where stuff started right
before cwm may not get noticed and not have borders.

ok okan@@. Prompted by something todd noticed.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.52 2010/01/27 03:04:50 okan Exp $
@


1.52
log
@- allow per-screen gap; not (yet) user configurable.
- teach _NET_WORKAREA about gap.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.51 2009/12/15 04:10:42 okan Exp $
d179 6
a197 6

	rootattr.event_mask = ChildMask|PropertyChangeMask|EnterWindowMask|
	    LeaveWindowMask|ColormapChangeMask|ButtonMask;

	XChangeWindowAttributes(X_Dpy, sc->rootwin,
	    CWEventMask, &rootattr);
@


1.51
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.50 2009/12/15 03:34:34 okan Exp $
d162 1
@


1.50
log
@pull these headers only into files that need them.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.49 2009/12/15 03:24:36 okan Exp $
d21 6
d29 4
@


1.49
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.48 2009/12/10 23:14:58 oga Exp $
d20 3
@


1.48
log
@Implement _NET_CURRENT_DESKTOP, _NET_DESKTOP_VIEWPORT and
_NET_DESKTOP_GEOMETRY.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.47 2009/12/10 17:16:51 oga Exp $
a20 1
#include "headers.h"
@


1.47
log
@finish unfucking the screen_ctx handling.

remove screen_current() it was utterly bogus when nscreens > 1.

pass a fake client_ctx in the case where there's no client and the
kbfunc or mousefunc doesn't need a real one, it just contains the
current screen, modify these functions so that they pass down the screen
context to their callees.

make groups per screen, it's the only way it makes sense in this regard.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.46 2009/12/08 16:52:17 okan Exp $
d146 1
a146 2
	u_int			 ndesks = CALMWM_NGROUPS, nwins, i;

d149 3
a151 2
	sc->xmax = DisplayWidth(X_Dpy, sc->which);
	sc->ymax = DisplayHeight(X_Dpy, sc->which);
a162 7

	/*
	 * XXX this probably should be somewhere else, but since it's a 
	 * static value for now it does ok.
	 */
	XChangeProperty(X_Dpy, sc->rootwin, _NET_NUMBER_OF_DESKTOPS,
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)&ndesks, 1);
@


1.46
log
@start fixing screen_ctx usage, for it is utterly broken.  bring font
into screen_ctx and start passing screen_ctx around to in order get rid
of Curscreen; fixup per-screen config colors the same way.

diff mostly from oga@@, with a bit harsher reaction to the state of screen_ctx.

"please commit" oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.45 2009/12/07 23:19:51 oga Exp $
a32 2
struct screen_ctx		*Curscreen;

a73 2
	group_init();

a147 2
	Curscreen = sc;

d155 1
d185 1
a185 1
	screen_updatestackingorder();
@


1.45
log
@Implement _NET_NUMBER_OF_DESKTOPS, currently this is statically 9 and
unchangable. the group code needs some cleaning up before this will be a
bit less hackish.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.44 2009/12/07 21:20:52 okan Exp $
d159 1
a159 1
	conf_color(&Conf);
d162 1
a162 1
	conf_font(&Conf);
@


1.44
log
@introduce the beginnings of netwm support, minimally and correctly;
allows java to be happy, but additionally stops others from whinning
about a non-netwm complaint wm.  more to come.

written a few times; this one includes a clever hack from oga@@ to
populate _NET_SUPPORTED.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.43 2009/08/24 21:22:48 oga Exp $
d150 1
a150 1
	u_int			 nwins, i;
d168 7
@


1.43
log
@Instead of having a function that just calls TAILQ_INIT on a global, use
TAILQ_HEAD_INITIALIZER() and drop the function.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.42 2009/06/26 12:21:58 okan Exp $
d168 2
@


1.42
log
@static local functions and data; almost identical diff from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.41 2009/06/23 21:52:38 okan Exp $
d32 1
a32 1
struct screen_ctx_q		 Screenq;
d35 1
a35 1
struct client_ctx_q		 Clientq;
a75 1
	screen_init();
a76 1
	client_init();
@


1.41
log
@tidy up startup/init routines

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.40 2009/06/20 00:22:39 okan Exp $
d43 1
d93 1
a93 1
void
d107 1
a107 1
void
d134 1
a134 1
void
d145 1
a145 1
void
a203 2

	return;
d206 1
a206 1
int
@


1.40
log
@unroll XCALLOC/XMALLOC macros; since we use xcalloc/xmalloc all over the
place anyway, this makes things a bit more consistent; from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.39 2009/05/18 00:23:35 okan Exp $
d72 4
d77 1
a78 2
	Starting = 1;
	dpy_init(display_name);
a80 1
	client_setup();
a103 2

	TAILQ_INIT(&Screenq);
@


1.39
log
@nuke the leading underscore notation for local static functions - there
are far better ways to know.

"go for it" oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.38 2009/05/18 00:14:19 oga Exp $
d114 1
a114 1
		XCALLOC(sc, struct screen_ctx);
@


1.38
log
@Rip out the event layer and just use a static array of callbacks like
every other window manager since twm.

The event layer is very nice, very shiny, very flexible, and very much
underutilised. We don't need any of those shiny features so it's
probably better to earn ourselves 1k smaller text size instead.

ok todd@@, okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.37 2009/05/17 23:40:57 okan Exp $
d41 1
a41 1
static void	_sigchld_cb(int);
d69 1
a69 1
	if (signal(SIGCHLD, _sigchld_cb) == SIG_ERR)
d233 1
a233 1
_sigchld_cb(int which)
@


1.37
log
@a long time coming - re-work the way we deal with colors: since we're
using Xft(3), use it to select the font color as well instead of trying
to build one; properly allocate and free colors at-will, e.g. we now
have configurable colors.

feedback and ok's todd@@ and oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.36 2009/04/15 14:01:45 okan Exp $
a81 18

	xev_init();

	XEV_QUICK(NULL, NULL, MapRequest, xev_handle_maprequest, NULL);
	XEV_QUICK(NULL, NULL, UnmapNotify, xev_handle_unmapnotify, NULL);
	XEV_QUICK(NULL, NULL, ConfigureRequest,
	    xev_handle_configurerequest, NULL);
	XEV_QUICK(NULL, NULL, PropertyNotify, xev_handle_propertynotify, NULL);
	XEV_QUICK(NULL, NULL, EnterNotify, xev_handle_enternotify, NULL);
	XEV_QUICK(NULL, NULL, LeaveNotify, xev_handle_leavenotify, NULL);
	XEV_QUICK(NULL, NULL, ButtonPress, xev_handle_buttonpress, NULL);
	XEV_QUICK(NULL, NULL, ButtonRelease, xev_handle_buttonrelease, NULL);
	XEV_QUICK(NULL, NULL, KeyPress, xev_handle_keypress, NULL);
	XEV_QUICK(NULL, NULL, KeyRelease, xev_handle_keyrelease, NULL);
	XEV_QUICK(NULL, NULL, Expose, xev_handle_expose, NULL);
	XEV_QUICK(NULL, NULL, DestroyNotify, xev_handle_destroynotify, NULL);
	XEV_QUICK(NULL, NULL, ClientMessage, xev_handle_clientmessage, NULL);
	XEV_QUICK(NULL, NULL, MappingNotify, xev_handle_mapping, NULL);
@


1.36
log
@properly teardown X connection upon quit; static a few while here,
requested by oga@@

ok oga@@ sometime ago
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.35 2009/01/27 02:16:20 okan Exp $
a164 2
	XColor			 tmp;
	XGCValues		 gv;
d174 1
a174 2
	sc->rootwin = RootWindow(X_Dpy, which);

d178 1
a178 30
	XAllocNamedColor(X_Dpy, DefaultColormap(X_Dpy, which),
	    "black", &sc->fgcolor, &tmp);
	XAllocNamedColor(X_Dpy, DefaultColormap(X_Dpy, which),
	    "#00cc00", &sc->bgcolor, &tmp);
	XAllocNamedColor(X_Dpy,DefaultColormap(X_Dpy, which),
	    "blue", &sc->fccolor, &tmp);
	XAllocNamedColor(X_Dpy, DefaultColormap(X_Dpy, which),
	    "red", &sc->redcolor, &tmp);
	XAllocNamedColor(X_Dpy, DefaultColormap(X_Dpy, which),
	    "#666666", &sc->graycolor, &tmp);
	XAllocNamedColor(X_Dpy, DefaultColormap(X_Dpy, which),
	    "white", &sc->whitecolor, &tmp);
	XAllocNamedColor(X_Dpy, DefaultColormap(X_Dpy, which),
	    "black", &sc->blackcolor, &tmp);

	sc->blackpixl = BlackPixel(X_Dpy, sc->which);
	sc->whitepixl = WhitePixel(X_Dpy, sc->which);
	sc->bluepixl = sc->fccolor.pixel;
	sc->redpixl = sc->redcolor.pixel;
	sc->graypixl = sc->graycolor.pixel;

	gv.foreground = sc->blackpixl^sc->whitepixl;
	gv.background = sc->whitepixl;
	gv.function = GXxor;
	gv.line_width = 1;
	gv.subwindow_mode = IncludeInferiors;

	sc->gc = XCreateGC(X_Dpy, sc->rootwin,
	    GCForeground|GCBackground|GCFunction|
	    GCLineWidth|GCSubwindowMode, &gv);
@


1.35
log
@remove Nscreens and x_screenname() - we really don't need them.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.34 2009/01/22 15:26:33 oga Exp $
d43 3
d103 2
d149 11
@


1.34
log
@Cache all of the X atoms we use at startup.

Do this instead of querying for them every time we use them. This
removes an XXX that has been in there since time began. This will become
more important as we move towards supporting netwm.

ok todd@@, okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.33 2009/01/16 15:24:14 okan Exp $
a33 1
u_int				 Nscreens;
d126 1
a126 2
	Nscreens = ScreenCount(X_Dpy);
	for (i = 0; i < (int)Nscreens; i++) {
a138 1

a158 1
	sc->display = x_screenname(which);
a238 26
}

char *
x_screenname(int which)
{
	char	*cp, *dstr, *sn;
	size_t	 snlen;

	if (which > 9)
		errx(1, "Can't handle more than 9 screens.  If you need it, "
		    "tell <marius@@monkey.org>.  It's a trivial fix.");

	dstr = xstrdup(DisplayString(X_Dpy));

	if ((cp = strrchr(dstr, ':')) == NULL)
		return (NULL);

	if ((cp = strchr(cp, '.')) != NULL)
		*cp = '\0';

	snlen = strlen(dstr) + 3; /* string, dot, number, null */
	sn = (char *)xmalloc(snlen);
	snprintf(sn, snlen, "%s.%d", dstr, which);
	free(dstr);

	return (sn);
@


1.33
log
@remove pwin, bringing us to one client, one window.  we no longer have
to push attributes around, so things get a lot simplier, while fixing a
few issues in the meantime; original suggestion by Edd Barrett many many
moons ago.

annoying window placement and race, found in c2k8 by todd, fix by oga!

lots of feedback from todd and oga - thanks!

"commit that bad boy" oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.32 2009/01/15 17:23:12 oga Exp $
d77 1
d82 1
@


1.32
log
@On startup, don't leak memory when we enumerate existing windows.

The behaviour until now was to ask X for the windows name (which is
malloced) then drop that on the floor and do nothing with it. Skip this
foolery and just skip the window. I don't believe I never noticed this before!

"you can has ok" okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.31 2008/12/03 23:55:46 oga Exp $
a37 1
int				 Doshape, Shape_ev;
a41 5
/* From TWM */
#define gray_width 2
#define gray_height 2
static char gray_bits[] = {0x02, 0x01};

a112 2
	Doshape = XShapeQueryExtension(X_Dpy, &Shape_ev, &i);

d176 1
a176 1
	    "#00ccc8", &sc->cyancolor, &tmp);
d186 1
a186 13
	sc->cyanpixl = sc->cyancolor.pixel;

	sc->gray = XCreatePixmapFromBitmapData(X_Dpy, sc->rootwin,
	    gray_bits, gray_width, gray_height,
	    sc->blackpixl, sc->whitepixl, DefaultDepth(X_Dpy, sc->which));

	sc->blue = XCreatePixmapFromBitmapData(X_Dpy, sc->rootwin,
	    gray_bits, gray_width, gray_height,
	    sc->bluepixl, sc->whitepixl, DefaultDepth(X_Dpy, sc->which));

	sc->red = XCreatePixmapFromBitmapData(X_Dpy, sc->rootwin,
	    gray_bits, gray_width, gray_height,
	    sc->redpixl, sc->whitepixl, DefaultDepth(X_Dpy, sc->which));
@


1.31
log
@Don't ignore sigpipe. Everytime cwm forks it execs anyway (so it
shouldn't get that signal), and this causes problems for our children
since they inherit the ignore.

Pointed out by Jacek Masiulani in pr 6010; thanks!
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.30 2008/09/29 23:16:46 oga Exp $
d232 1
a232 3
		    winattr.map_state != IsViewable) {
			char *name;
			XFetchName(X_Dpy, wins[i], &name);
a233 1
		}
@


1.30
log
@Xinerama and XRandR dual head support for cwm(1). Now we detect the xrandr
reconfiguration events and change our sizes depending on that. We also detect
the xinerama screens for maximize, vertmaximize and initial window placement.

This could be improved by automatically resizing maximized windows when
the screen resolution changes and by moving windows that would be hidden
into visible space. Said changes will come shortly.

Tested by many. matthieu@@ didn't oppose.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.29 2008/09/22 14:28:04 oga Exp $
a71 4

	/* Ignore a few signals. */
	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
		err(1, "signal");
@


1.29
log
@*sigh* Revert the diff that wasn't meant to go in yet.

note to self: When you mean to type cvs commit search.c, don't forget
the filename.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.27 2008/07/22 21:01:54 oga Exp $
d39 1
d125 2
d139 1
a139 1
		XMALLOC(sc, struct screen_ctx);
d167 1
d252 12
@


1.28
log
@Display the current window title not a previous one in the case of
``show all'' in the window search dialogue. Noticed and diff from Tim
van der Molen, thanks!
@
text
@a38 1
int				 HasXinerama, HasRandr, Randr_ev;
a123 2
	HasRandr = XRRQueryExtension(X_Dpy, &Randr_ev, &i);

d136 1
a136 1
		XCALLOC(sc, struct screen_ctx);
a163 1
	int			 fake;
a247 12

	if (XineramaQueryExtension(X_Dpy, &fake, &fake) == 1 &&
	    ((HasXinerama = XineramaIsActive(X_Dpy)) == 1))
		HasXinerama = 1;
	if (HasRandr)
		XRRSelectInput(X_Dpy, sc->rootwin, RRScreenChangeNotifyMask);
	/*
	 * initial setup of xinerama screens, if we're using RandR then we'll
	 * redo this whenever the screen changes since a CTRC may have been
	 * added or removed
	 */
	screen_init_xinerama(sc);
@


1.27
log
@fix the froggy problem.

Implement a handler for the MappingEvent, meaning that the keymap has changed.
When this happens, ungrab all bindings, update the map, and regrab.

Fixes the problem where some keybindings wouldn't work under non us or
uk keymaps (especially the .fr map, it seems). Issue noticed by
ajacoutot@@, ratchov@@, and a few people on misc. Based on an initial diff
from ratchov@@.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.26 2008/07/22 20:51:54 oga Exp $
d39 1
d125 2
d139 1
a139 1
		XMALLOC(sc, struct screen_ctx);
d167 1
d252 12
@


1.26
log
@We've been handling grabbing wrong all this time (noticed at c2k8).

add conf_grab() and conf_ungrab, and use them in the keybinding manipulation
functions to {,un}grab the binding for all screens we have defined.

the lovely little ordering problem comes in here, since when we parse
the config initially Screenq is empty, so regrab after we fill the
queue, hopefully later reordering will remove this little need and there
will be much rejoicing.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.25 2008/07/22 20:42:24 oga Exp $
d104 1
@


1.25
log
@split x_setup() into two. dpy_init() for setting up the display and
checking the X config, and x_setup to set up the screens.

There's an ordering problem that means that some of this init needs to
come after the config is parsed, the rest should ideally happen before
though. This is a rough split, it will be refined later. Again, needed
for an upcoming change.

ok okan.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.24 2008/07/22 19:54:57 oga Exp $
d130 1
d140 8
a162 1
	struct keybinding	*kb;
a187 3

	TAILQ_FOREACH(kb, &Conf.keybindingq, entry)
		xu_key_grab(sc->rootwin, kb->modmask, kb->keysym);
@


1.24
log
@Kill screen_init(). it's been stubbed out for a while now. I don't envision it
coming back in it's current form.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.23 2008/07/11 14:21:28 okan Exp $
d48 1
d82 1
d86 1
a86 1
	x_setup(display_name);
d111 1
a111 1
x_setup(char *display_name)
d113 1
a113 4
	struct screen_ctx	*sc;
	int			 i;

	TAILQ_INIT(&Screenq);
d115 1
a115 1
	if ((X_Dpy = XOpenDisplay(display_name)) == NULL)
d117 1
a117 1
		    XDisplayName(display_name));
d122 9
@


1.23
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.22 2008/06/25 01:09:09 oga Exp $
a206 4
	/*
	 * XXX - this should *really* be in screen_init().  ordering
	 * problem.
	 */
a226 1
	screen_init();
@


1.22
log
@Sort flags.

From Pierre Riteau, thanks!

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.21 2008/06/15 02:47:46 oga Exp $
a46 1

d52 3
a54 4
	int ch;
	const char *conf_file = NULL;

	char *display_name = NULL;
d111 2
a112 2
	int i;
	struct screen_ctx *sc;
d141 7
a147 7
	XColor tmp;
	XGCValues gv;
	Window *wins, w0, w1;
	u_int nwins, i = 0;
	XWindowAttributes winattr;
	XSetWindowAttributes rootattr;
	struct keybinding *kb;
d248 2
a249 2
	char *cp, *dstr, *sn;
	size_t snlen;
d299 3
a301 3
	pid_t pid;
	int save_errno = errno;
	int status;
d314 1
a314 1
	extern char *__progname;
@


1.21
log
@Rip out and burn the HASH_* stuff. We don't need a SPLAY tree for one font.
makes the code a lot simpler. While here rearrange the font handling functions
to be less shit.

ok and help okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.20 2008/05/21 14:11:19 oga Exp $
d318 1
a318 1
	fprintf(stderr, "usage: %s [-d display] [-c file]\n", __progname);
@


1.20
log
@Make menu_filter handle mouse movement too. This enables the keyboard
search dialogues to be manipulated with the mouse, too. It also allows
me to shrink the codebase further by killing grab_menu().

One known issue with highlighting the first entry in a search dialogue,
that'll be fixed soonish.

ok okan@@, tested by Edd Barrett and todd@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.19 2008/05/20 14:50:51 oga Exp $
a40 1
struct fontdesc			*DefaultFont = NULL;
d151 2
d207 1
a207 3
	DefaultFont = font_getx(sc, Conf.DefaultFontName);
	sc->fontheight = font_ascent(DefaultFont) +
	    font_descent(DefaultFont) + 1;
a232 1
	Curscreen = sc;	/* XXX */
@


1.19
log
@Pull out the behaviour in grab_label and search_start into one utility
function menu_filter(). The plan is to eventually merge in grab_menu too.
Shrinks the code a fair bit.

Also, change XMaskEvent for XWindowEvent to prevent getting exposes for other
windows. This is particuarly noticable on slow machines with a LOT of xterms
(todd, you're an odd man).

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.18 2008/05/19 18:53:09 oga Exp $
a204 4
	sc->hlgc = XCreateGC(X_Dpy, sc->rootwin,
	    GCForeground|GCBackground|GCFunction|
	    GCLineWidth|GCSubwindowMode, &gv);

d217 1
a217 1
	grab_menuinit(sc);
@


1.18
log
@General cleanup.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.17 2008/05/06 15:12:04 tobias Exp $
d155 4
d211 2
a221 1
	search_init(sc);
@


1.17
log
@Signal handler of SIGCHLD calls waitpid() which sets errno on error. To
avoid clubbering of errno in normal context, save_errno got introduced.

ok oga
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.16 2008/04/15 20:24:41 oga Exp $
d55 1
a55 1
	const char *conffile = NULL;
d62 1
a62 1
			conffile = optarg;
d85 1
a85 1
	conf_setup(&Conf, conffile);
d241 1
a241 1
	    /* CWCursor| */CWEventMask, &rootattr);
d260 1
a260 1
	if ((cp = rindex(dstr, ':')) == NULL)
d263 1
a263 1
	if ((cp = index(cp, '.')) != NULL)
@


1.16
log
@hit it with the knf stick.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.15 2008/04/15 18:22:08 okan Exp $
d303 1
d310 2
@


1.15
log
@malloc -> calloc

suggested by and ok oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.14 2008/04/03 13:58:57 simon Exp $
d41 1
a41 1
struct fontdesc                 *DefaultFont = NULL;
d49 1
a49 1
static void _sigchld_cb(int);
d75 2
a76 2
        if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
                err(1, "signal");
d78 2
a79 2
        if (signal(SIGCHLD, _sigchld_cb) == SIG_ERR)
                err(1, "signal");
d179 7
a185 7
        sc->gray = XCreatePixmapFromBitmapData(X_Dpy, sc->rootwin,
            gray_bits, gray_width, gray_height,
            sc->blackpixl, sc->whitepixl, DefaultDepth(X_Dpy, sc->which));

        sc->blue = XCreatePixmapFromBitmapData(X_Dpy, sc->rootwin,
            gray_bits, gray_width, gray_height,
            sc->bluepixl, sc->whitepixl, DefaultDepth(X_Dpy, sc->which));
d187 2
a188 2
        sc->red = XCreatePixmapFromBitmapData(X_Dpy, sc->rootwin,
            gray_bits, gray_width, gray_height,
d219 1
a219 1
	XQueryTree(X_Dpy, sc->rootwin, &w0, &w1, &wins, &nwins);	
d290 3
a292 3
	if (Starting && 
	    e->error_code == BadAccess &&                                       
	    e->request_code == X_GrabKey)                        
d294 1
a294 1
		    "wm is running?");                                      
d305 3
a307 3
/* 	Collect dead children. */
        while ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||
            (pid < 0 && errno == EINTR))
@


1.14
log
@Sync usage() with reality and manpage.

"ok, but no cookie" oga@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.13 2008/03/23 15:09:21 simon Exp $
d84 1
@


1.13
log
@Replace the symlink configuration scheme with a simple yacc parser as
found in other places of the tree.  Remove sticky and font commandline
options and add another one for alternative config locations.
Split off cwmrc(5) from cwm(1), nuke #ifdef __OpenBSD__ while there.

tested by various kind people, feedback from oga@@ and okan@@ - thanks!
ok oga@@, jasper@@, okan@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.12 2008/03/22 15:09:45 oga Exp $
d315 1
a315 1
	fprintf(stderr, "usage: %s [-s] [-d display] [-f fontname] \n", __progname);
@


1.12
log
@Rip out, burn, and dance around the grave of group-edit mode.
I've yet to speak to anyone who uses it, so just kill it.

You can still add/remove from groups using the mouse binding.  Groups
may get a re-work sometime soon if i have a stroke of genius.

knocks about 4k off the i386 binary for me.

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.11 2008/03/22 14:09:02 oga Exp $
d41 1
a41 2
struct fontdesc                 *DefaultFont;
char                            *DefaultFontName;
d55 1
a55 1
	int conf_flags = 0;
d59 1
a59 3
	DefaultFontName = "sans-serif:pixelsize=14:bold";

	while ((ch = getopt(argc, argv, "d:sf:")) != -1) {
d61 3
a66 6
		case 's':
			conf_flags |= CONF_STICKY_GROUPS;
			break;
		case 'f':
			DefaultFontName = xstrdup(optarg);
			break;
d84 1
a84 2
	conf_setup(&Conf);
	Conf.flags |= conf_flags;
d205 1
a205 1
	DefaultFont = font_getx(sc, DefaultFontName);
@


1.11
log
@Remove a bunch of unused variables and incorrect comments.

"ok with me" okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.10 2008/02/13 21:48:03 oga Exp $
a121 1
	char *fontname;
@


1.10
log
@usage never returns, and thus should be __dead.

ok jasper@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.9 2008/02/13 21:04:19 oga Exp $
d152 1
a152 1
	XGCValues gv, gv1/* , gv2 */;
a210 7

	gv1.function = GXinvert;
	gv1.subwindow_mode = IncludeInferiors;
	gv1.line_width = 1;

	sc->invgc = XCreateGC(X_Dpy, sc->rootwin,
	    GCFunction|GCSubwindowMode|GCLineWidth, &gv1);
@


1.9
log
@add usage() for when an unknown option is given.

from Gleydson Soares <gsoares@@gmail.com>, thanks!

ok jasper@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.8 2008/02/13 12:09:47 oga Exp $
d325 1
a325 1
void
@


1.8
log
@Make cwm print the XDisplayName() if it fails to open the display,
instead of an error message that'll be gibberish to most people.

from Gleydson Soares. Thanks!

ok simon@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.7 2008/01/16 11:39:20 oga Exp $
d74 1
a74 1
			errx(1, "Unknown option '%c'", ch);
d323 9
@


1.7
log
@huge amount of cleanup and dead code removal.

full description of changes:
-remove fontlist, and all associated structures/calls, it's not needed.
 this also removes any doubt about leftover 9wm code (the list was
 borrowed from it). Since cwm now uses Xft for everything, the legacy
 font handling is just not needed.
-add /* FALLTHROUGH */ comments into grab_{label,menu}. I actually
 didn't intend grab_menu to be a fallthrough, but it actually works quite
 well there, so remove the extra rectangle drawing. I love it when that
 happens.
-remove a couple of unused prototypes that were obviously missed
 before.
-remove a bunch of commented out or if 0ed out code. It doesn't look to
 be coming back anytime soon.
-several functions returned an int, but this was never checked. most of
 them only failed if they failed to grab the pointer (thus the internal
 state didn't change), so just make them void and return early if this is
 the case.
-remove several unused functions and some useless variables.

knocks something like 200bytes off the stripped binary size for me.

ok marc@@, tested by several others.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.6 2008/01/14 15:21:10 oga Exp $
d127 2
a128 1
		errx(1, "%s:%d XOpenDisplay()", __FILE__, __LINE__);
@


1.6
log
@Rewrite most of grab_menu in grab.c (it was partly 9wm code).
This should work functionally the same, with a few simplifications.

Changes:
- we don't care if you're holding another button when you release the
  menu key if you don't want to select anything, move off the menu.
- remove the hysteresis from the menu selection (before you had to move
  more than three pixels onto a new menu entry before it selected it)
- simplify a lot of the selection code
- kill dead code.
- do what the XXX comment said and cache the screensize (i may tweak
  this later).

As far as I can tell, the only code remaining from 9wm is the list of
fonts in calmwm.c. Others appear to concur.

ok marc@@, looked over and tested by a few others. Reminders from okan@@.
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.5 2008/01/11 16:06:44 oga Exp $
a24 1
XFontStruct			*X_Font;
a48 9
/* List borrowed from 9wm/rio */
char *tryfonts[] = {
	"9x15bold",
	"*-lucidatypewriter-bold-*-14-*-75-*",
	"*-lucidatypewriter-medium-*-12-*-75-*",
	"fixed",
	"*",
	NULL,
};
a132 9
	i = 0;
	while ((fontname = tryfonts[i++]) != NULL) {
		if ((X_Font = XLoadQueryFont(X_Dpy, fontname)) != NULL)
			break;
	}

	if (fontname == NULL)
		errx(1, "Couldn't load any fonts.");

a141 1
	/* (used to be) XCreateFontCursor(X_Dpy, XC_hand1); */
d147 1
a147 1
int
a178 4
	/* Special -- for alt state. */
/* 	xu_key_grab(sc->rootwin, 0, XK_Alt_L); */
/* 	xu_key_grab(sc->rootwin, 0, XK_Alt_R); */

a201 1
	gv.font = X_Font->fid;
d205 1
a205 10
	    GCLineWidth|GCSubwindowMode|GCFont, &gv);

#ifdef notyet
	gv2.foreground = sc->blackpixl^sc->cyanpixl;
	gv2.background = sc->cyanpixl;
	gv2.function = GXxor;
	gv2.line_width = 1;
	gv2.subwindow_mode = IncludeInferiors;
	gv2.font = X_Font->fid;
#endif
d209 1
a209 1
	    GCLineWidth|GCSubwindowMode|GCFont, &gv);
a213 1
	gv1.font = X_Font->fid;
d216 1
a216 1
	    GCFunction|GCSubwindowMode|GCLineWidth|GCFont, &gv1);
d258 1
a258 1
	return (0);
@


1.5
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d18 1
a18 1
 * $Id: calmwm.c,v 1.4 2007/05/28 18:34:27 jasper Exp $
a52 1
	"blit",
a162 1
/* 	Cursor_select = cursor_bigarrow(Curscreen); */
a163 1
/* 	Cursor_default = cursor_bigarrow(Curscreen); */
a286 3

	/* Set the root cursor to a nice obnoxious arrow :-) */
/* 	rootattr.cursor = cursor_bigarrow(sc); */
@


1.4
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@a4 1
 * All rights reserved.
d6 13
a18 1
 * $Id: calmwm.c,v 1.3 2007/05/21 07:53:11 jasper Exp $
@


1.3
log
@fix optind

ok ray@@
@
text
@d7 1
a7 1
 * $Id: calmwm.c,v 1.2 2007/05/10 17:23:49 jasper Exp $
d13 2
a14 2
Display				*G_dpy;
XFontStruct			*G_font;
d16 15
a30 15
Cursor				 G_cursor_move;
Cursor				 G_cursor_resize;
Cursor				 G_cursor_select;
Cursor				 G_cursor_default;
Cursor				 G_cursor_question;

struct screen_ctx_q		 G_screenq;
struct screen_ctx		*G_curscreen;
u_int				 G_nscreens;

struct client_ctx_q		 G_clientq;

int				 G_doshape, G_shape_ev;
int				 G_starting;
struct conf			 G_conf;
d89 3
a91 3
	G_starting = 1;
	conf_setup(&G_conf);
	G_conf.flags |= conf_flags;
d94 1
a94 1
	G_starting = 0;
d124 1
a124 1
	TAILQ_INIT(&G_screenq);
d126 1
a126 1
	if ((G_dpy = XOpenDisplay(display_name)) == NULL)
d131 1
a131 1
	G_doshape = XShapeQueryExtension(G_dpy, &G_shape_ev, &i);
d135 1
a135 1
		if ((G_font = XLoadQueryFont(G_dpy, fontname)) != NULL)
d142 2
a143 2
	G_nscreens = ScreenCount(G_dpy);
	for (i = 0; i < (int)G_nscreens; i++) {
d146 1
a146 1
		TAILQ_INSERT_TAIL(&G_screenq, sc, entry);
d149 8
a156 8
	G_cursor_move = XCreateFontCursor(G_dpy, XC_fleur);
	G_cursor_resize = XCreateFontCursor(G_dpy, XC_bottom_right_corner);
	/* (used to be) XCreateFontCursor(G_dpy, XC_hand1); */
	G_cursor_select = XCreateFontCursor(G_dpy, XC_hand1);
/* 	G_cursor_select = cursor_bigarrow(G_curscreen); */
	G_cursor_default = XCreateFontCursor(G_dpy, XC_X_cursor);
/* 	G_cursor_default = cursor_bigarrow(G_curscreen); */
	G_cursor_question = XCreateFontCursor(G_dpy, XC_question_arrow);
d172 2
a173 2
	sc->rootwin = RootWindow(G_dpy, which);
	XAllocNamedColor(G_dpy, DefaultColormap(G_dpy, which),
d175 1
a175 1
	XAllocNamedColor(G_dpy, DefaultColormap(G_dpy, which),
d177 1
a177 1
	XAllocNamedColor(G_dpy,DefaultColormap(G_dpy, which),
d179 1
a179 1
	XAllocNamedColor(G_dpy, DefaultColormap(G_dpy, which),
d181 1
a181 1
	XAllocNamedColor(G_dpy, DefaultColormap(G_dpy, which),
d183 1
a183 1
	XAllocNamedColor(G_dpy, DefaultColormap(G_dpy, which),
d185 1
a185 1
	XAllocNamedColor(G_dpy, DefaultColormap(G_dpy, which),
d188 1
a188 1
	TAILQ_FOREACH(kb, &G_conf.keybindingq, entry)
d195 2
a196 2
	sc->blackpixl = BlackPixel(G_dpy, sc->which);
	sc->whitepixl = WhitePixel(G_dpy, sc->which);
d201 1
a201 1
        sc->gray = XCreatePixmapFromBitmapData(G_dpy, sc->rootwin,
d203 1
a203 1
            sc->blackpixl, sc->whitepixl, DefaultDepth(G_dpy, sc->which));
d205 1
a205 1
        sc->blue = XCreatePixmapFromBitmapData(G_dpy, sc->rootwin,
d207 1
a207 1
            sc->bluepixl, sc->whitepixl, DefaultDepth(G_dpy, sc->which));
d209 1
a209 1
        sc->red = XCreatePixmapFromBitmapData(G_dpy, sc->rootwin,
d211 1
a211 1
	    sc->redpixl, sc->whitepixl, DefaultDepth(G_dpy, sc->which));
d218 1
a218 1
	gv.font = G_font->fid;
d220 1
a220 1
	sc->gc = XCreateGC(G_dpy, sc->rootwin,
d230 1
a230 1
	gv2.font = G_font->fid;
d233 1
a233 1
	sc->hlgc = XCreateGC(G_dpy, sc->rootwin,
d240 1
a240 1
	gv1.font = G_font->fid;
d242 1
a242 1
	sc->invgc = XCreateGC(G_dpy, sc->rootwin,
d259 1
a259 1
	XQueryTree(G_dpy, sc->rootwin, &w0, &w1, &wins, &nwins);	
d262 1
a262 1
		XGetWindowAttributes(G_dpy, wins[i], &winattr);
d266 1
a266 1
			XFetchName(G_dpy, wins[i], &name);
d273 1
a273 1
	G_curscreen = sc;	/* XXX */
d283 1
a283 1
	XChangeWindowAttributes(G_dpy, sc->rootwin,
d286 1
a286 1
	XSync(G_dpy, False);
d301 1
a301 1
	dstr = xstrdup(DisplayString(G_dpy));
d324 1
a324 1
		XGetErrorText(G_dpy, e->error_code, msg, sizeof(msg));
d326 1
a326 1
		XGetErrorDatabaseText(G_dpy, "XRequest", number,
d333 1
a333 1
	if (G_starting && 
@


1.2
log
@- add a "-d" option, to specify the display cwm should be started on
- adjust argc/argv by optind
- add an ENVIRONMENT section to the manpage

ok matthieu@@ ray@@
@
text
@d7 1
a7 1
 * $Id: calmwm.c,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
d78 1
a78 1
	argv +- optind;
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * $Id: calmwm.c,v 1.31 2005/08/28 09:46:33 marius Exp $
d58 2
d62 1
a62 1
	while ((ch = getopt(argc, argv, "sf:")) != -1) {
d64 3
d77 2
d93 1
a93 1
	x_setup();
d118 1
a118 1
x_setup(void)
d126 1
a126 1
	if ((G_dpy = XOpenDisplay("")) == NULL)
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
