head	1.84;
access;
symbols
	OPENBSD_6_2:1.84.0.4
	OPENBSD_6_2_BASE:1.84
	OPENBSD_6_1:1.84.0.2
	OPENBSD_6_1_BASE:1.84
	OPENBSD_6_0:1.79.0.4
	OPENBSD_6_0_BASE:1.79
	OPENBSD_5_9:1.79.0.2
	OPENBSD_5_9_BASE:1.79
	OPENBSD_5_8:1.76.0.2
	OPENBSD_5_8_BASE:1.76
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.61.0.4
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.61.0.2
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.52.0.2
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.6
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.16.0.2
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.84
date	2016.10.24.17.39.38;	author okan;	state Exp;
branches;
next	1.83;
commitid	4CtR29PGziRtkeB6;

1.83
date	2016.10.18.17.03.30;	author okan;	state Exp;
branches;
next	1.82;
commitid	dIOrHVlb55Ubzrpl;

1.82
date	2016.10.04.20.15.55;	author okan;	state Exp;
branches;
next	1.81;
commitid	vRGk95BhViXMArN6;

1.81
date	2016.10.04.15.18.20;	author okan;	state Exp;
branches;
next	1.80;
commitid	A3zvKURgft7ltYQX;

1.80
date	2016.09.16.14.32.02;	author okan;	state Exp;
branches;
next	1.79;
commitid	JzYS0uWdEYDeM0Hk;

1.79
date	2015.11.11.14.22.01;	author okan;	state Exp;
branches;
next	1.78;
commitid	t4AzuTxPlqQ6EzqO;

1.78
date	2015.11.09.20.03.30;	author okan;	state Exp;
branches;
next	1.77;
commitid	9uKgpfLzKiBWmiSm;

1.77
date	2015.08.21.16.52.37;	author okan;	state Exp;
branches;
next	1.76;
commitid	dg8NUwKKSZKDgRDL;

1.76
date	2015.06.30.14.01.43;	author okan;	state Exp;
branches;
next	1.75;
commitid	h5qrb2HfsKgjVuzR;

1.75
date	2015.06.26.18.54.25;	author okan;	state Exp;
branches;
next	1.74;
commitid	nUe9eqlUBkWabUnp;

1.74
date	2015.06.26.17.17.46;	author okan;	state Exp;
branches;
next	1.73;
commitid	lHlj3PDNu98waqIr;

1.73
date	2015.06.26.16.11.21;	author okan;	state Exp;
branches;
next	1.72;
commitid	Drua5igvHL1eg9QS;

1.72
date	2015.06.26.15.21.58;	author okan;	state Exp;
branches;
next	1.71;
commitid	TlmnEeM7r3xmmliS;

1.71
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.70;
commitid	kLADTGYX3gw0Sf2m;

1.70
date	2014.10.08.15.31.01;	author okan;	state Exp;
branches;
next	1.69;
commitid	koNZtHET0Ys55YOD;

1.69
date	2014.10.08.12.48.51;	author okan;	state Exp;
branches;
next	1.68;
commitid	bx3Cy9JxKYTynRL9;

1.68
date	2014.09.23.13.45.48;	author okan;	state Exp;
branches;
next	1.67;
commitid	3MLwoEk2vcFsHNle;

1.67
date	2014.09.08.20.11.22;	author okan;	state Exp;
branches;
next	1.66;
commitid	cu11ybsl8atTMRXD;

1.66
date	2014.09.07.19.27.30;	author okan;	state Exp;
branches;
next	1.65;
commitid	jXQ1fztXcP9vyPb1;

1.65
date	2014.09.07.17.38.38;	author okan;	state Exp;
branches;
next	1.64;
commitid	idgYRjbgDXLP4UK7;

1.64
date	2014.08.24.15.37.45;	author okan;	state Exp;
branches;
next	1.63;
commitid	0998haeGdCsc6F3q;

1.63
date	2014.08.20.15.15.29;	author okan;	state Exp;
branches;
next	1.62;
commitid	SsDu0AngUZExtrz4;

1.62
date	2014.08.20.12.35.39;	author okan;	state Exp;
branches;
next	1.61;
commitid	C809ocPBc4jEq7ra;

1.61
date	2014.02.08.02.49.30;	author okan;	state Exp;
branches;
next	1.60;

1.60
date	2014.02.03.21.07.47;	author okan;	state Exp;
branches;
next	1.59;

1.59
date	2014.02.03.20.29.05;	author okan;	state Exp;
branches;
next	1.58;

1.58
date	2014.02.03.20.20.39;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2014.02.02.16.29.04;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2014.02.02.16.13.50;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2014.01.27.15.13.09;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2014.01.03.15.29.06;	author okan;	state Exp;
branches;
next	1.53;

1.53
date	2013.12.13.22.39.13;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2013.06.17.17.11.10;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.20.20.21.04;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2013.05.11.22.01.07;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.11.21.46.27;	author okan;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.30.21.12.20;	author okan;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.29.00.56.48;	author okan;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.12.14.46.30;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.08.04.12.51;	author okan;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.07.21.45.24;	author okan;	state Exp;
branches;
next	1.43;

1.43
date	2013.01.07.20.32.19;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.02.18.11.23;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2013.01.02.16.26.34;	author okan;	state Exp;
branches;
next	1.40;

1.40
date	2012.12.18.18.39.55;	author okan;	state Exp;
branches;
next	1.39;

1.39
date	2012.12.17.18.34.06;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2012.11.29.03.54.46;	author okan;	state Exp;
branches;
next	1.37;

1.37
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2012.07.18.21.53.22;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.16.01.42.00;	author okan;	state Exp;
branches;
next	1.34;

1.34
date	2012.07.16.01.36.31;	author okan;	state Exp;
branches;
next	1.33;

1.33
date	2012.07.13.15.21.35;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2012.07.13.14.18.04;	author okan;	state Exp;
branches;
next	1.31;

1.31
date	2012.07.06.14.18.00;	author okan;	state Exp;
branches;
next	1.30;

1.30
date	2012.07.05.17.35.13;	author okan;	state Exp;
branches;
next	1.29;

1.29
date	2012.07.03.13.49.03;	author okan;	state Exp;
branches;
next	1.28;

1.28
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.27;

1.27
date	2011.03.22.10.54.42;	author okan;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.27.03.04.50;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.11.18.09.16;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2009.12.11.17.57.38;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.10.23.14.58;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.10.17.16.51;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2009.11.28.17.52.12;	author tobias;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.22.21.38.50;	author tobias;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.24.21.22.48;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.26.12.21.58;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.23.21.52.38;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.15.00.32.35;	author okan;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.11.18.25.49;	author okan;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.06.00.19.55;	author okan;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.23.16.46;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.22.14.28.04;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.22.14.15.03;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.07.22.19.54.57;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.01.18.01.13;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.16.13.35.37;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.84
log
@Sprinkle __func__ in appropriate error messages.
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: screen.c,v 1.83 2016/10/18 17:03:30 okan Exp $
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

void
screen_init(int which)
{
	struct screen_ctx	*sc;
	Window			*wins, w0, w1, active = None;
	XSetWindowAttributes	 rootattr;
	unsigned int		 nwins, i;

	sc = xmalloc(sizeof(*sc));

	TAILQ_INIT(&sc->clientq);
	TAILQ_INIT(&sc->regionq);
	TAILQ_INIT(&sc->groupq);

	sc->which = which;
	sc->rootwin = RootWindow(X_Dpy, sc->which);
	sc->cycling = 0;
	sc->hideall = 0;

	conf_screen(sc);

	xu_ewmh_net_supported(sc);
	xu_ewmh_net_supported_wm_check(sc);

	screen_update_geometry(sc);

	for (i = 0; i < Conf.ngroups; i++)
		group_init(sc, i);

	xu_ewmh_net_desktop_names(sc);
	xu_ewmh_net_wm_desktop_viewport(sc);
	xu_ewmh_net_wm_number_of_desktops(sc);
	xu_ewmh_net_showing_desktop(sc);
	xu_ewmh_net_virtual_roots(sc);
	active = xu_ewmh_get_net_active_window(sc);

	rootattr.cursor = Conf.cursor[CF_NORMAL];
	rootattr.event_mask = SubstructureRedirectMask |
	    SubstructureNotifyMask | PropertyChangeMask | EnterWindowMask |
	    LeaveWindowMask | ColormapChangeMask | BUTTONMASK;

	XChangeWindowAttributes(X_Dpy, sc->rootwin,
	    (CWEventMask | CWCursor), &rootattr);

	/* Deal with existing clients. */
	if (XQueryTree(X_Dpy, sc->rootwin, &w0, &w1, &wins, &nwins)) {
		for (i = 0; i < nwins; i++)
			(void)client_init(wins[i], sc, (active == wins[i]));

		XFree(wins);
	}
	screen_updatestackingorder(sc);

	if (Conf.xrandr)
		XRRSelectInput(X_Dpy, sc->rootwin, RRScreenChangeNotifyMask);

	TAILQ_INSERT_TAIL(&Screenq, sc, entry);

	XSync(X_Dpy, False);
}

struct screen_ctx *
screen_find(Window win)
{
	struct screen_ctx	*sc;

	TAILQ_FOREACH(sc, &Screenq, entry) {
		if (sc->rootwin == win)
			return(sc);
	}
	warnx("%s: failure win 0x%lu\n", __func__, win);
	return(NULL);
}

void
screen_updatestackingorder(struct screen_ctx *sc)
{
	Window			*wins, w0, w1;
	struct client_ctx	*cc;
	unsigned int		 nwins, i, s;

	if (XQueryTree(X_Dpy, sc->rootwin, &w0, &w1, &wins, &nwins)) {
		for (s = 0, i = 0; i < nwins; i++) {
			/* Skip hidden windows */
			if ((cc = client_find(wins[i])) == NULL ||
			    cc->flags & CLIENT_HIDDEN)
				continue;

			cc->stackingorder = s++;
		}
		XFree(wins);
	}
}

struct region_ctx *
region_find(struct screen_ctx *sc, int x, int y)
{
	struct region_ctx	*rc;

	TAILQ_FOREACH(rc, &sc->regionq, entry) {
		if ((x >= rc->view.x) && (x < (rc->view.x + rc->view.w)) &&
		    (y >= rc->view.y) && (y < (rc->view.y + rc->view.h))) {
			break;
		}
	}
	return(rc);
}

struct geom
screen_area(struct screen_ctx *sc, int x, int y, enum apply_gap apply_gap)
{
	struct region_ctx	*rc;
	struct geom		 area = sc->work;

	TAILQ_FOREACH(rc, &sc->regionq, entry) {
		if ((x >= rc->area.x) && (x < (rc->area.x + rc->area.w)) &&
		    (y >= rc->area.y) && (y < (rc->area.y + rc->area.h))) {
			area = rc->area;
			break;
		}
	}
	if (apply_gap)
		area = screen_apply_gap(sc, area);
	return(area);
}

void
screen_update_geometry(struct screen_ctx *sc)
{
	struct region_ctx	*rc;

	sc->view.x = 0;
	sc->view.y = 0;
	sc->view.w = DisplayWidth(X_Dpy, sc->which);
	sc->view.h = DisplayHeight(X_Dpy, sc->which);
	sc->work = screen_apply_gap(sc, sc->view);

	while ((rc = TAILQ_FIRST(&sc->regionq)) != NULL) {
		TAILQ_REMOVE(&sc->regionq, rc, entry);
		free(rc);
	}

	if (Conf.xrandr) {
		XRRScreenResources *sr;
		XRRCrtcInfo *ci;
		int i;

		sr = XRRGetScreenResources(X_Dpy, sc->rootwin);
		for (i = 0, ci = NULL; i < sr->ncrtc; i++) {
			ci = XRRGetCrtcInfo(X_Dpy, sr, sr->crtcs[i]);
			if (ci == NULL)
				continue;
			if (ci->noutput == 0) {
				XRRFreeCrtcInfo(ci);
				continue;
			}

			rc = xmalloc(sizeof(*rc));
			rc->num = i;
			rc->area.x = ci->x;
			rc->area.y = ci->y;
			rc->area.w = ci->width;
			rc->area.h = ci->height;
			rc->view.x = ci->x;
			rc->view.y = ci->y;
			rc->view.w = ci->width;
			rc->view.h = ci->height;
			rc->work = screen_apply_gap(sc, rc->view);
			TAILQ_INSERT_TAIL(&sc->regionq, rc, entry);

			XRRFreeCrtcInfo(ci);
		}
		XRRFreeScreenResources(sr);
	} else {
		rc = xmalloc(sizeof(*rc));
		rc->num = 0;
		rc->view.x = 0;
		rc->view.y = 0;
		rc->view.w = DisplayWidth(X_Dpy, sc->which);
		rc->view.h = DisplayHeight(X_Dpy, sc->which);
		rc->work = screen_apply_gap(sc, rc->view);
		TAILQ_INSERT_TAIL(&sc->regionq, rc, entry);
	}

	xu_ewmh_net_desktop_geometry(sc);
	xu_ewmh_net_workarea(sc);
}

struct geom
screen_apply_gap(struct screen_ctx *sc, struct geom geom)
{
	geom.x += sc->gap.left;
	geom.y += sc->gap.top;
	geom.w -= (sc->gap.left + sc->gap.right);
	geom.h -= (sc->gap.top + sc->gap.bottom);

	return(geom);
}

/* Bring back clients which are beyond the screen. */
void
screen_assert_clients_within(struct screen_ctx *sc)
{
	struct client_ctx	*cc;
	int			 top, left, right, bottom;

	TAILQ_FOREACH(cc, &sc->clientq, entry) {
		if (cc->sc != sc)
			continue;
		top = cc->geom.y;
		left = cc->geom.x;
		right = cc->geom.x + cc->geom.w + (cc->bwidth * 2) - 1;
		bottom = cc->geom.y + cc->geom.h + (cc->bwidth * 2) - 1;
		if ((top > sc->view.h || left > sc->view.w) ||
		    (bottom < 0 || right < 0)) {
			cc->geom.x = sc->gap.left;
			cc->geom.y = sc->gap.top;
			client_move(cc);
		}
	}
}
@


1.83
log
@Refactor callbacks to take a void * so as to not try and generalize into
client_ctx in keypress and buttonpress event handlers; pass appropriate *ctx's
based on context.

While here, limit some globals, replace defines with appropriate variables and
fix some naming.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.82 2016/10/04 20:15:55 okan Exp $
d104 1
a104 1
	warnx("screen_find failure win 0x%lu\n", win);
@


1.82
log
@When removing xrandr regions, ensure clients are within the bounds of
the screen; adapted from an ancient diff from Sviatoslav Chagaev. Things
in this area will likely change, but put this in so it works now and
serves as a reminder.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.81 2016/10/04 15:18:20 okan Exp $
d87 1
a87 1
	if (HasRandr)
d143 1
a143 1
screen_area(struct screen_ctx *sc, int x, int y, int flags)
d155 1
a155 1
	if (flags & CWM_GAP)
d176 1
a176 1
	if (HasRandr) {
@


1.81
log
@Turn CALMWM_NGROUPS define into variable, ngroups.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.80 2016/09/16 14:32:02 okan Exp $
d231 23
@


1.80
log
@During init, query screen for _NET_ACTIVE_WINDOW and set that client as
active; while we already look at what's under the pointer, use this
information first, then look under the pointer (saving that round-trip).
This restores the active state to a client after restart even if the
pointer is not above it (and of course the pointer is not above another
client).
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.79 2015/11/11 14:22:01 okan Exp $
d60 1
a60 1
	for (i = 0; i < CALMWM_NGROUPS; i++)
@


1.79
log
@Partial revert of replacing screen_area() with region_find(); until a
fix for a regression is found; this bug has been around for a long time
it seems, but this change exposed it. Likely need to track clients in to
and out of regions.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.78 2015/11/09 20:03:30 okan Exp $
d38 1
a38 1
	Window			*wins, w0, w1;
d68 1
d81 1
a81 1
			(void)client_init(wins[i], sc);
@


1.78
log
@Extend region to include both view and work areas; switch to
region_find() which no longer needs to recalculate gap each time
a client (or menu) is created or altered. If no RandR, fall back
to display dimensions while building regions instead of during
execution.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.77 2015/08/21 16:52:37 okan Exp $
d141 18
d192 4
@


1.77
log
@Fix whitespace.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.76 2015/06/30 14:01:43 okan Exp $
d127 2
a128 2
struct geom
screen_area(struct screen_ctx *sc, int x, int y, int flags)
a130 1
	struct geom		 area = sc->work;
d133 2
a134 3
		if ((x >= rc->area.x) && (x < (rc->area.x + rc->area.w)) &&
		    (y >= rc->area.y) && (y < (rc->area.y + rc->area.h))) {
			area = rc->area;
d138 1
a138 3
	if (flags & CWM_GAP)
		area = screen_apply_gap(sc, area);
	return(area);
a144 1
	int			 i;
a149 1

d160 1
d174 5
a178 4
			rc->area.x = ci->x;
			rc->area.y = ci->y;
			rc->area.w = ci->width;
			rc->area.h = ci->height;
d184 9
@


1.76
log
@Re-implement XClientMessage handling so that we can feed screen_find and
client_find valid resources as needed, relieving the need for
screen_find to ungracefully handle invalid root windows. Removes a long
standing XXX.  Should theoretically allow XClientMessage handling on
more than one X screen.  Alter callers of screen_find to handle
failures.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.75 2015/06/26 18:54:25 okan Exp $
d70 3
a72 3
	rootattr.event_mask = SubstructureRedirectMask|SubstructureNotifyMask|
	    PropertyChangeMask|EnterWindowMask|LeaveWindowMask|
	    ColormapChangeMask|BUTTONMASK;
d75 1
a75 1
	    CWEventMask|CWCursor, &rootattr);
@


1.75
log
@region is a _ctx, so name it so
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.74 2015/06/26 17:17:46 okan Exp $
d103 2
a104 2
	/* XXX FAIL HERE */
	return(TAILQ_FIRST(&Screenq));
@


1.74
log
@Mechanical change from xinerama to region backed areas.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.73 2015/06/26 16:11:21 okan Exp $
d130 1
a130 1
	struct region_ctx	*region;
d133 4
a136 4
	TAILQ_FOREACH(region, &sc->regionq, entry) {
		if (x >= region->area.x && x < region->area.x+region->area.w &&
		    y >= region->area.y && y < region->area.y+region->area.h) {
			area = region->area;
d148 1
a148 1
	struct region_ctx	*region;
d158 3
a160 3
	while ((region = TAILQ_FIRST(&sc->regionq)) != NULL) {
		TAILQ_REMOVE(&sc->regionq, region, entry);
		free(region);
d177 7
a183 7
			region = xmalloc(sizeof(*region));
			region->num = i;
			region->area.x = ci->x;
			region->area.y = ci->y;
			region->area.w = ci->width;
			region->area.h = ci->height;
			TAILQ_INSERT_TAIL(&sc->regionq, region, entry);
@


1.73
log
@collect 'gap' applications
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.72 2015/06/26 15:21:58 okan Exp $
a126 3
/*
 * Find which xinerama screen the coordinates (x,y) is on.
 */
d128 1
a128 1
screen_find_xinerama(struct screen_ctx *sc, int x, int y, int flags)
d131 1
a131 1
	struct geom		 geom = sc->work;
d136 1
a136 1
			geom = region->area;
d141 2
a142 2
		geom = screen_apply_gap(sc, geom);
	return(geom);
@


1.72
log
@Replace screen region info gathering with XRandR equivalent of Xinerama
queries (currently act on XRandR events anyway). Fall-back mode without
XRandR is still what X provides. This removes -lXinerama.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.71 2015/01/19 14:54:16 okan Exp $
d143 2
a144 6
	if (flags & CWM_GAP) {
		geom.x += sc->gap.left;
		geom.y += sc->gap.top;
		geom.w -= (sc->gap.left + sc->gap.right);
		geom.h -= (sc->gap.top + sc->gap.bottom);
	}
d159 1
a159 4
	sc->work.x = sc->view.x + sc->gap.left;
	sc->work.y = sc->view.y + sc->gap.top;
	sc->work.w = sc->view.w - (sc->gap.left + sc->gap.right);
	sc->work.h = sc->view.h - (sc->gap.top + sc->gap.bottom);
d195 11
@


1.71
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.70 2014/10/08 15:31:01 okan Exp $
a154 1
	XineramaScreenInfo	*info = NULL;
d156 1
a156 1
	int			 info_num = 0, i;
a167 4
	/* RandR event may have a CTRC added or removed. */
	if (XineramaIsActive(X_Dpy))
		info = XineramaQueryScreens(X_Dpy, &info_num);

d172 26
a197 8
	for (i = 0; i < info_num; i++) {
		region = xmalloc(sizeof(*region));
		region->num = i;
		region->area.x = info[i].x_org;
		region->area.y = info[i].y_org;
		region->area.w = info[i].width;
		region->area.h = info[i].height;
		TAILQ_INSERT_TAIL(&sc->regionq, region, entry);
a198 2
	if (info)
		XFree(info);
@


1.70
log
@no need for calloc(1,.. here, malloc is fine since we initialize
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.69 2014/10/08 12:48:51 okan Exp $
d21 1
a21 1
#include <sys/param.h>
d26 1
@


1.69
log
@make group_init work like other *_init's
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.68 2014/09/23 13:45:48 okan Exp $
d41 1
a41 1
	sc = xcalloc(1, sizeof(*sc));
d51 1
@


1.68
log
@Move stuff that doesn't belong in group_init; while here, explicitly
initialize hideall and cycling.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.67 2014/09/08 20:11:22 okan Exp $
d57 3
a59 1
	group_init(sc);
@


1.67
log
@Remove duplicate client queue (mruq); instead, remove and take the
global Clientq and place it inside screen_ctx since every client belongs
to a screen, then use the same per screen clientq to track stacking
order (the sole reason for mruq).
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.66 2014/09/07 19:27:30 okan Exp $
d45 1
d49 2
d58 6
@


1.66
log
@more style nits
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.65 2014/09/07 17:38:38 okan Exp $
d43 1
a43 1
	TAILQ_INIT(&sc->mruq);
@


1.65
log
@screen_fromroot -> screen_find
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.64 2014/08/24 15:37:45 okan Exp $
d86 1
a86 1
	TAILQ_FOREACH(sc, &Screenq, entry)
d88 2
a89 2
			return (sc);

d91 1
a91 1
	return (TAILQ_FIRST(&Screenq));
d136 1
a136 1
	return (geom);
@


1.64
log
@gc->hidden has never consistently kept track of a group's state;
group_show() and group_hide() are not the only ways a group can change
state - if all clients in a group are either hidden or unhidden, then
that group's state should change, as well as the various EWMH ways.
Instead of trying to keep track in a wide variety of places, simply
query the clients in a group before needing to take action based on the
group's state.  Solves long standing confusion of when a group is hidden
or not.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.63 2014/08/20 15:15:29 okan Exp $
d82 1
a82 1
screen_fromroot(Window rootwin)
d87 1
a87 1
		if (sc->rootwin == rootwin)
@


1.63
log
@Purely mechanical; unify 'num', 'no' and 'shortcut'.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.62 2014/08/20 12:35:39 okan Exp $
a71 1
	group_set_state(sc);
@


1.62
log
@whitespace
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.61 2014/02/08 02:49:30 okan Exp $
d145 1
a145 1
	int			 info_no = 0, i;
d159 1
a159 1
		info = XineramaQueryScreens(X_Dpy, &info_no);
d165 1
a165 1
	for (i = 0; i < info_no; i++) {
@


1.61
log
@Make sure we cycle through existing client's group membership and set
the hidden state on the group; important to know group hidden state
after a re-exec or restart of cwm (as easily seen in group menu).
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.60 2014/02/03 21:07:47 okan Exp $
d108 1
a108 1
	
@


1.60
log
@Introduce a region queue and replace screen's XineramaScreenInfo; we
still use Xinerama to populate the regions per screen, but will switch
at a more appropriate time.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.59 2014/02/03 20:29:05 okan Exp $
d72 1
@


1.59
log
@make this XQueryTree like the other
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.58 2014/02/03 20:20:39 okan Exp $
d44 1
d120 7
a126 17
	XineramaScreenInfo	*info;
	struct geom		 geom;
	int			 i;

	geom = sc->work;

	if (sc->xinerama == NULL)
		return (geom);

	for (i = 0; i < sc->xinerama_no; i++) {
		info = &sc->xinerama[i];
		if (x >= info->x_org && x < info->x_org + info->width &&
		    y >= info->y_org && y < info->y_org + info->height) {
			geom.x = info->x_org;
			geom.y = info->y_org;
			geom.w = info->width;
			geom.h = info->height;
d143 2
a144 1
	int			 info_no = 0;
d159 16
a174 4
	if (sc->xinerama != NULL)
		XFree(sc->xinerama);
	sc->xinerama = info;
	sc->xinerama_no = info_no;
@


1.58
log
@Move redundant bits from screen_init (while dealing with existing
clients) directly into client_init, performing the X roundtrip only
once. With the previous change in maprequest, this moves decision making
into one place for creating new clients.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.57 2014/02/02 16:29:04 okan Exp $
d100 10
a109 10
	if (!XQueryTree(X_Dpy, sc->rootwin, &w0, &w1, &wins, &nwins))
		return;

	for (s = 0, i = 0; i < nwins; i++) {
		/* Skip hidden windows */
		if ((cc = client_find(wins[i])) == NULL ||
		    cc->flags & CLIENT_HIDDEN)
			continue;

		cc->stackingorder = s++;
a110 2

	XFree(wins);
@


1.57
log
@No need to store screen colormap and visual; rather just use the X
macros in the one place they are needed.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.56 2014/02/02 16:13:50 okan Exp $
a37 1
	XWindowAttributes	 winattr;
d64 5
a68 7
	XQueryTree(X_Dpy, sc->rootwin, &w0, &w1, &wins, &nwins);
	for (i = 0; i < nwins; i++) {
		XGetWindowAttributes(X_Dpy, wins[i], &winattr);
		if (winattr.override_redirect ||
		    winattr.map_state != IsViewable)
			continue;
		(void)client_init(wins[i], sc, winattr.map_state != IsUnmapped);
a69 3
	if (wins)
		XFree(wins);

@


1.56
log
@Unlike free(3), XFree(3) can't be passed a NULL pointer.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.55 2014/01/27 15:13:09 okan Exp $
a46 2
	sc->visual = DefaultVisual(X_Dpy, sc->which);
	sc->colormap = DefaultColormap(X_Dpy, sc->which);
@


1.55
log
@move some init up and shed some blank lines
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.54 2014/01/03 15:29:06 okan Exp $
a67 1

d75 2
a76 1
	XFree(wins);
@


1.54
log
@use consistent types
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.53 2013/12/13 22:39:13 okan Exp $
d44 2
d50 1
a54 2
	conf_screen(sc);

a55 3

	TAILQ_INIT(&sc->mruq);

@


1.53
log
@Teach screen_find_xinerama() to apply gap only when told to do so;
adjust callers.  Needed for an upcoming feature.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.52 2013/06/17 17:11:10 okan Exp $
d40 1
a40 1
	u_int			 nwins, i;
d108 1
a108 1
	u_int			 nwins, i, s;
@


1.52
log
@move Cursors into conf.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.51 2013/05/20 20:21:04 okan Exp $
d129 1
a129 1
screen_find_xinerama(struct screen_ctx *sc, int x, int y)
d144 4
a147 4
			geom.x = info->x_org + sc->gap.left;
			geom.y = info->y_org + sc->gap.top;
			geom.w = info->width - (sc->gap.left + sc->gap.right);
			geom.h = info->height - (sc->gap.top + sc->gap.bottom);
d150 6
@


1.51
log
@- configure menuwin with the screen, then create the xft drawable using
  the menu window since that's the only place on which we draw
- elminate the need to change the drawable on every font draw
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.50 2013/05/11 22:01:07 okan Exp $
d60 1
a60 1
	rootattr.cursor = Cursor_normal;
@


1.50
log
@new -> init
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.49 2013/05/11 21:46:27 okan Exp $
a58 1
	menu_init(sc);
@


1.49
log
@replace conf_{gap,color,font} with conf_screen since really we are
configuring the screen *after* parsing, just as we do a conf_client on
client manage.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.48 2013/04/30 21:12:20 okan Exp $
d77 1
a77 1
		(void)client_new(wins[i], sc, winattr.map_state != IsUnmapped);
@


1.48
log
@group conf_* init functions
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.47 2013/04/29 00:56:48 okan Exp $
d52 1
a52 3
	conf_gap(&Conf, sc);
	conf_color(&Conf, sc);
	conf_font(&Conf, sc);
@


1.47
log
@use an int in screen_init and avoid needing to cast for screen number (which).
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.46 2013/04/12 14:46:30 okan Exp $
d53 2
d58 1
a58 1
	conf_color(&Conf, sc);
a60 4
	conf_font(&Conf, sc);

	TAILQ_INIT(&sc->mruq);

@


1.46
log
@push Screenq into screen_init
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.45 2013/01/08 04:12:51 okan Exp $
d34 1
a34 1
screen_init(u_int which)
@


1.45
log
@teach screen_find_xinerama() about gap and adjust (simplify) callers;
menu becomes gap-aware for free.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.44 2013/01/07 21:45:24 okan Exp $
d34 1
a34 1
screen_init(struct screen_ctx *sc, u_int which)
d36 1
d42 2
d89 2
@


1.44
log
@revert previous
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.43 2013/01/07 20:32:19 okan Exp $
d135 1
a135 1
	geom = sc->view;
d144 4
a147 4
			geom.x = info->x_org;
			geom.y = info->y_org;
			geom.w = info->width;
			geom.h = info->height;
@


1.43
log
@unbreak xinerama support from r1.41 for panning setups
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.42 2013/01/02 18:11:23 okan Exp $
d146 2
a147 2
			geom.w = info->x_org + info->width;
			geom.h = info->y_org + info->height;
@


1.42
log
@merge in Xinerama screen query; no functional change.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.41 2013/01/02 16:26:34 okan Exp $
d146 2
a147 2
			geom.w = info->width;
			geom.h = info->height;
@


1.41
log
@have screen_find_xinerama() return struct geom *reliably* instead of
XineramaScreenInfo; simplifies goop around the callers.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.40 2012/12/18 18:39:55 okan Exp $
a32 2
static void	 screen_init_xinerama(struct screen_ctx *);

a125 19
 * If we're using RandR then we'll redo this whenever the screen
 * changes since a CTRC may have been added or removed
 */
void
screen_init_xinerama(struct screen_ctx *sc)
{
	XineramaScreenInfo	*info = NULL;
	int			 no = 0;

	if (XineramaIsActive(X_Dpy))
		info = XineramaQueryScreens(X_Dpy, &no);

	if (sc->xinerama != NULL)
		XFree(sc->xinerama);
	sc->xinerama = info;
	sc->xinerama_no = no;
}

/*
d157 3
d170 7
a176 1
	screen_init_xinerama(sc);
@


1.40
log
@expand CHILDMASK
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.39 2012/12/17 18:34:06 okan Exp $
d149 1
a149 1
XineramaScreenInfo *
d153 1
d156 2
d159 1
a159 1
		return (NULL);
d164 7
a170 2
		    y >= info->y_org && y < info->y_org + info->height)
			return (info);
d172 1
a172 1
	return (NULL);
@


1.39
log
@stash the default screen visual and colormap in screen_ctx
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.38 2012/11/29 03:54:46 okan Exp $
d65 3
a67 2
	rootattr.event_mask = CHILDMASK|PropertyChangeMask|EnterWindowMask|
	    LeaveWindowMask|ColormapChangeMask|BUTTONMASK;
@


1.38
log
@x_setupscreen -> screen_init; no functional change.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.37 2012/11/09 03:52:02 okan Exp $
d44 2
@


1.37
log
@sort
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.36 2012/07/18 21:53:22 okan Exp $
d34 54
@


1.36
log
@Further simplify Xinerama init and re-init on XRR events.

While testing for Xinerama during setup was done display-wide, each time
XineramaQueryScreens() is called either in start-up or due to an XRR
event, the library re-tests for the Xinerama extension anyway before
moving on; so the initial test is redundant and allows another global to
go away with one other change: always fill in sc->xinerama (and _no),
regardless of the success of malloc in XineramaQueryScreens(), and use
it to see if Xinerama dimensions exist when asked by client and/or menu
code.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.35 2012/07/16 01:42:00 okan Exp $
d26 1
a28 1
#include <stdio.h>
@


1.35
log
@check value
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.34 2012/07/16 01:36:31 okan Exp $
d77 2
a78 7
	XineramaScreenInfo	*info;
	int			 no;

	if (HasXinerama == 0 || XineramaIsActive(X_Dpy) == 0) {
		HasXinerama = 0;
		sc->xinerama_no = 0;
	}
d80 2
a81 7
	info = XineramaQueryScreens(X_Dpy, &no);
	if (info == NULL) {
		/* Is xinerama actually off, instead of a malloc failure? */
		if (sc->xinerama == NULL)
			HasXinerama = 0;
		return;
	}
d98 1
a98 1
	if (HasXinerama == 0)
@


1.34
log
@move the HasXinerama check into screen_find_xinerama and simplify logic;
moves closer to logic in menu code.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.33 2012/07/13 15:21:35 okan Exp $
d108 1
a108 1
	if (HasXinerama = 0)
@


1.33
log
@convert xmax/ymax uses to view geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.32 2012/07/13 14:18:04 okan Exp $
d107 3
@


1.32
log
@introduce screen "view" area and "work" area (gap applied) to simplify
various blocks that require understanding the screen geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.31 2012/07/06 14:18:00 okan Exp $
a119 3
	sc->xmax = DisplayWidth(X_Dpy, sc->which);
	sc->ymax = DisplayHeight(X_Dpy, sc->which);

@


1.31
log
@querying for Xinerama should be done per display, not per screen, so
move chuck to display init; allows some shuffling to occur limiting
screen_init_xinerama()'s scope while keeping order intact.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.30 2012/07/05 17:35:13 okan Exp $
d122 10
@


1.30
log
@the display's width and height are updated after an XRandR event so we
don't need to pass down the new values to screen_update_geometry(); so
just read the width/height values directly for both uses of
screen_update_geometry().  prep for further changes in this area.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.29 2012/07/03 13:49:03 okan Exp $
d33 2
d70 4
d122 2
@


1.29
log
@re-implement atom handing; makes for a normalized and more consistent
separation between cwm and ewmh.  seen by a few.
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.28 2011/05/11 13:53:51 okan Exp $
d112 1
a112 1
screen_update_geometry(struct screen_ctx *sc, int width, int height)
d114 2
a115 2
	sc->xmax = width;
	sc->ymax = height;
@


1.28
log
@tag and comment cleanup; ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: screen.c,v 1.27 2011/03/22 10:54:42 okan Exp $
d114 2
a115 2
	long	 geom[2], workareas[CALMWM_NGROUPS][4];
	int	 i;
d117 2
a118 16
	sc->xmax = geom[0] = width;
	sc->ymax = geom[1] = height;
	XChangeProperty(X_Dpy, sc->rootwin, _NET_DESKTOP_GEOMETRY,
	    XA_CARDINAL, 32, PropModeReplace, (unsigned char *)geom , 2);

	/* x, y, width, height. */
	for (i = 0; i < CALMWM_NGROUPS; i++) {
		workareas[i][0] = sc->gap.left;
		workareas[i][1] = sc->gap.top;
		workareas[i][2] = width - (sc->gap.left + sc->gap.right);
		workareas[i][3] = height - (sc->gap.top + sc->gap.bottom);
	}

	XChangeProperty(X_Dpy, sc->rootwin, _NET_WORKAREA,
	    XA_CARDINAL, 32, PropModeReplace,
	    (unsigned char *)workareas, CALMWM_NGROUPS * 4);
@


1.27
log
@(0,0) is also inside in the screen; from Sviatoslav Chagaev.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.26 2010/01/27 03:04:50 okan Exp $
@


1.26
log
@- allow per-screen gap; not (yet) user configurable.
- teach _NET_WORKAREA about gap.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.25 2009/12/15 04:10:42 okan Exp $
d104 2
a105 2
		if (x > info->x_org && x < info->x_org + info->width &&
		    y > info->y_org && y < info->y_org + info->height)
@


1.25
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.24 2009/12/15 03:24:36 okan Exp $
d122 1
a122 1
	/* x, y, width, height. XXX gap */
d124 4
a127 4
		workareas[i][0] = 0;
		workareas[i][1] = 0;
		workareas[i][2] = width;
		workareas[i][3] = height;
@


1.24
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.23 2009/12/11 18:09:16 oga Exp $
d20 10
@


1.23
log
@add _NET_WORKAREA. for now we ignore the gap, this'll change soonish.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.22 2009/12/11 17:57:38 oga Exp $
a20 1
#include "headers.h"
@


1.22
log
@another int/long fixup that was giving dodgy property values on amd64, shame on
me for not reading xlibs (appauling) documentation more closely.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.21 2009/12/10 23:14:58 oga Exp $
d105 2
a106 1
	long	geom[2];
d112 12
@


1.21
log
@Implement _NET_CURRENT_DESKTOP, _NET_DESKTOP_VIEWPORT and
_NET_DESKTOP_GEOMETRY.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.20 2009/12/10 17:16:51 oga Exp $
d105 1
a105 1
	int	geom[2];
@


1.20
log
@finish unfucking the screen_ctx handling.

remove screen_current() it was utterly bogus when nscreens > 1.

pass a fake client_ctx in the case where there's no client and the
kbfunc or mousefunc doesn't need a real one, it just contains the
current screen, modify these functions so that they pass down the screen
context to their callees.

make groups per screen, it's the only way it makes sense in this regard.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.19 2009/11/28 17:52:12 tobias Exp $
d100 11
@


1.19
log
@style (whitespaces)

ok oga, okan
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.18 2009/11/22 21:38:50 tobias Exp $
a23 2
extern struct screen_ctx	*Curscreen;

a36 6
struct screen_ctx *
screen_current(void)
{
	return (Curscreen);
}

d38 1
a38 1
screen_updatestackingorder(void)
a40 1
	struct screen_ctx	*sc;
a42 2

	sc = screen_current();
@


1.18
log
@Corrected grammar in comment.

ok (and better style suggestion by) oga, okan
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.17 2009/08/24 21:22:48 oga Exp $
d80 1
a80 1
		
@


1.17
log
@Instead of having a function that just calls TAILQ_INIT on a global, use
TAILQ_HEAD_INITIALIZER() and drop the function.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.16 2009/06/26 12:21:58 okan Exp $
d83 1
a83 1
		/*is xinerama is actually off, instead of a malloc failure? */
@


1.16
log
@static local functions and data; almost identical diff from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.15 2009/06/23 21:52:38 okan Exp $
a24 6

void
screen_init(void)
{
	TAILQ_INIT(&Screenq);
}
@


1.15
log
@tidy up startup/init routines

ok oga@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.14 2009/01/15 00:32:35 okan Exp $
a23 1
extern struct screen_ctx_q	 Screenq;
@


1.14
log
@- add missing prototypes.
- properly name, place and static private functions.
- move function which finds the xinerama screen for a coordinate to
a more appropriate place while altering its semantics to match others.
- tiny bit of style.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.13 2009/01/11 18:25:49 okan Exp $
d26 6
@


1.13
log
@remove unused variables

ok oga@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.12 2009/01/06 00:19:55 okan Exp $
d94 18
@


1.12
log
@HasXinerama is an int

ok oga@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.11 2008/09/29 23:16:46 oga Exp $
d74 2
a75 2
	XineramaScreenInfo *info;
	int no, fake;
@


1.11
log
@Xinerama and XRandR dual head support for cwm(1). Now we detect the xrandr
reconfiguration events and change our sizes depending on that. We also detect
the xinerama screens for maximize, vertmaximize and initial window placement.

This could be improved by automatically resizing maximized windows when
the screen resolution changes and by moving windows that would be hidden
into visible space. Said changes will come shortly.

Tested by many. matthieu@@ didn't oppose.
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.10 2008/09/22 14:28:04 oga Exp $
d86 1
a86 1
			HasXinerama = NULL;
@


1.10
log
@*sigh* Revert the diff that wasn't meant to go in yet.

note to self: When you mean to type cvs commit search.c, don't forget
the filename.
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.8 2008/07/22 19:54:57 oga Exp $
d69 25
@


1.9
log
@Display the current window title not a previous one in the case of
``show all'' in the window search dialogue. Noticed and diff from Tim
van der Molen, thanks!
@
text
@a69 25

void
screen_init_xinerama(struct screen_ctx *sc)
{
	XineramaScreenInfo *info;
	int no, fake;

	if (HasXinerama == 0 || XineramaIsActive(X_Dpy) == 0) {
		HasXinerama = 0;
		sc->xinerama_no = 0;
	}
		
	info = XineramaQueryScreens(X_Dpy, &no);
	if (info == NULL) {
		/*is xinerama is actually off, instead of a malloc failure? */
		if (sc->xinerama == NULL)
			HasXinerama = NULL;
		return;
	}

	if (sc->xinerama != NULL)
		XFree(sc->xinerama);
	sc->xinerama = info;
	sc->xinerama_no = no;
}
@


1.8
log
@Kill screen_init(). it's been stubbed out for a while now. I don't envision it
coming back in it's current form.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.7 2008/07/11 14:21:28 okan Exp $
d69 25
@


1.7
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.6 2008/05/01 18:01:13 oga Exp $
a68 5
}

void
screen_init(void)
{
@


1.6
log
@Rework the alt-tabbing code to be a lot simpler.

Diff mostly from Edd Barrett, with some minor changes from me.
Unfortunately the issue where apps like gvim and xpdf are stealing
keyrelease events causing the ordering to be messed up, but this is a
lot better. A fix for the aforementioned issue shall be forthcoming,
once a good one's been found.

ok okan@@, also tested by todd@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.5 2008/04/16 13:35:37 oga Exp $
d30 1
a30 1
	struct screen_ctx *sc;
d49 6
a54 4
	Window *wins, w0, w1;
	struct screen_ctx *sc = screen_current();
	u_int nwins, i, s;
	struct client_ctx *cc;
@


1.5
log
@Remove screen_infomsg(), nothing uses it.

ok okan.
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.4 2008/04/15 20:24:41 oga Exp $
a71 3
	struct screen_ctx *sc = screen_current();

	sc->cycle_client = NULL;
@


1.4
log
@hit it with the knf stick.
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.3 2008/01/11 16:06:44 oga Exp $
a26 7
static void
_clearwindow_cb(int sig)
{
	struct screen_ctx *sc = screen_current();
	XUnmapWindow(X_Dpy, sc->infowin);
}

a74 31

	sc->infowin = XCreateSimpleWindow(X_Dpy, sc->rootwin, 0, 0,
	    1, 1, 1, sc->blackpixl, sc->whitepixl);

	/* XXX - marius. */
	if (signal(SIGALRM, _clearwindow_cb) == SIG_ERR)
		err(1, "signal");
}

void
screen_infomsg(char *msg)
{
	struct screen_ctx *sc = screen_current();
	char buf[1024];
	int dy, dx;
	struct fontdesc *font = DefaultFont;

	XUnmapWindow(X_Dpy, sc->infowin);
	alarm(0);

	snprintf(buf, sizeof(buf), ">%s", msg);
	dy = font_ascent(font) + font_descent(font) + 1;
	dx = font_width(font, buf, strlen(buf));

	XMoveResizeWindow(X_Dpy, sc->infowin, 0, 0, dx, dy);
	XMapRaised(X_Dpy, sc->infowin);

	font_draw(font, buf, strlen(buf), sc->infowin,
	    0, font_ascent(font) + 1);

	alarm(1);
@


1.3
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d18 1
a18 1
 * $Id: screen.c,v 1.2 2007/05/28 18:34:27 jasper Exp $
d24 2
a25 2
extern struct screen_ctx_q	Screenq;
extern struct screen_ctx       *Curscreen;
a78 1

@


1.2
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@a4 1
 * All rights reserved.
d6 13
a18 1
 * $Id: screen.c,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * $Id: screen.c,v 1.8 2005/08/28 09:46:33 marius Exp $
d13 2
a14 2
extern struct screen_ctx_q	G_screenq;
extern struct screen_ctx       *G_curscreen;
d20 1
a20 1
	XUnmapWindow(G_dpy, sc->infowin);
d28 1
a28 1
	TAILQ_FOREACH(sc, &G_screenq, entry)
d33 1
a33 1
	return (TAILQ_FIRST(&G_screenq));
d39 1
a39 1
	return (G_curscreen);
d50 1
a50 1
	if (!XQueryTree(G_dpy, sc->rootwin, &w0, &w1, &wins, &nwins))
d73 1
a73 1
	sc->infowin = XCreateSimpleWindow(G_dpy, sc->rootwin, 0, 0,
d89 1
a89 1
	XUnmapWindow(G_dpy, sc->infowin);
d96 2
a97 2
	XMoveResizeWindow(G_dpy, sc->infowin, 0, 0, dx, dy);
	XMapRaised(G_dpy, sc->infowin);
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
