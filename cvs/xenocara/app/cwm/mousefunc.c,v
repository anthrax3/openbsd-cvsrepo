head	1.115;
access;
symbols
	OPENBSD_6_1:1.115.0.2
	OPENBSD_6_1_BASE:1.115
	OPENBSD_6_0:1.103.0.4
	OPENBSD_6_0_BASE:1.103
	OPENBSD_5_9:1.103.0.2
	OPENBSD_5_9_BASE:1.103
	OPENBSD_5_8:1.96.0.2
	OPENBSD_5_8_BASE:1.96
	OPENBSD_5_7:1.86.0.2
	OPENBSD_5_7_BASE:1.86
	OPENBSD_5_6:1.71.0.4
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.71.0.2
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.56.0.2
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.37.0.2
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.6
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.12.0.2
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.115
date	2016.12.06.21.03.58;	author okan;	state Exp;
branches;
next	1.114;
commitid	fDcegTCHdXdkSSZG;

1.114
date	2016.10.18.17.03.30;	author okan;	state Exp;
branches;
next	1.113;
commitid	dIOrHVlb55Ubzrpl;

1.113
date	2016.10.06.14.41.19;	author okan;	state Exp;
branches;
next	1.112;
commitid	dEdTnOYrabSl1oRa;

1.112
date	2016.10.03.13.52.18;	author okan;	state Exp;
branches;
next	1.111;
commitid	NuJTywreZ210kHEh;

1.111
date	2016.09.30.18.28.06;	author okan;	state Exp;
branches;
next	1.110;
commitid	STecP6DPl2bavnIv;

1.110
date	2016.09.30.15.12.19;	author okan;	state Exp;
branches;
next	1.109;
commitid	uC9f6GlGiQkjBS9C;

1.109
date	2016.09.30.15.05.02;	author okan;	state Exp;
branches;
next	1.108;
commitid	mvWRaHVZ6d8Fddsw;

1.108
date	2016.09.29.00.21.55;	author okan;	state Exp;
branches;
next	1.107;
commitid	T0a7tiQalU2SO4pS;

1.107
date	2016.09.28.17.06.33;	author okan;	state Exp;
branches;
next	1.106;
commitid	UDBUlJ5kvU8CcYZj;

1.106
date	2016.09.28.15.54.54;	author okan;	state Exp;
branches;
next	1.105;
commitid	EKpEuatQs7y0mcxD;

1.105
date	2016.09.22.14.36.03;	author okan;	state Exp;
branches;
next	1.104;
commitid	ITo2h4srkSgvGLD0;

1.104
date	2016.09.13.13.42.28;	author okan;	state Exp;
branches;
next	1.103;
commitid	hFum1P2hF0CvKK9F;

1.103
date	2015.11.17.14.31.28;	author okan;	state Exp;
branches;
next	1.102;
commitid	PC4kqUfT6r7UF4x0;

1.102
date	2015.11.11.14.22.01;	author okan;	state Exp;
branches;
next	1.101;
commitid	t4AzuTxPlqQ6EzqO;

1.101
date	2015.11.10.22.06.57;	author okan;	state Exp;
branches;
next	1.100;
commitid	myf490V0gA4R6hn2;

1.100
date	2015.11.10.20.05.33;	author okan;	state Exp;
branches;
next	1.99;
commitid	vKzF5zXTpUgY9uJK;

1.99
date	2015.11.09.20.03.30;	author okan;	state Exp;
branches;
next	1.98;
commitid	9uKgpfLzKiBWmiSm;

1.98
date	2015.08.21.16.14.39;	author okan;	state Exp;
branches;
next	1.97;
commitid	SoqEvJwZGG56KptJ;

1.97
date	2015.08.21.16.05.55;	author okan;	state Exp;
branches;
next	1.96;
commitid	1r39soX8fGqXiSh3;

1.96
date	2015.07.12.14.31.47;	author okan;	state Exp;
branches;
next	1.95;
commitid	vbdA9GL2PIvC62Ws;

1.95
date	2015.07.01.14.36.42;	author okan;	state Exp;
branches;
next	1.94;
commitid	HEkKIvh6L9ijX1lH;

1.94
date	2015.06.30.19.02.24;	author okan;	state Exp;
branches;
next	1.93;
commitid	l7rItG5t6FzbOpiD;

1.93
date	2015.06.30.18.54.12;	author okan;	state Exp;
branches;
next	1.92;
commitid	BFKdrINXu4OZsfXB;

1.92
date	2015.06.26.17.17.46;	author okan;	state Exp;
branches;
next	1.91;
commitid	lHlj3PDNu98waqIr;

1.91
date	2015.06.08.15.41.27;	author okan;	state Exp;
branches;
next	1.90;
commitid	rIigjcpDTtgZpGbn;

1.90
date	2015.06.08.15.11.29;	author okan;	state Exp;
branches;
next	1.89;
commitid	ZvSEr0vP6GhJmETT;

1.89
date	2015.06.07.19.10.00;	author okan;	state Exp;
branches;
next	1.88;
commitid	DuQBUgWvLWBQOJbB;

1.88
date	2015.06.05.15.01.51;	author okan;	state Exp;
branches;
next	1.87;
commitid	zeddTrrTnPr6FqHq;

1.87
date	2015.05.21.00.37.04;	author okan;	state Exp;
branches;
next	1.86;
commitid	8wlAl4DgmYSCpXux;

1.86
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.85;
commitid	kLADTGYX3gw0Sf2m;

1.85
date	2014.09.27.19.04.32;	author okan;	state Exp;
branches;
next	1.84;
commitid	X6SwRTs6gMlrxQ8N;

1.84
date	2014.09.18.13.56.58;	author okan;	state Exp;
branches;
next	1.83;
commitid	o6dOcclBJZcxbm3d;

1.83
date	2014.09.17.18.09.30;	author okan;	state Exp;
branches;
next	1.82;
commitid	vjYvS7lYE7I0AXkO;

1.82
date	2014.09.17.16.32.53;	author okan;	state Exp;
branches;
next	1.81;
commitid	VoKzpesV33vUCQZ7;

1.81
date	2014.09.17.14.31.37;	author okan;	state Exp;
branches;
next	1.80;
commitid	PntP0xZYNorE93in;

1.80
date	2014.09.08.21.15.14;	author okan;	state Exp;
branches;
next	1.79;
commitid	os8IEZxNKyVrOZR1;

1.79
date	2014.09.08.20.11.22;	author okan;	state Exp;
branches;
next	1.78;
commitid	cu11ybsl8atTMRXD;

1.78
date	2014.09.08.13.51.29;	author okan;	state Exp;
branches;
next	1.77;
commitid	OmIn9iExEjTH79st;

1.77
date	2014.09.06.16.08.58;	author okan;	state Exp;
branches;
next	1.76;
commitid	hqjCXxcyI22RFKvg;

1.76
date	2014.09.02.14.08.39;	author okan;	state Exp;
branches;
next	1.75;
commitid	fmouNSuutoBeaTzg;

1.75
date	2014.09.01.18.17.32;	author okan;	state Exp;
branches;
next	1.74;
commitid	LaMeYyOZeKJqODV0;

1.74
date	2014.09.01.18.04.58;	author okan;	state Exp;
branches;
next	1.73;
commitid	X0CjpcmJsClz2NwK;

1.73
date	2014.08.22.19.04.00;	author okan;	state Exp;
branches;
next	1.72;
commitid	INCxCbmjnfOT88xa;

1.72
date	2014.08.20.15.15.29;	author okan;	state Exp;
branches;
next	1.71;
commitid	SsDu0AngUZExtrz4;

1.71
date	2014.02.07.21.59.56;	author okan;	state Exp;
branches;
next	1.70;

1.70
date	2014.01.30.14.40.21;	author okan;	state Exp;
branches;
next	1.69;

1.69
date	2014.01.29.22.30.00;	author okan;	state Exp;
branches;
next	1.68;

1.68
date	2014.01.20.22.31.53;	author okan;	state Exp;
branches;
next	1.67;

1.67
date	2014.01.20.21.34.32;	author okan;	state Exp;
branches;
next	1.66;

1.66
date	2014.01.20.18.58.03;	author okan;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.02.21.30.20;	author okan;	state Exp;
branches;
next	1.64;

1.64
date	2013.12.13.22.39.13;	author okan;	state Exp;
branches;
next	1.63;

1.63
date	2013.12.13.21.51.56;	author okan;	state Exp;
branches;
next	1.62;

1.62
date	2013.12.12.21.50.50;	author okan;	state Exp;
branches;
next	1.61;

1.61
date	2013.12.08.13.51.38;	author okan;	state Exp;
branches;
next	1.60;

1.60
date	2013.12.02.19.30.27;	author okan;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.27.18.34.34;	author okan;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.27.14.20.32;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.19.18.59.22;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2013.07.09.01.24.49;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2013.07.08.18.39.20;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2013.07.08.18.19.22;	author okan;	state Exp;
branches;
next	1.53;

1.53
date	2013.06.17.17.11.10;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2013.05.20.20.21.04;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.19.23.38.21;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2013.05.14.12.35.56;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2013.05.02.19.33.17;	author okan;	state Exp;
branches;
next	1.48;

1.48
date	2013.05.02.19.30.10;	author okan;	state Exp;
branches;
next	1.47;

1.47
date	2013.05.02.17.25.15;	author okan;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.08.15.43.04;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2013.04.08.13.02.31;	author okan;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.02.21.41.14;	author okan;	state Exp;
branches;
next	1.43;

1.43
date	2013.01.02.21.37.21;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2012.12.17.14.32.39;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2012.12.17.02.28.45;	author okan;	state Exp;
branches;
next	1.40;

1.40
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.39;

1.39
date	2012.11.07.20.34.39;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2012.09.09.19.47.47;	author okan;	state Exp;
branches;
next	1.37;

1.37
date	2012.07.13.17.01.04;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2012.07.13.15.21.35;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2012.07.04.23.42.03;	author okan;	state Exp;
branches;
next	1.34;

1.34
date	2011.10.17.18.18.38;	author okan;	state Exp;
branches;
next	1.33;

1.33
date	2011.09.03.09.42.33;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.25.15.10.24;	author okan;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.23.13.09.11;	author okan;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.24.06.09.26;	author okan;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.24.06.06.24;	author okan;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.24.05.51.25;	author okan;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.24.05.45.57;	author okan;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.13.12.53.19;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.07.17.15.37;	author okan;	state Exp;
branches;
next	1.23;

1.23
date	2011.05.05.19.52.52;	author okan;	state Exp;
branches;
next	1.22;

1.22
date	2011.03.23.07.27.32;	author okan;	state Exp;
branches;
next	1.21;

1.21
date	2011.03.22.10.59.08;	author okan;	state Exp;
branches;
next	1.20;

1.20
date	2010.12.14.11.08.47;	author martynas;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.10.17.16.51;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2009.12.08.16.52.17;	author okan;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.27.01.38.08;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2009.08.25.01.32.40;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.24.23.49.04;	author okan;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.20.00.55.42;	author okan;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.20.00.22.39;	author okan;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.17.12.45.01;	author okan;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.18.00.23.35;	author okan;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.15.14.10.07;	author okan;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.22.19.01.56;	author okan;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.16.15.24.14;	author okan;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.11.18.34.46;	author okan;	state Exp;
branches;
next	1.4;

1.4
date	2008.07.11.15.18.29;	author okan;	state Exp;
branches;
next	1.3;

1.3
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.25.22.44.42;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.14.21.48.54;	author okan;	state Exp;
branches;
next	;


desc
@@


1.115
log
@Now that dim.{x,y} are available early, use them before requiring a
MotionNotify event.
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 * Copyright (c) 2008 rivo nurges <rix@@estpak.ee>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: mousefunc.c,v 1.114 2016/10/18 17:03:30 okan Exp $
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

void
mousefunc_client_resize(void *ctx, union arg *arg, enum xev xev)
{
	struct client_ctx	*cc = ctx;
	XEvent			 ev;
	Time			 ltime = 0;
	struct screen_ctx	*sc = cc->sc;

	if (cc->flags & CLIENT_FREEZE)
		return;

	client_raise(cc);
	client_ptrsave(cc);

	xu_ptr_setpos(cc->win, cc->geom.w, cc->geom.h);

	if (XGrabPointer(X_Dpy, cc->win, False, MOUSEMASK,
	    GrabModeAsync, GrabModeAsync, None, Conf.cursor[CF_RESIZE],
	    CurrentTime) != GrabSuccess)
		return;

	menu_windraw(sc, cc->win, "%4d x %-4d", cc->dim.w, cc->dim.h);

	for (;;) {
		XWindowEvent(X_Dpy, cc->win, MOUSEMASK, &ev);

		switch (ev.type) {
		case MotionNotify:
			/* not more than 60 times / second */
			if ((ev.xmotion.time - ltime) <= (1000 / 60))
				continue;
			ltime = ev.xmotion.time;

			cc->geom.w = ev.xmotion.x;
			cc->geom.h = ev.xmotion.y;
			client_applysizehints(cc);
			client_resize(cc, 1);
			menu_windraw(sc, cc->win,
			    "%4d x %-4d", cc->dim.w, cc->dim.h);
			break;
		case ButtonRelease:
			client_resize(cc, 1);
			XUnmapWindow(X_Dpy, sc->menu.win);
			XReparentWindow(X_Dpy, sc->menu.win, sc->rootwin, 0, 0);
			XUngrabPointer(X_Dpy, CurrentTime);

			/* Make sure the pointer stays within the window. */
			if (cc->ptr.x > cc->geom.w)
				cc->ptr.x = cc->geom.w - cc->bwidth;
			if (cc->ptr.y > cc->geom.h)
				cc->ptr.y = cc->geom.h - cc->bwidth;
			client_ptrwarp(cc);
			return;
		}
	}
	/* NOTREACHED */
}

void
mousefunc_client_move(void *ctx, union arg *arg, enum xev xev)
{
	struct client_ctx	*cc = ctx;
	XEvent			 ev;
	Time			 ltime = 0;
	struct screen_ctx	*sc = cc->sc;
	struct geom		 area;
	int			 px, py;

	client_raise(cc);

	if (cc->flags & CLIENT_FREEZE)
		return;

	xu_ptr_getpos(cc->win, &px, &py);
	if (px < 0) 
		px = 0;
	else if (px > cc->geom.w)
		px = cc->geom.w;
	if (py < 0)
		py = 0;
	else if (py > cc->geom.h)
		py = cc->geom.h;

	xu_ptr_setpos(cc->win, px, py);

	if (XGrabPointer(X_Dpy, cc->win, False, MOUSEMASK,
	    GrabModeAsync, GrabModeAsync, None, Conf.cursor[CF_MOVE],
	    CurrentTime) != GrabSuccess)
		return;

	menu_windraw(sc, cc->win, "%4d, %-4d", cc->geom.x, cc->geom.y);

	for (;;) {
		XWindowEvent(X_Dpy, cc->win, MOUSEMASK, &ev);

		switch (ev.type) {
		case MotionNotify:
			/* not more than 60 times / second */
			if ((ev.xmotion.time - ltime) <= (1000 / 60))
				continue;
			ltime = ev.xmotion.time;

			cc->geom.x = ev.xmotion.x_root - px - cc->bwidth;
			cc->geom.y = ev.xmotion.y_root - py - cc->bwidth;

			area = screen_area(sc,
			    cc->geom.x + cc->geom.w / 2,
			    cc->geom.y + cc->geom.h / 2, CWM_GAP);
			cc->geom.x += client_snapcalc(cc->geom.x,
			    cc->geom.x + cc->geom.w + (cc->bwidth * 2),
			    area.x, area.x + area.w, sc->snapdist);
			cc->geom.y += client_snapcalc(cc->geom.y,
			    cc->geom.y + cc->geom.h + (cc->bwidth * 2),
			    area.y, area.y + area.h, sc->snapdist);
			client_move(cc);
			menu_windraw(sc, cc->win,
			    "%4d, %-4d", cc->geom.x, cc->geom.y);
			break;
		case ButtonRelease:
			client_move(cc);
			XUnmapWindow(X_Dpy, sc->menu.win);
			XReparentWindow(X_Dpy, sc->menu.win, sc->rootwin, 0, 0);
			XUngrabPointer(X_Dpy, CurrentTime);
			return;
		}
	}
	/* NOTREACHED */
}
@


1.114
log
@Refactor callbacks to take a void * so as to not try and generalize into
client_ctx in keypress and buttonpress event handlers; pass appropriate *ctx's
based on context.

While here, limit some globals, replace defines with appropriate variables and
fix some naming.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.113 2016/10/06 14:41:19 okan Exp $
d56 2
d124 2
@


1.113
log
@Add an argument to the callbacks to pass the xevent context, button or
key press. This allows to remove a few hacks to duplicate functions only
for behaviour changes; now differing behaviours are pushed down to the
callback. Also will allow for previously unavailable actions to be bind-able
down the road.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.112 2016/10/03 13:52:18 okan Exp $
d36 1
a36 1
mousefunc_client_resize(struct client_ctx *cc, union arg *arg, int xev)
d38 1
d92 1
a92 1
mousefunc_client_move(struct client_ctx *cc, union arg *arg, int xev)
d94 1
@


1.112
log
@For both kb and mouse move, it is possible to grab a client and move it
completely off the screen/region; instead, if the pointer is outside of
the client bounds, warp the pointer to the closest edge before moving.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.111 2016/09/30 18:28:06 okan Exp $
d36 1
a36 1
mousefunc_client_resize(struct client_ctx *cc, union arg *arg)
d91 1
a91 1
mousefunc_client_move(struct client_ctx *cc, union arg *arg)
@


1.111
log
@Use instinsic X11 functions for key/btn/ptr grab/ungrab/regrab requests;
the one line wrappers provided no value and limited altering calls where
needed; additionally, most of them had but one caller.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.110 2016/09/30 15:12:19 okan Exp $
d48 2
a54 2
	xu_ptr_setpos(cc->win, cc->geom.w, cc->geom.h);

d104 12
a119 2

	xu_ptr_getpos(cc->win, &px, &py);
@


1.110
log
@Replace mousefunc_sweep_draw() with a generic menu_windraw() using va
lists; use it appropriately for both window dimension and position in
the respective mousefunc calls.

ok bryent@@
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.109 2016/09/30 15:05:02 okan Exp $
d48 3
a50 1
	if (xu_ptr_grab(cc->win, MOUSEMASK, Conf.cursor[CF_RESIZE]) < 0)
d76 1
a76 1
			xu_ptr_ungrab();
d104 3
a106 1
	if (xu_ptr_grab(cc->win, MOUSEMASK, Conf.cursor[CF_MOVE]) < 0)
d141 1
a141 1
			xu_ptr_ungrab();
@


1.109
log
@Switch to XWindowEvent() pulling out events that match the mask *and*
window.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.108 2016/09/29 00:21:55 okan Exp $
a34 25
static void	mousefunc_sweep_draw(struct client_ctx *);

static void
mousefunc_sweep_draw(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	char			 s[14]; /* fits " nnnn x nnnn \0" */
	XGlyphInfo		 extents;

	(void)snprintf(s, sizeof(s), " %4d x %-4d ", cc->dim.w, cc->dim.h);

	XftTextExtentsUtf8(X_Dpy, sc->xftfont, (const FcChar8*)s,
	    strlen(s), &extents);

	XReparentWindow(X_Dpy, sc->menu.win, cc->win, 0, 0);
	XMoveResizeWindow(X_Dpy, sc->menu.win, 0, 0,
	    extents.xOff, sc->xftfont->height);
	XMapWindow(X_Dpy, sc->menu.win);
	XClearWindow(X_Dpy, sc->menu.win);

	XftDrawStringUtf8(sc->menu.xftdraw, &sc->xftcolor[CWM_COLOR_MENU_FONT],
	    sc->xftfont, 0, sc->xftfont->ascent + 1,
	    (const FcChar8*)s, strlen(s));
}

d67 2
a68 1
			mousefunc_sweep_draw(cc);
d130 2
d135 2
@


1.108
log
@Mechanical change: move screen menu bits to their own struct.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.107 2016/09/28 17:06:33 okan Exp $
d79 1
a79 1
		XMaskEvent(X_Dpy, MOUSEMASK, &ev);
d132 1
a132 1
		XMaskEvent(X_Dpy, MOUSEMASK, &ev);
@


1.107
log
@Inline Xft draw and extents wrappers; too much abstraction.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.106 2016/09/28 15:54:54 okan Exp $
d49 2
a50 2
	XReparentWindow(X_Dpy, sc->menuwin, cc->win, 0, 0);
	XMoveResizeWindow(X_Dpy, sc->menuwin, 0, 0,
d52 2
a53 2
	XMapWindow(X_Dpy, sc->menuwin);
	XClearWindow(X_Dpy, sc->menuwin);
d55 1
a55 1
	XftDrawStringUtf8(sc->xftdraw, &sc->xftcolor[CWM_COLOR_MENU_FONT],
d96 2
a97 2
			XUnmapWindow(X_Dpy, sc->menuwin);
			XReparentWindow(X_Dpy, sc->menuwin, sc->rootwin, 0, 0);
@


1.106
log
@Do not call sweep_draw() too early: don't yet have w/h dimensions; plus
we will get a MotionNotify event right away anyway, setting required
parameters.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.105 2016/09/22 14:36:03 okan Exp $
d42 1
d46 3
d51 1
a51 1
	    xu_xft_width(sc->xftfont, s, strlen(s)), sc->xftfont->height);
d55 3
a57 1
	xu_xft_draw(sc, s, CWM_COLOR_MENU_FONT, 0, sc->xftfont->ascent + 1);
@


1.105
log
@Continue merging kb and mouse functions: fold
mousefunc_menu_{client,cmd,group} into the respective
kbfunc_menu_{client,cmd,group} functions; simply pass a flag down from
config denoting mouse action behaviour.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.104 2016/09/13 13:42:28 okan Exp $
a70 1
	mousefunc_sweep_draw(cc);
@


1.104
log
@Limit mouse resize to hints within the client; matches kbd resize
behaviour.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.103 2015/11/17 14:31:28 okan Exp $
a156 77
}

void
mousefunc_menu_group(struct client_ctx *cc, union arg *arg)
{
	struct screen_ctx	*sc = cc->sc;
	struct group_ctx	*gc;
	struct menu		*mi;
	struct menu_q		 menuq;

	TAILQ_INIT(&menuq);
	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		if (group_holds_only_sticky(gc))
			continue;
		menuq_add(&menuq, gc, "%d %s", gc->num, gc->name);
	}

	if ((mi = menu_filter(sc, &menuq, NULL, NULL, CWM_MENU_LIST,
	    NULL, search_print_group)) != NULL) {
		gc = (struct group_ctx *)mi->ctx;
		(group_holds_only_hidden(gc)) ?
		    group_show(gc) : group_hide(gc);
	}

	menuq_clear(&menuq);
}

void
mousefunc_menu_client(struct client_ctx *cc, union arg *arg)
{
	struct screen_ctx	*sc = cc->sc;
	struct client_ctx	*old_cc;
	struct menu		*mi;
	struct menu_q		 menuq;

	old_cc = client_current();

	TAILQ_INIT(&menuq);
	TAILQ_FOREACH(cc, &sc->clientq, entry) {
		if (cc->flags & CLIENT_HIDDEN) {
			menuq_add(&menuq, cc, NULL);
		}
	}

	if ((mi = menu_filter(sc, &menuq, NULL, NULL, CWM_MENU_LIST,
	    NULL, search_print_client)) != NULL) {
		cc = (struct client_ctx *)mi->ctx;
		client_unhide(cc);
		if (old_cc != NULL)
			client_ptrsave(old_cc);
		client_ptrwarp(cc);
	}

	menuq_clear(&menuq);
}

void
mousefunc_menu_cmd(struct client_ctx *cc, union arg *arg)
{
	struct screen_ctx	*sc = cc->sc;
	struct cmd		*cmd;
	struct menu		*mi;
	struct menu_q		 menuq;

	TAILQ_INIT(&menuq);
	TAILQ_FOREACH(cmd, &Conf.cmdq, entry) {
		if ((strcmp(cmd->name, "lock") == 0) ||
		    (strcmp(cmd->name, "term") == 0))
			continue;
		menuq_add(&menuq, cmd, NULL);
	}

	if ((mi = menu_filter(sc, &menuq, NULL, NULL, CWM_MENU_LIST,
	    NULL, search_print_cmd)) != NULL)
		u_spawn(((struct cmd *)mi->ctx)->path);

	menuq_clear(&menuq);
@


1.103
log
@Inline the only use of mousefunc_sweep_calc.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.102 2015/11/11 14:22:01 okan Exp $
a59 1
	int			 x = cc->geom.x, y = cc->geom.y;
d83 2
a84 6
			cc->geom.w = abs(x - ev.xmotion.x_root) - cc->bwidth;
			cc->geom.h = abs(y - ev.xmotion.y_root) - cc->bwidth;
			cc->geom.x = (x <= ev.xmotion.x_root) ?
				x : x - cc->geom.w;
			cc->geom.y = (y <= ev.xmotion.y_root) ?
				y : y - cc->geom.h;
@


1.102
log
@Partial revert of replacing screen_area() with region_find(); until a
fix for a regression is found; this bug has been around for a long time
it seems, but this change exposed it. Likely need to track clients in to
and out of regions.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.101 2015/11/10 22:06:57 okan Exp $
a34 1
static void	mousefunc_sweep_calc(struct client_ctx *, int, int, int, int);
a37 12
mousefunc_sweep_calc(struct client_ctx *cc, int x, int y, int mx, int my)
{
	cc->geom.w = abs(x - mx) - cc->bwidth;
	cc->geom.h = abs(y - my) - cc->bwidth;

	client_applysizehints(cc);

	cc->geom.x = (x <= mx) ? x : x - cc->geom.w;
	cc->geom.y = (y <= my) ? y : y - cc->geom.h;
}

static void
d84 7
a90 2
			mousefunc_sweep_calc(cc, x, y,
			    ev.xmotion.x_root, ev.xmotion.y_root);
a152 1

@


1.101
log
@Use position on root to figure out region.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.100 2015/11/10 20:05:33 okan Exp $
d126 1
a126 1
	struct region_ctx	*rc;
d152 3
a154 2
			rc = region_find(sc,
			    ev.xmotion.x_root, ev.xmotion.y_root);
d157 1
a157 1
			    rc->work.x, rc->work.x + rc->work.w, sc->snapdist);
d160 1
a160 1
			    rc->work.y, rc->work.y + rc->work.h, sc->snapdist);
@


1.100
log
@Start cleaning up name vs function differences; replace magic numbers.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.99 2015/11/09 20:03:30 okan Exp $
d153 1
a153 2
			    cc->geom.x + cc->geom.w / 2,
			    cc->geom.y + cc->geom.h / 2);
@


1.99
log
@Extend region to include both view and work areas; switch to
region_find() which no longer needs to recalculate gap each time
a client (or menu) is created or altered. If no RandR, fall back
to display dimensions while building regions instead of during
execution.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.98 2015/08/21 16:14:39 okan Exp $
d199 1
a199 1
mousefunc_menu_unhide(struct client_ctx *cc, union arg *arg)
@


1.98
log
@_NET_WM_STATE_STICKY implies only sticky at the group/desktop level, not
position and size; based on discussion with a few.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.97 2015/08/21 16:05:55 okan Exp $
d126 1
a126 1
	struct geom		 area;
d152 1
a152 1
			area = screen_area(sc,
d154 1
a154 1
			    cc->geom.y + cc->geom.h / 2, CWM_GAP);
d157 1
a157 1
			    area.x, area.x + area.w, sc->snapdist);
d160 1
a160 1
			    area.y, area.y + area.h, sc->snapdist);
@


1.97
log
@Instead of special casing the 'term' and 'lock' commands, go back to
keeping them hidden; showing them has apparently caused confusion/angst.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.96 2015/07/12 14:31:47 okan Exp $
d75 1
a75 1
	if (cc->flags & (CLIENT_FREEZE|CLIENT_STICKY))
d131 1
a131 1
	if (cc->flags & (CLIENT_FREEZE|CLIENT_STICKY))
@


1.96
log
@introduce 'groupsearch' for group menu search; matches on either group
number/shortcut and/or name.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.95 2015/07/01 14:36:42 okan Exp $
d236 4
a239 1
	TAILQ_FOREACH(cmd, &Conf.cmdq, entry)
d241 1
@


1.95
log
@style
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.94 2015/06/30 19:02:24 okan Exp $
d185 1
a185 3
		menuq_add(&menuq, gc,
		    (group_holds_only_hidden(gc)) ? "%d: [%s]" : "%d: %s",
		    gc->num, gc->name);
d189 1
a189 1
	    NULL, NULL)) != NULL) {
@


1.94
log
@no longer need to pass down format strings after introducing search_print_cmd
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.93 2015/06/30 18:54:12 okan Exp $
d46 2
a47 2
	cc->geom.x = x <= mx ? x : x - cc->geom.w;
	cc->geom.y = y <= my ? y : y - cc->geom.h;
d186 1
a186 1
		    group_holds_only_hidden(gc) ? "%d: [%s]" : "%d: %s",
@


1.93
log
@Introduce a callback for cmd menu printing, special-casing 'lock' and
'term'.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.92 2015/06/26 17:17:46 okan Exp $
d239 1
a239 1
		menuq_add(&menuq, cmd, "%s", cmd->name);
@


1.92
log
@Mechanical change from xinerama to region backed areas.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.91 2015/06/08 15:41:27 okan Exp $
d242 1
a242 1
	    NULL, NULL)) != NULL)
@


1.91
log
@switch to search_print_client() as the print callback since it will now display labels as well
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.90 2015/06/08 15:11:29 okan Exp $
d126 1
a126 1
	struct geom		 xine;
d152 1
a152 1
			xine = screen_find_xinerama(sc,
d157 1
a157 1
			    xine.x, xine.x + xine.w, sc->snapdist);
d160 1
a160 1
			    xine.y, xine.y + xine.h, sc->snapdist);
@


1.90
log
@stash window dimensions
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.89 2015/06/07 19:10:00 okan Exp $
a206 1
	char			*wname;
d213 1
a213 5
			wname = (cc->label) ? cc->label : cc->name;
			if (wname == NULL)
				continue;
			menuq_add(&menuq, cc, "(%d) %s",
			    cc->group ? cc->group->num : 0, wname);
d218 1
a218 1
	    NULL, NULL)) != NULL) {
@


1.89
log
@even if the menuq is empty, at least show an empty menu instead of just
bailing making it look like the binding isn't working.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.88 2015/06/05 15:01:51 okan Exp $
d56 1
a56 3
	(void)snprintf(s, sizeof(s), " %4d x %-4d ",
	    (cc->geom.w - cc->hint.basew) / cc->hint.incw,
	    (cc->geom.h - cc->hint.baseh) / cc->hint.inch);
@


1.88
log
@add a flag to indicate a menu list instead of overloading 'prompt'
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.87 2015/05/21 00:37:04 okan Exp $
a190 2
	if (TAILQ_EMPTY(&menuq))
		return;
a222 2
	if (TAILQ_EMPTY(&menuq))
		return;
a246 2
	if (TAILQ_EMPTY(&menuq))
		return;
@


1.87
log
@merge kbd and mouse grouptoggle
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.86 2015/01/19 14:54:16 okan Exp $
d194 1
a194 1
	if ((mi = menu_filter(sc, &menuq, NULL, NULL, 0,
d228 1
a228 1
	if ((mi = menu_filter(sc, &menuq, NULL, NULL, 0,
d254 1
a254 1
	if ((mi = menu_filter(sc, &menuq, NULL, NULL, 0,
@


1.86
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.85 2014/09/27 19:04:32 okan Exp $
a172 6
}

void
mousefunc_client_grouptoggle(struct client_ctx *cc, union arg *arg)
{
	group_toggle_membership_enter(cc);
@


1.85
log
@these have nothing to do with 'sticky', but rather group membership; rename.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.84 2014/09/18 13:56:58 okan Exp $
d22 1
a22 1
#include <sys/param.h>
d27 1
@


1.84
log
@Move motion time check to the top of each MotionNotify block (and
eliminate from ButtonRelease); further limits the amount of work done
outside the threshold, notably mousefunc_sweep_calc,
screen_find_xinerama and client_snapcalc.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.83 2014/09/17 18:09:30 okan Exp $
d177 1
a177 1
	group_sticky_toggle_enter(cc);
@


1.83
log
@ewmh states _NET_WM_STATE_STICKY should not alter position
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.82 2014/09/17 16:32:53 okan Exp $
d93 5
d100 2
a101 7

			/* don't resize more than 60 times / second */
			if ((ev.xmotion.time - ltime) > (1000 / 60)) {
				ltime = ev.xmotion.time;
				client_resize(cc, 1);
				mousefunc_sweep_draw(cc);
			}
d104 1
a104 2
			if (ltime)
				client_resize(cc, 1);
d145 5
d163 1
a163 5
			/* don't move more than 60 times / second */
			if ((ev.xmotion.time - ltime) > (1000 / 60)) {
				ltime = ev.xmotion.time;
				client_move(cc);
			}
d166 1
a166 2
			if (ltime)
				client_move(cc);
@


1.82
log
@Use a similarly named check as sticky for hidden check in a group.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.81 2014/09/17 14:31:37 okan Exp $
d76 1
a76 1
	if (cc->flags & CLIENT_FREEZE)
d133 1
a133 1
	if (cc->flags & CLIENT_FREEZE)
@


1.81
log
@Introduce a check to see if a group holds only 'sticky' clients and use
this check to decide if a group is virtually empty.  Rationale: if a
group contains *only* 'sticky' clients, it should be skipped while
cycling through groups.  Apply similar logic to the group menu.

Based on an idea from phessler@@, who also tested another version.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.80 2014/09/08 21:15:14 okan Exp $
d194 1
a194 1
		    group_hidden_state(gc) ? "%d: [%s]" : "%d: %s",
d203 1
a203 1
		(group_hidden_state(gc)) ?
@


1.80
log
@name the group client queue appropriately, like other queues
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.79 2014/09/08 20:11:22 okan Exp $
d191 1
a191 1
		if (TAILQ_EMPTY(&gc->clientq))
@


1.79
log
@Remove duplicate client queue (mruq); instead, remove and take the
global Clientq and place it inside screen_ctx since every client belongs
to a screen, then use the same per screen clientq to track stacking
order (the sole reason for mruq).
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.78 2014/09/08 13:51:29 okan Exp $
d191 1
a191 1
		if (TAILQ_EMPTY(&gc->clients))
@


1.78
log
@Now that a group knows its screen, only pass down the group_ctx.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.77 2014/09/06 16:08:58 okan Exp $
d222 1
a222 1
	TAILQ_FOREACH(cc, &Clientq, entry) {
@


1.77
log
@Rework group names: stash the group name inside the group_ctx as opposed
to having to manage an array outside in screen_ctx for group names and
shortcuts.  Simplifies (and moves bits for) reading, and constructing
data for, EWMH's _NET_DESKTOP_NAMES.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.76 2014/09/02 14:08:39 okan Exp $
d204 1
a204 1
		    group_show(sc, gc) : group_hide(sc, gc);
@


1.76
log
@bring menu bits closer together
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.75 2014/09/01 18:17:32 okan Exp $
d195 1
a195 1
		    gc->num, sc->group_names[gc->num]);
@


1.75
log
@add explicit paran and drop some empty lines bringing like functions closer
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.74 2014/09/01 18:04:58 okan Exp $
d200 2
a201 2
	mi = menu_filter(sc, &menuq, NULL, NULL, 0, NULL, NULL);
	if (mi != NULL && mi->ctx != NULL) {
a237 1

@


1.74
log
@Merge group_menu into mousefunc_menu_group.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.73 2014/08/22 19:04:00 okan Exp $
a196 1

d222 1
a222 1
	TAILQ_FOREACH(cc, &Clientq, entry)
a226 1

d230 1
a230 1

a257 1

@


1.73
log
@Fix nogroup regression, where nogroup became an actual group - the
symantics between cwm groups and ewmh got in the way.  Ensure a client
that wants to be in nogroup stays in nogroup (thus stays in view), even
when (re)reading NET_WM_DESKTOP.  Paritially reverts patchset 644
(2014-02-07 13:09 PST) which deals with a NULL cc->group.  All to be
revisited when NET_WM_STATE_STICKY hits cwm.

Reported by many; testing and ok phessler.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.72 2014/08/20 15:15:29 okan Exp $
d184 25
a208 1
	group_menu(cc->sc);
@


1.72
log
@Purely mechanical; unify 'num', 'no' and 'shortcut'.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.71 2014/02/07 21:59:56 okan Exp $
d205 2
a206 1
			menuq_add(&menuq, cc, "(%d) %s", cc->group->num, wname);
@


1.71
log
@all mapped clients now should have a group, so simplify some cases
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.70 2014/01/30 14:40:21 okan Exp $
d205 1
a205 2
			menuq_add(&menuq, cc, "(%d) %s",
			    cc->group->shortcut, wname);
@


1.70
log
@Remove duplicate mouse functions and instead use the kbfunc ones.  No
user visable changes at this point, but they'll merge at an appropriate
time.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.69 2014/01/29 22:30:00 okan Exp $
d206 1
a206 1
			    cc->group ? cc->group->shortcut : 0, wname);
@


1.69
log
@Minimize trivial differences between a few kb and mb functions.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.68 2014/01/20 22:31:53 okan Exp $
a178 25
}

void
mousefunc_client_lower(struct client_ctx *cc, union arg *arg)
{
	client_ptrsave(cc);
	client_lower(cc);
}

void
mousefunc_client_raise(struct client_ctx *cc, union arg *arg)
{
	client_raise(cc);
}

void
mousefunc_client_hide(struct client_ctx *cc, union arg *arg)
{
	client_hide(cc);
}

void
mousefunc_client_cyclegroup(struct client_ctx *cc, union arg *arg)
{
	group_cycle(cc->sc, arg->i);
@


1.68
log
@Use argument to pass down flags for mousefunc cyclegroup; removes
rcyclegroup wrapper need - now similar to kbfunc.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.67 2014/01/20 21:34:32 okan Exp $
a223 1

d237 2
a238 2
	mi = menu_filter(sc, &menuq, NULL, NULL, 0, NULL, NULL);
	if (mi != NULL) {
d254 1
a256 1
	struct cmd		*cmd;
a258 1

d261 1
d265 2
a266 2
	mi = menu_filter(sc, &menuq, NULL, NULL, 0, NULL, NULL);
	if (mi != NULL)
@


1.67
log
@constify and rename some confusing variables around cmdq.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.66 2014/01/20 18:58:03 okan Exp $
d203 1
a203 7
	group_cycle(cc->sc, CWM_CYCLE);
}

void
mousefunc_client_rcyclegroup(struct client_ctx *cc, union arg *arg)
{
	group_cycle(cc->sc, CWM_RCYCLE);
@


1.66
log
@Add a function that adds an entry to a menuq, normalizing a common code
path; from Tiago Cunha.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.65 2014/01/02 21:30:20 okan Exp $
d268 1
a268 1
		menuq_add(&menuq, cmd, "%s", cmd->label);
d274 1
a274 1
		u_spawn(((struct cmd *)mi->ctx)->image);
@


1.65
log
@bring mousefunc closer to kbfunc
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.64 2013/12/13 22:39:13 okan Exp $
d237 1
a237 2
			mi = xcalloc(1, sizeof(*mi));
			(void)snprintf(mi->text, sizeof(mi->text), "(%d) %s",
a238 2
			mi->ctx = cc;
			TAILQ_INSERT_TAIL(&menuq, mi, entry);
d267 2
a268 6
	TAILQ_FOREACH(cmd, &Conf.cmdq, entry) {
		mi = xcalloc(1, sizeof(*mi));
		(void)strlcpy(mi->text, cmd->label, sizeof(mi->text));
		mi->ctx = cmd;
		TAILQ_INSERT_TAIL(&menuq, mi, entry);
	}
@


1.64
log
@Teach screen_find_xinerama() to apply gap only when told to do so;
adjust callers.  Needed for an upcoming feature.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.63 2013/12/13 21:51:56 okan Exp $
d69 1
a69 1
mousefunc_client_resize(struct client_ctx *cc, void *arg)
d123 1
a123 1
mousefunc_client_move(struct client_ctx *cc, void *arg)
d176 1
a176 1
mousefunc_client_grouptoggle(struct client_ctx *cc, void *arg)
d182 1
a182 1
mousefunc_client_lower(struct client_ctx *cc, void *arg)
d189 1
a189 1
mousefunc_client_raise(struct client_ctx *cc, void *arg)
d195 1
a195 1
mousefunc_client_hide(struct client_ctx *cc, void *arg)
d201 1
a201 1
mousefunc_client_cyclegroup(struct client_ctx *cc, void *arg)
d207 1
a207 1
mousefunc_client_rcyclegroup(struct client_ctx *cc, void *arg)
d213 1
a213 1
mousefunc_menu_group(struct client_ctx *cc, void *arg)
d219 1
a219 1
mousefunc_menu_unhide(struct client_ctx *cc, void *arg)
d261 1
a261 1
mousefunc_menu_cmd(struct client_ctx *cc, void *arg)
@


1.63
log
@Instead of using work area, use the Xinerama area for snap calculations;
based on a patch from Thomas Adam with appropriate adjustments for gap.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.62 2013/12/12 21:50:50 okan Exp $
d151 1
a151 1
			    cc->geom.y + cc->geom.h / 2);
@


1.62
log
@Make sure we really take work area gap into account with snap calculations;
from Dominik Honnef via Christian Neukirchen.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.61 2013/12/08 13:51:38 okan Exp $
d128 1
d149 3
d154 1
a154 1
			    sc->work.x, sc->work.x + sc->work.w, sc->snapdist);
d157 1
a157 1
			    sc->work.y, sc->work.y + sc->work.h, sc->snapdist);
@


1.61
log
@If not using sticky mode (the default), clients aren't automagically
assigned a group, thus cc->group will be NULL - fix the client group
shortcut in menu lists; crash reported by Christian Neukirchen.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.60 2013/12/02 19:30:27 okan Exp $
d150 1
a150 1
			    sc->work.x, sc->work.w, sc->snapdist);
d153 1
a153 1
			    sc->work.y, sc->work.h, sc->snapdist);
@


1.60
log
@Prepend the group shortcut in the client search menu; from Thomas Adam.
Likewise, prepend shortcut in unhide menu.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.59 2013/11/27 18:34:34 okan Exp $
d234 2
a235 2
			(void)snprintf(mi->text, sizeof(mi->text),
			    "(%d) %s", cc->group->shortcut, wname);
@


1.59
log
@like gap, make snapdist per screen
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.58 2013/11/27 14:20:32 okan Exp $
d234 2
a235 1
			(void)strlcpy(mi->text, wname, sizeof(mi->text));
@


1.58
log
@simplify/unfold
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.57 2013/10/19 18:59:22 okan Exp $
d150 1
a150 1
			    sc->work.x, sc->work.w, Conf.snapdist);
d153 1
a153 1
			    sc->work.y, sc->work.h, Conf.snapdist);
@


1.57
log
@I believe we redraw the border in too many cases; likely a leftover from
the cc->pwin days - don't redraw on every unhide, resize, and mouse
move/resize Expose event (note, all Expose events trigger a redraw
anyway).

Tested with some finicky X apps I could think of, though I'm sure others
will find more - if so, and they 'lose' the border, please report!
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.56 2013/07/09 01:24:49 okan Exp $
d53 1
a53 1
	char			 asize[14]; /* fits " nnnn x nnnn \0" */
d55 1
a55 1
	(void)snprintf(asize, sizeof(asize), " %4d x %-4d ",
d61 1
a61 2
	    xu_xft_width(sc->xftfont, asize, strlen(asize)),
	    sc->xftfont->height);
d65 1
a65 2
	xu_xft_draw(sc, asize, CWM_COLOR_MENU_FONT,
	    0, sc->xftfont->ascent + 1);
@


1.56
log
@since the root and event window are the same in the case of a button
event on the screen's root window, there's no need to pass down the
entire XButtonEvent event, at least to group_menu(), the only callback
which takes an argument at this point; instead use the already populated
screen.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.55 2013/07/08 18:39:20 okan Exp $
d91 1
a91 1
		XMaskEvent(X_Dpy, MOUSEMASK|ExposureMask, &ev);
a93 3
		case Expose:
			client_draw_border(cc);
			break;
d143 1
a143 1
		XMaskEvent(X_Dpy, MOUSEMASK|ExposureMask, &ev);
a145 3
		case Expose:
			client_draw_border(cc);
			break;
@


1.55
log
@add support for mouse based group {,r}cycle; from Rodrigo Mosconi.  not
bound by default.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.54 2013/07/08 18:19:22 okan Exp $
d219 1
a219 1
	group_menu(arg);
@


1.54
log
@move kbfunc and mousefunc closer together
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.53 2013/06/17 17:11:10 okan Exp $
d202 12
@


1.53
log
@move Cursors into conf.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.52 2013/05/20 20:21:04 okan Exp $
d71 1
a71 1
mousefunc_window_resize(struct client_ctx *cc, void *arg)
d128 1
a128 1
mousefunc_window_move(struct client_ctx *cc, void *arg)
d180 1
a180 1
mousefunc_window_grouptoggle(struct client_ctx *cc, void *arg)
d186 1
a186 1
mousefunc_window_lower(struct client_ctx *cc, void *arg)
d193 1
a193 1
mousefunc_window_raise(struct client_ctx *cc, void *arg)
d199 1
a199 1
mousefunc_window_hide(struct client_ctx *cc, void *arg)
@


1.52
log
@- configure menuwin with the screen, then create the xft drawable using
  the menu window since that's the only place on which we draw
- elminate the need to change the drawable on every font draw
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.51 2013/05/19 23:38:21 okan Exp $
d84 1
a84 1
	if (xu_ptr_grab(cc->win, MOUSEMASK, Cursor_resize) < 0)
d140 1
a140 1
	if (xu_ptr_grab(cc->win, MOUSEMASK, Cursor_move) < 0)
@


1.51
log
@move the 2 small font helper functions to xutil.c
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.50 2013/05/14 12:35:56 okan Exp $
d66 1
a66 1
	xu_xft_draw(sc, asize, sc->menuwin, CWM_COLOR_MENU_FONT,
@


1.50
log
@- let callers of font_draw figure out (and pass) the color instead of an
  'active' flag.
- use strlen() inside of font_draw; the only instance where it wasn't
  used happened to be ignored on a subsequent draw.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.49 2013/05/02 19:33:17 okan Exp $
d61 2
a62 1
	    font_width(sc->xftfont, asize, strlen(asize)), sc->xftfont->height);
d66 1
a66 1
	font_draw(sc, asize, sc->menuwin, CWM_COLOR_MENU_FONT,
@


1.49
log
@get rid of cc->name in the resize box and make dimensions more readable.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.48 2013/05/02 19:30:10 okan Exp $
d65 2
a66 2
	font_draw(sc, asize, strlen(asize), sc->menuwin, 0, 0,
	    sc->xftfont->ascent + 1);
@


1.48
log
@only redraw the name/size box when the client resizes, not every time
there's movement; should slightly help with resize syncs.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.47 2013/05/02 17:25:15 okan Exp $
d53 1
a53 2
	char			 asize[10]; /* fits "nnnnxnnnn\0" */
	int			 width, width_size, width_name, height;
d55 1
a55 1
	(void)snprintf(asize, sizeof(asize), "%dx%d",
a57 4
	width_size = font_width(sc->xftfont, asize, strlen(asize)) + 4;
	width_name = font_width(sc->xftfont, cc->name, strlen(cc->name)) + 4;
	width = MAX(width_size, width_name);
	height = sc->xftfont->height + 1;
d60 2
a61 1
	XMoveResizeWindow(X_Dpy, sc->menuwin, 0, 0, width, height * 2);
d64 3
a66 4
	font_draw(sc, cc->name, strlen(cc->name), sc->menuwin, 0,
	    2, sc->xftfont->ascent + 1);
	font_draw(sc, asize, strlen(asize), sc->menuwin, 0,
	    width / 2 - width_size / 2, height + sc->xftfont->ascent + 1);
@


1.47
log
@no need for font_{ascent,descent,height} wrappers; limit font_width to
just requiring xftfont.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.46 2013/04/08 15:43:04 okan Exp $
d34 1
a34 1
static int	mousefunc_sweep_calc(struct client_ctx *, int, int, int, int);
d37 1
a37 1
static int
a39 2
	int	 width = cc->geom.w, height = cc->geom.h;

a46 2

	return (width != cc->geom.w || height != cc->geom.h);
d102 2
a103 4
			if (mousefunc_sweep_calc(cc, x, y,
			    ev.xmotion.x_root, ev.xmotion.y_root))
				/* Recompute window output */
				mousefunc_sweep_draw(cc);
d109 1
@


1.46
log
@plug memleak; always need to menuq_clear even when a selection is made.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.45 2013/04/08 13:02:31 okan Exp $
d58 1
a58 1
	int			 width, width_size, width_name;
d63 2
a64 2
	width_size = font_width(sc, asize, strlen(asize)) + 4;
	width_name = font_width(sc, cc->name, strlen(cc->name)) + 4;
d66 1
d69 1
a69 1
	XMoveResizeWindow(X_Dpy, sc->menuwin, 0, 0, width, font_height(sc) * 2);
d73 1
a73 1
	    2, font_ascent(sc) + 1);
d75 1
a75 1
	    width / 2 - width_size / 2, font_height(sc) + font_ascent(sc) + 1);
@


1.45
log
@consistency
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.44 2013/01/02 21:41:14 okan Exp $
d254 3
a256 2
	} else
		menuq_clear(&menuq);
d281 2
a282 2
	else
		menuq_clear(&menuq);
@


1.44
log
@pass the screen workarea, as opposed to viewarea, allowing client
snapping to honor gap.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.43 2013/01/02 21:37:21 okan Exp $
d230 1
d267 1
@


1.43
log
@re-work client_snapcalc() so it takes client and edge dimensions with
snapdist; allows for simplier snap calculations.

required for an upcoming diff for honoring gap.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.42 2012/12/17 14:32:39 okan Exp $
d166 1
a166 1
			    sc->view.x, sc->view.w, Conf.snapdist);
d169 1
a169 1
			    sc->view.y, sc->view.h, Conf.snapdist);
@


1.42
log
@create and use menuq_clear() helper; from Tiago Cunha
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.41 2012/12/17 02:28:45 okan Exp $
d165 2
a166 2
			    cc->geom.w, sc->view.w,
			    cc->bwidth, Conf.snapdist);
d168 2
a169 2
			    cc->geom.h, sc->view.h,
			    cc->bwidth, Conf.snapdist);
@


1.41
log
@non-trivial menu drawing rewrite, moving to Xft and solving various
font/color drawing issues; from Alexander Polakov
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.40 2012/11/09 03:52:02 okan Exp $
d253 2
a254 6
	} else {
		while ((mi = TAILQ_FIRST(&menuq)) != NULL) {
			TAILQ_REMOVE(&menuq, mi, entry);
			free(mi);
		}
	}
d279 1
a279 4
		while ((mi = TAILQ_FIRST(&menuq)) != NULL) {
			TAILQ_REMOVE(&menuq, mi, entry);
			free(mi);
		}
@


1.40
log
@sort
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.39 2012/11/07 20:34:39 okan Exp $
d71 1
a71 1
	font_draw(sc, cc->name, strlen(cc->name), sc->menuwin,
d73 1
a73 1
	font_draw(sc, asize, strlen(asize), sc->menuwin,
@


1.39
log
@get rid of the xfree() wrapper around free(); from Tiago Cunha.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.38 2012/09/09 19:47:47 okan Exp $
d27 1
a29 1
#include <stdio.h>
@


1.38
log
@extend client_resize so that it can know when to reset max flags and
bwidth; this allows a client to be resized from a max state, which now
gets treated like a non-max'd client.  based on a diff that does part of
this in a different way from Alexander Polakov.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.37 2012/07/13 17:01:04 okan Exp $
d256 1
a256 1
			xfree(mi);
d285 1
a285 1
			xfree(mi);
@


1.37
log
@re-use geom struct in client_ctx (saved)geometry.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.36 2012/07/13 15:21:35 okan Exp $
d113 1
a113 1
				client_resize(cc);
d118 1
a118 1
				client_resize(cc);
@


1.36
log
@convert xmax/ymax uses to view geometry.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.35 2012/07/04 23:42:03 okan Exp $
d40 1
a40 1
	int	 width = cc->geom.width, height = cc->geom.height;
d42 2
a43 2
	cc->geom.width = abs(x - mx) - cc->bwidth;
	cc->geom.height = abs(y - my) - cc->bwidth;
d47 2
a48 2
	cc->geom.x = x <= mx ? x : x - cc->geom.width;
	cc->geom.y = y <= my ? y : y - cc->geom.height;
d50 1
a50 1
	return (width != cc->geom.width || height != cc->geom.height);
d61 2
a62 2
	    (cc->geom.width - cc->hint.basew) / cc->hint.incw,
	    (cc->geom.height - cc->hint.baseh) / cc->hint.inch);
d94 1
a94 1
	xu_ptr_setpos(cc->win, cc->geom.width, cc->geom.height);
d124 4
a127 4
			if (cc->ptr.x > cc->geom.width)
				cc->ptr.x = cc->geom.width - cc->bwidth;
			if (cc->ptr.y > cc->geom.height)
				cc->ptr.y = cc->geom.height - cc->bwidth;
d165 1
a165 1
			    cc->geom.width, sc->view.w,
d168 1
a168 1
			    cc->geom.height, sc->view.h,
@


1.35
log
@assign and use screen ctx where appropriate and consistently.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.34 2011/10/17 18:18:38 okan Exp $
d165 1
a165 1
			    cc->geom.width, sc->xmax,
d168 1
a168 1
			    cc->geom.height, sc->ymax,
@


1.34
log
@rename variable to reduce potential for name-space collision.

bikesheding and ok oga@@.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.33 2011/09/03 09:42:33 okan Exp $
d140 1
d165 1
a165 1
			    cc->geom.width, cc->sc->xmax,
d168 1
a168 1
			    cc->geom.height, cc->sc->ymax,
d221 1
a221 1
	struct screen_ctx	*sc;
a226 1
	sc = cc->sc;
d264 1
a264 1
	struct screen_ctx	*sc;
a267 2

	sc = cc->sc;
@


1.33
log
@split off window hints from geometry so we don't need to carry them all
around when dealing with {,h,v}max.  same idea from oga.
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.32 2011/07/25 15:10:24 okan Exp $
d81 1
a81 1
	Time			 time = 0;
d111 2
a112 2
			if ((ev.xmotion.time - time) > (1000 / 60)) {
				time = ev.xmotion.time;
d117 1
a117 1
			if (time)
d139 1
a139 1
	Time			 time = 0;
d171 2
a172 2
			if ((ev.xmotion.time - time) > (1000 / 60)) {
				time = ev.xmotion.time;
d177 1
a177 1
			if (time)
@


1.32
log
@We are inconsistent when it comes to function returns, so just go all
the way with the cwm specific parts.

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.31 2011/07/23 13:09:11 okan Exp $
d61 2
a62 2
	    (cc->geom.width - cc->geom.basew) / cc->geom.incw,
	    (cc->geom.height - cc->geom.baseh) / cc->geom.inch);
@


1.31
log
@Clarify defines and make them not look like non-local ones; started by a
small diff from Thomas Pfaff.

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.30 2011/06/24 06:09:26 okan Exp $
d60 1
a60 1
	snprintf(asize, sizeof(asize), "%dx%d",
d237 1
a237 1
			strlcpy(mi->text, wname, sizeof(mi->text));
d274 1
a274 1
		strlcpy(mi->text, cmd->label, sizeof(mi->text));
@


1.30
log
@New option to raise a client via the mouse (unbound by default);
opposing action, lower, already exists and bound.  Both keyboard
mappings already exist.

'no opinion either way' oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.29 2011/06/24 06:06:24 okan Exp $
d91 1
a91 1
	if (xu_ptr_grab(cc->win, MouseMask, Cursor_resize) < 0)
d98 1
a98 1
		XMaskEvent(X_Dpy, MouseMask|ExposureMask, &ev);
d147 1
a147 1
	if (xu_ptr_grab(cc->win, MouseMask, Cursor_move) < 0)
d153 1
a153 1
		XMaskEvent(X_Dpy, MouseMask|ExposureMask, &ev);
@


1.29
log
@introduce a new config option to snap to the screen edge.  'snapdist'
keyword taken from a diff from Sviatoslav Chagaev to do the same thing,
but implemented in a completely way (based on some very old code from
mk@@).  default set to 0, so no behavior change.

ok oga@@ (who would also like to take it further...)
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.28 2011/06/24 05:51:25 okan Exp $
d197 6
@


1.28
log
@re-order sweep draw so that we map into the client window after
re-parenting; from Sviatoslav Chagaev.

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.27 2011/06/24 05:45:57 okan Exp $
d162 7
@


1.27
log
@struct XftFont already has height which we can use directly instead of
calculating ourselves, so do so.

ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.26 2011/05/13 12:53:19 okan Exp $
d67 2
a68 2
	XMoveResizeWindow(X_Dpy, sc->menuwin, cc->geom.x, cc->geom.y,
	    width, font_height(sc) * 2);
a69 1
	XReparentWindow(X_Dpy, sc->menuwin, cc->win, 0, 0);
@


1.26
log
@remove left over XSync; ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.25 2011/05/11 13:53:51 okan Exp $
d58 1
a58 1
	int			 width, height, width_size, width_name;
a65 1
	height = font_ascent(sc) + font_descent(sc) + 1;
d68 1
a68 1
	    width, height * 2);
d75 1
a75 1
	    width / 2 - width_size / 2, height + font_ascent(sc) + 1);
@


1.25
log
@tag and comment cleanup; ok oga@@
@
text
@d19 1
a19 1
 * $OpenBSD: mousefunc.c,v 1.24 2011/05/07 17:15:37 okan Exp $
d119 1
a119 2
			if (time) {
				XSync(X_Dpy, False);
a120 1
			}
d172 1
a172 2
			if (time) {
				XSync(X_Dpy, False);
a173 1
			}
@


1.24
log
@introduce a new 'freeze' flag (CMS-f by default) which may be applied to
any window, after which all move/resize requests will be ignored,
essentially freezing the window in place.

there's a possibility to merge this with the 'ignore' concept, pending
on how ignore+freeze should behave (really more ewmh stuff), but punting
for now since ponies are on the line.

requested and tested by thib at k2k11 with ponies, unicorns and rainbows.

'save the unicorns' todd@@, ok oga@@
@
text
@d2 1
a2 1
 *  calmwm - the calm window manager
d4 2
a5 2
 *  Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *  Copyright (c) 2008 rivo nurges <rix@@estpak.ee>
d19 1
a19 1
 * $Id: mousefunc.c,v 1.23 2011/05/05 19:52:52 okan Exp $
@


1.23
log
@bump window resize back to 60hz. instead, we should not need to sync
every time we move/resize a window, so remove XSync in both mouse move
and resize events.  tested by Brynet as well.

ok oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.22 2011/03/23 07:27:32 okan Exp $
d87 3
d147 3
@


1.22
log
@revert the XSync timing change for client move only; first noticed by
brynet.

sure oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.21 2011/03/22 10:59:08 okan Exp $
d109 2
a110 2
			/* don't sync more than 10 times / second */
			if ((ev.xmotion.time - time) > (1000 / 10)) {
a111 1
				XSync(X_Dpy, False);
d161 1
a161 1
			/* don't sync more than 60 times / second */
a163 1
				XSync(X_Dpy, False);
@


1.21
log
@reduce the number of times we sync during a window resize.

ok oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.20 2010/12/14 11:08:47 martynas Exp $
d162 2
a163 2
			/* don't sync more than 10 times / second */
			if ((ev.xmotion.time - time) > (1000 / 10)) {
@


1.20
log
@in MotionNotify geom.x, geom.y calculations take into account bwidth.
fixes the annoying bug where windows would go +bwidth pixels right,
+bwidth pixels down.  ok okan@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.19 2009/12/15 04:10:42 okan Exp $
d109 2
a110 2
			/* don't sync more than 60 times / second */
			if ((ev.xmotion.time - time) > (1000 / 60)) {
a130 1

d162 2
a163 2
			/* don't sync more than 60 times / second */
			if ((ev.xmotion.time - time) > (1000 / 60)) {
@


1.19
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.18 2009/12/15 03:24:36 okan Exp $
d160 2
a161 2
			cc->geom.x = ev.xmotion.x_root - px;
			cc->geom.y = ev.xmotion.y_root - py;
@


1.18
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.17 2009/12/10 17:16:51 oga Exp $
d21 10
@


1.17
log
@finish unfucking the screen_ctx handling.

remove screen_current() it was utterly bogus when nscreens > 1.

pass a fake client_ctx in the case where there's no client and the
kbfunc or mousefunc doesn't need a real one, it just contains the
current screen, modify these functions so that they pass down the screen
context to their callees.

make groups per screen, it's the only way it makes sense in this regard.

ok okan@@.
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.16 2009/12/08 16:52:17 okan Exp $
a21 1
#include "headers.h"
@


1.16
log
@start fixing screen_ctx usage, for it is utterly broken.  bring font
into screen_ctx and start passing screen_ctx around to in order get rid
of Curscreen; fixup per-screen config colors the same way.

diff mostly from oga@@, with a bit harsher reaction to the state of screen_ctx.

"please commit" oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.15 2009/08/27 01:38:08 okan Exp $
d201 1
d207 1
d226 1
a226 1
	mi = menu_filter(&menuq, NULL, NULL, 0, NULL, NULL);
d245 6
a250 3
	struct menu	*mi;
	struct menu_q	 menuq;
	struct cmd	*cmd;
d262 1
a262 1
	mi = menu_filter(&menuq, NULL, NULL, 0, NULL, NULL);
@


1.15
log
@unroll the CCTOSC macro; from Thomas Pfaff

ok oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.14 2009/08/25 01:32:40 oga Exp $
d54 2
a55 2
	width_size = font_width(asize, strlen(asize)) + 4;
	width_name = font_width(cc->name, strlen(cc->name)) + 4;
d57 1
a57 1
	height = font_ascent() + font_descent() + 1;
d65 1
a65 1
	    2, font_ascent() + 1);
d67 1
a67 1
	    width / 2 - width_size / 2, height + font_ascent() + 1);
@


1.14
log
@Instead of messing around everytime we do a resize, just clamp the
resize increments to a minimum of one, and use it unconditionally.

"you've convinced me, do it!" okan@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.13 2009/08/24 23:49:04 okan Exp $
d47 1
a47 1
	struct screen_ctx	*sc = CCTOSC(cc);
d75 1
a75 1
	struct screen_ctx	*sc = CCTOSC(cc);
@


1.13
log
@bring together gathering, calculating and applying of size hints;
additionally, respect aspect ratio hints.

ok oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.12 2009/06/20 00:55:42 okan Exp $
d52 2
a53 2
	    (cc->geom.width - cc->geom.basew) / MAX(1, cc->geom.incw),
	    (cc->geom.height - cc->geom.baseh) / MAX(1, cc->geom.inch));
@


1.12
log
@compact a bit by condensing a few if-else's; from Thomas Pfaff

"go on then" oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.11 2009/06/20 00:22:39 okan Exp $
d36 1
a36 16
	if (cc->size->flags & PResizeInc) {
		cc->geom.width -=
		    (cc->geom.width - cc->geom.min_dx) % cc->size->width_inc;
		cc->geom.height -=
		    (cc->geom.height - cc->geom.min_dy) % cc->size->height_inc;
	}

	if (cc->size->flags & PMinSize) {
		cc->geom.width = MAX(cc->geom.width, cc->size->min_width);
		cc->geom.height = MAX(cc->geom.height, cc->size->min_height);
	}

	if (cc->size->flags & PMaxSize) {
		cc->geom.width = MIN(cc->geom.width, cc->size->max_width);
		cc->geom.height = MIN(cc->geom.height, cc->size->max_height);
	}
d52 2
a53 2
	    (cc->geom.width - cc->geom.min_dx) / cc->size->width_inc,
	    (cc->geom.height - cc->geom.min_dy) / cc->size->height_inc);
a76 3

	cc->size->width_inc = MAX(1, cc->size->width_inc);
	cc->size->height_inc = MAX(1, cc->size->height_inc);
@


1.11
log
@unroll XCALLOC/XMALLOC macros; since we use xcalloc/xmalloc all over the
place anyway, this makes things a bit more consistent; from Thomas Pfaff

ok oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.10 2009/06/17 12:45:01 okan Exp $
d229 1
a229 5
			if (cc->label != NULL)
				wname = cc->label;
			else
				wname = cc->name;

@


1.10
log
@re-factor parts of mouse move/resize bit to shrink and make more
readable; no behavior change

ok oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.9 2009/05/18 00:23:35 okan Exp $
d237 1
a237 1
			XCALLOC(mi, struct menu);
d271 1
a271 1
		XCALLOC(mi, struct menu);
@


1.9
log
@nuke the leading underscore notation for local static functions - there
are far better ways to know.

"go for it" oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.8 2009/04/15 14:10:07 okan Exp $
d26 1
a26 4
static void	mousefunc_sweep_draw(struct client_ctx *, int, int);

#define ADJUST_HEIGHT(cc, dy)	((cc->geom.height - cc->geom.min_dy) / dy)
#define ADJUST_WIDTH(cc, dx)	((cc->geom.width - cc->geom.min_dx) / dx)
d60 1
a60 1
mousefunc_sweep_draw(struct client_ctx *cc, int dx, int dy)
d64 1
a64 2
	int			 wide, height, wide_size, wide_name;
	int			 x = cc->geom.x, y = cc->geom.y;
d67 5
a71 4
	    ADJUST_WIDTH(cc, dx), ADJUST_HEIGHT(cc, dy));
	wide_size = font_width(asize, strlen(asize)) + 4;
	wide_name = font_width(cc->name, strlen(cc->name)) + 4;
	wide = MAX(wide_size, wide_name);
d74 2
a75 1
	XMoveResizeWindow(X_Dpy, sc->menuwin, x, y, wide, height * 2);
d82 1
a82 1
	    wide / 2 - wide_size / 2, height + font_ascent() + 1);
a90 1
	int			 dx, dy;
d93 2
a94 2
	dx = MAX(1, cc->size->width_inc);
	dy = MAX(1, cc->size->height_inc);
d99 1
a99 1
	if (xu_ptr_grab(sc->rootwin, MouseMask, Cursor_resize) < 0)
d103 1
a103 1
	mousefunc_sweep_draw(cc, dx, dy);
d114 1
a114 1
			    ev.xmotion.x, ev.xmotion.y))
d116 1
a116 1
				mousefunc_sweep_draw(cc, dx, dy);
d119 1
a119 1
			if ((ev.xmotion.time - time) > (1000 / 60) ) {
d152 1
a152 3
	struct screen_ctx	*sc = CCTOSC(cc);
	int			 mx, my;
	int			 x = cc->geom.x, y = cc->geom.y;
d156 1
a156 1
	if (xu_ptr_grab(sc->rootwin, MouseMask, Cursor_move) < 0)
d159 1
a159 1
	xu_ptr_getpos(sc->rootwin, &mx, &my);
d169 2
a170 2
			cc->geom.x = x + (ev.xmotion.x - mx);
			cc->geom.y = y + (ev.xmotion.y - my);
d173 1
a173 1
			if ((ev.xmotion.time - time) > (1000 / 60) ) {
@


1.8
log
@don't sync more than 60 times per sec on resize and move; idea from scrotwm.

ok oga@@ sometime ago
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.7 2009/01/22 19:01:56 okan Exp $
d25 2
a26 2
static int	_mousefunc_sweep_calc(struct client_ctx *, int, int, int, int);
static void	_mousefunc_sweep_draw(struct client_ctx *, int, int);
d32 1
a32 1
_mousefunc_sweep_calc(struct client_ctx *cc, int x, int y, int mx, int my)
d63 1
a63 1
_mousefunc_sweep_draw(struct client_ctx *cc, int dx, int dy)
d106 1
a106 1
	_mousefunc_sweep_draw(cc, dx, dy);
d116 1
a116 1
			if (_mousefunc_sweep_calc(cc, x, y,
d119 1
a119 1
				_mousefunc_sweep_draw(cc, dx, dy);
@


1.7
log
@now that pwin is gone gone gone, we no longer have to do the bwidth
dance; xevents now able to deal with a border being set (which fixes
those annoying movie-watching apps).

ok todd@@, oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.6 2009/01/16 15:24:14 okan Exp $
d91 1
d120 7
a126 1
			client_resize(cc);
d129 4
d154 1
d176 7
a182 1
			client_move(cc);
d185 4
@


1.6
log
@remove pwin, bringing us to one client, one window.  we no longer have
to push attributes around, so things get a lot simplier, while fixing a
few issues in the meantime; original suggestion by Edd Barrett many many
moons ago.

annoying window placement and race, found in c2k8 by todd, fix by oga!

lots of feedback from todd and oga - thanks!

"commit that bad boy" oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.5 2009/01/11 18:34:46 okan Exp $
d36 2
a37 2
	cc->geom.width = abs(x - mx);
	cc->geom.height = abs(y - my);
d119 1
a119 6

			XMoveResizeWindow(X_Dpy, cc->win,
			    cc->geom.x - cc->bwidth,
			    cc->geom.y - cc->bwidth,
			    cc->geom.width + cc->bwidth * 2,
			    cc->geom.height + cc->bwidth * 2);
d164 1
a164 4

			XMoveWindow(X_Dpy, cc->win,
			    cc->geom.x - cc->bwidth, cc->geom.y - cc->bwidth);

@


1.5
log
@- merge grab_sweep() into mousefunc_window_resize().
- merge grab_drag() into mousefunc_window_move().
- properly name, proto and static private functions.
- since we already do XMoveResizeWindow() and XMoveWindow() in (now)
mousefunc_window_resize() and mousefunc_window_move() respectively,
client_resize() and client_move() calls are unnecessary.

ok oga@@
@
text
@d19 1
a19 1
 * $Id: mousefunc.c,v 1.4 2008/07/11 15:18:29 okan Exp $
d120 1
a120 1
			XMoveResizeWindow(X_Dpy, cc->pwin,
a124 5
			XMoveResizeWindow(X_Dpy, cc->win,
			    cc->bwidth, cc->bwidth,
			    cc->geom.width, cc->geom.height);

			client_do_shape(cc);
d170 1
a170 1
			XMoveWindow(X_Dpy, cc->pwin,
@


1.4
log
@no more hidden (and mysterious) config reloads and allow binding a key
to a config reload; CMS-r by default.

ok oga@@
@
text
@d4 1
d19 1
a19 1
 * $Id: mousefunc.c,v 1.3 2008/07/11 14:21:28 okan Exp $
d25 62
d90 57
a146 2
	grab_sweep(cc);
	client_resize(cc);
d152 33
a184 2
	grab_drag(cc);
	client_move(cc);
@


1.3
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: mousefunc.c,v 1.2 2008/06/25 22:44:42 oga Exp $
a114 2

	conf_reload(&Conf);
@


1.2
log
@Allow a mouse binding to hide a window, and add a default keybinding for CMS-M3,
so it's hard to press by accident, but there if you need it.

requested (in a way) and tested by johan and todd.
@
text
@d18 1
a18 1
 * $Id: mousefunc.c,v 1.1 2008/06/14 21:48:54 okan Exp $
d66 6
a71 4
	struct menu *mi;
	struct menu_q menuq;
	char *wname;
	struct client_ctx *old_cc = client_current();
d101 1
a101 1
	} else
d106 1
d112 4
a115 3
	struct menu *mi;
	struct menu_q menuq;
	struct cmd *cmd;
@


1.1
log
@confable menu and window mouse bindings from rivo nurges (thanks!) with
some minor fixups, man page bits and knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id$
d49 6
@

