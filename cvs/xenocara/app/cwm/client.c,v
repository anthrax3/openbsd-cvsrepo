head	1.240;
access;
symbols
	OPENBSD_6_1:1.234.0.2
	OPENBSD_6_1_BASE:1.234
	OPENBSD_6_0:1.214.0.4
	OPENBSD_6_0_BASE:1.214
	OPENBSD_5_9:1.214.0.2
	OPENBSD_5_9_BASE:1.214
	OPENBSD_5_8:1.198.0.2
	OPENBSD_5_8_BASE:1.198
	OPENBSD_5_7:1.190.0.2
	OPENBSD_5_7_BASE:1.190
	OPENBSD_5_6:1.172.0.4
	OPENBSD_5_6_BASE:1.172
	OPENBSD_5_5:1.172.0.2
	OPENBSD_5_5_BASE:1.172
	OPENBSD_5_4:1.136.0.2
	OPENBSD_5_4_BASE:1.136
	OPENBSD_5_3:1.119.0.2
	OPENBSD_5_3_BASE:1.119
	OPENBSD_5_2:1.100.0.2
	OPENBSD_5_2_BASE:1.100
	OPENBSD_5_1_BASE:1.91
	OPENBSD_5_1:1.91.0.2
	OPENBSD_5_0:1.86.0.2
	OPENBSD_5_0_BASE:1.86
	OPENBSD_4_9:1.77.0.2
	OPENBSD_4_9_BASE:1.77
	OPENBSD_4_8:1.76.0.4
	OPENBSD_4_8_BASE:1.76
	OPENBSD_4_7:1.74.0.2
	OPENBSD_4_7_BASE:1.74
	OPENBSD_4_6:1.57.0.2
	OPENBSD_4_6_BASE:1.57
	OPENBSD_4_5:1.47.0.2
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.240
date	2017.05.05.14.14.19;	author okan;	state Exp;
branches;
next	1.239;
commitid	MHWFfQOhbHl6rRE3;

1.239
date	2017.05.01.12.54.55;	author okan;	state Exp;
branches;
next	1.238;
commitid	BmUz0RRjwbKEonTv;

1.238
date	2017.04.26.21.10.54;	author okan;	state Exp;
branches;
next	1.237;
commitid	LDoW1p4qPKaKlLtb;

1.237
date	2017.04.24.13.31.19;	author okan;	state Exp;
branches;
next	1.236;
commitid	yHkGelu3JBpyg1cf;

1.236
date	2017.04.24.12.27.32;	author okan;	state Exp;
branches;
next	1.235;
commitid	CMO2hezRv0M8BxQG;

1.235
date	2017.04.24.12.18.04;	author okan;	state Exp;
branches;
next	1.234;
commitid	vsLIT4l4jtxxEI3F;

1.234
date	2017.02.06.18.10.28;	author okan;	state Exp;
branches;
next	1.233;
commitid	6j1nDf4Z9CzQlSxN;

1.233
date	2016.12.19.14.17.26;	author okan;	state Exp;
branches;
next	1.232;
commitid	zSrmaVwVpIk7UW4X;

1.232
date	2016.12.06.21.59.33;	author okan;	state Exp;
branches;
next	1.231;
commitid	YeXGci1FHYjo8hBc;

1.231
date	2016.12.06.21.00.13;	author okan;	state Exp;
branches;
next	1.230;
commitid	8no9kGVHnWI22cXB;

1.230
date	2016.10.18.17.03.30;	author okan;	state Exp;
branches;
next	1.229;
commitid	dIOrHVlb55Ubzrpl;

1.229
date	2016.10.06.14.30.05;	author okan;	state Exp;
branches;
next	1.228;
commitid	OZOHyBQfkwf2zmsq;

1.228
date	2016.10.04.15.52.32;	author okan;	state Exp;
branches;
next	1.227;
commitid	YwD6cS669TAwbf4b;

1.227
date	2016.10.03.14.42.34;	author okan;	state Exp;
branches;
next	1.226;
commitid	sciYi1tUXUIu4s4n;

1.226
date	2016.10.03.13.41.30;	author okan;	state Exp;
branches;
next	1.225;
commitid	orUFke6gsTLo5w4T;

1.225
date	2016.09.30.20.55.54;	author okan;	state Exp;
branches;
next	1.224;
commitid	jjJC1StMTVdDeuKf;

1.224
date	2016.09.20.19.11.19;	author okan;	state Exp;
branches;
next	1.223;
commitid	rpX3LIVTde3xQU35;

1.223
date	2016.09.20.18.21.32;	author okan;	state Exp;
branches;
next	1.222;
commitid	qCDEY2YHcX1pzTdR;

1.222
date	2016.09.16.14.32.02;	author okan;	state Exp;
branches;
next	1.221;
commitid	JzYS0uWdEYDeM0Hk;

1.221
date	2016.09.14.21.00.24;	author okan;	state Exp;
branches;
next	1.220;
commitid	pcCrtKfll9BwI3VJ;

1.220
date	2016.09.14.19.45.33;	author okan;	state Exp;
branches;
next	1.219;
commitid	lAQwIuCLXRGzG7kf;

1.219
date	2016.09.13.17.42.58;	author okan;	state Exp;
branches;
next	1.218;
commitid	gjNKb6l3ftOcA9Qg;

1.218
date	2016.09.12.13.48.41;	author okan;	state Exp;
branches;
next	1.217;
commitid	8koKnOoMm0DFHl7t;

1.217
date	2016.09.02.15.08.44;	author okan;	state Exp;
branches;
next	1.216;
commitid	TD58KSaRT0x0jYEo;

1.216
date	2016.09.01.18.38.52;	author okan;	state Exp;
branches;
next	1.215;
commitid	YDPx0jkEYrjd61Vn;

1.215
date	2016.09.01.18.34.04;	author okan;	state Exp;
branches;
next	1.214;
commitid	sT5fMWND1s1QU10k;

1.214
date	2015.11.12.18.33.30;	author okan;	state Exp;
branches;
next	1.213;
commitid	Kx7sbbZDDgNr89PQ;

1.213
date	2015.11.11.14.22.01;	author okan;	state Exp;
branches;
next	1.212;
commitid	t4AzuTxPlqQ6EzqO;

1.212
date	2015.11.10.20.05.33;	author okan;	state Exp;
branches;
next	1.211;
commitid	vKzF5zXTpUgY9uJK;

1.211
date	2015.11.09.20.03.29;	author okan;	state Exp;
branches;
next	1.210;
commitid	9uKgpfLzKiBWmiSm;

1.210
date	2015.09.23.14.09.40;	author okan;	state Exp;
branches;
next	1.209;
commitid	BlOm8klehmzQte7C;

1.209
date	2015.08.27.18.53.15;	author okan;	state Exp;
branches;
next	1.208;
commitid	zidCZkwdtbi68xMi;

1.208
date	2015.08.27.18.42.56;	author okan;	state Exp;
branches;
next	1.207;
commitid	koe4Jefm6ZQVksWN;

1.207
date	2015.08.27.18.40.09;	author okan;	state Exp;
branches;
next	1.206;
commitid	ebXPgx05apj92Rc8;

1.206
date	2015.08.25.18.29.10;	author okan;	state Exp;
branches;
next	1.205;
commitid	uqkKibG5fLGc4c6r;

1.205
date	2015.08.24.15.42.57;	author okan;	state Exp;
branches;
next	1.204;
commitid	xGzIdCzrHkoqADxN;

1.204
date	2015.08.24.14.57.19;	author okan;	state Exp;
branches;
next	1.203;
commitid	PJyUpejTkmMmaCv6;

1.203
date	2015.08.23.17.31.20;	author okan;	state Exp;
branches;
next	1.202;
commitid	m6evlaUZXnHGLcAq;

1.202
date	2015.08.21.16.52.37;	author okan;	state Exp;
branches;
next	1.201;
commitid	dg8NUwKKSZKDgRDL;

1.201
date	2015.08.21.16.30.02;	author okan;	state Exp;
branches;
next	1.200;
commitid	MiLmJumEJ6sclldP;

1.200
date	2015.08.21.16.14.39;	author okan;	state Exp;
branches;
next	1.199;
commitid	SoqEvJwZGG56KptJ;

1.199
date	2015.08.21.15.52.49;	author okan;	state Exp;
branches;
next	1.198;
commitid	zAGJnc67FRmueTYK;

1.198
date	2015.07.01.14.36.42;	author okan;	state Exp;
branches;
next	1.197;
commitid	HEkKIvh6L9ijX1lH;

1.197
date	2015.06.30.14.01.43;	author okan;	state Exp;
branches;
next	1.196;
commitid	h5qrb2HfsKgjVuzR;

1.196
date	2015.06.28.19.54.37;	author okan;	state Exp;
branches;
next	1.195;
commitid	oNAVvU2yffuQaSjD;

1.195
date	2015.06.28.19.50.46;	author okan;	state Exp;
branches;
next	1.194;
commitid	9QJos70x7Vh2VORU;

1.194
date	2015.06.26.17.17.46;	author okan;	state Exp;
branches;
next	1.193;
commitid	lHlj3PDNu98waqIr;

1.193
date	2015.06.08.15.11.29;	author okan;	state Exp;
branches;
next	1.192;
commitid	ZvSEr0vP6GhJmETT;

1.192
date	2015.05.20.23.54.39;	author okan;	state Exp;
branches;
next	1.191;
commitid	OLy4wiKj7HhFaejM;

1.191
date	2015.03.29.00.21.05;	author okan;	state Exp;
branches;
next	1.190;
commitid	MVF41ziRaafJanpz;

1.190
date	2015.01.23.19.35.11;	author okan;	state Exp;
branches;
next	1.189;
commitid	EgQNGnGkv9n6KWLx;

1.189
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.188;
commitid	kLADTGYX3gw0Sf2m;

1.188
date	2014.09.27.19.04.32;	author okan;	state Exp;
branches;
next	1.187;
commitid	X6SwRTs6gMlrxQ8N;

1.187
date	2014.09.17.18.41.44;	author okan;	state Exp;
branches;
next	1.186;
commitid	7QDlXoO0YzmTdgVS;

1.186
date	2014.09.17.18.09.30;	author okan;	state Exp;
branches;
next	1.185;
commitid	vjYvS7lYE7I0AXkO;

1.185
date	2014.09.17.16.30.21;	author okan;	state Exp;
branches;
next	1.184;
commitid	pPcCIidv9XCU2Zn5;

1.184
date	2014.09.17.16.00.44;	author okan;	state Exp;
branches;
next	1.183;
commitid	PwtpIdl7nXCakavw;

1.183
date	2014.09.15.13.00.49;	author okan;	state Exp;
branches;
next	1.182;
commitid	VPtTUp6sF9rrEiW2;

1.182
date	2014.09.10.20.30.38;	author okan;	state Exp;
branches;
next	1.181;
commitid	HyfJQMRwfxSnHKow;

1.181
date	2014.09.08.21.24.27;	author okan;	state Exp;
branches;
next	1.180;
commitid	fgEMPavrPRABGLg0;

1.180
date	2014.09.08.21.15.14;	author okan;	state Exp;
branches;
next	1.179;
commitid	os8IEZxNKyVrOZR1;

1.179
date	2014.09.08.20.37.02;	author okan;	state Exp;
branches;
next	1.178;
commitid	92lZdHAgSZ9gQ95l;

1.178
date	2014.09.08.20.32.40;	author okan;	state Exp;
branches;
next	1.177;
commitid	ftA9UvUOKNxBjJmC;

1.177
date	2014.09.08.20.11.22;	author okan;	state Exp;
branches;
next	1.176;
commitid	cu11ybsl8atTMRXD;

1.176
date	2014.09.07.19.27.30;	author okan;	state Exp;
branches;
next	1.175;
commitid	jXQ1fztXcP9vyPb1;

1.175
date	2014.09.07.17.38.38;	author okan;	state Exp;
branches;
next	1.174;
commitid	idgYRjbgDXLP4UK7;

1.174
date	2014.08.25.12.49.19;	author okan;	state Exp;
branches;
next	1.173;
commitid	rbGNqfikQcQWLop3;

1.173
date	2014.08.20.15.15.29;	author okan;	state Exp;
branches;
next	1.172;
commitid	SsDu0AngUZExtrz4;

1.172
date	2014.02.06.20.58.46;	author okan;	state Exp;
branches;
next	1.171;

1.171
date	2014.02.03.20.20.39;	author okan;	state Exp;
branches;
next	1.170;

1.170
date	2014.02.02.21.34.05;	author okan;	state Exp;
branches;
next	1.169;

1.169
date	2014.01.27.15.13.09;	author okan;	state Exp;
branches;
next	1.168;

1.168
date	2014.01.03.14.23.50;	author okan;	state Exp;
branches;
next	1.167;

1.167
date	2014.01.02.21.15.39;	author okan;	state Exp;
branches;
next	1.166;

1.166
date	2014.01.02.20.58.20;	author okan;	state Exp;
branches;
next	1.165;

1.165
date	2013.12.17.16.10.43;	author okan;	state Exp;
branches;
next	1.164;

1.164
date	2013.12.16.19.02.17;	author okan;	state Exp;
branches;
next	1.163;

1.163
date	2013.12.13.22.39.13;	author okan;	state Exp;
branches;
next	1.162;

1.162
date	2013.12.13.15.56.44;	author okan;	state Exp;
branches;
next	1.161;

1.161
date	2013.12.13.14.40.52;	author okan;	state Exp;
branches;
next	1.160;

1.160
date	2013.12.12.20.15.07;	author okan;	state Exp;
branches;
next	1.159;

1.159
date	2013.12.11.22.14.23;	author okan;	state Exp;
branches;
next	1.158;

1.158
date	2013.12.11.17.23.31;	author okan;	state Exp;
branches;
next	1.157;

1.157
date	2013.12.11.15.46.47;	author okan;	state Exp;
branches;
next	1.156;

1.156
date	2013.12.11.15.41.11;	author okan;	state Exp;
branches;
next	1.155;

1.155
date	2013.12.11.14.16.09;	author okan;	state Exp;
branches;
next	1.154;

1.154
date	2013.12.11.14.09.21;	author okan;	state Exp;
branches;
next	1.153;

1.153
date	2013.12.10.21.27.37;	author okan;	state Exp;
branches;
next	1.152;

1.152
date	2013.11.27.17.04.35;	author okan;	state Exp;
branches;
next	1.151;

1.151
date	2013.11.27.14.20.32;	author okan;	state Exp;
branches;
next	1.150;

1.150
date	2013.11.27.00.01.23;	author okan;	state Exp;
branches;
next	1.149;

1.149
date	2013.11.12.21.25.00;	author okan;	state Exp;
branches;
next	1.148;

1.148
date	2013.11.11.12.51.15;	author okan;	state Exp;
branches;
next	1.147;

1.147
date	2013.11.08.17.35.12;	author okan;	state Exp;
branches;
next	1.146;

1.146
date	2013.11.05.00.55.42;	author okan;	state Exp;
branches;
next	1.145;

1.145
date	2013.11.02.19.13.57;	author okan;	state Exp;
branches;
next	1.144;

1.144
date	2013.11.01.21.54.20;	author okan;	state Exp;
branches;
next	1.143;

1.143
date	2013.11.01.14.07.19;	author okan;	state Exp;
branches;
next	1.142;

1.142
date	2013.10.25.19.46.16;	author okan;	state Exp;
branches;
next	1.141;

1.141
date	2013.10.20.01.35.47;	author okan;	state Exp;
branches;
next	1.140;

1.140
date	2013.10.19.19.39.34;	author okan;	state Exp;
branches;
next	1.139;

1.139
date	2013.10.19.18.59.22;	author okan;	state Exp;
branches;
next	1.138;

1.138
date	2013.10.19.00.24.54;	author okan;	state Exp;
branches;
next	1.137;

1.137
date	2013.10.03.13.51.59;	author okan;	state Exp;
branches;
next	1.136;

1.136
date	2013.07.15.23.51.59;	author okan;	state Exp;
branches;
next	1.135;

1.135
date	2013.07.15.14.50.44;	author okan;	state Exp;
branches;
next	1.134;

1.134
date	2013.06.10.21.37.30;	author okan;	state Exp;
branches;
next	1.133;

1.133
date	2013.05.23.16.52.39;	author okan;	state Exp;
branches;
next	1.132;

1.132
date	2013.05.20.21.13.58;	author okan;	state Exp;
branches;
next	1.131;

1.131
date	2013.05.19.23.09.59;	author okan;	state Exp;
branches;
next	1.130;

1.130
date	2013.05.19.17.02.04;	author okan;	state Exp;
branches;
next	1.129;

1.129
date	2013.05.11.22.01.07;	author okan;	state Exp;
branches;
next	1.128;

1.128
date	2013.05.06.16.03.11;	author okan;	state Exp;
branches;
next	1.127;

1.127
date	2013.04.17.13.57.06;	author okan;	state Exp;
branches;
next	1.126;

1.126
date	2013.04.17.13.52.20;	author okan;	state Exp;
branches;
next	1.125;

1.125
date	2013.04.14.16.13.17;	author okan;	state Exp;
branches;
next	1.124;

1.124
date	2013.04.12.20.54.27;	author okan;	state Exp;
branches;
next	1.123;

1.123
date	2013.04.12.20.45.57;	author okan;	state Exp;
branches;
next	1.122;

1.122
date	2013.04.05.17.07.25;	author okan;	state Exp;
branches;
next	1.121;

1.121
date	2013.04.03.20.22.55;	author okan;	state Exp;
branches;
next	1.120;

1.120
date	2013.04.03.19.20.50;	author okan;	state Exp;
branches;
next	1.119;

1.119
date	2013.01.08.15.16.05;	author okan;	state Exp;
branches;
next	1.118;

1.118
date	2013.01.08.04.12.51;	author okan;	state Exp;
branches;
next	1.117;

1.117
date	2013.01.07.21.53.23;	author okan;	state Exp;
branches;
next	1.116;

1.116
date	2013.01.06.01.01.26;	author okan;	state Exp;
branches;
next	1.115;

1.115
date	2013.01.04.16.30.03;	author okan;	state Exp;
branches;
next	1.114;

1.114
date	2013.01.04.16.23.04;	author okan;	state Exp;
branches;
next	1.113;

1.113
date	2013.01.02.21.37.21;	author okan;	state Exp;
branches;
next	1.112;

1.112
date	2013.01.02.16.26.34;	author okan;	state Exp;
branches;
next	1.111;

1.111
date	2013.01.02.02.19.20;	author okan;	state Exp;
branches;
next	1.110;

1.110
date	2013.01.02.02.02.08;	author okan;	state Exp;
branches;
next	1.109;

1.109
date	2013.01.01.14.26.29;	author okan;	state Exp;
branches;
next	1.108;

1.108
date	2013.01.01.14.19.56;	author okan;	state Exp;
branches;
next	1.107;

1.107
date	2012.12.17.18.35.26;	author okan;	state Exp;
branches;
next	1.106;

1.106
date	2012.12.17.17.48.57;	author okan;	state Exp;
branches;
next	1.105;

1.105
date	2012.12.17.14.58.46;	author okan;	state Exp;
branches;
next	1.104;

1.104
date	2012.12.17.14.26.29;	author okan;	state Exp;
branches;
next	1.103;

1.103
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.102;

1.102
date	2012.11.07.20.34.39;	author okan;	state Exp;
branches;
next	1.101;

1.101
date	2012.09.09.19.47.47;	author okan;	state Exp;
branches;
next	1.100;

1.100
date	2012.07.16.01.53.14;	author okan;	state Exp;
branches;
next	1.99;

1.99
date	2012.07.16.01.36.30;	author okan;	state Exp;
branches;
next	1.98;

1.98
date	2012.07.13.17.01.04;	author okan;	state Exp;
branches;
next	1.97;

1.97
date	2012.07.13.15.21.35;	author okan;	state Exp;
branches;
next	1.96;

1.96
date	2012.07.04.18.00.13;	author okan;	state Exp;
branches;
next	1.95;

1.95
date	2012.07.03.13.49.03;	author okan;	state Exp;
branches;
next	1.94;

1.94
date	2012.05.16.01.09.17;	author okan;	state Exp;
branches;
next	1.93;

1.93
date	2012.05.13.15.17.13;	author okan;	state Exp;
branches;
next	1.92;

1.92
date	2012.05.13.15.15.54;	author okan;	state Exp;
branches;
next	1.91;

1.91
date	2011.09.13.08.41.57;	author okan;	state Exp;
branches;
next	1.90;

1.90
date	2011.09.05.07.37.55;	author okan;	state Exp;
branches;
next	1.89;

1.89
date	2011.09.04.16.59.31;	author oga;	state Exp;
branches;
next	1.88;

1.88
date	2011.09.03.09.42.33;	author okan;	state Exp;
branches;
next	1.87;

1.87
date	2011.09.03.09.20.58;	author okan;	state Exp;
branches;
next	1.86;

1.86
date	2011.07.14.11.39.53;	author okan;	state Exp;
branches;
next	1.85;

1.85
date	2011.06.24.06.06.24;	author okan;	state Exp;
branches;
next	1.84;

1.84
date	2011.06.24.06.01.47;	author okan;	state Exp;
branches;
next	1.83;

1.83
date	2011.06.24.05.40.09;	author okan;	state Exp;
branches;
next	1.82;

1.82
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.81;

1.81
date	2011.05.07.17.15.37;	author okan;	state Exp;
branches;
next	1.80;

1.80
date	2011.03.22.10.56.08;	author okan;	state Exp;
branches;
next	1.79;

1.79
date	2011.03.22.10.52.37;	author okan;	state Exp;
branches;
next	1.78;

1.78
date	2011.03.22.10.49.46;	author okan;	state Exp;
branches;
next	1.77;

1.77
date	2011.02.13.20.09.57;	author okan;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.22.22.10.31;	author okan;	state Exp;
branches;
next	1.75;

1.75
date	2010.04.11.16.51.26;	author okan;	state Exp;
branches;
next	1.74;

1.74
date	2010.02.02.19.28.46;	author stsp;	state Exp;
branches;
next	1.73;

1.73
date	2010.01.27.03.04.50;	author okan;	state Exp;
branches;
next	1.72;

1.72
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.71;

1.71
date	2009.12.15.03.34.34;	author okan;	state Exp;
branches;
next	1.70;

1.70
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.69;

1.69
date	2009.12.10.17.16.51;	author oga;	state Exp;
branches;
next	1.68;

1.68
date	2009.12.07.22.46.15;	author oga;	state Exp;
branches;
next	1.67;

1.67
date	2009.12.07.22.21.59;	author oga;	state Exp;
branches;
next	1.66;

1.66
date	2009.11.28.17.52.12;	author tobias;	state Exp;
branches;
next	1.65;

1.65
date	2009.09.25.15.57.49;	author oga;	state Exp;
branches;
next	1.64;

1.64
date	2009.08.27.01.38.08;	author okan;	state Exp;
branches;
next	1.63;

1.63
date	2009.08.25.01.32.40;	author oga;	state Exp;
branches;
next	1.62;

1.62
date	2009.08.25.01.26.09;	author okan;	state Exp;
branches;
next	1.61;

1.61
date	2009.08.24.23.54.41;	author oga;	state Exp;
branches;
next	1.60;

1.60
date	2009.08.24.23.49.04;	author okan;	state Exp;
branches;
next	1.59;

1.59
date	2009.08.24.21.22.48;	author oga;	state Exp;
branches;
next	1.58;

1.58
date	2009.08.24.17.04.39;	author oga;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.26.12.21.58;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.23.21.52.38;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.20.00.55.41;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.20.00.22.39;	author okan;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.20.00.19.56;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2009.06.17.12.45.01;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2009.05.30.00.30.17;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2009.05.18.00.23.35;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.17.23.40.57;	author okan;	state Exp;
branches;
next	1.48;

1.48
date	2009.05.17.16.51.43;	author sthen;	state Exp;
branches;
next	1.47;

1.47
date	2009.01.23.20.47.45;	author okan;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.22.19.01.56;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.22.15.26.33;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.17.18.41.50;	author oga;	state Exp;
branches;
next	1.43;

1.43
date	2009.01.16.15.24.14;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.15.00.32.35;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.29.23.16.46;	author oga;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.22.14.28.04;	author oga;	state Exp;
branches;
next	1.39;

1.39
date	2008.09.22.14.15.03;	author oga;	state Exp;
branches;
next	1.38;

1.38
date	2008.07.15.22.12.09;	author okan;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.15.22.06.48;	author okan;	state Exp;
branches;
next	1.36;

1.36
date	2008.07.15.13.52.02;	author okan;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.11.14.23.30;	author okan;	state Exp;
branches;
next	1.34;

1.34
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.30.17.52.37;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.25.22.37.29;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.18.20.42.29;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.14.22.04.11;	author okan;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.12.04.59.51;	author okan;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.23.18.57.35;	author okan;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.20.14.50.51;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.19.17.24.19;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.19.15.17.50;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.19.12.56.58;	author okan;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.18.20.00.16;	author okan;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.17.03.59.54;	author okan;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.15.22.18.00;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.15.21.56.21;	author okan;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.01.18.01.13;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.16.13.35.37;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.15.18.46.58;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.09.18.10.47;	author okan;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.26.15.45.42;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.03.22.15.09.45;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.03.19.00.18.28;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.16.11.39.20;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.03.20.20.20;	author marc;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.01.22.28.59;	author marc;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.02.18.01.45;	author jasper;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.08.16.29.19;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.05.19.03.20;	author jasper;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.29.22.38.44;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.29.22.35.04;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.240
log
@Ensure clients stay within the viewable bounds on placement, even with empty
borders; based on a patch from Vadim Vygonets.
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Marius Aamodt Eriksen <marius@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: client.c,v 1.239 2017/05/01 12:54:55 okan Exp $
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <err.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

static struct client_ctx	*client_next(struct client_ctx *);
static struct client_ctx	*client_prev(struct client_ctx *);
static void			 client_mtf(struct client_ctx *);
static void			 client_placecalc(struct client_ctx *);
static void			 client_wm_protocols(struct client_ctx *);
static void			 client_mwm_hints(struct client_ctx *);

struct client_ctx *
client_init(Window win, struct screen_ctx *sc, int active)
{
	struct client_ctx	*cc;
	XWindowAttributes	 wattr;
	int			 mapped;
	Window			 rwin, cwin;
	int			 x, y, wx, wy;
	unsigned int		 mask;

	if (win == None)
		return(NULL);
	if (!XGetWindowAttributes(X_Dpy, win, &wattr))
		return(NULL);

	if (sc == NULL) {
		if ((sc = screen_find(wattr.root)) == NULL)
			return(NULL);
		mapped = 1;
	} else {
		if (wattr.override_redirect || wattr.map_state != IsViewable)
			return(NULL);
		mapped = wattr.map_state != IsUnmapped;
	}

	cc = xmalloc(sizeof(*cc));

	XGrabServer(X_Dpy);

	cc->sc = sc;
	cc->win = win;
	cc->label = NULL;
	cc->gc = NULL;
	cc->flags = 0;
	cc->stackingorder = 0;
	memset(&cc->hint, 0, sizeof(cc->hint));
	memset(&cc->ch, 0, sizeof(cc->ch));

	TAILQ_INIT(&cc->nameq);
	client_setname(cc);

	conf_client(cc);

	XGetClassHint(X_Dpy, cc->win, &cc->ch);
	client_wm_hints(cc);
	client_wm_protocols(cc);
	client_getsizehints(cc);
	client_mwm_hints(cc);

	cc->geom.x = wattr.x;
	cc->geom.y = wattr.y;
	cc->geom.w = wattr.width;
	cc->geom.h = wattr.height;
	cc->dim.w = (cc->geom.w - cc->hint.basew) / cc->hint.incw;
	cc->dim.h = (cc->geom.h - cc->hint.baseh) / cc->hint.inch;
	cc->ptr.x = cc->geom.w / 2;
	cc->ptr.y = cc->geom.h / 2;

	cc->colormap = wattr.colormap;

	if (wattr.map_state != IsViewable) {
		client_placecalc(cc);
		client_resize(cc, 0);
		if ((cc->wmh) && (cc->wmh->flags & StateHint))
			client_set_wm_state(cc, cc->wmh->initial_state);
	} else {
		if ((active == 0) && (XQueryPointer(X_Dpy, cc->win, &rwin, &cwin,
		    &x, &y, &wx, &wy, &mask)) && (cwin != None))
			active = 1;
	}

	XSelectInput(X_Dpy, cc->win, ColormapChangeMask | EnterWindowMask |
	    PropertyChangeMask | KeyReleaseMask);

	XAddToSaveSet(X_Dpy, cc->win);

	client_transient(cc);

	/* Notify client of its configuration. */
	client_config(cc);

	TAILQ_INSERT_TAIL(&sc->clientq, cc, entry);

	xu_ewmh_net_client_list(sc);
	xu_ewmh_net_client_list_stacking(sc);
	xu_ewmh_restore_net_wm_state(cc);

	if (client_get_wm_state(cc) == IconicState)
		client_hide(cc);
	else
		client_unhide(cc);

	if (mapped) {
		if (group_restore(cc))
			goto out;
		if (group_autogroup(cc))
			goto out;
		if (Conf.stickygroups)
			group_assign(sc->group_active, cc);
		else
			group_assign(NULL, cc);
	}
out:
	XSync(X_Dpy, False);
	XUngrabServer(X_Dpy);

	if (active)
		client_setactive(cc);

	return(cc);
}

struct client_ctx *
client_find(Window win)
{
	struct screen_ctx	*sc;
	struct client_ctx	*cc;

	TAILQ_FOREACH(sc, &Screenq, entry) {
		TAILQ_FOREACH(cc, &sc->clientq, entry) {
			if (cc->win == win)
				return(cc);
		}
	}
	return(NULL);
}

void
client_delete(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct winname		*wn;

	TAILQ_REMOVE(&sc->clientq, cc, entry);

	xu_ewmh_net_client_list(sc);
	xu_ewmh_net_client_list_stacking(sc);

	if (cc->flags & CLIENT_ACTIVE)
		xu_ewmh_net_active_window(sc, None);

	if (cc->gc != NULL)
		TAILQ_REMOVE(&cc->gc->clientq, cc, group_entry);

	while ((wn = TAILQ_FIRST(&cc->nameq)) != NULL) {
		TAILQ_REMOVE(&cc->nameq, wn, entry);
		free(wn->name);
		free(wn);
	}

	if (cc->ch.res_class)
		XFree(cc->ch.res_class);
	if (cc->ch.res_name)
		XFree(cc->ch.res_name);
	if (cc->wmh)
		XFree(cc->wmh);

	free(cc);
}

void
client_setactive(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct client_ctx	*oldcc;

	if (cc->flags & CLIENT_HIDDEN)
		return;

	XInstallColormap(X_Dpy, cc->colormap);

	if ((cc->flags & CLIENT_INPUT) ||
	    (!(cc->flags & CLIENT_WM_TAKE_FOCUS))) {
		XSetInputFocus(X_Dpy, cc->win,
		    RevertToPointerRoot, CurrentTime);
	}
	if (cc->flags & CLIENT_WM_TAKE_FOCUS)
		client_msg(cc, cwmh[WM_TAKE_FOCUS], Last_Event_Time);

	if ((oldcc = client_current()) != NULL) {
		oldcc->flags &= ~CLIENT_ACTIVE;
		client_draw_border(oldcc);
	}

	/* If we're in the middle of cycing, don't change the order. */
	if (!sc->cycling)
		client_mtf(cc);

	cc->flags |= CLIENT_ACTIVE;
	cc->flags &= ~CLIENT_URGENCY;
	client_draw_border(cc);
	conf_grab_mouse(cc->win);
	xu_ewmh_net_active_window(sc, cc->win);
}

struct client_ctx *
client_current(void)
{
	struct screen_ctx	*sc;
	struct client_ctx	*cc;

	TAILQ_FOREACH(sc, &Screenq, entry) {
		TAILQ_FOREACH(cc, &sc->clientq, entry) {
			if (cc->flags & CLIENT_ACTIVE)
				return(cc);
		}
	}
	return(NULL);
}

void
client_toggle_freeze(struct client_ctx *cc)
{
	if (cc->flags & CLIENT_FULLSCREEN)
		return;

	cc->flags ^= CLIENT_FREEZE;
	xu_ewmh_set_net_wm_state(cc);
}

void
client_toggle_hidden(struct client_ctx *cc)
{
	cc->flags ^= CLIENT_HIDDEN;
	xu_ewmh_set_net_wm_state(cc);
}

void
client_toggle_sticky(struct client_ctx *cc)
{
	cc->flags ^= CLIENT_STICKY;
	xu_ewmh_set_net_wm_state(cc);
}

void
client_toggle_fullscreen(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct geom		 area;

	if ((cc->flags & CLIENT_FREEZE) &&
	    !(cc->flags & CLIENT_FULLSCREEN))
		return;

	if (cc->flags & CLIENT_FULLSCREEN) {
		if (!(cc->flags & CLIENT_IGNORE))
			cc->bwidth = Conf.bwidth;
		cc->geom = cc->fullgeom;
		cc->flags &= ~(CLIENT_FULLSCREEN | CLIENT_FREEZE);
		goto resize;
	}

	cc->fullgeom = cc->geom;

	area = screen_area(sc,
	    cc->geom.x + cc->geom.w / 2,
	    cc->geom.y + cc->geom.h / 2, CWM_NOGAP);

	cc->bwidth = 0;
	cc->geom = area;
	cc->flags |= (CLIENT_FULLSCREEN | CLIENT_FREEZE);

resize:
	client_resize(cc, 0);
	xu_ewmh_set_net_wm_state(cc);
}

void
client_toggle_maximize(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct geom		 area;

	if (cc->flags & CLIENT_FREEZE)
		return;

	if ((cc->flags & CLIENT_MAXFLAGS) == CLIENT_MAXIMIZED) {
		cc->geom = cc->savegeom;
		cc->flags &= ~CLIENT_MAXIMIZED;
		goto resize;
	}

	if (!(cc->flags & CLIENT_VMAXIMIZED)) {
		cc->savegeom.h = cc->geom.h;
		cc->savegeom.y = cc->geom.y;
	}

	if (!(cc->flags & CLIENT_HMAXIMIZED)) {
		cc->savegeom.w = cc->geom.w;
		cc->savegeom.x = cc->geom.x;
	}

	/*
	 * pick screen that the middle of the window is on.
	 * that's probably more fair than if just the origin of
	 * a window is poking over a boundary
	 */
	area = screen_area(sc,
	    cc->geom.x + cc->geom.w / 2,
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);

	cc->geom.x = area.x;
	cc->geom.y = area.y;
	cc->geom.w = area.w - (cc->bwidth * 2);
	cc->geom.h = area.h - (cc->bwidth * 2);
	cc->flags |= CLIENT_MAXIMIZED;

resize:
	client_resize(cc, 0);
	xu_ewmh_set_net_wm_state(cc);
}

void
client_toggle_vmaximize(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct geom		 area;

	if (cc->flags & CLIENT_FREEZE)
		return;

	if (cc->flags & CLIENT_VMAXIMIZED) {
		cc->geom.y = cc->savegeom.y;
		cc->geom.h = cc->savegeom.h;
		cc->flags &= ~CLIENT_VMAXIMIZED;
		goto resize;
	}

	cc->savegeom.y = cc->geom.y;
	cc->savegeom.h = cc->geom.h;

	area = screen_area(sc,
	    cc->geom.x + cc->geom.w / 2,
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);

	cc->geom.y = area.y;
	cc->geom.h = area.h - (cc->bwidth * 2);
	cc->flags |= CLIENT_VMAXIMIZED;

resize:
	client_resize(cc, 0);
	xu_ewmh_set_net_wm_state(cc);
}

void
client_toggle_hmaximize(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct geom		 area;

	if (cc->flags & CLIENT_FREEZE)
		return;

	if (cc->flags & CLIENT_HMAXIMIZED) {
		cc->geom.x = cc->savegeom.x;
		cc->geom.w = cc->savegeom.w;
		cc->flags &= ~CLIENT_HMAXIMIZED;
		goto resize;
	}

	cc->savegeom.x = cc->geom.x;
	cc->savegeom.w = cc->geom.w;

	area = screen_area(sc,
	    cc->geom.x + cc->geom.w / 2,
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);

	cc->geom.x = area.x;
	cc->geom.w = area.w - (cc->bwidth * 2);
	cc->flags |= CLIENT_HMAXIMIZED;

resize:
	client_resize(cc, 0);
	xu_ewmh_set_net_wm_state(cc);
}

void
client_resize(struct client_ctx *cc, int reset)
{
	if (reset) {
		cc->flags &= ~CLIENT_MAXIMIZED;
		xu_ewmh_set_net_wm_state(cc);
	}

	client_draw_border(cc);

	XMoveResizeWindow(X_Dpy, cc->win, cc->geom.x,
	    cc->geom.y, cc->geom.w, cc->geom.h);
	cc->dim.w = (cc->geom.w - cc->hint.basew) / cc->hint.incw;
	cc->dim.h = (cc->geom.h - cc->hint.baseh) / cc->hint.inch;
	client_config(cc);
}

void
client_move(struct client_ctx *cc)
{
	XMoveWindow(X_Dpy, cc->win, cc->geom.x, cc->geom.y);
	client_config(cc);
}

void
client_lower(struct client_ctx *cc)
{
	XLowerWindow(X_Dpy, cc->win);
}

void
client_raise(struct client_ctx *cc)
{
	XRaiseWindow(X_Dpy, cc->win);
}

void
client_config(struct client_ctx *cc)
{
	XConfigureEvent	 cn;

	(void)memset(&cn, 0, sizeof(cn));
	cn.type = ConfigureNotify;
	cn.event = cc->win;
	cn.window = cc->win;
	cn.x = cc->geom.x;
	cn.y = cc->geom.y;
	cn.width = cc->geom.w;
	cn.height = cc->geom.h;
	cn.border_width = cc->bwidth;
	cn.above = None;
	cn.override_redirect = 0;

	XSendEvent(X_Dpy, cc->win, False, StructureNotifyMask, (XEvent *)&cn);
}

void
client_ptr_inbound(struct client_ctx *cc, int getpos)
{
	if (getpos)
		xu_ptr_getpos(cc->win, &cc->ptr.x, &cc->ptr.y);

	if (cc->ptr.x < 0)
		cc->ptr.x = 0;
	else if (cc->ptr.x > cc->geom.w - 1)
		cc->ptr.x = cc->geom.w - 1;
	if (cc->ptr.y < 0)
		cc->ptr.y = 0;
	else if (cc->ptr.y > cc->geom.h - 1)
		cc->ptr.y = cc->geom.h - 1;

	client_ptrwarp(cc);
}

void
client_ptrwarp(struct client_ctx *cc)
{
	xu_ptr_setpos(cc->win, cc->ptr.x, cc->ptr.y);
}

void
client_ptrsave(struct client_ctx *cc)
{
	int	 x, y;

	xu_ptr_getpos(cc->win, &x, &y);
	if (client_inbound(cc, x, y)) {
		cc->ptr.x = x;
		cc->ptr.y = y;
	} else {
		cc->ptr.x = cc->geom.w / 2;
		cc->ptr.y = cc->geom.h / 2;
	}
}

void
client_hide(struct client_ctx *cc)
{
	XUnmapWindow(X_Dpy, cc->win);

	if (cc->flags & CLIENT_ACTIVE)
		xu_ewmh_net_active_window(cc->sc, None);

	cc->flags &= ~CLIENT_ACTIVE;
	cc->flags |= CLIENT_HIDDEN;
	client_set_wm_state(cc, IconicState);
}

void
client_unhide(struct client_ctx *cc)
{
	XMapRaised(X_Dpy, cc->win);

	cc->flags &= ~CLIENT_HIDDEN;
	client_set_wm_state(cc, NormalState);
	client_draw_border(cc);
}

void
client_urgency(struct client_ctx *cc)
{
	if (!(cc->flags & CLIENT_ACTIVE))
		cc->flags |= CLIENT_URGENCY;
}

void
client_draw_border(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	unsigned long		 pixel;

	if (cc->flags & CLIENT_ACTIVE)
		switch (cc->flags & CLIENT_HIGHLIGHT) {
		case CLIENT_GROUP:
			pixel = sc->xftcolor[CWM_COLOR_BORDER_GROUP].pixel;
			break;
		case CLIENT_UNGROUP:
			pixel = sc->xftcolor[CWM_COLOR_BORDER_UNGROUP].pixel;
			break;
		default:
			pixel = sc->xftcolor[CWM_COLOR_BORDER_ACTIVE].pixel;
			break;
		}
	else
		pixel = sc->xftcolor[CWM_COLOR_BORDER_INACTIVE].pixel;

	if (cc->flags & CLIENT_URGENCY)
		pixel = sc->xftcolor[CWM_COLOR_BORDER_URGENCY].pixel;

	XSetWindowBorderWidth(X_Dpy, cc->win, (unsigned int)cc->bwidth);
	XSetWindowBorder(X_Dpy, cc->win, pixel);
}

static void
client_wm_protocols(struct client_ctx *cc)
{
	Atom	*p;
	int	 i, j;

	if (XGetWMProtocols(X_Dpy, cc->win, &p, &j)) {
		for (i = 0; i < j; i++) {
			if (p[i] == cwmh[WM_DELETE_WINDOW])
				cc->flags |= CLIENT_WM_DELETE_WINDOW;
			else if (p[i] == cwmh[WM_TAKE_FOCUS])
				cc->flags |= CLIENT_WM_TAKE_FOCUS;
		}
		XFree(p);
	}
}

void
client_wm_hints(struct client_ctx *cc)
{
	if ((cc->wmh = XGetWMHints(X_Dpy, cc->win)) == NULL)
		return;

	if ((cc->wmh->flags & InputHint) && (cc->wmh->input))
		cc->flags |= CLIENT_INPUT;

	if ((cc->wmh->flags & XUrgencyHint))
		client_urgency(cc);
}

void
client_msg(struct client_ctx *cc, Atom proto, Time ts)
{
	XClientMessageEvent	 cm;

	(void)memset(&cm, 0, sizeof(cm));
	cm.type = ClientMessage;
	cm.window = cc->win;
	cm.message_type = cwmh[WM_PROTOCOLS];
	cm.format = 32;
	cm.data.l[0] = proto;
	cm.data.l[1] = ts;

	XSendEvent(X_Dpy, cc->win, False, NoEventMask, (XEvent *)&cm);
}

void
client_send_delete(struct client_ctx *cc)
{
	if (cc->flags & CLIENT_WM_DELETE_WINDOW)
		client_msg(cc, cwmh[WM_DELETE_WINDOW], CurrentTime);
	else
		XKillClient(X_Dpy, cc->win);
}

void
client_setname(struct client_ctx *cc)
{
	struct winname	*wn;
	char		*newname;
	int		 i = 0;

	if (!xu_getstrprop(cc->win, ewmh[_NET_WM_NAME], &newname))
		if (!xu_getstrprop(cc->win, XA_WM_NAME, &newname))
			newname = xstrdup("");

	TAILQ_FOREACH(wn, &cc->nameq, entry) {
		if (strcmp(wn->name, newname) == 0) {
			/* Move to the last since we got a hit. */
			TAILQ_REMOVE(&cc->nameq, wn, entry);
			TAILQ_INSERT_TAIL(&cc->nameq, wn, entry);
			goto match;
		}
	}
	wn = xmalloc(sizeof(*wn));
	wn->name = newname;
	TAILQ_INSERT_TAIL(&cc->nameq, wn, entry);

match:
	cc->name = wn->name;

	/* Do some garbage collection. */
	TAILQ_FOREACH(wn, &cc->nameq, entry)
		i++;
	if (i > Conf.nameqlen) {
		wn = TAILQ_FIRST(&cc->nameq);
		TAILQ_REMOVE(&cc->nameq, wn, entry);
		free(wn->name);
		free(wn);
		i--;
	}
}

void
client_cycle(struct screen_ctx *sc, int flags)
{
	struct client_ctx	*newcc, *oldcc, *prevcc;
	int			 again = 1;

	/* For X apps that ignore events. */
	XGrabKeyboard(X_Dpy, sc->rootwin, True,
	    GrabModeAsync, GrabModeAsync, CurrentTime);

	if (TAILQ_EMPTY(&sc->clientq))
		return;

	prevcc = TAILQ_FIRST(&sc->clientq);
	oldcc = client_current();
	if (oldcc == NULL)
		oldcc = (flags & CWM_CYCLE_REVERSE) ?
		    TAILQ_LAST(&sc->clientq, client_q) :
		    TAILQ_FIRST(&sc->clientq);

	newcc = oldcc;
	while (again) {
		again = 0;

		newcc = (flags & CWM_CYCLE_REVERSE) ? client_prev(newcc) :
		    client_next(newcc);

		/* Only cycle visible and non-ignored windows. */
		if ((newcc->flags & (CLIENT_HIDDEN | CLIENT_IGNORE))
		    || ((flags & CWM_CYCLE_INGROUP) &&
			(newcc->gc != oldcc->gc)))
			again = 1;

		/* Is oldcc the only non-hidden window? */
		if (newcc == oldcc) {
			if (again)
				return;	/* No windows visible. */

			break;
		}
	}

	/* reset when cycling mod is released. XXX I hate this hack */
	sc->cycling = 1;
	client_ptrsave(oldcc);
	client_raise(prevcc);
	client_raise(newcc);
	if (!client_inbound(newcc, newcc->ptr.x, newcc->ptr.y)) {
		newcc->ptr.x = newcc->geom.w / 2;
		newcc->ptr.y = newcc->geom.h / 2;
	}
	client_ptrwarp(newcc);
}

void
client_cycle_leave(struct screen_ctx *sc)
{
	struct client_ctx	*cc;

	sc->cycling = 0;

	if ((cc = client_current()) != NULL) {
		client_mtf(cc);
		cc->flags &= ~CLIENT_HIGHLIGHT;
		client_draw_border(cc);
		XUngrabKeyboard(X_Dpy, CurrentTime);
	}
}

static struct client_ctx *
client_next(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct client_ctx	*newcc;

	return(((newcc = TAILQ_NEXT(cc, entry)) != NULL) ?
	    newcc : TAILQ_FIRST(&sc->clientq));
}

static struct client_ctx *
client_prev(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	struct client_ctx	*newcc;

	return(((newcc = TAILQ_PREV(cc, client_q, entry)) != NULL) ?
	    newcc : TAILQ_LAST(&sc->clientq, client_q));
}

static void
client_placecalc(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;
	int			 xslack, yslack;

	if (cc->hint.flags & (USPosition | PPosition)) {
		int			 wmax, hmax;

		wmax = DisplayWidth(X_Dpy, sc->which);
		hmax = DisplayHeight(X_Dpy, sc->which);

		if (cc->geom.x >= wmax)
			cc->geom.x = wmax - cc->bwidth - 1;
		if (cc->geom.x + cc->geom.w + cc->bwidth <= 0)
			cc->geom.x = -(cc->geom.w + cc->bwidth - 1);
		if (cc->geom.y >= hmax)
			cc->geom.x = hmax - cc->bwidth - 1;
		if (cc->geom.y + cc->geom.h + cc->bwidth <= 0)
			cc->geom.y = -(cc->geom.h + cc->bwidth - 1);
	} else {
		struct geom		 area;
		int			 xmouse, ymouse;

		xu_ptr_getpos(sc->rootwin, &xmouse, &ymouse);
		area = screen_area(sc, xmouse, ymouse, CWM_GAP);
		area.w += area.x;
		area.h += area.y;
		xmouse = MAX(xmouse, area.x) - cc->geom.w / 2;
		ymouse = MAX(ymouse, area.y) - cc->geom.h / 2;

		xmouse = MAX(xmouse, area.x);
		ymouse = MAX(ymouse, area.y);

		xslack = area.w - cc->geom.w - cc->bwidth * 2;
		yslack = area.h - cc->geom.h - cc->bwidth * 2;

		if (xslack >= area.x) {
			cc->geom.x = MAX(MIN(xmouse, xslack), area.x);
		} else {
			cc->geom.x = area.x;
			cc->geom.w = area.w;
		}
		if (yslack >= area.y) {
			cc->geom.y = MAX(MIN(ymouse, yslack), area.y);
		} else {
			cc->geom.y = area.y;
			cc->geom.h = area.h;
		}
	}
}

static void
client_mtf(struct client_ctx *cc)
{
	struct screen_ctx	*sc = cc->sc;

	TAILQ_REMOVE(&sc->clientq, cc, entry);
	TAILQ_INSERT_HEAD(&sc->clientq, cc, entry);
}

void
client_getsizehints(struct client_ctx *cc)
{
	long		 tmp;
	XSizeHints	 size;

	if (!XGetWMNormalHints(X_Dpy, cc->win, &size, &tmp))
		size.flags = 0;

	cc->hint.flags = size.flags;

	if (size.flags & PBaseSize) {
		cc->hint.basew = size.base_width;
		cc->hint.baseh = size.base_height;
	} else if (size.flags & PMinSize) {
		cc->hint.basew = size.min_width;
		cc->hint.baseh = size.min_height;
	}
	if (size.flags & PMinSize) {
		cc->hint.minw = size.min_width;
		cc->hint.minh = size.min_height;
	} else if (size.flags & PBaseSize) {
		cc->hint.minw = size.base_width;
		cc->hint.minh = size.base_height;
	}
	if (size.flags & PMaxSize) {
		cc->hint.maxw = size.max_width;
		cc->hint.maxh = size.max_height;
	}
	if (size.flags & PResizeInc) {
		cc->hint.incw = size.width_inc;
		cc->hint.inch = size.height_inc;
	}
	cc->hint.incw = MAX(1, cc->hint.incw);
	cc->hint.inch = MAX(1, cc->hint.inch);
	cc->hint.minw = MAX(1, cc->hint.minw);
	cc->hint.minh = MAX(1, cc->hint.minh);

	if (size.flags & PAspect) {
		if (size.min_aspect.x > 0)
			cc->hint.mina = (float)size.min_aspect.y /
			    size.min_aspect.x;
		if (size.max_aspect.y > 0)
			cc->hint.maxa = (float)size.max_aspect.x /
			    size.max_aspect.y;
	}
}

void
client_applysizehints(struct client_ctx *cc)
{
	Bool		 baseismin;

	baseismin = (cc->hint.basew == cc->hint.minw) &&
	    (cc->hint.baseh == cc->hint.minh);

	/* temporarily remove base dimensions, ICCCM 4.1.2.3 */
	if (!baseismin) {
		cc->geom.w -= cc->hint.basew;
		cc->geom.h -= cc->hint.baseh;
	}

	/* adjust for aspect limits */
	if (cc->hint.mina && cc->hint.maxa) {
		if (cc->hint.maxa < (float)cc->geom.w / cc->geom.h)
			cc->geom.w = cc->geom.h * cc->hint.maxa;
		else if (cc->hint.mina < (float)cc->geom.h / cc->geom.w)
			cc->geom.h = cc->geom.w * cc->hint.mina;
	}

	/* remove base dimensions for increment */
	if (baseismin) {
		cc->geom.w -= cc->hint.basew;
		cc->geom.h -= cc->hint.baseh;
	}

	/* adjust for increment value */
	cc->geom.w -= cc->geom.w % cc->hint.incw;
	cc->geom.h -= cc->geom.h % cc->hint.inch;

	/* restore base dimensions */
	cc->geom.w += cc->hint.basew;
	cc->geom.h += cc->hint.baseh;

	/* adjust for min width/height */
	cc->geom.w = MAX(cc->geom.w, cc->hint.minw);
	cc->geom.h = MAX(cc->geom.h, cc->hint.minh);

	/* adjust for max width/height */
	if (cc->hint.maxw)
		cc->geom.w = MIN(cc->geom.w, cc->hint.maxw);
	if (cc->hint.maxh)
		cc->geom.h = MIN(cc->geom.h, cc->hint.maxh);
}

static void
client_mwm_hints(struct client_ctx *cc)
{
	struct mwm_hints	*mwmh;

	if (xu_getprop(cc->win, cwmh[_MOTIF_WM_HINTS], cwmh[_MOTIF_WM_HINTS],
	    MWM_HINTS_ELEMENTS, (unsigned char **)&mwmh) == MWM_HINTS_ELEMENTS) {
		if (mwmh->flags & MWM_FLAGS_DECORATIONS &&
		    !(mwmh->decorations & MWM_DECOR_ALL) &&
		    !(mwmh->decorations & MWM_DECOR_BORDER))
			cc->bwidth = 0;
		XFree(mwmh);
	}
}

void
client_transient(struct client_ctx *cc)
{
	struct client_ctx	*tc;
	Window			 trans;

	if (XGetTransientForHint(X_Dpy, cc->win, &trans)) {
		if ((tc = client_find(trans)) != NULL && tc->gc) {
			group_movetogroup(cc, tc->gc->num);
			if (tc->flags & CLIENT_IGNORE)
				cc->flags |= CLIENT_IGNORE;
		}
	}
}

int
client_inbound(struct client_ctx *cc, int x, int y)
{
	return(x < cc->geom.w && x >= 0 &&
	    y < cc->geom.h && y >= 0);
}

int
client_snapcalc(int n0, int n1, int e0, int e1, int snapdist)
{
	int	 s0, s1;

	s0 = s1 = 0;

	if (abs(e0 - n0) <= snapdist)
		s0 = e0 - n0;

	if (abs(e1 - n1) <= snapdist)
		s1 = e1 - n1;

	/* possible to snap in both directions */
	if (s0 != 0 && s1 != 0)
		if (abs(s0) < abs(s1))
			return(s0);
		else
			return(s1);
	else if (s0 != 0)
		return(s0);
	else if (s1 != 0)
		return(s1);
	else
		return(0);
}

void
client_htile(struct client_ctx *cc)
{
	struct client_ctx	*ci;
	struct group_ctx 	*gc = cc->gc;
	struct screen_ctx 	*sc = cc->sc;
	struct geom 		 area;
	int 			 i, n, mh, x, w, h;

	if (!gc)
		return;
	i = n = 0;

	TAILQ_FOREACH(ci, &gc->clientq, group_entry) {
		if (ci->flags & CLIENT_HIDDEN ||
		    ci->flags & CLIENT_IGNORE || (ci == cc))
			continue;
		n++;
	}
	if (n == 0)
		return;

	area = screen_area(sc,
	    cc->geom.x + cc->geom.w / 2,
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);

	if (cc->flags & CLIENT_VMAXIMIZED ||
	    cc->geom.h + (cc->bwidth * 2) >= area.h)
		return;

	cc->flags &= ~CLIENT_HMAXIMIZED;
	cc->geom.x = area.x;
	cc->geom.y = area.y;
	cc->geom.w = area.w - (cc->bwidth * 2);
	cc->geom.h = (area.h - (cc->bwidth * 2)) / 2;
	client_resize(cc, 1);
	client_ptrwarp(cc);

	mh = cc->geom.h + (cc->bwidth * 2);
	x = area.x;
	w = area.w / n;
	h = area.h - mh;
	TAILQ_FOREACH(ci, &gc->clientq, group_entry) {
		if (ci->flags & CLIENT_HIDDEN ||
		    ci->flags & CLIENT_IGNORE || (ci == cc))
			continue;
		ci->bwidth = Conf.bwidth;
		ci->geom.x = x;
		ci->geom.y = area.y + mh;
		ci->geom.w = w - (ci->bwidth * 2);
		ci->geom.h = h - (ci->bwidth * 2);
		if (i + 1 == n)
			ci->geom.w = area.x + area.w -
			    ci->geom.x - (ci->bwidth * 2);
		x += w;
		i++;
		client_resize(ci, 1);
	}
}

void
client_vtile(struct client_ctx *cc)
{
	struct client_ctx	*ci;
	struct group_ctx 	*gc = cc->gc;
	struct screen_ctx 	*sc = cc->sc;
	struct geom 		 area;
	int 			 i, n, mw, y, w, h;

	if (!gc)
		return;
	i = n = 0;

	TAILQ_FOREACH(ci, &gc->clientq, group_entry) {
		if (ci->flags & CLIENT_HIDDEN ||
		    ci->flags & CLIENT_IGNORE || (ci == cc))
			continue;
		n++;
	}
	if (n == 0)
		return;

	area = screen_area(sc,
	    cc->geom.x + cc->geom.w / 2,
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);

	if (cc->flags & CLIENT_HMAXIMIZED ||
	    cc->geom.w + (cc->bwidth * 2) >= area.w)
		return;

	cc->flags &= ~CLIENT_VMAXIMIZED;
	cc->geom.x = area.x;
	cc->geom.y = area.y;
	cc->geom.w = (area.w - (cc->bwidth * 2)) / 2;
	cc->geom.h = area.h - (cc->bwidth * 2);
	client_resize(cc, 1);
	client_ptrwarp(cc);

	mw = cc->geom.w + (cc->bwidth * 2);
	y = area.y;
	h = area.h / n;
	w = area.w - mw;
	TAILQ_FOREACH(ci, &gc->clientq, group_entry) {
		if (ci->flags & CLIENT_HIDDEN ||
		    ci->flags & CLIENT_IGNORE || (ci == cc))
			continue;
		ci->bwidth = Conf.bwidth;
		ci->geom.x = area.x + mw;
		ci->geom.y = y;
		ci->geom.w = w - (ci->bwidth * 2);
		ci->geom.h = h - (ci->bwidth * 2);
		if (i + 1 == n)
			ci->geom.h = area.y + area.h -
			    ci->geom.y - (ci->bwidth * 2);
		y += h;
		i++;
		client_resize(ci, 1);
	}
}

long
client_get_wm_state(struct client_ctx *cc)
{
	long	*p, state = -1;

	if (xu_getprop(cc->win, cwmh[WM_STATE], cwmh[WM_STATE], 2L,
	    (unsigned char **)&p) > 0) {
		state = *p;
		XFree(p);
	}
	return(state);
}

void
client_set_wm_state(struct client_ctx *cc, long state)
{
	long	 data[] = { state, None };

	XChangeProperty(X_Dpy, cc->win, cwmh[WM_STATE], cwmh[WM_STATE], 32,
	    PropModeReplace, (unsigned char *)data, 2);
}
@


1.239
log
@Clean up, unify and accurately calculate edge distance with client move/resize
actions, so as to not lose windows off the edge.

inspired by diffs (and feedback) from Vadim Vygonets.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.238 2017/04/26 21:10:54 okan Exp $
d764 8
a771 8
		if (cc->geom.x + (cc->bwidth * 2) >= wmax)
			cc->geom.x = wmax - (cc->bwidth * 2);
		if (cc->geom.x + cc->geom.w - (cc->bwidth * 2) < 0)
			cc->geom.x = -cc->geom.w;
		if (cc->geom.y + (cc->bwidth * 2) >= hmax)
			cc->geom.y = hmax - (cc->bwidth * 2);
		if (cc->geom.y + cc->geom.h - (cc->bwidth * 2) < 0)
			cc->geom.y = -cc->geom.h;
@


1.238
log
@Switch bwidth type; unfortunately X11 is inconsistent.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.237 2017/04/24 13:31:19 okan Exp $
d471 18
@


1.237
log
@sort
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.236 2017/04/24 12:27:32 okan Exp $
d548 1
a548 1
	XSetWindowBorderWidth(X_Dpy, cc->win, cc->bwidth);
d746 1
a746 1
		if (cc->geom.x + ((int)cc->bwidth * 2) >= wmax)
d748 1
a748 1
		if (cc->geom.x + cc->geom.w - ((int)cc->bwidth * 2) < 0)
d750 1
a750 1
		if (cc->geom.y + ((int)cc->bwidth * 2) >= hmax)
d752 1
a752 1
		if (cc->geom.y + cc->geom.h - ((int)cc->bwidth * 2) < 0)
@


1.236
log
@Raise the previously focused window, instead of the previous window in the
cycle list; seems to match behaviour of other wm's; from Walter Alejandro
Iglesias.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.235 2017/04/24 12:18:04 okan Exp $
d961 1
a961 1
	int 			 i, n, mh, x, h, w;
d987 1
a988 1
	cc->geom.w = area.w - (cc->bwidth * 2);
d1001 1
d1003 1
a1003 1
		ci->geom.x = x;
a1004 1
		ci->geom.w = w - (ci->bwidth * 2);
d1009 1
a1010 1
		i++;
d1021 1
a1021 1
	int 			 i, n, mw, y, h, w;
d1047 1
a1048 1
	cc->geom.w = (area.w - (cc->bwidth * 2)) / 2;
d1061 1
d1063 1
a1063 1
		ci->geom.x = area.x + mw;
a1064 1
		ci->geom.w = w - (ci->bwidth * 2);
d1069 1
a1070 1
		i++;
@


1.235
log
@For {h,v}tile, instead of keeping the master client's {h,v} geometry, expand it
to %50 of the area, then fill in the remaining space with the other clients in
the same group; from Gerrit Meyerheim.

support from ajacoutot.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.234 2017/02/06 18:10:28 okan Exp $
d648 1
a648 1
	struct client_ctx	*newcc, *oldcc;
d658 1
d690 1
@


1.234
log
@Call client_resize instead of client_move after client_placecalc since the size
may also change.

from Vadim Vygonets
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.233 2016/12/19 14:17:26 okan Exp $
d985 1
d1046 1
@


1.233
log
@When a window has a user or program specified position, ensure the edge of the
final position is at least viewable and warp'able by the difference of bwidth;
prevents mapping windows completely off the virtual screen.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.232 2016/12/06 21:59:33 okan Exp $
d103 1
a103 1
		client_move(cc);
@


1.232
log
@stray newlines
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.231 2016/12/06 21:00:13 okan Exp $
d739 13
a751 11
		/*
		 * Ignore XINERAMA screens, just make sure it's somewhere
		 * in the virtual desktop. else it stops people putting xterms
		 * at startup in the screen the mouse doesn't start in *sigh*.
		 * XRandR bits mean that {x,y}max shouldn't be outside what's
		 * currently there.
		 */
		xslack = sc->view.w - cc->geom.w - cc->bwidth * 2;
		yslack = sc->view.h - cc->geom.h - cc->bwidth * 2;
		cc->geom.x = MIN(cc->geom.x, xslack);
		cc->geom.y = MIN(cc->geom.y, yslack);
@


1.231
log
@Set dim.{x,y} during client_init and update on resize, instead of
(re)calculating only when applying hints.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.230 2016/10/18 17:03:30 okan Exp $
a1088 1

@


1.230
log
@Refactor callbacks to take a void * so as to not try and generalize into
client_ctx in keypress and buttonpress event handlers; pass appropriate *ctx's
based on context.

While here, limit some globals, replace defines with appropriate variables and
fix some naming.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.229 2016/10/06 14:30:05 okan Exp $
d94 2
d429 2
a883 3

	cc->dim.w = (cc->geom.w - cc->hint.basew) / cc->hint.incw;
	cc->dim.h = (cc->geom.h - cc->hint.baseh) / cc->hint.inch;
@


1.229
log
@Check the ptr bounds in the new client during cycling, since not all
actions do ptrsave, such as restoring client geometry; adapted from a
diff by Vadim Vygonets.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.228 2016/10/04 15:52:32 okan Exp $
d656 2
a657 2
		oldcc = (flags & CWM_CLIENT_RCYCLE) ?
		    TAILQ_LAST(&sc->clientq, client_ctx_q) :
d664 1
a664 1
		newcc = (flags & CWM_CLIENT_RCYCLE) ? client_prev(newcc) :
d669 1
a669 1
		    || ((flags & CWM_CLIENT_CYCLE_INGRP) &&
d724 2
a725 2
	return(((newcc = TAILQ_PREV(cc, client_ctx_q, entry)) != NULL) ?
	    newcc : TAILQ_LAST(&sc->clientq, client_ctx_q));
@


1.228
log
@Calculate client nameqlen in client_setname(), the only place it's
needed/used.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.227 2016/10/03 14:42:34 okan Exp $
d686 4
@


1.227
log
@Defaults are split between defines and conf_init(); normalize these, as
well as give 'sticky' groups its own variable.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.226 2016/10/03 13:41:30 okan Exp $
d608 1
a624 1
	cc->nameqlen++;
d629 5
a633 4
	/* Now, do some garbage collection. */
	if (cc->nameqlen > CLIENT_MAXNAMEQLEN) {
		if ((wn = TAILQ_FIRST(&cc->nameq)) == NULL)
			errx(1, "client_setname: window name queue empty");
d637 1
a637 1
		cc->nameqlen--;
@


1.226
log
@client_ptrwarp should not deal with unhiding or raising clients (non ptr
requests); most callers do this already - deal with the few that do not.
client_ptrwarp becomes a simple wrapper (setpos) but it will be expanded.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.225 2016/09/30 20:55:54 okan Exp $
d136 1
a136 1
		if (Conf.flags & CONF_STICKY_GROUPS)
@


1.225
log
@Set the initial ptr position during client init, instead of waiting
until (maybe) a ptrwarp call. Likewise, explicitly ensure an inbounds ptr
position (same as initial) when saving.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.224 2016/09/20 19:11:19 okan Exp $
a471 5
	if (cc->flags & CLIENT_HIDDEN)
		client_unhide(cc);
	else
		client_raise(cc);

d684 1
@


1.224
log
@de-static client_inbound()
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.223 2016/09/20 18:21:32 okan Exp $
a77 2
	cc->ptr.x = -1;
	cc->ptr.y = -1;
d94 3
a471 7
	int	 x = cc->ptr.x, y = cc->ptr.y;

	if (x == -1 || y == -1) {
		x = cc->geom.w / 2;
		y = cc->geom.h / 2;
	}

d476 2
a477 1
	xu_ptr_setpos(cc->win, x, y);
d490 2
a491 2
		cc->ptr.x = -1;
		cc->ptr.y = -1;
@


1.223
log
@Get rid of curcc, instead cycle through the queue; removes the need for
client_none().
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.222 2016/09/16 14:32:02 okan Exp $
a39 1
static int			 client_inbound(struct client_ctx *, int, int);
d919 1
a919 1
static int
@


1.222
log
@During init, query screen for _NET_ACTIVE_WINDOW and set that client as
active; while we already look at what's under the pointer, use this
information first, then look under the pointer (saving that round-trip).
This restores the active state to a client after restart even if the
pointer is not above it (and of course the pointer is not above another
client).
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.221 2016/09/14 21:00:24 okan Exp $
a36 1
static void			 client_none(struct screen_ctx *);
a41 2
struct client_ctx	*curcc = NULL;

d178 1
a178 1
		client_none(sc);
a226 1
	curcc = cc;
a233 13
/*
 * set when there is no active client
 */
static void
client_none(struct screen_ctx *sc)
{
	Window none = None;

	xu_ewmh_net_active_window(sc, none);

	curcc = NULL;
}

d237 10
a246 1
	return(curcc);
d507 1
a507 1
		client_none(cc->sc);
@


1.221
log
@Some clients fail to setup hints at all, so initalize for them; fallout
from r1.218 switching to malloc - clearly missed this case.

found the hard way by brynet@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.220 2016/09/14 19:45:33 okan Exp $
d46 1
a46 1
client_init(Window win, struct screen_ctx *sc)
d52 1
a52 1
	int			 x, y, wx, wy, activate = 0;
d108 1
a108 1
		if ((XQueryPointer(X_Dpy, cc->win, &rwin, &cwin,
d110 1
a110 1
			activate = 1;
d148 1
a148 1
	if (activate)
@


1.220
log
@Fix-up a few simple uses of client_current(): check CLIENT_ACTIVE flag
instead of relying on curcc.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.219 2016/09/13 17:42:58 okan Exp $
d81 1
@


1.219
log
@init label
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.218 2016/09/12 13:48:41 okan Exp $
d179 3
a184 3
	if (cc == client_current())
		client_none(sc);

d513 3
a518 3

	if (cc == client_current())
		client_none(cc->sc);
@


1.218
log
@Switch to just malloc since we need initialize most everything anyway.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.217 2016/09/02 15:08:44 okan Exp $
d76 1
@


1.217
log
@Simplify toggling flags; from Vadim Vygonets.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.216 2016/09/01 18:38:52 okan Exp $
d70 1
a70 1
	cc = xcalloc(1, sizeof(*cc));
d76 6
a92 4

	/* Saved pointer position */
	cc->ptr.x = -1;
	cc->ptr.y = -1;
@


1.216
log
@Do not draw borders on ignored clients when returning from fullscreen;
from Vadim Vygonets.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.215 2016/09/01 18:34:04 okan Exp $
d259 1
a259 5
	if (cc->flags & CLIENT_FREEZE)
		cc->flags &= ~CLIENT_FREEZE;
	else
		cc->flags |= CLIENT_FREEZE;

d266 1
a266 5
	if (cc->flags & CLIENT_HIDDEN)
		cc->flags &= ~CLIENT_HIDDEN;
	else
		cc->flags |= CLIENT_HIDDEN;

d273 1
a273 5
	if (cc->flags & CLIENT_STICKY)
		cc->flags &= ~CLIENT_STICKY;
	else
		cc->flags |= CLIENT_STICKY;

@


1.215
log
@Remove redundant minimum client size adjustment (minw and minh are
always positive since r1.214); from Vadim Vygonets.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.214 2015/11/12 18:33:30 okan Exp $
d300 2
a301 1
		cc->bwidth = Conf.bwidth;
@


1.214
log
@If a client sets hints, honor them for kb resize requests, just like we
do for mouse based resize requests.

Based on a patch from Vadim Vygonets.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.213 2015/11/11 14:22:01 okan Exp $
a899 3

	cc->geom.w = MAX(cc->geom.w, 1);
	cc->geom.h = MAX(cc->geom.h, 1);
@


1.213
log
@Partial revert of replacing screen_area() with region_find(); until a
fix for a regression is found; this bug has been around for a long time
it seems, but this change exposed it. Likely need to track clients in to
and out of regions.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.212 2015/11/10 20:05:33 okan Exp $
d842 2
@


1.212
log
@Start cleaning up name vs function differences; replace magic numbers.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.211 2015/11/09 20:03:29 okan Exp $
d293 1
a293 1
	struct region_ctx	*rc;
d308 1
a308 1
	rc = region_find(sc,
d310 1
a310 1
	    cc->geom.y + cc->geom.h / 2);
d313 1
a313 1
	cc->geom = rc->view;
d325 1
a325 1
	struct region_ctx	*rc;
d351 1
a351 1
	rc = region_find(sc,
d353 1
a353 1
	    cc->geom.y + cc->geom.h / 2);
d355 4
a358 4
	cc->geom.x = rc->work.x;
	cc->geom.y = rc->work.y;
	cc->geom.w = rc->work.w - (cc->bwidth * 2);
	cc->geom.h = rc->work.h - (cc->bwidth * 2);
d370 1
a370 1
	struct region_ctx	*rc;
d385 1
a385 1
	rc = region_find(sc,
d387 1
a387 1
	    cc->geom.y + cc->geom.h / 2);
d389 2
a390 2
	cc->geom.y = rc->work.y;
	cc->geom.h = rc->work.h - (cc->bwidth * 2);
d402 1
a402 1
	struct region_ctx	*rc;
d417 1
a417 1
	rc = region_find(sc,
d419 1
a419 1
	    cc->geom.y + cc->geom.h / 2);
d421 2
a422 2
	cc->geom.x = rc->work.x;
	cc->geom.w = rc->work.w - (cc->bwidth * 2);
a751 1
	struct region_ctx	*rc;
d771 1
a771 2
		rc = region_find(sc, xmouse, ymouse);
		area = rc->work;
d976 1
a976 1
	struct region_ctx	*rc;
d992 1
a992 1
	rc = region_find(sc,
d994 1
a994 1
	    cc->geom.y + cc->geom.h / 2);
d997 1
a997 1
	    cc->geom.h + (cc->bwidth * 2) >= rc->work.h)
d1001 3
a1003 3
	cc->geom.x = rc->work.x;
	cc->geom.y = rc->work.y;
	cc->geom.w = rc->work.w - (cc->bwidth * 2);
d1008 3
a1010 3
	x = rc->work.x;
	w = rc->work.w / n;
	h = rc->work.h - mh;
d1016 1
a1016 1
		ci->geom.y = rc->work.y + mh;
d1021 1
a1021 1
			ci->geom.w = rc->work.x + rc->work.w -
d1035 1
a1035 1
	struct region_ctx	*rc;
d1051 1
a1051 1
	rc = region_find(sc,
d1053 1
a1053 1
	    cc->geom.y + cc->geom.h / 2);
d1056 1
a1056 1
	    cc->geom.w + (cc->bwidth * 2) >= rc->work.w)
d1060 3
a1062 3
	cc->geom.x = rc->work.x;
	cc->geom.y = rc->work.y;
	cc->geom.h = rc->work.h - (cc->bwidth * 2);
d1067 3
a1069 3
	y = rc->work.y;
	h = rc->work.h / n;
	w = rc->work.w - mw;
d1076 1
a1076 1
		ci->geom.x = rc->work.x + mw;
d1080 1
a1080 1
			ci->geom.h = rc->work.y + rc->work.h -
@


1.211
log
@Extend region to include both view and work areas; switch to
region_find() which no longer needs to recalculate gap each time
a client (or menu) is created or altered. If no RandR, fall back
to display dimensions while building regions instead of during
execution.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.210 2015/09/23 14:09:40 okan Exp $
d681 1
a681 1
		oldcc = (flags & CWM_RCYCLE) ?
d689 1
a689 1
		newcc = (flags & CWM_RCYCLE) ? client_prev(newcc) :
d694 1
a694 1
		    || ((flags & CWM_INGROUP) &&
@


1.210
log
@Only when mapping clients from an initial wm start or restart, query the
pointer and if it matches the child window, activate it; new clients
will not need to make this roundtrip to the server.

Based on a patch from Preben Guldberg.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.209 2015/08/27 18:53:15 okan Exp $
d293 1
a293 1
	struct geom		 area;
d308 1
a308 1
	area = screen_area(sc,
d310 1
a310 1
	    cc->geom.y + cc->geom.h / 2, CWM_NOGAP);
d313 1
a313 1
	cc->geom = area;
d325 1
a325 1
	struct geom		 area;
d351 1
a351 1
	area = screen_area(sc,
d353 1
a353 1
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);
d355 4
a358 4
	cc->geom.x = area.x;
	cc->geom.y = area.y;
	cc->geom.w = area.w - (cc->bwidth * 2);
	cc->geom.h = area.h - (cc->bwidth * 2);
d370 1
a370 1
	struct geom		 area;
d385 1
a385 1
	area = screen_area(sc,
d387 1
a387 1
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);
d389 2
a390 2
	cc->geom.y = area.y;
	cc->geom.h = area.h - (cc->bwidth * 2);
d402 1
a402 1
	struct geom		 area;
d417 1
a417 1
	area = screen_area(sc,
d419 1
a419 1
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);
d421 2
a422 2
	cc->geom.x = area.x;
	cc->geom.w = area.w - (cc->bwidth * 2);
d752 1
d772 2
a773 1
		area = screen_area(sc, xmouse, ymouse, CWM_GAP);
d978 1
a978 1
	struct geom 		 area;
d994 1
a994 1
	area = screen_area(sc,
d996 1
a996 1
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);
d999 1
a999 1
	    cc->geom.h + (cc->bwidth * 2) >= area.h)
d1003 3
a1005 3
	cc->geom.x = area.x;
	cc->geom.y = area.y;
	cc->geom.w = area.w - (cc->bwidth * 2);
d1010 3
a1012 3
	x = area.x;
	w = area.w / n;
	h = area.h - mh;
d1018 1
a1018 1
		ci->geom.y = area.y + mh;
d1023 1
a1023 1
			ci->geom.w = area.x + area.w -
d1037 1
a1037 1
	struct geom 		 area;
d1053 1
a1053 1
	area = screen_area(sc,
d1055 1
a1055 1
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);
d1058 1
a1058 1
	    cc->geom.w + (cc->bwidth * 2) >= area.w)
d1062 3
a1064 3
	cc->geom.x = area.x;
	cc->geom.y = area.y;
	cc->geom.h = area.h - (cc->bwidth * 2);
d1069 3
a1071 3
	y = area.y;
	h = area.h / n;
	w = area.w - mw;
d1078 1
a1078 1
		ci->geom.x = area.x + mw;
d1082 1
a1082 1
			ci->geom.h = area.y + area.h -
@


1.209
log
@Mechanical change: group->gc
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.208 2015/08/27 18:42:56 okan Exp $
d51 3
d103 4
d143 3
@


1.208
log
@Add consistent checks against NULL.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.207 2015/08/27 18:40:09 okan Exp $
d166 2
a167 2
	if (cc->group != NULL)
		TAILQ_REMOVE(&cc->group->clientq, cc, group_entry);
d685 1
a685 1
			(newcc->group != oldcc->group)))
d918 2
a919 2
		if ((tc = client_find(trans)) != NULL && tc->group) {
			group_movetogroup(cc, tc->group->num);
d964 1
a964 1
	struct group_ctx 	*gc = cc->group;
d1023 1
a1023 1
	struct group_ctx 	*gc = cc->group;
@


1.207
log
@Move client cycle grab/ungrab into a more relevant place; while here,
update comments about why we need to grab/ungrab the keyboard.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.206 2015/08/25 18:29:10 okan Exp $
d207 1
a207 1
	if ((oldcc = client_current())) {
d710 1
a710 1
	if ((cc = client_current())) {
d712 2
a713 1
		group_toggle_membership_leave(cc);
d918 1
a918 1
		if ((tc = client_find(trans)) && tc->group) {
@


1.206
log
@Split out sticky mode checks and the restoring of a client's group and
_NET_WM_DESKTOP from the config-based auto-grouping; no (intentional)
behavior changes.  Needed for further work in cleaning up this area.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.205 2015/08/24 15:42:57 okan Exp $
d661 4
@


1.205
log
@Implement _NET_CLIENT_LIST_STACKING (from Thomas Admin), but
bottom-to-top order, as per spec (notified Thomas as well).
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.204 2015/08/24 14:57:19 okan Exp $
d123 11
a133 3
	if (mapped)
		group_autogroup(cc);

@


1.204
log
@Don't allow freeze operations on fullscreen (consistent with what
fullscreen does).
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.203 2015/08/23 17:31:20 okan Exp $
d115 1
d156 1
@


1.203
log
@Move CLIENT_STICKY logic from client hide/unhide to group hide/unhide;
rationale being that clients should be able to hide/unhide independently
of group switching.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.202 2015/08/21 16:52:37 okan Exp $
d236 3
@


1.202
log
@Fix whitespace.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.201 2015/08/21 16:30:02 okan Exp $
a495 3
	if (cc->flags & CLIENT_STICKY)
		return;

a508 3
	if (cc->flags & CLIENT_STICKY)
		return;

@


1.201
log
@Add client freeze extension to _NET_WM_STATE Atom, allowing flag to
persist. As usual with new Atoms, requires X restart.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.200 2015/08/21 16:14:39 okan Exp $
d672 1
a672 1
		if ((newcc->flags & (CLIENT_HIDDEN|CLIENT_IGNORE))
d732 1
a732 1
	if (cc->hint.flags & (USPosition|PPosition)) {
@


1.200
log
@_NET_WM_STATE_STICKY implies only sticky at the group/desktop level, not
position and size; based on discussion with a few.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.199 2015/08/21 15:52:49 okan Exp $
d240 2
@


1.199
log
@Bring group and client cycle closer together.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.198 2015/07/01 14:36:42 okan Exp $
d302 1
a302 1
	if (cc->flags & (CLIENT_FREEZE|CLIENT_STICKY))
d347 1
a347 1
	if (cc->flags & (CLIENT_FREEZE|CLIENT_STICKY))
d379 1
a379 1
	if (cc->flags & (CLIENT_FREEZE|CLIENT_STICKY))
@


1.198
log
@style
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.197 2015/06/30 14:01:43 okan Exp $
d650 1
a650 1
	struct client_ctx	*oldcc, *newcc;
d658 1
a658 1
		oldcc = ((flags & CWM_RCYCLE) ?
d660 1
a660 1
		    TAILQ_FIRST(&sc->clientq));
d666 2
a667 2
		newcc = ((flags & CWM_RCYCLE) ? client_prev(newcc) :
		    client_next(newcc));
d708 1
a708 1
	struct client_ctx	*ccc;
d710 2
a711 2
	return(((ccc = TAILQ_NEXT(cc, entry)) != NULL) ?
	    ccc : TAILQ_FIRST(&sc->clientq));
d718 1
a718 1
	struct client_ctx	*ccc;
d720 2
a721 2
	return(((ccc = TAILQ_PREV(cc, client_ctx_q, entry)) != NULL) ?
	    ccc : TAILQ_LAST(&sc->clientq, client_ctx_q));
@


1.197
log
@Re-implement XClientMessage handling so that we can feed screen_find and
client_find valid resources as needed, relieving the need for
screen_find to ungracefully handle invalid root windows. Removes a long
standing XXX.  Should theoretically allow XClientMessage handling on
more than one X screen.  Alter callers of screen_find to handle
failures.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.196 2015/06/28 19:54:37 okan Exp $
d658 1
a658 1
		oldcc = (flags & CWM_RCYCLE ?
d666 1
a666 1
		newcc = (flags & CWM_RCYCLE ? client_prev(newcc) :
d710 1
a710 1
	return((ccc = TAILQ_NEXT(cc, entry)) != NULL ?
d720 1
a720 1
	return((ccc = TAILQ_PREV(cc, client_ctx_q, entry)) != NULL ?
@


1.196
log
@move client_find down
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.195 2015/06/28 19:50:46 okan Exp $
d58 2
a59 1
		sc = screen_find(wattr.root);
@


1.195
log
@replace assert usage
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.194 2015/06/26 17:17:46 okan Exp $
a45 15
client_find(Window win)
{
	struct screen_ctx	*sc;
	struct client_ctx	*cc;

	TAILQ_FOREACH(sc, &Screenq, entry) {
		TAILQ_FOREACH(cc, &sc->clientq, entry) {
			if (cc->win == win)
				return(cc);
		}
	}
	return(NULL);
}

struct client_ctx *
d128 15
@


1.194
log
@Mechanical change from xinerama to region backed areas.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.193 2015/06/08 15:11:29 okan Exp $
a23 1
#include <assert.h>
d637 2
a638 2
		wn = TAILQ_FIRST(&cc->nameq);
		assert(wn != NULL);
@


1.193
log
@stash window dimensions
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.192 2015/05/20 23:54:39 okan Exp $
d268 1
a268 1
	struct geom		 xine;
d283 1
a283 1
	xine = screen_find_xinerama(sc,
d288 1
a288 1
	cc->geom = xine;
d300 1
a300 1
	struct geom		 xine;
d326 1
a326 1
	xine = screen_find_xinerama(sc,
d330 4
a333 4
	cc->geom.x = xine.x;
	cc->geom.y = xine.y;
	cc->geom.w = xine.w - (cc->bwidth * 2);
	cc->geom.h = xine.h - (cc->bwidth * 2);
d345 1
a345 1
	struct geom		 xine;
d360 1
a360 1
	xine = screen_find_xinerama(sc,
d364 2
a365 2
	cc->geom.y = xine.y;
	cc->geom.h = xine.h - (cc->bwidth * 2);
d377 1
a377 1
	struct geom		 xine;
d392 1
a392 1
	xine = screen_find_xinerama(sc,
d396 2
a397 2
	cc->geom.x = xine.x;
	cc->geom.w = xine.w - (cc->bwidth * 2);
d743 1
a743 1
		struct geom		 xine;
d747 5
a751 5
		xine = screen_find_xinerama(sc, xmouse, ymouse, CWM_GAP);
		xine.w += xine.x;
		xine.h += xine.y;
		xmouse = MAX(xmouse, xine.x) - cc->geom.w / 2;
		ymouse = MAX(ymouse, xine.y) - cc->geom.h / 2;
d753 2
a754 2
		xmouse = MAX(xmouse, xine.x);
		ymouse = MAX(ymouse, xine.y);
d756 2
a757 2
		xslack = xine.w - cc->geom.w - cc->bwidth * 2;
		yslack = xine.h - cc->geom.h - cc->bwidth * 2;
d759 2
a760 2
		if (xslack >= xine.x) {
			cc->geom.x = MAX(MIN(xmouse, xslack), xine.x);
d762 2
a763 2
			cc->geom.x = xine.x;
			cc->geom.w = xine.w;
d765 2
a766 2
		if (yslack >= xine.y) {
			cc->geom.y = MAX(MIN(ymouse, yslack), xine.y);
d768 2
a769 2
			cc->geom.y = xine.y;
			cc->geom.h = xine.h;
d952 1
a952 1
	struct geom 		 xine;
d968 1
a968 1
	xine = screen_find_xinerama(sc,
d973 1
a973 1
	    cc->geom.h + (cc->bwidth * 2) >= xine.h)
d977 3
a979 3
	cc->geom.x = xine.x;
	cc->geom.y = xine.y;
	cc->geom.w = xine.w - (cc->bwidth * 2);
d984 3
a986 3
	x = xine.x;
	w = xine.w / n;
	h = xine.h - mh;
d992 1
a992 1
		ci->geom.y = xine.y + mh;
d997 1
a997 1
			ci->geom.w = xine.x + xine.w -
d1011 1
a1011 1
	struct geom 		 xine;
d1027 1
a1027 1
	xine = screen_find_xinerama(sc,
d1032 1
a1032 1
	    cc->geom.w + (cc->bwidth * 2) >= xine.w)
d1036 3
a1038 3
	cc->geom.x = xine.x;
	cc->geom.y = xine.y;
	cc->geom.h = xine.h - (cc->bwidth * 2);
d1043 3
a1045 3
	y = xine.y;
	h = xine.h / n;
	w = xine.w - mw;
d1052 1
a1052 1
		ci->geom.x = xine.x + mw;
d1056 1
a1056 1
			ci->geom.h = xine.y + xine.h -
@


1.192
log
@fill in mwm defines
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.191 2015/03/29 00:21:05 okan Exp $
d877 3
@


1.191
log
@plug a leak
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.190 2015/01/23 19:35:11 okan Exp $
d885 2
a886 2
	    PROP_MWM_HINTS_ELEMENTS, (unsigned char **)&mwmh) == MWM_NUMHINTS) {
		if (mwmh->flags & MWM_HINTS_DECORATIONS &&
@


1.190
log
@First restore net_wm_state(ewmh), then wm_state(iccc); prevents clients
from re-hiding on restart due to flag toggling (note that this is ripe
for re-vamping). Behavior only observed on restarts.

Problem found by, and initial patch from, Henri Kemppainen (thanks!),
though ever so slightly different one applied.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.189 2015/01/19 14:54:16 okan Exp $
d890 1
@


1.189
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.188 2014/09/27 19:04:32 okan Exp $
a65 1
	long			 state;
a126 5
	if ((state = client_get_wm_state(cc)) < 0)
		state = NormalState;

	(state == IconicState) ? client_hide(cc) : client_unhide(cc);

d131 5
@


1.188
log
@these have nothing to do with 'sticky', but rather group membership; rename.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.187 2014/09/17 18:41:44 okan Exp $
d21 1
a21 1
#include <sys/param.h>
d27 1
@


1.187
log
@these client actions are just toggles; less confusing with better names
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.186 2014/09/17 18:09:30 okan Exp $
d699 1
a699 1
		group_sticky_toggle_exit(cc);
@


1.186
log
@ewmh states _NET_WM_STATE_STICKY should not alter position
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.185 2014/09/17 16:30:21 okan Exp $
d234 1
a234 1
client_freeze(struct client_ctx *cc)
d243 1
a243 1
client_hidden(struct client_ctx *cc)
d254 1
a254 1
client_sticky(struct client_ctx *cc)
d265 1
a265 1
client_fullscreen(struct client_ctx *cc)
d297 1
a297 1
client_maximize(struct client_ctx *cc)
d342 1
a342 1
client_vmaximize(struct client_ctx *cc)
d374 1
a374 1
client_hmaximize(struct client_ctx *cc)
@


1.185
log
@don't toggle _WM_STATE_HIDDEN here yet
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.184 2014/09/17 16:00:44 okan Exp $
d302 1
a302 1
	if (cc->flags & CLIENT_FREEZE)
d347 1
a347 1
	if (cc->flags & CLIENT_FREEZE)
d379 1
a379 1
	if (cc->flags & CLIENT_FREEZE)
@


1.184
log
@Implement EWMH _NET_WM_STATE_HIDDEN.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.183 2014/09/15 13:00:49 okan Exp $
d500 1
a500 1
	client_hidden(cc);
d515 1
a515 1
	client_hidden(cc);
@


1.183
log
@use similiar style for client flags
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.182 2014/09/10 20:30:38 okan Exp $
d243 11
d500 1
a500 1
	cc->flags |= CLIENT_HIDDEN;
d515 1
a515 1
	cc->flags &= ~CLIENT_HIDDEN;
@


1.182
log
@fold in 'active' into 'flags'
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.181 2014/09/08 21:24:27 okan Exp $
d190 1
a190 1
	    ((cc->flags & CLIENT_WM_TAKE_FOCUS) == 0)) {
d263 1
a263 1
	if ((cc->flags & CLIENT_FULLSCREEN)) {
d300 1
a300 1
	if ((cc->flags & CLIENT_VMAXIMIZED) == 0) {
d305 1
a305 1
	if ((cc->flags & CLIENT_HMAXIMIZED) == 0) {
@


1.181
log
@move the check for an empty queue up during cycle
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.180 2014/09/08 21:15:14 okan Exp $
d198 1
a198 1
		oldcc->active = 0;
d207 1
a207 1
	cc->active = 1;
d488 1
a488 1
	cc->active = 0;
d512 1
a512 1
	if (!cc->active)
d522 1
a522 1
	if (cc->active)
@


1.180
log
@name the group client queue appropriately, like other queues
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.179 2014/09/08 20:37:02 okan Exp $
a641 3
	oldcc = client_current();

	/* If no windows then you cant cycle */
d645 1
@


1.179
log
@more style nits and wrapping
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.178 2014/09/08 20:32:40 okan Exp $
d157 1
a157 1
		TAILQ_REMOVE(&cc->group->clients, cc, group_entry);
d946 1
a946 1
	TAILQ_FOREACH(ci, &gc->clients, group_entry) {
d974 1
a974 1
	TAILQ_FOREACH(ci, &gc->clients, group_entry) {
d1005 1
a1005 1
	TAILQ_FOREACH(ci, &gc->clients, group_entry) {
d1033 1
a1033 1
	TAILQ_FOREACH(ci, &gc->clients, group_entry) {
@


1.178
log
@since mruq has been folded in, rename mru-named functions
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.177 2014/09/08 20:11:22 okan Exp $
d609 1
a609 1
	TAILQ_FOREACH(wn, &cc->nameq, entry)
d616 1
a616 1

d662 2
a663 1
			|| ((flags & CWM_INGROUP) && (newcc->group != oldcc->group)))
d876 1
a876 1
	    PROP_MWM_HINTS_ELEMENTS, (unsigned char **)&mwmh) == MWM_NUMHINTS)
d881 1
@


1.177
log
@Remove duplicate client queue (mruq); instead, remove and take the
global Clientq and place it inside screen_ctx since every client belongs
to a screen, then use the same per screen clientq to track stacking
order (the sole reason for mruq).
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.176 2014/09/07 19:27:30 okan Exp $
d34 2
a35 2
static struct client_ctx	*client_mrunext(struct client_ctx *);
static struct client_ctx	*client_mruprev(struct client_ctx *);
d657 2
a658 2
		newcc = (flags & CWM_RCYCLE ? client_mruprev(newcc) :
		    client_mrunext(newcc));
d695 1
a695 1
client_mrunext(struct client_ctx *cc)
d705 1
a705 1
client_mruprev(struct client_ctx *cc)
@


1.176
log
@more style nits
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.175 2014/09/07 17:38:38 okan Exp $
d48 1
d51 5
a55 3
	TAILQ_FOREACH(cc, &Clientq, entry) {
		if (cc->win == win)
			return(cc);
d132 1
a132 2
	TAILQ_INSERT_TAIL(&sc->mruq, cc, mru_entry);
	TAILQ_INSERT_TAIL(&Clientq, cc, entry);
d152 1
a152 2
	TAILQ_REMOVE(&sc->mruq, cc, mru_entry);
	TAILQ_REMOVE(&Clientq, cc, entry);
d645 1
a645 1
	if (TAILQ_EMPTY(&sc->mruq))
d650 2
a651 2
		    TAILQ_LAST(&sc->mruq, cycle_entry_q) :
		    TAILQ_FIRST(&sc->mruq));
d700 2
a701 2
	return((ccc = TAILQ_NEXT(cc, mru_entry)) != NULL ?
	    ccc : TAILQ_FIRST(&sc->mruq));
d710 2
a711 2
	return((ccc = TAILQ_PREV(cc, cycle_entry_q, mru_entry)) != NULL ?
	    ccc : TAILQ_LAST(&sc->mruq, cycle_entry_q));
d769 2
a770 2
	TAILQ_REMOVE(&sc->mruq, cc, mru_entry);
	TAILQ_INSERT_HEAD(&sc->mruq, cc, mru_entry);
@


1.175
log
@screen_fromroot -> screen_find
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.174 2014/08/25 12:49:19 okan Exp $
d50 1
a50 1
	TAILQ_FOREACH(cc, &Clientq, entry)
d52 3
a54 3
			return (cc);

	return (NULL);
d66 1
a66 1
		return (NULL);
d68 1
a68 1
		return (NULL);
d75 1
a75 1
			return (NULL);
d141 1
a141 1
	return (cc);
d229 1
a229 1
	return (curcc);
d699 1
a699 1
	return ((ccc = TAILQ_NEXT(cc, mru_entry)) != NULL ?
d709 1
a709 1
	return ((ccc = TAILQ_PREV(cc, cycle_entry_q, mru_entry)) != NULL ?
d899 1
a899 1
	return (x < cc->geom.w && x >= 0 &&
d919 1
a919 1
			return (s0);
d921 1
a921 1
			return (s1);
d923 1
a923 1
		return (s0);
d925 1
a925 1
		return (s1);
d927 1
a927 1
		return (0);
@


1.174
log
@Implement _NET_WM_STATE_STICKY, bound to CM-s by default; allows any
client to 'stick' to all desktops (ewmh speak) or groups - this
currently has the same affect as setting a client's group to 'nogroup',
with the exception that the client can also be in a group, so when
un-sticking, the client will go back to its original group/desktop.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.173 2014/08/20 15:15:29 okan Exp $
d71 1
a71 1
		sc = screen_fromroot(wattr.root);
@


1.173
log
@Purely mechanical; unify 'num', 'no' and 'shortcut'.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.172 2014/02/06 20:58:46 okan Exp $
d242 11
d482 3
d498 3
@


1.172
log
@Some clients set the urgency flag even if they are the active client;
prevent annoying behavior by only setting the cwm urgency flag if the client
is not active; diff from Thomas Adam.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.171 2014/02/03 20:20:39 okan Exp $
d872 1
a872 1
			group_movetogroup(cc, tc->group->shortcut);
@


1.171
log
@Move redundant bits from screen_init (while dealing with existing
clients) directly into client_init, performing the X roundtrip only
once. With the previous change in maprequest, this moves decision making
into one place for creating new clients.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.170 2014/02/02 21:34:05 okan Exp $
d494 2
a495 1
	cc->flags |= CLIENT_URGENCY;
@


1.170
log
@Move redundant window attr fetch from maprequest directly into
client_init and perform that X roundtrip only once.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.169 2014/01/27 15:13:09 okan Exp $
d58 1
a58 1
client_init(Window win, struct screen_ctx *sc, int mapped)
d63 1
d69 2
a70 1
	if (sc == NULL)
d72 6
@


1.169
log
@move some init up and shed some blank lines
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.168 2014/01/03 14:23:50 okan Exp $
d66 4
a92 1
	XGetWindowAttributes(X_Dpy, cc->win, &wattr);
@


1.168
log
@state is long
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.167 2014/01/02 21:15:39 okan Exp $
a121 1

@


1.167
log
@rename for clarity
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.166 2014/01/02 20:58:20 okan Exp $
d62 1
a62 1
	int			 state;
@


1.166
log
@When a client doesn't specify size hints, nothing prevents a resize to
0x0 - don't allow this situation during mouse resize (check already in
place for kbd resize).

Reported by brynet@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.165 2013/12/17 16:10:43 okan Exp $
d43 1
a43 1
struct client_ctx	*_curcc = NULL;
d195 1
a195 1
	_curcc = cc;
d213 1
a213 1
	_curcc = NULL;
d219 1
a219 1
	return (_curcc);
@


1.165
log
@replace with memset
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.164 2013/12/16 19:02:17 okan Exp $
d835 3
@


1.164
log
@Implement support for EWMH's _NET_WM_STATE_FULLSCREEN hint.

Since we already have a form of 'maximize', we need to differentiate
between 'maximize' and the new 'fullscreen' mode.  The 'maximize' mode
will continue to honor gap but now *retains* the border, matching the
'vert/horz maximize' behaviour.  The new 'fullscreen' mode supports and
follows the _NET_WM_STATE_FULLSCREEN hint, allowing the client perform
additional window modifications; in this mode, cwm(1) will *ignore* gap,
remove borders and freeze(move/resize) the client.  Additionally,
'fullscreen' mode will remember various combinations of previous states.

* default keybinding changes: CM-f 'fullscreen', CM-m 'maximize' (re-map
  as desired).

Positive feedback from a few, testing and ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.163 2013/12/13 22:39:13 okan Exp $
d411 1
a411 1
	bzero(&cn, sizeof(cn));
d550 1
a550 1
	bzero(&cm, sizeof(cm));
@


1.163
log
@Teach screen_find_xinerama() to apply gap only when told to do so;
adjust callers.  Needed for an upcoming feature.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.162 2013/12/13 15:56:44 okan Exp $
d232 32
d273 1
a274 2
		cc->geom = cc->savegeom;
		cc->bwidth = Conf.bwidth;
d297 4
a300 2
	cc->geom = xine;
	cc->bwidth = 0;
a319 3
		cc->bwidth = Conf.bwidth;
		if (cc->flags & CLIENT_HMAXIMIZED)
			cc->geom.w -= cc->bwidth * 2;
a326 6
	/* if this will make us fully maximized then remove boundary */
	if ((cc->flags & CLIENT_MAXFLAGS) == CLIENT_HMAXIMIZED) {
		cc->geom.w += cc->bwidth * 2;
		cc->bwidth = 0;
	}

a351 3
		cc->bwidth = Conf.bwidth;
		if (cc->flags & CLIENT_VMAXIMIZED)
			cc->geom.h -= cc->bwidth * 2;
a358 6
	/* if this will make us fully maximized then remove boundary */
	if ((cc->flags & CLIENT_MAXFLAGS) == CLIENT_VMAXIMIZED) {
		cc->geom.h += cc->bwidth * 2;
		cc->bwidth = 0;
	}

a376 1
		cc->bwidth = Conf.bwidth;
@


1.162
log
@we need the save-set when re-exec'ing so as to not lose State on our hidden clients
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.161 2013/12/13 14:40:52 okan Exp $
d264 1
a264 1
	    cc->geom.y + cc->geom.h / 2);
d305 1
a305 1
	    cc->geom.y + cc->geom.h / 2);
d346 1
a346 1
	    cc->geom.y + cc->geom.h / 2);
d694 1
a694 1
		xine = screen_find_xinerama(sc, xmouse, ymouse);
d909 1
a909 1
	    cc->geom.y + cc->geom.h / 2);
d968 1
a968 1
	    cc->geom.y + cc->geom.h / 2);
@


1.161
log
@Add support for XUrgency and matching _NET_WM_STATE_DEMANDS_ATTENTION
ewmh hint; urgencyborder is configurable.  The urgency flag will stick,
even while on a client in a non-viewable group, until the client
receives focus (where the border is reset).  Initial diff from Thomas
Adam with some changes/enhancements from me.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.160 2013/12/12 20:15:07 okan Exp $
d105 2
@


1.160
log
@ICCCM explicitly states that server time (CurrentTime) should *not* be
used for focus events, but rather the timestamp of the generated event.
Track the last event timestamp and send it down for a WM_TAKE_FOCUS
ClientMessage.  I suspect we should do this for clients that don't
announce this Atom as well, though the raciness gets us into a bind.

Solves focus order issue since WM_TAKE_FOCUS; fix verified by sthen@@

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.159 2013/12/11 22:14:23 okan Exp $
d195 1
d466 6
d492 3
d524 3
@


1.159
log
@we don't need to manage the save-set since we're not reparenting; left-over from pwin
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.158 2013/12/11 17:23:31 okan Exp $
d171 3
d182 1
a182 1
		client_msg(cc, cwmh[WM_TAKE_FOCUS]);
d517 1
a517 1
client_msg(struct client_ctx *cc, Atom proto)
d527 1
a527 1
	cm.data.l[1] = CurrentTime;
d536 1
a536 1
		client_msg(cc, cwmh[WM_DELETE_WINDOW]);
@


1.158
log
@since we are drawing in unhide, no need to during client setup
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.157 2013/12/11 15:46:47 okan Exp $
a104 2

	XAddToSaveSet(X_Dpy, cc->win);
@


1.157
log
@apply mwm hints later
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.156 2013/12/11 15:41:11 okan Exp $
a101 1
	client_draw_border(cc);
@


1.156
log
@Add client wrapper for XWMHints to support XA_WM_HINTS in PropertyNotify
events; based off a diff from Thomas Adam.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.155 2013/12/11 14:16:09 okan Exp $
d40 1
a40 1
static void			 client_getmwmhints(struct client_ctx *);
a80 1
	client_getmwmhints(cc);
d83 1
d809 1
a809 1
client_getmwmhints(struct client_ctx *cc)
@


1.155
log
@Remove extra work and simplify client state handling.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.154 2013/12/11 14:09:21 okan Exp $
d80 1
a80 1
	cc->wmh = XGetWMHints(X_Dpy, cc->win);
a95 6
	if (cc->wmh != NULL) {
		if (cc->wmh->flags & InputHint) {
			if (cc->wmh->input == 1)
				cc->flags |= CLIENT_INPUT;
		}
	}
d504 10
@


1.154
log
@Stash Class and WM Hints in client_ctx
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.153 2013/12/10 21:27:37 okan Exp $
a70 1
	cc->state = mapped ? NormalState : IconicState;
d105 2
a106 4
		if ((cc->wmh) && (cc->wmh->flags & StateHint)) {
			cc->state = cc->wmh->initial_state;
			xu_set_wm_state(cc->win, cc->state);
		}
a109 3
	if (xu_get_wm_state(cc->win, &state) < 0)
		state = NormalState;

d120 3
d425 4
a428 1
	(cc->state == IconicState) ? client_unhide(cc) : client_raise(cc);
d454 1
a454 2
	cc->state = IconicState;
	xu_set_wm_state(cc->win, cc->state);
d466 1
a466 2
	cc->state = NormalState;
	xu_set_wm_state(cc->win, cc->state);
d983 23
@


1.153
log
@Redraw client border when unhiding; during a hide, we just unset
the active flag but never redraw since it'll be in IconicState.

Behaviour reported by sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.152 2013/11/27 17:04:35 okan Exp $
a60 1
	XClassHint		 xch;
a61 1
	XWMHints		*wmhints;
a74 2
	client_getsizehints(cc);

d80 2
a81 4
	if (XGetClassHint(X_Dpy, cc->win, &xch)) {
		cc->app_name = xch.res_name;
		cc->app_class = xch.res_class;
	}
d83 2
d97 3
a99 3
	if ((wmhints = XGetWMHints(X_Dpy, cc->win)) != NULL) {
		if (wmhints->flags & InputHint) {
			if (wmhints->input == 1)
d106 2
a107 2
		if ((wmhints) && (wmhints->flags & StateHint)) {
			cc->state = wmhints->initial_state;
a110 2
	if (wmhints)
		XFree(wmhints);
a132 1
	client_wm_protocols(cc);
a160 5
	if (cc->app_name != NULL)
		XFree(cc->app_name);
	if (cc->app_class != NULL)
		XFree(cc->app_class);

d166 7
@


1.152
log
@alter -r1.145 getsizehints to deal with clients that don't have
WM_NORMAL_HINTS.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.151 2013/11/27 14:20:32 okan Exp $
d474 1
@


1.151
log
@simplify/unfold
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.150 2013/11/27 00:01:23 okan Exp $
d721 1
a721 1
	XSizeHints	*size;
d723 2
a724 2
	if ((size = XAllocSizeHints()) == NULL)
		warnx("XAllocSizeHints failure");
d726 1
a726 2
	if (!XGetWMNormalHints(X_Dpy, cc->win, size, &tmp))
		size->flags = 0;
d728 21
a748 23
	cc->hint.flags = size->flags;

	if (size->flags & PBaseSize) {
		cc->hint.basew = size->base_width;
		cc->hint.baseh = size->base_height;
	} else if (size->flags & PMinSize) {
		cc->hint.basew = size->min_width;
		cc->hint.baseh = size->min_height;
	}
	if (size->flags & PMinSize) {
		cc->hint.minw = size->min_width;
		cc->hint.minh = size->min_height;
	} else if (size->flags & PBaseSize) {
		cc->hint.minw = size->base_width;
		cc->hint.minh = size->base_height;
	}
	if (size->flags & PMaxSize) {
		cc->hint.maxw = size->max_width;
		cc->hint.maxh = size->max_height;
	}
	if (size->flags & PResizeInc) {
		cc->hint.incw = size->width_inc;
		cc->hint.inch = size->height_inc;
d753 7
a759 7
	if (size->flags & PAspect) {
		if (size->min_aspect.x > 0)
			cc->hint.mina = (float)size->min_aspect.y /
			    size->min_aspect.x;
		if (size->max_aspect.y > 0)
			cc->hint.maxa = (float)size->max_aspect.x /
			    size->max_aspect.y;
a760 3

	if (size)
		XFree(size);
@


1.150
log
@Rewrite active/inactive client handling in client_setactive();
client_leave() served no real purpose, likewise no reason to handle
LeaveNotify events since an EnterNotify will process the next active
client (and we don't have anything important to process anyway), so
xev_handle_leavenotify() goes as well.  Allows a simplification of
client_mtf() and client_cycle_leave() for clarity.  While here, unify a
few client_current() checks.

No intended behaviour change.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.149 2013/11/12 21:25:00 okan Exp $
d784 2
a785 3
	if (cc->hint.mina > 0 && cc->hint.maxa > 0) {
		if (cc->hint.maxa <
		    (float)cc->geom.w / cc->geom.h)
d787 1
a787 2
		else if (cc->hint.mina <
		    (float)cc->geom.h / cc->geom.w)
@


1.149
log
@Alter the r1.35 of event.c race fix.  Remove the forward looking event
queue check (removing the need for a server grab/ungrab) - if the client
is going away, let it fall all the way through to a DestroyNotify event.
There's no longer a need for us to manually destroy a client ourselves
(removing yet another server grab/ungrab).  Instead, when the
UnmapNotify event is synthetic, simply set the state to Withdrawn (as
per ICCCM), else Iconic (in our case 'hidden').

Verified with test case from the 2009 race which was the original reason
for r1.35 of event.c.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.148 2013/11/11 12:51:15 okan Exp $
d183 1
a183 1
client_leave(struct client_ctx *cc)
d185 2
a186 5
	if (cc == NULL)
		cc = client_current();
	if (cc == NULL)
		return;
}
d188 1
a188 4
void
client_setactive(struct client_ctx *cc, int fg)
{
	struct screen_ctx	*sc;
d190 7
a196 4
	if (cc == NULL)
		cc = client_current();
	if (cc == NULL)
		return;
d198 4
a201 1
	sc = cc->sc;
d203 3
a205 24
	if (fg) {
		XInstallColormap(X_Dpy, cc->colormap);
		if ((cc->flags & CLIENT_INPUT) ||
		    ((cc->flags & CLIENT_WM_TAKE_FOCUS) == 0)) {
			XSetInputFocus(X_Dpy, cc->win,
			    RevertToPointerRoot, CurrentTime);
		}
		if (cc->flags & CLIENT_WM_TAKE_FOCUS)
			client_msg(cc, cwmh[WM_TAKE_FOCUS]);
		conf_grab_mouse(cc->win);
		/*
		 * If we're in the middle of alt-tabbing, don't change
		 * the order please.
		 */
		if (!sc->cycling)
			client_mtf(cc);
	} else
		client_leave(cc);

	if (fg && cc != client_current()) {
		client_setactive(NULL, 0);
		_curcc = cc;
		xu_ewmh_net_active_window(sc, cc->win);
	}
d207 2
a208 1
	cc->active = fg;
d210 2
d625 1
a625 1
client_cycle_leave(struct screen_ctx *sc, struct client_ctx *cc)
d627 2
d631 2
a632 2
	client_mtf(NULL);
	if (cc) {
d711 1
a711 6
	struct screen_ctx	*sc;

	if (cc == NULL)
		cc = client_current();
	if (cc == NULL)
		return;
a712 1
	sc = cc->sc;
@


1.148
log
@Put back the border draw call in client_resize; since we are adding and
removing the border on maximized clients we need to redraw.

Also noticed by Tim van der Molen
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.147 2013/11/08 17:35:12 okan Exp $
d152 1
a152 1
client_delete(struct client_ctx *cc, int destroy)
a155 9

	if (destroy) {
		XGrabServer(X_Dpy);
		cc->state = WithdrawnState;
		xu_set_wm_state(cc->win, cc->state);
		XRemoveFromSaveSet(X_Dpy, cc->win);
		XSync(X_Dpy, False);
		XUngrabServer(X_Dpy);
	}
@


1.147
log
@stash WMProtocols in flags
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.146 2013/11/05 00:55:42 okan Exp $
d403 2
@


1.146
log
@quick keyboard focus fix for clients that neither populate wmhints nor wmprotocols, like rdesktop; focus needs to be re-visited
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.145 2013/11/02 19:13:57 okan Exp $
d215 1
a215 1
		    ((cc->xproto & _WM_TAKE_FOCUS) == 0)) {
d219 1
a219 1
		if (cc->xproto & _WM_TAKE_FOCUS)
d535 1
a535 1
				cc->xproto |= _WM_DELETE_WINDOW;
d537 1
a537 1
				cc->xproto |= _WM_TAKE_FOCUS;
d562 1
a562 1
	if (cc->xproto & _WM_DELETE_WINDOW)
@


1.145
log
@The only reason we need to keep XSizeHints in our client_ctx is for
flags, so just add one to hints; consolidates sizehints and shrinks.
Additionally don't abuse PSize for XGetWMNormalHints() failures.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.144 2013/11/01 21:54:20 okan Exp $
d214 2
a215 1
		if (cc->flags & CLIENT_INPUT) {
@


1.144
log
@x/y from XSizeHints are obsolete (and have been for a long time), so
instead use x/y from XWindowAttributes when USPosition|PPosition are
set.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.143 2013/11/01 14:07:19 okan Exp $
a75 1
	cc->size = XAllocSizeHints();
a176 1
	XFree(cc->size);
d686 1
a686 1
	if (cc->size->flags & (USPosition|PPosition)) {
d749 1
d751 2
a752 2
	if (!XGetWMNormalHints(X_Dpy, cc->win, cc->size, &tmp))
		cc->size->flags = PSize;
d754 26
a779 21
	if (cc->size->flags & PBaseSize) {
		cc->hint.basew = cc->size->base_width;
		cc->hint.baseh = cc->size->base_height;
	} else if (cc->size->flags & PMinSize) {
		cc->hint.basew = cc->size->min_width;
		cc->hint.baseh = cc->size->min_height;
	}
	if (cc->size->flags & PMinSize) {
		cc->hint.minw = cc->size->min_width;
		cc->hint.minh = cc->size->min_height;
	} else if (cc->size->flags & PBaseSize) {
		cc->hint.minw = cc->size->base_width;
		cc->hint.minh = cc->size->base_height;
	}
	if (cc->size->flags & PMaxSize) {
		cc->hint.maxw = cc->size->max_width;
		cc->hint.maxh = cc->size->max_height;
	}
	if (cc->size->flags & PResizeInc) {
		cc->hint.incw = cc->size->width_inc;
		cc->hint.inch = cc->size->height_inc;
d784 7
a790 7
	if (cc->size->flags & PAspect) {
		if (cc->size->min_aspect.x > 0)
			cc->hint.mina = (float)cc->size->min_aspect.y /
			    cc->size->min_aspect.x;
		if (cc->size->max_aspect.y > 0)
			cc->hint.maxa = (float)cc->size->max_aspect.x /
			    cc->size->max_aspect.y;
d792 3
@


1.143
log
@re-add support for WM_TAKE_FOCUS, and additionally this time only call
XSetInputFocus() for clients that have the InputHint; latter fix
discovered by Valery Masiutsin with a PoC patch - solves keyboard input
focus loss for java apps.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.142 2013/10/25 19:46:16 okan Exp $
d698 2
a699 4
		if (cc->size->x > 0)
			cc->geom.x = MIN(cc->size->x, xslack);
		if (cc->size->y > 0)
			cc->geom.y = MIN(cc->size->y, yslack);
@


1.142
log
@A client_delete should behave differently depending on whether the
triggering event was unmap (with pending destroy) log destroy; we only
need to grab/ungrab the server lock, set WithdrawnState and
XRemoveFromSaveSet clients coming from an unmap event - doing so for
clients coming from destroy are already gone, hence we generate errors.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.141 2013/10/20 01:35:47 okan Exp $
d102 6
d111 3
a113 6
		if ((wmhints = XGetWMHints(X_Dpy, cc->win)) != NULL) {
			if (wmhints->flags & StateHint) {
				cc->state = wmhints->initial_state;
				xu_set_wm_state(cc->win, cc->state);
			}
			XFree(wmhints);
d116 2
d216 6
a221 2
		XSetInputFocus(X_Dpy, cc->win,
		    RevertToPointerRoot, CurrentTime);
@


1.141
log
@revert 1.138 (WM_TAKE_FOCUS) for now
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.140 2013/10/19 19:39:34 okan Exp $
d148 1
a148 1
client_delete(struct client_ctx *cc)
d153 8
a160 6
	XGrabServer(X_Dpy);
	cc->state = WithdrawnState;
	xu_set_wm_state(cc->win, cc->state);
	XRemoveFromSaveSet(X_Dpy, cc->win);
	XSync(X_Dpy, False);
	XUngrabServer(X_Dpy);
@


1.140
log
@Using xu_btn_ungrab() buttons during client_leave doesn't work (error
BadValue) when the modifier is already AnyModifier .  Instead alter
xu_btn_ungrab() to ungrab AnyButton/AnyModifier and call it only when a
client is coming into focus in client_setactive(), instead of iterating
over ignore mods - matches how we handle key grabs.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.139 2013/10/19 18:59:22 okan Exp $
a210 2
		if (cc->xproto & _WM_TAKE_FOCUS)
			client_msg(cc, cwmh[WM_TAKE_FOCUS]);
@


1.139
log
@I believe we redraw the border in too many cases; likely a leftover from
the cc->pwin days - don't redraw on every unhide, resize, and mouse
move/resize Expose event (note, all Expose events trigger a redraw
anyway).

Tested with some finicky X apps I could think of, though I'm sure others
will find more - if so, and they 'lose' the border, please report!
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.138 2013/10/19 00:24:54 okan Exp $
a188 2
	struct screen_ctx	*sc;

a192 3

	sc = cc->sc;
	xu_btn_ungrab(sc->rootwin, AnyModifier, Button1);
@


1.138
log
@For clients that support WM_TAKE_FOCUS in their WM_PROTOCOLS property, send
a ClientMessage event.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.137 2013/10/03 13:51:59 okan Exp $
a400 2
	client_draw_border(cc);

a495 1
	client_draw_border(cc);
@


1.137
log
@unify type; no change
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.136 2013/07/15 23:51:59 okan Exp $
d216 2
@


1.136
log
@collapse lines
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.135 2013/07/15 14:50:44 okan Exp $
d844 1
a844 1
	    PROP_MWM_HINTS_ELEMENTS, (u_char **)&mwmh) == MWM_NUMHINTS)
@


1.135
log
@simplify atom handling; allows us to limit to one round-trip to server
for gathering Atoms.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.134 2013/06/10 21:37:30 okan Exp $
d843 1
a843 2
	if (xu_getprop(cc->win,
	    cwmh[_MOTIF_WM_HINTS], cwmh[_MOTIF_WM_HINTS],
@


1.134
log
@move synthetic responses and have client_msg only work with WM_PROTOCOLS,
since that's all ClientMessageEvent is for anyway.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.133 2013/05/23 16:52:39 okan Exp $
d532 1
a532 1
			if (p[i] == cwmh[WM_DELETE_WINDOW].atom)
d534 1
a534 1
			else if (p[i] == cwmh[WM_TAKE_FOCUS].atom)
d549 1
a549 1
	cm.message_type = cwmh[WM_PROTOCOLS].atom;
d561 1
a561 1
		client_msg(cc, cwmh[WM_DELETE_WINDOW].atom);
d572 1
a572 1
	if (!xu_getstrprop(cc->win, ewmh[_NET_WM_NAME].atom, &newname))
d844 1
a844 1
	    cwmh[_MOTIF_WM_HINTS].atom, cwmh[_MOTIF_WM_HINTS].atom,
@


1.133
log
@alter conf_grab(_kbd) to first ungrab AnyKey/AnyModifier, then proceed
to grab keys in keybindingq.  we don't need to ungrab/grab on every
addition to the queue, just once with a complete keybindingq; simplify
grabbing keys per screen (during init) and during a MappingNotify.

while here, change conf_grab_{kbd,mouse} to require only a Window.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.132 2013/05/20 21:13:58 okan Exp $
d126 1
a126 1
	xu_configure(cc);
d403 1
a403 1
	xu_configure(cc);
d410 1
a410 1
	xu_configure(cc);
d426 20
d542 16
d561 1
a561 2
		xu_sendmsg(cc->win,
		    cwmh[WM_PROTOCOLS].atom, cwmh[WM_DELETE_WINDOW].atom);
@


1.132
log
@add support for _NET_WM_STATE_MAXIMIZED_{HORZ,VERT}; from Alexander Polakov.

while I'm unsure of the final look of _NET_WM_STATE, there's no reason
to delay this support.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.131 2013/05/19 23:09:59 okan Exp $
d216 1
a216 1
		conf_grab_mouse(cc);
@


1.131
log
@- switch border colors to Xft
- merge border/menu color structures/functions since they now both use Xft
- switch xu_xorcolor to operating on XftColor instead of just
  XRenderColor (basically adding pixel)
- if color name allocation fails, revert back to default (this, along
  with font validation should occur during config parse, but we don't
  have screens setup yet - likely to change at some point)
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.130 2013/05/19 17:02:04 okan Exp $
d136 1
d305 1
d346 1
d387 1
d396 1
@


1.130
log
@use XGetWMProtocols and simplify WM_PROTOCOL handling
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.129 2013/05/11 22:01:07 okan Exp $
d483 1
a483 1
			pixel = sc->color[CWM_COLOR_BORDER_GROUP];
d486 1
a486 1
			pixel = sc->color[CWM_COLOR_BORDER_UNGROUP];
d489 1
a489 1
			pixel = sc->color[CWM_COLOR_BORDER_ACTIVE];
d493 1
a493 1
		pixel = sc->color[CWM_COLOR_BORDER_INACTIVE];
@


1.129
log
@new -> init
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.128 2013/05/06 16:03:11 okan Exp $
d39 1
a39 1
static void			 client_update(struct client_ctx *);
d135 1
a135 1
	client_update(cc);
d500 1
a500 1
client_update(struct client_ctx *cc)
d503 1
a503 2
	int	 i;
	long	 n;
d505 9
a513 11
	if ((n = xu_getprop(cc->win, cwmh[WM_PROTOCOLS].atom,
		 XA_ATOM, 20L, (u_char **)&p)) <= 0)
		return;

	for (i = 0; i < n; i++)
		if (p[i] == cwmh[WM_DELETE_WINDOW].atom)
			cc->xproto |= CLIENT_PROTO_DELETE;
		else if (p[i] == cwmh[WM_TAKE_FOCUS].atom)
			cc->xproto |= CLIENT_PROTO_TAKEFOCUS;

	XFree(p);
d519 1
a519 1
	if (cc->xproto & CLIENT_PROTO_DELETE)
@


1.128
log
@remove group in client_delete directly.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.127 2013/04/17 13:57:06 okan Exp $
d58 1
a58 1
client_new(Window win, struct screen_ctx *sc, int mapped)
@


1.127
log
@mechanical xu_{get,set}state -> xu_{get,set}_wm_state change
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.126 2013/04/17 13:52:20 okan Exp $
a151 2
	group_client_delete(cc);

a155 1

d163 3
@


1.126
log
@slightly rework WM_STATE set/get to make it less ambigious; will be more clear
on what needs to change to make it right in the end.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.125 2013/04/14 16:13:17 okan Exp $
d108 1
a108 1
				xu_setstate(cc->win, cc->state);
d115 1
a115 1
	if (xu_getstate(cc->win, &state) < 0)
d156 1
a156 1
	xu_setstate(cc->win, cc->state);
d457 1
a457 1
	xu_setstate(cc->win, cc->state);
d470 1
a470 1
	xu_setstate(cc->win, cc->state);
@


1.125
log
@only a window is required to set WM_STATE.  also un-confuse xu_ptr_getpos
by using 'win' instead of 'rootwin' so as not to imply only the root
window is queried, rather any window.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.124 2013/04/12 20:54:27 okan Exp $
d104 1
d106 4
a109 3
			if (wmhints->flags & StateHint)
				xu_setstate(cc, wmhints->initial_state);

a111 1
		client_move(cc);
d155 2
a156 1
	xu_setstate(cc, WithdrawnState);
d456 2
a457 1
	xu_setstate(cc, IconicState);
d469 2
a470 1
	xu_setstate(cc, NormalState);
@


1.124
log
@we handle WM_STATE here, so remove misleading comment.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.123 2013/04/12 20:45:57 okan Exp $
d114 1
a114 1
	if (xu_getstate(cc, &state) < 0)
@


1.123
log
@we already set window state in client_hide or client_unhide right before, so
there's no need to do it again.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.122 2013/04/05 17:07:25 okan Exp $
a449 1
	/* XXX - add wm_state stuff */
@


1.122
log
@zap stray whitespace
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.121 2013/04/03 20:22:55 okan Exp $
a127 1
	xu_setstate(cc, cc->state);
@


1.121
log
@- no reason to breakout ClassHints work, so fold into client_{new,delete},
  but keep _MOTIF_WM_HINTS separate.
- simplify fetching app/class hint.
- fix _MOTIF_WM_HINTS Atom type.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.120 2013/04/03 19:20:50 okan Exp $
d577 1
a577 1
		oldcc = (flags & CWM_RCYCLE ? 
d609 1
a609 1
client_cycle_leave(struct screen_ctx *sc, struct client_ctx *cc) 
@


1.120
log
@move XUngrabServer to the end of client_new() to avoid races where clients,
such as those using sdl, attempt to manage the clients themselves when the
clients aren't fully ready.  other wm's grab the xserver during the whole
client setup process, so match.

behavior found by jsg.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.119 2013/01/08 15:16:05 okan Exp $
d40 1
a40 2
static void			 client_gethints(struct client_ctx *);
static void			 client_freehints(struct client_ctx *);
d61 1
d85 6
a134 1
	client_gethints(cc);
d170 4
a180 1
	client_freehints(cc);
d800 1
a800 1
client_gethints(struct client_ctx *cc)
a801 1
	XClassHint		 xch;
d804 2
a805 8
	if (XGetClassHint(X_Dpy, cc->win, &xch)) {
		if (xch.res_name != NULL)
			cc->app_name = xch.res_name;
		if (xch.res_class != NULL)
			cc->app_class = xch.res_class;
	}

	if (xu_getprop(cc->win, cwmh[_MOTIF_WM_HINTS].atom, _MOTIF_WM_HINTS,
a810 9
}

static void
client_freehints(struct client_ctx *cc)
{
	if (cc->app_name != NULL)
		XFree(cc->app_name);
	if (cc->app_class != NULL)
		XFree(cc->app_class);
@


1.119
log
@add per-group vert/horiz tiling support; introduces 2 new bind commands,
'vtile' and 'htile'; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.118 2013/01/08 04:12:51 okan Exp $
a123 3
	XSync(X_Dpy, False);
	XUngrabServer(X_Dpy);

d134 3
@


1.118
log
@teach screen_find_xinerama() about gap and adjust (simplify) callers;
menu becomes gap-aware for free.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.117 2013/01/07 21:53:23 okan Exp $
d868 118
@


1.117
log
@fix menu/client placement in panning setups; XineramaQueryScreens gives
us the width of the psuedo screen, but here we need the edge instead
(xmax/ymax); just re-use w/h here for now.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.116 2013/01/06 01:01:26 okan Exp $
d289 1
a289 4
	cc->geom.x = xine.x + sc->gap.left;
	cc->geom.y = xine.y + sc->gap.top;
	cc->geom.h = xine.h - (sc->gap.top + sc->gap.bottom);
	cc->geom.w = xine.w - (sc->gap.left + sc->gap.right);
d329 2
a330 3
	cc->geom.y = xine.y + sc->gap.top;
	cc->geom.h = xine.h - (cc->bwidth * 2) - (sc->gap.top +
	    sc->gap.bottom);
d369 2
a370 3
	cc->geom.x = xine.x + sc->gap.left;
	cc->geom.w = xine.w - (cc->bwidth * 2) - (sc->gap.left +
	    sc->gap.right);
d670 1
a670 4
			cc->geom.x = MAX(MIN(xmouse, xslack),
			    xine.x + sc->gap.left);
			if (cc->geom.x > (xslack - sc->gap.right))
				cc->geom.x -= sc->gap.right;
d672 2
a673 2
			cc->geom.x = xine.x + sc->gap.left;
			cc->geom.w = xine.w - sc->gap.left;
d676 1
a676 4
			cc->geom.y = MAX(MIN(ymouse, yslack),
			    xine.y + sc->gap.top);
			if (cc->geom.y > (yslack - sc->gap.bottom))
				cc->geom.y -= sc->gap.bottom;
d678 2
a679 2
			cc->geom.y = xine.y + sc->gap.top;
			cc->geom.h = xine.h - sc->gap.top;
@


1.116
log
@use cc->bwidth in client_vmax since we've yet to reset it (matches
client_hmax); from Jan Stary
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.115 2013/01/04 16:30:03 okan Exp $
d663 2
@


1.115
log
@rename {h,v}max functions for consistency; from Jan Stary
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.114 2013/01/04 16:23:04 okan Exp $
d324 1
a324 1
		cc->geom.w += Conf.bwidth * 2;
@


1.114
log
@get rid of struct color
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.113 2013/01/02 21:37:21 okan Exp $
d301 1
a301 1
client_vertmaximize(struct client_ctx *cc)
d342 1
a342 1
client_horizmaximize(struct client_ctx *cc)
@


1.113
log
@re-work client_snapcalc() so it takes client and edge dimensions with
snapdist; allows for simplier snap calculations.

required for an upcoming diff for honoring gap.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.112 2013/01/02 16:26:34 okan Exp $
d478 1
a478 1
			pixel = sc->color[CWM_COLOR_BORDER_GROUP].pixel;
d481 1
a481 1
			pixel = sc->color[CWM_COLOR_BORDER_UNGROUP].pixel;
d484 1
a484 1
			pixel = sc->color[CWM_COLOR_BORDER_ACTIVE].pixel;
d488 1
a488 1
		pixel = sc->color[CWM_COLOR_BORDER_INACTIVE].pixel;
@


1.112
log
@have screen_find_xinerama() return struct geom *reliably* instead of
XineramaScreenInfo; simplifies goop around the callers.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.111 2013/01/02 02:19:20 okan Exp $
d853 1
a853 1
client_snapcalc(int n, int dn, int nmax, int bwidth, int snapdist)
d855 1
a855 1
	int	 n0, n1, s0, s1;
a857 2
	n0 = n;
	n1 = n + dn + (bwidth * 2);
d859 2
a860 2
	if (abs(n0) <= snapdist)
		s0 = -n0;
d862 2
a863 2
	if (nmax - snapdist <= n1 && n1 <= nmax + snapdist)
		s1 = nmax - n1;
@


1.111
log
@more variable consistency
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.110 2013/01/02 02:02:08 okan Exp $
d258 1
a258 2
	XineramaScreenInfo	*xine;
	int			 x_org, y_org, xmax, ymax;
a287 10
	if (xine) {
		x_org = xine->x_org;
		y_org = xine->y_org;
		xmax = xine->width;
		ymax = xine->height;
	} else {
		x_org = y_org = 0;
		xmax = sc->view.w;
		ymax = sc->view.h;
	}
d289 4
a292 4
	cc->geom.x = x_org + sc->gap.left;
	cc->geom.y = y_org + sc->gap.top;
	cc->geom.h = ymax - (sc->gap.top + sc->gap.bottom);
	cc->geom.w = xmax - (sc->gap.left + sc->gap.right);
d304 1
a304 2
	XineramaScreenInfo	*xine;
	int			 y_org, ymax;
a330 7
	if (xine) {
		y_org = xine->y_org;
		ymax = xine->height;
	} else {
		y_org = 0;
		ymax = sc->view.h;
	}
d332 2
a333 2
	cc->geom.y = y_org + sc->gap.top;
	cc->geom.h = ymax - (cc->bwidth * 2) - (sc->gap.top +
d345 1
a345 2
	XineramaScreenInfo	*xine;
	int			 x_org, xmax;
a371 7
	if (xine) {
		x_org = xine->x_org;
		xmax = xine->width;
	} else {
		x_org = 0;
		xmax = sc->view.w;
	}
d373 2
a374 2
	cc->geom.x = x_org + sc->gap.left;
	cc->geom.w = xmax - (cc->bwidth * 2) - (sc->gap.left +
d658 1
a658 2
		XineramaScreenInfo	*xine;
		int			 x_org, y_org, xmax, ymax;
d663 2
a664 12
		if (xine) {
			x_org = xine->x_org;
			y_org = xine->y_org;
			xmax = xine->x_org + xine->width;
			ymax = xine->y_org + xine->height;
		} else {
			x_org = y_org = 0;
			xmax = sc->view.w;
			ymax = sc->view.h;
		}
		xmouse = MAX(xmouse, x_org) - cc->geom.w / 2;
		ymouse = MAX(ymouse, y_org) - cc->geom.h / 2;
d666 2
a667 2
		xmouse = MAX(xmouse, x_org);
		ymouse = MAX(ymouse, y_org);
d669 2
a670 2
		xslack = xmax - cc->geom.w - cc->bwidth * 2;
		yslack = ymax - cc->geom.h - cc->bwidth * 2;
d672 1
a672 1
		if (xslack >= x_org) {
d674 1
a674 1
			    x_org + sc->gap.left);
d678 2
a679 2
			cc->geom.x = x_org + sc->gap.left;
			cc->geom.w = xmax - sc->gap.left;
d681 1
a681 1
		if (yslack >= y_org) {
d683 1
a683 1
			    y_org + sc->gap.top);
d687 2
a688 2
			cc->geom.y = y_org + sc->gap.top;
			cc->geom.h = ymax - sc->gap.top;
@


1.110
log
@info->xine, for consistent variable names
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.109 2013/01/01 14:26:29 okan Exp $
d258 1
a259 1
	XineramaScreenInfo	*xine;
d315 1
a316 1
	XineramaScreenInfo	*xine;
d364 1
a365 1
	XineramaScreenInfo	*xine;
d686 2
a687 2
		int			 xmouse, ymouse, xorig, yorig;
		int			 xmax, ymax;
d692 4
a695 4
			xorig = xine->x_org;
			yorig = xine->y_org;
			xmax = xorig + xine->width;
			ymax = yorig + xine->height;
d697 1
a697 1
			xorig = yorig = 0;
d701 2
a702 2
		xmouse = MAX(xmouse, xorig) - cc->geom.w / 2;
		ymouse = MAX(ymouse, yorig) - cc->geom.h / 2;
d704 2
a705 2
		xmouse = MAX(xmouse, xorig);
		ymouse = MAX(ymouse, yorig);
d710 1
a710 1
		if (xslack >= xorig) {
d712 1
a712 1
			    xorig + sc->gap.left);
d716 1
a716 1
			cc->geom.x = xorig + sc->gap.left;
d719 1
a719 1
		if (yslack >= yorig) {
d721 1
a721 1
			    yorig + sc->gap.top);
d725 1
a725 1
			cc->geom.y = yorig + sc->gap.top;
@


1.109
log
@replace emptystring with strdup here as well so we know we are free'ing
a malloc'd variable everytime; from Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.108 2013/01/01 14:19:56 okan Exp $
d685 1
a685 1
		XineramaScreenInfo	*info;
d690 6
a695 6
		info = screen_find_xinerama(sc, xmouse, ymouse);
		if (info) {
			xorig = info->x_org;
			yorig = info->y_org;
			xmax = xorig + info->width;
			ymax = yorig + info->height;
@


1.108
log
@make num of groups no longer off-by-one; from Alexander Polakov

note that a re-exec of cwm will not rewrite the group number atom of
*existing* clients, so they will remain off-by-one until each client has
its atom updated, or of course a restart of X.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.107 2012/12/17 18:35:26 okan Exp $
a43 1
static char		 emptystring[] = "";
d168 1
a168 2
		if (wn->name != emptystring)
			free(wn->name);
d559 1
a559 1
			newname = emptystring;
d582 1
a582 2
		if (wn->name != emptystring)
			free(wn->name);
@


1.107
log
@cmap -> colormap in client_ctx
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.106 2012/12/17 17:48:57 okan Exp $
d879 1
a879 1
			group_movetogroup(cc, tc->group->shortcut - 1);
@


1.106
log
@replace client highlight with a client flag
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.105 2012/12/17 14:58:46 okan Exp $
d95 1
a95 1
	cc->cmap = wattr.colormap;
d205 1
a205 1
		XInstallColormap(X_Dpy, cc->cmap);
@


1.105
log
@make client_mtf static
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.104 2012/12/17 14:26:29 okan Exp $
a492 1
	cc->highlight = 0;
d505 2
a506 2
		switch (cc->highlight) {
		case CLIENT_HIGHLIGHT_GROUP:
d509 1
a509 1
		case CLIENT_HIGHLIGHT_UNGROUP:
@


1.104
log
@current_client() returns _curcc, so use it where appropriate
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.103 2012/11/09 03:52:02 okan Exp $
d36 1
d735 1
a735 1
void
a745 2

	/* Move to front. */
@


1.103
log
@sort
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.102 2012/11/07 20:34:39 okan Exp $
d161 1
a161 1
	if (_curcc == cc)
d183 1
a183 1
		cc = _curcc;
d197 1
a197 1
		cc = _curcc;
d217 1
a217 1
	if (fg && _curcc != cc) {
d483 1
a483 1
	if (cc == _curcc)
d740 1
a740 1
		cc = _curcc;
@


1.102
log
@get rid of the xfree() wrapper around free(); from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.101 2012/09/09 19:47:47 okan Exp $
d27 1
a29 1
#include <stdio.h>
@


1.101
log
@extend client_resize so that it can know when to reset max flags and
bwidth; this allows a client to be resized from a max state, which now
gets treated like a non-max'd client.  based on a diff that does part of
this in a different way from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.100 2012/07/16 01:53:14 okan Exp $
d169 2
a170 2
			xfree(wn->name);
		xfree(wn);
d174 1
a174 1
	xfree(cc);
d585 2
a586 2
			xfree(wn->name);
		xfree(wn);
@


1.100
log
@unify various max routines to match client placement and partially menu ones
when calculating screen dimensions.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.99 2012/07/16 01:36:30 okan Exp $
d309 1
a309 1
	client_resize(cc);
d358 1
a358 1
	client_resize(cc);
d407 1
a407 1
	client_resize(cc);
d411 1
a411 1
client_resize(struct client_ctx *cc)
d413 5
@


1.99
log
@move the HasXinerama check into screen_find_xinerama and simplify logic;
moves closer to logic in menu code.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.98 2012/07/13 17:01:04 okan Exp $
d259 1
a259 2
	int			 xmax = sc->view.w, ymax = sc->view.h;
	int			 x_org = 0, y_org = 0;
d295 4
d316 1
a316 1
	int			 y_org = 0, ymax = sc->view.h;
d347 3
d365 1
a365 1
	int			 x_org = 0, xmax = sc->view.w;
d396 3
@


1.98
log
@re-use geom struct in client_ctx (saved)geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.97 2012/07/13 15:21:35 okan Exp $
d261 1
d283 9
a291 12
	if (HasXinerama) {
		XineramaScreenInfo *xine;
		/*
		 * pick screen that the middle of the window is on.
		 * that's probably more fair than if just the origin of
		 * a window is poking over a boundary
		 */
		xine = screen_find_xinerama(sc,
		    cc->geom.x + cc->geom.w / 2,
		    cc->geom.y + cc->geom.h / 2);
		if (xine == NULL)
			goto calc;
d297 1
a297 1
calc:
d314 1
d338 4
a341 7
	if (HasXinerama) {
		XineramaScreenInfo *xine;
		xine = screen_find_xinerama(sc,
		    cc->geom.x + cc->geom.w / 2,
		    cc->geom.y + cc->geom.h / 2);
		if (xine == NULL)
			goto calc;
d345 1
a345 1
calc:
d360 1
d384 4
a387 7
	if (HasXinerama) {
		XineramaScreenInfo *xine;
		xine = screen_find_xinerama(sc,
		    cc->geom.x + cc->geom.w / 2,
		    cc->geom.y + cc->geom.h / 2);
		if (xine == NULL)
			goto calc;
d391 1
a391 1
calc:
d679 2
a680 4
		if (HasXinerama) {
			info = screen_find_xinerama(sc, xmouse, ymouse);
			if (info == NULL)
				goto noxine;
a685 1
noxine:
@


1.97
log
@convert xmax/ymax uses to view geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.96 2012/07/04 18:00:13 okan Exp $
d92 2
a93 2
	cc->geom.width = wattr.width;
	cc->geom.height = wattr.height;
d273 1
a273 1
		cc->savegeom.height = cc->geom.height;
d278 1
a278 1
		cc->savegeom.width = cc->geom.width;
d290 2
a291 2
		    cc->geom.x + cc->geom.width / 2,
		    cc->geom.y + cc->geom.height / 2);
d302 2
a303 2
	cc->geom.height = ymax - (sc->gap.top + sc->gap.bottom);
	cc->geom.width = xmax - (sc->gap.left + sc->gap.right);
d322 1
a322 1
		cc->geom.height = cc->savegeom.height;
d325 1
a325 1
			cc->geom.width -= cc->bwidth * 2;
d331 1
a331 1
	cc->savegeom.height = cc->geom.height;
d335 1
a335 1
		cc->geom.width += Conf.bwidth * 2;
d342 2
a343 2
		    cc->geom.x + cc->geom.width / 2,
		    cc->geom.y + cc->geom.height / 2);
d351 1
a351 1
	cc->geom.height = ymax - (cc->bwidth * 2) - (sc->gap.top +
d370 1
a370 1
		cc->geom.width = cc->savegeom.width;
d373 1
a373 1
			cc->geom.height -= cc->bwidth * 2;
d379 1
a379 1
	cc->savegeom.width = cc->geom.width;
d383 1
a383 1
		cc->geom.height += cc->bwidth * 2;
d390 2
a391 2
		    cc->geom.x + cc->geom.width / 2,
		    cc->geom.y + cc->geom.height / 2);
d399 1
a399 1
	cc->geom.width = xmax - (cc->bwidth * 2) - (sc->gap.left +
d413 1
a413 1
	    cc->geom.y, cc->geom.width, cc->geom.height);
d442 2
a443 2
		x = cc->geom.width / 2;
		y = cc->geom.height / 2;
d673 2
a674 2
		xslack = sc->view.w - cc->geom.width - cc->bwidth * 2;
		yslack = sc->view.h - cc->geom.height - cc->bwidth * 2;
d699 2
a700 2
		xmouse = MAX(xmouse, xorig) - cc->geom.width / 2;
		ymouse = MAX(ymouse, yorig) - cc->geom.height / 2;
d705 2
a706 2
		xslack = xmax - cc->geom.width - cc->bwidth * 2;
		yslack = ymax - cc->geom.height - cc->bwidth * 2;
d715 1
a715 1
			cc->geom.width = xmax - sc->gap.left;
d724 1
a724 1
			cc->geom.height = ymax - sc->gap.top;
d799 2
a800 2
		cc->geom.width -= cc->hint.basew;
		cc->geom.height -= cc->hint.baseh;
d806 2
a807 2
		    (float)cc->geom.width / cc->geom.height)
			cc->geom.width = cc->geom.height * cc->hint.maxa;
d809 2
a810 2
		    (float)cc->geom.height / cc->geom.width)
			cc->geom.height = cc->geom.width * cc->hint.mina;
d815 2
a816 2
		cc->geom.width -= cc->hint.basew;
		cc->geom.height -= cc->hint.baseh;
d820 2
a821 2
	cc->geom.width -= cc->geom.width % cc->hint.incw;
	cc->geom.height -= cc->geom.height % cc->hint.inch;
d824 2
a825 2
	cc->geom.width += cc->hint.basew;
	cc->geom.height += cc->hint.baseh;
d828 2
a829 2
	cc->geom.width = MAX(cc->geom.width, cc->hint.minw);
	cc->geom.height = MAX(cc->geom.height, cc->hint.minh);
d833 1
a833 1
		cc->geom.width = MIN(cc->geom.width, cc->hint.maxw);
d835 1
a835 1
		cc->geom.height = MIN(cc->geom.height, cc->hint.maxh);
d886 2
a887 2
	return (x < cc->geom.width && x >= 0 &&
	    y < cc->geom.height && y >= 0);
@


1.96
log
@fix missing atom (WM_PROTOCOLS) wrt new style handing; without this, the
window manager didn't know if a client supported CLIENT_PROTO_DELETE and
thus used a hammer, XKillClient.

behaviour reported by Tim van der Molen.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.95 2012/07/03 13:49:03 okan Exp $
d259 1
a259 1
	int			 xmax = sc->xmax, ymax = sc->ymax;
d315 1
a315 1
	int			 y_org = 0, ymax = sc->ymax;
d363 1
a363 1
	int			 x_org = 0, xmax = sc->xmax;
d673 2
a674 2
		xslack = sc->xmax - cc->geom.width - cc->bwidth * 2;
		yslack = sc->ymax - cc->geom.height - cc->bwidth * 2;
d696 2
a697 2
			xmax = sc->xmax;
			ymax = sc->ymax;
@


1.95
log
@re-implement atom handing; makes for a normalized and more consistent
separation between cwm and ewmh.  seen by a few.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.94 2012/05/16 01:09:17 okan Exp $
d522 1
a522 1
	if ((n = xu_getprop(cc->win, WM_PROTOCOLS,
@


1.94
log
@cycle through other common cycling modifiers; based on a diff from
Alexander Polakov.

ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.93 2012/05/13 15:17:13 okan Exp $
d129 2
a130 3
	/* append to the client list */
	XChangeProperty(X_Dpy, sc->rootwin, _NET_CLIENT_LIST, XA_WINDOW, 32,
	    PropModeAppend,  (unsigned char *)&cc->win, 1);
a144 1
	struct client_ctx	*tcc;
a145 2
	Window			*winlist;
	int			 i, j;
d158 2
a159 17
	/*
	 * Sadly we can't remove just one entry from a property, so we must
	 * redo the whole thing from scratch. this is the stupid way, the other
	 * way incurs many roundtrips to the server.
	 */
	i = j = 0;
	TAILQ_FOREACH(tcc, &Clientq, entry)
		i++;
	if (i > 0) {
		winlist = xmalloc(i * sizeof(*winlist));
		TAILQ_FOREACH(tcc, &Clientq, entry)
			winlist[j++] = tcc->win;
		XChangeProperty(X_Dpy, sc->rootwin, _NET_CLIENT_LIST,
		    XA_WINDOW, 32, PropModeReplace,
		    (unsigned char *)winlist, i);
		xfree(winlist);
	}
d220 1
a220 3
		XChangeProperty(X_Dpy, sc->rootwin, _NET_ACTIVE_WINDOW,
		    XA_WINDOW, 32, PropModeReplace,
		    (unsigned char *)&cc->win, 1);
d235 2
a236 2
	XChangeProperty(X_Dpy, sc->rootwin, _NET_ACTIVE_WINDOW,
	    XA_WINDOW, 32, PropModeReplace, (unsigned char *)&none, 1);
d527 1
a527 1
		if (p[i] == WM_DELETE_WINDOW)
d529 1
a529 1
		else if (p[i] == WM_TAKE_FOCUS)
d539 2
a540 1
		xu_sendmsg(cc->win, WM_PROTOCOLS, WM_DELETE_WINDOW);
d551 1
a551 1
	if (!xu_getstrprop(cc->win, _NET_WM_NAME, &newname))
d851 1
a851 1
	if (xu_getprop(cc->win, _MOTIF_WM_HINTS, _MOTIF_WM_HINTS,
@


1.93
log
@altpersist->cycling to be more clear that this is for cycling mod
persistence; based on a diff from Alexander Polakov, in preparation for
looping through other potential cycling modifiers.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.92 2012/05/13 15:15:54 okan Exp $
d645 12
@


1.92
log
@knf, some from a diff from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.91 2011/09/13 08:41:57 okan Exp $
d231 1
a231 1
		if (!sc->altpersist)
d641 2
a642 2
	/* reset when alt is released. XXX I hate this hack */
	sc->altpersist = 1;
@


1.91
log
@add WM_TRANSIENT_FOR event support: moves dialogs, toolbars and such to
the group of the main application window; based on a diff from Alexander
Polakov with CLIENT_IGNORE flag suggestion from oga@@.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.90 2011/09/05 07:37:55 okan Exp $
d397 1
a397 1
	} 
d616 2
a617 1
		oldcc = (flags & CWM_RCYCLE ? TAILQ_LAST(&sc->mruq, cycle_entry_q) :
d796 1
d916 1
a916 1
			return s0;
d918 1
a918 1
			return s1;
d920 1
a920 1
		return s0;
d922 1
a922 1
		return s1;
d924 1
a924 1
		return 0;
@


1.90
log
@restore a comment and add another for clarity.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.89 2011/09/04 16:59:31 oga Exp $
d116 2
d872 15
@


1.89
log
@Make flavours of maximisation additive.

i.e. horiz-max + vertmax = full maximisation.  full - horiz = vertmax.
etc.

Martynas wrote something like this once, so I did okan, this version
seems to finally deal with the corner cases.

ok okan@@.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.88 2011/09/03 09:42:33 okan Exp $
d303 4
a306 1
		/* * that's probably more fair than if just the origin of * a window is poking over a boundary
d400 1
@


1.88
log
@split off window hints from geometry so we don't need to carry them all
around when dealing with {,h,v}max.  same idea from oga.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.87 2011/09/03 09:20:58 okan Exp $
d284 2
a285 1
	if (cc->flags & CLIENT_MAXIMIZED) {
d288 27
a314 21
		cc->flags &= ~CLIENT_MAXIMIZED;
	} else {
		if (!(cc->flags & (CLIENT_VMAXIMIZED | CLIENT_HMAXIMIZED)))
			cc->savegeom = cc->geom;
		if (HasXinerama) {
			XineramaScreenInfo *xine;
			/*
			 * pick screen that the middle of the window is on.
			 * that's probably more fair than if just the origin of
			 * a window is poking over a boundary
			 */
			xine = screen_find_xinerama(sc,
			    cc->geom.x + cc->geom.width / 2,
			    cc->geom.y + cc->geom.height / 2);
			if (xine == NULL)
				goto calc;
			x_org = xine->x_org;
			y_org = xine->y_org;
			xmax = xine->width;
			ymax = xine->height;
		}
d316 6
a321 7
		cc->geom.x = x_org + sc->gap.left;
		cc->geom.y = y_org + sc->gap.top;
		cc->geom.height = ymax - (sc->gap.top + sc->gap.bottom);
		cc->geom.width = xmax - (sc->gap.left + sc->gap.right);
		cc->bwidth = 0;
		cc->flags |= CLIENT_MAXIMIZED;
	}
d323 1
d340 2
d343 22
a364 13
	} else {
		if (!(cc->flags & (CLIENT_MAXIMIZED | CLIENT_HMAXIMIZED)))
			cc->savegeom = cc->geom;
		if (HasXinerama) {
			XineramaScreenInfo *xine;
			xine = screen_find_xinerama(sc,
			    cc->geom.x + cc->geom.width / 2,
			    cc->geom.y + cc->geom.height / 2);
			if (xine == NULL)
				goto calc;
			y_org = xine->y_org;
			ymax = xine->height;
		}
d366 4
a369 5
		cc->geom.y = y_org + sc->gap.top;
		cc->geom.height = ymax - (cc->bwidth * 2) - (sc->gap.top +
		    sc->gap.bottom);
		cc->flags |= CLIENT_VMAXIMIZED;
	}
d371 1
d388 2
d391 21
a411 13
	} else {
		if (!(cc->flags & (CLIENT_MAXIMIZED | CLIENT_VMAXIMIZED)))
			cc->savegeom = cc->geom;
		if (HasXinerama) {
			XineramaScreenInfo *xine;
			xine = screen_find_xinerama(sc,
			    cc->geom.x + cc->geom.width / 2,
			    cc->geom.y + cc->geom.height / 2);
			if (xine == NULL)
				goto calc;
			x_org = xine->x_org;
			xmax = xine->width;
		}
d413 4
a416 5
		cc->geom.x = x_org + sc->gap.left;
		cc->geom.width = xmax - (cc->bwidth * 2) - (sc->gap.left +
		    sc->gap.right);
		cc->flags |= CLIENT_HMAXIMIZED;
	}
d418 1
@


1.87
log
@Add {r,}cycleingroup to cycle through clients belonging to the same
group as the active client (as opposed to all unhidden clients); from
Alexander Polakov, with a tiny tweak requested by oga.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.86 2011/07/14 11:39:53 okan Exp $
d728 2
a729 2
		cc->geom.basew = cc->size->base_width;
		cc->geom.baseh = cc->size->base_height;
d731 2
a732 2
		cc->geom.basew = cc->size->min_width;
		cc->geom.baseh = cc->size->min_height;
d735 2
a736 2
		cc->geom.minw = cc->size->min_width;
		cc->geom.minh = cc->size->min_height;
d738 2
a739 2
		cc->geom.minw = cc->size->base_width;
		cc->geom.minh = cc->size->base_height;
d742 2
a743 2
		cc->geom.maxw = cc->size->max_width;
		cc->geom.maxh = cc->size->max_height;
d746 2
a747 2
		cc->geom.incw = cc->size->width_inc;
		cc->geom.inch = cc->size->height_inc;
d749 2
a750 2
	cc->geom.incw = MAX(1, cc->geom.incw);
	cc->geom.inch = MAX(1, cc->geom.inch);
d754 1
a754 1
			cc->geom.mina = (float)cc->size->min_aspect.y /
d757 1
a757 1
			cc->geom.maxa = (float)cc->size->max_aspect.x /
d766 2
a767 2
	baseismin = (cc->geom.basew == cc->geom.minw) &&
	    (cc->geom.baseh == cc->geom.minh);
d771 2
a772 2
		cc->geom.width -= cc->geom.basew;
		cc->geom.height -= cc->geom.baseh;
d776 2
a777 2
	if (cc->geom.mina > 0 && cc->geom.maxa > 0) {
		if (cc->geom.maxa <
d779 2
a780 2
			cc->geom.width = cc->geom.height * cc->geom.maxa;
		else if (cc->geom.mina <
d782 1
a782 1
			cc->geom.height = cc->geom.width * cc->geom.mina;
d787 2
a788 2
		cc->geom.width -= cc->geom.basew;
		cc->geom.height -= cc->geom.baseh;
d792 2
a793 2
	cc->geom.width -= cc->geom.width % cc->geom.incw;
	cc->geom.height -= cc->geom.height % cc->geom.inch;
d796 2
a797 2
	cc->geom.width += cc->geom.basew;
	cc->geom.height += cc->geom.baseh;
d800 2
a801 2
	cc->geom.width = MAX(cc->geom.width, cc->geom.minw);
	cc->geom.height = MAX(cc->geom.height, cc->geom.minh);
d804 4
a807 4
	if (cc->geom.maxw)
		cc->geom.width = MIN(cc->geom.width, cc->geom.maxw);
	if (cc->geom.maxh)
		cc->geom.height = MIN(cc->geom.height, cc->geom.maxh);
@


1.86
log
@correct spelling; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.85 2011/06/24 06:06:24 okan Exp $
d570 1
a570 1
client_cycle(struct screen_ctx *sc, int reverse)
d582 1
a582 1
		oldcc = (reverse ? TAILQ_LAST(&sc->mruq, cycle_entry_q) :
d589 1
a589 1
		newcc = (reverse ? client_mruprev(newcc) :
d593 2
a594 1
		if (newcc->flags & (CLIENT_HIDDEN|CLIENT_IGNORE))
@


1.85
log
@introduce a new config option to snap to the screen edge.  'snapdist'
keyword taken from a diff from Sviatoslav Chagaev to do the same thing,
but implemented in a completely way (based on some very old code from
mk@@).  default set to 0, so no behavior change.

ok oga@@ (who would also like to take it further...)
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.84 2011/06/24 06:01:47 okan Exp $
d492 1
a492 1
			pixel = sc->color[CWM_COLOR_BORDOR_ACTIVE].pixel;
@


1.84
log
@re-do various bits of {,h,v}max for simplicity and less flag handling.
as a bonus, flipping between various combinations of vmax+hmax provides
a more predictable behavior.

commitski oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.83 2011/06/24 05:40:09 okan Exp $
d844 29
@


1.83
log
@alter a few function returns and prototypes; found by lint.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.82 2011/05/11 13:53:51 okan Exp $
d286 2
d313 2
a314 1
		cc->flags |= CLIENT_DOMAXIMIZE;
d330 4
a333 1
		cc->geom = cc->savegeom;
d351 1
a351 1
		cc->flags |= CLIENT_DOVMAXIMIZE;
d367 4
a370 1
		cc->geom = cc->savegeom;
d388 1
a388 1
		cc->flags |= CLIENT_DOHMAXIMIZE;
a396 17
	cc->flags &= ~(CLIENT_MAXIMIZED | CLIENT_VMAXIMIZED |
	    CLIENT_HMAXIMIZED);

	if (cc->flags & CLIENT_DOMAXIMIZE) {
		cc->bwidth = 0;
		cc->flags &= ~CLIENT_DOMAXIMIZE;
		cc->flags |= CLIENT_MAXIMIZED;
	} else if (cc->flags & CLIENT_DOVMAXIMIZE) {
		cc->flags &= ~CLIENT_DOVMAXIMIZE;
		cc->flags |= CLIENT_VMAXIMIZED;
	} else if (cc->flags & CLIENT_DOHMAXIMIZE) {
		cc->flags &= ~CLIENT_DOHMAXIMIZE;
		cc->flags |= CLIENT_HMAXIMIZED;
	} else {
		cc->bwidth = Conf.bwidth;
	}

a406 5
	if (cc->flags & CLIENT_VMAXIMIZED)
		cc->savegeom.x = cc->geom.x;
	if (cc->flags & CLIENT_HMAXIMIZED)
		cc->savegeom.y = cc->geom.y;

@


1.82
log
@tag and comment cleanup; ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: client.c,v 1.81 2011/05/07 17:15:37 okan Exp $
d140 1
a140 1
int
a191 2

	return (0);
d551 2
a552 3
		xu_getstrprop(cc->win, XA_WM_NAME, &newname);
	if (newname == NULL)
		newname = emptystring;
a579 2

	return;
d582 1
a582 1
struct client_ctx *
d592 1
a592 1
		return (NULL);
d612 1
a612 1
				return (NULL);	/* No windows visible. */
a621 2

	return (newcc);
@


1.81
log
@introduce a new 'freeze' flag (CMS-f by default) which may be applied to
any window, after which all move/resize requests will be ignored,
essentially freezing the window in place.

there's a possibility to merge this with the 'ignore' concept, pending
on how ignore+freeze should behave (really more ewmh stuff), but punting
for now since ponies are on the line.

requested and tested by thib at k2k11 with ponies, unicorns and rainbows.

'save the unicorns' todd@@, ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.80 2011/03/22 10:56:08 okan Exp $
@


1.80
log
@if virt/horz un-maximizing, restore only the un-maximized axis
coordinates; allows moving a client and not restoring the maximized axis
coordinates.

picked from a larger martynas diff from ages ago.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.79 2011/03/22 10:52:37 okan Exp $
d268 9
d283 3
d325 3
d358 3
@


1.79
log
@while this piece deals with client argv's in a seemingly inefficient way
(noticed by Tim Peniket), since we don't ever do anything with cliarg,
remove the hunk and cliarg completely.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.78 2011/03/22 10:49:46 okan Exp $
d399 5
@


1.78
log
@remove XXX and move a configure event out of the event handler functions.

reminded by a similiar diff from Thomas Pfaff.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.77 2011/02/13 20:09:57 okan Exp $
a809 2
	int			 argc;
	char			**argv;
a824 23
	if (XGetCommand(X_Dpy, cc->win, &argv, &argc)) {
#define MAX_ARGLEN 512
#define ARG_SEP_ " "
		int	 i, o, len = MAX_ARGLEN;
		char	*buf;

		buf = xmalloc(len);
		buf[0] = '\0';

		for (o = 0, i = 0; o < len && i < argc; i++) {
			if (argv[i] == NULL)
				break;
			strlcat(buf, argv[i], len);
			o += strlen(buf);
			strlcat(buf, ARG_SEP_, len);
			o += strlen(ARG_SEP_);
		}

		if (strlen(buf) > 0)
			cc->app_cliarg = buf;

		XFreeStringList(argv);
	}
a833 1
	xfree(cc->app_cliarg);
@


1.77
log
@if we are saving the pointer location for a specific client, make sure
that if it is not already inbounds, put it in the default location,
which happens to be inbounds.

behavior noticed by Thomas Pfaff while maximizing and un-maximizing a
window, leaving the pointer behind and causing client_cycle() to be a
bit lost.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.76 2010/05/22 22:10:31 okan Exp $
d117 1
a117 1
	xev_reconfig(cc);
d393 1
a393 1
	xev_reconfig(cc);
d400 1
a400 1
	xev_reconfig(cc);
@


1.76
log
@replace XFetchName() with something more intelligent which attempts to
use the appropriate netwm Atom first, as well as deal with utf8.

slightly different incarnation tested by sthen@@ and ajacoutot@@ - thanks!

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.75 2010/04/11 16:51:26 okan Exp $
d438 3
@


1.75
log
@clean up a few xu_* functions to just accept what they need (Window).

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.74 2010/02/02 19:28:46 stsp Exp $
d186 1
a186 1
			XFree(wn->name);
d526 2
a527 1
	XFetchName(X_Dpy, cc->win, &newname);
d553 1
a553 1
			XFree(wn->name);
@


1.74
log
@Honour program-specified window position in size hints when placing windows.
Makes XMMS windows appear as expected.

ok okan, oga
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.73 2010/01/27 03:04:50 okan Exp $
d498 1
a498 1
	if ((n = xu_getprop(cc, WM_PROTOCOLS,
d515 1
a515 1
		xu_sendmsg(cc, WM_PROTOCOLS, WM_DELETE_WINDOW);
d817 1
a817 1
	if (xu_getprop(cc, _MOTIF_WM_HINTS, _MOTIF_WM_HINTS,
@


1.73
log
@- allow per-screen gap; not (yet) user configurable.
- teach _NET_WORKAREA about gap.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.72 2009/12/15 04:10:42 okan Exp $
d630 1
a630 1
	if (cc->size->flags & USPosition) {
@


1.72
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.71 2009/12/15 03:34:34 okan Exp $
d297 4
a300 4
		cc->geom.x = x_org + Conf.gap_left;
		cc->geom.y = y_org + Conf.gap_top;
		cc->geom.height = ymax - (Conf.gap_top + Conf.gap_bottom);
		cc->geom.width = xmax - (Conf.gap_left + Conf.gap_right);
d329 3
a331 3
		cc->geom.y = y_org + Conf.gap_top;
		cc->geom.height = ymax - (cc->bwidth * 2) - (Conf.gap_top +
		    Conf.gap_bottom);
d360 3
a362 3
		cc->geom.x = x_org + Conf.gap_left;
		cc->geom.width = xmax - (cc->bwidth * 2) - (Conf.gap_left +
		    Conf.gap_right);
d675 3
a677 3
			    xorig + Conf.gap_left);
			if (cc->geom.x > (xslack - Conf.gap_right))
				cc->geom.x -= Conf.gap_right;
d679 2
a680 2
			cc->geom.x = xorig + Conf.gap_left;
			cc->geom.width = xmax - Conf.gap_left;
d684 3
a686 3
			    yorig + Conf.gap_top);
			if (cc->geom.y > (yslack - Conf.gap_bottom))
				cc->geom.y -= Conf.gap_bottom;
d688 2
a689 2
			cc->geom.y = yorig + Conf.gap_top;
			cc->geom.height = ymax - Conf.gap_top;
@


1.71
log
@pull these headers only into files that need them.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.70 2009/12/15 03:24:36 okan Exp $
d21 3
d25 6
@


1.70
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.69 2009/12/10 17:16:51 oga Exp $
d20 2
@


1.69
log
@finish unfucking the screen_ctx handling.

remove screen_current() it was utterly bogus when nscreens > 1.

pass a fake client_ctx in the case where there's no client and the
kbfunc or mousefunc doesn't need a real one, it just contains the
current screen, modify these functions so that they pass down the screen
context to their callees.

make groups per screen, it's the only way it makes sense in this regard.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.68 2009/12/07 22:46:15 oga Exp $
a20 1
#include "headers.h"
@


1.68
log
@support _NET_CLIENT_LIST.

the x property api doesn't let you remove one entry from an X property
array, so client_remove is kinda expensive, but there's no real way
around that..

ok okan@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.67 2009/12/07 22:21:59 oga Exp $
d551 1
a551 1
client_cycle(int reverse)
a553 1
	struct screen_ctx	*sc;
a556 1
	sc = screen_current();
@


1.67
log
@Implement _NET_ACTIVE_WINDOW. for now just the informational hint is
supported, the client message to change this will be supported when all
informational hints are working.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.66 2009/11/28 17:52:12 tobias Exp $
d117 3
d134 1
d136 2
d150 17
@


1.66
log
@style (whitespaces)

ok oga, okan
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.65 2009/09/25 15:57:49 oga Exp $
d26 1
d146 1
a146 1
		_curcc = NULL;
d206 3
d215 13
d419 1
a419 1
		_curcc = NULL;
@


1.65
log
@With Xinerama enabled, the borders of a maximized window will show up on
all adjacent screens. This patch hides the borders while the window is
maximized.

From Bertrand Janin; thanks!

ok okan@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.64 2009/08/27 01:38:08 okan Exp $
d444 1
a444 1
	Atom	*p; 
d697 1
a697 1
		if (cc->size->min_aspect.x > 0) 
d700 1
a700 1
		if (cc->size->max_aspect.y > 0) 
@


1.64
log
@unroll the CCTOSC macro; from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.63 2009/08/25 01:32:40 oga Exp $
d247 2
a248 2
		cc->geom.x = x_org - cc->bwidth + Conf.gap_left;
		cc->geom.y = y_org - cc->bwidth + Conf.gap_top;
d326 1
d335 2
d338 2
@


1.63
log
@Instead of messing around everytime we do a resize, just clamp the
resize increments to a minimum of one, and use it unconditionally.

"you've convinced me, do it!" okan@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.62 2009/08/25 01:26:09 okan Exp $
d129 1
a129 1
	struct screen_ctx	*sc = CCTOSC(cc);
d172 1
a172 1
	sc = CCTOSC(cc);
d186 1
a186 1
	sc = CCTOSC(cc);
d220 1
a220 1
	struct screen_ctx	*sc = CCTOSC(cc);
d260 1
a260 1
	struct screen_ctx	*sc = CCTOSC(cc);
d291 1
a291 1
	struct screen_ctx	*sc = CCTOSC(cc);
d414 1
a414 1
	struct screen_ctx	*sc = CCTOSC(cc);
d554 1
a554 1
	struct screen_ctx	*sc = CCTOSC(cc);
d564 1
a564 1
	struct screen_ctx	*sc = CCTOSC(cc);
d574 1
a574 1
	struct screen_ctx	*sc = CCTOSC(cc);
d651 1
a651 1
	sc = CCTOSC(cc);
@


1.62
log
@unroll macro; ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.61 2009/08/24 23:54:41 oga Exp $
d688 3
d731 2
a732 4
	if (cc->geom.incw)
		cc->geom.width -= cc->geom.width % cc->geom.incw;
	if (cc->geom.inch)
		cc->geom.height -= cc->geom.height % cc->geom.inch;
@


1.61
log
@Add a keybinding to allow horizontal maximisation of a window (CMS-enter).

based on a diff by Thomas Pfaff; thanks!

ok okan@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.60 2009/08/24 23:49:04 okan Exp $
d236 1
a236 1
			xine = screen_find_xinerama(CCTOSC(cc),
d270 1
a270 1
			xine = screen_find_xinerama(CCTOSC(cc),
d301 1
a301 1
			xine = screen_find_xinerama(CCTOSC(cc),
@


1.60
log
@bring together gathering, calculating and applying of size hints;
additionally, respect aspect ratio hints.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.59 2009/08/24 21:22:48 oga Exp $
d227 1
a227 1
		if (!(cc->flags & CLIENT_VMAXIMIZED))
d266 1
a266 1
		if (!(cc->flags & CLIENT_MAXIMIZED))
d289 31
d322 2
a323 1
	cc->flags &= ~(CLIENT_MAXIMIZED | CLIENT_VMAXIMIZED);
d331 3
@


1.59
log
@Instead of having a function that just calls TAILQ_INIT on a global, use
TAILQ_HEAD_INITIALIZER() and drop the function.

ok okan@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.58 2009/08/24 17:04:39 oga Exp $
a52 1
	long			 tmp;
d67 1
a67 8
	XGetWMNormalHints(X_Dpy, cc->win, cc->size, &tmp);
	if (cc->size->flags & PBaseSize) {
		cc->geom.min_dx = cc->size->base_width;
		cc->geom.min_dy = cc->size->base_height;
	} else if (cc->size->flags & PMinSize) {
		cc->geom.min_dx = cc->size->min_width;
		cc->geom.min_dy = cc->size->min_height;
	}
d621 90
@


1.58
log
@instead of checking for flags in the client context, then removing them.
e.g.:

if (flags & flags_we_care_about)
	flags &= ~(flags_we_care_about);

just whack the flags unconditionally, it's simpler.

okan@@ agrees.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.57 2009/06/26 12:21:58 okan Exp $
a33 6

void
client_init(void)
{
	TAILQ_INIT(&Clientq);
}
@


1.57
log
@static local functions and data; almost identical diff from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.56 2009/06/23 21:52:38 okan Exp $
d305 1
a305 2
	if (cc->flags & (CLIENT_MAXIMIZED | CLIENT_VMAXIMIZED))
		cc->flags &= ~(CLIENT_MAXIMIZED | CLIENT_VMAXIMIZED);
@


1.56
log
@tidy up startup/init routines

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.55 2009/06/20 00:55:41 okan Exp $
d24 7
a30 1
static int		 client_inbound(struct client_ctx *, int, int);
d416 1
a416 1
void
d531 1
a531 1
struct client_ctx *
d541 1
a541 1
struct client_ctx *
d551 1
a551 1
void
d638 1
a638 1
void
d684 1
a684 1
void
@


1.55
log
@compact a bit by condensing a few if-else's; from Thomas Pfaff

"go on then" oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.54 2009/06/20 00:22:39 okan Exp $
d30 1
a30 1
client_setup(void)
@


1.54
log
@unroll XCALLOC/XMALLOC macros; since we use xcalloc/xmalloc all over the
place anyway, this makes things a bit more consistent; from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.53 2009/06/20 00:19:56 okan Exp $
d116 1
a116 5
	if (state == IconicState)
		client_hide(cc);
	else
		client_unhide(cc);

d344 1
a344 5
	if (cc->state == IconicState)
		client_unhide(cc);
	else
		client_raise(cc);

@


1.53
log
@spacing
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.52 2009/06/17 12:45:01 okan Exp $
d59 1
a59 1
	XCALLOC(cc, struct client_ctx);
d465 1
a465 1
	XMALLOC(wn, struct winname);
@


1.52
log
@re-factor parts of mouse move/resize bit to shrink and make more
readable; no behavior change

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.51 2009/05/30 00:30:17 okan Exp $
a168 1

a440 1

@


1.51
log
@re-order a bit for readability.

"if it makes you happy" oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.50 2009/05/18 00:23:35 okan Exp $
a68 5
	if (cc->size->width_inc == 0)
		cc->size->width_inc = 1;
	if (cc->size->height_inc == 0)
		cc->size->height_inc = 1;

@


1.50
log
@nuke the leading underscore notation for local static functions - there
are far better ways to know.

"go for it" oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.49 2009/05/17 23:40:57 okan Exp $
d67 1
a73 10
	TAILQ_INIT(&cc->nameq);
	client_setname(cc);

	/*
	 * conf_client() needs at least cc->win and cc->name
	 */
	conf_client(cc);

	XGetWindowAttributes(X_Dpy, cc->win, &wattr);

d82 5
d91 1
@


1.49
log
@a long time coming - re-work the way we deal with colors: since we're
using Xft(3), use it to select the font color as well instead of trying
to build one; properly allocate and free colors at-will, e.g. we now
have configurable colors.

feedback and ok's todd@@ and oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.48 2009/05/17 16:51:43 sthen Exp $
d24 1
a24 1
static int		 _client_inbound(struct client_ctx *, int, int);
d371 1
a371 1
	if (_client_inbound(cc, x, y)) {
d707 1
a707 1
_client_inbound(struct client_ctx *cc, int x, int y)
@


1.48
log
@redraw the border when unhiding a client window. fixes the situation where
you change to a different group and the mouse isn't over a window; previously
the border of the previously active window was highlighted but it didn't
actually have focus.

reads ok to oga@@.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.47 2009/01/23 20:47:45 okan Exp $
d406 1
a406 1
	u_long			 pixl;
d410 2
a411 2
		case CLIENT_HIGHLIGHT_BLUE:
			pixl = sc->bluepixl;
d413 2
a414 2
		case CLIENT_HIGHLIGHT_RED:
			pixl = sc->redpixl;
d417 1
a417 1
			pixl = sc->whitepixl;
d421 1
a421 1
		pixl = sc->graypixl;
d424 1
a424 1
	XSetWindowBorder(X_Dpy, cc->win, pixl);
@


1.47
log
@passing a null pointer to free() is valid; sprinkle a few free->xfree.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.46 2009/01/22 19:01:56 okan Exp $
d399 1
@


1.46
log
@now that pwin is gone gone gone, we no longer have to do the bwidth
dance; xevents now able to deal with a border being set (which fixes
those annoying movie-watching apps).

ok todd@@, oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.45 2009/01/22 15:26:33 oga Exp $
d702 1
a702 2
	if (cc->app_cliarg != NULL)
		xfree(cc->app_cliarg);
@


1.45
log
@Cache all of the X atoms we use at startup.

Do this instead of querying for them every time we use them. This
removes an XXX that has been in there since time began. This will become
more important as we move towards supporting netwm.

ok todd@@, okan@@.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.44 2009/01/17 18:41:50 oga Exp $
d106 1
a106 1
		
d268 2
a269 2
		cc->geom.x = x_org + Conf.gap_left;
		cc->geom.y = y_org + Conf.gap_top;
d300 1
a300 1
		cc->geom.y = y_org + cc->bwidth + Conf.gap_top;
d323 2
a324 2
	XMoveResizeWindow(X_Dpy, cc->win, cc->geom.x - cc->bwidth,
	    cc->geom.y - cc->bwidth, cc->geom.width, cc->geom.height);
d331 1
a331 2
	XMoveWindow(X_Dpy, cc->win,
	    cc->geom.x - cc->bwidth, cc->geom.y - cc->bwidth);
d421 1
d566 1
a566 1
	int			 yslack, xslack;
d576 6
a581 10
		yslack = sc->ymax - cc->geom.height - cc->bwidth;
		xslack = sc->xmax - cc->geom.width - cc->bwidth;
		if (cc->size->x >= 0)
			cc->geom.x = MAX(MIN(cc->size->x, xslack), cc->bwidth);
		else
			cc->geom.x = cc->bwidth;
		if (cc->size->y >= 0)
			cc->geom.y = MAX(MIN(cc->size->y, yslack), cc->bwidth);
		else 
			cc->geom.y = cc->bwidth;
d602 5
a606 2
		xmouse = MAX(xmouse, xorig + cc->bwidth) - cc->geom.width / 2;
		ymouse = MAX(ymouse, yorig + cc->bwidth) - cc->geom.height / 2;
d608 2
a609 2
		xmouse = MAX(xmouse, xorig + (int)cc->bwidth);
		ymouse = MAX(ymouse, yorig + (int)cc->bwidth);
a610 2
		xslack = xmax - cc->geom.width - cc->bwidth;
		yslack = ymax - cc->geom.height - cc->bwidth;
d613 1
a613 1
			    xorig + Conf.gap_left + cc->bwidth);
d617 1
a617 1
			cc->geom.x = xorig + cc->bwidth + Conf.gap_left;
d622 1
a622 1
			    yorig + Conf.gap_top + cc->bwidth);
d626 1
a626 1
			cc->geom.y = yorig + cc->bwidth + Conf.gap_top;
@


1.44
log
@Finally fix the really annoying race where if you rapidly switch groups several
times you'd end up losing clients (thinking they had gone away).

From the ICCCM (which should not be read without a stiff drink in hand,
I made this mistake so you don't have to): to request a window to be
withdrawn one should send a synthetic UnmapRequest event when iconified.
To request iconification one should just unmap the window. The ICCM
further recommends that the synthetic event should just be taken as a
cue to withdraw, to deal with legacy clients. Taking a hint from this,
rework xev_handle_unmaprequest to correctly detect these situations.  A
Withdrawn window may come back anywhere, even as a subwindow of
something else, so the correct way to handle this state is to forget it
ever existed.

While i'm here, kill a dumb attempt to notice this in client_delete, and
nuke the very unnecessary arguments.

Todd confirmed this fixes the `race'.

ok todd@@, ok ok okan@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.43 2009/01/16 15:24:14 okan Exp $
d429 1
a429 1
	Atom	*p, wm_delete, wm_protocols, wm_take_focus;
d433 1
a433 6
	/* XXX cache these. */
	wm_delete = XInternAtom(X_Dpy, "WM_DELETE_WINDOW", False);
	wm_protocols = XInternAtom(X_Dpy, "WM_PROTOCOLS", False);
	wm_take_focus = XInternAtom(X_Dpy, "WM_TAKE_FOCUS", False);

	if ((n = xu_getprop(cc, wm_protocols,
d438 1
a438 1
		if (p[i] == wm_delete)
d440 1
a440 1
		else if (p[i] == wm_take_focus)
a448 5
	Atom	 wm_delete, wm_protocols;

	/* XXX - cache */
	wm_delete = XInternAtom(X_Dpy, "WM_DELETE_WINDOW", False);
	wm_protocols = XInternAtom(X_Dpy, "WM_PROTOCOLS", False);
d451 1
a451 1
		xu_sendmsg(cc, wm_protocols, wm_delete);
a657 1
	Atom			 mha;
d667 2
a668 3
	mha = XInternAtom(X_Dpy, "_MOTIF_WM_HINTS", False);
	if (xu_getprop(cc, mha, mha, PROP_MWM_HINTS_ELEMENTS,
	    (u_char **)&mwmh) == MWM_NUMHINTS)
@


1.43
log
@remove pwin, bringing us to one client, one window.  we no longer have
to push attributes around, so things get a lot simplier, while fixing a
few issues in the meantime; original suggestion by Edd Barrett many many
moons ago.

annoying window placement and race, found in c2k8 by todd, fix by oga!

lots of feedback from todd and oga - thanks!

"commit that bad boy" oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.42 2009/01/15 00:32:35 okan Exp $
d147 1
a147 1
client_delete(struct client_ctx *cc, int sendevent, int ignorewindow)
a150 3

	if (cc->state == IconicState && !sendevent)
		return (1);
@


1.42
log
@- add missing prototypes.
- properly name, place and static private functions.
- move function which finds the xinerama screen for a coordinate to
a more appropriate place while altering its semantics to match others.
- tiny bit of style.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.41 2008/09/29 23:16:46 oga Exp $
d41 1
a41 1
		if (cc->pwin == win || cc->win == win)
a50 1
	XSetWindowAttributes	 pxattr;
d54 1
a54 1
	int			 x, y, height, width, state;
d67 1
a80 1
	XGetWMNormalHints(X_Dpy, cc->win, cc->size, &tmp);
a94 2
	client_gravitate(cc, 1);

d106 1
a106 1

d109 1
d111 1
a118 22
	x = cc->geom.x - cc->bwidth;
	y = cc->geom.y - cc->bwidth;

	width = cc->geom.width;
	height = cc->geom.height;
	if (cc->bwidth > 1) {
		width += (cc->bwidth)*2;
		height += (cc->bwidth)*2;
	}
	pxattr.override_redirect = True;
	pxattr.background_pixel = sc->bgcolor.pixel;
	pxattr.event_mask = ChildMask | ButtonPressMask | ButtonReleaseMask |
	    ExposureMask | EnterWindowMask;

	cc->pwin = XCreateWindow(X_Dpy, sc->rootwin, x, y,
	    width, height, 0,	/* XXX */
	    DefaultDepth(X_Dpy, sc->which), CopyFromParent,
	    DefaultVisual(X_Dpy, sc->which),
	    CWOverrideRedirect | CWBackPixel | CWEventMask, &pxattr);

	cc->active = 0;

a119 2
	XSetWindowBorderWidth(X_Dpy, cc->win, 0);
	XReparentWindow(X_Dpy, cc->win, cc->pwin, cc->bwidth, cc->bwidth);
d126 2
a127 4
	else {
		XMapRaised(X_Dpy, cc->pwin);
		XMapWindow(X_Dpy, cc->win);
	}
a145 21
void
client_do_shape(struct client_ctx *cc)
{
	/* Windows not rectangular require more effort */
	XRectangle	*r;
	int		 n, tmp;

	if (Doshape) {
		XShapeSelectInput(X_Dpy, cc->win, ShapeNotifyMask);

		r = XShapeGetRectangles(X_Dpy, cc->win, ShapeBounding,
		    &n, &tmp);

		if (n > 1)
			XShapeCombineShape(X_Dpy, cc->pwin, ShapeBounding,
			    cc->bwidth,	cc->bwidth, cc->win, ShapeBounding,
			    ShapeSet);
		XFree(r);
	}
}

a160 9
	if (!ignorewindow) {
		client_gravitate(cc, 0);
		XSetWindowBorderWidth(X_Dpy, cc->win, 1);	/* XXX */
		XReparentWindow(X_Dpy, cc->win,
		    sc->rootwin, cc->geom.x, cc->geom.y);
	}
	if (cc->pwin)
		XDestroyWindow(X_Dpy, cc->pwin);

a241 22
client_gravitate(struct client_ctx *cc, int yes)
{
	int	 dx = 0, dy = 0, mult = yes ? 1 : -1;
	int	 gravity = (cc->size->flags & PWinGravity) ?
		     cc->size->win_gravity : NorthWestGravity;

	switch (gravity) {
	case NorthWestGravity:
	case SouthWestGravity:
	case NorthEastGravity:
	case StaticGravity:
		dx = cc->bwidth;
	case NorthGravity:
		dy = cc->bwidth;
		break;
	}

	cc->geom.x += mult * dx;
	cc->geom.y += mult * dy;
}

void
d326 2
a327 5
	XMoveResizeWindow(X_Dpy, cc->pwin, cc->geom.x - cc->bwidth,
	    cc->geom.y - cc->bwidth, cc->geom.width + cc->bwidth*2,
	    cc->geom.height + cc->bwidth*2);
	XMoveResizeWindow(X_Dpy, cc->win, cc->bwidth, cc->bwidth,
	    cc->geom.width, cc->geom.height);
d334 1
a334 1
	XMoveWindow(X_Dpy, cc->pwin,
d342 1
a342 1
	XLowerWindow(X_Dpy, cc->pwin);
d348 1
a348 1
	XRaiseWindow(X_Dpy, cc->pwin);
d366 1
a366 1
	xu_ptr_setpos(cc->pwin, x, y);
d374 1
a374 1
	xu_ptr_getpos(cc->pwin, &x, &y);
d385 1
a385 1
	XUnmapWindow(X_Dpy, cc->pwin);
d398 1
a398 1
	XMapRaised(X_Dpy, cc->pwin);
a408 22

	if (cc->active) {
		XSetWindowBackground(X_Dpy, cc->pwin, client_bg_pixel(cc));
		XClearWindow(X_Dpy, cc->pwin);

		if (!cc->highlight && cc->bwidth > 1)
			XDrawRectangle(X_Dpy, cc->pwin, sc->gc, 1, 1,
			    cc->geom.width + cc->bwidth,
			    cc->geom.height + cc->bwidth);
	} else {
		if (cc->bwidth > 1)
			XSetWindowBackgroundPixmap(X_Dpy,
			    cc->pwin, client_bg_pixmap(cc));

		XClearWindow(X_Dpy, cc->pwin);
	}
}

u_long
client_bg_pixel(struct client_ctx *cc)
{
	struct screen_ctx	*sc = CCTOSC(cc);
d411 16
a426 34
	switch (cc->highlight) {
	case CLIENT_HIGHLIGHT_BLUE:
		pixl = sc->bluepixl;
		break;
	case CLIENT_HIGHLIGHT_RED:
		pixl = sc->redpixl;
		break;
	default:
		pixl = sc->blackpixl;
		break;
	}

	return (pixl);
}

Pixmap
client_bg_pixmap(struct client_ctx *cc)
{
	struct screen_ctx	*sc = CCTOSC(cc);
	Pixmap			 pix;

	switch (cc->highlight) {
	case CLIENT_HIGHLIGHT_BLUE:
		pix = sc->blue;
		break;
	case CLIENT_HIGHLIGHT_RED:
		pix = sc->red;
		break;
	default:
		pix = sc->gray;
		break;
	}

	return (pix);
@


1.41
log
@Xinerama and XRandR dual head support for cwm(1). Now we detect the xrandr
reconfiguration events and change our sizes depending on that. We also detect
the xinerama screens for maximize, vertmaximize and initial window placement.

This could be improved by automatically resizing maximized windows when
the screen resolution changes and by moving windows that would be hidden
into visible space. Said changes will come shortly.

Tested by many. matthieu@@ didn't oppose.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.40 2008/09/22 14:28:04 oga Exp $
d24 1
a24 3
int	_inwindowbounds(struct client_ctx *, int, int);
XineramaScreenInfo	*client_find_xinerama_screen(int , int ,
			     struct screen_ctx *);
a26 1

d339 3
a341 3
			xine = client_find_xinerama_screen(cc->geom.x + 
			    cc->geom.width / 2, cc->geom.y +
			    cc->geom.height / 2, CCTOSC(cc));
d373 3
a375 3
			xine = client_find_xinerama_screen(cc->geom.x + 
			    cc->geom.width / 2, cc->geom.y +
			    cc->geom.height / 2, CCTOSC(cc));
d457 1
a457 1
	if (_inwindowbounds(cc, x, y)) {
d728 1
a728 1
			info = client_find_xinerama_screen(xmouse, ymouse, sc);
d846 2
a847 2
int
_inwindowbounds(struct client_ctx *cc, int x, int y)
a850 18
}

/*
 * Find which xinerama screen the coordinates (x,y) is on.
 */
XineramaScreenInfo *
client_find_xinerama_screen(int x, int y, struct screen_ctx *sc)
{
	XineramaScreenInfo	*info;
	int			 i;

	for (i = 0; i < sc->xinerama_no; i++) {
		info = &sc->xinerama[i];
		if (x > info->x_org && x < info->x_org + info->width &&
		    y > info->y_org && y < info->y_org + info->height)
			return (info);
	}
	return (NULL);
@


1.40
log
@*sigh* Revert the diff that wasn't meant to go in yet.

note to self: When you mean to type cvs commit search.c, don't forget
the filename.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.38 2008/07/15 22:12:09 okan Exp $
d25 2
d327 2
d335 22
a356 4
		cc->geom.x = Conf.gap_left;
		cc->geom.y = Conf.gap_top;
		cc->geom.height = sc->ymax - (Conf.gap_top + Conf.gap_bottom);
		cc->geom.width = sc->xmax - (Conf.gap_left + Conf.gap_right);
d367 1
d374 14
a387 3
		cc->geom.y = cc->bwidth + Conf.gap_top;
		cc->geom.height = (sc->ymax - cc->bwidth * 2) -
		    (Conf.gap_top + Conf.gap_bottom);
d704 1
a704 12
	int			 yslack, xslack, xmouse, ymouse;

	yslack = sc->ymax - cc->geom.height - cc->bwidth;
	xslack = sc->xmax - cc->geom.width - cc->bwidth;

	xu_ptr_getpos(sc->rootwin, &xmouse, &ymouse);

	xmouse = MAX(xmouse, cc->bwidth) - cc->geom.width / 2;
	ymouse = MAX(ymouse, cc->bwidth) - cc->geom.height / 2;

	xmouse = MAX(xmouse, (int)cc->bwidth);
	ymouse = MAX(ymouse, (int)cc->bwidth);
d707 9
d725 28
a752 1
		if (xslack >= 0) {
d754 1
a754 1
					 Conf.gap_left + cc->bwidth);
d758 2
a759 2
			cc->geom.x = cc->bwidth + Conf.gap_left;
			cc->geom.width = sc->xmax - Conf.gap_left;
d761 1
a761 1
		if (yslack >= 0) {
d763 1
a763 1
					 Conf.gap_top + cc->bwidth);
d767 2
a768 2
			cc->geom.y = cc->bwidth + Conf.gap_top;
			cc->geom.height = sc->ymax - Conf.gap_top;
d854 18
@


1.39
log
@Display the current window title not a previous one in the case of
``show all'' in the window search dialogue. Noticed and diff from Tim
van der Molen, thanks!
@
text
@a24 6
static void	client_fullmaximize(struct client_ctx *);
static void	client_xinerama_maximize(struct client_ctx *);
static void	client_xinerama_vmax(struct client_ctx *);
static void	client_full_vmax(struct client_ctx *);
XineramaScreenInfo	*client_find_xinerama_screen(int , int ,
			     struct screen_ctx *);
d331 5
a335 4
		if (HasXinerama)
			client_xinerama_maximize(cc);
		else
			client_fullmaximize(cc);
a340 27
static void
client_xinerama_maximize(struct client_ctx *cc)
{
	XineramaScreenInfo *xine;

	xine = client_find_xinerama_screen(cc->geom.x, cc->geom.y, CCTOSC(cc));
	if (xine == NULL)
		return;
	cc->geom.x = xine->x_org + Conf.gap_left;
	cc->geom.y = xine->y_org + Conf.gap_top;
	cc->geom.height = xine->height - (Conf.gap_top + Conf.gap_bottom);
	cc->geom.width = xine->width - (Conf.gap_left + Conf.gap_right);
	cc->flags |= CLIENT_DOMAXIMIZE;
}

static void
client_fullmaximize(struct client_ctx *cc)
{
	struct screen_ctx	*sc = CCTOSC(cc);

	cc->geom.x = Conf.gap_left;
	cc->geom.y = Conf.gap_top;
	cc->geom.height = sc->ymax - (Conf.gap_top + Conf.gap_bottom);
	cc->geom.width = sc->xmax - (Conf.gap_left + Conf.gap_right);
	cc->flags |= CLIENT_DOMAXIMIZE;
}

d351 4
a354 4
		if (HasXinerama)
			client_xinerama_vmax(cc);
		else
			client_full_vmax(cc);
a359 25
static void
client_xinerama_vmax(struct client_ctx *cc)
{
	XineramaScreenInfo *xine;

	xine = client_find_xinerama_screen(cc->geom.x, cc->geom.y, CCTOSC(cc));
	if (xine == NULL)
		return;
	cc->geom.y = xine->y_org + cc->bwidth + Conf.gap_top;
	cc->geom.height = xine->height - (cc->bwidth * 2) - (Conf.gap_top +
	    Conf.gap_bottom);
	cc->flags |= CLIENT_DOVMAXIMIZE;
}

static void
client_full_vmax(struct client_ctx *cc)
{
	struct screen_ctx	*sc = CCTOSC(cc);

	cc->geom.y = cc->bwidth + Conf.gap_top;
	cc->geom.height = (sc->ymax - cc->bwidth * 2) -
	    (Conf.gap_top + Conf.gap_bottom);
	cc->flags |= CLIENT_DOVMAXIMIZE;
}

a670 2
	int			 xorig, yorig, xmax, ymax;
	XineramaScreenInfo	*info;
d672 2
a675 21
	if (HasXinerama) {
		info = client_find_xinerama_screen(xmouse, ymouse, sc);
		if (info == NULL)
			goto noxine;
		yslack = info->y_org + info->height - cc->geom.height -
		    cc->bwidth;
		xslack = info->x_org + info->width - cc->geom.width -
		    cc->bwidth;
		xorig = info->x_org;
		yorig = info->y_org;
		xmax = xorig + info->width;
		ymax = yorig + info->height;
	} else {
noxine:
		yslack = sc->ymax - cc->geom.height - cc->bwidth;
		xslack = sc->xmax - cc->geom.width - cc->bwidth;
		xorig = yorig = 0;
		xmax = sc->xmax;
		ymax = sc->ymax;
	}

d684 1
a684 1
		if (cc->size->x >= xorig)
d687 2
a688 2
			cc->geom.x = xorig + cc->bwidth;
		if (cc->size->y >= yorig)
d691 1
a691 1
			cc->geom.y =  yorig + cc->bwidth;
d693 1
a693 1
		if (xslack >= xorig) {
d695 1
a695 1
					 xorig + Conf.gap_left + cc->bwidth);
d699 2
a700 2
			cc->geom.x = xorig + cc->bwidth + Conf.gap_left;
			cc->geom.width = xmax - Conf.gap_left;
d702 1
a702 1
		if (yslack >= yorig) {
d704 1
a704 1
					 yorig + Conf.gap_top + cc->bwidth);
d708 2
a709 2
			cc->geom.y = yorig + cc->bwidth + Conf.gap_top;
			cc->geom.height = ymax - Conf.gap_top;
a794 15
}

XineramaScreenInfo *
client_find_xinerama_screen(int x, int y, struct screen_ctx *sc)
{
	XineramaScreenInfo	*info;
	int			 i;

	for (i = 0; i < sc->xinerama_no; i++) {
		info = &sc->xinerama[i];
		if (x > info->x_org && x < info->x_org + info->width &&
		    y > info->y_org && y < info->y_org + info->height)
			return (info);
	}
	return (NULL);
@


1.38
log
@move client_vertmaximize to a more sensible location, purely for readability.

"don't mind at all" oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.37 2008/07/15 22:06:48 okan Exp $
d25 6
d337 4
a340 5
		cc->geom.x = Conf.gap_left;
		cc->geom.y = Conf.gap_top;
		cc->geom.height = sc->ymax - (Conf.gap_top + Conf.gap_bottom);
		cc->geom.width = sc->xmax - (Conf.gap_left + Conf.gap_right);
		cc->flags |= CLIENT_DOMAXIMIZE;
d346 27
d383 4
a386 4
		cc->geom.y = cc->bwidth + Conf.gap_top;
		cc->geom.height = (sc->ymax - cc->bwidth * 2) -
		    (Conf.gap_top + Conf.gap_bottom);
		cc->flags |= CLIENT_DOVMAXIMIZE;
d392 25
d728 2
a730 2
	yslack = sc->ymax - cc->geom.height - cc->bwidth;
	xslack = sc->xmax - cc->geom.width - cc->bwidth;
d733 21
d762 1
a762 1
		if (cc->size->x >= 0)
d765 2
a766 2
			cc->geom.x = cc->bwidth;
		if (cc->size->y >= 0)
d769 1
a769 1
			cc->geom.y = cc->bwidth;
d771 1
a771 1
		if (xslack >= 0) {
d773 1
a773 1
					 Conf.gap_left + cc->bwidth);
d777 2
a778 2
			cc->geom.x = cc->bwidth + Conf.gap_left;
			cc->geom.width = sc->xmax - Conf.gap_left;
d780 1
a780 1
		if (yslack >= 0) {
d782 1
a782 1
					 Conf.gap_top + cc->bwidth);
d786 2
a787 2
			cc->geom.y = cc->bwidth + Conf.gap_top;
			cc->geom.height = sc->ymax - Conf.gap_top;
d873 15
@


1.37
log
@save an X call and use what we already have stored.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.36 2008/07/15 13:52:02 okan Exp $
d342 19
a711 19
}

void
client_vertmaximize(struct client_ctx *cc)
{
	struct screen_ctx	*sc = CCTOSC(cc);

	if (cc->flags & CLIENT_VMAXIMIZED) {
		cc->geom = cc->savegeom;
	} else {
		if (!(cc->flags & CLIENT_MAXIMIZED))
			cc->savegeom = cc->geom;
		cc->geom.y = cc->bwidth + Conf.gap_top;
		cc->geom.height = (sc->ymax - cc->bwidth * 2) -
		    (Conf.gap_top + Conf.gap_bottom);
		cc->flags |= CLIENT_DOVMAXIMIZE;
	}

	client_resize(cc);
@


1.36
log
@don't compensate for bwidth twice.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.35 2008/07/11 14:23:30 okan Exp $
d324 2
a328 4
		XWindowAttributes rootwin_geom;
		struct screen_ctx *sc = CCTOSC(cc);

		XGetWindowAttributes(X_Dpy, sc->rootwin, &rootwin_geom);
d333 2
a334 4
		cc->geom.height = rootwin_geom.height -
		    (Conf.gap_top + Conf.gap_bottom);
		cc->geom.width = rootwin_geom.width -
		    (Conf.gap_left + Conf.gap_right);
@


1.35
log
@we already have ymax, so use it instead of asking X for it again.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.34 2008/07/11 14:21:28 okan Exp $
d685 1
a685 1
			cc->geom.width = sc->xmax - cc->bwidth - Conf.gap_left;
d694 1
a694 1
			cc->geom.height = sc->ymax - cc->bwidth - Conf.gap_top;
@


1.34
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.33 2008/06/30 17:52:37 okan Exp $
d702 2
a706 6
		struct screen_ctx	*sc = CCTOSC(cc);
		int			 display_height;

		display_height = DisplayHeight(X_Dpy, sc->which) -
		    cc->bwidth * 2;

d710 1
a710 1
		cc->geom.height = display_height -
@


1.33
log
@only cycle through visible *and* non-ignored windows.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.32 2008/06/25 22:37:29 oga Exp $
d39 1
a39 1
	struct client_ctx *cc;
d51 6
a56 6
	struct client_ctx *cc;
	long tmp;
	XSetWindowAttributes pxattr;
	XWindowAttributes wattr;
	int x, y, height, width, state;
	XWMHints *wmhints;
a129 1

d178 2
a179 2
	XRectangle *r;
	int n, tmp;
d198 2
a199 2
	struct screen_ctx *sc = CCTOSC(cc);
	struct winname *wn;
d205 1
a206 1

d247 1
a247 1
	struct screen_ctx *sc;
d253 1
a254 1

d261 1
a261 1
	struct screen_ctx* sc;
d302 3
a304 3
	int dx = 0, dy = 0, mult = yes ? 1 : -1;
	int gravity = (cc->size->flags & PWinGravity) ?
	    cc->size->win_gravity : NorthWestGravity;
d317 2
a318 2
	cc->geom.x += mult*dx;
	cc->geom.y += mult*dy;
d390 1
a390 1
	int x = cc->ptr.x, y = cc->ptr.y;
d408 1
a408 1
	int x, y;
d444 1
a444 1
	struct screen_ctx *sc = CCTOSC(cc);
d466 2
a467 2
	struct screen_ctx *sc = CCTOSC(cc);
	u_long pixl;
d487 2
a488 2
	struct screen_ctx *sc = CCTOSC(cc);
	Pixmap pix;
d508 3
a510 3
	Atom *p, wm_delete, wm_protocols, wm_take_focus;
	int i;
	long n;
d533 1
a533 1
	Atom wm_delete, wm_protocols;
d548 2
a549 2
	char *newname;
	struct winname *wn;
d588 2
a589 2
	struct client_ctx	*oldcc = client_current(), *newcc;
	struct screen_ctx	*sc = screen_current();
d592 3
d634 2
a635 2
	struct screen_ctx *sc = CCTOSC(cc);
	struct client_ctx *ccc;
d644 2
a645 2
	struct screen_ctx *sc = CCTOSC(cc);
	struct client_ctx *ccc;
d654 2
a655 2
	struct screen_ctx *sc = CCTOSC(cc);
	int yslack, xslack, xmouse, ymouse;
d662 2
a663 2
	xmouse = MAX(xmouse, cc->bwidth) - cc->geom.width/2;
	ymouse = MAX(ymouse, cc->bwidth) - cc->geom.height/2;
d705 5
a709 3
		struct screen_ctx *sc = CCTOSC(cc);
		int display_height = DisplayHeight(X_Dpy, sc->which) -
		    cc->bwidth*2;
d725 1
a725 1
	struct screen_ctx *sc;
d742 5
a746 5
	XClassHint xch;
	int argc;
	char **argv;
	Atom mha;
	struct mwm_hints *mwmh;
d765 2
a766 3
		int len = MAX_ARGLEN;
		int i, o;
		char *buf;
@


1.32
log
@Actually grab the correct mouse buttons for a window, instead of doing the
old hardcoded ones (which now can be wrong).

tested by todd@@ and johan@@.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.31 2008/06/18 20:42:29 oga Exp $
d608 2
a609 2
		/* Only cycle visible windows. */
		if (newcc->flags & CLIENT_HIDDEN)
@


1.31
log
@No need to map/unmap the window on hide/show since we already do the
same to its parent.

"makes sense" okan@@.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.30 2008/06/14 22:04:11 okan Exp $
d275 1
a275 2
		xu_btn_grab(cc->pwin, Mod1Mask, AnyButton);
		xu_btn_grab(cc->pwin, ControlMask|Mod1Mask, Button1);
@


1.30
log
@(mostly) proper xshape event support

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.29 2008/06/12 04:59:51 okan Exp $
a423 1
	XUnmapWindow(X_Dpy, cc->win);
a435 1
	XMapWindow(X_Dpy, cc->win);
@


1.29
log
@re-work client_placecalc()
- make sure new clients sit inside the current screen
- respect 'gap' placement on new clients

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.28 2008/05/23 18:57:35 okan Exp $
a142 1
	client_draw_border(cc);
a464 2

	client_do_shape(cc);
@


1.28
log
@make sure to take bwdith into account when placing a new window.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.27 2008/05/20 14:50:51 oga Exp $
d659 1
a659 8
	int yslack, xslack;
	int x, y, height, width, mousex, mousey;

	y = cc->geom.y;
	x = cc->geom.x;

	height = cc->geom.height;
	width = cc->geom.width;
d664 1
a664 1
	xu_ptr_getpos(sc->rootwin, &mousex, &mousey);
d666 2
a667 2
	mousex = MAX(mousex, cc->bwidth) - cc->geom.width/2;
	mousey = MAX(mousey, cc->bwidth) - cc->geom.height/2;
d669 2
a670 2
	mousex = MAX(mousex, (int)cc->bwidth);
	mousey = MAX(mousey, (int)cc->bwidth);
d673 8
a680 12
		if (cc->size->x > 0)
			x = cc->size->x;
		if (x < cc->bwidth)
			x = cc->bwidth;
		else if (x > xslack)
			x = xslack;
		if (cc->size->y > 0)
			y = cc->size->y;
		if (y < cc->bwidth)
			y = cc->bwidth;
		else if (y > yslack)
			y = yslack;
d682 5
a686 3
		if (yslack < 0) {
			y = cc->bwidth;
			height = sc->ymax;
d688 2
a689 3
			if (y == 0 || y > yslack)
				y = MIN(mousey, yslack);
			height = cc->geom.height;
d691 5
a695 4

		if (xslack < 0) {
			x = cc->bwidth;
			width = sc->xmax;
d697 2
a698 3
			if (x == 0 || x > xslack)
				x = MIN(mousex, xslack);
			width = cc->geom.width;
a700 6

	cc->geom.y = y;
	cc->geom.x = x;

	cc->geom.height = height;
	cc->geom.width = width;
@


1.27
log
@Pull out the behaviour in grab_label and search_start into one utility
function menu_filter(). The plan is to eventually merge in grab_menu too.
Shrinks the code a fair bit.

Also, change XMaskEvent for XWindowEvent to prevent getting exposes for other
windows. This is particuarly noticable on slow machines with a LOT of xterms
(todd, you're an odd man).

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.26 2008/05/19 17:24:19 okan Exp $
d668 2
a669 3

	yslack = sc->ymax - cc->geom.height;
	xslack = sc->xmax - cc->geom.width;
@


1.26
log
@client_cyclenext() -> client_cycle() since we now pass an arg.

removes a stray proto as well.

discussed with and ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.25 2008/05/19 15:17:50 oga Exp $
d660 1
a660 1
	int x, y, height, width, ymax, xmax, mousex, mousey;
a667 2
	ymax = DisplayHeight(X_Dpy, sc->which) - cc->bwidth;
	xmax = DisplayWidth(X_Dpy, sc->which) - cc->bwidth;
d669 2
a670 2
	yslack = ymax - cc->geom.height;
	xslack = xmax - cc->geom.width;
d696 1
a696 1
			height = ymax;
d705 1
a705 1
			width = xmax;
@


1.25
log
@Use the XGrabKeyboard hack in for alt-tabbing as well. This stops the
mru getting the order messed up when gvim/xpdf et all steal key events.

While i'm here, change the logic in client_cyclenext() to use break instead
of goto, it's nicer that way.

Thirdly, instead of two different kbfuncs, just use the one and a flag.

"put your cycle diff in so I can pkg_delete gvim" okan@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.24 2008/05/19 12:56:58 okan Exp $
d593 1
a593 1
client_cyclenext(int reverse)
@


1.24
log
@finally implement keyboard binding for group toggling

idea for the
    "slightly-less-abhorrent-hack-but-a-hack-nonetheless-TM" from oga@@

grab and ungrab the keyboard to get around some silly X apps that like
stealing events

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.23 2008/05/18 20:00:16 okan Exp $
d623 1
a623 1
			goto done;
d626 1
a626 1
done:
@


1.23
log
@remove extra calls to client_draw_border()

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.22 2008/05/17 03:59:54 okan Exp $
d441 1
@


1.22
log
@fix cwm's current XShape support from Edd Barrett -thanks.

XShape events should be handled at some point.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.21 2008/05/15 22:18:00 oga Exp $
a367 1
	client_draw_border(cc);
a387 1
	client_draw_border(cc);
@


1.21
log
@KNF, no binary change.

From Pierre Riteau. Thanks!
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.20 2008/05/15 21:56:21 okan Exp $
a141 15
	if (Doshape) {
		XRectangle *r;
		int n, tmp;

		XShapeSelectInput(X_Dpy, cc->win, ShapeNotifyMask);

		r = XShapeGetRectangles(X_Dpy, cc->win, ShapeBounding,
		    &n, &tmp);
		if (n > 1)
			XShapeCombineShape(X_Dpy, cc->pwin, ShapeBounding,
			    0,	0, /* XXX border */
			    cc->win, ShapeBounding, ShapeSet);
		XFree(r);
	}

d176 21
d467 2
@


1.20
log
@tiny bit of knf

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.19 2008/05/01 18:01:13 oga Exp $
d333 1
a333 1
			(Conf.gap_top + Conf.gap_bottom);
d335 1
a335 1
			(Conf.gap_left + Conf.gap_right);
d729 1
a729 1
			(Conf.gap_top + Conf.gap_bottom); 
d771 1
a771 1
		(u_char **)&mwmh) == MWM_NUMHINTS)
@


1.19
log
@Rework the alt-tabbing code to be a lot simpler.

Diff mostly from Edd Barrett, with some minor changes from me.
Unfortunately the issue where apps like gvim and xpdf are stealing
keyrelease events causing the ordering to be messed up, but this is a
lot better. A fix for the aforementioned issue shall be forthcoming,
once a good one's been found.

ok okan@@, also tested by todd@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.18 2008/04/16 13:35:37 oga Exp $
d118 2
a119 2
	XSelectInput(X_Dpy, cc->win,
	    ColormapChangeMask|EnterWindowMask|PropertyChangeMask|KeyReleaseMask);
d133 2
a134 9
	pxattr.event_mask =
	    ChildMask|ButtonPressMask|ButtonReleaseMask|
	    ExposureMask|EnterWindowMask;
/* 	pxattr.border_pixel = sc->blackpix; */
/* 	pxattr.background_pixel = sc->whitepix; */


/* 	cc->pwin = XCreateSimpleWindow(X_Dpy, sc->rootwin, */
/* 	    x, y, width, height, 1, sc->blackpix, sc->whitepix); */
d185 1
a185 1
	if (mapped) {
a186 1
	}
@


1.18
log
@Remove screen_infomsg(), nothing uses it.

ok okan.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.17 2008/04/15 20:24:41 oga Exp $
a23 2
static struct client_ctx *client__cycle(struct client_ctx *cc,
    struct client_ctx *(*iter)(struct client_ctx *));
a231 3
	if (sc->cycle_client == cc)
		sc->cycle_client = NULL;

a592 5
/*
 * TODO: seems to have some issues still on the first invocation
 * (globally the first)
 */

d596 3
a598 14
	struct screen_ctx *sc;
	struct client_ctx *cc;
	struct client_ctx *(*iter)(struct client_ctx *) =
	    reverse ? &client_mruprev : &client_mrunext;

	/* TODO: maybe this should just be a CIRCLEQ. */

	if ((cc = client_current()) == NULL) {
		if (TAILQ_EMPTY(&Clientq))
			return(NULL);
		cc = TAILQ_FIRST(&Clientq);
	}

	sc = CCTOSC(cc);
d600 2
a601 5
	/* if altheld; then reset the iterator to the beginning */
	if (!sc->altpersist || sc->cycle_client == NULL)
		sc->cycle_client = TAILQ_FIRST(&sc->mruq);

	if (sc->cycle_client == NULL)
d604 19
a622 4
	/*
	 * INVARIANT: as long as sc->cycle_client != NULL here, we
	 * won't exit with sc->cycle_client == NULL
	 */
d624 8
a631 2
	if ((sc->cycle_client = client__cycle(cc, iter)) == NULL)
		sc->cycle_client = cc;
d633 1
a633 6
	/* Do the actual warp. */
	client_ptrsave(cc);
	client_ptrwarp(sc->cycle_client);
	sc->altpersist = 1; /* This is reset when alt is let go... */

	return (sc->cycle_client);
a653 14
}

static struct client_ctx *
client__cycle(struct client_ctx *cc,
    struct client_ctx *(*iter)(struct client_ctx *))
{
	struct client_ctx *save = cc;

	do {
		if (!((cc = (*iter)(cc))->flags & CLIENT_HIDDEN))
			break;
	} while (cc != save);

	return (cc != save ? cc : NULL);
@


1.17
log
@hit it with the knf stick.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.16 2008/04/15 18:46:58 oga Exp $
d613 1
a613 1
	if (!(cc = _curcc)) {
a675 14
}

void
client_altrelease()
{
	struct client_ctx *cc = _curcc;
	struct screen_ctx *sc;

	if (cc == NULL)
		return;
	sc = CCTOSC(cc);

	XUnmapWindow(X_Dpy, sc->infowin);
	XReparentWindow(X_Dpy, sc->infowin, sc->rootwin, 0, 0);
@


1.16
log
@Add "gap" support to .cwmrc. The options put in here make gaps on the edge
of the screen where an application won't be {,vert}maximized over. used for
placing a statusbar or something like xclock.

Patch from Edd Barrett, with input from myself and okan. Thanks!

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.15 2008/04/09 18:10:47 okan Exp $
d26 1
a26 1
int _inwindowbounds(struct client_ctx *, int, int);
d28 1
a28 1
static char emptystring[] = "";
d30 1
a30 1
struct client_ctx *_curcc = NULL;
d56 1
a56 1
 	XWindowAttributes wattr;
d70 1
a70 1
	cc->size= XAllocSizeHints();
d140 1
a140 1
	
d157 2
a158 1
		r = XShapeGetRectangles(X_Dpy, cc->win, ShapeBounding, &n, &tmp);
d193 1
a193 1
	
d312 2
a313 2
        int dx = 0, dy = 0, mult = yes ? 1 : -1;
        int gravity = (cc->size->flags & PWinGravity) ?
d316 1
a316 1
        switch (gravity) {
d325 1
a325 1
        }
d327 2
a328 2
        cc->geom.x += mult*dx;
        cc->geom.y += mult*dy;
d423 1
a423 1
        if (_inwindowbounds(cc, x, y)) {
d426 1
a426 1
        }
d595 1
a595 1
	return;	
d639 1
a639 1
	sc->altpersist = 1;   /* This is reset when alt is let go... */
d675 1
a675 1
	return cc != save ? cc : NULL;
d768 2
a769 2
        
		if (!(cc->flags & CLIENT_MAXIMIZED)) 
d835 1
a835 1
			strlcat(buf,  ARG_SEP_, len);
@


1.15
log
@remove alt-tab menu

discussed with a few

ok oga@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.14 2008/03/26 15:45:42 oga Exp $
d342 6
a347 4
		cc->geom.x = 0;
		cc->geom.y = 0;
		cc->geom.height = rootwin_geom.height;
		cc->geom.width = rootwin_geom.width;
d770 3
a772 6
		cc->geom.y = cc->bwidth;
		if (cc->geom.min_dx == 0)
			cc->geom.height = display_height; 
		else
			cc->geom.height = display_height -
			    (display_height % cc->geom.min_dx);
@


1.14
log
@Fix a couple of issues with the maximization code.

If a window is vertically maximized, then resized, before the MAXIMIZED
flag wasn't removed, now it is. so doing a resize then does the right
thing.

Also, separate flags are needed for vertical and normal maximziation,
else when you do vertical-maximize, followed by maximize, the window
returns to it's original size.

ok simon@@, okan@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.13 2008/03/22 15:09:45 oga Exp $
a637 3
	/* Draw window. */
	client_cycleinfo(sc->cycle_client);

a638 82
}

/*
 * XXX - have to have proper exposure handling here.  we will probably
 * have to do this by registering with the event loop a function to
 * redraw, then match that on windows.
 */

void
client_cycleinfo(struct client_ctx *cc)
{
#define LISTSIZE 3
	int w, h, nlines, i, n, oneh, curn = -1, x, y, diff;
	struct client_ctx *ccc, *list[LISTSIZE];
	struct screen_ctx *sc = CCTOSC(cc);
	struct fontdesc *font = DefaultFont;

	memset(list, 0, sizeof(list));

	nlines = 0;
	TAILQ_FOREACH(ccc, &sc->mruq, mru_entry) {
		if (!ccc->flags & CLIENT_HIDDEN) {
			if (++nlines == LISTSIZE)
				break;
		}
	}

	oneh = font_ascent(font) + font_descent(font) + 1;
	h = nlines*oneh;

	list[1] = cc;

	if (nlines > 1)
		list[2] = client__cycle(cc, &client_mrunext);
	if (nlines > 2)
		list[0] = client__cycle(cc, &client_mruprev);

	w = 0;
	for (i = 0; i < sizeof(list)/sizeof(list[0]); i++) {
		if ((ccc = list[i]) == NULL)
			continue;		
		w = MAX(w, font_width(font, ccc->name, strlen(ccc->name)));
	}

	w += 4;

	/* try to fit. */

	if ((x = cc->ptr.x) < 0 || (y = cc->ptr.y) < 0) {
		x = cc->geom.width / 2;
		y = cc->geom.height / 2;
	}

	if ((diff = cc->geom.width - (x + w)) < 0)
		x += diff;

	if ((diff = cc->geom.height - (y + h)) < 0)
		y += diff;

	/* Don't hide the beginning of the window names */
	if (x < 0)
		x = 0;

	XReparentWindow(X_Dpy, sc->infowin, cc->win, 0, 0);
	XMoveResizeWindow(X_Dpy, sc->infowin, x, y, w, h);
	XMapRaised(X_Dpy, sc->infowin);
	XClearWindow(X_Dpy, sc->infowin);

	for (i = 0, n = 0; i < sizeof(list)/sizeof(list[0]); i++) {
		if ((ccc = list[i]) == NULL)
			continue;
		font_draw(font, ccc->name, strlen(ccc->name), sc->infowin,
		    2, n*oneh + font_ascent(font) + 1);
		if (i == 1)
			curn = n;
		n++;
	}

	assert(curn != -1);

	/* Highlight the current entry. */
	XFillRectangle(X_Dpy, sc->infowin, sc->hlgc, 0, curn*oneh, w, oneh);
@


1.13
log
@Rip out, burn, and dance around the grave of group-edit mode.
I've yet to speak to anyone who uses it, so just kill it.

You can still add/remove from groups using the mouse binding.  Groups
may get a re-work sometime soon if i have a stroke of genius.

knocks about 4k off the i386 binary for me.

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.12 2008/03/19 00:18:28 oga Exp $
a333 1
		cc->flags &= ~CLIENT_MAXIMIZED;
d340 2
a341 1
		cc->savegeom = cc->geom;
d346 1
a346 1
		cc->flags |= CLIENT_MAXIMIZED;
d355 11
d844 1
a844 2
	if (cc->flags & CLIENT_MAXIMIZED) {
		cc->flags &= ~CLIENT_MAXIMIZED;
d851 2
a852 1
		cc->savegeom = cc->geom;
d859 1
a859 1
		cc->flags |= CLIENT_MAXIMIZED;
@


1.12
log
@As mentioned in my last commit, there was an issue where the switching
code would always assume that the number of windows to switch to was
three if there were more windows hidden. Check for CLIENT_HIDDEN when we
count. Now it counts correctly.

ok simon@@.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.11 2008/01/16 11:39:20 oga Exp $
d194 1
a194 4
		if (Conf.flags & CONF_STICKY_GROUPS)
			group_sticky(cc);
		else
			group_autogroup(cc);
@


1.11
log
@huge amount of cleanup and dead code removal.

full description of changes:
-remove fontlist, and all associated structures/calls, it's not needed.
 this also removes any doubt about leftover 9wm code (the list was
 borrowed from it). Since cwm now uses Xft for everything, the legacy
 font handling is just not needed.
-add /* FALLTHROUGH */ comments into grab_{label,menu}. I actually
 didn't intend grab_menu to be a fallthrough, but it actually works quite
 well there, so remove the extra rectangle drawing. I love it when that
 happens.
-remove a couple of unused prototypes that were obviously missed
 before.
-remove a bunch of commented out or if 0ed out code. It doesn't look to
 be coming back anytime soon.
-several functions returned an int, but this was never checked. most of
 them only failed if they failed to grab the pointer (thus the internal
 state didn't change), so just make them void and return early if this is
 the case.
-remove several unused functions and some useless variables.

knocks something like 200bytes off the stripped binary size for me.

ok marc@@, tested by several others.
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.10 2008/01/11 16:06:44 oga Exp $
d645 1
d647 1
a647 1
	struct client_ctx *ccc, *list[3];
d654 6
a659 3
	TAILQ_FOREACH(ccc, &sc->mruq, mru_entry)
		nlines++;
	nlines = MIN(nlines, 3);
@


1.10
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d18 1
a18 1
 * $Id: client.c,v 1.9 2008/01/03 20:20:20 marc Exp $
a269 9
client_nocurrent(void)
{
	if (_curcc != NULL)
		client_setactive(_curcc, 0);

	_curcc = NULL;
}

void
a355 13
client_push_geometry(struct client_ctx *cc)
{
       cc->savegeom = cc->geom;
}

void
client_restore_geometry(struct client_ctx *cc)
{
       cc->geom = cc->savegeom;
       client_resize(cc);
}

void
a388 7
client_warp(struct client_ctx *cc)
{
	client_raise(cc);
	xu_ptr_setpos(cc->pwin, 0, 0);
}

void
a850 7
}

void
client_map(struct client_ctx *cc)
{
	/* mtf? */
	client_ptrwarp(cc);
@


1.9
log
@
Adjust initial window placement with any geometry that would place
the window at or over the right or bottom edge.
OK oda@@
@
text
@a4 1
 * All rights reserved.
d6 13
a18 1
 * $Id: client.c,v 1.8 2008/01/01 22:28:59 marc Exp $
@


1.8
log
@
Only use the x,y values from the XSizeHints structure when they are greater
than zero.   The fields are obsolete and not always used.
OK jasper@@
@
text
@d7 1
a7 1
 * $Id: client.c,v 1.7 2007/10/02 18:01:45 jasper Exp $
a93 1
	cc->geom.height = wattr.height;
d810 1
a810 1
		if (x <= 0 || x >= xmax)
d812 2
d816 1
a816 1
		if (y <= 0 || y >= ymax)
d818 2
@


1.7
log
@When cycling, only the end of the window names will be printed if the
name is too long. so show the beginning instead.

from Pierre Riteau <pierre.riteau at free.fr>

"looks correct" matthieu@@
@
text
@d7 1
a7 1
 * $Id: client.c,v 1.6 2007/06/08 16:29:19 jasper Exp $
d809 2
a810 1
		x = cc->size->x;
d813 2
a814 1
		y = cc->size->y;
@


1.6
log
@don't map hidden windows on re-start.
from aon@@iki.fi
@
text
@d7 1
a7 1
 * $Id: client.c,v 1.5 2007/06/05 19:03:20 jasper Exp $
d707 4
@


1.5
log
@make it possible to cycle through the windows when non are selected.
(eg. when they're hidden, now you can cycle through them)

from aon@@iki.fi
@
text
@d7 1
a7 1
 * $Id: client.c,v 1.4 2007/05/29 22:38:44 jasper Exp $
d165 7
a171 2
	XMapRaised(X_Dpy, cc->pwin);
	XMapWindow(X_Dpy, cc->win);
@


1.4
log
@show hidden windows when they should (eg. when the pointer is warped to them)

from aon@@iki.fi via bernd@@
@
text
@d7 1
a7 1
 * $Id: client.c,v 1.3 2007/05/29 22:35:04 jasper Exp $
d607 1
a607 1
client_cyclenext(struct client_ctx *cc, int reverse)
d609 2
a610 1
	struct screen_ctx *sc = CCTOSC(cc);
d615 8
@


1.3
log
@don't give borderless windows a border, when they're inactive

from aon@@iki.fi via bernd@@
@
text
@d7 1
a7 1
 * $Id: client.c,v 1.2 2007/05/28 18:34:27 jasper Exp $
d412 5
a416 1
	client_raise(cc);
@


1.2
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@d7 1
a7 1
 * $Id: client.c,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
a466 2
		XSetWindowBackgroundPixmap(X_Dpy, cc->pwin,
		    client_bg_pixmap(cc));
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * $Id: client.c,v 1.49 2005/08/28 09:36:44 marius Exp $
d24 1
a24 1
	TAILQ_INIT(&G_clientq);
d32 1
a32 1
	TAILQ_FOREACH(cc, &G_clientq, entry)
d54 1
a54 1
	XGrabServer(G_dpy);
d73 2
a74 2
	XGetWMNormalHints(G_dpy, cc->win, cc->size, &tmp);
	XGetWindowAttributes(G_dpy, cc->win, &wattr);
d99 1
a99 1
		if ((wmhints = XGetWMHints(G_dpy, cc->win)) != NULL) {
d110 1
a110 1
	XSelectInput(G_dpy, cc->win,
d132 1
a132 1
/* 	cc->pwin = XCreateSimpleWindow(G_dpy, sc->rootwin, */
d135 1
a135 1
	cc->pwin = XCreateWindow(G_dpy, sc->rootwin, x, y,
d137 2
a138 2
	    DefaultDepth(G_dpy, sc->which), CopyFromParent,
	    DefaultVisual(G_dpy, sc->which),
d141 1
a141 1
	if (G_doshape) {
d145 1
a145 1
		XShapeSelectInput(G_dpy, cc->win, ShapeNotifyMask);
d147 1
a147 1
		r = XShapeGetRectangles(G_dpy, cc->win, ShapeBounding, &n, &tmp);
d149 1
a149 1
			XShapeCombineShape(G_dpy, cc->pwin, ShapeBounding,
d158 3
a160 3
	XAddToSaveSet(G_dpy, cc->win);
	XSetWindowBorderWidth(G_dpy, cc->win, 0);
	XReparentWindow(G_dpy, cc->win, cc->pwin, cc->bwidth, cc->bwidth);
d165 2
a166 2
	XMapRaised(G_dpy, cc->pwin);
	XMapWindow(G_dpy, cc->win);
d169 2
a170 2
	XSync(G_dpy, False);
	XUngrabServer(G_dpy);
d173 1
a173 1
	TAILQ_INSERT_TAIL(&G_clientq, cc, entry);
d179 1
a179 1
		if (G_conf.flags & CONF_STICKY_GROUPS)
d198 1
a198 1
	XGrabServer(G_dpy);
d201 1
a201 1
	XRemoveFromSaveSet(G_dpy, cc->win);
d205 2
a206 2
		XSetWindowBorderWidth(G_dpy, cc->win, 1);	/* XXX */
		XReparentWindow(G_dpy, cc->win,
d210 1
a210 1
		XDestroyWindow(G_dpy, cc->pwin);
d212 2
a213 2
	XSync(G_dpy, False);
	XUngrabServer(G_dpy);
d216 1
a216 1
	TAILQ_REMOVE(&G_clientq, cc, entry);
d276 2
a277 2
		XInstallColormap(G_dpy, cc->cmap);
		XSetInputFocus(G_dpy, cc->win,
d337 1
a337 1
		XGetWindowAttributes(G_dpy, sc->rootwin, &rootwin_geom);
d365 1
a365 1
	XMoveResizeWindow(G_dpy, cc->pwin, cc->geom.x - cc->bwidth,
d368 1
a368 1
	XMoveResizeWindow(G_dpy, cc->win, cc->bwidth, cc->bwidth,
d377 1
a377 1
	XMoveWindow(G_dpy, cc->pwin,
d385 1
a385 1
	XLowerWindow(G_dpy, cc->pwin);
d391 1
a391 1
	XRaiseWindow(G_dpy, cc->pwin);
d432 2
a433 2
	XUnmapWindow(G_dpy, cc->pwin);
	XUnmapWindow(G_dpy, cc->win);
d446 2
a447 2
	XMapWindow(G_dpy, cc->win);
	XMapRaised(G_dpy, cc->pwin);
d459 2
a460 2
		XSetWindowBackground(G_dpy, cc->pwin, client_bg_pixel(cc));
		XClearWindow(G_dpy, cc->pwin);
d463 1
a463 1
			XDrawRectangle(G_dpy, cc->pwin, sc->gc, 1, 1,
d467 1
a467 1
		XSetWindowBackgroundPixmap(G_dpy, cc->pwin,
d470 1
a470 1
			XSetWindowBackgroundPixmap(G_dpy,
d473 1
a473 1
		XClearWindow(G_dpy, cc->pwin);
d527 3
a529 3
	wm_delete = XInternAtom(G_dpy, "WM_DELETE_WINDOW", False);
	wm_protocols = XInternAtom(G_dpy, "WM_PROTOCOLS", False);
	wm_take_focus = XInternAtom(G_dpy, "WM_TAKE_FOCUS", False);
d550 2
a551 2
	wm_delete = XInternAtom(G_dpy, "WM_DELETE_WINDOW", False);
	wm_protocols = XInternAtom(G_dpy, "WM_PROTOCOLS", False);
d556 1
a556 1
		XKillClient(G_dpy, cc->win);
d565 1
a565 1
	XFetchName(G_dpy, cc->win, &newname);
d692 4
a695 4
	XReparentWindow(G_dpy, sc->infowin, cc->win, 0, 0);
	XMoveResizeWindow(G_dpy, sc->infowin, x, y, w, h);
	XMapRaised(G_dpy, sc->infowin);
	XClearWindow(G_dpy, sc->infowin);
d710 1
a710 1
	XFillRectangle(G_dpy, sc->infowin, sc->hlgc, 0, curn*oneh, w, oneh);
d757 2
a758 2
	XUnmapWindow(G_dpy, sc->infowin);
	XReparentWindow(G_dpy, sc->infowin, sc->rootwin, 0, 0);
d774 2
a775 2
	ymax = DisplayHeight(G_dpy, sc->which) - cc->bwidth;
	xmax = DisplayWidth(G_dpy, sc->which) - cc->bwidth;
d830 1
a830 1
		int display_height = DisplayHeight(G_dpy, sc->which) -
d879 1
a879 1
	if (XGetClassHint(G_dpy, cc->win, &xch)) {
d886 1
a886 1
	mha = XInternAtom(G_dpy, "_MOTIF_WM_HINTS", False);
d893 1
a893 1
	if (XGetCommand(G_dpy, cc->win, &argv, &argc)) {
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
