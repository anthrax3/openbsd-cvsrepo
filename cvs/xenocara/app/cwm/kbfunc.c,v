head	1.147;
access;
symbols
	OPENBSD_6_1:1.143.0.2
	OPENBSD_6_1_BASE:1.143
	OPENBSD_6_0:1.126.0.4
	OPENBSD_6_0_BASE:1.126
	OPENBSD_5_9:1.126.0.2
	OPENBSD_5_9_BASE:1.126
	OPENBSD_5_8:1.113.0.2
	OPENBSD_5_8_BASE:1.113
	OPENBSD_5_7:1.105.0.2
	OPENBSD_5_7_BASE:1.105
	OPENBSD_5_6:1.95.0.4
	OPENBSD_5_6_BASE:1.95
	OPENBSD_5_5:1.95.0.2
	OPENBSD_5_5_BASE:1.95
	OPENBSD_5_4:1.79.0.2
	OPENBSD_5_4_BASE:1.79
	OPENBSD_5_3:1.76.0.2
	OPENBSD_5_3_BASE:1.76
	OPENBSD_5_2:1.62.0.2
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.2
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.51.0.4
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.51.0.6
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.40.0.2
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	version_3:1.1.1.1
	cwm:1.1.1;
locks; strict;
comment	@ * @;


1.147
date	2017.07.12.16.56.26;	author okan;	state Exp;
branches;
next	1.146;
commitid	mOsbJnWWflfvhzWh;

1.146
date	2017.07.10.13.36.58;	author okan;	state Exp;
branches;
next	1.145;
commitid	WRIkCV3cdR21tGBY;

1.145
date	2017.05.09.13.40.18;	author okan;	state Exp;
branches;
next	1.144;
commitid	BPz9NGKyEWdLoyMS;

1.144
date	2017.05.01.12.54.55;	author okan;	state Exp;
branches;
next	1.143;
commitid	BmUz0RRjwbKEonTv;

1.143
date	2017.01.05.21.18.20;	author okan;	state Exp;
branches;
next	1.142;
commitid	uOWkHtag8VTRzt9p;

1.142
date	2016.12.06.21.54.10;	author okan;	state Exp;
branches;
next	1.141;
commitid	GTK8UjM1rfae1rvk;

1.141
date	2016.12.06.21.09.22;	author okan;	state Exp;
branches;
next	1.140;
commitid	YIfXV6Sp4DPXSfx3;

1.140
date	2016.12.01.20.28.19;	author okan;	state Exp;
branches;
next	1.139;
commitid	BV26iM1x8TsKqz4Z;

1.139
date	2016.12.01.18.44.09;	author okan;	state Exp;
branches;
next	1.138;
commitid	1le3tWB0Y53w7cfr;

1.138
date	2016.12.01.18.17.52;	author okan;	state Exp;
branches;
next	1.137;
commitid	xRY1Peh5GoP8Vw8q;

1.137
date	2016.11.15.18.43.09;	author okan;	state Exp;
branches;
next	1.136;
commitid	IRrzQQl3t2g2gDgc;

1.136
date	2016.11.15.00.22.02;	author okan;	state Exp;
branches;
next	1.135;
commitid	OqYiQl9bHme9at14;

1.135
date	2016.11.15.00.07.03;	author okan;	state Exp;
branches;
next	1.134;
commitid	PYr7HT01LVQhfDh6;

1.134
date	2016.10.24.20.44.08;	author okan;	state Exp;
branches;
next	1.133;
commitid	lzO3MzgydwqlVR1a;

1.133
date	2016.10.24.17.39.38;	author okan;	state Exp;
branches;
next	1.132;
commitid	4CtR29PGziRtkeB6;

1.132
date	2016.10.18.17.03.30;	author okan;	state Exp;
branches;
next	1.131;
commitid	dIOrHVlb55Ubzrpl;

1.131
date	2016.10.06.14.53.53;	author okan;	state Exp;
branches;
next	1.130;
commitid	bbvW6xIykd8xNbAy;

1.130
date	2016.10.06.14.41.19;	author okan;	state Exp;
branches;
next	1.129;
commitid	dEdTnOYrabSl1oRa;

1.129
date	2016.10.03.13.52.17;	author okan;	state Exp;
branches;
next	1.128;
commitid	NuJTywreZ210kHEh;

1.128
date	2016.10.03.13.41.30;	author okan;	state Exp;
branches;
next	1.127;
commitid	orUFke6gsTLo5w4T;

1.127
date	2016.09.22.14.36.03;	author okan;	state Exp;
branches;
next	1.126;
commitid	ITo2h4srkSgvGLD0;

1.126
date	2015.11.17.14.32.38;	author okan;	state Exp;
branches;
next	1.125;
commitid	c8XEzvXYnsxJ3oTn;

1.125
date	2015.11.12.21.28.03;	author okan;	state Exp;
branches;
next	1.124;
commitid	Hq4BZzA3Nlni69Xf;

1.124
date	2015.11.12.18.33.30;	author okan;	state Exp;
branches;
next	1.123;
commitid	Kx7sbbZDDgNr89PQ;

1.123
date	2015.11.12.18.26.41;	author okan;	state Exp;
branches;
next	1.122;
commitid	6VVx4mZhWgIPlBck;

1.122
date	2015.11.11.14.22.01;	author okan;	state Exp;
branches;
next	1.121;
commitid	t4AzuTxPlqQ6EzqO;

1.121
date	2015.11.10.22.06.57;	author okan;	state Exp;
branches;
next	1.120;
commitid	myf490V0gA4R6hn2;

1.120
date	2015.11.10.20.05.33;	author okan;	state Exp;
branches;
next	1.119;
commitid	vKzF5zXTpUgY9uJK;

1.119
date	2015.11.09.20.03.29;	author okan;	state Exp;
branches;
next	1.118;
commitid	9uKgpfLzKiBWmiSm;

1.118
date	2015.09.16.17.58.25;	author okan;	state Exp;
branches;
next	1.117;
commitid	5LZITTZspXcfHMXf;

1.117
date	2015.08.28.12.07.28;	author okan;	state Exp;
branches;
next	1.116;
commitid	C3ExTM59dfvNStp7;

1.116
date	2015.08.27.18.40.09;	author okan;	state Exp;
branches;
next	1.115;
commitid	ebXPgx05apj92Rc8;

1.115
date	2015.08.21.16.14.39;	author okan;	state Exp;
branches;
next	1.114;
commitid	SoqEvJwZGG56KptJ;

1.114
date	2015.08.21.16.05.55;	author okan;	state Exp;
branches;
next	1.113;
commitid	1r39soX8fGqXiSh3;

1.113
date	2015.07.12.14.31.47;	author okan;	state Exp;
branches;
next	1.112;
commitid	vbdA9GL2PIvC62Ws;

1.112
date	2015.07.03.17.11.16;	author okan;	state Exp;
branches;
next	1.111;
commitid	sxThNbE5rTmOXe3T;

1.111
date	2015.06.30.19.02.24;	author okan;	state Exp;
branches;
next	1.110;
commitid	l7rItG5t6FzbOpiD;

1.110
date	2015.06.30.18.54.12;	author okan;	state Exp;
branches;
next	1.109;
commitid	BFKdrINXu4OZsfXB;

1.109
date	2015.06.29.14.24.40;	author okan;	state Exp;
branches;
next	1.108;
commitid	1muloK7jkF9NVICv;

1.108
date	2015.06.26.17.17.46;	author okan;	state Exp;
branches;
next	1.107;
commitid	lHlj3PDNu98waqIr;

1.107
date	2015.06.08.15.43.13;	author okan;	state Exp;
branches;
next	1.106;
commitid	rhT7TC3ouVZ4RPuP;

1.106
date	2015.05.21.00.37.04;	author okan;	state Exp;
branches;
next	1.105;
commitid	8wlAl4DgmYSCpXux;

1.105
date	2015.01.19.14.54.16;	author okan;	state Exp;
branches;
next	1.104;
commitid	kLADTGYX3gw0Sf2m;

1.104
date	2014.09.27.19.04.32;	author okan;	state Exp;
branches;
next	1.103;
commitid	X6SwRTs6gMlrxQ8N;

1.103
date	2014.09.17.18.41.44;	author okan;	state Exp;
branches;
next	1.102;
commitid	7QDlXoO0YzmTdgVS;

1.102
date	2014.09.17.18.09.30;	author okan;	state Exp;
branches;
next	1.101;
commitid	vjYvS7lYE7I0AXkO;

1.101
date	2014.09.11.16.06.26;	author okan;	state Exp;
branches;
next	1.100;
commitid	ZLSHuwe8Xj9cN1Z8;

1.100
date	2014.09.08.20.11.22;	author okan;	state Exp;
branches;
next	1.99;
commitid	cu11ybsl8atTMRXD;

1.99
date	2014.09.06.18.50.43;	author okan;	state Exp;
branches;
next	1.98;
commitid	YXmYFnBWnkf1vsKU;

1.98
date	2014.09.06.16.14.35;	author okan;	state Exp;
branches;
next	1.97;
commitid	SwO1sBFRHuUKBTtD;

1.97
date	2014.09.01.18.17.32;	author okan;	state Exp;
branches;
next	1.96;
commitid	LaMeYyOZeKJqODV0;

1.96
date	2014.08.25.12.49.19;	author okan;	state Exp;
branches;
next	1.95;
commitid	rbGNqfikQcQWLop3;

1.95
date	2014.01.30.15.41.11;	author okan;	state Exp;
branches;
next	1.94;

1.94
date	2014.01.29.22.30.00;	author okan;	state Exp;
branches;
next	1.93;

1.93
date	2014.01.23.16.51.28;	author okan;	state Exp;
branches;
next	1.92;

1.92
date	2014.01.22.22.41.09;	author okan;	state Exp;
branches;
next	1.91;

1.91
date	2014.01.22.21.48.27;	author okan;	state Exp;
branches;
next	1.90;

1.90
date	2014.01.21.15.42.45;	author okan;	state Exp;
branches;
next	1.89;

1.89
date	2014.01.20.23.18.47;	author okan;	state Exp;
branches;
next	1.88;

1.88
date	2014.01.20.21.34.32;	author okan;	state Exp;
branches;
next	1.87;

1.87
date	2014.01.20.18.58.03;	author okan;	state Exp;
branches;
next	1.86;

1.86
date	2014.01.03.15.29.06;	author okan;	state Exp;
branches;
next	1.85;

1.85
date	2013.12.16.19.02.17;	author okan;	state Exp;
branches;
next	1.84;

1.84
date	2013.12.13.22.39.13;	author okan;	state Exp;
branches;
next	1.83;

1.83
date	2013.12.13.21.51.56;	author okan;	state Exp;
branches;
next	1.82;

1.82
date	2013.12.12.21.50.50;	author okan;	state Exp;
branches;
next	1.81;

1.81
date	2013.11.27.18.34.34;	author okan;	state Exp;
branches;
next	1.80;

1.80
date	2013.10.17.13.59.10;	author okan;	state Exp;
branches;
next	1.79;

1.79
date	2013.07.08.18.19.22;	author okan;	state Exp;
branches;
next	1.78;

1.78
date	2013.05.11.22.03.17;	author okan;	state Exp;
branches;
next	1.77;

1.77
date	2013.04.08.13.02.31;	author okan;	state Exp;
branches;
next	1.76;

1.76
date	2013.01.08.15.16.05;	author okan;	state Exp;
branches;
next	1.75;

1.75
date	2013.01.04.16.30.03;	author okan;	state Exp;
branches;
next	1.74;

1.74
date	2013.01.02.21.41.14;	author okan;	state Exp;
branches;
next	1.73;

1.73
date	2013.01.02.21.37.21;	author okan;	state Exp;
branches;
next	1.72;

1.72
date	2013.01.01.14.19.56;	author okan;	state Exp;
branches;
next	1.71;

1.71
date	2012.12.17.23.54.57;	author okan;	state Exp;
branches;
next	1.70;

1.70
date	2012.12.17.23.03.41;	author okan;	state Exp;
branches;
next	1.69;

1.69
date	2012.12.17.14.32.39;	author okan;	state Exp;
branches;
next	1.68;

1.68
date	2012.11.09.03.52.02;	author okan;	state Exp;
branches;
next	1.67;

1.67
date	2012.11.07.20.34.39;	author okan;	state Exp;
branches;
next	1.66;

1.66
date	2012.11.07.14.49.46;	author okan;	state Exp;
branches;
next	1.65;

1.65
date	2012.11.07.14.39.44;	author okan;	state Exp;
branches;
next	1.64;

1.64
date	2012.10.31.19.30.19;	author okan;	state Exp;
branches;
next	1.63;

1.63
date	2012.09.09.19.47.47;	author okan;	state Exp;
branches;
next	1.62;

1.62
date	2012.07.13.17.01.04;	author okan;	state Exp;
branches;
next	1.61;

1.61
date	2012.07.13.15.21.35;	author okan;	state Exp;
branches;
next	1.60;

1.60
date	2012.07.04.23.42.03;	author okan;	state Exp;
branches;
next	1.59;

1.59
date	2012.07.04.18.07.12;	author okan;	state Exp;
branches;
next	1.58;

1.58
date	2011.08.29.09.09.45;	author okan;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.25.15.10.24;	author okan;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.23.13.09.11;	author okan;	state Exp;
branches;
next	1.55;

1.55
date	2011.06.24.06.06.24;	author okan;	state Exp;
branches;
next	1.54;

1.54
date	2011.06.24.05.33.41;	author okan;	state Exp;
branches;
next	1.53;

1.53
date	2011.05.11.13.53.51;	author okan;	state Exp;
branches;
next	1.52;

1.52
date	2011.05.07.17.15.37;	author okan;	state Exp;
branches;
next	1.51;

1.51
date	2010.02.10.01.23.05;	author okan;	state Exp;
branches;
next	1.50;

1.50
date	2009.12.15.04.10.42;	author okan;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.15.03.34.34;	author okan;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.15.03.24.36;	author okan;	state Exp;
branches;
next	1.47;

1.47
date	2009.12.10.17.16.51;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2009.12.07.19.45.36;	author okan;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.07.19.44.31;	author okan;	state Exp;
branches;
next	1.44;

1.44
date	2009.11.28.17.52.12;	author tobias;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.05.16.06.15;	author okan;	state Exp;
branches;
next	1.42;

1.42
date	2009.08.25.02.02.59;	author okan;	state Exp;
branches;
next	1.41;

1.41
date	2009.08.24.23.54.41;	author oga;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.20.00.55.42;	author okan;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.20.00.22.39;	author okan;	state Exp;
branches;
next	1.38;

1.38
date	2009.05.17.17.04.59;	author sthen;	state Exp;
branches;
next	1.37;

1.37
date	2009.05.14.16.24.04;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2009.02.07.21.07.00;	author martynas;	state Exp;
branches;
next	1.35;

1.35
date	2009.02.03.22.20.31;	author martynas;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.23.18.58.40;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.16.15.24.14;	author okan;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.11.15.18.29;	author okan;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.11.14.21.28;	author okan;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.25.00.52.47;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.12.18.32.06;	author okan;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.20.14.50.51;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.19.18.53.09;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.19.17.24.19;	author okan;	state Exp;
branches;
next	1.25;

1.25
date	2008.05.19.17.11.19;	author okan;	state Exp;
branches;
next	1.24;

1.24
date	2008.05.19.15.17.50;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.19.12.56.58;	author okan;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.16.13.47.29;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.15.21.20.56;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.15.20.24.41;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.04.08.17.38.27;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.04.07.23.47.09;	author simon;	state Exp;
branches;
next	1.17;

1.17
date	2008.04.05.21.09.19;	author okan;	state Exp;
branches;
next	1.16;

1.16
date	2008.03.23.15.09.21;	author simon;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.22.15.09.45;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.03.22.14.09.02;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.16.11.39.20;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.11.16.06.44;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2007.11.28.16.35.52;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.13.23.08.49;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.07.22.02.04;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.07.21.58.03;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2007.09.06.06.01.14;	author jasper;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.27.13.28.22;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.26.19.34.26;	author niallo;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.05.19.03.20;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.28.18.34.27;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2007.04.27.18.08.14;	author bernd;	state Exp;
branches;
next	1.1;

1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.04.27.17.58.48;	author bernd;	state Exp;
branches;
next	;


desc
@@


1.147
log
@rename one function, matching others, to help upcoming change
@
text
@/*
 * calmwm - the calm window manager
 *
 * Copyright (c) 2004 Martin Murray <mmurray@@monkey.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * $OpenBSD: kbfunc.c,v 1.146 2017/07/10 13:36:58 okan Exp $
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <dirent.h>
#include <err.h>
#include <errno.h>
#include <limits.h>
#include <paths.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "calmwm.h"

#define HASH_MARKER	"|1|"

extern sig_atomic_t	 cwm_status;

static void kbfunc_amount(int, int, int *, int *);

void
kbfunc_cwm_status(void *ctx, struct cargs *cargs)
{
	cwm_status = cargs->flag;
}

static void
kbfunc_amount(int flags, int amt, int *mx, int *my)
{
#define CWM_FACTOR 10

	if (flags & CWM_BIGAMOUNT)
		amt *= CWM_FACTOR;

	switch (flags & DIRECTIONMASK) {
	case CWM_UP:
		*my -= amt;
		break;
	case CWM_DOWN:
		*my += amt;
		break;
	case CWM_RIGHT:
		*mx += amt;
		break;
	case CWM_LEFT:
		*mx -= amt;
		break;
	}
}

void
kbfunc_ptrmove(void *ctx, struct cargs *cargs)
{
	struct screen_ctx	*sc = ctx;
	int			 x, y;
	int			 mx = 0, my = 0;

	kbfunc_amount(cargs->flag, Conf.mamount, &mx, &my);

	xu_ptr_getpos(sc->rootwin, &x, &y);
	xu_ptr_setpos(sc->rootwin, x + mx, y + my);
}

void
kbfunc_client_move(void *ctx, struct cargs *cargs)
{
	struct client_ctx	*cc = ctx;
	struct screen_ctx	*sc = cc->sc;
	struct geom		 area;
	int			 mx = 0, my = 0;

	if (cc->flags & CLIENT_FREEZE)
		return;

	kbfunc_amount(cargs->flag, Conf.mamount, &mx, &my);

	cc->geom.x += mx;
	if (cc->geom.x < -(cc->geom.w + cc->bwidth - 1))
		cc->geom.x = -(cc->geom.w + cc->bwidth - 1);
	if (cc->geom.x > (sc->view.w - cc->bwidth - 1))
		cc->geom.x = sc->view.w - cc->bwidth - 1;
	cc->geom.y += my;
	if (cc->geom.y < -(cc->geom.h + cc->bwidth - 1))
		cc->geom.y = -(cc->geom.h + cc->bwidth - 1);
	if (cc->geom.y > (sc->view.h - cc->bwidth - 1))
		cc->geom.y = sc->view.h - cc->bwidth - 1;

	area = screen_area(sc,
	    cc->geom.x + cc->geom.w / 2,
	    cc->geom.y + cc->geom.h / 2, CWM_GAP);
	cc->geom.x += client_snapcalc(cc->geom.x,
	    cc->geom.x + cc->geom.w + (cc->bwidth * 2),
	    area.x, area.x + area.w, sc->snapdist);
	cc->geom.y += client_snapcalc(cc->geom.y,
	    cc->geom.y + cc->geom.h + (cc->bwidth * 2),
	    area.y, area.y + area.h, sc->snapdist);

	client_move(cc);
	client_ptr_inbound(cc, 1);
}

void
kbfunc_client_resize(void *ctx, struct cargs *cargs)
{
	struct client_ctx	*cc = ctx;
	int			 mx = 0, my = 0;
	int			 amt = 1;

	if (cc->flags & CLIENT_FREEZE)
		return;

	if (!(cc->hint.flags & PResizeInc))
		amt = Conf.mamount;

	kbfunc_amount(cargs->flag, amt, &mx, &my);

	if ((cc->geom.w += mx * cc->hint.incw) < cc->hint.minw)
		cc->geom.w = cc->hint.minw;
	if ((cc->geom.h += my * cc->hint.inch) < cc->hint.minh)
		cc->geom.h = cc->hint.minh;
	if (cc->geom.x + cc->geom.w + cc->bwidth - 1 < 0)
		cc->geom.x = -(cc->geom.w + cc->bwidth - 1);
	if (cc->geom.y + cc->geom.h + cc->bwidth - 1 < 0)
		cc->geom.y = -(cc->geom.h + cc->bwidth - 1);

	client_resize(cc, 1);
	client_ptr_inbound(cc, 1);
}

void
kbfunc_client_delete(void *ctx, struct cargs *cargs)
{
	client_send_delete(ctx);
}

void
kbfunc_client_lower(void *ctx, struct cargs *cargs)
{
	client_ptrsave(ctx);
	client_lower(ctx);
}

void
kbfunc_client_raise(void *ctx, struct cargs *cargs)
{
	client_raise(ctx);
}

void
kbfunc_client_hide(void *ctx, struct cargs *cargs)
{
	client_hide(ctx);
}

void
kbfunc_client_toggle_freeze(void *ctx, struct cargs *cargs)
{
	client_toggle_freeze(ctx);
}

void
kbfunc_client_toggle_sticky(void *ctx, struct cargs *cargs)
{
	client_toggle_sticky(ctx);
}

void
kbfunc_client_toggle_fullscreen(void *ctx, struct cargs *cargs)
{
	client_toggle_fullscreen(ctx);
}

void
kbfunc_client_toggle_maximize(void *ctx, struct cargs *cargs)
{
	client_toggle_maximize(ctx);
}

void
kbfunc_client_toggle_hmaximize(void *ctx, struct cargs *cargs)
{
	client_toggle_hmaximize(ctx);
}

void
kbfunc_client_toggle_vmaximize(void *ctx, struct cargs *cargs)
{
	client_toggle_vmaximize(ctx);
}

void
kbfunc_client_htile(void *ctx, struct cargs *cargs)
{
	client_htile(ctx);
}

void
kbfunc_client_vtile(void *ctx, struct cargs *cargs)
{
	client_vtile(ctx);
}

void
kbfunc_client_cycle(void *ctx, struct cargs *cargs)
{
	client_cycle(ctx, cargs->flag);
}

void
kbfunc_client_toggle_group(void *ctx, struct cargs *cargs)
{
	struct client_ctx	*cc = ctx;

	/* For X apps that steal events. */
	if (cargs->xev == CWM_XEV_KEY)
		XGrabKeyboard(X_Dpy, cc->win, True,
		    GrabModeAsync, GrabModeAsync, CurrentTime);

	group_toggle_membership_enter(cc);
}

void
kbfunc_client_movetogroup(void *ctx, struct cargs *cargs)
{
	group_movetogroup(ctx, cargs->flag);
}

void
kbfunc_group_toggle(void *ctx, struct cargs *cargs)
{
	group_hidetoggle(ctx, cargs->flag);
}

void
kbfunc_group_only(void *ctx, struct cargs *cargs)
{
	group_only(ctx, cargs->flag);
}

void
kbfunc_group_cycle(void *ctx, struct cargs *cargs)
{
	group_cycle(ctx, cargs->flag);
}

void
kbfunc_group_alltoggle(void *ctx, struct cargs *cargs)
{
	group_alltoggle(ctx);
}

void
kbfunc_menu_client(void *ctx, struct cargs *cargs)
{
	struct screen_ctx	*sc = ctx;
	struct client_ctx	*cc, *old_cc;
	struct menu		*mi;
	struct menu_q		 menuq;
	int			 m = (cargs->xev == CWM_XEV_BTN);
	int			 all = (cargs->flag & CWM_MENU_WINDOW_ALL);

	old_cc = client_current();

	TAILQ_INIT(&menuq);
	TAILQ_FOREACH(cc, &sc->clientq, entry) {
		if (!all) {
			if (cc->flags & CLIENT_HIDDEN)
				menuq_add(&menuq, cc, NULL);
		} else
			menuq_add(&menuq, cc, NULL);
	}

	if ((mi = menu_filter(sc, &menuq,
	    (m) ? NULL : "window", NULL,
	    ((m) ? CWM_MENU_LIST : 0),
	    search_match_client, search_print_client)) != NULL) {
		cc = (struct client_ctx *)mi->ctx;
		if (cc->flags & CLIENT_HIDDEN)
			client_unhide(cc);
		else
			client_raise(cc);
		if (old_cc)
			client_ptrsave(old_cc);
		client_ptrwarp(cc);
	}

	menuq_clear(&menuq);
}

void
kbfunc_menu_cmd(void *ctx, struct cargs *cargs)
{
	struct screen_ctx	*sc = ctx;
	struct cmd_ctx		*cmd;
	struct menu		*mi;
	struct menu_q		 menuq;
	int			 m = (cargs->xev == CWM_XEV_BTN);

	TAILQ_INIT(&menuq);
	TAILQ_FOREACH(cmd, &Conf.cmdq, entry) {
		if ((strcmp(cmd->name, "lock") == 0) ||
		    (strcmp(cmd->name, "term") == 0))
			continue;
		/* search_match_text() needs mi->text */
		menuq_add(&menuq, cmd, "%s", cmd->name);
	}

	if ((mi = menu_filter(sc, &menuq,
	    (m) ? NULL : "application", NULL,
	    ((m) ? CWM_MENU_LIST : 0),
	    search_match_text, search_print_cmd)) != NULL) {
		cmd = (struct cmd_ctx *)mi->ctx;
		u_spawn(cmd->path);
	}

	menuq_clear(&menuq);
}

void
kbfunc_menu_group(void *ctx, struct cargs *cargs)
{
	struct screen_ctx	*sc = ctx;
	struct group_ctx	*gc;
	struct menu		*mi;
	struct menu_q		 menuq;
	int			 m = (cargs->xev == CWM_XEV_BTN);

	TAILQ_INIT(&menuq);
	TAILQ_FOREACH(gc, &sc->groupq, entry) {
		if (group_holds_only_sticky(gc))
			continue;
		menuq_add(&menuq, gc, "%d %s", gc->num, gc->name);
	}

	if ((mi = menu_filter(sc, &menuq,
	    (m) ? NULL : "group", NULL, (CWM_MENU_LIST),
	    search_match_text, search_print_group)) != NULL) {
		gc = (struct group_ctx *)mi->ctx;
		(group_holds_only_hidden(gc)) ?
		    group_show(gc) : group_hide(gc);
	}

	menuq_clear(&menuq);
}

void
kbfunc_menu_exec(void *ctx, struct cargs *cargs)
{
#define NPATHS 256
	struct screen_ctx	*sc = ctx;
	char			**ap, *paths[NPATHS], *path, *pathcpy;
	char			 tpath[PATH_MAX];
	struct stat		 sb;
	const char		*label;
	DIR			*dirp;
	struct dirent		*dp;
	struct menu		*mi;
	struct menu_q		 menuq;
	int			 l, i, cmd = cargs->flag;

	switch (cmd) {
	case CWM_MENU_EXEC_EXEC:
		label = "exec";
		break;
	case CWM_MENU_EXEC_WM:
		label = "wm";
		break;
	default:
		errx(1, "%s: invalid cmd %d", __func__, cmd);
		/* NOTREACHED */
	}

	TAILQ_INIT(&menuq);

	if ((path = getenv("PATH")) == NULL)
		path = _PATH_DEFPATH;
	pathcpy = path = xstrdup(path);

	for (ap = paths; ap < &paths[NPATHS - 1] &&
	    (*ap = strsep(&pathcpy, ":")) != NULL;) {
		if (**ap != '\0')
			ap++;
	}
	*ap = NULL;
	for (i = 0; i < NPATHS && paths[i] != NULL; i++) {
		if ((dirp = opendir(paths[i])) == NULL)
			continue;

		while ((dp = readdir(dirp)) != NULL) {
			(void)memset(tpath, '\0', sizeof(tpath));
			l = snprintf(tpath, sizeof(tpath), "%s/%s", paths[i],
			    dp->d_name);
			if (l == -1 || l >= sizeof(tpath))
				continue;
			/* Skip everything but regular files and symlinks. */
			if (dp->d_type != DT_REG && dp->d_type != DT_LNK) {
				/* lstat(2) in case d_type isn't supported. */
				if (lstat(tpath, &sb) == -1)
					continue;
				if (!S_ISREG(sb.st_mode) && 
				    !S_ISLNK(sb.st_mode))
					continue;
			}
			if (access(tpath, X_OK) == 0)
				menuq_add(&menuq, NULL, "%s", dp->d_name);
		}
		(void)closedir(dirp);
	}
	free(path);

	if ((mi = menu_filter(sc, &menuq, label, NULL,
	    (CWM_MENU_DUMMY | CWM_MENU_FILE),
	    search_match_exec, search_print_text)) != NULL) {
		if (mi->text[0] == '\0')
			goto out;
		switch (cmd) {
		case CWM_MENU_EXEC_EXEC:
			u_spawn(mi->text);
			break;
		case CWM_MENU_EXEC_WM:
			cwm_status = CWM_EXEC_WM;
			free(Conf.wm_argv);
			Conf.wm_argv = xstrdup(mi->text);
			break;
		default:
			errx(1, "%s: egad, cmd changed value!", __func__);
			/* NOTREACHED */
		}
	}
out:
	if (mi != NULL && mi->dummy)
		free(mi);
	menuq_clear(&menuq);
}

void
kbfunc_menu_ssh(void *ctx, struct cargs *cargs)
{
	struct screen_ctx	*sc = ctx;
	struct cmd_ctx		*cmd;
	struct menu		*mi;
	struct menu_q		 menuq;
	FILE			*fp;
	char			*buf, *lbuf, *p;
	char			 hostbuf[HOST_NAME_MAX+1];
	char			 path[PATH_MAX];
	int			 l;
	size_t			 len;
	ssize_t			 slen;

	TAILQ_FOREACH(cmd, &Conf.cmdq, entry) {
		if (strcmp(cmd->name, "term") == 0)
			break;
	}
	TAILQ_INIT(&menuq);

	if ((fp = fopen(Conf.known_hosts, "r")) == NULL) {
		warn("%s: %s", __func__, Conf.known_hosts);
		goto menu;
	}

	lbuf = NULL;
	len = 0;
	while ((slen = getline(&lbuf, &len, fp)) != -1) {
		buf = lbuf;
		if (buf[slen - 1] == '\n')
			buf[slen - 1] = '\0';
		
		/* skip hashed hosts */
		if (strncmp(buf, HASH_MARKER, strlen(HASH_MARKER)) == 0)
			continue;
		for (p = buf; *p != ',' && *p != ' ' && p != buf + slen; p++) {
			/* do nothing */
		}
		/* ignore badness */
		if (p - buf + 1 > sizeof(hostbuf))
			continue;
		(void)strlcpy(hostbuf, buf, p - buf + 1);
		menuq_add(&menuq, NULL, "%s", hostbuf);
	}
	free(lbuf);
	if (ferror(fp))
		err(1, "%s", path);
	(void)fclose(fp);
menu:
	if ((mi = menu_filter(sc, &menuq, "ssh", NULL, (CWM_MENU_DUMMY),
	    search_match_text, search_print_text)) != NULL) {
		if (mi->text[0] == '\0')
			goto out;
		l = snprintf(path, sizeof(path), "%s -T '[ssh] %s' -e ssh %s",
		    cmd->path, mi->text, mi->text);
		if (l == -1 || l >= sizeof(path))
			goto out;
		u_spawn(path);
	}
out:
	if (mi != NULL && mi->dummy)
		free(mi);
	menuq_clear(&menuq);
}

void
kbfunc_client_menu_label(void *ctx, struct cargs *cargs)
{
	struct client_ctx	*cc = ctx;
	struct menu		*mi;
	struct menu_q		 menuq;

	TAILQ_INIT(&menuq);

	/* dummy is set, so this will always return */
	mi = menu_filter(cc->sc, &menuq, "label", cc->label, (CWM_MENU_DUMMY),
	    search_match_text, search_print_text);

	if (!mi->abort) {
		free(cc->label);
		cc->label = xstrdup(mi->text);
	}
	free(mi);
}

void
kbfunc_exec_cmd(void *ctx, struct cargs *cargs)
{
	u_spawn(cargs->cmd);
}

void
kbfunc_exec_term(void *ctx, struct cargs *cargs)
{
	struct cmd_ctx	*cmd;

	TAILQ_FOREACH(cmd, &Conf.cmdq, entry) {
		if (strcmp(cmd->name, "term") == 0)
			u_spawn(cmd->path);
	}
}

void
kbfunc_exec_lock(void *ctx, struct cargs *cargs)
{
	struct cmd_ctx	*cmd;

	TAILQ_FOREACH(cmd, &Conf.cmdq, entry) {
		if (strcmp(cmd->name, "lock") == 0)
			u_spawn(cmd->path);
	}
}
@


1.146
log
@Replace fgetln(3) with POSIX getline(3); inspired by brynet and Ingo.

feedback and ok brynet@@
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.145 2017/05/09 13:40:18 okan Exp $
d525 1
a525 1
kbfunc_menu_client_label(void *ctx, struct cargs *cargs)
@


1.145
log
@Alter callbacks to take a struct instead of a growing number of arguments;
greatly simplifies upcoming work.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.144 2017/05/01 12:54:55 okan Exp $
d471 1
d485 6
a490 10
	while ((buf = fgetln(fp, &len))) {
		if (buf[len - 1] == '\n')
			buf[len - 1] = '\0';
		else {
			/* EOF without EOL, copy and add the NUL */
			lbuf = xmalloc(len + 1);
			(void)memcpy(lbuf, buf, len);
			lbuf[len] = '\0';
			buf = lbuf;
		}
d494 1
a494 1
		for (p = buf; *p != ',' && *p != ' ' && p != buf + len; p++) {
d504 2
@


1.144
log
@Clean up, unify and accurately calculate edge distance with client move/resize
actions, so as to not lose windows off the edge.

inspired by diffs (and feedback) from Vadim Vygonets.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.143 2017/01/05 21:18:20 okan Exp $
d44 1
a44 1
kbfunc_cwm_status(void *ctx, union arg *arg, enum xev xev)
d46 1
a46 1
	cwm_status = arg->i;
d74 1
a74 1
kbfunc_ptrmove(void *ctx, union arg *arg, enum xev xev)
d80 1
a80 1
	kbfunc_amount(arg->i, Conf.mamount, &mx, &my);
d87 1
a87 1
kbfunc_client_move(void *ctx, union arg *arg, enum xev xev)
d97 1
a97 1
	kbfunc_amount(arg->i, Conf.mamount, &mx, &my);
d125 1
a125 1
kbfunc_client_resize(void *ctx, union arg *arg, enum xev xev)
d137 1
a137 1
	kbfunc_amount(arg->i, amt, &mx, &my);
d153 1
a153 1
kbfunc_client_delete(void *ctx, union arg *arg, enum xev xev)
d159 1
a159 1
kbfunc_client_lower(void *ctx, union arg *arg, enum xev xev)
d166 1
a166 1
kbfunc_client_raise(void *ctx, union arg *arg, enum xev xev)
d172 1
a172 1
kbfunc_client_hide(void *ctx, union arg *arg, enum xev xev)
d178 1
a178 1
kbfunc_client_toggle_freeze(void *ctx, union arg *arg, enum xev xev)
d184 1
a184 1
kbfunc_client_toggle_sticky(void *ctx, union arg *arg, enum xev xev)
d190 1
a190 1
kbfunc_client_toggle_fullscreen(void *ctx, union arg *arg, enum xev xev)
d196 1
a196 1
kbfunc_client_toggle_maximize(void *ctx, union arg *arg, enum xev xev)
d202 1
a202 1
kbfunc_client_toggle_hmaximize(void *ctx, union arg *arg, enum xev xev)
d208 1
a208 1
kbfunc_client_toggle_vmaximize(void *ctx, union arg *arg, enum xev xev)
d214 1
a214 1
kbfunc_client_htile(void *ctx, union arg *arg, enum xev xev)
d220 1
a220 1
kbfunc_client_vtile(void *ctx, union arg *arg, enum xev xev)
d226 1
a226 1
kbfunc_client_cycle(void *ctx, union arg *arg, enum xev xev)
d228 1
a228 1
	client_cycle(ctx, arg->i);
d232 1
a232 1
kbfunc_client_toggle_group(void *ctx, union arg *arg, enum xev xev)
d236 2
a237 2
	if (xev == CWM_XEV_KEY) {
		/* For X apps that steal events. */
a239 1
	}
d245 1
a245 1
kbfunc_client_movetogroup(void *ctx, union arg *arg, enum xev xev)
d247 1
a247 1
	group_movetogroup(ctx, arg->i);
d251 1
a251 1
kbfunc_group_toggle(void *ctx, union arg *arg, enum xev xev)
d253 1
a253 1
	group_hidetoggle(ctx, arg->i);
d257 1
a257 1
kbfunc_group_only(void *ctx, union arg *arg, enum xev xev)
d259 1
a259 1
	group_only(ctx, arg->i);
d263 1
a263 1
kbfunc_group_cycle(void *ctx, union arg *arg, enum xev xev)
d265 1
a265 1
	group_cycle(ctx, arg->i);
d269 1
a269 1
kbfunc_group_alltoggle(void *ctx, union arg *arg, enum xev xev)
d275 1
a275 1
kbfunc_menu_client(void *ctx, union arg *arg, enum xev xev)
d281 2
a282 2
	int			 m = (xev == CWM_XEV_BTN);
	int			 all = (arg->i & CWM_MENU_WINDOW_ALL);
d313 1
a313 1
kbfunc_menu_cmd(void *ctx, union arg *arg, enum xev xev)
d319 1
a319 1
	int			 m = (xev == CWM_XEV_BTN);
d342 1
a342 1
kbfunc_menu_group(void *ctx, union arg *arg, enum xev xev)
d348 1
a348 1
	int			 m = (xev == CWM_XEV_BTN);
d369 1
a369 1
kbfunc_menu_exec(void *ctx, union arg *arg, enum xev xev)
d381 1
a381 1
	int			 l, i, cmd = arg->i;
d459 1
a459 1
kbfunc_menu_ssh(void *ctx, union arg *arg, enum xev xev)
d526 1
a526 1
kbfunc_menu_client_label(void *ctx, union arg *arg, enum xev xev)
d546 1
a546 1
kbfunc_exec_cmd(void *ctx, union arg *arg, enum xev xev)
d548 1
a548 1
	u_spawn(arg->c);
d552 1
a552 1
kbfunc_exec_term(void *ctx, union arg *arg, enum xev xev)
d563 1
a563 1
kbfunc_exec_lock(void *ctx, union arg *arg, enum xev xev)
@


1.143
log
@Ensure client stays inbound on key-based resize; based on logic existing in
key-based client move; from Vadim Vygonets.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.142 2016/12/06 21:54:10 okan Exp $
d41 1
a41 1
static void kbfunc_amount(int, int, unsigned int *, unsigned int *);
d50 1
a50 1
kbfunc_amount(int flags, int amt, unsigned int *mx, unsigned int *my)
d78 1
a78 1
	unsigned int		 mx = 0, my = 0;
d92 1
a92 2
	int			 x, y, px, py;
	unsigned int		 mx = 0, my = 0;
a96 12
	xu_ptr_getpos(cc->win, &px, &py);
	if (px < 0)
		px = 0;
	else if (px > cc->geom.w)
		px = cc->geom.w;
	if (py < 0)
		py = 0;
	else if (py > cc->geom.h)
		py = cc->geom.h;

	xu_ptr_setpos(cc->win, px, py);

d100 4
a103 4
	if (cc->geom.x + cc->geom.w < 0)
		cc->geom.x = -cc->geom.w;
	if (cc->geom.x > sc->view.w - 1)
		cc->geom.x = sc->view.w - 1;
d105 4
a108 4
	if (cc->geom.y + cc->geom.h < 0)
		cc->geom.y = -cc->geom.h;
	if (cc->geom.y > sc->view.h - 1)
		cc->geom.y = sc->view.h - 1;
d119 1
d121 1
a121 5

	xu_ptr_getpos(cc->win, &x, &y);
	cc->ptr.x = x + mx;
	cc->ptr.y = y + my;
	client_ptrwarp(cc);
d128 1
a128 1
	unsigned int		 mx = 0, my = 0;
d143 5
a147 4
	if (cc->geom.x + cc->geom.w < 0)
		cc->geom.x = -cc->geom.w;
	if (cc->geom.y + cc->geom.h < 0)
		cc->geom.y = -cc->geom.h;
d149 1
a149 8

	/* Make sure the pointer stays within the window. */
	xu_ptr_getpos(cc->win, &cc->ptr.x, &cc->ptr.y);
	if (cc->ptr.x > cc->geom.w)
		cc->ptr.x = cc->geom.w - cc->bwidth;
	if (cc->ptr.y > cc->geom.h)
		cc->ptr.y = cc->geom.h - cc->bwidth;
	client_ptrwarp(cc);
@


1.142
log
@Add search_print_text(), a default callback for mi->print in menu_filter(). While
here, normalize the remaining search_print_* argument paramters.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.141 2016/12/06 21:09:22 okan Exp $
d159 4
@


1.141
log
@Consistent use of menuq_add for ssh menu.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.140 2016/12/01 20:28:19 okan Exp $
d454 1
a454 1
	    search_match_exec, NULL)) != NULL) {
d529 1
a529 1
	    search_match_text, NULL)) != NULL) {
d555 1
a555 1
	    search_match_text, NULL);
@


1.140
log
@Tame the number of 'exec' and 'path' search_match wrappers. No functional
change now, though more can likely go later, losing the (paritally complete or
incomplete/broken) argument completion bits.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.139 2016/12/01 18:44:09 okan Exp $
d523 1
a523 1
		menuq_add(&menuq, NULL, hostbuf);
@


1.139
log
@Switch ssh menu to search_match_text; like group/window/cmd menus, use only a
substring match. The previous matching is only intended for the exec menus.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.138 2016/12/01 18:17:52 okan Exp $
d454 1
a454 1
	    search_match_exec_path, NULL)) != NULL) {
@


1.138
log
@Change 'menu-window' to display all windows; then add 'menu-window-hidden' for
the previous behaviour of 'menu-window'.  'menu-window' becomes the default
binding; use 'bind-mouse "1" menu-window-hidden' to restore old behaviour for
those who prefer.

OK sthen@@ (long long time ago on a different version)
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.137 2016/11/15 18:43:09 okan Exp $
d529 1
a529 1
	    search_match_exec, NULL)) != NULL) {
@


1.137
log
@Use an additional check with lstat(2) when d_type is unknown.

from James McDonald via portable.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.136 2016/11/15 00:22:02 okan Exp $
d301 1
d307 1
a307 1
		if (m) {
@


1.136
log
@revert previous; upcoming changes will hopefully deal with these more
naturally.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.134 2016/10/24 20:44:08 okan Exp $
d393 1
a429 3
			/* skip everything but regular files and symlinks */
			if (dp->d_type != DT_REG && dp->d_type != DT_LNK)
				continue;
d435 9
@


1.135
log
@Add a wrapper based upon xevent handlers around client move/resize for key and
mouse bindings.
@
text
@a88 11
	int			 m = (xev == CWM_XEV_BTN);

	if (m)
		mousefunc_client_move(ctx, arg, xev);
	else
		kbfunc_client_move_key(ctx, arg, xev);
}

void
kbfunc_client_move_key(void *ctx, union arg *arg, enum xev xev)
{
a141 11
{
	int			 m = (xev == CWM_XEV_BTN);

	if (m)
		mousefunc_client_resize(ctx, arg, xev);
	else
		kbfunc_client_resize_key(ctx, arg, xev);
}

void
kbfunc_client_resize_key(void *ctx, union arg *arg, enum xev xev)
@


1.134
log
@Make it clear these are flags.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.133 2016/10/24 17:39:38 okan Exp $
d89 11
d153 11
@


1.133
log
@Sprinkle __func__ in appropriate error messages.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.132 2016/10/18 17:03:30 okan Exp $
d315 1
a315 1
	    (m) ? CWM_MENU_LIST : 0,
d350 1
a350 1
	    (m) ? CWM_MENU_LIST : 0,
d376 1
a376 1
	    (m) ? NULL : "group", NULL, CWM_MENU_LIST,
d445 1
a445 1
	    CWM_MENU_DUMMY | CWM_MENU_FILE,
d520 1
a520 1
	if ((mi = menu_filter(sc, &menuq, "ssh", NULL, CWM_MENU_DUMMY,
d546 1
a546 1
	mi = menu_filter(cc->sc, &menuq, "label", cc->label, CWM_MENU_DUMMY,
@


1.132
log
@Refactor callbacks to take a void * so as to not try and generalize into
client_ctx in keypress and buttonpress event handlers; pass appropriate *ctx's
based on context.

While here, limit some globals, replace defines with appropriate variables and
fix some naming.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.131 2016/10/06 14:53:53 okan Exp $
d408 1
a408 1
		errx(1, "kbfunc_menu_exec: invalid cmd %d", cmd);
d459 1
a459 1
			errx(1, "kb_func: egad, cmd changed value!");
d490 1
a490 1
		warn("kbfunc_menu_ssh: %s", Conf.known_hosts);
@


1.131
log
@Rename 2 kbfunc to match closer to what they do
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.130 2016/10/06 14:41:19 okan Exp $
d44 1
a44 1
kbfunc_client_lower(struct client_ctx *cc, union arg *arg, int xev)
d46 1
a46 8
	client_ptrsave(cc);
	client_lower(cc);
}

void
kbfunc_client_raise(struct client_ctx *cc, union arg *arg, int xev)
{
	client_raise(cc);
d74 1
a74 1
kbfunc_ptrmove(struct client_ctx *cc, union arg *arg, int xev)
d76 1
a76 1
	struct screen_ctx	*sc = cc->sc;
d87 1
a87 1
kbfunc_client_move(struct client_ctx *cc, union arg *arg, int xev)
d89 1
d141 1
a141 1
kbfunc_client_resize(struct client_ctx *cc, union arg *arg, int xev)
d143 1
d171 56
a226 1
kbfunc_menu_client(struct client_ctx *cc, union arg *arg, int xev)
d228 70
a297 2
	struct screen_ctx	*sc = cc->sc;
	struct client_ctx	*old_cc;
d300 1
a300 1
	int			 m = (xev == CWM_BTN);
d331 1
a331 1
kbfunc_menu_cmd(struct client_ctx *cc, union arg *arg, int xev)
d333 2
a334 2
	struct screen_ctx	*sc = cc->sc;
	struct cmd		*cmd;
d337 1
a337 1
	int			 m = (xev == CWM_BTN);
d352 1
a352 1
		cmd = (struct cmd *)mi->ctx;
d360 1
a360 1
kbfunc_menu_group(struct client_ctx *cc, union arg *arg, int xev)
d362 1
a362 1
	struct screen_ctx	*sc = cc->sc;
d366 1
a366 1
	int			 m = (xev == CWM_BTN);
d387 1
a387 41
kbfunc_client_cycle(struct client_ctx *cc, union arg *arg, int xev)
{
	client_cycle(cc->sc, arg->i);
}

void
kbfunc_client_hide(struct client_ctx *cc, union arg *arg, int xev)
{
	client_hide(cc);
}

void
kbfunc_exec(struct client_ctx *cc, union arg *arg, int xev)
{
	u_spawn(arg->c);
}

void
kbfunc_exec_term(struct client_ctx *cc, union arg *arg, int xev)
{
	struct cmd *cmd;

	TAILQ_FOREACH(cmd, &Conf.cmdq, entry) {
		if (strcmp(cmd->name, "term") == 0)
			u_spawn(cmd->path);
	}
}

void
kbfunc_exec_lock(struct client_ctx *cc, union arg *arg, int xev)
{
	struct cmd *cmd;

	TAILQ_FOREACH(cmd, &Conf.cmdq, entry) {
		if (strcmp(cmd->name, "lock") == 0)
			u_spawn(cmd->path);
	}
}

void
kbfunc_menu_exec(struct client_ctx *cc, union arg *arg, int xev)
d390 1
a390 1
	struct screen_ctx	*sc = cc->sc;
d401 1
a401 1
	case CWM_MENU_EXEC:
d409 1
a409 1
		/*NOTREACHED*/
d450 1
a450 1
		case CWM_MENU_EXEC:
d455 2
a456 2
			free(wm_argv);
			wm_argv = xstrdup(mi->text);
d460 1
a460 1
			break;
d470 1
a470 1
kbfunc_menu_ssh(struct client_ctx *cc, union arg *arg, int xev)
d472 2
a473 2
	struct screen_ctx	*sc = cc->sc;
	struct cmd		*cmd;
d537 1
a537 1
kbfunc_menu_client_label(struct client_ctx *cc, union arg *arg, int xev)
d539 3
a541 2
	struct menu	*mi;
	struct menu_q	 menuq;
d557 1
a557 1
kbfunc_client_delete(struct client_ctx *cc, union arg *arg, int xev)
d559 1
a559 1
	client_send_delete(cc);
d563 1
a563 1
kbfunc_group_toggle(struct client_ctx *cc, union arg *arg, int xev)
d565 1
a565 2
	group_hidetoggle(cc->sc, arg->i);
}
d567 3
a569 25
void
kbfunc_group_only(struct client_ctx *cc, union arg *arg, int xev)
{
	group_only(cc->sc, arg->i);
}

void
kbfunc_group_cycle(struct client_ctx *cc, union arg *arg, int xev)
{
	group_cycle(cc->sc, arg->i);
}

void
kbfunc_group_alltoggle(struct client_ctx *cc, union arg *arg, int xev)
{
	group_alltoggle(cc->sc);
}

void
kbfunc_client_toggle_group(struct client_ctx *cc, union arg *arg, int xev)
{
	if (xev == CWM_KEY) {
		/* For X apps that steal events. */
		XGrabKeyboard(X_Dpy, cc->win, True,
		    GrabModeAsync, GrabModeAsync, CurrentTime);
a570 2

	group_toggle_membership_enter(cc);
d574 1
a574 1
kbfunc_client_movetogroup(struct client_ctx *cc, union arg *arg, int xev)
d576 1
a576 2
	group_movetogroup(cc, arg->i);
}
d578 3
a580 52
void
kbfunc_client_toggle_sticky(struct client_ctx *cc, union arg *arg, int xev)
{
	client_toggle_sticky(cc);
}

void
kbfunc_client_toggle_fullscreen(struct client_ctx *cc, union arg *arg, int xev)
{
	client_toggle_fullscreen(cc);
}

void
kbfunc_client_toggle_maximize(struct client_ctx *cc, union arg *arg, int xev)
{
	client_toggle_maximize(cc);
}

void
kbfunc_client_toggle_vmaximize(struct client_ctx *cc, union arg *arg, int xev)
{
	client_toggle_vmaximize(cc);
}

void
kbfunc_client_toggle_hmaximize(struct client_ctx *cc, union arg *arg, int xev)
{
	client_toggle_hmaximize(cc);
}

void
kbfunc_client_toggle_freeze(struct client_ctx *cc, union arg *arg, int xev)
{
	client_toggle_freeze(cc);
}

void
kbfunc_cwm_status(struct client_ctx *cc, union arg *arg, int xev)
{
	cwm_status = arg->i;
}

void
kbfunc_client_tile(struct client_ctx *cc, union arg *arg, int xev)
{
	switch (arg->i) {
	case CWM_CLIENT_TILE_HORIZ:
		client_htile(cc);
		break;
	case CWM_CLIENT_TILE_VERT:
		client_vtile(cc);
		break;
@


1.130
log
@Add an argument to the callbacks to pass the xevent context, button or
key press. This allows to remove a few hacks to duplicate functions only
for behaviour changes; now differing behaviours are pushed down to the
callback. Also will allow for previously unavailable actions to be bind-able
down the road.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.129 2016/10/03 13:52:17 okan Exp $
d459 1
a459 1
kbfunc_client_label(struct client_ctx *cc, union arg *arg, int xev)
d508 1
a508 1
kbfunc_client_grouptoggle(struct client_ctx *cc, union arg *arg, int xev)
@


1.129
log
@For both kb and mouse move, it is possible to grab a client and move it
completely off the screen/region; instead, if the pointer is outside of
the client bounds, warp the pointer to the closest edge before moving.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.128 2016/10/03 13:41:30 okan Exp $
d44 1
a44 1
kbfunc_client_lower(struct client_ctx *cc, union arg *arg)
d51 1
a51 1
kbfunc_client_raise(struct client_ctx *cc, union arg *arg)
d81 1
a81 1
kbfunc_ptrmove(struct client_ctx *cc, union arg *arg)
d94 1
a94 1
kbfunc_client_move(struct client_ctx *cc, union arg *arg)
d147 1
a147 1
kbfunc_client_resize(struct client_ctx *cc, union arg *arg)
d176 1
a176 1
kbfunc_menu_client(struct client_ctx *cc, union arg *arg)
d182 1
a182 1
	int			 m = (arg->i == CWM_MOUSE);
d213 1
a213 1
kbfunc_menu_cmd(struct client_ctx *cc, union arg *arg)
d219 1
a219 1
	int			 m = (arg->i == CWM_MOUSE);
d242 1
a242 1
kbfunc_menu_group(struct client_ctx *cc, union arg *arg)
d248 1
a248 1
	int			 m = (arg->i == CWM_MOUSE);
d269 1
a269 1
kbfunc_client_cycle(struct client_ctx *cc, union arg *arg)
d275 1
a275 1
kbfunc_client_hide(struct client_ctx *cc, union arg *arg)
d281 1
a281 1
kbfunc_exec(struct client_ctx *cc, union arg *arg)
d287 1
a287 1
kbfunc_exec_term(struct client_ctx *cc, union arg *arg)
d298 1
a298 1
kbfunc_exec_lock(struct client_ctx *cc, union arg *arg)
d309 1
a309 1
kbfunc_menu_exec(struct client_ctx *cc, union arg *arg)
d392 1
a392 1
kbfunc_menu_ssh(struct client_ctx *cc, union arg *arg)
d459 1
a459 1
kbfunc_client_label(struct client_ctx *cc, union arg *arg)
d478 1
a478 1
kbfunc_client_delete(struct client_ctx *cc, union arg *arg)
d484 1
a484 1
kbfunc_group_toggle(struct client_ctx *cc, union arg *arg)
d490 1
a490 1
kbfunc_group_only(struct client_ctx *cc, union arg *arg)
d496 1
a496 1
kbfunc_group_cycle(struct client_ctx *cc, union arg *arg)
d502 1
a502 1
kbfunc_group_alltoggle(struct client_ctx *cc, union arg *arg)
d508 1
a508 1
kbfunc_client_grouptoggle(struct client_ctx *cc, union arg *arg)
d510 1
a510 1
	if (arg->i == CWM_KBD) {
d520 1
a520 1
kbfunc_client_movetogroup(struct client_ctx *cc, union arg *arg)
d526 1
a526 1
kbfunc_client_toggle_sticky(struct client_ctx *cc, union arg *arg)
d532 1
a532 1
kbfunc_client_toggle_fullscreen(struct client_ctx *cc, union arg *arg)
d538 1
a538 1
kbfunc_client_toggle_maximize(struct client_ctx *cc, union arg *arg)
d544 1
a544 1
kbfunc_client_toggle_vmaximize(struct client_ctx *cc, union arg *arg)
d550 1
a550 1
kbfunc_client_toggle_hmaximize(struct client_ctx *cc, union arg *arg)
d556 1
a556 1
kbfunc_client_toggle_freeze(struct client_ctx *cc, union arg *arg)
d562 1
a562 1
kbfunc_cwm_status(struct client_ctx *cc, union arg *arg)
d568 1
a568 1
kbfunc_client_tile(struct client_ctx *cc, union arg *arg)
@


1.128
log
@client_ptrwarp should not deal with unhiding or raising clients (non ptr
requests); most callers do this already - deal with the few that do not.
client_ptrwarp becomes a simple wrapper (setpos) but it will be expanded.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.127 2016/09/22 14:36:03 okan Exp $
d98 1
a98 1
	int			 x, y;
d103 12
@


1.127
log
@Continue merging kb and mouse functions: fold
mousefunc_menu_{client,cmd,group} into the respective
kbfunc_menu_{client,cmd,group} functions; simply pass a flag down from
config denoting mouse action behaviour.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.126 2015/11/17 14:32:38 okan Exp $
d190 2
@


1.126
log
@If a client does not set increment values, use 'moveamount' as a way to
scale keyboard based resizes; extend kbfunc_amount().

Behaviour noted by, tested by, and ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.125 2015/11/12 21:28:03 okan Exp $
d170 1
d175 7
a181 2
	TAILQ_FOREACH(cc, &sc->clientq, entry)
		menuq_add(&menuq, cc, NULL);
d183 3
a185 1
	if ((mi = menu_filter(sc, &menuq, "window", NULL, 0,
d205 1
d216 7
a222 3
	if ((mi = menu_filter(sc, &menuq, "application", NULL, 0,
	    search_match_text, search_print_cmd)) != NULL)
		u_spawn(((struct cmd *)mi->ctx)->path);
d234 1
d243 2
a244 1
	if ((mi = menu_filter(sc, &menuq, "group", NULL, CWM_MENU_LIST,
@


1.125
log
@more client vs screen context differences
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.124 2015/11/12 18:33:30 okan Exp $
d41 1
a41 1
static void kbfunc_amount(int, unsigned int *, unsigned int *);
d57 1
a57 1
kbfunc_amount(int flags, unsigned int *mx, unsigned int *my)
a59 1
	int	amt;
a60 1
	amt = Conf.mamount;
d87 1
a87 1
	kbfunc_amount(arg->i, &mx, &my);
d104 1
a104 1
	kbfunc_amount(arg->i, &mx, &my);
d138 1
d143 4
a146 1
	kbfunc_amount(arg->i, &mx, &my);
@


1.124
log
@If a client sets hints, honor them for kb resize requests, just like we
do for mouse based resize requests.

Based on a patch from Vadim Vygonets.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.123 2015/11/12 18:26:41 okan Exp $
d453 1
a453 1
kbfunc_client_group(struct client_ctx *cc, union arg *arg)
d459 1
a459 1
kbfunc_client_grouponly(struct client_ctx *cc, union arg *arg)
d465 1
a465 1
kbfunc_client_cyclegroup(struct client_ctx *cc, union arg *arg)
d471 1
a471 1
kbfunc_client_nogroup(struct client_ctx *cc, union arg *arg)
@


1.123
log
@Move kb pointer movement out of the kbfunc_client_moveresize since it's
got nothing to do with clients, thus doing flags work causes lots of
waste and almost useless jumpy pointer movements; while here, split out
move and resize since they share almost no code, just like mouse client
move/resize; factor out amount and factor. Still wonder why this is
here, but it works now.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.122 2015/11/11 14:22:01 okan Exp $
d146 4
a149 4
	if ((cc->geom.w += mx) < 1)
		cc->geom.w = 1;
	if ((cc->geom.h += my) < 1)
		cc->geom.h = 1;
@


1.122
log
@Partial revert of replacing screen_area() with region_find(); until a
fix for a regression is found; this bug has been around for a long time
it seems, but this change exposed it. Likely need to track clients in to
and out of regions.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.121 2015/11/10 22:06:57 okan Exp $
d41 2
d56 2
a57 4
#define TYPEMASK	(CWM_MOVE | CWM_RESIZE | CWM_PTRMOVE)
#define MOVEMASK	(CWM_UP | CWM_DOWN | CWM_LEFT | CWM_RIGHT)
void
kbfunc_client_moveresize(struct client_ctx *cc, union arg *arg)
d59 2
a60 4
	struct screen_ctx	*sc = cc->sc;
	struct geom		 area;
	int			 x, y, flags, amt;
	unsigned int		 mx, my;
a61 6
	if (cc->flags & CLIENT_FREEZE)
		return;

	mx = my = 0;

	flags = arg->i;
d63 2
d66 1
a66 6
	if (flags & CWM_BIGMOVE) {
		flags -= CWM_BIGMOVE;
		amt = amt * 10;
	}

	switch (flags & MOVEMASK) {
d68 1
a68 1
		my -= amt;
d71 1
a71 1
		my += amt;
d74 1
a74 1
		mx += amt;
d77 1
a77 1
		mx -= amt;
d80 79
a158 51
	switch (flags & TYPEMASK) {
	case CWM_MOVE:
		cc->geom.x += mx;
		if (cc->geom.x + cc->geom.w < 0)
			cc->geom.x = -cc->geom.w;
		if (cc->geom.x > sc->view.w - 1)
			cc->geom.x = sc->view.w - 1;
		cc->geom.y += my;
		if (cc->geom.y + cc->geom.h < 0)
			cc->geom.y = -cc->geom.h;
		if (cc->geom.y > sc->view.h - 1)
			cc->geom.y = sc->view.h - 1;

		area = screen_area(sc,
		    cc->geom.x + cc->geom.w / 2,
		    cc->geom.y + cc->geom.h / 2, CWM_GAP);
		cc->geom.x += client_snapcalc(cc->geom.x,
		    cc->geom.x + cc->geom.w + (cc->bwidth * 2),
		    area.x, area.x + area.w, sc->snapdist);
		cc->geom.y += client_snapcalc(cc->geom.y,
		    cc->geom.y + cc->geom.h + (cc->bwidth * 2),
		    area.y, area.y + area.h, sc->snapdist);

		client_move(cc);
		xu_ptr_getpos(cc->win, &x, &y);
		cc->ptr.x = x + mx;
		cc->ptr.y = y + my;
		client_ptrwarp(cc);
		break;
	case CWM_RESIZE:
		if ((cc->geom.w += mx) < 1)
			cc->geom.w = 1;
		if ((cc->geom.h += my) < 1)
			cc->geom.h = 1;
		client_resize(cc, 1);

		/* Make sure the pointer stays within the window. */
		xu_ptr_getpos(cc->win, &cc->ptr.x, &cc->ptr.y);
		if (cc->ptr.x > cc->geom.w)
			cc->ptr.x = cc->geom.w - cc->bwidth;
		if (cc->ptr.y > cc->geom.h)
			cc->ptr.y = cc->geom.h - cc->bwidth;
		client_ptrwarp(cc);
		break;
	case CWM_PTRMOVE:
		xu_ptr_getpos(sc->rootwin, &x, &y);
		xu_ptr_setpos(sc->rootwin, x + mx, y + my);
		break;
	default:
		warnx("invalid flags passed to kbfunc_client_moveresize");
	}
@


1.121
log
@Use position on root to figure out region.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.120 2015/11/10 20:05:33 okan Exp $
d60 1
a60 1
	struct region_ctx	*rc;
d104 3
a106 2
		xu_ptr_getpos(cc->win, &x, &y);
		rc = region_find(sc, x + 1, y + 1);
d109 1
a109 1
		    rc->work.x, rc->work.x + rc->work.w, sc->snapdist);
d112 1
a112 1
		    rc->work.y, rc->work.y + rc->work.h, sc->snapdist);
@


1.120
log
@Start cleaning up name vs function differences; replace magic numbers.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.119 2015/11/09 20:03:29 okan Exp $
d104 2
a105 3
		rc = region_find(sc,
		    cc->geom.x + cc->geom.w / 2,
		    cc->geom.y + cc->geom.h / 2);
@


1.119
log
@Extend region to include both view and work areas; switch to
region_find() which no longer needs to recalculate gap each time
a client (or menu) is created or altered. If no RandR, fall back
to display dimensions while building regions instead of during
execution.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.118 2015/09/16 17:58:25 okan Exp $
d145 1
a145 1
kbfunc_client_search(struct client_ctx *cc, union arg *arg)
d233 1
a233 1
kbfunc_cmdexec(struct client_ctx *cc, union arg *arg)
d239 1
a239 1
kbfunc_term(struct client_ctx *cc, union arg *arg)
d250 1
a250 1
kbfunc_lock(struct client_ctx *cc, union arg *arg)
d261 1
a261 1
kbfunc_exec(struct client_ctx *cc, union arg *arg)
d275 1
a275 1
	case CWM_EXEC_PROGRAM:
d278 1
a278 1
	case CWM_EXEC_WM:
d282 1
a282 1
		errx(1, "kbfunc_exec: invalid cmd %d", cmd);
d324 1
a324 1
		case CWM_EXEC_PROGRAM:
d327 2
a328 2
		case CWM_EXEC_WM:
			cwm_status = CWM_EXECWM;
d344 1
a344 1
kbfunc_ssh(struct client_ctx *cc, union arg *arg)
d364 1
a364 1
		warn("kbfunc_ssh: %s", Conf.known_hosts);
d462 1
a462 1
	if (arg->i == 0) {
d520 1
a520 1
kbfunc_tile(struct client_ctx *cc, union arg *arg)
d523 1
a523 1
	case CWM_TILE_HORIZ:
d526 1
a526 1
	case CWM_TILE_VERT:
@


1.118
log
@On execwm, we should properly release resources before exec'ing into a
new window manager; so allow CWM_EXEC_WM to assign new wm to wm_argv and
pass through cwm_status (now EXECWM) so that x_teardown() gets called
before exec'ing the new window manager.  Removes the need for a separate
x_restart() now, using new wm_argv; and consolidates errno for execvp.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.117 2015/08/28 12:07:28 okan Exp $
d60 1
a60 1
	struct geom		 area;
d104 1
a104 1
		area = screen_area(sc,
d106 1
a106 1
		    cc->geom.y + cc->geom.h / 2, CWM_GAP);
d109 1
a109 1
		    area.x, area.x + area.w, sc->snapdist);
d112 1
a112 1
		    area.y, area.y + area.h, sc->snapdist);
@


1.117
log
@Lost fix from r1.112; add comment.

Reported (again!) by Peter Kane.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.116 2015/08/27 18:40:09 okan Exp $
d328 3
a330 2
			u_exec(mi->text);
			warn("%s", mi->text);
@


1.116
log
@Move client cycle grab/ungrab into a more relevant place; while here,
update comments about why we need to grab/ungrab the keyboard.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.115 2015/08/21 16:14:39 okan Exp $
d184 2
a185 1
		menuq_add(&menuq, cmd, NULL);
@


1.115
log
@_NET_WM_STATE_STICKY implies only sticky at the group/desktop level, not
position and size; based on discussion with a few.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.114 2015/08/21 16:05:55 okan Exp $
d222 1
a222 7
	struct screen_ctx	*sc = cc->sc;

	/* XXX for X apps that ignore events */
	XGrabKeyboard(X_Dpy, sc->rootwin, True,
	    GrabModeAsync, GrabModeAsync, CurrentTime);

	client_cycle(sc, arg->i);
d461 1
a461 1
		/* XXX for stupid X apps like xpdf and gvim */
@


1.114
log
@Instead of special casing the 'term' and 'lock' commands, go back to
keeping them hidden; showing them has apparently caused confusion/angst.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.113 2015/07/12 14:31:47 okan Exp $
d64 1
a64 1
	if (cc->flags & (CLIENT_FREEZE|CLIENT_STICKY))
@


1.113
log
@introduce 'groupsearch' for group menu search; matches on either group
number/shortcut and/or name.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.112 2015/07/03 17:11:16 okan Exp $
d180 6
a185 2
	TAILQ_FOREACH(cmd, &Conf.cmdq, entry)
		menuq_add(&menuq, cmd, "%s", cmd->name);
@


1.112
log
@revert previous; seems search_match_text() needs mi->text pre-populated.
(only used in one place, application menu searching); re-visit later.

broken application menu searching reported by Peter Kane.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.111 2015/06/30 19:02:24 okan Exp $
d186 25
@


1.111
log
@no longer need to pass down format strings after introducing search_print_cmd
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.110 2015/06/30 18:54:12 okan Exp $
d181 1
a181 1
		menuq_add(&menuq, cmd, NULL);
@


1.110
log
@Introduce a callback for cmd menu printing, special-casing 'lock' and
'term'.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.109 2015/06/29 14:24:40 okan Exp $
d181 1
a181 1
		menuq_add(&menuq, cmd, "%s", cmd->name);
@


1.109
log
@Shuffle code in kbfunc_ssh so that a missing known_hosts file still
allows a (now blank) menu to appear, as opposed to nothing at all.

Behavior reported by Alex Greif.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.108 2015/06/26 17:17:46 okan Exp $
d184 1
a184 1
	    search_match_text, NULL)) != NULL)
@


1.108
log
@Mechanical change from xinerama to region backed areas.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.107 2015/06/08 15:43:13 okan Exp $
a331 5
	if ((fp = fopen(Conf.known_hosts, "r")) == NULL) {
		warn("kbfunc_ssh: %s", Conf.known_hosts);
		return;
	}

d336 1
d338 4
a341 1
	TAILQ_INIT(&menuq);
d368 1
a368 1

@


1.107
log
@just populating the ctx is enough since the menu uses a callback and ignores anything else
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.106 2015/05/21 00:37:04 okan Exp $
d60 1
a60 1
	struct geom		 xine;
d104 1
a104 1
		xine = screen_find_xinerama(sc,
d109 1
a109 1
		    xine.x, xine.x + xine.w, sc->snapdist);
d112 1
a112 1
		    xine.y, xine.y + xine.h, sc->snapdist);
@


1.106
log
@merge kbd and mouse grouptoggle
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.105 2015/01/19 14:54:16 okan Exp $
d156 1
a156 1
		menuq_add(&menuq, cc, "%s", cc->name);
@


1.105
log
@Switch to limits.h; replace MAXPATHLEN and MAXHOSTNAMELEN with PATH_MAX
and HOST_NAME_MAX+1, respectively.

ok doug@@
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.104 2014/09/27 19:04:32 okan Exp $
d438 5
a442 3
	/* XXX for stupid X apps like xpdf and gvim */
	XGrabKeyboard(X_Dpy, cc->win, True,
	    GrabModeAsync, GrabModeAsync, CurrentTime);
@


1.104
log
@these have nothing to do with 'sticky', but rather group membership; rename.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.103 2014/09/17 18:41:44 okan Exp $
d21 1
a21 1
#include <sys/param.h>
d27 1
d242 1
a242 1
	char			 tpath[MAXPATHLEN];
d327 2
a328 2
	char			 hostbuf[MAXHOSTNAMELEN];
	char			 path[MAXPATHLEN];
@


1.103
log
@these client actions are just toggles; less confusing with better names
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.102 2014/09/17 18:09:30 okan Exp $
d441 1
a441 1
	group_sticky_toggle_enter(cc);
@


1.102
log
@ewmh states _NET_WM_STATE_STICKY should not alter position
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.101 2014/09/11 16:06:26 okan Exp $
d451 1
a451 1
kbfunc_client_sticky(struct client_ctx *cc, union arg *arg)
d453 1
a453 1
	client_sticky(cc);
d457 1
a457 1
kbfunc_client_fullscreen(struct client_ctx *cc, union arg *arg)
d459 1
a459 1
	client_fullscreen(cc);
d463 1
a463 1
kbfunc_client_maximize(struct client_ctx *cc, union arg *arg)
d465 1
a465 1
	client_maximize(cc);
d469 1
a469 1
kbfunc_client_vmaximize(struct client_ctx *cc, union arg *arg)
d471 1
a471 1
	client_vmaximize(cc);
d475 1
a475 1
kbfunc_client_hmaximize(struct client_ctx *cc, union arg *arg)
d477 1
a477 1
	client_hmaximize(cc);
d481 1
a481 1
kbfunc_client_freeze(struct client_ctx *cc, union arg *arg)
d483 1
a483 1
	client_freeze(cc);
@


1.101
log
@Remove incorrect cast in kbfunc_exec. In kbfunc_ssh, reverse logic on
truncation check so it's obvious.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.100 2014/09/08 20:11:22 okan Exp $
d63 1
a63 1
	if (cc->flags & CLIENT_FREEZE)
@


1.100
log
@Remove duplicate client queue (mruq); instead, remove and take the
global Clientq and place it inside screen_ctx since every client belongs
to a screen, then use the same per screen clientq to track stacking
order (the sole reason for mruq).
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.99 2014/09/06 18:50:43 okan Exp $
d284 1
a284 2
			/* check for truncation etc */
			if (l == -1 || l >= (int)sizeof(tpath))
d375 3
a377 2
		if (l != -1 && l < sizeof(path))
			u_spawn(path);
@


1.99
log
@Few style nits; extend 'path' to MAXPATHLEN.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.98 2014/09/06 16:14:35 okan Exp $
d154 1
a154 1
	TAILQ_FOREACH(cc, &Clientq, entry)
@


1.98
log
@Move termpath and lockpath into cmdq; side effect is that 'lock' and
'term' now show up in the application menu.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.97 2014/09/01 18:17:32 okan Exp $
d218 1
a218 1
	TAILQ_FOREACH(cmd, &Conf.cmdq, entry)
d221 1
d229 1
a229 1
	TAILQ_FOREACH(cmd, &Conf.cmdq, entry)
d232 1
d322 1
a322 1
	struct cmd		*cmdq;
d328 1
a328 1
	char			 cmd[256];
d337 2
a338 2
	TAILQ_FOREACH(cmdq, &Conf.cmdq, entry)
		if (strcmp(cmdq->name, "term") == 0)
d340 1
d374 4
a377 4
		l = snprintf(cmd, sizeof(cmd), "%s -T '[ssh] %s' -e ssh %s",
		    cmdq->path, mi->text, mi->text);
		if (l != -1 && l < sizeof(cmd))
			u_spawn(cmd);
@


1.97
log
@add explicit paran and drop some empty lines bringing like functions closer
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.96 2014/08/25 12:49:19 okan Exp $
d216 5
a220 1
	u_spawn(Conf.termpath);
d226 5
a230 1
	u_spawn(Conf.lockpath);
d320 1
d335 4
d372 1
a372 1
		    Conf.termpath, mi->text, mi->text);
@


1.96
log
@Implement _NET_WM_STATE_STICKY, bound to CM-s by default; allows any
client to 'stick' to all desktops (ewmh speak) or groups - this
currently has the same affect as setting a client's group to 'nogroup',
with the exception that the client can also be in a group, so when
un-sticking, the client will go back to its original group/desktop.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.95 2014/01/30 15:41:11 okan Exp $
a161 1

@


1.95
log
@Move cwm_status around to avoid header fu, and remove extraneous signal
header from xevents.c; noticed by Christian Neukirchen.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.94 2014/01/29 22:30:00 okan Exp $
d433 6
@


1.94
log
@Minimize trivial differences between a few kb and mb functions.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.93 2014/01/23 16:51:28 okan Exp $
d37 2
@


1.93
log
@If no title is supplied, term uses only the basename for its title.
This is useless when searching for windows launched via the ssh command
menu; supply a more useful title: '[ssh] <hostname>'.

Idea from todd@@, ok todd@@
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.92 2014/01/22 22:41:09 okan Exp $
d170 1
a170 1
kbfunc_menu_search(struct client_ctx *cc, union arg *arg)
@


1.92
log
@zap whitespace
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.91 2014/01/22 21:48:27 okan Exp $
d357 2
a358 2
		l = snprintf(cmd, sizeof(cmd), "%s -e ssh %s", Conf.termpath,
		    mi->text);
@


1.91
log
@Somewhat streamline event loop/restart/quit handling; most notable
change allows a restart to trigger proper teardown first, even though
teardown is not (yet) complete.

After some discussion with oga@@nicotinebsd.org regarding a more
complicated version/idea.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.90 2014/01/21 15:42:45 okan Exp $
d239 9
a247 9
		case CWM_EXEC_PROGRAM:
			label = "exec";
			break;
		case CWM_EXEC_WM:
			label = "wm";
			break;
		default:
			errx(1, "kbfunc_exec: invalid cmd %d", cmd);
			/*NOTREACHED*/
d289 10
a298 10
			case CWM_EXEC_PROGRAM:
				u_spawn(mi->text);
				break;
			case CWM_EXEC_WM:
				u_exec(mi->text);
				warn("%s", mi->text);
				break;
			default:
				errx(1, "kb_func: egad, cmd changed value!");
				break;
d473 6
a478 6
		case CWM_TILE_HORIZ:
			client_htile(cc);
			break;
		case CWM_TILE_VERT:
			client_vtile(cc);
			break;
@


1.90
log
@Sprinkle a few more const; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.89 2014/01/20 23:18:47 okan Exp $
a37 3
extern char		**cwm_argv;
extern sig_atomic_t	xev_quit;

d464 1
a464 7
kbfunc_quit_wm(struct client_ctx *cc, union arg *arg)
{
	xev_quit = 1;
}

void
kbfunc_restart(struct client_ctx *cc, union arg *arg)
d466 1
a466 2
	(void)setsid();
	(void)execvp(cwm_argv[0], cwm_argv);
@


1.89
log
@Save the ptr position before lowering via kbd, so as to be able to cycle
back with the pointer in the right place; matches behaviour when
lowering via the mouse function.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.88 2014/01/20 21:34:32 okan Exp $
d232 1
a232 1
	char			**ap, *paths[NPATHS], *path, *pathcpy, *label;
d234 1
@


1.88
log
@constify and rename some confusing variables around cmdq.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.87 2014/01/20 18:58:03 okan Exp $
d44 1
@


1.87
log
@Add a function that adds an entry to a menuq, normalizing a common code
path; from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.86 2014/01/03 15:29:06 okan Exp $
d181 1
a181 1
		menuq_add(&menuq, cmd, "%s", cmd->label);
d185 1
a185 1
		u_spawn(((struct cmd *)mi->ctx)->image);
@


1.86
log
@use consistent types
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.85 2013/12/16 19:02:17 okan Exp $
d154 2
a155 7

	TAILQ_FOREACH(cc, &Clientq, entry) {
		mi = xcalloc(1, sizeof(*mi));
		(void)strlcpy(mi->text, cc->name, sizeof(mi->text));
		mi->ctx = cc;
		TAILQ_INSERT_TAIL(&menuq, mi, entry);
	}
d180 2
a181 7

	TAILQ_FOREACH(cmd, &Conf.cmdq, entry) {
		mi = xcalloc(1, sizeof(*mi));
		(void)strlcpy(mi->text, cmd->label, sizeof(mi->text));
		mi->ctx = cmd;
		TAILQ_INSERT_TAIL(&menuq, mi, entry);
	}
d277 2
a278 6
			if (access(tpath, X_OK) == 0) {
				mi = xcalloc(1, sizeof(*mi));
				(void)strlcpy(mi->text,
				    dp->d_name, sizeof(mi->text));
				TAILQ_INSERT_TAIL(&menuq, mi, entry);
			}
d349 1
a349 3
		mi = xcalloc(1, sizeof(*mi));
		(void)strlcpy(mi->text, hostbuf, sizeof(mi->text));
		TAILQ_INSERT_TAIL(&menuq, mi, entry);
@


1.85
log
@Implement support for EWMH's _NET_WM_STATE_FULLSCREEN hint.

Since we already have a form of 'maximize', we need to differentiate
between 'maximize' and the new 'fullscreen' mode.  The 'maximize' mode
will continue to honor gap but now *retains* the border, matching the
'vert/horz maximize' behaviour.  The new 'fullscreen' mode supports and
follows the _NET_WM_STATE_FULLSCREEN hint, allowing the client perform
additional window modifications; in this mode, cwm(1) will *ignore* gap,
remove borders and freeze(move/resize) the client.  Additionally,
'fullscreen' mode will remember various combinations of previous states.

* default keybinding changes: CM-f 'fullscreen', CM-m 'maximize' (re-map
  as desired).

Positive feedback from a few, testing and ok sthen@@
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.84 2013/12/13 22:39:13 okan Exp $
d61 1
a61 1
	u_int			 mx, my;
@


1.84
log
@Teach screen_find_xinerama() to apply gap only when told to do so;
adjust callers.  Needed for an upcoming feature.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.83 2013/12/13 21:51:56 okan Exp $
d448 6
@


1.83
log
@Instead of using work area, use the Xinerama area for snap calculations;
based on a patch from Thomas Adam with appropriate adjustments for gap.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.82 2013/12/12 21:50:50 okan Exp $
d105 1
a105 1
		    cc->geom.y + cc->geom.h / 2);
@


1.82
log
@Make sure we really take work area gap into account with snap calculations;
from Dominik Honnef via Christian Neukirchen.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.81 2013/11/27 18:34:34 okan Exp $
d59 1
d103 3
d108 1
a108 1
		    sc->work.x, sc->work.x + sc->work.w, sc->snapdist);
d111 1
a111 1
		    sc->work.y, sc->work.y + sc->work.h, sc->snapdist);
@


1.81
log
@like gap, make snapdist per screen
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.80 2013/10/17 13:59:10 okan Exp $
d104 1
a104 1
		    sc->work.x, sc->work.w, sc->snapdist);
d107 1
a107 1
		    sc->work.y, sc->work.h, sc->snapdist);
@


1.80
log
@a few err->errx since we don't have error messages here; from Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.79 2013/07/08 18:19:22 okan Exp $
d104 1
a104 1
		    sc->work.x, sc->work.w, Conf.snapdist);
d107 1
a107 1
		    sc->work.y, sc->work.h, Conf.snapdist);
@


1.79
log
@move kbfunc and mousefunc closer together
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.78 2013/05/11 22:03:17 okan Exp $
d253 1
a253 1
			err(1, "kbfunc_exec: invalid cmd %d", cmd);
d308 1
a308 1
				err(1, "kb_func: egad, cmd changed value!");
@


1.78
log
@swap x/y calculations in kbd move/resize to match those in the respective mouse functions
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.77 2013/04/08 13:02:31 okan Exp $
d56 1
a56 1
kbfunc_moveresize(struct client_ctx *cc, union arg *arg)
@


1.77
log
@consistency
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.76 2013/01/08 15:16:05 okan Exp $
d91 5
a101 6
		cc->geom.x += mx;
		if (cc->geom.x + cc->geom.w < 0)
			cc->geom.x = -cc->geom.w;
		if (cc->geom.x > sc->view.w - 1)
			cc->geom.x = sc->view.w - 1;

d111 1
a112 1
		cc->ptr.x = x + mx;
d116 2
a119 2
		if ((cc->geom.w += mx) < 1)
			cc->geom.w = 1;
@


1.76
log
@add per-group vert/horiz tiling support; introduces 2 new bind commands,
'vtile' and 'htile'; from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.75 2013/01/04 16:30:03 okan Exp $
d338 1
@


1.75
log
@rename {h,v}max functions for consistency; from Jan Stary
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.74 2013/01/02 21:41:14 okan Exp $
d481 13
@


1.74
log
@pass the screen workarea, as opposed to viewarea, allowing client
snapping to honor gap.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.73 2013/01/02 21:37:21 okan Exp $
d455 1
a455 1
	client_vertmaximize(cc);
d461 1
a461 1
	client_horizmaximize(cc);
@


1.73
log
@re-work client_snapcalc() so it takes client and edge dimensions with
snapdist; allows for simplier snap calculations.

required for an upcoming diff for honoring gap.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.72 2013/01/01 14:19:56 okan Exp $
d105 1
a105 1
		    sc->view.x, sc->view.w, Conf.snapdist);
d108 1
a108 1
		    sc->view.y, sc->view.h, Conf.snapdist);
@


1.72
log
@make num of groups no longer off-by-one; from Alexander Polakov

note that a re-exec of cwm will not rewrite the group number atom of
*existing* clients, so they will remain off-by-one until each client has
its atom updated, or of course a restart of X.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.71 2012/12/17 23:54:57 okan Exp $
d104 2
a105 2
		    cc->geom.w, sc->view.w,
		    cc->bwidth, Conf.snapdist);
d107 2
a108 2
		    cc->geom.h, sc->view.h,
		    cc->bwidth, Conf.snapdist);
@


1.71
log
@put a default known_hosts into conf
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.70 2012/12/17 23:03:41 okan Exp $
d409 1
a409 1
	group_hidetoggle(cc->sc, KBTOGROUP(arg->i));
d415 1
a415 1
	group_only(cc->sc, KBTOGROUP(arg->i));
d443 1
a443 1
	group_movetogroup(cc, KBTOGROUP(arg->i));
@


1.70
log
@pull user home directory via getenv or getpwuid and stash it so we don't
need to do this everytime; with Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.69 2012/12/17 14:32:39 okan Exp $
a35 1
#define KNOWN_HOSTS	".ssh/known_hosts"
d327 1
a327 1
	char			 hostbuf[MAXHOSTNAMELEN], filename[MAXPATHLEN];
d332 2
a333 5
	l = snprintf(filename, sizeof(filename), "%s/%s", homedir, KNOWN_HOSTS);
	if (l == -1 || l >= sizeof(filename))
		return;

	if ((fp = fopen(filename, "r")) == NULL)
d335 1
@


1.69
log
@create and use menuq_clear() helper; from Tiago Cunha
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.68 2012/11/09 03:52:02 okan Exp $
d327 1
a327 1
	char			*buf, *lbuf, *p, *home;
d333 1
a333 4
	if ((home = getenv("HOME")) == NULL)
		return;

	l = snprintf(filename, sizeof(filename), "%s/%s", home, KNOWN_HOSTS);
@


1.68
log
@sort
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.67 2012/11/07 20:34:39 okan Exp $
d171 1
a171 4
	while ((mi = TAILQ_FIRST(&menuq)) != NULL) {
		TAILQ_REMOVE(&menuq, mi, entry);
		free(mi);
	}
d195 1
a195 4
	while ((mi = TAILQ_FIRST(&menuq)) != NULL) {
		TAILQ_REMOVE(&menuq, mi, entry);
		free(mi);
	}
d317 1
a317 4
	while ((mi = TAILQ_FIRST(&menuq)) != NULL) {
		TAILQ_REMOVE(&menuq, mi, entry);
		free(mi);
	}
d384 1
a384 4
	while ((mi = TAILQ_FIRST(&menuq)) != NULL) {
		TAILQ_REMOVE(&menuq, mi, entry);
		free(mi);
	}
@


1.67
log
@get rid of the xfree() wrapper around free(); from Tiago Cunha.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.66 2012/11/07 14:49:46 okan Exp $
d29 1
a31 1
#include <stdio.h>
@


1.66
log
@missing headers; from Thordur Bjornsson.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.65 2012/11/07 14:39:44 okan Exp $
d173 1
a173 1
		xfree(mi);
d200 1
a200 1
		xfree(mi);
d300 1
a300 1
	xfree(path);
d322 1
a322 1
		xfree(mi);
d325 1
a325 1
		xfree(mi);
d378 1
a378 1
	xfree(lbuf);
d392 1
a392 1
		xfree(mi);
d395 1
a395 1
		xfree(mi);
d412 1
a412 2
		if (cc->label != NULL)
			xfree(cc->label);
d415 1
a415 1
	xfree(mi);
@


1.65
log
@tab completion support for menus; from Alexander Polakov.

ok sthen@@ on an older incarnation
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.64 2012/10/31 19:30:19 okan Exp $
d28 1
@


1.64
log
@replace 'reload' with 'restart', which merely re-exec's cwm using the
existing argv; same idea with respect to argv saving as Alexander
Polakov.  reload support was half-complete and is getting in the way.

agreed to by many
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.63 2012/09/09 19:47:47 okan Exp $
d301 3
a303 2
	if ((mi = menu_filter(sc, &menuq, label, NULL, 1,
	    search_match_exec, NULL)) != NULL) {
d380 1
a380 1
	if ((mi = menu_filter(sc, &menuq, "ssh", NULL, 1,
d407 1
a407 1
	mi = menu_filter(cc->sc, &menuq, "label", cc->label, 1,
@


1.63
log
@extend client_resize so that it can know when to reset max flags and
bwidth; this allows a client to be resized from a max state, which now
gets treated like a non-max'd client.  based on a diff that does part of
this in a different way from Alexander Polakov.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.62 2012/07/13 17:01:04 okan Exp $
d38 1
d494 1
a494 1
kbfunc_reload(struct client_ctx *cc, union arg *arg)
d496 2
a497 1
	conf_reload(&Conf);
@


1.62
log
@re-use geom struct in client_ctx (saved)geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.61 2012/07/13 15:21:35 okan Exp $
d120 1
a120 1
		client_resize(cc);
@


1.61
log
@convert xmax/ymax uses to view geometry.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.60 2012/07/04 23:42:03 okan Exp $
d91 2
a92 2
		if (cc->geom.y + cc->geom.height < 0)
			cc->geom.y = -cc->geom.height;
d97 2
a98 2
		if (cc->geom.x + cc->geom.width < 0)
			cc->geom.x = -cc->geom.width;
d103 1
a103 1
		    cc->geom.width, sc->view.w,
d106 1
a106 1
		    cc->geom.height, sc->view.h,
d116 4
a119 4
		if ((cc->geom.height += my) < 1)
			cc->geom.height = 1;
		if ((cc->geom.width += mx) < 1)
			cc->geom.width = 1;
d124 4
a127 4
		if (cc->ptr.x > cc->geom.width)
			cc->ptr.x = cc->geom.width - cc->bwidth;
		if (cc->ptr.y > cc->geom.height)
			cc->ptr.y = cc->geom.height - cc->bwidth;
@


1.60
log
@assign and use screen ctx where appropriate and consistently.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.59 2012/07/04 18:07:12 okan Exp $
d93 2
a94 2
		if (cc->geom.y > sc->ymax - 1)
			cc->geom.y = sc->ymax - 1;
d99 2
a100 2
		if (cc->geom.x > sc->xmax - 1)
			cc->geom.x = sc->xmax - 1;
d103 1
a103 1
		    cc->geom.width, sc->xmax,
d106 1
a106 1
		    cc->geom.height, sc->ymax,
@


1.59
log
@use the screen ctx since we already have it assigned.
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.58 2011/08/29 09:09:45 okan Exp $
d57 1
a57 1
	struct screen_ctx	*sc;
a63 1
	sc = cc->sc;
d142 1
a142 1
	struct screen_ctx	*sc;
a146 1
	sc = cc->sc;
d178 1
a178 1
	struct screen_ctx	*sc;
a182 1
	sc = cc->sc;
d205 1
a205 3
	struct screen_ctx	*sc;

	sc = cc->sc;
d242 1
a242 1
	struct screen_ctx	*sc;
a250 1
	sc = cc->sc;
d329 1
a329 1
	struct screen_ctx	*sc;
a337 2

	sc = cc->sc;
@


1.58
log
@restore mouse move via the keyboard, noticed by todd@@.  while the check
for cc was wrong due to the fact that cc->sc is always filled in during
the event, we don't even need it - just operate on the focused screen's
root window regardless.

ok todd@@ oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.57 2011/07/25 15:10:24 okan Exp $
d94 2
a95 2
		if (cc->geom.y > cc->sc->ymax - 1)
			cc->geom.y = cc->sc->ymax - 1;
d100 2
a101 2
		if (cc->geom.x > cc->sc->xmax - 1)
			cc->geom.x = cc->sc->xmax - 1;
d104 1
a104 1
		    cc->geom.width, cc->sc->xmax,
d107 1
a107 1
		    cc->geom.height, cc->sc->ymax,
@


1.57
log
@We are inconsistent when it comes to function returns, so just go all
the way with the cwm specific parts.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.56 2011/07/23 13:09:11 okan Exp $
d132 2
a133 7
		if (cc) {
			xu_ptr_getpos(cc->win, &x, &y);
			xu_ptr_setpos(cc->win, x + mx, y + my);
		} else {
			xu_ptr_getpos(sc->rootwin, &x, &y);
			xu_ptr_setpos(sc->rootwin, x + mx, y + my);
		}
@


1.56
log
@Clarify defines and make them not look like non-local ones; started by a
small diff from Thomas Pfaff.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.55 2011/06/24 06:06:24 okan Exp $
d160 1
a160 1
		strlcpy(mi->text, cc->name, sizeof(mi->text));
d195 1
a195 1
		strlcpy(mi->text, cmd->label, sizeof(mi->text));
d294 1
a294 1
			memset(tpath, '\0', sizeof(tpath));
d302 2
a303 1
				strlcpy(mi->text, dp->d_name, sizeof(mi->text));
d370 1
a370 1
			memcpy(lbuf, buf, len);
d383 1
a383 1
		(void) strlcpy(hostbuf, buf, p - buf + 1);
d385 1
a385 1
		(void) strlcpy(mi->text, hostbuf, sizeof(mi->text));
d389 1
a389 1
	fclose(fp);
@


1.55
log
@introduce a new config option to snap to the screen edge.  'snapdist'
keyword taken from a diff from Sviatoslav Chagaev to do the same thing,
but implemented in a completely way (based on some very old code from
mk@@).  default set to 0, so no behavior change.

ok oga@@ (who would also like to take it further...)
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.54 2011/06/24 05:33:41 okan Exp $
d52 2
a53 2
#define typemask	(CWM_MOVE | CWM_RESIZE | CWM_PTRMOVE)
#define movemask	(CWM_UP | CWM_DOWN | CWM_LEFT | CWM_RIGHT)
d75 1
a75 1
	switch (flags & movemask) {
d89 1
a89 1
	switch (flags & typemask) {
@


1.54
log
@Correct extern declaration and while here, rename a variable to be
pedantic.

from Thomas Pfaff.

ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.53 2011/05/11 13:53:51 okan Exp $
d102 7
@


1.53
log
@tag and comment cleanup; ok oga@@
@
text
@d18 1
a18 1
 * $OpenBSD: kbfunc.c,v 1.52 2011/05/07 17:15:37 okan Exp $
d38 1
a38 1
extern int		_xev_quit;
d494 1
a494 1
	_xev_quit = 1;
@


1.52
log
@introduce a new 'freeze' flag (CMS-f by default) which may be applied to
any window, after which all move/resize requests will be ignored,
essentially freezing the window in place.

there's a possibility to merge this with the 'ignore' concept, pending
on how ignore+freeze should behave (really more ewmh stuff), but punting
for now since ponies are on the line.

requested and tested by thib at k2k11 with ponies, unicorns and rainbows.

'save the unicorns' todd@@, ok oga@@
@
text
@d2 1
a2 1
 *  calmwm - the calm window manager
d4 1
a4 1
 *  Copyright (c) 2004 Martin Murray <mmurray@@monkey.org>
d18 1
a18 1
 * $Id: kbfunc.c,v 1.51 2010/02/10 01:23:05 okan Exp $
@


1.51
log
@preserve labels after an edit action is aborted; extending the menu
struct just for this is the least intrusive approach until the menu code
is reviewed.

inspired by Thomas Pfaff's report on tech@@

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.50 2009/12/15 04:10:42 okan Exp $
d61 3
d483 6
@


1.50
log
@pull all non-X11 headers from calmwm.h and place them only where they
are required.

encourged to go all the way by oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.49 2009/12/15 03:34:34 okan Exp $
a402 1
	char		*current;
d406 3
a408 1
	current = cc->label;
d410 1
a410 2
	if ((mi = menu_filter(cc->sc, &menuq, "label", current, 1,
	    search_match_text, NULL)) != NULL) {
a413 1
		xfree(mi);
d415 1
@


1.49
log
@pull these headers only into files that need them.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.48 2009/12/15 03:24:36 okan Exp $
d21 3
d25 2
d28 4
@


1.48
log
@merge the 2 common header files; specific includes to be pulled out as
separate commits.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.47 2009/12/10 17:16:51 oga Exp $
d21 1
@


1.47
log
@finish unfucking the screen_ctx handling.

remove screen_current() it was utterly bogus when nscreens > 1.

pass a fake client_ctx in the case where there's no client and the
kbfunc or mousefunc doesn't need a real one, it just contains the
current screen, modify these functions so that they pass down the screen
context to their callees.

make groups per screen, it's the only way it makes sense in this regard.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.46 2009/12/07 19:45:36 okan Exp $
a22 1
#include "headers.h"
@


1.46
log
@we already have sc from the passed cc, so just used that instead.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.45 2009/12/07 19:44:31 okan Exp $
d129 1
d134 1
d146 1
a146 1
	if ((mi = menu_filter(&menuq, "window", NULL, 0,
d166 4
a169 3
	struct cmd	*cmd;
	struct menu	*mi;
	struct menu_q	 menuq;
d171 1
d181 1
a181 1
	if ((mi = menu_filter(&menuq, "application", NULL, 0,
d196 1
a196 1
	sc = screen_current();
d202 1
a202 1
	client_cycle(arg->i);
d233 8
a240 7
	char		**ap, *paths[NPATHS], *path, *pathcpy, *label;
	char		 tpath[MAXPATHLEN];
	int		 l, i;
	DIR		*dirp;
	struct dirent	*dp;
	struct menu	*mi;
	struct menu_q	 menuq;
d242 1
a242 1
	int cmd = arg->i;
d291 1
a291 1
	if ((mi = menu_filter(&menuq, label, NULL, 1,
d320 11
a330 8
	struct menu	*mi;
	struct menu_q	 menuq;
	FILE		*fp;
	char		*buf, *lbuf, *p, *home;
	char		 hostbuf[MAXHOSTNAMELEN], filename[MAXPATHLEN];
	char		 cmd[256];
	int		 l;
	size_t		 len;
d371 1
a371 1
	if ((mi = menu_filter(&menuq, "ssh", NULL, 1,
d400 1
a400 1
	if ((mi = menu_filter(&menuq, "label", current, 1,
d418 1
a418 1
	group_hidetoggle(KBTOGROUP(arg->i));
d424 1
a424 1
	group_only(KBTOGROUP(arg->i));
d430 1
a430 1
	group_cycle(arg->i);
d436 1
a436 1
	group_alltoggle();
@


1.45
log
@be consistent

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.44 2009/11/28 17:52:12 tobias Exp $
d52 1
a52 1
	sc = screen_current();
@


1.44
log
@style (whitespaces)

ok oga, okan
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.43 2009/09/05 16:06:15 okan Exp $
d127 1
a127 1
kbfunc_client_search(struct client_ctx *scratch, union arg *arg)
d129 1
a129 1
	struct client_ctx	*cc, *old_cc;
d162 1
a162 1
kbfunc_menu_search(struct client_ctx *scratch, union arg *arg)
d188 1
a188 1
kbfunc_client_cycle(struct client_ctx *scratch, union arg *arg)
d226 1
a226 1
kbfunc_exec(struct client_ctx *scratch, union arg *arg)
d313 1
a313 1
kbfunc_ssh(struct client_ctx *scratch, union arg *arg)
@


1.43
log
@re-introduce the intention of the change from rev 1.4 in menu.c here
instead, by moving the check for '\0' to only the places that it
matters.  hint and 50% of the diff from oga@@, prodded by todd@@

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.42 2009/08/25 02:02:59 okan Exp $
d389 1
a389 1
	
@


1.42
log
@we are not doing access control here, so replace the "check if file is
executable" goo with access(2).

originally from jacekm@@ long time ago.

"i can live with that" oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.41 2009/08/24 23:54:41 oga Exp $
d288 2
d303 1
a303 1

d365 2
d372 1
a372 1

@


1.41
log
@Add a keybinding to allow horizontal maximisation of a window (CMS-enter).

based on a diff by Thomas Pfaff; thanks!

ok okan@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.40 2009/06/20 00:55:42 okan Exp $
d231 1
a231 3
	int		 l, i, j, ngroups;
	gid_t		 mygroups[NGROUPS_MAX];
	uid_t		 ruid, euid, suid;
a235 1
	struct stat	 sb;
a249 5
	if (getgroups(0, mygroups) == -1)
		err(1, "getgroups failure");
	if ((ngroups = getresuid(&ruid, &euid, &suid)) == -1)
		err(1, "getresuid failure");

d276 4
a279 9
			/* just ignore on stat failure */
			if (stat(tpath, &sb) == -1)
				continue;
			/* may we execute this file? */
			if (euid == sb.st_uid) {
					if (sb.st_mode & S_IXUSR)
						goto executable;
					else
						continue;
a280 16
			for (j = 0; j < ngroups; j++) {
				if (mygroups[j] == sb.st_gid) {
					if (sb.st_mode & S_IXGRP)
						goto executable;
					else
						continue;
				}
			}
			if (sb.st_mode & S_IXOTH)
				goto executable;
			continue;
		executable:
			/* the thing in tpath, we may execute */
			mi = xcalloc(1, sizeof(*mi));
			strlcpy(mi->text, dp->d_name, sizeof(mi->text));
			TAILQ_INSERT_TAIL(&menuq, mi, entry);
@


1.40
log
@compact a bit by condensing a few if-else's; from Thomas Pfaff

"go on then" oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.39 2009/06/20 00:22:39 okan Exp $
d482 6
@


1.39
log
@unroll XCALLOC/XMALLOC macros; since we use xcalloc/xmalloc all over the
place anyway, this makes things a bit more consistent; from Thomas Pfaff

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.38 2009/05/17 17:04:59 sthen Exp $
d415 1
a415 4
	if (cc->label != NULL)
		current = cc->label;
	else
		current = NULL;
@


1.38
log
@add a "movetogroup" function, which hides the current window from
display and moves it to another group. useful with the recently added
"grouponly" function, giving the ability to use groups as simple
virtual desktops (similar to e.g. xmonad, dwm and scrotwm).

this doesn't have default keyboard bindings; cwmrc(5) now shows how
you could use these functions (use M-1...9 for grouponly1...9 and
MS-1...9 for movetogroup1...9 to emulate the default dwm bindings).

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.37 2009/05/14 16:24:04 oga Exp $
d138 1
a138 1
		XCALLOC(mi, struct menu);
d171 1
a171 1
		XCALLOC(mi, struct menu);
d307 1
a307 1
			XCALLOC(mi, struct menu);
d383 1
a383 1
		XCALLOC(mi, struct menu);
@


1.37
log
@Add a new command (currently no default keybindings for it), grouponly[1-9].

This works like the group select binding, but hides all other groups.

So, the people who've been complaining that they don't get "virtual
desktops" in cwm may want to try this out in cwmrc (from memory, untested):

---

#cwmrc

# add new windows to the current group
set sticky

# automatically sticky windows. xclock for now.
# to make more windows sticky use group_toggle to unset their group
autogroup 0 xclock

# make the group selection keys hide other groups, emulate virtual desktops
bind CM-1 grouponly1
bind CM-2 grouponly2
bind CM-3 grouponly3
bind CM-4 grouponly4
bind CM-5 grouponly5
bind CM-6 grouponly6
bind CM-7 grouponly7
bind CM-8 grouponly8
bind CM-9 grouponly9

---

mostly by sthen, tweaks from me.

ok todd@@, "if it works i'm ok with it" okan@@, ok sthen@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.36 2009/02/07 21:07:00 martynas Exp $
d467 6
@


1.36
log
@add 'moveamount' to cwmrc;  it sets keyboard movement amount, making
it more useful on large screens
manpage tweak & ok jmc@@
ok okan@@, oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.35 2009/02/03 22:20:31 martynas Exp $
d439 6
@


1.35
log
@fix off-by-one in geom.[xy], after pwin changes.  keyboard movement
to the rightmost or bottommost corners would confuse cwm:
- there's no way to get the window back
- tab cycling breaks
ok okan@@, oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.34 2009/01/23 18:58:40 oga Exp $
a27 1
#define MOVE_AMOUNT	1
d56 1
a56 1
	amt = MOVE_AMOUNT;
@


1.34
log
@Move the keybinding argument to a union to prevent warnings where
sizeof(int) != sizeof(void *). This has been annoying me for ages.

ok okan@@, todd@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.33 2009/01/16 15:24:14 okan Exp $
d83 2
a84 2
		if (cc->geom.y > cc->sc->ymax)
			cc->geom.y = cc->sc->ymax;
d89 2
a90 2
		if (cc->geom.x > cc->sc->xmax)
			cc->geom.x = cc->sc->xmax;
@


1.33
log
@remove pwin, bringing us to one client, one window.  we no longer have
to push attributes around, so things get a lot simplier, while fixing a
few issues in the meantime; original suggestion by Edd Barrett many many
moons ago.

annoying window placement and race, found in c2k8 by todd, fix by oga!

lots of feedback from todd and oga - thanks!

"commit that bad boy" oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.32 2008/07/11 15:18:29 okan Exp $
d33 1
a33 1
kbfunc_client_lower(struct client_ctx *cc, void *arg)
d39 1
a39 1
kbfunc_client_raise(struct client_ctx *cc, void *arg)
d47 1
a47 1
kbfunc_moveresize(struct client_ctx *cc, void *arg)
d56 1
a56 1
	flags = (int)arg;
d128 1
a128 1
kbfunc_client_search(struct client_ctx *scratch, void *arg)
d163 1
a163 1
kbfunc_menu_search(struct client_ctx *scratch, void *arg)
d189 1
a189 1
kbfunc_client_cycle(struct client_ctx *scratch, void *arg)
d199 1
a199 1
	client_cycle((int)arg);
d203 1
a203 1
kbfunc_client_hide(struct client_ctx *cc, void *arg)
d209 1
a209 1
kbfunc_cmdexec(struct client_ctx *cc, void *arg)
d211 1
a211 1
	u_spawn((char *)arg);
d215 1
a215 1
kbfunc_term(struct client_ctx *cc, void *arg)
d221 1
a221 1
kbfunc_lock(struct client_ctx *cc, void *arg)
d227 1
a227 1
kbfunc_exec(struct client_ctx *scratch, void *arg)
d241 1
a241 1
	int cmd = (int)arg;
d341 1
a341 1
kbfunc_ssh(struct client_ctx *scratch, void *arg)
d408 1
a408 1
kbfunc_client_label(struct client_ctx *cc, void *arg)
d431 1
a431 1
kbfunc_client_delete(struct client_ctx *cc, void *arg)
d437 1
a437 1
kbfunc_client_group(struct client_ctx *cc, void *arg)
d439 1
a439 1
	group_hidetoggle(KBTOGROUP((int)arg));
d443 1
a443 1
kbfunc_client_cyclegroup(struct client_ctx *cc, void *arg)
d445 1
a445 1
	group_cycle((int)arg);
d449 1
a449 1
kbfunc_client_nogroup(struct client_ctx *cc, void *arg)
d455 1
a455 1
kbfunc_client_grouptoggle(struct client_ctx *cc, void *arg)
d465 1
a465 1
kbfunc_client_maximize(struct client_ctx *cc, void *arg)
d471 1
a471 1
kbfunc_client_vmaximize(struct client_ctx *cc, void *arg)
d477 1
a477 1
kbfunc_quit_wm(struct client_ctx *cc, void *arg)
d483 1
a483 1
kbfunc_reload(struct client_ctx *cc, void *arg)
@


1.32
log
@no more hidden (and mysterious) config reloads and allow binding a key
to a config reload; CMS-r by default.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.31 2008/07/11 14:21:28 okan Exp $
d93 1
a93 1
		xu_ptr_getpos(cc->pwin, &x, &y);
d106 1
a106 1
		xu_ptr_getpos(cc->pwin, &cc->ptr.x, &cc->ptr.y);
d115 2
a116 2
			xu_ptr_getpos(cc->pwin, &x, &y);
			xu_ptr_setpos(cc->pwin, x + mx, y + my);
d458 1
a458 1
	XGrabKeyboard(X_Dpy, cc->pwin, True,
@


1.31
log
@spacing, declaration lineup to be consistent throughout cwm,
readability, and a bit of knf.

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.30 2008/06/25 00:52:47 oga Exp $
a170 1
	conf_reload(&Conf);
a216 1
	conf_reload(&Conf);
a222 1
	conf_reload(&Conf);
a392 1
		conf_reload(&Conf);
d480 6
@


1.30
log
@Stop keyboard move moving the window utterly off the screen. If that
happens there's no way to get it back.  Also, stop resize making a
windows size negative or zero. X does not like that one bit.

Diff from Martynas. Ok okan@@.
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.29 2008/06/12 18:32:06 okan Exp $
d49 1
a49 1
	struct screen_ctx	*sc = screen_current();
d53 1
a124 1

d130 2
d133 2
a134 2
	struct client_ctx	*cc, *old_cc = client_current();
	struct menu		*mi;
d165 2
a167 2
	struct menu	*mi;
	struct cmd	*cmd;
d192 3
a194 1
	struct screen_ctx	*sc = screen_current();
d233 10
a242 10
	char **ap, *paths[NPATHS], *path, *pathcpy, tpath[MAXPATHLEN];
	int l, i, j, ngroups;
	gid_t mygroups[NGROUPS_MAX];
	uid_t ruid, euid, suid;
	DIR *dirp;
	struct dirent *dp;
	struct stat sb;
	struct menu_q menuq;
	struct menu *mi;
	char *label;
d315 1
a315 1
		(void) closedir(dirp);
d346 8
a353 7
	struct menu_q menuq;
	struct menu *mi;
	FILE *fp;
	size_t len;
	char *buf, *lbuf, *p, *home;
	char hostbuf[MAXHOSTNAMELEN], filename[MAXPATHLEN], cmd[256];
	int l;
a393 1

d415 1
a416 1
	struct menu_q	 menuq;
@


1.29
log
@instead of forcing the ptr in the middle everytime, be more 'calm'; keep
the ptr still unless it moves out-of-bounds, then just follow the edge.

brought up by todd@@

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.28 2008/05/20 14:50:51 oga Exp $
d80 5
d86 5
d98 4
a101 2
		cc->geom.height += my;
		cc->geom.width += mx;
@


1.28
log
@Pull out the behaviour in grab_label and search_start into one utility
function menu_filter(). The plan is to eventually merge in grab_menu too.
Shrinks the code a fair bit.

Also, change XMaskEvent for XWindowEvent to prevent getting exposes for other
windows. This is particuarly noticable on slow machines with a LOT of xterms
(todd, you're an odd man).

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.27 2008/05/19 18:53:09 oga Exp $
d92 6
a97 6
		/*
		 * Moving the cursor while resizing is problematic. Just place
		 * it in the middle of the window.
		 */
		cc->ptr.x = -1;
		cc->ptr.y = -1;
@


1.27
log
@General cleanup.

ok okan@@.
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.26 2008/05/19 17:24:19 okan Exp $
d131 2
a132 3
	if ((mi = search_start(&menuq,
	    search_match_client, search_print_client,
	    "window", 0)) != NULL) {
d165 2
a166 2
	if ((mi = search_start(&menuq,
	    search_match_text, NULL, "application", 0)) != NULL)
d303 2
a304 2
	if ((mi = search_start(&menuq,
	    search_match_exec, NULL, label, 1)) != NULL) {
d378 2
a379 2
	if ((mi = search_start(&menuq,
	    search_match_exec, NULL, "ssh", 1)) != NULL) {
d398 18
a415 1
	grab_label(cc);
@


1.26
log
@client_cyclenext() -> client_cycle() since we now pass an arg.

removes a stray proto as well.

discussed with and ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.25 2008/05/19 17:11:19 okan Exp $
d49 3
a51 3
	struct screen_ctx *sc = screen_current();
	int x,y,flags,amt;
	u_int mx,my;
d60 1
a60 1
		amt = amt*10;
d118 3
a120 3
	struct menu_q menuq;
	struct client_ctx *cc, *old_cc = client_current();
	struct menu *mi;
d152 3
a154 3
	struct menu_q menuq;
	struct menu *mi;
	struct cmd *cmd;
@


1.25
log
@as done with cycle/rcycle, make prev/next group switching one kbfuncs
and use a flag; adjusted to match and rename to {r,}cycle.

"ok, since i came up with the same thing" oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.24 2008/05/19 15:17:50 oga Exp $
d185 1
a185 1
	client_cyclenext((int)arg);
@


1.24
log
@Use the XGrabKeyboard hack in for alt-tabbing as well. This stops the
mru getting the order messed up when gvim/xpdf et all steal key events.

While i'm here, change the logic in client_cyclenext() to use break instead
of goto, it's nicer that way.

Thirdly, instead of two different kbfuncs, just use the one and a flag.

"put your cycle diff in so I can pkg_delete gvim" okan@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.23 2008/05/19 12:56:58 okan Exp $
d415 1
a415 1
kbfunc_client_nextgroup(struct client_ctx *cc, void *arg)
d417 1
a417 7
	group_slide(1);
}

void
kbfunc_client_prevgroup(struct client_ctx *cc, void *arg)
{
	group_slide(0);
@


1.23
log
@finally implement keyboard binding for group toggling

idea for the
    "slightly-less-abhorrent-hack-but-a-hack-nonetheless-TM" from oga@@

grab and ungrab the keyboard to get around some silly X apps that like
stealing events

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.22 2008/04/16 13:47:29 oga Exp $
d179 5
a183 2
	client_cyclenext(0);
}
d185 1
a185 4
void
kbfunc_client_rcycle(struct client_ctx *scratch, void *arg)
{
	client_cyclenext(1);
@


1.22
log
@merge kbfunc_{ptrmove,client_{move,resize}} into one function that takes a flag,
this code was almost identical...

ok okan.
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.21 2008/04/15 21:20:56 oga Exp $
d430 10
@


1.21
log
@make the argument parser for commands accept quoted strings, while i'm
there make u_spawn use exec_wm (renamed to u_exec) for it's execution to
remove duplicated code.

This means constructs like this work in .cwmrc:

bind CM-t "ssh -Y 192.168.1.2 \"xterm -e top\""

or alternatively:

bind CM-t "ssh -Y 192.168.1.2 'xterm -e top'"

"in it goes" okan@@.
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.20 2008/04/15 20:24:41 oga Exp $
d44 2
d47 1
a47 1
kbfunc_client_move(struct client_ctx *cc, void *arg)
d49 1
d63 1
a63 1
	switch (flags) {
d77 31
a107 38

	cc->geom.y += my;
	cc->geom.x += mx;
	client_move(cc);
	xu_ptr_getpos(cc->pwin, &x, &y);
	cc->ptr.y = y + my;
	cc->ptr.x = x + mx;
	client_ptrwarp(cc);
}

void
kbfunc_client_resize(struct client_ctx *cc, void *arg)
{
	int flags,mx,my;
	u_int amt;

	mx = my = 0;

	flags = (int)arg;
	amt = MOVE_AMOUNT;

	if (flags & CWM_BIGMOVE) {
		flags -= CWM_BIGMOVE;
		amt = amt*10;
	}

	switch (flags) {
	case CWM_UP:
		my -= amt;
		break;
	case CWM_DOWN:
		my += amt;
		break;
	case CWM_RIGHT:
		mx += amt;
		break;
	case CWM_LEFT:
		mx -= amt;
d109 2
a112 49
	cc->geom.height += my;
	cc->geom.width += mx;
	client_resize(cc);

	/*
	 * Moving the cursor while resizing is problematic. Just place
	 * it in the middle of the window.
	 */
	cc->ptr.x = -1;
	cc->ptr.y = -1;
	client_ptrwarp(cc);
}

void
kbfunc_ptrmove(struct client_ctx *cc, void *arg)
{
	int px,py,mx,my,flags,amt;
	struct screen_ctx *sc = screen_current();
	my = mx = 0;

	flags = (int)arg;
	amt = MOVE_AMOUNT;

	if (flags & CWM_BIGMOVE) {
		flags -= CWM_BIGMOVE;
		amt = amt * 10;
	}
	switch (flags) {
	case CWM_UP:
		my -= amt;
		break;
	case CWM_DOWN:
		my += amt;
		break;
	case CWM_RIGHT:
		mx += amt;
		break;
	case CWM_LEFT:
		mx -= amt;
		break;
	}

	if (cc) {
		xu_ptr_getpos(cc->pwin, &px, &py);
		xu_ptr_setpos(cc->pwin, px + mx, py + my);
	} else {
		xu_ptr_getpos(sc->rootwin, &px, &py);
		xu_ptr_setpos(sc->rootwin, px + mx, py + my);
	}
@


1.20
log
@hit it with the knf stick.
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.19 2008/04/08 17:38:27 oga Exp $
d362 2
a363 1
				exec_wm(mi->text);
@


1.19
log
@No cookie for okan.

fix use-after-free that broke exec's path getting stuff.

``paths'' isn't used anymore, but pointers to within that array are still
used in the next loop. delay freeing it until after then.
@
text
@d3 1
a3 1
 * 
d18 1
a18 1
 * $Id: kbfunc.c,v 1.18 2008/04/07 23:47:09 simon Exp $
d26 3
a28 3
#define KNOWN_HOSTS ".ssh/known_hosts"
#define HASH_MARKER "|1|"
#define MOVE_AMOUNT 1
d30 1
a30 1
extern int _xev_quit;
d60 1
a60 1
	switch(flags) {
d64 1
a64 1
	case CWM_DOWN: 
d100 1
a100 1
	switch(flags) {
d104 1
a104 1
	case CWM_DOWN: 
d142 1
a142 1
	switch(flags) {
d146 1
a146 1
	case CWM_DOWN: 
d170 1
a170 1
	struct client_ctx *cc, *old_cc = client_current(); 
d172 1
a172 1
	
d174 1
a174 1
	
d183 2
a184 2
		    search_match_client, search_print_client,
		        "window", 0)) != NULL) {
d218 1
a218 1
		    search_match_text, NULL, "application", 0)) != NULL)
d281 1
a281 1
	switch(cmd) {
d356 1
a356 1
		    search_match_exec, NULL, label, 1)) != NULL) {
d430 1
a430 1
		    search_match_exec, NULL, "ssh", 1)) != NULL) {
@


1.18
log
@Add quit function, bind it per default to CM-q and change exec_wm
binding to CM-w.

Inital diff from Gleydson Soares
Feedback from oga@@ and okan@@

ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.17 2008/04/05 21:09:19 okan Exp $
a309 1
	xfree(path);
d353 1
@


1.17
log
@- use $PATH before _PATH_DEFPATH, from Tim van der Molen
- plug leak, noticed by oga

feedback and ok oga@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.16 2008/03/23 15:09:21 simon Exp $
d30 2
d492 6
@


1.16
log
@Replace the symlink configuration scheme with a simple yacc parser as
found in other places of the tree.  Remove sticky and font commandline
options and add another one for alternative config locations.
Split off cwmrc(5) from cwm(1), nuke #ifdef __OpenBSD__ while there.

tested by various kind people, feedback from oga@@ and okan@@ - thanks!
ok oga@@, jasper@@, okan@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.15 2008/03/22 15:09:45 oga Exp $
d267 1
a267 1
	char **ap, *paths[NPATHS], *path, tpath[MAXPATHLEN];
d297 5
a301 2
	/* just use default path until we have config to set this */
	path = xstrdup(_PATH_DEFPATH);
d303 1
a303 1
	    (*ap = strsep(&path, ":")) != NULL;) {
d308 1
a373 1
	xfree(path);
@


1.15
log
@Rip out, burn, and dance around the grave of group-edit mode.
I've yet to speak to anyone who uses it, so just kill it.

You can still add/remove from groups using the mouse binding.  Groups
may get a re-work sometime soon if i have a stroke of genius.

knocks about 4k off the i386 binary for me.

ok okan@@, todd@@.
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.14 2008/03/22 14:09:02 oga Exp $
d207 1
a207 1
	conf_cmd_refresh(&Conf);
d252 1
a252 1
	conf_cmd_refresh(&Conf);
d259 1
a259 1
	conf_cmd_refresh(&Conf);
d426 1
a426 1
		conf_cmd_refresh(&Conf);
@


1.14
log
@Remove a bunch of unused variables and incorrect comments.

"ok with me" okan@@.
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.13 2008/01/16 11:39:20 oga Exp $
d323 1
a323 1
			if (euid == sb.st_uid)
d328 3
a330 2
			for (j = 0; j < ngroups; j++)
				if (mygroups[j] == sb.st_gid)
d335 2
a453 9
kbfunc_client_groupselect(struct client_ctx *cc, void *arg)
{
	if (Groupmode)
		group_done();
	else
		group_enter();
}

void
d456 1
a456 4
	if (Groupmode)
		group_select(KBTOGROUP((int)arg));
	else
		group_hidetoggle(KBTOGROUP((int)arg));
d474 1
a474 4
	if (Groupmode)
		group_deletecurrent();
	else
		group_alltoggle();
@


1.13
log
@huge amount of cleanup and dead code removal.

full description of changes:
-remove fontlist, and all associated structures/calls, it's not needed.
 this also removes any doubt about leftover 9wm code (the list was
 borrowed from it). Since cwm now uses Xft for everything, the legacy
 font handling is just not needed.
-add /* FALLTHROUGH */ comments into grab_{label,menu}. I actually
 didn't intend grab_menu to be a fallthrough, but it actually works quite
 well there, so remove the extra rectangle drawing. I love it when that
 happens.
-remove a couple of unused prototypes that were obviously missed
 before.
-remove a bunch of commented out or if 0ed out code. It doesn't look to
 be coming back anytime soon.
-several functions returned an int, but this was never checked. most of
 them only failed if they failed to grab the pointer (thus the internal
 state didn't change), so just make them void and return early if this is
 the case.
-remove several unused functions and some useless variables.

knocks something like 200bytes off the stripped binary size for me.

ok marc@@, tested by several others.
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.12 2008/01/11 16:06:44 oga Exp $
d181 2
a182 2
		    search_match_client, NULL,
		    search_print_client, "window", 0)) != NULL) {
d216 1
a216 1
		    search_match_text, NULL, NULL, "application", 0)) != NULL)
d347 1
a347 1
		    search_match_exec, NULL, NULL, label, 1)) != NULL) {
d422 1
a422 1
		    search_match_exec, NULL, NULL, "ssh", 1)) != NULL) {
@


1.12
log
@- Remove the "all rights reserved" tag at the top of most of the source
  files, and replace them with the actual ISC license.

- add license to the manpage (it was lacking before)

- correct license statement in the README

Permission given by Marius (copyright holder):
"1. please replace with the standard ISC license
2. you may add the ISC license to the man page
3. feel free to replace the information in the README as well"

and Dros (copyright holder for group.c):
"Please switch group.c to the ISC License."

ok ian@@
@
text
@d18 1
a18 1
 * $Id: kbfunc.c,v 1.11 2007/11/28 16:35:52 ian Exp $
a173 1
		struct menu *mi;
@


1.11
log
@Add a "restart wm" function. ok oga@@
@
text
@a4 1
 *  All rights reserved.
d6 13
a18 1
 * $Id: kbfunc.c,v 1.10 2007/11/13 23:08:49 todd Exp $
@


1.10
log
@enable pointer movement in cwm via C-<arrowkeys>
looked over by oga@@
@
text
@d7 1
a7 1
 * $Id: kbfunc.c,v 1.9 2007/11/07 22:02:04 oga Exp $
d266 14
d337 13
a349 2
		    search_match_exec, NULL, NULL, "exec", 1)) != NULL)
		u_spawn(mi->text);
@


1.9
log
@Change MOVE_AMOUNT in kbfunc.c to 1 from 10. This allows more fine tuning when
moving and resizing windows using the keyboard.

Future diffs might make this value configurable.

ok jasper@@, todd@@.
@
text
@d7 1
a7 1
 * $Id: kbfunc.c,v 1.8 2007/11/07 21:58:03 oga Exp $
d113 38
@


1.8
log
@Add support to cwm for resizing the windows using Control-Meta-[hjkl].

Please note that this remaps Control-Meta-L (label) to Control-Meta-N (name).

ok jasper@@, todd@@.
@
text
@d7 1
a7 1
 * $Id: kbfunc.c,v 1.7 2007/09/06 06:01:14 jasper Exp $
d17 1
a17 1
#define MOVE_AMOUNT 10
@


1.7
log
@fix buffer overflow, as sizeof(paths) won't fit inside the array.

from Stefan Kempf

"looks right to me" matthieu@@
@
text
@d7 1
a7 1
 * $Id: kbfunc.c,v 1.6 2007/06/27 13:28:22 todd Exp $
d70 45
@


1.6
log
@implement keyboard initiated movement of windows
enhanced version of diff originally from niallo@@
man bits from niallo@@
ok niallo@@ japser@@
@
text
@d7 1
a7 1
 * $Id: kbfunc.c,v 1.5 2007/06/26 19:34:26 niallo Exp $
d173 2
a174 1
	char **ap, *paths[256], *path, tpath[MAXPATHLEN];
d192 1
a192 1
	for (ap = paths; ap < &paths[sizeof(paths) - 1] &&
d198 1
a198 1
	for (i = 0; i < sizeof(paths) && paths[i] != NULL; i++) {
@


1.5
log
@modify "exec" dialog so that it auto-completes based on executables in
_PATH_DEFPATH

add an "ssh-to" dialog which auto-completes based on contents of
 ~/.ssh/known_hosts (M-.)

testing and eyeballing by Simon Kuhnle <simonkuhnle at web.de>, todd@@, pedro@@
mk@@ and David Cathcart <david at cathcart.cx>

ok todd@@
@
text
@d7 1
a7 1
 * $Id: kbfunc.c,v 1.4 2007/06/05 19:03:20 jasper Exp $
d17 1
d31 39
@


1.4
log
@make it possible to cycle through the windows when non are selected.
(eg. when they're hidden, now you can cycle through them)

from aon@@iki.fi
@
text
@d7 1
a7 1
 * $Id: kbfunc.c,v 1.3 2007/05/28 18:34:27 jasper Exp $
d10 2
d15 3
d49 1
a49 1
		    search_print_client, "window")) != NULL) {
d83 1
a83 1
		    search_match_text, NULL, NULL, "application")) != NULL)
d133 144
a276 1
	grab_exec();
@


1.3
log
@convert globals from G_foo to Foo, as per TODO.

"looks good" pedro@@, ok matthieu@@
@
text
@d7 1
a7 1
 * $Id: kbfunc.c,v 1.2 2007/04/27 18:08:14 bernd Exp $
d88 1
a88 1
kbfunc_client_cycle(struct client_ctx *cc, void *arg)
d90 1
a90 1
	client_cyclenext(cc, 0);
d94 1
a94 1
kbfunc_client_rcycle(struct client_ctx *cc, void *arg)
d96 1
a96 1
	client_cyclenext(cc, 1);
@


1.2
log
@Apply cwm-3-exec.diff from http://aon.iki.fi/cwm/. Document the new
key binding.
@
text
@d7 1
a7 1
 * $Id: kbfunc.c,v 1.1.1.1 2007/04/27 17:58:48 bernd Exp $
d34 1
a34 1
	TAILQ_FOREACH(cc, &G_clientq, entry) {
d69 2
a70 2
	conf_cmd_refresh(&G_conf);
	TAILQ_FOREACH(cmd, &G_conf.cmdq, entry) {
d114 2
a115 2
	conf_cmd_refresh(&G_conf);
	u_spawn(G_conf.termpath);
d121 2
a122 2
	conf_cmd_refresh(&G_conf);
	u_spawn(G_conf.lockpath);
d146 1
a146 1
	if (G_groupmode)
d155 1
a155 1
	if (G_groupmode)
d176 1
a176 1
	if (G_groupmode)
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * $Id: kbfunc.c,v 1.9 2005/06/25 15:58:49 marius Exp $
d123 6
@


1.1.1.1
log
@Initial import of cwm-3.

tested by sturm@@, ok matthieu@@
@
text
@@
