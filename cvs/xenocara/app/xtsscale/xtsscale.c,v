head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.22
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.20
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.18
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.16
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.14
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.12
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.23.0.10
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.8
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.6
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.6
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.4
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_2:1.1.0.2
	OPENBSD_4_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2012.03.06.23.24.37;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2012.03.06.23.23.44;	author matthieu;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.16.17.54.07;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.16.17.32.24;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.16.17.27.52;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.16.17.21.41;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2011.06.28.08.18.49;	author jasper;	state Exp;
branches;
next	1.16;

1.16
date	2010.12.06.06.49.47;	author jasper;	state Exp;
branches;
next	1.15;

1.15
date	2010.03.23.20.27.42;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.22.07.47.54;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.26.18.13.47;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2009.11.26.14.25.05;	author sobrado;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.26.11.35.29;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.26.10.58.45;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.25.23.00.57;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.25.19.43.05;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.25.18.30.13;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.31.21.53.55;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.31.21.17.33;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.31.20.59.33;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.31.20.28.18;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.30.19.45.25;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.20.14.43.12;	author robert;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Remove unused variable.
@
text
@/*      $OpenBSD: xtsscale.c,v 1.22 2012/03/06 23:23:44 matthieu Exp $ */
/*
 * Copyright (c) 2007 Robert Nagy <robert@@openbsd.org>
 * Copyright (c) 2009,2011 Matthieu Herrb <matthieu@@herrb.eu>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE OPENBSD PROJECT AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENBSD
 * PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright 1996 by Frederic Lepied, France. <Frederic.Lepied@@sugix.frmug.org>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is  hereby granted without fee, provided that
 * the  above copyright   notice appear  in   all  copies and  that both  that
 * copyright  notice   and   this  permission   notice  appear  in  supporting
 * documentation, and that   the  name of  the authors  not  be  used  in
 * advertising or publicity pertaining to distribution of the software without
 * specific,  written      prior  permission.     The authors  make  no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * THE AUTHORS DISCLAIM ALL   WARRANTIES WITH REGARD  TO  THIS SOFTWARE,
 * INCLUDING ALL IMPLIED   WARRANTIES OF MERCHANTABILITY  AND   FITNESS, IN NO
 * EVENT  SHALL THE AUTHORS  BE   LIABLE   FOR ANY  SPECIAL, INDIRECT   OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA  OR PROFITS, WHETHER  IN  AN ACTION OF  CONTRACT,  NEGLIGENCE OR OTHER
 * TORTIOUS  ACTION, ARISING    OUT OF OR   IN  CONNECTION  WITH THE USE    OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */

#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xft/Xft.h>
#include <X11/extensions/Xrender.h>
#include <X11/extensions/XInput.h>

#include <X11/extensions/Xrandr.h>

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <math.h>

#include <ws-properties.h>

#define FONT_NAME		"mono"
#define FONT_SIZE		14

#define Background		"white"
#define TouchCross		"black"
#define PromptText		"black"
#define Error			"red"

#define INVALID_EVENT_TYPE	-1

static int           motion_type = INVALID_EVENT_TYPE;
static int           button_press_type = INVALID_EVENT_TYPE;
static int           button_release_type = INVALID_EVENT_TYPE;
static int           proximity_in_type = INVALID_EVENT_TYPE;
static int           proximity_out_type = INVALID_EVENT_TYPE;

int has_xrandr = False;
int has_xrandr_1_2 = False;
int has_xrandr_1_3 = False;
int has_xinerama = False;

Atom prop_calibration, prop_swap;

/* where the calibration points are placed */
#define SCREEN_DIVIDE	16
#define SCREEN_MAX	0x800
#define M_POINT		(SCREEN_MAX/SCREEN_DIVIDE)
int             MARK_POINT[] = {M_POINT, SCREEN_MAX - 1 - M_POINT};

int             touched = 0;
char           *deviceName;

Display        *display;
int             screen;
Window          root;
Window          win;
XftFont	       *font;
XftColor	cross, errorColor, promptColor, bg;
XftDraw	       *draw;
unsigned int    xpos, ypos, width, height;	/* window size */
Bool		interrupted = False;
Bool		verbose = False;

int    cx[5], cy[5];
int    x[5], y[5];

extern char * __progname;

struct { int minx, maxx, miny, maxy, swapxy, resx, resy; } calib, old_calib;
Bool old_swap;

static char    *prompt_message[] = {
	"TOUCH SCREEN CALIBRATION",
	"Press on the crosshairs please...",
	"Use the ESC key to cancel.",
	NULL
};

static char *error_message[] = {
	"Not accurate enough.",
	"Try again...",
	NULL
};

void
cleanup_exit(XDevice *device)
{
	long values[4];

	values[0] = old_calib.minx;
	values[1] = old_calib.maxx;
	values[2] = old_calib.miny;
	values[3] = old_calib.maxy;

	XChangeDeviceProperty(display, device, prop_calibration,
	    XA_INTEGER, 32, PropModeReplace, (unsigned char *)values, 4);

	XChangeDeviceProperty(display, device, prop_swap,
	    XA_INTEGER, 8, PropModeReplace, (unsigned char *)&old_swap, 1);

	XCloseDevice(display, device);
	XUngrabServer(display);
	XUngrabKeyboard(display, CurrentTime);
	XCloseDisplay(display);
	exit(1);
}

void
render_init(void)
{
	font = XftFontOpen(display, screen,
	    XFT_FAMILY, XftTypeString, FONT_NAME,
	    XFT_SIZE, XftTypeInteger, FONT_SIZE,
	    NULL);
	if (!XftColorAllocName(display, XDefaultVisual(display, screen),
		DefaultColormap(display, screen), TouchCross, &cross)) {
		fprintf(stderr, "Cannot get color");
		exit(2);
	}
	if (!XftColorAllocName(display, XDefaultVisual(display, screen),
		DefaultColormap(display, screen), PromptText, &promptColor)) {
		fprintf(stderr, "Cannot get color");
		exit(2);
	}
	if (!XftColorAllocName(display, XDefaultVisual(display, screen),
		DefaultColormap(display, screen), Background, &bg)) {
		fprintf(stderr, "Cannot get bg color");
		exit(2);
	}
	if (!XftColorAllocName(display, XDefaultVisual(display, screen),
		DefaultColormap(display, screen), Error, &errorColor)) {
		fprintf(stderr, "Cannot get color");
		exit(2);
	}
	draw = XftDrawCreate(display, win, DefaultVisual(display, screen),
	    DefaultColormap(display, screen));
}

void
draw_point(int x, int y, int width, int size, XftColor *color)
{
	XPointDouble p[4];

	p[0].x = x - size;
	p[0].y = y - 1;
	p[1].x = x - size;
	p[1].y = y + 1;
	p[2].x = x + size;
	p[2].y = y + 1;
	p[3].x = x + size;
	p[3].y = y - 1;

	XRenderCompositeDoublePoly(display, PictOpOver,
	    XftDrawSrcPicture(draw, color),
	    XftDrawPicture(draw),
	    XRenderFindStandardFormat(display, PictStandardA8),
	    0, 0, 0, 0, p, 4, 0);
	p[0].x = x - 1;
	p[0].y = y - size;
	p[1].x = x + 1;
	p[1].y = y - size;
	p[2].x = x + 1;
	p[2].y = y + size;
	p[3].x = x - 1;
	p[3].y = y + size;
	XRenderCompositeDoublePoly(display, PictOpOver,
	    XftDrawSrcPicture(draw, color),
	    XftDrawPicture(draw),
	    XRenderFindStandardFormat(display, PictStandardA8),
	    0, 0, 0, 0, p, 4, 0);
}

void
draw_text(char **message, XftColor *color)
{
	int	 	len;
	int             i, x, y;
	XGlyphInfo	extents;

	i = 0;
	y = height / 3;
	while (message[i] != NULL) {
		len = strlen(message[i]);
		XftTextExtents8(display, font, message[i], len, &extents);
		x = (width - extents.width)/2;
		XftDrawString8(draw, color, font, x, y, message[i], len);
		y += extents.height * 1.5;
		i++;
	}
}

void
draw_graphics(int i, int j, int n)
{

	draw_text(prompt_message, &promptColor);

	if (n == 2) {
		cx[n] = width / 2;
		cy[n] = height / 2;
	} else {
		cx[n] = (MARK_POINT[i] * width) / SCREEN_MAX;
		cy[n] = (MARK_POINT[j] * height) / SCREEN_MAX;
	}
	draw_point(cx[n], cy[n], width / 200, width / 64, &cross);
}

Cursor
create_empty_cursor(void)
{
	char            nothing[] = {0};
	XColor          nullcolor;
	Pixmap          src = XCreateBitmapFromData(display, root, nothing, 1, 1);
	Pixmap          msk = XCreateBitmapFromData(display, root, nothing, 1, 1);
	Cursor          mcyursor = XCreatePixmapCursor(display, src, msk,
					      &nullcolor, &nullcolor, 0, 0);
	XFreePixmap(display, src);
	XFreePixmap(display, msk);

	return mcyursor;
}

int
check_device(XDeviceInfo *info)
{
	XDevice *device;
	Atom type;
	int format;
	unsigned long nitems, nbytes;
	unsigned char *retval;

	if (verbose)
		printf("Checking device %lu: %s...", info->id, info->name);
	device = XOpenDevice(display, info->id);
	XGetDeviceProperty(display,
			   device, prop_calibration,
			   0, 4, False,
			   XA_INTEGER, &type, &format,
			   &nitems, &nbytes, &retval);
	XCloseDevice(display, device);
	if (nitems != 4) {
		if (verbose)
			printf("can't be calibrated\n");
		return False;
	}
	if (verbose)
		printf("can be calibrated\n");
	return True;
}

XDeviceInfo*
find_device_info(char *name)
{
	XDeviceInfo    *devices;
	XDeviceInfo    *found = NULL;
	int		i, max_id;
	int		num_devices, num_found;
	Bool		is_id = True;
	XID		id = (XID)-1;
	const char	       *errstr;

	devices = XListInputDevices(display, &num_devices);
	max_id = 0;
	for (i = 0; i < num_devices; i++)
		if (devices[i].id > max_id)
			max_id = devices[i].id;


	if (name != NULL) {
		for(i = 0; i < strlen(name); i++) {
			if (!isdigit(name[i])) {
				is_id = False;
				break;
			}
		}
		if (is_id) {
			id = strtonum(name, 0, max_id, &errstr);
			if (errstr != NULL) {
				fprintf(stderr, "Invalid device id %s: %s\n",
				    name, errstr);
				exit(1);
			}
		}
	}

	num_found = 0;
	for(i = 0; i < num_devices; i++) {
		if (devices[i].use != IsXExtensionPointer)
			continue;
		if (name == NULL) {
			if (check_device(&devices[i])) {
				found = &devices[i];
				num_found++;
			}
			continue;
		}
		if ((!is_id && strcmp(devices[i].name, name) == 0) ||
		    (is_id && devices[i].id == id)) {
			found = &devices[i];
			num_found++;
		}
	}
	if (num_found > 1) {
		fprintf(stderr,
		    "Error: found multiple matching devices.\n"
		    "To ensure the correct one is selected, please use "
		    "the device ID instead.\n");
		return NULL;
	}
	return found;
}

static int
register_events(XDeviceInfo *info, XDevice *device,
    Bool handle_proximity)
{
	int		 number = 0;	/* number of events registered */
	XEventClass	 event_list[7];
	int		 i;
	unsigned long	 screen;
	XInputClassInfo	*ip;

	screen = DefaultScreen(display);

	if (device->num_classes > 0) {
		for (ip = device->classes, i=0; i<info->num_classes;
		     ip++, i++) {
			switch (ip->input_class) {
			case ButtonClass:
				DeviceButtonPress(device, button_press_type,
				    event_list[number]);
				number++;
				DeviceButtonRelease(device,
				    button_release_type, event_list[number]);
				number++;
				break;

			case ValuatorClass:
				DeviceMotionNotify(device, motion_type,
				    event_list[number]); number++;
				if (handle_proximity) {
					ProximityIn(device, proximity_in_type,
					    event_list[number]); number++;
					ProximityOut(device,
					    proximity_out_type,
					    event_list[number]); number++;
				}
				break;

			default:
				fprintf(stderr,
				    "Found unknown device class %d\n",
				    ip->input_class);
				break;
			}
		}

		if (XSelectExtensionEvent(display, root, event_list, number)) {
			fprintf(stderr, "Error selecting extended events\n");
			return 0;
		}
	}
	return number;
}

static Bool
get_events(int i)
{
	XEvent Event;
	XDeviceMotionEvent *motion = (XDeviceMotionEvent *) &Event;
	int j, a;
	char c;

	x[i] = y[i] = -1;
	while (1) {
		XNextEvent(display, &Event);

		if (Event.type == motion_type) {
			for (j = 0; j < motion->axes_count; j++) {
				a = motion->first_axis + j;
				switch (a) {
				case 0:
					x[i] = motion->axis_data[j];
					break;
				case 1:
					y[i] = motion->axis_data[j];
					break;
				default:
					fprintf(stderr,
					    "Unknown axis %d\n", a);
				}
			}
		} else if (Event.type == button_release_type) {
			if (x[i] != -1 && y[i] != -1)
				break;
		} else if (Event.type == KeyPress) {
			a = XLookupString(&Event.xkey, &c, 1, NULL, NULL);
			if ((a == 1) && ((c == 'q') || (c == 'Q') ||
				(c == '\03') || (c == '\033'))) {
				interrupted++;
				return False;
			}
		}
	}
	if (verbose)
		printf("x[%d] = %d y[%d] = %d\n", i, x[i], i, y[i]);

	return True;
}

int
uncalibrate(XDevice *device)
{
	Atom type;
	int format;
	unsigned long nitems, nbytes;
	long values[4] = { 0, 32767, 0, 32767 }; /* uncalibrated */
	Bool swap = 0;
	unsigned char *retval;

	/* Save old values */
	XGetDeviceProperty(display, device, prop_calibration, 0,
	    4, False, XA_INTEGER, &type, &format, &nitems,
	    &nbytes, &retval);

	if (type != XA_INTEGER) {
		fprintf(stderr, "Device property \"%s\": invalid type %s\n",
		    WS_PROP_CALIBRATION, XGetAtomName(display, type));
		return -1;
	}
	if (nitems != 4 && nitems != 0) {
		fprintf(stderr, "Device property \"%s\": "
		    "invalid number of items %ld\n",
		    WS_PROP_CALIBRATION, nitems);
		return -1;
	}
	old_calib.minx = *(long *)retval;
	old_calib.maxx = *((long *)retval + 1);
	old_calib.miny = *((long *)retval + 2);
	old_calib.maxy = *((long *)retval + 3);

	XFree(retval);

	XGetDeviceProperty(display, device, prop_swap, 0,
	    1, False, XA_INTEGER, &type, &format, &nitems,
	    &nbytes, &retval);
	old_swap = *(Bool *)retval;
	XFree(retval);

	/* Force uncalibrated state */
	XChangeDeviceProperty(display, device, prop_calibration,
	    XA_INTEGER, 32, PropModeReplace, (unsigned char *)values, 4);
	XChangeDeviceProperty(display, device, prop_swap,
	    XA_INTEGER, 8, PropModeReplace, (unsigned char *)&swap, 1);

	return 0;
}

void
get_xrandr_config(Display *dpy, Window root, char *name,
    int *x, int *y, int *width, int *height)
{
	XRRScreenResources *res;
	XRROutputInfo *output_info;
	XRRCrtcInfo *crtc_info;
	int o, found = 0;

	res = XRRGetScreenResources(dpy, root);

	for (o = 0; o < res->noutput; o++) {
		output_info = XRRGetOutputInfo (dpy, res, res->outputs[o]);
		if (!output_info) {
			fprintf(stderr,
			    "could not get output 0x%lx information\n",
			    res->outputs[o]);
			exit(2);
		}
		if (output_info->crtc != 0) {
			crtc_info = XRRGetCrtcInfo(dpy, res,
			    output_info->crtc);
			if (!crtc_info) {
				fprintf(stderr,
				    "%s: could not get crtc 0x%lx "
				    "information\n", __progname,
				    output_info->crtc);
				exit(2);
			}
			printf("%s: %dx%d+%d+%d\n",
			    output_info->name,
			    crtc_info->width, crtc_info->height,
			    crtc_info->x, crtc_info->y);
			if (!strcmp(output_info->name, name)) {
				*x = crtc_info->x;
				*y = crtc_info->y;
				*width = crtc_info->width;
				*height = crtc_info->height;
				found = 1;
			}
		}
	}
	if (!found) {
		fprintf(stderr, "%s: output %s not found\n", __progname, name);
		exit(2);
	}
}

void __dead
usage(void)
{
	fprintf(stderr, "usage: xtsscale [-c][-D display]"
		"[-d device][-o output]\n");
	exit(2);
}

int
main(int argc, char *argv[], char *env[])
{
	char           *display_name = NULL;
	char	       *device_name = NULL;
	char	       *output_name = NULL;
	XSetWindowAttributes xswa;
	int             i = 0;
	double          a, a1, a2, b, b1, b2, xerr, yerr;
	int		xi_opcode, event, error;
	XExtensionVersion *version;
	XDeviceInfo	*info;
	XDevice		*device;
	long		 calib_data[4];
	unsigned long	 mask;
	unsigned char	 swap;
	int 		 keep_cursor = 0, ch;

	/* Crosshair placement */
	int		cpx[] = { 0, 0, 1, 1, 1 };
	int		cpy[] = { 0, 1, 0, 0, 1 };

	while ((ch = getopt(argc, argv, "cD:d:o:v")) != -1) {
		switch (ch) {
		case 'c':
			keep_cursor++;
			break;
		case 'D':
			display_name = optarg;
			break;
		case 'd':
			device_name = optarg;
			break;
		case 'o':
			output_name = optarg;
			break;
		case 'v':
			verbose = True;
			break;
		default:
			usage();
			/* NOTREACHED */
		}
	}
	argc -= optind;
	argv += optind;

	if (argc != 0)
		usage();

	/* connect to X server */
	if ((display = XOpenDisplay(display_name)) == NULL) {
		fprintf(stderr, "%s: cannot connect to X server %s\n",
		    __progname, XDisplayName(display_name));
		exit(1);
	}
	screen = DefaultScreen(display);
	root = RootWindow(display, screen);

	/* get screen size from display structure macro */
	xpos = 0;
	ypos = 0;
	width = DisplayWidth(display, screen);
	height = DisplayHeight(display, screen);

	if (XRRQueryExtension(display, &event, &error)) {
		int major, minor;

		if (XRRQueryVersion(display, &major, &minor) != True) {
			fprintf(stderr, "Error querying XRandR version");
		} else {
			printf("XRandR extension version %d.%d present\n",
			    major, minor);
			has_xrandr = True;
			if (major > 1 || (major == 1 && minor >=2))
				has_xrandr_1_2 = True;
			if (major > 1 || (major == 1 && minor >=3))
				has_xrandr_1_3 = True;
		}
	}

	if (output_name != NULL) {
		if (has_xrandr_1_2) {
			get_xrandr_config(display, root, output_name,
			    &xpos, &ypos, &width, &height);
		} else {
			fprintf(stderr, "%s: can not specify an output "
			    "whithout XRandr 1.2 or later", __progname);
			exit(2);
		}
	}
	if (!XQueryExtension(display, INAME, &xi_opcode,
		&event, &error)) {
		fprintf(stderr, "%s: X Input extension not available.\n",
		    __progname);
		exit(1);
	}

	version = XGetExtensionVersion(display, INAME);
	if (version == NULL ||
	    version == (XExtensionVersion *)NoSuchExtension) {
		fprintf(stderr, "Cannot query X Input version.\n");
		exit(1);
	}
	XFree(version);
	prop_calibration = XInternAtom(display, WS_PROP_CALIBRATION, True);
	if (prop_calibration == None) {
		fprintf(stderr, "Unable to find the \"%s\" device property.\n"
		    "There are probably no calibrable devices "
		    "on this system.\n", WS_PROP_CALIBRATION);
		exit(1);
	}
	prop_swap = XInternAtom(display, WS_PROP_SWAP_AXES, True);
	if (prop_swap == None) {
		fprintf(stderr, "Unable to find the \"%s\" device property\n",
		    WS_PROP_SWAP_AXES);
		exit(1);
	}
	info = find_device_info(device_name);
	if (info == NULL) {
		fprintf(stderr, "Unable to find the %s device\n",
			device_name ? device_name : "default");
		exit(1);
	}


	/* setup window attributes */
	xswa.override_redirect = True;
	xswa.background_pixel = BlackPixel(display, screen);
	xswa.event_mask = ExposureMask | KeyPressMask;
	mask = CWOverrideRedirect | CWBackPixel | CWEventMask;
	if (!keep_cursor) {
		xswa.cursor = create_empty_cursor();
		mask |= CWCursor;
	}
	win = XCreateWindow(display, RootWindow(display, screen),
			    xpos, ypos, width, height, 0,
			    CopyFromParent, InputOutput, CopyFromParent,
			    mask, &xswa);
	render_init();
	XMapWindow(display, win);
	XGrabKeyboard(display, win, False, GrabModeAsync, GrabModeAsync,
		      CurrentTime);
	XGrabServer(display);

	XClearWindow(display, win);

	if (verbose)
		printf("Calibrating %s\n", info->name);
	device = XOpenDevice(display, info->id);
	if (!device) {
		fprintf(stderr, "Unable to open the X input device \"%s\"\n",
		    info->name);
		return 0;
	}

	if (!register_events(info, device, 0))
		exit(1);

	uncalibrate(device);
calib:
	XftDrawRect(draw, &bg, 0, 0, width, height);

	for (i = 0; i < 5; i++) {
		draw_graphics(cpx[i], cpy[i], i);
		XFlush(display);
		if (!get_events(i))
			break;
		XftDrawRect(draw, &bg, 0, 0, width, height);
	}
	if (interrupted)
		cleanup_exit(device);

	/* Check if  X and Y should be swapped */
	if (fabs(x[0] - x[1]) > fabs(y[0] - y[1])) {

		calib.swapxy = 1;

		for (i = 0; i < 5; i++) {
			int t = x[i];
			x[i] = y[i];
			y[i] = t;
		}
	}

	/* get touch pad resolution to screen resolution ratio */
	a1 = (double) (x[4] - x[0]) / (double) (cx[4] - cx[0]);
	a2 = (double) (x[3] - x[1]) / (double) (cx[3] - cx[1]);
	/* get the minimum pad position on the X-axis */
	b1 = x[0] - a1 * cx[0];
	b2 = x[1] - a2 * cx[1];
	/* use the average ratio and average minimum position */
	a = (a1 + a2) / 2.0;
	b = (b1 + b2) / 2.0;
	xerr = a * width / 2 + b - x[2];
	if (fabs(xerr) > fabs(a * width * .01)) {
		fprintf(stderr, "Calibration problem: X axis error (%.2f) too high, try again\n",
			fabs(xerr));
		goto err;
	}
	calib.minx = (int) (b + 0.5);
	calib.maxx = (int) (a * width + b + 0.5);

	/* get touch pad resolution to screen resolution ratio */
	a1 = (double) (y[4] - y[0]) / (double) (cy[4] - cy[0]);
	a2 = (double) (y[3] - y[1]) / (double) (cy[3] - cy[1]);
	/* get the minimum pad position on the Y-axis */
	b1 = y[0] - a1 * cy[0];
	b2 = y[1] - a2 * cy[1];
	/* use the average ratio and average minimum position */
	a = (a1 + a2) / 2.0;
	b = (b1 + b2) / 2.0;
	yerr = a * height / 2 + b - y[2];
	if (fabs(yerr) > fabs(a * height * 0.01)) {
		fprintf(stderr, "Calibration problem: Y axis error (%.2f) too high, try again\n",
			fabs(yerr));
		goto err;
	}
	calib.miny = (int) (b + 0.5);
	calib.maxy = (int) (a * height + b + 0.5);

	XFlush(display);

	calib.resx = width;
	calib.resy = height;

	/* Send new values to the X server */
	calib_data[0] = calib.minx;
	calib_data[1] = calib.maxx;
	calib_data[2] = calib.miny;
	calib_data[3] = calib.maxy;
	XChangeDeviceProperty(display, device, prop_calibration,
	    XA_INTEGER, 32, PropModeReplace, (unsigned char *)calib_data, 4);

	swap = calib.swapxy;
	XChangeDeviceProperty(display, device, prop_swap,
	    XA_INTEGER, 8, PropModeReplace, (unsigned char *)&swap, 1);

	XCloseDevice(display, device);

	XCloseDisplay(display);

	/* And print them for storage in wsconsctl.conf */
	printf("mouse.scale=%d,%d,%d,%d,%d,%d,%d\n",
	    calib.minx, calib.maxx,
	    calib.miny, calib.maxy,
	    calib.swapxy,
	    calib.resx, calib.resy);

	return 0;
err:
	draw_text(error_message, &errorColor);
	XFlush(display);
	sleep(2);
	goto calib;
}
@


1.22
log
@Fix 2 NULL pointer dereferences.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.21 2011/07/16 17:54:07 matthieu Exp $ */
a106 1
char           *progname;
@


1.21
log
@Remove an extra debugging printf that leaked in previous commit.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.20 2011/07/16 17:32:24 matthieu Exp $ */
d615 1
a615 1
		    argv[0], XDisplayName(display_name));
d656 1
a656 1
		    argv[0]);
@


1.20
log
@Check if an input device has calibration data before accepting it as
as candidate for calibration.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.19 2011/07/16 17:27:52 matthieu Exp $ */
a473 1
		fprintf(stderr, "type != XA_INTEGER %lu\n", type);
@


1.19
log
@Add a '-c' option to keep the X cursor visible while calibrating.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.18 2011/07/16 17:21:41 matthieu Exp $ */
d270 28
d338 4
a341 2
			found = &devices[i];
			num_found++;
d474 1
a667 7
	info = find_device_info(device_name);
	if (info == NULL) {
		fprintf(stderr, "Unable to find the %s device\n",
			device_name ? device_name : "default");
		exit(1);
	}

d681 7
d710 2
@


1.18
log
@White space cleanup.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.17 2011/06/28 08:18:49 jasper Exp $ */
d4 1
a4 1
 * Copyright (c) 2009 Matthieu Herrb <matthieu@@herrb.eu>
d527 2
a528 1
	fprintf(stderr, "usage: xtsscale [-D display][-d device][-o output]\n");
d546 1
d548 1
a548 1
	int ch;
d554 1
a554 1
	while ((ch = getopt(argc, argv, "D:d:o:v")) != -1) {
d556 3
d662 5
a666 2
	xswa.cursor = create_empty_cursor();

d670 1
a670 2
			    CWOverrideRedirect | CWBackPixel | CWEventMask |
			    CWCursor, &xswa);
@


1.17
log
@spello
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.16 2010/12/06 06:49:47 jasper Exp $ */
d71 1
a71 1
#define TouchCross	        "black"
d223 1
a223 1
	int      	len;
d490 1
a490 1
			fprintf(stderr, 
d501 1
a501 1
				    "information\n", __progname, 
d592 15
a606 2
        if (XRRQueryExtension(display, &event, &error)) {
                int major, minor;
a607 13
                if (XRRQueryVersion(display, &major, &minor) != True) {
                        fprintf(stderr, "Error querying XRandR version");
                } else {
                        printf("XRandR extension version %d.%d present\n",
                            major, minor);
                        has_xrandr = True;
                        if (major > 1 || (major == 1 && minor >=2))
                                has_xrandr_1_2 = True;
                        if (major > 1 || (major == 1 && minor >=3))
                                has_xrandr_1_3 = True;
                }
        }
        
d610 1
a610 1
			get_xrandr_config(display, root, output_name, 
@


1.16
log
@- add a flag to specify the display to start xtsscale on.

ok matthieu@@
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.15 2010/03/23 20:27:42 matthieu Exp $ */
d121 1
a121 1
	"Press on the cross hairs please...",
@


1.15
log
@add a -v flag to select verbose mode, to output raw coordinate read
from the device, for debugging.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.14 2010/01/22 07:47:54 matthieu Exp $ */
d527 1
a527 1
	fprintf(stderr, "usage: xtsscale [-d device][-o output]\n");
d552 1
a552 1
	while ((ch = getopt(argc, argv, "d:o:v")) != -1) {
d554 3
@


1.14
log
@Start adding XRandR support. not really functional yet though.
(missing the code to compute the calibration data that restrict events
to a given output)
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.13 2009/11/26 18:13:47 matthieu Exp $ */
d109 1
d422 3
d552 1
a552 1
	while ((ch = getopt(argc, argv, "d:o:")) != -1) {
d560 3
d716 1
a716 1
		fprintf(stderr, "X error (%.2f) too high, try again\n",
d734 1
a734 1
		fprintf(stderr, "Y error (%.2f) too high, try again\n",
@


1.13
log
@white space
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.12 2009/11/26 14:25:05 sobrado Exp $ */
d57 2
d62 1
d83 5
d106 1
a106 1
unsigned int    width, height;	/* window size */
d113 2
d472 55
d532 1
d542 1
d548 12
a559 3
	if (argc != 1 && argc != 2) {
		fprintf(stderr, "usage: %s [device]\n", argv[0]);
		return 1;
d561 5
a565 2
	if (argc == 2)
		device_name = argv[1];
d573 35
a642 3
	screen = DefaultScreen(display);
	root = RootWindow(display, screen);

a648 4
	/* get screen size from display structure macro */
	width = DisplayWidth(display, screen);
	height = DisplayHeight(display, screen);

d650 1
a650 1
			    0, 0, width, height, 0,
@


1.12
log
@"usage:" is usually lower case.

ok matthieu@@
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.11 2009/11/26 11:35:29 matthieu Exp $ */
d131 1
a131 1
	XChangeDeviceProperty(display, device, prop_calibration, 
d134 1
a134 1
	XChangeDeviceProperty(display, device, prop_swap, 
d269 1
a269 1
	
d275 1
a275 1
	
a293 1
	
d320 1
a320 1
register_events(XDeviceInfo *info, XDevice *device, 
d328 1
a328 1
	
d330 1
a330 1
	
d332 1
a332 1
		for (ip = device->classes, i=0; i<info->num_classes; 
d336 2
a337 2
				DeviceButtonPress(device, button_press_type, 
				    event_list[number]); 
d339 2
a340 2
				DeviceButtonRelease(device, 
				    button_release_type, event_list[number]); 
d343 1
a343 1
				
d345 1
a345 1
				DeviceMotionNotify(device, motion_type, 
d348 1
a348 1
					ProximityIn(device, proximity_in_type, 
d350 2
a351 2
					ProximityOut(device, 
					    proximity_out_type, 
d355 1
a355 1
				
d363 1
a363 1
		
d395 1
a395 1
					fprintf(stderr, 
d423 1
a423 1
	
d426 1
a426 1
	    4, False, XA_INTEGER, &type, &format, &nitems, 
d429 2
a430 2
	if (type != XA_INTEGER) { 
		fprintf(stderr, "Device property \"%s\": invalid type %s\n", 
d436 1
a436 1
		    "invalid number of items %ld\n", 
d444 1
a444 1
	
d452 1
a452 1
	
d454 1
a454 1
	XChangeDeviceProperty(display, device, prop_calibration, 
a461 1
		
d485 1
a485 1
	if (argc == 2) 
d487 1
a487 1
	
d494 1
a494 1
	if (!XQueryExtension(display, INAME, &xi_opcode, 
d502 1
a502 1
	if (version == NULL || 
d510 1
a510 1
		fprintf(stderr, "Unable to find the %s device\n", 
d557 1
a557 1
		fprintf(stderr, "Unable to open the X input device \"%s\"\n", 
d561 1
a561 1
	
d572 1
a572 1
		if (!get_events(i)) 
d578 1
a578 1
		
d637 1
a637 1
	XChangeDeviceProperty(display, device, prop_calibration, 
d641 1
a641 1
	XChangeDeviceProperty(display, device, prop_swap, 
@


1.11
log
@Tidy up error messages.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.10 2009/11/26 10:58:45 matthieu Exp $ */
d484 1
a484 1
		fprintf(stderr, "Usage: %s [device]\n", argv[0]);
@


1.10
log
@Allow the ESC key to interrupt the calibration process.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.9 2009/11/25 23:00:57 matthieu Exp $ */
d153 1
a153 1
		fprintf(stderr, "cannot get color");
d158 1
a158 1
		fprintf(stderr, "cannot get color");
d163 1
a163 1
		fprintf(stderr, "cannot get bg color");
d168 1
a168 1
		fprintf(stderr, "cannot get color");
d358 3
a360 1
				fprintf(stderr, "unknown class\n");
d366 1
a366 1
			fprintf(stderr, "error selecting extended events\n");
d397 1
a397 1
					    "unknown axis %d\n", a);
d431 2
a432 1
		fprintf(stderr, WS_PROP_CALIBRATION " isn't integer\n");
d436 3
a438 1
		fprintf(stderr, WS_PROP_CALIBRATION " bad number of items\n");
d484 1
a484 1
		fprintf(stderr, "usage: %s [device]\n", argv[0]);
d493 1
a493 1
			progname, XDisplayName(display_name));
d498 2
a499 1
		fprintf(stderr, "X Input extension not available.\n");
a515 4
	if (info->use != IsXPointer && info->use != IsXExtensionPointer) {
		fprintf(stderr, "%s is not an X pointer device", info->name);
		exit(1);
	}
d519 3
a521 1
		fprintf(stderr, "cannot find atom %s\n", WS_PROP_CALIBRATION);
d526 2
a527 1
		fprintf(stderr, "cannot find atom %s\n", WS_PROP_SWAP_AXES);
d559 2
a560 1
		fprintf(stderr, "unable to open device %s\n", info->name);
@


1.9
log
@Better error handling during device selection.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.8 2009/11/25 19:43:05 matthieu Exp $ */
d100 1
d111 1
d122 1
a122 1
cleanup_exit()
d124 14
d141 1
d371 1
a371 1
static void
d377 1
d401 7
d410 1
d568 2
a569 1
		get_events(i);
d572 3
a574 1

@


1.8
log
@Search for calibration properties atoms earlier, to avoid a screen
flash when they are not present.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.7 2009/11/25 18:30:13 matthieu Exp $ */
d247 1
a247 1
	int		i;
d254 5
d268 1
a268 1
			id = strtonum(name, 0, num_devices - 1, &errstr);
d305 1
a305 1
    char *dev_name, Bool handle_proximity)
a314 5
	if (!device) {
		fprintf(stderr, "unable to open device %s\n", dev_name);
		return 0;
	}
	
d437 1
d456 3
a458 1

d478 1
a478 1
	info = find_device_info(argv[1]);
d480 2
a481 1
		fprintf(stderr, "Unable to find device %s\n", argv[1]);
d527 6
a532 1
	if (!register_events(info, device, argv[1], 0))
@


1.7
log
@New, XInput based, version of xtsscale(1).
XInput is used to get raw events from the device and device properties
are used to send the data back to the X server.
Calibration can now be done without restarting X.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.6 2007/08/31 21:53:55 matthieu Exp $ */
d485 11
a524 12


	prop_calibration = XInternAtom(display, WS_PROP_CALIBRATION, True);
	if (prop_calibration == None) {
		fprintf(stderr, "cannot find atom %s\n", WS_PROP_CALIBRATION);
		exit(1);
	}
	prop_swap = XInternAtom(display, WS_PROP_SWAP_AXES, True);
	if (prop_swap == None) {
		fprintf(stderr, "cannot find atom %s\n", WS_PROP_SWAP_AXES);
		exit(1);
	}
@


1.6
log
@- Make the draw_text() function more generic.
- Display an error message on the screen when the calibration error
  is too high before re-starting.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.5 2007/08/31 21:17:33 matthieu Exp $ */
d4 1
d28 23
a51 2
#include <X11/Xutil.h>
#include <X11/Xos.h>
a52 1
#include <X11/keysym.h>
d55 1
d57 1
a57 6

#include <sys/param.h>
#include <sys/ioctl.h>
#include <dev/wscons/wsconsio.h>

#include <err.h>
a58 1
#include <termios.h>
d62 1
d72 10
a99 1
int             evfd;
d104 3
a119 35
get_events(int i)
{
	ssize_t         len;
	int             down;
	struct wscons_event ev;

	down = 0;
	x[i] = y[i] = -1;
	while (down || x[i] == -1 || y[i] == -1) {
		len = read(evfd, &ev, sizeof(ev));
		if (len != 16)
			break;
		switch (ev.type) {
		case WSCONS_EVENT_MOUSE_DOWN:
			down = 1;
			break;
		case WSCONS_EVENT_MOUSE_UP:
			down = 0;
			break;
		case WSCONS_EVENT_MOUSE_ABSOLUTE_X:
			if (down)
				x[i] = ev.value;
			break;
		case WSCONS_EVENT_MOUSE_ABSOLUTE_Y:
			if (down)
				y[i] = ev.value;
			break;
		default:
			break;
		}
	}
}


void
a124 1
	close(evfd);
d228 1
a228 1
create_empty_cursor()
d242 191
d438 1
a438 1
	int             i = 0, orawmode;
d440 6
a445 2
	struct		wsmouse_calibcoords wmcoords;
	extern char	*__progname;
d451 2
a452 2
	if (argc != 2) {
		fprintf(stderr, "usage: %s <device>\n", __progname);
a455 3
	if ((evfd = open(argv[1], O_RDONLY)) == -1)
		err(1, "open()");

a459 1
		close(evfd);
d462 23
d511 3
a513 2
        if (ioctl(evfd, WSMOUSEIO_GCALIBCOORDS, &wmcoords) < 0)
                err(1, "WSMOUSEIO_GCALIBCOORDS");
a514 2
        orawmode = wmcoords.samplelen;
        wmcoords.samplelen = 1;
d516 10
a525 2
        if (ioctl(evfd, WSMOUSEIO_SCALIBCOORDS, &wmcoords) < 0)
                err(1, "WSMOUSEIO_SCALIBCOORDS");
d527 1
d540 3
a542 1
		wmcoords.swapxy = 1;
d565 2
a566 2
	wmcoords.minx = (int) (b + 0.5);
	wmcoords.maxx = (int) (a * width + b + 0.5);
d583 2
a584 2
	wmcoords.miny = (int) (b + 0.5);
	wmcoords.maxy = (int) (a * height + b + 0.5);
d588 14
a601 3
        wmcoords.samplelen = orawmode;
	wmcoords.resx = width;
	wmcoords.resy = height;
d603 3
a605 2
        if (ioctl(evfd, WSMOUSEIO_SCALIBCOORDS, &wmcoords) < 0)
                err(1, "WSMOUSEIO_SCALIBCOORDS");
d607 1
d609 4
a612 4
	    wmcoords.minx, wmcoords.maxx,
	    wmcoords.miny, wmcoords.maxy,
	    wmcoords.swapxy,
	    wmcoords.resx, wmcoords.resy);
@


1.5
log
@Switch to Xft/Xrender rendering. Welcome to the 21st century.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.4 2007/08/31 20:59:33 matthieu Exp $ */
d53 1
d69 1
a69 1
XftColor	cross, promptColor, bg;
d78 12
d156 5
d200 1
a200 1
draw_text()
d202 1
a202 11
	static char    *prompt[] = {
		"TOUCH SCREEN CALIBRATION",
		"Press on the cross hairs please..."
	};

#define num	(sizeof(prompt) / sizeof(prompt[0]))
	static int      init = 0;
	static int      p_len[num];
	static int      p_xpos[num];
	static int      p_height = 0;
	static int      p_maxwidth = 0;
a203 1
	int             line_height;
d206 9
a214 13
	if (!init) {
		for (i = 0; i < num; i++) {
			p_len[i] = strlen(prompt[i]);
			XftTextExtents8(display, font, prompt[i],
			    p_len[i], &extents);
			p_xpos[i] = (width - extents.width)/2;
			if (extents.width > p_maxwidth)
				p_maxwidth = extents.width;
			if (extents.height > p_height)
				p_height = extents.height;
		}
		
		init = 1;
a215 9
	line_height = p_height * 1.5;
	y = height / 2 - 6 * line_height;

	for (i = 0; i < num; i++) {
		XftDrawString8(draw, &promptColor, font,
		    p_xpos[i], y+i*line_height, prompt[i], p_len[i]);

	}
#undef num
a220 1
	XftColor   *color;
d222 1
a222 2
	draw_text();
	color = &cross;
d231 1
a231 1
	draw_point(cx[n], cy[n], width / 200, width / 64, color);
d346 1
a346 1
		goto calib;
d364 1
a364 1
		goto calib;
d385 5
@


1.4
log
@Remove the useless ts structure, and fix the setting
of the new calibration values.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.3 2007/08/31 20:28:18 matthieu Exp $ */
d32 3
a45 10
#define FONT_NAME		"9x15"

#define Background		cWHITE
#define TouchCross		cBLACK
#define PromptText		cBLACK

#define N_Colors		3

static char     colors[N_Colors][10] =
{"BLACK", "WHITE"};
d47 2
a48 1
static unsigned long pixels[N_Colors];
d50 3
a52 2
#define cBLACK			(pixels[0])
#define cWHITE			(pixels[1])
a64 1
GC              gc;
d67 3
a69 1
XFontStruct    *font_info;
a114 1
	XUnloadFont(display, font_info->fid);
a116 1
	XFreeGC(display, gc);
a120 1

d122 1
a122 1
load_font(XFontStruct ** font_info)
d124 18
a141 5
	char           *fontname = FONT_NAME;

	if ((*font_info = XLoadQueryFont(display, fontname)) == NULL) {
		printf("Cannot open %s font\n", FONT_NAME);
		exit(1);
d143 2
a146 1

d148 1
a148 1
draw_point(int x, int y, int width, int size, unsigned long color)
d150 29
a178 5
	XSetForeground(display, gc, color);
	XSetLineAttributes(display, gc, width, LineSolid,
			   CapRound, JoinRound);
	XDrawLine(display, win, gc, x - size, y, x + size, y);
	XDrawLine(display, win, gc, x, y - size, x, y + size);
d185 1
a185 1
		"    TOUCH SCREEN CALIBRATION",
d192 2
a193 2
	static int      p_width[num];
	static int      p_height;
d197 1
d202 7
a208 3
			p_width[i] = XTextWidth(font_info, prompt[i], p_len[i]);
			if (p_width[i] > p_maxwidth)
				p_maxwidth = p_width[i];
d210 1
a210 1
		p_height = font_info->ascent + font_info->descent;
d213 1
a213 2
	line_height = p_height + 5;
	x = (width - p_maxwidth) / 2;
d216 3
a218 5
	XSetForeground(display, gc, PromptText);
	XClearArea(display, win, x - 11, y - 8 - p_height,
		   p_maxwidth + 11 * 2, num * line_height + 8 * 2, False);
	XSetLineAttributes(display, gc, 3, FillSolid,
			   CapRound, JoinRound);
a219 3
	for (i = 0; i < num; i++) {
		XDrawString(display, win, gc, x, y + i * line_height, prompt[i],
			    p_len[i]);
a223 1

d227 1
a227 1
	unsigned long   color;
d230 1
a230 1
	color = TouchCross;
a241 40
void
get_gc(Window win, GC * gc, XFontStruct * font_info)
{
	unsigned long   valuemask = 0;	/* ignore XGCvalues and use defaults */
	XGCValues       values;
	unsigned int    line_width = 5;
	int             line_style = LineSolid;
	int             cap_style = CapRound;
	int             join_style = JoinRound;

	*gc = XCreateGC(display, win, valuemask, &values);

	XSetFont(display, *gc, font_info->fid);

	XSetLineAttributes(display, *gc, line_width, line_style,
			   cap_style, join_style);
}


int
get_color()
{
	int             default_depth;
	Colormap        default_cmap;
	XColor          my_color;
	int             i;

	default_depth = DefaultDepth(display, screen);
	default_cmap = DefaultColormap(display, screen);

	for (i = 0; i < N_Colors; i++) {
		XParseColor(display, default_cmap, colors[i], &my_color);
		XAllocColor(display, default_cmap, &my_color);
		pixels[i] = my_color.pixel;
	}

	return 0;
}


d266 1
a266 1
	
d269 1
a269 1
	int		cpy[] = { 0, 1, 0, 0, 1 }; 
d304 1
a308 3
	load_font(&font_info);
	get_gc(win, &gc, font_info);
	get_color();
a309 1
	XSetWindowBackground(display, win, Background);
d322 2
d328 1
a328 1
		XClearWindow(display, win);
@


1.3
log
@Fix error computation, in the case where one axis is inverted.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.2 2007/08/30 19:45:25 matthieu Exp $ */
a281 8
	struct tsscale {
		int             ts_minx;
		int             ts_maxx;
		int             ts_miny;
		int             ts_maxy;
		int             ts_swapxy;
	} ts;

d368 2
a369 2
	ts.ts_minx = (int) (b + 0.5);
	ts.ts_maxx = (int) (a * width + b + 0.5);
d386 2
a387 2
	ts.ts_miny = (int) (b + 0.5);
	ts.ts_maxy = (int) (a * height + b + 0.5);
d392 2
d399 5
a403 3
	    ts.ts_minx, ts.ts_maxx, ts.ts_miny,
	    ts.ts_maxy, wmcoords.swapxy, width, height);
		 
@


1.2
log
@First round of bug fixes/enhancements.
- fix arithmetic errors.
- auto-detect swapxy.
@
text
@d1 1
a1 1
/*      $OpenBSD: xtsscale.c,v 1.1 2007/05/20 14:43:12 robert Exp $ */
d371 1
a371 1
	if (fabs(xerr) > (a * width + b) * .01) {
d389 1
a389 1
	if (fabs(yerr) > (a * height + b) * 0.01) {
@


1.1
log
@add xtsscale(1), an application that can be used to
calibrate touchscreens driven by the uts(4) driver.
it is not linked to the build yet; discussed with matthieu@@
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d78 2
a79 2
unsigned int    cx[5], cy[5];
unsigned int    x[5], y[5];
d351 10
d389 1
a389 1
	if (fabs(yerr) > (a * height + b)) {
d394 1
a394 1
	ts.ts_miny = (int) (b + 0.5) / 4;
@

