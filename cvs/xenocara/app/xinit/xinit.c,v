head	1.14;
access;
symbols
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.8
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.6
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.2
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.6
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.2
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_3:1.3.0.2
	v1_0_6:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_0_3:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2015.01.25.11.37.58;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	rIxERYrEVqNpd9Ck;

1.13
date	2013.09.14.09.16.24;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.05.31.21.44.42;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.10.31.14.00.14;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.01.08.58.06;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.11.01.08.52.28;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.31.20.23.19;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.05.03.13.17.37;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.18.20.31.51;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.20.13.46.02;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.20.13.25.46;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.15.17.12.01;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.26.17.17.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.14.47.19;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.14.47.19;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.15.17.05.32;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update to xinit 1.3.4
@
text
@/*

Copyright 1986, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include <X11/Xlib.h>
#include <X11/Xos.h>
#include <X11/Xatom.h>
#include <stdio.h>
#include <ctype.h>
#include <stdint.h>

#include <signal.h>
#include <sys/wait.h>
#include <errno.h>
#include <setjmp.h>
#include <stdarg.h>

#ifdef __APPLE__
#include <AvailabilityMacros.h>
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
#include <vproc.h>
#endif
#endif

/* For PRIO_PROCESS and setpriority() */
#include <sys/time.h>
#include <sys/resource.h>

#include <stdlib.h>

#ifndef SHELL
#define SHELL "sh"
#endif

const char *bindir = BINDIR;
const char * const server_names[] = {
#ifdef __APPLE__
    "Xquartz     Mac OSX Quartz displays.",
#else
# ifdef __CYGWIN__
    "XWin        X Server for the Cygwin environment on Microsoft Windows",
# else
    "Xorg        Common X server for most displays",
# endif
#endif
    "Xvfb        Virtual frame buffer",
    "Xfake       kdrive-based virtual frame buffer",
    "Xnest       X server nested in a window on another X server",
    "Xephyr      kdrive-based nested X server",
    "Xvnc        X server accessed over VNC's RFB protocol",
    "Xdmx        Distributed Multi-head X server",
    NULL};

#ifndef XINITRC
#define XINITRC ".xinitrc"
#endif
char xinitrcbuf[256];

#ifndef XSERVERRC
#define XSERVERRC ".xserverrc"
#endif
char xserverrcbuf[256];

#define TRUE 1
#define FALSE 0

static char *default_server = "X";
static char *default_display = ":0";        /* choose most efficient */
static char *default_client[] = {"xterm", "-geometry", "+1+1", "-n", "login", NULL};
static char *serverargv[100];
static char *clientargv[100];
static char **server = serverargv + 2;        /* make sure room for sh .xserverrc args */
static char **client = clientargv + 2;        /* make sure room for sh .xinitrc args */
static char *displayNum = NULL;
static char *program = NULL;
static Display *xd = NULL;            /* server connection */
int status;
pid_t serverpid = -1;
pid_t clientpid = -1;
volatile int gotSignal = 0;

static void Execute(char **vec);
static Bool waitforserver(void);
static Bool processTimeout(int timeout, const char *string);
static pid_t startServer(char *server[]);
static pid_t startClient(char *client[]);
static int ignorexio(Display *dpy);
static void shutdown(void);
static void set_environment(void);

static void Fatal(const char *fmt, ...) _X_ATTRIBUTE_PRINTF(1,2) _X_NORETURN;
static void Error(const char *fmt, ...) _X_ATTRIBUTE_PRINTF(1,2);
static void Fatalx(const char *fmt, ...) _X_ATTRIBUTE_PRINTF(1,2) _X_NORETURN;
static void Errorx(const char *fmt, ...) _X_ATTRIBUTE_PRINTF(1,2);

static void
sigCatch(int sig)
{
    /* On system with POSIX signals, just interrupt the system call */
    gotSignal = sig;
}

static void
sigIgnore(int sig)
{
}

static void
Execute(char **vec)		/* has room from up above */
{
    execvp(vec[0], vec);
    if (access(vec[0], R_OK) == 0) {
	vec--;				/* back it up to stuff shell in */
	vec[0] = SHELL;
	execvp(vec[0], vec);
    }
    return;
}

int
main(int argc, char *argv[])
{
    register char **sptr = server;
    register char **cptr = client;
    register char **ptr;
    pid_t pid;
    int client_given = 0, server_given = 0;
    int client_args_given = 0, server_args_given = 0;
    int start_of_client_args, start_of_server_args;
    struct sigaction sa, si;
#ifdef __APPLE__
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
    vproc_transaction_t vt;
#endif
#endif

    program = *argv++;
    argc--;
    /*
     * copy the client args.
     */
    if (argc == 0 ||
        (**argv != '/' && **argv != '.')) {
        for (ptr = default_client; *ptr; )
            *cptr++ = *ptr++;
    } else {
        client_given = 1;
    }
    start_of_client_args = (cptr - client);
    while (argc && strcmp(*argv, "--")) {
        client_args_given++;
        *cptr++ = *argv++;
        argc--;
    }
    *cptr = NULL;
    if (argc) {
        argv++;
        argc--;
    }

    /*
     * Copy the server args.
     */
    if (argc == 0 ||
        (**argv != '/' && **argv != '.')) {
        *sptr++ = default_server;
    } else {
        server_given = 1;
        *sptr++ = *argv++;
        argc--;
    }
    if (argc > 0 && (argv[0][0] == ':' && isdigit(argv[0][1])))
        displayNum = *argv;
    else
        displayNum = *sptr++ = default_display;

    start_of_server_args = (sptr - server);
    while (--argc >= 0) {
        server_args_given++;
        *sptr++ = *argv++;
    }
    *sptr = NULL;

    /*
     * if no client arguments given, check for a startup file and copy
     * that into the argument list
     */
    if (!client_given) {
        char *cp;
        Bool required = False;

        xinitrcbuf[0] = '\0';
        if ((cp = getenv("XINITRC")) != NULL) {
            snprintf(xinitrcbuf, sizeof(xinitrcbuf), "%s", cp);
            required = True;
        } else if ((cp = getenv("HOME")) != NULL) {
            snprintf(xinitrcbuf, sizeof(xinitrcbuf),
                     "%s/%s", cp, XINITRC);
        }
        if (xinitrcbuf[0]) {
            if (access(xinitrcbuf, F_OK) == 0) {
                client += start_of_client_args - 1;
                client[0] = xinitrcbuf;
            } else if (required) {
                Error("warning, no client init file \"%s\"", xinitrcbuf);
            }
        }
    }

    /*
     * if no server arguments given, check for a startup file and copy
     * that into the argument list
     */
    if (!server_given) {
        char *cp;
        Bool required = False;

        xserverrcbuf[0] = '\0';
        if ((cp = getenv("XSERVERRC")) != NULL) {
            snprintf(xserverrcbuf, sizeof(xserverrcbuf), "%s", cp);
            required = True;
        } else if ((cp = getenv("HOME")) != NULL) {
            snprintf(xserverrcbuf, sizeof(xserverrcbuf),
                     "%s/%s", cp, XSERVERRC);
        }
        if (xserverrcbuf[0]) {
            if (access(xserverrcbuf, F_OK) == 0) {
                server += start_of_server_args - 1;
                server[0] = xserverrcbuf;
            } else if (required) {
                Error("warning, no server init file \"%s\"", xserverrcbuf);
            }
        }
    }

    /*
     * Start the server and client.
     */
    signal(SIGCHLD, SIG_DFL);    /* Insurance */

    /* Let those signal interrupt the wait() call in the main loop */
    memset(&sa, 0, sizeof sa);
    sa.sa_handler = sigCatch;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;    /* do not set SA_RESTART */

    sigaction(SIGTERM, &sa, NULL);
    sigaction(SIGQUIT, &sa, NULL);
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGHUP, &sa, NULL);
    sigaction(SIGPIPE, &sa, NULL);

    memset(&si, 0, sizeof(si));
    si.sa_handler = sigIgnore;
    sigemptyset(&si.sa_mask);
    si.sa_flags = SA_RESTART;

    sigaction(SIGALRM, &si, NULL);
    sigaction(SIGUSR1, &si, NULL);

#ifdef __APPLE__
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
    vt = vproc_transaction_begin(NULL);
#endif
#endif

    if (startServer(server) > 0
        && startClient(client) > 0) {
        pid = -1;
        while (pid != clientpid && pid != serverpid
               && gotSignal == 0
            )
            pid = wait(NULL);
    }

#ifdef __APPLE__
#if MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
    vproc_transaction_end(NULL, vt);
#endif
#endif

    signal(SIGTERM, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    signal(SIGINT, SIG_IGN);
    signal(SIGHUP, SIG_IGN);
    signal(SIGPIPE, SIG_IGN);

    shutdown();

    if (gotSignal != 0) {
        Errorx("unexpected signal %d", gotSignal);
        exit(EXIT_FAILURE);
    }

    if (serverpid < 0)
        Fatalx("server error");
    if (clientpid < 0)
        Fatalx("client error");
    exit(EXIT_SUCCESS);
}


/*
 *    waitforserver - wait for X server to start up
 */
static Bool
waitforserver(void)
{
    int    ncycles     = 120;        /* # of cycles to wait */
    int    cycles;            /* Wait cycle count */

#ifdef __APPLE__
    /* For Apple, we don't get signaled by the server when it's ready, so we just
     * want to sleep now since we're going to sleep later anyways and this allows us
     * to avoid the awkard, "why is there an error message in the log" questions
     * from users.
     */

    sleep(2);
#endif

    for (cycles = 0; cycles < ncycles; cycles++) {
        if ((xd = XOpenDisplay(displayNum))) {
            return(TRUE);
        }
        else {
            if (!processTimeout(1, "X server to begin accepting connections"))
              break;
        }
    }

    Errorx("giving up");

    return(FALSE);
}

/*
 * return TRUE if we timeout waiting for pid to exit, FALSE otherwise.
 */
static Bool
processTimeout(int timeout, const char *string)
{
    int    i = 0;
    pid_t  pidfound = -1;
    static const char    *laststring;

    for (;;) {
        if ((pidfound = waitpid(serverpid, &status, WNOHANG)) == serverpid)
            break;
        if (timeout) {
            if (i == 0 && string != laststring)
                fprintf(stderr, "\r\nwaiting for %s ", string);
            else
                fprintf(stderr, ".");
            fflush(stderr);
            sleep(1);
        }
        if (++i > timeout)
            break;
    }
    if (i > 0) fputc('\n', stderr);     /* tidy up after message */
    laststring = string;
    return (serverpid != pidfound);
}

static pid_t
startServer(char *server_argv[])
{
    sigset_t mask, old;
    const char * const *cpp;

    sigemptyset(&mask);
    sigaddset(&mask, SIGUSR1);
    sigprocmask(SIG_BLOCK, &mask, &old);

    serverpid = fork();

    switch(serverpid) {
    case 0:
        /* Unblock */
        sigprocmask(SIG_SETMASK, &old, NULL);

        /*
         * don't hang on read/write to control tty
         */
        signal(SIGTTIN, SIG_IGN);
        signal(SIGTTOU, SIG_IGN);
        /*
         * ignore SIGUSR1 in child.  The server
         * will notice this and send SIGUSR1 back
         * at xinit when ready to accept connections
         */
        signal(SIGUSR1, SIG_IGN);
        /*
         * prevent server from getting sighup from vhangup()
         * if client is xterm -L
         */
        setpgid(0,getpid());
        Execute(server_argv);

        Error("unable to run server \"%s\"", server_argv[0]);

        fprintf(stderr, "Use the -- option, or make sure that %s is in your path and\n", bindir);
        fprintf(stderr, "that \"%s\" is a program or a link to the right type of server\n", server_argv[0]);
        fprintf(stderr, "for your display.  Possible server names include:\n\n");
        for (cpp = server_names; *cpp; cpp++)
            fprintf(stderr, "    %s\n", *cpp);
        fprintf(stderr, "\n");

        exit(EXIT_FAILURE);

        break;
    case -1:
        break;
    default:
        /*
         * don't nice server
         */
        setpriority(PRIO_PROCESS, serverpid, -1);

        errno = 0;
        if(! processTimeout(0, "")) {
            serverpid = -1;
            break;
        }
        /*
         * kludge to avoid race with TCP, giving server time to
         * set his socket options before we try to open it,
         * either use the 15 second timeout, or await SIGUSR1.
         *
         * If your machine is substantially slower than 15 seconds,
         * you can easily adjust this value.
         */
        alarm(15);

        sigsuspend(&old);
        alarm(0);
        sigprocmask(SIG_SETMASK, &old, NULL);

        if (waitforserver() == 0) {
            Error("unable to connect to X server");
            shutdown();
            serverpid = -1;
        }
        break;
    }

    return(serverpid);
}

static void
setWindowPath(void)
{
    /* setting WINDOWPATH for clients */
    Atom prop;
    Atom actualtype;
    int actualformat;
    unsigned long nitems;
    unsigned long bytes_after;
    unsigned char *buf;
    const char *windowpath;
    char *newwindowpath;
    unsigned long num;
    char nums[10];
    int numn;
    size_t len;
    prop = XInternAtom(xd, "XFree86_VT", False);
    if (prop == None) {
        Errorx("Unable to intern XFree86_VT atom");
        return;
    }
    if (XGetWindowProperty(xd, DefaultRootWindow(xd), prop, 0, 1,
        False, AnyPropertyType, &actualtype, &actualformat,
        &nitems, &bytes_after, &buf)) {
        Errorx("No XFree86_VT property detected on X server, WINDOWPATH won't be set");
        return;
    }
    if (nitems != 1) {
        Errorx("XFree86_VT property unexpectedly has %lu items instead of 1", nitems);
        XFree(buf);
        return;
    }
    switch (actualtype) {
    case XA_CARDINAL:
    case XA_INTEGER:
    case XA_WINDOW:
        switch (actualformat) {
        case  8:
            num = (*(uint8_t  *)(void *)buf);
            break;
        case 16:
            num = (*(uint16_t *)(void *)buf);
            break;
        case 32:
            num = (*(uint32_t *)(void *)buf);
            break;
        default:
            Errorx("XFree86_VT property has unexpected format %d", actualformat);
            XFree(buf);
            return;
        }
        break;
    default:
        Errorx("XFree86_VT property has unexpected type %lx", actualtype);
        XFree(buf);
        return;
    }
    XFree(buf);
    windowpath = getenv("WINDOWPATH");
    numn = snprintf(nums, sizeof(nums), "%lu", num);
    if (!windowpath) {
        len = numn + 1;
        newwindowpath = malloc(len);
        if (newwindowpath == NULL)
            return;
        snprintf(newwindowpath, len, "%s", nums);
    } else {
        len = strlen(windowpath) + 1 + numn + 1;
        newwindowpath = malloc(len);
        if (newwindowpath == NULL)
            return;
        snprintf(newwindowpath, len, "%s:%s",
                 windowpath, nums);
    }
    if (setenv("WINDOWPATH", newwindowpath, TRUE) == -1)
        Error("unable to set WINDOWPATH");


    free(newwindowpath);
}

static pid_t
startClient(char *client_argv[])
{
    clientpid = fork();
    if (clientpid == 0) {
        set_environment();
        setWindowPath();

        if (setuid(getuid()) == -1) {
            Error("cannot change uid");
            _exit(EXIT_FAILURE);
        }
        setpgid(0, getpid());
        Execute(client_argv);
        Error("Unable to run program \"%s\"", client_argv[0]);

        fprintf(stderr, "Specify a program on the command line or make sure that %s\n", bindir);
        fprintf(stderr, "is in your path.\n\n");

        _exit(EXIT_FAILURE);
    } else {
        return clientpid;
    }
}

static jmp_buf close_env;

static int
ignorexio(Display *dpy)
{
    Errorx("connection to X server lost");
    longjmp(close_env, 1);
    /*NOTREACHED*/
    return 0;
}

static void
shutdown(void)
{
    /* have kept display opened, so close it now */
    if (clientpid > 0) {
        XSetIOErrorHandler(ignorexio);
        if (! setjmp(close_env)) {
            XCloseDisplay(xd);
        }

        /* HUP all local clients to allow them to clean up */
        if (killpg(clientpid, SIGHUP) < 0 && errno != ESRCH)
            Error("can't send HUP to process group %d", clientpid);
    }

    if (serverpid < 0)
        return;

    if (killpg(serverpid, SIGTERM) < 0) {
        if (errno == ESRCH)
            return;
        Fatal("can't kill X server");
    }

    if (!processTimeout(10, "X server to shut down"))
        return;

    Errorx("X server slow to shut down, sending KILL signal");

    if (killpg(serverpid, SIGKILL) < 0) {
        if (errno == ESRCH)
            return;
        Error("can't SIGKILL X server");
    }

    if (processTimeout(3, "server to die"))
        Fatalx("X server refuses to die");
#ifdef __sun
    else {
        /* Restore keyboard mode. */
        serverpid = fork();
        switch (serverpid) {
        case 0:
            execlp ("kbd_mode", "kbd_mode", "-a", NULL);
            Fatal("Unable to run program \"%s\"", "kbd_mode");
            break;

        case 1:
            Error("fork failed");
            break;

        default:
            fprintf (stderr, "\r\nRestoring keyboard mode\r\n");
            processTimeout(1, "kbd_mode");
        }
    }
#endif
}

static void
set_environment(void)
{
    if (setenv("DISPLAY", displayNum, TRUE) == -1)
        Fatal("unable to set DISPLAY");
}

static void _X_ATTRIBUTE_PRINTF(1,0)
verror(const char *fmt, va_list ap)
{
    fprintf(stderr, "%s: ", program);
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, ": %s\n", strerror(errno));
}

static void _X_ATTRIBUTE_PRINTF(1,0)
verrorx(const char *fmt, va_list ap)
{
    fprintf(stderr, "%s: ", program);
    vfprintf(stderr, fmt, ap);
    fprintf(stderr, "\n");
}

static void
Fatal(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    verror(fmt, ap);
    va_end(ap);
    exit(EXIT_FAILURE);
}

static void
Fatalx(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    verrorx(fmt, ap);
    va_end(ap);
    exit(EXIT_FAILURE);
}

static void
Error(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    verror(fmt, ap);
    va_end(ap);
}

static void
Errorx(const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    verrorx(fmt, ap);
    va_end(ap);
}
@


1.13
log
@Update to xinit 1.3.3
@
text
@d393 1
a393 1
startServer(char *server[])
d425 1
a425 1
        Execute(server);
d427 1
a427 1
        Error("unable to run server \"%s\"", server[0]);
d430 1
a430 1
        fprintf(stderr, "that \"%s\" is a program or a link to the right type of server\n", server[0]);
d559 1
a559 1
startClient(char *client[])
d571 2
a572 2
        Execute(client);
        Error("Unable to run program \"%s\"", client[0]);
@


1.12
log
@Update to xinit 1.3.2
@
text
@d104 2
a105 2
int serverpid = -1;
int clientpid = -1;
d110 3
a112 3
static Bool processTimeout(int timeout, char *string);
static int startServer(char *server[]);
static int startClient(char *client[]);
d117 4
a120 4
static void Fatal(const char *fmt, ...);
static void Error(const char *fmt, ...);
static void Fatalx(const char *fmt, ...);
static void Errorx(const char *fmt, ...);
d152 1
a152 1
    int pid;
d367 1
a367 1
processTimeout(int timeout, char *string)
d369 3
a371 2
    int    i = 0, pidfound = -1;
    static char    *laststring;
d392 1
a392 1
static int
d558 1
a558 1
static int
d631 20
d660 1
a660 1
static void
d668 1
a668 1
static void
@


1.11
log
@Update to xinit 1.3.1
@
text
@a51 1
#if defined(__DragonFly__) || defined(__OpenBSD__)
a53 1
#endif /* __DragonFly__ || __OpenBSD__ */
@


1.10
log
@Remove Xorg RCSId that was left in a previous merge.
@
text
@d383 1
a384 2
        if (timeout)
            sleep(1);
d622 1
a622 1
    Errorx("X server slow to shut down, senging KILL signal");
@


1.9
log
@Update to xinit 1.3.0
@
text
@a0 1
/* $Xorg: xinit.c,v 1.5 2001/02/09 02:05:49 xorgcvs Exp $ */
@


1.8
log
@Update to xinit 1.2.1
@
text
@a38 2
#ifdef X_POSIX_C_SOURCE
#define _POSIX_C_SOURCE X_POSIX_C_SOURCE
a39 12
#undef _POSIX_C_SOURCE
#else
#if defined(X_NOT_POSIX) || defined(_POSIX_SOURCE)
#include <signal.h>
#else
#define _POSIX_SOURCE
#include <signal.h>
#undef _POSIX_SOURCE
#endif
#endif

#ifndef SYSV
a40 1
#endif
d52 5
a56 15
#if !defined(SIGCHLD) && defined(SIGCLD)
#define SIGCHLD SIGCLD
#endif
#ifdef __UNIXOS2__
#define INCL_DOSMODULEMGR
#include <os2.h>
#define setpgid(a,b)
#define setuid(a)
#define setgid(a)
#define SHELL "cmd.exe"
#define XINITRC "xinitrc.cmd"
#define XSERVERRC "xservrc.cmd"
char **envsave;	/* to circumvent an UNIXOS2 problem */
#define environ envsave
#endif
a58 3
extern char **environ;
char **newenviron = NULL;
char **newenvironlast = NULL;
a63 20
#ifndef HAVE_WORKING_VFORK
# ifndef vfork
#  define vfork() fork()
# endif
#else
# ifdef HAVE_VFORK_H
#  include <vfork.h>
# endif
#endif

#ifdef __UNIXOS2__
#define HAS_EXECVPE
#endif

#ifdef HAS_EXECVPE
#define Execvpe(path, argv, envp) execvpe(path, argv, envp)
#else
#define Execvpe(path, argv, envp) execvp(path, argv)
#endif

d93 2
a94 4
#define	TRUE		1
#define	FALSE		0
#define	OK_EXIT		0
#define	ERR_EXIT	1
d97 1
a97 1
static char *default_display = ":0";		/* choose most efficient */
d101 2
a102 2
static char **server = serverargv + 2;		/* make sure room for sh .xserverrc args */
static char **client = clientargv + 2;		/* make sure room for sh .xinitrc args */
d105 1
a105 3
static Display *xd = NULL;			/* server connection */
#ifndef SYSV
#if defined(__CYGWIN__) || defined(SVR4) || defined(_POSIX_SOURCE) || defined(CSRG_BASED) || defined(__UNIXOS2__) || defined(Lynx) || defined(__APPLE__)
a106 4
#else
union wait	status;
#endif
#endif /* SYSV */
d111 13
a123 14
static void Execute ( char **vec, char **envp );
static Bool waitforserver ( void );
static Bool processTimeout ( int timeout, char *string );
static int startServer ( char *server[] );
static int startClient ( char *client[] );
static int ignorexio ( Display *dpy );
static void shutdown ( void );
static void set_environment ( void );
static void Fatal(char *msg);
static void Error ( char *fmt, ... );

#ifdef RETSIGTYPE /* autoconf AC_TYPE_SIGNAL */
# define SIGVAL RETSIGTYPE
#endif /* RETSIGTYPE */
d125 1
a125 1
static SIGVAL 
d128 2
a129 2
	/* On system with POSIX signals, just interrupt the system call */
	gotSignal = sig;
d132 2
a133 2
static SIGVAL 
sigAlarm(int sig)
a134 3
#if defined(SYSV) || defined(SVR4) || defined(linux) || defined(__UNIXOS2__) || defined(__APPLE__)
	signal (sig, sigAlarm);
#endif
d137 2
a138 2
static SIGVAL
sigUsr1(int sig)
d140 2
a141 12
#if defined(SYSV) || defined(SVR4) || defined(linux) || defined(__UNIXOS2__) || defined(__APPLE__)
	signal (sig, sigUsr1);
#endif
}

static void 
Execute(char **vec,		/* has room from up above */
	char **envp)
{
    Execvpe (vec[0], vec, envp);
#ifndef __UNIXOS2__
    if (access (vec[0], R_OK) == 0) {
d144 1
a144 1
	Execvpe (vec[0], vec, envp);
a145 1
#endif
a148 1
#ifndef __UNIXOS2__
a150 4
#else
int
main(int argc, char *argv[], char *envp[])
#endif
d152 8
a159 8
	register char **sptr = server;
	register char **cptr = client;
	register char **ptr;
	int pid;
	int client_given = 0, server_given = 0;
	int client_args_given = 0, server_args_given = 0;
	int start_of_client_args, start_of_server_args;
	struct sigaction sa;
d162 1
a162 1
	vproc_transaction_t vt;
d166 72
a237 2
#ifdef __UNIXOS2__
	envsave = envp;	/* circumvent an EMX problem */
d239 47
a285 160
	/* Check whether the system will run at all */
	if (_emx_rev < 50) {
		APIRET rc;
		HMODULE hmod;
		char name[CCHMAXPATH];
		char fail[9];
		fputs ("This program requires emx.dll revision 50 (0.9c) "
			"or later.\n", stderr);
		rc = DosLoadModule (fail, sizeof (fail), "emx", &hmod);
		if (rc == 0) {
			rc = DosQueryModuleName (hmod, sizeof (name), name);
			if (rc == 0)
				fprintf (stderr, "Please delete or update `%s'.\n", name);
			DosFreeModule (hmod);
		}
		exit (2);
	}
#endif
	program = *argv++;
	argc--;
	/*
	 * copy the client args.
	 */
	if (argc == 0 ||
#ifndef __UNIXOS2__
	    (**argv != '/' && **argv != '.')) {
#else
	    (**argv != '/' && **argv != '\\' && **argv != '.' &&
	     !(isalpha(**argv) && (*argv)[1]==':'))) {
#endif
		for (ptr = default_client; *ptr; )
			*cptr++ = *ptr++;
	} else {
		client_given = 1;
	}
	start_of_client_args = (cptr - client);
	while (argc && strcmp(*argv, "--")) {
		client_args_given++;
		*cptr++ = *argv++;
		argc--;
	}
	*cptr = NULL;
	if (argc) {
		argv++;
		argc--;
	}

	/*
	 * Copy the server args.
	 */
	if (argc == 0 ||
#ifndef __UNIXOS2__
	    (**argv != '/' && **argv != '.')) {
		*sptr++ = default_server;
#else
	    (**argv != '/' && **argv != '\\' && **argv != '.' &&
	     !(isalpha(**argv) && (*argv)[1]==':'))) {
		*sptr = getenv("XSERVER");
		if (!*sptr) {
			Error("No XSERVER environment variable set");
			exit(1);
		}
		*sptr++;
#endif
	} else {
		server_given = 1;
		*sptr++ = *argv++;
		argc--;
	}
	if (argc > 0 && (argv[0][0] == ':' && isdigit(argv[0][1])))
		displayNum = *argv;
	else
		displayNum = *sptr++ = default_display;

	start_of_server_args = (sptr - server);
	while (--argc >= 0) {
		server_args_given++;
		*sptr++ = *argv++;
	}
	*sptr = NULL;

	/*
	 * if no client arguments given, check for a startup file and copy
	 * that into the argument list
	 */
	if (!client_given) {
	    char *cp;
	    Bool required = False;

	    xinitrcbuf[0] = '\0';
	    if ((cp = getenv ("XINITRC")) != NULL) {
		(void) snprintf (xinitrcbuf, sizeof(xinitrcbuf), "%s", cp);
		required = True;
	    } else if ((cp = getenv ("HOME")) != NULL) {
		(void) snprintf (xinitrcbuf, sizeof(xinitrcbuf),
				 "%s/%s", cp, XINITRC);
	    }
	    if (xinitrcbuf[0]) {
		if (access (xinitrcbuf, F_OK) == 0) {
		    client += start_of_client_args - 1;
		    client[0] = xinitrcbuf;
		} else if (required) {
		    fprintf (stderr,
			     "%s:  warning, no client init file \"%s\"\n",
			     program, xinitrcbuf);
		}
	    }
	}

	/*
	 * if no server arguments given, check for a startup file and copy
	 * that into the argument list
	 */
	if (!server_given) {
	    char *cp;
	    Bool required = False;

	    xserverrcbuf[0] = '\0';
	    if ((cp = getenv ("XSERVERRC")) != NULL) {
		(void) snprintf (xserverrcbuf, sizeof(xserverrcbuf), "%s", cp);
		required = True;
	    } else if ((cp = getenv ("HOME")) != NULL) {
		(void) snprintf (xserverrcbuf, sizeof(xserverrcbuf),
				 "%s/%s", cp, XSERVERRC);
	    }
	    if (xserverrcbuf[0]) {
		if (access (xserverrcbuf, F_OK) == 0) {
		    server += start_of_server_args - 1;
		    server[0] = xserverrcbuf;
		} else if (required) {
		    fprintf (stderr,
			     "%s:  warning, no server init file \"%s\"\n",
			     program, xserverrcbuf);
		}
	    }
	}

	/*
	 * put the display name into the environment
	 */
	set_environment ();

	/*
	 * Start the server and client.
	 */
#ifdef SIGCHLD
	signal(SIGCHLD, SIG_DFL);	/* Insurance */
#endif

	/* Let those signal interrupt the wait() call in the main loop */
	memset(&sa, 0, sizeof sa);
	sa.sa_handler = sigCatch;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;	/* do not set SA_RESTART */
	
	sigaction(SIGTERM, &sa, NULL);
	sigaction(SIGQUIT, &sa, NULL);
	sigaction(SIGINT, &sa, NULL);
	sigaction(SIGHUP, &sa, NULL);
	sigaction(SIGPIPE, &sa, NULL);
d287 2
a288 2
	signal(SIGALRM, sigAlarm);
	signal(SIGUSR1, sigUsr1);
d292 1
a292 1
	vt = vproc_transaction_begin(NULL);
d296 8
a303 8
	if (startServer(server) > 0
	 && startClient(client) > 0) {
		pid = -1;
		while (pid != clientpid && pid != serverpid
		       && gotSignal == 0
			)
			pid = wait(NULL);
	}
d307 1
a307 1
	vproc_transaction_end(NULL, vt);
d311 5
a315 5
	signal(SIGTERM, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
d317 1
a317 1
	shutdown();
d319 4
a322 4
	if (gotSignal != 0) {
		Error("unexpected signal %d.\n", gotSignal);
		exit(ERR_EXIT);
	}
d324 5
a328 5
	if (serverpid < 0 )
		Fatal("Server error.\n");
	if (clientpid < 0)
		Fatal("Client error.\n");
	exit(OK_EXIT);
d333 1
a333 1
 *	waitforserver - wait for X server to start up
d338 2
a339 2
	int	ncycles	 = 120;		/* # of cycles to wait */
	int	cycles;			/* Wait cycle count */
d342 18
a359 8
	/* For Apple, we don't get signaled by the server when it's ready, so we just
	 * want to sleep now since we're going to sleep later anyways and this allows us
	 * to avoid the awkard, "why is there an error message in the log" questions
	 * from users.
         */

	sleep(2);
#endif
d361 1
a361 9
	for (cycles = 0; cycles < ncycles; cycles++) {
		if ((xd = XOpenDisplay(displayNum))) {
			return(TRUE);
		}
		else {
		    if (!processTimeout (1, "X server to begin accepting connections")) 
		      break;
		}
	}
d363 1
a363 2
	fprintf (stderr, "giving up.\r\n");
	return(FALSE);
d372 2
a373 2
	int	i = 0, pidfound = -1;
	static char	*laststring;
d375 18
a392 30
	for (;;) {
#if defined(SYSV) || defined(__UNIXOS2__)
		alarm(1);
		if ((pidfound = wait(NULL)) == serverpid)
			break;
		alarm(0);
#else /* SYSV */
#if defined(SVR4) || defined(_POSIX_SOURCE) || defined(Lynx) || defined(__APPLE__)
		if ((pidfound = waitpid(serverpid, &status, WNOHANG)) == serverpid)
			break;
#else
		if ((pidfound = wait3(&status, WNOHANG, NULL)) == serverpid)
			break;
#endif
#endif /* SYSV */
		if (timeout) {
			if (i == 0 && string != laststring)
				fprintf(stderr, "\r\nwaiting for %s ", string);
			else
				fprintf(stderr, ".");
			fflush(stderr);
		}
		if (timeout)
			sleep (1);
		if (++i > timeout)
			break;
	}
	if ( i > 0 ) fputc( '\n', stderr );     /* tidy up after message */
	laststring = string;
	return( serverpid != pidfound );
d398 33
a430 106
	sigset_t mask, old;
#ifdef __UNIXOS2__
	sigset_t pendings;
#endif

	sigemptyset(&mask);
	sigaddset(&mask, SIGUSR1);
	sigprocmask(SIG_BLOCK, &mask, &old);

	serverpid = fork(); 

	switch(serverpid) {
	case 0:
		/* Unblock */
		sigprocmask(SIG_SETMASK, &old, NULL);

		/*
		 * don't hang on read/write to control tty
		 */
#ifdef SIGTTIN
		(void) signal(SIGTTIN, SIG_IGN);
#endif
#ifdef SIGTTOU
		(void) signal(SIGTTOU, SIG_IGN);
#endif
		/*
		 * ignore SIGUSR1 in child.  The server
		 * will notice this and send SIGUSR1 back
		 * at xinit when ready to accept connections
		 */
		(void) signal(SIGUSR1, SIG_IGN);
		/*
		 * prevent server from getting sighup from vhangup()
		 * if client is xterm -L
		 */
#ifndef __UNIXOS2__
		setpgid(0,getpid());
#endif
		Execute (server, environ);
		Error ("no server \"%s\" in PATH\n", server[0]);
		{
		    const char * const *cpp;

		    fprintf (stderr,
"\nUse the -- option, or make sure that %s is in your path and\n",
			     bindir);
		    fprintf (stderr,
"that \"%s\" is a program or a link to the right type of server\n",
			     server[0]);
		    fprintf (stderr,
"for your display.  Possible server names include:\n\n");
		    for (cpp = server_names; *cpp; cpp++) {
			fprintf (stderr, "    %s\n", *cpp);
		    }
		    fprintf (stderr, "\n");
		}
		exit (ERR_EXIT);

		break;
	case -1:
		break;
	default:
		/*
		 * don't nice server
		 */
#ifdef PRIO_PROCESS
		setpriority( PRIO_PROCESS, serverpid, -1 );
#endif

		errno = 0;
		if (! processTimeout(0, "")) {
			serverpid = -1;
			break;
		}
		/*
		 * kludge to avoid race with TCP, giving server time to
		 * set his socket options before we try to open it,
		 * either use the 15 second timeout, or await SIGUSR1.
		 *
		 * If your machine is substantially slower than 15 seconds,
		 * you can easily adjust this value.
		 */
		alarm (15);

#ifdef __UNIXOS2__
		/*
		 * fg2003/05/06: work around a problem in EMX: sigsuspend()
		 * does not deliver pending signals when called but when
		 * returning; so if SIGUSR1 has already been sent by the
		 * server, we would still have to await SIGALRM
		 */
		sigemptyset(&pendings);
		sigpending(&pendings);
		if (!sigismember(&pendings, SIGUSR1))
#endif /* __UNIXOS2__ */
		sigsuspend(&old);
		alarm (0);
		sigprocmask(SIG_SETMASK, &old, NULL);

		if (waitforserver() == 0) {
			Error("unable to connect to X server\r\n");
			shutdown();
			serverpid = -1;
		}
		break;
	}
d432 46
a477 1
	return(serverpid);
d483 76
a558 83
	/* setting WINDOWPATH for clients */
	Atom prop;
	Atom actualtype;
	int actualformat;
	unsigned long nitems;
	unsigned long bytes_after;
	unsigned char *buf;
	const char *windowpath;
	char *newwindowpath;
	unsigned long num;
	char nums[10];
	int numn;
	size_t len;
	prop = XInternAtom(xd, "XFree86_VT", False);
	if (prop == None) {
#ifdef DEBUG
		fprintf(stderr, "no XFree86_VT atom\n");
#endif
		return;
	}
	if (XGetWindowProperty(xd, DefaultRootWindow(xd), prop, 0, 1, 
		False, AnyPropertyType, &actualtype, &actualformat, 
		&nitems, &bytes_after, &buf)) {
#ifdef DEBUG
		fprintf(stderr, "no XFree86_VT property\n");
#endif
		return;
	}
	if (nitems != 1) {
#ifdef DEBUG
		fprintf(stderr, "%lu items in XFree86_VT property!\n", nitems);
#endif
		XFree(buf);
		return;
	}
	switch (actualtype) {
	case XA_CARDINAL:
	case XA_INTEGER:
	case XA_WINDOW:
		switch (actualformat) {
		case  8:
			num = (*(uint8_t  *)(void *)buf);
			break;
		case 16:
			num = (*(uint16_t *)(void *)buf);
			break;
		case 32:
			num = (*(uint32_t *)(void *)buf);
			break;
		default:
#ifdef DEBUG
			fprintf(stderr, "format %d in XFree86_VT property!\n", actualformat);
#endif
			XFree(buf);
			return;
		}
		break;
	default:
#ifdef DEBUG	    
		fprintf(stderr, "type %lx in XFree86_VT property!\n", actualtype);
#endif
		XFree(buf);
		return;
	}
	XFree(buf);
	windowpath = getenv("WINDOWPATH");
	numn = snprintf(nums, sizeof(nums), "%lu", num);
	if (!windowpath) {
		len = 10 + 1 + numn + 1;
		newwindowpath = malloc(len);
		if (newwindowpath == NULL) 
		    return;
		snprintf(newwindowpath, len, "WINDOWPATH=%s", nums);
	} else {
		len = 10 + 1 + strlen(windowpath) + 1 + numn + 1;
		newwindowpath = malloc(len);
		if (newwindowpath == NULL)
		    return;
		snprintf(newwindowpath, len, "WINDOWPATH=%s:%s", 
			 windowpath, nums);
	}
	*newenvironlast++ = newwindowpath;
	*newenvironlast = NULL;
d564 20
a583 23
	setWindowPath();
	if ((clientpid = vfork()) == 0) {
		if (setuid(getuid()) == -1) {
			Error("cannot change uid: %s\n", strerror(errno));
			_exit(ERR_EXIT);
		}
		setpgid(0, getpid());
		environ = newenviron;
#ifdef __UNIXOS2__
#undef environ
		environ = newenviron;
		client[0] = (char*)__XOS2RedirRoot(client[0]);
#endif
		Execute (client,newenviron);
		Error ("no program named \"%s\" in PATH\r\n", client[0]);
		fprintf (stderr,
"\nSpecify a program on the command line or make sure that %s\r\n", bindir);
		fprintf (stderr,
"is in your path.\r\n");
		fprintf (stderr, "\n");
		_exit (ERR_EXIT);
	}
	return (clientpid);
a585 4
#ifndef HAVE_KILLPG
#define killpg(pgrp, sig) kill(-(pgrp), sig)
#endif

d588 1
a588 1
static int 
d591 2
a592 2
    fprintf (stderr, "%s:  connection to X server lost.\r\n", program);
    longjmp (close_env, 1);
d597 1
a597 1
static void 
d600 41
a640 44
	/* have kept display opened, so close it now */
	if (clientpid > 0) {
		XSetIOErrorHandler (ignorexio);
		if (! setjmp(close_env)) {
		    XCloseDisplay(xd);
		}

		/* HUP all local clients to allow them to clean up */
		errno = 0;
		if ((killpg(clientpid, SIGHUP) != 0) &&
		    (errno != ESRCH))
			Error("can't send HUP to process group %d\r\n",
				clientpid);
	}

	if (serverpid < 0)
		return;
	errno = 0;
	if (killpg(serverpid, SIGTERM) < 0) {
		if (errno == EPERM)
			Fatal("Can't kill X server\r\n");
		if (errno == ESRCH)
			return;
	}
	if (! processTimeout(10, "X server to shut down")) {
	    fprintf (stderr, "\r\n");
	    return;
	}

	fprintf(stderr, 
	"\r\n%s:  X server slow to shut down, sending KILL signal.\r\n",
		program);
	fflush(stderr);
	errno = 0;
	if (killpg(serverpid, SIGKILL) < 0) {
		if (errno == ESRCH)
			return;
	}
	if (processTimeout(3, "server to die")) {
		fprintf (stderr, "\r\n");
		Fatal("Can't kill server\r\n");
	}
	fprintf (stderr, "\r\n");
	return;
d643 7
d651 7
a657 3
/*
 * make a new copy of environment that has room for DISPLAY
 */
d659 2
a660 2
static void 
set_environment(void)
d662 5
a666 31
    int nenvvars;
    char **newPtr, **oldPtr;
    static char displaybuf[512];

    /* count number of environment variables */
    for (oldPtr = environ; *oldPtr; oldPtr++) ;

    nenvvars = (oldPtr - environ);
    newenviron = (char **) malloc ((nenvvars + 3) * sizeof(char **));
    if (!newenviron) {
	fprintf (stderr,
		 "%s:  unable to allocate %d pointers for environment\n",
		 program, nenvvars + 3);
	exit (1);
    }

    /* put DISPLAY=displayname as first element */
    snprintf (displaybuf, sizeof(displaybuf), "DISPLAY=%s", displayNum);
    newPtr = newenviron;
    *newPtr++ = displaybuf;

    /* copy pointers to other variables */
    for (oldPtr = environ; *oldPtr; oldPtr++) {
	if (strncmp (*oldPtr, "DISPLAY=", 8) != 0
	 && strncmp (*oldPtr, "WINDOWPATH=", 11) != 0) {
	    *newPtr++ = *oldPtr;
	}
    }
    *newPtr = NULL;
    newenvironlast=newPtr;
    return;
d670 1
a670 1
Fatal(char *msg)
d672 5
a676 2
	Error(msg);
	exit(ERR_EXIT);
d680 1
a680 1
Error(char *fmt, ...)
d682 5
a686 1
        va_list ap;
d688 7
a694 6
	va_start(ap, fmt);
	fprintf(stderr, "%s:  ", program);
	if (errno > 0)
	  fprintf (stderr, "%s (errno %d):  ", strerror(errno), errno);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
@


1.7
log
@update to xinit 1.1.1
@
text
@a1 3
/* $XdotOrg: xc/programs/xinit/xinit.c,v 1.4 2005/10/04 01:27:34 ajax Exp $ */
/* $OpenBSD: xinit.c,v 1.6 2008/06/18 20:31:51 matthieu Exp $ */

a26 1
/* $XFree86: xc/programs/xinit/xinit.c,v 3.32 2002/05/31 18:46:13 dawes Exp $ */
d62 1
a62 1
#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
a101 6
/* A/UX setpgid incorrectly removes the controlling terminal.
   Per Posix, only setsid should do that. */
#ifdef macII
#define setpgid setpgrp
#endif

a113 23
#if defined(ultrix) && defined(mips)
    "Xdec        Digital color display on DECstation",
#endif
#if defined(sun) && !defined(XORG)	/* Sun */
    "Xsun        Sun BW2, CG2, CG3, CG4, or CG6 on Sun 2, 3, 4, or 386i",
    "Xsunmono    Sun BW2 on Sun 2, 3, 4, or 386i ",
    "Xsun24      Sun BW2, CG2, CG3, CG4, CG6, or CG8 on Sun 4",
#endif
#ifdef hpux				/* HP */
    "Xhp         HP monochrome and colors displays on 9000/300 series",
#endif
#ifdef ibm				/* IBM */
    "Xibm        IBM AED, APA, 8514a, megapel, VGA displays on PC/RT",
#endif
#ifdef macII				/* MacII */
    "XmacII      Apple monochrome display on Macintosh II",
#endif
#ifdef XFREE86
    "XFree86     XFree86 displays",
#endif
#ifdef XORG
    "Xorg        Common X server for most displays",
#endif
d116 6
d127 2
d237 1
a237 1
#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
a276 9
#ifdef sun
		/* 
		 * If running on a sun, and if WINDOW_PARENT isn't defined, 
		 * that means SunWindows isn't running, so we should pass 
		 * the -C flag to xterm so that it sets up a console.
		 */
		if ( getenv("WINDOW_PARENT") == NULL )
		    *cptr++ = "-C";
#endif /* sun */
d410 1
a410 1
#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
d425 1
a425 1
#if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060
@


1.6
log
@update to xinit 1.1.0.
@
text
@d3 1
a3 1
/* $OpenBSD: xinit.c,v 1.5 2008/04/20 13:46:02 matthieu Exp $ */
d64 7
d261 5
d442 7
d457 7
d494 10
d509 1
a509 2
#define MSG "X server to begin accepting connections"
		    if (!processTimeout (1, MSG)) 
a510 1
#undef MSG
@


1.5
log
@Update to xinit-1.0.8, while preserving local changes.
@
text
@d3 1
a3 1
/* $OpenBSD: xinit.c,v 1.4 2008/04/20 13:25:46 matthieu Exp $ */
a42 6
#ifdef __APPLE__
#include <CoreServices/CoreServices.h>
#define kX11AppBundleId "org.x.X11"
#define kX11AppBundlePath "/Contents/MacOS/X11"
#endif

a173 3
#ifdef __APPLE__
static char x11_path[PATH_MAX];
#endif
a222 34
#ifdef __APPLE__
static void set_x11_path() {
    CFURLRef appURL = NULL;
    OSStatus osstatus = LSFindApplicationForInfo(kLSUnknownCreator, CFSTR(kX11AppBundleId), nil, nil, &appURL);

    switch (osstatus) {
        case noErr:
            if (appURL == NULL) {
                fprintf(stderr, "xinit: Invalid response from LSFindApplicationForInfo(%s)\n", 
                        kX11AppBundleId);
                exit(1);
            }
            
            if (!CFURLGetFileSystemRepresentation(appURL, true, (unsigned char *)x11_path, sizeof(x11_path))) {
                fprintf(stderr, "xinit: Error resolving URL for %s\n", kX11AppBundleId);
                exit(2);
            }
            
            strlcat(x11_path, kX11AppBundlePath, sizeof(x11_path));
#ifdef DEBUG
            fprintf(stderr, "xinit: X11.app = %s\n", x11_path);
#endif
            break;
        case kLSApplicationNotFoundErr:
            fprintf(stderr, "xinit: Unable to find application for %s\n", kX11AppBundleId);
            exit(4);
        default:
            fprintf(stderr, "xinit: Unable to find application for %s, error code = %d\n", 
                    kX11AppBundleId, (int)osstatus);
            exit(5);
    }
}
#endif

d227 1
a227 12
    char *file = vec[0];
#ifdef __APPLE__
    /* This is ugly, but currently, we need to trick OS-X into thinking X is in
     * the X11.app bundle.  Hopefully UI, icons, etc will eventually be set
     * by Xquartz, but this is how we're doing it for now. -JH
     */
    if(!strcmp(file, "/usr/X11/bin/X") || !strcmp(file, "/usr/X11/bin/Xquartz") || !strcmp(file, "X") || !strcmp(file, "Xquartz")) {
        vec[0] = x11_path;
        fprintf(stderr, "xinit: Detected Xquartz startup, setting file=%s, argv[0]=%s\n", file, vec[0]);
    }
#endif
    Execvpe (file, vec, envp);
a254 4
#ifdef __APPLE__
    set_x11_path();
#endif

d358 1
a358 1
		strcpy (xinitrcbuf, cp);
d361 2
a362 1
		(void) sprintf (xinitrcbuf, "%s/%s", cp, XINITRC);
d386 1
a386 1
		strcpy (xserverrcbuf, cp);
d389 2
a390 1
		(void) sprintf (xserverrcbuf, "%s/%s", cp, XSERVERRC);
d653 1
d709 5
a713 2
		newwindowpath = malloc(10 + 1 + numn + 1);
		sprintf(newwindowpath, "WINDOWPATH=%s", nums);
d715 6
a720 2
		newwindowpath = malloc(10 + 1 + strlen(windowpath) + 1 + numn + 1);
		sprintf(newwindowpath, "WINDOWPATH=%s:%s", windowpath, nums);
d843 1
a843 2
    strcpy (displaybuf, "DISPLAY=");
    strcpy (displaybuf + 8, displayNum);
@


1.4
log
@Get rid of the Xwrapper hack. OpenBSD doesn't support XFree86 3.3.x anymore.
@
text
@d3 1
a3 1
/* $OpenBSD: xinit.c,v 1.3 2007/09/15 17:12:01 matthieu Exp $ */
d43 6
d146 2
a147 4
#ifdef __DARWIN__
    "XDarwin         Darwin/Mac OS X IOKit displays",
    "XDarwinQuartz   Mac OS X Quartz displays",
    "XDarwinStartup  Auto-select between XDarwin and XDarwinQuartz",
d150 1
d170 13
a182 10
char *default_server = "X";
char *default_display = ":0";		/* choose most efficient */
char *default_client[] = {"xterm", "-geometry", "+1+1", "-n", "login", NULL};
char *serverargv[100];
char *clientargv[100];
char **server = serverargv + 2;		/* make sure room for sh .xserverrc args */
char **client = clientargv + 2;		/* make sure room for sh .xinitrc args */
char *displayNum;
char *program;
Display *xd;			/* server connection */
d184 1
a184 1
#if defined(__CYGWIN__) || defined(SVR4) || defined(_POSIX_SOURCE) || defined(CSRG_BASED) || defined(__UNIXOS2__) || defined(Lynx)
d219 1
a219 1
#if defined(SYSV) || defined(SVR4) || defined(linux) || defined(__UNIXOS2__)
d227 1
a227 1
#if defined(SYSV) || defined(SVR4) || defined(linux) || defined(__UNIXOS2__)
d232 34
d270 12
a281 1
    Execvpe (vec[0], vec, envp);
d309 4
a459 1

d556 1
a556 1
#if defined(SVR4) || defined(_POSIX_SOURCE) || defined(Lynx)
d876 1
a876 1
    static char displaybuf[256];
@


1.3
log
@merge xinit 1.0.6
@
text
@d3 1
a3 1
/* $OpenBSD: xinit.c,v 1.2 2006/11/26 17:17:57 matthieu Exp $ */
a41 1
#include <sys/param.h>
a164 3
char *default_wrapper = BINDIR "/Xwrapper";
char real_server[MAXPATHLEN];
char test_path[MAXPATHLEN];
d250 1
a250 2
	char *path, *p;
	int pid, n;
d321 1
a321 30
	    /* hack for the Xfree86 3.3.6 servers: if the X link 
	       points to XF86_*, start Xwrapper instead of X */
		path = strdup(getenv("PATH"));
		if (path == NULL) {
		    Error("Can't find PATH\n");
		    exit(1);
		}
		/* Walk through the PATH */
		for (p = strtok(path, ":"); p != NULL; p = strtok(NULL, ":")) {
		    strlcpy(test_path, p, sizeof(test_path));
		    strlcat(test_path, "/", sizeof(test_path));
		    strlcat(test_path, default_server, sizeof(test_path));
		    if ((n = readlink(test_path, real_server, 
				 sizeof(real_server) - 1)) > 0) {
			real_server[n] = '\0';
			/* if the target path contains XF86_, we 
			   need Xwrapper */
			if (strstr(real_server, "XF86_") != NULL) {
			    *sptr++ = default_wrapper;
			} else {
			    *sptr++ = default_server;
			}
			break;
		    }
		}
		if (p == NULL) {
		    Error("Can't find X link\n");
		    exit(1);
		}
		free(path);
@


1.2
log
@OpenBSD customization:
- hack for XFree86 3.3.x X servers
- ssh-agent integration
- fvwm default window manager
@
text
@d3 1
a3 1
/* $OpenBSD: xinit.c,v 1.10 2006/01/21 22:12:13 matthieu Exp $ */
d38 1
d41 1
d84 1
d90 8
a97 8
#if !defined(HAS_VFORK) /* Imake */ && !defined(HAVE_WORKING_VFORK) /* autoconf*/
#ifndef vfork
#define vfork() fork()
#endif
#else
#if (defined(sun) && !defined(SVR4)) || defined(HAVE_VFORK_H)
#include <vfork.h>
#endif
d102 2
a103 2
#if !defined(X_NOT_POSIX) && !defined(macII)
#define setpgrp setpgid
d116 2
a117 2
char *bindir = BINDIR;
char *server_names[] = {
d121 1
a121 1
#ifdef sun				/* Sun */
d139 1
a139 1
    "Xorg	 X.Org displays",
d146 3
a148 1
    
a187 1
#ifndef X_NOT_POSIX
a188 1
#endif
a202 6
#else /* Imake */
#ifdef SIGNALRETURNSINT
#define SIGVAL int
#else
#define SIGVAL void
#endif
a204 9
#ifdef X_NOT_POSIX
/* Can't use Error() in signal handlers */
#ifndef STDERR_FILENO
#define WRITES(s) write(STDERR_FILENO, (s), strlen(s))
#else
#define WRITES(s) write(fileno(stderr), (s), strlen(s))
#endif
#endif

a207 14
#ifdef X_NOT_POSIX
	char buf[1024];

	signal(SIGTERM, SIG_IGN);
	signal(SIGQUIT, SIG_IGN);
	signal(SIGINT, SIG_IGN);
	signal(SIGHUP, SIG_IGN);
	signal(SIGPIPE, SIG_IGN);
	snprintf(buf, sizeof buf, "%s: unexpected signal %d\r\n", 
		 program, sig);
	WRITES(buf);
	shutdown();
	_exit(ERR_EXIT);
#else
a209 1
#endif
a258 1
#ifndef X_NOT_POSIX
a259 1
#endif
d449 1
a449 7
#ifdef X_NOT_POSIX
	signal(SIGTERM, sigCatch);
	signal(SIGQUIT, sigCatch);
	signal(SIGINT, sigCatch);
	signal(SIGHUP, sigCatch);
	signal(SIGPIPE, sigCatch);
#else
d461 1
a461 1
#endif
a467 1
#ifndef X_NOT_POSIX
a468 1
#endif
d479 1
a479 1
#ifndef X_NOT_POSIX
d484 1
a484 1
#endif
a561 1
#if !defined(X_NOT_POSIX)
a562 3
#else
	int old;
#endif
a566 1
#if !defined(X_NOT_POSIX)
d570 1
a570 3
#else
	old = sigblock (sigmask (SIGUSR1));
#endif
a575 1
#ifndef X_NOT_POSIX
a576 3
#else
		sigsetmask (old);
#endif
d598 1
a598 1
		setpgrp(0,getpid());
d603 1
a603 1
		    char **cpp;
a645 1
#ifndef X_NOT_POSIX
a659 5
#else
		sigpause (old);
		alarm (0);
		sigsetmask (old);
#endif
d672 80
d755 1
d761 1
a761 1
		setpgrp(0, getpid());
d780 1
a780 1
#if !defined(X_NOT_POSIX) || defined(SYSV) || defined(__UNIXOS2__)
d860 1
a860 1
    newenviron = (char **) malloc ((nenvvars + 2) * sizeof(char **));
d864 1
a864 1
		 program, nenvvars + 2);
d876 2
a877 1
	if (strncmp (*oldPtr, "DISPLAY=", 8) != 0) {
d882 1
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
/* $XdotOrg: $ */
d40 1
d161 3
d281 2
a282 1
	int pid;
d355 30
a384 1
		*sptr++ = default_server;
@


1.1.1.1
log
@Importing from X.Org indiviual releases
@
text
@@


1.1.1.2
log
@xinit 1.0.6
@
text
@a36 1
#include <X11/Xatom.h>
a38 1
#include <stdint.h>
a79 1
char **newenvironlast = NULL;
d85 8
a92 8
#ifndef HAVE_WORKING_VFORK
# ifndef vfork
#  define vfork() fork()
# endif
#else
# ifdef HAVE_VFORK_H
#  include <vfork.h>
# endif
d97 2
a98 2
#ifdef macII
#define setpgid setpgrp
d111 2
a112 2
const char *bindir = BINDIR;
const char * const server_names[] = {
d116 1
a116 1
#if defined(sun) && !defined(XORG)	/* Sun */
d134 1
a134 1
    "Xorg        Common X server for most displays",
d141 1
a141 3
    "Xvfb        Virtual frame buffer",
    "Xnest       X server nested in a window on another X server",
    "Xephyr      kdrive-based nested X server",
d178 1
d180 1
d195 6
d203 9
d215 14
d231 1
d280 1
d282 1
d443 7
a449 1

d461 1
a461 1

d468 1
d470 1
d481 1
a481 1

d486 1
a486 1

d564 1
d566 3
d573 1
d577 3
a579 1

d585 1
d587 3
d611 1
a611 1
		setpgid(0,getpid());
d616 1
a616 1
		    const char * const *cpp;
d659 1
d674 5
a690 80
static void
setWindowPath(void)
{
	/* setting WINDOWPATH for clients */
	Atom prop;
	Atom actualtype;
	int actualformat;
	unsigned long nitems;
	unsigned long bytes_after;
	unsigned char *buf;
	const char *windowpath;
	char *newwindowpath;
	unsigned long num;
	char nums[10];
	int numn;
	prop = XInternAtom(xd, "XFree86_VT", False);
	if (prop == None) {
#ifdef DEBUG
		fprintf(stderr, "no XFree86_VT atom\n");
#endif
		return;
	}
	if (XGetWindowProperty(xd, DefaultRootWindow(xd), prop, 0, 1, 
		False, AnyPropertyType, &actualtype, &actualformat, 
		&nitems, &bytes_after, &buf)) {
#ifdef DEBUG
		fprintf(stderr, "no XFree86_VT property\n");
#endif
		return;
	}
	if (nitems != 1) {
#ifdef DEBUG
		fprintf(stderr, "%lu items in XFree86_VT property!\n", nitems);
#endif
		XFree(buf);
		return;
	}
	switch (actualtype) {
	case XA_CARDINAL:
	case XA_INTEGER:
	case XA_WINDOW:
		switch (actualformat) {
		case  8:
			num = (*(uint8_t  *)(void *)buf);
			break;
		case 16:
			num = (*(uint16_t *)(void *)buf);
			break;
		case 32:
			num = (*(uint32_t *)(void *)buf);
			break;
		default:
#ifdef DEBUG
			fprintf(stderr, "format %d in XFree86_VT property!\n", actualformat);
#endif
			XFree(buf);
			return;
		}
		break;
	default:
#ifdef DEBUG	    
		fprintf(stderr, "type %lx in XFree86_VT property!\n", actualtype);
#endif
		XFree(buf);
		return;
	}
	XFree(buf);
	windowpath = getenv("WINDOWPATH");
	numn = snprintf(nums, sizeof(nums), "%lu", num);
	if (!windowpath) {
		newwindowpath = malloc(10 + 1 + numn + 1);
		sprintf(newwindowpath, "WINDOWPATH=%s", nums);
	} else {
		newwindowpath = malloc(10 + 1 + strlen(windowpath) + 1 + numn + 1);
		sprintf(newwindowpath, "WINDOWPATH=%s:%s", windowpath, nums);
	}
	*newenvironlast++ = newwindowpath;
	*newenvironlast = NULL;
}

a693 1
	setWindowPath();
d699 1
a699 1
		setpgid(0, getpid());
d718 1
a718 1
#ifndef HAVE_KILLPG
d798 1
a798 1
    newenviron = (char **) malloc ((nenvvars + 3) * sizeof(char **));
d802 1
a802 1
		 program, nenvvars + 3);
d814 1
a814 2
	if (strncmp (*oldPtr, "DISPLAY=", 8) != 0
	 && strncmp (*oldPtr, "WINDOWPATH=", 11) != 0) {
a818 1
    newenvironlast=newPtr;
@

