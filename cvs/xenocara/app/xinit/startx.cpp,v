head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.6
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.2
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.2
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.11.0.6
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.2
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	v1_0_6:1.1.1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	v1_0_3:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@// @;


1.16
date	2015.06.14.10.33.02;	author matthieu;	state Exp;
branches;
next	1.15;
commitid	y2rjijuotLP1x0Wk;

1.15
date	2015.01.30.10.51.41;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	qvJrRgtj73rnObCD;

1.14
date	2015.01.25.11.37.58;	author matthieu;	state Exp;
branches;
next	1.13;
commitid	rIxERYrEVqNpd9Ck;

1.13
date	2013.09.14.09.16.24;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2013.05.31.21.44.42;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.10.31.14.00.14;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.01.08.52.28;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.31.20.23.19;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.03.13.17.37;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.18.20.31.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.20.13.46.02;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2007.09.28.20.22.10;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2007.09.28.20.12.18;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.15.17.12.01;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.26.17.17.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.14.47.25;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.14.47.25;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.09.15.17.05.32;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Use mktemp to create .serverauth file. Inspired by Debian patches
@
text
@XCOMM!SHELL_CMD

XCOMM
XCOMM This is just a sample implementation of a slightly less primitive
XCOMM interface than xinit.  It looks for user .xinitrc and .xserverrc
XCOMM files, then system xinitrc and xserverrc files, else lets xinit choose
XCOMM its default.  The system xinitrc should probably do things like check
XCOMM for .Xresources files and merge them in, start up a window manager,
XCOMM and pop a clock and several xterms.
XCOMM
XCOMM Site administrators are STRONGLY urged to write nicer versions.
XCOMM

unset DBUS_SESSION_BUS_ADDRESS
unset SESSION_MANAGER

#ifdef __APPLE__

XCOMM Check for /usr/bin/X11 and BINDIR in the path, if not add them.
XCOMM This allows startx to be placed in a place like /usr/bin or /usr/local/bin
XCOMM and people may use X without changing their PATH.
XCOMM Note that we put our own bin directory at the front of the path, and
XCOMM the standard system path at the back, since if you are using the Xorg
XCOMM server there's a pretty good chance you want to bias the Xorg clients
XCOMM over the old system's clients.

XCOMM First our compiled path
bindir=__bindir__

case $PATH in
    *:$bindir | *:$bindir:* | $bindir:*) ;;
    *) PATH=$bindir:$PATH ;;
esac

XCOMM Now the "old" compiled path
oldbindir=/usr/X11R6/bin

if [ -d "$oldbindir" ] ; then
    case $PATH in
        *:$oldbindir | *:$oldbindir:* | $oldbindir:*) ;;
        *) PATH=$PATH:$oldbindir ;;
    esac
fi

XCOMM Bourne shell does not automatically export modified environment variables
XCOMM so export the new PATH just in case the user changes the shell
export PATH
#endif

userclientrc=$HOME/.xinitrc
sysclientrc=XINITDIR/xinitrc

userserverrc=$HOME/.xserverrc
sysserverrc=XINITDIR/xserverrc
defaultclient=XTERM
defaultserver=XSERVER
defaultclientargs=""
defaultserverargs=""
defaultdisplay=":0"
clientargs=""
serverargs=""
vtarg=""

#ifdef __APPLE__

if [ "x$X11_PREFS_DOMAIN" = x ] ; then
    export X11_PREFS_DOMAIN=BUNDLE_ID_PREFIX".X11"
fi

XCOMM Initialize defaults (this will cut down on "safe" error messages)
if ! defaults read $X11_PREFS_DOMAIN cache_fonts > /dev/null 2>&1 ; then
    defaults write $X11_PREFS_DOMAIN cache_fonts -bool true
fi

if ! defaults read $X11_PREFS_DOMAIN no_auth > /dev/null 2>&1 ; then
    defaults write $X11_PREFS_DOMAIN no_auth -bool false
fi

if ! defaults read $X11_PREFS_DOMAIN nolisten_tcp > /dev/null 2>&1 ; then
    defaults write $X11_PREFS_DOMAIN nolisten_tcp -bool true
fi

XCOMM First, start caching fonts
if [ x`defaults read $X11_PREFS_DOMAIN cache_fonts` = x1 ] ; then
    if [ -x $bindir/font_cache ] ; then
        $bindir/font_cache &
    elif [ -x $bindir/font_cache.sh ] ; then
        $bindir/font_cache.sh &
    elif [ -x $bindir/fc-cache ] ; then
        $bindir/fc-cache &
    fi
fi

if [ -x XINITDIR/privileged_startx ] ; then
	# Don't push this into the background becasue it can cause
	# a race to create /tmp/.X11-unix
	XINITDIR/privileged_startx
fi

if [ x`defaults read $X11_PREFS_DOMAIN no_auth` = x0 ] ; then
    enable_xauth=1
else
    enable_xauth=0
fi

if [ x`defaults read $X11_PREFS_DOMAIN nolisten_tcp` = x1 ] ; then
    defaultserverargs="$defaultserverargs -nolisten tcp"
fi

XCOMM The second check is the real one.  The first is to hopefully avoid
XCOMM needless syslog spamming.
if defaults read $X11_PREFS_DOMAIN 2> /dev/null | grep -q 'dpi' && defaults read $X11_PREFS_DOMAIN dpi > /dev/null 2>&1 ; then
    defaultserverargs="$defaultserverargs -dpi `defaults read $X11_PREFS_DOMAIN dpi`"
fi

#else
enable_xauth=1
#endif

XCOMM Automatically determine an unused $DISPLAY
d=0
while true ; do
    [ -e /tmp/.X$d-lock ] || break
    d=$(($d + 1))
done
defaultdisplay=":$d"
unset d

whoseargs="client"
while [ x"$1" != x ]; do
    case "$1" in
    XCOMM '' required to prevent cpp from treating "/*" as a C comment.
    /''*|\./''*)
	if [ "$whoseargs" = "client" ]; then
	    if [ x"$client" = x ] && [ x"$clientargs" = x ]; then
		client="$1"
	    else
		clientargs="$clientargs $1"
	    fi
	else
	    if [ x"$server" = x ] && [ x"$serverargs" = x ]; then
		server="$1"
	    else
		serverargs="$serverargs $1"
	    fi
	fi
	;;
    --)
	whoseargs="server"
	;;
    *)
	if [ "$whoseargs" = "client" ]; then
	    clientargs="$clientargs $1"
	else
	    XCOMM display must be the FIRST server argument
	    if [ x"$serverargs" = x ] && @@@@
		 expr "$1" : ':[0-9][0-9]*$' > /dev/null 2>&1; then
		display="$1"
	    else
		serverargs="$serverargs $1"
	    fi
	fi
	;;
    esac
    shift
done

XCOMM process client arguments
if [ x"$client" = x ]; then
    client=$defaultclient

    XCOMM For compatibility reasons, only use startxrc if there were no client command line arguments
    if [ x"$clientargs" = x ]; then
        if [ -f "$userclientrc" ]; then
            client=$userclientrc
        elif [ -f "$sysclientrc" ]; then
            client=$sysclientrc
        fi
    fi
fi

XCOMM if no client arguments, use defaults
if [ x"$clientargs" = x ]; then
    clientargs=$defaultclientargs
fi

XCOMM process server arguments
if [ x"$server" = x ]; then
    server=$defaultserver

#ifdef __linux__
    XCOMM When starting the defaultserver start X on the current tty to avoid
    XCOMM the startx session being seen as inactive:
    XCOMM "https://bugzilla.redhat.com/show_bug.cgi?id=806491"
    tty=$(tty)
    if expr "$tty" : '/dev/tty[0-9][0-9]*$' > /dev/null; then
        tty_num=$(echo "$tty" | grep -oE '[0-9]+$')
        vtarg="vt$tty_num"
    fi
#endif

    XCOMM For compatibility reasons, only use xserverrc if there were no server command line arguments
    if [ x"$serverargs" = x -a x"$display" = x ]; then
	if [ -f "$userserverrc" ]; then
	    server=$userserverrc
	elif [ -f "$sysserverrc" ]; then
	    server=$sysserverrc
	fi
    fi
fi

XCOMM if no server arguments, use defaults
if [ x"$serverargs" = x ]; then
    serverargs=$defaultserverargs
fi

XCOMM if no vt is specified add vtarg (which may be empty)
have_vtarg="no"
for i in $serverargs; do
    if expr "$i" : 'vt[0-9][0-9]*$' > /dev/null; then
        have_vtarg="yes"
    fi
done
if [ "$have_vtarg" = "no" ]; then
    serverargs="$serverargs $vtarg"
fi

XCOMM if no display, use default
if [ x"$display" = x ]; then
    display=$defaultdisplay
fi

if [ x"$enable_xauth" = x1 ] ; then
    if [ x"$XAUTHORITY" = x ]; then
        XAUTHORITY=$HOME/.Xauthority
        export XAUTHORITY
    fi

    removelist=

    XCOMM set up default Xauth info for this machine
    case `uname` in
    Linux*)
        if [ -z "`hostname --version 2>&1 | grep GNU`" ]; then
            hostname=`hostname -f`
        else
            hostname=`hostname`
        fi
        ;;
    *)
        hostname=`hostname`
        ;;
    esac

    authdisplay=${display:-:0}
#if defined(HAS_COOKIE_MAKER) && defined(MK_COOKIE)
    mcookie=`MK_COOKIE`
#else
    if [ -r /dev/urandom ]; then
        mcookie=`dd if=/dev/urandom bs=16 count=1 2>/dev/null | hexdump -e \\"%08x\\"`
    else
        mcookie=`dd if=/dev/random bs=16 count=1 2>/dev/null | hexdump -e \\"%08x\\"`
    fi
#endif
    if test x"$mcookie" = x; then
        echo "Couldn't create cookie"
        exit 1
    fi
    dummy=0

    XCOMM create a file with auth information for the server. ':0' is a dummy.
    xserverauthfile=`mktemp ${HOME}/.serverauth.XXXXXXXXXX`
    trap "rm -f '$xserverauthfile'" HUP INT QUIT ILL TRAP KILL BUS TERM
    xauth -q -f "$xserverauthfile" << EOF
add :$dummy . $mcookie
EOF
#if defined(__APPLE__) || defined(__CYGWIN__)
    xserverauthfilequoted=$(echo ${xserverauthfile} | sed "s/'/'\\\\''/g")
    serverargs=${serverargs}" -auth '"${xserverauthfilequoted}"'"
#else
    serverargs=${serverargs}" -auth "${xserverauthfile}
#endif

    XCOMM now add the same credentials to the client authority file
    XCOMM if '$displayname' already exists do not overwrite it as another
    XCOMM server man need it. Add them to the '$xserverauthfile' instead.
    for displayname in $authdisplay $hostname$authdisplay; do
        authcookie=`XAUTH list "$displayname" @@@@
        | sed -n "s/.*$displayname[[:space:]*].*[[:space:]*]//p"` 2>/dev/null;
        if [ "z${authcookie}" = "z" ] ; then
            XAUTH -q << EOF 
add $displayname . $mcookie
EOF
        removelist="$displayname $removelist"
        else
            dummy=$(($dummy+1));
            XAUTH -q -f "$xserverauthfile" << EOF
add :$dummy . $authcookie
EOF
        fi
    done
fi

#if defined(__APPLE__) || defined(__CYGWIN__)
eval XINIT \"$client\" $clientargs -- \"$server\" $display $serverargs
#else
XINIT "$client" $clientargs -- "$server" $display $serverargs
#endif
retval=$?

if [ x"$enable_xauth" = x1 ] ; then
    if [ x"$removelist" != x ]; then
        XAUTH remove $removelist
    fi
    if [ x"$xserverauthfile" != x ]; then
        rm -f "$xserverauthfile"
    fi
fi

/*
 * various machines need special cleaning up
 */
#ifdef __linux__
if command -v deallocvt > /dev/null 2>&1; then
    deallocvt
fi
#endif

#ifdef macII
Xrepair
screenrestore
#endif

#if defined(sun)
kbd_mode -a
#endif

exit $retval
@


1.15
log
@Avoid GNU expr extensions.  Already committed upstream.

ok matthieu@@
@
text
@d272 1
a272 1
    xserverauthfile=$HOME/.serverauth.$$
a338 1

@


1.14
log
@Update to xinit 1.3.4
@
text
@d196 1
a196 1
    if expr match "$tty" '^/dev/tty[0-9]\+$' > /dev/null; then
d220 1
a220 1
    if expr match "$i" '^vt[0-9]\+$' > /dev/null; then
@


1.13
log
@Update to xinit 1.3.3
@
text
@d17 1
a17 1
#if defined(__SCO__) || defined(__UNIXWARE__) || defined(__APPLE__)
a35 1
#ifdef __APPLE__
a36 3
#else
oldbindir=/usr/bin/X11
#endif
a49 15
#if defined(__SCO__) || defined(__UNIXWARE__)
XCOMM Set up the XMERGE env var so that dos merge is happy under X

if [ -f /usr/lib/merge/xmergeset.sh ]; then
	. /usr/lib/merge/xmergeset.sh
elif [ -f /usr/lib/merge/console.disp ]; then
	XMERGE=`cat /usr/lib/merge/console.disp`
	export XMERGE
fi

userclientrc=$HOME/.startxrc
sysclientrc=LIBDIR/sys.startxrc
scouserclientrc=$HOME/.xinitrc
scosysclientrc=XINITDIR/xinitrc
#else
a51 1
#endif
d62 1
a128 15
#if defined(__SCO__) || defined(__UNIXWARE__)

XCOMM SCO -t option: do not start an X server
case $1 in
  -t)   if [ -n "$DISPLAY" ]; then
                REMOTE_SERVER=TRUE
                shift
        else
                echo "DISPLAY environment variable not set"
                exit 1
        fi
        ;;
esac
#endif

a177 6
#if defined(__SCO__) || defined(__UNIXWARE__)
        elif [ -f "$scouserclientrc" ]; then
            client=$scouserclientrc
        elif [ -f "$scosysclientrc" ]; then
            client=$scosysclientrc
#endif
d191 11
d217 11
a303 8
#if defined(__SCO__) || defined(__UNIXWARE__)
if [ "$REMOTE_SERVER" = "TRUE" ]; then
        exec SHELL_CMD ${client}
else
        XINIT "$client" $clientargs -- "$server" $display $serverargs
fi
#else

a307 2
#endif

@


1.12
log
@Update to xinit 1.3.2
@
text
@d129 3
a131 1
if defaults read $X11_PREFS_DOMAIN dpi > /dev/null 2>&1 ; then
@


1.11
log
@Update to xinit 1.3.1
@
text
@d133 5
a145 4
#else
enable_xauth=1
#endif

d204 1
a204 1
    XCOMM if no client arguments either, use rc file instead
d217 2
d220 3
a222 2
        clientargs=$defaultclientargs
    fi
d229 1
a229 1
    XCOMM if no server arguments or display either, use defaults
a230 1
	XCOMM For compatibility reasons, only use xserverrc if there were no server command line arguments
d236 7
d244 3
a246 3
	serverargs=$defaultserverargs
	display=$defaultdisplay
    fi
@


1.10
log
@Update to xinit 1.3.0
@
text
@d8 2
a9 2
XCOMM for .Xresources files and merge them in, startup up a window manager,
XCOMM and pop a clock and serveral xterms.
d24 1
a24 1
XCOMM server theres a pretty good chance you want to bias the Xorg clients
d86 1
a86 1
    export X11_PREFS_DOMAIN=LAUNCHD_ID_PREFIX".X11"
@


1.9
log
@Update to xinit 1.2.1
@
text
@d90 1
a90 1
if ! defaults read $X11_PREFS_DOMAIN cache_fonts >& /dev/null ; then
d94 1
a94 1
if ! defaults read $X11_PREFS_DOMAIN no_auth >& /dev/null ; then
d98 1
a98 1
if ! defaults read $X11_PREFS_DOMAIN nolisten_tcp >& /dev/null ; then
d129 1
a129 1
if defaults read $X11_PREFS_DOMAIN dpi >& /dev/null ; then
d133 4
a136 2
for ((d=0; ; d++)) ; do
    [[ -e /tmp/.X$d-lock ]] || break
d139 1
d284 2
a285 1
    serverargs=${serverargs}" -auth '"${xserverauthfile//\'/\'\\\'\'}"'"
@


1.8
log
@update to xinit 1.1.1
@
text
@a2 1
XCOMM $Xorg: startx.cpp,v 1.3 2000/08/17 19:54:29 cpqbld Exp $
a12 1
XCOMM $XFree86: xc/programs/xinit/startx.cpp,v 3.16tsi Exp $
d86 1
a86 1
    X11_PREFS_DOMAIN="org.x.X11"
d163 1
a163 1
	    if [ x"$clientargs" = x ]; then
d169 1
a169 1
	    if [ x"$serverargs" = x ]; then
d280 2
a281 2
#ifdef __APPLE__
    serverargs=${serverargs}" -auth '"${xserverauthfile}"'"
d314 1
a314 1
#ifdef __APPLE__
d321 1
d349 3
@


1.7
log
@update to xinit 1.1.0.
@
text
@d87 4
d92 2
a93 2
if ! defaults read org.x.X11 cache_fonts >& /dev/null ; then
    defaults write org.x.X11 cache_fonts -bool true
d96 2
a97 2
if ! defaults read org.x.X11 no_auth >& /dev/null ; then
    defaults write org.x.X11 no_auth -bool false
d100 2
a101 2
if ! defaults read org.x.X11 nolisten_tcp >& /dev/null ; then
    defaults write org.x.X11 nolisten_tcp -bool true
d105 7
a111 7
if [ x`defaults read org.x.X11 cache_fonts` = x1 ] ; then
    if [ -x /usr/X11/bin/font_cache ] ; then
        /usr/X11/bin/font_cache &
    elif [ -x /usr/X11/bin/font_cache.sh ] ; then
        /usr/X11/bin/font_cache.sh &
    elif [ -x /usr/X11/bin/fc-cache ] ; then
        /usr/X11/bin/fc-cache &
d121 1
a121 1
if [ x`defaults read org.x.X11 no_auth` = x0 ] ; then
d127 1
a127 1
if [ x`defaults read org.x.X11 nolisten_tcp` = x1 ] ; then
d131 4
a143 13

if [ -f $userclientrc ]; then
    defaultclientargs=$userclientrc
elif [ -f $sysclientrc ]; then
    defaultclientargs=$sysclientrc
#if defined(__SCO__) || defined(__UNIXWARE__)
elif [ -f $scouserclientrc ]; then
    defaultclientargs=$scouserclientrc
elif [ -f $scosysclientrc ]; then
    defaultclientargs=$scosysclientrc
#endif
fi

d200 2
d204 13
a216 3
	client="$defaultclientargs"
    else
	client=$defaultclient
d227 1
a227 1
	if [ -f $userserverrc ]; then
d229 1
a229 1
	elif [ -f $sysserverrc ]; then
d278 2
a279 2
    trap "rm -f $xserverauthfile" HUP INT QUIT ILL TRAP KILL BUS TERM
    xauth -q -f $xserverauthfile << EOF
d282 3
d286 1
d301 1
a301 1
            XAUTH -q -f $xserverauthfile << EOF
d312 1
a312 1
        XINIT $client $clientargs -- $server $display $serverargs
d315 7
a321 1
XINIT $client $clientargs -- $server $display $serverargs
d329 1
a329 1
        rm -f $xserverauthfile
@


1.6
log
@Update to xinit-1.0.8, while preserving local changes.
@
text
@d16 3
d81 1
d102 3
a104 1
    if [ -x /usr/X11/bin/font_cache.sh ] ; then
d111 6
a163 6
if [ -f $userserverrc ]; then
    defaultserverargs=$userserverrc
elif [ -f $sysserverrc ]; then
    defaultserverargs=$sysserverrc
fi

d215 3
a217 1
    XCOMM if no server arguments or display either, use rc file instead
d219 9
a227 6
	server="$defaultserverargs"
#ifdef __APPLE__
	display="$defaultdisplay"
#endif
    else
	server=$defaultserver
d257 6
a262 1
    mcookie=`dd if=/dev/random bs=16 count=1 2>/dev/null | hexdump -e \\"%08x\\"`
a266 1
#endif
@


1.5
log
@revert previous. This is not the good place to patch.
@
text
@d16 1
a16 1
#if defined(__SCO__) || defined(__UNIXWARE__)
d22 1
a22 1
XCOMM the standard SCO path at the back, since if you are using the Xorg
d24 1
a24 1
XCOMM over the old SCO X11R5 clients.
d27 1
a27 3

bindir=BINDIR
scobindir=/usr/bin/X11
d30 2
a31 2
  *:$bindir | *:$bindir:* | $bindir:*) ;;
  *) PATH=$bindir:$PATH ;;
d34 6
a39 1
XCOMM Now the "SCO" compiled path
d41 6
a46 4
case $PATH in
  *:$scobindir | *:$scobindir:* | $scobindir:*) ;;
  *) PATH=$PATH:$scobindir ;;
esac
d51 1
d53 1
d81 44
d212 3
d220 7
a226 4
if [ x"$XAUTHORITY" = x ]; then
    XAUTHORITY=$HOME/.Xauthority
    export XAUTHORITY
fi
d228 13
a240 15
removelist=

XCOMM set up default Xauth info for this machine
case `uname` in
Linux*)
	if [ -z "`hostname --version 2>&1 | grep GNU`" ]; then
		hostname=`hostname -f`
	else
		hostname=`hostname`
	fi
	;;
*)
	hostname=`hostname`
	;;
esac
d242 1
a242 1
authdisplay=${display:-:0}
d244 1
a244 1
mcookie=`MK_COOKIE`
d246 5
a250 5
mcookie=`dd if=/dev/random bs=16 count=1 2>/dev/null | hexdump -e \\"%08x\\"`
if test x"$mcookie" = x; then
                echo "Couldn't create cookie"
                exit 1
fi
d252 1
a252 1
dummy=0
d254 4
a257 4
XCOMM create a file with auth information for the server. ':0' is a dummy.
xserverauthfile=$HOME/.serverauth.$$
trap "rm -f $xserverauthfile" ERR HUP INT QUIT ILL TRAP KILL BUS TERM
xauth -q -f $xserverauthfile << EOF
d260 1
a260 1
serverargs=${serverargs}" -auth "${xserverauthfile}
d262 8
a269 8
XCOMM now add the same credentials to the client authority file
XCOMM if '$displayname' already exists do not overwrite it as another
XCOMM server man need it. Add them to the '$xserverauthfile' instead.
for displayname in $authdisplay $hostname$authdisplay; do
     authcookie=`XAUTH list "$displayname" @@@@
       | sed -n "s/.*$displayname[[:space:]*].*[[:space:]*]//p"` 2>/dev/null;
    if [ "z${authcookie}" = "z" ] ; then
        XAUTH -q << EOF 
d272 4
a275 4
	removelist="$displayname $removelist"
    else
        dummy=$(($dummy+1));
        XAUTH -q -f $xserverauthfile << EOF
d278 3
a280 2
    fi
done
d292 7
a298 2
if [ x"$removelist" != x ]; then
    XAUTH remove $removelist
d300 1
a300 4
if [ x"$xserverauthfile" != x ]; then
    rm -f $xserverauthfile
fi
    
@


1.4
log
@use /dev/arandom to generate the cookie. Problem noticed
by Joerg Sonnenberger. Thanks.
@
text
@d191 1
a191 1
mcookie=`dd if=/dev/arandom bs=16 count=1 2>/dev/null | hexdump -e \\"%08x\\"`
@


1.3
log
@merge xinit 1.0.6
@
text
@d191 1
a191 1
mcookie=`dd if=/dev/random bs=16 count=1 2>/dev/null | hexdump -e \\"%08x\\"`
@


1.2
log
@OpenBSD customization:
- hack for XFree86 3.3.x X servers
- ssh-agent integration
- fvwm default window manager
@
text
@a172 1
#if defined(HAS_COOKIE_MAKER) && defined(MK_COOKIE)
d188 1
d190 7
a224 2

#endif
@


1.1
log
@Initial revision
@
text
@d194 1
@


1.1.1.1
log
@Importing from X.Org indiviual releases
@
text
@@


1.1.1.2
log
@xinit 1.0.6
@
text
@d173 1
a188 1
#if defined(HAS_COOKIE_MAKER) && defined(MK_COOKIE)
a189 7
#else
mcookie=`dd if=/dev/random bs=16 count=1 2>/dev/null | hexdump -e \\"%08x\\"`
if test x"$mcookie" = x; then
                echo "Couldn't create cookie"
                exit 1
fi
#endif
a193 1
trap "rm -f $xserverauthfile" ERR HUP INT QUIT ILL TRAP KILL BUS TERM
d217 2
@

