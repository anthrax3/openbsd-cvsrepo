head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.2
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.6
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.6
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.4
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.2
	OPENBSD_5_0:1.4.0.6
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.2.0.8
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.4
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.4
	v1_0_3:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v1_0_2:1.1.1.1
	v1_0_1:1.1.1.1
	xorg:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2017.02.28.18.45.48;	author matthieu;	state Exp;
branches;
next	1.7;
commitid	rNAkngJIQBxZEUOC;

1.7
date	2015.01.25.11.32.22;	author matthieu;	state Exp;
branches;
next	1.6;
commitid	IJsOpiDlgf1J9vgI;

1.6
date	2013.03.05.21.03.36;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.31.13.49.18;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.31.09.18.16;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.31.09.14.09;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.13.15.43.03;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.20.19.44;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.25.20.19.44;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update to sessreg 1.1.1
@
text
@/*
 * Copyright 1990, 1998  The Open Group
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation.
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of The Open Group shall
 * not be used in advertising or otherwise to promote the sale, use or
 * other dealings in this Software without prior written authorization
 * from The Open Group.
 *
 */

/*
 * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 * Author:  Keith Packard, MIT X Consortium
 * Lastlog support and dynamic utmp entry allocation
 *   by Andreas Stolcke <stolcke@@icsi.berkeley.edu>
 */

/*
 * sessreg
 *
 * simple wtmp/utmp frobber
 *
 * usage: sessreg [ -w <wtmp-file> ] [ -u <utmp-file> ]
 *		  [ -l <line> ]
 *		  [ -L <lastlog-file> ]		      / #ifdef USE_LASTLOG
 *		  [ -h <host-name> ]				/ BSD only
 *		  [ -s <slot-number> ] [ -x Xservers-file ]	/ BSD only
 *		  [ -t <ttys-file> ]				/ BSD only
 *		  [ -a ] [ -d ] user-name
 *
 * one of -a or -d must be specified
 */

#include "sessreg.h"

#include <X11/Xos.h>
#include <X11/Xfuncs.h>
#include <X11/Xfuncproto.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#ifdef USE_UTMP
static void set_utmp (struct utmp *u, char *line, char *user, char *host,
		      time_t date, int addp);
#endif

#ifdef USE_UTMPX
static void set_utmpx (struct utmpx *u, const char *line, const char *user,
		       const char *host, time_t date, int addp);
#endif

static int wflag, uflag, lflag;
static const char *wtmp_file, *utmp_file;
#ifdef USE_UTMPX
#ifdef HAVE_UPDWTMPX
static const char *wtmpx_file = NULL;
#endif
#ifdef HAVE_UTMPXNAME
static const char *utmpx_file = NULL;
#endif
#endif

static int utmp_none, wtmp_none;
/*
 * BSD specific variables.  To make life much easier for Xstartup/Xreset
 * maintainers, these arguments are accepted but ignored for sysV
 */
static int hflag, xflag, tflag;
static char *host_name = NULL;
#if defined(USE_UTMP) && !defined(HAVE_PUTUTLINE)
static int sflag;
static int slot_number;
#endif
static char *xservers_file, *ttys_file;
static char *user_name;
static int aflag, dflag;
#ifdef USE_LASTLOG
static const char *llog_file;
static int llog_none, Lflag;
#endif

static char *program_name;

#if defined(USE_UTMP) && !defined(HAVE_PUTUTLINE)
static int findslot (char *line_name, char *host_name, int addp, int slot);
static int Xslot (char *ttys_file, char *servers_file, char *tty_line,
		  char *host_name, int addp);
#endif

static void _X_NORETURN _X_COLD
usage (int x)
{
	fprintf (stderr,
		 "%s: usage %s {-a -d} [-w wtmp-file] [-u utmp-file]"
#ifdef USE_LASTLOG
		 " [-L lastlog-file]"
#endif
		 "\n"
		 "             [-t ttys-file] [-l line-name] [-h host-name] [-V]\n"
		 "             [-s slot-number] [-x servers-file] user-name\n",
		 program_name, program_name);
	exit (x);
}

static char *
getstring (char ***avp, int *flagp)
{
	char	**a = *avp;
	char	*flag = *a;

	if (*flagp != 0) {
		fprintf (stderr, "%s: cannot give more than one -%s option\n",
			 program_name, flag);
		usage (1);
	}
	*flagp = 1;
	/* if the argument is given immediately following the flag,
	   i.e. "sessreg -hfoo ...", not "sessreg -h foo ...",
	   then return the rest of the string as the argument value */
	if (*++*a)
		return *a;
	/* else use the next pointer in the argv list as the argument value */
	++a;
	if (!*a) {
		fprintf (stderr, "%s: -%s requires an argument\n",
			 program_name, flag);
		usage (1);
	}
	*avp = a;
	return *a;
}

#if defined(USE_UTMP) && !defined(HAVE_PUTUTLINE)
static int
syserr (int x, const char *s)
{
	if (x == -1) {
		perror (s);
		exit (1);
	}
	return x;
}
#endif

static int
sysnerr (int x, const char *s)
{
	if (x == 0) {
		perror (s);
		exit (1);
	}
	return x;
}

int
main (int argc, char **argv)
{
#if defined(USE_UTMP) && !defined(HAVE_PUTUTLINE)
	int		utmp;
#endif
#ifndef USE_UTMPX
	int		wtmp;
#endif
	time_t		current_time;
#ifdef USE_UTMP
	struct utmp	utmp_entry;
#endif
#ifdef USE_UTMPX
	struct utmpx	utmpx_entry;
#endif
	char *		line = NULL;

	program_name = argv[0];
	while (*++argv && **argv == '-') {
		switch (*++*argv) {
		case 'w':
			wtmp_file = getstring (&argv, &wflag);
			if (!strcmp (wtmp_file, "none"))
				wtmp_none = 1;
#if defined(USE_UTMPX) && defined(HAVE_UPDWTMPX)
			else
				wtmpx_file = wtmp_file;
#endif
			break;
		case 'u':
			utmp_file = getstring (&argv, &uflag);
			if (!strcmp (utmp_file, "none"))
				utmp_none = 1;
#if defined(USE_UTMPX) && defined(HAVE_UTMPXNAME)
			else
				utmpx_file = utmp_file;
#endif
			break;
#ifdef USE_LASTLOG
		case 'L':
			llog_file = getstring (&argv, &Lflag);
			if (!strcmp (llog_file, "none"))
				llog_none = 1;
			break;
#endif
		case 't':
			ttys_file = getstring (&argv, &tflag);
			break;
		case 'l':
			line = getstring (&argv, &lflag);
			break;
		case 'h':
			host_name = getstring (&argv, &hflag);
			break;
		case 's':
#if defined(USE_UTMP) && !defined(HAVE_PUTUTLINE)
			slot_number = atoi (getstring (&argv, &sflag));
#endif
			break;
		case 'x':
			xservers_file = getstring (&argv, &xflag);
			break;
		case 'a':
			aflag++;
			break;
		case 'd':
			dflag++;
			break;
		case 'V':
			printf("%s\n", PACKAGE_STRING);
			exit (0);
		default:
			fprintf (stderr, "%s: unrecognized option '%s'\n",
				 program_name, argv[0]);
			usage (1);
		}
	}
	user_name = *argv++;
	if (user_name == NULL) {
		fprintf (stderr, "%s: missing required user-name argument\n",
			 program_name);
		usage (1);
	}
	if (*argv != NULL) {
		fprintf (stderr, "%s: unrecognized argument '%s'\n",
			 program_name, argv[0]);
		usage (1);
	}
	/*
	 * complain if neither aflag nor dflag are set,
	 * or if both are set.
	 */
	if (!(aflag ^ dflag)) {
		fprintf (stderr, "%s: must specify exactly one of -a or -d\n",
			 program_name);
		usage (1);
	}
	if (xflag && !lflag) {
		fprintf (stderr, "%s: must specify -l when -x is used\n",
			 program_name);
		usage (1);
	}
	/* set up default file names */
	if (!wflag) {
		wtmp_file = WTMP_FILE;
#if defined(USE_UTMPX) && defined(HAVE_UPDWTMPX)
		wtmpx_file = WTMPX_FILE;
#endif
	}
	if (!uflag) {
		utmp_file = UTMP_FILE;
#if defined(USE_UTMPX) && defined(HAVE_UTMPXNAME)
		utmpx_file = UTMPX_FILE;
#endif
	}
#ifdef USE_LASTLOG
	if (!Lflag)
		llog_file = LLOG_FILE;
#endif
#if defined(USE_UTMP) && !defined(HAVE_PUTUTLINE)
	if (!tflag)
		ttys_file = TTYS_FILE;
	if (!sflag && !utmp_none) {
		if (xflag)
			sysnerr (slot_number = Xslot (ttys_file, xservers_file, line, host_name, aflag), "Xslot");
		else
			sysnerr (slot_number = ttyslot (), "ttyslot");
	}
#endif
	if (!lflag) {
		sysnerr ((line = ttyname (0)) != NULL, "ttyname");
		if (strncmp(line, "/dev/", 5) == 0)
			line += 5;
	}
	time (&current_time);
#ifdef USE_UTMP
	set_utmp (&utmp_entry, line, user_name, host_name, current_time, aflag);
#endif

#ifdef USE_UTMPX
	/* need to set utmpxname() before calling set_utmpx() for
	   UtmpxIdOpen to work */
# ifdef HAVE_UTMPXNAME
	if (utmpx_file != NULL) {
		utmpxname (utmpx_file);
	}
# endif
	set_utmpx (&utmpx_entry, line, user_name,
		   host_name, current_time, aflag);
#endif

	if (!utmp_none) {
#ifdef USE_UTMPX
# ifdef HAVE_UTMPXNAME
		if (utmpx_file != NULL)
# endif
		{
			setutxent ();
			(void) getutxid (&utmpx_entry);
			pututxline (&utmpx_entry);
			endutxent ();
		}
#endif
#ifdef USE_UTMP
# ifdef HAVE_PUTUTLINE
		utmpname (utmp_file);
		setutent ();
		(void) getutid (&utmp_entry);
		pututline (&utmp_entry);
		endutent ();
# else
		utmp = open (utmp_file, O_RDWR);
		if (utmp != -1) {
			syserr ((int) lseek (utmp, (off_t) slot_number * sizeof (struct utmp), 0), "lseek");
			sysnerr (write (utmp, (char *) &utmp_entry, sizeof (utmp_entry))
					== sizeof (utmp_entry), "write utmp entry");
			close (utmp);
		}
# endif
#endif /* USE_UTMP */
	}
	if (!wtmp_none) {
#ifdef USE_UTMPX
# ifdef HAVE_UPDWTMPX
		if (wtmpx_file != NULL) {
			updwtmpx(wtmpx_file, &utmpx_entry);
		}
# endif
#else
		wtmp = open (wtmp_file, O_WRONLY|O_APPEND);
		if (wtmp != -1) {
			sysnerr (write (wtmp, (char *) &utmp_entry, sizeof (utmp_entry))
					== sizeof (utmp_entry), "write wtmp entry");
			close (wtmp);
		}
#endif
	}
#ifdef USE_LASTLOG
	if (aflag && !llog_none) {
		int llog;
		struct passwd *pwd = getpwnam(user_name);

		sysnerr( pwd != NULL, "get user id");
		llog = open (llog_file, O_RDWR);

		if (llog != -1) {
			struct lastlog ll;

			sysnerr (lseek(llog, (off_t) (pwd->pw_uid*sizeof(ll)), 0)
					!= -1, "seeking lastlog entry");
			memset(&ll, 0, sizeof(ll));
			ll.ll_time = current_time;
			if (line)
			 (void) strncpy (ll.ll_line, line, sizeof (ll.ll_line));
			if (host_name)
			 (void) strncpy (ll.ll_host, host_name, sizeof (ll.ll_host));

			sysnerr (write (llog, (char *) &ll, sizeof (ll))
					== sizeof (ll), "write lastlog entry");
			close (llog);
		}
	}
#endif
	return 0;
}

/*
 * fill in the appropriate records of the utmp entry
 */

#ifdef USE_UTMP
static void
set_utmp (struct utmp *u, char *line, char *user, char *host, time_t date, int addp)
{
	memset (u, 0, sizeof (*u));
	if (line)
		(void) strncpy (u->ut_line, line, sizeof (u->ut_line));
	else
		memset (u->ut_line, 0, sizeof (u->ut_line));
	if (addp && user)
		(void) strncpy (u->ut_name, user, sizeof (u->ut_name));
	else
		memset (u->ut_name, 0, sizeof (u->ut_name));
#ifdef HAVE_STRUCT_UTMP_UT_ID
	if (line) {
		size_t	i;
		/*
		 * this is a bit crufty, but
		 * follows the apparent conventions in
		 * the ttys file.  ut_id is only 4 bytes
		 * long, and the last 4 bytes of the line
		 * name are written into it, left justified.
		 */
		i = strlen (line);
		if (i >= sizeof (u->ut_id))
			i -= sizeof (u->ut_id);
		else
			i = 0;
		(void) strncpy (u->ut_id, line + i, sizeof (u->ut_id));
	} else
		memset (u->ut_id, 0, sizeof (u->ut_id));
#endif
#ifdef HAVE_STRUCT_UTMP_UT_PID
	if (addp)
		u->ut_pid = getppid ();
	else
		u->ut_pid = 0;
#endif
#ifdef HAVE_STRUCT_UTMP_UT_TYPE
	if (addp)
		u->ut_type = USER_PROCESS;
	else
		u->ut_type = DEAD_PROCESS;
#endif
#ifdef HAVE_STRUCT_UTMP_UT_HOST
	if (addp && host)
		(void) strncpy (u->ut_host, host, sizeof (u->ut_host));
	else
		memset (u->ut_host, 0, sizeof (u->ut_host));
#endif
	u->ut_time = date;
}
#endif /* USE_UTMP */

#ifdef USE_UTMPX
static int
UtmpxIdOpen( char *utmpId )
{
	struct utmpx *u;	/* pointer to entry in utmp file           */
	int    status = 1;	/* return code                             */

	setutxent();

	while ( (u = getutxent()) != NULL ) {

		if ( (strncmp(u->ut_id, utmpId, 4) == 0 ) &&
		     u->ut_type != DEAD_PROCESS ) {

			status = 0;
			break;
		}
	}

	endutxent();
	return (status);
}

static void
set_utmpx (struct utmpx *u, const char *line, const char *user,
	   const char *host, time_t date, int addp)
{
	static const char letters[] =
	       "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

	memset (u, 0, sizeof (*u));
	if (line)
	{
		if(strcmp(line, ":0") == 0)
			(void) strcpy(u->ut_line, "console");
		else
			(void) strncpy (u->ut_line, line, sizeof (u->ut_line));

		strncpy(u->ut_host, line, sizeof(u->ut_host));
#ifdef HAVE_STRUCT_UTMPX_UT_SYSLEN
		u->ut_syslen = strlen(line);
#endif
	}
	else
		memset (u->ut_line, 0, sizeof (u->ut_line));
	if (addp && user)
		(void) strncpy (u->ut_user, user, sizeof (u->ut_user));
	else
		memset (u->ut_user, 0, sizeof (u->ut_user));

	if (line) {
		size_t	i;
		/*
		 * this is a bit crufty, but
		 * follows the apparent conventions in
		 * the ttys file.  ut_id is only 4 bytes
		 * long, and the last 4 bytes of the line
		 * name are written into it, left justified.
		 */
		i = strlen (line);
		if (i >= sizeof (u->ut_id))
			i -= sizeof (u->ut_id);
		else
			i = 0;
		(void) strncpy (u->ut_id, line + i, sizeof (u->ut_id));

		/* make sure there is no entry using identical ut_id */
		if (!UtmpxIdOpen(u->ut_id) && addp) {
			int limit = sizeof(letters) - 1;
			int t = 0;

			u->ut_id[1] = line[i];
			u->ut_id[2] = line[i+1];
			u->ut_id[3] = line[i+2];
			do {
				u->ut_id[0] = letters[t];
				t++;
			} while (!UtmpxIdOpen(u->ut_id) && (t < limit));
		}
		if (!addp && strstr(line, ":") != NULL) {
			struct utmpx *tmpu;

			while ( (tmpu = getutxent()) != NULL ) {
				if ( (strcmp(tmpu->ut_host, line) == 0 ) &&
					tmpu->ut_type != DEAD_PROCESS ) {
					strncpy(u->ut_id, tmpu->ut_id,
						sizeof(u->ut_id));
					break;
				}
			}
			endutxent();
		}
	} else
		memset (u->ut_id, 0, sizeof (u->ut_id));

	if (addp) {
		u->ut_pid = getppid ();
		u->ut_type = USER_PROCESS;
	} else {
		u->ut_pid = 0;
		u->ut_type = DEAD_PROCESS;
	}
	u->ut_tv.tv_sec = date;
	u->ut_tv.tv_usec = 0;
}
#endif /* USE_UTMPX */

#if defined(USE_UTMP) && !defined(HAVE_PUTUTLINE)
/*
 * compute the slot-number for an X display.  This is computed
 * by counting the lines in /etc/ttys and adding the line-number
 * that the display appears on in Xservers.  This is a poor
 * design, but is limited by the non-existant interface to utmp.
 * If host_name is non-NULL, assume it contains the display name,
 * otherwise use the tty_line argument (i.e., the tty name).
 */

static int
Xslot (char *ttys_file, char *servers_file, char *tty_line, char *host_name,
       int addp)
{
	FILE	*ttys, *servers;
	int	c;
	int	slot = 1;
	int	column0 = 1;
	char	servers_line[1024];
	char	disp_name[512];
	int	len;
	char	*pos;

	/* remove screen number from the display name */
	memset(disp_name, 0, sizeof(disp_name));
	strncpy(disp_name, host_name ? host_name : tty_line, sizeof(disp_name)-1);
	pos = strrchr(disp_name, ':');
	if (pos) {
		pos = strchr(pos, '.');
		if (pos)
			*pos = '\0';
	}
	sysnerr ((int)(long)(ttys = fopen (ttys_file, "r")), ttys_file);
	while ((c = getc (ttys)) != EOF)
		if (c == '\n') {
			++slot;
			column0 = 1;
		} else
			column0 = 0;
	if (!column0)
		++slot;
	(void) fclose (ttys);
	sysnerr ((int)(long)(servers = fopen (servers_file, "r")), servers_file);

	len = strlen (disp_name);
	column0 = 1;
	while (fgets (servers_line, sizeof (servers_line), servers)) {
		if (column0 && *servers_line != '#') {
			if (!strncmp (disp_name, servers_line, len) &&
			    (servers_line[len] == ' ' ||
			     servers_line[len] == '\t'))
				return slot;
			++slot;
		}
		if (servers_line[strlen(servers_line)-1] != '\n')
			column0 = 0;
		else
			column0 = 1;
	}
	/*
	 * display not found in Xservers file - allocate utmp entry dinamically
	 */
	return findslot (tty_line, host_name, addp, slot);
}

/*
 * find a free utmp slot for the X display.  This allocates a new entry
 * past the regular tty entries if necessary, reusing existing entries
 * (identified by (line,hostname)) if possible.
 */
static int
findslot (char *line_name, char *host_name, int addp, int slot)
{
	int	utmp;
	struct	utmp entry;
	int	found = 0;
	int	freeslot = -1;

	syserr(utmp = open (utmp_file, O_RDONLY), "open utmp");

	/*
	 * first, try to locate a previous entry for this display
	 * also record location of a free slots in case we need a new one
	 */
	syserr ((int) lseek (utmp, (off_t) slot * sizeof (struct utmp), 0), "lseek");

	if (!host_name)
		host_name = "";

	while (read (utmp, (char *) &entry, sizeof (entry)) == sizeof (entry)) {
		if (strncmp(entry.ut_line, line_name,
			sizeof(entry.ut_line)) == 0
#ifdef HAVE_STRUCT_UTMP_UT_HOST
		    &&
		    strncmp(entry.ut_host, host_name,
			sizeof(entry.ut_host)) == 0
#endif
		   ) {
			found = 1;
			break;
		}
		if (freeslot < 0 && *entry.ut_name == '\0')
			freeslot = slot;
		++slot;
	}

	close (utmp);

	if (found)
		return slot;
	else if (!addp)
		return 0;	/* trying to delete a non-existing entry */
	else if (freeslot < 0)
		return slot;	/* first slot past current entries */
	else
		return freeslot;
}
#endif
@


1.7
log
@Update to sessreg 1.1.0
@
text
@d369 1
a369 1
			syserr ((int) lseek (utmp, (long) slot_number * sizeof (struct utmp), 0), "lseek");
d404 1
a404 1
			sysnerr (lseek(llog, (long) (pwd->pw_uid*sizeof(ll)), 0)
d671 1
a671 1
	syserr ((int) lseek (utmp, (long) slot * sizeof (struct utmp), 0), "lseek");
@


1.6
log
@Update to sessreg 1.0.8
@
text
@d77 1
d130 1
a130 1
static int
d133 2
a134 3
	if (x) {
		fprintf (stderr,
                         "%s: usage %s {-a -d} [-w wtmp-file] [-u utmp-file]"
d136 1
a136 1
                         " [-L lastlog-file]"
d138 5
a142 7
                         "\n"
                         "             [-t ttys-file] [-l line-name] [-h host-name] [-V]\n"
                         "             [-s slot-number] [-x servers-file] user-name\n",
                         program_name, program_name);
		exit (1);
	}
	return x;
d149 1
d151 9
a159 1
	usage ((*flagp)++);
d162 1
d164 5
a168 1
	usage (!*a);
d220 4
d229 4
d268 2
d273 11
a283 2
	usage (!(user_name = *argv++));
	usage (*argv != NULL);
d288 10
a297 2
	usage (!(aflag ^ dflag));
	usage (xflag && !lflag);
d510 1
@


1.5
log
@Update to sessreg 1.0.7
@
text
@a92 1
static char *line;
d101 1
d133 2
a134 1
		fprintf (stderr, "%s: usage %s {-a -d} [-w wtmp-file] [-u utmp-file]", program_name, program_name);
d136 1
a136 1
		fprintf (stderr, " [-L lastlog-file]");
d138 4
a141 3
		fprintf (stderr, "\n");
		fprintf (stderr, "             [-t ttys-file] [-l line-name] [-h host-name]\n");
		fprintf (stderr, "             [-s slot-number] [-x servers-file] user-name\n");
d199 1
d244 3
a265 1
#ifndef NO_UTMP
a271 3
#else
	utmp_none = 1;
#endif
d365 1
a365 1
			sysnerr (lseek(llog, (long) pwd->pw_uid*sizeof(ll), 0)
d402 1
a402 1
		int	i;
d491 1
a491 1
		int	i;
@


1.4
log
@Update to sessreg 1.0.6
@
text
@d9 1
a9 1
 * 
d12 1
a12 1
 * 
d20 1
a20 1
 * 
d28 2
a29 1
/* Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
d64 1
a64 1
 *		  [ -L <lastlog-file> ]		      / #ifndef NO_LASTLOG
d68 1
a68 1
 *	          [ -a ] [ -d ] user-name
d75 4
a78 9
# include	<X11/Xos.h>
# include	<X11/Xfuncs.h>
# include	<stdio.h>
# include	<stdlib.h>

#if defined(__SVR4) || defined(SVR4) || defined(linux) || defined(__GLIBC__)
# define SYSV
#endif

a79 1
#define Time_t time_t
d83 1
a83 1
		      Time_t date, int addp);
d88 1
a88 1
		       const char *host, Time_t date, int addp);
d92 2
a93 1
static char *wtmp_file, *utmp_file, *line;
d96 1
a96 1
static char *wtmpx_file = NULL;
d99 1
a99 1
static char *utmpx_file = NULL;
d107 1
a107 1
static int hflag, sflag, xflag, tflag;
d109 2
a110 1
#ifdef USE_UTMP
d116 2
a117 2
#ifndef NO_LASTLOG
static char *llog_file;
d123 1
a123 1
#ifndef SYSV
d134 1
a134 1
#ifndef NO_LASTLOG
d159 1
a159 1
#ifndef SYSV
d184 1
a184 1
#if defined(USE_UTMP) && !defined(SYSV)
d187 1
a187 2
	char		*line_tmp;
#ifndef USE_UTMPX	
d189 2
a190 2
#endif	
	Time_t		current_time;
d211 1
a211 1
#ifndef NO_LASTLOG
d228 1
a228 1
#ifdef USE_UTMP
d270 1
a270 1
#ifndef NO_LASTLOG
d274 1
a274 1
#if defined(USE_UTMP) && !defined(SYSV) && !defined(linux) && !defined(__QNX__)
d285 3
a287 6
		sysnerr ((line_tmp = ttyname (0)) != NULL, "ttyname");
		line = strrchr(line_tmp, '/');
		if (line)
			line = line + 1;
		else
			line = line_tmp;
d299 1
a299 1
	        utmpxname (utmpx_file);
d304 1
a304 1
#endif	
d308 2
a309 2
# ifdef HAVE_UTMPX_NAME
	    if (utmpx_file != NULL)
d311 6
a316 6
	    {
		setutxent ();
		(void) getutxid (&utmpx_entry);
		pututxline (&utmpx_entry);
		endutxent ();
	    }
d319 1
a319 1
# ifdef SYSV
d330 1
a330 1
				        == sizeof (utmp_entry), "write utmp entry");
d347 1
a347 1
				        == sizeof (utmp_entry), "write wtmp entry");
d350 1
a350 1
#endif		
d352 1
a352 1
#ifndef NO_LASTLOG
d354 2
a355 2
	        int llog;
	        struct passwd *pwd = getpwnam(user_name);
d357 2
a358 2
	        sysnerr( pwd != NULL, "get user id");
	        llog = open (llog_file, O_RDWR);
d364 2
a365 2
				        != -1, "seeking lastlog entry");
			bzero((char *)&ll, sizeof(ll));
d373 1
a373 1
				        == sizeof (ll), "write lastlog entry");
d387 1
a387 1
set_utmp (struct utmp *u, char *line, char *user, char *host, Time_t date, int addp)
d389 1
a389 1
	bzero (u, sizeof (*u));
d393 1
a393 1
		bzero (u->ut_line, sizeof (u->ut_line));
d397 2
a398 2
		bzero (u->ut_name, sizeof (u->ut_name));
#ifdef SYSV
d415 4
a418 2
		bzero (u->ut_id, sizeof (u->ut_id));
	if (addp) {
d420 5
d426 1
a426 2
	} else {
		u->ut_pid = 0;
a427 1
	}
d429 1
a429 1
#if (!defined(SYSV) && !defined(__QNX__)) || defined(linux)
d433 1
a433 1
		bzero (u->ut_host, sizeof (u->ut_host));
d447 1
a447 1
 
d449 1
a449 1
		
d452 1
a452 1
			
d457 1
a457 1
 
d464 1
a464 1
	   const char *host, Time_t date, int addp)
d469 1
a469 1
        if (line)
d471 4
a474 4
                if(strcmp(line, ":0") == 0)
                        (void) strcpy(u->ut_line, "console");
                else
                        (void) strncpy (u->ut_line, line, sizeof (u->ut_line));
d477 2
a478 2
#if HAVE_UTMPX_UT_SYSLEN
		u->ut_syslen = strlen(line); 
d481 22
a502 22
        else
                bzero (u->ut_line, sizeof (u->ut_line));
        if (addp && user)
                (void) strncpy (u->ut_user, user, sizeof (u->ut_user));
        else
                bzero (u->ut_user, sizeof (u->ut_user));

        if (line) {
                int     i;
                /*
                 * this is a bit crufty, but
                 * follows the apparent conventions in
                 * the ttys file.  ut_id is only 4 bytes
                 * long, and the last 4 bytes of the line
                 * name are written into it, left justified.
                 */
                i = strlen (line);
                if (i >= sizeof (u->ut_id))
                        i -= sizeof (u->ut_id);
                else
                        i = 0;
                (void) strncpy (u->ut_id, line + i, sizeof (u->ut_id));
d506 13
a518 2
                        int limit = sizeof(letters) - 1;
                        int t = 0;
d520 4
a523 15
                        u->ut_id[1] = line[i];
                        u->ut_id[2] = line[i+1];
                        u->ut_id[3] = line[i+2];
                        do {
                                u->ut_id[0] = letters[t];
                                t++;
                        } while (!UtmpxIdOpen(u->ut_id) && (t < limit));
                }
                if (!addp && strstr(line, ":") != NULL) {
                        struct utmpx *tmpu;             

                        while ( (tmpu = getutxent()) != NULL ) {
                                if ( (strcmp(tmpu->ut_host, line) == 0 ) &&
                                        tmpu->ut_type != DEAD_PROCESS ) {
                                        strncpy(u->ut_id, tmpu->ut_id,
d525 15
a539 15
                                        break;
                                }
                        }
                        endutxent();
                }
        } else
                bzero (u->ut_id, sizeof (u->ut_id));
	
        if (addp) {
                u->ut_pid = getppid ();
                u->ut_type = USER_PROCESS;
        } else {
                u->ut_pid = 0;
                u->ut_type = DEAD_PROCESS;
        }
d545 1
a545 1
#if defined(USE_UTMP) && !defined(SYSV)
d573 3
a575 3
	    pos = strchr(pos, '.');
	    if (pos)
		*pos = '\0';
d636 3
a638 3
			sizeof(entry.ut_line)) == 0 
#ifndef __QNX__
                    &&
d642 1
a642 1
                   ) {
@


1.3
log
@Update to sessreg 1.0.5
@
text
@d31 17
a47 23
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
a77 1
# include	<utmp.h>
d86 4
a89 1
static void set_utmp (struct utmp *u, char *line, char *user, char *host, Time_t date, int addp);
d99 6
a104 1
static char *wtmpx_file = NULL, *utmpx_file = NULL;
d113 1
d115 1
d187 1
a187 1
#ifndef SYSV
d195 1
d197 1
d232 1
d234 1
d260 1
a260 1
#ifdef USE_UTMPX
d267 1
a267 1
#ifdef USE_UTMPX
d278 1
a278 1
#if !defined(SYSV) && !defined(linux) && !defined(__QNX__)
d297 1
d299 1
d304 1
d308 1
d315 4
a318 1
	    if (utmpx_file != NULL) {
d325 2
a326 1
#ifdef SYSV
d332 1
a332 1
#else
d340 2
a341 1
#endif
d345 1
d349 1
d392 1
d439 1
d447 2
d460 1
a460 1
	endutent();
d479 1
d481 1
d486 1
a486 1
                (void) strncpy (u->ut_name, user, sizeof (u->ut_name));
d488 1
a488 1
                bzero (u->ut_name, sizeof (u->ut_name));
d547 1
a547 1
#ifndef SYSV
@


1.2
log
@update to sessreg 1.0.4
@
text
@d69 1
d100 2
a101 2
int	wflag, uflag, lflag;
char	*wtmp_file, *utmp_file, *line;
d105 1
a105 1
int	utmp_none, wtmp_none;
d110 6
a115 6
int	hflag, sflag, xflag, tflag;
char	*host_name = NULL;
int	slot_number;
char	*xservers_file, *ttys_file;
char	*user_name;
int	aflag, dflag;
d117 2
a118 2
char	*llog_file;
int	llog_none, Lflag;
d121 1
a121 1
char	*program_name;
d243 1
a243 1
	usage (*argv != 0);
@


1.1
log
@Initial revision
@
text
@a90 4
#ifdef X_NOT_POSIX
extern long	lseek ();
extern char	*ttyname ();
#endif
@


1.1.1.1
log
@Importing from X.Org 7.2RC2
@
text
@@
