head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.2
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.18.0.2
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.7.0.2
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.1.1.4.0.4
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	psxxjI5z4Vpv2LL4;

1.21
date	2015.09.05.14.11.46;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	YVUODLQ4QcYTuGkb;

1.20
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.19;

1.19
date	2014.03.15.10.39.28;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2012.06.07.20.20.23;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.04.15.10.44;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.10.18.08.42;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.06.20.10.20;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.23.19.08.55;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.33;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.33;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.22;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.53.55;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.35.01;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@/* $XTermId: input.c,v 1.355 2016/05/17 12:12:51 tom Exp $ */

/*
 * Copyright 1999-2015,2016 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/* input.c */

#include <xterm.h>

#include <X11/keysym.h>

#ifdef VMS
#include <X11/keysymdef.h>
#endif

#if HAVE_X11_DECKEYSYM_H
#include <X11/DECkeysym.h>
#endif

#if HAVE_X11_SUNKEYSYM_H
#include <X11/Sunkeysym.h>
#endif

#if HAVE_X11_XF86KEYSYM_H
#include <X11/XF86keysym.h>
#endif

#ifdef HAVE_XKBKEYCODETOKEYSYM
#include <X11/XKBlib.h>
#endif

#include <X11/Xutil.h>
#include <stdio.h>
#include <ctype.h>

#include <xutf8.h>

#include <data.h>
#include <fontutils.h>
#include <xstrings.h>
#include <xtermcap.h>

/*
 * Xutil.h has no macro to check for the complete set of function- and
 * modifier-keys that might be returned.  Fake it.
 */
#ifdef XK_ISO_Lock
#define IsPredefinedKey(n) ((n) >= XK_ISO_Lock && (n) <= XK_Delete)
#else
#define IsPredefinedKey(n) ((n) >= XK_BackSpace && (n) <= XK_Delete)
#endif

#ifdef XK_ISO_Left_Tab
#define IsTabKey(n) ((n) == XK_Tab || (n) == XK_ISO_Left_Tab)
#else
#define IsTabKey(n) ((n) == XK_Tab)
#endif

#ifndef IsPrivateKeypadKey
#define IsPrivateKeypadKey(k) (0)
#endif

#define IsBackarrowToggle(keyboard, keysym, state) \
	((((keyboard->flags & MODE_DECBKM) == 0) \
	    ^ ((state & ControlMask) != 0)) \
	&& (keysym == XK_BackSpace))

#define MAP(from, to) case from: result = to; break
#define Masked(value,mask) ((value) & (unsigned) (~(mask)))

#define KEYSYM_FMT "0x%04lX"	/* simplify matching <X11/keysymdef.h> */

#define TEK4014_GIN(tw) (tw != 0 && TekScreenOf(tw)->TekGIN)

typedef struct {
    KeySym keysym;
    Bool is_fkey;
    int nbytes;
#define STRBUFSIZE 500
    char strbuf[STRBUFSIZE];
} KEY_DATA;

static
const char kypd_num[] = " XXXXXXXX\tXXX\rXXXxxxxXXXXXXXXXXXXXXXXXXXXX*+,-./0123456789XXX=";
/*                       0123456789 abc def0123456789abcdef0123456789abcdef0123456789abcd */
static
const char kypd_apl[] = " ABCDEFGHIJKLMNOPQRSTUVWXYZ??????abcdefghijklmnopqrstuvwxyzXXX";
/*                       0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd */
static
const char curfinal[] = "HDACB  FE";

static int decfuncvalue(KEY_DATA *);
static void sunfuncvalue(ANSI *, KEY_DATA *);
static void hpfuncvalue(ANSI *, KEY_DATA *);
static void scofuncvalue(ANSI *, KEY_DATA *);

static void
AdjustAfterInput(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->scrollkey && screen->topline != 0)
	WindowScroll(xw, 0, False);
    if (screen->marginbell) {
	int col = screen->max_col - screen->nmarginbell;
	if (screen->bellArmed >= 0) {
	    if (screen->bellArmed == screen->cur_row) {
		if (screen->cur_col >= col) {
		    Bell(xw, XkbBI_MarginBell, 0);
		    screen->bellArmed = -1;
		}
	    } else {
		screen->bellArmed =
		    screen->cur_col < col ? screen->cur_row : -1;
	    }
	} else if (screen->cur_col < col)
	    screen->bellArmed = screen->cur_row;
    }
}

/*
 * Return true if the key is on the editing keypad.  This overlaps with
 * IsCursorKey() and IsKeypadKey() and must be tested before those macros to
 * distinguish it from them.
 *
 * VT220  emulation  uses  the  VT100  numeric  keypad as well as a 6-key
 * editing keypad. Here's a picture of the VT220 editing keypad:
 *      +--------+--------+--------+
 *      | Find   | Insert | Remove |
 *      +--------+--------+--------+
 *      | Select | Prev   | Next   |
 *      +--------+--------+--------+
 *
 * and the similar Sun and PC keypads:
 *      +--------+--------+--------+
 *      | Insert | Home   | PageUp |
 *      +--------+--------+--------+
 *      | Delete | End    | PageDn |
 *      +--------+--------+--------+
 */
static Bool
IsEditKeypad(XtermWidget xw, KeySym keysym)
{
    Bool result;

    switch (keysym) {
    case XK_Delete:
	result = !xtermDeleteIsDEL(xw);
	break;
    case XK_Prior:
    case XK_Next:
    case XK_Insert:
    case XK_Find:
    case XK_Select:
#ifdef DXK_Remove
    case DXK_Remove:
#endif
	result = True;
	break;
    default:
	result = False;
	break;
    }
    return result;
}

/*
 * Editing-keypad, plus other editing keys which are not included in the
 * other macros.
 */
static Bool
IsEditFunctionKey(XtermWidget xw, KeySym keysym)
{
    Bool result;

    switch (keysym) {
#ifdef XK_KP_Delete
    case XK_KP_Delete:		/* editing key on numeric keypad */
    case XK_KP_Insert:		/* editing key on numeric keypad */
#endif
#ifdef XK_ISO_Left_Tab
    case XK_ISO_Left_Tab:
#endif
	result = True;
	break;
    default:
	result = IsEditKeypad(xw, keysym);
	break;
    }
    return result;
}

#if OPT_MOD_FKEYS
#define IS_CTRL(n) ((n) < ANSI_SPA || ((n) >= 0x7f && (n) <= 0x9f))

/*
 * Return true if the keysym corresponds to one of the control characters,
 * or one of the common ASCII characters that is combined with control to
 * make a control character.
 */
static Bool
IsControlInput(KEY_DATA * kd)
{
    return ((kd->keysym) >= 0x40 && (kd->keysym) <= 0x7f);
}

static Bool
IsControlOutput(KEY_DATA * kd)
{
    return IS_CTRL(kd->keysym);
}

/*
 * X "normally" has some built-in translations, which the user may want to
 * suppress when processing the modifyOtherKeys resource.  In particular, the
 * control modifier applied to some of the keyboard digits gives results for
 * control characters.
 *
 * control 2   0    NUL
 * control SPC 0    NUL
 * control @@   0    NUL
 * control `   0    NUL
 * control 3   0x1b ESC
 * control 4   0x1c FS
 * control \   0x1c FS
 * control 5   0x1d GS
 * control 6   0x1e RS
 * control ^   0x1e RS
 * control ~   0x1e RS
 * control 7   0x1f US
 * control /   0x1f US
 * control _   0x1f US
 * control 8   0x7f DEL
 *
 * It is possible that some other keyboards do not work for these combinations,
 * but they do work with modifyOtherKeys=2 for the US keyboard:
 *
 * control `   0    NUL
 * control [   0x1b ESC
 * control \   0x1c FS
 * control ]   0x1d GS
 * control ?   0x7f DEL
 */
static Bool
IsControlAlias(KEY_DATA * kd)
{
    Bool result = False;

    if (kd->nbytes == 1) {
	result = IS_CTRL(CharOf(kd->strbuf[0]));
    }
    return result;
}

/*
 * If we are in the non-VT220/VT52 keyboard state, allow modifiers to add a
 * parameter to the function-key control sequences.
 *
 * Note that we generally cannot capture the Shift-modifier for the numeric
 * keypad since this is commonly used to act as a type of NumLock, e.g.,
 * making the keypad send "7" (actually XK_KP_7) where the unshifted code
 * would be Home (XK_KP_Home).  The other modifiers work, subject to the
 * usual window-manager assignments.
 */
#if OPT_SUNPC_KBD
#define LegacyAllows(code) (!is_legacy || (code & xw->keyboard.modify_now.allow_keys) != 0)
#else
#define LegacyAllows(code) True
#endif

static Bool
allowModifierParm(XtermWidget xw, KEY_DATA * kd)
{
    TKeyboard *keyboard = &(xw->keyboard);
    int is_legacy = (keyboard->type == keyboardIsLegacy);
    Bool result = False;

#if OPT_SUNPC_KBD
    if (keyboard->type == keyboardIsVT220)
	is_legacy = True;
#endif

#if OPT_VT52_MODE
    if (TScreenOf(xw)->vtXX_level != 0)
#endif
    {
	if (IsCursorKey(kd->keysym) || IsEditFunctionKey(xw, kd->keysym)) {
	    result = LegacyAllows(2);
	} else if (IsKeypadKey(kd->keysym)) {
	    result = LegacyAllows(1);
	} else if (IsFunctionKey(kd->keysym)) {
	    result = LegacyAllows(4);
	} else if (IsMiscFunctionKey(kd->keysym)) {
	    result = LegacyAllows(8);
	}
    }
    if (xw->keyboard.modify_now.other_keys != 0) {
	result = True;
    }
    return result;
}

/*
* Modifier codes:
*       None                  1
*       Shift                 2 = 1(None)+1(Shift)
*       Alt                   3 = 1(None)+2(Alt)
*       Alt+Shift             4 = 1(None)+1(Shift)+2(Alt)
*       Ctrl                  5 = 1(None)+4(Ctrl)
*       Ctrl+Shift            6 = 1(None)+1(Shift)+4(Ctrl)
*       Ctrl+Alt              7 = 1(None)+2(Alt)+4(Ctrl)
*       Ctrl+Alt+Shift        8 = 1(None)+1(Shift)+2(Alt)+4(Ctrl)
*       Meta                  9 = 1(None)+8(Meta)
*       Meta+Shift           10 = 1(None)+8(Meta)+1(Shift)
*       Meta+Alt             11 = 1(None)+8(Meta)+2(Alt)
*       Meta+Alt+Shift       12 = 1(None)+8(Meta)+1(Shift)+2(Alt)
*       Meta+Ctrl            13 = 1(None)+8(Meta)+4(Ctrl)
*       Meta+Ctrl+Shift      14 = 1(None)+8(Meta)+1(Shift)+4(Ctrl)
*       Meta+Ctrl+Alt        15 = 1(None)+8(Meta)+2(Alt)+4(Ctrl)
*       Meta+Ctrl+Alt+Shift  16 = 1(None)+8(Meta)+1(Shift)+2(Alt)+4(Ctrl)
*/

unsigned
xtermParamToState(XtermWidget xw, unsigned param)
{
    unsigned result = 0;
#if OPT_NUM_LOCK
    if (param > MOD_NONE) {
	if ((param - MOD_NONE) & MOD_SHIFT)
	    UIntSet(result, ShiftMask);
	if ((param - MOD_NONE) & MOD_CTRL)
	    UIntSet(result, ControlMask);
	if ((param - MOD_NONE) & MOD_ALT)
	    UIntSet(result, xw->work.alt_mods);
	if ((param - MOD_NONE) & MOD_META)
	    UIntSet(result, xw->work.meta_mods);
    }
#else
    (void) xw;
    (void) param;
#endif
    TRACE(("xtermParamToState(%d) %s%s%s%s -> %#x\n", param,
	   MODIFIER_NAME(param, MOD_SHIFT),
	   MODIFIER_NAME(param, MOD_ALT),
	   MODIFIER_NAME(param, MOD_CTRL),
	   MODIFIER_NAME(param, MOD_META),
	   result));
    return result;
}

unsigned
xtermStateToParam(XtermWidget xw, unsigned state)
{
    unsigned modify_parm = MOD_NONE;

    TRACE(("xtermStateToParam %#x\n", state));
#if OPT_NUM_LOCK
    if (state & ShiftMask) {
	modify_parm += MOD_SHIFT;
	UIntClr(state, ShiftMask);
    }
    if (state & ControlMask) {
	modify_parm += MOD_CTRL;
	UIntClr(state, ControlMask);
    }
    if ((state & xw->work.alt_mods) != 0) {
	modify_parm += MOD_ALT;
	UIntClr(state, xw->work.alt_mods);
    }
    if ((state & xw->work.meta_mods) != 0) {
	modify_parm += MOD_META;
	/* UIntClr(state, xw->work.meta_mods); */
    }
    if (modify_parm == MOD_NONE)
	modify_parm = 0;
#else
    (void) xw;
    (void) state;
#endif
    TRACE(("...xtermStateToParam %d%s%s%s%s\n", modify_parm,
	   MODIFIER_NAME(modify_parm, MOD_SHIFT),
	   MODIFIER_NAME(modify_parm, MOD_ALT),
	   MODIFIER_NAME(modify_parm, MOD_CTRL),
	   MODIFIER_NAME(modify_parm, MOD_META)));
    return modify_parm;
}

#define computeMaskedModifier(xw, state, mask) \
	xtermStateToParam(xw, Masked(state, mask))

#if OPT_NUM_LOCK
static unsigned
filterAltMeta(unsigned result, unsigned mask, Bool enable, KEY_DATA * kd)
{
    if ((result & mask) != 0) {
	/*
	 * metaSendsEscape makes the meta key independent of
	 * modifyOtherKeys.
	 */
	if (enable) {
	    result &= ~mask;
	}
	/*
	 * A bare meta-modifier is independent of modifyOtherKeys.  If it
	 * is combined with other modifiers, make it depend.
	 */
	if ((result & ~(mask)) == 0) {
	    result &= ~mask;
	}
	/*
	 * Check for special cases of control+meta which are used by some
	 * applications, e.g., emacs.
	 */
	if ((IsControlInput(kd)
	     || IsControlOutput(kd))
	    && (result & ControlMask) != 0) {
	    result &= ~(mask | ControlMask);
	}
	if (kd->keysym == XK_Return || kd->keysym == XK_Tab) {
	    result &= ~(mask | ControlMask);
	}
    }
    return result;
}
#endif /* OPT_NUM_LOCK */

/*
 * Single characters (not function-keys) are allowed fewer modifiers when
 * interpreting modifyOtherKeys due to pre-existing associations with some
 * modifiers.
 */
static unsigned
allowedCharModifiers(XtermWidget xw, unsigned state, KEY_DATA * kd)
{
#if OPT_NUM_LOCK
    unsigned a_or_m = (state & (xw->work.meta_mods | xw->work.alt_mods));
#else
    unsigned a_or_m = 0;
#endif
    /*
     * Start by limiting the result to the modifiers we might want to use.
     */
    unsigned result = (state & (ControlMask
				| ShiftMask
				| a_or_m));

    /*
     * If modifyOtherKeys is off or medium (0 or 1), moderate its effects by
     * excluding the common cases for modifiers.
     */
    if (xw->keyboard.modify_now.other_keys <= 1) {
	if (IsControlInput(kd)
	    && Masked(result, ControlMask) == 0) {
	    /* These keys are already associated with the control-key */
	    if (xw->keyboard.modify_now.other_keys == 0) {
		UIntClr(result, ControlMask);
	    }
	} else if (kd->keysym == XK_Tab || kd->keysym == XK_Return) {
	    /* EMPTY */ ;
	} else if (IsControlAlias(kd)) {
	    /* Things like "^_" work here... */
	    if (Masked(result, (ControlMask | ShiftMask)) == 0) {
		result = 0;
	    }
	} else if (!IsControlOutput(kd) && !IsPredefinedKey(kd->keysym)) {
	    /* Printable keys are already associated with the shift-key */
	    if (!(result & ControlMask)) {
		UIntClr(result, ShiftMask);
	    }
	}
#if OPT_NUM_LOCK
	result = filterAltMeta(result,
			       xw->work.meta_mods,
			       TScreenOf(xw)->meta_sends_esc, kd);
	if (TScreenOf(xw)->alt_is_not_meta) {
	    result = filterAltMeta(result,
				   xw->work.alt_mods,
				   TScreenOf(xw)->alt_sends_esc, kd);
	}
#endif
    }
    TRACE(("...allowedCharModifiers(state=%u" FMT_MODIFIER_NAMES
	   ", ch=" KEYSYM_FMT ") ->"
	   "%u" FMT_MODIFIER_NAMES "\n",
	   state, ARG_MODIFIER_NAMES(state), kd->keysym,
	   result, ARG_MODIFIER_NAMES(result)));
    return result;
}

/*
 * Decide if we should generate a special escape sequence for "other" keys
 * than cursor-, function-keys, etc., as per the modifyOtherKeys resource.
 */
static Bool
ModifyOtherKeys(XtermWidget xw,
		unsigned state,
		KEY_DATA * kd,
		unsigned modify_parm)
{
    TKeyboard *keyboard = &(xw->keyboard);
    Bool result = False;

    /*
     * Exclude the keys already covered by a modifier.
     */
    if (kd->is_fkey
	|| IsEditFunctionKey(xw, kd->keysym)
	|| IsKeypadKey(kd->keysym)
	|| IsCursorKey(kd->keysym)
	|| IsPFKey(kd->keysym)
	|| IsMiscFunctionKey(kd->keysym)
	|| IsPrivateKeypadKey(kd->keysym)) {
	result = False;
    } else if (modify_parm != 0) {
	if (IsBackarrowToggle(keyboard, kd->keysym, state)) {
	    kd->keysym = XK_Delete;
	    UIntClr(state, ControlMask);
	}
	if (!IsPredefinedKey(kd->keysym)) {
	    state = allowedCharModifiers(xw, state, kd);
	}
	if (state != 0) {
	    switch (keyboard->modify_now.other_keys) {
	    default:
		break;
	    case 1:
		switch (kd->keysym) {
		case XK_BackSpace:
		case XK_Delete:
		    result = False;
		    break;
#ifdef XK_ISO_Left_Tab
		case XK_ISO_Left_Tab:
		    if (computeMaskedModifier(xw, state, ShiftMask))
			result = True;
		    break;
#endif
		case XK_Return:
		case XK_Tab:
		    result = (modify_parm != 0);
		    break;
		default:
		    if (IsControlInput(kd)) {
			if (state == ControlMask || state == ShiftMask) {
			    result = False;
			} else {
			    result = (modify_parm != 0);
			}
		    } else if (IsControlAlias(kd)) {
			if (state == ShiftMask)
			    result = False;
			else if (computeMaskedModifier(xw, state, ControlMask)) {
			    result = True;
			}
		    } else {
			result = True;
		    }
		    break;
		}
		break;
	    case 2:
		switch (kd->keysym) {
		case XK_BackSpace:
		    /* strip ControlMask as per IsBackarrowToggle() */
		    if (computeMaskedModifier(xw, state, ControlMask))
			result = True;
		    break;
		case XK_Delete:
		    result = (xtermStateToParam(xw, state) != 0);
		    break;
#ifdef XK_ISO_Left_Tab
		case XK_ISO_Left_Tab:
		    if (computeMaskedModifier(xw, state, ShiftMask))
			result = True;
		    break;
#endif
		case XK_Return:
		case XK_Tab:
		    result = (modify_parm != 0);
		    break;
		default:
		    if (IsControlInput(kd)) {
			result = True;
		    } else if (state == ShiftMask) {
			result = (kd->keysym == ' ' || kd->keysym == XK_Return);
		    } else if (computeMaskedModifier(xw, state, ShiftMask)) {
			result = True;
		    }
		    break;
		}
		break;
	    }
	}
    }
    TRACE(("...ModifyOtherKeys(%d,%d) %s\n",
	   keyboard->modify_now.other_keys,
	   modify_parm,
	   BtoS(result)));
    return result;
}

#define APPEND_PARM(number) \
	    reply->a_param[reply->a_nparam] = (ParmType) number; \
	    reply->a_nparam++

/*
 * Function-key code 27 happens to not be used in the vt220-style encoding.
 * xterm uses this to represent modified non-function-keys such as control/+ in
 * the Sun/PC keyboard layout.  See the modifyOtherKeys resource in the manpage
 * for more information.
 */
static Bool
modifyOtherKey(ANSI *reply, int input_char, unsigned modify_parm, int format_keys)
{
    Bool result = False;

    if (input_char >= 0) {
	reply->a_type = ANSI_CSI;
	if (format_keys) {
	    APPEND_PARM(input_char);
	    APPEND_PARM(modify_parm);
	    reply->a_final = 'u';
	} else {
	    APPEND_PARM(27);
	    APPEND_PARM(modify_parm);
	    APPEND_PARM(input_char);
	    reply->a_final = '~';
	}

	result = True;
    }
    return result;
}

static void
modifyCursorKey(ANSI *reply, int modify, unsigned *modify_parm)
{
    if (*modify_parm != 0) {
	if (modify < 0) {
	    *modify_parm = 0;
	}
	if (modify > 0) {
	    reply->a_type = ANSI_CSI;	/* SS3 should not have params */
	}
	if (modify > 1 && reply->a_nparam == 0) {
	    APPEND_PARM(1);	/* force modifier to 2nd param */
	}
	if (modify > 2) {
	    reply->a_pintro = '>';	/* mark this as "private" */
	}
    }
}
#else
#define modifyCursorKey(reply, modify, parm)	/* nothing */
#endif /* OPT_MOD_FKEYS */

#if OPT_SUNPC_KBD
/*
 * If we have told xterm that our keyboard is really a Sun/PC keyboard, this is
 * enough to make a reasonable approximation to DEC vt220 numeric and editing
 * keypads.
 */
static KeySym
TranslateFromSUNPC(KeySym keysym)
{
    /* *INDENT-OFF* */
    static struct {
	    KeySym before, after;
    } table[] = {
#ifdef DXK_Remove
	{ XK_Delete,       DXK_Remove },
#endif
	{ XK_Home,         XK_Find },
	{ XK_End,          XK_Select },
#ifdef XK_KP_Home
	{ XK_Delete,       XK_KP_Decimal },
	{ XK_KP_Delete,    XK_KP_Decimal },
	{ XK_KP_Insert,    XK_KP_0 },
	{ XK_KP_End,       XK_KP_1 },
	{ XK_KP_Down,      XK_KP_2 },
	{ XK_KP_Next,      XK_KP_3 },
	{ XK_KP_Left,      XK_KP_4 },
	{ XK_KP_Begin,     XK_KP_5 },
	{ XK_KP_Right,     XK_KP_6 },
	{ XK_KP_Home,      XK_KP_7 },
	{ XK_KP_Up,        XK_KP_8 },
	{ XK_KP_Prior,     XK_KP_9 },
#endif
    };
    /* *INDENT-ON* */

    unsigned n;

    for (n = 0; n < sizeof(table) / sizeof(table[0]); n++) {
	if (table[n].before == keysym) {
	    TRACE(("...Input keypad before was " KEYSYM_FMT "\n", keysym));
	    keysym = table[n].after;
	    TRACE(("...Input keypad changed to " KEYSYM_FMT "\n", keysym));
	    break;
	}
    }
    return keysym;
}
#endif /* OPT_SUNPC_KBD */

#define VT52_KEYPAD \
	if_OPT_VT52_MODE(screen,{ \
		reply.a_type = ANSI_ESC; \
		reply.a_pintro = '?'; \
		})

#define VT52_CURSOR_KEYS \
	if_OPT_VT52_MODE(screen,{ \
		reply.a_type = ANSI_ESC; \
		})

#undef  APPEND_PARM
#define APPEND_PARM(number) \
	    reply.a_param[reply.a_nparam] = (ParmType) number, \
	    reply.a_nparam++

#if OPT_MOD_FKEYS
#define MODIFIER_PARM \
	if (modify_parm != 0) APPEND_PARM(modify_parm)
#else
#define MODIFIER_PARM		/*nothing */
#endif

/*
 * Determine if we use the \E[3~ sequence for Delete, or the legacy ^?.  We
 * maintain the delete_is_del value as 3 states:  unspecified(2), true and
 * false.  If unspecified, it is handled differently according to whether the
 * legacy keyboard support is enabled, or if xterm emulates a VT220.
 *
 * Once the user (or application) has specified delete_is_del via resource
 * setting, popup menu or escape sequence, it overrides the keyboard type
 * rather than the reverse.
 */
Bool
xtermDeleteIsDEL(XtermWidget xw)
{
    Bool result = True;

    if (xw->keyboard.type == keyboardIsDefault
	|| xw->keyboard.type == keyboardIsVT220)
	result = (TScreenOf(xw)->delete_is_del == True);

    if (xw->keyboard.type == keyboardIsLegacy)
	result = (TScreenOf(xw)->delete_is_del != False);

    TRACE(("xtermDeleteIsDEL(%d/%d) = %d\n",
	   xw->keyboard.type,
	   TScreenOf(xw)->delete_is_del,
	   result));

    return result;
}

static Boolean
lookupKeyData(KEY_DATA * kd, XtermWidget xw, XKeyEvent *event)
{
    TScreen *screen = TScreenOf(xw);
    Boolean result = True;
#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
#if OPT_MOD_FKEYS
    TKeyboard *keyboard = &(xw->keyboard);
#endif
#endif

    TRACE(("%s %#x\n", visibleEventType(event->type), event->keycode));

    kd->keysym = 0;
    kd->is_fkey = False;
#if OPT_TCAP_QUERY
    if (screen->tc_query_code >= 0) {
	kd->keysym = (KeySym) screen->tc_query_code;
	kd->is_fkey = screen->tc_query_fkey;
	if (kd->keysym != XK_BackSpace) {
	    kd->nbytes = 0;
	    kd->strbuf[0] = 0;
	} else {
	    kd->nbytes = 1;
	    kd->strbuf[0] = 8;
	}
    } else
#endif
    {
#if OPT_I18N_SUPPORT && OPT_INPUT_METHOD
	TInput *input = lookupTInput(xw, (Widget) xw);
	if (input && input->xic) {
	    Status status_return;
#if OPT_WIDE_CHARS
	    if (screen->utf8_mode) {
		kd->nbytes = Xutf8LookupString(input->xic, event,
					       kd->strbuf, (int) sizeof(kd->strbuf),
					       &(kd->keysym), &status_return);
	    } else
#endif
	    {
		kd->nbytes = XmbLookupString(input->xic, event,
					     kd->strbuf, (int) sizeof(kd->strbuf),
					     &(kd->keysym), &status_return);
	    }
#if OPT_MOD_FKEYS
	    /*
	     * Fill-in some code useful with IsControlAlias():
	     */
	    if (status_return == XLookupBoth
		&& kd->nbytes <= 1
		&& !IsPredefinedKey(kd->keysym)
		&& (keyboard->modify_now.other_keys > 1)
		&& !IsControlInput(kd)) {
		kd->nbytes = 1;
		kd->strbuf[0] = (char) kd->keysym;
	    }
#endif /* OPT_MOD_FKEYS */
	} else
#endif /* OPT_I18N_SUPPORT */
	{
	    static XComposeStatus compose_status =
	    {NULL, 0};
	    kd->nbytes = XLookupString(event,
				       kd->strbuf, (int) sizeof(kd->strbuf),
				       &(kd->keysym), &compose_status);
	}
	kd->is_fkey = IsFunctionKey(kd->keysym);
    }
    return result;
}

void
Input(XtermWidget xw,
      XKeyEvent *event,
      Bool eightbit)
{
    Char *string;

    TKeyboard *keyboard = &(xw->keyboard);
    TScreen *screen = TScreenOf(xw);

    int j;
    int key = False;
    ANSI reply;
    int dec_code;
    unsigned modify_parm = 0;
    int keypad_mode = ((keyboard->flags & MODE_DECKPAM) != 0);
    unsigned evt_state = event->state;
    unsigned mod_state;
    KEY_DATA kd;

    /* Ignore characters typed at the keyboard */
    if (keyboard->flags & MODE_KAM)
	return;

    lookupKeyData(&kd, xw, event);

    memset(&reply, 0, sizeof(reply));

    TRACE(("Input keysym "
	   KEYSYM_FMT
	   ", %d:'%s'%s" FMT_MODIFIER_NAMES "%s%s%s%s%s%s\n",
	   kd.keysym,
	   kd.nbytes,
	   visibleChars((Char *) kd.strbuf,
			((kd.nbytes > 0)
			 ? (unsigned) kd.nbytes
			 : 0)),
	   ARG_MODIFIER_NAMES(evt_state),
	   eightbit ? " 8bit" : " 7bit",
	   IsKeypadKey(kd.keysym) ? " KeypadKey" : "",
	   IsCursorKey(kd.keysym) ? " CursorKey" : "",
	   IsPFKey(kd.keysym) ? " PFKey" : "",
	   kd.is_fkey ? " FKey" : "",
	   IsMiscFunctionKey(kd.keysym) ? " MiscFKey" : "",
	   IsEditFunctionKey(xw, kd.keysym) ? " EditFkey" : ""));

#if OPT_SUNPC_KBD
    /*
     * DEC keyboards don't have keypad(+), but do have keypad(,) instead.
     * Other (Sun, PC) keyboards commonly have keypad(+), but no keypad(,)
     * - it's a pain for users to work around.
     */
    if (keyboard->type == keyboardIsVT220
	&& (evt_state & ShiftMask) == 0) {
	if (kd.keysym == XK_KP_Add) {
	    kd.keysym = XK_KP_Separator;
	    UIntClr(evt_state, ShiftMask);
	    TRACE(("...Input keypad(+), change keysym to "
		   KEYSYM_FMT
		   "\n",
		   kd.keysym));
	}
	if ((evt_state & ControlMask) != 0
	    && kd.keysym == XK_KP_Separator) {
	    kd.keysym = XK_KP_Subtract;
	    UIntClr(evt_state, ControlMask);
	    TRACE(("...Input control/keypad(,), change keysym to "
		   KEYSYM_FMT
		   "\n",
		   kd.keysym));
	}
    }
#endif

    /*
     * The keyboard tables may give us different keypad codes according to
     * whether NumLock is pressed.  Use this check to simplify the process
     * of determining whether we generate an escape sequence for a keypad
     * key, or force it to the value kypd_num[].  There is no fixed
     * modifier for this feature, so we assume that it is the one assigned
     * to the NumLock key.
     *
     * This check used to try to return the contents of strbuf, but that
     * does not work properly when a control modifier is given (trash is
     * returned in the buffer in some cases -- perhaps an X bug).
     */
#if OPT_NUM_LOCK
    if (kd.nbytes == 1
	&& IsKeypadKey(kd.keysym)
	&& xw->misc.real_NumLock
	&& (xw->work.num_lock & evt_state) != 0) {
	keypad_mode = 0;
	TRACE(("...Input num_lock, force keypad_mode off\n"));
    }
#endif

#if OPT_MOD_FKEYS
    if (evt_state != 0
	&& allowModifierParm(xw, &kd)) {
	modify_parm = xtermStateToParam(xw, evt_state);
    }

    /*
     * Shift-tab is often mapped to XK_ISO_Left_Tab which is classified as
     * IsEditFunctionKey(), and the conversion does not produce any bytes.
     * Check for this special case so we have data when handling the
     * modifyOtherKeys resource.
     */
    if (keyboard->modify_now.other_keys > 1) {
	if (IsTabKey(kd.keysym) && kd.nbytes == 0) {
	    kd.nbytes = 1;
	    kd.strbuf[0] = '\t';
	}
    }
#ifdef XK_ISO_Left_Tab
    else if (IsTabKey(kd.keysym)
	     && kd.nbytes <= 1
	     && modify_parm == (MOD_NONE + MOD_SHIFT)) {
	kd.keysym = XK_ISO_Left_Tab;
    }
#endif
#endif /* OPT_MOD_FKEYS */

    /* VT300 & up: backarrow toggle */
    if ((kd.nbytes == 1)
	&& IsBackarrowToggle(keyboard, kd.keysym, evt_state)) {
	kd.strbuf[0] = ANSI_DEL;
	TRACE(("...Input backarrow changed to %d\n", kd.strbuf[0]));
    }
#if OPT_SUNPC_KBD
    /* make an DEC editing-keypad from a Sun or PC editing-keypad */
    if (keyboard->type == keyboardIsVT220
	&& (kd.keysym != XK_Delete || !xtermDeleteIsDEL(xw)))
	kd.keysym = TranslateFromSUNPC(kd.keysym);
    else
#endif
    {
#ifdef XK_KP_Home
	if (kd.keysym >= XK_KP_Home && kd.keysym <= XK_KP_Begin) {
	    TRACE(("...Input keypad before was " KEYSYM_FMT "\n", kd.keysym));
	    kd.keysym += (KeySym) (XK_Home - XK_KP_Home);
	    TRACE(("...Input keypad changed to " KEYSYM_FMT "\n", kd.keysym));
	}
#endif
    }

    /*
     * Map the Sun afterthought-keys in as F36 and F37.
     */
#ifdef SunXK_F36
    if (!kd.is_fkey) {
	if (kd.keysym == SunXK_F36) {
	    kd.keysym = XK_Fn(36);
	    kd.is_fkey = True;
	}
	if (kd.keysym == SunXK_F37) {
	    kd.keysym = XK_Fn(37);
	    kd.is_fkey = True;
	}
    }
#endif

    /*
     * Use the control- and shift-modifiers to obtain more function keys than
     * the keyboard provides.  We can do this if there is no conflicting use of
     * those modifiers:
     *
     * a) for VT220 keyboard, we use only the control-modifier.  The keyboard
     * uses shift-modifier for UDK's.
     *
     * b) for non-VT220 keyboards, we only have to check if the
     * modifyFunctionKeys resource is inactive.
     *
     * Thereafter, we note when we have a function-key and keep that
     * distinction when testing for "function-key" values.
     */
    if ((evt_state & (ControlMask | ShiftMask)) != 0
	&& kd.is_fkey) {

	/* VT220 keyboard uses shift for UDK */
	if (keyboard->type == keyboardIsVT220
	    || keyboard->type == keyboardIsLegacy) {

	    TRACE(("...map XK_F%ld", kd.keysym - XK_Fn(1) + 1));
	    if (evt_state & ControlMask) {
		kd.keysym += (KeySym) xw->misc.ctrl_fkeys;
		UIntClr(evt_state, ControlMask);
	    }
	    TRACE((" to XK_F%ld\n", kd.keysym - XK_Fn(1) + 1));

	}
#if OPT_MOD_FKEYS
	else if (keyboard->modify_now.function_keys < 0) {

	    TRACE(("...map XK_F%ld", kd.keysym - XK_Fn(1) + 1));
	    if (evt_state & ShiftMask) {
		kd.keysym += (KeySym) (xw->misc.ctrl_fkeys * 1);
		UIntClr(evt_state, ShiftMask);
	    }
	    if (evt_state & ControlMask) {
		kd.keysym += (KeySym) (xw->misc.ctrl_fkeys * 2);
		UIntClr(evt_state, ControlMask);
	    }
	    TRACE((" to XK_F%ld\n", kd.keysym - XK_Fn(1) + 1));

	}
	/*
	 * Reevaluate the modifier parameter, stripping off the modifiers
	 * that we just used.
	 */
	if (modify_parm) {
	    modify_parm = xtermStateToParam(xw, evt_state);
	}
#endif /* OPT_MOD_FKEYS */
    }

    /*
     * Test for one of the keyboard variants.
     */
    switch (keyboard->type) {
    case keyboardIsHP:
	hpfuncvalue(&reply, &kd);
	break;
    case keyboardIsSCO:
	scofuncvalue(&reply, &kd);
	break;
    case keyboardIsSun:
	sunfuncvalue(&reply, &kd);
	break;
    case keyboardIsTermcap:
#if OPT_TCAP_FKEYS
	if (xtermcapString(xw, (int) kd.keysym, evt_state))
	    return;
#endif
	break;
    case keyboardIsDefault:
    case keyboardIsLegacy:
    case keyboardIsVT220:
	break;
    }

    if (reply.a_final) {
	/*
	 * The key symbol matches one of the variants.  Most of those are
	 * function-keys, though some cursor- and editing-keys are mixed in.
	 */
	modifyCursorKey(&reply,
			((kd.is_fkey
			  || IsMiscFunctionKey(kd.keysym)
			  || IsEditFunctionKey(xw, kd.keysym))
			 ? keyboard->modify_now.function_keys
			 : keyboard->modify_now.cursor_keys),
			&modify_parm);
	MODIFIER_PARM;
	unparseseq(xw, &reply);
    } else if (((kd.is_fkey
		 || IsMiscFunctionKey(kd.keysym)
		 || IsEditFunctionKey(xw, kd.keysym))
#if OPT_MOD_FKEYS
		&& !ModifyOtherKeys(xw, evt_state, &kd, modify_parm)
#endif
	       ) || (kd.keysym == XK_Delete
		     && ((modify_parm != 0)
			 || !xtermDeleteIsDEL(xw)))) {
	dec_code = decfuncvalue(&kd);
	if ((evt_state & ShiftMask)
#if OPT_SUNPC_KBD
	    && keyboard->type == keyboardIsVT220
#endif
	    && ((string = (Char *) udk_lookup(xw, dec_code, &kd.nbytes)) != 0)) {
	    UIntClr(evt_state, ShiftMask);
	    while (kd.nbytes-- > 0)
		unparseputc(xw, CharOf(*string++));
	}
	/*
	 * Interpret F1-F4 as PF1-PF4 for VT52, VT100
	 */
	else if (keyboard->type != keyboardIsLegacy
		 && (dec_code >= 11 && dec_code <= 14)) {
	    reply.a_type = ANSI_SS3;
	    VT52_CURSOR_KEYS;
	    reply.a_final = (Char) A2E(dec_code - 11 + E2A('P'));
	    modifyCursorKey(&reply,
			    keyboard->modify_now.function_keys,
			    &modify_parm);
	    MODIFIER_PARM;
	    unparseseq(xw, &reply);
	} else {
	    reply.a_type = ANSI_CSI;
	    reply.a_final = 0;

#ifdef XK_ISO_Left_Tab
	    if (kd.keysym == XK_ISO_Left_Tab) {
		reply.a_nparam = 0;
		reply.a_final = 'Z';
#if OPT_MOD_FKEYS
		if (keyboard->modify_now.other_keys > 1
		    && computeMaskedModifier(xw, evt_state, ShiftMask))
		    modifyOtherKey(&reply, '\t', modify_parm, keyboard->format_keys);
#endif
	    } else
#endif /* XK_ISO_Left_Tab */
	    {
		reply.a_nparam = 1;
#if OPT_MOD_FKEYS
		if (kd.is_fkey) {
		    modifyCursorKey(&reply,
				    keyboard->modify_now.function_keys,
				    &modify_parm);
		}
		MODIFIER_PARM;
#endif
		reply.a_param[0] = (ParmType) dec_code;
		reply.a_final = '~';
	    }
	    if (reply.a_final != 0
		&& (reply.a_nparam == 0 || reply.a_param[0] >= 0))
		unparseseq(xw, &reply);
	}
	key = True;
    } else if (IsPFKey(kd.keysym)) {
	reply.a_type = ANSI_SS3;
	reply.a_final = (Char) ((kd.keysym - XK_KP_F1) + 'P');
	VT52_CURSOR_KEYS;
	MODIFIER_PARM;
	unparseseq(xw, &reply);
	key = True;
    } else if (IsKeypadKey(kd.keysym)) {
	if (keypad_mode) {
	    reply.a_type = ANSI_SS3;
	    reply.a_final = (Char) (kypd_apl[kd.keysym - XK_KP_Space]);
	    VT52_KEYPAD;
	    MODIFIER_PARM;
	    unparseseq(xw, &reply);
	} else {
	    unparseputc(xw, kypd_num[kd.keysym - XK_KP_Space]);
	}
	key = True;
    } else if (IsCursorKey(kd.keysym)) {
	if (keyboard->flags & MODE_DECCKM) {
	    reply.a_type = ANSI_SS3;
	} else {
	    reply.a_type = ANSI_CSI;
	}
	modifyCursorKey(&reply, keyboard->modify_now.cursor_keys, &modify_parm);
	reply.a_final = (Char) (curfinal[kd.keysym - XK_Home]);
	VT52_CURSOR_KEYS;
	MODIFIER_PARM;
	unparseseq(xw, &reply);
	key = True;
    } else if (kd.nbytes > 0) {

#if OPT_TEK4014
	if (TEK4014_GIN(tekWidget)) {
	    TekEnqMouse(tekWidget, kd.strbuf[0]);
	    TekGINoff(tekWidget);
	    kd.nbytes--;
	    for (j = 0; j < kd.nbytes; ++j) {
		kd.strbuf[j] = kd.strbuf[j + 1];
	    }
	}
#endif
#if OPT_MOD_FKEYS
	if ((keyboard->modify_now.other_keys > 0)
	    && ModifyOtherKeys(xw, evt_state, &kd, modify_parm)
	    && (mod_state = allowedCharModifiers(xw, evt_state, &kd)) != 0) {
	    int input_char;

	    evt_state = mod_state;

	    modify_parm = xtermStateToParam(xw, evt_state);

	    /*
	     * We want to show a keycode that corresponds to the 8-bit value
	     * of the key.  If the keysym is less than 256, that is good
	     * enough.  Special keys such as Tab may result in a value that
	     * is usable as well.  For the latter (special cases), try to use
	     * the result from the X library lookup.
	     */
	    input_char = ((kd.keysym < 256)
			  ? (int) kd.keysym
			  : ((kd.nbytes == 1)
			     ? CharOf(kd.strbuf[0])
			     : -1));

	    TRACE(("...modifyOtherKeys %d;%d\n", modify_parm, input_char));
	    if (modifyOtherKey(&reply, input_char, modify_parm, keyboard->format_keys)) {
		unparseseq(xw, &reply);
	    } else {
		Bell(xw, XkbBI_MinorError, 0);
	    }
	} else
#endif /* OPT_MOD_FKEYS */
	{
	    int prefix = 0;

#if OPT_NUM_LOCK
	    /*
	     * Send ESC if we have a META modifier and metaSendsEcape is true.
	     * Like eightBitInput, except that it is not associated with
	     * terminal settings.
	     */
	    if (kd.nbytes != 0) {
		if (screen->meta_sends_esc
		    && (evt_state & xw->work.meta_mods) != 0) {
		    TRACE(("...input-char is modified by META\n"));
		    UIntClr(evt_state, xw->work.meta_mods);
		    eightbit = False;
		    prefix = ANSI_ESC;
		} else if (eightbit) {
		    /* it might be overridden, but this helps for debugging */
		    TRACE(("...input-char is shifted by META\n"));
		}
		if (screen->alt_is_not_meta
		    && (evt_state & xw->work.alt_mods) != 0) {
		    UIntClr(evt_state, xw->work.alt_mods);
		    if (screen->alt_sends_esc) {
			TRACE(("...input-char is modified by ALT\n"));
			eightbit = False;
			prefix = ANSI_ESC;
		    } else if (!eightbit) {
			TRACE(("...input-char is shifted by ALT\n"));
			eightbit = True;
		    }
		}
	    }
#endif
	    /*
	     * If metaSendsEscape is false, fall through to this chunk, which
	     * implements the eightBitInput resource.
	     *
	     * It is normally executed when the user presses Meta plus a
	     * printable key, e.g., Meta+space.  The presence of the Meta
	     * modifier is not guaranteed since what really happens is the
	     * "insert-eight-bit" or "insert-seven-bit" action, which we
	     * distinguish by the eightbit parameter to this function.  So the
	     * eightBitInput resource really means that we use this shifting
	     * logic in the "insert-eight-bit" action.
	     */
	    if (eightbit && (kd.nbytes == 1) && screen->input_eight_bits) {
		IChar ch = CharOf(kd.strbuf[0]);
		if ((ch < 128) && (screen->eight_bit_meta == ebTrue)) {
		    kd.strbuf[0] |= (char) 0x80;
		    TRACE(("...input shift from %d to %d (%#x to %#x)\n",
			   ch, CharOf(kd.strbuf[0]),
			   ch, CharOf(kd.strbuf[0])));
#if OPT_WIDE_CHARS
		    if (screen->utf8_mode) {
			/*
			 * We could interpret the incoming code as "in the
			 * current locale", but it's simpler to treat it as
			 * a Unicode value to translate to UTF-8.
			 */
			ch = CharOf(kd.strbuf[0]);
			kd.nbytes = 2;
			kd.strbuf[0] = (char) (0xc0 | ((ch >> 6) & 0x3));
			kd.strbuf[1] = (char) (0x80 | (ch & 0x3f));
			TRACE(("...encoded %#x in UTF-8 as %#x,%#x\n",
			       ch, CharOf(kd.strbuf[0]), CharOf(kd.strbuf[1])));
		    }
#endif
		}
		eightbit = False;
	    }
#if OPT_WIDE_CHARS
	    if (kd.nbytes == 1)	/* cannot do NRC on UTF-8, for instance */
#endif
	    {
		/* VT220 & up: National Replacement Characters */
		if ((xw->flags & NATIONAL) != 0) {
		    unsigned cmp = xtermCharSetIn(screen,
						  CharOf(kd.strbuf[0]),
						  screen->keyboard_dialect[0]);
		    TRACE(("...input NRC %d, %s %d\n",
			   CharOf(kd.strbuf[0]),
			   (CharOf(kd.strbuf[0]) == cmp)
			   ? "unchanged"
			   : "changed to",
			   CharOf(cmp)));
		    kd.strbuf[0] = (char) cmp;
		} else if (eightbit) {
		    prefix = ANSI_ESC;
		} else if (kd.strbuf[0] == '?'
			   && (evt_state & ControlMask) != 0) {
		    kd.strbuf[0] = ANSI_DEL;
		    /* UIntClr(evt_state, ControlMask); */
		}
	    }
	    if (prefix != 0)
		unparseputc(xw, prefix);	/* escape */
	    for (j = 0; j < kd.nbytes; ++j)
		unparseputc(xw, CharOf(kd.strbuf[j]));
	}
	key = ((kd.keysym != ANSI_XOFF) && (kd.keysym != ANSI_XON));
    }
    unparse_end(xw);

    if (key && !TEK4014_ACTIVE(xw))
	AdjustAfterInput(xw);

    xtermShowPointer(xw, False);
    return;
}

void
StringInput(XtermWidget xw, const Char *string, size_t nbytes)
{
    TRACE(("InputString (%s,%lu)\n",
	   visibleChars(string, (unsigned) nbytes),
	   (unsigned long) nbytes));
#if OPT_TEK4014
    if (nbytes && TEK4014_GIN(tekWidget)) {
	TekEnqMouse(tekWidget, *string++);
	TekGINoff(tekWidget);
	nbytes--;
    }
#endif
    while (nbytes-- != 0)
	unparseputc(xw, *string++);
    if (!TEK4014_ACTIVE(xw))
	AdjustAfterInput(xw);
    unparse_end(xw);
}

/* These definitions are DEC-style (e.g., vt320) */
static int
decfuncvalue(KEY_DATA * kd)
{
    int result;

    if (kd->is_fkey) {
	switch (kd->keysym) {
	    MAP(XK_Fn(1), 11);
	    MAP(XK_Fn(2), 12);
	    MAP(XK_Fn(3), 13);
	    MAP(XK_Fn(4), 14);
	    MAP(XK_Fn(5), 15);
	    MAP(XK_Fn(6), 17);
	    MAP(XK_Fn(7), 18);
	    MAP(XK_Fn(8), 19);
	    MAP(XK_Fn(9), 20);
	    MAP(XK_Fn(10), 21);
	    MAP(XK_Fn(11), 23);
	    MAP(XK_Fn(12), 24);
	    MAP(XK_Fn(13), 25);
	    MAP(XK_Fn(14), 26);
	    MAP(XK_Fn(15), 28);
	    MAP(XK_Fn(16), 29);
	    MAP(XK_Fn(17), 31);
	    MAP(XK_Fn(18), 32);
	    MAP(XK_Fn(19), 33);
	    MAP(XK_Fn(20), 34);
	default:
	    /* after F20 the codes are made up and do not correspond to any
	     * real terminal.  So they are simply numbered sequentially.
	     */
	    result = 42 + (int) (kd->keysym - XK_Fn(21));
	    break;
	}
    } else {
	switch (kd->keysym) {
	    MAP(XK_Find, 1);
	    MAP(XK_Insert, 2);
	    MAP(XK_Delete, 3);
#ifdef XK_KP_Insert
	    MAP(XK_KP_Insert, 2);
	    MAP(XK_KP_Delete, 3);
#endif
#ifdef DXK_Remove
	    MAP(DXK_Remove, 3);
#endif
	    MAP(XK_Select, 4);
	    MAP(XK_Prior, 5);
	    MAP(XK_Next, 6);
#ifdef XK_ISO_Left_Tab
	    MAP(XK_ISO_Left_Tab, 'Z');
#endif
	    MAP(XK_Help, 28);
	    MAP(XK_Menu, 29);
	default:
	    result = -1;
	    break;
	}
    }
    return result;
}

static void
hpfuncvalue(ANSI *reply, KEY_DATA * kd)
{
#if OPT_HP_FUNC_KEYS
    int result;

    if (kd->is_fkey) {
	switch (kd->keysym) {
	    MAP(XK_Fn(1), 'p');
	    MAP(XK_Fn(2), 'q');
	    MAP(XK_Fn(3), 'r');
	    MAP(XK_Fn(4), 's');
	    MAP(XK_Fn(5), 't');
	    MAP(XK_Fn(6), 'u');
	    MAP(XK_Fn(7), 'v');
	    MAP(XK_Fn(8), 'w');
	default:
	    result = -1;
	    break;
	}
    } else {
	switch (kd->keysym) {
	    MAP(XK_Up, 'A');
	    MAP(XK_Down, 'B');
	    MAP(XK_Right, 'C');
	    MAP(XK_Left, 'D');
	    MAP(XK_End, 'F');
	    MAP(XK_Clear, 'J');
	    MAP(XK_Delete, 'P');
	    MAP(XK_Insert, 'Q');
	    MAP(XK_Next, 'S');
	    MAP(XK_Prior, 'T');
	    MAP(XK_Home, 'h');
#ifdef XK_KP_Insert
	    MAP(XK_KP_Delete, 'P');
	    MAP(XK_KP_Insert, 'Q');
#endif
#ifdef DXK_Remove
	    MAP(DXK_Remove, 'P');
#endif
	    MAP(XK_Select, 'F');
	    MAP(XK_Find, 'h');
	default:
	    result = -1;
	    break;
	}
    }
    if (result > 0) {
	reply->a_type = ANSI_ESC;
	reply->a_final = (Char) result;
    }
#else
    (void) reply;
    (void) kd;
#endif /* OPT_HP_FUNC_KEYS */
}

static void
scofuncvalue(ANSI *reply, KEY_DATA * kd)
{
#if OPT_SCO_FUNC_KEYS
    int result;

    if (kd->is_fkey) {
	switch (kd->keysym) {
	    MAP(XK_Fn(1), 'M');
	    MAP(XK_Fn(2), 'N');
	    MAP(XK_Fn(3), 'O');
	    MAP(XK_Fn(4), 'P');
	    MAP(XK_Fn(5), 'Q');
	    MAP(XK_Fn(6), 'R');
	    MAP(XK_Fn(7), 'S');
	    MAP(XK_Fn(8), 'T');
	    MAP(XK_Fn(9), 'U');
	    MAP(XK_Fn(10), 'V');
	    MAP(XK_Fn(11), 'W');
	    MAP(XK_Fn(12), 'X');
	    MAP(XK_Fn(13), 'Y');
	    MAP(XK_Fn(14), 'Z');
	    MAP(XK_Fn(15), 'a');
	    MAP(XK_Fn(16), 'b');
	    MAP(XK_Fn(17), 'c');
	    MAP(XK_Fn(18), 'd');
	    MAP(XK_Fn(19), 'e');
	    MAP(XK_Fn(20), 'f');
	    MAP(XK_Fn(21), 'g');
	    MAP(XK_Fn(22), 'h');
	    MAP(XK_Fn(23), 'i');
	    MAP(XK_Fn(24), 'j');
	    MAP(XK_Fn(25), 'k');
	    MAP(XK_Fn(26), 'l');
	    MAP(XK_Fn(27), 'm');
	    MAP(XK_Fn(28), 'n');
	    MAP(XK_Fn(29), 'o');
	    MAP(XK_Fn(30), 'p');
	    MAP(XK_Fn(31), 'q');
	    MAP(XK_Fn(32), 'r');
	    MAP(XK_Fn(33), 's');
	    MAP(XK_Fn(34), 't');
	    MAP(XK_Fn(35), 'u');
	    MAP(XK_Fn(36), 'v');
	    MAP(XK_Fn(37), 'w');
	    MAP(XK_Fn(38), 'x');
	    MAP(XK_Fn(39), 'y');
	    MAP(XK_Fn(40), 'z');
	    MAP(XK_Fn(41), '@@');
	    MAP(XK_Fn(42), '[');
	    MAP(XK_Fn(43), '\\');
	    MAP(XK_Fn(44), ']');
	    MAP(XK_Fn(45), '^');
	    MAP(XK_Fn(46), '_');
	    MAP(XK_Fn(47), '`');
	    MAP(XK_Fn(48), L_CURL);
	default:
	    result = -1;
	    break;
	}
    } else {
	switch (kd->keysym) {
	    MAP(XK_Up, 'A');
	    MAP(XK_Down, 'B');
	    MAP(XK_Right, 'C');
	    MAP(XK_Left, 'D');
	    MAP(XK_Begin, 'E');
	    MAP(XK_End, 'F');
	    MAP(XK_Insert, 'L');
	    MAP(XK_Next, 'G');
	    MAP(XK_Prior, 'I');
	    MAP(XK_Home, 'H');
#ifdef XK_KP_Insert
	    MAP(XK_KP_Insert, 'L');
#endif
	default:
	    result = -1;
	    break;
	}
    }
    if (result > 0) {
	reply->a_type = ANSI_CSI;
	reply->a_final = (Char) result;
    }
#else
    (void) reply;
    (void) kd;
#endif /* OPT_SCO_FUNC_KEYS */
}

static void
sunfuncvalue(ANSI *reply, KEY_DATA * kd)
{
#if OPT_SUN_FUNC_KEYS
    ParmType result;

    if (kd->is_fkey) {
	switch (kd->keysym) {
	    /* kf1-kf20 are numbered sequentially */
	    MAP(XK_Fn(1), 224);
	    MAP(XK_Fn(2), 225);
	    MAP(XK_Fn(3), 226);
	    MAP(XK_Fn(4), 227);
	    MAP(XK_Fn(5), 228);
	    MAP(XK_Fn(6), 229);
	    MAP(XK_Fn(7), 230);
	    MAP(XK_Fn(8), 231);
	    MAP(XK_Fn(9), 232);
	    MAP(XK_Fn(10), 233);
	    MAP(XK_Fn(11), 192);
	    MAP(XK_Fn(12), 193);
	    MAP(XK_Fn(13), 194);
	    MAP(XK_Fn(14), 195);	/* kund */
	    MAP(XK_Fn(15), 196);
	    MAP(XK_Fn(16), 197);	/* kcpy */
	    MAP(XK_Fn(17), 198);
	    MAP(XK_Fn(18), 199);
	    MAP(XK_Fn(19), 200);	/* kfnd */
	    MAP(XK_Fn(20), 201);

	    /* kf31-kf36 are numbered sequentially */
	    MAP(XK_Fn(21), 208);	/* kf31 */
	    MAP(XK_Fn(22), 209);
	    MAP(XK_Fn(23), 210);
	    MAP(XK_Fn(24), 211);
	    MAP(XK_Fn(25), 212);
	    MAP(XK_Fn(26), 213);	/* kf36 */

	    /* kf37-kf47 are interspersed with keypad keys */
	    MAP(XK_Fn(27), 214);	/* khome */
	    MAP(XK_Fn(28), 215);	/* kf38 */
	    MAP(XK_Fn(29), 216);	/* kpp */
	    MAP(XK_Fn(30), 217);	/* kf40 */
	    MAP(XK_Fn(31), 218);	/* kb2 */
	    MAP(XK_Fn(32), 219);	/* kf42 */
	    MAP(XK_Fn(33), 220);	/* kend */
	    MAP(XK_Fn(34), 221);	/* kf44 */
	    MAP(XK_Fn(35), 222);	/* knp */
	    MAP(XK_Fn(36), 234);	/* kf46 */
	    MAP(XK_Fn(37), 235);	/* kf47 */
	default:
	    result = -1;
	    break;
	}
    } else {
	switch (kd->keysym) {
	    MAP(XK_Help, 196);	/* khlp */
	    MAP(XK_Menu, 197);

	    MAP(XK_Find, 1);
	    MAP(XK_Insert, 2);	/* kich1 */
	    MAP(XK_Delete, 3);
#ifdef XK_KP_Insert
	    MAP(XK_KP_Insert, 2);
	    MAP(XK_KP_Delete, 3);
#endif
#ifdef DXK_Remove
	    MAP(DXK_Remove, 3);
#endif
	    MAP(XK_Select, 4);

	    MAP(XK_Prior, 216);
	    MAP(XK_Next, 222);
	    MAP(XK_Home, 214);
	    MAP(XK_End, 220);
	    MAP(XK_Begin, 218);	/* kf41=kb2 */

	default:
	    result = -1;
	    break;
	}
    }
    if (result > 0) {
	reply->a_type = ANSI_CSI;
	reply->a_nparam = 1;
	reply->a_param[0] = result;
	reply->a_final = 'z';
    } else if (IsCursorKey(kd->keysym)) {
	reply->a_type = ANSI_SS3;
	reply->a_final = (Char) curfinal[kd->keysym - XK_Home];
    }
#else
    (void) reply;
    (void) kd;
#endif /* OPT_SUN_FUNC_KEYS */
}

#if OPT_NUM_LOCK
#define isName(c) ((c) == '_' || (c) == '-' || isalnum(CharOf(c)))

static const char *
skipName(const char *s)
{
    while (*s != '\0' && isName(CharOf(*s)))
	++s;
    return s;
}

/*
 * Found a ":" in a translation, check what is past it to see if it contains
 * any of the insert-text action names.
 */
static Boolean
keyCanInsert(const char *parse)
{
    Boolean result = False;
    Boolean escape = False;
    Boolean quoted = False;

    static const char *const table[] =
    {
	"insert",
	"insert-seven-bit",
	"insert-eight-bit",
	"string",
    };
    Cardinal n;

    while (*parse != '\0' && *parse != '\n') {
	int ch = CharOf(*parse++);
	if (escape) {
	    escape = False;
	} else if (ch == '\\') {
	    escape = True;
	} else if (ch == '"') {
	    quoted = (Boolean) !quoted;
	} else if (!quoted && isName(ch)) {
	    const char *next = skipName(--parse);
	    size_t need = (size_t) (next - parse);

	    for (n = 0; n < XtNumber(table); ++n) {
		if (need == strlen(table[n])
		    && !strncmp(parse, table[n], need)) {
		    result = True;
		    break;
		}
	    }
	    parse = next;
	}

    }
    return result;
}

/*
 * Strip the entire action, to avoid matching it.
 */
static char *
stripAction(char *base, char *last)
{
    while (last != base) {
	if (*--last == '\n') {
	    break;
	}
    }
    return last;
}

static char *
stripBlanks(char *base, char *last)
{
    while (last != base) {
	int ch = CharOf(last[-1]);
	if (ch != ' ' && ch != '\t')
	    break;
	--last;
    }
    return last;
}

/*
 * Strip unneeded whitespace from a translations resource, mono-casing and
 * returning a malloc'd copy of the result.
 */
static char *
stripTranslations(const char *s, Bool onlyInsert)
{
    char *dst = 0;

    if (s != 0) {
	dst = TypeMallocN(char, strlen(s) + 1);

	if (dst != 0) {
	    int state = 0;
	    int prv = 0;
	    char *d = dst;

	    TRACE(("stripping:\n%s\n", s));
	    while (*s != '\0') {
		int ch = *s++;
		if (ch == '\n') {
		    if (d != dst)
			*d++ = (char) ch;
		    state = 0;
		} else if (strchr(":!#", ch) != 0) {
		    d = stripBlanks(dst, d);
		    if (onlyInsert && (ch == ':') && !keyCanInsert(s)) {
			d = stripAction(dst, d);
		    }
		    state = -1;
		} else if (state >= 0) {
		    if (isspace(CharOf(ch))) {
			if (state == 0 || strchr("<>~ \t", prv))
			    continue;
		    } else if (strchr("<>~", ch)) {
			d = stripBlanks(dst, d);
		    }
		    *d++ = x_toupper(ch);
		    ++state;
		}
		prv = ch;
	    }
	    *d = '\0';
	    TRACE(("...result:\n%s\n", dst));
	}
    }
    return dst;
}

/*
 * Make a simple check to see if a given translations keyword appears in
 * xterm's translations resource.  It does not attempt to parse the strings,
 * just makes a case-independent check and ensures that the ends of the match
 * are on token-boundaries.
 *
 * That this can only retrieve translations that are given as resource values;
 * the default translations in charproc.c for example are not retrievable by
 * any interface to X.
 *
 * Also:  We can retrieve only the most-specified translation resource.  For
 * example, if the resource file specifies both "*translations" and
 * "XTerm*translations", we see only the latter.
 */
static Bool
TranslationsUseKeyword(Widget w, char **cache, const char *keyword, Bool onlyInsert)
{
    Bool result = False;
    char *copy;
    char *test;

    if ((test = stripTranslations(keyword, onlyInsert)) != 0) {
	if (*cache == 0) {
	    String data = 0;
	    getKeymapResources(w, "vt100", "VT100", XtRString, &data, sizeof(data));
	    if (data != 0 && (copy = stripTranslations(data, onlyInsert)) != 0) {
		*cache = copy;
	    }
	}

	if (*cache != 0) {
	    char *p = *cache;
	    int state = 0;
	    int now = ' ';

	    while (*p != 0) {
		int prv = now;
		now = *p++;
		if (now == ':'
		    || now == '!') {
		    state = -1;
		} else if (now == '\n') {
		    state = 0;
		} else if (state >= 0) {
		    if (now == test[state]) {
			if ((state != 0
			     || !isName(prv))
			    && ((test[++state] == 0)
				&& !isName(*p))) {
			    result = True;
			    break;
			}
		    } else {
			state = 0;
		    }
		}
	    }
	}
	free(test);
    }
    TRACE(("TranslationsUseKeyword(%p, %s) = %d\n",
	   (void *) w, keyword, result));
    return result;
}

static Bool
xtermHasTranslation(XtermWidget xw, const char *keyword, Bool onlyInsert)
{
    return (TranslationsUseKeyword(SHELL_OF(xw),
				   &(xw->keyboard.shell_translations),
				   keyword,
				   onlyInsert)
	    || TranslationsUseKeyword((Widget) xw,
				      &(xw->keyboard.xterm_translations),
				      keyword,
				      onlyInsert));
}

#if OPT_EXTRA_PASTE
static void
addTranslation(XtermWidget xw, const char *fromString, const char *toString)
{
    size_t have = (xw->keyboard.extra_translations
		   ? strlen(xw->keyboard.extra_translations)
		   : 0);
    size_t need = (((have != 0) ? (have + 4) : 0)
		   + strlen(fromString)
		   + strlen(toString)
		   + 6);

    if (!xtermHasTranslation(xw, fromString, False)) {
	xw->keyboard.extra_translations
	    = TypeRealloc(char, need, xw->keyboard.extra_translations);
	if ((xw->keyboard.extra_translations) != 0) {
	    TRACE(("adding %s: %s\n", fromString, toString));
	    if (have)
		strcat(xw->keyboard.extra_translations, " \\n\\");
	    sprintf(xw->keyboard.extra_translations, "%s: %s",
		    fromString, toString);
	    TRACE(("...{%s}\n", xw->keyboard.extra_translations));
	}
    }
}
#endif

#define SaveMask(name)	xw->work.name |= (unsigned) mask;\
			TRACE(("SaveMask(%#x -> %s) %#x (%#x is%s modifier)\n", \
				(unsigned) keysym, #name, \
				xw->work.name, (unsigned) mask, \
				ModifierName((unsigned) mask)));
/*
 * Determine which modifier mask (if any) applies to the Num_Lock keysym.
 *
 * Also, determine which modifiers are associated with the ALT keys, so we can
 * send that information as a parameter for special keys in Sun/PC keyboard
 * mode.  However, if the ALT modifier is used in translations, we do not want
 * to confuse things by sending the parameter.
 */
void
VTInitModifiers(XtermWidget xw)
{
    Display *dpy = XtDisplay(xw);
    XModifierKeymap *keymap = XGetModifierMapping(dpy);
    KeySym keysym;
    int min_keycode, max_keycode, keysyms_per_keycode = 0;

    if (keymap != 0) {
	KeySym *theMap;
	int keycode_count;

	TRACE(("VTInitModifiers\n"));

	XDisplayKeycodes(dpy, &min_keycode, &max_keycode);
	keycode_count = (max_keycode - min_keycode + 1);
	theMap = XGetKeyboardMapping(dpy,
				     (KeyCode) min_keycode,
				     keycode_count,
				     &keysyms_per_keycode);

	if (theMap != 0) {
	    int i, j, k, l;
	    unsigned long mask;

#if OPT_EXTRA_PASTE
	    /*
	     * Assume that if we can find the paste keysym in the X keyboard
	     * mapping that the server allows the corresponding translations
	     * resource.
	     */
	    int limit = (max_keycode - min_keycode) * keysyms_per_keycode;
	    for (i = 0; i < limit; ++i) {
#ifdef XF86XK_Paste
		if (theMap[i] == XF86XK_Paste) {
		    TRACE(("keyboard has XF86XK_Paste\n"));
		    addTranslation(xw,
				   ":<KeyPress> XF86Paste",
				   "insert-selection(SELECT, CUT_BUFFER0)");
		}
#endif
#ifdef SunXK_Paste
		if (theMap[i] == SunXK_Paste) {
		    TRACE(("keyboard has SunXK_Paste\n"));
		    addTranslation(xw,
				   ":<KeyPress> SunPaste",
				   "insert-selection(SELECT, CUT_BUFFER0)");
		}
#endif
	    }
#endif /* OPT_EXTRA_PASTE */

	    for (i = k = 0, mask = 1; i < 8; i++, mask <<= 1) {
		for (j = 0; j < keymap->max_keypermod; j++) {
		    KeyCode code = keymap->modifiermap[k++];
		    if (code == 0)
			continue;

		    for (l = 0; l < keysyms_per_keycode; ++l) {
#ifdef HAVE_XKBKEYCODETOKEYSYM
			keysym = XkbKeycodeToKeysym(dpy, code, 0, l);
#else
			keysym = XKeycodeToKeysym(dpy, code, l);
#endif
			if (keysym == NoSymbol) {
			    /* EMPTY */ ;
			} else if (keysym == XK_Num_Lock) {
			    SaveMask(num_lock);
			} else if (keysym == XK_Alt_L || keysym == XK_Alt_R) {
			    SaveMask(alt_mods);
			} else if (keysym == XK_Meta_L || keysym == XK_Meta_R) {
			    SaveMask(meta_mods);
			}
		    }
		}
	    }
	    XFree(theMap);
	}

	/* Don't disable any mods if "alwaysUseMods" is true. */
	if (!xw->misc.alwaysUseMods) {

	    /*
	     * Force TranslationsUseKeyword() to reload.
	     */
	    if (xw->keyboard.shell_translations) {
		free(xw->keyboard.shell_translations);
		xw->keyboard.shell_translations = 0;
	    }
	    if (xw->keyboard.xterm_translations) {
		free(xw->keyboard.xterm_translations);
		xw->keyboard.xterm_translations = 0;
	    }

	    /*
	     * If the Alt modifier is used in translations, we would rather not
	     * use it to modify function-keys when NumLock is active.
	     */
	    if ((xw->work.alt_mods != 0)
		&& xtermHasTranslation(xw, "alt", True)) {
		TRACE(("ALT is used as a modifier in translations (ignore mask)\n"));
		xw->work.alt_mods = 0;
	    }

	    /*
	     * If the Meta modifier is used in translations, we would rather not
	     * use it to modify function-keys.
	     */
	    if ((xw->work.meta_mods != 0)
		&& xtermHasTranslation(xw, "meta", True)) {
		TRACE(("META is used as a modifier in translations\n"));
		xw->work.meta_mods = 0;
	    }
	}

	XFreeModifiermap(keymap);
    }
}
#endif /* OPT_NUM_LOCK */
@


1.21
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.354 2015/04/10 10:50:21 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2014,2015 by Thomas E. Dickey
d421 1
a421 1
	UIntClr(state, xw->work.meta_mods);
d812 3
d816 2
a817 1
    Boolean result = True;
a1230 1
	int prefix = 0;
d1274 2
d1365 1
a1365 1
		    UIntClr(evt_state, ControlMask);
a1729 1
    int ch;
d1743 1
a1743 1
	ch = CharOf(*parse++);
a1807 1
	    int ch = 0;
d1813 1
a1813 1
		ch = *s++;
d1876 1
a1876 1
	    int now = ' ', prv;
d1879 1
a1879 1
		prv = now;
a1965 1
    int i, j, k, l;
a1966 1
    unsigned long mask;
d1983 2
@


1.20
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.351 2014/04/27 23:50:36 Matthieu.Herrb Exp $ */
d4 1
a4 1
 * Copyright 1999-2013,2014 by Thomas E. Dickey
d133 2
a134 2
const char *kypd_num = " XXXXXXXX\tXXX\rXXXxxxxXXXXXXXXXXXXXXXXXXXXX*+,-./0123456789XXX=";
/*                      0123456789 abc def0123456789abcdef0123456789abcdef0123456789abcd */
d136 2
a137 2
const char *kypd_apl = " ABCDEFGHIJKLMNOPQRSTUVWXYZ??????abcdefghijklmnopqrstuvwxyzXXX";
/*                      0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd */
d139 1
a139 1
const char *curfinal = "HDACB  FE";
d809 1
a809 1
lookupKeyData(KEY_DATA * kd, XtermWidget xw, XKeyEvent * event)
d878 1
a878 1
      XKeyEvent * event,
d1574 1
a1574 1
	    MAP(XK_Fn(48), '{');	/* no matching '}' */
d1729 1
a1729 1
    static const char *table[] =
a1856 6
    static String data;
    static XtResource key_resources[] =
    {
	{XtNtranslations, XtCTranslations, XtRString,
	 sizeof(data), 0, XtRString, (XtPointer) NULL}
    };
d1863 2
a1864 8
	    XtGetSubresources(w,
			      (XtPointer) &data,
			      "vt100",
			      "VT100",
			      key_resources,
			      XtNumber(key_resources),
			      NULL,
			      (Cardinal) 0);
@


1.19
log
@Apply the ':' symbol to the SunPaste/XF86Paste events translations.

This makes shure that shift modifers are taken into account to trigger
the translation. It fixes the 'v' key on Zaurus keyboard, which has
SunPaste at 3rd level and was thus bound to insert-selection() regardless
of the shift level.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.348 2013/11/26 00:12:10 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2012,2013 by Thomas E. Dickey
d1145 1
a1145 1
	    && ((string = (Char *) udk_lookup(dec_code, &kd.nbytes)) != 0)) {
@


1.18
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d2007 1
a2007 1
				   "<KeyPress> XF86Paste",
d2015 1
a2015 1
				   "<KeyPress> SunPaste",
@


1.17
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.345 2013/02/06 09:51:33 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2011,2012 by Thomas E. Dickey
a323 2
    TScreen *screen = TScreenOf(xw);
    int keypad_mode = ((keyboard->flags & MODE_DECKPAM) != 0);
a331 1
    (void) screen;
d333 1
a333 1
    if (screen->vtXX_level != 0)
d339 1
a339 3
	    if (keypad_mode) {
		result = LegacyAllows(1);
	    }
d662 1
a662 1
modifyOtherKey(ANSI * reply, int input_char, unsigned modify_parm, int format_keys)
d685 1
a685 1
modifyCursorKey(ANSI * reply, int modify, unsigned *modify_parm)
d1345 2
a1346 1
		    unsigned cmp = xtermCharSetIn(CharOf(kd.strbuf[0]),
d1380 1
a1380 1
StringInput(XtermWidget xw, const Char * string, size_t nbytes)
d1463 1
a1463 1
hpfuncvalue(ANSI * reply, KEY_DATA * kd)
d1520 1
a1520 1
scofuncvalue(ANSI * reply, KEY_DATA * kd)
d1610 1
a1610 1
sunfuncvalue(ANSI * reply, KEY_DATA * kd)
d1745 1
a1745 1
	    quoted = (Boolean) ! quoted;
@


1.16
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.344 2012/11/23 18:43:35 tom Exp $ */
a144 36

#if OPT_TRACE
static const char *
ModifierName(unsigned modifier)
{
    const char *s = "";
    if (modifier & ShiftMask)
	s = " Shift";
    else if (modifier & LockMask)
	s = " Lock";
    else if (modifier & ControlMask)
	s = " Control";
    else if (modifier & Mod1Mask)
	s = " Mod1";
    else if (modifier & Mod2Mask)
	s = " Mod2";
    else if (modifier & Mod3Mask)
	s = " Mod3";
    else if (modifier & Mod4Mask)
	s = " Mod4";
    else if (modifier & Mod5Mask)
	s = " Mod5";
    return s;
}

#define FMT_MODIFIER_NAMES "%s%s%s%s%s%s%s%s"
#define ARG_MODIFIER_NAMES(state) \
	   ModifierName(state & ShiftMask), \
	   ModifierName(state & LockMask), \
	   ModifierName(state & ControlMask), \
	   ModifierName(state & Mod1Mask), \
	   ModifierName(state & Mod2Mask), \
	   ModifierName(state & Mod3Mask), \
	   ModifierName(state & Mod4Mask), \
	   ModifierName(state & Mod5Mask)
#endif
@


1.15
log
@Update to xterm 279. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.334 2012/03/15 00:01:30 tom Exp $ */
d77 4
d208 1
a208 1
 * IsCursorKey() and IsKeypadKey() and must be tested before those macro to
d210 15
d227 1
a227 1
IsEditFunctionKey(KeySym keysym)
d229 2
d232 8
a239 5
    case XK_Prior:		/* editing keypad */
    case XK_Next:		/* editing keypad */
    case XK_Insert:		/* editing keypad */
    case XK_Find:		/* editing keypad */
    case XK_Select:		/* editing keypad */
d241 1
a241 1
    case DXK_Remove:		/* editing keypad */
d243 19
d269 2
a270 1
	return True;
d272 2
a273 1
	return False;
d275 1
d350 6
d362 1
a362 1

a364 2
    (void) screen;
    if (!(IsKeypadKey(kd->keysym) && keypad_mode)
d366 2
a367 1
	&& keyboard->type != keyboardIsVT220
d369 2
d372 1
a372 1
	&& screen->vtXX_level != 0
d374 14
a387 1
	) {
d418 1
a418 5
    if (param > MOD_NONE
	&& ((ShiftMask
	     | ControlMask
	     | xw->misc.alt_mods
	     | xw->misc.meta_mods) & xw->misc.other_mods) == 0) {
d424 1
a424 1
	    UIntSet(result, xw->misc.alt_mods);
d426 1
a426 1
	    UIntSet(result, xw->misc.meta_mods);
d448 15
a462 17
    if ((state & xw->misc.other_mods) == 0) {
	if (state & ShiftMask) {
	    modify_parm += MOD_SHIFT;
	    UIntClr(state, ShiftMask);
	}
	if (state & ControlMask) {
	    modify_parm += MOD_CTRL;
	    UIntClr(state, ControlMask);
	}
	if ((state & xw->misc.alt_mods) != 0) {
	    modify_parm += MOD_ALT;
	    UIntClr(state, xw->misc.alt_mods);
	}
	if ((state & xw->misc.meta_mods) != 0) {
	    modify_parm += MOD_META;
	    UIntClr(state, xw->misc.meta_mods);
	}
d526 1
a526 1
    unsigned a_or_m = (state & (xw->misc.meta_mods | xw->misc.alt_mods));
d563 1
a563 1
			       xw->misc.meta_mods,
d567 1
a567 1
				   xw->misc.alt_mods,
d597 1
a597 1
	|| IsEditFunctionKey(kd->keysym)
d602 1
a602 5
	|| IsPrivateKeypadKey(kd->keysym)
#if OPT_NUM_LOCK
	|| (state & xw->misc.other_mods) != 0
#endif
	) {
d849 2
a850 4
void
Input(XtermWidget xw,
      XKeyEvent * event,
      Bool eightbit)
d852 1
a852 2
    Char *string;

d854 1
a854 1
    TScreen *screen = TScreenOf(xw);
d856 1
a856 9
    int j;
    int key = False;
    ANSI reply;
    int dec_code;
    unsigned modify_parm = 0;
    int keypad_mode = ((keyboard->flags & MODE_DECKPAM) != 0);
    unsigned evt_state = event->state;
    unsigned mod_state;
    KEY_DATA kd;
d858 2
a859 6
    /* Ignore characters typed at the keyboard */
    if (keyboard->flags & MODE_KAM)
	return;

    kd.keysym = 0;
    kd.is_fkey = False;
d862 5
a866 5
	kd.keysym = (KeySym) screen->tc_query_code;
	kd.is_fkey = screen->tc_query_fkey;
	if (kd.keysym != XK_BackSpace) {
	    kd.nbytes = 0;
	    kd.strbuf[0] = 0;
d868 2
a869 2
	    kd.nbytes = 1;
	    kd.strbuf[0] = 8;
d876 1
a876 1
	if (input->xic) {
d880 3
a882 3
		kd.nbytes = Xutf8LookupString(input->xic, event,
					      kd.strbuf, (int) sizeof(kd.strbuf),
					      &kd.keysym, &status_return);
d886 3
a888 3
		kd.nbytes = XmbLookupString(input->xic, event,
					    kd.strbuf, (int) sizeof(kd.strbuf),
					    &kd.keysym, &status_return);
d895 2
a896 2
		&& kd.nbytes <= 1
		&& !IsPredefinedKey(kd.keysym)
d898 3
a900 3
		&& !IsControlInput(&kd)) {
		kd.nbytes = 1;
		kd.strbuf[0] = (char) kd.keysym;
d908 3
a910 2
	    kd.nbytes = XLookupString(event, kd.strbuf, (int) sizeof(kd.strbuf),
				      &kd.keysym, &compose_status);
d912 1
a912 1
	kd.is_fkey = IsFunctionKey(kd.keysym);
d914 28
d961 1
a961 1
	   IsEditFunctionKey(kd.keysym) ? " EditFkey" : ""));
d1007 1
a1007 1
	&& (xw->misc.num_lock & evt_state) != 0) {
d1166 1
a1166 1
			  || IsEditFunctionKey(kd.keysym))
d1174 1
a1174 1
		 || IsEditFunctionKey(kd.keysym))
d1320 1
a1320 1
		    && (evt_state & xw->misc.meta_mods) != 0) {
d1322 1
a1322 1
		    UIntClr(evt_state, xw->misc.meta_mods);
d1330 2
a1331 2
		    && (evt_state & xw->misc.alt_mods) != 0) {
		    UIntClr(evt_state, xw->misc.alt_mods);
d1997 4
a2000 4
#define SaveMask(name)	xw->misc.name |= (unsigned) mask;\
			TRACE(("SaveMask(%s) %#x (%#x is%s modifier)\n", \
				#name, \
				xw->misc.name, (unsigned) mask, \
d2069 3
d2073 1
a2081 17
			} else if (mask == ShiftMask
				   && (keysym == XK_Shift_L
				       || keysym == XK_Shift_R)) {
			    /* EMPTY */ ;
			} else if (mask == ControlMask
				   && (keysym == XK_Control_L
				       || keysym == XK_Control_R)) {
			    /* EMPTY */ ;
			} else if (mask == LockMask
				   && (keysym == XK_Caps_Lock)) {
			    /* EMPTY */ ;
			} else if (keysym == XK_Mode_switch
#ifdef XK_ISO_Level3_Shift
				   || keysym == XK_ISO_Level3_Shift
#endif
			    ) {
			    SaveMask(other_mods);
d2108 1
a2108 1
	    if ((xw->misc.alt_mods != 0)
d2111 1
a2111 1
		xw->misc.alt_mods = 0;
d2118 1
a2118 1
	    if ((xw->misc.meta_mods != 0)
d2121 1
a2121 1
		xw->misc.meta_mods = 0;
@


1.14
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.333 2012/01/07 02:01:05 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2010,2011 by Thomas E. Dickey
@


1.13
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.327 2011/02/09 10:15:07 tom Exp $ */
d833 3
a835 2
#if OPT_I18N_SUPPORT
	if (screen->xic) {
d839 1
a839 1
		kd.nbytes = Xutf8LookupString(screen->xic, event,
d845 1
a845 1
		kd.nbytes = XmbLookupString(screen->xic, event,
d961 7
d1057 1
a1057 1
	if (modify_parm)
d1059 1
d1287 1
a1287 1
		if (ch < 128) {
@


1.12
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.326 2010/06/15 22:41:09 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2009,2010 by Thomas E. Dickey
d489 1
a489 1
	    ;
d1992 1
a1992 1
			    ;
d2002 1
a2002 1
			    ;	/* ignore */
d2006 1
a2006 1
			    ;	/* ignore */
d2009 1
a2009 1
			    ;	/* ignore */
@


1.11
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.324 2010/04/18 17:50:52 tom Exp $ */
d190 1
a190 1
		    Bell(XkbBI_MarginBell, 0);
d1228 1
a1228 1
		Bell(XkbBI_MinorError, 0);
d1341 1
a1341 1
StringInput(XtermWidget xw, Char * string, size_t nbytes)
@


1.10
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.312 2009/12/29 23:45:29 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2008,2009 by Thomas E. Dickey
d184 1
a184 1
	WindowScroll(xw, 0);
d358 1
a358 1
	    result |= ShiftMask;
d360 1
a360 1
	    result |= ControlMask;
d362 1
a362 1
	    result |= xw->misc.alt_mods;
d364 1
a364 1
	    result |= xw->misc.meta_mods;
d389 1
a389 1
	    state &= ~ShiftMask;
d393 1
a393 1
	    state &= ~ControlMask;
d397 1
a397 1
	    state &= ~xw->misc.alt_mods;
d401 1
a401 1
	    state &= ~xw->misc.meta_mods;
d486 1
a486 1
		result &= ~ControlMask;
d498 1
a498 1
		result &= ~ShiftMask;
d551 1
a551 1
	    state &= ~ControlMask;
d839 1
a839 1
					      kd.strbuf, sizeof(kd.strbuf),
d845 1
a845 1
					    kd.strbuf, sizeof(kd.strbuf),
d866 1
a866 1
	    kd.nbytes = XLookupString(event, kd.strbuf, sizeof(kd.strbuf),
d902 1
a902 1
	    evt_state &= ~ShiftMask;
d911 1
a911 1
	    evt_state &= ~ControlMask;
d1025 1
a1025 1
		evt_state &= ~ControlMask;
d1036 1
a1036 1
		evt_state &= ~ShiftMask;
d1040 1
a1040 1
		evt_state &= ~ControlMask;
d1108 1
a1108 1
	    evt_state &= ~ShiftMask;
d1243 1
a1243 1
		    evt_state &= ~xw->misc.meta_mods;
d1252 1
a1252 1
		    evt_state &= ~xw->misc.alt_mods;
d1321 1
a1321 1
		    evt_state &= ~ControlMask;
d1329 1
a1329 1
	key = True;
d1343 3
a1345 3
    TRACE(("InputString (%s,%d)\n",
	   visibleChars(string, nbytes),
	   nbytes));
d1668 82
a1749 1
#define isName(c) ((c) == '_' || isalnum(CharOf(c)))
d1756 1
a1756 1
stripTranslations(const char *s)
d1777 4
a1780 2
		    while (d != dst && isspace(CharOf(d[-1])))
			--d;
d1787 1
a1787 2
			while (d != dst && isspace(CharOf(d[-1])))
			    --d;
d1816 1
a1816 1
TranslationsUseKeyword(Widget w, char **cache, const char *keyword)
d1828 1
a1828 1
    if ((test = stripTranslations(keyword)) != 0) {
d1838 1
a1838 1
	    if (data != 0 && (copy = stripTranslations(data)) != 0) {
d1879 1
a1879 1
xtermHasTranslation(XtermWidget xw, const char *keyword)
d1883 2
a1884 1
				   keyword)
d1887 2
a1888 1
				      keyword));
d1895 7
a1901 7
    unsigned have = (xw->keyboard.extra_translations
		     ? strlen(xw->keyboard.extra_translations)
		     : 0);
    unsigned need = (((have != 0) ? (have + 4) : 0)
		     + strlen(fromString)
		     + strlen(toString)
		     + 6);
d1903 1
a1903 1
    if (!xtermHasTranslation(xw, fromString)) {
d1918 2
a1919 2
#define SaveMask(name)	xw->misc.name |= mask;\
			TRACE(("SaveMask(%s) %#lx (%#lx is%s modifier)\n", \
d1921 2
a1922 2
				xw->misc.name, mask, \
				ModifierName(mask)));
d2025 13
d2043 1
a2043 1
		&& xtermHasTranslation(xw, "alt")) {
d2053 1
a2053 1
		&& xtermHasTranslation(xw, "meta")) {
@


1.9
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.310 2009/10/12 00:12:34 tom Exp $ */
d118 1
a118 1
#define TEK4014_GIN(tw) (tw != 0 && tw->screen.TekGIN)
d181 1
a181 1
    TScreen *screen = &(xw->screen);
d187 2
a188 2
	if (screen->bellarmed >= 0) {
	    if (screen->bellarmed == screen->cur_row) {
d191 1
a191 1
		    screen->bellarmed = -1;
d193 2
a194 2
	    } else
		screen->bellarmed =
d196 1
d198 1
a198 1
	    screen->bellarmed = screen->cur_row;
d308 1
a308 1
    TScreen *screen = &(xw->screen);
d504 2
a505 2
			       xw->screen.meta_sends_esc, kd);
	if (xw->screen.alt_is_not_meta) {
d508 1
a508 1
				   xw->screen.alt_sends_esc, kd);
d780 1
a780 1
	result = (xw->screen.delete_is_del == True);
d783 1
a783 1
	result = (xw->screen.delete_is_del != False);
d787 1
a787 1
	   xw->screen.delete_is_del,
d801 1
a801 1
    TScreen *screen = &(xw->screen);
@


1.8
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.309 2009/06/18 00:08:40 tom Exp $ */
d128 8
a135 7
/*                       0123456789 abc def0123456789abcdef0123456789abcdef0123456789abcd */
static char *kypd_num = " XXXXXXXX\tXXX\rXXXxxxxXXXXXXXXXXXXXXXXXXXXX*+,-./0123456789XXX=";

/*                       0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcd */
static char *kypd_apl = " ABCDEFGHIJKLMNOPQRSTUVWXYZ??????abcdefghijklmnopqrstuvwxyzXXX";

static char *curfinal = "HDACB  FE";
d143 1
a143 1
static char *
d146 1
a146 1
    char *s = "";
d1790 2
a1791 1
    TRACE(("TranslationsUseKeyword(%p, %s) = %d\n", w, keyword, result));
d1808 1
a1808 1
addTranslation(XtermWidget xw, char *fromString, char *toString)
@


1.7
log
@Update to xterm 243. tested by naddy@@.

Patch #243 - 2009/3/28

* revert change to default for allowTcapOps (request by Bram Moolenaar).
* reallocate result returned by xtermEnvLocale() to avoid reference to
freed memory after handling menuLocale resource.
* fix an old (X11R5) bug in tek4014 for switching fontsizes.
* add resource defaultString to make configurable the use of "#" when
pastes of UTF-8 text fail due to limitations in the current locale settings.
* make the set of selection target Atom's configurable by two new
resources eightBitSelectTypes and utf8SelectTypes, e.g., to use the TEXT
Atom in preference to UTF8_STRING (discussion with Stanislav Sedov
regarding koi8rxterm and the FreeBSD port).
* modify handling of TARGETS Atom by making it return exactly the set of
targets as those which xterm is currently providing.
* set MANPAGER and PAGER explicitly to /bin/cat in minstall.sh to work
around /etc/man.conf's with those variables already set (report by
Mar'yasin Semion).
* improve error-checking of tcap-query parser.
* add check for keyboard tcap), which ensures that terminal descriptions
containing the same string for shifted/unshifted keys will be seen by
tcap-query as only the unshifted key. (This would only happen with an
incorrect terminal description).
* fix conversion for input event-state to modifier-parameter which made
tcap-query feature not work with tcapFunctionKeys (keyboard type tcap).
* add "DEF_ALLOW_XXX" definitions to main.h to allow overriding the
default compiled-in values for "allowxxx" resources.
* remove check on bell-percentage added in patch #242, which disallowed
zero/negative values (Redhat Bugzilla #487829).
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.307 2009/03/15 18:53:57 tom Exp $ */
d877 1
a877 1
	   visibleChars(PAIRED_CHARS((Char *) kd.strbuf, 0),
a1109 1
#if OPT_VT52_MODE
d1123 1
a1123 3
	}
#endif
	else {
d1342 1
a1342 1
	   visibleChars(PAIRED_CHARS(string, 0), nbytes),
@


1.6
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.304 2009/01/26 00:09:29 tom Exp $ */
a344 12
#undef CTRL

/* FIXME - make these used in xtermcap.c */
#define	UNMOD	1
#define	SHIFT	1
#define	ALT	2
#define	CTRL	4
#define	META	8

#define MODIFIER_NAME(parm, name) \
	(((parm > UNMOD) && ((parm - UNMOD) & name)) ? " "#name : "")

d350 1
a350 1
    if (param > UNMOD
d355 1
a355 1
	if ((param - UNMOD) & SHIFT)
d357 1
a357 1
	if ((param - UNMOD) & CTRL)
d359 1
a359 1
	if ((param - UNMOD) & ALT)
d361 1
a361 1
	if ((param - UNMOD) & META)
d369 4
a372 4
	   MODIFIER_NAME(param, SHIFT),
	   MODIFIER_NAME(param, ALT),
	   MODIFIER_NAME(param, CTRL),
	   MODIFIER_NAME(param, META),
d380 1
a380 1
    unsigned modify_parm = UNMOD;
d382 1
d386 1
a386 1
	    modify_parm += SHIFT;
d390 1
a390 1
	    modify_parm += CTRL;
d394 1
a394 1
	    modify_parm += ALT;
d398 1
a398 1
	    modify_parm += META;
d402 2
d409 4
a412 4
	   MODIFIER_NAME(modify_parm, SHIFT),
	   MODIFIER_NAME(modify_parm, ALT),
	   MODIFIER_NAME(modify_parm, CTRL),
	   MODIFIER_NAME(modify_parm, META)));
d566 1
a566 1
		    if (computeMaskedModifier(xw, state, ShiftMask) > 1)
d572 1
a572 1
		    result = (modify_parm > 1);
d579 1
a579 1
			    result = (modify_parm > 1);
d584 1
a584 2
			else if (computeMaskedModifier(xw, state, ControlMask)
				 > 1) {
d597 1
a597 1
		    if (computeMaskedModifier(xw, state, ControlMask) > 1)
d601 1
a601 1
		    result = (xtermStateToParam(xw, state) > 1);
d605 1
a605 1
		    if (computeMaskedModifier(xw, state, ShiftMask) > 1)
d611 1
a611 1
		    result = (modify_parm > 1);
d618 1
a618 1
		    } else if (computeMaskedModifier(xw, state, ShiftMask) > 1) {
d670 1
a670 1
    if (*modify_parm > 1) {
d756 1
a756 1
	if (modify_parm > 1) APPEND_PARM(modify_parm)
d1098 1
a1098 1
		     && ((modify_parm > 1)
d1136 1
a1136 1
		    && computeMaskedModifier(xw, evt_state, ShiftMask) > 1)
@


1.5
log
@xterm 239

correct a cast in input.c, which broke translation of numeric
keypad codes to pageup, pagedown, etc., on 64-bit platform (Debian
#511138, report by Larry Doolittle).
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.303 2009/01/08 23:28:36 tom Exp $ */
d357 1
a357 1
int
d360 1
a360 1
    int result = 0;
d389 1
a389 1
int
d392 1
a392 1
    int modify_parm = UNMOD;
d535 1
a535 1
		int modify_parm)
d645 2
a646 2
	    reply->a_param[(int) reply->a_nparam] = number, \
	    reply->a_nparam += 1
d655 1
a655 1
modifyOtherKey(ANSI * reply, int input_char, int modify_parm, int format_keys)
d678 1
a678 1
modifyCursorKey(ANSI * reply, int modify, int *modify_parm)
d761 2
a762 2
	    reply.a_param[(int) reply.a_nparam] = number, \
	    reply.a_nparam += 1
d815 1
a815 1
    int modify_parm = 0;
d1161 1
a1161 1
		reply.a_param[0] = dec_code;
d1585 1
a1585 1
    int result;
d1876 1
a1876 1
				     min_keycode,
@


1.4
log
@xterm 238. includes fix for CVE-2008-2383.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.302 2008/12/30 17:20:39 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2007,2008 by Thomas E. Dickey
d987 1
a987 1
	    kd.keysym += (unsigned) (XK_Home - XK_KP_Home);
@


1.3
log
@xterm 237. tested by krw@@ oga@@ and others.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.300 2008/09/14 16:37:25 Ted.Phelps Exp $ */
d85 1
d829 1
a829 1
	kd.keysym = screen->tc_query_code;
d866 1
a866 1
		kd.strbuf[0] = kd.keysym;
d987 1
a987 1
	    kd.keysym += XK_Home - XK_KP_Home;
d1032 1
a1032 1
		kd.keysym += xw->misc.ctrl_fkeys;
d1043 1
a1043 1
		kd.keysym += xw->misc.ctrl_fkeys * 1;
d1047 1
a1047 1
		kd.keysym += xw->misc.ctrl_fkeys * 2;
d1128 1
a1128 1
	    reply.a_final = A2E(dec_code - 11 + E2A('P'));
d1171 1
a1171 1
	reply.a_final = kd.keysym - XK_KP_F1 + 'P';
d1179 1
a1179 1
	    reply.a_final = kypd_apl[kd.keysym - XK_KP_Space];
d1194 1
a1194 1
	reply.a_final = curfinal[kd.keysym - XK_Home];
d1290 1
a1290 1
		    kd.strbuf[0] |= 0x80;
d1303 2
a1304 2
			kd.strbuf[0] = 0xc0 | ((ch >> 6) & 0x3);
			kd.strbuf[1] = 0x80 | (ch & 0x3f);
d1318 2
a1319 2
		    int cmp = xtermCharSetIn(CharOf(kd.strbuf[0]),
					     screen->keyboard_dialect[0]);
d1326 1
a1326 1
		    kd.strbuf[0] = cmp;
d1403 1
a1403 1
	    result = 42 + (kd->keysym - XK_Fn(21));
d1483 1
a1483 1
	reply->a_final = result;
d1573 1
a1573 1
	reply->a_final = result;
d1670 1
a1670 1
	reply->a_final = curfinal[kd->keysym - XK_Home];
d1682 1
a1682 1
 * Strip unneeded whitespace from a translations resource, lowercasing and
d1704 1
a1704 1
			*d++ = ch;
d1718 1
a1718 1
		    *d++ = char2lower(ch);
@


1.2
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.299 2008/04/20 20:27:18 tom Exp $ */
d1265 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 3
/* $XTermId: input.c,v 1.262 2006/08/03 00:08:35 tom Exp $ */

/* $XFree86: xc/programs/xterm/input.c,v 3.76 2006/06/19 00:36:51 dickey Exp $ */
d4 1
a4 1
 * Copyright 1999-2005,2006 by Thomas E. Dickey
d73 4
d78 1
d85 1
a106 2
#define XK_Fn(n)	(XK_F1 + (n) - 1)

d113 1
d117 2
d177 1
a177 1
AdjustAfterInput(TScreen * screen)
d179 2
d182 1
a182 1
	WindowScroll(screen, 0);
d230 1
a230 1
#define IS_CTRL(n) ((n) < 0x20 || ((n) >= 0x7f && (n) <= 0x9f))
d311 1
a311 5
    if (1
#if OPT_SUNPC_KBD || OPT_VT52
	&& !(((IsKeypadKey(kd->keysym) && keypad_mode)
	      || kd->is_fkey)
	     && (0
d313 1
a313 1
		 || (keyboard->type == keyboardIsVT220)
d316 1
a316 1
		 || (screen->vtXX_level == 0)
a317 2
	     ))
#endif /* OPT_SUNPC_KBD || OPT_VT52 */
d343 4
d352 38
a389 3
#define MODIFIER_NAME(parm, name) (((parm - UNMOD) & name) ? " "#name : "")
static short
computeModifierParm(XtermWidget xw, int state)
d391 1
a391 1
    short modify_parm = UNMOD;
d416 1
a416 1
    TRACE(("...computeModifierParm %d%s%s%s%s\n", modify_parm,
d424 39
d489 1
a489 1
	    && (result & ~ControlMask) == 0) {
d498 1
a498 1
	    if ((result & ~(ControlMask | ShiftMask)) == 0) {
d508 7
a514 27
	if ((result & xw->misc.meta_mods) != 0) {
	    /*
	     * metaSendsEscape makes the meta key independent of
	     * modifyOtherKeys.
	     */
	    if (xw->screen.meta_sends_esc) {
		result &= ~xw->misc.meta_mods;
	    }
	    /*
	     * A bare meta-modifier is independent of modifyOtherKeys.  If it
	     * is combined with other modifiers, make it depend.
	     */
	    if ((result & ~(xw->misc.meta_mods)) == 0) {
		result &= ~xw->misc.meta_mods;
	    }
	    /*
	     * Check for special cases of control+meta which are used by some
	     * applications, e.g., emacs.
	     */
	    if ((IsControlInput(kd)
		 || IsControlOutput(kd))
		&& (result & ControlMask) != 0) {
		result &= ~(xw->misc.meta_mods | ControlMask);
	    }
	    if (kd->keysym == XK_Return || kd->keysym == XK_Tab) {
		result &= ~(xw->misc.meta_mods | ControlMask);
	    }
d574 1
a574 1
		    if (computeModifierParm(xw, state & ~ShiftMask) > 1)
d592 1
a592 2
			else if (computeModifierParm(xw,
						     (state & ~ControlMask))
d606 1
a606 1
		    if (computeModifierParm(xw, state & ~ControlMask) > 1)
d610 1
a610 1
		    result = (computeModifierParm(xw, state) > 1);
d614 1
a614 1
		    if (computeModifierParm(xw, state & ~ShiftMask) > 1)
d627 1
a627 1
		    } else if (computeModifierParm(xw, state & ~ShiftMask) > 1) {
d654 1
a654 1
modifyOtherKey(ANSI * reply, int input_char, int modify_parm)
d659 11
a669 5
	reply->a_type = CSI;
	APPEND_PARM(27);
	APPEND_PARM(modify_parm);
	APPEND_PARM(input_char);
	reply->a_final = '~';
d677 1
a677 1
modifyCursorKey(ANSI * reply, int modify, int modify_parm)
d679 6
a684 3
    if (modify_parm > 1) {
	if (modify) {
	    reply->a_type = CSI;	/* SS3 should not have params */
d749 1
a749 1
		reply.a_type = ESC; \
d755 1
a755 1
		reply.a_type = ESC; \
d814 1
a814 1
    short modify_parm = 0;
d886 4
a889 1
	   visibleChars(PAIRED_CHARS((Char *) kd.strbuf, 0), kd.nbytes),
d952 1
a952 1
	modify_parm = computeModifierParm(xw, evt_state);
d972 1
a972 1
	kd.strbuf[0] = DEL;
d1057 1
a1057 1
	    modify_parm = computeModifierParm(xw, evt_state);
d1074 6
d1097 1
a1097 1
			modify_parm);
d1125 1
a1125 1
	    reply.a_type = SS3;
d1130 1
a1130 1
			    modify_parm);
d1136 1
a1136 1
	    reply.a_type = CSI;
d1145 2
a1146 2
		    && computeModifierParm(xw, evt_state & ~ShiftMask) > 1)
		    modifyOtherKey(&reply, '\t', modify_parm);
d1156 1
a1156 1
				    modify_parm);
d1169 1
a1169 1
	reply.a_type = SS3;
d1177 1
a1177 1
	    reply.a_type = SS3;
d1188 1
a1188 1
	    reply.a_type = SS3;
d1190 1
a1190 1
	    reply.a_type = CSI;
d1192 1
a1192 1
	modifyCursorKey(&reply, keyboard->modify_now.cursor_keys, modify_parm);
d1202 3
a1204 3
	if (screen->TekGIN) {
	    TekEnqMouse(kd.strbuf[0]);
	    TekGINoff();
d1219 1
a1219 1
	    modify_parm = computeModifierParm(xw, evt_state);
d1235 1
a1235 1
	    if (modifyOtherKey(&reply, input_char, modify_parm)) {
d1249 5
a1253 10
	    if (kd.nbytes != 0
		&& screen->meta_sends_esc
		&& (evt_state & xw->misc.meta_mods) != 0) {
		TRACE(("...input-char is modified by META\n"));
		/*
		 * If we cannot distinguish between the Alt/Meta keys, disallow
		 * the corresponding shift for eightBitInput that would happen
		 * in the next chunk of code.
		 */
		if ((evt_state & xw->misc.alt_mods & xw->misc.meta_mods) != 0)
d1255 16
a1270 2
		prefix = ESC;
		evt_state &= ~xw->misc.meta_mods;
d1326 1
a1326 1
		    prefix = ESC;
d1329 1
a1329 1
		    kd.strbuf[0] = DEL;
d1342 2
a1343 2
    if (key && !TEK4014_ACTIVE(screen))
	AdjustAfterInput(screen);
d1345 1
a1351 2
    TScreen *screen = &(xw->screen);

d1356 3
a1358 3
    if (nbytes && screen->TekGIN) {
	TekEnqMouse(*string++);
	TekGINoff();
d1364 2
a1365 2
    if (!TEK4014_ACTIVE(screen))
	AdjustAfterInput(screen);
d1480 1
a1480 1
	reply->a_type = ESC;
d1570 1
a1570 1
	reply->a_type = CSI;
d1582 1
a1582 1
#ifdef OPT_SUN_FUNC_KEYS
d1662 1
a1662 1
	reply->a_type = CSI;
d1667 1
a1667 1
	reply->a_type = SS3;
d1677 2
d1680 57
a1736 3
 * Note that this can only retrieve translations that are given as resource
 * values; the default translations in charproc.c for example are not
 * retrievable by any interface to X.
d1743 1
a1743 1
TranslationsUseKeyword(Widget w, const char *keyword)
d1752 17
d1770 24
a1793 31
    XtGetSubresources(w,
		      (XtPointer) &data,
		      "vt100",
		      "VT100",
		      key_resources,
		      XtNumber(key_resources),
		      NULL,
		      (Cardinal) 0);

    if (data != 0) {
	char *p = data;
	int state = 0;
	int now = ' ', prv;
	TRACE(("TranslationsUseKeyword(%p):%s\n", w, p));
	while (*p != 0) {
	    prv = now;
	    now = char2lower(*p++);
	    if (now == ':'
		|| now == '!') {
		state = -1;
	    } else if (now == '\n') {
		state = 0;
	    } else if (state >= 0) {
		if (isgraph(now)
		    && now == keyword[state]) {
		    if ((state != 0
			 || !isalnum(prv))
			&& ((keyword[++state] == 0)
			    && !isalnum(CharOf(*p)))) {
			result = True;
			break;
a1794 2
		} else {
		    state = 0;
d1798 1
d1804 38
a1857 1
    int i, j, k;
d1860 2
d1879 28
d1909 9
a1917 9
		    KeyCode code = keymap->modifiermap[k];
		    if (code != 0) {
			KeySym keysym;
			int l = 0;
			do {
			    keysym = XKeycodeToKeysym(dpy, code, l);
			    l++;
			} while (!keysym && l < keysyms_per_keycode);
			if (keysym == XK_Num_Lock) {
d1934 5
a1938 1
			} else {
a1941 1
		    k++;
d1954 1
a1954 2
		&& (TranslationsUseKeyword(toplevel, "alt")
		    || TranslationsUseKeyword((Widget) xw, "alt"))) {
d1964 1
a1964 2
		&& (TranslationsUseKeyword(toplevel, "meta")
		    || TranslationsUseKeyword((Widget) xw, "meta"))) {
a1973 207

#if OPT_TCAP_QUERY
static int
hex2int(int c)
{
    if (c >= '0' && c <= '9')
	return c - '0';
    if (c >= 'a' && c <= 'f')
	return c - 'a' + 10;
    if (c >= 'A' && c <= 'F')
	return c - 'A' + 10;
    return -1;
}

/*
 * Parse the termcap/terminfo name from the string, returning a positive number
 * (the keysym) if found, otherwise -1.  Update the string pointer.
 * Returns the (shift, control) state in *state.
 *
 * This does not attempt to construct control/shift modifiers to construct
 * function-key values.  Instead, it sets the *fkey flag to pass to Input()
 * and bypass the lookup of keysym altogether.
 */
int
xtermcapKeycode(XtermWidget xw, char **params, unsigned *state, Bool * fkey)
{
    /* *INDENT-OFF* */
#define DATA(tc,ti,x,y) { tc, ti, x, y }
    static struct {
	char *tc;
	char *ti;
	int code;
	unsigned state;
    } table[] = {
	/*	tcap	terminfo	keycode		masks */
	DATA(	"%1",	"khlp",		XK_Help,	0		),
	DATA(	"#1",	"kHLP",		XK_Help,	ShiftMask	),
	DATA(	"@@0",	"kfnd",		XK_Find,	0		),
	DATA(	"*0",	"kFND",		XK_Find,	ShiftMask	),
	DATA(	"*6",	"kslt",		XK_Select,	0		),
	DATA(	"#6",	"kSLT",		XK_Select,	ShiftMask	),

	DATA(	"kh",	"khome",	XK_Home,	0		),
	DATA(	"#2",	"kHOM",		XK_Home,	ShiftMask	),
	DATA(	"@@7",	"kend",		XK_End,		0		),
	DATA(	"*7",	"kEND",		XK_End,		ShiftMask	),

	DATA(	"kl",	"kcub1",	XK_Left,	0		),
	DATA(	"kr",	"kcuf1",	XK_Right,	0		),
	DATA(	"ku",	"kcuu1",	XK_Up,		0		),
	DATA(	"kd",	"kcud1",	XK_Down,	0		),

	DATA(	"#4",	"kLFT",		XK_Left,	ShiftMask	),
	DATA(	"%i",	"kRIT",		XK_Right,	ShiftMask	),
	DATA(	"%e",	"kPRV",		XK_Up,		ShiftMask	),
	DATA(	"%c",	"kNXT",		XK_Down,	ShiftMask	),

	DATA(	"k1",	"kf1",		XK_Fn(1),	0		),
	DATA(	"k2",	"kf2",		XK_Fn(2),	0		),
	DATA(	"k3",	"kf3",		XK_Fn(3),	0		),
	DATA(	"k4",	"kf4",		XK_Fn(4),	0		),
	DATA(	"k5",	"kf5",		XK_Fn(5),	0		),
	DATA(	"k6",	"kf6",		XK_Fn(6),	0		),
	DATA(	"k7",	"kf7",		XK_Fn(7),	0		),
	DATA(	"k8",	"kf8",		XK_Fn(8),	0		),
	DATA(	"k9",	"kf9",		XK_Fn(9),	0		),
	DATA(	"k;",	"kf10",		XK_Fn(10),	0		),

	DATA(	"F1",	"kf11",		XK_Fn(11),	0		),
	DATA(	"F2",	"kf12",		XK_Fn(12),	0		),
	DATA(	"F3",	"kf13",		XK_Fn(13),	0		),
	DATA(	"F4",	"kf14",		XK_Fn(14),	0		),
	DATA(	"F5",	"kf15",		XK_Fn(15),	0		),
	DATA(	"F6",	"kf16",		XK_Fn(16),	0		),
	DATA(	"F7",	"kf17",		XK_Fn(17),	0		),
	DATA(	"F8",	"kf18",		XK_Fn(18),	0		),
	DATA(	"F9",	"kf19",		XK_Fn(19),	0		),
	DATA(	"FA",	"kf20",		XK_Fn(20),	0		),
	DATA(	"FB",	"kf21",		XK_Fn(21),	0		),
	DATA(	"FC",	"kf22",		XK_Fn(22),	0		),
	DATA(	"FD",	"kf23",		XK_Fn(23),	0		),
	DATA(	"FE",	"kf24",		XK_Fn(24),	0		),
	DATA(	"FF",	"kf25",		XK_Fn(25),	0		),
	DATA(	"FG",	"kf26",		XK_Fn(26),	0		),
	DATA(	"FH",	"kf27",		XK_Fn(27),	0		),
	DATA(	"FI",	"kf28",		XK_Fn(28),	0		),
	DATA(	"FJ",	"kf29",		XK_Fn(29),	0		),
	DATA(	"FK",	"kf30",		XK_Fn(30),	0		),
	DATA(	"FL",	"kf31",		XK_Fn(31),	0		),
	DATA(	"FM",	"kf32",		XK_Fn(32),	0		),
	DATA(	"FN",	"kf33",		XK_Fn(33),	0		),
	DATA(	"FO",	"kf34",		XK_Fn(34),	0		),
	DATA(	"FP",	"kf35",		XK_Fn(35),	0		),

	DATA(	"FQ",	"kf36",		-36,		0		),
	DATA(	"FR",	"kf37",		-37,		0		),
	DATA(	"FS",	"kf38",		-38,		0		),
	DATA(	"FT",	"kf39",		-39,		0		),
	DATA(	"FU",	"kf40",		-40,		0		),
	DATA(	"FV",	"kf41",		-41,		0		),
	DATA(	"FW",	"kf42",		-42,		0		),
	DATA(	"FX",	"kf43",		-43,		0		),
	DATA(	"FY",	"kf44",		-44,		0		),
	DATA(	"FZ",	"kf45",		-45,		0		),
	DATA(	"Fa",	"kf46",		-46,		0		),
	DATA(	"Fb",	"kf47",		-47,		0		),
	DATA(	"Fc",	"kf48",		-48,		0		),
	DATA(	"Fd",	"kf49",		-49,		0		),
	DATA(	"Fe",	"kf50",		-50,		0		),
	DATA(	"Ff",	"kf51",		-51,		0		),
	DATA(	"Fg",	"kf52",		-52,		0		),
	DATA(	"Fh",	"kf53",		-53,		0		),
	DATA(	"Fi",	"kf54",		-54,		0		),
	DATA(	"Fj",	"kf55",		-55,		0		),
	DATA(	"Fk",	"kf56",		-56,		0		),
	DATA(	"Fl",	"kf57",		-57,		0		),
	DATA(	"Fm",	"kf58",		-58,		0		),
	DATA(	"Fn",	"kf59",		-59,		0		),
	DATA(	"Fo",	"kf60",		-60,		0		),
	DATA(	"Fp",	"kf61",		-61,		0		),
	DATA(	"Fq",	"kf62",		-62,		0		),
	DATA(	"Fr",	"kf63",		-63,		0		),

	DATA(	"K1",	"ka1",		XK_KP_Home,	0		),
	DATA(	"K4",	"kc1",		XK_KP_End,	0		),

#ifdef XK_ISO_Left_Tab
	DATA(	"kB",	"kcbt",		XK_ISO_Left_Tab, 0		),
#endif
	DATA(	"kC",	"kclr",		XK_Clear,	0		),
	DATA(	"kD",	"kdch1",	XK_Delete,	0		),
	DATA(	"kI",	"kich1",	XK_Insert,	0		),
	DATA(	"kN",	"knp",		XK_Next,	0		),
	DATA(	"kP",	"kpp",		XK_Prior,	0		),
	DATA(	"kb",	"kbs",		XK_BackSpace,	0		),
# if OPT_ISO_COLORS
	/* XK_COLORS is a fake code. */
	DATA(	"Co",	"colors",	XK_COLORS,	0		),
# endif
    };
    /* *INDENT-ON* */

    Cardinal n;
    unsigned len = 0;
    int code = -1;
#define MAX_TNAME_LEN 6
    char name[MAX_TNAME_LEN + 1];
    char *p;

    TRACE(("xtermcapKeycode(%s)\n", *params));

    /* Convert hex encoded name to ascii */
    for (p = *params; hex2int(p[0]) >= 0 && hex2int(p[1]) >= 0; p += 2) {
	if (len >= MAX_TNAME_LEN)
	    break;
	name[len++] = (hex2int(p[0]) << 4) + hex2int(p[1]);
    }
    name[len] = 0;
    *params = p;

    *state = 0;
    *fkey = False;

    if (*p == 0 || *p == ';') {
	for (n = 0; n < XtNumber(table); n++) {
	    if (!strcmp(table[n].ti, name) || !strcmp(table[n].tc, name)) {
		code = table[n].code;
		*state = table[n].state;
		if (IsFunctionKey(code)) {
		    *fkey = True;
		} else if (code < 0) {
		    *fkey = True;
		    code = XK_Fn((-code));
		}
#ifdef OPT_SUN_FUNC_KEYS
		if (*fkey && xw->keyboard.type == keyboardIsSun) {
		    int num = code - XK_Fn(0);

		    /* match function-key case in sunfuncvalue() */
		    if (num > 20) {
			if (num <= 30 || num > 47) {
			    code = -1;
			} else {
			    code -= 10;
			    switch (num) {
			    case 37:	/* khome */
			    case 39:	/* kpp */
			    case 41:	/* kb2 */
			    case 43:	/* kend */
			    case 45:	/* knp */
				code = -1;
				break;
			    }
			}
		    }
		}
#endif
		break;
	    }
	}
    }

    TRACE(("... xtermcapKeycode(%s, %u, %d) -> %#06x\n",
	   name, *state, *fkey, code));
    return code;
}
#endif
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.283 2007/03/19 23:58:54 tom Exp $ */
d6 1
a6 1
 * Copyright 1999-2006,2007 by Thomas E. Dickey
a81 1
#include <xtermcap.h>
d103 2
a113 2
#define TEK4014_GIN(tw) (tw != 0 && tw->screen.TekGIN)

d172 1
a172 1
AdjustAfterInput(XtermWidget xw)
a173 2
    TScreen *screen = &(xw->screen);

d175 1
a175 1
	WindowScroll(xw, 0);
d223 1
a223 1
#define IS_CTRL(n) ((n) < ANSI_SPA || ((n) >= 0x7f && (n) <= 0x9f))
d304 5
a308 1
    if (!(IsKeypadKey(kd->keysym) && keypad_mode)
d310 1
a310 1
	&& keyboard->type != keyboardIsVT220
d313 1
a313 1
	&& screen->vtXX_level != 0
d315 2
a341 3

#undef CTRL

a346 1

a347 1

a383 36
#if OPT_NUM_LOCK
static unsigned
filterAltMeta(unsigned result, unsigned mask, Boolean enable, KEY_DATA * kd)
{
    if ((result & mask) != 0) {
	/*
	 * metaSendsEscape makes the meta key independent of
	 * modifyOtherKeys.
	 */
	if (enable) {
	    result &= ~mask;
	}
	/*
	 * A bare meta-modifier is independent of modifyOtherKeys.  If it
	 * is combined with other modifiers, make it depend.
	 */
	if ((result & ~(mask)) == 0) {
	    result &= ~mask;
	}
	/*
	 * Check for special cases of control+meta which are used by some
	 * applications, e.g., emacs.
	 */
	if ((IsControlInput(kd)
	     || IsControlOutput(kd))
	    && (result & ControlMask) != 0) {
	    result &= ~(mask | ControlMask);
	}
	if (kd->keysym == XK_Return || kd->keysym == XK_Tab) {
	    result &= ~(mask | ControlMask);
	}
    }
    return result;
}
#endif /* OPT_NUM_LOCK */

d429 27
a455 7
	result = filterAltMeta(result,
			       xw->misc.meta_mods,
			       xw->screen.meta_sends_esc, kd);
	if (xw->screen.alt_is_not_meta) {
	    result = filterAltMeta(result,
				   xw->misc.alt_mods,
				   xw->screen.alt_sends_esc, kd);
d601 1
a601 1
	reply->a_type = ANSI_CSI;
d613 1
a613 1
modifyCursorKey(ANSI * reply, int modify, int *modify_parm)
d615 3
a617 6
    if (*modify_parm > 1) {
	if (modify < 0) {
	    *modify_parm = 0;
	}
	if (modify > 0) {
	    reply->a_type = ANSI_CSI;	/* SS3 should not have params */
d682 1
a682 1
		reply.a_type = ANSI_ESC; \
d688 1
a688 1
		reply.a_type = ANSI_ESC; \
d747 1
a747 1
    int modify_parm = 0;
d902 1
a902 1
	kd.strbuf[0] = ANSI_DEL;
a1003 6
    case keyboardIsTermcap:
#if OPT_TCAP_FKEYS
	if (xtermcapString(xw, kd.keysym, evt_state))
	    return;
#endif
	break;
d1021 1
a1021 1
			&modify_parm);
d1049 1
a1049 1
	    reply.a_type = ANSI_SS3;
d1054 1
a1054 1
			    &modify_parm);
d1060 1
a1060 1
	    reply.a_type = ANSI_CSI;
d1080 1
a1080 1
				    &modify_parm);
d1093 1
a1093 1
	reply.a_type = ANSI_SS3;
d1101 1
a1101 1
	    reply.a_type = ANSI_SS3;
d1112 1
a1112 1
	    reply.a_type = ANSI_SS3;
d1114 1
a1114 1
	    reply.a_type = ANSI_CSI;
d1116 1
a1116 1
	modifyCursorKey(&reply, keyboard->modify_now.cursor_keys, &modify_parm);
d1126 3
a1128 3
	if (TEK4014_GIN(tekWidget)) {
	    TekEnqMouse(tekWidget, kd.strbuf[0]);
	    TekGINoff(tekWidget);
d1173 10
a1182 5
	    if (kd.nbytes != 0) {
		if (screen->meta_sends_esc
		    && (evt_state & xw->misc.meta_mods) != 0) {
		    TRACE(("...input-char is modified by META\n"));
		    evt_state &= ~xw->misc.meta_mods;
d1184 2
a1185 16
		    prefix = ANSI_ESC;
		} else if (eightbit) {
		    /* it might be overridden, but this helps for debugging */
		    TRACE(("...input-char is shifted by META\n"));
		}
		if (screen->alt_is_not_meta
		    && (evt_state & xw->misc.alt_mods) != 0) {
		    evt_state &= ~xw->misc.alt_mods;
		    if (screen->alt_sends_esc) {
			TRACE(("...input-char is modified by ALT\n"));
			prefix = ANSI_ESC;
		    } else if (!eightbit) {
			TRACE(("...input-char is shifted by ALT\n"));
			eightbit = True;
		    }
		}
d1241 1
a1241 1
		    prefix = ANSI_ESC;
d1244 1
a1244 1
		    kd.strbuf[0] = ANSI_DEL;
d1257 2
a1258 2
    if (key && !TEK4014_ACTIVE(xw))
	AdjustAfterInput(xw);
d1266 2
d1272 3
a1274 3
    if (nbytes && TEK4014_GIN(tekWidget)) {
	TekEnqMouse(tekWidget, *string++);
	TekGINoff(tekWidget);
d1280 2
a1281 2
    if (!TEK4014_ACTIVE(xw))
	AdjustAfterInput(xw);
d1396 1
a1396 1
	reply->a_type = ANSI_ESC;
d1486 1
a1486 1
	reply->a_type = ANSI_CSI;
d1498 1
a1498 1
#if OPT_SUN_FUNC_KEYS
d1578 1
a1578 1
	reply->a_type = ANSI_CSI;
d1583 1
a1583 1
	reply->a_type = ANSI_SS3;
d1718 1
a1718 5
			} else if (keysym == XK_Mode_switch
#ifdef XK_ISO_Level3_Shift
				   || keysym == XK_ISO_Level3_Shift
#endif
			    ) {
d1757 207
@


1.1.1.3
log
@import xterm 229
@
text
@d1 3
a3 1
/* $XTermId: input.c,v 1.291 2007/07/22 20:34:04 tom Exp $ */
a74 4
#if HAVE_X11_XF86KEYSYM_H
#include <X11/XF86keysym.h>
#endif

a109 1
#define Masked(value,mask) ((value) & (unsigned) (~(mask)))
d351 1
a351 1
computeModifierParm(XtermWidget xw, unsigned state)
a385 3
#define computeMaskedModifier(xw, state, mask) \
	computeModifierParm(xw, Masked(state, mask))

d388 1
a388 1
filterAltMeta(unsigned result, unsigned mask, Bool enable, KEY_DATA * kd)
d448 1
a448 1
	    && Masked(result, ControlMask) == 0) {
d457 1
a457 1
	    if (Masked(result, (ControlMask | ShiftMask)) == 0) {
d533 1
a533 1
		    if (computeMaskedModifier(xw, state, ShiftMask) > 1)
d551 2
a552 1
			else if (computeMaskedModifier(xw, state, ControlMask)
d566 1
a566 1
		    if (computeMaskedModifier(xw, state, ControlMask) > 1)
d574 1
a574 1
		    if (computeMaskedModifier(xw, state, ShiftMask) > 1)
d587 1
a587 1
		    } else if (computeMaskedModifier(xw, state, ShiftMask) > 1) {
d840 1
a840 4
	   visibleChars(PAIRED_CHARS((Char *) kd.strbuf, 0),
			((kd.nbytes > 0)
			 ? (unsigned) kd.nbytes
			 : 0)),
d1027 1
a1027 1
	if (xtermcapString(xw, (int) kd.keysym, evt_state))
d1096 1
a1096 1
		    && computeMaskedModifier(xw, evt_state, ShiftMask) > 1)
a1626 2
#define isName(c) ((c) == '_' || isalnum(CharOf(c)))

d1628 3
a1630 57
 * Strip unneeded whitespace from a translations resource, lowercasing and
 * returning a malloc'd copy of the result.
 */
static char *
stripTranslations(const char *s)
{
    char *dst = 0;

    if (s != 0) {
	dst = malloc(strlen(s) + 1);

	if (dst != 0) {
	    int state = 0;
	    int ch = 0;
	    int prv = 0;
	    char *d = dst;

	    TRACE(("stripping:\n%s\n", s));
	    while (*s != '\0') {
		ch = *s++;
		if (ch == '\n') {
		    if (d != dst)
			*d++ = ch;
		    state = 0;
		} else if (strchr(":!#", ch) != 0) {
		    while (d != dst && isspace(CharOf(d[-1])))
			--d;
		    state = -1;
		} else if (state >= 0) {
		    if (isspace(CharOf(ch))) {
			if (state == 0 || strchr("<>~ \t", prv))
			    continue;
		    } else if (strchr("<>~", ch)) {
			while (d != dst && isspace(CharOf(d[-1])))
			    --d;
		    }
		    *d++ = char2lower(ch);
		    ++state;
		}
		prv = ch;
	    }
	    *d = '\0';
	    TRACE(("...result:\n%s\n", dst));
	}
    }
    return dst;
}

/*
 * Make a simple check to see if a given translations keyword appears in
 * xterm's translations resource.  It does not attempt to parse the strings,
 * just makes a case-independent check and ensures that the ends of the match
 * are on token-boundaries.
 *
 * That this can only retrieve translations that are given as resource values;
 * the default translations in charproc.c for example are not retrievable by
 * any interface to X.
d1637 1
a1637 1
TranslationsUseKeyword(Widget w, char **cache, const char *keyword)
a1645 2
    char *copy;
    char *test;
d1647 33
a1679 27
    if ((test = stripTranslations(keyword)) != 0) {
	if (*cache == 0) {
	    XtGetSubresources(w,
			      (XtPointer) &data,
			      "vt100",
			      "VT100",
			      key_resources,
			      XtNumber(key_resources),
			      NULL,
			      (Cardinal) 0);
	    if (data != 0 && (copy = stripTranslations(data)) != 0) {
		*cache = copy;
	    }
	}

	if (*cache != 0) {
	    char *p = *cache;
	    int state = 0;
	    int now = ' ', prv;

	    while (*p != 0) {
		prv = now;
		now = *p++;
		if (now == ':'
		    || now == '!') {
		    state = -1;
		} else if (now == '\n') {
a1680 12
		} else if (state >= 0) {
		    if (now == test[state]) {
			if ((state != 0
			     || !isName(prv))
			    && ((test[++state] == 0)
				&& !isName(*p))) {
			    result = True;
			    break;
			}
		    } else {
			state = 0;
		    }
a1683 1
	free(test);
a1688 37
static Bool
xtermHasTranslation(XtermWidget xw, const char *keyword)
{
    return (TranslationsUseKeyword(SHELL_OF(xw),
				   &(xw->keyboard.shell_translations),
				   keyword)
	    || TranslationsUseKeyword((Widget) xw,
				      &(xw->keyboard.xterm_translations),
				      keyword));
}

#if OPT_EXTRA_PASTE
static void
addTranslation(XtermWidget xw, char *fromString, char *toString)
{
    unsigned have = (xw->keyboard.extra_translations
		     ? strlen(xw->keyboard.extra_translations)
		     : 0);
    unsigned need = (((have != 0) ? (have + 4) : 0)
		     + strlen(fromString)
		     + strlen(toString)
		     + 6);

    if (!xtermHasTranslation(xw, fromString)) {
	if ((xw->keyboard.extra_translations
	     = realloc(xw->keyboard.extra_translations, need)) != 0) {
	    TRACE(("adding %s: %s\n", fromString, toString));
	    if (have)
		strcat(xw->keyboard.extra_translations, " \\n\\");
	    sprintf(xw->keyboard.extra_translations, "%s: %s",
		    fromString, toString);
	    TRACE(("...{%s}\n", xw->keyboard.extra_translations));
	}
    }
}
#endif

d1705 1
a1707 2
    int i, j, k, l;
    KeySym keysym;
a1724 28

#if OPT_EXTRA_PASTE
	    /*
	     * Assume that if we can find the paste keysym in the X keyboard
	     * mapping that the server allows the corresponding translations
	     * resource.
	     */
	    int limit = (max_keycode - min_keycode) * keysyms_per_keycode;
	    for (i = 0; i < limit; ++i) {
#ifdef XF86XK_Paste
		if (theMap[i] == XF86XK_Paste) {
		    TRACE(("keyboard has XF86XK_Paste\n"));
		    addTranslation(xw,
				   "<KeyPress> XF86Paste",
				   "insert-selection(SELECT, CUT_BUFFER0)");
		}
#endif
#ifdef SunXK_Paste
		if (theMap[i] == SunXK_Paste) {
		    TRACE(("keyboard has SunXK_Paste\n"));
		    addTranslation(xw,
				   "<KeyPress> SunPaste",
				   "insert-selection(SELECT, CUT_BUFFER0)");
		}
#endif
	    }
#endif /* OPT_EXTRA_PASTE */

d1727 9
a1735 9
		    KeyCode code = keymap->modifiermap[k++];
		    if (code == 0)
			continue;

		    for (l = 0; l < keysyms_per_keycode; ++l) {
			keysym = XKeycodeToKeysym(dpy, code, l);
			if (keysym == NoSymbol) {
			    ;
			} else if (keysym == XK_Num_Lock) {
d1760 1
d1773 2
a1774 1
		&& xtermHasTranslation(xw, "alt")) {
d1784 2
a1785 1
		&& xtermHasTranslation(xw, "meta")) {
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 1
a1 1
/* $XTermId: input.c,v 1.296 2007/12/31 21:11:19 tom Exp $ */
a344 1
/* FIXME - make these used in xtermcap.c */
d351 1
a351 2
#define MODIFIER_NAME(parm, name) \
	(((parm > UNMOD) && ((parm - UNMOD) & name)) ? " "#name : "")
d353 2
a354 2
int
xtermParamToState(XtermWidget xw, unsigned param)
d356 1
a356 33
    int result = 0;
#if OPT_NUM_LOCK
    if (param > UNMOD
	&& ((ShiftMask
	     | ControlMask
	     | xw->misc.alt_mods
	     | xw->misc.meta_mods) & xw->misc.other_mods) == 0) {
	if ((param - UNMOD) & SHIFT)
	    result |= ShiftMask;
	if ((param - UNMOD) & CTRL)
	    result |= ControlMask;
	if ((param - UNMOD) & ALT)
	    result |= xw->misc.alt_mods;
	if ((param - UNMOD) & META)
	    result |= xw->misc.meta_mods;
    }
#else
    (void) xw;
    (void) param;
#endif
    TRACE(("xtermParamToState(%d) %s%s%s%s -> %#x\n", param,
	   MODIFIER_NAME(param, SHIFT),
	   MODIFIER_NAME(param, ALT),
	   MODIFIER_NAME(param, CTRL),
	   MODIFIER_NAME(param, META),
	   result));
    return result;
}

int
xtermStateToParam(XtermWidget xw, unsigned state)
{
    int modify_parm = UNMOD;
d381 1
a381 1
    TRACE(("...xtermStateToParam %d%s%s%s%s\n", modify_parm,
d390 1
a390 1
	xtermStateToParam(xw, Masked(state, mask))
d575 1
a575 1
		    result = (xtermStateToParam(xw, state) > 1);
d911 1
a911 1
	modify_parm = xtermStateToParam(xw, evt_state);
d1016 1
a1016 1
	    modify_parm = xtermStateToParam(xw, evt_state);
d1178 1
a1178 1
	    modify_parm = xtermStateToParam(xw, evt_state);
a1303 1
    xtermShowPointer(xw, False);
d1647 1
a1647 1
	dst = TypeMallocN(char, strlen(s) + 1);
d1786 2
a1787 3
	xw->keyboard.extra_translations
	    = TypeRealloc(char, need, xw->keyboard.extra_translations);
	if ((xw->keyboard.extra_translations) != 0) {
@


