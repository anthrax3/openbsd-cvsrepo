head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.2
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.10.0.2
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.12
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.10
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.6
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.1.1.2.0.4
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.2
	v232:1.1.1.2
	v229:1.1.1.2
	OPENBSD_4_2:1.1.1.1.0.2
	OPENBSD_4_2_BASE:1.1.1.1
	v225:1.1.1.1
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2017.07.15.19.20.51;	author matthieu;	state Exp;
branches;
next	1.10;
commitid	b9xPQ49d1NNt4zlu;

1.10
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.9;
commitid	psxxjI5z4Vpv2LL4;

1.9
date	2014.01.02.15.14.50;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2012.06.07.20.20.23;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.06.20.10.20;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.31;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.31;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.08.25.18.53.52;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update to xterm 330
@
text
@/* $XTermId: cursor.c,v 1.71 2017/05/06 00:58:27 tom Exp $ */

/*
 * Copyright 2002-2016,2017 by Thomas E. Dickey
 * 
 *                         All Rights Reserved
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 * 
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/* cursor.c */

#include <xterm.h>
#include <data.h>
#include <menu.h>

#include <assert.h>

/*
 * Moves the cursor to the specified position, checking for bounds.
 * (this includes scrolling regions)
 * The origin is considered to be 0, 0 for this procedure.
 */
void
CursorSet(TScreen *screen, int row, int col, unsigned flags)
{
    int use_row = row;
    int use_col = col;
    int max_col = screen->max_col;
    int max_row = screen->max_row;

    if (flags & ORIGIN) {
	use_col += screen->lft_marg;
	max_col = screen->rgt_marg;
    }
    use_col = (use_col < 0 ? 0 : use_col);
    set_cur_col(screen, (use_col <= max_col ? use_col : max_col));

    if (flags & ORIGIN) {
	use_row += screen->top_marg;
	max_row = screen->bot_marg;
    }
    use_row = (use_row < 0 ? 0 : use_row);
    set_cur_row(screen, (use_row <= max_row ? use_row : max_row));

    ResetWrap(screen);

    TRACE(("CursorSet(%d,%d) margins V[%d..%d] H[%d..%d] -> %d,%d %s\n",
	   row, col,
	   screen->top_marg,
	   screen->bot_marg,
	   screen->lft_marg,
	   screen->rgt_marg,
	   screen->cur_row,
	   screen->cur_col,
	   ((flags & ORIGIN) ? "origin" : "normal")));
}

/*
 * moves the cursor left n, no wrap around
 */
void
CursorBack(XtermWidget xw, int n)
{
#define WRAP_MASK (REVERSEWRAP | WRAPAROUND)
    TScreen *screen = TScreenOf(xw);
    int rev;
    int left = ScrnLeftMargin(xw);
    int before = screen->cur_col;

    if ((rev = ((xw->flags & WRAP_MASK) == WRAP_MASK)) != 0
	&& screen->do_wrap) {
	n--;
    }

    /* if the cursor is already before the left-margin, we have to let it go */
    if (before < left)
	left = 0;

    if ((screen->cur_col -= n) < left) {
	if (rev) {
	    int in_row = ScrnRightMargin(xw) - left + 1;
	    int offset = (in_row * screen->cur_row) + screen->cur_col - left;
	    if (offset < 0) {
		int length = in_row * MaxRows(screen);
		offset += ((-offset) / length + 1) * length;
	    }
	    set_cur_row(screen, (offset / in_row));
	    set_cur_col(screen, (offset % in_row) + left);
	    do_xevents();
	} else {
	    set_cur_col(screen, left);
	}
    }
    ResetWrap(screen);
}

/*
 * moves the cursor forward n, no wraparound
 */
void
CursorForward(XtermWidget xw, int n)
{
    TScreen *screen = TScreenOf(xw);
#if OPT_DEC_CHRSET
    LineData *ld = getLineData(screen, screen->cur_row);
#endif
    int next = screen->cur_col + n;
    int max;

    if (IsLeftRightMode(xw)) {
	max = screen->rgt_marg;
	if (screen->cur_col > max)
	    max = screen->max_col;
    } else {
	max = LineMaxCol(screen, ld);
    }

    if (next > max)
	next = max;

    set_cur_col(screen, next);
    ResetWrap(screen);
}

/*
 * moves the cursor down n, no scrolling.
 * Won't pass bottom margin or bottom of screen.
 */
void
CursorDown(TScreen *screen, int n)
{
    int max;
    int next = screen->cur_row + n;

    max = (screen->cur_row > screen->bot_marg ?
	   screen->max_row : screen->bot_marg);
    if (next > max)
	next = max;
    if (next > screen->max_row)
	next = screen->max_row;

    set_cur_row(screen, next);
    ResetWrap(screen);
}

/*
 * moves the cursor up n, no linestarving.
 * Won't pass top margin or top of screen.
 */
void
CursorUp(TScreen *screen, int n)
{
    int min;
    int next = screen->cur_row - n;

    min = ((screen->cur_row < screen->top_marg)
	   ? 0
	   : screen->top_marg);
    if (next < min)
	next = min;
    if (next < 0)
	next = 0;

    set_cur_row(screen, next);
    ResetWrap(screen);
}

/*
 * Moves cursor down amount lines, scrolls if necessary.
 * Won't leave scrolling region. No carriage return.
 */
void
xtermIndex(XtermWidget xw, int amount)
{
    TScreen *screen = TScreenOf(xw);

    /*
     * indexing when below scrolling region is cursor down.
     * if cursor high enough, no scrolling necessary.
     */
    if (screen->cur_row > screen->bot_marg
	|| screen->cur_row + amount <= screen->bot_marg
	|| (IsLeftRightMode(xw)
	    && !ScrnIsColInMargins(screen, screen->cur_col))) {
	CursorDown(screen, amount);
    } else {
	int j;
	CursorDown(screen, j = screen->bot_marg - screen->cur_row);
	xtermScroll(xw, amount - j);
    }
}

/*
 * Moves cursor up amount lines, reverse scrolls if necessary.
 * Won't leave scrolling region. No carriage return.
 */
void
RevIndex(XtermWidget xw, int amount)
{
    TScreen *screen = TScreenOf(xw);

    /*
     * reverse indexing when above scrolling region is cursor up.
     * if cursor low enough, no reverse indexing needed
     */
    if (screen->cur_row < screen->top_marg
	|| screen->cur_row - amount >= screen->top_marg
	|| (IsLeftRightMode(xw)
	    && !ScrnIsColInMargins(screen, screen->cur_col))) {
	CursorUp(screen, amount);
    } else {
	RevScroll(xw, amount - (screen->cur_row - screen->top_marg));
	CursorUp(screen, screen->cur_row - screen->top_marg);
    }
}

/*
 * Moves Cursor To First Column In Line
 * (Note: xterm doesn't implement SLH, SLL which would affect use of this)
 */
void
CarriageReturn(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int left = ScrnLeftMargin(xw);
    int col;

    if (xw->flags & ORIGIN) {
	col = left;
    } else if (screen->cur_col >= left) {
	col = left;
    } else {
	/*
	 * If origin-mode is not active, it is possible to use cursor
	 * addressing outside the margins.  In that case we will go to the
	 * first column rather than following the margin.
	 */
	col = 0;
    }

    set_cur_col(screen, col);
    ResetWrap(screen);
    do_xevents();
}

/*
 * When resizing the window, if we're showing the alternate screen, we still
 * have to adjust the saved cursor from the normal screen to account for
 * shifting of the saved-line region in/out of the viewable window.
 */
void
AdjustSavedCursor(XtermWidget xw, int adjust)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->whichBuf) {
	SavedCursor *sc = &screen->sc[0];

	if (adjust > 0) {
	    TRACE(("AdjustSavedCursor %d -> %d\n", sc->row, sc->row - adjust));
	    sc->row += adjust;
	}
    }
}

/*
 * Save Cursor and Attributes
 */
void
CursorSave(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    SavedCursor *sc = &screen->sc[screen->whichBuf];

    sc->saved = True;
    sc->row = screen->cur_row;
    sc->col = screen->cur_col;
    sc->flags = xw->flags;
    sc->curgl = screen->curgl;
    sc->curgr = screen->curgr;
    sc->wrap_flag = screen->do_wrap;
#if OPT_ISO_COLORS
    sc->cur_foreground = xw->cur_foreground;
    sc->cur_background = xw->cur_background;
    sc->sgr_foreground = xw->sgr_foreground;
#endif
    memmove(sc->gsets, screen->gsets, sizeof(screen->gsets));
}

/*
 * We save/restore all visible attributes, plus wrapping, origin mode, and the
 * selective erase attribute.
 */
#define DECSC_FLAGS (ATTRIBUTES|ORIGIN|PROTECTED)

/*
 * Restore Cursor and Attributes
 */
void
CursorRestore(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    SavedCursor *sc = &screen->sc[screen->whichBuf];

    /* Restore the character sets, unless we never did a save-cursor op.
     * In that case, we'll reset the character sets.
     */
    if (sc->saved) {
	memmove(screen->gsets, sc->gsets, sizeof(screen->gsets));
	screen->curgl = sc->curgl;
	screen->curgr = sc->curgr;
    } else {
	resetCharsets(screen);
    }

    UIntClr(xw->flags, DECSC_FLAGS);
    UIntSet(xw->flags, sc->flags & DECSC_FLAGS);
    CursorSet(screen,
	      ((xw->flags & ORIGIN)
	       ? sc->row - screen->top_marg
	       : sc->row),
	      sc->col, xw->flags);
    screen->do_wrap = sc->wrap_flag;	/* after CursorSet/ResetWrap */

#if OPT_ISO_COLORS
    xw->sgr_foreground = sc->sgr_foreground;
    SGR_Foreground(xw, (xw->flags & FG_COLOR) ? sc->cur_foreground : -1);
    SGR_Background(xw, (xw->flags & BG_COLOR) ? sc->cur_background : -1);
#endif
}

/*
 * Move the cursor to the first column of the n-th next line.
 */
void
CursorNextLine(XtermWidget xw, int count)
{
    TScreen *screen = TScreenOf(xw);

    CursorDown(screen, count < 1 ? 1 : count);
    CarriageReturn(xw);
    do_xevents();
}

/*
 * Move the cursor to the first column of the n-th previous line.
 */
void
CursorPrevLine(XtermWidget xw, int count)
{
    TScreen *screen = TScreenOf(xw);

    CursorUp(screen, count < 1 ? 1 : count);
    CarriageReturn(xw);
    do_xevents();
}

/*
 * Return col/row values which can be passed to CursorSet() preserving the
 * current col/row, e.g., accounting for DECOM.
 */
int
CursorCol(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int result = screen->cur_col;
    if (xw->flags & ORIGIN) {
	result -= ScrnLeftMargin(xw);
	if (result < 0)
	    result = 0;
    }
    return result;
}

int
CursorRow(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int result = screen->cur_row;
    if (xw->flags & ORIGIN) {
	result -= screen->top_marg;
	if (result < 0)
	    result = 0;
    }
    return result;
}

#if OPT_TRACE
int
set_cur_row(TScreen *screen, int value)
{
    TRACE(("set_cur_row %d vs %d\n", value, screen ? screen->max_row : -1));

    assert(screen != 0);
    assert(value >= 0);
    assert(value <= screen->max_row);
    screen->cur_row = value;
    return value;
}

int
set_cur_col(TScreen *screen, int value)
{
    TRACE(("set_cur_col %d vs %d\n", value, screen ? screen->max_col : -1));

    assert(screen != 0);
    assert(value >= 0);
    assert(value <= screen->max_col);
    screen->cur_col = value;
    return value;
}
#endif /* OPT_TRACE */
@


1.10
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.70 2016/05/15 18:35:39 tom Exp $ */
d4 1
a4 1
 * Copyright 2002-2013,2016 by Thomas E. Dickey
d325 1
d338 1
a338 1
#define DECSC_FLAGS (ATTRIBUTES|ORIGIN|WRAPAROUND|PROTECTED)
d367 1
a373 1
    update_autowrap();
@


1.9
log
@Update to xterm-300. Tested  by ajacoutot@@ and shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.69 2013/08/08 08:16:40 tom Exp $ */
d4 1
a4 1
 * Copyright 2002-2012,2013 by Thomas E. Dickey
d68 1
a68 1
CursorSet(TScreen * screen, int row, int col, unsigned flags)
d99 1
a99 1
	   (flags & ORIGIN ? "origin" : "normal")));
d110 1
a110 1
    int offset, in_row, length, rev;
d114 1
a114 1
    if ((rev = (xw->flags & WRAP_MASK) == WRAP_MASK) != 0
d125 2
a126 2
	    in_row = ScrnRightMargin(xw) - left + 1;
	    offset = (in_row * screen->cur_row) + screen->cur_col - left;
d128 1
a128 1
		length = in_row * MaxRows(screen);
d174 1
a174 1
CursorDown(TScreen * screen, int n)
d195 1
a195 1
CursorUp(TScreen * screen, int n)
a219 1
    int j;
d231 1
d369 2
a370 2
    SGR_Foreground(xw, xw->flags & FG_COLOR ? sc->cur_foreground : -1);
    SGR_Background(xw, xw->flags & BG_COLOR ? sc->cur_background : -1);
d433 1
a433 1
set_cur_row(TScreen * screen, int value)
d445 1
a445 1
set_cur_col(TScreen * screen, int value)
@


1.8
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.67 2012/06/03 19:57:47 tom Exp $ */
d4 1
a4 1
 * Copyright 2002-2010,2012 by Thomas E. Dickey
d274 1
a274 1
    } else if (screen->cur_col > left) {
@


1.7
log
@Update to xterm 279. Tested by krw@@, mpi@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.66 2012/05/02 13:36:51 tom Exp $ */
d89 1
a89 1
    screen->do_wrap = False;
d138 1
a138 1
    screen->do_wrap = False;
d166 1
a166 1
    screen->do_wrap = False;
d187 1
a187 1
    screen->do_wrap = False;
d209 1
a209 1
    screen->do_wrap = False;
d286 1
a286 1
    screen->do_wrap = False;
@


1.6
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.55 2010/04/17 17:12:01 tom Exp $ */
d4 1
a4 1
 * Copyright 2002-2009,2010 by Thomas E. Dickey
d71 10
a80 1
    int max_row;
a81 3
    col = (col < 0 ? 0 : col);
    set_cur_col(screen, (col <= screen->max_col ? col : screen->max_col));
    max_row = screen->max_row;
d88 1
d91 1
a91 1
    TRACE(("CursorSet(%d,%d) margins [%d..%d] -> %d,%d %s\n",
d95 2
d108 1
d110 3
a112 1
    int i, j, k, rev;
d114 2
a115 3
    if ((rev = (xw->flags & (REVERSEWRAP | WRAPAROUND)) ==
	 (REVERSEWRAP | WRAPAROUND)) != 0
	&& screen->do_wrap)
d117 7
a123 1
    if ((screen->cur_col -= n) < 0) {
d125 5
a129 4
	    if ((i = ((j = MaxCols(screen))
		      * screen->cur_row) + screen->cur_col) < 0) {
		k = j * MaxRows(screen);
		i += ((-i) / k + 1) * k;
d131 2
a132 2
	    set_cur_row(screen, i / j);
	    set_cur_col(screen, i % j);
d135 1
a135 1
	    set_cur_col(screen, 0);
d145 1
a145 1
CursorForward(TScreen * screen, int n)
d147 1
d152 9
a160 1
    int max = LineMaxCol(screen, ld);
d227 3
a229 1
	|| screen->cur_row + amount <= screen->bot_marg) {
d231 3
a233 1
	return;
a234 3

    CursorDown(screen, j = screen->bot_marg - screen->cur_row);
    xtermScroll(xw, amount - j);
d251 3
a253 1
	|| screen->cur_row - amount >= screen->top_marg) {
d255 3
a257 1
	return;
a258 3

    RevScroll(xw, amount - (screen->cur_row - screen->top_marg));
    CursorUp(screen, screen->cur_row - screen->top_marg);
d266 1
a266 1
CarriageReturn(TScreen * screen)
d268 18
a285 1
    set_cur_col(screen, 0);
d379 1
a379 1
CursorNextLine(TScreen * screen, int count)
d381 2
d384 1
a384 1
    CarriageReturn(screen);
d392 1
a392 1
CursorPrevLine(TScreen * screen, int count)
d394 2
d397 1
a397 1
    CarriageReturn(screen);
d399 30
@


1.5
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.54 2009/11/28 13:26:13 tom Exp $ */
d4 1
a4 1
 * Copyright 2002-2008,2009 by Thomas E. Dickey
d313 2
a314 2
    xw->flags &= ~DECSC_FLAGS;
    xw->flags |= sc->flags & DECSC_FLAGS;
@


1.4
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.53 2009/08/09 17:23:25 tom Exp $ */
d99 1
a99 1
    TScreen *screen = &xw->screen;
d192 1
a192 1
    TScreen *screen = &xw->screen;
d216 1
a216 1
    TScreen *screen = &xw->screen;
d252 1
a252 1
    TScreen *screen = &xw->screen;
d270 1
a270 1
    TScreen *screen = &xw->screen;
d299 1
a299 1
    TScreen *screen = &xw->screen;
@


1.3
log
@xterm 238. includes fix for CVE-2008-2383.
@
text
@d1 1
a1 3
/* $XTermId: cursor.c,v 1.46 2008/10/05 20:12:16 tom Exp $ */

/* $XFree86: xc/programs/xterm/cursor.c,v 3.20 2006/02/13 01:14:58 dickey Exp $ */
d4 1
a4 1
 * Copyright 2002-2007,2008 by Thomas E. Dickey
d129 3
d133 1
a133 1
    int max = CurMaxCol(screen, screen->cur_row);
d254 2
a255 2
    if (screen->alternate) {
	SavedCursor *sc = &screen->sc[screen->alternate == False];
d271 1
a271 1
    SavedCursor *sc = &screen->sc[screen->alternate != False];
d300 1
a300 1
    SavedCursor *sc = &screen->sc[screen->alternate != False];
d355 2
d367 2
@


1.2
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.45 2008/04/20 21:06:22 tom Exp $ */
d84 1
a84 1
    screen->do_wrap = 0;
d122 1
a122 1
    screen->do_wrap = 0;
d138 1
a138 1
    screen->do_wrap = 0;
d159 1
a159 1
    screen->do_wrap = 0;
d181 1
a181 1
    screen->do_wrap = 0;
d239 1
a239 1
    screen->do_wrap = 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.42 2006/07/23 20:23:52 tom Exp $ */
d6 1
a6 1
 * Copyright 2002-2005,2006 by Thomas E. Dickey
d117 2
a118 1
	} else
d120 1
d240 21
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 229
@
text
@d1 1
a1 1
/* $XTermId: cursor.c,v 1.43 2007/07/07 12:14:51 tom Exp $ */
d6 1
a6 1
 * Copyright 2002-2006,2007 by Thomas E. Dickey
d117 1
a117 2
	    do_xevents();
	} else {
a118 1
	}
a237 1
    do_xevents();
@

