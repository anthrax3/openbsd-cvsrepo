head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.2
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.24.0.2
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.2
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.18.0.2
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.4.0.2
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.1.1.4.0.4
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.2
	v232:1.1.1.4
	v229:1.1.1.3
	OPENBSD_4_2:1.1.1.2.0.2
	OPENBSD_4_2_BASE:1.1.1.2
	v225:1.1.1.2
	v216:1.1.1.1
	xterm:1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2017.07.15.19.20.51;	author matthieu;	state Exp;
branches;
next	1.24;
commitid	b9xPQ49d1NNt4zlu;

1.24
date	2016.08.07.21.27.36;	author matthieu;	state Exp;
branches;
next	1.23;
commitid	psxxjI5z4Vpv2LL4;

1.23
date	2016.01.13.20.40.08;	author matthieu;	state Exp;
branches;
next	1.22;
commitid	by9Wu4LDAgU65dBU;

1.22
date	2015.09.05.14.11.46;	author matthieu;	state Exp;
branches;
next	1.21;
commitid	YVUODLQ4QcYTuGkb;

1.21
date	2014.10.05.16.39.19;	author matthieu;	state Exp;
branches;
next	1.20;
commitid	0wVJ6bWh03LWbUdn;

1.20
date	2014.07.14.08.30.11;	author matthieu;	state Exp;
branches;
next	1.19;
commitid	EnwNNUjlkdrocnMa;

1.19
date	2014.05.09.19.56.40;	author matthieu;	state Exp;
branches;
next	1.18;

1.18
date	2013.08.26.20.06.12;	author matthieu;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.09.14.45.38;	author matthieu;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.04.16.40.18;	author matthieu;	state Exp;
branches;
next	1.15;

1.15
date	2012.04.14.09.02.46;	author matthieu;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.16.21.14.25;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2011.09.17.11.51.57;	author matthieu;	state Exp;
branches;
next	1.12;

1.12
date	2011.08.18.19.47.42;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.07.19.21.06;	author matthieu;	state Exp;
branches;
next	1.10;

1.10
date	2011.03.07.20.41.27;	author matthieu;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.22.13.38.11;	author matthieu;	state Exp;
branches;
next	1.8;

1.8
date	2010.05.08.12.20.46;	author matthieu;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.25.22.03.51;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.31.14.11.57;	author matthieu;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.05.15.58.09;	author matthieu;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.04.15.10.44;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.09.22.13.04;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2008.08.25.18.05.57;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.26.11.11.37;	author matthieu;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.11.26.11.11.37;	author matthieu;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.06.15.19.30.27;	author matthieu;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.08.25.18.54.00;	author matthieu;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.02.16.09.35.07;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Update to xterm 330
@
text
@/* $XTermId: menu.c,v 1.344 2017/01/02 23:46:03 tom Exp $ */

/*
 * Copyright 1999-2016,2017 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1989  The Open Group
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation.
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of The Open Group shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from The Open Group.
 */

#include <xterm.h>
#include <data.h>
#include <menu.h>
#include <fontutils.h>
#include <xstrings.h>

#include <locale.h>

#include <X11/Xmu/CharSet.h>

#define app_con Xaw_app_con	/* quiet a warning from SimpleMenu.h */

#if defined(HAVE_LIB_XAW)

#include <X11/Xaw/SimpleMenu.h>
#include <X11/Xaw/Box.h>
#include <X11/Xaw/SmeBSB.h>
#include <X11/Xaw/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/Xaw/MenuButton.h>
#include <X11/Xaw/Form.h>
#endif

#elif defined(HAVE_LIB_XAW3D)

#include <X11/Xaw3d/SimpleMenu.h>
#include <X11/Xaw3d/Box.h>
#include <X11/Xaw3d/SmeBSB.h>
#include <X11/Xaw3d/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/Xaw3d/MenuButton.h>
#include <X11/Xaw3d/Form.h>
#endif

#elif defined(HAVE_LIB_XAW3DXFT)

#include <X11/Xaw3dxft/SimpleMenu.h>
#include <X11/Xaw3dxft/Box.h>
#include <X11/Xaw3dxft/SmeBSB.h>
#include <X11/Xaw3dxft/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/Xaw3dxft/MenuButton.h>
#include <X11/Xaw3dxft/Form.h>
#endif

#elif defined(HAVE_LIB_NEXTAW)

#include <X11/neXtaw/SimpleMenu.h>
#include <X11/neXtaw/Box.h>
#include <X11/neXtaw/SmeBSB.h>
#include <X11/neXtaw/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/neXtaw/MenuButton.h>
#include <X11/neXtaw/Form.h>
#endif

#elif defined(HAVE_LIB_XAWPLUS)

#include <X11/XawPlus/SimpleMenu.h>
#include <X11/XawPlus/Box.h>
#include <X11/XawPlus/SmeBSB.h>
#include <X11/XawPlus/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/XawPlus/MenuButton.h>
#include <X11/XawPlus/Form.h>
#endif

#endif

#undef app_con

#include <stdio.h>
#include <signal.h>

#if OPT_TRACE
#define UpdateCheckbox(func, mn, mi, val) UpdateMenuItem(func, mn, mi, val)
#else
#define UpdateCheckbox(func, mn, mi, val) UpdateMenuItem(mn, mi, val)
#endif

#define ToggleFlag(flag) flag = (Boolean) !flag
/* *INDENT-OFF* */
static void do_8bit_control    PROTO_XT_CALLBACK_ARGS;
static void do_allow132        PROTO_XT_CALLBACK_ARGS;
static void do_allowBoldFonts  PROTO_XT_CALLBACK_ARGS;
static void do_allowsends      PROTO_XT_CALLBACK_ARGS;
static void do_altscreen       PROTO_XT_CALLBACK_ARGS;
static void do_appcursor       PROTO_XT_CALLBACK_ARGS;
static void do_appkeypad       PROTO_XT_CALLBACK_ARGS;
static void do_autolinefeed    PROTO_XT_CALLBACK_ARGS;
static void do_autowrap        PROTO_XT_CALLBACK_ARGS;
static void do_backarrow       PROTO_XT_CALLBACK_ARGS;
static void do_bellIsUrgent    PROTO_XT_CALLBACK_ARGS;
static void do_clearsavedlines PROTO_XT_CALLBACK_ARGS;
static void do_continue        PROTO_XT_CALLBACK_ARGS;
static void do_delete_del      PROTO_XT_CALLBACK_ARGS;
#if OPT_SCREEN_DUMPS
static void do_dump_html       PROTO_XT_CALLBACK_ARGS;
static void do_dump_svg        PROTO_XT_CALLBACK_ARGS;
#endif
static void do_hardreset       PROTO_XT_CALLBACK_ARGS;
static void do_interrupt       PROTO_XT_CALLBACK_ARGS;
static void do_jumpscroll      PROTO_XT_CALLBACK_ARGS;
static void do_keepClipboard   PROTO_XT_CALLBACK_ARGS;
static void do_keepSelection   PROTO_XT_CALLBACK_ARGS;
static void do_kill            PROTO_XT_CALLBACK_ARGS;
static void do_old_fkeys       PROTO_XT_CALLBACK_ARGS;
static void do_poponbell       PROTO_XT_CALLBACK_ARGS;
static void do_print           PROTO_XT_CALLBACK_ARGS;
static void do_print_redir     PROTO_XT_CALLBACK_ARGS;
static void do_quit            PROTO_XT_CALLBACK_ARGS;
static void do_redraw          PROTO_XT_CALLBACK_ARGS;
static void do_reversevideo    PROTO_XT_CALLBACK_ARGS;
static void do_reversewrap     PROTO_XT_CALLBACK_ARGS;
static void do_scrollbar       PROTO_XT_CALLBACK_ARGS;
static void do_scrollkey       PROTO_XT_CALLBACK_ARGS;
static void do_scrollttyoutput PROTO_XT_CALLBACK_ARGS;
static void do_securekbd       PROTO_XT_CALLBACK_ARGS;
static void do_selectClipboard PROTO_XT_CALLBACK_ARGS;
static void do_softreset       PROTO_XT_CALLBACK_ARGS;
static void do_suspend         PROTO_XT_CALLBACK_ARGS;
static void do_terminate       PROTO_XT_CALLBACK_ARGS;
static void do_titeInhibit     PROTO_XT_CALLBACK_ARGS;
static void do_visualbell      PROTO_XT_CALLBACK_ARGS;
static void do_vtfont          PROTO_XT_CALLBACK_ARGS;

#ifdef ALLOWLOGGING
static void do_logging         PROTO_XT_CALLBACK_ARGS;
#endif

#ifndef NO_ACTIVE_ICON
static void do_activeicon      PROTO_XT_CALLBACK_ARGS;
#endif /* NO_ACTIVE_ICON */

#if OPT_ALLOW_XXX_OPS
static void enable_allow_xxx_ops (Bool);
static void do_allowColorOps   PROTO_XT_CALLBACK_ARGS;
static void do_allowFontOps    PROTO_XT_CALLBACK_ARGS;
static void do_allowMouseOps   PROTO_XT_CALLBACK_ARGS;
static void do_allowTcapOps    PROTO_XT_CALLBACK_ARGS;
static void do_allowTitleOps   PROTO_XT_CALLBACK_ARGS;
static void do_allowWindowOps  PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_BLINK_CURS
static void do_cursorblink     PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_BOX_CHARS
static void do_font_boxchars   PROTO_XT_CALLBACK_ARGS;
static void do_font_packed     PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_DEC_CHRSET
static void do_font_doublesize PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_DEC_SOFTFONT
static void do_font_loadable   PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_HP_FUNC_KEYS
static void do_hp_fkeys        PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_MAXIMIZE
static void do_fullscreen      PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_NUM_LOCK
static void do_alt_esc         PROTO_XT_CALLBACK_ARGS;
static void do_num_lock        PROTO_XT_CALLBACK_ARGS;
static void do_meta_esc        PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_PRINT_ON_EXIT
static void do_write_now       PROTO_XT_CALLBACK_ARGS;
static void do_write_error     PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_RENDERFONT
static void do_font_renderfont PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_SCO_FUNC_KEYS
static void do_sco_fkeys       PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_SIXEL_GRAPHICS
static void do_sixelscrolling  PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_GRAPHICS
static void do_privatecolorregisters PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_SUN_FUNC_KEYS
static void do_sun_fkeys       PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_SUNPC_KBD
static void do_sun_kbd         PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_TCAP_FKEYS
static void do_tcap_fkeys      PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_TEK4014
static void do_tekcopy         PROTO_XT_CALLBACK_ARGS;
static void do_tekhide         PROTO_XT_CALLBACK_ARGS;
static void do_tekmode         PROTO_XT_CALLBACK_ARGS;
static void do_tekonoff        PROTO_XT_CALLBACK_ARGS;
static void do_tekpage         PROTO_XT_CALLBACK_ARGS;
static void do_tekreset        PROTO_XT_CALLBACK_ARGS;
static void do_tekshow         PROTO_XT_CALLBACK_ARGS;
static void do_tektext2        PROTO_XT_CALLBACK_ARGS;
static void do_tektext3        PROTO_XT_CALLBACK_ARGS;
static void do_tektextlarge    PROTO_XT_CALLBACK_ARGS;
static void do_tektextsmall    PROTO_XT_CALLBACK_ARGS;
static void do_vthide          PROTO_XT_CALLBACK_ARGS;
static void do_vtmode          PROTO_XT_CALLBACK_ARGS;
static void do_vtonoff         PROTO_XT_CALLBACK_ARGS;
static void do_vtshow          PROTO_XT_CALLBACK_ARGS;
static void handle_tekshow     (Widget gw, Bool allowswitch);
static void handle_vtshow      (Widget gw, Bool allowswitch);
#endif

#if OPT_TOOLBAR
static void do_toolbar         PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_WIDE_CHARS
static void do_font_utf8_mode  PROTO_XT_CALLBACK_ARGS;
static void do_font_utf8_fonts PROTO_XT_CALLBACK_ARGS;
static void do_font_utf8_title PROTO_XT_CALLBACK_ARGS;
#endif

/*
 * The order of entries MUST match the values given in menu.h
 */
MenuEntry mainMenuEntries[] = {
#if OPT_TOOLBAR
    { "toolbar",	do_toolbar,	NULL },
#endif
#if OPT_MAXIMIZE
    { "fullscreen",	do_fullscreen,	NULL },
#endif
    { "securekbd",	do_securekbd,	NULL },
    { "allowsends",	do_allowsends,	NULL },
    { "redraw",		do_redraw,	NULL },
    { "line1",		NULL,		NULL },
#ifdef ALLOWLOGGING
    { "logging",	do_logging,	NULL },
#endif
#ifdef OPT_PRINT_ON_EXIT
    { "print-immediate", do_write_now,	NULL },
    { "print-on-error",	do_write_error,	NULL },
#endif
    { "print",		do_print,	NULL },
    { "print-redir",	do_print_redir,	NULL },
#if OPT_SCREEN_DUMPS
    { "dump-html",	do_dump_html,	NULL },
    { "dump-svg",	do_dump_svg,	NULL },
#endif
    { "line2",		NULL,		NULL },
    { "8-bit control",	do_8bit_control,NULL },
    { "backarrow key",	do_backarrow,	NULL },
#if OPT_NUM_LOCK
    { "num-lock",	do_num_lock,	NULL },
    { "alt-esc",	do_alt_esc,	NULL },
    { "meta-esc",	do_meta_esc,	NULL },
#endif
    { "delete-is-del",	do_delete_del,	NULL },
    { "oldFunctionKeys",do_old_fkeys,	NULL },
#if OPT_TCAP_FKEYS
    { "tcapFunctionKeys",do_tcap_fkeys,	NULL },
#endif
#if OPT_HP_FUNC_KEYS
    { "hpFunctionKeys",	do_hp_fkeys,	NULL },
#endif
#if OPT_SCO_FUNC_KEYS
    { "scoFunctionKeys",do_sco_fkeys,	NULL },
#endif
#if OPT_SUN_FUNC_KEYS
    { "sunFunctionKeys",do_sun_fkeys,	NULL },
#endif
#if OPT_SUNPC_KBD
    { "sunKeyboard",	do_sun_kbd,	NULL },
#endif
    { "line3",		NULL,		NULL },
    { "suspend",	do_suspend,	NULL },
    { "continue",	do_continue,	NULL },
    { "interrupt",	do_interrupt,	NULL },
    { "hangup",		do_hangup,	NULL },
    { "terminate",	do_terminate,	NULL },
    { "kill",		do_kill,	NULL },
    { "line4",		NULL,		NULL },
    { "quit",		do_quit,	NULL }};

MenuEntry vtMenuEntries[] = {
    { "scrollbar",	do_scrollbar,	NULL },
    { "jumpscroll",	do_jumpscroll,	NULL },
    { "reversevideo",	do_reversevideo, NULL },
    { "autowrap",	do_autowrap,	NULL },
    { "reversewrap",	do_reversewrap, NULL },
    { "autolinefeed",	do_autolinefeed, NULL },
    { "appcursor",	do_appcursor,	NULL },
    { "appkeypad",	do_appkeypad,	NULL },
    { "scrollkey",	do_scrollkey,	NULL },
    { "scrollttyoutput",do_scrollttyoutput, NULL },
    { "allow132",	do_allow132,	NULL },
    { "keepSelection",	do_keepSelection, NULL },
    { "selectToClipboard",do_selectClipboard, NULL },
    { "visualbell",	do_visualbell,	NULL },
    { "bellIsUrgent",	do_bellIsUrgent, NULL },
    { "poponbell",	do_poponbell,	NULL },
#if OPT_BLINK_CURS
    { "cursorblink",	do_cursorblink,	NULL },
#endif
    { "titeInhibit",	do_titeInhibit,	NULL },
#ifndef NO_ACTIVE_ICON
    { "activeicon",	do_activeicon,	NULL },
#endif /* NO_ACTIVE_ICON */
    { "line1",		NULL,		NULL },
    { "softreset",	do_softreset,	NULL },
    { "hardreset",	do_hardreset,	NULL },
    { "clearsavedlines",do_clearsavedlines, NULL },
    { "line2",		NULL,		NULL },
#if OPT_TEK4014
    { "tekshow",	do_tekshow,	NULL },
    { "tekmode",	do_tekmode,	NULL },
    { "vthide",		do_vthide,	NULL },
#endif
    { "altscreen",	do_altscreen,	NULL },
#if OPT_SIXEL_GRAPHICS
    { "sixelScrolling",	do_sixelscrolling,	NULL },
#endif
#if OPT_GRAPHICS
    { "privateColorRegisters", do_privatecolorregisters, NULL },
#endif
    };

MenuEntry fontMenuEntries[] = {
    { "fontdefault",	do_vtfont,	NULL },
    { "font1",		do_vtfont,	NULL },
    { "font2",		do_vtfont,	NULL },
    { "font3",		do_vtfont,	NULL },
    { "font4",		do_vtfont,	NULL },
    { "font5",		do_vtfont,	NULL },
    { "font6",		do_vtfont,	NULL },
    /* this is after the last builtin font; the other entries are special */
    { "fontescape",	do_vtfont,	NULL },
    { "fontsel",	do_vtfont,	NULL },
    /* down to here should match NMENUFONTS in ptyx.h */

#if OPT_DEC_CHRSET || OPT_BOX_CHARS || OPT_DEC_SOFTFONT
    { "line1",		NULL,		NULL },
    { "allow-bold-fonts", do_allowBoldFonts, NULL },
#if OPT_BOX_CHARS
    { "font-linedrawing",do_font_boxchars,NULL },
    { "font-packed",	do_font_packed,NULL },
#endif
#if OPT_DEC_CHRSET
    { "font-doublesize",do_font_doublesize,NULL },
#endif
#if OPT_DEC_SOFTFONT
    { "font-loadable",	do_font_loadable,NULL },
#endif
#endif /* toggles for DEC font extensions */

#if OPT_RENDERFONT || OPT_WIDE_CHARS
    { "line2",		NULL,		NULL },
#if OPT_RENDERFONT
    { "render-font",	do_font_renderfont,NULL },
#endif
#if OPT_WIDE_CHARS
    { "utf8-mode",	do_font_utf8_mode,NULL },
    { "utf8-fonts",	do_font_utf8_fonts,NULL },
    { "utf8-title",	do_font_utf8_title,NULL },
#endif
#endif /* toggles for other font extensions */

#if OPT_ALLOW_XXX_OPS
    { "line3",		NULL,		NULL },
    { "allow-color-ops",do_allowColorOps,NULL },
    { "allow-font-ops",	do_allowFontOps,NULL },
    { "allow-mouse-ops",do_allowMouseOps,NULL },
    { "allow-tcap-ops",	do_allowTcapOps,NULL },
    { "allow-title-ops",do_allowTitleOps,NULL },
    { "allow-window-ops",do_allowWindowOps,NULL },
#endif

    };

#if OPT_TEK4014
MenuEntry tekMenuEntries[] = {
    { "tektextlarge",	do_tektextlarge, NULL },
    { "tektext2",	do_tektext2,	NULL },
    { "tektext3",	do_tektext3,	NULL },
    { "tektextsmall",	do_tektextsmall, NULL },
    { "line1",		NULL,		NULL },
    { "tekpage",	do_tekpage,	NULL },
    { "tekreset",	do_tekreset,	NULL },
    { "tekcopy",	do_tekcopy,	NULL },
    { "line2",		NULL,		NULL },
    { "vtshow",		do_vtshow,	NULL },
    { "vtmode",		do_vtmode,	NULL },
    { "tekhide",	do_tekhide,	NULL }};
#endif

typedef struct {
    char *internal_name;
    MenuEntry *entry_list;
    Cardinal entry_len;
} MenuHeader;

    /* This table is ordered to correspond with MenuIndex */
static const MenuHeader menu_names[] = {
    { "mainMenu", mainMenuEntries, XtNumber(mainMenuEntries) },
    { "vtMenu",   vtMenuEntries,   XtNumber(vtMenuEntries)   },
    { "fontMenu", fontMenuEntries, XtNumber(fontMenuEntries) },
#if OPT_TEK4014
    { "tekMenu",  tekMenuEntries,  XtNumber(tekMenuEntries)  },
#endif
    { 0,          0,               0 },
};
/* *INDENT-ON* */

/*
 * FIXME:  These are global data rather than in the xterm widget because they
 * are initialized before the widget is created.
 */
typedef struct {
    Widget b;			/* the toolbar's buttons */
    Widget w;			/* the popup shell activated by the button */
    Cardinal entries;
} MenuList;

static MenuList vt_shell[NUM_POPUP_MENUS];

#if OPT_TEK4014 && OPT_TOOLBAR
static MenuList tek_shell[NUM_POPUP_MENUS];
#endif

static String
setMenuLocale(Bool before, String substitute)
{
    String result = setlocale(LC_CTYPE, 0);

    if (before) {
	result = x_strdup(result);
    }
    (void) setlocale(LC_CTYPE, substitute);
    TRACE(("setMenuLocale %s:%s\n",
	   (before
	    ? "before"
	    : "after"),
	   NonNull(result)));
    if (!before) {
	free((void *) substitute);
    }
    return result;
}

/*
 * Returns a pointer to the MenuList entry that matches the popup menu.
 */
static MenuList *
select_menu(Widget w GCC_UNUSED, MenuIndex num)
{
#if OPT_TEK4014 && OPT_TOOLBAR
    while (w != 0) {
	if (w == tekshellwidget) {
	    return &tek_shell[num];
	}
	w = XtParent(w);
    }
#endif
    return &vt_shell[num];
}

/*
 * Returns a pointer to the given popup menu shell
 */
static Widget
obtain_menu(Widget w, MenuIndex num)
{
    return select_menu(w, num)->w;
}

/*
 * Returns the number of entries in the given popup menu shell
 */
static Cardinal
sizeof_menu(Widget w, MenuIndex num)
{
    return select_menu(w, num)->entries;
}

/*
 * Return an array of flags telling if a given menu item is never going to
 * be used, so we can reduce the size of menus.
 */
static Boolean *
unusedEntries(XtermWidget xw, MenuIndex num)
{
    static Boolean result[XtNumber(mainMenuEntries)
			  + XtNumber(vtMenuEntries)
			  + XtNumber(fontMenuEntries)
#if OPT_TEK4014
			  + XtNumber(tekMenuEntries)
#endif
    ];
    TScreen *screen = TScreenOf(xw);

    memset(result, 0, sizeof(result));
    switch (num) {
    case mainMenu:
#if OPT_MAXIMIZE
	if (resource.fullscreen > 1) {
	    result[mainMenu_fullscreen] = True;
	}
#endif
#if OPT_NUM_LOCK
	if (!screen->alt_is_not_meta) {
	    result[mainMenu_alt_esc] = True;
	}
#endif
	if (!xtermHasPrinter(xw)) {
	    result[mainMenu_print] = True;
	    result[mainMenu_print_redir] = True;
	}
	if (screen->terminal_id < 200) {
	    result[mainMenu_8bit_ctrl] = True;
	}
#if !defined(SIGTSTP)
	result[mainMenu_suspend] = True;
#endif
#if !defined(SIGCONT)
	result[mainMenu_continue] = True;
#endif
#ifdef ALLOWLOGGING
	if (screen->inhibit & I_LOG) {
	    result[mainMenu_logging] = True;
	}
#endif
	if (screen->inhibit & I_SIGNAL) {
	    int n;
	    for (n = (int) mainMenu_suspend; n <= (int) mainMenu_quit; ++n) {
		result[n] = True;
	    }
	}
	break;
    case vtMenu:
#ifndef NO_ACTIVE_ICON
	if (!getIconicFont(screen)->fs || !screen->iconVwin.window) {
	    result[vtMenu_activeicon] = True;
	}
#endif /* NO_ACTIVE_ICON */
#if OPT_TEK4014
	if (screen->inhibit & I_TEK) {
	    int n;
	    for (n = (int) vtMenu_tekshow; n <= (int) vtMenu_vthide; ++n) {
		result[n] = True;
	    }
	}
#endif
	break;
    case fontMenu:
	break;
#if OPT_TEK4014
    case tekMenu:
	break;
#endif
    case noMenu:
	break;
    }
    return result;
}

/*
 * create_menu - create a popup shell and stuff the menu into it.
 */
static Widget
create_menu(Widget w, XtermWidget xw, MenuIndex num)
{
    static XtCallbackRec cb[2] =
    {
	{NULL, NULL},
	{NULL, NULL}};
    static Arg arg =
    {XtNcallback, (XtArgVal) cb};

    TScreen *screen = TScreenOf(xw);
    const MenuHeader *data = &menu_names[num];
    MenuList *list = select_menu(w, num);
    struct _MenuEntry *entries = data->entry_list;
    Cardinal nentries = data->entry_len;
#if !OPT_TOOLBAR
    String saveLocale;
#endif

    if (screen->menu_item_bitmap == None) {
	/*
	 * we really want to do these dynamically
	 */
#define check_width 9
#define check_height 8
	static unsigned char check_bits[] =
	{
	    0x00, 0x01, 0x80, 0x01, 0xc0, 0x00, 0x60, 0x00,
	    0x31, 0x00, 0x1b, 0x00, 0x0e, 0x00, 0x04, 0x00
	};

	screen->menu_item_bitmap =
	    XCreateBitmapFromData(XtDisplay(xw),
				  RootWindowOfScreen(XtScreen(xw)),
				  (char *) check_bits, check_width, check_height);
    }
#if !OPT_TOOLBAR
    saveLocale = setMenuLocale(True, resource.menuLocale);
    list->w = XtCreatePopupShell(data->internal_name,
				 simpleMenuWidgetClass,
				 toplevel,
				 NULL, 0);
#endif
    if (list->w != 0) {
	Boolean *unused = unusedEntries(xw, num);
	Cardinal n;

	list->entries = 0;

	for (n = 0; n < nentries; ++n) {
	    if (!unused[n]) {
		cb[0].callback = (XtCallbackProc) entries[n].function;
		cb[0].closure = (XtPointer) entries[n].name;
		entries[n].widget = XtCreateManagedWidget(entries[n].name,
							  (entries[n].function
							   ? smeBSBObjectClass
							   : smeLineObjectClass),
							  list->w,
							  &arg, (Cardinal) 1);
		list->entries++;
	    }
	}
    }
#if !OPT_TOOLBAR
    (void) setMenuLocale(False, saveLocale);
#endif

    /* do not realize at this point */
    return list->w;
}

static MenuIndex
indexOfMenu(String menuName)
{
    MenuIndex me;
    switch (*menuName) {
    case 'm':
	me = mainMenu;
	break;
    case 'v':
	me = vtMenu;
	break;
    case 'f':
	me = fontMenu;
	break;
#if OPT_TEK4014
    case 't':
	me = tekMenu;
	break;
#endif
    default:
	me = noMenu;
    }
    return (me);
}

/* ARGSUSED */
static Bool
domenu(Widget w,
       XEvent *event GCC_UNUSED,
       String *params,		/* mainMenu, vtMenu, or tekMenu */
       Cardinal *param_count)	/* 0 or 1 */
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
    MenuIndex me;
    Bool created = False;
    Widget mw;

    if (*param_count != 1) {
	Bell(xw, XkbBI_MinorError, 0);
	return False;
    }

    if ((me = indexOfMenu(params[0])) == noMenu) {
	Bell(xw, XkbBI_MinorError, 0);
	return False;
    }

    if ((mw = obtain_menu(w, me)) == 0
	|| sizeof_menu(w, me) == 0) {
	mw = create_menu(w, xw, me);
	created = (mw != 0);
    }
    if (mw == 0)
	return False;

    TRACE(("domenu(%s) %s\n", params[0], created ? "create" : "update"));
    switch (me) {
    case mainMenu:
	if (created) {
	    update_toolbar();
	    update_fullscreen();
	    update_securekbd();
	    update_allowsends();
	    update_logging();
	    update_print_redir();
	    update_8bit_control();
	    update_decbkm();
	    update_num_lock();
	    update_alt_esc();
	    update_meta_esc();
	    update_delete_del();
	    update_keyboard_type();
#ifdef OPT_PRINT_ON_EXIT
	    screen->write_error = !IsEmpty(resource.printFileOnXError);
	    SetItemSensitivity(mainMenuEntries[mainMenu_write_now].widget, False);
	    SetItemSensitivity(mainMenuEntries[mainMenu_write_error].widget, screen->write_error);
#endif
	}
	break;

    case vtMenu:
	if (created) {
	    update_scrollbar();
	    update_jumpscroll();
	    update_reversevideo();
	    update_autowrap();
	    update_reversewrap();
	    update_autolinefeed();
	    update_appcursor();
	    update_appkeypad();
	    update_scrollkey();
	    update_scrollttyoutput();
	    update_allow132();
	    update_cursesemul();
	    update_keepSelection();
	    update_selectToClipboard();
	    update_visualbell();
	    update_poponbell();
	    update_bellIsUrgent();
	    update_cursorblink();
	    update_altscreen();
	    update_decsdm();	/* Sixel Display Mode */
	    update_titeInhibit();
#ifndef NO_ACTIVE_ICON
	    update_activeicon();
#endif /* NO_ACTIVE_ICON */
	    update_privatecolorregisters();
	}
	break;

    case fontMenu:
	if (created) {
	    int n;

	    set_menu_font(True);
	    for (n = fontMenu_font1; n <= fontMenu_font6; ++n) {
		if (IsEmpty(screen->menu_font_names[n][fNorm]))
		    SetItemSensitivity(fontMenuEntries[n].widget, False);
	    }
	    update_font_escape();
	    update_menu_allowBoldFonts();
#if OPT_BOX_CHARS
	    update_font_boxchars();
	    SetItemSensitivity(
				  fontMenuEntries[fontMenu_font_boxchars].widget,
				  True);
	    update_font_packed();
	    SetItemSensitivity(
				  fontMenuEntries[fontMenu_font_packedfont].widget,
				  True);
#endif
#if OPT_DEC_SOFTFONT		/* FIXME: not implemented */
	    update_font_loadable();
	    SetItemSensitivity(
				  fontMenuEntries[fontMenu_font_loadable].widget,
				  False);
#endif
#if OPT_DEC_CHRSET
	    update_font_doublesize();
	    if (TScreenOf(xw)->cache_doublesize == 0)
		SetItemSensitivity(
				      fontMenuEntries[fontMenu_font_doublesize].widget,
				      False);
#endif
#if OPT_RENDERFONT
	    update_font_renderfont();
#endif
#if OPT_WIDE_CHARS
	    update_font_utf8_mode();
	    update_font_utf8_fonts();
	    update_font_utf8_title();
#endif
#if OPT_ALLOW_XXX_OPS
	    update_menu_allowColorOps();
	    update_menu_allowFontOps();
	    update_menu_allowMouseOps();
	    update_menu_allowTcapOps();
	    update_menu_allowTitleOps();
	    update_menu_allowWindowOps();
	    enable_allow_xxx_ops(!(screen->allowSendEvents));
#endif
	}
#if OPT_TOOLBAR
	/* menus for toolbar are initialized once only */
	SetItemSensitivity(fontMenuEntries[fontMenu_fontsel].widget, True);
#else
	FindFontSelection(xw, NULL, True);
	SetItemSensitivity(fontMenuEntries[fontMenu_fontsel].widget,
			   (screen->SelectFontName()
			    ? True
			    : False));
#endif
	break;

#if OPT_TEK4014
    case tekMenu:
	if (created && tekWidget) {
	    set_tekfont_menu_item(TekScreenOf(tekWidget)->cur.fontsize, True);
	    update_vtshow();
	}
	break;
#endif
    case noMenu:
    default:
	break;
    }

    return True;
}

/*
 * public interfaces
 */

void
HandleCreateMenu(Widget w,
		 XEvent *event,
		 String *params,	/* mainMenu, vtMenu, or tekMenu */
		 Cardinal *param_count)		/* 0 or 1 */
{
    TRACE(("HandleCreateMenu\n"));
    (void) domenu(w, event, params, param_count);
}

void
HandlePopupMenu(Widget w,
		XEvent *event,
		String *params,	/* mainMenu, vtMenu, or tekMenu */
		Cardinal *param_count)	/* 0 or 1 */
{
    TRACE(("HandlePopupMenu\n"));
    if (domenu(w, event, params, param_count)) {
	XtermWidget xw = term;
	TScreen *screen = TScreenOf(xw);

#if OPT_TOOLBAR
	w = select_menu(w, mainMenu)->w;
#endif
	/*
	 * The action procedure in SimpleMenu.c, PositionMenu does not expect a
	 * key translation event when we are popping up a menu.  In particular,
	 * if the pointer is outside the menu, then the action procedure will
	 * fail in its attempt to determine the location of the pointer within
	 * the menu.  Anticipate that by warping the pointer into the menu when
	 * a key event is detected.
	 */
	switch (event->type) {
	case KeyPress:
	case KeyRelease:
	    XWarpPointer(screen->display, None, XtWindow(w), 0, 0, 0, 0, 0, 0);
	    break;
	default:
	    XtCallActionProc(w, "XawPositionSimpleMenu", event, params, 1);
	    break;
	}
	XtCallActionProc(w, "MenuPopup", event, params, 1);
    }
}

/*
 * private interfaces - keep out!
 */

/* ARGSUSED */
static void
handle_send_signal(Widget gw GCC_UNUSED, int sig)
{
#ifndef VMS
    TScreen *screen = TScreenOf(term);

    if (hold_screen > 1)
	hold_screen = 0;
    if (screen->pid > 1)
	kill_process_group(screen->pid, sig);
#endif
}

static void
UpdateMenuItem(
#if OPT_TRACE
		  const char *func,
#endif
		  MenuEntry * menu,
		  int which,
		  Bool val)
{
    static Arg menuArgs =
    {XtNleftBitmap, (XtArgVal) 0};
    Widget mi = menu[which].widget;

    if (mi) {
	menuArgs.value = (XtArgVal) ((val)
				     ? TScreenOf(term)->menu_item_bitmap
				     : None);
	XtSetValues(mi, &menuArgs, (Cardinal) 1);
    }
    TRACE(("%s(%d): %s\n", func, which, MtoS(val)));
}

void
SetItemSensitivity(Widget mi, Bool val)
{
    static Arg menuArgs =
    {XtNsensitive, (XtArgVal) 0};

    if (mi) {
	menuArgs.value = (XtArgVal) (val);
	XtSetValues(mi, &menuArgs, (Cardinal) 1);
    }
}

/*
 * action routines
 */

static void
do_securekbd(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);
    Time now = CurrentTime;	/* XXX - wrong */

    if (screen->grabbedKbd) {
	XUngrabKeyboard(screen->display, now);
	ReverseVideo(xw);
	screen->grabbedKbd = False;
    } else {
	if (XGrabKeyboard(screen->display, XtWindow(CURRENT_EMU()),
			  True, GrabModeAsync, GrabModeAsync, now)
	    != GrabSuccess) {
	    Bell(xw, XkbBI_MinorError, 100);
	} else {
	    ReverseVideo(xw);
	    screen->grabbedKbd = True;
	}
    }
    update_securekbd();
}

/* ARGSUSED */
void
HandleSecure(Widget w GCC_UNUSED,
	     XEvent *event GCC_UNUSED,	/* unused */
	     String *params GCC_UNUSED,		/* [0] = volume */
	     Cardinal *param_count GCC_UNUSED)	/* 0 or 1 */
{
    do_securekbd(vt_shell[mainMenu].w, (XtPointer) 0, (XtPointer) 0);
}

static void
do_allowsends(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->allowSendEvents);
    update_allowsends();
#if OPT_ALLOW_XXX_OPS
    enable_allow_xxx_ops(!(screen->allowSendEvents));
#endif
}

static void
do_visualbell(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->visualbell);
    update_visualbell();
}

static void
do_bellIsUrgent(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->bellIsUrgent);
    update_bellIsUrgent();
}

static void
do_poponbell(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->poponbell);
    update_poponbell();
}

#ifdef ALLOWLOGGING
static void
do_logging(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

    if (screen->logging) {
	CloseLog(xw);
    } else {
	StartLog(xw);
    }
    /* update_logging done by CloseLog and StartLog */
}
#endif

#ifdef OPT_PRINT_ON_EXIT
static void
do_write_now(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;

    xtermPrintImmediately(xw,
			  (IsEmpty(resource.printFileNow)
			   ? (String) "XTerm"
			   : resource.printFileNow),
			  resource.printOptsNow,
			  resource.printModeNow);
}

static void
do_write_error(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;

    if (IsEmpty(resource.printFileOnXError)) {
	resource.printFileOnXError = "XTermError";
    }
    TScreenOf(xw)->write_error = (Boolean) (!TScreenOf(xw)->write_error);
    update_write_error();
}
#endif

static void
do_print(Widget gw GCC_UNUSED,
	 XtPointer closure GCC_UNUSED,
	 XtPointer data GCC_UNUSED)
{
    xtermPrintScreen(term, True, getPrinterFlags(term, NULL, 0));
}

static void
do_print_redir(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
{
    setPrinterControlMode(term,
			  (PrinterOf(TScreenOf(term)).printer_controlmode
			   ? 0
			   : 2));
}

#if OPT_SCREEN_DUMPS
static void
do_dump_html(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    xtermDumpHtml(term);
}

static void
do_dump_svg(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    xtermDumpSvg(term);
}
#endif

static void
do_redraw(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    Redraw();
}

void
show_8bit_control(Bool value)
{
    if (TScreenOf(term)->control_eight_bits != value) {
	TScreenOf(term)->control_eight_bits = (Boolean) value;
	update_8bit_control();
    }
}

static void
do_8bit_control(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    show_8bit_control(!TScreenOf(term)->control_eight_bits);
}

static void
do_backarrow(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    term->keyboard.flags ^= MODE_DECBKM;
    update_decbkm();
}

#if OPT_NUM_LOCK
static void
do_num_lock(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    ToggleFlag(term->misc.real_NumLock);
    update_num_lock();
}

static void
do_alt_esc(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    ToggleFlag(TScreenOf(term)->alt_sends_esc);
    update_alt_esc();
}

static void
do_meta_esc(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    ToggleFlag(TScreenOf(term)->meta_sends_esc);
    update_meta_esc();
}
#endif

static void
do_delete_del(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    if (xtermDeleteIsDEL(term))
	TScreenOf(term)->delete_is_del = False;
    else
	TScreenOf(term)->delete_is_del = True;
    update_delete_del();
}

static void
do_old_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(term, keyboardIsLegacy);
}

#if OPT_HP_FUNC_KEYS
static void
do_hp_fkeys(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(term, keyboardIsHP);
}
#endif

#if OPT_SCO_FUNC_KEYS
static void
do_sco_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(term, keyboardIsSCO);
}
#endif

#if OPT_SUN_FUNC_KEYS
static void
do_sun_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(term, keyboardIsSun);
}
#endif

#if OPT_SUNPC_KBD
/*
 * This really means "Sun/PC keyboard emulating VT220".
 */
static void
do_sun_kbd(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(term, keyboardIsVT220);
}
#endif

#if OPT_TCAP_FKEYS
static void
do_tcap_fkeys(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(term, keyboardIsTermcap);
}
#endif

/*
 * The following cases use the pid instead of the process group so that we
 * don't get hosed by programs that change their process group
 */

/* ARGSUSED */
static void
do_suspend(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
#if defined(SIGTSTP)
    handle_send_signal(gw, SIGTSTP);
#endif
}

/* ARGSUSED */
static void
do_continue(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
#if defined(SIGCONT)
    handle_send_signal(gw, SIGCONT);
#endif
}

/* ARGSUSED */
static void
do_interrupt(Widget gw,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    handle_send_signal(gw, SIGINT);
}

/* ARGSUSED */
void
do_hangup(Widget gw,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    handle_send_signal(gw, SIGHUP);
}

/* ARGSUSED */
static void
do_terminate(Widget gw,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    handle_send_signal(gw, SIGTERM);
}

/* ARGSUSED */
static void
do_kill(Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    handle_send_signal(gw, SIGKILL);
}

static void
do_quit(Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    Cleanup(SIGHUP);
}

/*
 * vt menu callbacks
 */

static void
do_scrollbar(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    ToggleScrollBar(term);
}

static void
do_jumpscroll(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    term->flags ^= SMOOTHSCROLL;
    if (term->flags & SMOOTHSCROLL) {
	screen->jumpscroll = False;
	if (screen->scroll_amt)
	    FlushScroll(term);
    } else {
	screen->jumpscroll = True;
    }
    update_jumpscroll();
}

static void
do_reversevideo(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    ReverseVideo(term);
}

static void
do_autowrap(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    term->flags ^= WRAPAROUND;
    update_autowrap();
}

static void
do_reversewrap(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
{
    term->flags ^= REVERSEWRAP;
    update_reversewrap();
}

static void
do_autolinefeed(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    term->flags ^= LINEFEED;
    update_autolinefeed();
}

static void
do_appcursor(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    term->keyboard.flags ^= MODE_DECCKM;
    update_appcursor();
}

static void
do_appkeypad(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    term->keyboard.flags ^= MODE_DECKPAM;
    update_appkeypad();
}

static void
do_scrollkey(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->scrollkey);
    update_scrollkey();
}

static void
do_scrollttyoutput(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->scrollttyoutput);
    update_scrollttyoutput();
}

static void
do_keepClipboard(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->keepClipboard);
    update_keepClipboard();
}

static void
do_keepSelection(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->keepSelection);
    update_keepSelection();
}

static void
do_selectClipboard(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->selectToClipboard);
    update_selectToClipboard();
}

static void
do_allow132(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->c132);
    update_allow132();
}

static void
do_cursesemul(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->curses);
    update_cursesemul();
}

static void
do_marginbell(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    if ((ToggleFlag(screen->marginbell)) == 0)
	screen->bellArmed = -1;
    update_marginbell();
}

#if OPT_TEK4014
static void
handle_tekshow(Widget gw GCC_UNUSED, Bool allowswitch)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

    TRACE(("Show tek-window\n"));
    if (!TEK4014_SHOWN(xw)) {	/* not showing, turn on */
	set_tek_visibility(True);
    } else if (screen->Vshow || allowswitch) {	/* is showing, turn off */
	set_tek_visibility(False);
	end_tek_mode();		/* WARNING: this does a longjmp */
    } else
	Bell(xw, XkbBI_MinorError, 0);
}

/* ARGSUSED */
static void
do_tekshow(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    handle_tekshow(gw, True);
}

/* ARGSUSED */
static void
do_tekonoff(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    handle_tekshow(gw, False);
}
#endif /* OPT_TEK4014 */

#if OPT_BLINK_CURS
/* ARGSUSED */
static void
do_cursorblink(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);
    ToggleCursorBlink(screen);
}
#endif

/* ARGSUSED */
static void
do_altscreen(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    ToggleAlternate(term);
}

/* ARGSUSED */
static void
do_titeInhibit(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
{
    ToggleFlag(term->misc.titeInhibit);
    update_titeInhibit();
}

#ifndef NO_ACTIVE_ICON
/* ARGSUSED */
static void
do_activeicon(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    if (screen->iconVwin.window) {
	Widget shell = XtParent(term);
	ToggleFlag(term->work.active_icon);
	XtVaSetValues(shell, XtNiconWindow,
		      term->work.active_icon ? screen->iconVwin.window : None,
		      (XtPointer) 0);
	update_activeicon();
    }
}
#endif /* NO_ACTIVE_ICON */

static void
do_softreset(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    VTReset(term, False, False);
}

static void
do_hardreset(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
{
    VTReset(term, True, False);
}

static void
do_clearsavedlines(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    VTReset(term, True, True);
}

#if OPT_TEK4014
static void
do_tekmode(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    switch_modes(TEK4014_ACTIVE(term));		/* switch to tek mode */
}

/* ARGSUSED */
static void
do_vthide(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    hide_vt_window();
}
#endif /* OPT_TEK4014 */

/*
 * vtfont menu
 */

static void
do_vtfont(Widget gw GCC_UNUSED,
	  XtPointer closure,
	  XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;
    char *entryname = (char *) closure;
    int i;

    TRACE(("do_vtfont(%s)\n", entryname));
    for (i = 0; i < NMENUFONTS; i++) {
	if (strcmp(entryname, fontMenuEntries[i].name) == 0) {
	    SetVTFont(xw, i, True, NULL);
	    return;
	}
    }
    Bell(xw, XkbBI_MinorError, 0);
}

#if OPT_DEC_CHRSET
static void
do_font_doublesize(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;

    if (TScreenOf(xw)->cache_doublesize != 0)
	ToggleFlag(TScreenOf(xw)->font_doublesize);
    update_font_doublesize();
    Redraw();
}
#endif

#if OPT_BOX_CHARS
static void
do_font_boxchars(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
{
    ToggleFlag(TScreenOf(term)->force_box_chars);
    update_font_boxchars();
    Redraw();
}

static void
do_font_packed(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
{
    ToggleFlag(TScreenOf(term)->force_packed);
    update_font_packed();
    SetVTFont(term, TScreenOf(term)->menu_font_number, True, NULL);
}
#endif

#if OPT_DEC_SOFTFONT
static void
do_font_loadable(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
{
    ToggleFlag(term->misc.font_loadable);
    update_font_loadable();
}
#endif

#if OPT_RENDERFONT
static void
do_font_renderfont(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    XtermWidget xw = (XtermWidget) term;
    TScreen *screen = TScreenOf(xw);
    int fontnum = screen->menu_font_number;
    String name = TScreenOf(xw)->MenuFontName(fontnum);

    DefaultRenderFont(xw);
    ToggleFlag(xw->work.render_font);
    update_font_renderfont();
    xtermLoadFont(xw, xtermFontName(name), True, fontnum);
    ScrnRefresh(term, 0, 0,
		MaxRows(screen),
		MaxCols(screen), True);
}
#endif

#if OPT_WIDE_CHARS
static void
setup_wide_fonts(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (screen->wide_chars) {
	if (xtermLoadWideFonts(xw, True)) {
	    SetVTFont(xw, screen->menu_font_number, True, NULL);
	}
    } else {
	ChangeToWide(xw);
    }
}

static void
setup_narrow_fonts(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);

    if (xtermLoadDefaultFonts(xw)) {
	SetVTFont(xw, screen->menu_font_number, True, NULL);
    }
}

static void
do_font_utf8_mode(Widget gw GCC_UNUSED,
		  XtPointer closure GCC_UNUSED,
		  XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

    /*
     * If xterm was started with -wc option, it might not have the wide fonts.
     * If xterm was not started with -wc, it might not have wide cells.
     */
    if (!screen->utf8_mode) {
	setup_wide_fonts(xw);
    }
    switchPtyData(screen, !screen->utf8_mode);
    /*
     * We don't repaint the screen when switching UTF-8 on/off.  When switching
     * on - the Latin-1 codes should paint as-is.  When switching off, that's
     * hard to do properly.
     */
}

static void
do_font_utf8_fonts(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

    ToggleFlag(screen->utf8_fonts);
    update_font_utf8_fonts();

    if (screen->utf8_fonts) {
	setup_wide_fonts(xw);
    } else {
	setup_narrow_fonts(xw);
    }
}

static void
do_font_utf8_title(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->utf8_title);
    update_font_utf8_title();
}
#endif

/*
 * tek menu
 */

#if OPT_TEK4014
static void
do_tektextlarge(Widget gw,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    TekSetFontSize(getTekWidget(gw), True, tekMenu_tektextlarge);
}

static void
do_tektext2(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    TekSetFontSize(getTekWidget(gw), True, tekMenu_tektext2);
}

static void
do_tektext3(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    TekSetFontSize(getTekWidget(gw), True, tekMenu_tektext3);
}

static void
do_tektextsmall(Widget gw,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    TekSetFontSize(getTekWidget(gw), True, tekMenu_tektextsmall);
}

static void
do_tekpage(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    TekSimulatePageButton(getTekWidget(gw), False);
}

static void
do_tekreset(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
{
    TekSimulatePageButton(getTekWidget(gw), True);
}

static void
do_tekcopy(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    TekCopy(getTekWidget(gw));
}

static void
handle_vtshow(Widget gw GCC_UNUSED, Bool allowswitch)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

    TRACE(("Show vt-window\n"));
    if (!screen->Vshow) {	/* not showing, turn on */
	set_vt_visibility(True);
    } else if (TEK4014_SHOWN(xw) || allowswitch) {	/* is showing, turn off */
	set_vt_visibility(False);
	if (!TEK4014_ACTIVE(xw) && tekRefreshList)
	    TekRefresh(tekWidget);
	end_vt_mode();		/* WARNING: this does a longjmp... */
    } else
	Bell(xw, XkbBI_MinorError, 0);
}

static void
do_vtshow(Widget gw,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    handle_vtshow(gw, True);
}

static void
do_vtonoff(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    handle_vtshow(gw, False);
}

static void
do_vtmode(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    switch_modes(TEK4014_ACTIVE(term));		/* switch to vt, or from */
}

/* ARGSUSED */
static void
do_tekhide(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    hide_tek_window();
}
#endif /* OPT_TEK4014 */

/*
 * public handler routines
 */
int
decodeToggle(XtermWidget xw, String *params, Cardinal nparams)
{
    int dir = toggleErr;

    switch (nparams) {
    case 0:
	dir = toggleAll;
	break;
    case 1:
	if (XmuCompareISOLatin1(params[0], "on") == 0)
	    dir = toggleOn;
	else if (XmuCompareISOLatin1(params[0], "off") == 0)
	    dir = toggleOff;
	else if (XmuCompareISOLatin1(params[0], "toggle") == 0)
	    dir = toggleAll;
	break;
    }

    if (dir == toggleErr) {
	Bell(xw, XkbBI_MinorError, 0);
    }

    return dir;
}

static void
handle_toggle(void (*proc) PROTO_XT_CALLBACK_ARGS,
	      int var,
	      String *params,
	      Cardinal nparams,
	      Widget w,
	      XtPointer closure,
	      XtPointer data)
{
    XtermWidget xw = term;

    switch (decodeToggle(xw, params, nparams)) {

    case toggleAll:
	(*proc) (w, closure, data);
	break;

    case toggleOff:
	if (var)
	    (*proc) (w, closure, data);
	else
	    Bell(xw, XkbBI_MinorError, 0);
	break;

    case toggleOn:
	if (!var)
	    (*proc) (w, closure, data);
	else
	    Bell(xw, XkbBI_MinorError, 0);
	break;
    }
    return;
}

#define handle_vt_toggle(proc, var, params, nparams, w) \
	handle_toggle(proc, (int) (var), params, nparams, w, (XtPointer)0, (XtPointer)0)

#define HANDLE_VT_TOGGLE(name) \
	handle_vt_toggle(do_##name, TScreenOf(term)->name, params, *param_count, w)

#define handle_tek_toggle(proc, var, params, nparams, w) \
	handle_toggle(proc, (int) (var), params, nparams, w, (XtPointer)0, (XtPointer)0)

void
HandleAllowSends(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    handle_vt_toggle(do_allowsends, TScreenOf(term)->allowSendEvents,
		     params, *param_count, w);
}

void
HandleSetVisualBell(Widget w,
		    XEvent *event GCC_UNUSED,
		    String *params,
		    Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(visualbell);
}

void
HandleSetPopOnBell(Widget w,
		   XEvent *event GCC_UNUSED,
		   String *params,
		   Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(poponbell);
}

#ifdef ALLOWLOGGING
void
HandleLogging(Widget w,
	      XEvent *event GCC_UNUSED,
	      String *params,
	      Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(logging);
}
#endif

#if OPT_PRINT_ON_EXIT
void
HandleWriteNow(Widget w,
	       XEvent *event GCC_UNUSED,
	       String *params GCC_UNUSED,
	       Cardinal *param_count GCC_UNUSED)
{
    do_write_now(w, 0, 0);
}

void
HandleWriteError(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(write_error);
}
#endif

/* ARGSUSED */
void
HandlePrintScreen(Widget w GCC_UNUSED,
		  XEvent *event GCC_UNUSED,
		  String *params GCC_UNUSED,
		  Cardinal *param_count GCC_UNUSED)
{
    xtermPrintScreen(term, True, getPrinterFlags(term, params, param_count));
}

/* ARGSUSED */
void
HandlePrintEverything(Widget w GCC_UNUSED,
		      XEvent *event GCC_UNUSED,
		      String *params,
		      Cardinal *param_count)
{
    xtermPrintEverything(term, getPrinterFlags(term, params, param_count));
}

/* ARGSUSED */
void
HandlePrintControlMode(Widget w,
		       XEvent *event GCC_UNUSED,
		       String *params GCC_UNUSED,
		       Cardinal *param_count GCC_UNUSED)
{
    do_print_redir(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleRedraw(Widget w,
	     XEvent *event GCC_UNUSED,
	     String *params GCC_UNUSED,
	     Cardinal *param_count GCC_UNUSED)
{
    do_redraw(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleSendSignal(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    /* *INDENT-OFF* */
    static const struct sigtab {
	const char *name;
	int sig;
    } signals[] = {
#ifdef SIGTSTP
	{ "suspend",	SIGTSTP },
	{ "tstp",	SIGTSTP },
#endif
#ifdef SIGCONT
	{ "cont",	SIGCONT },
#endif
	{ "int",	SIGINT },
	{ "hup",	SIGHUP },
	{ "quit",	SIGQUIT },
	{ "alrm",	SIGALRM },
	{ "alarm",	SIGALRM },
	{ "term",	SIGTERM },
	{ "kill",	SIGKILL },
	{ NULL, 0 },
    };
    /* *INDENT-ON* */

    if (*param_count == 1) {
	const struct sigtab *st;

	for (st = signals; st->name; st++) {
	    if (XmuCompareISOLatin1(st->name, params[0]) == 0) {
		handle_send_signal(w, st->sig);
		return;
	    }
	}
	/* one could allow numeric values, but that would be a security hole */
    }

    Bell(term, XkbBI_MinorError, 0);
}

/* ARGSUSED */
void
HandleQuit(Widget w,
	   XEvent *event GCC_UNUSED,
	   String *params GCC_UNUSED,
	   Cardinal *param_count GCC_UNUSED)
{
    do_quit(w, (XtPointer) 0, (XtPointer) 0);
}

void
Handle8BitControl(Widget w,
		  XEvent *event GCC_UNUSED,
		  String *params,
		  Cardinal *param_count)
{
    handle_vt_toggle(do_8bit_control, TScreenOf(term)->control_eight_bits,
		     params, *param_count, w);
}

void
HandleBackarrow(Widget w,
		XEvent *event GCC_UNUSED,
		String *params,
		Cardinal *param_count)
{
    handle_vt_toggle(do_backarrow, term->keyboard.flags & MODE_DECBKM,
		     params, *param_count, w);
}

#if OPT_MAXIMIZE
#if OPT_TEK4014
#define WhichEWMH (TEK4014_ACTIVE(xw) != 0)
#else
#define WhichEWMH 0
#endif
static void
do_fullscreen(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;

    if (resource.fullscreen != esNever)
	FullScreen(xw, !xw->work.ewmh[WhichEWMH].mode);
}

/* ARGSUSED */
void
HandleFullscreen(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params GCC_UNUSED,
		 Cardinal *param_count GCC_UNUSED)
{
    XtermWidget xw = term;

    if (resource.fullscreen != esNever) {
	handle_vt_toggle(do_fullscreen, xw->work.ewmh[WhichEWMH].mode,
			 params, *param_count, w);
    }
}

void
update_fullscreen(void)
{
    XtermWidget xw = term;

    if (resource.fullscreen <= 1) {
	UpdateCheckbox("update_fullscreen",
		       mainMenuEntries,
		       mainMenu_fullscreen,
		       xw->work.ewmh[WhichEWMH].mode);
    } else {
	SetItemSensitivity(mainMenuEntries[mainMenu_fullscreen].widget,
			   False);
    }
}

#endif /* OPT_MAXIMIZE */

#if OPT_SIXEL_GRAPHICS
static void
do_sixelscrolling(Widget gw GCC_UNUSED,
		  XtPointer closure GCC_UNUSED,
		  XtPointer data GCC_UNUSED)
{
    term->keyboard.flags ^= MODE_DECSDM;
    update_decsdm();
}

void
update_decsdm(void)
{
    UpdateCheckbox("update_decsdm",
		   vtMenuEntries,
		   vtMenu_sixelscrolling,
		   (term->keyboard.flags & MODE_DECSDM) != 0);
}

void
HandleSixelScrolling(Widget w,
		     XEvent *event GCC_UNUSED,
		     String *params,
		     Cardinal *param_count)
{
    handle_vt_toggle(do_sixelscrolling, term->keyboard.flags & MODE_DECSDM,
		     params, *param_count, w);
}
#endif

#if OPT_GRAPHICS
static void
do_privatecolorregisters(Widget gw GCC_UNUSED,
			 XtPointer closure GCC_UNUSED,
			 XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    ToggleFlag(screen->privatecolorregisters);
    update_privatecolorregisters();
}

void
update_privatecolorregisters(void)
{
    UpdateCheckbox("update_privatecolorregisters",
		   vtMenuEntries,
		   vtMenu_privatecolorregisters,
		   TScreenOf(term)->privatecolorregisters);
}

void
HandleSetPrivateColorRegisters(Widget w,
			       XEvent *event GCC_UNUSED,
			       String *params,
			       Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(privatecolorregisters);
}
#endif

#if OPT_SUN_FUNC_KEYS
void
HandleSunFunctionKeys(Widget w,
		      XEvent *event GCC_UNUSED,
		      String *params,
		      Cardinal *param_count)
{
    handle_vt_toggle(do_sun_fkeys, term->keyboard.type == keyboardIsSun,
		     params, *param_count, w);
}
#endif

#if OPT_NUM_LOCK
void
HandleNumLock(Widget w,
	      XEvent *event GCC_UNUSED,
	      String *params,
	      Cardinal *param_count)
{
    handle_vt_toggle(do_num_lock, term->misc.real_NumLock,
		     params, *param_count, w);
}

void
HandleAltEsc(Widget w,
	     XEvent *event GCC_UNUSED,
	     String *params,
	     Cardinal *param_count)
{
    handle_vt_toggle(do_alt_esc, !TScreenOf(term)->alt_sends_esc,
		     params, *param_count, w);
}

void
HandleMetaEsc(Widget w,
	      XEvent *event GCC_UNUSED,
	      String *params,
	      Cardinal *param_count)
{
    handle_vt_toggle(do_meta_esc, TScreenOf(term)->meta_sends_esc,
		     params, *param_count, w);
}
#endif

void
HandleDeleteIsDEL(Widget w,
		  XEvent *event GCC_UNUSED,
		  String *params,
		  Cardinal *param_count)
{
    handle_vt_toggle(do_delete_del, TScreenOf(term)->delete_is_del,
		     params, *param_count, w);
}

void
HandleOldFunctionKeys(Widget w,
		      XEvent *event GCC_UNUSED,
		      String *params,
		      Cardinal *param_count)
{
    handle_vt_toggle(do_old_fkeys, term->keyboard.type == keyboardIsLegacy,
		     params, *param_count, w);
}

#if OPT_SUNPC_KBD
void
HandleSunKeyboard(Widget w,
		  XEvent *event GCC_UNUSED,
		  String *params,
		  Cardinal *param_count)
{
    handle_vt_toggle(do_sun_kbd, term->keyboard.type == keyboardIsVT220,
		     params, *param_count, w);
}
#endif

#if OPT_HP_FUNC_KEYS
void
HandleHpFunctionKeys(Widget w,
		     XEvent *event GCC_UNUSED,
		     String *params,
		     Cardinal *param_count)
{
    handle_vt_toggle(do_hp_fkeys, term->keyboard.type == keyboardIsHP,
		     params, *param_count, w);
}
#endif

#if OPT_SCO_FUNC_KEYS
void
HandleScoFunctionKeys(Widget w,
		      XEvent *event GCC_UNUSED,
		      String *params,
		      Cardinal *param_count)
{
    handle_vt_toggle(do_sco_fkeys, term->keyboard.type == keyboardIsSCO,
		     params, *param_count, w);
}
#endif

void
HandleScrollbar(Widget w,
		XEvent *event GCC_UNUSED,
		String *params,
		Cardinal *param_count)
{
    XtermWidget xw = term;

    if (IsIcon(TScreenOf(xw))) {
	Bell(xw, XkbBI_MinorError, 0);
    } else {
	handle_vt_toggle(do_scrollbar, TScreenOf(xw)->fullVwin.sb_info.width,
			 params, *param_count, w);
    }
}

void
HandleJumpscroll(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(jumpscroll);
}

void
HandleKeepClipboard(Widget w,
		    XEvent *event GCC_UNUSED,
		    String *params,
		    Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(keepClipboard);
}

void
HandleKeepSelection(Widget w,
		    XEvent *event GCC_UNUSED,
		    String *params,
		    Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(keepSelection);
}

void
HandleSetSelect(Widget w,
		XEvent *event GCC_UNUSED,
		String *params,
		Cardinal *param_count)
{
    handle_vt_toggle(do_selectClipboard, TScreenOf(term)->selectToClipboard,
		     params, *param_count, w);
}

void
HandleReverseVideo(Widget w,
		   XEvent *event GCC_UNUSED,
		   String *params,
		   Cardinal *param_count)
{
    handle_vt_toggle(do_reversevideo, (term->misc.re_verse0),
		     params, *param_count, w);
}

void
HandleAutoWrap(Widget w,
	       XEvent *event GCC_UNUSED,
	       String *params,
	       Cardinal *param_count)
{
    handle_vt_toggle(do_autowrap, (term->flags & WRAPAROUND),
		     params, *param_count, w);
}

void
HandleReverseWrap(Widget w,
		  XEvent *event GCC_UNUSED,
		  String *params,
		  Cardinal *param_count)
{
    handle_vt_toggle(do_reversewrap, (term->flags & REVERSEWRAP),
		     params, *param_count, w);
}

void
HandleAutoLineFeed(Widget w,
		   XEvent *event GCC_UNUSED,
		   String *params,
		   Cardinal *param_count)
{
    handle_vt_toggle(do_autolinefeed, (term->flags & LINEFEED),
		     params, *param_count, w);
}

void
HandleAppCursor(Widget w,
		XEvent *event GCC_UNUSED,
		String *params,
		Cardinal *param_count)
{
    handle_vt_toggle(do_appcursor, (term->keyboard.flags & MODE_DECCKM),
		     params, *param_count, w);
}

void
HandleAppKeypad(Widget w,
		XEvent *event GCC_UNUSED,
		String *params,
		Cardinal *param_count)
{
    handle_vt_toggle(do_appkeypad, (term->keyboard.flags & MODE_DECKPAM),
		     params, *param_count, w);
}

void
HandleScrollKey(Widget w,
		XEvent *event GCC_UNUSED,
		String *params,
		Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(scrollkey);
}

void
HandleScrollTtyOutput(Widget w,
		      XEvent *event GCC_UNUSED,
		      String *params,
		      Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(scrollttyoutput);
}

void
HandleAllow132(Widget w,
	       XEvent *event GCC_UNUSED,
	       String *params,
	       Cardinal *param_count)
{
    handle_vt_toggle(do_allow132, TScreenOf(term)->c132,
		     params, *param_count, w);
}

void
HandleCursesEmul(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    handle_vt_toggle(do_cursesemul, TScreenOf(term)->curses,
		     params, *param_count, w);
}

void
HandleBellIsUrgent(Widget w,
		   XEvent *event GCC_UNUSED,
		   String *params,
		   Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(bellIsUrgent);
}

void
HandleMarginBell(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(marginbell);
}

#if OPT_BLINK_CURS
void
HandleCursorBlink(Widget w,
		  XEvent *event GCC_UNUSED,
		  String *params,
		  Cardinal *param_count)
{
    /* eventually want to see if sensitive or not */
    handle_vt_toggle(do_cursorblink, TScreenOf(term)->cursor_blink,
		     params, *param_count, w);
}
#endif

void
HandleAltScreen(Widget w,
		XEvent *event GCC_UNUSED,
		String *params,
		Cardinal *param_count)
{
    /* eventually want to see if sensitive or not */
    handle_vt_toggle(do_altscreen, TScreenOf(term)->whichBuf,
		     params, *param_count, w);
}

void
HandleTiteInhibit(Widget w,
		  XEvent *event GCC_UNUSED,
		  String *params,
		  Cardinal *param_count)
{
    /* eventually want to see if sensitive or not */
    handle_vt_toggle(do_titeInhibit, !(term->misc.titeInhibit),
		     params, *param_count, w);
}

/* ARGSUSED */
void
HandleSoftReset(Widget w,
		XEvent *event GCC_UNUSED,
		String *params GCC_UNUSED,
		Cardinal *param_count GCC_UNUSED)
{
    do_softreset(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleHardReset(Widget w,
		XEvent *event GCC_UNUSED,
		String *params GCC_UNUSED,
		Cardinal *param_count GCC_UNUSED)
{
    do_hardreset(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleClearSavedLines(Widget w,
		      XEvent *event GCC_UNUSED,
		      String *params GCC_UNUSED,
		      Cardinal *param_count GCC_UNUSED)
{
    do_clearsavedlines(w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleAllowBoldFonts(Widget w,
		     XEvent *event GCC_UNUSED,
		     String *params,
		     Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(allowBoldFonts);
}

#if OPT_LOAD_VTFONTS
void
update_font_escape(void)
{
    TScreen *screen = TScreenOf(term);

    SetItemSensitivity(fontMenuEntries[fontMenu_fontescape].widget,
		       ((screen->allowFontOps &&
			 screen->EscapeFontName())
			? True : False));
}
#endif

#if OPT_DEC_CHRSET
void
HandleFontDoublesize(Widget w,
		     XEvent *event GCC_UNUSED,
		     String *params,
		     Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(font_doublesize);
}
#endif

#if OPT_BOX_CHARS
void
HandleFontBoxChars(Widget w,
		   XEvent *event GCC_UNUSED,
		   String *params,
		   Cardinal *param_count)
{
    handle_vt_toggle(do_font_boxchars, TScreenOf(term)->force_box_chars,
		     params, *param_count, w);
}

void
HandleFontPacked(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    handle_vt_toggle(do_font_packed, TScreenOf(term)->force_packed,
		     params, *param_count, w);
}
#endif

#if OPT_DEC_SOFTFONT
void
HandleFontLoading(Widget w,
		  XEvent *event GCC_UNUSED,
		  String *params,
		  Cardinal *param_count)
{
    handle_vt_toggle(do_font_loadable, term->misc.font_loadable,
		     params, *param_count, w);
}
#endif

#if OPT_RENDERFONT
static void
update_fontmenu(XtermWidget xw)
{
    TScreen *screen = TScreenOf(xw);
    int n;

    for (n = 0; n <= fontMenu_lastBuiltin; ++n) {
	Boolean active = (Boolean) (xw->work.render_font ||
				    (screen->menu_font_sizes[n] >= 0));
	SetItemSensitivity(fontMenuEntries[n].widget, active);
    }
}

void
HandleRenderFont(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    XtermWidget xw = (XtermWidget) term;

    DefaultRenderFont(xw);

    handle_vt_toggle(do_font_renderfont, xw->work.render_font,
		     params, *param_count, w);

    update_fontmenu(xw);
}
#endif

#if OPT_WIDE_CHARS
void
HandleUTF8Mode(Widget w,
	       XEvent *event GCC_UNUSED,
	       String *params,
	       Cardinal *param_count)
{
    handle_vt_toggle(do_font_utf8_mode, TScreenOf(term)->utf8_mode,
		     params, *param_count, w);
}

void
HandleUTF8Fonts(Widget w,
		XEvent *event GCC_UNUSED,
		String *params,
		Cardinal *param_count)
{
    handle_vt_toggle(do_font_utf8_fonts, TScreenOf(term)->utf8_fonts,
		     params, *param_count, w);
}

void
HandleUTF8Title(Widget w,
		XEvent *event GCC_UNUSED,
		String *params,
		Cardinal *param_count)
{
    handle_vt_toggle(do_font_utf8_title, TScreenOf(term)->utf8_title,
		     params, *param_count, w);
}
#endif

#if OPT_SCREEN_DUMPS
void
HandleDumpHtml(Widget w GCC_UNUSED,
	       XEvent *event GCC_UNUSED,
	       String *params GCC_UNUSED,
	       Cardinal *param_count GCC_UNUSED)
{
    xtermDumpHtml(term);
}

void
HandleDumpSvg(Widget w GCC_UNUSED,
	      XEvent *event GCC_UNUSED,
	      String *params GCC_UNUSED,
	      Cardinal *param_count GCC_UNUSED)
{
    xtermDumpSvg(term);
}
#endif

#if OPT_TEK4014
void
HandleSetTerminalType(Widget w,
		      XEvent *event GCC_UNUSED,
		      String *params,
		      Cardinal *param_count)
{
    XtermWidget xw = term;

    if (*param_count == 1) {
	switch (params[0][0]) {
	case 'v':
	case 'V':
	    if (TEK4014_ACTIVE(xw))
		do_vtmode(w, (XtPointer) 0, (XtPointer) 0);
	    break;
	case 't':
	case 'T':
	    if (!TEK4014_ACTIVE(xw))
		do_tekmode(w, (XtPointer) 0, (XtPointer) 0);
	    break;
	default:
	    Bell(xw, XkbBI_MinorError, 0);
	}
    } else {
	Bell(xw, XkbBI_MinorError, 0);
    }
}

void
HandleVisibility(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    XtermWidget xw = term;

    if (*param_count == 2) {
	switch (params[0][0]) {
	case 'v':
	case 'V':
	    handle_tek_toggle(do_vtonoff, (int) TScreenOf(xw)->Vshow,
			      params + 1, (*param_count) - 1, w);
	    break;
	case 't':
	case 'T':
	    handle_tek_toggle(do_tekonoff, (int) TEK4014_SHOWN(xw),
			      params + 1, (*param_count) - 1, w);
	    break;
	default:
	    Bell(xw, XkbBI_MinorError, 0);
	}
    } else {
	Bell(xw, XkbBI_MinorError, 0);
    }
}

/* ARGSUSED */
void
HandleSetTekText(Widget w,
		 XEvent *event GCC_UNUSED,
		 String *params,
		 Cardinal *param_count)
{
    XtermWidget xw = term;
    void (*proc) PROTO_XT_CALLBACK_ARGS = 0;

    switch (*param_count) {
    case 0:
	proc = do_tektextlarge;
	break;
    case 1:
	switch (TekGetFontSize(params[0])) {
	case TEK_FONT_LARGE:
	    proc = do_tektextlarge;
	    break;
	case TEK_FONT_2:
	    proc = do_tektext2;
	    break;
	case TEK_FONT_3:
	    proc = do_tektext3;
	    break;
	case TEK_FONT_SMALL:
	    proc = do_tektextsmall;
	    break;
	}
	break;
    }
    if (proc)
	(*proc) (w, (XtPointer) 0, (XtPointer) 0);
    else
	Bell(xw, XkbBI_MinorError, 0);
}

/* ARGSUSED */
void
HandleTekPage(Widget w,
	      XEvent *event GCC_UNUSED,
	      String *params GCC_UNUSED,
	      Cardinal *param_count GCC_UNUSED)
{
    do_tekpage(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleTekReset(Widget w,
	       XEvent *event GCC_UNUSED,
	       String *params GCC_UNUSED,
	       Cardinal *param_count GCC_UNUSED)
{
    do_tekreset(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleTekCopy(Widget w,
	      XEvent *event GCC_UNUSED,
	      String *params GCC_UNUSED,
	      Cardinal *param_count GCC_UNUSED)
{
    do_tekcopy(w, (XtPointer) 0, (XtPointer) 0);
}
#endif /* OPT_TEK4014 */

#if OPT_TOOLBAR
/*
 * The normal style of xterm popup menu delays initialization until the menu is
 * first requested.  When using a toolbar, we can use the same initialization,
 * though on the first popup there will be a little geometry layout jitter,
 * since the menu is already managed when this callback is invoked.
 */
static void
InitPopup(Widget gw,
	  XtPointer closure,
	  XtPointer data GCC_UNUSED)
{
    String params[2];
    Cardinal count = 1;

    params[0] = (char *) closure;
    params[1] = 0;
    TRACE(("InitPopup(%s)\n", params[0]));

    domenu(gw, (XEvent *) 0, params, &count);

    XtRemoveCallback(gw, XtNpopupCallback, InitPopup, closure);
}

static Dimension
SetupShell(Widget *menus, MenuList * shell, int n, int m)
{
    char temp[80];
    char *external_name = 0;
    Dimension button_height;
    Dimension button_border;
    String saveLocale = setMenuLocale(True, resource.menuLocale);

    shell[n].w = XtVaCreatePopupShell(menu_names[n].internal_name,
				      simpleMenuWidgetClass,
				      *menus,
				      XtNgeometry, NULL,
				      (XtPointer) 0);

    XtAddCallback(shell[n].w, XtNpopupCallback, InitPopup, menu_names[n].internal_name);
    XtVaGetValues(shell[n].w,
		  XtNlabel, &external_name,
		  (XtPointer) 0);

    TRACE(("...SetupShell(%s) -> %s -> %#lx\n",
	   menu_names[n].internal_name,
	   external_name,
	   (long) shell[n].w));

    sprintf(temp, "%sButton", menu_names[n].internal_name);
    shell[n].b = XtVaCreateManagedWidget(temp,
					 menuButtonWidgetClass,
					 *menus,
					 XtNfromHoriz, ((m >= 0)
							? shell[m].b
							: 0),
					 XtNmenuName, menu_names[n].internal_name,
					 XtNlabel, external_name,
					 (XtPointer) 0);
    XtVaGetValues(shell[n].b,
		  XtNheight, &button_height,
		  XtNborderWidth, &button_border,
		  (XtPointer) 0);

    (void) setMenuLocale(False, saveLocale);
    return (Dimension) (button_height + (button_border * 2));
}
#endif /* OPT_TOOLBAR */

void
SetupMenus(Widget shell, Widget *forms, Widget *menus, Dimension *menu_high)
{
#if OPT_TOOLBAR
    Dimension button_height = 0;
    Dimension toolbar_hSpace;
    Arg args[10];
#endif

    TRACE(("SetupMenus(%s)\n", shell == toplevel ? "vt100" : "tek4014"));

    *menu_high = 0;

    if (shell == toplevel) {
	XawSimpleMenuAddGlobalActions(app_con);
	XtRegisterGrabAction(HandlePopupMenu, True,
			     (unsigned) (ButtonPressMask | ButtonReleaseMask),
			     GrabModeAsync, GrabModeAsync);
    }
#if OPT_TOOLBAR
    *forms = XtVaCreateManagedWidget("form",
				     formWidgetClass, shell,
				     (XtPointer) 0);
    xtermAddInput(*forms);

    /*
     * Set a nominal value for the preferred pane size, which lets the
     * buttons determine the actual height of the menu bar.  We don't show
     * the grip, because it's too easy to make the toolbar look bad that
     * way.
     */
    XtSetArg(args[0], XtNorientation, XtorientHorizontal);
    XtSetArg(args[1], XtNtop, XawChainTop);
    XtSetArg(args[2], XtNbottom, XawChainTop);
    XtSetArg(args[3], XtNleft, XawChainLeft);
    XtSetArg(args[4], XtNright, XawChainLeft);

    if (resource.toolBar) {
	*menus = XtCreateManagedWidget("menubar", boxWidgetClass, *forms,
				       args, 5);
    } else {
	*menus = XtCreateWidget("menubar", boxWidgetClass, *forms, args, 5);
    }

    /*
     * The toolbar widget's height is not necessarily known yet.  If the
     * toolbar is not created as a managed widget, we can still make a good
     * guess about its height by collecting the widget's other resource values.
     */
    XtVaGetValues(*menus,
		  XtNhSpace, &toolbar_hSpace,
		  (XtPointer) 0);

    if (shell == toplevel) {	/* vt100 */
	int j;
	for (j = mainMenu; j <= fontMenu; j++) {
	    button_height = SetupShell(menus, vt_shell, j, j - 1);
	}
    }
#if OPT_TEK4014
    else {			/* tek4014 */
	(void) SetupShell(menus, tek_shell, mainMenu, -1);
	button_height = SetupShell(menus, tek_shell, tekMenu, mainMenu);
    }
#endif

    /*
     * Tell the main program how high the toolbar is, to help with the initial
     * layout.
     */
    *menu_high = (Dimension) (button_height + 2 * (toolbar_hSpace));
    TRACE(("...menuHeight:%d = (%d + 2 * %d)\n",
	   *menu_high, button_height, toolbar_hSpace));

#else /* !OPT_TOOLBAR */
    *forms = shell;
    *menus = shell;
#endif

    TRACE(("...shell=%#lx\n", (long) shell));
    TRACE(("...forms=%#lx\n", (long) *forms));
    TRACE(("...menus=%#lx\n", (long) *menus));
}

void
repairSizeHints(void)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

    if (XtIsRealized((Widget) xw)) {
	getXtermSizeHints(xw);
	xtermSizeHints(xw, ScrollbarWidth(screen));

	XSetWMNormalHints(screen->display, VShellWindow(xw), &xw->hints);
    }
}

#if OPT_TOOLBAR
#define INIT_POPUP(s, n) InitPopup(s[n].w, menu_names[n].internal_name, 0)

static Bool
InitWidgetMenu(Widget shell)
{
    Bool result = False;

    TRACE(("InitWidgetMenu(%p)\n", (void *) shell));
    if (term != 0) {
	if (shell == toplevel) {	/* vt100 */
	    if (!term->init_menu) {
		INIT_POPUP(vt_shell, mainMenu);
		INIT_POPUP(vt_shell, vtMenu);
		INIT_POPUP(vt_shell, fontMenu);
		term->init_menu = True;
		TRACE(("...InitWidgetMenu(vt)\n"));
	    }
	    result = term->init_menu;
	}
#if OPT_TEK4014
	else if (tekWidget) {	/* tek4014 */
	    if (!tekWidget->init_menu) {
		INIT_POPUP(tek_shell, mainMenu);
		INIT_POPUP(tek_shell, tekMenu);
		tekWidget->init_menu = True;
		TRACE(("...InitWidgetMenu(tek)\n"));
	    }
	    result = tekWidget->init_menu;
	}
#endif
    }
    TRACE(("...InitWidgetMenu ->%d\n", result));
    return result;
}

static TbInfo *
toolbar_info(Widget w)
{
    TRACE(("...getting toolbar_info\n"));
#if OPT_TEK4014
    if (w != (Widget) term)
	return &(tekWidget->tek.tb_info);
#else
    (void) w;
#endif
    return &(WhichVWin(TScreenOf(term))->tb_info);
}

static void
hide_toolbar(Widget w)
{
    if (w != 0) {
	TbInfo *info = toolbar_info(w);

	TRACE(("hiding toolbar\n"));
	XtVaSetValues(w,
		      XtNfromVert, (Widget) 0,
		      (XtPointer) 0);

	if (info->menu_bar != 0) {
	    repairSizeHints();
	    XtUnmanageChild(info->menu_bar);
	    if (XtIsRealized(info->menu_bar)) {
		XtUnmapWidget(info->menu_bar);
	    }
	}
	TRACE(("...hiding toolbar (done)\n"));
    }
}

static void
show_toolbar(Widget w)
{
    if (w != 0) {
	TbInfo *info = toolbar_info(w);

	TRACE(("showing toolbar\n"));
	if (info->menu_bar != 0) {
	    XtVaSetValues(w,
			  XtNfromVert, info->menu_bar,
			  (XtPointer) 0);
	    if (XtIsRealized(info->menu_bar))
		repairSizeHints();
	    XtManageChild(info->menu_bar);
	    if (XtIsRealized(info->menu_bar)) {
		XtMapWidget(info->menu_bar);
	    }
	}
	/*
	 * This is needed to make the terminal widget move down below the
	 * toolbar.
	 */
	XawFormDoLayout(XtParent(w), True);
	TRACE(("...showing toolbar (done)\n"));
    }
}

/*
 * Make the toolbar visible or invisible in the current window(s).
 */
void
ShowToolbar(Bool enable)
{
    XtermWidget xw = term;

    TRACE(("ShowToolbar(%d)\n", enable));

    if (IsIcon(TScreenOf(xw))) {
	Bell(xw, XkbBI_MinorError, 0);
    } else {
	if (enable) {
	    if (InitWidgetMenu(toplevel))
		show_toolbar((Widget) xw);
#if OPT_TEK4014
	    if (InitWidgetMenu(tekshellwidget))
		show_toolbar((Widget) tekWidget);
#endif
	} else {
	    hide_toolbar((Widget) xw);
#if OPT_TEK4014
	    hide_toolbar((Widget) tekWidget);
#endif
	}
	resource.toolBar = (Boolean) enable;
	update_toolbar();
    }
}

void
HandleToolbar(Widget w,
	      XEvent *event GCC_UNUSED,
	      String *params GCC_UNUSED,
	      Cardinal *param_count GCC_UNUSED)
{
    XtermWidget xw = term;

    if (IsIcon(TScreenOf(xw))) {
	Bell(xw, XkbBI_MinorError, 0);
    } else {
	handle_vt_toggle(do_toolbar, resource.toolBar,
			 params, *param_count, w);
    }
}

/* ARGSUSED */
static void
do_toolbar(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;

    /*
     * Toggle toolbars for both vt100 and tek windows, since they share the
     * menu which contains the checkbox indicating whether the toolbar is
     * active.
     */
    if (IsIcon(TScreenOf(xw))) {
	Bell(xw, XkbBI_MinorError, 0);
    } else {
	ShowToolbar(ToggleFlag(resource.toolBar));
    }
}

void
update_toolbar(void)
{
    UpdateCheckbox("update_toolbar",
		   mainMenuEntries,
		   mainMenu_toolbar,
		   resource.toolBar);
}
#endif /* OPT_TOOLBAR */

void
update_securekbd(void)
{
    UpdateCheckbox("update_securekbd",
		   mainMenuEntries,
		   mainMenu_securekbd,
		   TScreenOf(term)->grabbedKbd);
}

void
update_allowsends(void)
{
    UpdateCheckbox("update_allowsends",
		   mainMenuEntries,
		   mainMenu_allowsends,
		   TScreenOf(term)->allowSendEvents);
}

#ifdef ALLOWLOGGING
void
update_logging(void)
{
    UpdateCheckbox("update_logging",
		   mainMenuEntries,
		   mainMenu_logging,
		   TScreenOf(term)->logging);
}
#endif

#if OPT_PRINT_ON_EXIT
void
update_write_error(void)
{
    UpdateCheckbox("update_write_error",
		   mainMenuEntries,
		   mainMenu_write_error,
		   TScreenOf(term)->write_error);
}
#endif

void
update_print_redir(void)
{
    UpdateCheckbox("update_print_redir",
		   mainMenuEntries,
		   mainMenu_print_redir,
		   PrinterOf(TScreenOf(term)).printer_controlmode);
}

void
update_8bit_control(void)
{
    UpdateCheckbox("update_8bit_control",
		   mainMenuEntries,
		   mainMenu_8bit_ctrl,
		   TScreenOf(term)->control_eight_bits);
}

void
update_decbkm(void)
{
    UpdateCheckbox("update_decbkm",
		   mainMenuEntries,
		   mainMenu_backarrow,
		   (term->keyboard.flags & MODE_DECBKM) != 0);
}

#if OPT_NUM_LOCK
void
update_num_lock(void)
{
    UpdateCheckbox("update_num_lock",
		   mainMenuEntries,
		   mainMenu_num_lock,
		   term->misc.real_NumLock);
}

void
update_alt_esc(void)
{
    UpdateCheckbox("update_alt_esc",
		   mainMenuEntries,
		   mainMenu_alt_esc,
		   TScreenOf(term)->alt_sends_esc);
}

void
update_meta_esc(void)
{
    UpdateCheckbox("update_meta_esc",
		   mainMenuEntries,
		   mainMenu_meta_esc,
		   TScreenOf(term)->meta_sends_esc);
}
#endif

#if OPT_SUN_FUNC_KEYS
void
update_sun_fkeys(void)
{
    UpdateCheckbox("update_sun_fkeys",
		   mainMenuEntries,
		   mainMenu_sun_fkeys,
		   term->keyboard.type == keyboardIsSun);
}
#endif

#if OPT_TCAP_FKEYS
void
update_tcap_fkeys(void)
{
    UpdateCheckbox("update_tcap_fkeys",
		   mainMenuEntries,
		   mainMenu_tcap_fkeys,
		   term->keyboard.type == keyboardIsTermcap);
}
#endif

void
update_old_fkeys(void)
{
    UpdateCheckbox("update_old_fkeys",
		   mainMenuEntries,
		   mainMenu_old_fkeys,
		   term->keyboard.type == keyboardIsLegacy);
}

void
update_delete_del(void)
{
    UpdateCheckbox("update_delete_del",
		   mainMenuEntries,
		   mainMenu_delete_del,
		   xtermDeleteIsDEL(term));
}

#if OPT_SUNPC_KBD
void
update_sun_kbd(void)
{
    UpdateCheckbox("update_sun_kbd",
		   mainMenuEntries,
		   mainMenu_sun_kbd,
		   term->keyboard.type == keyboardIsVT220);
}
#endif

#if OPT_HP_FUNC_KEYS
void
update_hp_fkeys(void)
{
    UpdateCheckbox("update_hp_fkeys",
		   mainMenuEntries,
		   mainMenu_hp_fkeys,
		   term->keyboard.type == keyboardIsHP);
}
#endif

#if OPT_SCO_FUNC_KEYS
void
update_sco_fkeys(void)
{
    UpdateCheckbox("update_sco_fkeys",
		   mainMenuEntries,
		   mainMenu_sco_fkeys,
		   term->keyboard.type == keyboardIsSCO);
}
#endif

void
update_scrollbar(void)
{
    UpdateCheckbox("update_scrollbar",
		   vtMenuEntries,
		   vtMenu_scrollbar,
		   ScrollbarWidth(TScreenOf(term)));
}

void
update_jumpscroll(void)
{
    UpdateCheckbox("update_jumpscroll",
		   vtMenuEntries,
		   vtMenu_jumpscroll,
		   TScreenOf(term)->jumpscroll);
}

void
update_reversevideo(void)
{
    UpdateCheckbox("update_reversevideo",
		   vtMenuEntries,
		   vtMenu_reversevideo,
		   (term->misc.re_verse));
}

void
update_autowrap(void)
{
    UpdateCheckbox("update_autowrap",
		   vtMenuEntries,
		   vtMenu_autowrap,
		   (term->flags & WRAPAROUND) != 0);
}

void
update_reversewrap(void)
{
    UpdateCheckbox("update_reversewrap",
		   vtMenuEntries,
		   vtMenu_reversewrap,
		   (term->flags & REVERSEWRAP) != 0);
}

void
update_autolinefeed(void)
{
    UpdateCheckbox("update_autolinefeed",
		   vtMenuEntries,
		   vtMenu_autolinefeed,
		   (term->flags & LINEFEED) != 0);
}

void
update_appcursor(void)
{
    UpdateCheckbox("update_appcursor",
		   vtMenuEntries,
		   vtMenu_appcursor,
		   (term->keyboard.flags & MODE_DECCKM) != 0);
}

void
update_appkeypad(void)
{
    UpdateCheckbox("update_appkeypad",
		   vtMenuEntries,
		   vtMenu_appkeypad,
		   (term->keyboard.flags & MODE_DECKPAM) != 0);
}

void
update_scrollkey(void)
{
    UpdateCheckbox("update_scrollkey",
		   vtMenuEntries,
		   vtMenu_scrollkey,
		   TScreenOf(term)->scrollkey);
}

void
update_scrollttyoutput(void)
{
    UpdateCheckbox("update_scrollttyoutput",
		   vtMenuEntries,
		   vtMenu_scrollttyoutput,
		   TScreenOf(term)->scrollttyoutput);
}

void
update_keepSelection(void)
{
    UpdateCheckbox("update_keepSelection",
		   vtMenuEntries,
		   vtMenu_keepSelection,
		   TScreenOf(term)->keepSelection);
}

void
update_selectToClipboard(void)
{
    UpdateCheckbox("update_selectToClipboard",
		   vtMenuEntries,
		   vtMenu_selectToClipboard,
		   TScreenOf(term)->selectToClipboard);
}

void
update_allow132(void)
{
    UpdateCheckbox("update_allow132",
		   vtMenuEntries,
		   vtMenu_allow132,
		   TScreenOf(term)->c132);
}

void
update_cursesemul(void)
{
#if 0				/* 2006-2-12: no longer menu entry */
    UpdateMenuItem("update_cursesemul", vtMenuEntries, vtMenu_cursesemul,
		   TScreenOf(term)->curses);
#endif
}

void
update_visualbell(void)
{
    UpdateCheckbox("update_visualbell",
		   vtMenuEntries,
		   vtMenu_visualbell,
		   TScreenOf(term)->visualbell);
}

void
update_bellIsUrgent(void)
{
    UpdateCheckbox("update_bellIsUrgent",
		   vtMenuEntries,
		   vtMenu_bellIsUrgent,
		   TScreenOf(term)->bellIsUrgent);
}

void
update_poponbell(void)
{
    UpdateCheckbox("update_poponbell",
		   vtMenuEntries,
		   vtMenu_poponbell,
		   TScreenOf(term)->poponbell);
}

#ifndef update_marginbell	/* 2007-3-7: no longer menu entry */
void
update_marginbell(void)
{
    UpdateCheckbox("update_marginbell",
		   vtMenuEntries,
		   vtMenu_marginbell,
		   TScreenOf(term)->marginbell);
}
#endif

#if OPT_BLINK_CURS
void
update_cursorblink(void)
{
    UpdateCheckbox("update_cursorblink",
		   vtMenuEntries,
		   vtMenu_cursorblink,
		   TScreenOf(term)->cursor_blink);
}
#endif

void
update_altscreen(void)
{
    UpdateCheckbox("update_altscreen",
		   vtMenuEntries,
		   vtMenu_altscreen,
		   TScreenOf(term)->whichBuf);
}

void
update_titeInhibit(void)
{
    UpdateCheckbox("update_titeInhibit",
		   vtMenuEntries,
		   vtMenu_titeInhibit,
		   !(term->misc.titeInhibit));
}

#ifndef NO_ACTIVE_ICON
void
update_activeicon(void)
{
    UpdateCheckbox("update_activeicon",
		   vtMenuEntries,
		   vtMenu_activeicon,
		   term->work.active_icon);
}
#endif /* NO_ACTIVE_ICON */

static void
do_allowBoldFonts(Widget w,
		  XtPointer closure GCC_UNUSED,
		  XtPointer data GCC_UNUSED)
{
    XtermWidget xw = getXtermWidget(w);
    if (xw != 0) {
	ToggleFlag(TScreenOf(xw)->allowBoldFonts);
	update_menu_allowBoldFonts();
	Redraw();
    }
}

#if OPT_DEC_CHRSET
void
update_font_doublesize(void)
{
    UpdateCheckbox("update_font_doublesize",
		   fontMenuEntries,
		   fontMenu_font_doublesize,
		   TScreenOf(term)->font_doublesize);
}
#endif

#if OPT_BOX_CHARS
void
update_font_boxchars(void)
{
    UpdateCheckbox("update_font_boxchars",
		   fontMenuEntries,
		   fontMenu_font_boxchars,
		   TScreenOf(term)->force_box_chars);
}

void
update_font_packed(void)
{
    UpdateCheckbox("update_font_packed",
		   fontMenuEntries,
		   fontMenu_font_packedfont,
		   TScreenOf(term)->force_packed);
}
#endif

#if OPT_DEC_SOFTFONT
void
update_font_loadable(void)
{
    UpdateCheckbox("update_font_loadable",
		   fontMenuEntries,
		   fontMenu_font_loadable,
		   term->misc.font_loadable);
}
#endif

#if OPT_RENDERFONT
void
update_font_renderfont(void)
{
    UpdateCheckbox("update_font_renderfont",
		   fontMenuEntries,
		   fontMenu_render_font,
		   (term->work.render_font == True));
    SetItemSensitivity(fontMenuEntries[fontMenu_render_font].widget,
		       !IsEmpty(CurrentXftFont(term)));
    update_fontmenu(term);
}
#endif

#if OPT_WIDE_CHARS
void
update_font_utf8_mode(void)
{
    Bool active = (TScreenOf(term)->utf8_mode != uAlways);
    Bool enable = (TScreenOf(term)->utf8_mode != uFalse);

    TRACE(("update_font_utf8_mode active %d, enable %d\n", active, enable));
    SetItemSensitivity(fontMenuEntries[fontMenu_utf8_mode].widget, active);
    UpdateCheckbox("update_font_utf8_mode",
		   fontMenuEntries,
		   fontMenu_utf8_mode,
		   enable);
}

void
update_font_utf8_fonts(void)
{
    Bool active = (TScreenOf(term)->utf8_fonts != uAlways);
    Bool enable = (TScreenOf(term)->utf8_fonts != uFalse);

    TRACE(("update_font_utf8_fonts active %d, enable %d\n", active, enable));
    SetItemSensitivity(fontMenuEntries[fontMenu_utf8_fonts].widget, active);
    UpdateCheckbox("update_font_utf8_fonts",
		   fontMenuEntries,
		   fontMenu_utf8_fonts,
		   enable);
}

void
update_font_utf8_title(void)
{
    Bool active = (TScreenOf(term)->utf8_mode != uFalse);
    Bool enable = (TScreenOf(term)->utf8_title);

    TRACE(("update_font_utf8_title active %d, enable %d\n", active, enable));
    SetItemSensitivity(fontMenuEntries[fontMenu_utf8_title].widget, active);
    UpdateCheckbox("update_font_utf8_title",
		   fontMenuEntries,
		   fontMenu_utf8_title,
		   enable);
}
#endif

#if OPT_DEC_CHRSET || OPT_BOX_CHARS || OPT_DEC_SOFTFONT
void
update_menu_allowBoldFonts(void)
{
    UpdateCheckbox("update_menu_allowBoldFonts",
		   fontMenuEntries,
		   fontMenu_allowBoldFonts,
		   TScreenOf(term)->allowBoldFonts);
}
#endif

#if OPT_ALLOW_XXX_OPS
static void
enable_allow_xxx_ops(Bool enable)
{
    SetItemSensitivity(fontMenuEntries[fontMenu_allowFontOps].widget, enable);
    SetItemSensitivity(fontMenuEntries[fontMenu_allowMouseOps].widget, enable);
    SetItemSensitivity(fontMenuEntries[fontMenu_allowTcapOps].widget, enable);
    SetItemSensitivity(fontMenuEntries[fontMenu_allowTitleOps].widget, enable);
    SetItemSensitivity(fontMenuEntries[fontMenu_allowWindowOps].widget, enable);
}

static void
do_allowColorOps(Widget w,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
{
    XtermWidget xw = getXtermWidget(w);
    if (xw != 0) {
	ToggleFlag(TScreenOf(xw)->allowColorOps);
	update_menu_allowColorOps();
    }
}

static void
do_allowFontOps(Widget w,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    XtermWidget xw = getXtermWidget(w);
    if (xw != 0) {
	ToggleFlag(TScreenOf(xw)->allowFontOps);
	update_menu_allowFontOps();
    }
}

static void
do_allowMouseOps(Widget w,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
{
    XtermWidget xw = getXtermWidget(w);
    if (xw != 0) {
	ToggleFlag(TScreenOf(xw)->allowMouseOps);
	update_menu_allowMouseOps();
    }
}

static void
do_allowTcapOps(Widget w,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    XtermWidget xw = getXtermWidget(w);
    if (xw != 0) {
	ToggleFlag(TScreenOf(xw)->allowTcapOps);
	update_menu_allowTcapOps();
    }
}

static void
do_allowTitleOps(Widget w,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
{
    XtermWidget xw = getXtermWidget(w);
    if (xw != 0) {
	ToggleFlag(TScreenOf(xw)->allowTitleOps);
	update_menu_allowTitleOps();
    }
}

static void
do_allowWindowOps(Widget w,
		  XtPointer closure GCC_UNUSED,
		  XtPointer data GCC_UNUSED)
{
    XtermWidget xw = getXtermWidget(w);
    if (xw != 0) {
	ToggleFlag(TScreenOf(xw)->allowWindowOps);
	update_menu_allowWindowOps();
    }
}

void
HandleAllowColorOps(Widget w,
		    XEvent *event GCC_UNUSED,
		    String *params,
		    Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(allowColorOps);
}

void
HandleAllowFontOps(Widget w,
		   XEvent *event GCC_UNUSED,
		   String *params,
		   Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(allowFontOps);
}

void
HandleAllowMouseOps(Widget w,
		    XEvent *event GCC_UNUSED,
		    String *params,
		    Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(allowMouseOps);
}

void
HandleAllowTcapOps(Widget w,
		   XEvent *event GCC_UNUSED,
		   String *params,
		   Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(allowTcapOps);
}

void
HandleAllowTitleOps(Widget w,
		    XEvent *event GCC_UNUSED,
		    String *params,
		    Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(allowTitleOps);
}

void
HandleAllowWindowOps(Widget w,
		     XEvent *event GCC_UNUSED,
		     String *params,
		     Cardinal *param_count)
{
    HANDLE_VT_TOGGLE(allowWindowOps);
}

void
update_menu_allowColorOps(void)
{
    UpdateCheckbox("update_menu_allowColorOps",
		   fontMenuEntries,
		   fontMenu_allowColorOps,
		   TScreenOf(term)->allowColorOps);
}

void
update_menu_allowFontOps(void)
{
    UpdateCheckbox("update_menu_allowFontOps",
		   fontMenuEntries,
		   fontMenu_allowFontOps,
		   TScreenOf(term)->allowFontOps);
}

void
update_menu_allowMouseOps(void)
{
    UpdateCheckbox("update_menu_allowMouseOps",
		   fontMenuEntries,
		   fontMenu_allowMouseOps,
		   TScreenOf(term)->allowMouseOps);
}

void
update_menu_allowTcapOps(void)
{
    UpdateCheckbox("update_menu_allowTcapOps",
		   fontMenuEntries,
		   fontMenu_allowTcapOps,
		   TScreenOf(term)->allowTcapOps);
}

void
update_menu_allowTitleOps(void)
{
    UpdateCheckbox("update_menu_allowTitleOps",
		   fontMenuEntries,
		   fontMenu_allowTitleOps,
		   TScreenOf(term)->allowTitleOps);
}

void
update_menu_allowWindowOps(void)
{
    UpdateCheckbox("update_menu_allowWindowOps",
		   fontMenuEntries,
		   fontMenu_allowWindowOps,
		   TScreenOf(term)->allowWindowOps);
}
#endif

#if OPT_TEK4014
void
update_tekshow(void)
{
    if (!(TScreenOf(term)->inhibit & I_TEK)) {
	UpdateCheckbox("update_tekshow",
		       vtMenuEntries,
		       vtMenu_tekshow,
		       TEK4014_SHOWN(term));
    }
}

void
update_vttekmode(void)
{
    XtermWidget xw = term;

    if (!(TScreenOf(xw)->inhibit & I_TEK)) {
	UpdateCheckbox("update_vtmode",
		       vtMenuEntries,
		       vtMenu_tekmode,
		       TEK4014_ACTIVE(xw));
	UpdateCheckbox("update_tekmode",
		       tekMenuEntries,
		       tekMenu_vtmode,
		       !TEK4014_ACTIVE(xw));
	update_fullscreen();
    }
}

void
update_vtshow(void)
{
    if (!(TScreenOf(term)->inhibit & I_TEK)) {
	UpdateCheckbox("update_vtshow",
		       tekMenuEntries,
		       tekMenu_vtshow,
		       TScreenOf(term)->Vshow);
    }
}

void
set_vthide_sensitivity(void)
{
    if (!(TScreenOf(term)->inhibit & I_TEK)) {
	SetItemSensitivity(
			      vtMenuEntries[vtMenu_vthide].widget,
			      TEK4014_SHOWN(term));
    }
}

void
set_tekhide_sensitivity(void)
{
    if (!(TScreenOf(term)->inhibit & I_TEK)) {
	SetItemSensitivity(
			      tekMenuEntries[tekMenu_tekhide].widget,
			      TScreenOf(term)->Vshow);
    }
}

void
set_tekfont_menu_item(int n, int val)
{
    if (!(TScreenOf(term)->inhibit & I_TEK)) {
	UpdateCheckbox("set_tekfont_menu_item", tekMenuEntries, FS2MI(n),
		       (val));
    }
}
#endif /* OPT_TEK4014 */

void
set_menu_font(int val)
{
    UpdateCheckbox("set_menu_font",
		   fontMenuEntries,
		   TScreenOf(term)->menu_font_number,
		   (val));
}
@


1.24
log
@Update to xterm-325. Testing by krw@@, shadchin@@ and naddy@@. Thanks
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.338 2016/05/30 20:58:39 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2015,2016 by Thomas E. Dickey
d199 1
d448 1
d617 1
a617 1
	if (!screen->fnt_icon.fs || !screen->iconVwin.window) {
d872 1
a1044 10
#if 0
    Time ev_time = CurrentTime;

    if ((event->xany.type == KeyPress) ||
	(event->xany.type == KeyRelease))
	ev_time = event->xkey.time;
    else if ((event->xany.type == ButtonPress) ||
	     (event->xany.type == ButtonRelease))
	ev_time = event->xbutton.time;
#endif
d3718 1
a3718 1
		       !IsEmpty(term->misc.face_name));
d3783 1
d3814 12
d3880 9
d3931 9
@


1.23
log
@Update to xterm 322. Tested by shadchin@@ and jsg@@. Thanks.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.332 2015/12/30 09:40:28 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2014,2015 by Thomas E. Dickey
d157 4
d321 4
d787 2
a788 2
#ifdef PRINT_ON_EXIT
	    screen->write_error = !IsEmpty(resource.printOnXError);
d1170 18
d2798 20
@


1.22
log
@Update to xterm 320. Tested by jsg@@ Thanks.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.331 2015/04/10 01:11:52 tom Exp $ */
d160 1
d1475 11
d2434 9
@


1.21
log
@Update to xterm 311. ok shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.327 2014/09/03 23:35:52 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2013,2014 by Thomas E. Dickey
d468 1
a468 1
static MenuHeader menu_names[] = {
d645 1
a645 1
    MenuHeader *data = &menu_names[num];
d981 1
a981 1
    TRACE(("%s(%d): %s\n", func, which, BtoS(val)));
d2121 1
a2121 1
    static struct sigtab {
d2144 1
a2144 1
	struct sigtab *st;
@


1.20
log
@Update to xterm-309. Version 308 tested by several people including
naddy@@ who found a small regression, fixed in 309.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.326 2014/07/12 22:50:28 Steve.Wall Exp $ */
d825 1
a825 4
	    SetItemSensitivity(
				  fontMenuEntries[fontMenu_fontescape].widget,
				  (screen->menu_font_names[fontMenu_fontescape][fNorm]
				   ? True : False));
d872 4
a875 4
	SetItemSensitivity(
			      fontMenuEntries[fontMenu_fontsel].widget,
			      (screen->menu_font_names[fontMenu_fontsel][fNorm]
			       ? True : False));
d2632 13
@


1.19
log
@Update to xterm 304. With help of shadchin@@

tested by ajacoutot@@ and shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.324 2014/05/03 10:53:43 tom Exp $ */
d92 12
d1124 1
a1124 1
			   ? "XTerm"
@


1.18
log
@Update to xterm 296. Sixel graphics disabled for now.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.320 2013/06/23 22:46:18 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2012,2013 by Thomas E. Dickey
d232 4
a236 1
static void do_sixelscrolling  PROTO_XT_CALLBACK_ARGS;
d376 2
d721 2
a722 2
       XEvent * event GCC_UNUSED,
       String * params,		/* mainMenu, vtMenu, or tekMenu */
d858 4
d867 1
d892 2
a893 2
		 XEvent * event,
		 String * params,	/* mainMenu, vtMenu, or tekMenu */
d902 2
a903 2
		XEvent * event,
		String * params,	/* mainMenu, vtMenu, or tekMenu */
d1020 2
a1021 2
	     XEvent * event GCC_UNUSED,		/* unused */
	     String * params GCC_UNUSED,	/* [0] = volume */
d1937 1
a1937 1
decodeToggle(XtermWidget xw, String * params, Cardinal nparams)
d1965 1
a1965 1
	      String * params,
d2007 2
a2008 2
		 XEvent * event GCC_UNUSED,
		 String * params,
d2017 2
a2018 2
		    XEvent * event GCC_UNUSED,
		    String * params,
d2026 2
a2027 2
		   XEvent * event GCC_UNUSED,
		   String * params,
d2036 2
a2037 2
	      XEvent * event GCC_UNUSED,
	      String * params,
d2047 2
a2048 2
	       XEvent * event GCC_UNUSED,
	       String * params GCC_UNUSED,
d2056 2
a2057 2
		 XEvent * event GCC_UNUSED,
		 String * params,
d2067 2
a2068 2
		  XEvent * event GCC_UNUSED,
		  String * params GCC_UNUSED,
d2077 2
a2078 2
		      XEvent * event GCC_UNUSED,
		      String * params,
d2087 2
a2088 2
		       XEvent * event GCC_UNUSED,
		       String * params GCC_UNUSED,
d2097 2
a2098 2
	     XEvent * event GCC_UNUSED,
	     String * params GCC_UNUSED,
d2107 2
a2108 2
		 XEvent * event GCC_UNUSED,
		 String * params,
d2152 2
a2153 2
	   XEvent * event GCC_UNUSED,
	   String * params GCC_UNUSED,
d2161 2
a2162 2
		  XEvent * event GCC_UNUSED,
		  String * params,
d2171 2
a2172 2
		XEvent * event GCC_UNUSED,
		String * params,
d2199 2
a2200 2
		 XEvent * event GCC_UNUSED,
		 String * params GCC_UNUSED,
d2239 21
a2280 9
update_decsdm(void)
{
    UpdateCheckbox("update_decsdm",
		   vtMenuEntries,
		   vtMenu_sixelscrolling,
		   (term->keyboard.flags & MODE_DECSDM) != 0);
}

void
d2282 2
a2283 2
			       XEvent * event GCC_UNUSED,
			       String * params,
a2287 10

void
HandleSixelScrolling(Widget w,
		     XEvent * event GCC_UNUSED,
		     String * params,
		     Cardinal *param_count)
{
    handle_vt_toggle(do_sixelscrolling, term->keyboard.flags & MODE_DECSDM,
		     params, *param_count, w);
}
d2293 2
a2294 2
		      XEvent * event GCC_UNUSED,
		      String * params,
d2305 2
a2306 2
	      XEvent * event GCC_UNUSED,
	      String * params,
d2315 2
a2316 2
	     XEvent * event GCC_UNUSED,
	     String * params,
d2325 2
a2326 2
	      XEvent * event GCC_UNUSED,
	      String * params,
d2336 2
a2337 2
		  XEvent * event GCC_UNUSED,
		  String * params,
d2346 2
a2347 2
		      XEvent * event GCC_UNUSED,
		      String * params,
d2357 2
a2358 2
		  XEvent * event GCC_UNUSED,
		  String * params,
d2369 2
a2370 2
		     XEvent * event GCC_UNUSED,
		     String * params,
d2381 2
a2382 2
		      XEvent * event GCC_UNUSED,
		      String * params,
d2392 2
a2393 2
		XEvent * event GCC_UNUSED,
		String * params,
d2408 2
a2409 2
		 XEvent * event GCC_UNUSED,
		 String * params,
d2417 2
a2418 2
		    XEvent * event GCC_UNUSED,
		    String * params,
d2426 2
a2427 2
		XEvent * event GCC_UNUSED,
		String * params,
d2436 2
a2437 2
		   XEvent * event GCC_UNUSED,
		   String * params,
d2446 2
a2447 2
	       XEvent * event GCC_UNUSED,
	       String * params,
d2456 2
a2457 2
		  XEvent * event GCC_UNUSED,
		  String * params,
d2466 2
a2467 2
		   XEvent * event GCC_UNUSED,
		   String * params,
d2476 2
a2477 2
		XEvent * event GCC_UNUSED,
		String * params,
d2486 2
a2487 2
		XEvent * event GCC_UNUSED,
		String * params,
d2496 2
a2497 2
		XEvent * event GCC_UNUSED,
		String * params,
d2505 2
a2506 2
		      XEvent * event GCC_UNUSED,
		      String * params,
d2514 2
a2515 2
	       XEvent * event GCC_UNUSED,
	       String * params,
d2524 2
a2525 2
		 XEvent * event GCC_UNUSED,
		 String * params,
d2534 2
a2535 2
		   XEvent * event GCC_UNUSED,
		   String * params,
d2543 2
a2544 2
		 XEvent * event GCC_UNUSED,
		 String * params,
d2553 2
a2554 2
		  XEvent * event GCC_UNUSED,
		  String * params,
d2565 2
a2566 2
		XEvent * event GCC_UNUSED,
		String * params,
d2576 2
a2577 2
		  XEvent * event GCC_UNUSED,
		  String * params,
d2588 2
a2589 2
		XEvent * event GCC_UNUSED,
		String * params GCC_UNUSED,
d2598 2
a2599 2
		XEvent * event GCC_UNUSED,
		String * params GCC_UNUSED,
d2608 2
a2609 2
		      XEvent * event GCC_UNUSED,
		      String * params GCC_UNUSED,
d2617 2
a2618 2
		     XEvent * event GCC_UNUSED,
		     String * params,
d2627 2
a2628 2
		     XEvent * event GCC_UNUSED,
		     String * params,
d2638 2
a2639 2
		   XEvent * event GCC_UNUSED,
		   String * params,
d2648 2
a2649 2
		 XEvent * event GCC_UNUSED,
		 String * params,
d2660 2
a2661 2
		  XEvent * event GCC_UNUSED,
		  String * params,
d2685 2
a2686 2
		 XEvent * event GCC_UNUSED,
		 String * params,
d2703 2
a2704 2
	       XEvent * event GCC_UNUSED,
	       String * params,
d2713 2
a2714 2
		XEvent * event GCC_UNUSED,
		String * params,
d2723 2
a2724 2
		XEvent * event GCC_UNUSED,
		String * params,
d2735 2
a2736 2
		      XEvent * event GCC_UNUSED,
		      String * params,
d2763 2
a2764 2
		 XEvent * event GCC_UNUSED,
		 String * params,
d2792 2
a2793 2
		 XEvent * event GCC_UNUSED,
		 String * params,
d2829 2
a2830 2
	      XEvent * event GCC_UNUSED,
	      String * params GCC_UNUSED,
d2839 2
a2840 2
	       XEvent * event GCC_UNUSED,
	       String * params GCC_UNUSED,
d2849 2
a2850 2
	      XEvent * event GCC_UNUSED,
	      String * params GCC_UNUSED,
d2878 1
a2878 2
    if (gw)
	XtRemoveCallback(gw, XtNpopupCallback, InitPopup, closure);
d2927 1
a2927 1
SetupMenus(Widget shell, Widget *forms, Widget *menus, Dimension * menu_high)
d3155 2
a3156 2
	      XEvent * event GCC_UNUSED,
	      String * params GCC_UNUSED,
d3768 2
a3769 2
		    XEvent * event GCC_UNUSED,
		    String * params,
d3777 2
a3778 2
		   XEvent * event GCC_UNUSED,
		   String * params,
d3786 2
a3787 2
		   XEvent * event GCC_UNUSED,
		   String * params,
d3795 2
a3796 2
		    XEvent * event GCC_UNUSED,
		    String * params,
d3804 2
a3805 2
		     XEvent * event GCC_UNUSED,
		     String * params,
@


1.17
log
@Update to xterm 291. Tested by many.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.313 2013/02/03 21:53:58 tom Exp $ */
d231 5
d371 4
d790 1
d795 1
d2218 59
@


1.16
log
@Update to xterm 287. tested by mpi@@ and krw@@.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.310 2012/09/22 14:53:45 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2011,2012 by Thomas E. Dickey
d845 1
a845 1
			      (screen->menu_font_names[fontMenu_fontsel]
d1642 1
@


1.15
log
@Update to xterm 278. Tested by mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.301 2011/12/14 01:21:57 tom Exp $ */
d4 1
a4 1
 * Copyright 1999-2010,2011 by Thomas E. Dickey
a969 39
#if OPT_MAXIMIZE
static void
do_fullscreen(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    XtermWidget xw = term;
    TScreen *screen = TScreenOf(xw);

    if (resource.fullscreen != esNever)
	FullScreen(xw, !screen->fullscreen);
}

/* ARGSUSED */
void
HandleFullscreen(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params GCC_UNUSED,
		 Cardinal *param_count GCC_UNUSED)
{
    do_fullscreen(w, (XtPointer) 0, (XtPointer) 0);
}

void
update_fullscreen(void)
{
    if (resource.fullscreen <= 1) {
	UpdateCheckbox("update_fullscreen",
		       mainMenuEntries,
		       mainMenu_fullscreen,
		       TScreenOf(term)->fullscreen);
    } else {
	SetItemSensitivity(mainMenuEntries[mainMenu_fullscreen].widget,
			   False);
    }
}

#endif /* OPT_MAXIMIZE */

d1577 1
a1577 1
	ToggleFlag(term->misc.active_icon);
d1579 1
a1579 1
		      term->misc.active_icon ? screen->iconVwin.window : None,
d1711 1
a1711 1
    ToggleFlag(xw->misc.render_font);
d1914 2
a1915 9

static void
handle_toggle(void (*proc) PROTO_XT_CALLBACK_ARGS,
	      int var,
	      String * params,
	      Cardinal nparams,
	      Widget w,
	      XtPointer closure,
	      XtPointer data)
d1917 1
a1917 2
    XtermWidget xw = term;
    int dir = -2;
d1921 1
a1921 1
	dir = -1;
d1925 1
a1925 1
	    dir = 1;
d1927 1
a1927 1
	    dir = 0;
d1929 1
a1929 1
	    dir = -1;
d1933 1
a1933 2
    switch (dir) {
    case -2:
d1935 17
a1951 1
	break;
d1953 1
a1953 1
    case -1:
d1957 1
a1957 1
    case 0:
d1964 1
a1964 1
    case 1:
d2157 50
d2594 1
a2594 1
	Boolean active = (Boolean) (xw->misc.render_font ||
d2610 1
a2610 1
    handle_vt_toggle(do_font_renderfont, xw->misc.render_font,
d2860 1
a2860 1
			     (ButtonPressMask | ButtonReleaseMask),
d3486 1
a3486 1
		   term->misc.active_icon);
d3552 1
a3552 1
		   (term->misc.render_font == True));
d3790 3
a3792 1
    if (!(TScreenOf(term)->inhibit & I_TEK)) {
d3796 1
a3796 1
		       TEK4014_ACTIVE(term));
d3800 2
a3801 1
		       !TEK4014_ACTIVE(term));
@


1.14
log
@Update to xterm 276. Tested by ajacoutot@@, krw@@, naddy@@, shadchin@@.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.300 2011/10/09 14:14:23 tom Exp $ */
d2218 1
a2218 1
    handle_vt_toggle(do_alt_esc, !TScreenOf(term)->input_eight_bits,
@


1.13
log
@Update to xterm-275. Tested by jasper@@.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.297 2011/09/11 13:15:18 tom Exp $ */
d2569 13
d2594 2
d3537 1
@


1.12
log
@Update to xterm 271. Tested by shadchin@@ and ajacoutot@@
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.295 2011/07/12 10:45:36 tom Exp $ */
d543 1
d547 1
d660 1
a660 1
		cb[0].closure = (caddr_t) entries[n].name;
d3569 1
d3578 1
@


1.11
log
@Update to xterm 270. Tested by ajacoutot@@, shadchin@@, krw@@ and jasper@@
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.289 2011/04/24 18:18:30 tom Exp $ */
d218 5
d290 4
d525 79
a605 1

d607 1
a607 1
create_menu(Widget w, XtermWidget xtw, MenuIndex num)
d616 1
a616 1
    TScreen *screen = TScreenOf(xtw);
d638 2
a639 2
	    XCreateBitmapFromData(XtDisplay(xtw),
				  RootWindowOfScreen(XtScreen(xtw)),
d650 2
a651 1
	list->entries = nentries;
d653 14
a666 9
	for (; nentries > 0; nentries--, entries++) {
	    cb[0].callback = (XtCallbackProc) entries->function;
	    cb[0].closure = (caddr_t) entries->name;
	    entries->widget = XtCreateManagedWidget(entries->name,
						    (entries->function
						     ? smeBSBObjectClass
						     : smeLineObjectClass),
						    list->w,
						    &arg, (Cardinal) 1);
d750 4
a753 30
#if OPT_NUM_LOCK
	    if (!screen->alt_is_not_meta) {
		SetItemSensitivity(mainMenuEntries[mainMenu_alt_esc].widget,
				   False);
	    }
#endif
	    if (!xtermHasPrinter(xw)) {
		SetItemSensitivity(mainMenuEntries[mainMenu_print].widget,
				   False);
		SetItemSensitivity(mainMenuEntries[mainMenu_print_redir].widget,
				   False);
	    }
	    if (screen->terminal_id < 200) {
		SetItemSensitivity(
				      mainMenuEntries[mainMenu_8bit_ctrl].widget,
				      False);
	    }
#if !defined(SIGTSTP)
	    SetItemSensitivity(
				  mainMenuEntries[mainMenu_suspend].widget, False);
#endif
#if !defined(SIGCONT)
	    SetItemSensitivity(
				  mainMenuEntries[mainMenu_continue].widget, False);
#endif
#ifdef ALLOWLOGGING
	    if (screen->inhibit & I_LOG) {
		SetItemSensitivity(
				      mainMenuEntries[mainMenu_logging].widget, False);
	    }
a754 6
	    if (screen->inhibit & I_SIGNAL) {
		int n;
		for (n = (int) mainMenu_suspend; n <= (int) mainMenu_quit; ++n) {
		    SetItemSensitivity(mainMenuEntries[n].widget, False);
		}
	    }
d781 1
a781 6
	    if (!screen->fnt_icon.fs || !screen->iconVwin.window) {
		SetItemSensitivity(
				      vtMenuEntries[vtMenu_activeicon].widget,
				      False);
	    } else
		update_activeicon();
a782 8
#if OPT_TEK4014
	    if (screen->inhibit & I_TEK) {
		int n;
		for (n = (int) vtMenu_tekshow; n <= (int) vtMenu_vthide; ++n) {
		    SetItemSensitivity(vtMenuEntries[n].widget, False);
		}
	    }
#endif
d885 3
d891 17
a907 1
	XtCallActionProc(w, "XawPositionSimpleMenu", event, params, 1);
d1118 31
d1162 4
a1165 1
    setPrinterControlMode(term, TScreenOf(term)->printer_controlmode ? 0 : 2);
d2052 20
d3111 11
d3128 1
a3128 1
		   TScreenOf(term)->printer_controlmode);
@


1.10
log
@Update to xterm version 269.
Tested and ok ajacoutot@@, jasper@@, krw@@, shadchin@@
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.284 2011/02/17 00:46:18 tom Exp $ */
d133 1
d148 1
a161 1
static void do_keepSelection   PROTO_XT_CALLBACK_ARGS;
d264 1
d374 1
d394 1
d740 2
d743 4
d751 1
d780 1
d1658 24
d1686 2
a1687 1
    TScreen *screen = TScreenOf(term);
d1694 1
a1694 7
	if (screen->wide_chars) {
	    if (xtermLoadWideFonts(term, True)) {
		SetVTFont(term, screen->menu_font_number, True, NULL);
	    }
	} else {
	    ChangeToWide(term);
	}
d1705 18
d2391 9
d2473 10
d3323 13
d3399 1
a3399 1
    SetItemSensitivity(fontMenuEntries[fontMenu_wide_chars].widget, active);
d3402 15
a3416 1
		   fontMenu_wide_chars,
d3427 1
a3427 1
    SetItemSensitivity(fontMenuEntries[fontMenu_wide_title].widget, active);
d3430 1
a3430 1
		   fontMenu_wide_title,
d3434 9
@


1.9
log
@Update to xterm 261. Tested by krw@@, jcs@@.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.267 2010/06/20 21:09:10 tom Exp $ */
d4 1
a4 2
 *
 * Copyright 1999-2009,2010 by Thomas E. Dickey
d32 1
a53 1
 *
d123 6
d207 4
d273 3
d641 1
d851 34
d889 39
d1418 1
a1418 1
    if (!(ToggleFlag(screen->marginbell)))
a2549 40
static void
UpdateMenuItem(
#if OPT_TRACE
		  const char *func,
#endif
		  MenuEntry * menu,
		  int which,
		  Bool val)
{
    static Arg menuArgs =
    {XtNleftBitmap, (XtArgVal) 0};
    Widget mi = menu[which].widget;

    if (mi) {
	menuArgs.value = (XtArgVal) ((val)
				     ? TScreenOf(term)->menu_item_bitmap
				     : None);
	XtSetValues(mi, &menuArgs, (Cardinal) 1);
    }
    TRACE(("%s(%d): %s\n", func, which, BtoS(val)));
}

#if OPT_TRACE
#define UpdateCheckbox(func, mn, mi, val) UpdateMenuItem(func, mn, mi, val)
#else
#define UpdateCheckbox(func, mn, mi, val) UpdateMenuItem(mn, mi, val)
#endif

void
SetItemSensitivity(Widget mi, Bool val)
{
    static Arg menuArgs =
    {XtNsensitive, (XtArgVal) 0};

    if (mi) {
	menuArgs.value = (XtArgVal) (val);
	XtSetValues(mi, &menuArgs, (Cardinal) 1);
    }
}

d2707 2
a2708 1
    TScreen *screen = TScreenOf(term);
d2710 3
a2712 3
    if (XtIsRealized((Widget) term)) {
	getXtermSizeHints(term);
	xtermSizeHints(term, ScrollbarWidth(screen));
d2714 1
a2714 1
	XSetWMNormalHints(screen->display, XtWindow(SHELL_OF(term)), &term->hints);
@


1.8
log
@Update to xterm 258. lightly tested by krw@@, thanks.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.262 2010/04/17 15:52:49 tom Exp $ */
d600 2
a601 1
    TScreen *screen = TScreenOf(term);
d607 1
a607 1
	Bell(XkbBI_MinorError, 0);
d612 1
a612 1
	Bell(XkbBI_MinorError, 0);
d618 1
a618 1
	mw = create_menu(w, term, me);
d646 1
a646 1
	    if (!xtermHasPrinter(term)) {
d746 1
a746 1
	    if (TScreenOf(term)->cache_doublesize == 0)
d767 1
a767 1
	FindFontSelection(term, NULL, True);
d847 2
a848 1
    TScreen *screen = TScreenOf(term);
d853 1
a853 1
	ReverseVideo(term);
d859 1
a859 1
	    Bell(XkbBI_MinorError, 100);
d861 1
a861 1
	    ReverseVideo(term);
d941 2
a942 1
    TScreen *screen = TScreenOf(term);
d945 1
a945 1
	CloseLog(screen);
d947 1
a947 1
	StartLog(screen);
d1341 2
a1342 1
    TScreen *screen = TScreenOf(term);
d1345 1
a1345 1
    if (!TEK4014_SHOWN(term)) {	/* not showing, turn on */
d1351 1
a1351 1
	Bell(XkbBI_MinorError, 0);
d1476 1
d1482 1
a1482 1
	    SetVTFont(term, i, True, NULL);
d1486 1
a1486 1
    Bell(XkbBI_MinorError, 0);
d1495 4
a1498 2
    if (TScreenOf(term)->cache_doublesize != 0)
	ToggleFlag(TScreenOf(term)->font_doublesize);
d1543 2
a1544 1
    TScreen *screen = TScreenOf(term);
d1546 1
a1546 1
    String name = TScreenOf(term)->MenuFontName(fontnum);
d1548 2
a1549 1
    ToggleFlag(term->misc.render_font);
d1551 1
a1551 1
    xtermLoadFont(term, xtermFontName(name), True, fontnum);
d1663 2
a1664 1
    TScreen *screen = TScreenOf(term);
d1669 1
a1669 1
    } else if (TEK4014_SHOWN(term) || allowswitch) {	/* is showing, turn off */
d1671 1
a1671 1
	if (!TEK4014_ACTIVE(term) && tekRefreshList)
d1675 1
a1675 1
	Bell(XkbBI_MinorError, 0);
d1725 1
d1744 1
a1744 1
	Bell(XkbBI_MinorError, 0);
d1755 1
a1755 1
	    Bell(XkbBI_MinorError, 0);
d1762 1
a1762 1
	    Bell(XkbBI_MinorError, 0);
d1898 1
a1898 1
    Bell(XkbBI_MinorError, 0);
d2037 4
a2040 2
    if (IsIcon(TScreenOf(term))) {
	Bell(XkbBI_MinorError, 0);
d2042 1
a2042 1
	handle_vt_toggle(do_scrollbar, TScreenOf(term)->fullVwin.sb_info.width,
d2308 5
a2312 1
    handle_vt_toggle(do_font_renderfont, term->misc.render_font,
d2346 2
d2352 1
a2352 1
	    if (TEK4014_ACTIVE(term))
d2357 1
a2357 1
	    if (!TEK4014_ACTIVE(term))
d2361 1
a2361 1
	    Bell(XkbBI_MinorError, 0);
d2364 1
a2364 1
	Bell(XkbBI_MinorError, 0);
d2374 2
d2380 1
a2380 1
	    handle_tek_toggle(do_vtonoff, (int) TScreenOf(term)->Vshow,
d2385 1
a2385 1
	    handle_tek_toggle(do_tekonoff, (int) TEK4014_SHOWN(term),
d2389 1
a2389 1
	    Bell(XkbBI_MinorError, 0);
d2392 1
a2392 1
	Bell(XkbBI_MinorError, 0);
d2403 1
d2430 1
a2430 1
	Bell(XkbBI_MinorError, 0);
d2635 1
a2635 1
	button_height = SetupShell(menus, tek_shell, mainMenu, -1);
d2775 2
d2779 2
a2780 2
    if (IsIcon(TScreenOf(term))) {
	Bell(XkbBI_MinorError, 0);
d2784 1
a2784 1
		show_toolbar((Widget) term);
d2790 1
a2790 1
	    hide_toolbar((Widget) term);
d2806 4
a2809 2
    if (IsIcon(TScreenOf(term))) {
	Bell(XkbBI_MinorError, 0);
d2822 2
d2829 2
a2830 2
    if (IsIcon(TScreenOf(term))) {
	Bell(XkbBI_MinorError, 0);
d3257 1
a3257 1
		   term->misc.render_font);
@


1.7
log
@Update to xterm-255. Tested by stsp@@, oga@@.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.261 2010/01/04 22:16:06 tom Exp $ */
d447 1
a447 1
    String result;
a448 1
    result = setlocale(LC_CTYPE, substitute);
d451 9
a459 2
    } else {
	result = 0;
@


1.6
log
@Update to xterm 250
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.254 2009/10/11 22:46:44 tom Exp $ */
d4 52
a55 45

Copyright 1999-2008,2009 by Thomas E. Dickey

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

Copyright 1989  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/
a145 1
static void do_print_everything PROTO_XT_CALLBACK_ARGS;
d174 2
a176 1
static void do_allowFontOps    PROTO_XT_CALLBACK_ARGS;
d385 2
a387 1
    { "allow-font-ops",	do_allowFontOps,NULL },
d507 1
a507 1
    TScreen *screen = &xtw->screen;
d739 1
a739 1
	    if (term->screen.cache_doublesize == 0)
a745 5
	    if (term->misc.face_name == 0) {
		SetItemSensitivity(
				      fontMenuEntries[fontMenu_render_font].widget,
				      False);
	    }
d752 2
a754 1
	    update_menu_allowFontOps();
d770 1
a770 1
	    set_tekfont_menu_item(tekWidget->screen.cur.fontsize, True);
d949 1
a949 9
    xtermPrintScreen(term, True);
}

static void
do_print_everything(Widget gw GCC_UNUSED,
		    XtPointer closure GCC_UNUSED,
		    XtPointer data GCC_UNUSED)
{
    xtermPrintEverything(term);
d957 1
a957 1
    setPrinterControlMode(term, term->screen.printer_controlmode ? 0 : 2);
d971 2
a972 2
    if (term->screen.control_eight_bits != value) {
	term->screen.control_eight_bits = (Boolean) value;
d982 1
a982 1
    show_8bit_control(!term->screen.control_eight_bits);
d1009 1
a1009 1
    ToggleFlag(term->screen.alt_sends_esc);
d1018 1
a1018 1
    ToggleFlag(term->screen.meta_sends_esc);
d1029 1
a1029 1
	term->screen.delete_is_del = False;
d1031 1
a1031 1
	term->screen.delete_is_del = True;
d1324 1
a1324 1
	screen->bellarmed = -1;
d1484 2
a1485 2
    if (term->screen.cache_doublesize != 0)
	ToggleFlag(term->screen.font_doublesize);
d1497 1
a1497 1
    ToggleFlag(term->screen.force_box_chars);
d1507 1
a1507 1
    ToggleFlag(term->screen.force_packed);
d1509 1
a1509 1
    SetVTFont(term, term->screen.menu_font_number, True, NULL);
d1532 1
a1532 1
    String name = term->screen.MenuFontName(fontnum);
d1754 3
d1766 1
a1766 1
    handle_vt_toggle(do_allowsends, term->screen.allowSendEvents,
d1776 1
a1776 2
    handle_vt_toggle(do_visualbell, term->screen.visualbell,
		     params, *param_count, w);
d1785 1
a1785 2
    handle_vt_toggle(do_poponbell, term->screen.poponbell,
		     params, *param_count, w);
d1795 1
a1795 2
    handle_vt_toggle(do_logging, term->screen.logging,
		     params, *param_count, w);
d1801 1
a1801 1
HandlePrintScreen(Widget w,
d1806 1
a1806 1
    do_print(w, (XtPointer) 0, (XtPointer) 0);
d1811 1
a1811 1
HandlePrintEverything(Widget w,
d1813 2
a1814 2
		      String * params GCC_UNUSED,
		      Cardinal *param_count GCC_UNUSED)
d1816 1
a1816 1
    do_print_everything(w, (XtPointer) 0, (XtPointer) 0);
d1900 1
a1900 1
    handle_vt_toggle(do_8bit_control, term->screen.control_eight_bits,
d1943 1
a1943 1
    handle_vt_toggle(do_alt_esc, !term->screen.input_eight_bits,
d1953 1
a1953 1
    handle_vt_toggle(do_meta_esc, term->screen.meta_sends_esc,
d1964 1
a1964 1
    handle_vt_toggle(do_delete_del, term->screen.delete_is_del,
d2020 1
a2020 1
    if (IsIcon(&(term->screen))) {
d2023 1
a2023 1
	handle_vt_toggle(do_scrollbar, term->screen.fullVwin.sb_info.width,
d2034 1
a2034 2
    handle_vt_toggle(do_jumpscroll, term->screen.jumpscroll,
		     params, *param_count, w);
d2043 1
a2043 2
    handle_vt_toggle(do_keepSelection, term->screen.keepSelection,
		     params, *param_count, w);
d2052 1
a2052 1
    handle_vt_toggle(do_selectClipboard, term->screen.selectToClipboard,
d2122 1
a2122 2
    handle_vt_toggle(do_scrollkey, term->screen.scrollkey,
		     params, *param_count, w);
d2131 1
a2131 2
    handle_vt_toggle(do_scrollttyoutput, term->screen.scrollttyoutput,
		     params, *param_count, w);
d2140 1
a2140 1
    handle_vt_toggle(do_allow132, term->screen.c132,
d2150 1
a2150 1
    handle_vt_toggle(do_cursesemul, term->screen.curses,
d2160 1
a2160 2
    handle_vt_toggle(do_bellIsUrgent, term->screen.bellIsUrgent,
		     params, *param_count, w);
d2169 1
a2169 2
    handle_vt_toggle(do_marginbell, term->screen.marginbell,
		     params, *param_count, w);
d2180 1
a2180 1
    handle_vt_toggle(do_cursorblink, term->screen.cursor_blink,
d2192 1
a2192 1
    handle_vt_toggle(do_altscreen, term->screen.whichBuf,
d2244 1
a2244 2
    handle_vt_toggle(do_font_doublesize, term->screen.font_doublesize,
		     params, *param_count, w);
d2255 1
a2255 1
    handle_vt_toggle(do_font_boxchars, term->screen.force_box_chars,
d2265 1
a2265 1
    handle_vt_toggle(do_font_packed, term->screen.force_packed,
d2301 1
a2301 1
    handle_vt_toggle(do_font_utf8_mode, term->screen.utf8_mode,
d2311 1
a2311 1
    handle_vt_toggle(do_font_utf8_title, term->screen.utf8_title,
d2353 1
a2353 1
	    handle_tek_toggle(do_vtonoff, (int) term->screen.Vshow,
d2451 1
a2451 1
				     ? term->screen.menu_item_bitmap
d2651 1
a2651 1
    TRACE(("InitWidgetMenu(%p)\n", shell));
d2689 1
a2689 1
    return &(WhichVWin(&(term->screen))->tb_info);
d2749 1
a2749 1
    if (IsIcon(&(term->screen))) {
d2776 1
a2776 1
    if (IsIcon(&(term->screen))) {
d2795 1
a2795 1
    if (IsIcon(&(term->screen))) {
d2818 1
a2818 1
		   term->screen.grabbedKbd);
d2827 1
a2827 1
		   term->screen.allowSendEvents);
d2837 1
a2837 1
		   term->screen.logging);
d2847 1
a2847 1
		   term->screen.printer_controlmode);
d2856 1
a2856 1
		   term->screen.control_eight_bits);
d2884 1
a2884 1
		   term->screen.alt_sends_esc);
d2893 1
a2893 1
		   term->screen.meta_sends_esc);
d2985 1
a2985 1
		   term->screen.jumpscroll);
d3048 1
a3048 1
		   term->screen.scrollkey);
d3057 1
a3057 1
		   term->screen.scrollttyoutput);
d3066 1
a3066 1
		   term->screen.keepSelection);
d3075 1
a3075 1
		   term->screen.selectToClipboard);
d3084 1
a3084 1
		   term->screen.c132);
d3092 1
a3092 1
		   term->screen.curses);
d3102 1
a3102 1
		   term->screen.visualbell);
d3111 1
a3111 1
		   term->screen.bellIsUrgent);
d3120 1
a3120 1
		   term->screen.poponbell);
d3130 1
a3130 1
		   term->screen.marginbell);
d3141 1
a3141 1
		   term->screen.cursor_blink);
d3151 1
a3151 1
		   term->screen.whichBuf);
d3181 1
a3181 1
		   term->screen.font_doublesize);
d3192 1
a3192 1
		   term->screen.force_box_chars);
d3201 1
a3201 1
		   term->screen.force_packed);
d3224 2
d3233 2
a3234 2
    Bool active = (term->screen.utf8_mode != uAlways);
    Bool enable = (term->screen.utf8_mode != uFalse);
d3247 2
a3248 2
    Bool active = (term->screen.utf8_mode != uFalse);
    Bool enable = (term->screen.utf8_title);
d3270 12
d3288 1
a3288 1
	ToggleFlag(xw->screen.allowFontOps);
d3300 1
a3300 1
	ToggleFlag(xw->screen.allowTcapOps);
d3312 1
a3312 1
	ToggleFlag(xw->screen.allowTitleOps);
d3324 1
a3324 1
	ToggleFlag(xw->screen.allowWindowOps);
d3330 9
d3344 1
a3344 2
    handle_vt_toggle(do_allowFontOps, term->screen.allowFontOps,
		     params, *param_count, w);
d3353 1
a3353 2
    handle_vt_toggle(do_allowTcapOps, term->screen.allowTcapOps,
		     params, *param_count, w);
d3362 1
a3362 2
    handle_vt_toggle(do_allowTitleOps, term->screen.allowTitleOps,
		     params, *param_count, w);
d3371 1
a3371 2
    handle_vt_toggle(do_allowWindowOps, term->screen.allowWindowOps,
		     params, *param_count, w);
d3375 1
a3375 1
update_menu_allowTcapOps(void)
d3377 1
a3377 1
    UpdateCheckbox("update_menu_allowTcapOps",
d3379 2
a3380 2
		   fontMenu_allowTcapOps,
		   term->screen.allowTcapOps);
d3389 10
a3398 1
		   term->screen.allowFontOps);
d3407 1
a3407 1
		   term->screen.allowTitleOps);
d3416 1
a3416 1
		   term->screen.allowWindowOps);
d3424 1
a3424 1
    if (!(term->screen.inhibit & I_TEK)) {
d3435 1
a3435 1
    if (!(term->screen.inhibit & I_TEK)) {
d3450 1
a3450 1
    if (!(term->screen.inhibit & I_TEK)) {
d3454 1
a3454 1
		       term->screen.Vshow);
d3461 1
a3461 1
    if (!(term->screen.inhibit & I_TEK)) {
d3471 1
a3471 1
    if (!(term->screen.inhibit & I_TEK)) {
d3474 1
a3474 1
			      term->screen.Vshow);
d3481 1
a3481 1
    if (!(term->screen.inhibit & I_TEK)) {
d3493 1
a3493 1
		   term->screen.menu_font_number,
@


1.5
log
@update to xterm 246. Has been in snapshots for some time.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.252 2009/07/03 15:01:14 tom Exp $ */
d180 1
d355 1
d718 4
d1505 10
d1852 1
a1852 1
	char *name;
d2269 10
d3204 9
@


1.4
log
@Update to xterm 243. tested by naddy@@.

Patch #243 - 2009/3/28

* revert change to default for allowTcapOps (request by Bram Moolenaar).
* reallocate result returned by xtermEnvLocale() to avoid reference to
freed memory after handling menuLocale resource.
* fix an old (X11R5) bug in tek4014 for switching fontsizes.
* add resource defaultString to make configurable the use of "#" when
pastes of UTF-8 text fail due to limitations in the current locale settings.
* make the set of selection target Atom's configurable by two new
resources eightBitSelectTypes and utf8SelectTypes, e.g., to use the TEXT
Atom in preference to UTF8_STRING (discussion with Stanislav Sedov
regarding koi8rxterm and the FreeBSD port).
* modify handling of TARGETS Atom by making it return exactly the set of
targets as those which xterm is currently providing.
* set MANPAGER and PAGER explicitly to /bin/cat in minstall.sh to work
around /etc/man.conf's with those variables already set (report by
Mar'yasin Semion).
* improve error-checking of tcap-query parser.
* add check for keyboard tcap), which ensures that terminal descriptions
containing the same string for shifted/unshifted keys will be seen by
tcap-query as only the unshifted key. (This would only happen with an
incorrect terminal description).
* fix conversion for input event-state to modifier-parameter which made
tcap-query feature not work with tcapFunctionKeys (keyboard type tcap).
* add "DEF_ALLOW_XXX" definitions to main.h to allow overriding the
default compiled-in values for "allowxxx" resources.
* remove check on bell-percentage added in patch #242, which disallowed
zero/negative values (Redhat Bugzilla #487829).
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.248 2009/03/28 17:27:57 tom Exp $ */
d139 1
d629 1
a629 1
	    if (!xtermHasPrinter()) {
d939 9
a947 1
    xtermPrintScreen(True);
d955 1
a955 1
    setPrinterControlMode(term->screen.printer_controlmode ? 0 : 2);
d1582 1
a1582 1
    TekSetFontSize(getTekWidget(gw), tekMenu_tektextlarge);
d1590 1
a1590 1
    TekSetFontSize(getTekWidget(gw), tekMenu_tektext2);
d1598 1
a1598 1
    TekSetFontSize(getTekWidget(gw), tekMenu_tektext3);
d1606 1
a1606 1
    TekSetFontSize(getTekWidget(gw), tekMenu_tektextsmall);
d1799 10
d2186 1
a2186 1
    handle_vt_toggle(do_altscreen, term->screen.alternate,
d3136 1
a3136 1
		   term->screen.alternate);
@


1.3
log
@Update to xterm 242. Tested by jsg@@.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.246 2009/02/13 19:56:04 tom Exp $ */
d1569 1
a1569 1
do_tektextlarge(Widget gw GCC_UNUSED,
d1573 1
a1573 1
    TekSetFontSize(tekWidget, tekMenu_tektextlarge);
d1577 1
a1577 1
do_tektext2(Widget gw GCC_UNUSED,
d1581 1
a1581 1
    TekSetFontSize(tekWidget, tekMenu_tektext2);
d1585 1
a1585 1
do_tektext3(Widget gw GCC_UNUSED,
d1589 1
a1589 1
    TekSetFontSize(tekWidget, tekMenu_tektext3);
d1593 1
a1593 1
do_tektextsmall(Widget gw GCC_UNUSED,
d1597 1
a1597 1
    TekSetFontSize(tekWidget, tekMenu_tektextsmall);
d1601 1
a1601 1
do_tekpage(Widget gw GCC_UNUSED,
d1605 1
a1605 1
    TekSimulatePageButton(tekWidget, False);
d1609 1
a1609 1
do_tekreset(Widget gw GCC_UNUSED,
d1613 1
a1613 1
    TekSimulatePageButton(tekWidget, True);
d1617 1
a1617 1
do_tekcopy(Widget gw GCC_UNUSED,
d1621 1
a1621 1
    TekCopy(tekWidget);
d2507 1
a2507 1
    (void) setMenuLocale(True, saveLocale);
@


1.2
log
@xterm-236. Tested by form@@ and simon@@.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.241 2008/06/03 20:05:49 tom Exp $ */
d5 1
a5 1
Copyright 1999-2007,2008 by Thomas E. Dickey
d116 2
d165 8
d373 8
d500 1
a500 1
    int nentries = data->entry_len;
d741 7
d876 1
a876 1
    screen->allowSendEvents = !screen->allowSendEvents;
d878 3
d890 1
a890 1
    screen->visualbell = !screen->visualbell;
d901 1
a901 1
    screen->bellIsUrgent = !screen->bellIsUrgent;
d912 1
a912 1
    screen->poponbell = !screen->poponbell;
d961 1
a961 1
	term->screen.control_eight_bits = value;
d989 1
a989 1
    term->misc.real_NumLock = !term->misc.real_NumLock;
d998 1
a998 1
    term->screen.alt_sends_esc = !term->screen.alt_sends_esc;
d1007 1
a1007 1
    term->screen.meta_sends_esc = !term->screen.meta_sends_esc;
d1246 1
a1246 1
    screen->scrollkey = !screen->scrollkey;
d1257 1
a1257 1
    screen->scrollttyoutput = !screen->scrollttyoutput;
d1268 1
a1268 1
    screen->keepSelection = !screen->keepSelection;
d1279 1
a1279 1
    screen->selectToClipboard = !screen->selectToClipboard;
d1290 1
a1290 1
    screen->c132 = !screen->c132;
d1301 1
a1301 1
    screen->curses = !screen->curses;
d1312 1
a1312 1
    if (!(screen->marginbell = !screen->marginbell))
d1379 1
a1379 1
    term->misc.titeInhibit = !term->misc.titeInhibit;
d1394 1
a1394 1
	term->misc.active_icon = !term->misc.active_icon;
d1474 1
a1474 1
	term->screen.font_doublesize = !term->screen.font_doublesize;
d1486 1
a1486 1
    term->screen.force_box_chars = !term->screen.force_box_chars;
d1498 1
a1498 1
    term->misc.font_loadable = !term->misc.font_loadable;
d1513 1
a1513 1
    term->misc.render_font = !term->misc.render_font;
d1558 1
a1558 1
    screen->utf8_title = !screen->utf8_title;
d2409 1
a2409 1
		  XtArgVal val)
d2431 1
a2431 1
SetItemSensitivity(Widget mi, XtArgVal val)
d2508 1
a2508 1
    return button_height + (button_border * 2);
d2582 1
a2582 1
    *menu_high = (button_height + 2 * (toolbar_hSpace));
d2731 1
a2731 1
	resource.toolBar = enable;
d2764 1
a2764 1
	ShowToolbar(resource.toolBar = !resource.toolBar);
d3211 135
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.217 2006/07/23 20:13:22 tom Exp $ */
d5 1
a5 1
Copyright 1999-2005,2006 by Thomas E. Dickey
a48 1
/* $XFree86: xc/programs/xterm/menu.c,v 3.68 2006/04/10 00:34:36 dickey Exp $ */
d54 3
d126 1
a133 1
static void do_marginbell      PROTO_XT_CALLBACK_ARGS;
d135 1
d146 1
a152 1
static void do_poponbell       PROTO_XT_CALLBACK_ARGS;
d205 4
d253 1
a253 1
    { "print-redirect",	do_print_redir,	NULL },
d264 3
d301 1
d304 1
a305 1
    { "marginbell",	do_marginbell,	NULL },
d415 14
a477 1
    Widget m;
d483 3
d504 20
a523 22
#if OPT_TOOLBAR
    m = list->w;
    if (m == 0) {
	return m;
    }
#else
    m = XtCreatePopupShell(data->internal_name,
			   simpleMenuWidgetClass,
			   toplevel,
			   NULL, 0);
    list->w = m;
#endif
    list->entries = nentries;

    for (; nentries > 0; nentries--, entries++) {
	cb[0].callback = (XtCallbackProc) entries->function;
	cb[0].closure = (caddr_t) entries->name;
	entries->widget = XtCreateManagedWidget(entries->name,
						(entries->function ?
						 smeBSBObjectClass :
						 smeLineObjectClass), m,
						&arg, (Cardinal) 1);
d525 3
d530 1
a530 1
    return m;
a557 4
/*
 * public interfaces
 */

d560 1
a560 1
domenu(Widget w GCC_UNUSED,
d565 1
a565 1
    TScreen *screen = &term->screen;
d604 6
d658 1
d662 1
a662 1
	    update_marginbell();
d667 1
a667 1
	    if (!screen->fnt_icon || !screen->iconVwin.window) {
d690 1
a690 1
				  (screen->menu_font_names[fontMenu_fontescape]
d733 2
a734 2
	if (created) {
	    set_tekfont_menu_item(screen->cur.fontsize, True);
d739 1
d747 4
d786 1
a786 1
    TScreen *screen = &term->screen;
d804 1
a804 1
    TScreen *screen = &term->screen;
d812 1
a812 1
	if (XGrabKeyboard(screen->display, XtWindow(CURRENT_EMU(screen)),
d849 1
a849 1
    TScreen *screen = &term->screen;
d860 1
a860 1
    TScreen *screen = &term->screen;
d867 11
d882 1
a882 1
    TScreen *screen = &term->screen;
d894 1
a894 1
    TScreen *screen = &term->screen;
d970 1
a970 1
    term->screen.input_eight_bits = !term->screen.input_eight_bits;
d1047 10
d1125 1
a1125 1
    Cleanup(0);
d1145 1
a1145 1
    TScreen *screen = &term->screen;
d1216 1
a1216 1
    TScreen *screen = &term->screen;
d1227 1
a1227 1
    TScreen *screen = &term->screen;
d1234 11
d1249 1
a1249 1
    TScreen *screen = &term->screen;
d1260 1
a1260 1
    TScreen *screen = &term->screen;
d1271 1
a1271 1
    TScreen *screen = &term->screen;
d1282 1
a1282 1
    TScreen *screen = &term->screen;
d1293 1
a1293 1
    TScreen *screen = &term->screen;
d1296 1
a1296 1
    if (!screen->Tshow) {	/* not showing, turn on */
d1331 1
a1331 1
    TScreen *screen = &term->screen;
d1362 1
a1362 1
    TScreen *screen = &term->screen;
d1405 1
a1405 3
    TScreen *screen = &term->screen;

    switch_modes(screen->TekEmu);	/* switch to tek mode */
d1481 1
a1481 1
    TScreen *screen = &term->screen;
d1500 1
a1500 1
    TScreen *screen = &term->screen;
d1509 1
a1509 1
		SetVTFont(term, screen->menu_font_number, TRUE, NULL);
d1528 1
a1528 1
    TScreen *screen = &term->screen;
d1545 1
a1545 1
    TekSetFontSize(tekMenu_tektextlarge);
d1553 1
a1553 1
    TekSetFontSize(tekMenu_tektext2);
d1561 1
a1561 1
    TekSetFontSize(tekMenu_tektext3);
d1569 1
a1569 2

    TekSetFontSize(tekMenu_tektextsmall);
d1577 1
a1577 1
    TekSimulatePageButton(False);
d1585 1
a1585 1
    TekSimulatePageButton(True);
d1593 1
a1593 1
    TekCopy();
d1599 1
a1599 1
    TScreen *screen = &term->screen;
d1604 1
a1604 1
    } else if (screen->Tshow || allowswitch) {	/* is showing, turn off */
d1606 2
a1607 2
	if (!screen->TekEmu && TekRefresh)
	    dorefresh();
d1634 1
a1634 3
    TScreen *screen = &term->screen;

    switch_modes(screen->TekEmu);	/* switch to vt, or from */
d1980 10
d2100 10
d2265 1
a2265 1
	    if (term->screen.TekEmu)
d2270 1
a2270 1
	    if (!term->screen.TekEmu)
d2296 1
a2296 1
	    handle_tek_toggle(do_tekonoff, (int) term->screen.Tshow,
d2321 2
a2322 3
	switch (params[0][0]) {
	case 'l':
	case 'L':
d2325 1
a2325 1
	case '2':
d2328 1
a2328 1
	case '3':
d2331 1
a2331 2
	case 's':
	case 'S':
d2375 7
a2381 1
UpdateMenuItem(Widget mi, XtArgVal val)
d2385 1
d2393 1
d2396 6
d2446 1
d2479 1
d2488 1
a2488 1
    Dimension button_height;
a2489 1
    Dimension toolbar_border;
a2534 1
		  XtNborderWidth, &toolbar_border,
d2554 3
a2556 3
    *menu_high = (button_height + 2 * (toolbar_hSpace + toolbar_border));
    TRACE(("...menuHeight:%d = (%d + 2 * (%d + %d))\n",
	   *menu_high, button_height, toolbar_hSpace, toolbar_border));
d2558 1
a2558 1
#else
d2571 1
a2571 1
    TScreen *screen = &term->screen;
d2574 1
a2574 1
	bzero(&term->hints, sizeof(term->hints));
d2624 2
d2743 3
a2745 1
    UpdateMenuItem(mainMenuEntries[mainMenu_toolbar].widget,
d2753 3
a2755 1
    UpdateMenuItem(mainMenuEntries[mainMenu_securekbd].widget,
d2762 3
a2764 1
    UpdateMenuItem(mainMenuEntries[mainMenu_allowsends].widget,
d2772 3
a2774 1
    UpdateMenuItem(mainMenuEntries[mainMenu_logging].widget,
d2782 3
a2784 1
    UpdateMenuItem(mainMenuEntries[mainMenu_print_redir].widget,
d2791 3
a2793 1
    UpdateMenuItem(mainMenuEntries[mainMenu_8bit_ctrl].widget,
d2800 3
a2802 1
    UpdateMenuItem(mainMenuEntries[mainMenu_backarrow].widget,
d2810 3
a2812 1
    UpdateMenuItem(mainMenuEntries[mainMenu_num_lock].widget,
d2819 4
a2822 2
    UpdateMenuItem(mainMenuEntries[mainMenu_alt_esc].widget,
		   !term->screen.input_eight_bits);
d2828 3
a2830 1
    UpdateMenuItem(mainMenuEntries[mainMenu_meta_esc].widget,
d2839 3
a2841 1
    UpdateMenuItem(mainMenuEntries[mainMenu_sun_fkeys].widget,
d2846 11
d2860 3
a2862 1
    UpdateMenuItem(mainMenuEntries[mainMenu_old_fkeys].widget,
d2869 3
a2871 1
    UpdateMenuItem(mainMenuEntries[mainMenu_delete_del].widget,
d2879 3
a2881 1
    UpdateMenuItem(mainMenuEntries[mainMenu_sun_kbd].widget,
d2890 3
a2892 1
    UpdateMenuItem(mainMenuEntries[mainMenu_hp_fkeys].widget,
d2901 3
a2903 1
    UpdateMenuItem(mainMenuEntries[mainMenu_sco_fkeys].widget,
d2911 4
a2914 2
    UpdateMenuItem(vtMenuEntries[vtMenu_scrollbar].widget,
		   ScrollbarWidth(&term->screen));
d2920 3
a2922 1
    UpdateMenuItem(vtMenuEntries[vtMenu_jumpscroll].widget,
d2929 3
a2931 1
    UpdateMenuItem(vtMenuEntries[vtMenu_reversevideo].widget,
d2938 3
a2940 1
    UpdateMenuItem(vtMenuEntries[vtMenu_autowrap].widget,
d2947 3
a2949 1
    UpdateMenuItem(vtMenuEntries[vtMenu_reversewrap].widget,
d2956 3
a2958 1
    UpdateMenuItem(vtMenuEntries[vtMenu_autolinefeed].widget,
d2965 3
a2967 1
    UpdateMenuItem(vtMenuEntries[vtMenu_appcursor].widget,
d2974 3
a2976 1
    UpdateMenuItem(vtMenuEntries[vtMenu_appkeypad].widget,
d2983 3
a2985 1
    UpdateMenuItem(vtMenuEntries[vtMenu_scrollkey].widget,
d2992 3
a2994 1
    UpdateMenuItem(vtMenuEntries[vtMenu_scrollttyoutput].widget,
d2999 9
d3010 3
a3012 1
    UpdateMenuItem(vtMenuEntries[vtMenu_selectToClipboard].widget,
d3019 3
a3021 1
    UpdateMenuItem(vtMenuEntries[vtMenu_allow132].widget,
d3029 1
a3029 1
    UpdateMenuItem(vtMenuEntries[vtMenu_cursesemul].widget,
d3037 3
a3039 1
    UpdateMenuItem(vtMenuEntries[vtMenu_visualbell].widget,
d3044 9
d3055 3
a3057 1
    UpdateMenuItem(vtMenuEntries[vtMenu_poponbell].widget,
d3061 1
d3065 3
a3067 1
    UpdateMenuItem(vtMenuEntries[vtMenu_marginbell].widget,
d3070 1
d3076 3
a3078 1
    UpdateMenuItem(vtMenuEntries[vtMenu_cursorblink].widget,
d3086 3
a3088 1
    UpdateMenuItem(vtMenuEntries[vtMenu_altscreen].widget,
d3095 3
a3097 1
    UpdateMenuItem(vtMenuEntries[vtMenu_titeInhibit].widget,
d3105 3
a3107 1
    UpdateMenuItem(vtMenuEntries[vtMenu_activeicon].widget,
d3116 3
a3118 1
    UpdateMenuItem(fontMenuEntries[fontMenu_font_doublesize].widget,
d3127 3
a3129 1
    UpdateMenuItem(fontMenuEntries[fontMenu_font_boxchars].widget,
d3138 3
a3140 1
    UpdateMenuItem(fontMenuEntries[fontMenu_font_loadable].widget,
d3149 3
a3151 1
    UpdateMenuItem(fontMenuEntries[fontMenu_render_font].widget,
a3159 1
    Widget iw = fontMenuEntries[fontMenu_wide_chars].widget;
d3164 5
a3168 2
    SetItemSensitivity(iw, active);
    UpdateMenuItem(iw, enable);
a3173 1
    Widget iw = fontMenuEntries[fontMenu_wide_title].widget;
d3178 5
a3182 2
    SetItemSensitivity(iw, active);
    UpdateMenuItem(iw, enable);
d3191 4
a3194 2
	UpdateMenuItem(vtMenuEntries[vtMenu_tekshow].widget,
		       term->screen.Tshow);
d3202 8
a3209 4
	UpdateMenuItem(vtMenuEntries[vtMenu_tekmode].widget,
		       term->screen.TekEmu);
	UpdateMenuItem(tekMenuEntries[tekMenu_vtmode].widget,
		       !term->screen.TekEmu);
d3217 3
a3219 1
	UpdateMenuItem(tekMenuEntries[tekMenu_vtshow].widget,
d3230 1
a3230 1
			      term->screen.Tshow);
d3248 1
a3248 1
	UpdateMenuItem(tekMenuEntries[FS2MI(n)].widget,
d3257 3
a3259 1
    UpdateMenuItem(fontMenuEntries[term->screen.menu_font_number].widget,
@


1.1.1.1
log
@Importing xterm 216
@
text
@@


1.1.1.2
log
@import xterm 225
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.232 2007/03/18 23:05:54 tom Exp $ */
d5 1
a5 1
Copyright 1999-2006,2007 by Thomas E. Dickey
a54 3
#include <xstrings.h>

#include <locale.h>
a123 1
static void do_bellIsUrgent    PROTO_XT_CALLBACK_ARGS;
d131 1
a132 1
static void do_poponbell       PROTO_XT_CALLBACK_ARGS;
d149 1
a201 4
#if OPT_TCAP_FKEYS
static void do_tcap_fkeys      PROTO_XT_CALLBACK_ARGS;
#endif

d246 1
a246 1
    { "print-redir",	do_print_redir,	NULL },
a256 3
#if OPT_TCAP_FKEYS
    { "tcapFunctionKeys",do_tcap_fkeys,	NULL },
#endif
a292 1
    { "bellIsUrgent",	do_bellIsUrgent, NULL },
d294 1
a403 14
static String
setMenuLocale(Boolean before, String substitute)
{
    String result;

    result = setlocale(LC_CTYPE, substitute);
    if (before) {
	result = x_strdup(result);
    } else {
	result = 0;
    }
    return result;
}

d453 1
a458 3
#if !OPT_TOOLBAR
    String saveLocale;
#endif
d477 22
a498 20
#if !OPT_TOOLBAR
    saveLocale = setMenuLocale(True, resource.menuLocale);
    list->w = XtCreatePopupShell(data->internal_name,
				 simpleMenuWidgetClass,
				 toplevel,
				 NULL, 0);
#endif
    if (list->w != 0) {
	list->entries = nentries;

	for (; nentries > 0; nentries--, entries++) {
	    cb[0].callback = (XtCallbackProc) entries->function;
	    cb[0].closure = (caddr_t) entries->name;
	    entries->widget = XtCreateManagedWidget(entries->name,
						    (entries->function
						     ? smeBSBObjectClass
						     : smeLineObjectClass),
						    list->w,
						    &arg, (Cardinal) 1);
	}
a499 3
#if !OPT_TOOLBAR
    (void) setMenuLocale(False, saveLocale);
#endif
d502 1
a502 1
    return list->w;
d530 4
d536 1
a536 1
domenu(Widget w,
d541 1
a541 1
    TScreen *screen = TScreenOf(term);
a579 6
#if OPT_NUM_LOCK
	    if (!screen->alt_is_not_meta) {
		SetItemSensitivity(mainMenuEntries[mainMenu_alt_esc].widget,
				   False);
	    }
#endif
d659 1
a659 1
				  (screen->menu_font_names[fontMenu_fontescape][fNorm]
d703 1
a703 1
	    set_tekfont_menu_item(tekWidget->screen.cur.fontsize, True);
a714 4
/*
 * public interfaces
 */

d750 1
a750 1
    TScreen *screen = TScreenOf(term);
d768 1
a768 1
    TScreen *screen = TScreenOf(term);
d776 1
a776 1
	if (XGrabKeyboard(screen->display, XtWindow(CURRENT_EMU()),
d813 1
a813 1
    TScreen *screen = TScreenOf(term);
d824 1
a824 1
    TScreen *screen = TScreenOf(term);
a830 11
do_bellIsUrgent(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    screen->bellIsUrgent = !screen->bellIsUrgent;
    update_bellIsUrgent();
}

static void
d835 1
a835 1
    TScreen *screen = TScreenOf(term);
d847 1
a847 1
    TScreen *screen = TScreenOf(term);
d923 1
a923 1
    term->screen.alt_sends_esc = !term->screen.alt_sends_esc;
a999 10
#if OPT_TCAP_FKEYS
static void
do_tcap_fkeys(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(term, keyboardIsTermcap);
}
#endif

d1088 1
a1088 1
    TScreen *screen = TScreenOf(term);
d1159 1
a1159 1
    TScreen *screen = TScreenOf(term);
d1170 1
a1170 1
    TScreen *screen = TScreenOf(term);
d1181 1
a1181 1
    TScreen *screen = TScreenOf(term);
d1192 1
a1192 1
    TScreen *screen = TScreenOf(term);
d1203 1
a1203 1
    TScreen *screen = TScreenOf(term);
d1214 1
a1214 1
    TScreen *screen = TScreenOf(term);
d1225 1
a1225 1
    TScreen *screen = TScreenOf(term);
d1228 1
a1228 1
    if (!TEK4014_SHOWN(term)) {	/* not showing, turn on */
d1263 1
a1263 1
    TScreen *screen = TScreenOf(term);
d1294 1
a1294 1
    TScreen *screen = TScreenOf(term);
d1337 3
a1339 1
    switch_modes(TEK4014_ACTIVE(term));		/* switch to tek mode */
d1415 1
a1415 1
    TScreen *screen = TScreenOf(term);
d1434 1
a1434 1
    TScreen *screen = TScreenOf(term);
d1443 1
a1443 1
		SetVTFont(term, screen->menu_font_number, True, NULL);
d1462 1
a1462 1
    TScreen *screen = TScreenOf(term);
d1479 1
a1479 1
    TekSetFontSize(tekWidget, tekMenu_tektextlarge);
d1487 1
a1487 1
    TekSetFontSize(tekWidget, tekMenu_tektext2);
d1495 1
a1495 1
    TekSetFontSize(tekWidget, tekMenu_tektext3);
d1503 2
a1504 1
    TekSetFontSize(tekWidget, tekMenu_tektextsmall);
d1512 1
a1512 1
    TekSimulatePageButton(tekWidget, False);
d1520 1
a1520 1
    TekSimulatePageButton(tekWidget, True);
d1528 1
a1528 1
    TekCopy(tekWidget);
d1534 1
a1534 1
    TScreen *screen = TScreenOf(term);
d1539 1
a1539 1
    } else if (TEK4014_SHOWN(term) || allowswitch) {	/* is showing, turn off */
d1541 2
a1542 2
	if (!TEK4014_ACTIVE(term) && tekRefreshList)
	    TekRefresh(tekWidget);
d1569 3
a1571 1
    switch_modes(TEK4014_ACTIVE(term));		/* switch to vt, or from */
a2026 10
HandleBellIsUrgent(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal *param_count)
{
    handle_vt_toggle(do_bellIsUrgent, term->screen.bellIsUrgent,
		     params, *param_count, w);
}

void
d2182 1
a2182 1
	    if (TEK4014_ACTIVE(term))
d2187 1
a2187 1
	    if (!TEK4014_ACTIVE(term))
d2213 1
a2213 1
	    handle_tek_toggle(do_tekonoff, (int) TEK4014_SHOWN(term),
d2238 3
a2240 2
	switch (TekGetFontSize(params[0])) {
	case TEK_FONT_LARGE:
d2243 1
a2243 1
	case TEK_FONT_2:
d2246 1
a2246 1
	case TEK_FONT_3:
d2249 2
a2250 1
	case TEK_FONT_SMALL:
a2350 1
    String saveLocale = setMenuLocale(True, resource.menuLocale);
a2382 1
    (void) setMenuLocale(True, saveLocale);
d2391 1
a2391 1
    Dimension button_height = 0;
d2463 1
a2463 1
#else /* !OPT_TOOLBAR */
d2476 1
a2476 1
    TScreen *screen = TScreenOf(term);
d2479 1
a2479 1
	getXtermSizeHints(term);
a2528 2
#else
    (void) w;
d2707 1
a2707 1
		   term->screen.alt_sends_esc);
a2726 9
#if OPT_TCAP_FKEYS
void
update_tcap_fkeys(void)
{
    UpdateMenuItem(mainMenuEntries[mainMenu_tcap_fkeys].widget,
		   term->keyboard.type == keyboardIsTermcap);
}
#endif

d2772 1
a2772 1
		   ScrollbarWidth(TScreenOf(term)));
a2868 7
update_bellIsUrgent(void)
{
    UpdateMenuItem(vtMenuEntries[vtMenu_bellIsUrgent].widget,
		   term->screen.bellIsUrgent);
}

void
a2874 1
#ifndef update_marginbell	/* 2007-3-7: no longer menu entry */
a2880 1
#endif
d2982 1
a2982 1
		       TEK4014_SHOWN(term));
d2991 1
a2991 1
		       TEK4014_ACTIVE(term));
d2993 1
a2993 1
		       !TEK4014_ACTIVE(term));
d3012 1
a3012 1
			      TEK4014_SHOWN(term));
@


1.1.1.3
log
@import xterm 229
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.237 2007/07/22 20:34:04 tom Exp $ */
d49 1
d415 1
a415 1
setMenuLocale(Bool before, String substitute)
d660 1
a660 1
	    update_bellIsUrgent();
d731 1
a731 1
	if (created && tekWidget) {
a736 1
    case noMenu:
d1122 1
a1122 1
    Cleanup(SIGHUP);
@


1.1.1.4
log
@Import xterm version 232. tested by many.
@
text
@d1 1
a1 1
/* $XTermId: menu.c,v 1.240 2008/01/20 15:16:43 tom Exp $ */
d5 1
a5 1
Copyright 1999-2007,2008 by Thomas E. Dickey
a145 1
static void do_keepSelection   PROTO_XT_CALLBACK_ARGS;
a299 1
    { "keepSelection",	do_keepSelection, NULL },
a655 1
	    update_keepSelection();
d664 1
a664 1
	    if (!screen->fnt_icon.fs || !screen->iconVwin.window) {
a1230 11
do_keepSelection(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
{
    TScreen *screen = TScreenOf(term);

    screen->keepSelection = !screen->keepSelection;
    update_keepSelection();
}

static void
a1965 10
HandleKeepSelection(Widget w,
		    XEvent * event GCC_UNUSED,
		    String * params,
		    Cardinal *param_count)
{
    handle_vt_toggle(do_keepSelection, term->screen.keepSelection,
		     params, *param_count, w);
}

void
d2351 1
a2351 7
UpdateMenuItem(
#if OPT_TRACE
		  const char *func,
#endif
		  MenuEntry * menu,
		  int which,
		  XtArgVal val)
a2354 1
    Widget mi = menu[which].widget;
a2361 1
    TRACE(("%s(%d): %s\n", func, which, BtoS(val)));
a2363 6
#if OPT_TRACE
#define UpdateCheckbox(func, mn, mi, val) UpdateMenuItem(func, mn, mi, val)
#else
#define UpdateCheckbox(func, mn, mi, val) UpdateMenuItem(mn, mi, val)
#endif

d2707 1
a2707 3
    UpdateCheckbox("update_toolbar",
		   mainMenuEntries,
		   mainMenu_toolbar,
d2715 1
a2715 3
    UpdateCheckbox("update_securekbd",
		   mainMenuEntries,
		   mainMenu_securekbd,
d2722 1
a2722 3
    UpdateCheckbox("update_allowsends",
		   mainMenuEntries,
		   mainMenu_allowsends,
d2730 1
a2730 3
    UpdateCheckbox("update_logging",
		   mainMenuEntries,
		   mainMenu_logging,
d2738 1
a2738 3
    UpdateCheckbox("update_print_redir",
		   mainMenuEntries,
		   mainMenu_print_redir,
d2745 1
a2745 3
    UpdateCheckbox("update_8bit_control",
		   mainMenuEntries,
		   mainMenu_8bit_ctrl,
d2752 1
a2752 3
    UpdateCheckbox("update_decbkm",
		   mainMenuEntries,
		   mainMenu_backarrow,
d2760 1
a2760 3
    UpdateCheckbox("update_num_lock",
		   mainMenuEntries,
		   mainMenu_num_lock,
d2767 1
a2767 3
    UpdateCheckbox("update_alt_esc",
		   mainMenuEntries,
		   mainMenu_alt_esc,
d2774 1
a2774 3
    UpdateCheckbox("update_meta_esc",
		   mainMenuEntries,
		   mainMenu_meta_esc,
d2783 1
a2783 3
    UpdateCheckbox("update_sun_fkeys",
		   mainMenuEntries,
		   mainMenu_sun_fkeys,
d2792 1
a2792 3
    UpdateCheckbox("update_tcap_fkeys",
		   mainMenuEntries,
		   mainMenu_tcap_fkeys,
d2800 1
a2800 3
    UpdateCheckbox("update_old_fkeys",
		   mainMenuEntries,
		   mainMenu_old_fkeys,
d2807 1
a2807 3
    UpdateCheckbox("update_delete_del",
		   mainMenuEntries,
		   mainMenu_delete_del,
d2815 1
a2815 3
    UpdateCheckbox("update_sun_kbd",
		   mainMenuEntries,
		   mainMenu_sun_kbd,
d2824 1
a2824 3
    UpdateCheckbox("update_hp_fkeys",
		   mainMenuEntries,
		   mainMenu_hp_fkeys,
d2833 1
a2833 3
    UpdateCheckbox("update_sco_fkeys",
		   mainMenuEntries,
		   mainMenu_sco_fkeys,
d2841 1
a2841 3
    UpdateCheckbox("update_scrollbar",
		   vtMenuEntries,
		   vtMenu_scrollbar,
d2848 1
a2848 3
    UpdateCheckbox("update_jumpscroll",
		   vtMenuEntries,
		   vtMenu_jumpscroll,
d2855 1
a2855 3
    UpdateCheckbox("update_reversevideo",
		   vtMenuEntries,
		   vtMenu_reversevideo,
d2862 1
a2862 3
    UpdateCheckbox("update_autowrap",
		   vtMenuEntries,
		   vtMenu_autowrap,
d2869 1
a2869 3
    UpdateCheckbox("update_reversewrap",
		   vtMenuEntries,
		   vtMenu_reversewrap,
d2876 1
a2876 3
    UpdateCheckbox("update_autolinefeed",
		   vtMenuEntries,
		   vtMenu_autolinefeed,
d2883 1
a2883 3
    UpdateCheckbox("update_appcursor",
		   vtMenuEntries,
		   vtMenu_appcursor,
d2890 1
a2890 3
    UpdateCheckbox("update_appkeypad",
		   vtMenuEntries,
		   vtMenu_appkeypad,
d2897 1
a2897 3
    UpdateCheckbox("update_scrollkey",
		   vtMenuEntries,
		   vtMenu_scrollkey,
d2904 1
a2904 3
    UpdateCheckbox("update_scrollttyoutput",
		   vtMenuEntries,
		   vtMenu_scrollttyoutput,
a2908 9
update_keepSelection(void)
{
    UpdateCheckbox("update_keepSelection",
		   vtMenuEntries,
		   vtMenu_keepSelection,
		   term->screen.keepSelection);
}

void
d2911 1
a2911 3
    UpdateCheckbox("update_selectToClipboard",
		   vtMenuEntries,
		   vtMenu_selectToClipboard,
d2918 1
a2918 3
    UpdateCheckbox("update_allow132",
		   vtMenuEntries,
		   vtMenu_allow132,
d2926 1
a2926 1
    UpdateMenuItem("update_cursesemul", vtMenuEntries, vtMenu_cursesemul,
d2934 1
a2934 3
    UpdateCheckbox("update_visualbell",
		   vtMenuEntries,
		   vtMenu_visualbell,
d2941 1
a2941 3
    UpdateCheckbox("update_bellIsUrgent",
		   vtMenuEntries,
		   vtMenu_bellIsUrgent,
d2948 1
a2948 3
    UpdateCheckbox("update_poponbell",
		   vtMenuEntries,
		   vtMenu_poponbell,
d2956 1
a2956 3
    UpdateCheckbox("update_marginbell",
		   vtMenuEntries,
		   vtMenu_marginbell,
d2965 1
a2965 3
    UpdateCheckbox("update_cursorblink",
		   vtMenuEntries,
		   vtMenu_cursorblink,
d2973 1
a2973 3
    UpdateCheckbox("update_altscreen",
		   vtMenuEntries,
		   vtMenu_altscreen,
d2980 1
a2980 3
    UpdateCheckbox("update_titeInhibit",
		   vtMenuEntries,
		   vtMenu_titeInhibit,
d2988 1
a2988 3
    UpdateCheckbox("update_activeicon",
		   vtMenuEntries,
		   vtMenu_activeicon,
d2997 1
a2997 3
    UpdateCheckbox("update_font_doublesize",
		   fontMenuEntries,
		   fontMenu_font_doublesize,
d3006 1
a3006 3
    UpdateCheckbox("update_font_boxchars",
		   fontMenuEntries,
		   fontMenu_font_boxchars,
d3015 1
a3015 3
    UpdateCheckbox("update_font_loadable",
		   fontMenuEntries,
		   fontMenu_font_loadable,
d3024 1
a3024 3
    UpdateCheckbox("update_font_renderfont",
		   fontMenuEntries,
		   fontMenu_render_font,
d3033 1
d3038 2
a3039 5
    SetItemSensitivity(fontMenuEntries[fontMenu_wide_chars].widget, active);
    UpdateCheckbox("update_font_utf8_mode",
		   fontMenuEntries,
		   fontMenu_wide_chars,
		   enable);
d3045 1
d3050 2
a3051 5
    SetItemSensitivity(fontMenuEntries[fontMenu_wide_title].widget, active);
    UpdateCheckbox("update_font_utf8_title",
		   fontMenuEntries,
		   fontMenu_wide_title,
		   enable);
d3060 1
a3060 3
	UpdateCheckbox("update_tekshow",
		       vtMenuEntries,
		       vtMenu_tekshow,
d3069 1
a3069 3
	UpdateCheckbox("update_vtmode",
		       vtMenuEntries,
		       vtMenu_tekmode,
d3071 1
a3071 3
	UpdateCheckbox("update_tekmode",
		       tekMenuEntries,
		       tekMenu_vtmode,
d3080 1
a3080 3
	UpdateCheckbox("update_vtshow",
		       tekMenuEntries,
		       tekMenu_vtshow,
d3109 1
a3109 1
	UpdateCheckbox("set_tekfont_menu_item", tekMenuEntries, FS2MI(n),
d3118 1
a3118 3
    UpdateCheckbox("set_menu_font",
		   fontMenuEntries,
		   term->screen.menu_font_number,
@


